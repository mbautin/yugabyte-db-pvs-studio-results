
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>basic_socket.hpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//</a>
<a name="ln2">// basic_socket.hpp</a>
<a name="ln3">// ~~~~~~~~~~~~~~~~</a>
<a name="ln4">//</a>
<a name="ln5">// Copyright (c) 2003-2018 Christopher M. Kohlhoff (chris at kohlhoff dot com)</a>
<a name="ln6">//</a>
<a name="ln7">// Distributed under the Boost Software License, Version 1.0. (See accompanying</a>
<a name="ln8">// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)</a>
<a name="ln9">//</a>
<a name="ln10"> </a>
<a name="ln11">#ifndef BOOST_ASIO_BASIC_SOCKET_HPP</a>
<a name="ln12">#define BOOST_ASIO_BASIC_SOCKET_HPP</a>
<a name="ln13"> </a>
<a name="ln14">#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1200)</a>
<a name="ln15"># pragma once</a>
<a name="ln16">#endif // defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1200)</a>
<a name="ln17"> </a>
<a name="ln18">#include &lt;boost/asio/detail/config.hpp&gt;</a>
<a name="ln19">#include &lt;boost/asio/async_result.hpp&gt;</a>
<a name="ln20">#include &lt;boost/asio/basic_io_object.hpp&gt;</a>
<a name="ln21">#include &lt;boost/asio/detail/handler_type_requirements.hpp&gt;</a>
<a name="ln22">#include &lt;boost/asio/detail/throw_error.hpp&gt;</a>
<a name="ln23">#include &lt;boost/asio/detail/type_traits.hpp&gt;</a>
<a name="ln24">#include &lt;boost/asio/error.hpp&gt;</a>
<a name="ln25">#include &lt;boost/asio/post.hpp&gt;</a>
<a name="ln26">#include &lt;boost/asio/socket_base.hpp&gt;</a>
<a name="ln27"> </a>
<a name="ln28">#if defined(BOOST_ASIO_HAS_MOVE)</a>
<a name="ln29"># include &lt;utility&gt;</a>
<a name="ln30">#endif // defined(BOOST_ASIO_HAS_MOVE)</a>
<a name="ln31"> </a>
<a name="ln32">#if !defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln33"># if defined(BOOST_ASIO_WINDOWS_RUNTIME)</a>
<a name="ln34">#  include &lt;boost/asio/detail/winrt_ssocket_service.hpp&gt;</a>
<a name="ln35">#  define BOOST_ASIO_SVC_T detail::winrt_ssocket_service&lt;Protocol&gt;</a>
<a name="ln36"># elif defined(BOOST_ASIO_HAS_IOCP)</a>
<a name="ln37">#  include &lt;boost/asio/detail/win_iocp_socket_service.hpp&gt;</a>
<a name="ln38">#  define BOOST_ASIO_SVC_T detail::win_iocp_socket_service&lt;Protocol&gt;</a>
<a name="ln39"># else</a>
<a name="ln40">#  include &lt;boost/asio/detail/reactive_socket_service.hpp&gt;</a>
<a name="ln41">#  define BOOST_ASIO_SVC_T detail::reactive_socket_service&lt;Protocol&gt;</a>
<a name="ln42"># endif</a>
<a name="ln43">#endif // !defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln44"> </a>
<a name="ln45">#include &lt;boost/asio/detail/push_options.hpp&gt;</a>
<a name="ln46"> </a>
<a name="ln47">namespace boost {</a>
<a name="ln48">namespace asio {</a>
<a name="ln49"> </a>
<a name="ln50">/// Provides socket functionality.</a>
<a name="ln51">/**</a>
<a name="ln52"> * The basic_socket class template provides functionality that is common to both</a>
<a name="ln53"> * stream-oriented and datagram-oriented sockets.</a>
<a name="ln54"> *</a>
<a name="ln55"> * @par Thread Safety</a>
<a name="ln56"> * @e Distinct @e objects: Safe.@n</a>
<a name="ln57"> * @e Shared @e objects: Unsafe.</a>
<a name="ln58"> */</a>
<a name="ln59">template &lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt;</a>
<a name="ln60">class basic_socket</a>
<a name="ln61">  : BOOST_ASIO_SVC_ACCESS basic_io_object&lt;BOOST_ASIO_SVC_T&gt;,</a>
<a name="ln62">    public socket_base</a>
<a name="ln63">{</a>
<a name="ln64">public:</a>
<a name="ln65">  /// The type of the executor associated with the object.</a>
<a name="ln66">  typedef io_context::executor_type executor_type;</a>
<a name="ln67"> </a>
<a name="ln68">  /// The native representation of a socket.</a>
<a name="ln69">#if defined(GENERATING_DOCUMENTATION)</a>
<a name="ln70">  typedef implementation_defined native_handle_type;</a>
<a name="ln71">#else</a>
<a name="ln72">  typedef typename BOOST_ASIO_SVC_T::native_handle_type native_handle_type;</a>
<a name="ln73">#endif</a>
<a name="ln74"> </a>
<a name="ln75">  /// The protocol type.</a>
<a name="ln76">  typedef Protocol protocol_type;</a>
<a name="ln77"> </a>
<a name="ln78">  /// The endpoint type.</a>
<a name="ln79">  typedef typename Protocol::endpoint endpoint_type;</a>
<a name="ln80"> </a>
<a name="ln81">#if !defined(BOOST_ASIO_NO_EXTENSIONS)</a>
<a name="ln82">  /// A basic_socket is always the lowest layer.</a>
<a name="ln83">  typedef basic_socket&lt;Protocol BOOST_ASIO_SVC_TARG&gt; lowest_layer_type;</a>
<a name="ln84">#endif // !defined(BOOST_ASIO_NO_EXTENSIONS)</a>
<a name="ln85"> </a>
<a name="ln86">  /// Construct a basic_socket without opening it.</a>
<a name="ln87">  /**</a>
<a name="ln88">   * This constructor creates a socket without opening it.</a>
<a name="ln89">   *</a>
<a name="ln90">   * @param io_context The io_context object that the socket will use to</a>
<a name="ln91">   * dispatch handlers for any asynchronous operations performed on the socket.</a>
<a name="ln92">   */</a>
<a name="ln93">  explicit basic_socket(boost::asio::io_context&amp; io_context)</a>
<a name="ln94">    : basic_io_object&lt;BOOST_ASIO_SVC_T&gt;(io_context)</a>
<a name="ln95">  {</a>
<a name="ln96">  }</a>
<a name="ln97"> </a>
<a name="ln98">  /// Construct and open a basic_socket.</a>
<a name="ln99">  /**</a>
<a name="ln100">   * This constructor creates and opens a socket.</a>
<a name="ln101">   *</a>
<a name="ln102">   * @param io_context The io_context object that the socket will use to</a>
<a name="ln103">   * dispatch handlers for any asynchronous operations performed on the socket.</a>
<a name="ln104">   *</a>
<a name="ln105">   * @param protocol An object specifying protocol parameters to be used.</a>
<a name="ln106">   *</a>
<a name="ln107">   * @throws boost::system::system_error Thrown on failure.</a>
<a name="ln108">   */</a>
<a name="ln109">  basic_socket(boost::asio::io_context&amp; io_context,</a>
<a name="ln110">      const protocol_type&amp; protocol)</a>
<a name="ln111">    : basic_io_object&lt;BOOST_ASIO_SVC_T&gt;(io_context)</a>
<a name="ln112">  {</a>
<a name="ln113">    boost::system::error_code ec;</a>
<a name="ln114">    this-&gt;get_service().open(this-&gt;get_implementation(), protocol, ec);</a>
<a name="ln115">    boost::asio::detail::throw_error(ec, &quot;open&quot;);</a>
<a name="ln116">  }</a>
<a name="ln117"> </a>
<a name="ln118">  /// Construct a basic_socket, opening it and binding it to the given local</a>
<a name="ln119">  /// endpoint.</a>
<a name="ln120">  /**</a>
<a name="ln121">   * This constructor creates a socket and automatically opens it bound to the</a>
<a name="ln122">   * specified endpoint on the local machine. The protocol used is the protocol</a>
<a name="ln123">   * associated with the given endpoint.</a>
<a name="ln124">   *</a>
<a name="ln125">   * @param io_context The io_context object that the socket will use to</a>
<a name="ln126">   * dispatch handlers for any asynchronous operations performed on the socket.</a>
<a name="ln127">   *</a>
<a name="ln128">   * @param endpoint An endpoint on the local machine to which the socket will</a>
<a name="ln129">   * be bound.</a>
<a name="ln130">   *</a>
<a name="ln131">   * @throws boost::system::system_error Thrown on failure.</a>
<a name="ln132">   */</a>
<a name="ln133">  basic_socket(boost::asio::io_context&amp; io_context,</a>
<a name="ln134">      const endpoint_type&amp; endpoint)</a>
<a name="ln135">    : basic_io_object&lt;BOOST_ASIO_SVC_T&gt;(io_context)</a>
<a name="ln136">  {</a>
<a name="ln137">    boost::system::error_code ec;</a>
<a name="ln138">    const protocol_type protocol = endpoint.protocol();</a>
<a name="ln139">    this-&gt;get_service().open(this-&gt;get_implementation(), protocol, ec);</a>
<a name="ln140">    boost::asio::detail::throw_error(ec, &quot;open&quot;);</a>
<a name="ln141">    this-&gt;get_service().bind(this-&gt;get_implementation(), endpoint, ec);</a>
<a name="ln142">    boost::asio::detail::throw_error(ec, &quot;bind&quot;);</a>
<a name="ln143">  }</a>
<a name="ln144"> </a>
<a name="ln145">  /// Construct a basic_socket on an existing native socket.</a>
<a name="ln146">  /**</a>
<a name="ln147">   * This constructor creates a socket object to hold an existing native socket.</a>
<a name="ln148">   *</a>
<a name="ln149">   * @param io_context The io_context object that the socket will use to</a>
<a name="ln150">   * dispatch handlers for any asynchronous operations performed on the socket.</a>
<a name="ln151">   *</a>
<a name="ln152">   * @param protocol An object specifying protocol parameters to be used.</a>
<a name="ln153">   *</a>
<a name="ln154">   * @param native_socket A native socket.</a>
<a name="ln155">   *</a>
<a name="ln156">   * @throws boost::system::system_error Thrown on failure.</a>
<a name="ln157">   */</a>
<a name="ln158">  basic_socket(boost::asio::io_context&amp; io_context,</a>
<a name="ln159">      const protocol_type&amp; protocol, const native_handle_type&amp; native_socket)</a>
<a name="ln160">    : basic_io_object&lt;BOOST_ASIO_SVC_T&gt;(io_context)</a>
<a name="ln161">  {</a>
<a name="ln162">    boost::system::error_code ec;</a>
<a name="ln163">    this-&gt;get_service().assign(this-&gt;get_implementation(),</a>
<a name="ln164">        protocol, native_socket, ec);</a>
<a name="ln165">    boost::asio::detail::throw_error(ec, &quot;assign&quot;);</a>
<a name="ln166">  }</a>
<a name="ln167"> </a>
<a name="ln168">#if defined(BOOST_ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)</a>
<a name="ln169">  /// Move-construct a basic_socket from another.</a>
<a name="ln170">  /**</a>
<a name="ln171">   * This constructor moves a socket from one object to another.</a>
<a name="ln172">   *</a>
<a name="ln173">   * @param other The other basic_socket object from which the move will</a>
<a name="ln174">   * occur.</a>
<a name="ln175">   *</a>
<a name="ln176">   * @note Following the move, the moved-from object is in the same state as if</a>
<a name="ln177">   * constructed using the @c basic_socket(io_context&amp;) constructor.</a>
<a name="ln178">   */</a>
<a name="ln179">  basic_socket(basic_socket&amp;&amp; other)</a>
<a name="ln180">    : basic_io_object&lt;BOOST_ASIO_SVC_T&gt;(std::move(other))</a>
<a name="ln181">  {</a>
<a name="ln182">  }</a>
<a name="ln183"> </a>
<a name="ln184">  /// Move-assign a basic_socket from another.</a>
<a name="ln185">  /**</a>
<a name="ln186">   * This assignment operator moves a socket from one object to another.</a>
<a name="ln187">   *</a>
<a name="ln188">   * @param other The other basic_socket object from which the move will</a>
<a name="ln189">   * occur.</a>
<a name="ln190">   *</a>
<a name="ln191">   * @note Following the move, the moved-from object is in the same state as if</a>
<a name="ln192">   * constructed using the @c basic_socket(io_context&amp;) constructor.</a>
<a name="ln193">   */</a>
<a name="ln194">  basic_socket&amp; operator=(basic_socket&amp;&amp; other)</a>
<a name="ln195">  {</a>
<a name="ln196">    basic_io_object&lt;BOOST_ASIO_SVC_T&gt;::operator=(std::move(other));</a>
<a name="ln197">    return *this;</a>
<a name="ln198">  }</a>
<a name="ln199"> </a>
<a name="ln200">  // All sockets have access to each other's implementations.</a>
<a name="ln201">  template &lt;typename Protocol1 BOOST_ASIO_SVC_TPARAM1&gt;</a>
<a name="ln202">  friend class basic_socket;</a>
<a name="ln203"> </a>
<a name="ln204">  /// Move-construct a basic_socket from a socket of another protocol type.</a>
<a name="ln205">  /**</a>
<a name="ln206">   * This constructor moves a socket from one object to another.</a>
<a name="ln207">   *</a>
<a name="ln208">   * @param other The other basic_socket object from which the move will</a>
<a name="ln209">   * occur.</a>
<a name="ln210">   *</a>
<a name="ln211">   * @note Following the move, the moved-from object is in the same state as if</a>
<a name="ln212">   * constructed using the @c basic_socket(io_context&amp;) constructor.</a>
<a name="ln213">   */</a>
<a name="ln214">  template &lt;typename Protocol1 BOOST_ASIO_SVC_TPARAM1&gt;</a>
<a name="ln215">  basic_socket(basic_socket&lt;Protocol1 BOOST_ASIO_SVC_TARG1&gt;&amp;&amp; other,</a>
<a name="ln216">      typename enable_if&lt;is_convertible&lt;Protocol1, Protocol&gt;::value&gt;::type* = 0)</a>
<a name="ln217">    : basic_io_object&lt;BOOST_ASIO_SVC_T&gt;(</a>
<a name="ln218">        other.get_service(), other.get_implementation())</a>
<a name="ln219">  {</a>
<a name="ln220">  }</a>
<a name="ln221"> </a>
<a name="ln222">  /// Move-assign a basic_socket from a socket of another protocol type.</a>
<a name="ln223">  /**</a>
<a name="ln224">   * This assignment operator moves a socket from one object to another.</a>
<a name="ln225">   *</a>
<a name="ln226">   * @param other The other basic_socket object from which the move will</a>
<a name="ln227">   * occur.</a>
<a name="ln228">   *</a>
<a name="ln229">   * @note Following the move, the moved-from object is in the same state as if</a>
<a name="ln230">   * constructed using the @c basic_socket(io_context&amp;) constructor.</a>
<a name="ln231">   */</a>
<a name="ln232">  template &lt;typename Protocol1 BOOST_ASIO_SVC_TPARAM1&gt;</a>
<a name="ln233">  typename enable_if&lt;is_convertible&lt;Protocol1, Protocol&gt;::value,</a>
<a name="ln234">      basic_socket&gt;::type&amp; operator=(</a>
<a name="ln235">        basic_socket&lt;Protocol1 BOOST_ASIO_SVC_TARG1&gt;&amp;&amp; other)</a>
<a name="ln236">  {</a>
<a name="ln237">    basic_socket tmp(std::move(other));</a>
<a name="ln238">    basic_io_object&lt;BOOST_ASIO_SVC_T&gt;::operator=(std::move(tmp));</a>
<a name="ln239">    return *this;</a>
<a name="ln240">  }</a>
<a name="ln241">#endif // defined(BOOST_ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)</a>
<a name="ln242"> </a>
<a name="ln243">#if defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln244">  // These functions are provided by basic_io_object&lt;&gt;.</a>
<a name="ln245">#else // defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln246">#if !defined(BOOST_ASIO_NO_DEPRECATED)</a>
<a name="ln247">  /// (Deprecated: Use get_executor().) Get the io_context associated with the</a>
<a name="ln248">  /// object.</a>
<a name="ln249">  /**</a>
<a name="ln250">   * This function may be used to obtain the io_context object that the I/O</a>
<a name="ln251">   * object uses to dispatch handlers for asynchronous operations.</a>
<a name="ln252">   *</a>
<a name="ln253">   * @return A reference to the io_context object that the I/O object will use</a>
<a name="ln254">   * to dispatch handlers. Ownership is not transferred to the caller.</a>
<a name="ln255">   */</a>
<a name="ln256">  boost::asio::io_context&amp; get_io_context()</a>
<a name="ln257">  {</a>
<a name="ln258">    return basic_io_object&lt;BOOST_ASIO_SVC_T&gt;::get_io_context();</a>
<a name="ln259">  }</a>
<a name="ln260"> </a>
<a name="ln261">  /// (Deprecated: Use get_executor().) Get the io_context associated with the</a>
<a name="ln262">  /// object.</a>
<a name="ln263">  /**</a>
<a name="ln264">   * This function may be used to obtain the io_context object that the I/O</a>
<a name="ln265">   * object uses to dispatch handlers for asynchronous operations.</a>
<a name="ln266">   *</a>
<a name="ln267">   * @return A reference to the io_context object that the I/O object will use</a>
<a name="ln268">   * to dispatch handlers. Ownership is not transferred to the caller.</a>
<a name="ln269">   */</a>
<a name="ln270">  boost::asio::io_context&amp; get_io_service()</a>
<a name="ln271">  {</a>
<a name="ln272">    return basic_io_object&lt;BOOST_ASIO_SVC_T&gt;::get_io_service();</a>
<a name="ln273">  }</a>
<a name="ln274">#endif // !defined(BOOST_ASIO_NO_DEPRECATED)</a>
<a name="ln275"> </a>
<a name="ln276">  /// Get the executor associated with the object.</a>
<a name="ln277">  executor_type get_executor() BOOST_ASIO_NOEXCEPT</a>
<a name="ln278">  {</a>
<a name="ln279">    return basic_io_object&lt;BOOST_ASIO_SVC_T&gt;::get_executor();</a>
<a name="ln280">  }</a>
<a name="ln281">#endif // defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln282"> </a>
<a name="ln283">#if !defined(BOOST_ASIO_NO_EXTENSIONS)</a>
<a name="ln284">  /// Get a reference to the lowest layer.</a>
<a name="ln285">  /**</a>
<a name="ln286">   * This function returns a reference to the lowest layer in a stack of</a>
<a name="ln287">   * layers. Since a basic_socket cannot contain any further layers, it simply</a>
<a name="ln288">   * returns a reference to itself.</a>
<a name="ln289">   *</a>
<a name="ln290">   * @return A reference to the lowest layer in the stack of layers. Ownership</a>
<a name="ln291">   * is not transferred to the caller.</a>
<a name="ln292">   */</a>
<a name="ln293">  lowest_layer_type&amp; lowest_layer()</a>
<a name="ln294">  {</a>
<a name="ln295">    return *this;</a>
<a name="ln296">  }</a>
<a name="ln297"> </a>
<a name="ln298">  /// Get a const reference to the lowest layer.</a>
<a name="ln299">  /**</a>
<a name="ln300">   * This function returns a const reference to the lowest layer in a stack of</a>
<a name="ln301">   * layers. Since a basic_socket cannot contain any further layers, it simply</a>
<a name="ln302">   * returns a reference to itself.</a>
<a name="ln303">   *</a>
<a name="ln304">   * @return A const reference to the lowest layer in the stack of layers.</a>
<a name="ln305">   * Ownership is not transferred to the caller.</a>
<a name="ln306">   */</a>
<a name="ln307">  const lowest_layer_type&amp; lowest_layer() const</a>
<a name="ln308">  {</a>
<a name="ln309">    return *this;</a>
<a name="ln310">  }</a>
<a name="ln311">#endif // !defined(BOOST_ASIO_NO_EXTENSIONS)</a>
<a name="ln312"> </a>
<a name="ln313">  /// Open the socket using the specified protocol.</a>
<a name="ln314">  /**</a>
<a name="ln315">   * This function opens the socket so that it will use the specified protocol.</a>
<a name="ln316">   *</a>
<a name="ln317">   * @param protocol An object specifying protocol parameters to be used.</a>
<a name="ln318">   *</a>
<a name="ln319">   * @throws boost::system::system_error Thrown on failure.</a>
<a name="ln320">   *</a>
<a name="ln321">   * @par Example</a>
<a name="ln322">   * @code</a>
<a name="ln323">   * boost::asio::ip::tcp::socket socket(io_context);</a>
<a name="ln324">   * socket.open(boost::asio::ip::tcp::v4());</a>
<a name="ln325">   * @endcode</a>
<a name="ln326">   */</a>
<a name="ln327">  void open(const protocol_type&amp; protocol = protocol_type())</a>
<a name="ln328">  {</a>
<a name="ln329">    boost::system::error_code ec;</a>
<a name="ln330">    this-&gt;get_service().open(this-&gt;get_implementation(), protocol, ec);</a>
<a name="ln331">    boost::asio::detail::throw_error(ec, &quot;open&quot;);</a>
<a name="ln332">  }</a>
<a name="ln333"> </a>
<a name="ln334">  /// Open the socket using the specified protocol.</a>
<a name="ln335">  /**</a>
<a name="ln336">   * This function opens the socket so that it will use the specified protocol.</a>
<a name="ln337">   *</a>
<a name="ln338">   * @param protocol An object specifying which protocol is to be used.</a>
<a name="ln339">   *</a>
<a name="ln340">   * @param ec Set to indicate what error occurred, if any.</a>
<a name="ln341">   *</a>
<a name="ln342">   * @par Example</a>
<a name="ln343">   * @code</a>
<a name="ln344">   * boost::asio::ip::tcp::socket socket(io_context);</a>
<a name="ln345">   * boost::system::error_code ec;</a>
<a name="ln346">   * socket.open(boost::asio::ip::tcp::v4(), ec);</a>
<a name="ln347">   * if (ec)</a>
<a name="ln348">   * {</a>
<a name="ln349">   *   // An error occurred.</a>
<a name="ln350">   * }</a>
<a name="ln351">   * @endcode</a>
<a name="ln352">   */</a>
<a name="ln353">  BOOST_ASIO_SYNC_OP_VOID open(const protocol_type&amp; protocol,</a>
<a name="ln354">      boost::system::error_code&amp; ec)</a>
<a name="ln355">  {</a>
<a name="ln356">    this-&gt;get_service().open(this-&gt;get_implementation(), protocol, ec);</a>
<a name="ln357">    BOOST_ASIO_SYNC_OP_VOID_RETURN(ec);</a>
<a name="ln358">  }</a>
<a name="ln359"> </a>
<a name="ln360">  /// Assign an existing native socket to the socket.</a>
<a name="ln361">  /*</a>
<a name="ln362">   * This function opens the socket to hold an existing native socket.</a>
<a name="ln363">   *</a>
<a name="ln364">   * @param protocol An object specifying which protocol is to be used.</a>
<a name="ln365">   *</a>
<a name="ln366">   * @param native_socket A native socket.</a>
<a name="ln367">   *</a>
<a name="ln368">   * @throws boost::system::system_error Thrown on failure.</a>
<a name="ln369">   */</a>
<a name="ln370">  void assign(const protocol_type&amp; protocol,</a>
<a name="ln371">      const native_handle_type&amp; native_socket)</a>
<a name="ln372">  {</a>
<a name="ln373">    boost::system::error_code ec;</a>
<a name="ln374">    this-&gt;get_service().assign(this-&gt;get_implementation(),</a>
<a name="ln375">        protocol, native_socket, ec);</a>
<a name="ln376">    boost::asio::detail::throw_error(ec, &quot;assign&quot;);</a>
<a name="ln377">  }</a>
<a name="ln378"> </a>
<a name="ln379">  /// Assign an existing native socket to the socket.</a>
<a name="ln380">  /*</a>
<a name="ln381">   * This function opens the socket to hold an existing native socket.</a>
<a name="ln382">   *</a>
<a name="ln383">   * @param protocol An object specifying which protocol is to be used.</a>
<a name="ln384">   *</a>
<a name="ln385">   * @param native_socket A native socket.</a>
<a name="ln386">   *</a>
<a name="ln387">   * @param ec Set to indicate what error occurred, if any.</a>
<a name="ln388">   */</a>
<a name="ln389">  BOOST_ASIO_SYNC_OP_VOID assign(const protocol_type&amp; protocol,</a>
<a name="ln390">      const native_handle_type&amp; native_socket, boost::system::error_code&amp; ec)</a>
<a name="ln391">  {</a>
<a name="ln392">    this-&gt;get_service().assign(this-&gt;get_implementation(),</a>
<a name="ln393">        protocol, native_socket, ec);</a>
<a name="ln394">    BOOST_ASIO_SYNC_OP_VOID_RETURN(ec);</a>
<a name="ln395">  }</a>
<a name="ln396"> </a>
<a name="ln397">  /// Determine whether the socket is open.</a>
<a name="ln398">  bool is_open() const</a>
<a name="ln399">  {</a>
<a name="ln400">    return this-&gt;get_service().is_open(this-&gt;get_implementation());</a>
<a name="ln401">  }</a>
<a name="ln402"> </a>
<a name="ln403">  /// Close the socket.</a>
<a name="ln404">  /**</a>
<a name="ln405">   * This function is used to close the socket. Any asynchronous send, receive</a>
<a name="ln406">   * or connect operations will be cancelled immediately, and will complete</a>
<a name="ln407">   * with the boost::asio::error::operation_aborted error.</a>
<a name="ln408">   *</a>
<a name="ln409">   * @throws boost::system::system_error Thrown on failure. Note that, even if</a>
<a name="ln410">   * the function indicates an error, the underlying descriptor is closed.</a>
<a name="ln411">   *</a>
<a name="ln412">   * @note For portable behaviour with respect to graceful closure of a</a>
<a name="ln413">   * connected socket, call shutdown() before closing the socket.</a>
<a name="ln414">   */</a>
<a name="ln415">  void close()</a>
<a name="ln416">  {</a>
<a name="ln417">    boost::system::error_code ec;</a>
<a name="ln418">    this-&gt;get_service().close(this-&gt;get_implementation(), ec);</a>
<a name="ln419">    boost::asio::detail::throw_error(ec, &quot;close&quot;);</a>
<a name="ln420">  }</a>
<a name="ln421"> </a>
<a name="ln422">  /// Close the socket.</a>
<a name="ln423">  /**</a>
<a name="ln424">   * This function is used to close the socket. Any asynchronous send, receive</a>
<a name="ln425">   * or connect operations will be cancelled immediately, and will complete</a>
<a name="ln426">   * with the boost::asio::error::operation_aborted error.</a>
<a name="ln427">   *</a>
<a name="ln428">   * @param ec Set to indicate what error occurred, if any. Note that, even if</a>
<a name="ln429">   * the function indicates an error, the underlying descriptor is closed.</a>
<a name="ln430">   *</a>
<a name="ln431">   * @par Example</a>
<a name="ln432">   * @code</a>
<a name="ln433">   * boost::asio::ip::tcp::socket socket(io_context);</a>
<a name="ln434">   * ...</a>
<a name="ln435">   * boost::system::error_code ec;</a>
<a name="ln436">   * socket.close(ec);</a>
<a name="ln437">   * if (ec)</a>
<a name="ln438">   * {</a>
<a name="ln439">   *   // An error occurred.</a>
<a name="ln440">   * }</a>
<a name="ln441">   * @endcode</a>
<a name="ln442">   *</a>
<a name="ln443">   * @note For portable behaviour with respect to graceful closure of a</a>
<a name="ln444">   * connected socket, call shutdown() before closing the socket.</a>
<a name="ln445">   */</a>
<a name="ln446">  BOOST_ASIO_SYNC_OP_VOID close(boost::system::error_code&amp; ec)</a>
<a name="ln447">  {</a>
<a name="ln448">    this-&gt;get_service().close(this-&gt;get_implementation(), ec);</a>
<a name="ln449">    BOOST_ASIO_SYNC_OP_VOID_RETURN(ec);</a>
<a name="ln450">  }</a>
<a name="ln451"> </a>
<a name="ln452">  /// Release ownership of the underlying native socket.</a>
<a name="ln453">  /**</a>
<a name="ln454">   * This function causes all outstanding asynchronous connect, send and receive</a>
<a name="ln455">   * operations to finish immediately, and the handlers for cancelled operations</a>
<a name="ln456">   * will be passed the boost::asio::error::operation_aborted error. Ownership</a>
<a name="ln457">   * of the native socket is then transferred to the caller.</a>
<a name="ln458">   *</a>
<a name="ln459">   * @throws boost::system::system_error Thrown on failure.</a>
<a name="ln460">   *</a>
<a name="ln461">   * @note This function is unsupported on Windows versions prior to Windows</a>
<a name="ln462">   * 8.1, and will fail with boost::asio::error::operation_not_supported on</a>
<a name="ln463">   * these platforms.</a>
<a name="ln464">   */</a>
<a name="ln465">#if defined(BOOST_ASIO_MSVC) &amp;&amp; (BOOST_ASIO_MSVC &gt;= 1400) \</a>
<a name="ln466">  &amp;&amp; (!defined(_WIN32_WINNT) || _WIN32_WINNT &lt; 0x0603)</a>
<a name="ln467">  __declspec(deprecated(&quot;This function always fails with &quot;</a>
<a name="ln468">        &quot;operation_not_supported when used on Windows versions &quot;</a>
<a name="ln469">        &quot;prior to Windows 8.1.&quot;))</a>
<a name="ln470">#endif</a>
<a name="ln471">  native_handle_type release()</a>
<a name="ln472">  {</a>
<a name="ln473">    boost::system::error_code ec;</a>
<a name="ln474">    native_handle_type s = this-&gt;get_service().release(</a>
<a name="ln475">        this-&gt;get_implementation(), ec);</a>
<a name="ln476">    boost::asio::detail::throw_error(ec, &quot;release&quot;);</a>
<a name="ln477">    return s;</a>
<a name="ln478">  }</a>
<a name="ln479"> </a>
<a name="ln480">  /// Release ownership of the underlying native socket.</a>
<a name="ln481">  /**</a>
<a name="ln482">   * This function causes all outstanding asynchronous connect, send and receive</a>
<a name="ln483">   * operations to finish immediately, and the handlers for cancelled operations</a>
<a name="ln484">   * will be passed the boost::asio::error::operation_aborted error. Ownership</a>
<a name="ln485">   * of the native socket is then transferred to the caller.</a>
<a name="ln486">   *</a>
<a name="ln487">   * @param ec Set to indicate what error occurred, if any.</a>
<a name="ln488">   *</a>
<a name="ln489">   * @note This function is unsupported on Windows versions prior to Windows</a>
<a name="ln490">   * 8.1, and will fail with boost::asio::error::operation_not_supported on</a>
<a name="ln491">   * these platforms.</a>
<a name="ln492">   */</a>
<a name="ln493">#if defined(BOOST_ASIO_MSVC) &amp;&amp; (BOOST_ASIO_MSVC &gt;= 1400) \</a>
<a name="ln494">  &amp;&amp; (!defined(_WIN32_WINNT) || _WIN32_WINNT &lt; 0x0603)</a>
<a name="ln495">  __declspec(deprecated(&quot;This function always fails with &quot;</a>
<a name="ln496">        &quot;operation_not_supported when used on Windows versions &quot;</a>
<a name="ln497">        &quot;prior to Windows 8.1.&quot;))</a>
<a name="ln498">#endif</a>
<a name="ln499">  native_handle_type release(boost::system::error_code&amp; ec)</a>
<a name="ln500">  {</a>
<a name="ln501">    return this-&gt;get_service().release(this-&gt;get_implementation(), ec);</a>
<a name="ln502">  }</a>
<a name="ln503"> </a>
<a name="ln504">  /// Get the native socket representation.</a>
<a name="ln505">  /**</a>
<a name="ln506">   * This function may be used to obtain the underlying representation of the</a>
<a name="ln507">   * socket. This is intended to allow access to native socket functionality</a>
<a name="ln508">   * that is not otherwise provided.</a>
<a name="ln509">   */</a>
<a name="ln510">  native_handle_type native_handle()</a>
<a name="ln511">  {</a>
<a name="ln512">    return this-&gt;get_service().native_handle(this-&gt;get_implementation());</a>
<a name="ln513">  }</a>
<a name="ln514"> </a>
<a name="ln515">  /// Cancel all asynchronous operations associated with the socket.</a>
<a name="ln516">  /**</a>
<a name="ln517">   * This function causes all outstanding asynchronous connect, send and receive</a>
<a name="ln518">   * operations to finish immediately, and the handlers for cancelled operations</a>
<a name="ln519">   * will be passed the boost::asio::error::operation_aborted error.</a>
<a name="ln520">   *</a>
<a name="ln521">   * @throws boost::system::system_error Thrown on failure.</a>
<a name="ln522">   *</a>
<a name="ln523">   * @note Calls to cancel() will always fail with</a>
<a name="ln524">   * boost::asio::error::operation_not_supported when run on Windows XP, Windows</a>
<a name="ln525">   * Server 2003, and earlier versions of Windows, unless</a>
<a name="ln526">   * BOOST_ASIO_ENABLE_CANCELIO is defined. However, the CancelIo function has</a>
<a name="ln527">   * two issues that should be considered before enabling its use:</a>
<a name="ln528">   *</a>
<a name="ln529">   * @li It will only cancel asynchronous operations that were initiated in the</a>
<a name="ln530">   * current thread.</a>
<a name="ln531">   *</a>
<a name="ln532">   * @li It can appear to complete without error, but the request to cancel the</a>
<a name="ln533">   * unfinished operations may be silently ignored by the operating system.</a>
<a name="ln534">   * Whether it works or not seems to depend on the drivers that are installed.</a>
<a name="ln535">   *</a>
<a name="ln536">   * For portable cancellation, consider using one of the following</a>
<a name="ln537">   * alternatives:</a>
<a name="ln538">   *</a>
<a name="ln539">   * @li Disable asio's I/O completion port backend by defining</a>
<a name="ln540">   * BOOST_ASIO_DISABLE_IOCP.</a>
<a name="ln541">   *</a>
<a name="ln542">   * @li Use the close() function to simultaneously cancel the outstanding</a>
<a name="ln543">   * operations and close the socket.</a>
<a name="ln544">   *</a>
<a name="ln545">   * When running on Windows Vista, Windows Server 2008, and later, the</a>
<a name="ln546">   * CancelIoEx function is always used. This function does not have the</a>
<a name="ln547">   * problems described above.</a>
<a name="ln548">   */</a>
<a name="ln549">#if defined(BOOST_ASIO_MSVC) &amp;&amp; (BOOST_ASIO_MSVC &gt;= 1400) \</a>
<a name="ln550">  &amp;&amp; (!defined(_WIN32_WINNT) || _WIN32_WINNT &lt; 0x0600) \</a>
<a name="ln551">  &amp;&amp; !defined(BOOST_ASIO_ENABLE_CANCELIO)</a>
<a name="ln552">  __declspec(deprecated(&quot;By default, this function always fails with &quot;</a>
<a name="ln553">        &quot;operation_not_supported when used on Windows XP, Windows Server 2003, &quot;</a>
<a name="ln554">        &quot;or earlier. Consult documentation for details.&quot;))</a>
<a name="ln555">#endif</a>
<a name="ln556">  void cancel()</a>
<a name="ln557">  {</a>
<a name="ln558">    boost::system::error_code ec;</a>
<a name="ln559">    this-&gt;get_service().cancel(this-&gt;get_implementation(), ec);</a>
<a name="ln560">    boost::asio::detail::throw_error(ec, &quot;cancel&quot;);</a>
<a name="ln561">  }</a>
<a name="ln562"> </a>
<a name="ln563">  /// Cancel all asynchronous operations associated with the socket.</a>
<a name="ln564">  /**</a>
<a name="ln565">   * This function causes all outstanding asynchronous connect, send and receive</a>
<a name="ln566">   * operations to finish immediately, and the handlers for cancelled operations</a>
<a name="ln567">   * will be passed the boost::asio::error::operation_aborted error.</a>
<a name="ln568">   *</a>
<a name="ln569">   * @param ec Set to indicate what error occurred, if any.</a>
<a name="ln570">   *</a>
<a name="ln571">   * @note Calls to cancel() will always fail with</a>
<a name="ln572">   * boost::asio::error::operation_not_supported when run on Windows XP, Windows</a>
<a name="ln573">   * Server 2003, and earlier versions of Windows, unless</a>
<a name="ln574">   * BOOST_ASIO_ENABLE_CANCELIO is defined. However, the CancelIo function has</a>
<a name="ln575">   * two issues that should be considered before enabling its use:</a>
<a name="ln576">   *</a>
<a name="ln577">   * @li It will only cancel asynchronous operations that were initiated in the</a>
<a name="ln578">   * current thread.</a>
<a name="ln579">   *</a>
<a name="ln580">   * @li It can appear to complete without error, but the request to cancel the</a>
<a name="ln581">   * unfinished operations may be silently ignored by the operating system.</a>
<a name="ln582">   * Whether it works or not seems to depend on the drivers that are installed.</a>
<a name="ln583">   *</a>
<a name="ln584">   * For portable cancellation, consider using one of the following</a>
<a name="ln585">   * alternatives:</a>
<a name="ln586">   *</a>
<a name="ln587">   * @li Disable asio's I/O completion port backend by defining</a>
<a name="ln588">   * BOOST_ASIO_DISABLE_IOCP.</a>
<a name="ln589">   *</a>
<a name="ln590">   * @li Use the close() function to simultaneously cancel the outstanding</a>
<a name="ln591">   * operations and close the socket.</a>
<a name="ln592">   *</a>
<a name="ln593">   * When running on Windows Vista, Windows Server 2008, and later, the</a>
<a name="ln594">   * CancelIoEx function is always used. This function does not have the</a>
<a name="ln595">   * problems described above.</a>
<a name="ln596">   */</a>
<a name="ln597">#if defined(BOOST_ASIO_MSVC) &amp;&amp; (BOOST_ASIO_MSVC &gt;= 1400) \</a>
<a name="ln598">  &amp;&amp; (!defined(_WIN32_WINNT) || _WIN32_WINNT &lt; 0x0600) \</a>
<a name="ln599">  &amp;&amp; !defined(BOOST_ASIO_ENABLE_CANCELIO)</a>
<a name="ln600">  __declspec(deprecated(&quot;By default, this function always fails with &quot;</a>
<a name="ln601">        &quot;operation_not_supported when used on Windows XP, Windows Server 2003, &quot;</a>
<a name="ln602">        &quot;or earlier. Consult documentation for details.&quot;))</a>
<a name="ln603">#endif</a>
<a name="ln604">  BOOST_ASIO_SYNC_OP_VOID cancel(boost::system::error_code&amp; ec)</a>
<a name="ln605">  {</a>
<a name="ln606">    this-&gt;get_service().cancel(this-&gt;get_implementation(), ec);</a>
<a name="ln607">    BOOST_ASIO_SYNC_OP_VOID_RETURN(ec);</a>
<a name="ln608">  }</a>
<a name="ln609"> </a>
<a name="ln610">  /// Determine whether the socket is at the out-of-band data mark.</a>
<a name="ln611">  /**</a>
<a name="ln612">   * This function is used to check whether the socket input is currently</a>
<a name="ln613">   * positioned at the out-of-band data mark.</a>
<a name="ln614">   *</a>
<a name="ln615">   * @return A bool indicating whether the socket is at the out-of-band data</a>
<a name="ln616">   * mark.</a>
<a name="ln617">   *</a>
<a name="ln618">   * @throws boost::system::system_error Thrown on failure.</a>
<a name="ln619">   */</a>
<a name="ln620">  bool at_mark() const</a>
<a name="ln621">  {</a>
<a name="ln622">    boost::system::error_code ec;</a>
<a name="ln623">    bool b = this-&gt;get_service().at_mark(this-&gt;get_implementation(), ec);</a>
<a name="ln624">    boost::asio::detail::throw_error(ec, &quot;at_mark&quot;);</a>
<a name="ln625">    return b;</a>
<a name="ln626">  }</a>
<a name="ln627"> </a>
<a name="ln628">  /// Determine whether the socket is at the out-of-band data mark.</a>
<a name="ln629">  /**</a>
<a name="ln630">   * This function is used to check whether the socket input is currently</a>
<a name="ln631">   * positioned at the out-of-band data mark.</a>
<a name="ln632">   *</a>
<a name="ln633">   * @param ec Set to indicate what error occurred, if any.</a>
<a name="ln634">   *</a>
<a name="ln635">   * @return A bool indicating whether the socket is at the out-of-band data</a>
<a name="ln636">   * mark.</a>
<a name="ln637">   */</a>
<a name="ln638">  bool at_mark(boost::system::error_code&amp; ec) const</a>
<a name="ln639">  {</a>
<a name="ln640">    return this-&gt;get_service().at_mark(this-&gt;get_implementation(), ec);</a>
<a name="ln641">  }</a>
<a name="ln642"> </a>
<a name="ln643">  /// Determine the number of bytes available for reading.</a>
<a name="ln644">  /**</a>
<a name="ln645">   * This function is used to determine the number of bytes that may be read</a>
<a name="ln646">   * without blocking.</a>
<a name="ln647">   *</a>
<a name="ln648">   * @return The number of bytes that may be read without blocking, or 0 if an</a>
<a name="ln649">   * error occurs.</a>
<a name="ln650">   *</a>
<a name="ln651">   * @throws boost::system::system_error Thrown on failure.</a>
<a name="ln652">   */</a>
<a name="ln653">  std::size_t available() const</a>
<a name="ln654">  {</a>
<a name="ln655">    boost::system::error_code ec;</a>
<a name="ln656">    std::size_t s = this-&gt;get_service().available(</a>
<a name="ln657">        this-&gt;get_implementation(), ec);</a>
<a name="ln658">    boost::asio::detail::throw_error(ec, &quot;available&quot;);</a>
<a name="ln659">    return s;</a>
<a name="ln660">  }</a>
<a name="ln661"> </a>
<a name="ln662">  /// Determine the number of bytes available for reading.</a>
<a name="ln663">  /**</a>
<a name="ln664">   * This function is used to determine the number of bytes that may be read</a>
<a name="ln665">   * without blocking.</a>
<a name="ln666">   *</a>
<a name="ln667">   * @param ec Set to indicate what error occurred, if any.</a>
<a name="ln668">   *</a>
<a name="ln669">   * @return The number of bytes that may be read without blocking, or 0 if an</a>
<a name="ln670">   * error occurs.</a>
<a name="ln671">   */</a>
<a name="ln672">  std::size_t available(boost::system::error_code&amp; ec) const</a>
<a name="ln673">  {</a>
<a name="ln674">    return this-&gt;get_service().available(this-&gt;get_implementation(), ec);</a>
<a name="ln675">  }</a>
<a name="ln676"> </a>
<a name="ln677">  /// Bind the socket to the given local endpoint.</a>
<a name="ln678">  /**</a>
<a name="ln679">   * This function binds the socket to the specified endpoint on the local</a>
<a name="ln680">   * machine.</a>
<a name="ln681">   *</a>
<a name="ln682">   * @param endpoint An endpoint on the local machine to which the socket will</a>
<a name="ln683">   * be bound.</a>
<a name="ln684">   *</a>
<a name="ln685">   * @throws boost::system::system_error Thrown on failure.</a>
<a name="ln686">   *</a>
<a name="ln687">   * @par Example</a>
<a name="ln688">   * @code</a>
<a name="ln689">   * boost::asio::ip::tcp::socket socket(io_context);</a>
<a name="ln690">   * socket.open(boost::asio::ip::tcp::v4());</a>
<a name="ln691">   * socket.bind(boost::asio::ip::tcp::endpoint(</a>
<a name="ln692">   *       boost::asio::ip::tcp::v4(), 12345));</a>
<a name="ln693">   * @endcode</a>
<a name="ln694">   */</a>
<a name="ln695">  void bind(const endpoint_type&amp; endpoint)</a>
<a name="ln696">  {</a>
<a name="ln697">    boost::system::error_code ec;</a>
<a name="ln698">    this-&gt;get_service().bind(this-&gt;get_implementation(), endpoint, ec);</a>
<a name="ln699">    boost::asio::detail::throw_error(ec, &quot;bind&quot;);</a>
<a name="ln700">  }</a>
<a name="ln701"> </a>
<a name="ln702">  /// Bind the socket to the given local endpoint.</a>
<a name="ln703">  /**</a>
<a name="ln704">   * This function binds the socket to the specified endpoint on the local</a>
<a name="ln705">   * machine.</a>
<a name="ln706">   *</a>
<a name="ln707">   * @param endpoint An endpoint on the local machine to which the socket will</a>
<a name="ln708">   * be bound.</a>
<a name="ln709">   *</a>
<a name="ln710">   * @param ec Set to indicate what error occurred, if any.</a>
<a name="ln711">   *</a>
<a name="ln712">   * @par Example</a>
<a name="ln713">   * @code</a>
<a name="ln714">   * boost::asio::ip::tcp::socket socket(io_context);</a>
<a name="ln715">   * socket.open(boost::asio::ip::tcp::v4());</a>
<a name="ln716">   * boost::system::error_code ec;</a>
<a name="ln717">   * socket.bind(boost::asio::ip::tcp::endpoint(</a>
<a name="ln718">   *       boost::asio::ip::tcp::v4(), 12345), ec);</a>
<a name="ln719">   * if (ec)</a>
<a name="ln720">   * {</a>
<a name="ln721">   *   // An error occurred.</a>
<a name="ln722">   * }</a>
<a name="ln723">   * @endcode</a>
<a name="ln724">   */</a>
<a name="ln725">  BOOST_ASIO_SYNC_OP_VOID bind(const endpoint_type&amp; endpoint,</a>
<a name="ln726">      boost::system::error_code&amp; ec)</a>
<a name="ln727">  {</a>
<a name="ln728">    this-&gt;get_service().bind(this-&gt;get_implementation(), endpoint, ec);</a>
<a name="ln729">    BOOST_ASIO_SYNC_OP_VOID_RETURN(ec);</a>
<a name="ln730">  }</a>
<a name="ln731"> </a>
<a name="ln732">  /// Connect the socket to the specified endpoint.</a>
<a name="ln733">  /**</a>
<a name="ln734">   * This function is used to connect a socket to the specified remote endpoint.</a>
<a name="ln735">   * The function call will block until the connection is successfully made or</a>
<a name="ln736">   * an error occurs.</a>
<a name="ln737">   *</a>
<a name="ln738">   * The socket is automatically opened if it is not already open. If the</a>
<a name="ln739">   * connect fails, and the socket was automatically opened, the socket is</a>
<a name="ln740">   * not returned to the closed state.</a>
<a name="ln741">   *</a>
<a name="ln742">   * @param peer_endpoint The remote endpoint to which the socket will be</a>
<a name="ln743">   * connected.</a>
<a name="ln744">   *</a>
<a name="ln745">   * @throws boost::system::system_error Thrown on failure.</a>
<a name="ln746">   *</a>
<a name="ln747">   * @par Example</a>
<a name="ln748">   * @code</a>
<a name="ln749">   * boost::asio::ip::tcp::socket socket(io_context);</a>
<a name="ln750">   * boost::asio::ip::tcp::endpoint endpoint(</a>
<a name="ln751">   *     boost::asio::ip::address::from_string(&quot;1.2.3.4&quot;), 12345);</a>
<a name="ln752">   * socket.connect(endpoint);</a>
<a name="ln753">   * @endcode</a>
<a name="ln754">   */</a>
<a name="ln755">  void connect(const endpoint_type&amp; peer_endpoint)</a>
<a name="ln756">  {</a>
<a name="ln757">    boost::system::error_code ec;</a>
<a name="ln758">    if (!is_open())</a>
<a name="ln759">    {</a>
<a name="ln760">      this-&gt;get_service().open(this-&gt;get_implementation(),</a>
<a name="ln761">          peer_endpoint.protocol(), ec);</a>
<a name="ln762">      boost::asio::detail::throw_error(ec, &quot;connect&quot;);</a>
<a name="ln763">    }</a>
<a name="ln764">    this-&gt;get_service().connect(this-&gt;get_implementation(), peer_endpoint, ec);</a>
<a name="ln765">    boost::asio::detail::throw_error(ec, &quot;connect&quot;);</a>
<a name="ln766">  }</a>
<a name="ln767"> </a>
<a name="ln768">  /// Connect the socket to the specified endpoint.</a>
<a name="ln769">  /**</a>
<a name="ln770">   * This function is used to connect a socket to the specified remote endpoint.</a>
<a name="ln771">   * The function call will block until the connection is successfully made or</a>
<a name="ln772">   * an error occurs.</a>
<a name="ln773">   *</a>
<a name="ln774">   * The socket is automatically opened if it is not already open. If the</a>
<a name="ln775">   * connect fails, and the socket was automatically opened, the socket is</a>
<a name="ln776">   * not returned to the closed state.</a>
<a name="ln777">   *</a>
<a name="ln778">   * @param peer_endpoint The remote endpoint to which the socket will be</a>
<a name="ln779">   * connected.</a>
<a name="ln780">   *</a>
<a name="ln781">   * @param ec Set to indicate what error occurred, if any.</a>
<a name="ln782">   *</a>
<a name="ln783">   * @par Example</a>
<a name="ln784">   * @code</a>
<a name="ln785">   * boost::asio::ip::tcp::socket socket(io_context);</a>
<a name="ln786">   * boost::asio::ip::tcp::endpoint endpoint(</a>
<a name="ln787">   *     boost::asio::ip::address::from_string(&quot;1.2.3.4&quot;), 12345);</a>
<a name="ln788">   * boost::system::error_code ec;</a>
<a name="ln789">   * socket.connect(endpoint, ec);</a>
<a name="ln790">   * if (ec)</a>
<a name="ln791">   * {</a>
<a name="ln792">   *   // An error occurred.</a>
<a name="ln793">   * }</a>
<a name="ln794">   * @endcode</a>
<a name="ln795">   */</a>
<a name="ln796">  BOOST_ASIO_SYNC_OP_VOID connect(const endpoint_type&amp; peer_endpoint,</a>
<a name="ln797">      boost::system::error_code&amp; ec)</a>
<a name="ln798">  {</a>
<a name="ln799">    if (!is_open())</a>
<a name="ln800">    {</a>
<a name="ln801">      this-&gt;get_service().open(this-&gt;get_implementation(),</a>
<a name="ln802">            peer_endpoint.protocol(), ec);</a>
<a name="ln803">      if (ec)</a>
<a name="ln804">      {</a>
<a name="ln805">        BOOST_ASIO_SYNC_OP_VOID_RETURN(ec);</a>
<a name="ln806">      }</a>
<a name="ln807">    }</a>
<a name="ln808"> </a>
<a name="ln809">    this-&gt;get_service().connect(this-&gt;get_implementation(), peer_endpoint, ec);</a>
<a name="ln810">    BOOST_ASIO_SYNC_OP_VOID_RETURN(ec);</a>
<a name="ln811">  }</a>
<a name="ln812"> </a>
<a name="ln813">  /// Start an asynchronous connect.</a>
<a name="ln814">  /**</a>
<a name="ln815">   * This function is used to asynchronously connect a socket to the specified</a>
<a name="ln816">   * remote endpoint. The function call always returns immediately.</a>
<a name="ln817">   *</a>
<a name="ln818">   * The socket is automatically opened if it is not already open. If the</a>
<a name="ln819">   * connect fails, and the socket was automatically opened, the socket is</a>
<a name="ln820">   * not returned to the closed state.</a>
<a name="ln821">   *</a>
<a name="ln822">   * @param peer_endpoint The remote endpoint to which the socket will be</a>
<a name="ln823">   * connected. Copies will be made of the endpoint object as required.</a>
<a name="ln824">   *</a>
<a name="ln825">   * @param handler The handler to be called when the connection operation</a>
<a name="ln826">   * completes. Copies will be made of the handler as required. The function</a>
<a name="ln827">   * signature of the handler must be:</a>
<a name="ln828">   * @code void handler(</a>
<a name="ln829">   *   const boost::system::error_code&amp; error // Result of operation</a>
<a name="ln830">   * ); @endcode</a>
<a name="ln831">   * Regardless of whether the asynchronous operation completes immediately or</a>
<a name="ln832">   * not, the handler will not be invoked from within this function. Invocation</a>
<a name="ln833">   * of the handler will be performed in a manner equivalent to using</a>
<a name="ln834">   * boost::asio::io_context::post().</a>
<a name="ln835">   *</a>
<a name="ln836">   * @par Example</a>
<a name="ln837">   * @code</a>
<a name="ln838">   * void connect_handler(const boost::system::error_code&amp; error)</a>
<a name="ln839">   * {</a>
<a name="ln840">   *   if (!error)</a>
<a name="ln841">   *   {</a>
<a name="ln842">   *     // Connect succeeded.</a>
<a name="ln843">   *   }</a>
<a name="ln844">   * }</a>
<a name="ln845">   *</a>
<a name="ln846">   * ...</a>
<a name="ln847">   *</a>
<a name="ln848">   * boost::asio::ip::tcp::socket socket(io_context);</a>
<a name="ln849">   * boost::asio::ip::tcp::endpoint endpoint(</a>
<a name="ln850">   *     boost::asio::ip::address::from_string(&quot;1.2.3.4&quot;), 12345);</a>
<a name="ln851">   * socket.async_connect(endpoint, connect_handler);</a>
<a name="ln852">   * @endcode</a>
<a name="ln853">   */</a>
<a name="ln854">  template &lt;typename ConnectHandler&gt;</a>
<a name="ln855">  BOOST_ASIO_INITFN_RESULT_TYPE(ConnectHandler,</a>
<a name="ln856">      void (boost::system::error_code))</a>
<a name="ln857">  async_connect(const endpoint_type&amp; peer_endpoint,</a>
<a name="ln858">      BOOST_ASIO_MOVE_ARG(ConnectHandler) handler)</a>
<a name="ln859">  {</a>
<a name="ln860">    // If you get an error on the following line it means that your handler does</a>
<a name="ln861">    // not meet the documented type requirements for a ConnectHandler.</a>
<a name="ln862">    BOOST_ASIO_CONNECT_HANDLER_CHECK(ConnectHandler, handler) type_check;</a>
<a name="ln863"> </a>
<a name="ln864">    if (!is_open())</a>
<a name="ln865">    {</a>
<a name="ln866">      boost::system::error_code ec;</a>
<a name="ln867">      const protocol_type protocol = peer_endpoint.protocol();</a>
<a name="ln868">      this-&gt;get_service().open(this-&gt;get_implementation(), protocol, ec);</a>
<a name="ln869">      if (ec)</a>
<a name="ln870">      {</a>
<a name="ln871">        async_completion&lt;ConnectHandler,</a>
<a name="ln872">          void (boost::system::error_code)&gt; init(handler);</a>
<a name="ln873"> </a>
<a name="ln874">        boost::asio::post(this-&gt;get_executor(),</a>
<a name="ln875">            boost::asio::detail::bind_handler(</a>
<a name="ln876">              BOOST_ASIO_MOVE_CAST(BOOST_ASIO_HANDLER_TYPE(</a>
<a name="ln877">                ConnectHandler, void (boost::system::error_code)))(</a>
<a name="ln878">                  init.completion_handler), ec));</a>
<a name="ln879"> </a>
<a name="ln880">        return init.result.get();</a>
<a name="ln881">      }</a>
<a name="ln882">    }</a>
<a name="ln883"> </a>
<a name="ln884">#if defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln885">    return this-&gt;get_service().async_connect(this-&gt;get_implementation(),</a>
<a name="ln886">        peer_endpoint, BOOST_ASIO_MOVE_CAST(ConnectHandler)(handler));</a>
<a name="ln887">#else // defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln888">    async_completion&lt;ConnectHandler,</a>
<a name="ln889">      void (boost::system::error_code)&gt; init(handler);</a>
<a name="ln890"> </a>
<a name="ln891">    this-&gt;get_service().async_connect(</a>
<a name="ln892">        this-&gt;get_implementation(), peer_endpoint, init.completion_handler);</a>
<a name="ln893"> </a>
<a name="ln894">    return init.result.get();</a>
<a name="ln895">#endif // defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln896">  }</a>
<a name="ln897"> </a>
<a name="ln898">  /// Set an option on the socket.</a>
<a name="ln899">  /**</a>
<a name="ln900">   * This function is used to set an option on the socket.</a>
<a name="ln901">   *</a>
<a name="ln902">   * @param option The new option value to be set on the socket.</a>
<a name="ln903">   *</a>
<a name="ln904">   * @throws boost::system::system_error Thrown on failure.</a>
<a name="ln905">   *</a>
<a name="ln906">   * @sa SettableSocketOption @n</a>
<a name="ln907">   * boost::asio::socket_base::broadcast @n</a>
<a name="ln908">   * boost::asio::socket_base::do_not_route @n</a>
<a name="ln909">   * boost::asio::socket_base::keep_alive @n</a>
<a name="ln910">   * boost::asio::socket_base::linger @n</a>
<a name="ln911">   * boost::asio::socket_base::receive_buffer_size @n</a>
<a name="ln912">   * boost::asio::socket_base::receive_low_watermark @n</a>
<a name="ln913">   * boost::asio::socket_base::reuse_address @n</a>
<a name="ln914">   * boost::asio::socket_base::send_buffer_size @n</a>
<a name="ln915">   * boost::asio::socket_base::send_low_watermark @n</a>
<a name="ln916">   * boost::asio::ip::multicast::join_group @n</a>
<a name="ln917">   * boost::asio::ip::multicast::leave_group @n</a>
<a name="ln918">   * boost::asio::ip::multicast::enable_loopback @n</a>
<a name="ln919">   * boost::asio::ip::multicast::outbound_interface @n</a>
<a name="ln920">   * boost::asio::ip::multicast::hops @n</a>
<a name="ln921">   * boost::asio::ip::tcp::no_delay</a>
<a name="ln922">   *</a>
<a name="ln923">   * @par Example</a>
<a name="ln924">   * Setting the IPPROTO_TCP/TCP_NODELAY option:</a>
<a name="ln925">   * @code</a>
<a name="ln926">   * boost::asio::ip::tcp::socket socket(io_context);</a>
<a name="ln927">   * ...</a>
<a name="ln928">   * boost::asio::ip::tcp::no_delay option(true);</a>
<a name="ln929">   * socket.set_option(option);</a>
<a name="ln930">   * @endcode</a>
<a name="ln931">   */</a>
<a name="ln932">  template &lt;typename SettableSocketOption&gt;</a>
<a name="ln933">  void set_option(const SettableSocketOption&amp; option)</a>
<a name="ln934">  {</a>
<a name="ln935">    boost::system::error_code ec;</a>
<a name="ln936">    this-&gt;get_service().set_option(this-&gt;get_implementation(), option, ec);</a>
<a name="ln937">    boost::asio::detail::throw_error(ec, &quot;set_option&quot;);</a>
<a name="ln938">  }</a>
<a name="ln939"> </a>
<a name="ln940">  /// Set an option on the socket.</a>
<a name="ln941">  /**</a>
<a name="ln942">   * This function is used to set an option on the socket.</a>
<a name="ln943">   *</a>
<a name="ln944">   * @param option The new option value to be set on the socket.</a>
<a name="ln945">   *</a>
<a name="ln946">   * @param ec Set to indicate what error occurred, if any.</a>
<a name="ln947">   *</a>
<a name="ln948">   * @sa SettableSocketOption @n</a>
<a name="ln949">   * boost::asio::socket_base::broadcast @n</a>
<a name="ln950">   * boost::asio::socket_base::do_not_route @n</a>
<a name="ln951">   * boost::asio::socket_base::keep_alive @n</a>
<a name="ln952">   * boost::asio::socket_base::linger @n</a>
<a name="ln953">   * boost::asio::socket_base::receive_buffer_size @n</a>
<a name="ln954">   * boost::asio::socket_base::receive_low_watermark @n</a>
<a name="ln955">   * boost::asio::socket_base::reuse_address @n</a>
<a name="ln956">   * boost::asio::socket_base::send_buffer_size @n</a>
<a name="ln957">   * boost::asio::socket_base::send_low_watermark @n</a>
<a name="ln958">   * boost::asio::ip::multicast::join_group @n</a>
<a name="ln959">   * boost::asio::ip::multicast::leave_group @n</a>
<a name="ln960">   * boost::asio::ip::multicast::enable_loopback @n</a>
<a name="ln961">   * boost::asio::ip::multicast::outbound_interface @n</a>
<a name="ln962">   * boost::asio::ip::multicast::hops @n</a>
<a name="ln963">   * boost::asio::ip::tcp::no_delay</a>
<a name="ln964">   *</a>
<a name="ln965">   * @par Example</a>
<a name="ln966">   * Setting the IPPROTO_TCP/TCP_NODELAY option:</a>
<a name="ln967">   * @code</a>
<a name="ln968">   * boost::asio::ip::tcp::socket socket(io_context);</a>
<a name="ln969">   * ...</a>
<a name="ln970">   * boost::asio::ip::tcp::no_delay option(true);</a>
<a name="ln971">   * boost::system::error_code ec;</a>
<a name="ln972">   * socket.set_option(option, ec);</a>
<a name="ln973">   * if (ec)</a>
<a name="ln974">   * {</a>
<a name="ln975">   *   // An error occurred.</a>
<a name="ln976">   * }</a>
<a name="ln977">   * @endcode</a>
<a name="ln978">   */</a>
<a name="ln979">  template &lt;typename SettableSocketOption&gt;</a>
<a name="ln980">  BOOST_ASIO_SYNC_OP_VOID set_option(const SettableSocketOption&amp; option,</a>
<a name="ln981">      boost::system::error_code&amp; ec)</a>
<a name="ln982">  {</a>
<a name="ln983">    this-&gt;get_service().set_option(this-&gt;get_implementation(), option, ec);</a>
<a name="ln984">    BOOST_ASIO_SYNC_OP_VOID_RETURN(ec);</a>
<a name="ln985">  }</a>
<a name="ln986"> </a>
<a name="ln987">  /// Get an option from the socket.</a>
<a name="ln988">  /**</a>
<a name="ln989">   * This function is used to get the current value of an option on the socket.</a>
<a name="ln990">   *</a>
<a name="ln991">   * @param option The option value to be obtained from the socket.</a>
<a name="ln992">   *</a>
<a name="ln993">   * @throws boost::system::system_error Thrown on failure.</a>
<a name="ln994">   *</a>
<a name="ln995">   * @sa GettableSocketOption @n</a>
<a name="ln996">   * boost::asio::socket_base::broadcast @n</a>
<a name="ln997">   * boost::asio::socket_base::do_not_route @n</a>
<a name="ln998">   * boost::asio::socket_base::keep_alive @n</a>
<a name="ln999">   * boost::asio::socket_base::linger @n</a>
<a name="ln1000">   * boost::asio::socket_base::receive_buffer_size @n</a>
<a name="ln1001">   * boost::asio::socket_base::receive_low_watermark @n</a>
<a name="ln1002">   * boost::asio::socket_base::reuse_address @n</a>
<a name="ln1003">   * boost::asio::socket_base::send_buffer_size @n</a>
<a name="ln1004">   * boost::asio::socket_base::send_low_watermark @n</a>
<a name="ln1005">   * boost::asio::ip::multicast::join_group @n</a>
<a name="ln1006">   * boost::asio::ip::multicast::leave_group @n</a>
<a name="ln1007">   * boost::asio::ip::multicast::enable_loopback @n</a>
<a name="ln1008">   * boost::asio::ip::multicast::outbound_interface @n</a>
<a name="ln1009">   * boost::asio::ip::multicast::hops @n</a>
<a name="ln1010">   * boost::asio::ip::tcp::no_delay</a>
<a name="ln1011">   *</a>
<a name="ln1012">   * @par Example</a>
<a name="ln1013">   * Getting the value of the SOL_SOCKET/SO_KEEPALIVE option:</a>
<a name="ln1014">   * @code</a>
<a name="ln1015">   * boost::asio::ip::tcp::socket socket(io_context);</a>
<a name="ln1016">   * ...</a>
<a name="ln1017">   * boost::asio::ip::tcp::socket::keep_alive option;</a>
<a name="ln1018">   * socket.get_option(option);</a>
<a name="ln1019">   * bool is_set = option.value();</a>
<a name="ln1020">   * @endcode</a>
<a name="ln1021">   */</a>
<a name="ln1022">  template &lt;typename GettableSocketOption&gt;</a>
<a name="ln1023">  void get_option(GettableSocketOption&amp; option) const</a>
<a name="ln1024">  {</a>
<a name="ln1025">    boost::system::error_code ec;</a>
<a name="ln1026">    this-&gt;get_service().get_option(this-&gt;get_implementation(), option, ec);</a>
<a name="ln1027">    boost::asio::detail::throw_error(ec, &quot;get_option&quot;);</a>
<a name="ln1028">  }</a>
<a name="ln1029"> </a>
<a name="ln1030">  /// Get an option from the socket.</a>
<a name="ln1031">  /**</a>
<a name="ln1032">   * This function is used to get the current value of an option on the socket.</a>
<a name="ln1033">   *</a>
<a name="ln1034">   * @param option The option value to be obtained from the socket.</a>
<a name="ln1035">   *</a>
<a name="ln1036">   * @param ec Set to indicate what error occurred, if any.</a>
<a name="ln1037">   *</a>
<a name="ln1038">   * @sa GettableSocketOption @n</a>
<a name="ln1039">   * boost::asio::socket_base::broadcast @n</a>
<a name="ln1040">   * boost::asio::socket_base::do_not_route @n</a>
<a name="ln1041">   * boost::asio::socket_base::keep_alive @n</a>
<a name="ln1042">   * boost::asio::socket_base::linger @n</a>
<a name="ln1043">   * boost::asio::socket_base::receive_buffer_size @n</a>
<a name="ln1044">   * boost::asio::socket_base::receive_low_watermark @n</a>
<a name="ln1045">   * boost::asio::socket_base::reuse_address @n</a>
<a name="ln1046">   * boost::asio::socket_base::send_buffer_size @n</a>
<a name="ln1047">   * boost::asio::socket_base::send_low_watermark @n</a>
<a name="ln1048">   * boost::asio::ip::multicast::join_group @n</a>
<a name="ln1049">   * boost::asio::ip::multicast::leave_group @n</a>
<a name="ln1050">   * boost::asio::ip::multicast::enable_loopback @n</a>
<a name="ln1051">   * boost::asio::ip::multicast::outbound_interface @n</a>
<a name="ln1052">   * boost::asio::ip::multicast::hops @n</a>
<a name="ln1053">   * boost::asio::ip::tcp::no_delay</a>
<a name="ln1054">   *</a>
<a name="ln1055">   * @par Example</a>
<a name="ln1056">   * Getting the value of the SOL_SOCKET/SO_KEEPALIVE option:</a>
<a name="ln1057">   * @code</a>
<a name="ln1058">   * boost::asio::ip::tcp::socket socket(io_context);</a>
<a name="ln1059">   * ...</a>
<a name="ln1060">   * boost::asio::ip::tcp::socket::keep_alive option;</a>
<a name="ln1061">   * boost::system::error_code ec;</a>
<a name="ln1062">   * socket.get_option(option, ec);</a>
<a name="ln1063">   * if (ec)</a>
<a name="ln1064">   * {</a>
<a name="ln1065">   *   // An error occurred.</a>
<a name="ln1066">   * }</a>
<a name="ln1067">   * bool is_set = option.value();</a>
<a name="ln1068">   * @endcode</a>
<a name="ln1069">   */</a>
<a name="ln1070">  template &lt;typename GettableSocketOption&gt;</a>
<a name="ln1071">  BOOST_ASIO_SYNC_OP_VOID get_option(GettableSocketOption&amp; option,</a>
<a name="ln1072">      boost::system::error_code&amp; ec) const</a>
<a name="ln1073">  {</a>
<a name="ln1074">    this-&gt;get_service().get_option(this-&gt;get_implementation(), option, ec);</a>
<a name="ln1075">    BOOST_ASIO_SYNC_OP_VOID_RETURN(ec);</a>
<a name="ln1076">  }</a>
<a name="ln1077"> </a>
<a name="ln1078">  /// Perform an IO control command on the socket.</a>
<a name="ln1079">  /**</a>
<a name="ln1080">   * This function is used to execute an IO control command on the socket.</a>
<a name="ln1081">   *</a>
<a name="ln1082">   * @param command The IO control command to be performed on the socket.</a>
<a name="ln1083">   *</a>
<a name="ln1084">   * @throws boost::system::system_error Thrown on failure.</a>
<a name="ln1085">   *</a>
<a name="ln1086">   * @sa IoControlCommand @n</a>
<a name="ln1087">   * boost::asio::socket_base::bytes_readable @n</a>
<a name="ln1088">   * boost::asio::socket_base::non_blocking_io</a>
<a name="ln1089">   *</a>
<a name="ln1090">   * @par Example</a>
<a name="ln1091">   * Getting the number of bytes ready to read:</a>
<a name="ln1092">   * @code</a>
<a name="ln1093">   * boost::asio::ip::tcp::socket socket(io_context);</a>
<a name="ln1094">   * ...</a>
<a name="ln1095">   * boost::asio::ip::tcp::socket::bytes_readable command;</a>
<a name="ln1096">   * socket.io_control(command);</a>
<a name="ln1097">   * std::size_t bytes_readable = command.get();</a>
<a name="ln1098">   * @endcode</a>
<a name="ln1099">   */</a>
<a name="ln1100">  template &lt;typename IoControlCommand&gt;</a>
<a name="ln1101">  void io_control(IoControlCommand&amp; command)</a>
<a name="ln1102">  {</a>
<a name="ln1103">    boost::system::error_code ec;</a>
<a name="ln1104">    this-&gt;get_service().io_control(this-&gt;get_implementation(), command, ec);</a>
<a name="ln1105">    boost::asio::detail::throw_error(ec, &quot;io_control&quot;);</a>
<a name="ln1106">  }</a>
<a name="ln1107"> </a>
<a name="ln1108">  /// Perform an IO control command on the socket.</a>
<a name="ln1109">  /**</a>
<a name="ln1110">   * This function is used to execute an IO control command on the socket.</a>
<a name="ln1111">   *</a>
<a name="ln1112">   * @param command The IO control command to be performed on the socket.</a>
<a name="ln1113">   *</a>
<a name="ln1114">   * @param ec Set to indicate what error occurred, if any.</a>
<a name="ln1115">   *</a>
<a name="ln1116">   * @sa IoControlCommand @n</a>
<a name="ln1117">   * boost::asio::socket_base::bytes_readable @n</a>
<a name="ln1118">   * boost::asio::socket_base::non_blocking_io</a>
<a name="ln1119">   *</a>
<a name="ln1120">   * @par Example</a>
<a name="ln1121">   * Getting the number of bytes ready to read:</a>
<a name="ln1122">   * @code</a>
<a name="ln1123">   * boost::asio::ip::tcp::socket socket(io_context);</a>
<a name="ln1124">   * ...</a>
<a name="ln1125">   * boost::asio::ip::tcp::socket::bytes_readable command;</a>
<a name="ln1126">   * boost::system::error_code ec;</a>
<a name="ln1127">   * socket.io_control(command, ec);</a>
<a name="ln1128">   * if (ec)</a>
<a name="ln1129">   * {</a>
<a name="ln1130">   *   // An error occurred.</a>
<a name="ln1131">   * }</a>
<a name="ln1132">   * std::size_t bytes_readable = command.get();</a>
<a name="ln1133">   * @endcode</a>
<a name="ln1134">   */</a>
<a name="ln1135">  template &lt;typename IoControlCommand&gt;</a>
<a name="ln1136">  BOOST_ASIO_SYNC_OP_VOID io_control(IoControlCommand&amp; command,</a>
<a name="ln1137">      boost::system::error_code&amp; ec)</a>
<a name="ln1138">  {</a>
<a name="ln1139">    this-&gt;get_service().io_control(this-&gt;get_implementation(), command, ec);</a>
<a name="ln1140">    BOOST_ASIO_SYNC_OP_VOID_RETURN(ec);</a>
<a name="ln1141">  }</a>
<a name="ln1142"> </a>
<a name="ln1143">  /// Gets the non-blocking mode of the socket.</a>
<a name="ln1144">  /**</a>
<a name="ln1145">   * @returns @c true if the socket's synchronous operations will fail with</a>
<a name="ln1146">   * boost::asio::error::would_block if they are unable to perform the requested</a>
<a name="ln1147">   * operation immediately. If @c false, synchronous operations will block</a>
<a name="ln1148">   * until complete.</a>
<a name="ln1149">   *</a>
<a name="ln1150">   * @note The non-blocking mode has no effect on the behaviour of asynchronous</a>
<a name="ln1151">   * operations. Asynchronous operations will never fail with the error</a>
<a name="ln1152">   * boost::asio::error::would_block.</a>
<a name="ln1153">   */</a>
<a name="ln1154">  bool non_blocking() const</a>
<a name="ln1155">  {</a>
<a name="ln1156">    return this-&gt;get_service().non_blocking(this-&gt;get_implementation());</a>
<a name="ln1157">  }</a>
<a name="ln1158"> </a>
<a name="ln1159">  /// Sets the non-blocking mode of the socket.</a>
<a name="ln1160">  /**</a>
<a name="ln1161">   * @param mode If @c true, the socket's synchronous operations will fail with</a>
<a name="ln1162">   * boost::asio::error::would_block if they are unable to perform the requested</a>
<a name="ln1163">   * operation immediately. If @c false, synchronous operations will block</a>
<a name="ln1164">   * until complete.</a>
<a name="ln1165">   *</a>
<a name="ln1166">   * @throws boost::system::system_error Thrown on failure.</a>
<a name="ln1167">   *</a>
<a name="ln1168">   * @note The non-blocking mode has no effect on the behaviour of asynchronous</a>
<a name="ln1169">   * operations. Asynchronous operations will never fail with the error</a>
<a name="ln1170">   * boost::asio::error::would_block.</a>
<a name="ln1171">   */</a>
<a name="ln1172">  void non_blocking(bool mode)</a>
<a name="ln1173">  {</a>
<a name="ln1174">    boost::system::error_code ec;</a>
<a name="ln1175">    this-&gt;get_service().non_blocking(this-&gt;get_implementation(), mode, ec);</a>
<a name="ln1176">    boost::asio::detail::throw_error(ec, &quot;non_blocking&quot;);</a>
<a name="ln1177">  }</a>
<a name="ln1178"> </a>
<a name="ln1179">  /// Sets the non-blocking mode of the socket.</a>
<a name="ln1180">  /**</a>
<a name="ln1181">   * @param mode If @c true, the socket's synchronous operations will fail with</a>
<a name="ln1182">   * boost::asio::error::would_block if they are unable to perform the requested</a>
<a name="ln1183">   * operation immediately. If @c false, synchronous operations will block</a>
<a name="ln1184">   * until complete.</a>
<a name="ln1185">   *</a>
<a name="ln1186">   * @param ec Set to indicate what error occurred, if any.</a>
<a name="ln1187">   *</a>
<a name="ln1188">   * @note The non-blocking mode has no effect on the behaviour of asynchronous</a>
<a name="ln1189">   * operations. Asynchronous operations will never fail with the error</a>
<a name="ln1190">   * boost::asio::error::would_block.</a>
<a name="ln1191">   */</a>
<a name="ln1192">  BOOST_ASIO_SYNC_OP_VOID non_blocking(</a>
<a name="ln1193">      bool mode, boost::system::error_code&amp; ec)</a>
<a name="ln1194">  {</a>
<a name="ln1195">    this-&gt;get_service().non_blocking(this-&gt;get_implementation(), mode, ec);</a>
<a name="ln1196">    BOOST_ASIO_SYNC_OP_VOID_RETURN(ec);</a>
<a name="ln1197">  }</a>
<a name="ln1198"> </a>
<a name="ln1199">  /// Gets the non-blocking mode of the native socket implementation.</a>
<a name="ln1200">  /**</a>
<a name="ln1201">   * This function is used to retrieve the non-blocking mode of the underlying</a>
<a name="ln1202">   * native socket. This mode has no effect on the behaviour of the socket</a>
<a name="ln1203">   * object's synchronous operations.</a>
<a name="ln1204">   *</a>
<a name="ln1205">   * @returns @c true if the underlying socket is in non-blocking mode and</a>
<a name="ln1206">   * direct system calls may fail with boost::asio::error::would_block (or the</a>
<a name="ln1207">   * equivalent system error).</a>
<a name="ln1208">   *</a>
<a name="ln1209">   * @note The current non-blocking mode is cached by the socket object.</a>
<a name="ln1210">   * Consequently, the return value may be incorrect if the non-blocking mode</a>
<a name="ln1211">   * was set directly on the native socket.</a>
<a name="ln1212">   *</a>
<a name="ln1213">   * @par Example</a>
<a name="ln1214">   * This function is intended to allow the encapsulation of arbitrary</a>
<a name="ln1215">   * non-blocking system calls as asynchronous operations, in a way that is</a>
<a name="ln1216">   * transparent to the user of the socket object. The following example</a>
<a name="ln1217">   * illustrates how Linux's @c sendfile system call might be encapsulated:</a>
<a name="ln1218">   * @code template &lt;typename Handler&gt;</a>
<a name="ln1219">   * struct sendfile_op</a>
<a name="ln1220">   * {</a>
<a name="ln1221">   *   tcp::socket&amp; sock_;</a>
<a name="ln1222">   *   int fd_;</a>
<a name="ln1223">   *   Handler handler_;</a>
<a name="ln1224">   *   off_t offset_;</a>
<a name="ln1225">   *   std::size_t total_bytes_transferred_;</a>
<a name="ln1226">   *</a>
<a name="ln1227">   *   // Function call operator meeting WriteHandler requirements.</a>
<a name="ln1228">   *   // Used as the handler for the async_write_some operation.</a>
<a name="ln1229">   *   void operator()(boost::system::error_code ec, std::size_t)</a>
<a name="ln1230">   *   {</a>
<a name="ln1231">   *     // Put the underlying socket into non-blocking mode.</a>
<a name="ln1232">   *     if (!ec)</a>
<a name="ln1233">   *       if (!sock_.native_non_blocking())</a>
<a name="ln1234">   *         sock_.native_non_blocking(true, ec);</a>
<a name="ln1235">   *</a>
<a name="ln1236">   *     if (!ec)</a>
<a name="ln1237">   *     {</a>
<a name="ln1238">   *       for (;;)</a>
<a name="ln1239">   *       {</a>
<a name="ln1240">   *         // Try the system call.</a>
<a name="ln1241">   *         errno = 0;</a>
<a name="ln1242">   *         int n = ::sendfile(sock_.native_handle(), fd_, &amp;offset_, 65536);</a>
<a name="ln1243">   *         ec = boost::system::error_code(n &lt; 0 ? errno : 0,</a>
<a name="ln1244">   *             boost::asio::error::get_system_category());</a>
<a name="ln1245">   *         total_bytes_transferred_ += ec ? 0 : n;</a>
<a name="ln1246">   *</a>
<a name="ln1247">   *         // Retry operation immediately if interrupted by signal.</a>
<a name="ln1248">   *         if (ec == boost::asio::error::interrupted)</a>
<a name="ln1249">   *           continue;</a>
<a name="ln1250">   *</a>
<a name="ln1251">   *         // Check if we need to run the operation again.</a>
<a name="ln1252">   *         if (ec == boost::asio::error::would_block</a>
<a name="ln1253">   *             || ec == boost::asio::error::try_again)</a>
<a name="ln1254">   *         {</a>
<a name="ln1255">   *           // We have to wait for the socket to become ready again.</a>
<a name="ln1256">   *           sock_.async_wait(tcp::socket::wait_write, *this);</a>
<a name="ln1257">   *           return;</a>
<a name="ln1258">   *         }</a>
<a name="ln1259">   *</a>
<a name="ln1260">   *         if (ec || n == 0)</a>
<a name="ln1261">   *         {</a>
<a name="ln1262">   *           // An error occurred, or we have reached the end of the file.</a>
<a name="ln1263">   *           // Either way we must exit the loop so we can call the handler.</a>
<a name="ln1264">   *           break;</a>
<a name="ln1265">   *         }</a>
<a name="ln1266">   *</a>
<a name="ln1267">   *         // Loop around to try calling sendfile again.</a>
<a name="ln1268">   *       }</a>
<a name="ln1269">   *     }</a>
<a name="ln1270">   *</a>
<a name="ln1271">   *     // Pass result back to user's handler.</a>
<a name="ln1272">   *     handler_(ec, total_bytes_transferred_);</a>
<a name="ln1273">   *   }</a>
<a name="ln1274">   * };</a>
<a name="ln1275">   *</a>
<a name="ln1276">   * template &lt;typename Handler&gt;</a>
<a name="ln1277">   * void async_sendfile(tcp::socket&amp; sock, int fd, Handler h)</a>
<a name="ln1278">   * {</a>
<a name="ln1279">   *   sendfile_op&lt;Handler&gt; op = { sock, fd, h, 0, 0 };</a>
<a name="ln1280">   *   sock.async_wait(tcp::socket::wait_write, op);</a>
<a name="ln1281">   * } @endcode</a>
<a name="ln1282">   */</a>
<a name="ln1283">  bool native_non_blocking() const</a>
<a name="ln1284">  {</a>
<a name="ln1285">    return this-&gt;get_service().native_non_blocking(this-&gt;get_implementation());</a>
<a name="ln1286">  }</a>
<a name="ln1287"> </a>
<a name="ln1288">  /// Sets the non-blocking mode of the native socket implementation.</a>
<a name="ln1289">  /**</a>
<a name="ln1290">   * This function is used to modify the non-blocking mode of the underlying</a>
<a name="ln1291">   * native socket. It has no effect on the behaviour of the socket object's</a>
<a name="ln1292">   * synchronous operations.</a>
<a name="ln1293">   *</a>
<a name="ln1294">   * @param mode If @c true, the underlying socket is put into non-blocking</a>
<a name="ln1295">   * mode and direct system calls may fail with boost::asio::error::would_block</a>
<a name="ln1296">   * (or the equivalent system error).</a>
<a name="ln1297">   *</a>
<a name="ln1298">   * @throws boost::system::system_error Thrown on failure. If the @c mode is</a>
<a name="ln1299">   * @c false, but the current value of @c non_blocking() is @c true, this</a>
<a name="ln1300">   * function fails with boost::asio::error::invalid_argument, as the</a>
<a name="ln1301">   * combination does not make sense.</a>
<a name="ln1302">   *</a>
<a name="ln1303">   * @par Example</a>
<a name="ln1304">   * This function is intended to allow the encapsulation of arbitrary</a>
<a name="ln1305">   * non-blocking system calls as asynchronous operations, in a way that is</a>
<a name="ln1306">   * transparent to the user of the socket object. The following example</a>
<a name="ln1307">   * illustrates how Linux's @c sendfile system call might be encapsulated:</a>
<a name="ln1308">   * @code template &lt;typename Handler&gt;</a>
<a name="ln1309">   * struct sendfile_op</a>
<a name="ln1310">   * {</a>
<a name="ln1311">   *   tcp::socket&amp; sock_;</a>
<a name="ln1312">   *   int fd_;</a>
<a name="ln1313">   *   Handler handler_;</a>
<a name="ln1314">   *   off_t offset_;</a>
<a name="ln1315">   *   std::size_t total_bytes_transferred_;</a>
<a name="ln1316">   *</a>
<a name="ln1317">   *   // Function call operator meeting WriteHandler requirements.</a>
<a name="ln1318">   *   // Used as the handler for the async_write_some operation.</a>
<a name="ln1319">   *   void operator()(boost::system::error_code ec, std::size_t)</a>
<a name="ln1320">   *   {</a>
<a name="ln1321">   *     // Put the underlying socket into non-blocking mode.</a>
<a name="ln1322">   *     if (!ec)</a>
<a name="ln1323">   *       if (!sock_.native_non_blocking())</a>
<a name="ln1324">   *         sock_.native_non_blocking(true, ec);</a>
<a name="ln1325">   *</a>
<a name="ln1326">   *     if (!ec)</a>
<a name="ln1327">   *     {</a>
<a name="ln1328">   *       for (;;)</a>
<a name="ln1329">   *       {</a>
<a name="ln1330">   *         // Try the system call.</a>
<a name="ln1331">   *         errno = 0;</a>
<a name="ln1332">   *         int n = ::sendfile(sock_.native_handle(), fd_, &amp;offset_, 65536);</a>
<a name="ln1333">   *         ec = boost::system::error_code(n &lt; 0 ? errno : 0,</a>
<a name="ln1334">   *             boost::asio::error::get_system_category());</a>
<a name="ln1335">   *         total_bytes_transferred_ += ec ? 0 : n;</a>
<a name="ln1336">   *</a>
<a name="ln1337">   *         // Retry operation immediately if interrupted by signal.</a>
<a name="ln1338">   *         if (ec == boost::asio::error::interrupted)</a>
<a name="ln1339">   *           continue;</a>
<a name="ln1340">   *</a>
<a name="ln1341">   *         // Check if we need to run the operation again.</a>
<a name="ln1342">   *         if (ec == boost::asio::error::would_block</a>
<a name="ln1343">   *             || ec == boost::asio::error::try_again)</a>
<a name="ln1344">   *         {</a>
<a name="ln1345">   *           // We have to wait for the socket to become ready again.</a>
<a name="ln1346">   *           sock_.async_wait(tcp::socket::wait_write, *this);</a>
<a name="ln1347">   *           return;</a>
<a name="ln1348">   *         }</a>
<a name="ln1349">   *</a>
<a name="ln1350">   *         if (ec || n == 0)</a>
<a name="ln1351">   *         {</a>
<a name="ln1352">   *           // An error occurred, or we have reached the end of the file.</a>
<a name="ln1353">   *           // Either way we must exit the loop so we can call the handler.</a>
<a name="ln1354">   *           break;</a>
<a name="ln1355">   *         }</a>
<a name="ln1356">   *</a>
<a name="ln1357">   *         // Loop around to try calling sendfile again.</a>
<a name="ln1358">   *       }</a>
<a name="ln1359">   *     }</a>
<a name="ln1360">   *</a>
<a name="ln1361">   *     // Pass result back to user's handler.</a>
<a name="ln1362">   *     handler_(ec, total_bytes_transferred_);</a>
<a name="ln1363">   *   }</a>
<a name="ln1364">   * };</a>
<a name="ln1365">   *</a>
<a name="ln1366">   * template &lt;typename Handler&gt;</a>
<a name="ln1367">   * void async_sendfile(tcp::socket&amp; sock, int fd, Handler h)</a>
<a name="ln1368">   * {</a>
<a name="ln1369">   *   sendfile_op&lt;Handler&gt; op = { sock, fd, h, 0, 0 };</a>
<a name="ln1370">   *   sock.async_wait(tcp::socket::wait_write, op);</a>
<a name="ln1371">   * } @endcode</a>
<a name="ln1372">   */</a>
<a name="ln1373">  void native_non_blocking(bool mode)</a>
<a name="ln1374">  {</a>
<a name="ln1375">    boost::system::error_code ec;</a>
<a name="ln1376">    this-&gt;get_service().native_non_blocking(</a>
<a name="ln1377">        this-&gt;get_implementation(), mode, ec);</a>
<a name="ln1378">    boost::asio::detail::throw_error(ec, &quot;native_non_blocking&quot;);</a>
<a name="ln1379">  }</a>
<a name="ln1380"> </a>
<a name="ln1381">  /// Sets the non-blocking mode of the native socket implementation.</a>
<a name="ln1382">  /**</a>
<a name="ln1383">   * This function is used to modify the non-blocking mode of the underlying</a>
<a name="ln1384">   * native socket. It has no effect on the behaviour of the socket object's</a>
<a name="ln1385">   * synchronous operations.</a>
<a name="ln1386">   *</a>
<a name="ln1387">   * @param mode If @c true, the underlying socket is put into non-blocking</a>
<a name="ln1388">   * mode and direct system calls may fail with boost::asio::error::would_block</a>
<a name="ln1389">   * (or the equivalent system error).</a>
<a name="ln1390">   *</a>
<a name="ln1391">   * @param ec Set to indicate what error occurred, if any. If the @c mode is</a>
<a name="ln1392">   * @c false, but the current value of @c non_blocking() is @c true, this</a>
<a name="ln1393">   * function fails with boost::asio::error::invalid_argument, as the</a>
<a name="ln1394">   * combination does not make sense.</a>
<a name="ln1395">   *</a>
<a name="ln1396">   * @par Example</a>
<a name="ln1397">   * This function is intended to allow the encapsulation of arbitrary</a>
<a name="ln1398">   * non-blocking system calls as asynchronous operations, in a way that is</a>
<a name="ln1399">   * transparent to the user of the socket object. The following example</a>
<a name="ln1400">   * illustrates how Linux's @c sendfile system call might be encapsulated:</a>
<a name="ln1401">   * @code template &lt;typename Handler&gt;</a>
<a name="ln1402">   * struct sendfile_op</a>
<a name="ln1403">   * {</a>
<a name="ln1404">   *   tcp::socket&amp; sock_;</a>
<a name="ln1405">   *   int fd_;</a>
<a name="ln1406">   *   Handler handler_;</a>
<a name="ln1407">   *   off_t offset_;</a>
<a name="ln1408">   *   std::size_t total_bytes_transferred_;</a>
<a name="ln1409">   *</a>
<a name="ln1410">   *   // Function call operator meeting WriteHandler requirements.</a>
<a name="ln1411">   *   // Used as the handler for the async_write_some operation.</a>
<a name="ln1412">   *   void operator()(boost::system::error_code ec, std::size_t)</a>
<a name="ln1413">   *   {</a>
<a name="ln1414">   *     // Put the underlying socket into non-blocking mode.</a>
<a name="ln1415">   *     if (!ec)</a>
<a name="ln1416">   *       if (!sock_.native_non_blocking())</a>
<a name="ln1417">   *         sock_.native_non_blocking(true, ec);</a>
<a name="ln1418">   *</a>
<a name="ln1419">   *     if (!ec)</a>
<a name="ln1420">   *     {</a>
<a name="ln1421">   *       for (;;)</a>
<a name="ln1422">   *       {</a>
<a name="ln1423">   *         // Try the system call.</a>
<a name="ln1424">   *         errno = 0;</a>
<a name="ln1425">   *         int n = ::sendfile(sock_.native_handle(), fd_, &amp;offset_, 65536);</a>
<a name="ln1426">   *         ec = boost::system::error_code(n &lt; 0 ? errno : 0,</a>
<a name="ln1427">   *             boost::asio::error::get_system_category());</a>
<a name="ln1428">   *         total_bytes_transferred_ += ec ? 0 : n;</a>
<a name="ln1429">   *</a>
<a name="ln1430">   *         // Retry operation immediately if interrupted by signal.</a>
<a name="ln1431">   *         if (ec == boost::asio::error::interrupted)</a>
<a name="ln1432">   *           continue;</a>
<a name="ln1433">   *</a>
<a name="ln1434">   *         // Check if we need to run the operation again.</a>
<a name="ln1435">   *         if (ec == boost::asio::error::would_block</a>
<a name="ln1436">   *             || ec == boost::asio::error::try_again)</a>
<a name="ln1437">   *         {</a>
<a name="ln1438">   *           // We have to wait for the socket to become ready again.</a>
<a name="ln1439">   *           sock_.async_wait(tcp::socket::wait_write, *this);</a>
<a name="ln1440">   *           return;</a>
<a name="ln1441">   *         }</a>
<a name="ln1442">   *</a>
<a name="ln1443">   *         if (ec || n == 0)</a>
<a name="ln1444">   *         {</a>
<a name="ln1445">   *           // An error occurred, or we have reached the end of the file.</a>
<a name="ln1446">   *           // Either way we must exit the loop so we can call the handler.</a>
<a name="ln1447">   *           break;</a>
<a name="ln1448">   *         }</a>
<a name="ln1449">   *</a>
<a name="ln1450">   *         // Loop around to try calling sendfile again.</a>
<a name="ln1451">   *       }</a>
<a name="ln1452">   *     }</a>
<a name="ln1453">   *</a>
<a name="ln1454">   *     // Pass result back to user's handler.</a>
<a name="ln1455">   *     handler_(ec, total_bytes_transferred_);</a>
<a name="ln1456">   *   }</a>
<a name="ln1457">   * };</a>
<a name="ln1458">   *</a>
<a name="ln1459">   * template &lt;typename Handler&gt;</a>
<a name="ln1460">   * void async_sendfile(tcp::socket&amp; sock, int fd, Handler h)</a>
<a name="ln1461">   * {</a>
<a name="ln1462">   *   sendfile_op&lt;Handler&gt; op = { sock, fd, h, 0, 0 };</a>
<a name="ln1463">   *   sock.async_wait(tcp::socket::wait_write, op);</a>
<a name="ln1464">   * } @endcode</a>
<a name="ln1465">   */</a>
<a name="ln1466">  BOOST_ASIO_SYNC_OP_VOID native_non_blocking(</a>
<a name="ln1467">      bool mode, boost::system::error_code&amp; ec)</a>
<a name="ln1468">  {</a>
<a name="ln1469">    this-&gt;get_service().native_non_blocking(</a>
<a name="ln1470">        this-&gt;get_implementation(), mode, ec);</a>
<a name="ln1471">    BOOST_ASIO_SYNC_OP_VOID_RETURN(ec);</a>
<a name="ln1472">  }</a>
<a name="ln1473"> </a>
<a name="ln1474">  /// Get the local endpoint of the socket.</a>
<a name="ln1475">  /**</a>
<a name="ln1476">   * This function is used to obtain the locally bound endpoint of the socket.</a>
<a name="ln1477">   *</a>
<a name="ln1478">   * @returns An object that represents the local endpoint of the socket.</a>
<a name="ln1479">   *</a>
<a name="ln1480">   * @throws boost::system::system_error Thrown on failure.</a>
<a name="ln1481">   *</a>
<a name="ln1482">   * @par Example</a>
<a name="ln1483">   * @code</a>
<a name="ln1484">   * boost::asio::ip::tcp::socket socket(io_context);</a>
<a name="ln1485">   * ...</a>
<a name="ln1486">   * boost::asio::ip::tcp::endpoint endpoint = socket.local_endpoint();</a>
<a name="ln1487">   * @endcode</a>
<a name="ln1488">   */</a>
<a name="ln1489">  endpoint_type local_endpoint() const</a>
<a name="ln1490">  {</a>
<a name="ln1491">    boost::system::error_code ec;</a>
<a name="ln1492">    endpoint_type ep = this-&gt;get_service().local_endpoint(</a>
<a name="ln1493">        this-&gt;get_implementation(), ec);</a>
<a name="ln1494">    boost::asio::detail::throw_error(ec, &quot;local_endpoint&quot;);</a>
<a name="ln1495">    return ep;</a>
<a name="ln1496">  }</a>
<a name="ln1497"> </a>
<a name="ln1498">  /// Get the local endpoint of the socket.</a>
<a name="ln1499">  /**</a>
<a name="ln1500">   * This function is used to obtain the locally bound endpoint of the socket.</a>
<a name="ln1501">   *</a>
<a name="ln1502">   * @param ec Set to indicate what error occurred, if any.</a>
<a name="ln1503">   *</a>
<a name="ln1504">   * @returns An object that represents the local endpoint of the socket.</a>
<a name="ln1505">   * Returns a default-constructed endpoint object if an error occurred.</a>
<a name="ln1506">   *</a>
<a name="ln1507">   * @par Example</a>
<a name="ln1508">   * @code</a>
<a name="ln1509">   * boost::asio::ip::tcp::socket socket(io_context);</a>
<a name="ln1510">   * ...</a>
<a name="ln1511">   * boost::system::error_code ec;</a>
<a name="ln1512">   * boost::asio::ip::tcp::endpoint endpoint = socket.local_endpoint(ec);</a>
<a name="ln1513">   * if (ec)</a>
<a name="ln1514">   * {</a>
<a name="ln1515">   *   // An error occurred.</a>
<a name="ln1516">   * }</a>
<a name="ln1517">   * @endcode</a>
<a name="ln1518">   */</a>
<a name="ln1519">  endpoint_type local_endpoint(boost::system::error_code&amp; ec) const</a>
<a name="ln1520">  {</a>
<a name="ln1521">    return this-&gt;get_service().local_endpoint(this-&gt;get_implementation(), ec);</a>
<a name="ln1522">  }</a>
<a name="ln1523"> </a>
<a name="ln1524">  /// Get the remote endpoint of the socket.</a>
<a name="ln1525">  /**</a>
<a name="ln1526">   * This function is used to obtain the remote endpoint of the socket.</a>
<a name="ln1527">   *</a>
<a name="ln1528">   * @returns An object that represents the remote endpoint of the socket.</a>
<a name="ln1529">   *</a>
<a name="ln1530">   * @throws boost::system::system_error Thrown on failure.</a>
<a name="ln1531">   *</a>
<a name="ln1532">   * @par Example</a>
<a name="ln1533">   * @code</a>
<a name="ln1534">   * boost::asio::ip::tcp::socket socket(io_context);</a>
<a name="ln1535">   * ...</a>
<a name="ln1536">   * boost::asio::ip::tcp::endpoint endpoint = socket.remote_endpoint();</a>
<a name="ln1537">   * @endcode</a>
<a name="ln1538">   */</a>
<a name="ln1539">  endpoint_type remote_endpoint() const</a>
<a name="ln1540">  {</a>
<a name="ln1541">    boost::system::error_code ec;</a>
<a name="ln1542">    endpoint_type ep = this-&gt;get_service().remote_endpoint(</a>
<a name="ln1543">        this-&gt;get_implementation(), ec);</a>
<a name="ln1544">    boost::asio::detail::throw_error(ec, &quot;remote_endpoint&quot;);</a>
<a name="ln1545">    return ep;</a>
<a name="ln1546">  }</a>
<a name="ln1547"> </a>
<a name="ln1548">  /// Get the remote endpoint of the socket.</a>
<a name="ln1549">  /**</a>
<a name="ln1550">   * This function is used to obtain the remote endpoint of the socket.</a>
<a name="ln1551">   *</a>
<a name="ln1552">   * @param ec Set to indicate what error occurred, if any.</a>
<a name="ln1553">   *</a>
<a name="ln1554">   * @returns An object that represents the remote endpoint of the socket.</a>
<a name="ln1555">   * Returns a default-constructed endpoint object if an error occurred.</a>
<a name="ln1556">   *</a>
<a name="ln1557">   * @par Example</a>
<a name="ln1558">   * @code</a>
<a name="ln1559">   * boost::asio::ip::tcp::socket socket(io_context);</a>
<a name="ln1560">   * ...</a>
<a name="ln1561">   * boost::system::error_code ec;</a>
<a name="ln1562">   * boost::asio::ip::tcp::endpoint endpoint = socket.remote_endpoint(ec);</a>
<a name="ln1563">   * if (ec)</a>
<a name="ln1564">   * {</a>
<a name="ln1565">   *   // An error occurred.</a>
<a name="ln1566">   * }</a>
<a name="ln1567">   * @endcode</a>
<a name="ln1568">   */</a>
<a name="ln1569">  endpoint_type remote_endpoint(boost::system::error_code&amp; ec) const</a>
<a name="ln1570">  {</a>
<a name="ln1571">    return this-&gt;get_service().remote_endpoint(this-&gt;get_implementation(), ec);</a>
<a name="ln1572">  }</a>
<a name="ln1573"> </a>
<a name="ln1574">  /// Disable sends or receives on the socket.</a>
<a name="ln1575">  /**</a>
<a name="ln1576">   * This function is used to disable send operations, receive operations, or</a>
<a name="ln1577">   * both.</a>
<a name="ln1578">   *</a>
<a name="ln1579">   * @param what Determines what types of operation will no longer be allowed.</a>
<a name="ln1580">   *</a>
<a name="ln1581">   * @throws boost::system::system_error Thrown on failure.</a>
<a name="ln1582">   *</a>
<a name="ln1583">   * @par Example</a>
<a name="ln1584">   * Shutting down the send side of the socket:</a>
<a name="ln1585">   * @code</a>
<a name="ln1586">   * boost::asio::ip::tcp::socket socket(io_context);</a>
<a name="ln1587">   * ...</a>
<a name="ln1588">   * socket.shutdown(boost::asio::ip::tcp::socket::shutdown_send);</a>
<a name="ln1589">   * @endcode</a>
<a name="ln1590">   */</a>
<a name="ln1591">  void shutdown(shutdown_type what)</a>
<a name="ln1592">  {</a>
<a name="ln1593">    boost::system::error_code ec;</a>
<a name="ln1594">    this-&gt;get_service().shutdown(this-&gt;get_implementation(), what, ec);</a>
<a name="ln1595">    boost::asio::detail::throw_error(ec, &quot;shutdown&quot;);</a>
<a name="ln1596">  }</a>
<a name="ln1597"> </a>
<a name="ln1598">  /// Disable sends or receives on the socket.</a>
<a name="ln1599">  /**</a>
<a name="ln1600">   * This function is used to disable send operations, receive operations, or</a>
<a name="ln1601">   * both.</a>
<a name="ln1602">   *</a>
<a name="ln1603">   * @param what Determines what types of operation will no longer be allowed.</a>
<a name="ln1604">   *</a>
<a name="ln1605">   * @param ec Set to indicate what error occurred, if any.</a>
<a name="ln1606">   *</a>
<a name="ln1607">   * @par Example</a>
<a name="ln1608">   * Shutting down the send side of the socket:</a>
<a name="ln1609">   * @code</a>
<a name="ln1610">   * boost::asio::ip::tcp::socket socket(io_context);</a>
<a name="ln1611">   * ...</a>
<a name="ln1612">   * boost::system::error_code ec;</a>
<a name="ln1613">   * socket.shutdown(boost::asio::ip::tcp::socket::shutdown_send, ec);</a>
<a name="ln1614">   * if (ec)</a>
<a name="ln1615">   * {</a>
<a name="ln1616">   *   // An error occurred.</a>
<a name="ln1617">   * }</a>
<a name="ln1618">   * @endcode</a>
<a name="ln1619">   */</a>
<a name="ln1620">  BOOST_ASIO_SYNC_OP_VOID shutdown(shutdown_type what,</a>
<a name="ln1621">      boost::system::error_code&amp; ec)</a>
<a name="ln1622">  {</a>
<a name="ln1623">    this-&gt;get_service().shutdown(this-&gt;get_implementation(), what, ec);</a>
<a name="ln1624">    BOOST_ASIO_SYNC_OP_VOID_RETURN(ec);</a>
<a name="ln1625">  }</a>
<a name="ln1626"> </a>
<a name="ln1627">  /// Wait for the socket to become ready to read, ready to write, or to have</a>
<a name="ln1628">  /// pending error conditions.</a>
<a name="ln1629">  /**</a>
<a name="ln1630">   * This function is used to perform a blocking wait for a socket to enter</a>
<a name="ln1631">   * a ready to read, write or error condition state.</a>
<a name="ln1632">   *</a>
<a name="ln1633">   * @param w Specifies the desired socket state.</a>
<a name="ln1634">   *</a>
<a name="ln1635">   * @par Example</a>
<a name="ln1636">   * Waiting for a socket to become readable.</a>
<a name="ln1637">   * @code</a>
<a name="ln1638">   * boost::asio::ip::tcp::socket socket(io_context);</a>
<a name="ln1639">   * ...</a>
<a name="ln1640">   * socket.wait(boost::asio::ip::tcp::socket::wait_read);</a>
<a name="ln1641">   * @endcode</a>
<a name="ln1642">   */</a>
<a name="ln1643">  void wait(wait_type w)</a>
<a name="ln1644">  {</a>
<a name="ln1645">    boost::system::error_code ec;</a>
<a name="ln1646">    this-&gt;get_service().wait(this-&gt;get_implementation(), w, ec);</a>
<a name="ln1647">    boost::asio::detail::throw_error(ec, &quot;wait&quot;);</a>
<a name="ln1648">  }</a>
<a name="ln1649"> </a>
<a name="ln1650">  /// Wait for the socket to become ready to read, ready to write, or to have</a>
<a name="ln1651">  /// pending error conditions.</a>
<a name="ln1652">  /**</a>
<a name="ln1653">   * This function is used to perform a blocking wait for a socket to enter</a>
<a name="ln1654">   * a ready to read, write or error condition state.</a>
<a name="ln1655">   *</a>
<a name="ln1656">   * @param w Specifies the desired socket state.</a>
<a name="ln1657">   *</a>
<a name="ln1658">   * @param ec Set to indicate what error occurred, if any.</a>
<a name="ln1659">   *</a>
<a name="ln1660">   * @par Example</a>
<a name="ln1661">   * Waiting for a socket to become readable.</a>
<a name="ln1662">   * @code</a>
<a name="ln1663">   * boost::asio::ip::tcp::socket socket(io_context);</a>
<a name="ln1664">   * ...</a>
<a name="ln1665">   * boost::system::error_code ec;</a>
<a name="ln1666">   * socket.wait(boost::asio::ip::tcp::socket::wait_read, ec);</a>
<a name="ln1667">   * @endcode</a>
<a name="ln1668">   */</a>
<a name="ln1669">  BOOST_ASIO_SYNC_OP_VOID wait(wait_type w, boost::system::error_code&amp; ec)</a>
<a name="ln1670">  {</a>
<a name="ln1671">    this-&gt;get_service().wait(this-&gt;get_implementation(), w, ec);</a>
<a name="ln1672">    BOOST_ASIO_SYNC_OP_VOID_RETURN(ec);</a>
<a name="ln1673">  }</a>
<a name="ln1674"> </a>
<a name="ln1675">  /// Asynchronously wait for the socket to become ready to read, ready to</a>
<a name="ln1676">  /// write, or to have pending error conditions.</a>
<a name="ln1677">  /**</a>
<a name="ln1678">   * This function is used to perform an asynchronous wait for a socket to enter</a>
<a name="ln1679">   * a ready to read, write or error condition state.</a>
<a name="ln1680">   *</a>
<a name="ln1681">   * @param w Specifies the desired socket state.</a>
<a name="ln1682">   *</a>
<a name="ln1683">   * @param handler The handler to be called when the wait operation completes.</a>
<a name="ln1684">   * Copies will be made of the handler as required. The function signature of</a>
<a name="ln1685">   * the handler must be:</a>
<a name="ln1686">   * @code void handler(</a>
<a name="ln1687">   *   const boost::system::error_code&amp; error // Result of operation</a>
<a name="ln1688">   * ); @endcode</a>
<a name="ln1689">   * Regardless of whether the asynchronous operation completes immediately or</a>
<a name="ln1690">   * not, the handler will not be invoked from within this function. Invocation</a>
<a name="ln1691">   * of the handler will be performed in a manner equivalent to using</a>
<a name="ln1692">   * boost::asio::io_context::post().</a>
<a name="ln1693">   *</a>
<a name="ln1694">   * @par Example</a>
<a name="ln1695">   * @code</a>
<a name="ln1696">   * void wait_handler(const boost::system::error_code&amp; error)</a>
<a name="ln1697">   * {</a>
<a name="ln1698">   *   if (!error)</a>
<a name="ln1699">   *   {</a>
<a name="ln1700">   *     // Wait succeeded.</a>
<a name="ln1701">   *   }</a>
<a name="ln1702">   * }</a>
<a name="ln1703">   *</a>
<a name="ln1704">   * ...</a>
<a name="ln1705">   *</a>
<a name="ln1706">   * boost::asio::ip::tcp::socket socket(io_context);</a>
<a name="ln1707">   * ...</a>
<a name="ln1708">   * socket.async_wait(boost::asio::ip::tcp::socket::wait_read, wait_handler);</a>
<a name="ln1709">   * @endcode</a>
<a name="ln1710">   */</a>
<a name="ln1711">  template &lt;typename WaitHandler&gt;</a>
<a name="ln1712">  BOOST_ASIO_INITFN_RESULT_TYPE(WaitHandler,</a>
<a name="ln1713">      void (boost::system::error_code))</a>
<a name="ln1714">  async_wait(wait_type w, BOOST_ASIO_MOVE_ARG(WaitHandler) handler)</a>
<a name="ln1715">  {</a>
<a name="ln1716">    // If you get an error on the following line it means that your handler does</a>
<a name="ln1717">    // not meet the documented type requirements for a WaitHandler.</a>
<a name="ln1718">    BOOST_ASIO_WAIT_HANDLER_CHECK(WaitHandler, handler) type_check;</a>
<a name="ln1719"> </a>
<a name="ln1720">#if defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln1721">    return this-&gt;get_service().async_wait(this-&gt;get_implementation(),</a>
<a name="ln1722">        w, BOOST_ASIO_MOVE_CAST(WaitHandler)(handler));</a>
<a name="ln1723">#else // defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln1724">    async_completion&lt;WaitHandler,</a>
<a name="ln1725">      void (boost::system::error_code)&gt; init(handler);</a>
<a name="ln1726"> </a>
<a name="ln1727">    this-&gt;get_service().async_wait(this-&gt;get_implementation(),</a>
<a name="ln1728">        w, init.completion_handler);</a>
<a name="ln1729"> </a>
<a name="ln1730">    return init.result.get();</a>
<a name="ln1731">#endif // defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln1732">  }</a>
<a name="ln1733"> </a>
<a name="ln1734">protected:</a>
<a name="ln1735">  /// Protected destructor to prevent deletion through this type.</a>
<a name="ln1736">  /**</a>
<a name="ln1737">   * This function destroys the socket, cancelling any outstanding asynchronous</a>
<a name="ln1738">   * operations associated with the socket as if by calling @c cancel.</a>
<a name="ln1739">   */</a>
<a name="ln1740">  ~basic_socket()</a>
<a name="ln1741">  {</a>
<a name="ln1742">  }</a>
<a name="ln1743"> </a>
<a name="ln1744">private:</a>
<a name="ln1745">  // Disallow copying and assignment.</a>
<a name="ln1746">  basic_socket(const basic_socket&amp;) BOOST_ASIO_DELETED;</a>
<a name="ln1747">  basic_socket&amp; operator=(const basic_socket&amp;) BOOST_ASIO_DELETED;</a>
<a name="ln1748">};</a>
<a name="ln1749"> </a>
<a name="ln1750">} // namespace asio</a>
<a name="ln1751">} // namespace boost</a>
<a name="ln1752"> </a>
<a name="ln1753">#include &lt;boost/asio/detail/pop_options.hpp&gt;</a>
<a name="ln1754"> </a>
<a name="ln1755">#if !defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln1756"># undef BOOST_ASIO_SVC_T</a>
<a name="ln1757">#endif // !defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln1758"> </a>
<a name="ln1759">#endif // BOOST_ASIO_BASIC_SOCKET_HPP</a>

</code></pre>
<div class="balloon" rel="141"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v779/" target="_blank">V779</a> Unreachable code detected. It is possible that an error is present.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
