
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>db_stress.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//  Copyright (c) 2011-present, Facebook, Inc.  All rights reserved.</a>
<a name="ln2">//  This source code is licensed under the BSD-style license found in the</a>
<a name="ln3">//  LICENSE file in the root directory of this source tree. An additional grant</a>
<a name="ln4">//  of patent rights can be found in the PATENTS file in the same directory.</a>
<a name="ln5">//</a>
<a name="ln6">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln7">//</a>
<a name="ln8">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln9">//</a>
<a name="ln10">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln11">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln12">//</a>
<a name="ln13">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln14">//</a>
<a name="ln15">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln16">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln17">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln18">// under the License.</a>
<a name="ln19">//</a>
<a name="ln20">// Copyright (c) 2011 The LevelDB Authors. All rights reserved.</a>
<a name="ln21">// Use of this source code is governed by a BSD-style license that can be</a>
<a name="ln22">// found in the LICENSE file. See the AUTHORS file for names of contributors.</a>
<a name="ln23">//</a>
<a name="ln24">// The test uses an array to compare against values written to the database.</a>
<a name="ln25">// Keys written to the array are in 1:1 correspondence to the actual values in</a>
<a name="ln26">// the database according to the formula in the function GenerateValue.</a>
<a name="ln27"> </a>
<a name="ln28">// Space is reserved in the array from 0 to FLAGS_max_key and values are</a>
<a name="ln29">// randomly written/deleted/read from those positions. During verification we</a>
<a name="ln30">// compare all the positions in the array. To shorten/elongate the running</a>
<a name="ln31">// time, you could change the settings: FLAGS_max_key, FLAGS_ops_per_thread,</a>
<a name="ln32">// (sometimes also FLAGS_threads).</a>
<a name="ln33">//</a>
<a name="ln34">// NOTE that if FLAGS_test_batches_snapshots is set, the test will have</a>
<a name="ln35">// different behavior. See comment of the flag for details.</a>
<a name="ln36"> </a>
<a name="ln37">#ifndef GFLAGS</a>
<a name="ln38">#include &lt;cstdio&gt;</a>
<a name="ln39">int main() {</a>
<a name="ln40">  fprintf(stderr, &quot;Please install gflags to run rocksdb tools\n&quot;);</a>
<a name="ln41">  return 1;</a>
<a name="ln42">}</a>
<a name="ln43">#else</a>
<a name="ln44"> </a>
<a name="ln45">#ifndef __STDC_FORMAT_MACROS</a>
<a name="ln46">#define __STDC_FORMAT_MACROS</a>
<a name="ln47">#endif</a>
<a name="ln48"> </a>
<a name="ln49">#include &lt;inttypes.h&gt;</a>
<a name="ln50">#include &lt;stdio.h&gt;</a>
<a name="ln51">#include &lt;stdlib.h&gt;</a>
<a name="ln52">#include &lt;sys/types.h&gt;</a>
<a name="ln53">#include &lt;chrono&gt;</a>
<a name="ln54">#include &lt;exception&gt;</a>
<a name="ln55">#include &lt;thread&gt;</a>
<a name="ln56"> </a>
<a name="ln57">#include &lt;gflags/gflags.h&gt;</a>
<a name="ln58">#include &quot;yb/rocksdb/db/db_impl.h&quot;</a>
<a name="ln59">#include &quot;yb/rocksdb/db/version_set.h&quot;</a>
<a name="ln60">#include &quot;yb/rocksdb/hdfs/env_hdfs.h&quot;</a>
<a name="ln61">#include &quot;yb/rocksdb/port/port.h&quot;</a>
<a name="ln62">#include &quot;yb/rocksdb/cache.h&quot;</a>
<a name="ln63">#include &quot;yb/rocksdb/env.h&quot;</a>
<a name="ln64">#include &quot;yb/util/slice.h&quot;</a>
<a name="ln65">#include &quot;yb/rocksdb/slice_transform.h&quot;</a>
<a name="ln66">#include &quot;yb/rocksdb/statistics.h&quot;</a>
<a name="ln67">#include &quot;yb/rocksdb/utilities/db_ttl.h&quot;</a>
<a name="ln68">#include &quot;yb/rocksdb/write_batch.h&quot;</a>
<a name="ln69">#include &quot;yb/rocksdb/util/coding.h&quot;</a>
<a name="ln70">#include &quot;yb/rocksdb/util/compression.h&quot;</a>
<a name="ln71">#include &quot;yb/rocksdb/util/crc32c.h&quot;</a>
<a name="ln72">#include &quot;yb/rocksdb/util/histogram.h&quot;</a>
<a name="ln73">#include &quot;yb/rocksdb/util/logging.h&quot;</a>
<a name="ln74">#include &quot;yb/rocksdb/util/mutexlock.h&quot;</a>
<a name="ln75">#include &quot;yb/rocksdb/util/random.h&quot;</a>
<a name="ln76">#include &quot;yb/util/string_util.h&quot;</a>
<a name="ln77">#include &quot;yb/rocksdb/util/testutil.h&quot;</a>
<a name="ln78">#include &quot;yb/rocksdb/utilities/merge_operators.h&quot;</a>
<a name="ln79"> </a>
<a name="ln80">using GFLAGS::ParseCommandLineFlags;</a>
<a name="ln81">using GFLAGS::RegisterFlagValidator;</a>
<a name="ln82">using GFLAGS::SetUsageMessage;</a>
<a name="ln83"> </a>
<a name="ln84">static const int64_t KB = 1024;</a>
<a name="ln85"> </a>
<a name="ln86">static bool ValidateUint32Range(const char* flagname, uint64_t value) {</a>
<a name="ln87">  if (value &gt; std::numeric_limits&lt;uint32_t&gt;::max()) {</a>
<a name="ln88">    fprintf(stderr,</a>
<a name="ln89">            &quot;Invalid value for --%s: %&quot; PRIu64 &quot;, overflow\n&quot;,</a>
<a name="ln90">            flagname,</a>
<a name="ln91">            value);</a>
<a name="ln92">    return false;</a>
<a name="ln93">  }</a>
<a name="ln94">  return true;</a>
<a name="ln95">}</a>
<a name="ln96"> </a>
<a name="ln97">DEFINE_uint64(seed, 2341234, &quot;Seed for PRNG&quot;);</a>
<a name="ln98">static const bool FLAGS_seed_dummy __attribute__((unused)) =</a>
<a name="ln99">    RegisterFlagValidator(&amp;FLAGS_seed, &amp;ValidateUint32Range);</a>
<a name="ln100"> </a>
<a name="ln101">DEFINE_int64(max_key, 1 * KB* KB,</a>
<a name="ln102">             &quot;Max number of key/values to place in database&quot;);</a>
<a name="ln103"> </a>
<a name="ln104">DEFINE_int32(column_families, 10, &quot;Number of column families&quot;);</a>
<a name="ln105"> </a>
<a name="ln106">// TODO(noetzli) Add support for single deletes</a>
<a name="ln107">DEFINE_bool(test_batches_snapshots, false,</a>
<a name="ln108">            &quot;If set, the test uses MultiGet(), MultiPut() and MultiDelete()&quot;</a>
<a name="ln109">            &quot; which read/write/delete multiple keys in a batch. In this mode,&quot;</a>
<a name="ln110">            &quot; we do not verify db content by comparing the content with the &quot;</a>
<a name="ln111">            &quot;pre-allocated array. Instead, we do partial verification inside&quot;</a>
<a name="ln112">            &quot; MultiGet() by checking various values in a batch. Benefit of&quot;</a>
<a name="ln113">            &quot; this mode:\n&quot;</a>
<a name="ln114">            &quot;\t(a) No need to acquire mutexes during writes (less cache &quot;</a>
<a name="ln115">            &quot;flushes in multi-core leading to speed up)\n&quot;</a>
<a name="ln116">            &quot;\t(b) No long validation at the end (more speed up)\n&quot;</a>
<a name="ln117">            &quot;\t(c) Test snapshot and atomicity of batch writes&quot;);</a>
<a name="ln118"> </a>
<a name="ln119">DEFINE_int32(threads, 32, &quot;Number of concurrent threads to run.&quot;);</a>
<a name="ln120"> </a>
<a name="ln121">DEFINE_int32(ttl, -1,</a>
<a name="ln122">             &quot;Opens the db with this ttl value if this is not -1. &quot;</a>
<a name="ln123">             &quot;Carefully specify a large value such that verifications on &quot;</a>
<a name="ln124">             &quot;deleted values don't fail&quot;);</a>
<a name="ln125"> </a>
<a name="ln126">DEFINE_int32(value_size_mult, 8,</a>
<a name="ln127">             &quot;Size of value will be this number times rand_int(1,3) bytes&quot;);</a>
<a name="ln128"> </a>
<a name="ln129">DEFINE_bool(verify_before_write, false, &quot;Verify before write&quot;);</a>
<a name="ln130"> </a>
<a name="ln131">DEFINE_bool(histogram, false, &quot;Print histogram of operation timings&quot;);</a>
<a name="ln132"> </a>
<a name="ln133">DEFINE_bool(destroy_db_initially, true,</a>
<a name="ln134">            &quot;Destroys the database dir before start if this is true&quot;);</a>
<a name="ln135"> </a>
<a name="ln136">DEFINE_bool(verbose, false, &quot;Verbose&quot;);</a>
<a name="ln137"> </a>
<a name="ln138">DEFINE_bool(progress_reports, true,</a>
<a name="ln139">            &quot;If true, db_stress will report number of finished operations&quot;);</a>
<a name="ln140"> </a>
<a name="ln141">DEFINE_uint64(db_write_buffer_size, rocksdb::Options().db_write_buffer_size,</a>
<a name="ln142">              &quot;Number of bytes to buffer in all memtables before compacting&quot;);</a>
<a name="ln143"> </a>
<a name="ln144">DEFINE_int32(write_buffer_size,</a>
<a name="ln145">             static_cast&lt;int32_t&gt;(rocksdb::Options().write_buffer_size),</a>
<a name="ln146">             &quot;Number of bytes to buffer in memtable before compacting&quot;);</a>
<a name="ln147"> </a>
<a name="ln148">DEFINE_int32(max_write_buffer_number,</a>
<a name="ln149">             rocksdb::Options().max_write_buffer_number,</a>
<a name="ln150">             &quot;The number of in-memory memtables. &quot;</a>
<a name="ln151">             &quot;Each memtable is of size FLAGS_write_buffer_size.&quot;);</a>
<a name="ln152"> </a>
<a name="ln153">DEFINE_int32(min_write_buffer_number_to_merge,</a>
<a name="ln154">             rocksdb::Options().min_write_buffer_number_to_merge,</a>
<a name="ln155">             &quot;The minimum number of write buffers that will be merged together &quot;</a>
<a name="ln156">             &quot;before writing to storage. This is cheap because it is an &quot;</a>
<a name="ln157">             &quot;in-memory merge. If this feature is not enabled, then all these &quot;</a>
<a name="ln158">             &quot;write buffers are flushed to L0 as separate files and this &quot;</a>
<a name="ln159">             &quot;increases read amplification because a get request has to check &quot;</a>
<a name="ln160">             &quot;in all of these files. Also, an in-memory merge may result in &quot;</a>
<a name="ln161">             &quot;writing less data to storage if there are duplicate records in&quot;</a>
<a name="ln162">             &quot; each of these individual write buffers.&quot;);</a>
<a name="ln163"> </a>
<a name="ln164">DEFINE_int32(max_write_buffer_number_to_maintain,</a>
<a name="ln165">             rocksdb::Options().max_write_buffer_number_to_maintain,</a>
<a name="ln166">             &quot;The total maximum number of write buffers to maintain in memory &quot;</a>
<a name="ln167">             &quot;including copies of buffers that have already been flushed. &quot;</a>
<a name="ln168">             &quot;Unlike max_write_buffer_number, this parameter does not affect &quot;</a>
<a name="ln169">             &quot;flushing. This controls the minimum amount of write history &quot;</a>
<a name="ln170">             &quot;that will be available in memory for conflict checking when &quot;</a>
<a name="ln171">             &quot;Transactions are used. If this value is too low, some &quot;</a>
<a name="ln172">             &quot;transactions may fail at commit time due to not being able to &quot;</a>
<a name="ln173">             &quot;determine whether there were any write conflicts. Setting this &quot;</a>
<a name="ln174">             &quot;value to 0 will cause write buffers to be freed immediately &quot;</a>
<a name="ln175">             &quot;after they are flushed.  If this value is set to -1, &quot;</a>
<a name="ln176">             &quot;'max_write_buffer_number' will be used.&quot;);</a>
<a name="ln177"> </a>
<a name="ln178">DEFINE_int32(open_files, rocksdb::Options().max_open_files,</a>
<a name="ln179">             &quot;Maximum number of files to keep open at the same time &quot;</a>
<a name="ln180">             &quot;(use default if == 0)&quot;);</a>
<a name="ln181"> </a>
<a name="ln182">DEFINE_int64(compressed_cache_size, -1,</a>
<a name="ln183">             &quot;Number of bytes to use as a cache of compressed data.&quot;</a>
<a name="ln184">             &quot; Negative means use default settings.&quot;);</a>
<a name="ln185"> </a>
<a name="ln186">DEFINE_int32(compaction_style, rocksdb::Options().compaction_style, &quot;&quot;);</a>
<a name="ln187"> </a>
<a name="ln188">DEFINE_int32(level0_file_num_compaction_trigger,</a>
<a name="ln189">             rocksdb::Options().level0_file_num_compaction_trigger,</a>
<a name="ln190">             &quot;Level0 compaction start trigger&quot;);</a>
<a name="ln191"> </a>
<a name="ln192">DEFINE_int32(level0_slowdown_writes_trigger,</a>
<a name="ln193">             rocksdb::Options().level0_slowdown_writes_trigger,</a>
<a name="ln194">             &quot;Number of files in level-0 that will slow down writes&quot;);</a>
<a name="ln195"> </a>
<a name="ln196">DEFINE_int32(level0_stop_writes_trigger,</a>
<a name="ln197">             rocksdb::Options().level0_stop_writes_trigger,</a>
<a name="ln198">             &quot;Number of files in level-0 that will trigger put stop.&quot;);</a>
<a name="ln199"> </a>
<a name="ln200">DEFINE_int32(block_size,</a>
<a name="ln201">             static_cast&lt;int32_t&gt;(rocksdb::BlockBasedTableOptions().block_size),</a>
<a name="ln202">             &quot;Number of bytes in a block.&quot;);</a>
<a name="ln203"> </a>
<a name="ln204">DEFINE_int32(max_background_compactions,</a>
<a name="ln205">             rocksdb::Options().max_background_compactions,</a>
<a name="ln206">             &quot;The maximum number of concurrent background compactions &quot;</a>
<a name="ln207">             &quot;that can occur in parallel.&quot;);</a>
<a name="ln208"> </a>
<a name="ln209">DEFINE_int32(compaction_thread_pool_adjust_interval, 0,</a>
<a name="ln210">             &quot;The interval (in milliseconds) to adjust compaction thread pool &quot;</a>
<a name="ln211">             &quot;size. Don't change it periodically if the value is 0.&quot;);</a>
<a name="ln212"> </a>
<a name="ln213">DEFINE_int32(compaction_thread_pool_variations, 2,</a>
<a name="ln214">             &quot;Range of background thread pool size variations when adjusted &quot;</a>
<a name="ln215">             &quot;periodically.&quot;);</a>
<a name="ln216"> </a>
<a name="ln217">DEFINE_int32(max_background_flushes, rocksdb::Options().max_background_flushes,</a>
<a name="ln218">             &quot;The maximum number of concurrent background flushes &quot;</a>
<a name="ln219">             &quot;that can occur in parallel.&quot;);</a>
<a name="ln220"> </a>
<a name="ln221">DEFINE_int32(universal_size_ratio, 0, &quot;The ratio of file sizes that trigger&quot;</a>
<a name="ln222">             &quot; compaction in universal style&quot;);</a>
<a name="ln223"> </a>
<a name="ln224">DEFINE_int32(universal_min_merge_width, 0, &quot;The minimum number of files to &quot;</a>
<a name="ln225">             &quot;compact in universal style compaction&quot;);</a>
<a name="ln226"> </a>
<a name="ln227">DEFINE_int32(universal_max_merge_width, 0, &quot;The max number of files to compact&quot;</a>
<a name="ln228">             &quot; in universal style compaction&quot;);</a>
<a name="ln229"> </a>
<a name="ln230">DEFINE_int32(universal_max_size_amplification_percent, 0,</a>
<a name="ln231">             &quot;The max size amplification for universal style compaction&quot;);</a>
<a name="ln232"> </a>
<a name="ln233">DEFINE_int32(clear_column_family_one_in, 1000000,</a>
<a name="ln234">             &quot;With a chance of 1/N, delete a column family and then recreate &quot;</a>
<a name="ln235">             &quot;it again. If N == 0, never drop/create column families. &quot;</a>
<a name="ln236">             &quot;When test_batches_snapshots is true, this flag has no effect&quot;);</a>
<a name="ln237"> </a>
<a name="ln238">DEFINE_int32(set_options_one_in, 0,</a>
<a name="ln239">             &quot;With a chance of 1/N, change some random options&quot;);</a>
<a name="ln240"> </a>
<a name="ln241">DEFINE_int32(set_in_place_one_in, 0,</a>
<a name="ln242">             &quot;With a chance of 1/N, toggle in place support option&quot;);</a>
<a name="ln243"> </a>
<a name="ln244">DEFINE_int64(cache_size, 2LL * KB * KB * KB,</a>
<a name="ln245">             &quot;Number of bytes to use as a cache of uncompressed data.&quot;);</a>
<a name="ln246"> </a>
<a name="ln247">DEFINE_uint64(subcompactions, 1,</a>
<a name="ln248">             &quot;Maximum number of subcompactions to divide L0-L1 compactions &quot;</a>
<a name="ln249">             &quot;into.&quot;);</a>
<a name="ln250"> </a>
<a name="ln251">DEFINE_bool(allow_concurrent_memtable_write, true,</a>
<a name="ln252">            &quot;Allow multi-writers to update mem tables in parallel.&quot;);</a>
<a name="ln253"> </a>
<a name="ln254">DEFINE_bool(enable_write_thread_adaptive_yield, true,</a>
<a name="ln255">            &quot;Use a yielding spin loop for brief writer thread waits.&quot;);</a>
<a name="ln256"> </a>
<a name="ln257">static const bool FLAGS_subcompactions_dummy __attribute__((unused)) =</a>
<a name="ln258">    RegisterFlagValidator(&amp;FLAGS_subcompactions, &amp;ValidateUint32Range);</a>
<a name="ln259"> </a>
<a name="ln260">static bool ValidateInt32Positive(const char* flagname, int32_t value) {</a>
<a name="ln261">  if (value &lt; 0) {</a>
<a name="ln262">    fprintf(stderr, &quot;Invalid value for --%s: %d, must be &gt;=0\n&quot;,</a>
<a name="ln263">            flagname, value);</a>
<a name="ln264">    return false;</a>
<a name="ln265">  }</a>
<a name="ln266">  return true;</a>
<a name="ln267">}</a>
<a name="ln268">DEFINE_int32(reopen, 10, &quot;Number of times database reopens&quot;);</a>
<a name="ln269">static const bool FLAGS_reopen_dummy __attribute__((unused)) =</a>
<a name="ln270">    RegisterFlagValidator(&amp;FLAGS_reopen, &amp;ValidateInt32Positive);</a>
<a name="ln271"> </a>
<a name="ln272">DEFINE_int32(bloom_bits, 10, &quot;Bloom filter bits per key. &quot;</a>
<a name="ln273">             &quot;Negative means use default settings.&quot;);</a>
<a name="ln274"> </a>
<a name="ln275">DEFINE_bool(use_block_based_filter, false, &quot;use block based filter&quot;</a>
<a name="ln276">              &quot;instead of full filter for block based table&quot;);</a>
<a name="ln277"> </a>
<a name="ln278">DEFINE_string(db, &quot;&quot;, &quot;Use the db with the following name.&quot;);</a>
<a name="ln279"> </a>
<a name="ln280">DEFINE_bool(verify_checksum, false,</a>
<a name="ln281">            &quot;Verify checksum for every block read from storage&quot;);</a>
<a name="ln282"> </a>
<a name="ln283">DEFINE_bool(mmap_read, rocksdb::EnvOptions().use_mmap_reads,</a>
<a name="ln284">            &quot;Allow reads to occur via mmap-ing files&quot;);</a>
<a name="ln285"> </a>
<a name="ln286">// Database statistics</a>
<a name="ln287">static std::shared_ptr&lt;rocksdb::Statistics&gt; dbstats;</a>
<a name="ln288">DEFINE_bool(statistics, false, &quot;Create database statistics&quot;);</a>
<a name="ln289"> </a>
<a name="ln290">DEFINE_bool(sync, false, &quot;Sync all writes to disk&quot;);</a>
<a name="ln291"> </a>
<a name="ln292">DEFINE_bool(disable_data_sync, false,</a>
<a name="ln293">            &quot;If true, do not wait until data is synced to disk.&quot;);</a>
<a name="ln294"> </a>
<a name="ln295">DEFINE_bool(use_fsync, false, &quot;If true, issue fsync instead of fdatasync&quot;);</a>
<a name="ln296"> </a>
<a name="ln297">DEFINE_int32(kill_random_test, 0,</a>
<a name="ln298">             &quot;If non-zero, kill at various points in source code with &quot;</a>
<a name="ln299">             &quot;probability 1/this&quot;);</a>
<a name="ln300">static const bool FLAGS_kill_random_test_dummy __attribute__((unused)) =</a>
<a name="ln301">    RegisterFlagValidator(&amp;FLAGS_kill_random_test, &amp;ValidateInt32Positive);</a>
<a name="ln302">extern int rocksdb_kill_odds;</a>
<a name="ln303"> </a>
<a name="ln304">DEFINE_string(kill_prefix_blacklist, &quot;&quot;,</a>
<a name="ln305">              &quot;If non-empty, kill points with prefix in the list given will be&quot;</a>
<a name="ln306">              &quot; skipped. Items are comma-separated.&quot;);</a>
<a name="ln307">extern std::vector&lt;std::string&gt; rocksdb_kill_prefix_blacklist;</a>
<a name="ln308"> </a>
<a name="ln309">DEFINE_bool(disable_wal, false, &quot;If true, do not write WAL for write.&quot;);</a>
<a name="ln310"> </a>
<a name="ln311">DEFINE_int32(target_file_size_base, 64 * KB,</a>
<a name="ln312">             &quot;Target level-1 file size for compaction&quot;);</a>
<a name="ln313"> </a>
<a name="ln314">DEFINE_int32(target_file_size_multiplier, 1,</a>
<a name="ln315">             &quot;A multiplier to compute target level-N file size (N &gt;= 2)&quot;);</a>
<a name="ln316"> </a>
<a name="ln317">DEFINE_uint64(max_bytes_for_level_base, 256 * KB, &quot;Max bytes for level-1&quot;);</a>
<a name="ln318"> </a>
<a name="ln319">DEFINE_int32(max_bytes_for_level_multiplier, 2,</a>
<a name="ln320">             &quot;A multiplier to compute max bytes for level-N (N &gt;= 2)&quot;);</a>
<a name="ln321"> </a>
<a name="ln322">static bool ValidateInt32Percent(const char* flagname, int32_t value) {</a>
<a name="ln323">  if (value &lt; 0 || value&gt;100) {</a>
<a name="ln324">    fprintf(stderr, &quot;Invalid value for --%s: %d, 0&lt;= pct &lt;=100 \n&quot;,</a>
<a name="ln325">            flagname, value);</a>
<a name="ln326">    return false;</a>
<a name="ln327">  }</a>
<a name="ln328">  return true;</a>
<a name="ln329">}</a>
<a name="ln330">DEFINE_int32(readpercent, 10,</a>
<a name="ln331">             &quot;Ratio of reads to total workload (expressed as a percentage)&quot;);</a>
<a name="ln332">static const bool FLAGS_readpercent_dummy __attribute__((unused)) =</a>
<a name="ln333">    RegisterFlagValidator(&amp;FLAGS_readpercent, &amp;ValidateInt32Percent);</a>
<a name="ln334"> </a>
<a name="ln335">DEFINE_int32(prefixpercent, 20,</a>
<a name="ln336">             &quot;Ratio of prefix iterators to total workload (expressed as a&quot;</a>
<a name="ln337">             &quot; percentage)&quot;);</a>
<a name="ln338">static const bool FLAGS_prefixpercent_dummy __attribute__((unused)) =</a>
<a name="ln339">    RegisterFlagValidator(&amp;FLAGS_prefixpercent, &amp;ValidateInt32Percent);</a>
<a name="ln340"> </a>
<a name="ln341">DEFINE_int32(writepercent, 45,</a>
<a name="ln342">             &quot;Ratio of writes to total workload (expressed as a percentage)&quot;);</a>
<a name="ln343">static const bool FLAGS_writepercent_dummy __attribute__((unused)) =</a>
<a name="ln344">    RegisterFlagValidator(&amp;FLAGS_writepercent, &amp;ValidateInt32Percent);</a>
<a name="ln345"> </a>
<a name="ln346">DEFINE_int32(delpercent, 15,</a>
<a name="ln347">             &quot;Ratio of deletes to total workload (expressed as a percentage)&quot;);</a>
<a name="ln348">static const bool FLAGS_delpercent_dummy __attribute__((unused)) =</a>
<a name="ln349">    RegisterFlagValidator(&amp;FLAGS_delpercent, &amp;ValidateInt32Percent);</a>
<a name="ln350"> </a>
<a name="ln351">DEFINE_int32(nooverwritepercent, 60,</a>
<a name="ln352">             &quot;Ratio of keys without overwrite to total workload (expressed as &quot;</a>
<a name="ln353">             &quot; a percentage)&quot;);</a>
<a name="ln354">static const bool FLAGS_nooverwritepercent_dummy __attribute__((__unused__)) =</a>
<a name="ln355">    RegisterFlagValidator(&amp;FLAGS_nooverwritepercent, &amp;ValidateInt32Percent);</a>
<a name="ln356"> </a>
<a name="ln357">DEFINE_int32(iterpercent, 10, &quot;Ratio of iterations to total workload&quot;</a>
<a name="ln358">             &quot; (expressed as a percentage)&quot;);</a>
<a name="ln359">static const bool FLAGS_iterpercent_dummy __attribute__((unused)) =</a>
<a name="ln360">    RegisterFlagValidator(&amp;FLAGS_iterpercent, &amp;ValidateInt32Percent);</a>
<a name="ln361"> </a>
<a name="ln362">DEFINE_uint64(num_iterations, 10, &quot;Number of iterations per MultiIterate run&quot;);</a>
<a name="ln363">static const bool FLAGS_num_iterations_dummy __attribute__((unused)) =</a>
<a name="ln364">    RegisterFlagValidator(&amp;FLAGS_num_iterations, &amp;ValidateUint32Range);</a>
<a name="ln365"> </a>
<a name="ln366">namespace {</a>
<a name="ln367">enum rocksdb::CompressionType StringToCompressionType(const char* ctype) {</a>
<a name="ln368">  assert(ctype);</a>
<a name="ln369"> </a>
<a name="ln370">  if (!strcasecmp(ctype, &quot;none&quot;))</a>
<a name="ln371">    return rocksdb::kNoCompression;</a>
<a name="ln372">  else if (!strcasecmp(ctype, &quot;snappy&quot;))</a>
<a name="ln373">    return rocksdb::kSnappyCompression;</a>
<a name="ln374">  else if (!strcasecmp(ctype, &quot;zlib&quot;))</a>
<a name="ln375">    return rocksdb::kZlibCompression;</a>
<a name="ln376">  else if (!strcasecmp(ctype, &quot;bzip2&quot;))</a>
<a name="ln377">    return rocksdb::kBZip2Compression;</a>
<a name="ln378">  else if (!strcasecmp(ctype, &quot;lz4&quot;))</a>
<a name="ln379">    return rocksdb::kLZ4Compression;</a>
<a name="ln380">  else if (!strcasecmp(ctype, &quot;lz4hc&quot;))</a>
<a name="ln381">    return rocksdb::kLZ4HCCompression;</a>
<a name="ln382">  else if (!strcasecmp(ctype, &quot;zstd&quot;))</a>
<a name="ln383">    return rocksdb::kZSTDNotFinalCompression;</a>
<a name="ln384"> </a>
<a name="ln385">  fprintf(stdout, &quot;Cannot parse compression type '%s'\n&quot;, ctype);</a>
<a name="ln386">  return rocksdb::kSnappyCompression; // default value</a>
<a name="ln387">}</a>
<a name="ln388"> </a>
<a name="ln389">std::vector&lt;std::string&gt; SplitString(std::string src) {</a>
<a name="ln390">  std::vector&lt;std::string&gt; ret;</a>
<a name="ln391">  if (src.empty()) {</a>
<a name="ln392">    return ret;</a>
<a name="ln393">  }</a>
<a name="ln394">  size_t pos = 0;</a>
<a name="ln395">  size_t pos_comma;</a>
<a name="ln396">  while ((pos_comma = src.find(',', pos)) != std::string::npos) {</a>
<a name="ln397">    ret.push_back(src.substr(pos, pos_comma - pos));</a>
<a name="ln398">    pos = pos_comma + 1;</a>
<a name="ln399">  }</a>
<a name="ln400">  ret.push_back(src.substr(pos, src.length()));</a>
<a name="ln401">  return ret;</a>
<a name="ln402">}</a>
<a name="ln403">}  // namespace</a>
<a name="ln404"> </a>
<a name="ln405">DEFINE_string(compression_type, &quot;snappy&quot;,</a>
<a name="ln406">              &quot;Algorithm to use to compress the database&quot;);</a>
<a name="ln407">static enum rocksdb::CompressionType FLAGS_compression_type_e =</a>
<a name="ln408">    rocksdb::kSnappyCompression;</a>
<a name="ln409"> </a>
<a name="ln410">DEFINE_string(hdfs, &quot;&quot;, &quot;Name of hdfs environment&quot;);</a>
<a name="ln411">// posix or hdfs environment</a>
<a name="ln412">static rocksdb::Env* FLAGS_env = rocksdb::Env::Default();</a>
<a name="ln413"> </a>
<a name="ln414">DEFINE_uint64(ops_per_thread, 1200000, &quot;Number of operations per thread.&quot;);</a>
<a name="ln415">static const bool FLAGS_ops_per_thread_dummy __attribute__((unused)) =</a>
<a name="ln416">    RegisterFlagValidator(&amp;FLAGS_ops_per_thread, &amp;ValidateUint32Range);</a>
<a name="ln417"> </a>
<a name="ln418">DEFINE_uint64(log2_keys_per_lock, 2, &quot;Log2 of number of keys per lock&quot;);</a>
<a name="ln419">static const bool FLAGS_log2_keys_per_lock_dummy __attribute__((unused)) =</a>
<a name="ln420">    RegisterFlagValidator(&amp;FLAGS_log2_keys_per_lock, &amp;ValidateUint32Range);</a>
<a name="ln421"> </a>
<a name="ln422">DEFINE_bool(filter_deletes, false, &quot;On true, deletes use KeyMayExist to drop&quot;</a>
<a name="ln423">            &quot; the delete if key not present&quot;);</a>
<a name="ln424"> </a>
<a name="ln425">DEFINE_bool(in_place_update, false, &quot;On true, does inplace update in memtable&quot;);</a>
<a name="ln426"> </a>
<a name="ln427">enum RepFactory {</a>
<a name="ln428">  kSkipList,</a>
<a name="ln429">  kHashSkipList,</a>
<a name="ln430">  kVectorRep</a>
<a name="ln431">};</a>
<a name="ln432"> </a>
<a name="ln433">namespace {</a>
<a name="ln434">enum RepFactory StringToRepFactory(const char* ctype) {</a>
<a name="ln435">  assert(ctype);</a>
<a name="ln436"> </a>
<a name="ln437">  if (!strcasecmp(ctype, &quot;skip_list&quot;))</a>
<a name="ln438">    return kSkipList;</a>
<a name="ln439">  else if (!strcasecmp(ctype, &quot;prefix_hash&quot;))</a>
<a name="ln440">    return kHashSkipList;</a>
<a name="ln441">  else if (!strcasecmp(ctype, &quot;vector&quot;))</a>
<a name="ln442">    return kVectorRep;</a>
<a name="ln443"> </a>
<a name="ln444">  fprintf(stdout, &quot;Cannot parse memreptable %s\n&quot;, ctype);</a>
<a name="ln445">  return kSkipList;</a>
<a name="ln446">}</a>
<a name="ln447">}  // namespace</a>
<a name="ln448"> </a>
<a name="ln449">static enum RepFactory FLAGS_rep_factory;</a>
<a name="ln450">DEFINE_string(memtablerep, &quot;prefix_hash&quot;, &quot;&quot;);</a>
<a name="ln451"> </a>
<a name="ln452">static bool ValidatePrefixSize(const char* flagname, int32_t value) {</a>
<a name="ln453">  if (value &lt; 0 || value &gt; 8) {</a>
<a name="ln454">    fprintf(stderr, &quot;Invalid value for --%s: %d. 0 &lt;= PrefixSize &lt;= 8\n&quot;,</a>
<a name="ln455">            flagname, value);</a>
<a name="ln456">    return false;</a>
<a name="ln457">  }</a>
<a name="ln458">  return true;</a>
<a name="ln459">}</a>
<a name="ln460">DEFINE_int32(prefix_size, 7, &quot;Control the prefix size for HashSkipListRep&quot;);</a>
<a name="ln461">static const bool FLAGS_prefix_size_dummy __attribute__((unused)) =</a>
<a name="ln462">    RegisterFlagValidator(&amp;FLAGS_prefix_size, &amp;ValidatePrefixSize);</a>
<a name="ln463"> </a>
<a name="ln464">DEFINE_bool(use_merge, false, &quot;On true, replaces all writes with a Merge &quot;</a>
<a name="ln465">            &quot;that behaves like a Put&quot;);</a>
<a name="ln466"> </a>
<a name="ln467"> </a>
<a name="ln468">namespace rocksdb {</a>
<a name="ln469"> </a>
<a name="ln470">// convert long to a big-endian slice key</a>
<a name="ln471">static std::string Key(int64_t val) {</a>
<a name="ln472">  std::string little_endian_key;</a>
<a name="ln473">  std::string big_endian_key;</a>
<a name="ln474">  PutFixed64(&amp;little_endian_key, val);</a>
<a name="ln475">  assert(little_endian_key.size() == sizeof(val));</a>
<a name="ln476">  big_endian_key.resize(sizeof(val));</a>
<a name="ln477">  for (size_t i = 0 ; i &lt; sizeof(val); ++i) {</a>
<a name="ln478">    big_endian_key[i] = little_endian_key[sizeof(val) - 1 - i];</a>
<a name="ln479">  }</a>
<a name="ln480">  return big_endian_key;</a>
<a name="ln481">}</a>
<a name="ln482"> </a>
<a name="ln483">static std::string StringToHex(const std::string&amp; str) {</a>
<a name="ln484">  std::string result = &quot;0x&quot;;</a>
<a name="ln485">  char buf[10];</a>
<a name="ln486">  for (size_t i = 0; i &lt; str.length(); i++) {</a>
<a name="ln487">    snprintf(buf, sizeof(buf), &quot;%02X&quot;, (unsigned char)str[i]);</a>
<a name="ln488">    result += buf;</a>
<a name="ln489">  }</a>
<a name="ln490">  return result;</a>
<a name="ln491">}</a>
<a name="ln492"> </a>
<a name="ln493"> </a>
<a name="ln494">class StressTest;</a>
<a name="ln495">namespace {</a>
<a name="ln496"> </a>
<a name="ln497">class Stats {</a>
<a name="ln498"> private:</a>
<a name="ln499">  uint64_t start_;</a>
<a name="ln500">  uint64_t finish_;</a>
<a name="ln501">  double  seconds_;</a>
<a name="ln502">  int64_t done_;</a>
<a name="ln503">  int64_t gets_;</a>
<a name="ln504">  int64_t prefixes_;</a>
<a name="ln505">  int64_t writes_;</a>
<a name="ln506">  int64_t deletes_;</a>
<a name="ln507">  size_t single_deletes_;</a>
<a name="ln508">  int64_t iterator_size_sums_;</a>
<a name="ln509">  int64_t founds_;</a>
<a name="ln510">  int64_t iterations_;</a>
<a name="ln511">  int64_t errors_;</a>
<a name="ln512">  int next_report_;</a>
<a name="ln513">  size_t bytes_;</a>
<a name="ln514">  uint64_t last_op_finish_;</a>
<a name="ln515">  HistogramImpl hist_;</a>
<a name="ln516"> </a>
<a name="ln517"> public:</a>
<a name="ln518">  Stats() { }</a>
<a name="ln519"> </a>
<a name="ln520">  void Start() {</a>
<a name="ln521">    next_report_ = 100;</a>
<a name="ln522">    hist_.Clear();</a>
<a name="ln523">    done_ = 0;</a>
<a name="ln524">    gets_ = 0;</a>
<a name="ln525">    prefixes_ = 0;</a>
<a name="ln526">    writes_ = 0;</a>
<a name="ln527">    deletes_ = 0;</a>
<a name="ln528">    single_deletes_ = 0;</a>
<a name="ln529">    iterator_size_sums_ = 0;</a>
<a name="ln530">    founds_ = 0;</a>
<a name="ln531">    iterations_ = 0;</a>
<a name="ln532">    errors_ = 0;</a>
<a name="ln533">    bytes_ = 0;</a>
<a name="ln534">    seconds_ = 0;</a>
<a name="ln535">    start_ = FLAGS_env-&gt;NowMicros();</a>
<a name="ln536">    last_op_finish_ = start_;</a>
<a name="ln537">    finish_ = start_;</a>
<a name="ln538">  }</a>
<a name="ln539"> </a>
<a name="ln540">  void Merge(const Stats&amp; other) {</a>
<a name="ln541">    hist_.Merge(other.hist_);</a>
<a name="ln542">    done_ += other.done_;</a>
<a name="ln543">    gets_ += other.gets_;</a>
<a name="ln544">    prefixes_ += other.prefixes_;</a>
<a name="ln545">    writes_ += other.writes_;</a>
<a name="ln546">    deletes_ += other.deletes_;</a>
<a name="ln547">    single_deletes_ += other.single_deletes_;</a>
<a name="ln548">    iterator_size_sums_ += other.iterator_size_sums_;</a>
<a name="ln549">    founds_ += other.founds_;</a>
<a name="ln550">    iterations_ += other.iterations_;</a>
<a name="ln551">    errors_ += other.errors_;</a>
<a name="ln552">    bytes_ += other.bytes_;</a>
<a name="ln553">    seconds_ += other.seconds_;</a>
<a name="ln554">    if (other.start_ &lt; start_) start_ = other.start_;</a>
<a name="ln555">    if (other.finish_ &gt; finish_) finish_ = other.finish_;</a>
<a name="ln556">  }</a>
<a name="ln557"> </a>
<a name="ln558">  void Stop() {</a>
<a name="ln559">    finish_ = FLAGS_env-&gt;NowMicros();</a>
<a name="ln560">    seconds_ = (finish_ - start_) * 1e-6;</a>
<a name="ln561">  }</a>
<a name="ln562"> </a>
<a name="ln563">  void FinishedSingleOp() {</a>
<a name="ln564">    if (FLAGS_histogram) {</a>
<a name="ln565">      auto now = FLAGS_env-&gt;NowMicros();</a>
<a name="ln566">      auto micros = now - last_op_finish_;</a>
<a name="ln567">      hist_.Add(micros);</a>
<a name="ln568">      if (micros &gt; 20000) {</a>
<a name="ln569">        fprintf(stdout, &quot;long op: %&quot; PRIu64 &quot; micros%30s\r&quot;, micros, &quot;&quot;);</a>
<a name="ln570">      }</a>
<a name="ln571">      last_op_finish_ = now;</a>
<a name="ln572">    }</a>
<a name="ln573"> </a>
<a name="ln574">      done_++;</a>
<a name="ln575">    if (FLAGS_progress_reports) {</a>
<a name="ln576">      if (done_ &gt;= next_report_) {</a>
<a name="ln577">        if      (next_report_ &lt; 1000)   next_report_ += 100;</a>
<a name="ln578">        else if (next_report_ &lt; 5000)   next_report_ += 500;</a>
<a name="ln579">        else if (next_report_ &lt; 10000)  next_report_ += 1000;</a>
<a name="ln580">        else if (next_report_ &lt; 50000)  next_report_ += 5000;</a>
<a name="ln581">        else if (next_report_ &lt; 100000) next_report_ += 10000;</a>
<a name="ln582">        else if (next_report_ &lt; 500000) next_report_ += 50000;</a>
<a name="ln583">        else                            next_report_ += 100000;</a>
<a name="ln584">        fprintf(stdout, &quot;... finished %&quot; PRId64 &quot; ops%30s\r&quot;, done_, &quot;&quot;);</a>
<a name="ln585">      }</a>
<a name="ln586">    }</a>
<a name="ln587">  }</a>
<a name="ln588"> </a>
<a name="ln589">  void AddBytesForWrites(int nwrites, size_t nbytes) {</a>
<a name="ln590">    writes_ += nwrites;</a>
<a name="ln591">    bytes_ += nbytes;</a>
<a name="ln592">  }</a>
<a name="ln593"> </a>
<a name="ln594">  void AddGets(int ngets, int nfounds) {</a>
<a name="ln595">    founds_ += nfounds;</a>
<a name="ln596">    gets_ += ngets;</a>
<a name="ln597">  }</a>
<a name="ln598"> </a>
<a name="ln599">  void AddPrefixes(int nprefixes, int count) {</a>
<a name="ln600">    prefixes_ += nprefixes;</a>
<a name="ln601">    iterator_size_sums_ += count;</a>
<a name="ln602">  }</a>
<a name="ln603"> </a>
<a name="ln604">  void AddIterations(int n) {</a>
<a name="ln605">    iterations_ += n;</a>
<a name="ln606">  }</a>
<a name="ln607"> </a>
<a name="ln608">  void AddDeletes(int n) {</a>
<a name="ln609">    deletes_ += n;</a>
<a name="ln610">  }</a>
<a name="ln611"> </a>
<a name="ln612">  void AddSingleDeletes(size_t n) { single_deletes_ += n; }</a>
<a name="ln613"> </a>
<a name="ln614">  void AddErrors(int n) {</a>
<a name="ln615">    errors_ += n;</a>
<a name="ln616">  }</a>
<a name="ln617"> </a>
<a name="ln618">  void Report(const char* name) {</a>
<a name="ln619">    std::string extra;</a>
<a name="ln620">    if (bytes_ &lt; 1 || done_ &lt; 1) {</a>
<a name="ln621">      fprintf(stderr, &quot;No writes or ops?\n&quot;);</a>
<a name="ln622">      return;</a>
<a name="ln623">    }</a>
<a name="ln624"> </a>
<a name="ln625">    double elapsed = (finish_ - start_) * 1e-6;</a>
<a name="ln626">    double bytes_mb = bytes_ / 1048576.0;</a>
<a name="ln627">    double rate = bytes_mb / elapsed;</a>
<a name="ln628">    int64_t throughput = static_cast&lt;int64_t&gt;(done_ / elapsed);</a>
<a name="ln629"> </a>
<a name="ln630">    fprintf(stdout, &quot;%-12s: &quot;, name);</a>
<a name="ln631">    fprintf(stdout, &quot;%.3f micros/op %&quot; PRId64 &quot; ops/sec\n&quot;,</a>
<a name="ln632">            seconds_ * 1e6 / done_, throughput);</a>
<a name="ln633">    fprintf(stdout, &quot;%-12s: Wrote %.2f MB (%.2f MB/sec) (%&quot; PRId64 &quot;%% of %&quot; PRId64 &quot; ops)\n&quot;,</a>
<a name="ln634">            &quot;&quot;, bytes_mb, rate, (100 * writes_) / done_, done_);</a>
<a name="ln635">    fprintf(stdout, &quot;%-12s: Wrote %&quot; PRId64 &quot; times\n&quot;, &quot;&quot;, writes_);</a>
<a name="ln636">    fprintf(stdout, &quot;%-12s: Deleted %&quot; PRId64 &quot; times\n&quot;, &quot;&quot;, deletes_);</a>
<a name="ln637">    fprintf(stdout, &quot;%-12s: Single deleted %&quot; ROCKSDB_PRIszt &quot; times\n&quot;, &quot;&quot;,</a>
<a name="ln638">           single_deletes_);</a>
<a name="ln639">    fprintf(stdout, &quot;%-12s: %&quot; PRId64 &quot; read and %&quot; PRId64 &quot; found the key\n&quot;, &quot;&quot;,</a>
<a name="ln640">            gets_, founds_);</a>
<a name="ln641">    fprintf(stdout, &quot;%-12s: Prefix scanned %&quot; PRId64 &quot; times\n&quot;, &quot;&quot;, prefixes_);</a>
<a name="ln642">    fprintf(stdout, &quot;%-12s: Iterator size sum is %&quot; PRId64 &quot;\n&quot;, &quot;&quot;, iterator_size_sums_);</a>
<a name="ln643">    fprintf(stdout, &quot;%-12s: Iterated %&quot; PRId64 &quot; times\n&quot;, &quot;&quot;, iterations_);</a>
<a name="ln644">    fprintf(stdout, &quot;%-12s: Got errors %&quot; PRId64 &quot; times\n&quot;, &quot;&quot;, errors_);</a>
<a name="ln645"> </a>
<a name="ln646">    if (FLAGS_histogram) {</a>
<a name="ln647">      fprintf(stdout, &quot;Microseconds per op:\n%s\n&quot;, hist_.ToString().c_str());</a>
<a name="ln648">    }</a>
<a name="ln649">    fflush(stdout);</a>
<a name="ln650">  }</a>
<a name="ln651">};</a>
<a name="ln652"> </a>
<a name="ln653">// State shared by all concurrent executions of the same benchmark.</a>
<a name="ln654">class SharedState {</a>
<a name="ln655"> public:</a>
<a name="ln656">  static const uint32_t SENTINEL;</a>
<a name="ln657"> </a>
<a name="ln658">  explicit SharedState(StressTest* stress_test)</a>
<a name="ln659">      : cv_(&amp;mu_),</a>
<a name="ln660">        seed_(static_cast&lt;uint32_t&gt;(FLAGS_seed)),</a>
<a name="ln661">        max_key_(FLAGS_max_key),</a>
<a name="ln662">        log2_keys_per_lock_(static_cast&lt;uint32_t&gt;(FLAGS_log2_keys_per_lock)),</a>
<a name="ln663">        num_threads_(FLAGS_threads),</a>
<a name="ln664">        num_initialized_(0),</a>
<a name="ln665">        num_populated_(0),</a>
<a name="ln666">        vote_reopen_(0),</a>
<a name="ln667">        num_done_(0),</a>
<a name="ln668">        start_(false),</a>
<a name="ln669">        start_verify_(false),</a>
<a name="ln670">        should_stop_bg_thread_(false),</a>
<a name="ln671">        bg_thread_finished_(false),</a>
<a name="ln672">        stress_test_(stress_test),</a>
<a name="ln673">        verification_failure_(false),</a>
<a name="ln674">        no_overwrite_ids_(FLAGS_column_families) {</a>
<a name="ln675">    // Pick random keys in each column family that will not experience</a>
<a name="ln676">    // overwrite</a>
<a name="ln677"> </a>
<a name="ln678">    printf(&quot;Choosing random keys with no overwrite\n&quot;);</a>
<a name="ln679">    Random rnd(seed_);</a>
<a name="ln680">    size_t num_no_overwrite_keys = (max_key_ * FLAGS_nooverwritepercent) / 100;</a>
<a name="ln681">    for (auto&amp; cf_ids : no_overwrite_ids_) {</a>
<a name="ln682">      for (size_t i = 0; i &lt; num_no_overwrite_keys; i++) {</a>
<a name="ln683">        size_t rand_key;</a>
<a name="ln684">        do {</a>
<a name="ln685">          rand_key = rnd.Next() % max_key_;</a>
<a name="ln686">        } while (cf_ids.find(rand_key) != cf_ids.end());</a>
<a name="ln687">        cf_ids.insert(rand_key);</a>
<a name="ln688">      }</a>
<a name="ln689">      assert(cf_ids.size() == num_no_overwrite_keys);</a>
<a name="ln690">    }</a>
<a name="ln691"> </a>
<a name="ln692">    if (FLAGS_test_batches_snapshots) {</a>
<a name="ln693">      fprintf(stdout, &quot;No lock creation because test_batches_snapshots set\n&quot;);</a>
<a name="ln694">      return;</a>
<a name="ln695">    }</a>
<a name="ln696">    values_.resize(FLAGS_column_families);</a>
<a name="ln697"> </a>
<a name="ln698">    for (int i = 0; i &lt; FLAGS_column_families; ++i) {</a>
<a name="ln699">      values_[i] = std::vector&lt;uint32_t&gt;(max_key_, SENTINEL);</a>
<a name="ln700">    }</a>
<a name="ln701"> </a>
<a name="ln702">    auto num_locks = max_key_ &gt;&gt; log2_keys_per_lock_;</a>
<a name="ln703">    if (max_key_ &amp; ((1 &lt;&lt; log2_keys_per_lock_) - 1)) {</a>
<a name="ln704">      num_locks++;</a>
<a name="ln705">    }</a>
<a name="ln706">    fprintf(stdout, &quot;Creating %&quot; PRId64 &quot; locks\n&quot;, num_locks * FLAGS_column_families);</a>
<a name="ln707">    key_locks_.resize(FLAGS_column_families);</a>
<a name="ln708"> </a>
<a name="ln709">    for (int i = 0; i &lt; FLAGS_column_families; ++i) {</a>
<a name="ln710">      key_locks_[i].resize(num_locks);</a>
<a name="ln711">      for (auto&amp; ptr : key_locks_[i]) {</a>
<a name="ln712">        ptr.reset(new port::Mutex);</a>
<a name="ln713">      }</a>
<a name="ln714">    }</a>
<a name="ln715">  }</a>
<a name="ln716"> </a>
<a name="ln717">  ~SharedState() {}</a>
<a name="ln718"> </a>
<a name="ln719">  port::Mutex* GetMutex() {</a>
<a name="ln720">    return &amp;mu_;</a>
<a name="ln721">  }</a>
<a name="ln722"> </a>
<a name="ln723">  port::CondVar* GetCondVar() {</a>
<a name="ln724">    return &amp;cv_;</a>
<a name="ln725">  }</a>
<a name="ln726"> </a>
<a name="ln727">  StressTest* GetStressTest() const {</a>
<a name="ln728">    return stress_test_;</a>
<a name="ln729">  }</a>
<a name="ln730"> </a>
<a name="ln731">  int64_t GetMaxKey() const {</a>
<a name="ln732">    return max_key_;</a>
<a name="ln733">  }</a>
<a name="ln734"> </a>
<a name="ln735">  uint32_t GetNumThreads() const {</a>
<a name="ln736">    return num_threads_;</a>
<a name="ln737">  }</a>
<a name="ln738"> </a>
<a name="ln739">  void IncInitialized() {</a>
<a name="ln740">    num_initialized_++;</a>
<a name="ln741">  }</a>
<a name="ln742"> </a>
<a name="ln743">  void IncOperated() {</a>
<a name="ln744">    num_populated_++;</a>
<a name="ln745">  }</a>
<a name="ln746"> </a>
<a name="ln747">  void IncDone() {</a>
<a name="ln748">    num_done_++;</a>
<a name="ln749">  }</a>
<a name="ln750"> </a>
<a name="ln751">  void IncVotedReopen() {</a>
<a name="ln752">    vote_reopen_ = (vote_reopen_ + 1) % num_threads_;</a>
<a name="ln753">  }</a>
<a name="ln754"> </a>
<a name="ln755">  bool AllInitialized() const {</a>
<a name="ln756">    return num_initialized_ &gt;= num_threads_;</a>
<a name="ln757">  }</a>
<a name="ln758"> </a>
<a name="ln759">  bool AllOperated() const {</a>
<a name="ln760">    return num_populated_ &gt;= num_threads_;</a>
<a name="ln761">  }</a>
<a name="ln762"> </a>
<a name="ln763">  bool AllDone() const {</a>
<a name="ln764">    return num_done_ &gt;= num_threads_;</a>
<a name="ln765">  }</a>
<a name="ln766"> </a>
<a name="ln767">  bool AllVotedReopen() {</a>
<a name="ln768">    return (vote_reopen_ == 0);</a>
<a name="ln769">  }</a>
<a name="ln770"> </a>
<a name="ln771">  void SetStart() {</a>
<a name="ln772">    start_ = true;</a>
<a name="ln773">  }</a>
<a name="ln774"> </a>
<a name="ln775">  void SetStartVerify() {</a>
<a name="ln776">    start_verify_ = true;</a>
<a name="ln777">  }</a>
<a name="ln778"> </a>
<a name="ln779">  bool Started() const {</a>
<a name="ln780">    return start_;</a>
<a name="ln781">  }</a>
<a name="ln782"> </a>
<a name="ln783">  bool VerifyStarted() const {</a>
<a name="ln784">    return start_verify_;</a>
<a name="ln785">  }</a>
<a name="ln786"> </a>
<a name="ln787">  void SetVerificationFailure() { verification_failure_.store(true); }</a>
<a name="ln788"> </a>
<a name="ln789">  bool HasVerificationFailedYet() { return verification_failure_.load(); }</a>
<a name="ln790"> </a>
<a name="ln791">  port::Mutex* GetMutexForKey(int cf, size_t key) {</a>
<a name="ln792">    return key_locks_[cf][key &gt;&gt; log2_keys_per_lock_].get();</a>
<a name="ln793">  }</a>
<a name="ln794"> </a>
<a name="ln795">  void LockColumnFamily(int cf) {</a>
<a name="ln796">    for (auto&amp; mutex : key_locks_[cf]) {</a>
<a name="ln797">      mutex-&gt;Lock();</a>
<a name="ln798">    }</a>
<a name="ln799">  }</a>
<a name="ln800"> </a>
<a name="ln801">  void UnlockColumnFamily(int cf) {</a>
<a name="ln802">    for (auto&amp; mutex : key_locks_[cf]) {</a>
<a name="ln803">      mutex-&gt;Unlock();</a>
<a name="ln804">    }</a>
<a name="ln805">  }</a>
<a name="ln806"> </a>
<a name="ln807">  void ClearColumnFamily(int cf) {</a>
<a name="ln808">    std::fill(values_[cf].begin(), values_[cf].end(), SENTINEL);</a>
<a name="ln809">  }</a>
<a name="ln810"> </a>
<a name="ln811">  void Put(int cf, int64_t key, uint32_t value_base) {</a>
<a name="ln812">    values_[cf][key] = value_base;</a>
<a name="ln813">  }</a>
<a name="ln814"> </a>
<a name="ln815">  uint32_t Get(int cf, int64_t key) const { return values_[cf][key]; }</a>
<a name="ln816"> </a>
<a name="ln817">  void Delete(int cf, int64_t key) { values_[cf][key] = SENTINEL; }</a>
<a name="ln818"> </a>
<a name="ln819">  void SingleDelete(int cf, int64_t key) { values_[cf][key] = SENTINEL; }</a>
<a name="ln820"> </a>
<a name="ln821">  bool AllowsOverwrite(int cf, int64_t key) {</a>
<a name="ln822">    return no_overwrite_ids_[cf].find(key) == no_overwrite_ids_[cf].end();</a>
<a name="ln823">  }</a>
<a name="ln824"> </a>
<a name="ln825">  bool Exists(int cf, int64_t key) { return values_[cf][key] != SENTINEL; }</a>
<a name="ln826"> </a>
<a name="ln827">  uint32_t GetSeed() const { return seed_; }</a>
<a name="ln828"> </a>
<a name="ln829">  void SetShouldStopBgThread() { should_stop_bg_thread_ = true; }</a>
<a name="ln830"> </a>
<a name="ln831">  bool ShoudStopBgThread() { return should_stop_bg_thread_; }</a>
<a name="ln832"> </a>
<a name="ln833">  void SetBgThreadFinish() { bg_thread_finished_ = true; }</a>
<a name="ln834"> </a>
<a name="ln835">  bool BgThreadFinished() const { return bg_thread_finished_; }</a>
<a name="ln836"> </a>
<a name="ln837"> private:</a>
<a name="ln838">  port::Mutex mu_;</a>
<a name="ln839">  port::CondVar cv_;</a>
<a name="ln840">  const uint32_t seed_;</a>
<a name="ln841">  const int64_t max_key_;</a>
<a name="ln842">  const uint32_t log2_keys_per_lock_;</a>
<a name="ln843">  const int num_threads_;</a>
<a name="ln844">  int64_t num_initialized_;</a>
<a name="ln845">  int64_t num_populated_;</a>
<a name="ln846">  int64_t vote_reopen_;</a>
<a name="ln847">  int64_t num_done_;</a>
<a name="ln848">  bool start_;</a>
<a name="ln849">  bool start_verify_;</a>
<a name="ln850">  bool should_stop_bg_thread_;</a>
<a name="ln851">  bool bg_thread_finished_;</a>
<a name="ln852">  StressTest* stress_test_;</a>
<a name="ln853">  std::atomic&lt;bool&gt; verification_failure_;</a>
<a name="ln854"> </a>
<a name="ln855">  // Keys that should not be overwritten</a>
<a name="ln856">  std::vector&lt;std::set&lt;size_t&gt; &gt; no_overwrite_ids_;</a>
<a name="ln857"> </a>
<a name="ln858">  std::vector&lt;std::vector&lt;uint32_t&gt;&gt; values_;</a>
<a name="ln859">  // Has to make it owned by a smart ptr as port::Mutex is not copyable</a>
<a name="ln860">  // and storing it in the container may require copying depending on the impl.</a>
<a name="ln861">  std::vector&lt;std::vector&lt;std::unique_ptr&lt;port::Mutex&gt; &gt; &gt; key_locks_;</a>
<a name="ln862">};</a>
<a name="ln863"> </a>
<a name="ln864">const uint32_t SharedState::SENTINEL = 0xffffffff;</a>
<a name="ln865"> </a>
<a name="ln866">// Per-thread state for concurrent executions of the same benchmark.</a>
<a name="ln867">struct ThreadState {</a>
<a name="ln868">  uint32_t tid; // 0..n-1</a>
<a name="ln869">  Random rand;  // Has different seeds for different threads</a>
<a name="ln870">  SharedState* shared;</a>
<a name="ln871">  Stats stats;</a>
<a name="ln872"> </a>
<a name="ln873">  ThreadState(uint32_t index, SharedState* _shared)</a>
<a name="ln874">      : tid(index), rand(1000 + index + _shared-&gt;GetSeed()), shared(_shared) {}</a>
<a name="ln875">};</a>
<a name="ln876"> </a>
<a name="ln877">class DbStressListener : public EventListener {</a>
<a name="ln878"> public:</a>
<a name="ln879">  DbStressListener(</a>
<a name="ln880">      const std::string&amp; db_name,</a>
<a name="ln881">      const std::vector&lt;DbPath&gt;&amp; db_paths) :</a>
<a name="ln882">      db_name_(db_name),</a>
<a name="ln883">      db_paths_(db_paths),</a>
<a name="ln884">      rand_(301) {}</a>
<a name="ln885">  virtual ~DbStressListener() {}</a>
<a name="ln886">#ifndef ROCKSDB_LITE</a>
<a name="ln887">  virtual void OnFlushCompleted(</a>
<a name="ln888">      DB* db, const FlushJobInfo&amp; info) override {</a>
<a name="ln889">    assert(db);</a>
<a name="ln890">    assert(db-&gt;GetName() == db_name_);</a>
<a name="ln891">    assert(IsValidColumnFamilyName(info.cf_name));</a>
<a name="ln892">    VerifyFilePath(info.file_path);</a>
<a name="ln893">    // pretending doing some work here</a>
<a name="ln894">    std::this_thread::sleep_for(</a>
<a name="ln895">        std::chrono::microseconds(rand_.Uniform(5000)));</a>
<a name="ln896">  }</a>
<a name="ln897"> </a>
<a name="ln898">  virtual void OnCompactionCompleted(</a>
<a name="ln899">      DB *db, const CompactionJobInfo&amp; ci) override {</a>
<a name="ln900">    assert(db);</a>
<a name="ln901">    assert(db-&gt;GetName() == db_name_);</a>
<a name="ln902">    assert(IsValidColumnFamilyName(ci.cf_name));</a>
<a name="ln903">    assert(ci.input_files.size() + ci.output_files.size() &gt; 0U);</a>
<a name="ln904">    for (const auto&amp; file_path : ci.input_files) {</a>
<a name="ln905">      VerifyFilePath(file_path);</a>
<a name="ln906">    }</a>
<a name="ln907">    for (const auto&amp; file_path : ci.output_files) {</a>
<a name="ln908">      VerifyFilePath(file_path);</a>
<a name="ln909">    }</a>
<a name="ln910">    // pretending doing some work here</a>
<a name="ln911">    std::this_thread::sleep_for(</a>
<a name="ln912">        std::chrono::microseconds(rand_.Uniform(5000)));</a>
<a name="ln913">  }</a>
<a name="ln914"> </a>
<a name="ln915">  virtual void OnTableFileCreated(</a>
<a name="ln916">      const TableFileCreationInfo&amp; info) override {</a>
<a name="ln917">    assert(info.db_name == db_name_);</a>
<a name="ln918">    assert(IsValidColumnFamilyName(info.cf_name));</a>
<a name="ln919">    VerifyFilePath(info.file_path);</a>
<a name="ln920">    assert(info.file_size &gt; 0);</a>
<a name="ln921">    assert(info.job_id &gt; 0);</a>
<a name="ln922">    assert(info.table_properties.data_size &gt; 0);</a>
<a name="ln923">    assert(info.table_properties.raw_key_size &gt; 0);</a>
<a name="ln924">    assert(info.table_properties.num_entries &gt; 0);</a>
<a name="ln925">  }</a>
<a name="ln926"> </a>
<a name="ln927"> protected:</a>
<a name="ln928">  bool IsValidColumnFamilyName(const std::string&amp; cf_name) const {</a>
<a name="ln929">    if (cf_name == kDefaultColumnFamilyName) {</a>
<a name="ln930">      return true;</a>
<a name="ln931">    }</a>
<a name="ln932">    // The column family names in the stress tests are numbers.</a>
<a name="ln933">    for (size_t i = 0; i &lt; cf_name.size(); ++i) {</a>
<a name="ln934">      if (cf_name[i] &lt; '0' || cf_name[i] &gt; '9') {</a>
<a name="ln935">        return false;</a>
<a name="ln936">      }</a>
<a name="ln937">    }</a>
<a name="ln938">    return true;</a>
<a name="ln939">  }</a>
<a name="ln940"> </a>
<a name="ln941">  void VerifyFileDir(const std::string&amp; file_dir) {</a>
<a name="ln942">#ifndef NDEBUG</a>
<a name="ln943">    if (db_name_ == file_dir) {</a>
<a name="ln944">      return;</a>
<a name="ln945">    }</a>
<a name="ln946">    for (const auto&amp; db_path : db_paths_) {</a>
<a name="ln947">      if (db_path.path == file_dir) {</a>
<a name="ln948">        return;</a>
<a name="ln949">      }</a>
<a name="ln950">    }</a>
<a name="ln951">    assert(false);</a>
<a name="ln952">#endif  // !NDEBUG</a>
<a name="ln953">  }</a>
<a name="ln954"> </a>
<a name="ln955">  void VerifyFileName(const std::string&amp; file_name) {</a>
<a name="ln956">#ifndef NDEBUG</a>
<a name="ln957">    uint64_t file_number;</a>
<a name="ln958">    FileType file_type;</a>
<a name="ln959">    bool result = ParseFileName(file_name, &amp;file_number, &amp;file_type);</a>
<a name="ln960">    assert(result);</a>
<a name="ln961">    assert(file_type == kTableFile);</a>
<a name="ln962">#endif  // !NDEBUG</a>
<a name="ln963">  }</a>
<a name="ln964"> </a>
<a name="ln965">  void VerifyFilePath(const std::string&amp; file_path) {</a>
<a name="ln966">#ifndef NDEBUG</a>
<a name="ln967">    size_t pos = file_path.find_last_of(&quot;/&quot;);</a>
<a name="ln968">    if (pos == std::string::npos) {</a>
<a name="ln969">      VerifyFileName(file_path);</a>
<a name="ln970">    } else {</a>
<a name="ln971">      if (pos &gt; 0) {</a>
<a name="ln972">        VerifyFileDir(file_path.substr(0, pos));</a>
<a name="ln973">      }</a>
<a name="ln974">      VerifyFileName(file_path.substr(pos));</a>
<a name="ln975">    }</a>
<a name="ln976">#endif  // !NDEBUG</a>
<a name="ln977">  }</a>
<a name="ln978">#endif  // !ROCKSDB_LITE</a>
<a name="ln979"> </a>
<a name="ln980"> private:</a>
<a name="ln981">  std::string db_name_;</a>
<a name="ln982">  std::vector&lt;DbPath&gt; db_paths_;</a>
<a name="ln983">  Random rand_;</a>
<a name="ln984">};</a>
<a name="ln985"> </a>
<a name="ln986">}  // namespace</a>
<a name="ln987"> </a>
<a name="ln988">class StressTest {</a>
<a name="ln989"> public:</a>
<a name="ln990">  StressTest()</a>
<a name="ln991">      : cache_(NewLRUCache(FLAGS_cache_size)),</a>
<a name="ln992">        compressed_cache_(FLAGS_compressed_cache_size &gt;= 0</a>
<a name="ln993">                              ? NewLRUCache(FLAGS_compressed_cache_size)</a>
<a name="ln994">                              : nullptr),</a>
<a name="ln995">        filter_policy_(FLAGS_bloom_bits &gt;= 0</a>
<a name="ln996">                   ? FLAGS_use_block_based_filter</a>
<a name="ln997">                     ? NewBloomFilterPolicy(FLAGS_bloom_bits, true)</a>
<a name="ln998">                     : NewBloomFilterPolicy(FLAGS_bloom_bits, false)</a>
<a name="ln999">                   : nullptr),</a>
<a name="ln1000">        db_(nullptr),</a>
<a name="ln1001">        new_column_family_name_(1),</a>
<a name="ln1002">        num_times_reopened_(0) {</a>
<a name="ln1003">    if (FLAGS_destroy_db_initially) {</a>
<a name="ln1004">      std::vector&lt;std::string&gt; files;</a>
<a name="ln1005">      FLAGS_env-&gt;GetChildren(FLAGS_db, &amp;files);</a>
<a name="ln1006">      for (unsigned int i = 0; i &lt; files.size(); i++) {</a>
<a name="ln1007">        if (Slice(files[i]).starts_with(&quot;heap-&quot;)) {</a>
<a name="ln1008">          FLAGS_env-&gt;DeleteFile(FLAGS_db + &quot;/&quot; + files[i]);</a>
<a name="ln1009">        }</a>
<a name="ln1010">      }</a>
<a name="ln1011">      DestroyDB(FLAGS_db, Options());</a>
<a name="ln1012">    }</a>
<a name="ln1013">  }</a>
<a name="ln1014"> </a>
<a name="ln1015">  ~StressTest() {</a>
<a name="ln1016">    for (auto cf : column_families_) {</a>
<a name="ln1017">      delete cf;</a>
<a name="ln1018">    }</a>
<a name="ln1019">    column_families_.clear();</a>
<a name="ln1020">    delete db_;</a>
<a name="ln1021">  }</a>
<a name="ln1022"> </a>
<a name="ln1023">  bool BuildOptionsTable() {</a>
<a name="ln1024">    if (FLAGS_set_options_one_in &lt;= 0) {</a>
<a name="ln1025">      return true;</a>
<a name="ln1026">    }</a>
<a name="ln1027"> </a>
<a name="ln1028">    std::unordered_map&lt;std::string, std::vector&lt;std::string&gt; &gt; options_tbl = {</a>
<a name="ln1029">        {&quot;write_buffer_size&quot;,</a>
<a name="ln1030">         {ToString(FLAGS_write_buffer_size),</a>
<a name="ln1031">          ToString(FLAGS_write_buffer_size * 2),</a>
<a name="ln1032">          ToString(FLAGS_write_buffer_size * 4)}},</a>
<a name="ln1033">        {&quot;max_write_buffer_number&quot;,</a>
<a name="ln1034">         {ToString(FLAGS_max_write_buffer_number),</a>
<a name="ln1035">          ToString(FLAGS_max_write_buffer_number * 2),</a>
<a name="ln1036">          ToString(FLAGS_max_write_buffer_number * 4)}},</a>
<a name="ln1037">        {&quot;arena_block_size&quot;,</a>
<a name="ln1038">         {</a>
<a name="ln1039">             ToString(Options().arena_block_size),</a>
<a name="ln1040">             ToString(FLAGS_write_buffer_size / 4),</a>
<a name="ln1041">             ToString(FLAGS_write_buffer_size / 8),</a>
<a name="ln1042">         }},</a>
<a name="ln1043">        {&quot;memtable_prefix_bloom_bits&quot;, {&quot;0&quot;, &quot;8&quot;, &quot;10&quot;}},</a>
<a name="ln1044">        {&quot;memtable_prefix_bloom_probes&quot;, {&quot;4&quot;, &quot;5&quot;, &quot;6&quot;}},</a>
<a name="ln1045">        {&quot;memtable_prefix_bloom_huge_page_tlb_size&quot;,</a>
<a name="ln1046">         {&quot;0&quot;, ToString(2 * 1024 * 1024)}},</a>
<a name="ln1047">        {&quot;max_successive_merges&quot;, {&quot;0&quot;, &quot;2&quot;, &quot;4&quot;}},</a>
<a name="ln1048">        {&quot;filter_deletes&quot;, {&quot;0&quot;, &quot;1&quot;}},</a>
<a name="ln1049">        {&quot;inplace_update_num_locks&quot;, {&quot;100&quot;, &quot;200&quot;, &quot;300&quot;}},</a>
<a name="ln1050">        // TODO(ljin): enable test for this option</a>
<a name="ln1051">        // {&quot;disable_auto_compactions&quot;, {&quot;100&quot;, &quot;200&quot;, &quot;300&quot;}},</a>
<a name="ln1052">        {&quot;soft_rate_limit&quot;, {&quot;0&quot;, &quot;0.5&quot;, &quot;0.9&quot;}},</a>
<a name="ln1053">        {&quot;hard_rate_limit&quot;, {&quot;0&quot;, &quot;1.1&quot;, &quot;2.0&quot;}},</a>
<a name="ln1054">        {&quot;level0_file_num_compaction_trigger&quot;,</a>
<a name="ln1055">         {</a>
<a name="ln1056">             ToString(FLAGS_level0_file_num_compaction_trigger),</a>
<a name="ln1057">             ToString(FLAGS_level0_file_num_compaction_trigger + 2),</a>
<a name="ln1058">             ToString(FLAGS_level0_file_num_compaction_trigger + 4),</a>
<a name="ln1059">         }},</a>
<a name="ln1060">        {&quot;level0_slowdown_writes_trigger&quot;,</a>
<a name="ln1061">         {</a>
<a name="ln1062">             ToString(FLAGS_level0_slowdown_writes_trigger),</a>
<a name="ln1063">             ToString(FLAGS_level0_slowdown_writes_trigger + 2),</a>
<a name="ln1064">             ToString(FLAGS_level0_slowdown_writes_trigger + 4),</a>
<a name="ln1065">         }},</a>
<a name="ln1066">        {&quot;level0_stop_writes_trigger&quot;,</a>
<a name="ln1067">         {</a>
<a name="ln1068">             ToString(FLAGS_level0_stop_writes_trigger),</a>
<a name="ln1069">             ToString(FLAGS_level0_stop_writes_trigger + 2),</a>
<a name="ln1070">             ToString(FLAGS_level0_stop_writes_trigger + 4),</a>
<a name="ln1071">         }},</a>
<a name="ln1072">        {&quot;max_grandparent_overlap_factor&quot;,</a>
<a name="ln1073">         {</a>
<a name="ln1074">             ToString(Options().max_grandparent_overlap_factor - 5),</a>
<a name="ln1075">             ToString(Options().max_grandparent_overlap_factor),</a>
<a name="ln1076">             ToString(Options().max_grandparent_overlap_factor + 5),</a>
<a name="ln1077">         }},</a>
<a name="ln1078">        {&quot;expanded_compaction_factor&quot;,</a>
<a name="ln1079">         {</a>
<a name="ln1080">             ToString(Options().expanded_compaction_factor - 5),</a>
<a name="ln1081">             ToString(Options().expanded_compaction_factor),</a>
<a name="ln1082">             ToString(Options().expanded_compaction_factor + 5),</a>
<a name="ln1083">         }},</a>
<a name="ln1084">        {&quot;source_compaction_factor&quot;,</a>
<a name="ln1085">         {</a>
<a name="ln1086">             ToString(Options().source_compaction_factor),</a>
<a name="ln1087">             ToString(Options().source_compaction_factor * 2),</a>
<a name="ln1088">             ToString(Options().source_compaction_factor * 4),</a>
<a name="ln1089">         }},</a>
<a name="ln1090">        {&quot;target_file_size_base&quot;,</a>
<a name="ln1091">         {</a>
<a name="ln1092">             ToString(FLAGS_target_file_size_base),</a>
<a name="ln1093">             ToString(FLAGS_target_file_size_base * 2),</a>
<a name="ln1094">             ToString(FLAGS_target_file_size_base * 4),</a>
<a name="ln1095">         }},</a>
<a name="ln1096">        {&quot;target_file_size_multiplier&quot;,</a>
<a name="ln1097">         {</a>
<a name="ln1098">             ToString(FLAGS_target_file_size_multiplier), &quot;1&quot;, &quot;2&quot;,</a>
<a name="ln1099">         }},</a>
<a name="ln1100">        {&quot;max_bytes_for_level_base&quot;,</a>
<a name="ln1101">         {</a>
<a name="ln1102">             ToString(FLAGS_max_bytes_for_level_base / 2),</a>
<a name="ln1103">             ToString(FLAGS_max_bytes_for_level_base),</a>
<a name="ln1104">             ToString(FLAGS_max_bytes_for_level_base * 2),</a>
<a name="ln1105">         }},</a>
<a name="ln1106">        {&quot;max_bytes_for_level_multiplier&quot;,</a>
<a name="ln1107">         {</a>
<a name="ln1108">             ToString(FLAGS_max_bytes_for_level_multiplier), &quot;1&quot;, &quot;2&quot;,</a>
<a name="ln1109">         }},</a>
<a name="ln1110">        {&quot;max_sequential_skip_in_iterations&quot;, {&quot;4&quot;, &quot;8&quot;, &quot;12&quot;}},</a>
<a name="ln1111">    };</a>
<a name="ln1112"> </a>
<a name="ln1113">    options_table_ = std::move(options_tbl);</a>
<a name="ln1114"> </a>
<a name="ln1115">    for (const auto&amp; iter : options_table_) {</a>
<a name="ln1116">      options_index_.push_back(iter.first);</a>
<a name="ln1117">    }</a>
<a name="ln1118">    return true;</a>
<a name="ln1119">  }</a>
<a name="ln1120"> </a>
<a name="ln1121">  bool Run() {</a>
<a name="ln1122">    PrintEnv();</a>
<a name="ln1123">    BuildOptionsTable();</a>
<a name="ln1124">    Open();</a>
<a name="ln1125">    SharedState shared(this);</a>
<a name="ln1126">    uint32_t n = shared.GetNumThreads();</a>
<a name="ln1127"> </a>
<a name="ln1128">    std::vector&lt;ThreadState*&gt; threads(n);</a>
<a name="ln1129">    for (uint32_t i = 0; i &lt; n; i++) {</a>
<a name="ln1130">      threads[i] = new ThreadState(i, &amp;shared);</a>
<a name="ln1131">      FLAGS_env-&gt;StartThread(ThreadBody, threads[i]);</a>
<a name="ln1132">    }</a>
<a name="ln1133">    ThreadState bg_thread(0, &amp;shared);</a>
<a name="ln1134">    if (FLAGS_compaction_thread_pool_adjust_interval &gt; 0) {</a>
<a name="ln1135">      FLAGS_env-&gt;StartThread(PoolSizeChangeThread, &amp;bg_thread);</a>
<a name="ln1136">    }</a>
<a name="ln1137"> </a>
<a name="ln1138">    // Each thread goes through the following states:</a>
<a name="ln1139">    // initializing -&gt; wait for others to init -&gt; read/populate/depopulate</a>
<a name="ln1140">    // wait for others to operate -&gt; verify -&gt; done</a>
<a name="ln1141"> </a>
<a name="ln1142">    {</a>
<a name="ln1143">      MutexLock l(shared.GetMutex());</a>
<a name="ln1144">      while (!shared.AllInitialized()) {</a>
<a name="ln1145">        shared.GetCondVar()-&gt;Wait();</a>
<a name="ln1146">      }</a>
<a name="ln1147"> </a>
<a name="ln1148">      auto now = FLAGS_env-&gt;NowMicros();</a>
<a name="ln1149">      fprintf(stdout, &quot;%s Starting database operations\n&quot;,</a>
<a name="ln1150">              FLAGS_env-&gt;TimeToString(now/1000000).c_str());</a>
<a name="ln1151"> </a>
<a name="ln1152">      shared.SetStart();</a>
<a name="ln1153">      shared.GetCondVar()-&gt;SignalAll();</a>
<a name="ln1154">      while (!shared.AllOperated()) {</a>
<a name="ln1155">        shared.GetCondVar()-&gt;Wait();</a>
<a name="ln1156">      }</a>
<a name="ln1157"> </a>
<a name="ln1158">      now = FLAGS_env-&gt;NowMicros();</a>
<a name="ln1159">      if (FLAGS_test_batches_snapshots) {</a>
<a name="ln1160">        fprintf(stdout, &quot;%s Limited verification already done during gets\n&quot;,</a>
<a name="ln1161">                FLAGS_env-&gt;TimeToString((uint64_t) now/1000000).c_str());</a>
<a name="ln1162">      } else {</a>
<a name="ln1163">        fprintf(stdout, &quot;%s Starting verification\n&quot;,</a>
<a name="ln1164">                FLAGS_env-&gt;TimeToString((uint64_t) now/1000000).c_str());</a>
<a name="ln1165">      }</a>
<a name="ln1166"> </a>
<a name="ln1167">      shared.SetStartVerify();</a>
<a name="ln1168">      shared.GetCondVar()-&gt;SignalAll();</a>
<a name="ln1169">      while (!shared.AllDone()) {</a>
<a name="ln1170">        shared.GetCondVar()-&gt;Wait();</a>
<a name="ln1171">      }</a>
<a name="ln1172">    }</a>
<a name="ln1173"> </a>
<a name="ln1174">    for (unsigned int i = 1; i &lt; n; i++) {</a>
<a name="ln1175">      threads[0]-&gt;stats.Merge(threads[i]-&gt;stats);</a>
<a name="ln1176">    }</a>
<a name="ln1177">    threads[0]-&gt;stats.Report(&quot;Stress Test&quot;);</a>
<a name="ln1178"> </a>
<a name="ln1179">    for (unsigned int i = 0; i &lt; n; i++) {</a>
<a name="ln1180">      delete threads[i];</a>
<a name="ln1181">      threads[i] = nullptr;</a>
<a name="ln1182">    }</a>
<a name="ln1183">    auto now = FLAGS_env-&gt;NowMicros();</a>
<a name="ln1184">    if (!FLAGS_test_batches_snapshots) {</a>
<a name="ln1185">      fprintf(stdout, &quot;%s Verification successful\n&quot;,</a>
<a name="ln1186">              FLAGS_env-&gt;TimeToString(now/1000000).c_str());</a>
<a name="ln1187">    }</a>
<a name="ln1188">    PrintStatistics();</a>
<a name="ln1189"> </a>
<a name="ln1190">    if (FLAGS_compaction_thread_pool_adjust_interval &gt; 0) {</a>
<a name="ln1191">      MutexLock l(shared.GetMutex());</a>
<a name="ln1192">      shared.SetShouldStopBgThread();</a>
<a name="ln1193">      while (!shared.BgThreadFinished()) {</a>
<a name="ln1194">        shared.GetCondVar()-&gt;Wait();</a>
<a name="ln1195">      }</a>
<a name="ln1196">    }</a>
<a name="ln1197"> </a>
<a name="ln1198">    if (shared.HasVerificationFailedYet()) {</a>
<a name="ln1199">      printf(&quot;Verification failed :(\n&quot;);</a>
<a name="ln1200">      return false;</a>
<a name="ln1201">    }</a>
<a name="ln1202">    return true;</a>
<a name="ln1203">  }</a>
<a name="ln1204"> </a>
<a name="ln1205"> private:</a>
<a name="ln1206"> </a>
<a name="ln1207">  static void ThreadBody(void* v) {</a>
<a name="ln1208">    ThreadState* thread = reinterpret_cast&lt;ThreadState*&gt;(v);</a>
<a name="ln1209">    SharedState* shared = thread-&gt;shared;</a>
<a name="ln1210"> </a>
<a name="ln1211">    {</a>
<a name="ln1212">      MutexLock l(shared-&gt;GetMutex());</a>
<a name="ln1213">      shared-&gt;IncInitialized();</a>
<a name="ln1214">      if (shared-&gt;AllInitialized()) {</a>
<a name="ln1215">        shared-&gt;GetCondVar()-&gt;SignalAll();</a>
<a name="ln1216">      }</a>
<a name="ln1217">      while (!shared-&gt;Started()) {</a>
<a name="ln1218">        shared-&gt;GetCondVar()-&gt;Wait();</a>
<a name="ln1219">      }</a>
<a name="ln1220">    }</a>
<a name="ln1221">    thread-&gt;shared-&gt;GetStressTest()-&gt;OperateDb(thread);</a>
<a name="ln1222"> </a>
<a name="ln1223">    {</a>
<a name="ln1224">      MutexLock l(shared-&gt;GetMutex());</a>
<a name="ln1225">      shared-&gt;IncOperated();</a>
<a name="ln1226">      if (shared-&gt;AllOperated()) {</a>
<a name="ln1227">        shared-&gt;GetCondVar()-&gt;SignalAll();</a>
<a name="ln1228">      }</a>
<a name="ln1229">      while (!shared-&gt;VerifyStarted()) {</a>
<a name="ln1230">        shared-&gt;GetCondVar()-&gt;Wait();</a>
<a name="ln1231">      }</a>
<a name="ln1232">    }</a>
<a name="ln1233"> </a>
<a name="ln1234">    if (!FLAGS_test_batches_snapshots) {</a>
<a name="ln1235">      thread-&gt;shared-&gt;GetStressTest()-&gt;VerifyDb(thread);</a>
<a name="ln1236">    }</a>
<a name="ln1237"> </a>
<a name="ln1238">    {</a>
<a name="ln1239">      MutexLock l(shared-&gt;GetMutex());</a>
<a name="ln1240">      shared-&gt;IncDone();</a>
<a name="ln1241">      if (shared-&gt;AllDone()) {</a>
<a name="ln1242">        shared-&gt;GetCondVar()-&gt;SignalAll();</a>
<a name="ln1243">      }</a>
<a name="ln1244">    }</a>
<a name="ln1245"> </a>
<a name="ln1246">  }</a>
<a name="ln1247"> </a>
<a name="ln1248">  static void PoolSizeChangeThread(void* v) {</a>
<a name="ln1249">    assert(FLAGS_compaction_thread_pool_adjust_interval &gt; 0);</a>
<a name="ln1250">    ThreadState* thread = reinterpret_cast&lt;ThreadState*&gt;(v);</a>
<a name="ln1251">    SharedState* shared = thread-&gt;shared;</a>
<a name="ln1252"> </a>
<a name="ln1253">    while (true) {</a>
<a name="ln1254">      {</a>
<a name="ln1255">        MutexLock l(shared-&gt;GetMutex());</a>
<a name="ln1256">        if (shared-&gt;ShoudStopBgThread()) {</a>
<a name="ln1257">          shared-&gt;SetBgThreadFinish();</a>
<a name="ln1258">          shared-&gt;GetCondVar()-&gt;SignalAll();</a>
<a name="ln1259">          return;</a>
<a name="ln1260">        }</a>
<a name="ln1261">      }</a>
<a name="ln1262"> </a>
<a name="ln1263">      auto thread_pool_size_base = FLAGS_max_background_compactions;</a>
<a name="ln1264">      auto thread_pool_size_var = FLAGS_compaction_thread_pool_variations;</a>
<a name="ln1265">      int new_thread_pool_size =</a>
<a name="ln1266">          thread_pool_size_base - thread_pool_size_var +</a>
<a name="ln1267">          thread-&gt;rand.Next() % (thread_pool_size_var * 2 + 1);</a>
<a name="ln1268">      if (new_thread_pool_size &lt; 1) {</a>
<a name="ln1269">        new_thread_pool_size = 1;</a>
<a name="ln1270">      }</a>
<a name="ln1271">      FLAGS_env-&gt;SetBackgroundThreads(new_thread_pool_size);</a>
<a name="ln1272">      // Sleep up to 3 seconds</a>
<a name="ln1273">      FLAGS_env-&gt;SleepForMicroseconds(</a>
<a name="ln1274">          thread-&gt;rand.Next() % FLAGS_compaction_thread_pool_adjust_interval *</a>
<a name="ln1275">              1000 +</a>
<a name="ln1276">          1);</a>
<a name="ln1277">    }</a>
<a name="ln1278">  }</a>
<a name="ln1279"> </a>
<a name="ln1280">  // Given a key K and value V, this puts (&quot;0&quot;+K, &quot;0&quot;+V), (&quot;1&quot;+K, &quot;1&quot;+V), ...</a>
<a name="ln1281">  // (&quot;9&quot;+K, &quot;9&quot;+V) in DB atomically i.e in a single batch.</a>
<a name="ln1282">  // Also refer MultiGet.</a>
<a name="ln1283">  Status MultiPut(ThreadState* thread, const WriteOptions&amp; writeoptions,</a>
<a name="ln1284">                  ColumnFamilyHandle* column_family, const Slice&amp; key,</a>
<a name="ln1285">                  const Slice&amp; value, size_t sz) {</a>
<a name="ln1286">    std::string keys[10] = {&quot;9&quot;, &quot;8&quot;, &quot;7&quot;, &quot;6&quot;, &quot;5&quot;,</a>
<a name="ln1287">                            &quot;4&quot;, &quot;3&quot;, &quot;2&quot;, &quot;1&quot;, &quot;0&quot;};</a>
<a name="ln1288">    std::string values[10] = {&quot;9&quot;, &quot;8&quot;, &quot;7&quot;, &quot;6&quot;, &quot;5&quot;,</a>
<a name="ln1289">                              &quot;4&quot;, &quot;3&quot;, &quot;2&quot;, &quot;1&quot;, &quot;0&quot;};</a>
<a name="ln1290">    Slice value_slices[10];</a>
<a name="ln1291">    WriteBatch batch;</a>
<a name="ln1292">    Status s;</a>
<a name="ln1293">    for (int i = 0; i &lt; 10; i++) {</a>
<a name="ln1294">      keys[i] += key.ToString();</a>
<a name="ln1295">      values[i] += value.ToString();</a>
<a name="ln1296">      value_slices[i] = values[i];</a>
<a name="ln1297">      if (FLAGS_use_merge) {</a>
<a name="ln1298">        batch.Merge(column_family, keys[i], value_slices[i]);</a>
<a name="ln1299">      } else {</a>
<a name="ln1300">        batch.Put(column_family, keys[i], value_slices[i]);</a>
<a name="ln1301">      }</a>
<a name="ln1302">    }</a>
<a name="ln1303"> </a>
<a name="ln1304">    s = db_-&gt;Write(writeoptions, &amp;batch);</a>
<a name="ln1305">    if (!s.ok()) {</a>
<a name="ln1306">      fprintf(stderr, &quot;multiput error: %s\n&quot;, s.ToString().c_str());</a>
<a name="ln1307">      thread-&gt;stats.AddErrors(1);</a>
<a name="ln1308">    } else {</a>
<a name="ln1309">      // we did 10 writes each of size sz + 1</a>
<a name="ln1310">      thread-&gt;stats.AddBytesForWrites(10, (sz + 1) * 10);</a>
<a name="ln1311">    }</a>
<a name="ln1312"> </a>
<a name="ln1313">    return s;</a>
<a name="ln1314">  }</a>
<a name="ln1315"> </a>
<a name="ln1316">  // Given a key K, this deletes (&quot;0&quot;+K), (&quot;1&quot;+K),... (&quot;9&quot;+K)</a>
<a name="ln1317">  // in DB atomically i.e in a single batch. Also refer MultiGet.</a>
<a name="ln1318">  Status MultiDelete(ThreadState* thread, const WriteOptions&amp; writeoptions,</a>
<a name="ln1319">                     ColumnFamilyHandle* column_family, const Slice&amp; key) {</a>
<a name="ln1320">    std::string keys[10] = {&quot;9&quot;, &quot;7&quot;, &quot;5&quot;, &quot;3&quot;, &quot;1&quot;,</a>
<a name="ln1321">                            &quot;8&quot;, &quot;6&quot;, &quot;4&quot;, &quot;2&quot;, &quot;0&quot;};</a>
<a name="ln1322"> </a>
<a name="ln1323">    WriteBatch batch;</a>
<a name="ln1324">    Status s;</a>
<a name="ln1325">    for (int i = 0; i &lt; 10; i++) {</a>
<a name="ln1326">      keys[i] += key.ToString();</a>
<a name="ln1327">      batch.Delete(column_family, keys[i]);</a>
<a name="ln1328">    }</a>
<a name="ln1329"> </a>
<a name="ln1330">    s = db_-&gt;Write(writeoptions, &amp;batch);</a>
<a name="ln1331">    if (!s.ok()) {</a>
<a name="ln1332">      fprintf(stderr, &quot;multidelete error: %s\n&quot;, s.ToString().c_str());</a>
<a name="ln1333">      thread-&gt;stats.AddErrors(1);</a>
<a name="ln1334">    } else {</a>
<a name="ln1335">      thread-&gt;stats.AddDeletes(10);</a>
<a name="ln1336">    }</a>
<a name="ln1337"> </a>
<a name="ln1338">    return s;</a>
<a name="ln1339">  }</a>
<a name="ln1340"> </a>
<a name="ln1341">  // Given a key K, this gets values for &quot;0&quot;+K, &quot;1&quot;+K,...&quot;9&quot;+K</a>
<a name="ln1342">  // in the same snapshot, and verifies that all the values are of the form</a>
<a name="ln1343">  // &quot;0&quot;+V, &quot;1&quot;+V,...&quot;9&quot;+V.</a>
<a name="ln1344">  // ASSUMES that MultiPut was used to put (K, V) into the DB.</a>
<a name="ln1345">  Status MultiGet(ThreadState* thread, const ReadOptions&amp; readoptions,</a>
<a name="ln1346">                  ColumnFamilyHandle* column_family, const Slice&amp; key,</a>
<a name="ln1347">                  std::string* value) {</a>
<a name="ln1348">    std::string keys[10] = {&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;};</a>
<a name="ln1349">    Slice key_slices[10];</a>
<a name="ln1350">    std::string values[10];</a>
<a name="ln1351">    ReadOptions readoptionscopy = readoptions;</a>
<a name="ln1352">    readoptionscopy.snapshot = db_-&gt;GetSnapshot();</a>
<a name="ln1353">    Status s;</a>
<a name="ln1354">    for (int i = 0; i &lt; 10; i++) {</a>
<a name="ln1355">      keys[i] += key.ToString();</a>
<a name="ln1356">      key_slices[i] = keys[i];</a>
<a name="ln1357">      s = db_-&gt;Get(readoptionscopy, column_family, key_slices[i], value);</a>
<a name="ln1358">      if (!s.ok() &amp;&amp; !s.IsNotFound()) {</a>
<a name="ln1359">        fprintf(stderr, &quot;get error: %s\n&quot;, s.ToString().c_str());</a>
<a name="ln1360">        values[i] = &quot;&quot;;</a>
<a name="ln1361">        thread-&gt;stats.AddErrors(1);</a>
<a name="ln1362">        // we continue after error rather than exiting so that we can</a>
<a name="ln1363">        // find more errors if any</a>
<a name="ln1364">      } else if (s.IsNotFound()) {</a>
<a name="ln1365">        values[i] = &quot;&quot;;</a>
<a name="ln1366">        thread-&gt;stats.AddGets(1, 0);</a>
<a name="ln1367">      } else {</a>
<a name="ln1368">        values[i] = *value;</a>
<a name="ln1369"> </a>
<a name="ln1370">        char expected_prefix = (keys[i])[0];</a>
<a name="ln1371">        char actual_prefix = (values[i])[0];</a>
<a name="ln1372">        if (actual_prefix != expected_prefix) {</a>
<a name="ln1373">          fprintf(stderr, &quot;error expected prefix = %c actual = %c\n&quot;,</a>
<a name="ln1374">                  expected_prefix, actual_prefix);</a>
<a name="ln1375">        }</a>
<a name="ln1376">        (values[i])[0] = ' '; // blank out the differing character</a>
<a name="ln1377">        thread-&gt;stats.AddGets(1, 1);</a>
<a name="ln1378">      }</a>
<a name="ln1379">    }</a>
<a name="ln1380">    db_-&gt;ReleaseSnapshot(readoptionscopy.snapshot);</a>
<a name="ln1381"> </a>
<a name="ln1382">    // Now that we retrieved all values, check that they all match</a>
<a name="ln1383">    for (int i = 1; i &lt; 10; i++) {</a>
<a name="ln1384">      if (values[i] != values[0]) {</a>
<a name="ln1385">        fprintf(stderr, &quot;error : inconsistent values for key %s: %s, %s\n&quot;,</a>
<a name="ln1386">                key.ToString(true).c_str(), StringToHex(values[0]).c_str(),</a>
<a name="ln1387">                StringToHex(values[i]).c_str());</a>
<a name="ln1388">      // we continue after error rather than exiting so that we can</a>
<a name="ln1389">      // find more errors if any</a>
<a name="ln1390">      }</a>
<a name="ln1391">    }</a>
<a name="ln1392"> </a>
<a name="ln1393">    return s;</a>
<a name="ln1394">  }</a>
<a name="ln1395"> </a>
<a name="ln1396">  // Given a key, this does prefix scans for &quot;0&quot;+P, &quot;1&quot;+P,...&quot;9&quot;+P</a>
<a name="ln1397">  // in the same snapshot where P is the first FLAGS_prefix_size - 1 bytes</a>
<a name="ln1398">  // of the key. Each of these 10 scans returns a series of values;</a>
<a name="ln1399">  // each series should be the same length, and it is verified for each</a>
<a name="ln1400">  // index i that all the i'th values are of the form &quot;0&quot;+V, &quot;1&quot;+V,...&quot;9&quot;+V.</a>
<a name="ln1401">  // ASSUMES that MultiPut was used to put (K, V)</a>
<a name="ln1402">  Status MultiPrefixScan(ThreadState* thread, const ReadOptions&amp; readoptions,</a>
<a name="ln1403">                         ColumnFamilyHandle* column_family,</a>
<a name="ln1404">                         const Slice&amp; key) {</a>
<a name="ln1405">    std::string prefixes[10] = {&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;,</a>
<a name="ln1406">                                &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;};</a>
<a name="ln1407">    Slice prefix_slices[10];</a>
<a name="ln1408">    ReadOptions readoptionscopy[10];</a>
<a name="ln1409">    const Snapshot* snapshot = db_-&gt;GetSnapshot();</a>
<a name="ln1410">    Iterator* iters[10];</a>
<a name="ln1411">    Status s = Status::OK();</a>
<a name="ln1412">    for (int i = 0; i &lt; 10; i++) {</a>
<a name="ln1413">      prefixes[i] += key.ToString();</a>
<a name="ln1414">      prefixes[i].resize(FLAGS_prefix_size);</a>
<a name="ln1415">      prefix_slices[i] = Slice(prefixes[i]);</a>
<a name="ln1416">      readoptionscopy[i] = readoptions;</a>
<a name="ln1417">      readoptionscopy[i].snapshot = snapshot;</a>
<a name="ln1418">      iters[i] = db_-&gt;NewIterator(readoptionscopy[i], column_family);</a>
<a name="ln1419">      iters[i]-&gt;Seek(prefix_slices[i]);</a>
<a name="ln1420">    }</a>
<a name="ln1421"> </a>
<a name="ln1422">    int count = 0;</a>
<a name="ln1423">    while (iters[0]-&gt;Valid() &amp;&amp; iters[0]-&gt;key().starts_with(prefix_slices[0])) {</a>
<a name="ln1424">      count++;</a>
<a name="ln1425">      std::string values[10];</a>
<a name="ln1426">      // get list of all values for this iteration</a>
<a name="ln1427">      for (int i = 0; i &lt; 10; i++) {</a>
<a name="ln1428">        // no iterator should finish before the first one</a>
<a name="ln1429">        assert(iters[i]-&gt;Valid() &amp;&amp;</a>
<a name="ln1430">               iters[i]-&gt;key().starts_with(prefix_slices[i]));</a>
<a name="ln1431">        values[i] = iters[i]-&gt;value().ToString();</a>
<a name="ln1432"> </a>
<a name="ln1433">        char expected_first = (prefixes[i])[0];</a>
<a name="ln1434">        char actual_first = (values[i])[0];</a>
<a name="ln1435"> </a>
<a name="ln1436">        if (actual_first != expected_first) {</a>
<a name="ln1437">          fprintf(stderr, &quot;error expected first = %c actual = %c\n&quot;,</a>
<a name="ln1438">                  expected_first, actual_first);</a>
<a name="ln1439">        }</a>
<a name="ln1440">        (values[i])[0] = ' '; // blank out the differing character</a>
<a name="ln1441">      }</a>
<a name="ln1442">      // make sure all values are equivalent</a>
<a name="ln1443">      for (int i = 0; i &lt; 10; i++) {</a>
<a name="ln1444">        if (values[i] != values[0]) {</a>
<a name="ln1445">          fprintf(stderr, &quot;error : %d, inconsistent values for prefix %s: %s, %s\n&quot;,</a>
<a name="ln1446">                  i, prefixes[i].c_str(), StringToHex(values[0]).c_str(),</a>
<a name="ln1447">                  StringToHex(values[i]).c_str());</a>
<a name="ln1448">          // we continue after error rather than exiting so that we can</a>
<a name="ln1449">          // find more errors if any</a>
<a name="ln1450">        }</a>
<a name="ln1451">        iters[i]-&gt;Next();</a>
<a name="ln1452">      }</a>
<a name="ln1453">    }</a>
<a name="ln1454"> </a>
<a name="ln1455">    // cleanup iterators and snapshot</a>
<a name="ln1456">    for (int i = 0; i &lt; 10; i++) {</a>
<a name="ln1457">      // if the first iterator finished, they should have all finished</a>
<a name="ln1458">      assert(!iters[i]-&gt;Valid() ||</a>
<a name="ln1459">             !iters[i]-&gt;key().starts_with(prefix_slices[i]));</a>
<a name="ln1460">      assert(iters[i]-&gt;status().ok());</a>
<a name="ln1461">      delete iters[i];</a>
<a name="ln1462">    }</a>
<a name="ln1463">    db_-&gt;ReleaseSnapshot(snapshot);</a>
<a name="ln1464"> </a>
<a name="ln1465">    if (s.ok()) {</a>
<a name="ln1466">      thread-&gt;stats.AddPrefixes(1, count);</a>
<a name="ln1467">    } else {</a>
<a name="ln1468">      thread-&gt;stats.AddErrors(1);</a>
<a name="ln1469">    }</a>
<a name="ln1470"> </a>
<a name="ln1471">    return s;</a>
<a name="ln1472">  }</a>
<a name="ln1473"> </a>
<a name="ln1474">  // Given a key K, this creates an iterator which scans to K and then</a>
<a name="ln1475">  // does a random sequence of Next/Prev operations.</a>
<a name="ln1476">  Status MultiIterate(ThreadState* thread, const ReadOptions&amp; readoptions,</a>
<a name="ln1477">                      ColumnFamilyHandle* column_family, const Slice&amp; key) {</a>
<a name="ln1478">    Status s;</a>
<a name="ln1479">    const Snapshot* snapshot = db_-&gt;GetSnapshot();</a>
<a name="ln1480">    ReadOptions readoptionscopy = readoptions;</a>
<a name="ln1481">    readoptionscopy.snapshot = snapshot;</a>
<a name="ln1482">    unique_ptr&lt;Iterator&gt; iter(db_-&gt;NewIterator(readoptionscopy, column_family));</a>
<a name="ln1483"> </a>
<a name="ln1484">    iter-&gt;Seek(key);</a>
<a name="ln1485">    for (uint64_t i = 0; i &lt; FLAGS_num_iterations &amp;&amp; iter-&gt;Valid(); i++) {</a>
<a name="ln1486">      if (thread-&gt;rand.OneIn(2)) {</a>
<a name="ln1487">        iter-&gt;Next();</a>
<a name="ln1488">      } else {</a>
<a name="ln1489">        iter-&gt;Prev();</a>
<a name="ln1490">      }</a>
<a name="ln1491">    }</a>
<a name="ln1492"> </a>
<a name="ln1493">    if (s.ok()) {</a>
<a name="ln1494">      thread-&gt;stats.AddIterations(1);</a>
<a name="ln1495">    } else {</a>
<a name="ln1496">      thread-&gt;stats.AddErrors(1);</a>
<a name="ln1497">    }</a>
<a name="ln1498"> </a>
<a name="ln1499">    db_-&gt;ReleaseSnapshot(snapshot);</a>
<a name="ln1500"> </a>
<a name="ln1501">    return s;</a>
<a name="ln1502">  }</a>
<a name="ln1503"> </a>
<a name="ln1504">  Status SetOptions(ThreadState* thread) {</a>
<a name="ln1505">    assert(FLAGS_set_options_one_in &gt; 0);</a>
<a name="ln1506">    std::unordered_map&lt;std::string, std::string&gt; opts;</a>
<a name="ln1507">    std::string name = options_index_[</a>
<a name="ln1508">      thread-&gt;rand.Next() % options_index_.size()];</a>
<a name="ln1509">    int value_idx = thread-&gt;rand.Next() % options_table_[name].size();</a>
<a name="ln1510">    if (name == &quot;soft_rate_limit&quot; || name == &quot;hard_rate_limit&quot;) {</a>
<a name="ln1511">      opts[&quot;soft_rate_limit&quot;] = options_table_[&quot;soft_rate_limit&quot;][value_idx];</a>
<a name="ln1512">      opts[&quot;hard_rate_limit&quot;] = options_table_[&quot;hard_rate_limit&quot;][value_idx];</a>
<a name="ln1513">    } else if (name == &quot;level0_file_num_compaction_trigger&quot; ||</a>
<a name="ln1514">               name == &quot;level0_slowdown_writes_trigger&quot; ||</a>
<a name="ln1515">               name == &quot;level0_stop_writes_trigger&quot;) {</a>
<a name="ln1516">      opts[&quot;level0_file_num_compaction_trigger&quot;] =</a>
<a name="ln1517">        options_table_[&quot;level0_file_num_compaction_trigger&quot;][value_idx];</a>
<a name="ln1518">      opts[&quot;level0_slowdown_writes_trigger&quot;] =</a>
<a name="ln1519">        options_table_[&quot;level0_slowdown_writes_trigger&quot;][value_idx];</a>
<a name="ln1520">      opts[&quot;level0_stop_writes_trigger&quot;] =</a>
<a name="ln1521">        options_table_[&quot;level0_stop_writes_trigger&quot;][value_idx];</a>
<a name="ln1522">    } else {</a>
<a name="ln1523">      opts[name] = options_table_[name][value_idx];</a>
<a name="ln1524">    }</a>
<a name="ln1525"> </a>
<a name="ln1526">    int rand_cf_idx = thread-&gt;rand.Next() % FLAGS_column_families;</a>
<a name="ln1527">    auto cfh = column_families_[rand_cf_idx];</a>
<a name="ln1528">    return db_-&gt;SetOptions(cfh, opts);</a>
<a name="ln1529">  }</a>
<a name="ln1530"> </a>
<a name="ln1531">  void OperateDb(ThreadState* thread) {</a>
<a name="ln1532">    ReadOptions read_opts(FLAGS_verify_checksum, true);</a>
<a name="ln1533">    WriteOptions write_opts;</a>
<a name="ln1534">    auto shared = thread-&gt;shared;</a>
<a name="ln1535">    char value[100];</a>
<a name="ln1536">    auto max_key = thread-&gt;shared-&gt;GetMaxKey();</a>
<a name="ln1537">    std::string from_db;</a>
<a name="ln1538">    if (FLAGS_sync) {</a>
<a name="ln1539">      write_opts.sync = true;</a>
<a name="ln1540">    }</a>
<a name="ln1541">    write_opts.disableWAL = FLAGS_disable_wal;</a>
<a name="ln1542">    const int prefixBound = FLAGS_readpercent + FLAGS_prefixpercent;</a>
<a name="ln1543">    const int writeBound = prefixBound + FLAGS_writepercent;</a>
<a name="ln1544">    const int delBound = writeBound + FLAGS_delpercent;</a>
<a name="ln1545"> </a>
<a name="ln1546">    thread-&gt;stats.Start();</a>
<a name="ln1547">    for (uint64_t i = 0; i &lt; FLAGS_ops_per_thread; i++) {</a>
<a name="ln1548">      if (thread-&gt;shared-&gt;HasVerificationFailedYet()) {</a>
<a name="ln1549">        break;</a>
<a name="ln1550">      }</a>
<a name="ln1551">      if (i != 0 &amp;&amp; (i % (FLAGS_ops_per_thread / (FLAGS_reopen + 1))) == 0) {</a>
<a name="ln1552">        {</a>
<a name="ln1553">          thread-&gt;stats.FinishedSingleOp();</a>
<a name="ln1554">          MutexLock l(thread-&gt;shared-&gt;GetMutex());</a>
<a name="ln1555">          thread-&gt;shared-&gt;IncVotedReopen();</a>
<a name="ln1556">          if (thread-&gt;shared-&gt;AllVotedReopen()) {</a>
<a name="ln1557">            thread-&gt;shared-&gt;GetStressTest()-&gt;Reopen();</a>
<a name="ln1558">            thread-&gt;shared-&gt;GetCondVar()-&gt;SignalAll();</a>
<a name="ln1559">          } else {</a>
<a name="ln1560">            thread-&gt;shared-&gt;GetCondVar()-&gt;Wait();</a>
<a name="ln1561">          }</a>
<a name="ln1562">          // Commenting this out as we don't want to reset stats on each open.</a>
<a name="ln1563">          // thread-&gt;stats.Start();</a>
<a name="ln1564">        }</a>
<a name="ln1565">      }</a>
<a name="ln1566"> </a>
<a name="ln1567">      // Change Options</a>
<a name="ln1568">      if (FLAGS_set_options_one_in &gt; 0 &amp;&amp;</a>
<a name="ln1569">          thread-&gt;rand.OneIn(FLAGS_set_options_one_in)) {</a>
<a name="ln1570">        SetOptions(thread);</a>
<a name="ln1571">      }</a>
<a name="ln1572"> </a>
<a name="ln1573">      if (FLAGS_set_in_place_one_in &gt; 0 &amp;&amp;</a>
<a name="ln1574">          thread-&gt;rand.OneIn(FLAGS_set_in_place_one_in)) {</a>
<a name="ln1575">        options_.inplace_update_support ^= options_.inplace_update_support;</a>
<a name="ln1576">      }</a>
<a name="ln1577"> </a>
<a name="ln1578">      if (!FLAGS_test_batches_snapshots &amp;&amp;</a>
<a name="ln1579">          FLAGS_clear_column_family_one_in != 0 &amp;&amp; FLAGS_column_families &gt; 1) {</a>
<a name="ln1580">        if (thread-&gt;rand.OneIn(FLAGS_clear_column_family_one_in)) {</a>
<a name="ln1581">          // drop column family and then create it again (can't drop default)</a>
<a name="ln1582">          int cf = thread-&gt;rand.Next() % (FLAGS_column_families - 1) + 1;</a>
<a name="ln1583">          std::string new_name =</a>
<a name="ln1584">              ToString(new_column_family_name_.fetch_add(1));</a>
<a name="ln1585">          {</a>
<a name="ln1586">            MutexLock l(thread-&gt;shared-&gt;GetMutex());</a>
<a name="ln1587">            fprintf(</a>
<a name="ln1588">                stdout,</a>
<a name="ln1589">                &quot;[CF %d] Dropping and recreating column family. new name: %s\n&quot;,</a>
<a name="ln1590">                cf, new_name.c_str());</a>
<a name="ln1591">          }</a>
<a name="ln1592">          thread-&gt;shared-&gt;LockColumnFamily(cf);</a>
<a name="ln1593">          Status s __attribute__((unused));</a>
<a name="ln1594">          s = db_-&gt;DropColumnFamily(column_families_[cf]);</a>
<a name="ln1595">          delete column_families_[cf];</a>
<a name="ln1596">          if (!s.ok()) {</a>
<a name="ln1597">            fprintf(stderr, &quot;dropping column family error: %s\n&quot;,</a>
<a name="ln1598">                s.ToString().c_str());</a>
<a name="ln1599">            std::terminate();</a>
<a name="ln1600">          }</a>
<a name="ln1601">          s = db_-&gt;CreateColumnFamily(ColumnFamilyOptions(options_), new_name,</a>
<a name="ln1602">                                      &amp;column_families_[cf]);</a>
<a name="ln1603">          column_family_names_[cf] = new_name;</a>
<a name="ln1604">          thread-&gt;shared-&gt;ClearColumnFamily(cf);</a>
<a name="ln1605">          if (!s.ok()) {</a>
<a name="ln1606">            fprintf(stderr, &quot;creating column family error: %s\n&quot;,</a>
<a name="ln1607">                s.ToString().c_str());</a>
<a name="ln1608">            std::terminate();</a>
<a name="ln1609">          }</a>
<a name="ln1610">          thread-&gt;shared-&gt;UnlockColumnFamily(cf);</a>
<a name="ln1611">        }</a>
<a name="ln1612">      }</a>
<a name="ln1613"> </a>
<a name="ln1614">      size_t rand_key = thread-&gt;rand.Next() % max_key;</a>
<a name="ln1615">      int rand_column_family = thread-&gt;rand.Next() % FLAGS_column_families;</a>
<a name="ln1616">      std::string keystr = Key(rand_key);</a>
<a name="ln1617">      Slice key = keystr;</a>
<a name="ln1618">      std::unique_ptr&lt;MutexLock&gt; l;</a>
<a name="ln1619">      if (!FLAGS_test_batches_snapshots) {</a>
<a name="ln1620">        l.reset(new MutexLock(</a>
<a name="ln1621">            shared-&gt;GetMutexForKey(rand_column_family, rand_key)));</a>
<a name="ln1622">      }</a>
<a name="ln1623">      auto column_family = column_families_[rand_column_family];</a>
<a name="ln1624"> </a>
<a name="ln1625">      int prob_op = thread-&gt;rand.Uniform(100);</a>
<a name="ln1626">      if (prob_op &gt;= 0 &amp;&amp; prob_op &lt; FLAGS_readpercent) {</a>
<a name="ln1627">        // OPERATION read</a>
<a name="ln1628">        if (!FLAGS_test_batches_snapshots) {</a>
<a name="ln1629">          Status s = db_-&gt;Get(read_opts, column_family, key, &amp;from_db);</a>
<a name="ln1630">          if (s.ok()) {</a>
<a name="ln1631">            // found case</a>
<a name="ln1632">            thread-&gt;stats.AddGets(1, 1);</a>
<a name="ln1633">          } else if (s.IsNotFound()) {</a>
<a name="ln1634">            // not found case</a>
<a name="ln1635">            thread-&gt;stats.AddGets(1, 0);</a>
<a name="ln1636">          } else {</a>
<a name="ln1637">            // errors case</a>
<a name="ln1638">            thread-&gt;stats.AddErrors(1);</a>
<a name="ln1639">          }</a>
<a name="ln1640">        } else {</a>
<a name="ln1641">          MultiGet(thread, read_opts, column_family, key, &amp;from_db);</a>
<a name="ln1642">        }</a>
<a name="ln1643">      } else if (FLAGS_readpercent &lt;= prob_op &amp;&amp; prob_op &lt; prefixBound) {</a>
<a name="ln1644">        // OPERATION prefix scan</a>
<a name="ln1645">        // keys are 8 bytes long, prefix size is FLAGS_prefix_size. There are</a>
<a name="ln1646">        // (8 - FLAGS_prefix_size) bytes besides the prefix. So there will</a>
<a name="ln1647">        // be 2 ^ ((8 - FLAGS_prefix_size) * 8) possible keys with the same</a>
<a name="ln1648">        // prefix</a>
<a name="ln1649">        if (!FLAGS_test_batches_snapshots) {</a>
<a name="ln1650">          Slice prefix = Slice(key.data(), FLAGS_prefix_size);</a>
<a name="ln1651">          Iterator* iter = db_-&gt;NewIterator(read_opts, column_family);</a>
<a name="ln1652">          int64_t count = 0;</a>
<a name="ln1653">          for (iter-&gt;Seek(prefix);</a>
<a name="ln1654">               iter-&gt;Valid() &amp;&amp; iter-&gt;key().starts_with(prefix); iter-&gt;Next()) {</a>
<a name="ln1655">            ++count;</a>
<a name="ln1656">          }</a>
<a name="ln1657">          assert(count &lt;=</a>
<a name="ln1658">                 (static_cast&lt;int64_t&gt;(1) &lt;&lt; ((8 - FLAGS_prefix_size) * 8)));</a>
<a name="ln1659">          if (iter-&gt;status().ok()) {</a>
<a name="ln1660">            thread-&gt;stats.AddPrefixes(1, static_cast&lt;int&gt;(count));</a>
<a name="ln1661">          } else {</a>
<a name="ln1662">            thread-&gt;stats.AddErrors(1);</a>
<a name="ln1663">          }</a>
<a name="ln1664">          delete iter;</a>
<a name="ln1665">        } else {</a>
<a name="ln1666">          MultiPrefixScan(thread, read_opts, column_family, key);</a>
<a name="ln1667">        }</a>
<a name="ln1668">      } else if (prefixBound &lt;= prob_op &amp;&amp; prob_op &lt; writeBound) {</a>
<a name="ln1669">        // OPERATION write</a>
<a name="ln1670">        uint32_t value_base = thread-&gt;rand.Next();</a>
<a name="ln1671">        size_t sz = GenerateValue(value_base, value, sizeof(value));</a>
<a name="ln1672">        Slice v(value, sz);</a>
<a name="ln1673">        if (!FLAGS_test_batches_snapshots) {</a>
<a name="ln1674">          // If the chosen key does not allow overwrite and it already</a>
<a name="ln1675">          // exists, choose another key.</a>
<a name="ln1676">          while (!shared-&gt;AllowsOverwrite(rand_column_family, rand_key) &amp;&amp;</a>
<a name="ln1677">                 shared-&gt;Exists(rand_column_family, rand_key)) {</a>
<a name="ln1678">            l.reset();</a>
<a name="ln1679">            rand_key = thread-&gt;rand.Next() % max_key;</a>
<a name="ln1680">            rand_column_family = thread-&gt;rand.Next() % FLAGS_column_families;</a>
<a name="ln1681">            l.reset(new MutexLock(</a>
<a name="ln1682">                shared-&gt;GetMutexForKey(rand_column_family, rand_key)));</a>
<a name="ln1683">          }</a>
<a name="ln1684"> </a>
<a name="ln1685">          keystr = Key(rand_key);</a>
<a name="ln1686">          key = keystr;</a>
<a name="ln1687">          column_family = column_families_[rand_column_family];</a>
<a name="ln1688"> </a>
<a name="ln1689">          if (FLAGS_verify_before_write) {</a>
<a name="ln1690">            std::string keystr2 = Key(rand_key);</a>
<a name="ln1691">            Slice k = keystr2;</a>
<a name="ln1692">            Status s = db_-&gt;Get(read_opts, column_family, k, &amp;from_db);</a>
<a name="ln1693">            if (!VerifyValue(rand_column_family, rand_key, read_opts,</a>
<a name="ln1694">                             thread-&gt;shared, from_db, s, true)) {</a>
<a name="ln1695">              break;</a>
<a name="ln1696">            }</a>
<a name="ln1697">          }</a>
<a name="ln1698">          shared-&gt;Put(rand_column_family, rand_key, value_base);</a>
<a name="ln1699">          Status s;</a>
<a name="ln1700">          if (FLAGS_use_merge) {</a>
<a name="ln1701">            s = db_-&gt;Merge(write_opts, column_family, key, v);</a>
<a name="ln1702">          } else {</a>
<a name="ln1703">            s = db_-&gt;Put(write_opts, column_family, key, v);</a>
<a name="ln1704">          }</a>
<a name="ln1705">          if (!s.ok()) {</a>
<a name="ln1706">            fprintf(stderr, &quot;put or merge error: %s\n&quot;, s.ToString().c_str());</a>
<a name="ln1707">            std::terminate();</a>
<a name="ln1708">          }</a>
<a name="ln1709">          thread-&gt;stats.AddBytesForWrites(1, sz);</a>
<a name="ln1710">        } else {</a>
<a name="ln1711">          MultiPut(thread, write_opts, column_family, key, v, sz);</a>
<a name="ln1712">        }</a>
<a name="ln1713">        PrintKeyValue(rand_column_family, static_cast&lt;uint32_t&gt;(rand_key),</a>
<a name="ln1714">                      value, sz);</a>
<a name="ln1715">      } else if (writeBound &lt;= prob_op &amp;&amp; prob_op &lt; delBound) {</a>
<a name="ln1716">        // OPERATION delete</a>
<a name="ln1717">        if (!FLAGS_test_batches_snapshots) {</a>
<a name="ln1718">          // If the chosen key does not allow overwrite and it does not exist,</a>
<a name="ln1719">          // choose another key.</a>
<a name="ln1720">          while (!shared-&gt;AllowsOverwrite(rand_column_family, rand_key) &amp;&amp;</a>
<a name="ln1721">                 !shared-&gt;Exists(rand_column_family, rand_key)) {</a>
<a name="ln1722">            l.reset();</a>
<a name="ln1723">            rand_key = thread-&gt;rand.Next() % max_key;</a>
<a name="ln1724">            rand_column_family = thread-&gt;rand.Next() % FLAGS_column_families;</a>
<a name="ln1725">            l.reset(new MutexLock(</a>
<a name="ln1726">                shared-&gt;GetMutexForKey(rand_column_family, rand_key)));</a>
<a name="ln1727">          }</a>
<a name="ln1728"> </a>
<a name="ln1729">          keystr = Key(rand_key);</a>
<a name="ln1730">          key = keystr;</a>
<a name="ln1731">          column_family = column_families_[rand_column_family];</a>
<a name="ln1732"> </a>
<a name="ln1733">          // Use delete if the key may be overwritten and a single deletion</a>
<a name="ln1734">          // otherwise.</a>
<a name="ln1735">          if (shared-&gt;AllowsOverwrite(rand_column_family, rand_key)) {</a>
<a name="ln1736">            shared-&gt;Delete(rand_column_family, rand_key);</a>
<a name="ln1737">            Status s = db_-&gt;Delete(write_opts, column_family, key);</a>
<a name="ln1738">            thread-&gt;stats.AddDeletes(1);</a>
<a name="ln1739">            if (!s.ok()) {</a>
<a name="ln1740">              fprintf(stderr, &quot;delete error: %s\n&quot;, s.ToString().c_str());</a>
<a name="ln1741">              std::terminate();</a>
<a name="ln1742">            }</a>
<a name="ln1743">          } else {</a>
<a name="ln1744">            shared-&gt;SingleDelete(rand_column_family, rand_key);</a>
<a name="ln1745">            Status s = db_-&gt;SingleDelete(write_opts, column_family, key);</a>
<a name="ln1746">            thread-&gt;stats.AddSingleDeletes(1);</a>
<a name="ln1747">            if (!s.ok()) {</a>
<a name="ln1748">              fprintf(stderr, &quot;single delete error: %s\n&quot;,</a>
<a name="ln1749">                      s.ToString().c_str());</a>
<a name="ln1750">              std::terminate();</a>
<a name="ln1751">            }</a>
<a name="ln1752">          }</a>
<a name="ln1753">        } else {</a>
<a name="ln1754">          MultiDelete(thread, write_opts, column_family, key);</a>
<a name="ln1755">        }</a>
<a name="ln1756">      } else {</a>
<a name="ln1757">        // OPERATION iterate</a>
<a name="ln1758">        MultiIterate(thread, read_opts, column_family, key);</a>
<a name="ln1759">      }</a>
<a name="ln1760">      thread-&gt;stats.FinishedSingleOp();</a>
<a name="ln1761">    }</a>
<a name="ln1762"> </a>
<a name="ln1763">    thread-&gt;stats.Stop();</a>
<a name="ln1764">  }</a>
<a name="ln1765"> </a>
<a name="ln1766">  void VerifyDb(ThreadState* thread) const {</a>
<a name="ln1767">    ReadOptions options(FLAGS_verify_checksum, true);</a>
<a name="ln1768">    auto shared = thread-&gt;shared;</a>
<a name="ln1769">    const int64_t max_key = shared-&gt;GetMaxKey();</a>
<a name="ln1770">    const int64_t keys_per_thread = max_key / shared-&gt;GetNumThreads();</a>
<a name="ln1771">    int64_t start = keys_per_thread * thread-&gt;tid;</a>
<a name="ln1772">    int64_t end = start + keys_per_thread;</a>
<a name="ln1773">    if (thread-&gt;tid == shared-&gt;GetNumThreads() - 1) {</a>
<a name="ln1774">      end = max_key;</a>
<a name="ln1775">    }</a>
<a name="ln1776">    for (size_t cf = 0; cf &lt; column_families_.size(); ++cf) {</a>
<a name="ln1777">      if (thread-&gt;shared-&gt;HasVerificationFailedYet()) {</a>
<a name="ln1778">        break;</a>
<a name="ln1779">      }</a>
<a name="ln1780">      if (!thread-&gt;rand.OneIn(2)) {</a>
<a name="ln1781">        // Use iterator to verify this range</a>
<a name="ln1782">        unique_ptr&lt;Iterator&gt; iter(</a>
<a name="ln1783">            db_-&gt;NewIterator(options, column_families_[cf]));</a>
<a name="ln1784">        iter-&gt;Seek(Key(start));</a>
<a name="ln1785">        for (auto i = start; i &lt; end; i++) {</a>
<a name="ln1786">          if (thread-&gt;shared-&gt;HasVerificationFailedYet()) {</a>
<a name="ln1787">            break;</a>
<a name="ln1788">          }</a>
<a name="ln1789">          // TODO(ljin): update &quot;long&quot; to uint64_t</a>
<a name="ln1790">          // Reseek when the prefix changes</a>
<a name="ln1791">          if (i % (static_cast&lt;int64_t&gt;(1) &lt;&lt; 8 * (8 - FLAGS_prefix_size)) ==</a>
<a name="ln1792">              0) {</a>
<a name="ln1793">            iter-&gt;Seek(Key(i));</a>
<a name="ln1794">          }</a>
<a name="ln1795">          std::string from_db;</a>
<a name="ln1796">          std::string keystr = Key(i);</a>
<a name="ln1797">          Slice k = keystr;</a>
<a name="ln1798">          Status s = iter-&gt;status();</a>
<a name="ln1799">          if (iter-&gt;Valid()) {</a>
<a name="ln1800">            if (iter-&gt;key().compare(k) &gt; 0) {</a>
<a name="ln1801">              s = STATUS(NotFound, Slice());</a>
<a name="ln1802">            } else if (iter-&gt;key().compare(k) == 0) {</a>
<a name="ln1803">              from_db = iter-&gt;value().ToString();</a>
<a name="ln1804">              iter-&gt;Next();</a>
<a name="ln1805">            } else if (iter-&gt;key().compare(k) &lt; 0) {</a>
<a name="ln1806">              VerificationAbort(shared, &quot;An out of range key was found&quot;,</a>
<a name="ln1807">                                static_cast&lt;int&gt;(cf), i);</a>
<a name="ln1808">            }</a>
<a name="ln1809">          } else {</a>
<a name="ln1810">            // The iterator found no value for the key in question, so do not</a>
<a name="ln1811">            // move to the next item in the iterator</a>
<a name="ln1812">            s = STATUS(NotFound, Slice());</a>
<a name="ln1813">          }</a>
<a name="ln1814">          VerifyValue(static_cast&lt;int&gt;(cf), i, options, shared, from_db, s,</a>
<a name="ln1815">                      true);</a>
<a name="ln1816">          if (from_db.length()) {</a>
<a name="ln1817">            PrintKeyValue(static_cast&lt;int&gt;(cf), static_cast&lt;uint32_t&gt;(i),</a>
<a name="ln1818">                          from_db.data(), from_db.length());</a>
<a name="ln1819">          }</a>
<a name="ln1820">        }</a>
<a name="ln1821">      } else {</a>
<a name="ln1822">        // Use Get to verify this range</a>
<a name="ln1823">        for (auto i = start; i &lt; end; i++) {</a>
<a name="ln1824">          if (thread-&gt;shared-&gt;HasVerificationFailedYet()) {</a>
<a name="ln1825">            break;</a>
<a name="ln1826">          }</a>
<a name="ln1827">          std::string from_db;</a>
<a name="ln1828">          std::string keystr = Key(i);</a>
<a name="ln1829">          Slice k = keystr;</a>
<a name="ln1830">          Status s = db_-&gt;Get(options, column_families_[cf], k, &amp;from_db);</a>
<a name="ln1831">          VerifyValue(static_cast&lt;int&gt;(cf), i, options, shared, from_db, s,</a>
<a name="ln1832">                      true);</a>
<a name="ln1833">          if (from_db.length()) {</a>
<a name="ln1834">            PrintKeyValue(static_cast&lt;int&gt;(cf), static_cast&lt;uint32_t&gt;(i),</a>
<a name="ln1835">                          from_db.data(), from_db.length());</a>
<a name="ln1836">          }</a>
<a name="ln1837">        }</a>
<a name="ln1838">      }</a>
<a name="ln1839">    }</a>
<a name="ln1840">  }</a>
<a name="ln1841"> </a>
<a name="ln1842">  void VerificationAbort(SharedState* shared, std::string msg, int cf,</a>
<a name="ln1843">                         int64_t key) const {</a>
<a name="ln1844">    printf(&quot;Verification failed for column family %d key %&quot; PRIi64 &quot;: %s\n&quot;, cf, key,</a>
<a name="ln1845">           msg.c_str());</a>
<a name="ln1846">    shared-&gt;SetVerificationFailure();</a>
<a name="ln1847">  }</a>
<a name="ln1848"> </a>
<a name="ln1849">  bool VerifyValue(int cf, int64_t key, const ReadOptions&amp; opts,</a>
<a name="ln1850">                   SharedState* shared, const std::string&amp; value_from_db,</a>
<a name="ln1851">                   Status s, bool strict = false) const {</a>
<a name="ln1852">    if (shared-&gt;HasVerificationFailedYet()) {</a>
<a name="ln1853">      return false;</a>
<a name="ln1854">    }</a>
<a name="ln1855">    // compare value_from_db with the value in the shared state</a>
<a name="ln1856">    char value[100];</a>
<a name="ln1857">    uint32_t value_base = shared-&gt;Get(cf, key);</a>
<a name="ln1858">    if (value_base == SharedState::SENTINEL &amp;&amp; !strict) {</a>
<a name="ln1859">      return true;</a>
<a name="ln1860">    }</a>
<a name="ln1861"> </a>
<a name="ln1862">    if (s.ok()) {</a>
<a name="ln1863">      if (value_base == SharedState::SENTINEL) {</a>
<a name="ln1864">        VerificationAbort(shared, &quot;Unexpected value found&quot;, cf, key);</a>
<a name="ln1865">        return false;</a>
<a name="ln1866">      }</a>
<a name="ln1867">      size_t sz = GenerateValue(value_base, value, sizeof(value));</a>
<a name="ln1868">      if (value_from_db.length() != sz) {</a>
<a name="ln1869">        VerificationAbort(shared, &quot;Length of value read is not equal&quot;, cf, key);</a>
<a name="ln1870">        return false;</a>
<a name="ln1871">      }</a>
<a name="ln1872">      if (memcmp(value_from_db.data(), value, sz) != 0) {</a>
<a name="ln1873">        VerificationAbort(shared, &quot;Contents of value read don't match&quot;, cf,</a>
<a name="ln1874">                          key);</a>
<a name="ln1875">        return false;</a>
<a name="ln1876">      }</a>
<a name="ln1877">    } else {</a>
<a name="ln1878">      if (value_base != SharedState::SENTINEL) {</a>
<a name="ln1879">        VerificationAbort(shared, &quot;Value not found: &quot; + s.ToString(), cf, key);</a>
<a name="ln1880">        return false;</a>
<a name="ln1881">      }</a>
<a name="ln1882">    }</a>
<a name="ln1883">    return true;</a>
<a name="ln1884">  }</a>
<a name="ln1885"> </a>
<a name="ln1886">  static void PrintKeyValue(int cf, int64_t key, const char* value,</a>
<a name="ln1887">                            size_t sz) {</a>
<a name="ln1888">    if (!FLAGS_verbose) {</a>
<a name="ln1889">      return;</a>
<a name="ln1890">    }</a>
<a name="ln1891">    fprintf(stdout, &quot;[CF %d] %&quot; PRIi64 &quot; == &gt; (%&quot; ROCKSDB_PRIszt &quot;) &quot;, cf, key, sz);</a>
<a name="ln1892">    for (size_t i = 0; i &lt; sz; i++) {</a>
<a name="ln1893">      fprintf(stdout, &quot;%X&quot;, value[i]);</a>
<a name="ln1894">    }</a>
<a name="ln1895">    fprintf(stdout, &quot;\n&quot;);</a>
<a name="ln1896">  }</a>
<a name="ln1897"> </a>
<a name="ln1898">  static size_t GenerateValue(uint32_t rand, char *v, size_t max_sz) {</a>
<a name="ln1899">    size_t value_sz = ((rand % 3) + 1) * FLAGS_value_size_mult;</a>
<a name="ln1900">    assert(value_sz &lt;= max_sz &amp;&amp; value_sz &gt;= sizeof(uint32_t));</a>
<a name="ln1901">    memcpy(v, &amp;rand, sizeof(rand));</a>
<a name="ln1902">    for (size_t i=sizeof(uint32_t); i &lt; value_sz; i++) {</a>
<a name="ln1903">      v[i] = static_cast&lt;char&gt;(rand ^ i);</a>
<a name="ln1904">    }</a>
<a name="ln1905">    v[value_sz] = '\0';</a>
<a name="ln1906">    return value_sz; // the size of the value set.</a>
<a name="ln1907">  }</a>
<a name="ln1908"> </a>
<a name="ln1909">  void PrintEnv() const {</a>
<a name="ln1910">    fprintf(stdout, &quot;Column families           : %d\n&quot;, FLAGS_column_families);</a>
<a name="ln1911">    if (!FLAGS_test_batches_snapshots) {</a>
<a name="ln1912">      fprintf(stdout, &quot;Clear CFs one in          : %d\n&quot;,</a>
<a name="ln1913">              FLAGS_clear_column_family_one_in);</a>
<a name="ln1914">    }</a>
<a name="ln1915">    fprintf(stdout, &quot;Number of threads         : %d\n&quot;, FLAGS_threads);</a>
<a name="ln1916">    fprintf(stdout, &quot;Ops per thread            : %&quot; PRIu64 &quot;\n&quot;, FLAGS_ops_per_thread);</a>
<a name="ln1917">    std::string ttl_state(&quot;unused&quot;);</a>
<a name="ln1918">    if (FLAGS_ttl &gt; 0) {</a>
<a name="ln1919">      ttl_state = NumberToString(FLAGS_ttl);</a>
<a name="ln1920">    }</a>
<a name="ln1921">    fprintf(stdout, &quot;Time to live(sec)         : %s\n&quot;, ttl_state.c_str());</a>
<a name="ln1922">    fprintf(stdout, &quot;Read percentage           : %d%%\n&quot;, FLAGS_readpercent);</a>
<a name="ln1923">    fprintf(stdout, &quot;Prefix percentage         : %d%%\n&quot;, FLAGS_prefixpercent);</a>
<a name="ln1924">    fprintf(stdout, &quot;Write percentage          : %d%%\n&quot;, FLAGS_writepercent);</a>
<a name="ln1925">    fprintf(stdout, &quot;Delete percentage         : %d%%\n&quot;, FLAGS_delpercent);</a>
<a name="ln1926">    fprintf(stdout, &quot;No overwrite percentage   : %d%%\n&quot;,</a>
<a name="ln1927">            FLAGS_nooverwritepercent);</a>
<a name="ln1928">    fprintf(stdout, &quot;Iterate percentage        : %d%%\n&quot;, FLAGS_iterpercent);</a>
<a name="ln1929">    fprintf(stdout, &quot;DB-write-buffer-size      : %&quot; PRIu64 &quot;\n&quot;,</a>
<a name="ln1930">            FLAGS_db_write_buffer_size);</a>
<a name="ln1931">    fprintf(stdout, &quot;Write-buffer-size         : %d\n&quot;,</a>
<a name="ln1932">            FLAGS_write_buffer_size);</a>
<a name="ln1933">    fprintf(stdout, &quot;Iterations                : %&quot; PRIu64 &quot;\n&quot;, FLAGS_num_iterations);</a>
<a name="ln1934">    fprintf(stdout, &quot;Max key                   : %&quot; PRId64 &quot;\n&quot;, FLAGS_max_key);</a>
<a name="ln1935">    fprintf(stdout, &quot;Ratio #ops/#keys          : %f\n&quot;,</a>
<a name="ln1936">            (1.0 * FLAGS_ops_per_thread * FLAGS_threads) / FLAGS_max_key);</a>
<a name="ln1937">    fprintf(stdout, &quot;Num times DB reopens      : %d\n&quot;, FLAGS_reopen);</a>
<a name="ln1938">    fprintf(stdout, &quot;Batches/snapshots         : %d\n&quot;,</a>
<a name="ln1939">            FLAGS_test_batches_snapshots);</a>
<a name="ln1940">    fprintf(stdout, &quot;Deletes use filter        : %d\n&quot;, FLAGS_filter_deletes);</a>
<a name="ln1941">    fprintf(stdout, &quot;Do update in place        : %d\n&quot;, FLAGS_in_place_update);</a>
<a name="ln1942">    fprintf(stdout, &quot;Num keys per lock         : %d\n&quot;,</a>
<a name="ln1943">            1 &lt;&lt; FLAGS_log2_keys_per_lock);</a>
<a name="ln1944">    std::string compression = CompressionTypeToString(FLAGS_compression_type_e);</a>
<a name="ln1945">    fprintf(stdout, &quot;Compression               : %s\n&quot;, compression.c_str());</a>
<a name="ln1946"> </a>
<a name="ln1947">    const char* memtablerep = &quot;&quot;;</a>
<a name="ln1948">    switch (FLAGS_rep_factory) {</a>
<a name="ln1949">      case kSkipList:</a>
<a name="ln1950">        memtablerep = &quot;skip_list&quot;;</a>
<a name="ln1951">        break;</a>
<a name="ln1952">      case kHashSkipList:</a>
<a name="ln1953">        memtablerep = &quot;prefix_hash&quot;;</a>
<a name="ln1954">        break;</a>
<a name="ln1955">      case kVectorRep:</a>
<a name="ln1956">        memtablerep = &quot;vector&quot;;</a>
<a name="ln1957">        break;</a>
<a name="ln1958">    }</a>
<a name="ln1959"> </a>
<a name="ln1960">    fprintf(stdout, &quot;Memtablerep               : %s\n&quot;, memtablerep);</a>
<a name="ln1961"> </a>
<a name="ln1962">    fprintf(stdout, &quot;Test kill odd             : %d\n&quot;, rocksdb_kill_odds);</a>
<a name="ln1963">    if (!rocksdb_kill_prefix_blacklist.empty()) {</a>
<a name="ln1964">      fprintf(stdout, &quot;Skipping kill points prefixes:\n&quot;);</a>
<a name="ln1965">      for (auto&amp; p : rocksdb_kill_prefix_blacklist) {</a>
<a name="ln1966">        fprintf(stdout, &quot;  %s\n&quot;, p.c_str());</a>
<a name="ln1967">      }</a>
<a name="ln1968">    }</a>
<a name="ln1969"> </a>
<a name="ln1970">    fprintf(stdout, &quot;------------------------------------------------\n&quot;);</a>
<a name="ln1971">  }</a>
<a name="ln1972"> </a>
<a name="ln1973">  void Open() {</a>
<a name="ln1974">    assert(db_ == nullptr);</a>
<a name="ln1975">    BlockBasedTableOptions block_based_options;</a>
<a name="ln1976">    block_based_options.block_cache = cache_;</a>
<a name="ln1977">    block_based_options.block_cache_compressed = compressed_cache_;</a>
<a name="ln1978">    block_based_options.block_size = FLAGS_block_size;</a>
<a name="ln1979">    block_based_options.format_version = 2;</a>
<a name="ln1980">    block_based_options.filter_policy = filter_policy_;</a>
<a name="ln1981">    options_.table_factory.reset(</a>
<a name="ln1982">        NewBlockBasedTableFactory(block_based_options));</a>
<a name="ln1983">    options_.db_write_buffer_size = FLAGS_db_write_buffer_size;</a>
<a name="ln1984">    options_.write_buffer_size = FLAGS_write_buffer_size;</a>
<a name="ln1985">    options_.max_write_buffer_number = FLAGS_max_write_buffer_number;</a>
<a name="ln1986">    options_.min_write_buffer_number_to_merge =</a>
<a name="ln1987">        FLAGS_min_write_buffer_number_to_merge;</a>
<a name="ln1988">    options_.max_write_buffer_number_to_maintain =</a>
<a name="ln1989">        FLAGS_max_write_buffer_number_to_maintain;</a>
<a name="ln1990">    options_.max_background_compactions = FLAGS_max_background_compactions;</a>
<a name="ln1991">    options_.max_background_flushes = FLAGS_max_background_flushes;</a>
<a name="ln1992">    options_.compaction_style =</a>
<a name="ln1993">        static_cast&lt;rocksdb::CompactionStyle&gt;(FLAGS_compaction_style);</a>
<a name="ln1994">    options_.prefix_extractor.reset(NewFixedPrefixTransform(FLAGS_prefix_size));</a>
<a name="ln1995">    options_.max_open_files = FLAGS_open_files;</a>
<a name="ln1996">    options_.statistics = dbstats;</a>
<a name="ln1997">    options_.env = FLAGS_env;</a>
<a name="ln1998">    options_.disableDataSync = FLAGS_disable_data_sync;</a>
<a name="ln1999">    options_.use_fsync = FLAGS_use_fsync;</a>
<a name="ln2000">    options_.allow_mmap_reads = FLAGS_mmap_read;</a>
<a name="ln2001">    options_.target_file_size_base = FLAGS_target_file_size_base;</a>
<a name="ln2002">    options_.target_file_size_multiplier = FLAGS_target_file_size_multiplier;</a>
<a name="ln2003">    options_.max_bytes_for_level_base = FLAGS_max_bytes_for_level_base;</a>
<a name="ln2004">    options_.max_bytes_for_level_multiplier =</a>
<a name="ln2005">        FLAGS_max_bytes_for_level_multiplier;</a>
<a name="ln2006">    options_.level0_stop_writes_trigger = FLAGS_level0_stop_writes_trigger;</a>
<a name="ln2007">    options_.level0_slowdown_writes_trigger =</a>
<a name="ln2008">        FLAGS_level0_slowdown_writes_trigger;</a>
<a name="ln2009">    options_.level0_file_num_compaction_trigger =</a>
<a name="ln2010">        FLAGS_level0_file_num_compaction_trigger;</a>
<a name="ln2011">    options_.compression = FLAGS_compression_type_e;</a>
<a name="ln2012">    options_.create_if_missing = true;</a>
<a name="ln2013">    options_.max_manifest_file_size = 10 * 1024;</a>
<a name="ln2014">    options_.filter_deletes = FLAGS_filter_deletes;</a>
<a name="ln2015">    options_.inplace_update_support = FLAGS_in_place_update;</a>
<a name="ln2016">    options_.max_subcompactions = static_cast&lt;uint32_t&gt;(FLAGS_subcompactions);</a>
<a name="ln2017">    options_.allow_concurrent_memtable_write =</a>
<a name="ln2018">        FLAGS_allow_concurrent_memtable_write;</a>
<a name="ln2019">    options_.enable_write_thread_adaptive_yield =</a>
<a name="ln2020">        FLAGS_enable_write_thread_adaptive_yield;</a>
<a name="ln2021"> </a>
<a name="ln2022">    if (FLAGS_prefix_size == 0 &amp;&amp; FLAGS_rep_factory == kHashSkipList) {</a>
<a name="ln2023">      fprintf(stderr,</a>
<a name="ln2024">              &quot;prefeix_size cannot be zero if memtablerep == prefix_hash\n&quot;);</a>
<a name="ln2025">      exit(1);</a>
<a name="ln2026">    }</a>
<a name="ln2027">    if (FLAGS_prefix_size != 0 &amp;&amp; FLAGS_rep_factory != kHashSkipList) {</a>
<a name="ln2028">      fprintf(stderr,</a>
<a name="ln2029">              &quot;WARNING: prefix_size is non-zero but &quot;</a>
<a name="ln2030">              &quot;memtablerep != prefix_hash\n&quot;);</a>
<a name="ln2031">    }</a>
<a name="ln2032">    switch (FLAGS_rep_factory) {</a>
<a name="ln2033">      case kSkipList:</a>
<a name="ln2034">        // no need to do anything</a>
<a name="ln2035">        break;</a>
<a name="ln2036">#ifndef ROCKSDB_LITE</a>
<a name="ln2037">      case kHashSkipList:</a>
<a name="ln2038">        options_.memtable_factory.reset(NewHashSkipListRepFactory(10000));</a>
<a name="ln2039">        break;</a>
<a name="ln2040">      case kVectorRep:</a>
<a name="ln2041">        options_.memtable_factory.reset(new VectorRepFactory());</a>
<a name="ln2042">        break;</a>
<a name="ln2043">#else</a>
<a name="ln2044">      default:</a>
<a name="ln2045">        fprintf(stderr,</a>
<a name="ln2046">                &quot;RocksdbLite only supports skip list mem table. Skip &quot;</a>
<a name="ln2047">                &quot;--rep_factory\n&quot;);</a>
<a name="ln2048">#endif  // ROCKSDB_LITE</a>
<a name="ln2049">    }</a>
<a name="ln2050"> </a>
<a name="ln2051">    if (FLAGS_use_merge) {</a>
<a name="ln2052">      options_.merge_operator = MergeOperators::CreatePutOperator();</a>
<a name="ln2053">    }</a>
<a name="ln2054"> </a>
<a name="ln2055">    // set universal style compaction configurations, if applicable</a>
<a name="ln2056">    if (FLAGS_universal_size_ratio != 0) {</a>
<a name="ln2057">      options_.compaction_options_universal.size_ratio =</a>
<a name="ln2058">          FLAGS_universal_size_ratio;</a>
<a name="ln2059">    }</a>
<a name="ln2060">    if (FLAGS_universal_min_merge_width != 0) {</a>
<a name="ln2061">      options_.compaction_options_universal.min_merge_width =</a>
<a name="ln2062">          FLAGS_universal_min_merge_width;</a>
<a name="ln2063">    }</a>
<a name="ln2064">    if (FLAGS_universal_max_merge_width != 0) {</a>
<a name="ln2065">      options_.compaction_options_universal.max_merge_width =</a>
<a name="ln2066">          FLAGS_universal_max_merge_width;</a>
<a name="ln2067">    }</a>
<a name="ln2068">    if (FLAGS_universal_max_size_amplification_percent != 0) {</a>
<a name="ln2069">      options_.compaction_options_universal.max_size_amplification_percent =</a>
<a name="ln2070">          FLAGS_universal_max_size_amplification_percent;</a>
<a name="ln2071">    }</a>
<a name="ln2072"> </a>
<a name="ln2073">    fprintf(stdout, &quot;DB path: [%s]\n&quot;, FLAGS_db.c_str());</a>
<a name="ln2074"> </a>
<a name="ln2075">    Status s;</a>
<a name="ln2076">    if (FLAGS_ttl == -1) {</a>
<a name="ln2077">      std::vector&lt;std::string&gt; existing_column_families;</a>
<a name="ln2078">      s = DB::ListColumnFamilies(DBOptions(options_), FLAGS_db,</a>
<a name="ln2079">                                 &amp;existing_column_families);  // ignore errors</a>
<a name="ln2080">      if (!s.ok()) {</a>
<a name="ln2081">        // DB doesn't exist</a>
<a name="ln2082">        assert(existing_column_families.empty());</a>
<a name="ln2083">        assert(column_family_names_.empty());</a>
<a name="ln2084">        column_family_names_.push_back(kDefaultColumnFamilyName);</a>
<a name="ln2085">      } else if (column_family_names_.empty()) {</a>
<a name="ln2086">        // this is the first call to the function Open()</a>
<a name="ln2087">        column_family_names_ = existing_column_families;</a>
<a name="ln2088">      } else {</a>
<a name="ln2089">        // this is a reopen. just assert that existing column_family_names are</a>
<a name="ln2090">        // equivalent to what we remember</a>
<a name="ln2091">        auto sorted_cfn = column_family_names_;</a>
<a name="ln2092">        sort(sorted_cfn.begin(), sorted_cfn.end());</a>
<a name="ln2093">        sort(existing_column_families.begin(), existing_column_families.end());</a>
<a name="ln2094">        if (sorted_cfn != existing_column_families) {</a>
<a name="ln2095">          fprintf(stderr,</a>
<a name="ln2096">                  &quot;Expected column families differ from the existing:\n&quot;);</a>
<a name="ln2097">          printf(&quot;Expected: {&quot;);</a>
<a name="ln2098">          for (auto cf : sorted_cfn) {</a>
<a name="ln2099">            printf(&quot;%s &quot;, cf.c_str());</a>
<a name="ln2100">          }</a>
<a name="ln2101">          printf(&quot;}\n&quot;);</a>
<a name="ln2102">          printf(&quot;Existing: {&quot;);</a>
<a name="ln2103">          for (auto cf : existing_column_families) {</a>
<a name="ln2104">            printf(&quot;%s &quot;, cf.c_str());</a>
<a name="ln2105">          }</a>
<a name="ln2106">          printf(&quot;}\n&quot;);</a>
<a name="ln2107">        }</a>
<a name="ln2108">        assert(sorted_cfn == existing_column_families);</a>
<a name="ln2109">      }</a>
<a name="ln2110">      std::vector&lt;ColumnFamilyDescriptor&gt; cf_descriptors;</a>
<a name="ln2111">      for (auto name : column_family_names_) {</a>
<a name="ln2112">        if (name != kDefaultColumnFamilyName) {</a>
<a name="ln2113">          new_column_family_name_ =</a>
<a name="ln2114">              std::max(new_column_family_name_.load(), std::stoi(name) + 1);</a>
<a name="ln2115">        }</a>
<a name="ln2116">        cf_descriptors.emplace_back(name, ColumnFamilyOptions(options_));</a>
<a name="ln2117">      }</a>
<a name="ln2118">      while (cf_descriptors.size() &lt; (size_t)FLAGS_column_families) {</a>
<a name="ln2119">        std::string name = ToString(new_column_family_name_.load());</a>
<a name="ln2120">        new_column_family_name_++;</a>
<a name="ln2121">        cf_descriptors.emplace_back(name, ColumnFamilyOptions(options_));</a>
<a name="ln2122">        column_family_names_.push_back(name);</a>
<a name="ln2123">      }</a>
<a name="ln2124">      options_.listeners.clear();</a>
<a name="ln2125">      options_.listeners.emplace_back(</a>
<a name="ln2126">          new DbStressListener(FLAGS_db, options_.db_paths));</a>
<a name="ln2127">      options_.create_missing_column_families = true;</a>
<a name="ln2128">      s = DB::Open(DBOptions(options_), FLAGS_db, cf_descriptors,</a>
<a name="ln2129">                   &amp;column_families_, &amp;db_);</a>
<a name="ln2130">      assert(!s.ok() || column_families_.size() ==</a>
<a name="ln2131">                            static_cast&lt;size_t&gt;(FLAGS_column_families));</a>
<a name="ln2132">    } else {</a>
<a name="ln2133">#ifndef ROCKSDB_LITE</a>
<a name="ln2134">      DBWithTTL* db_with_ttl;</a>
<a name="ln2135">      s = DBWithTTL::Open(options_, FLAGS_db, &amp;db_with_ttl, FLAGS_ttl);</a>
<a name="ln2136">      db_ = db_with_ttl;</a>
<a name="ln2137">#else</a>
<a name="ln2138">      fprintf(stderr, &quot;TTL is not supported in RocksDBLite\n&quot;);</a>
<a name="ln2139">      exit(1);</a>
<a name="ln2140">#endif</a>
<a name="ln2141">    }</a>
<a name="ln2142">    if (!s.ok()) {</a>
<a name="ln2143">      fprintf(stderr, &quot;open error: %s\n&quot;, s.ToString().c_str());</a>
<a name="ln2144">      exit(1);</a>
<a name="ln2145">    }</a>
<a name="ln2146">  }</a>
<a name="ln2147"> </a>
<a name="ln2148">  void Reopen() {</a>
<a name="ln2149">    for (auto cf : column_families_) {</a>
<a name="ln2150">      delete cf;</a>
<a name="ln2151">    }</a>
<a name="ln2152">    column_families_.clear();</a>
<a name="ln2153">    delete db_;</a>
<a name="ln2154">    db_ = nullptr;</a>
<a name="ln2155"> </a>
<a name="ln2156">    num_times_reopened_++;</a>
<a name="ln2157">    auto now = FLAGS_env-&gt;NowMicros();</a>
<a name="ln2158">    fprintf(stdout, &quot;%s Reopening database for the %dth time\n&quot;,</a>
<a name="ln2159">            FLAGS_env-&gt;TimeToString(now/1000000).c_str(),</a>
<a name="ln2160">            num_times_reopened_);</a>
<a name="ln2161">    Open();</a>
<a name="ln2162">  }</a>
<a name="ln2163"> </a>
<a name="ln2164">  void PrintStatistics() {</a>
<a name="ln2165">    if (dbstats) {</a>
<a name="ln2166">      fprintf(stdout, &quot;STATISTICS:\n%s\n&quot;, dbstats-&gt;ToString().c_str());</a>
<a name="ln2167">    }</a>
<a name="ln2168">  }</a>
<a name="ln2169"> </a>
<a name="ln2170"> private:</a>
<a name="ln2171">  std::shared_ptr&lt;Cache&gt; cache_;</a>
<a name="ln2172">  std::shared_ptr&lt;Cache&gt; compressed_cache_;</a>
<a name="ln2173">  std::shared_ptr&lt;const FilterPolicy&gt; filter_policy_;</a>
<a name="ln2174">  DB* db_;</a>
<a name="ln2175">  Options options_;</a>
<a name="ln2176">  std::vector&lt;ColumnFamilyHandle*&gt; column_families_;</a>
<a name="ln2177">  std::vector&lt;std::string&gt; column_family_names_;</a>
<a name="ln2178">  std::atomic&lt;int&gt; new_column_family_name_;</a>
<a name="ln2179">  int num_times_reopened_;</a>
<a name="ln2180">  std::unordered_map&lt;std::string, std::vector&lt;std::string&gt;&gt; options_table_;</a>
<a name="ln2181">  std::vector&lt;std::string&gt; options_index_;</a>
<a name="ln2182">};</a>
<a name="ln2183"> </a>
<a name="ln2184">}  // namespace rocksdb</a>
<a name="ln2185"> </a>
<a name="ln2186">int main(int argc, char** argv) {</a>
<a name="ln2187">  SetUsageMessage(std::string(&quot;\nUSAGE:\n&quot;) + std::string(argv[0]) +</a>
<a name="ln2188">                  &quot; [OPTIONS]...&quot;);</a>
<a name="ln2189">  ParseCommandLineFlags(&amp;argc, &amp;argv, true);</a>
<a name="ln2190"> </a>
<a name="ln2191">  if (FLAGS_statistics) {</a>
<a name="ln2192">    dbstats = rocksdb::CreateDBStatistics();</a>
<a name="ln2193">  }</a>
<a name="ln2194">  FLAGS_compression_type_e =</a>
<a name="ln2195">    StringToCompressionType(FLAGS_compression_type.c_str());</a>
<a name="ln2196">  if (!FLAGS_hdfs.empty()) {</a>
<a name="ln2197">    FLAGS_env  = new rocksdb::HdfsEnv(FLAGS_hdfs);</a>
<a name="ln2198">  }</a>
<a name="ln2199">  FLAGS_rep_factory = StringToRepFactory(FLAGS_memtablerep.c_str());</a>
<a name="ln2200"> </a>
<a name="ln2201">  // The number of background threads should be at least as much the</a>
<a name="ln2202">  // max number of concurrent compactions.</a>
<a name="ln2203">  FLAGS_env-&gt;SetBackgroundThreads(FLAGS_max_background_compactions);</a>
<a name="ln2204"> </a>
<a name="ln2205">  if (FLAGS_prefixpercent &gt; 0 &amp;&amp; FLAGS_prefix_size &lt;= 0) {</a>
<a name="ln2206">    fprintf(stderr,</a>
<a name="ln2207">            &quot;Error: prefixpercent is non-zero while prefix_size is &quot;</a>
<a name="ln2208">            &quot;not positive!\n&quot;);</a>
<a name="ln2209">    exit(1);</a>
<a name="ln2210">  }</a>
<a name="ln2211">  if (FLAGS_test_batches_snapshots &amp;&amp; FLAGS_prefix_size &lt;= 0) {</a>
<a name="ln2212">    fprintf(stderr,</a>
<a name="ln2213">            &quot;Error: please specify prefix_size for &quot;</a>
<a name="ln2214">            &quot;test_batches_snapshots test!\n&quot;);</a>
<a name="ln2215">    exit(1);</a>
<a name="ln2216">  }</a>
<a name="ln2217">  if ((FLAGS_readpercent + FLAGS_prefixpercent +</a>
<a name="ln2218">       FLAGS_writepercent + FLAGS_delpercent + FLAGS_iterpercent) != 100) {</a>
<a name="ln2219">      fprintf(stderr,</a>
<a name="ln2220">              &quot;Error: Read+Prefix+Write+Delete+Iterate percents != 100!\n&quot;);</a>
<a name="ln2221">      exit(1);</a>
<a name="ln2222">  }</a>
<a name="ln2223">  if (FLAGS_disable_wal == 1 &amp;&amp; FLAGS_reopen &gt; 0) {</a>
<a name="ln2224">      fprintf(stderr, &quot;Error: Db cannot reopen safely with disable_wal set!\n&quot;);</a>
<a name="ln2225">      exit(1);</a>
<a name="ln2226">  }</a>
<a name="ln2227">  if ((unsigned)FLAGS_reopen &gt;= FLAGS_ops_per_thread) {</a>
<a name="ln2228">      fprintf(stderr,</a>
<a name="ln2229">              &quot;Error: #DB-reopens should be &lt; ops_per_thread\n&quot;</a>
<a name="ln2230">              &quot;Provided reopens = %d and ops_per_thread = %&quot; PRIu64 &quot;\n&quot;,</a>
<a name="ln2231">              FLAGS_reopen,</a>
<a name="ln2232">              FLAGS_ops_per_thread);</a>
<a name="ln2233">      exit(1);</a>
<a name="ln2234">  }</a>
<a name="ln2235"> </a>
<a name="ln2236">  // Choose a location for the test database if none given with --db=&lt;path&gt;</a>
<a name="ln2237">  if (FLAGS_db.empty()) {</a>
<a name="ln2238">      std::string default_db_path;</a>
<a name="ln2239">      rocksdb::Env::Default()-&gt;GetTestDirectory(&amp;default_db_path);</a>
<a name="ln2240">      default_db_path += &quot;/dbstress&quot;;</a>
<a name="ln2241">      FLAGS_db = default_db_path;</a>
<a name="ln2242">  }</a>
<a name="ln2243"> </a>
<a name="ln2244">  rocksdb_kill_odds = FLAGS_kill_random_test;</a>
<a name="ln2245">  rocksdb_kill_prefix_blacklist = SplitString(FLAGS_kill_prefix_blacklist);</a>
<a name="ln2246"> </a>
<a name="ln2247">  rocksdb::StressTest stress;</a>
<a name="ln2248">  if (stress.Run()) {</a>
<a name="ln2249">    return 0;</a>
<a name="ln2250">  } else {</a>
<a name="ln2251">    return 1;</a>
<a name="ln2252">  }</a>
<a name="ln2253">}</a>
<a name="ln2254"> </a>
<a name="ln2255">#endif  // GFLAGS</a>

</code></pre>
<div class="balloon" rel="84"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v707/" target="_blank">V707</a> Giving short names to global variables is considered to be bad practice. It is suggested to rename 'KB' variable.</p></div>
<div class="balloon" rel="1626"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: prob_op >= 0.</p></div>
<div class="balloon" rel="1979"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'block_based_options.format_version' variable was assigned the same value.</p></div>
<div class="balloon" rel="2125"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1023/" target="_blank">V1023</a> A pointer without owner is added to the 'options_.listeners' container by the 'emplace_back' method. A memory leak will occur in case of an exception.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
