
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>types.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Licensed to the Apache Software Foundation (ASF) under one</a>
<a name="ln2">// or more contributor license agreements.  See the NOTICE file</a>
<a name="ln3">// distributed with this work for additional information</a>
<a name="ln4">// regarding copyright ownership.  The ASF licenses this file</a>
<a name="ln5">// to you under the Apache License, Version 2.0 (the</a>
<a name="ln6">// &quot;License&quot;); you may not use this file except in compliance</a>
<a name="ln7">// with the License.  You may obtain a copy of the License at</a>
<a name="ln8">//</a>
<a name="ln9">//   http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln10">//</a>
<a name="ln11">// Unless required by applicable law or agreed to in writing,</a>
<a name="ln12">// software distributed under the License is distributed on an</a>
<a name="ln13">// &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</a>
<a name="ln14">// KIND, either express or implied.  See the License for the</a>
<a name="ln15">// specific language governing permissions and limitations</a>
<a name="ln16">// under the License.</a>
<a name="ln17">//</a>
<a name="ln18">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln19">//</a>
<a name="ln20">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln21">//</a>
<a name="ln22">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln23">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln24">//</a>
<a name="ln25">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln26">//</a>
<a name="ln27">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln28">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln29">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln30">// under the License.</a>
<a name="ln31">//</a>
<a name="ln32"> </a>
<a name="ln33">#ifndef YB_COMMON_TYPES_H</a>
<a name="ln34">#define YB_COMMON_TYPES_H</a>
<a name="ln35"> </a>
<a name="ln36">#include &lt;stdint.h&gt;</a>
<a name="ln37">#include &lt;string&gt;</a>
<a name="ln38"> </a>
<a name="ln39">#include &lt;glog/logging.h&gt;</a>
<a name="ln40"> </a>
<a name="ln41">#include &quot;yb/common/common.pb.h&quot;</a>
<a name="ln42">#include &quot;yb/gutil/mathlimits.h&quot;</a>
<a name="ln43">#include &quot;yb/gutil/strings/escaping.h&quot;</a>
<a name="ln44">#include &quot;yb/gutil/strings/numbers.h&quot;</a>
<a name="ln45">#include &quot;yb/util/net/inetaddress.h&quot;</a>
<a name="ln46">#include &quot;yb/util/uuid.h&quot;</a>
<a name="ln47">#include &quot;yb/util/debug-util.h&quot;</a>
<a name="ln48">#include &quot;yb/util/slice.h&quot;</a>
<a name="ln49"> </a>
<a name="ln50">namespace yb {</a>
<a name="ln51"> </a>
<a name="ln52">// The size of the in-memory format of the largest</a>
<a name="ln53">// type we support.</a>
<a name="ln54">const int kLargestTypeSize = sizeof(Slice);</a>
<a name="ln55"> </a>
<a name="ln56">class TypeInfo;</a>
<a name="ln57"> </a>
<a name="ln58">// This is the important bit of this header:</a>
<a name="ln59">// given a type enum, get the TypeInfo about it.</a>
<a name="ln60">extern const TypeInfo* GetTypeInfo(DataType type);</a>
<a name="ln61"> </a>
<a name="ln62">// Information about a given type.</a>
<a name="ln63">// This is a runtime equivalent of the TypeTraits template below.</a>
<a name="ln64">class TypeInfo {</a>
<a name="ln65"> public:</a>
<a name="ln66">  // Returns the type mentioned in the schema.</a>
<a name="ln67">  DataType type() const { return type_; }</a>
<a name="ln68">  // Returns the type used to actually store the data.</a>
<a name="ln69">  DataType physical_type() const { return physical_type_; }</a>
<a name="ln70">  const std::string&amp; name() const { return name_; }</a>
<a name="ln71">  const size_t size() const { return size_; }</a>
<a name="ln72">  void AppendDebugStringForValue(const void *ptr, std::string *str) const;</a>
<a name="ln73">  int Compare(const void *lhs, const void *rhs) const;</a>
<a name="ln74">  void CopyMinValue(void* dst) const {</a>
<a name="ln75">    memcpy(dst, min_value_, size_);</a>
<a name="ln76">  }</a>
<a name="ln77"> </a>
<a name="ln78"> private:</a>
<a name="ln79">  friend class TypeInfoResolver;</a>
<a name="ln80">  template&lt;typename Type&gt; TypeInfo(Type t);</a>
<a name="ln81"> </a>
<a name="ln82">  const DataType type_;</a>
<a name="ln83">  const DataType physical_type_;</a>
<a name="ln84">  const std::string name_;</a>
<a name="ln85">  const size_t size_;</a>
<a name="ln86">  const void* const min_value_;</a>
<a name="ln87"> </a>
<a name="ln88">  typedef void (*AppendDebugFunc)(const void *, std::string *);</a>
<a name="ln89">  const AppendDebugFunc append_func_;</a>
<a name="ln90"> </a>
<a name="ln91">  typedef int (*CompareFunc)(const void *, const void *);</a>
<a name="ln92">  const CompareFunc compare_func_;</a>
<a name="ln93">};</a>
<a name="ln94"> </a>
<a name="ln95">template&lt;DataType Type&gt; struct DataTypeTraits {};</a>
<a name="ln96"> </a>
<a name="ln97">template&lt;DataType Type&gt;</a>
<a name="ln98">static int GenericCompare(const void *lhs, const void *rhs) {</a>
<a name="ln99">  typedef typename DataTypeTraits&lt;Type&gt;::cpp_type CppType;</a>
<a name="ln100">  CppType lhs_int = *reinterpret_cast&lt;const CppType *&gt;(lhs);</a>
<a name="ln101">  CppType rhs_int = *reinterpret_cast&lt;const CppType *&gt;(rhs);</a>
<a name="ln102">  if (lhs_int &lt; rhs_int) {</a>
<a name="ln103">    return -1;</a>
<a name="ln104">  } else if (lhs_int &gt; rhs_int) {</a>
<a name="ln105">    return 1;</a>
<a name="ln106">  } else {</a>
<a name="ln107">    return 0;</a>
<a name="ln108">  }</a>
<a name="ln109">}</a>
<a name="ln110"> </a>
<a name="ln111">template&lt;&gt;</a>
<a name="ln112">struct DataTypeTraits&lt;UINT8&gt; {</a>
<a name="ln113">  static const DataType physical_type = UINT8;</a>
<a name="ln114">  typedef uint8_t cpp_type;</a>
<a name="ln115">  static const char *name() {</a>
<a name="ln116">    return &quot;uint8&quot;;</a>
<a name="ln117">  }</a>
<a name="ln118">  static void AppendDebugStringForValue(const void *val, std::string *str) {</a>
<a name="ln119">    str-&gt;append(SimpleItoa(*reinterpret_cast&lt;const uint8_t *&gt;(val)));</a>
<a name="ln120">  }</a>
<a name="ln121">  static int Compare(const void *lhs, const void *rhs) {</a>
<a name="ln122">    return GenericCompare&lt;UINT8&gt;(lhs, rhs);</a>
<a name="ln123">  }</a>
<a name="ln124">  static const cpp_type* min_value() {</a>
<a name="ln125">    return &amp;MathLimits&lt;cpp_type&gt;::kMin;</a>
<a name="ln126">  }</a>
<a name="ln127">};</a>
<a name="ln128"> </a>
<a name="ln129">template&lt;&gt;</a>
<a name="ln130">struct DataTypeTraits&lt;INT8&gt; {</a>
<a name="ln131">  static const DataType physical_type = INT8;</a>
<a name="ln132">  typedef int8_t cpp_type;</a>
<a name="ln133">  static const char *name() {</a>
<a name="ln134">    return &quot;int8&quot;;</a>
<a name="ln135">  }</a>
<a name="ln136">  static void AppendDebugStringForValue(const void *val, std::string *str) {</a>
<a name="ln137">    str-&gt;append(SimpleItoa(*reinterpret_cast&lt;const int8_t *&gt;(val)));</a>
<a name="ln138">  }</a>
<a name="ln139">  static int Compare(const void *lhs, const void *rhs) {</a>
<a name="ln140">    return GenericCompare&lt;INT8&gt;(lhs, rhs);</a>
<a name="ln141">  }</a>
<a name="ln142">  static const cpp_type* min_value() {</a>
<a name="ln143">    return &amp;MathLimits&lt;cpp_type&gt;::kMin;</a>
<a name="ln144">  }</a>
<a name="ln145">};</a>
<a name="ln146"> </a>
<a name="ln147">template&lt;&gt;</a>
<a name="ln148">struct DataTypeTraits&lt;UINT16&gt; {</a>
<a name="ln149">  static const DataType physical_type = UINT16;</a>
<a name="ln150">  typedef uint16_t cpp_type;</a>
<a name="ln151">  static const char *name() {</a>
<a name="ln152">    return &quot;uint16&quot;;</a>
<a name="ln153">  }</a>
<a name="ln154">  static void AppendDebugStringForValue(const void *val, std::string *str) {</a>
<a name="ln155">    str-&gt;append(SimpleItoa(*reinterpret_cast&lt;const uint16_t *&gt;(val)));</a>
<a name="ln156">  }</a>
<a name="ln157">  static int Compare(const void *lhs, const void *rhs) {</a>
<a name="ln158">    return GenericCompare&lt;UINT16&gt;(lhs, rhs);</a>
<a name="ln159">  }</a>
<a name="ln160">  static const cpp_type* min_value() {</a>
<a name="ln161">    return &amp;MathLimits&lt;cpp_type&gt;::kMin;</a>
<a name="ln162">  }</a>
<a name="ln163">};</a>
<a name="ln164"> </a>
<a name="ln165">template&lt;&gt;</a>
<a name="ln166">struct DataTypeTraits&lt;INT16&gt; {</a>
<a name="ln167">  static const DataType physical_type = INT16;</a>
<a name="ln168">  typedef int16_t cpp_type;</a>
<a name="ln169">  static const char *name() {</a>
<a name="ln170">    return &quot;int16&quot;;</a>
<a name="ln171">  }</a>
<a name="ln172">  static void AppendDebugStringForValue(const void *val, std::string *str) {</a>
<a name="ln173">    str-&gt;append(SimpleItoa(*reinterpret_cast&lt;const int16_t *&gt;(val)));</a>
<a name="ln174">  }</a>
<a name="ln175">  static int Compare(const void *lhs, const void *rhs) {</a>
<a name="ln176">    return GenericCompare&lt;INT16&gt;(lhs, rhs);</a>
<a name="ln177">  }</a>
<a name="ln178">  static const cpp_type* min_value() {</a>
<a name="ln179">    return &amp;MathLimits&lt;cpp_type&gt;::kMin;</a>
<a name="ln180">  }</a>
<a name="ln181">};</a>
<a name="ln182"> </a>
<a name="ln183">template&lt;&gt;</a>
<a name="ln184">struct DataTypeTraits&lt;UINT32&gt; {</a>
<a name="ln185">  static const DataType physical_type = UINT32;</a>
<a name="ln186">  typedef uint32_t cpp_type;</a>
<a name="ln187">  static const char *name() {</a>
<a name="ln188">    return &quot;uint32&quot;;</a>
<a name="ln189">  }</a>
<a name="ln190">  static void AppendDebugStringForValue(const void *val, std::string *str) {</a>
<a name="ln191">    str-&gt;append(SimpleItoa(*reinterpret_cast&lt;const uint32_t *&gt;(val)));</a>
<a name="ln192">  }</a>
<a name="ln193">  static int Compare(const void *lhs, const void *rhs) {</a>
<a name="ln194">    return GenericCompare&lt;UINT32&gt;(lhs, rhs);</a>
<a name="ln195">  }</a>
<a name="ln196">  static const cpp_type* min_value() {</a>
<a name="ln197">    return &amp;MathLimits&lt;cpp_type&gt;::kMin;</a>
<a name="ln198">  }</a>
<a name="ln199">};</a>
<a name="ln200"> </a>
<a name="ln201">template&lt;&gt;</a>
<a name="ln202">struct DataTypeTraits&lt;INT32&gt; {</a>
<a name="ln203">  static const DataType physical_type = INT32;</a>
<a name="ln204">  typedef int32_t cpp_type;</a>
<a name="ln205">  static const char *name() {</a>
<a name="ln206">    return &quot;int32&quot;;</a>
<a name="ln207">  }</a>
<a name="ln208">  static void AppendDebugStringForValue(const void *val, std::string *str) {</a>
<a name="ln209">    str-&gt;append(SimpleItoa(*reinterpret_cast&lt;const int32_t *&gt;(val)));</a>
<a name="ln210">  }</a>
<a name="ln211">  static int Compare(const void *lhs, const void *rhs) {</a>
<a name="ln212">    return GenericCompare&lt;INT32&gt;(lhs, rhs);</a>
<a name="ln213">  }</a>
<a name="ln214">  static const cpp_type* min_value() {</a>
<a name="ln215">    return &amp;MathLimits&lt;cpp_type&gt;::kMin;</a>
<a name="ln216">  }</a>
<a name="ln217">};</a>
<a name="ln218"> </a>
<a name="ln219">template&lt;&gt;</a>
<a name="ln220">struct DataTypeTraits&lt;UINT64&gt; {</a>
<a name="ln221">  static const DataType physical_type = UINT64;</a>
<a name="ln222">  typedef uint64_t cpp_type;</a>
<a name="ln223">  static const char *name() {</a>
<a name="ln224">    return &quot;uint64&quot;;</a>
<a name="ln225">  }</a>
<a name="ln226">  static void AppendDebugStringForValue(const void *val, std::string *str) {</a>
<a name="ln227">    str-&gt;append(SimpleItoa(*reinterpret_cast&lt;const uint64_t *&gt;(val)));</a>
<a name="ln228">  }</a>
<a name="ln229">  static int Compare(const void *lhs, const void *rhs) {</a>
<a name="ln230">    return GenericCompare&lt;UINT64&gt;(lhs, rhs);</a>
<a name="ln231">  }</a>
<a name="ln232">  static const cpp_type* min_value() {</a>
<a name="ln233">    return &amp;MathLimits&lt;cpp_type&gt;::kMin;</a>
<a name="ln234">  }</a>
<a name="ln235">};</a>
<a name="ln236"> </a>
<a name="ln237">template&lt;&gt;</a>
<a name="ln238">struct DataTypeTraits&lt;INT64&gt; {</a>
<a name="ln239">  static const DataType physical_type = INT64;</a>
<a name="ln240">  typedef int64_t cpp_type;</a>
<a name="ln241">  static const char *name() {</a>
<a name="ln242">    return &quot;int64&quot;;</a>
<a name="ln243">  }</a>
<a name="ln244">  static void AppendDebugStringForValue(const void *val, std::string *str) {</a>
<a name="ln245">    str-&gt;append(SimpleItoa(*reinterpret_cast&lt;const int64_t *&gt;(val)));</a>
<a name="ln246">  }</a>
<a name="ln247">  static int Compare(const void *lhs, const void *rhs) {</a>
<a name="ln248">    return GenericCompare&lt;INT64&gt;(lhs, rhs);</a>
<a name="ln249">  }</a>
<a name="ln250">  static const cpp_type* min_value() {</a>
<a name="ln251">    return &amp;MathLimits&lt;cpp_type&gt;::kMin;</a>
<a name="ln252">  }</a>
<a name="ln253">};</a>
<a name="ln254"> </a>
<a name="ln255">template&lt;&gt;</a>
<a name="ln256">struct DataTypeTraits&lt;FLOAT&gt; {</a>
<a name="ln257">  static const DataType physical_type = FLOAT;</a>
<a name="ln258">  typedef float cpp_type;</a>
<a name="ln259">  static const char *name() {</a>
<a name="ln260">    return &quot;float&quot;;</a>
<a name="ln261">  }</a>
<a name="ln262">  static void AppendDebugStringForValue(const void *val, std::string *str) {</a>
<a name="ln263">    str-&gt;append(SimpleFtoa(*reinterpret_cast&lt;const float *&gt;(val)));</a>
<a name="ln264">  }</a>
<a name="ln265">  static int Compare(const void *lhs, const void *rhs) {</a>
<a name="ln266">    return GenericCompare&lt;FLOAT&gt;(lhs, rhs);</a>
<a name="ln267">  }</a>
<a name="ln268">  static const cpp_type* min_value() {</a>
<a name="ln269">    return &amp;MathLimits&lt;cpp_type&gt;::kMin;</a>
<a name="ln270">  }</a>
<a name="ln271">};</a>
<a name="ln272"> </a>
<a name="ln273">template&lt;&gt;</a>
<a name="ln274">struct DataTypeTraits&lt;DOUBLE&gt; {</a>
<a name="ln275">  static const DataType physical_type = DOUBLE;</a>
<a name="ln276">  typedef double cpp_type;</a>
<a name="ln277">  static const char *name() {</a>
<a name="ln278">    return &quot;double&quot;;</a>
<a name="ln279">  }</a>
<a name="ln280">  static void AppendDebugStringForValue(const void *val, std::string *str) {</a>
<a name="ln281">    str-&gt;append(SimpleDtoa(*reinterpret_cast&lt;const double *&gt;(val)));</a>
<a name="ln282">  }</a>
<a name="ln283">  static int Compare(const void *lhs, const void *rhs) {</a>
<a name="ln284">    return GenericCompare&lt;DOUBLE&gt;(lhs, rhs);</a>
<a name="ln285">  }</a>
<a name="ln286">  static const cpp_type* min_value() {</a>
<a name="ln287">    return &amp;MathLimits&lt;cpp_type&gt;::kMin;</a>
<a name="ln288">  }</a>
<a name="ln289">};</a>
<a name="ln290"> </a>
<a name="ln291">template&lt;&gt;</a>
<a name="ln292">struct DataTypeTraits&lt;BINARY&gt; {</a>
<a name="ln293">  static const DataType physical_type = BINARY;</a>
<a name="ln294">  typedef Slice cpp_type;</a>
<a name="ln295">  static const char *name() {</a>
<a name="ln296">    return &quot;binary&quot;;</a>
<a name="ln297">  }</a>
<a name="ln298">  static void AppendDebugStringForValue(const void *val, std::string *str) {</a>
<a name="ln299">    const Slice *s = reinterpret_cast&lt;const Slice *&gt;(val);</a>
<a name="ln300">    str-&gt;append(strings::CHexEscape(s-&gt;ToString()));</a>
<a name="ln301">  }</a>
<a name="ln302"> </a>
<a name="ln303">  static int Compare(const void *lhs, const void *rhs) {</a>
<a name="ln304">    const Slice *lhs_slice = reinterpret_cast&lt;const Slice *&gt;(lhs);</a>
<a name="ln305">    const Slice *rhs_slice = reinterpret_cast&lt;const Slice *&gt;(rhs);</a>
<a name="ln306">    return lhs_slice-&gt;compare(*rhs_slice);</a>
<a name="ln307">  }</a>
<a name="ln308">  static const cpp_type* min_value() {</a>
<a name="ln309">    static Slice s(&quot;&quot;);</a>
<a name="ln310">    return &amp;s;</a>
<a name="ln311">  }</a>
<a name="ln312">};</a>
<a name="ln313"> </a>
<a name="ln314">template&lt;&gt;</a>
<a name="ln315">struct DataTypeTraits&lt;BOOL&gt; {</a>
<a name="ln316">  static const DataType physical_type = BOOL;</a>
<a name="ln317">  typedef bool cpp_type;</a>
<a name="ln318">  static const char* name() {</a>
<a name="ln319">    return &quot;bool&quot;;</a>
<a name="ln320">  }</a>
<a name="ln321">  static void AppendDebugStringForValue(const void* val, std::string* str) {</a>
<a name="ln322">    str-&gt;append(*reinterpret_cast&lt;const bool *&gt;(val) ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="ln323">  }</a>
<a name="ln324"> </a>
<a name="ln325">  static int Compare(const void *lhs, const void *rhs) {</a>
<a name="ln326">    return GenericCompare&lt;BOOL&gt;(lhs, rhs);</a>
<a name="ln327">  }</a>
<a name="ln328">  static const cpp_type* min_value() {</a>
<a name="ln329">    static bool b = false;</a>
<a name="ln330">    return &amp;b;</a>
<a name="ln331">  }</a>
<a name="ln332">};</a>
<a name="ln333"> </a>
<a name="ln334">// Base class for types that are derived, that is that have some other type as the</a>
<a name="ln335">// physical representation.</a>
<a name="ln336">template&lt;DataType PhysicalType&gt;</a>
<a name="ln337">struct DerivedTypeTraits {</a>
<a name="ln338">  typedef typename DataTypeTraits&lt;PhysicalType&gt;::cpp_type cpp_type;</a>
<a name="ln339">  static const DataType physical_type = PhysicalType;</a>
<a name="ln340"> </a>
<a name="ln341">  static void AppendDebugStringForValue(const void *val, std::string *str) {</a>
<a name="ln342">    DataTypeTraits&lt;PhysicalType&gt;::AppendDebugStringForValue(val, str);</a>
<a name="ln343">  }</a>
<a name="ln344"> </a>
<a name="ln345">  static int Compare(const void *lhs, const void *rhs) {</a>
<a name="ln346">    return DataTypeTraits&lt;PhysicalType&gt;::Compare(lhs, rhs);</a>
<a name="ln347">  }</a>
<a name="ln348"> </a>
<a name="ln349">  static const cpp_type* min_value() {</a>
<a name="ln350">    return DataTypeTraits&lt;PhysicalType&gt;::min_value();</a>
<a name="ln351">  }</a>
<a name="ln352">};</a>
<a name="ln353"> </a>
<a name="ln354">template&lt;&gt;</a>
<a name="ln355">struct DataTypeTraits&lt;STRING&gt; : public DerivedTypeTraits&lt;BINARY&gt;{</a>
<a name="ln356">  static const char* name() {</a>
<a name="ln357">    return &quot;string&quot;;</a>
<a name="ln358">  }</a>
<a name="ln359">  static void AppendDebugStringForValue(const void *val, std::string *str) {</a>
<a name="ln360">    const Slice *s = reinterpret_cast&lt;const Slice *&gt;(val);</a>
<a name="ln361">    str-&gt;append(strings::Utf8SafeCEscape(s-&gt;ToString()));</a>
<a name="ln362">  }</a>
<a name="ln363">};</a>
<a name="ln364"> </a>
<a name="ln365">template&lt;&gt;</a>
<a name="ln366">struct DataTypeTraits&lt;INET&gt; : public DerivedTypeTraits&lt;BINARY&gt;{</a>
<a name="ln367">  static const char* name() {</a>
<a name="ln368">    return &quot;inet&quot;;</a>
<a name="ln369">  }</a>
<a name="ln370">  static void AppendDebugStringForValue(const void *val, std::string *str) {</a>
<a name="ln371">    const Slice *s = reinterpret_cast&lt;const Slice *&gt;(val);</a>
<a name="ln372">    InetAddress addr;</a>
<a name="ln373">    DCHECK(addr.FromSlice(*s).ok());</a>
<a name="ln374">    str-&gt;append(addr.ToString());</a>
<a name="ln375">  }</a>
<a name="ln376">};</a>
<a name="ln377"> </a>
<a name="ln378">template&lt;&gt;</a>
<a name="ln379">struct DataTypeTraits&lt;JSONB&gt; : public DerivedTypeTraits&lt;BINARY&gt;{</a>
<a name="ln380">  static const char* name() {</a>
<a name="ln381">    return &quot;jsonb&quot;;</a>
<a name="ln382">  }</a>
<a name="ln383">  static void AppendDebugStringForValue(const void *val, std::string *str) {</a>
<a name="ln384">    const Slice *s = reinterpret_cast&lt;const Slice *&gt;(val);</a>
<a name="ln385">    str-&gt;append(strings::Utf8SafeCEscape(s-&gt;ToString()));</a>
<a name="ln386">  }</a>
<a name="ln387">};</a>
<a name="ln388"> </a>
<a name="ln389">template&lt;&gt;</a>
<a name="ln390">struct DataTypeTraits&lt;UUID&gt; : public DerivedTypeTraits&lt;BINARY&gt;{</a>
<a name="ln391">  static const char* name() {</a>
<a name="ln392">    return &quot;uuid&quot;;</a>
<a name="ln393">  }</a>
<a name="ln394">  static void AppendDebugStringForValue(const void *val, std::string *str) {</a>
<a name="ln395">    const Slice *s = reinterpret_cast&lt;const Slice *&gt;(val);</a>
<a name="ln396">    Uuid uuid;</a>
<a name="ln397">    DCHECK(uuid.FromSlice(*s).ok());</a>
<a name="ln398">    str-&gt;append(uuid.ToString());</a>
<a name="ln399">  }</a>
<a name="ln400">};</a>
<a name="ln401"> </a>
<a name="ln402">template&lt;&gt;</a>
<a name="ln403">struct DataTypeTraits&lt;TIMEUUID&gt; : public DerivedTypeTraits&lt;BINARY&gt;{</a>
<a name="ln404">  static const char* name() {</a>
<a name="ln405">    return &quot;timeuuid&quot;;</a>
<a name="ln406">  }</a>
<a name="ln407">  static void AppendDebugStringForValue(const void *val, std::string *str) {</a>
<a name="ln408">    const Slice *s = reinterpret_cast&lt;const Slice *&gt;(val);</a>
<a name="ln409">    Uuid uuid;</a>
<a name="ln410">    DCHECK(uuid.FromSlice(*s).ok());</a>
<a name="ln411">    str-&gt;append(uuid.ToString());</a>
<a name="ln412">  }</a>
<a name="ln413">};</a>
<a name="ln414"> </a>
<a name="ln415">template&lt;&gt;</a>
<a name="ln416">struct DataTypeTraits&lt;MAP&gt; : public DerivedTypeTraits&lt;BINARY&gt;{</a>
<a name="ln417">  static const char* name() {</a>
<a name="ln418">    return &quot;map&quot;;</a>
<a name="ln419">  }</a>
<a name="ln420"> </a>
<a name="ln421">  // using the default implementation inherited from BINARY for AppendDebugStringForValue</a>
<a name="ln422">  // TODO much of this codepath should be retired and we should systematically use QLValue instead</a>
<a name="ln423">  // of Kudu Slice [ENG-1235]</a>
<a name="ln424">};</a>
<a name="ln425"> </a>
<a name="ln426">template&lt;&gt;</a>
<a name="ln427">struct DataTypeTraits&lt;SET&gt; : public DerivedTypeTraits&lt;BINARY&gt;{</a>
<a name="ln428">  static const char* name() {</a>
<a name="ln429">    return &quot;set&quot;;</a>
<a name="ln430">  }</a>
<a name="ln431"> </a>
<a name="ln432">  // using the default implementation inherited from BINARY for AppendDebugStringForValue</a>
<a name="ln433">  // TODO much of this codepath should be retired and we should systematically use QLValue instead</a>
<a name="ln434">  // of Kudu Slice [ENG-1235]</a>
<a name="ln435">};</a>
<a name="ln436"> </a>
<a name="ln437">template&lt;&gt;</a>
<a name="ln438">struct DataTypeTraits&lt;LIST&gt; : public DerivedTypeTraits&lt;BINARY&gt;{</a>
<a name="ln439">  static const char* name() {</a>
<a name="ln440">    return &quot;list&quot;;</a>
<a name="ln441">  }</a>
<a name="ln442"> </a>
<a name="ln443">  // using the default implementation inherited from BINARY for AppendDebugStringForValue</a>
<a name="ln444">  // TODO much of this codepath should be retired and we should systematically use QLValue instead</a>
<a name="ln445">  // of Kudu Slice [ENG-1235]</a>
<a name="ln446">};</a>
<a name="ln447"> </a>
<a name="ln448">template&lt;&gt;</a>
<a name="ln449">struct DataTypeTraits&lt;USER_DEFINED_TYPE&gt; : public DerivedTypeTraits&lt;BINARY&gt;{</a>
<a name="ln450">  static const char* name() {</a>
<a name="ln451">    return &quot;user_defined_type&quot;;</a>
<a name="ln452">  }</a>
<a name="ln453"> </a>
<a name="ln454">  // using the default implementation inherited from BINARY for AppendDebugStringForValue</a>
<a name="ln455">  // TODO much of this codepath should be retired and we should systematically use QLValue instead</a>
<a name="ln456">  // of Kudu Slice [ENG-1235]</a>
<a name="ln457">};</a>
<a name="ln458"> </a>
<a name="ln459">template&lt;&gt;</a>
<a name="ln460">struct DataTypeTraits&lt;FROZEN&gt; : public DerivedTypeTraits&lt;BINARY&gt;{</a>
<a name="ln461">  static const char* name() {</a>
<a name="ln462">    return &quot;frozen&quot;;</a>
<a name="ln463">  }</a>
<a name="ln464"> </a>
<a name="ln465">  // using the default implementation inherited from BINARY for AppendDebugStringForValue</a>
<a name="ln466">  // TODO much of this codepath should be retired and we should systematically use QLValue instead</a>
<a name="ln467">  // of Kudu Slice [ENG-1235]</a>
<a name="ln468">};</a>
<a name="ln469"> </a>
<a name="ln470">template&lt;&gt;</a>
<a name="ln471">struct DataTypeTraits&lt;DECIMAL&gt; : public DerivedTypeTraits&lt;BINARY&gt;{</a>
<a name="ln472">  static const char* name() {</a>
<a name="ln473">    return &quot;decimal&quot;;</a>
<a name="ln474">  }</a>
<a name="ln475">  static void AppendDebugDecimalForValue(const void* val, std::string* str) {</a>
<a name="ln476">    const Slice *s = reinterpret_cast&lt;const Slice *&gt;(val);</a>
<a name="ln477">    str-&gt;append(strings::Utf8SafeCEscape(s-&gt;ToString()));</a>
<a name="ln478">  }</a>
<a name="ln479">};</a>
<a name="ln480"> </a>
<a name="ln481">template&lt;&gt;</a>
<a name="ln482">struct DataTypeTraits&lt;VARINT&gt; : public DerivedTypeTraits&lt;BINARY&gt;{</a>
<a name="ln483">  static const char* name() {</a>
<a name="ln484">    return &quot;varint&quot;;</a>
<a name="ln485">  }</a>
<a name="ln486">  static void AppendDebugVarIntForValue(const void* val, std::string* str) {</a>
<a name="ln487">    const Slice *s = reinterpret_cast&lt;const Slice *&gt;(val);</a>
<a name="ln488">    str-&gt;append(strings::Utf8SafeCEscape(s-&gt;ToString()));</a>
<a name="ln489">  }</a>
<a name="ln490">};</a>
<a name="ln491"> </a>
<a name="ln492"> </a>
<a name="ln493">static const char* kDateFormat = &quot;%Y-%m-%d %H:%M:%S&quot;;</a>
<a name="ln494">static const char* kDateMicrosAndTzFormat = &quot;%s.%06d GMT&quot;;</a>
<a name="ln495"> </a>
<a name="ln496">template&lt;&gt;</a>
<a name="ln497">struct DataTypeTraits&lt;TIMESTAMP&gt; : public DerivedTypeTraits&lt;INT64&gt;{</a>
<a name="ln498">  static const int US_TO_S = 1000L * 1000L;</a>
<a name="ln499"> </a>
<a name="ln500">  static const char* name() {</a>
<a name="ln501">    return &quot;timestamp&quot;;</a>
<a name="ln502">  }</a>
<a name="ln503"> </a>
<a name="ln504">  static void AppendDebugStringForValue(const void* val, std::string* str) {</a>
<a name="ln505">    int64_t timestamp_micros = *reinterpret_cast&lt;const int64_t *&gt;(val);</a>
<a name="ln506">    time_t secs_since_epoch = timestamp_micros / US_TO_S;</a>
<a name="ln507">    // If the time is negative we need to take into account that any microseconds</a>
<a name="ln508">    // will actually decrease the time in seconds by one.</a>
<a name="ln509">    int remaining_micros = timestamp_micros % US_TO_S;</a>
<a name="ln510">    if (remaining_micros &lt; 0) {</a>
<a name="ln511">      secs_since_epoch--;</a>
<a name="ln512">      remaining_micros = US_TO_S - std::abs(remaining_micros);</a>
<a name="ln513">    }</a>
<a name="ln514">    struct tm tm_info;</a>
<a name="ln515">    gmtime_r(&amp;secs_since_epoch, &amp;tm_info);</a>
<a name="ln516">    char time_up_to_secs[24];</a>
<a name="ln517">    strftime(time_up_to_secs, sizeof(time_up_to_secs), kDateFormat, &amp;tm_info);</a>
<a name="ln518">    char time[40];</a>
<a name="ln519">    snprintf(time, sizeof(time), kDateMicrosAndTzFormat, time_up_to_secs, remaining_micros);</a>
<a name="ln520">    str-&gt;append(time);</a>
<a name="ln521">  }</a>
<a name="ln522">};</a>
<a name="ln523"> </a>
<a name="ln524">template&lt;&gt;</a>
<a name="ln525">struct DataTypeTraits&lt;DATE&gt; : public DerivedTypeTraits&lt;UINT32&gt;{</a>
<a name="ln526">  static const char* name() {</a>
<a name="ln527">    return &quot;date&quot;;</a>
<a name="ln528">  }</a>
<a name="ln529">};</a>
<a name="ln530"> </a>
<a name="ln531">template&lt;&gt;</a>
<a name="ln532">struct DataTypeTraits&lt;TIME&gt; : public DerivedTypeTraits&lt;INT64&gt;{</a>
<a name="ln533">  static const char* name() {</a>
<a name="ln534">    return &quot;time&quot;;</a>
<a name="ln535">  }</a>
<a name="ln536">};</a>
<a name="ln537"> </a>
<a name="ln538">// Instantiate this template to get static access to the type traits.</a>
<a name="ln539">template&lt;DataType datatype&gt;</a>
<a name="ln540">struct TypeTraits : public DataTypeTraits&lt;datatype&gt; {</a>
<a name="ln541">  typedef typename DataTypeTraits&lt;datatype&gt;::cpp_type cpp_type;</a>
<a name="ln542"> </a>
<a name="ln543">  static const DataType type = datatype;</a>
<a name="ln544">  static const size_t size = sizeof(cpp_type);</a>
<a name="ln545">};</a>
<a name="ln546"> </a>
<a name="ln547">class Variant {</a>
<a name="ln548"> public:</a>
<a name="ln549">  Variant(DataType type, const void *value) {</a>
<a name="ln550">    Reset(type, value);</a>
<a name="ln551">  }</a>
<a name="ln552"> </a>
<a name="ln553">  ~Variant() {</a>
<a name="ln554">    Clear();</a>
<a name="ln555">  }</a>
<a name="ln556"> </a>
<a name="ln557">  template&lt;DataType Type&gt;</a>
<a name="ln558">  void Reset(const typename DataTypeTraits&lt;Type&gt;::cpp_type&amp; value) {</a>
<a name="ln559">    Reset(Type, &amp;value);</a>
<a name="ln560">  }</a>
<a name="ln561"> </a>
<a name="ln562">  // Set the variant to the specified type/value.</a>
<a name="ln563">  // The value must be of the relative type.</a>
<a name="ln564">  // In case of strings, the value must be a pointer to a Slice, and the data block</a>
<a name="ln565">  // will be copied, and released by the variant on the next set/clear call.</a>
<a name="ln566">  //</a>
<a name="ln567">  //  Examples:</a>
<a name="ln568">  //      uint16_t u16 = 512;</a>
<a name="ln569">  //      Slice slice(&quot;Hello World&quot;);</a>
<a name="ln570">  //      variant.set(UINT16, &amp;u16);</a>
<a name="ln571">  //      variant.set(STRING, &amp;slice);</a>
<a name="ln572">  void Reset(DataType type, const void *value) {</a>
<a name="ln573">    CHECK(value != NULL) &lt;&lt; &quot;Variant value must be not NULL&quot;;</a>
<a name="ln574">    Clear();</a>
<a name="ln575">    type_ = type;</a>
<a name="ln576">    switch (type_) {</a>
<a name="ln577">      case UNKNOWN_DATA:</a>
<a name="ln578">        LOG(FATAL) &lt;&lt; &quot;Unreachable&quot;;</a>
<a name="ln579">      case BOOL:</a>
<a name="ln580">        numeric_.b1 = *static_cast&lt;const bool *&gt;(value);</a>
<a name="ln581">        break;</a>
<a name="ln582">      case INT8:</a>
<a name="ln583">        numeric_.i8 = *static_cast&lt;const int8_t *&gt;(value);</a>
<a name="ln584">        break;</a>
<a name="ln585">      case UINT8:</a>
<a name="ln586">        numeric_.u8 = *static_cast&lt;const uint8_t *&gt;(value);</a>
<a name="ln587">        break;</a>
<a name="ln588">      case INT16:</a>
<a name="ln589">        numeric_.i16 = *static_cast&lt;const int16_t *&gt;(value);</a>
<a name="ln590">        break;</a>
<a name="ln591">      case UINT16:</a>
<a name="ln592">        numeric_.u16 = *static_cast&lt;const uint16_t *&gt;(value);</a>
<a name="ln593">        break;</a>
<a name="ln594">      case INT32:</a>
<a name="ln595">        numeric_.i32 = *static_cast&lt;const int32_t *&gt;(value);</a>
<a name="ln596">        break;</a>
<a name="ln597">      case UINT32:</a>
<a name="ln598">      case DATE:</a>
<a name="ln599">        numeric_.u32 = *static_cast&lt;const uint32_t *&gt;(value);</a>
<a name="ln600">        break;</a>
<a name="ln601">      case TIMESTAMP:</a>
<a name="ln602">      case TIME:</a>
<a name="ln603">      case INT64:</a>
<a name="ln604">        numeric_.i64 = *static_cast&lt;const int64_t *&gt;(value);</a>
<a name="ln605">        break;</a>
<a name="ln606">      case UINT64:</a>
<a name="ln607">        numeric_.u64 = *static_cast&lt;const uint64_t *&gt;(value);</a>
<a name="ln608">        break;</a>
<a name="ln609">      case FLOAT:</a>
<a name="ln610">        numeric_.float_val = *static_cast&lt;const float *&gt;(value);</a>
<a name="ln611">        break;</a>
<a name="ln612">      case DOUBLE:</a>
<a name="ln613">        numeric_.double_val = *static_cast&lt;const double *&gt;(value);</a>
<a name="ln614">        break;</a>
<a name="ln615">      case STRING: FALLTHROUGH_INTENDED;</a>
<a name="ln616">      case INET: FALLTHROUGH_INTENDED;</a>
<a name="ln617">      case UUID: FALLTHROUGH_INTENDED;</a>
<a name="ln618">      case TIMEUUID: FALLTHROUGH_INTENDED;</a>
<a name="ln619">      case FROZEN: FALLTHROUGH_INTENDED;</a>
<a name="ln620">      case JSONB: FALLTHROUGH_INTENDED;</a>
<a name="ln621">      case BINARY:</a>
<a name="ln622">        {</a>
<a name="ln623">          const Slice *str = static_cast&lt;const Slice *&gt;(value);</a>
<a name="ln624">          // In the case that str-&gt;size() == 0, then the 'Clear()' above has already</a>
<a name="ln625">          // set vstr_ to Slice(&quot;&quot;). Otherwise, we need to allocate and copy the</a>
<a name="ln626">          // user's data.</a>
<a name="ln627">          if (str-&gt;size() &gt; 0) {</a>
<a name="ln628">            auto blob = new uint8_t[str-&gt;size()];</a>
<a name="ln629">            memcpy(blob, str-&gt;data(), str-&gt;size());</a>
<a name="ln630">            vstr_ = Slice(blob, str-&gt;size());</a>
<a name="ln631">          }</a>
<a name="ln632">        }</a>
<a name="ln633">        break;</a>
<a name="ln634">      case MAP: FALLTHROUGH_INTENDED;</a>
<a name="ln635">      case SET: FALLTHROUGH_INTENDED;</a>
<a name="ln636">      case LIST:</a>
<a name="ln637">        LOG(FATAL) &lt;&lt; &quot;Default values for collection types not supported, found: &quot;</a>
<a name="ln638">                   &lt;&lt; DataType_Name(type_);</a>
<a name="ln639">      case DECIMAL: FALLTHROUGH_INTENDED;</a>
<a name="ln640">      case USER_DEFINED_TYPE:</a>
<a name="ln641">        LOG(FATAL) &lt;&lt; &quot;Unsupported data type: &quot; &lt;&lt; DataType_Name(type_);</a>
<a name="ln642"> </a>
<a name="ln643">      default: LOG(FATAL) &lt;&lt; &quot;Unknown data type: &quot; &lt;&lt; DataType_Name(type_);</a>
<a name="ln644">    }</a>
<a name="ln645">  }</a>
<a name="ln646"> </a>
<a name="ln647">  // Set the variant to a STRING type.</a>
<a name="ln648">  // The specified data block will be copied, and released by the variant</a>
<a name="ln649">  // on the next set/clear call.</a>
<a name="ln650">  void Reset(const std::string&amp; data) {</a>
<a name="ln651">    Slice slice(data);</a>
<a name="ln652">    Reset(STRING, &amp;slice);</a>
<a name="ln653">  }</a>
<a name="ln654"> </a>
<a name="ln655">  // Set the variant to a STRING type.</a>
<a name="ln656">  // The specified data block will be copied, and released by the variant</a>
<a name="ln657">  // on the next set/clear call.</a>
<a name="ln658">  void Reset(const char *data, size_t size) {</a>
<a name="ln659">    Slice slice(data, size);</a>
<a name="ln660">    Reset(STRING, &amp;slice);</a>
<a name="ln661">  }</a>
<a name="ln662"> </a>
<a name="ln663">  // Returns the type of the Variant</a>
<a name="ln664">  DataType type() const {</a>
<a name="ln665">    return type_;</a>
<a name="ln666">  }</a>
<a name="ln667"> </a>
<a name="ln668">  // Returns a pointer to the internal variant value</a>
<a name="ln669">  // The return value can be casted to the relative type()</a>
<a name="ln670">  // The return value will be valid until the next set() is called.</a>
<a name="ln671">  //</a>
<a name="ln672">  //  Examples:</a>
<a name="ln673">  //    static_cast&lt;const int32_t *&gt;(variant.value())</a>
<a name="ln674">  //    static_cast&lt;const Slice *&gt;(variant.value())</a>
<a name="ln675">  const void *value() const {</a>
<a name="ln676">    switch (type_) {</a>
<a name="ln677">      case UNKNOWN_DATA: LOG(FATAL) &lt;&lt; &quot;Attempted to access value of unknown data type&quot;;</a>
<a name="ln678">      case BOOL:         return &amp;(numeric_.b1);</a>
<a name="ln679">      case INT8:         return &amp;(numeric_.i8);</a>
<a name="ln680">      case UINT8:        return &amp;(numeric_.u8);</a>
<a name="ln681">      case INT16:        return &amp;(numeric_.i16);</a>
<a name="ln682">      case UINT16:       return &amp;(numeric_.u16);</a>
<a name="ln683">      case INT32:        return &amp;(numeric_.i32);</a>
<a name="ln684">      case UINT32:       return &amp;(numeric_.u32);</a>
<a name="ln685">      case INT64:        return &amp;(numeric_.i64);</a>
<a name="ln686">      case UINT64:       return &amp;(numeric_.u64);</a>
<a name="ln687">      case FLOAT:        return (&amp;numeric_.float_val);</a>
<a name="ln688">      case DOUBLE:       return (&amp;numeric_.double_val);</a>
<a name="ln689">      case STRING:       FALLTHROUGH_INTENDED;</a>
<a name="ln690">      case INET:         FALLTHROUGH_INTENDED;</a>
<a name="ln691">      case UUID:         FALLTHROUGH_INTENDED;</a>
<a name="ln692">      case TIMEUUID:     FALLTHROUGH_INTENDED;</a>
<a name="ln693">      case FROZEN:       FALLTHROUGH_INTENDED;</a>
<a name="ln694">      case BINARY:       return &amp;vstr_;</a>
<a name="ln695">      case MAP: FALLTHROUGH_INTENDED;</a>
<a name="ln696">      case SET: FALLTHROUGH_INTENDED;</a>
<a name="ln697">      case LIST:</a>
<a name="ln698">        LOG(FATAL) &lt;&lt; &quot;Default values for collection types not supported, found: &quot;</a>
<a name="ln699">                   &lt;&lt; DataType_Name(type_);</a>
<a name="ln700"> </a>
<a name="ln701">      case DECIMAL: FALLTHROUGH_INTENDED;</a>
<a name="ln702">      case USER_DEFINED_TYPE:</a>
<a name="ln703">        LOG(FATAL) &lt;&lt; &quot;Unsupported data type: &quot; &lt;&lt; type_;</a>
<a name="ln704"> </a>
<a name="ln705">      default: LOG(FATAL) &lt;&lt; &quot;Unknown data type: &quot; &lt;&lt; type_;</a>
<a name="ln706">    }</a>
<a name="ln707">    CHECK(false) &lt;&lt; &quot;not reached!&quot;;</a>
<a name="ln708">    return NULL;</a>
<a name="ln709">  }</a>
<a name="ln710"> </a>
<a name="ln711">  bool Equals(const Variant *other) const {</a>
<a name="ln712">    if (other == NULL || type_ != other-&gt;type_)</a>
<a name="ln713">      return false;</a>
<a name="ln714">    return GetTypeInfo(type_)-&gt;Compare(value(), other-&gt;value()) == 0;</a>
<a name="ln715">  }</a>
<a name="ln716"> </a>
<a name="ln717"> private:</a>
<a name="ln718">  void Clear() {</a>
<a name="ln719">    // No need to delete[] zero-length vstr_, because we always ensure that</a>
<a name="ln720">    // such a string would point to a constant &quot;&quot; rather than an allocated piece</a>
<a name="ln721">    // of memory.</a>
<a name="ln722">    if (vstr_.size() &gt; 0) {</a>
<a name="ln723">      delete[] vstr_.mutable_data();</a>
<a name="ln724">      vstr_.clear();</a>
<a name="ln725">    }</a>
<a name="ln726">  }</a>
<a name="ln727"> </a>
<a name="ln728">  union NumericValue {</a>
<a name="ln729">    bool     b1;</a>
<a name="ln730">    int8_t   i8;</a>
<a name="ln731">    uint8_t  u8;</a>
<a name="ln732">    int16_t  i16;</a>
<a name="ln733">    uint16_t u16;</a>
<a name="ln734">    int32_t  i32;</a>
<a name="ln735">    uint32_t u32;</a>
<a name="ln736">    int64_t  i64;</a>
<a name="ln737">    uint64_t u64;</a>
<a name="ln738">    float    float_val;</a>
<a name="ln739">    double   double_val;</a>
<a name="ln740">  };</a>
<a name="ln741"> </a>
<a name="ln742">  DataType type_;</a>
<a name="ln743">  NumericValue numeric_;</a>
<a name="ln744">  Slice vstr_;</a>
<a name="ln745"> </a>
<a name="ln746">  DISALLOW_COPY_AND_ASSIGN(Variant);</a>
<a name="ln747">};</a>
<a name="ln748"> </a>
<a name="ln749">}  // namespace yb</a>
<a name="ln750"> </a>
<a name="ln751">#endif  // YB_COMMON_TYPES_H</a>

</code></pre>
<div class="balloon" rel="373"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="397"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="410"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="573"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="578"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v796/" target="_blank">V796</a> It is possible that 'break' statement is missing in switch statement.</p></div>
<div class="balloon" rel="641"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v796/" target="_blank">V796</a> It is possible that 'break' statement is missing in switch statement.</p></div>
<div class="balloon" rel="703"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v796/" target="_blank">V796</a> It is possible that 'break' statement is missing in switch statement.</p></div>
<div class="balloon" rel="707"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
