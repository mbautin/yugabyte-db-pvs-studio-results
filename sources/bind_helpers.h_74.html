
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>bind_helpers.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Copyright (c) 2011 The Chromium Authors. All rights reserved.</a>
<a name="ln2">// Use of this source code is governed by a BSD-style license that can be</a>
<a name="ln3">// found in the LICENSE file.</a>
<a name="ln4">//</a>
<a name="ln5">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln6">//</a>
<a name="ln7">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln8">//</a>
<a name="ln9">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln10">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln11">//</a>
<a name="ln12">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln13">//</a>
<a name="ln14">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln15">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln16">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln17">// under the License.</a>
<a name="ln18">//</a>
<a name="ln19"> </a>
<a name="ln20">// This defines a set of argument wrappers and related factory methods that</a>
<a name="ln21">// can be used specify the refcounting and reference semantics of arguments</a>
<a name="ln22">// that are bound by the Bind() function in yb/gutil/bind.h.</a>
<a name="ln23">//</a>
<a name="ln24">// It also defines a set of simple functions and utilities that people want</a>
<a name="ln25">// when using Callback&lt;&gt; and Bind().</a>
<a name="ln26">//</a>
<a name="ln27">//</a>
<a name="ln28">// ARGUMENT BINDING WRAPPERS</a>
<a name="ln29">//</a>
<a name="ln30">// The wrapper functions are yb::Unretained(), yb::Owned(), yb::Passed(),</a>
<a name="ln31">// yb::ConstRef(), and yb::IgnoreResult().</a>
<a name="ln32">//</a>
<a name="ln33">// Unretained() allows Bind() to bind a non-refcounted class, and to disable</a>
<a name="ln34">// refcounting on arguments that are refcounted objects.</a>
<a name="ln35">//</a>
<a name="ln36">// Owned() transfers ownership of an object to the Callback resulting from</a>
<a name="ln37">// bind; the object will be deleted when the Callback is deleted.</a>
<a name="ln38">//</a>
<a name="ln39">// Passed() is for transferring movable-but-not-copyable types (eg. scoped_ptr)</a>
<a name="ln40">// through a Callback. Logically, this signifies a destructive transfer of</a>
<a name="ln41">// the state of the argument into the target function.  Invoking</a>
<a name="ln42">// Callback::Run() twice on a Callback that was created with a Passed()</a>
<a name="ln43">// argument will CHECK() because the first invocation would have already</a>
<a name="ln44">// transferred ownership to the target function.</a>
<a name="ln45">//</a>
<a name="ln46">// ConstRef() allows binding a constant reference to an argument rather</a>
<a name="ln47">// than a copy.</a>
<a name="ln48">//</a>
<a name="ln49">// IgnoreResult() is used to adapt a function or Callback with a return type to</a>
<a name="ln50">// one with a void return. This is most useful if you have a function with,</a>
<a name="ln51">// say, a pesky ignorable bool return that you want to use with PostTask or</a>
<a name="ln52">// something else that expect a Callback with a void return.</a>
<a name="ln53">//</a>
<a name="ln54">// EXAMPLE OF Unretained():</a>
<a name="ln55">//</a>
<a name="ln56">//   class Foo {</a>
<a name="ln57">//    public:</a>
<a name="ln58">//     void func() { cout &lt;&lt; &quot;Foo:f&quot; &lt;&lt; endl; }</a>
<a name="ln59">//   };</a>
<a name="ln60">//</a>
<a name="ln61">//   // In some function somewhere.</a>
<a name="ln62">//   Foo foo;</a>
<a name="ln63">//   Closure foo_callback =</a>
<a name="ln64">//       Bind(&amp;Foo::func, Unretained(&amp;foo));</a>
<a name="ln65">//   foo_callback.Run();  // Prints &quot;Foo:f&quot;.</a>
<a name="ln66">//</a>
<a name="ln67">// Without the Unretained() wrapper on |&amp;foo|, the above call would fail</a>
<a name="ln68">// to compile because Foo does not support the AddRef() and Release() methods.</a>
<a name="ln69">//</a>
<a name="ln70">//</a>
<a name="ln71">// EXAMPLE OF Owned():</a>
<a name="ln72">//</a>
<a name="ln73">//   void foo(int* arg) { cout &lt;&lt; *arg &lt;&lt; endl }</a>
<a name="ln74">//</a>
<a name="ln75">//   int* pn = new int(1);</a>
<a name="ln76">//   Closure foo_callback = Bind(&amp;foo, Owned(pn));</a>
<a name="ln77">//</a>
<a name="ln78">//   foo_callback.Run();  // Prints &quot;1&quot;</a>
<a name="ln79">//   foo_callback.Run();  // Prints &quot;1&quot;</a>
<a name="ln80">//   *n = 2;</a>
<a name="ln81">//   foo_callback.Run();  // Prints &quot;2&quot;</a>
<a name="ln82">//</a>
<a name="ln83">//   foo_callback.Reset();  // |pn| is deleted.  Also will happen when</a>
<a name="ln84">//                          // |foo_callback| goes out of scope.</a>
<a name="ln85">//</a>
<a name="ln86">// Without Owned(), someone would have to know to delete |pn| when the last</a>
<a name="ln87">// reference to the Callback is deleted.</a>
<a name="ln88">//</a>
<a name="ln89">//</a>
<a name="ln90">// EXAMPLE OF ConstRef():</a>
<a name="ln91">//</a>
<a name="ln92">//   void foo(int arg) { cout &lt;&lt; arg &lt;&lt; endl }</a>
<a name="ln93">//</a>
<a name="ln94">//   int n = 1;</a>
<a name="ln95">//   Closure no_ref = Bind(&amp;foo, n);</a>
<a name="ln96">//   Closure has_ref = Bind(&amp;foo, ConstRef(n));</a>
<a name="ln97">//</a>
<a name="ln98">//   no_ref.Run();  // Prints &quot;1&quot;</a>
<a name="ln99">//   has_ref.Run();  // Prints &quot;1&quot;</a>
<a name="ln100">//</a>
<a name="ln101">//   n = 2;</a>
<a name="ln102">//   no_ref.Run();  // Prints &quot;1&quot;</a>
<a name="ln103">//   has_ref.Run();  // Prints &quot;2&quot;</a>
<a name="ln104">//</a>
<a name="ln105">// Note that because ConstRef() takes a reference on |n|, |n| must outlive all</a>
<a name="ln106">// its bound callbacks.</a>
<a name="ln107">//</a>
<a name="ln108">//</a>
<a name="ln109">// EXAMPLE OF IgnoreResult():</a>
<a name="ln110">//</a>
<a name="ln111">//   int DoSomething(int arg) { cout &lt;&lt; arg &lt;&lt; endl; }</a>
<a name="ln112">//</a>
<a name="ln113">//   // Assign to a Callback with a void return type.</a>
<a name="ln114">//   Callback&lt;void(int)&gt; cb = Bind(IgnoreResult(&amp;DoSomething));</a>
<a name="ln115">//   cb-&gt;Run(1);  // Prints &quot;1&quot;.</a>
<a name="ln116">//</a>
<a name="ln117">//   // Prints &quot;1&quot; on |ml|.</a>
<a name="ln118">//   ml-&gt;PostTask(FROM_HERE, Bind(IgnoreResult(&amp;DoSomething), 1);</a>
<a name="ln119">//</a>
<a name="ln120">//</a>
<a name="ln121">// EXAMPLE OF Passed():</a>
<a name="ln122">//</a>
<a name="ln123">//   void TakesOwnership(scoped_ptr&lt;Foo&gt; arg) { }</a>
<a name="ln124">//   scoped_ptr&lt;Foo&gt; CreateFoo() { return scoped_ptr&lt;Foo&gt;(new Foo()); }</a>
<a name="ln125">//</a>
<a name="ln126">//   scoped_ptr&lt;Foo&gt; f(new Foo());</a>
<a name="ln127">//</a>
<a name="ln128">//   // |cb| is given ownership of Foo(). |f| is now NULL.</a>
<a name="ln129">//   // You can use f.Pass() in place of &amp;f, but it's more verbose.</a>
<a name="ln130">//   Closure cb = Bind(&amp;TakesOwnership, Passed(&amp;f));</a>
<a name="ln131">//</a>
<a name="ln132">//   // Run was never called so |cb| still owns Foo() and deletes</a>
<a name="ln133">//   // it on Reset().</a>
<a name="ln134">//   cb.Reset();</a>
<a name="ln135">//</a>
<a name="ln136">//   // |cb| is given a new Foo created by CreateFoo().</a>
<a name="ln137">//   cb = Bind(&amp;TakesOwnership, Passed(CreateFoo()));</a>
<a name="ln138">//</a>
<a name="ln139">//   // |arg| in TakesOwnership() is given ownership of Foo(). |cb|</a>
<a name="ln140">//   // no longer owns Foo() and, if reset, would not delete Foo().</a>
<a name="ln141">//   cb.Run();  // Foo() is now transferred to |arg| and deleted.</a>
<a name="ln142">//   cb.Run();  // This CHECK()s since Foo() already been used once.</a>
<a name="ln143">//</a>
<a name="ln144">// Passed() is particularly useful with PostTask() when you are transferring</a>
<a name="ln145">// ownership of an argument into a task, but don't necessarily know if the</a>
<a name="ln146">// task will always be executed. This can happen if the task is cancellable</a>
<a name="ln147">// or if it is posted to a MessageLoopProxy.</a>
<a name="ln148">//</a>
<a name="ln149">//</a>
<a name="ln150">// SIMPLE FUNCTIONS AND UTILITIES.</a>
<a name="ln151">//</a>
<a name="ln152">//   DoNothing() - Useful for creating a Closure that does nothing when called.</a>
<a name="ln153">//   DeletePointer&lt;T&gt;() - Useful for creating a Closure that will delete a</a>
<a name="ln154">//                        pointer when invoked. Only use this when necessary.</a>
<a name="ln155">//                        In most cases MessageLoop::DeleteSoon() is a better</a>
<a name="ln156">//                        fit.</a>
<a name="ln157"> </a>
<a name="ln158">#ifndef YB_GUTIL_BIND_HELPERS_H_</a>
<a name="ln159">#define YB_GUTIL_BIND_HELPERS_H_</a>
<a name="ln160"> </a>
<a name="ln161">#include &lt;assert.h&gt;</a>
<a name="ln162"> </a>
<a name="ln163">#include &quot;yb/gutil/basictypes.h&quot;</a>
<a name="ln164">#include &quot;yb/gutil/callback.h&quot;</a>
<a name="ln165">#include &quot;yb/gutil/template_util.h&quot;</a>
<a name="ln166"> </a>
<a name="ln167">// Unneeded define from Chromium</a>
<a name="ln168">#define BASE_EXPORT</a>
<a name="ln169"> </a>
<a name="ln170"> </a>
<a name="ln171">namespace yb {</a>
<a name="ln172">namespace internal {</a>
<a name="ln173"> </a>
<a name="ln174">// Use the Substitution Failure Is Not An Error (SFINAE) trick to inspect T</a>
<a name="ln175">// for the existence of AddRef() and Release() functions of the correct</a>
<a name="ln176">// signature.</a>
<a name="ln177">//</a>
<a name="ln178">// http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error</a>
<a name="ln179">// http://stackoverflow.com/questions/257288/is-it-possible-to-write-a-c-template-to-check-for-a-functions-existence</a>
<a name="ln180">// http://stackoverflow.com/questions/4358584/sfinae-approach-comparison</a>
<a name="ln181">// http://stackoverflow.com/questions/1966362/sfinae-to-check-for-inherited-member-functions</a>
<a name="ln182">//</a>
<a name="ln183">// The last link in particular show the method used below.</a>
<a name="ln184">//</a>
<a name="ln185">// For SFINAE to work with inherited methods, we need to pull some extra tricks</a>
<a name="ln186">// with multiple inheritance.  In the more standard formulation, the overloads</a>
<a name="ln187">// of Check would be:</a>
<a name="ln188">//</a>
<a name="ln189">//   template &lt;typename C&gt;</a>
<a name="ln190">//   Yes NotTheCheckWeWant(Helper&lt;&amp;C::TargetFunc&gt;*);</a>
<a name="ln191">//</a>
<a name="ln192">//   template &lt;typename C&gt;</a>
<a name="ln193">//   No NotTheCheckWeWant(...);</a>
<a name="ln194">//</a>
<a name="ln195">//   static const bool value = sizeof(NotTheCheckWeWant&lt;T&gt;(0)) == sizeof(Yes);</a>
<a name="ln196">//</a>
<a name="ln197">// The problem here is that template resolution will not match</a>
<a name="ln198">// C::TargetFunc if TargetFunc does not exist directly in C.  That is, if</a>
<a name="ln199">// TargetFunc in inherited from an ancestor, &amp;C::TargetFunc will not match,</a>
<a name="ln200">// |value| will be false.  This formulation only checks for whether or</a>
<a name="ln201">// not TargetFunc exist directly in the class being introspected.</a>
<a name="ln202">//</a>
<a name="ln203">// To get around this, we play a dirty trick with multiple inheritance.</a>
<a name="ln204">// First, We create a class BaseMixin that declares each function that we</a>
<a name="ln205">// want to probe for.  Then we create a class Base that inherits from both T</a>
<a name="ln206">// (the class we wish to probe) and BaseMixin.  Note that the function</a>
<a name="ln207">// signature in BaseMixin does not need to match the signature of the function</a>
<a name="ln208">// we are probing for; thus it's easiest to just use void(void).</a>
<a name="ln209">//</a>
<a name="ln210">// Now, if TargetFunc exists somewhere in T, then &amp;Base::TargetFunc has an</a>
<a name="ln211">// ambiguous resolution between BaseMixin and T.  This lets us write the</a>
<a name="ln212">// following:</a>
<a name="ln213">//</a>
<a name="ln214">//   template &lt;typename C&gt;</a>
<a name="ln215">//   No GoodCheck(Helper&lt;&amp;C::TargetFunc&gt;*);</a>
<a name="ln216">//</a>
<a name="ln217">//   template &lt;typename C&gt;</a>
<a name="ln218">//   Yes GoodCheck(...);</a>
<a name="ln219">//</a>
<a name="ln220">//   static const bool value = sizeof(GoodCheck&lt;Base&gt;(0)) == sizeof(Yes);</a>
<a name="ln221">//</a>
<a name="ln222">// Notice here that the variadic version of GoodCheck() returns Yes here</a>
<a name="ln223">// instead of No like the previous one. Also notice that we calculate |value|</a>
<a name="ln224">// by specializing GoodCheck() on Base instead of T.</a>
<a name="ln225">//</a>
<a name="ln226">// We've reversed the roles of the variadic, and Helper overloads.</a>
<a name="ln227">// GoodCheck(Helper&lt;&amp;C::TargetFunc&gt;*), when C = Base, fails to be a valid</a>
<a name="ln228">// substitution if T::TargetFunc exists. Thus GoodCheck&lt;Base&gt;(0) will resolve</a>
<a name="ln229">// to the variadic version if T has TargetFunc.  If T::TargetFunc does not</a>
<a name="ln230">// exist, then &amp;C::TargetFunc is not ambiguous, and the overload resolution</a>
<a name="ln231">// will prefer GoodCheck(Helper&lt;&amp;C::TargetFunc&gt;*).</a>
<a name="ln232">//</a>
<a name="ln233">// This method of SFINAE will correctly probe for inherited names, but it cannot</a>
<a name="ln234">// typecheck those names.  It's still a good enough sanity check though.</a>
<a name="ln235">//</a>
<a name="ln236">// Works on gcc-4.2, gcc-4.4, and Visual Studio 2008.</a>
<a name="ln237">//</a>
<a name="ln238">// TODO(ajwong): Move to ref_counted.h or template_util.h when we've vetted</a>
<a name="ln239">// this works well.</a>
<a name="ln240">//</a>
<a name="ln241">// TODO(ajwong): Make this check for Release() as well.</a>
<a name="ln242">// See http://crbug.com/82038.</a>
<a name="ln243">template &lt;typename T&gt;</a>
<a name="ln244">class SupportsAddRefAndRelease {</a>
<a name="ln245">  typedef char Yes[1];</a>
<a name="ln246">  typedef char No[2];</a>
<a name="ln247"> </a>
<a name="ln248">  struct BaseMixin {</a>
<a name="ln249">    void AddRef();</a>
<a name="ln250">  };</a>
<a name="ln251"> </a>
<a name="ln252">// MSVC warns when you try to use Base if T has a private destructor, the</a>
<a name="ln253">// common pattern for refcounted types. It does this even though no attempt to</a>
<a name="ln254">// instantiate Base is made.  We disable the warning for this definition.</a>
<a name="ln255">#if defined(OS_WIN)</a>
<a name="ln256">#pragma warning(push)</a>
<a name="ln257">#pragma warning(disable:4624)</a>
<a name="ln258">#endif</a>
<a name="ln259">  struct Base : public T, public BaseMixin {</a>
<a name="ln260">  };</a>
<a name="ln261">#if defined(OS_WIN)</a>
<a name="ln262">#pragma warning(pop)</a>
<a name="ln263">#endif</a>
<a name="ln264"> </a>
<a name="ln265">  template &lt;void(BaseMixin::*)(void)&gt; struct Helper {};</a>
<a name="ln266"> </a>
<a name="ln267">  template &lt;typename C&gt;</a>
<a name="ln268">  static No&amp; Check(Helper&lt;&amp;C::AddRef&gt;*);</a>
<a name="ln269"> </a>
<a name="ln270">  template &lt;typename &gt;</a>
<a name="ln271">  static Yes&amp; Check(...);</a>
<a name="ln272"> </a>
<a name="ln273"> public:</a>
<a name="ln274">  static const bool value = sizeof(Check&lt;Base&gt;(0)) == sizeof(Yes);</a>
<a name="ln275">};</a>
<a name="ln276"> </a>
<a name="ln277">// Helpers to assert that arguments of a recounted type are bound with a</a>
<a name="ln278">// scoped_refptr.</a>
<a name="ln279">template &lt;bool IsClasstype, typename T&gt;</a>
<a name="ln280">struct UnsafeBindtoRefCountedArgHelper : base::false_type {</a>
<a name="ln281">};</a>
<a name="ln282"> </a>
<a name="ln283">template &lt;typename T&gt;</a>
<a name="ln284">struct UnsafeBindtoRefCountedArgHelper&lt;true, T&gt;</a>
<a name="ln285">    : base::integral_constant&lt;bool, SupportsAddRefAndRelease&lt;T&gt;::value&gt; {</a>
<a name="ln286">};</a>
<a name="ln287"> </a>
<a name="ln288">template &lt;typename T&gt;</a>
<a name="ln289">struct UnsafeBindtoRefCountedArg : base::false_type {</a>
<a name="ln290">};</a>
<a name="ln291"> </a>
<a name="ln292">template &lt;typename T&gt;</a>
<a name="ln293">struct UnsafeBindtoRefCountedArg&lt;T*&gt;</a>
<a name="ln294">    : UnsafeBindtoRefCountedArgHelper&lt;base::is_class&lt;T&gt;::value, T&gt; {</a>
<a name="ln295">};</a>
<a name="ln296"> </a>
<a name="ln297">template &lt;typename T&gt;</a>
<a name="ln298">class HasIsMethodTag {</a>
<a name="ln299">  typedef char Yes[1];</a>
<a name="ln300">  typedef char No[2];</a>
<a name="ln301"> </a>
<a name="ln302">  template &lt;typename U&gt;</a>
<a name="ln303">  static Yes&amp; Check(typename U::IsMethod*);</a>
<a name="ln304"> </a>
<a name="ln305">  template &lt;typename U&gt;</a>
<a name="ln306">  static No&amp; Check(...);</a>
<a name="ln307"> </a>
<a name="ln308"> public:</a>
<a name="ln309">  static const bool value = sizeof(Check&lt;T&gt;(0)) == sizeof(Yes);</a>
<a name="ln310">};</a>
<a name="ln311"> </a>
<a name="ln312">template &lt;typename T&gt;</a>
<a name="ln313">class UnretainedWrapper {</a>
<a name="ln314"> public:</a>
<a name="ln315">  explicit UnretainedWrapper(T* o) : ptr_(o) {}</a>
<a name="ln316">  T* get() const { return ptr_; }</a>
<a name="ln317"> private:</a>
<a name="ln318">  T* ptr_;</a>
<a name="ln319">};</a>
<a name="ln320"> </a>
<a name="ln321">template &lt;typename T&gt;</a>
<a name="ln322">class ConstRefWrapper {</a>
<a name="ln323"> public:</a>
<a name="ln324">  explicit ConstRefWrapper(const T&amp; o) : ptr_(&amp;o) {}</a>
<a name="ln325">  const T&amp; get() const { return *ptr_; }</a>
<a name="ln326"> private:</a>
<a name="ln327">  const T* ptr_;</a>
<a name="ln328">};</a>
<a name="ln329"> </a>
<a name="ln330">template &lt;typename T&gt;</a>
<a name="ln331">struct IgnoreResultHelper {</a>
<a name="ln332">  explicit IgnoreResultHelper(T functor) : functor_(functor) {}</a>
<a name="ln333"> </a>
<a name="ln334">  T functor_;</a>
<a name="ln335">};</a>
<a name="ln336"> </a>
<a name="ln337">template &lt;typename T&gt;</a>
<a name="ln338">struct IgnoreResultHelper&lt;Callback&lt;T&gt; &gt; {</a>
<a name="ln339">  explicit IgnoreResultHelper(const Callback&lt;T&gt;&amp; functor) : functor_(functor) {}</a>
<a name="ln340"> </a>
<a name="ln341">  const Callback&lt;T&gt;&amp; functor_;</a>
<a name="ln342">};</a>
<a name="ln343"> </a>
<a name="ln344">// An alternate implementation is to avoid the destructive copy, and instead</a>
<a name="ln345">// specialize ParamTraits&lt;&gt; for OwnedWrapper&lt;&gt; to change the StorageType to</a>
<a name="ln346">// a class that is essentially a scoped_ptr&lt;&gt;.</a>
<a name="ln347">//</a>
<a name="ln348">// The current implementation has the benefit though of leaving ParamTraits&lt;&gt;</a>
<a name="ln349">// fully in callback_internal.h as well as avoiding type conversions during</a>
<a name="ln350">// storage.</a>
<a name="ln351">template &lt;typename T&gt;</a>
<a name="ln352">class OwnedWrapper {</a>
<a name="ln353"> public:</a>
<a name="ln354">  explicit OwnedWrapper(T* o) : ptr_(o) {}</a>
<a name="ln355">  ~OwnedWrapper() { delete ptr_; }</a>
<a name="ln356">  T* get() const { return ptr_; }</a>
<a name="ln357">  OwnedWrapper(const OwnedWrapper&amp; other) {</a>
<a name="ln358">    ptr_ = other.ptr_;</a>
<a name="ln359">    other.ptr_ = NULL;</a>
<a name="ln360">  }</a>
<a name="ln361"> </a>
<a name="ln362"> private:</a>
<a name="ln363">  mutable T* ptr_;</a>
<a name="ln364">};</a>
<a name="ln365"> </a>
<a name="ln366">// PassedWrapper is a copyable adapter for a scoper that ignores const.</a>
<a name="ln367">//</a>
<a name="ln368">// It is needed to get around the fact that Bind() takes a const reference to</a>
<a name="ln369">// all its arguments.  Because Bind() takes a const reference to avoid</a>
<a name="ln370">// unnecessary copies, it is incompatible with movable-but-not-copyable</a>
<a name="ln371">// types; doing a destructive &quot;move&quot; of the type into Bind() would violate</a>
<a name="ln372">// the const correctness.</a>
<a name="ln373">//</a>
<a name="ln374">// This conundrum cannot be solved without either C++11 rvalue references or</a>
<a name="ln375">// a O(2^n) blowup of Bind() templates to handle each combination of regular</a>
<a name="ln376">// types and movable-but-not-copyable types.  Thus we introduce a wrapper type</a>
<a name="ln377">// that is copyable to transmit the correct type information down into</a>
<a name="ln378">// BindState&lt;&gt;. Ignoring const in this type makes sense because it is only</a>
<a name="ln379">// created when we are explicitly trying to do a destructive move.</a>
<a name="ln380">//</a>
<a name="ln381">// Two notes:</a>
<a name="ln382">//  1) PassedWrapper supports any type that has a &quot;Pass()&quot; function.</a>
<a name="ln383">//     This is intentional. The whitelisting of which specific types we</a>
<a name="ln384">//     support is maintained by CallbackParamTraits&lt;&gt;.</a>
<a name="ln385">//  2) is_valid_ is distinct from NULL because it is valid to bind a &quot;NULL&quot;</a>
<a name="ln386">//     scoper to a Callback and allow the Callback to execute once.</a>
<a name="ln387">template &lt;typename T&gt;</a>
<a name="ln388">class PassedWrapper {</a>
<a name="ln389"> public:</a>
<a name="ln390">  explicit PassedWrapper(T scoper) : is_valid_(true), scoper_(scoper.Pass()) {}</a>
<a name="ln391">  PassedWrapper(const PassedWrapper&amp; other)</a>
<a name="ln392">      : is_valid_(other.is_valid_), scoper_(other.scoper_.Pass()) {</a>
<a name="ln393">  }</a>
<a name="ln394">  T Pass() const {</a>
<a name="ln395">    assert(is_valid_);</a>
<a name="ln396">    is_valid_ = false;</a>
<a name="ln397">    return scoper_.Pass();</a>
<a name="ln398">  }</a>
<a name="ln399"> </a>
<a name="ln400"> private:</a>
<a name="ln401">  mutable bool is_valid_;</a>
<a name="ln402">  mutable T scoper_;</a>
<a name="ln403">};</a>
<a name="ln404"> </a>
<a name="ln405">// Unwrap the stored parameters for the wrappers above.</a>
<a name="ln406">template &lt;typename T&gt;</a>
<a name="ln407">struct UnwrapTraits {</a>
<a name="ln408">  typedef const T&amp; ForwardType;</a>
<a name="ln409">  static ForwardType Unwrap(const T&amp; o) { return o; }</a>
<a name="ln410">};</a>
<a name="ln411"> </a>
<a name="ln412">template &lt;typename T&gt;</a>
<a name="ln413">struct UnwrapTraits&lt;UnretainedWrapper&lt;T&gt; &gt; {</a>
<a name="ln414">  typedef T* ForwardType;</a>
<a name="ln415">  static ForwardType Unwrap(UnretainedWrapper&lt;T&gt; unretained) {</a>
<a name="ln416">    return unretained.get();</a>
<a name="ln417">  }</a>
<a name="ln418">};</a>
<a name="ln419"> </a>
<a name="ln420">template &lt;typename T&gt;</a>
<a name="ln421">struct UnwrapTraits&lt;ConstRefWrapper&lt;T&gt; &gt; {</a>
<a name="ln422">  typedef const T&amp; ForwardType;</a>
<a name="ln423">  static ForwardType Unwrap(ConstRefWrapper&lt;T&gt; const_ref) {</a>
<a name="ln424">    return const_ref.get();</a>
<a name="ln425">  }</a>
<a name="ln426">};</a>
<a name="ln427"> </a>
<a name="ln428">template &lt;typename T&gt;</a>
<a name="ln429">struct UnwrapTraits&lt;scoped_refptr&lt;T&gt; &gt; {</a>
<a name="ln430">  typedef T* ForwardType;</a>
<a name="ln431">  static ForwardType Unwrap(const scoped_refptr&lt;T&gt;&amp; o) { return o.get(); }</a>
<a name="ln432">};</a>
<a name="ln433"> </a>
<a name="ln434">// We didn't import WeakPtr from Chromium.</a>
<a name="ln435">//</a>
<a name="ln436">//template &lt;typename T&gt;</a>
<a name="ln437">//struct UnwrapTraits&lt;WeakPtr&lt;T&gt; &gt; {</a>
<a name="ln438">//  typedef const WeakPtr&lt;T&gt;&amp; ForwardType;</a>
<a name="ln439">//  static ForwardType Unwrap(const WeakPtr&lt;T&gt;&amp; o) { return o; }</a>
<a name="ln440">//};</a>
<a name="ln441"> </a>
<a name="ln442">template &lt;typename T&gt;</a>
<a name="ln443">struct UnwrapTraits&lt;OwnedWrapper&lt;T&gt; &gt; {</a>
<a name="ln444">  typedef T* ForwardType;</a>
<a name="ln445">  static ForwardType Unwrap(const OwnedWrapper&lt;T&gt;&amp; o) {</a>
<a name="ln446">    return o.get();</a>
<a name="ln447">  }</a>
<a name="ln448">};</a>
<a name="ln449"> </a>
<a name="ln450">template &lt;typename T&gt;</a>
<a name="ln451">struct UnwrapTraits&lt;PassedWrapper&lt;T&gt; &gt; {</a>
<a name="ln452">  typedef T ForwardType;</a>
<a name="ln453">  static T Unwrap(PassedWrapper&lt;T&gt;&amp; o) {</a>
<a name="ln454">    return o.Pass();</a>
<a name="ln455">  }</a>
<a name="ln456">};</a>
<a name="ln457"> </a>
<a name="ln458">// Utility for handling different refcounting semantics in the Bind()</a>
<a name="ln459">// function.</a>
<a name="ln460">template &lt;bool is_method, typename T&gt;</a>
<a name="ln461">struct MaybeRefcount;</a>
<a name="ln462"> </a>
<a name="ln463">template &lt;typename T&gt;</a>
<a name="ln464">struct MaybeRefcount&lt;false, T&gt; {</a>
<a name="ln465">  static void AddRef(const T&amp;) {}</a>
<a name="ln466">  static void Release(const T&amp;) {}</a>
<a name="ln467">};</a>
<a name="ln468"> </a>
<a name="ln469">template &lt;typename T, size_t n&gt;</a>
<a name="ln470">struct MaybeRefcount&lt;false, T[n]&gt; {</a>
<a name="ln471">  static void AddRef(const T*) {}</a>
<a name="ln472">  static void Release(const T*) {}</a>
<a name="ln473">};</a>
<a name="ln474"> </a>
<a name="ln475">template &lt;typename T&gt;</a>
<a name="ln476">struct MaybeRefcount&lt;true, T&gt; {</a>
<a name="ln477">  static void AddRef(const T&amp;) {}</a>
<a name="ln478">  static void Release(const T&amp;) {}</a>
<a name="ln479">};</a>
<a name="ln480"> </a>
<a name="ln481">template &lt;typename T&gt;</a>
<a name="ln482">struct MaybeRefcount&lt;true, T*&gt; {</a>
<a name="ln483">  static void AddRef(T* o) { o-&gt;AddRef(); }</a>
<a name="ln484">  static void Release(T* o) { o-&gt;Release(); }</a>
<a name="ln485">};</a>
<a name="ln486"> </a>
<a name="ln487">// No need to additionally AddRef() and Release() since we are storing a</a>
<a name="ln488">// scoped_refptr&lt;&gt; inside the storage object already.</a>
<a name="ln489">template &lt;typename T&gt;</a>
<a name="ln490">struct MaybeRefcount&lt;true, scoped_refptr&lt;T&gt; &gt; {</a>
<a name="ln491">  static void AddRef(const scoped_refptr&lt;T&gt;&amp; o) {}</a>
<a name="ln492">  static void Release(const scoped_refptr&lt;T&gt;&amp; o) {}</a>
<a name="ln493">};</a>
<a name="ln494"> </a>
<a name="ln495">template &lt;typename T&gt;</a>
<a name="ln496">struct MaybeRefcount&lt;true, const T*&gt; {</a>
<a name="ln497">  static void AddRef(const T* o) { o-&gt;AddRef(); }</a>
<a name="ln498">  static void Release(const T* o) { o-&gt;Release(); }</a>
<a name="ln499">};</a>
<a name="ln500"> </a>
<a name="ln501">// We didn't import WeakPtr from Chromium.</a>
<a name="ln502">//</a>
<a name="ln503">//// IsWeakMethod is a helper that determine if we are binding a WeakPtr&lt;&gt; to a</a>
<a name="ln504">//// method.  It is used internally by Bind() to select the correct</a>
<a name="ln505">//// InvokeHelper that will no-op itself in the event the WeakPtr&lt;&gt; for</a>
<a name="ln506">//// the target object is invalidated.</a>
<a name="ln507">////</a>
<a name="ln508">//// P1 should be the type of the object that will be received of the method.</a>
<a name="ln509">//template &lt;bool IsMethod, typename P1&gt;</a>
<a name="ln510">//struct IsWeakMethod : public false_type {};</a>
<a name="ln511">//</a>
<a name="ln512">//template &lt;typename T&gt;</a>
<a name="ln513">//struct IsWeakMethod&lt;true, WeakPtr&lt;T&gt; &gt; : public true_type {};</a>
<a name="ln514">//</a>
<a name="ln515">//template &lt;typename T&gt;</a>
<a name="ln516">//struct IsWeakMethod&lt;true, ConstRefWrapper&lt;WeakPtr&lt;T&gt; &gt; &gt; : public true_type {};</a>
<a name="ln517"> </a>
<a name="ln518">}  // namespace internal</a>
<a name="ln519"> </a>
<a name="ln520">template &lt;typename T&gt;</a>
<a name="ln521">static inline internal::UnretainedWrapper&lt;T&gt; Unretained(T* o) {</a>
<a name="ln522">  return internal::UnretainedWrapper&lt;T&gt;(o);</a>
<a name="ln523">}</a>
<a name="ln524"> </a>
<a name="ln525">template &lt;typename T&gt;</a>
<a name="ln526">static inline internal::ConstRefWrapper&lt;T&gt; ConstRef(const T&amp; o) {</a>
<a name="ln527">  return internal::ConstRefWrapper&lt;T&gt;(o);</a>
<a name="ln528">}</a>
<a name="ln529"> </a>
<a name="ln530">template &lt;typename T&gt;</a>
<a name="ln531">static inline internal::OwnedWrapper&lt;T&gt; Owned(T* o) {</a>
<a name="ln532">  return internal::OwnedWrapper&lt;T&gt;(o);</a>
<a name="ln533">}</a>
<a name="ln534"> </a>
<a name="ln535">// We offer 2 syntaxes for calling Passed().  The first takes a temporary and</a>
<a name="ln536">// is best suited for use with the return value of a function. The second</a>
<a name="ln537">// takes a pointer to the scoper and is just syntactic sugar to avoid having</a>
<a name="ln538">// to write Passed(scoper.Pass()).</a>
<a name="ln539">template &lt;typename T&gt;</a>
<a name="ln540">static inline internal::PassedWrapper&lt;T&gt; Passed(T scoper) {</a>
<a name="ln541">  return internal::PassedWrapper&lt;T&gt;(scoper.Pass());</a>
<a name="ln542">}</a>
<a name="ln543">template &lt;typename T&gt;</a>
<a name="ln544">static inline internal::PassedWrapper&lt;T&gt; Passed(T* scoper) {</a>
<a name="ln545">  return internal::PassedWrapper&lt;T&gt;(scoper-&gt;Pass());</a>
<a name="ln546">}</a>
<a name="ln547"> </a>
<a name="ln548">template &lt;typename T&gt;</a>
<a name="ln549">static inline internal::IgnoreResultHelper&lt;T&gt; IgnoreResult(T data) {</a>
<a name="ln550">  return internal::IgnoreResultHelper&lt;T&gt;(data);</a>
<a name="ln551">}</a>
<a name="ln552"> </a>
<a name="ln553">template &lt;typename T&gt;</a>
<a name="ln554">static inline internal::IgnoreResultHelper&lt;Callback&lt;T&gt; &gt;</a>
<a name="ln555">IgnoreResult(const Callback&lt;T&gt;&amp; data) {</a>
<a name="ln556">  return internal::IgnoreResultHelper&lt;Callback&lt;T&gt; &gt;(data);</a>
<a name="ln557">}</a>
<a name="ln558"> </a>
<a name="ln559">template&lt;typename T&gt;</a>
<a name="ln560">void DeletePointer(T* obj) {</a>
<a name="ln561">  delete obj;</a>
<a name="ln562">}</a>
<a name="ln563"> </a>
<a name="ln564">}  // namespace yb</a>
<a name="ln565"> </a>
<a name="ln566">#endif  // BASE_BIND_HELPERS_H_</a>

</code></pre>
<div class="balloon" rel="352"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v690/" target="_blank">V690</a> The 'OwnedWrapper' class implements a copy constructor, but lacks the copy assignment operator. It is dangerous to use such a class.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
