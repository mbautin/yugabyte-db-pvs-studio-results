
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>pggate.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//--------------------------------------------------------------------------------------------------</a>
<a name="ln2">// Copyright (c) YugaByte, Inc.</a>
<a name="ln3">//</a>
<a name="ln4">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln5">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln6">//</a>
<a name="ln7">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln8">//</a>
<a name="ln9">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln10">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln11">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln12">// under the License.</a>
<a name="ln13">//--------------------------------------------------------------------------------------------------</a>
<a name="ln14"> </a>
<a name="ln15">#include &lt;boost/optional.hpp&gt;</a>
<a name="ln16"> </a>
<a name="ln17">#include &quot;yb/client/yb_table_name.h&quot;</a>
<a name="ln18"> </a>
<a name="ln19">#include &quot;yb/yql/pggate/pggate.h&quot;</a>
<a name="ln20">#include &quot;yb/yql/pggate/pggate_flags.h&quot;</a>
<a name="ln21">#include &quot;yb/yql/pggate/pg_memctx.h&quot;</a>
<a name="ln22">#include &quot;yb/yql/pggate/pg_ddl.h&quot;</a>
<a name="ln23">#include &quot;yb/yql/pggate/pg_insert.h&quot;</a>
<a name="ln24">#include &quot;yb/yql/pggate/pg_update.h&quot;</a>
<a name="ln25">#include &quot;yb/yql/pggate/pg_delete.h&quot;</a>
<a name="ln26">#include &quot;yb/yql/pggate/pg_truncate_colocated.h&quot;</a>
<a name="ln27">#include &quot;yb/yql/pggate/pg_select.h&quot;</a>
<a name="ln28">#include &quot;yb/yql/pggate/pg_txn_manager.h&quot;</a>
<a name="ln29">#include &quot;yb/yql/pggate/ybc_pggate.h&quot;</a>
<a name="ln30"> </a>
<a name="ln31">#include &quot;yb/util/flag_tags.h&quot;</a>
<a name="ln32">#include &quot;yb/client/client_fwd.h&quot;</a>
<a name="ln33">#include &quot;yb/client/client_utils.h&quot;</a>
<a name="ln34">#include &quot;yb/rpc/messenger.h&quot;</a>
<a name="ln35">#include &quot;yb/rpc/secure_stream.h&quot;</a>
<a name="ln36">#include &quot;yb/server/secure.h&quot;</a>
<a name="ln37"> </a>
<a name="ln38">#include &quot;yb/tserver/tserver_shared_mem.h&quot;</a>
<a name="ln39"> </a>
<a name="ln40">DECLARE_string(rpc_bind_addresses);</a>
<a name="ln41">DECLARE_bool(use_node_to_node_encryption);</a>
<a name="ln42">DECLARE_string(certs_dir);</a>
<a name="ln43"> </a>
<a name="ln44">namespace yb {</a>
<a name="ln45">namespace pggate {</a>
<a name="ln46"> </a>
<a name="ln47">namespace {</a>
<a name="ln48"> </a>
<a name="ln49">CHECKED_STATUS AddColumn(PgCreateTable* pg_stmt, const char *attr_name, int attr_num,</a>
<a name="ln50">                         const YBCPgTypeEntity *attr_type, bool is_hash, bool is_range,</a>
<a name="ln51">                         bool is_desc, bool is_nulls_first) {</a>
<a name="ln52">  using SortingType = ColumnSchema::SortingType;</a>
<a name="ln53">  SortingType sorting_type = SortingType::kNotSpecified;</a>
<a name="ln54"> </a>
<a name="ln55">  if (!is_hash &amp;&amp; is_range) {</a>
<a name="ln56">    if (is_desc) {</a>
<a name="ln57">      sorting_type = is_nulls_first ? SortingType::kDescending : SortingType::kDescendingNullsLast;</a>
<a name="ln58">    } else {</a>
<a name="ln59">      sorting_type = is_nulls_first ? SortingType::kAscending : SortingType::kAscendingNullsLast;</a>
<a name="ln60">    }</a>
<a name="ln61">  }</a>
<a name="ln62"> </a>
<a name="ln63">  return pg_stmt-&gt;AddColumn(attr_name, attr_num, attr_type, is_hash, is_range, sorting_type);</a>
<a name="ln64">}</a>
<a name="ln65"> </a>
<a name="ln66">Result&lt;PgApiImpl::MessengerHolder&gt; BuildMessenger(</a>
<a name="ln67">    const string&amp; client_name,</a>
<a name="ln68">    int32_t num_reactors,</a>
<a name="ln69">    const scoped_refptr&lt;MetricEntity&gt;&amp; metric_entity,</a>
<a name="ln70">    const std::shared_ptr&lt;MemTracker&gt;&amp; parent_mem_tracker) {</a>
<a name="ln71">  std::unique_ptr&lt;rpc::SecureContext&gt; secure_context;</a>
<a name="ln72">  if (FLAGS_use_node_to_node_encryption) {</a>
<a name="ln73">    secure_context = VERIFY_RESULT(server::CreateSecureContext(FLAGS_certs_dir));</a>
<a name="ln74">  }</a>
<a name="ln75">  auto messenger = VERIFY_RESULT(client::CreateClientMessenger(</a>
<a name="ln76">      client_name, num_reactors, metric_entity, parent_mem_tracker, secure_context.get()));</a>
<a name="ln77">  return PgApiImpl::MessengerHolder{std::move(secure_context), std::move(messenger)};</a>
<a name="ln78">}</a>
<a name="ln79"> </a>
<a name="ln80">std::unique_ptr&lt;tserver::TServerSharedObject&gt; InitTServerSharedObject() {</a>
<a name="ln81">  // Do not use shared memory in initdb or if explicity set to be ignored.</a>
<a name="ln82">  if (YBCIsInitDbModeEnvVarSet() || FLAGS_TEST_pggate_ignore_tserver_shm ||</a>
<a name="ln83">      FLAGS_pggate_tserver_shm_fd == -1) {</a>
<a name="ln84">    return nullptr;</a>
<a name="ln85">  }</a>
<a name="ln86">  return std::make_unique&lt;tserver::TServerSharedObject&gt;(CHECK_RESULT(</a>
<a name="ln87">      tserver::TServerSharedObject::OpenReadOnly(FLAGS_pggate_tserver_shm_fd)));</a>
<a name="ln88">}</a>
<a name="ln89"> </a>
<a name="ln90">} // namespace</a>
<a name="ln91"> </a>
<a name="ln92">using std::make_shared;</a>
<a name="ln93">using client::YBSession;</a>
<a name="ln94"> </a>
<a name="ln95">//--------------------------------------------------------------------------------------------------</a>
<a name="ln96"> </a>
<a name="ln97">PggateOptions::PggateOptions() {</a>
<a name="ln98">  server_type = &quot;tserver&quot;;</a>
<a name="ln99">  rpc_opts.default_port = kDefaultPort;</a>
<a name="ln100">  rpc_opts.connection_keepalive_time_ms = FLAGS_pgsql_rpc_keepalive_time_ms;</a>
<a name="ln101"> </a>
<a name="ln102">  if (FLAGS_pggate_proxy_bind_address.empty()) {</a>
<a name="ln103">    HostPort host_port;</a>
<a name="ln104">    CHECK_OK(host_port.ParseString(FLAGS_rpc_bind_addresses, 0));</a>
<a name="ln105">    host_port.set_port(PggateOptions::kDefaultPort);</a>
<a name="ln106">    FLAGS_pggate_proxy_bind_address = host_port.ToString();</a>
<a name="ln107">    LOG(INFO) &lt;&lt; &quot;Reset YSQL bind address to &quot; &lt;&lt; FLAGS_pggate_proxy_bind_address;</a>
<a name="ln108">  }</a>
<a name="ln109">  rpc_opts.rpc_bind_addresses = FLAGS_pggate_proxy_bind_address;</a>
<a name="ln110">  master_addresses_flag = FLAGS_pggate_master_addresses;</a>
<a name="ln111"> </a>
<a name="ln112">  server::MasterAddresses master_addresses;</a>
<a name="ln113">  // TODO: we might have to allow setting master_replication_factor similarly to how it is done</a>
<a name="ln114">  // in tserver to support master auto-discovery on Kubernetes.</a>
<a name="ln115">  CHECK_OK(server::DetermineMasterAddresses(</a>
<a name="ln116">      &quot;pggate_master_addresses&quot;, master_addresses_flag, /* master_replication_factor */ 0,</a>
<a name="ln117">      &amp;master_addresses, &amp;master_addresses_flag));</a>
<a name="ln118">  SetMasterAddresses(make_shared&lt;server::MasterAddresses&gt;(std::move(master_addresses)));</a>
<a name="ln119">}</a>
<a name="ln120"> </a>
<a name="ln121">//--------------------------------------------------------------------------------------------------</a>
<a name="ln122"> </a>
<a name="ln123">PgApiImpl::PgApiImpl(const YBCPgTypeEntity *YBCDataTypeArray, int count, YBCPgCallbacks callbacks)</a>
<a name="ln124">    : metric_registry_(new MetricRegistry()),</a>
<a name="ln125">      metric_entity_(METRIC_ENTITY_server.Instantiate(metric_registry_.get(), &quot;yb.pggate&quot;)),</a>
<a name="ln126">      mem_tracker_(MemTracker::CreateTracker(&quot;PostgreSQL&quot;)),</a>
<a name="ln127">      messenger_holder_(CHECK_RESULT(BuildMessenger(&quot;pggate_ybclient&quot;,</a>
<a name="ln128">                                                    FLAGS_pggate_ybclient_reactor_threads,</a>
<a name="ln129">                                                    metric_entity_,</a>
<a name="ln130">                                                    mem_tracker_))),</a>
<a name="ln131">      async_client_init_(messenger_holder_.messenger.get()-&gt;name(),</a>
<a name="ln132">                         FLAGS_pggate_ybclient_reactor_threads,</a>
<a name="ln133">                         FLAGS_pggate_rpc_timeout_secs,</a>
<a name="ln134">                         &quot;&quot; /* tserver_uuid */,</a>
<a name="ln135">                         &amp;pggate_options_,</a>
<a name="ln136">                         metric_entity_,</a>
<a name="ln137">                         mem_tracker_,</a>
<a name="ln138">                         messenger_holder_.messenger.get()),</a>
<a name="ln139">      clock_(new server::HybridClock()),</a>
<a name="ln140">      tserver_shared_object_(InitTServerSharedObject()),</a>
<a name="ln141">      pg_txn_manager_(new PgTxnManager(&amp;async_client_init_, clock_, tserver_shared_object_.get())),</a>
<a name="ln142">      pg_callbacks_(callbacks) {</a>
<a name="ln143">  CHECK_OK(clock_-&gt;Init());</a>
<a name="ln144"> </a>
<a name="ln145">  // Setup type mapping.</a>
<a name="ln146">  for (int idx = 0; idx &lt; count; idx++) {</a>
<a name="ln147">    const YBCPgTypeEntity *type_entity = &amp;YBCDataTypeArray[idx];</a>
<a name="ln148">    type_map_[type_entity-&gt;type_oid] = type_entity;</a>
<a name="ln149">  }</a>
<a name="ln150"> </a>
<a name="ln151">  async_client_init_.Start();</a>
<a name="ln152">}</a>
<a name="ln153"> </a>
<a name="ln154">PgApiImpl::~PgApiImpl() {</a>
<a name="ln155">  messenger_holder_.messenger-&gt;Shutdown();</a>
<a name="ln156">  async_client_init_.client()-&gt;Shutdown();</a>
<a name="ln157">}</a>
<a name="ln158"> </a>
<a name="ln159">const YBCPgTypeEntity *PgApiImpl::FindTypeEntity(int type_oid) {</a>
<a name="ln160">  const auto iter = type_map_.find(type_oid);</a>
<a name="ln161">  if (iter != type_map_.end()) {</a>
<a name="ln162">    return iter-&gt;second;</a>
<a name="ln163">  }</a>
<a name="ln164">  return nullptr;</a>
<a name="ln165">}</a>
<a name="ln166"> </a>
<a name="ln167">//--------------------------------------------------------------------------------------------------</a>
<a name="ln168"> </a>
<a name="ln169">Status PgApiImpl::CreateEnv(PgEnv **pg_env) {</a>
<a name="ln170">  *pg_env = pg_env_.get();</a>
<a name="ln171">  return Status::OK();</a>
<a name="ln172">}</a>
<a name="ln173"> </a>
<a name="ln174">Status PgApiImpl::DestroyEnv(PgEnv *pg_env) {</a>
<a name="ln175">  pg_env_ = nullptr;</a>
<a name="ln176">  return Status::OK();</a>
<a name="ln177">}</a>
<a name="ln178"> </a>
<a name="ln179">//--------------------------------------------------------------------------------------------------</a>
<a name="ln180"> </a>
<a name="ln181">Status PgApiImpl::InitSession(const PgEnv *pg_env,</a>
<a name="ln182">                              const string&amp; database_name) {</a>
<a name="ln183">  CHECK(!pg_session_);</a>
<a name="ln184">  auto session = make_scoped_refptr&lt;PgSession&gt;(client(),</a>
<a name="ln185">                                               database_name,</a>
<a name="ln186">                                               pg_txn_manager_,</a>
<a name="ln187">                                               clock_,</a>
<a name="ln188">                                               tserver_shared_object_.get(),</a>
<a name="ln189">                                               pg_callbacks_);</a>
<a name="ln190">  if (!database_name.empty()) {</a>
<a name="ln191">    RETURN_NOT_OK(session-&gt;ConnectDatabase(database_name));</a>
<a name="ln192">  }</a>
<a name="ln193"> </a>
<a name="ln194">  pg_session_.swap(session);</a>
<a name="ln195">  return Status::OK();</a>
<a name="ln196">}</a>
<a name="ln197"> </a>
<a name="ln198">Status PgApiImpl::InvalidateCache() {</a>
<a name="ln199">  pg_session_-&gt;InvalidateCache();</a>
<a name="ln200">  return Status::OK();</a>
<a name="ln201">}</a>
<a name="ln202"> </a>
<a name="ln203">const bool PgApiImpl::GetDisableTransparentCacheRefreshRetry() {</a>
<a name="ln204">  return FLAGS_TEST_ysql_disable_transparent_cache_refresh_retry;</a>
<a name="ln205">}</a>
<a name="ln206"> </a>
<a name="ln207">//--------------------------------------------------------------------------------------------------</a>
<a name="ln208"> </a>
<a name="ln209">PgMemctx *PgApiImpl::CreateMemctx() {</a>
<a name="ln210">  // Postgres will create YB Memctx when it first use the Memctx to allocate YugaByte object.</a>
<a name="ln211">  return PgMemctx::Create();</a>
<a name="ln212">}</a>
<a name="ln213"> </a>
<a name="ln214">Status PgApiImpl::DestroyMemctx(PgMemctx *memctx) {</a>
<a name="ln215">  // Postgres will destroy YB Memctx by releasing the pointer.</a>
<a name="ln216">  return PgMemctx::Destroy(memctx);</a>
<a name="ln217">}</a>
<a name="ln218"> </a>
<a name="ln219">Status PgApiImpl::ResetMemctx(PgMemctx *memctx) {</a>
<a name="ln220">  // Postgres reset YB Memctx when clearing a context content without clearing its nested context.</a>
<a name="ln221">  return PgMemctx::Reset(memctx);</a>
<a name="ln222">}</a>
<a name="ln223"> </a>
<a name="ln224">// TODO(neil) Use Arena in the future.</a>
<a name="ln225">// - PgStatement should have been declared as derived class of &quot;MCBase&quot;.</a>
<a name="ln226">// - All objects of PgStatement's derived class should be allocated by YbPgMemctx::Arena.</a>
<a name="ln227">// - We cannot use Arena yet because quite a large number of YugaByte objects are being referenced</a>
<a name="ln228">//   from other layers.  Those added code violated the original design as they assume ScopedPtr</a>
<a name="ln229">//   instead of memory pool is being used. This mess should be cleaned up later.</a>
<a name="ln230">//</a>
<a name="ln231">// For now, statements is allocated as ScopedPtr and cached in the memory context. The statements</a>
<a name="ln232">// would then be destructed when the context is destroyed and all other references are also cleared.</a>
<a name="ln233">Status PgApiImpl::AddToCurrentPgMemctx(const PgStatement::ScopedRefPtr &amp;stmt,</a>
<a name="ln234">                                       PgStatement **handle) {</a>
<a name="ln235">  pg_callbacks_.GetCurrentYbMemctx()-&gt;Cache(stmt);</a>
<a name="ln236">  *handle = stmt.get();</a>
<a name="ln237">  return Status::OK();</a>
<a name="ln238">}</a>
<a name="ln239"> </a>
<a name="ln240">// TODO(neil) Most like we don't need table_desc. If we do need it, use Arena here.</a>
<a name="ln241">// - PgTableDesc should have been declared as derived class of &quot;MCBase&quot;.</a>
<a name="ln242">// - PgTableDesc objects should be allocated by YbPgMemctx::Arena.</a>
<a name="ln243">//</a>
<a name="ln244">// For now, table_desc is allocated as ScopedPtr and cached in the memory context. The table_desc</a>
<a name="ln245">// would then be destructed when the context is destroyed.</a>
<a name="ln246">Status PgApiImpl::AddToCurrentPgMemctx(size_t table_desc_id,</a>
<a name="ln247">                                       const PgTableDesc::ScopedRefPtr &amp;table_desc) {</a>
<a name="ln248">  pg_callbacks_.GetCurrentYbMemctx()-&gt;Cache(table_desc_id, table_desc);</a>
<a name="ln249">  return Status::OK();</a>
<a name="ln250">}</a>
<a name="ln251"> </a>
<a name="ln252">Status PgApiImpl::GetTabledescFromCurrentPgMemctx(size_t table_desc_id, PgTableDesc **handle) {</a>
<a name="ln253">  pg_callbacks_.GetCurrentYbMemctx()-&gt;GetCache(table_desc_id, handle);</a>
<a name="ln254">  return Status::OK();</a>
<a name="ln255">}</a>
<a name="ln256"> </a>
<a name="ln257">//--------------------------------------------------------------------------------------------------</a>
<a name="ln258"> </a>
<a name="ln259">Status PgApiImpl::CreateSequencesDataTable() {</a>
<a name="ln260">  return pg_session_-&gt;CreateSequencesDataTable();</a>
<a name="ln261">}</a>
<a name="ln262"> </a>
<a name="ln263">Status PgApiImpl::InsertSequenceTuple(int64_t db_oid,</a>
<a name="ln264">                                      int64_t seq_oid,</a>
<a name="ln265">                                      uint64_t ysql_catalog_version,</a>
<a name="ln266">                                      int64_t last_val,</a>
<a name="ln267">                                      bool is_called) {</a>
<a name="ln268">  return pg_session_-&gt;InsertSequenceTuple(</a>
<a name="ln269">      db_oid, seq_oid, ysql_catalog_version, last_val, is_called);</a>
<a name="ln270">}</a>
<a name="ln271"> </a>
<a name="ln272">Status PgApiImpl::UpdateSequenceTupleConditionally(int64_t db_oid,</a>
<a name="ln273">                                                   int64_t seq_oid,</a>
<a name="ln274">                                                   uint64_t ysql_catalog_version,</a>
<a name="ln275">                                                   int64_t last_val,</a>
<a name="ln276">                                                   bool is_called,</a>
<a name="ln277">                                                   int64_t expected_last_val,</a>
<a name="ln278">                                                   bool expected_is_called,</a>
<a name="ln279">                                                   bool *skipped) {</a>
<a name="ln280">  return pg_session_-&gt;UpdateSequenceTuple(</a>
<a name="ln281">      db_oid, seq_oid, ysql_catalog_version, last_val, is_called,</a>
<a name="ln282">      expected_last_val, expected_is_called, skipped);</a>
<a name="ln283">}</a>
<a name="ln284"> </a>
<a name="ln285">Status PgApiImpl::UpdateSequenceTuple(int64_t db_oid,</a>
<a name="ln286">                                      int64_t seq_oid,</a>
<a name="ln287">                                      uint64_t ysql_catalog_version,</a>
<a name="ln288">                                      int64_t last_val,</a>
<a name="ln289">                                      bool is_called,</a>
<a name="ln290">                                      bool* skipped) {</a>
<a name="ln291">  return pg_session_-&gt;UpdateSequenceTuple(</a>
<a name="ln292">      db_oid, seq_oid, ysql_catalog_version, last_val,</a>
<a name="ln293">      is_called, boost::none, boost::none, skipped);</a>
<a name="ln294">}</a>
<a name="ln295"> </a>
<a name="ln296">Status PgApiImpl::ReadSequenceTuple(int64_t db_oid,</a>
<a name="ln297">                                    int64_t seq_oid,</a>
<a name="ln298">                                    uint64_t ysql_catalog_version,</a>
<a name="ln299">                                    int64_t *last_val,</a>
<a name="ln300">                                    bool *is_called) {</a>
<a name="ln301">  return pg_session_-&gt;ReadSequenceTuple(db_oid, seq_oid, ysql_catalog_version, last_val, is_called);</a>
<a name="ln302">}</a>
<a name="ln303"> </a>
<a name="ln304">Status PgApiImpl::DeleteSequenceTuple(int64_t db_oid, int64_t seq_oid) {</a>
<a name="ln305">  return pg_session_-&gt;DeleteSequenceTuple(db_oid, seq_oid);</a>
<a name="ln306">}</a>
<a name="ln307"> </a>
<a name="ln308"> </a>
<a name="ln309">//--------------------------------------------------------------------------------------------------</a>
<a name="ln310"> </a>
<a name="ln311">Status PgApiImpl::ClearBinds(PgStatement *handle) {</a>
<a name="ln312">  return handle-&gt;ClearBinds();</a>
<a name="ln313">}</a>
<a name="ln314"> </a>
<a name="ln315">//--------------------------------------------------------------------------------------------------</a>
<a name="ln316"> </a>
<a name="ln317">Status PgApiImpl::ConnectDatabase(const char *database_name) {</a>
<a name="ln318">  return pg_session_-&gt;ConnectDatabase(database_name);</a>
<a name="ln319">}</a>
<a name="ln320"> </a>
<a name="ln321">Status PgApiImpl::IsDatabaseColocated(const PgOid database_oid, bool *colocated) {</a>
<a name="ln322">  return pg_session_-&gt;IsDatabaseColocated(database_oid, colocated);</a>
<a name="ln323">}</a>
<a name="ln324"> </a>
<a name="ln325">Status PgApiImpl::NewCreateDatabase(const char *database_name,</a>
<a name="ln326">                                    const PgOid database_oid,</a>
<a name="ln327">                                    const PgOid source_database_oid,</a>
<a name="ln328">                                    const PgOid next_oid,</a>
<a name="ln329">                                    const bool colocated,</a>
<a name="ln330">                                    PgStatement **handle) {</a>
<a name="ln331">  auto stmt = make_scoped_refptr&lt;PgCreateDatabase&gt;(pg_session_, database_name, database_oid,</a>
<a name="ln332">                                                   source_database_oid, next_oid, colocated);</a>
<a name="ln333">  RETURN_NOT_OK(AddToCurrentPgMemctx(stmt, handle));</a>
<a name="ln334">  return Status::OK();</a>
<a name="ln335">}</a>
<a name="ln336"> </a>
<a name="ln337">Status PgApiImpl::ExecCreateDatabase(PgStatement *handle) {</a>
<a name="ln338">  if (!PgStatement::IsValidStmt(handle, StmtOp::STMT_CREATE_DATABASE)) {</a>
<a name="ln339">    // Invalid handle.</a>
<a name="ln340">    return STATUS(InvalidArgument, &quot;Invalid statement handle&quot;);</a>
<a name="ln341">  }</a>
<a name="ln342"> </a>
<a name="ln343">  return down_cast&lt;PgCreateDatabase*&gt;(handle)-&gt;Exec();</a>
<a name="ln344">}</a>
<a name="ln345"> </a>
<a name="ln346">Status PgApiImpl::NewDropDatabase(const char *database_name,</a>
<a name="ln347">                                  PgOid database_oid,</a>
<a name="ln348">                                  PgStatement **handle) {</a>
<a name="ln349">  auto stmt = make_scoped_refptr&lt;PgDropDatabase&gt;(pg_session_, database_name, database_oid);</a>
<a name="ln350">  RETURN_NOT_OK(AddToCurrentPgMemctx(stmt, handle));</a>
<a name="ln351">  return Status::OK();</a>
<a name="ln352">}</a>
<a name="ln353"> </a>
<a name="ln354">Status PgApiImpl::ExecDropDatabase(PgStatement *handle) {</a>
<a name="ln355">  if (!PgStatement::IsValidStmt(handle, StmtOp::STMT_DROP_DATABASE)) {</a>
<a name="ln356">    // Invalid handle.</a>
<a name="ln357">    return STATUS(InvalidArgument, &quot;Invalid statement handle&quot;);</a>
<a name="ln358">  }</a>
<a name="ln359">  return down_cast&lt;PgDropDatabase*&gt;(handle)-&gt;Exec();</a>
<a name="ln360">}</a>
<a name="ln361"> </a>
<a name="ln362">Status PgApiImpl::NewAlterDatabase(const char *database_name,</a>
<a name="ln363">                                  PgOid database_oid,</a>
<a name="ln364">                                  PgStatement **handle) {</a>
<a name="ln365">  auto stmt = make_scoped_refptr&lt;PgAlterDatabase&gt;(pg_session_, database_name, database_oid);</a>
<a name="ln366">  RETURN_NOT_OK(AddToCurrentPgMemctx(stmt, handle));</a>
<a name="ln367">  return Status::OK();</a>
<a name="ln368">}</a>
<a name="ln369"> </a>
<a name="ln370">Status PgApiImpl::AlterDatabaseRenameDatabase(PgStatement *handle, const char *newname) {</a>
<a name="ln371">  if (!PgStatement::IsValidStmt(handle, StmtOp::STMT_ALTER_DATABASE)) {</a>
<a name="ln372">    // Invalid handle.</a>
<a name="ln373">    return STATUS(InvalidArgument, &quot;Invalid statement handle&quot;);</a>
<a name="ln374">  }</a>
<a name="ln375">  return down_cast&lt;PgAlterDatabase*&gt;(handle)-&gt;RenameDatabase(newname);</a>
<a name="ln376">}</a>
<a name="ln377"> </a>
<a name="ln378">Status PgApiImpl::ExecAlterDatabase(PgStatement *handle) {</a>
<a name="ln379">  if (!PgStatement::IsValidStmt(handle, StmtOp::STMT_ALTER_DATABASE)) {</a>
<a name="ln380">    // Invalid handle.</a>
<a name="ln381">    return STATUS(InvalidArgument, &quot;Invalid statement handle&quot;);</a>
<a name="ln382">  }</a>
<a name="ln383">  return down_cast&lt;PgAlterDatabase*&gt;(handle)-&gt;Exec();</a>
<a name="ln384">}</a>
<a name="ln385"> </a>
<a name="ln386">Status PgApiImpl::ReserveOids(const PgOid database_oid,</a>
<a name="ln387">                              const PgOid next_oid,</a>
<a name="ln388">                              const uint32_t count,</a>
<a name="ln389">                              PgOid *begin_oid,</a>
<a name="ln390">                              PgOid *end_oid) {</a>
<a name="ln391">  return pg_session_-&gt;ReserveOids(database_oid, next_oid, count, begin_oid, end_oid);</a>
<a name="ln392">}</a>
<a name="ln393"> </a>
<a name="ln394">Status PgApiImpl::GetCatalogMasterVersion(uint64_t *version) {</a>
<a name="ln395">  return pg_session_-&gt;GetCatalogMasterVersion(version);</a>
<a name="ln396">}</a>
<a name="ln397"> </a>
<a name="ln398">Result&lt;PgTableDesc::ScopedRefPtr&gt; PgApiImpl::LoadTable(const PgObjectId&amp; table_id) {</a>
<a name="ln399">  return pg_session_-&gt;LoadTable(table_id);</a>
<a name="ln400">}</a>
<a name="ln401"> </a>
<a name="ln402">void PgApiImpl::InvalidateTableCache(const PgObjectId&amp; table_id) {</a>
<a name="ln403">  pg_session_-&gt;InvalidateTableCache(table_id);</a>
<a name="ln404">}</a>
<a name="ln405"> </a>
<a name="ln406">//--------------------------------------------------------------------------------------------------</a>
<a name="ln407"> </a>
<a name="ln408">Status PgApiImpl::NewCreateTablegroup(const char *database_name,</a>
<a name="ln409">                                      const PgOid database_oid,</a>
<a name="ln410">                                      const PgOid tablegroup_oid,</a>
<a name="ln411">                                      PgStatement **handle) {</a>
<a name="ln412">  auto stmt = make_scoped_refptr&lt;PgCreateTablegroup&gt;(pg_session_, database_name,</a>
<a name="ln413">                                                     database_oid, tablegroup_oid);</a>
<a name="ln414">  RETURN_NOT_OK(AddToCurrentPgMemctx(stmt, handle));</a>
<a name="ln415">  return Status::OK();</a>
<a name="ln416">}</a>
<a name="ln417"> </a>
<a name="ln418">Status PgApiImpl::ExecCreateTablegroup(PgStatement *handle) {</a>
<a name="ln419">  if (!PgStatement::IsValidStmt(handle, StmtOp::STMT_CREATE_TABLEGROUP)) {</a>
<a name="ln420">    // Invalid handle.</a>
<a name="ln421">    return STATUS(InvalidArgument, &quot;Invalid statement handle&quot;);</a>
<a name="ln422">  }</a>
<a name="ln423"> </a>
<a name="ln424">  return down_cast&lt;PgCreateTablegroup*&gt;(handle)-&gt;Exec();</a>
<a name="ln425">}</a>
<a name="ln426"> </a>
<a name="ln427">Status PgApiImpl::NewDropTablegroup(const PgOid database_oid,</a>
<a name="ln428">                                    const PgOid tablegroup_oid,</a>
<a name="ln429">                                    PgStatement **handle) {</a>
<a name="ln430">  auto stmt = make_scoped_refptr&lt;PgDropTablegroup&gt;(pg_session_, database_oid, tablegroup_oid);</a>
<a name="ln431">  RETURN_NOT_OK(AddToCurrentPgMemctx(stmt, handle));</a>
<a name="ln432">  return Status::OK();</a>
<a name="ln433">}</a>
<a name="ln434"> </a>
<a name="ln435"> </a>
<a name="ln436">Status PgApiImpl::ExecDropTablegroup(PgStatement *handle) {</a>
<a name="ln437">  if (!PgStatement::IsValidStmt(handle, StmtOp::STMT_DROP_TABLEGROUP)) {</a>
<a name="ln438">    // Invalid handle.</a>
<a name="ln439">    return STATUS(InvalidArgument, &quot;Invalid statement handle&quot;);</a>
<a name="ln440">  }</a>
<a name="ln441">  return down_cast&lt;PgDropTablegroup*&gt;(handle)-&gt;Exec();</a>
<a name="ln442">}</a>
<a name="ln443"> </a>
<a name="ln444"> </a>
<a name="ln445">//--------------------------------------------------------------------------------------------------</a>
<a name="ln446"> </a>
<a name="ln447">Status PgApiImpl::NewCreateTable(const char *database_name,</a>
<a name="ln448">                                 const char *schema_name,</a>
<a name="ln449">                                 const char *table_name,</a>
<a name="ln450">                                 const PgObjectId&amp; table_id,</a>
<a name="ln451">                                 bool is_shared_table,</a>
<a name="ln452">                                 bool if_not_exist,</a>
<a name="ln453">                                 bool add_primary_key,</a>
<a name="ln454">                                 const bool colocated,</a>
<a name="ln455">                                 const PgObjectId&amp; tablegroup_oid,</a>
<a name="ln456">                                 PgStatement **handle) {</a>
<a name="ln457">  auto stmt = make_scoped_refptr&lt;PgCreateTable&gt;(</a>
<a name="ln458">      pg_session_, database_name, schema_name, table_name,</a>
<a name="ln459">      table_id, is_shared_table, if_not_exist, add_primary_key, colocated, tablegroup_oid);</a>
<a name="ln460">  RETURN_NOT_OK(AddToCurrentPgMemctx(stmt, handle));</a>
<a name="ln461">  return Status::OK();</a>
<a name="ln462">}</a>
<a name="ln463"> </a>
<a name="ln464">Status PgApiImpl::CreateTableAddColumn(PgStatement *handle, const char *attr_name, int attr_num,</a>
<a name="ln465">                                       const YBCPgTypeEntity *attr_type,</a>
<a name="ln466">                                       bool is_hash, bool is_range,</a>
<a name="ln467">                                       bool is_desc, bool is_nulls_first) {</a>
<a name="ln468">  if (!PgStatement::IsValidStmt(handle, StmtOp::STMT_CREATE_TABLE)) {</a>
<a name="ln469">    // Invalid handle.</a>
<a name="ln470">    return STATUS(InvalidArgument, &quot;Invalid statement handle&quot;);</a>
<a name="ln471">  }</a>
<a name="ln472">  return AddColumn(down_cast&lt;PgCreateTable*&gt;(handle), attr_name, attr_num, attr_type,</a>
<a name="ln473">      is_hash, is_range, is_desc, is_nulls_first);</a>
<a name="ln474">}</a>
<a name="ln475"> </a>
<a name="ln476">Status PgApiImpl::CreateTableSetNumTablets(PgStatement *handle, int32_t num_tablets) {</a>
<a name="ln477">  if (!PgStatement::IsValidStmt(handle, StmtOp::STMT_CREATE_TABLE)) {</a>
<a name="ln478">    // Invalid handle.</a>
<a name="ln479">    return STATUS(InvalidArgument, &quot;Invalid statement handle&quot;);</a>
<a name="ln480">  }</a>
<a name="ln481">  return down_cast&lt;PgCreateTable*&gt;(handle)-&gt;SetNumTablets(num_tablets);</a>
<a name="ln482">}</a>
<a name="ln483"> </a>
<a name="ln484">Status PgApiImpl::CreateTableAddSplitRow(PgStatement *handle, int num_cols,</a>
<a name="ln485">                                           YBCPgTypeEntity **types, uint64_t *data) {</a>
<a name="ln486">  if (!PgStatement::IsValidStmt(handle, StmtOp::STMT_CREATE_TABLE)) {</a>
<a name="ln487">    // Invalid handle.</a>
<a name="ln488">    return STATUS(InvalidArgument, &quot;Invalid statement handle&quot;);</a>
<a name="ln489">  }</a>
<a name="ln490">  return down_cast&lt;PgCreateTable*&gt;(handle)-&gt;AddSplitRow(num_cols, types, data);</a>
<a name="ln491">}</a>
<a name="ln492"> </a>
<a name="ln493">Status PgApiImpl::ExecCreateTable(PgStatement *handle) {</a>
<a name="ln494">  if (!PgStatement::IsValidStmt(handle, StmtOp::STMT_CREATE_TABLE)) {</a>
<a name="ln495">    // Invalid handle.</a>
<a name="ln496">    return STATUS(InvalidArgument, &quot;Invalid statement handle&quot;);</a>
<a name="ln497">  }</a>
<a name="ln498">  return down_cast&lt;PgCreateTable*&gt;(handle)-&gt;Exec();</a>
<a name="ln499">}</a>
<a name="ln500"> </a>
<a name="ln501">Status PgApiImpl::NewAlterTable(const PgObjectId&amp; table_id,</a>
<a name="ln502">                                PgStatement **handle) {</a>
<a name="ln503">  auto stmt = make_scoped_refptr&lt;PgAlterTable&gt;(pg_session_, table_id);</a>
<a name="ln504">  RETURN_NOT_OK(AddToCurrentPgMemctx(stmt, handle));</a>
<a name="ln505">  return Status::OK();</a>
<a name="ln506">}</a>
<a name="ln507"> </a>
<a name="ln508">Status PgApiImpl::AlterTableAddColumn(PgStatement *handle, const char *name,</a>
<a name="ln509">                                      int order, const YBCPgTypeEntity *attr_type,</a>
<a name="ln510">                                      bool is_not_null) {</a>
<a name="ln511">  if (!PgStatement::IsValidStmt(handle, StmtOp::STMT_ALTER_TABLE)) {</a>
<a name="ln512">    // Invalid handle.</a>
<a name="ln513">    return STATUS(InvalidArgument, &quot;Invalid statement handle&quot;);</a>
<a name="ln514">  }</a>
<a name="ln515"> </a>
<a name="ln516">  PgAlterTable *pg_stmt = down_cast&lt;PgAlterTable*&gt;(handle);</a>
<a name="ln517">  return pg_stmt-&gt;AddColumn(name, attr_type, order, is_not_null);</a>
<a name="ln518">}</a>
<a name="ln519"> </a>
<a name="ln520">Status PgApiImpl::AlterTableRenameColumn(PgStatement *handle, const char *oldname,</a>
<a name="ln521">                                         const char *newname) {</a>
<a name="ln522">  if (!PgStatement::IsValidStmt(handle, StmtOp::STMT_ALTER_TABLE)) {</a>
<a name="ln523">    // Invalid handle.</a>
<a name="ln524">    return STATUS(InvalidArgument, &quot;Invalid statement handle&quot;);</a>
<a name="ln525">  }</a>
<a name="ln526"> </a>
<a name="ln527">  PgAlterTable *pg_stmt = down_cast&lt;PgAlterTable*&gt;(handle);</a>
<a name="ln528">  return pg_stmt-&gt;RenameColumn(oldname, newname);</a>
<a name="ln529">}</a>
<a name="ln530"> </a>
<a name="ln531">Status PgApiImpl::AlterTableDropColumn(PgStatement *handle, const char *name) {</a>
<a name="ln532">  if (!PgStatement::IsValidStmt(handle, StmtOp::STMT_ALTER_TABLE)) {</a>
<a name="ln533">    // Invalid handle.</a>
<a name="ln534">    return STATUS(InvalidArgument, &quot;Invalid statement handle&quot;);</a>
<a name="ln535">  }</a>
<a name="ln536"> </a>
<a name="ln537">  PgAlterTable *pg_stmt = down_cast&lt;PgAlterTable*&gt;(handle);</a>
<a name="ln538">  return pg_stmt-&gt;DropColumn(name);</a>
<a name="ln539">}</a>
<a name="ln540"> </a>
<a name="ln541">Status PgApiImpl::AlterTableRenameTable(PgStatement *handle, const char *db_name,</a>
<a name="ln542">                                        const char *newname) {</a>
<a name="ln543">  if (!PgStatement::IsValidStmt(handle, StmtOp::STMT_ALTER_TABLE)) {</a>
<a name="ln544">    // Invalid handle.</a>
<a name="ln545">    return STATUS(InvalidArgument, &quot;Invalid statement handle&quot;);</a>
<a name="ln546">  }</a>
<a name="ln547"> </a>
<a name="ln548">  PgAlterTable *pg_stmt = down_cast&lt;PgAlterTable*&gt;(handle);</a>
<a name="ln549">  return pg_stmt-&gt;RenameTable(db_name, newname);</a>
<a name="ln550">}</a>
<a name="ln551"> </a>
<a name="ln552">Status PgApiImpl::ExecAlterTable(PgStatement *handle) {</a>
<a name="ln553">  if (!PgStatement::IsValidStmt(handle, StmtOp::STMT_ALTER_TABLE)) {</a>
<a name="ln554">    // Invalid handle.</a>
<a name="ln555">    return STATUS(InvalidArgument, &quot;Invalid statement handle&quot;);</a>
<a name="ln556">  }</a>
<a name="ln557">  PgAlterTable *pg_stmt = down_cast&lt;PgAlterTable*&gt;(handle);</a>
<a name="ln558">  return pg_stmt-&gt;Exec();</a>
<a name="ln559">}</a>
<a name="ln560"> </a>
<a name="ln561">Status PgApiImpl::NewDropTable(const PgObjectId&amp; table_id,</a>
<a name="ln562">                               bool if_exist,</a>
<a name="ln563">                               PgStatement **handle) {</a>
<a name="ln564">  auto stmt = make_scoped_refptr&lt;PgDropTable&gt;(pg_session_, table_id, if_exist);</a>
<a name="ln565">  RETURN_NOT_OK(AddToCurrentPgMemctx(stmt, handle));</a>
<a name="ln566">  return Status::OK();</a>
<a name="ln567">}</a>
<a name="ln568"> </a>
<a name="ln569">Status PgApiImpl::ExecDropTable(PgStatement *handle) {</a>
<a name="ln570">  if (!PgStatement::IsValidStmt(handle, StmtOp::STMT_DROP_TABLE)) {</a>
<a name="ln571">    // Invalid handle.</a>
<a name="ln572">    return STATUS(InvalidArgument, &quot;Invalid statement handle&quot;);</a>
<a name="ln573">  }</a>
<a name="ln574">  return down_cast&lt;PgDropTable*&gt;(handle)-&gt;Exec();</a>
<a name="ln575">}</a>
<a name="ln576"> </a>
<a name="ln577">Status PgApiImpl::NewTruncateTable(const PgObjectId&amp; table_id,</a>
<a name="ln578">                                   PgStatement **handle) {</a>
<a name="ln579">  auto stmt = make_scoped_refptr&lt;PgTruncateTable&gt;(pg_session_, table_id);</a>
<a name="ln580">  RETURN_NOT_OK(AddToCurrentPgMemctx(stmt, handle));</a>
<a name="ln581">  return Status::OK();</a>
<a name="ln582">}</a>
<a name="ln583"> </a>
<a name="ln584">Status PgApiImpl::ExecTruncateTable(PgStatement *handle) {</a>
<a name="ln585">  if (!PgStatement::IsValidStmt(handle, StmtOp::STMT_TRUNCATE_TABLE)) {</a>
<a name="ln586">    // Invalid handle.</a>
<a name="ln587">    return STATUS(InvalidArgument, &quot;Invalid statement handle&quot;);</a>
<a name="ln588">  }</a>
<a name="ln589">  return down_cast&lt;PgTruncateTable*&gt;(handle)-&gt;Exec();</a>
<a name="ln590">}</a>
<a name="ln591"> </a>
<a name="ln592">Status PgApiImpl::GetTableDesc(const PgObjectId&amp; table_id,</a>
<a name="ln593">                               PgTableDesc **handle) {</a>
<a name="ln594">  // First read from memory context.</a>
<a name="ln595">  size_t hash_id = hash_value(table_id);</a>
<a name="ln596">  RETURN_NOT_OK(GetTabledescFromCurrentPgMemctx(hash_id, handle));</a>
<a name="ln597"> </a>
<a name="ln598">  // Read from environment.</a>
<a name="ln599">  if (*handle == nullptr) {</a>
<a name="ln600">    auto result = pg_session_-&gt;LoadTable(table_id);</a>
<a name="ln601">    RETURN_NOT_OK(result);</a>
<a name="ln602">    RETURN_NOT_OK(AddToCurrentPgMemctx(hash_id, *result));</a>
<a name="ln603"> </a>
<a name="ln604">    *handle = result-&gt;get();</a>
<a name="ln605">  }</a>
<a name="ln606"> </a>
<a name="ln607">  return Status::OK();</a>
<a name="ln608">}</a>
<a name="ln609"> </a>
<a name="ln610">Status PgApiImpl::GetColumnInfo(YBCPgTableDesc table_desc,</a>
<a name="ln611">                                int16_t attr_number,</a>
<a name="ln612">                                bool *is_primary,</a>
<a name="ln613">                                bool *is_hash) {</a>
<a name="ln614">  return table_desc-&gt;GetColumnInfo(attr_number, is_primary, is_hash);</a>
<a name="ln615">}</a>
<a name="ln616"> </a>
<a name="ln617">Status PgApiImpl::DmlModifiesRow(PgStatement *handle, bool *modifies_row) {</a>
<a name="ln618">  if (!handle) {</a>
<a name="ln619">    return STATUS(InvalidArgument, &quot;Invalid statement handle&quot;);</a>
<a name="ln620">  }</a>
<a name="ln621"> </a>
<a name="ln622">  *modifies_row = false;</a>
<a name="ln623"> </a>
<a name="ln624">  switch (handle-&gt;stmt_op()) {</a>
<a name="ln625">    case StmtOp::STMT_UPDATE:</a>
<a name="ln626">    case StmtOp::STMT_DELETE:</a>
<a name="ln627">      *modifies_row = true;</a>
<a name="ln628">      break;</a>
<a name="ln629">    default:</a>
<a name="ln630">      break;</a>
<a name="ln631">  }</a>
<a name="ln632"> </a>
<a name="ln633">  return Status::OK();</a>
<a name="ln634">}</a>
<a name="ln635"> </a>
<a name="ln636">Status PgApiImpl::SetIsSysCatalogVersionChange(PgStatement *handle) {</a>
<a name="ln637">  if (!handle) {</a>
<a name="ln638">    return STATUS(InvalidArgument, &quot;Invalid statement handle&quot;);</a>
<a name="ln639">  }</a>
<a name="ln640"> </a>
<a name="ln641">  switch (handle-&gt;stmt_op()) {</a>
<a name="ln642">    case StmtOp::STMT_UPDATE:</a>
<a name="ln643">    case StmtOp::STMT_DELETE:</a>
<a name="ln644">    case StmtOp::STMT_INSERT:</a>
<a name="ln645">      down_cast&lt;PgDmlWrite *&gt;(handle)-&gt;SetIsSystemCatalogChange();</a>
<a name="ln646">      return Status::OK();</a>
<a name="ln647">    default:</a>
<a name="ln648">      break;</a>
<a name="ln649">  }</a>
<a name="ln650"> </a>
<a name="ln651">  return STATUS(InvalidArgument, &quot;Invalid statement handle&quot;);</a>
<a name="ln652">}</a>
<a name="ln653"> </a>
<a name="ln654">Status PgApiImpl::SetCatalogCacheVersion(PgStatement *handle, uint64_t catalog_cache_version) {</a>
<a name="ln655">  if (!handle) {</a>
<a name="ln656">    return STATUS(InvalidArgument, &quot;Invalid statement handle&quot;);</a>
<a name="ln657">  }</a>
<a name="ln658"> </a>
<a name="ln659">  switch (handle-&gt;stmt_op()) {</a>
<a name="ln660">    case StmtOp::STMT_SELECT:</a>
<a name="ln661">    case StmtOp::STMT_INSERT:</a>
<a name="ln662">    case StmtOp::STMT_UPDATE:</a>
<a name="ln663">    case StmtOp::STMT_DELETE:</a>
<a name="ln664">      down_cast&lt;PgDml *&gt;(handle)-&gt;SetCatalogCacheVersion(catalog_cache_version);</a>
<a name="ln665">      return Status::OK();</a>
<a name="ln666">    default:</a>
<a name="ln667">      break;</a>
<a name="ln668">  }</a>
<a name="ln669"> </a>
<a name="ln670">  return STATUS(InvalidArgument, &quot;Invalid statement handle&quot;);</a>
<a name="ln671">}</a>
<a name="ln672"> </a>
<a name="ln673">//--------------------------------------------------------------------------------------------------</a>
<a name="ln674"> </a>
<a name="ln675">Status PgApiImpl::NewCreateIndex(const char *database_name,</a>
<a name="ln676">                                 const char *schema_name,</a>
<a name="ln677">                                 const char *index_name,</a>
<a name="ln678">                                 const PgObjectId&amp; index_id,</a>
<a name="ln679">                                 const PgObjectId&amp; base_table_id,</a>
<a name="ln680">                                 bool is_shared_index,</a>
<a name="ln681">                                 bool is_unique_index,</a>
<a name="ln682">                                 const bool skip_index_backfill,</a>
<a name="ln683">                                 bool if_not_exist,</a>
<a name="ln684">                                 const PgObjectId&amp; tablegroup_oid,</a>
<a name="ln685">                                 PgStatement **handle) {</a>
<a name="ln686">  auto stmt = make_scoped_refptr&lt;PgCreateIndex&gt;(</a>
<a name="ln687">      pg_session_, database_name, schema_name, index_name, index_id, base_table_id,</a>
<a name="ln688">      is_shared_index, is_unique_index, skip_index_backfill, if_not_exist, tablegroup_oid);</a>
<a name="ln689">  RETURN_NOT_OK(AddToCurrentPgMemctx(stmt, handle));</a>
<a name="ln690">  return Status::OK();</a>
<a name="ln691">}</a>
<a name="ln692"> </a>
<a name="ln693">Status PgApiImpl::CreateIndexAddColumn(PgStatement *handle, const char *attr_name, int attr_num,</a>
<a name="ln694">                                       const YBCPgTypeEntity *attr_type,</a>
<a name="ln695">                                       bool is_hash, bool is_range,</a>
<a name="ln696">                                       bool is_desc, bool is_nulls_first) {</a>
<a name="ln697">  if (!PgStatement::IsValidStmt(handle, StmtOp::STMT_CREATE_INDEX)) {</a>
<a name="ln698">    // Invalid handle.</a>
<a name="ln699">    return STATUS(InvalidArgument, &quot;Invalid statement handle&quot;);</a>
<a name="ln700">  }</a>
<a name="ln701"> </a>
<a name="ln702">  return AddColumn(down_cast&lt;PgCreateIndex*&gt;(handle), attr_name, attr_num, attr_type,</a>
<a name="ln703">      is_hash, is_range, is_desc, is_nulls_first);</a>
<a name="ln704">}</a>
<a name="ln705"> </a>
<a name="ln706">Status PgApiImpl::CreateIndexSetNumTablets(PgStatement *handle, int32_t num_tablets) {</a>
<a name="ln707">  SCHECK(PgStatement::IsValidStmt(handle, StmtOp::STMT_CREATE_INDEX),</a>
<a name="ln708">         InvalidArgument,</a>
<a name="ln709">         &quot;Invalid statement handle&quot;);</a>
<a name="ln710">  return down_cast&lt;PgCreateIndex*&gt;(handle)-&gt;SetNumTablets(num_tablets);</a>
<a name="ln711">}</a>
<a name="ln712"> </a>
<a name="ln713">Status PgApiImpl::CreateIndexAddSplitRow(PgStatement *handle, int num_cols,</a>
<a name="ln714">                                         YBCPgTypeEntity **types, uint64_t *data) {</a>
<a name="ln715">  SCHECK(PgStatement::IsValidStmt(handle, StmtOp::STMT_CREATE_INDEX),</a>
<a name="ln716">      InvalidArgument,</a>
<a name="ln717">      &quot;Invalid statement handle&quot;);</a>
<a name="ln718">  return down_cast&lt;PgCreateIndex*&gt;(handle)-&gt;AddSplitRow(num_cols, types, data);</a>
<a name="ln719">}</a>
<a name="ln720"> </a>
<a name="ln721">Status PgApiImpl::ExecCreateIndex(PgStatement *handle) {</a>
<a name="ln722">  if (!PgStatement::IsValidStmt(handle, StmtOp::STMT_CREATE_INDEX)) {</a>
<a name="ln723">    // Invalid handle.</a>
<a name="ln724">    return STATUS(InvalidArgument, &quot;Invalid statement handle&quot;);</a>
<a name="ln725">  }</a>
<a name="ln726">  return down_cast&lt;PgCreateIndex*&gt;(handle)-&gt;Exec();</a>
<a name="ln727">}</a>
<a name="ln728"> </a>
<a name="ln729">Status PgApiImpl::NewDropIndex(const PgObjectId&amp; index_id,</a>
<a name="ln730">                               bool if_exist,</a>
<a name="ln731">                               PgStatement **handle) {</a>
<a name="ln732">  auto stmt = make_scoped_refptr&lt;PgDropIndex&gt;(pg_session_, index_id, if_exist);</a>
<a name="ln733">  RETURN_NOT_OK(AddToCurrentPgMemctx(stmt, handle));</a>
<a name="ln734">  return Status::OK();</a>
<a name="ln735">}</a>
<a name="ln736"> </a>
<a name="ln737">Status PgApiImpl::ExecDropIndex(PgStatement *handle) {</a>
<a name="ln738">  if (!PgStatement::IsValidStmt(handle, StmtOp::STMT_DROP_INDEX)) {</a>
<a name="ln739">    // Invalid handle.</a>
<a name="ln740">    return STATUS(InvalidArgument, &quot;Invalid statement handle&quot;);</a>
<a name="ln741">  }</a>
<a name="ln742">  return down_cast&lt;PgDropIndex*&gt;(handle)-&gt;Exec();</a>
<a name="ln743">}</a>
<a name="ln744"> </a>
<a name="ln745">Result&lt;IndexPermissions&gt; PgApiImpl::WaitUntilIndexPermissionsAtLeast(</a>
<a name="ln746">    const PgObjectId&amp; table_id,</a>
<a name="ln747">    const PgObjectId&amp; index_id,</a>
<a name="ln748">    const IndexPermissions&amp; target_index_permissions) {</a>
<a name="ln749">  return pg_session_-&gt;WaitUntilIndexPermissionsAtLeast(</a>
<a name="ln750">      table_id,</a>
<a name="ln751">      index_id,</a>
<a name="ln752">      target_index_permissions);</a>
<a name="ln753">}</a>
<a name="ln754"> </a>
<a name="ln755">Status PgApiImpl::AsyncUpdateIndexPermissions(const PgObjectId&amp; indexed_table_id) {</a>
<a name="ln756">  return pg_session_-&gt;AsyncUpdateIndexPermissions(indexed_table_id);</a>
<a name="ln757">}</a>
<a name="ln758"> </a>
<a name="ln759">//--------------------------------------------------------------------------------------------------</a>
<a name="ln760">// DML Statment Support.</a>
<a name="ln761">//--------------------------------------------------------------------------------------------------</a>
<a name="ln762"> </a>
<a name="ln763">// Binding -----------------------------------------------------------------------------------------</a>
<a name="ln764"> </a>
<a name="ln765">Status PgApiImpl::DmlAppendTarget(PgStatement *handle, PgExpr *target) {</a>
<a name="ln766">  return down_cast&lt;PgDml*&gt;(handle)-&gt;AppendTarget(target);</a>
<a name="ln767">}</a>
<a name="ln768"> </a>
<a name="ln769">Status PgApiImpl::DmlBindColumn(PgStatement *handle, int attr_num, PgExpr *attr_value) {</a>
<a name="ln770">  return down_cast&lt;PgDml*&gt;(handle)-&gt;BindColumn(attr_num, attr_value);</a>
<a name="ln771">}</a>
<a name="ln772"> </a>
<a name="ln773">Status PgApiImpl::DmlBindColumnCondEq(PgStatement *handle, int attr_num, PgExpr *attr_value) {</a>
<a name="ln774">  return down_cast&lt;PgDmlRead*&gt;(handle)-&gt;BindColumnCondEq(attr_num, attr_value);</a>
<a name="ln775">}</a>
<a name="ln776"> </a>
<a name="ln777">Status PgApiImpl::DmlBindColumnCondBetween(PgStatement *handle, int attr_num, PgExpr *attr_value,</a>
<a name="ln778">    PgExpr *attr_value_end) {</a>
<a name="ln779">  return down_cast&lt;PgDmlRead*&gt;(handle)-&gt;BindColumnCondBetween(attr_num, attr_value, attr_value_end);</a>
<a name="ln780">}</a>
<a name="ln781"> </a>
<a name="ln782">Status PgApiImpl::DmlBindColumnCondIn(PgStatement *handle, int attr_num, int n_attr_values,</a>
<a name="ln783">    PgExpr **attr_values) {</a>
<a name="ln784">  return down_cast&lt;PgDmlRead*&gt;(handle)-&gt;BindColumnCondIn(attr_num, n_attr_values, attr_values);</a>
<a name="ln785">}</a>
<a name="ln786"> </a>
<a name="ln787">Status PgApiImpl::DmlBindTable(PgStatement *handle) {</a>
<a name="ln788">  return down_cast&lt;PgDml*&gt;(handle)-&gt;BindTable();</a>
<a name="ln789">}</a>
<a name="ln790"> </a>
<a name="ln791">CHECKED_STATUS PgApiImpl::DmlAssignColumn(PgStatement *handle, int attr_num, PgExpr *attr_value) {</a>
<a name="ln792">  return down_cast&lt;PgDml*&gt;(handle)-&gt;AssignColumn(attr_num, attr_value);</a>
<a name="ln793">}</a>
<a name="ln794"> </a>
<a name="ln795">Status PgApiImpl::DmlFetch(PgStatement *handle, int32_t natts, uint64_t *values, bool *isnulls,</a>
<a name="ln796">                           PgSysColumns *syscols, bool *has_data) {</a>
<a name="ln797">  return down_cast&lt;PgDml*&gt;(handle)-&gt;Fetch(natts, values, isnulls, syscols, has_data);</a>
<a name="ln798">}</a>
<a name="ln799"> </a>
<a name="ln800">Status PgApiImpl::DmlBuildYBTupleId(PgStatement *handle, const PgAttrValueDescriptor *attrs,</a>
<a name="ln801">                                    int32_t nattrs, uint64_t *ybctid) {</a>
<a name="ln802">  const string id = VERIFY_RESULT(down_cast&lt;PgDml*&gt;(handle)-&gt;BuildYBTupleId(attrs, nattrs));</a>
<a name="ln803">  const YBCPgTypeEntity *type_entity = FindTypeEntity(kPgByteArrayOid);</a>
<a name="ln804">  *ybctid = type_entity-&gt;yb_to_datum(id.data(), id.size(), nullptr /* type_attrs */);</a>
<a name="ln805">  return Status::OK();</a>
<a name="ln806">}</a>
<a name="ln807"> </a>
<a name="ln808">void PgApiImpl::StartOperationsBuffering() {</a>
<a name="ln809">  pg_session_-&gt;StartOperationsBuffering();</a>
<a name="ln810">}</a>
<a name="ln811"> </a>
<a name="ln812">Status PgApiImpl::StopOperationsBuffering() {</a>
<a name="ln813">  return pg_session_-&gt;StopOperationsBuffering();</a>
<a name="ln814">}</a>
<a name="ln815"> </a>
<a name="ln816">Status PgApiImpl::ResetOperationsBuffering() {</a>
<a name="ln817">  return pg_session_-&gt;ResetOperationsBuffering();</a>
<a name="ln818">}</a>
<a name="ln819"> </a>
<a name="ln820">Status PgApiImpl::FlushBufferedOperations() {</a>
<a name="ln821">  return pg_session_-&gt;FlushBufferedOperations();</a>
<a name="ln822">}</a>
<a name="ln823"> </a>
<a name="ln824">void PgApiImpl::DropBufferedOperations() {</a>
<a name="ln825">  pg_session_-&gt;DropBufferedOperations();</a>
<a name="ln826">}</a>
<a name="ln827"> </a>
<a name="ln828">Status PgApiImpl::DmlExecWriteOp(PgStatement *handle, int32_t *rows_affected_count) {</a>
<a name="ln829">  switch (handle-&gt;stmt_op()) {</a>
<a name="ln830">    case StmtOp::STMT_INSERT:</a>
<a name="ln831">    case StmtOp::STMT_UPDATE:</a>
<a name="ln832">    case StmtOp::STMT_DELETE:</a>
<a name="ln833">    case StmtOp::STMT_TRUNCATE:</a>
<a name="ln834">      {</a>
<a name="ln835">        auto dml_write = down_cast&lt;PgDmlWrite *&gt;(handle);</a>
<a name="ln836">        RETURN_NOT_OK(dml_write-&gt;Exec(rows_affected_count != nullptr /* force_non_bufferable */));</a>
<a name="ln837">        if (rows_affected_count) {</a>
<a name="ln838">          *rows_affected_count = dml_write-&gt;GetRowsAffectedCount();</a>
<a name="ln839">        }</a>
<a name="ln840">        return Status::OK();</a>
<a name="ln841">      }</a>
<a name="ln842">    default:</a>
<a name="ln843">      break;</a>
<a name="ln844">  }</a>
<a name="ln845">  return STATUS(InvalidArgument, &quot;Invalid statement handle&quot;);</a>
<a name="ln846">}</a>
<a name="ln847"> </a>
<a name="ln848">// Insert ------------------------------------------------------------------------------------------</a>
<a name="ln849"> </a>
<a name="ln850">Status PgApiImpl::NewInsert(const PgObjectId&amp; table_id,</a>
<a name="ln851">                            const bool is_single_row_txn,</a>
<a name="ln852">                            PgStatement **handle) {</a>
<a name="ln853">  *handle = nullptr;</a>
<a name="ln854">  auto stmt = make_scoped_refptr&lt;PgInsert&gt;(pg_session_, table_id, is_single_row_txn);</a>
<a name="ln855">  RETURN_NOT_OK(stmt-&gt;Prepare());</a>
<a name="ln856">  RETURN_NOT_OK(AddToCurrentPgMemctx(stmt, handle));</a>
<a name="ln857">  return Status::OK();</a>
<a name="ln858">}</a>
<a name="ln859"> </a>
<a name="ln860">Status PgApiImpl::ExecInsert(PgStatement *handle) {</a>
<a name="ln861">  if (!PgStatement::IsValidStmt(handle, StmtOp::STMT_INSERT)) {</a>
<a name="ln862">    // Invalid handle.</a>
<a name="ln863">    return STATUS(InvalidArgument, &quot;Invalid statement handle&quot;);</a>
<a name="ln864">  }</a>
<a name="ln865">  return down_cast&lt;PgInsert*&gt;(handle)-&gt;Exec();</a>
<a name="ln866">}</a>
<a name="ln867"> </a>
<a name="ln868">Status PgApiImpl::InsertStmtSetUpsertMode(PgStatement *handle) {</a>
<a name="ln869">  if (!PgStatement::IsValidStmt(handle, StmtOp::STMT_INSERT)) {</a>
<a name="ln870">    // Invalid handle.</a>
<a name="ln871">    return STATUS(InvalidArgument, &quot;Invalid statement handle&quot;);</a>
<a name="ln872">  }</a>
<a name="ln873">  down_cast&lt;PgInsert*&gt;(handle)-&gt;SetUpsertMode();</a>
<a name="ln874"> </a>
<a name="ln875">  return Status::OK();</a>
<a name="ln876">}</a>
<a name="ln877"> </a>
<a name="ln878">Status PgApiImpl::InsertStmtSetWriteTime(PgStatement *handle, const HybridTime write_time) {</a>
<a name="ln879">  if (!PgStatement::IsValidStmt(handle, StmtOp::STMT_INSERT)) {</a>
<a name="ln880">    // Invalid handle.</a>
<a name="ln881">    return STATUS(InvalidArgument, &quot;Invalid statement handle&quot;);</a>
<a name="ln882">  }</a>
<a name="ln883">  RETURN_NOT_OK(down_cast&lt;PgInsert*&gt;(handle)-&gt;SetWriteTime(write_time));</a>
<a name="ln884">  return Status::OK();</a>
<a name="ln885">}</a>
<a name="ln886"> </a>
<a name="ln887">// Update ------------------------------------------------------------------------------------------</a>
<a name="ln888"> </a>
<a name="ln889">Status PgApiImpl::NewUpdate(const PgObjectId&amp; table_id,</a>
<a name="ln890">                            const bool is_single_row_txn,</a>
<a name="ln891">                            PgStatement **handle) {</a>
<a name="ln892">  *handle = nullptr;</a>
<a name="ln893">  auto stmt = make_scoped_refptr&lt;PgUpdate&gt;(pg_session_, table_id, is_single_row_txn);</a>
<a name="ln894">  RETURN_NOT_OK(stmt-&gt;Prepare());</a>
<a name="ln895">  RETURN_NOT_OK(AddToCurrentPgMemctx(stmt, handle));</a>
<a name="ln896">  return Status::OK();</a>
<a name="ln897">}</a>
<a name="ln898"> </a>
<a name="ln899">Status PgApiImpl::ExecUpdate(PgStatement *handle) {</a>
<a name="ln900">  if (!PgStatement::IsValidStmt(handle, StmtOp::STMT_UPDATE)) {</a>
<a name="ln901">    // Invalid handle.</a>
<a name="ln902">    return STATUS(InvalidArgument, &quot;Invalid statement handle&quot;);</a>
<a name="ln903">  }</a>
<a name="ln904">  return down_cast&lt;PgUpdate*&gt;(handle)-&gt;Exec();</a>
<a name="ln905">}</a>
<a name="ln906"> </a>
<a name="ln907">// Delete ------------------------------------------------------------------------------------------</a>
<a name="ln908"> </a>
<a name="ln909">Status PgApiImpl::NewDelete(const PgObjectId&amp; table_id,</a>
<a name="ln910">                            const bool is_single_row_txn,</a>
<a name="ln911">                            PgStatement **handle) {</a>
<a name="ln912">  *handle = nullptr;</a>
<a name="ln913">  auto stmt = make_scoped_refptr&lt;PgDelete&gt;(pg_session_, table_id, is_single_row_txn);</a>
<a name="ln914">  RETURN_NOT_OK(stmt-&gt;Prepare());</a>
<a name="ln915">  RETURN_NOT_OK(AddToCurrentPgMemctx(stmt, handle));</a>
<a name="ln916">  return Status::OK();</a>
<a name="ln917">}</a>
<a name="ln918"> </a>
<a name="ln919">Status PgApiImpl::ExecDelete(PgStatement *handle) {</a>
<a name="ln920">  if (!PgStatement::IsValidStmt(handle, StmtOp::STMT_DELETE)) {</a>
<a name="ln921">    // Invalid handle.</a>
<a name="ln922">    return STATUS(InvalidArgument, &quot;Invalid statement handle&quot;);</a>
<a name="ln923">  }</a>
<a name="ln924">  return down_cast&lt;PgDelete*&gt;(handle)-&gt;Exec();</a>
<a name="ln925">}</a>
<a name="ln926"> </a>
<a name="ln927">// Colocated Truncate ------------------------------------------------------------------------------</a>
<a name="ln928"> </a>
<a name="ln929">Status PgApiImpl::NewTruncateColocated(const PgObjectId&amp; table_id,</a>
<a name="ln930">                                       const bool is_single_row_txn,</a>
<a name="ln931">                                       PgStatement **handle) {</a>
<a name="ln932">  *handle = nullptr;</a>
<a name="ln933">  auto stmt = make_scoped_refptr&lt;PgTruncateColocated&gt;(pg_session_, table_id, is_single_row_txn);</a>
<a name="ln934">  RETURN_NOT_OK(stmt-&gt;Prepare());</a>
<a name="ln935">  RETURN_NOT_OK(AddToCurrentPgMemctx(stmt, handle));</a>
<a name="ln936">  return Status::OK();</a>
<a name="ln937">}</a>
<a name="ln938"> </a>
<a name="ln939">Status PgApiImpl::ExecTruncateColocated(PgStatement *handle) {</a>
<a name="ln940">  if (!PgStatement::IsValidStmt(handle, StmtOp::STMT_TRUNCATE)) {</a>
<a name="ln941">    // Invalid handle.</a>
<a name="ln942">    return STATUS(InvalidArgument, &quot;Invalid statement handle&quot;);</a>
<a name="ln943">  }</a>
<a name="ln944">  return down_cast&lt;PgTruncateColocated*&gt;(handle)-&gt;Exec();</a>
<a name="ln945">}</a>
<a name="ln946"> </a>
<a name="ln947">// Select ------------------------------------------------------------------------------------------</a>
<a name="ln948"> </a>
<a name="ln949">Status PgApiImpl::NewSelect(const PgObjectId&amp; table_id,</a>
<a name="ln950">                            const PgObjectId&amp; index_id,</a>
<a name="ln951">                            const PgPrepareParameters *prepare_params,</a>
<a name="ln952">                            PgStatement **handle) {</a>
<a name="ln953">  // Scenarios:</a>
<a name="ln954">  // - Sequential Scan: PgSelect to read from table_id.</a>
<a name="ln955">  // - Primary Scan: PgSelect from table_id. YugaByte does not have separate table for primary key.</a>
<a name="ln956">  // - Index-Only-Scan: PgSelectIndex directly from secondary index_id.</a>
<a name="ln957">  // - IndexScan: Use PgSelectIndex to read from index_id and then PgSelect to read from table_id.</a>
<a name="ln958">  //     Note that for SysTable, only one request is send for both table_id and index_id.</a>
<a name="ln959">  *handle = nullptr;</a>
<a name="ln960">  PgDmlRead::ScopedRefPtr stmt;</a>
<a name="ln961">  if (prepare_params &amp;&amp; prepare_params-&gt;index_only_scan &amp;&amp; prepare_params-&gt;use_secondary_index) {</a>
<a name="ln962">    if (!index_id.IsValid()) {</a>
<a name="ln963">      return STATUS(InvalidArgument, &quot;Cannot run query with invalid index ID&quot;);</a>
<a name="ln964">    }</a>
<a name="ln965">    stmt = make_scoped_refptr&lt;PgSelectIndex&gt;(pg_session_, table_id, index_id, prepare_params);</a>
<a name="ln966">  } else {</a>
<a name="ln967">    // For IndexScan PgSelect processing will create subquery PgSelectIndex.</a>
<a name="ln968">    stmt = make_scoped_refptr&lt;PgSelect&gt;(pg_session_, table_id, index_id, prepare_params);</a>
<a name="ln969">  }</a>
<a name="ln970"> </a>
<a name="ln971">  RETURN_NOT_OK(stmt-&gt;Prepare());</a>
<a name="ln972">  RETURN_NOT_OK(AddToCurrentPgMemctx(stmt, handle));</a>
<a name="ln973">  return Status::OK();</a>
<a name="ln974">}</a>
<a name="ln975"> </a>
<a name="ln976">Status PgApiImpl::SetForwardScan(PgStatement *handle, bool is_forward_scan) {</a>
<a name="ln977">  if (!PgStatement::IsValidStmt(handle, StmtOp::STMT_SELECT)) {</a>
<a name="ln978">    // Invalid handle.</a>
<a name="ln979">    return STATUS(InvalidArgument, &quot;Invalid statement handle&quot;);</a>
<a name="ln980">  }</a>
<a name="ln981">  down_cast&lt;PgDmlRead*&gt;(handle)-&gt;SetForwardScan(is_forward_scan);</a>
<a name="ln982">  return Status::OK();</a>
<a name="ln983">}</a>
<a name="ln984"> </a>
<a name="ln985">Status PgApiImpl::ExecSelect(PgStatement *handle, const PgExecParameters *exec_params) {</a>
<a name="ln986">  if (!PgStatement::IsValidStmt(handle, StmtOp::STMT_SELECT)) {</a>
<a name="ln987">    // Invalid handle.</a>
<a name="ln988">    return STATUS(InvalidArgument, &quot;Invalid statement handle&quot;);</a>
<a name="ln989">  }</a>
<a name="ln990">  return down_cast&lt;PgDmlRead*&gt;(handle)-&gt;Exec(exec_params);</a>
<a name="ln991">}</a>
<a name="ln992"> </a>
<a name="ln993">//--------------------------------------------------------------------------------------------------</a>
<a name="ln994">// Expressions.</a>
<a name="ln995">//--------------------------------------------------------------------------------------------------</a>
<a name="ln996"> </a>
<a name="ln997">// Column references -------------------------------------------------------------------------------</a>
<a name="ln998"> </a>
<a name="ln999">Status PgApiImpl::NewColumnRef(PgStatement *stmt, int attr_num, const PgTypeEntity *type_entity,</a>
<a name="ln1000">                               const PgTypeAttrs *type_attrs, PgExpr **expr_handle) {</a>
<a name="ln1001">  if (!stmt) {</a>
<a name="ln1002">    // Invalid handle.</a>
<a name="ln1003">    return STATUS(InvalidArgument, &quot;Invalid statement handle&quot;);</a>
<a name="ln1004">  }</a>
<a name="ln1005">  PgColumnRef::SharedPtr colref = make_shared&lt;PgColumnRef&gt;(attr_num, type_entity, type_attrs);</a>
<a name="ln1006">  stmt-&gt;AddExpr(colref);</a>
<a name="ln1007"> </a>
<a name="ln1008">  *expr_handle = colref.get();</a>
<a name="ln1009">  return Status::OK();</a>
<a name="ln1010">}</a>
<a name="ln1011"> </a>
<a name="ln1012">// Constant ----------------------------------------------------------------------------------------</a>
<a name="ln1013">Status PgApiImpl::NewConstant(YBCPgStatement stmt, const YBCPgTypeEntity *type_entity,</a>
<a name="ln1014">                              uint64_t datum, bool is_null, YBCPgExpr *expr_handle) {</a>
<a name="ln1015">  if (!stmt) {</a>
<a name="ln1016">    // Invalid handle.</a>
<a name="ln1017">    return STATUS(InvalidArgument, &quot;Invalid statement handle&quot;);</a>
<a name="ln1018">  }</a>
<a name="ln1019">  PgExpr::SharedPtr pg_const = make_shared&lt;PgConstant&gt;(type_entity, datum, is_null);</a>
<a name="ln1020">  stmt-&gt;AddExpr(pg_const);</a>
<a name="ln1021"> </a>
<a name="ln1022">  *expr_handle = pg_const.get();</a>
<a name="ln1023">  return Status::OK();</a>
<a name="ln1024">}</a>
<a name="ln1025"> </a>
<a name="ln1026">Status PgApiImpl::NewConstantOp(YBCPgStatement stmt, const YBCPgTypeEntity *type_entity,</a>
<a name="ln1027">                              uint64_t datum, bool is_null, YBCPgExpr *expr_handle, bool is_gt) {</a>
<a name="ln1028">  if (!stmt) {</a>
<a name="ln1029">    // Invalid handle.</a>
<a name="ln1030">    return STATUS(InvalidArgument, &quot;Invalid statement handle&quot;);</a>
<a name="ln1031">  }</a>
<a name="ln1032">  PgExpr::SharedPtr pg_const = make_shared&lt;PgConstant&gt;(type_entity, datum, is_null,</a>
<a name="ln1033">      is_gt ? PgExpr::Opcode::PG_EXPR_GT : PgExpr::Opcode::PG_EXPR_LT);</a>
<a name="ln1034">  stmt-&gt;AddExpr(pg_const);</a>
<a name="ln1035"> </a>
<a name="ln1036">  *expr_handle = pg_const.get();</a>
<a name="ln1037">  return Status::OK();</a>
<a name="ln1038">}</a>
<a name="ln1039"> </a>
<a name="ln1040">// Text constant -----------------------------------------------------------------------------------</a>
<a name="ln1041"> </a>
<a name="ln1042">Status PgApiImpl::UpdateConstant(PgExpr *expr, const char *value, bool is_null) {</a>
<a name="ln1043">  if (expr-&gt;opcode() != PgExpr::Opcode::PG_EXPR_CONSTANT) {</a>
<a name="ln1044">    // Invalid handle.</a>
<a name="ln1045">    return STATUS(InvalidArgument, &quot;Invalid expression handle for constant&quot;);</a>
<a name="ln1046">  }</a>
<a name="ln1047">  down_cast&lt;PgConstant*&gt;(expr)-&gt;UpdateConstant(value, is_null);</a>
<a name="ln1048">  return Status::OK();</a>
<a name="ln1049">}</a>
<a name="ln1050"> </a>
<a name="ln1051">Status PgApiImpl::UpdateConstant(PgExpr *expr, const void *value, int64_t bytes, bool is_null) {</a>
<a name="ln1052">  if (expr-&gt;opcode() != PgExpr::Opcode::PG_EXPR_CONSTANT) {</a>
<a name="ln1053">    // Invalid handle.</a>
<a name="ln1054">    return STATUS(InvalidArgument, &quot;Invalid expression handle for constant&quot;);</a>
<a name="ln1055">  }</a>
<a name="ln1056">  down_cast&lt;PgConstant*&gt;(expr)-&gt;UpdateConstant(value, bytes, is_null);</a>
<a name="ln1057">  return Status::OK();</a>
<a name="ln1058">}</a>
<a name="ln1059"> </a>
<a name="ln1060">// Text constant -----------------------------------------------------------------------------------</a>
<a name="ln1061"> </a>
<a name="ln1062">Status PgApiImpl::NewOperator(PgStatement *stmt, const char *opname,</a>
<a name="ln1063">                              const YBCPgTypeEntity *type_entity,</a>
<a name="ln1064">                              PgExpr **op_handle) {</a>
<a name="ln1065">  if (!stmt) {</a>
<a name="ln1066">    // Invalid handle.</a>
<a name="ln1067">    return STATUS(InvalidArgument, &quot;Invalid statement handle&quot;);</a>
<a name="ln1068">  }</a>
<a name="ln1069">  RETURN_NOT_OK(PgExpr::CheckOperatorName(opname));</a>
<a name="ln1070"> </a>
<a name="ln1071">  // Create operator.</a>
<a name="ln1072">  PgExpr::SharedPtr pg_op = make_shared&lt;PgOperator&gt;(opname, type_entity);</a>
<a name="ln1073">  stmt-&gt;AddExpr(pg_op);</a>
<a name="ln1074"> </a>
<a name="ln1075">  *op_handle = pg_op.get();</a>
<a name="ln1076">  return Status::OK();</a>
<a name="ln1077">}</a>
<a name="ln1078"> </a>
<a name="ln1079">Status PgApiImpl::OperatorAppendArg(PgExpr *op_handle, PgExpr *arg) {</a>
<a name="ln1080">  if (!op_handle || !arg) {</a>
<a name="ln1081">    // Invalid handle.</a>
<a name="ln1082">    return STATUS(InvalidArgument, &quot;Invalid expression handle&quot;);</a>
<a name="ln1083">  }</a>
<a name="ln1084">  down_cast&lt;PgOperator*&gt;(op_handle)-&gt;AppendArg(arg);</a>
<a name="ln1085">  return Status::OK();</a>
<a name="ln1086">}</a>
<a name="ln1087"> </a>
<a name="ln1088">Result&lt;bool&gt; PgApiImpl::IsInitDbDone() {</a>
<a name="ln1089">  return pg_session_-&gt;IsInitDbDone();</a>
<a name="ln1090">}</a>
<a name="ln1091"> </a>
<a name="ln1092">Result&lt;uint64_t&gt; PgApiImpl::GetSharedCatalogVersion() {</a>
<a name="ln1093">  return pg_session_-&gt;GetSharedCatalogVersion();</a>
<a name="ln1094">}</a>
<a name="ln1095"> </a>
<a name="ln1096">// Transaction Control -----------------------------------------------------------------------------</a>
<a name="ln1097">Status PgApiImpl::BeginTransaction() {</a>
<a name="ln1098">  pg_session_-&gt;InvalidateForeignKeyReferenceCache();</a>
<a name="ln1099">  return pg_txn_manager_-&gt;BeginTransaction();</a>
<a name="ln1100">}</a>
<a name="ln1101"> </a>
<a name="ln1102">Status PgApiImpl::RestartTransaction() {</a>
<a name="ln1103">  pg_session_-&gt;InvalidateForeignKeyReferenceCache();</a>
<a name="ln1104">  return pg_txn_manager_-&gt;RestartTransaction();</a>
<a name="ln1105">}</a>
<a name="ln1106"> </a>
<a name="ln1107">Status PgApiImpl::CommitTransaction() {</a>
<a name="ln1108">  pg_session_-&gt;InvalidateForeignKeyReferenceCache();</a>
<a name="ln1109">  return pg_txn_manager_-&gt;CommitTransaction();</a>
<a name="ln1110">}</a>
<a name="ln1111"> </a>
<a name="ln1112">Status PgApiImpl::AbortTransaction() {</a>
<a name="ln1113">  pg_session_-&gt;InvalidateForeignKeyReferenceCache();</a>
<a name="ln1114">  return pg_txn_manager_-&gt;AbortTransaction();</a>
<a name="ln1115">}</a>
<a name="ln1116"> </a>
<a name="ln1117">Status PgApiImpl::SetTransactionIsolationLevel(int isolation) {</a>
<a name="ln1118">  return pg_txn_manager_-&gt;SetIsolationLevel(isolation);</a>
<a name="ln1119">}</a>
<a name="ln1120"> </a>
<a name="ln1121">Status PgApiImpl::SetTransactionReadOnly(bool read_only) {</a>
<a name="ln1122">  return pg_txn_manager_-&gt;SetReadOnly(read_only);</a>
<a name="ln1123">}</a>
<a name="ln1124"> </a>
<a name="ln1125">Status PgApiImpl::SetTransactionDeferrable(bool deferrable) {</a>
<a name="ln1126">  return pg_txn_manager_-&gt;SetDeferrable(deferrable);</a>
<a name="ln1127">}</a>
<a name="ln1128"> </a>
<a name="ln1129">Status PgApiImpl::EnterSeparateDdlTxnMode() {</a>
<a name="ln1130">  // Flush all buffered operations as ddl txn use its own transaction session.</a>
<a name="ln1131">  RETURN_NOT_OK(pg_session_-&gt;FlushBufferedOperations());</a>
<a name="ln1132">  return pg_txn_manager_-&gt;EnterSeparateDdlTxnMode();</a>
<a name="ln1133">}</a>
<a name="ln1134"> </a>
<a name="ln1135">Status PgApiImpl::ExitSeparateDdlTxnMode(bool success) {</a>
<a name="ln1136">  // Flush all buffered operations as ddl txn use its own transaction session.</a>
<a name="ln1137">  if (success) {</a>
<a name="ln1138">    RETURN_NOT_OK(pg_session_-&gt;FlushBufferedOperations());</a>
<a name="ln1139">  } else {</a>
<a name="ln1140">    pg_session_-&gt;DropBufferedOperations();</a>
<a name="ln1141">  }</a>
<a name="ln1142"> </a>
<a name="ln1143">  return pg_txn_manager_-&gt;ExitSeparateDdlTxnMode(success);</a>
<a name="ln1144">}</a>
<a name="ln1145"> </a>
<a name="ln1146">bool PgApiImpl::ForeignKeyReferenceExists(YBCPgOid table_id, std::string&amp;&amp; ybctid) {</a>
<a name="ln1147">  return pg_session_-&gt;ForeignKeyReferenceExists(table_id, std::move(ybctid));</a>
<a name="ln1148">}</a>
<a name="ln1149"> </a>
<a name="ln1150">Status PgApiImpl::CacheForeignKeyReference(YBCPgOid table_id, std::string&amp;&amp; ybctid) {</a>
<a name="ln1151">  return pg_session_-&gt;CacheForeignKeyReference(table_id, std::move(ybctid));</a>
<a name="ln1152">}</a>
<a name="ln1153"> </a>
<a name="ln1154">Status PgApiImpl::DeleteForeignKeyReference(YBCPgOid table_id, std::string&amp;&amp; ybctid) {</a>
<a name="ln1155">  return pg_session_-&gt;DeleteForeignKeyReference(table_id, std::move(ybctid));</a>
<a name="ln1156">}</a>
<a name="ln1157"> </a>
<a name="ln1158">void PgApiImpl::ClearForeignKeyReferenceCache() {</a>
<a name="ln1159">  pg_session_-&gt;InvalidateForeignKeyReferenceCache();</a>
<a name="ln1160">}</a>
<a name="ln1161"> </a>
<a name="ln1162">void PgApiImpl::SetTimeout(const int timeout_ms) {</a>
<a name="ln1163">  pg_session_-&gt;SetTimeout(timeout_ms);</a>
<a name="ln1164">}</a>
<a name="ln1165"> </a>
<a name="ln1166">} // namespace pggate</a>
<a name="ln1167">} // namespace yb</a>

</code></pre>
<div class="balloon" rel="86"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="104"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="115"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="127"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="143"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="183"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
