
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>pt_dml.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//--------------------------------------------------------------------------------------------------</a>
<a name="ln2">// Copyright (c) YugaByte, Inc.</a>
<a name="ln3">//</a>
<a name="ln4">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln5">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln6">//</a>
<a name="ln7">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln8">//</a>
<a name="ln9">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln10">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln11">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln12">// under the License.</a>
<a name="ln13">//</a>
<a name="ln14">//</a>
<a name="ln15">// Treenode implementation for DML including SELECT statements.</a>
<a name="ln16">//--------------------------------------------------------------------------------------------------</a>
<a name="ln17"> </a>
<a name="ln18">#include &quot;yb/yql/cql/ql/ptree/pt_dml.h&quot;</a>
<a name="ln19"> </a>
<a name="ln20">#include &quot;yb/client/table.h&quot;</a>
<a name="ln21"> </a>
<a name="ln22">#include &quot;yb/yql/cql/ql/ptree/sem_context.h&quot;</a>
<a name="ln23"> </a>
<a name="ln24">DECLARE_bool(use_cassandra_authentication);</a>
<a name="ln25"> </a>
<a name="ln26">namespace yb {</a>
<a name="ln27">namespace ql {</a>
<a name="ln28"> </a>
<a name="ln29">DECLARE_bool(allow_index_table_read_write);</a>
<a name="ln30"> </a>
<a name="ln31">using strings::Substitute;</a>
<a name="ln32"> </a>
<a name="ln33">PTDmlStmt::PTDmlStmt(MemoryContext *memctx,</a>
<a name="ln34">                     YBLocation::SharedPtr loc,</a>
<a name="ln35">                     PTExpr::SharedPtr where_clause,</a>
<a name="ln36">                     PTExpr::SharedPtr if_clause,</a>
<a name="ln37">                     const bool else_error,</a>
<a name="ln38">                     PTDmlUsingClause::SharedPtr using_clause,</a>
<a name="ln39">                     const bool returns_status)</a>
<a name="ln40">    : PTCollection(memctx, loc),</a>
<a name="ln41">      where_clause_(where_clause),</a>
<a name="ln42">      if_clause_(if_clause),</a>
<a name="ln43">      else_error_(else_error),</a>
<a name="ln44">      using_clause_(using_clause),</a>
<a name="ln45">      returns_status_(returns_status),</a>
<a name="ln46">      bind_variables_(memctx),</a>
<a name="ln47">      column_map_(memctx),</a>
<a name="ln48">      func_ops_(memctx),</a>
<a name="ln49">      key_where_ops_(memctx),</a>
<a name="ln50">      where_ops_(memctx),</a>
<a name="ln51">      subscripted_col_where_ops_(memctx),</a>
<a name="ln52">      json_col_where_ops_(memctx),</a>
<a name="ln53">      partition_key_ops_(memctx),</a>
<a name="ln54">      hash_col_bindvars_(memctx),</a>
<a name="ln55">      column_refs_(memctx),</a>
<a name="ln56">      static_column_refs_(memctx),</a>
<a name="ln57">      pk_only_indexes_(memctx),</a>
<a name="ln58">      non_pk_only_indexes_(memctx),</a>
<a name="ln59">      filtering_exprs_(memctx) {</a>
<a name="ln60">}</a>
<a name="ln61"> </a>
<a name="ln62">// Clone a DML tnode for re-analysis. Only the syntactic information populated by the parser should</a>
<a name="ln63">// be cloned here. Semantic information should be left in the initial state to be populated when</a>
<a name="ln64">// this tnode is analyzed.</a>
<a name="ln65">PTDmlStmt::PTDmlStmt(MemoryContext *memctx, const PTDmlStmt&amp; other, bool copy_if_clause)</a>
<a name="ln66">    : PTCollection(memctx, other.loc_ptr()),</a>
<a name="ln67">      where_clause_(other.where_clause_),</a>
<a name="ln68">      if_clause_(copy_if_clause ? other.if_clause_ : nullptr),</a>
<a name="ln69">      else_error_(other.else_error_),</a>
<a name="ln70">      using_clause_(other.using_clause_),</a>
<a name="ln71">      returns_status_(other.returns_status_),</a>
<a name="ln72">      bind_variables_(other.bind_variables_, memctx),</a>
<a name="ln73">      column_map_(memctx),</a>
<a name="ln74">      func_ops_(memctx),</a>
<a name="ln75">      key_where_ops_(memctx),</a>
<a name="ln76">      where_ops_(memctx),</a>
<a name="ln77">      subscripted_col_where_ops_(memctx),</a>
<a name="ln78">      json_col_where_ops_(memctx),</a>
<a name="ln79">      partition_key_ops_(memctx),</a>
<a name="ln80">      hash_col_bindvars_(memctx),</a>
<a name="ln81">      column_refs_(memctx),</a>
<a name="ln82">      static_column_refs_(memctx),</a>
<a name="ln83">      pk_only_indexes_(memctx),</a>
<a name="ln84">      non_pk_only_indexes_(memctx),</a>
<a name="ln85">      filtering_exprs_(memctx) {</a>
<a name="ln86">}</a>
<a name="ln87"> </a>
<a name="ln88">PTDmlStmt::~PTDmlStmt() {</a>
<a name="ln89">}</a>
<a name="ln90"> </a>
<a name="ln91">int PTDmlStmt::num_columns() const {</a>
<a name="ln92">  return table_-&gt;schema().num_columns();</a>
<a name="ln93">}</a>
<a name="ln94"> </a>
<a name="ln95">int PTDmlStmt::num_key_columns() const {</a>
<a name="ln96">  return table_-&gt;schema().num_key_columns();</a>
<a name="ln97">}</a>
<a name="ln98"> </a>
<a name="ln99">int PTDmlStmt::num_hash_key_columns() const {</a>
<a name="ln100">  return table_-&gt;schema().num_hash_key_columns();</a>
<a name="ln101">}</a>
<a name="ln102"> </a>
<a name="ln103">string PTDmlStmt::hash_key_columns() const {</a>
<a name="ln104">  std::stringstream s;</a>
<a name="ln105">  auto &amp;schema = table_-&gt;schema();</a>
<a name="ln106">  for (int i = 0; i &lt; schema.num_hash_key_columns(); ++i) {</a>
<a name="ln107">    if (i != 0) s &lt;&lt; &quot;, &quot;;</a>
<a name="ln108">    s &lt;&lt; schema.Column(i).name();</a>
<a name="ln109">  }</a>
<a name="ln110">  return s.str();</a>
<a name="ln111">}</a>
<a name="ln112"> </a>
<a name="ln113">Status PTDmlStmt::LookupTable(SemContext *sem_context) {</a>
<a name="ln114">  if (FLAGS_use_cassandra_authentication) {</a>
<a name="ln115">    switch (opcode()) {</a>
<a name="ln116">      case TreeNodeOpcode::kPTSelectStmt: {</a>
<a name="ln117">        if (!internal_) {</a>
<a name="ln118">          if (down_cast&lt;PTSelectStmt *&gt;(this)-&gt;IsReadableByAllSystemTable()) {</a>
<a name="ln119">            break;</a>
<a name="ln120">          }</a>
<a name="ln121">          RETURN_NOT_OK(sem_context-&gt;CheckHasTablePermission(loc(),</a>
<a name="ln122">              PermissionType::SELECT_PERMISSION, this-&gt;table_name()));</a>
<a name="ln123">        }</a>
<a name="ln124">        break;</a>
<a name="ln125">      }</a>
<a name="ln126">      case TreeNodeOpcode::kPTUpdateStmt: FALLTHROUGH_INTENDED;</a>
<a name="ln127">      case TreeNodeOpcode::kPTInsertStmt: FALLTHROUGH_INTENDED;</a>
<a name="ln128">      case TreeNodeOpcode::kPTDeleteStmt: {</a>
<a name="ln129">        RETURN_NOT_OK(sem_context-&gt;CheckHasTablePermission(loc(),</a>
<a name="ln130">            PermissionType::MODIFY_PERMISSION, this-&gt;table_name()));</a>
<a name="ln131">        break;</a>
<a name="ln132">      }</a>
<a name="ln133">      default:</a>
<a name="ln134">        DFATAL_OR_RETURN_NOT_OK(STATUS_FORMAT(InternalError, &quot;Unexpected operation $0&quot;, opcode()));</a>
<a name="ln135">    }</a>
<a name="ln136">  }</a>
<a name="ln137">  is_system_ = table_name().is_system();</a>
<a name="ln138">  if (is_system_ &amp;&amp; IsWriteOp() &amp;&amp; client::FLAGS_yb_system_namespace_readonly) {</a>
<a name="ln139">    return sem_context-&gt;Error(table_loc(), ErrorCode::SYSTEM_NAMESPACE_READONLY);</a>
<a name="ln140">  }</a>
<a name="ln141"> </a>
<a name="ln142">  VLOG(3) &lt;&lt; &quot;Loading table descriptor for &quot; &lt;&lt; table_name().ToString();</a>
<a name="ln143">  table_ = sem_context-&gt;GetTableDesc(table_name());</a>
<a name="ln144">  if (!table_ || (table_-&gt;IsIndex() &amp;&amp; !FLAGS_allow_index_table_read_write) ||</a>
<a name="ln145">      // Only looking for CQL tables.</a>
<a name="ln146">      (table_-&gt;table_type() != client::YBTableType::YQL_TABLE_TYPE)) {</a>
<a name="ln147">    return sem_context-&gt;Error(table_loc(), ErrorCode::OBJECT_NOT_FOUND);</a>
<a name="ln148">  }</a>
<a name="ln149">  LoadSchema(sem_context, table_, &amp;column_map_, false /* is_index */);</a>
<a name="ln150">  return Status::OK();</a>
<a name="ln151">}</a>
<a name="ln152"> </a>
<a name="ln153">void PTDmlStmt::LoadSchema(SemContext *sem_context,</a>
<a name="ln154">                           const client::YBTablePtr&amp; table,</a>
<a name="ln155">                           MCColumnMap* column_map,</a>
<a name="ln156">                           bool is_index) {</a>
<a name="ln157">  column_map-&gt;clear();</a>
<a name="ln158">  const client::YBSchema&amp; schema = table-&gt;schema();</a>
<a name="ln159">  for (size_t idx = 0; idx &lt; schema.num_columns(); idx++) {</a>
<a name="ln160">    const client::YBColumnSchema col = schema.Column(idx);</a>
<a name="ln161">    string colname = col.name();</a>
<a name="ln162">    if (is_index &amp;&amp; !schema.table_properties().use_mangled_column_name()) {</a>
<a name="ln163">      // This is an OLD INDEX. We need to mangled its column name to work with new implementation.</a>
<a name="ln164">      colname = YcqlName::MangleColumnName(colname);</a>
<a name="ln165">    }</a>
<a name="ln166">    column_map-&gt;emplace(MCString(colname.c_str(), sem_context-&gt;PSemMem()),</a>
<a name="ln167">                        ColumnDesc(idx,</a>
<a name="ln168">                                   schema.ColumnId(idx),</a>
<a name="ln169">                                   col.name(),</a>
<a name="ln170">                                   idx &lt; schema.num_hash_key_columns(),</a>
<a name="ln171">                                   idx &lt; schema.num_key_columns(),</a>
<a name="ln172">                                   col.is_static(),</a>
<a name="ln173">                                   col.is_counter(),</a>
<a name="ln174">                                   col.type(),</a>
<a name="ln175">                                   client::YBColumnSchema::ToInternalDataType(col.type()),</a>
<a name="ln176">                                   is_index));</a>
<a name="ln177">  }</a>
<a name="ln178">}</a>
<a name="ln179"> </a>
<a name="ln180">// Node semantics analysis.</a>
<a name="ln181">Status PTDmlStmt::Analyze(SemContext *sem_context) {</a>
<a name="ln182">  sem_context-&gt;set_current_dml_stmt(this);</a>
<a name="ln183">  MemoryContext *psem_mem = sem_context-&gt;PSemMem();</a>
<a name="ln184">  column_args_ = MCMakeShared&lt;MCVector&lt;ColumnArg&gt;&gt;(psem_mem);</a>
<a name="ln185">  subscripted_col_args_ = MCMakeShared&lt;MCVector&lt;SubscriptedColumnArg&gt;&gt;(psem_mem);</a>
<a name="ln186">  json_col_args_ = MCMakeShared&lt;MCVector&lt;JsonColumnArg&gt;&gt;(psem_mem);</a>
<a name="ln187">  return Status::OK();</a>
<a name="ln188">}</a>
<a name="ln189"> </a>
<a name="ln190">const ColumnDesc* PTDmlStmt::GetColumnDesc(const SemContext *sem_context,</a>
<a name="ln191">                                           const MCString&amp; col_name) {</a>
<a name="ln192">  const auto iter = column_map_.find(col_name);</a>
<a name="ln193">  if (iter == column_map_.end()) {</a>
<a name="ln194">    return nullptr;</a>
<a name="ln195">  }</a>
<a name="ln196"> </a>
<a name="ln197">  const ColumnDesc* column_desc = &amp;iter-&gt;second;</a>
<a name="ln198"> </a>
<a name="ln199">  // To indicate that DocDB must read a columm value to execute an expression, the column is added</a>
<a name="ln200">  // to the column_refs list.</a>
<a name="ln201">  bool reading_column = false;</a>
<a name="ln202"> </a>
<a name="ln203">  switch (opcode()) {</a>
<a name="ln204">    case TreeNodeOpcode::kPTSelectStmt:</a>
<a name="ln205">      reading_column = true;</a>
<a name="ln206">      break;</a>
<a name="ln207">    case TreeNodeOpcode::kPTUpdateStmt:</a>
<a name="ln208">      if (sem_context-&gt;sem_state() != nullptr &amp;&amp;</a>
<a name="ln209">          sem_context-&gt;processing_set_clause() &amp;&amp;</a>
<a name="ln210">          !sem_context-&gt;processing_assignee()) {</a>
<a name="ln211">        reading_column = true;</a>
<a name="ln212">        break;</a>
<a name="ln213">      }</a>
<a name="ln214">      FALLTHROUGH_INTENDED;</a>
<a name="ln215">    case TreeNodeOpcode::kPTInsertStmt:</a>
<a name="ln216">    case TreeNodeOpcode::kPTDeleteStmt:</a>
<a name="ln217">      if (sem_context-&gt;sem_state() != nullptr &amp;&amp;</a>
<a name="ln218">          sem_context-&gt;processing_if_clause()) {</a>
<a name="ln219">        reading_column = true;</a>
<a name="ln220">        break;</a>
<a name="ln221">      }</a>
<a name="ln222">      break;</a>
<a name="ln223">    default:</a>
<a name="ln224">      break;</a>
<a name="ln225">  }</a>
<a name="ln226"> </a>
<a name="ln227">  if (reading_column) {</a>
<a name="ln228">    // TODO(neil) Currently AddColumnRef() relies on MCSet datatype to guarantee that we have a</a>
<a name="ln229">    // unique list of IDs, but we should take advantage to &quot;symbol table&quot; when collecting data</a>
<a name="ln230">    // for execution. Symbol table and &quot;column_read_count_&quot; need to be corrected so that we can</a>
<a name="ln231">    // use MCList instead.</a>
<a name="ln232"> </a>
<a name="ln233">    // Indicate that this column must be read for the statement execution.</a>
<a name="ln234">    AddColumnRef(*column_desc);</a>
<a name="ln235">  }</a>
<a name="ln236"> </a>
<a name="ln237">  return column_desc;</a>
<a name="ln238">}</a>
<a name="ln239"> </a>
<a name="ln240">Status PTDmlStmt::AnalyzeWhereClause(SemContext *sem_context) {</a>
<a name="ln241">  if (!where_clause_) {</a>
<a name="ln242">    if (IsWriteOp()) {</a>
<a name="ln243">      return sem_context-&gt;Error(this, &quot;Missing partition key&quot;, ErrorCode::CQL_STATEMENT_INVALID);</a>
<a name="ln244">    }</a>
<a name="ln245">    return Status::OK();</a>
<a name="ln246">  }</a>
<a name="ln247"> </a>
<a name="ln248">  // Analyze where expression.</a>
<a name="ln249">  if (IsWriteOp()) {</a>
<a name="ln250">    key_where_ops_.resize(num_key_columns());</a>
<a name="ln251">  } else {</a>
<a name="ln252">    key_where_ops_.resize(num_hash_key_columns());</a>
<a name="ln253">  }</a>
<a name="ln254">  RETURN_NOT_OK(AnalyzeWhereExpr(sem_context, where_clause_.get()));</a>
<a name="ln255">  return Status::OK();</a>
<a name="ln256">}</a>
<a name="ln257"> </a>
<a name="ln258">Status PTDmlStmt::AnalyzeWhereExpr(SemContext *sem_context, PTExpr *expr) {</a>
<a name="ln259">  // Construct the state variables and analyze the expression.</a>
<a name="ln260">  MCVector&lt;ColumnOpCounter&gt; op_counters(sem_context-&gt;PTempMem());</a>
<a name="ln261">  op_counters.resize(num_columns());</a>
<a name="ln262">  ColumnOpCounter partition_key_counter;</a>
<a name="ln263">  WhereExprState where_state(&amp;where_ops_, &amp;key_where_ops_, &amp;subscripted_col_where_ops_,</a>
<a name="ln264">                             &amp;json_col_where_ops_, &amp;partition_key_ops_, &amp;op_counters,</a>
<a name="ln265">                             &amp;partition_key_counter, opcode(), &amp;func_ops_,</a>
<a name="ln266">                             &amp;filtering_exprs_);</a>
<a name="ln267"> </a>
<a name="ln268">  SemState sem_state(sem_context, QLType::Create(BOOL), InternalType::kBoolValue);</a>
<a name="ln269">  sem_state.SetWhereState(&amp;where_state);</a>
<a name="ln270">  RETURN_NOT_OK(expr-&gt;Analyze(sem_context));</a>
<a name="ln271"> </a>
<a name="ln272">  if (IsWriteOp()) {</a>
<a name="ln273">    // Make sure that all hash entries are referenced in where expression.</a>
<a name="ln274">    for (int idx = 0; idx &lt; num_hash_key_columns(); idx++) {</a>
<a name="ln275">      if (op_counters[idx].eq_count() == 0) {</a>
<a name="ln276">        return sem_context-&gt;Error(expr, &quot;Missing condition on key columns in WHERE clause&quot;,</a>
<a name="ln277">                                  ErrorCode::CQL_STATEMENT_INVALID);</a>
<a name="ln278">      }</a>
<a name="ln279">    }</a>
<a name="ln280"> </a>
<a name="ln281">    // If writing static columns only, check that either all range key entries are referenced in the</a>
<a name="ln282">    // where expression or none is referenced. Else, check that all range key are referenced.</a>
<a name="ln283">    int range_keys = 0;</a>
<a name="ln284">    for (int idx = num_hash_key_columns(); idx &lt; num_key_columns(); idx++) {</a>
<a name="ln285">      if (op_counters[idx].eq_count() != 0) {</a>
<a name="ln286">        range_keys++;</a>
<a name="ln287">      }</a>
<a name="ln288">    }</a>
<a name="ln289">    if (StaticColumnArgsOnly()) {</a>
<a name="ln290">      if (range_keys != num_key_columns() - num_hash_key_columns() &amp;&amp; range_keys != 0)</a>
<a name="ln291">        return sem_context-&gt;Error(expr, &quot;Missing condition on key columns in WHERE clause&quot;,</a>
<a name="ln292">                                  ErrorCode::CQL_STATEMENT_INVALID);</a>
<a name="ln293">      if (range_keys == 0) {</a>
<a name="ln294">        key_where_ops_.resize(num_hash_key_columns());</a>
<a name="ln295">      }</a>
<a name="ln296">    } else {</a>
<a name="ln297">      if (range_keys != num_key_columns() - num_hash_key_columns()) {</a>
<a name="ln298">        if (opcode() == TreeNodeOpcode::kPTDeleteStmt) {</a>
<a name="ln299">          // Range expression in write requests are allowed for deletes only.</a>
<a name="ln300">          for (int idx = num_hash_key_columns(); idx &lt; num_key_columns(); idx++) {</a>
<a name="ln301">            if (op_counters[idx].eq_count() != 0) {</a>
<a name="ln302">              where_ops_.push_front(key_where_ops_[idx]);</a>
<a name="ln303">            }</a>
<a name="ln304">          }</a>
<a name="ln305">          key_where_ops_.resize(num_hash_key_columns());</a>
<a name="ln306">        } else {</a>
<a name="ln307">          return sem_context-&gt;Error(expr, &quot;Missing condition on key columns in WHERE clause&quot;,</a>
<a name="ln308">                                    ErrorCode::CQL_STATEMENT_INVALID);</a>
<a name="ln309">        }</a>
<a name="ln310">      }</a>
<a name="ln311">    }</a>
<a name="ln312">  } else { // ReadOp</a>
<a name="ln313">    // Add the hash to the where clause if the list is incomplete. Clear key_where_ops_ to do</a>
<a name="ln314">    // whole-table scan.</a>
<a name="ln315">    for (int idx = 0; idx &lt; num_hash_key_columns(); idx++) {</a>
<a name="ln316">      if (!key_where_ops_[idx].IsInitialized()) {</a>
<a name="ln317">        has_incomplete_hash_ = true;</a>
<a name="ln318">        break;</a>
<a name="ln319">      }</a>
<a name="ln320">    }</a>
<a name="ln321">    if (has_incomplete_hash_) {</a>
<a name="ln322">      for (int idx = num_hash_key_columns() - 1; idx &gt;= 0; idx--) {</a>
<a name="ln323">        if (key_where_ops_[idx].IsInitialized()) {</a>
<a name="ln324">          where_ops_.push_front(key_where_ops_[idx]);</a>
<a name="ln325">        }</a>
<a name="ln326">      }</a>
<a name="ln327">      key_where_ops_.clear();</a>
<a name="ln328">    } else {</a>
<a name="ln329">      select_has_primary_keys_set_ = true;</a>
<a name="ln330">      // Unset if there is a range key without a condition.</a>
<a name="ln331">      for (int idx = num_hash_key_columns(); idx &lt; num_key_columns(); idx++) {</a>
<a name="ln332">        if (op_counters[idx].IsEmpty()) {</a>
<a name="ln333">          select_has_primary_keys_set_ = false;</a>
<a name="ln334">          break;</a>
<a name="ln335">        }</a>
<a name="ln336">      }</a>
<a name="ln337">    }</a>
<a name="ln338">  }</a>
<a name="ln339"> </a>
<a name="ln340">  // Analyze bind variables for hash columns in the WHERE clause.</a>
<a name="ln341">  RETURN_NOT_OK(AnalyzeHashColumnBindVars(sem_context));</a>
<a name="ln342"> </a>
<a name="ln343">  return Status::OK();</a>
<a name="ln344">}</a>
<a name="ln345"> </a>
<a name="ln346">Status PTDmlStmt::AnalyzeIfClause(SemContext *sem_context) {</a>
<a name="ln347">  if (if_clause_) {</a>
<a name="ln348">    IfExprState if_state(&amp;filtering_exprs_);</a>
<a name="ln349">    SemState sem_state(sem_context, QLType::Create(BOOL), InternalType::kBoolValue);</a>
<a name="ln350">    sem_state.set_processing_if_clause(true);</a>
<a name="ln351">    sem_state.SetIfState(&amp;if_state);</a>
<a name="ln352">    return if_clause_-&gt;Analyze(sem_context);</a>
<a name="ln353">  }</a>
<a name="ln354">  return Status::OK();</a>
<a name="ln355">}</a>
<a name="ln356"> </a>
<a name="ln357">Status PTDmlStmt::AnalyzeUsingClause(SemContext *sem_context) {</a>
<a name="ln358">  if (using_clause_ == nullptr) {</a>
<a name="ln359">    return Status::OK();</a>
<a name="ln360">  }</a>
<a name="ln361"> </a>
<a name="ln362">  RETURN_NOT_OK(using_clause_-&gt;Analyze(sem_context));</a>
<a name="ln363">  return Status::OK();</a>
<a name="ln364">}</a>
<a name="ln365"> </a>
<a name="ln366">Status PTDmlStmt::AnalyzeIndexesForWrites(SemContext *sem_context) {</a>
<a name="ln367">  const Schema&amp; indexed_schema = table_-&gt;InternalSchema();</a>
<a name="ln368">  for (const auto&amp; itr : table_-&gt;index_map()) {</a>
<a name="ln369">    const TableId&amp; index_id = itr.first;</a>
<a name="ln370">    const IndexInfo&amp; index = itr.second;</a>
<a name="ln371">    // If the index indexes the primary key columns only, index updates can be issued from the CQL</a>
<a name="ln372">    // proxy side without reading the current row so long as the DML does not delete the column</a>
<a name="ln373">    // (including setting the value to null). Otherwise, the updates needed can only be determined</a>
<a name="ln374">    // from the tserver side after the current values are read.</a>
<a name="ln375">    if (index.PrimaryKeyColumnsOnly(indexed_schema)) {</a>
<a name="ln376">      std::shared_ptr&lt;client::YBTable&gt; index_table = sem_context-&gt;GetTableDesc(index_id);</a>
<a name="ln377">      if (index_table == nullptr) {</a>
<a name="ln378">        return sem_context-&gt;Error(this, Substitute(&quot;Index table $0 not found&quot;, index_id).c_str(),</a>
<a name="ln379">                                  ErrorCode::OBJECT_NOT_FOUND);</a>
<a name="ln380">      }</a>
<a name="ln381">      pk_only_indexes_.insert(index_table);</a>
<a name="ln382">    } else {</a>
<a name="ln383">      non_pk_only_indexes_.insert(index_id);</a>
<a name="ln384">      for (const IndexInfo::IndexColumn&amp; column : index.columns()) {</a>
<a name="ln385">        const ColumnId indexed_column_id = column.indexed_column_id;</a>
<a name="ln386">        if (!indexed_schema.is_key_column(indexed_column_id)) {</a>
<a name="ln387">          column_refs_.insert(indexed_column_id);</a>
<a name="ln388">        }</a>
<a name="ln389">      }</a>
<a name="ln390">    }</a>
<a name="ln391">  }</a>
<a name="ln392">  return Status::OK();</a>
<a name="ln393">}</a>
<a name="ln394"> </a>
<a name="ln395">bool PTDmlStmt::RequiresTransaction() const {</a>
<a name="ln396">  return IsWriteOp() &amp;&amp; !DCHECK_NOTNULL(table_.get())-&gt;index_map().empty() &amp;&amp;</a>
<a name="ln397">      table_-&gt;InternalSchema().table_properties().is_transactional();</a>
<a name="ln398">}</a>
<a name="ln399"> </a>
<a name="ln400">Status PTDmlStmt::AnalyzeHashColumnBindVars(SemContext *sem_context) {</a>
<a name="ln401">  // If not all hash columns are bound, clear hash_col_bindvars_ because the client driver will not</a>
<a name="ln402">  // be able to compute the full hash key unless it parses the SQL statement and extracts the</a>
<a name="ln403">  // literals also, which is not currently supported and unlikely to be.</a>
<a name="ln404">  if (hash_col_bindvars_.size() != num_hash_key_columns()) {</a>
<a name="ln405">    hash_col_bindvars_.clear();</a>
<a name="ln406">  }</a>
<a name="ln407"> </a>
<a name="ln408">  return Status::OK();</a>
<a name="ln409">}</a>
<a name="ln410"> </a>
<a name="ln411">Status PTDmlStmt::AnalyzeColumnArgs(SemContext *sem_context) {</a>
<a name="ln412"> </a>
<a name="ln413">  // If we have no args, this must be a delete modifying primary key only.</a>
<a name="ln414">  if (column_args_-&gt;empty() &amp;&amp; subscripted_col_args_-&gt;empty() &amp;&amp; json_col_args_-&gt;empty()) {</a>
<a name="ln415">    modifies_primary_row_ = true;</a>
<a name="ln416">    return Status::OK();</a>
<a name="ln417">  }</a>
<a name="ln418"> </a>
<a name="ln419">  // If we have range keys we modify the primary row.</a>
<a name="ln420">  for (int idx = num_hash_key_columns(); idx &lt; num_key_columns(); idx++) {</a>
<a name="ln421">    if (column_args_-&gt;at(idx).IsInitialized()) {</a>
<a name="ln422">      modifies_primary_row_ = true;</a>
<a name="ln423">      break;</a>
<a name="ln424">    }</a>
<a name="ln425">  }</a>
<a name="ln426"> </a>
<a name="ln427">  // If we have column args:</a>
<a name="ln428">  //  - Writing to static columns =&gt; modify static row.</a>
<a name="ln429">  //  - Writing to non-static columns -&gt; modify primary row.</a>
<a name="ln430"> </a>
<a name="ln431">  // Check plain column args.</a>
<a name="ln432">  for (int idx = num_key_columns(); idx &lt; column_args_-&gt;size(); idx++) {</a>
<a name="ln433">    if (column_args_-&gt;at(idx).IsInitialized()) {</a>
<a name="ln434">      if (column_args_-&gt;at(idx).desc()-&gt;is_static()) {</a>
<a name="ln435">        modifies_static_row_ = true;</a>
<a name="ln436">      } else {</a>
<a name="ln437">        modifies_primary_row_ = true;</a>
<a name="ln438">      }</a>
<a name="ln439">      if (modifies_static_row_ &amp;&amp; modifies_primary_row_) {</a>
<a name="ln440">        return Status::OK();</a>
<a name="ln441">      }</a>
<a name="ln442">    }</a>
<a name="ln443">  }</a>
<a name="ln444"> </a>
<a name="ln445">  // Check subscripted column args (e.g. map['k'] or list[1])</a>
<a name="ln446">  for (auto&amp; arg : *subscripted_col_args_) {</a>
<a name="ln447">    if (arg.desc()-&gt;is_static()) {</a>
<a name="ln448">      modifies_static_row_ = true;</a>
<a name="ln449">    } else {</a>
<a name="ln450">      modifies_primary_row_ = true;</a>
<a name="ln451">    }</a>
<a name="ln452">    if (modifies_static_row_ &amp;&amp; modifies_primary_row_) {</a>
<a name="ln453">      return Status::OK();</a>
<a name="ln454">    }</a>
<a name="ln455">  }</a>
<a name="ln456"> </a>
<a name="ln457">  // Check json column args (e.g. json-&gt;'key' or json-&gt;1)</a>
<a name="ln458">  for (auto&amp; arg : *json_col_args_) {</a>
<a name="ln459">    if (arg.desc()-&gt;is_static()) {</a>
<a name="ln460">      modifies_static_row_ = true;</a>
<a name="ln461">    } else {</a>
<a name="ln462">      modifies_primary_row_ = true;</a>
<a name="ln463">    }</a>
<a name="ln464">    if (modifies_static_row_ &amp;&amp; modifies_primary_row_) {</a>
<a name="ln465">      return Status::OK();</a>
<a name="ln466">    }</a>
<a name="ln467">  }</a>
<a name="ln468"> </a>
<a name="ln469">  return Status::OK();</a>
<a name="ln470">}</a>
<a name="ln471"> </a>
<a name="ln472">// Are we writing to static columns only, i.e. no range columns or non-static columns.</a>
<a name="ln473">bool PTDmlStmt::StaticColumnArgsOnly() const {</a>
<a name="ln474">  return modifies_static_row_ &amp;&amp; !modifies_primary_row_;</a>
<a name="ln475">}</a>
<a name="ln476"> </a>
<a name="ln477">//--------------------------------------------------------------------------------------------------</a>
<a name="ln478"> </a>
<a name="ln479">Status WhereExprState::AnalyzeColumnOp(SemContext *sem_context,</a>
<a name="ln480">                                       const PTRelationExpr *expr,</a>
<a name="ln481">                                       const ColumnDesc *col_desc,</a>
<a name="ln482">                                       PTExpr::SharedPtr value,</a>
<a name="ln483">                                       PTExprListNode::SharedPtr col_args) {</a>
<a name="ln484">  // Collecting all filtering expressions to help choosing INDEX when processing a DML.</a>
<a name="ln485">  filtering_exprs_-&gt;push_back(expr);</a>
<a name="ln486"> </a>
<a name="ln487">  // If this is a nested select from an uncovered index, ignore column that is uncovered.</a>
<a name="ln488">  if (col_desc == nullptr &amp;&amp; sem_context-&gt;IsUncoveredIndexSelect()) {</a>
<a name="ln489">    return Status::OK();</a>
<a name="ln490">  }</a>
<a name="ln491">  ColumnOpCounter&amp; counter = op_counters_-&gt;at(col_desc-&gt;index());</a>
<a name="ln492">  switch (expr-&gt;ql_op()) {</a>
<a name="ln493">    case QL_OP_EQUAL: {</a>
<a name="ln494">      counter.increase_eq(col_args != nullptr);</a>
<a name="ln495">      if (!counter.isValid()) {</a>
<a name="ln496">        return sem_context-&gt;Error(expr, &quot;Illogical condition for where clause&quot;,</a>
<a name="ln497">            ErrorCode::CQL_STATEMENT_INVALID);</a>
<a name="ln498">      }</a>
<a name="ln499"> </a>
<a name="ln500">      // Check that the column is being used correctly.</a>
<a name="ln501">      switch (statement_type_) {</a>
<a name="ln502">        case TreeNodeOpcode::kPTInsertStmt:</a>
<a name="ln503">        case TreeNodeOpcode::kPTUpdateStmt:</a>
<a name="ln504">        case TreeNodeOpcode::kPTDeleteStmt: {</a>
<a name="ln505">          if (!col_desc-&gt;is_primary()) {</a>
<a name="ln506">            return sem_context-&gt;Error(expr,</a>
<a name="ln507">                &quot;Non primary key cannot be used in where clause for write requests&quot;,</a>
<a name="ln508">                ErrorCode::CQL_STATEMENT_INVALID);</a>
<a name="ln509">          }</a>
<a name="ln510">          (*key_ops_)[col_desc-&gt;index()].Init(col_desc, value, QLOperator::QL_OP_EQUAL);</a>
<a name="ln511">          break;</a>
<a name="ln512">        }</a>
<a name="ln513">        case TreeNodeOpcode::kPTSelectStmt: {</a>
<a name="ln514">          if (col_desc-&gt;is_hash()) {</a>
<a name="ln515">            (*key_ops_)[col_desc-&gt;index()].Init(col_desc, value, QLOperator::QL_OP_EQUAL);</a>
<a name="ln516">          } else if (col_args != nullptr) {</a>
<a name="ln517">            if (col_desc-&gt;ql_type()-&gt;IsJson()) {</a>
<a name="ln518">              json_col_ops_-&gt;emplace_back(col_desc, col_args, value, expr-&gt;ql_op());</a>
<a name="ln519">            } else {</a>
<a name="ln520">              subscripted_col_ops_-&gt;emplace_back(col_desc, col_args, value, expr-&gt;ql_op());</a>
<a name="ln521">            }</a>
<a name="ln522">          } else {</a>
<a name="ln523">            ops_-&gt;emplace_back(col_desc, value, QLOperator::QL_OP_EQUAL);</a>
<a name="ln524">          }</a>
<a name="ln525">          break;</a>
<a name="ln526">        }</a>
<a name="ln527">        default:</a>
<a name="ln528">          return sem_context-&gt;Error(expr, &quot;Statement type cannot have where condition&quot;,</a>
<a name="ln529">              ErrorCode::CQL_STATEMENT_INVALID);</a>
<a name="ln530">      }</a>
<a name="ln531">      break;</a>
<a name="ln532">    }</a>
<a name="ln533"> </a>
<a name="ln534">    case QL_OP_LESS_THAN: FALLTHROUGH_INTENDED;</a>
<a name="ln535">    case QL_OP_LESS_THAN_EQUAL: FALLTHROUGH_INTENDED;</a>
<a name="ln536">    case QL_OP_GREATER_THAN_EQUAL: FALLTHROUGH_INTENDED;</a>
<a name="ln537">    case QL_OP_GREATER_THAN: {</a>
<a name="ln538"> </a>
<a name="ln539">      // Inequality conditions on hash columns are not allowed.</a>
<a name="ln540">      if (col_desc-&gt;is_hash()) {</a>
<a name="ln541">        return sem_context-&gt;Error(expr, &quot;Partition column cannot be used in this expression&quot;,</a>
<a name="ln542">            ErrorCode::CQL_STATEMENT_INVALID);</a>
<a name="ln543">      }</a>
<a name="ln544"> </a>
<a name="ln545">      // Check for illogical conditions.</a>
<a name="ln546">      if (col_args == nullptr) { // subcolumn conditions don't affect the condition counter.</a>
<a name="ln547">        if (expr-&gt;ql_op() == QL_OP_LESS_THAN || expr-&gt;ql_op() == QL_OP_LESS_THAN_EQUAL) {</a>
<a name="ln548">          counter.increase_lt(col_args != nullptr);</a>
<a name="ln549">        } else {</a>
<a name="ln550">          counter.increase_gt(col_args != nullptr);</a>
<a name="ln551">        }</a>
<a name="ln552"> </a>
<a name="ln553">        if (!counter.isValid()) {</a>
<a name="ln554">          return sem_context-&gt;Error(expr, &quot;Illogical condition for where clause&quot;,</a>
<a name="ln555">              ErrorCode::CQL_STATEMENT_INVALID);</a>
<a name="ln556">        }</a>
<a name="ln557">      }</a>
<a name="ln558"> </a>
<a name="ln559">      // Check that the column is being used correctly.</a>
<a name="ln560">      switch (statement_type_) {</a>
<a name="ln561">        case TreeNodeOpcode::kPTInsertStmt:</a>
<a name="ln562">        case TreeNodeOpcode::kPTUpdateStmt:</a>
<a name="ln563">          if (col_desc-&gt;is_primary()) {</a>
<a name="ln564">            return sem_context-&gt;Error(expr,</a>
<a name="ln565">                &quot;Range expressions are not supported for inserts and updates&quot;,</a>
<a name="ln566">                ErrorCode::CQL_STATEMENT_INVALID);</a>
<a name="ln567">          }</a>
<a name="ln568">          FALLTHROUGH_INTENDED;</a>
<a name="ln569">        case TreeNodeOpcode::kPTDeleteStmt: {</a>
<a name="ln570">          if (!col_desc-&gt;is_primary()) {</a>
<a name="ln571">            return sem_context-&gt;Error(expr,</a>
<a name="ln572">                &quot;Non primary key cannot be used in where clause for write requests&quot;,</a>
<a name="ln573">                ErrorCode::CQL_STATEMENT_INVALID);</a>
<a name="ln574">          }</a>
<a name="ln575">          ops_-&gt;emplace_back(col_desc, value, expr-&gt;ql_op());</a>
<a name="ln576">          break;</a>
<a name="ln577">        }</a>
<a name="ln578">        case TreeNodeOpcode::kPTSelectStmt: {</a>
<a name="ln579">          // Cache the column operator for execution.</a>
<a name="ln580">          if (col_args != nullptr) {</a>
<a name="ln581">            if (col_desc-&gt;ql_type()-&gt;IsJson()) {</a>
<a name="ln582">              json_col_ops_-&gt;emplace_back(col_desc, col_args, value, expr-&gt;ql_op());</a>
<a name="ln583">            } else {</a>
<a name="ln584">              subscripted_col_ops_-&gt;emplace_back(col_desc, col_args, value, expr-&gt;ql_op());</a>
<a name="ln585">            }</a>
<a name="ln586">          } else {</a>
<a name="ln587">            ops_-&gt;emplace_back(col_desc, value, expr-&gt;ql_op());</a>
<a name="ln588">          }</a>
<a name="ln589">          break;</a>
<a name="ln590">        }</a>
<a name="ln591">        default:</a>
<a name="ln592">          return sem_context-&gt;Error(expr, &quot;Statement type cannot have where condition&quot;,</a>
<a name="ln593">              ErrorCode::CQL_STATEMENT_INVALID);</a>
<a name="ln594">      }</a>
<a name="ln595">      break;</a>
<a name="ln596">    }</a>
<a name="ln597"> </a>
<a name="ln598">    case QL_OP_NOT_IN: FALLTHROUGH_INTENDED;</a>
<a name="ln599">    case QL_OP_IN: {</a>
<a name="ln600">      if (statement_type_ != TreeNodeOpcode::kPTSelectStmt) {</a>
<a name="ln601">        return sem_context-&gt;Error(expr, &quot;IN expression not supported for write operations&quot;,</a>
<a name="ln602">                                  ErrorCode::FEATURE_NOT_YET_IMPLEMENTED);</a>
<a name="ln603">      }</a>
<a name="ln604"> </a>
<a name="ln605">      if (col_args != nullptr) {</a>
<a name="ln606">        return sem_context-&gt;Error(expr, &quot;IN expression not supported for subscripted column&quot;,</a>
<a name="ln607">                                  ErrorCode::CQL_STATEMENT_INVALID);</a>
<a name="ln608">      }</a>
<a name="ln609"> </a>
<a name="ln610">      if(!value-&gt;has_no_column_ref()) {</a>
<a name="ln611">        return sem_context-&gt;Error(expr,</a>
<a name="ln612">            &quot;Expressions are not allowed as argument of IN condition.&quot;,</a>
<a name="ln613">            ErrorCode::CQL_STATEMENT_INVALID);</a>
<a name="ln614">      }</a>
<a name="ln615"> </a>
<a name="ln616">      counter.increase_in(col_args != nullptr);</a>
<a name="ln617">      if (!counter.isValid()) {</a>
<a name="ln618">        return sem_context-&gt;Error(expr, &quot;Illogical condition for where clause&quot;,</a>
<a name="ln619">                                  ErrorCode::CQL_STATEMENT_INVALID);</a>
<a name="ln620">      }</a>
<a name="ln621"> </a>
<a name="ln622">      if (expr-&gt;ql_op() == QL_OP_IN &amp;&amp; col_desc-&gt;is_hash()) {</a>
<a name="ln623">        (*key_ops_)[col_desc-&gt;index()].Init(col_desc, value, QLOperator::QL_OP_IN);</a>
<a name="ln624">      } else {</a>
<a name="ln625">        ops_-&gt;emplace_back(col_desc, value, expr-&gt;ql_op());</a>
<a name="ln626">      }</a>
<a name="ln627">      break;</a>
<a name="ln628">    }</a>
<a name="ln629"> </a>
<a name="ln630">    default:</a>
<a name="ln631">      return sem_context-&gt;Error(expr, &quot;Operator is not supported in where clause&quot;,</a>
<a name="ln632">                                ErrorCode::CQL_STATEMENT_INVALID);</a>
<a name="ln633">  }</a>
<a name="ln634"> </a>
<a name="ln635">  return Status::OK();</a>
<a name="ln636">}</a>
<a name="ln637"> </a>
<a name="ln638">Status WhereExprState::AnalyzeColumnFunction(SemContext *sem_context,</a>
<a name="ln639">                                             const PTRelationExpr *expr,</a>
<a name="ln640">                                             PTExpr::SharedPtr value,</a>
<a name="ln641">                                             PTBcall::SharedPtr call) {</a>
<a name="ln642">  switch (expr-&gt;ql_op()) {</a>
<a name="ln643">    case QL_OP_LESS_THAN:</a>
<a name="ln644">    case QL_OP_LESS_THAN_EQUAL:</a>
<a name="ln645">    case QL_OP_EQUAL:</a>
<a name="ln646">    case QL_OP_GREATER_THAN_EQUAL:</a>
<a name="ln647">    case QL_OP_IN:</a>
<a name="ln648">    case QL_OP_NOT_IN:</a>
<a name="ln649">    case QL_OP_GREATER_THAN: {</a>
<a name="ln650">      func_ops_-&gt;emplace_back(value, call, expr-&gt;ql_op());</a>
<a name="ln651">      break;</a>
<a name="ln652">    }</a>
<a name="ln653"> </a>
<a name="ln654">    default:</a>
<a name="ln655">      return sem_context-&gt;Error(expr, &quot;Operator is not supported in where clause&quot;,</a>
<a name="ln656">                                ErrorCode::CQL_STATEMENT_INVALID);</a>
<a name="ln657">  }</a>
<a name="ln658"> </a>
<a name="ln659">  // Check that if where clause is present, it must follow CQL rules.</a>
<a name="ln660">  return Status::OK();</a>
<a name="ln661">}</a>
<a name="ln662"> </a>
<a name="ln663">Status WhereExprState::AnalyzePartitionKeyOp(SemContext *sem_context,</a>
<a name="ln664">                                             const PTRelationExpr *expr,</a>
<a name="ln665">                                             PTExpr::SharedPtr value) {</a>
<a name="ln666">  switch (expr-&gt;ql_op()) {</a>
<a name="ln667">    case QL_OP_LESS_THAN: {</a>
<a name="ln668">      partition_key_counter_-&gt;increase_lt();</a>
<a name="ln669">      break;</a>
<a name="ln670">    }</a>
<a name="ln671">    case QL_OP_LESS_THAN_EQUAL: {</a>
<a name="ln672">      partition_key_counter_-&gt;increase_lt();</a>
<a name="ln673">      break;</a>
<a name="ln674">    }</a>
<a name="ln675">    case QL_OP_EQUAL: {</a>
<a name="ln676">      partition_key_counter_-&gt;increase_eq();</a>
<a name="ln677">      break;</a>
<a name="ln678">    }</a>
<a name="ln679">    case QL_OP_GREATER_THAN_EQUAL: {</a>
<a name="ln680">      partition_key_counter_-&gt;increase_gt();</a>
<a name="ln681">      break;</a>
<a name="ln682">    }</a>
<a name="ln683">    case QL_OP_GREATER_THAN: {</a>
<a name="ln684">      partition_key_counter_-&gt;increase_gt();</a>
<a name="ln685">      break;</a>
<a name="ln686">    }</a>
<a name="ln687"> </a>
<a name="ln688">    default:</a>
<a name="ln689">      return sem_context-&gt;Error(expr, &quot;Operator is not supported for token in where clause&quot;,</a>
<a name="ln690">                                ErrorCode::CQL_STATEMENT_INVALID);</a>
<a name="ln691">  }</a>
<a name="ln692"> </a>
<a name="ln693">  if (!partition_key_counter_-&gt;isValid()) {</a>
<a name="ln694">    return sem_context-&gt;Error(expr, &quot;Illogical where condition for token in where clause&quot;,</a>
<a name="ln695">                              ErrorCode::CQL_STATEMENT_INVALID);</a>
<a name="ln696">  }</a>
<a name="ln697"> </a>
<a name="ln698">  partition_key_ops_-&gt;emplace_back(expr-&gt;ql_op(), value);</a>
<a name="ln699">  return Status::OK();</a>
<a name="ln700">}</a>
<a name="ln701"> </a>
<a name="ln702">}  // namespace ql</a>
<a name="ln703">}  // namespace yb</a>

</code></pre>
<div class="balloon" rel="134"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="142"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="548"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'col_args != nullptr' is always false.</p></div>
<div class="balloon" rel="550"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'col_args != nullptr' is always false.</p></div>
<div class="balloon" rel="616"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'col_args != nullptr' is always false.</p></div>
<div class="balloon" rel="680"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 680, 684</p></div>
<div class="balloon" rel="668"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 668, 672</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
