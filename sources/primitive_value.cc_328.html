
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>primitive_value.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Copyright (c) YugaByte, Inc.</a>
<a name="ln2">//</a>
<a name="ln3">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln4">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln5">//</a>
<a name="ln6">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln7">//</a>
<a name="ln8">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln9">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln10">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln11">// under the License.</a>
<a name="ln12">//</a>
<a name="ln13"> </a>
<a name="ln14">#include &quot;yb/docdb/primitive_value.h&quot;</a>
<a name="ln15"> </a>
<a name="ln16">#include &lt;string&gt;</a>
<a name="ln17"> </a>
<a name="ln18">#include &lt;glog/logging.h&gt;</a>
<a name="ln19"> </a>
<a name="ln20">#include &quot;yb/common/jsonb.h&quot;</a>
<a name="ln21">#include &quot;yb/common/schema.h&quot;</a>
<a name="ln22">#include &quot;yb/common/ql_value.h&quot;</a>
<a name="ln23"> </a>
<a name="ln24">#include &quot;yb/docdb/doc_kv_util.h&quot;</a>
<a name="ln25">#include &quot;yb/docdb/subdocument.h&quot;</a>
<a name="ln26">#include &quot;yb/docdb/intent.h&quot;</a>
<a name="ln27">#include &quot;yb/gutil/stringprintf.h&quot;</a>
<a name="ln28">#include &quot;yb/gutil/strings/substitute.h&quot;</a>
<a name="ln29">#include &quot;yb/rocksutil/yb_rocksdb.h&quot;</a>
<a name="ln30">#include &quot;yb/util/bytes_formatter.h&quot;</a>
<a name="ln31">#include &quot;yb/util/compare_util.h&quot;</a>
<a name="ln32">#include &quot;yb/util/decimal.h&quot;</a>
<a name="ln33">#include &quot;yb/util/fast_varint.h&quot;</a>
<a name="ln34">#include &quot;yb/util/net/inetaddress.h&quot;</a>
<a name="ln35"> </a>
<a name="ln36">using std::string;</a>
<a name="ln37">using strings::Substitute;</a>
<a name="ln38">using yb::QLValuePB;</a>
<a name="ln39">using yb::common::Jsonb;</a>
<a name="ln40">using yb::util::Decimal;</a>
<a name="ln41">using yb::util::VarInt;</a>
<a name="ln42">using yb::FormatBytesAsStr;</a>
<a name="ln43">using yb::util::CompareUsingLessThan;</a>
<a name="ln44">using yb::util::FastAppendSignedVarIntToBuffer;</a>
<a name="ln45">using yb::util::FastDecodeSignedVarInt;</a>
<a name="ln46">using yb::util::kInt32SignBitFlipMask;</a>
<a name="ln47">using yb::util::AppendBigEndianUInt64;</a>
<a name="ln48">using yb::util::AppendBigEndianUInt32;</a>
<a name="ln49">using yb::util::DecodeInt64FromKey;</a>
<a name="ln50">using yb::util::DecodeFloatFromKey;</a>
<a name="ln51">using yb::util::DecodeDoubleFromKey;</a>
<a name="ln52"> </a>
<a name="ln53">// We're listing all non-primitive value types at the end of switch statement instead of using a</a>
<a name="ln54">// default clause so that we can ensure that we're handling all possible primitive value types</a>
<a name="ln55">// at compile time.</a>
<a name="ln56">#define IGNORE_NON_PRIMITIVE_VALUE_TYPES_IN_SWITCH \</a>
<a name="ln57">    case ValueType::kArray: FALLTHROUGH_INTENDED; \</a>
<a name="ln58">    case ValueType::kMergeFlags: FALLTHROUGH_INTENDED; \</a>
<a name="ln59">    case ValueType::kRowLock: FALLTHROUGH_INTENDED; \</a>
<a name="ln60">    case ValueType::kBitSet: FALLTHROUGH_INTENDED; \</a>
<a name="ln61">    case ValueType::kGroupEnd: FALLTHROUGH_INTENDED; \</a>
<a name="ln62">    case ValueType::kGroupEndDescending: FALLTHROUGH_INTENDED; \</a>
<a name="ln63">    case ValueType::kInvalid: FALLTHROUGH_INTENDED; \</a>
<a name="ln64">    case ValueType::kJsonb: FALLTHROUGH_INTENDED; \</a>
<a name="ln65">    case ValueType::kObject: FALLTHROUGH_INTENDED; \</a>
<a name="ln66">    case ValueType::kObsoleteIntentPrefix: FALLTHROUGH_INTENDED; \</a>
<a name="ln67">    case ValueType::kGreaterThanIntentType: FALLTHROUGH_INTENDED; \</a>
<a name="ln68">    case ValueType::kRedisList: FALLTHROUGH_INTENDED;            \</a>
<a name="ln69">    case ValueType::kRedisSet: FALLTHROUGH_INTENDED; \</a>
<a name="ln70">    case ValueType::kRedisSortedSet: FALLTHROUGH_INTENDED;  \</a>
<a name="ln71">    case ValueType::kRedisTS: FALLTHROUGH_INTENDED; \</a>
<a name="ln72">    case ValueType::kTombstone: FALLTHROUGH_INTENDED; \</a>
<a name="ln73">    case ValueType::kTtl: FALLTHROUGH_INTENDED; \</a>
<a name="ln74">    case ValueType::kUserTimestamp: \</a>
<a name="ln75">  break</a>
<a name="ln76"> </a>
<a name="ln77">namespace yb {</a>
<a name="ln78">namespace docdb {</a>
<a name="ln79"> </a>
<a name="ln80">namespace {</a>
<a name="ln81"> </a>
<a name="ln82">template &lt;class T&gt;</a>
<a name="ln83">string RealToString(T val) {</a>
<a name="ln84">  string s = std::to_string(val);</a>
<a name="ln85">  // Remove trailing zeros.</a>
<a name="ln86">  auto dot_pos = s.find('.');</a>
<a name="ln87">  if (dot_pos != string::npos) {</a>
<a name="ln88">    s.erase(std::max(dot_pos + 1, s.find_last_not_of('0')) + 1, string::npos);</a>
<a name="ln89">  }</a>
<a name="ln90">  if (s == &quot;0.0&quot; &amp;&amp; val != 0.0) {</a>
<a name="ln91">    // Use the exponential notation for small numbers that would otherwise look like a zero.</a>
<a name="ln92">    return StringPrintf(&quot;%E&quot;, val);</a>
<a name="ln93">  }</a>
<a name="ln94">  return s;</a>
<a name="ln95">}</a>
<a name="ln96"> </a>
<a name="ln97">} // anonymous namespace</a>
<a name="ln98"> </a>
<a name="ln99">const PrimitiveValue PrimitiveValue::kInvalid = PrimitiveValue(ValueType::kInvalid);</a>
<a name="ln100">const PrimitiveValue PrimitiveValue::kTombstone = PrimitiveValue(ValueType::kTombstone);</a>
<a name="ln101">const PrimitiveValue PrimitiveValue::kObject = PrimitiveValue(ValueType::kObject);</a>
<a name="ln102"> </a>
<a name="ln103">string PrimitiveValue::ToString() const {</a>
<a name="ln104">  switch (type_) {</a>
<a name="ln105">    case ValueType::kNullHigh: FALLTHROUGH_INTENDED;</a>
<a name="ln106">    case ValueType::kNullLow:</a>
<a name="ln107">      return &quot;null&quot;;</a>
<a name="ln108">    case ValueType::kCounter:</a>
<a name="ln109">      return &quot;counter&quot;;</a>
<a name="ln110">    case ValueType::kSSForward:</a>
<a name="ln111">      return &quot;SSforward&quot;;</a>
<a name="ln112">    case ValueType::kSSReverse:</a>
<a name="ln113">      return &quot;SSreverse&quot;;</a>
<a name="ln114">    case ValueType::kFalse: FALLTHROUGH_INTENDED;</a>
<a name="ln115">    case ValueType::kFalseDescending:</a>
<a name="ln116">      return &quot;false&quot;;</a>
<a name="ln117">    case ValueType::kTrue: FALLTHROUGH_INTENDED;</a>
<a name="ln118">    case ValueType::kTrueDescending:</a>
<a name="ln119">      return &quot;true&quot;;</a>
<a name="ln120">    case ValueType::kInvalid:</a>
<a name="ln121">      return &quot;invalid&quot;;</a>
<a name="ln122">    case ValueType::kStringDescending:</a>
<a name="ln123">    case ValueType::kString:</a>
<a name="ln124">      return FormatBytesAsStr(str_val_);</a>
<a name="ln125">    case ValueType::kInt32Descending: FALLTHROUGH_INTENDED;</a>
<a name="ln126">    case ValueType::kInt32:</a>
<a name="ln127">      return std::to_string(int32_val_);</a>
<a name="ln128">    case ValueType::kUInt32:</a>
<a name="ln129">    case ValueType::kUInt32Descending:</a>
<a name="ln130">      return std::to_string(uint32_val_);</a>
<a name="ln131">    case ValueType::kUInt64:  FALLTHROUGH_INTENDED;</a>
<a name="ln132">    case ValueType::kUInt64Descending:</a>
<a name="ln133">      return std::to_string(uint64_val_);</a>
<a name="ln134">    case ValueType::kInt64Descending: FALLTHROUGH_INTENDED;</a>
<a name="ln135">    case ValueType::kInt64:</a>
<a name="ln136">      return std::to_string(int64_val_);</a>
<a name="ln137">    case ValueType::kFloatDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln138">    case ValueType::kFloat:</a>
<a name="ln139">      return RealToString(float_val_);</a>
<a name="ln140">    case ValueType::kFrozenDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln141">    case ValueType::kFrozen: {</a>
<a name="ln142">      std::stringstream ss;</a>
<a name="ln143">      bool first = true;</a>
<a name="ln144">      ss &lt;&lt; &quot;&lt;&quot;;</a>
<a name="ln145">      for (const auto&amp; pv : *frozen_val_) {</a>
<a name="ln146">        if (first) {</a>
<a name="ln147">          first = false;</a>
<a name="ln148">        } else {</a>
<a name="ln149">          ss &lt;&lt; &quot;,&quot;;</a>
<a name="ln150">        }</a>
<a name="ln151">        ss &lt;&lt; pv.ToString();</a>
<a name="ln152">      }</a>
<a name="ln153">      ss &lt;&lt; &quot;&gt;&quot;;</a>
<a name="ln154">      return ss.str();</a>
<a name="ln155">    }</a>
<a name="ln156">    case ValueType::kDoubleDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln157">    case ValueType::kDouble:</a>
<a name="ln158">      return RealToString(double_val_);</a>
<a name="ln159">    case ValueType::kDecimalDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln160">    case ValueType::kDecimal: {</a>
<a name="ln161">      util::Decimal decimal;</a>
<a name="ln162">      auto status = decimal.DecodeFromComparable(decimal_val_);</a>
<a name="ln163">      if (!status.ok()) {</a>
<a name="ln164">        LOG(ERROR) &lt;&lt; &quot;Unable to decode decimal&quot;;</a>
<a name="ln165">        return &quot;&quot;;</a>
<a name="ln166">      }</a>
<a name="ln167">      return decimal.ToString();</a>
<a name="ln168">    }</a>
<a name="ln169">    case ValueType::kVarIntDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln170">    case ValueType::kVarInt: {</a>
<a name="ln171">      util::VarInt varint;</a>
<a name="ln172">      auto status = varint.DecodeFromComparable(varint_val_);</a>
<a name="ln173">      if (!status.ok()) {</a>
<a name="ln174">        LOG(ERROR) &lt;&lt; &quot;Unable to decode varint: &quot; &lt;&lt; status.message().ToString();</a>
<a name="ln175">        return &quot;&quot;;</a>
<a name="ln176">      }</a>
<a name="ln177">      return varint.ToString();</a>
<a name="ln178">    }</a>
<a name="ln179">    case ValueType::kTimestampDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln180">    case ValueType::kTimestamp:</a>
<a name="ln181">      return timestamp_val_.ToString();</a>
<a name="ln182">    case ValueType::kInetaddressDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln183">    case ValueType::kInetaddress:</a>
<a name="ln184">      return inetaddress_val_-&gt;ToString();</a>
<a name="ln185">    case ValueType::kJsonb:</a>
<a name="ln186">      return FormatBytesAsStr(json_val_);</a>
<a name="ln187">    case ValueType::kUuidDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln188">    case ValueType::kUuid:</a>
<a name="ln189">      return uuid_val_.ToString();</a>
<a name="ln190">    case ValueType::kArrayIndex:</a>
<a name="ln191">      return Substitute(&quot;ArrayIndex($0)&quot;, int64_val_);</a>
<a name="ln192">    case ValueType::kHybridTime:</a>
<a name="ln193">      return hybrid_time_val_.ToString();</a>
<a name="ln194">    case ValueType::kUInt16Hash:</a>
<a name="ln195">      return Substitute(&quot;UInt16Hash($0)&quot;, uint16_val_);</a>
<a name="ln196">    case ValueType::kColumnId:</a>
<a name="ln197">      return Substitute(&quot;ColumnId($0)&quot;, column_id_val_);</a>
<a name="ln198">    case ValueType::kSystemColumnId:</a>
<a name="ln199">      return Substitute(&quot;SystemColumnId($0)&quot;, column_id_val_);</a>
<a name="ln200">    case ValueType::kObject:</a>
<a name="ln201">      return &quot;{}&quot;;</a>
<a name="ln202">    case ValueType::kRedisSet:</a>
<a name="ln203">      return &quot;()&quot;;</a>
<a name="ln204">    case ValueType::kRedisTS:</a>
<a name="ln205">      return &quot;&lt;&gt;&quot;;</a>
<a name="ln206">    case ValueType::kRedisSortedSet:</a>
<a name="ln207">      return &quot;(-&gt;)&quot;;</a>
<a name="ln208">    case ValueType::kTombstone:</a>
<a name="ln209">      return &quot;DEL&quot;;</a>
<a name="ln210">    case ValueType::kRedisList: FALLTHROUGH_INTENDED;</a>
<a name="ln211">    case ValueType::kArray:</a>
<a name="ln212">      return &quot;[]&quot;;</a>
<a name="ln213">    case ValueType::kTableId:</a>
<a name="ln214">      return Format(&quot;TableId($0)&quot;, uuid_val_.ToString());</a>
<a name="ln215">    case ValueType::kPgTableOid:</a>
<a name="ln216">      return Format(&quot;PgTableOid($0)&quot;, uint32_val_);</a>
<a name="ln217">    case ValueType::kTransactionApplyState: FALLTHROUGH_INTENDED;</a>
<a name="ln218">    case ValueType::kTransactionId:</a>
<a name="ln219">      return Substitute(&quot;TransactionId($0)&quot;, uuid_val_.ToString());</a>
<a name="ln220">    case ValueType::kWriteId:</a>
<a name="ln221">      return Format(&quot;WriteId($0)&quot;, int32_val_);</a>
<a name="ln222">    case ValueType::kIntentTypeSet:</a>
<a name="ln223">      return Format(&quot;Intents($0)&quot;, IntentTypeSet(uint16_val_));</a>
<a name="ln224">    case ValueType::kObsoleteIntentTypeSet:</a>
<a name="ln225">      return Format(&quot;ObsoleteIntents($0)&quot;, uint16_val_);</a>
<a name="ln226">    case ValueType::kObsoleteIntentType:</a>
<a name="ln227">      return Format(&quot;Intent($0)&quot;, uint16_val_);</a>
<a name="ln228">    case ValueType::kMergeFlags: FALLTHROUGH_INTENDED;</a>
<a name="ln229">    case ValueType::kRowLock: FALLTHROUGH_INTENDED;</a>
<a name="ln230">    case ValueType::kBitSet: FALLTHROUGH_INTENDED;</a>
<a name="ln231">    case ValueType::kGroupEnd: FALLTHROUGH_INTENDED;</a>
<a name="ln232">    case ValueType::kGroupEndDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln233">    case ValueType::kTtl: FALLTHROUGH_INTENDED;</a>
<a name="ln234">    case ValueType::kUserTimestamp: FALLTHROUGH_INTENDED;</a>
<a name="ln235">    case ValueType::kObsoleteIntentPrefix: FALLTHROUGH_INTENDED;</a>
<a name="ln236">    case ValueType::kGreaterThanIntentType:</a>
<a name="ln237">      break;</a>
<a name="ln238">    case ValueType::kLowest:</a>
<a name="ln239">      return &quot;-Inf&quot;;</a>
<a name="ln240">    case ValueType::kHighest:</a>
<a name="ln241">      return &quot;+Inf&quot;;</a>
<a name="ln242">    case ValueType::kMaxByte:</a>
<a name="ln243">      return &quot;0xff&quot;;</a>
<a name="ln244">  }</a>
<a name="ln245">  FATAL_INVALID_ENUM_VALUE(ValueType, type_);</a>
<a name="ln246">}</a>
<a name="ln247"> </a>
<a name="ln248">void PrimitiveValue::AppendToKey(KeyBytes* key_bytes) const {</a>
<a name="ln249">  key_bytes-&gt;AppendValueType(type_);</a>
<a name="ln250">  switch (type_) {</a>
<a name="ln251">    case ValueType::kLowest: return;</a>
<a name="ln252">    case ValueType::kHighest: return;</a>
<a name="ln253">    case ValueType::kMaxByte: return;</a>
<a name="ln254">    case ValueType::kNullHigh: return;</a>
<a name="ln255">    case ValueType::kNullLow: return;</a>
<a name="ln256">    case ValueType::kCounter: return;</a>
<a name="ln257">    case ValueType::kSSForward: return;</a>
<a name="ln258">    case ValueType::kSSReverse: return;</a>
<a name="ln259">    case ValueType::kFalse: return;</a>
<a name="ln260">    case ValueType::kTrue: return;</a>
<a name="ln261">    case ValueType::kFalseDescending: return;</a>
<a name="ln262">    case ValueType::kTrueDescending: return;</a>
<a name="ln263"> </a>
<a name="ln264">    case ValueType::kString:</a>
<a name="ln265">      key_bytes-&gt;AppendString(str_val_);</a>
<a name="ln266">      return;</a>
<a name="ln267"> </a>
<a name="ln268">    case ValueType::kStringDescending:</a>
<a name="ln269">      key_bytes-&gt;AppendDescendingString(str_val_);</a>
<a name="ln270">      return;</a>
<a name="ln271"> </a>
<a name="ln272">    case ValueType::kInt64:</a>
<a name="ln273">      key_bytes-&gt;AppendInt64(int64_val_);</a>
<a name="ln274">      return;</a>
<a name="ln275"> </a>
<a name="ln276">    case ValueType::kInt32: FALLTHROUGH_INTENDED;</a>
<a name="ln277">    case ValueType::kWriteId:</a>
<a name="ln278">      key_bytes-&gt;AppendInt32(int32_val_);</a>
<a name="ln279">      return;</a>
<a name="ln280"> </a>
<a name="ln281">    case ValueType::kPgTableOid: FALLTHROUGH_INTENDED;</a>
<a name="ln282">    case ValueType::kUInt32:</a>
<a name="ln283">      key_bytes-&gt;AppendUInt32(uint32_val_);</a>
<a name="ln284">      return;</a>
<a name="ln285"> </a>
<a name="ln286">    case ValueType::kUInt32Descending:</a>
<a name="ln287">      key_bytes-&gt;AppendDescendingUInt32(uint32_val_);</a>
<a name="ln288">      return;</a>
<a name="ln289"> </a>
<a name="ln290">    case ValueType::kInt32Descending:</a>
<a name="ln291">      key_bytes-&gt;AppendDescendingInt32(int32_val_);</a>
<a name="ln292">      return;</a>
<a name="ln293"> </a>
<a name="ln294">    case ValueType::kInt64Descending:</a>
<a name="ln295">      key_bytes-&gt;AppendDescendingInt64(int64_val_);</a>
<a name="ln296">      return;</a>
<a name="ln297"> </a>
<a name="ln298">    case ValueType::kUInt64:</a>
<a name="ln299">      key_bytes-&gt;AppendUInt64(uint64_val_);</a>
<a name="ln300">      return;</a>
<a name="ln301"> </a>
<a name="ln302">    case ValueType::kUInt64Descending:</a>
<a name="ln303">      key_bytes-&gt;AppendDescendingUInt64(uint64_val_);</a>
<a name="ln304">      return;</a>
<a name="ln305"> </a>
<a name="ln306">    case ValueType::kDouble:</a>
<a name="ln307">      key_bytes-&gt;AppendDouble(double_val_);</a>
<a name="ln308">      return;</a>
<a name="ln309"> </a>
<a name="ln310">    case ValueType::kDoubleDescending:</a>
<a name="ln311">      key_bytes-&gt;AppendDescendingDouble(double_val_);</a>
<a name="ln312">      return;</a>
<a name="ln313"> </a>
<a name="ln314">    case ValueType::kFloat:</a>
<a name="ln315">      key_bytes-&gt;AppendFloat(float_val_);</a>
<a name="ln316">      return;</a>
<a name="ln317"> </a>
<a name="ln318">    case ValueType::kFloatDescending:</a>
<a name="ln319">      key_bytes-&gt;AppendDescendingFloat(float_val_);</a>
<a name="ln320">      return;</a>
<a name="ln321"> </a>
<a name="ln322">    case ValueType::kFrozenDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln323">    case ValueType::kFrozen: {</a>
<a name="ln324">      for (const auto&amp; pv : *frozen_val_) {</a>
<a name="ln325">        pv.AppendToKey(key_bytes);</a>
<a name="ln326">      }</a>
<a name="ln327">      if (type_ == ValueType::kFrozenDescending) {</a>
<a name="ln328">        key_bytes-&gt;AppendValueType(ValueType::kGroupEndDescending);</a>
<a name="ln329">      } else {</a>
<a name="ln330">        key_bytes-&gt;AppendValueType(ValueType::kGroupEnd);</a>
<a name="ln331">      }</a>
<a name="ln332">      return;</a>
<a name="ln333">    }</a>
<a name="ln334"> </a>
<a name="ln335">    case ValueType::kDecimal:</a>
<a name="ln336">      key_bytes-&gt;AppendDecimal(decimal_val_);</a>
<a name="ln337">      return;</a>
<a name="ln338"> </a>
<a name="ln339">    case ValueType::kDecimalDescending:</a>
<a name="ln340">      key_bytes-&gt;AppendDecimalDescending(decimal_val_);</a>
<a name="ln341">      return;</a>
<a name="ln342"> </a>
<a name="ln343">    case ValueType::kVarInt:</a>
<a name="ln344">      key_bytes-&gt;AppendVarInt(varint_val_);</a>
<a name="ln345">      return;</a>
<a name="ln346"> </a>
<a name="ln347">    case ValueType::kVarIntDescending:</a>
<a name="ln348">      key_bytes-&gt;AppendVarIntDescending(varint_val_);</a>
<a name="ln349">      return;</a>
<a name="ln350"> </a>
<a name="ln351">    case ValueType::kTimestamp:</a>
<a name="ln352">      key_bytes-&gt;AppendInt64(timestamp_val_.ToInt64());</a>
<a name="ln353">      return;</a>
<a name="ln354"> </a>
<a name="ln355">    case ValueType::kTimestampDescending:</a>
<a name="ln356">      key_bytes-&gt;AppendDescendingInt64(timestamp_val_.ToInt64());</a>
<a name="ln357">      return;</a>
<a name="ln358"> </a>
<a name="ln359">    case ValueType::kInetaddress: {</a>
<a name="ln360">      std::string bytes;</a>
<a name="ln361">      CHECK_OK(inetaddress_val_-&gt;ToBytes(&amp;bytes));</a>
<a name="ln362">      key_bytes-&gt;AppendString(bytes);</a>
<a name="ln363">      return;</a>
<a name="ln364">    }</a>
<a name="ln365"> </a>
<a name="ln366">    case ValueType::kInetaddressDescending: {</a>
<a name="ln367">      std::string bytes;</a>
<a name="ln368">      CHECK_OK(inetaddress_val_-&gt;ToBytes(&amp;bytes));</a>
<a name="ln369">      key_bytes-&gt;AppendDescendingString(bytes);</a>
<a name="ln370">      return;</a>
<a name="ln371">    }</a>
<a name="ln372"> </a>
<a name="ln373">    case ValueType::kTransactionApplyState: FALLTHROUGH_INTENDED;</a>
<a name="ln374">    case ValueType::kTransactionId: FALLTHROUGH_INTENDED;</a>
<a name="ln375">    case ValueType::kTableId: FALLTHROUGH_INTENDED;</a>
<a name="ln376">    case ValueType::kUuid: {</a>
<a name="ln377">      std::string bytes;</a>
<a name="ln378">      uuid_val_.EncodeToComparable(&amp;bytes);</a>
<a name="ln379">      key_bytes-&gt;AppendString(bytes);</a>
<a name="ln380">      return;</a>
<a name="ln381">    }</a>
<a name="ln382"> </a>
<a name="ln383">    case ValueType::kUuidDescending: {</a>
<a name="ln384">      std::string bytes;</a>
<a name="ln385">      uuid_val_.EncodeToComparable(&amp;bytes);</a>
<a name="ln386">      key_bytes-&gt;AppendDescendingString(bytes);</a>
<a name="ln387">      return;</a>
<a name="ln388">    }</a>
<a name="ln389"> </a>
<a name="ln390">    case ValueType::kArrayIndex:</a>
<a name="ln391">      key_bytes-&gt;AppendInt64(int64_val_);</a>
<a name="ln392">      return;</a>
<a name="ln393"> </a>
<a name="ln394">    case ValueType::kHybridTime:</a>
<a name="ln395">      hybrid_time_val_.AppendEncodedInDocDbFormat(key_bytes-&gt;mutable_data());</a>
<a name="ln396">      return;</a>
<a name="ln397"> </a>
<a name="ln398">    case ValueType::kUInt16Hash:</a>
<a name="ln399">      key_bytes-&gt;AppendUInt16(uint16_val_);</a>
<a name="ln400">      return;</a>
<a name="ln401"> </a>
<a name="ln402">    case ValueType::kColumnId: FALLTHROUGH_INTENDED;</a>
<a name="ln403">    case ValueType::kSystemColumnId:</a>
<a name="ln404">      key_bytes-&gt;AppendColumnId(column_id_val_);</a>
<a name="ln405">      return;</a>
<a name="ln406"> </a>
<a name="ln407">    case ValueType::kObsoleteIntentType:</a>
<a name="ln408">      key_bytes-&gt;AppendIntentTypeSet(ObsoleteIntentTypeToSet(uint16_val_));</a>
<a name="ln409">      return;</a>
<a name="ln410"> </a>
<a name="ln411">    case ValueType::kObsoleteIntentTypeSet:</a>
<a name="ln412">      key_bytes-&gt;AppendIntentTypeSet(ObsoleteIntentTypeSetToNew(uint16_val_));</a>
<a name="ln413">      return;</a>
<a name="ln414"> </a>
<a name="ln415">    case ValueType::kIntentTypeSet:</a>
<a name="ln416">      key_bytes-&gt;AppendIntentTypeSet(IntentTypeSet(uint16_val_));</a>
<a name="ln417">      return;</a>
<a name="ln418"> </a>
<a name="ln419">    IGNORE_NON_PRIMITIVE_VALUE_TYPES_IN_SWITCH;</a>
<a name="ln420">  }</a>
<a name="ln421">  FATAL_INVALID_ENUM_VALUE(ValueType, type_);</a>
<a name="ln422">}</a>
<a name="ln423"> </a>
<a name="ln424">string PrimitiveValue::ToValue() const {</a>
<a name="ln425">  string result;</a>
<a name="ln426">  result.push_back(static_cast&lt;char&gt;(type_));</a>
<a name="ln427">  switch (type_) {</a>
<a name="ln428">    case ValueType::kNullHigh: FALLTHROUGH_INTENDED;</a>
<a name="ln429">    case ValueType::kNullLow: FALLTHROUGH_INTENDED;</a>
<a name="ln430">    case ValueType::kCounter: FALLTHROUGH_INTENDED;</a>
<a name="ln431">    case ValueType::kSSForward: FALLTHROUGH_INTENDED;</a>
<a name="ln432">    case ValueType::kSSReverse: FALLTHROUGH_INTENDED;</a>
<a name="ln433">    case ValueType::kFalse: FALLTHROUGH_INTENDED;</a>
<a name="ln434">    case ValueType::kTrue: FALLTHROUGH_INTENDED;</a>
<a name="ln435">    case ValueType::kFalseDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln436">    case ValueType::kTrueDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln437">    case ValueType::kTombstone: FALLTHROUGH_INTENDED;</a>
<a name="ln438">    case ValueType::kObject: FALLTHROUGH_INTENDED;</a>
<a name="ln439">    case ValueType::kArray: FALLTHROUGH_INTENDED;</a>
<a name="ln440">    case ValueType::kRedisTS: FALLTHROUGH_INTENDED;</a>
<a name="ln441">    case ValueType::kRedisList: FALLTHROUGH_INTENDED;</a>
<a name="ln442">    case ValueType::kRedisSortedSet: FALLTHROUGH_INTENDED;</a>
<a name="ln443">    case ValueType::kRedisSet: return result;</a>
<a name="ln444"> </a>
<a name="ln445">    case ValueType::kStringDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln446">    case ValueType::kString:</a>
<a name="ln447">      // No zero encoding necessary when storing the string in a value.</a>
<a name="ln448">      result.append(str_val_);</a>
<a name="ln449">      return result;</a>
<a name="ln450"> </a>
<a name="ln451">    case ValueType::kInt32Descending: FALLTHROUGH_INTENDED;</a>
<a name="ln452">    case ValueType::kInt32: FALLTHROUGH_INTENDED;</a>
<a name="ln453">    case ValueType::kWriteId:</a>
<a name="ln454">      AppendBigEndianUInt32(int32_val_, &amp;result);</a>
<a name="ln455">      return result;</a>
<a name="ln456"> </a>
<a name="ln457">    case ValueType::kPgTableOid: FALLTHROUGH_INTENDED;</a>
<a name="ln458">    case ValueType::kUInt32Descending: FALLTHROUGH_INTENDED;</a>
<a name="ln459">    case ValueType::kUInt32:</a>
<a name="ln460">      AppendBigEndianUInt32(uint32_val_, &amp;result);</a>
<a name="ln461">      return result;</a>
<a name="ln462"> </a>
<a name="ln463">    case ValueType::kUInt64Descending: FALLTHROUGH_INTENDED;</a>
<a name="ln464">    case ValueType::kUInt64:</a>
<a name="ln465">      AppendBigEndianUInt64(uint64_val_, &amp;result);</a>
<a name="ln466">      return result;</a>
<a name="ln467"> </a>
<a name="ln468">    case ValueType::kInt64Descending: FALLTHROUGH_INTENDED;</a>
<a name="ln469">    case ValueType::kInt64:</a>
<a name="ln470">      AppendBigEndianUInt64(int64_val_, &amp;result);</a>
<a name="ln471">      return result;</a>
<a name="ln472"> </a>
<a name="ln473">    case ValueType::kArrayIndex:</a>
<a name="ln474">      LOG(FATAL) &lt;&lt; &quot;Array index cannot be stored in a value&quot;;</a>
<a name="ln475">      return result;</a>
<a name="ln476"> </a>
<a name="ln477">    case ValueType::kDoubleDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln478">    case ValueType::kDouble:</a>
<a name="ln479">      static_assert(sizeof(double) == sizeof(uint64_t),</a>
<a name="ln480">                    &quot;Expected double to be the same size as uint64_t&quot;);</a>
<a name="ln481">      // TODO: make sure this is a safe and reasonable representation for doubles.</a>
<a name="ln482">      AppendBigEndianUInt64(int64_val_, &amp;result);</a>
<a name="ln483">      return result;</a>
<a name="ln484"> </a>
<a name="ln485">    case ValueType::kFloatDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln486">    case ValueType::kFloat:</a>
<a name="ln487">      static_assert(sizeof(float) == sizeof(uint32_t),</a>
<a name="ln488">                    &quot;Expected float to be the same size as uint32_t&quot;);</a>
<a name="ln489">      // TODO: make sure this is a safe and reasonable representation for floats.</a>
<a name="ln490">      AppendBigEndianUInt32(int32_val_, &amp;result);</a>
<a name="ln491">      return result;</a>
<a name="ln492"> </a>
<a name="ln493">    case ValueType::kFrozenDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln494">    case ValueType::kFrozen: {</a>
<a name="ln495">      KeyBytes key(result);</a>
<a name="ln496">      for (const auto &amp;pv : *frozen_val_) {</a>
<a name="ln497">        pv.AppendToKey(&amp;key);</a>
<a name="ln498">      }</a>
<a name="ln499"> </a>
<a name="ln500">      // Still need the end marker for values in case of nested frozen collections.</a>
<a name="ln501">      if (type_ == ValueType::kFrozenDescending) {</a>
<a name="ln502">        key.AppendValueType(ValueType::kGroupEndDescending);</a>
<a name="ln503">      } else {</a>
<a name="ln504">        key.AppendValueType(ValueType::kGroupEnd);</a>
<a name="ln505">      }</a>
<a name="ln506">      return key.ToStringBuffer();</a>
<a name="ln507">    }</a>
<a name="ln508"> </a>
<a name="ln509">    case ValueType::kDecimalDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln510">    case ValueType::kDecimal:</a>
<a name="ln511">      result.append(decimal_val_);</a>
<a name="ln512">      return result;</a>
<a name="ln513"> </a>
<a name="ln514">    case ValueType::kVarIntDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln515">    case ValueType::kVarInt:</a>
<a name="ln516">      result.append(varint_val_);</a>
<a name="ln517">      return result;</a>
<a name="ln518"> </a>
<a name="ln519">    case ValueType::kTimestampDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln520">    case ValueType::kTimestamp:</a>
<a name="ln521">      AppendBigEndianUInt64(timestamp_val_.ToInt64(), &amp;result);</a>
<a name="ln522">      return result;</a>
<a name="ln523"> </a>
<a name="ln524">    case ValueType::kInetaddressDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln525">    case ValueType::kInetaddress: {</a>
<a name="ln526">      std::string bytes;</a>
<a name="ln527">      CHECK_OK(inetaddress_val_-&gt;ToBytes(&amp;bytes))</a>
<a name="ln528">      result.append(bytes);</a>
<a name="ln529">      return result;</a>
<a name="ln530">    }</a>
<a name="ln531"> </a>
<a name="ln532">    case ValueType::kJsonb: {</a>
<a name="ln533">      // Append the jsonb flags.</a>
<a name="ln534">      int64_t jsonb_flags = kCompleteJsonb;</a>
<a name="ln535">      AppendBigEndianUInt64(jsonb_flags, &amp;result);</a>
<a name="ln536"> </a>
<a name="ln537">      // Append the jsonb serialized blob.</a>
<a name="ln538">      result.append(json_val_);</a>
<a name="ln539">      return result;</a>
<a name="ln540">    }</a>
<a name="ln541"> </a>
<a name="ln542">    case ValueType::kUuidDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln543">    case ValueType::kTransactionApplyState: FALLTHROUGH_INTENDED;</a>
<a name="ln544">    case ValueType::kTransactionId: FALLTHROUGH_INTENDED;</a>
<a name="ln545">    case ValueType::kTableId: FALLTHROUGH_INTENDED;</a>
<a name="ln546">    case ValueType::kUuid: {</a>
<a name="ln547">      std::string bytes;</a>
<a name="ln548">      uuid_val_.EncodeToComparable(&amp;bytes);</a>
<a name="ln549">      result.append(bytes);</a>
<a name="ln550">      return result;</a>
<a name="ln551">    }</a>
<a name="ln552"> </a>
<a name="ln553">    case ValueType::kUInt16Hash:</a>
<a name="ln554">      // Hashes are not allowed in a value.</a>
<a name="ln555">      break;</a>
<a name="ln556"> </a>
<a name="ln557">    case ValueType::kIntentTypeSet: FALLTHROUGH_INTENDED;</a>
<a name="ln558">    case ValueType::kObsoleteIntentTypeSet: FALLTHROUGH_INTENDED;</a>
<a name="ln559">    case ValueType::kObsoleteIntentType: FALLTHROUGH_INTENDED;</a>
<a name="ln560">    case ValueType::kMergeFlags: FALLTHROUGH_INTENDED;</a>
<a name="ln561">    case ValueType::kRowLock: FALLTHROUGH_INTENDED;</a>
<a name="ln562">    case ValueType::kBitSet: FALLTHROUGH_INTENDED;</a>
<a name="ln563">    case ValueType::kGroupEnd: FALLTHROUGH_INTENDED;</a>
<a name="ln564">    case ValueType::kGroupEndDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln565">    case ValueType::kObsoleteIntentPrefix: FALLTHROUGH_INTENDED;</a>
<a name="ln566">    case ValueType::kGreaterThanIntentType: FALLTHROUGH_INTENDED;</a>
<a name="ln567">    case ValueType::kTtl: FALLTHROUGH_INTENDED;</a>
<a name="ln568">    case ValueType::kUserTimestamp: FALLTHROUGH_INTENDED;</a>
<a name="ln569">    case ValueType::kColumnId: FALLTHROUGH_INTENDED;</a>
<a name="ln570">    case ValueType::kSystemColumnId: FALLTHROUGH_INTENDED;</a>
<a name="ln571">    case ValueType::kHybridTime: FALLTHROUGH_INTENDED;</a>
<a name="ln572">    case ValueType::kInvalid: FALLTHROUGH_INTENDED;</a>
<a name="ln573">    case ValueType::kLowest: FALLTHROUGH_INTENDED;</a>
<a name="ln574">    case ValueType::kHighest: FALLTHROUGH_INTENDED;</a>
<a name="ln575">    case ValueType::kMaxByte:</a>
<a name="ln576">      break;</a>
<a name="ln577">  }</a>
<a name="ln578">  FATAL_INVALID_ENUM_VALUE(ValueType, type_);</a>
<a name="ln579">}</a>
<a name="ln580"> </a>
<a name="ln581">Status PrimitiveValue::DecodeFromKey(rocksdb::Slice* slice) {</a>
<a name="ln582">  return DecodeKey(slice, this);</a>
<a name="ln583">}</a>
<a name="ln584"> </a>
<a name="ln585">Status PrimitiveValue::DecodeKey(rocksdb::Slice* slice, PrimitiveValue* out) {</a>
<a name="ln586">  // A copy for error reporting.</a>
<a name="ln587">  const rocksdb::Slice input_slice(*slice);</a>
<a name="ln588"> </a>
<a name="ln589">  if (slice-&gt;empty()) {</a>
<a name="ln590">    return STATUS_SUBSTITUTE(Corruption,</a>
<a name="ln591">        &quot;Cannot decode a primitive value in the key encoding format from an empty slice: $0&quot;,</a>
<a name="ln592">        ToShortDebugStr(input_slice));</a>
<a name="ln593">  }</a>
<a name="ln594">  ValueType value_type = ConsumeValueType(slice);</a>
<a name="ln595">  ValueType dummy_type;</a>
<a name="ln596">  ValueType&amp; type_ref = out ? out-&gt;type_ : dummy_type;</a>
<a name="ln597"> </a>
<a name="ln598">  if (out) {</a>
<a name="ln599">    out-&gt;~PrimitiveValue();</a>
<a name="ln600">    // Ensure we are not leaving the object in an invalid state in case e.g. an exception is thrown</a>
<a name="ln601">    // due to inability to allocate memory.</a>
<a name="ln602">  }</a>
<a name="ln603">  type_ref = ValueType::kNullLow;</a>
<a name="ln604"> </a>
<a name="ln605">  switch (value_type) {</a>
<a name="ln606">    case ValueType::kNullHigh: FALLTHROUGH_INTENDED;</a>
<a name="ln607">    case ValueType::kNullLow: FALLTHROUGH_INTENDED;</a>
<a name="ln608">    case ValueType::kCounter: FALLTHROUGH_INTENDED;</a>
<a name="ln609">    case ValueType::kSSForward: FALLTHROUGH_INTENDED;</a>
<a name="ln610">    case ValueType::kSSReverse: FALLTHROUGH_INTENDED;</a>
<a name="ln611">    case ValueType::kFalse: FALLTHROUGH_INTENDED;</a>
<a name="ln612">    case ValueType::kTrue: FALLTHROUGH_INTENDED;</a>
<a name="ln613">    case ValueType::kFalseDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln614">    case ValueType::kTrueDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln615">    case ValueType::kHighest: FALLTHROUGH_INTENDED;</a>
<a name="ln616">    case ValueType::kLowest:</a>
<a name="ln617">      type_ref = value_type;</a>
<a name="ln618">      return Status::OK();</a>
<a name="ln619"> </a>
<a name="ln620">    case ValueType::kStringDescending: {</a>
<a name="ln621">      if (out) {</a>
<a name="ln622">        string result;</a>
<a name="ln623">        RETURN_NOT_OK(DecodeComplementZeroEncodedStr(slice, &amp;result));</a>
<a name="ln624">        new (&amp;out-&gt;str_val_) string(std::move(result));</a>
<a name="ln625">      } else {</a>
<a name="ln626">        RETURN_NOT_OK(DecodeComplementZeroEncodedStr(slice, nullptr));</a>
<a name="ln627">      }</a>
<a name="ln628">      // Only set type to string after string field initialization succeeds.</a>
<a name="ln629">      type_ref = value_type;</a>
<a name="ln630">      return Status::OK();</a>
<a name="ln631">    }</a>
<a name="ln632"> </a>
<a name="ln633">    case ValueType::kString: {</a>
<a name="ln634">      if (out) {</a>
<a name="ln635">        string result;</a>
<a name="ln636">        RETURN_NOT_OK(DecodeZeroEncodedStr(slice, &amp;result));</a>
<a name="ln637">        new (&amp;out-&gt;str_val_) string(std::move(result));</a>
<a name="ln638">      } else {</a>
<a name="ln639">        RETURN_NOT_OK(DecodeZeroEncodedStr(slice, nullptr));</a>
<a name="ln640">      }</a>
<a name="ln641">      // Only set type to string after string field initialization succeeds.</a>
<a name="ln642">      type_ref = value_type;</a>
<a name="ln643">      return Status::OK();</a>
<a name="ln644">    }</a>
<a name="ln645"> </a>
<a name="ln646">    case ValueType::kFrozenDescending:</a>
<a name="ln647">    case ValueType::kFrozen: {</a>
<a name="ln648">      ValueType end_marker_value_type = ValueType::kGroupEnd;</a>
<a name="ln649">      if (value_type == ValueType::kFrozenDescending) {</a>
<a name="ln650">        end_marker_value_type = ValueType::kGroupEndDescending;</a>
<a name="ln651">      }</a>
<a name="ln652"> </a>
<a name="ln653">      if (out) {</a>
<a name="ln654">        out-&gt;frozen_val_ = new FrozenContainer();</a>
<a name="ln655">        while (!slice-&gt;empty()) {</a>
<a name="ln656">          ValueType current_value_type = static_cast&lt;ValueType&gt;(*slice-&gt;data());</a>
<a name="ln657">          if (current_value_type == end_marker_value_type) {</a>
<a name="ln658">            slice-&gt;consume_byte();</a>
<a name="ln659">            type_ref = value_type;</a>
<a name="ln660">            return Status::OK();</a>
<a name="ln661">          } else {</a>
<a name="ln662">            PrimitiveValue pv;</a>
<a name="ln663">            RETURN_NOT_OK(DecodeKey(slice, &amp;pv));</a>
<a name="ln664">            out-&gt;frozen_val_-&gt;push_back(pv);</a>
<a name="ln665">          }</a>
<a name="ln666">        }</a>
<a name="ln667">      } else {</a>
<a name="ln668">        while (!slice-&gt;empty()) {</a>
<a name="ln669">          ValueType current_value_type = static_cast&lt;ValueType&gt;(*slice-&gt;data());</a>
<a name="ln670">          if (current_value_type == end_marker_value_type) {</a>
<a name="ln671">            slice-&gt;consume_byte();</a>
<a name="ln672">            return Status::OK();</a>
<a name="ln673">          } else {</a>
<a name="ln674">            RETURN_NOT_OK(DecodeKey(slice, nullptr));</a>
<a name="ln675">          }</a>
<a name="ln676">        }</a>
<a name="ln677">      }</a>
<a name="ln678"> </a>
<a name="ln679">      return STATUS(Corruption, &quot;Reached end of slice looking for frozen group end marker&quot;);</a>
<a name="ln680">    }</a>
<a name="ln681"> </a>
<a name="ln682">    case ValueType::kDecimalDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln683">    case ValueType::kDecimal: {</a>
<a name="ln684">      util::Decimal decimal;</a>
<a name="ln685">      Slice slice_temp(slice-&gt;data(), slice-&gt;size());</a>
<a name="ln686">      size_t num_decoded_bytes = 0;</a>
<a name="ln687">      RETURN_NOT_OK(decimal.DecodeFromComparable(slice_temp, &amp;num_decoded_bytes));</a>
<a name="ln688">      if (value_type == ValueType::kDecimalDescending) {</a>
<a name="ln689">        // When we encode a descending decimal, we do a bitwise negation of each byte, which changes</a>
<a name="ln690">        // the sign of the number. This way we reverse the sorting order. decimal.Negate() restores</a>
<a name="ln691">        // the original sign of the number.</a>
<a name="ln692">        decimal.Negate();</a>
<a name="ln693">      }</a>
<a name="ln694">      if (out) { // TODO avoid using temp variable, when out is nullptr</a>
<a name="ln695">        new(&amp;out-&gt;decimal_val_) string(decimal.EncodeToComparable());</a>
<a name="ln696">      }</a>
<a name="ln697">      slice-&gt;remove_prefix(num_decoded_bytes);</a>
<a name="ln698">      type_ref = value_type;</a>
<a name="ln699">      return Status::OK();</a>
<a name="ln700">    }</a>
<a name="ln701"> </a>
<a name="ln702">    case ValueType::kVarIntDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln703">    case ValueType::kVarInt: {</a>
<a name="ln704">      util::VarInt varint;</a>
<a name="ln705">      Slice slice_temp(slice-&gt;data(), slice-&gt;size());</a>
<a name="ln706">      size_t num_decoded_bytes = 0;</a>
<a name="ln707">      RETURN_NOT_OK(varint.DecodeFromComparable(slice_temp, &amp;num_decoded_bytes));</a>
<a name="ln708">      if (value_type == ValueType::kVarIntDescending) {</a>
<a name="ln709">        varint.Negate();</a>
<a name="ln710">      }</a>
<a name="ln711">      if (out) { // TODO avoid using temp variable, when out is nullptr</a>
<a name="ln712">        new(&amp;out-&gt;varint_val_) string(varint.EncodeToComparable());</a>
<a name="ln713">      }</a>
<a name="ln714">      slice-&gt;remove_prefix(num_decoded_bytes);</a>
<a name="ln715">      type_ref = value_type;</a>
<a name="ln716">      return Status::OK();</a>
<a name="ln717">    }</a>
<a name="ln718"> </a>
<a name="ln719">    case ValueType::kInt32Descending: FALLTHROUGH_INTENDED;</a>
<a name="ln720">    case ValueType::kInt32: FALLTHROUGH_INTENDED;</a>
<a name="ln721">    case ValueType::kWriteId:</a>
<a name="ln722">      if (slice-&gt;size() &lt; sizeof(int32_t)) {</a>
<a name="ln723">        return STATUS_SUBSTITUTE(Corruption,</a>
<a name="ln724">                                 &quot;Not enough bytes to decode a 32-bit integer: $0&quot;,</a>
<a name="ln725">                                 slice-&gt;size());</a>
<a name="ln726">      }</a>
<a name="ln727">      if (out) {</a>
<a name="ln728">        out-&gt;int32_val_ = BigEndian::Load32(slice-&gt;data()) ^ kInt32SignBitFlipMask;</a>
<a name="ln729">        if (value_type == ValueType::kInt32Descending) {</a>
<a name="ln730">          out-&gt;int32_val_ = ~out-&gt;int32_val_;</a>
<a name="ln731">        }</a>
<a name="ln732">      }</a>
<a name="ln733">      slice-&gt;remove_prefix(sizeof(int32_t));</a>
<a name="ln734">      type_ref = value_type;</a>
<a name="ln735">      return Status::OK();</a>
<a name="ln736"> </a>
<a name="ln737">    case ValueType::kPgTableOid: FALLTHROUGH_INTENDED;</a>
<a name="ln738">    case ValueType::kUInt32Descending: FALLTHROUGH_INTENDED;</a>
<a name="ln739">    case ValueType::kUInt32:</a>
<a name="ln740">      if (slice-&gt;size() &lt; sizeof(uint32_t)) {</a>
<a name="ln741">        return STATUS_SUBSTITUTE(Corruption,</a>
<a name="ln742">                                 &quot;Not enough bytes to decode a 32-bit integer: $0&quot;,</a>
<a name="ln743">                                 slice-&gt;size());</a>
<a name="ln744">      }</a>
<a name="ln745">      if (out) {</a>
<a name="ln746">        out-&gt;uint32_val_ = BigEndian::Load32(slice-&gt;data());</a>
<a name="ln747">        if (value_type == ValueType::kUInt32Descending) {</a>
<a name="ln748">          out-&gt;uint32_val_ = ~out-&gt;uint32_val_;</a>
<a name="ln749">        }</a>
<a name="ln750">      }</a>
<a name="ln751">      slice-&gt;remove_prefix(sizeof(uint32_t));</a>
<a name="ln752">      type_ref = value_type;</a>
<a name="ln753">      return Status::OK();</a>
<a name="ln754"> </a>
<a name="ln755">    case ValueType::kUInt64Descending: FALLTHROUGH_INTENDED;</a>
<a name="ln756">    case ValueType::kUInt64:</a>
<a name="ln757">      if (slice-&gt;size() &lt; sizeof(uint64_t)) {</a>
<a name="ln758">        return STATUS_SUBSTITUTE(Corruption,</a>
<a name="ln759">                                 &quot;Not enough bytes to decode a 64-bit integer: $0&quot;,</a>
<a name="ln760">                                 slice-&gt;size());</a>
<a name="ln761">      }</a>
<a name="ln762">      if (out) {</a>
<a name="ln763">        out-&gt;uint64_val_ = BigEndian::Load64(slice-&gt;data());</a>
<a name="ln764">        if (value_type == ValueType::kUInt64Descending) {</a>
<a name="ln765">          out-&gt;uint64_val_ = ~out-&gt;uint64_val_;</a>
<a name="ln766">        }</a>
<a name="ln767">      }</a>
<a name="ln768">      slice-&gt;remove_prefix(sizeof(uint64_t));</a>
<a name="ln769">      type_ref = value_type;</a>
<a name="ln770">      return Status::OK();</a>
<a name="ln771"> </a>
<a name="ln772">    case ValueType::kInt64Descending: FALLTHROUGH_INTENDED;</a>
<a name="ln773">    case ValueType::kInt64: FALLTHROUGH_INTENDED;</a>
<a name="ln774">    case ValueType::kArrayIndex:</a>
<a name="ln775">      if (slice-&gt;size() &lt; sizeof(int64_t)) {</a>
<a name="ln776">        return STATUS_SUBSTITUTE(Corruption,</a>
<a name="ln777">            &quot;Not enough bytes to decode a 64-bit integer: $0&quot;,</a>
<a name="ln778">            slice-&gt;size());</a>
<a name="ln779">      }</a>
<a name="ln780">      if (out) {</a>
<a name="ln781">        out-&gt;int64_val_ = DecodeInt64FromKey(*slice);</a>
<a name="ln782">        if (value_type == ValueType::kInt64Descending) {</a>
<a name="ln783">          out-&gt;int64_val_ = ~out-&gt;int64_val_;</a>
<a name="ln784">        }</a>
<a name="ln785">      }</a>
<a name="ln786">      slice-&gt;remove_prefix(sizeof(int64_t));</a>
<a name="ln787">      type_ref = value_type;</a>
<a name="ln788">      return Status::OK();</a>
<a name="ln789"> </a>
<a name="ln790">    case ValueType::kUInt16Hash:</a>
<a name="ln791">      if (slice-&gt;size() &lt; sizeof(uint16_t)) {</a>
<a name="ln792">        return STATUS(Corruption, Substitute(&quot;Not enough bytes to decode a 16-bit hash: $0&quot;,</a>
<a name="ln793">                                             slice-&gt;size()));</a>
<a name="ln794">      }</a>
<a name="ln795">      if (out) {</a>
<a name="ln796">        out-&gt;uint16_val_ = BigEndian::Load16(slice-&gt;data());</a>
<a name="ln797">      }</a>
<a name="ln798">      slice-&gt;remove_prefix(sizeof(uint16_t));</a>
<a name="ln799">      type_ref = value_type;</a>
<a name="ln800">      return Status::OK();</a>
<a name="ln801"> </a>
<a name="ln802">    case ValueType::kTimestampDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln803">    case ValueType::kTimestamp: {</a>
<a name="ln804">      if (slice-&gt;size() &lt; sizeof(Timestamp)) {</a>
<a name="ln805">        return STATUS(Corruption,</a>
<a name="ln806">            Substitute(&quot;Not enough bytes to decode a Timestamp: $0, need $1&quot;,</a>
<a name="ln807">                slice-&gt;size(), sizeof(Timestamp)));</a>
<a name="ln808">      }</a>
<a name="ln809">      if (out) {</a>
<a name="ln810">        const auto uint64_timestamp = DecodeInt64FromKey(*slice);</a>
<a name="ln811">        if (value_type == ValueType::kTimestampDescending) {</a>
<a name="ln812">          // Flip all the bits after loading the integer.</a>
<a name="ln813">          out-&gt;timestamp_val_ = Timestamp(~uint64_timestamp);</a>
<a name="ln814">        } else {</a>
<a name="ln815">          out-&gt;timestamp_val_ = Timestamp(uint64_timestamp);</a>
<a name="ln816">        }</a>
<a name="ln817">      }</a>
<a name="ln818">      slice-&gt;remove_prefix(sizeof(Timestamp));</a>
<a name="ln819">      type_ref = value_type;</a>
<a name="ln820">      return Status::OK();</a>
<a name="ln821">    }</a>
<a name="ln822"> </a>
<a name="ln823">    case ValueType::kInetaddress: {</a>
<a name="ln824">      if (out) {</a>
<a name="ln825">        string bytes;</a>
<a name="ln826">        RETURN_NOT_OK(DecodeZeroEncodedStr(slice, &amp;bytes));</a>
<a name="ln827">        out-&gt;inetaddress_val_ = new InetAddress();</a>
<a name="ln828">        RETURN_NOT_OK(out-&gt;inetaddress_val_-&gt;FromBytes(bytes));</a>
<a name="ln829">      } else {</a>
<a name="ln830">        RETURN_NOT_OK(DecodeZeroEncodedStr(slice, nullptr));</a>
<a name="ln831">      }</a>
<a name="ln832">      type_ref = value_type;</a>
<a name="ln833">      return Status::OK();</a>
<a name="ln834">    }</a>
<a name="ln835"> </a>
<a name="ln836">    case ValueType::kInetaddressDescending: {</a>
<a name="ln837">      if (out) {</a>
<a name="ln838">        string bytes;</a>
<a name="ln839">        RETURN_NOT_OK(DecodeComplementZeroEncodedStr(slice, &amp;bytes));</a>
<a name="ln840">        out-&gt;inetaddress_val_ = new InetAddress();</a>
<a name="ln841">        RETURN_NOT_OK(out-&gt;inetaddress_val_-&gt;FromBytes(bytes));</a>
<a name="ln842">      } else {</a>
<a name="ln843">        RETURN_NOT_OK(DecodeComplementZeroEncodedStr(slice, nullptr));</a>
<a name="ln844">      }</a>
<a name="ln845">      type_ref = value_type;</a>
<a name="ln846">      return Status::OK();</a>
<a name="ln847">    }</a>
<a name="ln848"> </a>
<a name="ln849">    case ValueType::kTransactionApplyState:</a>
<a name="ln850">      if (slice-&gt;size() &lt; boost::uuids::uuid::static_size()) {</a>
<a name="ln851">        return STATUS_FORMAT(Corruption, &quot;Not enough bytes for UUID: $0&quot;, slice-&gt;size());</a>
<a name="ln852">      }</a>
<a name="ln853">      if (out) {</a>
<a name="ln854">        RETURN_NOT_OK((new(&amp;out-&gt;uuid_val_) Uuid())-&gt;FromSlice(</a>
<a name="ln855">            *slice, boost::uuids::uuid::static_size()));</a>
<a name="ln856">      }</a>
<a name="ln857">      slice-&gt;remove_prefix(boost::uuids::uuid::static_size());</a>
<a name="ln858">      type_ref = value_type;</a>
<a name="ln859">      return Status::OK();</a>
<a name="ln860"> </a>
<a name="ln861">    case ValueType::kTransactionId: FALLTHROUGH_INTENDED;</a>
<a name="ln862">    case ValueType::kTableId: FALLTHROUGH_INTENDED;</a>
<a name="ln863">    case ValueType::kUuid: {</a>
<a name="ln864">      if (out) {</a>
<a name="ln865">        string bytes;</a>
<a name="ln866">        RETURN_NOT_OK(DecodeZeroEncodedStr(slice, &amp;bytes));</a>
<a name="ln867">        new(&amp;out-&gt;uuid_val_) Uuid();</a>
<a name="ln868">        RETURN_NOT_OK(out-&gt;uuid_val_.DecodeFromComparable(bytes));</a>
<a name="ln869">      } else {</a>
<a name="ln870">        RETURN_NOT_OK(DecodeZeroEncodedStr(slice, nullptr));</a>
<a name="ln871">      }</a>
<a name="ln872">      type_ref = value_type;</a>
<a name="ln873">      return Status::OK();</a>
<a name="ln874">    }</a>
<a name="ln875"> </a>
<a name="ln876">    case ValueType::kUuidDescending: {</a>
<a name="ln877">      if (out) {</a>
<a name="ln878">        string bytes;</a>
<a name="ln879">        RETURN_NOT_OK(DecodeComplementZeroEncodedStr(slice, &amp;bytes));</a>
<a name="ln880">        new(&amp;out-&gt;uuid_val_) Uuid();</a>
<a name="ln881">        RETURN_NOT_OK(out-&gt;uuid_val_.DecodeFromComparable(bytes));</a>
<a name="ln882">      } else {</a>
<a name="ln883">        RETURN_NOT_OK(DecodeComplementZeroEncodedStr(slice, nullptr));</a>
<a name="ln884">      }</a>
<a name="ln885">      type_ref = value_type;</a>
<a name="ln886">      return Status::OK();</a>
<a name="ln887">    }</a>
<a name="ln888"> </a>
<a name="ln889">    case ValueType::kColumnId: FALLTHROUGH_INTENDED;</a>
<a name="ln890">    case ValueType::kSystemColumnId: {</a>
<a name="ln891">      // Decode varint</a>
<a name="ln892">      {</a>
<a name="ln893">        ColumnId dummy_column_id;</a>
<a name="ln894">        ColumnId&amp; column_id_ref = out ? out-&gt;column_id_val_ : dummy_column_id;</a>
<a name="ln895">        int64_t column_id_as_int64 = VERIFY_RESULT(FastDecodeSignedVarInt(slice));</a>
<a name="ln896">        RETURN_NOT_OK(ColumnId::FromInt64(column_id_as_int64, &amp;column_id_ref));</a>
<a name="ln897">      }</a>
<a name="ln898"> </a>
<a name="ln899">      type_ref = value_type;</a>
<a name="ln900">      return Status::OK();</a>
<a name="ln901">    }</a>
<a name="ln902"> </a>
<a name="ln903">    case ValueType::kHybridTime: {</a>
<a name="ln904">      if (out) {</a>
<a name="ln905">        new(&amp;out-&gt;hybrid_time_val_) DocHybridTime();</a>
<a name="ln906">        RETURN_NOT_OK(out-&gt;hybrid_time_val_.DecodeFrom(slice));</a>
<a name="ln907">      } else {</a>
<a name="ln908">        DocHybridTime dummy_hybrid_time;</a>
<a name="ln909">        RETURN_NOT_OK(dummy_hybrid_time.DecodeFrom(slice));</a>
<a name="ln910">      }</a>
<a name="ln911"> </a>
<a name="ln912">      type_ref = ValueType::kHybridTime;</a>
<a name="ln913">      return Status::OK();</a>
<a name="ln914">    }</a>
<a name="ln915"> </a>
<a name="ln916">    case ValueType::kIntentTypeSet: FALLTHROUGH_INTENDED;</a>
<a name="ln917">    case ValueType::kObsoleteIntentTypeSet: FALLTHROUGH_INTENDED;</a>
<a name="ln918">    case ValueType::kObsoleteIntentType: {</a>
<a name="ln919">      if (out) {</a>
<a name="ln920">        out-&gt;uint16_val_ = static_cast&lt;uint16_t&gt;(*slice-&gt;data());</a>
<a name="ln921">      }</a>
<a name="ln922">      type_ref = value_type;</a>
<a name="ln923">      slice-&gt;consume_byte();</a>
<a name="ln924">      return Status::OK();</a>
<a name="ln925">    }</a>
<a name="ln926"> </a>
<a name="ln927">    case ValueType::kFloatDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln928">    case ValueType::kFloat: {</a>
<a name="ln929">      if (slice-&gt;size() &lt; sizeof(float_t)) {</a>
<a name="ln930">        return STATUS_FORMAT(Corruption, &quot;Not enough bytes to decode a float: $0&quot;, slice-&gt;size());</a>
<a name="ln931">      }</a>
<a name="ln932">      if (out) {</a>
<a name="ln933">        if (value_type == ValueType::kFloatDescending) {</a>
<a name="ln934">          out-&gt;float_val_ = DecodeFloatFromKey(*slice, /* descending */ true);</a>
<a name="ln935">        } else {</a>
<a name="ln936">          out-&gt;float_val_ = DecodeFloatFromKey(*slice);</a>
<a name="ln937">        }</a>
<a name="ln938">      }</a>
<a name="ln939">      slice-&gt;remove_prefix(sizeof(float_t));</a>
<a name="ln940">      type_ref = value_type;</a>
<a name="ln941">      return Status::OK();</a>
<a name="ln942">    }</a>
<a name="ln943">    case ValueType::kDoubleDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln944">    case ValueType::kDouble: {</a>
<a name="ln945">      if (slice-&gt;size() &lt; sizeof(double_t)) {</a>
<a name="ln946">        return STATUS_FORMAT(Corruption, &quot;Not enough bytes to decode a float: $0&quot;, slice-&gt;size());</a>
<a name="ln947">      }</a>
<a name="ln948">      if (out) {</a>
<a name="ln949">        if (value_type == ValueType::kDoubleDescending) {</a>
<a name="ln950">          out-&gt;double_val_ = DecodeDoubleFromKey(*slice, /* descending */ true);</a>
<a name="ln951">        } else {</a>
<a name="ln952">          out-&gt;double_val_ = DecodeDoubleFromKey(*slice);</a>
<a name="ln953">        }</a>
<a name="ln954">      }</a>
<a name="ln955">      slice-&gt;remove_prefix(sizeof(double_t));</a>
<a name="ln956">      type_ref = value_type;</a>
<a name="ln957">      return Status::OK();</a>
<a name="ln958">    }</a>
<a name="ln959">    case ValueType::kMaxByte:</a>
<a name="ln960">      break;</a>
<a name="ln961"> </a>
<a name="ln962">    IGNORE_NON_PRIMITIVE_VALUE_TYPES_IN_SWITCH;</a>
<a name="ln963">  }</a>
<a name="ln964">  return STATUS_FORMAT(</a>
<a name="ln965">      Corruption,</a>
<a name="ln966">      &quot;Cannot decode value type $0 from the key encoding format: $1&quot;,</a>
<a name="ln967">      value_type,</a>
<a name="ln968">      ToShortDebugStr(input_slice));</a>
<a name="ln969">}</a>
<a name="ln970"> </a>
<a name="ln971">Status PrimitiveValue::DecodeFromValue(const rocksdb::Slice&amp; rocksdb_slice) {</a>
<a name="ln972">  if (rocksdb_slice.empty()) {</a>
<a name="ln973">    return STATUS(Corruption, &quot;Cannot decode a value from an empty slice&quot;);</a>
<a name="ln974">  }</a>
<a name="ln975">  rocksdb::Slice slice(rocksdb_slice);</a>
<a name="ln976">  this-&gt;~PrimitiveValue();</a>
<a name="ln977">  // Ensure we are not leaving the object in an invalid state in case e.g. an exception is thrown</a>
<a name="ln978">  // due to inability to allocate memory.</a>
<a name="ln979">  type_ = ValueType::kNullLow;</a>
<a name="ln980"> </a>
<a name="ln981">  const auto value_type = ConsumeValueType(&amp;slice);</a>
<a name="ln982"> </a>
<a name="ln983">  // TODO: ensure we consume all data from the given slice.</a>
<a name="ln984">  switch (value_type) {</a>
<a name="ln985">    case ValueType::kNullHigh: FALLTHROUGH_INTENDED;</a>
<a name="ln986">    case ValueType::kNullLow: FALLTHROUGH_INTENDED;</a>
<a name="ln987">    case ValueType::kCounter: FALLTHROUGH_INTENDED;</a>
<a name="ln988">    case ValueType::kSSForward: FALLTHROUGH_INTENDED;</a>
<a name="ln989">    case ValueType::kSSReverse: FALLTHROUGH_INTENDED;</a>
<a name="ln990">    case ValueType::kFalse: FALLTHROUGH_INTENDED;</a>
<a name="ln991">    case ValueType::kTrue: FALLTHROUGH_INTENDED;</a>
<a name="ln992">    case ValueType::kFalseDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln993">    case ValueType::kTrueDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln994">    case ValueType::kObject: FALLTHROUGH_INTENDED;</a>
<a name="ln995">    case ValueType::kArray: FALLTHROUGH_INTENDED;</a>
<a name="ln996">    case ValueType::kRedisList: FALLTHROUGH_INTENDED;</a>
<a name="ln997">    case ValueType::kRedisSet: FALLTHROUGH_INTENDED;</a>
<a name="ln998">    case ValueType::kRedisTS: FALLTHROUGH_INTENDED;</a>
<a name="ln999">    case ValueType::kRedisSortedSet: FALLTHROUGH_INTENDED;</a>
<a name="ln1000">    case ValueType::kTombstone:</a>
<a name="ln1001">      type_ = value_type;</a>
<a name="ln1002">      complex_data_structure_ = nullptr;</a>
<a name="ln1003">      return Status::OK();</a>
<a name="ln1004"> </a>
<a name="ln1005">    case ValueType::kFrozenDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln1006">    case ValueType::kFrozen: {</a>
<a name="ln1007">      ValueType end_marker_value_type = ValueType::kGroupEnd;</a>
<a name="ln1008">      if (value_type == ValueType::kFrozenDescending) {</a>
<a name="ln1009">        end_marker_value_type = ValueType::kGroupEndDescending;</a>
<a name="ln1010">      }</a>
<a name="ln1011"> </a>
<a name="ln1012">      frozen_val_ = new FrozenContainer();</a>
<a name="ln1013">      while (!slice.empty()) {</a>
<a name="ln1014">        ValueType current_value_type = static_cast&lt;ValueType&gt;(*slice.data());</a>
<a name="ln1015">        if (current_value_type == end_marker_value_type) {</a>
<a name="ln1016">          slice.consume_byte();</a>
<a name="ln1017">          type_ = value_type;</a>
<a name="ln1018">          return Status::OK();</a>
<a name="ln1019">        } else {</a>
<a name="ln1020">          PrimitiveValue pv;</a>
<a name="ln1021">          // Frozen elems are encoded as keys even in values.</a>
<a name="ln1022">          RETURN_NOT_OK(pv.DecodeFromKey(&amp;slice));</a>
<a name="ln1023">          frozen_val_-&gt;push_back(pv);</a>
<a name="ln1024">        }</a>
<a name="ln1025">      }</a>
<a name="ln1026"> </a>
<a name="ln1027">      return STATUS(Corruption, &quot;Reached end of slice looking for frozen group end marker&quot;);</a>
<a name="ln1028">    }</a>
<a name="ln1029">    case ValueType::kString:</a>
<a name="ln1030">      new(&amp;str_val_) string(slice.cdata(), slice.size());</a>
<a name="ln1031">      // Only set type to string after string field initialization succeeds.</a>
<a name="ln1032">      type_ = ValueType::kString;</a>
<a name="ln1033">      return Status::OK();</a>
<a name="ln1034"> </a>
<a name="ln1035">    case ValueType::kInt32: FALLTHROUGH_INTENDED;</a>
<a name="ln1036">    case ValueType::kInt32Descending: FALLTHROUGH_INTENDED;</a>
<a name="ln1037">    case ValueType::kFloatDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln1038">    case ValueType::kWriteId: FALLTHROUGH_INTENDED;</a>
<a name="ln1039">    case ValueType::kFloat:</a>
<a name="ln1040">      if (slice.size() != sizeof(int32_t)) {</a>
<a name="ln1041">        return STATUS_FORMAT(Corruption, &quot;Invalid number of bytes for a $0: $1&quot;,</a>
<a name="ln1042">            value_type, slice.size());</a>
<a name="ln1043">      }</a>
<a name="ln1044">      type_ = value_type;</a>
<a name="ln1045">      int32_val_ = BigEndian::Load32(slice.data());</a>
<a name="ln1046">      return Status::OK();</a>
<a name="ln1047"> </a>
<a name="ln1048">    case ValueType::kPgTableOid: FALLTHROUGH_INTENDED;</a>
<a name="ln1049">    case ValueType::kUInt32: FALLTHROUGH_INTENDED;</a>
<a name="ln1050">    case ValueType::kUInt32Descending:</a>
<a name="ln1051">      if (slice.size() != sizeof(uint32_t)) {</a>
<a name="ln1052">        return STATUS_FORMAT(Corruption, &quot;Invalid number of bytes for a $0: $1&quot;,</a>
<a name="ln1053">            value_type, slice.size());</a>
<a name="ln1054">      }</a>
<a name="ln1055">      type_ = value_type;</a>
<a name="ln1056">      uint32_val_ = BigEndian::Load32(slice.data());</a>
<a name="ln1057">      return Status::OK();</a>
<a name="ln1058"> </a>
<a name="ln1059">    case ValueType::kUInt64: FALLTHROUGH_INTENDED;</a>
<a name="ln1060">    case ValueType::kUInt64Descending:</a>
<a name="ln1061">      if (slice.size() != sizeof(uint64_t)) {</a>
<a name="ln1062">        return STATUS_FORMAT(Corruption, &quot;Invalid number of bytes for a $0: $1&quot;,</a>
<a name="ln1063">            value_type, slice.size());</a>
<a name="ln1064">      }</a>
<a name="ln1065">      type_ = value_type;</a>
<a name="ln1066">      uint64_val_ = BigEndian::Load64(slice.data());</a>
<a name="ln1067">      return Status::OK();</a>
<a name="ln1068"> </a>
<a name="ln1069">    case ValueType::kInt64: FALLTHROUGH_INTENDED;</a>
<a name="ln1070">    case ValueType::kInt64Descending: FALLTHROUGH_INTENDED;</a>
<a name="ln1071">    case ValueType::kArrayIndex: FALLTHROUGH_INTENDED;</a>
<a name="ln1072">    case ValueType::kDoubleDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln1073">    case ValueType::kDouble:</a>
<a name="ln1074">      if (slice.size() != sizeof(int64_t)) {</a>
<a name="ln1075">        return STATUS_FORMAT(Corruption, &quot;Invalid number of bytes for a $0: $1&quot;,</a>
<a name="ln1076">            value_type, slice.size());</a>
<a name="ln1077">      }</a>
<a name="ln1078">      type_ = value_type;</a>
<a name="ln1079">      int64_val_ = BigEndian::Load64(slice.data());</a>
<a name="ln1080">      return Status::OK();</a>
<a name="ln1081"> </a>
<a name="ln1082">    case ValueType::kDecimal: {</a>
<a name="ln1083">      util::Decimal decimal;</a>
<a name="ln1084">      size_t num_decoded_bytes = 0;</a>
<a name="ln1085">      RETURN_NOT_OK(decimal.DecodeFromComparable(slice.ToString(), &amp;num_decoded_bytes));</a>
<a name="ln1086">      type_ = value_type;</a>
<a name="ln1087">      new(&amp;decimal_val_) string(decimal.EncodeToComparable());</a>
<a name="ln1088">      return Status::OK();</a>
<a name="ln1089">    }</a>
<a name="ln1090"> </a>
<a name="ln1091">    case ValueType::kVarInt: {</a>
<a name="ln1092">      util::VarInt varint;</a>
<a name="ln1093">      size_t num_decoded_bytes = 0;</a>
<a name="ln1094">      RETURN_NOT_OK(varint.DecodeFromComparable(slice.ToString(), &amp;num_decoded_bytes));</a>
<a name="ln1095">      type_ = value_type;</a>
<a name="ln1096">      new(&amp;varint_val_) string(varint.EncodeToComparable());</a>
<a name="ln1097">      return Status::OK();</a>
<a name="ln1098">    }</a>
<a name="ln1099"> </a>
<a name="ln1100">    case ValueType::kTimestamp:</a>
<a name="ln1101">      if (slice.size() != sizeof(Timestamp)) {</a>
<a name="ln1102">        return STATUS_FORMAT(Corruption, &quot;Invalid number of bytes for a $0: $1&quot;,</a>
<a name="ln1103">            value_type, slice.size());</a>
<a name="ln1104">      }</a>
<a name="ln1105">      type_ = value_type;</a>
<a name="ln1106">      timestamp_val_ = Timestamp(BigEndian::Load64(slice.data()));</a>
<a name="ln1107">      return Status::OK();</a>
<a name="ln1108"> </a>
<a name="ln1109">    case ValueType::kJsonb: {</a>
<a name="ln1110">      if (slice.size() &lt; sizeof(int64_t)) {</a>
<a name="ln1111">        return STATUS_FORMAT(Corruption, &quot;Invalid number of bytes for a $0: $1&quot;,</a>
<a name="ln1112">                             value_type, slice.size());</a>
<a name="ln1113">      }</a>
<a name="ln1114">      // Read the jsonb flags.</a>
<a name="ln1115">      int64_t jsonb_flags = BigEndian::Load64(slice.data());</a>
<a name="ln1116">      slice.remove_prefix(sizeof(jsonb_flags));</a>
<a name="ln1117"> </a>
<a name="ln1118">      // Read the serialized jsonb.</a>
<a name="ln1119">      new(&amp;json_val_) string(slice.ToBuffer());</a>
<a name="ln1120">      type_ = value_type;</a>
<a name="ln1121">      return Status::OK();</a>
<a name="ln1122">    }</a>
<a name="ln1123"> </a>
<a name="ln1124">    case ValueType::kInetaddress: {</a>
<a name="ln1125">      if (slice.size() != kInetAddressV4Size &amp;&amp; slice.size() != kInetAddressV6Size) {</a>
<a name="ln1126">        return STATUS_FORMAT(Corruption,</a>
<a name="ln1127">                             &quot;Invalid number of bytes to decode IPv4/IPv6: $0, need $1 or $2&quot;,</a>
<a name="ln1128">                             slice.size(), kInetAddressV4Size, kInetAddressV6Size);</a>
<a name="ln1129">      }</a>
<a name="ln1130">      // Need to use a non-rocksdb slice for InetAddress.</a>
<a name="ln1131">      Slice slice_temp(slice.data(), slice.size());</a>
<a name="ln1132">      inetaddress_val_ = new InetAddress();</a>
<a name="ln1133">          RETURN_NOT_OK(inetaddress_val_-&gt;FromSlice(slice_temp));</a>
<a name="ln1134">      type_ = value_type;</a>
<a name="ln1135">      return Status::OK();</a>
<a name="ln1136">    }</a>
<a name="ln1137"> </a>
<a name="ln1138">    case ValueType::kTransactionApplyState: FALLTHROUGH_INTENDED;</a>
<a name="ln1139">    case ValueType::kTransactionId: FALLTHROUGH_INTENDED;</a>
<a name="ln1140">    case ValueType::kTableId: FALLTHROUGH_INTENDED;</a>
<a name="ln1141">    case ValueType::kUuid: {</a>
<a name="ln1142">      if (slice.size() != kUuidSize) {</a>
<a name="ln1143">        return STATUS_FORMAT(Corruption, &quot;Invalid number of bytes to decode Uuid: $0, need $1&quot;,</a>
<a name="ln1144">            slice.size(), kUuidSize);</a>
<a name="ln1145">      }</a>
<a name="ln1146">      Slice slice_temp(slice.data(), slice.size());</a>
<a name="ln1147">      new(&amp;uuid_val_) Uuid();</a>
<a name="ln1148">      RETURN_NOT_OK(uuid_val_.DecodeFromComparableSlice(slice_temp));</a>
<a name="ln1149">      type_ = value_type;</a>
<a name="ln1150">      return Status::OK();</a>
<a name="ln1151">    }</a>
<a name="ln1152"> </a>
<a name="ln1153">    case ValueType::kIntentTypeSet: FALLTHROUGH_INTENDED;</a>
<a name="ln1154">    case ValueType::kObsoleteIntentTypeSet: FALLTHROUGH_INTENDED;</a>
<a name="ln1155">    case ValueType::kObsoleteIntentType: FALLTHROUGH_INTENDED;</a>
<a name="ln1156">    case ValueType::kGroupEnd: FALLTHROUGH_INTENDED;</a>
<a name="ln1157">    case ValueType::kGroupEndDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln1158">    case ValueType::kObsoleteIntentPrefix: FALLTHROUGH_INTENDED;</a>
<a name="ln1159">    case ValueType::kGreaterThanIntentType: FALLTHROUGH_INTENDED;</a>
<a name="ln1160">    case ValueType::kUInt16Hash: FALLTHROUGH_INTENDED;</a>
<a name="ln1161">    case ValueType::kInvalid: FALLTHROUGH_INTENDED;</a>
<a name="ln1162">    case ValueType::kMergeFlags: FALLTHROUGH_INTENDED;</a>
<a name="ln1163">    case ValueType::kRowLock: FALLTHROUGH_INTENDED;</a>
<a name="ln1164">    case ValueType::kBitSet: FALLTHROUGH_INTENDED;</a>
<a name="ln1165">    case ValueType::kTtl: FALLTHROUGH_INTENDED;</a>
<a name="ln1166">    case ValueType::kUserTimestamp: FALLTHROUGH_INTENDED;</a>
<a name="ln1167">    case ValueType::kColumnId: FALLTHROUGH_INTENDED;</a>
<a name="ln1168">    case ValueType::kSystemColumnId: FALLTHROUGH_INTENDED;</a>
<a name="ln1169">    case ValueType::kHybridTime: FALLTHROUGH_INTENDED;</a>
<a name="ln1170">    case ValueType::kStringDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln1171">    case ValueType::kInetaddressDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln1172">    case ValueType::kDecimalDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln1173">    case ValueType::kVarIntDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln1174">    case ValueType::kUuidDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln1175">    case ValueType::kTimestampDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln1176">    case ValueType::kLowest: FALLTHROUGH_INTENDED;</a>
<a name="ln1177">    case ValueType::kHighest: FALLTHROUGH_INTENDED;</a>
<a name="ln1178">    case ValueType::kMaxByte:</a>
<a name="ln1179">      return STATUS_FORMAT(Corruption, &quot;$0 is not allowed in a RocksDB PrimitiveValue&quot;, value_type);</a>
<a name="ln1180">  }</a>
<a name="ln1181">  FATAL_INVALID_ENUM_VALUE(ValueType, value_type);</a>
<a name="ln1182">  return Status::OK();</a>
<a name="ln1183">}</a>
<a name="ln1184"> </a>
<a name="ln1185">PrimitiveValue PrimitiveValue::Double(double d, SortOrder sort_order) {</a>
<a name="ln1186">  PrimitiveValue primitive_value;</a>
<a name="ln1187">  if (sort_order == SortOrder::kAscending) {</a>
<a name="ln1188">    primitive_value.type_ = ValueType::kDouble;</a>
<a name="ln1189">  } else {</a>
<a name="ln1190">    primitive_value.type_ = ValueType::kDoubleDescending;</a>
<a name="ln1191">  }</a>
<a name="ln1192">  primitive_value.double_val_ = d;</a>
<a name="ln1193">  return primitive_value;</a>
<a name="ln1194">}</a>
<a name="ln1195"> </a>
<a name="ln1196">PrimitiveValue PrimitiveValue::Float(float f, SortOrder sort_order) {</a>
<a name="ln1197">  PrimitiveValue primitive_value;</a>
<a name="ln1198">  if (sort_order == SortOrder::kAscending) {</a>
<a name="ln1199">    primitive_value.type_ = ValueType::kFloat;</a>
<a name="ln1200">  } else {</a>
<a name="ln1201">    primitive_value.type_ = ValueType::kFloatDescending;</a>
<a name="ln1202">  }</a>
<a name="ln1203">  primitive_value.float_val_ = f;</a>
<a name="ln1204">  return primitive_value;</a>
<a name="ln1205">}</a>
<a name="ln1206"> </a>
<a name="ln1207">PrimitiveValue PrimitiveValue::Decimal(const string&amp; encoded_decimal_str, SortOrder sort_order) {</a>
<a name="ln1208">  PrimitiveValue primitive_value;</a>
<a name="ln1209">  if (sort_order == SortOrder::kDescending) {</a>
<a name="ln1210">    primitive_value.type_ = ValueType::kDecimalDescending;</a>
<a name="ln1211">  } else {</a>
<a name="ln1212">    primitive_value.type_ = ValueType::kDecimal;</a>
<a name="ln1213">  }</a>
<a name="ln1214">  new(&amp;primitive_value.decimal_val_) string(encoded_decimal_str);</a>
<a name="ln1215">  return primitive_value;</a>
<a name="ln1216">}</a>
<a name="ln1217"> </a>
<a name="ln1218">PrimitiveValue PrimitiveValue::VarInt(const string&amp; encoded_varint_str, SortOrder sort_order) {</a>
<a name="ln1219">  PrimitiveValue primitive_value;</a>
<a name="ln1220">  if (sort_order == SortOrder::kDescending) {</a>
<a name="ln1221">    primitive_value.type_ = ValueType::kVarIntDescending;</a>
<a name="ln1222">  } else {</a>
<a name="ln1223">    primitive_value.type_ = ValueType::kVarInt;</a>
<a name="ln1224">  }</a>
<a name="ln1225">  new(&amp;primitive_value.varint_val_) string(encoded_varint_str);</a>
<a name="ln1226">  return primitive_value;</a>
<a name="ln1227">}</a>
<a name="ln1228"> </a>
<a name="ln1229">PrimitiveValue PrimitiveValue::ArrayIndex(int64_t index) {</a>
<a name="ln1230">  PrimitiveValue primitive_value;</a>
<a name="ln1231">  primitive_value.type_ = ValueType::kArrayIndex;</a>
<a name="ln1232">  primitive_value.int64_val_ = index;</a>
<a name="ln1233">  return primitive_value;</a>
<a name="ln1234">}</a>
<a name="ln1235"> </a>
<a name="ln1236">PrimitiveValue PrimitiveValue::UInt16Hash(uint16_t hash) {</a>
<a name="ln1237">  PrimitiveValue primitive_value;</a>
<a name="ln1238">  primitive_value.type_ = ValueType::kUInt16Hash;</a>
<a name="ln1239">  primitive_value.uint16_val_ = hash;</a>
<a name="ln1240">  return primitive_value;</a>
<a name="ln1241">}</a>
<a name="ln1242"> </a>
<a name="ln1243">PrimitiveValue PrimitiveValue::SystemColumnId(SystemColumnIds system_column_id) {</a>
<a name="ln1244">  return PrimitiveValue::SystemColumnId(ColumnId(static_cast&lt;ColumnIdRep&gt;(system_column_id)));</a>
<a name="ln1245">}</a>
<a name="ln1246"> </a>
<a name="ln1247">PrimitiveValue PrimitiveValue::SystemColumnId(ColumnId column_id) {</a>
<a name="ln1248">  PrimitiveValue primitive_value;</a>
<a name="ln1249">  primitive_value.type_ = ValueType::kSystemColumnId;</a>
<a name="ln1250">  primitive_value.column_id_val_ = column_id;</a>
<a name="ln1251">  return primitive_value;</a>
<a name="ln1252">}</a>
<a name="ln1253"> </a>
<a name="ln1254">PrimitiveValue PrimitiveValue::Int32(int32_t v, SortOrder sort_order) {</a>
<a name="ln1255">  PrimitiveValue primitive_value;</a>
<a name="ln1256">  if (sort_order == SortOrder::kDescending) {</a>
<a name="ln1257">    primitive_value.type_ = ValueType::kInt32Descending;</a>
<a name="ln1258">  } else {</a>
<a name="ln1259">    primitive_value.type_ = ValueType::kInt32;</a>
<a name="ln1260">  }</a>
<a name="ln1261">  primitive_value.int32_val_ = v;</a>
<a name="ln1262">  return primitive_value;</a>
<a name="ln1263">}</a>
<a name="ln1264"> </a>
<a name="ln1265">PrimitiveValue PrimitiveValue::UInt32(uint32_t v, SortOrder sort_order) {</a>
<a name="ln1266">  PrimitiveValue primitive_value;</a>
<a name="ln1267">  if (sort_order == SortOrder::kDescending) {</a>
<a name="ln1268">    primitive_value.type_ = ValueType::kUInt32Descending;</a>
<a name="ln1269">  } else {</a>
<a name="ln1270">    primitive_value.type_ = ValueType::kUInt32;</a>
<a name="ln1271">  }</a>
<a name="ln1272">  primitive_value.uint32_val_ = v;</a>
<a name="ln1273">  return primitive_value;</a>
<a name="ln1274">}</a>
<a name="ln1275"> </a>
<a name="ln1276">PrimitiveValue PrimitiveValue::UInt64(uint64_t v, SortOrder sort_order) {</a>
<a name="ln1277">  PrimitiveValue primitive_value;</a>
<a name="ln1278">  if (sort_order == SortOrder::kDescending) {</a>
<a name="ln1279">    primitive_value.type_ = ValueType::kUInt64Descending;</a>
<a name="ln1280">  } else {</a>
<a name="ln1281">    primitive_value.type_ = ValueType::kUInt64;</a>
<a name="ln1282">  }</a>
<a name="ln1283">  primitive_value.uint64_val_ = v;</a>
<a name="ln1284">  return primitive_value;</a>
<a name="ln1285">}</a>
<a name="ln1286"> </a>
<a name="ln1287">PrimitiveValue PrimitiveValue::TransactionId(Uuid transaction_id) {</a>
<a name="ln1288">  PrimitiveValue primitive_value(transaction_id);</a>
<a name="ln1289">  primitive_value.type_ = ValueType::kTransactionId;</a>
<a name="ln1290">  return primitive_value;</a>
<a name="ln1291">}</a>
<a name="ln1292"> </a>
<a name="ln1293">PrimitiveValue PrimitiveValue::TableId(Uuid table_id) {</a>
<a name="ln1294">  PrimitiveValue primitive_value(table_id);</a>
<a name="ln1295">  primitive_value.type_ = ValueType::kTableId;</a>
<a name="ln1296">  return primitive_value;</a>
<a name="ln1297">}</a>
<a name="ln1298"> </a>
<a name="ln1299">PrimitiveValue PrimitiveValue::PgTableOid(const yb::PgTableOid pgtable_id) {</a>
<a name="ln1300">  PrimitiveValue primitive_value(pgtable_id);</a>
<a name="ln1301">  primitive_value.type_ = ValueType::kPgTableOid;</a>
<a name="ln1302">  return primitive_value;</a>
<a name="ln1303">}</a>
<a name="ln1304"> </a>
<a name="ln1305">PrimitiveValue PrimitiveValue::Jsonb(const std::string&amp; json) {</a>
<a name="ln1306">  PrimitiveValue primitive_value;</a>
<a name="ln1307">  primitive_value.type_ = ValueType::kJsonb;</a>
<a name="ln1308">  new(&amp;primitive_value.json_val_) string(json);</a>
<a name="ln1309">  return primitive_value;</a>
<a name="ln1310">}</a>
<a name="ln1311"> </a>
<a name="ln1312">KeyBytes PrimitiveValue::ToKeyBytes() const {</a>
<a name="ln1313">  KeyBytes kb;</a>
<a name="ln1314">  AppendToKey(&amp;kb);</a>
<a name="ln1315">  return kb;</a>
<a name="ln1316">}</a>
<a name="ln1317"> </a>
<a name="ln1318">bool PrimitiveValue::operator==(const PrimitiveValue&amp; other) const {</a>
<a name="ln1319">  if (type_ != other.type_) {</a>
<a name="ln1320">    return false;</a>
<a name="ln1321">  }</a>
<a name="ln1322">  switch (type_) {</a>
<a name="ln1323">    case ValueType::kNullHigh: FALLTHROUGH_INTENDED;</a>
<a name="ln1324">    case ValueType::kNullLow: FALLTHROUGH_INTENDED;</a>
<a name="ln1325">    case ValueType::kCounter: FALLTHROUGH_INTENDED;</a>
<a name="ln1326">    case ValueType::kFalse: FALLTHROUGH_INTENDED;</a>
<a name="ln1327">    case ValueType::kFalseDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln1328">    case ValueType::kSSForward: FALLTHROUGH_INTENDED;</a>
<a name="ln1329">    case ValueType::kSSReverse: FALLTHROUGH_INTENDED;</a>
<a name="ln1330">    case ValueType::kTrue: FALLTHROUGH_INTENDED;</a>
<a name="ln1331">    case ValueType::kTrueDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln1332">    case ValueType::kLowest: FALLTHROUGH_INTENDED;</a>
<a name="ln1333">    case ValueType::kHighest: FALLTHROUGH_INTENDED;</a>
<a name="ln1334">    case ValueType::kMaxByte: return true;</a>
<a name="ln1335"> </a>
<a name="ln1336">    case ValueType::kStringDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln1337">    case ValueType::kString: return str_val_ == other.str_val_;</a>
<a name="ln1338"> </a>
<a name="ln1339">    case ValueType::kFrozenDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln1340">    case ValueType::kFrozen: return *frozen_val_ == *other.frozen_val_;</a>
<a name="ln1341"> </a>
<a name="ln1342">    case ValueType::kInt32Descending: FALLTHROUGH_INTENDED;</a>
<a name="ln1343">    case ValueType::kWriteId: FALLTHROUGH_INTENDED;</a>
<a name="ln1344">    case ValueType::kInt32: return int32_val_ == other.int32_val_;</a>
<a name="ln1345"> </a>
<a name="ln1346">    case ValueType::kPgTableOid: FALLTHROUGH_INTENDED;</a>
<a name="ln1347">    case ValueType::kUInt32Descending: FALLTHROUGH_INTENDED;</a>
<a name="ln1348">    case ValueType::kUInt32: return uint32_val_ == other.uint32_val_;</a>
<a name="ln1349"> </a>
<a name="ln1350">    case ValueType::kUInt64Descending: FALLTHROUGH_INTENDED;</a>
<a name="ln1351">    case ValueType::kUInt64: return uint64_val_ == other.uint64_val_;</a>
<a name="ln1352"> </a>
<a name="ln1353">    case ValueType::kInt64Descending: FALLTHROUGH_INTENDED;</a>
<a name="ln1354">    case ValueType::kInt64: FALLTHROUGH_INTENDED;</a>
<a name="ln1355">    case ValueType::kArrayIndex: return int64_val_ == other.int64_val_;</a>
<a name="ln1356"> </a>
<a name="ln1357">    case ValueType::kFloatDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln1358">    case ValueType::kFloat: {</a>
<a name="ln1359">      if (util::IsNanFloat(float_val_) &amp;&amp; util::IsNanFloat(other.float_val_)) {</a>
<a name="ln1360">        return true;</a>
<a name="ln1361">      }</a>
<a name="ln1362">      return float_val_ == other.float_val_;</a>
<a name="ln1363">    }</a>
<a name="ln1364">    case ValueType::kDoubleDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln1365">    case ValueType::kDouble: {</a>
<a name="ln1366">      if (util::IsNanDouble(double_val_) &amp;&amp; util::IsNanDouble(other.double_val_)) {</a>
<a name="ln1367">        return true;</a>
<a name="ln1368">      }</a>
<a name="ln1369">      return double_val_ == other.double_val_;</a>
<a name="ln1370">    }</a>
<a name="ln1371">    case ValueType::kDecimalDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln1372">    case ValueType::kDecimal: return decimal_val_ == other.decimal_val_;</a>
<a name="ln1373">    case ValueType::kVarIntDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln1374">    case ValueType::kVarInt: return varint_val_ == other.varint_val_;</a>
<a name="ln1375">    case ValueType::kIntentTypeSet: FALLTHROUGH_INTENDED;</a>
<a name="ln1376">    case ValueType::kObsoleteIntentTypeSet: FALLTHROUGH_INTENDED;</a>
<a name="ln1377">    case ValueType::kObsoleteIntentType: FALLTHROUGH_INTENDED;</a>
<a name="ln1378">    case ValueType::kUInt16Hash: return uint16_val_ == other.uint16_val_;</a>
<a name="ln1379"> </a>
<a name="ln1380">    case ValueType::kTimestampDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln1381">    case ValueType::kTimestamp: return timestamp_val_ == other.timestamp_val_;</a>
<a name="ln1382">    case ValueType::kInetaddressDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln1383">    case ValueType::kInetaddress: return *inetaddress_val_ == *(other.inetaddress_val_);</a>
<a name="ln1384">    case ValueType::kTransactionApplyState: FALLTHROUGH_INTENDED;</a>
<a name="ln1385">    case ValueType::kTransactionId: FALLTHROUGH_INTENDED;</a>
<a name="ln1386">    case ValueType::kTableId: FALLTHROUGH_INTENDED;</a>
<a name="ln1387">    case ValueType::kUuidDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln1388">    case ValueType::kUuid: return uuid_val_ == other.uuid_val_;</a>
<a name="ln1389"> </a>
<a name="ln1390">    case ValueType::kColumnId: FALLTHROUGH_INTENDED;</a>
<a name="ln1391">    case ValueType::kSystemColumnId: return column_id_val_ == other.column_id_val_;</a>
<a name="ln1392">    case ValueType::kHybridTime: return hybrid_time_val_.CompareTo(other.hybrid_time_val_) == 0;</a>
<a name="ln1393">    IGNORE_NON_PRIMITIVE_VALUE_TYPES_IN_SWITCH;</a>
<a name="ln1394">  }</a>
<a name="ln1395">  FATAL_INVALID_ENUM_VALUE(ValueType, type_);</a>
<a name="ln1396">}</a>
<a name="ln1397"> </a>
<a name="ln1398">int PrimitiveValue::CompareTo(const PrimitiveValue&amp; other) const {</a>
<a name="ln1399">  int result = CompareUsingLessThan(type_, other.type_);</a>
<a name="ln1400">  if (result != 0) {</a>
<a name="ln1401">    return result;</a>
<a name="ln1402">  }</a>
<a name="ln1403">  switch (type_) {</a>
<a name="ln1404">    case ValueType::kNullHigh: FALLTHROUGH_INTENDED;</a>
<a name="ln1405">    case ValueType::kNullLow: FALLTHROUGH_INTENDED;</a>
<a name="ln1406">    case ValueType::kCounter: FALLTHROUGH_INTENDED;</a>
<a name="ln1407">    case ValueType::kSSForward: FALLTHROUGH_INTENDED;</a>
<a name="ln1408">    case ValueType::kSSReverse: FALLTHROUGH_INTENDED;</a>
<a name="ln1409">    case ValueType::kFalse: FALLTHROUGH_INTENDED;</a>
<a name="ln1410">    case ValueType::kTrue: FALLTHROUGH_INTENDED;</a>
<a name="ln1411">    case ValueType::kFalseDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln1412">    case ValueType::kTrueDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln1413">    case ValueType::kLowest: FALLTHROUGH_INTENDED;</a>
<a name="ln1414">    case ValueType::kHighest: FALLTHROUGH_INTENDED;</a>
<a name="ln1415">    case ValueType::kMaxByte:</a>
<a name="ln1416">      return 0;</a>
<a name="ln1417">    case ValueType::kStringDescending:</a>
<a name="ln1418">      return other.str_val_.compare(str_val_);</a>
<a name="ln1419">    case ValueType::kString:</a>
<a name="ln1420">      return str_val_.compare(other.str_val_);</a>
<a name="ln1421">    case ValueType::kInt64Descending:</a>
<a name="ln1422">      return CompareUsingLessThan(other.int64_val_, int64_val_);</a>
<a name="ln1423">    case ValueType::kInt32Descending:</a>
<a name="ln1424">      return CompareUsingLessThan(other.int32_val_, int32_val_);</a>
<a name="ln1425">    case ValueType::kInt32: FALLTHROUGH_INTENDED;</a>
<a name="ln1426">    case ValueType::kWriteId:</a>
<a name="ln1427">      return CompareUsingLessThan(int32_val_, other.int32_val_);</a>
<a name="ln1428">    case ValueType::kUInt32Descending:</a>
<a name="ln1429">      return CompareUsingLessThan(other.uint32_val_, uint32_val_);</a>
<a name="ln1430">    case ValueType::kPgTableOid: FALLTHROUGH_INTENDED;</a>
<a name="ln1431">    case ValueType::kUInt32:</a>
<a name="ln1432">      return CompareUsingLessThan(uint32_val_, other.uint32_val_);</a>
<a name="ln1433">    case ValueType::kUInt64Descending:</a>
<a name="ln1434">      return CompareUsingLessThan(other.uint64_val_, uint64_val_);</a>
<a name="ln1435">    case ValueType::kUInt64:</a>
<a name="ln1436">      return CompareUsingLessThan(uint64_val_, other.uint64_val_);</a>
<a name="ln1437">    case ValueType::kInt64: FALLTHROUGH_INTENDED;</a>
<a name="ln1438">    case ValueType::kArrayIndex:</a>
<a name="ln1439">      return CompareUsingLessThan(int64_val_, other.int64_val_);</a>
<a name="ln1440">    case ValueType::kDoubleDescending:</a>
<a name="ln1441">      return CompareUsingLessThan(other.double_val_, double_val_);</a>
<a name="ln1442">    case ValueType::kDouble:</a>
<a name="ln1443">      return CompareUsingLessThan(double_val_, other.double_val_);</a>
<a name="ln1444">    case ValueType::kFloatDescending:</a>
<a name="ln1445">      return CompareUsingLessThan(other.float_val_, float_val_);</a>
<a name="ln1446">    case ValueType::kFloat:</a>
<a name="ln1447">      return CompareUsingLessThan(float_val_, other.float_val_);</a>
<a name="ln1448">    case ValueType::kDecimalDescending:</a>
<a name="ln1449">      return other.decimal_val_.compare(decimal_val_);</a>
<a name="ln1450">    case ValueType::kDecimal:</a>
<a name="ln1451">      return decimal_val_.compare(other.decimal_val_);</a>
<a name="ln1452">    case ValueType::kVarIntDescending:</a>
<a name="ln1453">      return other.varint_val_.compare(varint_val_);</a>
<a name="ln1454">    case ValueType::kVarInt:</a>
<a name="ln1455">      return varint_val_.compare(other.varint_val_);</a>
<a name="ln1456">    case ValueType::kIntentTypeSet: FALLTHROUGH_INTENDED;</a>
<a name="ln1457">    case ValueType::kObsoleteIntentTypeSet: FALLTHROUGH_INTENDED;</a>
<a name="ln1458">    case ValueType::kObsoleteIntentType: FALLTHROUGH_INTENDED;</a>
<a name="ln1459">    case ValueType::kUInt16Hash:</a>
<a name="ln1460">      return CompareUsingLessThan(uint16_val_, other.uint16_val_);</a>
<a name="ln1461">    case ValueType::kTimestampDescending:</a>
<a name="ln1462">      return CompareUsingLessThan(other.timestamp_val_, timestamp_val_);</a>
<a name="ln1463">    case ValueType::kTimestamp:</a>
<a name="ln1464">      return CompareUsingLessThan(timestamp_val_, other.timestamp_val_);</a>
<a name="ln1465">    case ValueType::kInetaddress:</a>
<a name="ln1466">      return CompareUsingLessThan(*inetaddress_val_, *(other.inetaddress_val_));</a>
<a name="ln1467">    case ValueType::kInetaddressDescending:</a>
<a name="ln1468">      return CompareUsingLessThan(*(other.inetaddress_val_), *inetaddress_val_);</a>
<a name="ln1469">    case ValueType::kFrozenDescending: FALLTHROUGH_INTENDED;</a>
<a name="ln1470">    case ValueType::kFrozen: {</a>
<a name="ln1471">      // Compare elements one by one.</a>
<a name="ln1472">      size_t min_size = std::min(frozen_val_-&gt;size(), other.frozen_val_-&gt;size());</a>
<a name="ln1473">      for (size_t i = 0; i &lt; min_size; i++) {</a>
<a name="ln1474">        result = frozen_val_-&gt;at(i).CompareTo(other.frozen_val_-&gt;at(i));</a>
<a name="ln1475">        if (result != 0) {</a>
<a name="ln1476">          return result;</a>
<a name="ln1477">        }</a>
<a name="ln1478">      }</a>
<a name="ln1479"> </a>
<a name="ln1480">      // If elements are equal, compare lengths.</a>
<a name="ln1481">      if (type_ == ValueType::kFrozenDescending) {</a>
<a name="ln1482">        return CompareUsingLessThan(other.frozen_val_-&gt;size(), frozen_val_-&gt;size());</a>
<a name="ln1483">      } else {</a>
<a name="ln1484">        return CompareUsingLessThan(frozen_val_-&gt;size(), other.frozen_val_-&gt;size());</a>
<a name="ln1485">      }</a>
<a name="ln1486">    }</a>
<a name="ln1487">    case ValueType::kTransactionApplyState: FALLTHROUGH_INTENDED;</a>
<a name="ln1488">    case ValueType::kTransactionId: FALLTHROUGH_INTENDED;</a>
<a name="ln1489">    case ValueType::kTableId: FALLTHROUGH_INTENDED;</a>
<a name="ln1490">    case ValueType::kUuidDescending:</a>
<a name="ln1491">      return CompareUsingLessThan(other.uuid_val_, uuid_val_);</a>
<a name="ln1492">    case ValueType::kUuid:</a>
<a name="ln1493">      return CompareUsingLessThan(uuid_val_, other.uuid_val_);</a>
<a name="ln1494">    case ValueType::kColumnId: FALLTHROUGH_INTENDED;</a>
<a name="ln1495">    case ValueType::kSystemColumnId:</a>
<a name="ln1496">      return CompareUsingLessThan(column_id_val_, other.column_id_val_);</a>
<a name="ln1497">    case ValueType::kHybridTime:</a>
<a name="ln1498">      // HybridTimes are sorted in reverse order when wrapped in a PrimitiveValue.</a>
<a name="ln1499">      return -hybrid_time_val_.CompareTo(other.hybrid_time_val_);</a>
<a name="ln1500">    IGNORE_NON_PRIMITIVE_VALUE_TYPES_IN_SWITCH;</a>
<a name="ln1501">  }</a>
<a name="ln1502">  LOG(FATAL) &lt;&lt; &quot;Comparing invalid PrimitiveValues: &quot; &lt;&lt; *this &lt;&lt; &quot; and &quot; &lt;&lt; other;</a>
<a name="ln1503">}</a>
<a name="ln1504"> </a>
<a name="ln1505">// This is used to initialize kNullLow, kNullHigh, kTrue, kFalse constants.</a>
<a name="ln1506">PrimitiveValue::PrimitiveValue(ValueType value_type)</a>
<a name="ln1507">    : type_(value_type) {</a>
<a name="ln1508">  complex_data_structure_ = nullptr;</a>
<a name="ln1509">  if (value_type == ValueType::kString || value_type == ValueType::kStringDescending) {</a>
<a name="ln1510">    new(&amp;str_val_) std::string();</a>
<a name="ln1511">  } else if (value_type == ValueType::kInetaddress</a>
<a name="ln1512">      || value_type == ValueType::kInetaddressDescending) {</a>
<a name="ln1513">    inetaddress_val_ = new InetAddress();</a>
<a name="ln1514">  } else if (value_type == ValueType::kDecimal || value_type == ValueType::kDecimalDescending) {</a>
<a name="ln1515">    new(&amp;decimal_val_) std::string();</a>
<a name="ln1516">  } else if (value_type == ValueType::kUuid || value_type == ValueType::kUuidDescending) {</a>
<a name="ln1517">    new(&amp;uuid_val_) Uuid();</a>
<a name="ln1518">  } else if (value_type == ValueType::kFrozen || value_type == ValueType::kFrozenDescending) {</a>
<a name="ln1519">    frozen_val_ = new FrozenContainer();</a>
<a name="ln1520">  } else if (value_type == ValueType::kJsonb) {</a>
<a name="ln1521">    new(&amp;json_val_) std::string();</a>
<a name="ln1522">  }</a>
<a name="ln1523">}</a>
<a name="ln1524"> </a>
<a name="ln1525">PrimitiveValue PrimitiveValue::NullValue(ColumnSchema::SortingType sorting) {</a>
<a name="ln1526">  using SortingType = ColumnSchema::SortingType;</a>
<a name="ln1527"> </a>
<a name="ln1528">  return PrimitiveValue(</a>
<a name="ln1529">      sorting == SortingType::kAscendingNullsLast || sorting == SortingType::kDescendingNullsLast</a>
<a name="ln1530">      ? ValueType::kNullHigh</a>
<a name="ln1531">      : ValueType::kNullLow);</a>
<a name="ln1532">}</a>
<a name="ln1533"> </a>
<a name="ln1534">SortOrder PrimitiveValue::SortOrderFromColumnSchemaSortingType(</a>
<a name="ln1535">    ColumnSchema::SortingType sorting_type) {</a>
<a name="ln1536">  if (sorting_type == ColumnSchema::SortingType::kDescending ||</a>
<a name="ln1537">      sorting_type == ColumnSchema::SortingType::kDescendingNullsLast) {</a>
<a name="ln1538">    return SortOrder::kDescending;</a>
<a name="ln1539">  }</a>
<a name="ln1540">  return SortOrder::kAscending;</a>
<a name="ln1541">}</a>
<a name="ln1542"> </a>
<a name="ln1543">PrimitiveValue PrimitiveValue::FromQLValuePB(const QLValuePB&amp; value,</a>
<a name="ln1544">                                             ColumnSchema::SortingType sorting_type) {</a>
<a name="ln1545">  const auto sort_order = SortOrderFromColumnSchemaSortingType(sorting_type);</a>
<a name="ln1546"> </a>
<a name="ln1547">  switch (value.value_case()) {</a>
<a name="ln1548">    case QLValuePB::kInt8Value:</a>
<a name="ln1549">      return PrimitiveValue::Int32(value.int8_value(), sort_order);</a>
<a name="ln1550">    case QLValuePB::kInt16Value:</a>
<a name="ln1551">      return PrimitiveValue::Int32(value.int16_value(), sort_order);</a>
<a name="ln1552">    case QLValuePB::kInt32Value:</a>
<a name="ln1553">      return PrimitiveValue::Int32(value.int32_value(), sort_order);</a>
<a name="ln1554">    case QLValuePB::kInt64Value:</a>
<a name="ln1555">      return PrimitiveValue(value.int64_value(), sort_order);</a>
<a name="ln1556">    case QLValuePB::kUint32Value:</a>
<a name="ln1557">      return PrimitiveValue::UInt32(value.uint32_value(), sort_order);</a>
<a name="ln1558">    case QLValuePB::kUint64Value:</a>
<a name="ln1559">      return PrimitiveValue::UInt64(value.uint64_value(), sort_order);</a>
<a name="ln1560">    case QLValuePB::kFloatValue: {</a>
<a name="ln1561">      float f = value.float_value();</a>
<a name="ln1562">      return PrimitiveValue::Float(util::CanonicalizeFloat(f), sort_order);</a>
<a name="ln1563">    }</a>
<a name="ln1564">    case QLValuePB::kDoubleValue: {</a>
<a name="ln1565">      double d = value.double_value();</a>
<a name="ln1566">      return PrimitiveValue::Double(util::CanonicalizeDouble(d), sort_order);</a>
<a name="ln1567">    }</a>
<a name="ln1568">    case QLValuePB::kDecimalValue:</a>
<a name="ln1569">      return PrimitiveValue::Decimal(value.decimal_value(), sort_order);</a>
<a name="ln1570">    case QLValuePB::kVarintValue:</a>
<a name="ln1571">      return PrimitiveValue::VarInt(value.varint_value(), sort_order);</a>
<a name="ln1572">    case QLValuePB::kStringValue:</a>
<a name="ln1573">      return PrimitiveValue(value.string_value(), sort_order);</a>
<a name="ln1574">    case QLValuePB::kBinaryValue:</a>
<a name="ln1575">      // TODO consider using dedicated encoding for binary (not string) to avoid overhead of</a>
<a name="ln1576">      // zero-encoding for keys (since zero-bytes could be common for binary)</a>
<a name="ln1577">      return PrimitiveValue(value.binary_value(), sort_order);</a>
<a name="ln1578">    case QLValuePB::kBoolValue:</a>
<a name="ln1579">      return PrimitiveValue(sort_order == SortOrder::kDescending</a>
<a name="ln1580">                            ? (value.bool_value() ? ValueType::kTrueDescending</a>
<a name="ln1581">                                                  : ValueType::kFalseDescending)</a>
<a name="ln1582">                            : (value.bool_value() ? ValueType::kTrue</a>
<a name="ln1583">                                                  : ValueType::kFalse));</a>
<a name="ln1584">    case QLValuePB::kTimestampValue:</a>
<a name="ln1585">      return PrimitiveValue(QLValue::timestamp_value(value), sort_order);</a>
<a name="ln1586">    case QLValuePB::kDateValue:</a>
<a name="ln1587">      return PrimitiveValue::UInt32(value.date_value(), sort_order);</a>
<a name="ln1588">    case QLValuePB::kTimeValue:</a>
<a name="ln1589">      return PrimitiveValue(value.time_value(), sort_order);</a>
<a name="ln1590">    case QLValuePB::kInetaddressValue:</a>
<a name="ln1591">      return PrimitiveValue(QLValue::inetaddress_value(value), sort_order);</a>
<a name="ln1592">    case QLValuePB::kJsonbValue:</a>
<a name="ln1593">      return PrimitiveValue::Jsonb(QLValue::jsonb_value(value));</a>
<a name="ln1594">    case QLValuePB::kUuidValue:</a>
<a name="ln1595">      return PrimitiveValue(QLValue::uuid_value(value), sort_order);</a>
<a name="ln1596">    case QLValuePB::kTimeuuidValue:</a>
<a name="ln1597">      return PrimitiveValue(QLValue::timeuuid_value(value), sort_order);</a>
<a name="ln1598">    case QLValuePB::kFrozenValue: {</a>
<a name="ln1599">      QLSeqValuePB frozen = value.frozen_value();</a>
<a name="ln1600">      PrimitiveValue pv(ValueType::kFrozen);</a>
<a name="ln1601">      auto null_value_type = ValueType::kNullLow;</a>
<a name="ln1602">      if (sort_order == SortOrder::kDescending) {</a>
<a name="ln1603">        null_value_type = ValueType::kNullHigh;</a>
<a name="ln1604">        pv.type_ = ValueType::kFrozenDescending;</a>
<a name="ln1605">      }</a>
<a name="ln1606"> </a>
<a name="ln1607">      for (int i = 0; i &lt; frozen.elems_size(); i++) {</a>
<a name="ln1608">        if (IsNull(frozen.elems(i))) {</a>
<a name="ln1609">          pv.frozen_val_-&gt;emplace_back(null_value_type);</a>
<a name="ln1610">        } else {</a>
<a name="ln1611">          pv.frozen_val_-&gt;push_back(PrimitiveValue::FromQLValuePB(frozen.elems(i), sorting_type));</a>
<a name="ln1612">        }</a>
<a name="ln1613">      }</a>
<a name="ln1614">      return pv;</a>
<a name="ln1615">    }</a>
<a name="ln1616">    case QLValuePB::VALUE_NOT_SET:</a>
<a name="ln1617">      return PrimitiveValue::kTombstone;</a>
<a name="ln1618"> </a>
<a name="ln1619">    case QLValuePB::kMapValue: FALLTHROUGH_INTENDED;</a>
<a name="ln1620">    case QLValuePB::kSetValue: FALLTHROUGH_INTENDED;</a>
<a name="ln1621">    case QLValuePB::kListValue:</a>
<a name="ln1622">      break;</a>
<a name="ln1623"> </a>
<a name="ln1624">    // default: fall through</a>
<a name="ln1625">  }</a>
<a name="ln1626"> </a>
<a name="ln1627">  LOG(FATAL) &lt;&lt; &quot;Unsupported datatype in PrimitiveValue: &quot; &lt;&lt; value.value_case();</a>
<a name="ln1628">}</a>
<a name="ln1629"> </a>
<a name="ln1630">void PrimitiveValue::ToQLValuePB(const PrimitiveValue&amp; primitive_value,</a>
<a name="ln1631">                                 const std::shared_ptr&lt;QLType&gt;&amp; ql_type,</a>
<a name="ln1632">                                 QLValuePB* ql_value) {</a>
<a name="ln1633">  // DocDB sets type to kInvalidValueType for SubDocuments that don't exist. That's why they need</a>
<a name="ln1634">  // to be set to Null in QLValue.</a>
<a name="ln1635">  if (primitive_value.value_type() == ValueType::kNullLow ||</a>
<a name="ln1636">      primitive_value.value_type() == ValueType::kNullHigh ||</a>
<a name="ln1637">      primitive_value.value_type() == ValueType::kInvalid) {</a>
<a name="ln1638">    SetNull(ql_value);</a>
<a name="ln1639">    return;</a>
<a name="ln1640">  }</a>
<a name="ln1641"> </a>
<a name="ln1642">  switch (ql_type-&gt;main()) {</a>
<a name="ln1643">    case INT8:</a>
<a name="ln1644">      ql_value-&gt;set_int8_value(static_cast&lt;int8_t&gt;(primitive_value.GetInt32()));</a>
<a name="ln1645">      return;</a>
<a name="ln1646">    case INT16:</a>
<a name="ln1647">      ql_value-&gt;set_int16_value(static_cast&lt;int16_t&gt;(primitive_value.GetInt32()));</a>
<a name="ln1648">      return;</a>
<a name="ln1649">    case INT32:</a>
<a name="ln1650">      ql_value-&gt;set_int32_value(primitive_value.GetInt32());</a>
<a name="ln1651">      return;</a>
<a name="ln1652">    case INT64:</a>
<a name="ln1653">      ql_value-&gt;set_int64_value(primitive_value.GetInt64());</a>
<a name="ln1654">      return;</a>
<a name="ln1655">    case UINT32:</a>
<a name="ln1656">      ql_value-&gt;set_uint32_value(primitive_value.GetUInt32());</a>
<a name="ln1657">      return;</a>
<a name="ln1658">    case UINT64:</a>
<a name="ln1659">      ql_value-&gt;set_uint64_value(primitive_value.GetUInt64());</a>
<a name="ln1660">      return;</a>
<a name="ln1661">    case FLOAT:</a>
<a name="ln1662">      ql_value-&gt;set_float_value(primitive_value.GetFloat());</a>
<a name="ln1663">      return;</a>
<a name="ln1664">    case DOUBLE:</a>
<a name="ln1665">      ql_value-&gt;set_double_value(primitive_value.GetDouble());</a>
<a name="ln1666">      return;</a>
<a name="ln1667">    case DECIMAL:</a>
<a name="ln1668">      ql_value-&gt;set_decimal_value(primitive_value.GetDecimal());</a>
<a name="ln1669">      return;</a>
<a name="ln1670">    case VARINT:</a>
<a name="ln1671">      ql_value-&gt;set_varint_value(primitive_value.GetVarInt());</a>
<a name="ln1672">      return;</a>
<a name="ln1673">    case BOOL:</a>
<a name="ln1674">      ql_value-&gt;set_bool_value(primitive_value.value_type() == ValueType::kTrue ||</a>
<a name="ln1675">                               primitive_value.value_type() == ValueType::kTrueDescending);</a>
<a name="ln1676">      return;</a>
<a name="ln1677">    case TIMESTAMP:</a>
<a name="ln1678">      ql_value-&gt;set_timestamp_value(primitive_value.GetTimestamp().ToInt64());</a>
<a name="ln1679">      return;</a>
<a name="ln1680">    case DATE:</a>
<a name="ln1681">      ql_value-&gt;set_date_value(primitive_value.GetUInt32());</a>
<a name="ln1682">      return;</a>
<a name="ln1683">    case TIME:</a>
<a name="ln1684">      ql_value-&gt;set_time_value(primitive_value.GetInt64());</a>
<a name="ln1685">      return;</a>
<a name="ln1686">    case INET: {</a>
<a name="ln1687">      QLValue temp_value;</a>
<a name="ln1688">      temp_value.set_inetaddress_value(*primitive_value.GetInetaddress());</a>
<a name="ln1689">      *ql_value = std::move(*temp_value.mutable_value());</a>
<a name="ln1690">      return;</a>
<a name="ln1691">    }</a>
<a name="ln1692">    case JSONB: {</a>
<a name="ln1693">      QLValue temp_value;</a>
<a name="ln1694">      temp_value.set_jsonb_value(primitive_value.GetJson());</a>
<a name="ln1695">      *ql_value = std::move(*temp_value.mutable_value());</a>
<a name="ln1696">      return;</a>
<a name="ln1697">    }</a>
<a name="ln1698">    case UUID: {</a>
<a name="ln1699">      QLValue temp_value;</a>
<a name="ln1700">      temp_value.set_uuid_value(primitive_value.GetUuid());</a>
<a name="ln1701">      *ql_value = std::move(*temp_value.mutable_value());</a>
<a name="ln1702">      return;</a>
<a name="ln1703">    }</a>
<a name="ln1704">    case TIMEUUID: {</a>
<a name="ln1705">      QLValue temp_value;</a>
<a name="ln1706">      temp_value.set_timeuuid_value(primitive_value.GetUuid());</a>
<a name="ln1707">      *ql_value = std::move(*temp_value.mutable_value());</a>
<a name="ln1708">      return;</a>
<a name="ln1709">    }</a>
<a name="ln1710">    case STRING:</a>
<a name="ln1711">      ql_value-&gt;set_string_value(primitive_value.GetString());</a>
<a name="ln1712">      return;</a>
<a name="ln1713">    case BINARY:</a>
<a name="ln1714">      ql_value-&gt;set_binary_value(primitive_value.GetString());</a>
<a name="ln1715">      return;</a>
<a name="ln1716">    case FROZEN: {</a>
<a name="ln1717">      const auto&amp; type = ql_type-&gt;param_type(0);</a>
<a name="ln1718">      QLSeqValuePB *frozen_value = ql_value-&gt;mutable_frozen_value();</a>
<a name="ln1719">      frozen_value-&gt;clear_elems();</a>
<a name="ln1720">      switch (type-&gt;main()) {</a>
<a name="ln1721">        case MAP: {</a>
<a name="ln1722">          const std::shared_ptr&lt;QLType&gt;&amp; keys_type = type-&gt;param_type(0);</a>
<a name="ln1723">          const std::shared_ptr&lt;QLType&gt;&amp; values_type = type-&gt;param_type(1);</a>
<a name="ln1724">          for (int i = 0; i &lt; primitive_value.frozen_val_-&gt;size(); i++) {</a>
<a name="ln1725">            if (i % 2 == 0) {</a>
<a name="ln1726">              QLValuePB *key = frozen_value-&gt;add_elems();</a>
<a name="ln1727">              PrimitiveValue::ToQLValuePB(primitive_value.frozen_val_-&gt;at(i), keys_type, key);</a>
<a name="ln1728">            } else {</a>
<a name="ln1729">              QLValuePB *value = frozen_value-&gt;add_elems();</a>
<a name="ln1730">              PrimitiveValue::ToQLValuePB(primitive_value.frozen_val_-&gt;at(i), values_type, value);</a>
<a name="ln1731">            }</a>
<a name="ln1732">          }</a>
<a name="ln1733">          return;</a>
<a name="ln1734">        }</a>
<a name="ln1735">        case SET: FALLTHROUGH_INTENDED;</a>
<a name="ln1736">        case LIST: {</a>
<a name="ln1737">          const std::shared_ptr&lt;QLType&gt;&amp; elems_type = type-&gt;param_type(0);</a>
<a name="ln1738">          for (const auto &amp;pv : *primitive_value.frozen_val_) {</a>
<a name="ln1739">            QLValuePB *elem = frozen_value-&gt;add_elems();</a>
<a name="ln1740">            PrimitiveValue::ToQLValuePB(pv, elems_type, elem);</a>
<a name="ln1741">          }</a>
<a name="ln1742">          return;</a>
<a name="ln1743">        }</a>
<a name="ln1744">        case USER_DEFINED_TYPE: {</a>
<a name="ln1745">          for (int i = 0; i &lt; primitive_value.frozen_val_-&gt;size(); i++) {</a>
<a name="ln1746">            QLValuePB *value = frozen_value-&gt;add_elems();</a>
<a name="ln1747">            PrimitiveValue::ToQLValuePB(primitive_value.frozen_val_-&gt;at(i), type-&gt;param_type(i),</a>
<a name="ln1748">                value);</a>
<a name="ln1749">          }</a>
<a name="ln1750">          return;</a>
<a name="ln1751">        }</a>
<a name="ln1752"> </a>
<a name="ln1753">        default:</a>
<a name="ln1754">          break;</a>
<a name="ln1755">      }</a>
<a name="ln1756">      FATAL_INVALID_ENUM_VALUE(DataType, type-&gt;main());</a>
<a name="ln1757">    }</a>
<a name="ln1758"> </a>
<a name="ln1759">    case NULL_VALUE_TYPE: FALLTHROUGH_INTENDED;</a>
<a name="ln1760">    case MAP: FALLTHROUGH_INTENDED;</a>
<a name="ln1761">    case SET: FALLTHROUGH_INTENDED;</a>
<a name="ln1762">    case LIST: FALLTHROUGH_INTENDED;</a>
<a name="ln1763">    case TUPLE: FALLTHROUGH_INTENDED;</a>
<a name="ln1764">    case TYPEARGS: FALLTHROUGH_INTENDED;</a>
<a name="ln1765">    case USER_DEFINED_TYPE: FALLTHROUGH_INTENDED;</a>
<a name="ln1766"> </a>
<a name="ln1767">    case UINT8:  FALLTHROUGH_INTENDED;</a>
<a name="ln1768">    case UINT16: FALLTHROUGH_INTENDED;</a>
<a name="ln1769">    case UNKNOWN_DATA:</a>
<a name="ln1770">      break;</a>
<a name="ln1771"> </a>
<a name="ln1772">    // default: fall through</a>
<a name="ln1773">  }</a>
<a name="ln1774"> </a>
<a name="ln1775">  LOG(FATAL) &lt;&lt; &quot;Unsupported datatype &quot; &lt;&lt; ql_type-&gt;ToString();</a>
<a name="ln1776">}</a>
<a name="ln1777"> </a>
<a name="ln1778">}  // namespace docdb</a>
<a name="ln1779">}  // namespace yb</a>

</code></pre>
<div class="balloon" rel="361"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="368"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="273"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 273, 391</p></div>
<div class="balloon" rel="527"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
