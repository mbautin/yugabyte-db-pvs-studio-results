
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>gthr-default.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* Threads compatibility routines for libgcc2 and libobjc.  */</a>
<a name="ln2">/* Compile this one with gcc.  */</a>
<a name="ln3">/* Copyright (C) 1997-2018 Free Software Foundation, Inc.</a>
<a name="ln4"> </a>
<a name="ln5">This file is part of GCC.</a>
<a name="ln6"> </a>
<a name="ln7">GCC is free software; you can redistribute it and/or modify it under</a>
<a name="ln8">the terms of the GNU General Public License as published by the Free</a>
<a name="ln9">Software Foundation; either version 3, or (at your option) any later</a>
<a name="ln10">version.</a>
<a name="ln11"> </a>
<a name="ln12">GCC is distributed in the hope that it will be useful, but WITHOUT ANY</a>
<a name="ln13">WARRANTY; without even the implied warranty of MERCHANTABILITY or</a>
<a name="ln14">FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License</a>
<a name="ln15">for more details.</a>
<a name="ln16"> </a>
<a name="ln17">Under Section 7 of GPL version 3, you are granted additional</a>
<a name="ln18">permissions described in the GCC Runtime Library Exception, version</a>
<a name="ln19">3.1, as published by the Free Software Foundation.</a>
<a name="ln20"> </a>
<a name="ln21">You should have received a copy of the GNU General Public License and</a>
<a name="ln22">a copy of the GCC Runtime Library Exception along with this program;</a>
<a name="ln23">see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see</a>
<a name="ln24">&lt;http://www.gnu.org/licenses/&gt;.  */</a>
<a name="ln25"> </a>
<a name="ln26">#ifndef _GLIBCXX_GCC_GTHR_POSIX_H</a>
<a name="ln27">#define _GLIBCXX_GCC_GTHR_POSIX_H</a>
<a name="ln28"> </a>
<a name="ln29">/* POSIX threads specific definitions.</a>
<a name="ln30">   Easy, since the interface is just one-to-one mapping.  */</a>
<a name="ln31"> </a>
<a name="ln32">#define __GTHREADS 1</a>
<a name="ln33">#define __GTHREADS_CXX0X 1</a>
<a name="ln34"> </a>
<a name="ln35">#include &lt;pthread.h&gt;</a>
<a name="ln36"> </a>
<a name="ln37">#if ((defined(_LIBOBJC) || defined(_LIBOBJC_WEAK)) \</a>
<a name="ln38">     || !defined(_GTHREAD_USE_MUTEX_TIMEDLOCK))</a>
<a name="ln39"># include &lt;unistd.h&gt;</a>
<a name="ln40"># if defined(_POSIX_TIMEOUTS) &amp;&amp; _POSIX_TIMEOUTS &gt;= 0</a>
<a name="ln41">#  define _GTHREAD_USE_MUTEX_TIMEDLOCK 1</a>
<a name="ln42"># else</a>
<a name="ln43">#  define _GTHREAD_USE_MUTEX_TIMEDLOCK 0</a>
<a name="ln44"># endif</a>
<a name="ln45">#endif</a>
<a name="ln46"> </a>
<a name="ln47">typedef pthread_t __gthread_t;</a>
<a name="ln48">typedef pthread_key_t __gthread_key_t;</a>
<a name="ln49">typedef pthread_once_t __gthread_once_t;</a>
<a name="ln50">typedef pthread_mutex_t __gthread_mutex_t;</a>
<a name="ln51">typedef pthread_mutex_t __gthread_recursive_mutex_t;</a>
<a name="ln52">typedef pthread_cond_t __gthread_cond_t;</a>
<a name="ln53">typedef struct timespec __gthread_time_t;</a>
<a name="ln54"> </a>
<a name="ln55">/* POSIX like conditional variables are supported.  Please look at comments</a>
<a name="ln56">   in gthr.h for details. */</a>
<a name="ln57">#define __GTHREAD_HAS_COND	1</a>
<a name="ln58"> </a>
<a name="ln59">#define __GTHREAD_MUTEX_INIT PTHREAD_MUTEX_INITIALIZER</a>
<a name="ln60">#define __GTHREAD_MUTEX_INIT_FUNCTION __gthread_mutex_init_function</a>
<a name="ln61">#define __GTHREAD_ONCE_INIT PTHREAD_ONCE_INIT</a>
<a name="ln62">#if defined(PTHREAD_RECURSIVE_MUTEX_INITIALIZER)</a>
<a name="ln63">#define __GTHREAD_RECURSIVE_MUTEX_INIT PTHREAD_RECURSIVE_MUTEX_INITIALIZER</a>
<a name="ln64">#elif defined(PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP)</a>
<a name="ln65">#define __GTHREAD_RECURSIVE_MUTEX_INIT PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP</a>
<a name="ln66">#else</a>
<a name="ln67">#define __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION __gthread_recursive_mutex_init_function</a>
<a name="ln68">#endif</a>
<a name="ln69">#define __GTHREAD_COND_INIT PTHREAD_COND_INITIALIZER</a>
<a name="ln70">#define __GTHREAD_TIME_INIT {0,0}</a>
<a name="ln71"> </a>
<a name="ln72">#ifdef _GTHREAD_USE_MUTEX_INIT_FUNC</a>
<a name="ln73"># undef __GTHREAD_MUTEX_INIT</a>
<a name="ln74">#endif</a>
<a name="ln75">#ifdef _GTHREAD_USE_RECURSIVE_MUTEX_INIT_FUNC</a>
<a name="ln76"># undef __GTHREAD_RECURSIVE_MUTEX_INIT</a>
<a name="ln77"># undef __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION</a>
<a name="ln78"># define __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION __gthread_recursive_mutex_init_function</a>
<a name="ln79">#endif</a>
<a name="ln80">#ifdef _GTHREAD_USE_COND_INIT_FUNC</a>
<a name="ln81"># undef __GTHREAD_COND_INIT</a>
<a name="ln82"># define __GTHREAD_COND_INIT_FUNCTION __gthread_cond_init_function</a>
<a name="ln83">#endif</a>
<a name="ln84"> </a>
<a name="ln85">#if __GXX_WEAK__ &amp;&amp; _GLIBCXX_GTHREAD_USE_WEAK</a>
<a name="ln86"># ifndef __gthrw_pragma</a>
<a name="ln87">#  define __gthrw_pragma(pragma)</a>
<a name="ln88"># endif</a>
<a name="ln89"># define __gthrw2(name,name2,type) \</a>
<a name="ln90">  static __typeof(type) name __attribute__ ((__weakref__(#name2))); \</a>
<a name="ln91">  __gthrw_pragma(weak type)</a>
<a name="ln92"># define __gthrw_(name) __gthrw_ ## name</a>
<a name="ln93">#else</a>
<a name="ln94"># define __gthrw2(name,name2,type)</a>
<a name="ln95"># define __gthrw_(name) name</a>
<a name="ln96">#endif</a>
<a name="ln97"> </a>
<a name="ln98">/* Typically, __gthrw_foo is a weak reference to symbol foo.  */</a>
<a name="ln99">#define __gthrw(name) __gthrw2(__gthrw_ ## name,name,name)</a>
<a name="ln100"> </a>
<a name="ln101">__gthrw(pthread_once)</a>
<a name="ln102">__gthrw(pthread_getspecific)</a>
<a name="ln103">__gthrw(pthread_setspecific)</a>
<a name="ln104"> </a>
<a name="ln105">__gthrw(pthread_create)</a>
<a name="ln106">__gthrw(pthread_join)</a>
<a name="ln107">__gthrw(pthread_equal)</a>
<a name="ln108">__gthrw(pthread_self)</a>
<a name="ln109">__gthrw(pthread_detach)</a>
<a name="ln110">#ifndef __BIONIC__</a>
<a name="ln111">__gthrw(pthread_cancel)</a>
<a name="ln112">#endif</a>
<a name="ln113">__gthrw(sched_yield)</a>
<a name="ln114"> </a>
<a name="ln115">__gthrw(pthread_mutex_lock)</a>
<a name="ln116">__gthrw(pthread_mutex_trylock)</a>
<a name="ln117">#if _GTHREAD_USE_MUTEX_TIMEDLOCK</a>
<a name="ln118">__gthrw(pthread_mutex_timedlock)</a>
<a name="ln119">#endif</a>
<a name="ln120">__gthrw(pthread_mutex_unlock)</a>
<a name="ln121">__gthrw(pthread_mutex_init)</a>
<a name="ln122">__gthrw(pthread_mutex_destroy)</a>
<a name="ln123"> </a>
<a name="ln124">__gthrw(pthread_cond_init)</a>
<a name="ln125">__gthrw(pthread_cond_broadcast)</a>
<a name="ln126">__gthrw(pthread_cond_signal)</a>
<a name="ln127">__gthrw(pthread_cond_wait)</a>
<a name="ln128">__gthrw(pthread_cond_timedwait)</a>
<a name="ln129">__gthrw(pthread_cond_destroy)</a>
<a name="ln130"> </a>
<a name="ln131">__gthrw(pthread_key_create)</a>
<a name="ln132">__gthrw(pthread_key_delete)</a>
<a name="ln133">__gthrw(pthread_mutexattr_init)</a>
<a name="ln134">__gthrw(pthread_mutexattr_settype)</a>
<a name="ln135">__gthrw(pthread_mutexattr_destroy)</a>
<a name="ln136"> </a>
<a name="ln137"> </a>
<a name="ln138">#if defined(_LIBOBJC) || defined(_LIBOBJC_WEAK)</a>
<a name="ln139">/* Objective-C.  */</a>
<a name="ln140">__gthrw(pthread_exit)</a>
<a name="ln141">#ifdef _POSIX_PRIORITY_SCHEDULING</a>
<a name="ln142">#ifdef _POSIX_THREAD_PRIORITY_SCHEDULING</a>
<a name="ln143">__gthrw(sched_get_priority_max)</a>
<a name="ln144">__gthrw(sched_get_priority_min)</a>
<a name="ln145">#endif /* _POSIX_THREAD_PRIORITY_SCHEDULING */</a>
<a name="ln146">#endif /* _POSIX_PRIORITY_SCHEDULING */</a>
<a name="ln147">__gthrw(pthread_attr_destroy)</a>
<a name="ln148">__gthrw(pthread_attr_init)</a>
<a name="ln149">__gthrw(pthread_attr_setdetachstate)</a>
<a name="ln150">#ifdef _POSIX_THREAD_PRIORITY_SCHEDULING</a>
<a name="ln151">__gthrw(pthread_getschedparam)</a>
<a name="ln152">__gthrw(pthread_setschedparam)</a>
<a name="ln153">#endif /* _POSIX_THREAD_PRIORITY_SCHEDULING */</a>
<a name="ln154">#endif /* _LIBOBJC || _LIBOBJC_WEAK */</a>
<a name="ln155"> </a>
<a name="ln156">#if __GXX_WEAK__ &amp;&amp; _GLIBCXX_GTHREAD_USE_WEAK</a>
<a name="ln157"> </a>
<a name="ln158">/* On Solaris 2.6 up to 9, the libc exposes a POSIX threads interface even if</a>
<a name="ln159">   -pthreads is not specified.  The functions are dummies and most return an</a>
<a name="ln160">   error value.  However pthread_once returns 0 without invoking the routine</a>
<a name="ln161">   it is passed so we cannot pretend that the interface is active if -pthreads</a>
<a name="ln162">   is not specified.  On Solaris 2.5.1, the interface is not exposed at all so</a>
<a name="ln163">   we need to play the usual game with weak symbols.  On Solaris 10 and up, a</a>
<a name="ln164">   working interface is always exposed.  On FreeBSD 6 and later, libc also</a>
<a name="ln165">   exposes a dummy POSIX threads interface, similar to what Solaris 2.6 up</a>
<a name="ln166">   to 9 does.  FreeBSD &gt;= 700014 even provides a pthread_cancel stub in libc,</a>
<a name="ln167">   which means the alternate __gthread_active_p below cannot be used there.  */</a>
<a name="ln168"> </a>
<a name="ln169">#if defined(__FreeBSD__) || (defined(__sun) &amp;&amp; defined(__svr4__))</a>
<a name="ln170"> </a>
<a name="ln171">static volatile int __gthread_active = -1;</a>
<a name="ln172"> </a>
<a name="ln173">static void</a>
<a name="ln174">__gthread_trigger (void)</a>
<a name="ln175">{</a>
<a name="ln176">  __gthread_active = 1;</a>
<a name="ln177">}</a>
<a name="ln178"> </a>
<a name="ln179">static inline int</a>
<a name="ln180">__gthread_active_p (void)</a>
<a name="ln181">{</a>
<a name="ln182">  static pthread_mutex_t __gthread_active_mutex = PTHREAD_MUTEX_INITIALIZER;</a>
<a name="ln183">  static pthread_once_t __gthread_active_once = PTHREAD_ONCE_INIT;</a>
<a name="ln184"> </a>
<a name="ln185">  /* Avoid reading __gthread_active twice on the main code path.  */</a>
<a name="ln186">  int __gthread_active_latest_value = __gthread_active;</a>
<a name="ln187"> </a>
<a name="ln188">  /* This test is not protected to avoid taking a lock on the main code</a>
<a name="ln189">     path so every update of __gthread_active in a threaded program must</a>
<a name="ln190">     be atomic with regard to the result of the test.  */</a>
<a name="ln191">  if (__builtin_expect (__gthread_active_latest_value &lt; 0, 0))</a>
<a name="ln192">    {</a>
<a name="ln193">      if (__gthrw_(pthread_once))</a>
<a name="ln194">	{</a>
<a name="ln195">	  /* If this really is a threaded program, then we must ensure that</a>
<a name="ln196">	     __gthread_active has been set to 1 before exiting this block.  */</a>
<a name="ln197">	  __gthrw_(pthread_mutex_lock) (&amp;__gthread_active_mutex);</a>
<a name="ln198">	  __gthrw_(pthread_once) (&amp;__gthread_active_once, __gthread_trigger);</a>
<a name="ln199">	  __gthrw_(pthread_mutex_unlock) (&amp;__gthread_active_mutex);</a>
<a name="ln200">	}</a>
<a name="ln201"> </a>
<a name="ln202">      /* Make sure we'll never enter this block again.  */</a>
<a name="ln203">      if (__gthread_active &lt; 0)</a>
<a name="ln204">	__gthread_active = 0;</a>
<a name="ln205"> </a>
<a name="ln206">      __gthread_active_latest_value = __gthread_active;</a>
<a name="ln207">    }</a>
<a name="ln208"> </a>
<a name="ln209">  return __gthread_active_latest_value != 0;</a>
<a name="ln210">}</a>
<a name="ln211"> </a>
<a name="ln212">#else /* neither FreeBSD nor Solaris */</a>
<a name="ln213"> </a>
<a name="ln214">/* For a program to be multi-threaded the only thing that it certainly must</a>
<a name="ln215">   be using is pthread_create.  However, there may be other libraries that</a>
<a name="ln216">   intercept pthread_create with their own definitions to wrap pthreads</a>
<a name="ln217">   functionality for some purpose.  In those cases, pthread_create being</a>
<a name="ln218">   defined might not necessarily mean that libpthread is actually linked</a>
<a name="ln219">   in.</a>
<a name="ln220"> </a>
<a name="ln221">   For the GNU C library, we can use a known internal name.  This is always</a>
<a name="ln222">   available in the ABI, but no other library would define it.  That is</a>
<a name="ln223">   ideal, since any public pthread function might be intercepted just as</a>
<a name="ln224">   pthread_create might be.  __pthread_key_create is an &quot;internal&quot;</a>
<a name="ln225">   implementation symbol, but it is part of the public exported ABI.  Also,</a>
<a name="ln226">   it's among the symbols that the static libpthread.a always links in</a>
<a name="ln227">   whenever pthread_create is used, so there is no danger of a false</a>
<a name="ln228">   negative result in any statically-linked, multi-threaded program.</a>
<a name="ln229"> </a>
<a name="ln230">   For others, we choose pthread_cancel as a function that seems unlikely</a>
<a name="ln231">   to be redefined by an interceptor library.  The bionic (Android) C</a>
<a name="ln232">   library does not provide pthread_cancel, so we do use pthread_create</a>
<a name="ln233">   there (and interceptor libraries lose).  */</a>
<a name="ln234"> </a>
<a name="ln235">#ifdef __GLIBC__</a>
<a name="ln236">__gthrw2(__gthrw_(__pthread_key_create),</a>
<a name="ln237">	 __pthread_key_create,</a>
<a name="ln238">	 pthread_key_create)</a>
<a name="ln239"># define GTHR_ACTIVE_PROXY	__gthrw_(__pthread_key_create)</a>
<a name="ln240">#elif defined (__BIONIC__)</a>
<a name="ln241"># define GTHR_ACTIVE_PROXY	__gthrw_(pthread_create)</a>
<a name="ln242">#else</a>
<a name="ln243"># define GTHR_ACTIVE_PROXY	__gthrw_(pthread_cancel)</a>
<a name="ln244">#endif</a>
<a name="ln245"> </a>
<a name="ln246">static inline int</a>
<a name="ln247">__gthread_active_p (void)</a>
<a name="ln248">{</a>
<a name="ln249">  static void *const __gthread_active_ptr</a>
<a name="ln250">    = __extension__ (void *) &amp;GTHR_ACTIVE_PROXY;</a>
<a name="ln251">  return __gthread_active_ptr != 0;</a>
<a name="ln252">}</a>
<a name="ln253"> </a>
<a name="ln254">#endif /* FreeBSD or Solaris */</a>
<a name="ln255"> </a>
<a name="ln256">#else /* not __GXX_WEAK__ */</a>
<a name="ln257"> </a>
<a name="ln258">/* Similar to Solaris, HP-UX 11 for PA-RISC provides stubs for pthread</a>
<a name="ln259">   calls in shared flavors of the HP-UX C library.  Most of the stubs</a>
<a name="ln260">   have no functionality.  The details are described in the &quot;libc cumulative</a>
<a name="ln261">   patch&quot; for each subversion of HP-UX 11.  There are two special interfaces</a>
<a name="ln262">   provided for checking whether an application is linked to a shared pthread</a>
<a name="ln263">   library or not.  However, these interfaces aren't available in early</a>
<a name="ln264">   libpthread libraries.  We also need a test that works for archive</a>
<a name="ln265">   libraries.  We can't use pthread_once as some libc versions call the</a>
<a name="ln266">   init function.  We also can't use pthread_create or pthread_attr_init</a>
<a name="ln267">   as these create a thread and thereby prevent changing the default stack</a>
<a name="ln268">   size.  The function pthread_default_stacksize_np is available in both</a>
<a name="ln269">   the archive and shared versions of libpthread.   It can be used to</a>
<a name="ln270">   determine the default pthread stack size.  There is a stub in some</a>
<a name="ln271">   shared libc versions which returns a zero size if pthreads are not</a>
<a name="ln272">   active.  We provide an equivalent stub to handle cases where libc</a>
<a name="ln273">   doesn't provide one.  */</a>
<a name="ln274"> </a>
<a name="ln275">#if defined(__hppa__) &amp;&amp; defined(__hpux__)</a>
<a name="ln276"> </a>
<a name="ln277">static volatile int __gthread_active = -1;</a>
<a name="ln278"> </a>
<a name="ln279">static inline int</a>
<a name="ln280">__gthread_active_p (void)</a>
<a name="ln281">{</a>
<a name="ln282">  /* Avoid reading __gthread_active twice on the main code path.  */</a>
<a name="ln283">  int __gthread_active_latest_value = __gthread_active;</a>
<a name="ln284">  size_t __s;</a>
<a name="ln285"> </a>
<a name="ln286">  if (__builtin_expect (__gthread_active_latest_value &lt; 0, 0))</a>
<a name="ln287">    {</a>
<a name="ln288">      pthread_default_stacksize_np (0, &amp;__s);</a>
<a name="ln289">      __gthread_active = __s ? 1 : 0;</a>
<a name="ln290">      __gthread_active_latest_value = __gthread_active;</a>
<a name="ln291">    }</a>
<a name="ln292"> </a>
<a name="ln293">  return __gthread_active_latest_value != 0;</a>
<a name="ln294">}</a>
<a name="ln295"> </a>
<a name="ln296">#else /* not hppa-hpux */</a>
<a name="ln297"> </a>
<a name="ln298">static inline int</a>
<a name="ln299">__gthread_active_p (void)</a>
<a name="ln300">{</a>
<a name="ln301">  return 1;</a>
<a name="ln302">}</a>
<a name="ln303"> </a>
<a name="ln304">#endif /* hppa-hpux */</a>
<a name="ln305"> </a>
<a name="ln306">#endif /* __GXX_WEAK__ */</a>
<a name="ln307"> </a>
<a name="ln308">#ifdef _LIBOBJC</a>
<a name="ln309"> </a>
<a name="ln310">/* This is the config.h file in libobjc/ */</a>
<a name="ln311">#include &lt;config.h&gt;</a>
<a name="ln312"> </a>
<a name="ln313">#ifdef HAVE_SCHED_H</a>
<a name="ln314"># include &lt;sched.h&gt;</a>
<a name="ln315">#endif</a>
<a name="ln316"> </a>
<a name="ln317">/* Key structure for maintaining thread specific storage */</a>
<a name="ln318">static pthread_key_t _objc_thread_storage;</a>
<a name="ln319">static pthread_attr_t _objc_thread_attribs;</a>
<a name="ln320"> </a>
<a name="ln321">/* Thread local storage for a single thread */</a>
<a name="ln322">static void *thread_local_storage = NULL;</a>
<a name="ln323"> </a>
<a name="ln324">/* Backend initialization functions */</a>
<a name="ln325"> </a>
<a name="ln326">/* Initialize the threads subsystem.  */</a>
<a name="ln327">static inline int</a>
<a name="ln328">__gthread_objc_init_thread_system (void)</a>
<a name="ln329">{</a>
<a name="ln330">  if (__gthread_active_p ())</a>
<a name="ln331">    {</a>
<a name="ln332">      /* Initialize the thread storage key.  */</a>
<a name="ln333">      if (__gthrw_(pthread_key_create) (&amp;_objc_thread_storage, NULL) == 0)</a>
<a name="ln334">	{</a>
<a name="ln335">	  /* The normal default detach state for threads is</a>
<a name="ln336">	   * PTHREAD_CREATE_JOINABLE which causes threads to not die</a>
<a name="ln337">	   * when you think they should.  */</a>
<a name="ln338">	  if (__gthrw_(pthread_attr_init) (&amp;_objc_thread_attribs) == 0</a>
<a name="ln339">	      &amp;&amp; __gthrw_(pthread_attr_setdetachstate) (&amp;_objc_thread_attribs,</a>
<a name="ln340">					      PTHREAD_CREATE_DETACHED) == 0)</a>
<a name="ln341">	    return 0;</a>
<a name="ln342">	}</a>
<a name="ln343">    }</a>
<a name="ln344"> </a>
<a name="ln345">  return -1;</a>
<a name="ln346">}</a>
<a name="ln347"> </a>
<a name="ln348">/* Close the threads subsystem.  */</a>
<a name="ln349">static inline int</a>
<a name="ln350">__gthread_objc_close_thread_system (void)</a>
<a name="ln351">{</a>
<a name="ln352">  if (__gthread_active_p ()</a>
<a name="ln353">      &amp;&amp; __gthrw_(pthread_key_delete) (_objc_thread_storage) == 0</a>
<a name="ln354">      &amp;&amp; __gthrw_(pthread_attr_destroy) (&amp;_objc_thread_attribs) == 0)</a>
<a name="ln355">    return 0;</a>
<a name="ln356"> </a>
<a name="ln357">  return -1;</a>
<a name="ln358">}</a>
<a name="ln359"> </a>
<a name="ln360">/* Backend thread functions */</a>
<a name="ln361"> </a>
<a name="ln362">/* Create a new thread of execution.  */</a>
<a name="ln363">static inline objc_thread_t</a>
<a name="ln364">__gthread_objc_thread_detach (void (*func)(void *), void *arg)</a>
<a name="ln365">{</a>
<a name="ln366">  objc_thread_t thread_id;</a>
<a name="ln367">  pthread_t new_thread_handle;</a>
<a name="ln368"> </a>
<a name="ln369">  if (!__gthread_active_p ())</a>
<a name="ln370">    return NULL;</a>
<a name="ln371"> </a>
<a name="ln372">  if (!(__gthrw_(pthread_create) (&amp;new_thread_handle, &amp;_objc_thread_attribs,</a>
<a name="ln373">				  (void *) func, arg)))</a>
<a name="ln374">    thread_id = (objc_thread_t) new_thread_handle;</a>
<a name="ln375">  else</a>
<a name="ln376">    thread_id = NULL;</a>
<a name="ln377"> </a>
<a name="ln378">  return thread_id;</a>
<a name="ln379">}</a>
<a name="ln380"> </a>
<a name="ln381">/* Set the current thread's priority.  */</a>
<a name="ln382">static inline int</a>
<a name="ln383">__gthread_objc_thread_set_priority (int priority)</a>
<a name="ln384">{</a>
<a name="ln385">  if (!__gthread_active_p ())</a>
<a name="ln386">    return -1;</a>
<a name="ln387">  else</a>
<a name="ln388">    {</a>
<a name="ln389">#ifdef _POSIX_PRIORITY_SCHEDULING</a>
<a name="ln390">#ifdef _POSIX_THREAD_PRIORITY_SCHEDULING</a>
<a name="ln391">      pthread_t thread_id = __gthrw_(pthread_self) ();</a>
<a name="ln392">      int policy;</a>
<a name="ln393">      struct sched_param params;</a>
<a name="ln394">      int priority_min, priority_max;</a>
<a name="ln395"> </a>
<a name="ln396">      if (__gthrw_(pthread_getschedparam) (thread_id, &amp;policy, &amp;params) == 0)</a>
<a name="ln397">	{</a>
<a name="ln398">	  if ((priority_max = __gthrw_(sched_get_priority_max) (policy)) == -1)</a>
<a name="ln399">	    return -1;</a>
<a name="ln400"> </a>
<a name="ln401">	  if ((priority_min = __gthrw_(sched_get_priority_min) (policy)) == -1)</a>
<a name="ln402">	    return -1;</a>
<a name="ln403"> </a>
<a name="ln404">	  if (priority &gt; priority_max)</a>
<a name="ln405">	    priority = priority_max;</a>
<a name="ln406">	  else if (priority &lt; priority_min)</a>
<a name="ln407">	    priority = priority_min;</a>
<a name="ln408">	  params.sched_priority = priority;</a>
<a name="ln409"> </a>
<a name="ln410">	  /*</a>
<a name="ln411">	   * The solaris 7 and several other man pages incorrectly state that</a>
<a name="ln412">	   * this should be a pointer to policy but pthread.h is universally</a>
<a name="ln413">	   * at odds with this.</a>
<a name="ln414">	   */</a>
<a name="ln415">	  if (__gthrw_(pthread_setschedparam) (thread_id, policy, &amp;params) == 0)</a>
<a name="ln416">	    return 0;</a>
<a name="ln417">	}</a>
<a name="ln418">#endif /* _POSIX_THREAD_PRIORITY_SCHEDULING */</a>
<a name="ln419">#endif /* _POSIX_PRIORITY_SCHEDULING */</a>
<a name="ln420">      return -1;</a>
<a name="ln421">    }</a>
<a name="ln422">}</a>
<a name="ln423"> </a>
<a name="ln424">/* Return the current thread's priority.  */</a>
<a name="ln425">static inline int</a>
<a name="ln426">__gthread_objc_thread_get_priority (void)</a>
<a name="ln427">{</a>
<a name="ln428">#ifdef _POSIX_PRIORITY_SCHEDULING</a>
<a name="ln429">#ifdef _POSIX_THREAD_PRIORITY_SCHEDULING</a>
<a name="ln430">  if (__gthread_active_p ())</a>
<a name="ln431">    {</a>
<a name="ln432">      int policy;</a>
<a name="ln433">      struct sched_param params;</a>
<a name="ln434"> </a>
<a name="ln435">      if (__gthrw_(pthread_getschedparam) (__gthrw_(pthread_self) (), &amp;policy, &amp;params) == 0)</a>
<a name="ln436">	return params.sched_priority;</a>
<a name="ln437">      else</a>
<a name="ln438">	return -1;</a>
<a name="ln439">    }</a>
<a name="ln440">  else</a>
<a name="ln441">#endif /* _POSIX_THREAD_PRIORITY_SCHEDULING */</a>
<a name="ln442">#endif /* _POSIX_PRIORITY_SCHEDULING */</a>
<a name="ln443">    return OBJC_THREAD_INTERACTIVE_PRIORITY;</a>
<a name="ln444">}</a>
<a name="ln445"> </a>
<a name="ln446">/* Yield our process time to another thread.  */</a>
<a name="ln447">static inline void</a>
<a name="ln448">__gthread_objc_thread_yield (void)</a>
<a name="ln449">{</a>
<a name="ln450">  if (__gthread_active_p ())</a>
<a name="ln451">    __gthrw_(sched_yield) ();</a>
<a name="ln452">}</a>
<a name="ln453"> </a>
<a name="ln454">/* Terminate the current thread.  */</a>
<a name="ln455">static inline int</a>
<a name="ln456">__gthread_objc_thread_exit (void)</a>
<a name="ln457">{</a>
<a name="ln458">  if (__gthread_active_p ())</a>
<a name="ln459">    /* exit the thread */</a>
<a name="ln460">    __gthrw_(pthread_exit) (&amp;__objc_thread_exit_status);</a>
<a name="ln461"> </a>
<a name="ln462">  /* Failed if we reached here */</a>
<a name="ln463">  return -1;</a>
<a name="ln464">}</a>
<a name="ln465"> </a>
<a name="ln466">/* Returns an integer value which uniquely describes a thread.  */</a>
<a name="ln467">static inline objc_thread_t</a>
<a name="ln468">__gthread_objc_thread_id (void)</a>
<a name="ln469">{</a>
<a name="ln470">  if (__gthread_active_p ())</a>
<a name="ln471">    return (objc_thread_t) __gthrw_(pthread_self) ();</a>
<a name="ln472">  else</a>
<a name="ln473">    return (objc_thread_t) 1;</a>
<a name="ln474">}</a>
<a name="ln475"> </a>
<a name="ln476">/* Sets the thread's local storage pointer.  */</a>
<a name="ln477">static inline int</a>
<a name="ln478">__gthread_objc_thread_set_data (void *value)</a>
<a name="ln479">{</a>
<a name="ln480">  if (__gthread_active_p ())</a>
<a name="ln481">    return __gthrw_(pthread_setspecific) (_objc_thread_storage, value);</a>
<a name="ln482">  else</a>
<a name="ln483">    {</a>
<a name="ln484">      thread_local_storage = value;</a>
<a name="ln485">      return 0;</a>
<a name="ln486">    }</a>
<a name="ln487">}</a>
<a name="ln488"> </a>
<a name="ln489">/* Returns the thread's local storage pointer.  */</a>
<a name="ln490">static inline void *</a>
<a name="ln491">__gthread_objc_thread_get_data (void)</a>
<a name="ln492">{</a>
<a name="ln493">  if (__gthread_active_p ())</a>
<a name="ln494">    return __gthrw_(pthread_getspecific) (_objc_thread_storage);</a>
<a name="ln495">  else</a>
<a name="ln496">    return thread_local_storage;</a>
<a name="ln497">}</a>
<a name="ln498"> </a>
<a name="ln499">/* Backend mutex functions */</a>
<a name="ln500"> </a>
<a name="ln501">/* Allocate a mutex.  */</a>
<a name="ln502">static inline int</a>
<a name="ln503">__gthread_objc_mutex_allocate (objc_mutex_t mutex)</a>
<a name="ln504">{</a>
<a name="ln505">  if (__gthread_active_p ())</a>
<a name="ln506">    {</a>
<a name="ln507">      mutex-&gt;backend = objc_malloc (sizeof (pthread_mutex_t));</a>
<a name="ln508"> </a>
<a name="ln509">      if (__gthrw_(pthread_mutex_init) ((pthread_mutex_t *) mutex-&gt;backend, NULL))</a>
<a name="ln510">	{</a>
<a name="ln511">	  objc_free (mutex-&gt;backend);</a>
<a name="ln512">	  mutex-&gt;backend = NULL;</a>
<a name="ln513">	  return -1;</a>
<a name="ln514">	}</a>
<a name="ln515">    }</a>
<a name="ln516"> </a>
<a name="ln517">  return 0;</a>
<a name="ln518">}</a>
<a name="ln519"> </a>
<a name="ln520">/* Deallocate a mutex.  */</a>
<a name="ln521">static inline int</a>
<a name="ln522">__gthread_objc_mutex_deallocate (objc_mutex_t mutex)</a>
<a name="ln523">{</a>
<a name="ln524">  if (__gthread_active_p ())</a>
<a name="ln525">    {</a>
<a name="ln526">      int count;</a>
<a name="ln527"> </a>
<a name="ln528">      /*</a>
<a name="ln529">       * Posix Threads specifically require that the thread be unlocked</a>
<a name="ln530">       * for __gthrw_(pthread_mutex_destroy) to work.</a>
<a name="ln531">       */</a>
<a name="ln532"> </a>
<a name="ln533">      do</a>
<a name="ln534">	{</a>
<a name="ln535">	  count = __gthrw_(pthread_mutex_unlock) ((pthread_mutex_t *) mutex-&gt;backend);</a>
<a name="ln536">	  if (count &lt; 0)</a>
<a name="ln537">	    return -1;</a>
<a name="ln538">	}</a>
<a name="ln539">      while (count);</a>
<a name="ln540"> </a>
<a name="ln541">      if (__gthrw_(pthread_mutex_destroy) ((pthread_mutex_t *) mutex-&gt;backend))</a>
<a name="ln542">	return -1;</a>
<a name="ln543"> </a>
<a name="ln544">      objc_free (mutex-&gt;backend);</a>
<a name="ln545">      mutex-&gt;backend = NULL;</a>
<a name="ln546">    }</a>
<a name="ln547">  return 0;</a>
<a name="ln548">}</a>
<a name="ln549"> </a>
<a name="ln550">/* Grab a lock on a mutex.  */</a>
<a name="ln551">static inline int</a>
<a name="ln552">__gthread_objc_mutex_lock (objc_mutex_t mutex)</a>
<a name="ln553">{</a>
<a name="ln554">  if (__gthread_active_p ()</a>
<a name="ln555">      &amp;&amp; __gthrw_(pthread_mutex_lock) ((pthread_mutex_t *) mutex-&gt;backend) != 0)</a>
<a name="ln556">    {</a>
<a name="ln557">      return -1;</a>
<a name="ln558">    }</a>
<a name="ln559"> </a>
<a name="ln560">  return 0;</a>
<a name="ln561">}</a>
<a name="ln562"> </a>
<a name="ln563">/* Try to grab a lock on a mutex.  */</a>
<a name="ln564">static inline int</a>
<a name="ln565">__gthread_objc_mutex_trylock (objc_mutex_t mutex)</a>
<a name="ln566">{</a>
<a name="ln567">  if (__gthread_active_p ()</a>
<a name="ln568">      &amp;&amp; __gthrw_(pthread_mutex_trylock) ((pthread_mutex_t *) mutex-&gt;backend) != 0)</a>
<a name="ln569">    {</a>
<a name="ln570">      return -1;</a>
<a name="ln571">    }</a>
<a name="ln572"> </a>
<a name="ln573">  return 0;</a>
<a name="ln574">}</a>
<a name="ln575"> </a>
<a name="ln576">/* Unlock the mutex */</a>
<a name="ln577">static inline int</a>
<a name="ln578">__gthread_objc_mutex_unlock (objc_mutex_t mutex)</a>
<a name="ln579">{</a>
<a name="ln580">  if (__gthread_active_p ()</a>
<a name="ln581">      &amp;&amp; __gthrw_(pthread_mutex_unlock) ((pthread_mutex_t *) mutex-&gt;backend) != 0)</a>
<a name="ln582">    {</a>
<a name="ln583">      return -1;</a>
<a name="ln584">    }</a>
<a name="ln585"> </a>
<a name="ln586">  return 0;</a>
<a name="ln587">}</a>
<a name="ln588"> </a>
<a name="ln589">/* Backend condition mutex functions */</a>
<a name="ln590"> </a>
<a name="ln591">/* Allocate a condition.  */</a>
<a name="ln592">static inline int</a>
<a name="ln593">__gthread_objc_condition_allocate (objc_condition_t condition)</a>
<a name="ln594">{</a>
<a name="ln595">  if (__gthread_active_p ())</a>
<a name="ln596">    {</a>
<a name="ln597">      condition-&gt;backend = objc_malloc (sizeof (pthread_cond_t));</a>
<a name="ln598"> </a>
<a name="ln599">      if (__gthrw_(pthread_cond_init) ((pthread_cond_t *) condition-&gt;backend, NULL))</a>
<a name="ln600">	{</a>
<a name="ln601">	  objc_free (condition-&gt;backend);</a>
<a name="ln602">	  condition-&gt;backend = NULL;</a>
<a name="ln603">	  return -1;</a>
<a name="ln604">	}</a>
<a name="ln605">    }</a>
<a name="ln606"> </a>
<a name="ln607">  return 0;</a>
<a name="ln608">}</a>
<a name="ln609"> </a>
<a name="ln610">/* Deallocate a condition.  */</a>
<a name="ln611">static inline int</a>
<a name="ln612">__gthread_objc_condition_deallocate (objc_condition_t condition)</a>
<a name="ln613">{</a>
<a name="ln614">  if (__gthread_active_p ())</a>
<a name="ln615">    {</a>
<a name="ln616">      if (__gthrw_(pthread_cond_destroy) ((pthread_cond_t *) condition-&gt;backend))</a>
<a name="ln617">	return -1;</a>
<a name="ln618"> </a>
<a name="ln619">      objc_free (condition-&gt;backend);</a>
<a name="ln620">      condition-&gt;backend = NULL;</a>
<a name="ln621">    }</a>
<a name="ln622">  return 0;</a>
<a name="ln623">}</a>
<a name="ln624"> </a>
<a name="ln625">/* Wait on the condition */</a>
<a name="ln626">static inline int</a>
<a name="ln627">__gthread_objc_condition_wait (objc_condition_t condition, objc_mutex_t mutex)</a>
<a name="ln628">{</a>
<a name="ln629">  if (__gthread_active_p ())</a>
<a name="ln630">    return __gthrw_(pthread_cond_wait) ((pthread_cond_t *) condition-&gt;backend,</a>
<a name="ln631">			      (pthread_mutex_t *) mutex-&gt;backend);</a>
<a name="ln632">  else</a>
<a name="ln633">    return 0;</a>
<a name="ln634">}</a>
<a name="ln635"> </a>
<a name="ln636">/* Wake up all threads waiting on this condition.  */</a>
<a name="ln637">static inline int</a>
<a name="ln638">__gthread_objc_condition_broadcast (objc_condition_t condition)</a>
<a name="ln639">{</a>
<a name="ln640">  if (__gthread_active_p ())</a>
<a name="ln641">    return __gthrw_(pthread_cond_broadcast) ((pthread_cond_t *) condition-&gt;backend);</a>
<a name="ln642">  else</a>
<a name="ln643">    return 0;</a>
<a name="ln644">}</a>
<a name="ln645"> </a>
<a name="ln646">/* Wake up one thread waiting on this condition.  */</a>
<a name="ln647">static inline int</a>
<a name="ln648">__gthread_objc_condition_signal (objc_condition_t condition)</a>
<a name="ln649">{</a>
<a name="ln650">  if (__gthread_active_p ())</a>
<a name="ln651">    return __gthrw_(pthread_cond_signal) ((pthread_cond_t *) condition-&gt;backend);</a>
<a name="ln652">  else</a>
<a name="ln653">    return 0;</a>
<a name="ln654">}</a>
<a name="ln655"> </a>
<a name="ln656">#else /* _LIBOBJC */</a>
<a name="ln657"> </a>
<a name="ln658">static inline int</a>
<a name="ln659">__gthread_create (__gthread_t *__threadid, void *(*__func) (void*),</a>
<a name="ln660">		  void *__args)</a>
<a name="ln661">{</a>
<a name="ln662">  return __gthrw_(pthread_create) (__threadid, NULL, __func, __args);</a>
<a name="ln663">}</a>
<a name="ln664"> </a>
<a name="ln665">static inline int</a>
<a name="ln666">__gthread_join (__gthread_t __threadid, void **__value_ptr)</a>
<a name="ln667">{</a>
<a name="ln668">  return __gthrw_(pthread_join) (__threadid, __value_ptr);</a>
<a name="ln669">}</a>
<a name="ln670"> </a>
<a name="ln671">static inline int</a>
<a name="ln672">__gthread_detach (__gthread_t __threadid)</a>
<a name="ln673">{</a>
<a name="ln674">  return __gthrw_(pthread_detach) (__threadid);</a>
<a name="ln675">}</a>
<a name="ln676"> </a>
<a name="ln677">static inline int</a>
<a name="ln678">__gthread_equal (__gthread_t __t1, __gthread_t __t2)</a>
<a name="ln679">{</a>
<a name="ln680">  return __gthrw_(pthread_equal) (__t1, __t2);</a>
<a name="ln681">}</a>
<a name="ln682"> </a>
<a name="ln683">static inline __gthread_t</a>
<a name="ln684">__gthread_self (void)</a>
<a name="ln685">{</a>
<a name="ln686">  return __gthrw_(pthread_self) ();</a>
<a name="ln687">}</a>
<a name="ln688"> </a>
<a name="ln689">static inline int</a>
<a name="ln690">__gthread_yield (void)</a>
<a name="ln691">{</a>
<a name="ln692">  return __gthrw_(sched_yield) ();</a>
<a name="ln693">}</a>
<a name="ln694"> </a>
<a name="ln695">static inline int</a>
<a name="ln696">__gthread_once (__gthread_once_t *__once, void (*__func) (void))</a>
<a name="ln697">{</a>
<a name="ln698">  if (__gthread_active_p ())</a>
<a name="ln699">    return __gthrw_(pthread_once) (__once, __func);</a>
<a name="ln700">  else</a>
<a name="ln701">    return -1;</a>
<a name="ln702">}</a>
<a name="ln703"> </a>
<a name="ln704">static inline int</a>
<a name="ln705">__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))</a>
<a name="ln706">{</a>
<a name="ln707">  return __gthrw_(pthread_key_create) (__key, __dtor);</a>
<a name="ln708">}</a>
<a name="ln709"> </a>
<a name="ln710">static inline int</a>
<a name="ln711">__gthread_key_delete (__gthread_key_t __key)</a>
<a name="ln712">{</a>
<a name="ln713">  return __gthrw_(pthread_key_delete) (__key);</a>
<a name="ln714">}</a>
<a name="ln715"> </a>
<a name="ln716">static inline void *</a>
<a name="ln717">__gthread_getspecific (__gthread_key_t __key)</a>
<a name="ln718">{</a>
<a name="ln719">  return __gthrw_(pthread_getspecific) (__key);</a>
<a name="ln720">}</a>
<a name="ln721"> </a>
<a name="ln722">static inline int</a>
<a name="ln723">__gthread_setspecific (__gthread_key_t __key, const void *__ptr)</a>
<a name="ln724">{</a>
<a name="ln725">  return __gthrw_(pthread_setspecific) (__key, __ptr);</a>
<a name="ln726">}</a>
<a name="ln727"> </a>
<a name="ln728">static inline void</a>
<a name="ln729">__gthread_mutex_init_function (__gthread_mutex_t *__mutex)</a>
<a name="ln730">{</a>
<a name="ln731">  if (__gthread_active_p ())</a>
<a name="ln732">    __gthrw_(pthread_mutex_init) (__mutex, NULL);</a>
<a name="ln733">}</a>
<a name="ln734"> </a>
<a name="ln735">static inline int</a>
<a name="ln736">__gthread_mutex_destroy (__gthread_mutex_t *__mutex)</a>
<a name="ln737">{</a>
<a name="ln738">  if (__gthread_active_p ())</a>
<a name="ln739">    return __gthrw_(pthread_mutex_destroy) (__mutex);</a>
<a name="ln740">  else</a>
<a name="ln741">    return 0;</a>
<a name="ln742">}</a>
<a name="ln743"> </a>
<a name="ln744">static inline int</a>
<a name="ln745">__gthread_mutex_lock (__gthread_mutex_t *__mutex)</a>
<a name="ln746">{</a>
<a name="ln747">  if (__gthread_active_p ())</a>
<a name="ln748">    return __gthrw_(pthread_mutex_lock) (__mutex);</a>
<a name="ln749">  else</a>
<a name="ln750">    return 0;</a>
<a name="ln751">}</a>
<a name="ln752"> </a>
<a name="ln753">static inline int</a>
<a name="ln754">__gthread_mutex_trylock (__gthread_mutex_t *__mutex)</a>
<a name="ln755">{</a>
<a name="ln756">  if (__gthread_active_p ())</a>
<a name="ln757">    return __gthrw_(pthread_mutex_trylock) (__mutex);</a>
<a name="ln758">  else</a>
<a name="ln759">    return 0;</a>
<a name="ln760">}</a>
<a name="ln761"> </a>
<a name="ln762">#if _GTHREAD_USE_MUTEX_TIMEDLOCK</a>
<a name="ln763">static inline int</a>
<a name="ln764">__gthread_mutex_timedlock (__gthread_mutex_t *__mutex,</a>
<a name="ln765">			   const __gthread_time_t *__abs_timeout)</a>
<a name="ln766">{</a>
<a name="ln767">  if (__gthread_active_p ())</a>
<a name="ln768">    return __gthrw_(pthread_mutex_timedlock) (__mutex, __abs_timeout);</a>
<a name="ln769">  else</a>
<a name="ln770">    return 0;</a>
<a name="ln771">}</a>
<a name="ln772">#endif</a>
<a name="ln773"> </a>
<a name="ln774">static inline int</a>
<a name="ln775">__gthread_mutex_unlock (__gthread_mutex_t *__mutex)</a>
<a name="ln776">{</a>
<a name="ln777">  if (__gthread_active_p ())</a>
<a name="ln778">    return __gthrw_(pthread_mutex_unlock) (__mutex);</a>
<a name="ln779">  else</a>
<a name="ln780">    return 0;</a>
<a name="ln781">}</a>
<a name="ln782"> </a>
<a name="ln783">#if !defined( PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP) \</a>
<a name="ln784">  || defined(_GTHREAD_USE_RECURSIVE_MUTEX_INIT_FUNC)</a>
<a name="ln785">static inline int</a>
<a name="ln786">__gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *__mutex)</a>
<a name="ln787">{</a>
<a name="ln788">  if (__gthread_active_p ())</a>
<a name="ln789">    {</a>
<a name="ln790">      pthread_mutexattr_t __attr;</a>
<a name="ln791">      int __r;</a>
<a name="ln792"> </a>
<a name="ln793">      __r = __gthrw_(pthread_mutexattr_init) (&amp;__attr);</a>
<a name="ln794">      if (!__r)</a>
<a name="ln795">	__r = __gthrw_(pthread_mutexattr_settype) (&amp;__attr,</a>
<a name="ln796">						   PTHREAD_MUTEX_RECURSIVE);</a>
<a name="ln797">      if (!__r)</a>
<a name="ln798">	__r = __gthrw_(pthread_mutex_init) (__mutex, &amp;__attr);</a>
<a name="ln799">      if (!__r)</a>
<a name="ln800">	__r = __gthrw_(pthread_mutexattr_destroy) (&amp;__attr);</a>
<a name="ln801">      return __r;</a>
<a name="ln802">    }</a>
<a name="ln803">  return 0;</a>
<a name="ln804">}</a>
<a name="ln805">#endif</a>
<a name="ln806"> </a>
<a name="ln807">static inline int</a>
<a name="ln808">__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)</a>
<a name="ln809">{</a>
<a name="ln810">  return __gthread_mutex_lock (__mutex);</a>
<a name="ln811">}</a>
<a name="ln812"> </a>
<a name="ln813">static inline int</a>
<a name="ln814">__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)</a>
<a name="ln815">{</a>
<a name="ln816">  return __gthread_mutex_trylock (__mutex);</a>
<a name="ln817">}</a>
<a name="ln818"> </a>
<a name="ln819">#if _GTHREAD_USE_MUTEX_TIMEDLOCK</a>
<a name="ln820">static inline int</a>
<a name="ln821">__gthread_recursive_mutex_timedlock (__gthread_recursive_mutex_t *__mutex,</a>
<a name="ln822">				     const __gthread_time_t *__abs_timeout)</a>
<a name="ln823">{</a>
<a name="ln824">  return __gthread_mutex_timedlock (__mutex, __abs_timeout);</a>
<a name="ln825">}</a>
<a name="ln826">#endif</a>
<a name="ln827"> </a>
<a name="ln828">static inline int</a>
<a name="ln829">__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)</a>
<a name="ln830">{</a>
<a name="ln831">  return __gthread_mutex_unlock (__mutex);</a>
<a name="ln832">}</a>
<a name="ln833"> </a>
<a name="ln834">static inline int</a>
<a name="ln835">__gthread_recursive_mutex_destroy (__gthread_recursive_mutex_t *__mutex)</a>
<a name="ln836">{</a>
<a name="ln837">  return __gthread_mutex_destroy (__mutex);</a>
<a name="ln838">}</a>
<a name="ln839"> </a>
<a name="ln840">#ifdef _GTHREAD_USE_COND_INIT_FUNC</a>
<a name="ln841">static inline void</a>
<a name="ln842">__gthread_cond_init_function (__gthread_cond_t *__cond)</a>
<a name="ln843">{</a>
<a name="ln844">  if (__gthread_active_p ())</a>
<a name="ln845">    __gthrw_(pthread_cond_init) (__cond, NULL);</a>
<a name="ln846">}</a>
<a name="ln847">#endif</a>
<a name="ln848"> </a>
<a name="ln849">static inline int</a>
<a name="ln850">__gthread_cond_broadcast (__gthread_cond_t *__cond)</a>
<a name="ln851">{</a>
<a name="ln852">  return __gthrw_(pthread_cond_broadcast) (__cond);</a>
<a name="ln853">}</a>
<a name="ln854"> </a>
<a name="ln855">static inline int</a>
<a name="ln856">__gthread_cond_signal (__gthread_cond_t *__cond)</a>
<a name="ln857">{</a>
<a name="ln858">  return __gthrw_(pthread_cond_signal) (__cond);</a>
<a name="ln859">}</a>
<a name="ln860"> </a>
<a name="ln861">static inline int</a>
<a name="ln862">__gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)</a>
<a name="ln863">{</a>
<a name="ln864">  return __gthrw_(pthread_cond_wait) (__cond, __mutex);</a>
<a name="ln865">}</a>
<a name="ln866"> </a>
<a name="ln867">static inline int</a>
<a name="ln868">__gthread_cond_timedwait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,</a>
<a name="ln869">			  const __gthread_time_t *__abs_timeout)</a>
<a name="ln870">{</a>
<a name="ln871">  return __gthrw_(pthread_cond_timedwait) (__cond, __mutex, __abs_timeout);</a>
<a name="ln872">}</a>
<a name="ln873"> </a>
<a name="ln874">static inline int</a>
<a name="ln875">__gthread_cond_wait_recursive (__gthread_cond_t *__cond,</a>
<a name="ln876">			       __gthread_recursive_mutex_t *__mutex)</a>
<a name="ln877">{</a>
<a name="ln878">  return __gthread_cond_wait (__cond, __mutex);</a>
<a name="ln879">}</a>
<a name="ln880"> </a>
<a name="ln881">static inline int</a>
<a name="ln882">__gthread_cond_destroy (__gthread_cond_t* __cond)</a>
<a name="ln883">{</a>
<a name="ln884">  return __gthrw_(pthread_cond_destroy) (__cond);</a>
<a name="ln885">}</a>
<a name="ln886"> </a>
<a name="ln887">#endif /* _LIBOBJC */</a>
<a name="ln888"> </a>
<a name="ln889">#endif /* ! _GLIBCXX_GCC_GTHR_POSIX_H */</a>

</code></pre>
<div class="balloon" rel="251"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '__gthread_active_ptr != 0' is always true.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
