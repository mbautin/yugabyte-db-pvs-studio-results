
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>bitset</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// &lt;bitset&gt; -*- C++ -*-</a>
<a name="ln2"> </a>
<a name="ln3">// Copyright (C) 2001-2018 Free Software Foundation, Inc.</a>
<a name="ln4">//</a>
<a name="ln5">// This file is part of the GNU ISO C++ Library.  This library is free</a>
<a name="ln6">// software; you can redistribute it and/or modify it under the</a>
<a name="ln7">// terms of the GNU General Public License as published by the</a>
<a name="ln8">// Free Software Foundation; either version 3, or (at your option)</a>
<a name="ln9">// any later version.</a>
<a name="ln10"> </a>
<a name="ln11">// This library is distributed in the hope that it will be useful,</a>
<a name="ln12">// but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">// GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">// Under Section 7 of GPL version 3, you are granted additional</a>
<a name="ln17">// permissions described in the GCC Runtime Library Exception, version</a>
<a name="ln18">// 3.1, as published by the Free Software Foundation.</a>
<a name="ln19"> </a>
<a name="ln20">// You should have received a copy of the GNU General Public License and</a>
<a name="ln21">// a copy of the GCC Runtime Library Exception along with this program;</a>
<a name="ln22">// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see</a>
<a name="ln23">// &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln24"> </a>
<a name="ln25">/*</a>
<a name="ln26"> * Copyright (c) 1998</a>
<a name="ln27"> * Silicon Graphics Computer Systems, Inc.</a>
<a name="ln28"> *</a>
<a name="ln29"> * Permission to use, copy, modify, distribute and sell this software</a>
<a name="ln30"> * and its documentation for any purpose is hereby granted without fee,</a>
<a name="ln31"> * provided that the above copyright notice appear in all copies and</a>
<a name="ln32"> * that both that copyright notice and this permission notice appear</a>
<a name="ln33"> * in supporting documentation.  Silicon Graphics makes no</a>
<a name="ln34"> * representations about the suitability of this software for any</a>
<a name="ln35"> * purpose.  It is provided &quot;as is&quot; without express or implied warranty.</a>
<a name="ln36"> */</a>
<a name="ln37"> </a>
<a name="ln38">/** @file include/bitset</a>
<a name="ln39"> *  This is a Standard C++ Library header.</a>
<a name="ln40"> */</a>
<a name="ln41"> </a>
<a name="ln42">#ifndef _GLIBCXX_BITSET</a>
<a name="ln43">#define _GLIBCXX_BITSET 1</a>
<a name="ln44"> </a>
<a name="ln45">#pragma GCC system_header</a>
<a name="ln46"> </a>
<a name="ln47">#include &lt;string&gt;</a>
<a name="ln48">#include &lt;bits/functexcept.h&gt;   // For invalid_argument, out_of_range,</a>
<a name="ln49">                                // overflow_error</a>
<a name="ln50">#include &lt;iosfwd&gt;</a>
<a name="ln51">#include &lt;bits/cxxabi_forced.h&gt;</a>
<a name="ln52"> </a>
<a name="ln53">#if __cplusplus &gt;= 201103L</a>
<a name="ln54"># include &lt;bits/functional_hash.h&gt;</a>
<a name="ln55">#endif</a>
<a name="ln56"> </a>
<a name="ln57">#define _GLIBCXX_BITSET_BITS_PER_WORD  (__CHAR_BIT__ * __SIZEOF_LONG__)</a>
<a name="ln58">#define _GLIBCXX_BITSET_WORDS(__n) \</a>
<a name="ln59">  ((__n) / _GLIBCXX_BITSET_BITS_PER_WORD + \</a>
<a name="ln60">   ((__n) % _GLIBCXX_BITSET_BITS_PER_WORD == 0 ? 0 : 1))</a>
<a name="ln61"> </a>
<a name="ln62">#define _GLIBCXX_BITSET_BITS_PER_ULL (__CHAR_BIT__ * __SIZEOF_LONG_LONG__)</a>
<a name="ln63"> </a>
<a name="ln64">namespace std _GLIBCXX_VISIBILITY(default)</a>
<a name="ln65">{</a>
<a name="ln66">_GLIBCXX_BEGIN_NAMESPACE_CONTAINER</a>
<a name="ln67"> </a>
<a name="ln68">  /**</a>
<a name="ln69">   *  Base class, general case.  It is a class invariant that _Nw will be</a>
<a name="ln70">   *  nonnegative.</a>
<a name="ln71">   *</a>
<a name="ln72">   *  See documentation for bitset.</a>
<a name="ln73">  */</a>
<a name="ln74">  template&lt;size_t _Nw&gt;</a>
<a name="ln75">    struct _Base_bitset</a>
<a name="ln76">    {</a>
<a name="ln77">      typedef unsigned long _WordT;</a>
<a name="ln78"> </a>
<a name="ln79">      /// 0 is the least significant word.</a>
<a name="ln80">      _WordT 		_M_w[_Nw];</a>
<a name="ln81"> </a>
<a name="ln82">      _GLIBCXX_CONSTEXPR _Base_bitset() _GLIBCXX_NOEXCEPT</a>
<a name="ln83">      : _M_w() { }</a>
<a name="ln84"> </a>
<a name="ln85">#if __cplusplus &gt;= 201103L</a>
<a name="ln86">      constexpr _Base_bitset(unsigned long long __val) noexcept</a>
<a name="ln87">      : _M_w{ _WordT(__val)</a>
<a name="ln88">#if __SIZEOF_LONG_LONG__ &gt; __SIZEOF_LONG__</a>
<a name="ln89">	       , _WordT(__val &gt;&gt; _GLIBCXX_BITSET_BITS_PER_WORD)</a>
<a name="ln90">#endif</a>
<a name="ln91">       } { }</a>
<a name="ln92">#else</a>
<a name="ln93">      _Base_bitset(unsigned long __val)</a>
<a name="ln94">      : _M_w()</a>
<a name="ln95">      { _M_w[0] = __val; }</a>
<a name="ln96">#endif</a>
<a name="ln97"> </a>
<a name="ln98">      static _GLIBCXX_CONSTEXPR size_t</a>
<a name="ln99">      _S_whichword(size_t __pos) _GLIBCXX_NOEXCEPT</a>
<a name="ln100">      { return __pos / _GLIBCXX_BITSET_BITS_PER_WORD; }</a>
<a name="ln101"> </a>
<a name="ln102">      static _GLIBCXX_CONSTEXPR size_t</a>
<a name="ln103">      _S_whichbyte(size_t __pos) _GLIBCXX_NOEXCEPT</a>
<a name="ln104">      { return (__pos % _GLIBCXX_BITSET_BITS_PER_WORD) / __CHAR_BIT__; }</a>
<a name="ln105"> </a>
<a name="ln106">      static _GLIBCXX_CONSTEXPR size_t</a>
<a name="ln107">      _S_whichbit(size_t __pos) _GLIBCXX_NOEXCEPT</a>
<a name="ln108">      { return __pos % _GLIBCXX_BITSET_BITS_PER_WORD; }</a>
<a name="ln109"> </a>
<a name="ln110">      static _GLIBCXX_CONSTEXPR _WordT</a>
<a name="ln111">      _S_maskbit(size_t __pos) _GLIBCXX_NOEXCEPT</a>
<a name="ln112">      { return (static_cast&lt;_WordT&gt;(1)) &lt;&lt; _S_whichbit(__pos); }</a>
<a name="ln113"> </a>
<a name="ln114">      _WordT&amp;</a>
<a name="ln115">      _M_getword(size_t __pos) _GLIBCXX_NOEXCEPT</a>
<a name="ln116">      { return _M_w[_S_whichword(__pos)]; }</a>
<a name="ln117"> </a>
<a name="ln118">      _GLIBCXX_CONSTEXPR _WordT</a>
<a name="ln119">      _M_getword(size_t __pos) const _GLIBCXX_NOEXCEPT</a>
<a name="ln120">      { return _M_w[_S_whichword(__pos)]; }</a>
<a name="ln121"> </a>
<a name="ln122">#if __cplusplus &gt;= 201103L</a>
<a name="ln123">      const _WordT*</a>
<a name="ln124">      _M_getdata() const noexcept</a>
<a name="ln125">      { return _M_w; }</a>
<a name="ln126">#endif</a>
<a name="ln127"> </a>
<a name="ln128">      _WordT&amp;</a>
<a name="ln129">      _M_hiword() _GLIBCXX_NOEXCEPT</a>
<a name="ln130">      { return _M_w[_Nw - 1]; }</a>
<a name="ln131"> </a>
<a name="ln132">      _GLIBCXX_CONSTEXPR _WordT</a>
<a name="ln133">      _M_hiword() const _GLIBCXX_NOEXCEPT</a>
<a name="ln134">      { return _M_w[_Nw - 1]; }</a>
<a name="ln135"> </a>
<a name="ln136">      void</a>
<a name="ln137">      _M_do_and(const _Base_bitset&lt;_Nw&gt;&amp; __x) _GLIBCXX_NOEXCEPT</a>
<a name="ln138">      {</a>
<a name="ln139">	for (size_t __i = 0; __i &lt; _Nw; __i++)</a>
<a name="ln140">	  _M_w[__i] &amp;= __x._M_w[__i];</a>
<a name="ln141">      }</a>
<a name="ln142"> </a>
<a name="ln143">      void</a>
<a name="ln144">      _M_do_or(const _Base_bitset&lt;_Nw&gt;&amp; __x) _GLIBCXX_NOEXCEPT</a>
<a name="ln145">      {</a>
<a name="ln146">	for (size_t __i = 0; __i &lt; _Nw; __i++)</a>
<a name="ln147">	  _M_w[__i] |= __x._M_w[__i];</a>
<a name="ln148">      }</a>
<a name="ln149"> </a>
<a name="ln150">      void</a>
<a name="ln151">      _M_do_xor(const _Base_bitset&lt;_Nw&gt;&amp; __x) _GLIBCXX_NOEXCEPT</a>
<a name="ln152">      {</a>
<a name="ln153">	for (size_t __i = 0; __i &lt; _Nw; __i++)</a>
<a name="ln154">	  _M_w[__i] ^= __x._M_w[__i];</a>
<a name="ln155">      }</a>
<a name="ln156"> </a>
<a name="ln157">      void</a>
<a name="ln158">      _M_do_left_shift(size_t __shift) _GLIBCXX_NOEXCEPT;</a>
<a name="ln159"> </a>
<a name="ln160">      void</a>
<a name="ln161">      _M_do_right_shift(size_t __shift) _GLIBCXX_NOEXCEPT;</a>
<a name="ln162"> </a>
<a name="ln163">      void</a>
<a name="ln164">      _M_do_flip() _GLIBCXX_NOEXCEPT</a>
<a name="ln165">      {</a>
<a name="ln166">	for (size_t __i = 0; __i &lt; _Nw; __i++)</a>
<a name="ln167">	  _M_w[__i] = ~_M_w[__i];</a>
<a name="ln168">      }</a>
<a name="ln169"> </a>
<a name="ln170">      void</a>
<a name="ln171">      _M_do_set() _GLIBCXX_NOEXCEPT</a>
<a name="ln172">      {</a>
<a name="ln173">	for (size_t __i = 0; __i &lt; _Nw; __i++)</a>
<a name="ln174">	  _M_w[__i] = ~static_cast&lt;_WordT&gt;(0);</a>
<a name="ln175">      }</a>
<a name="ln176"> </a>
<a name="ln177">      void</a>
<a name="ln178">      _M_do_reset() _GLIBCXX_NOEXCEPT</a>
<a name="ln179">      { __builtin_memset(_M_w, 0, _Nw * sizeof(_WordT)); }</a>
<a name="ln180"> </a>
<a name="ln181">      bool</a>
<a name="ln182">      _M_is_equal(const _Base_bitset&lt;_Nw&gt;&amp; __x) const _GLIBCXX_NOEXCEPT</a>
<a name="ln183">      {</a>
<a name="ln184">	for (size_t __i = 0; __i &lt; _Nw; ++__i)</a>
<a name="ln185">	  if (_M_w[__i] != __x._M_w[__i])</a>
<a name="ln186">	    return false;</a>
<a name="ln187">	return true;</a>
<a name="ln188">      }</a>
<a name="ln189"> </a>
<a name="ln190">      template&lt;size_t _Nb&gt;</a>
<a name="ln191">        bool</a>
<a name="ln192">        _M_are_all() const _GLIBCXX_NOEXCEPT</a>
<a name="ln193">        {</a>
<a name="ln194">	  for (size_t __i = 0; __i &lt; _Nw - 1; __i++)</a>
<a name="ln195">	    if (_M_w[__i] != ~static_cast&lt;_WordT&gt;(0))</a>
<a name="ln196">	      return false;</a>
<a name="ln197">	  return _M_hiword() == (~static_cast&lt;_WordT&gt;(0)</a>
<a name="ln198">				 &gt;&gt; (_Nw * _GLIBCXX_BITSET_BITS_PER_WORD</a>
<a name="ln199">				     - _Nb));</a>
<a name="ln200">	}</a>
<a name="ln201"> </a>
<a name="ln202">      bool</a>
<a name="ln203">      _M_is_any() const _GLIBCXX_NOEXCEPT</a>
<a name="ln204">      {</a>
<a name="ln205">	for (size_t __i = 0; __i &lt; _Nw; __i++)</a>
<a name="ln206">	  if (_M_w[__i] != static_cast&lt;_WordT&gt;(0))</a>
<a name="ln207">	    return true;</a>
<a name="ln208">	return false;</a>
<a name="ln209">      }</a>
<a name="ln210"> </a>
<a name="ln211">      size_t</a>
<a name="ln212">      _M_do_count() const _GLIBCXX_NOEXCEPT</a>
<a name="ln213">      {</a>
<a name="ln214">	size_t __result = 0;</a>
<a name="ln215">	for (size_t __i = 0; __i &lt; _Nw; __i++)</a>
<a name="ln216">	  __result += __builtin_popcountl(_M_w[__i]);</a>
<a name="ln217">	return __result;</a>
<a name="ln218">      }</a>
<a name="ln219"> </a>
<a name="ln220">      unsigned long</a>
<a name="ln221">      _M_do_to_ulong() const;</a>
<a name="ln222"> </a>
<a name="ln223">#if __cplusplus &gt;= 201103L</a>
<a name="ln224">      unsigned long long</a>
<a name="ln225">      _M_do_to_ullong() const;</a>
<a name="ln226">#endif</a>
<a name="ln227"> </a>
<a name="ln228">      // find first &quot;on&quot; bit</a>
<a name="ln229">      size_t</a>
<a name="ln230">      _M_do_find_first(size_t) const _GLIBCXX_NOEXCEPT;</a>
<a name="ln231"> </a>
<a name="ln232">      // find the next &quot;on&quot; bit that follows &quot;prev&quot;</a>
<a name="ln233">      size_t</a>
<a name="ln234">      _M_do_find_next(size_t, size_t) const _GLIBCXX_NOEXCEPT;</a>
<a name="ln235">    };</a>
<a name="ln236"> </a>
<a name="ln237">  // Definitions of non-inline functions from _Base_bitset.</a>
<a name="ln238">  template&lt;size_t _Nw&gt;</a>
<a name="ln239">    void</a>
<a name="ln240">    _Base_bitset&lt;_Nw&gt;::_M_do_left_shift(size_t __shift) _GLIBCXX_NOEXCEPT</a>
<a name="ln241">    {</a>
<a name="ln242">      if (__builtin_expect(__shift != 0, 1))</a>
<a name="ln243">	{</a>
<a name="ln244">	  const size_t __wshift = __shift / _GLIBCXX_BITSET_BITS_PER_WORD;</a>
<a name="ln245">	  const size_t __offset = __shift % _GLIBCXX_BITSET_BITS_PER_WORD;</a>
<a name="ln246"> </a>
<a name="ln247">	  if (__offset == 0)</a>
<a name="ln248">	    for (size_t __n = _Nw - 1; __n &gt;= __wshift; --__n)</a>
<a name="ln249">	      _M_w[__n] = _M_w[__n - __wshift];</a>
<a name="ln250">	  else</a>
<a name="ln251">	    {</a>
<a name="ln252">	      const size_t __sub_offset = (_GLIBCXX_BITSET_BITS_PER_WORD</a>
<a name="ln253">					   - __offset);</a>
<a name="ln254">	      for (size_t __n = _Nw - 1; __n &gt; __wshift; --__n)</a>
<a name="ln255">		_M_w[__n] = ((_M_w[__n - __wshift] &lt;&lt; __offset)</a>
<a name="ln256">			     | (_M_w[__n - __wshift - 1] &gt;&gt; __sub_offset));</a>
<a name="ln257">	      _M_w[__wshift] = _M_w[0] &lt;&lt; __offset;</a>
<a name="ln258">	    }</a>
<a name="ln259"> </a>
<a name="ln260">	  std::fill(_M_w + 0, _M_w + __wshift, static_cast&lt;_WordT&gt;(0));</a>
<a name="ln261">	}</a>
<a name="ln262">    }</a>
<a name="ln263"> </a>
<a name="ln264">  template&lt;size_t _Nw&gt;</a>
<a name="ln265">    void</a>
<a name="ln266">    _Base_bitset&lt;_Nw&gt;::_M_do_right_shift(size_t __shift) _GLIBCXX_NOEXCEPT</a>
<a name="ln267">    {</a>
<a name="ln268">      if (__builtin_expect(__shift != 0, 1))</a>
<a name="ln269">	{</a>
<a name="ln270">	  const size_t __wshift = __shift / _GLIBCXX_BITSET_BITS_PER_WORD;</a>
<a name="ln271">	  const size_t __offset = __shift % _GLIBCXX_BITSET_BITS_PER_WORD;</a>
<a name="ln272">	  const size_t __limit = _Nw - __wshift - 1;</a>
<a name="ln273"> </a>
<a name="ln274">	  if (__offset == 0)</a>
<a name="ln275">	    for (size_t __n = 0; __n &lt;= __limit; ++__n)</a>
<a name="ln276">	      _M_w[__n] = _M_w[__n + __wshift];</a>
<a name="ln277">	  else</a>
<a name="ln278">	    {</a>
<a name="ln279">	      const size_t __sub_offset = (_GLIBCXX_BITSET_BITS_PER_WORD</a>
<a name="ln280">					   - __offset);</a>
<a name="ln281">	      for (size_t __n = 0; __n &lt; __limit; ++__n)</a>
<a name="ln282">		_M_w[__n] = ((_M_w[__n + __wshift] &gt;&gt; __offset)</a>
<a name="ln283">			     | (_M_w[__n + __wshift + 1] &lt;&lt; __sub_offset));</a>
<a name="ln284">	      _M_w[__limit] = _M_w[_Nw-1] &gt;&gt; __offset;</a>
<a name="ln285">	    }</a>
<a name="ln286"> </a>
<a name="ln287">	  std::fill(_M_w + __limit + 1, _M_w + _Nw, static_cast&lt;_WordT&gt;(0));</a>
<a name="ln288">	}</a>
<a name="ln289">    }</a>
<a name="ln290"> </a>
<a name="ln291">  template&lt;size_t _Nw&gt;</a>
<a name="ln292">    unsigned long</a>
<a name="ln293">    _Base_bitset&lt;_Nw&gt;::_M_do_to_ulong() const</a>
<a name="ln294">    {</a>
<a name="ln295">      for (size_t __i = 1; __i &lt; _Nw; ++__i)</a>
<a name="ln296">	if (_M_w[__i])</a>
<a name="ln297">	  __throw_overflow_error(__N(&quot;_Base_bitset::_M_do_to_ulong&quot;));</a>
<a name="ln298">      return _M_w[0];</a>
<a name="ln299">    }</a>
<a name="ln300"> </a>
<a name="ln301">#if __cplusplus &gt;= 201103L</a>
<a name="ln302">  template&lt;size_t _Nw&gt;</a>
<a name="ln303">    unsigned long long</a>
<a name="ln304">    _Base_bitset&lt;_Nw&gt;::_M_do_to_ullong() const</a>
<a name="ln305">    {</a>
<a name="ln306">      const bool __dw = sizeof(unsigned long long) &gt; sizeof(unsigned long);</a>
<a name="ln307">      for (size_t __i = 1 + __dw; __i &lt; _Nw; ++__i)</a>
<a name="ln308">	if (_M_w[__i])</a>
<a name="ln309">	  __throw_overflow_error(__N(&quot;_Base_bitset::_M_do_to_ullong&quot;));</a>
<a name="ln310"> </a>
<a name="ln311">      if (__dw)</a>
<a name="ln312">	return _M_w[0] + (static_cast&lt;unsigned long long&gt;(_M_w[1])</a>
<a name="ln313">			  &lt;&lt; _GLIBCXX_BITSET_BITS_PER_WORD);</a>
<a name="ln314">      return _M_w[0];</a>
<a name="ln315">    }</a>
<a name="ln316">#endif</a>
<a name="ln317"> </a>
<a name="ln318">  template&lt;size_t _Nw&gt;</a>
<a name="ln319">    size_t</a>
<a name="ln320">    _Base_bitset&lt;_Nw&gt;::</a>
<a name="ln321">    _M_do_find_first(size_t __not_found) const _GLIBCXX_NOEXCEPT</a>
<a name="ln322">    {</a>
<a name="ln323">      for (size_t __i = 0; __i &lt; _Nw; __i++)</a>
<a name="ln324">	{</a>
<a name="ln325">	  _WordT __thisword = _M_w[__i];</a>
<a name="ln326">	  if (__thisword != static_cast&lt;_WordT&gt;(0))</a>
<a name="ln327">	    return (__i * _GLIBCXX_BITSET_BITS_PER_WORD</a>
<a name="ln328">		    + __builtin_ctzl(__thisword));</a>
<a name="ln329">	}</a>
<a name="ln330">      // not found, so return an indication of failure.</a>
<a name="ln331">      return __not_found;</a>
<a name="ln332">    }</a>
<a name="ln333"> </a>
<a name="ln334">  template&lt;size_t _Nw&gt;</a>
<a name="ln335">    size_t</a>
<a name="ln336">    _Base_bitset&lt;_Nw&gt;::</a>
<a name="ln337">    _M_do_find_next(size_t __prev, size_t __not_found) const _GLIBCXX_NOEXCEPT</a>
<a name="ln338">    {</a>
<a name="ln339">      // make bound inclusive</a>
<a name="ln340">      ++__prev;</a>
<a name="ln341"> </a>
<a name="ln342">      // check out of bounds</a>
<a name="ln343">      if (__prev &gt;= _Nw * _GLIBCXX_BITSET_BITS_PER_WORD)</a>
<a name="ln344">	return __not_found;</a>
<a name="ln345"> </a>
<a name="ln346">      // search first word</a>
<a name="ln347">      size_t __i = _S_whichword(__prev);</a>
<a name="ln348">      _WordT __thisword = _M_w[__i];</a>
<a name="ln349"> </a>
<a name="ln350">      // mask off bits below bound</a>
<a name="ln351">      __thisword &amp;= (~static_cast&lt;_WordT&gt;(0)) &lt;&lt; _S_whichbit(__prev);</a>
<a name="ln352"> </a>
<a name="ln353">      if (__thisword != static_cast&lt;_WordT&gt;(0))</a>
<a name="ln354">	return (__i * _GLIBCXX_BITSET_BITS_PER_WORD</a>
<a name="ln355">		+ __builtin_ctzl(__thisword));</a>
<a name="ln356"> </a>
<a name="ln357">      // check subsequent words</a>
<a name="ln358">      __i++;</a>
<a name="ln359">      for (; __i &lt; _Nw; __i++)</a>
<a name="ln360">	{</a>
<a name="ln361">	  __thisword = _M_w[__i];</a>
<a name="ln362">	  if (__thisword != static_cast&lt;_WordT&gt;(0))</a>
<a name="ln363">	    return (__i * _GLIBCXX_BITSET_BITS_PER_WORD</a>
<a name="ln364">		    + __builtin_ctzl(__thisword));</a>
<a name="ln365">	}</a>
<a name="ln366">      // not found, so return an indication of failure.</a>
<a name="ln367">      return __not_found;</a>
<a name="ln368">    } // end _M_do_find_next</a>
<a name="ln369"> </a>
<a name="ln370">  /**</a>
<a name="ln371">   *  Base class, specialization for a single word.</a>
<a name="ln372">   *</a>
<a name="ln373">   *  See documentation for bitset.</a>
<a name="ln374">  */</a>
<a name="ln375">  template&lt;&gt;</a>
<a name="ln376">    struct _Base_bitset&lt;1&gt;</a>
<a name="ln377">    {</a>
<a name="ln378">      typedef unsigned long _WordT;</a>
<a name="ln379">      _WordT _M_w;</a>
<a name="ln380"> </a>
<a name="ln381">      _GLIBCXX_CONSTEXPR _Base_bitset() _GLIBCXX_NOEXCEPT</a>
<a name="ln382">      : _M_w(0)</a>
<a name="ln383">      { }</a>
<a name="ln384"> </a>
<a name="ln385">#if __cplusplus &gt;= 201103L</a>
<a name="ln386">      constexpr _Base_bitset(unsigned long long __val) noexcept</a>
<a name="ln387">#else</a>
<a name="ln388">      _Base_bitset(unsigned long __val)</a>
<a name="ln389">#endif</a>
<a name="ln390">      : _M_w(__val)</a>
<a name="ln391">      { }</a>
<a name="ln392"> </a>
<a name="ln393">      static _GLIBCXX_CONSTEXPR size_t</a>
<a name="ln394">      _S_whichword(size_t __pos) _GLIBCXX_NOEXCEPT</a>
<a name="ln395">      { return __pos / _GLIBCXX_BITSET_BITS_PER_WORD; }</a>
<a name="ln396"> </a>
<a name="ln397">      static _GLIBCXX_CONSTEXPR size_t</a>
<a name="ln398">      _S_whichbyte(size_t __pos) _GLIBCXX_NOEXCEPT</a>
<a name="ln399">      { return (__pos % _GLIBCXX_BITSET_BITS_PER_WORD) / __CHAR_BIT__; }</a>
<a name="ln400"> </a>
<a name="ln401">      static _GLIBCXX_CONSTEXPR size_t</a>
<a name="ln402">      _S_whichbit(size_t __pos) _GLIBCXX_NOEXCEPT</a>
<a name="ln403">      {  return __pos % _GLIBCXX_BITSET_BITS_PER_WORD; }</a>
<a name="ln404"> </a>
<a name="ln405">      static _GLIBCXX_CONSTEXPR _WordT</a>
<a name="ln406">      _S_maskbit(size_t __pos) _GLIBCXX_NOEXCEPT</a>
<a name="ln407">      { return (static_cast&lt;_WordT&gt;(1)) &lt;&lt; _S_whichbit(__pos); }</a>
<a name="ln408"> </a>
<a name="ln409">      _WordT&amp;</a>
<a name="ln410">      _M_getword(size_t) _GLIBCXX_NOEXCEPT</a>
<a name="ln411">      { return _M_w; }</a>
<a name="ln412"> </a>
<a name="ln413">      _GLIBCXX_CONSTEXPR _WordT</a>
<a name="ln414">      _M_getword(size_t) const _GLIBCXX_NOEXCEPT</a>
<a name="ln415">      { return _M_w; }</a>
<a name="ln416"> </a>
<a name="ln417">#if __cplusplus &gt;= 201103L</a>
<a name="ln418">      const _WordT*</a>
<a name="ln419">      _M_getdata() const noexcept</a>
<a name="ln420">      { return &amp;_M_w; }</a>
<a name="ln421">#endif</a>
<a name="ln422"> </a>
<a name="ln423">      _WordT&amp;</a>
<a name="ln424">      _M_hiword() _GLIBCXX_NOEXCEPT</a>
<a name="ln425">      { return _M_w; }</a>
<a name="ln426"> </a>
<a name="ln427">      _GLIBCXX_CONSTEXPR _WordT</a>
<a name="ln428">      _M_hiword() const _GLIBCXX_NOEXCEPT</a>
<a name="ln429">      { return _M_w; }</a>
<a name="ln430"> </a>
<a name="ln431">      void</a>
<a name="ln432">      _M_do_and(const _Base_bitset&lt;1&gt;&amp; __x) _GLIBCXX_NOEXCEPT</a>
<a name="ln433">      { _M_w &amp;= __x._M_w; }</a>
<a name="ln434"> </a>
<a name="ln435">      void</a>
<a name="ln436">      _M_do_or(const _Base_bitset&lt;1&gt;&amp; __x) _GLIBCXX_NOEXCEPT</a>
<a name="ln437">      { _M_w |= __x._M_w; }</a>
<a name="ln438"> </a>
<a name="ln439">      void</a>
<a name="ln440">      _M_do_xor(const _Base_bitset&lt;1&gt;&amp; __x) _GLIBCXX_NOEXCEPT</a>
<a name="ln441">      { _M_w ^= __x._M_w; }</a>
<a name="ln442"> </a>
<a name="ln443">      void</a>
<a name="ln444">      _M_do_left_shift(size_t __shift) _GLIBCXX_NOEXCEPT</a>
<a name="ln445">      { _M_w &lt;&lt;= __shift; }</a>
<a name="ln446"> </a>
<a name="ln447">      void</a>
<a name="ln448">      _M_do_right_shift(size_t __shift) _GLIBCXX_NOEXCEPT</a>
<a name="ln449">      { _M_w &gt;&gt;= __shift; }</a>
<a name="ln450"> </a>
<a name="ln451">      void</a>
<a name="ln452">      _M_do_flip() _GLIBCXX_NOEXCEPT</a>
<a name="ln453">      { _M_w = ~_M_w; }</a>
<a name="ln454"> </a>
<a name="ln455">      void</a>
<a name="ln456">      _M_do_set() _GLIBCXX_NOEXCEPT</a>
<a name="ln457">      { _M_w = ~static_cast&lt;_WordT&gt;(0); }</a>
<a name="ln458"> </a>
<a name="ln459">      void</a>
<a name="ln460">      _M_do_reset() _GLIBCXX_NOEXCEPT</a>
<a name="ln461">      { _M_w = 0; }</a>
<a name="ln462"> </a>
<a name="ln463">      bool</a>
<a name="ln464">      _M_is_equal(const _Base_bitset&lt;1&gt;&amp; __x) const _GLIBCXX_NOEXCEPT</a>
<a name="ln465">      { return _M_w == __x._M_w; }</a>
<a name="ln466"> </a>
<a name="ln467">      template&lt;size_t _Nb&gt;</a>
<a name="ln468">        bool</a>
<a name="ln469">        _M_are_all() const _GLIBCXX_NOEXCEPT</a>
<a name="ln470">        { return _M_w == (~static_cast&lt;_WordT&gt;(0)</a>
<a name="ln471">			  &gt;&gt; (_GLIBCXX_BITSET_BITS_PER_WORD - _Nb)); }</a>
<a name="ln472"> </a>
<a name="ln473">      bool</a>
<a name="ln474">      _M_is_any() const _GLIBCXX_NOEXCEPT</a>
<a name="ln475">      { return _M_w != 0; }</a>
<a name="ln476"> </a>
<a name="ln477">      size_t</a>
<a name="ln478">      _M_do_count() const _GLIBCXX_NOEXCEPT</a>
<a name="ln479">      { return __builtin_popcountl(_M_w); }</a>
<a name="ln480"> </a>
<a name="ln481">      unsigned long</a>
<a name="ln482">      _M_do_to_ulong() const _GLIBCXX_NOEXCEPT</a>
<a name="ln483">      { return _M_w; }</a>
<a name="ln484"> </a>
<a name="ln485">#if __cplusplus &gt;= 201103L</a>
<a name="ln486">      unsigned long long</a>
<a name="ln487">      _M_do_to_ullong() const noexcept</a>
<a name="ln488">      { return _M_w; }</a>
<a name="ln489">#endif</a>
<a name="ln490"> </a>
<a name="ln491">      size_t</a>
<a name="ln492">      _M_do_find_first(size_t __not_found) const _GLIBCXX_NOEXCEPT</a>
<a name="ln493">      {</a>
<a name="ln494">        if (_M_w != 0)</a>
<a name="ln495">          return __builtin_ctzl(_M_w);</a>
<a name="ln496">        else</a>
<a name="ln497">          return __not_found;</a>
<a name="ln498">      }</a>
<a name="ln499"> </a>
<a name="ln500">      // find the next &quot;on&quot; bit that follows &quot;prev&quot;</a>
<a name="ln501">      size_t</a>
<a name="ln502">      _M_do_find_next(size_t __prev, size_t __not_found) const</a>
<a name="ln503">	_GLIBCXX_NOEXCEPT</a>
<a name="ln504">      {</a>
<a name="ln505">	++__prev;</a>
<a name="ln506">	if (__prev &gt;= ((size_t) _GLIBCXX_BITSET_BITS_PER_WORD))</a>
<a name="ln507">	  return __not_found;</a>
<a name="ln508"> </a>
<a name="ln509">	_WordT __x = _M_w &gt;&gt; __prev;</a>
<a name="ln510">	if (__x != 0)</a>
<a name="ln511">	  return __builtin_ctzl(__x) + __prev;</a>
<a name="ln512">	else</a>
<a name="ln513">	  return __not_found;</a>
<a name="ln514">      }</a>
<a name="ln515">    };</a>
<a name="ln516"> </a>
<a name="ln517">  /**</a>
<a name="ln518">   *  Base class, specialization for no storage (zero-length %bitset).</a>
<a name="ln519">   *</a>
<a name="ln520">   *  See documentation for bitset.</a>
<a name="ln521">  */</a>
<a name="ln522">  template&lt;&gt;</a>
<a name="ln523">    struct _Base_bitset&lt;0&gt;</a>
<a name="ln524">    {</a>
<a name="ln525">      typedef unsigned long _WordT;</a>
<a name="ln526"> </a>
<a name="ln527">      _GLIBCXX_CONSTEXPR _Base_bitset() _GLIBCXX_NOEXCEPT</a>
<a name="ln528">      { }</a>
<a name="ln529"> </a>
<a name="ln530">#if __cplusplus &gt;= 201103L</a>
<a name="ln531">      constexpr _Base_bitset(unsigned long long) noexcept</a>
<a name="ln532">#else</a>
<a name="ln533">      _Base_bitset(unsigned long)</a>
<a name="ln534">#endif</a>
<a name="ln535">      { }</a>
<a name="ln536"> </a>
<a name="ln537">      static _GLIBCXX_CONSTEXPR size_t</a>
<a name="ln538">      _S_whichword(size_t __pos) _GLIBCXX_NOEXCEPT</a>
<a name="ln539">      { return __pos / _GLIBCXX_BITSET_BITS_PER_WORD; }</a>
<a name="ln540"> </a>
<a name="ln541">      static _GLIBCXX_CONSTEXPR size_t</a>
<a name="ln542">      _S_whichbyte(size_t __pos) _GLIBCXX_NOEXCEPT</a>
<a name="ln543">      { return (__pos % _GLIBCXX_BITSET_BITS_PER_WORD) / __CHAR_BIT__; }</a>
<a name="ln544"> </a>
<a name="ln545">      static _GLIBCXX_CONSTEXPR size_t</a>
<a name="ln546">      _S_whichbit(size_t __pos) _GLIBCXX_NOEXCEPT</a>
<a name="ln547">      {  return __pos % _GLIBCXX_BITSET_BITS_PER_WORD; }</a>
<a name="ln548"> </a>
<a name="ln549">      static _GLIBCXX_CONSTEXPR _WordT</a>
<a name="ln550">      _S_maskbit(size_t __pos) _GLIBCXX_NOEXCEPT</a>
<a name="ln551">      { return (static_cast&lt;_WordT&gt;(1)) &lt;&lt; _S_whichbit(__pos); }</a>
<a name="ln552"> </a>
<a name="ln553">      // This would normally give access to the data.  The bounds-checking</a>
<a name="ln554">      // in the bitset class will prevent the user from getting this far,</a>
<a name="ln555">      // but (1) it must still return an lvalue to compile, and (2) the</a>
<a name="ln556">      // user might call _Unchecked_set directly, in which case this /needs/</a>
<a name="ln557">      // to fail.  Let's not penalize zero-length users unless they actually</a>
<a name="ln558">      // make an unchecked call; all the memory ugliness is therefore</a>
<a name="ln559">      // localized to this single should-never-get-this-far function.</a>
<a name="ln560">      _WordT&amp;</a>
<a name="ln561">      _M_getword(size_t) _GLIBCXX_NOEXCEPT</a>
<a name="ln562">      {</a>
<a name="ln563">	__throw_out_of_range(__N(&quot;_Base_bitset::_M_getword&quot;));</a>
<a name="ln564">	return *new _WordT;</a>
<a name="ln565">      }</a>
<a name="ln566"> </a>
<a name="ln567">      _GLIBCXX_CONSTEXPR _WordT</a>
<a name="ln568">      _M_getword(size_t) const _GLIBCXX_NOEXCEPT</a>
<a name="ln569">      { return 0; }</a>
<a name="ln570"> </a>
<a name="ln571">      _GLIBCXX_CONSTEXPR _WordT</a>
<a name="ln572">      _M_hiword() const _GLIBCXX_NOEXCEPT</a>
<a name="ln573">      { return 0; }</a>
<a name="ln574"> </a>
<a name="ln575">      void</a>
<a name="ln576">      _M_do_and(const _Base_bitset&lt;0&gt;&amp;) _GLIBCXX_NOEXCEPT</a>
<a name="ln577">      { }</a>
<a name="ln578"> </a>
<a name="ln579">      void</a>
<a name="ln580">      _M_do_or(const _Base_bitset&lt;0&gt;&amp;) _GLIBCXX_NOEXCEPT</a>
<a name="ln581">      { }</a>
<a name="ln582"> </a>
<a name="ln583">      void</a>
<a name="ln584">      _M_do_xor(const _Base_bitset&lt;0&gt;&amp;) _GLIBCXX_NOEXCEPT</a>
<a name="ln585">      { }</a>
<a name="ln586"> </a>
<a name="ln587">      void</a>
<a name="ln588">      _M_do_left_shift(size_t) _GLIBCXX_NOEXCEPT</a>
<a name="ln589">      { }</a>
<a name="ln590"> </a>
<a name="ln591">      void</a>
<a name="ln592">      _M_do_right_shift(size_t) _GLIBCXX_NOEXCEPT</a>
<a name="ln593">      { }</a>
<a name="ln594"> </a>
<a name="ln595">      void</a>
<a name="ln596">      _M_do_flip() _GLIBCXX_NOEXCEPT</a>
<a name="ln597">      { }</a>
<a name="ln598"> </a>
<a name="ln599">      void</a>
<a name="ln600">      _M_do_set() _GLIBCXX_NOEXCEPT</a>
<a name="ln601">      { }</a>
<a name="ln602"> </a>
<a name="ln603">      void</a>
<a name="ln604">      _M_do_reset() _GLIBCXX_NOEXCEPT</a>
<a name="ln605">      { }</a>
<a name="ln606"> </a>
<a name="ln607">      // Are all empty bitsets equal to each other?  Are they equal to</a>
<a name="ln608">      // themselves?  How to compare a thing which has no state?  What is</a>
<a name="ln609">      // the sound of one zero-length bitset clapping?</a>
<a name="ln610">      bool</a>
<a name="ln611">      _M_is_equal(const _Base_bitset&lt;0&gt;&amp;) const _GLIBCXX_NOEXCEPT</a>
<a name="ln612">      { return true; }</a>
<a name="ln613"> </a>
<a name="ln614">      template&lt;size_t _Nb&gt;</a>
<a name="ln615">        bool</a>
<a name="ln616">        _M_are_all() const _GLIBCXX_NOEXCEPT</a>
<a name="ln617">        { return true; }</a>
<a name="ln618"> </a>
<a name="ln619">      bool</a>
<a name="ln620">      _M_is_any() const _GLIBCXX_NOEXCEPT</a>
<a name="ln621">      { return false; }</a>
<a name="ln622"> </a>
<a name="ln623">      size_t</a>
<a name="ln624">      _M_do_count() const _GLIBCXX_NOEXCEPT</a>
<a name="ln625">      { return 0; }</a>
<a name="ln626"> </a>
<a name="ln627">      unsigned long</a>
<a name="ln628">      _M_do_to_ulong() const _GLIBCXX_NOEXCEPT</a>
<a name="ln629">      { return 0; }</a>
<a name="ln630"> </a>
<a name="ln631">#if __cplusplus &gt;= 201103L</a>
<a name="ln632">      unsigned long long</a>
<a name="ln633">      _M_do_to_ullong() const noexcept</a>
<a name="ln634">      { return 0; }</a>
<a name="ln635">#endif</a>
<a name="ln636"> </a>
<a name="ln637">      // Normally &quot;not found&quot; is the size, but that could also be</a>
<a name="ln638">      // misinterpreted as an index in this corner case.  Oh well.</a>
<a name="ln639">      size_t</a>
<a name="ln640">      _M_do_find_first(size_t) const _GLIBCXX_NOEXCEPT</a>
<a name="ln641">      { return 0; }</a>
<a name="ln642"> </a>
<a name="ln643">      size_t</a>
<a name="ln644">      _M_do_find_next(size_t, size_t) const _GLIBCXX_NOEXCEPT</a>
<a name="ln645">      { return 0; }</a>
<a name="ln646">    };</a>
<a name="ln647"> </a>
<a name="ln648"> </a>
<a name="ln649">  // Helper class to zero out the unused high-order bits in the highest word.</a>
<a name="ln650">  template&lt;size_t _Extrabits&gt;</a>
<a name="ln651">    struct _Sanitize</a>
<a name="ln652">    {</a>
<a name="ln653">      typedef unsigned long _WordT;</a>
<a name="ln654"> </a>
<a name="ln655">      static void</a>
<a name="ln656">      _S_do_sanitize(_WordT&amp; __val) _GLIBCXX_NOEXCEPT</a>
<a name="ln657">      { __val &amp;= ~((~static_cast&lt;_WordT&gt;(0)) &lt;&lt; _Extrabits); }</a>
<a name="ln658">    };</a>
<a name="ln659"> </a>
<a name="ln660">  template&lt;&gt;</a>
<a name="ln661">    struct _Sanitize&lt;0&gt;</a>
<a name="ln662">    {</a>
<a name="ln663">      typedef unsigned long _WordT;</a>
<a name="ln664"> </a>
<a name="ln665">      static void</a>
<a name="ln666">      _S_do_sanitize(_WordT) _GLIBCXX_NOEXCEPT { }</a>
<a name="ln667">    };</a>
<a name="ln668"> </a>
<a name="ln669">#if __cplusplus &gt;= 201103L</a>
<a name="ln670">  template&lt;size_t _Nb, bool = (_Nb &lt; _GLIBCXX_BITSET_BITS_PER_ULL)&gt;</a>
<a name="ln671">    struct _Sanitize_val</a>
<a name="ln672">    {</a>
<a name="ln673">      static constexpr unsigned long long</a>
<a name="ln674">      _S_do_sanitize_val(unsigned long long __val)</a>
<a name="ln675">      { return __val; }</a>
<a name="ln676">    };</a>
<a name="ln677"> </a>
<a name="ln678">  template&lt;size_t _Nb&gt;</a>
<a name="ln679">    struct _Sanitize_val&lt;_Nb, true&gt;</a>
<a name="ln680">    {</a>
<a name="ln681">      static constexpr unsigned long long</a>
<a name="ln682">      _S_do_sanitize_val(unsigned long long __val)</a>
<a name="ln683">      { return __val &amp; ~((~static_cast&lt;unsigned long long&gt;(0)) &lt;&lt; _Nb); }</a>
<a name="ln684">    };</a>
<a name="ln685">#endif</a>
<a name="ln686"> </a>
<a name="ln687">  /**</a>
<a name="ln688">   *  @brief The %bitset class represents a @e fixed-size sequence of bits.</a>
<a name="ln689">   *  @ingroup utilities</a>
<a name="ln690">   *</a>
<a name="ln691">   *  (Note that %bitset does @e not meet the formal requirements of a</a>
<a name="ln692">   *  &lt;a href=&quot;tables.html#65&quot;&gt;container&lt;/a&gt;.  Mainly, it lacks iterators.)</a>
<a name="ln693">   *</a>
<a name="ln694">   *  The template argument, @a Nb, may be any non-negative number,</a>
<a name="ln695">   *  specifying the number of bits (e.g., &quot;0&quot;, &quot;12&quot;, &quot;1024*1024&quot;).</a>
<a name="ln696">   *</a>
<a name="ln697">   *  In the general unoptimized case, storage is allocated in word-sized</a>
<a name="ln698">   *  blocks.  Let B be the number of bits in a word, then (Nb+(B-1))/B</a>
<a name="ln699">   *  words will be used for storage.  B - Nb%B bits are unused.  (They are</a>
<a name="ln700">   *  the high-order bits in the highest word.)  It is a class invariant</a>
<a name="ln701">   *  that those unused bits are always zero.</a>
<a name="ln702">   *</a>
<a name="ln703">   *  If you think of %bitset as &lt;em&gt;a simple array of bits&lt;/em&gt;, be</a>
<a name="ln704">   *  aware that your mental picture is reversed: a %bitset behaves</a>
<a name="ln705">   *  the same way as bits in integers do, with the bit at index 0 in</a>
<a name="ln706">   *  the &lt;em&gt;least significant / right-hand&lt;/em&gt; position, and the bit at</a>
<a name="ln707">   *  index Nb-1 in the &lt;em&gt;most significant / left-hand&lt;/em&gt; position.</a>
<a name="ln708">   *  Thus, unlike other containers, a %bitset's index &lt;em&gt;counts from</a>
<a name="ln709">   *  right to left&lt;/em&gt;, to put it very loosely.</a>
<a name="ln710">   *</a>
<a name="ln711">   *  This behavior is preserved when translating to and from strings.  For</a>
<a name="ln712">   *  example, the first line of the following program probably prints</a>
<a name="ln713">   *  &lt;em&gt;b(&amp;apos;a&amp;apos;) is 0001100001&lt;/em&gt; on a modern ASCII system.</a>
<a name="ln714">   *</a>
<a name="ln715">   *  @code</a>
<a name="ln716">   *     #include &lt;bitset&gt;</a>
<a name="ln717">   *     #include &lt;iostream&gt;</a>
<a name="ln718">   *     #include &lt;sstream&gt;</a>
<a name="ln719">   *</a>
<a name="ln720">   *     using namespace std;</a>
<a name="ln721">   *</a>
<a name="ln722">   *     int main()</a>
<a name="ln723">   *     {</a>
<a name="ln724">   *         long         a = 'a';</a>
<a name="ln725">   *         bitset&lt;10&gt;   b(a);</a>
<a name="ln726">   *</a>
<a name="ln727">   *         cout &lt;&lt; &quot;b('a') is &quot; &lt;&lt; b &lt;&lt; endl;</a>
<a name="ln728">   *</a>
<a name="ln729">   *         ostringstream s;</a>
<a name="ln730">   *         s &lt;&lt; b;</a>
<a name="ln731">   *         string  str = s.str();</a>
<a name="ln732">   *         cout &lt;&lt; &quot;index 3 in the string is &quot; &lt;&lt; str[3] &lt;&lt; &quot; but\n&quot;</a>
<a name="ln733">   *              &lt;&lt; &quot;index 3 in the bitset is &quot; &lt;&lt; b[3] &lt;&lt; endl;</a>
<a name="ln734">   *     }</a>
<a name="ln735">   *  @endcode</a>
<a name="ln736">   *</a>
<a name="ln737">   *  Also see:</a>
<a name="ln738">   *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/ext_containers.html</a>
<a name="ln739">   *  for a description of extensions.</a>
<a name="ln740">   *</a>
<a name="ln741">   *  Most of the actual code isn't contained in %bitset&lt;&gt; itself, but in the</a>
<a name="ln742">   *  base class _Base_bitset.  The base class works with whole words, not with</a>
<a name="ln743">   *  individual bits.  This allows us to specialize _Base_bitset for the</a>
<a name="ln744">   *  important special case where the %bitset is only a single word.</a>
<a name="ln745">   *</a>
<a name="ln746">   *  Extra confusion can result due to the fact that the storage for</a>
<a name="ln747">   *  _Base_bitset @e is a regular array, and is indexed as such.  This is</a>
<a name="ln748">   *  carefully encapsulated.</a>
<a name="ln749">  */</a>
<a name="ln750">  template&lt;size_t _Nb&gt;</a>
<a name="ln751">    class bitset</a>
<a name="ln752">    : private _Base_bitset&lt;_GLIBCXX_BITSET_WORDS(_Nb)&gt;</a>
<a name="ln753">    {</a>
<a name="ln754">    private:</a>
<a name="ln755">      typedef _Base_bitset&lt;_GLIBCXX_BITSET_WORDS(_Nb)&gt; _Base;</a>
<a name="ln756">      typedef unsigned long _WordT;</a>
<a name="ln757"> </a>
<a name="ln758">      template&lt;class _CharT, class _Traits, class _Alloc&gt;</a>
<a name="ln759">      void</a>
<a name="ln760">      _M_check_initial_position(const std::basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __s,</a>
<a name="ln761">				size_t __position) const</a>
<a name="ln762">      {</a>
<a name="ln763">	if (__position &gt; __s.size())</a>
<a name="ln764">	  __throw_out_of_range_fmt(__N(&quot;bitset::bitset: __position &quot;</a>
<a name="ln765">				       &quot;(which is %zu) &gt; __s.size() &quot;</a>
<a name="ln766">				       &quot;(which is %zu)&quot;),</a>
<a name="ln767">				   __position, __s.size());</a>
<a name="ln768">      }</a>
<a name="ln769"> </a>
<a name="ln770">      void _M_check(size_t __position, const char *__s) const</a>
<a name="ln771">      {</a>
<a name="ln772">	if (__position &gt;= _Nb)</a>
<a name="ln773">	  __throw_out_of_range_fmt(__N(&quot;%s: __position (which is %zu) &quot;</a>
<a name="ln774">				       &quot;&gt;= _Nb (which is %zu)&quot;),</a>
<a name="ln775">				   __s, __position, _Nb);</a>
<a name="ln776">      }</a>
<a name="ln777"> </a>
<a name="ln778">      void</a>
<a name="ln779">      _M_do_sanitize() _GLIBCXX_NOEXCEPT</a>
<a name="ln780">      {</a>
<a name="ln781">	typedef _Sanitize&lt;_Nb % _GLIBCXX_BITSET_BITS_PER_WORD&gt; __sanitize_type;</a>
<a name="ln782">	__sanitize_type::_S_do_sanitize(this-&gt;_M_hiword());</a>
<a name="ln783">      }</a>
<a name="ln784"> </a>
<a name="ln785">#if __cplusplus &gt;= 201103L</a>
<a name="ln786">      friend struct std::hash&lt;bitset&gt;;</a>
<a name="ln787">#endif</a>
<a name="ln788"> </a>
<a name="ln789">    public:</a>
<a name="ln790">      /**</a>
<a name="ln791">       *  This encapsulates the concept of a single bit.  An instance of this</a>
<a name="ln792">       *  class is a proxy for an actual bit; this way the individual bit</a>
<a name="ln793">       *  operations are done as faster word-size bitwise instructions.</a>
<a name="ln794">       *</a>
<a name="ln795">       *  Most users will never need to use this class directly; conversions</a>
<a name="ln796">       *  to and from bool are automatic and should be transparent.  Overloaded</a>
<a name="ln797">       *  operators help to preserve the illusion.</a>
<a name="ln798">       *</a>
<a name="ln799">       *  (On a typical system, this &lt;em&gt;bit %reference&lt;/em&gt; is 64</a>
<a name="ln800">       *  times the size of an actual bit.  Ha.)</a>
<a name="ln801">       */</a>
<a name="ln802">      class reference</a>
<a name="ln803">      {</a>
<a name="ln804">	friend class bitset;</a>
<a name="ln805"> </a>
<a name="ln806">	_WordT*	_M_wp;</a>
<a name="ln807">	size_t 	_M_bpos;</a>
<a name="ln808"> </a>
<a name="ln809">	// left undefined</a>
<a name="ln810">	reference();</a>
<a name="ln811"> </a>
<a name="ln812">      public:</a>
<a name="ln813">	reference(bitset&amp; __b, size_t __pos) _GLIBCXX_NOEXCEPT</a>
<a name="ln814">	{</a>
<a name="ln815">	  _M_wp = &amp;__b._M_getword(__pos);</a>
<a name="ln816">	  _M_bpos = _Base::_S_whichbit(__pos);</a>
<a name="ln817">	}</a>
<a name="ln818"> </a>
<a name="ln819">	~reference() _GLIBCXX_NOEXCEPT</a>
<a name="ln820">	{ }</a>
<a name="ln821"> </a>
<a name="ln822">	// For b[i] = __x;</a>
<a name="ln823">	reference&amp;</a>
<a name="ln824">	operator=(bool __x) _GLIBCXX_NOEXCEPT</a>
<a name="ln825">	{</a>
<a name="ln826">	  if (__x)</a>
<a name="ln827">	    *_M_wp |= _Base::_S_maskbit(_M_bpos);</a>
<a name="ln828">	  else</a>
<a name="ln829">	    *_M_wp &amp;= ~_Base::_S_maskbit(_M_bpos);</a>
<a name="ln830">	  return *this;</a>
<a name="ln831">	}</a>
<a name="ln832"> </a>
<a name="ln833">	// For b[i] = b[__j];</a>
<a name="ln834">	reference&amp;</a>
<a name="ln835">	operator=(const reference&amp; __j) _GLIBCXX_NOEXCEPT</a>
<a name="ln836">	{</a>
<a name="ln837">	  if ((*(__j._M_wp) &amp; _Base::_S_maskbit(__j._M_bpos)))</a>
<a name="ln838">	    *_M_wp |= _Base::_S_maskbit(_M_bpos);</a>
<a name="ln839">	  else</a>
<a name="ln840">	    *_M_wp &amp;= ~_Base::_S_maskbit(_M_bpos);</a>
<a name="ln841">	  return *this;</a>
<a name="ln842">	}</a>
<a name="ln843"> </a>
<a name="ln844">	// Flips the bit</a>
<a name="ln845">	bool</a>
<a name="ln846">	operator~() const _GLIBCXX_NOEXCEPT</a>
<a name="ln847">	{ return (*(_M_wp) &amp; _Base::_S_maskbit(_M_bpos)) == 0; }</a>
<a name="ln848"> </a>
<a name="ln849">	// For __x = b[i];</a>
<a name="ln850">	operator bool() const _GLIBCXX_NOEXCEPT</a>
<a name="ln851">	{ return (*(_M_wp) &amp; _Base::_S_maskbit(_M_bpos)) != 0; }</a>
<a name="ln852"> </a>
<a name="ln853">	// For b[i].flip();</a>
<a name="ln854">	reference&amp;</a>
<a name="ln855">	flip() _GLIBCXX_NOEXCEPT</a>
<a name="ln856">	{</a>
<a name="ln857">	  *_M_wp ^= _Base::_S_maskbit(_M_bpos);</a>
<a name="ln858">	  return *this;</a>
<a name="ln859">	}</a>
<a name="ln860">      };</a>
<a name="ln861">      friend class reference;</a>
<a name="ln862"> </a>
<a name="ln863">      // 23.3.5.1 constructors:</a>
<a name="ln864">      /// All bits set to zero.</a>
<a name="ln865">      _GLIBCXX_CONSTEXPR bitset() _GLIBCXX_NOEXCEPT</a>
<a name="ln866">      { }</a>
<a name="ln867"> </a>
<a name="ln868">      /// Initial bits bitwise-copied from a single word (others set to zero).</a>
<a name="ln869">#if __cplusplus &gt;= 201103L</a>
<a name="ln870">      constexpr bitset(unsigned long long __val) noexcept</a>
<a name="ln871">      : _Base(_Sanitize_val&lt;_Nb&gt;::_S_do_sanitize_val(__val)) { }</a>
<a name="ln872">#else</a>
<a name="ln873">      bitset(unsigned long __val)</a>
<a name="ln874">      : _Base(__val)</a>
<a name="ln875">      { _M_do_sanitize(); }</a>
<a name="ln876">#endif</a>
<a name="ln877"> </a>
<a name="ln878">      /**</a>
<a name="ln879">       *  Use a subset of a string.</a>
<a name="ln880">       *  @param  __s  A string of @a 0 and @a 1 characters.</a>
<a name="ln881">       *  @param  __position  Index of the first character in @a __s to use;</a>
<a name="ln882">       *                    defaults to zero.</a>
<a name="ln883">       *  @throw  std::out_of_range  If @a pos is bigger the size of @a __s.</a>
<a name="ln884">       *  @throw  std::invalid_argument  If a character appears in the string</a>
<a name="ln885">       *                                 which is neither @a 0 nor @a 1.</a>
<a name="ln886">       */</a>
<a name="ln887">      template&lt;class _CharT, class _Traits, class _Alloc&gt;</a>
<a name="ln888">	explicit</a>
<a name="ln889">	bitset(const std::basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __s,</a>
<a name="ln890">	       size_t __position = 0)</a>
<a name="ln891">	: _Base()</a>
<a name="ln892">	{</a>
<a name="ln893">	  _M_check_initial_position(__s, __position);</a>
<a name="ln894">	  _M_copy_from_string(__s, __position,</a>
<a name="ln895">			      std::basic_string&lt;_CharT, _Traits, _Alloc&gt;::npos,</a>
<a name="ln896">			      _CharT('0'), _CharT('1'));</a>
<a name="ln897">	}</a>
<a name="ln898"> </a>
<a name="ln899">      /**</a>
<a name="ln900">       *  Use a subset of a string.</a>
<a name="ln901">       *  @param  __s  A string of @a 0 and @a 1 characters.</a>
<a name="ln902">       *  @param  __position  Index of the first character in @a __s to use.</a>
<a name="ln903">       *  @param  __n    The number of characters to copy.</a>
<a name="ln904">       *  @throw std::out_of_range If @a __position is bigger the size</a>
<a name="ln905">       *  of @a __s.</a>
<a name="ln906">       *  @throw  std::invalid_argument  If a character appears in the string</a>
<a name="ln907">       *                                 which is neither @a 0 nor @a 1.</a>
<a name="ln908">       */</a>
<a name="ln909">      template&lt;class _CharT, class _Traits, class _Alloc&gt;</a>
<a name="ln910">	bitset(const std::basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __s,</a>
<a name="ln911">	       size_t __position, size_t __n)</a>
<a name="ln912">	: _Base()</a>
<a name="ln913">	{</a>
<a name="ln914">	  _M_check_initial_position(__s, __position);</a>
<a name="ln915">	  _M_copy_from_string(__s, __position, __n, _CharT('0'), _CharT('1'));</a>
<a name="ln916">	}</a>
<a name="ln917"> </a>
<a name="ln918">      // _GLIBCXX_RESOLVE_LIB_DEFECTS</a>
<a name="ln919">      // 396. what are characters zero and one.</a>
<a name="ln920">      template&lt;class _CharT, class _Traits, class _Alloc&gt;</a>
<a name="ln921">	bitset(const std::basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __s,</a>
<a name="ln922">	       size_t __position, size_t __n,</a>
<a name="ln923">	       _CharT __zero, _CharT __one = _CharT('1'))</a>
<a name="ln924">	: _Base()</a>
<a name="ln925">	{</a>
<a name="ln926">	  _M_check_initial_position(__s, __position);</a>
<a name="ln927">	  _M_copy_from_string(__s, __position, __n, __zero, __one);</a>
<a name="ln928">	}</a>
<a name="ln929"> </a>
<a name="ln930">#if __cplusplus &gt;= 201103L</a>
<a name="ln931">      /**</a>
<a name="ln932">       *  Construct from a character %array.</a>
<a name="ln933">       *  @param  __str  An %array of characters @a zero and @a one.</a>
<a name="ln934">       *  @param  __n    The number of characters to use.</a>
<a name="ln935">       *  @param  __zero The character corresponding to the value 0.</a>
<a name="ln936">       *  @param  __one  The character corresponding to the value 1.</a>
<a name="ln937">       *  @throw  std::invalid_argument If a character appears in the string</a>
<a name="ln938">       *                                which is neither @a __zero nor @a __one.</a>
<a name="ln939">       */</a>
<a name="ln940">      template&lt;typename _CharT&gt;</a>
<a name="ln941">        explicit</a>
<a name="ln942">        bitset(const _CharT* __str,</a>
<a name="ln943">	       typename std::basic_string&lt;_CharT&gt;::size_type __n</a>
<a name="ln944">	       = std::basic_string&lt;_CharT&gt;::npos,</a>
<a name="ln945">	       _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'))</a>
<a name="ln946">        : _Base()</a>
<a name="ln947">        {</a>
<a name="ln948">	  if (!__str)</a>
<a name="ln949">	    __throw_logic_error(__N(&quot;bitset::bitset(const _CharT*, ...)&quot;));</a>
<a name="ln950"> </a>
<a name="ln951">	  if (__n == std::basic_string&lt;_CharT&gt;::npos)</a>
<a name="ln952">	    __n = std::char_traits&lt;_CharT&gt;::length(__str);</a>
<a name="ln953">	  _M_copy_from_ptr&lt;_CharT, std::char_traits&lt;_CharT&gt;&gt;(__str, __n, 0,</a>
<a name="ln954">							     __n, __zero,</a>
<a name="ln955">							     __one);</a>
<a name="ln956">	}</a>
<a name="ln957">#endif</a>
<a name="ln958"> </a>
<a name="ln959">      // 23.3.5.2 bitset operations:</a>
<a name="ln960">      //@{</a>
<a name="ln961">      /**</a>
<a name="ln962">       *  Operations on bitsets.</a>
<a name="ln963">       *  @param  __rhs  A same-sized bitset.</a>
<a name="ln964">       *</a>
<a name="ln965">       *  These should be self-explanatory.</a>
<a name="ln966">       */</a>
<a name="ln967">      bitset&lt;_Nb&gt;&amp;</a>
<a name="ln968">      operator&amp;=(const bitset&lt;_Nb&gt;&amp; __rhs) _GLIBCXX_NOEXCEPT</a>
<a name="ln969">      {</a>
<a name="ln970">	this-&gt;_M_do_and(__rhs);</a>
<a name="ln971">	return *this;</a>
<a name="ln972">      }</a>
<a name="ln973"> </a>
<a name="ln974">      bitset&lt;_Nb&gt;&amp;</a>
<a name="ln975">      operator|=(const bitset&lt;_Nb&gt;&amp; __rhs) _GLIBCXX_NOEXCEPT</a>
<a name="ln976">      {</a>
<a name="ln977">	this-&gt;_M_do_or(__rhs);</a>
<a name="ln978">	return *this;</a>
<a name="ln979">      }</a>
<a name="ln980"> </a>
<a name="ln981">      bitset&lt;_Nb&gt;&amp;</a>
<a name="ln982">      operator^=(const bitset&lt;_Nb&gt;&amp; __rhs) _GLIBCXX_NOEXCEPT</a>
<a name="ln983">      {</a>
<a name="ln984">	this-&gt;_M_do_xor(__rhs);</a>
<a name="ln985">	return *this;</a>
<a name="ln986">      }</a>
<a name="ln987">      //@}</a>
<a name="ln988"> </a>
<a name="ln989">      //@{</a>
<a name="ln990">      /**</a>
<a name="ln991">       *  Operations on bitsets.</a>
<a name="ln992">       *  @param  __position  The number of places to shift.</a>
<a name="ln993">       *</a>
<a name="ln994">       *  These should be self-explanatory.</a>
<a name="ln995">       */</a>
<a name="ln996">      bitset&lt;_Nb&gt;&amp;</a>
<a name="ln997">      operator&lt;&lt;=(size_t __position) _GLIBCXX_NOEXCEPT</a>
<a name="ln998">      {</a>
<a name="ln999">	if (__builtin_expect(__position &lt; _Nb, 1))</a>
<a name="ln1000">	  {</a>
<a name="ln1001">	    this-&gt;_M_do_left_shift(__position);</a>
<a name="ln1002">	    this-&gt;_M_do_sanitize();</a>
<a name="ln1003">	  }</a>
<a name="ln1004">	else</a>
<a name="ln1005">	  this-&gt;_M_do_reset();</a>
<a name="ln1006">	return *this;</a>
<a name="ln1007">      }</a>
<a name="ln1008"> </a>
<a name="ln1009">      bitset&lt;_Nb&gt;&amp;</a>
<a name="ln1010">      operator&gt;&gt;=(size_t __position) _GLIBCXX_NOEXCEPT</a>
<a name="ln1011">      {</a>
<a name="ln1012">	if (__builtin_expect(__position &lt; _Nb, 1))</a>
<a name="ln1013">	  {</a>
<a name="ln1014">	    this-&gt;_M_do_right_shift(__position);</a>
<a name="ln1015">	    this-&gt;_M_do_sanitize();</a>
<a name="ln1016">	  }</a>
<a name="ln1017">	else</a>
<a name="ln1018">	  this-&gt;_M_do_reset();</a>
<a name="ln1019">	return *this;</a>
<a name="ln1020">      }</a>
<a name="ln1021">      //@}</a>
<a name="ln1022"> </a>
<a name="ln1023">      //@{</a>
<a name="ln1024">      /**</a>
<a name="ln1025">       *  These versions of single-bit set, reset, flip, and test are</a>
<a name="ln1026">       *  extensions from the SGI version.  They do no range checking.</a>
<a name="ln1027">       *  @ingroup SGIextensions</a>
<a name="ln1028">       */</a>
<a name="ln1029">      bitset&lt;_Nb&gt;&amp;</a>
<a name="ln1030">      _Unchecked_set(size_t __pos) _GLIBCXX_NOEXCEPT</a>
<a name="ln1031">      {</a>
<a name="ln1032">	this-&gt;_M_getword(__pos) |= _Base::_S_maskbit(__pos);</a>
<a name="ln1033">	return *this;</a>
<a name="ln1034">      }</a>
<a name="ln1035"> </a>
<a name="ln1036">      bitset&lt;_Nb&gt;&amp;</a>
<a name="ln1037">      _Unchecked_set(size_t __pos, int __val) _GLIBCXX_NOEXCEPT</a>
<a name="ln1038">      {</a>
<a name="ln1039">	if (__val)</a>
<a name="ln1040">	  this-&gt;_M_getword(__pos) |= _Base::_S_maskbit(__pos);</a>
<a name="ln1041">	else</a>
<a name="ln1042">	  this-&gt;_M_getword(__pos) &amp;= ~_Base::_S_maskbit(__pos);</a>
<a name="ln1043">	return *this;</a>
<a name="ln1044">      }</a>
<a name="ln1045"> </a>
<a name="ln1046">      bitset&lt;_Nb&gt;&amp;</a>
<a name="ln1047">      _Unchecked_reset(size_t __pos) _GLIBCXX_NOEXCEPT</a>
<a name="ln1048">      {</a>
<a name="ln1049">	this-&gt;_M_getword(__pos) &amp;= ~_Base::_S_maskbit(__pos);</a>
<a name="ln1050">	return *this;</a>
<a name="ln1051">      }</a>
<a name="ln1052"> </a>
<a name="ln1053">      bitset&lt;_Nb&gt;&amp;</a>
<a name="ln1054">      _Unchecked_flip(size_t __pos) _GLIBCXX_NOEXCEPT</a>
<a name="ln1055">      {</a>
<a name="ln1056">	this-&gt;_M_getword(__pos) ^= _Base::_S_maskbit(__pos);</a>
<a name="ln1057">	return *this;</a>
<a name="ln1058">      }</a>
<a name="ln1059"> </a>
<a name="ln1060">      _GLIBCXX_CONSTEXPR bool</a>
<a name="ln1061">      _Unchecked_test(size_t __pos) const _GLIBCXX_NOEXCEPT</a>
<a name="ln1062">      { return ((this-&gt;_M_getword(__pos) &amp; _Base::_S_maskbit(__pos))</a>
<a name="ln1063">		!= static_cast&lt;_WordT&gt;(0)); }</a>
<a name="ln1064">      //@}</a>
<a name="ln1065"> </a>
<a name="ln1066">      // Set, reset, and flip.</a>
<a name="ln1067">      /**</a>
<a name="ln1068">       *  @brief Sets every bit to true.</a>
<a name="ln1069">       */</a>
<a name="ln1070">      bitset&lt;_Nb&gt;&amp;</a>
<a name="ln1071">      set() _GLIBCXX_NOEXCEPT</a>
<a name="ln1072">      {</a>
<a name="ln1073">	this-&gt;_M_do_set();</a>
<a name="ln1074">	this-&gt;_M_do_sanitize();</a>
<a name="ln1075">	return *this;</a>
<a name="ln1076">      }</a>
<a name="ln1077"> </a>
<a name="ln1078">      /**</a>
<a name="ln1079">       *  @brief Sets a given bit to a particular value.</a>
<a name="ln1080">       *  @param  __position  The index of the bit.</a>
<a name="ln1081">       *  @param  __val  Either true or false, defaults to true.</a>
<a name="ln1082">       *  @throw  std::out_of_range  If @a pos is bigger the size of the %set.</a>
<a name="ln1083">       */</a>
<a name="ln1084">      bitset&lt;_Nb&gt;&amp;</a>
<a name="ln1085">      set(size_t __position, bool __val = true)</a>
<a name="ln1086">      {</a>
<a name="ln1087">	this-&gt;_M_check(__position, __N(&quot;bitset::set&quot;));</a>
<a name="ln1088">	return _Unchecked_set(__position, __val);</a>
<a name="ln1089">      }</a>
<a name="ln1090"> </a>
<a name="ln1091">      /**</a>
<a name="ln1092">       *  @brief Sets every bit to false.</a>
<a name="ln1093">       */</a>
<a name="ln1094">      bitset&lt;_Nb&gt;&amp;</a>
<a name="ln1095">      reset() _GLIBCXX_NOEXCEPT</a>
<a name="ln1096">      {</a>
<a name="ln1097">	this-&gt;_M_do_reset();</a>
<a name="ln1098">	return *this;</a>
<a name="ln1099">      }</a>
<a name="ln1100"> </a>
<a name="ln1101">      /**</a>
<a name="ln1102">       *  @brief Sets a given bit to false.</a>
<a name="ln1103">       *  @param  __position  The index of the bit.</a>
<a name="ln1104">       *  @throw  std::out_of_range  If @a pos is bigger the size of the %set.</a>
<a name="ln1105">       *</a>
<a name="ln1106">       *  Same as writing @c set(pos,false).</a>
<a name="ln1107">       */</a>
<a name="ln1108">      bitset&lt;_Nb&gt;&amp;</a>
<a name="ln1109">      reset(size_t __position)</a>
<a name="ln1110">      {</a>
<a name="ln1111">	this-&gt;_M_check(__position, __N(&quot;bitset::reset&quot;));</a>
<a name="ln1112">	return _Unchecked_reset(__position);</a>
<a name="ln1113">      }</a>
<a name="ln1114"> </a>
<a name="ln1115">      /**</a>
<a name="ln1116">       *  @brief Toggles every bit to its opposite value.</a>
<a name="ln1117">       */</a>
<a name="ln1118">      bitset&lt;_Nb&gt;&amp;</a>
<a name="ln1119">      flip() _GLIBCXX_NOEXCEPT</a>
<a name="ln1120">      {</a>
<a name="ln1121">	this-&gt;_M_do_flip();</a>
<a name="ln1122">	this-&gt;_M_do_sanitize();</a>
<a name="ln1123">	return *this;</a>
<a name="ln1124">      }</a>
<a name="ln1125"> </a>
<a name="ln1126">      /**</a>
<a name="ln1127">       *  @brief Toggles a given bit to its opposite value.</a>
<a name="ln1128">       *  @param  __position  The index of the bit.</a>
<a name="ln1129">       *  @throw  std::out_of_range  If @a pos is bigger the size of the %set.</a>
<a name="ln1130">       */</a>
<a name="ln1131">      bitset&lt;_Nb&gt;&amp;</a>
<a name="ln1132">      flip(size_t __position)</a>
<a name="ln1133">      {</a>
<a name="ln1134">	this-&gt;_M_check(__position, __N(&quot;bitset::flip&quot;));</a>
<a name="ln1135">	return _Unchecked_flip(__position);</a>
<a name="ln1136">      }</a>
<a name="ln1137"> </a>
<a name="ln1138">      /// See the no-argument flip().</a>
<a name="ln1139">      bitset&lt;_Nb&gt;</a>
<a name="ln1140">      operator~() const _GLIBCXX_NOEXCEPT</a>
<a name="ln1141">      { return bitset&lt;_Nb&gt;(*this).flip(); }</a>
<a name="ln1142"> </a>
<a name="ln1143">      //@{</a>
<a name="ln1144">      /**</a>
<a name="ln1145">       *  @brief  Array-indexing support.</a>
<a name="ln1146">       *  @param  __position  Index into the %bitset.</a>
<a name="ln1147">       *  @return A bool for a &lt;em&gt;const %bitset&lt;/em&gt;.  For non-const</a>
<a name="ln1148">       *           bitsets, an instance of the reference proxy class.</a>
<a name="ln1149">       *  @note  These operators do no range checking and throw no exceptions,</a>
<a name="ln1150">       *         as required by DR 11 to the standard.</a>
<a name="ln1151">       *</a>
<a name="ln1152">       *  _GLIBCXX_RESOLVE_LIB_DEFECTS Note that this implementation already</a>
<a name="ln1153">       *  resolves DR 11 (items 1 and 2), but does not do the range-checking</a>
<a name="ln1154">       *  required by that DR's resolution.  -pme</a>
<a name="ln1155">       *  The DR has since been changed:  range-checking is a precondition</a>
<a name="ln1156">       *  (users' responsibility), and these functions must not throw.  -pme</a>
<a name="ln1157">       */</a>
<a name="ln1158">      reference</a>
<a name="ln1159">      operator[](size_t __position)</a>
<a name="ln1160">      { return reference(*this, __position); }</a>
<a name="ln1161"> </a>
<a name="ln1162">      _GLIBCXX_CONSTEXPR bool</a>
<a name="ln1163">      operator[](size_t __position) const</a>
<a name="ln1164">      { return _Unchecked_test(__position); }</a>
<a name="ln1165">      //@}</a>
<a name="ln1166"> </a>
<a name="ln1167">      /**</a>
<a name="ln1168">       *  @brief Returns a numerical interpretation of the %bitset.</a>
<a name="ln1169">       *  @return  The integral equivalent of the bits.</a>
<a name="ln1170">       *  @throw  std::overflow_error  If there are too many bits to be</a>
<a name="ln1171">       *                               represented in an @c unsigned @c long.</a>
<a name="ln1172">       */</a>
<a name="ln1173">      unsigned long</a>
<a name="ln1174">      to_ulong() const</a>
<a name="ln1175">      { return this-&gt;_M_do_to_ulong(); }</a>
<a name="ln1176"> </a>
<a name="ln1177">#if __cplusplus &gt;= 201103L</a>
<a name="ln1178">      unsigned long long</a>
<a name="ln1179">      to_ullong() const</a>
<a name="ln1180">      { return this-&gt;_M_do_to_ullong(); }</a>
<a name="ln1181">#endif</a>
<a name="ln1182"> </a>
<a name="ln1183">      /**</a>
<a name="ln1184">       *  @brief Returns a character interpretation of the %bitset.</a>
<a name="ln1185">       *  @return  The string equivalent of the bits.</a>
<a name="ln1186">       *</a>
<a name="ln1187">       *  Note the ordering of the bits:  decreasing character positions</a>
<a name="ln1188">       *  correspond to increasing bit positions (see the main class notes for</a>
<a name="ln1189">       *  an example).</a>
<a name="ln1190">       */</a>
<a name="ln1191">      template&lt;class _CharT, class _Traits, class _Alloc&gt;</a>
<a name="ln1192">	std::basic_string&lt;_CharT, _Traits, _Alloc&gt;</a>
<a name="ln1193">	to_string() const</a>
<a name="ln1194">	{</a>
<a name="ln1195">	  std::basic_string&lt;_CharT, _Traits, _Alloc&gt; __result;</a>
<a name="ln1196">	  _M_copy_to_string(__result, _CharT('0'), _CharT('1'));</a>
<a name="ln1197">	  return __result;</a>
<a name="ln1198">	}</a>
<a name="ln1199"> </a>
<a name="ln1200">      // _GLIBCXX_RESOLVE_LIB_DEFECTS</a>
<a name="ln1201">      // 396. what are characters zero and one.</a>
<a name="ln1202">      template&lt;class _CharT, class _Traits, class _Alloc&gt;</a>
<a name="ln1203">	std::basic_string&lt;_CharT, _Traits, _Alloc&gt;</a>
<a name="ln1204">	to_string(_CharT __zero, _CharT __one = _CharT('1')) const</a>
<a name="ln1205">	{</a>
<a name="ln1206">	  std::basic_string&lt;_CharT, _Traits, _Alloc&gt; __result;</a>
<a name="ln1207">	  _M_copy_to_string(__result, __zero, __one);</a>
<a name="ln1208">	  return __result;</a>
<a name="ln1209">	}</a>
<a name="ln1210"> </a>
<a name="ln1211">      // _GLIBCXX_RESOLVE_LIB_DEFECTS</a>
<a name="ln1212">      // 434. bitset::to_string() hard to use.</a>
<a name="ln1213">      template&lt;class _CharT, class _Traits&gt;</a>
<a name="ln1214">	std::basic_string&lt;_CharT, _Traits, std::allocator&lt;_CharT&gt; &gt;</a>
<a name="ln1215">	to_string() const</a>
<a name="ln1216">	{ return to_string&lt;_CharT, _Traits, std::allocator&lt;_CharT&gt; &gt;(); }</a>
<a name="ln1217"> </a>
<a name="ln1218">      // _GLIBCXX_RESOLVE_LIB_DEFECTS</a>
<a name="ln1219">      // 853. to_string needs updating with zero and one.</a>
<a name="ln1220">      template&lt;class _CharT, class _Traits&gt;</a>
<a name="ln1221">	std::basic_string&lt;_CharT, _Traits, std::allocator&lt;_CharT&gt; &gt;</a>
<a name="ln1222">	to_string(_CharT __zero, _CharT __one = _CharT('1')) const</a>
<a name="ln1223">	{ return to_string&lt;_CharT, _Traits,</a>
<a name="ln1224">	                   std::allocator&lt;_CharT&gt; &gt;(__zero, __one); }</a>
<a name="ln1225"> </a>
<a name="ln1226">      template&lt;class _CharT&gt;</a>
<a name="ln1227">	std::basic_string&lt;_CharT, std::char_traits&lt;_CharT&gt;,</a>
<a name="ln1228">	                  std::allocator&lt;_CharT&gt; &gt;</a>
<a name="ln1229">	to_string() const</a>
<a name="ln1230">	{</a>
<a name="ln1231">	  return to_string&lt;_CharT, std::char_traits&lt;_CharT&gt;,</a>
<a name="ln1232">	                   std::allocator&lt;_CharT&gt; &gt;();</a>
<a name="ln1233">	}</a>
<a name="ln1234"> </a>
<a name="ln1235">      template&lt;class _CharT&gt;</a>
<a name="ln1236">	std::basic_string&lt;_CharT, std::char_traits&lt;_CharT&gt;,</a>
<a name="ln1237">	                  std::allocator&lt;_CharT&gt; &gt;</a>
<a name="ln1238">	to_string(_CharT __zero, _CharT __one = _CharT('1')) const</a>
<a name="ln1239">	{</a>
<a name="ln1240">	  return to_string&lt;_CharT, std::char_traits&lt;_CharT&gt;,</a>
<a name="ln1241">	                   std::allocator&lt;_CharT&gt; &gt;(__zero, __one);</a>
<a name="ln1242">	}</a>
<a name="ln1243"> </a>
<a name="ln1244">      std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;</a>
<a name="ln1245">      to_string() const</a>
<a name="ln1246">      {</a>
<a name="ln1247">	return to_string&lt;char, std::char_traits&lt;char&gt;,</a>
<a name="ln1248">	                 std::allocator&lt;char&gt; &gt;();</a>
<a name="ln1249">      }</a>
<a name="ln1250"> </a>
<a name="ln1251">      std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;</a>
<a name="ln1252">      to_string(char __zero, char __one = '1') const</a>
<a name="ln1253">      {</a>
<a name="ln1254">	return to_string&lt;char, std::char_traits&lt;char&gt;,</a>
<a name="ln1255">	                 std::allocator&lt;char&gt; &gt;(__zero, __one);</a>
<a name="ln1256">      }</a>
<a name="ln1257"> </a>
<a name="ln1258">      // Helper functions for string operations.</a>
<a name="ln1259">      template&lt;class _CharT, class _Traits&gt;</a>
<a name="ln1260">        void</a>
<a name="ln1261">        _M_copy_from_ptr(const _CharT*, size_t, size_t, size_t,</a>
<a name="ln1262">			 _CharT, _CharT);</a>
<a name="ln1263"> </a>
<a name="ln1264">      template&lt;class _CharT, class _Traits, class _Alloc&gt;</a>
<a name="ln1265">	void</a>
<a name="ln1266">	_M_copy_from_string(const std::basic_string&lt;_CharT,</a>
<a name="ln1267">			    _Traits, _Alloc&gt;&amp; __s, size_t __pos, size_t __n,</a>
<a name="ln1268">			    _CharT __zero, _CharT __one)</a>
<a name="ln1269">	{ _M_copy_from_ptr&lt;_CharT, _Traits&gt;(__s.data(), __s.size(), __pos, __n,</a>
<a name="ln1270">					    __zero, __one); }</a>
<a name="ln1271"> </a>
<a name="ln1272">      template&lt;class _CharT, class _Traits, class _Alloc&gt;</a>
<a name="ln1273">	void</a>
<a name="ln1274">        _M_copy_to_string(std::basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp;,</a>
<a name="ln1275">			  _CharT, _CharT) const;</a>
<a name="ln1276"> </a>
<a name="ln1277">      // NB: Backward compat.</a>
<a name="ln1278">      template&lt;class _CharT, class _Traits, class _Alloc&gt;</a>
<a name="ln1279">	void</a>
<a name="ln1280">	_M_copy_from_string(const std::basic_string&lt;_CharT,</a>
<a name="ln1281">			    _Traits, _Alloc&gt;&amp; __s, size_t __pos, size_t __n)</a>
<a name="ln1282">	{ _M_copy_from_string(__s, __pos, __n, _CharT('0'), _CharT('1')); }</a>
<a name="ln1283"> </a>
<a name="ln1284">      template&lt;class _CharT, class _Traits, class _Alloc&gt;</a>
<a name="ln1285">	void</a>
<a name="ln1286">        _M_copy_to_string(std::basic_string&lt;_CharT, _Traits,_Alloc&gt;&amp; __s) const</a>
<a name="ln1287">	{ _M_copy_to_string(__s, _CharT('0'), _CharT('1')); }</a>
<a name="ln1288"> </a>
<a name="ln1289">      /// Returns the number of bits which are set.</a>
<a name="ln1290">      size_t</a>
<a name="ln1291">      count() const _GLIBCXX_NOEXCEPT</a>
<a name="ln1292">      { return this-&gt;_M_do_count(); }</a>
<a name="ln1293"> </a>
<a name="ln1294">      /// Returns the total number of bits.</a>
<a name="ln1295">      _GLIBCXX_CONSTEXPR size_t</a>
<a name="ln1296">      size() const _GLIBCXX_NOEXCEPT</a>
<a name="ln1297">      { return _Nb; }</a>
<a name="ln1298"> </a>
<a name="ln1299">      //@{</a>
<a name="ln1300">      /// These comparisons for equality/inequality are, well, @e bitwise.</a>
<a name="ln1301">      bool</a>
<a name="ln1302">      operator==(const bitset&lt;_Nb&gt;&amp; __rhs) const _GLIBCXX_NOEXCEPT</a>
<a name="ln1303">      { return this-&gt;_M_is_equal(__rhs); }</a>
<a name="ln1304"> </a>
<a name="ln1305">      bool</a>
<a name="ln1306">      operator!=(const bitset&lt;_Nb&gt;&amp; __rhs) const _GLIBCXX_NOEXCEPT</a>
<a name="ln1307">      { return !this-&gt;_M_is_equal(__rhs); }</a>
<a name="ln1308">      //@}</a>
<a name="ln1309"> </a>
<a name="ln1310">      /**</a>
<a name="ln1311">       *  @brief Tests the value of a bit.</a>
<a name="ln1312">       *  @param  __position  The index of a bit.</a>
<a name="ln1313">       *  @return  The value at @a pos.</a>
<a name="ln1314">       *  @throw  std::out_of_range  If @a pos is bigger the size of the %set.</a>
<a name="ln1315">       */</a>
<a name="ln1316">      bool</a>
<a name="ln1317">      test(size_t __position) const</a>
<a name="ln1318">      {</a>
<a name="ln1319">	this-&gt;_M_check(__position, __N(&quot;bitset::test&quot;));</a>
<a name="ln1320">	return _Unchecked_test(__position);</a>
<a name="ln1321">      }</a>
<a name="ln1322"> </a>
<a name="ln1323">      // _GLIBCXX_RESOLVE_LIB_DEFECTS</a>
<a name="ln1324">      // DR 693. std::bitset::all() missing.</a>
<a name="ln1325">      /**</a>
<a name="ln1326">       *  @brief Tests whether all the bits are on.</a>
<a name="ln1327">       *  @return  True if all the bits are set.</a>
<a name="ln1328">       */</a>
<a name="ln1329">      bool</a>
<a name="ln1330">      all() const _GLIBCXX_NOEXCEPT</a>
<a name="ln1331">      { return this-&gt;template _M_are_all&lt;_Nb&gt;(); }</a>
<a name="ln1332"> </a>
<a name="ln1333">      /**</a>
<a name="ln1334">       *  @brief Tests whether any of the bits are on.</a>
<a name="ln1335">       *  @return  True if at least one bit is set.</a>
<a name="ln1336">       */</a>
<a name="ln1337">      bool</a>
<a name="ln1338">      any() const _GLIBCXX_NOEXCEPT</a>
<a name="ln1339">      { return this-&gt;_M_is_any(); }</a>
<a name="ln1340"> </a>
<a name="ln1341">      /**</a>
<a name="ln1342">       *  @brief Tests whether any of the bits are on.</a>
<a name="ln1343">       *  @return  True if none of the bits are set.</a>
<a name="ln1344">       */</a>
<a name="ln1345">      bool</a>
<a name="ln1346">      none() const _GLIBCXX_NOEXCEPT</a>
<a name="ln1347">      { return !this-&gt;_M_is_any(); }</a>
<a name="ln1348"> </a>
<a name="ln1349">      //@{</a>
<a name="ln1350">      /// Self-explanatory.</a>
<a name="ln1351">      bitset&lt;_Nb&gt;</a>
<a name="ln1352">      operator&lt;&lt;(size_t __position) const _GLIBCXX_NOEXCEPT</a>
<a name="ln1353">      { return bitset&lt;_Nb&gt;(*this) &lt;&lt;= __position; }</a>
<a name="ln1354"> </a>
<a name="ln1355">      bitset&lt;_Nb&gt;</a>
<a name="ln1356">      operator&gt;&gt;(size_t __position) const _GLIBCXX_NOEXCEPT</a>
<a name="ln1357">      { return bitset&lt;_Nb&gt;(*this) &gt;&gt;= __position; }</a>
<a name="ln1358">      //@}</a>
<a name="ln1359"> </a>
<a name="ln1360">      /**</a>
<a name="ln1361">       *  @brief  Finds the index of the first &quot;on&quot; bit.</a>
<a name="ln1362">       *  @return  The index of the first bit set, or size() if not found.</a>
<a name="ln1363">       *  @ingroup SGIextensions</a>
<a name="ln1364">       *  @sa  _Find_next</a>
<a name="ln1365">       */</a>
<a name="ln1366">      size_t</a>
<a name="ln1367">      _Find_first() const _GLIBCXX_NOEXCEPT</a>
<a name="ln1368">      { return this-&gt;_M_do_find_first(_Nb); }</a>
<a name="ln1369"> </a>
<a name="ln1370">      /**</a>
<a name="ln1371">       *  @brief  Finds the index of the next &quot;on&quot; bit after prev.</a>
<a name="ln1372">       *  @return  The index of the next bit set, or size() if not found.</a>
<a name="ln1373">       *  @param  __prev  Where to start searching.</a>
<a name="ln1374">       *  @ingroup SGIextensions</a>
<a name="ln1375">       *  @sa  _Find_first</a>
<a name="ln1376">       */</a>
<a name="ln1377">      size_t</a>
<a name="ln1378">      _Find_next(size_t __prev) const _GLIBCXX_NOEXCEPT</a>
<a name="ln1379">      { return this-&gt;_M_do_find_next(__prev, _Nb); }</a>
<a name="ln1380">    };</a>
<a name="ln1381"> </a>
<a name="ln1382">  // Definitions of non-inline member functions.</a>
<a name="ln1383">  template&lt;size_t _Nb&gt;</a>
<a name="ln1384">    template&lt;class _CharT, class _Traits&gt;</a>
<a name="ln1385">      void</a>
<a name="ln1386">      bitset&lt;_Nb&gt;::</a>
<a name="ln1387">      _M_copy_from_ptr(const _CharT* __s, size_t __len,</a>
<a name="ln1388">		       size_t __pos, size_t __n, _CharT __zero, _CharT __one)</a>
<a name="ln1389">      {</a>
<a name="ln1390">	reset();</a>
<a name="ln1391">	const size_t __nbits = std::min(_Nb, std::min(__n, size_t(__len - __pos)));</a>
<a name="ln1392">	for (size_t __i = __nbits; __i &gt; 0; --__i)</a>
<a name="ln1393">	  {</a>
<a name="ln1394">	    const _CharT __c = __s[__pos + __nbits - __i];</a>
<a name="ln1395">	    if (_Traits::eq(__c, __zero))</a>
<a name="ln1396">	      ;</a>
<a name="ln1397">	    else if (_Traits::eq(__c, __one))</a>
<a name="ln1398">	      _Unchecked_set(__i - 1);</a>
<a name="ln1399">	    else</a>
<a name="ln1400">	      __throw_invalid_argument(__N(&quot;bitset::_M_copy_from_ptr&quot;));</a>
<a name="ln1401">	  }</a>
<a name="ln1402">      }</a>
<a name="ln1403"> </a>
<a name="ln1404">  template&lt;size_t _Nb&gt;</a>
<a name="ln1405">    template&lt;class _CharT, class _Traits, class _Alloc&gt;</a>
<a name="ln1406">      void</a>
<a name="ln1407">      bitset&lt;_Nb&gt;::</a>
<a name="ln1408">      _M_copy_to_string(std::basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __s,</a>
<a name="ln1409">			_CharT __zero, _CharT __one) const</a>
<a name="ln1410">      {</a>
<a name="ln1411">	__s.assign(_Nb, __zero);</a>
<a name="ln1412">	for (size_t __i = _Nb; __i &gt; 0; --__i)</a>
<a name="ln1413">	  if (_Unchecked_test(__i - 1))</a>
<a name="ln1414">	    _Traits::assign(__s[_Nb - __i], __one);</a>
<a name="ln1415">      }</a>
<a name="ln1416"> </a>
<a name="ln1417">  // 23.3.5.3 bitset operations:</a>
<a name="ln1418">  //@{</a>
<a name="ln1419">  /**</a>
<a name="ln1420">   *  @brief  Global bitwise operations on bitsets.</a>
<a name="ln1421">   *  @param  __x  A bitset.</a>
<a name="ln1422">   *  @param  __y  A bitset of the same size as @a __x.</a>
<a name="ln1423">   *  @return  A new bitset.</a>
<a name="ln1424">   *</a>
<a name="ln1425">   *  These should be self-explanatory.</a>
<a name="ln1426">  */</a>
<a name="ln1427">  template&lt;size_t _Nb&gt;</a>
<a name="ln1428">    inline bitset&lt;_Nb&gt;</a>
<a name="ln1429">    operator&amp;(const bitset&lt;_Nb&gt;&amp; __x, const bitset&lt;_Nb&gt;&amp; __y) _GLIBCXX_NOEXCEPT</a>
<a name="ln1430">    {</a>
<a name="ln1431">      bitset&lt;_Nb&gt; __result(__x);</a>
<a name="ln1432">      __result &amp;= __y;</a>
<a name="ln1433">      return __result;</a>
<a name="ln1434">    }</a>
<a name="ln1435"> </a>
<a name="ln1436">  template&lt;size_t _Nb&gt;</a>
<a name="ln1437">    inline bitset&lt;_Nb&gt;</a>
<a name="ln1438">    operator|(const bitset&lt;_Nb&gt;&amp; __x, const bitset&lt;_Nb&gt;&amp; __y) _GLIBCXX_NOEXCEPT</a>
<a name="ln1439">    {</a>
<a name="ln1440">      bitset&lt;_Nb&gt; __result(__x);</a>
<a name="ln1441">      __result |= __y;</a>
<a name="ln1442">      return __result;</a>
<a name="ln1443">    }</a>
<a name="ln1444"> </a>
<a name="ln1445">  template &lt;size_t _Nb&gt;</a>
<a name="ln1446">    inline bitset&lt;_Nb&gt;</a>
<a name="ln1447">    operator^(const bitset&lt;_Nb&gt;&amp; __x, const bitset&lt;_Nb&gt;&amp; __y) _GLIBCXX_NOEXCEPT</a>
<a name="ln1448">    {</a>
<a name="ln1449">      bitset&lt;_Nb&gt; __result(__x);</a>
<a name="ln1450">      __result ^= __y;</a>
<a name="ln1451">      return __result;</a>
<a name="ln1452">    }</a>
<a name="ln1453">  //@}</a>
<a name="ln1454"> </a>
<a name="ln1455">  //@{</a>
<a name="ln1456">  /**</a>
<a name="ln1457">   *  @brief Global I/O operators for bitsets.</a>
<a name="ln1458">   *</a>
<a name="ln1459">   *  Direct I/O between streams and bitsets is supported.  Output is</a>
<a name="ln1460">   *  straightforward.  Input will skip whitespace, only accept @a 0 and @a 1</a>
<a name="ln1461">   *  characters, and will only extract as many digits as the %bitset will</a>
<a name="ln1462">   *  hold.</a>
<a name="ln1463">  */</a>
<a name="ln1464">  template&lt;class _CharT, class _Traits, size_t _Nb&gt;</a>
<a name="ln1465">    std::basic_istream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln1466">    operator&gt;&gt;(std::basic_istream&lt;_CharT, _Traits&gt;&amp; __is, bitset&lt;_Nb&gt;&amp; __x)</a>
<a name="ln1467">    {</a>
<a name="ln1468">      typedef typename _Traits::char_type          char_type;</a>
<a name="ln1469">      typedef std::basic_istream&lt;_CharT, _Traits&gt;  __istream_type;</a>
<a name="ln1470">      typedef typename __istream_type::ios_base    __ios_base;</a>
<a name="ln1471"> </a>
<a name="ln1472">      std::basic_string&lt;_CharT, _Traits&gt; __tmp;</a>
<a name="ln1473">      __tmp.reserve(_Nb);</a>
<a name="ln1474"> </a>
<a name="ln1475">      // _GLIBCXX_RESOLVE_LIB_DEFECTS</a>
<a name="ln1476">      // 303. Bitset input operator underspecified</a>
<a name="ln1477">      const char_type __zero = __is.widen('0');</a>
<a name="ln1478">      const char_type __one = __is.widen('1');</a>
<a name="ln1479"> </a>
<a name="ln1480">      typename __ios_base::iostate __state = __ios_base::goodbit;</a>
<a name="ln1481">      typename __istream_type::sentry __sentry(__is);</a>
<a name="ln1482">      if (__sentry)</a>
<a name="ln1483">	{</a>
<a name="ln1484">	  __try</a>
<a name="ln1485">	    {</a>
<a name="ln1486">	      for (size_t __i = _Nb; __i &gt; 0; --__i)</a>
<a name="ln1487">		{</a>
<a name="ln1488">		  static typename _Traits::int_type __eof = _Traits::eof();</a>
<a name="ln1489"> </a>
<a name="ln1490">		  typename _Traits::int_type __c1 = __is.rdbuf()-&gt;sbumpc();</a>
<a name="ln1491">		  if (_Traits::eq_int_type(__c1, __eof))</a>
<a name="ln1492">		    {</a>
<a name="ln1493">		      __state |= __ios_base::eofbit;</a>
<a name="ln1494">		      break;</a>
<a name="ln1495">		    }</a>
<a name="ln1496">		  else</a>
<a name="ln1497">		    {</a>
<a name="ln1498">		      const char_type __c2 = _Traits::to_char_type(__c1);</a>
<a name="ln1499">		      if (_Traits::eq(__c2, __zero))</a>
<a name="ln1500">			__tmp.push_back(__zero);</a>
<a name="ln1501">		      else if (_Traits::eq(__c2, __one))</a>
<a name="ln1502">			__tmp.push_back(__one);</a>
<a name="ln1503">		      else if (_Traits::</a>
<a name="ln1504">			       eq_int_type(__is.rdbuf()-&gt;sputbackc(__c2),</a>
<a name="ln1505">					   __eof))</a>
<a name="ln1506">			{</a>
<a name="ln1507">			  __state |= __ios_base::failbit;</a>
<a name="ln1508">			  break;</a>
<a name="ln1509">			}</a>
<a name="ln1510">		    }</a>
<a name="ln1511">		}</a>
<a name="ln1512">	    }</a>
<a name="ln1513">	  __catch(__cxxabiv1::__forced_unwind&amp;)</a>
<a name="ln1514">	    {</a>
<a name="ln1515">	      __is._M_setstate(__ios_base::badbit);</a>
<a name="ln1516">	      __throw_exception_again;</a>
<a name="ln1517">	    }</a>
<a name="ln1518">	  __catch(...)</a>
<a name="ln1519">	    { __is._M_setstate(__ios_base::badbit); }</a>
<a name="ln1520">	}</a>
<a name="ln1521"> </a>
<a name="ln1522">      if (__tmp.empty() &amp;&amp; _Nb)</a>
<a name="ln1523">	__state |= __ios_base::failbit;</a>
<a name="ln1524">      else</a>
<a name="ln1525">	__x._M_copy_from_string(__tmp, static_cast&lt;size_t&gt;(0), _Nb,</a>
<a name="ln1526">				__zero, __one);</a>
<a name="ln1527">      if (__state)</a>
<a name="ln1528">	__is.setstate(__state);</a>
<a name="ln1529">      return __is;</a>
<a name="ln1530">    }</a>
<a name="ln1531"> </a>
<a name="ln1532">  template &lt;class _CharT, class _Traits, size_t _Nb&gt;</a>
<a name="ln1533">    std::basic_ostream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln1534">    operator&lt;&lt;(std::basic_ostream&lt;_CharT, _Traits&gt;&amp; __os,</a>
<a name="ln1535">	       const bitset&lt;_Nb&gt;&amp; __x)</a>
<a name="ln1536">    {</a>
<a name="ln1537">      std::basic_string&lt;_CharT, _Traits&gt; __tmp;</a>
<a name="ln1538"> </a>
<a name="ln1539">      // _GLIBCXX_RESOLVE_LIB_DEFECTS</a>
<a name="ln1540">      // 396. what are characters zero and one.</a>
<a name="ln1541">      const ctype&lt;_CharT&gt;&amp; __ct = use_facet&lt;ctype&lt;_CharT&gt; &gt;(__os.getloc());</a>
<a name="ln1542">      __x._M_copy_to_string(__tmp, __ct.widen('0'), __ct.widen('1'));</a>
<a name="ln1543">      return __os &lt;&lt; __tmp;</a>
<a name="ln1544">    }</a>
<a name="ln1545">  //@}</a>
<a name="ln1546"> </a>
<a name="ln1547">_GLIBCXX_END_NAMESPACE_CONTAINER</a>
<a name="ln1548">} // namespace std</a>
<a name="ln1549"> </a>
<a name="ln1550">#undef _GLIBCXX_BITSET_WORDS</a>
<a name="ln1551">#undef _GLIBCXX_BITSET_BITS_PER_WORD</a>
<a name="ln1552">#undef _GLIBCXX_BITSET_BITS_PER_ULL</a>
<a name="ln1553"> </a>
<a name="ln1554">#if __cplusplus &gt;= 201103L</a>
<a name="ln1555"> </a>
<a name="ln1556">namespace std _GLIBCXX_VISIBILITY(default)</a>
<a name="ln1557">{</a>
<a name="ln1558">_GLIBCXX_BEGIN_NAMESPACE_VERSION</a>
<a name="ln1559"> </a>
<a name="ln1560">  // DR 1182.</a>
<a name="ln1561">  /// std::hash specialization for bitset.</a>
<a name="ln1562">  template&lt;size_t _Nb&gt;</a>
<a name="ln1563">    struct hash&lt;_GLIBCXX_STD_C::bitset&lt;_Nb&gt;&gt;</a>
<a name="ln1564">    : public __hash_base&lt;size_t, _GLIBCXX_STD_C::bitset&lt;_Nb&gt;&gt;</a>
<a name="ln1565">    {</a>
<a name="ln1566">      size_t</a>
<a name="ln1567">      operator()(const _GLIBCXX_STD_C::bitset&lt;_Nb&gt;&amp; __b) const noexcept</a>
<a name="ln1568">      {</a>
<a name="ln1569">	const size_t __clength = (_Nb + __CHAR_BIT__ - 1) / __CHAR_BIT__;</a>
<a name="ln1570">	return std::_Hash_impl::hash(__b._M_getdata(), __clength);</a>
<a name="ln1571">      }</a>
<a name="ln1572">    };</a>
<a name="ln1573"> </a>
<a name="ln1574">  template&lt;&gt;</a>
<a name="ln1575">    struct hash&lt;_GLIBCXX_STD_C::bitset&lt;0&gt;&gt;</a>
<a name="ln1576">    : public __hash_base&lt;size_t, _GLIBCXX_STD_C::bitset&lt;0&gt;&gt;</a>
<a name="ln1577">    {</a>
<a name="ln1578">      size_t</a>
<a name="ln1579">      operator()(const _GLIBCXX_STD_C::bitset&lt;0&gt;&amp;) const noexcept</a>
<a name="ln1580">      { return 0; }</a>
<a name="ln1581">    };</a>
<a name="ln1582"> </a>
<a name="ln1583">_GLIBCXX_END_NAMESPACE_VERSION</a>
<a name="ln1584">} // namespace</a>
<a name="ln1585"> </a>
<a name="ln1586">#endif // C++11</a>
<a name="ln1587"> </a>
<a name="ln1588">#ifdef _GLIBCXX_DEBUG</a>
<a name="ln1589"># include &lt;debug/bitset&gt;</a>
<a name="ln1590">#endif</a>
<a name="ln1591"> </a>
<a name="ln1592">#ifdef _GLIBCXX_PROFILE</a>
<a name="ln1593"># include &lt;profile/bitset&gt;</a>
<a name="ln1594">#endif</a>
<a name="ln1595"> </a>
<a name="ln1596">#endif /* _GLIBCXX_BITSET */</a>

</code></pre>
<div class="balloon" rel="564"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v509/" target="_blank">V509</a> The 'new' operator is used in the noexcept '_M_getword' function. It should be located inside the try..catch block, as it could potentially generate an exception.</p></div>
<div class="balloon" rel="802"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v690/" target="_blank">V690</a> The 'reference' class implements the copy assignment operator, but lacks a copy constructor. It is dangerous to use such a class.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
