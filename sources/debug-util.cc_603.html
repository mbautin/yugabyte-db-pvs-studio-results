
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>debug-util.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Licensed to the Apache Software Foundation (ASF) under one</a>
<a name="ln2">// or more contributor license agreements.  See the NOTICE file</a>
<a name="ln3">// distributed with this work for additional information</a>
<a name="ln4">// regarding copyright ownership.  The ASF licenses this file</a>
<a name="ln5">// to you under the Apache License, Version 2.0 (the</a>
<a name="ln6">// &quot;License&quot;); you may not use this file except in compliance</a>
<a name="ln7">// with the License.  You may obtain a copy of the License at</a>
<a name="ln8">//</a>
<a name="ln9">//   http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln10">//</a>
<a name="ln11">// Unless required by applicable law or agreed to in writing,</a>
<a name="ln12">// software distributed under the License is distributed on an</a>
<a name="ln13">// &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</a>
<a name="ln14">// KIND, either express or implied.  See the License for the</a>
<a name="ln15">// specific language governing permissions and limitations</a>
<a name="ln16">// under the License.</a>
<a name="ln17">//</a>
<a name="ln18">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln19">//</a>
<a name="ln20">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln21">//</a>
<a name="ln22">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln23">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln24">//</a>
<a name="ln25">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln26">//</a>
<a name="ln27">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln28">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln29">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln30">// under the License.</a>
<a name="ln31">//</a>
<a name="ln32"> </a>
<a name="ln33">#include &quot;yb/util/debug-util.h&quot;</a>
<a name="ln34"> </a>
<a name="ln35">#include &lt;execinfo.h&gt;</a>
<a name="ln36">#include &lt;dirent.h&gt;</a>
<a name="ln37">#include &lt;signal.h&gt;</a>
<a name="ln38">#include &lt;sys/syscall.h&gt;</a>
<a name="ln39"> </a>
<a name="ln40">#ifdef __linux__</a>
<a name="ln41">#include &lt;link.h&gt;</a>
<a name="ln42">#include &lt;cxxabi.h&gt;</a>
<a name="ln43">#endif // __linux__</a>
<a name="ln44"> </a>
<a name="ln45">#ifdef __linux__</a>
<a name="ln46">#include &lt;backtrace.h&gt;</a>
<a name="ln47">#endif // __linux__</a>
<a name="ln48"> </a>
<a name="ln49">#include &lt;string&gt;</a>
<a name="ln50">#include &lt;iostream&gt;</a>
<a name="ln51">#include &lt;regex&gt;</a>
<a name="ln52">#include &lt;unordered_map&gt;</a>
<a name="ln53">#include &lt;unordered_set&gt;</a>
<a name="ln54">#include &lt;fstream&gt;</a>
<a name="ln55">#include &lt;queue&gt;</a>
<a name="ln56">#include &lt;sstream&gt;</a>
<a name="ln57"> </a>
<a name="ln58">#include &lt;glog/logging.h&gt;</a>
<a name="ln59"> </a>
<a name="ln60">#include &quot;yb/gutil/linux_syscall_support.h&quot;</a>
<a name="ln61">#include &quot;yb/gutil/macros.h&quot;</a>
<a name="ln62">#include &quot;yb/gutil/singleton.h&quot;</a>
<a name="ln63">#include &quot;yb/gutil/spinlock.h&quot;</a>
<a name="ln64">#include &quot;yb/gutil/stringprintf.h&quot;</a>
<a name="ln65">#include &quot;yb/gutil/strings/numbers.h&quot;</a>
<a name="ln66">#include &quot;yb/gutil/strtoint.h&quot;</a>
<a name="ln67"> </a>
<a name="ln68">#include &quot;yb/util/enums.h&quot;</a>
<a name="ln69">#include &quot;yb/util/env.h&quot;</a>
<a name="ln70">#include &quot;yb/util/errno.h&quot;</a>
<a name="ln71">#include &quot;yb/util/lockfree.h&quot;</a>
<a name="ln72">#include &quot;yb/util/memory/memory.h&quot;</a>
<a name="ln73">#include &quot;yb/util/monotime.h&quot;</a>
<a name="ln74">#include &quot;yb/util/thread.h&quot;</a>
<a name="ln75">#include &quot;yb/util/string_trim.h&quot;</a>
<a name="ln76"> </a>
<a name="ln77">using namespace std::literals;</a>
<a name="ln78"> </a>
<a name="ln79">#if defined(__linux__) &amp;&amp; !defined(NDEBUG)</a>
<a name="ln80">constexpr bool kDefaultUseLibbacktrace = true;</a>
<a name="ln81">#else</a>
<a name="ln82">constexpr bool kDefaultUseLibbacktrace = false;</a>
<a name="ln83">#endif</a>
<a name="ln84"> </a>
<a name="ln85">DEFINE_bool(use_libbacktrace, kDefaultUseLibbacktrace,</a>
<a name="ln86">            &quot;Whether to use the libbacktrace library for symbolizing stack traces&quot;);</a>
<a name="ln87"> </a>
<a name="ln88">#if defined(__APPLE__)</a>
<a name="ln89">typedef sig_t sighandler_t;</a>
<a name="ln90">#endif</a>
<a name="ln91"> </a>
<a name="ln92">// Evil hack to grab a few useful functions from glog</a>
<a name="ln93">namespace google {</a>
<a name="ln94"> </a>
<a name="ln95">extern int GetStackTrace(void** result, int max_depth, int skip_count);</a>
<a name="ln96"> </a>
<a name="ln97">// Symbolizes a program counter.  On success, returns true and write the</a>
<a name="ln98">// symbol name to &quot;out&quot;.  The symbol name is demangled if possible</a>
<a name="ln99">// (supports symbols generated by GCC 3.x or newer).  Otherwise,</a>
<a name="ln100">// returns false.</a>
<a name="ln101">bool Symbolize(void *pc, char *out, int out_size);</a>
<a name="ln102"> </a>
<a name="ln103">namespace glog_internal_namespace_ {</a>
<a name="ln104">extern void DumpStackTraceToString(std::string *s);</a>
<a name="ln105">} // namespace glog_internal_namespace_</a>
<a name="ln106">} // namespace google</a>
<a name="ln107"> </a>
<a name="ln108">// The %p field width for printf() functions is two characters per byte.</a>
<a name="ln109">// For some environments, add two extra bytes for the leading &quot;0x&quot;.</a>
<a name="ln110">static const int kPrintfPointerFieldWidth = 2 + 2 * sizeof(void*);</a>
<a name="ln111"> </a>
<a name="ln112">using std::string;</a>
<a name="ln113"> </a>
<a name="ln114">namespace yb {</a>
<a name="ln115"> </a>
<a name="ln116">// https://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01696.html</a>
<a name="ln117">enum DemangleStatus : int {</a>
<a name="ln118">  kDemangleOk = 0,</a>
<a name="ln119">  kDemangleMemAllocFailure = -1,</a>
<a name="ln120">  kDemangleInvalidMangledName = -2,</a>
<a name="ln121">  kDemangleInvalidArgument = -3</a>
<a name="ln122">};</a>
<a name="ln123"> </a>
<a name="ln124">namespace {</a>
<a name="ln125"> </a>
<a name="ln126">YB_DEFINE_ENUM(ThreadStackState, (kNone)(kSendFailed)(kReady));</a>
<a name="ln127"> </a>
<a name="ln128">struct ThreadStackEntry : public MPSCQueueEntry&lt;ThreadStackEntry&gt; {</a>
<a name="ln129">  ThreadIdForStack tid;</a>
<a name="ln130">  StackTrace stack;</a>
<a name="ln131">};</a>
<a name="ln132"> </a>
<a name="ln133">#if !defined(__APPLE__) &amp;&amp; !defined(THREAD_SANITIZER) &amp;&amp; !defined(ADDRESS_SANITIZER)</a>
<a name="ln134">#define USE_FUTEX 1</a>
<a name="ln135">#else</a>
<a name="ln136">#define USE_FUTEX 0</a>
<a name="ln137">#endif</a>
<a name="ln138"> </a>
<a name="ln139">class CompletionFlag {</a>
<a name="ln140"> public:</a>
<a name="ln141">  void Signal() {</a>
<a name="ln142">    complete_.store(1, std::memory_order_release);</a>
<a name="ln143">#if USE_FUTEX</a>
<a name="ln144">    sys_futex(reinterpret_cast&lt;int32_t*&gt;(&amp;complete_),</a>
<a name="ln145">              FUTEX_WAKE | FUTEX_PRIVATE_FLAG,</a>
<a name="ln146">              INT_MAX, // wake all</a>
<a name="ln147">              0 /* ignored */);</a>
<a name="ln148">#endif</a>
<a name="ln149">  }</a>
<a name="ln150"> </a>
<a name="ln151">  bool TimedWait(MonoDelta timeout) {</a>
<a name="ln152">    if (complete()) {</a>
<a name="ln153">      return true;</a>
<a name="ln154">    }</a>
<a name="ln155"> </a>
<a name="ln156">    auto now = MonoTime::Now();</a>
<a name="ln157">    auto deadline = now + timeout;</a>
<a name="ln158">#if !USE_FUTEX</a>
<a name="ln159">    auto wait_time = 10ms;</a>
<a name="ln160">#endif</a>
<a name="ln161">    while (now &lt; deadline) {</a>
<a name="ln162">#if USE_FUTEX</a>
<a name="ln163">      struct timespec ts;</a>
<a name="ln164">      (deadline - now).ToTimeSpec(&amp;ts);</a>
<a name="ln165">      kernel_timespec kernel_ts;</a>
<a name="ln166">      ts.tv_sec = ts.tv_sec;</a>
<a name="ln167">      ts.tv_nsec = ts.tv_nsec;</a>
<a name="ln168">      sys_futex(reinterpret_cast&lt;int32_t*&gt;(&amp;complete_),</a>
<a name="ln169">                FUTEX_WAIT | FUTEX_PRIVATE_FLAG,</a>
<a name="ln170">                0, // wait if value is still 0</a>
<a name="ln171">                &amp;kernel_ts);</a>
<a name="ln172">#else</a>
<a name="ln173">      std::this_thread::sleep_for(wait_time);</a>
<a name="ln174">      wait_time = std::min(wait_time * 2, 100ms);</a>
<a name="ln175">#endif</a>
<a name="ln176">      if (complete()) {</a>
<a name="ln177">        return true;</a>
<a name="ln178">      }</a>
<a name="ln179">      now = MonoTime::Now();</a>
<a name="ln180">    }</a>
<a name="ln181"> </a>
<a name="ln182">    return complete();</a>
<a name="ln183">  }</a>
<a name="ln184"> </a>
<a name="ln185">  void Reset() {</a>
<a name="ln186">    complete_.store(0, std::memory_order_release);</a>
<a name="ln187">  }</a>
<a name="ln188"> </a>
<a name="ln189">  bool complete() const {</a>
<a name="ln190">    return complete_.load(std::memory_order_acquire);</a>
<a name="ln191">  }</a>
<a name="ln192"> private:</a>
<a name="ln193">  std::atomic&lt;int32_t&gt; complete_ { 0 };</a>
<a name="ln194">};</a>
<a name="ln195"> </a>
<a name="ln196">// Global structure used to communicate between the signal handler</a>
<a name="ln197">// and a dumping thread.</a>
<a name="ln198">struct ThreadStackHelper {</a>
<a name="ln199">  std::mutex mutex; // Locked by ThreadStacks, so only one could be executed in parallel.</a>
<a name="ln200"> </a>
<a name="ln201">  LockFreeStack&lt;ThreadStackEntry&gt; collected;</a>
<a name="ln202">  // Reuse previously allocated memory. We expect this size to be merely small, near 152 bytes</a>
<a name="ln203">  // per application thread.</a>
<a name="ln204">  LockFreeStack&lt;ThreadStackEntry&gt; allocated;</a>
<a name="ln205">  CompletionFlag completion_flag;</a>
<a name="ln206"> </a>
<a name="ln207">  // Could be modified only by ThreadStacks.</a>
<a name="ln208">  CoarseTimePoint deadline;</a>
<a name="ln209">  size_t allocated_entries = 0;</a>
<a name="ln210"> </a>
<a name="ln211">  // Incremented by each signal handler.</a>
<a name="ln212">  std::atomic&lt;int64_t&gt; left_to_collect;</a>
<a name="ln213"> </a>
<a name="ln214">  std::vector&lt;std::unique_ptr&lt;ThreadStackEntry[]&gt;&gt; allocated_chunks;</a>
<a name="ln215"> </a>
<a name="ln216">  void SetNumEntries(size_t len) {</a>
<a name="ln217">    len += 5; // We reserve several entries, because threads from previous request could still be</a>
<a name="ln218">              // processing signal and write their results.</a>
<a name="ln219">    if (len &lt;= allocated_entries) {</a>
<a name="ln220">      return;</a>
<a name="ln221">    }</a>
<a name="ln222"> </a>
<a name="ln223">    size_t new_chunk_size = std::max&lt;size_t&gt;(len - allocated_entries, 0x10);</a>
<a name="ln224">    allocated_chunks.emplace_back(new ThreadStackEntry[new_chunk_size]);</a>
<a name="ln225">    allocated_entries += new_chunk_size;</a>
<a name="ln226"> </a>
<a name="ln227">    for (auto entry = allocated_chunks.back().get(), end = entry + new_chunk_size; entry != end;</a>
<a name="ln228">         ++entry) {</a>
<a name="ln229">      allocated.Push(entry);</a>
<a name="ln230">    }</a>
<a name="ln231">  }</a>
<a name="ln232"> </a>
<a name="ln233">  void StoreResult(</a>
<a name="ln234">      const std::vector&lt;ThreadIdForStack&gt;&amp; tids, std::vector&lt;Result&lt;StackTrace&gt;&gt;* out) {</a>
<a name="ln235">    // We give the thread ~1s to respond. In testing, threads typically respond within</a>
<a name="ln236">    // a few iterations of the loop, so this timeout is very conservative.</a>
<a name="ln237">    //</a>
<a name="ln238">    // The main reason that a thread would not respond is that it has blocked signals. For</a>
<a name="ln239">    // example, glibc's timer_thread doesn't respond to our signal, so we always time out</a>
<a name="ln240">    // on that one.</a>
<a name="ln241">    if (left_to_collect.load(std::memory_order_acquire) &gt; 0) {</a>
<a name="ln242">      completion_flag.TimedWait(1s);</a>
<a name="ln243">    }</a>
<a name="ln244"> </a>
<a name="ln245">    while (auto entry = collected.Pop()) {</a>
<a name="ln246">      auto it = std::lower_bound(tids.begin(), tids.end(), entry-&gt;tid);</a>
<a name="ln247">      if (it != tids.end() &amp;&amp; *it == entry-&gt;tid) {</a>
<a name="ln248">        (*out)[it - tids.begin()] = entry-&gt;stack;</a>
<a name="ln249">      }</a>
<a name="ln250">      allocated.Push(entry);</a>
<a name="ln251">    }</a>
<a name="ln252">  }</a>
<a name="ln253"> </a>
<a name="ln254">  void RecordStackTrace(const StackTrace&amp; stack_trace) {</a>
<a name="ln255">    auto* entry = allocated.Pop();</a>
<a name="ln256">    if (entry) {</a>
<a name="ln257">      // Not enough allocated entries, don't write log since we are in signal handler.</a>
<a name="ln258">      entry-&gt;tid = Thread::CurrentThreadIdForStack();</a>
<a name="ln259">      entry-&gt;stack = stack_trace;</a>
<a name="ln260">      collected.Push(entry);</a>
<a name="ln261">    }</a>
<a name="ln262"> </a>
<a name="ln263">    if (left_to_collect.fetch_sub(1, std::memory_order_acq_rel) - 1 &lt;= 0) {</a>
<a name="ln264">      completion_flag.Signal();</a>
<a name="ln265">    }</a>
<a name="ln266">  }</a>
<a name="ln267">};</a>
<a name="ln268"> </a>
<a name="ln269">ThreadStackHelper thread_stack_helper;</a>
<a name="ln270"> </a>
<a name="ln271">// Signal handler for our stack trace signal.</a>
<a name="ln272">// We expect that the signal is only sent from DumpThreadStack() -- not by a user.</a>
<a name="ln273"> </a>
<a name="ln274">void HandleStackTraceSignal(int signum) {</a>
<a name="ln275">  int old_errno = errno;</a>
<a name="ln276">  StackTrace stack_trace;</a>
<a name="ln277">  stack_trace.Collect(2);</a>
<a name="ln278"> </a>
<a name="ln279">  thread_stack_helper.RecordStackTrace(stack_trace);</a>
<a name="ln280">  errno = old_errno;</a>
<a name="ln281">}</a>
<a name="ln282"> </a>
<a name="ln283">// The signal that we'll use to communicate with our other threads.</a>
<a name="ln284">// This can't be in used by other libraries in the process.</a>
<a name="ln285">int g_stack_trace_signum = SIGUSR2;</a>
<a name="ln286"> </a>
<a name="ln287">bool InitSignalHandlerUnlocked(int signum) {</a>
<a name="ln288">  enum InitState {</a>
<a name="ln289">    UNINITIALIZED,</a>
<a name="ln290">    INIT_ERROR,</a>
<a name="ln291">    INITIALIZED</a>
<a name="ln292">  };</a>
<a name="ln293">  static InitState state = UNINITIALIZED;</a>
<a name="ln294"> </a>
<a name="ln295">  // If we've already registered a handler, but we're being asked to</a>
<a name="ln296">  // change our signal, unregister the old one.</a>
<a name="ln297">  if (signum != g_stack_trace_signum &amp;&amp; state == INITIALIZED) {</a>
<a name="ln298">    struct sigaction old_act;</a>
<a name="ln299">    PCHECK(sigaction(g_stack_trace_signum, nullptr, &amp;old_act) == 0);</a>
<a name="ln300">    if (old_act.sa_handler == &amp;HandleStackTraceSignal) {</a>
<a name="ln301">      signal(g_stack_trace_signum, SIG_DFL);</a>
<a name="ln302">    }</a>
<a name="ln303">  }</a>
<a name="ln304"> </a>
<a name="ln305">  // If we'd previously had an error, but the signal number</a>
<a name="ln306">  // is changing, we should mark ourselves uninitialized.</a>
<a name="ln307">  if (signum != g_stack_trace_signum) {</a>
<a name="ln308">    g_stack_trace_signum = signum;</a>
<a name="ln309">    state = UNINITIALIZED;</a>
<a name="ln310">  }</a>
<a name="ln311"> </a>
<a name="ln312">  if (state == UNINITIALIZED) {</a>
<a name="ln313">    struct sigaction old_act;</a>
<a name="ln314">    PCHECK(sigaction(g_stack_trace_signum, nullptr, &amp;old_act) == 0);</a>
<a name="ln315">    if (old_act.sa_handler != SIG_DFL &amp;&amp;</a>
<a name="ln316">        old_act.sa_handler != SIG_IGN) {</a>
<a name="ln317">      state = INIT_ERROR;</a>
<a name="ln318">      LOG(WARNING) &lt;&lt; &quot;signal handler for stack trace signal &quot;</a>
<a name="ln319">                   &lt;&lt; g_stack_trace_signum</a>
<a name="ln320">                   &lt;&lt; &quot; is already in use: &quot;</a>
<a name="ln321">                   &lt;&lt; &quot;YB will not produce thread stack traces.&quot;;</a>
<a name="ln322">    } else {</a>
<a name="ln323">      // No one appears to be using the signal. This is racy, but there is no</a>
<a name="ln324">      // atomic swap capability.</a>
<a name="ln325">      sighandler_t old_handler = signal(g_stack_trace_signum, HandleStackTraceSignal);</a>
<a name="ln326">      if (old_handler != SIG_IGN &amp;&amp;</a>
<a name="ln327">          old_handler != SIG_DFL) {</a>
<a name="ln328">        LOG(FATAL) &lt;&lt; &quot;raced against another thread installing a signal handler&quot;;</a>
<a name="ln329">      }</a>
<a name="ln330">      state = INITIALIZED;</a>
<a name="ln331">    }</a>
<a name="ln332">  }</a>
<a name="ln333">  return state == INITIALIZED;</a>
<a name="ln334">}</a>
<a name="ln335"> </a>
<a name="ln336">const char kUnknownSymbol[] = &quot;(unknown)&quot;;</a>
<a name="ln337">const char kStackTraceEntryFormat[] = &quot;    @ %*p  %s&quot;;</a>
<a name="ln338"> </a>
<a name="ln339">#ifdef __linux__</a>
<a name="ln340"> </a>
<a name="ln341">// Remove path prefixes up to what looks like the root of the YB source tree, or the source tree</a>
<a name="ln342">// of other recognizable codebases.</a>
<a name="ln343">const char* NormalizeSourceFilePath(const char* file_path) {</a>
<a name="ln344">  if (file_path == nullptr) {</a>
<a name="ln345">    return file_path;</a>
<a name="ln346">  }</a>
<a name="ln347"> </a>
<a name="ln348">  // Remove the leading &quot;../../../&quot; stuff.</a>
<a name="ln349">  while (strncmp(file_path, &quot;../&quot;, 3) == 0) {</a>
<a name="ln350">    file_path += 3;</a>
<a name="ln351">  }</a>
<a name="ln352"> </a>
<a name="ln353">  // This could be called arbitrarily early or late in program execution as part of backtrace,</a>
<a name="ln354">  // so we're not using any std::string static constants here.</a>
<a name="ln355">#define YB_HANDLE_SOURCE_SUBPATH(subpath, prefix_len_to_remove) \</a>
<a name="ln356">    do { \</a>
<a name="ln357">      const char* const subpath_ptr = strstr(file_path, (subpath)); \</a>
<a name="ln358">      if (subpath_ptr != nullptr) { \</a>
<a name="ln359">        return subpath_ptr + (prefix_len_to_remove); \</a>
<a name="ln360">      } \</a>
<a name="ln361">    } while (0);</a>
<a name="ln362"> </a>
<a name="ln363">  YB_HANDLE_SOURCE_SUBPATH(&quot;/src/yb/&quot;, 5);</a>
<a name="ln364">  YB_HANDLE_SOURCE_SUBPATH(&quot;/src/postgres/src/&quot;, 5);</a>
<a name="ln365">  YB_HANDLE_SOURCE_SUBPATH(&quot;/src/rocksdb/&quot;, 5);</a>
<a name="ln366">  YB_HANDLE_SOURCE_SUBPATH(&quot;/thirdparty/build/&quot;, 1);</a>
<a name="ln367"> </a>
<a name="ln368">  // These are Linuxbrew gcc's standard headers. Keep the path starting from &quot;gcc/...&quot;.</a>
<a name="ln369">  YB_HANDLE_SOURCE_SUBPATH(&quot;/Cellar/gcc/&quot;, 8);</a>
<a name="ln370"> </a>
<a name="ln371">  // TODO: replace postgres_build with just postgres.</a>
<a name="ln372">  YB_HANDLE_SOURCE_SUBPATH(&quot;/postgres_build/src/&quot;, 1);</a>
<a name="ln373"> </a>
<a name="ln374">#undef YB_HANDLE_SOURCE_SUBPATH</a>
<a name="ln375"> </a>
<a name="ln376">  return file_path;</a>
<a name="ln377">}</a>
<a name="ln378"> </a>
<a name="ln379">struct SymbolizationContext {</a>
<a name="ln380">  StackTraceLineFormat stack_trace_line_format = StackTraceLineFormat::DEFAULT;</a>
<a name="ln381">  string* buf = nullptr;</a>
<a name="ln382">};</a>
<a name="ln383"> </a>
<a name="ln384">void BacktraceErrorCallback(void* data, const char* msg, int errnum) {</a>
<a name="ln385">  bool reported = false;</a>
<a name="ln386">  string* buf_ptr = nullptr;</a>
<a name="ln387">  if (data) {</a>
<a name="ln388">    auto* context = static_cast&lt;SymbolizationContext*&gt;(data);</a>
<a name="ln389">    if (context-&gt;buf) {</a>
<a name="ln390">      buf_ptr = context-&gt;buf;</a>
<a name="ln391">      buf_ptr-&gt;append(StringPrintf(&quot;Backtrace error: %s (errnum=%d)\n&quot;, msg, errnum));</a>
<a name="ln392">      reported = true;</a>
<a name="ln393">    }</a>
<a name="ln394">  }</a>
<a name="ln395"> </a>
<a name="ln396">  if (!reported) {</a>
<a name="ln397">    // A backup mechanism for error reporting.</a>
<a name="ln398">    fprintf(stderr, &quot;%s called with data=%p, msg=%s, errnum=%d, buf_ptr=%p\n&quot;, __func__,</a>
<a name="ln399">            data, msg, errnum, buf_ptr);</a>
<a name="ln400">  }</a>
<a name="ln401">}</a>
<a name="ln402"> </a>
<a name="ln403">class GlobalBacktraceState {</a>
<a name="ln404"> public:</a>
<a name="ln405">  GlobalBacktraceState() {</a>
<a name="ln406">    bt_state_ = backtrace_create_state(</a>
<a name="ln407">        /* filename */ nullptr,</a>
<a name="ln408">        /* threaded = */ 0,</a>
<a name="ln409">        BacktraceErrorCallback,</a>
<a name="ln410">        /* data */ nullptr);</a>
<a name="ln411"> </a>
<a name="ln412">    // To complete initialization we should call backtrace, otherwise it could fail in case of</a>
<a name="ln413">    // concurrent initialization.</a>
<a name="ln414">    backtrace_full(bt_state_, /* skip = */ 1, DummyCallback,</a>
<a name="ln415">                   BacktraceErrorCallback, nullptr);</a>
<a name="ln416">  }</a>
<a name="ln417"> </a>
<a name="ln418">  backtrace_state* GetState() { return bt_state_; }</a>
<a name="ln419"> </a>
<a name="ln420">  std::mutex* mutex() { return &amp;mutex_; }</a>
<a name="ln421"> </a>
<a name="ln422"> private:</a>
<a name="ln423">  static int DummyCallback(void *const data, const uintptr_t pc,</a>
<a name="ln424">                    const char* const filename, const int lineno,</a>
<a name="ln425">                    const char* const original_function_name) {</a>
<a name="ln426">    return 0;</a>
<a name="ln427">  }</a>
<a name="ln428"> </a>
<a name="ln429">  struct backtrace_state* bt_state_;</a>
<a name="ln430">  std::mutex mutex_;</a>
<a name="ln431">};</a>
<a name="ln432"> </a>
<a name="ln433">int BacktraceFullCallback(void *const data, const uintptr_t pc,</a>
<a name="ln434">                          const char* const filename, const int lineno,</a>
<a name="ln435">                          const char* const original_function_name) {</a>
<a name="ln436">  assert(data != nullptr);</a>
<a name="ln437">  const SymbolizationContext&amp; context = *pointer_cast&lt;SymbolizationContext*&gt;(data);</a>
<a name="ln438">  string* const buf = context.buf;</a>
<a name="ln439">  int demangle_status = 0;</a>
<a name="ln440">  char* const demangled_function_name =</a>
<a name="ln441">      original_function_name != nullptr ?</a>
<a name="ln442">      abi::__cxa_demangle(original_function_name,</a>
<a name="ln443">                          nullptr,  // output_buffer</a>
<a name="ln444">                          nullptr,  // length</a>
<a name="ln445">                          &amp;demangle_status) :</a>
<a name="ln446">      nullptr;</a>
<a name="ln447">  const char* function_name_to_use = original_function_name;</a>
<a name="ln448">  if (original_function_name != nullptr) {</a>
<a name="ln449">    if (demangle_status != kDemangleOk) {</a>
<a name="ln450">      if (demangle_status != kDemangleInvalidMangledName) {</a>
<a name="ln451">        // -2 means the mangled name is not a valid name under the C++ ABI mangling rules.</a>
<a name="ln452">        // This happens when the name is e.g. &quot;main&quot;, so we don't report the error.</a>
<a name="ln453">        StringAppendF(buf, &quot;Error: __cxa_demangle failed for '%s' with error code %d\n&quot;,</a>
<a name="ln454">            original_function_name, demangle_status);</a>
<a name="ln455">      }</a>
<a name="ln456">      // Regardless of the exact reason for demangle failure, we use the original function name</a>
<a name="ln457">      // provided by libbacktrace.</a>
<a name="ln458">    } else if (demangled_function_name != nullptr) {</a>
<a name="ln459">      // If __cxa_demangle returns 0 and a non-null string, we use that instead of the original</a>
<a name="ln460">      // function name.</a>
<a name="ln461">      function_name_to_use = demangled_function_name;</a>
<a name="ln462">    } else {</a>
<a name="ln463">      StringAppendF(buf,</a>
<a name="ln464">          &quot;Error: __cxa_demangle returned zero status but nullptr demangled function for '%s'\n&quot;,</a>
<a name="ln465">          original_function_name);</a>
<a name="ln466">    }</a>
<a name="ln467">  }</a>
<a name="ln468"> </a>
<a name="ln469">  string pretty_function_name;</a>
<a name="ln470">  if (function_name_to_use == nullptr) {</a>
<a name="ln471">    pretty_function_name = kUnknownSymbol;</a>
<a name="ln472">  } else {</a>
<a name="ln473">    // Allocating regexes on the heap so that they would never get deallocated. This is because</a>
<a name="ln474">    // the kernel watchdog thread could still be symbolizing stack traces as global destructors</a>
<a name="ln475">    // are being called.</a>
<a name="ln476">    static const std::regex* kStdColonColonOneRE = new std::regex(&quot;\\bstd::__1::\\b&quot;);</a>
<a name="ln477">    pretty_function_name = std::regex_replace(function_name_to_use, *kStdColonColonOneRE, &quot;std::&quot;);</a>
<a name="ln478"> </a>
<a name="ln479">    static const std::regex* kStringRE = new std::regex(</a>
<a name="ln480">        &quot;\\bstd::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;&quot;);</a>
<a name="ln481">    pretty_function_name = std::regex_replace(pretty_function_name, *kStringRE, &quot;string&quot;);</a>
<a name="ln482"> </a>
<a name="ln483">    static const std::regex* kRemoveStdPrefixRE =</a>
<a name="ln484">        new std::regex(&quot;\\bstd::(string|tuple|shared_ptr|unique_ptr)\\b&quot;);</a>
<a name="ln485">    pretty_function_name = std::regex_replace(pretty_function_name, *kRemoveStdPrefixRE, &quot;$1&quot;);</a>
<a name="ln486">  }</a>
<a name="ln487"> </a>
<a name="ln488">  const bool is_symbol_only_fmt =</a>
<a name="ln489">      context.stack_trace_line_format == StackTraceLineFormat::SYMBOL_ONLY;</a>
<a name="ln490"> </a>
<a name="ln491">  // We have not appended an end-of-line character yet. Let's see if we have file name / line number</a>
<a name="ln492">  // information first. BTW kStackTraceEntryFormat is used both here and in glog-based</a>
<a name="ln493">  // symbolization.</a>
<a name="ln494">  if (filename == nullptr) {</a>
<a name="ln495">    // libbacktrace failed to produce an address. We still need to produce a line of the form:</a>
<a name="ln496">    // &quot;    @     0x7f2d98f9bd87  &quot;</a>
<a name="ln497">    char hex_pc_buf[32];</a>
<a name="ln498">    snprintf(hex_pc_buf, sizeof(hex_pc_buf), &quot;0x%&quot; PRIxPTR, pc);</a>
<a name="ln499">    if (is_symbol_only_fmt) {</a>
<a name="ln500">      // At least print out the hex address, otherwise we'd end up with an empty string.</a>
<a name="ln501">      *buf += hex_pc_buf;</a>
<a name="ln502">    } else {</a>
<a name="ln503">      StringAppendF(buf, &quot;    @ %18s &quot;, hex_pc_buf);</a>
<a name="ln504">    }</a>
<a name="ln505">  } else {</a>
<a name="ln506">    const string frame_without_file_line =</a>
<a name="ln507">        is_symbol_only_fmt ? pretty_function_name</a>
<a name="ln508">                           : StringPrintf(</a>
<a name="ln509">                               kStackTraceEntryFormat, kPrintfPointerFieldWidth,</a>
<a name="ln510">                               reinterpret_cast&lt;void*&gt;(pc), pretty_function_name.c_str());</a>
<a name="ln511"> </a>
<a name="ln512">    // Got filename and line number from libbacktrace! No need to filter the output through</a>
<a name="ln513">    // addr2line, etc.</a>
<a name="ln514">    switch (context.stack_trace_line_format) {</a>
<a name="ln515">      case StackTraceLineFormat::CLION_CLICKABLE: {</a>
<a name="ln516">        const string file_line_prefix = StringPrintf(&quot;%s:%d: &quot;, filename, lineno);</a>
<a name="ln517">        StringAppendF(buf, &quot;%-100s&quot;, file_line_prefix.c_str());</a>
<a name="ln518">        *buf += frame_without_file_line;</a>
<a name="ln519">        break;</a>
<a name="ln520">      }</a>
<a name="ln521">      case StackTraceLineFormat::SHORT: {</a>
<a name="ln522">        *buf += frame_without_file_line;</a>
<a name="ln523">        StringAppendF(buf, &quot; (%s:%d)&quot;, NormalizeSourceFilePath(filename), lineno);</a>
<a name="ln524">        break;</a>
<a name="ln525">      }</a>
<a name="ln526">      case StackTraceLineFormat::SYMBOL_ONLY: {</a>
<a name="ln527">        *buf += frame_without_file_line;</a>
<a name="ln528">        StringAppendF(buf, &quot; (%s:%d)&quot;, NormalizeSourceFilePath(filename), lineno);</a>
<a name="ln529">        break;</a>
<a name="ln530">      }</a>
<a name="ln531">    }</a>
<a name="ln532">  }</a>
<a name="ln533"> </a>
<a name="ln534">  buf-&gt;push_back('\n');</a>
<a name="ln535"> </a>
<a name="ln536">  // No need to check for nullptr, free is a no-op in that case.</a>
<a name="ln537">  free(demangled_function_name);</a>
<a name="ln538">  return 0;</a>
<a name="ln539">}</a>
<a name="ln540">#endif  // __linux__</a>
<a name="ln541"> </a>
<a name="ln542">bool IsDoubleUnderscoredAndInList(</a>
<a name="ln543">    const char* symbol, const std::initializer_list&lt;const char*&gt;&amp; list) {</a>
<a name="ln544">  if (symbol[0] != '_' || symbol[1] != '_') {</a>
<a name="ln545">    return false;</a>
<a name="ln546">  }</a>
<a name="ln547">  for (const auto* idle_function : list) {</a>
<a name="ln548">    if (!strcmp(symbol, idle_function)) {</a>
<a name="ln549">      return true;</a>
<a name="ln550">    }</a>
<a name="ln551">  }</a>
<a name="ln552">  return false;</a>
<a name="ln553">}</a>
<a name="ln554"> </a>
<a name="ln555">bool IsIdle(const char* symbol) {</a>
<a name="ln556">  return IsDoubleUnderscoredAndInList(symbol,</a>
<a name="ln557">                                      { &quot;__GI_epoll_wait&quot;,</a>
<a name="ln558">                                        &quot;__pthread_cond_timedwait&quot;,</a>
<a name="ln559">                                        &quot;__pthread_cond_wait&quot; });</a>
<a name="ln560">}</a>
<a name="ln561"> </a>
<a name="ln562">bool IsWaiting(const char* symbol) {</a>
<a name="ln563">  return IsDoubleUnderscoredAndInList(symbol,</a>
<a name="ln564">                                      { &quot;__GI___pthread_mutex_lock&quot; });</a>
<a name="ln565">}</a>
<a name="ln566"> </a>
<a name="ln567">}  // anonymous namespace</a>
<a name="ln568"> </a>
<a name="ln569">Status SetStackTraceSignal(int signum) {</a>
<a name="ln570">  std::lock_guard&lt;decltype(thread_stack_helper.mutex)&gt; lock(thread_stack_helper.mutex);</a>
<a name="ln571">  if (!InitSignalHandlerUnlocked(signum)) {</a>
<a name="ln572">    return STATUS(InvalidArgument, &quot;Unable to install signal handler&quot;);</a>
<a name="ln573">  }</a>
<a name="ln574">  return Status::OK();</a>
<a name="ln575">}</a>
<a name="ln576"> </a>
<a name="ln577">Result&lt;StackTrace&gt; ThreadStack(ThreadIdForStack tid) {</a>
<a name="ln578">  return ThreadStacks({tid}).front();</a>
<a name="ln579">}</a>
<a name="ln580"> </a>
<a name="ln581">std::vector&lt;Result&lt;StackTrace&gt;&gt; ThreadStacks(const std::vector&lt;ThreadIdForStack&gt;&amp; tids) {</a>
<a name="ln582">  static const Status status = STATUS(</a>
<a name="ln583">      RuntimeError, &quot;Thread did not respond: maybe it is blocking signals&quot;);</a>
<a name="ln584"> </a>
<a name="ln585">  std::vector&lt;Result&lt;StackTrace&gt;&gt; result(tids.size(), status);</a>
<a name="ln586">  std::lock_guard&lt;std::mutex&gt; execution_lock(thread_stack_helper.mutex);</a>
<a name="ln587"> </a>
<a name="ln588">  // Ensure that our signal handler is installed. We don't need any fancy GoogleOnce here</a>
<a name="ln589">  // because of the mutex above.</a>
<a name="ln590">  if (!InitSignalHandlerUnlocked(g_stack_trace_signum)) {</a>
<a name="ln591">    static const Status status = STATUS(</a>
<a name="ln592">        RuntimeError, &quot;Unable to take thread stack: signal handler unavailable&quot;);</a>
<a name="ln593">    std::fill_n(result.begin(), tids.size(), status);</a>
<a name="ln594">    return result;</a>
<a name="ln595">  }</a>
<a name="ln596"> </a>
<a name="ln597">  thread_stack_helper.left_to_collect.store(tids.size(), std::memory_order_release);</a>
<a name="ln598">  thread_stack_helper.SetNumEntries(tids.size());</a>
<a name="ln599">  thread_stack_helper.completion_flag.Reset();</a>
<a name="ln600"> </a>
<a name="ln601">  for (size_t i = 0; i != tids.size(); ++i) {</a>
<a name="ln602">    // We use the raw syscall here instead of kill() to ensure that we don't accidentally</a>
<a name="ln603">    // send a signal to some other process in the case that the thread has exited and</a>
<a name="ln604">    // the TID been recycled.</a>
<a name="ln605">#if defined(__linux__)</a>
<a name="ln606">    int res = syscall(SYS_tgkill, getpid(), tids[i], g_stack_trace_signum);</a>
<a name="ln607">#else</a>
<a name="ln608">    int res = pthread_kill(tids[i], g_stack_trace_signum);</a>
<a name="ln609">#endif</a>
<a name="ln610">    if (res != 0) {</a>
<a name="ln611">      static const Status status = STATUS(</a>
<a name="ln612">          RuntimeError, &quot;Unable to deliver signal: process may have exited&quot;);</a>
<a name="ln613">      result[i] = status;</a>
<a name="ln614">      thread_stack_helper.left_to_collect.fetch_sub(1, std::memory_order_acq_rel);</a>
<a name="ln615">    }</a>
<a name="ln616">  }</a>
<a name="ln617"> </a>
<a name="ln618">  thread_stack_helper.StoreResult(tids, &amp;result);</a>
<a name="ln619"> </a>
<a name="ln620">  return result;</a>
<a name="ln621">}</a>
<a name="ln622"> </a>
<a name="ln623">std::string DumpThreadStack(ThreadIdForStack tid) {</a>
<a name="ln624">  auto stack_trace = ThreadStack(tid);</a>
<a name="ln625">  if (!stack_trace.ok()) {</a>
<a name="ln626">    return stack_trace.status().message().ToBuffer();</a>
<a name="ln627">  }</a>
<a name="ln628">  return stack_trace-&gt;Symbolize();</a>
<a name="ln629">}</a>
<a name="ln630"> </a>
<a name="ln631">Status ListThreads(std::vector&lt;pid_t&gt; *tids) {</a>
<a name="ln632">#if defined(__linux__)</a>
<a name="ln633">  DIR *dir = opendir(&quot;/proc/self/task/&quot;);</a>
<a name="ln634">  if (dir == NULL) {</a>
<a name="ln635">    return STATUS(IOError, &quot;failed to open task dir&quot;, Errno(errno));</a>
<a name="ln636">  }</a>
<a name="ln637">  struct dirent *d;</a>
<a name="ln638">  while ((d = readdir(dir)) != NULL) {</a>
<a name="ln639">    if (d-&gt;d_name[0] != '.') {</a>
<a name="ln640">      uint32_t tid;</a>
<a name="ln641">      if (!safe_strtou32(d-&gt;d_name, &amp;tid)) {</a>
<a name="ln642">        LOG(WARNING) &lt;&lt; &quot;bad tid found in procfs: &quot; &lt;&lt; d-&gt;d_name;</a>
<a name="ln643">        continue;</a>
<a name="ln644">      }</a>
<a name="ln645">      tids-&gt;push_back(tid);</a>
<a name="ln646">    }</a>
<a name="ln647">  }</a>
<a name="ln648">  closedir(dir);</a>
<a name="ln649">#endif // defined(__linux__)</a>
<a name="ln650">  return Status::OK();</a>
<a name="ln651">}</a>
<a name="ln652"> </a>
<a name="ln653">std::string GetStackTrace(StackTraceLineFormat stack_trace_line_format,</a>
<a name="ln654">                          int num_top_frames_to_skip) {</a>
<a name="ln655">  std::string buf;</a>
<a name="ln656">#ifdef __linux__</a>
<a name="ln657">  if (FLAGS_use_libbacktrace) {</a>
<a name="ln658">    SymbolizationContext context;</a>
<a name="ln659">    context.buf = &amp;buf;</a>
<a name="ln660">    context.stack_trace_line_format = stack_trace_line_format;</a>
<a name="ln661"> </a>
<a name="ln662">    // Use libbacktrace on Linux because that gives us file names and line numbers.</a>
<a name="ln663">    auto* global_backtrace_state = Singleton&lt;GlobalBacktraceState&gt;::get();</a>
<a name="ln664">    struct backtrace_state* const backtrace_state = global_backtrace_state-&gt;GetState();</a>
<a name="ln665"> </a>
<a name="ln666">    // Avoid multi-threaded access to libbacktrace which causes high memory consumption.</a>
<a name="ln667">    std::lock_guard&lt;std::mutex&gt; l(*global_backtrace_state-&gt;mutex());</a>
<a name="ln668"> </a>
<a name="ln669">    // TODO: https://yugabyte.atlassian.net/browse/ENG-4729</a>
<a name="ln670"> </a>
<a name="ln671">    const int backtrace_full_rv = backtrace_full(</a>
<a name="ln672">        backtrace_state, /* skip = */ num_top_frames_to_skip + 1, BacktraceFullCallback,</a>
<a name="ln673">        BacktraceErrorCallback, &amp;context);</a>
<a name="ln674">    if (backtrace_full_rv != 0) {</a>
<a name="ln675">      StringAppendF(&amp;buf, &quot;Error: backtrace_full return value is %d&quot;, backtrace_full_rv);</a>
<a name="ln676">    }</a>
<a name="ln677">    return buf;</a>
<a name="ln678">  }</a>
<a name="ln679">#endif</a>
<a name="ln680">  google::glog_internal_namespace_::DumpStackTraceToString(&amp;buf);</a>
<a name="ln681">  return buf;</a>
<a name="ln682">}</a>
<a name="ln683"> </a>
<a name="ln684">std::string GetStackTraceHex() {</a>
<a name="ln685">  char buf[1024];</a>
<a name="ln686">  HexStackTraceToString(buf, 1024);</a>
<a name="ln687">  return std::string(buf);</a>
<a name="ln688">}</a>
<a name="ln689"> </a>
<a name="ln690">void HexStackTraceToString(char* buf, size_t size) {</a>
<a name="ln691">  StackTrace trace;</a>
<a name="ln692">  trace.Collect(1);</a>
<a name="ln693">  trace.StringifyToHex(buf, size);</a>
<a name="ln694">}</a>
<a name="ln695"> </a>
<a name="ln696">string GetLogFormatStackTraceHex() {</a>
<a name="ln697">  StackTrace trace;</a>
<a name="ln698">  trace.Collect(1);</a>
<a name="ln699">  return trace.ToLogFormatHexString();</a>
<a name="ln700">}</a>
<a name="ln701"> </a>
<a name="ln702">void StackTrace::Collect(int skip_frames) {</a>
<a name="ln703">#if THREAD_SANITIZER || ADDRESS_SANITIZER</a>
<a name="ln704">  num_frames_ = google::GetStackTrace(frames_, arraysize(frames_), skip_frames);</a>
<a name="ln705">#else</a>
<a name="ln706">  int max_frames = skip_frames + arraysize(frames_);</a>
<a name="ln707">  void** buffer = static_cast&lt;void**&gt;(alloca((max_frames) * sizeof(void*)));</a>
<a name="ln708">  num_frames_ = backtrace(buffer, max_frames);</a>
<a name="ln709">  if (num_frames_ &gt; skip_frames) {</a>
<a name="ln710">    num_frames_ -= skip_frames;</a>
<a name="ln711">    memmove(frames_, buffer + skip_frames, num_frames_ * sizeof(void*));</a>
<a name="ln712">  } else {</a>
<a name="ln713">    num_frames_ = 0;</a>
<a name="ln714">  }</a>
<a name="ln715">#endif</a>
<a name="ln716">}</a>
<a name="ln717"> </a>
<a name="ln718">void StackTrace::StringifyToHex(char* buf, size_t size, int flags) const {</a>
<a name="ln719">  char* dst = buf;</a>
<a name="ln720"> </a>
<a name="ln721">  // Reserve kHexEntryLength for the first iteration of the loop, 1 byte for a</a>
<a name="ln722">  // space (which we may not need if there's just one frame), and 1 for a nul</a>
<a name="ln723">  // terminator.</a>
<a name="ln724">  char* limit = dst + size - kHexEntryLength - 2;</a>
<a name="ln725">  for (int i = 0; i &lt; num_frames_ &amp;&amp; dst &lt; limit; i++) {</a>
<a name="ln726">    if (i != 0) {</a>
<a name="ln727">      *dst++ = ' ';</a>
<a name="ln728">    }</a>
<a name="ln729">    // See note in Symbolize() below about why we subtract 1 from each address here.</a>
<a name="ln730">    uintptr_t addr = reinterpret_cast&lt;uintptr_t&gt;(frames_[i]);</a>
<a name="ln731">    if (!(flags &amp; NO_FIX_CALLER_ADDRESSES)) {</a>
<a name="ln732">      addr--;</a>
<a name="ln733">    }</a>
<a name="ln734">    FastHex64ToBuffer(addr, dst);</a>
<a name="ln735">    dst += kHexEntryLength;</a>
<a name="ln736">  }</a>
<a name="ln737">  *dst = '\0';</a>
<a name="ln738">}</a>
<a name="ln739"> </a>
<a name="ln740">string StackTrace::ToHexString(int flags) const {</a>
<a name="ln741">  // Each frame requires kHexEntryLength, plus a space</a>
<a name="ln742">  // We also need one more byte at the end for '\0'</a>
<a name="ln743">  char buf[kMaxFrames * (kHexEntryLength + 1) + 1];</a>
<a name="ln744">  StringifyToHex(buf, arraysize(buf), flags);</a>
<a name="ln745">  return string(buf);</a>
<a name="ln746">}</a>
<a name="ln747"> </a>
<a name="ln748">// If group is specified it is filled with value corresponding to this stack trace.</a>
<a name="ln749">void SymbolizeAddress(</a>
<a name="ln750">    const StackTraceLineFormat stack_trace_line_format,</a>
<a name="ln751">    void* pc,</a>
<a name="ln752">    string* buf,</a>
<a name="ln753">    StackTraceGroup* group = nullptr</a>
<a name="ln754">#ifdef __linux__</a>
<a name="ln755">    , GlobalBacktraceState* global_backtrace_state = nullptr</a>
<a name="ln756">#endif</a>
<a name="ln757">    ) {</a>
<a name="ln758">  // The return address 'pc' on the stack is the address of the instruction</a>
<a name="ln759">  // following the 'call' instruction. In the case of calling a function annotated</a>
<a name="ln760">  // 'noreturn', this address may actually be the first instruction of the next</a>
<a name="ln761">  // function, because the function we care about ends with the 'call'.</a>
<a name="ln762">  // So, we subtract 1 from 'pc' so that we're pointing at the 'call' instead</a>
<a name="ln763">  // of the return address.</a>
<a name="ln764">  //</a>
<a name="ln765">  // For example, compiling a C program with -O2 that simply calls 'abort()' yields</a>
<a name="ln766">  // the following disassembly:</a>
<a name="ln767">  //     Disassembly of section .text:</a>
<a name="ln768">  //</a>
<a name="ln769">  //     0000000000400440 &lt;main&gt;:</a>
<a name="ln770">  //       400440:   48 83 ec 08             sub    $0x8,%rsp</a>
<a name="ln771">  //       400444:   e8 c7 ff ff ff          callq  400410 &lt;abort@plt&gt;</a>
<a name="ln772">  //</a>
<a name="ln773">  //     0000000000400449 &lt;_start&gt;:</a>
<a name="ln774">  //       400449:   31 ed                   xor    %ebp,%ebp</a>
<a name="ln775">  //       ...</a>
<a name="ln776">  //</a>
<a name="ln777">  // If we were to take a stack trace while inside 'abort', the return pointer</a>
<a name="ln778">  // on the stack would be 0x400449 (the first instruction of '_start'). By subtracting</a>
<a name="ln779">  // 1, we end up with 0x400448, which is still within 'main'.</a>
<a name="ln780">  //</a>
<a name="ln781">  // This also ensures that we point at the correct line number when using addr2line</a>
<a name="ln782">  // on logged stacks.</a>
<a name="ln783">  pc = reinterpret_cast&lt;void*&gt;(reinterpret_cast&lt;size_t&gt;(pc) - 1);</a>
<a name="ln784">#ifdef __linux__</a>
<a name="ln785">  if (FLAGS_use_libbacktrace) {</a>
<a name="ln786">    if (!global_backtrace_state) {</a>
<a name="ln787">      global_backtrace_state = Singleton&lt;GlobalBacktraceState&gt;::get();</a>
<a name="ln788">    }</a>
<a name="ln789">    struct backtrace_state* const backtrace_state = global_backtrace_state-&gt;GetState();</a>
<a name="ln790"> </a>
<a name="ln791">    // Avoid multi-threaded access to libbacktrace which causes high memory consumption.</a>
<a name="ln792">    std::lock_guard&lt;std::mutex&gt; l(*global_backtrace_state-&gt;mutex());</a>
<a name="ln793"> </a>
<a name="ln794">    SymbolizationContext context;</a>
<a name="ln795">    context.stack_trace_line_format = stack_trace_line_format;</a>
<a name="ln796">    context.buf = buf;</a>
<a name="ln797">    backtrace_pcinfo(backtrace_state, reinterpret_cast&lt;uintptr_t&gt;(pc),</a>
<a name="ln798">                    BacktraceFullCallback, BacktraceErrorCallback, &amp;context);</a>
<a name="ln799">    return;</a>
<a name="ln800">  }</a>
<a name="ln801">#endif</a>
<a name="ln802">  char tmp[1024];</a>
<a name="ln803">  const char* symbol = kUnknownSymbol;</a>
<a name="ln804"> </a>
<a name="ln805">  if (google::Symbolize(pc, tmp, sizeof(tmp))) {</a>
<a name="ln806">    symbol = tmp;</a>
<a name="ln807">    if (group) {</a>
<a name="ln808">      if (IsWaiting(symbol)) {</a>
<a name="ln809">        *group = StackTraceGroup::kWaiting;</a>
<a name="ln810">      } else if (IsIdle(symbol)) {</a>
<a name="ln811">        *group = StackTraceGroup::kIdle;</a>
<a name="ln812">      }</a>
<a name="ln813">    }</a>
<a name="ln814">  }</a>
<a name="ln815"> </a>
<a name="ln816">  StringAppendF(buf, kStackTraceEntryFormat, kPrintfPointerFieldWidth, pc, symbol);</a>
<a name="ln817">  // We are appending the end-of-line character separately because we want to reuse the same</a>
<a name="ln818">  // format string for libbacktrace callback and glog-based symbolization, and we have an extra</a>
<a name="ln819">  // file name / line number component before the end-of-line in the libbacktrace case.</a>
<a name="ln820">  buf-&gt;push_back('\n');</a>
<a name="ln821">}</a>
<a name="ln822"> </a>
<a name="ln823">// Symbolization function borrowed from glog and modified to use libbacktrace on Linux.</a>
<a name="ln824">string StackTrace::Symbolize(</a>
<a name="ln825">    const StackTraceLineFormat stack_trace_line_format, StackTraceGroup* group) const {</a>
<a name="ln826">  string buf;</a>
<a name="ln827">#ifdef __linux__</a>
<a name="ln828">  // Use libbacktrace for symbolization.</a>
<a name="ln829">  auto* global_backtrace_state =</a>
<a name="ln830">      FLAGS_use_libbacktrace ? Singleton&lt;GlobalBacktraceState&gt;::get() : nullptr;</a>
<a name="ln831">#endif</a>
<a name="ln832"> </a>
<a name="ln833">  if (group) {</a>
<a name="ln834">    *group = StackTraceGroup::kActive;</a>
<a name="ln835">  }</a>
<a name="ln836"> </a>
<a name="ln837">  for (int i = 0; i &lt; num_frames_; i++) {</a>
<a name="ln838">    void* const pc = frames_[i];</a>
<a name="ln839"> </a>
<a name="ln840">    SymbolizeAddress(stack_trace_line_format, pc, &amp;buf, group</a>
<a name="ln841">#ifdef __linux__</a>
<a name="ln842">        , global_backtrace_state</a>
<a name="ln843">#endif</a>
<a name="ln844">        );</a>
<a name="ln845">  }</a>
<a name="ln846"> </a>
<a name="ln847">  return buf;</a>
<a name="ln848">}</a>
<a name="ln849"> </a>
<a name="ln850">string StackTrace::ToLogFormatHexString() const {</a>
<a name="ln851">  string buf;</a>
<a name="ln852">  for (int i = 0; i &lt; num_frames_; i++) {</a>
<a name="ln853">    void* pc = frames_[i];</a>
<a name="ln854">    StringAppendF(&amp;buf, &quot;    @ %*p\n&quot;, kPrintfPointerFieldWidth, pc);</a>
<a name="ln855">  }</a>
<a name="ln856">  return buf;</a>
<a name="ln857">}</a>
<a name="ln858"> </a>
<a name="ln859">uint64_t StackTrace::HashCode() const {</a>
<a name="ln860">  return util_hash::CityHash64(reinterpret_cast&lt;const char*&gt;(frames_),</a>
<a name="ln861">                               sizeof(frames_[0]) * num_frames_);</a>
<a name="ln862">}</a>
<a name="ln863"> </a>
<a name="ln864">namespace {</a>
<a name="ln865">#ifdef __linux__</a>
<a name="ln866">int DynamcLibraryListCallback(struct dl_phdr_info *info, size_t size, void *data) {</a>
<a name="ln867">  if (*info-&gt;dlpi_name != '\0') {</a>
<a name="ln868">    // We can't use LOG(...) yet because Google Logging might not be initialized.</a>
<a name="ln869">    // It is also important to write the entire line at once so that it is less likely to be</a>
<a name="ln870">    // interleaved with pieces of similar lines from other processes.</a>
<a name="ln871">    std::cerr &lt;&lt; StringPrintf(</a>
<a name="ln872">        &quot;Shared library '%s' loaded at address 0x%&quot; PRIx64 &quot;\n&quot;, info-&gt;dlpi_name, info-&gt;dlpi_addr);</a>
<a name="ln873">  }</a>
<a name="ln874">  return 0;</a>
<a name="ln875">}</a>
<a name="ln876">#endif</a>
<a name="ln877"> </a>
<a name="ln878">void PrintLoadedDynamicLibraries() {</a>
<a name="ln879">#ifdef __linux__</a>
<a name="ln880">  // Supported on Linux only.</a>
<a name="ln881">  dl_iterate_phdr(DynamcLibraryListCallback, nullptr);</a>
<a name="ln882">#endif</a>
<a name="ln883">}</a>
<a name="ln884"> </a>
<a name="ln885">bool PrintLoadedDynamicLibrariesOnceHelper() {</a>
<a name="ln886">  const char* list_dl_env_var = std::getenv(&quot;YB_LIST_LOADED_DYNAMIC_LIBS&quot;);</a>
<a name="ln887">  if (list_dl_env_var != nullptr &amp;&amp; *list_dl_env_var != '\0') {</a>
<a name="ln888">    PrintLoadedDynamicLibraries();</a>
<a name="ln889">  }</a>
<a name="ln890">  return true;</a>
<a name="ln891">}</a>
<a name="ln892"> </a>
<a name="ln893">} // anonymous namespace</a>
<a name="ln894"> </a>
<a name="ln895">string SymbolizeAddress(void *pc, const StackTraceLineFormat stack_trace_line_format) {</a>
<a name="ln896">  string s;</a>
<a name="ln897">  SymbolizeAddress(stack_trace_line_format, pc, &amp;s);</a>
<a name="ln898">  return s;</a>
<a name="ln899">}</a>
<a name="ln900"> </a>
<a name="ln901">// ------------------------------------------------------------------------------------------------</a>
<a name="ln902">// Tracing function calls</a>
<a name="ln903">// ------------------------------------------------------------------------------------------------</a>
<a name="ln904"> </a>
<a name="ln905">namespace {</a>
<a name="ln906"> </a>
<a name="ln907">const char* GetEnvVar(const char* name) {</a>
<a name="ln908">  const char* value = getenv(name);</a>
<a name="ln909">  if (value &amp;&amp; strlen(value) == 0) {</a>
<a name="ln910">    // Treat empty values as undefined.</a>
<a name="ln911">    return nullptr;</a>
<a name="ln912">  }</a>
<a name="ln913">  return value;</a>
<a name="ln914">}</a>
<a name="ln915"> </a>
<a name="ln916">struct FunctionTraceConf {</a>
<a name="ln917"> </a>
<a name="ln918">  bool enabled = false;</a>
<a name="ln919"> </a>
<a name="ln920">  // Auto-blacklist functions that have done more than this number of calls per second.</a>
<a name="ln921">  int32_t blacklist_calls_per_sec = 1000;</a>
<a name="ln922"> </a>
<a name="ln923">  std::unordered_set&lt;std::string&gt; fn_name_blacklist;</a>
<a name="ln924"> </a>
<a name="ln925">  FunctionTraceConf() {</a>
<a name="ln926">    enabled = GetEnvVar(&quot;YB_FN_TRACE&quot;);</a>
<a name="ln927">    if (!enabled) {</a>
<a name="ln928">      return;</a>
<a name="ln929">    }</a>
<a name="ln930">    auto blacklist_calls_per_sec_str = GetEnvVar(&quot;YB_FN_TRACE_BLACKLIST_CALLS_PER_SEC&quot;);</a>
<a name="ln931">    if (blacklist_calls_per_sec_str) {</a>
<a name="ln932">      blacklist_calls_per_sec = atoi32(blacklist_calls_per_sec_str);</a>
<a name="ln933">    }</a>
<a name="ln934"> </a>
<a name="ln935">    static const char* kBlacklistFileEnvVarName = &quot;YB_FN_TRACE_BLACKLIST_FILE&quot;;</a>
<a name="ln936">    auto blacklist_file_path = GetEnvVar(kBlacklistFileEnvVarName);</a>
<a name="ln937">    if (blacklist_file_path) {</a>
<a name="ln938">      LOG(INFO) &lt;&lt; &quot;Reading blacklist from &quot; &lt;&lt; blacklist_file_path;</a>
<a name="ln939">      std::ifstream blacklist_file(blacklist_file_path);</a>
<a name="ln940">      if (!blacklist_file) {</a>
<a name="ln941">        LOG(FATAL) &lt;&lt; &quot;Could not read function trace blacklist file from '&quot;</a>
<a name="ln942">                   &lt;&lt; blacklist_file_path &lt;&lt; &quot;' as specified by &quot; &lt;&lt; kBlacklistFileEnvVarName;</a>
<a name="ln943">      }</a>
<a name="ln944">      string fn_name;</a>
<a name="ln945">      while (std::getline(blacklist_file, fn_name)) {</a>
<a name="ln946">        fn_name = util::TrimStr(fn_name);</a>
<a name="ln947">        if (fn_name.size()) {</a>
<a name="ln948">          fn_name_blacklist.insert(fn_name);</a>
<a name="ln949">        }</a>
<a name="ln950">      }</a>
<a name="ln951"> </a>
<a name="ln952">      if (blacklist_file.bad()) {</a>
<a name="ln953">        LOG(FATAL) &lt;&lt; &quot;Error reading blacklist file '&quot; &lt;&lt; blacklist_file_path &lt;&lt; &quot;': &quot;</a>
<a name="ln954">                   &lt;&lt; strerror(errno);</a>
<a name="ln955">      }</a>
<a name="ln956">    }</a>
<a name="ln957">  }</a>
<a name="ln958">};</a>
<a name="ln959"> </a>
<a name="ln960">const FunctionTraceConf&amp; GetFunctionTraceConf() {</a>
<a name="ln961">  static const FunctionTraceConf conf;</a>
<a name="ln962">  return conf;</a>
<a name="ln963">}</a>
<a name="ln964"> </a>
<a name="ln965">enum class EventType : uint8_t {</a>
<a name="ln966">  kEnter,</a>
<a name="ln967">  kLeave</a>
<a name="ln968">};</a>
<a name="ln969"> </a>
<a name="ln970">struct FunctionTraceEvent {</a>
<a name="ln971">  EventType event_type;</a>
<a name="ln972">  void* this_fn;</a>
<a name="ln973">  void* call_site;</a>
<a name="ln974">  int64_t thread_id;</a>
<a name="ln975">  CoarseMonoClock::time_point time;</a>
<a name="ln976"> </a>
<a name="ln977">  FunctionTraceEvent(</a>
<a name="ln978">      EventType type_,</a>
<a name="ln979">      void* this_fn_,</a>
<a name="ln980">      void* call_site_)</a>
<a name="ln981">      : event_type(type_),</a>
<a name="ln982">        this_fn(this_fn_),</a>
<a name="ln983">        call_site(call_site_),</a>
<a name="ln984">        thread_id(Thread::CurrentThreadId()),</a>
<a name="ln985">        time(CoarseMonoClock::Now()) {</a>
<a name="ln986">  }</a>
<a name="ln987">};</a>
<a name="ln988"> </a>
<a name="ln989">class FunctionTracer {</a>
<a name="ln990"> public:</a>
<a name="ln991">  FunctionTracer() {</a>
<a name="ln992">  }</a>
<a name="ln993"> </a>
<a name="ln994">  void RecordEvent(EventType event_type, void* this_fn, void* call_site) {</a>
<a name="ln995">    if (blacklisted_fns_.count(this_fn)) {</a>
<a name="ln996">      return;</a>
<a name="ln997">    }</a>
<a name="ln998">    const auto&amp; conf = GetFunctionTraceConf();</a>
<a name="ln999"> </a>
<a name="ln1000">    FunctionTraceEvent event(event_type, this_fn, call_site);</a>
<a name="ln1001">    auto&amp; time_queue = func_event_times_[this_fn];</a>
<a name="ln1002">    while (!time_queue.empty() &amp;&amp; time_queue.back() - time_queue.front() &gt; 1000ms) {</a>
<a name="ln1003">      time_queue.pop();</a>
<a name="ln1004">    }</a>
<a name="ln1005">    time_queue.push(event.time);</a>
<a name="ln1006">    if (conf.blacklist_calls_per_sec &gt; 0 &amp;&amp;</a>
<a name="ln1007">        time_queue.size() &gt;= conf.blacklist_calls_per_sec) {</a>
<a name="ln1008">      std::cerr &lt;&lt; &quot;Auto-blacklisting &quot; &lt;&lt; Symbolize(this_fn) &lt;&lt; &quot;: repeated &quot;</a>
<a name="ln1009">                &lt;&lt; time_queue.size() &lt;&lt; &quot; times per sec&quot; &lt;&lt; std::endl;</a>
<a name="ln1010">      blacklisted_fns_.insert(this_fn);</a>
<a name="ln1011">      func_event_times_.erase(this_fn);</a>
<a name="ln1012">      return;</a>
<a name="ln1013">    }</a>
<a name="ln1014">    const string&amp; symbol = Symbolize(event.this_fn);</a>
<a name="ln1015">    if (!conf.fn_name_blacklist.empty()) {</a>
<a name="ln1016">      // User specified a file listing functions that should not be traced. Match the symbolized</a>
<a name="ln1017">      // function name to that file.</a>
<a name="ln1018">      const char* symbol_str = symbol.c_str();</a>
<a name="ln1019">      const char* space_ptr = strchr(symbol_str, ' ');</a>
<a name="ln1020">      if (conf.fn_name_blacklist.count(space_ptr ? std::string(symbol_str, space_ptr)</a>
<a name="ln1021">                                                 : symbol)) {</a>
<a name="ln1022">        // Remember to avoid tracing this function pointer from now on.</a>
<a name="ln1023">        blacklisted_fns_.insert(event.this_fn);</a>
<a name="ln1024">        return;</a>
<a name="ln1025">      }</a>
<a name="ln1026">    }</a>
<a name="ln1027">    const char* event_type_str = event.event_type == EventType::kEnter ? &quot;-&gt;&quot; : &quot;&lt;-&quot;;</a>
<a name="ln1028">    if (!first_event_) {</a>
<a name="ln1029">      auto delay_ms = ToMilliseconds(event.time - last_event_time_);</a>
<a name="ln1030">      if (delay_ms &gt; 1000) {</a>
<a name="ln1031">        std::ostringstream ss;</a>
<a name="ln1032">        ss &lt;&lt; &quot;\n&quot; &lt;&lt; std::string(80, '-') &lt;&lt; &quot;\n&quot;;</a>
<a name="ln1033">        ss &lt;&lt; &quot;No events for &quot; &lt;&lt; delay_ms &lt;&lt; &quot; ms (thread id: &quot; &lt;&lt; event.thread_id &lt;&lt; &quot;)&quot;;</a>
<a name="ln1034">        ss &lt;&lt; &quot;\n&quot; &lt;&lt; std::string(80, '-') &lt;&lt; &quot;\n&quot;;</a>
<a name="ln1035">        std::cout &lt;&lt; ss.str() &lt;&lt; std::endl;</a>
<a name="ln1036">      }</a>
<a name="ln1037">      last_event_time_ = event.time;</a>
<a name="ln1038">    }</a>
<a name="ln1039">    first_event_ = false;</a>
<a name="ln1040">    std::ostringstream ss;</a>
<a name="ln1041">    ss &lt;&lt; ToMicroseconds(event.time.time_since_epoch())</a>
<a name="ln1042">       &lt;&lt; &quot; &quot; &lt;&lt; event.thread_id &lt;&lt; &quot; &quot; &lt;&lt; event_type_str &lt;&lt; &quot; &quot; &lt;&lt; symbol</a>
<a name="ln1043">       &lt;&lt; &quot;, called from: &quot; &lt;&lt; Symbolize(event.call_site);</a>
<a name="ln1044">    std::cerr &lt;&lt; ss.str() &lt;&lt; std::endl;</a>
<a name="ln1045">  }</a>
<a name="ln1046"> </a>
<a name="ln1047"> private:</a>
<a name="ln1048">  const std::string&amp; Symbolize(void* pc) {</a>
<a name="ln1049">    {</a>
<a name="ln1050">      auto iter = symbol_cache_.find(pc);</a>
<a name="ln1051">      if (iter != symbol_cache_.end()) {</a>
<a name="ln1052">        return iter-&gt;second;</a>
<a name="ln1053">      }</a>
<a name="ln1054">    }</a>
<a name="ln1055">    string buf;</a>
<a name="ln1056">    SymbolizeAddress(StackTraceLineFormat::SYMBOL_ONLY, pc, &amp;buf);</a>
<a name="ln1057">    if (!buf.empty() &amp;&amp; buf.back() == '\n') {</a>
<a name="ln1058">      buf.pop_back();</a>
<a name="ln1059">    }</a>
<a name="ln1060">    return symbol_cache_.emplace(pc, buf).first-&gt;second;</a>
<a name="ln1061">  }</a>
<a name="ln1062"> </a>
<a name="ln1063">  std::unordered_map&lt;void*, std::queue&lt;CoarseMonoClock::time_point&gt;&gt; func_event_times_;</a>
<a name="ln1064">  std::unordered_set&lt;void*&gt; blacklisted_fns_;</a>
<a name="ln1065">  CoarseMonoClock::time_point last_event_time_;</a>
<a name="ln1066">  bool first_event_ = true;</a>
<a name="ln1067"> </a>
<a name="ln1068">  std::unordered_map&lt;void*, std::string&gt; symbol_cache_;</a>
<a name="ln1069">};</a>
<a name="ln1070"> </a>
<a name="ln1071">FunctionTracer&amp; GetFunctionTracer() {</a>
<a name="ln1072">  static FunctionTracer function_tracer;</a>
<a name="ln1073">  return function_tracer;</a>
<a name="ln1074">}</a>
<a name="ln1075"> </a>
<a name="ln1076">} // anonymous namespace</a>
<a name="ln1077"> </a>
<a name="ln1078">// List the load addresses of dynamic libraries once on process startup if required.</a>
<a name="ln1079">const bool  __attribute__((unused)) kPrintedLoadedDynamicLibraries =</a>
<a name="ln1080">    PrintLoadedDynamicLibrariesOnceHelper();</a>
<a name="ln1081"> </a>
<a name="ln1082">extern &quot;C&quot; {</a>
<a name="ln1083"> </a>
<a name="ln1084">void __cyg_profile_func_enter(void*, void*) __attribute__((no_instrument_function));</a>
<a name="ln1085">void __cyg_profile_func_enter(void *this_fn, void *call_site) {</a>
<a name="ln1086">  if (GetFunctionTraceConf().enabled) {</a>
<a name="ln1087">    GetFunctionTracer().RecordEvent(EventType::kEnter, this_fn, call_site);</a>
<a name="ln1088">  }</a>
<a name="ln1089">}</a>
<a name="ln1090"> </a>
<a name="ln1091">void __cyg_profile_func_exit(void*, void*) __attribute__((no_instrument_function));</a>
<a name="ln1092">void __cyg_profile_func_exit (void *this_fn, void *call_site) {</a>
<a name="ln1093">  if (GetFunctionTraceConf().enabled) {</a>
<a name="ln1094">    GetFunctionTracer().RecordEvent(EventType::kLeave, this_fn, call_site);</a>
<a name="ln1095">  }</a>
<a name="ln1096">}</a>
<a name="ln1097"> </a>
<a name="ln1098">}  // extern &quot;C&quot;</a>
<a name="ln1099"> </a>
<a name="ln1100">std::string DemangleName(const char* mangled_name) {</a>
<a name="ln1101">  int demangle_status = 0;</a>
<a name="ln1102">  char* demangled_name =</a>
<a name="ln1103">      abi::__cxa_demangle(mangled_name, nullptr /* output_buffer */, nullptr /* length */,</a>
<a name="ln1104">                          &amp;demangle_status);</a>
<a name="ln1105">  string ret_val = demangle_status == kDemangleOk ? demangled_name : mangled_name;</a>
<a name="ln1106">  free(demangled_name);</a>
<a name="ln1107">  return ret_val;</a>
<a name="ln1108">}</a>
<a name="ln1109"> </a>
<a name="ln1110">std::string SourceLocation::ToString() const {</a>
<a name="ln1111">  return Format(&quot;$0:$1&quot;, file_name, line_number);</a>
<a name="ln1112">}</a>
<a name="ln1113"> </a>
<a name="ln1114">}  // namespace yb</a>

</code></pre>
<div class="balloon" rel="166"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v570/" target="_blank">V570</a> The 'ts.tv_sec' variable is assigned to itself.</p></div>
<div class="balloon" rel="167"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v570/" target="_blank">V570</a> The 'ts.tv_nsec' variable is assigned to itself.</p></div>
<div class="balloon" rel="224"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1023/" target="_blank">V1023</a> A pointer without owner is added to the 'allocated_chunks' container by the 'emplace_back' method. A memory leak will occur in case of an exception.</p></div>
<div class="balloon" rel="299"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="314"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="522"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 522, 527</p></div>
<div class="balloon" rel="198"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the compiler generated constructor. Consider inspecting: left_to_collect.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
