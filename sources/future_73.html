
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>future</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// &lt;future&gt; -*- C++ -*-</a>
<a name="ln2"> </a>
<a name="ln3">// Copyright (C) 2009-2018 Free Software Foundation, Inc.</a>
<a name="ln4">//</a>
<a name="ln5">// This file is part of the GNU ISO C++ Library.  This library is free</a>
<a name="ln6">// software; you can redistribute it and/or modify it under the</a>
<a name="ln7">// terms of the GNU General Public License as published by the</a>
<a name="ln8">// Free Software Foundation; either version 3, or (at your option)</a>
<a name="ln9">// any later version.</a>
<a name="ln10"> </a>
<a name="ln11">// This library is distributed in the hope that it will be useful,</a>
<a name="ln12">// but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">// GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">// Under Section 7 of GPL version 3, you are granted additional</a>
<a name="ln17">// permissions described in the GCC Runtime Library Exception, version</a>
<a name="ln18">// 3.1, as published by the Free Software Foundation.</a>
<a name="ln19"> </a>
<a name="ln20">// You should have received a copy of the GNU General Public License and</a>
<a name="ln21">// a copy of the GCC Runtime Library Exception along with this program;</a>
<a name="ln22">// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see</a>
<a name="ln23">// &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln24"> </a>
<a name="ln25">/** @file include/future</a>
<a name="ln26"> *  This is a Standard C++ Library header.</a>
<a name="ln27"> */</a>
<a name="ln28"> </a>
<a name="ln29">#ifndef _GLIBCXX_FUTURE</a>
<a name="ln30">#define _GLIBCXX_FUTURE 1</a>
<a name="ln31"> </a>
<a name="ln32">#pragma GCC system_header</a>
<a name="ln33"> </a>
<a name="ln34">#if __cplusplus &lt; 201103L</a>
<a name="ln35"># include &lt;bits/c++0x_warning.h&gt;</a>
<a name="ln36">#else</a>
<a name="ln37"> </a>
<a name="ln38">#include &lt;mutex&gt;</a>
<a name="ln39">#include &lt;thread&gt;</a>
<a name="ln40">#include &lt;condition_variable&gt;</a>
<a name="ln41">#include &lt;system_error&gt;</a>
<a name="ln42">#include &lt;atomic&gt;</a>
<a name="ln43">#include &lt;bits/atomic_futex.h&gt;</a>
<a name="ln44">#include &lt;bits/functexcept.h&gt;</a>
<a name="ln45">#include &lt;bits/invoke.h&gt;</a>
<a name="ln46">#include &lt;bits/unique_ptr.h&gt;</a>
<a name="ln47">#include &lt;bits/shared_ptr.h&gt;</a>
<a name="ln48">#include &lt;bits/std_function.h&gt;</a>
<a name="ln49">#include &lt;bits/uses_allocator.h&gt;</a>
<a name="ln50">#include &lt;bits/allocated_ptr.h&gt;</a>
<a name="ln51">#include &lt;ext/aligned_buffer.h&gt;</a>
<a name="ln52"> </a>
<a name="ln53">namespace std _GLIBCXX_VISIBILITY(default)</a>
<a name="ln54">{</a>
<a name="ln55">_GLIBCXX_BEGIN_NAMESPACE_VERSION</a>
<a name="ln56"> </a>
<a name="ln57">  /**</a>
<a name="ln58">   * @defgroup futures Futures</a>
<a name="ln59">   * @ingroup concurrency</a>
<a name="ln60">   *</a>
<a name="ln61">   * Classes for futures support.</a>
<a name="ln62">   * @{</a>
<a name="ln63">   */</a>
<a name="ln64"> </a>
<a name="ln65">  /// Error code for futures</a>
<a name="ln66">  enum class future_errc</a>
<a name="ln67">  {</a>
<a name="ln68">    future_already_retrieved = 1,</a>
<a name="ln69">    promise_already_satisfied,</a>
<a name="ln70">    no_state,</a>
<a name="ln71">    broken_promise</a>
<a name="ln72">  };</a>
<a name="ln73"> </a>
<a name="ln74">  /// Specialization.</a>
<a name="ln75">  template&lt;&gt;</a>
<a name="ln76">    struct is_error_code_enum&lt;future_errc&gt; : public true_type { };</a>
<a name="ln77"> </a>
<a name="ln78">  /// Points to a statically-allocated object derived from error_category.</a>
<a name="ln79">  const error_category&amp;</a>
<a name="ln80">  future_category() noexcept;</a>
<a name="ln81"> </a>
<a name="ln82">  /// Overload for make_error_code.</a>
<a name="ln83">  inline error_code</a>
<a name="ln84">  make_error_code(future_errc __errc) noexcept</a>
<a name="ln85">  { return error_code(static_cast&lt;int&gt;(__errc), future_category()); }</a>
<a name="ln86"> </a>
<a name="ln87">  /// Overload for make_error_condition.</a>
<a name="ln88">  inline error_condition</a>
<a name="ln89">  make_error_condition(future_errc __errc) noexcept</a>
<a name="ln90">  { return error_condition(static_cast&lt;int&gt;(__errc), future_category()); }</a>
<a name="ln91"> </a>
<a name="ln92">  /**</a>
<a name="ln93">   *  @brief Exception type thrown by futures.</a>
<a name="ln94">   *  @ingroup exceptions</a>
<a name="ln95">   */</a>
<a name="ln96">  class future_error : public logic_error</a>
<a name="ln97">  {</a>
<a name="ln98">  public:</a>
<a name="ln99">    explicit</a>
<a name="ln100">    future_error(future_errc __errc)</a>
<a name="ln101">    : future_error(std::make_error_code(__errc))</a>
<a name="ln102">    { }</a>
<a name="ln103"> </a>
<a name="ln104">    virtual ~future_error() noexcept;</a>
<a name="ln105"> </a>
<a name="ln106">    virtual const char*</a>
<a name="ln107">    what() const noexcept;</a>
<a name="ln108"> </a>
<a name="ln109">    const error_code&amp;</a>
<a name="ln110">    code() const noexcept { return _M_code; }</a>
<a name="ln111"> </a>
<a name="ln112">  private:</a>
<a name="ln113">    explicit</a>
<a name="ln114">    future_error(error_code __ec)</a>
<a name="ln115">    : logic_error(&quot;std::future_error: &quot; + __ec.message()), _M_code(__ec)</a>
<a name="ln116">    { }</a>
<a name="ln117"> </a>
<a name="ln118">    friend void __throw_future_error(int);</a>
<a name="ln119"> </a>
<a name="ln120">    error_code 			_M_code;</a>
<a name="ln121">  };</a>
<a name="ln122"> </a>
<a name="ln123">  // Forward declarations.</a>
<a name="ln124">  template&lt;typename _Res&gt;</a>
<a name="ln125">    class future;</a>
<a name="ln126"> </a>
<a name="ln127">  template&lt;typename _Res&gt;</a>
<a name="ln128">    class shared_future;</a>
<a name="ln129"> </a>
<a name="ln130">  template&lt;typename _Signature&gt;</a>
<a name="ln131">    class packaged_task;</a>
<a name="ln132"> </a>
<a name="ln133">  template&lt;typename _Res&gt;</a>
<a name="ln134">    class promise;</a>
<a name="ln135"> </a>
<a name="ln136">  /// Launch code for futures</a>
<a name="ln137">  enum class launch</a>
<a name="ln138">  {</a>
<a name="ln139">    async = 1,</a>
<a name="ln140">    deferred = 2</a>
<a name="ln141">  };</a>
<a name="ln142"> </a>
<a name="ln143">  constexpr launch operator&amp;(launch __x, launch __y)</a>
<a name="ln144">  {</a>
<a name="ln145">    return static_cast&lt;launch&gt;(</a>
<a name="ln146">	static_cast&lt;int&gt;(__x) &amp; static_cast&lt;int&gt;(__y));</a>
<a name="ln147">  }</a>
<a name="ln148"> </a>
<a name="ln149">  constexpr launch operator|(launch __x, launch __y)</a>
<a name="ln150">  {</a>
<a name="ln151">    return static_cast&lt;launch&gt;(</a>
<a name="ln152">	static_cast&lt;int&gt;(__x) | static_cast&lt;int&gt;(__y));</a>
<a name="ln153">  }</a>
<a name="ln154"> </a>
<a name="ln155">  constexpr launch operator^(launch __x, launch __y)</a>
<a name="ln156">  {</a>
<a name="ln157">    return static_cast&lt;launch&gt;(</a>
<a name="ln158">	static_cast&lt;int&gt;(__x) ^ static_cast&lt;int&gt;(__y));</a>
<a name="ln159">  }</a>
<a name="ln160"> </a>
<a name="ln161">  constexpr launch operator~(launch __x)</a>
<a name="ln162">  { return static_cast&lt;launch&gt;(~static_cast&lt;int&gt;(__x)); }</a>
<a name="ln163"> </a>
<a name="ln164">  inline launch&amp; operator&amp;=(launch&amp; __x, launch __y)</a>
<a name="ln165">  { return __x = __x &amp; __y; }</a>
<a name="ln166"> </a>
<a name="ln167">  inline launch&amp; operator|=(launch&amp; __x, launch __y)</a>
<a name="ln168">  { return __x = __x | __y; }</a>
<a name="ln169"> </a>
<a name="ln170">  inline launch&amp; operator^=(launch&amp; __x, launch __y)</a>
<a name="ln171">  { return __x = __x ^ __y; }</a>
<a name="ln172"> </a>
<a name="ln173">  /// Status code for futures</a>
<a name="ln174">  enum class future_status</a>
<a name="ln175">  {</a>
<a name="ln176">    ready,</a>
<a name="ln177">    timeout,</a>
<a name="ln178">    deferred</a>
<a name="ln179">  };</a>
<a name="ln180"> </a>
<a name="ln181">  // _GLIBCXX_RESOLVE_LIB_DEFECTS</a>
<a name="ln182">  // 2021. Further incorrect usages of result_of</a>
<a name="ln183">  template&lt;typename _Fn, typename... _Args&gt;</a>
<a name="ln184">    using __async_result_of = typename result_of&lt;</a>
<a name="ln185">      typename decay&lt;_Fn&gt;::type(typename decay&lt;_Args&gt;::type...)&gt;::type;</a>
<a name="ln186"> </a>
<a name="ln187">  template&lt;typename _Fn, typename... _Args&gt;</a>
<a name="ln188">    future&lt;__async_result_of&lt;_Fn, _Args...&gt;&gt;</a>
<a name="ln189">    async(launch __policy, _Fn&amp;&amp; __fn, _Args&amp;&amp;... __args);</a>
<a name="ln190"> </a>
<a name="ln191">  template&lt;typename _Fn, typename... _Args&gt;</a>
<a name="ln192">    future&lt;__async_result_of&lt;_Fn, _Args...&gt;&gt;</a>
<a name="ln193">    async(_Fn&amp;&amp; __fn, _Args&amp;&amp;... __args);</a>
<a name="ln194"> </a>
<a name="ln195">#if defined(_GLIBCXX_HAS_GTHREADS) &amp;&amp; defined(_GLIBCXX_USE_C99_STDINT_TR1)</a>
<a name="ln196"> </a>
<a name="ln197">  /// Base class and enclosing scope.</a>
<a name="ln198">  struct __future_base</a>
<a name="ln199">  {</a>
<a name="ln200">    /// Base class for results.</a>
<a name="ln201">    struct _Result_base</a>
<a name="ln202">    {</a>
<a name="ln203">      exception_ptr		_M_error;</a>
<a name="ln204"> </a>
<a name="ln205">      _Result_base(const _Result_base&amp;) = delete;</a>
<a name="ln206">      _Result_base&amp; operator=(const _Result_base&amp;) = delete;</a>
<a name="ln207"> </a>
<a name="ln208">      // _M_destroy() allows derived classes to control deallocation</a>
<a name="ln209">      virtual void _M_destroy() = 0;</a>
<a name="ln210"> </a>
<a name="ln211">      struct _Deleter</a>
<a name="ln212">      {</a>
<a name="ln213">	void operator()(_Result_base* __fr) const { __fr-&gt;_M_destroy(); }</a>
<a name="ln214">      };</a>
<a name="ln215"> </a>
<a name="ln216">    protected:</a>
<a name="ln217">      _Result_base();</a>
<a name="ln218">      virtual ~_Result_base();</a>
<a name="ln219">    };</a>
<a name="ln220"> </a>
<a name="ln221">    /// A unique_ptr for result objects.</a>
<a name="ln222">    template&lt;typename _Res&gt;</a>
<a name="ln223">      using _Ptr = unique_ptr&lt;_Res, _Result_base::_Deleter&gt;;</a>
<a name="ln224"> </a>
<a name="ln225">    /// A result object that has storage for an object of type _Res.</a>
<a name="ln226">    template&lt;typename _Res&gt;</a>
<a name="ln227">      struct _Result : _Result_base</a>
<a name="ln228">      {</a>
<a name="ln229">      private:</a>
<a name="ln230">	__gnu_cxx::__aligned_buffer&lt;_Res&gt;	_M_storage;</a>
<a name="ln231">	bool 					_M_initialized;</a>
<a name="ln232"> </a>
<a name="ln233">      public:</a>
<a name="ln234">	typedef _Res result_type;</a>
<a name="ln235"> </a>
<a name="ln236">	_Result() noexcept : _M_initialized() { }</a>
<a name="ln237"> </a>
<a name="ln238">	~_Result()</a>
<a name="ln239">	{</a>
<a name="ln240">	  if (_M_initialized)</a>
<a name="ln241">	    _M_value().~_Res();</a>
<a name="ln242">	}</a>
<a name="ln243"> </a>
<a name="ln244">	// Return lvalue, future will add const or rvalue-reference</a>
<a name="ln245">	_Res&amp;</a>
<a name="ln246">	_M_value() noexcept { return *_M_storage._M_ptr(); }</a>
<a name="ln247"> </a>
<a name="ln248">	void</a>
<a name="ln249">	_M_set(const _Res&amp; __res)</a>
<a name="ln250">	{</a>
<a name="ln251">	  ::new (_M_storage._M_addr()) _Res(__res);</a>
<a name="ln252">	  _M_initialized = true;</a>
<a name="ln253">	}</a>
<a name="ln254"> </a>
<a name="ln255">	void</a>
<a name="ln256">	_M_set(_Res&amp;&amp; __res)</a>
<a name="ln257">	{</a>
<a name="ln258">	  ::new (_M_storage._M_addr()) _Res(std::move(__res));</a>
<a name="ln259">	  _M_initialized = true;</a>
<a name="ln260">	}</a>
<a name="ln261"> </a>
<a name="ln262">      private:</a>
<a name="ln263">	void _M_destroy() { delete this; }</a>
<a name="ln264">    };</a>
<a name="ln265"> </a>
<a name="ln266">    /// A result object that uses an allocator.</a>
<a name="ln267">    template&lt;typename _Res, typename _Alloc&gt;</a>
<a name="ln268">      struct _Result_alloc final : _Result&lt;_Res&gt;, _Alloc</a>
<a name="ln269">      {</a>
<a name="ln270">	using __allocator_type = __alloc_rebind&lt;_Alloc, _Result_alloc&gt;;</a>
<a name="ln271"> </a>
<a name="ln272">        explicit</a>
<a name="ln273">	_Result_alloc(const _Alloc&amp; __a) : _Result&lt;_Res&gt;(), _Alloc(__a)</a>
<a name="ln274">	{ }</a>
<a name="ln275"> </a>
<a name="ln276">      private:</a>
<a name="ln277">	void _M_destroy()</a>
<a name="ln278">	{</a>
<a name="ln279">	  __allocator_type __a(*this);</a>
<a name="ln280">	  __allocated_ptr&lt;__allocator_type&gt; __guard_ptr{ __a, this };</a>
<a name="ln281">	  this-&gt;~_Result_alloc();</a>
<a name="ln282">	}</a>
<a name="ln283">      };</a>
<a name="ln284"> </a>
<a name="ln285">    // Create a result object that uses an allocator.</a>
<a name="ln286">    template&lt;typename _Res, typename _Allocator&gt;</a>
<a name="ln287">      static _Ptr&lt;_Result_alloc&lt;_Res, _Allocator&gt;&gt;</a>
<a name="ln288">      _S_allocate_result(const _Allocator&amp; __a)</a>
<a name="ln289">      {</a>
<a name="ln290">	using __result_type = _Result_alloc&lt;_Res, _Allocator&gt;;</a>
<a name="ln291">	typename __result_type::__allocator_type __a2(__a);</a>
<a name="ln292">	auto __guard = std::__allocate_guarded(__a2);</a>
<a name="ln293">	__result_type* __p = ::new((void*)__guard.get()) __result_type{__a};</a>
<a name="ln294">	__guard = nullptr;</a>
<a name="ln295">	return _Ptr&lt;__result_type&gt;(__p);</a>
<a name="ln296">      }</a>
<a name="ln297"> </a>
<a name="ln298">    // Keep it simple for std::allocator.</a>
<a name="ln299">    template&lt;typename _Res, typename _Tp&gt;</a>
<a name="ln300">      static _Ptr&lt;_Result&lt;_Res&gt;&gt;</a>
<a name="ln301">      _S_allocate_result(const std::allocator&lt;_Tp&gt;&amp; __a)</a>
<a name="ln302">      {</a>
<a name="ln303">	return _Ptr&lt;_Result&lt;_Res&gt;&gt;(new _Result&lt;_Res&gt;);</a>
<a name="ln304">      }</a>
<a name="ln305"> </a>
<a name="ln306">    // Base class for various types of shared state created by an</a>
<a name="ln307">    // asynchronous provider (such as a std::promise) and shared with one</a>
<a name="ln308">    // or more associated futures.</a>
<a name="ln309">    class _State_baseV2</a>
<a name="ln310">    {</a>
<a name="ln311">      typedef _Ptr&lt;_Result_base&gt; _Ptr_type;</a>
<a name="ln312"> </a>
<a name="ln313">      enum _Status : unsigned {</a>
<a name="ln314">	__not_ready,</a>
<a name="ln315">	__ready</a>
<a name="ln316">      };</a>
<a name="ln317"> </a>
<a name="ln318">      _Ptr_type			_M_result;</a>
<a name="ln319">      __atomic_futex_unsigned&lt;&gt;	_M_status;</a>
<a name="ln320">      atomic_flag         	_M_retrieved = ATOMIC_FLAG_INIT;</a>
<a name="ln321">      once_flag			_M_once;</a>
<a name="ln322"> </a>
<a name="ln323">    public:</a>
<a name="ln324">      _State_baseV2() noexcept : _M_result(), _M_status(_Status::__not_ready)</a>
<a name="ln325">	{ }</a>
<a name="ln326">      _State_baseV2(const _State_baseV2&amp;) = delete;</a>
<a name="ln327">      _State_baseV2&amp; operator=(const _State_baseV2&amp;) = delete;</a>
<a name="ln328">      virtual ~_State_baseV2() = default;</a>
<a name="ln329"> </a>
<a name="ln330">      _Result_base&amp;</a>
<a name="ln331">      wait()</a>
<a name="ln332">      {</a>
<a name="ln333">	// Run any deferred function or join any asynchronous thread:</a>
<a name="ln334">	_M_complete_async();</a>
<a name="ln335">	// Acquire MO makes sure this synchronizes with the thread that made</a>
<a name="ln336">	// the future ready.</a>
<a name="ln337">	_M_status._M_load_when_equal(_Status::__ready, memory_order_acquire);</a>
<a name="ln338">	return *_M_result;</a>
<a name="ln339">      }</a>
<a name="ln340"> </a>
<a name="ln341">      template&lt;typename _Rep, typename _Period&gt;</a>
<a name="ln342">        future_status</a>
<a name="ln343">        wait_for(const chrono::duration&lt;_Rep, _Period&gt;&amp; __rel)</a>
<a name="ln344">        {</a>
<a name="ln345">	  // First, check if the future has been made ready.  Use acquire MO</a>
<a name="ln346">	  // to synchronize with the thread that made it ready.</a>
<a name="ln347">	  if (_M_status._M_load(memory_order_acquire) == _Status::__ready)</a>
<a name="ln348">	    return future_status::ready;</a>
<a name="ln349">	  if (_M_is_deferred_future())</a>
<a name="ln350">	    return future_status::deferred;</a>
<a name="ln351">	  if (_M_status._M_load_when_equal_for(_Status::__ready,</a>
<a name="ln352">	      memory_order_acquire, __rel))</a>
<a name="ln353">	    {</a>
<a name="ln354">	      // _GLIBCXX_RESOLVE_LIB_DEFECTS</a>
<a name="ln355">	      // 2100.  timed waiting functions must also join</a>
<a name="ln356">	      // This call is a no-op by default except on an async future,</a>
<a name="ln357">	      // in which case the async thread is joined.  It's also not a</a>
<a name="ln358">	      // no-op for a deferred future, but such a future will never</a>
<a name="ln359">	      // reach this point because it returns future_status::deferred</a>
<a name="ln360">	      // instead of waiting for the future to become ready (see</a>
<a name="ln361">	      // above).  Async futures synchronize in this call, so we need</a>
<a name="ln362">	      // no further synchronization here.</a>
<a name="ln363">	      _M_complete_async();</a>
<a name="ln364"> </a>
<a name="ln365">	      return future_status::ready;</a>
<a name="ln366">	    }</a>
<a name="ln367">	  return future_status::timeout;</a>
<a name="ln368">	}</a>
<a name="ln369"> </a>
<a name="ln370">      template&lt;typename _Clock, typename _Duration&gt;</a>
<a name="ln371">        future_status</a>
<a name="ln372">        wait_until(const chrono::time_point&lt;_Clock, _Duration&gt;&amp; __abs)</a>
<a name="ln373">        {</a>
<a name="ln374">	  // First, check if the future has been made ready.  Use acquire MO</a>
<a name="ln375">	  // to synchronize with the thread that made it ready.</a>
<a name="ln376">	  if (_M_status._M_load(memory_order_acquire) == _Status::__ready)</a>
<a name="ln377">	    return future_status::ready;</a>
<a name="ln378">	  if (_M_is_deferred_future())</a>
<a name="ln379">	    return future_status::deferred;</a>
<a name="ln380">	  if (_M_status._M_load_when_equal_until(_Status::__ready,</a>
<a name="ln381">	      memory_order_acquire, __abs))</a>
<a name="ln382">	    {</a>
<a name="ln383">	      // _GLIBCXX_RESOLVE_LIB_DEFECTS</a>
<a name="ln384">	      // 2100.  timed waiting functions must also join</a>
<a name="ln385">	      // See wait_for(...) above.</a>
<a name="ln386">	      _M_complete_async();</a>
<a name="ln387"> </a>
<a name="ln388">	      return future_status::ready;</a>
<a name="ln389">	    }</a>
<a name="ln390">	  return future_status::timeout;</a>
<a name="ln391">	}</a>
<a name="ln392"> </a>
<a name="ln393">      // Provide a result to the shared state and make it ready.</a>
<a name="ln394">      // Calls at most once: _M_result = __res();</a>
<a name="ln395">      void</a>
<a name="ln396">      _M_set_result(function&lt;_Ptr_type()&gt; __res, bool __ignore_failure = false)</a>
<a name="ln397">      {</a>
<a name="ln398">	bool __did_set = false;</a>
<a name="ln399">        // all calls to this function are serialized,</a>
<a name="ln400">        // side-effects of invoking __res only happen once</a>
<a name="ln401">	call_once(_M_once, &amp;_State_baseV2::_M_do_set, this,</a>
<a name="ln402">		  std::__addressof(__res), std::__addressof(__did_set));</a>
<a name="ln403">	if (__did_set)</a>
<a name="ln404">	  // Use release MO to synchronize with observers of the ready state.</a>
<a name="ln405">	  _M_status._M_store_notify_all(_Status::__ready,</a>
<a name="ln406">					memory_order_release);</a>
<a name="ln407">	else if (!__ignore_failure)</a>
<a name="ln408">          __throw_future_error(int(future_errc::promise_already_satisfied));</a>
<a name="ln409">      }</a>
<a name="ln410"> </a>
<a name="ln411">      // Provide a result to the shared state but delay making it ready</a>
<a name="ln412">      // until the calling thread exits.</a>
<a name="ln413">      // Calls at most once: _M_result = __res();</a>
<a name="ln414">      void</a>
<a name="ln415">      _M_set_delayed_result(function&lt;_Ptr_type()&gt; __res,</a>
<a name="ln416">			    weak_ptr&lt;_State_baseV2&gt; __self)</a>
<a name="ln417">      {</a>
<a name="ln418">	bool __did_set = false;</a>
<a name="ln419">	unique_ptr&lt;_Make_ready&gt; __mr{new _Make_ready};</a>
<a name="ln420">        // all calls to this function are serialized,</a>
<a name="ln421">        // side-effects of invoking __res only happen once</a>
<a name="ln422">	call_once(_M_once, &amp;_State_baseV2::_M_do_set, this,</a>
<a name="ln423">		  std::__addressof(__res), std::__addressof(__did_set));</a>
<a name="ln424">	if (!__did_set)</a>
<a name="ln425">          __throw_future_error(int(future_errc::promise_already_satisfied));</a>
<a name="ln426">	__mr-&gt;_M_shared_state = std::move(__self);</a>
<a name="ln427">	__mr-&gt;_M_set();</a>
<a name="ln428">	__mr.release();</a>
<a name="ln429">      }</a>
<a name="ln430"> </a>
<a name="ln431">      // Abandon this shared state.</a>
<a name="ln432">      void</a>
<a name="ln433">      _M_break_promise(_Ptr_type __res)</a>
<a name="ln434">      {</a>
<a name="ln435">	if (static_cast&lt;bool&gt;(__res))</a>
<a name="ln436">	  {</a>
<a name="ln437">	    __res-&gt;_M_error =</a>
<a name="ln438">	      make_exception_ptr(future_error(future_errc::broken_promise));</a>
<a name="ln439">	    // This function is only called when the last asynchronous result</a>
<a name="ln440">	    // provider is abandoning this shared state, so noone can be</a>
<a name="ln441">	    // trying to make the shared state ready at the same time, and</a>
<a name="ln442">	    // we can access _M_result directly instead of through call_once.</a>
<a name="ln443">	    _M_result.swap(__res);</a>
<a name="ln444">	    // Use release MO to synchronize with observers of the ready state.</a>
<a name="ln445">	    _M_status._M_store_notify_all(_Status::__ready,</a>
<a name="ln446">					  memory_order_release);</a>
<a name="ln447">	  }</a>
<a name="ln448">      }</a>
<a name="ln449"> </a>
<a name="ln450">      // Called when this object is first passed to a future.</a>
<a name="ln451">      void</a>
<a name="ln452">      _M_set_retrieved_flag()</a>
<a name="ln453">      {</a>
<a name="ln454">	if (_M_retrieved.test_and_set())</a>
<a name="ln455">	  __throw_future_error(int(future_errc::future_already_retrieved));</a>
<a name="ln456">      }</a>
<a name="ln457"> </a>
<a name="ln458">      template&lt;typename _Res, typename _Arg&gt;</a>
<a name="ln459">        struct _Setter;</a>
<a name="ln460"> </a>
<a name="ln461">      // set lvalues</a>
<a name="ln462">      template&lt;typename _Res, typename _Arg&gt;</a>
<a name="ln463">        struct _Setter&lt;_Res, _Arg&amp;&gt;</a>
<a name="ln464">        {</a>
<a name="ln465">          // check this is only used by promise&lt;R&gt;::set_value(const R&amp;)</a>
<a name="ln466">          // or promise&lt;R&amp;&gt;::set_value(R&amp;)</a>
<a name="ln467">          static_assert(is_same&lt;_Res, _Arg&amp;&gt;::value  // promise&lt;R&amp;&gt;</a>
<a name="ln468">              || is_same&lt;const _Res, _Arg&gt;::value,   // promise&lt;R&gt;</a>
<a name="ln469">              &quot;Invalid specialisation&quot;);</a>
<a name="ln470"> </a>
<a name="ln471">	  // Used by std::promise to copy construct the result.</a>
<a name="ln472">          typename promise&lt;_Res&gt;::_Ptr_type operator()() const</a>
<a name="ln473">          {</a>
<a name="ln474">            _M_promise-&gt;_M_storage-&gt;_M_set(*_M_arg);</a>
<a name="ln475">            return std::move(_M_promise-&gt;_M_storage);</a>
<a name="ln476">          }</a>
<a name="ln477">          promise&lt;_Res&gt;*    _M_promise;</a>
<a name="ln478">          _Arg*             _M_arg;</a>
<a name="ln479">        };</a>
<a name="ln480"> </a>
<a name="ln481">      // set rvalues</a>
<a name="ln482">      template&lt;typename _Res&gt;</a>
<a name="ln483">        struct _Setter&lt;_Res, _Res&amp;&amp;&gt;</a>
<a name="ln484">        {</a>
<a name="ln485">	  // Used by std::promise to move construct the result.</a>
<a name="ln486">          typename promise&lt;_Res&gt;::_Ptr_type operator()() const</a>
<a name="ln487">          {</a>
<a name="ln488">            _M_promise-&gt;_M_storage-&gt;_M_set(std::move(*_M_arg));</a>
<a name="ln489">            return std::move(_M_promise-&gt;_M_storage);</a>
<a name="ln490">          }</a>
<a name="ln491">          promise&lt;_Res&gt;*    _M_promise;</a>
<a name="ln492">          _Res*             _M_arg;</a>
<a name="ln493">        };</a>
<a name="ln494"> </a>
<a name="ln495">      // set void</a>
<a name="ln496">      template&lt;typename _Res&gt;</a>
<a name="ln497">	struct _Setter&lt;_Res, void&gt;</a>
<a name="ln498">	{</a>
<a name="ln499">	  static_assert(is_void&lt;_Res&gt;::value, &quot;Only used for promise&lt;void&gt;&quot;);</a>
<a name="ln500"> </a>
<a name="ln501">	  typename promise&lt;_Res&gt;::_Ptr_type operator()() const</a>
<a name="ln502">	  { return std::move(_M_promise-&gt;_M_storage); }</a>
<a name="ln503"> </a>
<a name="ln504">	  promise&lt;_Res&gt;*    _M_promise;</a>
<a name="ln505">	};</a>
<a name="ln506"> </a>
<a name="ln507">      struct __exception_ptr_tag { };</a>
<a name="ln508"> </a>
<a name="ln509">      // set exceptions</a>
<a name="ln510">      template&lt;typename _Res&gt;</a>
<a name="ln511">        struct _Setter&lt;_Res, __exception_ptr_tag&gt;</a>
<a name="ln512">        {</a>
<a name="ln513">	  // Used by std::promise to store an exception as the result.</a>
<a name="ln514">          typename promise&lt;_Res&gt;::_Ptr_type operator()() const</a>
<a name="ln515">          {</a>
<a name="ln516">            _M_promise-&gt;_M_storage-&gt;_M_error = *_M_ex;</a>
<a name="ln517">            return std::move(_M_promise-&gt;_M_storage);</a>
<a name="ln518">          }</a>
<a name="ln519"> </a>
<a name="ln520">          promise&lt;_Res&gt;*   _M_promise;</a>
<a name="ln521">          exception_ptr*    _M_ex;</a>
<a name="ln522">        };</a>
<a name="ln523"> </a>
<a name="ln524">      template&lt;typename _Res, typename _Arg&gt;</a>
<a name="ln525">        static _Setter&lt;_Res, _Arg&amp;&amp;&gt;</a>
<a name="ln526">        __setter(promise&lt;_Res&gt;* __prom, _Arg&amp;&amp; __arg)</a>
<a name="ln527">        {</a>
<a name="ln528">	  _S_check(__prom-&gt;_M_future);</a>
<a name="ln529">          return _Setter&lt;_Res, _Arg&amp;&amp;&gt;{ __prom, std::__addressof(__arg) };</a>
<a name="ln530">        }</a>
<a name="ln531"> </a>
<a name="ln532">      template&lt;typename _Res&gt;</a>
<a name="ln533">        static _Setter&lt;_Res, __exception_ptr_tag&gt;</a>
<a name="ln534">        __setter(exception_ptr&amp; __ex, promise&lt;_Res&gt;* __prom)</a>
<a name="ln535">        {</a>
<a name="ln536">	  _S_check(__prom-&gt;_M_future);</a>
<a name="ln537">          return _Setter&lt;_Res, __exception_ptr_tag&gt;{ __prom, &amp;__ex };</a>
<a name="ln538">        }</a>
<a name="ln539"> </a>
<a name="ln540">      template&lt;typename _Res&gt;</a>
<a name="ln541">	static _Setter&lt;_Res, void&gt;</a>
<a name="ln542">	__setter(promise&lt;_Res&gt;* __prom)</a>
<a name="ln543">	{</a>
<a name="ln544">	  _S_check(__prom-&gt;_M_future);</a>
<a name="ln545">	  return _Setter&lt;_Res, void&gt;{ __prom };</a>
<a name="ln546">	}</a>
<a name="ln547"> </a>
<a name="ln548">      template&lt;typename _Tp&gt;</a>
<a name="ln549">        static void</a>
<a name="ln550">        _S_check(const shared_ptr&lt;_Tp&gt;&amp; __p)</a>
<a name="ln551">        {</a>
<a name="ln552">          if (!static_cast&lt;bool&gt;(__p))</a>
<a name="ln553">            __throw_future_error((int)future_errc::no_state);</a>
<a name="ln554">        }</a>
<a name="ln555"> </a>
<a name="ln556">    private:</a>
<a name="ln557">      // The function invoked with std::call_once(_M_once, ...).</a>
<a name="ln558">      void</a>
<a name="ln559">      _M_do_set(function&lt;_Ptr_type()&gt;* __f, bool* __did_set)</a>
<a name="ln560">      {</a>
<a name="ln561">        _Ptr_type __res = (*__f)();</a>
<a name="ln562">        // Notify the caller that we did try to set; if we do not throw an</a>
<a name="ln563">        // exception, the caller will be aware that it did set (e.g., see</a>
<a name="ln564">        // _M_set_result).</a>
<a name="ln565">	*__did_set = true;</a>
<a name="ln566">        _M_result.swap(__res); // nothrow</a>
<a name="ln567">      }</a>
<a name="ln568"> </a>
<a name="ln569">      // Wait for completion of async function.</a>
<a name="ln570">      virtual void _M_complete_async() { }</a>
<a name="ln571"> </a>
<a name="ln572">      // Return true if state corresponds to a deferred function.</a>
<a name="ln573">      virtual bool _M_is_deferred_future() const { return false; }</a>
<a name="ln574"> </a>
<a name="ln575">      struct _Make_ready final : __at_thread_exit_elt</a>
<a name="ln576">      {</a>
<a name="ln577">	weak_ptr&lt;_State_baseV2&gt; _M_shared_state;</a>
<a name="ln578">	static void _S_run(void*);</a>
<a name="ln579">	void _M_set();</a>
<a name="ln580">      };</a>
<a name="ln581">    };</a>
<a name="ln582"> </a>
<a name="ln583">#ifdef _GLIBCXX_ASYNC_ABI_COMPAT</a>
<a name="ln584">    class _State_base;</a>
<a name="ln585">    class _Async_state_common;</a>
<a name="ln586">#else</a>
<a name="ln587">    using _State_base = _State_baseV2;</a>
<a name="ln588">    class _Async_state_commonV2;</a>
<a name="ln589">#endif</a>
<a name="ln590"> </a>
<a name="ln591">    template&lt;typename _BoundFn,</a>
<a name="ln592">	     typename _Res = decltype(std::declval&lt;_BoundFn&amp;&gt;()())&gt;</a>
<a name="ln593">      class _Deferred_state;</a>
<a name="ln594"> </a>
<a name="ln595">    template&lt;typename _BoundFn,</a>
<a name="ln596">	     typename _Res = decltype(std::declval&lt;_BoundFn&amp;&gt;()())&gt;</a>
<a name="ln597">      class _Async_state_impl;</a>
<a name="ln598"> </a>
<a name="ln599">    template&lt;typename _Signature&gt;</a>
<a name="ln600">      class _Task_state_base;</a>
<a name="ln601"> </a>
<a name="ln602">    template&lt;typename _Fn, typename _Alloc, typename _Signature&gt;</a>
<a name="ln603">      class _Task_state;</a>
<a name="ln604"> </a>
<a name="ln605">    template&lt;typename _BoundFn&gt;</a>
<a name="ln606">      static std::shared_ptr&lt;_State_base&gt;</a>
<a name="ln607">      _S_make_deferred_state(_BoundFn&amp;&amp; __fn);</a>
<a name="ln608"> </a>
<a name="ln609">    template&lt;typename _BoundFn&gt;</a>
<a name="ln610">      static std::shared_ptr&lt;_State_base&gt;</a>
<a name="ln611">      _S_make_async_state(_BoundFn&amp;&amp; __fn);</a>
<a name="ln612"> </a>
<a name="ln613">    template&lt;typename _Res_ptr, typename _Fn,</a>
<a name="ln614">	     typename _Res = typename _Res_ptr::element_type::result_type&gt;</a>
<a name="ln615">      struct _Task_setter;</a>
<a name="ln616"> </a>
<a name="ln617">    template&lt;typename _Res_ptr, typename _BoundFn&gt;</a>
<a name="ln618">      static _Task_setter&lt;_Res_ptr, _BoundFn&gt;</a>
<a name="ln619">      _S_task_setter(_Res_ptr&amp; __ptr, _BoundFn&amp; __call)</a>
<a name="ln620">      {</a>
<a name="ln621">	return { std::__addressof(__ptr), std::__addressof(__call) };</a>
<a name="ln622">      }</a>
<a name="ln623">  };</a>
<a name="ln624"> </a>
<a name="ln625">  /// Partial specialization for reference types.</a>
<a name="ln626">  template&lt;typename _Res&gt;</a>
<a name="ln627">    struct __future_base::_Result&lt;_Res&amp;&gt; : __future_base::_Result_base</a>
<a name="ln628">    {</a>
<a name="ln629">      typedef _Res&amp; result_type;</a>
<a name="ln630"> </a>
<a name="ln631">      _Result() noexcept : _M_value_ptr() { }</a>
<a name="ln632"> </a>
<a name="ln633">      void</a>
<a name="ln634">      _M_set(_Res&amp; __res) noexcept</a>
<a name="ln635">      { _M_value_ptr = std::addressof(__res); }</a>
<a name="ln636"> </a>
<a name="ln637">      _Res&amp; _M_get() noexcept { return *_M_value_ptr; }</a>
<a name="ln638"> </a>
<a name="ln639">    private:</a>
<a name="ln640">      _Res* 			_M_value_ptr;</a>
<a name="ln641"> </a>
<a name="ln642">      void _M_destroy() { delete this; }</a>
<a name="ln643">    };</a>
<a name="ln644"> </a>
<a name="ln645">  /// Explicit specialization for void.</a>
<a name="ln646">  template&lt;&gt;</a>
<a name="ln647">    struct __future_base::_Result&lt;void&gt; : __future_base::_Result_base</a>
<a name="ln648">    {</a>
<a name="ln649">      typedef void result_type;</a>
<a name="ln650"> </a>
<a name="ln651">    private:</a>
<a name="ln652">      void _M_destroy() { delete this; }</a>
<a name="ln653">    };</a>
<a name="ln654"> </a>
<a name="ln655">#ifndef _GLIBCXX_ASYNC_ABI_COMPAT</a>
<a name="ln656"> </a>
<a name="ln657">  // Allow _Setter objects to be stored locally in std::function</a>
<a name="ln658">  template&lt;typename _Res, typename _Arg&gt;</a>
<a name="ln659">    struct __is_location_invariant</a>
<a name="ln660">    &lt;__future_base::_State_base::_Setter&lt;_Res, _Arg&gt;&gt;</a>
<a name="ln661">    : true_type { };</a>
<a name="ln662"> </a>
<a name="ln663">  // Allow _Task_setter objects to be stored locally in std::function</a>
<a name="ln664">  template&lt;typename _Res_ptr, typename _Fn, typename _Res&gt;</a>
<a name="ln665">    struct __is_location_invariant</a>
<a name="ln666">    &lt;__future_base::_Task_setter&lt;_Res_ptr, _Fn, _Res&gt;&gt;</a>
<a name="ln667">    : true_type { };</a>
<a name="ln668"> </a>
<a name="ln669">  /// Common implementation for future and shared_future.</a>
<a name="ln670">  template&lt;typename _Res&gt;</a>
<a name="ln671">    class __basic_future : public __future_base</a>
<a name="ln672">    {</a>
<a name="ln673">    protected:</a>
<a name="ln674">      typedef shared_ptr&lt;_State_base&gt;		__state_type;</a>
<a name="ln675">      typedef __future_base::_Result&lt;_Res&gt;&amp;	__result_type;</a>
<a name="ln676"> </a>
<a name="ln677">    private:</a>
<a name="ln678">      __state_type 		_M_state;</a>
<a name="ln679"> </a>
<a name="ln680">    public:</a>
<a name="ln681">      // Disable copying.</a>
<a name="ln682">      __basic_future(const __basic_future&amp;) = delete;</a>
<a name="ln683">      __basic_future&amp; operator=(const __basic_future&amp;) = delete;</a>
<a name="ln684"> </a>
<a name="ln685">      bool</a>
<a name="ln686">      valid() const noexcept { return static_cast&lt;bool&gt;(_M_state); }</a>
<a name="ln687"> </a>
<a name="ln688">      void</a>
<a name="ln689">      wait() const</a>
<a name="ln690">      {</a>
<a name="ln691">        _State_base::_S_check(_M_state);</a>
<a name="ln692">        _M_state-&gt;wait();</a>
<a name="ln693">      }</a>
<a name="ln694"> </a>
<a name="ln695">      template&lt;typename _Rep, typename _Period&gt;</a>
<a name="ln696">        future_status</a>
<a name="ln697">        wait_for(const chrono::duration&lt;_Rep, _Period&gt;&amp; __rel) const</a>
<a name="ln698">        {</a>
<a name="ln699">          _State_base::_S_check(_M_state);</a>
<a name="ln700">          return _M_state-&gt;wait_for(__rel);</a>
<a name="ln701">        }</a>
<a name="ln702"> </a>
<a name="ln703">      template&lt;typename _Clock, typename _Duration&gt;</a>
<a name="ln704">        future_status</a>
<a name="ln705">        wait_until(const chrono::time_point&lt;_Clock, _Duration&gt;&amp; __abs) const</a>
<a name="ln706">        {</a>
<a name="ln707">          _State_base::_S_check(_M_state);</a>
<a name="ln708">          return _M_state-&gt;wait_until(__abs);</a>
<a name="ln709">        }</a>
<a name="ln710"> </a>
<a name="ln711">    protected:</a>
<a name="ln712">      /// Wait for the state to be ready and rethrow any stored exception</a>
<a name="ln713">      __result_type</a>
<a name="ln714">      _M_get_result() const</a>
<a name="ln715">      {</a>
<a name="ln716">        _State_base::_S_check(_M_state);</a>
<a name="ln717">        _Result_base&amp; __res = _M_state-&gt;wait();</a>
<a name="ln718">        if (!(__res._M_error == 0))</a>
<a name="ln719">          rethrow_exception(__res._M_error);</a>
<a name="ln720">        return static_cast&lt;__result_type&gt;(__res);</a>
<a name="ln721">      }</a>
<a name="ln722"> </a>
<a name="ln723">      void _M_swap(__basic_future&amp; __that) noexcept</a>
<a name="ln724">      {</a>
<a name="ln725">        _M_state.swap(__that._M_state);</a>
<a name="ln726">      }</a>
<a name="ln727"> </a>
<a name="ln728">      // Construction of a future by promise::get_future()</a>
<a name="ln729">      explicit</a>
<a name="ln730">      __basic_future(const __state_type&amp; __state) : _M_state(__state)</a>
<a name="ln731">      {</a>
<a name="ln732">        _State_base::_S_check(_M_state);</a>
<a name="ln733">        _M_state-&gt;_M_set_retrieved_flag();</a>
<a name="ln734">      }</a>
<a name="ln735"> </a>
<a name="ln736">      // Copy construction from a shared_future</a>
<a name="ln737">      explicit</a>
<a name="ln738">      __basic_future(const shared_future&lt;_Res&gt;&amp;) noexcept;</a>
<a name="ln739"> </a>
<a name="ln740">      // Move construction from a shared_future</a>
<a name="ln741">      explicit</a>
<a name="ln742">      __basic_future(shared_future&lt;_Res&gt;&amp;&amp;) noexcept;</a>
<a name="ln743"> </a>
<a name="ln744">      // Move construction from a future</a>
<a name="ln745">      explicit</a>
<a name="ln746">      __basic_future(future&lt;_Res&gt;&amp;&amp;) noexcept;</a>
<a name="ln747"> </a>
<a name="ln748">      constexpr __basic_future() noexcept : _M_state() { }</a>
<a name="ln749"> </a>
<a name="ln750">      struct _Reset</a>
<a name="ln751">      {</a>
<a name="ln752">        explicit _Reset(__basic_future&amp; __fut) noexcept : _M_fut(__fut) { }</a>
<a name="ln753">        ~_Reset() { _M_fut._M_state.reset(); }</a>
<a name="ln754">        __basic_future&amp; _M_fut;</a>
<a name="ln755">      };</a>
<a name="ln756">    };</a>
<a name="ln757"> </a>
<a name="ln758"> </a>
<a name="ln759">  /// Primary template for future.</a>
<a name="ln760">  template&lt;typename _Res&gt;</a>
<a name="ln761">    class future : public __basic_future&lt;_Res&gt;</a>
<a name="ln762">    {</a>
<a name="ln763">      friend class promise&lt;_Res&gt;;</a>
<a name="ln764">      template&lt;typename&gt; friend class packaged_task;</a>
<a name="ln765">      template&lt;typename _Fn, typename... _Args&gt;</a>
<a name="ln766">        friend future&lt;__async_result_of&lt;_Fn, _Args...&gt;&gt;</a>
<a name="ln767">        async(launch, _Fn&amp;&amp;, _Args&amp;&amp;...);</a>
<a name="ln768"> </a>
<a name="ln769">      typedef __basic_future&lt;_Res&gt; _Base_type;</a>
<a name="ln770">      typedef typename _Base_type::__state_type __state_type;</a>
<a name="ln771"> </a>
<a name="ln772">      explicit</a>
<a name="ln773">      future(const __state_type&amp; __state) : _Base_type(__state) { }</a>
<a name="ln774"> </a>
<a name="ln775">    public:</a>
<a name="ln776">      constexpr future() noexcept : _Base_type() { }</a>
<a name="ln777"> </a>
<a name="ln778">      /// Move constructor</a>
<a name="ln779">      future(future&amp;&amp; __uf) noexcept : _Base_type(std::move(__uf)) { }</a>
<a name="ln780"> </a>
<a name="ln781">      // Disable copying</a>
<a name="ln782">      future(const future&amp;) = delete;</a>
<a name="ln783">      future&amp; operator=(const future&amp;) = delete;</a>
<a name="ln784"> </a>
<a name="ln785">      future&amp; operator=(future&amp;&amp; __fut) noexcept</a>
<a name="ln786">      {</a>
<a name="ln787">        future(std::move(__fut))._M_swap(*this);</a>
<a name="ln788">        return *this;</a>
<a name="ln789">      }</a>
<a name="ln790"> </a>
<a name="ln791">      /// Retrieving the value</a>
<a name="ln792">      _Res</a>
<a name="ln793">      get()</a>
<a name="ln794">      {</a>
<a name="ln795">        typename _Base_type::_Reset __reset(*this);</a>
<a name="ln796">        return std::move(this-&gt;_M_get_result()._M_value());</a>
<a name="ln797">      }</a>
<a name="ln798"> </a>
<a name="ln799">      shared_future&lt;_Res&gt; share() noexcept;</a>
<a name="ln800">    };</a>
<a name="ln801"> </a>
<a name="ln802">  /// Partial specialization for future&lt;R&amp;&gt;</a>
<a name="ln803">  template&lt;typename _Res&gt;</a>
<a name="ln804">    class future&lt;_Res&amp;&gt; : public __basic_future&lt;_Res&amp;&gt;</a>
<a name="ln805">    {</a>
<a name="ln806">      friend class promise&lt;_Res&amp;&gt;;</a>
<a name="ln807">      template&lt;typename&gt; friend class packaged_task;</a>
<a name="ln808">      template&lt;typename _Fn, typename... _Args&gt;</a>
<a name="ln809">        friend future&lt;__async_result_of&lt;_Fn, _Args...&gt;&gt;</a>
<a name="ln810">        async(launch, _Fn&amp;&amp;, _Args&amp;&amp;...);</a>
<a name="ln811"> </a>
<a name="ln812">      typedef __basic_future&lt;_Res&amp;&gt; _Base_type;</a>
<a name="ln813">      typedef typename _Base_type::__state_type __state_type;</a>
<a name="ln814"> </a>
<a name="ln815">      explicit</a>
<a name="ln816">      future(const __state_type&amp; __state) : _Base_type(__state) { }</a>
<a name="ln817"> </a>
<a name="ln818">    public:</a>
<a name="ln819">      constexpr future() noexcept : _Base_type() { }</a>
<a name="ln820"> </a>
<a name="ln821">      /// Move constructor</a>
<a name="ln822">      future(future&amp;&amp; __uf) noexcept : _Base_type(std::move(__uf)) { }</a>
<a name="ln823"> </a>
<a name="ln824">      // Disable copying</a>
<a name="ln825">      future(const future&amp;) = delete;</a>
<a name="ln826">      future&amp; operator=(const future&amp;) = delete;</a>
<a name="ln827"> </a>
<a name="ln828">      future&amp; operator=(future&amp;&amp; __fut) noexcept</a>
<a name="ln829">      {</a>
<a name="ln830">        future(std::move(__fut))._M_swap(*this);</a>
<a name="ln831">        return *this;</a>
<a name="ln832">      }</a>
<a name="ln833"> </a>
<a name="ln834">      /// Retrieving the value</a>
<a name="ln835">      _Res&amp;</a>
<a name="ln836">      get()</a>
<a name="ln837">      {</a>
<a name="ln838">        typename _Base_type::_Reset __reset(*this);</a>
<a name="ln839">        return this-&gt;_M_get_result()._M_get();</a>
<a name="ln840">      }</a>
<a name="ln841"> </a>
<a name="ln842">      shared_future&lt;_Res&amp;&gt; share() noexcept;</a>
<a name="ln843">    };</a>
<a name="ln844"> </a>
<a name="ln845">  /// Explicit specialization for future&lt;void&gt;</a>
<a name="ln846">  template&lt;&gt;</a>
<a name="ln847">    class future&lt;void&gt; : public __basic_future&lt;void&gt;</a>
<a name="ln848">    {</a>
<a name="ln849">      friend class promise&lt;void&gt;;</a>
<a name="ln850">      template&lt;typename&gt; friend class packaged_task;</a>
<a name="ln851">      template&lt;typename _Fn, typename... _Args&gt;</a>
<a name="ln852">        friend future&lt;__async_result_of&lt;_Fn, _Args...&gt;&gt;</a>
<a name="ln853">        async(launch, _Fn&amp;&amp;, _Args&amp;&amp;...);</a>
<a name="ln854"> </a>
<a name="ln855">      typedef __basic_future&lt;void&gt; _Base_type;</a>
<a name="ln856">      typedef typename _Base_type::__state_type __state_type;</a>
<a name="ln857"> </a>
<a name="ln858">      explicit</a>
<a name="ln859">      future(const __state_type&amp; __state) : _Base_type(__state) { }</a>
<a name="ln860"> </a>
<a name="ln861">    public:</a>
<a name="ln862">      constexpr future() noexcept : _Base_type() { }</a>
<a name="ln863"> </a>
<a name="ln864">      /// Move constructor</a>
<a name="ln865">      future(future&amp;&amp; __uf) noexcept : _Base_type(std::move(__uf)) { }</a>
<a name="ln866"> </a>
<a name="ln867">      // Disable copying</a>
<a name="ln868">      future(const future&amp;) = delete;</a>
<a name="ln869">      future&amp; operator=(const future&amp;) = delete;</a>
<a name="ln870"> </a>
<a name="ln871">      future&amp; operator=(future&amp;&amp; __fut) noexcept</a>
<a name="ln872">      {</a>
<a name="ln873">        future(std::move(__fut))._M_swap(*this);</a>
<a name="ln874">        return *this;</a>
<a name="ln875">      }</a>
<a name="ln876"> </a>
<a name="ln877">      /// Retrieving the value</a>
<a name="ln878">      void</a>
<a name="ln879">      get()</a>
<a name="ln880">      {</a>
<a name="ln881">        typename _Base_type::_Reset __reset(*this);</a>
<a name="ln882">        this-&gt;_M_get_result();</a>
<a name="ln883">      }</a>
<a name="ln884"> </a>
<a name="ln885">      shared_future&lt;void&gt; share() noexcept;</a>
<a name="ln886">    };</a>
<a name="ln887"> </a>
<a name="ln888"> </a>
<a name="ln889">  /// Primary template for shared_future.</a>
<a name="ln890">  template&lt;typename _Res&gt;</a>
<a name="ln891">    class shared_future : public __basic_future&lt;_Res&gt;</a>
<a name="ln892">    {</a>
<a name="ln893">      typedef __basic_future&lt;_Res&gt; _Base_type;</a>
<a name="ln894"> </a>
<a name="ln895">    public:</a>
<a name="ln896">      constexpr shared_future() noexcept : _Base_type() { }</a>
<a name="ln897"> </a>
<a name="ln898">      /// Copy constructor</a>
<a name="ln899">      shared_future(const shared_future&amp; __sf) noexcept : _Base_type(__sf) { }</a>
<a name="ln900"> </a>
<a name="ln901">      /// Construct from a future rvalue</a>
<a name="ln902">      shared_future(future&lt;_Res&gt;&amp;&amp; __uf) noexcept</a>
<a name="ln903">      : _Base_type(std::move(__uf))</a>
<a name="ln904">      { }</a>
<a name="ln905"> </a>
<a name="ln906">      /// Construct from a shared_future rvalue</a>
<a name="ln907">      shared_future(shared_future&amp;&amp; __sf) noexcept</a>
<a name="ln908">      : _Base_type(std::move(__sf))</a>
<a name="ln909">      { }</a>
<a name="ln910"> </a>
<a name="ln911">      shared_future&amp; operator=(const shared_future&amp; __sf) noexcept</a>
<a name="ln912">      {</a>
<a name="ln913">        shared_future(__sf)._M_swap(*this);</a>
<a name="ln914">        return *this;</a>
<a name="ln915">      }</a>
<a name="ln916"> </a>
<a name="ln917">      shared_future&amp; operator=(shared_future&amp;&amp; __sf) noexcept</a>
<a name="ln918">      {</a>
<a name="ln919">        shared_future(std::move(__sf))._M_swap(*this);</a>
<a name="ln920">        return *this;</a>
<a name="ln921">      }</a>
<a name="ln922"> </a>
<a name="ln923">      /// Retrieving the value</a>
<a name="ln924">      const _Res&amp;</a>
<a name="ln925">      get() const { return this-&gt;_M_get_result()._M_value(); }</a>
<a name="ln926">    };</a>
<a name="ln927"> </a>
<a name="ln928">  /// Partial specialization for shared_future&lt;R&amp;&gt;</a>
<a name="ln929">  template&lt;typename _Res&gt;</a>
<a name="ln930">    class shared_future&lt;_Res&amp;&gt; : public __basic_future&lt;_Res&amp;&gt;</a>
<a name="ln931">    {</a>
<a name="ln932">      typedef __basic_future&lt;_Res&amp;&gt;           _Base_type;</a>
<a name="ln933"> </a>
<a name="ln934">    public:</a>
<a name="ln935">      constexpr shared_future() noexcept : _Base_type() { }</a>
<a name="ln936"> </a>
<a name="ln937">      /// Copy constructor</a>
<a name="ln938">      shared_future(const shared_future&amp; __sf) : _Base_type(__sf) { }</a>
<a name="ln939"> </a>
<a name="ln940">      /// Construct from a future rvalue</a>
<a name="ln941">      shared_future(future&lt;_Res&amp;&gt;&amp;&amp; __uf) noexcept</a>
<a name="ln942">      : _Base_type(std::move(__uf))</a>
<a name="ln943">      { }</a>
<a name="ln944"> </a>
<a name="ln945">      /// Construct from a shared_future rvalue</a>
<a name="ln946">      shared_future(shared_future&amp;&amp; __sf) noexcept</a>
<a name="ln947">      : _Base_type(std::move(__sf))</a>
<a name="ln948">      { }</a>
<a name="ln949"> </a>
<a name="ln950">      shared_future&amp; operator=(const shared_future&amp; __sf)</a>
<a name="ln951">      {</a>
<a name="ln952">        shared_future(__sf)._M_swap(*this);</a>
<a name="ln953">        return *this;</a>
<a name="ln954">      }</a>
<a name="ln955"> </a>
<a name="ln956">      shared_future&amp; operator=(shared_future&amp;&amp; __sf) noexcept</a>
<a name="ln957">      {</a>
<a name="ln958">        shared_future(std::move(__sf))._M_swap(*this);</a>
<a name="ln959">        return *this;</a>
<a name="ln960">      }</a>
<a name="ln961"> </a>
<a name="ln962">      /// Retrieving the value</a>
<a name="ln963">      _Res&amp;</a>
<a name="ln964">      get() const { return this-&gt;_M_get_result()._M_get(); }</a>
<a name="ln965">    };</a>
<a name="ln966"> </a>
<a name="ln967">  /// Explicit specialization for shared_future&lt;void&gt;</a>
<a name="ln968">  template&lt;&gt;</a>
<a name="ln969">    class shared_future&lt;void&gt; : public __basic_future&lt;void&gt;</a>
<a name="ln970">    {</a>
<a name="ln971">      typedef __basic_future&lt;void&gt; _Base_type;</a>
<a name="ln972"> </a>
<a name="ln973">    public:</a>
<a name="ln974">      constexpr shared_future() noexcept : _Base_type() { }</a>
<a name="ln975"> </a>
<a name="ln976">      /// Copy constructor</a>
<a name="ln977">      shared_future(const shared_future&amp; __sf) : _Base_type(__sf) { }</a>
<a name="ln978"> </a>
<a name="ln979">      /// Construct from a future rvalue</a>
<a name="ln980">      shared_future(future&lt;void&gt;&amp;&amp; __uf) noexcept</a>
<a name="ln981">      : _Base_type(std::move(__uf))</a>
<a name="ln982">      { }</a>
<a name="ln983"> </a>
<a name="ln984">      /// Construct from a shared_future rvalue</a>
<a name="ln985">      shared_future(shared_future&amp;&amp; __sf) noexcept</a>
<a name="ln986">      : _Base_type(std::move(__sf))</a>
<a name="ln987">      { }</a>
<a name="ln988"> </a>
<a name="ln989">      shared_future&amp; operator=(const shared_future&amp; __sf)</a>
<a name="ln990">      {</a>
<a name="ln991">        shared_future(__sf)._M_swap(*this);</a>
<a name="ln992">        return *this;</a>
<a name="ln993">      }</a>
<a name="ln994"> </a>
<a name="ln995">      shared_future&amp; operator=(shared_future&amp;&amp; __sf) noexcept</a>
<a name="ln996">      {</a>
<a name="ln997">        shared_future(std::move(__sf))._M_swap(*this);</a>
<a name="ln998">        return *this;</a>
<a name="ln999">      }</a>
<a name="ln1000"> </a>
<a name="ln1001">      // Retrieving the value</a>
<a name="ln1002">      void</a>
<a name="ln1003">      get() const { this-&gt;_M_get_result(); }</a>
<a name="ln1004">    };</a>
<a name="ln1005"> </a>
<a name="ln1006">  // Now we can define the protected __basic_future constructors.</a>
<a name="ln1007">  template&lt;typename _Res&gt;</a>
<a name="ln1008">    inline __basic_future&lt;_Res&gt;::</a>
<a name="ln1009">    __basic_future(const shared_future&lt;_Res&gt;&amp; __sf) noexcept</a>
<a name="ln1010">    : _M_state(__sf._M_state)</a>
<a name="ln1011">    { }</a>
<a name="ln1012"> </a>
<a name="ln1013">  template&lt;typename _Res&gt;</a>
<a name="ln1014">    inline __basic_future&lt;_Res&gt;::</a>
<a name="ln1015">    __basic_future(shared_future&lt;_Res&gt;&amp;&amp; __sf) noexcept</a>
<a name="ln1016">    : _M_state(std::move(__sf._M_state))</a>
<a name="ln1017">    { }</a>
<a name="ln1018"> </a>
<a name="ln1019">  template&lt;typename _Res&gt;</a>
<a name="ln1020">    inline __basic_future&lt;_Res&gt;::</a>
<a name="ln1021">    __basic_future(future&lt;_Res&gt;&amp;&amp; __uf) noexcept</a>
<a name="ln1022">    : _M_state(std::move(__uf._M_state))</a>
<a name="ln1023">    { }</a>
<a name="ln1024"> </a>
<a name="ln1025">  // _GLIBCXX_RESOLVE_LIB_DEFECTS</a>
<a name="ln1026">  // 2556. Wide contract for future::share()</a>
<a name="ln1027">  template&lt;typename _Res&gt;</a>
<a name="ln1028">    inline shared_future&lt;_Res&gt;</a>
<a name="ln1029">    future&lt;_Res&gt;::share() noexcept</a>
<a name="ln1030">    { return shared_future&lt;_Res&gt;(std::move(*this)); }</a>
<a name="ln1031"> </a>
<a name="ln1032">  template&lt;typename _Res&gt;</a>
<a name="ln1033">    inline shared_future&lt;_Res&amp;&gt;</a>
<a name="ln1034">    future&lt;_Res&amp;&gt;::share() noexcept</a>
<a name="ln1035">    { return shared_future&lt;_Res&amp;&gt;(std::move(*this)); }</a>
<a name="ln1036"> </a>
<a name="ln1037">  inline shared_future&lt;void&gt;</a>
<a name="ln1038">  future&lt;void&gt;::share() noexcept</a>
<a name="ln1039">  { return shared_future&lt;void&gt;(std::move(*this)); }</a>
<a name="ln1040"> </a>
<a name="ln1041">  /// Primary template for promise</a>
<a name="ln1042">  template&lt;typename _Res&gt;</a>
<a name="ln1043">    class promise</a>
<a name="ln1044">    {</a>
<a name="ln1045">      typedef __future_base::_State_base 	_State;</a>
<a name="ln1046">      typedef __future_base::_Result&lt;_Res&gt;	_Res_type;</a>
<a name="ln1047">      typedef __future_base::_Ptr&lt;_Res_type&gt;	_Ptr_type;</a>
<a name="ln1048">      template&lt;typename, typename&gt; friend class _State::_Setter;</a>
<a name="ln1049">      friend _State;</a>
<a name="ln1050"> </a>
<a name="ln1051">      shared_ptr&lt;_State&gt;                        _M_future;</a>
<a name="ln1052">      _Ptr_type                                 _M_storage;</a>
<a name="ln1053"> </a>
<a name="ln1054">    public:</a>
<a name="ln1055">      promise()</a>
<a name="ln1056">      : _M_future(std::make_shared&lt;_State&gt;()),</a>
<a name="ln1057">	_M_storage(new _Res_type())</a>
<a name="ln1058">      { }</a>
<a name="ln1059"> </a>
<a name="ln1060">      promise(promise&amp;&amp; __rhs) noexcept</a>
<a name="ln1061">      : _M_future(std::move(__rhs._M_future)),</a>
<a name="ln1062">	_M_storage(std::move(__rhs._M_storage))</a>
<a name="ln1063">      { }</a>
<a name="ln1064"> </a>
<a name="ln1065">      template&lt;typename _Allocator&gt;</a>
<a name="ln1066">        promise(allocator_arg_t, const _Allocator&amp; __a)</a>
<a name="ln1067">        : _M_future(std::allocate_shared&lt;_State&gt;(__a)),</a>
<a name="ln1068">	  _M_storage(__future_base::_S_allocate_result&lt;_Res&gt;(__a))</a>
<a name="ln1069">        { }</a>
<a name="ln1070"> </a>
<a name="ln1071">      template&lt;typename _Allocator&gt;</a>
<a name="ln1072">        promise(allocator_arg_t, const _Allocator&amp;, promise&amp;&amp; __rhs)</a>
<a name="ln1073">        : _M_future(std::move(__rhs._M_future)),</a>
<a name="ln1074">	  _M_storage(std::move(__rhs._M_storage))</a>
<a name="ln1075">        { }</a>
<a name="ln1076"> </a>
<a name="ln1077">      promise(const promise&amp;) = delete;</a>
<a name="ln1078"> </a>
<a name="ln1079">      ~promise()</a>
<a name="ln1080">      {</a>
<a name="ln1081">        if (static_cast&lt;bool&gt;(_M_future) &amp;&amp; !_M_future.unique())</a>
<a name="ln1082">          _M_future-&gt;_M_break_promise(std::move(_M_storage));</a>
<a name="ln1083">      }</a>
<a name="ln1084"> </a>
<a name="ln1085">      // Assignment</a>
<a name="ln1086">      promise&amp;</a>
<a name="ln1087">      operator=(promise&amp;&amp; __rhs) noexcept</a>
<a name="ln1088">      {</a>
<a name="ln1089">        promise(std::move(__rhs)).swap(*this);</a>
<a name="ln1090">        return *this;</a>
<a name="ln1091">      }</a>
<a name="ln1092"> </a>
<a name="ln1093">      promise&amp; operator=(const promise&amp;) = delete;</a>
<a name="ln1094"> </a>
<a name="ln1095">      void</a>
<a name="ln1096">      swap(promise&amp; __rhs) noexcept</a>
<a name="ln1097">      {</a>
<a name="ln1098">        _M_future.swap(__rhs._M_future);</a>
<a name="ln1099">        _M_storage.swap(__rhs._M_storage);</a>
<a name="ln1100">      }</a>
<a name="ln1101"> </a>
<a name="ln1102">      // Retrieving the result</a>
<a name="ln1103">      future&lt;_Res&gt;</a>
<a name="ln1104">      get_future()</a>
<a name="ln1105">      { return future&lt;_Res&gt;(_M_future); }</a>
<a name="ln1106"> </a>
<a name="ln1107">      // Setting the result</a>
<a name="ln1108">      void</a>
<a name="ln1109">      set_value(const _Res&amp; __r)</a>
<a name="ln1110">      { _M_future-&gt;_M_set_result(_State::__setter(this, __r)); }</a>
<a name="ln1111"> </a>
<a name="ln1112">      void</a>
<a name="ln1113">      set_value(_Res&amp;&amp; __r)</a>
<a name="ln1114">      { _M_future-&gt;_M_set_result(_State::__setter(this, std::move(__r))); }</a>
<a name="ln1115"> </a>
<a name="ln1116">      void</a>
<a name="ln1117">      set_exception(exception_ptr __p)</a>
<a name="ln1118">      { _M_future-&gt;_M_set_result(_State::__setter(__p, this)); }</a>
<a name="ln1119"> </a>
<a name="ln1120">      void</a>
<a name="ln1121">      set_value_at_thread_exit(const _Res&amp; __r)</a>
<a name="ln1122">      {</a>
<a name="ln1123">	_M_future-&gt;_M_set_delayed_result(_State::__setter(this, __r),</a>
<a name="ln1124">					 _M_future);</a>
<a name="ln1125">      }</a>
<a name="ln1126"> </a>
<a name="ln1127">      void</a>
<a name="ln1128">      set_value_at_thread_exit(_Res&amp;&amp; __r)</a>
<a name="ln1129">      {</a>
<a name="ln1130">	_M_future-&gt;_M_set_delayed_result(</a>
<a name="ln1131">	    _State::__setter(this, std::move(__r)), _M_future);</a>
<a name="ln1132">      }</a>
<a name="ln1133"> </a>
<a name="ln1134">      void</a>
<a name="ln1135">      set_exception_at_thread_exit(exception_ptr __p)</a>
<a name="ln1136">      {</a>
<a name="ln1137">	_M_future-&gt;_M_set_delayed_result(_State::__setter(__p, this),</a>
<a name="ln1138">					 _M_future);</a>
<a name="ln1139">      }</a>
<a name="ln1140">    };</a>
<a name="ln1141"> </a>
<a name="ln1142">  template&lt;typename _Res&gt;</a>
<a name="ln1143">    inline void</a>
<a name="ln1144">    swap(promise&lt;_Res&gt;&amp; __x, promise&lt;_Res&gt;&amp; __y) noexcept</a>
<a name="ln1145">    { __x.swap(__y); }</a>
<a name="ln1146"> </a>
<a name="ln1147">  template&lt;typename _Res, typename _Alloc&gt;</a>
<a name="ln1148">    struct uses_allocator&lt;promise&lt;_Res&gt;, _Alloc&gt;</a>
<a name="ln1149">    : public true_type { };</a>
<a name="ln1150"> </a>
<a name="ln1151"> </a>
<a name="ln1152">  /// Partial specialization for promise&lt;R&amp;&gt;</a>
<a name="ln1153">  template&lt;typename _Res&gt;</a>
<a name="ln1154">    class promise&lt;_Res&amp;&gt;</a>
<a name="ln1155">    {</a>
<a name="ln1156">      typedef __future_base::_State_base	_State;</a>
<a name="ln1157">      typedef __future_base::_Result&lt;_Res&amp;&gt;	_Res_type;</a>
<a name="ln1158">      typedef __future_base::_Ptr&lt;_Res_type&gt; 	_Ptr_type;</a>
<a name="ln1159">      template&lt;typename, typename&gt; friend class _State::_Setter;</a>
<a name="ln1160">      friend _State;</a>
<a name="ln1161"> </a>
<a name="ln1162">      shared_ptr&lt;_State&gt;                        _M_future;</a>
<a name="ln1163">      _Ptr_type                                 _M_storage;</a>
<a name="ln1164"> </a>
<a name="ln1165">    public:</a>
<a name="ln1166">      promise()</a>
<a name="ln1167">      : _M_future(std::make_shared&lt;_State&gt;()),</a>
<a name="ln1168">	_M_storage(new _Res_type())</a>
<a name="ln1169">      { }</a>
<a name="ln1170"> </a>
<a name="ln1171">      promise(promise&amp;&amp; __rhs) noexcept</a>
<a name="ln1172">      : _M_future(std::move(__rhs._M_future)),</a>
<a name="ln1173">	_M_storage(std::move(__rhs._M_storage))</a>
<a name="ln1174">      { }</a>
<a name="ln1175"> </a>
<a name="ln1176">      template&lt;typename _Allocator&gt;</a>
<a name="ln1177">        promise(allocator_arg_t, const _Allocator&amp; __a)</a>
<a name="ln1178">        : _M_future(std::allocate_shared&lt;_State&gt;(__a)),</a>
<a name="ln1179">	  _M_storage(__future_base::_S_allocate_result&lt;_Res&amp;&gt;(__a))</a>
<a name="ln1180">        { }</a>
<a name="ln1181"> </a>
<a name="ln1182">      template&lt;typename _Allocator&gt;</a>
<a name="ln1183">        promise(allocator_arg_t, const _Allocator&amp;, promise&amp;&amp; __rhs)</a>
<a name="ln1184">        : _M_future(std::move(__rhs._M_future)),</a>
<a name="ln1185">	  _M_storage(std::move(__rhs._M_storage))</a>
<a name="ln1186">        { }</a>
<a name="ln1187"> </a>
<a name="ln1188">      promise(const promise&amp;) = delete;</a>
<a name="ln1189"> </a>
<a name="ln1190">      ~promise()</a>
<a name="ln1191">      {</a>
<a name="ln1192">        if (static_cast&lt;bool&gt;(_M_future) &amp;&amp; !_M_future.unique())</a>
<a name="ln1193">          _M_future-&gt;_M_break_promise(std::move(_M_storage));</a>
<a name="ln1194">      }</a>
<a name="ln1195"> </a>
<a name="ln1196">      // Assignment</a>
<a name="ln1197">      promise&amp;</a>
<a name="ln1198">      operator=(promise&amp;&amp; __rhs) noexcept</a>
<a name="ln1199">      {</a>
<a name="ln1200">        promise(std::move(__rhs)).swap(*this);</a>
<a name="ln1201">        return *this;</a>
<a name="ln1202">      }</a>
<a name="ln1203"> </a>
<a name="ln1204">      promise&amp; operator=(const promise&amp;) = delete;</a>
<a name="ln1205"> </a>
<a name="ln1206">      void</a>
<a name="ln1207">      swap(promise&amp; __rhs) noexcept</a>
<a name="ln1208">      {</a>
<a name="ln1209">        _M_future.swap(__rhs._M_future);</a>
<a name="ln1210">        _M_storage.swap(__rhs._M_storage);</a>
<a name="ln1211">      }</a>
<a name="ln1212"> </a>
<a name="ln1213">      // Retrieving the result</a>
<a name="ln1214">      future&lt;_Res&amp;&gt;</a>
<a name="ln1215">      get_future()</a>
<a name="ln1216">      { return future&lt;_Res&amp;&gt;(_M_future); }</a>
<a name="ln1217"> </a>
<a name="ln1218">      // Setting the result</a>
<a name="ln1219">      void</a>
<a name="ln1220">      set_value(_Res&amp; __r)</a>
<a name="ln1221">      { _M_future-&gt;_M_set_result(_State::__setter(this, __r)); }</a>
<a name="ln1222"> </a>
<a name="ln1223">      void</a>
<a name="ln1224">      set_exception(exception_ptr __p)</a>
<a name="ln1225">      { _M_future-&gt;_M_set_result(_State::__setter(__p, this)); }</a>
<a name="ln1226"> </a>
<a name="ln1227">      void</a>
<a name="ln1228">      set_value_at_thread_exit(_Res&amp; __r)</a>
<a name="ln1229">      {</a>
<a name="ln1230">	_M_future-&gt;_M_set_delayed_result(_State::__setter(this, __r),</a>
<a name="ln1231">					 _M_future);</a>
<a name="ln1232">      }</a>
<a name="ln1233"> </a>
<a name="ln1234">      void</a>
<a name="ln1235">      set_exception_at_thread_exit(exception_ptr __p)</a>
<a name="ln1236">      {</a>
<a name="ln1237">	_M_future-&gt;_M_set_delayed_result(_State::__setter(__p, this),</a>
<a name="ln1238">					 _M_future);</a>
<a name="ln1239">      }</a>
<a name="ln1240">    };</a>
<a name="ln1241"> </a>
<a name="ln1242">  /// Explicit specialization for promise&lt;void&gt;</a>
<a name="ln1243">  template&lt;&gt;</a>
<a name="ln1244">    class promise&lt;void&gt;</a>
<a name="ln1245">    {</a>
<a name="ln1246">      typedef __future_base::_State_base	_State;</a>
<a name="ln1247">      typedef __future_base::_Result&lt;void&gt;	_Res_type;</a>
<a name="ln1248">      typedef __future_base::_Ptr&lt;_Res_type&gt; 	_Ptr_type;</a>
<a name="ln1249">      template&lt;typename, typename&gt; friend class _State::_Setter;</a>
<a name="ln1250">      friend _State;</a>
<a name="ln1251"> </a>
<a name="ln1252">      shared_ptr&lt;_State&gt;                        _M_future;</a>
<a name="ln1253">      _Ptr_type                                 _M_storage;</a>
<a name="ln1254"> </a>
<a name="ln1255">    public:</a>
<a name="ln1256">      promise()</a>
<a name="ln1257">      : _M_future(std::make_shared&lt;_State&gt;()),</a>
<a name="ln1258">	_M_storage(new _Res_type())</a>
<a name="ln1259">      { }</a>
<a name="ln1260"> </a>
<a name="ln1261">      promise(promise&amp;&amp; __rhs) noexcept</a>
<a name="ln1262">      : _M_future(std::move(__rhs._M_future)),</a>
<a name="ln1263">	_M_storage(std::move(__rhs._M_storage))</a>
<a name="ln1264">      { }</a>
<a name="ln1265"> </a>
<a name="ln1266">      template&lt;typename _Allocator&gt;</a>
<a name="ln1267">        promise(allocator_arg_t, const _Allocator&amp; __a)</a>
<a name="ln1268">        : _M_future(std::allocate_shared&lt;_State&gt;(__a)),</a>
<a name="ln1269">	  _M_storage(__future_base::_S_allocate_result&lt;void&gt;(__a))</a>
<a name="ln1270">        { }</a>
<a name="ln1271"> </a>
<a name="ln1272">      // _GLIBCXX_RESOLVE_LIB_DEFECTS</a>
<a name="ln1273">      // 2095.  missing constructors needed for uses-allocator construction</a>
<a name="ln1274">      template&lt;typename _Allocator&gt;</a>
<a name="ln1275">        promise(allocator_arg_t, const _Allocator&amp;, promise&amp;&amp; __rhs)</a>
<a name="ln1276">        : _M_future(std::move(__rhs._M_future)),</a>
<a name="ln1277">	  _M_storage(std::move(__rhs._M_storage))</a>
<a name="ln1278">        { }</a>
<a name="ln1279"> </a>
<a name="ln1280">      promise(const promise&amp;) = delete;</a>
<a name="ln1281"> </a>
<a name="ln1282">      ~promise()</a>
<a name="ln1283">      {</a>
<a name="ln1284">        if (static_cast&lt;bool&gt;(_M_future) &amp;&amp; !_M_future.unique())</a>
<a name="ln1285">          _M_future-&gt;_M_break_promise(std::move(_M_storage));</a>
<a name="ln1286">      }</a>
<a name="ln1287"> </a>
<a name="ln1288">      // Assignment</a>
<a name="ln1289">      promise&amp;</a>
<a name="ln1290">      operator=(promise&amp;&amp; __rhs) noexcept</a>
<a name="ln1291">      {</a>
<a name="ln1292">        promise(std::move(__rhs)).swap(*this);</a>
<a name="ln1293">        return *this;</a>
<a name="ln1294">      }</a>
<a name="ln1295"> </a>
<a name="ln1296">      promise&amp; operator=(const promise&amp;) = delete;</a>
<a name="ln1297"> </a>
<a name="ln1298">      void</a>
<a name="ln1299">      swap(promise&amp; __rhs) noexcept</a>
<a name="ln1300">      {</a>
<a name="ln1301">        _M_future.swap(__rhs._M_future);</a>
<a name="ln1302">        _M_storage.swap(__rhs._M_storage);</a>
<a name="ln1303">      }</a>
<a name="ln1304"> </a>
<a name="ln1305">      // Retrieving the result</a>
<a name="ln1306">      future&lt;void&gt;</a>
<a name="ln1307">      get_future()</a>
<a name="ln1308">      { return future&lt;void&gt;(_M_future); }</a>
<a name="ln1309"> </a>
<a name="ln1310">      // Setting the result</a>
<a name="ln1311">      void</a>
<a name="ln1312">      set_value()</a>
<a name="ln1313">      { _M_future-&gt;_M_set_result(_State::__setter(this)); }</a>
<a name="ln1314"> </a>
<a name="ln1315">      void</a>
<a name="ln1316">      set_exception(exception_ptr __p)</a>
<a name="ln1317">      { _M_future-&gt;_M_set_result(_State::__setter(__p, this)); }</a>
<a name="ln1318"> </a>
<a name="ln1319">      void</a>
<a name="ln1320">      set_value_at_thread_exit()</a>
<a name="ln1321">      { _M_future-&gt;_M_set_delayed_result(_State::__setter(this), _M_future); }</a>
<a name="ln1322"> </a>
<a name="ln1323">      void</a>
<a name="ln1324">      set_exception_at_thread_exit(exception_ptr __p)</a>
<a name="ln1325">      {</a>
<a name="ln1326">	_M_future-&gt;_M_set_delayed_result(_State::__setter(__p, this),</a>
<a name="ln1327">					 _M_future);</a>
<a name="ln1328">      }</a>
<a name="ln1329">    };</a>
<a name="ln1330"> </a>
<a name="ln1331">  template&lt;typename _Ptr_type, typename _Fn, typename _Res&gt;</a>
<a name="ln1332">    struct __future_base::_Task_setter</a>
<a name="ln1333">    {</a>
<a name="ln1334">      // Invoke the function and provide the result to the caller.</a>
<a name="ln1335">      _Ptr_type operator()() const</a>
<a name="ln1336">      {</a>
<a name="ln1337">	__try</a>
<a name="ln1338">	  {</a>
<a name="ln1339">	    (*_M_result)-&gt;_M_set((*_M_fn)());</a>
<a name="ln1340">	  }</a>
<a name="ln1341">	__catch(const __cxxabiv1::__forced_unwind&amp;)</a>
<a name="ln1342">	  {</a>
<a name="ln1343">	    __throw_exception_again; // will cause broken_promise</a>
<a name="ln1344">	  }</a>
<a name="ln1345">	__catch(...)</a>
<a name="ln1346">	  {</a>
<a name="ln1347">	    (*_M_result)-&gt;_M_error = current_exception();</a>
<a name="ln1348">	  }</a>
<a name="ln1349">	return std::move(*_M_result);</a>
<a name="ln1350">      }</a>
<a name="ln1351">      _Ptr_type*	_M_result;</a>
<a name="ln1352">      _Fn*		_M_fn;</a>
<a name="ln1353">    };</a>
<a name="ln1354"> </a>
<a name="ln1355">  template&lt;typename _Ptr_type, typename _Fn&gt;</a>
<a name="ln1356">    struct __future_base::_Task_setter&lt;_Ptr_type, _Fn, void&gt;</a>
<a name="ln1357">    {</a>
<a name="ln1358">      _Ptr_type operator()() const</a>
<a name="ln1359">      {</a>
<a name="ln1360">	__try</a>
<a name="ln1361">	  {</a>
<a name="ln1362">	    (*_M_fn)();</a>
<a name="ln1363">	  }</a>
<a name="ln1364">	__catch(const __cxxabiv1::__forced_unwind&amp;)</a>
<a name="ln1365">	  {</a>
<a name="ln1366">	    __throw_exception_again; // will cause broken_promise</a>
<a name="ln1367">	  }</a>
<a name="ln1368">	__catch(...)</a>
<a name="ln1369">	  {</a>
<a name="ln1370">	    (*_M_result)-&gt;_M_error = current_exception();</a>
<a name="ln1371">	  }</a>
<a name="ln1372">	return std::move(*_M_result);</a>
<a name="ln1373">      }</a>
<a name="ln1374">      _Ptr_type*	_M_result;</a>
<a name="ln1375">      _Fn*		_M_fn;</a>
<a name="ln1376">    };</a>
<a name="ln1377"> </a>
<a name="ln1378">  // Holds storage for a packaged_task's result.</a>
<a name="ln1379">  template&lt;typename _Res, typename... _Args&gt;</a>
<a name="ln1380">    struct __future_base::_Task_state_base&lt;_Res(_Args...)&gt;</a>
<a name="ln1381">    : __future_base::_State_base</a>
<a name="ln1382">    {</a>
<a name="ln1383">      typedef _Res _Res_type;</a>
<a name="ln1384"> </a>
<a name="ln1385">      template&lt;typename _Alloc&gt;</a>
<a name="ln1386">	_Task_state_base(const _Alloc&amp; __a)</a>
<a name="ln1387">	: _M_result(_S_allocate_result&lt;_Res&gt;(__a))</a>
<a name="ln1388">	{ }</a>
<a name="ln1389"> </a>
<a name="ln1390">      // Invoke the stored task and make the state ready.</a>
<a name="ln1391">      virtual void</a>
<a name="ln1392">      _M_run(_Args&amp;&amp;... __args) = 0;</a>
<a name="ln1393"> </a>
<a name="ln1394">      // Invoke the stored task and make the state ready at thread exit.</a>
<a name="ln1395">      virtual void</a>
<a name="ln1396">      _M_run_delayed(_Args&amp;&amp;... __args, weak_ptr&lt;_State_base&gt;) = 0;</a>
<a name="ln1397"> </a>
<a name="ln1398">      virtual shared_ptr&lt;_Task_state_base&gt;</a>
<a name="ln1399">      _M_reset() = 0;</a>
<a name="ln1400"> </a>
<a name="ln1401">      typedef __future_base::_Ptr&lt;_Result&lt;_Res&gt;&gt; _Ptr_type;</a>
<a name="ln1402">      _Ptr_type _M_result;</a>
<a name="ln1403">    };</a>
<a name="ln1404"> </a>
<a name="ln1405">  // Holds a packaged_task's stored task.</a>
<a name="ln1406">  template&lt;typename _Fn, typename _Alloc, typename _Res, typename... _Args&gt;</a>
<a name="ln1407">    struct __future_base::_Task_state&lt;_Fn, _Alloc, _Res(_Args...)&gt; final</a>
<a name="ln1408">    : __future_base::_Task_state_base&lt;_Res(_Args...)&gt;</a>
<a name="ln1409">    {</a>
<a name="ln1410">      template&lt;typename _Fn2&gt;</a>
<a name="ln1411">	_Task_state(_Fn2&amp;&amp; __fn, const _Alloc&amp; __a)</a>
<a name="ln1412">	: _Task_state_base&lt;_Res(_Args...)&gt;(__a),</a>
<a name="ln1413">	  _M_impl(std::forward&lt;_Fn2&gt;(__fn), __a)</a>
<a name="ln1414">	{ }</a>
<a name="ln1415"> </a>
<a name="ln1416">    private:</a>
<a name="ln1417">      virtual void</a>
<a name="ln1418">      _M_run(_Args&amp;&amp;... __args)</a>
<a name="ln1419">      {</a>
<a name="ln1420">	auto __boundfn = [&amp;] () -&gt; typename result_of&lt;_Fn&amp;(_Args&amp;&amp;...)&gt;::type {</a>
<a name="ln1421">	    return std::__invoke(_M_impl._M_fn, std::forward&lt;_Args&gt;(__args)...);</a>
<a name="ln1422">	};</a>
<a name="ln1423">	this-&gt;_M_set_result(_S_task_setter(this-&gt;_M_result, __boundfn));</a>
<a name="ln1424">      }</a>
<a name="ln1425"> </a>
<a name="ln1426">      virtual void</a>
<a name="ln1427">      _M_run_delayed(_Args&amp;&amp;... __args, weak_ptr&lt;_State_base&gt; __self)</a>
<a name="ln1428">      {</a>
<a name="ln1429">	auto __boundfn = [&amp;] () -&gt; typename result_of&lt;_Fn&amp;(_Args&amp;&amp;...)&gt;::type {</a>
<a name="ln1430">	    return std::__invoke(_M_impl._M_fn, std::forward&lt;_Args&gt;(__args)...);</a>
<a name="ln1431">	};</a>
<a name="ln1432">	this-&gt;_M_set_delayed_result(_S_task_setter(this-&gt;_M_result, __boundfn),</a>
<a name="ln1433">				    std::move(__self));</a>
<a name="ln1434">      }</a>
<a name="ln1435"> </a>
<a name="ln1436">      virtual shared_ptr&lt;_Task_state_base&lt;_Res(_Args...)&gt;&gt;</a>
<a name="ln1437">      _M_reset();</a>
<a name="ln1438"> </a>
<a name="ln1439">      struct _Impl : _Alloc</a>
<a name="ln1440">      {</a>
<a name="ln1441">	template&lt;typename _Fn2&gt;</a>
<a name="ln1442">	  _Impl(_Fn2&amp;&amp; __fn, const _Alloc&amp; __a)</a>
<a name="ln1443">	  : _Alloc(__a), _M_fn(std::forward&lt;_Fn2&gt;(__fn)) { }</a>
<a name="ln1444">	_Fn _M_fn;</a>
<a name="ln1445">      } _M_impl;</a>
<a name="ln1446">    };</a>
<a name="ln1447"> </a>
<a name="ln1448">  template&lt;typename _Signature, typename _Fn, typename _Alloc&gt;</a>
<a name="ln1449">    static shared_ptr&lt;__future_base::_Task_state_base&lt;_Signature&gt;&gt;</a>
<a name="ln1450">    __create_task_state(_Fn&amp;&amp; __fn, const _Alloc&amp; __a)</a>
<a name="ln1451">    {</a>
<a name="ln1452">      typedef typename decay&lt;_Fn&gt;::type _Fn2;</a>
<a name="ln1453">      typedef __future_base::_Task_state&lt;_Fn2, _Alloc, _Signature&gt; _State;</a>
<a name="ln1454">      return std::allocate_shared&lt;_State&gt;(__a, std::forward&lt;_Fn&gt;(__fn), __a);</a>
<a name="ln1455">    }</a>
<a name="ln1456"> </a>
<a name="ln1457">  template&lt;typename _Fn, typename _Alloc, typename _Res, typename... _Args&gt;</a>
<a name="ln1458">    shared_ptr&lt;__future_base::_Task_state_base&lt;_Res(_Args...)&gt;&gt;</a>
<a name="ln1459">    __future_base::_Task_state&lt;_Fn, _Alloc, _Res(_Args...)&gt;::_M_reset()</a>
<a name="ln1460">    {</a>
<a name="ln1461">      return __create_task_state&lt;_Res(_Args...)&gt;(std::move(_M_impl._M_fn),</a>
<a name="ln1462">						 static_cast&lt;_Alloc&amp;&gt;(_M_impl));</a>
<a name="ln1463">    }</a>
<a name="ln1464"> </a>
<a name="ln1465">  template&lt;typename _Task, typename _Fn, bool</a>
<a name="ln1466">	   = is_same&lt;_Task, typename decay&lt;_Fn&gt;::type&gt;::value&gt;</a>
<a name="ln1467">    struct __constrain_pkgdtask</a>
<a name="ln1468">    { typedef void __type; };</a>
<a name="ln1469"> </a>
<a name="ln1470">  template&lt;typename _Task, typename _Fn&gt;</a>
<a name="ln1471">    struct __constrain_pkgdtask&lt;_Task, _Fn, true&gt;</a>
<a name="ln1472">    { };</a>
<a name="ln1473"> </a>
<a name="ln1474">  /// packaged_task</a>
<a name="ln1475">  template&lt;typename _Res, typename... _ArgTypes&gt;</a>
<a name="ln1476">    class packaged_task&lt;_Res(_ArgTypes...)&gt;</a>
<a name="ln1477">    {</a>
<a name="ln1478">      typedef __future_base::_Task_state_base&lt;_Res(_ArgTypes...)&gt; _State_type;</a>
<a name="ln1479">      shared_ptr&lt;_State_type&gt;                   _M_state;</a>
<a name="ln1480"> </a>
<a name="ln1481">    public:</a>
<a name="ln1482">      // Construction and destruction</a>
<a name="ln1483">      packaged_task() noexcept { }</a>
<a name="ln1484"> </a>
<a name="ln1485">      // _GLIBCXX_RESOLVE_LIB_DEFECTS</a>
<a name="ln1486">      // 2095.  missing constructors needed for uses-allocator construction</a>
<a name="ln1487">      template&lt;typename _Allocator&gt;</a>
<a name="ln1488">	packaged_task(allocator_arg_t, const _Allocator&amp; __a) noexcept</a>
<a name="ln1489">	{ }</a>
<a name="ln1490"> </a>
<a name="ln1491">      template&lt;typename _Fn, typename = typename</a>
<a name="ln1492">	       __constrain_pkgdtask&lt;packaged_task, _Fn&gt;::__type&gt;</a>
<a name="ln1493">	explicit</a>
<a name="ln1494">	packaged_task(_Fn&amp;&amp; __fn)</a>
<a name="ln1495">	: packaged_task(allocator_arg, std::allocator&lt;int&gt;(),</a>
<a name="ln1496">			std::forward&lt;_Fn&gt;(__fn))</a>
<a name="ln1497">	{ }</a>
<a name="ln1498"> </a>
<a name="ln1499">      // _GLIBCXX_RESOLVE_LIB_DEFECTS</a>
<a name="ln1500">      // 2097.  packaged_task constructors should be constrained</a>
<a name="ln1501">      // 2407. [this constructor should not be] explicit</a>
<a name="ln1502">      template&lt;typename _Fn, typename _Alloc, typename = typename</a>
<a name="ln1503">	       __constrain_pkgdtask&lt;packaged_task, _Fn&gt;::__type&gt;</a>
<a name="ln1504">	packaged_task(allocator_arg_t, const _Alloc&amp; __a, _Fn&amp;&amp; __fn)</a>
<a name="ln1505">	: _M_state(__create_task_state&lt;_Res(_ArgTypes...)&gt;(</a>
<a name="ln1506">		    std::forward&lt;_Fn&gt;(__fn), __a))</a>
<a name="ln1507">	{ }</a>
<a name="ln1508"> </a>
<a name="ln1509">      ~packaged_task()</a>
<a name="ln1510">      {</a>
<a name="ln1511">        if (static_cast&lt;bool&gt;(_M_state) &amp;&amp; !_M_state.unique())</a>
<a name="ln1512">	  _M_state-&gt;_M_break_promise(std::move(_M_state-&gt;_M_result));</a>
<a name="ln1513">      }</a>
<a name="ln1514"> </a>
<a name="ln1515">      // No copy</a>
<a name="ln1516">      packaged_task(const packaged_task&amp;) = delete;</a>
<a name="ln1517">      packaged_task&amp; operator=(const packaged_task&amp;) = delete;</a>
<a name="ln1518"> </a>
<a name="ln1519">      template&lt;typename _Allocator&gt;</a>
<a name="ln1520">	packaged_task(allocator_arg_t, const _Allocator&amp;,</a>
<a name="ln1521">		      const packaged_task&amp;) = delete;</a>
<a name="ln1522"> </a>
<a name="ln1523">      // Move support</a>
<a name="ln1524">      packaged_task(packaged_task&amp;&amp; __other) noexcept</a>
<a name="ln1525">      { this-&gt;swap(__other); }</a>
<a name="ln1526"> </a>
<a name="ln1527">      template&lt;typename _Allocator&gt;</a>
<a name="ln1528">	packaged_task(allocator_arg_t, const _Allocator&amp;,</a>
<a name="ln1529">		      packaged_task&amp;&amp; __other) noexcept</a>
<a name="ln1530">	{ this-&gt;swap(__other); }</a>
<a name="ln1531"> </a>
<a name="ln1532">      packaged_task&amp; operator=(packaged_task&amp;&amp; __other) noexcept</a>
<a name="ln1533">      {</a>
<a name="ln1534">	packaged_task(std::move(__other)).swap(*this);</a>
<a name="ln1535">	return *this;</a>
<a name="ln1536">      }</a>
<a name="ln1537"> </a>
<a name="ln1538">      void</a>
<a name="ln1539">      swap(packaged_task&amp; __other) noexcept</a>
<a name="ln1540">      { _M_state.swap(__other._M_state); }</a>
<a name="ln1541"> </a>
<a name="ln1542">      bool</a>
<a name="ln1543">      valid() const noexcept</a>
<a name="ln1544">      { return static_cast&lt;bool&gt;(_M_state); }</a>
<a name="ln1545"> </a>
<a name="ln1546">      // Result retrieval</a>
<a name="ln1547">      future&lt;_Res&gt;</a>
<a name="ln1548">      get_future()</a>
<a name="ln1549">      { return future&lt;_Res&gt;(_M_state); }</a>
<a name="ln1550"> </a>
<a name="ln1551">      // Execution</a>
<a name="ln1552">      void</a>
<a name="ln1553">      operator()(_ArgTypes... __args)</a>
<a name="ln1554">      {</a>
<a name="ln1555">	__future_base::_State_base::_S_check(_M_state);</a>
<a name="ln1556">	_M_state-&gt;_M_run(std::forward&lt;_ArgTypes&gt;(__args)...);</a>
<a name="ln1557">      }</a>
<a name="ln1558"> </a>
<a name="ln1559">      void</a>
<a name="ln1560">      make_ready_at_thread_exit(_ArgTypes... __args)</a>
<a name="ln1561">      {</a>
<a name="ln1562">	__future_base::_State_base::_S_check(_M_state);</a>
<a name="ln1563">	_M_state-&gt;_M_run_delayed(std::forward&lt;_ArgTypes&gt;(__args)..., _M_state);</a>
<a name="ln1564">      }</a>
<a name="ln1565"> </a>
<a name="ln1566">      void</a>
<a name="ln1567">      reset()</a>
<a name="ln1568">      {</a>
<a name="ln1569">	__future_base::_State_base::_S_check(_M_state);</a>
<a name="ln1570">	packaged_task __tmp;</a>
<a name="ln1571">	__tmp._M_state = _M_state;</a>
<a name="ln1572">	_M_state = _M_state-&gt;_M_reset();</a>
<a name="ln1573">      }</a>
<a name="ln1574">    };</a>
<a name="ln1575"> </a>
<a name="ln1576">  /// swap</a>
<a name="ln1577">  template&lt;typename _Res, typename... _ArgTypes&gt;</a>
<a name="ln1578">    inline void</a>
<a name="ln1579">    swap(packaged_task&lt;_Res(_ArgTypes...)&gt;&amp; __x,</a>
<a name="ln1580">	 packaged_task&lt;_Res(_ArgTypes...)&gt;&amp; __y) noexcept</a>
<a name="ln1581">    { __x.swap(__y); }</a>
<a name="ln1582"> </a>
<a name="ln1583">  template&lt;typename _Res, typename _Alloc&gt;</a>
<a name="ln1584">    struct uses_allocator&lt;packaged_task&lt;_Res&gt;, _Alloc&gt;</a>
<a name="ln1585">    : public true_type { };</a>
<a name="ln1586"> </a>
<a name="ln1587"> </a>
<a name="ln1588">  // Shared state created by std::async().</a>
<a name="ln1589">  // Holds a deferred function and storage for its result.</a>
<a name="ln1590">  template&lt;typename _BoundFn, typename _Res&gt;</a>
<a name="ln1591">    class __future_base::_Deferred_state final</a>
<a name="ln1592">    : public __future_base::_State_base</a>
<a name="ln1593">    {</a>
<a name="ln1594">    public:</a>
<a name="ln1595">      explicit</a>
<a name="ln1596">      _Deferred_state(_BoundFn&amp;&amp; __fn)</a>
<a name="ln1597">      : _M_result(new _Result&lt;_Res&gt;()), _M_fn(std::move(__fn))</a>
<a name="ln1598">      { }</a>
<a name="ln1599"> </a>
<a name="ln1600">    private:</a>
<a name="ln1601">      typedef __future_base::_Ptr&lt;_Result&lt;_Res&gt;&gt; _Ptr_type;</a>
<a name="ln1602">      _Ptr_type _M_result;</a>
<a name="ln1603">      _BoundFn _M_fn;</a>
<a name="ln1604"> </a>
<a name="ln1605">      // Run the deferred function.</a>
<a name="ln1606">      virtual void</a>
<a name="ln1607">      _M_complete_async()</a>
<a name="ln1608">      {</a>
<a name="ln1609">	// Multiple threads can call a waiting function on the future and</a>
<a name="ln1610">	// reach this point at the same time. The call_once in _M_set_result</a>
<a name="ln1611">	// ensures only the first one run the deferred function, stores the</a>
<a name="ln1612">	// result in _M_result, swaps that with the base _M_result and makes</a>
<a name="ln1613">	// the state ready. Tell _M_set_result to ignore failure so all later</a>
<a name="ln1614">	// calls do nothing.</a>
<a name="ln1615">        _M_set_result(_S_task_setter(_M_result, _M_fn), true);</a>
<a name="ln1616">      }</a>
<a name="ln1617"> </a>
<a name="ln1618">      // Caller should check whether the state is ready first, because this</a>
<a name="ln1619">      // function will return true even after the deferred function has run.</a>
<a name="ln1620">      virtual bool _M_is_deferred_future() const { return true; }</a>
<a name="ln1621">    };</a>
<a name="ln1622"> </a>
<a name="ln1623">  // Common functionality hoisted out of the _Async_state_impl template.</a>
<a name="ln1624">  class __future_base::_Async_state_commonV2</a>
<a name="ln1625">    : public __future_base::_State_base</a>
<a name="ln1626">  {</a>
<a name="ln1627">  protected:</a>
<a name="ln1628">    ~_Async_state_commonV2() = default;</a>
<a name="ln1629"> </a>
<a name="ln1630">    // Make waiting functions block until the thread completes, as if joined.</a>
<a name="ln1631">    //</a>
<a name="ln1632">    // This function is used by wait() to satisfy the first requirement below</a>
<a name="ln1633">    // and by wait_for() / wait_until() to satisfy the second.</a>
<a name="ln1634">    //</a>
<a name="ln1635">    // [futures.async]:</a>
<a name="ln1636">    //</a>
<a name="ln1637">    //  a call to a waiting function on an asynchronous return object that</a>
<a name="ln1638">    // shares the shared state created by this async call shall block until</a>
<a name="ln1639">    // the associated thread has completed, as if joined, or else time out.</a>
<a name="ln1640">    //</a>
<a name="ln1641">    //  the associated thread completion synchronizes with the return from</a>
<a name="ln1642">    // the first function that successfully detects the ready status of the</a>
<a name="ln1643">    // shared state or with the return from the last function that releases</a>
<a name="ln1644">    // the shared state, whichever happens first.</a>
<a name="ln1645">    virtual void _M_complete_async() { _M_join(); }</a>
<a name="ln1646"> </a>
<a name="ln1647">    void _M_join() { std::call_once(_M_once, &amp;thread::join, &amp;_M_thread); }</a>
<a name="ln1648"> </a>
<a name="ln1649">    thread _M_thread;</a>
<a name="ln1650">    once_flag _M_once;</a>
<a name="ln1651">  };</a>
<a name="ln1652"> </a>
<a name="ln1653">  // Shared state created by std::async().</a>
<a name="ln1654">  // Starts a new thread that runs a function and makes the shared state ready.</a>
<a name="ln1655">  template&lt;typename _BoundFn, typename _Res&gt;</a>
<a name="ln1656">    class __future_base::_Async_state_impl final</a>
<a name="ln1657">    : public __future_base::_Async_state_commonV2</a>
<a name="ln1658">    {</a>
<a name="ln1659">    public:</a>
<a name="ln1660">      explicit</a>
<a name="ln1661">      _Async_state_impl(_BoundFn&amp;&amp; __fn)</a>
<a name="ln1662">      : _M_result(new _Result&lt;_Res&gt;()), _M_fn(std::move(__fn))</a>
<a name="ln1663">      {</a>
<a name="ln1664">	_M_thread = std::thread{ [this] {</a>
<a name="ln1665">	    __try</a>
<a name="ln1666">	      {</a>
<a name="ln1667">		_M_set_result(_S_task_setter(_M_result, _M_fn));</a>
<a name="ln1668">	      }</a>
<a name="ln1669">	    __catch (const __cxxabiv1::__forced_unwind&amp;)</a>
<a name="ln1670">	      {</a>
<a name="ln1671">		// make the shared state ready on thread cancellation</a>
<a name="ln1672">		if (static_cast&lt;bool&gt;(_M_result))</a>
<a name="ln1673">		  this-&gt;_M_break_promise(std::move(_M_result));</a>
<a name="ln1674">		__throw_exception_again;</a>
<a name="ln1675">	      }</a>
<a name="ln1676">        } };</a>
<a name="ln1677">      }</a>
<a name="ln1678"> </a>
<a name="ln1679">      // Must not destroy _M_result and _M_fn until the thread finishes.</a>
<a name="ln1680">      // Call join() directly rather than through _M_join() because no other</a>
<a name="ln1681">      // thread can be referring to this state if it is being destroyed.</a>
<a name="ln1682">      ~_Async_state_impl() { if (_M_thread.joinable()) _M_thread.join(); }</a>
<a name="ln1683"> </a>
<a name="ln1684">    private:</a>
<a name="ln1685">      typedef __future_base::_Ptr&lt;_Result&lt;_Res&gt;&gt; _Ptr_type;</a>
<a name="ln1686">      _Ptr_type _M_result;</a>
<a name="ln1687">      _BoundFn _M_fn;</a>
<a name="ln1688">    };</a>
<a name="ln1689"> </a>
<a name="ln1690">  template&lt;typename _BoundFn&gt;</a>
<a name="ln1691">    inline std::shared_ptr&lt;__future_base::_State_base&gt;</a>
<a name="ln1692">    __future_base::_S_make_deferred_state(_BoundFn&amp;&amp; __fn)</a>
<a name="ln1693">    {</a>
<a name="ln1694">      typedef typename remove_reference&lt;_BoundFn&gt;::type __fn_type;</a>
<a name="ln1695">      typedef _Deferred_state&lt;__fn_type&gt; __state_type;</a>
<a name="ln1696">      return std::make_shared&lt;__state_type&gt;(std::move(__fn));</a>
<a name="ln1697">    }</a>
<a name="ln1698"> </a>
<a name="ln1699">  template&lt;typename _BoundFn&gt;</a>
<a name="ln1700">    inline std::shared_ptr&lt;__future_base::_State_base&gt;</a>
<a name="ln1701">    __future_base::_S_make_async_state(_BoundFn&amp;&amp; __fn)</a>
<a name="ln1702">    {</a>
<a name="ln1703">      typedef typename remove_reference&lt;_BoundFn&gt;::type __fn_type;</a>
<a name="ln1704">      typedef _Async_state_impl&lt;__fn_type&gt; __state_type;</a>
<a name="ln1705">      return std::make_shared&lt;__state_type&gt;(std::move(__fn));</a>
<a name="ln1706">    }</a>
<a name="ln1707"> </a>
<a name="ln1708"> </a>
<a name="ln1709">  /// async</a>
<a name="ln1710">  template&lt;typename _Fn, typename... _Args&gt;</a>
<a name="ln1711">    future&lt;__async_result_of&lt;_Fn, _Args...&gt;&gt;</a>
<a name="ln1712">    async(launch __policy, _Fn&amp;&amp; __fn, _Args&amp;&amp;... __args)</a>
<a name="ln1713">    {</a>
<a name="ln1714">      std::shared_ptr&lt;__future_base::_State_base&gt; __state;</a>
<a name="ln1715">      if ((__policy &amp; launch::async) == launch::async)</a>
<a name="ln1716">	{</a>
<a name="ln1717">	  __try</a>
<a name="ln1718">	    {</a>
<a name="ln1719">	      __state = __future_base::_S_make_async_state(</a>
<a name="ln1720">		  std::thread::__make_invoker(std::forward&lt;_Fn&gt;(__fn),</a>
<a name="ln1721">					      std::forward&lt;_Args&gt;(__args)...)</a>
<a name="ln1722">		  );</a>
<a name="ln1723">	    }</a>
<a name="ln1724">#if __cpp_exceptions</a>
<a name="ln1725">	  catch(const system_error&amp; __e)</a>
<a name="ln1726">	    {</a>
<a name="ln1727">	      if (__e.code() != errc::resource_unavailable_try_again</a>
<a name="ln1728">		  || (__policy &amp; launch::deferred) != launch::deferred)</a>
<a name="ln1729">		throw;</a>
<a name="ln1730">	    }</a>
<a name="ln1731">#endif</a>
<a name="ln1732">	}</a>
<a name="ln1733">      if (!__state)</a>
<a name="ln1734">	{</a>
<a name="ln1735">	  __state = __future_base::_S_make_deferred_state(</a>
<a name="ln1736">	      std::thread::__make_invoker(std::forward&lt;_Fn&gt;(__fn),</a>
<a name="ln1737">					  std::forward&lt;_Args&gt;(__args)...));</a>
<a name="ln1738">	}</a>
<a name="ln1739">      return future&lt;__async_result_of&lt;_Fn, _Args...&gt;&gt;(__state);</a>
<a name="ln1740">    }</a>
<a name="ln1741"> </a>
<a name="ln1742">  /// async, potential overload</a>
<a name="ln1743">  template&lt;typename _Fn, typename... _Args&gt;</a>
<a name="ln1744">    inline future&lt;__async_result_of&lt;_Fn, _Args...&gt;&gt;</a>
<a name="ln1745">    async(_Fn&amp;&amp; __fn, _Args&amp;&amp;... __args)</a>
<a name="ln1746">    {</a>
<a name="ln1747">      return std::async(launch::async|launch::deferred,</a>
<a name="ln1748">			std::forward&lt;_Fn&gt;(__fn),</a>
<a name="ln1749">			std::forward&lt;_Args&gt;(__args)...);</a>
<a name="ln1750">    }</a>
<a name="ln1751"> </a>
<a name="ln1752">#endif // _GLIBCXX_ASYNC_ABI_COMPAT</a>
<a name="ln1753">#endif // _GLIBCXX_HAS_GTHREADS &amp;&amp; _GLIBCXX_USE_C99_STDINT_TR1</a>
<a name="ln1754"> </a>
<a name="ln1755">  // @} group futures</a>
<a name="ln1756">_GLIBCXX_END_NAMESPACE_VERSION</a>
<a name="ln1757">} // namespace</a>
<a name="ln1758"> </a>
<a name="ln1759">#endif // C++11</a>
<a name="ln1760"> </a>
<a name="ln1761">#endif // _GLIBCXX_FUTURE</a>

</code></pre>
<div class="balloon" rel="428"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v530/" target="_blank">V530</a> The return value of function 'release' is required to be utilized.</p></div>
<div class="balloon" rel="294"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1001/" target="_blank">V1001</a> The '__guard' variable is assigned but is not used by the end of the function.</p></div>
<div class="balloon" rel="1407"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1052/" target="_blank">V1052</a> Declaring virtual methods in a class marked as 'final' is pointless. Consider inspecting the "_M_run, _M_run_delayed, _M_reset" methods of the '__future_base::_Task_state < _Fn, _Alloc, _Res (_Args) >' class.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
