
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ldb_cmd.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//  Copyright (c) 2011-present, Facebook, Inc.  All rights reserved.</a>
<a name="ln2">//  This source code is licensed under the BSD-style license found in the</a>
<a name="ln3">//  LICENSE file in the root directory of this source tree. An additional grant</a>
<a name="ln4">//  of patent rights can be found in the PATENTS file in the same directory.</a>
<a name="ln5">//</a>
<a name="ln6">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln7">//</a>
<a name="ln8">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln9">//</a>
<a name="ln10">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln11">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln12">//</a>
<a name="ln13">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln14">//</a>
<a name="ln15">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln16">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln17">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln18">// under the License.</a>
<a name="ln19">//</a>
<a name="ln20">#ifndef YB_ROCKSDB_TOOLS_LDB_CMD_H</a>
<a name="ln21">#define YB_ROCKSDB_TOOLS_LDB_CMD_H</a>
<a name="ln22"> </a>
<a name="ln23">#pragma once</a>
<a name="ln24"> </a>
<a name="ln25">#ifndef ROCKSDB_LITE</a>
<a name="ln26"> </a>
<a name="ln27">#include &lt;stdlib.h&gt;</a>
<a name="ln28">#include &lt;stdio.h&gt;</a>
<a name="ln29"> </a>
<a name="ln30">#include &lt;string&gt;</a>
<a name="ln31">#include &lt;iostream&gt;</a>
<a name="ln32">#include &lt;sstream&gt;</a>
<a name="ln33">#include &lt;algorithm&gt;</a>
<a name="ln34">#include &lt;vector&gt;</a>
<a name="ln35">#include &lt;map&gt;</a>
<a name="ln36"> </a>
<a name="ln37">#include &quot;yb/rocksdb/db/version_set.h&quot;</a>
<a name="ln38">#include &quot;yb/rocksdb/env.h&quot;</a>
<a name="ln39">#include &quot;yb/rocksdb/iterator.h&quot;</a>
<a name="ln40">#include &quot;yb/rocksdb/ldb_tool.h&quot;</a>
<a name="ln41">#include &quot;yb/rocksdb/options.h&quot;</a>
<a name="ln42">#include &quot;yb/rocksdb/utilities/db_ttl.h&quot;</a>
<a name="ln43">#include &quot;yb/rocksdb/tools/ldb_cmd_execute_result.h&quot;</a>
<a name="ln44">#include &quot;yb/rocksdb/util/logging.h&quot;</a>
<a name="ln45">#include &quot;yb/rocksdb/utilities/ttl/db_ttl_impl.h&quot;</a>
<a name="ln46">#include &quot;yb/util/header_manager_impl.h&quot;</a>
<a name="ln47">#include &quot;yb/util/slice.h&quot;</a>
<a name="ln48">#include &quot;yb/util/string_util.h&quot;</a>
<a name="ln49">#include &quot;yb/util/universe_key_manager.h&quot;</a>
<a name="ln50">#include &quot;yb/rocksutil/rocksdb_encrypted_file_factory.h&quot;</a>
<a name="ln51"> </a>
<a name="ln52">using std::string;</a>
<a name="ln53">using std::map;</a>
<a name="ln54">using std::vector;</a>
<a name="ln55">using std::ostringstream;</a>
<a name="ln56"> </a>
<a name="ln57">namespace rocksdb {</a>
<a name="ln58"> </a>
<a name="ln59">class LDBCommand {</a>
<a name="ln60"> public:</a>
<a name="ln61">  // Command-line arguments</a>
<a name="ln62">  static const string ARG_DB;</a>
<a name="ln63">  static const string ARG_PATH;</a>
<a name="ln64">  static const string ARG_HEX;</a>
<a name="ln65">  static const string ARG_KEY_HEX;</a>
<a name="ln66">  static const string ARG_VALUE_HEX;</a>
<a name="ln67">  static const string ARG_CF_NAME;</a>
<a name="ln68">  static const string ARG_TTL;</a>
<a name="ln69">  static const string ARG_TTL_START;</a>
<a name="ln70">  static const string ARG_TTL_END;</a>
<a name="ln71">  static const string ARG_TIMESTAMP;</a>
<a name="ln72">  static const string ARG_FROM;</a>
<a name="ln73">  static const string ARG_TO;</a>
<a name="ln74">  static const string ARG_MAX_KEYS;</a>
<a name="ln75">  static const string ARG_BLOOM_BITS;</a>
<a name="ln76">  static const string ARG_FIX_PREFIX_LEN;</a>
<a name="ln77">  static const string ARG_COMPRESSION_TYPE;</a>
<a name="ln78">  static const string ARG_BLOCK_SIZE;</a>
<a name="ln79">  static const string ARG_AUTO_COMPACTION;</a>
<a name="ln80">  static const string ARG_DB_WRITE_BUFFER_SIZE;</a>
<a name="ln81">  static const string ARG_WRITE_BUFFER_SIZE;</a>
<a name="ln82">  static const string ARG_FILE_SIZE;</a>
<a name="ln83">  static const string ARG_CREATE_IF_MISSING;</a>
<a name="ln84">  static const string ARG_NO_VALUE;</a>
<a name="ln85">  static const string ARG_UNIVERSE_KEY_FILE;</a>
<a name="ln86">  static const string ARG_ONLY_VERIFY_CHECKSUMS;</a>
<a name="ln87"> </a>
<a name="ln88">  static LDBCommand* InitFromCmdLineArgs(</a>
<a name="ln89">      const vector&lt;string&gt;&amp; args, const Options&amp; options,</a>
<a name="ln90">      const LDBOptions&amp; ldb_options,</a>
<a name="ln91">      const std::vector&lt;ColumnFamilyDescriptor&gt;* column_families);</a>
<a name="ln92"> </a>
<a name="ln93">  static LDBCommand* InitFromCmdLineArgs(</a>
<a name="ln94">      int argc, char** argv, const Options&amp; options,</a>
<a name="ln95">      const LDBOptions&amp; ldb_options,</a>
<a name="ln96">      const std::vector&lt;ColumnFamilyDescriptor&gt;* column_families);</a>
<a name="ln97"> </a>
<a name="ln98">  bool ValidateCmdLineOptions();</a>
<a name="ln99"> </a>
<a name="ln100">  virtual Options PrepareOptionsForOpenDB();</a>
<a name="ln101"> </a>
<a name="ln102">  virtual void SetDBOptions(Options options) {</a>
<a name="ln103">    options_ = options;</a>
<a name="ln104">  }</a>
<a name="ln105"> </a>
<a name="ln106">  virtual void SetColumnFamilies(</a>
<a name="ln107">      const std::vector&lt;ColumnFamilyDescriptor&gt;* column_families) {</a>
<a name="ln108">    if (column_families != nullptr) {</a>
<a name="ln109">      column_families_ = *column_families;</a>
<a name="ln110">    } else {</a>
<a name="ln111">      column_families_.clear();</a>
<a name="ln112">    }</a>
<a name="ln113">  }</a>
<a name="ln114"> </a>
<a name="ln115">  void SetLDBOptions(const LDBOptions&amp; ldb_options) {</a>
<a name="ln116">    ldb_options_ = ldb_options;</a>
<a name="ln117">  }</a>
<a name="ln118"> </a>
<a name="ln119">  virtual bool NoDBOpen() {</a>
<a name="ln120">    return false;</a>
<a name="ln121">  }</a>
<a name="ln122"> </a>
<a name="ln123">  virtual ~LDBCommand() { CloseDB(); }</a>
<a name="ln124"> </a>
<a name="ln125">  /* Run the command, and return the execute result. */</a>
<a name="ln126">  void Run() {</a>
<a name="ln127">    if (!exec_state_.IsNotStarted()) {</a>
<a name="ln128">      return;</a>
<a name="ln129">    }</a>
<a name="ln130"> </a>
<a name="ln131">    if (db_ == nullptr &amp;&amp; !NoDBOpen()) {</a>
<a name="ln132">      OpenDB();</a>
<a name="ln133">    }</a>
<a name="ln134"> </a>
<a name="ln135">    // We'll intentionally proceed even if the DB can't be opened because users</a>
<a name="ln136">    // can also specify a filename, not just a directory.</a>
<a name="ln137">    DoCommand();</a>
<a name="ln138"> </a>
<a name="ln139">    if (exec_state_.IsNotStarted()) {</a>
<a name="ln140">      exec_state_ = LDBCommandExecuteResult::Succeed(&quot;&quot;);</a>
<a name="ln141">    }</a>
<a name="ln142"> </a>
<a name="ln143">    if (db_ != nullptr) {</a>
<a name="ln144">      CloseDB ();</a>
<a name="ln145">    }</a>
<a name="ln146">  }</a>
<a name="ln147"> </a>
<a name="ln148">  virtual void DoCommand() = 0;</a>
<a name="ln149"> </a>
<a name="ln150">  LDBCommandExecuteResult GetExecuteState() {</a>
<a name="ln151">    return exec_state_;</a>
<a name="ln152">  }</a>
<a name="ln153"> </a>
<a name="ln154">  void ClearPreviousRunState() {</a>
<a name="ln155">    exec_state_.Reset();</a>
<a name="ln156">  }</a>
<a name="ln157"> </a>
<a name="ln158">  static string HexToString(const string&amp; str) {</a>
<a name="ln159">    std::string::size_type len = str.length();</a>
<a name="ln160">    string parsed;</a>
<a name="ln161">    static const char* const hexas = &quot;0123456789ABCDEF&quot;;</a>
<a name="ln162">    parsed.reserve(len / 2);</a>
<a name="ln163"> </a>
<a name="ln164">    if (len &lt; 2 || str[0] != '0' || str[1] != 'x') {</a>
<a name="ln165">      fprintf(stderr, &quot;Invalid hex input %s.  Must start with 0x\n&quot;,</a>
<a name="ln166">              str.c_str());</a>
<a name="ln167">      throw &quot;Invalid hex input&quot;;</a>
<a name="ln168">    }</a>
<a name="ln169"> </a>
<a name="ln170">    for (unsigned int i = 2; i &lt; len; i += 2) {</a>
<a name="ln171">      char a = static_cast&lt;char&gt;(toupper(str[i]));</a>
<a name="ln172">      const char* p = std::lower_bound(hexas, hexas + 16, a);</a>
<a name="ln173">      if (*p != a) {</a>
<a name="ln174">        throw &quot;Invalid hex value&quot;;</a>
<a name="ln175">      }</a>
<a name="ln176"> </a>
<a name="ln177">      if (i + 1 &gt;= len) {</a>
<a name="ln178">        // if odd number of chars than we just hit end of string</a>
<a name="ln179">        parsed.push_back(static_cast&lt;char&gt;(p - hexas));</a>
<a name="ln180">        break;</a>
<a name="ln181">      }</a>
<a name="ln182"> </a>
<a name="ln183">      char b = static_cast&lt;char&gt;(toupper(str[i + 1]));</a>
<a name="ln184">      const char* q = std::lower_bound(hexas, hexas + 16, b);</a>
<a name="ln185">      if (*q == b) {</a>
<a name="ln186">        // pairwise compute decimal value from hex</a>
<a name="ln187">        parsed.push_back(static_cast&lt;char&gt;(((p - hexas) &lt;&lt; 4) | (q - hexas)));</a>
<a name="ln188">      } else {</a>
<a name="ln189">        throw &quot;Invalid hex value&quot;;</a>
<a name="ln190">      }</a>
<a name="ln191">    }</a>
<a name="ln192">    return parsed;</a>
<a name="ln193">  }</a>
<a name="ln194"> </a>
<a name="ln195">  static string StringToHex(const string&amp; str) {</a>
<a name="ln196">    string result = &quot;0x&quot;;</a>
<a name="ln197">    char buf[10];</a>
<a name="ln198">    for (size_t i = 0; i &lt; str.length(); i++) {</a>
<a name="ln199">      snprintf(buf, sizeof(buf), &quot;%02X&quot;, (unsigned char)str[i]);</a>
<a name="ln200">      result += buf;</a>
<a name="ln201">    }</a>
<a name="ln202">    return result;</a>
<a name="ln203">  }</a>
<a name="ln204"> </a>
<a name="ln205">  static const char* DELIM;</a>
<a name="ln206"> </a>
<a name="ln207"> protected:</a>
<a name="ln208"> </a>
<a name="ln209">  LDBCommandExecuteResult exec_state_;</a>
<a name="ln210">  string db_path_;</a>
<a name="ln211">  string column_family_name_;</a>
<a name="ln212">  DB* db_;</a>
<a name="ln213">  DBWithTTL* db_ttl_;</a>
<a name="ln214">  std::map&lt;std::string, ColumnFamilyHandle*&gt; cf_handles_;</a>
<a name="ln215"> </a>
<a name="ln216">  /**</a>
<a name="ln217">   * true implies that this command can work if the db is opened in read-only</a>
<a name="ln218">   * mode.</a>
<a name="ln219">   */</a>
<a name="ln220">  bool is_read_only_;</a>
<a name="ln221"> </a>
<a name="ln222">  /** If true, the key is input/output as hex in get/put/scan/delete etc. */</a>
<a name="ln223">  bool is_key_hex_;</a>
<a name="ln224"> </a>
<a name="ln225">  /** If true, the value is input/output as hex in get/put/scan/delete etc. */</a>
<a name="ln226">  bool is_value_hex_;</a>
<a name="ln227"> </a>
<a name="ln228">  /** If true, the value is treated as timestamp suffixed */</a>
<a name="ln229">  bool is_db_ttl_;</a>
<a name="ln230"> </a>
<a name="ln231">  // If true, the kvs are output with their insert/modify timestamp in a ttl db</a>
<a name="ln232">  bool timestamp_;</a>
<a name="ln233"> </a>
<a name="ln234">  /**</a>
<a name="ln235">   * Map of options passed on the command-line.</a>
<a name="ln236">   */</a>
<a name="ln237">  const map&lt;string, string&gt; option_map_;</a>
<a name="ln238"> </a>
<a name="ln239">  /**</a>
<a name="ln240">   * Flags passed on the command-line.</a>
<a name="ln241">   */</a>
<a name="ln242">  const vector&lt;string&gt; flags_;</a>
<a name="ln243"> </a>
<a name="ln244">  /** List of command-line options valid for this command */</a>
<a name="ln245">  const vector&lt;string&gt; valid_cmd_line_options_;</a>
<a name="ln246"> </a>
<a name="ln247">  std::unique_ptr&lt;yb::enterprise::UniverseKeyManager&gt; universe_key_manager_;</a>
<a name="ln248">  std::unique_ptr&lt;rocksdb::Env&gt; env_;</a>
<a name="ln249"> </a>
<a name="ln250">  bool ParseKeyValue(const string&amp; line, string* key, string* value,</a>
<a name="ln251">                      bool is_key_hex, bool is_value_hex);</a>
<a name="ln252"> </a>
<a name="ln253">  LDBCommand(const map&lt;string, string&gt;&amp; options, const vector&lt;string&gt;&amp; flags,</a>
<a name="ln254">             bool is_read_only, const vector&lt;string&gt;&amp; valid_cmd_line_options) :</a>
<a name="ln255">      db_(nullptr),</a>
<a name="ln256">      is_read_only_(is_read_only),</a>
<a name="ln257">      is_key_hex_(false),</a>
<a name="ln258">      is_value_hex_(false),</a>
<a name="ln259">      is_db_ttl_(false),</a>
<a name="ln260">      timestamp_(false),</a>
<a name="ln261">      option_map_(options),</a>
<a name="ln262">      flags_(flags),</a>
<a name="ln263">      valid_cmd_line_options_(valid_cmd_line_options) {</a>
<a name="ln264"> </a>
<a name="ln265">    map&lt;string, string&gt;::const_iterator itr = options.find(ARG_DB);</a>
<a name="ln266">    if (itr != options.end()) {</a>
<a name="ln267">      db_path_ = itr-&gt;second;</a>
<a name="ln268">    }</a>
<a name="ln269"> </a>
<a name="ln270">    itr = options.find(ARG_UNIVERSE_KEY_FILE);</a>
<a name="ln271">    if (itr != options.end()) {</a>
<a name="ln272">      vector&lt;string&gt; splits = StringSplit(itr-&gt;second, ':');</a>
<a name="ln273">      if (splits.size() != 2) {</a>
<a name="ln274">        LOG(FATAL) &lt;&lt; yb::Format(&quot;Could not split $0 by ':' into a key id and key file&quot;,</a>
<a name="ln275">                                 itr-&gt;second);</a>
<a name="ln276">      }</a>
<a name="ln277">      string key_data;</a>
<a name="ln278">      auto key_id = splits[0];</a>
<a name="ln279">      auto key_path = splits[1];</a>
<a name="ln280">      Status s = ReadFileToString(Env::Default(), key_path, &amp;key_data);</a>
<a name="ln281">      if(!s.ok()) {</a>
<a name="ln282">        LOG(FATAL) &lt;&lt; yb::Format(&quot;Could not read file at path $0: $1&quot;, key_path, s.ToString());</a>
<a name="ln283">      }</a>
<a name="ln284">      auto res = yb::enterprise::UniverseKeyManager::FromKey(key_id, yb::Slice(key_data));</a>
<a name="ln285">      if (!res.ok()) {</a>
<a name="ln286">        LOG(FATAL) &lt;&lt; &quot;Could not create universe key manager: &quot; &lt;&lt; res.status().ToString();</a>
<a name="ln287">      }</a>
<a name="ln288">      universe_key_manager_ = std::move(*res);</a>
<a name="ln289">      env_ = yb::enterprise::NewRocksDBEncryptedEnv(</a>
<a name="ln290">          yb::enterprise::DefaultHeaderManager(universe_key_manager_.get()));</a>
<a name="ln291">    }</a>
<a name="ln292"> </a>
<a name="ln293">    itr = options.find(ARG_CF_NAME);</a>
<a name="ln294">    if (itr != options.end()) {</a>
<a name="ln295">      column_family_name_ = itr-&gt;second;</a>
<a name="ln296">    } else {</a>
<a name="ln297">      column_family_name_ = kDefaultColumnFamilyName;</a>
<a name="ln298">    }</a>
<a name="ln299"> </a>
<a name="ln300">    is_key_hex_ = IsKeyHex(options, flags);</a>
<a name="ln301">    is_value_hex_ = IsValueHex(options, flags);</a>
<a name="ln302">    is_db_ttl_ = IsFlagPresent(flags, ARG_TTL);</a>
<a name="ln303">    timestamp_ = IsFlagPresent(flags, ARG_TIMESTAMP);</a>
<a name="ln304">  }</a>
<a name="ln305"> </a>
<a name="ln306">  void OpenDB() {</a>
<a name="ln307">    Options opt = PrepareOptionsForOpenDB();</a>
<a name="ln308">    if (!exec_state_.IsNotStarted()) {</a>
<a name="ln309">      return;</a>
<a name="ln310">    }</a>
<a name="ln311">    // Open the DB.</a>
<a name="ln312">    Status st;</a>
<a name="ln313">    std::vector&lt;ColumnFamilyHandle*&gt; handles_opened;</a>
<a name="ln314">    if (is_db_ttl_) {</a>
<a name="ln315">      // ldb doesn't yet support TTL DB with multiple column families</a>
<a name="ln316">      if (!column_family_name_.empty() || !column_families_.empty()) {</a>
<a name="ln317">        exec_state_ = LDBCommandExecuteResult::Failed(</a>
<a name="ln318">            &quot;ldb doesn't support TTL DB with multiple column families&quot;);</a>
<a name="ln319">      }</a>
<a name="ln320">      if (is_read_only_) {</a>
<a name="ln321">        st = DBWithTTL::Open(opt, db_path_, &amp;db_ttl_, 0, true);</a>
<a name="ln322">      } else {</a>
<a name="ln323">        st = DBWithTTL::Open(opt, db_path_, &amp;db_ttl_);</a>
<a name="ln324">      }</a>
<a name="ln325">      db_ = db_ttl_;</a>
<a name="ln326">    } else {</a>
<a name="ln327">      if (column_families_.empty()) {</a>
<a name="ln328">        // Try to figure out column family lists</a>
<a name="ln329">        std::vector&lt;std::string&gt; cf_list;</a>
<a name="ln330">        st = DB::ListColumnFamilies(DBOptions(), db_path_, &amp;cf_list);</a>
<a name="ln331">        // There is possible the DB doesn't exist yet, for &quot;create if not</a>
<a name="ln332">        // &quot;existing case&quot;. The failure is ignored here. We rely on DB::Open()</a>
<a name="ln333">        // to give us the correct error message for problem with opening</a>
<a name="ln334">        // existing DB.</a>
<a name="ln335">        if (st.ok() &amp;&amp; cf_list.size() &gt; 1) {</a>
<a name="ln336">          // Ignore single column family DB.</a>
<a name="ln337">          for (auto cf_name : cf_list) {</a>
<a name="ln338">            column_families_.emplace_back(cf_name, opt);</a>
<a name="ln339">          }</a>
<a name="ln340">        }</a>
<a name="ln341">      }</a>
<a name="ln342">      if (is_read_only_) {</a>
<a name="ln343">        if (column_families_.empty()) {</a>
<a name="ln344">          st = DB::OpenForReadOnly(opt, db_path_, &amp;db_);</a>
<a name="ln345">        } else {</a>
<a name="ln346">          st = DB::OpenForReadOnly(opt, db_path_, column_families_,</a>
<a name="ln347">                                   &amp;handles_opened, &amp;db_);</a>
<a name="ln348">        }</a>
<a name="ln349">      } else {</a>
<a name="ln350">        if (column_families_.empty()) {</a>
<a name="ln351">          st = DB::Open(opt, db_path_, &amp;db_);</a>
<a name="ln352">        } else {</a>
<a name="ln353">          st = DB::Open(opt, db_path_, column_families_, &amp;handles_opened, &amp;db_);</a>
<a name="ln354">        }</a>
<a name="ln355">      }</a>
<a name="ln356">    }</a>
<a name="ln357">    if (!st.ok()) {</a>
<a name="ln358">      string msg = st.ToString();</a>
<a name="ln359">      exec_state_ = LDBCommandExecuteResult::Failed(msg);</a>
<a name="ln360">    } else if (!handles_opened.empty()) {</a>
<a name="ln361">      assert(handles_opened.size() == column_families_.size());</a>
<a name="ln362">      bool found_cf_name = false;</a>
<a name="ln363">      for (size_t i = 0; i &lt; handles_opened.size(); i++) {</a>
<a name="ln364">        cf_handles_[column_families_[i].name] = handles_opened[i];</a>
<a name="ln365">        if (column_family_name_ == column_families_[i].name) {</a>
<a name="ln366">          found_cf_name = true;</a>
<a name="ln367">        }</a>
<a name="ln368">      }</a>
<a name="ln369">      if (!found_cf_name) {</a>
<a name="ln370">        exec_state_ = LDBCommandExecuteResult::Failed(</a>
<a name="ln371">            &quot;Non-existing column family &quot; + column_family_name_);</a>
<a name="ln372">        CloseDB();</a>
<a name="ln373">      }</a>
<a name="ln374">    } else {</a>
<a name="ln375">      // We successfully opened DB in single column family mode.</a>
<a name="ln376">      assert(column_families_.empty());</a>
<a name="ln377">      if (column_family_name_ != kDefaultColumnFamilyName) {</a>
<a name="ln378">        exec_state_ = LDBCommandExecuteResult::Failed(</a>
<a name="ln379">            &quot;Non-existing column family &quot; + column_family_name_);</a>
<a name="ln380">        CloseDB();</a>
<a name="ln381">      }</a>
<a name="ln382">    }</a>
<a name="ln383"> </a>
<a name="ln384">    options_ = opt;</a>
<a name="ln385">  }</a>
<a name="ln386"> </a>
<a name="ln387">  void CloseDB () {</a>
<a name="ln388">    if (db_ != nullptr) {</a>
<a name="ln389">      for (auto&amp; pair : cf_handles_) {</a>
<a name="ln390">        delete pair.second;</a>
<a name="ln391">      }</a>
<a name="ln392">      delete db_;</a>
<a name="ln393">      db_ = nullptr;</a>
<a name="ln394">    }</a>
<a name="ln395">  }</a>
<a name="ln396"> </a>
<a name="ln397">  ColumnFamilyHandle* GetCfHandle() {</a>
<a name="ln398">    if (!cf_handles_.empty()) {</a>
<a name="ln399">      auto it = cf_handles_.find(column_family_name_);</a>
<a name="ln400">      if (it == cf_handles_.end()) {</a>
<a name="ln401">        exec_state_ = LDBCommandExecuteResult::Failed(</a>
<a name="ln402">            &quot;Cannot find column family &quot; + column_family_name_);</a>
<a name="ln403">      } else {</a>
<a name="ln404">        return it-&gt;second;</a>
<a name="ln405">      }</a>
<a name="ln406">    }</a>
<a name="ln407">    return db_-&gt;DefaultColumnFamily();</a>
<a name="ln408">  }</a>
<a name="ln409"> </a>
<a name="ln410">  static string PrintKeyValue(const string&amp; key, const string&amp; value,</a>
<a name="ln411">        bool is_key_hex, bool is_value_hex) {</a>
<a name="ln412">    string result;</a>
<a name="ln413">    result.append(is_key_hex ? StringToHex(key) : key);</a>
<a name="ln414">    result.append(DELIM);</a>
<a name="ln415">    result.append(is_value_hex ? StringToHex(value) : value);</a>
<a name="ln416">    return result;</a>
<a name="ln417">  }</a>
<a name="ln418"> </a>
<a name="ln419">  static string PrintKeyValue(const string&amp; key, const string&amp; value,</a>
<a name="ln420">        bool is_hex) {</a>
<a name="ln421">    return PrintKeyValue(key, value, is_hex, is_hex);</a>
<a name="ln422">  }</a>
<a name="ln423"> </a>
<a name="ln424">  /**</a>
<a name="ln425">   * Return true if the specified flag is present in the specified flags vector</a>
<a name="ln426">   */</a>
<a name="ln427">  static bool IsFlagPresent(const vector&lt;string&gt;&amp; flags, const string&amp; flag) {</a>
<a name="ln428">    return (std::find(flags.begin(), flags.end(), flag) != flags.end());</a>
<a name="ln429">  }</a>
<a name="ln430"> </a>
<a name="ln431">  static string HelpRangeCmdArgs() {</a>
<a name="ln432">    ostringstream str_stream;</a>
<a name="ln433">    str_stream &lt;&lt; &quot; &quot;;</a>
<a name="ln434">    str_stream &lt;&lt; &quot;[--&quot; &lt;&lt; ARG_FROM &lt;&lt; &quot;] &quot;;</a>
<a name="ln435">    str_stream &lt;&lt; &quot;[--&quot; &lt;&lt; ARG_TO &lt;&lt; &quot;] &quot;;</a>
<a name="ln436">    return str_stream.str();</a>
<a name="ln437">  }</a>
<a name="ln438"> </a>
<a name="ln439">  /**</a>
<a name="ln440">   * A helper function that returns a list of command line options</a>
<a name="ln441">   * used by this command.  It includes the common options and the ones</a>
<a name="ln442">   * passed in.</a>
<a name="ln443">   */</a>
<a name="ln444">  static vector&lt;string&gt; BuildCmdLineOptions(vector&lt;string&gt; options) {</a>
<a name="ln445">    vector&lt;string&gt; ret = {ARG_DB, ARG_BLOOM_BITS, ARG_BLOCK_SIZE,</a>
<a name="ln446">                          ARG_AUTO_COMPACTION, ARG_COMPRESSION_TYPE,</a>
<a name="ln447">                          ARG_WRITE_BUFFER_SIZE, ARG_FILE_SIZE,</a>
<a name="ln448">                          ARG_FIX_PREFIX_LEN, ARG_CF_NAME, ARG_UNIVERSE_KEY_FILE};</a>
<a name="ln449">    ret.insert(ret.end(), options.begin(), options.end());</a>
<a name="ln450">    return ret;</a>
<a name="ln451">  }</a>
<a name="ln452"> </a>
<a name="ln453">  bool ParseIntOption(const map&lt;string, string&gt;&amp; options, const string&amp; option,</a>
<a name="ln454">                      int&amp; value, LDBCommandExecuteResult&amp; exec_state); // NOLINT</a>
<a name="ln455"> </a>
<a name="ln456">  bool ParseStringOption(const map&lt;string, string&gt;&amp; options,</a>
<a name="ln457">                         const string&amp; option, string* value);</a>
<a name="ln458"> </a>
<a name="ln459">  Options options_;</a>
<a name="ln460">  std::vector&lt;ColumnFamilyDescriptor&gt; column_families_;</a>
<a name="ln461">  LDBOptions ldb_options_;</a>
<a name="ln462"> </a>
<a name="ln463"> private:</a>
<a name="ln464"> </a>
<a name="ln465">  /**</a>
<a name="ln466">   * Interpret command line options and flags to determine if the key</a>
<a name="ln467">   * should be input/output in hex.</a>
<a name="ln468">   */</a>
<a name="ln469">  bool IsKeyHex(const map&lt;string, string&gt;&amp; options,</a>
<a name="ln470">      const vector&lt;string&gt;&amp; flags) {</a>
<a name="ln471">    return (IsFlagPresent(flags, ARG_HEX) ||</a>
<a name="ln472">        IsFlagPresent(flags, ARG_KEY_HEX) ||</a>
<a name="ln473">        ParseBooleanOption(options, ARG_HEX, false) ||</a>
<a name="ln474">        ParseBooleanOption(options, ARG_KEY_HEX, false));</a>
<a name="ln475">  }</a>
<a name="ln476"> </a>
<a name="ln477">  /**</a>
<a name="ln478">   * Interpret command line options and flags to determine if the value</a>
<a name="ln479">   * should be input/output in hex.</a>
<a name="ln480">   */</a>
<a name="ln481">  bool IsValueHex(const map&lt;string, string&gt;&amp; options,</a>
<a name="ln482">      const vector&lt;string&gt;&amp; flags) {</a>
<a name="ln483">    return (IsFlagPresent(flags, ARG_HEX) ||</a>
<a name="ln484">          IsFlagPresent(flags, ARG_VALUE_HEX) ||</a>
<a name="ln485">          ParseBooleanOption(options, ARG_HEX, false) ||</a>
<a name="ln486">          ParseBooleanOption(options, ARG_VALUE_HEX, false));</a>
<a name="ln487">  }</a>
<a name="ln488"> </a>
<a name="ln489">  /**</a>
<a name="ln490">   * Returns the value of the specified option as a boolean.</a>
<a name="ln491">   * default_val is used if the option is not found in options.</a>
<a name="ln492">   * Throws an exception if the value of the option is not</a>
<a name="ln493">   * &quot;true&quot; or &quot;false&quot; (case insensitive).</a>
<a name="ln494">   */</a>
<a name="ln495">  bool ParseBooleanOption(const map&lt;string, string&gt;&amp; options,</a>
<a name="ln496">      const string&amp; option, bool default_val) {</a>
<a name="ln497"> </a>
<a name="ln498">    map&lt;string, string&gt;::const_iterator itr = options.find(option);</a>
<a name="ln499">    if (itr != options.end()) {</a>
<a name="ln500">      string option_val = itr-&gt;second;</a>
<a name="ln501">      return StringToBool(itr-&gt;second);</a>
<a name="ln502">    }</a>
<a name="ln503">    return default_val;</a>
<a name="ln504">  }</a>
<a name="ln505"> </a>
<a name="ln506">  /**</a>
<a name="ln507">   * Converts val to a boolean.</a>
<a name="ln508">   * val must be either true or false (case insensitive).</a>
<a name="ln509">   * Otherwise an exception is thrown.</a>
<a name="ln510">   */</a>
<a name="ln511">  bool StringToBool(string val) {</a>
<a name="ln512">    std::transform(val.begin(), val.end(), val.begin(),</a>
<a name="ln513">                   [](char ch)-&gt;char { return static_cast&lt;char&gt;(::tolower(ch)); });</a>
<a name="ln514"> </a>
<a name="ln515">    if (val == &quot;true&quot;) {</a>
<a name="ln516">      return true;</a>
<a name="ln517">    } else if (val == &quot;false&quot;) {</a>
<a name="ln518">      return false;</a>
<a name="ln519">    } else {</a>
<a name="ln520">      throw &quot;Invalid value for boolean argument&quot;;</a>
<a name="ln521">    }</a>
<a name="ln522">  }</a>
<a name="ln523"> </a>
<a name="ln524">  static LDBCommand* SelectCommand(</a>
<a name="ln525">    const string&amp; cmd,</a>
<a name="ln526">    const vector&lt;string&gt;&amp; cmdParams,</a>
<a name="ln527">    const map&lt;string, string&gt;&amp; option_map,</a>
<a name="ln528">    const vector&lt;string&gt;&amp; flags</a>
<a name="ln529">  );</a>
<a name="ln530"> </a>
<a name="ln531">};</a>
<a name="ln532"> </a>
<a name="ln533">class CompactorCommand: public LDBCommand {</a>
<a name="ln534"> public:</a>
<a name="ln535">  static string Name() { return &quot;compact&quot;; }</a>
<a name="ln536"> </a>
<a name="ln537">  CompactorCommand(const vector&lt;string&gt;&amp; params,</a>
<a name="ln538">      const map&lt;string, string&gt;&amp; options, const vector&lt;string&gt;&amp; flags);</a>
<a name="ln539"> </a>
<a name="ln540">  static void Help(string&amp; ret); // NOLINT</a>
<a name="ln541"> </a>
<a name="ln542">  virtual void DoCommand() override;</a>
<a name="ln543"> </a>
<a name="ln544"> private:</a>
<a name="ln545">  bool null_from_;</a>
<a name="ln546">  string from_;</a>
<a name="ln547">  bool null_to_;</a>
<a name="ln548">  string to_;</a>
<a name="ln549">};</a>
<a name="ln550"> </a>
<a name="ln551">class DBFileDumperCommand : public LDBCommand {</a>
<a name="ln552"> public:</a>
<a name="ln553">  static string Name() { return &quot;dump_live_files&quot;; }</a>
<a name="ln554"> </a>
<a name="ln555">  DBFileDumperCommand(const vector&lt;string&gt;&amp; params,</a>
<a name="ln556">                      const map&lt;string, string&gt;&amp; options,</a>
<a name="ln557">                      const vector&lt;string&gt;&amp; flags);</a>
<a name="ln558"> </a>
<a name="ln559">  static void Help(string&amp; ret); // NOLINT</a>
<a name="ln560"> </a>
<a name="ln561">  virtual void DoCommand() override;</a>
<a name="ln562">};</a>
<a name="ln563"> </a>
<a name="ln564">class DBDumperCommand: public LDBCommand {</a>
<a name="ln565"> public:</a>
<a name="ln566">  static string Name() { return &quot;dump&quot;; }</a>
<a name="ln567"> </a>
<a name="ln568">  DBDumperCommand(const vector&lt;string&gt;&amp; params,</a>
<a name="ln569">      const map&lt;string, string&gt;&amp; options, const vector&lt;string&gt;&amp; flags);</a>
<a name="ln570"> </a>
<a name="ln571">  static void Help(string&amp; ret); // NOLINT</a>
<a name="ln572"> </a>
<a name="ln573">  virtual void DoCommand() override;</a>
<a name="ln574"> </a>
<a name="ln575"> private:</a>
<a name="ln576">  /**</a>
<a name="ln577">   * Extract file name from the full path. We handle both the forward slash (/)</a>
<a name="ln578">   * and backslash (\) to make sure that different OS-s are supported.</a>
<a name="ln579">  */</a>
<a name="ln580">  static string GetFileNameFromPath(const string&amp; s) {</a>
<a name="ln581">    std::size_t n = s.find_last_of(&quot;/\\&quot;);</a>
<a name="ln582"> </a>
<a name="ln583">    if (std::string::npos == n) {</a>
<a name="ln584">      return s;</a>
<a name="ln585">    } else {</a>
<a name="ln586">      return s.substr(n + 1);</a>
<a name="ln587">    }</a>
<a name="ln588">  }</a>
<a name="ln589"> </a>
<a name="ln590">  void DoDumpCommand();</a>
<a name="ln591"> </a>
<a name="ln592">  bool null_from_;</a>
<a name="ln593">  string from_;</a>
<a name="ln594">  bool null_to_;</a>
<a name="ln595">  string to_;</a>
<a name="ln596">  int max_keys_;</a>
<a name="ln597">  string delim_;</a>
<a name="ln598">  bool count_only_;</a>
<a name="ln599">  bool count_delim_;</a>
<a name="ln600">  bool print_stats_;</a>
<a name="ln601">  string path_;</a>
<a name="ln602"> </a>
<a name="ln603">  static const string ARG_COUNT_ONLY;</a>
<a name="ln604">  static const string ARG_COUNT_DELIM;</a>
<a name="ln605">  static const string ARG_STATS;</a>
<a name="ln606">  static const string ARG_TTL_BUCKET;</a>
<a name="ln607">};</a>
<a name="ln608"> </a>
<a name="ln609">class InternalDumpCommand: public LDBCommand {</a>
<a name="ln610"> public:</a>
<a name="ln611">  static string Name() { return &quot;idump&quot;; }</a>
<a name="ln612"> </a>
<a name="ln613">  InternalDumpCommand(const vector&lt;string&gt;&amp; params,</a>
<a name="ln614">                      const map&lt;string, string&gt;&amp; options,</a>
<a name="ln615">                      const vector&lt;string&gt;&amp; flags);</a>
<a name="ln616"> </a>
<a name="ln617">  static void Help(string&amp; ret); // NOLINT</a>
<a name="ln618"> </a>
<a name="ln619">  virtual void DoCommand() override;</a>
<a name="ln620"> </a>
<a name="ln621"> private:</a>
<a name="ln622">  bool has_from_;</a>
<a name="ln623">  string from_;</a>
<a name="ln624">  bool has_to_;</a>
<a name="ln625">  string to_;</a>
<a name="ln626">  int max_keys_;</a>
<a name="ln627">  string delim_;</a>
<a name="ln628">  bool count_only_;</a>
<a name="ln629">  bool count_delim_;</a>
<a name="ln630">  bool print_stats_;</a>
<a name="ln631">  bool is_input_key_hex_;</a>
<a name="ln632"> </a>
<a name="ln633">  static const string ARG_DELIM;</a>
<a name="ln634">  static const string ARG_COUNT_ONLY;</a>
<a name="ln635">  static const string ARG_COUNT_DELIM;</a>
<a name="ln636">  static const string ARG_STATS;</a>
<a name="ln637">  static const string ARG_INPUT_KEY_HEX;</a>
<a name="ln638">};</a>
<a name="ln639"> </a>
<a name="ln640">class DBLoaderCommand: public LDBCommand {</a>
<a name="ln641"> public:</a>
<a name="ln642">  static string Name() { return &quot;load&quot;; }</a>
<a name="ln643"> </a>
<a name="ln644">  DBLoaderCommand(string&amp; db_name, vector&lt;string&gt;&amp; args); // NOLINT</a>
<a name="ln645"> </a>
<a name="ln646">  DBLoaderCommand(const vector&lt;string&gt;&amp; params,</a>
<a name="ln647">      const map&lt;string, string&gt;&amp; options, const vector&lt;string&gt;&amp; flags);</a>
<a name="ln648"> </a>
<a name="ln649">  static void Help(string&amp; ret); // NOLINT</a>
<a name="ln650">  virtual void DoCommand() override;</a>
<a name="ln651"> </a>
<a name="ln652">  virtual Options PrepareOptionsForOpenDB() override;</a>
<a name="ln653"> </a>
<a name="ln654"> private:</a>
<a name="ln655">  bool create_if_missing_;</a>
<a name="ln656">  bool disable_wal_;</a>
<a name="ln657">  bool bulk_load_;</a>
<a name="ln658">  bool compact_;</a>
<a name="ln659"> </a>
<a name="ln660">  static const string ARG_DISABLE_WAL;</a>
<a name="ln661">  static const string ARG_BULK_LOAD;</a>
<a name="ln662">  static const string ARG_COMPACT;</a>
<a name="ln663">};</a>
<a name="ln664"> </a>
<a name="ln665">class ManifestDumpCommand: public LDBCommand {</a>
<a name="ln666"> public:</a>
<a name="ln667">  static string Name() { return &quot;manifest_dump&quot;; }</a>
<a name="ln668"> </a>
<a name="ln669">  ManifestDumpCommand(const vector&lt;string&gt;&amp; params,</a>
<a name="ln670">      const map&lt;string, string&gt;&amp; options, const vector&lt;string&gt;&amp; flags);</a>
<a name="ln671"> </a>
<a name="ln672">  static void Help(string&amp; ret); // NOLINT</a>
<a name="ln673">  virtual void DoCommand() override;</a>
<a name="ln674"> </a>
<a name="ln675">  virtual bool NoDBOpen() override { return true; }</a>
<a name="ln676"> </a>
<a name="ln677"> private:</a>
<a name="ln678">  bool verbose_;</a>
<a name="ln679">  string path_;</a>
<a name="ln680"> </a>
<a name="ln681">  static const string ARG_VERBOSE;</a>
<a name="ln682">  static const string ARG_JSON;</a>
<a name="ln683">  static const string ARG_PATH;</a>
<a name="ln684">};</a>
<a name="ln685"> </a>
<a name="ln686">class ListColumnFamiliesCommand : public LDBCommand {</a>
<a name="ln687"> public:</a>
<a name="ln688">  static string Name() { return &quot;list_column_families&quot;; }</a>
<a name="ln689"> </a>
<a name="ln690">  ListColumnFamiliesCommand(const vector&lt;string&gt;&amp; params,</a>
<a name="ln691">                            const map&lt;string, string&gt;&amp; options,</a>
<a name="ln692">                            const vector&lt;string&gt;&amp; flags);</a>
<a name="ln693"> </a>
<a name="ln694">  static void Help(string&amp; ret); // NOLINT</a>
<a name="ln695">  virtual void DoCommand() override;</a>
<a name="ln696"> </a>
<a name="ln697">  virtual bool NoDBOpen() override { return true; }</a>
<a name="ln698"> </a>
<a name="ln699"> private:</a>
<a name="ln700">  string dbname_;</a>
<a name="ln701">};</a>
<a name="ln702"> </a>
<a name="ln703">class CreateColumnFamilyCommand : public LDBCommand {</a>
<a name="ln704"> public:</a>
<a name="ln705">  static string Name() { return &quot;create_column_family&quot;; }</a>
<a name="ln706"> </a>
<a name="ln707">  CreateColumnFamilyCommand(const vector&lt;string&gt;&amp; params,</a>
<a name="ln708">                            const map&lt;string, string&gt;&amp; options,</a>
<a name="ln709">                            const vector&lt;string&gt;&amp; flags);</a>
<a name="ln710"> </a>
<a name="ln711">  static void Help(string&amp; ret); // NOLINT</a>
<a name="ln712">  virtual void DoCommand() override;</a>
<a name="ln713"> </a>
<a name="ln714">  virtual bool NoDBOpen() override { return false; }</a>
<a name="ln715"> </a>
<a name="ln716"> private:</a>
<a name="ln717">  string new_cf_name_;</a>
<a name="ln718">};</a>
<a name="ln719"> </a>
<a name="ln720">class ReduceDBLevelsCommand : public LDBCommand {</a>
<a name="ln721"> public:</a>
<a name="ln722">  static string Name() { return &quot;reduce_levels&quot;; }</a>
<a name="ln723"> </a>
<a name="ln724">  ReduceDBLevelsCommand(const vector&lt;string&gt;&amp; params,</a>
<a name="ln725">      const map&lt;string, string&gt;&amp; options, const vector&lt;string&gt;&amp; flags);</a>
<a name="ln726"> </a>
<a name="ln727">  virtual Options PrepareOptionsForOpenDB() override;</a>
<a name="ln728"> </a>
<a name="ln729">  virtual void DoCommand() override;</a>
<a name="ln730"> </a>
<a name="ln731">  virtual bool NoDBOpen() override { return true; }</a>
<a name="ln732"> </a>
<a name="ln733">  static void Help(string&amp; msg); // NOLINT</a>
<a name="ln734"> </a>
<a name="ln735">  static vector&lt;string&gt; PrepareArgs(const string&amp; db_path, int new_levels,</a>
<a name="ln736">      bool print_old_level = false);</a>
<a name="ln737"> </a>
<a name="ln738"> private:</a>
<a name="ln739">  int old_levels_;</a>
<a name="ln740">  int new_levels_;</a>
<a name="ln741">  bool print_old_levels_;</a>
<a name="ln742"> </a>
<a name="ln743">  static const string ARG_NEW_LEVELS;</a>
<a name="ln744">  static const string ARG_PRINT_OLD_LEVELS;</a>
<a name="ln745"> </a>
<a name="ln746">  Status GetOldNumOfLevels(Options&amp; opt, int* levels); // NOLINT</a>
<a name="ln747">};</a>
<a name="ln748"> </a>
<a name="ln749">class ChangeCompactionStyleCommand : public LDBCommand {</a>
<a name="ln750"> public:</a>
<a name="ln751">  static string Name() { return &quot;change_compaction_style&quot;; }</a>
<a name="ln752"> </a>
<a name="ln753">  ChangeCompactionStyleCommand(const vector&lt;string&gt;&amp; params,</a>
<a name="ln754">      const map&lt;string, string&gt;&amp; options, const vector&lt;string&gt;&amp; flags);</a>
<a name="ln755"> </a>
<a name="ln756">  virtual Options PrepareOptionsForOpenDB() override;</a>
<a name="ln757"> </a>
<a name="ln758">  virtual void DoCommand() override;</a>
<a name="ln759"> </a>
<a name="ln760">  static void Help(string&amp; msg); // NOLINT</a>
<a name="ln761"> </a>
<a name="ln762"> private:</a>
<a name="ln763">  int old_compaction_style_;</a>
<a name="ln764">  int new_compaction_style_;</a>
<a name="ln765"> </a>
<a name="ln766">  static const string ARG_OLD_COMPACTION_STYLE;</a>
<a name="ln767">  static const string ARG_NEW_COMPACTION_STYLE;</a>
<a name="ln768">};</a>
<a name="ln769"> </a>
<a name="ln770">class WALDumperCommand : public LDBCommand {</a>
<a name="ln771"> public:</a>
<a name="ln772">  static string Name() { return &quot;dump_wal&quot;; }</a>
<a name="ln773"> </a>
<a name="ln774">  WALDumperCommand(const vector&lt;string&gt;&amp; params,</a>
<a name="ln775">      const map&lt;string, string&gt;&amp; options, const vector&lt;string&gt;&amp; flags);</a>
<a name="ln776"> </a>
<a name="ln777">  virtual bool NoDBOpen() override { return true; }</a>
<a name="ln778"> </a>
<a name="ln779">  static void Help(string&amp; ret); // NOLINT</a>
<a name="ln780">  virtual void DoCommand() override;</a>
<a name="ln781"> </a>
<a name="ln782"> private:</a>
<a name="ln783">  bool print_header_;</a>
<a name="ln784">  string wal_file_;</a>
<a name="ln785">  bool print_values_;</a>
<a name="ln786"> </a>
<a name="ln787">  static const string ARG_WAL_FILE;</a>
<a name="ln788">  static const string ARG_PRINT_HEADER;</a>
<a name="ln789">  static const string ARG_PRINT_VALUE;</a>
<a name="ln790">};</a>
<a name="ln791"> </a>
<a name="ln792"> </a>
<a name="ln793">class GetCommand : public LDBCommand {</a>
<a name="ln794"> public:</a>
<a name="ln795">  static string Name() { return &quot;get&quot;; }</a>
<a name="ln796"> </a>
<a name="ln797">  GetCommand(const vector&lt;string&gt;&amp; params, const map&lt;string, string&gt;&amp; options,</a>
<a name="ln798">      const vector&lt;string&gt;&amp; flags);</a>
<a name="ln799"> </a>
<a name="ln800">  virtual void DoCommand() override;</a>
<a name="ln801"> </a>
<a name="ln802">  static void Help(string&amp; ret); // NOLINT</a>
<a name="ln803"> </a>
<a name="ln804"> private:</a>
<a name="ln805">  string key_;</a>
<a name="ln806">};</a>
<a name="ln807"> </a>
<a name="ln808">class ApproxSizeCommand : public LDBCommand {</a>
<a name="ln809"> public:</a>
<a name="ln810">  static string Name() { return &quot;approxsize&quot;; }</a>
<a name="ln811"> </a>
<a name="ln812">  ApproxSizeCommand(const vector&lt;string&gt;&amp; params,</a>
<a name="ln813">      const map&lt;string, string&gt;&amp; options, const vector&lt;string&gt;&amp; flags);</a>
<a name="ln814"> </a>
<a name="ln815">  virtual void DoCommand() override;</a>
<a name="ln816"> </a>
<a name="ln817">  static void Help(string&amp; ret); // NOLINT</a>
<a name="ln818"> </a>
<a name="ln819"> private:</a>
<a name="ln820">  string start_key_;</a>
<a name="ln821">  string end_key_;</a>
<a name="ln822">};</a>
<a name="ln823"> </a>
<a name="ln824">class BatchPutCommand : public LDBCommand {</a>
<a name="ln825"> public:</a>
<a name="ln826">  static string Name() { return &quot;batchput&quot;; }</a>
<a name="ln827"> </a>
<a name="ln828">  BatchPutCommand(const vector&lt;string&gt;&amp; params,</a>
<a name="ln829">      const map&lt;string, string&gt;&amp; options, const vector&lt;string&gt;&amp; flags);</a>
<a name="ln830"> </a>
<a name="ln831">  virtual void DoCommand() override;</a>
<a name="ln832"> </a>
<a name="ln833">  static void Help(string&amp; ret); // NOLINT</a>
<a name="ln834"> </a>
<a name="ln835">  virtual Options PrepareOptionsForOpenDB() override;</a>
<a name="ln836"> </a>
<a name="ln837"> private:</a>
<a name="ln838">  /**</a>
<a name="ln839">   * The key-values to be inserted.</a>
<a name="ln840">   */</a>
<a name="ln841">  vector&lt;std::pair&lt;string, string&gt;&gt; key_values_;</a>
<a name="ln842">};</a>
<a name="ln843"> </a>
<a name="ln844">class ScanCommand : public LDBCommand {</a>
<a name="ln845"> public:</a>
<a name="ln846">  static string Name() { return &quot;scan&quot;; }</a>
<a name="ln847"> </a>
<a name="ln848">  ScanCommand(const vector&lt;string&gt;&amp; params, const map&lt;string, string&gt;&amp; options,</a>
<a name="ln849">      const vector&lt;string&gt;&amp; flags);</a>
<a name="ln850"> </a>
<a name="ln851">  virtual void DoCommand() override;</a>
<a name="ln852"> </a>
<a name="ln853">  static void Help(string&amp; ret); // NOLINT</a>
<a name="ln854"> </a>
<a name="ln855"> private:</a>
<a name="ln856">  string start_key_;</a>
<a name="ln857">  string end_key_;</a>
<a name="ln858">  bool start_key_specified_;</a>
<a name="ln859">  bool end_key_specified_;</a>
<a name="ln860">  int max_keys_scanned_;</a>
<a name="ln861">  bool no_value_;</a>
<a name="ln862">  bool only_verify_checksums_ = false;</a>
<a name="ln863">};</a>
<a name="ln864"> </a>
<a name="ln865">class DeleteCommand : public LDBCommand {</a>
<a name="ln866"> public:</a>
<a name="ln867">  static string Name() { return &quot;delete&quot;; }</a>
<a name="ln868"> </a>
<a name="ln869">  DeleteCommand(const vector&lt;string&gt;&amp; params,</a>
<a name="ln870">      const map&lt;string, string&gt;&amp; options, const vector&lt;string&gt;&amp; flags);</a>
<a name="ln871"> </a>
<a name="ln872">  virtual void DoCommand() override;</a>
<a name="ln873"> </a>
<a name="ln874">  static void Help(string&amp; ret); // NOLINT</a>
<a name="ln875"> </a>
<a name="ln876"> private:</a>
<a name="ln877">  string key_;</a>
<a name="ln878">};</a>
<a name="ln879"> </a>
<a name="ln880">class PutCommand : public LDBCommand {</a>
<a name="ln881"> public:</a>
<a name="ln882">  static string Name() { return &quot;put&quot;; }</a>
<a name="ln883"> </a>
<a name="ln884">  PutCommand(const vector&lt;string&gt;&amp; params, const map&lt;string, string&gt;&amp; options,</a>
<a name="ln885">      const vector&lt;string&gt;&amp; flags);</a>
<a name="ln886"> </a>
<a name="ln887">  virtual void DoCommand() override;</a>
<a name="ln888"> </a>
<a name="ln889">  static void Help(string&amp; ret); // NOLINT</a>
<a name="ln890"> </a>
<a name="ln891">  virtual Options PrepareOptionsForOpenDB() override;</a>
<a name="ln892"> </a>
<a name="ln893"> private:</a>
<a name="ln894">  string key_;</a>
<a name="ln895">  string value_;</a>
<a name="ln896">};</a>
<a name="ln897"> </a>
<a name="ln898">/**</a>
<a name="ln899"> * Command that starts up a REPL shell that allows</a>
<a name="ln900"> * get/put/delete.</a>
<a name="ln901"> */</a>
<a name="ln902">class DBQuerierCommand: public LDBCommand {</a>
<a name="ln903"> public:</a>
<a name="ln904">  static string Name() { return &quot;query&quot;; }</a>
<a name="ln905"> </a>
<a name="ln906">  DBQuerierCommand(const vector&lt;string&gt;&amp; params,</a>
<a name="ln907">      const map&lt;string, string&gt;&amp; options, const vector&lt;string&gt;&amp; flags);</a>
<a name="ln908"> </a>
<a name="ln909">  static void Help(string&amp; ret); // NOLINT</a>
<a name="ln910"> </a>
<a name="ln911">  virtual void DoCommand() override;</a>
<a name="ln912"> </a>
<a name="ln913"> private:</a>
<a name="ln914">  static const char* HELP_CMD;</a>
<a name="ln915">  static const char* GET_CMD;</a>
<a name="ln916">  static const char* PUT_CMD;</a>
<a name="ln917">  static const char* DELETE_CMD;</a>
<a name="ln918">};</a>
<a name="ln919"> </a>
<a name="ln920">class CheckConsistencyCommand : public LDBCommand {</a>
<a name="ln921"> public:</a>
<a name="ln922">  static string Name() { return &quot;checkconsistency&quot;; }</a>
<a name="ln923"> </a>
<a name="ln924">  CheckConsistencyCommand(const vector&lt;string&gt;&amp; params,</a>
<a name="ln925">      const map&lt;string, string&gt;&amp; options, const vector&lt;string&gt;&amp; flags);</a>
<a name="ln926"> </a>
<a name="ln927">  virtual void DoCommand() override;</a>
<a name="ln928"> </a>
<a name="ln929">  virtual bool NoDBOpen() override { return true; }</a>
<a name="ln930"> </a>
<a name="ln931">  static void Help(string&amp; ret); // NOLINT</a>
<a name="ln932">};</a>
<a name="ln933"> </a>
<a name="ln934">} // namespace rocksdb</a>
<a name="ln935"> </a>
<a name="ln936">#endif  // ROCKSDB_LITE</a>
<a name="ln937">#endif // YB_ROCKSDB_TOOLS_LDB_CMD_H</a>

</code></pre>
<div class="balloon" rel="145"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1020/" target="_blank">V1020</a> The function exited without calling the 'CloseDB' function. Check lines: 145, 132.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
