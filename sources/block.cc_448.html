
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>block.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//  Copyright (c) 2011-present, Facebook, Inc.  All rights reserved.</a>
<a name="ln2">//  This source code is licensed under the BSD-style license found in the</a>
<a name="ln3">//  LICENSE file in the root directory of this source tree. An additional grant</a>
<a name="ln4">//  of patent rights can be found in the PATENTS file in the same directory.</a>
<a name="ln5">//</a>
<a name="ln6">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln7">//</a>
<a name="ln8">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln9">//</a>
<a name="ln10">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln11">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln12">//</a>
<a name="ln13">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln14">//</a>
<a name="ln15">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln16">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln17">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln18">// under the License.</a>
<a name="ln19">//</a>
<a name="ln20">// Copyright (c) 2011 The LevelDB Authors. All rights reserved.</a>
<a name="ln21">// Use of this source code is governed by a BSD-style license that can be</a>
<a name="ln22">// found in the LICENSE file. See the AUTHORS file for names of contributors.</a>
<a name="ln23">//</a>
<a name="ln24">// Decodes the blocks generated by block_builder.cc.</a>
<a name="ln25"> </a>
<a name="ln26">#include &quot;yb/rocksdb/table/block.h&quot;</a>
<a name="ln27"> </a>
<a name="ln28">#include &lt;algorithm&gt;</a>
<a name="ln29">#include &lt;string&gt;</a>
<a name="ln30">#include &lt;unordered_map&gt;</a>
<a name="ln31">#include &lt;vector&gt;</a>
<a name="ln32"> </a>
<a name="ln33">#include &quot;yb/rocksdb/comparator.h&quot;</a>
<a name="ln34">#include &quot;yb/rocksdb/table/format.h&quot;</a>
<a name="ln35">#include &quot;yb/rocksdb/table/block_hash_index.h&quot;</a>
<a name="ln36">#include &quot;yb/rocksdb/table/block_prefix_index.h&quot;</a>
<a name="ln37">#include &quot;yb/rocksdb/util/coding.h&quot;</a>
<a name="ln38">#include &quot;yb/rocksdb/util/logging.h&quot;</a>
<a name="ln39">#include &quot;yb/rocksdb/util/perf_context_imp.h&quot;</a>
<a name="ln40"> </a>
<a name="ln41">namespace rocksdb {</a>
<a name="ln42"> </a>
<a name="ln43">namespace {</a>
<a name="ln44"> </a>
<a name="ln45">// Empty block consists of (see comments inside block_builder.cc for block structure):</a>
<a name="ln46">// - 0 data keys</a>
<a name="ln47">// - uint32 for single restart point (first restart point is always 0 and present in block)</a>
<a name="ln48">// - num_restarts: uint32</a>
<a name="ln49">const size_t kMinBlockSize = 2*sizeof(uint32_t);</a>
<a name="ln50"> </a>
<a name="ln51">} // namespace</a>
<a name="ln52"> </a>
<a name="ln53">// Helper routine: decode the next block entry starting at &quot;p&quot;,</a>
<a name="ln54">// storing the number of shared key bytes, non_shared key bytes,</a>
<a name="ln55">// and the length of the value in &quot;*shared&quot;, &quot;*non_shared&quot;, and</a>
<a name="ln56">// &quot;*value_length&quot;, respectively.  Will not derefence past &quot;limit&quot;.</a>
<a name="ln57">//</a>
<a name="ln58">// If any errors are detected, returns nullptr.  Otherwise, returns a</a>
<a name="ln59">// pointer to the key delta (just past the three decoded values).</a>
<a name="ln60">static inline const char* DecodeEntry(const char* p, const char* limit,</a>
<a name="ln61">                                      uint32_t* shared,</a>
<a name="ln62">                                      uint32_t* non_shared,</a>
<a name="ln63">                                      uint32_t* value_length) {</a>
<a name="ln64">  if (limit - p &lt; 3) return nullptr;</a>
<a name="ln65">  *shared = reinterpret_cast&lt;const unsigned char*&gt;(p)[0];</a>
<a name="ln66">  *non_shared = reinterpret_cast&lt;const unsigned char*&gt;(p)[1];</a>
<a name="ln67">  *value_length = reinterpret_cast&lt;const unsigned char*&gt;(p)[2];</a>
<a name="ln68">  if ((*shared | *non_shared | *value_length) &lt; 128) {</a>
<a name="ln69">    // Fast path: all three values are encoded in one byte each</a>
<a name="ln70">    p += 3;</a>
<a name="ln71">  } else {</a>
<a name="ln72">    if ((p = GetVarint32Ptr(p, limit, shared)) == nullptr) return nullptr;</a>
<a name="ln73">    if ((p = GetVarint32Ptr(p, limit, non_shared)) == nullptr) return nullptr;</a>
<a name="ln74">    if ((p = GetVarint32Ptr(p, limit, value_length)) == nullptr) return nullptr;</a>
<a name="ln75">  }</a>
<a name="ln76"> </a>
<a name="ln77">  if (static_cast&lt;uint32_t&gt;(limit - p) &lt; (*non_shared + *value_length)) {</a>
<a name="ln78">    return nullptr;</a>
<a name="ln79">  }</a>
<a name="ln80">  return p;</a>
<a name="ln81">}</a>
<a name="ln82"> </a>
<a name="ln83">void BlockIter::Next() {</a>
<a name="ln84">  assert(Valid());</a>
<a name="ln85">  ParseNextKey();</a>
<a name="ln86">}</a>
<a name="ln87"> </a>
<a name="ln88">void BlockIter::Prev() {</a>
<a name="ln89">  assert(Valid());</a>
<a name="ln90"> </a>
<a name="ln91">  // Scan backwards to a restart point before current_</a>
<a name="ln92">  const uint32_t original = current_;</a>
<a name="ln93">  while (GetRestartPoint(restart_index_) &gt;= original) {</a>
<a name="ln94">    if (restart_index_ == 0) {</a>
<a name="ln95">      // No more entries</a>
<a name="ln96">      current_ = restarts_;</a>
<a name="ln97">      restart_index_ = num_restarts_;</a>
<a name="ln98">      return;</a>
<a name="ln99">    }</a>
<a name="ln100">    restart_index_--;</a>
<a name="ln101">  }</a>
<a name="ln102"> </a>
<a name="ln103">  SeekToRestartPoint(restart_index_);</a>
<a name="ln104">  do {</a>
<a name="ln105">    // Loop until end of current entry hits the start of original entry</a>
<a name="ln106">  } while (ParseNextKey() &amp;&amp; NextEntryOffset() &lt; original);</a>
<a name="ln107">}</a>
<a name="ln108"> </a>
<a name="ln109">void BlockIter::Initialize(const Comparator* comparator, const char* data,</a>
<a name="ln110">                           uint32_t restarts, uint32_t num_restarts, BlockHashIndex* hash_index,</a>
<a name="ln111">                           BlockPrefixIndex* prefix_index) {</a>
<a name="ln112">  DCHECK(data_ == nullptr); // Ensure it is called only once</a>
<a name="ln113">  DCHECK_GT(num_restarts, 0); // Ensure the param is valid</a>
<a name="ln114"> </a>
<a name="ln115">  comparator_ = comparator;</a>
<a name="ln116">  data_ = data;</a>
<a name="ln117">  restarts_ = restarts;</a>
<a name="ln118">  num_restarts_ = num_restarts;</a>
<a name="ln119">  current_ = restarts_;</a>
<a name="ln120">  restart_index_ = num_restarts_;</a>
<a name="ln121">  hash_index_ = hash_index;</a>
<a name="ln122">  prefix_index_ = prefix_index;</a>
<a name="ln123">}</a>
<a name="ln124"> </a>
<a name="ln125"> </a>
<a name="ln126">void BlockIter::Seek(const Slice&amp; target) {</a>
<a name="ln127">  PERF_TIMER_GUARD(block_seek_nanos);</a>
<a name="ln128">  if (data_ == nullptr) {  // Not init yet</a>
<a name="ln129">    return;</a>
<a name="ln130">  }</a>
<a name="ln131">  uint32_t index = 0;</a>
<a name="ln132">  bool ok = false;</a>
<a name="ln133">  if (prefix_index_) {</a>
<a name="ln134">    ok = PrefixSeek(target, &amp;index);</a>
<a name="ln135">  } else {</a>
<a name="ln136">    ok = hash_index_ ? HashSeek(target, &amp;index)</a>
<a name="ln137">      : BinarySeek(target, 0, num_restarts_ - 1, &amp;index);</a>
<a name="ln138">  }</a>
<a name="ln139"> </a>
<a name="ln140">  if (!ok) {</a>
<a name="ln141">    return;</a>
<a name="ln142">  }</a>
<a name="ln143">  SeekToRestartPoint(index);</a>
<a name="ln144">  // Linear search (within restart block) for first key &gt;= target</a>
<a name="ln145"> </a>
<a name="ln146">  while (true) {</a>
<a name="ln147">    if (!ParseNextKey() || Compare(key_.GetKey(), target) &gt;= 0) {</a>
<a name="ln148">      return;</a>
<a name="ln149">    }</a>
<a name="ln150">  }</a>
<a name="ln151">}</a>
<a name="ln152"> </a>
<a name="ln153">void BlockIter::SeekToFirst() {</a>
<a name="ln154">  if (data_ == nullptr) {  // Not init yet</a>
<a name="ln155">    return;</a>
<a name="ln156">  }</a>
<a name="ln157">  SeekToRestartPoint(0);</a>
<a name="ln158">  ParseNextKey();</a>
<a name="ln159">}</a>
<a name="ln160"> </a>
<a name="ln161">void BlockIter::SeekToLast() {</a>
<a name="ln162">  if (data_ == nullptr) {  // Not init yet</a>
<a name="ln163">    return;</a>
<a name="ln164">  }</a>
<a name="ln165">  SeekToRestartPoint(num_restarts_ - 1);</a>
<a name="ln166">  while (ParseNextKey() &amp;&amp; NextEntryOffset() &lt; restarts_) {</a>
<a name="ln167">    // Keep skipping</a>
<a name="ln168">  }</a>
<a name="ln169">}</a>
<a name="ln170"> </a>
<a name="ln171"> </a>
<a name="ln172">namespace {</a>
<a name="ln173"> </a>
<a name="ln174">Status BadBlockContentsError() {</a>
<a name="ln175">  return STATUS(Corruption, &quot;bad block contents&quot;);</a>
<a name="ln176">}</a>
<a name="ln177"> </a>
<a name="ln178">Status BadEntryInBlockError() {</a>
<a name="ln179">  return STATUS(Corruption, &quot;bad entry in block&quot;);</a>
<a name="ln180">}</a>
<a name="ln181"> </a>
<a name="ln182">} // namespace</a>
<a name="ln183"> </a>
<a name="ln184">void BlockIter::CorruptionError() {</a>
<a name="ln185">  current_ = restarts_;</a>
<a name="ln186">  restart_index_ = num_restarts_;</a>
<a name="ln187">  status_ = BadEntryInBlockError();</a>
<a name="ln188">  key_.Clear();</a>
<a name="ln189">  value_.clear();</a>
<a name="ln190">}</a>
<a name="ln191"> </a>
<a name="ln192">bool BlockIter::ParseNextKey() {</a>
<a name="ln193">  current_ = NextEntryOffset();</a>
<a name="ln194">  const char* p = data_ + current_;</a>
<a name="ln195">  const char* limit = data_ + restarts_;  // Restarts come right after data</a>
<a name="ln196">  if (p &gt;= limit) {</a>
<a name="ln197">    // No more entries to return.  Mark as invalid.</a>
<a name="ln198">    current_ = restarts_;</a>
<a name="ln199">    restart_index_ = num_restarts_;</a>
<a name="ln200">    return false;</a>
<a name="ln201">  }</a>
<a name="ln202"> </a>
<a name="ln203">  // Decode next entry</a>
<a name="ln204">  uint32_t shared, non_shared, value_length;</a>
<a name="ln205">  p = DecodeEntry(p, limit, &amp;shared, &amp;non_shared, &amp;value_length);</a>
<a name="ln206">  if (p == nullptr || key_.Size() &lt; shared) {</a>
<a name="ln207">    CorruptionError();</a>
<a name="ln208">    return false;</a>
<a name="ln209">  } else {</a>
<a name="ln210">    if (shared == 0) {</a>
<a name="ln211">      // If this key dont share any bytes with prev key then we dont need</a>
<a name="ln212">      // to decode it and can use it's address in the block directly.</a>
<a name="ln213">      key_.SetKey(Slice(p, non_shared), false /* copy */);</a>
<a name="ln214">    } else {</a>
<a name="ln215">      // This key share `shared` bytes with prev key, we need to decode it</a>
<a name="ln216">      key_.TrimAppend(shared, p, non_shared);</a>
<a name="ln217">    }</a>
<a name="ln218">    value_ = Slice(p + non_shared, value_length);</a>
<a name="ln219">    while (restart_index_ + 1 &lt; num_restarts_ &amp;&amp;</a>
<a name="ln220">           GetRestartPoint(restart_index_ + 1) &lt; current_) {</a>
<a name="ln221">      ++restart_index_;</a>
<a name="ln222">    }</a>
<a name="ln223">    return true;</a>
<a name="ln224">  }</a>
<a name="ln225">}</a>
<a name="ln226"> </a>
<a name="ln227">// Binary search in restart array to find the first restart point</a>
<a name="ln228">// with a key &gt;= target (TODO: this comment is inaccurate)</a>
<a name="ln229">bool BlockIter::BinarySeek(const Slice&amp; target, uint32_t left, uint32_t right,</a>
<a name="ln230">                  uint32_t* index) {</a>
<a name="ln231">  assert(left &lt;= right);</a>
<a name="ln232"> </a>
<a name="ln233">  while (left &lt; right) {</a>
<a name="ln234">    uint32_t mid = (left + right + 1) / 2;</a>
<a name="ln235">    uint32_t region_offset = GetRestartPoint(mid);</a>
<a name="ln236">    uint32_t shared, non_shared, value_length;</a>
<a name="ln237">    const char* key_ptr =</a>
<a name="ln238">        DecodeEntry(data_ + region_offset, data_ + restarts_, &amp;shared,</a>
<a name="ln239">                    &amp;non_shared, &amp;value_length);</a>
<a name="ln240">    if (key_ptr == nullptr || (shared != 0)) {</a>
<a name="ln241">      CorruptionError();</a>
<a name="ln242">      return false;</a>
<a name="ln243">    }</a>
<a name="ln244">    Slice mid_key(key_ptr, non_shared);</a>
<a name="ln245">    int cmp = Compare(mid_key, target);</a>
<a name="ln246">    if (cmp &lt; 0) {</a>
<a name="ln247">      // Key at &quot;mid&quot; is smaller than &quot;target&quot;. Therefore all</a>
<a name="ln248">      // blocks before &quot;mid&quot; are uninteresting.</a>
<a name="ln249">      left = mid;</a>
<a name="ln250">    } else if (cmp &gt; 0) {</a>
<a name="ln251">      // Key at &quot;mid&quot; is &gt;= &quot;target&quot;. Therefore all blocks at or</a>
<a name="ln252">      // after &quot;mid&quot; are uninteresting.</a>
<a name="ln253">      right = mid - 1;</a>
<a name="ln254">    } else {</a>
<a name="ln255">      left = right = mid;</a>
<a name="ln256">    }</a>
<a name="ln257">  }</a>
<a name="ln258"> </a>
<a name="ln259">  *index = left;</a>
<a name="ln260">  return true;</a>
<a name="ln261">}</a>
<a name="ln262"> </a>
<a name="ln263">// Compare target key and the block key of the block of `block_index`.</a>
<a name="ln264">// Return -1 if error.</a>
<a name="ln265">int BlockIter::CompareBlockKey(uint32_t block_index, const Slice&amp; target) {</a>
<a name="ln266">  uint32_t region_offset = GetRestartPoint(block_index);</a>
<a name="ln267">  uint32_t shared, non_shared, value_length;</a>
<a name="ln268">  const char* key_ptr = DecodeEntry(data_ + region_offset, data_ + restarts_,</a>
<a name="ln269">                                    &amp;shared, &amp;non_shared, &amp;value_length);</a>
<a name="ln270">  if (key_ptr == nullptr || (shared != 0)) {</a>
<a name="ln271">    CorruptionError();</a>
<a name="ln272">    return 1;  // Return target is smaller</a>
<a name="ln273">  }</a>
<a name="ln274">  Slice block_key(key_ptr, non_shared);</a>
<a name="ln275">  return Compare(block_key, target);</a>
<a name="ln276">}</a>
<a name="ln277"> </a>
<a name="ln278">// Binary search in block_ids to find the first block</a>
<a name="ln279">// with a key &gt;= target</a>
<a name="ln280">bool BlockIter::BinaryBlockIndexSeek(const Slice&amp; target, uint32_t* block_ids,</a>
<a name="ln281">                          uint32_t left, uint32_t right,</a>
<a name="ln282">                          uint32_t* index) {</a>
<a name="ln283">  assert(left &lt;= right);</a>
<a name="ln284">  uint32_t left_bound = left;</a>
<a name="ln285"> </a>
<a name="ln286">  while (left &lt;= right) {</a>
<a name="ln287">    uint32_t mid = (left + right) / 2;</a>
<a name="ln288"> </a>
<a name="ln289">    int cmp = CompareBlockKey(block_ids[mid], target);</a>
<a name="ln290">    if (!status_.ok()) {</a>
<a name="ln291">      return false;</a>
<a name="ln292">    }</a>
<a name="ln293">    if (cmp &lt; 0) {</a>
<a name="ln294">      // Key at &quot;target&quot; is larger than &quot;mid&quot;. Therefore all</a>
<a name="ln295">      // blocks before or at &quot;mid&quot; are uninteresting.</a>
<a name="ln296">      left = mid + 1;</a>
<a name="ln297">    } else {</a>
<a name="ln298">      // Key at &quot;target&quot; is &lt;= &quot;mid&quot;. Therefore all blocks</a>
<a name="ln299">      // after &quot;mid&quot; are uninteresting.</a>
<a name="ln300">      // If there is only one block left, we found it.</a>
<a name="ln301">      if (left == right) break;</a>
<a name="ln302">      right = mid;</a>
<a name="ln303">    }</a>
<a name="ln304">  }</a>
<a name="ln305"> </a>
<a name="ln306">  if (left == right) {</a>
<a name="ln307">    // In one of the two following cases:</a>
<a name="ln308">    // (1) left is the first one of block_ids</a>
<a name="ln309">    // (2) there is a gap of blocks between block of `left` and `left-1`.</a>
<a name="ln310">    // we can further distinguish the case of key in the block or key not</a>
<a name="ln311">    // existing, by comparing the target key and the key of the previous</a>
<a name="ln312">    // block to the left of the block found.</a>
<a name="ln313">    if (block_ids[left] &gt; 0 &amp;&amp;</a>
<a name="ln314">        (left == left_bound || block_ids[left - 1] != block_ids[left] - 1) &amp;&amp;</a>
<a name="ln315">        CompareBlockKey(block_ids[left] - 1, target) &gt; 0) {</a>
<a name="ln316">      current_ = restarts_;</a>
<a name="ln317">      return false;</a>
<a name="ln318">    }</a>
<a name="ln319"> </a>
<a name="ln320">    *index = block_ids[left];</a>
<a name="ln321">    return true;</a>
<a name="ln322">  } else {</a>
<a name="ln323">    assert(left &gt; right);</a>
<a name="ln324">    // Mark iterator invalid</a>
<a name="ln325">    current_ = restarts_;</a>
<a name="ln326">    return false;</a>
<a name="ln327">  }</a>
<a name="ln328">}</a>
<a name="ln329"> </a>
<a name="ln330">bool BlockIter::HashSeek(const Slice&amp; target, uint32_t* index) {</a>
<a name="ln331">  assert(hash_index_);</a>
<a name="ln332">  auto restart_index = hash_index_-&gt;GetRestartIndex(target);</a>
<a name="ln333">  if (restart_index == nullptr) {</a>
<a name="ln334">    current_ = restarts_;</a>
<a name="ln335">    return false;</a>
<a name="ln336">  }</a>
<a name="ln337"> </a>
<a name="ln338">  // the elements in restart_array[index : index + num_blocks]</a>
<a name="ln339">  // are all with same prefix. We'll do binary search in that small range.</a>
<a name="ln340">  auto left = restart_index-&gt;first_index;</a>
<a name="ln341">  auto right = restart_index-&gt;first_index + restart_index-&gt;num_blocks - 1;</a>
<a name="ln342">  return BinarySeek(target, left, right, index);</a>
<a name="ln343">}</a>
<a name="ln344"> </a>
<a name="ln345">bool BlockIter::PrefixSeek(const Slice&amp; target, uint32_t* index) {</a>
<a name="ln346">  assert(prefix_index_);</a>
<a name="ln347">  uint32_t* block_ids = nullptr;</a>
<a name="ln348">  uint32_t num_blocks = prefix_index_-&gt;GetBlocks(target, &amp;block_ids);</a>
<a name="ln349"> </a>
<a name="ln350">  if (num_blocks == 0) {</a>
<a name="ln351">    current_ = restarts_;</a>
<a name="ln352">    return false;</a>
<a name="ln353">  } else  {</a>
<a name="ln354">    return BinaryBlockIndexSeek(target, block_ids, 0, num_blocks - 1, index);</a>
<a name="ln355">  }</a>
<a name="ln356">}</a>
<a name="ln357"> </a>
<a name="ln358">uint32_t Block::NumRestarts() const {</a>
<a name="ln359">  assert(size_ &gt;= kMinBlockSize);</a>
<a name="ln360">  return DecodeFixed32(data_ + size_ - sizeof(uint32_t));</a>
<a name="ln361">}</a>
<a name="ln362"> </a>
<a name="ln363">Block::Block(BlockContents&amp;&amp; contents)</a>
<a name="ln364">    : contents_(std::move(contents)),</a>
<a name="ln365">      data_(contents_.data.cdata()),</a>
<a name="ln366">      size_(contents_.data.size()) {</a>
<a name="ln367">  if (size_ &lt; sizeof(uint32_t)) {</a>
<a name="ln368">    size_ = 0;  // Error marker</a>
<a name="ln369">  } else {</a>
<a name="ln370">    restart_offset_ =</a>
<a name="ln371">        static_cast&lt;uint32_t&gt;(size_) - (1 + NumRestarts()) * sizeof(uint32_t);</a>
<a name="ln372">    if (restart_offset_ &gt; size_ - sizeof(uint32_t)) {</a>
<a name="ln373">      // The size is too small for NumRestarts() and therefore</a>
<a name="ln374">      // restart_offset_ wrapped around.</a>
<a name="ln375">      size_ = 0;</a>
<a name="ln376">    }</a>
<a name="ln377">  }</a>
<a name="ln378">}</a>
<a name="ln379"> </a>
<a name="ln380">InternalIterator* Block::NewIterator(const Comparator* cmp, BlockIter* iter,</a>
<a name="ln381">                                     bool total_order_seek) {</a>
<a name="ln382">  if (size_ &lt; kMinBlockSize) {</a>
<a name="ln383">    if (iter != nullptr) {</a>
<a name="ln384">      iter-&gt;SetStatus(BadBlockContentsError());</a>
<a name="ln385">      return iter;</a>
<a name="ln386">    } else {</a>
<a name="ln387">      return NewErrorInternalIterator(BadBlockContentsError());</a>
<a name="ln388">    }</a>
<a name="ln389">  }</a>
<a name="ln390">  const uint32_t num_restarts = NumRestarts();</a>
<a name="ln391">  if (num_restarts == 0) {</a>
<a name="ln392">    if (iter != nullptr) {</a>
<a name="ln393">      iter-&gt;SetStatus(Status::OK());</a>
<a name="ln394">      return iter;</a>
<a name="ln395">    } else {</a>
<a name="ln396">      return NewEmptyInternalIterator();</a>
<a name="ln397">    }</a>
<a name="ln398">  } else {</a>
<a name="ln399">    BlockHashIndex* hash_index_ptr =</a>
<a name="ln400">        total_order_seek ? nullptr : hash_index_.get();</a>
<a name="ln401">    BlockPrefixIndex* prefix_index_ptr =</a>
<a name="ln402">        total_order_seek ? nullptr : prefix_index_.get();</a>
<a name="ln403"> </a>
<a name="ln404">    if (iter != nullptr) {</a>
<a name="ln405">      iter-&gt;Initialize(cmp, data_, restart_offset_, num_restarts,</a>
<a name="ln406">                    hash_index_ptr, prefix_index_ptr);</a>
<a name="ln407">    } else {</a>
<a name="ln408">      iter = new BlockIter(cmp, data_, restart_offset_, num_restarts,</a>
<a name="ln409">                           hash_index_ptr, prefix_index_ptr);</a>
<a name="ln410">    }</a>
<a name="ln411">  }</a>
<a name="ln412"> </a>
<a name="ln413">  return iter;</a>
<a name="ln414">}</a>
<a name="ln415"> </a>
<a name="ln416">void Block::SetBlockHashIndex(BlockHashIndex* hash_index) {</a>
<a name="ln417">  hash_index_.reset(hash_index);</a>
<a name="ln418">}</a>
<a name="ln419"> </a>
<a name="ln420">void Block::SetBlockPrefixIndex(BlockPrefixIndex* prefix_index) {</a>
<a name="ln421">  prefix_index_.reset(prefix_index);</a>
<a name="ln422">}</a>
<a name="ln423"> </a>
<a name="ln424">size_t Block::ApproximateMemoryUsage() const {</a>
<a name="ln425">  size_t usage = usable_size();</a>
<a name="ln426">  if (hash_index_) {</a>
<a name="ln427">    usage += hash_index_-&gt;ApproximateMemoryUsage();</a>
<a name="ln428">  }</a>
<a name="ln429">  if (prefix_index_) {</a>
<a name="ln430">    usage += prefix_index_-&gt;ApproximateMemoryUsage();</a>
<a name="ln431">  }</a>
<a name="ln432">  return usage;</a>
<a name="ln433">}</a>
<a name="ln434"> </a>
<a name="ln435">yb::Result&lt;Slice&gt; Block::GetMiddleKey() const {</a>
<a name="ln436">  if (size_ &lt; kMinBlockSize) {</a>
<a name="ln437">    return BadBlockContentsError();</a>
<a name="ln438">  } else if (size_ == kMinBlockSize) {</a>
<a name="ln439">    return STATUS(Incomplete, &quot;Empty block&quot;);</a>
<a name="ln440">  }</a>
<a name="ln441"> </a>
<a name="ln442">  const auto restart_idx = (NumRestarts() - 1) / 2;</a>
<a name="ln443"> </a>
<a name="ln444">  const auto entry_offset = DecodeFixed32(data_ + restart_offset_ + restart_idx * sizeof(uint32_t));</a>
<a name="ln445">  uint32_t shared, non_shared, value_length;</a>
<a name="ln446">  const char* key_ptr = DecodeEntry(</a>
<a name="ln447">      data_ + entry_offset, data_ + restart_offset_, &amp;shared, &amp;non_shared, &amp;value_length);</a>
<a name="ln448">  if (key_ptr == nullptr || (shared != 0)) {</a>
<a name="ln449">    return BadEntryInBlockError();</a>
<a name="ln450">  }</a>
<a name="ln451">  return Slice(key_ptr, non_shared);</a>
<a name="ln452">}</a>
<a name="ln453"> </a>
<a name="ln454">}  // namespace rocksdb</a>

</code></pre>
<div class="balloon" rel="112"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
