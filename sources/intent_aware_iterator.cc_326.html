
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>intent_aware_iterator.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Copyright (c) YugaByte, Inc.</a>
<a name="ln2">//</a>
<a name="ln3">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln4">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln5">//</a>
<a name="ln6">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln7">//</a>
<a name="ln8">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln9">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln10">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln11">// under the License.</a>
<a name="ln12">//</a>
<a name="ln13"> </a>
<a name="ln14">#include &quot;yb/docdb/intent_aware_iterator.h&quot;</a>
<a name="ln15"> </a>
<a name="ln16">#include &lt;future&gt;</a>
<a name="ln17">#include &lt;thread&gt;</a>
<a name="ln18">#include &lt;boost/optional/optional_io.hpp&gt;</a>
<a name="ln19"> </a>
<a name="ln20">#include &quot;yb/common/doc_hybrid_time.h&quot;</a>
<a name="ln21">#include &quot;yb/common/hybrid_time.h&quot;</a>
<a name="ln22">#include &quot;yb/common/transaction.h&quot;</a>
<a name="ln23"> </a>
<a name="ln24">#include &quot;yb/docdb/conflict_resolution.h&quot;</a>
<a name="ln25">#include &quot;yb/docdb/docdb.h&quot;</a>
<a name="ln26">#include &quot;yb/docdb/docdb_rocksdb_util.h&quot;</a>
<a name="ln27">#include &quot;yb/docdb/docdb-internal.h&quot;</a>
<a name="ln28">#include &quot;yb/docdb/intent.h&quot;</a>
<a name="ln29">#include &quot;yb/docdb/value.h&quot;</a>
<a name="ln30"> </a>
<a name="ln31">#include &quot;yb/server/hybrid_clock.h&quot;</a>
<a name="ln32">#include &quot;yb/util/backoff_waiter.h&quot;</a>
<a name="ln33">#include &quot;yb/util/bytes_formatter.h&quot;</a>
<a name="ln34">#include &quot;yb/util/tsan_util.h&quot;</a>
<a name="ln35"> </a>
<a name="ln36">using namespace std::literals;</a>
<a name="ln37"> </a>
<a name="ln38">DEFINE_bool(TEST_transaction_allow_rerequest_status, true,</a>
<a name="ln39">            &quot;Allow rerequest transaction status when try again is received.&quot;);</a>
<a name="ln40"> </a>
<a name="ln41">namespace yb {</a>
<a name="ln42">namespace docdb {</a>
<a name="ln43"> </a>
<a name="ln44">namespace {</a>
<a name="ln45"> </a>
<a name="ln46">void GetIntentPrefixForKeyWithoutHt(const Slice&amp; key, KeyBytes* out) {</a>
<a name="ln47">  out-&gt;Clear();</a>
<a name="ln48">  // Since caller guarantees that key_bytes doesn't have hybrid time, we can simply use it</a>
<a name="ln49">  // to get prefix for all related intents.</a>
<a name="ln50">  out-&gt;AppendRawBytes(key);</a>
<a name="ln51">}</a>
<a name="ln52"> </a>
<a name="ln53">KeyBytes GetIntentPrefixForKeyWithoutHt(const Slice&amp; key) {</a>
<a name="ln54">  KeyBytes result;</a>
<a name="ln55">  GetIntentPrefixForKeyWithoutHt(key, &amp;result);</a>
<a name="ln56">  return result;</a>
<a name="ln57">}</a>
<a name="ln58"> </a>
<a name="ln59">void AppendEncodedDocHt(const Slice&amp; encoded_doc_ht, KeyBytes* key_bytes) {</a>
<a name="ln60">  key_bytes-&gt;AppendValueType(ValueType::kHybridTime);</a>
<a name="ln61">  key_bytes-&gt;AppendRawBytes(encoded_doc_ht);</a>
<a name="ln62">}</a>
<a name="ln63"> </a>
<a name="ln64">const char kStrongWriteTail[] = {</a>
<a name="ln65">    ValueTypeAsChar::kIntentTypeSet,</a>
<a name="ln66">    static_cast&lt;char&gt;(IntentTypeSet({IntentType::kStrongWrite}).ToUIntPtr()) };</a>
<a name="ln67"> </a>
<a name="ln68">const Slice kStrongWriteTailSlice = Slice(kStrongWriteTail, sizeof(kStrongWriteTail));</a>
<a name="ln69"> </a>
<a name="ln70">char kEmptyKeyStrongWriteTail[] = {</a>
<a name="ln71">    ValueTypeAsChar::kGroupEnd,</a>
<a name="ln72">    ValueTypeAsChar::kIntentTypeSet,</a>
<a name="ln73">    static_cast&lt;char&gt;(IntentTypeSet({IntentType::kStrongWrite}).ToUIntPtr()) };</a>
<a name="ln74"> </a>
<a name="ln75">const Slice kEmptyKeyStrongWriteTailSlice =</a>
<a name="ln76">    Slice(kEmptyKeyStrongWriteTail, sizeof(kEmptyKeyStrongWriteTail));</a>
<a name="ln77"> </a>
<a name="ln78">Slice StrongWriteSuffix(const KeyBytes&amp; key) {</a>
<a name="ln79">  return key.empty() ? kEmptyKeyStrongWriteTailSlice : kStrongWriteTailSlice;</a>
<a name="ln80">}</a>
<a name="ln81"> </a>
<a name="ln82">// We are not interested in weak and read intents here.</a>
<a name="ln83">// So could just skip them.</a>
<a name="ln84">void AppendStrongWrite(KeyBytes* out) {</a>
<a name="ln85">  out-&gt;AppendRawBytes(StrongWriteSuffix(*out));</a>
<a name="ln86">}</a>
<a name="ln87"> </a>
<a name="ln88">} // namespace</a>
<a name="ln89"> </a>
<a name="ln90">// For locally committed transactions returns commit time if committed at specified time or</a>
<a name="ln91">// HybridTime::kMin otherwise. For other transactions returns HybridTime::kInvalid.</a>
<a name="ln92">HybridTime TransactionStatusCache::GetLocalCommitTime(const TransactionId&amp; transaction_id) {</a>
<a name="ln93">  const HybridTime local_commit_time = txn_status_manager_-&gt;LocalCommitTime(transaction_id);</a>
<a name="ln94">  return local_commit_time.is_valid()</a>
<a name="ln95">      ? local_commit_time &lt;= read_time_.global_limit ? local_commit_time : HybridTime::kMin</a>
<a name="ln96">      : local_commit_time;</a>
<a name="ln97">}</a>
<a name="ln98"> </a>
<a name="ln99">Result&lt;HybridTime&gt; TransactionStatusCache::GetCommitTime(const TransactionId&amp; transaction_id) {</a>
<a name="ln100">  auto it = cache_.find(transaction_id);</a>
<a name="ln101">  if (it != cache_.end()) {</a>
<a name="ln102">    return it-&gt;second;</a>
<a name="ln103">  }</a>
<a name="ln104"> </a>
<a name="ln105">  auto result = DoGetCommitTime(transaction_id);</a>
<a name="ln106">  if (result.ok()) {</a>
<a name="ln107">    cache_.emplace(transaction_id, *result);</a>
<a name="ln108">  }</a>
<a name="ln109">  return result;</a>
<a name="ln110">}</a>
<a name="ln111"> </a>
<a name="ln112">Status StatusWaitTimedOut(const TransactionId&amp; transaction_id) {</a>
<a name="ln113">  return STATUS_FORMAT(</a>
<a name="ln114">      TimedOut, &quot;Timed out waiting for transaction status: $0&quot;, transaction_id);</a>
<a name="ln115">}</a>
<a name="ln116"> </a>
<a name="ln117">Result&lt;HybridTime&gt; TransactionStatusCache::DoGetCommitTime(const TransactionId&amp; transaction_id) {</a>
<a name="ln118">  HybridTime local_commit_time = GetLocalCommitTime(transaction_id);</a>
<a name="ln119">  if (local_commit_time.is_valid()) {</a>
<a name="ln120">    return local_commit_time;</a>
<a name="ln121">  }</a>
<a name="ln122"> </a>
<a name="ln123">  // Since TransactionStatusResult does not have default ctor we should init it somehow.</a>
<a name="ln124">  TransactionStatusResult txn_status(TransactionStatus::ABORTED, HybridTime());</a>
<a name="ln125">  const auto kMaxWait = 50ms * kTimeMultiplier;</a>
<a name="ln126">  const auto kRequestTimeout = kMaxWait;</a>
<a name="ln127">  bool retry_allowed = FLAGS_TEST_transaction_allow_rerequest_status;</a>
<a name="ln128">  CoarseBackoffWaiter waiter(deadline_, kMaxWait);</a>
<a name="ln129">  static const std::string kRequestReason = &quot;get commit time&quot;s;</a>
<a name="ln130">  for(;;) {</a>
<a name="ln131">    auto txn_status_promise = std::make_shared&lt;std::promise&lt;Result&lt;TransactionStatusResult&gt;&gt;&gt;();</a>
<a name="ln132">    auto future = txn_status_promise-&gt;get_future();</a>
<a name="ln133">    auto callback = [txn_status_promise](Result&lt;TransactionStatusResult&gt; result) {</a>
<a name="ln134">      txn_status_promise-&gt;set_value(std::move(result));</a>
<a name="ln135">    };</a>
<a name="ln136">    txn_status_manager_-&gt;RequestStatusAt(</a>
<a name="ln137">        {&amp;transaction_id, read_time_.read, read_time_.global_limit, read_time_.serial_no,</a>
<a name="ln138">              &amp;kRequestReason,</a>
<a name="ln139">              TransactionLoadFlags{TransactionLoadFlag::kCleanup},</a>
<a name="ln140">              callback});</a>
<a name="ln141">    auto wait_start = CoarseMonoClock::now();</a>
<a name="ln142">    auto future_status = future.wait_until(</a>
<a name="ln143">        retry_allowed ? wait_start + kRequestTimeout : deadline_);</a>
<a name="ln144">    if (future_status == std::future_status::ready) {</a>
<a name="ln145">      auto txn_status_result = future.get();</a>
<a name="ln146">      if (txn_status_result.ok()) {</a>
<a name="ln147">        txn_status = *txn_status_result;</a>
<a name="ln148">        break;</a>
<a name="ln149">      }</a>
<a name="ln150">      if (txn_status_result.status().IsNotFound()) {</a>
<a name="ln151">        // We have intent w/o metadata, that means that transaction was already cleaned up.</a>
<a name="ln152">        LOG(WARNING) &lt;&lt; &quot;Intent for transaction w/o metadata: &quot; &lt;&lt; transaction_id;</a>
<a name="ln153">        return HybridTime::kMin;</a>
<a name="ln154">      }</a>
<a name="ln155">      LOG(WARNING)</a>
<a name="ln156">          &lt;&lt; &quot;Failed to request transaction &quot; &lt;&lt; transaction_id &lt;&lt; &quot; status: &quot;</a>
<a name="ln157">          &lt;&lt;  txn_status_result.status();</a>
<a name="ln158">      if (!txn_status_result.status().IsTryAgain()) {</a>
<a name="ln159">        return std::move(txn_status_result.status());</a>
<a name="ln160">      }</a>
<a name="ln161">      if (!waiter.Wait()) {</a>
<a name="ln162">        return StatusWaitTimedOut(transaction_id);</a>
<a name="ln163">      }</a>
<a name="ln164">    } else {</a>
<a name="ln165">      LOG(INFO) &lt;&lt; &quot;TXN: &quot; &lt;&lt; transaction_id &lt;&lt; &quot;: Timed out waiting txn status, waited: &quot;</a>
<a name="ln166">                &lt;&lt; MonoDelta(CoarseMonoClock::now() - wait_start)</a>
<a name="ln167">                &lt;&lt; &quot;, future status: &quot; &lt;&lt; to_underlying(future_status)</a>
<a name="ln168">                &lt;&lt; &quot;, left to deadline: &quot; &lt;&lt; MonoDelta(deadline_ - CoarseMonoClock::now());</a>
<a name="ln169">      if (waiter.ExpiredNow()) {</a>
<a name="ln170">        return StatusWaitTimedOut(transaction_id);</a>
<a name="ln171">      }</a>
<a name="ln172">      waiter.NextAttempt();</a>
<a name="ln173">    }</a>
<a name="ln174">    DCHECK(retry_allowed);</a>
<a name="ln175">  }</a>
<a name="ln176">  VLOG(4) &lt;&lt; &quot;Transaction_id &quot; &lt;&lt; transaction_id &lt;&lt; &quot; at &quot; &lt;&lt; read_time_</a>
<a name="ln177">          &lt;&lt; &quot;: status: &quot; &lt;&lt; TransactionStatus_Name(txn_status.status)</a>
<a name="ln178">          &lt;&lt; &quot;, status_time: &quot; &lt;&lt; txn_status.status_time;</a>
<a name="ln179">  // There could be case when transaction was committed and applied between previous call to</a>
<a name="ln180">  // GetLocalCommitTime, in this case coordinator does not know transaction and will respond</a>
<a name="ln181">  // with ABORTED status. So we recheck whether it was committed locally.</a>
<a name="ln182">  if (txn_status.status == TransactionStatus::ABORTED) {</a>
<a name="ln183">    local_commit_time = GetLocalCommitTime(transaction_id);</a>
<a name="ln184">    return local_commit_time.is_valid() ? local_commit_time : HybridTime::kMin;</a>
<a name="ln185">  } else {</a>
<a name="ln186">    return txn_status.status == TransactionStatus::COMMITTED ? txn_status.status_time</a>
<a name="ln187">        : HybridTime::kMin;</a>
<a name="ln188">  }</a>
<a name="ln189">}</a>
<a name="ln190"> </a>
<a name="ln191">namespace {</a>
<a name="ln192"> </a>
<a name="ln193">struct DecodeStrongWriteIntentResult {</a>
<a name="ln194">  Slice intent_prefix;</a>
<a name="ln195">  Slice intent_value;</a>
<a name="ln196">  DocHybridTime value_time;</a>
<a name="ln197">  IntentTypeSet intent_types;</a>
<a name="ln198"> </a>
<a name="ln199">  // Whether this intent from the same transaction as specified in context.</a>
<a name="ln200">  bool same_transaction = false;</a>
<a name="ln201"> </a>
<a name="ln202">  std::string ToString() const {</a>
<a name="ln203">    return Format(&quot;{ intent_prefix: $0 intent_value: $1 value_time: $2 same_transaction: $3 &quot;</a>
<a name="ln204">                  &quot;intent_types: $4 }&quot;,</a>
<a name="ln205">                  intent_prefix.ToDebugHexString(), intent_value.ToDebugHexString(), value_time,</a>
<a name="ln206">                  same_transaction, intent_types);</a>
<a name="ln207">  }</a>
<a name="ln208">};</a>
<a name="ln209"> </a>
<a name="ln210">std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const DecodeStrongWriteIntentResult&amp; result) {</a>
<a name="ln211">  return out &lt;&lt; result.ToString();</a>
<a name="ln212">}</a>
<a name="ln213"> </a>
<a name="ln214">// Decodes intent based on intent_iterator and its transaction commit time if intent is a strong</a>
<a name="ln215">// write intent, intent is not for row locking, and transaction is already committed at specified</a>
<a name="ln216">// time or is current transaction.</a>
<a name="ln217">// Returns HybridTime::kMin as value_time otherwise.</a>
<a name="ln218">// For current transaction returns intent record hybrid time as value_time.</a>
<a name="ln219">// Consumes intent from value_slice leaving only value itself.</a>
<a name="ln220">Result&lt;DecodeStrongWriteIntentResult&gt; DecodeStrongWriteIntent(</a>
<a name="ln221">    const TransactionOperationContext&amp; txn_op_context, rocksdb::Iterator* intent_iter,</a>
<a name="ln222">    TransactionStatusCache* transaction_status_cache) {</a>
<a name="ln223">  DecodeStrongWriteIntentResult result;</a>
<a name="ln224">  auto decoded_intent_key = VERIFY_RESULT(DecodeIntentKey(intent_iter-&gt;key()));</a>
<a name="ln225">  result.intent_prefix = decoded_intent_key.intent_prefix;</a>
<a name="ln226">  result.intent_types = decoded_intent_key.intent_types;</a>
<a name="ln227">  if (result.intent_types.Test(IntentType::kStrongWrite)) {</a>
<a name="ln228">    result.intent_value = intent_iter-&gt;value();</a>
<a name="ln229">    auto txn_id = VERIFY_RESULT(DecodeTransactionIdFromIntentValue(&amp;result.intent_value));</a>
<a name="ln230">    result.same_transaction = txn_id == txn_op_context.transaction_id;</a>
<a name="ln231">    if (result.intent_value.size() &lt; 1 + sizeof(IntraTxnWriteId) ||</a>
<a name="ln232">        result.intent_value[0] != ValueTypeAsChar::kWriteId) {</a>
<a name="ln233">      return STATUS_FORMAT(</a>
<a name="ln234">          Corruption, &quot;Write id is missing in $0&quot;, intent_iter-&gt;value().ToDebugHexString());</a>
<a name="ln235">    }</a>
<a name="ln236">    result.intent_value.consume_byte();</a>
<a name="ln237">    IntraTxnWriteId in_txn_write_id = BigEndian::Load32(result.intent_value.data());</a>
<a name="ln238">    result.intent_value.remove_prefix(sizeof(IntraTxnWriteId));</a>
<a name="ln239">    if (result.intent_value.starts_with(ValueTypeAsChar::kRowLock)) {</a>
<a name="ln240">      result.value_time = DocHybridTime::kMin;</a>
<a name="ln241">    } else if (result.same_transaction) {</a>
<a name="ln242">      result.value_time = decoded_intent_key.doc_ht;</a>
<a name="ln243">    } else {</a>
<a name="ln244">      auto commit_ht = VERIFY_RESULT(transaction_status_cache-&gt;GetCommitTime(txn_id));</a>
<a name="ln245">      result.value_time = DocHybridTime(</a>
<a name="ln246">          commit_ht, commit_ht != HybridTime::kMin ? in_txn_write_id : 0);</a>
<a name="ln247">      VLOG(4) &lt;&lt; &quot;Transaction id: &quot; &lt;&lt; txn_id &lt;&lt; &quot;, value time: &quot; &lt;&lt; result.value_time</a>
<a name="ln248">              &lt;&lt; &quot;, value: &quot; &lt;&lt; result.intent_value.ToDebugHexString();</a>
<a name="ln249">    }</a>
<a name="ln250">  } else {</a>
<a name="ln251">    result.value_time = DocHybridTime::kMin;</a>
<a name="ln252">  }</a>
<a name="ln253">  return result;</a>
<a name="ln254">}</a>
<a name="ln255"> </a>
<a name="ln256">// Given that key is well-formed DocDB encoded key, checks if it is an intent key for the same key</a>
<a name="ln257">// as intent_prefix. If key is not well-formed DocDB encoded key, result could be true or false.</a>
<a name="ln258">bool IsIntentForTheSameKey(const Slice&amp; key, const Slice&amp; intent_prefix) {</a>
<a name="ln259">  return key.starts_with(intent_prefix) &amp;&amp;</a>
<a name="ln260">         key.size() &gt; intent_prefix.size() &amp;&amp;</a>
<a name="ln261">         IntentValueType(key[intent_prefix.size()]);</a>
<a name="ln262">}</a>
<a name="ln263"> </a>
<a name="ln264">std::string DebugDumpKeyToStr(const Slice &amp;key) {</a>
<a name="ln265">  return key.ToDebugString() + &quot; (&quot; + SubDocKey::DebugSliceToString(key) + &quot;)&quot;;</a>
<a name="ln266">}</a>
<a name="ln267"> </a>
<a name="ln268">std::string DebugDumpKeyToStr(const KeyBytes &amp;key) {</a>
<a name="ln269">  return DebugDumpKeyToStr(key.AsSlice());</a>
<a name="ln270">}</a>
<a name="ln271"> </a>
<a name="ln272">bool DebugHasHybridTime(const Slice&amp; subdoc_key_encoded) {</a>
<a name="ln273">  SubDocKey subdoc_key;</a>
<a name="ln274">  CHECK(subdoc_key.FullyDecodeFromKeyWithOptionalHybridTime(subdoc_key_encoded).ok());</a>
<a name="ln275">  return subdoc_key.has_hybrid_time();</a>
<a name="ln276">}</a>
<a name="ln277"> </a>
<a name="ln278">} // namespace</a>
<a name="ln279"> </a>
<a name="ln280">IntentAwareIterator::IntentAwareIterator(</a>
<a name="ln281">    const DocDB&amp; doc_db,</a>
<a name="ln282">    const rocksdb::ReadOptions&amp; read_opts,</a>
<a name="ln283">    CoarseTimePoint deadline,</a>
<a name="ln284">    const ReadHybridTime&amp; read_time,</a>
<a name="ln285">    const TransactionOperationContextOpt&amp; txn_op_context)</a>
<a name="ln286">    : read_time_(read_time),</a>
<a name="ln287">      encoded_read_time_local_limit_(</a>
<a name="ln288">          DocHybridTime(read_time_.local_limit, kMaxWriteId).EncodedInDocDbFormat()),</a>
<a name="ln289">      encoded_read_time_global_limit_(</a>
<a name="ln290">          DocHybridTime(read_time_.global_limit, kMaxWriteId).EncodedInDocDbFormat()),</a>
<a name="ln291">      txn_op_context_(txn_op_context),</a>
<a name="ln292">      transaction_status_cache_(</a>
<a name="ln293">          txn_op_context ? &amp;txn_op_context-&gt;txn_status_manager : nullptr, read_time, deadline) {</a>
<a name="ln294">  VLOG(4) &lt;&lt; &quot;IntentAwareIterator, read_time: &quot; &lt;&lt; read_time</a>
<a name="ln295">          &lt;&lt; &quot;, txn_op_context: &quot; &lt;&lt; txn_op_context_;</a>
<a name="ln296"> </a>
<a name="ln297">  if (txn_op_context) {</a>
<a name="ln298">    if (txn_op_context-&gt;txn_status_manager.MinRunningHybridTime() != HybridTime::kMax) {</a>
<a name="ln299">      intent_iter_ = docdb::CreateRocksDBIterator(doc_db.intents,</a>
<a name="ln300">                                                  doc_db.key_bounds,</a>
<a name="ln301">                                                  docdb::BloomFilterMode::DONT_USE_BLOOM_FILTER,</a>
<a name="ln302">                                                  boost::none,</a>
<a name="ln303">                                                  rocksdb::kDefaultQueryId,</a>
<a name="ln304">                                                  nullptr /* file_filter */,</a>
<a name="ln305">                                                  &amp;intent_upperbound_);</a>
<a name="ln306">    } else {</a>
<a name="ln307">      VLOG(4) &lt;&lt; &quot;No transactions running&quot;;</a>
<a name="ln308">    }</a>
<a name="ln309">  }</a>
<a name="ln310">  // WARNING: Is is important for regular DB iterator to be created after intents DB iterator,</a>
<a name="ln311">  // otherwise consistency could break, for example in following scenario:</a>
<a name="ln312">  // 1) Transaction is T1 committed with value v1 for k1, but not yet applied to regular DB.</a>
<a name="ln313">  // 2) Client reads v1 for k1.</a>
<a name="ln314">  // 3) Regular DB iterator is created on a regular DB snapshot containing no values for k1.</a>
<a name="ln315">  // 4) Transaction T1 is applied, k1-&gt;v1 is written into regular DB, intent k1-&gt;v1 is deleted.</a>
<a name="ln316">  // 5) Intents DB iterator is created on an intents DB snapshot containing no intents for k1.</a>
<a name="ln317">  // 6) Client reads no values for k1.</a>
<a name="ln318">  iter_ = BoundedRocksDbIterator(doc_db.regular, read_opts, doc_db.key_bounds);</a>
<a name="ln319">}</a>
<a name="ln320"> </a>
<a name="ln321">void IntentAwareIterator::Seek(const DocKey &amp;doc_key) {</a>
<a name="ln322">  Seek(doc_key.Encode());</a>
<a name="ln323">}</a>
<a name="ln324"> </a>
<a name="ln325">void IntentAwareIterator::Seek(const Slice&amp; key) {</a>
<a name="ln326">  VLOG(4) &lt;&lt; &quot;Seek(&quot; &lt;&lt; SubDocKey::DebugSliceToString(key) &lt;&lt; &quot;)&quot;;</a>
<a name="ln327">  DOCDB_DEBUG_SCOPE_LOG(</a>
<a name="ln328">      key.ToDebugString(),</a>
<a name="ln329">      std::bind(&amp;IntentAwareIterator::DebugDump, this));</a>
<a name="ln330">  if (!status_.ok()) {</a>
<a name="ln331">    return;</a>
<a name="ln332">  }</a>
<a name="ln333"> </a>
<a name="ln334">  ROCKSDB_SEEK(&amp;iter_, key);</a>
<a name="ln335">  skip_future_records_needed_ = true;</a>
<a name="ln336"> </a>
<a name="ln337">  if (intent_iter_.Initialized()) {</a>
<a name="ln338">    seek_intent_iter_needed_ = SeekIntentIterNeeded::kSeek;</a>
<a name="ln339">    GetIntentPrefixForKeyWithoutHt(key, &amp;seek_key_buffer_);</a>
<a name="ln340">    AppendStrongWrite(&amp;seek_key_buffer_);</a>
<a name="ln341">  }</a>
<a name="ln342">}</a>
<a name="ln343"> </a>
<a name="ln344">void IntentAwareIterator::SeekForward(const Slice&amp; key) {</a>
<a name="ln345">  KeyBytes key_bytes;</a>
<a name="ln346">  // Reserve space for key plus kMaxBytesPerEncodedHybridTime + 1 bytes for SeekForward() below to</a>
<a name="ln347">  // avoid extra realloc while appending the read time.</a>
<a name="ln348">  key_bytes.Reserve(key.size() + kMaxBytesPerEncodedHybridTime + 1);</a>
<a name="ln349">  key_bytes.AppendRawBytes(key);</a>
<a name="ln350">  SeekForward(&amp;key_bytes);</a>
<a name="ln351">}</a>
<a name="ln352"> </a>
<a name="ln353">void IntentAwareIterator::SeekForward(KeyBytes* key_bytes) {</a>
<a name="ln354">  VLOG(4) &lt;&lt; &quot;SeekForward(&quot; &lt;&lt; SubDocKey::DebugSliceToString(*key_bytes) &lt;&lt; &quot;)&quot;;</a>
<a name="ln355">  DOCDB_DEBUG_SCOPE_LOG(</a>
<a name="ln356">      SubDocKey::DebugSliceToString(*key_bytes),</a>
<a name="ln357">      std::bind(&amp;IntentAwareIterator::DebugDump, this));</a>
<a name="ln358">  if (!status_.ok()) {</a>
<a name="ln359">    return;</a>
<a name="ln360">  }</a>
<a name="ln361"> </a>
<a name="ln362">  const size_t key_size = key_bytes-&gt;size();</a>
<a name="ln363">  AppendEncodedDocHt(encoded_read_time_global_limit_, key_bytes);</a>
<a name="ln364">  SeekForwardRegular(*key_bytes);</a>
<a name="ln365">  key_bytes-&gt;Truncate(key_size);</a>
<a name="ln366">  if (intent_iter_.Initialized() &amp;&amp; status_.ok()) {</a>
<a name="ln367">    UpdatePlannedIntentSeekForward(</a>
<a name="ln368">        *key_bytes, StrongWriteSuffix(*key_bytes), /* use_suffix_for_prefix= */ false);</a>
<a name="ln369">  }</a>
<a name="ln370">}</a>
<a name="ln371"> </a>
<a name="ln372">void IntentAwareIterator::UpdatePlannedIntentSeekForward(const Slice&amp; key,</a>
<a name="ln373">                                                         const Slice&amp; suffix,</a>
<a name="ln374">                                                         bool use_suffix_for_prefix) {</a>
<a name="ln375">  if (seek_intent_iter_needed_ != SeekIntentIterNeeded::kNoNeed &amp;&amp;</a>
<a name="ln376">      seek_key_buffer_.AsSlice().GreaterOrEqual(key, suffix)) {</a>
<a name="ln377">    return;</a>
<a name="ln378">  }</a>
<a name="ln379">  seek_key_buffer_.Clear();</a>
<a name="ln380">  seek_key_buffer_.AppendRawBytes(key);</a>
<a name="ln381">  seek_key_buffer_.AppendRawBytes(suffix);</a>
<a name="ln382">  if (seek_intent_iter_needed_ == SeekIntentIterNeeded::kNoNeed) {</a>
<a name="ln383">    seek_intent_iter_needed_ = SeekIntentIterNeeded::kSeekForward;</a>
<a name="ln384">  }</a>
<a name="ln385">  seek_key_prefix_ = seek_key_buffer_.AsSlice();</a>
<a name="ln386">  if (!use_suffix_for_prefix) {</a>
<a name="ln387">    seek_key_prefix_.remove_suffix(suffix.size());</a>
<a name="ln388">  }</a>
<a name="ln389">}</a>
<a name="ln390"> </a>
<a name="ln391">// TODO: If TTL rows are ever supported on subkeys, this may need to change appropriately.</a>
<a name="ln392">// Otherwise, this function might seek past the TTL merge record, but not the original</a>
<a name="ln393">// record for the actual subkey.</a>
<a name="ln394">void IntentAwareIterator::SeekPastSubKey(const Slice&amp; key) {</a>
<a name="ln395">  VLOG(4) &lt;&lt; &quot;SeekPastSubKey(&quot; &lt;&lt; SubDocKey::DebugSliceToString(key) &lt;&lt; &quot;)&quot;;</a>
<a name="ln396">  if (!status_.ok()) {</a>
<a name="ln397">    return;</a>
<a name="ln398">  }</a>
<a name="ln399"> </a>
<a name="ln400">  docdb::SeekPastSubKey(key, &amp;iter_);</a>
<a name="ln401">  skip_future_records_needed_ = true;</a>
<a name="ln402">  if (intent_iter_.Initialized() &amp;&amp; status_.ok()) {</a>
<a name="ln403">    // Skip all intents for subdoc_key.</a>
<a name="ln404">    char kSuffix = ValueTypeAsChar::kGreaterThanIntentType;</a>
<a name="ln405">    UpdatePlannedIntentSeekForward(key, Slice(&amp;kSuffix, 1));</a>
<a name="ln406">  }</a>
<a name="ln407">}</a>
<a name="ln408"> </a>
<a name="ln409">void IntentAwareIterator::SeekOutOfSubDoc(KeyBytes* key_bytes) {</a>
<a name="ln410">  VLOG(4) &lt;&lt; &quot;SeekOutOfSubDoc(&quot; &lt;&lt; SubDocKey::DebugSliceToString(*key_bytes) &lt;&lt; &quot;)&quot;;</a>
<a name="ln411">  if (!status_.ok()) {</a>
<a name="ln412">    return;</a>
<a name="ln413">  }</a>
<a name="ln414"> </a>
<a name="ln415">  docdb::SeekOutOfSubKey(key_bytes, &amp;iter_);</a>
<a name="ln416">  skip_future_records_needed_ = true;</a>
<a name="ln417">  if (intent_iter_.Initialized() &amp;&amp; status_.ok()) {</a>
<a name="ln418">    // See comment for SubDocKey::AdvanceOutOfSubDoc.</a>
<a name="ln419">    const char kSuffix = ValueTypeAsChar::kMaxByte;</a>
<a name="ln420">    UpdatePlannedIntentSeekForward(*key_bytes, Slice(&amp;kSuffix, 1));</a>
<a name="ln421">  }</a>
<a name="ln422">}</a>
<a name="ln423"> </a>
<a name="ln424">void IntentAwareIterator::SeekOutOfSubDoc(const Slice&amp; key) {</a>
<a name="ln425">  KeyBytes key_bytes;</a>
<a name="ln426">  // Reserve space for key + 1 byte for docdb::SeekOutOfSubKey() above to avoid extra realloc while</a>
<a name="ln427">  // appending kMaxByte.</a>
<a name="ln428">  key_bytes.Reserve(key.size() + 1);</a>
<a name="ln429">  key_bytes.AppendRawBytes(key);</a>
<a name="ln430">  SeekOutOfSubDoc(&amp;key_bytes);</a>
<a name="ln431">}</a>
<a name="ln432"> </a>
<a name="ln433">bool IntentAwareIterator::HasCurrentEntry() {</a>
<a name="ln434">  return iter_valid_ || resolved_intent_state_ == ResolvedIntentState::kValid;</a>
<a name="ln435">}</a>
<a name="ln436"> </a>
<a name="ln437">void IntentAwareIterator::SeekToLastDocKey() {</a>
<a name="ln438">  iter_.SeekToLast();</a>
<a name="ln439">  SkipFutureRecords(Direction::kBackward);</a>
<a name="ln440">  if (intent_iter_.Initialized()) {</a>
<a name="ln441">    ResetIntentUpperbound();</a>
<a name="ln442">    intent_iter_.SeekToLast();</a>
<a name="ln443">    SeekToSuitableIntent&lt;Direction::kBackward&gt;();</a>
<a name="ln444">    seek_intent_iter_needed_ = SeekIntentIterNeeded::kNoNeed;</a>
<a name="ln445">    skip_future_intents_needed_ = false;</a>
<a name="ln446">  }</a>
<a name="ln447">  if (HasCurrentEntry()) {</a>
<a name="ln448">    SeekToLatestDocKeyInternal();</a>
<a name="ln449">  }</a>
<a name="ln450">}</a>
<a name="ln451"> </a>
<a name="ln452">template &lt;class T&gt;</a>
<a name="ln453">void Assign(const T&amp; value, T* out) {</a>
<a name="ln454">  if (out) {</a>
<a name="ln455">    *out = value;</a>
<a name="ln456">  }</a>
<a name="ln457">}</a>
<a name="ln458"> </a>
<a name="ln459">// If we reach a different key, stop seeking.</a>
<a name="ln460">Status IntentAwareIterator::NextFullValue(</a>
<a name="ln461">    DocHybridTime* latest_record_ht,</a>
<a name="ln462">    Slice* result_value,</a>
<a name="ln463">    Slice* final_key) {</a>
<a name="ln464">  if (!latest_record_ht || !result_value)</a>
<a name="ln465">    return STATUS(Corruption, &quot;The arguments latest_record_ht and &quot;</a>
<a name="ln466">                              &quot;result_value cannot be null pointers.&quot;);</a>
<a name="ln467">  RETURN_NOT_OK(status_);</a>
<a name="ln468">  Slice v;</a>
<a name="ln469">  if (!valid() || !IsMergeRecord(v = value())) {</a>
<a name="ln470">    auto key_data = VERIFY_RESULT(FetchKey());</a>
<a name="ln471">    Assign(key_data.key, final_key);</a>
<a name="ln472">    Assign(key_data.write_time, latest_record_ht);</a>
<a name="ln473">    *result_value = v;</a>
<a name="ln474">    return status_;</a>
<a name="ln475">  }</a>
<a name="ln476"> </a>
<a name="ln477">  *latest_record_ht = DocHybridTime::kMin;</a>
<a name="ln478">  const auto key_data = VERIFY_RESULT(FetchKey());</a>
<a name="ln479">  auto key = key_data.key;</a>
<a name="ln480">  const size_t key_size = key.size();</a>
<a name="ln481">  bool found_record = false;</a>
<a name="ln482"> </a>
<a name="ln483">  // The condition specifies that the first type is the flags type,</a>
<a name="ln484">  // And that the key is still the same.</a>
<a name="ln485">  while ((found_record = iter_.Valid() &amp;&amp;</a>
<a name="ln486">          (key = iter_.key()).starts_with(key_data.key) &amp;&amp;</a>
<a name="ln487">          (ValueType)(key[key_size]) == ValueType::kHybridTime) &amp;&amp;</a>
<a name="ln488">         IsMergeRecord(v = iter_.value())) {</a>
<a name="ln489">    iter_.Next();</a>
<a name="ln490">  }</a>
<a name="ln491"> </a>
<a name="ln492">  if (found_record) {</a>
<a name="ln493">    *result_value = v;</a>
<a name="ln494">    *latest_record_ht = VERIFY_RESULT(DocHybridTime::DecodeFromEnd(&amp;key));</a>
<a name="ln495">    Assign(key, final_key);</a>
<a name="ln496">  }</a>
<a name="ln497"> </a>
<a name="ln498">  found_record = false;</a>
<a name="ln499">  if (intent_iter_.Initialized()) {</a>
<a name="ln500">    while ((found_record = IsIntentForTheSameKey(intent_iter_.key(), key_data.key)) &amp;&amp;</a>
<a name="ln501">           IsMergeRecord(v = intent_iter_.value())) {</a>
<a name="ln502">      intent_iter_.Next();</a>
<a name="ln503">    }</a>
<a name="ln504">    DocHybridTime doc_ht;</a>
<a name="ln505">    if (found_record &amp;&amp; !(key = intent_iter_.key()).empty() &amp;&amp;</a>
<a name="ln506">        (doc_ht = VERIFY_RESULT(DocHybridTime::DecodeFromEnd(&amp;key))) &gt;= *latest_record_ht) {</a>
<a name="ln507">      *latest_record_ht = doc_ht;</a>
<a name="ln508">      *result_value = v;</a>
<a name="ln509">      Assign(key, final_key);</a>
<a name="ln510">    }</a>
<a name="ln511">  }</a>
<a name="ln512"> </a>
<a name="ln513">  if (*latest_record_ht == DocHybridTime::kMin) {</a>
<a name="ln514">    iter_valid_ = false;</a>
<a name="ln515">  }</a>
<a name="ln516">  return status_;</a>
<a name="ln517">}</a>
<a name="ln518"> </a>
<a name="ln519">bool IntentAwareIterator::PreparePrev(const Slice&amp; key) {</a>
<a name="ln520">  VLOG(4) &lt;&lt; __func__ &lt;&lt; &quot;(&quot; &lt;&lt; SubDocKey::DebugSliceToString(key) &lt;&lt; &quot;)&quot;;</a>
<a name="ln521"> </a>
<a name="ln522">  ROCKSDB_SEEK(&amp;iter_, key);</a>
<a name="ln523"> </a>
<a name="ln524">  if (iter_.Valid()) {</a>
<a name="ln525">    iter_.Prev();</a>
<a name="ln526">  } else {</a>
<a name="ln527">    iter_.SeekToLast();</a>
<a name="ln528">  }</a>
<a name="ln529">  SkipFutureRecords(Direction::kBackward);</a>
<a name="ln530"> </a>
<a name="ln531">  if (intent_iter_.Initialized()) {</a>
<a name="ln532">    ResetIntentUpperbound();</a>
<a name="ln533">    ROCKSDB_SEEK(&amp;intent_iter_, GetIntentPrefixForKeyWithoutHt(key));</a>
<a name="ln534">    if (intent_iter_.Valid()) {</a>
<a name="ln535">      intent_iter_.Prev();</a>
<a name="ln536">    } else {</a>
<a name="ln537">      intent_iter_.SeekToLast();</a>
<a name="ln538">    }</a>
<a name="ln539">    SeekToSuitableIntent&lt;Direction::kBackward&gt;();</a>
<a name="ln540">    seek_intent_iter_needed_ = SeekIntentIterNeeded::kNoNeed;</a>
<a name="ln541">    skip_future_intents_needed_ = false;</a>
<a name="ln542">  }</a>
<a name="ln543"> </a>
<a name="ln544">  return HasCurrentEntry();</a>
<a name="ln545">}</a>
<a name="ln546"> </a>
<a name="ln547">void IntentAwareIterator::PrevSubDocKey(const KeyBytes&amp; key_bytes) {</a>
<a name="ln548">  if (PreparePrev(key_bytes)) {</a>
<a name="ln549">    SeekToLatestSubDocKeyInternal();</a>
<a name="ln550">  }</a>
<a name="ln551">}</a>
<a name="ln552"> </a>
<a name="ln553">void IntentAwareIterator::PrevDocKey(const DocKey&amp; doc_key) {</a>
<a name="ln554">  PrevDocKey(doc_key.Encode().AsSlice());</a>
<a name="ln555">}</a>
<a name="ln556"> </a>
<a name="ln557">void IntentAwareIterator::PrevDocKey(const Slice&amp; encoded_doc_key) {</a>
<a name="ln558">  if (PreparePrev(encoded_doc_key)) {</a>
<a name="ln559">    SeekToLatestDocKeyInternal();</a>
<a name="ln560">  }</a>
<a name="ln561">}</a>
<a name="ln562"> </a>
<a name="ln563">Slice IntentAwareIterator::LatestSubDocKey() {</a>
<a name="ln564">  DCHECK(HasCurrentEntry())</a>
<a name="ln565">      &lt;&lt; &quot;Expected iter_valid(&quot; &lt;&lt; iter_valid_ &lt;&lt; &quot;) || resolved_intent_state_(&quot;</a>
<a name="ln566">      &lt;&lt; resolved_intent_state_ &lt;&lt; &quot;) == ResolvedIntentState::kValid&quot;;</a>
<a name="ln567">  return IsEntryRegular(/* descending */ true) ? iter_.key()</a>
<a name="ln568">                                               : resolved_intent_key_prefix_.AsSlice();</a>
<a name="ln569">}</a>
<a name="ln570"> </a>
<a name="ln571">void IntentAwareIterator::SeekToLatestSubDocKeyInternal() {</a>
<a name="ln572">  auto subdockey_slice = LatestSubDocKey();</a>
<a name="ln573"> </a>
<a name="ln574">  // Strip the hybrid time and seek the slice.</a>
<a name="ln575">  auto doc_ht = DocHybridTime::DecodeFromEnd(&amp;subdockey_slice);</a>
<a name="ln576">  if (!doc_ht.ok()) {</a>
<a name="ln577">    status_ = doc_ht.status();</a>
<a name="ln578">    return;</a>
<a name="ln579">  }</a>
<a name="ln580">  subdockey_slice.remove_suffix(1);</a>
<a name="ln581">  Seek(subdockey_slice);</a>
<a name="ln582">}</a>
<a name="ln583"> </a>
<a name="ln584">void IntentAwareIterator::SeekToLatestDocKeyInternal() {</a>
<a name="ln585">  auto subdockey_slice = LatestSubDocKey();</a>
<a name="ln586"> </a>
<a name="ln587">  // Seek to the first key for row containing found subdockey.</a>
<a name="ln588">  auto dockey_size = DocKey::EncodedSize(subdockey_slice, DocKeyPart::kWholeDocKey);</a>
<a name="ln589">  if (!dockey_size.ok()) {</a>
<a name="ln590">    status_ = dockey_size.status();</a>
<a name="ln591">    return;</a>
<a name="ln592">  }</a>
<a name="ln593">  Seek(Slice(subdockey_slice.data(), *dockey_size));</a>
<a name="ln594">}</a>
<a name="ln595"> </a>
<a name="ln596">void IntentAwareIterator::SeekIntentIterIfNeeded() {</a>
<a name="ln597">  if (seek_intent_iter_needed_ == SeekIntentIterNeeded::kNoNeed || !status_.ok()) {</a>
<a name="ln598">    return;</a>
<a name="ln599">  }</a>
<a name="ln600">  status_ = SetIntentUpperbound();</a>
<a name="ln601">  if (!status_.ok()) {</a>
<a name="ln602">    return;</a>
<a name="ln603">  }</a>
<a name="ln604">  switch (seek_intent_iter_needed_) {</a>
<a name="ln605">    case SeekIntentIterNeeded::kNoNeed:</a>
<a name="ln606">      break;</a>
<a name="ln607">    case SeekIntentIterNeeded::kSeek:</a>
<a name="ln608">      VLOG(4) &lt;&lt; __func__ &lt;&lt; &quot;, seek: &quot; &lt;&lt; SubDocKey::DebugSliceToString(seek_key_buffer_);</a>
<a name="ln609">      ROCKSDB_SEEK(&amp;intent_iter_, seek_key_buffer_);</a>
<a name="ln610">      SeekToSuitableIntent&lt;Direction::kForward&gt;();</a>
<a name="ln611">      seek_intent_iter_needed_ = SeekIntentIterNeeded::kNoNeed;</a>
<a name="ln612">      return;</a>
<a name="ln613">    case SeekIntentIterNeeded::kSeekForward:</a>
<a name="ln614">      SeekForwardToSuitableIntent();</a>
<a name="ln615">      seek_intent_iter_needed_ = SeekIntentIterNeeded::kNoNeed;</a>
<a name="ln616">      return;</a>
<a name="ln617">  }</a>
<a name="ln618">  FATAL_INVALID_ENUM_VALUE(SeekIntentIterNeeded, seek_intent_iter_needed_);</a>
<a name="ln619">}</a>
<a name="ln620"> </a>
<a name="ln621">bool IntentAwareIterator::valid() {</a>
<a name="ln622">  if (skip_future_records_needed_) {</a>
<a name="ln623">    SkipFutureRecords(Direction::kForward);</a>
<a name="ln624">  }</a>
<a name="ln625">  SeekIntentIterIfNeeded();</a>
<a name="ln626">  if (skip_future_intents_needed_) {</a>
<a name="ln627">    SkipFutureIntents();</a>
<a name="ln628">  }</a>
<a name="ln629">  return !status_.ok() || HasCurrentEntry();</a>
<a name="ln630">}</a>
<a name="ln631"> </a>
<a name="ln632">bool IntentAwareIterator::IsEntryRegular(bool descending) {</a>
<a name="ln633">  if (PREDICT_FALSE(!iter_valid_)) {</a>
<a name="ln634">    return false;</a>
<a name="ln635">  }</a>
<a name="ln636">  if (resolved_intent_state_ == ResolvedIntentState::kValid) {</a>
<a name="ln637">    return (iter_.key().compare(resolved_intent_sub_doc_key_encoded_) &lt; 0) != descending;</a>
<a name="ln638">  }</a>
<a name="ln639">  return true;</a>
<a name="ln640">}</a>
<a name="ln641"> </a>
<a name="ln642">Result&lt;FetchKeyResult&gt; IntentAwareIterator::FetchKey() {</a>
<a name="ln643">  RETURN_NOT_OK(status_);</a>
<a name="ln644">  FetchKeyResult result;</a>
<a name="ln645">  if (IsEntryRegular()) {</a>
<a name="ln646">    result.key = iter_.key();</a>
<a name="ln647">    result.write_time = VERIFY_RESULT(DocHybridTime::DecodeFromEnd(&amp;result.key));</a>
<a name="ln648">    DCHECK(result.key.ends_with(ValueTypeAsChar::kHybridTime)) &lt;&lt; result.key.ToDebugString();</a>
<a name="ln649">    result.key.remove_suffix(1);</a>
<a name="ln650">    result.same_transaction = false;</a>
<a name="ln651">    max_seen_ht_.MakeAtLeast(result.write_time.hybrid_time());</a>
<a name="ln652">  } else {</a>
<a name="ln653">    DCHECK_EQ(ResolvedIntentState::kValid, resolved_intent_state_);</a>
<a name="ln654">    result.key = resolved_intent_key_prefix_.AsSlice();</a>
<a name="ln655">    result.write_time = GetIntentDocHybridTime();</a>
<a name="ln656">    result.same_transaction = ResolvedIntentFromSameTransaction();</a>
<a name="ln657">    max_seen_ht_.MakeAtLeast(resolved_intent_txn_dht_.hybrid_time());</a>
<a name="ln658">  }</a>
<a name="ln659">  VLOG(4) &lt;&lt; &quot;Fetched key &quot; &lt;&lt; SubDocKey::DebugSliceToString(result.key)</a>
<a name="ln660">          &lt;&lt; &quot;, with time: &quot; &lt;&lt; result.write_time</a>
<a name="ln661">          &lt;&lt; &quot;, while read bounds are: &quot; &lt;&lt; read_time_;</a>
<a name="ln662">  return result;</a>
<a name="ln663">}</a>
<a name="ln664"> </a>
<a name="ln665">Slice IntentAwareIterator::value() {</a>
<a name="ln666">  if (IsEntryRegular()) {</a>
<a name="ln667">    VLOG(4) &lt;&lt; &quot;IntentAwareIterator::value() returning iter_.value(): &quot;</a>
<a name="ln668">            &lt;&lt; iter_.value().ToDebugHexString() &lt;&lt; &quot; or &quot; &lt;&lt; FormatSliceAsStr(iter_.value());</a>
<a name="ln669">    return iter_.value();</a>
<a name="ln670">  } else {</a>
<a name="ln671">    DCHECK_EQ(ResolvedIntentState::kValid, resolved_intent_state_);</a>
<a name="ln672">    VLOG(4) &lt;&lt; &quot;IntentAwareIterator::value() returning resolved_intent_value_: &quot;</a>
<a name="ln673">            &lt;&lt; resolved_intent_value_.AsSlice().ToDebugHexString();</a>
<a name="ln674">    return resolved_intent_value_;</a>
<a name="ln675">  }</a>
<a name="ln676">}</a>
<a name="ln677"> </a>
<a name="ln678">void IntentAwareIterator::SeekForwardRegular(const Slice&amp; slice) {</a>
<a name="ln679">  VLOG(4) &lt;&lt; &quot;SeekForwardRegular(&quot; &lt;&lt; SubDocKey::DebugSliceToString(slice) &lt;&lt; &quot;)&quot;;</a>
<a name="ln680">  docdb::SeekForward(slice, &amp;iter_);</a>
<a name="ln681">  skip_future_records_needed_ = true;</a>
<a name="ln682">}</a>
<a name="ln683"> </a>
<a name="ln684">bool IntentAwareIterator::SatisfyBounds(const Slice&amp; slice) {</a>
<a name="ln685">  return upperbound_.empty() || slice.compare(upperbound_) &lt;= 0;</a>
<a name="ln686">}</a>
<a name="ln687"> </a>
<a name="ln688">void IntentAwareIterator::ProcessIntent() {</a>
<a name="ln689">  auto decode_result = DecodeStrongWriteIntent(</a>
<a name="ln690">      txn_op_context_.get(), &amp;intent_iter_, &amp;transaction_status_cache_);</a>
<a name="ln691">  if (!decode_result.ok()) {</a>
<a name="ln692">    status_ = decode_result.status();</a>
<a name="ln693">    return;</a>
<a name="ln694">  }</a>
<a name="ln695">  VLOG(4) &lt;&lt; &quot;Intent decode: &quot; &lt;&lt; DebugIntentKeyToString(intent_iter_.key())</a>
<a name="ln696">          &lt;&lt; &quot; =&gt; &quot; &lt;&lt; intent_iter_.value().ToDebugHexString() &lt;&lt; &quot;, result: &quot; &lt;&lt; *decode_result;</a>
<a name="ln697">  DOCDB_DEBUG_LOG(</a>
<a name="ln698">      &quot;resolved_intent_txn_dht_: $0 value_time: $1 read_time: $2&quot;,</a>
<a name="ln699">      resolved_intent_txn_dht_.ToString(),</a>
<a name="ln700">      decode_result-&gt;value_time.ToString(),</a>
<a name="ln701">      read_time_.ToString());</a>
<a name="ln702">  auto resolved_intent_time = decode_result-&gt;same_transaction ? intent_dht_from_same_txn_</a>
<a name="ln703">                                                              : resolved_intent_txn_dht_;</a>
<a name="ln704">  // If we already resolved intent that is newer that this one, we should ignore current</a>
<a name="ln705">  // intent because we are interested in the most recent intent only.</a>
<a name="ln706">  if (decode_result-&gt;value_time &lt;= resolved_intent_time) {</a>
<a name="ln707">    return;</a>
<a name="ln708">  }</a>
<a name="ln709"> </a>
<a name="ln710">  // Ignore intent past read limit.</a>
<a name="ln711">  auto max_allowed_time = decode_result-&gt;same_transaction</a>
<a name="ln712">      ? read_time_.in_txn_limit : read_time_.global_limit;</a>
<a name="ln713">  if (decode_result-&gt;value_time.hybrid_time() &gt; max_allowed_time) {</a>
<a name="ln714">    return;</a>
<a name="ln715">  }</a>
<a name="ln716"> </a>
<a name="ln717">  if (resolved_intent_state_ == ResolvedIntentState::kNoIntent) {</a>
<a name="ln718">    resolved_intent_key_prefix_.Reset(decode_result-&gt;intent_prefix);</a>
<a name="ln719">    auto prefix = prefix_stack_.empty() ? Slice() : prefix_stack_.back();</a>
<a name="ln720">    if (!decode_result-&gt;intent_prefix.starts_with(prefix)) {</a>
<a name="ln721">      resolved_intent_state_ = ResolvedIntentState::kInvalidPrefix;</a>
<a name="ln722">    } else if (!SatisfyBounds(decode_result-&gt;intent_prefix)) {</a>
<a name="ln723">      resolved_intent_state_ = ResolvedIntentState::kNoIntent;</a>
<a name="ln724">    } else {</a>
<a name="ln725">      resolved_intent_state_ = ResolvedIntentState::kValid;</a>
<a name="ln726">    }</a>
<a name="ln727">  }</a>
<a name="ln728">  if (decode_result-&gt;same_transaction) {</a>
<a name="ln729">    intent_dht_from_same_txn_ = decode_result-&gt;value_time;</a>
<a name="ln730">    // We set resolved_intent_txn_dht_ to maximum possible time (time higher than read_time_.read</a>
<a name="ln731">    // will cause read restart or will be ignored if higher than read_time_.global_limit) in</a>
<a name="ln732">    // order to ignore intents/values from other transactions. But we save origin intent time into</a>
<a name="ln733">    // intent_dht_from_same_txn_, so we can compare time of intents for the same key from the same</a>
<a name="ln734">    // transaction and select the latest one.</a>
<a name="ln735">    resolved_intent_txn_dht_ = DocHybridTime(read_time_.read, kMaxWriteId);</a>
<a name="ln736">  } else {</a>
<a name="ln737">    resolved_intent_txn_dht_ = decode_result-&gt;value_time;</a>
<a name="ln738">  }</a>
<a name="ln739">  resolved_intent_value_.Reset(decode_result-&gt;intent_value);</a>
<a name="ln740">}</a>
<a name="ln741"> </a>
<a name="ln742">void IntentAwareIterator::UpdateResolvedIntentSubDocKeyEncoded() {</a>
<a name="ln743">  resolved_intent_sub_doc_key_encoded_.Reset(resolved_intent_key_prefix_.AsSlice());</a>
<a name="ln744">  resolved_intent_sub_doc_key_encoded_.AppendValueType(ValueType::kHybridTime);</a>
<a name="ln745">  resolved_intent_sub_doc_key_encoded_.AppendHybridTime(resolved_intent_txn_dht_);</a>
<a name="ln746">  VLOG(4) &lt;&lt; &quot;Resolved intent SubDocKey: &quot;</a>
<a name="ln747">          &lt;&lt; DebugDumpKeyToStr(resolved_intent_sub_doc_key_encoded_);</a>
<a name="ln748">}</a>
<a name="ln749"> </a>
<a name="ln750">void IntentAwareIterator::SeekForwardToSuitableIntent() {</a>
<a name="ln751">  VLOG(4) &lt;&lt; __func__ &lt;&lt; &quot;(&quot; &lt;&lt; DebugDumpKeyToStr(seek_key_buffer_) &lt;&lt; &quot;)&quot;;</a>
<a name="ln752"> </a>
<a name="ln753">  DOCDB_DEBUG_SCOPE_LOG(seek_key_buffer_.ToString(),</a>
<a name="ln754">                        std::bind(&amp;IntentAwareIterator::DebugDump, this));</a>
<a name="ln755">  if (resolved_intent_state_ != ResolvedIntentState::kNoIntent &amp;&amp;</a>
<a name="ln756">      resolved_intent_key_prefix_.CompareTo(seek_key_prefix_) &gt;= 0) {</a>
<a name="ln757">    VLOG(4) &lt;&lt; __func__ &lt;&lt; &quot;, has suitable &quot; &lt;&lt; AsString(resolved_intent_state_) &lt;&lt; &quot; intent: &quot;</a>
<a name="ln758">            &lt;&lt; DebugDumpKeyToStr(resolved_intent_key_prefix_);</a>
<a name="ln759">    return;</a>
<a name="ln760">  }</a>
<a name="ln761"> </a>
<a name="ln762">  if (VLOG_IS_ON(4)) {</a>
<a name="ln763">    if (resolved_intent_state_ != ResolvedIntentState::kNoIntent) {</a>
<a name="ln764">      VLOG(4) &lt;&lt; __func__ &lt;&lt; &quot;, has NOT suitable &quot; &lt;&lt; AsString(resolved_intent_state_)</a>
<a name="ln765">              &lt;&lt; &quot; intent: &quot; &lt;&lt; DebugDumpKeyToStr(resolved_intent_key_prefix_);</a>
<a name="ln766">    }</a>
<a name="ln767"> </a>
<a name="ln768">    if (intent_iter_.Valid()) {</a>
<a name="ln769">      VLOG(4) &lt;&lt; __func__ &lt;&lt; &quot;, current position: &quot; &lt;&lt; DebugDumpKeyToStr(intent_iter_.key());</a>
<a name="ln770">    } else {</a>
<a name="ln771">      VLOG(4) &lt;&lt; __func__ &lt;&lt; &quot;, iterator invalid&quot;;</a>
<a name="ln772">    }</a>
<a name="ln773">  }</a>
<a name="ln774"> </a>
<a name="ln775">  docdb::SeekForward(seek_key_buffer_.AsSlice(), &amp;intent_iter_);</a>
<a name="ln776">  SeekToSuitableIntent&lt;Direction::kForward&gt;();</a>
<a name="ln777">}</a>
<a name="ln778"> </a>
<a name="ln779">template&lt;Direction direction&gt;</a>
<a name="ln780">void IntentAwareIterator::SeekToSuitableIntent() {</a>
<a name="ln781">  DOCDB_DEBUG_SCOPE_LOG(/* msg */ &quot;&quot;, std::bind(&amp;IntentAwareIterator::DebugDump, this));</a>
<a name="ln782">  resolved_intent_state_ = ResolvedIntentState::kNoIntent;</a>
<a name="ln783">  resolved_intent_txn_dht_ = DocHybridTime::kMin;</a>
<a name="ln784">  intent_dht_from_same_txn_ = DocHybridTime::kMin;</a>
<a name="ln785">  auto prefix = prefix_stack_.empty() ? Slice() : prefix_stack_.back();</a>
<a name="ln786"> </a>
<a name="ln787">  // Find latest suitable intent for the first SubDocKey having suitable intents.</a>
<a name="ln788">  while (intent_iter_.Valid()) {</a>
<a name="ln789">    auto intent_key = intent_iter_.key();</a>
<a name="ln790">    if (intent_key[0] == ValueTypeAsChar::kTransactionId) {</a>
<a name="ln791">      // If the intent iterator ever enters the transaction metadata and reverse index region, skip</a>
<a name="ln792">      // past it.</a>
<a name="ln793">      switch (direction) {</a>
<a name="ln794">        case Direction::kForward: {</a>
<a name="ln795">          static const std::array&lt;char, 1&gt; kAfterTransactionId{ValueTypeAsChar::kTransactionId + 1};</a>
<a name="ln796">          static const Slice kAfterTxnRegion(kAfterTransactionId);</a>
<a name="ln797">          intent_iter_.Seek(kAfterTxnRegion);</a>
<a name="ln798">          break;</a>
<a name="ln799">        }</a>
<a name="ln800">        case Direction::kBackward:</a>
<a name="ln801">          intent_upperbound_keybytes_.Clear();</a>
<a name="ln802">          intent_upperbound_keybytes_.AppendValueType(ValueType::kTransactionId);</a>
<a name="ln803">          intent_upperbound_ = intent_upperbound_keybytes_.AsSlice();</a>
<a name="ln804">          intent_iter_.SeekToLast();</a>
<a name="ln805">          break;</a>
<a name="ln806">      }</a>
<a name="ln807">      continue;</a>
<a name="ln808">    }</a>
<a name="ln809">    VLOG(4) &lt;&lt; &quot;Intent found: &quot; &lt;&lt; DebugIntentKeyToString(intent_key)</a>
<a name="ln810">            &lt;&lt; &quot;, resolved state: &quot; &lt;&lt; yb::ToString(resolved_intent_state_);</a>
<a name="ln811">    if (resolved_intent_state_ != ResolvedIntentState::kNoIntent &amp;&amp;</a>
<a name="ln812">        // Only scan intents for the first SubDocKey having suitable intents.</a>
<a name="ln813">        !IsIntentForTheSameKey(intent_key, resolved_intent_key_prefix_)) {</a>
<a name="ln814">      break;</a>
<a name="ln815">    }</a>
<a name="ln816">    if (!intent_key.starts_with(prefix) || !SatisfyBounds(intent_key)) {</a>
<a name="ln817">      break;</a>
<a name="ln818">    }</a>
<a name="ln819">    ProcessIntent();</a>
<a name="ln820">    if (!status_.ok()) {</a>
<a name="ln821">      return;</a>
<a name="ln822">    }</a>
<a name="ln823">    switch (direction) {</a>
<a name="ln824">      case Direction::kForward:</a>
<a name="ln825">        intent_iter_.Next();</a>
<a name="ln826">        break;</a>
<a name="ln827">      case Direction::kBackward:</a>
<a name="ln828">        intent_iter_.Prev();</a>
<a name="ln829">        break;</a>
<a name="ln830">    }</a>
<a name="ln831">  }</a>
<a name="ln832">  if (resolved_intent_state_ != ResolvedIntentState::kNoIntent) {</a>
<a name="ln833">    UpdateResolvedIntentSubDocKeyEncoded();</a>
<a name="ln834">  }</a>
<a name="ln835">}</a>
<a name="ln836"> </a>
<a name="ln837">void IntentAwareIterator::DebugDump() {</a>
<a name="ln838">  bool is_valid = valid();</a>
<a name="ln839">  LOG(INFO) &lt;&lt; &quot;&gt;&gt; IntentAwareIterator dump&quot;;</a>
<a name="ln840">  LOG(INFO) &lt;&lt; &quot;iter_.Valid(): &quot; &lt;&lt; iter_.Valid();</a>
<a name="ln841">  if (iter_.Valid()) {</a>
<a name="ln842">    LOG(INFO) &lt;&lt; &quot;iter_.key(): &quot; &lt;&lt; DebugDumpKeyToStr(iter_.key());</a>
<a name="ln843">  }</a>
<a name="ln844">  if (intent_iter_.Initialized()) {</a>
<a name="ln845">    LOG(INFO) &lt;&lt; &quot;intent_iter_.Valid(): &quot; &lt;&lt; intent_iter_.Valid();</a>
<a name="ln846">    if (intent_iter_.Valid()) {</a>
<a name="ln847">      LOG(INFO) &lt;&lt; &quot;intent_iter_.key(): &quot; &lt;&lt; intent_iter_.key().ToDebugHexString();</a>
<a name="ln848">    }</a>
<a name="ln849">  }</a>
<a name="ln850">  LOG(INFO) &lt;&lt; &quot;resolved_intent_state_: &quot; &lt;&lt; yb::ToString(resolved_intent_state_);</a>
<a name="ln851">  if (resolved_intent_state_ != ResolvedIntentState::kNoIntent) {</a>
<a name="ln852">    LOG(INFO) &lt;&lt; &quot;resolved_intent_sub_doc_key_encoded_: &quot;</a>
<a name="ln853">              &lt;&lt; DebugDumpKeyToStr(resolved_intent_sub_doc_key_encoded_);</a>
<a name="ln854">  }</a>
<a name="ln855">  LOG(INFO) &lt;&lt; &quot;valid(): &quot; &lt;&lt; is_valid;</a>
<a name="ln856">  if (valid()) {</a>
<a name="ln857">    auto key_data = FetchKey();</a>
<a name="ln858">    if (key_data.ok()) {</a>
<a name="ln859">      LOG(INFO) &lt;&lt; &quot;key(): &quot; &lt;&lt; DebugDumpKeyToStr(key_data-&gt;key)</a>
<a name="ln860">                &lt;&lt; &quot;, doc_ht: &quot; &lt;&lt; key_data-&gt;write_time;</a>
<a name="ln861">    } else {</a>
<a name="ln862">      LOG(INFO) &lt;&lt; &quot;key(): fetch failed: &quot; &lt;&lt; key_data.status();</a>
<a name="ln863">    }</a>
<a name="ln864">  }</a>
<a name="ln865">  LOG(INFO) &lt;&lt; &quot;&lt;&lt; IntentAwareIterator dump&quot;;</a>
<a name="ln866">}</a>
<a name="ln867"> </a>
<a name="ln868">Result&lt;DocHybridTime&gt;</a>
<a name="ln869">IntentAwareIterator::FindMatchingIntentRecordDocHybridTime(const Slice&amp; key_without_ht) {</a>
<a name="ln870">  VLOG(4) &lt;&lt; __func__ &lt;&lt; &quot;(&quot; &lt;&lt; SubDocKey::DebugSliceToString(key_without_ht) &lt;&lt; &quot;)&quot;;</a>
<a name="ln871">  GetIntentPrefixForKeyWithoutHt(key_without_ht, &amp;seek_key_buffer_);</a>
<a name="ln872">  seek_key_prefix_ = seek_key_buffer_.AsSlice();</a>
<a name="ln873"> </a>
<a name="ln874">  SeekForwardToSuitableIntent();</a>
<a name="ln875">  RETURN_NOT_OK(status_);</a>
<a name="ln876"> </a>
<a name="ln877">  if (resolved_intent_state_ != ResolvedIntentState::kValid) {</a>
<a name="ln878">    return DocHybridTime::kInvalid;</a>
<a name="ln879">  }</a>
<a name="ln880"> </a>
<a name="ln881">  if (resolved_intent_key_prefix_.CompareTo(seek_key_buffer_) == 0) {</a>
<a name="ln882">    max_seen_ht_.MakeAtLeast(resolved_intent_txn_dht_.hybrid_time());</a>
<a name="ln883">    return GetIntentDocHybridTime();</a>
<a name="ln884">  }</a>
<a name="ln885">  return DocHybridTime::kInvalid;</a>
<a name="ln886">}</a>
<a name="ln887"> </a>
<a name="ln888">Result&lt;DocHybridTime&gt;</a>
<a name="ln889">IntentAwareIterator::GetMatchingRegularRecordDocHybridTime(</a>
<a name="ln890">    const Slice&amp; key_without_ht) {</a>
<a name="ln891">  DocHybridTime doc_ht;</a>
<a name="ln892">  int other_encoded_ht_size = 0;</a>
<a name="ln893">  RETURN_NOT_OK(CheckHybridTimeSizeAndValueType(iter_.key(), &amp;other_encoded_ht_size));</a>
<a name="ln894">  Slice iter_key_without_ht = iter_.key();</a>
<a name="ln895">  iter_key_without_ht.remove_suffix(1 + other_encoded_ht_size);</a>
<a name="ln896">  if (key_without_ht == iter_key_without_ht) {</a>
<a name="ln897">    RETURN_NOT_OK(DecodeHybridTimeFromEndOfKey(iter_.key(), &amp;doc_ht));</a>
<a name="ln898">    max_seen_ht_.MakeAtLeast(doc_ht.hybrid_time());</a>
<a name="ln899">    return doc_ht;</a>
<a name="ln900">  }</a>
<a name="ln901">  return DocHybridTime::kInvalid;</a>
<a name="ln902">}</a>
<a name="ln903"> </a>
<a name="ln904">Result&lt;HybridTime&gt; IntentAwareIterator::FindOldestRecord(</a>
<a name="ln905">    const Slice&amp; key_without_ht, HybridTime min_hybrid_time) {</a>
<a name="ln906">  VLOG(4) &lt;&lt; &quot;FindOldestRecord(&quot;</a>
<a name="ln907">          &lt;&lt; SubDocKey::DebugSliceToString(key_without_ht) &lt;&lt; &quot; = &quot;</a>
<a name="ln908">          &lt;&lt; key_without_ht.ToDebugHexString() &lt;&lt; &quot; , &quot; &lt;&lt; min_hybrid_time</a>
<a name="ln909">          &lt;&lt; &quot;)&quot;;</a>
<a name="ln910">#define DOCDB_DEBUG</a>
<a name="ln911">  DOCDB_DEBUG_SCOPE_LOG(SubDocKey::DebugSliceToString(key_without_ht) + &quot;, &quot; +</a>
<a name="ln912">                            yb::ToString(min_hybrid_time),</a>
<a name="ln913">                        std::bind(&amp;IntentAwareIterator::DebugDump, this));</a>
<a name="ln914">#undef DOCDB_DEBUG</a>
<a name="ln915">  DCHECK(!DebugHasHybridTime(key_without_ht));</a>
<a name="ln916"> </a>
<a name="ln917">  RETURN_NOT_OK(status_);</a>
<a name="ln918">  if (!valid()) {</a>
<a name="ln919">    VLOG(4) &lt;&lt; &quot;Returning kInvalid&quot;;</a>
<a name="ln920">    return HybridTime::kInvalid;</a>
<a name="ln921">  }</a>
<a name="ln922"> </a>
<a name="ln923">  HybridTime result;</a>
<a name="ln924">  if (intent_iter_.Initialized()) {</a>
<a name="ln925">    auto intent_dht = VERIFY_RESULT(FindMatchingIntentRecordDocHybridTime(key_without_ht));</a>
<a name="ln926">    VLOG(4) &lt;&lt; &quot;Looking for Intent Record found ?  =  &quot;</a>
<a name="ln927">            &lt;&lt; (intent_dht != DocHybridTime::kInvalid);</a>
<a name="ln928">    if (intent_dht != DocHybridTime::kInvalid &amp;&amp;</a>
<a name="ln929">        intent_dht.hybrid_time() &gt; min_hybrid_time) {</a>
<a name="ln930">      result = intent_dht.hybrid_time();</a>
<a name="ln931">      VLOG(4) &lt;&lt; &quot; oldest_record_ht is now &quot; &lt;&lt; result;</a>
<a name="ln932">    }</a>
<a name="ln933">  } else {</a>
<a name="ln934">    VLOG(4) &lt;&lt; &quot;intent_iter_ not Initialized&quot;;</a>
<a name="ln935">  }</a>
<a name="ln936"> </a>
<a name="ln937">  seek_key_buffer_.Reserve(key_without_ht.size() +</a>
<a name="ln938">                           kMaxBytesPerEncodedHybridTime);</a>
<a name="ln939">  seek_key_buffer_.Reset(key_without_ht);</a>
<a name="ln940">  seek_key_buffer_.AppendValueType(ValueType::kHybridTime);</a>
<a name="ln941">  seek_key_buffer_.AppendHybridTime(</a>
<a name="ln942">      DocHybridTime(min_hybrid_time, kMaxWriteId));</a>
<a name="ln943">  SeekForwardRegular(seek_key_buffer_);</a>
<a name="ln944">  RETURN_NOT_OK(status_);</a>
<a name="ln945">  if (iter_.Valid()) {</a>
<a name="ln946">    iter_.Prev();</a>
<a name="ln947">  } else {</a>
<a name="ln948">    iter_.SeekToLast();</a>
<a name="ln949">  }</a>
<a name="ln950">  SkipFutureRecords(Direction::kForward);</a>
<a name="ln951"> </a>
<a name="ln952">  if (iter_valid_) {</a>
<a name="ln953">    DocHybridTime regular_dht =</a>
<a name="ln954">        VERIFY_RESULT(GetMatchingRegularRecordDocHybridTime(key_without_ht));</a>
<a name="ln955">    VLOG(4) &lt;&lt; &quot;Looking for Matching Regular Record found   =  &quot; &lt;&lt; regular_dht;</a>
<a name="ln956">    if (regular_dht != DocHybridTime::kInvalid &amp;&amp;</a>
<a name="ln957">        regular_dht.hybrid_time() &gt; min_hybrid_time) {</a>
<a name="ln958">      result.MakeAtMost(regular_dht.hybrid_time());</a>
<a name="ln959">    }</a>
<a name="ln960">  } else {</a>
<a name="ln961">    VLOG(4) &lt;&lt; &quot;iter_valid_ is false&quot;;</a>
<a name="ln962">  }</a>
<a name="ln963">  VLOG(4) &lt;&lt; &quot;Returning &quot; &lt;&lt; result;</a>
<a name="ln964">  return result;</a>
<a name="ln965">}</a>
<a name="ln966"> </a>
<a name="ln967">Status IntentAwareIterator::FindLatestRecord(</a>
<a name="ln968">    const Slice&amp; key_without_ht,</a>
<a name="ln969">    DocHybridTime* latest_record_ht,</a>
<a name="ln970">    Slice* result_value) {</a>
<a name="ln971">  if (!latest_record_ht) {</a>
<a name="ln972">    return STATUS(Corruption, &quot;latest_record_ht should not be a null pointer&quot;);</a>
<a name="ln973">  }</a>
<a name="ln974">  VLOG(4) &lt;&lt; __func__ &lt;&lt; &quot;(&quot; &lt;&lt; SubDocKey::DebugSliceToString(key_without_ht) &lt;&lt; &quot;, &quot;</a>
<a name="ln975">          &lt;&lt; *latest_record_ht &lt;&lt; &quot;)&quot;;</a>
<a name="ln976">  DOCDB_DEBUG_SCOPE_LOG(</a>
<a name="ln977">      SubDocKey::DebugSliceToString(key_without_ht) + &quot;, &quot; + yb::ToString(latest_record_ht) + &quot;, &quot;</a>
<a name="ln978">      + yb::ToString(result_value),</a>
<a name="ln979">      std::bind(&amp;IntentAwareIterator::DebugDump, this));</a>
<a name="ln980">  DCHECK(!DebugHasHybridTime(key_without_ht));</a>
<a name="ln981"> </a>
<a name="ln982">  RETURN_NOT_OK(status_);</a>
<a name="ln983">  if (!valid()) {</a>
<a name="ln984">    return Status::OK();</a>
<a name="ln985">  }</a>
<a name="ln986"> </a>
<a name="ln987">  bool found_later_intent_result = false;</a>
<a name="ln988">  if (intent_iter_.Initialized()) {</a>
<a name="ln989">    DocHybridTime dht = VERIFY_RESULT(FindMatchingIntentRecordDocHybridTime(key_without_ht));</a>
<a name="ln990">    if (dht != DocHybridTime::kInvalid &amp;&amp; dht &gt; *latest_record_ht) {</a>
<a name="ln991">      *latest_record_ht = dht;</a>
<a name="ln992">      found_later_intent_result = true;</a>
<a name="ln993">    }</a>
<a name="ln994">  }</a>
<a name="ln995"> </a>
<a name="ln996">  seek_key_buffer_.Reserve(key_without_ht.size() + encoded_read_time_global_limit_.size() + 1);</a>
<a name="ln997">  seek_key_buffer_.Reset(key_without_ht);</a>
<a name="ln998">  AppendEncodedDocHt(encoded_read_time_global_limit_, &amp;seek_key_buffer_);</a>
<a name="ln999"> </a>
<a name="ln1000">  SeekForwardRegular(seek_key_buffer_);</a>
<a name="ln1001">  RETURN_NOT_OK(status_);</a>
<a name="ln1002">  // After SeekForwardRegular(), we need to call valid() to skip future records and see if the</a>
<a name="ln1003">  // current key still matches the pushed prefix if any. If it does not, we are done.</a>
<a name="ln1004">  if (!valid()) {</a>
<a name="ln1005">    return Status::OK();</a>
<a name="ln1006">  }</a>
<a name="ln1007"> </a>
<a name="ln1008">  bool found_later_regular_result = false;</a>
<a name="ln1009">  if (iter_valid_) {</a>
<a name="ln1010">    DocHybridTime dht = VERIFY_RESULT(GetMatchingRegularRecordDocHybridTime(key_without_ht));</a>
<a name="ln1011">    if (dht != DocHybridTime::kInvalid &amp;&amp; dht &gt; *latest_record_ht) {</a>
<a name="ln1012">      *latest_record_ht = dht;</a>
<a name="ln1013">      found_later_regular_result = true;</a>
<a name="ln1014">    }</a>
<a name="ln1015">  }</a>
<a name="ln1016"> </a>
<a name="ln1017">  if (result_value) {</a>
<a name="ln1018">    if (found_later_regular_result) {</a>
<a name="ln1019">      *result_value = iter_.value();</a>
<a name="ln1020">    } else if (found_later_intent_result) {</a>
<a name="ln1021">      *result_value = resolved_intent_value_;</a>
<a name="ln1022">    }</a>
<a name="ln1023">  }</a>
<a name="ln1024">  return Status::OK();</a>
<a name="ln1025">}</a>
<a name="ln1026"> </a>
<a name="ln1027">void IntentAwareIterator::PushPrefix(const Slice&amp; prefix) {</a>
<a name="ln1028">  VLOG(4) &lt;&lt; &quot;PushPrefix: &quot; &lt;&lt; SubDocKey::DebugSliceToString(prefix);</a>
<a name="ln1029">  prefix_stack_.push_back(prefix);</a>
<a name="ln1030">  skip_future_records_needed_ = true;</a>
<a name="ln1031">  skip_future_intents_needed_ = true;</a>
<a name="ln1032">}</a>
<a name="ln1033"> </a>
<a name="ln1034">void IntentAwareIterator::PopPrefix() {</a>
<a name="ln1035">  prefix_stack_.pop_back();</a>
<a name="ln1036">  skip_future_records_needed_ = true;</a>
<a name="ln1037">  skip_future_intents_needed_ = true;</a>
<a name="ln1038">  VLOG(4) &lt;&lt; &quot;PopPrefix: &quot;</a>
<a name="ln1039">          &lt;&lt; (prefix_stack_.empty() ? std::string()</a>
<a name="ln1040">              : SubDocKey::DebugSliceToString(prefix_stack_.back()));</a>
<a name="ln1041">}</a>
<a name="ln1042"> </a>
<a name="ln1043">void IntentAwareIterator::SkipFutureRecords(const Direction direction) {</a>
<a name="ln1044">  skip_future_records_needed_ = false;</a>
<a name="ln1045">  if (!status_.ok()) {</a>
<a name="ln1046">    return;</a>
<a name="ln1047">  }</a>
<a name="ln1048">  auto prefix = prefix_stack_.empty() ? Slice() : prefix_stack_.back();</a>
<a name="ln1049">  while (iter_.Valid()) {</a>
<a name="ln1050">    if (!iter_.key().starts_with(prefix)) {</a>
<a name="ln1051">      VLOG(4) &lt;&lt; &quot;Unmatched prefix: &quot; &lt;&lt; SubDocKey::DebugSliceToString(iter_.key())</a>
<a name="ln1052">              &lt;&lt; &quot;, prefix: &quot; &lt;&lt; SubDocKey::DebugSliceToString(prefix);</a>
<a name="ln1053">      iter_valid_ = false;</a>
<a name="ln1054">      return;</a>
<a name="ln1055">    }</a>
<a name="ln1056">    if (!SatisfyBounds(iter_.key())) {</a>
<a name="ln1057">      VLOG(4) &lt;&lt; &quot;Out of bounds: &quot; &lt;&lt; SubDocKey::DebugSliceToString(iter_.key())</a>
<a name="ln1058">              &lt;&lt; &quot;, upperbound: &quot; &lt;&lt; SubDocKey::DebugSliceToString(upperbound_);</a>
<a name="ln1059">      iter_valid_ = false;</a>
<a name="ln1060">      return;</a>
<a name="ln1061">    }</a>
<a name="ln1062">    Slice encoded_doc_ht = iter_.key();</a>
<a name="ln1063">    if (encoded_doc_ht.TryConsumeByte(ValueTypeAsChar::kTransactionApplyState)) {</a>
<a name="ln1064">      if (!NextRegular(direction)) {</a>
<a name="ln1065">        return;</a>
<a name="ln1066">      }</a>
<a name="ln1067">      continue;</a>
<a name="ln1068">    }</a>
<a name="ln1069">    int doc_ht_size = 0;</a>
<a name="ln1070">    auto decode_status = DocHybridTime::CheckAndGetEncodedSize(encoded_doc_ht, &amp;doc_ht_size);</a>
<a name="ln1071">    if (!decode_status.ok()) {</a>
<a name="ln1072">      LOG(ERROR) &lt;&lt; &quot;Decode doc ht from key failed: &quot; &lt;&lt; decode_status</a>
<a name="ln1073">                 &lt;&lt; &quot;, key: &quot; &lt;&lt; iter_.key().ToDebugHexString();</a>
<a name="ln1074">      status_ = std::move(decode_status);</a>
<a name="ln1075">      return;</a>
<a name="ln1076">    }</a>
<a name="ln1077">    encoded_doc_ht.remove_prefix(encoded_doc_ht.size() - doc_ht_size);</a>
<a name="ln1078">    auto value = iter_.value();</a>
<a name="ln1079">    auto value_type = DecodeValueType(value);</a>
<a name="ln1080">    VLOG(4) &lt;&lt; &quot;Checking for skip, type &quot; &lt;&lt; value_type &lt;&lt; &quot;, encoded_doc_ht: &quot;</a>
<a name="ln1081">            &lt;&lt; DocHybridTime::DebugSliceToString(encoded_doc_ht)</a>
<a name="ln1082">            &lt;&lt; &quot; value: &quot; &lt;&lt; value.ToDebugHexString();</a>
<a name="ln1083">    if (value_type == ValueType::kHybridTime) {</a>
<a name="ln1084">      // Value came from a transaction, we could try to filter it by original intent time.</a>
<a name="ln1085">      Slice encoded_intent_doc_ht = value;</a>
<a name="ln1086">      encoded_intent_doc_ht.consume_byte();</a>
<a name="ln1087">      if (encoded_intent_doc_ht.compare(Slice(encoded_read_time_local_limit_)) &gt; 0 &amp;&amp;</a>
<a name="ln1088">          encoded_doc_ht.compare(Slice(encoded_read_time_global_limit_)) &gt; 0) {</a>
<a name="ln1089">        iter_valid_ = true;</a>
<a name="ln1090">        return;</a>
<a name="ln1091">      }</a>
<a name="ln1092">    } else if (encoded_doc_ht.compare(Slice(encoded_read_time_local_limit_)) &gt; 0) {</a>
<a name="ln1093">      iter_valid_ = true;</a>
<a name="ln1094">      return;</a>
<a name="ln1095">    }</a>
<a name="ln1096">    VLOG(4) &lt;&lt; &quot;Skipping because of time: &quot; &lt;&lt; SubDocKey::DebugSliceToString(iter_.key())</a>
<a name="ln1097">            &lt;&lt; &quot;, read time: &quot; &lt;&lt; read_time_;</a>
<a name="ln1098">    if (!NextRegular(direction)) {</a>
<a name="ln1099">      return;</a>
<a name="ln1100">    }</a>
<a name="ln1101">  }</a>
<a name="ln1102">  iter_valid_ = false;</a>
<a name="ln1103">}</a>
<a name="ln1104"> </a>
<a name="ln1105">bool IntentAwareIterator::NextRegular(Direction direction) {</a>
<a name="ln1106">  switch (direction) {</a>
<a name="ln1107">    case Direction::kForward:</a>
<a name="ln1108">      iter_.Next(); // TODO(dtxn) use seek with the same key, but read limit as doc hybrid time.</a>
<a name="ln1109">      return true;</a>
<a name="ln1110">    case Direction::kBackward:</a>
<a name="ln1111">      iter_.Prev();</a>
<a name="ln1112">      return true;</a>
<a name="ln1113">  }</a>
<a name="ln1114"> </a>
<a name="ln1115">  status_ = STATUS_FORMAT(Corruption, &quot;Unexpected direction: $0&quot;, direction);</a>
<a name="ln1116">  LOG(ERROR) &lt;&lt; status_;</a>
<a name="ln1117">  iter_valid_ = false;</a>
<a name="ln1118">  return false;</a>
<a name="ln1119">}</a>
<a name="ln1120"> </a>
<a name="ln1121">void IntentAwareIterator::SkipFutureIntents() {</a>
<a name="ln1122">  skip_future_intents_needed_ = false;</a>
<a name="ln1123">  if (!intent_iter_.Initialized() || !status_.ok()) {</a>
<a name="ln1124">    return;</a>
<a name="ln1125">  }</a>
<a name="ln1126">  auto prefix = prefix_stack_.empty() ? Slice() : prefix_stack_.back();</a>
<a name="ln1127">  if (resolved_intent_state_ != ResolvedIntentState::kNoIntent) {</a>
<a name="ln1128">    auto compare_result = resolved_intent_key_prefix_.AsSlice().compare_prefix(prefix);</a>
<a name="ln1129">    VLOG(4) &lt;&lt; &quot;Checking resolved intent subdockey: &quot;</a>
<a name="ln1130">            &lt;&lt; DebugDumpKeyToStr(resolved_intent_key_prefix_)</a>
<a name="ln1131">            &lt;&lt; &quot;, against new prefix: &quot; &lt;&lt; DebugDumpKeyToStr(prefix) &lt;&lt; &quot;: &quot;</a>
<a name="ln1132">            &lt;&lt; compare_result;</a>
<a name="ln1133">    if (compare_result == 0) {</a>
<a name="ln1134">      if (!SatisfyBounds(resolved_intent_key_prefix_.AsSlice())) {</a>
<a name="ln1135">        resolved_intent_state_ = ResolvedIntentState::kNoIntent;</a>
<a name="ln1136">      } else {</a>
<a name="ln1137">        resolved_intent_state_ = ResolvedIntentState::kValid;</a>
<a name="ln1138">      }</a>
<a name="ln1139">      return;</a>
<a name="ln1140">    } else if (compare_result &gt; 0) {</a>
<a name="ln1141">      resolved_intent_state_ = ResolvedIntentState::kInvalidPrefix;</a>
<a name="ln1142">      return;</a>
<a name="ln1143">    }</a>
<a name="ln1144">  }</a>
<a name="ln1145">  SeekToSuitableIntent&lt;Direction::kForward&gt;();</a>
<a name="ln1146">}</a>
<a name="ln1147"> </a>
<a name="ln1148">Status IntentAwareIterator::SetIntentUpperbound() {</a>
<a name="ln1149">  if (iter_.Valid()) {</a>
<a name="ln1150">    intent_upperbound_keybytes_.Clear();</a>
<a name="ln1151">    // Strip ValueType::kHybridTime + DocHybridTime at the end of SubDocKey in iter_ and append</a>
<a name="ln1152">    // to upperbound with 0xff.</a>
<a name="ln1153">    Slice subdoc_key = iter_.key();</a>
<a name="ln1154">    int doc_ht_size = 0;</a>
<a name="ln1155">    RETURN_NOT_OK(DocHybridTime::CheckAndGetEncodedSize(subdoc_key, &amp;doc_ht_size));</a>
<a name="ln1156">    subdoc_key.remove_suffix(1 + doc_ht_size);</a>
<a name="ln1157">    intent_upperbound_keybytes_.AppendRawBytes(subdoc_key);</a>
<a name="ln1158">    VLOG(4) &lt;&lt; &quot;SetIntentUpperbound = &quot;</a>
<a name="ln1159">            &lt;&lt; SubDocKey::DebugSliceToString(intent_upperbound_keybytes_.AsSlice());</a>
<a name="ln1160">    intent_upperbound_keybytes_.AppendValueType(ValueType::kMaxByte);</a>
<a name="ln1161">    intent_upperbound_ = intent_upperbound_keybytes_.AsSlice();</a>
<a name="ln1162">    intent_iter_.RevalidateAfterUpperBoundChange();</a>
<a name="ln1163">  } else {</a>
<a name="ln1164">    // In case the current position of the regular iterator is invalid, set the exclusive intent</a>
<a name="ln1165">    // upperbound high to be able to find all intents higher than the last regular record.</a>
<a name="ln1166">    ResetIntentUpperbound();</a>
<a name="ln1167">  }</a>
<a name="ln1168">  return Status::OK();</a>
<a name="ln1169">}</a>
<a name="ln1170"> </a>
<a name="ln1171">void IntentAwareIterator::ResetIntentUpperbound() {</a>
<a name="ln1172">  intent_upperbound_keybytes_.Clear();</a>
<a name="ln1173">  intent_upperbound_keybytes_.AppendValueType(ValueType::kHighest);</a>
<a name="ln1174">  intent_upperbound_ = intent_upperbound_keybytes_.AsSlice();</a>
<a name="ln1175">  intent_iter_.RevalidateAfterUpperBoundChange();</a>
<a name="ln1176">  VLOG(4) &lt;&lt; &quot;ResetIntentUpperbound = &quot; &lt;&lt; intent_upperbound_.ToDebugString();</a>
<a name="ln1177">}</a>
<a name="ln1178"> </a>
<a name="ln1179">}  // namespace docdb</a>
<a name="ln1180">}  // namespace yb</a>

</code></pre>
<div class="balloon" rel="174"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="176"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="247"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="274"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="294"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="307"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="326"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="354"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="395"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="410"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="520"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="564"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="608"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="648"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="659"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="667"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="672"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="679"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="695"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="746"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="751"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="757"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="764"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="769"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="771"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="809"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="870"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="906"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="915"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="919"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="926"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="931"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="934"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="955"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="961"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="963"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="974"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="980"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1028"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1038"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1051"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1057"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1080"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1096"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1129"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1158"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1176"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
