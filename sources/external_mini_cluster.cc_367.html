
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>external_mini_cluster.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Licensed to the Apache Software Foundation (ASF) under one</a>
<a name="ln2">// or more contributor license agreements.  See the NOTICE file</a>
<a name="ln3">// distributed with this work for additional information</a>
<a name="ln4">// regarding copyright ownership.  The ASF licenses this file</a>
<a name="ln5">// to you under the Apache License, Version 2.0 (the</a>
<a name="ln6">// &quot;License&quot;); you may not use this file except in compliance</a>
<a name="ln7">// with the License.  You may obtain a copy of the License at</a>
<a name="ln8">//</a>
<a name="ln9">//   http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln10">//</a>
<a name="ln11">// Unless required by applicable law or agreed to in writing,</a>
<a name="ln12">// software distributed under the License is distributed on an</a>
<a name="ln13">// &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</a>
<a name="ln14">// KIND, either express or implied.  See the License for the</a>
<a name="ln15">// specific language governing permissions and limitations</a>
<a name="ln16">// under the License.</a>
<a name="ln17">//</a>
<a name="ln18">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln19">//</a>
<a name="ln20">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln21">//</a>
<a name="ln22">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln23">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln24">//</a>
<a name="ln25">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln26">//</a>
<a name="ln27">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln28">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln29">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln30">// under the License.</a>
<a name="ln31">//</a>
<a name="ln32"> </a>
<a name="ln33">#include &quot;yb/integration-tests/external_mini_cluster.h&quot;</a>
<a name="ln34"> </a>
<a name="ln35">#include &lt;sys/stat.h&gt;</a>
<a name="ln36"> </a>
<a name="ln37">#include &lt;atomic&gt;</a>
<a name="ln38">#include &lt;memory&gt;</a>
<a name="ln39">#include &lt;mutex&gt;</a>
<a name="ln40">#include &lt;string&gt;</a>
<a name="ln41">#include &lt;thread&gt;</a>
<a name="ln42">#include &lt;chrono&gt;</a>
<a name="ln43"> </a>
<a name="ln44">#include &lt;gtest/gtest.h&gt;</a>
<a name="ln45">#include &lt;rapidjson/document.h&gt;</a>
<a name="ln46"> </a>
<a name="ln47">#include &quot;yb/client/client.h&quot;</a>
<a name="ln48">#include &quot;yb/client/table_handle.h&quot;</a>
<a name="ln49">#include &quot;yb/common/wire_protocol.h&quot;</a>
<a name="ln50">#include &quot;yb/fs/fs_manager.h&quot;</a>
<a name="ln51">#include &quot;yb/gutil/mathlimits.h&quot;</a>
<a name="ln52">#include &quot;yb/gutil/strings/join.h&quot;</a>
<a name="ln53">#include &quot;yb/gutil/strings/substitute.h&quot;</a>
<a name="ln54">#include &quot;yb/gutil/strings/util.h&quot;</a>
<a name="ln55">#include &quot;yb/gutil/singleton.h&quot;</a>
<a name="ln56">#include &quot;yb/integration-tests/cluster_itest_util.h&quot;</a>
<a name="ln57">#include &quot;yb/master/master.proxy.h&quot;</a>
<a name="ln58">#include &quot;yb/master/master_rpc.h&quot;</a>
<a name="ln59">#include &quot;yb/server/server_base.pb.h&quot;</a>
<a name="ln60">#include &quot;yb/tserver/tserver_service.proxy.h&quot;</a>
<a name="ln61">#include &quot;yb/rpc/connection_context.h&quot;</a>
<a name="ln62">#include &quot;yb/rpc/messenger.h&quot;</a>
<a name="ln63">#include &quot;yb/rpc/yb_rpc.h&quot;</a>
<a name="ln64">#include &quot;yb/master/sys_catalog.h&quot;</a>
<a name="ln65">#include &quot;yb/util/async_util.h&quot;</a>
<a name="ln66">#include &quot;yb/util/curl_util.h&quot;</a>
<a name="ln67">#include &quot;yb/util/env.h&quot;</a>
<a name="ln68">#include &quot;yb/util/jsonreader.h&quot;</a>
<a name="ln69">#include &quot;yb/util/metrics.h&quot;</a>
<a name="ln70">#include &quot;yb/util/net/sockaddr.h&quot;</a>
<a name="ln71">#include &quot;yb/util/net/socket.h&quot;</a>
<a name="ln72">#include &quot;yb/util/path_util.h&quot;</a>
<a name="ln73">#include &quot;yb/util/pb_util.h&quot;</a>
<a name="ln74">#include &quot;yb/util/stopwatch.h&quot;</a>
<a name="ln75">#include &quot;yb/util/subprocess.h&quot;</a>
<a name="ln76">#include &quot;yb/util/test_util.h&quot;</a>
<a name="ln77">#include &quot;yb/util/size_literals.h&quot;</a>
<a name="ln78">#include &quot;yb/yql/pgwrapper/pg_wrapper.h&quot;</a>
<a name="ln79"> </a>
<a name="ln80">using namespace std::literals;  // NOLINT</a>
<a name="ln81">using namespace yb::size_literals;  // NOLINT</a>
<a name="ln82"> </a>
<a name="ln83">using std::atomic;</a>
<a name="ln84">using std::lock_guard;</a>
<a name="ln85">using std::mutex;</a>
<a name="ln86">using std::shared_ptr;</a>
<a name="ln87">using std::string;</a>
<a name="ln88">using std::thread;</a>
<a name="ln89">using std::unique_ptr;</a>
<a name="ln90"> </a>
<a name="ln91">using rapidjson::Value;</a>
<a name="ln92">using strings::Substitute;</a>
<a name="ln93"> </a>
<a name="ln94">using yb::master::GetLeaderMasterRpc;</a>
<a name="ln95">using yb::master::MasterServiceProxy;</a>
<a name="ln96">using yb::master::IsInitDbDoneRequestPB;</a>
<a name="ln97">using yb::master::IsInitDbDoneResponsePB;</a>
<a name="ln98">using yb::server::ServerStatusPB;</a>
<a name="ln99">using yb::tserver::ListTabletsRequestPB;</a>
<a name="ln100">using yb::tserver::ListTabletsResponsePB;</a>
<a name="ln101">using yb::tserver::TabletServerErrorPB;</a>
<a name="ln102">using yb::tserver::TabletServerServiceProxy;</a>
<a name="ln103">using yb::consensus::ConsensusServiceProxy;</a>
<a name="ln104">using yb::consensus::RaftPeerPB;</a>
<a name="ln105">using yb::consensus::ChangeConfigRequestPB;</a>
<a name="ln106">using yb::consensus::ChangeConfigResponsePB;</a>
<a name="ln107">using yb::consensus::ChangeConfigType;</a>
<a name="ln108">using yb::consensus::GetLastOpIdRequestPB;</a>
<a name="ln109">using yb::consensus::GetLastOpIdResponsePB;</a>
<a name="ln110">using yb::consensus::LeaderStepDownRequestPB;</a>
<a name="ln111">using yb::consensus::LeaderStepDownResponsePB;</a>
<a name="ln112">using yb::consensus::RunLeaderElectionRequestPB;</a>
<a name="ln113">using yb::consensus::RunLeaderElectionResponsePB;</a>
<a name="ln114">using yb::master::IsMasterLeaderReadyRequestPB;</a>
<a name="ln115">using yb::master::IsMasterLeaderReadyResponsePB;</a>
<a name="ln116">using yb::master::GetMasterClusterConfigRequestPB;</a>
<a name="ln117">using yb::master::GetMasterClusterConfigResponsePB;</a>
<a name="ln118">using yb::master::ChangeMasterClusterConfigRequestPB;</a>
<a name="ln119">using yb::master::ChangeMasterClusterConfigResponsePB;</a>
<a name="ln120">using yb::master::SysClusterConfigEntryPB;</a>
<a name="ln121">using yb::master::BlacklistPB;</a>
<a name="ln122">using yb::master::ListMastersRequestPB;</a>
<a name="ln123">using yb::master::ListMastersResponsePB;</a>
<a name="ln124">using yb::master::ListMasterRaftPeersRequestPB;</a>
<a name="ln125">using yb::master::ListMasterRaftPeersResponsePB;</a>
<a name="ln126">using yb::tserver::TabletServerErrorPB;</a>
<a name="ln127">using yb::rpc::RpcController;</a>
<a name="ln128">using yb::pgwrapper::PgWrapper;</a>
<a name="ln129"> </a>
<a name="ln130">typedef ListTabletsResponsePB::StatusAndSchemaPB StatusAndSchemaPB;</a>
<a name="ln131"> </a>
<a name="ln132">DECLARE_string(vmodule);</a>
<a name="ln133">DECLARE_int32(replication_factor);</a>
<a name="ln134">DECLARE_bool(mem_tracker_logging);</a>
<a name="ln135">DECLARE_bool(mem_tracker_log_stack_trace);</a>
<a name="ln136">DECLARE_string(minicluster_daemon_id);</a>
<a name="ln137">DECLARE_bool(use_libbacktrace);</a>
<a name="ln138"> </a>
<a name="ln139">DEFINE_string(external_daemon_heap_profile_prefix, &quot;&quot;,</a>
<a name="ln140">              &quot;If this is not empty, tcmalloc's HEAPPROFILE is set this, followed by a unique &quot;</a>
<a name="ln141">              &quot;suffix for external mini-cluster daemons.&quot;);</a>
<a name="ln142"> </a>
<a name="ln143">DEFINE_bool(external_daemon_safe_shutdown, false,</a>
<a name="ln144">            &quot;Shutdown external daemons using SIGTERM first. Disabled by default to avoid &quot;</a>
<a name="ln145">            &quot;interfering with kill-testing.&quot;);</a>
<a name="ln146"> </a>
<a name="ln147">DECLARE_int64(outbound_rpc_block_size);</a>
<a name="ln148">DECLARE_int64(outbound_rpc_memory_limit);</a>
<a name="ln149"> </a>
<a name="ln150">DEFINE_int64(external_mini_cluster_max_log_bytes, 50_MB * 100,</a>
<a name="ln151">             &quot;Max total size of log bytes produced by all external mini-cluster daemons. &quot;</a>
<a name="ln152">             &quot;The test is shut down if this limit is exceeded.&quot;);</a>
<a name="ln153"> </a>
<a name="ln154">namespace yb {</a>
<a name="ln155"> </a>
<a name="ln156">static const char* const kMasterBinaryName = &quot;yb-master&quot;;</a>
<a name="ln157">static const char* const kTabletServerBinaryName = &quot;yb-tserver&quot;;</a>
<a name="ln158">static double kProcessStartTimeoutSeconds = 60.0;</a>
<a name="ln159">static MonoDelta kTabletServerRegistrationTimeout = 60s;</a>
<a name="ln160"> </a>
<a name="ln161">static const int kHeapProfileSignal = SIGUSR1;</a>
<a name="ln162"> </a>
<a name="ln163">#if defined(__APPLE__)</a>
<a name="ln164">static bool kBindToUniqueLoopbackAddress = false;</a>
<a name="ln165">#else</a>
<a name="ln166">static bool kBindToUniqueLoopbackAddress = true;</a>
<a name="ln167">#endif</a>
<a name="ln168"> </a>
<a name="ln169">constexpr size_t kDefaultMemoryLimitHardBytes = NonTsanVsTsan(1_GB, 512_MB);</a>
<a name="ln170"> </a>
<a name="ln171">namespace {</a>
<a name="ln172"> </a>
<a name="ln173">void AddExtraFlagsFromEnvVar(const char* env_var_name, std::vector&lt;std::string&gt;* args_dest) {</a>
<a name="ln174">  const char* extra_daemon_flags_env_var_value = getenv(env_var_name);</a>
<a name="ln175">  if (extra_daemon_flags_env_var_value) {</a>
<a name="ln176">    LOG(INFO) &lt;&lt; &quot;Setting extra daemon flags as specified by env var &quot; &lt;&lt; env_var_name &lt;&lt; &quot;: &quot;</a>
<a name="ln177">              &lt;&lt; extra_daemon_flags_env_var_value;</a>
<a name="ln178">    // TODO: this has an issue with handling quoted arguments with embedded spaces.</a>
<a name="ln179">    std::istringstream iss(extra_daemon_flags_env_var_value);</a>
<a name="ln180">    copy(std::istream_iterator&lt;string&gt;(iss),</a>
<a name="ln181">         std::istream_iterator&lt;string&gt;(),</a>
<a name="ln182">         std::back_inserter(*args_dest));</a>
<a name="ln183">  } else {</a>
<a name="ln184">    LOG(INFO) &lt;&lt; &quot;Env var &quot; &lt;&lt; env_var_name &lt;&lt; &quot; not specified, not setting extra flags from it&quot;;</a>
<a name="ln185">  }</a>
<a name="ln186">}</a>
<a name="ln187"> </a>
<a name="ln188">}  // anonymous namespace</a>
<a name="ln189"> </a>
<a name="ln190">// ------------------------------------------------------------------------------------------------</a>
<a name="ln191">// ExternalMiniClusterOptions</a>
<a name="ln192">// ------------------------------------------------------------------------------------------------</a>
<a name="ln193"> </a>
<a name="ln194">ExternalMiniClusterOptions::ExternalMiniClusterOptions()</a>
<a name="ln195">    : bind_to_unique_loopback_addresses(kBindToUniqueLoopbackAddress),</a>
<a name="ln196">      timeout(MonoDelta::FromMilliseconds(1000 * 10)) {</a>
<a name="ln197">}</a>
<a name="ln198"> </a>
<a name="ln199">ExternalMiniClusterOptions::~ExternalMiniClusterOptions() {</a>
<a name="ln200">}</a>
<a name="ln201"> </a>
<a name="ln202">Status ExternalMiniClusterOptions::RemovePort(const uint16_t port) {</a>
<a name="ln203">  auto iter = std::find(master_rpc_ports.begin(), master_rpc_ports.end(), port);</a>
<a name="ln204"> </a>
<a name="ln205">  if (iter == master_rpc_ports.end()) {</a>
<a name="ln206">    return STATUS(InvalidArgument, Substitute(</a>
<a name="ln207">        &quot;Port to be removed '$0' not found in existing list of $1 masters.&quot;,</a>
<a name="ln208">        port, num_masters));</a>
<a name="ln209">  }</a>
<a name="ln210"> </a>
<a name="ln211">  master_rpc_ports.erase(iter);</a>
<a name="ln212">  --num_masters;</a>
<a name="ln213"> </a>
<a name="ln214">  return Status::OK();</a>
<a name="ln215">}</a>
<a name="ln216"> </a>
<a name="ln217">Status ExternalMiniClusterOptions::AddPort(const uint16_t port) {</a>
<a name="ln218">  auto iter = std::find(master_rpc_ports.begin(), master_rpc_ports.end(), port);</a>
<a name="ln219"> </a>
<a name="ln220">  if (iter != master_rpc_ports.end()) {</a>
<a name="ln221">    return STATUS(InvalidArgument, Substitute(</a>
<a name="ln222">        &quot;Port to be added '$0' already found in the existing list of $1 masters.&quot;,</a>
<a name="ln223">        port, num_masters));</a>
<a name="ln224">  }</a>
<a name="ln225"> </a>
<a name="ln226">  master_rpc_ports.push_back(port);</a>
<a name="ln227">  ++num_masters;</a>
<a name="ln228"> </a>
<a name="ln229">  return Status::OK();</a>
<a name="ln230">}</a>
<a name="ln231"> </a>
<a name="ln232">void ExternalMiniClusterOptions::AdjustMasterRpcPorts() {</a>
<a name="ln233">  if (master_rpc_ports.size() == 1 &amp;&amp; master_rpc_ports[0] == 0) {</a>
<a name="ln234">    // Add missing master ports to avoid errors when we try to start the cluster.</a>
<a name="ln235">    while (master_rpc_ports.size() &lt; num_masters) {</a>
<a name="ln236">      master_rpc_ports.push_back(0);</a>
<a name="ln237">    }</a>
<a name="ln238">  }</a>
<a name="ln239">}</a>
<a name="ln240"> </a>
<a name="ln241">// ------------------------------------------------------------------------------------------------</a>
<a name="ln242">// ExternalMiniCluster</a>
<a name="ln243">// ------------------------------------------------------------------------------------------------</a>
<a name="ln244"> </a>
<a name="ln245">ExternalMiniCluster::ExternalMiniCluster(const ExternalMiniClusterOptions&amp; opts)</a>
<a name="ln246">    : opts_(opts), add_new_master_at_(-1) {</a>
<a name="ln247">  opts_.AdjustMasterRpcPorts();</a>
<a name="ln248">  // These &quot;extra mini cluster options&quot; are added in the end of the command line.</a>
<a name="ln249">  const auto common_extra_flags = {</a>
<a name="ln250">      &quot;--enable_tracing&quot;s,</a>
<a name="ln251">      Substitute(&quot;--memory_limit_hard_bytes=$0&quot;, kDefaultMemoryLimitHardBytes),</a>
<a name="ln252">      (opts.log_to_file ? &quot;--alsologtostderr&quot;s : &quot;--logtostderr&quot;s)</a>
<a name="ln253">  };</a>
<a name="ln254">  for (auto* extra_flags : {&amp;opts_.extra_master_flags, &amp;opts_.extra_tserver_flags}) {</a>
<a name="ln255">    // Common default extra flags are inserted in the beginning so that they can be overridden by</a>
<a name="ln256">    // caller-specified flags.</a>
<a name="ln257">    extra_flags-&gt;insert(extra_flags-&gt;begin(),</a>
<a name="ln258">                        common_extra_flags.begin(),</a>
<a name="ln259">                        common_extra_flags.end());</a>
<a name="ln260">  }</a>
<a name="ln261">  AddExtraFlagsFromEnvVar(&quot;YB_EXTRA_MASTER_FLAGS&quot;, &amp;opts_.extra_master_flags);</a>
<a name="ln262">  AddExtraFlagsFromEnvVar(&quot;YB_EXTRA_TSERVER_FLAGS&quot;, &amp;opts_.extra_tserver_flags);</a>
<a name="ln263">}</a>
<a name="ln264"> </a>
<a name="ln265">ExternalMiniCluster::~ExternalMiniCluster() {</a>
<a name="ln266">  Shutdown();</a>
<a name="ln267">  if (messenger_holder_) {</a>
<a name="ln268">    messenger_holder_-&gt;Shutdown();</a>
<a name="ln269">  }</a>
<a name="ln270">}</a>
<a name="ln271"> </a>
<a name="ln272">Status ExternalMiniCluster::DeduceBinRoot(std::string* ret) {</a>
<a name="ln273">  string exe;</a>
<a name="ln274">  RETURN_NOT_OK(Env::Default()-&gt;GetExecutablePath(&amp;exe));</a>
<a name="ln275">  *ret = DirName(exe) + &quot;/../bin&quot;;</a>
<a name="ln276">  return Status::OK();</a>
<a name="ln277">}</a>
<a name="ln278"> </a>
<a name="ln279">std::string ExternalMiniCluster::GetClusterDataDirName() const {</a>
<a name="ln280">  if (opts_.cluster_id == &quot;&quot;) {</a>
<a name="ln281">    return &quot;minicluster-data&quot;;</a>
<a name="ln282">  }</a>
<a name="ln283">  return Format(&quot;minicluster-data-$0&quot;, opts_.cluster_id);</a>
<a name="ln284">}</a>
<a name="ln285"> </a>
<a name="ln286">Status ExternalMiniCluster::HandleOptions() {</a>
<a name="ln287">  daemon_bin_path_ = opts_.daemon_bin_path;</a>
<a name="ln288">  if (daemon_bin_path_.empty()) {</a>
<a name="ln289">    RETURN_NOT_OK(DeduceBinRoot(&amp;daemon_bin_path_));</a>
<a name="ln290">  }</a>
<a name="ln291"> </a>
<a name="ln292">  data_root_ = opts_.data_root;</a>
<a name="ln293">  if (data_root_.empty()) {</a>
<a name="ln294">    // If they don't specify a data root, use the current gtest directory.</a>
<a name="ln295">    data_root_ = JoinPathSegments(GetTestDataDirectory(), GetClusterDataDirName());</a>
<a name="ln296"> </a>
<a name="ln297">    // If &quot;data_root_counter&quot; is non-negative, and the auto-generated &quot;data_root_&quot; directory already</a>
<a name="ln298">    // exists, create a subdirectory using the counter value as its name. The caller should maintain</a>
<a name="ln299">    // this counter and increment it for each test run.</a>
<a name="ln300">    if (opts_.data_root_counter &gt;= 0) {</a>
<a name="ln301">      struct stat sb;</a>
<a name="ln302">      if (stat(data_root_.c_str(), &amp;sb) == 0 &amp;&amp; S_ISDIR(sb.st_mode)) {</a>
<a name="ln303">        data_root_ = Substitute(&quot;$0/$1&quot;, data_root_, opts_.data_root_counter);</a>
<a name="ln304">        CHECK_EQ(mkdir(data_root_.c_str(), S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH), 0);</a>
<a name="ln305">      }</a>
<a name="ln306">    }</a>
<a name="ln307">  }</a>
<a name="ln308"> </a>
<a name="ln309">  return Status::OK();</a>
<a name="ln310">}</a>
<a name="ln311"> </a>
<a name="ln312">Status ExternalMiniCluster::Start(rpc::Messenger* messenger) {</a>
<a name="ln313">  CHECK(masters_.empty()) &lt;&lt; &quot;Masters are not empty (size: &quot; &lt;&lt; masters_.size()</a>
<a name="ln314">      &lt;&lt; &quot;). Maybe you meant Restart()?&quot;;</a>
<a name="ln315">  CHECK(tablet_servers_.empty()) &lt;&lt; &quot;Tablet servers are not empty (size: &quot;</a>
<a name="ln316">      &lt;&lt; tablet_servers_.size() &lt;&lt; &quot;). Maybe you meant Restart()?&quot;;</a>
<a name="ln317">  RETURN_NOT_OK(HandleOptions());</a>
<a name="ln318">  FLAGS_replication_factor = opts_.num_masters;</a>
<a name="ln319"> </a>
<a name="ln320">  if (messenger == nullptr) {</a>
<a name="ln321">    rpc::MessengerBuilder builder(&quot;minicluster-messenger&quot;);</a>
<a name="ln322">    builder.set_num_reactors(1);</a>
<a name="ln323">    messenger_holder_ = VERIFY_RESULT_PREPEND(</a>
<a name="ln324">        builder.Build(), &quot;Failed to start Messenger for minicluster&quot;);</a>
<a name="ln325">    messenger_ = messenger_holder_.get();</a>
<a name="ln326">  } else {</a>
<a name="ln327">    messenger_holder_ = nullptr;</a>
<a name="ln328">    messenger_ = messenger;</a>
<a name="ln329">  }</a>
<a name="ln330">  proxy_cache_ = std::make_unique&lt;rpc::ProxyCache&gt;(messenger_);</a>
<a name="ln331"> </a>
<a name="ln332">  Status s = Env::Default()-&gt;CreateDir(data_root_);</a>
<a name="ln333">  if (!s.ok() &amp;&amp; !s.IsAlreadyPresent()) {</a>
<a name="ln334">    RETURN_NOT_OK_PREPEND(s, &quot;Could not create root dir &quot; + data_root_);</a>
<a name="ln335">  }</a>
<a name="ln336"> </a>
<a name="ln337">  LOG(INFO) &lt;&lt; &quot;Starting cluster with option bind_to_unique_loopback_addresses=&quot;</a>
<a name="ln338">      &lt;&lt; (opts_.bind_to_unique_loopback_addresses ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="ln339"> </a>
<a name="ln340">  LOG(INFO) &lt;&lt; &quot;Starting &quot; &lt;&lt; opts_.num_masters &lt;&lt; &quot; masters&quot;;</a>
<a name="ln341">  RETURN_NOT_OK_PREPEND(StartMasters(), &quot;Failed to start masters.&quot;);</a>
<a name="ln342">  add_new_master_at_ = opts_.num_masters;</a>
<a name="ln343"> </a>
<a name="ln344">  if (opts_.num_tablet_servers &gt; 0) {</a>
<a name="ln345">    LOG(INFO) &lt;&lt; &quot;Starting &quot; &lt;&lt; opts_.num_tablet_servers &lt;&lt; &quot; tablet servers&quot;;</a>
<a name="ln346"> </a>
<a name="ln347">    for (int i = 1; i &lt;= opts_.num_tablet_servers; i++) {</a>
<a name="ln348">      RETURN_NOT_OK_PREPEND(</a>
<a name="ln349">          AddTabletServer(ExternalMiniClusterOptions::kDefaultStartCqlProxy),</a>
<a name="ln350">          Substitute(&quot;Failed starting tablet server $0&quot;, i));</a>
<a name="ln351">    }</a>
<a name="ln352">    RETURN_NOT_OK(WaitForTabletServerCount(</a>
<a name="ln353">        opts_.num_tablet_servers, kTabletServerRegistrationTimeout));</a>
<a name="ln354">  } else {</a>
<a name="ln355">    LOG(INFO) &lt;&lt; &quot;No need to start tablet servers&quot;;</a>
<a name="ln356">  }</a>
<a name="ln357"> </a>
<a name="ln358">  running_ = true;</a>
<a name="ln359">  return Status::OK();</a>
<a name="ln360">}</a>
<a name="ln361"> </a>
<a name="ln362">void ExternalMiniCluster::Shutdown(NodeSelectionMode mode) {</a>
<a name="ln363">  // TODO: in the regular MiniCluster Shutdown is a no-op if running_ is false.</a>
<a name="ln364">  // Therefore, in case of an error during cluster startup behavior might be different.</a>
<a name="ln365">  if (mode == ALL) {</a>
<a name="ln366">    for (const scoped_refptr&lt;ExternalMaster&gt;&amp; master : masters_) {</a>
<a name="ln367">      if (master) {</a>
<a name="ln368">        master-&gt;Shutdown();</a>
<a name="ln369">      }</a>
<a name="ln370">    }</a>
<a name="ln371">  }</a>
<a name="ln372"> </a>
<a name="ln373">  for (const scoped_refptr&lt;ExternalTabletServer&gt;&amp; ts : tablet_servers_) {</a>
<a name="ln374">    ts-&gt;Shutdown();</a>
<a name="ln375">  }</a>
<a name="ln376">  running_ = false;</a>
<a name="ln377">}</a>
<a name="ln378"> </a>
<a name="ln379">Status ExternalMiniCluster::Restart() {</a>
<a name="ln380">  LOG(INFO) &lt;&lt; &quot;Restarting cluster with &quot; &lt;&lt; masters_.size() &lt;&lt; &quot; masters.&quot;;</a>
<a name="ln381">  for (const scoped_refptr&lt;ExternalMaster&gt;&amp; master : masters_) {</a>
<a name="ln382">    if (master &amp;&amp; master-&gt;IsShutdown()) {</a>
<a name="ln383">      RETURN_NOT_OK_PREPEND(master-&gt;Restart(), &quot;Cannot restart master bound at: &quot; +</a>
<a name="ln384">                                               master-&gt;bound_rpc_hostport().ToString());</a>
<a name="ln385">    }</a>
<a name="ln386">  }</a>
<a name="ln387"> </a>
<a name="ln388">  for (const scoped_refptr&lt;ExternalTabletServer&gt;&amp; ts : tablet_servers_) {</a>
<a name="ln389">    if (ts-&gt;IsShutdown()) {</a>
<a name="ln390">      RETURN_NOT_OK_PREPEND(ts-&gt;Restart(), &quot;Cannot restart tablet server bound at: &quot; +</a>
<a name="ln391">                                           ts-&gt;bound_rpc_hostport().ToString());</a>
<a name="ln392">    }</a>
<a name="ln393">  }</a>
<a name="ln394"> </a>
<a name="ln395">  RETURN_NOT_OK(WaitForTabletServerCount(tablet_servers_.size(), kTabletServerRegistrationTimeout));</a>
<a name="ln396"> </a>
<a name="ln397">  running_ = true;</a>
<a name="ln398">  return Status::OK();</a>
<a name="ln399">}</a>
<a name="ln400"> </a>
<a name="ln401">string ExternalMiniCluster::GetBinaryPath(const string&amp; binary) const {</a>
<a name="ln402">  CHECK(!daemon_bin_path_.empty());</a>
<a name="ln403">  string default_path = JoinPathSegments(daemon_bin_path_, binary);</a>
<a name="ln404">  if (Env::Default()-&gt;FileExists(default_path)) {</a>
<a name="ln405">    return default_path;</a>
<a name="ln406">  }</a>
<a name="ln407"> </a>
<a name="ln408">  // In CLion-based builds we sometimes have to look for the binary in other directories.</a>
<a name="ln409">  string alternative_dir;</a>
<a name="ln410">  if (binary == &quot;yb-master&quot;) {</a>
<a name="ln411">    alternative_dir = &quot;master&quot;;</a>
<a name="ln412">  } else if (binary == &quot;yb-tserver&quot;) {</a>
<a name="ln413">    alternative_dir = &quot;tserver&quot;;</a>
<a name="ln414">  } else {</a>
<a name="ln415">    LOG(WARNING) &lt;&lt; &quot;Default path &quot; &lt;&lt; default_path &lt;&lt; &quot; for binary &quot; &lt;&lt; binary &lt;&lt;</a>
<a name="ln416">      &quot; does not exist, and no alternative directory is available for this binary&quot;;</a>
<a name="ln417">    return default_path;</a>
<a name="ln418">  }</a>
<a name="ln419"> </a>
<a name="ln420">  string alternative_path = JoinPathSegments(daemon_bin_path_,</a>
<a name="ln421">    &quot;../&quot; + alternative_dir + &quot;/&quot; + binary);</a>
<a name="ln422">  if (Env::Default()-&gt;FileExists(alternative_path)) {</a>
<a name="ln423">    LOG(INFO) &lt;&lt; &quot;Default path &quot; &lt;&lt; default_path &lt;&lt; &quot; for binary &quot; &lt;&lt; binary &lt;&lt;</a>
<a name="ln424">      &quot; does not exist, using alternative location: &quot; &lt;&lt; alternative_path;</a>
<a name="ln425">    return alternative_path;</a>
<a name="ln426">  } else {</a>
<a name="ln427">    LOG(WARNING) &lt;&lt; &quot;Neither &quot; &lt;&lt; default_path &lt;&lt; &quot; nor &quot; &lt;&lt; alternative_path &lt;&lt; &quot; exist&quot;;</a>
<a name="ln428">    return default_path;</a>
<a name="ln429">  }</a>
<a name="ln430">}</a>
<a name="ln431"> </a>
<a name="ln432">string ExternalMiniCluster::GetDataPath(const string&amp; daemon_id) const {</a>
<a name="ln433">  CHECK(!data_root_.empty());</a>
<a name="ln434">  return JoinPathSegments(data_root_, daemon_id);</a>
<a name="ln435">}</a>
<a name="ln436"> </a>
<a name="ln437">namespace {</a>
<a name="ln438">vector&lt;string&gt; SubstituteInFlags(const vector&lt;string&gt;&amp; orig_flags,</a>
<a name="ln439">                                 int index) {</a>
<a name="ln440">  string str_index = strings::Substitute(&quot;$0&quot;, index);</a>
<a name="ln441">  vector&lt;string&gt; ret;</a>
<a name="ln442">  for (const string&amp; orig : orig_flags) {</a>
<a name="ln443">    ret.push_back(StringReplace(orig, &quot;${index}&quot;, str_index, true));</a>
<a name="ln444">  }</a>
<a name="ln445">  return ret;</a>
<a name="ln446">}</a>
<a name="ln447"> </a>
<a name="ln448">}  // anonymous namespace</a>
<a name="ln449"> </a>
<a name="ln450">Result&lt;ExternalMaster *&gt; ExternalMiniCluster::StartMasterWithPeers(const string&amp; peer_addrs) {</a>
<a name="ln451">  uint16_t rpc_port = AllocateFreePort();</a>
<a name="ln452">  uint16_t http_port = AllocateFreePort();</a>
<a name="ln453">  LOG(INFO) &lt;&lt; &quot;Using auto-assigned rpc_port &quot; &lt;&lt; rpc_port &lt;&lt; &quot;; http_port &quot; &lt;&lt; http_port</a>
<a name="ln454">            &lt;&lt; &quot; to start a new external mini-cluster master with peers '&quot; &lt;&lt; peer_addrs &lt;&lt; &quot;'.&quot;;</a>
<a name="ln455"> </a>
<a name="ln456">  string addr = MasterAddressForPort(rpc_port);</a>
<a name="ln457">  string exe = GetBinaryPath(kMasterBinaryName);</a>
<a name="ln458"> </a>
<a name="ln459">  ExternalMaster* master =</a>
<a name="ln460">      new ExternalMaster(add_new_master_at_, messenger_, proxy_cache_.get(), exe,</a>
<a name="ln461">                         GetDataPath(Substitute(&quot;master-$0&quot;, add_new_master_at_)),</a>
<a name="ln462">                         opts_.extra_master_flags, addr, http_port, peer_addrs);</a>
<a name="ln463"> </a>
<a name="ln464">  RETURN_NOT_OK(master-&gt;Start());</a>
<a name="ln465"> </a>
<a name="ln466">  add_new_master_at_++;</a>
<a name="ln467">  return master;</a>
<a name="ln468">}</a>
<a name="ln469"> </a>
<a name="ln470">std::string ExternalMiniCluster::MasterAddressForPort(uint16_t port) const {</a>
<a name="ln471">  return Format(opts_.use_even_ips ? &quot;127.0.0.2:$0&quot; : &quot;127.0.0.1:$0&quot;, port);</a>
<a name="ln472">}</a>
<a name="ln473"> </a>
<a name="ln474">void ExternalMiniCluster::StartShellMaster(ExternalMaster** new_master) {</a>
<a name="ln475">  uint16_t rpc_port = AllocateFreePort();</a>
<a name="ln476">  uint16_t http_port = AllocateFreePort();</a>
<a name="ln477">  LOG(INFO) &lt;&lt; &quot;Using auto-assigned rpc_port &quot; &lt;&lt; rpc_port &lt;&lt; &quot;; http_port &quot; &lt;&lt; http_port</a>
<a name="ln478">            &lt;&lt; &quot; to start a new external mini-cluster shell master.&quot;;</a>
<a name="ln479"> </a>
<a name="ln480">  string addr = MasterAddressForPort(rpc_port);</a>
<a name="ln481"> </a>
<a name="ln482">  string exe = GetBinaryPath(kMasterBinaryName);</a>
<a name="ln483"> </a>
<a name="ln484">  ExternalMaster* master = new ExternalMaster(</a>
<a name="ln485">      add_new_master_at_,</a>
<a name="ln486">      messenger_,</a>
<a name="ln487">      proxy_cache_.get(),</a>
<a name="ln488">      exe,</a>
<a name="ln489">      GetDataPath(Substitute(&quot;master-$0&quot;, add_new_master_at_)),</a>
<a name="ln490">      opts_.extra_master_flags,</a>
<a name="ln491">      addr,</a>
<a name="ln492">      http_port,</a>
<a name="ln493">      &quot;&quot;);</a>
<a name="ln494"> </a>
<a name="ln495">  Status s = master-&gt;Start(true);</a>
<a name="ln496"> </a>
<a name="ln497">  if (!s.ok()) {</a>
<a name="ln498">    LOG(FATAL) &lt;&lt; Substitute(&quot;Unable to start 'shell' mode master at index $0, due to error $1.&quot;,</a>
<a name="ln499">                             add_new_master_at_, s.ToString());</a>
<a name="ln500">  }</a>
<a name="ln501"> </a>
<a name="ln502">  add_new_master_at_++;</a>
<a name="ln503">  *new_master = master;</a>
<a name="ln504">}</a>
<a name="ln505"> </a>
<a name="ln506">Status ExternalMiniCluster::CheckPortAndMasterSizes() const {</a>
<a name="ln507">  if (opts_.num_masters != masters_.size() ||</a>
<a name="ln508">      opts_.num_masters != opts_.master_rpc_ports.size()) {</a>
<a name="ln509">    string fatal_err_msg = Substitute(</a>
<a name="ln510">        &quot;Mismatch number of masters in options $0, compared to masters vector $1 or rpc ports $2&quot;,</a>
<a name="ln511">        opts_.num_masters, masters_.size(), opts_.master_rpc_ports.size());</a>
<a name="ln512">    LOG(FATAL) &lt;&lt; fatal_err_msg;</a>
<a name="ln513">  }</a>
<a name="ln514"> </a>
<a name="ln515">  return Status::OK();</a>
<a name="ln516">}</a>
<a name="ln517"> </a>
<a name="ln518">Status ExternalMiniCluster::AddMaster(ExternalMaster* master) {</a>
<a name="ln519">  auto iter = std::find_if(masters_.begin(), masters_.end(), MasterComparator(master));</a>
<a name="ln520"> </a>
<a name="ln521">  if (iter != masters_.end()) {</a>
<a name="ln522">    return STATUS(InvalidArgument, Substitute(</a>
<a name="ln523">        &quot;Master to be added '$0' already found in existing list of $1 masters.&quot;,</a>
<a name="ln524">        master-&gt;bound_rpc_hostport().ToString(), opts_.num_masters));</a>
<a name="ln525">  }</a>
<a name="ln526"> </a>
<a name="ln527">  RETURN_NOT_OK(opts_.AddPort(master-&gt;bound_rpc_hostport().port()));</a>
<a name="ln528">  masters_.push_back(master);</a>
<a name="ln529"> </a>
<a name="ln530">  RETURN_NOT_OK(CheckPortAndMasterSizes());</a>
<a name="ln531"> </a>
<a name="ln532">  return Status::OK();</a>
<a name="ln533">}</a>
<a name="ln534"> </a>
<a name="ln535">Status ExternalMiniCluster::RemoveMaster(ExternalMaster* master) {</a>
<a name="ln536">  auto iter = std::find_if(masters_.begin(), masters_.end(), MasterComparator(master));</a>
<a name="ln537"> </a>
<a name="ln538">  if (iter == masters_.end()) {</a>
<a name="ln539">    return STATUS(InvalidArgument, Substitute(</a>
<a name="ln540">        &quot;Master to be removed '$0' not found in existing list of $1 masters.&quot;,</a>
<a name="ln541">        master-&gt;bound_rpc_hostport().ToString(), opts_.num_masters));</a>
<a name="ln542">  }</a>
<a name="ln543"> </a>
<a name="ln544">  RETURN_NOT_OK(opts_.RemovePort(master-&gt;bound_rpc_hostport().port()));</a>
<a name="ln545">  masters_.erase(iter);</a>
<a name="ln546"> </a>
<a name="ln547">  RETURN_NOT_OK(CheckPortAndMasterSizes());</a>
<a name="ln548"> </a>
<a name="ln549">  return Status::OK();</a>
<a name="ln550">}</a>
<a name="ln551"> </a>
<a name="ln552">std::shared_ptr&lt;ConsensusServiceProxy&gt; ExternalMiniCluster::GetLeaderConsensusProxy() {</a>
<a name="ln553">  auto leader_master_sock = GetLeaderMaster()-&gt;bound_rpc_addr();</a>
<a name="ln554"> </a>
<a name="ln555">  return std::make_shared&lt;ConsensusServiceProxy&gt;(proxy_cache_.get(), leader_master_sock);</a>
<a name="ln556">}</a>
<a name="ln557"> </a>
<a name="ln558">std::shared_ptr&lt;ConsensusServiceProxy&gt; ExternalMiniCluster::GetConsensusProxy(</a>
<a name="ln559">    scoped_refptr&lt;ExternalMaster&gt; master) {</a>
<a name="ln560">  auto master_sock = master-&gt;bound_rpc_addr();</a>
<a name="ln561"> </a>
<a name="ln562">  return std::make_shared&lt;ConsensusServiceProxy&gt;(proxy_cache_.get(), master_sock);</a>
<a name="ln563">}</a>
<a name="ln564"> </a>
<a name="ln565">Status ExternalMiniCluster::StepDownMasterLeader(TabletServerErrorPB::Code* error_code) {</a>
<a name="ln566">  ExternalMaster* leader = GetLeaderMaster();</a>
<a name="ln567">  string leader_uuid = leader-&gt;uuid();</a>
<a name="ln568">  auto host_port = leader-&gt;bound_rpc_addr();</a>
<a name="ln569">  LeaderStepDownRequestPB lsd_req;</a>
<a name="ln570">  lsd_req.set_tablet_id(yb::master::kSysCatalogTabletId);</a>
<a name="ln571">  lsd_req.set_dest_uuid(leader_uuid);</a>
<a name="ln572">  LeaderStepDownResponsePB lsd_resp;</a>
<a name="ln573">  RpcController lsd_rpc;</a>
<a name="ln574">  lsd_rpc.set_timeout(opts_.timeout);</a>
<a name="ln575">  ConsensusServiceProxy proxy(proxy_cache_.get(), host_port);</a>
<a name="ln576">  RETURN_NOT_OK(proxy.LeaderStepDown(lsd_req, &amp;lsd_resp, &amp;lsd_rpc));</a>
<a name="ln577">  if (lsd_resp.has_error()) {</a>
<a name="ln578">    LOG(ERROR) &lt;&lt; &quot;LeaderStepDown for &quot; &lt;&lt; leader_uuid &lt;&lt; &quot; received error &quot;</a>
<a name="ln579">               &lt;&lt; lsd_resp.error().ShortDebugString();</a>
<a name="ln580">    *error_code = lsd_resp.error().code();</a>
<a name="ln581">    return StatusFromPB(lsd_resp.error().status());</a>
<a name="ln582">  }</a>
<a name="ln583"> </a>
<a name="ln584">  LOG(INFO) &lt;&lt; &quot;Leader at host/port '&quot; &lt;&lt; host_port &lt;&lt; &quot;' step down complete.&quot;;</a>
<a name="ln585"> </a>
<a name="ln586">  return Status::OK();</a>
<a name="ln587">}</a>
<a name="ln588"> </a>
<a name="ln589">Status ExternalMiniCluster::StepDownMasterLeaderAndWaitForNewLeader() {</a>
<a name="ln590">  ExternalMaster* leader = GetLeaderMaster();</a>
<a name="ln591">  string old_leader_uuid = leader-&gt;uuid();</a>
<a name="ln592">  string leader_uuid = old_leader_uuid;</a>
<a name="ln593">  TabletServerErrorPB::Code error_code = TabletServerErrorPB::UNKNOWN_ERROR;</a>
<a name="ln594">  LOG(INFO) &lt;&lt; &quot;Starting step down of leader &quot; &lt;&lt; leader-&gt;bound_rpc_addr();</a>
<a name="ln595"> </a>
<a name="ln596">  // while loop will not be needed once JIRA ENG-49 is fixed.</a>
<a name="ln597">  int iter = 1;</a>
<a name="ln598">  while (leader_uuid == old_leader_uuid) {</a>
<a name="ln599">    Status s = StepDownMasterLeader(&amp;error_code);</a>
<a name="ln600">    // If step down hits any error except not-ready, exit.</a>
<a name="ln601">    if (!s.ok() &amp;&amp; error_code != TabletServerErrorPB::LEADER_NOT_READY_TO_STEP_DOWN) {</a>
<a name="ln602">      return s;</a>
<a name="ln603">    }</a>
<a name="ln604">    sleep(3);  // TODO: add wait for election api.</a>
<a name="ln605">    leader = GetLeaderMaster();</a>
<a name="ln606">    leader_uuid = leader-&gt;uuid();</a>
<a name="ln607">    LOG(INFO) &lt;&lt; &quot;Got new leader &quot; &lt;&lt; leader-&gt;bound_rpc_addr() &lt;&lt; &quot;, iter=&quot; &lt;&lt; iter;</a>
<a name="ln608">    iter++;</a>
<a name="ln609">  }</a>
<a name="ln610"> </a>
<a name="ln611">  return Status::OK();</a>
<a name="ln612">}</a>
<a name="ln613"> </a>
<a name="ln614">Status ExternalMiniCluster::ChangeConfig(ExternalMaster* master,</a>
<a name="ln615">                                         ChangeConfigType type,</a>
<a name="ln616">                                         RaftPeerPB::MemberType member_type,</a>
<a name="ln617">                                         bool use_hostport) {</a>
<a name="ln618">  if (type != consensus::ADD_SERVER &amp;&amp; type != consensus::REMOVE_SERVER) {</a>
<a name="ln619">    return STATUS(InvalidArgument, Substitute(&quot;Invalid Change Config type $0&quot;, type));</a>
<a name="ln620">  }</a>
<a name="ln621"> </a>
<a name="ln622">  ChangeConfigRequestPB req;</a>
<a name="ln623">  ChangeConfigResponsePB resp;</a>
<a name="ln624">  rpc::RpcController rpc;</a>
<a name="ln625">  rpc.set_timeout(opts_.timeout);</a>
<a name="ln626"> </a>
<a name="ln627">  RaftPeerPB peer_pb;</a>
<a name="ln628">  peer_pb.set_permanent_uuid(use_hostport ? &quot;&quot; : master-&gt;uuid());</a>
<a name="ln629">  if (type == consensus::ADD_SERVER) {</a>
<a name="ln630">    peer_pb.set_member_type(member_type);</a>
<a name="ln631">  }</a>
<a name="ln632">  HostPortToPB(master-&gt;bound_rpc_hostport(), peer_pb.mutable_last_known_private_addr()-&gt;Add());</a>
<a name="ln633">  req.set_tablet_id(yb::master::kSysCatalogTabletId);</a>
<a name="ln634">  req.set_type(type);</a>
<a name="ln635">  req.set_use_host(use_hostport);</a>
<a name="ln636">  *req.mutable_server() = peer_pb;</a>
<a name="ln637"> </a>
<a name="ln638">  // There could be timing window where we found the leader host/port, but an election in the</a>
<a name="ln639">  // meantime could have made it step down. So we retry till we hit the leader correctly.</a>
<a name="ln640">  int num_attempts = 1;</a>
<a name="ln641">  while (true) {</a>
<a name="ln642">    ExternalMaster* leader = GetLeaderMaster();</a>
<a name="ln643">    auto leader_proxy = std::make_unique&lt;ConsensusServiceProxy&gt;(</a>
<a name="ln644">        proxy_cache_.get(), leader-&gt;bound_rpc_addr());</a>
<a name="ln645">    string leader_uuid = leader-&gt;uuid();</a>
<a name="ln646"> </a>
<a name="ln647">    if (type == consensus::REMOVE_SERVER &amp;&amp; leader_uuid == req.server().permanent_uuid()) {</a>
<a name="ln648">      RETURN_NOT_OK(StepDownMasterLeaderAndWaitForNewLeader());</a>
<a name="ln649">      leader = GetLeaderMaster();</a>
<a name="ln650">      leader_uuid = leader-&gt;uuid();</a>
<a name="ln651">      leader_proxy.reset(new ConsensusServiceProxy(proxy_cache_.get(), leader-&gt;bound_rpc_addr()));</a>
<a name="ln652">    }</a>
<a name="ln653"> </a>
<a name="ln654">    req.set_dest_uuid(leader_uuid);</a>
<a name="ln655">    RETURN_NOT_OK(leader_proxy-&gt;ChangeConfig(req, &amp;resp, &amp;rpc));</a>
<a name="ln656">    if (resp.has_error()) {</a>
<a name="ln657">      if (resp.error().code() != TabletServerErrorPB::NOT_THE_LEADER &amp;&amp;</a>
<a name="ln658">          resp.error().code() != TabletServerErrorPB::LEADER_NOT_READY_CHANGE_CONFIG) {</a>
<a name="ln659">        return STATUS(RuntimeError, Substitute(&quot;Change Config RPC to leader hit error: $0&quot;,</a>
<a name="ln660">                                               resp.error().ShortDebugString()));</a>
<a name="ln661">      }</a>
<a name="ln662">    } else {</a>
<a name="ln663">      break;</a>
<a name="ln664">    }</a>
<a name="ln665"> </a>
<a name="ln666">    // Need to retry as we come here with NOT_THE_LEADER.</a>
<a name="ln667">    if (num_attempts &gt;= kMaxRetryIterations) {</a>
<a name="ln668">      return STATUS(IllegalState,</a>
<a name="ln669">                    Substitute(&quot;Failed to complete ChangeConfig request '$0' even after maximum &quot;</a>
<a name="ln670">                               &quot;number of attempts. Last error '$1'&quot;,</a>
<a name="ln671">                               req.ShortDebugString(), resp.error().ShortDebugString()));</a>
<a name="ln672">    }</a>
<a name="ln673"> </a>
<a name="ln674">    SleepFor(MonoDelta::FromSeconds(1));</a>
<a name="ln675"> </a>
<a name="ln676">    LOG(INFO) &lt;&lt; &quot;Resp error '&quot; &lt;&lt; resp.error().ShortDebugString() &lt;&lt; &quot;', num=&quot; &lt;&lt; num_attempts</a>
<a name="ln677">              &lt;&lt; &quot;, retrying...&quot;;</a>
<a name="ln678"> </a>
<a name="ln679">    rpc.Reset();</a>
<a name="ln680">    num_attempts++;</a>
<a name="ln681">  }</a>
<a name="ln682"> </a>
<a name="ln683">  LOG(INFO) &lt;&lt; &quot;Master &quot; &lt;&lt; master-&gt;bound_rpc_hostport().ToString() &lt;&lt; &quot;, change type &quot;</a>
<a name="ln684">            &lt;&lt; type &lt;&lt; &quot; to &quot; &lt;&lt; masters_.size() &lt;&lt; &quot; masters.&quot;;</a>
<a name="ln685"> </a>
<a name="ln686">  if (type == consensus::ADD_SERVER) {</a>
<a name="ln687">    return AddMaster(master);</a>
<a name="ln688">  } else if (type == consensus::REMOVE_SERVER) {</a>
<a name="ln689">    return RemoveMaster(master);</a>
<a name="ln690">  }</a>
<a name="ln691"> </a>
<a name="ln692">  string err_msg = Substitute(&quot;Should not reach here - change type $0&quot;, type);</a>
<a name="ln693"> </a>
<a name="ln694">  LOG(FATAL) &lt;&lt; err_msg;</a>
<a name="ln695"> </a>
<a name="ln696">  // Satisfy the compiler with a return from here</a>
<a name="ln697">  return STATUS(RuntimeError, err_msg);</a>
<a name="ln698">}</a>
<a name="ln699"> </a>
<a name="ln700">// We look for the exact master match. Since it is possible to stop/restart master on</a>
<a name="ln701">// a given host/port, we do not want a stale master pointer input to match a newer master.</a>
<a name="ln702">int ExternalMiniCluster::GetIndexOfMaster(ExternalMaster* master) const {</a>
<a name="ln703">  for (int i = 0; i &lt; masters_.size(); i++) {</a>
<a name="ln704">    if (masters_[i].get() == master) {</a>
<a name="ln705">      return i;</a>
<a name="ln706">    }</a>
<a name="ln707">  }</a>
<a name="ln708">  return -1;</a>
<a name="ln709">}</a>
<a name="ln710"> </a>
<a name="ln711">Status ExternalMiniCluster::PingMaster(ExternalMaster* master) const {</a>
<a name="ln712">  int index = GetIndexOfMaster(master);</a>
<a name="ln713">  server::PingRequestPB req;</a>
<a name="ln714">  server::PingResponsePB resp;</a>
<a name="ln715">  std::shared_ptr&lt;server::GenericServiceProxy&gt; proxy =</a>
<a name="ln716">      index == -1 ? master_generic_proxy(master-&gt;bound_rpc_addr()) : master_generic_proxy(index);</a>
<a name="ln717">  rpc::RpcController rpc;</a>
<a name="ln718">  rpc.set_timeout(opts_.timeout);</a>
<a name="ln719">  return proxy-&gt;Ping(req, &amp;resp, &amp;rpc);</a>
<a name="ln720">}</a>
<a name="ln721"> </a>
<a name="ln722">Status ExternalMiniCluster::AddTServerToBlacklist(</a>
<a name="ln723">    ExternalMaster* master,</a>
<a name="ln724">    ExternalTabletServer* ts) {</a>
<a name="ln725">  GetMasterClusterConfigRequestPB config_req;</a>
<a name="ln726">  GetMasterClusterConfigResponsePB config_resp;</a>
<a name="ln727">  int index = GetIndexOfMaster(master);</a>
<a name="ln728"> </a>
<a name="ln729">  if (index == -1) {</a>
<a name="ln730">    return STATUS(InvalidArgument, Substitute(</a>
<a name="ln731">        &quot;Given master '$0' not in the current list of $1 masters.&quot;,</a>
<a name="ln732">        master-&gt;bound_rpc_hostport().ToString(), masters_.size()));</a>
<a name="ln733">  }</a>
<a name="ln734"> </a>
<a name="ln735">  std::shared_ptr&lt;MasterServiceProxy&gt; proxy = master_proxy(index);</a>
<a name="ln736">  rpc::RpcController rpc;</a>
<a name="ln737">  rpc.set_timeout(opts_.timeout);</a>
<a name="ln738">  RETURN_NOT_OK(proxy-&gt;GetMasterClusterConfig(config_req, &amp;config_resp, &amp;rpc));</a>
<a name="ln739">  if (config_resp.has_error()) {</a>
<a name="ln740">    return STATUS(RuntimeError, Substitute(</a>
<a name="ln741">        &quot;GetMasterClusterConfig RPC response hit error: $0&quot;,</a>
<a name="ln742">        config_resp.error().ShortDebugString()));</a>
<a name="ln743">  }</a>
<a name="ln744">  // Get current config</a>
<a name="ln745">  ChangeMasterClusterConfigRequestPB change_req;</a>
<a name="ln746">  SysClusterConfigEntryPB config = *config_resp.mutable_cluster_config();</a>
<a name="ln747">  // add tserver to blacklist</a>
<a name="ln748">  HostPortToPB(ts-&gt;bound_rpc_hostport(), config.mutable_server_blacklist()-&gt;mutable_hosts()-&gt;Add());</a>
<a name="ln749">  *change_req.mutable_cluster_config() = config;</a>
<a name="ln750">  ChangeMasterClusterConfigResponsePB change_resp;</a>
<a name="ln751">  rpc.Reset();</a>
<a name="ln752">  RETURN_NOT_OK(proxy-&gt;ChangeMasterClusterConfig(change_req, &amp;change_resp, &amp;rpc));</a>
<a name="ln753">  if (change_resp.has_error()) {</a>
<a name="ln754">    return STATUS(RuntimeError, Substitute(</a>
<a name="ln755">        &quot;ChangeMasterClusterConfig RPC response hit error: $0&quot;,</a>
<a name="ln756">        change_resp.error().ShortDebugString()));</a>
<a name="ln757">  }</a>
<a name="ln758"> </a>
<a name="ln759">  LOG(INFO) &lt;&lt; &quot;TServer at &quot; &lt;&lt; ts-&gt;bound_rpc_hostport().ToString()</a>
<a name="ln760">  &lt;&lt; &quot; was added to the blacklist&quot;;</a>
<a name="ln761"> </a>
<a name="ln762">  return Status::OK();</a>
<a name="ln763">}</a>
<a name="ln764"> </a>
<a name="ln765">Status ExternalMiniCluster::GetNumMastersAsSeenBy(ExternalMaster* master, int* num_peers) {</a>
<a name="ln766">  ListMastersRequestPB list_req;</a>
<a name="ln767">  ListMastersResponsePB list_resp;</a>
<a name="ln768">  int index = GetIndexOfMaster(master);</a>
<a name="ln769"> </a>
<a name="ln770">  if (index == -1) {</a>
<a name="ln771">    return STATUS(InvalidArgument, Substitute(</a>
<a name="ln772">        &quot;Given master '$0' not in the current list of $1 masters.&quot;,</a>
<a name="ln773">        master-&gt;bound_rpc_hostport().ToString(), masters_.size()));</a>
<a name="ln774">  }</a>
<a name="ln775"> </a>
<a name="ln776">  std::shared_ptr&lt;MasterServiceProxy&gt; proxy = master_proxy(index);</a>
<a name="ln777">  rpc::RpcController rpc;</a>
<a name="ln778">  rpc.set_timeout(opts_.timeout);</a>
<a name="ln779">  RETURN_NOT_OK(proxy-&gt;ListMasters(list_req, &amp;list_resp, &amp;rpc));</a>
<a name="ln780">  if (list_resp.has_error()) {</a>
<a name="ln781">    return STATUS(RuntimeError, Substitute(</a>
<a name="ln782">        &quot;List Masters RPC response hit error: $0&quot;, list_resp.error().ShortDebugString()));</a>
<a name="ln783">  }</a>
<a name="ln784"> </a>
<a name="ln785">  LOG(INFO) &lt;&lt; &quot;List Masters for master at index &quot; &lt;&lt; index</a>
<a name="ln786">            &lt;&lt; &quot; got &quot; &lt;&lt; list_resp.masters_size() &lt;&lt; &quot; peers&quot;;</a>
<a name="ln787"> </a>
<a name="ln788">  *num_peers = list_resp.masters_size();</a>
<a name="ln789"> </a>
<a name="ln790">  return Status::OK();</a>
<a name="ln791">}</a>
<a name="ln792"> </a>
<a name="ln793">Status ExternalMiniCluster::WaitForLeaderCommitTermAdvance() {</a>
<a name="ln794">  OpIdPB start_opid;</a>
<a name="ln795">  RETURN_NOT_OK(GetLastOpIdForLeader(&amp;start_opid));</a>
<a name="ln796">  LOG(INFO) &lt;&lt; &quot;Start OPID : &quot; &lt;&lt; start_opid.ShortDebugString();</a>
<a name="ln797"> </a>
<a name="ln798">  // Need not do any wait if it is a restart case - so the commit term will be &gt; 0.</a>
<a name="ln799">  if (start_opid.term() != 0)</a>
<a name="ln800">    return Status::OK();</a>
<a name="ln801"> </a>
<a name="ln802">  MonoTime now = MonoTime::Now();</a>
<a name="ln803">  MonoTime deadline = now;</a>
<a name="ln804">  deadline.AddDelta(opts_.timeout);</a>
<a name="ln805">  auto opid = start_opid;</a>
<a name="ln806"> </a>
<a name="ln807">  for (int i = 1; now.ComesBefore(deadline); ++i) {</a>
<a name="ln808">    if (opid.term() &gt; start_opid.term()) {</a>
<a name="ln809">      LOG(INFO) &lt;&lt; &quot;Final OPID: &quot; &lt;&lt; opid.ShortDebugString() &lt;&lt; &quot; after &quot;</a>
<a name="ln810">                &lt;&lt; i &lt;&lt; &quot; iterations.&quot;;</a>
<a name="ln811"> </a>
<a name="ln812">      return Status::OK();</a>
<a name="ln813">    }</a>
<a name="ln814">    SleepFor(MonoDelta::FromMilliseconds(min(i, 10)));</a>
<a name="ln815">    RETURN_NOT_OK(GetLastOpIdForLeader(&amp;opid));</a>
<a name="ln816">    now = MonoTime::Now();</a>
<a name="ln817">  }</a>
<a name="ln818"> </a>
<a name="ln819">  return STATUS(TimedOut, Substitute(&quot;Term did not advance from $0.&quot;, start_opid.term()));</a>
<a name="ln820">}</a>
<a name="ln821"> </a>
<a name="ln822">Status ExternalMiniCluster::GetLastOpIdForEachMasterPeer(</a>
<a name="ln823">    const MonoDelta&amp; timeout,</a>
<a name="ln824">    consensus::OpIdType opid_type,</a>
<a name="ln825">    vector&lt;OpIdPB&gt;* op_ids) {</a>
<a name="ln826">  GetLastOpIdRequestPB opid_req;</a>
<a name="ln827">  GetLastOpIdResponsePB opid_resp;</a>
<a name="ln828">  opid_req.set_tablet_id(yb::master::kSysCatalogTabletId);</a>
<a name="ln829">  RpcController controller;</a>
<a name="ln830">  controller.set_timeout(timeout);</a>
<a name="ln831"> </a>
<a name="ln832">  op_ids-&gt;clear();</a>
<a name="ln833">  for (scoped_refptr&lt;ExternalMaster&gt; master : masters_) {</a>
<a name="ln834">    opid_req.set_dest_uuid(master-&gt;uuid());</a>
<a name="ln835">    opid_req.set_opid_type(opid_type);</a>
<a name="ln836">    RETURN_NOT_OK_PREPEND(</a>
<a name="ln837">        GetConsensusProxy(master)-&gt;GetLastOpId(opid_req, &amp;opid_resp, &amp;controller),</a>
<a name="ln838">        Substitute(&quot;Failed to fetch last op id from $0&quot;, master-&gt;bound_rpc_hostport().port()));</a>
<a name="ln839">    op_ids-&gt;push_back(opid_resp.opid());</a>
<a name="ln840">    controller.Reset();</a>
<a name="ln841">  }</a>
<a name="ln842"> </a>
<a name="ln843">  return Status::OK();</a>
<a name="ln844">}</a>
<a name="ln845"> </a>
<a name="ln846">Status ExternalMiniCluster::WaitForMastersToCommitUpTo(int target_index) {</a>
<a name="ln847">  auto deadline = CoarseMonoClock::Now() + opts_.timeout.ToSteadyDuration();</a>
<a name="ln848"> </a>
<a name="ln849">  for (int i = 1;; i++) {</a>
<a name="ln850">    vector&lt;OpIdPB&gt; ids;</a>
<a name="ln851">    Status s = GetLastOpIdForEachMasterPeer(opts_.timeout, consensus::COMMITTED_OPID, &amp;ids);</a>
<a name="ln852"> </a>
<a name="ln853">    if (s.ok()) {</a>
<a name="ln854">      bool any_behind = false;</a>
<a name="ln855">      for (const auto&amp; id : ids) {</a>
<a name="ln856">        if (id.index() &lt; target_index) {</a>
<a name="ln857">          any_behind = true;</a>
<a name="ln858">          break;</a>
<a name="ln859">        }</a>
<a name="ln860">      }</a>
<a name="ln861">      if (!any_behind) {</a>
<a name="ln862">        LOG(INFO) &lt;&lt; &quot;Committed up to &quot; &lt;&lt; target_index;</a>
<a name="ln863">        return Status::OK();</a>
<a name="ln864">      }</a>
<a name="ln865">    } else {</a>
<a name="ln866">      LOG(WARNING) &lt;&lt; &quot;Got error getting last opid for each replica: &quot; &lt;&lt; s.ToString();</a>
<a name="ln867">    }</a>
<a name="ln868"> </a>
<a name="ln869">    if (CoarseMonoClock::Now() &gt;= deadline) {</a>
<a name="ln870">      if (!s.ok()) {</a>
<a name="ln871">        return s;</a>
<a name="ln872">      }</a>
<a name="ln873"> </a>
<a name="ln874">      return STATUS_FORMAT(TimedOut,</a>
<a name="ln875">                           &quot;Index $0 not available on all replicas after $1. &quot;,</a>
<a name="ln876">                           target_index,</a>
<a name="ln877">                           opts_.timeout);</a>
<a name="ln878">    }</a>
<a name="ln879"> </a>
<a name="ln880">    SleepFor(MonoDelta::FromMilliseconds(min(i * 100, 1000)));</a>
<a name="ln881">  }</a>
<a name="ln882">}</a>
<a name="ln883"> </a>
<a name="ln884">Status ExternalMiniCluster::GetIsMasterLeaderServiceReady(ExternalMaster* master) {</a>
<a name="ln885">  IsMasterLeaderReadyRequestPB req;</a>
<a name="ln886">  IsMasterLeaderReadyResponsePB resp;</a>
<a name="ln887">  int index = GetIndexOfMaster(master);</a>
<a name="ln888"> </a>
<a name="ln889">  if (index == -1) {</a>
<a name="ln890">    return STATUS(InvalidArgument, Substitute(</a>
<a name="ln891">        &quot;Given master '$0' not in the current list of $1 masters.&quot;,</a>
<a name="ln892">        master-&gt;bound_rpc_hostport().ToString(), masters_.size()));</a>
<a name="ln893">  }</a>
<a name="ln894"> </a>
<a name="ln895">  std::shared_ptr&lt;MasterServiceProxy&gt; proxy = master_proxy(index);</a>
<a name="ln896">  rpc::RpcController rpc;</a>
<a name="ln897">  rpc.set_timeout(opts_.timeout);</a>
<a name="ln898">  RETURN_NOT_OK(proxy-&gt;IsMasterLeaderServiceReady(req, &amp;resp, &amp;rpc));</a>
<a name="ln899">  if (resp.has_error()) {</a>
<a name="ln900">    return STATUS(RuntimeError, Substitute(</a>
<a name="ln901">        &quot;Is master ready RPC response hit error: $0&quot;, resp.error().ShortDebugString()));</a>
<a name="ln902">  }</a>
<a name="ln903"> </a>
<a name="ln904">  return Status::OK();</a>
<a name="ln905">}</a>
<a name="ln906"> </a>
<a name="ln907">Status ExternalMiniCluster::GetLastOpIdForLeader(OpIdPB* opid) {</a>
<a name="ln908">  ExternalMaster* leader = GetLeaderMaster();</a>
<a name="ln909">  auto leader_master_sock = leader-&gt;bound_rpc_addr();</a>
<a name="ln910">  std::shared_ptr&lt;ConsensusServiceProxy&gt; leader_proxy =</a>
<a name="ln911">    std::make_shared&lt;ConsensusServiceProxy&gt;(proxy_cache_.get(), leader_master_sock);</a>
<a name="ln912"> </a>
<a name="ln913">  RETURN_NOT_OK(itest::GetLastOpIdForMasterReplica(</a>
<a name="ln914">      leader_proxy,</a>
<a name="ln915">      yb::master::kSysCatalogTabletId,</a>
<a name="ln916">      leader-&gt;uuid(),</a>
<a name="ln917">      consensus::COMMITTED_OPID,</a>
<a name="ln918">      opts_.timeout,</a>
<a name="ln919">      opid));</a>
<a name="ln920"> </a>
<a name="ln921">  return Status::OK();</a>
<a name="ln922">}</a>
<a name="ln923"> </a>
<a name="ln924">string ExternalMiniCluster::GetMasterAddresses() const {</a>
<a name="ln925">  string peer_addrs = &quot;&quot;;</a>
<a name="ln926">  for (int i = 0; i &lt; opts_.num_masters; i++) {</a>
<a name="ln927">    if (!peer_addrs.empty()) {</a>
<a name="ln928">      peer_addrs += &quot;,&quot;;</a>
<a name="ln929">    }</a>
<a name="ln930">    peer_addrs += MasterAddressForPort(opts_.master_rpc_ports[i]);</a>
<a name="ln931">  }</a>
<a name="ln932">  return peer_addrs;</a>
<a name="ln933">}</a>
<a name="ln934"> </a>
<a name="ln935">string ExternalMiniCluster::GetTabletServerAddresses() const {</a>
<a name="ln936">  string peer_addrs = &quot;&quot;;</a>
<a name="ln937">  for (const auto&amp; ts : tablet_servers_) {</a>
<a name="ln938">    if (!peer_addrs.empty()) {</a>
<a name="ln939">      peer_addrs += &quot;,&quot;;</a>
<a name="ln940">    }</a>
<a name="ln941">    peer_addrs += HostPortToString(ts-&gt;bind_host(), ts-&gt;rpc_port());</a>
<a name="ln942">  }</a>
<a name="ln943">  return peer_addrs;</a>
<a name="ln944">}</a>
<a name="ln945"> </a>
<a name="ln946">Status ExternalMiniCluster::StartMasters() {</a>
<a name="ln947">  int num_masters = opts_.num_masters;</a>
<a name="ln948"> </a>
<a name="ln949">  if (opts_.master_rpc_ports.size() != num_masters) {</a>
<a name="ln950">    LOG(FATAL) &lt;&lt; num_masters &lt;&lt; &quot; masters requested, but &quot; &lt;&lt;</a>
<a name="ln951">        opts_.master_rpc_ports.size() &lt;&lt; &quot; ports specified in 'master_rpc_ports'&quot;;</a>
<a name="ln952">  }</a>
<a name="ln953"> </a>
<a name="ln954">  for (int i = 0; i &lt; opts_.master_rpc_ports.size(); ++i) {</a>
<a name="ln955">    if (opts_.master_rpc_ports[i] == 0) {</a>
<a name="ln956">      opts_.master_rpc_ports[i] = AllocateFreePort();</a>
<a name="ln957">      LOG(INFO) &lt;&lt; &quot;Using an auto-assigned port &quot; &lt;&lt; opts_.master_rpc_ports[i]</a>
<a name="ln958">        &lt;&lt; &quot; to start an external mini-cluster master&quot;;</a>
<a name="ln959">    }</a>
<a name="ln960">  }</a>
<a name="ln961"> </a>
<a name="ln962">  vector&lt;string&gt; peer_addrs;</a>
<a name="ln963">  for (int i = 0; i &lt; num_masters; i++) {</a>
<a name="ln964">    string addr = MasterAddressForPort(opts_.master_rpc_ports[i]);</a>
<a name="ln965">    peer_addrs.push_back(addr);</a>
<a name="ln966">  }</a>
<a name="ln967">  string peer_addrs_str = JoinStrings(peer_addrs, &quot;,&quot;);</a>
<a name="ln968">  vector&lt;string&gt; flags = opts_.extra_master_flags;</a>
<a name="ln969">  flags.push_back(&quot;--enable_leader_failure_detection=true&quot;);</a>
<a name="ln970">  if (opts_.enable_ysql) {</a>
<a name="ln971">    flags.push_back(&quot;--enable_ysql=true&quot;);</a>
<a name="ln972">    flags.push_back(&quot;--master_auto_run_initdb&quot;);</a>
<a name="ln973">  } else {</a>
<a name="ln974">    flags.push_back(&quot;--enable_ysql=false&quot;);</a>
<a name="ln975">  }</a>
<a name="ln976">  string exe = GetBinaryPath(kMasterBinaryName);</a>
<a name="ln977"> </a>
<a name="ln978">  // Start the masters.</a>
<a name="ln979">  for (int i = 0; i &lt; num_masters; i++) {</a>
<a name="ln980">    uint16_t http_port = AllocateFreePort();</a>
<a name="ln981">    scoped_refptr&lt;ExternalMaster&gt; peer =</a>
<a name="ln982">      new ExternalMaster(</a>
<a name="ln983">        i,</a>
<a name="ln984">        messenger_,</a>
<a name="ln985">        proxy_cache_.get(),</a>
<a name="ln986">        exe,</a>
<a name="ln987">        GetDataPath(Substitute(&quot;master-$0&quot;, i)),</a>
<a name="ln988">        SubstituteInFlags(flags, i),</a>
<a name="ln989">        peer_addrs[i],</a>
<a name="ln990">        http_port,</a>
<a name="ln991">        peer_addrs_str);</a>
<a name="ln992">    RETURN_NOT_OK_PREPEND(peer-&gt;Start(),</a>
<a name="ln993">                          Substitute(&quot;Unable to start Master at index $0&quot;, i));</a>
<a name="ln994">    masters_.push_back(peer);</a>
<a name="ln995">  }</a>
<a name="ln996"> </a>
<a name="ln997">  if (opts_.enable_ysql) {</a>
<a name="ln998">    RETURN_NOT_OK(WaitForInitDb());</a>
<a name="ln999">  }</a>
<a name="ln1000">  return Status::OK();</a>
<a name="ln1001">}</a>
<a name="ln1002"> </a>
<a name="ln1003">Status ExternalMiniCluster::WaitForInitDb() {</a>
<a name="ln1004">  const auto start_time = std::chrono::steady_clock::now();</a>
<a name="ln1005">  const auto kTimeout = NonTsanVsTsan(900s, 1800s);</a>
<a name="ln1006">  while (true) {</a>
<a name="ln1007">    for (int i = 0; i &lt; opts_.num_masters; i++) {</a>
<a name="ln1008">      auto elapsed_time = std::chrono::steady_clock::now() - start_time;</a>
<a name="ln1009">      if (elapsed_time &gt; kTimeout) {</a>
<a name="ln1010">        return STATUS_FORMAT(</a>
<a name="ln1011">            TimedOut,</a>
<a name="ln1012">            &quot;Timed out while waiting for initdb to complete: elapsed time is $0, timeout is $1&quot;,</a>
<a name="ln1013">            elapsed_time, kTimeout);</a>
<a name="ln1014">      }</a>
<a name="ln1015">      std::shared_ptr&lt;MasterServiceProxy&gt; proxy = master_proxy(i);</a>
<a name="ln1016">      rpc::RpcController rpc;</a>
<a name="ln1017">      rpc.set_timeout(opts_.timeout);</a>
<a name="ln1018">      IsInitDbDoneRequestPB req;</a>
<a name="ln1019">      IsInitDbDoneResponsePB resp;</a>
<a name="ln1020">      RETURN_NOT_OK(proxy-&gt;IsInitDbDone(req, &amp;resp, &amp;rpc));</a>
<a name="ln1021">      if (resp.has_error() &amp;&amp;</a>
<a name="ln1022">          resp.error().code() != master::MasterErrorPB::NOT_THE_LEADER) {</a>
<a name="ln1023"> </a>
<a name="ln1024">        return STATUS(RuntimeError, Substitute(</a>
<a name="ln1025">            &quot;IsInitDbDone RPC response hit error: $0&quot;,</a>
<a name="ln1026">            resp.error().ShortDebugString()));</a>
<a name="ln1027">      }</a>
<a name="ln1028">      if (resp.done()) {</a>
<a name="ln1029">        if (resp.has_initdb_error() &amp;&amp; !resp.initdb_error().empty()) {</a>
<a name="ln1030">          LOG(ERROR) &lt;&lt; &quot;master reported an initdb error: &quot; &lt;&lt; resp.initdb_error();</a>
<a name="ln1031">          return STATUS(RuntimeError, &quot;initdb failed: &quot; + resp.initdb_error());</a>
<a name="ln1032">        }</a>
<a name="ln1033">        LOG(INFO) &lt;&lt; &quot;master indicated that initdb is done&quot;;</a>
<a name="ln1034">        return Status::OK();</a>
<a name="ln1035">      }</a>
<a name="ln1036">    }</a>
<a name="ln1037">    std::this_thread::sleep_for(500ms);</a>
<a name="ln1038">  }</a>
<a name="ln1039">}</a>
<a name="ln1040"> </a>
<a name="ln1041">string ExternalMiniCluster::GetBindIpForTabletServer(int index) const {</a>
<a name="ln1042">  if (opts_.use_even_ips) {</a>
<a name="ln1043">    return Substitute(&quot;127.0.0.$0&quot;, (index + 1) * 2);</a>
<a name="ln1044">  } else if (opts_.bind_to_unique_loopback_addresses) {</a>
<a name="ln1045">#if defined(__APPLE__)</a>
<a name="ln1046">    return Substitute(&quot;127.0.0.$0&quot;, index + 1); // Use default 127.0.0.x IPs.</a>
<a name="ln1047">#else</a>
<a name="ln1048">    const pid_t p = getpid();</a>
<a name="ln1049">    return Substitute(&quot;127.$0.$1.$2&quot;, (p &gt;&gt; 8) &amp; 0xff, p &amp; 0xff, index);</a>
<a name="ln1050">#endif</a>
<a name="ln1051">  } else {</a>
<a name="ln1052">    return &quot;127.0.0.1&quot;;</a>
<a name="ln1053">  }</a>
<a name="ln1054">}</a>
<a name="ln1055"> </a>
<a name="ln1056">Status ExternalMiniCluster::AddTabletServer(</a>
<a name="ln1057">    bool start_cql_proxy, const std::vector&lt;std::string&gt;&amp; extra_flags) {</a>
<a name="ln1058">  CHECK(GetLeaderMaster() != nullptr)</a>
<a name="ln1059">      &lt;&lt; &quot;Must have started at least 1 master before adding tablet servers&quot;;</a>
<a name="ln1060"> </a>
<a name="ln1061">  int idx = tablet_servers_.size();</a>
<a name="ln1062"> </a>
<a name="ln1063">  string exe = GetBinaryPath(kTabletServerBinaryName);</a>
<a name="ln1064">  vector&lt;HostPort&gt; master_hostports;</a>
<a name="ln1065">  for (int i = 0; i &lt; num_masters(); i++) {</a>
<a name="ln1066">    master_hostports.push_back(DCHECK_NOTNULL(master(i))-&gt;bound_rpc_hostport());</a>
<a name="ln1067">  }</a>
<a name="ln1068"> </a>
<a name="ln1069">  uint16_t ts_rpc_port = 0;</a>
<a name="ln1070">  uint16_t ts_http_port = 0;</a>
<a name="ln1071">  uint16_t redis_rpc_port = 0;</a>
<a name="ln1072">  uint16_t redis_http_port = 0;</a>
<a name="ln1073">  uint16_t cql_rpc_port = 0;</a>
<a name="ln1074">  uint16_t cql_http_port = 0;</a>
<a name="ln1075">  uint16_t pgsql_rpc_port = 0;</a>
<a name="ln1076">  uint16_t pgsql_http_port = 0;</a>
<a name="ln1077"> </a>
<a name="ln1078">  if (idx &gt; 0 &amp;&amp; opts_.use_same_ts_ports &amp;&amp; opts_.bind_to_unique_loopback_addresses) {</a>
<a name="ln1079">    const scoped_refptr&lt;ExternalTabletServer&gt;&amp; first_ts = tablet_servers_[0];</a>
<a name="ln1080">    ts_rpc_port = first_ts-&gt;rpc_port();</a>
<a name="ln1081">    ts_http_port = first_ts-&gt;http_port();</a>
<a name="ln1082">    redis_rpc_port = first_ts-&gt;redis_rpc_port();</a>
<a name="ln1083">    redis_http_port = first_ts-&gt;redis_http_port();</a>
<a name="ln1084">    cql_rpc_port = first_ts-&gt;cql_rpc_port();</a>
<a name="ln1085">    cql_http_port = first_ts-&gt;cql_http_port();</a>
<a name="ln1086">    pgsql_rpc_port = first_ts-&gt;pgsql_rpc_port();</a>
<a name="ln1087">    pgsql_http_port = first_ts-&gt;pgsql_http_port();</a>
<a name="ln1088">  } else {</a>
<a name="ln1089">    ts_rpc_port = AllocateFreePort();</a>
<a name="ln1090">    ts_http_port = AllocateFreePort();</a>
<a name="ln1091">    redis_rpc_port = AllocateFreePort();</a>
<a name="ln1092">    redis_http_port = AllocateFreePort();</a>
<a name="ln1093">    cql_rpc_port = AllocateFreePort();</a>
<a name="ln1094">    cql_http_port = AllocateFreePort();</a>
<a name="ln1095">    pgsql_rpc_port = AllocateFreePort();</a>
<a name="ln1096">    pgsql_http_port = AllocateFreePort();</a>
<a name="ln1097">  }</a>
<a name="ln1098"> </a>
<a name="ln1099">  vector&lt;string&gt; flags = opts_.extra_tserver_flags;</a>
<a name="ln1100">  if (opts_.enable_ysql) {</a>
<a name="ln1101">    flags.push_back(&quot;--enable_ysql=true&quot;);</a>
<a name="ln1102">  } else {</a>
<a name="ln1103">    flags.push_back(&quot;--enable_ysql=false&quot;);</a>
<a name="ln1104">  }</a>
<a name="ln1105">  flags.insert(flags.end(), extra_flags.begin(), extra_flags.end());</a>
<a name="ln1106"> </a>
<a name="ln1107">  scoped_refptr&lt;ExternalTabletServer&gt; ts = new ExternalTabletServer(</a>
<a name="ln1108">      idx, messenger_, proxy_cache_.get(), exe, GetDataPath(Substitute(&quot;ts-$0&quot;, idx + 1)),</a>
<a name="ln1109">      GetBindIpForTabletServer(idx), ts_rpc_port, ts_http_port, redis_rpc_port, redis_http_port,</a>
<a name="ln1110">      cql_rpc_port, cql_http_port, pgsql_rpc_port, pgsql_http_port, master_hostports,</a>
<a name="ln1111">      SubstituteInFlags(flags, idx));</a>
<a name="ln1112">  RETURN_NOT_OK(ts-&gt;Start(start_cql_proxy));</a>
<a name="ln1113">  tablet_servers_.push_back(ts);</a>
<a name="ln1114">  return Status::OK();</a>
<a name="ln1115">}</a>
<a name="ln1116"> </a>
<a name="ln1117">Status ExternalMiniCluster::WaitForTabletServerCount(int count, const MonoDelta&amp; timeout) {</a>
<a name="ln1118">  MonoTime deadline = MonoTime::Now();</a>
<a name="ln1119">  deadline.AddDelta(timeout);</a>
<a name="ln1120"> </a>
<a name="ln1121">  std::vector&lt;scoped_refptr&lt;ExternalTabletServer&gt;&gt; last_unmatched = tablet_servers_;</a>
<a name="ln1122">  bool had_leader = false;</a>
<a name="ln1123"> </a>
<a name="ln1124">  while (true) {</a>
<a name="ln1125">    MonoDelta remaining = deadline - MonoTime::Now();</a>
<a name="ln1126">    if (remaining.ToSeconds() &lt; 0) {</a>
<a name="ln1127">      std::vector&lt;std::string&gt; unmatched_uuids;</a>
<a name="ln1128">      unmatched_uuids.reserve(last_unmatched.size());</a>
<a name="ln1129">      for (const auto&amp; server : last_unmatched) {</a>
<a name="ln1130">        unmatched_uuids.push_back(server-&gt;instance_id().permanent_uuid());</a>
<a name="ln1131">      }</a>
<a name="ln1132">      if (!had_leader) {</a>
<a name="ln1133">        return STATUS(TimedOut, &quot;Does not have active master leader to check tserver registration&quot;);</a>
<a name="ln1134">      }</a>
<a name="ln1135">      return STATUS_FORMAT(TimedOut, &quot;$0 TS(s) never registered with master (not registered $1)&quot;,</a>
<a name="ln1136">                           count, unmatched_uuids);</a>
<a name="ln1137">    }</a>
<a name="ln1138"> </a>
<a name="ln1139">    // We should give some time for RPC to proceed, otherwise all requests would fail.</a>
<a name="ln1140">    remaining = std::max&lt;MonoDelta&gt;(remaining, 250ms);</a>
<a name="ln1141"> </a>
<a name="ln1142">    last_unmatched = tablet_servers_;</a>
<a name="ln1143">    had_leader = false;</a>
<a name="ln1144">    for (int i = 0; i &lt; masters_.size(); i++) {</a>
<a name="ln1145">      master::ListTabletServersRequestPB req;</a>
<a name="ln1146">      master::ListTabletServersResponsePB resp;</a>
<a name="ln1147">      rpc::RpcController rpc;</a>
<a name="ln1148">      rpc.set_timeout(remaining);</a>
<a name="ln1149">      auto status = master_proxy(i)-&gt;ListTabletServers(req, &amp;resp, &amp;rpc);</a>
<a name="ln1150">      LOG_IF(WARNING, !status.ok()) &lt;&lt; &quot;ListTabletServers failed: &quot; &lt;&lt; status;</a>
<a name="ln1151">      if (!status.ok() || resp.has_error()) {</a>
<a name="ln1152">        continue;</a>
<a name="ln1153">      }</a>
<a name="ln1154">      had_leader = true;</a>
<a name="ln1155">      // ListTabletServers() may return servers that are no longer online.</a>
<a name="ln1156">      // Do a second step of verification to verify that the descs that we got</a>
<a name="ln1157">      // are aligned (same uuid/seqno) with the TSs that we have in the cluster.</a>
<a name="ln1158">      int match_count = 0;</a>
<a name="ln1159">      for (const master::ListTabletServersResponsePB_Entry&amp; e : resp.servers()) {</a>
<a name="ln1160">        for (auto it = last_unmatched.begin(); it != last_unmatched.end(); ++it) {</a>
<a name="ln1161">          if ((**it).instance_id().permanent_uuid() == e.instance_id().permanent_uuid() &amp;&amp;</a>
<a name="ln1162">              (**it).instance_id().instance_seqno() == e.instance_id().instance_seqno()) {</a>
<a name="ln1163">            match_count++;</a>
<a name="ln1164">            last_unmatched.erase(it);</a>
<a name="ln1165">            break;</a>
<a name="ln1166">          }</a>
<a name="ln1167">        }</a>
<a name="ln1168">      }</a>
<a name="ln1169">      if (match_count &gt;= count) {</a>
<a name="ln1170">        LOG(INFO) &lt;&lt; count &lt;&lt; &quot; TS(s) registered with Master&quot;;</a>
<a name="ln1171">        return Status::OK();</a>
<a name="ln1172">      }</a>
<a name="ln1173">    }</a>
<a name="ln1174">    SleepFor(MonoDelta::FromMilliseconds(1));</a>
<a name="ln1175">  }</a>
<a name="ln1176">}</a>
<a name="ln1177"> </a>
<a name="ln1178">void ExternalMiniCluster::AssertNoCrashes() {</a>
<a name="ln1179">  vector&lt;ExternalDaemon*&gt; daemons = this-&gt;daemons();</a>
<a name="ln1180">  for (ExternalDaemon* d : daemons) {</a>
<a name="ln1181">    if (d-&gt;IsShutdown()) continue;</a>
<a name="ln1182">    EXPECT_TRUE(d-&gt;IsProcessAlive()) &lt;&lt; &quot;At least one process crashed. viz: &quot;</a>
<a name="ln1183">                                     &lt;&lt; d-&gt;id();</a>
<a name="ln1184">  }</a>
<a name="ln1185">}</a>
<a name="ln1186"> </a>
<a name="ln1187">Result&lt;std::vector&lt;std::string&gt;&gt; ExternalMiniCluster::GetTabletIds(ExternalTabletServer* ts) {</a>
<a name="ln1188">  TabletServerServiceProxy proxy(proxy_cache_.get(), ts-&gt;bound_rpc_addr());</a>
<a name="ln1189">  ListTabletsRequestPB req;</a>
<a name="ln1190">  ListTabletsResponsePB resp;</a>
<a name="ln1191"> </a>
<a name="ln1192">  rpc::RpcController rpc;</a>
<a name="ln1193">  rpc.set_timeout(MonoDelta::FromSeconds(10));</a>
<a name="ln1194">  RETURN_NOT_OK(proxy.ListTablets(req, &amp;resp, &amp;rpc));</a>
<a name="ln1195">  if (resp.has_error()) {</a>
<a name="ln1196">    return StatusFromPB(resp.error().status());</a>
<a name="ln1197">  }</a>
<a name="ln1198"> </a>
<a name="ln1199">  std::vector&lt;std::string&gt; result;</a>
<a name="ln1200">  result.reserve(resp.status_and_schema().size());</a>
<a name="ln1201">  for (const StatusAndSchemaPB&amp; status : resp.status_and_schema()) {</a>
<a name="ln1202">    result.push_back(status.tablet_status().tablet_id());</a>
<a name="ln1203">  }</a>
<a name="ln1204"> </a>
<a name="ln1205">  return result;</a>
<a name="ln1206">}</a>
<a name="ln1207"> </a>
<a name="ln1208">Status ExternalMiniCluster::WaitForTabletsRunning(ExternalTabletServer* ts,</a>
<a name="ln1209">                                                  const MonoDelta&amp; timeout) {</a>
<a name="ln1210">  TabletServerServiceProxy proxy(proxy_cache_.get(), ts-&gt;bound_rpc_addr());</a>
<a name="ln1211">  ListTabletsRequestPB req;</a>
<a name="ln1212">  ListTabletsResponsePB resp;</a>
<a name="ln1213"> </a>
<a name="ln1214">  MonoTime deadline = MonoTime::Now();</a>
<a name="ln1215">  deadline.AddDelta(timeout);</a>
<a name="ln1216">  while (MonoTime::Now().ComesBefore(deadline)) {</a>
<a name="ln1217">    rpc::RpcController rpc;</a>
<a name="ln1218">    rpc.set_timeout(MonoDelta::FromSeconds(10));</a>
<a name="ln1219">    RETURN_NOT_OK(proxy.ListTablets(req, &amp;resp, &amp;rpc));</a>
<a name="ln1220">    if (resp.has_error()) {</a>
<a name="ln1221">      return StatusFromPB(resp.error().status());</a>
<a name="ln1222">    }</a>
<a name="ln1223"> </a>
<a name="ln1224">    int num_not_running = 0;</a>
<a name="ln1225">    for (const StatusAndSchemaPB&amp; status : resp.status_and_schema()) {</a>
<a name="ln1226">      if (status.tablet_status().state() != tablet::RUNNING) {</a>
<a name="ln1227">        num_not_running++;</a>
<a name="ln1228">      }</a>
<a name="ln1229">    }</a>
<a name="ln1230"> </a>
<a name="ln1231">    if (num_not_running == 0) {</a>
<a name="ln1232">      return Status::OK();</a>
<a name="ln1233">    }</a>
<a name="ln1234"> </a>
<a name="ln1235">    SleepFor(MonoDelta::FromMilliseconds(10));</a>
<a name="ln1236">  }</a>
<a name="ln1237"> </a>
<a name="ln1238">  return STATUS(TimedOut, resp.DebugString());</a>
<a name="ln1239">}</a>
<a name="ln1240"> </a>
<a name="ln1241">Status ExternalMiniCluster::WaitForTSToCrash(int index, const MonoDelta&amp; timeout) {</a>
<a name="ln1242">  ExternalTabletServer* ts = tablet_server(index);</a>
<a name="ln1243">  return WaitForTSToCrash(ts, timeout);</a>
<a name="ln1244">}</a>
<a name="ln1245"> </a>
<a name="ln1246">Status ExternalMiniCluster::WaitForTSToCrash(const ExternalTabletServer* ts,</a>
<a name="ln1247">                                             const MonoDelta&amp; timeout) {</a>
<a name="ln1248">  MonoTime deadline = MonoTime::Now();</a>
<a name="ln1249">  deadline.AddDelta(timeout);</a>
<a name="ln1250">  while (MonoTime::Now().ComesBefore(deadline)) {</a>
<a name="ln1251">    if (!ts-&gt;IsProcessAlive()) {</a>
<a name="ln1252">      return Status::OK();</a>
<a name="ln1253">    }</a>
<a name="ln1254">    SleepFor(MonoDelta::FromMilliseconds(10));</a>
<a name="ln1255">  }</a>
<a name="ln1256">  return STATUS(TimedOut, Substitute(&quot;TS $0 did not crash!&quot;, ts-&gt;instance_id().permanent_uuid()));</a>
<a name="ln1257">}</a>
<a name="ln1258"> </a>
<a name="ln1259">namespace {</a>
<a name="ln1260">void LeaderMasterCallback(HostPort* dst_hostport,</a>
<a name="ln1261">                          Synchronizer* sync,</a>
<a name="ln1262">                          const Status&amp; status,</a>
<a name="ln1263">                          const HostPort&amp; result) {</a>
<a name="ln1264">  if (status.ok()) {</a>
<a name="ln1265">    *dst_hostport = result;</a>
<a name="ln1266">  }</a>
<a name="ln1267">  sync-&gt;StatusCB(status);</a>
<a name="ln1268">}</a>
<a name="ln1269">}  // anonymous namespace</a>
<a name="ln1270"> </a>
<a name="ln1271">Status ExternalMiniCluster::GetFirstNonLeaderMasterIndex(int* idx) {</a>
<a name="ln1272">  return GetPeerMasterIndex(idx, false);</a>
<a name="ln1273">}</a>
<a name="ln1274"> </a>
<a name="ln1275">Status ExternalMiniCluster::GetLeaderMasterIndex(int* idx) {</a>
<a name="ln1276">  return GetPeerMasterIndex(idx, true);</a>
<a name="ln1277">}</a>
<a name="ln1278"> </a>
<a name="ln1279">Status ExternalMiniCluster::GetPeerMasterIndex(int* idx, bool is_leader) {</a>
<a name="ln1280">  Synchronizer sync;</a>
<a name="ln1281">  server::MasterAddresses addrs;</a>
<a name="ln1282">  HostPort leader_master_hp;</a>
<a name="ln1283">  auto deadline = CoarseMonoClock::Now() + 5s;</a>
<a name="ln1284"> </a>
<a name="ln1285">  *idx = 0;  // default to 0'th index, even in case of errors.</a>
<a name="ln1286"> </a>
<a name="ln1287">  for (const scoped_refptr&lt;ExternalMaster&gt;&amp; master : masters_) {</a>
<a name="ln1288">    if (master-&gt;IsProcessAlive()) {</a>
<a name="ln1289">      addrs.push_back({ master-&gt;bound_rpc_addr() });</a>
<a name="ln1290">    }</a>
<a name="ln1291">  }</a>
<a name="ln1292">  if (addrs.empty()) {</a>
<a name="ln1293">    return STATUS(IllegalState, &quot;No running masters&quot;);</a>
<a name="ln1294">  }</a>
<a name="ln1295">  rpc::Rpcs rpcs;</a>
<a name="ln1296">  auto rpc = rpc::StartRpc&lt;GetLeaderMasterRpc&gt;(</a>
<a name="ln1297">      Bind(&amp;LeaderMasterCallback, &amp;leader_master_hp, &amp;sync),</a>
<a name="ln1298">      addrs,</a>
<a name="ln1299">      deadline,</a>
<a name="ln1300">      messenger_,</a>
<a name="ln1301">      proxy_cache_.get(),</a>
<a name="ln1302">      &amp;rpcs);</a>
<a name="ln1303">  RETURN_NOT_OK(sync.Wait());</a>
<a name="ln1304">  rpcs.Shutdown();</a>
<a name="ln1305">  bool found = false;</a>
<a name="ln1306">  for (int i = 0; i &lt; masters_.size(); i++) {</a>
<a name="ln1307">    bool matches_leader = masters_[i]-&gt;bound_rpc_hostport().port() == leader_master_hp.port();</a>
<a name="ln1308">    if (is_leader == matches_leader) {</a>
<a name="ln1309">      found = true;</a>
<a name="ln1310">      *idx = i;</a>
<a name="ln1311">      break;</a>
<a name="ln1312">    }</a>
<a name="ln1313">  }</a>
<a name="ln1314"> </a>
<a name="ln1315">  const string peer_type = is_leader ? &quot;leader&quot; : &quot;non-leader&quot;;</a>
<a name="ln1316">  if (!found) {</a>
<a name="ln1317">    // There is never a situation where this should happen, so it's</a>
<a name="ln1318">    // better to exit with a FATAL log message right away vs. return a</a>
<a name="ln1319">    // Status::IllegalState().</a>
<a name="ln1320">    LOG(FATAL) &lt;&lt; &quot;Peer &quot; &lt;&lt; peer_type &lt;&lt; &quot; master is not in masters_ list.&quot;;</a>
<a name="ln1321">  }</a>
<a name="ln1322"> </a>
<a name="ln1323">  LOG(INFO) &lt;&lt; &quot;Found peer &quot; &lt;&lt; peer_type &lt;&lt; &quot; at index &quot; &lt;&lt; *idx &lt;&lt; &quot;.&quot;;</a>
<a name="ln1324"> </a>
<a name="ln1325">  return Status::OK();</a>
<a name="ln1326">}</a>
<a name="ln1327"> </a>
<a name="ln1328">ExternalMaster* ExternalMiniCluster::GetLeaderMaster() {</a>
<a name="ln1329">  int idx = 0;</a>
<a name="ln1330">  int num_attempts = 0;</a>
<a name="ln1331">  Status s;</a>
<a name="ln1332">  // Retry to get the leader master's index - due to timing issues (like election in progress).</a>
<a name="ln1333">  do {</a>
<a name="ln1334">    ++num_attempts;</a>
<a name="ln1335">    s = GetLeaderMasterIndex(&amp;idx);</a>
<a name="ln1336">    if (!s.ok()) {</a>
<a name="ln1337">      LOG(INFO) &lt;&lt; &quot;GetLeaderMasterIndex@&quot; &lt;&lt; num_attempts &lt;&lt; &quot; hit error: &quot; &lt;&lt; s.ToString();</a>
<a name="ln1338">      if (num_attempts &gt;= kMaxRetryIterations) {</a>
<a name="ln1339">        LOG(WARNING) &lt;&lt; &quot;Failed to get leader master after &quot; &lt;&lt; num_attempts &lt;&lt; &quot; attempts, &quot;</a>
<a name="ln1340">                     &lt;&lt; &quot;returning the first master.&quot;;</a>
<a name="ln1341">        break;</a>
<a name="ln1342">      }</a>
<a name="ln1343">      SleepFor(MonoDelta::FromMilliseconds(num_attempts * 10));</a>
<a name="ln1344">    }</a>
<a name="ln1345">  } while (!s.ok());</a>
<a name="ln1346"> </a>
<a name="ln1347">  return master(idx);</a>
<a name="ln1348">}</a>
<a name="ln1349"> </a>
<a name="ln1350">ExternalTabletServer* ExternalMiniCluster::tablet_server_by_uuid(const std::string&amp; uuid) const {</a>
<a name="ln1351">  for (const scoped_refptr&lt;ExternalTabletServer&gt;&amp; ts : tablet_servers_) {</a>
<a name="ln1352">    if (ts-&gt;instance_id().permanent_uuid() == uuid) {</a>
<a name="ln1353">      return ts.get();</a>
<a name="ln1354">    }</a>
<a name="ln1355">  }</a>
<a name="ln1356">  return nullptr;</a>
<a name="ln1357">}</a>
<a name="ln1358"> </a>
<a name="ln1359">int ExternalMiniCluster::tablet_server_index_by_uuid(const std::string&amp; uuid) const {</a>
<a name="ln1360">  for (int i = 0; i &lt; tablet_servers_.size(); i++) {</a>
<a name="ln1361">    if (tablet_servers_[i]-&gt;uuid() == uuid) {</a>
<a name="ln1362">      return i;</a>
<a name="ln1363">    }</a>
<a name="ln1364">  }</a>
<a name="ln1365">  return -1;</a>
<a name="ln1366">}</a>
<a name="ln1367"> </a>
<a name="ln1368">vector&lt;ExternalMaster*&gt; ExternalMiniCluster::master_daemons() const {</a>
<a name="ln1369">  vector&lt;ExternalMaster*&gt; results;</a>
<a name="ln1370">  for (const scoped_refptr&lt;ExternalMaster&gt;&amp; master : masters_) {</a>
<a name="ln1371">    results.push_back(master.get());</a>
<a name="ln1372">  }</a>
<a name="ln1373">  return results;</a>
<a name="ln1374">}</a>
<a name="ln1375"> </a>
<a name="ln1376">vector&lt;ExternalDaemon*&gt; ExternalMiniCluster::daemons() const {</a>
<a name="ln1377">  vector&lt;ExternalDaemon*&gt; results;</a>
<a name="ln1378">  for (const scoped_refptr&lt;ExternalTabletServer&gt;&amp; ts : tablet_servers_) {</a>
<a name="ln1379">    results.push_back(ts.get());</a>
<a name="ln1380">  }</a>
<a name="ln1381">  for (const scoped_refptr&lt;ExternalMaster&gt;&amp; master : masters_) {</a>
<a name="ln1382">    results.push_back(master.get());</a>
<a name="ln1383">  }</a>
<a name="ln1384">  return results;</a>
<a name="ln1385">}</a>
<a name="ln1386"> </a>
<a name="ln1387">std::vector&lt;ExternalTabletServer*&gt; ExternalMiniCluster::tserver_daemons() const {</a>
<a name="ln1388">  std::vector&lt;ExternalTabletServer*&gt; result;</a>
<a name="ln1389">  result.reserve(tablet_servers_.size());</a>
<a name="ln1390">  for (const auto&amp; ts : tablet_servers_) {</a>
<a name="ln1391">    result.push_back(ts.get());</a>
<a name="ln1392">  }</a>
<a name="ln1393">  return result;</a>
<a name="ln1394">}</a>
<a name="ln1395"> </a>
<a name="ln1396">HostPort ExternalMiniCluster::pgsql_hostport(int node_index) const {</a>
<a name="ln1397">  return HostPort(tablet_servers_[node_index]-&gt;bind_host(),</a>
<a name="ln1398">                  tablet_servers_[node_index]-&gt;pgsql_rpc_port());</a>
<a name="ln1399">}</a>
<a name="ln1400"> </a>
<a name="ln1401">rpc::Messenger* ExternalMiniCluster::messenger() {</a>
<a name="ln1402">  return messenger_;</a>
<a name="ln1403">}</a>
<a name="ln1404"> </a>
<a name="ln1405">std::shared_ptr&lt;MasterServiceProxy&gt; ExternalMiniCluster::master_proxy() {</a>
<a name="ln1406">  CHECK_EQ(masters_.size(), 1);</a>
<a name="ln1407">  return master_proxy(0);</a>
<a name="ln1408">}</a>
<a name="ln1409"> </a>
<a name="ln1410">std::shared_ptr&lt;MasterServiceProxy&gt; ExternalMiniCluster::master_proxy(int idx) {</a>
<a name="ln1411">  CHECK_GE(idx, 0);</a>
<a name="ln1412">  CHECK_LT(idx, masters_.size());</a>
<a name="ln1413">  return std::make_shared&lt;MasterServiceProxy&gt;(</a>
<a name="ln1414">      proxy_cache_.get(), CHECK_NOTNULL(master(idx))-&gt;bound_rpc_addr());</a>
<a name="ln1415">}</a>
<a name="ln1416"> </a>
<a name="ln1417">std::shared_ptr&lt;server::GenericServiceProxy&gt; ExternalMiniCluster::master_generic_proxy(</a>
<a name="ln1418">    int idx) const {</a>
<a name="ln1419">  CHECK_GE(idx, 0);</a>
<a name="ln1420">  CHECK_LT(idx, masters_.size());</a>
<a name="ln1421">  return std::make_shared&lt;server::GenericServiceProxy&gt;(</a>
<a name="ln1422">    proxy_cache_.get(), CHECK_NOTNULL(master(idx))-&gt;bound_rpc_addr());</a>
<a name="ln1423">}</a>
<a name="ln1424"> </a>
<a name="ln1425">std::shared_ptr&lt;server::GenericServiceProxy&gt; ExternalMiniCluster::master_generic_proxy(</a>
<a name="ln1426">    const HostPort&amp; bound_rpc_addr) const {</a>
<a name="ln1427">  return std::make_shared&lt;server::GenericServiceProxy&gt;(proxy_cache_.get(), bound_rpc_addr);</a>
<a name="ln1428">}</a>
<a name="ln1429"> </a>
<a name="ln1430">void ExternalMiniCluster::ConfigureClientBuilder(client::YBClientBuilder* builder) {</a>
<a name="ln1431">  CHECK_NOTNULL(builder);</a>
<a name="ln1432">  CHECK(!masters_.empty());</a>
<a name="ln1433">  builder-&gt;clear_master_server_addrs();</a>
<a name="ln1434">  for (const scoped_refptr&lt;ExternalMaster&gt;&amp; master : masters_) {</a>
<a name="ln1435">    builder-&gt;add_master_server_addr(master-&gt;bound_rpc_hostport().ToString());</a>
<a name="ln1436">  }</a>
<a name="ln1437">}</a>
<a name="ln1438"> </a>
<a name="ln1439">HostPort ExternalMiniCluster::DoGetLeaderMasterBoundRpcAddr() {</a>
<a name="ln1440">  return GetLeaderMaster()-&gt;bound_rpc_addr();</a>
<a name="ln1441">}</a>
<a name="ln1442"> </a>
<a name="ln1443">Status ExternalMiniCluster::SetFlag(ExternalDaemon* daemon,</a>
<a name="ln1444">                                    const string&amp; flag,</a>
<a name="ln1445">                                    const string&amp; value) {</a>
<a name="ln1446">  server::GenericServiceProxy proxy(proxy_cache_.get(), daemon-&gt;bound_rpc_addr());</a>
<a name="ln1447"> </a>
<a name="ln1448">  rpc::RpcController controller;</a>
<a name="ln1449">  controller.set_timeout(MonoDelta::FromSeconds(30));</a>
<a name="ln1450">  server::SetFlagRequestPB req;</a>
<a name="ln1451">  server::SetFlagResponsePB resp;</a>
<a name="ln1452">  req.set_flag(flag);</a>
<a name="ln1453">  req.set_value(value);</a>
<a name="ln1454">  req.set_force(true);</a>
<a name="ln1455">  RETURN_NOT_OK_PREPEND(proxy.SetFlag(req, &amp;resp, &amp;controller),</a>
<a name="ln1456">                        &quot;rpc failed&quot;);</a>
<a name="ln1457">  if (resp.result() != server::SetFlagResponsePB::SUCCESS) {</a>
<a name="ln1458">    return STATUS(RemoteError, &quot;failed to set flag&quot;,</a>
<a name="ln1459">                               resp.ShortDebugString());</a>
<a name="ln1460">  }</a>
<a name="ln1461">  return Status::OK();</a>
<a name="ln1462">}</a>
<a name="ln1463"> </a>
<a name="ln1464">Status ExternalMiniCluster::SetFlagOnTServers(const string&amp; flag, const string&amp; value) {</a>
<a name="ln1465">  for (const auto&amp; tablet_server : tablet_servers_) {</a>
<a name="ln1466">    RETURN_NOT_OK(SetFlag(tablet_server.get(), flag, value));</a>
<a name="ln1467">  }</a>
<a name="ln1468">  return Status::OK();</a>
<a name="ln1469">}</a>
<a name="ln1470"> </a>
<a name="ln1471"> </a>
<a name="ln1472">uint16_t ExternalMiniCluster::AllocateFreePort() {</a>
<a name="ln1473">  // This will take a file lock ensuring the port does not get claimed by another thread/process</a>
<a name="ln1474">  // and add it to our vector of such locks that will be freed on minicluster shutdown.</a>
<a name="ln1475">  free_port_file_locks_.emplace_back();</a>
<a name="ln1476">  return GetFreePort(&amp;free_port_file_locks_.back());</a>
<a name="ln1477">}</a>
<a name="ln1478"> </a>
<a name="ln1479">Status ExternalMiniCluster::StartElection(ExternalMaster* master) {</a>
<a name="ln1480">  auto master_sock = master-&gt;bound_rpc_addr();</a>
<a name="ln1481">  auto master_proxy = std::make_shared&lt;ConsensusServiceProxy&gt;(proxy_cache_.get(), master_sock);</a>
<a name="ln1482"> </a>
<a name="ln1483">  RunLeaderElectionRequestPB req;</a>
<a name="ln1484">  req.set_dest_uuid(master-&gt;uuid());</a>
<a name="ln1485">  req.set_tablet_id(yb::master::kSysCatalogTabletId);</a>
<a name="ln1486">  RunLeaderElectionResponsePB resp;</a>
<a name="ln1487">  RpcController rpc;</a>
<a name="ln1488">  rpc.set_timeout(opts_.timeout);</a>
<a name="ln1489">  RETURN_NOT_OK(master_proxy-&gt;RunLeaderElection(req, &amp;resp, &amp;rpc));</a>
<a name="ln1490">  if (resp.has_error()) {</a>
<a name="ln1491">    return StatusFromPB(resp.error().status())</a>
<a name="ln1492">               .CloneAndPrepend(Substitute(&quot;Code $0&quot;,</a>
<a name="ln1493">                                           TabletServerErrorPB::Code_Name(resp.error().code())));</a>
<a name="ln1494">  }</a>
<a name="ln1495">  return Status::OK();</a>
<a name="ln1496">}</a>
<a name="ln1497"> </a>
<a name="ln1498">//------------------------------------------------------------</a>
<a name="ln1499">// ExternalDaemon</a>
<a name="ln1500">//------------------------------------------------------------</a>
<a name="ln1501"> </a>
<a name="ln1502">namespace {</a>
<a name="ln1503"> </a>
<a name="ln1504">// Global state to manage all log tailer threads. This state is managed using Singleton from gutil</a>
<a name="ln1505">// and is never deallocated.</a>
<a name="ln1506">struct GlobalLogTailerState {</a>
<a name="ln1507">  mutex logging_mutex;</a>
<a name="ln1508">  atomic&lt;int&gt; next_log_tailer_id{0};</a>
<a name="ln1509"> </a>
<a name="ln1510">  // We need some references to these heap-allocated atomic booleans so that ASAN would not consider</a>
<a name="ln1511">  // them memory leaks.</a>
<a name="ln1512">  mutex id_to_stopped_flag_mutex;</a>
<a name="ln1513">  map&lt;int, atomic&lt;bool&gt;*&gt; id_to_stopped_flag;</a>
<a name="ln1514"> </a>
<a name="ln1515">  // This is used to limit the total amount of logs produced by external daemons over the lifetime</a>
<a name="ln1516">  // of a test program. Guarded by logging_mutex.</a>
<a name="ln1517">  size_t total_bytes_logged = 0;</a>
<a name="ln1518">};</a>
<a name="ln1519"> </a>
<a name="ln1520">}  // anonymous namespace</a>
<a name="ln1521"> </a>
<a name="ln1522">class ExternalDaemon::LogTailerThread {</a>
<a name="ln1523"> public:</a>
<a name="ln1524">  LogTailerThread(const string line_prefix,</a>
<a name="ln1525">                  const int child_fd,</a>
<a name="ln1526">                  ostream* const out)</a>
<a name="ln1527">      : id_(global_state()-&gt;next_log_tailer_id.fetch_add(1)),</a>
<a name="ln1528">        stopped_(CreateStoppedFlagForId(id_)),</a>
<a name="ln1529">        thread_desc_(Substitute(&quot;log tailer thread for prefix $0&quot;, line_prefix)),</a>
<a name="ln1530">        thread_([=] {</a>
<a name="ln1531">          VLOG(1) &lt;&lt; &quot;Starting &quot; &lt;&lt; thread_desc_;</a>
<a name="ln1532">          FILE* const fp = fdopen(child_fd, &quot;rb&quot;);</a>
<a name="ln1533">          char buf[65536];</a>
<a name="ln1534">          const atomic&lt;bool&gt;* stopped;</a>
<a name="ln1535"> </a>
<a name="ln1536">          {</a>
<a name="ln1537">            lock_guard&lt;mutex&gt; l(state_lock_);</a>
<a name="ln1538">            stopped = stopped_;</a>
<a name="ln1539">          }</a>
<a name="ln1540"> </a>
<a name="ln1541">          // Instead of doing a nonblocking read, we detach this thread and allow it to block</a>
<a name="ln1542">          // indefinitely trying to read from a child process's stream where nothing is happening.</a>
<a name="ln1543">          // This is probably OK as long as we are careful to avoid accessing any state that might</a>
<a name="ln1544">          // have been already destructed (e.g. logging, cout/cerr, member fields of this class,</a>
<a name="ln1545">          // etc.) in case we do get unblocked. Instead, we keep a local pointer to the atomic</a>
<a name="ln1546">          // &quot;stopped&quot; flag, and that allows us to safely check if it is OK to print log messages.</a>
<a name="ln1547">          // The &quot;stopped&quot; flag itself is never deallocated.</a>
<a name="ln1548">          bool is_eof = false;</a>
<a name="ln1549">          bool is_fgets_null = false;</a>
<a name="ln1550">          auto&amp; logging_mutex = global_state()-&gt;logging_mutex;</a>
<a name="ln1551">          auto&amp; total_bytes_logged = global_state()-&gt;total_bytes_logged;</a>
<a name="ln1552">          while (!(is_eof = feof(fp)) &amp;&amp;</a>
<a name="ln1553">                 !(is_fgets_null = (fgets(buf, sizeof(buf), fp) == nullptr)) &amp;&amp;</a>
<a name="ln1554">                 !stopped-&gt;load()) {</a>
<a name="ln1555">            size_t l = strlen(buf);</a>
<a name="ln1556">            const char* maybe_end_of_line = l &gt; 0 &amp;&amp; buf[l - 1] == '\n' ? &quot;&quot; : &quot;\n&quot;;</a>
<a name="ln1557">            // Synchronize tailing output from all external daemons for simplicity.</a>
<a name="ln1558">            lock_guard&lt;mutex&gt; lock(logging_mutex);</a>
<a name="ln1559">            if (stopped-&gt;load()) break;</a>
<a name="ln1560">            // Make sure we always output an end-of-line character.</a>
<a name="ln1561">            *out &lt;&lt; line_prefix &lt;&lt; &quot; &quot; &lt;&lt; buf &lt;&lt; maybe_end_of_line;</a>
<a name="ln1562">            if (!stopped-&gt;load()) {</a>
<a name="ln1563">              auto listener = listener_.load(std::memory_order_acquire);</a>
<a name="ln1564">              if (!stopped-&gt;load() &amp;&amp; listener) {</a>
<a name="ln1565">                listener-&gt;Handle(GStringPiece(buf, maybe_end_of_line ? l : l - 1));</a>
<a name="ln1566">              }</a>
<a name="ln1567">            }</a>
<a name="ln1568">            total_bytes_logged += strlen(buf) + strlen(maybe_end_of_line);</a>
<a name="ln1569">            // Abort the test if it produces too much log spew.</a>
<a name="ln1570">            CHECK_LE(total_bytes_logged, FLAGS_external_mini_cluster_max_log_bytes);</a>
<a name="ln1571">          }</a>
<a name="ln1572">          fclose(fp);</a>
<a name="ln1573">          if (!stopped-&gt;load()) {</a>
<a name="ln1574">            // It might not be safe to log anything if we have already stopped.</a>
<a name="ln1575">            VLOG(1) &lt;&lt; &quot;Exiting &quot; &lt;&lt; thread_desc_</a>
<a name="ln1576">                    &lt;&lt; &quot;: is_eof=&quot; &lt;&lt; is_eof</a>
<a name="ln1577">                    &lt;&lt; &quot;, is_fgets_null=&quot; &lt;&lt; is_fgets_null</a>
<a name="ln1578">                    &lt;&lt; &quot;, stopped=0&quot;;</a>
<a name="ln1579">          }</a>
<a name="ln1580">        }) {</a>
<a name="ln1581">    thread_.detach();</a>
<a name="ln1582">  }</a>
<a name="ln1583"> </a>
<a name="ln1584">  void SetListener(StringListener* listener) {</a>
<a name="ln1585">    listener_ = listener;</a>
<a name="ln1586">  }</a>
<a name="ln1587"> </a>
<a name="ln1588">  void RemoveListener(StringListener* listener) {</a>
<a name="ln1589">    listener_.compare_exchange_strong(listener, nullptr);</a>
<a name="ln1590">  }</a>
<a name="ln1591"> </a>
<a name="ln1592">  ~LogTailerThread() {</a>
<a name="ln1593">    VLOG(1) &lt;&lt; &quot;Stopping &quot; &lt;&lt; thread_desc_;</a>
<a name="ln1594">    lock_guard&lt;mutex&gt; l(state_lock_);</a>
<a name="ln1595">    stopped_-&gt;store(true);</a>
<a name="ln1596">    listener_ = nullptr;</a>
<a name="ln1597">  }</a>
<a name="ln1598"> </a>
<a name="ln1599"> private:</a>
<a name="ln1600">  static GlobalLogTailerState* global_state() {</a>
<a name="ln1601">    return Singleton&lt;GlobalLogTailerState&gt;::get();</a>
<a name="ln1602">  }</a>
<a name="ln1603"> </a>
<a name="ln1604">  static atomic&lt;bool&gt;* CreateStoppedFlagForId(int id) {</a>
<a name="ln1605">    lock_guard&lt;mutex&gt; lock(global_state()-&gt;id_to_stopped_flag_mutex);</a>
<a name="ln1606">    // This is never deallocated, but we add this pointer to the id_to_stopped_flag map referenced</a>
<a name="ln1607">    // from the global state singleton, and that apparently makes ASAN no longer consider this to be</a>
<a name="ln1608">    // a memory leak. We don't need to check if the id already exists in the map, because this</a>
<a name="ln1609">    // function is never invoked with a particular id more than once.</a>
<a name="ln1610">    auto* const stopped = new atomic&lt;bool&gt;();</a>
<a name="ln1611">    stopped-&gt;store(false);</a>
<a name="ln1612">    global_state()-&gt;id_to_stopped_flag[id] = stopped;</a>
<a name="ln1613">    return stopped;</a>
<a name="ln1614">  }</a>
<a name="ln1615"> </a>
<a name="ln1616">  const int id_;</a>
<a name="ln1617"> </a>
<a name="ln1618">  // This lock protects the stopped_ pointer in case of a race between tailer thread's</a>
<a name="ln1619">  // initialization (i.e. before it gets into its loop) and the destructor.</a>
<a name="ln1620">  mutex state_lock_;</a>
<a name="ln1621"> </a>
<a name="ln1622">  atomic&lt;bool&gt;* const stopped_;</a>
<a name="ln1623">  const string thread_desc_;  // A human-readable description of this thread.</a>
<a name="ln1624">  thread thread_;</a>
<a name="ln1625">  std::atomic&lt;StringListener*&gt; listener_{nullptr};</a>
<a name="ln1626">};</a>
<a name="ln1627"> </a>
<a name="ln1628">ExternalDaemon::ExternalDaemon(</a>
<a name="ln1629">    std::string daemon_id,</a>
<a name="ln1630">    rpc::Messenger* messenger,</a>
<a name="ln1631">    rpc::ProxyCache* proxy_cache,</a>
<a name="ln1632">    string exe,</a>
<a name="ln1633">    string data_dir,</a>
<a name="ln1634">    string server_type,</a>
<a name="ln1635">    vector&lt;string&gt; extra_flags)</a>
<a name="ln1636">  : daemon_id_(daemon_id),</a>
<a name="ln1637">    messenger_(messenger),</a>
<a name="ln1638">    proxy_cache_(proxy_cache),</a>
<a name="ln1639">    exe_(std::move(exe)),</a>
<a name="ln1640">    data_dir_(std::move(data_dir)),</a>
<a name="ln1641">    full_data_dir_(GetServerTypeDataPath(data_dir_, std::move(server_type))),</a>
<a name="ln1642">    extra_flags_(std::move(extra_flags)) {}</a>
<a name="ln1643"> </a>
<a name="ln1644">ExternalDaemon::~ExternalDaemon() {</a>
<a name="ln1645">}</a>
<a name="ln1646"> </a>
<a name="ln1647">bool ExternalDaemon::ServerInfoPathsExist() {</a>
<a name="ln1648">  return Env::Default()-&gt;FileExists(GetServerInfoPath());</a>
<a name="ln1649">}</a>
<a name="ln1650"> </a>
<a name="ln1651">Status ExternalDaemon::BuildServerStateFromInfoPath() {</a>
<a name="ln1652">  return BuildServerStateFromInfoPath(GetServerInfoPath(), &amp;status_);</a>
<a name="ln1653">}</a>
<a name="ln1654"> </a>
<a name="ln1655">Status ExternalDaemon::BuildServerStateFromInfoPath(</a>
<a name="ln1656">    const string&amp; info_path, std::unique_ptr&lt;ServerStatusPB&gt;* server_status) {</a>
<a name="ln1657">  server_status-&gt;reset(new ServerStatusPB());</a>
<a name="ln1658">  RETURN_NOT_OK_PREPEND(pb_util::ReadPBFromPath(Env::Default(), info_path, (*server_status).get()),</a>
<a name="ln1659">                        &quot;Failed to read info file from &quot; + info_path);</a>
<a name="ln1660">  return Status::OK();</a>
<a name="ln1661">}</a>
<a name="ln1662"> </a>
<a name="ln1663">string ExternalDaemon::GetServerInfoPath() {</a>
<a name="ln1664">  return JoinPathSegments(full_data_dir_, &quot;info.pb&quot;);</a>
<a name="ln1665">}</a>
<a name="ln1666"> </a>
<a name="ln1667">Status ExternalDaemon::DeleteServerInfoPaths() {</a>
<a name="ln1668">  return Env::Default()-&gt;DeleteFile(GetServerInfoPath());</a>
<a name="ln1669">}</a>
<a name="ln1670"> </a>
<a name="ln1671">Status ExternalDaemon::StartProcess(const vector&lt;string&gt;&amp; user_flags) {</a>
<a name="ln1672">  CHECK(!process_);</a>
<a name="ln1673"> </a>
<a name="ln1674">  vector&lt;string&gt; argv;</a>
<a name="ln1675">  // First the exe for argv[0]</a>
<a name="ln1676">  argv.push_back(BaseName(exe_));</a>
<a name="ln1677"> </a>
<a name="ln1678">  // Then all the flags coming from the minicluster framework.</a>
<a name="ln1679">  argv.insert(argv.end(), user_flags.begin(), user_flags.end());</a>
<a name="ln1680"> </a>
<a name="ln1681">  // Disable callhome.</a>
<a name="ln1682">  argv.push_back(&quot;--callhome_enabled=false&quot;);</a>
<a name="ln1683"> </a>
<a name="ln1684">  // Disabled due to #4507.</a>
<a name="ln1685">  // TODO: Enable metrics logging after #4507 is fixed.</a>
<a name="ln1686">  //</a>
<a name="ln1687">  // Even though we set -logtostderr down below, metrics logs end up being written</a>
<a name="ln1688">  // based on -log_dir. So, we have to set that too.</a>
<a name="ln1689">  argv.push_back(&quot;--metrics_log_interval_ms=0&quot;);</a>
<a name="ln1690"> </a>
<a name="ln1691">  // Force set log_dir to empty value, process will chose default destination inside fs_data_dir</a>
<a name="ln1692">  // In other case log_dir value will be extracted from TEST_TMPDIR env variable but it is</a>
<a name="ln1693">  // inherited from test script</a>
<a name="ln1694">  argv.push_back(&quot;--log_dir=&quot;);</a>
<a name="ln1695"> </a>
<a name="ln1696">  // Then the &quot;extra flags&quot; passed into the ctor (from the ExternalMiniCluster</a>
<a name="ln1697">  // options struct). These come at the end so they can override things like</a>
<a name="ln1698">  // web port or RPC bind address if necessary.</a>
<a name="ln1699">  argv.insert(argv.end(), extra_flags_.begin(), extra_flags_.end());</a>
<a name="ln1700"> </a>
<a name="ln1701">  // Tell the server to dump its port information so we can pick it up.</a>
<a name="ln1702">  const string info_path = GetServerInfoPath();</a>
<a name="ln1703">  argv.push_back(&quot;--server_dump_info_path=&quot; + info_path);</a>
<a name="ln1704">  argv.push_back(&quot;--server_dump_info_format=pb&quot;);</a>
<a name="ln1705"> </a>
<a name="ln1706">  // We use ephemeral ports in many tests. They don't work for production, but are OK</a>
<a name="ln1707">  // in unit tests.</a>
<a name="ln1708">  argv.push_back(&quot;--rpc_server_allow_ephemeral_ports&quot;);</a>
<a name="ln1709"> </a>
<a name="ln1710">  // A previous instance of the daemon may have run in the same directory. So, remove</a>
<a name="ln1711">  // the previous info file if it's there.</a>
<a name="ln1712">  Status s = DeleteServerInfoPaths();</a>
<a name="ln1713">  if (!s.ok() &amp;&amp; !s.IsNotFound()) {</a>
<a name="ln1714">    LOG (WARNING) &lt;&lt; &quot;Failed to delete info paths: &quot; &lt;&lt; s.ToString();</a>
<a name="ln1715">  }</a>
<a name="ln1716"> </a>
<a name="ln1717">  // Ensure that logging goes to the test output doesn't get buffered.</a>
<a name="ln1718">  argv.push_back(&quot;--logbuflevel=-1&quot;);</a>
<a name="ln1719"> </a>
<a name="ln1720">  // Use the same verbose logging level in the child process as in the test driver.</a>
<a name="ln1721">  if (FLAGS_v != 0) {  // Skip this option if it has its default value (0).</a>
<a name="ln1722">    argv.push_back(Substitute(&quot;-v=$0&quot;, FLAGS_v));</a>
<a name="ln1723">  }</a>
<a name="ln1724">  if (!FLAGS_vmodule.empty()) {</a>
<a name="ln1725">    argv.push_back(Substitute(&quot;--vmodule=$0&quot;, FLAGS_vmodule));</a>
<a name="ln1726">  }</a>
<a name="ln1727">  if (FLAGS_mem_tracker_logging) {</a>
<a name="ln1728">    argv.push_back(&quot;--mem_tracker_logging&quot;);</a>
<a name="ln1729">  }</a>
<a name="ln1730">  if (FLAGS_mem_tracker_log_stack_trace) {</a>
<a name="ln1731">    argv.push_back(&quot;--mem_tracker_log_stack_trace&quot;);</a>
<a name="ln1732">  }</a>
<a name="ln1733">  if (FLAGS_use_libbacktrace) {</a>
<a name="ln1734">    argv.push_back(&quot;--use_libbacktrace&quot;);</a>
<a name="ln1735">  }</a>
<a name="ln1736"> </a>
<a name="ln1737">  const char* test_invocation_id = getenv(&quot;YB_TEST_INVOCATION_ID&quot;);</a>
<a name="ln1738">  if (test_invocation_id) {</a>
<a name="ln1739">    // We use --metric_node_name=... to include a unique &quot;test invocation id&quot; into the command</a>
<a name="ln1740">    // line so we can kill any stray processes later. --metric_node_name is normally how we pass</a>
<a name="ln1741">    // the Universe ID to the cluster. We could use any other flag that is present in yb-master</a>
<a name="ln1742">    // and yb-tserver for this.</a>
<a name="ln1743">    argv.push_back(Format(&quot;--metric_node_name=$0&quot;, test_invocation_id));</a>
<a name="ln1744">  }</a>
<a name="ln1745"> </a>
<a name="ln1746">  string fatal_details_path_prefix = GetFatalDetailsPathPrefix();</a>
<a name="ln1747">  argv.push_back(Format(</a>
<a name="ln1748">      &quot;--fatal_details_path_prefix=$0.$1&quot;, GetFatalDetailsPathPrefix(), daemon_id_));</a>
<a name="ln1749"> </a>
<a name="ln1750">  argv.push_back(Format(&quot;--minicluster_daemon_id=$0&quot;, daemon_id_));</a>
<a name="ln1751"> </a>
<a name="ln1752">  AddExtraFlagsFromEnvVar(&quot;YB_EXTRA_DAEMON_FLAGS&quot;, &amp;argv);</a>
<a name="ln1753"> </a>
<a name="ln1754">  gscoped_ptr&lt;Subprocess&gt; p(new Subprocess(exe_, argv));</a>
<a name="ln1755">  p-&gt;ShareParentStdout(false);</a>
<a name="ln1756">  p-&gt;ShareParentStderr(false);</a>
<a name="ln1757">  auto default_output_prefix = Substitute(&quot;[$0]&quot;, daemon_id_);</a>
<a name="ln1758">  LOG(INFO) &lt;&lt; &quot;Running &quot; &lt;&lt; default_output_prefix &lt;&lt; &quot;: &quot; &lt;&lt; exe_ &lt;&lt; &quot;\n&quot;</a>
<a name="ln1759">    &lt;&lt; JoinStrings(argv, &quot;\n&quot;);</a>
<a name="ln1760">  if (!FLAGS_external_daemon_heap_profile_prefix.empty()) {</a>
<a name="ln1761">    p-&gt;SetEnv(&quot;HEAPPROFILE&quot;,</a>
<a name="ln1762">              FLAGS_external_daemon_heap_profile_prefix + &quot;_&quot; + daemon_id_);</a>
<a name="ln1763">    p-&gt;SetEnv(&quot;HEAPPROFILESIGNAL&quot;, std::to_string(kHeapProfileSignal));</a>
<a name="ln1764">  }</a>
<a name="ln1765"> </a>
<a name="ln1766">  RETURN_NOT_OK_PREPEND(p-&gt;Start(),</a>
<a name="ln1767">                        Substitute(&quot;Failed to start subprocess $0&quot;, exe_));</a>
<a name="ln1768"> </a>
<a name="ln1769">  stdout_tailer_thread_ = unique_ptr&lt;LogTailerThread&gt;(new LogTailerThread(</a>
<a name="ln1770">      Substitute(&quot;[$0 stdout]&quot;, daemon_id_), p-&gt;ReleaseChildStdoutFd(), &amp;std::cout));</a>
<a name="ln1771"> </a>
<a name="ln1772">  // We will mostly see stderr output from the child process (because of --logtostderr), so we'll</a>
<a name="ln1773">  // assume that by default in the output prefix.</a>
<a name="ln1774">  stderr_tailer_thread_ = unique_ptr&lt;LogTailerThread&gt;(new LogTailerThread(</a>
<a name="ln1775">      default_output_prefix, p-&gt;ReleaseChildStderrFd(), &amp;std::cerr));</a>
<a name="ln1776"> </a>
<a name="ln1777">  // The process is now starting -- wait for the bound port info to show up.</a>
<a name="ln1778">  Stopwatch sw;</a>
<a name="ln1779">  sw.start();</a>
<a name="ln1780">  bool success = false;</a>
<a name="ln1781">  while (sw.elapsed().wall_seconds() &lt; kProcessStartTimeoutSeconds) {</a>
<a name="ln1782">    if (ServerInfoPathsExist()) {</a>
<a name="ln1783">      success = true;</a>
<a name="ln1784">      break;</a>
<a name="ln1785">    }</a>
<a name="ln1786">    SleepFor(MonoDelta::FromMilliseconds(10));</a>
<a name="ln1787">    int rc;</a>
<a name="ln1788">    Status s = p-&gt;WaitNoBlock(&amp;rc);</a>
<a name="ln1789">    if (s.IsTimedOut()) {</a>
<a name="ln1790">      // The process is still running.</a>
<a name="ln1791">      continue;</a>
<a name="ln1792">    }</a>
<a name="ln1793">    RETURN_NOT_OK_PREPEND(s, Substitute(&quot;Failed waiting on $0&quot;, exe_));</a>
<a name="ln1794">    return STATUS(RuntimeError,</a>
<a name="ln1795">      Substitute(&quot;Process exited with rc=$0&quot;, rc),</a>
<a name="ln1796">      exe_);</a>
<a name="ln1797">  }</a>
<a name="ln1798"> </a>
<a name="ln1799">  if (!success) {</a>
<a name="ln1800">    ignore_result(p-&gt;Kill(SIGKILL));</a>
<a name="ln1801">    return STATUS(TimedOut,</a>
<a name="ln1802">        Substitute(&quot;Timed out after $0s waiting for process ($1) to write info file ($2)&quot;,</a>
<a name="ln1803">                   kProcessStartTimeoutSeconds, exe_, info_path));</a>
<a name="ln1804">  }</a>
<a name="ln1805"> </a>
<a name="ln1806">  RETURN_NOT_OK(BuildServerStateFromInfoPath());</a>
<a name="ln1807">  LOG(INFO) &lt;&lt; &quot;Started &quot; &lt;&lt; default_output_prefix &lt;&lt; &quot; &quot; &lt;&lt; exe_ &lt;&lt; &quot; as pid &quot; &lt;&lt; p-&gt;pid();</a>
<a name="ln1808">  VLOG(1) &lt;&lt; exe_ &lt;&lt; &quot; instance information:\n&quot; &lt;&lt; status_-&gt;DebugString();</a>
<a name="ln1809"> </a>
<a name="ln1810">  process_.swap(p);</a>
<a name="ln1811">  return Status::OK();</a>
<a name="ln1812">}</a>
<a name="ln1813"> </a>
<a name="ln1814">Status ExternalDaemon::Pause() {</a>
<a name="ln1815">  if (!process_) return Status::OK();</a>
<a name="ln1816">  VLOG(1) &lt;&lt; &quot;Pausing &quot; &lt;&lt; ProcessNameAndPidStr();</a>
<a name="ln1817">  return process_-&gt;Kill(SIGSTOP);</a>
<a name="ln1818">}</a>
<a name="ln1819"> </a>
<a name="ln1820">Status ExternalDaemon::Resume() {</a>
<a name="ln1821">  if (!process_) return Status::OK();</a>
<a name="ln1822">  VLOG(1) &lt;&lt; &quot;Resuming &quot; &lt;&lt; ProcessNameAndPidStr();</a>
<a name="ln1823">  return process_-&gt;Kill(SIGCONT);</a>
<a name="ln1824">}</a>
<a name="ln1825"> </a>
<a name="ln1826">bool ExternalDaemon::IsShutdown() const {</a>
<a name="ln1827">  return process_.get() == nullptr;</a>
<a name="ln1828">}</a>
<a name="ln1829"> </a>
<a name="ln1830">bool ExternalDaemon::IsProcessAlive() const {</a>
<a name="ln1831">  if (IsShutdown()) {</a>
<a name="ln1832">    return false;</a>
<a name="ln1833">  }</a>
<a name="ln1834"> </a>
<a name="ln1835">  int rc = 0;</a>
<a name="ln1836">  Status s = process_-&gt;WaitNoBlock(&amp;rc);</a>
<a name="ln1837">  // If the non-blocking Wait &quot;times out&quot;, that means the process</a>
<a name="ln1838">  // is running.</a>
<a name="ln1839">  return s.IsTimedOut();</a>
<a name="ln1840">}</a>
<a name="ln1841"> </a>
<a name="ln1842">pid_t ExternalDaemon::pid() const {</a>
<a name="ln1843">  return process_-&gt;pid();</a>
<a name="ln1844">}</a>
<a name="ln1845"> </a>
<a name="ln1846">void ExternalDaemon::Shutdown() {</a>
<a name="ln1847">  if (!process_) return;</a>
<a name="ln1848"> </a>
<a name="ln1849">  LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Starting Shutdown()&quot;;</a>
<a name="ln1850"> </a>
<a name="ln1851">  // Before we kill the process, store the addresses. If we're told to start again we'll reuse</a>
<a name="ln1852">  // these.</a>
<a name="ln1853">  bound_rpc_ = bound_rpc_hostport();</a>
<a name="ln1854">  bound_http_ = bound_http_hostport();</a>
<a name="ln1855"> </a>
<a name="ln1856">  if (IsProcessAlive()) {</a>
<a name="ln1857">    // In coverage builds, ask the process nicely to flush coverage info</a>
<a name="ln1858">    // before we kill -9 it. Otherwise, we never get any coverage from</a>
<a name="ln1859">    // external clusters.</a>
<a name="ln1860">    FlushCoverage();</a>
<a name="ln1861"> </a>
<a name="ln1862">    if (!FLAGS_external_daemon_heap_profile_prefix.empty()) {</a>
<a name="ln1863">      // The child process has been configured using the HEAPPROFILESIGNAL environment variable to</a>
<a name="ln1864">      // create a heap profile on receiving kHeapProfileSignal.</a>
<a name="ln1865">      static const int kWaitMs = 100;</a>
<a name="ln1866">      LOG(INFO) &lt;&lt; &quot;Sending signal &quot; &lt;&lt; kHeapProfileSignal &lt;&lt; &quot; to &quot; &lt;&lt; ProcessNameAndPidStr()</a>
<a name="ln1867">                &lt;&lt; &quot; to capture a heap profile. Waiting for &quot; &lt;&lt; kWaitMs &lt;&lt; &quot; ms afterwards.&quot;;</a>
<a name="ln1868">      ignore_result(process_-&gt;Kill(kHeapProfileSignal));</a>
<a name="ln1869">      std::this_thread::sleep_for(std::chrono::milliseconds(kWaitMs));</a>
<a name="ln1870">    }</a>
<a name="ln1871"> </a>
<a name="ln1872">    if (FLAGS_external_daemon_safe_shutdown) {</a>
<a name="ln1873">      // We put 'SIGTERM' in quotes because an unquoted one would be treated as a test failure</a>
<a name="ln1874">      // by our regular expressions in common-test-env.sh.</a>
<a name="ln1875">      LOG(INFO) &lt;&lt; &quot;Terminating &quot; &lt;&lt; ProcessNameAndPidStr() &lt;&lt; &quot; using 'SIGTERM' signal&quot;;</a>
<a name="ln1876">      ignore_result(process_-&gt;Kill(SIGTERM));</a>
<a name="ln1877">      int total_delay_ms = 0;</a>
<a name="ln1878">      int current_delay_ms = 10;</a>
<a name="ln1879">      for (int i = 0; i &lt; 10 &amp;&amp; IsProcessAlive(); ++i) {</a>
<a name="ln1880">        std::this_thread::sleep_for(std::chrono::milliseconds(current_delay_ms));</a>
<a name="ln1881">        total_delay_ms += current_delay_ms;</a>
<a name="ln1882">        current_delay_ms += 10;  // will sleep for 10ms, then 20ms, etc.</a>
<a name="ln1883">      }</a>
<a name="ln1884"> </a>
<a name="ln1885">      if (IsProcessAlive()) {</a>
<a name="ln1886">        LOG(INFO) &lt;&lt; &quot;The process &quot; &lt;&lt; ProcessNameAndPidStr() &lt;&lt; &quot; is still running after &quot;</a>
<a name="ln1887">                  &lt;&lt; total_delay_ms &lt;&lt; &quot; ms, will send SIGKILL&quot;;</a>
<a name="ln1888">      }</a>
<a name="ln1889">    }</a>
<a name="ln1890"> </a>
<a name="ln1891">    if (IsProcessAlive()) {</a>
<a name="ln1892">      LOG(INFO) &lt;&lt; &quot;Killing &quot; &lt;&lt; ProcessNameAndPidStr() &lt;&lt; &quot; with SIGKILL&quot;;</a>
<a name="ln1893">      ignore_result(process_-&gt;Kill(SIGKILL));</a>
<a name="ln1894">    }</a>
<a name="ln1895">  }</a>
<a name="ln1896">  int ret = 0;</a>
<a name="ln1897">  WARN_NOT_OK(process_-&gt;Wait(&amp;ret), &quot;Waiting on &quot; + exe_);</a>
<a name="ln1898">  process_.reset();</a>
<a name="ln1899">}</a>
<a name="ln1900"> </a>
<a name="ln1901">void ExternalDaemon::FlushCoverage() {</a>
<a name="ln1902">#ifndef COVERAGE_BUILD_</a>
<a name="ln1903">  return;</a>
<a name="ln1904">#else</a>
<a name="ln1905">  LOG(INFO) &lt;&lt; &quot;Attempting to flush coverage for &quot; &lt;&lt; exe_ &lt;&lt; &quot; pid &quot; &lt;&lt; process_-&gt;pid();</a>
<a name="ln1906">  server::GenericServiceProxy proxy(messenger_, bound_rpc_addr());</a>
<a name="ln1907"> </a>
<a name="ln1908">  server::FlushCoverageRequestPB req;</a>
<a name="ln1909">  server::FlushCoverageResponsePB resp;</a>
<a name="ln1910">  rpc::RpcController rpc;</a>
<a name="ln1911"> </a>
<a name="ln1912">  // Set a reasonably short timeout, since some of our tests kill servers which</a>
<a name="ln1913">  // are kill -STOPed.</a>
<a name="ln1914">  rpc.set_timeout(MonoDelta::FromMilliseconds(100));</a>
<a name="ln1915">  Status s = proxy.FlushCoverage(req, &amp;resp, &amp;rpc);</a>
<a name="ln1916">  if (s.ok() &amp;&amp; !resp.success()) {</a>
<a name="ln1917">    s = STATUS(RemoteError, &quot;Server does not appear to be running a coverage build&quot;);</a>
<a name="ln1918">  }</a>
<a name="ln1919">  WARN_NOT_OK(s, Substitute(&quot;Unable to flush coverage on $0 pid $1&quot;, exe_, process_-&gt;pid()));</a>
<a name="ln1920">#endif</a>
<a name="ln1921">}</a>
<a name="ln1922"> </a>
<a name="ln1923">std::string ExternalDaemon::ProcessNameAndPidStr() {</a>
<a name="ln1924">  return Substitute(&quot;$0 with pid $1&quot;, exe_, process_-&gt;pid());</a>
<a name="ln1925">}</a>
<a name="ln1926"> </a>
<a name="ln1927">HostPort ExternalDaemon::bound_rpc_hostport() const {</a>
<a name="ln1928">  CHECK(status_);</a>
<a name="ln1929">  CHECK_GE(status_-&gt;bound_rpc_addresses_size(), 1);</a>
<a name="ln1930">  return HostPortFromPB(status_-&gt;bound_rpc_addresses(0));</a>
<a name="ln1931">}</a>
<a name="ln1932"> </a>
<a name="ln1933">HostPort ExternalDaemon::bound_rpc_addr() const {</a>
<a name="ln1934">  return bound_rpc_hostport();</a>
<a name="ln1935">}</a>
<a name="ln1936"> </a>
<a name="ln1937">HostPort ExternalDaemon::bound_http_hostport() const {</a>
<a name="ln1938">  CHECK(status_);</a>
<a name="ln1939">  CHECK_GE(status_-&gt;bound_http_addresses_size(), 1);</a>
<a name="ln1940">  return HostPortFromPB(status_-&gt;bound_http_addresses(0));</a>
<a name="ln1941">}</a>
<a name="ln1942"> </a>
<a name="ln1943">const NodeInstancePB&amp; ExternalDaemon::instance_id() const {</a>
<a name="ln1944">  CHECK(status_);</a>
<a name="ln1945">  return status_-&gt;node_instance();</a>
<a name="ln1946">}</a>
<a name="ln1947"> </a>
<a name="ln1948">const string&amp; ExternalDaemon::uuid() const {</a>
<a name="ln1949">  CHECK(status_);</a>
<a name="ln1950">  return status_-&gt;node_instance().permanent_uuid();</a>
<a name="ln1951">}</a>
<a name="ln1952"> </a>
<a name="ln1953">Result&lt;int64_t&gt; ExternalDaemon::GetInt64MetricFromHost(const HostPort&amp; hostport,</a>
<a name="ln1954">                                                       const MetricEntityPrototype* entity_proto,</a>
<a name="ln1955">                                                       const char* entity_id,</a>
<a name="ln1956">                                                       const MetricPrototype* metric_proto,</a>
<a name="ln1957">                                                       const char* value_field) {</a>
<a name="ln1958">  return GetInt64MetricFromHost(hostport, entity_proto-&gt;name(), entity_id, metric_proto-&gt;name(),</a>
<a name="ln1959">                                value_field);</a>
<a name="ln1960">}</a>
<a name="ln1961"> </a>
<a name="ln1962">Result&lt;int64_t&gt; ExternalDaemon::GetInt64MetricFromHost(const HostPort&amp; hostport,</a>
<a name="ln1963">                                                       const char* entity_proto_name,</a>
<a name="ln1964">                                                       const char* entity_id,</a>
<a name="ln1965">                                                       const char* metric_proto_name,</a>
<a name="ln1966">                                                       const char* value_field) {</a>
<a name="ln1967">  // Fetch metrics whose name matches the given prototype.</a>
<a name="ln1968">  string url = Substitute(</a>
<a name="ln1969">      &quot;http://$0/jsonmetricz?metrics=$1&quot;,</a>
<a name="ln1970">      hostport.ToString(),</a>
<a name="ln1971">      metric_proto_name);</a>
<a name="ln1972">  EasyCurl curl;</a>
<a name="ln1973">  faststring dst;</a>
<a name="ln1974">  RETURN_NOT_OK(curl.FetchURL(url, &amp;dst));</a>
<a name="ln1975"> </a>
<a name="ln1976">  // Parse the results, beginning with the top-level entity array.</a>
<a name="ln1977">  JsonReader r(dst.ToString());</a>
<a name="ln1978">  RETURN_NOT_OK(r.Init());</a>
<a name="ln1979">  vector&lt;const Value*&gt; entities;</a>
<a name="ln1980">  RETURN_NOT_OK(r.ExtractObjectArray(r.root(), NULL, &amp;entities));</a>
<a name="ln1981">  for (const Value* entity : entities) {</a>
<a name="ln1982">    // Find the desired entity.</a>
<a name="ln1983">    string type;</a>
<a name="ln1984">    RETURN_NOT_OK(r.ExtractString(entity, &quot;type&quot;, &amp;type));</a>
<a name="ln1985">    if (type != entity_proto_name) {</a>
<a name="ln1986">      continue;</a>
<a name="ln1987">    }</a>
<a name="ln1988">    if (entity_id) {</a>
<a name="ln1989">      string id;</a>
<a name="ln1990">      RETURN_NOT_OK(r.ExtractString(entity, &quot;id&quot;, &amp;id));</a>
<a name="ln1991">      if (id != entity_id) {</a>
<a name="ln1992">        continue;</a>
<a name="ln1993">      }</a>
<a name="ln1994">    }</a>
<a name="ln1995"> </a>
<a name="ln1996">    // Find the desired metric within the entity.</a>
<a name="ln1997">    vector&lt;const Value*&gt; metrics;</a>
<a name="ln1998">    RETURN_NOT_OK(r.ExtractObjectArray(entity, &quot;metrics&quot;, &amp;metrics));</a>
<a name="ln1999">    for (const Value* metric : metrics) {</a>
<a name="ln2000">      string name;</a>
<a name="ln2001">      RETURN_NOT_OK(r.ExtractString(metric, &quot;name&quot;, &amp;name));</a>
<a name="ln2002">      if (name != metric_proto_name) {</a>
<a name="ln2003">        continue;</a>
<a name="ln2004">      }</a>
<a name="ln2005">      int64_t value;</a>
<a name="ln2006">      RETURN_NOT_OK(r.ExtractInt64(metric, value_field, &amp;value));</a>
<a name="ln2007">      return value;</a>
<a name="ln2008">    }</a>
<a name="ln2009">  }</a>
<a name="ln2010">  string msg;</a>
<a name="ln2011">  if (entity_id) {</a>
<a name="ln2012">    msg = Substitute(&quot;Could not find metric $0.$1 for entity $2&quot;,</a>
<a name="ln2013">                     entity_proto_name, metric_proto_name,</a>
<a name="ln2014">                     entity_id);</a>
<a name="ln2015">  } else {</a>
<a name="ln2016">    msg = Substitute(&quot;Could not find metric $0.$1&quot;,</a>
<a name="ln2017">                     entity_proto_name, metric_proto_name);</a>
<a name="ln2018">  }</a>
<a name="ln2019">  return STATUS(NotFound, msg);</a>
<a name="ln2020">}</a>
<a name="ln2021"> </a>
<a name="ln2022">string ExternalDaemon::LogPrefix() {</a>
<a name="ln2023">  return Format(&quot;{ daemon_id: $0 bound_rpc: $1 } &quot;, daemon_id_, bound_rpc_);</a>
<a name="ln2024">}</a>
<a name="ln2025"> </a>
<a name="ln2026">void ExternalDaemon::SetLogListener(StringListener* listener) {</a>
<a name="ln2027">  stdout_tailer_thread_-&gt;SetListener(listener);</a>
<a name="ln2028">  stderr_tailer_thread_-&gt;SetListener(listener);</a>
<a name="ln2029">}</a>
<a name="ln2030"> </a>
<a name="ln2031">void ExternalDaemon::RemoveLogListener(StringListener* listener) {</a>
<a name="ln2032">  stdout_tailer_thread_-&gt;RemoveListener(listener);</a>
<a name="ln2033">  stderr_tailer_thread_-&gt;RemoveListener(listener);</a>
<a name="ln2034">}</a>
<a name="ln2035"> </a>
<a name="ln2036">Result&lt;string&gt; ExternalDaemon::GetFlag(const std::string&amp; flag) {</a>
<a name="ln2037">  server::GenericServiceProxy proxy(proxy_cache_, bound_rpc_addr());</a>
<a name="ln2038"> </a>
<a name="ln2039">  rpc::RpcController controller;</a>
<a name="ln2040">  controller.set_timeout(MonoDelta::FromSeconds(30));</a>
<a name="ln2041">  server::GetFlagRequestPB req;</a>
<a name="ln2042">  server::GetFlagResponsePB resp;</a>
<a name="ln2043">  req.set_flag(flag);</a>
<a name="ln2044">  RETURN_NOT_OK(proxy.GetFlag(req, &amp;resp, &amp;controller));</a>
<a name="ln2045">  if (!resp.valid()) {</a>
<a name="ln2046">    return STATUS_FORMAT(RemoteError, &quot;Failed to get gflag $0 value.&quot;, flag);</a>
<a name="ln2047">  }</a>
<a name="ln2048">  return resp.value();</a>
<a name="ln2049">}</a>
<a name="ln2050"> </a>
<a name="ln2051">LogWaiter::LogWaiter(ExternalDaemon* daemon, const std::string&amp; string_to_wait) :</a>
<a name="ln2052">    daemon_(daemon), string_to_wait_(string_to_wait) {</a>
<a name="ln2053">  daemon_-&gt;SetLogListener(this);</a>
<a name="ln2054">}</a>
<a name="ln2055"> </a>
<a name="ln2056">void LogWaiter::Handle(const GStringPiece&amp; s) {</a>
<a name="ln2057">  if (s.contains(string_to_wait_)) {</a>
<a name="ln2058">    event_occurred_ = true;</a>
<a name="ln2059">  }</a>
<a name="ln2060">}</a>
<a name="ln2061"> </a>
<a name="ln2062">Status LogWaiter::WaitFor(const MonoDelta timeout) {</a>
<a name="ln2063">  constexpr auto kInitialWaitPeriod = 100ms;</a>
<a name="ln2064">  return ::yb::WaitFor(</a>
<a name="ln2065">      [this]{ return event_occurred_.load(); }, timeout,</a>
<a name="ln2066">      Format(&quot;Waiting for log record '$0' on $1...&quot;, string_to_wait_, daemon_-&gt;id()),</a>
<a name="ln2067">      kInitialWaitPeriod);</a>
<a name="ln2068">}</a>
<a name="ln2069"> </a>
<a name="ln2070">LogWaiter::~LogWaiter() {</a>
<a name="ln2071">  daemon_-&gt;RemoveLogListener(this);</a>
<a name="ln2072">}</a>
<a name="ln2073"> </a>
<a name="ln2074">//------------------------------------------------------------</a>
<a name="ln2075">// ScopedResumeExternalDaemon</a>
<a name="ln2076">//------------------------------------------------------------</a>
<a name="ln2077"> </a>
<a name="ln2078">ScopedResumeExternalDaemon::ScopedResumeExternalDaemon(ExternalDaemon* daemon)</a>
<a name="ln2079">    : daemon_(CHECK_NOTNULL(daemon)) {</a>
<a name="ln2080">}</a>
<a name="ln2081"> </a>
<a name="ln2082">ScopedResumeExternalDaemon::~ScopedResumeExternalDaemon() {</a>
<a name="ln2083">  CHECK_OK(daemon_-&gt;Resume());</a>
<a name="ln2084">}</a>
<a name="ln2085"> </a>
<a name="ln2086">//------------------------------------------------------------</a>
<a name="ln2087">// ExternalMaster</a>
<a name="ln2088">//------------------------------------------------------------</a>
<a name="ln2089">ExternalMaster::ExternalMaster(</a>
<a name="ln2090">    int master_index,</a>
<a name="ln2091">    rpc::Messenger* messenger,</a>
<a name="ln2092">    rpc::ProxyCache* proxy_cache,</a>
<a name="ln2093">    const string&amp; exe,</a>
<a name="ln2094">    const string&amp; data_dir,</a>
<a name="ln2095">    const std::vector&lt;string&gt;&amp; extra_flags,</a>
<a name="ln2096">    const string&amp; rpc_bind_address,</a>
<a name="ln2097">    uint16_t http_port,</a>
<a name="ln2098">    const string&amp; master_addrs)</a>
<a name="ln2099">    : ExternalDaemon(</a>
<a name="ln2100">          Substitute(&quot;m-$0&quot;, master_index + 1), messenger, proxy_cache, exe, data_dir, &quot;master&quot;,</a>
<a name="ln2101">          extra_flags),</a>
<a name="ln2102">      rpc_bind_address_(rpc_bind_address),</a>
<a name="ln2103">      master_addrs_(master_addrs),</a>
<a name="ln2104">      http_port_(http_port) {</a>
<a name="ln2105">}</a>
<a name="ln2106"> </a>
<a name="ln2107">ExternalMaster::~ExternalMaster() {</a>
<a name="ln2108">}</a>
<a name="ln2109"> </a>
<a name="ln2110">namespace {</a>
<a name="ln2111"> </a>
<a name="ln2112">class Flags {</a>
<a name="ln2113"> public:</a>
<a name="ln2114">  template &lt;class Value&gt;</a>
<a name="ln2115">  void Add(const std::string&amp; name, const Value&amp; value) {</a>
<a name="ln2116">    value_.push_back(Format(&quot;--$0=$1&quot;, name, value));</a>
<a name="ln2117">  }</a>
<a name="ln2118"> </a>
<a name="ln2119">  void AddHostPort(const std::string&amp; name, const std::string&amp; host, uint16_t port) {</a>
<a name="ln2120">    Add(name, HostPort(host, port));</a>
<a name="ln2121">  }</a>
<a name="ln2122"> </a>
<a name="ln2123">  const std::vector&lt;std::string&gt;&amp; value() const {</a>
<a name="ln2124">    return value_;</a>
<a name="ln2125">  }</a>
<a name="ln2126"> </a>
<a name="ln2127"> private:</a>
<a name="ln2128">  std::vector&lt;std::string&gt; value_;</a>
<a name="ln2129">};</a>
<a name="ln2130"> </a>
<a name="ln2131">} // namespace</a>
<a name="ln2132"> </a>
<a name="ln2133">Status ExternalMaster::Start(bool shell_mode) {</a>
<a name="ln2134">  Flags flags;</a>
<a name="ln2135">  flags.Add(&quot;fs_data_dirs&quot;, data_dir_);</a>
<a name="ln2136">  flags.Add(&quot;rpc_bind_addresses&quot;, rpc_bind_address_);</a>
<a name="ln2137">  flags.Add(&quot;webserver_interface&quot;, &quot;localhost&quot;);</a>
<a name="ln2138">  flags.Add(&quot;webserver_port&quot;, http_port_);</a>
<a name="ln2139">  // Default master args to make sure we don't wait to trigger new LB tasks upon master leader</a>
<a name="ln2140">  // failover.</a>
<a name="ln2141">  flags.Add(&quot;load_balancer_initial_delay_secs&quot;, 0);</a>
<a name="ln2142">  // On first start, we need to tell the masters their list of expected peers.</a>
<a name="ln2143">  // For 'shell' master, there is no master addresses.</a>
<a name="ln2144">  if (!shell_mode) {</a>
<a name="ln2145">    flags.Add(&quot;master_addresses&quot;, master_addrs_);</a>
<a name="ln2146">  }</a>
<a name="ln2147">  RETURN_NOT_OK(StartProcess(flags.value()));</a>
<a name="ln2148">  return Status::OK();</a>
<a name="ln2149">}</a>
<a name="ln2150"> </a>
<a name="ln2151">Status ExternalMaster::Restart() {</a>
<a name="ln2152">  LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Restart()&quot;;</a>
<a name="ln2153">  if (!IsProcessAlive()) {</a>
<a name="ln2154">    // Make sure this function could be safely called if the process has already crashed.</a>
<a name="ln2155">    Shutdown();</a>
<a name="ln2156">  }</a>
<a name="ln2157">  // We store the addresses on shutdown so make sure we did that first.</a>
<a name="ln2158">  if (bound_rpc_.port() == 0) {</a>
<a name="ln2159">    return STATUS(IllegalState, &quot;Master cannot be restarted. Must call Shutdown() first.&quot;);</a>
<a name="ln2160">  }</a>
<a name="ln2161">  return Start(true);</a>
<a name="ln2162">}</a>
<a name="ln2163"> </a>
<a name="ln2164">//------------------------------------------------------------</a>
<a name="ln2165">// ExternalTabletServer</a>
<a name="ln2166">//------------------------------------------------------------</a>
<a name="ln2167"> </a>
<a name="ln2168">ExternalTabletServer::ExternalTabletServer(</a>
<a name="ln2169">    int tablet_server_index, rpc::Messenger* messenger, rpc::ProxyCache* proxy_cache,</a>
<a name="ln2170">    const std::string&amp; exe, const std::string&amp; data_dir, std::string bind_host, uint16_t rpc_port,</a>
<a name="ln2171">    uint16_t http_port, uint16_t redis_rpc_port, uint16_t redis_http_port,</a>
<a name="ln2172">    uint16_t cql_rpc_port, uint16_t cql_http_port,</a>
<a name="ln2173">    uint16_t pgsql_rpc_port, uint16_t pgsql_http_port,</a>
<a name="ln2174">    const std::vector&lt;HostPort&gt;&amp; master_addrs, const std::vector&lt;std::string&gt;&amp; extra_flags)</a>
<a name="ln2175">    : ExternalDaemon(</a>
<a name="ln2176">          Substitute(&quot;ts-$0&quot;, tablet_server_index + 1), messenger, proxy_cache, exe, data_dir,</a>
<a name="ln2177">          &quot;tserver&quot;, extra_flags),</a>
<a name="ln2178">      master_addrs_(HostPort::ToCommaSeparatedString(master_addrs)),</a>
<a name="ln2179">      bind_host_(std::move(bind_host)),</a>
<a name="ln2180">      rpc_port_(rpc_port),</a>
<a name="ln2181">      http_port_(http_port),</a>
<a name="ln2182">      redis_rpc_port_(redis_rpc_port),</a>
<a name="ln2183">      redis_http_port_(redis_http_port),</a>
<a name="ln2184">      pgsql_rpc_port_(pgsql_rpc_port),</a>
<a name="ln2185">      pgsql_http_port_(pgsql_http_port),</a>
<a name="ln2186">      cql_rpc_port_(cql_rpc_port),</a>
<a name="ln2187">      cql_http_port_(cql_http_port) {}</a>
<a name="ln2188"> </a>
<a name="ln2189">ExternalTabletServer::~ExternalTabletServer() {</a>
<a name="ln2190">}</a>
<a name="ln2191"> </a>
<a name="ln2192">Status ExternalTabletServer::Start(bool start_cql_proxy, bool set_proxy_addrs) {</a>
<a name="ln2193">  start_cql_proxy_ = start_cql_proxy;</a>
<a name="ln2194">  Flags flags;</a>
<a name="ln2195">  flags.Add(&quot;fs_data_dirs&quot;, data_dir_);</a>
<a name="ln2196">  flags.AddHostPort(&quot;rpc_bind_addresses&quot;, bind_host_, rpc_port_);</a>
<a name="ln2197">  flags.Add(&quot;webserver_interface&quot;, bind_host_);</a>
<a name="ln2198">  flags.Add(&quot;webserver_port&quot;, http_port_);</a>
<a name="ln2199">  flags.Add(&quot;redis_proxy_webserver_port&quot;, redis_http_port_);</a>
<a name="ln2200">  flags.Add(&quot;pgsql_proxy_webserver_port&quot;, pgsql_http_port_);</a>
<a name="ln2201">  flags.Add(&quot;cql_proxy_webserver_port&quot;, cql_http_port_);</a>
<a name="ln2202"> </a>
<a name="ln2203">  if (set_proxy_addrs) {</a>
<a name="ln2204">    flags.AddHostPort(&quot;redis_proxy_bind_address&quot;, bind_host_, redis_rpc_port_);</a>
<a name="ln2205">    flags.AddHostPort(&quot;pgsql_proxy_bind_address&quot;, bind_host_, pgsql_rpc_port_);</a>
<a name="ln2206">    flags.AddHostPort(&quot;cql_proxy_bind_address&quot;, bind_host_, cql_rpc_port_);</a>
<a name="ln2207">  }</a>
<a name="ln2208"> </a>
<a name="ln2209">  flags.Add(&quot;start_cql_proxy&quot;, start_cql_proxy_);</a>
<a name="ln2210">  flags.Add(&quot;tserver_master_addrs&quot;, master_addrs_);</a>
<a name="ln2211"> </a>
<a name="ln2212">  // Use conservative number of threads for the mini cluster for unit test env</a>
<a name="ln2213">  // where several unit tests tend to run in parallel.</a>
<a name="ln2214">  flags.Add(&quot;tablet_server_svc_num_threads&quot;, &quot;64&quot;);</a>
<a name="ln2215">  flags.Add(&quot;ts_consensus_svc_num_threads&quot;, &quot;20&quot;);</a>
<a name="ln2216"> </a>
<a name="ln2217">  RETURN_NOT_OK(StartProcess(flags.value()));</a>
<a name="ln2218"> </a>
<a name="ln2219">  return Status::OK();</a>
<a name="ln2220">}</a>
<a name="ln2221"> </a>
<a name="ln2222">Status ExternalTabletServer::BuildServerStateFromInfoPath() {</a>
<a name="ln2223">  RETURN_NOT_OK(ExternalDaemon::BuildServerStateFromInfoPath());</a>
<a name="ln2224">  if (start_cql_proxy_) {</a>
<a name="ln2225">    RETURN_NOT_OK(ExternalDaemon::BuildServerStateFromInfoPath(GetCQLServerInfoPath(),</a>
<a name="ln2226">                                                               &amp;cqlserver_status_));</a>
<a name="ln2227">  }</a>
<a name="ln2228">  return Status::OK();</a>
<a name="ln2229">}</a>
<a name="ln2230"> </a>
<a name="ln2231">string ExternalTabletServer::GetCQLServerInfoPath() {</a>
<a name="ln2232">  return ExternalDaemon::GetServerInfoPath() + &quot;-cql&quot;;</a>
<a name="ln2233">}</a>
<a name="ln2234"> </a>
<a name="ln2235">bool ExternalTabletServer::ServerInfoPathsExist() {</a>
<a name="ln2236">  if (start_cql_proxy_) {</a>
<a name="ln2237">    return ExternalDaemon::ServerInfoPathsExist() &amp;&amp;</a>
<a name="ln2238">        Env::Default()-&gt;FileExists(GetCQLServerInfoPath());</a>
<a name="ln2239">  }</a>
<a name="ln2240">  return ExternalDaemon::ServerInfoPathsExist();</a>
<a name="ln2241">}</a>
<a name="ln2242"> </a>
<a name="ln2243">Status ExternalTabletServer::DeleteServerInfoPaths() {</a>
<a name="ln2244">  // We want to try a deletion for both files.</a>
<a name="ln2245">  Status s1 = ExternalDaemon::DeleteServerInfoPaths();</a>
<a name="ln2246">  Status s2 = Env::Default()-&gt;DeleteFile(GetCQLServerInfoPath());</a>
<a name="ln2247">  RETURN_NOT_OK(s1);</a>
<a name="ln2248">  RETURN_NOT_OK(s2);</a>
<a name="ln2249">  return Status::OK();</a>
<a name="ln2250">}</a>
<a name="ln2251"> </a>
<a name="ln2252">Status ExternalTabletServer::Restart(bool start_cql_proxy) {</a>
<a name="ln2253">  LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Restart: start_cql_proxy=&quot; &lt;&lt; start_cql_proxy;</a>
<a name="ln2254">  if (!IsProcessAlive()) {</a>
<a name="ln2255">    // Make sure this function could be safely called if the process has already crashed.</a>
<a name="ln2256">    Shutdown();</a>
<a name="ln2257">  }</a>
<a name="ln2258">  // We store the addresses on shutdown so make sure we did that first.</a>
<a name="ln2259">  if (bound_rpc_.port() == 0) {</a>
<a name="ln2260">    return STATUS(IllegalState, &quot;Tablet server cannot be restarted. Must call Shutdown() first.&quot;);</a>
<a name="ln2261">  }</a>
<a name="ln2262">  return Start(start_cql_proxy);</a>
<a name="ln2263">}</a>
<a name="ln2264"> </a>
<a name="ln2265">}  // namespace yb</a>

</code></pre>
<div class="balloon" rel="313"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="315"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="402"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="433"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="692"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v779/" target="_blank">V779</a> Unreachable code detected. It is possible that an error is present.</p></div>
<div class="balloon" rel="1058"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1150"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1432"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1531"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1575"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1593"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1672"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1808"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1816"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1822"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1928"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1938"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1944"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1949"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="2083"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
