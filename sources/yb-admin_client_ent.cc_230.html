
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>yb-admin_client_ent.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Copyright (c) YugaByte, Inc.</a>
<a name="ln2">//</a>
<a name="ln3">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln4">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln5">//</a>
<a name="ln6">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln7">//</a>
<a name="ln8">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln9">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln10">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln11">// under the License.</a>
<a name="ln12"> </a>
<a name="ln13">#include &quot;yb/tools/yb-admin_client.h&quot;</a>
<a name="ln14"> </a>
<a name="ln15">#include &lt;iostream&gt;</a>
<a name="ln16"> </a>
<a name="ln17">#include &lt;boost/algorithm/string.hpp&gt;</a>
<a name="ln18"> </a>
<a name="ln19">#include &quot;yb/cdc/cdc_service.h&quot;</a>
<a name="ln20">#include &quot;yb/cdc/cdc_service.proxy.h&quot;</a>
<a name="ln21">#include &quot;yb/client/client.h&quot;</a>
<a name="ln22">#include &quot;yb/common/snapshot.h&quot;</a>
<a name="ln23">#include &quot;yb/common/wire_protocol.h&quot;</a>
<a name="ln24">#include &quot;yb/gutil/strings/util.h&quot;</a>
<a name="ln25">#include &quot;yb/master/master_defaults.h&quot;</a>
<a name="ln26">#include &quot;yb/rpc/messenger.h&quot;</a>
<a name="ln27">#include &quot;yb/tools/yb-admin_util.h&quot;</a>
<a name="ln28">#include &quot;yb/util/cast.h&quot;</a>
<a name="ln29">#include &quot;yb/util/env.h&quot;</a>
<a name="ln30">#include &quot;yb/util/jsonwriter.h&quot;</a>
<a name="ln31">#include &quot;yb/util/monotime.h&quot;</a>
<a name="ln32">#include &quot;yb/util/pb_util.h&quot;</a>
<a name="ln33">#include &quot;yb/util/protobuf_util.h&quot;</a>
<a name="ln34">#include &quot;yb/util/string_util.h&quot;</a>
<a name="ln35">#include &quot;yb/util/encryption_util.h&quot;</a>
<a name="ln36"> </a>
<a name="ln37">DECLARE_bool(use_client_to_server_encryption);</a>
<a name="ln38">DECLARE_int32(yb_client_admin_operation_timeout_sec);</a>
<a name="ln39"> </a>
<a name="ln40">namespace yb {</a>
<a name="ln41"> </a>
<a name="ln42">using enterprise::EncryptionParams;</a>
<a name="ln43"> </a>
<a name="ln44">namespace tools {</a>
<a name="ln45">namespace enterprise {</a>
<a name="ln46"> </a>
<a name="ln47">using namespace std::literals;</a>
<a name="ln48"> </a>
<a name="ln49">using std::cout;</a>
<a name="ln50">using std::endl;</a>
<a name="ln51">using std::string;</a>
<a name="ln52">using std::vector;</a>
<a name="ln53"> </a>
<a name="ln54">using google::protobuf::RepeatedPtrField;</a>
<a name="ln55"> </a>
<a name="ln56">using client::YBTableName;</a>
<a name="ln57">using pb_util::ParseFromSlice;</a>
<a name="ln58">using rpc::RpcController;</a>
<a name="ln59"> </a>
<a name="ln60">using master::ChangeEncryptionInfoRequestPB;</a>
<a name="ln61">using master::ChangeEncryptionInfoResponsePB;</a>
<a name="ln62">using master::CreateSnapshotRequestPB;</a>
<a name="ln63">using master::CreateSnapshotResponsePB;</a>
<a name="ln64">using master::DeleteSnapshotRequestPB;</a>
<a name="ln65">using master::DeleteSnapshotResponsePB;</a>
<a name="ln66">using master::IdPairPB;</a>
<a name="ln67">using master::ImportSnapshotMetaRequestPB;</a>
<a name="ln68">using master::ImportSnapshotMetaResponsePB;</a>
<a name="ln69">using master::ImportSnapshotMetaResponsePB_TableMetaPB;</a>
<a name="ln70">using master::IsCreateTableDoneRequestPB;</a>
<a name="ln71">using master::IsCreateTableDoneResponsePB;</a>
<a name="ln72">using master::ListSnapshotRestorationsRequestPB;</a>
<a name="ln73">using master::ListSnapshotRestorationsResponsePB;</a>
<a name="ln74">using master::ListSnapshotsRequestPB;</a>
<a name="ln75">using master::ListSnapshotsResponsePB;</a>
<a name="ln76">using master::ListTablesRequestPB;</a>
<a name="ln77">using master::ListTablesResponsePB;</a>
<a name="ln78">using master::ListTabletServersRequestPB;</a>
<a name="ln79">using master::ListTabletServersResponsePB;</a>
<a name="ln80">using master::RestoreSnapshotRequestPB;</a>
<a name="ln81">using master::RestoreSnapshotResponsePB;</a>
<a name="ln82">using master::SnapshotInfoPB;</a>
<a name="ln83">using master::SysNamespaceEntryPB;</a>
<a name="ln84">using master::SysRowEntry;</a>
<a name="ln85">using master::SysTablesEntryPB;</a>
<a name="ln86">using master::SysSnapshotEntryPB;</a>
<a name="ln87"> </a>
<a name="ln88">PB_ENUM_FORMATTERS(yb::master::SysSnapshotEntryPB::State);</a>
<a name="ln89"> </a>
<a name="ln90">Status ClusterAdminClient::ListSnapshots(bool show_details, bool show_restored, bool show_deleted) {</a>
<a name="ln91">  RpcController rpc;</a>
<a name="ln92">  rpc.set_timeout(timeout_);</a>
<a name="ln93">  ListSnapshotsRequestPB req;</a>
<a name="ln94">  req.set_list_deleted_snapshots(show_deleted);</a>
<a name="ln95">  ListSnapshotsResponsePB resp;</a>
<a name="ln96">  RETURN_NOT_OK(master_backup_proxy_-&gt;ListSnapshots(req, &amp;resp, &amp;rpc));</a>
<a name="ln97"> </a>
<a name="ln98">  if (resp.has_error()) {</a>
<a name="ln99">    return StatusFromPB(resp.error().status());</a>
<a name="ln100">  }</a>
<a name="ln101"> </a>
<a name="ln102">  if (resp.has_current_snapshot_id()) {</a>
<a name="ln103">    cout &lt;&lt; &quot;Current snapshot id: &quot; &lt;&lt; SnapshotIdToString(resp.current_snapshot_id()) &lt;&lt; endl;</a>
<a name="ln104">  }</a>
<a name="ln105"> </a>
<a name="ln106">  if (resp.snapshots_size()) {</a>
<a name="ln107">    cout &lt;&lt; RightPadToUuidWidth(&quot;Snapshot UUID&quot;) &lt;&lt; kColumnSep &lt;&lt; &quot;State&quot; &lt;&lt; endl;</a>
<a name="ln108">  } else {</a>
<a name="ln109">    cout &lt;&lt; &quot;No snapshots&quot; &lt;&lt; endl;</a>
<a name="ln110">  }</a>
<a name="ln111"> </a>
<a name="ln112">  for (SnapshotInfoPB&amp; snapshot : *resp.mutable_snapshots()) {</a>
<a name="ln113">    cout &lt;&lt; SnapshotIdToString(snapshot.id()) &lt;&lt; kColumnSep &lt;&lt; snapshot.entry().state() &lt;&lt; endl;</a>
<a name="ln114"> </a>
<a name="ln115">    if (show_details) {</a>
<a name="ln116">      for (SysRowEntry&amp; entry : *snapshot.mutable_entry()-&gt;mutable_entries()) {</a>
<a name="ln117">        string decoded_data;</a>
<a name="ln118">        switch (entry.type()) {</a>
<a name="ln119">          case SysRowEntry::NAMESPACE: {</a>
<a name="ln120">            auto meta = VERIFY_RESULT(ParseFromSlice&lt;SysNamespaceEntryPB&gt;(entry.data()));</a>
<a name="ln121">            decoded_data = JsonWriter::ToJson(meta, JsonWriter::COMPACT);</a>
<a name="ln122">            break;</a>
<a name="ln123">          }</a>
<a name="ln124">          case SysRowEntry::TABLE: {</a>
<a name="ln125">            auto meta = VERIFY_RESULT(ParseFromSlice&lt;SysTablesEntryPB&gt;(entry.data()));</a>
<a name="ln126">            meta.clear_schema();</a>
<a name="ln127">            meta.clear_partition_schema();</a>
<a name="ln128">            meta.clear_index_info();</a>
<a name="ln129">            meta.clear_indexes();</a>
<a name="ln130">            decoded_data = JsonWriter::ToJson(meta, JsonWriter::COMPACT);</a>
<a name="ln131">            break;</a>
<a name="ln132">          }</a>
<a name="ln133">          default:</a>
<a name="ln134">            break;</a>
<a name="ln135">        }</a>
<a name="ln136"> </a>
<a name="ln137">        if (!decoded_data.empty()) {</a>
<a name="ln138">          entry.set_data(&quot;DATA&quot;);</a>
<a name="ln139">          cout &lt;&lt; kColumnSep &lt;&lt; StringReplace(JsonWriter::ToJson(entry, JsonWriter::COMPACT),</a>
<a name="ln140">                                              &quot;\&quot;DATA\&quot;&quot;, decoded_data, false) &lt;&lt; endl;</a>
<a name="ln141">        }</a>
<a name="ln142">      }</a>
<a name="ln143">    }</a>
<a name="ln144">  }</a>
<a name="ln145"> </a>
<a name="ln146">  rpc.Reset();</a>
<a name="ln147">  rpc.set_timeout(timeout_);</a>
<a name="ln148">  ListSnapshotRestorationsRequestPB rest_req;</a>
<a name="ln149">  ListSnapshotRestorationsResponsePB rest_resp;</a>
<a name="ln150">  RETURN_NOT_OK(master_backup_proxy_-&gt;ListSnapshotRestorations(rest_req, &amp;rest_resp, &amp;rpc));</a>
<a name="ln151"> </a>
<a name="ln152">  if (rest_resp.restorations_size() == 0) {</a>
<a name="ln153">    cout &lt;&lt; &quot;No snapshot restorations&quot; &lt;&lt; endl;</a>
<a name="ln154">  } else if (!show_restored) {</a>
<a name="ln155">    cout &lt;&lt; &quot;Not show fully RESTORED entries&quot; &lt;&lt; endl;</a>
<a name="ln156">  }</a>
<a name="ln157"> </a>
<a name="ln158">  bool title_printed = false;</a>
<a name="ln159">  for (const SnapshotInfoPB&amp; snapshot : rest_resp.restorations()) {</a>
<a name="ln160">    if (show_restored || snapshot.entry().state() != SysSnapshotEntryPB::RESTORED) {</a>
<a name="ln161">      if (!title_printed) {</a>
<a name="ln162">        cout &lt;&lt; RightPadToUuidWidth(&quot;Restoration UUID&quot;) &lt;&lt; kColumnSep &lt;&lt; &quot;State&quot; &lt;&lt; endl;</a>
<a name="ln163">        title_printed = true;</a>
<a name="ln164">      }</a>
<a name="ln165">      cout &lt;&lt; SnapshotIdToString(snapshot.id()) &lt;&lt; kColumnSep &lt;&lt; snapshot.entry().state() &lt;&lt; endl;</a>
<a name="ln166">    }</a>
<a name="ln167">  }</a>
<a name="ln168"> </a>
<a name="ln169">  return Status::OK();</a>
<a name="ln170">}</a>
<a name="ln171"> </a>
<a name="ln172">Status ClusterAdminClient::CreateSnapshot(</a>
<a name="ln173">    const vector&lt;YBTableName&gt;&amp; tables,</a>
<a name="ln174">    const bool add_indexes,</a>
<a name="ln175">    const int flush_timeout_secs) {</a>
<a name="ln176"> </a>
<a name="ln177">  if (flush_timeout_secs &gt; 0) {</a>
<a name="ln178">    const auto status = FlushTables(tables, add_indexes, flush_timeout_secs, false);</a>
<a name="ln179">    if (status.IsTimedOut()) {</a>
<a name="ln180">      cout &lt;&lt; status.ToString(false) &lt;&lt; &quot; (ignored)&quot; &lt;&lt; endl;</a>
<a name="ln181">    } else if (!status.ok() &amp;&amp; !status.IsNotFound()) {</a>
<a name="ln182">      return status;</a>
<a name="ln183">    }</a>
<a name="ln184">  }</a>
<a name="ln185"> </a>
<a name="ln186">  RpcController rpc;</a>
<a name="ln187">  rpc.set_timeout(timeout_);</a>
<a name="ln188">  CreateSnapshotRequestPB req;</a>
<a name="ln189">  CreateSnapshotResponsePB resp;</a>
<a name="ln190"> </a>
<a name="ln191">  for (const YBTableName&amp; table_name : tables) {</a>
<a name="ln192">    table_name.SetIntoTableIdentifierPB(req.add_tables());</a>
<a name="ln193">  }</a>
<a name="ln194"> </a>
<a name="ln195">  req.set_add_indexes(add_indexes);</a>
<a name="ln196">  req.set_transaction_aware(true);</a>
<a name="ln197">  RETURN_NOT_OK(master_backup_proxy_-&gt;CreateSnapshot(req, &amp;resp, &amp;rpc));</a>
<a name="ln198"> </a>
<a name="ln199">  if (resp.has_error()) {</a>
<a name="ln200">    return StatusFromPB(resp.error().status());</a>
<a name="ln201">  }</a>
<a name="ln202"> </a>
<a name="ln203">  cout &lt;&lt; &quot;Started snapshot creation: &quot; &lt;&lt; SnapshotIdToString(resp.snapshot_id()) &lt;&lt; endl;</a>
<a name="ln204">  return Status::OK();</a>
<a name="ln205">}</a>
<a name="ln206"> </a>
<a name="ln207">Status ClusterAdminClient::CreateNamespaceSnapshot(const TypedNamespaceName&amp; ns) {</a>
<a name="ln208">  RpcController rpc;</a>
<a name="ln209">  rpc.set_timeout(timeout_);</a>
<a name="ln210">  ListTablesRequestPB req;</a>
<a name="ln211">  ListTablesResponsePB resp;</a>
<a name="ln212"> </a>
<a name="ln213">  req.mutable_namespace_()-&gt;set_name(ns.name);</a>
<a name="ln214">  req.mutable_namespace_()-&gt;set_database_type(ns.db_type);</a>
<a name="ln215">  req.set_exclude_system_tables(true);</a>
<a name="ln216">  req.add_relation_type_filter(master::USER_TABLE_RELATION);</a>
<a name="ln217">  req.add_relation_type_filter(master::INDEX_TABLE_RELATION);</a>
<a name="ln218">  RETURN_NOT_OK(master_proxy_-&gt;ListTables(req, &amp;resp, &amp;rpc));</a>
<a name="ln219"> </a>
<a name="ln220">  if (resp.has_error()) {</a>
<a name="ln221">    cout &lt;&lt; &quot;Error getting tables from namespace: &quot; &lt;&lt; resp.error().status().message() &lt;&lt; endl;</a>
<a name="ln222">    return StatusFromPB(resp.error().status());</a>
<a name="ln223">  }</a>
<a name="ln224"> </a>
<a name="ln225">  if (resp.tables_size() == 0) {</a>
<a name="ln226">    return STATUS_FORMAT(InvalidArgument, &quot;No tables found in namespace: $0&quot;, ns.name);</a>
<a name="ln227">  }</a>
<a name="ln228"> </a>
<a name="ln229">  vector&lt;YBTableName&gt; tables(resp.tables_size());</a>
<a name="ln230">  for (int i = 0; i &lt; resp.tables_size(); ++i) {</a>
<a name="ln231">    const auto&amp; table = resp.tables(i);</a>
<a name="ln232">    tables[i].set_table_id(table.id());</a>
<a name="ln233">    tables[i].set_namespace_id(table.namespace_().id());</a>
<a name="ln234"> </a>
<a name="ln235">    DSCHECK(table.relation_type() == master::USER_TABLE_RELATION ||</a>
<a name="ln236">            table.relation_type() == master::INDEX_TABLE_RELATION, InternalError,</a>
<a name="ln237">            Format(&quot;Invalid relation type: $0&quot;, table.relation_type()));</a>
<a name="ln238">    DSCHECK_EQ(table.namespace_().name(), ns.name, InternalError,</a>
<a name="ln239">               Format(&quot;Invalid namespace name: $0&quot;, table.namespace_().name()));</a>
<a name="ln240">    DSCHECK_EQ(table.namespace_().database_type(), ns.db_type, InternalError,</a>
<a name="ln241">               Format(&quot;Invalid namespace type: $0&quot;,</a>
<a name="ln242">                      YQLDatabase_Name(table.namespace_().database_type())));</a>
<a name="ln243">  }</a>
<a name="ln244"> </a>
<a name="ln245">  return CreateSnapshot(tables, /* add_indexes */ false);</a>
<a name="ln246">}</a>
<a name="ln247"> </a>
<a name="ln248">Status ClusterAdminClient::RestoreSnapshot(const string&amp; snapshot_id) {</a>
<a name="ln249">  RpcController rpc;</a>
<a name="ln250">  rpc.set_timeout(timeout_);</a>
<a name="ln251"> </a>
<a name="ln252">  RestoreSnapshotRequestPB req;</a>
<a name="ln253">  RestoreSnapshotResponsePB resp;</a>
<a name="ln254">  req.set_snapshot_id(StringToSnapshotId(snapshot_id));</a>
<a name="ln255">  RETURN_NOT_OK(master_backup_proxy_-&gt;RestoreSnapshot(req, &amp;resp, &amp;rpc));</a>
<a name="ln256"> </a>
<a name="ln257">  if (resp.has_error()) {</a>
<a name="ln258">    return StatusFromPB(resp.error().status());</a>
<a name="ln259">  }</a>
<a name="ln260"> </a>
<a name="ln261">  cout &lt;&lt; &quot;Started restoring snapshot: &quot; &lt;&lt; snapshot_id &lt;&lt; endl</a>
<a name="ln262">       &lt;&lt; &quot;Restoration id: &quot; &lt;&lt; FullyDecodeTxnSnapshotRestorationId(resp.restoration_id()) &lt;&lt; endl;</a>
<a name="ln263">  return Status::OK();</a>
<a name="ln264">}</a>
<a name="ln265"> </a>
<a name="ln266">Status ClusterAdminClient::DeleteSnapshot(const std::string&amp; snapshot_id) {</a>
<a name="ln267">  RpcController rpc;</a>
<a name="ln268">  rpc.set_timeout(timeout_);</a>
<a name="ln269"> </a>
<a name="ln270">  DeleteSnapshotRequestPB req;</a>
<a name="ln271">  DeleteSnapshotResponsePB resp;</a>
<a name="ln272">  req.set_snapshot_id(StringToSnapshotId(snapshot_id));</a>
<a name="ln273">  RETURN_NOT_OK(master_backup_proxy_-&gt;DeleteSnapshot(req, &amp;resp, &amp;rpc));</a>
<a name="ln274"> </a>
<a name="ln275">  if (resp.has_error()) {</a>
<a name="ln276">    return StatusFromPB(resp.error().status());</a>
<a name="ln277">  }</a>
<a name="ln278"> </a>
<a name="ln279">  cout &lt;&lt; &quot;Deleted snapshot: &quot; &lt;&lt; snapshot_id &lt;&lt; endl;</a>
<a name="ln280">  return Status::OK();</a>
<a name="ln281">}</a>
<a name="ln282"> </a>
<a name="ln283">Status ClusterAdminClient::CreateSnapshotMetaFile(const string&amp; snapshot_id,</a>
<a name="ln284">                                                  const string&amp; file_name) {</a>
<a name="ln285">  RpcController rpc;</a>
<a name="ln286">  rpc.set_timeout(timeout_);</a>
<a name="ln287">  ListSnapshotsRequestPB req;</a>
<a name="ln288">  ListSnapshotsResponsePB resp;</a>
<a name="ln289">  req.set_snapshot_id(StringToSnapshotId(snapshot_id));</a>
<a name="ln290">  RETURN_NOT_OK(master_backup_proxy_-&gt;ListSnapshots(req, &amp;resp, &amp;rpc));</a>
<a name="ln291"> </a>
<a name="ln292">  if (resp.has_error()) {</a>
<a name="ln293">    return StatusFromPB(resp.error().status());</a>
<a name="ln294">  }</a>
<a name="ln295"> </a>
<a name="ln296">  const SnapshotInfoPB* snapshot = nullptr;</a>
<a name="ln297">  for (const auto&amp; snapshot_entry : resp.snapshots()) {</a>
<a name="ln298">    if (SnapshotIdToString(snapshot_entry.id()) == snapshot_id) {</a>
<a name="ln299">      snapshot = &amp;snapshot_entry;</a>
<a name="ln300">      break;</a>
<a name="ln301">    }</a>
<a name="ln302">  }</a>
<a name="ln303">  if (!snapshot) {</a>
<a name="ln304">    return STATUS_FORMAT(</a>
<a name="ln305">        InternalError, &quot;Response contained $0 entries but no entry for snapshot '$1'&quot;,</a>
<a name="ln306">        resp.snapshots_size(), snapshot_id);</a>
<a name="ln307">  }</a>
<a name="ln308">  if (resp.snapshots_size() &gt; 1) {</a>
<a name="ln309">    LOG(WARNING) &lt;&lt; &quot;Requested snapshot metadata for snapshot '&quot; &lt;&lt; snapshot_id &lt;&lt; &quot;', but got &quot;</a>
<a name="ln310">                 &lt;&lt; resp.snapshots_size() &lt;&lt; &quot; snapshots in the response&quot;;</a>
<a name="ln311">  }</a>
<a name="ln312"> </a>
<a name="ln313">  cout &lt;&lt; &quot;Exporting snapshot &quot; &lt;&lt; snapshot_id &lt;&lt; &quot; (&quot;</a>
<a name="ln314">       &lt;&lt; snapshot-&gt;entry().state() &lt;&lt; &quot;) to file &quot; &lt;&lt; file_name &lt;&lt; endl;</a>
<a name="ln315"> </a>
<a name="ln316">  // Serialize snapshot protobuf to given path.</a>
<a name="ln317">  RETURN_NOT_OK(pb_util::WritePBContainerToPath(</a>
<a name="ln318">      Env::Default(), file_name, *snapshot, pb_util::OVERWRITE, pb_util::SYNC));</a>
<a name="ln319"> </a>
<a name="ln320">  cout &lt;&lt; &quot;Snapshot meta data was saved into file: &quot; &lt;&lt; file_name &lt;&lt; endl;</a>
<a name="ln321">  return Status::OK();</a>
<a name="ln322">}</a>
<a name="ln323"> </a>
<a name="ln324">Status ClusterAdminClient::ImportSnapshotMetaFile(const string&amp; file_name,</a>
<a name="ln325">                                                  const TypedNamespaceName&amp; keyspace,</a>
<a name="ln326">                                                  const vector&lt;YBTableName&gt;&amp; tables) {</a>
<a name="ln327">  cout &lt;&lt; &quot;Read snapshot meta file &quot; &lt;&lt; file_name &lt;&lt; endl;</a>
<a name="ln328"> </a>
<a name="ln329">  ImportSnapshotMetaRequestPB req;</a>
<a name="ln330">  ImportSnapshotMetaResponsePB resp;</a>
<a name="ln331"> </a>
<a name="ln332">  SnapshotInfoPB* const snapshot_info = req.mutable_snapshot();</a>
<a name="ln333"> </a>
<a name="ln334">  // Read snapshot protobuf from given path.</a>
<a name="ln335">  RETURN_NOT_OK(pb_util::ReadPBContainerFromPath(Env::Default(), file_name, snapshot_info));</a>
<a name="ln336"> </a>
<a name="ln337">  cout &lt;&lt; &quot;Importing snapshot &quot; &lt;&lt; SnapshotIdToString(snapshot_info-&gt;id())</a>
<a name="ln338">       &lt;&lt; &quot; (&quot; &lt;&lt; snapshot_info-&gt;entry().state() &lt;&lt; &quot;)&quot; &lt;&lt; endl;</a>
<a name="ln339"> </a>
<a name="ln340">  YBTableName orig_table_name;</a>
<a name="ln341">  int table_index = 0;</a>
<a name="ln342">  bool was_table_renamed = false;</a>
<a name="ln343">  for (SysRowEntry&amp; entry : *snapshot_info-&gt;mutable_entry()-&gt;mutable_entries()) {</a>
<a name="ln344">    const YBTableName table_name = table_index &lt; tables.size()</a>
<a name="ln345">        ? tables[table_index] : YBTableName();</a>
<a name="ln346"> </a>
<a name="ln347">    switch (entry.type()) {</a>
<a name="ln348">      case SysRowEntry::NAMESPACE: {</a>
<a name="ln349">        auto meta = VERIFY_RESULT(ParseFromSlice&lt;SysNamespaceEntryPB&gt;(entry.data()));</a>
<a name="ln350">        orig_table_name.set_namespace_name(meta.name());</a>
<a name="ln351"> </a>
<a name="ln352">        if (!keyspace.name.empty() &amp;&amp; keyspace.name != orig_table_name.namespace_name()) {</a>
<a name="ln353">          meta.set_name(keyspace.name);</a>
<a name="ln354">          entry.set_data(meta.SerializeAsString());</a>
<a name="ln355">        }</a>
<a name="ln356">        break;</a>
<a name="ln357">      }</a>
<a name="ln358">      case SysRowEntry::TABLE: {</a>
<a name="ln359">        auto meta = VERIFY_RESULT(ParseFromSlice&lt;SysTablesEntryPB&gt;(entry.data()));</a>
<a name="ln360">        orig_table_name.set_table_name(meta.name());</a>
<a name="ln361"> </a>
<a name="ln362">        if (!orig_table_name.has_table()) {</a>
<a name="ln363">          return STATUS(IllegalState, &quot;Could not find table name from snapshot metadata&quot;);</a>
<a name="ln364">        }</a>
<a name="ln365"> </a>
<a name="ln366">        if (!orig_table_name.has_namespace()) {</a>
<a name="ln367">          return STATUS(IllegalState, &quot;Could not find keyspace name from snapshot metadata&quot;);</a>
<a name="ln368">        }</a>
<a name="ln369"> </a>
<a name="ln370">        // Update the table name if needed.</a>
<a name="ln371">        if (!table_name.empty() &amp;&amp; table_name.table_name() != orig_table_name.table_name()) {</a>
<a name="ln372">          meta.set_name(table_name.table_name());</a>
<a name="ln373">          entry.set_data(meta.SerializeAsString());</a>
<a name="ln374">          was_table_renamed = true;</a>
<a name="ln375">        } else if (was_table_renamed &amp;&amp; table_name.empty()) {</a>
<a name="ln376">          // Renaming is allowed for all tables OR for no one table.</a>
<a name="ln377">          return STATUS_FORMAT(InvalidArgument,</a>
<a name="ln378">                               &quot;There is no name for table (including indexes) number: $0&quot;,</a>
<a name="ln379">                               table_index);</a>
<a name="ln380">        }</a>
<a name="ln381"> </a>
<a name="ln382">        if (meta.indexed_table_id().empty()) {</a>
<a name="ln383">          cout &lt;&lt; &quot;Table type: table&quot; &lt;&lt; endl;</a>
<a name="ln384">        } else {</a>
<a name="ln385">          cout &lt;&lt; &quot;Table type: index (attaching to the old table id &quot;</a>
<a name="ln386">               &lt;&lt; meta.indexed_table_id() &lt;&lt; &quot;)&quot; &lt;&lt; endl;</a>
<a name="ln387">        }</a>
<a name="ln388"> </a>
<a name="ln389">        if (!table_name.empty()) {</a>
<a name="ln390">          DCHECK(table_name.has_namespace());</a>
<a name="ln391">          DCHECK(table_name.has_table());</a>
<a name="ln392">          cout &lt;&lt; &quot;Target imported table name: &quot; &lt;&lt; table_name.ToString() &lt;&lt; endl;</a>
<a name="ln393">        } else if (!keyspace.name.empty()) {</a>
<a name="ln394">          cout &lt;&lt; &quot;Target imported table name: &quot; &lt;&lt; keyspace.name &lt;&lt; &quot;.&quot;</a>
<a name="ln395">               &lt;&lt; orig_table_name.table_name() &lt;&lt; endl;</a>
<a name="ln396">        }</a>
<a name="ln397"> </a>
<a name="ln398">        cout &lt;&lt; &quot;Table being imported: &quot; &lt;&lt; orig_table_name.ToString() &lt;&lt; endl;</a>
<a name="ln399">        ++table_index;</a>
<a name="ln400">        orig_table_name = YBTableName();</a>
<a name="ln401">        break;</a>
<a name="ln402">      }</a>
<a name="ln403">      default:</a>
<a name="ln404">        break;</a>
<a name="ln405">    }</a>
<a name="ln406">  }</a>
<a name="ln407"> </a>
<a name="ln408">  RpcController rpc;</a>
<a name="ln409">  rpc.set_timeout(timeout_);</a>
<a name="ln410">  RETURN_NOT_OK(master_backup_proxy_-&gt;ImportSnapshotMeta(req, &amp;resp, &amp;rpc));</a>
<a name="ln411"> </a>
<a name="ln412">  if (resp.has_error()) {</a>
<a name="ln413">    return StatusFromPB(resp.error().status());</a>
<a name="ln414">  }</a>
<a name="ln415"> </a>
<a name="ln416">  const int kObjectColumnWidth = 16;</a>
<a name="ln417">  const auto pad_object_type = [](const string&amp; s) {</a>
<a name="ln418">    return RightPadToWidth(s, kObjectColumnWidth);</a>
<a name="ln419">  };</a>
<a name="ln420"> </a>
<a name="ln421">  cout &lt;&lt; &quot;Successfully applied snapshot.&quot; &lt;&lt; endl</a>
<a name="ln422">       &lt;&lt; pad_object_type(&quot;Object&quot;) &lt;&lt; kColumnSep</a>
<a name="ln423">       &lt;&lt; RightPadToUuidWidth(&quot;Old ID&quot;) &lt;&lt; kColumnSep</a>
<a name="ln424">       &lt;&lt; RightPadToUuidWidth(&quot;New ID&quot;) &lt;&lt; endl;</a>
<a name="ln425"> </a>
<a name="ln426">  const RepeatedPtrField&lt;ImportSnapshotMetaResponsePB_TableMetaPB&gt;&amp; tables_meta =</a>
<a name="ln427">      resp.tables_meta();</a>
<a name="ln428">  CreateSnapshotRequestPB snapshot_req;</a>
<a name="ln429">  CreateSnapshotResponsePB snapshot_resp;</a>
<a name="ln430"> </a>
<a name="ln431">  for (int i = 0; i &lt; tables_meta.size(); ++i) {</a>
<a name="ln432">    const ImportSnapshotMetaResponsePB_TableMetaPB&amp; table_meta = tables_meta.Get(i);</a>
<a name="ln433">    const string&amp; new_table_id = table_meta.table_ids().new_id();</a>
<a name="ln434"> </a>
<a name="ln435">    cout &lt;&lt; pad_object_type(&quot;Keyspace&quot;) &lt;&lt; kColumnSep</a>
<a name="ln436">         &lt;&lt; table_meta.namespace_ids().old_id() &lt;&lt; kColumnSep</a>
<a name="ln437">         &lt;&lt; table_meta.namespace_ids().new_id() &lt;&lt; endl;</a>
<a name="ln438"> </a>
<a name="ln439">    cout &lt;&lt; pad_object_type(&quot;Table&quot;) &lt;&lt; kColumnSep</a>
<a name="ln440">         &lt;&lt; table_meta.table_ids().old_id() &lt;&lt; kColumnSep</a>
<a name="ln441">         &lt;&lt; new_table_id &lt;&lt; endl;</a>
<a name="ln442"> </a>
<a name="ln443">    const RepeatedPtrField&lt;IdPairPB&gt;&amp; tablets_map = table_meta.tablets_ids();</a>
<a name="ln444">    for (int j = 0; j &lt; tablets_map.size(); ++j) {</a>
<a name="ln445">      const IdPairPB&amp; pair = tablets_map.Get(j);</a>
<a name="ln446">      cout &lt;&lt; pad_object_type(Format(&quot;Tablet $0&quot;, j)) &lt;&lt; kColumnSep</a>
<a name="ln447">           &lt;&lt; pair.old_id() &lt;&lt; kColumnSep</a>
<a name="ln448">           &lt;&lt; pair.new_id() &lt;&lt; endl;</a>
<a name="ln449">    }</a>
<a name="ln450"> </a>
<a name="ln451">    RETURN_NOT_OK(yb_client_-&gt;WaitForCreateTableToFinish(</a>
<a name="ln452">        new_table_id,</a>
<a name="ln453">        CoarseMonoClock::Now() + MonoDelta::FromSeconds(FLAGS_yb_client_admin_operation_timeout_sec)</a>
<a name="ln454">    ));</a>
<a name="ln455"> </a>
<a name="ln456">    snapshot_req.mutable_tables()-&gt;Add()-&gt;set_table_id(new_table_id);</a>
<a name="ln457">  }</a>
<a name="ln458"> </a>
<a name="ln459">  // All indexes already are in the request. Do not add them twice.</a>
<a name="ln460">  snapshot_req.set_add_indexes(false);</a>
<a name="ln461">  snapshot_req.set_transaction_aware(true);</a>
<a name="ln462">  snapshot_req.set_imported(true);</a>
<a name="ln463">  // Create new snapshot.</a>
<a name="ln464">  rpc.Reset();</a>
<a name="ln465">  RETURN_NOT_OK(master_backup_proxy_-&gt;CreateSnapshot(snapshot_req, &amp;snapshot_resp, &amp;rpc));</a>
<a name="ln466"> </a>
<a name="ln467">  if (snapshot_resp.has_error()) {</a>
<a name="ln468">    return StatusFromPB(snapshot_resp.error().status());</a>
<a name="ln469">  }</a>
<a name="ln470"> </a>
<a name="ln471">  cout &lt;&lt; pad_object_type(&quot;Snapshot&quot;) &lt;&lt; kColumnSep</a>
<a name="ln472">       &lt;&lt; SnapshotIdToString(snapshot_info-&gt;id()) &lt;&lt; kColumnSep</a>
<a name="ln473">       &lt;&lt; SnapshotIdToString(snapshot_resp.snapshot_id()) &lt;&lt; endl;</a>
<a name="ln474"> </a>
<a name="ln475">  return Status::OK();</a>
<a name="ln476">}</a>
<a name="ln477"> </a>
<a name="ln478">Status ClusterAdminClient::ListReplicaTypeCounts(const YBTableName&amp; table_name) {</a>
<a name="ln479">  vector&lt;string&gt; tablet_ids, ranges;</a>
<a name="ln480">  RETURN_NOT_OK(yb_client_-&gt;GetTablets(table_name, 0, &amp;tablet_ids, &amp;ranges));</a>
<a name="ln481">  rpc::RpcController rpc;</a>
<a name="ln482">  master::GetTabletLocationsRequestPB req;</a>
<a name="ln483">  master::GetTabletLocationsResponsePB resp;</a>
<a name="ln484">  rpc.set_timeout(timeout_);</a>
<a name="ln485">  for (const auto&amp; tablet_id : tablet_ids) {</a>
<a name="ln486">    req.add_tablet_ids(tablet_id);</a>
<a name="ln487">  }</a>
<a name="ln488">  RETURN_NOT_OK(master_proxy_-&gt;GetTabletLocations(req, &amp;resp, &amp;rpc));</a>
<a name="ln489">  if (resp.has_error()) {</a>
<a name="ln490">    return StatusFromPB(resp.error().status());</a>
<a name="ln491">  }</a>
<a name="ln492"> </a>
<a name="ln493">  struct ReplicaCounts {</a>
<a name="ln494">    int live_count;</a>
<a name="ln495">    int read_only_count;</a>
<a name="ln496">    string placement_uuid;</a>
<a name="ln497">  };</a>
<a name="ln498">  std::map&lt;TabletServerId, ReplicaCounts&gt; replica_map;</a>
<a name="ln499"> </a>
<a name="ln500">  std::cout &lt;&lt; &quot;Tserver ID\t\tPlacement ID\t\tLive count\t\tRead only count\n&quot;;</a>
<a name="ln501"> </a>
<a name="ln502">  for (int tablet_idx = 0; tablet_idx &lt; resp.tablet_locations_size(); tablet_idx++) {</a>
<a name="ln503">    const master::TabletLocationsPB&amp; locs = resp.tablet_locations(tablet_idx);</a>
<a name="ln504">    for (int replica_idx = 0; replica_idx &lt; locs.replicas_size(); replica_idx++) {</a>
<a name="ln505">      const auto&amp; replica = locs.replicas(replica_idx);</a>
<a name="ln506">      const string&amp; ts_uuid = replica.ts_info().permanent_uuid();</a>
<a name="ln507">      const string&amp; placement_uuid =</a>
<a name="ln508">          replica.ts_info().has_placement_uuid() ? replica.ts_info().placement_uuid() : &quot;&quot;;</a>
<a name="ln509">      bool is_replica_read_only =</a>
<a name="ln510">          replica.member_type() == consensus::RaftPeerPB::PRE_OBSERVER ||</a>
<a name="ln511">          replica.member_type() == consensus::RaftPeerPB::OBSERVER;</a>
<a name="ln512">      int live_count = is_replica_read_only ? 0 : 1;</a>
<a name="ln513">      int read_only_count = 1 - live_count;</a>
<a name="ln514">      if (replica_map.count(ts_uuid) == 0) {</a>
<a name="ln515">        replica_map[ts_uuid].live_count = live_count;</a>
<a name="ln516">        replica_map[ts_uuid].read_only_count = read_only_count;</a>
<a name="ln517">        replica_map[ts_uuid].placement_uuid = placement_uuid;</a>
<a name="ln518">      } else {</a>
<a name="ln519">        ReplicaCounts* counts = &amp;replica_map[ts_uuid];</a>
<a name="ln520">        counts-&gt;live_count += live_count;</a>
<a name="ln521">        counts-&gt;read_only_count += read_only_count;</a>
<a name="ln522">      }</a>
<a name="ln523">    }</a>
<a name="ln524">  }</a>
<a name="ln525"> </a>
<a name="ln526">  for (auto const&amp; tserver : replica_map) {</a>
<a name="ln527">    std::cout &lt;&lt; tserver.first &lt;&lt; &quot;\t\t&quot; &lt;&lt; tserver.second.placement_uuid &lt;&lt; &quot;\t\t&quot;</a>
<a name="ln528">              &lt;&lt; tserver.second.live_count &lt;&lt; &quot;\t\t&quot; &lt;&lt; tserver.second.read_only_count &lt;&lt; std::endl;</a>
<a name="ln529">  }</a>
<a name="ln530"> </a>
<a name="ln531">  return Status::OK();</a>
<a name="ln532">}</a>
<a name="ln533"> </a>
<a name="ln534">Status ClusterAdminClient::SetPreferredZones(const std::vector&lt;string&gt;&amp; preferred_zones) {</a>
<a name="ln535">  rpc::RpcController rpc;</a>
<a name="ln536">  master::SetPreferredZonesRequestPB req;</a>
<a name="ln537">  master::SetPreferredZonesResponsePB resp;</a>
<a name="ln538">  rpc.set_timeout(timeout_);</a>
<a name="ln539"> </a>
<a name="ln540">  std::set&lt;string&gt; zones;</a>
<a name="ln541">  for (const string&amp; zone : preferred_zones) {</a>
<a name="ln542">    if (std::find(zones.begin(), zones.end(), zone) != zones.end()) {</a>
<a name="ln543">      continue;</a>
<a name="ln544">    }</a>
<a name="ln545">    size_t last_pos = 0;</a>
<a name="ln546">    size_t next_pos;</a>
<a name="ln547">    std::vector&lt;string&gt; tokens;</a>
<a name="ln548">    while ((next_pos = zone.find(&quot;.&quot;, last_pos)) != string::npos) {</a>
<a name="ln549">      tokens.push_back(zone.substr(last_pos, next_pos - last_pos));</a>
<a name="ln550">      last_pos = next_pos + 1;</a>
<a name="ln551">    }</a>
<a name="ln552">    tokens.push_back(zone.substr(last_pos, zone.size() - last_pos));</a>
<a name="ln553">    if (tokens.size() != 3) {</a>
<a name="ln554">      return STATUS_SUBSTITUTE(InvalidArgument, &quot;Invalid argument for preferred zone $0, should &quot;</a>
<a name="ln555">          &quot;have format cloud.region.zone&quot;, zone);</a>
<a name="ln556">    }</a>
<a name="ln557"> </a>
<a name="ln558">    CloudInfoPB* cloud_info = req.add_preferred_zones();</a>
<a name="ln559">    cloud_info-&gt;set_placement_cloud(tokens[0]);</a>
<a name="ln560">    cloud_info-&gt;set_placement_region(tokens[1]);</a>
<a name="ln561">    cloud_info-&gt;set_placement_zone(tokens[2]);</a>
<a name="ln562"> </a>
<a name="ln563">    zones.emplace(zone);</a>
<a name="ln564">  }</a>
<a name="ln565"> </a>
<a name="ln566">  RETURN_NOT_OK(master_proxy_-&gt;SetPreferredZones(req, &amp;resp, &amp;rpc));</a>
<a name="ln567"> </a>
<a name="ln568">  if (resp.has_error()) {</a>
<a name="ln569">    return STATUS(ServiceUnavailable, resp.error().status().message());</a>
<a name="ln570">  }</a>
<a name="ln571"> </a>
<a name="ln572">  return Status::OK();</a>
<a name="ln573">}</a>
<a name="ln574"> </a>
<a name="ln575">Status ClusterAdminClient::RotateUniverseKey(const std::string&amp; key_path) {</a>
<a name="ln576">  return SendEncryptionRequest(key_path, true);</a>
<a name="ln577">}</a>
<a name="ln578"> </a>
<a name="ln579">Status ClusterAdminClient::DisableEncryption() {</a>
<a name="ln580">  return SendEncryptionRequest(&quot;&quot;, false);</a>
<a name="ln581">}</a>
<a name="ln582"> </a>
<a name="ln583">Status ClusterAdminClient::SendEncryptionRequest(</a>
<a name="ln584">    const std::string&amp; key_path, bool enable_encryption) {</a>
<a name="ln585">  RETURN_NOT_OK_PREPEND(WaitUntilMasterLeaderReady(), &quot;Wait for master leader failed!&quot;);</a>
<a name="ln586">  rpc::RpcController rpc;</a>
<a name="ln587">  rpc.set_timeout(timeout_);</a>
<a name="ln588"> </a>
<a name="ln589">  // Get the cluster config from the master leader.</a>
<a name="ln590">  master::ChangeEncryptionInfoRequestPB encryption_info_req;</a>
<a name="ln591">  master::ChangeEncryptionInfoResponsePB encryption_info_resp;</a>
<a name="ln592">  encryption_info_req.set_encryption_enabled(enable_encryption);</a>
<a name="ln593">  if (key_path != &quot;&quot;) {</a>
<a name="ln594">    encryption_info_req.set_key_path(key_path);</a>
<a name="ln595">  }</a>
<a name="ln596">  RETURN_NOT_OK_PREPEND(master_proxy_-&gt;</a>
<a name="ln597">      ChangeEncryptionInfo(encryption_info_req, &amp;encryption_info_resp, &amp;rpc),</a>
<a name="ln598">                        &quot;MasterServiceImpl::ChangeEncryptionInfo call fails.&quot;)</a>
<a name="ln599"> </a>
<a name="ln600">  if (encryption_info_resp.has_error()) {</a>
<a name="ln601">    return StatusFromPB(encryption_info_resp.error().status());</a>
<a name="ln602">  }</a>
<a name="ln603">  return Status::OK();</a>
<a name="ln604">}</a>
<a name="ln605"> </a>
<a name="ln606">Status ClusterAdminClient::IsEncryptionEnabled() {</a>
<a name="ln607">  RETURN_NOT_OK_PREPEND(WaitUntilMasterLeaderReady(), &quot;Wait for master leader failed!&quot;);</a>
<a name="ln608">  rpc::RpcController rpc;</a>
<a name="ln609">  rpc.set_timeout(timeout_);</a>
<a name="ln610"> </a>
<a name="ln611">  master::IsEncryptionEnabledRequestPB req;</a>
<a name="ln612">  master::IsEncryptionEnabledResponsePB resp;</a>
<a name="ln613">  RETURN_NOT_OK_PREPEND(master_proxy_-&gt;</a>
<a name="ln614">      IsEncryptionEnabled(req, &amp;resp, &amp;rpc),</a>
<a name="ln615">      &quot;MasterServiceImpl::IsEncryptionEnabled call fails.&quot;);</a>
<a name="ln616">  if (resp.has_error()) {</a>
<a name="ln617">    return StatusFromPB(resp.error().status());</a>
<a name="ln618">  }</a>
<a name="ln619"> </a>
<a name="ln620">  std::cout &lt;&lt; &quot;Encryption status: &quot; &lt;&lt; (resp.encryption_enabled() ?</a>
<a name="ln621">      Format(&quot;ENABLED with key id $0&quot;, resp.key_id()) : &quot;DISABLED&quot; ) &lt;&lt; std::endl;</a>
<a name="ln622">  return Status::OK();</a>
<a name="ln623">}</a>
<a name="ln624"> </a>
<a name="ln625">Status ClusterAdminClient::AddUniverseKeyToAllMasters(</a>
<a name="ln626">    const std::string&amp; key_id, const std::string&amp; universe_key) {</a>
<a name="ln627"> </a>
<a name="ln628">  RETURN_NOT_OK(EncryptionParams::IsValidKeySize(</a>
<a name="ln629">      universe_key.size() - EncryptionParams::kBlockSize));</a>
<a name="ln630"> </a>
<a name="ln631">  master::AddUniverseKeysRequestPB req;</a>
<a name="ln632">  master::AddUniverseKeysResponsePB resp;</a>
<a name="ln633">  auto* universe_keys = req.mutable_universe_keys();</a>
<a name="ln634">  (*universe_keys-&gt;mutable_map())[key_id] = universe_key;</a>
<a name="ln635"> </a>
<a name="ln636">  for (auto hp : VERIFY_RESULT(HostPort::ParseStrings(master_addr_list_, 7100))) {</a>
<a name="ln637">    rpc::RpcController rpc;</a>
<a name="ln638">    rpc.set_timeout(timeout_);</a>
<a name="ln639">    master::MasterServiceProxy proxy(proxy_cache_.get(), hp);</a>
<a name="ln640">    RETURN_NOT_OK_PREPEND(proxy.AddUniverseKeys(req, &amp;resp, &amp;rpc),</a>
<a name="ln641">                          Format(&quot;MasterServiceImpl::AddUniverseKeys call fails on host $0.&quot;,</a>
<a name="ln642">                                 hp.ToString()));</a>
<a name="ln643">    if (resp.has_error()) {</a>
<a name="ln644">      return StatusFromPB(resp.error().status());</a>
<a name="ln645">    }</a>
<a name="ln646">    std::cout &lt;&lt; Format(&quot;Successfully added key to the node $0.\n&quot;, hp.ToString());</a>
<a name="ln647">  }</a>
<a name="ln648"> </a>
<a name="ln649">  return Status::OK();</a>
<a name="ln650">}</a>
<a name="ln651"> </a>
<a name="ln652">Status ClusterAdminClient::AllMastersHaveUniverseKeyInMemory(const std::string&amp; key_id) {</a>
<a name="ln653">  master::HasUniverseKeyInMemoryRequestPB req;</a>
<a name="ln654">  master::HasUniverseKeyInMemoryResponsePB resp;</a>
<a name="ln655">  req.set_version_id(key_id);</a>
<a name="ln656"> </a>
<a name="ln657">  for (auto hp : VERIFY_RESULT(HostPort::ParseStrings(master_addr_list_, 7100))) {</a>
<a name="ln658">    rpc::RpcController rpc;</a>
<a name="ln659">    rpc.set_timeout(timeout_);</a>
<a name="ln660">    master::MasterServiceProxy proxy(proxy_cache_.get(), hp);</a>
<a name="ln661">    RETURN_NOT_OK_PREPEND(proxy.HasUniverseKeyInMemory(req, &amp;resp, &amp;rpc),</a>
<a name="ln662">                          &quot;MasterServiceImpl::ChangeEncryptionInfo call fails.&quot;);</a>
<a name="ln663"> </a>
<a name="ln664">    if (resp.has_error()) {</a>
<a name="ln665">      return StatusFromPB(resp.error().status());</a>
<a name="ln666">    }</a>
<a name="ln667"> </a>
<a name="ln668">    std::cout &lt;&lt; Format(&quot;Node $0 has universe key in memory: $1\n&quot;, hp.ToString(), resp.has_key());</a>
<a name="ln669">  }</a>
<a name="ln670"> </a>
<a name="ln671">  return Status::OK();</a>
<a name="ln672">}</a>
<a name="ln673"> </a>
<a name="ln674">Status ClusterAdminClient::RotateUniverseKeyInMemory(const std::string&amp; key_id) {</a>
<a name="ln675">  RETURN_NOT_OK_PREPEND(WaitUntilMasterLeaderReady(), &quot;Wait for master leader failed!&quot;);</a>
<a name="ln676">  rpc::RpcController rpc;</a>
<a name="ln677">  rpc.set_timeout(timeout_);</a>
<a name="ln678"> </a>
<a name="ln679">  master::ChangeEncryptionInfoRequestPB req;</a>
<a name="ln680">  master::ChangeEncryptionInfoResponsePB resp;</a>
<a name="ln681">  req.set_encryption_enabled(true);</a>
<a name="ln682">  req.set_in_memory(true);</a>
<a name="ln683">  req.set_version_id(key_id);</a>
<a name="ln684">  RETURN_NOT_OK_PREPEND(master_proxy_-&gt;ChangeEncryptionInfo(req, &amp;resp, &amp;rpc),</a>
<a name="ln685">                        &quot;MasterServiceImpl::ChangeEncryptionInfo call fails.&quot;);</a>
<a name="ln686">  if (resp.has_error()) {</a>
<a name="ln687">    return StatusFromPB(resp.error().status());</a>
<a name="ln688">  }</a>
<a name="ln689"> </a>
<a name="ln690">  std::cout &lt;&lt; &quot;Rotated universe key in memory\n&quot;;</a>
<a name="ln691">  return Status::OK();</a>
<a name="ln692">}</a>
<a name="ln693"> </a>
<a name="ln694">Status ClusterAdminClient::DisableEncryptionInMemory() {</a>
<a name="ln695">  RETURN_NOT_OK_PREPEND(WaitUntilMasterLeaderReady(), &quot;Wait for master leader failed!&quot;);</a>
<a name="ln696">  rpc::RpcController rpc;</a>
<a name="ln697">  rpc.set_timeout(timeout_);</a>
<a name="ln698"> </a>
<a name="ln699">  master::ChangeEncryptionInfoRequestPB req;</a>
<a name="ln700">  master::ChangeEncryptionInfoResponsePB resp;</a>
<a name="ln701">  req.set_encryption_enabled(false);</a>
<a name="ln702">  RETURN_NOT_OK_PREPEND(master_proxy_-&gt;ChangeEncryptionInfo(req, &amp;resp, &amp;rpc),</a>
<a name="ln703">                        &quot;MasterServiceImpl::ChangeEncryptionInfo call fails.&quot;);</a>
<a name="ln704">  if (resp.has_error()) {</a>
<a name="ln705">    return StatusFromPB(resp.error().status());</a>
<a name="ln706">  }</a>
<a name="ln707"> </a>
<a name="ln708">  std::cout &lt;&lt; &quot;Encryption disabled\n&quot;;</a>
<a name="ln709">  return Status::OK();</a>
<a name="ln710">}</a>
<a name="ln711"> </a>
<a name="ln712">Status ClusterAdminClient::WriteUniverseKeyToFile(</a>
<a name="ln713">    const std::string&amp; key_id, const std::string&amp; file_name) {</a>
<a name="ln714">  RETURN_NOT_OK_PREPEND(WaitUntilMasterLeaderReady(), &quot;Wait for master leader failed!&quot;);</a>
<a name="ln715">  rpc::RpcController rpc;</a>
<a name="ln716">  rpc.set_timeout(timeout_);</a>
<a name="ln717"> </a>
<a name="ln718">  master::GetUniverseKeyRegistryRequestPB req;</a>
<a name="ln719">  master::GetUniverseKeyRegistryResponsePB resp;</a>
<a name="ln720">  RETURN_NOT_OK_PREPEND(master_proxy_-&gt;GetUniverseKeyRegistry(req, &amp;resp, &amp;rpc),</a>
<a name="ln721">                        &quot;MasterServiceImpl::ChangeEncryptionInfo call fails.&quot;);</a>
<a name="ln722">  if (resp.has_error()) {</a>
<a name="ln723">    return StatusFromPB(resp.error().status());</a>
<a name="ln724">  }</a>
<a name="ln725"> </a>
<a name="ln726">  auto universe_keys = resp.universe_keys();</a>
<a name="ln727">  const auto&amp; it = universe_keys.map().find(key_id);</a>
<a name="ln728">  if (it == universe_keys.map().end()) {</a>
<a name="ln729">    return STATUS_FORMAT(NotFound, &quot;Could not find key with id $0&quot;, key_id);</a>
<a name="ln730">  }</a>
<a name="ln731"> </a>
<a name="ln732">  RETURN_NOT_OK(WriteStringToFile(Env::Default(), Slice(it-&gt;second), file_name));</a>
<a name="ln733"> </a>
<a name="ln734">  std::cout &lt;&lt; &quot;Finished writing to file\n&quot;;</a>
<a name="ln735">  return Status::OK();</a>
<a name="ln736">}</a>
<a name="ln737"> </a>
<a name="ln738">Status ClusterAdminClient::CreateCDCStream(const TableId&amp; table_id) {</a>
<a name="ln739">  master::CreateCDCStreamRequestPB req;</a>
<a name="ln740">  master::CreateCDCStreamResponsePB resp;</a>
<a name="ln741">  req.set_table_id(table_id);</a>
<a name="ln742">  req.mutable_options()-&gt;Reserve(2);</a>
<a name="ln743"> </a>
<a name="ln744">  auto record_type_option = req.add_options();</a>
<a name="ln745">  record_type_option-&gt;set_key(cdc::kRecordType);</a>
<a name="ln746">  record_type_option-&gt;set_value(CDCRecordType_Name(cdc::CDCRecordType::CHANGE));</a>
<a name="ln747"> </a>
<a name="ln748">  auto record_format_option = req.add_options();</a>
<a name="ln749">  record_format_option-&gt;set_key(cdc::kRecordFormat);</a>
<a name="ln750">  record_format_option-&gt;set_value(CDCRecordFormat_Name(cdc::CDCRecordFormat::JSON));</a>
<a name="ln751"> </a>
<a name="ln752">  RpcController rpc;</a>
<a name="ln753">  rpc.set_timeout(timeout_);</a>
<a name="ln754">  RETURN_NOT_OK(master_proxy_-&gt;CreateCDCStream(req, &amp;resp, &amp;rpc));</a>
<a name="ln755"> </a>
<a name="ln756">  if (resp.has_error()) {</a>
<a name="ln757">    cout &lt;&lt; &quot;Error creating stream: &quot; &lt;&lt; resp.error().status().message() &lt;&lt; endl;</a>
<a name="ln758">    return StatusFromPB(resp.error().status());</a>
<a name="ln759">  }</a>
<a name="ln760"> </a>
<a name="ln761">  cout &lt;&lt; &quot;CDC Stream ID: &quot; &lt;&lt; resp.stream_id() &lt;&lt; endl;</a>
<a name="ln762">  return Status::OK();</a>
<a name="ln763">}</a>
<a name="ln764"> </a>
<a name="ln765">Status ClusterAdminClient::DeleteCDCStream(const std::string&amp; stream_id) {</a>
<a name="ln766">  master::DeleteCDCStreamRequestPB req;</a>
<a name="ln767">  master::DeleteCDCStreamResponsePB resp;</a>
<a name="ln768">  req.add_stream_id(stream_id);</a>
<a name="ln769"> </a>
<a name="ln770">  RpcController rpc;</a>
<a name="ln771">  rpc.set_timeout(timeout_);</a>
<a name="ln772">  RETURN_NOT_OK(master_proxy_-&gt;DeleteCDCStream(req, &amp;resp, &amp;rpc));</a>
<a name="ln773"> </a>
<a name="ln774">  if (resp.has_error()) {</a>
<a name="ln775">    cout &lt;&lt; &quot;Error deleting stream: &quot; &lt;&lt; resp.error().status().message() &lt;&lt; endl;</a>
<a name="ln776">    return StatusFromPB(resp.error().status());</a>
<a name="ln777">  }</a>
<a name="ln778"> </a>
<a name="ln779">  cout &lt;&lt; &quot;Successfully deleted CDC Stream ID: &quot; &lt;&lt; stream_id &lt;&lt; endl;</a>
<a name="ln780">  return Status::OK();</a>
<a name="ln781">}</a>
<a name="ln782"> </a>
<a name="ln783">Status ClusterAdminClient::ListCDCStreams(const TableId&amp; table_id) {</a>
<a name="ln784">  master::ListCDCStreamsRequestPB req;</a>
<a name="ln785">  master::ListCDCStreamsResponsePB resp;</a>
<a name="ln786">  if (!table_id.empty()) {</a>
<a name="ln787">    req.set_table_id(table_id);</a>
<a name="ln788">  }</a>
<a name="ln789"> </a>
<a name="ln790">  RpcController rpc;</a>
<a name="ln791">  rpc.set_timeout(timeout_);</a>
<a name="ln792">  RETURN_NOT_OK(master_proxy_-&gt;ListCDCStreams(req, &amp;resp, &amp;rpc));</a>
<a name="ln793"> </a>
<a name="ln794">  if (resp.has_error()) {</a>
<a name="ln795">    cout &lt;&lt; &quot;Error getting CDC stream list: &quot; &lt;&lt; resp.error().status().message() &lt;&lt; endl;</a>
<a name="ln796">    return StatusFromPB(resp.error().status());</a>
<a name="ln797">  }</a>
<a name="ln798"> </a>
<a name="ln799">  cout &lt;&lt; &quot;CDC Streams: \r\n&quot; &lt;&lt; resp.DebugString();</a>
<a name="ln800">  return Status::OK();</a>
<a name="ln801">}</a>
<a name="ln802"> </a>
<a name="ln803">Status ClusterAdminClient::SetupUniverseReplication(</a>
<a name="ln804">    const string&amp; producer_uuid, const vector&lt;string&gt;&amp; producer_addresses,</a>
<a name="ln805">    const vector&lt;TableId&gt;&amp; tables,</a>
<a name="ln806">    const vector&lt;string&gt;&amp; producer_bootstrap_ids) {</a>
<a name="ln807">  master::SetupUniverseReplicationRequestPB req;</a>
<a name="ln808">  master::SetupUniverseReplicationResponsePB resp;</a>
<a name="ln809">  req.set_producer_id(producer_uuid);</a>
<a name="ln810"> </a>
<a name="ln811">  req.mutable_producer_master_addresses()-&gt;Reserve(producer_addresses.size());</a>
<a name="ln812">  for (const auto&amp; addr : producer_addresses) {</a>
<a name="ln813">    // HostPort::FromString() expects a default port.</a>
<a name="ln814">    auto hp = VERIFY_RESULT(HostPort::FromString(addr, master::kMasterDefaultPort));</a>
<a name="ln815">    HostPortToPB(hp, req.add_producer_master_addresses());</a>
<a name="ln816">  }</a>
<a name="ln817"> </a>
<a name="ln818">  req.mutable_producer_table_ids()-&gt;Reserve(tables.size());</a>
<a name="ln819">  for (const auto&amp; table : tables) {</a>
<a name="ln820">    req.add_producer_table_ids(table);</a>
<a name="ln821">  }</a>
<a name="ln822"> </a>
<a name="ln823">  for (const auto&amp; producer_bootstrap_id : producer_bootstrap_ids) {</a>
<a name="ln824">    req.add_producer_bootstrap_ids(producer_bootstrap_id);</a>
<a name="ln825">  }</a>
<a name="ln826"> </a>
<a name="ln827">  RpcController rpc;</a>
<a name="ln828">  rpc.set_timeout(timeout_);</a>
<a name="ln829">  RETURN_NOT_OK(master_proxy_-&gt;SetupUniverseReplication(req, &amp;resp, &amp;rpc));</a>
<a name="ln830"> </a>
<a name="ln831">  if (resp.has_error()) {</a>
<a name="ln832">    cout &lt;&lt; &quot;Error setting up universe replication: &quot; &lt;&lt; resp.error().status().message() &lt;&lt; endl;</a>
<a name="ln833">    return StatusFromPB(resp.error().status());</a>
<a name="ln834">  }</a>
<a name="ln835"> </a>
<a name="ln836">  cout &lt;&lt; &quot;Replication setup successfully&quot; &lt;&lt; endl;</a>
<a name="ln837">  return Status::OK();</a>
<a name="ln838">}</a>
<a name="ln839"> </a>
<a name="ln840">Status ClusterAdminClient::DeleteUniverseReplication(const std::string&amp; producer_id) {</a>
<a name="ln841">  master::DeleteUniverseReplicationRequestPB req;</a>
<a name="ln842">  master::DeleteUniverseReplicationResponsePB resp;</a>
<a name="ln843">  req.set_producer_id(producer_id);</a>
<a name="ln844"> </a>
<a name="ln845">  RpcController rpc;</a>
<a name="ln846">  rpc.set_timeout(timeout_);</a>
<a name="ln847">  RETURN_NOT_OK(master_proxy_-&gt;DeleteUniverseReplication(req, &amp;resp, &amp;rpc));</a>
<a name="ln848"> </a>
<a name="ln849">  if (resp.has_error()) {</a>
<a name="ln850">    cout &lt;&lt; &quot;Error deleting universe replication: &quot; &lt;&lt; resp.error().status().message() &lt;&lt; endl;</a>
<a name="ln851">    return StatusFromPB(resp.error().status());</a>
<a name="ln852">  }</a>
<a name="ln853"> </a>
<a name="ln854">  cout &lt;&lt; &quot;Replication deleted successfully&quot; &lt;&lt; endl;</a>
<a name="ln855">  return Status::OK();</a>
<a name="ln856">}</a>
<a name="ln857"> </a>
<a name="ln858">Status ClusterAdminClient::AlterUniverseReplication(const std::string&amp; producer_uuid,</a>
<a name="ln859">    const std::vector&lt;std::string&gt;&amp; producer_addresses,</a>
<a name="ln860">    const std::vector&lt;TableId&gt;&amp; add_tables,</a>
<a name="ln861">    const std::vector&lt;TableId&gt;&amp; remove_tables) {</a>
<a name="ln862">  master::AlterUniverseReplicationRequestPB req;</a>
<a name="ln863">  master::AlterUniverseReplicationResponsePB resp;</a>
<a name="ln864">  req.set_producer_id(producer_uuid);</a>
<a name="ln865"> </a>
<a name="ln866">  if (!producer_addresses.empty()) {</a>
<a name="ln867">    req.mutable_producer_master_addresses()-&gt;Reserve(producer_addresses.size());</a>
<a name="ln868">    for (const auto&amp; addr : producer_addresses) {</a>
<a name="ln869">      // HostPort::FromString() expects a default port.</a>
<a name="ln870">      auto hp = VERIFY_RESULT(HostPort::FromString(addr, master::kMasterDefaultPort));</a>
<a name="ln871">      HostPortToPB(hp, req.add_producer_master_addresses());</a>
<a name="ln872">    }</a>
<a name="ln873">  }</a>
<a name="ln874"> </a>
<a name="ln875">  if (!add_tables.empty()) {</a>
<a name="ln876">    req.mutable_producer_table_ids_to_add()-&gt;Reserve(add_tables.size());</a>
<a name="ln877">    for (const auto&amp; table : add_tables) {</a>
<a name="ln878">      req.add_producer_table_ids_to_add(table);</a>
<a name="ln879">    }</a>
<a name="ln880">  }</a>
<a name="ln881"> </a>
<a name="ln882">  if (!remove_tables.empty()) {</a>
<a name="ln883">    req.mutable_producer_table_ids_to_remove()-&gt;Reserve(remove_tables.size());</a>
<a name="ln884">    for (const auto&amp; table : remove_tables) {</a>
<a name="ln885">      req.add_producer_table_ids_to_remove(table);</a>
<a name="ln886">    }</a>
<a name="ln887">  }</a>
<a name="ln888"> </a>
<a name="ln889">  RpcController rpc;</a>
<a name="ln890">  rpc.set_timeout(timeout_);</a>
<a name="ln891">  RETURN_NOT_OK(master_proxy_-&gt;AlterUniverseReplication(req, &amp;resp, &amp;rpc));</a>
<a name="ln892"> </a>
<a name="ln893">  if (resp.has_error()) {</a>
<a name="ln894">    cout &lt;&lt; &quot;Error altering universe replication: &quot; &lt;&lt; resp.error().status().message() &lt;&lt; endl;</a>
<a name="ln895">    return StatusFromPB(resp.error().status());</a>
<a name="ln896">  }</a>
<a name="ln897"> </a>
<a name="ln898">  cout &lt;&lt; &quot;Replication altered successfully&quot; &lt;&lt; endl;</a>
<a name="ln899">  return Status::OK();</a>
<a name="ln900">}</a>
<a name="ln901"> </a>
<a name="ln902">CHECKED_STATUS ClusterAdminClient::SetUniverseReplicationEnabled(const std::string&amp; producer_id,</a>
<a name="ln903">                                                                 bool is_enabled) {</a>
<a name="ln904">  master::SetUniverseReplicationEnabledRequestPB req;</a>
<a name="ln905">  master::SetUniverseReplicationEnabledResponsePB resp;</a>
<a name="ln906">  req.set_producer_id(producer_id);</a>
<a name="ln907">  req.set_is_enabled(is_enabled);</a>
<a name="ln908">  const string toggle = (is_enabled ? &quot;enabl&quot; : &quot;disabl&quot;);</a>
<a name="ln909"> </a>
<a name="ln910">  RpcController rpc;</a>
<a name="ln911">  rpc.set_timeout(timeout_);</a>
<a name="ln912">  RETURN_NOT_OK(master_proxy_-&gt;SetUniverseReplicationEnabled(req, &amp;resp, &amp;rpc));</a>
<a name="ln913"> </a>
<a name="ln914">  if (resp.has_error()) {</a>
<a name="ln915">    cout &lt;&lt; &quot;Error &quot; &lt;&lt; toggle &lt;&lt; &quot;ing &quot;</a>
<a name="ln916">         &lt;&lt; &quot;universe replication: &quot; &lt;&lt; resp.error().status().message() &lt;&lt; endl;</a>
<a name="ln917">    return StatusFromPB(resp.error().status());</a>
<a name="ln918">  }</a>
<a name="ln919"> </a>
<a name="ln920">  cout &lt;&lt; &quot;Replication &quot; &lt;&lt; toggle &lt;&lt; &quot;ed successfully&quot; &lt;&lt; endl;</a>
<a name="ln921">  return Status::OK();</a>
<a name="ln922">}</a>
<a name="ln923"> </a>
<a name="ln924">Result&lt;HostPort&gt; ClusterAdminClient::GetFirstRpcAddressForTS() {</a>
<a name="ln925">  RepeatedPtrField&lt;ListTabletServersResponsePB::Entry&gt; servers;</a>
<a name="ln926">  RETURN_NOT_OK(ListTabletServers(&amp;servers));</a>
<a name="ln927">  for (const ListTabletServersResponsePB::Entry&amp; server : servers) {</a>
<a name="ln928">    if (server.has_registration() &amp;&amp;</a>
<a name="ln929">        !server.registration().common().private_rpc_addresses().empty()) {</a>
<a name="ln930">      return HostPortFromPB(server.registration().common().private_rpc_addresses(0));</a>
<a name="ln931">    }</a>
<a name="ln932">  }</a>
<a name="ln933"> </a>
<a name="ln934">  return STATUS(NotFound, &quot;Didn't find a server registered with the Master&quot;);</a>
<a name="ln935">}</a>
<a name="ln936"> </a>
<a name="ln937">Status ClusterAdminClient::BootstrapProducer(const vector&lt;TableId&gt;&amp; table_ids) {</a>
<a name="ln938"> </a>
<a name="ln939">  HostPort ts_addr = VERIFY_RESULT(GetFirstRpcAddressForTS());</a>
<a name="ln940">  auto cdc_proxy = std::make_unique&lt;cdc::CDCServiceProxy&gt;(proxy_cache_.get(), ts_addr);</a>
<a name="ln941"> </a>
<a name="ln942">  cdc::BootstrapProducerRequestPB bootstrap_req;</a>
<a name="ln943">  cdc::BootstrapProducerResponsePB bootstrap_resp;</a>
<a name="ln944">  for (const auto&amp; table_id : table_ids) {</a>
<a name="ln945">    bootstrap_req.add_table_ids(table_id);</a>
<a name="ln946">  }</a>
<a name="ln947">  RpcController rpc;</a>
<a name="ln948">  rpc.set_timeout(MonoDelta::FromSeconds(std::max(timeout_.ToSeconds(), 120.0)));</a>
<a name="ln949">  RETURN_NOT_OK(cdc_proxy-&gt;BootstrapProducer(bootstrap_req, &amp;bootstrap_resp, &amp;rpc));</a>
<a name="ln950"> </a>
<a name="ln951">  if (bootstrap_resp.has_error()) {</a>
<a name="ln952">    cout &lt;&lt; &quot;Error bootstrapping consumer: &quot; &lt;&lt; bootstrap_resp.error().status().message() &lt;&lt; endl;</a>
<a name="ln953">    return StatusFromPB(bootstrap_resp.error().status());</a>
<a name="ln954">  }</a>
<a name="ln955"> </a>
<a name="ln956">  if (bootstrap_resp.cdc_bootstrap_ids().size() != table_ids.size()) {</a>
<a name="ln957">    cout &lt;&lt; &quot;Received invalid number of bootstrap ids: &quot; &lt;&lt; bootstrap_resp.ShortDebugString();</a>
<a name="ln958">    return STATUS(InternalError, &quot;Invalid number of bootstrap ids&quot;);</a>
<a name="ln959">  }</a>
<a name="ln960"> </a>
<a name="ln961">  int i = 0;</a>
<a name="ln962">  for (const auto&amp; bootstrap_id : bootstrap_resp.cdc_bootstrap_ids()) {</a>
<a name="ln963">    cout &lt;&lt; &quot;table id: &quot; &lt;&lt; table_ids[i++] &lt;&lt; &quot;, CDC bootstrap id: &quot; &lt;&lt; bootstrap_id &lt;&lt; endl;</a>
<a name="ln964">  }</a>
<a name="ln965">  return Status::OK();</a>
<a name="ln966">}</a>
<a name="ln967"> </a>
<a name="ln968">}  // namespace enterprise</a>
<a name="ln969">}  // namespace tools</a>
<a name="ln970">}  // namespace yb</a>

</code></pre>
<div class="balloon" rel="390"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="391"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
