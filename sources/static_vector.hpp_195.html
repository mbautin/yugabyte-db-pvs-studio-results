
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>static_vector.hpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Boost.Container static_vector</a>
<a name="ln2">//</a>
<a name="ln3">// Copyright (c) 2012-2013 Adam Wulkiewicz, Lodz, Poland.</a>
<a name="ln4">// Copyright (c) 2011-2013 Andrew Hundt.</a>
<a name="ln5">// Copyright (c) 2013-2014 Ion Gaztanaga</a>
<a name="ln6">//</a>
<a name="ln7">// Use, modification and distribution is subject to the Boost Software License,</a>
<a name="ln8">// Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at</a>
<a name="ln9">// http://www.boost.org/LICENSE_1_0.txt)</a>
<a name="ln10"> </a>
<a name="ln11">#ifndef BOOST_CONTAINER_STATIC_VECTOR_HPP</a>
<a name="ln12">#define BOOST_CONTAINER_STATIC_VECTOR_HPP</a>
<a name="ln13"> </a>
<a name="ln14">#ifndef BOOST_CONFIG_HPP</a>
<a name="ln15">#  include &lt;boost/config.hpp&gt;</a>
<a name="ln16">#endif</a>
<a name="ln17"> </a>
<a name="ln18">#if defined(BOOST_HAS_PRAGMA_ONCE)</a>
<a name="ln19">#  pragma once</a>
<a name="ln20">#endif</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;boost/container/detail/config_begin.hpp&gt;</a>
<a name="ln23">#include &lt;boost/container/detail/workaround.hpp&gt;</a>
<a name="ln24">#include &lt;boost/container/detail/type_traits.hpp&gt;</a>
<a name="ln25">#include &lt;boost/container/vector.hpp&gt;</a>
<a name="ln26"> </a>
<a name="ln27">#include &lt;cstddef&gt;</a>
<a name="ln28">#if !defined(BOOST_NO_CXX11_HDR_INITIALIZER_LIST)</a>
<a name="ln29">#include &lt;initializer_list&gt;</a>
<a name="ln30">#endif</a>
<a name="ln31"> </a>
<a name="ln32">namespace boost { namespace container {</a>
<a name="ln33"> </a>
<a name="ln34">#ifndef BOOST_CONTAINER_DOXYGEN_INVOKED</a>
<a name="ln35"> </a>
<a name="ln36">namespace dtl {</a>
<a name="ln37"> </a>
<a name="ln38">template&lt;class T, std::size_t N&gt;</a>
<a name="ln39">class static_storage_allocator</a>
<a name="ln40">{</a>
<a name="ln41">   public:</a>
<a name="ln42">   typedef T value_type;</a>
<a name="ln43"> </a>
<a name="ln44">   BOOST_CONTAINER_FORCEINLINE static_storage_allocator() BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln45">   {}</a>
<a name="ln46"> </a>
<a name="ln47">   BOOST_CONTAINER_FORCEINLINE static_storage_allocator(const static_storage_allocator &amp;) BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln48">   {}</a>
<a name="ln49"> </a>
<a name="ln50">   BOOST_CONTAINER_FORCEINLINE static_storage_allocator &amp; operator=(const static_storage_allocator &amp;) BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln51">   {  return *this;  }</a>
<a name="ln52"> </a>
<a name="ln53">   BOOST_CONTAINER_FORCEINLINE T* internal_storage() const BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln54">   {  return const_cast&lt;T*&gt;(static_cast&lt;const T*&gt;(static_cast&lt;const void*&gt;(storage.data)));  }</a>
<a name="ln55"> </a>
<a name="ln56">   BOOST_CONTAINER_FORCEINLINE T* internal_storage() BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln57">   {  return static_cast&lt;T*&gt;(static_cast&lt;void*&gt;(storage.data));  }</a>
<a name="ln58"> </a>
<a name="ln59">   static const std::size_t internal_capacity = N;</a>
<a name="ln60"> </a>
<a name="ln61">   std::size_t max_size() const</a>
<a name="ln62">   {  return N;   }</a>
<a name="ln63"> </a>
<a name="ln64">   typedef boost::container::dtl::version_type&lt;static_storage_allocator, 0&gt;   version;</a>
<a name="ln65"> </a>
<a name="ln66">   BOOST_CONTAINER_FORCEINLINE friend bool operator==(const static_storage_allocator &amp;, const static_storage_allocator &amp;) BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln67">   {  return false;  }</a>
<a name="ln68"> </a>
<a name="ln69">   BOOST_CONTAINER_FORCEINLINE friend bool operator!=(const static_storage_allocator &amp;, const static_storage_allocator &amp;) BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln70">   {  return true;  }</a>
<a name="ln71"> </a>
<a name="ln72">   private:</a>
<a name="ln73">   typename aligned_storage&lt;sizeof(T)*N, alignment_of&lt;T&gt;::value&gt;::type storage;</a>
<a name="ln74">};</a>
<a name="ln75"> </a>
<a name="ln76">}  //namespace dtl {</a>
<a name="ln77"> </a>
<a name="ln78">#endif   //#ifndef BOOST_CONTAINER_DOXYGEN_INVOKED</a>
<a name="ln79"> </a>
<a name="ln80">//!</a>
<a name="ln81">//!@brief A variable-size array container with fixed capacity.</a>
<a name="ln82">//!</a>
<a name="ln83">//!static_vector is a sequence container like boost::container::vector with contiguous storage that can</a>
<a name="ln84">//!change in size, along with the static allocation, low overhead, and fixed capacity of boost::array.</a>
<a name="ln85">//!</a>
<a name="ln86">//!A static_vector is a sequence that supports random access to elements, constant time insertion and</a>
<a name="ln87">//!removal of elements at the end, and linear time insertion and removal of elements at the beginning or</a>
<a name="ln88">//!in the middle. The number of elements in a static_vector may vary dynamically up to a fixed capacity</a>
<a name="ln89">//!because elements are stored within the object itself similarly to an array. However, objects are</a>
<a name="ln90">//!initialized as they are inserted into static_vector unlike C arrays or std::array which must construct</a>
<a name="ln91">//!all elements on instantiation. The behavior of static_vector enables the use of statically allocated</a>
<a name="ln92">//!elements in cases with complex object lifetime requirements that would otherwise not be trivially</a>
<a name="ln93">//!possible.</a>
<a name="ln94">//!</a>
<a name="ln95">//!@par Error Handling</a>
<a name="ln96">//! Insertion beyond the capacity result in throwing std::bad_alloc() if exceptions are enabled or</a>
<a name="ln97">//! calling throw_bad_alloc() if not enabled.</a>
<a name="ln98">//!</a>
<a name="ln99">//! std::out_of_range is thrown if out of bounds access is performed in &lt;code&gt;at()&lt;/code&gt; if exceptions are</a>
<a name="ln100">//! enabled, throw_out_of_range() if not enabled.</a>
<a name="ln101">//!</a>
<a name="ln102">//!@tparam Value    The type of element that will be stored.</a>
<a name="ln103">//!@tparam Capacity The maximum number of elements static_vector can store, fixed at compile time.</a>
<a name="ln104">template &lt;typename Value, std::size_t Capacity&gt;</a>
<a name="ln105">class static_vector</a>
<a name="ln106">    : public vector&lt;Value, dtl::static_storage_allocator&lt;Value, Capacity&gt; &gt;</a>
<a name="ln107">{</a>
<a name="ln108">   #ifndef BOOST_CONTAINER_DOXYGEN_INVOKED</a>
<a name="ln109">   typedef vector&lt;Value, dtl::static_storage_allocator&lt;Value, Capacity&gt; &gt; base_t;</a>
<a name="ln110"> </a>
<a name="ln111">   BOOST_COPYABLE_AND_MOVABLE(static_vector)</a>
<a name="ln112"> </a>
<a name="ln113">   template&lt;class U, std::size_t OtherCapacity&gt;</a>
<a name="ln114">   friend class static_vector;</a>
<a name="ln115"> </a>
<a name="ln116">   public:</a>
<a name="ln117">   typedef dtl::static_storage_allocator&lt;Value, Capacity&gt; allocator_type;</a>
<a name="ln118">   #endif   //#ifndef BOOST_CONTAINER_DOXYGEN_INVOKED</a>
<a name="ln119"> </a>
<a name="ln120">public:</a>
<a name="ln121">    //! @brief The type of elements stored in the container.</a>
<a name="ln122">    typedef typename base_t::value_type value_type;</a>
<a name="ln123">    //! @brief The unsigned integral type used by the container.</a>
<a name="ln124">    typedef typename base_t::size_type size_type;</a>
<a name="ln125">    //! @brief The pointers difference type.</a>
<a name="ln126">    typedef typename base_t::difference_type difference_type;</a>
<a name="ln127">    //! @brief The pointer type.</a>
<a name="ln128">    typedef typename base_t::pointer pointer;</a>
<a name="ln129">    //! @brief The const pointer type.</a>
<a name="ln130">    typedef typename base_t::const_pointer const_pointer;</a>
<a name="ln131">    //! @brief The value reference type.</a>
<a name="ln132">    typedef typename base_t::reference reference;</a>
<a name="ln133">    //! @brief The value const reference type.</a>
<a name="ln134">    typedef typename base_t::const_reference const_reference;</a>
<a name="ln135">    //! @brief The iterator type.</a>
<a name="ln136">    typedef typename base_t::iterator iterator;</a>
<a name="ln137">    //! @brief The const iterator type.</a>
<a name="ln138">    typedef typename base_t::const_iterator const_iterator;</a>
<a name="ln139">    //! @brief The reverse iterator type.</a>
<a name="ln140">    typedef typename base_t::reverse_iterator reverse_iterator;</a>
<a name="ln141">    //! @brief The const reverse iterator.</a>
<a name="ln142">    typedef typename base_t::const_reverse_iterator const_reverse_iterator;</a>
<a name="ln143"> </a>
<a name="ln144">    //! @brief The capacity/max size of the container</a>
<a name="ln145">    static const size_type static_capacity = Capacity;</a>
<a name="ln146"> </a>
<a name="ln147">    //! @brief Constructs an empty static_vector.</a>
<a name="ln148">    //!</a>
<a name="ln149">    //! @par Throws</a>
<a name="ln150">    //!   Nothing.</a>
<a name="ln151">    //!</a>
<a name="ln152">    //! @par Complexity</a>
<a name="ln153">    //!   Constant O(1).</a>
<a name="ln154">    BOOST_CONTAINER_FORCEINLINE static_vector() BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln155">        : base_t()</a>
<a name="ln156">    {}</a>
<a name="ln157"> </a>
<a name="ln158">    //! @pre &lt;tt&gt;count &lt;= capacity()&lt;/tt&gt;</a>
<a name="ln159">    //!</a>
<a name="ln160">    //! @brief Constructs a static_vector containing count value initialized values.</a>
<a name="ln161">    //!</a>
<a name="ln162">    //! @param count    The number of values which will be contained in the container.</a>
<a name="ln163">    //!</a>
<a name="ln164">    //! @par Throws</a>
<a name="ln165">    //!   If Value's value initialization throws.</a>
<a name="ln166">    //!</a>
<a name="ln167">    //! @par Complexity</a>
<a name="ln168">    //!   Linear O(N).</a>
<a name="ln169">    BOOST_CONTAINER_FORCEINLINE explicit static_vector(size_type count)</a>
<a name="ln170">        : base_t(count)</a>
<a name="ln171">    {}</a>
<a name="ln172"> </a>
<a name="ln173">    //! @pre &lt;tt&gt;count &lt;= capacity()&lt;/tt&gt;</a>
<a name="ln174">    //!</a>
<a name="ln175">    //! @brief Constructs a static_vector containing count default initialized values.</a>
<a name="ln176">    //!</a>
<a name="ln177">    //! @param count    The number of values which will be contained in the container.</a>
<a name="ln178">    //!</a>
<a name="ln179">    //! @par Throws</a>
<a name="ln180">    //!   If Value's default initialization throws.</a>
<a name="ln181">    //!</a>
<a name="ln182">    //! @par Complexity</a>
<a name="ln183">    //!   Linear O(N).</a>
<a name="ln184">    //!</a>
<a name="ln185">    //! @par Note</a>
<a name="ln186">    //!   Non-standard extension</a>
<a name="ln187">    BOOST_CONTAINER_FORCEINLINE static_vector(size_type count, default_init_t)</a>
<a name="ln188">        : base_t(count, default_init_t())</a>
<a name="ln189">    {}</a>
<a name="ln190"> </a>
<a name="ln191">    //! @pre &lt;tt&gt;count &lt;= capacity()&lt;/tt&gt;</a>
<a name="ln192">    //!</a>
<a name="ln193">    //! @brief Constructs a static_vector containing count copies of value.</a>
<a name="ln194">    //!</a>
<a name="ln195">    //! @param count    The number of copies of a values that will be contained in the container.</a>
<a name="ln196">    //! @param value    The value which will be used to copy construct values.</a>
<a name="ln197">    //!</a>
<a name="ln198">    //! @par Throws</a>
<a name="ln199">    //!   If Value's copy constructor throws.</a>
<a name="ln200">    //!</a>
<a name="ln201">    //! @par Complexity</a>
<a name="ln202">    //!   Linear O(N).</a>
<a name="ln203">    BOOST_CONTAINER_FORCEINLINE static_vector(size_type count, value_type const&amp; value)</a>
<a name="ln204">        : base_t(count, value)</a>
<a name="ln205">    {}</a>
<a name="ln206"> </a>
<a name="ln207">    //! @pre</a>
<a name="ln208">    //!  @li &lt;tt&gt;distance(first, last) &lt;= capacity()&lt;/tt&gt;</a>
<a name="ln209">    //!  @li Iterator must meet the \c ForwardTraversalIterator concept.</a>
<a name="ln210">    //!</a>
<a name="ln211">    //! @brief Constructs a static_vector containing copy of a range &lt;tt&gt;[first, last)&lt;/tt&gt;.</a>
<a name="ln212">    //!</a>
<a name="ln213">    //! @param first    The iterator to the first element in range.</a>
<a name="ln214">    //! @param last     The iterator to the one after the last element in range.</a>
<a name="ln215">    //!</a>
<a name="ln216">    //! @par Throws</a>
<a name="ln217">    //!   If Value's constructor taking a dereferenced Iterator throws.</a>
<a name="ln218">    //!</a>
<a name="ln219">    //! @par Complexity</a>
<a name="ln220">    //!   Linear O(N).</a>
<a name="ln221">    template &lt;typename Iterator&gt;</a>
<a name="ln222">    BOOST_CONTAINER_FORCEINLINE static_vector(Iterator first, Iterator last)</a>
<a name="ln223">        : base_t(first, last)</a>
<a name="ln224">    {}</a>
<a name="ln225"> </a>
<a name="ln226">#if !defined(BOOST_NO_CXX11_HDR_INITIALIZER_LIST)</a>
<a name="ln227">    //! @pre</a>
<a name="ln228">    //!  @li &lt;tt&gt;distance(il.begin(), il.end()) &lt;= capacity()&lt;/tt&gt;</a>
<a name="ln229">    //!</a>
<a name="ln230">    //! @brief Constructs a static_vector containing copy of a range &lt;tt&gt;[il.begin(), il.end())&lt;/tt&gt;.</a>
<a name="ln231">    //!</a>
<a name="ln232">    //! @param il       std::initializer_list with values to initialize vector.</a>
<a name="ln233">    //!</a>
<a name="ln234">    //! @par Throws</a>
<a name="ln235">    //!   If Value's constructor taking a dereferenced std::initializer_list throws.</a>
<a name="ln236">    //!</a>
<a name="ln237">    //! @par Complexity</a>
<a name="ln238">    //!   Linear O(N).</a>
<a name="ln239">    BOOST_CONTAINER_FORCEINLINE static_vector(std::initializer_list&lt;value_type&gt; il)</a>
<a name="ln240">        : base_t(il)</a>
<a name="ln241">    {}</a>
<a name="ln242">#endif</a>
<a name="ln243"> </a>
<a name="ln244">    //! @brief Constructs a copy of other static_vector.</a>
<a name="ln245">    //!</a>
<a name="ln246">    //! @param other    The static_vector which content will be copied to this one.</a>
<a name="ln247">    //!</a>
<a name="ln248">    //! @par Throws</a>
<a name="ln249">    //!   If Value's copy constructor throws.</a>
<a name="ln250">    //!</a>
<a name="ln251">    //! @par Complexity</a>
<a name="ln252">    //!   Linear O(N).</a>
<a name="ln253">    BOOST_CONTAINER_FORCEINLINE static_vector(static_vector const&amp; other)</a>
<a name="ln254">        : base_t(other)</a>
<a name="ln255">    {}</a>
<a name="ln256"> </a>
<a name="ln257">    BOOST_CONTAINER_FORCEINLINE static_vector(static_vector const&amp; other, const allocator_type &amp;)</a>
<a name="ln258">       : base_t(other)</a>
<a name="ln259">    {}</a>
<a name="ln260"> </a>
<a name="ln261">    BOOST_CONTAINER_FORCEINLINE static_vector(BOOST_RV_REF(static_vector) other,  const allocator_type &amp;)</a>
<a name="ln262">       BOOST_NOEXCEPT_IF(boost::container::dtl::is_nothrow_move_constructible&lt;value_type&gt;::value)</a>
<a name="ln263">       : base_t(BOOST_MOVE_BASE(base_t, other))</a>
<a name="ln264">    {}</a>
<a name="ln265"> </a>
<a name="ln266">    BOOST_CONTAINER_FORCEINLINE explicit static_vector(const allocator_type &amp;)</a>
<a name="ln267">       : base_t()</a>
<a name="ln268">    {}</a>
<a name="ln269"> </a>
<a name="ln270">    //! @pre &lt;tt&gt;other.size() &lt;= capacity()&lt;/tt&gt;.</a>
<a name="ln271">    //!</a>
<a name="ln272">    //! @brief Constructs a copy of other static_vector.</a>
<a name="ln273">    //!</a>
<a name="ln274">    //! @param other    The static_vector which content will be copied to this one.</a>
<a name="ln275">    //!</a>
<a name="ln276">    //! @par Throws</a>
<a name="ln277">    //!   If Value's copy constructor throws.</a>
<a name="ln278">    //!</a>
<a name="ln279">    //! @par Complexity</a>
<a name="ln280">    //!   Linear O(N).</a>
<a name="ln281">    template &lt;std::size_t C&gt;</a>
<a name="ln282">    BOOST_CONTAINER_FORCEINLINE static_vector(static_vector&lt;value_type, C&gt; const&amp; other)</a>
<a name="ln283">        : base_t(other)</a>
<a name="ln284">    {}</a>
<a name="ln285"> </a>
<a name="ln286">    //! @brief Move constructor. Moves Values stored in the other static_vector to this one.</a>
<a name="ln287">    //!</a>
<a name="ln288">    //! @param other    The static_vector which content will be moved to this one.</a>
<a name="ln289">    //!</a>
<a name="ln290">    //! @par Throws</a>
<a name="ln291">    //!   @li If \c has_nothrow_move&lt;Value&gt;::value is \c true and Value's move constructor throws.</a>
<a name="ln292">    //!   @li If \c has_nothrow_move&lt;Value&gt;::value is \c false and Value's copy constructor throws.</a>
<a name="ln293">    //!</a>
<a name="ln294">    //! @par Complexity</a>
<a name="ln295">    //!   Linear O(N).</a>
<a name="ln296">    BOOST_CONTAINER_FORCEINLINE static_vector(BOOST_RV_REF(static_vector) other)</a>
<a name="ln297">      BOOST_NOEXCEPT_IF(boost::container::dtl::is_nothrow_move_constructible&lt;value_type&gt;::value)</a>
<a name="ln298">        : base_t(BOOST_MOVE_BASE(base_t, other))</a>
<a name="ln299">    {}</a>
<a name="ln300"> </a>
<a name="ln301">    //! @pre &lt;tt&gt;other.size() &lt;= capacity()&lt;/tt&gt;</a>
<a name="ln302">    //!</a>
<a name="ln303">    //! @brief Move constructor. Moves Values stored in the other static_vector to this one.</a>
<a name="ln304">    //!</a>
<a name="ln305">    //! @param other    The static_vector which content will be moved to this one.</a>
<a name="ln306">    //!</a>
<a name="ln307">    //! @par Throws</a>
<a name="ln308">    //!   @li If \c has_nothrow_move&lt;Value&gt;::value is \c true and Value's move constructor throws.</a>
<a name="ln309">    //!   @li If \c has_nothrow_move&lt;Value&gt;::value is \c false and Value's copy constructor throws.</a>
<a name="ln310">    //!</a>
<a name="ln311">    //! @par Complexity</a>
<a name="ln312">    //!   Linear O(N).</a>
<a name="ln313">    template &lt;std::size_t C&gt;</a>
<a name="ln314">    BOOST_CONTAINER_FORCEINLINE static_vector(BOOST_RV_REF_BEG static_vector&lt;value_type, C&gt; BOOST_RV_REF_END other)</a>
<a name="ln315">        : base_t(BOOST_MOVE_BASE(typename static_vector&lt;value_type BOOST_MOVE_I C&gt;::base_t, other))</a>
<a name="ln316">    {}</a>
<a name="ln317"> </a>
<a name="ln318">    //! @brief Copy assigns Values stored in the other static_vector to this one.</a>
<a name="ln319">    //!</a>
<a name="ln320">    //! @param other    The static_vector which content will be copied to this one.</a>
<a name="ln321">    //!</a>
<a name="ln322">    //! @par Throws</a>
<a name="ln323">    //!   If Value's copy constructor or copy assignment throws.</a>
<a name="ln324">    //!</a>
<a name="ln325">    //! @par Complexity</a>
<a name="ln326">    //! Linear O(N).</a>
<a name="ln327">    BOOST_CONTAINER_FORCEINLINE static_vector &amp; operator=(BOOST_COPY_ASSIGN_REF(static_vector) other)</a>
<a name="ln328">    {</a>
<a name="ln329">        return static_cast&lt;static_vector&amp;&gt;(base_t::operator=(static_cast&lt;base_t const&amp;&gt;(other)));</a>
<a name="ln330">    }</a>
<a name="ln331"> </a>
<a name="ln332">#if !defined(BOOST_NO_CXX11_HDR_INITIALIZER_LIST)</a>
<a name="ln333">    //! @brief Copy assigns Values stored in std::initializer_list to *this.</a>
<a name="ln334">    //!</a>
<a name="ln335">    //! @param il    The std::initializer_list which content will be copied to this one.</a>
<a name="ln336">    //!</a>
<a name="ln337">    //! @par Throws</a>
<a name="ln338">    //!   If Value's copy constructor or copy assignment throws.</a>
<a name="ln339">    //!</a>
<a name="ln340">    //! @par Complexity</a>
<a name="ln341">    //! Linear O(N).</a>
<a name="ln342">    BOOST_CONTAINER_FORCEINLINE static_vector &amp; operator=(std::initializer_list&lt;value_type&gt; il)</a>
<a name="ln343">    { return static_cast&lt;static_vector&amp;&gt;(base_t::operator=(il));  }</a>
<a name="ln344">#endif</a>
<a name="ln345"> </a>
<a name="ln346">    //! @pre &lt;tt&gt;other.size() &lt;= capacity()&lt;/tt&gt;</a>
<a name="ln347">    //!</a>
<a name="ln348">    //! @brief Copy assigns Values stored in the other static_vector to this one.</a>
<a name="ln349">    //!</a>
<a name="ln350">    //! @param other    The static_vector which content will be copied to this one.</a>
<a name="ln351">    //!</a>
<a name="ln352">    //! @par Throws</a>
<a name="ln353">    //!   If Value's copy constructor or copy assignment throws.</a>
<a name="ln354">    //!</a>
<a name="ln355">    //! @par Complexity</a>
<a name="ln356">    //!   Linear O(N).</a>
<a name="ln357">    template &lt;std::size_t C&gt;</a>
<a name="ln358">    BOOST_CONTAINER_FORCEINLINE static_vector &amp; operator=(static_vector&lt;value_type, C&gt; const&amp; other)</a>
<a name="ln359">    {</a>
<a name="ln360">        return static_cast&lt;static_vector&amp;&gt;(base_t::operator=</a>
<a name="ln361">            (static_cast&lt;typename static_vector&lt;value_type, C&gt;::base_t const&amp;&gt;(other)));</a>
<a name="ln362">    }</a>
<a name="ln363"> </a>
<a name="ln364">    //! @brief Move assignment. Moves Values stored in the other static_vector to this one.</a>
<a name="ln365">    //!</a>
<a name="ln366">    //! @param other    The static_vector which content will be moved to this one.</a>
<a name="ln367">    //!</a>
<a name="ln368">    //! @par Throws</a>
<a name="ln369">    //!   @li If \c has_nothrow_move&lt;Value&gt;::value is \c true and Value's move constructor or move assignment throws.</a>
<a name="ln370">    //!   @li If \c has_nothrow_move&lt;Value&gt;::value is \c false and Value's copy constructor or copy assignment throws.</a>
<a name="ln371">    //!</a>
<a name="ln372">    //! @par Complexity</a>
<a name="ln373">    //!   Linear O(N).</a>
<a name="ln374">    BOOST_CONTAINER_FORCEINLINE static_vector &amp; operator=(BOOST_RV_REF(static_vector) other)</a>
<a name="ln375">       BOOST_NOEXCEPT_IF(boost::container::dtl::is_nothrow_move_assignable&lt;value_type&gt;::value)</a>
<a name="ln376">    {</a>
<a name="ln377">        return static_cast&lt;static_vector&amp;&gt;(base_t::operator=(BOOST_MOVE_BASE(base_t, other)));</a>
<a name="ln378">    }</a>
<a name="ln379"> </a>
<a name="ln380">    //! @pre &lt;tt&gt;other.size() &lt;= capacity()&lt;/tt&gt;</a>
<a name="ln381">    //!</a>
<a name="ln382">    //! @brief Move assignment. Moves Values stored in the other static_vector to this one.</a>
<a name="ln383">    //!</a>
<a name="ln384">    //! @param other    The static_vector which content will be moved to this one.</a>
<a name="ln385">    //!</a>
<a name="ln386">    //! @par Throws</a>
<a name="ln387">    //!   @li If \c has_nothrow_move&lt;Value&gt;::value is \c true and Value's move constructor or move assignment throws.</a>
<a name="ln388">    //!   @li If \c has_nothrow_move&lt;Value&gt;::value is \c false and Value's copy constructor or copy assignment throws.</a>
<a name="ln389">    //!</a>
<a name="ln390">    //! @par Complexity</a>
<a name="ln391">    //!   Linear O(N).</a>
<a name="ln392">    template &lt;std::size_t C&gt;</a>
<a name="ln393">    BOOST_CONTAINER_FORCEINLINE static_vector &amp; operator=(BOOST_RV_REF_BEG static_vector&lt;value_type, C&gt; BOOST_RV_REF_END other)</a>
<a name="ln394">    {</a>
<a name="ln395">        return static_cast&lt;static_vector&amp;&gt;(base_t::operator=</a>
<a name="ln396">         (BOOST_MOVE_BASE(typename static_vector&lt;value_type BOOST_MOVE_I C&gt;::base_t, other)));</a>
<a name="ln397">    }</a>
<a name="ln398"> </a>
<a name="ln399">#ifdef BOOST_CONTAINER_DOXYGEN_INVOKED</a>
<a name="ln400"> </a>
<a name="ln401">    //! @brief Destructor. Destroys Values stored in this container.</a>
<a name="ln402">    //!</a>
<a name="ln403">    //! @par Throws</a>
<a name="ln404">    //!   Nothing</a>
<a name="ln405">    //!</a>
<a name="ln406">    //! @par Complexity</a>
<a name="ln407">    //!   Linear O(N).</a>
<a name="ln408">    ~static_vector();</a>
<a name="ln409"> </a>
<a name="ln410">    //! @brief Swaps contents of the other static_vector and this one.</a>
<a name="ln411">    //!</a>
<a name="ln412">    //! @param other    The static_vector which content will be swapped with this one's content.</a>
<a name="ln413">    //!</a>
<a name="ln414">    //! @par Throws</a>
<a name="ln415">    //!   @li If \c has_nothrow_move&lt;Value&gt;::value is \c true and Value's move constructor or move assignment throws,</a>
<a name="ln416">    //!   @li If \c has_nothrow_move&lt;Value&gt;::value is \c false and Value's copy constructor or copy assignment throws,</a>
<a name="ln417">    //!</a>
<a name="ln418">    //! @par Complexity</a>
<a name="ln419">    //!   Linear O(N).</a>
<a name="ln420">    void swap(static_vector &amp; other);</a>
<a name="ln421"> </a>
<a name="ln422">    //! @pre &lt;tt&gt;other.size() &lt;= capacity() &amp;&amp; size() &lt;= other.capacity()&lt;/tt&gt;</a>
<a name="ln423">    //!</a>
<a name="ln424">    //! @brief Swaps contents of the other static_vector and this one.</a>
<a name="ln425">    //!</a>
<a name="ln426">    //! @param other    The static_vector which content will be swapped with this one's content.</a>
<a name="ln427">    //!</a>
<a name="ln428">    //! @par Throws</a>
<a name="ln429">    //!   @li If \c has_nothrow_move&lt;Value&gt;::value is \c true and Value's move constructor or move assignment throws,</a>
<a name="ln430">    //!   @li If \c has_nothrow_move&lt;Value&gt;::value is \c false and Value's copy constructor or copy assignment throws,</a>
<a name="ln431">    //!</a>
<a name="ln432">    //! @par Complexity</a>
<a name="ln433">    //!   Linear O(N).</a>
<a name="ln434">    template &lt;std::size_t C&gt;</a>
<a name="ln435">    void swap(static_vector&lt;value_type, C&gt; &amp; other);</a>
<a name="ln436"> </a>
<a name="ln437">    //! @pre &lt;tt&gt;count &lt;= capacity()&lt;/tt&gt;</a>
<a name="ln438">    //!</a>
<a name="ln439">    //! @brief Inserts or erases elements at the end such that</a>
<a name="ln440">    //!   the size becomes count. New elements are value initialized.</a>
<a name="ln441">    //!</a>
<a name="ln442">    //! @param count    The number of elements which will be stored in the container.</a>
<a name="ln443">    //!</a>
<a name="ln444">    //! @par Throws</a>
<a name="ln445">    //!   If Value's value initialization throws.</a>
<a name="ln446">    //!</a>
<a name="ln447">    //! @par Complexity</a>
<a name="ln448">    //!   Linear O(N).</a>
<a name="ln449">    void resize(size_type count);</a>
<a name="ln450"> </a>
<a name="ln451">    //! @pre &lt;tt&gt;count &lt;= capacity()&lt;/tt&gt;</a>
<a name="ln452">    //!</a>
<a name="ln453">    //! @brief Inserts or erases elements at the end such that</a>
<a name="ln454">    //!   the size becomes count. New elements are default initialized.</a>
<a name="ln455">    //!</a>
<a name="ln456">    //! @param count    The number of elements which will be stored in the container.</a>
<a name="ln457">    //!</a>
<a name="ln458">    //! @par Throws</a>
<a name="ln459">    //!   If Value's default initialization throws.</a>
<a name="ln460">    //!</a>
<a name="ln461">    //! @par Complexity</a>
<a name="ln462">    //!   Linear O(N).</a>
<a name="ln463">    //!</a>
<a name="ln464">    //! @par Note</a>
<a name="ln465">    //!   Non-standard extension</a>
<a name="ln466">    void resize(size_type count, default_init_t);</a>
<a name="ln467"> </a>
<a name="ln468">    //! @pre &lt;tt&gt;count &lt;= capacity()&lt;/tt&gt;</a>
<a name="ln469">    //!</a>
<a name="ln470">    //! @brief Inserts or erases elements at the end such that</a>
<a name="ln471">    //!   the size becomes count. New elements are copy constructed from value.</a>
<a name="ln472">    //!</a>
<a name="ln473">    //! @param count    The number of elements which will be stored in the container.</a>
<a name="ln474">    //! @param value    The value used to copy construct the new element.</a>
<a name="ln475">    //!</a>
<a name="ln476">    //! @par Throws</a>
<a name="ln477">    //!   If Value's copy constructor throws.</a>
<a name="ln478">    //!</a>
<a name="ln479">    //! @par Complexity</a>
<a name="ln480">    //!   Linear O(N).</a>
<a name="ln481">    void resize(size_type count, value_type const&amp; value);</a>
<a name="ln482"> </a>
<a name="ln483">    //! @pre &lt;tt&gt;count &lt;= capacity()&lt;/tt&gt;</a>
<a name="ln484">    //!</a>
<a name="ln485">    //! @brief This call has no effect because the Capacity of this container is constant.</a>
<a name="ln486">    //!</a>
<a name="ln487">    //! @param count    The number of elements which the container should be able to contain.</a>
<a name="ln488">    //!</a>
<a name="ln489">    //! @par Throws</a>
<a name="ln490">    //!   Nothing.</a>
<a name="ln491">    //!</a>
<a name="ln492">    //! @par Complexity</a>
<a name="ln493">    //!   Linear O(N).</a>
<a name="ln494">    void reserve(size_type count)  BOOST_NOEXCEPT_OR_NOTHROW;</a>
<a name="ln495"> </a>
<a name="ln496">    //! @pre &lt;tt&gt;size() &lt; capacity()&lt;/tt&gt;</a>
<a name="ln497">    //!</a>
<a name="ln498">    //! @brief Adds a copy of value at the end.</a>
<a name="ln499">    //!</a>
<a name="ln500">    //! @param value    The value used to copy construct the new element.</a>
<a name="ln501">    //!</a>
<a name="ln502">    //! @par Throws</a>
<a name="ln503">    //!   If Value's copy constructor throws.</a>
<a name="ln504">    //!</a>
<a name="ln505">    //! @par Complexity</a>
<a name="ln506">    //!   Constant O(1).</a>
<a name="ln507">    void push_back(value_type const&amp; value);</a>
<a name="ln508"> </a>
<a name="ln509">    //! @pre &lt;tt&gt;size() &lt; capacity()&lt;/tt&gt;</a>
<a name="ln510">    //!</a>
<a name="ln511">    //! @brief Moves value to the end.</a>
<a name="ln512">    //!</a>
<a name="ln513">    //! @param value    The value to move construct the new element.</a>
<a name="ln514">    //!</a>
<a name="ln515">    //! @par Throws</a>
<a name="ln516">    //!   If Value's move constructor throws.</a>
<a name="ln517">    //!</a>
<a name="ln518">    //! @par Complexity</a>
<a name="ln519">    //!   Constant O(1).</a>
<a name="ln520">    void push_back(BOOST_RV_REF(value_type) value);</a>
<a name="ln521"> </a>
<a name="ln522">    //! @pre &lt;tt&gt;!empty()&lt;/tt&gt;</a>
<a name="ln523">    //!</a>
<a name="ln524">    //! @brief Destroys last value and decreases the size.</a>
<a name="ln525">    //!</a>
<a name="ln526">    //! @par Throws</a>
<a name="ln527">    //!   Nothing by default.</a>
<a name="ln528">    //!</a>
<a name="ln529">    //! @par Complexity</a>
<a name="ln530">    //!   Constant O(1).</a>
<a name="ln531">    void pop_back();</a>
<a name="ln532"> </a>
<a name="ln533">    //! @pre</a>
<a name="ln534">    //!  @li \c p must be a valid iterator of \c *this in range &lt;tt&gt;[begin(), end()]&lt;/tt&gt;.</a>
<a name="ln535">    //!  @li &lt;tt&gt;size() &lt; capacity()&lt;/tt&gt;</a>
<a name="ln536">    //!</a>
<a name="ln537">    //! @brief Inserts a copy of element at p.</a>
<a name="ln538">    //!</a>
<a name="ln539">    //! @param p     The position at which the new value will be inserted.</a>
<a name="ln540">    //! @param value The value used to copy construct the new element.</a>
<a name="ln541">    //!</a>
<a name="ln542">    //! @par Throws</a>
<a name="ln543">    //!   @li If Value's copy constructor or copy assignment throws</a>
<a name="ln544">    //!   @li If Value's move constructor or move assignment throws.</a>
<a name="ln545">    //!</a>
<a name="ln546">    //! @par Complexity</a>
<a name="ln547">    //!   Constant or linear.</a>
<a name="ln548">    iterator insert(const_iterator p, value_type const&amp; value);</a>
<a name="ln549"> </a>
<a name="ln550">    //! @pre</a>
<a name="ln551">    //!  @li \c p must be a valid iterator of \c *this in range &lt;tt&gt;[begin(), end()]&lt;/tt&gt;.</a>
<a name="ln552">    //!  @li &lt;tt&gt;size() &lt; capacity()&lt;/tt&gt;</a>
<a name="ln553">    //!</a>
<a name="ln554">    //! @brief Inserts a move-constructed element at p.</a>
<a name="ln555">    //!</a>
<a name="ln556">    //! @param p     The position at which the new value will be inserted.</a>
<a name="ln557">    //! @param value The value used to move construct the new element.</a>
<a name="ln558">    //!</a>
<a name="ln559">    //! @par Throws</a>
<a name="ln560">    //!   If Value's move constructor or move assignment throws.</a>
<a name="ln561">    //!</a>
<a name="ln562">    //! @par Complexity</a>
<a name="ln563">    //!   Constant or linear.</a>
<a name="ln564">    iterator insert(const_iterator p, BOOST_RV_REF(value_type) value);</a>
<a name="ln565"> </a>
<a name="ln566">    //! @pre</a>
<a name="ln567">    //!  @li \c p must be a valid iterator of \c *this in range &lt;tt&gt;[begin(), end()]&lt;/tt&gt;.</a>
<a name="ln568">    //!  @li &lt;tt&gt;size() + count &lt;= capacity()&lt;/tt&gt;</a>
<a name="ln569">    //!</a>
<a name="ln570">    //! @brief Inserts a count copies of value at p.</a>
<a name="ln571">    //!</a>
<a name="ln572">    //! @param p     The position at which new elements will be inserted.</a>
<a name="ln573">    //! @param count The number of new elements which will be inserted.</a>
<a name="ln574">    //! @param value The value used to copy construct new elements.</a>
<a name="ln575">    //!</a>
<a name="ln576">    //! @par Throws</a>
<a name="ln577">    //!   @li If Value's copy constructor or copy assignment throws.</a>
<a name="ln578">    //!   @li If Value's move constructor or move assignment throws.</a>
<a name="ln579">    //!</a>
<a name="ln580">    //! @par Complexity</a>
<a name="ln581">    //!   Linear O(N).</a>
<a name="ln582">    iterator insert(const_iterator p, size_type count, value_type const&amp; value);</a>
<a name="ln583"> </a>
<a name="ln584">    //! @pre</a>
<a name="ln585">    //!  @li \c p must be a valid iterator of \c *this in range &lt;tt&gt;[begin(), end()]&lt;/tt&gt;.</a>
<a name="ln586">    //!  @li &lt;tt&gt;distance(first, last) &lt;= capacity()&lt;/tt&gt;</a>
<a name="ln587">    //!  @li \c Iterator must meet the \c ForwardTraversalIterator concept.</a>
<a name="ln588">    //!</a>
<a name="ln589">    //! @brief Inserts a copy of a range &lt;tt&gt;[first, last)&lt;/tt&gt; at p.</a>
<a name="ln590">    //!</a>
<a name="ln591">    //! @param p     The position at which new elements will be inserted.</a>
<a name="ln592">    //! @param first The iterator to the first element of a range used to construct new elements.</a>
<a name="ln593">    //! @param last  The iterator to the one after the last element of a range used to construct new elements.</a>
<a name="ln594">    //!</a>
<a name="ln595">    //! @par Throws</a>
<a name="ln596">    //!   @li If Value's constructor and assignment taking a dereferenced \c Iterator.</a>
<a name="ln597">    //!   @li If Value's move constructor or move assignment throws.</a>
<a name="ln598">    //!</a>
<a name="ln599">    //! @par Complexity</a>
<a name="ln600">    //!   Linear O(N).</a>
<a name="ln601">    template &lt;typename Iterator&gt;</a>
<a name="ln602">    iterator insert(const_iterator p, Iterator first, Iterator last);</a>
<a name="ln603"> </a>
<a name="ln604">    //! @pre</a>
<a name="ln605">    //!  @li \c p must be a valid iterator of \c *this in range &lt;tt&gt;[begin(), end()]&lt;/tt&gt;.</a>
<a name="ln606">    //!  @li &lt;tt&gt;distance(il.begin(), il.end()) &lt;= capacity()&lt;/tt&gt;</a>
<a name="ln607">    //!</a>
<a name="ln608">    //! @brief Inserts a copy of a range &lt;tt&gt;[il.begin(), il.end())&lt;/tt&gt; at p.</a>
<a name="ln609">    //!</a>
<a name="ln610">    //! @param p     The position at which new elements will be inserted.</a>
<a name="ln611">    //! @param il    The std::initializer_list which contains elements that will be inserted.</a>
<a name="ln612">    //!</a>
<a name="ln613">    //! @par Throws</a>
<a name="ln614">    //!   @li If Value's constructor and assignment taking a dereferenced std::initializer_list iterator.</a>
<a name="ln615">    //!</a>
<a name="ln616">    //! @par Complexity</a>
<a name="ln617">    //!   Linear O(N).</a>
<a name="ln618">    iterator insert(const_iterator p, std::initializer_list&lt;value_type&gt; il);</a>
<a name="ln619"> </a>
<a name="ln620">    //! @pre \c p must be a valid iterator of \c *this in range &lt;tt&gt;[begin(), end())&lt;/tt&gt;</a>
<a name="ln621">    //!</a>
<a name="ln622">    //! @brief Erases Value from p.</a>
<a name="ln623">    //!</a>
<a name="ln624">    //! @param p    The position of the element which will be erased from the container.</a>
<a name="ln625">    //!</a>
<a name="ln626">    //! @par Throws</a>
<a name="ln627">    //!   If Value's move assignment throws.</a>
<a name="ln628">    //!</a>
<a name="ln629">    //! @par Complexity</a>
<a name="ln630">    //!   Linear O(N).</a>
<a name="ln631">    iterator erase(const_iterator p);</a>
<a name="ln632"> </a>
<a name="ln633">    //! @pre</a>
<a name="ln634">    //!  @li \c first and \c last must define a valid range</a>
<a name="ln635">    //!  @li iterators must be in range &lt;tt&gt;[begin(), end()]&lt;/tt&gt;</a>
<a name="ln636">    //!</a>
<a name="ln637">    //! @brief Erases Values from a range &lt;tt&gt;[first, last)&lt;/tt&gt;.</a>
<a name="ln638">    //!</a>
<a name="ln639">    //! @param first    The position of the first element of a range which will be erased from the container.</a>
<a name="ln640">    //! @param last     The position of the one after the last element of a range which will be erased from the container.</a>
<a name="ln641">    //!</a>
<a name="ln642">    //! @par Throws</a>
<a name="ln643">    //!   If Value's move assignment throws.</a>
<a name="ln644">    //!</a>
<a name="ln645">    //! @par Complexity</a>
<a name="ln646">    //!   Linear O(N).</a>
<a name="ln647">    iterator erase(const_iterator first, const_iterator last);</a>
<a name="ln648"> </a>
<a name="ln649">    //! @pre &lt;tt&gt;distance(first, last) &lt;= capacity()&lt;/tt&gt;</a>
<a name="ln650">    //!</a>
<a name="ln651">    //! @brief Assigns a range &lt;tt&gt;[first, last)&lt;/tt&gt; of Values to this container.</a>
<a name="ln652">    //!</a>
<a name="ln653">    //! @param first       The iterator to the first element of a range used to construct new content of this container.</a>
<a name="ln654">    //! @param last        The iterator to the one after the last element of a range used to construct new content of this container.</a>
<a name="ln655">    //!</a>
<a name="ln656">    //! @par Throws</a>
<a name="ln657">    //!   If Value's copy constructor or copy assignment throws,</a>
<a name="ln658">    //!</a>
<a name="ln659">    //! @par Complexity</a>
<a name="ln660">    //!   Linear O(N).</a>
<a name="ln661">    template &lt;typename Iterator&gt;</a>
<a name="ln662">    void assign(Iterator first, Iterator last);</a>
<a name="ln663"> </a>
<a name="ln664">    //! @pre &lt;tt&gt;distance(il.begin(), il.end()) &lt;= capacity()&lt;/tt&gt;</a>
<a name="ln665">    //!</a>
<a name="ln666">    //! @brief Assigns a range &lt;tt&gt;[il.begin(), il.end())&lt;/tt&gt; of Values to this container.</a>
<a name="ln667">    //!</a>
<a name="ln668">    //! @param il       std::initializer_list with values used to construct new content of this container.</a>
<a name="ln669">    //!</a>
<a name="ln670">    //! @par Throws</a>
<a name="ln671">    //!   If Value's copy constructor or copy assignment throws,</a>
<a name="ln672">    //!</a>
<a name="ln673">    //! @par Complexity</a>
<a name="ln674">    //!   Linear O(N).</a>
<a name="ln675">    void assign(std::initializer_list&lt;value_type&gt; il);</a>
<a name="ln676"> </a>
<a name="ln677">    //! @pre &lt;tt&gt;count &lt;= capacity()&lt;/tt&gt;</a>
<a name="ln678">    //!</a>
<a name="ln679">    //! @brief Assigns a count copies of value to this container.</a>
<a name="ln680">    //!</a>
<a name="ln681">    //! @param count       The new number of elements which will be container in the container.</a>
<a name="ln682">    //! @param value       The value which will be used to copy construct the new content.</a>
<a name="ln683">    //!</a>
<a name="ln684">    //! @par Throws</a>
<a name="ln685">    //!   If Value's copy constructor or copy assignment throws.</a>
<a name="ln686">    //!</a>
<a name="ln687">    //! @par Complexity</a>
<a name="ln688">    //!   Linear O(N).</a>
<a name="ln689">    void assign(size_type count, value_type const&amp; value);</a>
<a name="ln690"> </a>
<a name="ln691">    //! @pre &lt;tt&gt;size() &lt; capacity()&lt;/tt&gt;</a>
<a name="ln692">    //!</a>
<a name="ln693">    //! @brief Inserts a Value constructed with</a>
<a name="ln694">    //!   \c std::forward&lt;Args&gt;(args)... in the end of the container.</a>
<a name="ln695">    //!</a>
<a name="ln696">    //! @return A reference to the created object.</a>
<a name="ln697">    //!</a>
<a name="ln698">    //! @param args     The arguments of the constructor of the new element which will be created at the end of the container.</a>
<a name="ln699">    //!</a>
<a name="ln700">    //! @par Throws</a>
<a name="ln701">    //!   If in-place constructor throws or Value's move constructor throws.</a>
<a name="ln702">    //!</a>
<a name="ln703">    //! @par Complexity</a>
<a name="ln704">    //!   Constant O(1).</a>
<a name="ln705">    template&lt;class ...Args&gt;</a>
<a name="ln706">    reference emplace_back(Args &amp;&amp;...args);</a>
<a name="ln707"> </a>
<a name="ln708">    //! @pre</a>
<a name="ln709">    //!  @li \c p must be a valid iterator of \c *this in range &lt;tt&gt;[begin(), end()]&lt;/tt&gt;</a>
<a name="ln710">    //!  @li &lt;tt&gt;size() &lt; capacity()&lt;/tt&gt;</a>
<a name="ln711">    //!</a>
<a name="ln712">    //! @brief Inserts a Value constructed with</a>
<a name="ln713">    //!   \c std::forward&lt;Args&gt;(args)... before p</a>
<a name="ln714">    //!</a>
<a name="ln715">    //! @param p     The position at which new elements will be inserted.</a>
<a name="ln716">    //! @param args  The arguments of the constructor of the new element.</a>
<a name="ln717">    //!</a>
<a name="ln718">    //! @par Throws</a>
<a name="ln719">    //!   If in-place constructor throws or if Value's move constructor or move assignment throws.</a>
<a name="ln720">    //!</a>
<a name="ln721">    //! @par Complexity</a>
<a name="ln722">    //!   Constant or linear.</a>
<a name="ln723">    template&lt;class ...Args&gt;</a>
<a name="ln724">    iterator emplace(const_iterator p, Args &amp;&amp;...args);</a>
<a name="ln725"> </a>
<a name="ln726">    //! @brief Removes all elements from the container.</a>
<a name="ln727">    //!</a>
<a name="ln728">    //! @par Throws</a>
<a name="ln729">    //!   Nothing.</a>
<a name="ln730">    //!</a>
<a name="ln731">    //! @par Complexity</a>
<a name="ln732">    //!   Constant O(1).</a>
<a name="ln733">    void clear()  BOOST_NOEXCEPT_OR_NOTHROW;</a>
<a name="ln734"> </a>
<a name="ln735">    //! @pre &lt;tt&gt;i &lt; size()&lt;/tt&gt;</a>
<a name="ln736">    //!</a>
<a name="ln737">    //! @brief Returns reference to the i-th element.</a>
<a name="ln738">    //!</a>
<a name="ln739">    //! @param i    The element's index.</a>
<a name="ln740">    //!</a>
<a name="ln741">    //! @return reference to the i-th element</a>
<a name="ln742">    //!   from the beginning of the container.</a>
<a name="ln743">    //!</a>
<a name="ln744">    //! @par Throws</a>
<a name="ln745">    //!   \c std::out_of_range exception by default.</a>
<a name="ln746">    //!</a>
<a name="ln747">    //! @par Complexity</a>
<a name="ln748">    //!   Constant O(1).</a>
<a name="ln749">    reference at(size_type i);</a>
<a name="ln750"> </a>
<a name="ln751">    //! @pre &lt;tt&gt;i &lt; size()&lt;/tt&gt;</a>
<a name="ln752">    //!</a>
<a name="ln753">    //! @brief Returns const reference to the i-th element.</a>
<a name="ln754">    //!</a>
<a name="ln755">    //! @param i    The element's index.</a>
<a name="ln756">    //!</a>
<a name="ln757">    //! @return const reference to the i-th element</a>
<a name="ln758">    //!   from the beginning of the container.</a>
<a name="ln759">    //!</a>
<a name="ln760">    //! @par Throws</a>
<a name="ln761">    //!   \c std::out_of_range exception by default.</a>
<a name="ln762">    //!</a>
<a name="ln763">    //! @par Complexity</a>
<a name="ln764">    //!   Constant O(1).</a>
<a name="ln765">    const_reference at(size_type i) const;</a>
<a name="ln766"> </a>
<a name="ln767">    //! @pre &lt;tt&gt;i &lt; size()&lt;/tt&gt;</a>
<a name="ln768">    //!</a>
<a name="ln769">    //! @brief Returns reference to the i-th element.</a>
<a name="ln770">    //!</a>
<a name="ln771">    //! @param i    The element's index.</a>
<a name="ln772">    //!</a>
<a name="ln773">    //! @return reference to the i-th element</a>
<a name="ln774">    //!   from the beginning of the container.</a>
<a name="ln775">    //!</a>
<a name="ln776">    //! @par Throws</a>
<a name="ln777">    //!   Nothing by default.</a>
<a name="ln778">    //!</a>
<a name="ln779">    //! @par Complexity</a>
<a name="ln780">    //!   Constant O(1).</a>
<a name="ln781">    reference operator[](size_type i);</a>
<a name="ln782"> </a>
<a name="ln783">    //! @pre &lt;tt&gt;i &lt; size()&lt;/tt&gt;</a>
<a name="ln784">    //!</a>
<a name="ln785">    //! @brief Returns const reference to the i-th element.</a>
<a name="ln786">    //!</a>
<a name="ln787">    //! @param i    The element's index.</a>
<a name="ln788">    //!</a>
<a name="ln789">    //! @return const reference to the i-th element</a>
<a name="ln790">    //!   from the beginning of the container.</a>
<a name="ln791">    //!</a>
<a name="ln792">    //! @par Throws</a>
<a name="ln793">    //!   Nothing by default.</a>
<a name="ln794">    //!</a>
<a name="ln795">    //! @par Complexity</a>
<a name="ln796">    //!   Constant O(1).</a>
<a name="ln797">    const_reference operator[](size_type i) const;</a>
<a name="ln798"> </a>
<a name="ln799">    //! @pre &lt;tt&gt;i =&lt; size()&lt;/tt&gt;</a>
<a name="ln800">    //!</a>
<a name="ln801">    //! @brief Returns a iterator to the i-th element.</a>
<a name="ln802">    //!</a>
<a name="ln803">    //! @param i    The element's index.</a>
<a name="ln804">    //!</a>
<a name="ln805">    //! @return a iterator to the i-th element.</a>
<a name="ln806">    //!</a>
<a name="ln807">    //! @par Throws</a>
<a name="ln808">    //!   Nothing by default.</a>
<a name="ln809">    //!</a>
<a name="ln810">    //! @par Complexity</a>
<a name="ln811">    //!   Constant O(1).</a>
<a name="ln812">    iterator nth(size_type i);</a>
<a name="ln813"> </a>
<a name="ln814">    //! @pre &lt;tt&gt;i =&lt; size()&lt;/tt&gt;</a>
<a name="ln815">    //!</a>
<a name="ln816">    //! @brief Returns a const_iterator to the i-th element.</a>
<a name="ln817">    //!</a>
<a name="ln818">    //! @param i    The element's index.</a>
<a name="ln819">    //!</a>
<a name="ln820">    //! @return a const_iterator to the i-th element.</a>
<a name="ln821">    //!</a>
<a name="ln822">    //! @par Throws</a>
<a name="ln823">    //!   Nothing by default.</a>
<a name="ln824">    //!</a>
<a name="ln825">    //! @par Complexity</a>
<a name="ln826">    //!   Constant O(1).</a>
<a name="ln827">    const_iterator nth(size_type i) const;</a>
<a name="ln828"> </a>
<a name="ln829">    //! @pre &lt;tt&gt;begin() &lt;= p &lt;= end()&lt;/tt&gt;</a>
<a name="ln830">    //!</a>
<a name="ln831">    //! @brief Returns the index of the element pointed by p.</a>
<a name="ln832">    //!</a>
<a name="ln833">    //! @param p    An iterator to the element.</a>
<a name="ln834">    //!</a>
<a name="ln835">    //! @return The index of the element pointed by p.</a>
<a name="ln836">    //!</a>
<a name="ln837">    //! @par Throws</a>
<a name="ln838">    //!   Nothing by default.</a>
<a name="ln839">    //!</a>
<a name="ln840">    //! @par Complexity</a>
<a name="ln841">    //!   Constant O(1).</a>
<a name="ln842">    size_type index_of(iterator p);</a>
<a name="ln843"> </a>
<a name="ln844">    //! @pre &lt;tt&gt;begin() &lt;= p &lt;= end()&lt;/tt&gt;</a>
<a name="ln845">    //!</a>
<a name="ln846">    //! @brief Returns the index of the element pointed by p.</a>
<a name="ln847">    //!</a>
<a name="ln848">    //! @param p    A const_iterator to the element.</a>
<a name="ln849">    //!</a>
<a name="ln850">    //! @return a const_iterator to the i-th element.</a>
<a name="ln851">    //!</a>
<a name="ln852">    //! @par Throws</a>
<a name="ln853">    //!   Nothing by default.</a>
<a name="ln854">    //!</a>
<a name="ln855">    //! @par Complexity</a>
<a name="ln856">    //!   Constant O(1).</a>
<a name="ln857">    size_type index_of(const_iterator p) const;</a>
<a name="ln858"> </a>
<a name="ln859">    //! @pre \c !empty()</a>
<a name="ln860">    //!</a>
<a name="ln861">    //! @brief Returns reference to the first element.</a>
<a name="ln862">    //!</a>
<a name="ln863">    //! @return reference to the first element</a>
<a name="ln864">    //!   from the beginning of the container.</a>
<a name="ln865">    //!</a>
<a name="ln866">    //! @par Throws</a>
<a name="ln867">    //!   Nothing by default.</a>
<a name="ln868">    //!</a>
<a name="ln869">    //! @par Complexity</a>
<a name="ln870">    //!   Constant O(1).</a>
<a name="ln871">    reference front();</a>
<a name="ln872"> </a>
<a name="ln873">    //! @pre \c !empty()</a>
<a name="ln874">    //!</a>
<a name="ln875">    //! @brief Returns const reference to the first element.</a>
<a name="ln876">    //!</a>
<a name="ln877">    //! @return const reference to the first element</a>
<a name="ln878">    //!   from the beginning of the container.</a>
<a name="ln879">    //!</a>
<a name="ln880">    //! @par Throws</a>
<a name="ln881">    //!   Nothing by default.</a>
<a name="ln882">    //!</a>
<a name="ln883">    //! @par Complexity</a>
<a name="ln884">    //!   Constant O(1).</a>
<a name="ln885">    const_reference front() const;</a>
<a name="ln886"> </a>
<a name="ln887">    //! @pre \c !empty()</a>
<a name="ln888">    //!</a>
<a name="ln889">    //! @brief Returns reference to the last element.</a>
<a name="ln890">    //!</a>
<a name="ln891">    //! @return reference to the last element</a>
<a name="ln892">    //!   from the beginning of the container.</a>
<a name="ln893">    //!</a>
<a name="ln894">    //! @par Throws</a>
<a name="ln895">    //!   Nothing by default.</a>
<a name="ln896">    //!</a>
<a name="ln897">    //! @par Complexity</a>
<a name="ln898">    //!   Constant O(1).</a>
<a name="ln899">    reference back();</a>
<a name="ln900"> </a>
<a name="ln901">    //! @pre \c !empty()</a>
<a name="ln902">    //!</a>
<a name="ln903">    //! @brief Returns const reference to the first element.</a>
<a name="ln904">    //!</a>
<a name="ln905">    //! @return const reference to the last element</a>
<a name="ln906">    //!   from the beginning of the container.</a>
<a name="ln907">    //!</a>
<a name="ln908">    //! @par Throws</a>
<a name="ln909">    //!   Nothing by default.</a>
<a name="ln910">    //!</a>
<a name="ln911">    //! @par Complexity</a>
<a name="ln912">    //!   Constant O(1).</a>
<a name="ln913">    const_reference back() const;</a>
<a name="ln914"> </a>
<a name="ln915">    //! @brief Pointer such that &lt;tt&gt;[data(), data() + size())&lt;/tt&gt; is a valid range.</a>
<a name="ln916">    //!   For a non-empty vector &lt;tt&gt;data() == &amp;front()&lt;/tt&gt;.</a>
<a name="ln917">    //!</a>
<a name="ln918">    //! @par Throws</a>
<a name="ln919">    //!   Nothing.</a>
<a name="ln920">    //!</a>
<a name="ln921">    //! @par Complexity</a>
<a name="ln922">    //!   Constant O(1).</a>
<a name="ln923">    Value * data() BOOST_NOEXCEPT_OR_NOTHROW;</a>
<a name="ln924"> </a>
<a name="ln925">    //! @brief Const pointer such that &lt;tt&gt;[data(), data() + size())&lt;/tt&gt; is a valid range.</a>
<a name="ln926">    //!   For a non-empty vector &lt;tt&gt;data() == &amp;front()&lt;/tt&gt;.</a>
<a name="ln927">    //!</a>
<a name="ln928">    //! @par Throws</a>
<a name="ln929">    //!   Nothing.</a>
<a name="ln930">    //!</a>
<a name="ln931">    //! @par Complexity</a>
<a name="ln932">    //!   Constant O(1).</a>
<a name="ln933">    const Value * data() const BOOST_NOEXCEPT_OR_NOTHROW;</a>
<a name="ln934"> </a>
<a name="ln935">    //! @brief Returns iterator to the first element.</a>
<a name="ln936">    //!</a>
<a name="ln937">    //! @return iterator to the first element contained in the vector.</a>
<a name="ln938">    //!</a>
<a name="ln939">    //! @par Throws</a>
<a name="ln940">    //!   Nothing.</a>
<a name="ln941">    //!</a>
<a name="ln942">    //! @par Complexity</a>
<a name="ln943">    //!   Constant O(1).</a>
<a name="ln944">    iterator begin() BOOST_NOEXCEPT_OR_NOTHROW;</a>
<a name="ln945"> </a>
<a name="ln946">    //! @brief Returns const iterator to the first element.</a>
<a name="ln947">    //!</a>
<a name="ln948">    //! @return const_iterator to the first element contained in the vector.</a>
<a name="ln949">    //!</a>
<a name="ln950">    //! @par Throws</a>
<a name="ln951">    //!   Nothing.</a>
<a name="ln952">    //!</a>
<a name="ln953">    //! @par Complexity</a>
<a name="ln954">    //!   Constant O(1).</a>
<a name="ln955">    const_iterator begin() const BOOST_NOEXCEPT_OR_NOTHROW;</a>
<a name="ln956"> </a>
<a name="ln957">    //! @brief Returns const iterator to the first element.</a>
<a name="ln958">    //!</a>
<a name="ln959">    //! @return const_iterator to the first element contained in the vector.</a>
<a name="ln960">    //!</a>
<a name="ln961">    //! @par Throws</a>
<a name="ln962">    //!   Nothing.</a>
<a name="ln963">    //!</a>
<a name="ln964">    //! @par Complexity</a>
<a name="ln965">    //!   Constant O(1).</a>
<a name="ln966">    const_iterator cbegin() const BOOST_NOEXCEPT_OR_NOTHROW;</a>
<a name="ln967"> </a>
<a name="ln968">    //! @brief Returns iterator to the one after the last element.</a>
<a name="ln969">    //!</a>
<a name="ln970">    //! @return iterator pointing to the one after the last element contained in the vector.</a>
<a name="ln971">    //!</a>
<a name="ln972">    //! @par Throws</a>
<a name="ln973">    //!   Nothing.</a>
<a name="ln974">    //!</a>
<a name="ln975">    //! @par Complexity</a>
<a name="ln976">    //!   Constant O(1).</a>
<a name="ln977">    iterator end() BOOST_NOEXCEPT_OR_NOTHROW;</a>
<a name="ln978"> </a>
<a name="ln979">    //! @brief Returns const iterator to the one after the last element.</a>
<a name="ln980">    //!</a>
<a name="ln981">    //! @return const_iterator pointing to the one after the last element contained in the vector.</a>
<a name="ln982">    //!</a>
<a name="ln983">    //! @par Throws</a>
<a name="ln984">    //!   Nothing.</a>
<a name="ln985">    //!</a>
<a name="ln986">    //! @par Complexity</a>
<a name="ln987">    //!   Constant O(1).</a>
<a name="ln988">    const_iterator end() const BOOST_NOEXCEPT_OR_NOTHROW;</a>
<a name="ln989"> </a>
<a name="ln990">    //! @brief Returns const iterator to the one after the last element.</a>
<a name="ln991">    //!</a>
<a name="ln992">    //! @return const_iterator pointing to the one after the last element contained in the vector.</a>
<a name="ln993">    //!</a>
<a name="ln994">    //! @par Throws</a>
<a name="ln995">    //!   Nothing.</a>
<a name="ln996">    //!</a>
<a name="ln997">    //! @par Complexity</a>
<a name="ln998">    //!   Constant O(1).</a>
<a name="ln999">    const_iterator cend() const BOOST_NOEXCEPT_OR_NOTHROW;</a>
<a name="ln1000"> </a>
<a name="ln1001">    //! @brief Returns reverse iterator to the first element of the reversed container.</a>
<a name="ln1002">    //!</a>
<a name="ln1003">    //! @return reverse_iterator pointing to the beginning</a>
<a name="ln1004">    //! of the reversed static_vector.</a>
<a name="ln1005">    //!</a>
<a name="ln1006">    //! @par Throws</a>
<a name="ln1007">    //!   Nothing.</a>
<a name="ln1008">    //!</a>
<a name="ln1009">    //! @par Complexity</a>
<a name="ln1010">    //!   Constant O(1).</a>
<a name="ln1011">    reverse_iterator rbegin() BOOST_NOEXCEPT_OR_NOTHROW;</a>
<a name="ln1012"> </a>
<a name="ln1013">    //! @brief Returns const reverse iterator to the first element of the reversed container.</a>
<a name="ln1014">    //!</a>
<a name="ln1015">    //! @return const_reverse_iterator pointing to the beginning</a>
<a name="ln1016">    //! of the reversed static_vector.</a>
<a name="ln1017">    //!</a>
<a name="ln1018">    //! @par Throws</a>
<a name="ln1019">    //!   Nothing.</a>
<a name="ln1020">    //!</a>
<a name="ln1021">    //! @par Complexity</a>
<a name="ln1022">    //!   Constant O(1).</a>
<a name="ln1023">    const_reverse_iterator rbegin() const BOOST_NOEXCEPT_OR_NOTHROW;</a>
<a name="ln1024"> </a>
<a name="ln1025">    //! @brief Returns const reverse iterator to the first element of the reversed container.</a>
<a name="ln1026">    //!</a>
<a name="ln1027">    //! @return const_reverse_iterator pointing to the beginning</a>
<a name="ln1028">    //! of the reversed static_vector.</a>
<a name="ln1029">    //!</a>
<a name="ln1030">    //! @par Throws</a>
<a name="ln1031">    //!   Nothing.</a>
<a name="ln1032">    //!</a>
<a name="ln1033">    //! @par Complexity</a>
<a name="ln1034">    //!   Constant O(1).</a>
<a name="ln1035">    const_reverse_iterator crbegin() const BOOST_NOEXCEPT_OR_NOTHROW;</a>
<a name="ln1036"> </a>
<a name="ln1037">    //! @brief Returns reverse iterator to the one after the last element of the reversed container.</a>
<a name="ln1038">    //!</a>
<a name="ln1039">    //! @return reverse_iterator pointing to the one after the last element</a>
<a name="ln1040">    //! of the reversed static_vector.</a>
<a name="ln1041">    //!</a>
<a name="ln1042">    //! @par Throws</a>
<a name="ln1043">    //!   Nothing.</a>
<a name="ln1044">    //!</a>
<a name="ln1045">    //! @par Complexity</a>
<a name="ln1046">    //!   Constant O(1).</a>
<a name="ln1047">    reverse_iterator rend() BOOST_NOEXCEPT_OR_NOTHROW;</a>
<a name="ln1048"> </a>
<a name="ln1049">    //! @brief Returns const reverse iterator to the one after the last element of the reversed container.</a>
<a name="ln1050">    //!</a>
<a name="ln1051">    //! @return const_reverse_iterator pointing to the one after the last element</a>
<a name="ln1052">    //! of the reversed static_vector.</a>
<a name="ln1053">    //!</a>
<a name="ln1054">    //! @par Throws</a>
<a name="ln1055">    //!   Nothing.</a>
<a name="ln1056">    //!</a>
<a name="ln1057">    //! @par Complexity</a>
<a name="ln1058">    //!   Constant O(1).</a>
<a name="ln1059">    const_reverse_iterator rend() const BOOST_NOEXCEPT_OR_NOTHROW;</a>
<a name="ln1060"> </a>
<a name="ln1061">    //! @brief Returns const reverse iterator to the one after the last element of the reversed container.</a>
<a name="ln1062">    //!</a>
<a name="ln1063">    //! @return const_reverse_iterator pointing to the one after the last element</a>
<a name="ln1064">    //! of the reversed static_vector.</a>
<a name="ln1065">    //!</a>
<a name="ln1066">    //! @par Throws</a>
<a name="ln1067">    //!   Nothing.</a>
<a name="ln1068">    //!</a>
<a name="ln1069">    //! @par Complexity</a>
<a name="ln1070">    //!   Constant O(1).</a>
<a name="ln1071">    const_reverse_iterator crend() const BOOST_NOEXCEPT_OR_NOTHROW;</a>
<a name="ln1072"> </a>
<a name="ln1073">    //! @brief Returns container's capacity.</a>
<a name="ln1074">    //!</a>
<a name="ln1075">    //! @return container's capacity.</a>
<a name="ln1076">    //!</a>
<a name="ln1077">    //! @par Throws</a>
<a name="ln1078">    //!   Nothing.</a>
<a name="ln1079">    //!</a>
<a name="ln1080">    //! @par Complexity</a>
<a name="ln1081">    //!   Constant O(1).</a>
<a name="ln1082">    static size_type capacity() BOOST_NOEXCEPT_OR_NOTHROW;</a>
<a name="ln1083"> </a>
<a name="ln1084">    //! @brief Returns container's capacity.</a>
<a name="ln1085">    //!</a>
<a name="ln1086">    //! @return container's capacity.</a>
<a name="ln1087">    //!</a>
<a name="ln1088">    //! @par Throws</a>
<a name="ln1089">    //!   Nothing.</a>
<a name="ln1090">    //!</a>
<a name="ln1091">    //! @par Complexity</a>
<a name="ln1092">    //!   Constant O(1).</a>
<a name="ln1093">    static size_type max_size() BOOST_NOEXCEPT_OR_NOTHROW;</a>
<a name="ln1094"> </a>
<a name="ln1095">    //! @brief Returns the number of stored elements.</a>
<a name="ln1096">    //!</a>
<a name="ln1097">    //! @return Number of elements contained in the container.</a>
<a name="ln1098">    //!</a>
<a name="ln1099">    //! @par Throws</a>
<a name="ln1100">    //!   Nothing.</a>
<a name="ln1101">    //!</a>
<a name="ln1102">    //! @par Complexity</a>
<a name="ln1103">    //!   Constant O(1).</a>
<a name="ln1104">    size_type size() const BOOST_NOEXCEPT_OR_NOTHROW;</a>
<a name="ln1105"> </a>
<a name="ln1106">    //! @brief Queries if the container contains elements.</a>
<a name="ln1107">    //!</a>
<a name="ln1108">    //! @return true if the number of elements contained in the</a>
<a name="ln1109">    //!   container is equal to 0.</a>
<a name="ln1110">    //!</a>
<a name="ln1111">    //! @par Throws</a>
<a name="ln1112">    //!   Nothing.</a>
<a name="ln1113">    //!</a>
<a name="ln1114">    //! @par Complexity</a>
<a name="ln1115">    //!   Constant O(1).</a>
<a name="ln1116">    bool empty() const BOOST_NOEXCEPT_OR_NOTHROW;</a>
<a name="ln1117">#else</a>
<a name="ln1118"> </a>
<a name="ln1119">   BOOST_CONTAINER_FORCEINLINE friend void swap(static_vector &amp;x, static_vector &amp;y)</a>
<a name="ln1120">   {</a>
<a name="ln1121">      x.swap(y);</a>
<a name="ln1122">   }</a>
<a name="ln1123"> </a>
<a name="ln1124">#endif // BOOST_CONTAINER_DOXYGEN_INVOKED</a>
<a name="ln1125"> </a>
<a name="ln1126">};</a>
<a name="ln1127"> </a>
<a name="ln1128">#ifdef BOOST_CONTAINER_DOXYGEN_INVOKED</a>
<a name="ln1129"> </a>
<a name="ln1130">//! @brief Checks if contents of two static_vectors are equal.</a>
<a name="ln1131">//!</a>
<a name="ln1132">//! @ingroup static_vector_non_member</a>
<a name="ln1133">//!</a>
<a name="ln1134">//! @param x    The first static_vector.</a>
<a name="ln1135">//! @param y    The second static_vector.</a>
<a name="ln1136">//!</a>
<a name="ln1137">//! @return     \c true if containers have the same size and elements in both containers are equal.</a>
<a name="ln1138">//!</a>
<a name="ln1139">//! @par Complexity</a>
<a name="ln1140">//!   Linear O(N).</a>
<a name="ln1141">template&lt;typename V, std::size_t C1, std::size_t C2&gt;</a>
<a name="ln1142">bool operator== (static_vector&lt;V, C1&gt; const&amp; x, static_vector&lt;V, C2&gt; const&amp; y);</a>
<a name="ln1143"> </a>
<a name="ln1144">//! @brief Checks if contents of two static_vectors are not equal.</a>
<a name="ln1145">//!</a>
<a name="ln1146">//! @ingroup static_vector_non_member</a>
<a name="ln1147">//!</a>
<a name="ln1148">//! @param x    The first static_vector.</a>
<a name="ln1149">//! @param y    The second static_vector.</a>
<a name="ln1150">//!</a>
<a name="ln1151">//! @return     \c true if containers have different size or elements in both containers are not equal.</a>
<a name="ln1152">//!</a>
<a name="ln1153">//! @par Complexity</a>
<a name="ln1154">//!   Linear O(N).</a>
<a name="ln1155">template&lt;typename V, std::size_t C1, std::size_t C2&gt;</a>
<a name="ln1156">bool operator!= (static_vector&lt;V, C1&gt; const&amp; x, static_vector&lt;V, C2&gt; const&amp; y);</a>
<a name="ln1157"> </a>
<a name="ln1158">//! @brief Lexicographically compares static_vectors.</a>
<a name="ln1159">//!</a>
<a name="ln1160">//! @ingroup static_vector_non_member</a>
<a name="ln1161">//!</a>
<a name="ln1162">//! @param x    The first static_vector.</a>
<a name="ln1163">//! @param y    The second static_vector.</a>
<a name="ln1164">//!</a>
<a name="ln1165">//! @return     \c true if x compares lexicographically less than y.</a>
<a name="ln1166">//!</a>
<a name="ln1167">//! @par Complexity</a>
<a name="ln1168">//!   Linear O(N).</a>
<a name="ln1169">template&lt;typename V, std::size_t C1, std::size_t C2&gt;</a>
<a name="ln1170">bool operator&lt; (static_vector&lt;V, C1&gt; const&amp; x, static_vector&lt;V, C2&gt; const&amp; y);</a>
<a name="ln1171"> </a>
<a name="ln1172">//! @brief Lexicographically compares static_vectors.</a>
<a name="ln1173">//!</a>
<a name="ln1174">//! @ingroup static_vector_non_member</a>
<a name="ln1175">//!</a>
<a name="ln1176">//! @param x    The first static_vector.</a>
<a name="ln1177">//! @param y    The second static_vector.</a>
<a name="ln1178">//!</a>
<a name="ln1179">//! @return     \c true if y compares lexicographically less than x.</a>
<a name="ln1180">//!</a>
<a name="ln1181">//! @par Complexity</a>
<a name="ln1182">//!   Linear O(N).</a>
<a name="ln1183">template&lt;typename V, std::size_t C1, std::size_t C2&gt;</a>
<a name="ln1184">bool operator&gt; (static_vector&lt;V, C1&gt; const&amp; x, static_vector&lt;V, C2&gt; const&amp; y);</a>
<a name="ln1185"> </a>
<a name="ln1186">//! @brief Lexicographically compares static_vectors.</a>
<a name="ln1187">//!</a>
<a name="ln1188">//! @ingroup static_vector_non_member</a>
<a name="ln1189">//!</a>
<a name="ln1190">//! @param x    The first static_vector.</a>
<a name="ln1191">//! @param y    The second static_vector.</a>
<a name="ln1192">//!</a>
<a name="ln1193">//! @return     \c true if y don't compare lexicographically less than x.</a>
<a name="ln1194">//!</a>
<a name="ln1195">//! @par Complexity</a>
<a name="ln1196">//!   Linear O(N).</a>
<a name="ln1197">template&lt;typename V, std::size_t C1, std::size_t C2&gt;</a>
<a name="ln1198">bool operator&lt;= (static_vector&lt;V, C1&gt; const&amp; x, static_vector&lt;V, C2&gt; const&amp; y);</a>
<a name="ln1199"> </a>
<a name="ln1200">//! @brief Lexicographically compares static_vectors.</a>
<a name="ln1201">//!</a>
<a name="ln1202">//! @ingroup static_vector_non_member</a>
<a name="ln1203">//!</a>
<a name="ln1204">//! @param x    The first static_vector.</a>
<a name="ln1205">//! @param y    The second static_vector.</a>
<a name="ln1206">//!</a>
<a name="ln1207">//! @return     \c true if x don't compare lexicographically less than y.</a>
<a name="ln1208">//!</a>
<a name="ln1209">//! @par Complexity</a>
<a name="ln1210">//!   Linear O(N).</a>
<a name="ln1211">template&lt;typename V, std::size_t C1, std::size_t C2&gt;</a>
<a name="ln1212">bool operator&gt;= (static_vector&lt;V, C1&gt; const&amp; x, static_vector&lt;V, C2&gt; const&amp; y);</a>
<a name="ln1213"> </a>
<a name="ln1214">//! @brief Swaps contents of two static_vectors.</a>
<a name="ln1215">//!</a>
<a name="ln1216">//! This function calls static_vector::swap().</a>
<a name="ln1217">//!</a>
<a name="ln1218">//! @ingroup static_vector_non_member</a>
<a name="ln1219">//!</a>
<a name="ln1220">//! @param x    The first static_vector.</a>
<a name="ln1221">//! @param y    The second static_vector.</a>
<a name="ln1222">//!</a>
<a name="ln1223">//! @par Complexity</a>
<a name="ln1224">//!   Linear O(N).</a>
<a name="ln1225">template&lt;typename V, std::size_t C1, std::size_t C2&gt;</a>
<a name="ln1226">inline void swap(static_vector&lt;V, C1&gt; &amp; x, static_vector&lt;V, C2&gt; &amp; y);</a>
<a name="ln1227"> </a>
<a name="ln1228">#else</a>
<a name="ln1229"> </a>
<a name="ln1230">template&lt;typename V, std::size_t C1, std::size_t C2&gt;</a>
<a name="ln1231">inline void swap(static_vector&lt;V, C1&gt; &amp; x, static_vector&lt;V, C2&gt; &amp; y</a>
<a name="ln1232">      , typename dtl::enable_if_c&lt; C1 != C2&gt;::type * = 0)</a>
<a name="ln1233">{</a>
<a name="ln1234">   x.swap(y);</a>
<a name="ln1235">}</a>
<a name="ln1236"> </a>
<a name="ln1237">#endif // BOOST_CONTAINER_DOXYGEN_INVOKED</a>
<a name="ln1238"> </a>
<a name="ln1239">}} // namespace boost::container</a>
<a name="ln1240"> </a>
<a name="ln1241">#include &lt;boost/container/detail/config_end.hpp&gt;</a>
<a name="ln1242"> </a>
<a name="ln1243">#endif // BOOST_CONTAINER_STATIC_VECTOR_HPP</a>

</code></pre>
<div class="balloon" rel="44"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: storage.</p></div>
<div class="balloon" rel="47"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: storage.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
