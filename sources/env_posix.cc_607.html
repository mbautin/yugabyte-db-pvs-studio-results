
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>env_posix.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Copyright (c) 2011 The LevelDB Authors. All rights reserved.</a>
<a name="ln2">// Use of this source code is governed by a BSD-style license that can be</a>
<a name="ln3">// found in the LICENSE file. See the AUTHORS file for names of contributors.</a>
<a name="ln4">//</a>
<a name="ln5">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln6">//</a>
<a name="ln7">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln8">//</a>
<a name="ln9">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln10">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln11">//</a>
<a name="ln12">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln13">//</a>
<a name="ln14">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln15">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln16">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln17">// under the License.</a>
<a name="ln18">//</a>
<a name="ln19"> </a>
<a name="ln20">#include &lt;dirent.h&gt;</a>
<a name="ln21">#include &lt;errno.h&gt;</a>
<a name="ln22">#include &lt;fcntl.h&gt;</a>
<a name="ln23">#include &lt;fts.h&gt;</a>
<a name="ln24">#include &lt;limits.h&gt;</a>
<a name="ln25">#include &lt;pthread.h&gt;</a>
<a name="ln26">#include &lt;stdio.h&gt;</a>
<a name="ln27">#include &lt;stdlib.h&gt;</a>
<a name="ln28">#include &lt;string.h&gt;</a>
<a name="ln29">#include &lt;sys/mman.h&gt;</a>
<a name="ln30">#include &lt;sys/stat.h&gt;</a>
<a name="ln31">#include &lt;sys/statvfs.h&gt;</a>
<a name="ln32">#include &lt;sys/time.h&gt;</a>
<a name="ln33">#include &lt;sys/types.h&gt;</a>
<a name="ln34">#include &lt;sys/uio.h&gt;</a>
<a name="ln35">#include &lt;time.h&gt;</a>
<a name="ln36">#include &lt;unistd.h&gt;</a>
<a name="ln37"> </a>
<a name="ln38">#include &lt;set&gt;</a>
<a name="ln39">#include &lt;vector&gt;</a>
<a name="ln40">#include &quot;yb/util/status.h&quot;</a>
<a name="ln41"> </a>
<a name="ln42">#if defined(__APPLE__)</a>
<a name="ln43">#include &lt;mach-o/dyld.h&gt;</a>
<a name="ln44">#include &lt;sys/sysctl.h&gt;</a>
<a name="ln45">#else</a>
<a name="ln46">#include &lt;linux/falloc.h&gt;</a>
<a name="ln47">#include &lt;sys/sysinfo.h&gt;</a>
<a name="ln48">#endif  // defined(__APPLE__)</a>
<a name="ln49">#include &lt;sys/resource.h&gt;</a>
<a name="ln50"> </a>
<a name="ln51">#include &lt;glog/logging.h&gt;</a>
<a name="ln52"> </a>
<a name="ln53">#include &quot;yb/gutil/atomicops.h&quot;</a>
<a name="ln54">#include &quot;yb/gutil/bind.h&quot;</a>
<a name="ln55">#include &quot;yb/gutil/callback.h&quot;</a>
<a name="ln56">#include &quot;yb/gutil/map-util.h&quot;</a>
<a name="ln57">#include &quot;yb/gutil/strings/substitute.h&quot;</a>
<a name="ln58">#include &quot;yb/util/alignment.h&quot;</a>
<a name="ln59">#include &quot;yb/util/debug/trace_event.h&quot;</a>
<a name="ln60">#include &quot;yb/util/env.h&quot;</a>
<a name="ln61">#include &quot;yb/util/errno.h&quot;</a>
<a name="ln62">#include &quot;yb/util/file_system_posix.h&quot;</a>
<a name="ln63">#include &quot;yb/util/flag_tags.h&quot;</a>
<a name="ln64">#include &quot;yb/util/locks.h&quot;</a>
<a name="ln65">#include &quot;yb/util/logging.h&quot;</a>
<a name="ln66">#include &quot;yb/util/malloc.h&quot;</a>
<a name="ln67">#include &quot;yb/util/monotime.h&quot;</a>
<a name="ln68">#include &quot;yb/util/path_util.h&quot;</a>
<a name="ln69">#include &quot;yb/util/slice.h&quot;</a>
<a name="ln70">#include &quot;yb/util/stopwatch.h&quot;</a>
<a name="ln71">#include &quot;yb/util/thread_restrictions.h&quot;</a>
<a name="ln72"> </a>
<a name="ln73">// Copied from falloc.h. Useful for older kernels that lack support for</a>
<a name="ln74">// hole punching; fallocate(2) will return EOPNOTSUPP.</a>
<a name="ln75">#ifndef FALLOC_FL_KEEP_SIZE</a>
<a name="ln76">#define FALLOC_FL_KEEP_SIZE 0x01 /* default is extend size */</a>
<a name="ln77">#endif</a>
<a name="ln78">#ifndef FALLOC_FL_PUNCH_HOLE</a>
<a name="ln79">#define FALLOC_FL_PUNCH_HOLE  0x02 /* de-allocates range */</a>
<a name="ln80">#endif</a>
<a name="ln81"> </a>
<a name="ln82">// For platforms without fdatasync (like OS X)</a>
<a name="ln83">#ifndef fdatasync</a>
<a name="ln84">#define fdatasync fsync</a>
<a name="ln85">#endif</a>
<a name="ln86"> </a>
<a name="ln87">// For platforms without unlocked_stdio (like OS X)</a>
<a name="ln88">#ifndef fread_unlocked</a>
<a name="ln89">#define fread_unlocked fread</a>
<a name="ln90">#endif</a>
<a name="ln91"> </a>
<a name="ln92">// See KUDU-588 for details.</a>
<a name="ln93">DEFINE_bool(writable_file_use_fsync, false,</a>
<a name="ln94">            &quot;Use fsync(2) instead of fdatasync(2) for synchronizing dirty &quot;</a>
<a name="ln95">            &quot;data to disk.&quot;);</a>
<a name="ln96">TAG_FLAG(writable_file_use_fsync, advanced);</a>
<a name="ln97"> </a>
<a name="ln98">DEFINE_bool(suicide_on_eio, true,</a>
<a name="ln99">            &quot;Kill the process if an I/O operation results in EIO&quot;);</a>
<a name="ln100">TAG_FLAG(suicide_on_eio, advanced);</a>
<a name="ln101"> </a>
<a name="ln102">#ifdef __APPLE__</a>
<a name="ln103">// Never fsync on Mac OS X as we are getting many slow fsync errors in Jenkins and the fsync</a>
<a name="ln104">// implementation is very different in production (on Linux) anyway.</a>
<a name="ln105">#define FLAGS_never_fsync_default true</a>
<a name="ln106">#else</a>
<a name="ln107">#define FLAGS_never_fsync_default false</a>
<a name="ln108">#endif</a>
<a name="ln109"> </a>
<a name="ln110">DEFINE_bool(never_fsync, FLAGS_never_fsync_default,</a>
<a name="ln111">            &quot;Never fsync() anything to disk. This is used by certain test cases to &quot;</a>
<a name="ln112">            &quot;speed up runtime. This is very unsafe to use in production.&quot;);</a>
<a name="ln113"> </a>
<a name="ln114">TAG_FLAG(never_fsync, advanced);</a>
<a name="ln115">TAG_FLAG(never_fsync, unsafe);</a>
<a name="ln116"> </a>
<a name="ln117">DEFINE_int32(o_direct_block_size_bytes, 4096,</a>
<a name="ln118">             &quot;Size of the block to use when flag durable_wal_write is set.&quot;);</a>
<a name="ln119">TAG_FLAG(o_direct_block_size_bytes, advanced);</a>
<a name="ln120"> </a>
<a name="ln121">DEFINE_int32(o_direct_block_alignment_bytes, 4096,</a>
<a name="ln122">             &quot;Alignment (in bytes) for blocks used for O_DIRECT operations.&quot;);</a>
<a name="ln123">TAG_FLAG(o_direct_block_alignment_bytes, advanced);</a>
<a name="ln124"> </a>
<a name="ln125">DEFINE_test_flag(bool, simulate_fs_without_fallocate, false,</a>
<a name="ln126">    &quot;If true, the system simulates a file system that doesn't support fallocate.&quot;);</a>
<a name="ln127"> </a>
<a name="ln128">DEFINE_test_flag(int64, simulate_free_space_bytes, -1,</a>
<a name="ln129">    &quot;If a non-negative value, GetFreeSpaceBytes will return the specified value.&quot;);</a>
<a name="ln130"> </a>
<a name="ln131">using base::subtle::Atomic64;</a>
<a name="ln132">using base::subtle::Barrier_AtomicIncrement;</a>
<a name="ln133">using std::vector;</a>
<a name="ln134">using strings::Substitute;</a>
<a name="ln135"> </a>
<a name="ln136">static __thread uint64_t thread_local_id;</a>
<a name="ln137">static Atomic64 cur_thread_local_id_;</a>
<a name="ln138"> </a>
<a name="ln139">namespace yb {</a>
<a name="ln140"> </a>
<a name="ln141">Status IOError(const std::string&amp; context, int err_number, const char* file, int line) {</a>
<a name="ln142">  Errno err(err_number);</a>
<a name="ln143">  switch (err_number) {</a>
<a name="ln144">    case ENOENT:</a>
<a name="ln145">      return Status(Status::kNotFound, file, line, context, err);</a>
<a name="ln146">    case EEXIST:</a>
<a name="ln147">      return Status(Status::kAlreadyPresent, file, line, context, err);</a>
<a name="ln148">    case EOPNOTSUPP:</a>
<a name="ln149">      return Status(Status::kNotSupported, file, line, context, err);</a>
<a name="ln150">    case EIO:</a>
<a name="ln151">      if (FLAGS_suicide_on_eio) {</a>
<a name="ln152">        // TODO: This is very, very coarse-grained. A more comprehensive</a>
<a name="ln153">        // approach is described in KUDU-616.</a>
<a name="ln154">        LOG(FATAL) &lt;&lt; &quot;Fatal I/O error, context: &quot; &lt;&lt; context;</a>
<a name="ln155">      }</a>
<a name="ln156">  }</a>
<a name="ln157">  return Status(Status::kIOError, file, line, context, err);</a>
<a name="ln158">}</a>
<a name="ln159"> </a>
<a name="ln160">namespace {</a>
<a name="ln161"> </a>
<a name="ln162">#if defined(__APPLE__)</a>
<a name="ln163">// Simulates Linux's fallocate file preallocation API on OS X.</a>
<a name="ln164">int fallocate(int fd, int mode, off_t offset, off_t len) {</a>
<a name="ln165">  CHECK_EQ(mode, 0);</a>
<a name="ln166">  off_t size = offset + len;</a>
<a name="ln167"> </a>
<a name="ln168">  struct stat stat;</a>
<a name="ln169">  int ret = fstat(fd, &amp;stat);</a>
<a name="ln170">  if (ret &lt; 0) {</a>
<a name="ln171">    return ret;</a>
<a name="ln172">  }</a>
<a name="ln173"> </a>
<a name="ln174">  if (stat.st_blocks * 512 &lt; size) {</a>
<a name="ln175">    // The offset field seems to have no effect; the file is always allocated</a>
<a name="ln176">    // with space from 0 to the size. This is probably because OS X does not</a>
<a name="ln177">    // support sparse files.</a>
<a name="ln178">    fstore_t store = {F_ALLOCATECONTIG, F_PEOFPOSMODE, 0, size};</a>
<a name="ln179">    if (fcntl(fd, F_PREALLOCATE, &amp;store) &lt; 0) {</a>
<a name="ln180">      LOG(INFO) &lt;&lt; &quot;Unable to allocate contiguous disk space, attempting non-contiguous allocation&quot;;</a>
<a name="ln181">      store.fst_flags = F_ALLOCATEALL;</a>
<a name="ln182">      ret = fcntl(fd, F_PREALLOCATE, &amp;store);</a>
<a name="ln183">      if (ret &lt; 0) {</a>
<a name="ln184">        return ret;</a>
<a name="ln185">      }</a>
<a name="ln186">    }</a>
<a name="ln187">  }</a>
<a name="ln188"> </a>
<a name="ln189">  if (stat.st_size &lt; size) {</a>
<a name="ln190">    // fcntl does not change the file size, so set it if necessary.</a>
<a name="ln191">    return ftruncate(fd, size);</a>
<a name="ln192">  }</a>
<a name="ln193">  return 0;</a>
<a name="ln194">}</a>
<a name="ln195">#endif</a>
<a name="ln196"> </a>
<a name="ln197">// Close file descriptor when object goes out of scope.</a>
<a name="ln198">class ScopedFdCloser {</a>
<a name="ln199"> public:</a>
<a name="ln200">  explicit ScopedFdCloser(int fd)</a>
<a name="ln201">    : fd_(fd) {</a>
<a name="ln202">  }</a>
<a name="ln203"> </a>
<a name="ln204">  ~ScopedFdCloser() {</a>
<a name="ln205">    ThreadRestrictions::AssertIOAllowed();</a>
<a name="ln206">    int err = ::close(fd_);</a>
<a name="ln207">    if (PREDICT_FALSE(err != 0)) {</a>
<a name="ln208">      PLOG(WARNING) &lt;&lt; &quot;Failed to close fd &quot; &lt;&lt; fd_;</a>
<a name="ln209">    }</a>
<a name="ln210">  }</a>
<a name="ln211"> </a>
<a name="ln212"> private:</a>
<a name="ln213">  int fd_;</a>
<a name="ln214">};</a>
<a name="ln215"> </a>
<a name="ln216">#define STATUS_IO_ERROR(context, err_number) IOError(context, err_number, __FILE__, __LINE__)</a>
<a name="ln217"> </a>
<a name="ln218">static Status DoSync(int fd, const string&amp; filename) {</a>
<a name="ln219">  ThreadRestrictions::AssertIOAllowed();</a>
<a name="ln220">  if (FLAGS_never_fsync) return Status::OK();</a>
<a name="ln221">  if (FLAGS_writable_file_use_fsync) {</a>
<a name="ln222">    if (fsync(fd) &lt; 0) {</a>
<a name="ln223">      return STATUS_IO_ERROR(filename, errno);</a>
<a name="ln224">    }</a>
<a name="ln225">  } else {</a>
<a name="ln226">    if (fdatasync(fd) &lt; 0) {</a>
<a name="ln227">      return STATUS_IO_ERROR(filename, errno);</a>
<a name="ln228">    }</a>
<a name="ln229">  }</a>
<a name="ln230">  return Status::OK();</a>
<a name="ln231">}</a>
<a name="ln232"> </a>
<a name="ln233">static Status DoOpen(const string&amp; filename, Env::CreateMode mode, int* fd, int extra_flags = 0) {</a>
<a name="ln234">  ThreadRestrictions::AssertIOAllowed();</a>
<a name="ln235">  int flags = O_RDWR;</a>
<a name="ln236">  switch (mode) {</a>
<a name="ln237">    case Env::CREATE_IF_NON_EXISTING_TRUNCATE:</a>
<a name="ln238">      flags |= O_CREAT | O_TRUNC;</a>
<a name="ln239">      break;</a>
<a name="ln240">    case Env::CREATE_NON_EXISTING:</a>
<a name="ln241">      flags |= O_CREAT | O_EXCL;</a>
<a name="ln242">      break;</a>
<a name="ln243">    case Env::OPEN_EXISTING:</a>
<a name="ln244">      break;</a>
<a name="ln245">    default:</a>
<a name="ln246">      return STATUS(NotSupported, Substitute(&quot;Unknown create mode $0&quot;, mode));</a>
<a name="ln247">  }</a>
<a name="ln248"> </a>
<a name="ln249">  const int f = open(filename.c_str(), flags | extra_flags, 0644);</a>
<a name="ln250">  if (f &lt; 0) {</a>
<a name="ln251">    return STATUS_IO_ERROR(filename, errno);</a>
<a name="ln252">  }</a>
<a name="ln253">  *fd = f;</a>
<a name="ln254">  return Status::OK();</a>
<a name="ln255">}</a>
<a name="ln256"> </a>
<a name="ln257">template &lt;class Extractor&gt;</a>
<a name="ln258">Result&lt;uint64_t&gt; GetFileStat(const std::string&amp; fname, const char* event, Extractor extractor) {</a>
<a name="ln259">  TRACE_EVENT1(&quot;io&quot;, event, &quot;path&quot;, fname);</a>
<a name="ln260">  ThreadRestrictions::AssertIOAllowed();</a>
<a name="ln261">  struct stat sbuf;</a>
<a name="ln262">  if (stat(fname.c_str(), &amp;sbuf) != 0) {</a>
<a name="ln263">    return STATUS_IO_ERROR(fname, errno);</a>
<a name="ln264">  }</a>
<a name="ln265">  return extractor(sbuf);</a>
<a name="ln266">}</a>
<a name="ln267"> </a>
<a name="ln268">// Use non-memory mapped POSIX files to write data to a file.</a>
<a name="ln269">//</a>
<a name="ln270">// TODO (perf) investigate zeroing a pre-allocated allocated area in</a>
<a name="ln271">// order to further improve Sync() performance.</a>
<a name="ln272">class PosixWritableFile : public WritableFile {</a>
<a name="ln273"> public:</a>
<a name="ln274">  PosixWritableFile(std::string fname, int fd, uint64_t file_size,</a>
<a name="ln275">                    bool sync_on_close)</a>
<a name="ln276">      : filename_(std::move(fname)),</a>
<a name="ln277">        fd_(fd),</a>
<a name="ln278">        sync_on_close_(sync_on_close),</a>
<a name="ln279">        filesize_(file_size),</a>
<a name="ln280">        pre_allocated_size_(0),</a>
<a name="ln281">        pending_sync_(false) {}</a>
<a name="ln282"> </a>
<a name="ln283">  ~PosixWritableFile() {</a>
<a name="ln284">    if (fd_ &gt;= 0) {</a>
<a name="ln285">      WARN_NOT_OK(Close(), &quot;Failed to close &quot; + filename_);</a>
<a name="ln286">    }</a>
<a name="ln287">  }</a>
<a name="ln288"> </a>
<a name="ln289">  Status Append(const Slice&amp; data) override {</a>
<a name="ln290">    vector&lt;Slice&gt; data_vector;</a>
<a name="ln291">    data_vector.push_back(data);</a>
<a name="ln292">    return AppendVector(data_vector);</a>
<a name="ln293">  }</a>
<a name="ln294"> </a>
<a name="ln295">  Status AppendVector(const vector&lt;Slice&gt;&amp; data_vector) override {</a>
<a name="ln296">    ThreadRestrictions::AssertIOAllowed();</a>
<a name="ln297">    static const size_t kIovMaxElements = IOV_MAX;</a>
<a name="ln298"> </a>
<a name="ln299">    Status s;</a>
<a name="ln300">    for (size_t i = 0; i &lt; data_vector.size() &amp;&amp; s.ok(); i += kIovMaxElements) {</a>
<a name="ln301">      size_t n = std::min(data_vector.size() - i, kIovMaxElements);</a>
<a name="ln302">      s = DoWritev(data_vector, i, n);</a>
<a name="ln303">    }</a>
<a name="ln304"> </a>
<a name="ln305">    pending_sync_ = true;</a>
<a name="ln306">    return s;</a>
<a name="ln307">  }</a>
<a name="ln308"> </a>
<a name="ln309">  Status PreAllocate(uint64_t size) override {</a>
<a name="ln310">    TRACE_EVENT1(&quot;io&quot;, &quot;PosixWritableFile::PreAllocate&quot;, &quot;path&quot;, filename_);</a>
<a name="ln311">    ThreadRestrictions::AssertIOAllowed();</a>
<a name="ln312">    uint64_t offset = std::max(filesize_, pre_allocated_size_);</a>
<a name="ln313">    if (PREDICT_FALSE(FLAGS_TEST_simulate_fs_without_fallocate)) {</a>
<a name="ln314">      YB_LOG_FIRST_N(WARNING, 1) &lt;&lt; &quot;Simulating a filesystem without fallocate() support&quot;;</a>
<a name="ln315">      return Status::OK();</a>
<a name="ln316">    }</a>
<a name="ln317">    if (fallocate(fd_, 0, offset, size) &lt; 0) {</a>
<a name="ln318">      if (errno == EOPNOTSUPP) {</a>
<a name="ln319">        YB_LOG_FIRST_N(WARNING, 1) &lt;&lt; &quot;The filesystem does not support fallocate().&quot;;</a>
<a name="ln320">      } else if (errno == ENOSYS) {</a>
<a name="ln321">        YB_LOG_FIRST_N(WARNING, 1) &lt;&lt; &quot;The kernel does not implement fallocate().&quot;;</a>
<a name="ln322">      } else {</a>
<a name="ln323">        return STATUS_IO_ERROR(filename_, errno);</a>
<a name="ln324">      }</a>
<a name="ln325">      // We don't want to modify pre_allocated_size_ since nothing was pre-allocated.</a>
<a name="ln326">      return Status::OK();</a>
<a name="ln327">    }</a>
<a name="ln328">    pre_allocated_size_ = offset + size;</a>
<a name="ln329">    return Status::OK();</a>
<a name="ln330">  }</a>
<a name="ln331"> </a>
<a name="ln332">  Status Close() override {</a>
<a name="ln333">    TRACE_EVENT1(&quot;io&quot;, &quot;PosixWritableFile::Close&quot;, &quot;path&quot;, filename_);</a>
<a name="ln334">    ThreadRestrictions::AssertIOAllowed();</a>
<a name="ln335">    Status s;</a>
<a name="ln336"> </a>
<a name="ln337">    // If we've allocated more space than we used, truncate to the</a>
<a name="ln338">    // actual size of the file and perform Sync().</a>
<a name="ln339">    if (filesize_ &lt; pre_allocated_size_) {</a>
<a name="ln340">      if (ftruncate(fd_, filesize_) &lt; 0) {</a>
<a name="ln341">        s = STATUS_IO_ERROR(filename_, errno);</a>
<a name="ln342">        pending_sync_ = true;</a>
<a name="ln343">      }</a>
<a name="ln344">    }</a>
<a name="ln345"> </a>
<a name="ln346">    if (sync_on_close_) {</a>
<a name="ln347">      Status sync_status = Sync();</a>
<a name="ln348">      if (!sync_status.ok()) {</a>
<a name="ln349">        LOG(ERROR) &lt;&lt; &quot;Unable to Sync &quot; &lt;&lt; filename_ &lt;&lt; &quot;: &quot; &lt;&lt; sync_status.ToString();</a>
<a name="ln350">        if (s.ok()) {</a>
<a name="ln351">          s = sync_status;</a>
<a name="ln352">        }</a>
<a name="ln353">      }</a>
<a name="ln354">    }</a>
<a name="ln355"> </a>
<a name="ln356">    if (close(fd_) &lt; 0) {</a>
<a name="ln357">      if (s.ok()) {</a>
<a name="ln358">        s = STATUS_IO_ERROR(filename_, errno);</a>
<a name="ln359">      }</a>
<a name="ln360">    }</a>
<a name="ln361"> </a>
<a name="ln362">    fd_ = -1;</a>
<a name="ln363">    return s;</a>
<a name="ln364">  }</a>
<a name="ln365"> </a>
<a name="ln366">  Status Flush(FlushMode mode) override {</a>
<a name="ln367">    TRACE_EVENT1(&quot;io&quot;, &quot;PosixWritableFile::Flush&quot;, &quot;path&quot;, filename_);</a>
<a name="ln368">    ThreadRestrictions::AssertIOAllowed();</a>
<a name="ln369">#if defined(__linux__)</a>
<a name="ln370">    int flags = SYNC_FILE_RANGE_WRITE;</a>
<a name="ln371">    if (mode == FLUSH_SYNC) {</a>
<a name="ln372">      flags |= SYNC_FILE_RANGE_WAIT_AFTER;</a>
<a name="ln373">    }</a>
<a name="ln374">    if (sync_file_range(fd_, 0, 0, flags) &lt; 0) {</a>
<a name="ln375">      return STATUS_IO_ERROR(filename_, errno);</a>
<a name="ln376">    }</a>
<a name="ln377">#else</a>
<a name="ln378">    if (fsync(fd_) &lt; 0) {</a>
<a name="ln379">      return STATUS_IO_ERROR(filename_, errno);</a>
<a name="ln380">    }</a>
<a name="ln381">#endif</a>
<a name="ln382">    return Status::OK();</a>
<a name="ln383">  }</a>
<a name="ln384"> </a>
<a name="ln385">  Status Sync() override {</a>
<a name="ln386">    TRACE_EVENT1(&quot;io&quot;, &quot;PosixWritableFile::Sync&quot;, &quot;path&quot;, filename_);</a>
<a name="ln387">    ThreadRestrictions::AssertIOAllowed();</a>
<a name="ln388">    LOG_SLOW_EXECUTION(WARNING, 1000, Substitute(&quot;sync call for $0&quot;, filename_)) {</a>
<a name="ln389">      if (pending_sync_) {</a>
<a name="ln390">        pending_sync_ = false;</a>
<a name="ln391">        RETURN_NOT_OK(DoSync(fd_, filename_));</a>
<a name="ln392">      }</a>
<a name="ln393">    }</a>
<a name="ln394">    return Status::OK();</a>
<a name="ln395">  }</a>
<a name="ln396"> </a>
<a name="ln397">  uint64_t Size() const override {</a>
<a name="ln398">    return filesize_;</a>
<a name="ln399">  }</a>
<a name="ln400"> </a>
<a name="ln401">  const string&amp; filename() const override { return filename_; }</a>
<a name="ln402"> </a>
<a name="ln403"> protected:</a>
<a name="ln404">    const std::string filename_;</a>
<a name="ln405">    int fd_;</a>
<a name="ln406">    bool sync_on_close_;</a>
<a name="ln407">    uint64_t filesize_;</a>
<a name="ln408">    uint64_t pre_allocated_size_;</a>
<a name="ln409">    bool pending_sync_;</a>
<a name="ln410"> </a>
<a name="ln411"> private:</a>
<a name="ln412"> </a>
<a name="ln413">  Status DoWritev(const vector&lt;Slice&gt;&amp; data_vector,</a>
<a name="ln414">                  size_t offset, size_t n) {</a>
<a name="ln415">    ThreadRestrictions::AssertIOAllowed();</a>
<a name="ln416">#if defined(__linux__)</a>
<a name="ln417">    DCHECK_LE(n, IOV_MAX);</a>
<a name="ln418"> </a>
<a name="ln419">    struct iovec iov[n];</a>
<a name="ln420">    size_t j = 0;</a>
<a name="ln421">    size_t nbytes = 0;</a>
<a name="ln422"> </a>
<a name="ln423">    for (size_t i = offset; i &lt; offset + n; i++) {</a>
<a name="ln424">      const Slice&amp; data = data_vector[i];</a>
<a name="ln425">      iov[j].iov_base = const_cast&lt;uint8_t*&gt;(data.data());</a>
<a name="ln426">      iov[j].iov_len = data.size();</a>
<a name="ln427">      nbytes += data.size();</a>
<a name="ln428">      ++j;</a>
<a name="ln429">    }</a>
<a name="ln430"> </a>
<a name="ln431">    ssize_t written = pwritev(fd_, iov, n, filesize_);</a>
<a name="ln432"> </a>
<a name="ln433">    if (PREDICT_FALSE(written == -1)) {</a>
<a name="ln434">      int err = errno;</a>
<a name="ln435">      return STATUS_IO_ERROR(filename_, err);</a>
<a name="ln436">    }</a>
<a name="ln437"> </a>
<a name="ln438">    filesize_ += written;</a>
<a name="ln439"> </a>
<a name="ln440">    if (PREDICT_FALSE(written != nbytes)) {</a>
<a name="ln441">      return STATUS(IOError,</a>
<a name="ln442">          Substitute(&quot;pwritev error: expected to write $0 bytes, wrote $1 bytes instead&quot;,</a>
<a name="ln443">                     nbytes, written));</a>
<a name="ln444">    }</a>
<a name="ln445">#else</a>
<a name="ln446">    for (size_t i = offset; i &lt; offset + n; i++) {</a>
<a name="ln447">      const Slice&amp; data = data_vector[i];</a>
<a name="ln448">      ssize_t written = pwrite(fd_, data.data(), data.size(), filesize_);</a>
<a name="ln449">      if (PREDICT_FALSE(written == -1)) {</a>
<a name="ln450">        int err = errno;</a>
<a name="ln451">        return STATUS_IO_ERROR(&quot;pwrite error&quot;, err);</a>
<a name="ln452">      }</a>
<a name="ln453"> </a>
<a name="ln454">      filesize_ += written;</a>
<a name="ln455"> </a>
<a name="ln456">      if (PREDICT_FALSE(written != data.size())) {</a>
<a name="ln457">        return STATUS(IOError,</a>
<a name="ln458">            Substitute(&quot;pwrite error: expected to write $0 bytes, wrote $1 bytes instead&quot;,</a>
<a name="ln459">                       data.size(), written));</a>
<a name="ln460">      }</a>
<a name="ln461">    }</a>
<a name="ln462">#endif</a>
<a name="ln463"> </a>
<a name="ln464">    return Status::OK();</a>
<a name="ln465">  }</a>
<a name="ln466">};</a>
<a name="ln467"> </a>
<a name="ln468">#if defined(__linux__)</a>
<a name="ln469">class PosixDirectIOWritableFile final : public PosixWritableFile {</a>
<a name="ln470"> public:</a>
<a name="ln471">  PosixDirectIOWritableFile(const std::string &amp;fname, int fd, uint64_t file_size,</a>
<a name="ln472">                            bool sync_on_close)</a>
<a name="ln473">      : PosixWritableFile(fname, fd, file_size, false /* sync_on_close */) {</a>
<a name="ln474"> </a>
<a name="ln475">    if (file_size != 0) {</a>
<a name="ln476">      // For now, we don't support appending to an already existing file (of non-zero size).</a>
<a name="ln477">      // TODO(hector): If file size is not a multiple of block_size_, read the</a>
<a name="ln478">      // last aligned block.</a>
<a name="ln479">      LOG(FATAL) &lt;&lt; &quot;file size != 0&quot;;</a>
<a name="ln480">    }</a>
<a name="ln481"> </a>
<a name="ln482">    next_write_offset_ = 0;</a>
<a name="ln483">    last_block_used_bytes_ = 0;</a>
<a name="ln484">    block_size_ = FLAGS_o_direct_block_size_bytes;</a>
<a name="ln485">    last_block_idx_ = 0;</a>
<a name="ln486">    has_new_data_ = false;</a>
<a name="ln487">    real_size_ = 0;</a>
<a name="ln488">    CHECK_GE(block_size_, 512);</a>
<a name="ln489">  }</a>
<a name="ln490"> </a>
<a name="ln491">  ~PosixDirectIOWritableFile() {</a>
<a name="ln492">    if (fd_ &gt;= 0) {</a>
<a name="ln493">      WARN_NOT_OK(Close(), &quot;Failed to close &quot; + filename_);</a>
<a name="ln494">    }</a>
<a name="ln495">  }</a>
<a name="ln496"> </a>
<a name="ln497">  Status Append(const Slice &amp;const_data_slice) override {</a>
<a name="ln498">    ThreadRestrictions::AssertIOAllowed();</a>
<a name="ln499">    Slice data_slice = const_data_slice;</a>
<a name="ln500"> </a>
<a name="ln501">    while (data_slice.size() &gt; 0) {</a>
<a name="ln502">      size_t max_data = IOV_MAX * block_size_ - BufferedByteCount();</a>
<a name="ln503">      CHECK_GT(IOV_MAX, 0);</a>
<a name="ln504">      CHECK_GT(IOV_MAX * block_size_, BufferedByteCount());</a>
<a name="ln505">      CHECK_GT(max_data, 0);</a>
<a name="ln506">      const auto data = Slice(data_slice.data(), std::min(data_slice.size(), max_data));</a>
<a name="ln507"> </a>
<a name="ln508">      RETURN_NOT_OK(MaybeAllocateMemory(data.size()));</a>
<a name="ln509">      RETURN_NOT_OK(WriteToBuffer(data));</a>
<a name="ln510"> </a>
<a name="ln511">      if (data_slice.size() &gt;= max_data) {</a>
<a name="ln512">        data_slice.remove_prefix(max_data);</a>
<a name="ln513">        RETURN_NOT_OK(Sync());</a>
<a name="ln514">      } else {</a>
<a name="ln515">        break;</a>
<a name="ln516">      }</a>
<a name="ln517">    }</a>
<a name="ln518">    real_size_ += const_data_slice.size();</a>
<a name="ln519">    return Status::OK();</a>
<a name="ln520">  }</a>
<a name="ln521"> </a>
<a name="ln522">  Status AppendVector(const vector&lt;Slice&gt; &amp;data_vector) override {</a>
<a name="ln523">    ThreadRestrictions::AssertIOAllowed();</a>
<a name="ln524">    for (auto const &amp;slice : data_vector) {</a>
<a name="ln525">      RETURN_NOT_OK(Append(slice));</a>
<a name="ln526">    }</a>
<a name="ln527">    return Status::OK();</a>
<a name="ln528">  }</a>
<a name="ln529"> </a>
<a name="ln530">  Status Close() override {</a>
<a name="ln531">    TRACE_EVENT1(&quot;io&quot;, &quot;PosixDirectIOWritableFile::Close&quot;, &quot;path&quot;, filename_);</a>
<a name="ln532">    ThreadRestrictions::AssertIOAllowed();</a>
<a name="ln533">    RETURN_NOT_OK(Sync());</a>
<a name="ln534">    LOG(INFO) &lt;&lt; &quot;Closing file &quot; &lt;&lt; filename_ &lt;&lt; &quot; with &quot; &lt;&lt; block_ptr_vec_.size() &lt;&lt; &quot; blocks&quot;;</a>
<a name="ln535">    off_t fsize;</a>
<a name="ln536">    fsize = lseek(fd_, 0, SEEK_END);</a>
<a name="ln537">    CHECK_EQ(fsize, std::max(filesize_, pre_allocated_size_));</a>
<a name="ln538"> </a>
<a name="ln539">    if (real_size_ &lt; filesize_ || real_size_ &lt; pre_allocated_size_) {</a>
<a name="ln540">      LOG(INFO) &lt;&lt; filename_ &lt;&lt; &quot;: Truncating file from size: &quot; &lt;&lt; filesize_</a>
<a name="ln541">                &lt;&lt; &quot; to size: &quot; &lt;&lt; real_size_</a>
<a name="ln542">                &lt;&lt; &quot;. Preallocated size: &quot; &lt;&lt; pre_allocated_size_;</a>
<a name="ln543">      if (ftruncate(fd_, real_size_) != 0) {</a>
<a name="ln544">        return STATUS_IO_ERROR(filename_, errno);</a>
<a name="ln545">      }</a>
<a name="ln546">    }</a>
<a name="ln547"> </a>
<a name="ln548">    if (close(fd_) &lt; 0) {</a>
<a name="ln549">      return STATUS_IO_ERROR(filename_, errno);</a>
<a name="ln550">    }</a>
<a name="ln551"> </a>
<a name="ln552">    fd_ = -1;</a>
<a name="ln553">    return Status::OK();</a>
<a name="ln554">  }</a>
<a name="ln555"> </a>
<a name="ln556">  Status Flush(FlushMode mode) override {</a>
<a name="ln557">    ThreadRestrictions::AssertIOAllowed();</a>
<a name="ln558">    return Sync();</a>
<a name="ln559">  }</a>
<a name="ln560"> </a>
<a name="ln561">  Status Sync() override {</a>
<a name="ln562">    ThreadRestrictions::AssertIOAllowed();</a>
<a name="ln563">    return DoWrite();</a>
<a name="ln564">  }</a>
<a name="ln565"> </a>
<a name="ln566">  uint64_t Size() const override {</a>
<a name="ln567">    return real_size_;</a>
<a name="ln568">  }</a>
<a name="ln569"> </a>
<a name="ln570"> private:</a>
<a name="ln571">  // The number of bytes buffered so far (that will be written out as part of the next write).</a>
<a name="ln572">  size_t BufferedByteCount() {</a>
<a name="ln573">    return last_block_idx_ * block_size_ + last_block_used_bytes_;</a>
<a name="ln574">  }</a>
<a name="ln575"> </a>
<a name="ln576">  Status WriteToBuffer(Slice data) {</a>
<a name="ln577">    auto last_block_used_bytes = last_block_used_bytes_;</a>
<a name="ln578">    auto last_block_idx = last_block_idx_;</a>
<a name="ln579">    auto total_bytes_cached = BufferedByteCount();</a>
<a name="ln580">    auto request_size = data.size();</a>
<a name="ln581"> </a>
<a name="ln582">    CHECK_GT(data.size(), 0);</a>
<a name="ln583">    // Used only for the first block. Reset to 0 after the first memcpy.</a>
<a name="ln584">    size_t block_offset = last_block_used_bytes_;</a>
<a name="ln585">    auto i = last_block_idx_;</a>
<a name="ln586">    if (last_block_used_bytes_ == block_size_) {</a>
<a name="ln587">      // Start writing in a new block if the last block is full.</a>
<a name="ln588">      i++;</a>
<a name="ln589">      block_offset = 0;</a>
<a name="ln590">    }</a>
<a name="ln591">    while (data.size() &gt; 0) {</a>
<a name="ln592">      last_block_used_bytes_ = block_size_;</a>
<a name="ln593">      size_t block_data_size = std::min(data.size(), block_size_ - block_offset);</a>
<a name="ln594">      if (block_data_size + block_offset &lt; block_size_) {</a>
<a name="ln595">        // Writing the last block.</a>
<a name="ln596">        last_block_used_bytes_ = block_data_size + block_offset;</a>
<a name="ln597">        memset(&amp;block_ptr_vec_[i].get()[last_block_used_bytes_], 0,</a>
<a name="ln598">               block_size_ - last_block_used_bytes_);</a>
<a name="ln599">      }</a>
<a name="ln600">      CHECK(i &lt; block_ptr_vec_.size());</a>
<a name="ln601">      memcpy(&amp;block_ptr_vec_[i].get()[block_offset], data.data(), block_data_size);</a>
<a name="ln602">      block_offset = 0;</a>
<a name="ln603">      data.remove_prefix(block_data_size);</a>
<a name="ln604">      last_block_idx_ = i++;</a>
<a name="ln605">      has_new_data_ = true;</a>
<a name="ln606">    }</a>
<a name="ln607"> </a>
<a name="ln608">    CHECK_GE(last_block_idx_, last_block_idx);</a>
<a name="ln609">    if (last_block_idx_ == last_block_idx) {</a>
<a name="ln610">      CHECK_GE(last_block_used_bytes_, last_block_used_bytes);</a>
<a name="ln611">    }</a>
<a name="ln612">    CHECK_EQ(BufferedByteCount(), total_bytes_cached + request_size);</a>
<a name="ln613"> </a>
<a name="ln614">    return Status::OK();</a>
<a name="ln615">  }</a>
<a name="ln616"> </a>
<a name="ln617">  Status DoWrite() {</a>
<a name="ln618">    if (!has_new_data_) {</a>
<a name="ln619">      return Status::OK();</a>
<a name="ln620">    }</a>
<a name="ln621">    CHECK_LE(last_block_used_bytes_, block_size_);</a>
<a name="ln622">    CHECK_LT(last_block_idx_, block_ptr_vec_.size());</a>
<a name="ln623">    auto blocks_to_write = last_block_idx_ + 1;</a>
<a name="ln624">    CHECK_LE(blocks_to_write, IOV_MAX);</a>
<a name="ln625"> </a>
<a name="ln626">    struct iovec iov[blocks_to_write];</a>
<a name="ln627">    for (int j = 0; j &lt; blocks_to_write; j++) {</a>
<a name="ln628">      iov[j].iov_base = block_ptr_vec_[j].get();</a>
<a name="ln629">      iov[j].iov_len = block_size_;</a>
<a name="ln630">    }</a>
<a name="ln631">    auto bytes_to_write = blocks_to_write * block_size_;</a>
<a name="ln632">    ssize_t written = pwritev(fd_, iov, blocks_to_write, next_write_offset_);</a>
<a name="ln633"> </a>
<a name="ln634">    if (PREDICT_FALSE(written == -1)) {</a>
<a name="ln635">      int err = errno;</a>
<a name="ln636">      return STATUS_IO_ERROR(filename_, err);</a>
<a name="ln637">    }</a>
<a name="ln638"> </a>
<a name="ln639">    if (PREDICT_FALSE(written != bytes_to_write)) {</a>
<a name="ln640">      return STATUS(IOError,</a>
<a name="ln641">                    Substitute(&quot;pwritev error: expected to write $0 bytes, wrote $1 bytes instead&quot;,</a>
<a name="ln642">                               bytes_to_write, written));</a>
<a name="ln643">    }</a>
<a name="ln644"> </a>
<a name="ln645">    filesize_ = next_write_offset_ + written;</a>
<a name="ln646">    CHECK_EQ(filesize_, align_up(filesize_, block_size_));</a>
<a name="ln647"> </a>
<a name="ln648">    next_write_offset_ = filesize_;</a>
<a name="ln649"> </a>
<a name="ln650">    if (last_block_used_bytes_ != block_size_) {</a>
<a name="ln651">      // Next write will happen at filesize_ - block_size_ offset in the file if the last block is</a>
<a name="ln652">      // not full.</a>
<a name="ln653">      next_write_offset_ -= block_size_;</a>
<a name="ln654"> </a>
<a name="ln655">      // Since the last block is only partially full, make it the first block so we can append to</a>
<a name="ln656">      // it in the next call.</a>
<a name="ln657">      if (last_block_idx_ &gt; 0) {</a>
<a name="ln658">        std::swap(block_ptr_vec_[0], block_ptr_vec_[last_block_idx_]);</a>
<a name="ln659">      }</a>
<a name="ln660"> </a>
<a name="ln661">    } else {</a>
<a name="ln662">      last_block_used_bytes_ = 0;</a>
<a name="ln663">    }</a>
<a name="ln664">    last_block_idx_ = 0;</a>
<a name="ln665">    has_new_data_ = false;</a>
<a name="ln666">    return Status::OK();</a>
<a name="ln667">  }</a>
<a name="ln668"> </a>
<a name="ln669">  Status MaybeAllocateMemory(size_t data_size) {</a>
<a name="ln670">    auto buffered_data_size = last_block_idx_ * block_size_ + last_block_used_bytes_;</a>
<a name="ln671">    auto bytes_to_write = align_up(buffered_data_size + data_size, block_size_);</a>
<a name="ln672">    auto blocks_to_write = bytes_to_write / block_size_;</a>
<a name="ln673"> </a>
<a name="ln674">    if (blocks_to_write &gt; block_ptr_vec_.size()) {</a>
<a name="ln675">      auto nblocks = blocks_to_write - block_ptr_vec_.size();</a>
<a name="ln676">      for (auto i = 0; i &lt; nblocks; i++) {</a>
<a name="ln677">        void *temp_buf = nullptr;</a>
<a name="ln678">        auto err = posix_memalign(&amp;temp_buf, FLAGS_o_direct_block_alignment_bytes, block_size_);</a>
<a name="ln679">        if (err) {</a>
<a name="ln680">          return STATUS(RuntimeError, &quot;Unable to allocate memory&quot;, Errno(err));</a>
<a name="ln681">        }</a>
<a name="ln682"> </a>
<a name="ln683">        uint8_t *start = static_cast&lt;uint8_t *&gt;(temp_buf);</a>
<a name="ln684">        block_ptr_vec_.push_back(std::shared_ptr&lt;uint8_t&gt;(start, [](uint8_t *p) { free(p); }));</a>
<a name="ln685">      }</a>
<a name="ln686"> </a>
<a name="ln687">      CHECK_EQ(block_ptr_vec_.size() * block_size_, bytes_to_write);</a>
<a name="ln688">    }</a>
<a name="ln689">    return Status::OK();</a>
<a name="ln690">  }</a>
<a name="ln691"> </a>
<a name="ln692">  size_t next_write_offset_;</a>
<a name="ln693">  vector&lt;std::shared_ptr&lt;uint8_t&gt;&gt; block_ptr_vec_;</a>
<a name="ln694">  size_t last_block_used_bytes_;</a>
<a name="ln695">  size_t last_block_idx_;</a>
<a name="ln696">  int block_size_;</a>
<a name="ln697">  bool has_new_data_;</a>
<a name="ln698">  size_t real_size_;</a>
<a name="ln699">};</a>
<a name="ln700">#endif</a>
<a name="ln701"> </a>
<a name="ln702">class PosixRWFile final : public RWFile {</a>
<a name="ln703">// is not employed.</a>
<a name="ln704"> public:</a>
<a name="ln705">  PosixRWFile(string fname, int fd, bool sync_on_close)</a>
<a name="ln706">      : filename_(std::move(fname)),</a>
<a name="ln707">        fd_(fd),</a>
<a name="ln708">        sync_on_close_(sync_on_close),</a>
<a name="ln709">        pending_sync_(false) {}</a>
<a name="ln710"> </a>
<a name="ln711">  ~PosixRWFile() {</a>
<a name="ln712">    if (fd_ &gt;= 0) {</a>
<a name="ln713">      // Virtual method call in destructor.</a>
<a name="ln714">      WARN_NOT_OK(Close(), &quot;Failed to close &quot; + filename_);</a>
<a name="ln715">    }</a>
<a name="ln716">  }</a>
<a name="ln717"> </a>
<a name="ln718">  virtual Status Read(uint64_t offset, size_t length,</a>
<a name="ln719">                      Slice* result, uint8_t* scratch) const override {</a>
<a name="ln720">    ThreadRestrictions::AssertIOAllowed();</a>
<a name="ln721">    int rem = length;</a>
<a name="ln722">    uint8_t* dst = scratch;</a>
<a name="ln723">    while (rem &gt; 0) {</a>
<a name="ln724">      ssize_t r = pread(fd_, dst, rem, offset);</a>
<a name="ln725">      if (r &lt; 0) {</a>
<a name="ln726">        // An error: return a non-ok status.</a>
<a name="ln727">        return STATUS_IO_ERROR(filename_, errno);</a>
<a name="ln728">      }</a>
<a name="ln729">      Slice this_result(dst, r);</a>
<a name="ln730">      DCHECK_LE(this_result.size(), rem);</a>
<a name="ln731">      if (this_result.size() == 0) {</a>
<a name="ln732">        // EOF</a>
<a name="ln733">        return STATUS_FORMAT(IOError, &quot;EOF trying to read $0 bytes at offset $1&quot;, length, offset);</a>
<a name="ln734">      }</a>
<a name="ln735">      dst += this_result.size();</a>
<a name="ln736">      rem -= this_result.size();</a>
<a name="ln737">      offset += this_result.size();</a>
<a name="ln738">    }</a>
<a name="ln739">    DCHECK_EQ(0, rem);</a>
<a name="ln740">    *result = Slice(scratch, length);</a>
<a name="ln741">    return Status::OK();</a>
<a name="ln742">  }</a>
<a name="ln743"> </a>
<a name="ln744">  Status Write(uint64_t offset, const Slice&amp; data) override {</a>
<a name="ln745">    ThreadRestrictions::AssertIOAllowed();</a>
<a name="ln746">    ssize_t written = pwrite(fd_, data.data(), data.size(), offset);</a>
<a name="ln747"> </a>
<a name="ln748">    if (PREDICT_FALSE(written == -1)) {</a>
<a name="ln749">      int err = errno;</a>
<a name="ln750">      return STATUS_IO_ERROR(filename_, err);</a>
<a name="ln751">    }</a>
<a name="ln752"> </a>
<a name="ln753">    if (PREDICT_FALSE(written != data.size())) {</a>
<a name="ln754">      return STATUS(IOError,</a>
<a name="ln755">          Substitute(&quot;pwrite error: expected to write $0 bytes, wrote $1 bytes instead&quot;,</a>
<a name="ln756">                     data.size(), written));</a>
<a name="ln757">    }</a>
<a name="ln758"> </a>
<a name="ln759">    pending_sync_ = true;</a>
<a name="ln760">    return Status::OK();</a>
<a name="ln761">  }</a>
<a name="ln762"> </a>
<a name="ln763">  Status PreAllocate(uint64_t offset, size_t length) override {</a>
<a name="ln764">    TRACE_EVENT1(&quot;io&quot;, &quot;PosixRWFile::PreAllocate&quot;, &quot;path&quot;, filename_);</a>
<a name="ln765">    ThreadRestrictions::AssertIOAllowed();</a>
<a name="ln766">    if (fallocate(fd_, 0, offset, length) &lt; 0) {</a>
<a name="ln767">      if (errno == EOPNOTSUPP) {</a>
<a name="ln768">        YB_LOG_FIRST_N(WARNING, 1) &lt;&lt; &quot;The filesystem does not support fallocate().&quot;;</a>
<a name="ln769">      } else if (errno == ENOSYS) {</a>
<a name="ln770">        YB_LOG_FIRST_N(WARNING, 1) &lt;&lt; &quot;The kernel does not implement fallocate().&quot;;</a>
<a name="ln771">      } else {</a>
<a name="ln772">        return STATUS_IO_ERROR(filename_, errno);</a>
<a name="ln773">      }</a>
<a name="ln774">    }</a>
<a name="ln775">    return Status::OK();</a>
<a name="ln776">  }</a>
<a name="ln777"> </a>
<a name="ln778">  Status PunchHole(uint64_t offset, size_t length) override {</a>
<a name="ln779">#if defined(__linux__)</a>
<a name="ln780">    TRACE_EVENT1(&quot;io&quot;, &quot;PosixRWFile::PunchHole&quot;, &quot;path&quot;, filename_);</a>
<a name="ln781">    ThreadRestrictions::AssertIOAllowed();</a>
<a name="ln782">    if (fallocate(fd_, FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE, offset, length) &lt; 0) {</a>
<a name="ln783">      return STATUS_IO_ERROR(filename_, errno);</a>
<a name="ln784">    }</a>
<a name="ln785">    return Status::OK();</a>
<a name="ln786">#else</a>
<a name="ln787">    return STATUS(NotSupported, &quot;Hole punching not supported on this platform&quot;);</a>
<a name="ln788">#endif</a>
<a name="ln789">  }</a>
<a name="ln790"> </a>
<a name="ln791">  Status Flush(FlushMode mode, uint64_t offset, size_t length) override {</a>
<a name="ln792">    TRACE_EVENT1(&quot;io&quot;, &quot;PosixRWFile::Flush&quot;, &quot;path&quot;, filename_);</a>
<a name="ln793">    ThreadRestrictions::AssertIOAllowed();</a>
<a name="ln794">#if defined(__linux__)</a>
<a name="ln795">    int flags = SYNC_FILE_RANGE_WRITE;</a>
<a name="ln796">    if (mode == FLUSH_SYNC) {</a>
<a name="ln797">      flags |= SYNC_FILE_RANGE_WAIT_AFTER;</a>
<a name="ln798">    }</a>
<a name="ln799">    if (sync_file_range(fd_, offset, length, flags) &lt; 0) {</a>
<a name="ln800">      return STATUS_IO_ERROR(filename_, errno);</a>
<a name="ln801">    }</a>
<a name="ln802">#else</a>
<a name="ln803">    if (fsync(fd_) &lt; 0) {</a>
<a name="ln804">      return STATUS_IO_ERROR(filename_, errno);</a>
<a name="ln805">    }</a>
<a name="ln806">#endif</a>
<a name="ln807">    return Status::OK();</a>
<a name="ln808">  }</a>
<a name="ln809"> </a>
<a name="ln810">  Status Sync() override {</a>
<a name="ln811">    TRACE_EVENT1(&quot;io&quot;, &quot;PosixRWFile::Sync&quot;, &quot;path&quot;, filename_);</a>
<a name="ln812">    ThreadRestrictions::AssertIOAllowed();</a>
<a name="ln813">    LOG_SLOW_EXECUTION(WARNING, 1000, Substitute(&quot;sync call for $0&quot;, filename())) {</a>
<a name="ln814">      if (pending_sync_) {</a>
<a name="ln815">        pending_sync_ = false;</a>
<a name="ln816">        RETURN_NOT_OK(DoSync(fd_, filename_));</a>
<a name="ln817">      }</a>
<a name="ln818">    }</a>
<a name="ln819">    return Status::OK();</a>
<a name="ln820">  }</a>
<a name="ln821"> </a>
<a name="ln822">  Status Close() override {</a>
<a name="ln823">    TRACE_EVENT1(&quot;io&quot;, &quot;PosixRWFile::Close&quot;, &quot;path&quot;, filename_);</a>
<a name="ln824">    ThreadRestrictions::AssertIOAllowed();</a>
<a name="ln825">    Status s;</a>
<a name="ln826"> </a>
<a name="ln827">    if (sync_on_close_) {</a>
<a name="ln828">      // Virtual function call in destructor.</a>
<a name="ln829">      s = Sync();</a>
<a name="ln830">      if (!s.ok()) {</a>
<a name="ln831">        LOG(ERROR) &lt;&lt; &quot;Unable to Sync &quot; &lt;&lt; filename_ &lt;&lt; &quot;: &quot; &lt;&lt; s.ToString();</a>
<a name="ln832">      }</a>
<a name="ln833">    }</a>
<a name="ln834"> </a>
<a name="ln835">    if (close(fd_) &lt; 0) {</a>
<a name="ln836">      if (s.ok()) {</a>
<a name="ln837">        s = STATUS_IO_ERROR(filename_, errno);</a>
<a name="ln838">      }</a>
<a name="ln839">    }</a>
<a name="ln840"> </a>
<a name="ln841">    fd_ = -1;</a>
<a name="ln842">    return s;</a>
<a name="ln843">  }</a>
<a name="ln844"> </a>
<a name="ln845">  Status Size(uint64_t* size) const override {</a>
<a name="ln846">    TRACE_EVENT1(&quot;io&quot;, &quot;PosixRWFile::Size&quot;, &quot;path&quot;, filename_);</a>
<a name="ln847">    ThreadRestrictions::AssertIOAllowed();</a>
<a name="ln848">    struct stat st;</a>
<a name="ln849">    if (fstat(fd_, &amp;st) == -1) {</a>
<a name="ln850">      return STATUS_IO_ERROR(filename_, errno);</a>
<a name="ln851">    }</a>
<a name="ln852">    *size = st.st_size;</a>
<a name="ln853">    return Status::OK();</a>
<a name="ln854">  }</a>
<a name="ln855"> </a>
<a name="ln856">  const string&amp; filename() const override {</a>
<a name="ln857">    return filename_;</a>
<a name="ln858">  }</a>
<a name="ln859"> </a>
<a name="ln860"> private:</a>
<a name="ln861">  const std::string filename_;</a>
<a name="ln862">  int fd_;</a>
<a name="ln863">  bool sync_on_close_;</a>
<a name="ln864">  bool pending_sync_;</a>
<a name="ln865">};</a>
<a name="ln866"> </a>
<a name="ln867">// Set of pathnames that are locked, and a mutex for protecting changes to the set.</a>
<a name="ln868">static std::set&lt;std::string&gt; locked_files;</a>
<a name="ln869">static std::mutex mutex_locked_files;</a>
<a name="ln870"> </a>
<a name="ln871">// Helper function to lock/unlock file whose filename and file descriptor are passed in. Returns -1</a>
<a name="ln872">// on failure and a value other than -1 (as mentioned in fcntl() doc) on success.</a>
<a name="ln873">static int LockOrUnlock(const std::string&amp; fname,</a>
<a name="ln874">                        int fd,</a>
<a name="ln875">                        bool lock,</a>
<a name="ln876">                        bool recursive_lock_ok) {</a>
<a name="ln877">  std::lock_guard&lt;std::mutex&gt; guard(mutex_locked_files);</a>
<a name="ln878">  if (lock) {</a>
<a name="ln879">    // If recursive locks on the same file must be disallowed, but the specified file name already</a>
<a name="ln880">    // exists in the locked_files set, then it is already locked, so we fail this lock attempt.</a>
<a name="ln881">    // Otherwise, we insert the specified file name into locked_files. This check is needed because</a>
<a name="ln882">    // fcntl() does not detect lock conflict if the fcntl is issued by the same thread that earlier</a>
<a name="ln883">    // acquired this lock.</a>
<a name="ln884">    if (!locked_files.insert(fname).second &amp;&amp; !recursive_lock_ok) {</a>
<a name="ln885">      errno = ENOLCK;</a>
<a name="ln886">      return -1;</a>
<a name="ln887">    }</a>
<a name="ln888">  } else {</a>
<a name="ln889">    // If we are unlocking, then verify that we had locked it earlier, it should already exist in</a>
<a name="ln890">    // locked_files. Remove it from locked_files.</a>
<a name="ln891">    if (locked_files.erase(fname) != 1) {</a>
<a name="ln892">      errno = ENOLCK;</a>
<a name="ln893">      return -1;</a>
<a name="ln894">    }</a>
<a name="ln895">  }</a>
<a name="ln896">  errno = 0;</a>
<a name="ln897">  struct flock f;</a>
<a name="ln898">  memset(&amp;f, 0, sizeof(f));</a>
<a name="ln899">  f.l_type = (lock ? F_WRLCK : F_UNLCK);</a>
<a name="ln900">  f.l_whence = SEEK_SET;</a>
<a name="ln901">  f.l_start = 0;</a>
<a name="ln902">  f.l_len = 0; // Lock/unlock entire file.</a>
<a name="ln903">  int value = fcntl(fd, F_SETLK, &amp;f);</a>
<a name="ln904">  if (value == -1 &amp;&amp; lock) {</a>
<a name="ln905">    // If there is an error in locking, then remove the pathname from locked_files.</a>
<a name="ln906">    locked_files.erase(fname);</a>
<a name="ln907">  }</a>
<a name="ln908">  return value;</a>
<a name="ln909">}</a>
<a name="ln910"> </a>
<a name="ln911">class PosixFileLock : public FileLock {</a>
<a name="ln912"> public:</a>
<a name="ln913">  int fd_;</a>
<a name="ln914">  std::string filename;</a>
<a name="ln915">};</a>
<a name="ln916"> </a>
<a name="ln917">class PosixEnv : public Env {</a>
<a name="ln918"> public:</a>
<a name="ln919">  PosixEnv();</a>
<a name="ln920">  explicit PosixEnv(std::unique_ptr&lt;FileFactory&gt; file_factory);</a>
<a name="ln921">  virtual ~PosixEnv() = default;</a>
<a name="ln922"> </a>
<a name="ln923">  virtual Status NewSequentialFile(const std::string&amp; fname,</a>
<a name="ln924">                                   std::unique_ptr&lt;SequentialFile&gt;* result) override {</a>
<a name="ln925">    return file_factory_-&gt;NewSequentialFile(fname, result);</a>
<a name="ln926">  }</a>
<a name="ln927"> </a>
<a name="ln928">  virtual Status NewRandomAccessFile(const std::string&amp; fname,</a>
<a name="ln929">                                     std::unique_ptr&lt;RandomAccessFile&gt;* result) override {</a>
<a name="ln930">    return file_factory_-&gt;NewRandomAccessFile(fname, result);</a>
<a name="ln931">  }</a>
<a name="ln932"> </a>
<a name="ln933">  virtual Status NewWritableFile(const std::string&amp; fname,</a>
<a name="ln934">                                 std::unique_ptr&lt;WritableFile&gt;* result) override {</a>
<a name="ln935">    return file_factory_-&gt;NewWritableFile(fname, result);</a>
<a name="ln936">  }</a>
<a name="ln937"> </a>
<a name="ln938">  virtual Status NewWritableFile(const WritableFileOptions&amp; opts,</a>
<a name="ln939">                                 const std::string&amp; fname,</a>
<a name="ln940">                                 std::unique_ptr&lt;WritableFile&gt;* result) override {</a>
<a name="ln941">    return file_factory_-&gt;NewWritableFile(opts, fname, result);</a>
<a name="ln942">  }</a>
<a name="ln943"> </a>
<a name="ln944">  virtual Status NewTempWritableFile(const WritableFileOptions&amp; opts,</a>
<a name="ln945">                                     const std::string&amp; name_template,</a>
<a name="ln946">                                     std::string* created_filename,</a>
<a name="ln947">                                     std::unique_ptr&lt;WritableFile&gt;* result) override {</a>
<a name="ln948">    return file_factory_-&gt;NewTempWritableFile(opts, name_template, created_filename, result);</a>
<a name="ln949">  }</a>
<a name="ln950"> </a>
<a name="ln951">  virtual Status NewRWFile(const string&amp; fname,</a>
<a name="ln952">                           std::unique_ptr&lt;RWFile&gt;* result) override {</a>
<a name="ln953">    return file_factory_-&gt;NewRWFile(fname, result);</a>
<a name="ln954">  }</a>
<a name="ln955"> </a>
<a name="ln956">  virtual Status NewRWFile(const RWFileOptions&amp; opts,</a>
<a name="ln957">                           const string&amp; fname,</a>
<a name="ln958">                           std::unique_ptr&lt;RWFile&gt;* result) override {</a>
<a name="ln959">    return file_factory_-&gt;NewRWFile(opts, fname, result);</a>
<a name="ln960">  }</a>
<a name="ln961"> </a>
<a name="ln962">  bool FileExists(const std::string&amp; fname) override {</a>
<a name="ln963">    TRACE_EVENT1(&quot;io&quot;, &quot;PosixEnv::FileExists&quot;, &quot;path&quot;, fname);</a>
<a name="ln964">    ThreadRestrictions::AssertIOAllowed();</a>
<a name="ln965">    return access(fname.c_str(), F_OK) == 0;</a>
<a name="ln966">  }</a>
<a name="ln967"> </a>
<a name="ln968">  virtual bool DirExists(const std::string&amp; dname) override {</a>
<a name="ln969">    TRACE_EVENT1(&quot;io&quot;, &quot;PosixEnv::DirExists&quot;, &quot;path&quot;, dname);</a>
<a name="ln970">    ThreadRestrictions::AssertIOAllowed();</a>
<a name="ln971">    struct stat statbuf;</a>
<a name="ln972">    if (stat(dname.c_str(), &amp;statbuf) == 0) {</a>
<a name="ln973">      return S_ISDIR(statbuf.st_mode);</a>
<a name="ln974">    }</a>
<a name="ln975">    return false;</a>
<a name="ln976">  }</a>
<a name="ln977"> </a>
<a name="ln978">  CHECKED_STATUS GetChildren(const std::string&amp; dir,</a>
<a name="ln979">                             ExcludeDots exclude_dots,</a>
<a name="ln980">                             std::vector&lt;std::string&gt;* result) override {</a>
<a name="ln981">    TRACE_EVENT1(&quot;io&quot;, &quot;PosixEnv::GetChildren&quot;, &quot;path&quot;, dir);</a>
<a name="ln982">    ThreadRestrictions::AssertIOAllowed();</a>
<a name="ln983">    result-&gt;clear();</a>
<a name="ln984">    DIR* d = opendir(dir.c_str());</a>
<a name="ln985">    if (d == nullptr) {</a>
<a name="ln986">      return STATUS_IO_ERROR(dir, errno);</a>
<a name="ln987">    }</a>
<a name="ln988">    struct dirent* entry;</a>
<a name="ln989">    // TODO: lint: Consider using readdir_r(...) instead of readdir(...) for improved thread safety.</a>
<a name="ln990">    while ((entry = readdir(d)) != nullptr) {</a>
<a name="ln991">      if (exclude_dots &amp;&amp; (strcmp(entry-&gt;d_name, &quot;.&quot;) == 0 || strcmp(entry-&gt;d_name, &quot;..&quot;) == 0)) {</a>
<a name="ln992">        continue;</a>
<a name="ln993">      }</a>
<a name="ln994">      result-&gt;push_back(entry-&gt;d_name);</a>
<a name="ln995">    }</a>
<a name="ln996">    closedir(d);</a>
<a name="ln997">    return Status::OK();</a>
<a name="ln998">  }</a>
<a name="ln999"> </a>
<a name="ln1000">  Status DeleteFile(const std::string&amp; fname) override {</a>
<a name="ln1001">    TRACE_EVENT1(&quot;io&quot;, &quot;PosixEnv::DeleteFile&quot;, &quot;path&quot;, fname);</a>
<a name="ln1002">    ThreadRestrictions::AssertIOAllowed();</a>
<a name="ln1003">    Status result;</a>
<a name="ln1004">    if (unlink(fname.c_str()) != 0) {</a>
<a name="ln1005">      result = STATUS_IO_ERROR(fname, errno);</a>
<a name="ln1006">    }</a>
<a name="ln1007">    return result;</a>
<a name="ln1008">  };</a>
<a name="ln1009"> </a>
<a name="ln1010">  Status CreateDir(const std::string&amp; name) override {</a>
<a name="ln1011">    TRACE_EVENT1(&quot;io&quot;, &quot;PosixEnv::CreateDir&quot;, &quot;path&quot;, name);</a>
<a name="ln1012">    ThreadRestrictions::AssertIOAllowed();</a>
<a name="ln1013">    Status result;</a>
<a name="ln1014">    if (mkdir(name.c_str(), 0755) != 0) {</a>
<a name="ln1015">      result = STATUS_IO_ERROR(name, errno);</a>
<a name="ln1016">    }</a>
<a name="ln1017">    return result;</a>
<a name="ln1018">  };</a>
<a name="ln1019"> </a>
<a name="ln1020">  Status DeleteDir(const std::string&amp; name) override {</a>
<a name="ln1021">    TRACE_EVENT1(&quot;io&quot;, &quot;PosixEnv::DeleteDir&quot;, &quot;path&quot;, name);</a>
<a name="ln1022">    ThreadRestrictions::AssertIOAllowed();</a>
<a name="ln1023">    Status result;</a>
<a name="ln1024">    if (rmdir(name.c_str()) != 0) {</a>
<a name="ln1025">      result = STATUS_IO_ERROR(name, errno);</a>
<a name="ln1026">    }</a>
<a name="ln1027">    return result;</a>
<a name="ln1028">  };</a>
<a name="ln1029"> </a>
<a name="ln1030">  Status SyncDir(const std::string&amp; dirname) override {</a>
<a name="ln1031">    TRACE_EVENT1(&quot;io&quot;, &quot;SyncDir&quot;, &quot;path&quot;, dirname);</a>
<a name="ln1032">    ThreadRestrictions::AssertIOAllowed();</a>
<a name="ln1033">    if (FLAGS_never_fsync) return Status::OK();</a>
<a name="ln1034">    int dir_fd;</a>
<a name="ln1035">    if ((dir_fd = open(dirname.c_str(), O_DIRECTORY|O_RDONLY)) == -1) {</a>
<a name="ln1036">      return STATUS_IO_ERROR(dirname, errno);</a>
<a name="ln1037">    }</a>
<a name="ln1038">    ScopedFdCloser fd_closer(dir_fd);</a>
<a name="ln1039">    if (fsync(dir_fd) != 0) {</a>
<a name="ln1040">      return STATUS_IO_ERROR(dirname, errno);</a>
<a name="ln1041">    }</a>
<a name="ln1042">    return Status::OK();</a>
<a name="ln1043">  }</a>
<a name="ln1044"> </a>
<a name="ln1045">  Status DeleteRecursively(const std::string &amp;name) override {</a>
<a name="ln1046">    return Walk(name, POST_ORDER, Bind(&amp;PosixEnv::DeleteRecursivelyCb,</a>
<a name="ln1047">                                       Unretained(this)));</a>
<a name="ln1048">  }</a>
<a name="ln1049"> </a>
<a name="ln1050">  Result&lt;uint64_t&gt; GetFileSize(const std::string&amp; fname) override {</a>
<a name="ln1051">    return file_factory_-&gt;GetFileSize(fname);</a>
<a name="ln1052">  }</a>
<a name="ln1053"> </a>
<a name="ln1054">  Result&lt;uint64_t&gt; GetFileINode(const std::string&amp; fname) override {</a>
<a name="ln1055">    return GetFileStat(</a>
<a name="ln1056">        fname, &quot;PosixEnv::GetFileINode&quot;, [](const struct stat&amp; sbuf) { return sbuf.st_ino; });</a>
<a name="ln1057">  }</a>
<a name="ln1058"> </a>
<a name="ln1059">  Result&lt;uint64_t&gt; GetFileSizeOnDisk(const std::string&amp; fname) override {</a>
<a name="ln1060">    return GetFileStat(</a>
<a name="ln1061">        fname, &quot;PosixEnv::GetFileSizeOnDisk&quot;, [](const struct stat&amp; sbuf) {</a>
<a name="ln1062">          // From stat(2):</a>
<a name="ln1063">          //</a>
<a name="ln1064">          //   The st_blocks field indicates the number of blocks allocated to</a>
<a name="ln1065">          //   the file, 512-byte units. (This may be smaller than st_size/512</a>
<a name="ln1066">          //   when the file has holes.)</a>
<a name="ln1067">          return sbuf.st_blocks * 512;</a>
<a name="ln1068">        });</a>
<a name="ln1069">  }</a>
<a name="ln1070"> </a>
<a name="ln1071">  Result&lt;uint64_t&gt; GetBlockSize(const string&amp; fname) override {</a>
<a name="ln1072">    return GetFileStat(</a>
<a name="ln1073">        fname, &quot;PosixEnv::GetBlockSize&quot;, [](const struct stat&amp; sbuf) { return sbuf.st_blksize; });</a>
<a name="ln1074">  }</a>
<a name="ln1075"> </a>
<a name="ln1076">  CHECKED_STATUS LinkFile(const std::string&amp; src,</a>
<a name="ln1077">                          const std::string&amp; target) override {</a>
<a name="ln1078">    if (link(src.c_str(), target.c_str()) != 0) {</a>
<a name="ln1079">      if (errno == EXDEV) {</a>
<a name="ln1080">        return STATUS(NotSupported, &quot;No cross FS links allowed&quot;);</a>
<a name="ln1081">      }</a>
<a name="ln1082">      return STATUS_IO_ERROR(src, errno);</a>
<a name="ln1083">    }</a>
<a name="ln1084">    return Status::OK();</a>
<a name="ln1085">  }</a>
<a name="ln1086"> </a>
<a name="ln1087">  Result&lt;std::string&gt; ReadLink(const std::string&amp; link) override {</a>
<a name="ln1088">    char buf[PATH_MAX];</a>
<a name="ln1089">    const auto len = readlink(link.c_str(), buf, sizeof(buf));</a>
<a name="ln1090">    if (len &gt; -1) {</a>
<a name="ln1091">      return std::string(buf, buf + len);</a>
<a name="ln1092">    }</a>
<a name="ln1093">    return STATUS_IO_ERROR(link, errno);</a>
<a name="ln1094">  }</a>
<a name="ln1095"> </a>
<a name="ln1096">  Status RenameFile(const std::string&amp; src, const std::string&amp; target) override {</a>
<a name="ln1097">    TRACE_EVENT2(&quot;io&quot;, &quot;PosixEnv::RenameFile&quot;, &quot;src&quot;, src, &quot;dst&quot;, target);</a>
<a name="ln1098">    ThreadRestrictions::AssertIOAllowed();</a>
<a name="ln1099">    Status result;</a>
<a name="ln1100">    if (rename(src.c_str(), target.c_str()) != 0) {</a>
<a name="ln1101">      result = STATUS_IO_ERROR(Format(&quot;Rename $0 =&gt; $1&quot;, src, target), errno);</a>
<a name="ln1102">    }</a>
<a name="ln1103">    return result;</a>
<a name="ln1104">  }</a>
<a name="ln1105"> </a>
<a name="ln1106">  virtual Status LockFile(const std::string&amp; fname,</a>
<a name="ln1107">                          FileLock** lock,</a>
<a name="ln1108">                          bool recursive_lock_ok) override {</a>
<a name="ln1109">    TRACE_EVENT1(&quot;io&quot;, &quot;PosixEnv::LockFile&quot;, &quot;path&quot;, fname);</a>
<a name="ln1110">    ThreadRestrictions::AssertIOAllowed();</a>
<a name="ln1111">    *lock = nullptr;</a>
<a name="ln1112">    Status result;</a>
<a name="ln1113">    int fd = open(fname.c_str(), O_RDWR | O_CREAT, 0644);</a>
<a name="ln1114">    if (fd &lt; 0) {</a>
<a name="ln1115">      result = STATUS_IO_ERROR(fname, errno);</a>
<a name="ln1116">    } else if (LockOrUnlock(fname, fd, true /* lock */, recursive_lock_ok) == -1) {</a>
<a name="ln1117">      result = STATUS_IO_ERROR(&quot;lock &quot; + fname, errno);</a>
<a name="ln1118">      close(fd);</a>
<a name="ln1119">    } else {</a>
<a name="ln1120">      auto my_lock = new PosixFileLock;</a>
<a name="ln1121">      my_lock-&gt;fd_ = fd;</a>
<a name="ln1122">      my_lock-&gt;filename = fname;</a>
<a name="ln1123">      *lock = my_lock;</a>
<a name="ln1124">    }</a>
<a name="ln1125">    return result;</a>
<a name="ln1126">  }</a>
<a name="ln1127"> </a>
<a name="ln1128">  Status UnlockFile(FileLock* lock) override {</a>
<a name="ln1129">    TRACE_EVENT0(&quot;io&quot;, &quot;PosixEnv::UnlockFile&quot;);</a>
<a name="ln1130">    ThreadRestrictions::AssertIOAllowed();</a>
<a name="ln1131">    PosixFileLock* my_lock = reinterpret_cast&lt;PosixFileLock*&gt;(lock);</a>
<a name="ln1132">    Status result;</a>
<a name="ln1133">    if (LockOrUnlock(my_lock-&gt;filename,</a>
<a name="ln1134">                     my_lock-&gt;fd_,</a>
<a name="ln1135">                     false /* lock */,</a>
<a name="ln1136">                     false /* recursive_lock_ok (unused when lock = false) */) == -1) {</a>
<a name="ln1137">      result = STATUS_IO_ERROR(&quot;unlock&quot;, errno);</a>
<a name="ln1138">    }</a>
<a name="ln1139">    close(my_lock-&gt;fd_);</a>
<a name="ln1140">    delete my_lock;</a>
<a name="ln1141">    return result;</a>
<a name="ln1142">  }</a>
<a name="ln1143"> </a>
<a name="ln1144">  Status GetTestDirectory(std::string* result) override {</a>
<a name="ln1145">    string dir;</a>
<a name="ln1146">    const char* env = getenv(&quot;TEST_TMPDIR&quot;);</a>
<a name="ln1147">    if (env &amp;&amp; env[0] != '\0') {</a>
<a name="ln1148">      dir = env;</a>
<a name="ln1149">    } else {</a>
<a name="ln1150">      char buf[100];</a>
<a name="ln1151">      snprintf(buf, sizeof(buf), &quot;/tmp/ybtest-%d&quot;, static_cast&lt;int&gt;(geteuid()));</a>
<a name="ln1152">      dir = buf;</a>
<a name="ln1153">    }</a>
<a name="ln1154">    // Directory may already exist</a>
<a name="ln1155">    ignore_result(CreateDir(dir));</a>
<a name="ln1156">    // /tmp may be a symlink, so canonicalize the path.</a>
<a name="ln1157">    return Canonicalize(dir, result);</a>
<a name="ln1158">  }</a>
<a name="ln1159"> </a>
<a name="ln1160">  uint64_t gettid() override {</a>
<a name="ln1161">    // Platform-independent thread ID.  We can't use pthread_self here,</a>
<a name="ln1162">    // because that function returns a totally opaque ID, which can't be</a>
<a name="ln1163">    // compared via normal means.</a>
<a name="ln1164">    if (thread_local_id == 0) {</a>
<a name="ln1165">      thread_local_id = Barrier_AtomicIncrement(&amp;cur_thread_local_id_, 1);</a>
<a name="ln1166">    }</a>
<a name="ln1167">    return thread_local_id;</a>
<a name="ln1168">  }</a>
<a name="ln1169"> </a>
<a name="ln1170">  uint64_t NowMicros() override {</a>
<a name="ln1171">    struct timeval tv;</a>
<a name="ln1172">    gettimeofday(&amp;tv, nullptr);</a>
<a name="ln1173">    return static_cast&lt;uint64_t&gt;(tv.tv_sec) * 1000000 + tv.tv_usec;</a>
<a name="ln1174">  }</a>
<a name="ln1175"> </a>
<a name="ln1176">  uint64_t NowNanos() override {</a>
<a name="ln1177">#if defined(__linux__) || defined(OS_FREEBSD)</a>
<a name="ln1178">    struct timespec ts;</a>
<a name="ln1179">    clock_gettime(CLOCK_MONOTONIC, &amp;ts);</a>
<a name="ln1180">    return static_cast&lt;uint64_t&gt;(ts.tv_sec) * 1000000000 + ts.tv_nsec;</a>
<a name="ln1181">#elif defined(__MACH__)</a>
<a name="ln1182">    clock_serv_t cclock;</a>
<a name="ln1183">    mach_timespec_t ts;</a>
<a name="ln1184">    host_get_clock_service(mach_host_self(), CALENDAR_CLOCK, &amp;cclock);</a>
<a name="ln1185">    clock_get_time(cclock, &amp;ts);</a>
<a name="ln1186">    mach_port_deallocate(mach_task_self(), cclock);</a>
<a name="ln1187">    return static_cast&lt;uint64_t&gt;(ts.tv_sec) * 1000000000 + ts.tv_nsec;</a>
<a name="ln1188">#else</a>
<a name="ln1189">    return std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(</a>
<a name="ln1190">       std::chrono::steady_clock::now().time_since_epoch()).count();</a>
<a name="ln1191">#endif</a>
<a name="ln1192">  }</a>
<a name="ln1193"> </a>
<a name="ln1194">  void SleepForMicroseconds(int micros) override {</a>
<a name="ln1195">    ThreadRestrictions::AssertWaitAllowed();</a>
<a name="ln1196">    SleepFor(MonoDelta::FromMicroseconds(micros));</a>
<a name="ln1197">  }</a>
<a name="ln1198"> </a>
<a name="ln1199">  Status GetExecutablePath(string* path) override {</a>
<a name="ln1200">    uint32_t size = 64;</a>
<a name="ln1201">    uint32_t len = 0;</a>
<a name="ln1202">    while (true) {</a>
<a name="ln1203">      std::unique_ptr&lt;char[]&gt; buf(new char[size]);</a>
<a name="ln1204">#if defined(__linux__)</a>
<a name="ln1205">      int rc = readlink(&quot;/proc/self/exe&quot;, buf.get(), size);</a>
<a name="ln1206">      if (rc == -1) {</a>
<a name="ln1207">        return STATUS(IOError, &quot;Unable to determine own executable path&quot;, &quot;&quot;, Errno(errno));</a>
<a name="ln1208">      } else if (rc &gt;= size) {</a>
<a name="ln1209">        // The buffer wasn't large enough</a>
<a name="ln1210">        size *= 2;</a>
<a name="ln1211">        continue;</a>
<a name="ln1212">      }</a>
<a name="ln1213">      len = rc;</a>
<a name="ln1214">#elif defined(__APPLE__)</a>
<a name="ln1215">      if (_NSGetExecutablePath(buf.get(), &amp;size) != 0) {</a>
<a name="ln1216">        // The buffer wasn't large enough; 'size' has been updated.</a>
<a name="ln1217">        continue;</a>
<a name="ln1218">      }</a>
<a name="ln1219">      len = strlen(buf.get());</a>
<a name="ln1220">#else</a>
<a name="ln1221">#error Unsupported platform</a>
<a name="ln1222">#endif</a>
<a name="ln1223"> </a>
<a name="ln1224">      path-&gt;assign(buf.get(), len);</a>
<a name="ln1225">      break;</a>
<a name="ln1226">    }</a>
<a name="ln1227">    return Status::OK();</a>
<a name="ln1228">  }</a>
<a name="ln1229"> </a>
<a name="ln1230">  Status IsDirectory(const string&amp; path, bool* is_dir) override {</a>
<a name="ln1231">    TRACE_EVENT1(&quot;io&quot;, &quot;PosixEnv::IsDirectory&quot;, &quot;path&quot;, path);</a>
<a name="ln1232">    ThreadRestrictions::AssertIOAllowed();</a>
<a name="ln1233">    Status s;</a>
<a name="ln1234">    struct stat sbuf;</a>
<a name="ln1235">    if (stat(path.c_str(), &amp;sbuf) != 0) {</a>
<a name="ln1236">      s = STATUS_IO_ERROR(path, errno);</a>
<a name="ln1237">    } else {</a>
<a name="ln1238">      *is_dir = S_ISDIR(sbuf.st_mode);</a>
<a name="ln1239">    }</a>
<a name="ln1240">    return s;</a>
<a name="ln1241">  }</a>
<a name="ln1242"> </a>
<a name="ln1243">  Result&lt;bool&gt; IsExecutableFile(const std::string&amp; path) override {</a>
<a name="ln1244">    TRACE_EVENT1(&quot;io&quot;, &quot;PosixEnv::IsExecutableFile&quot;, &quot;path&quot;, path);</a>
<a name="ln1245">    ThreadRestrictions::AssertIOAllowed();</a>
<a name="ln1246">    Status s;</a>
<a name="ln1247">    struct stat sbuf;</a>
<a name="ln1248">    if (stat(path.c_str(), &amp;sbuf) != 0) {</a>
<a name="ln1249">      if (errno == ENOENT) {</a>
<a name="ln1250">        // If the file does not exist, we just return false.</a>
<a name="ln1251">        return false;</a>
<a name="ln1252">      }</a>
<a name="ln1253">      return STATUS_IO_ERROR(path, errno);</a>
<a name="ln1254">    }</a>
<a name="ln1255"> </a>
<a name="ln1256">    return !S_ISDIR(sbuf.st_mode) &amp;&amp; (sbuf.st_mode &amp; S_IXUSR);</a>
<a name="ln1257">  }</a>
<a name="ln1258"> </a>
<a name="ln1259">  Status Walk(const string&amp; root, DirectoryOrder order, const WalkCallback&amp; cb) override {</a>
<a name="ln1260">    TRACE_EVENT1(&quot;io&quot;, &quot;PosixEnv::Walk&quot;, &quot;path&quot;, root);</a>
<a name="ln1261">    ThreadRestrictions::AssertIOAllowed();</a>
<a name="ln1262">    // Some sanity checks</a>
<a name="ln1263">    CHECK_NE(root, &quot;/&quot;);</a>
<a name="ln1264">    CHECK_NE(root, &quot;./&quot;);</a>
<a name="ln1265">    CHECK_NE(root, &quot;.&quot;);</a>
<a name="ln1266">    CHECK_NE(root, &quot;&quot;);</a>
<a name="ln1267"> </a>
<a name="ln1268">    // FTS requires a non-const copy of the name. strdup it and free() when</a>
<a name="ln1269">    // we leave scope.</a>
<a name="ln1270">    gscoped_ptr&lt;char, FreeDeleter&gt; name_dup(strdup(root.c_str()));</a>
<a name="ln1271">    char *paths[] = { name_dup.get(), nullptr };</a>
<a name="ln1272"> </a>
<a name="ln1273">    // FTS_NOCHDIR is important here to make this thread-safe.</a>
<a name="ln1274">    gscoped_ptr&lt;FTS, FtsCloser&gt; tree(</a>
<a name="ln1275">        fts_open(paths, FTS_PHYSICAL | FTS_XDEV | FTS_NOCHDIR, nullptr));</a>
<a name="ln1276">    if (!tree.get()) {</a>
<a name="ln1277">      return STATUS_IO_ERROR(root, errno);</a>
<a name="ln1278">    }</a>
<a name="ln1279"> </a>
<a name="ln1280">    FTSENT *ent = nullptr;</a>
<a name="ln1281">    bool had_errors = false;</a>
<a name="ln1282">    while ((ent = fts_read(tree.get())) != nullptr) {</a>
<a name="ln1283">      bool doCb = false;</a>
<a name="ln1284">      FileType type = DIRECTORY_TYPE;</a>
<a name="ln1285">      switch (ent-&gt;fts_info) {</a>
<a name="ln1286">        case FTS_D:         // Directory in pre-order</a>
<a name="ln1287">          if (order == PRE_ORDER) {</a>
<a name="ln1288">            doCb = true;</a>
<a name="ln1289">          }</a>
<a name="ln1290">          break;</a>
<a name="ln1291">        case FTS_DP:        // Directory in post-order</a>
<a name="ln1292">          if (order == POST_ORDER) {</a>
<a name="ln1293">            doCb = true;</a>
<a name="ln1294">          }</a>
<a name="ln1295">          break;</a>
<a name="ln1296">        case FTS_F:         // A regular file</a>
<a name="ln1297">        case FTS_SL:        // A symbolic link</a>
<a name="ln1298">        case FTS_SLNONE:    // A broken symbolic link</a>
<a name="ln1299">        case FTS_DEFAULT:   // Unknown type of file</a>
<a name="ln1300">          doCb = true;</a>
<a name="ln1301">          type = FILE_TYPE;</a>
<a name="ln1302">          break;</a>
<a name="ln1303"> </a>
<a name="ln1304">        case FTS_ERR:</a>
<a name="ln1305">          LOG(WARNING) &lt;&lt; &quot;Unable to access file &quot; &lt;&lt; ent-&gt;fts_path</a>
<a name="ln1306">                       &lt;&lt; &quot; during walk: &quot; &lt;&lt; strerror(ent-&gt;fts_errno);</a>
<a name="ln1307">          had_errors = true;</a>
<a name="ln1308">          break;</a>
<a name="ln1309"> </a>
<a name="ln1310">        default:</a>
<a name="ln1311">          LOG(WARNING) &lt;&lt; &quot;Unable to access file &quot; &lt;&lt; ent-&gt;fts_path</a>
<a name="ln1312">                       &lt;&lt; &quot; during walk (code &quot; &lt;&lt; ent-&gt;fts_info &lt;&lt; &quot;)&quot;;</a>
<a name="ln1313">          break;</a>
<a name="ln1314">      }</a>
<a name="ln1315">      if (doCb) {</a>
<a name="ln1316">        if (!cb.Run(type, DirName(ent-&gt;fts_path), ent-&gt;fts_name).ok()) {</a>
<a name="ln1317">          had_errors = true;</a>
<a name="ln1318">        }</a>
<a name="ln1319">      }</a>
<a name="ln1320">    }</a>
<a name="ln1321"> </a>
<a name="ln1322">    if (had_errors) {</a>
<a name="ln1323">      return STATUS(IOError, root, &quot;One or more errors occurred&quot;);</a>
<a name="ln1324">    }</a>
<a name="ln1325">    return Status::OK();</a>
<a name="ln1326">  }</a>
<a name="ln1327"> </a>
<a name="ln1328">  Status Canonicalize(const string&amp; path, string* result) override {</a>
<a name="ln1329">    TRACE_EVENT1(&quot;io&quot;, &quot;PosixEnv::Canonicalize&quot;, &quot;path&quot;, path);</a>
<a name="ln1330">    ThreadRestrictions::AssertIOAllowed();</a>
<a name="ln1331">    gscoped_ptr&lt;char[], FreeDeleter&gt; r(realpath(path.c_str(), nullptr));</a>
<a name="ln1332">    if (!r) {</a>
<a name="ln1333">      return STATUS_IO_ERROR(path, errno);</a>
<a name="ln1334">    }</a>
<a name="ln1335">    *result = string(r.get());</a>
<a name="ln1336">    return Status::OK();</a>
<a name="ln1337">  }</a>
<a name="ln1338"> </a>
<a name="ln1339">  Status GetTotalRAMBytes(int64_t* ram) override {</a>
<a name="ln1340">#if defined(__APPLE__)</a>
<a name="ln1341">    int mib[2];</a>
<a name="ln1342">    size_t length = sizeof(*ram);</a>
<a name="ln1343"> </a>
<a name="ln1344">    // Get the Physical memory size</a>
<a name="ln1345">    mib[0] = CTL_HW;</a>
<a name="ln1346">    mib[1] = HW_MEMSIZE;</a>
<a name="ln1347">    CHECK_ERR(sysctl(mib, 2, ram, &amp;length, nullptr, 0)) &lt;&lt; &quot;sysctl CTL_HW HW_MEMSIZE failed&quot;;</a>
<a name="ln1348">#else</a>
<a name="ln1349">    struct sysinfo info;</a>
<a name="ln1350">    if (sysinfo(&amp;info) &lt; 0) {</a>
<a name="ln1351">      return STATUS_IO_ERROR(&quot;sysinfo() failed&quot;, errno);</a>
<a name="ln1352">    }</a>
<a name="ln1353">    *ram = info.totalram;</a>
<a name="ln1354">#endif</a>
<a name="ln1355">    return Status::OK();</a>
<a name="ln1356">  }</a>
<a name="ln1357"> </a>
<a name="ln1358">  FileFactory* GetFileFactory() {</a>
<a name="ln1359">    return file_factory_.get();</a>
<a name="ln1360">  }</a>
<a name="ln1361"> </a>
<a name="ln1362">  Result&lt;uint64_t&gt; GetFreeSpaceBytes(const std::string&amp; path) override {</a>
<a name="ln1363">    if (PREDICT_FALSE(FLAGS_TEST_simulate_free_space_bytes &gt;= 0)) {</a>
<a name="ln1364">      return FLAGS_TEST_simulate_free_space_bytes;</a>
<a name="ln1365">    }</a>
<a name="ln1366">    struct statvfs stat;</a>
<a name="ln1367">    auto ret = statvfs(path.c_str(), &amp;stat);</a>
<a name="ln1368">    if (ret != 0) {</a>
<a name="ln1369">      if (errno == EACCES) {</a>
<a name="ln1370">        return STATUS_SUBSTITUTE(NotAuthorized,</a>
<a name="ln1371">            &quot;Caller doesn't have the required permission on a component of the path $0&quot;,</a>
<a name="ln1372">            path);</a>
<a name="ln1373">      } else if (errno == EIO) {</a>
<a name="ln1374">        return STATUS_SUBSTITUTE(IOError,</a>
<a name="ln1375">            &quot;I/O error occurred while reading from '$0' filesystem&quot;,</a>
<a name="ln1376">            path);</a>
<a name="ln1377">      } else if (errno == ELOOP) {</a>
<a name="ln1378">        return STATUS_SUBSTITUTE(InternalError,</a>
<a name="ln1379">            &quot;Too many symbolic links while translating '$0' path&quot;,</a>
<a name="ln1380">            path);</a>
<a name="ln1381">      } else if (errno == ENAMETOOLONG) {</a>
<a name="ln1382">        return STATUS_SUBSTITUTE(NotSupported,</a>
<a name="ln1383">            &quot;Path '$0' is too long&quot;,</a>
<a name="ln1384">            path);</a>
<a name="ln1385">      } else if (errno == ENOENT) {</a>
<a name="ln1386">        return STATUS_SUBSTITUTE(NotFound,</a>
<a name="ln1387">            &quot;File specified by path '$0' doesn't exist&quot;,</a>
<a name="ln1388">            path);</a>
<a name="ln1389">      } else if (errno == ENOMEM) {</a>
<a name="ln1390">        return STATUS(InternalError, &quot;Insufficient memory&quot;);</a>
<a name="ln1391">      } else if (errno == ENOSYS) {</a>
<a name="ln1392">        return STATUS_SUBSTITUTE(NotSupported,</a>
<a name="ln1393">            &quot;Filesystem for path '$0' doesn't support statvfs&quot;,</a>
<a name="ln1394">            path);</a>
<a name="ln1395">      } else if (errno == ENOTDIR) {</a>
<a name="ln1396">        return STATUS_SUBSTITUTE(InvalidArgument,</a>
<a name="ln1397">            &quot;A component of the path '$0' is not a directory&quot;,</a>
<a name="ln1398">            path);</a>
<a name="ln1399">      } else {</a>
<a name="ln1400">        return STATUS_SUBSTITUTE(InternalError,</a>
<a name="ln1401">            &quot;Failed to read information about filesystem for path '%s': errno=$0: $1&quot;,</a>
<a name="ln1402">            path,</a>
<a name="ln1403">            errno,</a>
<a name="ln1404">            ErrnoToString(errno));</a>
<a name="ln1405">      }</a>
<a name="ln1406">    }</a>
<a name="ln1407">    uint64_t block_size = stat.f_frsize &gt; 0 ? static_cast&lt;uint64_t&gt;(stat.f_frsize) :</a>
<a name="ln1408">                                              static_cast&lt;uint64_t&gt;(stat.f_bsize);</a>
<a name="ln1409">    uint64_t available_blocks = static_cast&lt;uint64_t&gt;(stat.f_bavail);</a>
<a name="ln1410"> </a>
<a name="ln1411">    return available_blocks * block_size;</a>
<a name="ln1412">  }</a>
<a name="ln1413"> </a>
<a name="ln1414">  Status GetUlimit(int resource, int64_t* soft_limit, int64_t* hard_limit) override {</a>
<a name="ln1415">    struct rlimit lim;</a>
<a name="ln1416">    if (getrlimit(resource, &amp;lim) != 0) {</a>
<a name="ln1417">      return STATUS_IO_ERROR(&quot;getrlimit() failed&quot;, errno);</a>
<a name="ln1418">    }</a>
<a name="ln1419">    if (soft_limit != NULL) *soft_limit = lim.rlim_cur;</a>
<a name="ln1420">    if (hard_limit != NULL) *hard_limit = lim.rlim_max;</a>
<a name="ln1421">    return Status::OK();</a>
<a name="ln1422">  }</a>
<a name="ln1423"> </a>
<a name="ln1424">  Status SetUlimit(int resource, int64_t value) override {</a>
<a name="ln1425">    return SetUlimit(resource, value, strings::Substitute(&quot;resource no. $0&quot;, resource));</a>
<a name="ln1426">  }</a>
<a name="ln1427"> </a>
<a name="ln1428">  Status SetUlimit(int resource, int64_t value, const std::string&amp; resource_name) override {</a>
<a name="ln1429">    int64_t soft_limit = 0, hard_limit = 0;</a>
<a name="ln1430">    RETURN_NOT_OK(GetUlimit(resource, &amp;soft_limit, &amp;hard_limit));</a>
<a name="ln1431">    if (soft_limit == value) {</a>
<a name="ln1432">      return Status::OK();</a>
<a name="ln1433">    }</a>
<a name="ln1434">    if (hard_limit != RLIM_INFINITY &amp;&amp; hard_limit &lt; value) {</a>
<a name="ln1435">      return STATUS_FORMAT(</a>
<a name="ln1436">        InvalidArgument,</a>
<a name="ln1437">        &quot;Resource limit value $0 for resource $1 greater than hard limit $2&quot;,</a>
<a name="ln1438">        value, resource, hard_limit);</a>
<a name="ln1439">    }</a>
<a name="ln1440">    struct rlimit lim;</a>
<a name="ln1441">    lim.rlim_cur = value;</a>
<a name="ln1442">    lim.rlim_max = hard_limit;</a>
<a name="ln1443">    LOG(INFO)</a>
<a name="ln1444">        &lt;&lt; &quot;Modifying limit for &quot; &lt;&lt; resource_name</a>
<a name="ln1445">        &lt;&lt; &quot; from &quot; &lt;&lt; soft_limit</a>
<a name="ln1446">        &lt;&lt; &quot; to &quot; &lt;&lt; value;</a>
<a name="ln1447">    if (setrlimit(resource, &amp;lim) != 0) {</a>
<a name="ln1448">      return STATUS(RuntimeError, &quot;Unable to set rlimit&quot;, Errno(errno));</a>
<a name="ln1449">    }</a>
<a name="ln1450">    return Status::OK();</a>
<a name="ln1451">  }</a>
<a name="ln1452"> </a>
<a name="ln1453"> private:</a>
<a name="ln1454">  // gscoped_ptr Deleter implementation for fts_close</a>
<a name="ln1455">  struct FtsCloser {</a>
<a name="ln1456">    void operator()(FTS *fts) const {</a>
<a name="ln1457">      if (fts) { fts_close(fts); }</a>
<a name="ln1458">    }</a>
<a name="ln1459">  };</a>
<a name="ln1460"> </a>
<a name="ln1461">  Status DeleteRecursivelyCb(FileType type, const string&amp; dirname, const string&amp; basename) {</a>
<a name="ln1462">    string full_path = JoinPathSegments(dirname, basename);</a>
<a name="ln1463">    Status s;</a>
<a name="ln1464">    switch (type) {</a>
<a name="ln1465">      case FILE_TYPE:</a>
<a name="ln1466">        s = DeleteFile(full_path);</a>
<a name="ln1467">        WARN_NOT_OK(s, &quot;Could not delete file&quot;);</a>
<a name="ln1468">        return s;</a>
<a name="ln1469">      case DIRECTORY_TYPE:</a>
<a name="ln1470">        s = DeleteDir(full_path);</a>
<a name="ln1471">        WARN_NOT_OK(s, &quot;Could not delete directory&quot;);</a>
<a name="ln1472">        return s;</a>
<a name="ln1473">      default:</a>
<a name="ln1474">        LOG(FATAL) &lt;&lt; &quot;Unknown file type: &quot; &lt;&lt; type;</a>
<a name="ln1475">        return Status::OK();</a>
<a name="ln1476">    }</a>
<a name="ln1477">  }</a>
<a name="ln1478"> </a>
<a name="ln1479">  std::unique_ptr&lt;FileFactory&gt; file_factory_;</a>
<a name="ln1480">};</a>
<a name="ln1481"> </a>
<a name="ln1482">class PosixFileFactory : public FileFactory {</a>
<a name="ln1483">#if defined(__linux__)</a>
<a name="ln1484">  static constexpr int kODirectFlags = O_DIRECT | O_NOATIME | O_SYNC;</a>
<a name="ln1485">#else</a>
<a name="ln1486">  static constexpr int kODirectFlags = 0;</a>
<a name="ln1487">#endif</a>
<a name="ln1488"> </a>
<a name="ln1489"> public:</a>
<a name="ln1490">  PosixFileFactory() {}</a>
<a name="ln1491">  ~PosixFileFactory() {}</a>
<a name="ln1492"> </a>
<a name="ln1493">  Status NewSequentialFile(</a>
<a name="ln1494">      const std::string&amp; fname, std::unique_ptr&lt;SequentialFile&gt;* result) override {</a>
<a name="ln1495">    TRACE_EVENT1(&quot;io&quot;, &quot;PosixEnv::NewSequentialFile&quot;, &quot;path&quot;, fname);</a>
<a name="ln1496">    ThreadRestrictions::AssertIOAllowed();</a>
<a name="ln1497">    FILE* f = fopen(fname.c_str(), &quot;r&quot;);</a>
<a name="ln1498">    if (f == nullptr) {</a>
<a name="ln1499">      return STATUS_IO_ERROR(fname, errno);</a>
<a name="ln1500">    } else {</a>
<a name="ln1501">      result-&gt;reset(new yb::PosixSequentialFile(fname, f, yb::FileSystemOptions::kDefault));</a>
<a name="ln1502">      return Status::OK();</a>
<a name="ln1503">    }</a>
<a name="ln1504">  }</a>
<a name="ln1505"> </a>
<a name="ln1506">  Status NewRandomAccessFile(const std::string&amp; fname,</a>
<a name="ln1507">                             std::unique_ptr&lt;RandomAccessFile&gt;* result) override {</a>
<a name="ln1508">    TRACE_EVENT1(&quot;io&quot;, &quot;PosixEnv::NewRandomAccessFile&quot;, &quot;path&quot;, fname);</a>
<a name="ln1509">    ThreadRestrictions::AssertIOAllowed();</a>
<a name="ln1510">    int fd = open(fname.c_str(), O_RDONLY);</a>
<a name="ln1511">    if (fd &lt; 0) {</a>
<a name="ln1512">      return STATUS_IO_ERROR(fname, errno);</a>
<a name="ln1513">    }</a>
<a name="ln1514"> </a>
<a name="ln1515">    result-&gt;reset(new yb::PosixRandomAccessFile(fname, fd, yb::FileSystemOptions::kDefault));</a>
<a name="ln1516">    return Status::OK();</a>
<a name="ln1517">  }</a>
<a name="ln1518"> </a>
<a name="ln1519">  Status NewWritableFile(const std::string&amp; fname,</a>
<a name="ln1520">                         std::unique_ptr&lt;WritableFile&gt;* result) override {</a>
<a name="ln1521">    return NewWritableFile(WritableFileOptions(), fname, result);</a>
<a name="ln1522">  }</a>
<a name="ln1523"> </a>
<a name="ln1524">  Status NewWritableFile(const WritableFileOptions&amp; opts,</a>
<a name="ln1525">                         const std::string&amp; fname,</a>
<a name="ln1526">                         std::unique_ptr&lt;WritableFile&gt;* result) override {</a>
<a name="ln1527">    TRACE_EVENT1(&quot;io&quot;, &quot;PosixEnv::NewWritableFile&quot;, &quot;path&quot;, fname);</a>
<a name="ln1528">    int fd = -1;</a>
<a name="ln1529">    int extra_flags = 0;</a>
<a name="ln1530">    if (UseODirect(opts.o_direct)) {</a>
<a name="ln1531">      extra_flags = kODirectFlags;</a>
<a name="ln1532">    }</a>
<a name="ln1533">    RETURN_NOT_OK(DoOpen(fname, opts.mode, &amp;fd, extra_flags));</a>
<a name="ln1534">    return InstantiateNewWritableFile(fname, fd, opts, result);</a>
<a name="ln1535">  }</a>
<a name="ln1536"> </a>
<a name="ln1537">  Status NewTempWritableFile(const WritableFileOptions&amp; opts,</a>
<a name="ln1538">                             const std::string&amp; name_template,</a>
<a name="ln1539">                             std::string* created_filename,</a>
<a name="ln1540">                             std::unique_ptr&lt;WritableFile&gt;* result) override {</a>
<a name="ln1541">    TRACE_EVENT1(&quot;io&quot;, &quot;PosixEnv::NewTempWritableFile&quot;, &quot;template&quot;, name_template);</a>
<a name="ln1542">    ThreadRestrictions::AssertIOAllowed();</a>
<a name="ln1543">    std::unique_ptr&lt;char[]&gt; fname(new char[name_template.size() + 1]);</a>
<a name="ln1544">    ::snprintf(fname.get(), name_template.size() + 1, &quot;%s&quot;, name_template.c_str());</a>
<a name="ln1545">    int fd = -1;</a>
<a name="ln1546">    if (UseODirect(opts.o_direct)) {</a>
<a name="ln1547">      fd = ::mkostemp(fname.get(), kODirectFlags);</a>
<a name="ln1548">    } else {</a>
<a name="ln1549">      fd = ::mkstemp(fname.get());</a>
<a name="ln1550">    }</a>
<a name="ln1551">    if (fd &lt; 0) {</a>
<a name="ln1552">      return STATUS_IO_ERROR(Format(&quot;Call to mkstemp() failed on name template $0&quot;, name_template),</a>
<a name="ln1553">                             errno);</a>
<a name="ln1554">    }</a>
<a name="ln1555">    *created_filename = fname.get();</a>
<a name="ln1556">    return InstantiateNewWritableFile(*created_filename, fd, opts, result);</a>
<a name="ln1557">  }</a>
<a name="ln1558"> </a>
<a name="ln1559">  Status NewRWFile(const string&amp; fname, std::unique_ptr&lt;RWFile&gt;* result) override {</a>
<a name="ln1560">    return NewRWFile(RWFileOptions(), fname, result);</a>
<a name="ln1561">  }</a>
<a name="ln1562"> </a>
<a name="ln1563">  Status NewRWFile(const RWFileOptions&amp; opts, const string&amp; fname,</a>
<a name="ln1564">                   std::unique_ptr&lt;RWFile&gt;* result) override {</a>
<a name="ln1565">    TRACE_EVENT1(&quot;io&quot;, &quot;PosixEnv::NewRWFile&quot;, &quot;path&quot;, fname);</a>
<a name="ln1566">    int fd = -1;</a>
<a name="ln1567">    RETURN_NOT_OK(DoOpen(fname, opts.mode, &amp;fd));</a>
<a name="ln1568">    result-&gt;reset(new PosixRWFile(fname, fd, opts.sync_on_close));</a>
<a name="ln1569">    return Status::OK();</a>
<a name="ln1570">  }</a>
<a name="ln1571"> </a>
<a name="ln1572">  Result&lt;uint64_t&gt; GetFileSize(const std::string&amp; fname) override {</a>
<a name="ln1573">    return GetFileStat(</a>
<a name="ln1574">        fname, &quot;PosixEnv::GetFileSize&quot;, [](const struct stat&amp; sbuf) { return sbuf.st_size; });</a>
<a name="ln1575">  }</a>
<a name="ln1576"> </a>
<a name="ln1577"> private:</a>
<a name="ln1578">  bool UseODirect(bool o_direct) {</a>
<a name="ln1579">#if defined(__linux__)</a>
<a name="ln1580">    return o_direct;</a>
<a name="ln1581">#else</a>
<a name="ln1582">    return false;</a>
<a name="ln1583">#endif</a>
<a name="ln1584">  }</a>
<a name="ln1585"> </a>
<a name="ln1586">  Status InstantiateNewWritableFile(const std::string&amp; fname,</a>
<a name="ln1587">                                    int fd,</a>
<a name="ln1588">                                    const WritableFileOptions&amp; opts,</a>
<a name="ln1589">                                    std::unique_ptr&lt;WritableFile&gt;* result) {</a>
<a name="ln1590">    uint64_t file_size = 0;</a>
<a name="ln1591">    if (opts.mode == PosixEnv::OPEN_EXISTING) {</a>
<a name="ln1592">      file_size = VERIFY_RESULT(GetFileSize(fname));</a>
<a name="ln1593">    }</a>
<a name="ln1594">    PosixWritableFile *posix_writable_file;</a>
<a name="ln1595">#if defined(__linux__)</a>
<a name="ln1596">    if (opts.o_direct)</a>
<a name="ln1597">      posix_writable_file = new PosixDirectIOWritableFile(fname, fd, file_size, opts.sync_on_close);</a>
<a name="ln1598">    else</a>
<a name="ln1599">#endif</a>
<a name="ln1600">    posix_writable_file = new PosixWritableFile(fname, fd, file_size, opts.sync_on_close);</a>
<a name="ln1601">    result-&gt;reset(posix_writable_file);</a>
<a name="ln1602">    return Status::OK();</a>
<a name="ln1603">  }</a>
<a name="ln1604">};</a>
<a name="ln1605"> </a>
<a name="ln1606">PosixEnv::PosixEnv() : file_factory_(std::make_unique&lt;PosixFileFactory&gt;()) {}</a>
<a name="ln1607">PosixEnv::PosixEnv(std::unique_ptr&lt;FileFactory&gt; file_factory) :</a>
<a name="ln1608">  file_factory_(std::move(file_factory)) {}</a>
<a name="ln1609"> </a>
<a name="ln1610">}  // namespace</a>
<a name="ln1611"> </a>
<a name="ln1612">static pthread_once_t once = PTHREAD_ONCE_INIT;</a>
<a name="ln1613">static Env* default_env;</a>
<a name="ln1614">static void InitDefaultEnv() { default_env = new PosixEnv; }</a>
<a name="ln1615"> </a>
<a name="ln1616">Env* Env::Default() {</a>
<a name="ln1617">  pthread_once(&amp;once, InitDefaultEnv);</a>
<a name="ln1618">  return default_env;</a>
<a name="ln1619">}</a>
<a name="ln1620"> </a>
<a name="ln1621">FileFactory* Env::DefaultFileFactory() {</a>
<a name="ln1622">  return down_cast&lt;PosixEnv*&gt;(Env::Default())-&gt;GetFileFactory();</a>
<a name="ln1623">}</a>
<a name="ln1624"> </a>
<a name="ln1625">std::unique_ptr&lt;Env&gt; Env::NewDefaultEnv(std::unique_ptr&lt;FileFactory&gt; file_factory) {</a>
<a name="ln1626">  return std::make_unique&lt;PosixEnv&gt;(std::move(file_factory));</a>
<a name="ln1627">}</a>
<a name="ln1628"> </a>
<a name="ln1629"> </a>
<a name="ln1630">}  // namespace yb</a>

</code></pre>
<div class="balloon" rel="600"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
