
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>doc_reader.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Copyright (c) YugaByte, Inc.</a>
<a name="ln2">//</a>
<a name="ln3">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln4">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln5">//</a>
<a name="ln6">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln7">//</a>
<a name="ln8">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln9">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln10">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln11">// under the License.</a>
<a name="ln12">//</a>
<a name="ln13"> </a>
<a name="ln14">#include &quot;yb/docdb/doc_reader.h&quot;</a>
<a name="ln15"> </a>
<a name="ln16">#include &lt;string&gt;</a>
<a name="ln17">#include &lt;vector&gt;</a>
<a name="ln18"> </a>
<a name="ln19">#include &quot;yb/common/hybrid_time.h&quot;</a>
<a name="ln20">#include &quot;yb/common/transaction.h&quot;</a>
<a name="ln21"> </a>
<a name="ln22">#include &quot;yb/docdb/doc_ttl_util.h&quot;</a>
<a name="ln23">#include &quot;yb/docdb/docdb-internal.h&quot;</a>
<a name="ln24">#include &quot;yb/docdb/docdb_rocksdb_util.h&quot;</a>
<a name="ln25">#include &quot;yb/docdb/intent_aware_iterator.h&quot;</a>
<a name="ln26">#include &quot;yb/docdb/subdocument.h&quot;</a>
<a name="ln27">#include &quot;yb/docdb/value.h&quot;</a>
<a name="ln28">#include &quot;yb/docdb/value_type.h&quot;</a>
<a name="ln29">#include &quot;yb/docdb/deadline_info.h&quot;</a>
<a name="ln30">#include &quot;yb/docdb/docdb_types.h&quot;</a>
<a name="ln31"> </a>
<a name="ln32">#include &quot;yb/server/hybrid_clock.h&quot;</a>
<a name="ln33"> </a>
<a name="ln34">#include &quot;yb/util/status.h&quot;</a>
<a name="ln35"> </a>
<a name="ln36">using std::vector;</a>
<a name="ln37"> </a>
<a name="ln38">using yb::HybridTime;</a>
<a name="ln39"> </a>
<a name="ln40">namespace yb {</a>
<a name="ln41">namespace docdb {</a>
<a name="ln42"> </a>
<a name="ln43">const SliceKeyBound&amp; SliceKeyBound::Invalid() {</a>
<a name="ln44">  static SliceKeyBound result;</a>
<a name="ln45">  return result;</a>
<a name="ln46">}</a>
<a name="ln47"> </a>
<a name="ln48">const IndexBound&amp; IndexBound::Empty() {</a>
<a name="ln49">  static IndexBound result;</a>
<a name="ln50">  return result;</a>
<a name="ln51">}</a>
<a name="ln52"> </a>
<a name="ln53"> </a>
<a name="ln54">// ------------------------------------------------------------------------------------------------</a>
<a name="ln55">// Standalone functions</a>
<a name="ln56">// ------------------------------------------------------------------------------------------------</a>
<a name="ln57"> </a>
<a name="ln58">namespace {</a>
<a name="ln59"> </a>
<a name="ln60">void SeekToLowerBound(const SliceKeyBound&amp; lower_bound, IntentAwareIterator* iter) {</a>
<a name="ln61">  if (lower_bound.is_exclusive()) {</a>
<a name="ln62">    iter-&gt;SeekPastSubKey(lower_bound.key());</a>
<a name="ln63">  } else {</a>
<a name="ln64">    iter-&gt;SeekForward(lower_bound.key());</a>
<a name="ln65">  }</a>
<a name="ln66">}</a>
<a name="ln67"> </a>
<a name="ln68">// This function does not assume that object init_markers are present. If no init marker is present,</a>
<a name="ln69">// or if a tombstone is found at some level, it still looks for subkeys inside it if they have</a>
<a name="ln70">// larger timestamps.</a>
<a name="ln71">//</a>
<a name="ln72">// TODO(akashnil): ENG-1152: If object init markers were required, this read path may be optimized.</a>
<a name="ln73">// We look at all rocksdb keys with prefix = subdocument_key, and construct a subdocument out of</a>
<a name="ln74">// them, between the timestamp range high_ts and low_ts.</a>
<a name="ln75">//</a>
<a name="ln76">// The iterator is expected to be placed at the smallest key that is subdocument_key or later, and</a>
<a name="ln77">// after the function returns, the iterator should be placed just completely outside the</a>
<a name="ln78">// subdocument_key prefix. Although if high_subkey is specified, the iterator is only guaranteed</a>
<a name="ln79">// to be positioned after the high_subkey and not necessarily outside the subdocument_key prefix.</a>
<a name="ln80">// num_values_observed is used for queries on indices, and keeps track of the number of primitive</a>
<a name="ln81">// values observed thus far. In a query with lower index bound k, ignore the first k primitive</a>
<a name="ln82">// values before building the subdocument.</a>
<a name="ln83">CHECKED_STATUS BuildSubDocument(</a>
<a name="ln84">    IntentAwareIterator* iter,</a>
<a name="ln85">    const GetSubDocumentData&amp; data,</a>
<a name="ln86">    DocHybridTime low_ts,</a>
<a name="ln87">    int64* num_values_observed) {</a>
<a name="ln88">  VLOG(3) &lt;&lt; &quot;BuildSubDocument data: &quot; &lt;&lt; data &lt;&lt; &quot; read_time: &quot; &lt;&lt; iter-&gt;read_time()</a>
<a name="ln89">          &lt;&lt; &quot; low_ts: &quot; &lt;&lt; low_ts;</a>
<a name="ln90">  while (iter-&gt;valid()) {</a>
<a name="ln91">    if (data.deadline_info &amp;&amp; data.deadline_info-&gt;CheckAndSetDeadlinePassed()) {</a>
<a name="ln92">      return STATUS(Expired, &quot;Deadline for query passed.&quot;);</a>
<a name="ln93">    }</a>
<a name="ln94">    // Since we modify num_values_observed on recursive calls, we keep a local copy of the value.</a>
<a name="ln95">    int64 current_values_observed = *num_values_observed;</a>
<a name="ln96">    auto key_data = VERIFY_RESULT(iter-&gt;FetchKey());</a>
<a name="ln97">    auto key = key_data.key;</a>
<a name="ln98">    const auto write_time = key_data.write_time;</a>
<a name="ln99">    VLOG(4) &lt;&lt; &quot;iter: &quot; &lt;&lt; SubDocKey::DebugSliceToString(key)</a>
<a name="ln100">            &lt;&lt; &quot;, key: &quot; &lt;&lt; SubDocKey::DebugSliceToString(data.subdocument_key);</a>
<a name="ln101">    DCHECK(key.starts_with(data.subdocument_key))</a>
<a name="ln102">        &lt;&lt; &quot;iter: &quot; &lt;&lt; SubDocKey::DebugSliceToString(key)</a>
<a name="ln103">        &lt;&lt; &quot;, key: &quot; &lt;&lt; SubDocKey::DebugSliceToString(data.subdocument_key);</a>
<a name="ln104"> </a>
<a name="ln105">    // Key could be invalidated because we could move iterator, so back it up.</a>
<a name="ln106">    KeyBytes key_copy(key);</a>
<a name="ln107">    key = key_copy.AsSlice();</a>
<a name="ln108">    rocksdb::Slice value = iter-&gt;value();</a>
<a name="ln109">    // Checking that IntentAwareIterator returns an entry with correct time.</a>
<a name="ln110">    DCHECK(key_data.same_transaction ||</a>
<a name="ln111">           iter-&gt;read_time().global_limit &gt;= write_time.hybrid_time())</a>
<a name="ln112">        &lt;&lt; &quot;Bad key: &quot; &lt;&lt; SubDocKey::DebugSliceToString(key)</a>
<a name="ln113">        &lt;&lt; &quot;, global limit: &quot; &lt;&lt; iter-&gt;read_time().global_limit</a>
<a name="ln114">        &lt;&lt; &quot;, write time: &quot; &lt;&lt; write_time.hybrid_time();</a>
<a name="ln115"> </a>
<a name="ln116">    if (low_ts &gt; write_time) {</a>
<a name="ln117">      VLOG(3) &lt;&lt; &quot;SeekPastSubKey: &quot; &lt;&lt; SubDocKey::DebugSliceToString(key);</a>
<a name="ln118">      iter-&gt;SeekPastSubKey(key);</a>
<a name="ln119">      continue;</a>
<a name="ln120">    }</a>
<a name="ln121">    Value doc_value;</a>
<a name="ln122">    RETURN_NOT_OK(doc_value.Decode(value));</a>
<a name="ln123">    ValueType value_type = doc_value.value_type();</a>
<a name="ln124">    if (key == data.subdocument_key) {</a>
<a name="ln125">      if (write_time == DocHybridTime::kMin)</a>
<a name="ln126">        return STATUS(Corruption, &quot;No hybrid timestamp found on entry&quot;);</a>
<a name="ln127"> </a>
<a name="ln128">      // We may need to update the TTL in individual columns.</a>
<a name="ln129">      if (write_time.hybrid_time() &gt;= data.exp.write_ht) {</a>
<a name="ln130">        // We want to keep the default TTL otherwise.</a>
<a name="ln131">        if (doc_value.ttl() != Value::kMaxTtl) {</a>
<a name="ln132">          data.exp.write_ht = write_time.hybrid_time();</a>
<a name="ln133">          data.exp.ttl = doc_value.ttl();</a>
<a name="ln134">        } else if (data.exp.ttl.IsNegative()) {</a>
<a name="ln135">          data.exp.ttl = -data.exp.ttl;</a>
<a name="ln136">        }</a>
<a name="ln137">      }</a>
<a name="ln138"> </a>
<a name="ln139">      // If the hybrid time is kMin, then we must be using default TTL.</a>
<a name="ln140">      if (data.exp.write_ht == HybridTime::kMin) {</a>
<a name="ln141">        data.exp.write_ht = write_time.hybrid_time();</a>
<a name="ln142">      }</a>
<a name="ln143"> </a>
<a name="ln144">      bool has_expired;</a>
<a name="ln145">      CHECK_OK(HasExpiredTTL(data.exp.write_ht, data.exp.ttl,</a>
<a name="ln146">                             iter-&gt;read_time().read, &amp;has_expired));</a>
<a name="ln147"> </a>
<a name="ln148">      // Treat an expired value as a tombstone written at the same time as the original value.</a>
<a name="ln149">      if (has_expired) {</a>
<a name="ln150">        doc_value = Value::Tombstone();</a>
<a name="ln151">        value_type = ValueType::kTombstone;</a>
<a name="ln152">      }</a>
<a name="ln153"> </a>
<a name="ln154">      const bool is_collection = IsCollectionType(value_type);</a>
<a name="ln155">      // We have found some key that matches our entire subdocument_key, i.e. we didn't skip ahead</a>
<a name="ln156">      // to a lower level key (with optional object init markers).</a>
<a name="ln157">      if (is_collection || value_type == ValueType::kTombstone) {</a>
<a name="ln158">        if (low_ts &lt; write_time) {</a>
<a name="ln159">          low_ts = write_time;</a>
<a name="ln160">        }</a>
<a name="ln161">        if (is_collection) {</a>
<a name="ln162">          *data.result = SubDocument(value_type);</a>
<a name="ln163">        }</a>
<a name="ln164"> </a>
<a name="ln165">        // If the subkey lower bound filters out the key we found, we want to skip to the lower</a>
<a name="ln166">        // bound. If it does not, we want to seek to the next key. This prevents an infinite loop</a>
<a name="ln167">        // where the iterator keeps seeking to itself if the key we found matches the low subkey.</a>
<a name="ln168">        // TODO: why are not we doing this for arrays?</a>
<a name="ln169">        if (IsObjectType(value_type) &amp;&amp; !data.low_subkey-&gt;CanInclude(key)) {</a>
<a name="ln170">          // Try to seek to the low_subkey for efficiency.</a>
<a name="ln171">          SeekToLowerBound(*data.low_subkey, iter);</a>
<a name="ln172">        } else {</a>
<a name="ln173">          VLOG(3) &lt;&lt; &quot;SeekPastSubKey: &quot; &lt;&lt; SubDocKey::DebugSliceToString(key);</a>
<a name="ln174">          iter-&gt;SeekPastSubKey(key);</a>
<a name="ln175">        }</a>
<a name="ln176">        continue;</a>
<a name="ln177">      } else if (IsPrimitiveValueType(value_type)) {</a>
<a name="ln178">        // TODO: the ttl_seconds in primitive value is currently only in use for CQL. At some</a>
<a name="ln179">        // point streamline by refactoring CQL to use the mutable Expiration in GetSubDocumentData.</a>
<a name="ln180">        if (data.exp.ttl == Value::kMaxTtl) {</a>
<a name="ln181">          doc_value.mutable_primitive_value()-&gt;SetTtl(-1);</a>
<a name="ln182">        } else {</a>
<a name="ln183">          int64_t time_since_write_seconds = (</a>
<a name="ln184">              server::HybridClock::GetPhysicalValueMicros(iter-&gt;read_time().read) -</a>
<a name="ln185">              server::HybridClock::GetPhysicalValueMicros(write_time.hybrid_time())) /</a>
<a name="ln186">              MonoTime::kMicrosecondsPerSecond;</a>
<a name="ln187">          int64_t ttl_seconds = std::max(static_cast&lt;int64_t&gt;(0),</a>
<a name="ln188">              data.exp.ttl.ToMilliseconds() /</a>
<a name="ln189">              MonoTime::kMillisecondsPerSecond - time_since_write_seconds);</a>
<a name="ln190">          doc_value.mutable_primitive_value()-&gt;SetTtl(ttl_seconds);</a>
<a name="ln191">        }</a>
<a name="ln192">        // Choose the user supplied timestamp if present.</a>
<a name="ln193">        const UserTimeMicros user_timestamp = doc_value.user_timestamp();</a>
<a name="ln194">        doc_value.mutable_primitive_value()-&gt;SetWriteTime(</a>
<a name="ln195">            user_timestamp == Value::kInvalidUserTimestamp</a>
<a name="ln196">            ? write_time.hybrid_time().GetPhysicalValueMicros()</a>
<a name="ln197">            : doc_value.user_timestamp());</a>
<a name="ln198">        if (!data.high_index-&gt;CanInclude(current_values_observed)) {</a>
<a name="ln199">          iter-&gt;SeekOutOfSubDoc(&amp;key_copy);</a>
<a name="ln200">          return Status::OK();</a>
<a name="ln201">        }</a>
<a name="ln202">        if (data.low_index-&gt;CanInclude(*num_values_observed)) {</a>
<a name="ln203">          *data.result = SubDocument(doc_value.primitive_value());</a>
<a name="ln204">        }</a>
<a name="ln205">        (*num_values_observed)++;</a>
<a name="ln206">        VLOG(3) &lt;&lt; &quot;SeekOutOfSubDoc: &quot; &lt;&lt; SubDocKey::DebugSliceToString(key);</a>
<a name="ln207">        iter-&gt;SeekOutOfSubDoc(&amp;key_copy);</a>
<a name="ln208">        return Status::OK();</a>
<a name="ln209">      } else {</a>
<a name="ln210">        return STATUS_FORMAT(Corruption, &quot;Expected primitive value type, got $0&quot;, value_type);</a>
<a name="ln211">      }</a>
<a name="ln212">    }</a>
<a name="ln213">    SubDocument descendant{PrimitiveValue(ValueType::kInvalid)};</a>
<a name="ln214">    // TODO: what if the key we found is the same as before?</a>
<a name="ln215">    //       We'll get into an infinite recursion then.</a>
<a name="ln216">    {</a>
<a name="ln217">      IntentAwareIteratorPrefixScope prefix_scope(key, iter);</a>
<a name="ln218">      RETURN_NOT_OK(BuildSubDocument(</a>
<a name="ln219">          iter, data.Adjusted(key, &amp;descendant), low_ts,</a>
<a name="ln220">          num_values_observed));</a>
<a name="ln221"> </a>
<a name="ln222">    }</a>
<a name="ln223">    if (descendant.value_type() == ValueType::kInvalid) {</a>
<a name="ln224">      // The document was not found in this level (maybe a tombstone was encountered).</a>
<a name="ln225">      continue;</a>
<a name="ln226">    }</a>
<a name="ln227"> </a>
<a name="ln228">    if (!data.low_subkey-&gt;CanInclude(key)) {</a>
<a name="ln229">      VLOG(3) &lt;&lt; &quot;Filtered by low_subkey: &quot; &lt;&lt; data.low_subkey-&gt;ToString()</a>
<a name="ln230">              &lt;&lt; &quot;, key: &quot; &lt;&lt; SubDocKey::DebugSliceToString(key);</a>
<a name="ln231">      // The value provided is lower than what we are looking for, seek to the lower bound.</a>
<a name="ln232">      SeekToLowerBound(*data.low_subkey, iter);</a>
<a name="ln233">      continue;</a>
<a name="ln234">    }</a>
<a name="ln235"> </a>
<a name="ln236">    // We use num_values_observed as a conservative figure for lower bound and</a>
<a name="ln237">    // current_values_observed for upper bound so we don't lose any data we should be including.</a>
<a name="ln238">    if (!data.low_index-&gt;CanInclude(*num_values_observed)) {</a>
<a name="ln239">      continue;</a>
<a name="ln240">    }</a>
<a name="ln241"> </a>
<a name="ln242">    if (!data.high_subkey-&gt;CanInclude(key)) {</a>
<a name="ln243">      VLOG(3) &lt;&lt; &quot;Filtered by high_subkey: &quot; &lt;&lt; data.high_subkey-&gt;ToString()</a>
<a name="ln244">              &lt;&lt; &quot;, key: &quot; &lt;&lt; SubDocKey::DebugSliceToString(key);</a>
<a name="ln245">      // We have encountered a subkey higher than our constraints, we should stop here.</a>
<a name="ln246">      return Status::OK();</a>
<a name="ln247">    }</a>
<a name="ln248"> </a>
<a name="ln249">    if (!data.high_index-&gt;CanInclude(current_values_observed)) {</a>
<a name="ln250">      return Status::OK();</a>
<a name="ln251">    }</a>
<a name="ln252"> </a>
<a name="ln253">    if (!IsObjectType(data.result-&gt;value_type())) {</a>
<a name="ln254">      *data.result = SubDocument();</a>
<a name="ln255">    }</a>
<a name="ln256"> </a>
<a name="ln257">    SubDocument* current = data.result;</a>
<a name="ln258">    size_t num_children;</a>
<a name="ln259">    RETURN_NOT_OK(current-&gt;NumChildren(&amp;num_children));</a>
<a name="ln260">    if (data.limit != 0 &amp;&amp; num_children &gt;= data.limit) {</a>
<a name="ln261">      // We have processed enough records.</a>
<a name="ln262">      return Status::OK();</a>
<a name="ln263">    }</a>
<a name="ln264"> </a>
<a name="ln265">    if (data.count_only) {</a>
<a name="ln266">      // We need to only count the records that we found.</a>
<a name="ln267">      data.record_count++;</a>
<a name="ln268">    } else {</a>
<a name="ln269">      Slice temp = key;</a>
<a name="ln270">      temp.remove_prefix(data.subdocument_key.size());</a>
<a name="ln271">      for (;;) {</a>
<a name="ln272">        PrimitiveValue child;</a>
<a name="ln273">        RETURN_NOT_OK(child.DecodeFromKey(&amp;temp));</a>
<a name="ln274">        if (temp.empty()) {</a>
<a name="ln275">          current-&gt;SetChild(child, std::move(descendant));</a>
<a name="ln276">          break;</a>
<a name="ln277">        }</a>
<a name="ln278">        current = current-&gt;GetOrAddChild(child).first;</a>
<a name="ln279">      }</a>
<a name="ln280">    }</a>
<a name="ln281">  }</a>
<a name="ln282"> </a>
<a name="ln283">  return Status::OK();</a>
<a name="ln284">}</a>
<a name="ln285"> </a>
<a name="ln286">// If there is a key equal to key_bytes_without_ht + some timestamp, which is later than</a>
<a name="ln287">// max_overwrite_time, we update max_overwrite_time, and result_value (unless it is nullptr).</a>
<a name="ln288">// If there is a TTL with write time later than the write time in expiration, it is updated with</a>
<a name="ln289">// the new write time and TTL, unless its value is kMaxTTL.</a>
<a name="ln290">// When the TTL found is kMaxTTL and it is not a merge record, then it is assumed not to be</a>
<a name="ln291">// explicitly set. Because it does not override the default table ttl, exp, which was initialized</a>
<a name="ln292">// to the table ttl, is not updated.</a>
<a name="ln293">// Observe that exp updates based on the first record found, while max_overwrite_time updates</a>
<a name="ln294">// based on the first non-merge record found.</a>
<a name="ln295">// This should not be used for leaf nodes. - Why? Looks like it is already used for leaf nodes</a>
<a name="ln296">// also.</a>
<a name="ln297">// Note: it is responsibility of caller to make sure key_bytes_without_ht doesn't have hybrid</a>
<a name="ln298">// time.</a>
<a name="ln299">// TODO: We could also check that the value is kTombStone or kObject type for sanity checking - ?</a>
<a name="ln300">// It could be a simple value as well, not necessarily kTombstone or kObject.</a>
<a name="ln301">Status FindLastWriteTime(</a>
<a name="ln302">    IntentAwareIterator* iter,</a>
<a name="ln303">    const Slice&amp; key_without_ht,</a>
<a name="ln304">    DocHybridTime* max_overwrite_time,</a>
<a name="ln305">    Expiration* exp,</a>
<a name="ln306">    Value* result_value = nullptr) {</a>
<a name="ln307">  Slice value;</a>
<a name="ln308">  DocHybridTime doc_ht = *max_overwrite_time;</a>
<a name="ln309">  RETURN_NOT_OK(iter-&gt;FindLatestRecord(key_without_ht, &amp;doc_ht, &amp;value));</a>
<a name="ln310">  if (!iter-&gt;valid()) {</a>
<a name="ln311">    return Status::OK();</a>
<a name="ln312">  }</a>
<a name="ln313"> </a>
<a name="ln314">  uint64_t merge_flags = 0;</a>
<a name="ln315">  MonoDelta ttl;</a>
<a name="ln316">  ValueType value_type;</a>
<a name="ln317">  RETURN_NOT_OK(Value::DecodePrimitiveValueType(value, &amp;value_type, &amp;merge_flags, &amp;ttl));</a>
<a name="ln318">  if (value_type == ValueType::kInvalid) {</a>
<a name="ln319">    return Status::OK();</a>
<a name="ln320">  }</a>
<a name="ln321"> </a>
<a name="ln322">  // We update the expiration if and only if the write time is later than the write time</a>
<a name="ln323">  // currently stored in expiration, and the record is not a regular record with default TTL.</a>
<a name="ln324">  // This is done independently of whether the row is a TTL row.</a>
<a name="ln325">  // In the case that the always_override flag is true, default TTL will not be preserved.</a>
<a name="ln326">  Expiration new_exp = *exp;</a>
<a name="ln327">  if (doc_ht.hybrid_time() &gt;= exp-&gt;write_ht) {</a>
<a name="ln328">    // We want to keep the default TTL otherwise.</a>
<a name="ln329">    if (ttl != Value::kMaxTtl || merge_flags == Value::kTtlFlag || exp-&gt;always_override) {</a>
<a name="ln330">      new_exp.write_ht = doc_ht.hybrid_time();</a>
<a name="ln331">      new_exp.ttl = ttl;</a>
<a name="ln332">    } else if (exp-&gt;ttl.IsNegative()) {</a>
<a name="ln333">      new_exp.ttl = -new_exp.ttl;</a>
<a name="ln334">    }</a>
<a name="ln335">  }</a>
<a name="ln336"> </a>
<a name="ln337">  // If we encounter a TTL row, we assign max_overwrite_time to be the write time of the</a>
<a name="ln338">  // original value/init marker.</a>
<a name="ln339">  if (merge_flags == Value::kTtlFlag) {</a>
<a name="ln340">    DocHybridTime new_ht;</a>
<a name="ln341">    RETURN_NOT_OK(iter-&gt;NextFullValue(&amp;new_ht, &amp;value));</a>
<a name="ln342"> </a>
<a name="ln343">    // There could be a case where the TTL row exists, but the value has been</a>
<a name="ln344">    // compacted away. Then, it is treated as a Tombstone written at the time</a>
<a name="ln345">    // of the TTL row.</a>
<a name="ln346">    if (!iter-&gt;valid() &amp;&amp; !new_exp.ttl.IsNegative()) {</a>
<a name="ln347">      new_exp.ttl = -new_exp.ttl;</a>
<a name="ln348">    } else {</a>
<a name="ln349">      ValueType value_type;</a>
<a name="ln350">      RETURN_NOT_OK(Value::DecodePrimitiveValueType(value, &amp;value_type));</a>
<a name="ln351">      // Because we still do not know whether we are seeking something expired,</a>
<a name="ln352">      // we must take the max_overwrite_time as if the value were not expired.</a>
<a name="ln353">      doc_ht = new_ht;</a>
<a name="ln354">    }</a>
<a name="ln355">  }</a>
<a name="ln356"> </a>
<a name="ln357">  if ((value_type == ValueType::kTombstone || value_type == ValueType::kInvalid) &amp;&amp;</a>
<a name="ln358">      !new_exp.ttl.IsNegative()) {</a>
<a name="ln359">    new_exp.ttl = -new_exp.ttl;</a>
<a name="ln360">  }</a>
<a name="ln361">  *exp = new_exp;</a>
<a name="ln362"> </a>
<a name="ln363">  if (doc_ht &gt; *max_overwrite_time) {</a>
<a name="ln364">    *max_overwrite_time = doc_ht;</a>
<a name="ln365">    VLOG(4) &lt;&lt; &quot;Max overwritten time for &quot; &lt;&lt; key_without_ht.ToDebugHexString() &lt;&lt; &quot;: &quot;</a>
<a name="ln366">            &lt;&lt; *max_overwrite_time;</a>
<a name="ln367">  }</a>
<a name="ln368"> </a>
<a name="ln369">  if (result_value)</a>
<a name="ln370">    RETURN_NOT_OK(result_value-&gt;Decode(value));</a>
<a name="ln371"> </a>
<a name="ln372">  return Status::OK();</a>
<a name="ln373">}</a>
<a name="ln374"> </a>
<a name="ln375">}  // namespace</a>
<a name="ln376"> </a>
<a name="ln377">yb::Status GetSubDocument(</a>
<a name="ln378">    const DocDB&amp; doc_db,</a>
<a name="ln379">    const GetSubDocumentData&amp; data,</a>
<a name="ln380">    const rocksdb::QueryId query_id,</a>
<a name="ln381">    const TransactionOperationContextOpt&amp; txn_op_context,</a>
<a name="ln382">    CoarseTimePoint deadline,</a>
<a name="ln383">    const ReadHybridTime&amp; read_time) {</a>
<a name="ln384">  auto iter = CreateIntentAwareIterator(</a>
<a name="ln385">      doc_db, BloomFilterMode::USE_BLOOM_FILTER, data.subdocument_key, query_id,</a>
<a name="ln386">      txn_op_context, deadline, read_time);</a>
<a name="ln387">  return GetSubDocument(iter.get(), data, nullptr /* projection */, SeekFwdSuffices::kFalse);</a>
<a name="ln388">}</a>
<a name="ln389"> </a>
<a name="ln390">yb::Status GetSubDocument(</a>
<a name="ln391">    IntentAwareIterator *db_iter,</a>
<a name="ln392">    const GetSubDocumentData&amp; data,</a>
<a name="ln393">    const vector&lt;PrimitiveValue&gt;* projection,</a>
<a name="ln394">    const SeekFwdSuffices seek_fwd_suffices) {</a>
<a name="ln395">  // TODO(dtxn) scan through all involved transactions first to cache statuses in a batch,</a>
<a name="ln396">  // so during building subdocument we don't need to request them one by one.</a>
<a name="ln397">  // TODO(dtxn) we need to restart read with scan_ht = commit_ht if some transaction was committed</a>
<a name="ln398">  // at time commit_ht within [scan_ht; read_request_time + max_clock_skew). Also we need</a>
<a name="ln399">  // to wait until time scan_ht = commit_ht passed.</a>
<a name="ln400">  // TODO(dtxn) for each scanned key (and its subkeys) we need to avoid *new* values committed at</a>
<a name="ln401">  // ht &lt;= scan_ht (or just ht &lt; scan_ht?)</a>
<a name="ln402">  // Question: what will break if we allow later commit at ht &lt;= scan_ht ? Need to write down</a>
<a name="ln403">  // detailed example.</a>
<a name="ln404">  *data.doc_found = false;</a>
<a name="ln405">  DOCDB_DEBUG_LOG(&quot;GetSubDocument for key $0 @ $1&quot;, data.subdocument_key.ToDebugHexString(),</a>
<a name="ln406">                  db_iter-&gt;read_time().ToString());</a>
<a name="ln407"> </a>
<a name="ln408">  // The latest time at which any prefix of the given key was overwritten.</a>
<a name="ln409">  DocHybridTime max_overwrite_ht(DocHybridTime::kMin);</a>
<a name="ln410">  VLOG(4) &lt;&lt; &quot;GetSubDocument(&quot; &lt;&lt; data &lt;&lt; &quot;)&quot;;</a>
<a name="ln411"> </a>
<a name="ln412">  SubDocKey found_subdoc_key;</a>
<a name="ln413">  auto dockey_size =</a>
<a name="ln414">      VERIFY_RESULT(DocKey::EncodedSize(data.subdocument_key, DocKeyPart::kWholeDocKey));</a>
<a name="ln415"> </a>
<a name="ln416">  Slice key_slice(data.subdocument_key.data(), dockey_size);</a>
<a name="ln417"> </a>
<a name="ln418">  // Check ancestors for init markers, tombstones, and expiration, tracking the expiration and</a>
<a name="ln419">  // corresponding most recent write time in exp, and the general most recent overwrite time in</a>
<a name="ln420">  // max_overwrite_ht.</a>
<a name="ln421">  //</a>
<a name="ln422">  // First, check for an ancestor at the ID level: a table tombstone.  Currently, this is only</a>
<a name="ln423">  // supported for YSQL colocated tables.  Since iterators only ever pertain to one table, there is</a>
<a name="ln424">  // no need to create a prefix scope here.</a>
<a name="ln425">  if (data.table_tombstone_time &amp;&amp; *data.table_tombstone_time == DocHybridTime::kInvalid) {</a>
<a name="ln426">    // Only check for table tombstones if the table is colocated, as signified by the prefix of</a>
<a name="ln427">    // kPgTableOid.</a>
<a name="ln428">    // TODO: adjust when fixing issue #3551</a>
<a name="ln429">    if (key_slice[0] == ValueTypeAsChar::kPgTableOid) {</a>
<a name="ln430">      // Seek to the ID level to look for a table tombstone.  Since this seek is expensive, cache</a>
<a name="ln431">      // the result in data.table_tombstone_time to avoid double seeking for the lifetime of the</a>
<a name="ln432">      // DocRowwiseIterator.</a>
<a name="ln433">      DocKey empty_key;</a>
<a name="ln434">      RETURN_NOT_OK(empty_key.DecodeFrom(key_slice, DocKeyPart::kUpToId));</a>
<a name="ln435">      db_iter-&gt;Seek(empty_key);</a>
<a name="ln436">      Value doc_value = Value(PrimitiveValue(ValueType::kInvalid));</a>
<a name="ln437">      RETURN_NOT_OK(FindLastWriteTime(</a>
<a name="ln438">          db_iter,</a>
<a name="ln439">          empty_key.Encode(),</a>
<a name="ln440">          &amp;max_overwrite_ht,</a>
<a name="ln441">          &amp;data.exp,</a>
<a name="ln442">          &amp;doc_value));</a>
<a name="ln443">      if (doc_value.value_type() == ValueType::kTombstone) {</a>
<a name="ln444">        SCHECK_NE(max_overwrite_ht, DocHybridTime::kInvalid, Corruption,</a>
<a name="ln445">                  &quot;Invalid hybrid time for table tombstone&quot;);</a>
<a name="ln446">        *data.table_tombstone_time = max_overwrite_ht;</a>
<a name="ln447">      } else {</a>
<a name="ln448">        *data.table_tombstone_time = DocHybridTime::kMin;</a>
<a name="ln449">      }</a>
<a name="ln450">    } else {</a>
<a name="ln451">      *data.table_tombstone_time = DocHybridTime::kMin;</a>
<a name="ln452">    }</a>
<a name="ln453">  } else if (data.table_tombstone_time) {</a>
<a name="ln454">    // Use the cached result.  Don't worry about exp as YSQL does not support TTL, yet.</a>
<a name="ln455">    max_overwrite_ht = *data.table_tombstone_time;</a>
<a name="ln456">  }</a>
<a name="ln457">  // Second, check the descendants of the ID level.</a>
<a name="ln458">  IntentAwareIteratorPrefixScope prefix_scope(key_slice, db_iter);</a>
<a name="ln459">  if (seek_fwd_suffices) {</a>
<a name="ln460">    db_iter-&gt;SeekForward(key_slice);</a>
<a name="ln461">  } else {</a>
<a name="ln462">    db_iter-&gt;Seek(key_slice);</a>
<a name="ln463">  }</a>
<a name="ln464">  {</a>
<a name="ln465">    auto temp_key = data.subdocument_key;</a>
<a name="ln466">    temp_key.remove_prefix(dockey_size);</a>
<a name="ln467">    for (;;) {</a>
<a name="ln468">      auto decode_result = VERIFY_RESULT(SubDocKey::DecodeSubkey(&amp;temp_key));</a>
<a name="ln469">      if (!decode_result) {</a>
<a name="ln470">        break;</a>
<a name="ln471">      }</a>
<a name="ln472">      RETURN_NOT_OK(FindLastWriteTime(db_iter, key_slice, &amp;max_overwrite_ht, &amp;data.exp));</a>
<a name="ln473">      key_slice = Slice(key_slice.data(), temp_key.data() - key_slice.data());</a>
<a name="ln474">    }</a>
<a name="ln475">  }</a>
<a name="ln476"> </a>
<a name="ln477">  // By this point, key_slice is the DocKey and all the subkeys of subdocument_key. Check for</a>
<a name="ln478">  // init-marker / tombstones at the top level; update max_overwrite_ht.</a>
<a name="ln479">  Value doc_value = Value(PrimitiveValue(ValueType::kInvalid));</a>
<a name="ln480">  RETURN_NOT_OK(FindLastWriteTime(db_iter, key_slice, &amp;max_overwrite_ht, &amp;data.exp, &amp;doc_value));</a>
<a name="ln481"> </a>
<a name="ln482">  const ValueType value_type = doc_value.value_type();</a>
<a name="ln483"> </a>
<a name="ln484">  if (data.return_type_only) {</a>
<a name="ln485">    *data.doc_found = value_type != ValueType::kInvalid &amp;&amp;</a>
<a name="ln486">      !data.exp.ttl.IsNegative();</a>
<a name="ln487">    // Check for expiration.</a>
<a name="ln488">    if (*data.doc_found &amp;&amp; max_overwrite_ht != DocHybridTime::kMin) {</a>
<a name="ln489">      bool has_expired;</a>
<a name="ln490">      CHECK_OK(HasExpiredTTL(data.exp.write_ht, data.exp.ttl,</a>
<a name="ln491">                             db_iter-&gt;read_time().read, &amp;has_expired));</a>
<a name="ln492">      *data.doc_found = !has_expired;</a>
<a name="ln493">    }</a>
<a name="ln494">    if (*data.doc_found) {</a>
<a name="ln495">      // Observe that this will have the right type but not necessarily the right value.</a>
<a name="ln496">      *data.result = SubDocument(doc_value.primitive_value());</a>
<a name="ln497">    }</a>
<a name="ln498">    return Status::OK();</a>
<a name="ln499">  }</a>
<a name="ln500"> </a>
<a name="ln501">  if (projection == nullptr) {</a>
<a name="ln502">    *data.result = SubDocument(ValueType::kInvalid);</a>
<a name="ln503">    int64 num_values_observed = 0;</a>
<a name="ln504">    IntentAwareIteratorPrefixScope prefix_scope(key_slice, db_iter);</a>
<a name="ln505">    RETURN_NOT_OK(BuildSubDocument(db_iter, data, max_overwrite_ht,</a>
<a name="ln506">                                   &amp;num_values_observed));</a>
<a name="ln507">    *data.doc_found = data.result-&gt;value_type() != ValueType::kInvalid;</a>
<a name="ln508">    if (*data.doc_found) {</a>
<a name="ln509">      if (value_type == ValueType::kRedisSet) {</a>
<a name="ln510">        RETURN_NOT_OK(data.result-&gt;ConvertToRedisSet());</a>
<a name="ln511">      } else if (value_type == ValueType::kRedisTS) {</a>
<a name="ln512">        RETURN_NOT_OK(data.result-&gt;ConvertToRedisTS());</a>
<a name="ln513">      } else if (value_type == ValueType::kRedisSortedSet) {</a>
<a name="ln514">        RETURN_NOT_OK(data.result-&gt;ConvertToRedisSortedSet());</a>
<a name="ln515">      } else if (value_type == ValueType::kRedisList) {</a>
<a name="ln516">        RETURN_NOT_OK(data.result-&gt;ConvertToRedisList());</a>
<a name="ln517">      }</a>
<a name="ln518">    }</a>
<a name="ln519">    return Status::OK();</a>
<a name="ln520">  }</a>
<a name="ln521">  // Seed key_bytes with the subdocument key. For each subkey in the projection, build subdocument</a>
<a name="ln522">  // and reuse key_bytes while appending the subkey.</a>
<a name="ln523">  *data.result = SubDocument();</a>
<a name="ln524">  KeyBytes key_bytes;</a>
<a name="ln525">  // Preallocate some extra space to avoid allocation for small subkeys.</a>
<a name="ln526">  key_bytes.Reserve(data.subdocument_key.size() + kMaxBytesPerEncodedHybridTime + 32);</a>
<a name="ln527">  key_bytes.AppendRawBytes(data.subdocument_key);</a>
<a name="ln528">  const size_t subdocument_key_size = key_bytes.size();</a>
<a name="ln529">  for (const PrimitiveValue&amp; subkey : *projection) {</a>
<a name="ln530">    // Append subkey to subdocument key. Reserve extra kMaxBytesPerEncodedHybridTime + 1 bytes in</a>
<a name="ln531">    // key_bytes to avoid the internal buffer from getting reallocated and moved by SeekForward()</a>
<a name="ln532">    // appending the hybrid time, thereby invalidating the buffer pointer saved by prefix_scope.</a>
<a name="ln533">    subkey.AppendToKey(&amp;key_bytes);</a>
<a name="ln534">    key_bytes.Reserve(key_bytes.size() + kMaxBytesPerEncodedHybridTime + 1);</a>
<a name="ln535">    // This seek is to initialize the iterator for BuildSubDocument call.</a>
<a name="ln536">    IntentAwareIteratorPrefixScope prefix_scope(key_bytes, db_iter);</a>
<a name="ln537">    db_iter-&gt;SeekForward(&amp;key_bytes);</a>
<a name="ln538">    SubDocument descendant(ValueType::kInvalid);</a>
<a name="ln539">    int64 num_values_observed = 0;</a>
<a name="ln540">    RETURN_NOT_OK(BuildSubDocument(</a>
<a name="ln541">        db_iter, data.Adjusted(key_bytes, &amp;descendant), max_overwrite_ht,</a>
<a name="ln542">        &amp;num_values_observed));</a>
<a name="ln543">    *data.doc_found = descendant.value_type() != ValueType::kInvalid;</a>
<a name="ln544">    data.result-&gt;SetChild(subkey, std::move(descendant));</a>
<a name="ln545"> </a>
<a name="ln546">    // Restore subdocument key by truncating the appended subkey.</a>
<a name="ln547">    key_bytes.Truncate(subdocument_key_size);</a>
<a name="ln548">  }</a>
<a name="ln549">  // Make sure the iterator is placed outside the whole document in the end.</a>
<a name="ln550">  key_bytes.Truncate(dockey_size);</a>
<a name="ln551">  db_iter-&gt;SeekOutOfSubDoc(&amp;key_bytes);</a>
<a name="ln552">  return Status::OK();</a>
<a name="ln553">}</a>
<a name="ln554"> </a>
<a name="ln555">}  // namespace docdb</a>
<a name="ln556">}  // namespace yb</a>

</code></pre>
<div class="balloon" rel="88"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="99"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="101"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="110"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="117"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="145"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="173"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="206"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="229"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="243"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="357"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: value_type == ValueType::kInvalid.</p></div>
<div class="balloon" rel="365"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="410"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="490"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
