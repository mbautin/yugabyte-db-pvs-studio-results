
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>column_family.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//  Copyright (c) 2011-present, Facebook, Inc.  All rights reserved.</a>
<a name="ln2">//  This source code is licensed under the BSD-style license found in the</a>
<a name="ln3">//  LICENSE file in the root directory of this source tree. An additional grant</a>
<a name="ln4">//  of patent rights can be found in the PATENTS file in the same directory.</a>
<a name="ln5">//</a>
<a name="ln6">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln7">//</a>
<a name="ln8">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln9">//</a>
<a name="ln10">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln11">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln12">//</a>
<a name="ln13">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln14">//</a>
<a name="ln15">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln16">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln17">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln18">// under the License.</a>
<a name="ln19">//</a>
<a name="ln20">// Copyright (c) 2011 The LevelDB Authors. All rights reserved.</a>
<a name="ln21">// Use of this source code is governed by a BSD-style license that can be</a>
<a name="ln22">// found in the LICENSE file. See the AUTHORS file for names of contributors.</a>
<a name="ln23"> </a>
<a name="ln24">#ifndef YB_ROCKSDB_DB_COLUMN_FAMILY_H</a>
<a name="ln25">#define YB_ROCKSDB_DB_COLUMN_FAMILY_H</a>
<a name="ln26"> </a>
<a name="ln27">#pragma once</a>
<a name="ln28"> </a>
<a name="ln29">#include &lt;unordered_map&gt;</a>
<a name="ln30">#include &lt;string&gt;</a>
<a name="ln31">#include &lt;vector&gt;</a>
<a name="ln32">#include &lt;atomic&gt;</a>
<a name="ln33"> </a>
<a name="ln34">#include &quot;yb/rocksdb/db/memtable_list.h&quot;</a>
<a name="ln35">#include &quot;yb/rocksdb/db/write_batch_internal.h&quot;</a>
<a name="ln36">#include &quot;yb/rocksdb/db/write_controller.h&quot;</a>
<a name="ln37">#include &quot;yb/rocksdb/db/table_cache.h&quot;</a>
<a name="ln38">#include &quot;yb/rocksdb/db/table_properties_collector.h&quot;</a>
<a name="ln39">#include &quot;yb/rocksdb/compaction_job_stats.h&quot;</a>
<a name="ln40">#include &quot;yb/rocksdb/db.h&quot;</a>
<a name="ln41">#include &quot;yb/rocksdb/env.h&quot;</a>
<a name="ln42">#include &quot;yb/rocksdb/options.h&quot;</a>
<a name="ln43">#include &quot;yb/rocksdb/util/mutable_cf_options.h&quot;</a>
<a name="ln44">#include &quot;yb/rocksdb/util/thread_local.h&quot;</a>
<a name="ln45"> </a>
<a name="ln46">namespace rocksdb {</a>
<a name="ln47"> </a>
<a name="ln48">class Version;</a>
<a name="ln49">class VersionSet;</a>
<a name="ln50">class MemTable;</a>
<a name="ln51">class MemTableListVersion;</a>
<a name="ln52">class CompactionPicker;</a>
<a name="ln53">class Compaction;</a>
<a name="ln54">class InternalKey;</a>
<a name="ln55">class InternalStats;</a>
<a name="ln56">class ColumnFamilyData;</a>
<a name="ln57">class DBImpl;</a>
<a name="ln58">class LogBuffer;</a>
<a name="ln59">class InstrumentedMutex;</a>
<a name="ln60">class InstrumentedMutexLock;</a>
<a name="ln61"> </a>
<a name="ln62">extern const double kSlowdownRatio;</a>
<a name="ln63"> </a>
<a name="ln64">// ColumnFamilyHandleImpl is the class that clients use to access different</a>
<a name="ln65">// column families. It has non-trivial destructor, which gets called when client</a>
<a name="ln66">// is done using the column family</a>
<a name="ln67">class ColumnFamilyHandleImpl : public ColumnFamilyHandle {</a>
<a name="ln68"> public:</a>
<a name="ln69">  // create while holding the mutex</a>
<a name="ln70">  ColumnFamilyHandleImpl(</a>
<a name="ln71">      ColumnFamilyData* cfd, DBImpl* db, InstrumentedMutex* mutex);</a>
<a name="ln72">  // destroy without mutex</a>
<a name="ln73">  virtual ~ColumnFamilyHandleImpl();</a>
<a name="ln74">  virtual ColumnFamilyData* cfd() const { return cfd_; }</a>
<a name="ln75">  virtual const Comparator* user_comparator() const;</a>
<a name="ln76"> </a>
<a name="ln77">  virtual uint32_t GetID() const override;</a>
<a name="ln78">  virtual const std::string&amp; GetName() const override;</a>
<a name="ln79">  virtual Status GetDescriptor(ColumnFamilyDescriptor* desc) override;</a>
<a name="ln80"> </a>
<a name="ln81"> private:</a>
<a name="ln82">  ColumnFamilyData* cfd_;</a>
<a name="ln83">  DBImpl* db_;</a>
<a name="ln84">  InstrumentedMutex* mutex_;</a>
<a name="ln85">};</a>
<a name="ln86"> </a>
<a name="ln87">// Does not ref-count ColumnFamilyData</a>
<a name="ln88">// We use this dummy ColumnFamilyHandleImpl because sometimes MemTableInserter</a>
<a name="ln89">// calls DBImpl methods. When this happens, MemTableInserter need access to</a>
<a name="ln90">// ColumnFamilyHandle (same as the client would need). In that case, we feed</a>
<a name="ln91">// MemTableInserter dummy ColumnFamilyHandle and enable it to call DBImpl</a>
<a name="ln92">// methods</a>
<a name="ln93">class ColumnFamilyHandleInternal : public ColumnFamilyHandleImpl {</a>
<a name="ln94"> public:</a>
<a name="ln95">  ColumnFamilyHandleInternal()</a>
<a name="ln96">      : ColumnFamilyHandleImpl(nullptr, nullptr, nullptr) {}</a>
<a name="ln97"> </a>
<a name="ln98">  void SetCFD(ColumnFamilyData* _cfd) { internal_cfd_ = _cfd; }</a>
<a name="ln99">  virtual ColumnFamilyData* cfd() const override { return internal_cfd_; }</a>
<a name="ln100"> </a>
<a name="ln101"> private:</a>
<a name="ln102">  ColumnFamilyData* internal_cfd_;</a>
<a name="ln103">};</a>
<a name="ln104"> </a>
<a name="ln105">// holds references to memtable, all immutable memtables and version</a>
<a name="ln106">struct SuperVersion {</a>
<a name="ln107">  // Accessing members of this class is not thread-safe and requires external</a>
<a name="ln108">  // synchronization (ie db mutex held or on write thread).</a>
<a name="ln109">  MemTable* mem;</a>
<a name="ln110">  MemTableListVersion* imm;</a>
<a name="ln111">  Version* current;</a>
<a name="ln112">  MutableCFOptions mutable_cf_options;</a>
<a name="ln113">  // Version number of the current SuperVersion</a>
<a name="ln114">  uint64_t version_number;</a>
<a name="ln115"> </a>
<a name="ln116">  InstrumentedMutex* db_mutex;</a>
<a name="ln117"> </a>
<a name="ln118">  // should be called outside the mutex</a>
<a name="ln119">  SuperVersion() = default;</a>
<a name="ln120">  ~SuperVersion();</a>
<a name="ln121">  SuperVersion* Ref();</a>
<a name="ln122">  // If Unref() returns true, Cleanup() should be called with mutex held</a>
<a name="ln123">  // before deleting this SuperVersion.</a>
<a name="ln124">  bool Unref();</a>
<a name="ln125"> </a>
<a name="ln126">  // call these two methods with db mutex held</a>
<a name="ln127">  // Cleanup unrefs mem, imm and current. Also, it stores all memtables</a>
<a name="ln128">  // that needs to be deleted in to_delete vector. Unrefing those</a>
<a name="ln129">  // objects needs to be done in the mutex</a>
<a name="ln130">  void Cleanup();</a>
<a name="ln131">  void Init(MemTable* new_mem, MemTableListVersion* new_imm,</a>
<a name="ln132">            Version* new_current);</a>
<a name="ln133"> </a>
<a name="ln134">  // The value of dummy is not actually used. kSVInUse takes its address as a</a>
<a name="ln135">  // mark in the thread local storage to indicate the SuperVersion is in use</a>
<a name="ln136">  // by thread. This way, the value of kSVInUse is guaranteed to have no</a>
<a name="ln137">  // conflict with SuperVersion object address and portable on different</a>
<a name="ln138">  // platform.</a>
<a name="ln139">  static int dummy;</a>
<a name="ln140">  static void* const kSVInUse;</a>
<a name="ln141">  static void* const kSVObsolete;</a>
<a name="ln142"> </a>
<a name="ln143"> private:</a>
<a name="ln144">  std::atomic&lt;uint32_t&gt; refs;</a>
<a name="ln145">  // We need to_delete because during Cleanup(), imm-&gt;Unref() returns</a>
<a name="ln146">  // all memtables that we need to free through this vector. We then</a>
<a name="ln147">  // delete all those memtables outside of mutex, during destruction</a>
<a name="ln148">  autovector&lt;MemTable*&gt; to_delete;</a>
<a name="ln149">};</a>
<a name="ln150"> </a>
<a name="ln151">extern Status CheckCompressionSupported(const ColumnFamilyOptions&amp; cf_options);</a>
<a name="ln152"> </a>
<a name="ln153">extern Status CheckConcurrentWritesSupported(</a>
<a name="ln154">    const ColumnFamilyOptions&amp; cf_options);</a>
<a name="ln155"> </a>
<a name="ln156">extern ColumnFamilyOptions SanitizeOptions(const DBOptions&amp; db_options,</a>
<a name="ln157">                                           const InternalKeyComparator* icmp,</a>
<a name="ln158">                                           const ColumnFamilyOptions&amp; src);</a>
<a name="ln159">// Wrap user defined table proproties collector factories `from cf_options`</a>
<a name="ln160">// into internal ones in int_tbl_prop_collector_factories. Add a system internal</a>
<a name="ln161">// one too.</a>
<a name="ln162">extern void GetIntTblPropCollectorFactory(</a>
<a name="ln163">    const ColumnFamilyOptions&amp; cf_options,</a>
<a name="ln164">    IntTblPropCollectorFactories* int_tbl_prop_collector_factories);</a>
<a name="ln165"> </a>
<a name="ln166">class ColumnFamilySet;</a>
<a name="ln167"> </a>
<a name="ln168">// This class keeps all the data that a column family needs.</a>
<a name="ln169">// Most methods require DB mutex held, unless otherwise noted</a>
<a name="ln170">class ColumnFamilyData {</a>
<a name="ln171"> public:</a>
<a name="ln172">  ~ColumnFamilyData();</a>
<a name="ln173"> </a>
<a name="ln174">  // thread-safe</a>
<a name="ln175">  uint32_t GetID() const { return id_; }</a>
<a name="ln176">  // thread-safe</a>
<a name="ln177">  const std::string&amp; GetName() const { return name_; }</a>
<a name="ln178"> </a>
<a name="ln179">  // Ref() can only be called from a context where the caller can guarantee</a>
<a name="ln180">  // that ColumnFamilyData is alive (while holding a non-zero ref already,</a>
<a name="ln181">  // holding a DB mutex, or as the leader in a write batch group).</a>
<a name="ln182">  void Ref() { refs_.fetch_add(1, std::memory_order_relaxed); }</a>
<a name="ln183"> </a>
<a name="ln184">  // Unref decreases the reference count, but does not handle deletion</a>
<a name="ln185">  // when the count goes to 0.  If this method returns true then the</a>
<a name="ln186">  // caller should delete the instance immediately, or later, by calling</a>
<a name="ln187">  // FreeDeadColumnFamilies().  Unref() can only be called while holding</a>
<a name="ln188">  // a DB mutex, or during single-threaded recovery.</a>
<a name="ln189">  bool Unref() {</a>
<a name="ln190">    int old_refs = refs_.fetch_sub(1, std::memory_order_relaxed);</a>
<a name="ln191">    assert(old_refs &gt; 0);</a>
<a name="ln192">    return old_refs == 1;</a>
<a name="ln193">  }</a>
<a name="ln194"> </a>
<a name="ln195">  // SetDropped() can only be called under following conditions:</a>
<a name="ln196">  // 1) Holding a DB mutex,</a>
<a name="ln197">  // 2) from single-threaded write thread, AND</a>
<a name="ln198">  // 3) from single-threaded VersionSet::LogAndApply()</a>
<a name="ln199">  // After dropping column family no other operation on that column family</a>
<a name="ln200">  // will be executed. All the files and memory will be, however, kept around</a>
<a name="ln201">  // until client drops the column family handle. That way, client can still</a>
<a name="ln202">  // access data from dropped column family.</a>
<a name="ln203">  // Column family can be dropped and still alive. In that state:</a>
<a name="ln204">  // *) Compaction and flush is not executed on the dropped column family.</a>
<a name="ln205">  // *) Client can continue reading from column family. Writes will fail unless</a>
<a name="ln206">  // WriteOptions::ignore_missing_column_families is true</a>
<a name="ln207">  // When the dropped column family is unreferenced, then we:</a>
<a name="ln208">  // *) Remove column family from the linked list maintained by ColumnFamilySet</a>
<a name="ln209">  // *) delete all memory associated with that column family</a>
<a name="ln210">  // *) delete all the files associated with that column family</a>
<a name="ln211">  void SetDropped();</a>
<a name="ln212">  bool IsDropped() const { return dropped_; }</a>
<a name="ln213"> </a>
<a name="ln214">  // thread-safe</a>
<a name="ln215">  int NumberLevels() const { return ioptions_.num_levels; }</a>
<a name="ln216"> </a>
<a name="ln217">  void SetLogNumber(uint64_t log_number) { log_number_ = log_number; }</a>
<a name="ln218">  uint64_t GetLogNumber() const { return log_number_; }</a>
<a name="ln219"> </a>
<a name="ln220">  // !!! To be deprecated! Please don't not use this function anymore!</a>
<a name="ln221">  const Options* options() const { return &amp;options_; }</a>
<a name="ln222"> </a>
<a name="ln223">  // thread-safe</a>
<a name="ln224">  const EnvOptions* soptions() const;</a>
<a name="ln225">  const ImmutableCFOptions* ioptions() const { return &amp;ioptions_; }</a>
<a name="ln226">  // REQUIRES: DB mutex held</a>
<a name="ln227">  // This returns the MutableCFOptions used by current SuperVersion</a>
<a name="ln228">  // You shoul use this API to reference MutableCFOptions most of the time.</a>
<a name="ln229">  const MutableCFOptions* GetCurrentMutableCFOptions() const {</a>
<a name="ln230">    return &amp;(super_version_-&gt;mutable_cf_options);</a>
<a name="ln231">  }</a>
<a name="ln232">  // REQUIRES: DB mutex held</a>
<a name="ln233">  // This returns the latest MutableCFOptions, which may be not in effect yet.</a>
<a name="ln234">  const MutableCFOptions* GetLatestMutableCFOptions() const {</a>
<a name="ln235">    return &amp;mutable_cf_options_;</a>
<a name="ln236">  }</a>
<a name="ln237">#ifndef ROCKSDB_LITE</a>
<a name="ln238">  // REQUIRES: DB mutex held</a>
<a name="ln239">  Status SetOptions(</a>
<a name="ln240">      const std::unordered_map&lt;std::string, std::string&gt;&amp; options_map);</a>
<a name="ln241">#endif  // ROCKSDB_LITE</a>
<a name="ln242"> </a>
<a name="ln243">  InternalStats* internal_stats() { return internal_stats_.get(); }</a>
<a name="ln244"> </a>
<a name="ln245">  MemTableList* imm() { return &amp;imm_; }</a>
<a name="ln246">  MemTable* mem() { return mem_; }</a>
<a name="ln247">  Version* current() const { return current_.load(); }</a>
<a name="ln248">  Version* dummy_versions() { return dummy_versions_; }</a>
<a name="ln249">  void SetCurrent(Version* _current);</a>
<a name="ln250">  uint64_t GetNumLiveVersions() const;  // REQUIRE: DB mutex held</a>
<a name="ln251">  uint64_t GetTotalSstFilesSize() const;  // REQUIRE: DB mutex held</a>
<a name="ln252">  void SetMemtable(MemTable* new_mem) { mem_ = new_mem; }</a>
<a name="ln253"> </a>
<a name="ln254">  // See Memtable constructor for explanation of earliest_seq param.</a>
<a name="ln255">  MemTable* ConstructNewMemtable(const MutableCFOptions&amp; mutable_cf_options,</a>
<a name="ln256">                                 SequenceNumber earliest_seq);</a>
<a name="ln257">  void CreateNewMemtable(const MutableCFOptions&amp; mutable_cf_options,</a>
<a name="ln258">                         SequenceNumber earliest_seq);</a>
<a name="ln259"> </a>
<a name="ln260">  TableCache* table_cache() const { return table_cache_.get(); }</a>
<a name="ln261"> </a>
<a name="ln262">  // See documentation in compaction_picker.h</a>
<a name="ln263">  // REQUIRES: DB mutex held</a>
<a name="ln264">  bool NeedsCompaction() const;</a>
<a name="ln265">  // REQUIRES: DB mutex held</a>
<a name="ln266">  std::unique_ptr&lt;Compaction&gt; PickCompaction(</a>
<a name="ln267">      const MutableCFOptions&amp; mutable_options, LogBuffer* log_buffer);</a>
<a name="ln268">  // A flag to tell a manual compaction is to compact all levels together</a>
<a name="ln269">  // instad of for specific level.</a>
<a name="ln270">  static const int kCompactAllLevels;</a>
<a name="ln271">  // A flag to tell a manual compaction's output is base level.</a>
<a name="ln272">  static const int kCompactToBaseLevel;</a>
<a name="ln273">  // REQUIRES: DB mutex held</a>
<a name="ln274">  std::unique_ptr&lt;Compaction&gt; CompactRange(</a>
<a name="ln275">      const MutableCFOptions&amp; mutable_cf_options,</a>
<a name="ln276">      int input_level,</a>
<a name="ln277">      int output_level,</a>
<a name="ln278">      uint32_t output_path_id,</a>
<a name="ln279">      const InternalKey* begin,</a>
<a name="ln280">      const InternalKey* end,</a>
<a name="ln281">      InternalKey** compaction_end,</a>
<a name="ln282">      bool* manual_conflict);</a>
<a name="ln283"> </a>
<a name="ln284">  CompactionPicker* compaction_picker() { return compaction_picker_.get(); }</a>
<a name="ln285">  // thread-safe</a>
<a name="ln286">  const Comparator* user_comparator() const {</a>
<a name="ln287">    return internal_comparator_-&gt;user_comparator();</a>
<a name="ln288">  }</a>
<a name="ln289">  // thread-safe</a>
<a name="ln290">  const InternalKeyComparatorPtr&amp; internal_comparator() const {</a>
<a name="ln291">    return internal_comparator_;</a>
<a name="ln292">  }</a>
<a name="ln293"> </a>
<a name="ln294">  const IntTblPropCollectorFactories&amp; int_tbl_prop_collector_factories() const {</a>
<a name="ln295">    return int_tbl_prop_collector_factories_;</a>
<a name="ln296">  }</a>
<a name="ln297"> </a>
<a name="ln298">  SuperVersion* GetSuperVersion() { return super_version_; }</a>
<a name="ln299">  // thread-safe</a>
<a name="ln300">  // Return a already referenced SuperVersion to be used safely.</a>
<a name="ln301">  SuperVersion* GetReferencedSuperVersion(InstrumentedMutex* db_mutex);</a>
<a name="ln302">  // thread-safe</a>
<a name="ln303">  // Get SuperVersion stored in thread local storage. If it does not exist,</a>
<a name="ln304">  // get a reference from a current SuperVersion.</a>
<a name="ln305">  SuperVersion* GetThreadLocalSuperVersion(InstrumentedMutex* db_mutex);</a>
<a name="ln306">  // Try to return SuperVersion back to thread local storage. Retrun true on</a>
<a name="ln307">  // success and false on failure. It fails when the thread local storage</a>
<a name="ln308">  // contains anything other than SuperVersion::kSVInUse flag.</a>
<a name="ln309">  bool ReturnThreadLocalSuperVersion(SuperVersion* sv);</a>
<a name="ln310">  // thread-safe</a>
<a name="ln311">  uint64_t GetSuperVersionNumber() const {</a>
<a name="ln312">    return super_version_number_.load();</a>
<a name="ln313">  }</a>
<a name="ln314">  // will return a pointer to SuperVersion* if previous SuperVersion</a>
<a name="ln315">  // if its reference count is zero and needs deletion or nullptr if not</a>
<a name="ln316">  // As argument takes a pointer to allocated SuperVersion to enable</a>
<a name="ln317">  // the clients to allocate SuperVersion outside of mutex.</a>
<a name="ln318">  // IMPORTANT: Only call this from DBImpl::InstallSuperVersion()</a>
<a name="ln319">  std::unique_ptr&lt;SuperVersion&gt; InstallSuperVersion(SuperVersion* new_superversion,</a>
<a name="ln320">                                                    InstrumentedMutex* db_mutex,</a>
<a name="ln321">                                                    const MutableCFOptions&amp; mutable_cf_options);</a>
<a name="ln322">  std::unique_ptr&lt;SuperVersion&gt; InstallSuperVersion(SuperVersion* new_superversion,</a>
<a name="ln323">                                                    InstrumentedMutex* db_mutex);</a>
<a name="ln324"> </a>
<a name="ln325">  void ResetThreadLocalSuperVersions();</a>
<a name="ln326"> </a>
<a name="ln327">  // Protected by DB mutex</a>
<a name="ln328">  void set_pending_flush(bool value) { pending_flush_ = value; }</a>
<a name="ln329">  void set_pending_compaction(bool value) { pending_compaction_ = value; }</a>
<a name="ln330">  bool pending_flush() { return pending_flush_; }</a>
<a name="ln331">  bool pending_compaction() { return pending_compaction_; }</a>
<a name="ln332"> </a>
<a name="ln333">  // Recalculate some small conditions, which are changed only during</a>
<a name="ln334">  // compaction, adding new memtable and/or</a>
<a name="ln335">  // recalculation of compaction score. These values are used in</a>
<a name="ln336">  // DBImpl::MakeRoomForWrite function to decide, if it need to make</a>
<a name="ln337">  // a write stall</a>
<a name="ln338">  void RecalculateWriteStallConditions(</a>
<a name="ln339">      const MutableCFOptions&amp; mutable_cf_options);</a>
<a name="ln340"> </a>
<a name="ln341"> private:</a>
<a name="ln342">  friend class ColumnFamilySet;</a>
<a name="ln343">  ColumnFamilyData(uint32_t id, const std::string&amp; name,</a>
<a name="ln344">                   Version* dummy_versions, Cache* table_cache,</a>
<a name="ln345">                   WriteBuffer* write_buffer,</a>
<a name="ln346">                   const ColumnFamilyOptions&amp; options,</a>
<a name="ln347">                   const DBOptions* db_options, const EnvOptions&amp; env_options,</a>
<a name="ln348">                   ColumnFamilySet* column_family_set);</a>
<a name="ln349"> </a>
<a name="ln350">  uint32_t id_;</a>
<a name="ln351">  const std::string name_;</a>
<a name="ln352">  Version* dummy_versions_;  // Head of circular doubly-linked list of versions.</a>
<a name="ln353">  std::atomic&lt;Version*&gt; current_; // == dummy_versions-&gt;prev_</a>
<a name="ln354"> </a>
<a name="ln355">  std::atomic&lt;int&gt; refs_;      // outstanding references to ColumnFamilyData</a>
<a name="ln356">  bool dropped_;               // true if client dropped it</a>
<a name="ln357"> </a>
<a name="ln358">  InternalKeyComparatorPtr internal_comparator_;</a>
<a name="ln359">  IntTblPropCollectorFactories int_tbl_prop_collector_factories_;</a>
<a name="ln360"> </a>
<a name="ln361">  const Options options_;</a>
<a name="ln362">  const ImmutableCFOptions ioptions_;</a>
<a name="ln363">  MutableCFOptions mutable_cf_options_;</a>
<a name="ln364"> </a>
<a name="ln365">  std::unique_ptr&lt;TableCache&gt; table_cache_;</a>
<a name="ln366"> </a>
<a name="ln367">  std::unique_ptr&lt;InternalStats&gt; internal_stats_;</a>
<a name="ln368"> </a>
<a name="ln369">  WriteBuffer* write_buffer_;</a>
<a name="ln370"> </a>
<a name="ln371">  MemTable* mem_;</a>
<a name="ln372">  MemTableList imm_;</a>
<a name="ln373">  SuperVersion* super_version_;</a>
<a name="ln374"> </a>
<a name="ln375">  // An ordinal representing the current SuperVersion. Updated by</a>
<a name="ln376">  // InstallSuperVersion(), i.e. incremented every time super_version_</a>
<a name="ln377">  // changes.</a>
<a name="ln378">  std::atomic&lt;uint64_t&gt; super_version_number_;</a>
<a name="ln379"> </a>
<a name="ln380">  // Thread's local copy of SuperVersion pointer</a>
<a name="ln381">  // This needs to be destructed before mutex_</a>
<a name="ln382">  std::unique_ptr&lt;ThreadLocalPtr&gt; local_sv_;</a>
<a name="ln383"> </a>
<a name="ln384">  // pointers for a circular linked list. we use it to support iterations over</a>
<a name="ln385">  // all column families that are alive (note: dropped column families can also</a>
<a name="ln386">  // be alive as long as client holds a reference)</a>
<a name="ln387">  ColumnFamilyData* next_;</a>
<a name="ln388">  ColumnFamilyData* prev_;</a>
<a name="ln389"> </a>
<a name="ln390">  // This is the earliest log file number that contains data from this</a>
<a name="ln391">  // Column Family. All earlier log files must be ignored and not</a>
<a name="ln392">  // recovered from</a>
<a name="ln393">  uint64_t log_number_;</a>
<a name="ln394"> </a>
<a name="ln395">  // An object that keeps all the compaction stats</a>
<a name="ln396">  // and picks the next compaction</a>
<a name="ln397">  std::unique_ptr&lt;CompactionPicker&gt; compaction_picker_;</a>
<a name="ln398"> </a>
<a name="ln399">  ColumnFamilySet* column_family_set_;</a>
<a name="ln400"> </a>
<a name="ln401">  std::unique_ptr&lt;WriteControllerToken&gt; write_controller_token_;</a>
<a name="ln402"> </a>
<a name="ln403">  // If true --&gt; this ColumnFamily is currently present in DBImpl::flush_queue_</a>
<a name="ln404">  bool pending_flush_;</a>
<a name="ln405"> </a>
<a name="ln406">  // If true --&gt; this ColumnFamily is currently present in</a>
<a name="ln407">  // DBImpl::compaction_queue_</a>
<a name="ln408">  bool pending_compaction_;</a>
<a name="ln409"> </a>
<a name="ln410">  uint64_t prev_compaction_needed_bytes_;</a>
<a name="ln411">};</a>
<a name="ln412"> </a>
<a name="ln413">// ColumnFamilySet has interesting thread-safety requirements</a>
<a name="ln414">// * CreateColumnFamily() or RemoveColumnFamily() -- need to be protected by DB</a>
<a name="ln415">// mutex AND executed in the write thread.</a>
<a name="ln416">// CreateColumnFamily() should ONLY be called from VersionSet::LogAndApply() AND</a>
<a name="ln417">// single-threaded write thread. It is also called during Recovery and in</a>
<a name="ln418">// DumpManifest().</a>
<a name="ln419">// RemoveColumnFamily() is only called from SetDropped(). DB mutex needs to be</a>
<a name="ln420">// held and it needs to be executed from the write thread. SetDropped() also</a>
<a name="ln421">// guarantees that it will be called only from single-threaded LogAndApply(),</a>
<a name="ln422">// but this condition is not that important.</a>
<a name="ln423">// * Iteration -- hold DB mutex, but you can release it in the body of</a>
<a name="ln424">// iteration. If you release DB mutex in body, reference the column</a>
<a name="ln425">// family before the mutex and unreference after you unlock, since the column</a>
<a name="ln426">// family might get dropped when the DB mutex is released</a>
<a name="ln427">// * GetDefault() -- thread safe</a>
<a name="ln428">// * GetColumnFamily() -- either inside of DB mutex or from a write thread</a>
<a name="ln429">// * GetNextColumnFamilyID(), GetMaxColumnFamily(), UpdateMaxColumnFamily(),</a>
<a name="ln430">// NumberOfColumnFamilies -- inside of DB mutex</a>
<a name="ln431">class ColumnFamilySet {</a>
<a name="ln432"> public:</a>
<a name="ln433">  // ColumnFamilySet supports iteration</a>
<a name="ln434">  class iterator {</a>
<a name="ln435">   public:</a>
<a name="ln436">    explicit iterator(ColumnFamilyData* cfd)</a>
<a name="ln437">        : current_(cfd) {}</a>
<a name="ln438">    iterator&amp; operator++() {</a>
<a name="ln439">      // dropped column families might still be included in this iteration</a>
<a name="ln440">      // (we're only removing them when client drops the last reference to the</a>
<a name="ln441">      // column family).</a>
<a name="ln442">      // dummy is never dead, so this will never be infinite</a>
<a name="ln443">      do {</a>
<a name="ln444">        current_ = current_-&gt;next_;</a>
<a name="ln445">      } while (current_-&gt;refs_.load(std::memory_order_relaxed) == 0);</a>
<a name="ln446">      return *this;</a>
<a name="ln447">    }</a>
<a name="ln448">    bool operator!=(const iterator&amp; other) {</a>
<a name="ln449">      return this-&gt;current_ != other.current_;</a>
<a name="ln450">    }</a>
<a name="ln451">    ColumnFamilyData* operator*() { return current_; }</a>
<a name="ln452"> </a>
<a name="ln453">   private:</a>
<a name="ln454">    ColumnFamilyData* current_;</a>
<a name="ln455">  };</a>
<a name="ln456"> </a>
<a name="ln457">  ColumnFamilySet(const std::string&amp; dbname, const DBOptions* db_options,</a>
<a name="ln458">                  const EnvOptions&amp; env_options, Cache* table_cache,</a>
<a name="ln459">                  WriteBuffer* write_buffer, WriteController* write_controller);</a>
<a name="ln460">  ~ColumnFamilySet();</a>
<a name="ln461"> </a>
<a name="ln462">  ColumnFamilyData* GetDefault() const;</a>
<a name="ln463">  // GetColumnFamily() calls return nullptr if column family is not found</a>
<a name="ln464">  ColumnFamilyData* GetColumnFamily(uint32_t id) const;</a>
<a name="ln465">  ColumnFamilyData* GetColumnFamily(const std::string&amp; name) const;</a>
<a name="ln466">  // this call will return the next available column family ID. it guarantees</a>
<a name="ln467">  // that there is no column family with id greater than or equal to the</a>
<a name="ln468">  // returned value in the current running instance or anytime in RocksDB</a>
<a name="ln469">  // instance history.</a>
<a name="ln470">  uint32_t GetNextColumnFamilyID();</a>
<a name="ln471">  uint32_t GetMaxColumnFamily();</a>
<a name="ln472">  void UpdateMaxColumnFamily(uint32_t new_max_column_family);</a>
<a name="ln473">  size_t NumberOfColumnFamilies() const;</a>
<a name="ln474"> </a>
<a name="ln475">  ColumnFamilyData* CreateColumnFamily(const std::string&amp; name, uint32_t id,</a>
<a name="ln476">                                       Version* dummy_version,</a>
<a name="ln477">                                       const ColumnFamilyOptions&amp; options);</a>
<a name="ln478"> </a>
<a name="ln479">  iterator begin() { return iterator(dummy_cfd_-&gt;next_); }</a>
<a name="ln480">  iterator end() { return iterator(dummy_cfd_); }</a>
<a name="ln481"> </a>
<a name="ln482">  // REQUIRES: DB mutex held</a>
<a name="ln483">  // Don't call while iterating over ColumnFamilySet</a>
<a name="ln484">  void FreeDeadColumnFamilies();</a>
<a name="ln485"> </a>
<a name="ln486"> private:</a>
<a name="ln487">  friend class ColumnFamilyData;</a>
<a name="ln488">  // helper function that gets called from cfd destructor</a>
<a name="ln489">  // REQUIRES: DB mutex held</a>
<a name="ln490">  void RemoveColumnFamily(ColumnFamilyData* cfd);</a>
<a name="ln491"> </a>
<a name="ln492">  // column_families_ and column_family_data_ need to be protected:</a>
<a name="ln493">  // * when mutating both conditions have to be satisfied:</a>
<a name="ln494">  // 1. DB mutex locked</a>
<a name="ln495">  // 2. thread currently in single-threaded write thread</a>
<a name="ln496">  // * when reading, at least one condition needs to be satisfied:</a>
<a name="ln497">  // 1. DB mutex locked</a>
<a name="ln498">  // 2. accessed from a single-threaded write thread</a>
<a name="ln499">  std::unordered_map&lt;std::string, uint32_t&gt; column_families_;</a>
<a name="ln500">  std::unordered_map&lt;uint32_t, ColumnFamilyData*&gt; column_family_data_;</a>
<a name="ln501"> </a>
<a name="ln502">  uint32_t max_column_family_;</a>
<a name="ln503">  ColumnFamilyData* dummy_cfd_;</a>
<a name="ln504">  // We don't hold the refcount here, since default column family always exists</a>
<a name="ln505">  // We are also not responsible for cleaning up default_cfd_cache_. This is</a>
<a name="ln506">  // just a cache that makes common case (accessing default column family)</a>
<a name="ln507">  // faster</a>
<a name="ln508">  ColumnFamilyData* default_cfd_cache_;</a>
<a name="ln509"> </a>
<a name="ln510">  const std::string db_name_;</a>
<a name="ln511">  const DBOptions* const db_options_;</a>
<a name="ln512">  const EnvOptions env_options_;</a>
<a name="ln513">  Cache* table_cache_;</a>
<a name="ln514">  WriteBuffer* write_buffer_;</a>
<a name="ln515">  WriteController* write_controller_;</a>
<a name="ln516">};</a>
<a name="ln517"> </a>
<a name="ln518">// We use ColumnFamilyMemTablesImpl to provide WriteBatch a way to access</a>
<a name="ln519">// memtables of different column families (specified by ID in the write batch)</a>
<a name="ln520">class ColumnFamilyMemTablesImpl : public ColumnFamilyMemTables {</a>
<a name="ln521"> public:</a>
<a name="ln522">  explicit ColumnFamilyMemTablesImpl(ColumnFamilySet* column_family_set)</a>
<a name="ln523">      : column_family_set_(column_family_set), current_(nullptr) {}</a>
<a name="ln524"> </a>
<a name="ln525">  // Constructs a ColumnFamilyMemTablesImpl equivalent to one constructed</a>
<a name="ln526">  // with the arguments used to construct *orig.</a>
<a name="ln527">  explicit ColumnFamilyMemTablesImpl(ColumnFamilyMemTablesImpl* orig)</a>
<a name="ln528">      : column_family_set_(orig-&gt;column_family_set_), current_(nullptr) {}</a>
<a name="ln529"> </a>
<a name="ln530">  // sets current_ to ColumnFamilyData with column_family_id</a>
<a name="ln531">  // returns false if column family doesn't exist</a>
<a name="ln532">  // REQUIRES: use this function of DBImpl::column_family_memtables_ should be</a>
<a name="ln533">  //           under a DB mutex OR from a write thread</a>
<a name="ln534">  bool Seek(uint32_t column_family_id) override;</a>
<a name="ln535"> </a>
<a name="ln536">  // Returns log number of the selected column family</a>
<a name="ln537">  // REQUIRES: under a DB mutex OR from a write thread</a>
<a name="ln538">  uint64_t GetLogNumber() const override;</a>
<a name="ln539"> </a>
<a name="ln540">  // REQUIRES: Seek() called first</a>
<a name="ln541">  // REQUIRES: use this function of DBImpl::column_family_memtables_ should be</a>
<a name="ln542">  //           under a DB mutex OR from a write thread</a>
<a name="ln543">  virtual MemTable* GetMemTable() const override;</a>
<a name="ln544"> </a>
<a name="ln545">  // Returns column family handle for the selected column family</a>
<a name="ln546">  // REQUIRES: use this function of DBImpl::column_family_memtables_ should be</a>
<a name="ln547">  //           under a DB mutex OR from a write thread</a>
<a name="ln548">  virtual ColumnFamilyHandle* GetColumnFamilyHandle() override;</a>
<a name="ln549"> </a>
<a name="ln550">  // Cannot be called while another thread is calling Seek().</a>
<a name="ln551">  // REQUIRES: use this function of DBImpl::column_family_memtables_ should be</a>
<a name="ln552">  //           under a DB mutex OR from a write thread</a>
<a name="ln553">  virtual ColumnFamilyData* current() override { return current_; }</a>
<a name="ln554"> </a>
<a name="ln555"> private:</a>
<a name="ln556">  ColumnFamilySet* column_family_set_;</a>
<a name="ln557">  ColumnFamilyData* current_;</a>
<a name="ln558">  ColumnFamilyHandleInternal handle_;</a>
<a name="ln559">};</a>
<a name="ln560"> </a>
<a name="ln561">extern uint32_t GetColumnFamilyID(ColumnFamilyHandle* column_family);</a>
<a name="ln562"> </a>
<a name="ln563">extern const Comparator* GetColumnFamilyUserComparator(</a>
<a name="ln564">    ColumnFamilyHandle* column_family);</a>
<a name="ln565"> </a>
<a name="ln566">}  // namespace rocksdb</a>
<a name="ln567"> </a>
<a name="ln568">#endif // YB_ROCKSDB_DB_COLUMN_FAMILY_H</a>

</code></pre>
<div class="balloon" rel="95"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: internal_cfd_.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
