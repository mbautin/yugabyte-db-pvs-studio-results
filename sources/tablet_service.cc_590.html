
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>tablet_service.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Licensed to the Apache Software Foundation (ASF) under one</a>
<a name="ln2">// or more contributor license agreements.  See the NOTICE file</a>
<a name="ln3">// distributed with this work for additional information</a>
<a name="ln4">// regarding copyright ownership.  The ASF licenses this file</a>
<a name="ln5">// to you under the Apache License, Version 2.0 (the</a>
<a name="ln6">// &quot;License&quot;); you may not use this file except in compliance</a>
<a name="ln7">// with the License.  You may obtain a copy of the License at</a>
<a name="ln8">//</a>
<a name="ln9">//   http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln10">//</a>
<a name="ln11">// Unless required by applicable law or agreed to in writing,</a>
<a name="ln12">// software distributed under the License is distributed on an</a>
<a name="ln13">// &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</a>
<a name="ln14">// KIND, either express or implied.  See the License for the</a>
<a name="ln15">// specific language governing permissions and limitations</a>
<a name="ln16">// under the License.</a>
<a name="ln17">//</a>
<a name="ln18">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln19">//</a>
<a name="ln20">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln21">//</a>
<a name="ln22">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln23">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln24">//</a>
<a name="ln25">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln26">//</a>
<a name="ln27">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln28">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln29">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln30">// under the License.</a>
<a name="ln31">//</a>
<a name="ln32"> </a>
<a name="ln33">#include &quot;yb/tserver/tablet_service.h&quot;</a>
<a name="ln34"> </a>
<a name="ln35">#include &lt;algorithm&gt;</a>
<a name="ln36">#include &lt;memory&gt;</a>
<a name="ln37">#include &lt;string&gt;</a>
<a name="ln38">#include &lt;vector&gt;</a>
<a name="ln39"> </a>
<a name="ln40">#include &quot;yb/client/transaction.h&quot;</a>
<a name="ln41">#include &quot;yb/client/transaction_pool.h&quot;</a>
<a name="ln42"> </a>
<a name="ln43">#include &quot;yb/common/ql_value.h&quot;</a>
<a name="ln44">#include &quot;yb/common/row_mark.h&quot;</a>
<a name="ln45">#include &quot;yb/common/schema.h&quot;</a>
<a name="ln46">#include &quot;yb/common/wire_protocol.h&quot;</a>
<a name="ln47">#include &quot;yb/consensus/leader_lease.h&quot;</a>
<a name="ln48">#include &quot;yb/consensus/raft_consensus.h&quot;</a>
<a name="ln49"> </a>
<a name="ln50">#include &quot;yb/docdb/cql_operation.h&quot;</a>
<a name="ln51">#include &quot;yb/docdb/doc_rowwise_iterator.h&quot;</a>
<a name="ln52">#include &quot;yb/docdb/pgsql_operation.h&quot;</a>
<a name="ln53"> </a>
<a name="ln54">#include &quot;yb/gutil/bind.h&quot;</a>
<a name="ln55">#include &quot;yb/gutil/casts.h&quot;</a>
<a name="ln56">#include &quot;yb/gutil/stl_util.h&quot;</a>
<a name="ln57">#include &quot;yb/gutil/stringprintf.h&quot;</a>
<a name="ln58">#include &quot;yb/gutil/strings/escaping.h&quot;</a>
<a name="ln59">#include &quot;yb/master/sys_catalog_constants.h&quot;</a>
<a name="ln60">#include &quot;yb/server/hybrid_clock.h&quot;</a>
<a name="ln61"> </a>
<a name="ln62">#include &quot;yb/tablet/tablet_bootstrap_if.h&quot;</a>
<a name="ln63">#include &quot;yb/tablet/abstract_tablet.h&quot;</a>
<a name="ln64">#include &quot;yb/tablet/metadata.pb.h&quot;</a>
<a name="ln65">#include &quot;yb/tablet/tablet.h&quot;</a>
<a name="ln66">#include &quot;yb/tablet/tablet_metrics.h&quot;</a>
<a name="ln67"> </a>
<a name="ln68">#include &quot;yb/tablet/operations/change_metadata_operation.h&quot;</a>
<a name="ln69">#include &quot;yb/tablet/operations/split_operation.h&quot;</a>
<a name="ln70">#include &quot;yb/tablet/operations/truncate_operation.h&quot;</a>
<a name="ln71">#include &quot;yb/tablet/operations/update_txn_operation.h&quot;</a>
<a name="ln72">#include &quot;yb/tablet/operations/write_operation.h&quot;</a>
<a name="ln73"> </a>
<a name="ln74">#include &quot;yb/tserver/remote_bootstrap_service.h&quot;</a>
<a name="ln75">#include &quot;yb/tserver/tablet_server.h&quot;</a>
<a name="ln76">#include &quot;yb/tserver/ts_tablet_manager.h&quot;</a>
<a name="ln77">#include &quot;yb/tserver/tserver_error.h&quot;</a>
<a name="ln78">#include &quot;yb/tserver/tserver.pb.h&quot;</a>
<a name="ln79"> </a>
<a name="ln80">#include &quot;yb/util/crc.h&quot;</a>
<a name="ln81">#include &quot;yb/util/debug/long_operation_tracker.h&quot;</a>
<a name="ln82">#include &quot;yb/util/debug/trace_event.h&quot;</a>
<a name="ln83">#include &quot;yb/util/faststring.h&quot;</a>
<a name="ln84">#include &quot;yb/util/flag_tags.h&quot;</a>
<a name="ln85">#include &quot;yb/util/math_util.h&quot;</a>
<a name="ln86">#include &quot;yb/util/mem_tracker.h&quot;</a>
<a name="ln87">#include &quot;yb/util/monotime.h&quot;</a>
<a name="ln88">#include &quot;yb/util/random_util.h&quot;</a>
<a name="ln89">#include &quot;yb/util/scope_exit.h&quot;</a>
<a name="ln90">#include &quot;yb/util/size_literals.h&quot;</a>
<a name="ln91">#include &quot;yb/util/status.h&quot;</a>
<a name="ln92">#include &quot;yb/util/status_callback.h&quot;</a>
<a name="ln93">#include &quot;yb/util/trace.h&quot;</a>
<a name="ln94">#include &quot;yb/util/string_util.h&quot;</a>
<a name="ln95">#include &quot;yb/consensus/consensus.pb.h&quot;</a>
<a name="ln96">#include &quot;yb/tserver/service_util.h&quot;</a>
<a name="ln97"> </a>
<a name="ln98">#include &quot;yb/yql/pggate/util/pg_doc_data.h&quot;</a>
<a name="ln99"> </a>
<a name="ln100">using namespace std::literals;  // NOLINT</a>
<a name="ln101"> </a>
<a name="ln102">DEFINE_int32(scanner_default_batch_size_bytes, 64 * 1024,</a>
<a name="ln103">             &quot;The default size for batches of scan results&quot;);</a>
<a name="ln104">TAG_FLAG(scanner_default_batch_size_bytes, advanced);</a>
<a name="ln105">TAG_FLAG(scanner_default_batch_size_bytes, runtime);</a>
<a name="ln106"> </a>
<a name="ln107">DEFINE_int32(scanner_max_batch_size_bytes, 8 * 1024 * 1024,</a>
<a name="ln108">             &quot;The maximum batch size that a client may request for &quot;</a>
<a name="ln109">             &quot;scan results.&quot;);</a>
<a name="ln110">TAG_FLAG(scanner_max_batch_size_bytes, advanced);</a>
<a name="ln111">TAG_FLAG(scanner_max_batch_size_bytes, runtime);</a>
<a name="ln112"> </a>
<a name="ln113">DEFINE_int32(scanner_batch_size_rows, 100,</a>
<a name="ln114">             &quot;The number of rows to batch for servicing scan requests.&quot;);</a>
<a name="ln115">TAG_FLAG(scanner_batch_size_rows, advanced);</a>
<a name="ln116">TAG_FLAG(scanner_batch_size_rows, runtime);</a>
<a name="ln117"> </a>
<a name="ln118">DEFINE_bool(parallelize_read_ops, true,</a>
<a name="ln119">            &quot;Controls weather multiple (Redis) read ops that are present in a operation &quot;</a>
<a name="ln120">            &quot;should be executed in parallel.&quot;);</a>
<a name="ln121">TAG_FLAG(parallelize_read_ops, advanced);</a>
<a name="ln122">TAG_FLAG(parallelize_read_ops, runtime);</a>
<a name="ln123"> </a>
<a name="ln124">// Fault injection flags.</a>
<a name="ln125">DEFINE_test_flag(int32, scanner_inject_latency_on_each_batch_ms, 0,</a>
<a name="ln126">                 &quot;If set, the scanner will pause the specified number of milliesconds &quot;</a>
<a name="ln127">                 &quot;before reading each batch of data on the tablet server.&quot;);</a>
<a name="ln128"> </a>
<a name="ln129">DECLARE_int32(memory_limit_warn_threshold_percentage);</a>
<a name="ln130"> </a>
<a name="ln131">DEFINE_int32(max_wait_for_safe_time_ms, 5000,</a>
<a name="ln132">             &quot;Maximum time in milliseconds to wait for the safe time to advance when trying to &quot;</a>
<a name="ln133">             &quot;scan at the given hybrid_time.&quot;);</a>
<a name="ln134"> </a>
<a name="ln135">DEFINE_int32(num_concurrent_backfills_allowed, 8,</a>
<a name="ln136">             &quot;Maximum number of concurrent backfill jobs that is allowed to run.&quot;);</a>
<a name="ln137"> </a>
<a name="ln138">DEFINE_test_flag(bool, tserver_noop_read_write, false, &quot;Respond NOOP to read/write.&quot;);</a>
<a name="ln139"> </a>
<a name="ln140">DEFINE_int32(max_stale_read_bound_time_ms, 0, &quot;If we are allowed to read from followers, &quot;</a>
<a name="ln141">             &quot;specify the maximum time a follower can be behind by using the last message received &quot;</a>
<a name="ln142">             &quot;from the leader. If set to zero, a read can be served by a follower regardless of &quot;</a>
<a name="ln143">             &quot;when was the last time it received a message from the leader or how far behind this&quot;</a>
<a name="ln144">             &quot;follower is.&quot;);</a>
<a name="ln145">TAG_FLAG(max_stale_read_bound_time_ms, evolving);</a>
<a name="ln146">TAG_FLAG(max_stale_read_bound_time_ms, runtime);</a>
<a name="ln147"> </a>
<a name="ln148">DEFINE_uint64(sst_files_soft_limit, 24,</a>
<a name="ln149">              &quot;When majority SST files number is greater that this limit, we will start rejecting &quot;</a>
<a name="ln150">              &quot;part of write requests. The higher the number of SST files, the higher probability &quot;</a>
<a name="ln151">              &quot;of rejection.&quot;);</a>
<a name="ln152">TAG_FLAG(sst_files_soft_limit, runtime);</a>
<a name="ln153"> </a>
<a name="ln154">DEFINE_uint64(sst_files_hard_limit, 48,</a>
<a name="ln155">              &quot;When majority SST files number is greater that this limit, we will reject all write &quot;</a>
<a name="ln156">              &quot;requests.&quot;);</a>
<a name="ln157">TAG_FLAG(sst_files_hard_limit, runtime);</a>
<a name="ln158"> </a>
<a name="ln159">DEFINE_uint64(min_rejection_delay_ms, 100, &quot;.&quot;);</a>
<a name="ln160">TAG_FLAG(min_rejection_delay_ms, runtime);</a>
<a name="ln161"> </a>
<a name="ln162">DEFINE_uint64(max_rejection_delay_ms, 5000, &quot;.&quot;);</a>
<a name="ln163">TAG_FLAG(max_rejection_delay_ms, runtime);</a>
<a name="ln164"> </a>
<a name="ln165">DEFINE_uint64(index_backfill_upperbound_for_user_enforced_txn_duration_ms, 65000,</a>
<a name="ln166">              &quot;For Non-Txn tables, it is impossible to know at the tservers &quot;</a>
<a name="ln167">              &quot;weather or not an 'old transaction' is still active. To avoid &quot;</a>
<a name="ln168">              &quot;having such old transactions, we assume a bound on the duration &quot;</a>
<a name="ln169">              &quot;of such transactions (during the backfill process) and wait &quot;</a>
<a name="ln170">              &quot;it out. This flag denotes a conservative upper bound on the &quot;</a>
<a name="ln171">              &quot;duration of such user enforced transactions.&quot;);</a>
<a name="ln172">TAG_FLAG(index_backfill_upperbound_for_user_enforced_txn_duration_ms, evolving);</a>
<a name="ln173">TAG_FLAG(index_backfill_upperbound_for_user_enforced_txn_duration_ms, runtime);</a>
<a name="ln174"> </a>
<a name="ln175">DEFINE_int32(index_backfill_additional_delay_before_backfilling_ms, 0,</a>
<a name="ln176">             &quot;Operations that are received by the tserver, and have decided how &quot;</a>
<a name="ln177">             &quot;the indexes need to be updated (based on the IndexPermission), will &quot;</a>
<a name="ln178">             &quot;not be added to the list of current transactions until they are &quot;</a>
<a name="ln179">             &quot;replicated/applied. This delay allows for the GetSafeTime method &quot;</a>
<a name="ln180">             &quot;to wait for such operations to be replicated/applied. Ideally, this &quot;</a>
<a name="ln181">             &quot;value should be set to be something larger than the raft-heartbeat-interval &quot;</a>
<a name="ln182">             &quot;but can be as high as the client_rpc_timeout if we want to be more conservative.&quot;);</a>
<a name="ln183">TAG_FLAG(index_backfill_additional_delay_before_backfilling_ms, evolving);</a>
<a name="ln184">TAG_FLAG(index_backfill_additional_delay_before_backfilling_ms, runtime);</a>
<a name="ln185"> </a>
<a name="ln186">DEFINE_int32(index_backfill_wait_for_old_txns_ms, 0,</a>
<a name="ln187">             &quot;Index backfill needs to wait for transactions that started before the &quot;</a>
<a name="ln188">             &quot;WRITE_AND_DELETE phase to commit or abort before choosing a time for &quot;</a>
<a name="ln189">             &quot;backfilling the index. This is the max time that the GetSafeTime call will &quot;</a>
<a name="ln190">             &quot;wait for, before it resorts to attempt aborting old transactions. This is &quot;</a>
<a name="ln191">             &quot;necessary to guard against the pathological active transaction that never &quot;</a>
<a name="ln192">             &quot;commits, from blocking the index backfill forever.&quot;);</a>
<a name="ln193">TAG_FLAG(index_backfill_wait_for_old_txns_ms, evolving);</a>
<a name="ln194">TAG_FLAG(index_backfill_wait_for_old_txns_ms, runtime);</a>
<a name="ln195"> </a>
<a name="ln196">DEFINE_test_flag(int32, write_rejection_percentage, 0,</a>
<a name="ln197">                 &quot;Reject specified percentage of writes.&quot;);</a>
<a name="ln198"> </a>
<a name="ln199">DEFINE_test_flag(bool, assert_reads_from_follower_rejected_because_of_staleness, false,</a>
<a name="ln200">                 &quot;If set, we verify that the consistency level is CONSISTENT_PREFIX, and that &quot;</a>
<a name="ln201">                 &quot;a follower receives the request, but that it gets rejected because it's a stale &quot;</a>
<a name="ln202">                 &quot;follower&quot;);</a>
<a name="ln203"> </a>
<a name="ln204">DEFINE_test_flag(bool, assert_reads_served_by_follower, false, &quot;If set, we verify that the &quot;</a>
<a name="ln205">                 &quot;consistency level is CONSISTENT_PREFIX, and that this server is not the leader &quot;</a>
<a name="ln206">                 &quot;for the tablet&quot;);</a>
<a name="ln207"> </a>
<a name="ln208">DEFINE_test_flag(bool, simulate_time_out_failures, false,</a>
<a name="ln209">                 &quot;If true, we will randomly mark replicas as failed to simulate time out failures.&quot;</a>
<a name="ln210">                 &quot;The periodic refresh of the lookup cache will eventually mark them as available&quot;);</a>
<a name="ln211"> </a>
<a name="ln212">DEFINE_test_flag(double, respond_write_failed_probability, 0.0,</a>
<a name="ln213">                 &quot;Probability to respond that write request is failed&quot;);</a>
<a name="ln214"> </a>
<a name="ln215">DEFINE_test_flag(bool, rpc_delete_tablet_fail, false, &quot;Should delete tablet RPC fail.&quot;);</a>
<a name="ln216"> </a>
<a name="ln217">DECLARE_bool(disable_alter_vs_write_mutual_exclusion);</a>
<a name="ln218">DECLARE_uint64(max_clock_skew_usec);</a>
<a name="ln219">DECLARE_uint64(transaction_min_running_check_interval_ms);</a>
<a name="ln220"> </a>
<a name="ln221">DEFINE_test_flag(int32, txn_status_table_tablet_creation_delay_ms, 0,</a>
<a name="ln222">                 &quot;Extra delay to slowdown creation of transaction status table tablet.&quot;);</a>
<a name="ln223"> </a>
<a name="ln224">DEFINE_test_flag(int32, leader_stepdown_delay_ms, 0,</a>
<a name="ln225">                 &quot;Amount of time to delay before starting a leader stepdown change.&quot;);</a>
<a name="ln226"> </a>
<a name="ln227">namespace yb {</a>
<a name="ln228">namespace tserver {</a>
<a name="ln229"> </a>
<a name="ln230">using consensus::ChangeConfigRequestPB;</a>
<a name="ln231">using consensus::ChangeConfigResponsePB;</a>
<a name="ln232">using consensus::CONSENSUS_CONFIG_ACTIVE;</a>
<a name="ln233">using consensus::CONSENSUS_CONFIG_COMMITTED;</a>
<a name="ln234">using consensus::Consensus;</a>
<a name="ln235">using consensus::ConsensusConfigType;</a>
<a name="ln236">using consensus::ConsensusRequestPB;</a>
<a name="ln237">using consensus::ConsensusResponsePB;</a>
<a name="ln238">using consensus::GetLastOpIdRequestPB;</a>
<a name="ln239">using consensus::GetNodeInstanceRequestPB;</a>
<a name="ln240">using consensus::GetNodeInstanceResponsePB;</a>
<a name="ln241">using consensus::LeaderStepDownRequestPB;</a>
<a name="ln242">using consensus::LeaderStepDownResponsePB;</a>
<a name="ln243">using consensus::LeaderLeaseStatus;</a>
<a name="ln244">using consensus::RunLeaderElectionRequestPB;</a>
<a name="ln245">using consensus::RunLeaderElectionResponsePB;</a>
<a name="ln246">using consensus::StartRemoteBootstrapRequestPB;</a>
<a name="ln247">using consensus::StartRemoteBootstrapResponsePB;</a>
<a name="ln248">using consensus::VoteRequestPB;</a>
<a name="ln249">using consensus::VoteResponsePB;</a>
<a name="ln250">using consensus::RaftPeerPB;</a>
<a name="ln251"> </a>
<a name="ln252">using std::unique_ptr;</a>
<a name="ln253">using google::protobuf::RepeatedPtrField;</a>
<a name="ln254">using rpc::RpcContext;</a>
<a name="ln255">using std::shared_ptr;</a>
<a name="ln256">using std::vector;</a>
<a name="ln257">using std::string;</a>
<a name="ln258">using strings::Substitute;</a>
<a name="ln259">using tablet::ChangeMetadataOperationState;</a>
<a name="ln260">using tablet::Tablet;</a>
<a name="ln261">using tablet::TabletPeer;</a>
<a name="ln262">using tablet::TabletPeerPtr;</a>
<a name="ln263">using tablet::TabletStatusPB;</a>
<a name="ln264">using tablet::TruncateOperationState;</a>
<a name="ln265">using tablet::OperationCompletionCallback;</a>
<a name="ln266">using tablet::WriteOperationState;</a>
<a name="ln267"> </a>
<a name="ln268">namespace {</a>
<a name="ln269"> </a>
<a name="ln270">template&lt;class RespClass&gt;</a>
<a name="ln271">bool GetConsensusOrRespond(const TabletPeerPtr&amp; tablet_peer,</a>
<a name="ln272">                           RespClass* resp,</a>
<a name="ln273">                           rpc::RpcContext* context,</a>
<a name="ln274">                           shared_ptr&lt;Consensus&gt;* consensus) {</a>
<a name="ln275">  *consensus = tablet_peer-&gt;shared_consensus();</a>
<a name="ln276">  if (!*consensus) {</a>
<a name="ln277">    Status s = STATUS(ServiceUnavailable, &quot;Consensus unavailable. Tablet not running&quot;);</a>
<a name="ln278">    SetupErrorAndRespond(resp-&gt;mutable_error(), s,</a>
<a name="ln279">                         TabletServerErrorPB::TABLET_NOT_RUNNING, context);</a>
<a name="ln280">    return false;</a>
<a name="ln281">  }</a>
<a name="ln282">  return true;</a>
<a name="ln283">}</a>
<a name="ln284"> </a>
<a name="ln285">Status GetTabletRef(const TabletPeerPtr&amp; tablet_peer,</a>
<a name="ln286">                    tablet::TabletPtr* tablet,</a>
<a name="ln287">                    TabletServerErrorPB::Code* error_code) {</a>
<a name="ln288">  *DCHECK_NOTNULL(tablet) = tablet_peer-&gt;shared_tablet();</a>
<a name="ln289">  if (PREDICT_FALSE(!*tablet)) {</a>
<a name="ln290">    *error_code = TabletServerErrorPB::TABLET_NOT_RUNNING;</a>
<a name="ln291">    return STATUS(IllegalState, &quot;Tablet is not running&quot;);</a>
<a name="ln292">  }</a>
<a name="ln293">  return Status::OK();</a>
<a name="ln294">}</a>
<a name="ln295"> </a>
<a name="ln296">// overlimit - we have 2 bounds, value and random score.</a>
<a name="ln297">// overlimit is calculated as:</a>
<a name="ln298">// score + (value - lower_bound) / (upper_bound - lower_bound).</a>
<a name="ln299">// And it will be &gt;= 1.0 when this function is invoked.</a>
<a name="ln300">template&lt;class Resp&gt;</a>
<a name="ln301">bool RejectWrite(tablet::TabletPeer* tablet_peer, const std::string&amp; message, double overlimit,</a>
<a name="ln302">                 Resp* resp, rpc::RpcContext* context) {</a>
<a name="ln303">  int64_t delay_ms = fit_bounds&lt;int64_t&gt;((overlimit - 1.0) * FLAGS_max_rejection_delay_ms,</a>
<a name="ln304">                                         FLAGS_min_rejection_delay_ms,</a>
<a name="ln305">                                         FLAGS_max_rejection_delay_ms);</a>
<a name="ln306">  auto status = STATUS(ServiceUnavailable, message, TabletServerDelay(delay_ms * 1ms));</a>
<a name="ln307">  YB_LOG_EVERY_N_SECS(WARNING, 1)</a>
<a name="ln308">      &lt;&lt; &quot;T &quot; &lt;&lt; tablet_peer-&gt;tablet_id() &lt;&lt; &quot; P &quot; &lt;&lt; tablet_peer-&gt;permanent_uuid()</a>
<a name="ln309">      &lt;&lt; &quot;: Rejecting Write request, &quot; &lt;&lt; status &lt;&lt; THROTTLE_MSG;</a>
<a name="ln310">  SetupErrorAndRespond(resp-&gt;mutable_error(), status,</a>
<a name="ln311">                       TabletServerErrorPB::UNKNOWN_ERROR,</a>
<a name="ln312">                       context);</a>
<a name="ln313">  return false;</a>
<a name="ln314">}</a>
<a name="ln315"> </a>
<a name="ln316">void AdjustYsqlOperationTransactionality(</a>
<a name="ln317">    size_t ysql_batch_size,</a>
<a name="ln318">    const TabletPeer* tablet_peer,</a>
<a name="ln319">    tablet::WriteOperationState* operation_state) {</a>
<a name="ln320">  // Operations on YSQL system catalog tables are always considered transactional.</a>
<a name="ln321">  if (ysql_batch_size &gt; 0 &amp;&amp; tablet_peer-&gt;tablet()-&gt;is_sys_catalog()) {</a>
<a name="ln322">    operation_state-&gt;set_force_txn_path();</a>
<a name="ln323">  }</a>
<a name="ln324">}</a>
<a name="ln325"> </a>
<a name="ln326">} // namespace</a>
<a name="ln327"> </a>
<a name="ln328">template&lt;class Resp&gt;</a>
<a name="ln329">bool TabletServiceImpl::CheckWriteThrottlingOrRespond(</a>
<a name="ln330">    double score, tablet::TabletPeer* tablet_peer, Resp* resp, rpc::RpcContext* context) {</a>
<a name="ln331">  // Check for memory pressure; don't bother doing any additional work if we've</a>
<a name="ln332">  // exceeded the limit.</a>
<a name="ln333">  auto tablet = tablet_peer-&gt;tablet();</a>
<a name="ln334">  auto soft_limit_exceeded_result = tablet-&gt;mem_tracker()-&gt;AnySoftLimitExceeded(score);</a>
<a name="ln335">  if (soft_limit_exceeded_result.exceeded) {</a>
<a name="ln336">    tablet-&gt;metrics()-&gt;leader_memory_pressure_rejections-&gt;Increment();</a>
<a name="ln337">    string msg = StringPrintf(</a>
<a name="ln338">        &quot;Soft memory limit exceeded (at %.2f%% of capacity), score: %.2f&quot;,</a>
<a name="ln339">        soft_limit_exceeded_result.current_capacity_pct, score);</a>
<a name="ln340">    if (soft_limit_exceeded_result.current_capacity_pct &gt;=</a>
<a name="ln341">            FLAGS_memory_limit_warn_threshold_percentage) {</a>
<a name="ln342">      YB_LOG_EVERY_N_SECS(WARNING, 1) &lt;&lt; &quot;Rejecting Write request: &quot; &lt;&lt; msg &lt;&lt; THROTTLE_MSG;</a>
<a name="ln343">    } else {</a>
<a name="ln344">      YB_LOG_EVERY_N_SECS(INFO, 1) &lt;&lt; &quot;Rejecting Write request: &quot; &lt;&lt; msg &lt;&lt; THROTTLE_MSG;</a>
<a name="ln345">    }</a>
<a name="ln346">    SetupErrorAndRespond(resp-&gt;mutable_error(), STATUS(ServiceUnavailable, msg),</a>
<a name="ln347">                         TabletServerErrorPB::UNKNOWN_ERROR,</a>
<a name="ln348">                         context);</a>
<a name="ln349">    return false;</a>
<a name="ln350">  }</a>
<a name="ln351"> </a>
<a name="ln352">  const uint64_t num_sst_files = tablet_peer-&gt;raft_consensus()-&gt;MajorityNumSSTFiles();</a>
<a name="ln353">  const auto sst_files_soft_limit = FLAGS_sst_files_soft_limit;</a>
<a name="ln354">  const int64_t sst_files_used_delta = num_sst_files - sst_files_soft_limit;</a>
<a name="ln355">  if (sst_files_used_delta &gt;= 0) {</a>
<a name="ln356">    const auto sst_files_hard_limit = FLAGS_sst_files_hard_limit;</a>
<a name="ln357">    const auto sst_files_full_delta = sst_files_hard_limit - sst_files_soft_limit;</a>
<a name="ln358">    if (sst_files_used_delta &gt;= sst_files_full_delta * (1 - score)) {</a>
<a name="ln359">      tablet-&gt;metrics()-&gt;majority_sst_files_rejections-&gt;Increment();</a>
<a name="ln360">      auto message = Format(&quot;SST files limit exceeded $0 against ($1, $2), score: $3&quot;,</a>
<a name="ln361">                            num_sst_files, sst_files_soft_limit, sst_files_hard_limit, score);</a>
<a name="ln362">      auto overlimit = sst_files_full_delta &gt; 0</a>
<a name="ln363">          ? score + static_cast&lt;double&gt;(sst_files_used_delta) / sst_files_full_delta</a>
<a name="ln364">          : 2.0;</a>
<a name="ln365">      return RejectWrite(tablet_peer, message, overlimit, resp, context);</a>
<a name="ln366">    }</a>
<a name="ln367">  }</a>
<a name="ln368"> </a>
<a name="ln369">  if (FLAGS_TEST_write_rejection_percentage != 0 &amp;&amp;</a>
<a name="ln370">      score &gt;= 1.0 - FLAGS_TEST_write_rejection_percentage * 0.01) {</a>
<a name="ln371">    auto status = Format(&quot;TEST: Write request rejected, desired percentage: $0, score: $1&quot;,</a>
<a name="ln372">                         FLAGS_TEST_write_rejection_percentage, score);</a>
<a name="ln373">    return RejectWrite(tablet_peer, status, score + FLAGS_TEST_write_rejection_percentage * 0.01,</a>
<a name="ln374">                       resp, context);</a>
<a name="ln375">  }</a>
<a name="ln376"> </a>
<a name="ln377">  return true;</a>
<a name="ln378">}</a>
<a name="ln379"> </a>
<a name="ln380">typedef ListTabletsResponsePB::StatusAndSchemaPB StatusAndSchemaPB;</a>
<a name="ln381"> </a>
<a name="ln382">class WriteOperationCompletionCallback : public OperationCompletionCallback {</a>
<a name="ln383"> public:</a>
<a name="ln384">  WriteOperationCompletionCallback(</a>
<a name="ln385">      tablet::TabletPeerPtr tablet_peer,</a>
<a name="ln386">      std::shared_ptr&lt;rpc::RpcContext&gt; context,</a>
<a name="ln387">      WriteResponsePB* response,</a>
<a name="ln388">      tablet::WriteOperationState* state,</a>
<a name="ln389">      const server::ClockPtr&amp; clock,</a>
<a name="ln390">      bool trace = false)</a>
<a name="ln391">      : tablet_peer_(std::move(tablet_peer)), context_(std::move(context)), response_(response),</a>
<a name="ln392">        state_(state), clock_(clock), include_trace_(trace) {}</a>
<a name="ln393"> </a>
<a name="ln394">  void OperationCompleted() override {</a>
<a name="ln395">    VLOG(1) &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; &quot;completing with status &quot; &lt;&lt; status_;</a>
<a name="ln396">    // When we don't need to return any data, we could return success on duplicate request.</a>
<a name="ln397">    if (status_.IsAlreadyPresent() &amp;&amp;</a>
<a name="ln398">        state_-&gt;ql_write_ops()-&gt;empty() &amp;&amp;</a>
<a name="ln399">        state_-&gt;pgsql_write_ops()-&gt;empty() &amp;&amp;</a>
<a name="ln400">        state_-&gt;request()-&gt;redis_write_batch().empty()) {</a>
<a name="ln401">      status_ = Status::OK();</a>
<a name="ln402">    }</a>
<a name="ln403"> </a>
<a name="ln404">    if (!status_.ok()) {</a>
<a name="ln405">      LOG(INFO) &lt;&lt; &quot;Write failed: &quot; &lt;&lt; status_;</a>
<a name="ln406">      SetupErrorAndRespond(get_error(), status_, code_, context_.get());</a>
<a name="ln407">      return;</a>
<a name="ln408">    }</a>
<a name="ln409"> </a>
<a name="ln410">    // Retrieve the rowblocks returned from the QL write operations and return them as RPC</a>
<a name="ln411">    // sidecars. Populate the row schema also.</a>
<a name="ln412">    faststring rows_data;</a>
<a name="ln413">    for (const auto&amp; ql_write_op : *state_-&gt;ql_write_ops()) {</a>
<a name="ln414">      const auto&amp; ql_write_req = ql_write_op-&gt;request();</a>
<a name="ln415">      auto* ql_write_resp = ql_write_op-&gt;response();</a>
<a name="ln416">      const QLRowBlock* rowblock = ql_write_op-&gt;rowblock();</a>
<a name="ln417">      SchemaToColumnPBs(rowblock-&gt;schema(), ql_write_resp-&gt;mutable_column_schemas());</a>
<a name="ln418">      rows_data.clear();</a>
<a name="ln419">      rowblock-&gt;Serialize(ql_write_req.client(), &amp;rows_data);</a>
<a name="ln420">      ql_write_resp-&gt;set_rows_data_sidecar(context_-&gt;AddRpcSidecar(rows_data));</a>
<a name="ln421">    }</a>
<a name="ln422"> </a>
<a name="ln423">    if (!state_-&gt;pgsql_write_ops()-&gt;empty()) {</a>
<a name="ln424">      // Retrieve the resultset returned from the PGSQL write operations and return them as RPC</a>
<a name="ln425">      // sidecars.</a>
<a name="ln426"> </a>
<a name="ln427">      size_t sidecars_size = 0;</a>
<a name="ln428">      for (const auto&amp; pgsql_write_op : *state_-&gt;pgsql_write_ops()) {</a>
<a name="ln429">        sidecars_size += pgsql_write_op-&gt;result_buffer().size();</a>
<a name="ln430">      }</a>
<a name="ln431"> </a>
<a name="ln432">      if (sidecars_size != 0) {</a>
<a name="ln433">        context_-&gt;ReserveSidecarSpace(sidecars_size);</a>
<a name="ln434">        for (const auto&amp; pgsql_write_op : *state_-&gt;pgsql_write_ops()) {</a>
<a name="ln435">          auto* pgsql_write_resp = pgsql_write_op-&gt;response();</a>
<a name="ln436">          const faststring&amp; result_buffer = pgsql_write_op-&gt;result_buffer();</a>
<a name="ln437">          if (!result_buffer.empty()) {</a>
<a name="ln438">            pgsql_write_resp-&gt;set_rows_data_sidecar(context_-&gt;AddRpcSidecar(result_buffer));</a>
<a name="ln439">          }</a>
<a name="ln440">        }</a>
<a name="ln441">      }</a>
<a name="ln442">    }</a>
<a name="ln443"> </a>
<a name="ln444">    if (include_trace_ &amp;&amp; Trace::CurrentTrace() != nullptr) {</a>
<a name="ln445">      response_-&gt;set_trace_buffer(Trace::CurrentTrace()-&gt;DumpToString(true));</a>
<a name="ln446">    }</a>
<a name="ln447">    response_-&gt;set_propagated_hybrid_time(clock_-&gt;Now().ToUint64());</a>
<a name="ln448">    context_-&gt;RespondSuccess();</a>
<a name="ln449">    VLOG(1) &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; &quot; RespondedSuccess&quot;;</a>
<a name="ln450">  }</a>
<a name="ln451"> </a>
<a name="ln452"> private:</a>
<a name="ln453"> </a>
<a name="ln454">  TabletServerErrorPB* get_error() {</a>
<a name="ln455">    return response_-&gt;mutable_error();</a>
<a name="ln456">  }</a>
<a name="ln457"> </a>
<a name="ln458">  tablet::TabletPeerPtr tablet_peer_;</a>
<a name="ln459">  const std::shared_ptr&lt;rpc::RpcContext&gt; context_;</a>
<a name="ln460">  WriteResponsePB* const response_;</a>
<a name="ln461">  tablet::WriteOperationState* const state_;</a>
<a name="ln462">  server::ClockPtr clock_;</a>
<a name="ln463">  const bool include_trace_;</a>
<a name="ln464">};</a>
<a name="ln465"> </a>
<a name="ln466">// Checksums the scan result.</a>
<a name="ln467">class ScanResultChecksummer {</a>
<a name="ln468"> public:</a>
<a name="ln469">  ScanResultChecksummer() {}</a>
<a name="ln470"> </a>
<a name="ln471">  void HandleRow(const Schema&amp; schema, const QLTableRow&amp; row) {</a>
<a name="ln472">    QLValue value;</a>
<a name="ln473">    buffer_.clear();</a>
<a name="ln474">    for (uint32_t col_index = 0; col_index != schema.num_columns(); ++col_index) {</a>
<a name="ln475">      auto status = row.GetValue(schema.column_id(col_index), &amp;value);</a>
<a name="ln476">      if (!status.ok()) {</a>
<a name="ln477">        LOG(WARNING) &lt;&lt; &quot;Column &quot; &lt;&lt; schema.column_id(col_index)</a>
<a name="ln478">                     &lt;&lt; &quot; not found in &quot; &lt;&lt; row.ToString();</a>
<a name="ln479">        continue;</a>
<a name="ln480">      }</a>
<a name="ln481">      buffer_.append(pointer_cast&lt;const char*&gt;(&amp;col_index), sizeof(col_index));</a>
<a name="ln482">      if (schema.column(col_index).is_nullable()) {</a>
<a name="ln483">        uint8_t defined = value.IsNull() ? 0 : 1;</a>
<a name="ln484">        buffer_.append(pointer_cast&lt;const char*&gt;(&amp;defined), sizeof(defined));</a>
<a name="ln485">      }</a>
<a name="ln486">      if (!value.IsNull()) {</a>
<a name="ln487">        value.value().AppendToString(&amp;buffer_);</a>
<a name="ln488">      }</a>
<a name="ln489">    }</a>
<a name="ln490">    crc_-&gt;Compute(buffer_.c_str(), buffer_.size(), &amp;agg_checksum_, nullptr);</a>
<a name="ln491">  }</a>
<a name="ln492"> </a>
<a name="ln493">  // Accessors for initializing / setting the checksum.</a>
<a name="ln494">  uint64_t agg_checksum() const { return agg_checksum_; }</a>
<a name="ln495"> </a>
<a name="ln496"> private:</a>
<a name="ln497">  crc::Crc* const crc_ = crc::GetCrc32cInstance();</a>
<a name="ln498">  uint64_t agg_checksum_ = 0;</a>
<a name="ln499">  std::string buffer_;</a>
<a name="ln500">};</a>
<a name="ln501"> </a>
<a name="ln502">TabletServiceImpl::TabletServiceImpl(TabletServerIf* server)</a>
<a name="ln503">    : TabletServerServiceIf(server-&gt;MetricEnt()),</a>
<a name="ln504">      server_(server) {</a>
<a name="ln505">}</a>
<a name="ln506"> </a>
<a name="ln507">TabletServiceAdminImpl::TabletServiceAdminImpl(TabletServer* server)</a>
<a name="ln508">    : TabletServerAdminServiceIf(server-&gt;MetricEnt()), server_(server) {}</a>
<a name="ln509"> </a>
<a name="ln510">void TabletServiceAdminImpl::BackfillDone(</a>
<a name="ln511">    const ChangeMetadataRequestPB* req, ChangeMetadataResponsePB* resp, rpc::RpcContext context) {</a>
<a name="ln512">  if (!CheckUuidMatchOrRespond(server_-&gt;tablet_manager(), &quot;BackfillDone&quot;, req, resp, &amp;context)) {</a>
<a name="ln513">    return;</a>
<a name="ln514">  }</a>
<a name="ln515">  DVLOG(3) &lt;&lt; &quot;Received BackfillDone RPC: &quot; &lt;&lt; req-&gt;DebugString();</a>
<a name="ln516"> </a>
<a name="ln517">  server::UpdateClock(*req, server_-&gt;Clock());</a>
<a name="ln518"> </a>
<a name="ln519">  // For now, we shall only allow this RPC on the leader.</a>
<a name="ln520">  auto tablet =</a>
<a name="ln521">      LookupLeaderTabletOrRespond(server_-&gt;tablet_peer_lookup(), req-&gt;tablet_id(), resp, &amp;context);</a>
<a name="ln522">  if (!tablet) {</a>
<a name="ln523">    return;</a>
<a name="ln524">  }</a>
<a name="ln525"> </a>
<a name="ln526">  auto operation_state = std::make_unique&lt;ChangeMetadataOperationState&gt;(</a>
<a name="ln527">      tablet.peer-&gt;tablet(), tablet.peer-&gt;log(), req);</a>
<a name="ln528"> </a>
<a name="ln529">  operation_state-&gt;set_completion_callback(</a>
<a name="ln530">      MakeRpcOperationCompletionCallback(std::move(context), resp, server_-&gt;Clock()));</a>
<a name="ln531"> </a>
<a name="ln532">  // Submit the alter schema op. The RPC will be responded to asynchronously.</a>
<a name="ln533">  tablet.peer-&gt;Submit(</a>
<a name="ln534">      std::make_unique&lt;tablet::ChangeMetadataOperation&gt;(std::move(operation_state)),</a>
<a name="ln535">      tablet.leader_term);</a>
<a name="ln536">}</a>
<a name="ln537"> </a>
<a name="ln538">void TabletServiceAdminImpl::GetSafeTime(</a>
<a name="ln539">    const GetSafeTimeRequestPB* req, GetSafeTimeResponsePB* resp, rpc::RpcContext context) {</a>
<a name="ln540">  if (!CheckUuidMatchOrRespond(server_-&gt;tablet_manager(), &quot;GetSafeTime&quot;, req, resp, &amp;context)) {</a>
<a name="ln541">    return;</a>
<a name="ln542">  }</a>
<a name="ln543">  DVLOG(3) &lt;&lt; &quot;Received GetSafeTime RPC: &quot; &lt;&lt; req-&gt;DebugString();</a>
<a name="ln544"> </a>
<a name="ln545">  server::UpdateClock(*req, server_-&gt;Clock());</a>
<a name="ln546"> </a>
<a name="ln547">  // For now, we shall only allow this RPC on the leader.</a>
<a name="ln548">  auto tablet =</a>
<a name="ln549">      LookupLeaderTabletOrRespond(server_-&gt;tablet_peer_lookup(), req-&gt;tablet_id(), resp, &amp;context);</a>
<a name="ln550">  if (!tablet) {</a>
<a name="ln551">    return;</a>
<a name="ln552">  }</a>
<a name="ln553">  const CoarseTimePoint&amp; deadline = context.GetClientDeadline();</a>
<a name="ln554">  HybridTime min_hybrid_time(HybridTime::kMin);</a>
<a name="ln555">  if (req-&gt;has_min_hybrid_time_for_backfill()) {</a>
<a name="ln556">    min_hybrid_time = HybridTime(req-&gt;min_hybrid_time_for_backfill());</a>
<a name="ln557">    // For Transactional tables, wait until there are no pending transactions that started</a>
<a name="ln558">    // prior to min_hybrid_time. These may not have updated the index correctly, if they</a>
<a name="ln559">    // happen to commit after the backfill scan, it is possible that they may miss updating</a>
<a name="ln560">    // the index because the some operations may have taken place prior to min_hybrid_time.</a>
<a name="ln561">    //</a>
<a name="ln562">    // For Non-Txn tables, it is impossible to know at the tservers weather or not an &quot;old</a>
<a name="ln563">    // transaction&quot; is still active. To avoid having such old transactions, we assume a</a>
<a name="ln564">    // bound on the length of such transactions (during the backfill process) and wait it</a>
<a name="ln565">    // out.</a>
<a name="ln566">    if (!tablet.peer-&gt;tablet()-&gt;transaction_participant()) {</a>
<a name="ln567">      min_hybrid_time = min_hybrid_time.AddMilliseconds(</a>
<a name="ln568">          FLAGS_index_backfill_upperbound_for_user_enforced_txn_duration_ms);</a>
<a name="ln569">      VLOG(2) &lt;&lt; &quot;GetSafeTime called on a user enforced transaction tablet &quot;</a>
<a name="ln570">              &lt;&lt; tablet.peer-&gt;tablet_id() &lt;&lt; &quot; will wait until &quot;</a>
<a name="ln571">              &lt;&lt; min_hybrid_time &lt;&lt; &quot; is safe.&quot;;</a>
<a name="ln572">    } else {</a>
<a name="ln573">      // Add some extra delay to wait for operations being replicated to be</a>
<a name="ln574">      // applied.</a>
<a name="ln575">      SleepFor(MonoDelta::FromMilliseconds(</a>
<a name="ln576">          FLAGS_index_backfill_additional_delay_before_backfilling_ms));</a>
<a name="ln577"> </a>
<a name="ln578">      auto txn_particpant = tablet.peer-&gt;tablet()-&gt;transaction_participant();</a>
<a name="ln579">      auto wait_until = CoarseMonoClock::Now() + FLAGS_index_backfill_wait_for_old_txns_ms * 1ms;</a>
<a name="ln580">      HybridTime min_running_ht;</a>
<a name="ln581">      for (;;) {</a>
<a name="ln582">        min_running_ht = txn_particpant-&gt;MinRunningHybridTime();</a>
<a name="ln583">        if ((min_running_ht &amp;&amp; min_running_ht &gt;= min_hybrid_time) ||</a>
<a name="ln584">            CoarseMonoClock::Now() &gt; wait_until) {</a>
<a name="ln585">          break;</a>
<a name="ln586">        }</a>
<a name="ln587">        VLOG(2) &lt;&lt; &quot;MinRunningHybridTime is &quot; &lt;&lt; min_running_ht</a>
<a name="ln588">                &lt;&lt; &quot; need to wait for &quot; &lt;&lt; min_hybrid_time;</a>
<a name="ln589">        SleepFor(MonoDelta::FromMilliseconds(FLAGS_transaction_min_running_check_interval_ms));</a>
<a name="ln590">      }</a>
<a name="ln591"> </a>
<a name="ln592">      VLOG(2) &lt;&lt; &quot;Finally MinRunningHybridTime is &quot; &lt;&lt; min_running_ht;</a>
<a name="ln593">      if (min_running_ht &lt; min_hybrid_time) {</a>
<a name="ln594">        VLOG(2) &lt;&lt; &quot;Aborting Txns that started prior to &quot; &lt;&lt; min_hybrid_time;</a>
<a name="ln595">        auto s = txn_particpant-&gt;StopActiveTxnsPriorTo(min_hybrid_time, deadline);</a>
<a name="ln596">        if (!s.ok()) {</a>
<a name="ln597">          SetupErrorAndRespond(</a>
<a name="ln598">              resp-&gt;mutable_error(), s, TabletServerErrorPB::UNKNOWN_ERROR, &amp;context);</a>
<a name="ln599">          return;</a>
<a name="ln600">        }</a>
<a name="ln601">      }</a>
<a name="ln602">    }</a>
<a name="ln603">  }</a>
<a name="ln604"> </a>
<a name="ln605">  HybridTime safe_time = tablet.peer-&gt;tablet()-&gt;SafeTime(</a>
<a name="ln606">      tablet::RequireLease::kTrue, min_hybrid_time, deadline);</a>
<a name="ln607">  if (!safe_time.is_valid()) {</a>
<a name="ln608">    SetupErrorAndRespond(</a>
<a name="ln609">        resp-&gt;mutable_error(),</a>
<a name="ln610">        STATUS(TimedOut, &quot;Timed out waiting for safe time.&quot;),</a>
<a name="ln611">        TabletServerErrorPB::UNKNOWN_ERROR, &amp;context);</a>
<a name="ln612">    return;</a>
<a name="ln613">  }</a>
<a name="ln614"> </a>
<a name="ln615">  resp-&gt;set_safe_time(safe_time.ToUint64());</a>
<a name="ln616">  resp-&gt;set_propagated_hybrid_time(server_-&gt;Clock()-&gt;Now().ToUint64());</a>
<a name="ln617">  VLOG(1) &lt;&lt; &quot;Tablet &quot; &lt;&lt; tablet.peer-&gt;tablet_id()</a>
<a name="ln618">          &lt;&lt; &quot;. returning SafeTime for : &quot; &lt;&lt; yb::ToString(safe_time);</a>
<a name="ln619"> </a>
<a name="ln620">  context.RespondSuccess();</a>
<a name="ln621">}</a>
<a name="ln622"> </a>
<a name="ln623">void TabletServiceAdminImpl::BackfillIndex(</a>
<a name="ln624">    const BackfillIndexRequestPB* req, BackfillIndexResponsePB* resp, rpc::RpcContext context) {</a>
<a name="ln625">  if (!CheckUuidMatchOrRespond(server_-&gt;tablet_manager(), &quot;BackfillIndex&quot;, req, resp, &amp;context)) {</a>
<a name="ln626">    return;</a>
<a name="ln627">  }</a>
<a name="ln628">  DVLOG(3) &lt;&lt; &quot;Received BackfillIndex RPC: &quot; &lt;&lt; req-&gt;DebugString();</a>
<a name="ln629"> </a>
<a name="ln630">  server::UpdateClock(*req, server_-&gt;Clock());</a>
<a name="ln631"> </a>
<a name="ln632">  // For now, we shall only allow this RPC on the leader.</a>
<a name="ln633">  auto tablet =</a>
<a name="ln634">      LookupLeaderTabletOrRespond(server_-&gt;tablet_peer_lookup(), req-&gt;tablet_id(), resp, &amp;context);</a>
<a name="ln635">  if (!tablet) {</a>
<a name="ln636">    return;</a>
<a name="ln637">  }</a>
<a name="ln638"> </a>
<a name="ln639">  DVLOG(1) &lt;&lt; &quot;Received Backfill Index RPC: &quot; &lt;&lt; req-&gt;DebugString();</a>
<a name="ln640">  const CoarseTimePoint &amp;deadline = context.GetClientDeadline();</a>
<a name="ln641">  const auto coarse_start = CoarseMonoClock::Now();</a>
<a name="ln642">  {</a>
<a name="ln643">    std::unique_lock&lt;std::mutex&gt; l(backfill_lock_);</a>
<a name="ln644">    while (num_tablets_backfilling_ &gt;= FLAGS_num_concurrent_backfills_allowed) {</a>
<a name="ln645">      if (backfill_cond_.wait_until(l, deadline) == std::cv_status::timeout) {</a>
<a name="ln646">        SetupErrorAndRespond(</a>
<a name="ln647">            resp-&gt;mutable_error(),</a>
<a name="ln648">            STATUS_SUBSTITUTE(ServiceUnavailable,</a>
<a name="ln649">                              &quot;Already running $0 backfill requests.&quot;,</a>
<a name="ln650">                              FLAGS_num_concurrent_backfills_allowed),</a>
<a name="ln651">            TabletServerErrorPB::UNKNOWN_ERROR, &amp;context);</a>
<a name="ln652">        return;</a>
<a name="ln653">      }</a>
<a name="ln654">    }</a>
<a name="ln655">    num_tablets_backfilling_++;</a>
<a name="ln656">  }</a>
<a name="ln657">  auto se = ScopeExit([this] {</a>
<a name="ln658">    std::unique_lock&lt;std::mutex&gt; l(this-&gt;backfill_lock_);</a>
<a name="ln659">    this-&gt;num_tablets_backfilling_--;</a>
<a name="ln660">    this-&gt;backfill_cond_.notify_all();</a>
<a name="ln661">  });</a>
<a name="ln662"> </a>
<a name="ln663">  // Wait for SafeTime to get past read_at;</a>
<a name="ln664">  const HybridTime read_at(req-&gt;read_at_hybrid_time());</a>
<a name="ln665">  const HybridTime safe_time = tablet.peer-&gt;tablet()-&gt;SafeTime(</a>
<a name="ln666">      tablet::RequireLease::kTrue, read_at, deadline);</a>
<a name="ln667">  if (!safe_time.is_valid()) {</a>
<a name="ln668">    SetupErrorAndRespond(</a>
<a name="ln669">        resp-&gt;mutable_error(),</a>
<a name="ln670">        STATUS_SUBSTITUTE(TimedOut,</a>
<a name="ln671">                          &quot;TimedOut waiting for safe time to get past $0&quot;,</a>
<a name="ln672">                          read_at.ToString()),</a>
<a name="ln673">        TabletServerErrorPB::UNKNOWN_ERROR, &amp;context);</a>
<a name="ln674">    return;</a>
<a name="ln675">  }</a>
<a name="ln676"> </a>
<a name="ln677">  // Don't work on the request if we have had to wait more than 50%</a>
<a name="ln678">  // of the time allocated to us for the RPC.</a>
<a name="ln679">  // Backfill is a costly operation, we do not want to start working</a>
<a name="ln680">  // on it if we expect the client (master) to time out the RPC and</a>
<a name="ln681">  // force us to redo the work.</a>
<a name="ln682">  const auto coarse_now = CoarseMonoClock::Now();</a>
<a name="ln683">  if (deadline - coarse_now &lt; coarse_now - coarse_start) {</a>
<a name="ln684">    SetupErrorAndRespond(</a>
<a name="ln685">        resp-&gt;mutable_error(),</a>
<a name="ln686">        STATUS_SUBSTITUTE(</a>
<a name="ln687">            ServiceUnavailable, &quot;Already running $0 backfill requests.&quot;,</a>
<a name="ln688">            FLAGS_num_concurrent_backfills_allowed),</a>
<a name="ln689">        TabletServerErrorPB::UNKNOWN_ERROR, &amp;context);</a>
<a name="ln690">    return;</a>
<a name="ln691">  }</a>
<a name="ln692"> </a>
<a name="ln693">  bool all_past_backfill = true;</a>
<a name="ln694">  bool all_at_backfill = true;</a>
<a name="ln695">  const shared_ptr&lt;IndexMap&gt; index_map = tablet.peer-&gt;tablet_metadata()-&gt;index_map();</a>
<a name="ln696">  std::vector&lt;IndexInfo&gt; indexes_to_backfill;</a>
<a name="ln697">  std::vector&lt;TableId&gt; index_ids;</a>
<a name="ln698">  for (const auto&amp; idx : req-&gt;indexes()) {</a>
<a name="ln699">    auto result = index_map-&gt;FindIndex(idx.table_id());</a>
<a name="ln700">    if (result) {</a>
<a name="ln701">      const IndexInfo* index_info = *result;</a>
<a name="ln702">      indexes_to_backfill.push_back(*index_info);</a>
<a name="ln703">      index_ids.push_back(index_info-&gt;table_id());</a>
<a name="ln704"> </a>
<a name="ln705">      IndexInfoPB idx_info_pb;</a>
<a name="ln706">      index_info-&gt;ToPB(&amp;idx_info_pb);</a>
<a name="ln707">      all_at_backfill &amp;=</a>
<a name="ln708">          idx_info_pb.index_permissions() == IndexPermissions::INDEX_PERM_DO_BACKFILL;</a>
<a name="ln709">      all_past_backfill &amp;=</a>
<a name="ln710">          idx_info_pb.index_permissions() &gt; IndexPermissions::INDEX_PERM_DO_BACKFILL;</a>
<a name="ln711">    } else {</a>
<a name="ln712">      all_at_backfill = false;</a>
<a name="ln713">    }</a>
<a name="ln714">  }</a>
<a name="ln715"> </a>
<a name="ln716">  if (!all_at_backfill) {</a>
<a name="ln717">    if (all_past_backfill) {</a>
<a name="ln718">      // Change this to see if for all indexes: IndexPermission &gt; DO_BACKFILL.</a>
<a name="ln719">      LOG(WARNING) &lt;&lt; &quot;Received BackfillIndex RPC: &quot; &lt;&lt; req-&gt;DebugString()</a>
<a name="ln720">                   &lt;&lt; &quot; after all indexes moved past DO_BACKFILL. IndexMap is &quot;</a>
<a name="ln721">                   &lt;&lt; ToString(index_map);</a>
<a name="ln722">      // This is possible if this tablet completed the backfill. But the master failed over before</a>
<a name="ln723">      // other tablets could complete.</a>
<a name="ln724">      // The new master is redoing the backfill. We are safe to ignore this request.</a>
<a name="ln725">      context.RespondSuccess();</a>
<a name="ln726">      return;</a>
<a name="ln727">    }</a>
<a name="ln728"> </a>
<a name="ln729">    SetupErrorAndRespond(</a>
<a name="ln730">        resp-&gt;mutable_error(),</a>
<a name="ln731">        STATUS_SUBSTITUTE(</a>
<a name="ln732">            InvalidArgument,</a>
<a name="ln733">            &quot;Tablet has a different schema $0 vs $1. &quot;</a>
<a name="ln734">            &quot;Requested index is not ready to backfill. IndexMap: $2&quot;,</a>
<a name="ln735">            tablet.peer-&gt;tablet_metadata()-&gt;schema_version(), req-&gt;schema_version(),</a>
<a name="ln736">            ToString(index_map)),</a>
<a name="ln737">        TabletServerErrorPB::MISMATCHED_SCHEMA, &amp;context);</a>
<a name="ln738">    return;</a>
<a name="ln739">  }</a>
<a name="ln740"> </a>
<a name="ln741">  Result&lt;string&gt; resume_from = STATUS(InternalError, &quot;placeholder&quot;);</a>
<a name="ln742">  if (tablet.peer-&gt;tablet()-&gt;table_type() == TableType::PGSQL_TABLE_TYPE) {</a>
<a name="ln743">    if (!req-&gt;has_namespace_name()) {</a>
<a name="ln744">      SetupErrorAndRespond(</a>
<a name="ln745">          resp-&gt;mutable_error(),</a>
<a name="ln746">          STATUS(</a>
<a name="ln747">              InvalidArgument,</a>
<a name="ln748">              &quot;Attempted backfill on YSQL table without supplying database name&quot;),</a>
<a name="ln749">          TabletServerErrorPB::OPERATION_NOT_SUPPORTED,</a>
<a name="ln750">          &amp;context);</a>
<a name="ln751">      return;</a>
<a name="ln752">    }</a>
<a name="ln753">    // TODO(jason): handle missing pgsql_proxy_bind_address (I think it is possible when disabling</a>
<a name="ln754">    // YSQL).</a>
<a name="ln755">    resume_from = tablet.peer-&gt;tablet()-&gt;BackfillIndexesForYsql(</a>
<a name="ln756">        indexes_to_backfill,</a>
<a name="ln757">        req-&gt;start_key(),</a>
<a name="ln758">        deadline,</a>
<a name="ln759">        read_at,</a>
<a name="ln760">        server_-&gt;pgsql_proxy_bind_address(),</a>
<a name="ln761">        req-&gt;namespace_name());</a>
<a name="ln762">  } else if (tablet.peer-&gt;tablet()-&gt;table_type() == TableType::YQL_TABLE_TYPE) {</a>
<a name="ln763">    resume_from = tablet.peer-&gt;tablet()-&gt;BackfillIndexes(</a>
<a name="ln764">        indexes_to_backfill, req-&gt;start_key(), deadline, read_at);</a>
<a name="ln765">  } else {</a>
<a name="ln766">    SetupErrorAndRespond(</a>
<a name="ln767">        resp-&gt;mutable_error(),</a>
<a name="ln768">        STATUS(InvalidArgument, &quot;Attempted backfill on tablet of invalid table type&quot;),</a>
<a name="ln769">        TabletServerErrorPB::OPERATION_NOT_SUPPORTED,</a>
<a name="ln770">        &amp;context);</a>
<a name="ln771">    return;</a>
<a name="ln772">  }</a>
<a name="ln773">  DVLOG(1) &lt;&lt; &quot;Tablet &quot; &lt;&lt; tablet.peer-&gt;tablet_id()</a>
<a name="ln774">           &lt;&lt; &quot;. Backfilled indexes for : &quot; &lt;&lt; yb::ToString(index_ids)</a>
<a name="ln775">           &lt;&lt; &quot; got &quot; &lt;&lt; resume_from.ToString();</a>
<a name="ln776">  if (!resume_from) {</a>
<a name="ln777">    auto s = resume_from.status();</a>
<a name="ln778">    SetupErrorAndRespond(</a>
<a name="ln779">        resp-&gt;mutable_error(), s, (s.IsIllegalState() ? TabletServerErrorPB::OPERATION_NOT_SUPPORTED</a>
<a name="ln780">                                                      : TabletServerErrorPB::UNKNOWN_ERROR),</a>
<a name="ln781">        &amp;context);</a>
<a name="ln782">    return;</a>
<a name="ln783">  }</a>
<a name="ln784"> </a>
<a name="ln785">  resp-&gt;set_backfilled_until(*resume_from);</a>
<a name="ln786">  resp-&gt;set_propagated_hybrid_time(server_-&gt;Clock()-&gt;Now().ToUint64());</a>
<a name="ln787">  context.RespondSuccess();</a>
<a name="ln788">}</a>
<a name="ln789"> </a>
<a name="ln790">void TabletServiceAdminImpl::AlterSchema(const ChangeMetadataRequestPB* req,</a>
<a name="ln791">                                         ChangeMetadataResponsePB* resp,</a>
<a name="ln792">                                         rpc::RpcContext context) {</a>
<a name="ln793">  if (!CheckUuidMatchOrRespond(server_-&gt;tablet_manager(), &quot;ChangeMetadata&quot;, req, resp, &amp;context)) {</a>
<a name="ln794">    return;</a>
<a name="ln795">  }</a>
<a name="ln796">  VLOG(1) &lt;&lt; &quot;Received Change Metadata RPC: &quot; &lt;&lt; req-&gt;DebugString();</a>
<a name="ln797"> </a>
<a name="ln798">  server::UpdateClock(*req, server_-&gt;Clock());</a>
<a name="ln799"> </a>
<a name="ln800">  auto tablet = LookupLeaderTabletOrRespond(</a>
<a name="ln801">      server_-&gt;tablet_peer_lookup(), req-&gt;tablet_id(), resp, &amp;context);</a>
<a name="ln802">  if (!tablet) {</a>
<a name="ln803">    return;</a>
<a name="ln804">  }</a>
<a name="ln805"> </a>
<a name="ln806">  tablet::TableInfoPtr table_info;</a>
<a name="ln807">  if (req-&gt;has_alter_table_id()) {</a>
<a name="ln808">    auto result = tablet.peer-&gt;tablet_metadata()-&gt;GetTableInfo(req-&gt;alter_table_id());</a>
<a name="ln809">    if (!result.ok()) {</a>
<a name="ln810">      SetupErrorAndRespond(resp-&gt;mutable_error(), result.status(),</a>
<a name="ln811">                           TabletServerErrorPB::INVALID_SCHEMA, &amp;context);</a>
<a name="ln812">      return;</a>
<a name="ln813">    }</a>
<a name="ln814">    table_info = *result;</a>
<a name="ln815">  } else {</a>
<a name="ln816">    table_info = tablet.peer-&gt;tablet_metadata()-&gt;primary_table_info();</a>
<a name="ln817">  }</a>
<a name="ln818">  const Schema&amp; tablet_schema = table_info-&gt;schema;</a>
<a name="ln819">  uint32_t schema_version = table_info-&gt;schema_version;</a>
<a name="ln820">  // Sanity check, to verify that the tablet should have the same schema</a>
<a name="ln821">  // specified in the request.</a>
<a name="ln822">  Schema req_schema;</a>
<a name="ln823">  Status s = SchemaFromPB(req-&gt;schema(), &amp;req_schema);</a>
<a name="ln824">  if (!s.ok()) {</a>
<a name="ln825">    SetupErrorAndRespond(resp-&gt;mutable_error(), s, TabletServerErrorPB::INVALID_SCHEMA, &amp;context);</a>
<a name="ln826">    return;</a>
<a name="ln827">  }</a>
<a name="ln828"> </a>
<a name="ln829">  // If the schema was already applied, respond as succeeded.</a>
<a name="ln830">  if (!req-&gt;has_wal_retention_secs() &amp;&amp; schema_version == req-&gt;schema_version()) {</a>
<a name="ln831"> </a>
<a name="ln832">    if (req_schema.Equals(tablet_schema)) {</a>
<a name="ln833">      context.RespondSuccess();</a>
<a name="ln834">      return;</a>
<a name="ln835">    }</a>
<a name="ln836"> </a>
<a name="ln837">    schema_version = tablet.peer-&gt;tablet_metadata()-&gt;schema_version(</a>
<a name="ln838">        req-&gt;has_alter_table_id() ? req-&gt;alter_table_id() : &quot;&quot;);</a>
<a name="ln839">    if (schema_version == req-&gt;schema_version()) {</a>
<a name="ln840">      LOG(ERROR) &lt;&lt; &quot;The current schema does not match the request schema.&quot;</a>
<a name="ln841">                 &lt;&lt; &quot; version=&quot; &lt;&lt; schema_version</a>
<a name="ln842">                 &lt;&lt; &quot; current-schema=&quot; &lt;&lt; tablet_schema.ToString()</a>
<a name="ln843">                 &lt;&lt; &quot; request-schema=&quot; &lt;&lt; req_schema.ToString()</a>
<a name="ln844">                 &lt;&lt; &quot; (corruption)&quot;;</a>
<a name="ln845">      SetupErrorAndRespond(resp-&gt;mutable_error(),</a>
<a name="ln846">                           STATUS(Corruption, &quot;got a different schema for the same version number&quot;),</a>
<a name="ln847">                           TabletServerErrorPB::MISMATCHED_SCHEMA, &amp;context);</a>
<a name="ln848">      return;</a>
<a name="ln849">    }</a>
<a name="ln850">  }</a>
<a name="ln851"> </a>
<a name="ln852">  // If the current schema is newer than the one in the request reject the request.</a>
<a name="ln853">  if (schema_version &gt; req-&gt;schema_version()) {</a>
<a name="ln854">    LOG(ERROR) &lt;&lt; &quot;Tablet &quot; &lt;&lt; req-&gt;tablet_id() &lt;&lt; &quot; has a newer schema &quot;</a>
<a name="ln855">               &lt;&lt; &quot; version=&quot; &lt;&lt; schema_version</a>
<a name="ln856">               &lt;&lt; &quot; req-&gt;schema_version()=&quot; &lt;&lt; req-&gt;schema_version()</a>
<a name="ln857">               &lt;&lt; &quot;\n current-schema=&quot; &lt;&lt; tablet_schema.ToString()</a>
<a name="ln858">               &lt;&lt; &quot;\n request-schema=&quot; &lt;&lt; req_schema.ToString() &lt;&lt; &quot; (wtf?)&quot;;</a>
<a name="ln859">    SetupErrorAndRespond(</a>
<a name="ln860">        resp-&gt;mutable_error(),</a>
<a name="ln861">        STATUS_SUBSTITUTE(</a>
<a name="ln862">            InvalidArgument, &quot;Tablet has a newer schema Tab $0. Req $1 vs Existing version : $2&quot;,</a>
<a name="ln863">            req-&gt;tablet_id(), req-&gt;DebugString(), schema_version),</a>
<a name="ln864">        TabletServerErrorPB::TABLET_HAS_A_NEWER_SCHEMA, &amp;context);</a>
<a name="ln865">    return;</a>
<a name="ln866">  }</a>
<a name="ln867"> </a>
<a name="ln868">  VLOG(1) &lt;&lt; &quot;Tablet updating schema from &quot;</a>
<a name="ln869">          &lt;&lt; &quot; version=&quot; &lt;&lt; schema_version &lt;&lt; &quot; current-schema=&quot; &lt;&lt; tablet_schema.ToString()</a>
<a name="ln870">          &lt;&lt; &quot; to request-schema=&quot; &lt;&lt; req_schema.ToString()</a>
<a name="ln871">          &lt;&lt; &quot; for table ID=&quot; &lt;&lt; table_info-&gt;table_id;</a>
<a name="ln872">  ScopedRWOperationPause pause_writes;</a>
<a name="ln873">  if (tablet.peer-&gt;tablet()-&gt;table_type() == TableType::YQL_TABLE_TYPE &amp;&amp;</a>
<a name="ln874">      !GetAtomicFlag(&amp;FLAGS_disable_alter_vs_write_mutual_exclusion)) {</a>
<a name="ln875">    // For schema change operations we will have to pause the write operations</a>
<a name="ln876">    // until the schema change is done. This will be done synchronously.</a>
<a name="ln877">    pause_writes = tablet.peer-&gt;tablet()-&gt;PauseWritePermits(context.GetClientDeadline());</a>
<a name="ln878">    if (!pause_writes.ok()) {</a>
<a name="ln879">      SetupErrorAndRespond(</a>
<a name="ln880">          resp-&gt;mutable_error(),</a>
<a name="ln881">          STATUS_SUBSTITUTE(</a>
<a name="ln882">              TryAgain, &quot;Could not lock the tablet against write operations for schema change&quot;),</a>
<a name="ln883">          TabletServerErrorPB::UNKNOWN_ERROR, &amp;context);</a>
<a name="ln884">      return;</a>
<a name="ln885">    }</a>
<a name="ln886">  }</a>
<a name="ln887">  auto operation_state = std::make_unique&lt;ChangeMetadataOperationState&gt;(</a>
<a name="ln888">      tablet.peer-&gt;tablet(), tablet.peer-&gt;log(), req);</a>
<a name="ln889"> </a>
<a name="ln890">  operation_state-&gt;set_completion_callback(</a>
<a name="ln891">      MakeRpcOperationCompletionCallback(std::move(context), resp, server_-&gt;Clock()));</a>
<a name="ln892">  operation_state-&gt;UsePermitToken(std::move(pause_writes));</a>
<a name="ln893"> </a>
<a name="ln894">  // Submit the alter schema op. The RPC will be responded to asynchronously.</a>
<a name="ln895">  tablet.peer-&gt;Submit(</a>
<a name="ln896">      std::make_unique&lt;tablet::ChangeMetadataOperation&gt;(std::move(operation_state)),</a>
<a name="ln897">      tablet.leader_term);</a>
<a name="ln898">}</a>
<a name="ln899"> </a>
<a name="ln900">#define VERIFY_RESULT_OR_RETURN(expr) \</a>
<a name="ln901">  __extension__ ({ \</a>
<a name="ln902">    auto&amp;&amp; __result = (expr); \</a>
<a name="ln903">    if (!__result.ok()) { return; } \</a>
<a name="ln904">    std::move(*__result); \</a>
<a name="ln905">  })</a>
<a name="ln906"> </a>
<a name="ln907">void TabletServiceImpl::UpdateTransaction(const UpdateTransactionRequestPB* req,</a>
<a name="ln908">                                          UpdateTransactionResponsePB* resp,</a>
<a name="ln909">                                          rpc::RpcContext context) {</a>
<a name="ln910">  TRACE(&quot;UpdateTransaction&quot;);</a>
<a name="ln911"> </a>
<a name="ln912">  VLOG(1) &lt;&lt; &quot;UpdateTransaction: &quot; &lt;&lt; req-&gt;ShortDebugString()</a>
<a name="ln913">          &lt;&lt; &quot;, context: &quot; &lt;&lt; context.ToString();</a>
<a name="ln914">  UpdateClock(*req, server_-&gt;Clock());</a>
<a name="ln915"> </a>
<a name="ln916">  LeaderTabletPeer tablet;</a>
<a name="ln917">  if (req-&gt;state().status() != CLEANUP) {</a>
<a name="ln918">    tablet = LookupLeaderTabletOrRespond(</a>
<a name="ln919">        server_-&gt;tablet_peer_lookup(), req-&gt;tablet_id(), resp, &amp;context);</a>
<a name="ln920">  } else {</a>
<a name="ln921">    tablet.peer = VERIFY_RESULT_OR_RETURN(LookupTabletPeerOrRespond(</a>
<a name="ln922">        server_-&gt;tablet_peer_lookup(), req-&gt;tablet_id(), resp, &amp;context));</a>
<a name="ln923">    tablet.leader_term = OpId::kUnknownTerm;</a>
<a name="ln924">  }</a>
<a name="ln925">  if (!tablet) {</a>
<a name="ln926">    return;</a>
<a name="ln927">  }</a>
<a name="ln928"> </a>
<a name="ln929">  auto state = std::make_unique&lt;tablet::UpdateTxnOperationState&gt;(tablet.peer-&gt;tablet(),</a>
<a name="ln930">                                                                 &amp;req-&gt;state());</a>
<a name="ln931">  state-&gt;set_completion_callback(MakeRpcOperationCompletionCallback(</a>
<a name="ln932">      std::move(context), resp, server_-&gt;Clock()));</a>
<a name="ln933"> </a>
<a name="ln934">  if (req-&gt;state().status() == TransactionStatus::APPLYING ||</a>
<a name="ln935">      req-&gt;state().status() == TransactionStatus::CLEANUP) {</a>
<a name="ln936">    tablet.peer-&gt;tablet()-&gt;transaction_participant()-&gt;Handle(std::move(state), tablet.leader_term);</a>
<a name="ln937">  } else {</a>
<a name="ln938">    tablet.peer-&gt;tablet()-&gt;transaction_coordinator()-&gt;Handle(std::move(state), tablet.leader_term);</a>
<a name="ln939">  }</a>
<a name="ln940">}</a>
<a name="ln941"> </a>
<a name="ln942">template &lt;class Req, class Resp, class Action&gt;</a>
<a name="ln943">void TabletServiceImpl::PerformAtLeader(</a>
<a name="ln944">    const Req&amp; req, Resp* resp, rpc::RpcContext* context, const Action&amp; action) {</a>
<a name="ln945">  UpdateClock(*req, server_-&gt;Clock());</a>
<a name="ln946"> </a>
<a name="ln947">  auto tablet_peer = LookupLeaderTabletOrRespond(</a>
<a name="ln948">      server_-&gt;tablet_peer_lookup(), req-&gt;tablet_id(), resp, context);</a>
<a name="ln949"> </a>
<a name="ln950">  if (!tablet_peer) {</a>
<a name="ln951">    return;</a>
<a name="ln952">  }</a>
<a name="ln953"> </a>
<a name="ln954">  auto status = action(tablet_peer);</a>
<a name="ln955"> </a>
<a name="ln956">  if (*context) {</a>
<a name="ln957">    resp-&gt;set_propagated_hybrid_time(server_-&gt;Clock()-&gt;Now().ToUint64());</a>
<a name="ln958">    if (status.ok()) {</a>
<a name="ln959">      context-&gt;RespondSuccess();</a>
<a name="ln960">    } else {</a>
<a name="ln961">      SetupErrorAndRespond(</a>
<a name="ln962">          resp-&gt;mutable_error(), status, TabletServerErrorPB::UNKNOWN_ERROR, context);</a>
<a name="ln963">    }</a>
<a name="ln964">  }</a>
<a name="ln965">}</a>
<a name="ln966"> </a>
<a name="ln967">void TabletServiceImpl::GetTransactionStatus(const GetTransactionStatusRequestPB* req,</a>
<a name="ln968">                                             GetTransactionStatusResponsePB* resp,</a>
<a name="ln969">                                             rpc::RpcContext context) {</a>
<a name="ln970">  TRACE(&quot;GetTransactionStatus&quot;);</a>
<a name="ln971"> </a>
<a name="ln972">  PerformAtLeader(req, resp, &amp;context,</a>
<a name="ln973">      [req, resp, &amp;context](const LeaderTabletPeer&amp; tablet_peer) {</a>
<a name="ln974">    auto* transaction_coordinator = tablet_peer.peer-&gt;tablet()-&gt;transaction_coordinator();</a>
<a name="ln975">    if (!transaction_coordinator) {</a>
<a name="ln976">      return STATUS_FORMAT(</a>
<a name="ln977">          InvalidArgument, &quot;No transaction coordinator at tablet $0&quot;,</a>
<a name="ln978">          tablet_peer.peer-&gt;tablet_id());</a>
<a name="ln979">    }</a>
<a name="ln980">    return transaction_coordinator-&gt;GetStatus(</a>
<a name="ln981">        req-&gt;transaction_id(), context.GetClientDeadline(), resp);</a>
<a name="ln982">  });</a>
<a name="ln983">}</a>
<a name="ln984"> </a>
<a name="ln985">void TabletServiceImpl::GetTransactionStatusAtParticipant(</a>
<a name="ln986">    const GetTransactionStatusAtParticipantRequestPB* req,</a>
<a name="ln987">    GetTransactionStatusAtParticipantResponsePB* resp,</a>
<a name="ln988">    rpc::RpcContext context) {</a>
<a name="ln989">  TRACE(&quot;GetTransactionStatusAtParticipant&quot;);</a>
<a name="ln990"> </a>
<a name="ln991">  PerformAtLeader(req, resp, &amp;context,</a>
<a name="ln992">      [req, resp, &amp;context](const LeaderTabletPeer&amp; tablet_peer) -&gt; Status {</a>
<a name="ln993">    auto* transaction_participant = tablet_peer.peer-&gt;tablet()-&gt;transaction_participant();</a>
<a name="ln994">    if (!transaction_participant) {</a>
<a name="ln995">      return STATUS_FORMAT(</a>
<a name="ln996">          InvalidArgument, &quot;No transaction participant at tablet $0&quot;,</a>
<a name="ln997">          tablet_peer.peer-&gt;tablet_id());</a>
<a name="ln998">    }</a>
<a name="ln999"> </a>
<a name="ln1000">    transaction_participant-&gt;GetStatus(</a>
<a name="ln1001">        VERIFY_RESULT(FullyDecodeTransactionId(req-&gt;transaction_id())),</a>
<a name="ln1002">        req-&gt;required_num_replicated_batches(), tablet_peer.leader_term, resp, &amp;context);</a>
<a name="ln1003">    return Status::OK();</a>
<a name="ln1004">  });</a>
<a name="ln1005">}</a>
<a name="ln1006"> </a>
<a name="ln1007">void TabletServiceImpl::AbortTransaction(const AbortTransactionRequestPB* req,</a>
<a name="ln1008">                                         AbortTransactionResponsePB* resp,</a>
<a name="ln1009">                                         rpc::RpcContext context) {</a>
<a name="ln1010">  TRACE(&quot;AbortTransaction&quot;);</a>
<a name="ln1011"> </a>
<a name="ln1012">  UpdateClock(*req, server_-&gt;Clock());</a>
<a name="ln1013"> </a>
<a name="ln1014">  auto tablet = LookupLeaderTabletOrRespond(</a>
<a name="ln1015">      server_-&gt;tablet_peer_lookup(), req-&gt;tablet_id(), resp, &amp;context);</a>
<a name="ln1016">  if (!tablet) {</a>
<a name="ln1017">    return;</a>
<a name="ln1018">  }</a>
<a name="ln1019"> </a>
<a name="ln1020">  server::ClockPtr clock(server_-&gt;Clock());</a>
<a name="ln1021">  auto context_ptr = std::make_shared&lt;rpc::RpcContext&gt;(std::move(context));</a>
<a name="ln1022">  tablet.peer-&gt;tablet()-&gt;transaction_coordinator()-&gt;Abort(</a>
<a name="ln1023">      req-&gt;transaction_id(),</a>
<a name="ln1024">      tablet.leader_term,</a>
<a name="ln1025">      [resp, context_ptr, clock](Result&lt;TransactionStatusResult&gt; result) {</a>
<a name="ln1026">        resp-&gt;set_propagated_hybrid_time(clock-&gt;Now().ToUint64());</a>
<a name="ln1027">        if (result.ok()) {</a>
<a name="ln1028">          resp-&gt;set_status(result-&gt;status);</a>
<a name="ln1029">          if (result-&gt;status_time.is_valid()) {</a>
<a name="ln1030">            resp-&gt;set_status_hybrid_time(result-&gt;status_time.ToUint64());</a>
<a name="ln1031">          }</a>
<a name="ln1032">          context_ptr-&gt;RespondSuccess();</a>
<a name="ln1033">        } else {</a>
<a name="ln1034">          SetupErrorAndRespond(resp-&gt;mutable_error(),</a>
<a name="ln1035">                               result.status(),</a>
<a name="ln1036">                               TabletServerErrorPB::UNKNOWN_ERROR,</a>
<a name="ln1037">                               context_ptr.get());</a>
<a name="ln1038">        }</a>
<a name="ln1039">      });</a>
<a name="ln1040">}</a>
<a name="ln1041"> </a>
<a name="ln1042">void TabletServiceImpl::Truncate(const TruncateRequestPB* req,</a>
<a name="ln1043">                                 TruncateResponsePB* resp,</a>
<a name="ln1044">                                 rpc::RpcContext context) {</a>
<a name="ln1045">  TRACE(&quot;Truncate&quot;);</a>
<a name="ln1046"> </a>
<a name="ln1047">  UpdateClock(*req, server_-&gt;Clock());</a>
<a name="ln1048"> </a>
<a name="ln1049">  auto tablet = LookupLeaderTabletOrRespond(</a>
<a name="ln1050">      server_-&gt;tablet_peer_lookup(), req-&gt;tablet_id(), resp, &amp;context);</a>
<a name="ln1051">  if (!tablet) {</a>
<a name="ln1052">    return;</a>
<a name="ln1053">  }</a>
<a name="ln1054"> </a>
<a name="ln1055">  auto tx_state = std::make_unique&lt;TruncateOperationState&gt;(tablet.peer-&gt;tablet(), req);</a>
<a name="ln1056"> </a>
<a name="ln1057">  tx_state-&gt;set_completion_callback(</a>
<a name="ln1058">      MakeRpcOperationCompletionCallback(std::move(context), resp, server_-&gt;Clock()));</a>
<a name="ln1059"> </a>
<a name="ln1060">  // Submit the truncate tablet op. The RPC will be responded to asynchronously.</a>
<a name="ln1061">  tablet.peer-&gt;Submit(</a>
<a name="ln1062">      std::make_unique&lt;tablet::TruncateOperation&gt;(std::move(tx_state)), tablet.leader_term);</a>
<a name="ln1063">}</a>
<a name="ln1064"> </a>
<a name="ln1065">void TabletServiceAdminImpl::CreateTablet(const CreateTabletRequestPB* req,</a>
<a name="ln1066">                                          CreateTabletResponsePB* resp,</a>
<a name="ln1067">                                          rpc::RpcContext context) {</a>
<a name="ln1068">  if (PREDICT_FALSE(FLAGS_TEST_txn_status_table_tablet_creation_delay_ms &gt; 0 &amp;&amp;</a>
<a name="ln1069">                    req-&gt;table_type() == TableType::TRANSACTION_STATUS_TABLE_TYPE)) {</a>
<a name="ln1070">    std::this_thread::sleep_for(FLAGS_TEST_txn_status_table_tablet_creation_delay_ms * 1ms);</a>
<a name="ln1071">  }</a>
<a name="ln1072"> </a>
<a name="ln1073">  if (!CheckUuidMatchOrRespond(server_-&gt;tablet_manager(), &quot;CreateTablet&quot;, req, resp, &amp;context)) {</a>
<a name="ln1074">    return;</a>
<a name="ln1075">  }</a>
<a name="ln1076">  DVLOG(3) &lt;&lt; &quot;Received CreateTablet RPC: &quot; &lt;&lt; yb::ToString(*req);</a>
<a name="ln1077">  TRACE_EVENT1(&quot;tserver&quot;, &quot;CreateTablet&quot;,</a>
<a name="ln1078">               &quot;tablet_id&quot;, req-&gt;tablet_id());</a>
<a name="ln1079"> </a>
<a name="ln1080">  Schema schema;</a>
<a name="ln1081">  Status s = SchemaFromPB(req-&gt;schema(), &amp;schema);</a>
<a name="ln1082">  DCHECK(schema.has_column_ids());</a>
<a name="ln1083">  if (!s.ok()) {</a>
<a name="ln1084">    SetupErrorAndRespond(resp-&gt;mutable_error(),</a>
<a name="ln1085">                         STATUS(InvalidArgument, &quot;Invalid Schema.&quot;),</a>
<a name="ln1086">                         TabletServerErrorPB::INVALID_SCHEMA, &amp;context);</a>
<a name="ln1087">    return;</a>
<a name="ln1088">  }</a>
<a name="ln1089"> </a>
<a name="ln1090">  PartitionSchema partition_schema;</a>
<a name="ln1091">  s = PartitionSchema::FromPB(req-&gt;partition_schema(), schema, &amp;partition_schema);</a>
<a name="ln1092">  if (!s.ok()) {</a>
<a name="ln1093">    SetupErrorAndRespond(resp-&gt;mutable_error(),</a>
<a name="ln1094">                         STATUS(InvalidArgument, &quot;Invalid PartitionSchema.&quot;),</a>
<a name="ln1095">                         TabletServerErrorPB::INVALID_SCHEMA, &amp;context);</a>
<a name="ln1096">    return;</a>
<a name="ln1097">  }</a>
<a name="ln1098"> </a>
<a name="ln1099">  Partition partition;</a>
<a name="ln1100">  Partition::FromPB(req-&gt;partition(), &amp;partition);</a>
<a name="ln1101"> </a>
<a name="ln1102">  LOG(INFO) &lt;&lt; &quot;Processing CreateTablet for tablet &quot; &lt;&lt; req-&gt;tablet_id()</a>
<a name="ln1103">            &lt;&lt; &quot; (table=&quot; &lt;&lt; req-&gt;table_name()</a>
<a name="ln1104">            &lt;&lt; &quot; [id=&quot; &lt;&lt; req-&gt;table_id() &lt;&lt; &quot;]), partition=&quot;</a>
<a name="ln1105">            &lt;&lt; partition_schema.PartitionDebugString(partition, schema);</a>
<a name="ln1106">  VLOG(1) &lt;&lt; &quot;Full request: &quot; &lt;&lt; req-&gt;DebugString();</a>
<a name="ln1107"> </a>
<a name="ln1108">  s = server_-&gt;tablet_manager()-&gt;CreateNewTablet(</a>
<a name="ln1109">      req-&gt;table_id(), req-&gt;tablet_id(), partition, req-&gt;namespace_name(), req-&gt;table_name(),</a>
<a name="ln1110">      req-&gt;table_type(), schema, partition_schema,</a>
<a name="ln1111">      req-&gt;has_index_info() ? boost::optional&lt;IndexInfo&gt;(req-&gt;index_info()) : boost::none,</a>
<a name="ln1112">      req-&gt;config(), /* tablet_peer */ nullptr, req-&gt;colocated());</a>
<a name="ln1113">  if (PREDICT_FALSE(!s.ok())) {</a>
<a name="ln1114">    TabletServerErrorPB::Code code;</a>
<a name="ln1115">    if (s.IsAlreadyPresent()) {</a>
<a name="ln1116">      code = TabletServerErrorPB::TABLET_ALREADY_EXISTS;</a>
<a name="ln1117">    } else {</a>
<a name="ln1118">      code = TabletServerErrorPB::UNKNOWN_ERROR;</a>
<a name="ln1119">    }</a>
<a name="ln1120">    SetupErrorAndRespond(resp-&gt;mutable_error(), s, code, &amp;context);</a>
<a name="ln1121">    return;</a>
<a name="ln1122">  }</a>
<a name="ln1123">  context.RespondSuccess();</a>
<a name="ln1124">}</a>
<a name="ln1125"> </a>
<a name="ln1126">void TabletServiceAdminImpl::DeleteTablet(const DeleteTabletRequestPB* req,</a>
<a name="ln1127">                                          DeleteTabletResponsePB* resp,</a>
<a name="ln1128">                                          rpc::RpcContext context) {</a>
<a name="ln1129">  if (PREDICT_FALSE(FLAGS_TEST_rpc_delete_tablet_fail)) {</a>
<a name="ln1130">    context.RespondFailure(STATUS(NetworkError, &quot;Simulating network partition for test&quot;));</a>
<a name="ln1131">    return;</a>
<a name="ln1132">  }</a>
<a name="ln1133"> </a>
<a name="ln1134">  if (!CheckUuidMatchOrRespond(server_-&gt;tablet_manager(), &quot;DeleteTablet&quot;, req, resp, &amp;context)) {</a>
<a name="ln1135">    return;</a>
<a name="ln1136">  }</a>
<a name="ln1137">  TRACE_EVENT2(&quot;tserver&quot;, &quot;DeleteTablet&quot;,</a>
<a name="ln1138">               &quot;tablet_id&quot;, req-&gt;tablet_id(),</a>
<a name="ln1139">               &quot;reason&quot;, req-&gt;reason());</a>
<a name="ln1140"> </a>
<a name="ln1141">  tablet::TabletDataState delete_type = tablet::TABLET_DATA_UNKNOWN;</a>
<a name="ln1142">  if (req-&gt;has_delete_type()) {</a>
<a name="ln1143">    delete_type = req-&gt;delete_type();</a>
<a name="ln1144">  }</a>
<a name="ln1145">  LOG(INFO) &lt;&lt; &quot;T &quot; &lt;&lt; req-&gt;tablet_id() &lt;&lt; &quot; P &quot; &lt;&lt; server_-&gt;permanent_uuid()</a>
<a name="ln1146">            &lt;&lt; &quot;: Processing DeleteTablet with delete_type &quot; &lt;&lt; TabletDataState_Name(delete_type)</a>
<a name="ln1147">            &lt;&lt; (req-&gt;has_reason() ? (&quot; (&quot; + req-&gt;reason() + &quot;)&quot;) : &quot;&quot;)</a>
<a name="ln1148">            &lt;&lt; &quot; from &quot; &lt;&lt; context.requestor_string();</a>
<a name="ln1149">  VLOG(1) &lt;&lt; &quot;Full request: &quot; &lt;&lt; req-&gt;DebugString();</a>
<a name="ln1150"> </a>
<a name="ln1151">  boost::optional&lt;int64_t&gt; cas_config_opid_index_less_or_equal;</a>
<a name="ln1152">  if (req-&gt;has_cas_config_opid_index_less_or_equal()) {</a>
<a name="ln1153">    cas_config_opid_index_less_or_equal = req-&gt;cas_config_opid_index_less_or_equal();</a>
<a name="ln1154">  }</a>
<a name="ln1155">  boost::optional&lt;TabletServerErrorPB::Code&gt; error_code;</a>
<a name="ln1156">  Status s = server_-&gt;tablet_manager()-&gt;DeleteTablet(req-&gt;tablet_id(),</a>
<a name="ln1157">                                                     delete_type,</a>
<a name="ln1158">                                                     cas_config_opid_index_less_or_equal,</a>
<a name="ln1159">                                                     &amp;error_code);</a>
<a name="ln1160">  if (PREDICT_FALSE(!s.ok())) {</a>
<a name="ln1161">    HandleErrorResponse(resp, &amp;context, s, error_code);</a>
<a name="ln1162">    return;</a>
<a name="ln1163">  }</a>
<a name="ln1164">  context.RespondSuccess();</a>
<a name="ln1165">}</a>
<a name="ln1166"> </a>
<a name="ln1167">// TODO(sagnik): Modify this to actually create a copartitioned table</a>
<a name="ln1168">void TabletServiceAdminImpl::CopartitionTable(const CopartitionTableRequestPB* req,</a>
<a name="ln1169">                                              CopartitionTableResponsePB* resp,</a>
<a name="ln1170">                                              rpc::RpcContext context) {</a>
<a name="ln1171">  context.RespondSuccess();</a>
<a name="ln1172">  LOG(INFO) &lt;&lt; &quot;tserver doesn't support co-partitioning yet&quot;;</a>
<a name="ln1173">}</a>
<a name="ln1174"> </a>
<a name="ln1175">void TabletServiceAdminImpl::FlushTablets(const FlushTabletsRequestPB* req,</a>
<a name="ln1176">                                          FlushTabletsResponsePB* resp,</a>
<a name="ln1177">                                          rpc::RpcContext context) {</a>
<a name="ln1178">  if (!CheckUuidMatchOrRespond(server_-&gt;tablet_manager(), &quot;FlushTablets&quot;, req, resp, &amp;context)) {</a>
<a name="ln1179">    return;</a>
<a name="ln1180">  }</a>
<a name="ln1181"> </a>
<a name="ln1182">  if (!req-&gt;all_tablets() &amp;&amp; req-&gt;tablet_ids_size() == 0) {</a>
<a name="ln1183">    const Status s = STATUS(InvalidArgument, &quot;No tablet ids&quot;);</a>
<a name="ln1184">    SetupErrorAndRespond(</a>
<a name="ln1185">        resp-&gt;mutable_error(), s, TabletServerErrorPB_Code_UNKNOWN_ERROR, &amp;context);</a>
<a name="ln1186">    return;</a>
<a name="ln1187">  }</a>
<a name="ln1188"> </a>
<a name="ln1189">  server::UpdateClock(*req, server_-&gt;Clock());</a>
<a name="ln1190"> </a>
<a name="ln1191">  TRACE_EVENT1(&quot;tserver&quot;, &quot;FlushTablets&quot;,</a>
<a name="ln1192">               &quot;TS: &quot;, req-&gt;dest_uuid());</a>
<a name="ln1193"> </a>
<a name="ln1194">  LOG(INFO) &lt;&lt; &quot;Processing FlushTablets from &quot; &lt;&lt; context.requestor_string();</a>
<a name="ln1195">  VLOG(1) &lt;&lt; &quot;Full FlushTablets request: &quot; &lt;&lt; req-&gt;DebugString();</a>
<a name="ln1196">  TabletPeers tablet_peers;</a>
<a name="ln1197"> </a>
<a name="ln1198">  if (req-&gt;all_tablets()) {</a>
<a name="ln1199">    server_-&gt;tablet_manager()-&gt;GetTabletPeers(&amp;tablet_peers);</a>
<a name="ln1200">  } else {</a>
<a name="ln1201">    for (const TabletId&amp; id : req-&gt;tablet_ids()) {</a>
<a name="ln1202">      auto tablet_peer = VERIFY_RESULT_OR_RETURN(LookupTabletPeerOrRespond(</a>
<a name="ln1203">          server_-&gt;tablet_peer_lookup(), id, resp, &amp;context));</a>
<a name="ln1204">      tablet_peers.push_back(tablet_peer);</a>
<a name="ln1205">    }</a>
<a name="ln1206">  }</a>
<a name="ln1207">  for (const TabletPeerPtr&amp; tablet_peer : tablet_peers) {</a>
<a name="ln1208">    resp-&gt;set_failed_tablet_id(tablet_peer-&gt;tablet()-&gt;tablet_id());</a>
<a name="ln1209">    auto tablet = tablet_peer-&gt;tablet();</a>
<a name="ln1210">    if (req-&gt;is_compaction()) {</a>
<a name="ln1211">      tablet-&gt;ForceRocksDBCompactInTest();</a>
<a name="ln1212">    } else {</a>
<a name="ln1213">      RETURN_UNKNOWN_ERROR_IF_NOT_OK(tablet-&gt;Flush(tablet::FlushMode::kAsync), resp, &amp;context);</a>
<a name="ln1214">    }</a>
<a name="ln1215">    resp-&gt;clear_failed_tablet_id();</a>
<a name="ln1216">  }</a>
<a name="ln1217"> </a>
<a name="ln1218">  // Wait for end of all flush operations.</a>
<a name="ln1219">  for (const TabletPeerPtr&amp; tablet_peer : tablet_peers) {</a>
<a name="ln1220">    resp-&gt;set_failed_tablet_id(tablet_peer-&gt;tablet()-&gt;tablet_id());</a>
<a name="ln1221">    RETURN_UNKNOWN_ERROR_IF_NOT_OK(tablet_peer-&gt;tablet()-&gt;WaitForFlush(), resp, &amp;context);</a>
<a name="ln1222">    resp-&gt;clear_failed_tablet_id();</a>
<a name="ln1223">  }</a>
<a name="ln1224"> </a>
<a name="ln1225">  context.RespondSuccess();</a>
<a name="ln1226">}</a>
<a name="ln1227"> </a>
<a name="ln1228">void TabletServiceAdminImpl::CountIntents(</a>
<a name="ln1229">    const CountIntentsRequestPB* req,</a>
<a name="ln1230">    CountIntentsResponsePB* resp,</a>
<a name="ln1231">    rpc::RpcContext context) {</a>
<a name="ln1232">  auto tablet_peers = server_-&gt;tablet_manager()-&gt;GetTabletPeers();</a>
<a name="ln1233">  int64_t total_intents = 0;</a>
<a name="ln1234">  // TODO: do this in parallel.</a>
<a name="ln1235">  // TODO: per-tablet intent counts.</a>
<a name="ln1236">  for (const auto&amp; peer : tablet_peers) {</a>
<a name="ln1237">    auto num_intents = peer-&gt;tablet()-&gt;CountIntents();</a>
<a name="ln1238">    if (!num_intents.ok()) {</a>
<a name="ln1239">      SetupErrorAndRespond(</a>
<a name="ln1240">          resp-&gt;mutable_error(), num_intents.status(), TabletServerErrorPB_Code_UNKNOWN_ERROR,</a>
<a name="ln1241">          &amp;context);</a>
<a name="ln1242">      return;</a>
<a name="ln1243">    }</a>
<a name="ln1244">    total_intents += *num_intents;</a>
<a name="ln1245">  }</a>
<a name="ln1246">  resp-&gt;set_num_intents(total_intents);</a>
<a name="ln1247">  context.RespondSuccess();</a>
<a name="ln1248">}</a>
<a name="ln1249"> </a>
<a name="ln1250">void TabletServiceAdminImpl::AddTableToTablet(</a>
<a name="ln1251">    const AddTableToTabletRequestPB* req, AddTableToTabletResponsePB* resp,</a>
<a name="ln1252">    rpc::RpcContext context) {</a>
<a name="ln1253">  auto tablet_id = req-&gt;tablet_id();</a>
<a name="ln1254"> </a>
<a name="ln1255">  const auto tablet =</a>
<a name="ln1256">      LookupLeaderTabletOrRespond(server_-&gt;tablet_peer_lookup(), tablet_id, resp, &amp;context);</a>
<a name="ln1257">  if (!tablet) {</a>
<a name="ln1258">    return;</a>
<a name="ln1259">  }</a>
<a name="ln1260">  DVLOG(3) &lt;&lt; &quot;Received AddTableToTablet RPC: &quot; &lt;&lt; yb::ToString(*req);</a>
<a name="ln1261"> </a>
<a name="ln1262">  tserver::ChangeMetadataRequestPB change_req;</a>
<a name="ln1263">  *change_req.mutable_add_table() = req-&gt;add_table();</a>
<a name="ln1264">  change_req.set_tablet_id(tablet_id);</a>
<a name="ln1265">  Status s = tablet::SyncReplicateChangeMetadataOperation(</a>
<a name="ln1266">      &amp;change_req, tablet.peer.get(), tablet.leader_term);</a>
<a name="ln1267">  if (PREDICT_FALSE(!s.ok())) {</a>
<a name="ln1268">    SetupErrorAndRespond(resp-&gt;mutable_error(), s, &amp;context);</a>
<a name="ln1269">    return;</a>
<a name="ln1270">  }</a>
<a name="ln1271">  context.RespondSuccess();</a>
<a name="ln1272">}</a>
<a name="ln1273"> </a>
<a name="ln1274">void TabletServiceAdminImpl::RemoveTableFromTablet(</a>
<a name="ln1275">    const RemoveTableFromTabletRequestPB* req,</a>
<a name="ln1276">    RemoveTableFromTabletResponsePB* resp,</a>
<a name="ln1277">    rpc::RpcContext context) {</a>
<a name="ln1278">  auto tablet =</a>
<a name="ln1279">      LookupLeaderTabletOrRespond(server_-&gt;tablet_peer_lookup(), req-&gt;tablet_id(), resp, &amp;context);</a>
<a name="ln1280">  if (!tablet) {</a>
<a name="ln1281">    return;</a>
<a name="ln1282">  }</a>
<a name="ln1283"> </a>
<a name="ln1284">  tserver::ChangeMetadataRequestPB change_req;</a>
<a name="ln1285">  change_req.set_remove_table_id(req-&gt;remove_table_id());</a>
<a name="ln1286">  change_req.set_tablet_id(req-&gt;tablet_id());</a>
<a name="ln1287">  Status s = tablet::SyncReplicateChangeMetadataOperation(</a>
<a name="ln1288">      &amp;change_req, tablet.peer.get(), tablet.leader_term);</a>
<a name="ln1289">  if (PREDICT_FALSE(!s.ok())) {</a>
<a name="ln1290">    SetupErrorAndRespond(resp-&gt;mutable_error(), s, &amp;context);</a>
<a name="ln1291">    return;</a>
<a name="ln1292">  }</a>
<a name="ln1293">  context.RespondSuccess();</a>
<a name="ln1294">}</a>
<a name="ln1295"> </a>
<a name="ln1296">void TabletServiceAdminImpl::SplitTablet(</a>
<a name="ln1297">    const SplitTabletRequestPB* req, SplitTabletResponsePB* resp, rpc::RpcContext context) {</a>
<a name="ln1298">  if (!CheckUuidMatchOrRespond(server_-&gt;tablet_manager(), &quot;SplitTablet&quot;, req, resp, &amp;context)) {</a>
<a name="ln1299">    return;</a>
<a name="ln1300">  }</a>
<a name="ln1301">  TRACE_EVENT1(&quot;tserver&quot;, &quot;SplitTablet&quot;, &quot;tablet_id&quot;, req-&gt;tablet_id());</a>
<a name="ln1302"> </a>
<a name="ln1303">  server::UpdateClock(*req, server_-&gt;Clock());</a>
<a name="ln1304"> </a>
<a name="ln1305">  auto leader_tablet_peer =</a>
<a name="ln1306">      LookupLeaderTabletOrRespond(server_-&gt;tablet_peer_lookup(), req-&gt;tablet_id(), resp, &amp;context);</a>
<a name="ln1307">  if (!leader_tablet_peer) {</a>
<a name="ln1308">    return;</a>
<a name="ln1309">  }</a>
<a name="ln1310"> </a>
<a name="ln1311">  auto state = std::make_unique&lt;tablet::SplitOperationState&gt;(</a>
<a name="ln1312">      leader_tablet_peer.peer-&gt;tablet(), leader_tablet_peer.peer-&gt;raft_consensus(),</a>
<a name="ln1313">      server_-&gt;tablet_manager(), req);</a>
<a name="ln1314"> </a>
<a name="ln1315">  state-&gt;set_completion_callback(</a>
<a name="ln1316">      MakeRpcOperationCompletionCallback(std::move(context), resp, server_-&gt;Clock()));</a>
<a name="ln1317"> </a>
<a name="ln1318">  leader_tablet_peer.peer-&gt;Submit(</a>
<a name="ln1319">      std::make_unique&lt;tablet::SplitOperation&gt;(std::move(state)), leader_tablet_peer.leader_term);</a>
<a name="ln1320">}</a>
<a name="ln1321"> </a>
<a name="ln1322">void TabletServiceImpl::Write(const WriteRequestPB* req,</a>
<a name="ln1323">                              WriteResponsePB* resp,</a>
<a name="ln1324">                              rpc::RpcContext context) {</a>
<a name="ln1325">  if (FLAGS_TEST_tserver_noop_read_write) {</a>
<a name="ln1326">    for (int i = 0; i &lt; req-&gt;ql_write_batch_size(); ++i) {</a>
<a name="ln1327">      resp-&gt;add_ql_response_batch();</a>
<a name="ln1328">    }</a>
<a name="ln1329">    context.RespondSuccess();</a>
<a name="ln1330">    return;</a>
<a name="ln1331">  }</a>
<a name="ln1332">  TRACE(&quot;Start Write&quot;);</a>
<a name="ln1333">  TRACE_EVENT1(&quot;tserver&quot;, &quot;TabletServiceImpl::Write&quot;,</a>
<a name="ln1334">               &quot;tablet_id&quot;, req-&gt;tablet_id());</a>
<a name="ln1335">  VLOG(2) &lt;&lt; &quot;Received Write RPC: &quot; &lt;&lt; req-&gt;DebugString();</a>
<a name="ln1336">  UpdateClock(*req, server_-&gt;Clock());</a>
<a name="ln1337"> </a>
<a name="ln1338">  auto tablet = LookupLeaderTabletOrRespond(</a>
<a name="ln1339">      server_-&gt;tablet_peer_lookup(), req-&gt;tablet_id(), resp, &amp;context);</a>
<a name="ln1340">  if (!tablet ||</a>
<a name="ln1341">      !CheckWriteThrottlingOrRespond(</a>
<a name="ln1342">          req-&gt;rejection_score(), tablet.peer.get(), resp, &amp;context)) {</a>
<a name="ln1343">    return;</a>
<a name="ln1344">  }</a>
<a name="ln1345"> </a>
<a name="ln1346">#if defined(DUMP_WRITE)</a>
<a name="ln1347">  if (req-&gt;has_write_batch() &amp;&amp; req-&gt;write_batch().has_transaction()) {</a>
<a name="ln1348">    VLOG(1) &lt;&lt; &quot;Write with transaction: &quot; &lt;&lt; req-&gt;write_batch().transaction().ShortDebugString();</a>
<a name="ln1349">    if (req-&gt;pgsql_write_batch_size() != 0) {</a>
<a name="ln1350">      auto txn_id = CHECK_RESULT(FullyDecodeTransactionId(</a>
<a name="ln1351">          req-&gt;write_batch().transaction().transaction_id()));</a>
<a name="ln1352">      for (const auto&amp; entry : req-&gt;pgsql_write_batch()) {</a>
<a name="ln1353">        if (entry.stmt_type() == PgsqlWriteRequestPB::PGSQL_UPDATE) {</a>
<a name="ln1354">          auto key = entry.column_new_values(0).expr().value().int32_value();</a>
<a name="ln1355">          LOG(INFO) &lt;&lt; txn_id &lt;&lt; &quot; UPDATE: &quot; &lt;&lt; key &lt;&lt; &quot; = &quot;</a>
<a name="ln1356">                    &lt;&lt; entry.column_new_values(1).expr().value().string_value();</a>
<a name="ln1357">        } else if (</a>
<a name="ln1358">            entry.stmt_type() == PgsqlWriteRequestPB::PGSQL_INSERT ||</a>
<a name="ln1359">            entry.stmt_type() == PgsqlWriteRequestPB::PGSQL_UPSERT) {</a>
<a name="ln1360">          docdb::DocKey doc_key;</a>
<a name="ln1361">          CHECK_OK(doc_key.FullyDecodeFrom(entry.ybctid_column_value().value().binary_value()));</a>
<a name="ln1362">          LOG(INFO) &lt;&lt; txn_id &lt;&lt; &quot; INSERT: &quot; &lt;&lt; doc_key.hashed_group()[0].GetInt32() &lt;&lt; &quot; = &quot;</a>
<a name="ln1363">                    &lt;&lt; entry.column_values(0).expr().value().string_value();</a>
<a name="ln1364">        } else if (entry.stmt_type() == PgsqlWriteRequestPB::PGSQL_DELETE) {</a>
<a name="ln1365">          LOG(INFO) &lt;&lt; txn_id &lt;&lt; &quot; DELETE: &quot; &lt;&lt; entry.ShortDebugString();</a>
<a name="ln1366">        }</a>
<a name="ln1367">      }</a>
<a name="ln1368">    }</a>
<a name="ln1369">  }</a>
<a name="ln1370">#endif</a>
<a name="ln1371"> </a>
<a name="ln1372">  if (PREDICT_FALSE(req-&gt;has_write_batch() &amp;&amp; !req-&gt;has_external_hybrid_time() &amp;&amp;</a>
<a name="ln1373">      (!req-&gt;write_batch().write_pairs().empty() || !req-&gt;write_batch().read_pairs().empty()))) {</a>
<a name="ln1374">    Status s = STATUS(NotSupported, &quot;Write Request contains write batch. This field should be &quot;</a>
<a name="ln1375">        &quot;used only for post-processed write requests during &quot;</a>
<a name="ln1376">        &quot;Raft replication.&quot;);</a>
<a name="ln1377">    SetupErrorAndRespond(resp-&gt;mutable_error(), s,</a>
<a name="ln1378">                         TabletServerErrorPB::INVALID_MUTATION,</a>
<a name="ln1379">                         &amp;context);</a>
<a name="ln1380">    return;</a>
<a name="ln1381">  }</a>
<a name="ln1382"> </a>
<a name="ln1383">  bool has_operations = (req-&gt;ql_write_batch_size() != 0 ||</a>
<a name="ln1384">                         req-&gt;redis_write_batch_size() != 0 ||</a>
<a name="ln1385">                         req-&gt;pgsql_write_batch_size() != 0 ||</a>
<a name="ln1386">                         (req-&gt;write_batch().write_pairs_size() != 0 &amp;&amp;</a>
<a name="ln1387">                          req-&gt;has_external_hybrid_time()));</a>
<a name="ln1388">  if (!has_operations &amp;&amp; tablet.peer-&gt;tablet()-&gt;table_type() != TableType::REDIS_TABLE_TYPE) {</a>
<a name="ln1389">    // An empty request. This is fine, can just exit early with ok status instead of working hard.</a>
<a name="ln1390">    // This doesn't need to go to Raft log.</a>
<a name="ln1391">    RpcOperationCompletionCallback&lt;WriteResponsePB&gt; callback(</a>
<a name="ln1392">        std::move(context), resp, server_-&gt;Clock());</a>
<a name="ln1393">    callback.OperationCompleted();</a>
<a name="ln1394">    return;</a>
<a name="ln1395">  }</a>
<a name="ln1396"> </a>
<a name="ln1397">  // For postgres requests check that the syscatalog version matches.</a>
<a name="ln1398">  if (tablet.peer-&gt;tablet()-&gt;table_type() == TableType::PGSQL_TABLE_TYPE) {</a>
<a name="ln1399">    for (const auto&amp; pg_req : req-&gt;pgsql_write_batch()) {</a>
<a name="ln1400">      if (pg_req.has_ysql_catalog_version() &amp;&amp;</a>
<a name="ln1401">          pg_req.ysql_catalog_version() &lt; server_-&gt;ysql_catalog_version()) {</a>
<a name="ln1402">        SetupErrorAndRespond(resp-&gt;mutable_error(),</a>
<a name="ln1403">            STATUS_SUBSTITUTE(QLError, &quot;Catalog Version Mismatch: A DDL occurred while processing &quot;</a>
<a name="ln1404">                                       &quot;this query. Try Again.&quot;),</a>
<a name="ln1405">            TabletServerErrorPB::MISMATCHED_SCHEMA, &amp;context);</a>
<a name="ln1406">        return;</a>
<a name="ln1407">      }</a>
<a name="ln1408">    }</a>
<a name="ln1409">  }</a>
<a name="ln1410"> </a>
<a name="ln1411">  auto operation_state = std::make_unique&lt;WriteOperationState&gt;(tablet.peer-&gt;tablet(), req, resp);</a>
<a name="ln1412"> </a>
<a name="ln1413">  auto context_ptr = std::make_shared&lt;RpcContext&gt;(std::move(context));</a>
<a name="ln1414">  if (RandomActWithProbability(GetAtomicFlag(&amp;FLAGS_TEST_respond_write_failed_probability))) {</a>
<a name="ln1415">    operation_state-&gt;set_completion_callback(nullptr);</a>
<a name="ln1416">    SetupErrorAndRespond(resp-&gt;mutable_error(), STATUS(LeaderHasNoLease, &quot;TEST: Random failure&quot;),</a>
<a name="ln1417">                         TabletServerErrorPB::UNKNOWN_ERROR, context_ptr.get());</a>
<a name="ln1418">  } else {</a>
<a name="ln1419">    operation_state-&gt;set_completion_callback(</a>
<a name="ln1420">        std::make_unique&lt;WriteOperationCompletionCallback&gt;(</a>
<a name="ln1421">            tablet.peer, context_ptr, resp, operation_state.get(), server_-&gt;Clock(),</a>
<a name="ln1422">            req-&gt;include_trace()));</a>
<a name="ln1423">  }</a>
<a name="ln1424"> </a>
<a name="ln1425">  AdjustYsqlOperationTransactionality(</a>
<a name="ln1426">      req-&gt;pgsql_write_batch_size(), tablet.peer.get(), operation_state.get());</a>
<a name="ln1427"> </a>
<a name="ln1428">  tablet.peer-&gt;WriteAsync(</a>
<a name="ln1429">      std::move(operation_state), tablet.leader_term, context_ptr-&gt;GetClientDeadline());</a>
<a name="ln1430">}</a>
<a name="ln1431"> </a>
<a name="ln1432">Status TabletServiceImpl::CheckPeerIsReady(</a>
<a name="ln1433">    const TabletPeer&amp; tablet_peer, AllowSplitTablet allow_split_tablet) {</a>
<a name="ln1434">  shared_ptr&lt;consensus::Consensus&gt; consensus = tablet_peer.shared_consensus();</a>
<a name="ln1435">  if (!consensus) {</a>
<a name="ln1436">    return STATUS(</a>
<a name="ln1437">        IllegalState, Format(&quot;Consensus not available for tablet $0.&quot;, tablet_peer.tablet_id()),</a>
<a name="ln1438">        Slice(), TabletServerError(TabletServerErrorPB::TABLET_NOT_RUNNING));</a>
<a name="ln1439">  }</a>
<a name="ln1440"> </a>
<a name="ln1441">  Status s = tablet_peer.CheckRunning();</a>
<a name="ln1442">  if (!s.ok()) {</a>
<a name="ln1443">    return s.CloneAndAddErrorCode(TabletServerError(TabletServerErrorPB::TABLET_NOT_RUNNING));</a>
<a name="ln1444">  }</a>
<a name="ln1445"> </a>
<a name="ln1446">  auto* tablet = tablet_peer.tablet();</a>
<a name="ln1447">  SCHECK(tablet != nullptr, IllegalState, &quot;Expected tablet peer to have a tablet&quot;);</a>
<a name="ln1448">  const auto tablet_data_state = tablet-&gt;metadata()-&gt;tablet_data_state();</a>
<a name="ln1449">  if (!allow_split_tablet &amp;&amp;</a>
<a name="ln1450">      tablet_data_state == tablet::TabletDataState::TABLET_DATA_SPLIT_COMPLETED) {</a>
<a name="ln1451">    return STATUS(</a>
<a name="ln1452">        IllegalState,</a>
<a name="ln1453">        Format(</a>
<a name="ln1454">            &quot;The tablet $0 is in $1 state.&quot;, tablet-&gt;tablet_id(), tablet_data_state),</a>
<a name="ln1455">        TabletServerError(TabletServerErrorPB::TABLET_SPLIT));</a>
<a name="ln1456">    // TODO(tsplit): If we get FS corruption on 1 node, we can just delete that tablet copy and</a>
<a name="ln1457">    // bootstrap from a good leader. If there's a way that all peers replicated the SPLIT and</a>
<a name="ln1458">    // modified their data state, but all had some failures (code bug?).</a>
<a name="ln1459">    // Perhaps we should consider a tool for editing the data state?</a>
<a name="ln1460">  }</a>
<a name="ln1461">  return Status::OK();</a>
<a name="ln1462">}</a>
<a name="ln1463"> </a>
<a name="ln1464">Status TabletServiceImpl::CheckPeerIsLeader(const TabletPeer&amp; tablet_peer) {</a>
<a name="ln1465">  return ResultToStatus(LeaderTerm(tablet_peer));</a>
<a name="ln1466">}</a>
<a name="ln1467"> </a>
<a name="ln1468">bool TabletServiceImpl::GetTabletOrRespond(</a>
<a name="ln1469">    const ReadRequestPB* req, ReadResponsePB* resp, rpc::RpcContext* context,</a>
<a name="ln1470">    std::shared_ptr&lt;tablet::AbstractTablet&gt;* tablet, TabletPeerPtr tablet_peer) {</a>
<a name="ln1471">  return DoGetTabletOrRespond(req, resp, context, tablet, tablet_peer);</a>
<a name="ln1472">}</a>
<a name="ln1473"> </a>
<a name="ln1474">template &lt;class Req, class Resp&gt;</a>
<a name="ln1475">bool TabletServiceImpl::DoGetTabletOrRespond(</a>
<a name="ln1476">    const Req* req, Resp* resp, rpc::RpcContext* context,</a>
<a name="ln1477">    std::shared_ptr&lt;tablet::AbstractTablet&gt;* tablet, TabletPeerPtr tablet_peer,</a>
<a name="ln1478">    AllowSplitTablet allow_split_tablet) {</a>
<a name="ln1479">  if (tablet_peer) {</a>
<a name="ln1480">    DCHECK_EQ(tablet_peer-&gt;tablet_id(), req-&gt;tablet_id());</a>
<a name="ln1481">  } else {</a>
<a name="ln1482">    auto tablet_peer_result = LookupTabletPeerOrRespond(</a>
<a name="ln1483">        server_-&gt;tablet_peer_lookup(), req-&gt;tablet_id(), resp, context);</a>
<a name="ln1484"> </a>
<a name="ln1485">    if (!tablet_peer_result.ok()) {</a>
<a name="ln1486">      return false;</a>
<a name="ln1487">    }</a>
<a name="ln1488"> </a>
<a name="ln1489">    tablet_peer = std::move(*tablet_peer_result);</a>
<a name="ln1490">  }</a>
<a name="ln1491"> </a>
<a name="ln1492">  Status s = CheckPeerIsReady(*tablet_peer, allow_split_tablet);</a>
<a name="ln1493">  if (PREDICT_FALSE(!s.ok())) {</a>
<a name="ln1494">    SetupErrorAndRespond(resp-&gt;mutable_error(), s, context);</a>
<a name="ln1495">    return false;</a>
<a name="ln1496">  }</a>
<a name="ln1497"> </a>
<a name="ln1498">  // Check for leader only in strong consistency level.</a>
<a name="ln1499">  if (req-&gt;consistency_level() == YBConsistencyLevel::STRONG) {</a>
<a name="ln1500">    if (PREDICT_FALSE(FLAGS_TEST_assert_reads_served_by_follower) &amp;&amp;</a>
<a name="ln1501">        std::is_same&lt;Req, ReadRequestPB&gt;::value) {</a>
<a name="ln1502">      LOG(FATAL) &lt;&lt; &quot;--TEST_assert_reads_served_by_follower is true but consistency level is &quot;</a>
<a name="ln1503">                    &quot;invalid: YBConsistencyLevel::STRONG&quot;;</a>
<a name="ln1504">    }</a>
<a name="ln1505">    if (PREDICT_FALSE(FLAGS_TEST_assert_reads_from_follower_rejected_because_of_staleness)) {</a>
<a name="ln1506">      LOG(FATAL) &lt;&lt; &quot;--TEST_assert_reads_from_follower_rejected_because_of_staleness is true but &quot;</a>
<a name="ln1507">                    &quot;consistency level is invalid: YBConsistencyLevel::STRONG&quot;;</a>
<a name="ln1508">    }</a>
<a name="ln1509"> </a>
<a name="ln1510">    s = CheckPeerIsLeader(*tablet_peer);</a>
<a name="ln1511">    if (PREDICT_FALSE(!s.ok())) {</a>
<a name="ln1512">      SetupErrorAndRespond(resp-&gt;mutable_error(), s, context);</a>
<a name="ln1513">      return false;</a>
<a name="ln1514">    }</a>
<a name="ln1515">  } else {</a>
<a name="ln1516">    s = CheckPeerIsLeader(*tablet_peer.get());</a>
<a name="ln1517"> </a>
<a name="ln1518">    // Peer is not the leader, so check that the time since it last heard from the leader is less</a>
<a name="ln1519">    // than FLAGS_max_stale_read_bound_time_ms.</a>
<a name="ln1520">    if (PREDICT_FALSE(!s.ok())) {</a>
<a name="ln1521">      if (FLAGS_max_stale_read_bound_time_ms &gt; 0) {</a>
<a name="ln1522">        shared_ptr &lt;consensus::Consensus&gt; consensus = tablet_peer-&gt;shared_consensus();</a>
<a name="ln1523">        // TODO(hector): This safe time could be reused by the read operation.</a>
<a name="ln1524">        auto safe_time_micros = tablet_peer-&gt;tablet()-&gt;mvcc_manager()-&gt;SafeTimeForFollower(</a>
<a name="ln1525">            HybridTime::kMin, CoarseTimePoint::min()).GetPhysicalValueMicros();</a>
<a name="ln1526">        auto now_micros = server_-&gt;Clock()-&gt;Now().GetPhysicalValueMicros();</a>
<a name="ln1527">        auto follower_staleness_ms = (now_micros - safe_time_micros) / 1000;</a>
<a name="ln1528">        if (follower_staleness_ms &gt; FLAGS_max_stale_read_bound_time_ms) {</a>
<a name="ln1529">          SetupErrorAndRespond(resp-&gt;mutable_error(), STATUS(IllegalState, &quot;Stale follower&quot;),</a>
<a name="ln1530">                               TabletServerErrorPB::STALE_FOLLOWER, context);</a>
<a name="ln1531">          return false;</a>
<a name="ln1532">        } else if (PREDICT_FALSE(</a>
<a name="ln1533">            FLAGS_TEST_assert_reads_from_follower_rejected_because_of_staleness)) {</a>
<a name="ln1534">          LOG(FATAL) &lt;&lt; &quot;--TEST_assert_reads_from_follower_rejected_because_of_staleness is true,&quot;</a>
<a name="ln1535">                     &lt;&lt; &quot; but peer &quot; &lt;&lt; tablet_peer-&gt;permanent_uuid()</a>
<a name="ln1536">                     &lt;&lt; &quot; for tablet: &quot; &lt;&lt; req-&gt;tablet_id()</a>
<a name="ln1537">                     &lt;&lt; &quot; is not stale. Time since last update from leader: &quot;</a>
<a name="ln1538">                     &lt;&lt; follower_staleness_ms;</a>
<a name="ln1539">        } else {</a>
<a name="ln1540">          VLOG(3) &lt;&lt; &quot;Reading from follower with staleness (ms): &quot;</a>
<a name="ln1541">                  &lt;&lt; follower_staleness_ms;</a>
<a name="ln1542">        }</a>
<a name="ln1543">      }</a>
<a name="ln1544">    } else {</a>
<a name="ln1545">      // We are here because we are the leader.</a>
<a name="ln1546">      if (PREDICT_FALSE(FLAGS_TEST_assert_reads_from_follower_rejected_because_of_staleness)) {</a>
<a name="ln1547">        LOG(FATAL) &lt;&lt; &quot;--TEST_assert_reads_from_follower_rejected_because_of_staleness is true but &quot;</a>
<a name="ln1548">                   &lt;&lt; &quot; peer &quot; &lt;&lt; tablet_peer-&gt;permanent_uuid()</a>
<a name="ln1549">                   &lt;&lt; &quot; is the leader for tablet &quot; &lt;&lt; req-&gt;tablet_id();</a>
<a name="ln1550">      }</a>
<a name="ln1551">      if (PREDICT_FALSE(FLAGS_TEST_assert_reads_served_by_follower) &amp;&amp;</a>
<a name="ln1552">               std::is_same&lt;Req, ReadRequestPB&gt;::value) {</a>
<a name="ln1553">        LOG(FATAL) &lt;&lt; &quot;--TEST_assert_reads_served_by_follower is true but read is being served by &quot;</a>
<a name="ln1554">                   &lt;&lt; &quot; peer &quot; &lt;&lt; tablet_peer-&gt;permanent_uuid()</a>
<a name="ln1555">                   &lt;&lt; &quot; which is the leader for tablet &quot; &lt;&lt; req-&gt;tablet_id();</a>
<a name="ln1556">      }</a>
<a name="ln1557">    }</a>
<a name="ln1558">  }</a>
<a name="ln1559"> </a>
<a name="ln1560">  shared_ptr&lt;tablet::Tablet&gt; ptr;</a>
<a name="ln1561">  TabletServerErrorPB::Code error_code;</a>
<a name="ln1562">  s = GetTabletRef(tablet_peer, &amp;ptr, &amp;error_code);</a>
<a name="ln1563">  if (PREDICT_FALSE(!s.ok())) {</a>
<a name="ln1564">    SetupErrorAndRespond(resp-&gt;mutable_error(), s, error_code, context);</a>
<a name="ln1565">    return false;</a>
<a name="ln1566">  }</a>
<a name="ln1567">  *tablet = ptr;</a>
<a name="ln1568">  return true;</a>
<a name="ln1569">}</a>
<a name="ln1570"> </a>
<a name="ln1571">struct ReadContext {</a>
<a name="ln1572">  const ReadRequestPB* req = nullptr;</a>
<a name="ln1573">  ReadResponsePB* resp = nullptr;</a>
<a name="ln1574">  rpc::RpcContext* context = nullptr;</a>
<a name="ln1575"> </a>
<a name="ln1576">  std::shared_ptr&lt;tablet::AbstractTablet&gt; tablet;</a>
<a name="ln1577"> </a>
<a name="ln1578">  ReadHybridTime read_time;</a>
<a name="ln1579">  HybridTime safe_ht_to_read;</a>
<a name="ln1580">  ReadHybridTime used_read_time;</a>
<a name="ln1581">  tablet::RequireLease require_lease = tablet::RequireLease::kFalse;</a>
<a name="ln1582">  HostPortPB* host_port_pb = nullptr;</a>
<a name="ln1583">  bool allow_retry = false;</a>
<a name="ln1584">  RequestScope request_scope;</a>
<a name="ln1585"> </a>
<a name="ln1586">  bool transactional() const {</a>
<a name="ln1587">    return tablet-&gt;IsTransactionalRequest(req-&gt;pgsql_batch_size() &gt; 0);</a>
<a name="ln1588">  }</a>
<a name="ln1589"> </a>
<a name="ln1590">  // Picks read based for specified read context.</a>
<a name="ln1591">  CHECKED_STATUS PickReadTime(server::Clock* clock) {</a>
<a name="ln1592">    if (!read_time) {</a>
<a name="ln1593">      safe_ht_to_read = tablet-&gt;SafeTime(require_lease);</a>
<a name="ln1594">      // If the read time is not specified, then it is a single-shard read.</a>
<a name="ln1595">      // So we should restart it in server in case of failure.</a>
<a name="ln1596">      read_time.read = safe_ht_to_read;</a>
<a name="ln1597">      if (transactional()) {</a>
<a name="ln1598">        read_time.local_limit = clock-&gt;MaxGlobalNow();</a>
<a name="ln1599">        read_time.global_limit = read_time.local_limit;</a>
<a name="ln1600"> </a>
<a name="ln1601">        VLOG(1) &lt;&lt; &quot;Read time: &quot; &lt;&lt; read_time.ToString();</a>
<a name="ln1602">      } else {</a>
<a name="ln1603">        read_time.local_limit = read_time.read;</a>
<a name="ln1604">        read_time.global_limit = read_time.read;</a>
<a name="ln1605">      }</a>
<a name="ln1606">    } else {</a>
<a name="ln1607">      safe_ht_to_read = tablet-&gt;SafeTime(</a>
<a name="ln1608">          require_lease, read_time.read, context-&gt;GetClientDeadline());</a>
<a name="ln1609">      if (!safe_ht_to_read.is_valid()) { // Timed out</a>
<a name="ln1610">        const char* error_message = &quot;Timed out waiting for read time&quot;;</a>
<a name="ln1611">        TRACE(error_message);</a>
<a name="ln1612">        return STATUS(TimedOut, error_message);</a>
<a name="ln1613">      }</a>
<a name="ln1614">    }</a>
<a name="ln1615">    return Status::OK();</a>
<a name="ln1616">  }</a>
<a name="ln1617">};</a>
<a name="ln1618"> </a>
<a name="ln1619">// Used when we write intents during read, i.e. for serializable isolation.</a>
<a name="ln1620">// We cannot proceed with read from ReadOperationCompletionCallback, to avoid holding</a>
<a name="ln1621">// replica state lock for too long.</a>
<a name="ln1622">// So ThreadPool is used to proceed with read.</a>
<a name="ln1623">class ReadCompletionTask : public rpc::ThreadPoolTask {</a>
<a name="ln1624"> public:</a>
<a name="ln1625">  ReadCompletionTask(</a>
<a name="ln1626">      TabletServiceImpl* service,</a>
<a name="ln1627">      ReadContext&amp;&amp; read_context,</a>
<a name="ln1628">      std::shared_ptr&lt;rpc::RpcContext&gt; context)</a>
<a name="ln1629">      : service_(service), read_context_(std::move(read_context)), context_(std::move(context)) {</a>
<a name="ln1630">  }</a>
<a name="ln1631"> </a>
<a name="ln1632">  virtual ~ReadCompletionTask() = default;</a>
<a name="ln1633"> </a>
<a name="ln1634"> private:</a>
<a name="ln1635">  void Run() override {</a>
<a name="ln1636">    auto status = read_context_.PickReadTime(service_-&gt;server_-&gt;Clock());</a>
<a name="ln1637">    if (!status.ok()) {</a>
<a name="ln1638">      Done(status);</a>
<a name="ln1639">      return;</a>
<a name="ln1640">    }</a>
<a name="ln1641">    service_-&gt;CompleteRead(&amp;read_context_);</a>
<a name="ln1642">  }</a>
<a name="ln1643"> </a>
<a name="ln1644">  void Done(const Status&amp; status) override {</a>
<a name="ln1645">    if (!status.ok()) {</a>
<a name="ln1646">      SetupErrorAndRespond(</a>
<a name="ln1647">          read_context_.resp-&gt;mutable_error(), status, TabletServerErrorPB::UNKNOWN_ERROR,</a>
<a name="ln1648">          context_.get());</a>
<a name="ln1649">    }</a>
<a name="ln1650"> </a>
<a name="ln1651">    delete this;</a>
<a name="ln1652">  }</a>
<a name="ln1653"> </a>
<a name="ln1654">  TabletServiceImpl* service_;</a>
<a name="ln1655">  ReadContext read_context_;</a>
<a name="ln1656">  std::shared_ptr&lt;rpc::RpcContext&gt; context_;</a>
<a name="ln1657">};</a>
<a name="ln1658"> </a>
<a name="ln1659">class ReadOperationCompletionCallback : public OperationCompletionCallback {</a>
<a name="ln1660"> public:</a>
<a name="ln1661">  explicit ReadOperationCompletionCallback(</a>
<a name="ln1662">      TabletServiceImpl* service,</a>
<a name="ln1663">      tablet::TabletPeerPtr tablet_peer,</a>
<a name="ln1664">      ReadContext&amp;&amp; read_context,</a>
<a name="ln1665">      std::shared_ptr&lt;rpc::RpcContext&gt; context)</a>
<a name="ln1666">      : service_(service), tablet_peer_(std::move(tablet_peer)),</a>
<a name="ln1667">        read_context_(std::move(read_context)), context_(std::move(context)) {}</a>
<a name="ln1668"> </a>
<a name="ln1669">  void OperationCompleted() override {</a>
<a name="ln1670">    if (!status_.ok()) {</a>
<a name="ln1671">      SetupErrorAndRespond(read_context_.resp-&gt;mutable_error(), status_, code_,</a>
<a name="ln1672">                           context_.get());</a>
<a name="ln1673">      return;</a>
<a name="ln1674">    }</a>
<a name="ln1675"> </a>
<a name="ln1676">    tablet_peer_-&gt;Enqueue(new ReadCompletionTask(service_, std::move(read_context_), context_));</a>
<a name="ln1677">  }</a>
<a name="ln1678"> </a>
<a name="ln1679"> private:</a>
<a name="ln1680">  TabletServiceImpl* service_;</a>
<a name="ln1681">  tablet::TabletPeerPtr tablet_peer_;</a>
<a name="ln1682">  ReadContext read_context_;</a>
<a name="ln1683">  std::shared_ptr&lt;rpc::RpcContext&gt; context_;</a>
<a name="ln1684">};</a>
<a name="ln1685"> </a>
<a name="ln1686">void TabletServiceImpl::Read(const ReadRequestPB* req,</a>
<a name="ln1687">                             ReadResponsePB* resp,</a>
<a name="ln1688">                             rpc::RpcContext context) {</a>
<a name="ln1689">  if (FLAGS_TEST_tserver_noop_read_write) {</a>
<a name="ln1690">    context.RespondSuccess();</a>
<a name="ln1691">    return;</a>
<a name="ln1692">  }</a>
<a name="ln1693">  TRACE(&quot;Start Read&quot;);</a>
<a name="ln1694">  TRACE_EVENT1(&quot;tserver&quot;, &quot;TabletServiceImpl::Read&quot;,</a>
<a name="ln1695">      &quot;tablet_id&quot;, req-&gt;tablet_id());</a>
<a name="ln1696">  VLOG(2) &lt;&lt; &quot;Received Read RPC: &quot; &lt;&lt; req-&gt;DebugString();</a>
<a name="ln1697"> </a>
<a name="ln1698">  // Unfortunately, determining the isolation level is not as straightforward as it seems. All but</a>
<a name="ln1699">  // the first request to a given tablet by a particular transaction assume that the tablet already</a>
<a name="ln1700">  // has the transaction metadata, including the isolation level, and those requests expect us to</a>
<a name="ln1701">  // retrieve the isolation level from that metadata. Failure to do so was the cause of a</a>
<a name="ln1702">  // serialization anomaly tested by TestOneOrTwoAdmins</a>
<a name="ln1703">  // (https://github.com/YugaByte/yugabyte-db/issues/1572).</a>
<a name="ln1704"> </a>
<a name="ln1705">  bool serializable_isolation = false;</a>
<a name="ln1706">  TabletPeerPtr tablet_peer;</a>
<a name="ln1707">  if (req-&gt;has_transaction()) {</a>
<a name="ln1708">    IsolationLevel isolation_level;</a>
<a name="ln1709">    if (req-&gt;transaction().has_isolation()) {</a>
<a name="ln1710">      // This must be the first request to this tablet by this particular transaction.</a>
<a name="ln1711">      isolation_level = req-&gt;transaction().isolation();</a>
<a name="ln1712">    } else {</a>
<a name="ln1713">      tablet_peer = VERIFY_RESULT_OR_RETURN(LookupTabletPeerOrRespond(</a>
<a name="ln1714">          server_-&gt;tablet_peer_lookup(), req-&gt;tablet_id(), resp, &amp;context));</a>
<a name="ln1715">      auto isolation_level_result = tablet_peer-&gt;tablet()-&gt;GetIsolationLevelFromPB(*req);</a>
<a name="ln1716">      if (!isolation_level_result.ok()) {</a>
<a name="ln1717">        SetupErrorAndRespond(</a>
<a name="ln1718">            resp-&gt;mutable_error(), isolation_level_result.status(),</a>
<a name="ln1719">            TabletServerErrorPB::UNKNOWN_ERROR, &amp;context);</a>
<a name="ln1720">        return;</a>
<a name="ln1721">      }</a>
<a name="ln1722">      isolation_level = *isolation_level_result;</a>
<a name="ln1723">    }</a>
<a name="ln1724">    serializable_isolation = isolation_level == IsolationLevel::SERIALIZABLE_ISOLATION;</a>
<a name="ln1725">#if defined(DUMP_READ)</a>
<a name="ln1726">    if (req-&gt;pgsql_batch().size() &gt; 0) {</a>
<a name="ln1727">      LOG(INFO) &lt;&lt; CHECK_RESULT(FullyDecodeTransactionId(req-&gt;transaction().transaction_id()))</a>
<a name="ln1728">                &lt;&lt; &quot; READ: &quot; &lt;&lt; req-&gt;pgsql_batch(0).partition_column_values(0).value().int32_value()</a>
<a name="ln1729">                &lt;&lt; &quot;, &quot; &lt;&lt; isolation_level;</a>
<a name="ln1730">    }</a>
<a name="ln1731">#endif</a>
<a name="ln1732">  }</a>
<a name="ln1733"> </a>
<a name="ln1734">  // Get the most restrictive row mark present in the batch of PostgreSQL requests.</a>
<a name="ln1735">  // TODO: rather handle individual row marks once we start batching read requests (issue #2495)</a>
<a name="ln1736">  RowMarkType batch_row_mark = RowMarkType::ROW_MARK_ABSENT;</a>
<a name="ln1737">  if (!req-&gt;pgsql_batch().empty()) {</a>
<a name="ln1738">    for (const auto&amp; pg_req : req-&gt;pgsql_batch()) {</a>
<a name="ln1739">      // For postgres requests check that the syscatalog version matches.</a>
<a name="ln1740">      if (pg_req.has_ysql_catalog_version() &amp;&amp;</a>
<a name="ln1741">          pg_req.ysql_catalog_version() &lt; server_-&gt;ysql_catalog_version()) {</a>
<a name="ln1742">        SetupErrorAndRespond(resp-&gt;mutable_error(),</a>
<a name="ln1743">            STATUS_SUBSTITUTE(QLError, &quot;Catalog Version Mismatch: A DDL occurred while processing &quot;</a>
<a name="ln1744">                                       &quot;this query. Try Again.&quot;),</a>
<a name="ln1745">            TabletServerErrorPB::MISMATCHED_SCHEMA, &amp;context);</a>
<a name="ln1746">        return;</a>
<a name="ln1747">      }</a>
<a name="ln1748">      RowMarkType current_row_mark = GetRowMarkTypeFromPB(pg_req);</a>
<a name="ln1749">      if (IsValidRowMarkType(current_row_mark)) {</a>
<a name="ln1750">        if (!req-&gt;has_transaction()) {</a>
<a name="ln1751">          SetupErrorAndRespond(resp-&gt;mutable_error(),</a>
<a name="ln1752">              STATUS(NotSupported,</a>
<a name="ln1753">                     &quot;Read request with row mark types must be part of a transaction&quot;),</a>
<a name="ln1754">              TabletServerErrorPB::OPERATION_NOT_SUPPORTED, &amp;context);</a>
<a name="ln1755">        }</a>
<a name="ln1756">        batch_row_mark = GetStrongestRowMarkType({current_row_mark, batch_row_mark});</a>
<a name="ln1757">      }</a>
<a name="ln1758">    }</a>
<a name="ln1759">  }</a>
<a name="ln1760">  const bool has_row_mark = IsValidRowMarkType(batch_row_mark);</a>
<a name="ln1761"> </a>
<a name="ln1762">  LeaderTabletPeer leader_peer;</a>
<a name="ln1763">  ReadContext read_context = {req, resp, &amp;context};</a>
<a name="ln1764"> </a>
<a name="ln1765">  if (serializable_isolation || has_row_mark) {</a>
<a name="ln1766">    // At this point we expect that we don't have pure read serializable transactions, and</a>
<a name="ln1767">    // always write read intents to detect conflicts with other writes.</a>
<a name="ln1768">    leader_peer = LookupLeaderTabletOrRespond(</a>
<a name="ln1769">        server_-&gt;tablet_peer_lookup(), req-&gt;tablet_id(), resp, &amp;context, std::move(tablet_peer));</a>
<a name="ln1770">    // Serializable read adds intents, i.e. writes data.</a>
<a name="ln1771">    // We should check for memory pressure in this case.</a>
<a name="ln1772">    if (!leader_peer ||</a>
<a name="ln1773">        !CheckWriteThrottlingOrRespond(</a>
<a name="ln1774">            req-&gt;rejection_score(), leader_peer.peer.get(), resp, &amp;context)) {</a>
<a name="ln1775">      return;</a>
<a name="ln1776">    }</a>
<a name="ln1777">    read_context.tablet = leader_peer.peer-&gt;shared_tablet();</a>
<a name="ln1778">  } else {</a>
<a name="ln1779">    if (!GetTabletOrRespond(req, resp, &amp;context, &amp;read_context.tablet, std::move(tablet_peer))) {</a>
<a name="ln1780">      return;</a>
<a name="ln1781">    }</a>
<a name="ln1782">    leader_peer.leader_term = yb::OpId::kUnknownTerm;</a>
<a name="ln1783">  }</a>
<a name="ln1784"> </a>
<a name="ln1785">  if (PREDICT_FALSE(FLAGS_TEST_simulate_time_out_failures) &amp;&amp; RandomUniformInt(0, 10) &lt; 3) {</a>
<a name="ln1786">    LOG(INFO) &lt;&lt; &quot;Marking request as timed out for test&quot;;</a>
<a name="ln1787">    SetupErrorAndRespond(resp-&gt;mutable_error(), STATUS(TimedOut, &quot;timed out for test&quot;),</a>
<a name="ln1788">        TabletServerErrorPB::UNKNOWN_ERROR, &amp;context);</a>
<a name="ln1789">    return;</a>
<a name="ln1790">  }</a>
<a name="ln1791"> </a>
<a name="ln1792">  if (server_ &amp;&amp; server_-&gt;Clock()) {</a>
<a name="ln1793">    server::UpdateClock(*req, server_-&gt;Clock());</a>
<a name="ln1794">  }</a>
<a name="ln1795"> </a>
<a name="ln1796">  // safe_ht_to_read is used only for read restart, so if read_time is valid, then we would respond</a>
<a name="ln1797">  // with &quot;restart required&quot;.</a>
<a name="ln1798">  ReadHybridTime&amp; read_time = read_context.read_time;</a>
<a name="ln1799"> </a>
<a name="ln1800">  read_time = ReadHybridTime::FromReadTimePB(*req);</a>
<a name="ln1801"> </a>
<a name="ln1802">  read_context.allow_retry = !read_time;</a>
<a name="ln1803">  read_context.require_lease = tablet::RequireLease(</a>
<a name="ln1804">      req-&gt;consistency_level() == YBConsistencyLevel::STRONG);</a>
<a name="ln1805">  // TODO: should check all the tables referenced by the requests to decide if it is transactional.</a>
<a name="ln1806">  const bool transactional = read_context.transactional();</a>
<a name="ln1807">  // Should not pick read time for serializable isolation, since it is picked after read intents</a>
<a name="ln1808">  // are added. Also conflict resolution for serializable isolation should be done without read time</a>
<a name="ln1809">  // specified. So we use max hybrid time for conflict resolution in such case.</a>
<a name="ln1810">  // It was implemented as part of #655.</a>
<a name="ln1811">  if (!serializable_isolation) {</a>
<a name="ln1812">    auto status = read_context.PickReadTime(server_-&gt;Clock());</a>
<a name="ln1813">    if (!status.ok()) {</a>
<a name="ln1814">      SetupErrorAndRespond(</a>
<a name="ln1815">          resp-&gt;mutable_error(), status, TabletServerErrorPB::UNKNOWN_ERROR, &amp;context);</a>
<a name="ln1816">      return;</a>
<a name="ln1817">    }</a>
<a name="ln1818">  }</a>
<a name="ln1819"> </a>
<a name="ln1820">  if (transactional) {</a>
<a name="ln1821">    // Serial number is used to check whether this operation was initiated before</a>
<a name="ln1822">    // transaction status request. So we should initialize it as soon as possible.</a>
<a name="ln1823">    read_context.request_scope = RequestScope(</a>
<a name="ln1824">        down_cast&lt;Tablet*&gt;(read_context.tablet.get())-&gt;transaction_participant());</a>
<a name="ln1825">    read_time.serial_no = read_context.request_scope.request_id();</a>
<a name="ln1826">  }</a>
<a name="ln1827"> </a>
<a name="ln1828">  const auto&amp; remote_address = context.remote_address();</a>
<a name="ln1829">  HostPortPB host_port_pb;</a>
<a name="ln1830">  host_port_pb.set_host(remote_address.address().to_string());</a>
<a name="ln1831">  host_port_pb.set_port(remote_address.port());</a>
<a name="ln1832">  read_context.host_port_pb = &amp;host_port_pb;</a>
<a name="ln1833"> </a>
<a name="ln1834">  if (serializable_isolation || has_row_mark) {</a>
<a name="ln1835">    WriteRequestPB write_req;</a>
<a name="ln1836">    *write_req.mutable_write_batch()-&gt;mutable_transaction() = req-&gt;transaction();</a>
<a name="ln1837">    if (has_row_mark) {</a>
<a name="ln1838">      write_req.mutable_write_batch()-&gt;set_row_mark_type(batch_row_mark);</a>
<a name="ln1839">      read_context.read_time.ToPB(write_req.mutable_read_time());</a>
<a name="ln1840">    }</a>
<a name="ln1841">    write_req.set_tablet_id(req-&gt;tablet_id());</a>
<a name="ln1842">    write_req.mutable_write_batch()-&gt;set_deprecated_may_have_metadata(true);</a>
<a name="ln1843">    write_req.set_batch_idx(req-&gt;batch_idx());</a>
<a name="ln1844">    // TODO(dtxn) write request id</a>
<a name="ln1845"> </a>
<a name="ln1846">    auto* write_batch = write_req.mutable_write_batch();</a>
<a name="ln1847">    auto status = leader_peer.peer-&gt;tablet()-&gt;CreateReadIntents(</a>
<a name="ln1848">        req-&gt;transaction(), req-&gt;ql_batch(), req-&gt;pgsql_batch(), write_batch);</a>
<a name="ln1849">    if (!status.ok()) {</a>
<a name="ln1850">      SetupErrorAndRespond(</a>
<a name="ln1851">          resp-&gt;mutable_error(), status, TabletServerErrorPB::UNKNOWN_ERROR, &amp;context);</a>
<a name="ln1852">      return;</a>
<a name="ln1853">    }</a>
<a name="ln1854"> </a>
<a name="ln1855">    auto operation_state = std::make_unique&lt;WriteOperationState&gt;(</a>
<a name="ln1856">        leader_peer.peer-&gt;tablet(), &amp;write_req, nullptr /* response */,</a>
<a name="ln1857">        docdb::OperationKind::kRead);</a>
<a name="ln1858"> </a>
<a name="ln1859">    AdjustYsqlOperationTransactionality(</a>
<a name="ln1860">        req-&gt;pgsql_batch_size(), leader_peer.peer.get(), operation_state.get());</a>
<a name="ln1861"> </a>
<a name="ln1862">    auto context_ptr = std::make_shared&lt;RpcContext&gt;(std::move(context));</a>
<a name="ln1863">    read_context.context = context_ptr.get();</a>
<a name="ln1864">    operation_state-&gt;set_completion_callback(std::make_unique&lt;ReadOperationCompletionCallback&gt;(</a>
<a name="ln1865">        this, leader_peer.peer, std::move(read_context), context_ptr));</a>
<a name="ln1866">    leader_peer.peer-&gt;WriteAsync(</a>
<a name="ln1867">        std::move(operation_state), leader_peer.leader_term, context_ptr-&gt;GetClientDeadline());</a>
<a name="ln1868">    return;</a>
<a name="ln1869">  }</a>
<a name="ln1870"> </a>
<a name="ln1871">  CompleteRead(&amp;read_context);</a>
<a name="ln1872">}</a>
<a name="ln1873"> </a>
<a name="ln1874">void TabletServiceImpl::CompleteRead(ReadContext* read_context) {</a>
<a name="ln1875">  for (;;) {</a>
<a name="ln1876">    read_context-&gt;resp-&gt;Clear();</a>
<a name="ln1877">    read_context-&gt;context-&gt;ResetRpcSidecars();</a>
<a name="ln1878">    VLOG(1) &lt;&lt; &quot;Read time: &quot; &lt;&lt; read_context-&gt;read_time</a>
<a name="ln1879">            &lt;&lt; &quot;, safe: &quot; &lt;&lt; read_context-&gt;safe_ht_to_read;</a>
<a name="ln1880">    Result&lt;ReadHybridTime&gt; result{ReadHybridTime()};</a>
<a name="ln1881">    {</a>
<a name="ln1882">      LongOperationTracker long_operation_tracker(&quot;Read&quot;, 1s);</a>
<a name="ln1883">      result = DoRead(read_context);</a>
<a name="ln1884">    }</a>
<a name="ln1885">    if (!result.ok()) {</a>
<a name="ln1886">      WARN_NOT_OK(result.status(), &quot;DoRead&quot;);</a>
<a name="ln1887">      SetupErrorAndRespond(</a>
<a name="ln1888">          read_context-&gt;resp-&gt;mutable_error(), result.status(), TabletServerErrorPB::UNKNOWN_ERROR,</a>
<a name="ln1889">          read_context-&gt;context);</a>
<a name="ln1890">      return;</a>
<a name="ln1891">    }</a>
<a name="ln1892">    read_context-&gt;read_time = *result;</a>
<a name="ln1893">    // If read was successful, then restart time is invalid. Finishing.</a>
<a name="ln1894">    if (!read_context-&gt;read_time) {</a>
<a name="ln1895">      break;</a>
<a name="ln1896">    }</a>
<a name="ln1897">    if (!read_context-&gt;allow_retry) {</a>
<a name="ln1898">      // The read time is specified, than we read as part of transaction. So we should restart</a>
<a name="ln1899">      // whole transaction. In this case we report restart time and abort reading.</a>
<a name="ln1900">      read_context-&gt;resp-&gt;Clear();</a>
<a name="ln1901">      auto restart_read_time = read_context-&gt;resp-&gt;mutable_restart_read_time();</a>
<a name="ln1902">      restart_read_time-&gt;set_read_ht(read_context-&gt;read_time.read.ToUint64());</a>
<a name="ln1903">      restart_read_time-&gt;set_local_limit_ht(read_context-&gt;read_time.local_limit.ToUint64());</a>
<a name="ln1904">      // Global limit is ignored by caller, so we don't set it.</a>
<a name="ln1905">      down_cast&lt;Tablet*&gt;(read_context-&gt;tablet.get())-&gt;metrics()-&gt;restart_read_requests-&gt;Increment();</a>
<a name="ln1906">      break;</a>
<a name="ln1907">    }</a>
<a name="ln1908"> </a>
<a name="ln1909">    if (CoarseMonoClock::now() &gt; read_context-&gt;context-&gt;GetClientDeadline()) {</a>
<a name="ln1910">      TRACE(&quot;Read timed out&quot;);</a>
<a name="ln1911">      SetupErrorAndRespond(read_context-&gt;resp-&gt;mutable_error(), STATUS(TimedOut, &quot;&quot;),</a>
<a name="ln1912">                           TabletServerErrorPB::UNKNOWN_ERROR, read_context-&gt;context);</a>
<a name="ln1913">      return;</a>
<a name="ln1914">    }</a>
<a name="ln1915">  }</a>
<a name="ln1916">  if (read_context-&gt;req-&gt;include_trace() &amp;&amp; Trace::CurrentTrace() != nullptr) {</a>
<a name="ln1917">    read_context-&gt;resp-&gt;set_trace_buffer(Trace::CurrentTrace()-&gt;DumpToString(true));</a>
<a name="ln1918">  }</a>
<a name="ln1919"> </a>
<a name="ln1920">  // It was read as part of transaction, but read time was not specified.</a>
<a name="ln1921">  // I.e. allow_retry is true.</a>
<a name="ln1922">  // So we just picked a read time and we should tell it back to the caller.</a>
<a name="ln1923">  if (read_context-&gt;req-&gt;has_transaction() &amp;&amp; read_context-&gt;allow_retry) {</a>
<a name="ln1924">    read_context-&gt;used_read_time.ToPB(read_context-&gt;resp-&gt;mutable_used_read_time());</a>
<a name="ln1925">  }</a>
<a name="ln1926"> </a>
<a name="ln1927">  // Useful when debugging transactions</a>
<a name="ln1928">#if defined(DUMP_READ)</a>
<a name="ln1929">  if (read_context-&gt;req-&gt;has_transaction() &amp;&amp; read_context-&gt;req-&gt;pgsql_batch().size() == 1 &amp;&amp;</a>
<a name="ln1930">      read_context-&gt;req-&gt;pgsql_batch()[0].partition_column_values().size() == 1 &amp;&amp;</a>
<a name="ln1931">      read_context-&gt;resp-&gt;pgsql_batch().size() == 1 &amp;&amp;</a>
<a name="ln1932">      read_context-&gt;resp-&gt;pgsql_batch()[0].rows_data_sidecar() == 0) {</a>
<a name="ln1933">    auto txn_id = CHECK_RESULT(FullyDecodeTransactionId(</a>
<a name="ln1934">        read_context-&gt;req-&gt;transaction().transaction_id()));</a>
<a name="ln1935">    auto value_slice = read_context-&gt;context-&gt;RpcSidecar(0).as_slice();</a>
<a name="ln1936">    auto num = BigEndian::Load64(value_slice.data());</a>
<a name="ln1937">    std::string result;</a>
<a name="ln1938">    if (num == 0) {</a>
<a name="ln1939">      result = &quot;&lt;NONE&gt;&quot;;</a>
<a name="ln1940">    } else if (num == 1) {</a>
<a name="ln1941">      auto len = BigEndian::Load64(value_slice.data() + 14) - 1;</a>
<a name="ln1942">      result = Slice(value_slice.data() + 22, len).ToBuffer();</a>
<a name="ln1943">    } else {</a>
<a name="ln1944">      result = value_slice.ToDebugHexString();</a>
<a name="ln1945">    }</a>
<a name="ln1946">    auto key = read_context-&gt;req-&gt;pgsql_batch(0).partition_column_values(0).value().int32_value();</a>
<a name="ln1947">    LOG(INFO) &lt;&lt; txn_id &lt;&lt; &quot; READ DONE: &quot; &lt;&lt; key &lt;&lt; &quot; = &quot; &lt;&lt; result;</a>
<a name="ln1948">  }</a>
<a name="ln1949">#endif</a>
<a name="ln1950"> </a>
<a name="ln1951">  RpcOperationCompletionCallback&lt;ReadResponsePB&gt; callback(</a>
<a name="ln1952">      std::move(*read_context-&gt;context), read_context-&gt;resp, server_-&gt;Clock());</a>
<a name="ln1953">  callback.OperationCompleted();</a>
<a name="ln1954">  TRACE(&quot;Done Read&quot;);</a>
<a name="ln1955">}</a>
<a name="ln1956"> </a>
<a name="ln1957">void HandleRedisReadRequestAsync(</a>
<a name="ln1958">    tablet::AbstractTablet* tablet,</a>
<a name="ln1959">    CoarseTimePoint deadline,</a>
<a name="ln1960">    const ReadHybridTime&amp; read_time,</a>
<a name="ln1961">    const RedisReadRequestPB&amp; redis_read_request,</a>
<a name="ln1962">    RedisResponsePB* response,</a>
<a name="ln1963">    const std::function&lt;void(const Status&amp; s)&gt;&amp; status_cb</a>
<a name="ln1964">) {</a>
<a name="ln1965">  status_cb(tablet-&gt;HandleRedisReadRequest(deadline, read_time, redis_read_request, response));</a>
<a name="ln1966">}</a>
<a name="ln1967"> </a>
<a name="ln1968">Result&lt;ReadHybridTime&gt; TabletServiceImpl::DoRead(ReadContext* read_context) {</a>
<a name="ln1969">  auto read_tx = VERIFY_RESULT(</a>
<a name="ln1970">      tablet::ScopedReadOperation::Create(</a>
<a name="ln1971">          read_context-&gt;tablet.get(), read_context-&gt;require_lease, read_context-&gt;read_time));</a>
<a name="ln1972">  read_context-&gt;used_read_time = read_tx.read_time();</a>
<a name="ln1973">  if (!read_context-&gt;req-&gt;redis_batch().empty()) {</a>
<a name="ln1974">    // Assert the primary table is a redis table.</a>
<a name="ln1975">    DCHECK_EQ(read_context-&gt;tablet-&gt;table_type(), TableType::REDIS_TABLE_TYPE);</a>
<a name="ln1976">    size_t count = read_context-&gt;req-&gt;redis_batch_size();</a>
<a name="ln1977">    std::vector&lt;Status&gt; rets(count);</a>
<a name="ln1978">    CountDownLatch latch(count);</a>
<a name="ln1979">    for (int idx = 0; idx &lt; count; idx++) {</a>
<a name="ln1980">      const RedisReadRequestPB&amp; redis_read_req = read_context-&gt;req-&gt;redis_batch(idx);</a>
<a name="ln1981">      Status &amp;failed_status_ = rets[idx];</a>
<a name="ln1982">      auto cb = [&amp;latch, &amp;failed_status_] (const Status &amp;status) -&gt; void {</a>
<a name="ln1983">                  if (!status.ok())</a>
<a name="ln1984">                    failed_status_ = status;</a>
<a name="ln1985">                  latch.CountDown(1);</a>
<a name="ln1986">                };</a>
<a name="ln1987">      auto func = Bind(</a>
<a name="ln1988">          &amp;HandleRedisReadRequestAsync,</a>
<a name="ln1989">          Unretained(read_context-&gt;tablet.get()),</a>
<a name="ln1990">          read_context-&gt;context-&gt;GetClientDeadline(),</a>
<a name="ln1991">          read_tx.read_time(),</a>
<a name="ln1992">          redis_read_req,</a>
<a name="ln1993">          Unretained(read_context-&gt;resp-&gt;add_redis_batch()),</a>
<a name="ln1994">          cb);</a>
<a name="ln1995"> </a>
<a name="ln1996">      Status s;</a>
<a name="ln1997">      bool run_async = FLAGS_parallelize_read_ops &amp;&amp; (idx != count - 1);</a>
<a name="ln1998">      if (run_async) {</a>
<a name="ln1999">        s = server_-&gt;tablet_manager()-&gt;read_pool()-&gt;SubmitClosure(func);</a>
<a name="ln2000">      }</a>
<a name="ln2001"> </a>
<a name="ln2002">      if (!s.ok() || !run_async) {</a>
<a name="ln2003">        func.Run();</a>
<a name="ln2004">      }</a>
<a name="ln2005">    }</a>
<a name="ln2006">    latch.Wait();</a>
<a name="ln2007">    std::vector&lt;Status&gt; failed;</a>
<a name="ln2008">    for (auto&amp; status : rets) {</a>
<a name="ln2009">      if (!status.ok()) {</a>
<a name="ln2010">        failed.push_back(status);</a>
<a name="ln2011">      }</a>
<a name="ln2012">    }</a>
<a name="ln2013">    if (failed.size() == 0) {</a>
<a name="ln2014">      // TODO(dtxn) implement read restart for Redis.</a>
<a name="ln2015">      return ReadHybridTime();</a>
<a name="ln2016">    } else if (failed.size() == 1) {</a>
<a name="ln2017">      return failed[0];</a>
<a name="ln2018">    } else {</a>
<a name="ln2019">      return STATUS(Combined, VectorToString(failed));</a>
<a name="ln2020">    }</a>
<a name="ln2021">  }</a>
<a name="ln2022"> </a>
<a name="ln2023">  if (!read_context-&gt;req-&gt;ql_batch().empty()) {</a>
<a name="ln2024">    // Assert the primary table is a YQL table.</a>
<a name="ln2025">    DCHECK_EQ(read_context-&gt;tablet-&gt;table_type(), TableType::YQL_TABLE_TYPE);</a>
<a name="ln2026">    ReadRequestPB* mutable_req = const_cast&lt;ReadRequestPB*&gt;(read_context-&gt;req);</a>
<a name="ln2027">    for (QLReadRequestPB&amp; ql_read_req : *mutable_req-&gt;mutable_ql_batch()) {</a>
<a name="ln2028">      // Update the remote endpoint.</a>
<a name="ln2029">      ql_read_req.set_allocated_remote_endpoint(read_context-&gt;host_port_pb);</a>
<a name="ln2030">      ql_read_req.set_allocated_proxy_uuid(mutable_req-&gt;mutable_proxy_uuid());</a>
<a name="ln2031">      auto se = ScopeExit([&amp;ql_read_req] {</a>
<a name="ln2032">        ql_read_req.release_remote_endpoint();</a>
<a name="ln2033">        ql_read_req.release_proxy_uuid();</a>
<a name="ln2034">      });</a>
<a name="ln2035"> </a>
<a name="ln2036">      tablet::QLReadRequestResult result;</a>
<a name="ln2037">      TRACE(&quot;Start HandleQLReadRequest&quot;);</a>
<a name="ln2038">      RETURN_NOT_OK(read_context-&gt;tablet-&gt;HandleQLReadRequest(</a>
<a name="ln2039">          read_context-&gt;context-&gt;GetClientDeadline(), read_tx.read_time(), ql_read_req,</a>
<a name="ln2040">          read_context-&gt;req-&gt;transaction(), &amp;result));</a>
<a name="ln2041">      TRACE(&quot;Done HandleQLReadRequest&quot;);</a>
<a name="ln2042">      if (result.restart_read_ht.is_valid()) {</a>
<a name="ln2043">        DCHECK_GT(result.restart_read_ht, read_context-&gt;read_time.read);</a>
<a name="ln2044">        VLOG(1) &lt;&lt; &quot;Restart read required at: &quot; &lt;&lt; result.restart_read_ht</a>
<a name="ln2045">                &lt;&lt; &quot;, original: &quot; &lt;&lt; read_context-&gt;read_time;</a>
<a name="ln2046">        read_context-&gt;read_time.read = result.restart_read_ht;</a>
<a name="ln2047">        read_context-&gt;read_time.local_limit = read_context-&gt;safe_ht_to_read;</a>
<a name="ln2048">        return read_context-&gt;read_time;</a>
<a name="ln2049">      }</a>
<a name="ln2050">      result.response.set_rows_data_sidecar(read_context-&gt;context-&gt;AddRpcSidecar(result.rows_data));</a>
<a name="ln2051">      read_context-&gt;resp-&gt;add_ql_batch()-&gt;Swap(&amp;result.response);</a>
<a name="ln2052">    }</a>
<a name="ln2053">    return ReadHybridTime();</a>
<a name="ln2054">  }</a>
<a name="ln2055"> </a>
<a name="ln2056">  if (!read_context-&gt;req-&gt;pgsql_batch().empty()) {</a>
<a name="ln2057">    ReadRequestPB* mutable_req = const_cast&lt;ReadRequestPB*&gt;(read_context-&gt;req);</a>
<a name="ln2058">    for (PgsqlReadRequestPB&amp; pgsql_read_req : *mutable_req-&gt;mutable_pgsql_batch()) {</a>
<a name="ln2059">      tablet::PgsqlReadRequestResult result;</a>
<a name="ln2060">      TRACE(&quot;Start HandlePgsqlReadRequest&quot;);</a>
<a name="ln2061">      RETURN_NOT_OK(read_context-&gt;tablet-&gt;HandlePgsqlReadRequest(</a>
<a name="ln2062">          read_context-&gt;context-&gt;GetClientDeadline(), read_tx.read_time(), pgsql_read_req,</a>
<a name="ln2063">          read_context-&gt;req-&gt;transaction(), &amp;result));</a>
<a name="ln2064">      TRACE(&quot;Done HandlePgsqlReadRequest&quot;);</a>
<a name="ln2065">      if (result.restart_read_ht.is_valid()) {</a>
<a name="ln2066">        VLOG(1) &lt;&lt; &quot;Restart read required at: &quot; &lt;&lt; result.restart_read_ht;</a>
<a name="ln2067">        read_context-&gt;read_time.read = result.restart_read_ht;</a>
<a name="ln2068">        read_context-&gt;read_time.local_limit = read_context-&gt;safe_ht_to_read;</a>
<a name="ln2069">        return read_context-&gt;read_time;</a>
<a name="ln2070">      }</a>
<a name="ln2071">      result.response.set_rows_data_sidecar(read_context-&gt;context-&gt;AddRpcSidecar(result.rows_data));</a>
<a name="ln2072">      read_context-&gt;resp-&gt;add_pgsql_batch()-&gt;Swap(&amp;result.response);</a>
<a name="ln2073">    }</a>
<a name="ln2074">    return ReadHybridTime();</a>
<a name="ln2075">  }</a>
<a name="ln2076"> </a>
<a name="ln2077">  if (read_context-&gt;tablet-&gt;table_type() == TableType::TRANSACTION_STATUS_TABLE_TYPE) {</a>
<a name="ln2078">    return STATUS(NotSupported, &quot;Transaction status table does not support read&quot;);</a>
<a name="ln2079">  }</a>
<a name="ln2080"> </a>
<a name="ln2081">  return ReadHybridTime();</a>
<a name="ln2082">}</a>
<a name="ln2083"> </a>
<a name="ln2084">ConsensusServiceImpl::ConsensusServiceImpl(const scoped_refptr&lt;MetricEntity&gt;&amp; metric_entity,</a>
<a name="ln2085">                                           TabletPeerLookupIf* tablet_manager)</a>
<a name="ln2086">    : ConsensusServiceIf(metric_entity),</a>
<a name="ln2087">      tablet_manager_(tablet_manager) {</a>
<a name="ln2088">}</a>
<a name="ln2089"> </a>
<a name="ln2090">ConsensusServiceImpl::~ConsensusServiceImpl() {</a>
<a name="ln2091">}</a>
<a name="ln2092"> </a>
<a name="ln2093">void ConsensusServiceImpl::UpdateConsensus(const ConsensusRequestPB* req,</a>
<a name="ln2094">                                           ConsensusResponsePB* resp,</a>
<a name="ln2095">                                           rpc::RpcContext context) {</a>
<a name="ln2096">  DVLOG(3) &lt;&lt; &quot;Received Consensus Update RPC: &quot; &lt;&lt; req-&gt;ShortDebugString();</a>
<a name="ln2097">  if (!CheckUuidMatchOrRespond(tablet_manager_, &quot;UpdateConsensus&quot;, req, resp, &amp;context)) {</a>
<a name="ln2098">    return;</a>
<a name="ln2099">  }</a>
<a name="ln2100">  auto tablet_peer = VERIFY_RESULT_OR_RETURN(LookupTabletPeerOrRespond(</a>
<a name="ln2101">      tablet_manager_, req-&gt;tablet_id(), resp, &amp;context));</a>
<a name="ln2102"> </a>
<a name="ln2103">  // Submit the update directly to the TabletPeer's Consensus instance.</a>
<a name="ln2104">  shared_ptr&lt;Consensus&gt; consensus;</a>
<a name="ln2105">  if (!GetConsensusOrRespond(tablet_peer, resp, &amp;context, &amp;consensus)) return;</a>
<a name="ln2106"> </a>
<a name="ln2107">  // Unfortunately, we have to use const_cast here, because the protobuf-generated interface only</a>
<a name="ln2108">  // gives us a const request, but we need to be able to move messages out of the request for</a>
<a name="ln2109">  // efficiency.</a>
<a name="ln2110">  Status s = consensus-&gt;Update(</a>
<a name="ln2111">      const_cast&lt;ConsensusRequestPB*&gt;(req), resp, context.GetClientDeadline());</a>
<a name="ln2112">  if (PREDICT_FALSE(!s.ok())) {</a>
<a name="ln2113">    // Clear the response first, since a partially-filled response could</a>
<a name="ln2114">    // result in confusing a caller, or in having missing required fields</a>
<a name="ln2115">    // in embedded optional messages.</a>
<a name="ln2116">    resp-&gt;Clear();</a>
<a name="ln2117"> </a>
<a name="ln2118">    SetupErrorAndRespond(resp-&gt;mutable_error(), s,</a>
<a name="ln2119">                         TabletServerErrorPB::UNKNOWN_ERROR,</a>
<a name="ln2120">                         &amp;context);</a>
<a name="ln2121">    return;</a>
<a name="ln2122">  }</a>
<a name="ln2123"> </a>
<a name="ln2124">  auto tablet = tablet_peer-&gt;shared_tablet();</a>
<a name="ln2125">  if (tablet) {</a>
<a name="ln2126">    resp-&gt;set_num_sst_files(tablet-&gt;GetCurrentVersionNumSSTFiles());</a>
<a name="ln2127">  }</a>
<a name="ln2128"> </a>
<a name="ln2129">  resp-&gt;set_propagated_hybrid_time(tablet_peer-&gt;clock().Now().ToUint64());</a>
<a name="ln2130">  context.RespondSuccess();</a>
<a name="ln2131">}</a>
<a name="ln2132"> </a>
<a name="ln2133">void ConsensusServiceImpl::RequestConsensusVote(const VoteRequestPB* req,</a>
<a name="ln2134">                                                VoteResponsePB* resp,</a>
<a name="ln2135">                                                rpc::RpcContext context) {</a>
<a name="ln2136">  DVLOG(3) &lt;&lt; &quot;Received Consensus Request Vote RPC: &quot; &lt;&lt; req-&gt;DebugString();</a>
<a name="ln2137">  if (!CheckUuidMatchOrRespond(tablet_manager_, &quot;RequestConsensusVote&quot;, req, resp, &amp;context)) {</a>
<a name="ln2138">    return;</a>
<a name="ln2139">  }</a>
<a name="ln2140">  auto tablet_peer = VERIFY_RESULT_OR_RETURN(LookupTabletPeerOrRespond(</a>
<a name="ln2141">      tablet_manager_, req-&gt;tablet_id(), resp, &amp;context));</a>
<a name="ln2142"> </a>
<a name="ln2143">  // Submit the vote request directly to the consensus instance.</a>
<a name="ln2144">  shared_ptr&lt;Consensus&gt; consensus;</a>
<a name="ln2145">  if (!GetConsensusOrRespond(tablet_peer, resp, &amp;context, &amp;consensus)) return;</a>
<a name="ln2146">  Status s = consensus-&gt;RequestVote(req, resp);</a>
<a name="ln2147">  RETURN_UNKNOWN_ERROR_IF_NOT_OK(s, resp, &amp;context);</a>
<a name="ln2148">  context.RespondSuccess();</a>
<a name="ln2149">}</a>
<a name="ln2150"> </a>
<a name="ln2151">void ConsensusServiceImpl::ChangeConfig(const ChangeConfigRequestPB* req,</a>
<a name="ln2152">                                        ChangeConfigResponsePB* resp,</a>
<a name="ln2153">                                        RpcContext context) {</a>
<a name="ln2154">  VLOG(1) &lt;&lt; &quot;Received ChangeConfig RPC: &quot; &lt;&lt; req-&gt;ShortDebugString();</a>
<a name="ln2155">  // If the destination uuid is empty string, it means the client was retrying after a leader</a>
<a name="ln2156">  // stepdown and did not have a chance to update the uuid inside the request.</a>
<a name="ln2157">  // TODO: Note that this can be removed once Java YBClient will reset change config's uuid</a>
<a name="ln2158">  // correctly after leader step down.</a>
<a name="ln2159">  if (req-&gt;dest_uuid() != &quot;&quot; &amp;&amp;</a>
<a name="ln2160">      !CheckUuidMatchOrRespond(tablet_manager_, &quot;ChangeConfig&quot;, req, resp, &amp;context)) {</a>
<a name="ln2161">    return;</a>
<a name="ln2162">  }</a>
<a name="ln2163">  auto tablet_peer = VERIFY_RESULT_OR_RETURN(LookupTabletPeerOrRespond(</a>
<a name="ln2164">      tablet_manager_, req-&gt;tablet_id(), resp, &amp;context));</a>
<a name="ln2165"> </a>
<a name="ln2166">  shared_ptr&lt;Consensus&gt; consensus;</a>
<a name="ln2167">  if (!GetConsensusOrRespond(tablet_peer, resp, &amp;context, &amp;consensus)) return;</a>
<a name="ln2168">  boost::optional&lt;TabletServerErrorPB::Code&gt; error_code;</a>
<a name="ln2169">  std::shared_ptr&lt;RpcContext&gt; context_ptr = std::make_shared&lt;RpcContext&gt;(std::move(context));</a>
<a name="ln2170">  Status s = consensus-&gt;ChangeConfig(*req, BindHandleResponse(resp, context_ptr), &amp;error_code);</a>
<a name="ln2171">  VLOG(1) &lt;&lt; &quot;Sent ChangeConfig req &quot; &lt;&lt; req-&gt;ShortDebugString() &lt;&lt; &quot; to consensus layer.&quot;;</a>
<a name="ln2172">  if (PREDICT_FALSE(!s.ok())) {</a>
<a name="ln2173">    HandleErrorResponse(resp, context_ptr.get(), s, error_code);</a>
<a name="ln2174">    return;</a>
<a name="ln2175">  }</a>
<a name="ln2176">  // The success case is handled when the callback fires.</a>
<a name="ln2177">}</a>
<a name="ln2178"> </a>
<a name="ln2179">void ConsensusServiceImpl::GetNodeInstance(const GetNodeInstanceRequestPB* req,</a>
<a name="ln2180">                                           GetNodeInstanceResponsePB* resp,</a>
<a name="ln2181">                                           rpc::RpcContext context) {</a>
<a name="ln2182">  DVLOG(3) &lt;&lt; &quot;Received Get Node Instance RPC: &quot; &lt;&lt; req-&gt;DebugString();</a>
<a name="ln2183">  resp-&gt;mutable_node_instance()-&gt;CopyFrom(tablet_manager_-&gt;NodeInstance());</a>
<a name="ln2184">  auto status = tablet_manager_-&gt;GetRegistration(resp-&gt;mutable_registration());</a>
<a name="ln2185">  if (!status.ok()) {</a>
<a name="ln2186">    context.RespondFailure(status);</a>
<a name="ln2187">  } else {</a>
<a name="ln2188">    context.RespondSuccess();</a>
<a name="ln2189">  }</a>
<a name="ln2190">}</a>
<a name="ln2191"> </a>
<a name="ln2192">namespace {</a>
<a name="ln2193"> </a>
<a name="ln2194">class RpcScope {</a>
<a name="ln2195"> public:</a>
<a name="ln2196">  template&lt;class Req, class Resp&gt;</a>
<a name="ln2197">  RpcScope(TabletPeerLookupIf* tablet_manager,</a>
<a name="ln2198">           const char* method_name,</a>
<a name="ln2199">           const Req* req,</a>
<a name="ln2200">           Resp* resp,</a>
<a name="ln2201">           rpc::RpcContext* context)</a>
<a name="ln2202">      : context_(context) {</a>
<a name="ln2203">    if (!CheckUuidMatchOrRespond(tablet_manager, method_name, req, resp, context)) {</a>
<a name="ln2204">      return;</a>
<a name="ln2205">    }</a>
<a name="ln2206">    auto tablet_peer = VERIFY_RESULT_OR_RETURN(LookupTabletPeerOrRespond(</a>
<a name="ln2207">        tablet_manager, req-&gt;tablet_id(), resp, context));</a>
<a name="ln2208"> </a>
<a name="ln2209">    if (!GetConsensusOrRespond(tablet_peer, resp, context, &amp;consensus_)) {</a>
<a name="ln2210">      return;</a>
<a name="ln2211">    }</a>
<a name="ln2212">    responded_ = false;</a>
<a name="ln2213">  }</a>
<a name="ln2214"> </a>
<a name="ln2215">  ~RpcScope() {</a>
<a name="ln2216">    if (!responded_) {</a>
<a name="ln2217">      context_-&gt;RespondSuccess();</a>
<a name="ln2218">    }</a>
<a name="ln2219">  }</a>
<a name="ln2220"> </a>
<a name="ln2221">  template&lt;class Resp&gt;</a>
<a name="ln2222">  void CheckStatus(const Status&amp; status, Resp* resp) {</a>
<a name="ln2223">    if (!status.ok()) {</a>
<a name="ln2224">      LOG(INFO) &lt;&lt; &quot;Status failed: &quot; &lt;&lt; status.ToString();</a>
<a name="ln2225">      SetupErrorAndRespond(resp-&gt;mutable_error(), status,</a>
<a name="ln2226">                           TabletServerErrorPB::UNKNOWN_ERROR,</a>
<a name="ln2227">                           context_);</a>
<a name="ln2228">      responded_ = true;</a>
<a name="ln2229">    }</a>
<a name="ln2230">  }</a>
<a name="ln2231"> </a>
<a name="ln2232">  Consensus* operator-&gt;() {</a>
<a name="ln2233">    return consensus_.get();</a>
<a name="ln2234">  }</a>
<a name="ln2235"> </a>
<a name="ln2236">  explicit operator bool() const {</a>
<a name="ln2237">    return !responded_;</a>
<a name="ln2238">  }</a>
<a name="ln2239"> </a>
<a name="ln2240"> private:</a>
<a name="ln2241">  rpc::RpcContext* context_;</a>
<a name="ln2242">  bool responded_ = true;</a>
<a name="ln2243">  shared_ptr&lt;Consensus&gt; consensus_;</a>
<a name="ln2244">};</a>
<a name="ln2245"> </a>
<a name="ln2246">} // namespace</a>
<a name="ln2247"> </a>
<a name="ln2248">void ConsensusServiceImpl::RunLeaderElection(const RunLeaderElectionRequestPB* req,</a>
<a name="ln2249">                                             RunLeaderElectionResponsePB* resp,</a>
<a name="ln2250">                                             rpc::RpcContext context) {</a>
<a name="ln2251">  VLOG(1) &lt;&lt; &quot;Received Run Leader Election RPC: &quot; &lt;&lt; req-&gt;DebugString();</a>
<a name="ln2252">  RpcScope scope(tablet_manager_, &quot;RunLeaderElection&quot;, req, resp, &amp;context);</a>
<a name="ln2253">  if (!scope) {</a>
<a name="ln2254">    return;</a>
<a name="ln2255">  }</a>
<a name="ln2256">  Status s = scope-&gt;StartElection(</a>
<a name="ln2257">      { consensus::ElectionMode::ELECT_EVEN_IF_LEADER_IS_ALIVE,</a>
<a name="ln2258">        req-&gt;has_committed_index(),</a>
<a name="ln2259">        req-&gt;committed_index(),</a>
<a name="ln2260">        req-&gt;has_originator_uuid() ? req-&gt;originator_uuid() : std::string(),</a>
<a name="ln2261">        consensus::TEST_SuppressVoteRequest(</a>
<a name="ln2262">          req-&gt;has_suppress_vote_request() &amp;&amp; req-&gt;suppress_vote_request()) });</a>
<a name="ln2263">  scope.CheckStatus(s, resp);</a>
<a name="ln2264">}</a>
<a name="ln2265"> </a>
<a name="ln2266">void ConsensusServiceImpl::LeaderElectionLost(const consensus::LeaderElectionLostRequestPB *req,</a>
<a name="ln2267">                                              consensus::LeaderElectionLostResponsePB *resp,</a>
<a name="ln2268">                                              ::yb::rpc::RpcContext context) {</a>
<a name="ln2269">  LOG(INFO) &lt;&lt; &quot;LeaderElectionLost, req: &quot; &lt;&lt; req-&gt;ShortDebugString();</a>
<a name="ln2270">  RpcScope scope(tablet_manager_, &quot;LeaderElectionLost&quot;, req, resp, &amp;context);</a>
<a name="ln2271">  if (!scope) {</a>
<a name="ln2272">    return;</a>
<a name="ln2273">  }</a>
<a name="ln2274">  auto status = scope-&gt;ElectionLostByProtege(req-&gt;election_lost_by_uuid());</a>
<a name="ln2275">  scope.CheckStatus(status, resp);</a>
<a name="ln2276">  LOG(INFO) &lt;&lt; &quot;LeaderElectionLost, outcome: &quot; &lt;&lt; (scope ? &quot;success&quot; : &quot;failure&quot;) &lt;&lt; &quot;req: &quot;</a>
<a name="ln2277">            &lt;&lt; req-&gt;ShortDebugString();</a>
<a name="ln2278">}</a>
<a name="ln2279"> </a>
<a name="ln2280">void ConsensusServiceImpl::LeaderStepDown(const LeaderStepDownRequestPB* req,</a>
<a name="ln2281">                                          LeaderStepDownResponsePB* resp,</a>
<a name="ln2282">                                          RpcContext context) {</a>
<a name="ln2283">  LOG(INFO) &lt;&lt; &quot;Received Leader stepdown RPC: &quot; &lt;&lt; req-&gt;ShortDebugString();</a>
<a name="ln2284"> </a>
<a name="ln2285">  if (PREDICT_FALSE(FLAGS_TEST_leader_stepdown_delay_ms &gt; 0)) {</a>
<a name="ln2286">    LOG(INFO) &lt;&lt; &quot;Delaying leader stepdown for &quot;</a>
<a name="ln2287">              &lt;&lt; FLAGS_TEST_leader_stepdown_delay_ms &lt;&lt; &quot; ms.&quot;;</a>
<a name="ln2288">    SleepFor(MonoDelta::FromMilliseconds(FLAGS_TEST_leader_stepdown_delay_ms));</a>
<a name="ln2289">  }</a>
<a name="ln2290"> </a>
<a name="ln2291">  RpcScope scope(tablet_manager_, &quot;LeaderStepDown&quot;, req, resp, &amp;context);</a>
<a name="ln2292">  if (!scope) {</a>
<a name="ln2293">    return;</a>
<a name="ln2294">  }</a>
<a name="ln2295">  Status s = scope-&gt;StepDown(req, resp);</a>
<a name="ln2296">  LOG(INFO) &lt;&lt; &quot;Leader stepdown request &quot; &lt;&lt; req-&gt;ShortDebugString() &lt;&lt; &quot; success. Resp code=&quot;</a>
<a name="ln2297">            &lt;&lt; TabletServerErrorPB::Code_Name(resp-&gt;error().code());</a>
<a name="ln2298">  scope.CheckStatus(s, resp);</a>
<a name="ln2299">}</a>
<a name="ln2300"> </a>
<a name="ln2301">void ConsensusServiceImpl::GetLastOpId(const consensus::GetLastOpIdRequestPB *req,</a>
<a name="ln2302">                                       consensus::GetLastOpIdResponsePB *resp,</a>
<a name="ln2303">                                       rpc::RpcContext context) {</a>
<a name="ln2304">  DVLOG(3) &lt;&lt; &quot;Received GetLastOpId RPC: &quot; &lt;&lt; req-&gt;DebugString();</a>
<a name="ln2305">  if (!CheckUuidMatchOrRespond(tablet_manager_, &quot;GetLastOpId&quot;, req, resp, &amp;context)) {</a>
<a name="ln2306">    return;</a>
<a name="ln2307">  }</a>
<a name="ln2308">  auto tablet_peer = VERIFY_RESULT_OR_RETURN(LookupTabletPeerOrRespond(</a>
<a name="ln2309">      tablet_manager_, req-&gt;tablet_id(), resp, &amp;context));</a>
<a name="ln2310"> </a>
<a name="ln2311">  if (tablet_peer-&gt;state() != tablet::RUNNING) {</a>
<a name="ln2312">    SetupErrorAndRespond(resp-&gt;mutable_error(),</a>
<a name="ln2313">                         STATUS(ServiceUnavailable, &quot;Tablet Peer not in RUNNING state&quot;),</a>
<a name="ln2314">                         TabletServerErrorPB::TABLET_NOT_RUNNING, &amp;context);</a>
<a name="ln2315">    return;</a>
<a name="ln2316">  }</a>
<a name="ln2317">  std::shared_ptr&lt;Consensus&gt; consensus;</a>
<a name="ln2318">  if (!GetConsensusOrRespond(tablet_peer, resp, &amp;context, &amp;consensus)) return;</a>
<a name="ln2319">  if (PREDICT_FALSE(req-&gt;opid_type() == consensus::UNKNOWN_OPID_TYPE)) {</a>
<a name="ln2320">    HandleErrorResponse(resp, &amp;context,</a>
<a name="ln2321">                        STATUS(InvalidArgument, &quot;Invalid opid_type specified to GetLastOpId()&quot;));</a>
<a name="ln2322">    return;</a>
<a name="ln2323">  }</a>
<a name="ln2324">  auto op_id = consensus-&gt;GetLastOpId(req-&gt;opid_type());</a>
<a name="ln2325">  // RETURN_UNKNOWN_ERROR_IF_NOT_OK does not support Result, so have to add extra check here.</a>
<a name="ln2326">  if (!op_id.ok()) {</a>
<a name="ln2327">    RETURN_UNKNOWN_ERROR_IF_NOT_OK(op_id.status(), resp, &amp;context);</a>
<a name="ln2328">  }</a>
<a name="ln2329">  op_id-&gt;ToPB(resp-&gt;mutable_opid());</a>
<a name="ln2330">  context.RespondSuccess();</a>
<a name="ln2331">}</a>
<a name="ln2332"> </a>
<a name="ln2333">void ConsensusServiceImpl::GetConsensusState(const consensus::GetConsensusStateRequestPB *req,</a>
<a name="ln2334">                                             consensus::GetConsensusStateResponsePB *resp,</a>
<a name="ln2335">                                             rpc::RpcContext context) {</a>
<a name="ln2336">  DVLOG(3) &lt;&lt; &quot;Received GetConsensusState RPC: &quot; &lt;&lt; req-&gt;DebugString();</a>
<a name="ln2337"> </a>
<a name="ln2338">  RpcScope scope(tablet_manager_, &quot;GetConsensusState&quot;, req, resp, &amp;context);</a>
<a name="ln2339">  if (!scope) {</a>
<a name="ln2340">    return;</a>
<a name="ln2341">  }</a>
<a name="ln2342">  ConsensusConfigType type = req-&gt;type();</a>
<a name="ln2343">  if (PREDICT_FALSE(type != CONSENSUS_CONFIG_ACTIVE &amp;&amp; type != CONSENSUS_CONFIG_COMMITTED)) {</a>
<a name="ln2344">    HandleErrorResponse(resp, &amp;context,</a>
<a name="ln2345">        STATUS(InvalidArgument, Substitute(&quot;Unsupported ConsensusConfigType $0 ($1)&quot;,</a>
<a name="ln2346">                                           ConsensusConfigType_Name(type), type)));</a>
<a name="ln2347">    return;</a>
<a name="ln2348">  }</a>
<a name="ln2349">  LeaderLeaseStatus leader_lease_status;</a>
<a name="ln2350">  *resp-&gt;mutable_cstate() = scope-&gt;ConsensusState(req-&gt;type(), &amp;leader_lease_status);</a>
<a name="ln2351">  resp-&gt;set_leader_lease_status(leader_lease_status);</a>
<a name="ln2352">}</a>
<a name="ln2353"> </a>
<a name="ln2354">void ConsensusServiceImpl::StartRemoteBootstrap(const StartRemoteBootstrapRequestPB* req,</a>
<a name="ln2355">                                                StartRemoteBootstrapResponsePB* resp,</a>
<a name="ln2356">                                                rpc::RpcContext context) {</a>
<a name="ln2357">  if (!CheckUuidMatchOrRespond(tablet_manager_, &quot;StartRemoteBootstrap&quot;, req, resp, &amp;context)) {</a>
<a name="ln2358">    return;</a>
<a name="ln2359">  }</a>
<a name="ln2360">  Status s = tablet_manager_-&gt;StartRemoteBootstrap(*req);</a>
<a name="ln2361">  if (!s.ok()) {</a>
<a name="ln2362">    // Using Status::AlreadyPresent for a remote bootstrap operation that is already in progress.</a>
<a name="ln2363">    if (s.IsAlreadyPresent()) {</a>
<a name="ln2364">      YB_LOG_EVERY_N_SECS(WARNING, 30) &lt;&lt; &quot;Start remote bootstrap failed: &quot; &lt;&lt; s;</a>
<a name="ln2365">      SetupErrorAndRespond(resp-&gt;mutable_error(), s, TabletServerErrorPB::ALREADY_IN_PROGRESS,</a>
<a name="ln2366">                           &amp;context);</a>
<a name="ln2367">      return;</a>
<a name="ln2368">    } else {</a>
<a name="ln2369">      LOG(WARNING) &lt;&lt; &quot;Start remote bootstrap failed: &quot; &lt;&lt; s;</a>
<a name="ln2370">    }</a>
<a name="ln2371">  }</a>
<a name="ln2372"> </a>
<a name="ln2373">  RETURN_UNKNOWN_ERROR_IF_NOT_OK(s, resp, &amp;context);</a>
<a name="ln2374">  context.RespondSuccess();</a>
<a name="ln2375">}</a>
<a name="ln2376"> </a>
<a name="ln2377">void TabletServiceImpl::NoOp(const NoOpRequestPB *req,</a>
<a name="ln2378">                             NoOpResponsePB *resp,</a>
<a name="ln2379">                             rpc::RpcContext context) {</a>
<a name="ln2380">  context.RespondSuccess();</a>
<a name="ln2381">}</a>
<a name="ln2382"> </a>
<a name="ln2383">void TabletServiceImpl::Publish(</a>
<a name="ln2384">    const PublishRequestPB* req, PublishResponsePB* resp, rpc::RpcContext context) {</a>
<a name="ln2385">  rpc::Publisher* publisher = server_-&gt;GetPublisher();</a>
<a name="ln2386">  resp-&gt;set_num_clients_forwarded_to(publisher ? (*publisher)(req-&gt;channel(), req-&gt;message()) : 0);</a>
<a name="ln2387">  context.RespondSuccess();</a>
<a name="ln2388">}</a>
<a name="ln2389"> </a>
<a name="ln2390">void TabletServiceImpl::ListTablets(const ListTabletsRequestPB* req,</a>
<a name="ln2391">                                    ListTabletsResponsePB* resp,</a>
<a name="ln2392">                                    rpc::RpcContext context) {</a>
<a name="ln2393">  TabletPeers peers;</a>
<a name="ln2394">  server_-&gt;tablet_manager()-&gt;GetTabletPeers(&amp;peers);</a>
<a name="ln2395">  RepeatedPtrField&lt;StatusAndSchemaPB&gt;* peer_status = resp-&gt;mutable_status_and_schema();</a>
<a name="ln2396">  for (const TabletPeerPtr&amp; peer : peers) {</a>
<a name="ln2397">    StatusAndSchemaPB* status = peer_status-&gt;Add();</a>
<a name="ln2398">    peer-&gt;GetTabletStatusPB(status-&gt;mutable_tablet_status());</a>
<a name="ln2399">    SchemaToPB(*peer-&gt;status_listener()-&gt;schema(), status-&gt;mutable_schema());</a>
<a name="ln2400">    peer-&gt;tablet_metadata()-&gt;partition_schema()-&gt;ToPB(status-&gt;mutable_partition_schema());</a>
<a name="ln2401">  }</a>
<a name="ln2402">  context.RespondSuccess();</a>
<a name="ln2403">}</a>
<a name="ln2404"> </a>
<a name="ln2405">void TabletServiceImpl::GetMasterAddresses(const GetMasterAddressesRequestPB* req,</a>
<a name="ln2406">                                           GetMasterAddressesResponsePB* resp,</a>
<a name="ln2407">                                           rpc::RpcContext context) {</a>
<a name="ln2408">  resp-&gt;set_master_addresses(server::MasterAddressesToString(</a>
<a name="ln2409">      *server_-&gt;tablet_manager()-&gt;server()-&gt;options().GetMasterAddresses()));</a>
<a name="ln2410">  context.RespondSuccess();</a>
<a name="ln2411">}</a>
<a name="ln2412"> </a>
<a name="ln2413">void TabletServiceImpl::GetLogLocation(</a>
<a name="ln2414">    const GetLogLocationRequestPB* req,</a>
<a name="ln2415">    GetLogLocationResponsePB* resp,</a>
<a name="ln2416">    rpc::RpcContext context) {</a>
<a name="ln2417">  resp-&gt;set_log_location(FLAGS_log_dir);</a>
<a name="ln2418">  context.RespondSuccess();</a>
<a name="ln2419">}</a>
<a name="ln2420"> </a>
<a name="ln2421">void TabletServiceImpl::ListTabletsForTabletServer(const ListTabletsForTabletServerRequestPB* req,</a>
<a name="ln2422">                                                   ListTabletsForTabletServerResponsePB* resp,</a>
<a name="ln2423">                                                   rpc::RpcContext context) {</a>
<a name="ln2424">  // Replicating logic from path-handlers.</a>
<a name="ln2425">  TabletPeers peers;</a>
<a name="ln2426">  server_-&gt;tablet_manager()-&gt;GetTabletPeers(&amp;peers);</a>
<a name="ln2427">  for (const TabletPeerPtr&amp; peer : peers) {</a>
<a name="ln2428">    TabletStatusPB status;</a>
<a name="ln2429">    peer-&gt;GetTabletStatusPB(&amp;status);</a>
<a name="ln2430"> </a>
<a name="ln2431">    ListTabletsForTabletServerResponsePB::Entry* data_entry = resp-&gt;add_entries();</a>
<a name="ln2432">    data_entry-&gt;set_table_name(status.table_name());</a>
<a name="ln2433">    data_entry-&gt;set_tablet_id(status.tablet_id());</a>
<a name="ln2434"> </a>
<a name="ln2435">    std::shared_ptr&lt;consensus::Consensus&gt; consensus = peer-&gt;shared_consensus();</a>
<a name="ln2436">    data_entry-&gt;set_is_leader(consensus &amp;&amp; consensus-&gt;role() == consensus::RaftPeerPB::LEADER);</a>
<a name="ln2437">    data_entry-&gt;set_state(status.state());</a>
<a name="ln2438"> </a>
<a name="ln2439">    auto tablet = peer-&gt;shared_tablet();</a>
<a name="ln2440">    uint64_t num_sst_files = tablet ? tablet-&gt;GetCurrentVersionNumSSTFiles() : 0;</a>
<a name="ln2441">    data_entry-&gt;set_num_sst_files(num_sst_files);</a>
<a name="ln2442"> </a>
<a name="ln2443">    uint64_t num_log_segments = peer-&gt;GetNumLogSegments();</a>
<a name="ln2444">    data_entry-&gt;set_num_log_segments(num_log_segments);</a>
<a name="ln2445"> </a>
<a name="ln2446">    auto num_memtables = tablet ? tablet-&gt;GetNumMemtables() : std::make_pair(0, 0);</a>
<a name="ln2447">    data_entry-&gt;set_num_memtables_intents(num_memtables.first);</a>
<a name="ln2448">    data_entry-&gt;set_num_memtables_regular(num_memtables.second);</a>
<a name="ln2449">  }</a>
<a name="ln2450"> </a>
<a name="ln2451">  context.RespondSuccess();</a>
<a name="ln2452">}</a>
<a name="ln2453"> </a>
<a name="ln2454">namespace {</a>
<a name="ln2455"> </a>
<a name="ln2456">Result&lt;uint64_t&gt; CalcChecksum(tablet::Tablet* tablet, CoarseTimePoint deadline) {</a>
<a name="ln2457">  const shared_ptr&lt;Schema&gt; schema = tablet-&gt;metadata()-&gt;schema();</a>
<a name="ln2458">  auto client_schema = schema-&gt;CopyWithoutColumnIds();</a>
<a name="ln2459">  auto iter = tablet-&gt;NewRowIterator(client_schema, boost::none, {}, &quot;&quot;, deadline);</a>
<a name="ln2460">  RETURN_NOT_OK(iter);</a>
<a name="ln2461"> </a>
<a name="ln2462">  QLTableRow value_map;</a>
<a name="ln2463">  ScanResultChecksummer collector;</a>
<a name="ln2464"> </a>
<a name="ln2465">  while (VERIFY_RESULT((**iter).HasNext())) {</a>
<a name="ln2466">    RETURN_NOT_OK((**iter).NextRow(&amp;value_map));</a>
<a name="ln2467">    collector.HandleRow(*schema, value_map);</a>
<a name="ln2468">  }</a>
<a name="ln2469"> </a>
<a name="ln2470">  return collector.agg_checksum();</a>
<a name="ln2471">}</a>
<a name="ln2472"> </a>
<a name="ln2473">} // namespace</a>
<a name="ln2474"> </a>
<a name="ln2475">void TabletServiceImpl::Checksum(const ChecksumRequestPB* req,</a>
<a name="ln2476">                                 ChecksumResponsePB* resp,</a>
<a name="ln2477">                                 rpc::RpcContext context) {</a>
<a name="ln2478">  VLOG(1) &lt;&lt; &quot;Full request: &quot; &lt;&lt; req-&gt;DebugString();</a>
<a name="ln2479"> </a>
<a name="ln2480">  std::shared_ptr&lt;tablet::AbstractTablet&gt; abstract_tablet;</a>
<a name="ln2481">  if (!DoGetTabletOrRespond(</a>
<a name="ln2482">          req, resp, &amp;context, &amp;abstract_tablet, /* tablet_peer = */ nullptr,</a>
<a name="ln2483">          AllowSplitTablet::kTrue)) {</a>
<a name="ln2484">    return;</a>
<a name="ln2485">  }</a>
<a name="ln2486">  auto checksum = CalcChecksum(</a>
<a name="ln2487">      down_cast&lt;tablet::Tablet*&gt;(abstract_tablet.get()), context.GetClientDeadline());</a>
<a name="ln2488">  if (!checksum.ok()) {</a>
<a name="ln2489">    SetupErrorAndRespond(resp-&gt;mutable_error(), checksum.status(),</a>
<a name="ln2490">                         TabletServerErrorPB::UNKNOWN_ERROR, &amp;context);</a>
<a name="ln2491">    return;</a>
<a name="ln2492">  }</a>
<a name="ln2493"> </a>
<a name="ln2494">  resp-&gt;set_checksum(*checksum);</a>
<a name="ln2495"> </a>
<a name="ln2496">  context.RespondSuccess();</a>
<a name="ln2497">}</a>
<a name="ln2498"> </a>
<a name="ln2499">void TabletServiceImpl::ImportData(const ImportDataRequestPB* req,</a>
<a name="ln2500">                                   ImportDataResponsePB* resp,</a>
<a name="ln2501">                                   rpc::RpcContext context) {</a>
<a name="ln2502">  auto peer = VERIFY_RESULT_OR_RETURN(LookupTabletPeerOrRespond(</a>
<a name="ln2503">      server_-&gt;tablet_peer_lookup(), req-&gt;tablet_id(), resp, &amp;context));</a>
<a name="ln2504"> </a>
<a name="ln2505">  auto status = peer-&gt;tablet()-&gt;ImportData(req-&gt;source_dir());</a>
<a name="ln2506">  if (!status.ok()) {</a>
<a name="ln2507">    SetupErrorAndRespond(resp-&gt;mutable_error(),</a>
<a name="ln2508">                         status,</a>
<a name="ln2509">                         TabletServerErrorPB::UNKNOWN_ERROR,</a>
<a name="ln2510">                         &amp;context);</a>
<a name="ln2511">    return;</a>
<a name="ln2512">  }</a>
<a name="ln2513">  context.RespondSuccess();</a>
<a name="ln2514">}</a>
<a name="ln2515"> </a>
<a name="ln2516">void TabletServiceImpl::GetTabletStatus(const GetTabletStatusRequestPB* req,</a>
<a name="ln2517">                                        GetTabletStatusResponsePB* resp,</a>
<a name="ln2518">                                        rpc::RpcContext context) {</a>
<a name="ln2519">  const Status s = server_-&gt;GetTabletStatus(req, resp);</a>
<a name="ln2520">  if (!s.ok()) {</a>
<a name="ln2521">    SetupErrorAndRespond(resp-&gt;mutable_error(), s,</a>
<a name="ln2522">                         s.IsNotFound() ? TabletServerErrorPB::TABLET_NOT_FOUND</a>
<a name="ln2523">                                        : TabletServerErrorPB::UNKNOWN_ERROR,</a>
<a name="ln2524">                         &amp;context);</a>
<a name="ln2525">    return;</a>
<a name="ln2526">  }</a>
<a name="ln2527">  context.RespondSuccess();</a>
<a name="ln2528">}</a>
<a name="ln2529"> </a>
<a name="ln2530">void TabletServiceImpl::IsTabletServerReady(const IsTabletServerReadyRequestPB* req,</a>
<a name="ln2531">                                            IsTabletServerReadyResponsePB* resp,</a>
<a name="ln2532">                                            rpc::RpcContext context) {</a>
<a name="ln2533">  Status s = server_-&gt;tablet_manager()-&gt;GetNumTabletsPendingBootstrap(resp);</a>
<a name="ln2534">  if (!s.ok()) {</a>
<a name="ln2535">    SetupErrorAndRespond(resp-&gt;mutable_error(), s, TabletServerErrorPB::UNKNOWN_ERROR,</a>
<a name="ln2536">                         &amp;context);</a>
<a name="ln2537">    return;</a>
<a name="ln2538">  }</a>
<a name="ln2539">  context.RespondSuccess();</a>
<a name="ln2540">}</a>
<a name="ln2541"> </a>
<a name="ln2542">void TabletServiceImpl::TakeTransaction(const TakeTransactionRequestPB* req,</a>
<a name="ln2543">                                        TakeTransactionResponsePB* resp,</a>
<a name="ln2544">                                        rpc::RpcContext context) {</a>
<a name="ln2545">  auto transaction = server_-&gt;TransactionPool()-&gt;Take();</a>
<a name="ln2546">  auto metadata = transaction-&gt;Release();</a>
<a name="ln2547">  if (!metadata.ok()) {</a>
<a name="ln2548">    LOG(INFO) &lt;&lt; &quot;Take failed: &quot; &lt;&lt; metadata.status();</a>
<a name="ln2549">    context.RespondFailure(metadata.status());</a>
<a name="ln2550">    return;</a>
<a name="ln2551">  }</a>
<a name="ln2552">  metadata-&gt;ForceToPB(resp-&gt;mutable_metadata());</a>
<a name="ln2553">  VLOG(2) &lt;&lt; &quot;Taken metadata: &quot; &lt;&lt; metadata-&gt;ToString();</a>
<a name="ln2554">  context.RespondSuccess();</a>
<a name="ln2555">}</a>
<a name="ln2556"> </a>
<a name="ln2557">void TabletServiceImpl::Shutdown() {</a>
<a name="ln2558">}</a>
<a name="ln2559"> </a>
<a name="ln2560">scoped_refptr&lt;Histogram&gt; TabletServer::GetMetricsHistogram(</a>
<a name="ln2561">    TabletServerServiceIf::RpcMetricIndexes metric) {</a>
<a name="ln2562">  // Returns the metric Histogram by holding a lock to make sure tablet_server_service_ remains</a>
<a name="ln2563">  // unchanged during the operation.</a>
<a name="ln2564">  std::lock_guard&lt;simple_spinlock&gt; l(lock_);</a>
<a name="ln2565">  if (tablet_server_service_) {</a>
<a name="ln2566">    return tablet_server_service_-&gt;GetMetric(metric).handler_latency;</a>
<a name="ln2567">  }</a>
<a name="ln2568">  return nullptr;</a>
<a name="ln2569">}</a>
<a name="ln2570"> </a>
<a name="ln2571">}  // namespace tserver</a>
<a name="ln2572">}  // namespace yb</a>

</code></pre>
<div class="balloon" rel="395"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="449"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="515"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="543"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="569"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="587"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="592"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="594"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="617"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="628"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="639"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="773"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="796"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="868"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="912"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="921"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v530/" target="_blank">V530</a> The return value of function 'move' is required to be utilized.</p></div>
<div class="balloon" rel="1076"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1082"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1106"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1149"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1195"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1202"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v530/" target="_blank">V530</a> The return value of function 'move' is required to be utilized.</p></div>
<div class="balloon" rel="1260"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1335"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1450"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'tablet_data_state' should be checked here.</p></div>
<div class="balloon" rel="1540"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1601"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1696"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1713"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v530/" target="_blank">V530</a> The return value of function 'move' is required to be utilized.</p></div>
<div class="balloon" rel="1878"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="2044"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="2066"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="2096"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="2100"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v530/" target="_blank">V530</a> The return value of function 'move' is required to be utilized.</p></div>
<div class="balloon" rel="2136"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="2140"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v530/" target="_blank">V530</a> The return value of function 'move' is required to be utilized.</p></div>
<div class="balloon" rel="2154"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="2163"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v530/" target="_blank">V530</a> The return value of function 'move' is required to be utilized.</p></div>
<div class="balloon" rel="2171"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="2182"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="2206"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v530/" target="_blank">V530</a> The return value of function 'move' is required to be utilized.</p></div>
<div class="balloon" rel="2251"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="2304"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="2308"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v530/" target="_blank">V530</a> The return value of function 'move' is required to be utilized.</p></div>
<div class="balloon" rel="2336"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="2478"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="2502"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v530/" target="_blank">V530</a> The return value of function 'move' is required to be utilized.</p></div>
<div class="balloon" rel="2553"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
