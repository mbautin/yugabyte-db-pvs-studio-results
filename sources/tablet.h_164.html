
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>tablet.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Licensed to the Apache Software Foundation (ASF) under one</a>
<a name="ln2">// or more contributor license agreements.  See the NOTICE file</a>
<a name="ln3">// distributed with this work for additional information</a>
<a name="ln4">// regarding copyright ownership.  The ASF licenses this file</a>
<a name="ln5">// to you under the Apache License, Version 2.0 (the</a>
<a name="ln6">// &quot;License&quot;); you may not use this file except in compliance</a>
<a name="ln7">// with the License.  You may obtain a copy of the License at</a>
<a name="ln8">//</a>
<a name="ln9">//   http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln10">//</a>
<a name="ln11">// Unless required by applicable law or agreed to in writing,</a>
<a name="ln12">// software distributed under the License is distributed on an</a>
<a name="ln13">// &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</a>
<a name="ln14">// KIND, either express or implied.  See the License for the</a>
<a name="ln15">// specific language governing permissions and limitations</a>
<a name="ln16">// under the License.</a>
<a name="ln17">//</a>
<a name="ln18">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln19">//</a>
<a name="ln20">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln21">//</a>
<a name="ln22">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln23">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln24">//</a>
<a name="ln25">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln26">//</a>
<a name="ln27">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln28">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln29">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln30">// under the License.</a>
<a name="ln31">//</a>
<a name="ln32">#ifndef YB_TABLET_TABLET_H_</a>
<a name="ln33">#define YB_TABLET_TABLET_H_</a>
<a name="ln34"> </a>
<a name="ln35">#include &lt;iosfwd&gt;</a>
<a name="ln36">#include &lt;map&gt;</a>
<a name="ln37">#include &lt;memory&gt;</a>
<a name="ln38">#include &lt;mutex&gt;</a>
<a name="ln39">#include &lt;string&gt;</a>
<a name="ln40">#include &lt;vector&gt;</a>
<a name="ln41"> </a>
<a name="ln42">#include &quot;yb/rocksdb/cache.h&quot;</a>
<a name="ln43">#include &quot;yb/rocksdb/options.h&quot;</a>
<a name="ln44">#include &quot;yb/rocksdb/statistics.h&quot;</a>
<a name="ln45">#include &quot;yb/rocksdb/write_batch.h&quot;</a>
<a name="ln46"> </a>
<a name="ln47">#include &quot;yb/client/client.h&quot;</a>
<a name="ln48">#include &quot;yb/client/meta_data_cache.h&quot;</a>
<a name="ln49">#include &quot;yb/client/transaction_manager.h&quot;</a>
<a name="ln50"> </a>
<a name="ln51">#include &quot;yb/common/schema.h&quot;</a>
<a name="ln52">#include &quot;yb/common/transaction.h&quot;</a>
<a name="ln53">#include &quot;yb/common/ql_storage_interface.h&quot;</a>
<a name="ln54"> </a>
<a name="ln55">#include &quot;yb/docdb/docdb.pb.h&quot;</a>
<a name="ln56">#include &quot;yb/docdb/docdb.h&quot;</a>
<a name="ln57">#include &quot;yb/docdb/docdb_compaction_filter.h&quot;</a>
<a name="ln58">#include &quot;yb/docdb/doc_operation.h&quot;</a>
<a name="ln59">#include &quot;yb/docdb/ql_rocksdb_storage.h&quot;</a>
<a name="ln60">#include &quot;yb/docdb/shared_lock_manager.h&quot;</a>
<a name="ln61"> </a>
<a name="ln62">#include &quot;yb/gutil/atomicops.h&quot;</a>
<a name="ln63">#include &quot;yb/gutil/gscoped_ptr.h&quot;</a>
<a name="ln64">#include &quot;yb/gutil/macros.h&quot;</a>
<a name="ln65"> </a>
<a name="ln66">#include &quot;yb/rpc/rpc_fwd.h&quot;</a>
<a name="ln67"> </a>
<a name="ln68">#include &quot;yb/tablet/abstract_tablet.h&quot;</a>
<a name="ln69">#include &quot;yb/tablet/tablet_options.h&quot;</a>
<a name="ln70">#include &quot;yb/tablet/mvcc.h&quot;</a>
<a name="ln71">#include &quot;yb/tablet/tablet_metadata.h&quot;</a>
<a name="ln72">#include &quot;yb/tablet/transaction_participant.h&quot;</a>
<a name="ln73">#include &quot;yb/tablet/tablet_bootstrap_if.h&quot;</a>
<a name="ln74"> </a>
<a name="ln75">#include &quot;yb/util/locks.h&quot;</a>
<a name="ln76">#include &quot;yb/util/metrics.h&quot;</a>
<a name="ln77">#include &quot;yb/util/operation_counter.h&quot;</a>
<a name="ln78">#include &quot;yb/util/semaphore.h&quot;</a>
<a name="ln79">#include &quot;yb/util/slice.h&quot;</a>
<a name="ln80">#include &quot;yb/util/status.h&quot;</a>
<a name="ln81">#include &quot;yb/util/countdown_latch.h&quot;</a>
<a name="ln82">#include &quot;yb/util/enums.h&quot;</a>
<a name="ln83"> </a>
<a name="ln84">#include &quot;yb/gutil/thread_annotations.h&quot;</a>
<a name="ln85"> </a>
<a name="ln86">#include &quot;yb/tablet/operations/snapshot_operation.h&quot;</a>
<a name="ln87">#include &quot;yb/util/strongly_typed_bool.h&quot;</a>
<a name="ln88"> </a>
<a name="ln89">namespace rocksdb {</a>
<a name="ln90">class DB;</a>
<a name="ln91">}</a>
<a name="ln92"> </a>
<a name="ln93">namespace yb {</a>
<a name="ln94"> </a>
<a name="ln95">class MemTracker;</a>
<a name="ln96">class MetricEntity;</a>
<a name="ln97">class RowChangeList;</a>
<a name="ln98"> </a>
<a name="ln99">namespace docdb {</a>
<a name="ln100">class ConsensusFrontier;</a>
<a name="ln101">}</a>
<a name="ln102"> </a>
<a name="ln103">namespace log {</a>
<a name="ln104">class LogAnchorRegistry;</a>
<a name="ln105">}</a>
<a name="ln106"> </a>
<a name="ln107">namespace server {</a>
<a name="ln108">class Clock;</a>
<a name="ln109">}</a>
<a name="ln110"> </a>
<a name="ln111">class MaintenanceManager;</a>
<a name="ln112">class MaintenanceOp;</a>
<a name="ln113">class MaintenanceOpStats;</a>
<a name="ln114"> </a>
<a name="ln115">namespace tablet {</a>
<a name="ln116"> </a>
<a name="ln117">class ChangeMetadataOperationState;</a>
<a name="ln118">class ScopedReadOperation;</a>
<a name="ln119">class TabletRetentionPolicy;</a>
<a name="ln120">class TransactionCoordinator;</a>
<a name="ln121">class TransactionCoordinatorContext;</a>
<a name="ln122">class TransactionParticipant;</a>
<a name="ln123">class TruncateOperationState;</a>
<a name="ln124">class WriteOperationState;</a>
<a name="ln125"> </a>
<a name="ln126">struct TabletMetrics;</a>
<a name="ln127">struct TransactionApplyData;</a>
<a name="ln128"> </a>
<a name="ln129">using docdb::LockBatch;</a>
<a name="ln130"> </a>
<a name="ln131">YB_STRONGLY_TYPED_BOOL(IncludeIntents);</a>
<a name="ln132">YB_STRONGLY_TYPED_BOOL(Destroy);</a>
<a name="ln133">YB_STRONGLY_TYPED_BOOL(DisableFlushOnShutdown);</a>
<a name="ln134"> </a>
<a name="ln135">YB_DEFINE_ENUM(FlushMode, (kSync)(kAsync));</a>
<a name="ln136"> </a>
<a name="ln137">enum class FlushFlags {</a>
<a name="ln138">  kNone = 0,</a>
<a name="ln139"> </a>
<a name="ln140">  kRegular = 1,</a>
<a name="ln141">  kIntents = 2,</a>
<a name="ln142"> </a>
<a name="ln143">  kAll = kRegular | kIntents</a>
<a name="ln144">};</a>
<a name="ln145"> </a>
<a name="ln146">inline FlushFlags operator|(FlushFlags lhs, FlushFlags rhs) {</a>
<a name="ln147">  return static_cast&lt;FlushFlags&gt;(to_underlying(lhs) | to_underlying(rhs));</a>
<a name="ln148">}</a>
<a name="ln149"> </a>
<a name="ln150">inline FlushFlags operator&amp;(FlushFlags lhs, FlushFlags rhs) {</a>
<a name="ln151">  return static_cast&lt;FlushFlags&gt;(to_underlying(lhs) &amp; to_underlying(rhs));</a>
<a name="ln152">}</a>
<a name="ln153"> </a>
<a name="ln154">inline bool HasFlags(FlushFlags lhs, FlushFlags rhs) {</a>
<a name="ln155">  return (lhs &amp; rhs) != FlushFlags::kNone;</a>
<a name="ln156">}</a>
<a name="ln157"> </a>
<a name="ln158">class WriteOperation;</a>
<a name="ln159"> </a>
<a name="ln160">using AddTableListener = std::function&lt;Status(const TableInfo&amp;)&gt;;</a>
<a name="ln161">using DocWriteOperationCallback =</a>
<a name="ln162">    boost::function&lt;void(std::unique_ptr&lt;WriteOperation&gt;, const Status&amp;)&gt;;</a>
<a name="ln163"> </a>
<a name="ln164">class TabletScopedIf : public RefCountedThreadSafe&lt;TabletScopedIf&gt; {</a>
<a name="ln165"> public:</a>
<a name="ln166">  virtual std::string Key() const = 0;</a>
<a name="ln167"> protected:</a>
<a name="ln168">  friend class RefCountedThreadSafe&lt;TabletScopedIf&gt;;</a>
<a name="ln169">  virtual ~TabletScopedIf() { }</a>
<a name="ln170">};</a>
<a name="ln171"> </a>
<a name="ln172">YB_STRONGLY_TYPED_BOOL(AllowBootstrappingState);</a>
<a name="ln173"> </a>
<a name="ln174">class Tablet : public AbstractTablet, public TransactionIntentApplier {</a>
<a name="ln175"> public:</a>
<a name="ln176">  class CompactionFaultHooks;</a>
<a name="ln177">  class FlushCompactCommonHooks;</a>
<a name="ln178">  class FlushFaultHooks;</a>
<a name="ln179"> </a>
<a name="ln180">  // A function that returns the current majority-replicated hybrid time leader lease, or waits</a>
<a name="ln181">  // until a hybrid time leader lease with at least the given microsecond component is acquired</a>
<a name="ln182">  // (first argument), or a timeout occurs (second argument). HybridTime::kInvalid is returned</a>
<a name="ln183">  // in case of a timeout.</a>
<a name="ln184">  using HybridTimeLeaseProvider = std::function&lt;FixedHybridTimeLease(MicrosTime, CoarseTimePoint)&gt;;</a>
<a name="ln185">  using TransactionIdSet = std::unordered_set&lt;TransactionId, TransactionIdHash&gt;;</a>
<a name="ln186"> </a>
<a name="ln187">  // Create a new tablet.</a>
<a name="ln188">  //</a>
<a name="ln189">  // If 'metric_registry' is non-NULL, then this tablet will create a 'tablet' entity</a>
<a name="ln190">  // within the provided registry. Otherwise, no metrics are collected.</a>
<a name="ln191">  explicit Tablet(const TabletInitData&amp; data);</a>
<a name="ln192"> </a>
<a name="ln193">  ~Tablet();</a>
<a name="ln194"> </a>
<a name="ln195">  // Open the tablet.</a>
<a name="ln196">  // Upon completion, the tablet enters the kBootstrapping state.</a>
<a name="ln197">  CHECKED_STATUS Open();</a>
<a name="ln198"> </a>
<a name="ln199">  CHECKED_STATUS EnableCompactions(ScopedRWOperationPause* operation_pause);</a>
<a name="ln200"> </a>
<a name="ln201">  Result&lt;std::string&gt; BackfillIndexesForYsql(</a>
<a name="ln202">      const std::vector&lt;IndexInfo&gt;&amp; indexes,</a>
<a name="ln203">      const std::string&amp; backfill_from,</a>
<a name="ln204">      const CoarseTimePoint deadline,</a>
<a name="ln205">      const HybridTime read_time,</a>
<a name="ln206">      const HostPort&amp; pgsql_proxy_bind_address,</a>
<a name="ln207">      const std::string&amp; database_name);</a>
<a name="ln208">  Result&lt;std::string&gt; BackfillIndexes(const std::vector&lt;IndexInfo&gt;&amp; indexes,</a>
<a name="ln209">                                      const std::string&amp; backfill_from,</a>
<a name="ln210">                                      const CoarseTimePoint deadline,</a>
<a name="ln211">                                      const HybridTime read_time);</a>
<a name="ln212"> </a>
<a name="ln213">  CHECKED_STATUS UpdateIndexInBatches(</a>
<a name="ln214">      const QLTableRow&amp; row, const std::vector&lt;IndexInfo&gt;&amp; indexes,</a>
<a name="ln215">      std::vector&lt;std::pair&lt;const IndexInfo*, QLWriteRequestPB&gt;&gt;* index_requests,</a>
<a name="ln216">      CoarseTimePoint* last_flushed_at);</a>
<a name="ln217"> </a>
<a name="ln218">  CHECKED_STATUS FlushIndexBatchIfRequired(</a>
<a name="ln219">      std::vector&lt;std::pair&lt;const IndexInfo*, QLWriteRequestPB&gt;&gt;* index_requests,</a>
<a name="ln220">      bool force_flush,</a>
<a name="ln221">      CoarseTimePoint* last_flushed_at);</a>
<a name="ln222"> </a>
<a name="ln223">  CHECKED_STATUS</a>
<a name="ln224">  FlushWithRetries(</a>
<a name="ln225">      std::shared_ptr&lt;client::YBSession&gt; session,</a>
<a name="ln226">      const std::vector&lt;std::shared_ptr&lt;client::YBqlWriteOp&gt;&gt;&amp; write_ops,</a>
<a name="ln227">      int num_retries);</a>
<a name="ln228"> </a>
<a name="ln229">  // Mark that the tablet has finished bootstrapping.</a>
<a name="ln230">  // This transitions from kBootstrapping to kOpen state.</a>
<a name="ln231">  void MarkFinishedBootstrapping();</a>
<a name="ln232"> </a>
<a name="ln233">  // This can be called to proactively prevent new operations from being handled, even before</a>
<a name="ln234">  // Shutdown() is called.</a>
<a name="ln235">  // Returns true if it was the first call to StartShutdown.</a>
<a name="ln236">  bool StartShutdown();</a>
<a name="ln237">  bool IsShutdownRequested() const {</a>
<a name="ln238">    return shutdown_requested_.load(std::memory_order::memory_order_acquire);</a>
<a name="ln239">  }</a>
<a name="ln240"> </a>
<a name="ln241">  void CompleteShutdown(IsDropTable is_drop_table = IsDropTable::kFalse);</a>
<a name="ln242"> </a>
<a name="ln243">  CHECKED_STATUS ImportData(const std::string&amp; source_dir);</a>
<a name="ln244"> </a>
<a name="ln245">  Result&lt;docdb::ApplyTransactionState&gt; ApplyIntents(const TransactionApplyData&amp; data) override;</a>
<a name="ln246"> </a>
<a name="ln247">  CHECKED_STATUS RemoveIntents(const RemoveIntentsData&amp; data, const TransactionId&amp; id) override;</a>
<a name="ln248"> </a>
<a name="ln249">  CHECKED_STATUS RemoveIntents(</a>
<a name="ln250">      const RemoveIntentsData&amp; data, const TransactionIdSet&amp; transactions) override;</a>
<a name="ln251"> </a>
<a name="ln252">  // Finish the Prepare phase of a write transaction.</a>
<a name="ln253">  //</a>
<a name="ln254">  // Starts an MVCC transaction and assigns a timestamp for the transaction.</a>
<a name="ln255">  //</a>
<a name="ln256">  // This should always be done _after_ any relevant row locks are acquired</a>
<a name="ln257">  // (using CreatePreparedInsert/CreatePreparedMutate). This ensures that,</a>
<a name="ln258">  // within each row, timestamps only move forward. If we took a timestamp before</a>
<a name="ln259">  // getting the row lock, we could have the following situation:</a>
<a name="ln260">  //</a>
<a name="ln261">  //   Thread 1         |  Thread 2</a>
<a name="ln262">  //   ----------------------</a>
<a name="ln263">  //   Start tx 1       |</a>
<a name="ln264">  //                    |  Start tx 2</a>
<a name="ln265">  //                    |  Obtain row lock</a>
<a name="ln266">  //                    |  Update row</a>
<a name="ln267">  //                    |  Commit tx 2</a>
<a name="ln268">  //   Obtain row lock  |</a>
<a name="ln269">  //   Delete row       |</a>
<a name="ln270">  //   Commit tx 1</a>
<a name="ln271">  //</a>
<a name="ln272">  // This would cause the mutation list to look like: @t1: DELETE, @t2: UPDATE</a>
<a name="ln273">  // which is invalid, since we expect to be able to be able to replay mutations</a>
<a name="ln274">  // in increasing timestamp order on a given row.</a>
<a name="ln275">  //</a>
<a name="ln276">  // TODO: rename this to something like &quot;FinishPrepare&quot; or &quot;StartApply&quot;, since</a>
<a name="ln277">  // it's not the first thing in a transaction!</a>
<a name="ln278">  void StartOperation(WriteOperationState* operation_state);</a>
<a name="ln279"> </a>
<a name="ln280">  // Apply all of the row operations associated with this transaction.</a>
<a name="ln281">  CHECKED_STATUS ApplyRowOperations(WriteOperationState* operation_state);</a>
<a name="ln282"> </a>
<a name="ln283">  CHECKED_STATUS ApplyOperationState(</a>
<a name="ln284">      const OperationState&amp; operation_state, int64_t batch_idx,</a>
<a name="ln285">      const docdb::KeyValueWriteBatchPB&amp; write_batch);</a>
<a name="ln286"> </a>
<a name="ln287">  // Apply a set of RocksDB row operations.</a>
<a name="ln288">  // If rocksdb_write_batch is specified it could contain preencoded RocksDB operations.</a>
<a name="ln289">  CHECKED_STATUS ApplyKeyValueRowOperations(</a>
<a name="ln290">      int64_t batch_idx, // index of this batch in its transaction</a>
<a name="ln291">      const docdb::KeyValueWriteBatchPB&amp; put_batch,</a>
<a name="ln292">      const rocksdb::UserFrontiers* frontiers,</a>
<a name="ln293">      HybridTime hybrid_time);</a>
<a name="ln294"> </a>
<a name="ln295">  void WriteToRocksDB(</a>
<a name="ln296">      const rocksdb::UserFrontiers* frontiers,</a>
<a name="ln297">      rocksdb::WriteBatch* write_batch,</a>
<a name="ln298">      docdb::StorageDbType storage_db_type);</a>
<a name="ln299"> </a>
<a name="ln300">  //------------------------------------------------------------------------------------------------</a>
<a name="ln301">  // Redis Request Processing.</a>
<a name="ln302">  // Takes a Redis WriteRequestPB as input with its redis_write_batch.</a>
<a name="ln303">  // Constructs a WriteRequestPB containing a serialized WriteBatch that will be</a>
<a name="ln304">  // replicated by Raft. (Makes a copy, it is caller's responsibility to deallocate</a>
<a name="ln305">  // write_request afterwards if it is no longer needed).</a>
<a name="ln306">  // The operation acquires the necessary locks required to correctly serialize concurrent write</a>
<a name="ln307">  // operations to same/conflicting part of the key/sub-key space. The locks acquired are returned</a>
<a name="ln308">  // via the 'keys_locked' vector, so that they may be unlocked later when the operation has been</a>
<a name="ln309">  // committed.</a>
<a name="ln310">  void KeyValueBatchFromRedisWriteBatch(std::unique_ptr&lt;WriteOperation&gt; operation);</a>
<a name="ln311"> </a>
<a name="ln312">  CHECKED_STATUS HandleRedisReadRequest(</a>
<a name="ln313">      CoarseTimePoint deadline,</a>
<a name="ln314">      const ReadHybridTime&amp; read_time,</a>
<a name="ln315">      const RedisReadRequestPB&amp; redis_read_request,</a>
<a name="ln316">      RedisResponsePB* response) override;</a>
<a name="ln317"> </a>
<a name="ln318">  //------------------------------------------------------------------------------------------------</a>
<a name="ln319">  // CQL Request Processing.</a>
<a name="ln320">  CHECKED_STATUS HandleQLReadRequest(</a>
<a name="ln321">      CoarseTimePoint deadline,</a>
<a name="ln322">      const ReadHybridTime&amp; read_time,</a>
<a name="ln323">      const QLReadRequestPB&amp; ql_read_request,</a>
<a name="ln324">      const TransactionMetadataPB&amp; transaction_metadata,</a>
<a name="ln325">      QLReadRequestResult* result) override;</a>
<a name="ln326"> </a>
<a name="ln327">  CHECKED_STATUS CreatePagingStateForRead(</a>
<a name="ln328">      const QLReadRequestPB&amp; ql_read_request, const size_t row_count,</a>
<a name="ln329">      QLResponsePB* response) const override;</a>
<a name="ln330"> </a>
<a name="ln331">  // The QL equivalent of KeyValueBatchFromRedisWriteBatch, works similarly.</a>
<a name="ln332">  void KeyValueBatchFromQLWriteBatch(std::unique_ptr&lt;WriteOperation&gt; operation);</a>
<a name="ln333"> </a>
<a name="ln334">  //------------------------------------------------------------------------------------------------</a>
<a name="ln335">  // Postgres Request Processing.</a>
<a name="ln336">  CHECKED_STATUS HandlePgsqlReadRequest(</a>
<a name="ln337">      CoarseTimePoint deadline,</a>
<a name="ln338">      const ReadHybridTime&amp; read_time,</a>
<a name="ln339">      const PgsqlReadRequestPB&amp; pgsql_read_request,</a>
<a name="ln340">      const TransactionMetadataPB&amp; transaction_metadata,</a>
<a name="ln341">      PgsqlReadRequestResult* result) override;</a>
<a name="ln342"> </a>
<a name="ln343">  CHECKED_STATUS CreatePagingStateForRead(</a>
<a name="ln344">      const PgsqlReadRequestPB&amp; pgsql_read_request, const size_t row_count,</a>
<a name="ln345">      PgsqlResponsePB* response) const override;</a>
<a name="ln346"> </a>
<a name="ln347">  CHECKED_STATUS PreparePgsqlWriteOperations(WriteOperation* operation);</a>
<a name="ln348">  void KeyValueBatchFromPgsqlWriteBatch(std::unique_ptr&lt;WriteOperation&gt; operation);</a>
<a name="ln349"> </a>
<a name="ln350">  // Create a new row iterator which yields the rows as of the current MVCC</a>
<a name="ln351">  // state of this tablet.</a>
<a name="ln352">  // The returned iterator is not initialized.</a>
<a name="ln353">  Result&lt;std::unique_ptr&lt;common::YQLRowwiseIteratorIf&gt;&gt; NewRowIterator(</a>
<a name="ln354">      const Schema&amp; projection,</a>
<a name="ln355">      const boost::optional&lt;TransactionId&gt;&amp; transaction_id,</a>
<a name="ln356">      const ReadHybridTime read_hybrid_time = {},</a>
<a name="ln357">      const TableId&amp; table_id = &quot;&quot;,</a>
<a name="ln358">      CoarseTimePoint deadline = CoarseTimePoint::max(),</a>
<a name="ln359">      AllowBootstrappingState allow_bootstrapping_state = AllowBootstrappingState::kFalse) const;</a>
<a name="ln360">  Result&lt;std::unique_ptr&lt;common::YQLRowwiseIteratorIf&gt;&gt; NewRowIterator(</a>
<a name="ln361">      const TableId&amp; table_id) const;</a>
<a name="ln362"> </a>
<a name="ln363">  //------------------------------------------------------------------------------------------------</a>
<a name="ln364">  // Makes RocksDB Flush.</a>
<a name="ln365">  CHECKED_STATUS Flush(FlushMode mode,</a>
<a name="ln366">                       FlushFlags flags = FlushFlags::kAll,</a>
<a name="ln367">                       int64_t ignore_if_flushed_after_tick = rocksdb::FlushOptions::kNeverIgnore);</a>
<a name="ln368"> </a>
<a name="ln369">  CHECKED_STATUS WaitForFlush();</a>
<a name="ln370"> </a>
<a name="ln371">  // Prepares the transaction context for the alter schema operation.</a>
<a name="ln372">  // An error will be returned if the specified schema is invalid (e.g.</a>
<a name="ln373">  // key mismatch, or missing IDs)</a>
<a name="ln374">  CHECKED_STATUS CreatePreparedChangeMetadata(</a>
<a name="ln375">      ChangeMetadataOperationState *operation_state,</a>
<a name="ln376">      const Schema* schema);</a>
<a name="ln377"> </a>
<a name="ln378">  // Apply the Schema of the specified operation.</a>
<a name="ln379">  CHECKED_STATUS AlterSchema(ChangeMetadataOperationState* operation_state);</a>
<a name="ln380"> </a>
<a name="ln381">  // Used to update the tablets on the index table that the index has been backfilled.</a>
<a name="ln382">  // This means that major compactions can now garbage collect delete markers.</a>
<a name="ln383">  CHECKED_STATUS MarkBackfillDone();</a>
<a name="ln384"> </a>
<a name="ln385">  // Change wal_retention_secs in the metadata.</a>
<a name="ln386">  CHECKED_STATUS AlterWalRetentionSecs(ChangeMetadataOperationState* operation_state);</a>
<a name="ln387"> </a>
<a name="ln388">  // Apply replicated add table operation.</a>
<a name="ln389">  CHECKED_STATUS AddTable(const TableInfoPB&amp; table_info);</a>
<a name="ln390"> </a>
<a name="ln391">  // Apply replicated remove table operation.</a>
<a name="ln392">  CHECKED_STATUS RemoveTable(const std::string&amp; table_id);</a>
<a name="ln393"> </a>
<a name="ln394">  // Truncate this tablet by resetting the content of RocksDB.</a>
<a name="ln395">  CHECKED_STATUS Truncate(TruncateOperationState* state);</a>
<a name="ln396"> </a>
<a name="ln397">  // Verbosely dump this entire tablet to the logs. This is only</a>
<a name="ln398">  // really useful when debugging unit tests failures where the tablet</a>
<a name="ln399">  // has a very small number of rows.</a>
<a name="ln400">  CHECKED_STATUS DebugDump(vector&lt;std::string&gt; *lines = NULL);</a>
<a name="ln401"> </a>
<a name="ln402">  const yb::SchemaPtr schema() const {</a>
<a name="ln403">    return metadata_-&gt;schema();</a>
<a name="ln404">  }</a>
<a name="ln405"> </a>
<a name="ln406">  // Returns a reference to the key projection of the tablet schema.</a>
<a name="ln407">  // The schema keys are immutable.</a>
<a name="ln408">  const Schema&amp; key_schema() const { return key_schema_; }</a>
<a name="ln409"> </a>
<a name="ln410">  // Return the MVCC manager for this tablet.</a>
<a name="ln411">  MvccManager* mvcc_manager() { return &amp;mvcc_; }</a>
<a name="ln412"> </a>
<a name="ln413">  docdb::SharedLockManager* shared_lock_manager() { return &amp;shared_lock_manager_; }</a>
<a name="ln414"> </a>
<a name="ln415">  std::atomic&lt;int64_t&gt;* monotonic_counter() { return &amp;monotonic_counter_; }</a>
<a name="ln416"> </a>
<a name="ln417">  // Set the conter to at least 'value'.</a>
<a name="ln418">  void UpdateMonotonicCounter(int64_t value);</a>
<a name="ln419"> </a>
<a name="ln420">  const RaftGroupMetadata *metadata() const { return metadata_.get(); }</a>
<a name="ln421">  RaftGroupMetadata *metadata() { return metadata_.get(); }</a>
<a name="ln422"> </a>
<a name="ln423">  rocksdb::Env&amp; rocksdb_env() const;</a>
<a name="ln424"> </a>
<a name="ln425">  const std::string&amp; tablet_id() const override { return metadata_-&gt;raft_group_id(); }</a>
<a name="ln426"> </a>
<a name="ln427">  // Return the metrics for this tablet.</a>
<a name="ln428">  // May be NULL in unit tests, etc.</a>
<a name="ln429">  TabletMetrics* metrics() { return metrics_.get(); }</a>
<a name="ln430"> </a>
<a name="ln431">  // Return handle to the metric entity of this tablet.</a>
<a name="ln432">  const scoped_refptr&lt;MetricEntity&gt;&amp; GetMetricEntity() const { return metric_entity_; }</a>
<a name="ln433"> </a>
<a name="ln434">  // Returns a reference to this tablet's memory tracker.</a>
<a name="ln435">  const std::shared_ptr&lt;MemTracker&gt;&amp; mem_tracker() const { return mem_tracker_; }</a>
<a name="ln436"> </a>
<a name="ln437">  TableType table_type() const override { return table_type_; }</a>
<a name="ln438"> </a>
<a name="ln439">  // Returns true if a RocksDB-backed tablet has any SSTables.</a>
<a name="ln440">  Result&lt;bool&gt; HasSSTables() const;</a>
<a name="ln441"> </a>
<a name="ln442">  // Returns the maximum persistent op id from all SSTables in RocksDB.</a>
<a name="ln443">  // First for regular records and second for intents.</a>
<a name="ln444">  // When invalid_if_no_new_data is true then function would return invalid op id when no new</a>
<a name="ln445">  // data is present in corresponding db.</a>
<a name="ln446">  Result&lt;DocDbOpIds&gt; MaxPersistentOpId(bool invalid_if_no_new_data = false) const;</a>
<a name="ln447"> </a>
<a name="ln448">  // Returns the maximum persistent hybrid_time across all SSTables in RocksDB.</a>
<a name="ln449">  Result&lt;HybridTime&gt; MaxPersistentHybridTime() const;</a>
<a name="ln450"> </a>
<a name="ln451">  // Returns oldest mutable memtable write hybrid time in RocksDB or HybridTime::kMax if memtable</a>
<a name="ln452">  // is empty.</a>
<a name="ln453">  Result&lt;HybridTime&gt; OldestMutableMemtableWriteHybridTime() const;</a>
<a name="ln454"> </a>
<a name="ln455">  // For non-kudu table type fills key-value batch in transaction state request and updates</a>
<a name="ln456">  // request in state. Due to acquiring locks it can block the thread.</a>
<a name="ln457">  void AcquireLocksAndPerformDocOperations(std::unique_ptr&lt;WriteOperation&gt; operation);</a>
<a name="ln458"> </a>
<a name="ln459">  // Given a propopsed &quot;history cutoff&quot; timestamp, returns either that value, if possible, or a</a>
<a name="ln460">  // smaller value corresponding to the oldest active reader, whichever is smaller. This ensures</a>
<a name="ln461">  // that data needed by active read operations is not compacted away.</a>
<a name="ln462">  //</a>
<a name="ln463">  // Also updates the &quot;earliest allowed read time&quot; of the tablet to be equal to the returned value,</a>
<a name="ln464">  // (if it is still lower than the value about to be returned), so that new readers with timestamps</a>
<a name="ln465">  // earlier than that will be rejected.</a>
<a name="ln466">  HybridTime UpdateHistoryCutoff(HybridTime proposed_cutoff);</a>
<a name="ln467"> </a>
<a name="ln468">  const scoped_refptr&lt;server::Clock&gt; &amp;clock() const {</a>
<a name="ln469">    return clock_;</a>
<a name="ln470">  }</a>
<a name="ln471"> </a>
<a name="ln472">  yb::SchemaPtr GetSchema(const std::string&amp; table_id = &quot;&quot;) const override {</a>
<a name="ln473">    if (table_id.empty()) {</a>
<a name="ln474">      return metadata_-&gt;schema();</a>
<a name="ln475">    }</a>
<a name="ln476">    auto table_info = CHECK_RESULT(metadata_-&gt;GetTableInfo(table_id));</a>
<a name="ln477">    return yb::SchemaPtr(table_info, &amp;table_info-&gt;schema);</a>
<a name="ln478">  }</a>
<a name="ln479"> </a>
<a name="ln480">  Schema GetKeySchema(const std::string&amp; table_id = &quot;&quot;) const {</a>
<a name="ln481">    if (table_id.empty()) {</a>
<a name="ln482">      return key_schema_;</a>
<a name="ln483">    }</a>
<a name="ln484">    auto table_info = CHECK_RESULT(metadata_-&gt;GetTableInfo(table_id));</a>
<a name="ln485">    return table_info-&gt;schema.CreateKeyProjection();</a>
<a name="ln486">  }</a>
<a name="ln487"> </a>
<a name="ln488">  const common::YQLStorageIf&amp; QLStorage() const override {</a>
<a name="ln489">    return *ql_storage_;</a>
<a name="ln490">  }</a>
<a name="ln491"> </a>
<a name="ln492">  // Provide a way for write operations to wait when tablet schema is</a>
<a name="ln493">  // being changed.</a>
<a name="ln494">  ScopedRWOperationPause PauseWritePermits(CoarseTimePoint deadline);</a>
<a name="ln495">  ScopedRWOperation GetPermitToWrite(CoarseTimePoint deadline);</a>
<a name="ln496"> </a>
<a name="ln497">  // Used from tests</a>
<a name="ln498">  const std::shared_ptr&lt;rocksdb::Statistics&gt;&amp; rocksdb_statistics() const {</a>
<a name="ln499">    return rocksdb_statistics_;</a>
<a name="ln500">  }</a>
<a name="ln501"> </a>
<a name="ln502">  TransactionCoordinator* transaction_coordinator() {</a>
<a name="ln503">    return transaction_coordinator_.get();</a>
<a name="ln504">  }</a>
<a name="ln505"> </a>
<a name="ln506">  TransactionParticipant* transaction_participant() const {</a>
<a name="ln507">    return transaction_participant_.get();</a>
<a name="ln508">  }</a>
<a name="ln509"> </a>
<a name="ln510">  void ForceRocksDBCompactInTest();</a>
<a name="ln511"> </a>
<a name="ln512">  docdb::DocDB doc_db() const { return { regular_db_.get(), intents_db_.get(), &amp;key_bounds_ }; }</a>
<a name="ln513"> </a>
<a name="ln514">  // Returns approximate middle key for tablet split:</a>
<a name="ln515">  // - for hash-based partitions: encoded hash code in order to split by hash code.</a>
<a name="ln516">  // - for range-based partitions: encoded doc key in order to split by row.</a>
<a name="ln517">  Result&lt;std::string&gt; GetEncodedMiddleSplitKey() const;</a>
<a name="ln518"> </a>
<a name="ln519">  std::string TEST_DocDBDumpStr(IncludeIntents include_intents = IncludeIntents::kFalse);</a>
<a name="ln520"> </a>
<a name="ln521">  void TEST_DocDBDumpToContainer(</a>
<a name="ln522">      IncludeIntents include_intents, std::unordered_set&lt;std::string&gt;* out);</a>
<a name="ln523"> </a>
<a name="ln524">  size_t TEST_CountRegularDBRecords();</a>
<a name="ln525"> </a>
<a name="ln526">  CHECKED_STATUS CreateReadIntents(</a>
<a name="ln527">      const TransactionMetadataPB&amp; transaction_metadata,</a>
<a name="ln528">      const google::protobuf::RepeatedPtrField&lt;QLReadRequestPB&gt;&amp; ql_batch,</a>
<a name="ln529">      const google::protobuf::RepeatedPtrField&lt;PgsqlReadRequestPB&gt;&amp; pgsql_batch,</a>
<a name="ln530">      docdb::KeyValueWriteBatchPB* out);</a>
<a name="ln531"> </a>
<a name="ln532">  uint64_t GetCurrentVersionSstFilesSize() const;</a>
<a name="ln533">  uint64_t GetCurrentVersionSstFilesUncompressedSize() const;</a>
<a name="ln534">  uint64_t GetCurrentVersionNumSSTFiles() const;</a>
<a name="ln535"> </a>
<a name="ln536">  void ListenNumSSTFilesChanged(std::function&lt;void()&gt; listener);</a>
<a name="ln537"> </a>
<a name="ln538">  // Returns the number of memtables in intents and regular db-s.</a>
<a name="ln539">  std::pair&lt;int, int&gt; GetNumMemtables() const;</a>
<a name="ln540"> </a>
<a name="ln541">  void SetHybridTimeLeaseProvider(HybridTimeLeaseProvider provider) {</a>
<a name="ln542">    ht_lease_provider_ = std::move(provider);</a>
<a name="ln543">  }</a>
<a name="ln544"> </a>
<a name="ln545">  void SetMemTableFlushFilterFactory(std::function&lt;rocksdb::MemTableFilter()&gt; factory) {</a>
<a name="ln546">    mem_table_flush_filter_factory_ = std::move(factory);</a>
<a name="ln547">  }</a>
<a name="ln548"> </a>
<a name="ln549">  // When a compaction starts with a particular &quot;history cutoff&quot; timestamp, it calls this function</a>
<a name="ln550">  // to disallow reads at a time lower than that history cutoff timestamp, to avoid reading</a>
<a name="ln551">  // invalid/incomplete data.</a>
<a name="ln552">  //</a>
<a name="ln553">  // Returns true if the new history cutoff timestamp was successfully registered, or false if</a>
<a name="ln554">  // it can't be used because there are pending reads at lower timestamps.</a>
<a name="ln555">  HybridTime Get(HybridTime lower_bound);</a>
<a name="ln556"> </a>
<a name="ln557">  bool ShouldApplyWrite();</a>
<a name="ln558"> </a>
<a name="ln559">  rocksdb::DB* TEST_db() const {</a>
<a name="ln560">    return regular_db_.get();</a>
<a name="ln561">  }</a>
<a name="ln562"> </a>
<a name="ln563">  rocksdb::DB* TEST_intents_db() const {</a>
<a name="ln564">    return intents_db_.get();</a>
<a name="ln565">  }</a>
<a name="ln566"> </a>
<a name="ln567">  CHECKED_STATUS TEST_SwitchMemtable();</a>
<a name="ln568"> </a>
<a name="ln569">  // Initialize RocksDB's max persistent op id and hybrid time to that of the operation state.</a>
<a name="ln570">  // Necessary for cases like truncate or restore snapshot when RocksDB is reset.</a>
<a name="ln571">  CHECKED_STATUS ModifyFlushedFrontier(</a>
<a name="ln572">      const docdb::ConsensusFrontier&amp; value,</a>
<a name="ln573">      rocksdb::FrontierModificationMode mode);</a>
<a name="ln574"> </a>
<a name="ln575">  // Get the isolation level of the given transaction from the metadata stored in the provisional</a>
<a name="ln576">  // records RocksDB.</a>
<a name="ln577">  Result&lt;IsolationLevel&gt; GetIsolationLevel(const TransactionMetadataPB&amp; transaction) override;</a>
<a name="ln578"> </a>
<a name="ln579">  // Creates an on-disk sub tablet of this tablet with specified ID, partition and key bounds.</a>
<a name="ln580">  // Flushes this tablet data onto disk before creating sub tablet.</a>
<a name="ln581">  // Also updates flushed frontier for regular and intents DBs to match split_op_id and</a>
<a name="ln582">  // split_op_hybrid_time.</a>
<a name="ln583">  // In case of error sub-tablet could be partially persisted on disk.</a>
<a name="ln584">  Result&lt;RaftGroupMetadataPtr&gt; CreateSubtablet(</a>
<a name="ln585">      const TabletId&amp; tablet_id, const Partition&amp; partition, const docdb::KeyBounds&amp; key_bounds,</a>
<a name="ln586">      const yb::OpId&amp; split_op_id, const HybridTime&amp; split_op_hybrid_time);</a>
<a name="ln587"> </a>
<a name="ln588">  // Scans the intent db. Potentially takes a long time. Used for testing/debugging.</a>
<a name="ln589">  Result&lt;int64_t&gt; CountIntents();</a>
<a name="ln590"> </a>
<a name="ln591">  // Flushed intents db if necessary.</a>
<a name="ln592">  void FlushIntentsDbIfNecessary(const yb::OpId&amp; lastest_log_entry_op_id);</a>
<a name="ln593"> </a>
<a name="ln594">  bool is_sys_catalog() const { return is_sys_catalog_; }</a>
<a name="ln595">  bool IsTransactionalRequest(bool is_ysql_request) const override;</a>
<a name="ln596"> </a>
<a name="ln597">  void SetCleanupPool(ThreadPool* thread_pool);</a>
<a name="ln598"> </a>
<a name="ln599">  TabletSnapshots&amp; snapshots() {</a>
<a name="ln600">    return *snapshots_;</a>
<a name="ln601">  }</a>
<a name="ln602"> </a>
<a name="ln603">  SnapshotCoordinator* snapshot_coordinator() {</a>
<a name="ln604">    return snapshot_coordinator_;</a>
<a name="ln605">  }</a>
<a name="ln606"> </a>
<a name="ln607">  // Allows us to add tablet-specific information that will get deref'd when the tablet does.</a>
<a name="ln608">  void AddAdditionalMetadata(const std::string&amp; key, std::shared_ptr&lt;void&gt; additional_metadata) {</a>
<a name="ln609">    std::lock_guard&lt;std::mutex&gt; lock(control_path_mutex_);</a>
<a name="ln610">    additional_metadata_.emplace(key, std::move(additional_metadata));</a>
<a name="ln611">  }</a>
<a name="ln612"> </a>
<a name="ln613">  std::shared_ptr&lt;void&gt; GetAdditionalMetadata(const std::string&amp; key) {</a>
<a name="ln614">    std::lock_guard&lt;std::mutex&gt; lock(control_path_mutex_);</a>
<a name="ln615">    auto val = additional_metadata_.find(key);</a>
<a name="ln616">    return (val != additional_metadata_.end()) ? val-&gt;second : nullptr;</a>
<a name="ln617">  }</a>
<a name="ln618"> </a>
<a name="ln619">  void InitRocksDBOptions(rocksdb::Options* options, const std::string&amp; log_prefix);</a>
<a name="ln620"> </a>
<a name="ln621">  TabletRetentionPolicy* RetentionPolicy() override {</a>
<a name="ln622">    return retention_policy_.get();</a>
<a name="ln623">  }</a>
<a name="ln624"> </a>
<a name="ln625"> private:</a>
<a name="ln626">  friend class Iterator;</a>
<a name="ln627">  friend class TabletPeerTest;</a>
<a name="ln628">  friend class ScopedReadOperation;</a>
<a name="ln629">  friend class TabletComponent;</a>
<a name="ln630"> </a>
<a name="ln631">  class RegularRocksDbListener;</a>
<a name="ln632"> </a>
<a name="ln633">  FRIEND_TEST(TestTablet, TestGetLogRetentionSizeForIndex);</a>
<a name="ln634"> </a>
<a name="ln635">  void StartDocWriteOperation(</a>
<a name="ln636">      std::unique_ptr&lt;WriteOperation&gt; operation,</a>
<a name="ln637">      ScopedRWOperation scoped_read_operation,</a>
<a name="ln638">      DocWriteOperationCallback callback);</a>
<a name="ln639"> </a>
<a name="ln640">  CHECKED_STATUS OpenKeyValueTablet();</a>
<a name="ln641">  virtual CHECKED_STATUS CreateTabletDirectories(const string&amp; db_dir, FsManager* fs);</a>
<a name="ln642"> </a>
<a name="ln643">  void DocDBDebugDump(std::vector&lt;std::string&gt; *lines);</a>
<a name="ln644"> </a>
<a name="ln645">  CHECKED_STATUS PrepareTransactionWriteBatch(</a>
<a name="ln646">      int64_t batch_idx, // index of this batch in its transaction</a>
<a name="ln647">      const docdb::KeyValueWriteBatchPB&amp; put_batch,</a>
<a name="ln648">      HybridTime hybrid_time,</a>
<a name="ln649">      rocksdb::WriteBatch* rocksdb_write_batch);</a>
<a name="ln650"> </a>
<a name="ln651">  Result&lt;TransactionOperationContextOpt&gt; CreateTransactionOperationContext(</a>
<a name="ln652">      const TransactionMetadataPB&amp; transaction_metadata,</a>
<a name="ln653">      bool is_ysql_catalog_table) const;</a>
<a name="ln654"> </a>
<a name="ln655">  TransactionOperationContextOpt CreateTransactionOperationContext(</a>
<a name="ln656">      const boost::optional&lt;TransactionId&gt;&amp; transaction_id,</a>
<a name="ln657">      bool is_ysql_catalog_table) const;</a>
<a name="ln658"> </a>
<a name="ln659">  // Pause any new read/write operations and wait for all pending read/write operations to finish.</a>
<a name="ln660">  ScopedRWOperationPause PauseReadWriteOperations(Stop stop = Stop::kFalse);</a>
<a name="ln661"> </a>
<a name="ln662">  CHECKED_STATUS ResetRocksDBs(Destroy destroy, DisableFlushOnShutdown disable_flush_on_shutdown);</a>
<a name="ln663"> </a>
<a name="ln664">  CHECKED_STATUS DoEnableCompactions();</a>
<a name="ln665"> </a>
<a name="ln666">  void PreventCallbacksFromRocksDBs(DisableFlushOnShutdown disable_flush_on_shutdown);</a>
<a name="ln667"> </a>
<a name="ln668">  std::string LogPrefix() const;</a>
<a name="ln669"> </a>
<a name="ln670">  std::string LogPrefix(docdb::StorageDbType db_type) const;</a>
<a name="ln671"> </a>
<a name="ln672">  Result&lt;bool&gt; IsQueryOnlyForTablet(const PgsqlReadRequestPB&amp; pgsql_read_request) const;</a>
<a name="ln673"> </a>
<a name="ln674">  Result&lt;bool&gt; HasScanReachedMaxPartitionKey(</a>
<a name="ln675">      const PgsqlReadRequestPB&amp; pgsql_read_request, const string&amp; partition_key) const;</a>
<a name="ln676"> </a>
<a name="ln677">  // Sets metadata_cache_ to nullptr. This is done atomically to avoid race conditions.</a>
<a name="ln678">  void ResetYBMetaDataCache();</a>
<a name="ln679"> </a>
<a name="ln680">  // Creates a new client::YBMetaDataCache object and atomically assigns it to metadata_cache_.</a>
<a name="ln681">  void CreateNewYBMetaDataCache();</a>
<a name="ln682"> </a>
<a name="ln683">  // Creates a new shared pointer of the object managed by metadata_cache_. This is done</a>
<a name="ln684">  // atomically to avoid race conditions.</a>
<a name="ln685">  std::shared_ptr&lt;client::YBMetaDataCache&gt; YBMetaDataCache();</a>
<a name="ln686"> </a>
<a name="ln687">  const Schema key_schema_;</a>
<a name="ln688"> </a>
<a name="ln689">  RaftGroupMetadataPtr metadata_;</a>
<a name="ln690">  TableType table_type_;</a>
<a name="ln691"> </a>
<a name="ln692">  // Lock protecting access to the 'components_' member (i.e the rowsets in the tablet)</a>
<a name="ln693">  //</a>
<a name="ln694">  // Shared mode:</a>
<a name="ln695">  // - Writers take this in shared mode at the same time as they obtain an MVCC hybrid_time</a>
<a name="ln696">  //   and capture a reference to components_. This ensures that we can use the MVCC hybrid_time</a>
<a name="ln697">  //   to determine which writers are writing to which components during compaction.</a>
<a name="ln698">  // - Readers take this in shared mode while capturing their iterators. This ensures that</a>
<a name="ln699">  //   they see a consistent view when racing against flush/compact.</a>
<a name="ln700">  //</a>
<a name="ln701">  // Exclusive mode:</a>
<a name="ln702">  // - Flushes/compactions take this lock in order to lock out concurrent updates.</a>
<a name="ln703">  //</a>
<a name="ln704">  // NOTE: callers should avoid taking this lock for a long time, even in shared mode.</a>
<a name="ln705">  // This is because the lock has some concept of fairness -- if, while a long reader</a>
<a name="ln706">  // is active, a writer comes along, then all future short readers will be blocked.</a>
<a name="ln707">  // TODO: now that this is single-threaded again, we should change it to rw_spinlock</a>
<a name="ln708">  mutable rw_spinlock component_lock_;</a>
<a name="ln709"> </a>
<a name="ln710">  scoped_refptr&lt;log::LogAnchorRegistry&gt; log_anchor_registry_;</a>
<a name="ln711">  std::shared_ptr&lt;MemTracker&gt; mem_tracker_;</a>
<a name="ln712">  std::shared_ptr&lt;MemTracker&gt; block_based_table_mem_tracker_;</a>
<a name="ln713"> </a>
<a name="ln714">  MetricEntityPtr metric_entity_;</a>
<a name="ln715">  gscoped_ptr&lt;TabletMetrics&gt; metrics_;</a>
<a name="ln716">  FunctionGaugeDetacher metric_detacher_;</a>
<a name="ln717"> </a>
<a name="ln718">  // A pointer to the server's clock.</a>
<a name="ln719">  scoped_refptr&lt;server::Clock&gt; clock_;</a>
<a name="ln720"> </a>
<a name="ln721">  MvccManager mvcc_;</a>
<a name="ln722"> </a>
<a name="ln723">  // Lock used to serialize the creation of RocksDB checkpoints.</a>
<a name="ln724">  mutable std::mutex create_checkpoint_lock_;</a>
<a name="ln725"> </a>
<a name="ln726">  enum State {</a>
<a name="ln727">    kInitialized,</a>
<a name="ln728">    kBootstrapping,</a>
<a name="ln729">    kOpen,</a>
<a name="ln730">    kShutdown</a>
<a name="ln731">  };</a>
<a name="ln732">  State state_ = kInitialized;</a>
<a name="ln733"> </a>
<a name="ln734">  // Fault hooks. In production code, these will always be NULL.</a>
<a name="ln735">  std::shared_ptr&lt;CompactionFaultHooks&gt; compaction_hooks_;</a>
<a name="ln736">  std::shared_ptr&lt;FlushFaultHooks&gt; flush_hooks_;</a>
<a name="ln737">  std::shared_ptr&lt;FlushCompactCommonHooks&gt; common_hooks_;</a>
<a name="ln738"> </a>
<a name="ln739">  // Statistics for the RocksDB database.</a>
<a name="ln740">  std::shared_ptr&lt;rocksdb::Statistics&gt; rocksdb_statistics_;</a>
<a name="ln741"> </a>
<a name="ln742">  // RocksDB database for key-value tables.</a>
<a name="ln743">  std::unique_ptr&lt;rocksdb::DB&gt; regular_db_;</a>
<a name="ln744"> </a>
<a name="ln745">  std::unique_ptr&lt;rocksdb::DB&gt; intents_db_;</a>
<a name="ln746"> </a>
<a name="ln747">  // Optional key bounds (see docdb::KeyBounds) served by this tablet.</a>
<a name="ln748">  docdb::KeyBounds key_bounds_;</a>
<a name="ln749"> </a>
<a name="ln750">  std::unique_ptr&lt;common::YQLStorageIf&gt; ql_storage_;</a>
<a name="ln751"> </a>
<a name="ln752">  // This is for docdb fine-grained locking.</a>
<a name="ln753">  docdb::SharedLockManager shared_lock_manager_;</a>
<a name="ln754"> </a>
<a name="ln755">  // For the block cache and memory manager shared across tablets</a>
<a name="ln756">  TabletOptions tablet_options_;</a>
<a name="ln757"> </a>
<a name="ln758">  // A lightweight way to reject new operations when the tablet is shutting down. This is used to</a>
<a name="ln759">  // prevent race conditions between destroying the RocksDB instance and read/write operations.</a>
<a name="ln760">  std::atomic_bool shutdown_requested_{false};</a>
<a name="ln761"> </a>
<a name="ln762">  // This is a special atomic counter per tablet that increases monotonically.</a>
<a name="ln763">  // It is like timestamp, but doesn't need locks to read or update.</a>
<a name="ln764">  // This is raft replicated as well. Each replicate message contains the current number.</a>
<a name="ln765">  // It is guaranteed to keep increasing for committed entries even across tablet server</a>
<a name="ln766">  // restarts and leader changes.</a>
<a name="ln767">  std::atomic&lt;int64_t&gt; monotonic_counter_{0};</a>
<a name="ln768"> </a>
<a name="ln769">  // Number of pending operations. We use this to make sure we don't shut down RocksDB before all</a>
<a name="ln770">  // pending operations are finished. We don't have a strict definition of an &quot;operation&quot; for the</a>
<a name="ln771">  // purpose of this counter. We simply wait for this counter to go to zero before shutting down</a>
<a name="ln772">  // RocksDB.</a>
<a name="ln773">  //</a>
<a name="ln774">  // This is marked mutable because read path member functions (which are const) are using this.</a>
<a name="ln775">  mutable RWOperationCounter pending_op_counter_;</a>
<a name="ln776"> </a>
<a name="ln777">  // Used by Alter/Schema-change ops to pause new write ops from being submitted.</a>
<a name="ln778">  RWOperationCounter write_ops_being_submitted_counter_;</a>
<a name="ln779"> </a>
<a name="ln780">  std::unique_ptr&lt;TransactionCoordinator&gt; transaction_coordinator_;</a>
<a name="ln781"> </a>
<a name="ln782">  std::unique_ptr&lt;TransactionParticipant&gt; transaction_participant_;</a>
<a name="ln783"> </a>
<a name="ln784">  std::shared_future&lt;client::YBClient*&gt; client_future_;</a>
<a name="ln785"> </a>
<a name="ln786">  // Created only when secondary indexes are present.</a>
<a name="ln787">  boost::optional&lt;client::TransactionManager&gt; transaction_manager_;</a>
<a name="ln788"> </a>
<a name="ln789">  // This object should not be accessed directly to avoid race conditions.</a>
<a name="ln790">  // Use methods YBMetaDataCache, CreateNewYBMetaDataCache, and ResetYBMetaDataCache to read it</a>
<a name="ln791">  // and modify it.</a>
<a name="ln792">  std::shared_ptr&lt;client::YBMetaDataCache&gt; metadata_cache_;</a>
<a name="ln793"> </a>
<a name="ln794">  // Created only if it is a unique index tablet.</a>
<a name="ln795">  boost::optional&lt;Schema&gt; unique_index_key_schema_;</a>
<a name="ln796"> </a>
<a name="ln797">  std::atomic&lt;int64_t&gt; last_committed_write_index_{0};</a>
<a name="ln798"> </a>
<a name="ln799">  HybridTimeLeaseProvider ht_lease_provider_;</a>
<a name="ln800"> </a>
<a name="ln801">  HybridTime DoGetSafeTime(</a>
<a name="ln802">      RequireLease require_lease, HybridTime min_allowed, CoarseTimePoint deadline) const override;</a>
<a name="ln803"> </a>
<a name="ln804">  using IndexOps = std::vector&lt;std::pair&lt;</a>
<a name="ln805">      std::shared_ptr&lt;client::YBqlWriteOp&gt;, docdb::QLWriteOperation*&gt;&gt;;</a>
<a name="ln806">  void UpdateQLIndexes(std::unique_ptr&lt;WriteOperation&gt; operation);</a>
<a name="ln807">  void UpdateQLIndexesFlushed(</a>
<a name="ln808">      WriteOperation* op, const client::YBSessionPtr&amp; session, const client::YBTransactionPtr&amp; txn,</a>
<a name="ln809">      const IndexOps&amp; index_ops, const Status&amp; status);</a>
<a name="ln810"> </a>
<a name="ln811">  void CompleteQLWriteBatch(std::unique_ptr&lt;WriteOperation&gt; operation, const Status&amp; status);</a>
<a name="ln812"> </a>
<a name="ln813">  Result&lt;bool&gt; IntentsDbFlushFilter(const rocksdb::MemTable&amp; memtable);</a>
<a name="ln814"> </a>
<a name="ln815">  template &lt;class Ids&gt;</a>
<a name="ln816">  CHECKED_STATUS RemoveIntentsImpl(const RemoveIntentsData&amp; data, const Ids&amp; ids);</a>
<a name="ln817"> </a>
<a name="ln818">  // Tries to find intent .SST files that could be deleted and remove them.</a>
<a name="ln819">  void CleanupIntentFiles();</a>
<a name="ln820">  void DoCleanupIntentFiles();</a>
<a name="ln821"> </a>
<a name="ln822">  void RegularDbFilesChanged();</a>
<a name="ln823"> </a>
<a name="ln824">  HybridTime ApplierSafeTime(HybridTime min_allowed, CoarseTimePoint deadline) override;</a>
<a name="ln825"> </a>
<a name="ln826">  void MinRunningHybridTimeSatisfied() override {</a>
<a name="ln827">    CleanupIntentFiles();</a>
<a name="ln828">  }</a>
<a name="ln829"> </a>
<a name="ln830">  template &lt;class Functor&gt;</a>
<a name="ln831">  uint64_t GetRegularDbStat(const Functor&amp; functor) const;</a>
<a name="ln832"> </a>
<a name="ln833">  std::function&lt;rocksdb::MemTableFilter()&gt; mem_table_flush_filter_factory_;</a>
<a name="ln834"> </a>
<a name="ln835">  client::LocalTabletFilter local_tablet_filter_;</a>
<a name="ln836"> </a>
<a name="ln837">  std::string log_prefix_suffix_;</a>
<a name="ln838"> </a>
<a name="ln839">  IsSysCatalogTablet is_sys_catalog_;</a>
<a name="ln840">  TransactionsEnabled txns_enabled_;</a>
<a name="ln841"> </a>
<a name="ln842">  std::unique_ptr&lt;ThreadPoolToken&gt; cleanup_intent_files_token_;</a>
<a name="ln843"> </a>
<a name="ln844">  std::unique_ptr&lt;TabletSnapshots&gt; snapshots_;</a>
<a name="ln845"> </a>
<a name="ln846">  SnapshotCoordinator* snapshot_coordinator_ = nullptr;</a>
<a name="ln847"> </a>
<a name="ln848">  mutable std::mutex control_path_mutex_;</a>
<a name="ln849">  std::unordered_map&lt;std::string, std::shared_ptr&lt;void&gt;&gt; additional_metadata_</a>
<a name="ln850">    GUARDED_BY(control_path_mutex_);</a>
<a name="ln851"> </a>
<a name="ln852">  std::mutex num_sst_files_changed_listener_mutex_;</a>
<a name="ln853">  std::function&lt;void()&gt; num_sst_files_changed_listener_</a>
<a name="ln854">      GUARDED_BY(num_sst_files_changed_listener_mutex_);</a>
<a name="ln855"> </a>
<a name="ln856">  std::shared_ptr&lt;TabletRetentionPolicy&gt; retention_policy_;</a>
<a name="ln857"> </a>
<a name="ln858">  DISALLOW_COPY_AND_ASSIGN(Tablet);</a>
<a name="ln859">};</a>
<a name="ln860"> </a>
<a name="ln861">// A helper class to manage read transactions. Grabs and registers a read point with the tablet</a>
<a name="ln862">// when created, and deregisters the read point when this object is destructed.</a>
<a name="ln863">class ScopedReadOperation {</a>
<a name="ln864"> public:</a>
<a name="ln865">  ScopedReadOperation() : tablet_(nullptr) {}</a>
<a name="ln866">  ScopedReadOperation(ScopedReadOperation&amp;&amp; rhs)</a>
<a name="ln867">      : tablet_(rhs.tablet_), read_time_(rhs.read_time_) {</a>
<a name="ln868">    rhs.tablet_ = nullptr;</a>
<a name="ln869">  }</a>
<a name="ln870"> </a>
<a name="ln871">  void operator=(ScopedReadOperation&amp;&amp; rhs);</a>
<a name="ln872"> </a>
<a name="ln873">  static Result&lt;ScopedReadOperation&gt; Create(</a>
<a name="ln874">      AbstractTablet* tablet,</a>
<a name="ln875">      RequireLease require_lease,</a>
<a name="ln876">      ReadHybridTime read_time);</a>
<a name="ln877"> </a>
<a name="ln878">  ScopedReadOperation(const ScopedReadOperation&amp;) = delete;</a>
<a name="ln879">  void operator=(const ScopedReadOperation&amp;) = delete;</a>
<a name="ln880"> </a>
<a name="ln881">  ~ScopedReadOperation();</a>
<a name="ln882"> </a>
<a name="ln883">  const ReadHybridTime&amp; read_time() const { return read_time_; }</a>
<a name="ln884"> </a>
<a name="ln885">  Status status() const { return status_; }</a>
<a name="ln886"> </a>
<a name="ln887">  void Reset();</a>
<a name="ln888"> </a>
<a name="ln889"> private:</a>
<a name="ln890">  explicit ScopedReadOperation(</a>
<a name="ln891">      AbstractTablet* tablet, const ReadHybridTime&amp; read_time);</a>
<a name="ln892"> </a>
<a name="ln893">  AbstractTablet* tablet_;</a>
<a name="ln894">  ReadHybridTime read_time_;</a>
<a name="ln895">  Status status_;</a>
<a name="ln896">};</a>
<a name="ln897"> </a>
<a name="ln898">}  // namespace tablet</a>
<a name="ln899">}  // namespace yb</a>
<a name="ln900"> </a>
<a name="ln901">#endif  // YB_TABLET_TABLET_H_</a>

</code></pre>
<div class="balloon" rel="476"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="484"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
