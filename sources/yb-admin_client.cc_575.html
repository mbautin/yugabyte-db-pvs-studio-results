
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>yb-admin_client.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Licensed to the Apache Software Foundation (ASF) under one</a>
<a name="ln2">// or more contributor license agreements.  See the NOTICE file</a>
<a name="ln3">// distributed with this work for additional information</a>
<a name="ln4">// regarding copyright ownership.  The ASF licenses this file</a>
<a name="ln5">// to you under the Apache License, Version 2.0 (the</a>
<a name="ln6">// &quot;License&quot;); you may not use this file except in compliance</a>
<a name="ln7">// with the License.  You may obtain a copy of the License at</a>
<a name="ln8">//</a>
<a name="ln9">//   http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln10">//</a>
<a name="ln11">// Unless required by applicable law or agreed to in writing,</a>
<a name="ln12">// software distributed under the License is distributed on an</a>
<a name="ln13">// &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</a>
<a name="ln14">// KIND, either express or implied.  See the License for the</a>
<a name="ln15">// specific language governing permissions and limitations</a>
<a name="ln16">// under the License.</a>
<a name="ln17">//</a>
<a name="ln18">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln19">//</a>
<a name="ln20">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln21">//</a>
<a name="ln22">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln23">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln24">//</a>
<a name="ln25">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln26">//</a>
<a name="ln27">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln28">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln29">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln30">// under the License.</a>
<a name="ln31">//</a>
<a name="ln32">#include &quot;yb/tools/yb-admin_client.h&quot;</a>
<a name="ln33"> </a>
<a name="ln34">#include &lt;array&gt;</a>
<a name="ln35">#include &lt;iomanip&gt;</a>
<a name="ln36">#include &lt;sstream&gt;</a>
<a name="ln37">#include &lt;type_traits&gt;</a>
<a name="ln38"> </a>
<a name="ln39">#include &lt;boost/multi_index_container.hpp&gt;</a>
<a name="ln40">#include &lt;boost/multi_index/composite_key.hpp&gt;</a>
<a name="ln41">#include &lt;boost/multi_index/global_fun.hpp&gt;</a>
<a name="ln42">#include &lt;boost/multi_index/mem_fun.hpp&gt;</a>
<a name="ln43">#include &lt;boost/multi_index/ordered_index.hpp&gt;</a>
<a name="ln44">#include &lt;boost/tti/has_member_function.hpp&gt;</a>
<a name="ln45"> </a>
<a name="ln46">#include &lt;google/protobuf/util/json_util.h&gt;</a>
<a name="ln47"> </a>
<a name="ln48">#include &quot;yb/common/redis_constants_common.h&quot;</a>
<a name="ln49">#include &quot;yb/common/wire_protocol.h&quot;</a>
<a name="ln50">#include &quot;yb/client/client.h&quot;</a>
<a name="ln51">#include &quot;yb/client/table_creator.h&quot;</a>
<a name="ln52">#include &quot;yb/master/master.pb.h&quot;</a>
<a name="ln53">#include &quot;yb/master/master_error.h&quot;</a>
<a name="ln54">#include &quot;yb/master/sys_catalog.h&quot;</a>
<a name="ln55">#include &quot;yb/rpc/messenger.h&quot;</a>
<a name="ln56"> </a>
<a name="ln57">#include &quot;yb/util/string_case.h&quot;</a>
<a name="ln58">#include &quot;yb/util/net/net_util.h&quot;</a>
<a name="ln59">#include &quot;yb/util/string_util.h&quot;</a>
<a name="ln60">#include &quot;yb/util/protobuf_util.h&quot;</a>
<a name="ln61">#include &quot;yb/util/random_util.h&quot;</a>
<a name="ln62">#include &quot;yb/gutil/strings/split.h&quot;</a>
<a name="ln63">#include &quot;yb/gutil/strings/join.h&quot;</a>
<a name="ln64">#include &quot;yb/gutil/strings/numbers.h&quot;</a>
<a name="ln65"> </a>
<a name="ln66">#include &quot;yb/consensus/consensus.proxy.h&quot;</a>
<a name="ln67">#include &quot;yb/tserver/tserver_service.proxy.h&quot;</a>
<a name="ln68"> </a>
<a name="ln69">DEFINE_bool(wait_if_no_leader_master, false,</a>
<a name="ln70">            &quot;When yb-admin connects to the cluster and no leader master is present, &quot;</a>
<a name="ln71">            &quot;this flag determines if yb-admin should wait for the entire duration of timeout or&quot;</a>
<a name="ln72">            &quot;in case a leader master appears in that duration or return error immediately.&quot;);</a>
<a name="ln73"> </a>
<a name="ln74">DEFINE_string(certs_dir_name, &quot;&quot;,</a>
<a name="ln75">              &quot;Directory with certificates to use for secure server connection.&quot;);</a>
<a name="ln76"> </a>
<a name="ln77">DEFINE_bool(</a>
<a name="ln78">    disable_graceful_transition, false,</a>
<a name="ln79">    &quot;During a leader stepdown, disable graceful leadership transfer &quot;</a>
<a name="ln80">    &quot;to an up to date peer&quot;);</a>
<a name="ln81"> </a>
<a name="ln82">// Maximum number of elements to dump on unexpected errors.</a>
<a name="ln83">static constexpr int MAX_NUM_ELEMENTS_TO_SHOW_ON_ERROR = 10;</a>
<a name="ln84"> </a>
<a name="ln85">PB_ENUM_FORMATTERS(yb::consensus::RaftPeerPB::Role);</a>
<a name="ln86">PB_ENUM_FORMATTERS(yb::AppStatusPB::ErrorCode);</a>
<a name="ln87">PB_ENUM_FORMATTERS(yb::tablet::RaftGroupStatePB);</a>
<a name="ln88"> </a>
<a name="ln89">namespace yb {</a>
<a name="ln90">namespace tools {</a>
<a name="ln91"> </a>
<a name="ln92">using namespace std::literals;</a>
<a name="ln93"> </a>
<a name="ln94">using std::cout;</a>
<a name="ln95">using std::endl;</a>
<a name="ln96"> </a>
<a name="ln97">using google::protobuf::RepeatedPtrField;</a>
<a name="ln98">using google::protobuf::util::MessageToJsonString;</a>
<a name="ln99"> </a>
<a name="ln100">using client::YBClientBuilder;</a>
<a name="ln101">using client::YBTableName;</a>
<a name="ln102">using rpc::MessengerBuilder;</a>
<a name="ln103">using rpc::RpcController;</a>
<a name="ln104">using strings::Substitute;</a>
<a name="ln105">using tserver::TabletServerServiceProxy;</a>
<a name="ln106"> </a>
<a name="ln107">using consensus::ConsensusServiceProxy;</a>
<a name="ln108">using consensus::LeaderStepDownRequestPB;</a>
<a name="ln109">using consensus::LeaderStepDownResponsePB;</a>
<a name="ln110">using consensus::RaftPeerPB;</a>
<a name="ln111">using consensus::RunLeaderElectionRequestPB;</a>
<a name="ln112">using consensus::RunLeaderElectionResponsePB;</a>
<a name="ln113"> </a>
<a name="ln114">using master::ListMastersRequestPB;</a>
<a name="ln115">using master::ListMastersResponsePB;</a>
<a name="ln116">using master::ListMasterRaftPeersRequestPB;</a>
<a name="ln117">using master::ListMasterRaftPeersResponsePB;</a>
<a name="ln118">using master::ListTabletServersRequestPB;</a>
<a name="ln119">using master::ListTabletServersResponsePB;</a>
<a name="ln120">using master::MasterServiceProxy;</a>
<a name="ln121">using master::TabletLocationsPB;</a>
<a name="ln122">using master::TSInfoPB;</a>
<a name="ln123"> </a>
<a name="ln124">namespace {</a>
<a name="ln125"> </a>
<a name="ln126">static constexpr const char* kRpcHostPortHeading = &quot;RPC Host/Port&quot;;</a>
<a name="ln127">static constexpr const char* kDBTypePrefixUnknown = &quot;unknown&quot;;</a>
<a name="ln128">static constexpr const char* kDBTypePrefixCql = &quot;ycql&quot;;</a>
<a name="ln129">static constexpr const char* kDBTypePrefixYsql = &quot;ysql&quot;;</a>
<a name="ln130">static constexpr const char* kDBTypePrefixRedis = &quot;yedis&quot;;</a>
<a name="ln131">static constexpr const char* kTableIDPrefix = &quot;tableid&quot;;</a>
<a name="ln132"> </a>
<a name="ln133">string FormatFirstHostPort(</a>
<a name="ln134">    const RepeatedPtrField&lt;HostPortPB&gt;&amp; rpc_addresses) {</a>
<a name="ln135">  if (rpc_addresses.empty()) {</a>
<a name="ln136">    return &quot;N/A&quot;;</a>
<a name="ln137">  } else {</a>
<a name="ln138">    return HostPortPBToString(rpc_addresses.Get(0));</a>
<a name="ln139">  }</a>
<a name="ln140">}</a>
<a name="ln141"> </a>
<a name="ln142">string FormatDouble(double d, int precision = 2) {</a>
<a name="ln143">  std::ostringstream op_stream;</a>
<a name="ln144">  op_stream &lt;&lt; std::fixed &lt;&lt; std::setprecision(precision);</a>
<a name="ln145">  op_stream &lt;&lt; d;</a>
<a name="ln146">  return op_stream.str();</a>
<a name="ln147">}</a>
<a name="ln148"> </a>
<a name="ln149">const int kPartitionRangeColWidth = 56;</a>
<a name="ln150">const int kHostPortColWidth = 20;</a>
<a name="ln151">const int kTableNameColWidth = 48;</a>
<a name="ln152">const int kNumCharactersInUuid = 32;</a>
<a name="ln153">const int kLongColWidth = 15;</a>
<a name="ln154">const int kSmallColWidth = 8;</a>
<a name="ln155">const int kSleepTimeSec = 1;</a>
<a name="ln156">const int kNumberOfTryouts = 30;</a>
<a name="ln157"> </a>
<a name="ln158">BOOST_TTI_HAS_MEMBER_FUNCTION(has_error)</a>
<a name="ln159">template&lt;typename T&gt;</a>
<a name="ln160">constexpr bool HasMemberFunctionHasError = has_member_function_has_error&lt;const T, bool&gt;::value;</a>
<a name="ln161"> </a>
<a name="ln162">template&lt;class Response&gt;</a>
<a name="ln163">Result&lt;Response&gt; ResponseResult(Response&amp;&amp; response,</a>
<a name="ln164">    typename std::enable_if&lt;HasMemberFunctionHasError&lt;Response&gt;, void*&gt;::type = nullptr) {</a>
<a name="ln165">  // Response has has_error method, use status from it</a>
<a name="ln166">  if(response.has_error()) {</a>
<a name="ln167">    return StatusFromPB(response.error().status());</a>
<a name="ln168">  }</a>
<a name="ln169">  return std::move(response);</a>
<a name="ln170">}</a>
<a name="ln171"> </a>
<a name="ln172">template&lt;class Response&gt;</a>
<a name="ln173">Result&lt;Response&gt; ResponseResult(Response&amp;&amp; response,</a>
<a name="ln174">    typename std::enable_if&lt;!HasMemberFunctionHasError&lt;Response&gt;, void*&gt;::type = nullptr) {</a>
<a name="ln175">  // Response has no has_error method, nothing to check</a>
<a name="ln176">  return std::move(response);</a>
<a name="ln177">}</a>
<a name="ln178"> </a>
<a name="ln179">const char* DatabasePrefix(YQLDatabase db) {</a>
<a name="ln180">  switch(db) {</a>
<a name="ln181">    case YQL_DATABASE_UNKNOWN: break;</a>
<a name="ln182">    case YQL_DATABASE_CQL: return kDBTypePrefixCql;</a>
<a name="ln183">    case YQL_DATABASE_PGSQL: return kDBTypePrefixYsql;</a>
<a name="ln184">    case YQL_DATABASE_REDIS: return kDBTypePrefixRedis;</a>
<a name="ln185">  }</a>
<a name="ln186">  CHECK(false) &lt;&lt; &quot;Unexpected db type &quot; &lt;&lt; db;</a>
<a name="ln187">  return kDBTypePrefixUnknown;</a>
<a name="ln188">}</a>
<a name="ln189"> </a>
<a name="ln190">Result&lt;TypedNamespaceName&gt; ResolveNamespaceName(</a>
<a name="ln191">    const Slice&amp; prefix,</a>
<a name="ln192">    const Slice&amp; name,</a>
<a name="ln193">    const YQLDatabase default_if_no_prefix = YQL_DATABASE_CQL) {</a>
<a name="ln194">  auto db_type = YQL_DATABASE_UNKNOWN;</a>
<a name="ln195">  if (!prefix.empty()) {</a>
<a name="ln196">    static const std::array&lt;pair&lt;const char*, YQLDatabase&gt;, 3&gt; type_prefixes{</a>
<a name="ln197">        make_pair(kDBTypePrefixCql, YQL_DATABASE_CQL),</a>
<a name="ln198">        make_pair(kDBTypePrefixYsql, YQL_DATABASE_PGSQL),</a>
<a name="ln199">        make_pair(kDBTypePrefixRedis, YQL_DATABASE_REDIS)};</a>
<a name="ln200">    for (const auto&amp; p : type_prefixes) {</a>
<a name="ln201">      if (prefix == p.first) {</a>
<a name="ln202">        db_type = p.second;</a>
<a name="ln203">        break;</a>
<a name="ln204">      }</a>
<a name="ln205">    }</a>
<a name="ln206"> </a>
<a name="ln207">    if (db_type == YQL_DATABASE_UNKNOWN) {</a>
<a name="ln208">      return STATUS_FORMAT(InvalidArgument, &quot;Invalid db type name '$0'&quot;, prefix);</a>
<a name="ln209">    }</a>
<a name="ln210">  } else {</a>
<a name="ln211">    db_type = (name == common::kRedisKeyspaceName ? YQL_DATABASE_REDIS : default_if_no_prefix);</a>
<a name="ln212">  }</a>
<a name="ln213">  return TypedNamespaceName{.db_type = db_type, .name = name.cdata()};</a>
<a name="ln214">}</a>
<a name="ln215"> </a>
<a name="ln216">Slice GetTableIdAsSlice(const YBTableName&amp; table_name) {</a>
<a name="ln217">  return table_name.table_id();</a>
<a name="ln218">}</a>
<a name="ln219"> </a>
<a name="ln220">Slice GetNamespaceIdAsSlice(const YBTableName&amp; table_name) {</a>
<a name="ln221">  return table_name.namespace_id();</a>
<a name="ln222">}</a>
<a name="ln223"> </a>
<a name="ln224">Slice GetTableNameAsSlice(const YBTableName&amp; table_name) {</a>
<a name="ln225">  return table_name.table_name();</a>
<a name="ln226">}</a>
<a name="ln227"> </a>
<a name="ln228">std::string FullNamespaceName(const master::NamespaceIdentifierPB&amp; ns) {</a>
<a name="ln229">  return Format(&quot;$0.$1&quot;, DatabasePrefix(ns.database_type()), ns.name());</a>
<a name="ln230">}</a>
<a name="ln231"> </a>
<a name="ln232">struct NamespaceKey {</a>
<a name="ln233">  explicit NamespaceKey(const master::NamespaceIdentifierPB&amp; ns)</a>
<a name="ln234">      : db_type(ns.database_type()), name(ns.name()) {</a>
<a name="ln235">  }</a>
<a name="ln236"> </a>
<a name="ln237">  NamespaceKey(YQLDatabase d, const Slice&amp; n)</a>
<a name="ln238">      : db_type(d), name(n) {</a>
<a name="ln239">  }</a>
<a name="ln240"> </a>
<a name="ln241">  YQLDatabase db_type;</a>
<a name="ln242">  Slice name;</a>
<a name="ln243">};</a>
<a name="ln244"> </a>
<a name="ln245">struct NamespaceComparator {</a>
<a name="ln246">  using is_transparent = void;</a>
<a name="ln247"> </a>
<a name="ln248">  bool operator()(const master::NamespaceIdentifierPB&amp; lhs,</a>
<a name="ln249">                  const master::NamespaceIdentifierPB&amp; rhs) const {</a>
<a name="ln250">    return (*this)(NamespaceKey(lhs), NamespaceKey(rhs));</a>
<a name="ln251">  }</a>
<a name="ln252"> </a>
<a name="ln253">  bool operator()(const master::NamespaceIdentifierPB&amp; lhs, const NamespaceKey&amp; rhs) const {</a>
<a name="ln254">    return (*this)(NamespaceKey(lhs), rhs);</a>
<a name="ln255">  }</a>
<a name="ln256"> </a>
<a name="ln257">  bool operator()(const NamespaceKey&amp; lhs, const master::NamespaceIdentifierPB&amp; rhs) const {</a>
<a name="ln258">    return (*this)(lhs, NamespaceKey(rhs));</a>
<a name="ln259">  }</a>
<a name="ln260"> </a>
<a name="ln261">  bool operator()(const NamespaceKey&amp; lhs, const NamespaceKey&amp; rhs) const {</a>
<a name="ln262">    return lhs.db_type &lt; rhs.db_type ||</a>
<a name="ln263">           (lhs.db_type == rhs.db_type &amp;&amp; lhs.name.compare(rhs.name) &lt; 0);</a>
<a name="ln264">  }</a>
<a name="ln265">};</a>
<a name="ln266"> </a>
<a name="ln267">struct DotStringParts {</a>
<a name="ln268">  Slice prefix;</a>
<a name="ln269">  Slice value;</a>
<a name="ln270">};</a>
<a name="ln271"> </a>
<a name="ln272">DotStringParts SplitByDot(const std::string&amp; str) {</a>
<a name="ln273">  const size_t dot_pos = str.find('.');</a>
<a name="ln274">  DotStringParts result{.prefix = Slice(), .value = str};</a>
<a name="ln275">  if (dot_pos != string::npos) {</a>
<a name="ln276">    result.prefix = Slice(str.data(), dot_pos);</a>
<a name="ln277">    result.value.remove_prefix(dot_pos + 1);</a>
<a name="ln278">  }</a>
<a name="ln279">  return result;</a>
<a name="ln280">}</a>
<a name="ln281"> </a>
<a name="ln282">}  // anonymous namespace</a>
<a name="ln283"> </a>
<a name="ln284">class TableNameResolver::Impl {</a>
<a name="ln285"> public:</a>
<a name="ln286">  struct TableIdTag;</a>
<a name="ln287">  struct TableNameTag;</a>
<a name="ln288">  using Values = std::vector&lt;client::YBTableName&gt;;</a>
<a name="ln289"> </a>
<a name="ln290">  Impl(std::vector&lt;YBTableName&gt; tables, vector&lt;master::NamespaceIdentifierPB&gt; namespaces)</a>
<a name="ln291">      : current_namespace_(nullptr) {</a>
<a name="ln292">    std::move(tables.begin(), tables.end(), std::inserter(tables_, tables_.end()));</a>
<a name="ln293">    std::move(namespaces.begin(), namespaces.end(), std::inserter(namespaces_, namespaces_.end()));</a>
<a name="ln294">  }</a>
<a name="ln295"> </a>
<a name="ln296">  Result&lt;bool&gt; Feed(const std::string&amp; str) {</a>
<a name="ln297">    const auto result = FeedImpl(str);</a>
<a name="ln298">    if (!result.ok()) {</a>
<a name="ln299">      current_namespace_ = nullptr;</a>
<a name="ln300">    }</a>
<a name="ln301">    return result;</a>
<a name="ln302">  }</a>
<a name="ln303"> </a>
<a name="ln304">  Values&amp; values() {</a>
<a name="ln305">    return values_;</a>
<a name="ln306">  }</a>
<a name="ln307"> </a>
<a name="ln308"> private:</a>
<a name="ln309">  Result&lt;bool&gt; FeedImpl(const std::string&amp; str) {</a>
<a name="ln310">    auto parts = SplitByDot(str);</a>
<a name="ln311">    if (parts.prefix == kTableIDPrefix) {</a>
<a name="ln312">      RETURN_NOT_OK(ProcessTableId(parts.value));</a>
<a name="ln313">      return true;</a>
<a name="ln314">    } else {</a>
<a name="ln315">      if (!current_namespace_) {</a>
<a name="ln316">        RETURN_NOT_OK(ProcessNamespace(parts.prefix, parts.value));</a>
<a name="ln317">      } else {</a>
<a name="ln318">        if (parts.prefix.empty()) {</a>
<a name="ln319">          RETURN_NOT_OK(ProcessTableName(parts.value));</a>
<a name="ln320">          return true;</a>
<a name="ln321">        }</a>
<a name="ln322">        return STATUS(InvalidArgument, &quot;Wrong table name &quot; + str);</a>
<a name="ln323">      }</a>
<a name="ln324">    }</a>
<a name="ln325">    return false;</a>
<a name="ln326">  }</a>
<a name="ln327"> </a>
<a name="ln328">  CHECKED_STATUS ProcessNamespace(const Slice&amp; prefix, const Slice&amp; value) {</a>
<a name="ln329">    DCHECK(!current_namespace_);</a>
<a name="ln330">    const auto ns = VERIFY_RESULT(ResolveNamespaceName(prefix, value));</a>
<a name="ln331">    const auto i = namespaces_.find(NamespaceKey(ns.db_type, ns.name));</a>
<a name="ln332">    if (i != namespaces_.end()) {</a>
<a name="ln333">      current_namespace_ = &amp;*i;</a>
<a name="ln334">      return Status::OK();</a>
<a name="ln335">    }</a>
<a name="ln336">    return STATUS_FORMAT(</a>
<a name="ln337">        InvalidArgument, &quot;Namespace '$0' of type '$1' not found&quot;,</a>
<a name="ln338">        ns.name, DatabasePrefix(ns.db_type));</a>
<a name="ln339">  }</a>
<a name="ln340"> </a>
<a name="ln341">  CHECKED_STATUS ProcessTableId(const Slice&amp; table_id) {</a>
<a name="ln342">    const auto&amp; idx = tables_.get&lt;TableIdTag&gt;();</a>
<a name="ln343">    const auto i = idx.find(table_id);</a>
<a name="ln344">    if (i == idx.end()) {</a>
<a name="ln345">      return STATUS_FORMAT(InvalidArgument, &quot;Table with id '$0' not found&quot;, table_id);</a>
<a name="ln346">    }</a>
<a name="ln347">    if (current_namespace_ &amp;&amp; current_namespace_-&gt;id() != i-&gt;namespace_id()) {</a>
<a name="ln348">      return STATUS_FORMAT(</a>
<a name="ln349">          InvalidArgument, &quot;Table with id '$0' belongs to different namespace '$1'&quot;,</a>
<a name="ln350">          table_id, FullNamespaceName(*current_namespace_));</a>
<a name="ln351">    }</a>
<a name="ln352">    AppendTable(*i);</a>
<a name="ln353">    return Status::OK();</a>
<a name="ln354">  }</a>
<a name="ln355"> </a>
<a name="ln356">  CHECKED_STATUS ProcessTableName(const Slice&amp; table_name) {</a>
<a name="ln357">    DCHECK(current_namespace_);</a>
<a name="ln358">    const auto&amp; idx = tables_.get&lt;TableNameTag&gt;();</a>
<a name="ln359">    const auto key = boost::make_tuple(Slice(current_namespace_-&gt;id()), table_name);</a>
<a name="ln360">    // For some reason idx.equal_range(key) failed to compile.</a>
<a name="ln361">    const auto range = std::make_pair(idx.lower_bound(key), idx.upper_bound(key));</a>
<a name="ln362">    switch (std::distance(range.first, range.second)) {</a>
<a name="ln363">      case 0:</a>
<a name="ln364">        return STATUS_FORMAT(</a>
<a name="ln365">            InvalidArgument, &quot;Table with name '$0' not found in namespace '$1'&quot;,</a>
<a name="ln366">            table_name, FullNamespaceName(*current_namespace_));</a>
<a name="ln367">      case 1:</a>
<a name="ln368">        AppendTable(*range.first);</a>
<a name="ln369">        return Status::OK();</a>
<a name="ln370">      default:</a>
<a name="ln371">        return STATUS_FORMAT(</a>
<a name="ln372">            InvalidArgument,</a>
<a name="ln373">            &quot;Namespace '$0' has multiple tables named '$1', specify table id instead&quot;,</a>
<a name="ln374">            FullNamespaceName(*current_namespace_), table_name);</a>
<a name="ln375">    }</a>
<a name="ln376">  }</a>
<a name="ln377"> </a>
<a name="ln378">  void AppendTable(const YBTableName&amp; table) {</a>
<a name="ln379">    current_namespace_ = nullptr;</a>
<a name="ln380">    values_.push_back(table);</a>
<a name="ln381">  }</a>
<a name="ln382"> </a>
<a name="ln383">  using TableContainer = boost::multi_index_container&lt;YBTableName,</a>
<a name="ln384">      boost::multi_index::indexed_by&lt;</a>
<a name="ln385">          boost::multi_index::ordered_unique&lt;</a>
<a name="ln386">              boost::multi_index::tag&lt;TableIdTag&gt;,</a>
<a name="ln387">              boost::multi_index::global_fun&lt;const YBTableName&amp;, Slice, &amp;GetTableIdAsSlice&gt;,</a>
<a name="ln388">              Slice::Comparator</a>
<a name="ln389">          &gt;,</a>
<a name="ln390">          boost::multi_index::ordered_non_unique&lt;</a>
<a name="ln391">              boost::multi_index::tag&lt;TableNameTag&gt;,</a>
<a name="ln392">              boost::multi_index::composite_key&lt;</a>
<a name="ln393">                  YBTableName,</a>
<a name="ln394">                  boost::multi_index::global_fun&lt;const YBTableName&amp;, Slice, &amp;GetNamespaceIdAsSlice&gt;,</a>
<a name="ln395">                  boost::multi_index::global_fun&lt;const YBTableName&amp;, Slice, &amp;GetTableNameAsSlice&gt;</a>
<a name="ln396">              &gt;,</a>
<a name="ln397">              boost::multi_index::composite_key_compare&lt;</a>
<a name="ln398">                  Slice::Comparator,</a>
<a name="ln399">                  Slice::Comparator</a>
<a name="ln400">              &gt;</a>
<a name="ln401">          &gt;</a>
<a name="ln402">      &gt;</a>
<a name="ln403">  &gt;;</a>
<a name="ln404"> </a>
<a name="ln405">  TableContainer tables_;</a>
<a name="ln406">  std::set&lt;master::NamespaceIdentifierPB, NamespaceComparator&gt; namespaces_;</a>
<a name="ln407">  const master::NamespaceIdentifierPB* current_namespace_;</a>
<a name="ln408">  Values values_;</a>
<a name="ln409">};</a>
<a name="ln410"> </a>
<a name="ln411">TableNameResolver::TableNameResolver(std::vector&lt;client::YBTableName&gt; tables,</a>
<a name="ln412">                                     std::vector&lt;master::NamespaceIdentifierPB&gt; namespaces)</a>
<a name="ln413">    : impl_(new Impl(std::move(tables), std::move(namespaces))) {</a>
<a name="ln414">}</a>
<a name="ln415"> </a>
<a name="ln416">TableNameResolver::TableNameResolver(TableNameResolver&amp;&amp;) = default;</a>
<a name="ln417"> </a>
<a name="ln418">TableNameResolver::~TableNameResolver() = default;</a>
<a name="ln419"> </a>
<a name="ln420">Result&lt;bool&gt; TableNameResolver::Feed(const std::string&amp; value) {</a>
<a name="ln421">  return impl_-&gt;Feed(value);</a>
<a name="ln422">}</a>
<a name="ln423"> </a>
<a name="ln424">std::vector&lt;client::YBTableName&gt;&amp; TableNameResolver::values() {</a>
<a name="ln425">  return impl_-&gt;values();</a>
<a name="ln426">}</a>
<a name="ln427"> </a>
<a name="ln428">ClusterAdminClient::ClusterAdminClient(string addrs, MonoDelta timeout)</a>
<a name="ln429">    : master_addr_list_(std::move(addrs)),</a>
<a name="ln430">      timeout_(timeout),</a>
<a name="ln431">      initted_(false) {}</a>
<a name="ln432"> </a>
<a name="ln433">ClusterAdminClient::ClusterAdminClient(const HostPort&amp; init_master_addr, MonoDelta timeout)</a>
<a name="ln434">    : init_master_addr_(init_master_addr),</a>
<a name="ln435">      timeout_(timeout),</a>
<a name="ln436">      initted_(false) {}</a>
<a name="ln437"> </a>
<a name="ln438">ClusterAdminClient::~ClusterAdminClient() {</a>
<a name="ln439">  if (messenger_) {</a>
<a name="ln440">    messenger_-&gt;Shutdown();</a>
<a name="ln441">  }</a>
<a name="ln442">}</a>
<a name="ln443"> </a>
<a name="ln444">Status ClusterAdminClient::DiscoverAllMasters(</a>
<a name="ln445">    const HostPort&amp; init_master_addr,</a>
<a name="ln446">    std::string* all_master_addrs</a>
<a name="ln447">) {</a>
<a name="ln448"> </a>
<a name="ln449">  std::unique_ptr&lt;MasterServiceProxy&gt; master_proxy(new MasterServiceProxy(</a>
<a name="ln450">      proxy_cache_.get(),</a>
<a name="ln451">      init_master_addr));</a>
<a name="ln452"> </a>
<a name="ln453">  VLOG(0) &lt;&lt; &quot;Initializing master leader list from single master at &quot;</a>
<a name="ln454">          &lt;&lt; init_master_addr.ToString();</a>
<a name="ln455">  const auto list_resp = VERIFY_RESULT(InvokeRpc(&amp;MasterServiceProxy::ListMasters,</a>
<a name="ln456">      master_proxy.get(), ListMastersRequestPB()));</a>
<a name="ln457">  if (list_resp.masters().empty()) {</a>
<a name="ln458">    return  STATUS(NotFound, &quot;no masters found&quot;);</a>
<a name="ln459">  }</a>
<a name="ln460"> </a>
<a name="ln461">  std::vector&lt;std::string&gt; addrs;</a>
<a name="ln462">  for (const auto&amp; master : list_resp.masters()) {</a>
<a name="ln463">    if (!master.has_registration()) {</a>
<a name="ln464">      LOG(WARNING) &lt;&lt; master.instance_id().permanent_uuid() &lt;&lt; &quot; has no registration.&quot;;</a>
<a name="ln465">      continue;</a>
<a name="ln466">    }</a>
<a name="ln467"> </a>
<a name="ln468">    if (master.registration().broadcast_addresses_size() &gt; 0) {</a>
<a name="ln469">      addrs.push_back(FormatFirstHostPort(master.registration().broadcast_addresses()));</a>
<a name="ln470">    } else if (master.registration().private_rpc_addresses_size() &gt; 0) {</a>
<a name="ln471">      addrs.push_back(FormatFirstHostPort(master.registration().private_rpc_addresses()));</a>
<a name="ln472">    } else {</a>
<a name="ln473">      LOG(WARNING) &lt;&lt; master.instance_id().permanent_uuid() &lt;&lt; &quot; has no rpc/broadcast address.&quot;;</a>
<a name="ln474">      continue;</a>
<a name="ln475">    }</a>
<a name="ln476">  }</a>
<a name="ln477"> </a>
<a name="ln478">  if (addrs.empty()) {</a>
<a name="ln479">    return STATUS(NotFound, &quot;no masters found&quot;);</a>
<a name="ln480">  }</a>
<a name="ln481"> </a>
<a name="ln482">  JoinStrings(addrs, &quot;,&quot;, all_master_addrs);</a>
<a name="ln483">  VLOG(0) &lt;&lt; &quot;Discovered full master list: &quot; &lt;&lt; *all_master_addrs;</a>
<a name="ln484">  return Status::OK();</a>
<a name="ln485">}</a>
<a name="ln486"> </a>
<a name="ln487">Status ClusterAdminClient::Init() {</a>
<a name="ln488">  CHECK(!initted_);</a>
<a name="ln489"> </a>
<a name="ln490">  // Check if caller will initialize the client and related parts.</a>
<a name="ln491">  rpc::MessengerBuilder messenger_builder(&quot;yb-admin&quot;);</a>
<a name="ln492">  if (!FLAGS_certs_dir_name.empty()) {</a>
<a name="ln493">    LOG(INFO) &lt;&lt; &quot;Built secure client using certs dir &quot; &lt;&lt; FLAGS_certs_dir_name;</a>
<a name="ln494">    secure_context_ = VERIFY_RESULT(server::CreateSecureContext(FLAGS_certs_dir_name));</a>
<a name="ln495">    server::ApplySecureContext(secure_context_.get(), &amp;messenger_builder);</a>
<a name="ln496">  }</a>
<a name="ln497"> </a>
<a name="ln498">  messenger_ = VERIFY_RESULT(messenger_builder.Build());</a>
<a name="ln499">  proxy_cache_ = std::make_unique&lt;rpc::ProxyCache&gt;(messenger_.get());</a>
<a name="ln500"> </a>
<a name="ln501">  if (!init_master_addr_.host().empty()) {</a>
<a name="ln502">    RETURN_NOT_OK(DiscoverAllMasters(init_master_addr_, &amp;master_addr_list_));</a>
<a name="ln503">  }</a>
<a name="ln504"> </a>
<a name="ln505">  yb_client_ = VERIFY_RESULT(YBClientBuilder()</a>
<a name="ln506">      .add_master_server_addr(master_addr_list_)</a>
<a name="ln507">      .default_admin_operation_timeout(timeout_)</a>
<a name="ln508">      .wait_for_leader_election_on_init(FLAGS_wait_if_no_leader_master)</a>
<a name="ln509">      .Build(messenger_.get()));</a>
<a name="ln510"> </a>
<a name="ln511">  // Find the leader master's socket info to set up the master proxy.</a>
<a name="ln512">  leader_addr_ = yb_client_-&gt;GetMasterLeaderAddress();</a>
<a name="ln513">  master_proxy_.reset(new MasterServiceProxy(proxy_cache_.get(), leader_addr_));</a>
<a name="ln514"> </a>
<a name="ln515">  rpc::ProxyCache proxy_cache(messenger_.get());</a>
<a name="ln516">  master_backup_proxy_.reset(new master::MasterBackupServiceProxy(&amp;proxy_cache, leader_addr_));</a>
<a name="ln517"> </a>
<a name="ln518">  initted_ = true;</a>
<a name="ln519">  return Status::OK();</a>
<a name="ln520">}</a>
<a name="ln521"> </a>
<a name="ln522">Status ClusterAdminClient::MasterLeaderStepDown(</a>
<a name="ln523">    const string&amp; leader_uuid,</a>
<a name="ln524">    const string&amp; new_leader_uuid) {</a>
<a name="ln525">  auto master_proxy = std::make_unique&lt;ConsensusServiceProxy&gt;(proxy_cache_.get(), leader_addr_);</a>
<a name="ln526"> </a>
<a name="ln527">  return LeaderStepDown(leader_uuid, yb::master::kSysCatalogTabletId,</a>
<a name="ln528">      new_leader_uuid, &amp;master_proxy);</a>
<a name="ln529">}</a>
<a name="ln530"> </a>
<a name="ln531">CHECKED_STATUS ClusterAdminClient::LeaderStepDownWithNewLeader(</a>
<a name="ln532">    const std::string&amp; tablet_id,</a>
<a name="ln533">    const std::string&amp; dest_ts_uuid) {</a>
<a name="ln534">  return LeaderStepDown(</a>
<a name="ln535">      /* leader_uuid */ std::string(),</a>
<a name="ln536">      tablet_id,</a>
<a name="ln537">      dest_ts_uuid,</a>
<a name="ln538">      /* leader_proxy */ nullptr);</a>
<a name="ln539">}</a>
<a name="ln540"> </a>
<a name="ln541">Status ClusterAdminClient::LeaderStepDown(</a>
<a name="ln542">    const PeerId&amp; leader_uuid,</a>
<a name="ln543">    const TabletId&amp; tablet_id,</a>
<a name="ln544">    const PeerId&amp; new_leader_uuid,</a>
<a name="ln545">    std::unique_ptr&lt;ConsensusServiceProxy&gt;* leader_proxy) {</a>
<a name="ln546">  LeaderStepDownRequestPB req;</a>
<a name="ln547">  req.set_tablet_id(tablet_id);</a>
<a name="ln548">  if (!new_leader_uuid.empty()) {</a>
<a name="ln549">    req.set_new_leader_uuid(new_leader_uuid);</a>
<a name="ln550">  } else {</a>
<a name="ln551">    if (FLAGS_disable_graceful_transition) {</a>
<a name="ln552">      req.set_disable_graceful_transition(true);</a>
<a name="ln553">    }</a>
<a name="ln554">  }</a>
<a name="ln555">  // The API for InvokeRpcNoResponseCheck requires a raw pointer to a ConsensusServiceProxy, so</a>
<a name="ln556">  // cache it outside, if we are creating a new proxy to a previously unknown leader.</a>
<a name="ln557">  std::unique_ptr&lt;ConsensusServiceProxy&gt; new_proxy;</a>
<a name="ln558">  if (!leader_uuid.empty()) {</a>
<a name="ln559">    // TODO: validate leader_proxy ?</a>
<a name="ln560">    req.set_dest_uuid(leader_uuid);</a>
<a name="ln561">  } else {</a>
<a name="ln562">    // Look up the location of the tablet leader from the Master.</a>
<a name="ln563">    HostPort leader_addr;</a>
<a name="ln564">    string lookup_leader_uuid;</a>
<a name="ln565">    RETURN_NOT_OK(SetTabletPeerInfo(tablet_id, LEADER, &amp;lookup_leader_uuid, &amp;leader_addr));</a>
<a name="ln566">    req.set_dest_uuid(lookup_leader_uuid);</a>
<a name="ln567">    new_proxy = std::make_unique&lt;ConsensusServiceProxy&gt;(proxy_cache_.get(), leader_addr);</a>
<a name="ln568">  }</a>
<a name="ln569">  VLOG(2) &lt;&lt; &quot;Sending request &quot; &lt;&lt; req.DebugString() &lt;&lt; &quot; to node with uuid [&quot; &lt;&lt; leader_uuid</a>
<a name="ln570">          &lt;&lt; &quot;]&quot;;</a>
<a name="ln571">  const auto resp = VERIFY_RESULT(InvokeRpcNoResponseCheck(&amp;ConsensusServiceProxy::LeaderStepDown,</a>
<a name="ln572">      new_proxy ? new_proxy.get() : leader_proxy-&gt;get(),</a>
<a name="ln573">      req));</a>
<a name="ln574">  if (resp.has_error()) {</a>
<a name="ln575">    LOG(ERROR) &lt;&lt; &quot;LeaderStepDown for &quot; &lt;&lt; leader_uuid &lt;&lt; &quot;received error &quot;</a>
<a name="ln576">      &lt;&lt; resp.error().ShortDebugString();</a>
<a name="ln577">    return StatusFromPB(resp.error().status());</a>
<a name="ln578">  }</a>
<a name="ln579">  return Status::OK();</a>
<a name="ln580">}</a>
<a name="ln581"> </a>
<a name="ln582">// Force start an election on a randomly chosen non-leader peer of this tablet's raft quorum.</a>
<a name="ln583">Status ClusterAdminClient::StartElection(const TabletId&amp; tablet_id) {</a>
<a name="ln584">  HostPort non_leader_addr;</a>
<a name="ln585">  string non_leader_uuid;</a>
<a name="ln586">  RETURN_NOT_OK(SetTabletPeerInfo(tablet_id, FOLLOWER, &amp;non_leader_uuid, &amp;non_leader_addr));</a>
<a name="ln587">  ConsensusServiceProxy non_leader_proxy(proxy_cache_.get(), non_leader_addr);</a>
<a name="ln588">  RunLeaderElectionRequestPB req;</a>
<a name="ln589">  req.set_dest_uuid(non_leader_uuid);</a>
<a name="ln590">  req.set_tablet_id(tablet_id);</a>
<a name="ln591">  return ResultToStatus(InvokeRpc(&amp;ConsensusServiceProxy::RunLeaderElection,</a>
<a name="ln592">      &amp;non_leader_proxy, req));</a>
<a name="ln593">}</a>
<a name="ln594"> </a>
<a name="ln595">// Look up the location of the tablet server leader or non-leader peer from the leader master</a>
<a name="ln596">Status ClusterAdminClient::SetTabletPeerInfo(</a>
<a name="ln597">    const TabletId&amp; tablet_id,</a>
<a name="ln598">    PeerMode mode,</a>
<a name="ln599">    PeerId* peer_uuid,</a>
<a name="ln600">    HostPort* peer_addr) {</a>
<a name="ln601">  TSInfoPB peer_ts_info;</a>
<a name="ln602">  RETURN_NOT_OK(GetTabletPeer(tablet_id, mode, &amp;peer_ts_info));</a>
<a name="ln603">  auto rpc_addresses = peer_ts_info.private_rpc_addresses();</a>
<a name="ln604">  CHECK_GT(rpc_addresses.size(), 0) &lt;&lt; peer_ts_info</a>
<a name="ln605">        .ShortDebugString();</a>
<a name="ln606"> </a>
<a name="ln607">  *peer_addr = HostPortFromPB(rpc_addresses.Get(0));</a>
<a name="ln608">  *peer_uuid = peer_ts_info.permanent_uuid();</a>
<a name="ln609">  return Status::OK();</a>
<a name="ln610">}</a>
<a name="ln611"> </a>
<a name="ln612">Status ClusterAdminClient::ParseChangeType(</a>
<a name="ln613">    const string&amp; change_type,</a>
<a name="ln614">    consensus::ChangeConfigType* cc_type) {</a>
<a name="ln615">  consensus::ChangeConfigType cctype = consensus::UNKNOWN_CHANGE;</a>
<a name="ln616">  *cc_type = cctype;</a>
<a name="ln617">  string uppercase_change_type;</a>
<a name="ln618">  ToUpperCase(change_type, &amp;uppercase_change_type);</a>
<a name="ln619">  if (!consensus::ChangeConfigType_Parse(uppercase_change_type, &amp;cctype) ||</a>
<a name="ln620">    cctype == consensus::UNKNOWN_CHANGE) {</a>
<a name="ln621">    return STATUS(InvalidArgument, &quot;Unsupported change_type&quot;, change_type);</a>
<a name="ln622">  }</a>
<a name="ln623"> </a>
<a name="ln624">  *cc_type = cctype;</a>
<a name="ln625"> </a>
<a name="ln626">  return Status::OK();</a>
<a name="ln627">}</a>
<a name="ln628"> </a>
<a name="ln629">Status ClusterAdminClient::ChangeConfig(</a>
<a name="ln630">    const TabletId&amp; tablet_id,</a>
<a name="ln631">    const string&amp; change_type,</a>
<a name="ln632">    const PeerId&amp; peer_uuid,</a>
<a name="ln633">    const boost::optional&lt;string&gt;&amp; member_type) {</a>
<a name="ln634">  CHECK(initted_);</a>
<a name="ln635"> </a>
<a name="ln636">  consensus::ChangeConfigType cc_type;</a>
<a name="ln637">  RETURN_NOT_OK(ParseChangeType(change_type, &amp;cc_type));</a>
<a name="ln638"> </a>
<a name="ln639">  RaftPeerPB peer_pb;</a>
<a name="ln640">  peer_pb.set_permanent_uuid(peer_uuid);</a>
<a name="ln641"> </a>
<a name="ln642">  // Parse the optional fields.</a>
<a name="ln643">  if (member_type) {</a>
<a name="ln644">    RaftPeerPB::MemberType member_type_val;</a>
<a name="ln645">    string uppercase_member_type;</a>
<a name="ln646">    ToUpperCase(*member_type, &amp;uppercase_member_type);</a>
<a name="ln647">    if (!RaftPeerPB::MemberType_Parse(uppercase_member_type, &amp;member_type_val)) {</a>
<a name="ln648">      return STATUS(InvalidArgument, &quot;Unrecognized member_type&quot;, *member_type);</a>
<a name="ln649">    }</a>
<a name="ln650">    if (member_type_val != RaftPeerPB::PRE_VOTER &amp;&amp; member_type_val != RaftPeerPB::PRE_OBSERVER) {</a>
<a name="ln651">      return STATUS(InvalidArgument, &quot;member_type should be PRE_VOTER or PRE_OBSERVER&quot;);</a>
<a name="ln652">    }</a>
<a name="ln653">    peer_pb.set_member_type(member_type_val);</a>
<a name="ln654">  }</a>
<a name="ln655"> </a>
<a name="ln656">  // Validate the existence of the optional fields.</a>
<a name="ln657">  if (!member_type &amp;&amp; cc_type == consensus::ADD_SERVER) {</a>
<a name="ln658">    return STATUS(InvalidArgument, &quot;Must specify member_type when adding a server.&quot;);</a>
<a name="ln659">  }</a>
<a name="ln660"> </a>
<a name="ln661">  // Look up RPC address of peer if adding as a new server.</a>
<a name="ln662">  if (cc_type == consensus::ADD_SERVER) {</a>
<a name="ln663">    HostPort host_port = VERIFY_RESULT(GetFirstRpcAddressForTS(peer_uuid));</a>
<a name="ln664">    HostPortToPB(host_port, peer_pb.mutable_last_known_private_addr()-&gt;Add());</a>
<a name="ln665">  }</a>
<a name="ln666"> </a>
<a name="ln667">  // Look up the location of the tablet leader from the Master.</a>
<a name="ln668">  HostPort leader_addr;</a>
<a name="ln669">  string leader_uuid;</a>
<a name="ln670">  RETURN_NOT_OK(SetTabletPeerInfo(tablet_id, LEADER, &amp;leader_uuid, &amp;leader_addr));</a>
<a name="ln671"> </a>
<a name="ln672">  auto consensus_proxy = std::make_unique&lt;ConsensusServiceProxy&gt;(proxy_cache_.get(), leader_addr);</a>
<a name="ln673">  // If removing the leader ts, then first make it step down and that</a>
<a name="ln674">  // starts an election and gets a new leader ts.</a>
<a name="ln675">  if (cc_type == consensus::REMOVE_SERVER &amp;&amp;</a>
<a name="ln676">      leader_uuid == peer_uuid) {</a>
<a name="ln677">    string old_leader_uuid = leader_uuid;</a>
<a name="ln678">    RETURN_NOT_OK(LeaderStepDown(</a>
<a name="ln679">          leader_uuid, tablet_id, /* new_leader_uuid */ std::string(), &amp;consensus_proxy));</a>
<a name="ln680">    sleep(5);  // TODO - election completion timing is not known accurately</a>
<a name="ln681">    RETURN_NOT_OK(SetTabletPeerInfo(tablet_id, LEADER, &amp;leader_uuid, &amp;leader_addr));</a>
<a name="ln682">    if (leader_uuid != old_leader_uuid) {</a>
<a name="ln683">      return STATUS(ConfigurationError,</a>
<a name="ln684">                    &quot;Old tablet server leader same as new even after re-election!&quot;);</a>
<a name="ln685">    }</a>
<a name="ln686">    consensus_proxy.reset(new ConsensusServiceProxy(proxy_cache_.get(), leader_addr));</a>
<a name="ln687">  }</a>
<a name="ln688"> </a>
<a name="ln689">  consensus::ChangeConfigRequestPB req;</a>
<a name="ln690">  req.set_dest_uuid(leader_uuid);</a>
<a name="ln691">  req.set_tablet_id(tablet_id);</a>
<a name="ln692">  req.set_type(cc_type);</a>
<a name="ln693">  *req.mutable_server() = peer_pb;</a>
<a name="ln694">  return ResultToStatus(InvokeRpc(&amp;ConsensusServiceProxy::ChangeConfig,</a>
<a name="ln695">      consensus_proxy.get(), req));</a>
<a name="ln696">}</a>
<a name="ln697"> </a>
<a name="ln698">Result&lt;std::string&gt; ClusterAdminClient::GetMasterLeaderUuid() {</a>
<a name="ln699">  std::string leader_uuid;</a>
<a name="ln700">  const auto list_resp = VERIFY_RESULT_PREPEND(</a>
<a name="ln701">      InvokeRpc(&amp;MasterServiceProxy::ListMasters, master_proxy_.get(), ListMastersRequestPB()),</a>
<a name="ln702">      &quot;Could not locate master leader&quot;);</a>
<a name="ln703">  for (const auto&amp; master : list_resp.masters()) {</a>
<a name="ln704">    if (master.role() == RaftPeerPB::LEADER) {</a>
<a name="ln705">      SCHECK(</a>
<a name="ln706">          leader_uuid.empty(), ConfigurationError, &quot;Found two LEADER's in the same raft config.&quot;);</a>
<a name="ln707">      leader_uuid = master.instance_id().permanent_uuid();</a>
<a name="ln708">    }</a>
<a name="ln709">  }</a>
<a name="ln710">  SCHECK(!leader_uuid.empty(), ConfigurationError, &quot;Could not locate master leader!&quot;);</a>
<a name="ln711">  return std::move(leader_uuid);</a>
<a name="ln712">}</a>
<a name="ln713"> </a>
<a name="ln714">Status ClusterAdminClient::DumpMasterState(bool to_console) {</a>
<a name="ln715">  CHECK(initted_);</a>
<a name="ln716">  master::DumpMasterStateRequestPB req;</a>
<a name="ln717">  req.set_peers_also(true);</a>
<a name="ln718">  req.set_on_disk(true);</a>
<a name="ln719">  req.set_return_dump_as_string(to_console);</a>
<a name="ln720"> </a>
<a name="ln721">  const auto resp = VERIFY_RESULT(InvokeRpc(</a>
<a name="ln722">      &amp;MasterServiceProxy::DumpState, master_proxy_.get(), req));</a>
<a name="ln723"> </a>
<a name="ln724">  if (to_console) {</a>
<a name="ln725">    cout &lt;&lt; resp.dump() &lt;&lt; endl;</a>
<a name="ln726">  } else {</a>
<a name="ln727">    cout &lt;&lt; &quot;Master state dump has been completed and saved into &quot;</a>
<a name="ln728">            &quot;the master respective log files.&quot; &lt;&lt; endl;</a>
<a name="ln729">  }</a>
<a name="ln730">  return Status::OK();</a>
<a name="ln731">}</a>
<a name="ln732"> </a>
<a name="ln733">Status ClusterAdminClient::GetLoadMoveCompletion() {</a>
<a name="ln734">  CHECK(initted_);</a>
<a name="ln735">  const auto resp = VERIFY_RESULT(InvokeRpc(</a>
<a name="ln736">      &amp;MasterServiceProxy::GetLoadMoveCompletion, master_proxy_.get(),</a>
<a name="ln737">      master::GetLoadMovePercentRequestPB()));</a>
<a name="ln738">  cout &lt;&lt; &quot;Percent complete = &quot; &lt;&lt; resp.percent() &lt;&lt; &quot; : &quot;</a>
<a name="ln739">    &lt;&lt; resp.remaining() &lt;&lt; &quot; remaining out of &quot; &lt;&lt; resp.total() &lt;&lt; endl;</a>
<a name="ln740">  return Status::OK();</a>
<a name="ln741">}</a>
<a name="ln742"> </a>
<a name="ln743">Status ClusterAdminClient::GetLeaderBlacklistCompletion() {</a>
<a name="ln744">  CHECK(initted_);</a>
<a name="ln745">  const auto resp = VERIFY_RESULT(InvokeRpc(</a>
<a name="ln746">      &amp;MasterServiceProxy::GetLeaderBlacklistCompletion, master_proxy_.get(),</a>
<a name="ln747">      master::GetLeaderBlacklistPercentRequestPB()));</a>
<a name="ln748">  cout &lt;&lt; &quot;Percent complete = &quot; &lt;&lt; resp.percent() &lt;&lt; &quot; : &quot;</a>
<a name="ln749">    &lt;&lt; resp.remaining() &lt;&lt; &quot; remaining out of &quot; &lt;&lt; resp.total() &lt;&lt; endl;</a>
<a name="ln750">  return Status::OK();</a>
<a name="ln751">}</a>
<a name="ln752"> </a>
<a name="ln753">Status ClusterAdminClient::GetIsLoadBalancerIdle() {</a>
<a name="ln754">  CHECK(initted_);</a>
<a name="ln755"> </a>
<a name="ln756">  const bool is_idle = VERIFY_RESULT(yb_client_-&gt;IsLoadBalancerIdle());</a>
<a name="ln757">  cout &lt;&lt; &quot;Idle = &quot; &lt;&lt; is_idle &lt;&lt; endl;</a>
<a name="ln758">  return Status::OK();</a>
<a name="ln759">}</a>
<a name="ln760"> </a>
<a name="ln761">Status ClusterAdminClient::ListLeaderCounts(const YBTableName&amp; table_name) {</a>
<a name="ln762">  unordered_map&lt;string, int&gt; leader_counts = VERIFY_RESULT(GetLeaderCounts(table_name));</a>
<a name="ln763">  int total_leader_count = 0;</a>
<a name="ln764">  for (const auto&amp; lc : leader_counts) { total_leader_count += lc.second; }</a>
<a name="ln765"> </a>
<a name="ln766">  // Calculate the standard deviation and adjusted deviation percentage according to the best and</a>
<a name="ln767">  // worst-case scenarios. Best-case distribution is when leaders are evenly distributed and</a>
<a name="ln768">  // worst-case is when leaders are all on one tablet server.</a>
<a name="ln769">  // For example, say we have 16 leaders on 3 tablet servers:</a>
<a name="ln770">  //   Leader distribution:    7 5 4</a>
<a name="ln771">  //   Best-case scenario:     6 5 5</a>
<a name="ln772">  //   Worst-case scenario:   12 0 0</a>
<a name="ln773">  //   Standard deviation:    1.24722</a>
<a name="ln774">  //   Adjusted deviation %:  10.9717%</a>
<a name="ln775">  vector&lt;double&gt; leader_dist, best_case, worst_case;</a>
<a name="ln776">  cout &lt;&lt; RightPadToUuidWidth(&quot;Server UUID&quot;) &lt;&lt; kColumnSep &lt;&lt; &quot;Leader Count&quot; &lt;&lt; endl;</a>
<a name="ln777">  for (const auto&amp; leader_count : leader_counts) {</a>
<a name="ln778">    cout &lt;&lt; leader_count.first &lt;&lt; kColumnSep &lt;&lt; leader_count.second &lt;&lt; endl;</a>
<a name="ln779">    leader_dist.push_back(leader_count.second);</a>
<a name="ln780">  }</a>
<a name="ln781"> </a>
<a name="ln782">  if (!leader_dist.empty()) {</a>
<a name="ln783">    for (int i = 0; i &lt; leader_dist.size(); ++i) {</a>
<a name="ln784">      best_case.push_back(total_leader_count / leader_dist.size());</a>
<a name="ln785">      worst_case.push_back(0);</a>
<a name="ln786">    }</a>
<a name="ln787">    for (int i = 0; i &lt; total_leader_count % leader_dist.size(); ++i) {</a>
<a name="ln788">      ++best_case[i];</a>
<a name="ln789">    }</a>
<a name="ln790">    worst_case[0] = total_leader_count;</a>
<a name="ln791"> </a>
<a name="ln792">    double stdev = yb::standard_deviation(leader_dist);</a>
<a name="ln793">    double best_stdev = yb::standard_deviation(best_case);</a>
<a name="ln794">    double worst_stdev = yb::standard_deviation(worst_case);</a>
<a name="ln795">    double percent_dev = (stdev - best_stdev) / (worst_stdev - best_stdev) * 100.0;</a>
<a name="ln796">    cout &lt;&lt; &quot;Standard deviation: &quot; &lt;&lt; stdev &lt;&lt; endl;</a>
<a name="ln797">    cout &lt;&lt; &quot;Adjusted deviation percentage: &quot; &lt;&lt; percent_dev &lt;&lt; &quot;%&quot; &lt;&lt; endl;</a>
<a name="ln798">  }</a>
<a name="ln799"> </a>
<a name="ln800">  return Status::OK();</a>
<a name="ln801">}</a>
<a name="ln802"> </a>
<a name="ln803">Result&lt;unordered_map&lt;string, int&gt;&gt; ClusterAdminClient::GetLeaderCounts(</a>
<a name="ln804">    const client::YBTableName&amp; table_name) {</a>
<a name="ln805">  vector&lt;string&gt; tablet_ids, ranges;</a>
<a name="ln806">  RETURN_NOT_OK(yb_client_-&gt;GetTablets(table_name, 0, &amp;tablet_ids, &amp;ranges));</a>
<a name="ln807">  master::GetTabletLocationsRequestPB req;</a>
<a name="ln808">  for (const auto&amp; tablet_id : tablet_ids) {</a>
<a name="ln809">    req.add_tablet_ids(tablet_id);</a>
<a name="ln810">  }</a>
<a name="ln811">  const auto resp = VERIFY_RESULT(InvokeRpc(&amp;MasterServiceProxy::GetTabletLocations,</a>
<a name="ln812">      master_proxy_.get(), req));</a>
<a name="ln813"> </a>
<a name="ln814">  unordered_map&lt;string, int&gt; leader_counts;</a>
<a name="ln815">  for (const auto&amp; locs : resp.tablet_locations()) {</a>
<a name="ln816">    for (const auto&amp; replica : locs.replicas()) {</a>
<a name="ln817">      const auto uuid = replica.ts_info().permanent_uuid();</a>
<a name="ln818">      switch(replica.role()) {</a>
<a name="ln819">        case RaftPeerPB::LEADER:</a>
<a name="ln820">          // If this is a leader, increment leader counts.</a>
<a name="ln821">          ++leader_counts[uuid];</a>
<a name="ln822">          break;</a>
<a name="ln823">        case RaftPeerPB::FOLLOWER:</a>
<a name="ln824">          // If this is a follower, touch the leader count entry also so that tablet server with</a>
<a name="ln825">          // followers only and 0 leader will be accounted for still.</a>
<a name="ln826">          leader_counts[uuid];</a>
<a name="ln827">          break;</a>
<a name="ln828">        default:</a>
<a name="ln829">          break;</a>
<a name="ln830">      }</a>
<a name="ln831">    }</a>
<a name="ln832">  }</a>
<a name="ln833"> </a>
<a name="ln834">  return leader_counts;</a>
<a name="ln835">}</a>
<a name="ln836"> </a>
<a name="ln837">Status ClusterAdminClient::SetupRedisTable() {</a>
<a name="ln838">  const YBTableName table_name(</a>
<a name="ln839">      YQL_DATABASE_REDIS, common::kRedisKeyspaceName, common::kRedisTableName);</a>
<a name="ln840">  RETURN_NOT_OK(yb_client_-&gt;CreateNamespaceIfNotExists(common::kRedisKeyspaceName,</a>
<a name="ln841">                                                       YQLDatabase::YQL_DATABASE_REDIS));</a>
<a name="ln842">  // Try to create the table.</a>
<a name="ln843">  std::unique_ptr&lt;yb::client::YBTableCreator&gt; table_creator(yb_client_-&gt;NewTableCreator());</a>
<a name="ln844">  Status s = table_creator-&gt;table_name(table_name)</a>
<a name="ln845">                              .table_type(yb::client::YBTableType::REDIS_TABLE_TYPE)</a>
<a name="ln846">                              .Create();</a>
<a name="ln847">  // If we could create it, then all good!</a>
<a name="ln848">  if (s.ok()) {</a>
<a name="ln849">    LOG(INFO) &lt;&lt; &quot;Table '&quot; &lt;&lt; table_name.ToString() &lt;&lt; &quot;' created.&quot;;</a>
<a name="ln850">    // If the table was already there, also not an error...</a>
<a name="ln851">  } else if (s.IsAlreadyPresent()) {</a>
<a name="ln852">    LOG(INFO) &lt;&lt; &quot;Table '&quot; &lt;&lt; table_name.ToString() &lt;&lt; &quot;' already exists&quot;;</a>
<a name="ln853">  } else {</a>
<a name="ln854">    // If any other error, report that!</a>
<a name="ln855">    LOG(ERROR) &lt;&lt; s;</a>
<a name="ln856">    RETURN_NOT_OK(s);</a>
<a name="ln857">  }</a>
<a name="ln858">  return Status::OK();</a>
<a name="ln859">}</a>
<a name="ln860"> </a>
<a name="ln861">Status ClusterAdminClient::DropRedisTable() {</a>
<a name="ln862">  const YBTableName table_name(</a>
<a name="ln863">      YQL_DATABASE_REDIS, common::kRedisKeyspaceName, common::kRedisTableName);</a>
<a name="ln864">  Status s = yb_client_-&gt;DeleteTable(table_name, true /* wait */);</a>
<a name="ln865">  if (s.ok()) {</a>
<a name="ln866">    LOG(INFO) &lt;&lt; &quot;Table '&quot; &lt;&lt; table_name.ToString() &lt;&lt; &quot;' deleted.&quot;;</a>
<a name="ln867">  } else if (s.IsNotFound()) {</a>
<a name="ln868">    LOG(INFO) &lt;&lt; &quot;Table '&quot; &lt;&lt; table_name.ToString() &lt;&lt; &quot;' does not exist.&quot;;</a>
<a name="ln869">  } else {</a>
<a name="ln870">    RETURN_NOT_OK(s);</a>
<a name="ln871">  }</a>
<a name="ln872">  return Status::OK();</a>
<a name="ln873">}</a>
<a name="ln874"> </a>
<a name="ln875">Status ClusterAdminClient::ChangeMasterConfig(</a>
<a name="ln876">    const string&amp; change_type,</a>
<a name="ln877">    const string&amp; peer_host,</a>
<a name="ln878">    int16 peer_port,</a>
<a name="ln879">    bool use_hostport) {</a>
<a name="ln880">  CHECK(initted_);</a>
<a name="ln881"> </a>
<a name="ln882">  VLOG(1) &lt;&lt; &quot;ChangeMasterConfig: &quot; &lt;&lt; change_type &lt;&lt; &quot; | &quot; &lt;&lt; peer_host &lt;&lt; &quot;:&quot; &lt;&lt; peer_port;</a>
<a name="ln883">  consensus::ChangeConfigType cc_type;</a>
<a name="ln884">  RETURN_NOT_OK(ParseChangeType(change_type, &amp;cc_type));</a>
<a name="ln885"> </a>
<a name="ln886">  string peer_uuid;</a>
<a name="ln887">  if (!use_hostport) {</a>
<a name="ln888">      VLOG(1) &lt;&lt; &quot;ChangeMasterConfig: attempt to get UUID for changed host: &quot;</a>
<a name="ln889">              &lt;&lt; peer_host &lt;&lt; &quot;:&quot; &lt;&lt; peer_port;</a>
<a name="ln890">      RETURN_NOT_OK(yb_client_-&gt;GetMasterUUID(peer_host, peer_port, &amp;peer_uuid));</a>
<a name="ln891">  }</a>
<a name="ln892"> </a>
<a name="ln893">  auto leader_uuid = VERIFY_RESULT(GetMasterLeaderUuid());</a>
<a name="ln894"> </a>
<a name="ln895">  // If removing the leader master, then first make it step down and that</a>
<a name="ln896">  // starts an election and gets a new leader master.</a>
<a name="ln897">  auto changed_leader_addr = leader_addr_;</a>
<a name="ln898">  if (cc_type == consensus::REMOVE_SERVER &amp;&amp; leader_uuid == peer_uuid) {</a>
<a name="ln899">    VLOG(1) &lt;&lt; &quot;ChangeMasterConfig: request leader &quot; &lt;&lt; leader_addr_</a>
<a name="ln900">            &lt;&lt; &quot; to step down before removal.&quot;;</a>
<a name="ln901">    string old_leader_uuid = leader_uuid;</a>
<a name="ln902">    RETURN_NOT_OK(MasterLeaderStepDown(leader_uuid));</a>
<a name="ln903">    sleep(5);  // TODO - wait for exactly the time needed for new leader to get elected.</a>
<a name="ln904">    // Reget the leader master's socket info to set up the proxy</a>
<a name="ln905">    leader_addr_ = VERIFY_RESULT(yb_client_-&gt;RefreshMasterLeaderAddress());</a>
<a name="ln906">    master_proxy_.reset(new MasterServiceProxy(proxy_cache_.get(), leader_addr_));</a>
<a name="ln907">    leader_uuid = VERIFY_RESULT(GetMasterLeaderUuid());</a>
<a name="ln908">    if (leader_uuid == old_leader_uuid) {</a>
<a name="ln909">      return STATUS(ConfigurationError,</a>
<a name="ln910">        Substitute(&quot;Old master leader uuid $0 same as new one even after stepdown!&quot;, leader_uuid));</a>
<a name="ln911">    }</a>
<a name="ln912">    // Go ahead below and send the actual config change message to the new master</a>
<a name="ln913">  }</a>
<a name="ln914"> </a>
<a name="ln915">  std::unique_ptr&lt;consensus::ConsensusServiceProxy&gt; leader_proxy(</a>
<a name="ln916">    new consensus::ConsensusServiceProxy(proxy_cache_.get(), leader_addr_));</a>
<a name="ln917">  consensus::ChangeConfigRequestPB req;</a>
<a name="ln918"> </a>
<a name="ln919">  RaftPeerPB peer_pb;</a>
<a name="ln920">  peer_pb.set_permanent_uuid(peer_uuid);</a>
<a name="ln921">  // Ignored by ChangeConfig if request != ADD_SERVER.</a>
<a name="ln922">  peer_pb.set_member_type(RaftPeerPB::PRE_VOTER);</a>
<a name="ln923">  HostPortPB *peer_host_port = peer_pb.mutable_last_known_private_addr()-&gt;Add();</a>
<a name="ln924">  peer_host_port-&gt;set_port(peer_port);</a>
<a name="ln925">  peer_host_port-&gt;set_host(peer_host);</a>
<a name="ln926">  req.set_dest_uuid(leader_uuid);</a>
<a name="ln927">  req.set_tablet_id(yb::master::kSysCatalogTabletId);</a>
<a name="ln928">  req.set_type(cc_type);</a>
<a name="ln929">  req.set_use_host(use_hostport);</a>
<a name="ln930">  *req.mutable_server() = peer_pb;</a>
<a name="ln931"> </a>
<a name="ln932">  VLOG(1) &lt;&lt; &quot;ChangeMasterConfig: ChangeConfig for tablet id &quot; &lt;&lt; yb::master::kSysCatalogTabletId</a>
<a name="ln933">          &lt;&lt; &quot; to host &quot; &lt;&lt; leader_addr_;</a>
<a name="ln934">  RETURN_NOT_OK(InvokeRpc(</a>
<a name="ln935">    &amp;consensus::ConsensusServiceProxy::ChangeConfig,</a>
<a name="ln936">    leader_proxy.get(),</a>
<a name="ln937">    req));</a>
<a name="ln938"> </a>
<a name="ln939">  VLOG(1) &lt;&lt; &quot;ChangeMasterConfig: update yb client to reflect config change.&quot;;</a>
<a name="ln940">  if (cc_type == consensus::ADD_SERVER) {</a>
<a name="ln941">    RETURN_NOT_OK(yb_client_-&gt;AddMasterToClient(changed_leader_addr));</a>
<a name="ln942">  } else {</a>
<a name="ln943">    RETURN_NOT_OK(yb_client_-&gt;RemoveMasterFromClient(changed_leader_addr));</a>
<a name="ln944">  }</a>
<a name="ln945"> </a>
<a name="ln946">  return Status::OK();</a>
<a name="ln947">}</a>
<a name="ln948"> </a>
<a name="ln949">Status ClusterAdminClient::GetTabletLocations(const TabletId&amp; tablet_id,</a>
<a name="ln950">                                              TabletLocationsPB* locations) {</a>
<a name="ln951">  master::GetTabletLocationsRequestPB req;</a>
<a name="ln952">  req.add_tablet_ids(tablet_id);</a>
<a name="ln953">  const auto resp = VERIFY_RESULT(InvokeRpc(&amp;MasterServiceProxy::GetTabletLocations,</a>
<a name="ln954">      master_proxy_.get(), req));</a>
<a name="ln955"> </a>
<a name="ln956">  if (resp.errors_size() &gt; 0) {</a>
<a name="ln957">    // This tool only needs to support one-by-one requests for tablet</a>
<a name="ln958">    // locations, so we only look at the first error.</a>
<a name="ln959">    return StatusFromPB(resp.errors(0).status());</a>
<a name="ln960">  }</a>
<a name="ln961"> </a>
<a name="ln962">  // Same as above, no batching, and we already got past the error checks.</a>
<a name="ln963">  CHECK_EQ(1, resp.tablet_locations_size()) &lt;&lt; resp.ShortDebugString();</a>
<a name="ln964"> </a>
<a name="ln965">  *locations = resp.tablet_locations(0);</a>
<a name="ln966">  return Status::OK();</a>
<a name="ln967">}</a>
<a name="ln968"> </a>
<a name="ln969">Status ClusterAdminClient::GetTabletPeer(const TabletId&amp; tablet_id,</a>
<a name="ln970">                                         PeerMode mode,</a>
<a name="ln971">                                         TSInfoPB* ts_info) {</a>
<a name="ln972">  TabletLocationsPB locations;</a>
<a name="ln973">  RETURN_NOT_OK(GetTabletLocations(tablet_id, &amp;locations));</a>
<a name="ln974">  CHECK_EQ(tablet_id, locations.tablet_id()) &lt;&lt; locations.ShortDebugString();</a>
<a name="ln975">  bool found = false;</a>
<a name="ln976">  for (const TabletLocationsPB::ReplicaPB&amp; replica : locations.replicas()) {</a>
<a name="ln977">    if (mode == LEADER &amp;&amp; replica.role() == RaftPeerPB::LEADER) {</a>
<a name="ln978">      *ts_info = replica.ts_info();</a>
<a name="ln979">      found = true;</a>
<a name="ln980">      break;</a>
<a name="ln981">    }</a>
<a name="ln982">    if (mode == FOLLOWER &amp;&amp; replica.role() != RaftPeerPB::LEADER) {</a>
<a name="ln983">      *ts_info = replica.ts_info();</a>
<a name="ln984">      found = true;</a>
<a name="ln985">      break;</a>
<a name="ln986">    }</a>
<a name="ln987">  }</a>
<a name="ln988"> </a>
<a name="ln989">  if (!found) {</a>
<a name="ln990">    return STATUS(NotFound,</a>
<a name="ln991">      Substitute(&quot;No peer replica found in $0 mode for tablet $1&quot;, mode, tablet_id));</a>
<a name="ln992">  }</a>
<a name="ln993"> </a>
<a name="ln994">  return Status::OK();</a>
<a name="ln995">}</a>
<a name="ln996"> </a>
<a name="ln997">Status ClusterAdminClient::ListTabletServers(</a>
<a name="ln998">    RepeatedPtrField&lt;ListTabletServersResponsePB::Entry&gt;* servers) {</a>
<a name="ln999">  auto resp = VERIFY_RESULT(InvokeRpc(&amp;MasterServiceProxy::ListTabletServers, master_proxy_.get(),</a>
<a name="ln1000">      ListTabletServersRequestPB()));</a>
<a name="ln1001">  *servers = std::move(*resp.mutable_servers());</a>
<a name="ln1002">  return Status::OK();</a>
<a name="ln1003">}</a>
<a name="ln1004"> </a>
<a name="ln1005">Result&lt;HostPort&gt; ClusterAdminClient::GetFirstRpcAddressForTS(const PeerId&amp; uuid) {</a>
<a name="ln1006">  RepeatedPtrField&lt;ListTabletServersResponsePB::Entry&gt; servers;</a>
<a name="ln1007">  RETURN_NOT_OK(ListTabletServers(&amp;servers));</a>
<a name="ln1008">  for (const ListTabletServersResponsePB::Entry&amp; server : servers) {</a>
<a name="ln1009">    if (server.instance_id().permanent_uuid() == uuid) {</a>
<a name="ln1010">      if (!server.has_registration() ||</a>
<a name="ln1011">          server.registration().common().private_rpc_addresses().empty()) {</a>
<a name="ln1012">        break;</a>
<a name="ln1013">      }</a>
<a name="ln1014">      return HostPortFromPB(server.registration().common().private_rpc_addresses(0));</a>
<a name="ln1015">    }</a>
<a name="ln1016">  }</a>
<a name="ln1017"> </a>
<a name="ln1018">  return STATUS_FORMAT(</a>
<a name="ln1019">      NotFound, &quot;Server with UUID $0 has no RPC address registered with the Master&quot;, uuid);</a>
<a name="ln1020">}</a>
<a name="ln1021"> </a>
<a name="ln1022">Status ClusterAdminClient::ListAllTabletServers(bool exclude_dead) {</a>
<a name="ln1023">  RepeatedPtrField&lt;ListTabletServersResponsePB::Entry&gt; servers;</a>
<a name="ln1024">  RETURN_NOT_OK(ListTabletServers(&amp;servers));</a>
<a name="ln1025">  char kSpaceSep = ' ';</a>
<a name="ln1026"> </a>
<a name="ln1027">  cout &lt;&lt; RightPadToUuidWidth(&quot;Tablet Server UUID&quot;) &lt;&lt; kSpaceSep</a>
<a name="ln1028">        &lt;&lt; kRpcHostPortHeading &lt;&lt; kSpaceSep</a>
<a name="ln1029">        &lt;&lt; RightPadToWidth(&quot;Heartbeat delay&quot;, kLongColWidth) &lt;&lt; kSpaceSep</a>
<a name="ln1030">        &lt;&lt; RightPadToWidth(&quot;Status&quot;, kSmallColWidth) &lt;&lt; kSpaceSep</a>
<a name="ln1031">        &lt;&lt; RightPadToWidth(&quot;Reads/s&quot;, kSmallColWidth) &lt;&lt; kSpaceSep</a>
<a name="ln1032">        &lt;&lt; RightPadToWidth(&quot;Writes/s&quot;, kSmallColWidth) &lt;&lt; kSpaceSep</a>
<a name="ln1033">        &lt;&lt; RightPadToWidth(&quot;Uptime&quot;, kSmallColWidth) &lt;&lt; kSpaceSep</a>
<a name="ln1034">        &lt;&lt; RightPadToWidth(&quot;SST total size&quot;, kLongColWidth) &lt;&lt; kSpaceSep</a>
<a name="ln1035">        &lt;&lt; RightPadToWidth(&quot;SST uncomp size&quot;, kLongColWidth) &lt;&lt; kSpaceSep</a>
<a name="ln1036">        &lt;&lt; RightPadToWidth(&quot;SST #files&quot;, kLongColWidth) &lt;&lt; kSpaceSep</a>
<a name="ln1037">        &lt;&lt; RightPadToWidth(&quot;Memory&quot;, kSmallColWidth) &lt;&lt; kSpaceSep</a>
<a name="ln1038">        &lt;&lt; endl;</a>
<a name="ln1039">  for (const ListTabletServersResponsePB::Entry&amp; server : servers) {</a>
<a name="ln1040">    if (exclude_dead &amp;&amp; server.has_alive() &amp;&amp; !server.alive()) {</a>
<a name="ln1041">      continue;</a>
<a name="ln1042">    }</a>
<a name="ln1043">    std::stringstream time_str;</a>
<a name="ln1044">    auto heartbeat_delay_ms = server.has_millis_since_heartbeat() ?</a>
<a name="ln1045">                               server.millis_since_heartbeat() : 0;</a>
<a name="ln1046">    time_str &lt;&lt; std::fixed &lt;&lt; std::setprecision(2) &lt;&lt; (heartbeat_delay_ms/1000.0) &lt;&lt; &quot;s&quot;;</a>
<a name="ln1047">    auto status_str = server.has_alive() ? (server.alive() ? &quot;ALIVE&quot; : &quot;DEAD&quot;) : &quot;UNKNOWN&quot;;</a>
<a name="ln1048">    cout &lt;&lt; server.instance_id().permanent_uuid() &lt;&lt; kSpaceSep</a>
<a name="ln1049">         &lt;&lt; FormatFirstHostPort(server.registration().common().private_rpc_addresses())</a>
<a name="ln1050">         &lt;&lt; kSpaceSep</a>
<a name="ln1051">         &lt;&lt; RightPadToWidth(time_str.str(), kLongColWidth) &lt;&lt; kSpaceSep</a>
<a name="ln1052">         &lt;&lt; RightPadToWidth(status_str, kSmallColWidth) &lt;&lt; kSpaceSep</a>
<a name="ln1053">         &lt;&lt; RightPadToWidth(FormatDouble(server.metrics().read_ops_per_sec()), kSmallColWidth)</a>
<a name="ln1054">         &lt;&lt; kSpaceSep</a>
<a name="ln1055">         &lt;&lt; RightPadToWidth(FormatDouble(server.metrics().write_ops_per_sec()), kSmallColWidth)</a>
<a name="ln1056">         &lt;&lt; kSpaceSep</a>
<a name="ln1057">         &lt;&lt; RightPadToWidth(server.metrics().uptime_seconds(), kSmallColWidth) &lt;&lt; kSpaceSep</a>
<a name="ln1058">         &lt;&lt; RightPadToWidth(HumanizeBytes(server.metrics().total_sst_file_size()), kLongColWidth)</a>
<a name="ln1059">         &lt;&lt; kSpaceSep</a>
<a name="ln1060">         &lt;&lt; RightPadToWidth(HumanizeBytes(server.metrics().uncompressed_sst_file_size()),</a>
<a name="ln1061">                            kLongColWidth)</a>
<a name="ln1062">         &lt;&lt; kSpaceSep</a>
<a name="ln1063">         &lt;&lt; RightPadToWidth(server.metrics().num_sst_files(), kLongColWidth) &lt;&lt; kSpaceSep</a>
<a name="ln1064">         &lt;&lt; RightPadToWidth(HumanizeBytes(server.metrics().total_ram_usage()), kSmallColWidth)</a>
<a name="ln1065">         &lt;&lt; kSpaceSep</a>
<a name="ln1066">         &lt;&lt; endl;</a>
<a name="ln1067">  }</a>
<a name="ln1068"> </a>
<a name="ln1069">  return Status::OK();</a>
<a name="ln1070">}</a>
<a name="ln1071"> </a>
<a name="ln1072">Status ClusterAdminClient::ListAllMasters() {</a>
<a name="ln1073">  const auto lresp = VERIFY_RESULT(InvokeRpc(&amp;MasterServiceProxy::ListMasters,</a>
<a name="ln1074">      master_proxy_.get(), ListMastersRequestPB()));</a>
<a name="ln1075"> </a>
<a name="ln1076">  if (lresp.has_error()) {</a>
<a name="ln1077">    LOG(ERROR) &lt;&lt; &quot;Error: querying leader master for live master info : &quot;</a>
<a name="ln1078">               &lt;&lt; lresp.error().DebugString() &lt;&lt; endl;</a>
<a name="ln1079">    return STATUS(RemoteError, lresp.error().DebugString());</a>
<a name="ln1080">  }</a>
<a name="ln1081"> </a>
<a name="ln1082">  cout &lt;&lt; RightPadToUuidWidth(&quot;Master UUID&quot;) &lt;&lt; kColumnSep</a>
<a name="ln1083">        &lt;&lt; RightPadToWidth(kRpcHostPortHeading, kHostPortColWidth) &lt;&lt; kColumnSep</a>
<a name="ln1084">        &lt;&lt; RightPadToWidth(&quot;State&quot;, kSmallColWidth) &lt;&lt; kColumnSep</a>
<a name="ln1085">        &lt;&lt; &quot;Role&quot; &lt;&lt; endl;</a>
<a name="ln1086"> </a>
<a name="ln1087">  for (const auto&amp; master : lresp.masters()) {</a>
<a name="ln1088">      const auto master_reg = master.has_registration() ? &amp;master.registration() : nullptr;</a>
<a name="ln1089">      cout &lt;&lt; (master.has_instance_id() ? master.instance_id().permanent_uuid()</a>
<a name="ln1090">                          : RightPadToUuidWidth(&quot;UNKNOWN_UUID&quot;)) &lt;&lt; kColumnSep;</a>
<a name="ln1091">      cout &lt;&lt; RightPadToWidth(</a>
<a name="ln1092">                master_reg ? FormatFirstHostPort(master_reg-&gt;private_rpc_addresses())</a>
<a name="ln1093">                            : &quot;UNKNOWN&quot;, kHostPortColWidth)</a>
<a name="ln1094">            &lt;&lt; kColumnSep;</a>
<a name="ln1095">      cout &lt;&lt; RightPadToWidth((master.has_error() ?</a>
<a name="ln1096">                                PBEnumToString(master.error().code()) : &quot;ALIVE&quot;),</a>
<a name="ln1097">                              kSmallColWidth)</a>
<a name="ln1098">            &lt;&lt; kColumnSep;</a>
<a name="ln1099">      cout &lt;&lt; (master.has_role() ? PBEnumToString(master.role()) : &quot;UNKNOWN&quot;) &lt;&lt; endl;</a>
<a name="ln1100">  }</a>
<a name="ln1101"> </a>
<a name="ln1102">  return Status::OK();</a>
<a name="ln1103">}</a>
<a name="ln1104"> </a>
<a name="ln1105">Status ClusterAdminClient::ListTabletServersLogLocations() {</a>
<a name="ln1106">  RepeatedPtrField&lt;ListTabletServersResponsePB::Entry&gt; servers;</a>
<a name="ln1107">  RETURN_NOT_OK(ListTabletServers(&amp;servers));</a>
<a name="ln1108"> </a>
<a name="ln1109">  if (!servers.empty()) {</a>
<a name="ln1110">    cout &lt;&lt; RightPadToUuidWidth(&quot;TS UUID&quot;) &lt;&lt; kColumnSep</a>
<a name="ln1111">         &lt;&lt; kRpcHostPortHeading &lt;&lt; kColumnSep</a>
<a name="ln1112">         &lt;&lt; &quot;LogLocation&quot;</a>
<a name="ln1113">         &lt;&lt; endl;</a>
<a name="ln1114">  }</a>
<a name="ln1115"> </a>
<a name="ln1116">  for (const ListTabletServersResponsePB::Entry&amp; server : servers) {</a>
<a name="ln1117">    auto ts_uuid = server.instance_id().permanent_uuid();</a>
<a name="ln1118"> </a>
<a name="ln1119">    HostPort ts_addr = VERIFY_RESULT(GetFirstRpcAddressForTS(ts_uuid));</a>
<a name="ln1120"> </a>
<a name="ln1121">    TabletServerServiceProxy ts_proxy(proxy_cache_.get(), ts_addr);</a>
<a name="ln1122"> </a>
<a name="ln1123">    const auto resp = VERIFY_RESULT(InvokeRpc(&amp;TabletServerServiceProxy::GetLogLocation,</a>
<a name="ln1124">        &amp;ts_proxy, tserver::GetLogLocationRequestPB()));</a>
<a name="ln1125">    cout &lt;&lt; ts_uuid &lt;&lt; kColumnSep</a>
<a name="ln1126">         &lt;&lt; ts_addr &lt;&lt; kColumnSep</a>
<a name="ln1127">         &lt;&lt; resp.log_location() &lt;&lt; endl;</a>
<a name="ln1128">  }</a>
<a name="ln1129"> </a>
<a name="ln1130">  return Status::OK();</a>
<a name="ln1131">}</a>
<a name="ln1132"> </a>
<a name="ln1133">Status ClusterAdminClient::ListTables(bool include_db_type,</a>
<a name="ln1134">                                      bool include_table_id,</a>
<a name="ln1135">                                      bool include_table_type) {</a>
<a name="ln1136">  const auto tables = VERIFY_RESULT(yb_client_-&gt;ListTables());</a>
<a name="ln1137">  const auto&amp; namespace_metadata = VERIFY_RESULT_REF(GetNamespaceMap());</a>
<a name="ln1138">  vector&lt;string&gt; names;</a>
<a name="ln1139">  for (const auto&amp; table : tables) {</a>
<a name="ln1140">    std::stringstream str;</a>
<a name="ln1141">    if (include_db_type) {</a>
<a name="ln1142">      const auto db_type_iter = namespace_metadata.find(table.namespace_id());</a>
<a name="ln1143">      if (db_type_iter != namespace_metadata.end()) {</a>
<a name="ln1144">        str &lt;&lt; DatabasePrefix(db_type_iter-&gt;second.database_type()) &lt;&lt; '.';</a>
<a name="ln1145">      } else {</a>
<a name="ln1146">        LOG(WARNING) &lt;&lt; &quot;Table in unknown namespace found &quot; &lt;&lt; table.ToString();</a>
<a name="ln1147">        continue;</a>
<a name="ln1148">      }</a>
<a name="ln1149">    }</a>
<a name="ln1150">    str &lt;&lt; table.ToString();</a>
<a name="ln1151">    if (include_table_id) {</a>
<a name="ln1152">      str &lt;&lt; ' ' &lt;&lt; table.table_id();</a>
<a name="ln1153">    }</a>
<a name="ln1154">    if (include_table_type) {</a>
<a name="ln1155">      boost::optional&lt;master::RelationType&gt; relation_type = table.relation_type();</a>
<a name="ln1156">      switch (relation_type.get()) {</a>
<a name="ln1157">        case master::SYSTEM_TABLE_RELATION:</a>
<a name="ln1158">          str &lt;&lt; &quot; catalog&quot;;</a>
<a name="ln1159">          break;</a>
<a name="ln1160">        case master::USER_TABLE_RELATION:</a>
<a name="ln1161">          str &lt;&lt; &quot; table&quot;;</a>
<a name="ln1162">          break;</a>
<a name="ln1163">        case master::INDEX_TABLE_RELATION:</a>
<a name="ln1164">          str &lt;&lt; &quot; index&quot;;</a>
<a name="ln1165">          break;</a>
<a name="ln1166">        default:</a>
<a name="ln1167">          str &lt;&lt; &quot; other&quot;;</a>
<a name="ln1168">      }</a>
<a name="ln1169">    }</a>
<a name="ln1170">    names.push_back(str.str());</a>
<a name="ln1171">  }</a>
<a name="ln1172">  sort(names.begin(), names.end());</a>
<a name="ln1173">  copy(names.begin(), names.end(), std::ostream_iterator&lt;string&gt;(cout, &quot;\n&quot;));</a>
<a name="ln1174">  return Status::OK();</a>
<a name="ln1175">}</a>
<a name="ln1176"> </a>
<a name="ln1177">Status ClusterAdminClient::ListTablets(const YBTableName&amp; table_name, int max_tablets) {</a>
<a name="ln1178">  vector&lt;string&gt; tablet_uuids, ranges;</a>
<a name="ln1179">  std::vector&lt;master::TabletLocationsPB&gt; locations;</a>
<a name="ln1180">  RETURN_NOT_OK(yb_client_-&gt;GetTablets(</a>
<a name="ln1181">      table_name, max_tablets, &amp;tablet_uuids, &amp;ranges, &amp;locations));</a>
<a name="ln1182">  cout &lt;&lt; RightPadToUuidWidth(&quot;Tablet-UUID&quot;) &lt;&lt; kColumnSep</a>
<a name="ln1183">       &lt;&lt; RightPadToWidth(&quot;Range&quot;, kPartitionRangeColWidth) &lt;&lt; kColumnSep</a>
<a name="ln1184">       &lt;&lt; RightPadToWidth(&quot;Leader-IP&quot;, kLongColWidth) &lt;&lt; kColumnSep &lt;&lt; &quot;Leader-UUID&quot; &lt;&lt; endl;</a>
<a name="ln1185">  for (int i = 0; i &lt; tablet_uuids.size(); i++) {</a>
<a name="ln1186">    string tablet_uuid = tablet_uuids[i];</a>
<a name="ln1187">    string leader_host_port;</a>
<a name="ln1188">    string leader_uuid;</a>
<a name="ln1189">    const auto&amp; locations_of_this_tablet = locations[i];</a>
<a name="ln1190">    for (const auto&amp; replica : locations_of_this_tablet.replicas()) {</a>
<a name="ln1191">      if (replica.role() == RaftPeerPB::Role::RaftPeerPB_Role_LEADER) {</a>
<a name="ln1192">        if (leader_host_port.empty()) {</a>
<a name="ln1193">          leader_host_port = HostPortPBToString(replica.ts_info().private_rpc_addresses(0));</a>
<a name="ln1194">          leader_uuid = replica.ts_info().permanent_uuid();</a>
<a name="ln1195">        } else {</a>
<a name="ln1196">          LOG(ERROR) &lt;&lt; &quot;Multiple leader replicas found for tablet &quot; &lt;&lt; tablet_uuid</a>
<a name="ln1197">                     &lt;&lt; &quot;: &quot; &lt;&lt; locations_of_this_tablet.ShortDebugString();</a>
<a name="ln1198">        }</a>
<a name="ln1199">      }</a>
<a name="ln1200">    }</a>
<a name="ln1201">    cout &lt;&lt; tablet_uuid &lt;&lt; kColumnSep &lt;&lt; RightPadToWidth(ranges[i], kPartitionRangeColWidth)</a>
<a name="ln1202">         &lt;&lt; kColumnSep &lt;&lt; RightPadToWidth(leader_host_port, kLongColWidth) &lt;&lt; kColumnSep</a>
<a name="ln1203">         &lt;&lt; leader_uuid &lt;&lt; endl;</a>
<a name="ln1204">  }</a>
<a name="ln1205">  return Status::OK();</a>
<a name="ln1206">}</a>
<a name="ln1207"> </a>
<a name="ln1208">Status ClusterAdminClient::ListPerTabletTabletServers(const TabletId&amp; tablet_id) {</a>
<a name="ln1209">  master::GetTabletLocationsRequestPB req;</a>
<a name="ln1210">  req.add_tablet_ids(tablet_id);</a>
<a name="ln1211">  const auto resp = VERIFY_RESULT(InvokeRpc(&amp;MasterServiceProxy::GetTabletLocations,</a>
<a name="ln1212">      master_proxy_.get(), req));</a>
<a name="ln1213"> </a>
<a name="ln1214">  if (resp.tablet_locations_size() != 1) {</a>
<a name="ln1215">    if (resp.tablet_locations_size() &gt; 0) {</a>
<a name="ln1216">      std::cerr &lt;&lt; &quot;List of all incorrect locations - &quot; &lt;&lt; resp.tablet_locations_size()</a>
<a name="ln1217">                &lt;&lt; &quot; : &quot; &lt;&lt; endl;</a>
<a name="ln1218">      const auto limit = std::min(resp.tablet_locations_size(), MAX_NUM_ELEMENTS_TO_SHOW_ON_ERROR);</a>
<a name="ln1219">      for (int i = 0; i &lt; limit; ++i) {</a>
<a name="ln1220">        std::cerr &lt;&lt; i &lt;&lt; &quot; : &quot; &lt;&lt; resp.tablet_locations(i).DebugString();</a>
<a name="ln1221">      }</a>
<a name="ln1222">      std::cerr &lt;&lt; endl;</a>
<a name="ln1223">    }</a>
<a name="ln1224">    return STATUS_FORMAT(IllegalState,</a>
<a name="ln1225">                         &quot;Incorrect number of locations $0 for tablet $1.&quot;,</a>
<a name="ln1226">                         resp.tablet_locations_size(), tablet_id);</a>
<a name="ln1227">  }</a>
<a name="ln1228"> </a>
<a name="ln1229">  TabletLocationsPB locs = resp.tablet_locations(0);</a>
<a name="ln1230">  if (!locs.replicas().empty()) {</a>
<a name="ln1231">    cout &lt;&lt; RightPadToUuidWidth(&quot;Server UUID&quot;) &lt;&lt; kColumnSep</a>
<a name="ln1232">         &lt;&lt; RightPadToWidth(kRpcHostPortHeading, kHostPortColWidth) &lt;&lt; kColumnSep</a>
<a name="ln1233">         &lt;&lt; &quot;Role&quot; &lt;&lt; endl;</a>
<a name="ln1234">  }</a>
<a name="ln1235">  for (const auto&amp; replica : locs.replicas()) {</a>
<a name="ln1236">    cout &lt;&lt; replica.ts_info().permanent_uuid() &lt;&lt; kColumnSep</a>
<a name="ln1237">         &lt;&lt; RightPadToWidth(HostPortPBToString(replica.ts_info().private_rpc_addresses(0)),</a>
<a name="ln1238">                            kHostPortColWidth) &lt;&lt; kColumnSep</a>
<a name="ln1239">         &lt;&lt; PBEnumToString(replica.role()) &lt;&lt; endl;</a>
<a name="ln1240">  }</a>
<a name="ln1241"> </a>
<a name="ln1242">  return Status::OK();</a>
<a name="ln1243">}</a>
<a name="ln1244"> </a>
<a name="ln1245">Status ClusterAdminClient::DeleteTable(const YBTableName&amp; table_name) {</a>
<a name="ln1246">  RETURN_NOT_OK(yb_client_-&gt;DeleteTable(table_name));</a>
<a name="ln1247">  cout &lt;&lt; &quot;Deleted table &quot; &lt;&lt; table_name.ToString() &lt;&lt; endl;</a>
<a name="ln1248">  return Status::OK();</a>
<a name="ln1249">}</a>
<a name="ln1250"> </a>
<a name="ln1251">Status ClusterAdminClient::DeleteTableById(const TableId&amp; table_id) {</a>
<a name="ln1252">  RETURN_NOT_OK(yb_client_-&gt;DeleteTable(table_id));</a>
<a name="ln1253">  cout &lt;&lt; &quot;Deleted table &quot; &lt;&lt; table_id &lt;&lt; endl;</a>
<a name="ln1254">  return Status::OK();</a>
<a name="ln1255">}</a>
<a name="ln1256"> </a>
<a name="ln1257">Status ClusterAdminClient::DeleteIndex(const YBTableName&amp; table_name) {</a>
<a name="ln1258">  YBTableName indexed_table_name;</a>
<a name="ln1259">  RETURN_NOT_OK(yb_client_-&gt;DeleteIndexTable(table_name, &amp;indexed_table_name));</a>
<a name="ln1260">  cout &lt;&lt; &quot;Deleted index &quot; &lt;&lt; table_name.ToString() &lt;&lt; &quot; from table &quot; &lt;&lt;</a>
<a name="ln1261">      indexed_table_name.ToString() &lt;&lt; endl;</a>
<a name="ln1262">  return Status::OK();</a>
<a name="ln1263">}</a>
<a name="ln1264"> </a>
<a name="ln1265">Status ClusterAdminClient::DeleteIndexById(const TableId&amp; table_id) {</a>
<a name="ln1266">  YBTableName indexed_table_name;</a>
<a name="ln1267">  RETURN_NOT_OK(yb_client_-&gt;DeleteIndexTable(table_id, &amp;indexed_table_name));</a>
<a name="ln1268">  cout &lt;&lt; &quot;Deleted index &quot; &lt;&lt; table_id &lt;&lt; &quot; from table &quot; &lt;&lt;</a>
<a name="ln1269">      indexed_table_name.ToString() &lt;&lt; endl;</a>
<a name="ln1270">  return Status::OK();</a>
<a name="ln1271">}</a>
<a name="ln1272"> </a>
<a name="ln1273">Status ClusterAdminClient::DeleteNamespace(const TypedNamespaceName&amp; namespace_name) {</a>
<a name="ln1274">  RETURN_NOT_OK(yb_client_-&gt;DeleteNamespace(namespace_name.name, namespace_name.db_type));</a>
<a name="ln1275">  cout &lt;&lt; &quot;Deleted namespace &quot; &lt;&lt; namespace_name.name &lt;&lt; endl;</a>
<a name="ln1276">  return Status::OK();</a>
<a name="ln1277">}</a>
<a name="ln1278"> </a>
<a name="ln1279">Status ClusterAdminClient::DeleteNamespaceById(const NamespaceId&amp; namespace_id) {</a>
<a name="ln1280">  RETURN_NOT_OK(yb_client_-&gt;DeleteNamespace(</a>
<a name="ln1281">      std::string() /* name */, boost::none /* database type */, namespace_id));</a>
<a name="ln1282">  cout &lt;&lt; &quot;Deleted namespace &quot; &lt;&lt; namespace_id &lt;&lt; endl;</a>
<a name="ln1283">  return Status::OK();</a>
<a name="ln1284">}</a>
<a name="ln1285"> </a>
<a name="ln1286">Status ClusterAdminClient::ListTabletsForTabletServer(const PeerId&amp; ts_uuid) {</a>
<a name="ln1287">  auto ts_addr = VERIFY_RESULT(GetFirstRpcAddressForTS(ts_uuid));</a>
<a name="ln1288"> </a>
<a name="ln1289">  TabletServerServiceProxy ts_proxy(proxy_cache_.get(), ts_addr);</a>
<a name="ln1290"> </a>
<a name="ln1291">  const auto resp = VERIFY_RESULT(InvokeRpc(&amp;TabletServerServiceProxy::ListTabletsForTabletServer,</a>
<a name="ln1292">      &amp;ts_proxy, tserver::ListTabletsForTabletServerRequestPB()));</a>
<a name="ln1293"> </a>
<a name="ln1294">  cout &lt;&lt; RightPadToWidth(&quot;Table name&quot;, kTableNameColWidth) &lt;&lt; kColumnSep</a>
<a name="ln1295">       &lt;&lt; RightPadToUuidWidth(&quot;Tablet ID&quot;) &lt;&lt; kColumnSep</a>
<a name="ln1296">       &lt;&lt; &quot;Is Leader&quot; &lt;&lt; kColumnSep</a>
<a name="ln1297">       &lt;&lt; &quot;State&quot; &lt;&lt; kColumnSep</a>
<a name="ln1298">       &lt;&lt; &quot;Num SST Files&quot; &lt;&lt; kColumnSep</a>
<a name="ln1299">       &lt;&lt; &quot;Num Log Segments&quot; &lt;&lt; kColumnSep</a>
<a name="ln1300">       &lt;&lt; &quot;Num Memtables (Intents/Regular)&quot; &lt;&lt; endl;</a>
<a name="ln1301">  for (const auto&amp; entry : resp.entries()) {</a>
<a name="ln1302">    cout &lt;&lt; RightPadToWidth(entry.table_name(), kTableNameColWidth) &lt;&lt; kColumnSep</a>
<a name="ln1303">         &lt;&lt; RightPadToUuidWidth(entry.tablet_id()) &lt;&lt; kColumnSep</a>
<a name="ln1304">         &lt;&lt; entry.is_leader() &lt;&lt; kColumnSep</a>
<a name="ln1305">         &lt;&lt; PBEnumToString(entry.state()) &lt;&lt; kColumnSep</a>
<a name="ln1306">         &lt;&lt; entry.num_sst_files() &lt;&lt; kColumnSep</a>
<a name="ln1307">         &lt;&lt; entry.num_log_segments() &lt;&lt; kColumnSep</a>
<a name="ln1308">         &lt;&lt; entry.num_memtables_intents() &lt;&lt; &quot;/&quot; &lt;&lt; entry.num_memtables_regular() &lt;&lt; endl;</a>
<a name="ln1309">  }</a>
<a name="ln1310">  return Status::OK();</a>
<a name="ln1311">}</a>
<a name="ln1312"> </a>
<a name="ln1313">Status ClusterAdminClient::SetLoadBalancerEnabled(bool is_enabled) {</a>
<a name="ln1314">  const auto list_resp = VERIFY_RESULT(InvokeRpc(&amp;MasterServiceProxy::ListMasters,</a>
<a name="ln1315">      master_proxy_.get(), ListMastersRequestPB()));</a>
<a name="ln1316"> </a>
<a name="ln1317">  master::ChangeLoadBalancerStateRequestPB req;</a>
<a name="ln1318">  req.set_is_enabled(is_enabled);</a>
<a name="ln1319">  for (const auto&amp; master : list_resp.masters()) {</a>
<a name="ln1320"> </a>
<a name="ln1321">    if (master.role() == RaftPeerPB::LEADER) {</a>
<a name="ln1322">      RETURN_NOT_OK(InvokeRpc(&amp;MasterServiceProxy::ChangeLoadBalancerState,</a>
<a name="ln1323">          master_proxy_.get(), req));</a>
<a name="ln1324">    } else {</a>
<a name="ln1325">      HostPortPB hp_pb = master.registration().private_rpc_addresses(0);</a>
<a name="ln1326"> </a>
<a name="ln1327">      MasterServiceProxy proxy(proxy_cache_.get(), HostPortFromPB(hp_pb));</a>
<a name="ln1328">      RETURN_NOT_OK(InvokeRpc(&amp;MasterServiceProxy::ChangeLoadBalancerState, &amp;proxy, req));</a>
<a name="ln1329">    }</a>
<a name="ln1330">  }</a>
<a name="ln1331"> </a>
<a name="ln1332">  return Status::OK();</a>
<a name="ln1333">}</a>
<a name="ln1334"> </a>
<a name="ln1335">Status ClusterAdminClient::GetLoadBalancerState() {</a>
<a name="ln1336">  const auto list_resp = VERIFY_RESULT(InvokeRpc(&amp;MasterServiceProxy::ListMasters,</a>
<a name="ln1337">      master_proxy_.get(), ListMastersRequestPB()));</a>
<a name="ln1338"> </a>
<a name="ln1339">  if (list_resp.has_error()) {</a>
<a name="ln1340">    LOG(ERROR) &lt;&lt; &quot;Error: querying leader master for live master info : &quot;</a>
<a name="ln1341">               &lt;&lt; list_resp.error().DebugString() &lt;&lt; endl;</a>
<a name="ln1342">    return STATUS(RemoteError, list_resp.error().DebugString());</a>
<a name="ln1343">  }</a>
<a name="ln1344"> </a>
<a name="ln1345">  cout &lt;&lt; RightPadToUuidWidth(&quot;Master UUID&quot;) &lt;&lt; kColumnSep</a>
<a name="ln1346">       &lt;&lt; RightPadToWidth(kRpcHostPortHeading, kHostPortColWidth) &lt;&lt; kColumnSep</a>
<a name="ln1347">       &lt;&lt; RightPadToWidth(&quot;State&quot;, kSmallColWidth) &lt;&lt; kColumnSep</a>
<a name="ln1348">       &lt;&lt; RightPadToWidth(&quot;Role&quot;, kSmallColWidth) &lt;&lt; kColumnSep</a>
<a name="ln1349">       &lt;&lt; &quot;Load Balancer State&quot; &lt;&lt; endl;</a>
<a name="ln1350"> </a>
<a name="ln1351"> </a>
<a name="ln1352">  master::GetLoadBalancerStateRequestPB req;</a>
<a name="ln1353">  master::GetLoadBalancerStateResponsePB resp;</a>
<a name="ln1354">  string error;</a>
<a name="ln1355">  MasterServiceProxy* proxy;</a>
<a name="ln1356">  for (const auto&amp; master : list_resp.masters()) {</a>
<a name="ln1357">    error.clear();</a>
<a name="ln1358">    std::unique_ptr&lt;MasterServiceProxy&gt; follower_proxy;</a>
<a name="ln1359">    if (master.role() == RaftPeerPB::LEADER) {</a>
<a name="ln1360">      proxy = master_proxy_.get();</a>
<a name="ln1361">    } else {</a>
<a name="ln1362">      HostPortPB hp_pb = master.registration().private_rpc_addresses(0);</a>
<a name="ln1363">      follower_proxy = std::make_unique&lt;MasterServiceProxy&gt;(</a>
<a name="ln1364">          proxy_cache_.get(), HostPortFromPB(hp_pb));</a>
<a name="ln1365">      proxy = follower_proxy.get();</a>
<a name="ln1366">    }</a>
<a name="ln1367">    auto result = InvokeRpc(&amp;MasterServiceProxy::GetLoadBalancerState, proxy, req);</a>
<a name="ln1368">    if (!result) {</a>
<a name="ln1369">      error = result.ToString();</a>
<a name="ln1370">    } else {</a>
<a name="ln1371">      resp = *result;</a>
<a name="ln1372">      if (!resp.has_error()) {</a>
<a name="ln1373">        error = resp.error().status().message();</a>
<a name="ln1374">      }</a>
<a name="ln1375">    }</a>
<a name="ln1376">    const auto master_reg = master.has_registration() ? &amp;master.registration() : nullptr;</a>
<a name="ln1377">    cout &lt;&lt; (master.has_instance_id() ? master.instance_id().permanent_uuid()</a>
<a name="ln1378">                                      : RightPadToUuidWidth(&quot;UNKNOWN_UUID&quot;)) &lt;&lt; kColumnSep;</a>
<a name="ln1379">    cout &lt;&lt; RightPadToWidth(</a>
<a name="ln1380">        master_reg ? FormatFirstHostPort(master_reg-&gt;private_rpc_addresses())</a>
<a name="ln1381">                   : &quot;UNKNOWN&quot;, kHostPortColWidth)</a>
<a name="ln1382">         &lt;&lt; kColumnSep;</a>
<a name="ln1383">    cout &lt;&lt; RightPadToWidth((master.has_error() ?</a>
<a name="ln1384">                             PBEnumToString(master.error().code()) : &quot;ALIVE&quot;), kSmallColWidth)</a>
<a name="ln1385">         &lt;&lt; kColumnSep;</a>
<a name="ln1386">    cout &lt;&lt; RightPadToWidth((master.has_role() ?</a>
<a name="ln1387">                             PBEnumToString(master.role()) : &quot;UNKNOWN&quot;), kSmallColWidth)</a>
<a name="ln1388">         &lt;&lt; kColumnSep;</a>
<a name="ln1389">    cout &lt;&lt; (!error.empty() ? &quot;Error: &quot; + error : (resp.is_enabled() ? &quot;ENABLED&quot; : &quot;DISABLED&quot;))</a>
<a name="ln1390">         &lt;&lt; std::endl;</a>
<a name="ln1391">  }</a>
<a name="ln1392"> </a>
<a name="ln1393">  return Status::OK();</a>
<a name="ln1394">}</a>
<a name="ln1395"> </a>
<a name="ln1396">Status ClusterAdminClient::FlushTables(const std::vector&lt;YBTableName&gt;&amp; table_names,</a>
<a name="ln1397">                                       bool add_indexes,</a>
<a name="ln1398">                                       int timeout_secs,</a>
<a name="ln1399">                                       bool is_compaction) {</a>
<a name="ln1400">  RETURN_NOT_OK(yb_client_-&gt;FlushTables(table_names, add_indexes, timeout_secs, is_compaction));</a>
<a name="ln1401">  cout &lt;&lt; (is_compaction ? &quot;Compacted &quot; : &quot;Flushed &quot;)</a>
<a name="ln1402">       &lt;&lt; ToString(table_names) &lt;&lt; &quot; tables&quot;</a>
<a name="ln1403">       &lt;&lt; (add_indexes ? &quot; and associated indexes.&quot; : &quot;.&quot;) &lt;&lt; endl;</a>
<a name="ln1404">  return Status::OK();</a>
<a name="ln1405">}</a>
<a name="ln1406"> </a>
<a name="ln1407">Status ClusterAdminClient::FlushTablesById(</a>
<a name="ln1408">    const std::vector&lt;TableId&gt;&amp; table_ids,</a>
<a name="ln1409">    bool add_indexes,</a>
<a name="ln1410">    int timeout_secs,</a>
<a name="ln1411">    bool is_compaction) {</a>
<a name="ln1412">  RETURN_NOT_OK(yb_client_-&gt;FlushTables(table_ids, add_indexes, timeout_secs, is_compaction));</a>
<a name="ln1413">  cout &lt;&lt; (is_compaction ? &quot;Compacted &quot; : &quot;Flushed &quot;)</a>
<a name="ln1414">       &lt;&lt; ToString(table_ids) &lt;&lt; &quot; tables&quot;</a>
<a name="ln1415">       &lt;&lt; (add_indexes ? &quot; and associated indexes.&quot; : &quot;.&quot;) &lt;&lt; endl;</a>
<a name="ln1416">  return Status::OK();</a>
<a name="ln1417">}</a>
<a name="ln1418"> </a>
<a name="ln1419">Status ClusterAdminClient::WaitUntilMasterLeaderReady() {</a>
<a name="ln1420">  for(int iter = 0; iter &lt; kNumberOfTryouts; ++iter) {</a>
<a name="ln1421">    const auto res_leader_ready = VERIFY_RESULT(InvokeRpcNoResponseCheck(</a>
<a name="ln1422">        &amp;MasterServiceProxy::IsMasterLeaderServiceReady,</a>
<a name="ln1423">        master_proxy_.get(),  master::IsMasterLeaderReadyRequestPB(),</a>
<a name="ln1424">        &quot;MasterServiceImpl::IsMasterLeaderServiceReady call failed.&quot;));</a>
<a name="ln1425">    if (!res_leader_ready.has_error()) {</a>
<a name="ln1426">      return Status::OK();</a>
<a name="ln1427">    }</a>
<a name="ln1428">    sleep(kSleepTimeSec);</a>
<a name="ln1429">  }</a>
<a name="ln1430">  return STATUS(TimedOut, &quot;ClusterAdminClient::WaitUntilMasterLeaderReady timed out.&quot;);</a>
<a name="ln1431">}</a>
<a name="ln1432"> </a>
<a name="ln1433">Status ClusterAdminClient::AddReadReplicaPlacementInfo(</a>
<a name="ln1434">    const string&amp; placement_info, int replication_factor, const std::string&amp; optional_uuid) {</a>
<a name="ln1435">  RETURN_NOT_OK_PREPEND(WaitUntilMasterLeaderReady(), &quot;Wait for master leader failed!&quot;);</a>
<a name="ln1436"> </a>
<a name="ln1437">  // Get the cluster config from the master leader.</a>
<a name="ln1438">  auto resp_cluster_config = VERIFY_RESULT(GetMasterClusterConfig());</a>
<a name="ln1439"> </a>
<a name="ln1440">  auto* cluster_config = resp_cluster_config.mutable_cluster_config();</a>
<a name="ln1441">  if (cluster_config-&gt;replication_info().read_replicas_size() &gt; 0) {</a>
<a name="ln1442">    return STATUS(InvalidCommand, &quot;Already have a read replica placement, cannot add another.&quot;);</a>
<a name="ln1443">  }</a>
<a name="ln1444">  auto* read_replica_config = cluster_config-&gt;mutable_replication_info()-&gt;add_read_replicas();</a>
<a name="ln1445"> </a>
<a name="ln1446">  // If optional_uuid is set, make that the placement info, otherwise generate a random one.</a>
<a name="ln1447">  string uuid_str = optional_uuid;</a>
<a name="ln1448">  if (optional_uuid.empty()) {</a>
<a name="ln1449">    uuid_str = RandomHumanReadableString(16);</a>
<a name="ln1450">  }</a>
<a name="ln1451">  read_replica_config-&gt;set_num_replicas(replication_factor);</a>
<a name="ln1452">  read_replica_config-&gt;set_placement_uuid(uuid_str);</a>
<a name="ln1453"> </a>
<a name="ln1454">  // Fill in the placement info with new stuff.</a>
<a name="ln1455">  RETURN_NOT_OK(FillPlacementInfo(read_replica_config, placement_info));</a>
<a name="ln1456"> </a>
<a name="ln1457">  master::ChangeMasterClusterConfigRequestPB req_new_cluster_config;</a>
<a name="ln1458"> </a>
<a name="ln1459">  *req_new_cluster_config.mutable_cluster_config() = *cluster_config;</a>
<a name="ln1460"> </a>
<a name="ln1461">  RETURN_NOT_OK(InvokeRpc(&amp;MasterServiceProxy::ChangeMasterClusterConfig,</a>
<a name="ln1462">                          master_proxy_.get(), req_new_cluster_config,</a>
<a name="ln1463">                          &quot;MasterServiceImpl::ChangeMasterClusterConfig call failed.&quot;));</a>
<a name="ln1464"> </a>
<a name="ln1465">  LOG(INFO)&lt;&lt; &quot;Created read replica placement with uuid: &quot; &lt;&lt; uuid_str;</a>
<a name="ln1466">  return Status::OK();</a>
<a name="ln1467">}</a>
<a name="ln1468"> </a>
<a name="ln1469">CHECKED_STATUS ClusterAdminClient::ModifyReadReplicaPlacementInfo(</a>
<a name="ln1470">    const std::string&amp; placement_uuid, const std::string&amp; placement_info, int replication_factor) {</a>
<a name="ln1471">  RETURN_NOT_OK_PREPEND(WaitUntilMasterLeaderReady(), &quot;Wait for master leader failed!&quot;);</a>
<a name="ln1472"> </a>
<a name="ln1473">  // Get the cluster config from the master leader.</a>
<a name="ln1474">  auto master_resp = VERIFY_RESULT(GetMasterClusterConfig());</a>
<a name="ln1475">  auto* cluster_config = master_resp.mutable_cluster_config();</a>
<a name="ln1476"> </a>
<a name="ln1477">  auto* replication_info = cluster_config-&gt;mutable_replication_info();</a>
<a name="ln1478">  if (replication_info-&gt;read_replicas_size() == 0) {</a>
<a name="ln1479">    return STATUS(InvalidCommand, &quot;No read replica placement info to modify.&quot;);</a>
<a name="ln1480">  }</a>
<a name="ln1481"> </a>
<a name="ln1482">  auto* read_replica_config = replication_info-&gt;mutable_read_replicas(0);</a>
<a name="ln1483"> </a>
<a name="ln1484">  std::string config_placement_uuid;</a>
<a name="ln1485">  if (placement_uuid.empty())  {</a>
<a name="ln1486">    // If there is no placement_uuid set, use the existing uuid.</a>
<a name="ln1487">    config_placement_uuid = read_replica_config-&gt;placement_uuid();</a>
<a name="ln1488">  } else {</a>
<a name="ln1489">    // Otherwise, use the passed in value.</a>
<a name="ln1490">    config_placement_uuid = placement_uuid;</a>
<a name="ln1491">  }</a>
<a name="ln1492"> </a>
<a name="ln1493">  read_replica_config-&gt;Clear();</a>
<a name="ln1494"> </a>
<a name="ln1495">  read_replica_config-&gt;set_num_replicas(replication_factor);</a>
<a name="ln1496">  read_replica_config-&gt;set_placement_uuid(config_placement_uuid);</a>
<a name="ln1497">  RETURN_NOT_OK(FillPlacementInfo(read_replica_config, placement_info));</a>
<a name="ln1498"> </a>
<a name="ln1499">  master::ChangeMasterClusterConfigRequestPB req_new_cluster_config;</a>
<a name="ln1500"> </a>
<a name="ln1501">  *req_new_cluster_config.mutable_cluster_config() = *cluster_config;</a>
<a name="ln1502"> </a>
<a name="ln1503">  RETURN_NOT_OK(InvokeRpc(&amp;MasterServiceProxy::ChangeMasterClusterConfig,</a>
<a name="ln1504">                          master_proxy_.get(), req_new_cluster_config,</a>
<a name="ln1505">                          &quot;MasterServiceImpl::ChangeMasterClusterConfig call failed.&quot;));</a>
<a name="ln1506"> </a>
<a name="ln1507">  LOG(INFO)&lt;&lt; &quot;Changed read replica placement.&quot;;</a>
<a name="ln1508">  return Status::OK();</a>
<a name="ln1509">}</a>
<a name="ln1510"> </a>
<a name="ln1511">CHECKED_STATUS ClusterAdminClient::DeleteReadReplicaPlacementInfo() {</a>
<a name="ln1512">  RETURN_NOT_OK_PREPEND(WaitUntilMasterLeaderReady(), &quot;Wait for master leader failed!&quot;);</a>
<a name="ln1513"> </a>
<a name="ln1514">  auto master_resp = VERIFY_RESULT(GetMasterClusterConfig());</a>
<a name="ln1515">  auto* cluster_config = master_resp.mutable_cluster_config();</a>
<a name="ln1516"> </a>
<a name="ln1517">  auto* replication_info = cluster_config-&gt;mutable_replication_info();</a>
<a name="ln1518">  if (replication_info-&gt;read_replicas_size() == 0) {</a>
<a name="ln1519">    return STATUS(InvalidCommand, &quot;No read replica placement info to delete.&quot;);</a>
<a name="ln1520">  }</a>
<a name="ln1521"> </a>
<a name="ln1522">  replication_info-&gt;clear_read_replicas();</a>
<a name="ln1523"> </a>
<a name="ln1524">  master::ChangeMasterClusterConfigRequestPB req_new_cluster_config;</a>
<a name="ln1525"> </a>
<a name="ln1526">  *req_new_cluster_config.mutable_cluster_config() = *cluster_config;</a>
<a name="ln1527"> </a>
<a name="ln1528">  RETURN_NOT_OK(InvokeRpc(&amp;MasterServiceProxy::ChangeMasterClusterConfig,</a>
<a name="ln1529">                          master_proxy_.get(), req_new_cluster_config,</a>
<a name="ln1530">                          &quot;MasterServiceImpl::ChangeMasterClusterConfig call failed.&quot;));</a>
<a name="ln1531"> </a>
<a name="ln1532">  LOG(INFO)&lt;&lt; &quot;Deleted read replica placement.&quot;;</a>
<a name="ln1533">  return Status::OK();</a>
<a name="ln1534">}</a>
<a name="ln1535"> </a>
<a name="ln1536">Status ClusterAdminClient::FillPlacementInfo(</a>
<a name="ln1537">    master::PlacementInfoPB* placement_info_pb, const string&amp; placement_str) {</a>
<a name="ln1538"> </a>
<a name="ln1539">  std::vector&lt;std::string&gt; placement_info_split = strings::Split(</a>
<a name="ln1540">      placement_str, &quot;,&quot;, strings::SkipEmpty());</a>
<a name="ln1541">  if (placement_info_split.size() &lt; 1) {</a>
<a name="ln1542">    return STATUS(InvalidCommand, &quot;Cluster config must be a list of &quot;</a>
<a name="ln1543">                                  &quot;placement infos seperated by commas. &quot;</a>
<a name="ln1544">                                  &quot;Format: 'cloud1.region1.zone1:rf,cloud2.region2.zone2:rf, ...&quot;</a>
<a name="ln1545">        + std::to_string(placement_info_split.size()));</a>
<a name="ln1546">  }</a>
<a name="ln1547"> </a>
<a name="ln1548">  for (int iter = 0; iter &lt; placement_info_split.size(); iter++) {</a>
<a name="ln1549">    std::vector&lt;std::string&gt; placement_block = strings::Split(placement_info_split[iter], &quot;:&quot;,</a>
<a name="ln1550">                                                              strings::SkipEmpty());</a>
<a name="ln1551"> </a>
<a name="ln1552">    if (placement_block.size() != 2) {</a>
<a name="ln1553">      return STATUS(InvalidCommand, &quot;Each placement info must be in format placement:rf&quot;);</a>
<a name="ln1554">    }</a>
<a name="ln1555"> </a>
<a name="ln1556">    int min_num_replicas = boost::lexical_cast&lt;int&gt;(placement_block[1]);</a>
<a name="ln1557"> </a>
<a name="ln1558">    std::vector&lt;std::string&gt; block = strings::Split(placement_block[0], &quot;.&quot;,</a>
<a name="ln1559">                                                    strings::SkipEmpty());</a>
<a name="ln1560">    if (block.size() != 3) {</a>
<a name="ln1561">      return STATUS(InvalidCommand,</a>
<a name="ln1562">          &quot;Each placement info must have exactly 3 values seperated&quot;</a>
<a name="ln1563">          &quot;by dots that denote cloud, region and zone. Block: &quot; + placement_info_split[iter]</a>
<a name="ln1564">          + &quot; is invalid&quot;);</a>
<a name="ln1565">    }</a>
<a name="ln1566">    auto pb = placement_info_pb-&gt;add_placement_blocks();</a>
<a name="ln1567">    pb-&gt;mutable_cloud_info()-&gt;set_placement_cloud(block[0]);</a>
<a name="ln1568">    pb-&gt;mutable_cloud_info()-&gt;set_placement_region(block[1]);</a>
<a name="ln1569">    pb-&gt;mutable_cloud_info()-&gt;set_placement_zone(block[2]);</a>
<a name="ln1570"> </a>
<a name="ln1571">    pb-&gt;set_min_num_replicas(min_num_replicas);</a>
<a name="ln1572">  }</a>
<a name="ln1573"> </a>
<a name="ln1574">  return Status::OK();</a>
<a name="ln1575">}</a>
<a name="ln1576"> </a>
<a name="ln1577">Status ClusterAdminClient::ModifyPlacementInfo(</a>
<a name="ln1578">    std::string placement_info, int replication_factor, const std::string&amp; optional_uuid) {</a>
<a name="ln1579"> </a>
<a name="ln1580">  // Wait to make sure that master leader is ready.</a>
<a name="ln1581">  RETURN_NOT_OK_PREPEND(WaitUntilMasterLeaderReady(), &quot;Wait for master leader failed!&quot;);</a>
<a name="ln1582"> </a>
<a name="ln1583">  // Get the cluster config from the master leader.</a>
<a name="ln1584">  auto resp_cluster_config = VERIFY_RESULT(GetMasterClusterConfig());</a>
<a name="ln1585"> </a>
<a name="ln1586">  // Create a new cluster config.</a>
<a name="ln1587">  std::vector&lt;std::string&gt; placement_info_split = strings::Split(</a>
<a name="ln1588">      placement_info, &quot;,&quot;, strings::SkipEmpty());</a>
<a name="ln1589">  if (placement_info_split.size() &lt; 1) {</a>
<a name="ln1590">    return STATUS(InvalidCommand, &quot;Cluster config must be a list of &quot;</a>
<a name="ln1591">    &quot;placement infos seperated by commas. &quot;</a>
<a name="ln1592">    &quot;Format: 'cloud1.region1.zone1,cloud2.region2.zone2,cloud3.region3.zone3 ...&quot;</a>
<a name="ln1593">    + std::to_string(placement_info_split.size()));</a>
<a name="ln1594">  }</a>
<a name="ln1595">  master::ChangeMasterClusterConfigRequestPB req_new_cluster_config;</a>
<a name="ln1596">  master::SysClusterConfigEntryPB* sys_cluster_config_entry =</a>
<a name="ln1597">      resp_cluster_config.mutable_cluster_config();</a>
<a name="ln1598">  master::PlacementInfoPB* live_replicas = new master::PlacementInfoPB;</a>
<a name="ln1599">  live_replicas-&gt;set_num_replicas(replication_factor);</a>
<a name="ln1600">  // Iterate over the placement blocks of the placementInfo structure.</a>
<a name="ln1601">  for (int iter = 0; iter &lt; placement_info_split.size(); iter++) {</a>
<a name="ln1602">    std::vector&lt;std::string&gt; block = strings::Split(placement_info_split[iter], &quot;.&quot;,</a>
<a name="ln1603">                                                    strings::SkipEmpty());</a>
<a name="ln1604">    if (block.size() != 3) {</a>
<a name="ln1605">      return STATUS(InvalidCommand, &quot;Each placement info must have exactly 3 values seperated&quot;</a>
<a name="ln1606">          &quot;by dots that denote cloud, region and zone. Block: &quot; + placement_info_split[iter]</a>
<a name="ln1607">          + &quot; is invalid&quot;);</a>
<a name="ln1608">    }</a>
<a name="ln1609">    auto pb = live_replicas-&gt;add_placement_blocks();</a>
<a name="ln1610">    pb-&gt;mutable_cloud_info()-&gt;set_placement_cloud(block[0]);</a>
<a name="ln1611">    pb-&gt;mutable_cloud_info()-&gt;set_placement_region(block[1]);</a>
<a name="ln1612">    pb-&gt;mutable_cloud_info()-&gt;set_placement_zone(block[2]);</a>
<a name="ln1613">    pb-&gt;set_min_num_replicas(1);</a>
<a name="ln1614">  }</a>
<a name="ln1615"> </a>
<a name="ln1616">  if (!optional_uuid.empty()) {</a>
<a name="ln1617">    // If we have an optional uuid, set it.</a>
<a name="ln1618">    live_replicas-&gt;set_placement_uuid(optional_uuid);</a>
<a name="ln1619">  } else if (sys_cluster_config_entry-&gt;replication_info().live_replicas().has_placement_uuid()) {</a>
<a name="ln1620">    // Otherwise, if we have an existing placement uuid, use that.</a>
<a name="ln1621">    live_replicas-&gt;set_placement_uuid(</a>
<a name="ln1622">        sys_cluster_config_entry-&gt;replication_info().live_replicas().placement_uuid());</a>
<a name="ln1623">  }</a>
<a name="ln1624"> </a>
<a name="ln1625">  sys_cluster_config_entry-&gt;mutable_replication_info()-&gt;set_allocated_live_replicas(live_replicas);</a>
<a name="ln1626">  req_new_cluster_config.mutable_cluster_config()-&gt;CopyFrom(*sys_cluster_config_entry);</a>
<a name="ln1627"> </a>
<a name="ln1628">  RETURN_NOT_OK(InvokeRpc(&amp;MasterServiceProxy::ChangeMasterClusterConfig,</a>
<a name="ln1629">      master_proxy_.get(), req_new_cluster_config,</a>
<a name="ln1630">      &quot;MasterServiceImpl::ChangeMasterClusterConfig call failed.&quot;));</a>
<a name="ln1631"> </a>
<a name="ln1632">  LOG(INFO)&lt;&lt; &quot;Changed master cluster config.&quot;;</a>
<a name="ln1633">  return Status::OK();</a>
<a name="ln1634">}</a>
<a name="ln1635"> </a>
<a name="ln1636">Status ClusterAdminClient::GetUniverseConfig() {</a>
<a name="ln1637">  const auto cluster_config = VERIFY_RESULT(GetMasterClusterConfig());</a>
<a name="ln1638">  std::string output;</a>
<a name="ln1639">  MessageToJsonString(cluster_config.cluster_config(), &amp;output);</a>
<a name="ln1640">  cout &lt;&lt; output &lt;&lt; endl;</a>
<a name="ln1641">  return Status::OK();</a>
<a name="ln1642">}</a>
<a name="ln1643"> </a>
<a name="ln1644">Status ClusterAdminClient::GetYsqlCatalogVersion() {</a>
<a name="ln1645">  uint64_t version = 0;</a>
<a name="ln1646">  RETURN_NOT_OK(yb_client_-&gt;GetYsqlCatalogMasterVersion(&amp;version));</a>
<a name="ln1647">  cout &lt;&lt; &quot;Version: &quot;  &lt;&lt; version &lt;&lt; endl;</a>
<a name="ln1648">  return Status::OK();</a>
<a name="ln1649">}</a>
<a name="ln1650"> </a>
<a name="ln1651">Status ClusterAdminClient::ChangeBlacklist(const std::vector&lt;HostPort&gt;&amp; servers, bool add,</a>
<a name="ln1652">    bool blacklist_leader) {</a>
<a name="ln1653">  auto config = VERIFY_RESULT(GetMasterClusterConfig());</a>
<a name="ln1654">  auto&amp; cluster_config = *config.mutable_cluster_config();</a>
<a name="ln1655">  auto&amp; blacklist = (blacklist_leader) ?</a>
<a name="ln1656">    *cluster_config.mutable_leader_blacklist() :</a>
<a name="ln1657">    *cluster_config.mutable_server_blacklist();</a>
<a name="ln1658">  std::vector&lt;HostPort&gt; result_blacklist;</a>
<a name="ln1659">  for (const auto&amp; host : blacklist.hosts()) {</a>
<a name="ln1660">    const HostPort hostport(host.host(), host.port());</a>
<a name="ln1661">    if (std::find(servers.begin(), servers.end(), hostport) == servers.end()) {</a>
<a name="ln1662">      result_blacklist.emplace_back(host.host(), host.port());</a>
<a name="ln1663">    }</a>
<a name="ln1664">  }</a>
<a name="ln1665">  if (add) {</a>
<a name="ln1666">    result_blacklist.insert(result_blacklist.end(), servers.begin(), servers.end());</a>
<a name="ln1667">  }</a>
<a name="ln1668">  auto result_begin = result_blacklist.begin(), result_end = result_blacklist.end();</a>
<a name="ln1669">  std::sort(result_begin, result_end);</a>
<a name="ln1670">  result_blacklist.erase(std::unique(result_begin, result_end), result_end);</a>
<a name="ln1671">  blacklist.clear_hosts();</a>
<a name="ln1672">  for (const auto&amp; hostport : result_blacklist) {</a>
<a name="ln1673">    auto&amp; new_host = *blacklist.add_hosts();</a>
<a name="ln1674">    new_host.set_host(hostport.host());</a>
<a name="ln1675">    new_host.set_port(hostport.port());</a>
<a name="ln1676">  }</a>
<a name="ln1677">  master::ChangeMasterClusterConfigRequestPB req_new_cluster_config;</a>
<a name="ln1678">  req_new_cluster_config.mutable_cluster_config()-&gt;Swap(&amp;cluster_config);</a>
<a name="ln1679">  return ResultToStatus(InvokeRpc(&amp;MasterServiceProxy::ChangeMasterClusterConfig,</a>
<a name="ln1680">                                  master_proxy_.get(), req_new_cluster_config,</a>
<a name="ln1681">                                  &quot;MasterServiceImpl::ChangeMasterClusterConfig call failed.&quot;));</a>
<a name="ln1682">}</a>
<a name="ln1683"> </a>
<a name="ln1684">Result&lt;const master::NamespaceIdentifierPB&amp;&gt; ClusterAdminClient::GetNamespaceInfo(</a>
<a name="ln1685">    YQLDatabase db_type, const std::string&amp; namespace_name) {</a>
<a name="ln1686">  LOG(INFO) &lt;&lt; Format(</a>
<a name="ln1687">      &quot;Resolving namespace id for '$0' of type '$1'&quot;, namespace_name, DatabasePrefix(db_type));</a>
<a name="ln1688">  for (const auto&amp; item : VERIFY_RESULT_REF(GetNamespaceMap())) {</a>
<a name="ln1689">    const auto&amp; namespace_info = item.second;</a>
<a name="ln1690">    if (namespace_info.database_type() == db_type &amp;&amp; namespace_name == namespace_info.name()) {</a>
<a name="ln1691">      return namespace_info;</a>
<a name="ln1692">    }</a>
<a name="ln1693">  }</a>
<a name="ln1694">  return STATUS_FORMAT(</a>
<a name="ln1695">      NotFound, &quot;Namespace '$0' of type '$1' not found&quot;, namespace_name, DatabasePrefix(db_type));</a>
<a name="ln1696">}</a>
<a name="ln1697"> </a>
<a name="ln1698">Result&lt;master::GetMasterClusterConfigResponsePB&gt; ClusterAdminClient::GetMasterClusterConfig() {</a>
<a name="ln1699">  return InvokeRpc(&amp;MasterServiceProxy::GetMasterClusterConfig, master_proxy_.get(),</a>
<a name="ln1700">                   master::GetMasterClusterConfigRequestPB(),</a>
<a name="ln1701">                   &quot;MasterServiceImpl::GetMasterClusterConfig call failed.&quot;);</a>
<a name="ln1702">}</a>
<a name="ln1703"> </a>
<a name="ln1704">CHECKED_STATUS ClusterAdminClient::SplitTablet(const std::string&amp; tablet_id) {</a>
<a name="ln1705">  master::SplitTabletRequestPB req;</a>
<a name="ln1706">  req.set_tablet_id(tablet_id);</a>
<a name="ln1707">  const auto resp = VERIFY_RESULT(</a>
<a name="ln1708">      InvokeRpc(&amp;MasterServiceProxy::SplitTablet, master_proxy_.get(), req));</a>
<a name="ln1709">  std::cout &lt;&lt; &quot;Response: &quot; &lt;&lt; AsString(resp) &lt;&lt; std::endl;</a>
<a name="ln1710">  return Status::OK();</a>
<a name="ln1711">}</a>
<a name="ln1712"> </a>
<a name="ln1713">template&lt;class Response, class Request, class Object&gt;</a>
<a name="ln1714">Result&lt;Response&gt; ClusterAdminClient::InvokeRpcNoResponseCheck(</a>
<a name="ln1715">    Status (Object::*func)(const Request&amp;, Response*, rpc::RpcController*),</a>
<a name="ln1716">    Object* obj, const Request&amp; req, const char* error_message) {</a>
<a name="ln1717">  rpc::RpcController rpc;</a>
<a name="ln1718">  rpc.set_timeout(timeout_);</a>
<a name="ln1719">  Response response;</a>
<a name="ln1720">  auto result = (obj-&gt;*func)(req, &amp;response, &amp;rpc);</a>
<a name="ln1721">  if (error_message) {</a>
<a name="ln1722">    RETURN_NOT_OK_PREPEND(result, error_message);</a>
<a name="ln1723">  } else {</a>
<a name="ln1724">    RETURN_NOT_OK(result);</a>
<a name="ln1725">  }</a>
<a name="ln1726">  return std::move(response);</a>
<a name="ln1727">}</a>
<a name="ln1728"> </a>
<a name="ln1729">template&lt;class Response, class Request, class Object&gt;</a>
<a name="ln1730">Result&lt;Response&gt; ClusterAdminClient::InvokeRpc(</a>
<a name="ln1731">    Status (Object::*func)(const Request&amp;, Response*, rpc::RpcController*),</a>
<a name="ln1732">    Object* obj, const Request&amp; req, const char* error_message) {</a>
<a name="ln1733">  return ResponseResult(VERIFY_RESULT(InvokeRpcNoResponseCheck(func, obj, req, error_message)));</a>
<a name="ln1734">}</a>
<a name="ln1735"> </a>
<a name="ln1736">Result&lt;const ClusterAdminClient::NamespaceMap&amp;&gt; ClusterAdminClient::GetNamespaceMap() {</a>
<a name="ln1737">  if (namespace_map_.empty()) {</a>
<a name="ln1738">    auto v = VERIFY_RESULT(yb_client_-&gt;ListNamespaces());</a>
<a name="ln1739">    for (auto&amp; ns : v) {</a>
<a name="ln1740">      auto ns_id = ns.id();</a>
<a name="ln1741">      namespace_map_.emplace(std::move(ns_id), std::move(ns));</a>
<a name="ln1742">    }</a>
<a name="ln1743">  }</a>
<a name="ln1744">  return const_cast&lt;const ClusterAdminClient::NamespaceMap&amp;&gt;(namespace_map_);</a>
<a name="ln1745">}</a>
<a name="ln1746"> </a>
<a name="ln1747">Result&lt;TableNameResolver&gt; ClusterAdminClient::BuildTableNameResolver() {</a>
<a name="ln1748">  return TableNameResolver(VERIFY_RESULT(yb_client_-&gt;ListTables()),</a>
<a name="ln1749">                           VERIFY_RESULT(yb_client_-&gt;ListNamespaces()));</a>
<a name="ln1750">}</a>
<a name="ln1751"> </a>
<a name="ln1752">string RightPadToUuidWidth(const string &amp;s) {</a>
<a name="ln1753">  return RightPadToWidth(s, kNumCharactersInUuid);</a>
<a name="ln1754">}</a>
<a name="ln1755"> </a>
<a name="ln1756">Result&lt;TypedNamespaceName&gt; ParseNamespaceName(const std::string&amp; full_namespace_name,</a>
<a name="ln1757">                                              const YQLDatabase default_if_no_prefix) {</a>
<a name="ln1758">  const auto parts = SplitByDot(full_namespace_name);</a>
<a name="ln1759">  return ResolveNamespaceName(parts.prefix, parts.value, default_if_no_prefix);</a>
<a name="ln1760">}</a>
<a name="ln1761"> </a>
<a name="ln1762">}  // namespace tools</a>
<a name="ln1763">}  // namespace yb</a>

</code></pre>
<div class="balloon" rel="186"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="329"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="357"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="453"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="483"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="488"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="569"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="634"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="715"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="734"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="744"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="754"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="880"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="882"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="888"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="899"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="932"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="939"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1605"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'live_replicas' pointer. A memory leak is possible.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
