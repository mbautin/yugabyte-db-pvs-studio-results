
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>basic_socket_acceptor.hpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//</a>
<a name="ln2">// basic_socket_acceptor.hpp</a>
<a name="ln3">// ~~~~~~~~~~~~~~~~~~~~~~~~~</a>
<a name="ln4">//</a>
<a name="ln5">// Copyright (c) 2003-2018 Christopher M. Kohlhoff (chris at kohlhoff dot com)</a>
<a name="ln6">//</a>
<a name="ln7">// Distributed under the Boost Software License, Version 1.0. (See accompanying</a>
<a name="ln8">// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)</a>
<a name="ln9">//</a>
<a name="ln10"> </a>
<a name="ln11">#ifndef BOOST_ASIO_BASIC_SOCKET_ACCEPTOR_HPP</a>
<a name="ln12">#define BOOST_ASIO_BASIC_SOCKET_ACCEPTOR_HPP</a>
<a name="ln13"> </a>
<a name="ln14">#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1200)</a>
<a name="ln15"># pragma once</a>
<a name="ln16">#endif // defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1200)</a>
<a name="ln17"> </a>
<a name="ln18">#include &lt;boost/asio/detail/config.hpp&gt;</a>
<a name="ln19">#include &lt;boost/asio/basic_io_object.hpp&gt;</a>
<a name="ln20">#include &lt;boost/asio/basic_socket.hpp&gt;</a>
<a name="ln21">#include &lt;boost/asio/detail/handler_type_requirements.hpp&gt;</a>
<a name="ln22">#include &lt;boost/asio/detail/throw_error.hpp&gt;</a>
<a name="ln23">#include &lt;boost/asio/detail/type_traits.hpp&gt;</a>
<a name="ln24">#include &lt;boost/asio/error.hpp&gt;</a>
<a name="ln25">#include &lt;boost/asio/socket_base.hpp&gt;</a>
<a name="ln26"> </a>
<a name="ln27">#if defined(BOOST_ASIO_HAS_MOVE)</a>
<a name="ln28"># include &lt;utility&gt;</a>
<a name="ln29">#endif // defined(BOOST_ASIO_HAS_MOVE)</a>
<a name="ln30"> </a>
<a name="ln31">#if defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln32"># include &lt;boost/asio/socket_acceptor_service.hpp&gt;</a>
<a name="ln33">#else // defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln34"># if defined(BOOST_ASIO_WINDOWS_RUNTIME)</a>
<a name="ln35">#  include &lt;boost/asio/detail/null_socket_service.hpp&gt;</a>
<a name="ln36">#  define BOOST_ASIO_SVC_T detail::null_socket_service&lt;Protocol&gt;</a>
<a name="ln37"># elif defined(BOOST_ASIO_HAS_IOCP)</a>
<a name="ln38">#  include &lt;boost/asio/detail/win_iocp_socket_service.hpp&gt;</a>
<a name="ln39">#  define BOOST_ASIO_SVC_T detail::win_iocp_socket_service&lt;Protocol&gt;</a>
<a name="ln40"># else</a>
<a name="ln41">#  include &lt;boost/asio/detail/reactive_socket_service.hpp&gt;</a>
<a name="ln42">#  define BOOST_ASIO_SVC_T detail::reactive_socket_service&lt;Protocol&gt;</a>
<a name="ln43"># endif</a>
<a name="ln44">#endif // defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln45"> </a>
<a name="ln46">#include &lt;boost/asio/detail/push_options.hpp&gt;</a>
<a name="ln47"> </a>
<a name="ln48">namespace boost {</a>
<a name="ln49">namespace asio {</a>
<a name="ln50"> </a>
<a name="ln51">/// Provides the ability to accept new connections.</a>
<a name="ln52">/**</a>
<a name="ln53"> * The basic_socket_acceptor class template is used for accepting new socket</a>
<a name="ln54"> * connections.</a>
<a name="ln55"> *</a>
<a name="ln56"> * @par Thread Safety</a>
<a name="ln57"> * @e Distinct @e objects: Safe.@n</a>
<a name="ln58"> * @e Shared @e objects: Unsafe.</a>
<a name="ln59"> *</a>
<a name="ln60"> * @par Example</a>
<a name="ln61"> * Opening a socket acceptor with the SO_REUSEADDR option enabled:</a>
<a name="ln62"> * @code</a>
<a name="ln63"> * boost::asio::ip::tcp::acceptor acceptor(io_context);</a>
<a name="ln64"> * boost::asio::ip::tcp::endpoint endpoint(boost::asio::ip::tcp::v4(), port);</a>
<a name="ln65"> * acceptor.open(endpoint.protocol());</a>
<a name="ln66"> * acceptor.set_option(boost::asio::ip::tcp::acceptor::reuse_address(true));</a>
<a name="ln67"> * acceptor.bind(endpoint);</a>
<a name="ln68"> * acceptor.listen();</a>
<a name="ln69"> * @endcode</a>
<a name="ln70"> */</a>
<a name="ln71">template &lt;typename Protocol</a>
<a name="ln72">    BOOST_ASIO_SVC_TPARAM_DEF1(= socket_acceptor_service&lt;Protocol&gt;)&gt;</a>
<a name="ln73">class basic_socket_acceptor</a>
<a name="ln74">  : BOOST_ASIO_SVC_ACCESS basic_io_object&lt;BOOST_ASIO_SVC_T&gt;,</a>
<a name="ln75">    public socket_base</a>
<a name="ln76">{</a>
<a name="ln77">public:</a>
<a name="ln78">  /// The type of the executor associated with the object.</a>
<a name="ln79">  typedef io_context::executor_type executor_type;</a>
<a name="ln80"> </a>
<a name="ln81">  /// The native representation of an acceptor.</a>
<a name="ln82">#if defined(GENERATING_DOCUMENTATION)</a>
<a name="ln83">  typedef implementation_defined native_handle_type;</a>
<a name="ln84">#else</a>
<a name="ln85">  typedef typename BOOST_ASIO_SVC_T::native_handle_type native_handle_type;</a>
<a name="ln86">#endif</a>
<a name="ln87"> </a>
<a name="ln88">  /// The protocol type.</a>
<a name="ln89">  typedef Protocol protocol_type;</a>
<a name="ln90"> </a>
<a name="ln91">  /// The endpoint type.</a>
<a name="ln92">  typedef typename Protocol::endpoint endpoint_type;</a>
<a name="ln93"> </a>
<a name="ln94">  /// Construct an acceptor without opening it.</a>
<a name="ln95">  /**</a>
<a name="ln96">   * This constructor creates an acceptor without opening it to listen for new</a>
<a name="ln97">   * connections. The open() function must be called before the acceptor can</a>
<a name="ln98">   * accept new socket connections.</a>
<a name="ln99">   *</a>
<a name="ln100">   * @param io_context The io_context object that the acceptor will use to</a>
<a name="ln101">   * dispatch handlers for any asynchronous operations performed on the</a>
<a name="ln102">   * acceptor.</a>
<a name="ln103">   */</a>
<a name="ln104">  explicit basic_socket_acceptor(boost::asio::io_context&amp; io_context)</a>
<a name="ln105">    : basic_io_object&lt;BOOST_ASIO_SVC_T&gt;(io_context)</a>
<a name="ln106">  {</a>
<a name="ln107">  }</a>
<a name="ln108"> </a>
<a name="ln109">  /// Construct an open acceptor.</a>
<a name="ln110">  /**</a>
<a name="ln111">   * This constructor creates an acceptor and automatically opens it.</a>
<a name="ln112">   *</a>
<a name="ln113">   * @param io_context The io_context object that the acceptor will use to</a>
<a name="ln114">   * dispatch handlers for any asynchronous operations performed on the</a>
<a name="ln115">   * acceptor.</a>
<a name="ln116">   *</a>
<a name="ln117">   * @param protocol An object specifying protocol parameters to be used.</a>
<a name="ln118">   *</a>
<a name="ln119">   * @throws boost::system::system_error Thrown on failure.</a>
<a name="ln120">   */</a>
<a name="ln121">  basic_socket_acceptor(boost::asio::io_context&amp; io_context,</a>
<a name="ln122">      const protocol_type&amp; protocol)</a>
<a name="ln123">    : basic_io_object&lt;BOOST_ASIO_SVC_T&gt;(io_context)</a>
<a name="ln124">  {</a>
<a name="ln125">    boost::system::error_code ec;</a>
<a name="ln126">    this-&gt;get_service().open(this-&gt;get_implementation(), protocol, ec);</a>
<a name="ln127">    boost::asio::detail::throw_error(ec, &quot;open&quot;);</a>
<a name="ln128">  }</a>
<a name="ln129"> </a>
<a name="ln130">  /// Construct an acceptor opened on the given endpoint.</a>
<a name="ln131">  /**</a>
<a name="ln132">   * This constructor creates an acceptor and automatically opens it to listen</a>
<a name="ln133">   * for new connections on the specified endpoint.</a>
<a name="ln134">   *</a>
<a name="ln135">   * @param io_context The io_context object that the acceptor will use to</a>
<a name="ln136">   * dispatch handlers for any asynchronous operations performed on the</a>
<a name="ln137">   * acceptor.</a>
<a name="ln138">   *</a>
<a name="ln139">   * @param endpoint An endpoint on the local machine on which the acceptor</a>
<a name="ln140">   * will listen for new connections.</a>
<a name="ln141">   *</a>
<a name="ln142">   * @param reuse_addr Whether the constructor should set the socket option</a>
<a name="ln143">   * socket_base::reuse_address.</a>
<a name="ln144">   *</a>
<a name="ln145">   * @throws boost::system::system_error Thrown on failure.</a>
<a name="ln146">   *</a>
<a name="ln147">   * @note This constructor is equivalent to the following code:</a>
<a name="ln148">   * @code</a>
<a name="ln149">   * basic_socket_acceptor&lt;Protocol&gt; acceptor(io_context);</a>
<a name="ln150">   * acceptor.open(endpoint.protocol());</a>
<a name="ln151">   * if (reuse_addr)</a>
<a name="ln152">   *   acceptor.set_option(socket_base::reuse_address(true));</a>
<a name="ln153">   * acceptor.bind(endpoint);</a>
<a name="ln154">   * acceptor.listen(listen_backlog);</a>
<a name="ln155">   * @endcode</a>
<a name="ln156">   */</a>
<a name="ln157">  basic_socket_acceptor(boost::asio::io_context&amp; io_context,</a>
<a name="ln158">      const endpoint_type&amp; endpoint, bool reuse_addr = true)</a>
<a name="ln159">    : basic_io_object&lt;BOOST_ASIO_SVC_T&gt;(io_context)</a>
<a name="ln160">  {</a>
<a name="ln161">    boost::system::error_code ec;</a>
<a name="ln162">    const protocol_type protocol = endpoint.protocol();</a>
<a name="ln163">    this-&gt;get_service().open(this-&gt;get_implementation(), protocol, ec);</a>
<a name="ln164">    boost::asio::detail::throw_error(ec, &quot;open&quot;);</a>
<a name="ln165">    if (reuse_addr)</a>
<a name="ln166">    {</a>
<a name="ln167">      this-&gt;get_service().set_option(this-&gt;get_implementation(),</a>
<a name="ln168">          socket_base::reuse_address(true), ec);</a>
<a name="ln169">      boost::asio::detail::throw_error(ec, &quot;set_option&quot;);</a>
<a name="ln170">    }</a>
<a name="ln171">    this-&gt;get_service().bind(this-&gt;get_implementation(), endpoint, ec);</a>
<a name="ln172">    boost::asio::detail::throw_error(ec, &quot;bind&quot;);</a>
<a name="ln173">    this-&gt;get_service().listen(this-&gt;get_implementation(),</a>
<a name="ln174">        socket_base::max_listen_connections, ec);</a>
<a name="ln175">    boost::asio::detail::throw_error(ec, &quot;listen&quot;);</a>
<a name="ln176">  }</a>
<a name="ln177"> </a>
<a name="ln178">  /// Construct a basic_socket_acceptor on an existing native acceptor.</a>
<a name="ln179">  /**</a>
<a name="ln180">   * This constructor creates an acceptor object to hold an existing native</a>
<a name="ln181">   * acceptor.</a>
<a name="ln182">   *</a>
<a name="ln183">   * @param io_context The io_context object that the acceptor will use to</a>
<a name="ln184">   * dispatch handlers for any asynchronous operations performed on the</a>
<a name="ln185">   * acceptor.</a>
<a name="ln186">   *</a>
<a name="ln187">   * @param protocol An object specifying protocol parameters to be used.</a>
<a name="ln188">   *</a>
<a name="ln189">   * @param native_acceptor A native acceptor.</a>
<a name="ln190">   *</a>
<a name="ln191">   * @throws boost::system::system_error Thrown on failure.</a>
<a name="ln192">   */</a>
<a name="ln193">  basic_socket_acceptor(boost::asio::io_context&amp; io_context,</a>
<a name="ln194">      const protocol_type&amp; protocol, const native_handle_type&amp; native_acceptor)</a>
<a name="ln195">    : basic_io_object&lt;BOOST_ASIO_SVC_T&gt;(io_context)</a>
<a name="ln196">  {</a>
<a name="ln197">    boost::system::error_code ec;</a>
<a name="ln198">    this-&gt;get_service().assign(this-&gt;get_implementation(),</a>
<a name="ln199">        protocol, native_acceptor, ec);</a>
<a name="ln200">    boost::asio::detail::throw_error(ec, &quot;assign&quot;);</a>
<a name="ln201">  }</a>
<a name="ln202"> </a>
<a name="ln203">#if defined(BOOST_ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)</a>
<a name="ln204">  /// Move-construct a basic_socket_acceptor from another.</a>
<a name="ln205">  /**</a>
<a name="ln206">   * This constructor moves an acceptor from one object to another.</a>
<a name="ln207">   *</a>
<a name="ln208">   * @param other The other basic_socket_acceptor object from which the move</a>
<a name="ln209">   * will occur.</a>
<a name="ln210">   *</a>
<a name="ln211">   * @note Following the move, the moved-from object is in the same state as if</a>
<a name="ln212">   * constructed using the @c basic_socket_acceptor(io_context&amp;) constructor.</a>
<a name="ln213">   */</a>
<a name="ln214">  basic_socket_acceptor(basic_socket_acceptor&amp;&amp; other)</a>
<a name="ln215">    : basic_io_object&lt;BOOST_ASIO_SVC_T&gt;(std::move(other))</a>
<a name="ln216">  {</a>
<a name="ln217">  }</a>
<a name="ln218"> </a>
<a name="ln219">  /// Move-assign a basic_socket_acceptor from another.</a>
<a name="ln220">  /**</a>
<a name="ln221">   * This assignment operator moves an acceptor from one object to another.</a>
<a name="ln222">   *</a>
<a name="ln223">   * @param other The other basic_socket_acceptor object from which the move</a>
<a name="ln224">   * will occur.</a>
<a name="ln225">   *</a>
<a name="ln226">   * @note Following the move, the moved-from object is in the same state as if</a>
<a name="ln227">   * constructed using the @c basic_socket_acceptor(io_context&amp;) constructor.</a>
<a name="ln228">   */</a>
<a name="ln229">  basic_socket_acceptor&amp; operator=(basic_socket_acceptor&amp;&amp; other)</a>
<a name="ln230">  {</a>
<a name="ln231">    basic_io_object&lt;BOOST_ASIO_SVC_T&gt;::operator=(std::move(other));</a>
<a name="ln232">    return *this;</a>
<a name="ln233">  }</a>
<a name="ln234"> </a>
<a name="ln235">  // All socket acceptors have access to each other's implementations.</a>
<a name="ln236">  template &lt;typename Protocol1 BOOST_ASIO_SVC_TPARAM1&gt;</a>
<a name="ln237">  friend class basic_socket_acceptor;</a>
<a name="ln238"> </a>
<a name="ln239">  /// Move-construct a basic_socket_acceptor from an acceptor of another</a>
<a name="ln240">  /// protocol type.</a>
<a name="ln241">  /**</a>
<a name="ln242">   * This constructor moves an acceptor from one object to another.</a>
<a name="ln243">   *</a>
<a name="ln244">   * @param other The other basic_socket_acceptor object from which the move</a>
<a name="ln245">   * will occur.</a>
<a name="ln246">   *</a>
<a name="ln247">   * @note Following the move, the moved-from object is in the same state as if</a>
<a name="ln248">   * constructed using the @c basic_socket(io_context&amp;) constructor.</a>
<a name="ln249">   */</a>
<a name="ln250">  template &lt;typename Protocol1 BOOST_ASIO_SVC_TPARAM1&gt;</a>
<a name="ln251">  basic_socket_acceptor(</a>
<a name="ln252">      basic_socket_acceptor&lt;Protocol1 BOOST_ASIO_SVC_TARG1&gt;&amp;&amp; other,</a>
<a name="ln253">      typename enable_if&lt;is_convertible&lt;Protocol1, Protocol&gt;::value&gt;::type* = 0)</a>
<a name="ln254">    : basic_io_object&lt;BOOST_ASIO_SVC_T&gt;(</a>
<a name="ln255">        other.get_service(), other.get_implementation())</a>
<a name="ln256">  {</a>
<a name="ln257">  }</a>
<a name="ln258"> </a>
<a name="ln259">  /// Move-assign a basic_socket_acceptor from an acceptor of another protocol</a>
<a name="ln260">  /// type.</a>
<a name="ln261">  /**</a>
<a name="ln262">   * This assignment operator moves an acceptor from one object to another.</a>
<a name="ln263">   *</a>
<a name="ln264">   * @param other The other basic_socket_acceptor object from which the move</a>
<a name="ln265">   * will occur.</a>
<a name="ln266">   *</a>
<a name="ln267">   * @note Following the move, the moved-from object is in the same state as if</a>
<a name="ln268">   * constructed using the @c basic_socket(io_context&amp;) constructor.</a>
<a name="ln269">   */</a>
<a name="ln270">  template &lt;typename Protocol1 BOOST_ASIO_SVC_TPARAM1&gt;</a>
<a name="ln271">  typename enable_if&lt;is_convertible&lt;Protocol1, Protocol&gt;::value,</a>
<a name="ln272">      basic_socket_acceptor&gt;::type&amp; operator=(</a>
<a name="ln273">        basic_socket_acceptor&lt;Protocol1 BOOST_ASIO_SVC_TARG1&gt;&amp;&amp; other)</a>
<a name="ln274">  {</a>
<a name="ln275">    basic_socket_acceptor tmp(std::move(other));</a>
<a name="ln276">    basic_io_object&lt;BOOST_ASIO_SVC_T&gt;::operator=(std::move(tmp));</a>
<a name="ln277">    return *this;</a>
<a name="ln278">  }</a>
<a name="ln279">#endif // defined(BOOST_ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)</a>
<a name="ln280"> </a>
<a name="ln281">  /// Destroys the acceptor.</a>
<a name="ln282">  /**</a>
<a name="ln283">   * This function destroys the acceptor, cancelling any outstanding</a>
<a name="ln284">   * asynchronous operations associated with the acceptor as if by calling</a>
<a name="ln285">   * @c cancel.</a>
<a name="ln286">   */</a>
<a name="ln287">  ~basic_socket_acceptor()</a>
<a name="ln288">  {</a>
<a name="ln289">  }</a>
<a name="ln290"> </a>
<a name="ln291">#if defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln292">  // These functions are provided by basic_io_object&lt;&gt;.</a>
<a name="ln293">#else // defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln294">#if !defined(BOOST_ASIO_NO_DEPRECATED)</a>
<a name="ln295">  /// (Deprecated: Use get_executor().) Get the io_context associated with the</a>
<a name="ln296">  /// object.</a>
<a name="ln297">  /**</a>
<a name="ln298">   * This function may be used to obtain the io_context object that the I/O</a>
<a name="ln299">   * object uses to dispatch handlers for asynchronous operations.</a>
<a name="ln300">   *</a>
<a name="ln301">   * @return A reference to the io_context object that the I/O object will use</a>
<a name="ln302">   * to dispatch handlers. Ownership is not transferred to the caller.</a>
<a name="ln303">   */</a>
<a name="ln304">  boost::asio::io_context&amp; get_io_context()</a>
<a name="ln305">  {</a>
<a name="ln306">    return basic_io_object&lt;BOOST_ASIO_SVC_T&gt;::get_io_context();</a>
<a name="ln307">  }</a>
<a name="ln308"> </a>
<a name="ln309">  /// (Deprecated: Use get_executor().) Get the io_context associated with the</a>
<a name="ln310">  /// object.</a>
<a name="ln311">  /**</a>
<a name="ln312">   * This function may be used to obtain the io_context object that the I/O</a>
<a name="ln313">   * object uses to dispatch handlers for asynchronous operations.</a>
<a name="ln314">   *</a>
<a name="ln315">   * @return A reference to the io_context object that the I/O object will use</a>
<a name="ln316">   * to dispatch handlers. Ownership is not transferred to the caller.</a>
<a name="ln317">   */</a>
<a name="ln318">  boost::asio::io_context&amp; get_io_service()</a>
<a name="ln319">  {</a>
<a name="ln320">    return basic_io_object&lt;BOOST_ASIO_SVC_T&gt;::get_io_service();</a>
<a name="ln321">  }</a>
<a name="ln322">#endif // !defined(BOOST_ASIO_NO_DEPRECATED)</a>
<a name="ln323"> </a>
<a name="ln324">  /// Get the executor associated with the object.</a>
<a name="ln325">  executor_type get_executor() BOOST_ASIO_NOEXCEPT</a>
<a name="ln326">  {</a>
<a name="ln327">    return basic_io_object&lt;BOOST_ASIO_SVC_T&gt;::get_executor();</a>
<a name="ln328">  }</a>
<a name="ln329">#endif // defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln330"> </a>
<a name="ln331">  /// Open the acceptor using the specified protocol.</a>
<a name="ln332">  /**</a>
<a name="ln333">   * This function opens the socket acceptor so that it will use the specified</a>
<a name="ln334">   * protocol.</a>
<a name="ln335">   *</a>
<a name="ln336">   * @param protocol An object specifying which protocol is to be used.</a>
<a name="ln337">   *</a>
<a name="ln338">   * @throws boost::system::system_error Thrown on failure.</a>
<a name="ln339">   *</a>
<a name="ln340">   * @par Example</a>
<a name="ln341">   * @code</a>
<a name="ln342">   * boost::asio::ip::tcp::acceptor acceptor(io_context);</a>
<a name="ln343">   * acceptor.open(boost::asio::ip::tcp::v4());</a>
<a name="ln344">   * @endcode</a>
<a name="ln345">   */</a>
<a name="ln346">  void open(const protocol_type&amp; protocol = protocol_type())</a>
<a name="ln347">  {</a>
<a name="ln348">    boost::system::error_code ec;</a>
<a name="ln349">    this-&gt;get_service().open(this-&gt;get_implementation(), protocol, ec);</a>
<a name="ln350">    boost::asio::detail::throw_error(ec, &quot;open&quot;);</a>
<a name="ln351">  }</a>
<a name="ln352"> </a>
<a name="ln353">  /// Open the acceptor using the specified protocol.</a>
<a name="ln354">  /**</a>
<a name="ln355">   * This function opens the socket acceptor so that it will use the specified</a>
<a name="ln356">   * protocol.</a>
<a name="ln357">   *</a>
<a name="ln358">   * @param protocol An object specifying which protocol is to be used.</a>
<a name="ln359">   *</a>
<a name="ln360">   * @param ec Set to indicate what error occurred, if any.</a>
<a name="ln361">   *</a>
<a name="ln362">   * @par Example</a>
<a name="ln363">   * @code</a>
<a name="ln364">   * boost::asio::ip::tcp::acceptor acceptor(io_context);</a>
<a name="ln365">   * boost::system::error_code ec;</a>
<a name="ln366">   * acceptor.open(boost::asio::ip::tcp::v4(), ec);</a>
<a name="ln367">   * if (ec)</a>
<a name="ln368">   * {</a>
<a name="ln369">   *   // An error occurred.</a>
<a name="ln370">   * }</a>
<a name="ln371">   * @endcode</a>
<a name="ln372">   */</a>
<a name="ln373">  BOOST_ASIO_SYNC_OP_VOID open(const protocol_type&amp; protocol,</a>
<a name="ln374">      boost::system::error_code&amp; ec)</a>
<a name="ln375">  {</a>
<a name="ln376">    this-&gt;get_service().open(this-&gt;get_implementation(), protocol, ec);</a>
<a name="ln377">    BOOST_ASIO_SYNC_OP_VOID_RETURN(ec);</a>
<a name="ln378">  }</a>
<a name="ln379"> </a>
<a name="ln380">  /// Assigns an existing native acceptor to the acceptor.</a>
<a name="ln381">  /*</a>
<a name="ln382">   * This function opens the acceptor to hold an existing native acceptor.</a>
<a name="ln383">   *</a>
<a name="ln384">   * @param protocol An object specifying which protocol is to be used.</a>
<a name="ln385">   *</a>
<a name="ln386">   * @param native_acceptor A native acceptor.</a>
<a name="ln387">   *</a>
<a name="ln388">   * @throws boost::system::system_error Thrown on failure.</a>
<a name="ln389">   */</a>
<a name="ln390">  void assign(const protocol_type&amp; protocol,</a>
<a name="ln391">      const native_handle_type&amp; native_acceptor)</a>
<a name="ln392">  {</a>
<a name="ln393">    boost::system::error_code ec;</a>
<a name="ln394">    this-&gt;get_service().assign(this-&gt;get_implementation(),</a>
<a name="ln395">        protocol, native_acceptor, ec);</a>
<a name="ln396">    boost::asio::detail::throw_error(ec, &quot;assign&quot;);</a>
<a name="ln397">  }</a>
<a name="ln398"> </a>
<a name="ln399">  /// Assigns an existing native acceptor to the acceptor.</a>
<a name="ln400">  /*</a>
<a name="ln401">   * This function opens the acceptor to hold an existing native acceptor.</a>
<a name="ln402">   *</a>
<a name="ln403">   * @param protocol An object specifying which protocol is to be used.</a>
<a name="ln404">   *</a>
<a name="ln405">   * @param native_acceptor A native acceptor.</a>
<a name="ln406">   *</a>
<a name="ln407">   * @param ec Set to indicate what error occurred, if any.</a>
<a name="ln408">   */</a>
<a name="ln409">  BOOST_ASIO_SYNC_OP_VOID assign(const protocol_type&amp; protocol,</a>
<a name="ln410">      const native_handle_type&amp; native_acceptor, boost::system::error_code&amp; ec)</a>
<a name="ln411">  {</a>
<a name="ln412">    this-&gt;get_service().assign(this-&gt;get_implementation(),</a>
<a name="ln413">        protocol, native_acceptor, ec);</a>
<a name="ln414">    BOOST_ASIO_SYNC_OP_VOID_RETURN(ec);</a>
<a name="ln415">  }</a>
<a name="ln416"> </a>
<a name="ln417">  /// Determine whether the acceptor is open.</a>
<a name="ln418">  bool is_open() const</a>
<a name="ln419">  {</a>
<a name="ln420">    return this-&gt;get_service().is_open(this-&gt;get_implementation());</a>
<a name="ln421">  }</a>
<a name="ln422"> </a>
<a name="ln423">  /// Bind the acceptor to the given local endpoint.</a>
<a name="ln424">  /**</a>
<a name="ln425">   * This function binds the socket acceptor to the specified endpoint on the</a>
<a name="ln426">   * local machine.</a>
<a name="ln427">   *</a>
<a name="ln428">   * @param endpoint An endpoint on the local machine to which the socket</a>
<a name="ln429">   * acceptor will be bound.</a>
<a name="ln430">   *</a>
<a name="ln431">   * @throws boost::system::system_error Thrown on failure.</a>
<a name="ln432">   *</a>
<a name="ln433">   * @par Example</a>
<a name="ln434">   * @code</a>
<a name="ln435">   * boost::asio::ip::tcp::acceptor acceptor(io_context);</a>
<a name="ln436">   * boost::asio::ip::tcp::endpoint endpoint(boost::asio::ip::tcp::v4(), 12345);</a>
<a name="ln437">   * acceptor.open(endpoint.protocol());</a>
<a name="ln438">   * acceptor.bind(endpoint);</a>
<a name="ln439">   * @endcode</a>
<a name="ln440">   */</a>
<a name="ln441">  void bind(const endpoint_type&amp; endpoint)</a>
<a name="ln442">  {</a>
<a name="ln443">    boost::system::error_code ec;</a>
<a name="ln444">    this-&gt;get_service().bind(this-&gt;get_implementation(), endpoint, ec);</a>
<a name="ln445">    boost::asio::detail::throw_error(ec, &quot;bind&quot;);</a>
<a name="ln446">  }</a>
<a name="ln447"> </a>
<a name="ln448">  /// Bind the acceptor to the given local endpoint.</a>
<a name="ln449">  /**</a>
<a name="ln450">   * This function binds the socket acceptor to the specified endpoint on the</a>
<a name="ln451">   * local machine.</a>
<a name="ln452">   *</a>
<a name="ln453">   * @param endpoint An endpoint on the local machine to which the socket</a>
<a name="ln454">   * acceptor will be bound.</a>
<a name="ln455">   *</a>
<a name="ln456">   * @param ec Set to indicate what error occurred, if any.</a>
<a name="ln457">   *</a>
<a name="ln458">   * @par Example</a>
<a name="ln459">   * @code</a>
<a name="ln460">   * boost::asio::ip::tcp::acceptor acceptor(io_context);</a>
<a name="ln461">   * boost::asio::ip::tcp::endpoint endpoint(boost::asio::ip::tcp::v4(), 12345);</a>
<a name="ln462">   * acceptor.open(endpoint.protocol());</a>
<a name="ln463">   * boost::system::error_code ec;</a>
<a name="ln464">   * acceptor.bind(endpoint, ec);</a>
<a name="ln465">   * if (ec)</a>
<a name="ln466">   * {</a>
<a name="ln467">   *   // An error occurred.</a>
<a name="ln468">   * }</a>
<a name="ln469">   * @endcode</a>
<a name="ln470">   */</a>
<a name="ln471">  BOOST_ASIO_SYNC_OP_VOID bind(const endpoint_type&amp; endpoint,</a>
<a name="ln472">      boost::system::error_code&amp; ec)</a>
<a name="ln473">  {</a>
<a name="ln474">    this-&gt;get_service().bind(this-&gt;get_implementation(), endpoint, ec);</a>
<a name="ln475">    BOOST_ASIO_SYNC_OP_VOID_RETURN(ec);</a>
<a name="ln476">  }</a>
<a name="ln477"> </a>
<a name="ln478">  /// Place the acceptor into the state where it will listen for new</a>
<a name="ln479">  /// connections.</a>
<a name="ln480">  /**</a>
<a name="ln481">   * This function puts the socket acceptor into the state where it may accept</a>
<a name="ln482">   * new connections.</a>
<a name="ln483">   *</a>
<a name="ln484">   * @param backlog The maximum length of the queue of pending connections.</a>
<a name="ln485">   *</a>
<a name="ln486">   * @throws boost::system::system_error Thrown on failure.</a>
<a name="ln487">   */</a>
<a name="ln488">  void listen(int backlog = socket_base::max_listen_connections)</a>
<a name="ln489">  {</a>
<a name="ln490">    boost::system::error_code ec;</a>
<a name="ln491">    this-&gt;get_service().listen(this-&gt;get_implementation(), backlog, ec);</a>
<a name="ln492">    boost::asio::detail::throw_error(ec, &quot;listen&quot;);</a>
<a name="ln493">  }</a>
<a name="ln494"> </a>
<a name="ln495">  /// Place the acceptor into the state where it will listen for new</a>
<a name="ln496">  /// connections.</a>
<a name="ln497">  /**</a>
<a name="ln498">   * This function puts the socket acceptor into the state where it may accept</a>
<a name="ln499">   * new connections.</a>
<a name="ln500">   *</a>
<a name="ln501">   * @param backlog The maximum length of the queue of pending connections.</a>
<a name="ln502">   *</a>
<a name="ln503">   * @param ec Set to indicate what error occurred, if any.</a>
<a name="ln504">   *</a>
<a name="ln505">   * @par Example</a>
<a name="ln506">   * @code</a>
<a name="ln507">   * boost::asio::ip::tcp::acceptor acceptor(io_context);</a>
<a name="ln508">   * ...</a>
<a name="ln509">   * boost::system::error_code ec;</a>
<a name="ln510">   * acceptor.listen(boost::asio::socket_base::max_listen_connections, ec);</a>
<a name="ln511">   * if (ec)</a>
<a name="ln512">   * {</a>
<a name="ln513">   *   // An error occurred.</a>
<a name="ln514">   * }</a>
<a name="ln515">   * @endcode</a>
<a name="ln516">   */</a>
<a name="ln517">  BOOST_ASIO_SYNC_OP_VOID listen(int backlog, boost::system::error_code&amp; ec)</a>
<a name="ln518">  {</a>
<a name="ln519">    this-&gt;get_service().listen(this-&gt;get_implementation(), backlog, ec);</a>
<a name="ln520">    BOOST_ASIO_SYNC_OP_VOID_RETURN(ec);</a>
<a name="ln521">  }</a>
<a name="ln522"> </a>
<a name="ln523">  /// Close the acceptor.</a>
<a name="ln524">  /**</a>
<a name="ln525">   * This function is used to close the acceptor. Any asynchronous accept</a>
<a name="ln526">   * operations will be cancelled immediately.</a>
<a name="ln527">   *</a>
<a name="ln528">   * A subsequent call to open() is required before the acceptor can again be</a>
<a name="ln529">   * used to again perform socket accept operations.</a>
<a name="ln530">   *</a>
<a name="ln531">   * @throws boost::system::system_error Thrown on failure.</a>
<a name="ln532">   */</a>
<a name="ln533">  void close()</a>
<a name="ln534">  {</a>
<a name="ln535">    boost::system::error_code ec;</a>
<a name="ln536">    this-&gt;get_service().close(this-&gt;get_implementation(), ec);</a>
<a name="ln537">    boost::asio::detail::throw_error(ec, &quot;close&quot;);</a>
<a name="ln538">  }</a>
<a name="ln539"> </a>
<a name="ln540">  /// Close the acceptor.</a>
<a name="ln541">  /**</a>
<a name="ln542">   * This function is used to close the acceptor. Any asynchronous accept</a>
<a name="ln543">   * operations will be cancelled immediately.</a>
<a name="ln544">   *</a>
<a name="ln545">   * A subsequent call to open() is required before the acceptor can again be</a>
<a name="ln546">   * used to again perform socket accept operations.</a>
<a name="ln547">   *</a>
<a name="ln548">   * @param ec Set to indicate what error occurred, if any.</a>
<a name="ln549">   *</a>
<a name="ln550">   * @par Example</a>
<a name="ln551">   * @code</a>
<a name="ln552">   * boost::asio::ip::tcp::acceptor acceptor(io_context);</a>
<a name="ln553">   * ...</a>
<a name="ln554">   * boost::system::error_code ec;</a>
<a name="ln555">   * acceptor.close(ec);</a>
<a name="ln556">   * if (ec)</a>
<a name="ln557">   * {</a>
<a name="ln558">   *   // An error occurred.</a>
<a name="ln559">   * }</a>
<a name="ln560">   * @endcode</a>
<a name="ln561">   */</a>
<a name="ln562">  BOOST_ASIO_SYNC_OP_VOID close(boost::system::error_code&amp; ec)</a>
<a name="ln563">  {</a>
<a name="ln564">    this-&gt;get_service().close(this-&gt;get_implementation(), ec);</a>
<a name="ln565">    BOOST_ASIO_SYNC_OP_VOID_RETURN(ec);</a>
<a name="ln566">  }</a>
<a name="ln567"> </a>
<a name="ln568">  /// Release ownership of the underlying native acceptor.</a>
<a name="ln569">  /**</a>
<a name="ln570">   * This function causes all outstanding asynchronous accept operations to</a>
<a name="ln571">   * finish immediately, and the handlers for cancelled operations will be</a>
<a name="ln572">   * passed the boost::asio::error::operation_aborted error. Ownership of the</a>
<a name="ln573">   * native acceptor is then transferred to the caller.</a>
<a name="ln574">   *</a>
<a name="ln575">   * @throws boost::system::system_error Thrown on failure.</a>
<a name="ln576">   *</a>
<a name="ln577">   * @note This function is unsupported on Windows versions prior to Windows</a>
<a name="ln578">   * 8.1, and will fail with boost::asio::error::operation_not_supported on</a>
<a name="ln579">   * these platforms.</a>
<a name="ln580">   */</a>
<a name="ln581">#if defined(BOOST_ASIO_MSVC) &amp;&amp; (BOOST_ASIO_MSVC &gt;= 1400) \</a>
<a name="ln582">  &amp;&amp; (!defined(_WIN32_WINNT) || _WIN32_WINNT &lt; 0x0603)</a>
<a name="ln583">  __declspec(deprecated(&quot;This function always fails with &quot;</a>
<a name="ln584">        &quot;operation_not_supported when used on Windows versions &quot;</a>
<a name="ln585">        &quot;prior to Windows 8.1.&quot;))</a>
<a name="ln586">#endif</a>
<a name="ln587">  native_handle_type release()</a>
<a name="ln588">  {</a>
<a name="ln589">    boost::system::error_code ec;</a>
<a name="ln590">    native_handle_type s = this-&gt;get_service().release(</a>
<a name="ln591">        this-&gt;get_implementation(), ec);</a>
<a name="ln592">    boost::asio::detail::throw_error(ec, &quot;release&quot;);</a>
<a name="ln593">    return s;</a>
<a name="ln594">  }</a>
<a name="ln595"> </a>
<a name="ln596">  /// Release ownership of the underlying native acceptor.</a>
<a name="ln597">  /**</a>
<a name="ln598">   * This function causes all outstanding asynchronous accept operations to</a>
<a name="ln599">   * finish immediately, and the handlers for cancelled operations will be</a>
<a name="ln600">   * passed the boost::asio::error::operation_aborted error. Ownership of the</a>
<a name="ln601">   * native acceptor is then transferred to the caller.</a>
<a name="ln602">   *</a>
<a name="ln603">   * @param ec Set to indicate what error occurred, if any.</a>
<a name="ln604">   *</a>
<a name="ln605">   * @note This function is unsupported on Windows versions prior to Windows</a>
<a name="ln606">   * 8.1, and will fail with boost::asio::error::operation_not_supported on</a>
<a name="ln607">   * these platforms.</a>
<a name="ln608">   */</a>
<a name="ln609">#if defined(BOOST_ASIO_MSVC) &amp;&amp; (BOOST_ASIO_MSVC &gt;= 1400) \</a>
<a name="ln610">  &amp;&amp; (!defined(_WIN32_WINNT) || _WIN32_WINNT &lt; 0x0603)</a>
<a name="ln611">  __declspec(deprecated(&quot;This function always fails with &quot;</a>
<a name="ln612">        &quot;operation_not_supported when used on Windows versions &quot;</a>
<a name="ln613">        &quot;prior to Windows 8.1.&quot;))</a>
<a name="ln614">#endif</a>
<a name="ln615">  native_handle_type release(boost::system::error_code&amp; ec)</a>
<a name="ln616">  {</a>
<a name="ln617">    return this-&gt;get_service().release(this-&gt;get_implementation(), ec);</a>
<a name="ln618">  }</a>
<a name="ln619"> </a>
<a name="ln620">  /// Get the native acceptor representation.</a>
<a name="ln621">  /**</a>
<a name="ln622">   * This function may be used to obtain the underlying representation of the</a>
<a name="ln623">   * acceptor. This is intended to allow access to native acceptor functionality</a>
<a name="ln624">   * that is not otherwise provided.</a>
<a name="ln625">   */</a>
<a name="ln626">  native_handle_type native_handle()</a>
<a name="ln627">  {</a>
<a name="ln628">    return this-&gt;get_service().native_handle(this-&gt;get_implementation());</a>
<a name="ln629">  }</a>
<a name="ln630"> </a>
<a name="ln631">  /// Cancel all asynchronous operations associated with the acceptor.</a>
<a name="ln632">  /**</a>
<a name="ln633">   * This function causes all outstanding asynchronous connect, send and receive</a>
<a name="ln634">   * operations to finish immediately, and the handlers for cancelled operations</a>
<a name="ln635">   * will be passed the boost::asio::error::operation_aborted error.</a>
<a name="ln636">   *</a>
<a name="ln637">   * @throws boost::system::system_error Thrown on failure.</a>
<a name="ln638">   */</a>
<a name="ln639">  void cancel()</a>
<a name="ln640">  {</a>
<a name="ln641">    boost::system::error_code ec;</a>
<a name="ln642">    this-&gt;get_service().cancel(this-&gt;get_implementation(), ec);</a>
<a name="ln643">    boost::asio::detail::throw_error(ec, &quot;cancel&quot;);</a>
<a name="ln644">  }</a>
<a name="ln645"> </a>
<a name="ln646">  /// Cancel all asynchronous operations associated with the acceptor.</a>
<a name="ln647">  /**</a>
<a name="ln648">   * This function causes all outstanding asynchronous connect, send and receive</a>
<a name="ln649">   * operations to finish immediately, and the handlers for cancelled operations</a>
<a name="ln650">   * will be passed the boost::asio::error::operation_aborted error.</a>
<a name="ln651">   *</a>
<a name="ln652">   * @param ec Set to indicate what error occurred, if any.</a>
<a name="ln653">   */</a>
<a name="ln654">  BOOST_ASIO_SYNC_OP_VOID cancel(boost::system::error_code&amp; ec)</a>
<a name="ln655">  {</a>
<a name="ln656">    this-&gt;get_service().cancel(this-&gt;get_implementation(), ec);</a>
<a name="ln657">    BOOST_ASIO_SYNC_OP_VOID_RETURN(ec);</a>
<a name="ln658">  }</a>
<a name="ln659"> </a>
<a name="ln660">  /// Set an option on the acceptor.</a>
<a name="ln661">  /**</a>
<a name="ln662">   * This function is used to set an option on the acceptor.</a>
<a name="ln663">   *</a>
<a name="ln664">   * @param option The new option value to be set on the acceptor.</a>
<a name="ln665">   *</a>
<a name="ln666">   * @throws boost::system::system_error Thrown on failure.</a>
<a name="ln667">   *</a>
<a name="ln668">   * @sa SettableSocketOption @n</a>
<a name="ln669">   * boost::asio::socket_base::reuse_address</a>
<a name="ln670">   * boost::asio::socket_base::enable_connection_aborted</a>
<a name="ln671">   *</a>
<a name="ln672">   * @par Example</a>
<a name="ln673">   * Setting the SOL_SOCKET/SO_REUSEADDR option:</a>
<a name="ln674">   * @code</a>
<a name="ln675">   * boost::asio::ip::tcp::acceptor acceptor(io_context);</a>
<a name="ln676">   * ...</a>
<a name="ln677">   * boost::asio::ip::tcp::acceptor::reuse_address option(true);</a>
<a name="ln678">   * acceptor.set_option(option);</a>
<a name="ln679">   * @endcode</a>
<a name="ln680">   */</a>
<a name="ln681">  template &lt;typename SettableSocketOption&gt;</a>
<a name="ln682">  void set_option(const SettableSocketOption&amp; option)</a>
<a name="ln683">  {</a>
<a name="ln684">    boost::system::error_code ec;</a>
<a name="ln685">    this-&gt;get_service().set_option(this-&gt;get_implementation(), option, ec);</a>
<a name="ln686">    boost::asio::detail::throw_error(ec, &quot;set_option&quot;);</a>
<a name="ln687">  }</a>
<a name="ln688"> </a>
<a name="ln689">  /// Set an option on the acceptor.</a>
<a name="ln690">  /**</a>
<a name="ln691">   * This function is used to set an option on the acceptor.</a>
<a name="ln692">   *</a>
<a name="ln693">   * @param option The new option value to be set on the acceptor.</a>
<a name="ln694">   *</a>
<a name="ln695">   * @param ec Set to indicate what error occurred, if any.</a>
<a name="ln696">   *</a>
<a name="ln697">   * @sa SettableSocketOption @n</a>
<a name="ln698">   * boost::asio::socket_base::reuse_address</a>
<a name="ln699">   * boost::asio::socket_base::enable_connection_aborted</a>
<a name="ln700">   *</a>
<a name="ln701">   * @par Example</a>
<a name="ln702">   * Setting the SOL_SOCKET/SO_REUSEADDR option:</a>
<a name="ln703">   * @code</a>
<a name="ln704">   * boost::asio::ip::tcp::acceptor acceptor(io_context);</a>
<a name="ln705">   * ...</a>
<a name="ln706">   * boost::asio::ip::tcp::acceptor::reuse_address option(true);</a>
<a name="ln707">   * boost::system::error_code ec;</a>
<a name="ln708">   * acceptor.set_option(option, ec);</a>
<a name="ln709">   * if (ec)</a>
<a name="ln710">   * {</a>
<a name="ln711">   *   // An error occurred.</a>
<a name="ln712">   * }</a>
<a name="ln713">   * @endcode</a>
<a name="ln714">   */</a>
<a name="ln715">  template &lt;typename SettableSocketOption&gt;</a>
<a name="ln716">  BOOST_ASIO_SYNC_OP_VOID set_option(const SettableSocketOption&amp; option,</a>
<a name="ln717">      boost::system::error_code&amp; ec)</a>
<a name="ln718">  {</a>
<a name="ln719">    this-&gt;get_service().set_option(this-&gt;get_implementation(), option, ec);</a>
<a name="ln720">    BOOST_ASIO_SYNC_OP_VOID_RETURN(ec);</a>
<a name="ln721">  }</a>
<a name="ln722"> </a>
<a name="ln723">  /// Get an option from the acceptor.</a>
<a name="ln724">  /**</a>
<a name="ln725">   * This function is used to get the current value of an option on the</a>
<a name="ln726">   * acceptor.</a>
<a name="ln727">   *</a>
<a name="ln728">   * @param option The option value to be obtained from the acceptor.</a>
<a name="ln729">   *</a>
<a name="ln730">   * @throws boost::system::system_error Thrown on failure.</a>
<a name="ln731">   *</a>
<a name="ln732">   * @sa GettableSocketOption @n</a>
<a name="ln733">   * boost::asio::socket_base::reuse_address</a>
<a name="ln734">   *</a>
<a name="ln735">   * @par Example</a>
<a name="ln736">   * Getting the value of the SOL_SOCKET/SO_REUSEADDR option:</a>
<a name="ln737">   * @code</a>
<a name="ln738">   * boost::asio::ip::tcp::acceptor acceptor(io_context);</a>
<a name="ln739">   * ...</a>
<a name="ln740">   * boost::asio::ip::tcp::acceptor::reuse_address option;</a>
<a name="ln741">   * acceptor.get_option(option);</a>
<a name="ln742">   * bool is_set = option.get();</a>
<a name="ln743">   * @endcode</a>
<a name="ln744">   */</a>
<a name="ln745">  template &lt;typename GettableSocketOption&gt;</a>
<a name="ln746">  void get_option(GettableSocketOption&amp; option) const</a>
<a name="ln747">  {</a>
<a name="ln748">    boost::system::error_code ec;</a>
<a name="ln749">    this-&gt;get_service().get_option(this-&gt;get_implementation(), option, ec);</a>
<a name="ln750">    boost::asio::detail::throw_error(ec, &quot;get_option&quot;);</a>
<a name="ln751">  }</a>
<a name="ln752"> </a>
<a name="ln753">  /// Get an option from the acceptor.</a>
<a name="ln754">  /**</a>
<a name="ln755">   * This function is used to get the current value of an option on the</a>
<a name="ln756">   * acceptor.</a>
<a name="ln757">   *</a>
<a name="ln758">   * @param option The option value to be obtained from the acceptor.</a>
<a name="ln759">   *</a>
<a name="ln760">   * @param ec Set to indicate what error occurred, if any.</a>
<a name="ln761">   *</a>
<a name="ln762">   * @sa GettableSocketOption @n</a>
<a name="ln763">   * boost::asio::socket_base::reuse_address</a>
<a name="ln764">   *</a>
<a name="ln765">   * @par Example</a>
<a name="ln766">   * Getting the value of the SOL_SOCKET/SO_REUSEADDR option:</a>
<a name="ln767">   * @code</a>
<a name="ln768">   * boost::asio::ip::tcp::acceptor acceptor(io_context);</a>
<a name="ln769">   * ...</a>
<a name="ln770">   * boost::asio::ip::tcp::acceptor::reuse_address option;</a>
<a name="ln771">   * boost::system::error_code ec;</a>
<a name="ln772">   * acceptor.get_option(option, ec);</a>
<a name="ln773">   * if (ec)</a>
<a name="ln774">   * {</a>
<a name="ln775">   *   // An error occurred.</a>
<a name="ln776">   * }</a>
<a name="ln777">   * bool is_set = option.get();</a>
<a name="ln778">   * @endcode</a>
<a name="ln779">   */</a>
<a name="ln780">  template &lt;typename GettableSocketOption&gt;</a>
<a name="ln781">  BOOST_ASIO_SYNC_OP_VOID get_option(GettableSocketOption&amp; option,</a>
<a name="ln782">      boost::system::error_code&amp; ec) const</a>
<a name="ln783">  {</a>
<a name="ln784">    this-&gt;get_service().get_option(this-&gt;get_implementation(), option, ec);</a>
<a name="ln785">    BOOST_ASIO_SYNC_OP_VOID_RETURN(ec);</a>
<a name="ln786">  }</a>
<a name="ln787"> </a>
<a name="ln788">  /// Perform an IO control command on the acceptor.</a>
<a name="ln789">  /**</a>
<a name="ln790">   * This function is used to execute an IO control command on the acceptor.</a>
<a name="ln791">   *</a>
<a name="ln792">   * @param command The IO control command to be performed on the acceptor.</a>
<a name="ln793">   *</a>
<a name="ln794">   * @throws boost::system::system_error Thrown on failure.</a>
<a name="ln795">   *</a>
<a name="ln796">   * @sa IoControlCommand @n</a>
<a name="ln797">   * boost::asio::socket_base::non_blocking_io</a>
<a name="ln798">   *</a>
<a name="ln799">   * @par Example</a>
<a name="ln800">   * Getting the number of bytes ready to read:</a>
<a name="ln801">   * @code</a>
<a name="ln802">   * boost::asio::ip::tcp::acceptor acceptor(io_context);</a>
<a name="ln803">   * ...</a>
<a name="ln804">   * boost::asio::ip::tcp::acceptor::non_blocking_io command(true);</a>
<a name="ln805">   * socket.io_control(command);</a>
<a name="ln806">   * @endcode</a>
<a name="ln807">   */</a>
<a name="ln808">  template &lt;typename IoControlCommand&gt;</a>
<a name="ln809">  void io_control(IoControlCommand&amp; command)</a>
<a name="ln810">  {</a>
<a name="ln811">    boost::system::error_code ec;</a>
<a name="ln812">    this-&gt;get_service().io_control(this-&gt;get_implementation(), command, ec);</a>
<a name="ln813">    boost::asio::detail::throw_error(ec, &quot;io_control&quot;);</a>
<a name="ln814">  }</a>
<a name="ln815"> </a>
<a name="ln816">  /// Perform an IO control command on the acceptor.</a>
<a name="ln817">  /**</a>
<a name="ln818">   * This function is used to execute an IO control command on the acceptor.</a>
<a name="ln819">   *</a>
<a name="ln820">   * @param command The IO control command to be performed on the acceptor.</a>
<a name="ln821">   *</a>
<a name="ln822">   * @param ec Set to indicate what error occurred, if any.</a>
<a name="ln823">   *</a>
<a name="ln824">   * @sa IoControlCommand @n</a>
<a name="ln825">   * boost::asio::socket_base::non_blocking_io</a>
<a name="ln826">   *</a>
<a name="ln827">   * @par Example</a>
<a name="ln828">   * Getting the number of bytes ready to read:</a>
<a name="ln829">   * @code</a>
<a name="ln830">   * boost::asio::ip::tcp::acceptor acceptor(io_context);</a>
<a name="ln831">   * ...</a>
<a name="ln832">   * boost::asio::ip::tcp::acceptor::non_blocking_io command(true);</a>
<a name="ln833">   * boost::system::error_code ec;</a>
<a name="ln834">   * socket.io_control(command, ec);</a>
<a name="ln835">   * if (ec)</a>
<a name="ln836">   * {</a>
<a name="ln837">   *   // An error occurred.</a>
<a name="ln838">   * }</a>
<a name="ln839">   * @endcode</a>
<a name="ln840">   */</a>
<a name="ln841">  template &lt;typename IoControlCommand&gt;</a>
<a name="ln842">  BOOST_ASIO_SYNC_OP_VOID io_control(IoControlCommand&amp; command,</a>
<a name="ln843">      boost::system::error_code&amp; ec)</a>
<a name="ln844">  {</a>
<a name="ln845">    this-&gt;get_service().io_control(this-&gt;get_implementation(), command, ec);</a>
<a name="ln846">    BOOST_ASIO_SYNC_OP_VOID_RETURN(ec);</a>
<a name="ln847">  }</a>
<a name="ln848"> </a>
<a name="ln849">  /// Gets the non-blocking mode of the acceptor.</a>
<a name="ln850">  /**</a>
<a name="ln851">   * @returns @c true if the acceptor's synchronous operations will fail with</a>
<a name="ln852">   * boost::asio::error::would_block if they are unable to perform the requested</a>
<a name="ln853">   * operation immediately. If @c false, synchronous operations will block</a>
<a name="ln854">   * until complete.</a>
<a name="ln855">   *</a>
<a name="ln856">   * @note The non-blocking mode has no effect on the behaviour of asynchronous</a>
<a name="ln857">   * operations. Asynchronous operations will never fail with the error</a>
<a name="ln858">   * boost::asio::error::would_block.</a>
<a name="ln859">   */</a>
<a name="ln860">  bool non_blocking() const</a>
<a name="ln861">  {</a>
<a name="ln862">    return this-&gt;get_service().non_blocking(this-&gt;get_implementation());</a>
<a name="ln863">  }</a>
<a name="ln864"> </a>
<a name="ln865">  /// Sets the non-blocking mode of the acceptor.</a>
<a name="ln866">  /**</a>
<a name="ln867">   * @param mode If @c true, the acceptor's synchronous operations will fail</a>
<a name="ln868">   * with boost::asio::error::would_block if they are unable to perform the</a>
<a name="ln869">   * requested operation immediately. If @c false, synchronous operations will</a>
<a name="ln870">   * block until complete.</a>
<a name="ln871">   *</a>
<a name="ln872">   * @throws boost::system::system_error Thrown on failure.</a>
<a name="ln873">   *</a>
<a name="ln874">   * @note The non-blocking mode has no effect on the behaviour of asynchronous</a>
<a name="ln875">   * operations. Asynchronous operations will never fail with the error</a>
<a name="ln876">   * boost::asio::error::would_block.</a>
<a name="ln877">   */</a>
<a name="ln878">  void non_blocking(bool mode)</a>
<a name="ln879">  {</a>
<a name="ln880">    boost::system::error_code ec;</a>
<a name="ln881">    this-&gt;get_service().non_blocking(this-&gt;get_implementation(), mode, ec);</a>
<a name="ln882">    boost::asio::detail::throw_error(ec, &quot;non_blocking&quot;);</a>
<a name="ln883">  }</a>
<a name="ln884"> </a>
<a name="ln885">  /// Sets the non-blocking mode of the acceptor.</a>
<a name="ln886">  /**</a>
<a name="ln887">   * @param mode If @c true, the acceptor's synchronous operations will fail</a>
<a name="ln888">   * with boost::asio::error::would_block if they are unable to perform the</a>
<a name="ln889">   * requested operation immediately. If @c false, synchronous operations will</a>
<a name="ln890">   * block until complete.</a>
<a name="ln891">   *</a>
<a name="ln892">   * @param ec Set to indicate what error occurred, if any.</a>
<a name="ln893">   *</a>
<a name="ln894">   * @note The non-blocking mode has no effect on the behaviour of asynchronous</a>
<a name="ln895">   * operations. Asynchronous operations will never fail with the error</a>
<a name="ln896">   * boost::asio::error::would_block.</a>
<a name="ln897">   */</a>
<a name="ln898">  BOOST_ASIO_SYNC_OP_VOID non_blocking(</a>
<a name="ln899">      bool mode, boost::system::error_code&amp; ec)</a>
<a name="ln900">  {</a>
<a name="ln901">    this-&gt;get_service().non_blocking(this-&gt;get_implementation(), mode, ec);</a>
<a name="ln902">    BOOST_ASIO_SYNC_OP_VOID_RETURN(ec);</a>
<a name="ln903">  }</a>
<a name="ln904"> </a>
<a name="ln905">  /// Gets the non-blocking mode of the native acceptor implementation.</a>
<a name="ln906">  /**</a>
<a name="ln907">   * This function is used to retrieve the non-blocking mode of the underlying</a>
<a name="ln908">   * native acceptor. This mode has no effect on the behaviour of the acceptor</a>
<a name="ln909">   * object's synchronous operations.</a>
<a name="ln910">   *</a>
<a name="ln911">   * @returns @c true if the underlying acceptor is in non-blocking mode and</a>
<a name="ln912">   * direct system calls may fail with boost::asio::error::would_block (or the</a>
<a name="ln913">   * equivalent system error).</a>
<a name="ln914">   *</a>
<a name="ln915">   * @note The current non-blocking mode is cached by the acceptor object.</a>
<a name="ln916">   * Consequently, the return value may be incorrect if the non-blocking mode</a>
<a name="ln917">   * was set directly on the native acceptor.</a>
<a name="ln918">   */</a>
<a name="ln919">  bool native_non_blocking() const</a>
<a name="ln920">  {</a>
<a name="ln921">    return this-&gt;get_service().native_non_blocking(this-&gt;get_implementation());</a>
<a name="ln922">  }</a>
<a name="ln923"> </a>
<a name="ln924">  /// Sets the non-blocking mode of the native acceptor implementation.</a>
<a name="ln925">  /**</a>
<a name="ln926">   * This function is used to modify the non-blocking mode of the underlying</a>
<a name="ln927">   * native acceptor. It has no effect on the behaviour of the acceptor object's</a>
<a name="ln928">   * synchronous operations.</a>
<a name="ln929">   *</a>
<a name="ln930">   * @param mode If @c true, the underlying acceptor is put into non-blocking</a>
<a name="ln931">   * mode and direct system calls may fail with boost::asio::error::would_block</a>
<a name="ln932">   * (or the equivalent system error).</a>
<a name="ln933">   *</a>
<a name="ln934">   * @throws boost::system::system_error Thrown on failure. If the @c mode is</a>
<a name="ln935">   * @c false, but the current value of @c non_blocking() is @c true, this</a>
<a name="ln936">   * function fails with boost::asio::error::invalid_argument, as the</a>
<a name="ln937">   * combination does not make sense.</a>
<a name="ln938">   */</a>
<a name="ln939">  void native_non_blocking(bool mode)</a>
<a name="ln940">  {</a>
<a name="ln941">    boost::system::error_code ec;</a>
<a name="ln942">    this-&gt;get_service().native_non_blocking(</a>
<a name="ln943">        this-&gt;get_implementation(), mode, ec);</a>
<a name="ln944">    boost::asio::detail::throw_error(ec, &quot;native_non_blocking&quot;);</a>
<a name="ln945">  }</a>
<a name="ln946"> </a>
<a name="ln947">  /// Sets the non-blocking mode of the native acceptor implementation.</a>
<a name="ln948">  /**</a>
<a name="ln949">   * This function is used to modify the non-blocking mode of the underlying</a>
<a name="ln950">   * native acceptor. It has no effect on the behaviour of the acceptor object's</a>
<a name="ln951">   * synchronous operations.</a>
<a name="ln952">   *</a>
<a name="ln953">   * @param mode If @c true, the underlying acceptor is put into non-blocking</a>
<a name="ln954">   * mode and direct system calls may fail with boost::asio::error::would_block</a>
<a name="ln955">   * (or the equivalent system error).</a>
<a name="ln956">   *</a>
<a name="ln957">   * @param ec Set to indicate what error occurred, if any. If the @c mode is</a>
<a name="ln958">   * @c false, but the current value of @c non_blocking() is @c true, this</a>
<a name="ln959">   * function fails with boost::asio::error::invalid_argument, as the</a>
<a name="ln960">   * combination does not make sense.</a>
<a name="ln961">   */</a>
<a name="ln962">  BOOST_ASIO_SYNC_OP_VOID native_non_blocking(</a>
<a name="ln963">      bool mode, boost::system::error_code&amp; ec)</a>
<a name="ln964">  {</a>
<a name="ln965">    this-&gt;get_service().native_non_blocking(</a>
<a name="ln966">        this-&gt;get_implementation(), mode, ec);</a>
<a name="ln967">    BOOST_ASIO_SYNC_OP_VOID_RETURN(ec);</a>
<a name="ln968">  }</a>
<a name="ln969"> </a>
<a name="ln970">  /// Get the local endpoint of the acceptor.</a>
<a name="ln971">  /**</a>
<a name="ln972">   * This function is used to obtain the locally bound endpoint of the acceptor.</a>
<a name="ln973">   *</a>
<a name="ln974">   * @returns An object that represents the local endpoint of the acceptor.</a>
<a name="ln975">   *</a>
<a name="ln976">   * @throws boost::system::system_error Thrown on failure.</a>
<a name="ln977">   *</a>
<a name="ln978">   * @par Example</a>
<a name="ln979">   * @code</a>
<a name="ln980">   * boost::asio::ip::tcp::acceptor acceptor(io_context);</a>
<a name="ln981">   * ...</a>
<a name="ln982">   * boost::asio::ip::tcp::endpoint endpoint = acceptor.local_endpoint();</a>
<a name="ln983">   * @endcode</a>
<a name="ln984">   */</a>
<a name="ln985">  endpoint_type local_endpoint() const</a>
<a name="ln986">  {</a>
<a name="ln987">    boost::system::error_code ec;</a>
<a name="ln988">    endpoint_type ep = this-&gt;get_service().local_endpoint(</a>
<a name="ln989">        this-&gt;get_implementation(), ec);</a>
<a name="ln990">    boost::asio::detail::throw_error(ec, &quot;local_endpoint&quot;);</a>
<a name="ln991">    return ep;</a>
<a name="ln992">  }</a>
<a name="ln993"> </a>
<a name="ln994">  /// Get the local endpoint of the acceptor.</a>
<a name="ln995">  /**</a>
<a name="ln996">   * This function is used to obtain the locally bound endpoint of the acceptor.</a>
<a name="ln997">   *</a>
<a name="ln998">   * @param ec Set to indicate what error occurred, if any.</a>
<a name="ln999">   *</a>
<a name="ln1000">   * @returns An object that represents the local endpoint of the acceptor.</a>
<a name="ln1001">   * Returns a default-constructed endpoint object if an error occurred and the</a>
<a name="ln1002">   * error handler did not throw an exception.</a>
<a name="ln1003">   *</a>
<a name="ln1004">   * @par Example</a>
<a name="ln1005">   * @code</a>
<a name="ln1006">   * boost::asio::ip::tcp::acceptor acceptor(io_context);</a>
<a name="ln1007">   * ...</a>
<a name="ln1008">   * boost::system::error_code ec;</a>
<a name="ln1009">   * boost::asio::ip::tcp::endpoint endpoint = acceptor.local_endpoint(ec);</a>
<a name="ln1010">   * if (ec)</a>
<a name="ln1011">   * {</a>
<a name="ln1012">   *   // An error occurred.</a>
<a name="ln1013">   * }</a>
<a name="ln1014">   * @endcode</a>
<a name="ln1015">   */</a>
<a name="ln1016">  endpoint_type local_endpoint(boost::system::error_code&amp; ec) const</a>
<a name="ln1017">  {</a>
<a name="ln1018">    return this-&gt;get_service().local_endpoint(this-&gt;get_implementation(), ec);</a>
<a name="ln1019">  }</a>
<a name="ln1020"> </a>
<a name="ln1021">  /// Wait for the acceptor to become ready to read, ready to write, or to have</a>
<a name="ln1022">  /// pending error conditions.</a>
<a name="ln1023">  /**</a>
<a name="ln1024">   * This function is used to perform a blocking wait for an acceptor to enter</a>
<a name="ln1025">   * a ready to read, write or error condition state.</a>
<a name="ln1026">   *</a>
<a name="ln1027">   * @param w Specifies the desired acceptor state.</a>
<a name="ln1028">   *</a>
<a name="ln1029">   * @par Example</a>
<a name="ln1030">   * Waiting for an acceptor to become readable.</a>
<a name="ln1031">   * @code</a>
<a name="ln1032">   * boost::asio::ip::tcp::acceptor acceptor(io_context);</a>
<a name="ln1033">   * ...</a>
<a name="ln1034">   * acceptor.wait(boost::asio::ip::tcp::acceptor::wait_read);</a>
<a name="ln1035">   * @endcode</a>
<a name="ln1036">   */</a>
<a name="ln1037">  void wait(wait_type w)</a>
<a name="ln1038">  {</a>
<a name="ln1039">    boost::system::error_code ec;</a>
<a name="ln1040">    this-&gt;get_service().wait(this-&gt;get_implementation(), w, ec);</a>
<a name="ln1041">    boost::asio::detail::throw_error(ec, &quot;wait&quot;);</a>
<a name="ln1042">  }</a>
<a name="ln1043"> </a>
<a name="ln1044">  /// Wait for the acceptor to become ready to read, ready to write, or to have</a>
<a name="ln1045">  /// pending error conditions.</a>
<a name="ln1046">  /**</a>
<a name="ln1047">   * This function is used to perform a blocking wait for an acceptor to enter</a>
<a name="ln1048">   * a ready to read, write or error condition state.</a>
<a name="ln1049">   *</a>
<a name="ln1050">   * @param w Specifies the desired acceptor state.</a>
<a name="ln1051">   *</a>
<a name="ln1052">   * @param ec Set to indicate what error occurred, if any.</a>
<a name="ln1053">   *</a>
<a name="ln1054">   * @par Example</a>
<a name="ln1055">   * Waiting for an acceptor to become readable.</a>
<a name="ln1056">   * @code</a>
<a name="ln1057">   * boost::asio::ip::tcp::acceptor acceptor(io_context);</a>
<a name="ln1058">   * ...</a>
<a name="ln1059">   * boost::system::error_code ec;</a>
<a name="ln1060">   * acceptor.wait(boost::asio::ip::tcp::acceptor::wait_read, ec);</a>
<a name="ln1061">   * @endcode</a>
<a name="ln1062">   */</a>
<a name="ln1063">  BOOST_ASIO_SYNC_OP_VOID wait(wait_type w, boost::system::error_code&amp; ec)</a>
<a name="ln1064">  {</a>
<a name="ln1065">    this-&gt;get_service().wait(this-&gt;get_implementation(), w, ec);</a>
<a name="ln1066">    BOOST_ASIO_SYNC_OP_VOID_RETURN(ec);</a>
<a name="ln1067">  }</a>
<a name="ln1068"> </a>
<a name="ln1069">  /// Asynchronously wait for the acceptor to become ready to read, ready to</a>
<a name="ln1070">  /// write, or to have pending error conditions.</a>
<a name="ln1071">  /**</a>
<a name="ln1072">   * This function is used to perform an asynchronous wait for an acceptor to</a>
<a name="ln1073">   * enter a ready to read, write or error condition state.</a>
<a name="ln1074">   *</a>
<a name="ln1075">   * @param w Specifies the desired acceptor state.</a>
<a name="ln1076">   *</a>
<a name="ln1077">   * @param handler The handler to be called when the wait operation completes.</a>
<a name="ln1078">   * Copies will be made of the handler as required. The function signature of</a>
<a name="ln1079">   * the handler must be:</a>
<a name="ln1080">   * @code void handler(</a>
<a name="ln1081">   *   const boost::system::error_code&amp; error // Result of operation</a>
<a name="ln1082">   * ); @endcode</a>
<a name="ln1083">   * Regardless of whether the asynchronous operation completes immediately or</a>
<a name="ln1084">   * not, the handler will not be invoked from within this function. Invocation</a>
<a name="ln1085">   * of the handler will be performed in a manner equivalent to using</a>
<a name="ln1086">   * boost::asio::io_context::post().</a>
<a name="ln1087">   *</a>
<a name="ln1088">   * @par Example</a>
<a name="ln1089">   * @code</a>
<a name="ln1090">   * void wait_handler(const boost::system::error_code&amp; error)</a>
<a name="ln1091">   * {</a>
<a name="ln1092">   *   if (!error)</a>
<a name="ln1093">   *   {</a>
<a name="ln1094">   *     // Wait succeeded.</a>
<a name="ln1095">   *   }</a>
<a name="ln1096">   * }</a>
<a name="ln1097">   *</a>
<a name="ln1098">   * ...</a>
<a name="ln1099">   *</a>
<a name="ln1100">   * boost::asio::ip::tcp::acceptor acceptor(io_context);</a>
<a name="ln1101">   * ...</a>
<a name="ln1102">   * acceptor.async_wait(</a>
<a name="ln1103">   *     boost::asio::ip::tcp::acceptor::wait_read,</a>
<a name="ln1104">   *     wait_handler);</a>
<a name="ln1105">   * @endcode</a>
<a name="ln1106">   */</a>
<a name="ln1107">  template &lt;typename WaitHandler&gt;</a>
<a name="ln1108">  BOOST_ASIO_INITFN_RESULT_TYPE(WaitHandler,</a>
<a name="ln1109">      void (boost::system::error_code))</a>
<a name="ln1110">  async_wait(wait_type w, BOOST_ASIO_MOVE_ARG(WaitHandler) handler)</a>
<a name="ln1111">  {</a>
<a name="ln1112">    // If you get an error on the following line it means that your handler does</a>
<a name="ln1113">    // not meet the documented type requirements for a WaitHandler.</a>
<a name="ln1114">    BOOST_ASIO_WAIT_HANDLER_CHECK(WaitHandler, handler) type_check;</a>
<a name="ln1115"> </a>
<a name="ln1116">#if defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln1117">    return this-&gt;get_service().async_wait(this-&gt;get_implementation(),</a>
<a name="ln1118">        w, BOOST_ASIO_MOVE_CAST(WaitHandler)(handler));</a>
<a name="ln1119">#else // defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln1120">    async_completion&lt;WaitHandler,</a>
<a name="ln1121">      void (boost::system::error_code)&gt; init(handler);</a>
<a name="ln1122"> </a>
<a name="ln1123">    this-&gt;get_service().async_wait(this-&gt;get_implementation(),</a>
<a name="ln1124">        w, init.completion_handler);</a>
<a name="ln1125"> </a>
<a name="ln1126">    return init.result.get();</a>
<a name="ln1127">#endif // defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln1128">  }</a>
<a name="ln1129"> </a>
<a name="ln1130">#if !defined(BOOST_ASIO_NO_EXTENSIONS)</a>
<a name="ln1131">  /// Accept a new connection.</a>
<a name="ln1132">  /**</a>
<a name="ln1133">   * This function is used to accept a new connection from a peer into the</a>
<a name="ln1134">   * given socket. The function call will block until a new connection has been</a>
<a name="ln1135">   * accepted successfully or an error occurs.</a>
<a name="ln1136">   *</a>
<a name="ln1137">   * @param peer The socket into which the new connection will be accepted.</a>
<a name="ln1138">   *</a>
<a name="ln1139">   * @throws boost::system::system_error Thrown on failure.</a>
<a name="ln1140">   *</a>
<a name="ln1141">   * @par Example</a>
<a name="ln1142">   * @code</a>
<a name="ln1143">   * boost::asio::ip::tcp::acceptor acceptor(io_context);</a>
<a name="ln1144">   * ...</a>
<a name="ln1145">   * boost::asio::ip::tcp::socket socket(io_context);</a>
<a name="ln1146">   * acceptor.accept(socket);</a>
<a name="ln1147">   * @endcode</a>
<a name="ln1148">   */</a>
<a name="ln1149">#if defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln1150">  template &lt;typename Protocol1, typename SocketService&gt;</a>
<a name="ln1151">  void accept(basic_socket&lt;Protocol1, SocketService&gt;&amp; peer,</a>
<a name="ln1152">      typename enable_if&lt;is_convertible&lt;Protocol, Protocol1&gt;::value&gt;::type* = 0)</a>
<a name="ln1153">#else // defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln1154">  template &lt;typename Protocol1&gt;</a>
<a name="ln1155">  void accept(basic_socket&lt;Protocol1&gt;&amp; peer,</a>
<a name="ln1156">      typename enable_if&lt;is_convertible&lt;Protocol, Protocol1&gt;::value&gt;::type* = 0)</a>
<a name="ln1157">#endif // defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln1158">  {</a>
<a name="ln1159">    boost::system::error_code ec;</a>
<a name="ln1160">    this-&gt;get_service().accept(this-&gt;get_implementation(),</a>
<a name="ln1161">        peer, static_cast&lt;endpoint_type*&gt;(0), ec);</a>
<a name="ln1162">    boost::asio::detail::throw_error(ec, &quot;accept&quot;);</a>
<a name="ln1163">  }</a>
<a name="ln1164"> </a>
<a name="ln1165">  /// Accept a new connection.</a>
<a name="ln1166">  /**</a>
<a name="ln1167">   * This function is used to accept a new connection from a peer into the</a>
<a name="ln1168">   * given socket. The function call will block until a new connection has been</a>
<a name="ln1169">   * accepted successfully or an error occurs.</a>
<a name="ln1170">   *</a>
<a name="ln1171">   * @param peer The socket into which the new connection will be accepted.</a>
<a name="ln1172">   *</a>
<a name="ln1173">   * @param ec Set to indicate what error occurred, if any.</a>
<a name="ln1174">   *</a>
<a name="ln1175">   * @par Example</a>
<a name="ln1176">   * @code</a>
<a name="ln1177">   * boost::asio::ip::tcp::acceptor acceptor(io_context);</a>
<a name="ln1178">   * ...</a>
<a name="ln1179">   * boost::asio::ip::tcp::socket socket(io_context);</a>
<a name="ln1180">   * boost::system::error_code ec;</a>
<a name="ln1181">   * acceptor.accept(socket, ec);</a>
<a name="ln1182">   * if (ec)</a>
<a name="ln1183">   * {</a>
<a name="ln1184">   *   // An error occurred.</a>
<a name="ln1185">   * }</a>
<a name="ln1186">   * @endcode</a>
<a name="ln1187">   */</a>
<a name="ln1188">#if defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln1189">  template &lt;typename Protocol1, typename SocketService&gt;</a>
<a name="ln1190">  BOOST_ASIO_SYNC_OP_VOID accept(</a>
<a name="ln1191">      basic_socket&lt;Protocol1, SocketService&gt;&amp; peer,</a>
<a name="ln1192">      boost::system::error_code&amp; ec,</a>
<a name="ln1193">      typename enable_if&lt;is_convertible&lt;Protocol, Protocol1&gt;::value&gt;::type* = 0)</a>
<a name="ln1194">#else // defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln1195">  template &lt;typename Protocol1&gt;</a>
<a name="ln1196">  BOOST_ASIO_SYNC_OP_VOID accept(</a>
<a name="ln1197">      basic_socket&lt;Protocol1&gt;&amp; peer, boost::system::error_code&amp; ec,</a>
<a name="ln1198">      typename enable_if&lt;is_convertible&lt;Protocol, Protocol1&gt;::value&gt;::type* = 0)</a>
<a name="ln1199">#endif // defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln1200">  {</a>
<a name="ln1201">    this-&gt;get_service().accept(this-&gt;get_implementation(),</a>
<a name="ln1202">        peer, static_cast&lt;endpoint_type*&gt;(0), ec);</a>
<a name="ln1203">    BOOST_ASIO_SYNC_OP_VOID_RETURN(ec);</a>
<a name="ln1204">  }</a>
<a name="ln1205"> </a>
<a name="ln1206">  /// Start an asynchronous accept.</a>
<a name="ln1207">  /**</a>
<a name="ln1208">   * This function is used to asynchronously accept a new connection into a</a>
<a name="ln1209">   * socket. The function call always returns immediately.</a>
<a name="ln1210">   *</a>
<a name="ln1211">   * @param peer The socket into which the new connection will be accepted.</a>
<a name="ln1212">   * Ownership of the peer object is retained by the caller, which must</a>
<a name="ln1213">   * guarantee that it is valid until the handler is called.</a>
<a name="ln1214">   *</a>
<a name="ln1215">   * @param handler The handler to be called when the accept operation</a>
<a name="ln1216">   * completes. Copies will be made of the handler as required. The function</a>
<a name="ln1217">   * signature of the handler must be:</a>
<a name="ln1218">   * @code void handler(</a>
<a name="ln1219">   *   const boost::system::error_code&amp; error // Result of operation.</a>
<a name="ln1220">   * ); @endcode</a>
<a name="ln1221">   * Regardless of whether the asynchronous operation completes immediately or</a>
<a name="ln1222">   * not, the handler will not be invoked from within this function. Invocation</a>
<a name="ln1223">   * of the handler will be performed in a manner equivalent to using</a>
<a name="ln1224">   * boost::asio::io_context::post().</a>
<a name="ln1225">   *</a>
<a name="ln1226">   * @par Example</a>
<a name="ln1227">   * @code</a>
<a name="ln1228">   * void accept_handler(const boost::system::error_code&amp; error)</a>
<a name="ln1229">   * {</a>
<a name="ln1230">   *   if (!error)</a>
<a name="ln1231">   *   {</a>
<a name="ln1232">   *     // Accept succeeded.</a>
<a name="ln1233">   *   }</a>
<a name="ln1234">   * }</a>
<a name="ln1235">   *</a>
<a name="ln1236">   * ...</a>
<a name="ln1237">   *</a>
<a name="ln1238">   * boost::asio::ip::tcp::acceptor acceptor(io_context);</a>
<a name="ln1239">   * ...</a>
<a name="ln1240">   * boost::asio::ip::tcp::socket socket(io_context);</a>
<a name="ln1241">   * acceptor.async_accept(socket, accept_handler);</a>
<a name="ln1242">   * @endcode</a>
<a name="ln1243">   */</a>
<a name="ln1244">#if defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln1245">  template &lt;typename Protocol1, typename SocketService, typename AcceptHandler&gt;</a>
<a name="ln1246">  BOOST_ASIO_INITFN_RESULT_TYPE(AcceptHandler,</a>
<a name="ln1247">      void (boost::system::error_code))</a>
<a name="ln1248">  async_accept(basic_socket&lt;Protocol1, SocketService&gt;&amp; peer,</a>
<a name="ln1249">      BOOST_ASIO_MOVE_ARG(AcceptHandler) handler,</a>
<a name="ln1250">      typename enable_if&lt;is_convertible&lt;Protocol, Protocol1&gt;::value&gt;::type* = 0)</a>
<a name="ln1251">#else // defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln1252">  template &lt;typename Protocol1, typename AcceptHandler&gt;</a>
<a name="ln1253">  BOOST_ASIO_INITFN_RESULT_TYPE(AcceptHandler,</a>
<a name="ln1254">      void (boost::system::error_code))</a>
<a name="ln1255">  async_accept(basic_socket&lt;Protocol1&gt;&amp; peer,</a>
<a name="ln1256">      BOOST_ASIO_MOVE_ARG(AcceptHandler) handler,</a>
<a name="ln1257">      typename enable_if&lt;is_convertible&lt;Protocol, Protocol1&gt;::value&gt;::type* = 0)</a>
<a name="ln1258">#endif // defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln1259">  {</a>
<a name="ln1260">    // If you get an error on the following line it means that your handler does</a>
<a name="ln1261">    // not meet the documented type requirements for a AcceptHandler.</a>
<a name="ln1262">    BOOST_ASIO_ACCEPT_HANDLER_CHECK(AcceptHandler, handler) type_check;</a>
<a name="ln1263"> </a>
<a name="ln1264">#if defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln1265">    return this-&gt;get_service().async_accept(this-&gt;get_implementation(),</a>
<a name="ln1266">        peer, static_cast&lt;endpoint_type*&gt;(0),</a>
<a name="ln1267">        BOOST_ASIO_MOVE_CAST(AcceptHandler)(handler));</a>
<a name="ln1268">#else // defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln1269">    async_completion&lt;AcceptHandler,</a>
<a name="ln1270">      void (boost::system::error_code)&gt; init(handler);</a>
<a name="ln1271"> </a>
<a name="ln1272">    this-&gt;get_service().async_accept(this-&gt;get_implementation(),</a>
<a name="ln1273">        peer, static_cast&lt;endpoint_type*&gt;(0), init.completion_handler);</a>
<a name="ln1274"> </a>
<a name="ln1275">    return init.result.get();</a>
<a name="ln1276">#endif // defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln1277">  }</a>
<a name="ln1278"> </a>
<a name="ln1279">  /// Accept a new connection and obtain the endpoint of the peer</a>
<a name="ln1280">  /**</a>
<a name="ln1281">   * This function is used to accept a new connection from a peer into the</a>
<a name="ln1282">   * given socket, and additionally provide the endpoint of the remote peer.</a>
<a name="ln1283">   * The function call will block until a new connection has been accepted</a>
<a name="ln1284">   * successfully or an error occurs.</a>
<a name="ln1285">   *</a>
<a name="ln1286">   * @param peer The socket into which the new connection will be accepted.</a>
<a name="ln1287">   *</a>
<a name="ln1288">   * @param peer_endpoint An endpoint object which will receive the endpoint of</a>
<a name="ln1289">   * the remote peer.</a>
<a name="ln1290">   *</a>
<a name="ln1291">   * @throws boost::system::system_error Thrown on failure.</a>
<a name="ln1292">   *</a>
<a name="ln1293">   * @par Example</a>
<a name="ln1294">   * @code</a>
<a name="ln1295">   * boost::asio::ip::tcp::acceptor acceptor(io_context);</a>
<a name="ln1296">   * ...</a>
<a name="ln1297">   * boost::asio::ip::tcp::socket socket(io_context);</a>
<a name="ln1298">   * boost::asio::ip::tcp::endpoint endpoint;</a>
<a name="ln1299">   * acceptor.accept(socket, endpoint);</a>
<a name="ln1300">   * @endcode</a>
<a name="ln1301">   */</a>
<a name="ln1302">#if defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln1303">  template &lt;typename SocketService&gt;</a>
<a name="ln1304">  void accept(basic_socket&lt;protocol_type, SocketService&gt;&amp; peer,</a>
<a name="ln1305">      endpoint_type&amp; peer_endpoint)</a>
<a name="ln1306">#else // defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln1307">  void accept(basic_socket&lt;protocol_type&gt;&amp; peer, endpoint_type&amp; peer_endpoint)</a>
<a name="ln1308">#endif // defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln1309">  {</a>
<a name="ln1310">    boost::system::error_code ec;</a>
<a name="ln1311">    this-&gt;get_service().accept(this-&gt;get_implementation(),</a>
<a name="ln1312">        peer, &amp;peer_endpoint, ec);</a>
<a name="ln1313">    boost::asio::detail::throw_error(ec, &quot;accept&quot;);</a>
<a name="ln1314">  }</a>
<a name="ln1315"> </a>
<a name="ln1316">  /// Accept a new connection and obtain the endpoint of the peer</a>
<a name="ln1317">  /**</a>
<a name="ln1318">   * This function is used to accept a new connection from a peer into the</a>
<a name="ln1319">   * given socket, and additionally provide the endpoint of the remote peer.</a>
<a name="ln1320">   * The function call will block until a new connection has been accepted</a>
<a name="ln1321">   * successfully or an error occurs.</a>
<a name="ln1322">   *</a>
<a name="ln1323">   * @param peer The socket into which the new connection will be accepted.</a>
<a name="ln1324">   *</a>
<a name="ln1325">   * @param peer_endpoint An endpoint object which will receive the endpoint of</a>
<a name="ln1326">   * the remote peer.</a>
<a name="ln1327">   *</a>
<a name="ln1328">   * @param ec Set to indicate what error occurred, if any.</a>
<a name="ln1329">   *</a>
<a name="ln1330">   * @par Example</a>
<a name="ln1331">   * @code</a>
<a name="ln1332">   * boost::asio::ip::tcp::acceptor acceptor(io_context);</a>
<a name="ln1333">   * ...</a>
<a name="ln1334">   * boost::asio::ip::tcp::socket socket(io_context);</a>
<a name="ln1335">   * boost::asio::ip::tcp::endpoint endpoint;</a>
<a name="ln1336">   * boost::system::error_code ec;</a>
<a name="ln1337">   * acceptor.accept(socket, endpoint, ec);</a>
<a name="ln1338">   * if (ec)</a>
<a name="ln1339">   * {</a>
<a name="ln1340">   *   // An error occurred.</a>
<a name="ln1341">   * }</a>
<a name="ln1342">   * @endcode</a>
<a name="ln1343">   */</a>
<a name="ln1344">#if defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln1345">  template &lt;typename SocketService&gt;</a>
<a name="ln1346">  BOOST_ASIO_SYNC_OP_VOID accept(</a>
<a name="ln1347">      basic_socket&lt;protocol_type, SocketService&gt;&amp; peer,</a>
<a name="ln1348">      endpoint_type&amp; peer_endpoint, boost::system::error_code&amp; ec)</a>
<a name="ln1349">#else // defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln1350">  BOOST_ASIO_SYNC_OP_VOID accept(basic_socket&lt;protocol_type&gt;&amp; peer,</a>
<a name="ln1351">      endpoint_type&amp; peer_endpoint, boost::system::error_code&amp; ec)</a>
<a name="ln1352">#endif // defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln1353">  {</a>
<a name="ln1354">    this-&gt;get_service().accept(</a>
<a name="ln1355">        this-&gt;get_implementation(), peer, &amp;peer_endpoint, ec);</a>
<a name="ln1356">    BOOST_ASIO_SYNC_OP_VOID_RETURN(ec);</a>
<a name="ln1357">  }</a>
<a name="ln1358"> </a>
<a name="ln1359">  /// Start an asynchronous accept.</a>
<a name="ln1360">  /**</a>
<a name="ln1361">   * This function is used to asynchronously accept a new connection into a</a>
<a name="ln1362">   * socket, and additionally obtain the endpoint of the remote peer. The</a>
<a name="ln1363">   * function call always returns immediately.</a>
<a name="ln1364">   *</a>
<a name="ln1365">   * @param peer The socket into which the new connection will be accepted.</a>
<a name="ln1366">   * Ownership of the peer object is retained by the caller, which must</a>
<a name="ln1367">   * guarantee that it is valid until the handler is called.</a>
<a name="ln1368">   *</a>
<a name="ln1369">   * @param peer_endpoint An endpoint object into which the endpoint of the</a>
<a name="ln1370">   * remote peer will be written. Ownership of the peer_endpoint object is</a>
<a name="ln1371">   * retained by the caller, which must guarantee that it is valid until the</a>
<a name="ln1372">   * handler is called.</a>
<a name="ln1373">   *</a>
<a name="ln1374">   * @param handler The handler to be called when the accept operation</a>
<a name="ln1375">   * completes. Copies will be made of the handler as required. The function</a>
<a name="ln1376">   * signature of the handler must be:</a>
<a name="ln1377">   * @code void handler(</a>
<a name="ln1378">   *   const boost::system::error_code&amp; error // Result of operation.</a>
<a name="ln1379">   * ); @endcode</a>
<a name="ln1380">   * Regardless of whether the asynchronous operation completes immediately or</a>
<a name="ln1381">   * not, the handler will not be invoked from within this function. Invocation</a>
<a name="ln1382">   * of the handler will be performed in a manner equivalent to using</a>
<a name="ln1383">   * boost::asio::io_context::post().</a>
<a name="ln1384">   */</a>
<a name="ln1385">#if defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln1386">  template &lt;typename SocketService, typename AcceptHandler&gt;</a>
<a name="ln1387">  BOOST_ASIO_INITFN_RESULT_TYPE(AcceptHandler,</a>
<a name="ln1388">      void (boost::system::error_code))</a>
<a name="ln1389">  async_accept(basic_socket&lt;protocol_type, SocketService&gt;&amp; peer,</a>
<a name="ln1390">      endpoint_type&amp; peer_endpoint, BOOST_ASIO_MOVE_ARG(AcceptHandler) handler)</a>
<a name="ln1391">#else // defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln1392">  template &lt;typename AcceptHandler&gt;</a>
<a name="ln1393">  BOOST_ASIO_INITFN_RESULT_TYPE(AcceptHandler,</a>
<a name="ln1394">      void (boost::system::error_code))</a>
<a name="ln1395">  async_accept(basic_socket&lt;protocol_type&gt;&amp; peer,</a>
<a name="ln1396">      endpoint_type&amp; peer_endpoint, BOOST_ASIO_MOVE_ARG(AcceptHandler) handler)</a>
<a name="ln1397">#endif // defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln1398">  {</a>
<a name="ln1399">    // If you get an error on the following line it means that your handler does</a>
<a name="ln1400">    // not meet the documented type requirements for a AcceptHandler.</a>
<a name="ln1401">    BOOST_ASIO_ACCEPT_HANDLER_CHECK(AcceptHandler, handler) type_check;</a>
<a name="ln1402"> </a>
<a name="ln1403">#if defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln1404">    return this-&gt;get_service().async_accept(this-&gt;get_implementation(), peer,</a>
<a name="ln1405">        &amp;peer_endpoint, BOOST_ASIO_MOVE_CAST(AcceptHandler)(handler));</a>
<a name="ln1406">#else // defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln1407">    async_completion&lt;AcceptHandler,</a>
<a name="ln1408">      void (boost::system::error_code)&gt; init(handler);</a>
<a name="ln1409"> </a>
<a name="ln1410">    this-&gt;get_service().async_accept(this-&gt;get_implementation(),</a>
<a name="ln1411">        peer, &amp;peer_endpoint, init.completion_handler);</a>
<a name="ln1412"> </a>
<a name="ln1413">    return init.result.get();</a>
<a name="ln1414">#endif // defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln1415">  }</a>
<a name="ln1416">#endif // !defined(BOOST_ASIO_NO_EXTENSIONS)</a>
<a name="ln1417"> </a>
<a name="ln1418">#if defined(BOOST_ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)</a>
<a name="ln1419">  /// Accept a new connection.</a>
<a name="ln1420">  /**</a>
<a name="ln1421">   * This function is used to accept a new connection from a peer. The function</a>
<a name="ln1422">   * call will block until a new connection has been accepted successfully or</a>
<a name="ln1423">   * an error occurs.</a>
<a name="ln1424">   *</a>
<a name="ln1425">   * This overload requires that the Protocol template parameter satisfy the</a>
<a name="ln1426">   * AcceptableProtocol type requirements.</a>
<a name="ln1427">   *</a>
<a name="ln1428">   * @returns A socket object representing the newly accepted connection.</a>
<a name="ln1429">   *</a>
<a name="ln1430">   * @throws boost::system::system_error Thrown on failure.</a>
<a name="ln1431">   *</a>
<a name="ln1432">   * @par Example</a>
<a name="ln1433">   * @code</a>
<a name="ln1434">   * boost::asio::ip::tcp::acceptor acceptor(io_context);</a>
<a name="ln1435">   * ...</a>
<a name="ln1436">   * boost::asio::ip::tcp::socket socket(acceptor.accept());</a>
<a name="ln1437">   * @endcode</a>
<a name="ln1438">   */</a>
<a name="ln1439">  typename Protocol::socket accept()</a>
<a name="ln1440">  {</a>
<a name="ln1441">    boost::system::error_code ec;</a>
<a name="ln1442">    typename Protocol::socket peer(</a>
<a name="ln1443">        this-&gt;get_service().accept(</a>
<a name="ln1444">          this-&gt;get_implementation(), 0, 0, ec));</a>
<a name="ln1445">    boost::asio::detail::throw_error(ec, &quot;accept&quot;);</a>
<a name="ln1446">    return peer;</a>
<a name="ln1447">  }</a>
<a name="ln1448"> </a>
<a name="ln1449">  /// Accept a new connection.</a>
<a name="ln1450">  /**</a>
<a name="ln1451">   * This function is used to accept a new connection from a peer. The function</a>
<a name="ln1452">   * call will block until a new connection has been accepted successfully or</a>
<a name="ln1453">   * an error occurs.</a>
<a name="ln1454">   *</a>
<a name="ln1455">   * This overload requires that the Protocol template parameter satisfy the</a>
<a name="ln1456">   * AcceptableProtocol type requirements.</a>
<a name="ln1457">   *</a>
<a name="ln1458">   * @param ec Set to indicate what error occurred, if any.</a>
<a name="ln1459">   *</a>
<a name="ln1460">   * @returns On success, a socket object representing the newly accepted</a>
<a name="ln1461">   * connection. On error, a socket object where is_open() is false.</a>
<a name="ln1462">   *</a>
<a name="ln1463">   * @par Example</a>
<a name="ln1464">   * @code</a>
<a name="ln1465">   * boost::asio::ip::tcp::acceptor acceptor(io_context);</a>
<a name="ln1466">   * ...</a>
<a name="ln1467">   * boost::asio::ip::tcp::socket socket(acceptor.accept(ec));</a>
<a name="ln1468">   * if (ec)</a>
<a name="ln1469">   * {</a>
<a name="ln1470">   *   // An error occurred.</a>
<a name="ln1471">   * }</a>
<a name="ln1472">   * @endcode</a>
<a name="ln1473">   */</a>
<a name="ln1474">  typename Protocol::socket accept(boost::system::error_code&amp; ec)</a>
<a name="ln1475">  {</a>
<a name="ln1476">    return this-&gt;get_service().accept(this-&gt;get_implementation(), 0, 0, ec);</a>
<a name="ln1477">  }</a>
<a name="ln1478"> </a>
<a name="ln1479">  /// Start an asynchronous accept.</a>
<a name="ln1480">  /**</a>
<a name="ln1481">   * This function is used to asynchronously accept a new connection. The</a>
<a name="ln1482">   * function call always returns immediately.</a>
<a name="ln1483">   *</a>
<a name="ln1484">   * This overload requires that the Protocol template parameter satisfy the</a>
<a name="ln1485">   * AcceptableProtocol type requirements.</a>
<a name="ln1486">   *</a>
<a name="ln1487">   * @param handler The handler to be called when the accept operation</a>
<a name="ln1488">   * completes. Copies will be made of the handler as required. The function</a>
<a name="ln1489">   * signature of the handler must be:</a>
<a name="ln1490">   * @code void handler(</a>
<a name="ln1491">   *   const boost::system::error_code&amp; error, // Result of operation.</a>
<a name="ln1492">   *   typename Protocol::socket peer // On success, the newly accepted socket.</a>
<a name="ln1493">   * ); @endcode</a>
<a name="ln1494">   * Regardless of whether the asynchronous operation completes immediately or</a>
<a name="ln1495">   * not, the handler will not be invoked from within this function. Invocation</a>
<a name="ln1496">   * of the handler will be performed in a manner equivalent to using</a>
<a name="ln1497">   * boost::asio::io_context::post().</a>
<a name="ln1498">   *</a>
<a name="ln1499">   * @par Example</a>
<a name="ln1500">   * @code</a>
<a name="ln1501">   * void accept_handler(const boost::system::error_code&amp; error,</a>
<a name="ln1502">   *     boost::asio::ip::tcp::socket peer)</a>
<a name="ln1503">   * {</a>
<a name="ln1504">   *   if (!error)</a>
<a name="ln1505">   *   {</a>
<a name="ln1506">   *     // Accept succeeded.</a>
<a name="ln1507">   *   }</a>
<a name="ln1508">   * }</a>
<a name="ln1509">   *</a>
<a name="ln1510">   * ...</a>
<a name="ln1511">   *</a>
<a name="ln1512">   * boost::asio::ip::tcp::acceptor acceptor(io_context);</a>
<a name="ln1513">   * ...</a>
<a name="ln1514">   * acceptor.async_accept(accept_handler);</a>
<a name="ln1515">   * @endcode</a>
<a name="ln1516">   */</a>
<a name="ln1517">  template &lt;typename MoveAcceptHandler&gt;</a>
<a name="ln1518">  BOOST_ASIO_INITFN_RESULT_TYPE(MoveAcceptHandler,</a>
<a name="ln1519">      void (boost::system::error_code, typename Protocol::socket))</a>
<a name="ln1520">  async_accept(BOOST_ASIO_MOVE_ARG(MoveAcceptHandler) handler)</a>
<a name="ln1521">  {</a>
<a name="ln1522">    // If you get an error on the following line it means that your handler does</a>
<a name="ln1523">    // not meet the documented type requirements for a MoveAcceptHandler.</a>
<a name="ln1524">    BOOST_ASIO_MOVE_ACCEPT_HANDLER_CHECK(MoveAcceptHandler,</a>
<a name="ln1525">        handler, typename Protocol::socket) type_check;</a>
<a name="ln1526"> </a>
<a name="ln1527">#if defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln1528">    return this-&gt;get_service().async_accept(</a>
<a name="ln1529">        this-&gt;get_implementation(), static_cast&lt;boost::asio::io_context*&gt;(0),</a>
<a name="ln1530">        static_cast&lt;endpoint_type*&gt;(0),</a>
<a name="ln1531">        BOOST_ASIO_MOVE_CAST(MoveAcceptHandler)(handler));</a>
<a name="ln1532">#else // defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln1533">    async_completion&lt;MoveAcceptHandler,</a>
<a name="ln1534">      void (boost::system::error_code,</a>
<a name="ln1535">        typename Protocol::socket)&gt; init(handler);</a>
<a name="ln1536"> </a>
<a name="ln1537">    this-&gt;get_service().async_accept(</a>
<a name="ln1538">        this-&gt;get_implementation(), static_cast&lt;boost::asio::io_context*&gt;(0),</a>
<a name="ln1539">        static_cast&lt;endpoint_type*&gt;(0), init.completion_handler);</a>
<a name="ln1540"> </a>
<a name="ln1541">    return init.result.get();</a>
<a name="ln1542">#endif // defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln1543">  }</a>
<a name="ln1544"> </a>
<a name="ln1545">  /// Accept a new connection.</a>
<a name="ln1546">  /**</a>
<a name="ln1547">   * This function is used to accept a new connection from a peer. The function</a>
<a name="ln1548">   * call will block until a new connection has been accepted successfully or</a>
<a name="ln1549">   * an error occurs.</a>
<a name="ln1550">   *</a>
<a name="ln1551">   * This overload requires that the Protocol template parameter satisfy the</a>
<a name="ln1552">   * AcceptableProtocol type requirements.</a>
<a name="ln1553">   *</a>
<a name="ln1554">   * @param io_context The io_context object to be used for the newly accepted</a>
<a name="ln1555">   * socket.</a>
<a name="ln1556">   *</a>
<a name="ln1557">   * @returns A socket object representing the newly accepted connection.</a>
<a name="ln1558">   *</a>
<a name="ln1559">   * @throws boost::system::system_error Thrown on failure.</a>
<a name="ln1560">   *</a>
<a name="ln1561">   * @par Example</a>
<a name="ln1562">   * @code</a>
<a name="ln1563">   * boost::asio::ip::tcp::acceptor acceptor(io_context);</a>
<a name="ln1564">   * ...</a>
<a name="ln1565">   * boost::asio::ip::tcp::socket socket(acceptor.accept());</a>
<a name="ln1566">   * @endcode</a>
<a name="ln1567">   */</a>
<a name="ln1568">  typename Protocol::socket accept(boost::asio::io_context&amp; io_context)</a>
<a name="ln1569">  {</a>
<a name="ln1570">    boost::system::error_code ec;</a>
<a name="ln1571">    typename Protocol::socket peer(</a>
<a name="ln1572">        this-&gt;get_service().accept(this-&gt;get_implementation(),</a>
<a name="ln1573">          &amp;io_context, static_cast&lt;endpoint_type*&gt;(0), ec));</a>
<a name="ln1574">    boost::asio::detail::throw_error(ec, &quot;accept&quot;);</a>
<a name="ln1575">    return peer;</a>
<a name="ln1576">  }</a>
<a name="ln1577"> </a>
<a name="ln1578">  /// Accept a new connection.</a>
<a name="ln1579">  /**</a>
<a name="ln1580">   * This function is used to accept a new connection from a peer. The function</a>
<a name="ln1581">   * call will block until a new connection has been accepted successfully or</a>
<a name="ln1582">   * an error occurs.</a>
<a name="ln1583">   *</a>
<a name="ln1584">   * This overload requires that the Protocol template parameter satisfy the</a>
<a name="ln1585">   * AcceptableProtocol type requirements.</a>
<a name="ln1586">   *</a>
<a name="ln1587">   * @param io_context The io_context object to be used for the newly accepted</a>
<a name="ln1588">   * socket.</a>
<a name="ln1589">   *</a>
<a name="ln1590">   * @param ec Set to indicate what error occurred, if any.</a>
<a name="ln1591">   *</a>
<a name="ln1592">   * @returns On success, a socket object representing the newly accepted</a>
<a name="ln1593">   * connection. On error, a socket object where is_open() is false.</a>
<a name="ln1594">   *</a>
<a name="ln1595">   * @par Example</a>
<a name="ln1596">   * @code</a>
<a name="ln1597">   * boost::asio::ip::tcp::acceptor acceptor(io_context);</a>
<a name="ln1598">   * ...</a>
<a name="ln1599">   * boost::asio::ip::tcp::socket socket(acceptor.accept(io_context2, ec));</a>
<a name="ln1600">   * if (ec)</a>
<a name="ln1601">   * {</a>
<a name="ln1602">   *   // An error occurred.</a>
<a name="ln1603">   * }</a>
<a name="ln1604">   * @endcode</a>
<a name="ln1605">   */</a>
<a name="ln1606">  typename Protocol::socket accept(</a>
<a name="ln1607">      boost::asio::io_context&amp; io_context, boost::system::error_code&amp; ec)</a>
<a name="ln1608">  {</a>
<a name="ln1609">    return this-&gt;get_service().accept(this-&gt;get_implementation(),</a>
<a name="ln1610">        &amp;io_context, static_cast&lt;endpoint_type*&gt;(0), ec);</a>
<a name="ln1611">  }</a>
<a name="ln1612"> </a>
<a name="ln1613">  /// Start an asynchronous accept.</a>
<a name="ln1614">  /**</a>
<a name="ln1615">   * This function is used to asynchronously accept a new connection. The</a>
<a name="ln1616">   * function call always returns immediately.</a>
<a name="ln1617">   *</a>
<a name="ln1618">   * This overload requires that the Protocol template parameter satisfy the</a>
<a name="ln1619">   * AcceptableProtocol type requirements.</a>
<a name="ln1620">   *</a>
<a name="ln1621">   * @param io_context The io_context object to be used for the newly accepted</a>
<a name="ln1622">   * socket.</a>
<a name="ln1623">   *</a>
<a name="ln1624">   * @param handler The handler to be called when the accept operation</a>
<a name="ln1625">   * completes. Copies will be made of the handler as required. The function</a>
<a name="ln1626">   * signature of the handler must be:</a>
<a name="ln1627">   * @code void handler(</a>
<a name="ln1628">   *   const boost::system::error_code&amp; error, // Result of operation.</a>
<a name="ln1629">   *   typename Protocol::socket peer // On success, the newly accepted socket.</a>
<a name="ln1630">   * ); @endcode</a>
<a name="ln1631">   * Regardless of whether the asynchronous operation completes immediately or</a>
<a name="ln1632">   * not, the handler will not be invoked from within this function. Invocation</a>
<a name="ln1633">   * of the handler will be performed in a manner equivalent to using</a>
<a name="ln1634">   * boost::asio::io_context::post().</a>
<a name="ln1635">   *</a>
<a name="ln1636">   * @par Example</a>
<a name="ln1637">   * @code</a>
<a name="ln1638">   * void accept_handler(const boost::system::error_code&amp; error,</a>
<a name="ln1639">   *     boost::asio::ip::tcp::socket peer)</a>
<a name="ln1640">   * {</a>
<a name="ln1641">   *   if (!error)</a>
<a name="ln1642">   *   {</a>
<a name="ln1643">   *     // Accept succeeded.</a>
<a name="ln1644">   *   }</a>
<a name="ln1645">   * }</a>
<a name="ln1646">   *</a>
<a name="ln1647">   * ...</a>
<a name="ln1648">   *</a>
<a name="ln1649">   * boost::asio::ip::tcp::acceptor acceptor(io_context);</a>
<a name="ln1650">   * ...</a>
<a name="ln1651">   * acceptor.async_accept(io_context2, accept_handler);</a>
<a name="ln1652">   * @endcode</a>
<a name="ln1653">   */</a>
<a name="ln1654">  template &lt;typename MoveAcceptHandler&gt;</a>
<a name="ln1655">  BOOST_ASIO_INITFN_RESULT_TYPE(MoveAcceptHandler,</a>
<a name="ln1656">      void (boost::system::error_code, typename Protocol::socket))</a>
<a name="ln1657">  async_accept(boost::asio::io_context&amp; io_context,</a>
<a name="ln1658">      BOOST_ASIO_MOVE_ARG(MoveAcceptHandler) handler)</a>
<a name="ln1659">  {</a>
<a name="ln1660">    // If you get an error on the following line it means that your handler does</a>
<a name="ln1661">    // not meet the documented type requirements for a MoveAcceptHandler.</a>
<a name="ln1662">    BOOST_ASIO_MOVE_ACCEPT_HANDLER_CHECK(MoveAcceptHandler,</a>
<a name="ln1663">        handler, typename Protocol::socket) type_check;</a>
<a name="ln1664"> </a>
<a name="ln1665">#if defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln1666">    return this-&gt;get_service().async_accept(this-&gt;get_implementation(),</a>
<a name="ln1667">        &amp;io_context, static_cast&lt;endpoint_type*&gt;(0),</a>
<a name="ln1668">        BOOST_ASIO_MOVE_CAST(MoveAcceptHandler)(handler));</a>
<a name="ln1669">#else // defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln1670">    async_completion&lt;MoveAcceptHandler,</a>
<a name="ln1671">      void (boost::system::error_code,</a>
<a name="ln1672">        typename Protocol::socket)&gt; init(handler);</a>
<a name="ln1673"> </a>
<a name="ln1674">    this-&gt;get_service().async_accept(this-&gt;get_implementation(),</a>
<a name="ln1675">        &amp;io_context, static_cast&lt;endpoint_type*&gt;(0), init.completion_handler);</a>
<a name="ln1676"> </a>
<a name="ln1677">    return init.result.get();</a>
<a name="ln1678">#endif // defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln1679">  }</a>
<a name="ln1680"> </a>
<a name="ln1681">  /// Accept a new connection.</a>
<a name="ln1682">  /**</a>
<a name="ln1683">   * This function is used to accept a new connection from a peer. The function</a>
<a name="ln1684">   * call will block until a new connection has been accepted successfully or</a>
<a name="ln1685">   * an error occurs.</a>
<a name="ln1686">   *</a>
<a name="ln1687">   * This overload requires that the Protocol template parameter satisfy the</a>
<a name="ln1688">   * AcceptableProtocol type requirements.</a>
<a name="ln1689">   *</a>
<a name="ln1690">   * @param peer_endpoint An endpoint object into which the endpoint of the</a>
<a name="ln1691">   * remote peer will be written.</a>
<a name="ln1692">   *</a>
<a name="ln1693">   * @returns A socket object representing the newly accepted connection.</a>
<a name="ln1694">   *</a>
<a name="ln1695">   * @throws boost::system::system_error Thrown on failure.</a>
<a name="ln1696">   *</a>
<a name="ln1697">   * @par Example</a>
<a name="ln1698">   * @code</a>
<a name="ln1699">   * boost::asio::ip::tcp::acceptor acceptor(io_context);</a>
<a name="ln1700">   * ...</a>
<a name="ln1701">   * boost::asio::ip::tcp::endpoint endpoint;</a>
<a name="ln1702">   * boost::asio::ip::tcp::socket socket(acceptor.accept(endpoint));</a>
<a name="ln1703">   * @endcode</a>
<a name="ln1704">   */</a>
<a name="ln1705">  typename Protocol::socket accept(endpoint_type&amp; peer_endpoint)</a>
<a name="ln1706">  {</a>
<a name="ln1707">    boost::system::error_code ec;</a>
<a name="ln1708">    typename Protocol::socket peer(</a>
<a name="ln1709">        this-&gt;get_service().accept(this-&gt;get_implementation(),</a>
<a name="ln1710">          static_cast&lt;boost::asio::io_context*&gt;(0), &amp;peer_endpoint, ec));</a>
<a name="ln1711">    boost::asio::detail::throw_error(ec, &quot;accept&quot;);</a>
<a name="ln1712">    return peer;</a>
<a name="ln1713">  }</a>
<a name="ln1714"> </a>
<a name="ln1715">  /// Accept a new connection.</a>
<a name="ln1716">  /**</a>
<a name="ln1717">   * This function is used to accept a new connection from a peer. The function</a>
<a name="ln1718">   * call will block until a new connection has been accepted successfully or</a>
<a name="ln1719">   * an error occurs.</a>
<a name="ln1720">   *</a>
<a name="ln1721">   * This overload requires that the Protocol template parameter satisfy the</a>
<a name="ln1722">   * AcceptableProtocol type requirements.</a>
<a name="ln1723">   *</a>
<a name="ln1724">   * @param peer_endpoint An endpoint object into which the endpoint of the</a>
<a name="ln1725">   * remote peer will be written.</a>
<a name="ln1726">   *</a>
<a name="ln1727">   * @param ec Set to indicate what error occurred, if any.</a>
<a name="ln1728">   *</a>
<a name="ln1729">   * @returns On success, a socket object representing the newly accepted</a>
<a name="ln1730">   * connection. On error, a socket object where is_open() is false.</a>
<a name="ln1731">   *</a>
<a name="ln1732">   * @par Example</a>
<a name="ln1733">   * @code</a>
<a name="ln1734">   * boost::asio::ip::tcp::acceptor acceptor(io_context);</a>
<a name="ln1735">   * ...</a>
<a name="ln1736">   * boost::asio::ip::tcp::endpoint endpoint;</a>
<a name="ln1737">   * boost::asio::ip::tcp::socket socket(acceptor.accept(endpoint, ec));</a>
<a name="ln1738">   * if (ec)</a>
<a name="ln1739">   * {</a>
<a name="ln1740">   *   // An error occurred.</a>
<a name="ln1741">   * }</a>
<a name="ln1742">   * @endcode</a>
<a name="ln1743">   */</a>
<a name="ln1744">  typename Protocol::socket accept(</a>
<a name="ln1745">      endpoint_type&amp; peer_endpoint, boost::system::error_code&amp; ec)</a>
<a name="ln1746">  {</a>
<a name="ln1747">    return this-&gt;get_service().accept(this-&gt;get_implementation(),</a>
<a name="ln1748">        static_cast&lt;boost::asio::io_context*&gt;(0), &amp;peer_endpoint, ec);</a>
<a name="ln1749">  }</a>
<a name="ln1750"> </a>
<a name="ln1751">  /// Start an asynchronous accept.</a>
<a name="ln1752">  /**</a>
<a name="ln1753">   * This function is used to asynchronously accept a new connection. The</a>
<a name="ln1754">   * function call always returns immediately.</a>
<a name="ln1755">   *</a>
<a name="ln1756">   * This overload requires that the Protocol template parameter satisfy the</a>
<a name="ln1757">   * AcceptableProtocol type requirements.</a>
<a name="ln1758">   *</a>
<a name="ln1759">   * @param peer_endpoint An endpoint object into which the endpoint of the</a>
<a name="ln1760">   * remote peer will be written. Ownership of the peer_endpoint object is</a>
<a name="ln1761">   * retained by the caller, which must guarantee that it is valid until the</a>
<a name="ln1762">   * handler is called.</a>
<a name="ln1763">   *</a>
<a name="ln1764">   * @param handler The handler to be called when the accept operation</a>
<a name="ln1765">   * completes. Copies will be made of the handler as required. The function</a>
<a name="ln1766">   * signature of the handler must be:</a>
<a name="ln1767">   * @code void handler(</a>
<a name="ln1768">   *   const boost::system::error_code&amp; error, // Result of operation.</a>
<a name="ln1769">   *   typename Protocol::socket peer // On success, the newly accepted socket.</a>
<a name="ln1770">   * ); @endcode</a>
<a name="ln1771">   * Regardless of whether the asynchronous operation completes immediately or</a>
<a name="ln1772">   * not, the handler will not be invoked from within this function. Invocation</a>
<a name="ln1773">   * of the handler will be performed in a manner equivalent to using</a>
<a name="ln1774">   * boost::asio::io_context::post().</a>
<a name="ln1775">   *</a>
<a name="ln1776">   * @par Example</a>
<a name="ln1777">   * @code</a>
<a name="ln1778">   * void accept_handler(const boost::system::error_code&amp; error,</a>
<a name="ln1779">   *     boost::asio::ip::tcp::socket peer)</a>
<a name="ln1780">   * {</a>
<a name="ln1781">   *   if (!error)</a>
<a name="ln1782">   *   {</a>
<a name="ln1783">   *     // Accept succeeded.</a>
<a name="ln1784">   *   }</a>
<a name="ln1785">   * }</a>
<a name="ln1786">   *</a>
<a name="ln1787">   * ...</a>
<a name="ln1788">   *</a>
<a name="ln1789">   * boost::asio::ip::tcp::acceptor acceptor(io_context);</a>
<a name="ln1790">   * ...</a>
<a name="ln1791">   * boost::asio::ip::tcp::endpoint endpoint;</a>
<a name="ln1792">   * acceptor.async_accept(endpoint, accept_handler);</a>
<a name="ln1793">   * @endcode</a>
<a name="ln1794">   */</a>
<a name="ln1795">  template &lt;typename MoveAcceptHandler&gt;</a>
<a name="ln1796">  BOOST_ASIO_INITFN_RESULT_TYPE(MoveAcceptHandler,</a>
<a name="ln1797">      void (boost::system::error_code, typename Protocol::socket))</a>
<a name="ln1798">  async_accept(endpoint_type&amp; peer_endpoint,</a>
<a name="ln1799">      BOOST_ASIO_MOVE_ARG(MoveAcceptHandler) handler)</a>
<a name="ln1800">  {</a>
<a name="ln1801">    // If you get an error on the following line it means that your handler does</a>
<a name="ln1802">    // not meet the documented type requirements for a MoveAcceptHandler.</a>
<a name="ln1803">    BOOST_ASIO_MOVE_ACCEPT_HANDLER_CHECK(MoveAcceptHandler,</a>
<a name="ln1804">        handler, typename Protocol::socket) type_check;</a>
<a name="ln1805"> </a>
<a name="ln1806">#if defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln1807">    return this-&gt;get_service().async_accept(this-&gt;get_implementation(),</a>
<a name="ln1808">        static_cast&lt;boost::asio::io_context*&gt;(0), &amp;peer_endpoint,</a>
<a name="ln1809">        BOOST_ASIO_MOVE_CAST(MoveAcceptHandler)(handler));</a>
<a name="ln1810">#else // defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln1811">    async_completion&lt;MoveAcceptHandler,</a>
<a name="ln1812">      void (boost::system::error_code,</a>
<a name="ln1813">        typename Protocol::socket)&gt; init(handler);</a>
<a name="ln1814"> </a>
<a name="ln1815">    this-&gt;get_service().async_accept(this-&gt;get_implementation(),</a>
<a name="ln1816">        static_cast&lt;boost::asio::io_context*&gt;(0), &amp;peer_endpoint,</a>
<a name="ln1817">        init.completion_handler);</a>
<a name="ln1818"> </a>
<a name="ln1819">    return init.result.get();</a>
<a name="ln1820">#endif // defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln1821">  }</a>
<a name="ln1822"> </a>
<a name="ln1823">  /// Accept a new connection.</a>
<a name="ln1824">  /**</a>
<a name="ln1825">   * This function is used to accept a new connection from a peer. The function</a>
<a name="ln1826">   * call will block until a new connection has been accepted successfully or</a>
<a name="ln1827">   * an error occurs.</a>
<a name="ln1828">   *</a>
<a name="ln1829">   * This overload requires that the Protocol template parameter satisfy the</a>
<a name="ln1830">   * AcceptableProtocol type requirements.</a>
<a name="ln1831">   *</a>
<a name="ln1832">   * @param io_context The io_context object to be used for the newly accepted</a>
<a name="ln1833">   * socket.</a>
<a name="ln1834">   *</a>
<a name="ln1835">   * @param peer_endpoint An endpoint object into which the endpoint of the</a>
<a name="ln1836">   * remote peer will be written.</a>
<a name="ln1837">   *</a>
<a name="ln1838">   * @returns A socket object representing the newly accepted connection.</a>
<a name="ln1839">   *</a>
<a name="ln1840">   * @throws boost::system::system_error Thrown on failure.</a>
<a name="ln1841">   *</a>
<a name="ln1842">   * @par Example</a>
<a name="ln1843">   * @code</a>
<a name="ln1844">   * boost::asio::ip::tcp::acceptor acceptor(io_context);</a>
<a name="ln1845">   * ...</a>
<a name="ln1846">   * boost::asio::ip::tcp::endpoint endpoint;</a>
<a name="ln1847">   * boost::asio::ip::tcp::socket socket(</a>
<a name="ln1848">   *     acceptor.accept(io_context2, endpoint));</a>
<a name="ln1849">   * @endcode</a>
<a name="ln1850">   */</a>
<a name="ln1851">  typename Protocol::socket accept(</a>
<a name="ln1852">      boost::asio::io_context&amp; io_context, endpoint_type&amp; peer_endpoint)</a>
<a name="ln1853">  {</a>
<a name="ln1854">    boost::system::error_code ec;</a>
<a name="ln1855">    typename Protocol::socket peer(</a>
<a name="ln1856">        this-&gt;get_service().accept(this-&gt;get_implementation(),</a>
<a name="ln1857">          &amp;io_context, &amp;peer_endpoint, ec));</a>
<a name="ln1858">    boost::asio::detail::throw_error(ec, &quot;accept&quot;);</a>
<a name="ln1859">    return peer;</a>
<a name="ln1860">  }</a>
<a name="ln1861"> </a>
<a name="ln1862">  /// Accept a new connection.</a>
<a name="ln1863">  /**</a>
<a name="ln1864">   * This function is used to accept a new connection from a peer. The function</a>
<a name="ln1865">   * call will block until a new connection has been accepted successfully or</a>
<a name="ln1866">   * an error occurs.</a>
<a name="ln1867">   *</a>
<a name="ln1868">   * This overload requires that the Protocol template parameter satisfy the</a>
<a name="ln1869">   * AcceptableProtocol type requirements.</a>
<a name="ln1870">   *</a>
<a name="ln1871">   * @param io_context The io_context object to be used for the newly accepted</a>
<a name="ln1872">   * socket.</a>
<a name="ln1873">   *</a>
<a name="ln1874">   * @param peer_endpoint An endpoint object into which the endpoint of the</a>
<a name="ln1875">   * remote peer will be written.</a>
<a name="ln1876">   *</a>
<a name="ln1877">   * @param ec Set to indicate what error occurred, if any.</a>
<a name="ln1878">   *</a>
<a name="ln1879">   * @returns On success, a socket object representing the newly accepted</a>
<a name="ln1880">   * connection. On error, a socket object where is_open() is false.</a>
<a name="ln1881">   *</a>
<a name="ln1882">   * @par Example</a>
<a name="ln1883">   * @code</a>
<a name="ln1884">   * boost::asio::ip::tcp::acceptor acceptor(io_context);</a>
<a name="ln1885">   * ...</a>
<a name="ln1886">   * boost::asio::ip::tcp::endpoint endpoint;</a>
<a name="ln1887">   * boost::asio::ip::tcp::socket socket(</a>
<a name="ln1888">   *     acceptor.accept(io_context2, endpoint, ec));</a>
<a name="ln1889">   * if (ec)</a>
<a name="ln1890">   * {</a>
<a name="ln1891">   *   // An error occurred.</a>
<a name="ln1892">   * }</a>
<a name="ln1893">   * @endcode</a>
<a name="ln1894">   */</a>
<a name="ln1895">  typename Protocol::socket accept(boost::asio::io_context&amp; io_context,</a>
<a name="ln1896">      endpoint_type&amp; peer_endpoint, boost::system::error_code&amp; ec)</a>
<a name="ln1897">  {</a>
<a name="ln1898">    return this-&gt;get_service().accept(this-&gt;get_implementation(),</a>
<a name="ln1899">        &amp;io_context, &amp;peer_endpoint, ec);</a>
<a name="ln1900">  }</a>
<a name="ln1901"> </a>
<a name="ln1902">  /// Start an asynchronous accept.</a>
<a name="ln1903">  /**</a>
<a name="ln1904">   * This function is used to asynchronously accept a new connection. The</a>
<a name="ln1905">   * function call always returns immediately.</a>
<a name="ln1906">   *</a>
<a name="ln1907">   * This overload requires that the Protocol template parameter satisfy the</a>
<a name="ln1908">   * AcceptableProtocol type requirements.</a>
<a name="ln1909">   *</a>
<a name="ln1910">   * @param io_context The io_context object to be used for the newly accepted</a>
<a name="ln1911">   * socket.</a>
<a name="ln1912">   *</a>
<a name="ln1913">   * @param peer_endpoint An endpoint object into which the endpoint of the</a>
<a name="ln1914">   * remote peer will be written. Ownership of the peer_endpoint object is</a>
<a name="ln1915">   * retained by the caller, which must guarantee that it is valid until the</a>
<a name="ln1916">   * handler is called.</a>
<a name="ln1917">   *</a>
<a name="ln1918">   * @param handler The handler to be called when the accept operation</a>
<a name="ln1919">   * completes. Copies will be made of the handler as required. The function</a>
<a name="ln1920">   * signature of the handler must be:</a>
<a name="ln1921">   * @code void handler(</a>
<a name="ln1922">   *   const boost::system::error_code&amp; error, // Result of operation.</a>
<a name="ln1923">   *   typename Protocol::socket peer // On success, the newly accepted socket.</a>
<a name="ln1924">   * ); @endcode</a>
<a name="ln1925">   * Regardless of whether the asynchronous operation completes immediately or</a>
<a name="ln1926">   * not, the handler will not be invoked from within this function. Invocation</a>
<a name="ln1927">   * of the handler will be performed in a manner equivalent to using</a>
<a name="ln1928">   * boost::asio::io_context::post().</a>
<a name="ln1929">   *</a>
<a name="ln1930">   * @par Example</a>
<a name="ln1931">   * @code</a>
<a name="ln1932">   * void accept_handler(const boost::system::error_code&amp; error,</a>
<a name="ln1933">   *     boost::asio::ip::tcp::socket peer)</a>
<a name="ln1934">   * {</a>
<a name="ln1935">   *   if (!error)</a>
<a name="ln1936">   *   {</a>
<a name="ln1937">   *     // Accept succeeded.</a>
<a name="ln1938">   *   }</a>
<a name="ln1939">   * }</a>
<a name="ln1940">   *</a>
<a name="ln1941">   * ...</a>
<a name="ln1942">   *</a>
<a name="ln1943">   * boost::asio::ip::tcp::acceptor acceptor(io_context);</a>
<a name="ln1944">   * ...</a>
<a name="ln1945">   * boost::asio::ip::tcp::endpoint endpoint;</a>
<a name="ln1946">   * acceptor.async_accept(io_context2, endpoint, accept_handler);</a>
<a name="ln1947">   * @endcode</a>
<a name="ln1948">   */</a>
<a name="ln1949">  template &lt;typename MoveAcceptHandler&gt;</a>
<a name="ln1950">  BOOST_ASIO_INITFN_RESULT_TYPE(MoveAcceptHandler,</a>
<a name="ln1951">      void (boost::system::error_code, typename Protocol::socket))</a>
<a name="ln1952">  async_accept(boost::asio::io_context&amp; io_context,</a>
<a name="ln1953">      endpoint_type&amp; peer_endpoint,</a>
<a name="ln1954">      BOOST_ASIO_MOVE_ARG(MoveAcceptHandler) handler)</a>
<a name="ln1955">  {</a>
<a name="ln1956">    // If you get an error on the following line it means that your handler does</a>
<a name="ln1957">    // not meet the documented type requirements for a MoveAcceptHandler.</a>
<a name="ln1958">    BOOST_ASIO_MOVE_ACCEPT_HANDLER_CHECK(MoveAcceptHandler,</a>
<a name="ln1959">        handler, typename Protocol::socket) type_check;</a>
<a name="ln1960"> </a>
<a name="ln1961">#if defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln1962">    return this-&gt;get_service().async_accept(</a>
<a name="ln1963">        this-&gt;get_implementation(), &amp;io_context, &amp;peer_endpoint,</a>
<a name="ln1964">        BOOST_ASIO_MOVE_CAST(MoveAcceptHandler)(handler));</a>
<a name="ln1965">#else // defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln1966">    async_completion&lt;MoveAcceptHandler,</a>
<a name="ln1967">      void (boost::system::error_code,</a>
<a name="ln1968">        typename Protocol::socket)&gt; init(handler);</a>
<a name="ln1969"> </a>
<a name="ln1970">    this-&gt;get_service().async_accept(this-&gt;get_implementation(),</a>
<a name="ln1971">        &amp;io_context, &amp;peer_endpoint, init.completion_handler);</a>
<a name="ln1972"> </a>
<a name="ln1973">    return init.result.get();</a>
<a name="ln1974">#endif // defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln1975">  }</a>
<a name="ln1976">#endif // defined(BOOST_ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)</a>
<a name="ln1977">};</a>
<a name="ln1978"> </a>
<a name="ln1979">} // namespace asio</a>
<a name="ln1980">} // namespace boost</a>
<a name="ln1981"> </a>
<a name="ln1982">#include &lt;boost/asio/detail/pop_options.hpp&gt;</a>
<a name="ln1983"> </a>
<a name="ln1984">#if !defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln1985"># undef BOOST_ASIO_SVC_T</a>
<a name="ln1986">#endif // !defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln1987"> </a>
<a name="ln1988">#endif // BOOST_ASIO_BASIC_SOCKET_ACCEPTOR_HPP</a>

</code></pre>
<div class="balloon" rel="165"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v779/" target="_blank">V779</a> Unreachable code detected. It is possible that an error is present.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
