
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>pb_util.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Licensed to the Apache Software Foundation (ASF) under one</a>
<a name="ln2">// or more contributor license agreements.  See the NOTICE file</a>
<a name="ln3">// distributed with this work for additional information</a>
<a name="ln4">// regarding copyright ownership.  The ASF licenses this file</a>
<a name="ln5">// to you under the Apache License, Version 2.0 (the</a>
<a name="ln6">// &quot;License&quot;); you may not use this file except in compliance</a>
<a name="ln7">// with the License.  You may obtain a copy of the License at</a>
<a name="ln8">//</a>
<a name="ln9">//   http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln10">//</a>
<a name="ln11">// Unless required by applicable law or agreed to in writing,</a>
<a name="ln12">// software distributed under the License is distributed on an</a>
<a name="ln13">// &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</a>
<a name="ln14">// KIND, either express or implied.  See the License for the</a>
<a name="ln15">// specific language governing permissions and limitations</a>
<a name="ln16">// under the License.</a>
<a name="ln17">//</a>
<a name="ln18">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln19">//</a>
<a name="ln20">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln21">//</a>
<a name="ln22">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln23">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln24">//</a>
<a name="ln25">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln26">//</a>
<a name="ln27">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln28">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln29">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln30">// under the License.</a>
<a name="ln31">//</a>
<a name="ln32">// Some portions copyright (C) 2008, Google, inc.</a>
<a name="ln33">//</a>
<a name="ln34">// Utilities for working with protobufs.</a>
<a name="ln35">// Some of this code is cribbed from the protobuf source,</a>
<a name="ln36">// but modified to work with yb's 'faststring' instead of STL strings.</a>
<a name="ln37"> </a>
<a name="ln38">#include &quot;yb/util/pb_util.h&quot;</a>
<a name="ln39"> </a>
<a name="ln40">#include &lt;deque&gt;</a>
<a name="ln41">#include &lt;memory&gt;</a>
<a name="ln42">#include &lt;string&gt;</a>
<a name="ln43">#include &lt;unordered_set&gt;</a>
<a name="ln44">#include &lt;vector&gt;</a>
<a name="ln45"> </a>
<a name="ln46">#include &lt;glog/logging.h&gt;</a>
<a name="ln47">#include &lt;google/protobuf/descriptor.h&gt;</a>
<a name="ln48">#include &lt;google/protobuf/descriptor.pb.h&gt;</a>
<a name="ln49">#include &lt;google/protobuf/descriptor_database.h&gt;</a>
<a name="ln50">#include &lt;google/protobuf/dynamic_message.h&gt;</a>
<a name="ln51">#include &lt;google/protobuf/io/coded_stream.h&gt;</a>
<a name="ln52">#include &lt;google/protobuf/io/zero_copy_stream.h&gt;</a>
<a name="ln53">#include &lt;google/protobuf/io/zero_copy_stream_impl_lite.h&gt;</a>
<a name="ln54">#include &lt;google/protobuf/message.h&gt;</a>
<a name="ln55">#include &lt;google/protobuf/message_lite.h&gt;</a>
<a name="ln56">#include &lt;google/protobuf/util/message_differencer.h&gt;</a>
<a name="ln57"> </a>
<a name="ln58">#include &quot;yb/gutil/bind.h&quot;</a>
<a name="ln59">#include &quot;yb/gutil/callback.h&quot;</a>
<a name="ln60">#include &quot;yb/gutil/map-util.h&quot;</a>
<a name="ln61">#include &quot;yb/gutil/strings/escaping.h&quot;</a>
<a name="ln62">#include &quot;yb/gutil/strings/fastmem.h&quot;</a>
<a name="ln63">#include &quot;yb/gutil/strings/substitute.h&quot;</a>
<a name="ln64">#include &quot;yb/util/coding-inl.h&quot;</a>
<a name="ln65">#include &quot;yb/util/coding.h&quot;</a>
<a name="ln66">#include &quot;yb/util/crc.h&quot;</a>
<a name="ln67">#include &quot;yb/util/debug/sanitizer_scopes.h&quot;</a>
<a name="ln68">#include &quot;yb/util/debug/trace_event.h&quot;</a>
<a name="ln69">#include &quot;yb/util/env.h&quot;</a>
<a name="ln70">#include &quot;yb/util/env_util.h&quot;</a>
<a name="ln71">#include &quot;yb/util/path_util.h&quot;</a>
<a name="ln72">#include &quot;yb/util/pb_util-internal.h&quot;</a>
<a name="ln73">#include &quot;yb/util/pb_util.pb.h&quot;</a>
<a name="ln74">#include &quot;yb/util/status.h&quot;</a>
<a name="ln75"> </a>
<a name="ln76">using google::protobuf::Descriptor;</a>
<a name="ln77">using google::protobuf::DescriptorPool;</a>
<a name="ln78">using google::protobuf::DynamicMessageFactory;</a>
<a name="ln79">using google::protobuf::FieldDescriptor;</a>
<a name="ln80">using google::protobuf::FileDescriptor;</a>
<a name="ln81">using google::protobuf::FileDescriptorProto;</a>
<a name="ln82">using google::protobuf::FileDescriptorSet;</a>
<a name="ln83">using google::protobuf::io::ArrayInputStream;</a>
<a name="ln84">using google::protobuf::io::CodedInputStream;</a>
<a name="ln85">using google::protobuf::Message;</a>
<a name="ln86">using google::protobuf::MessageLite;</a>
<a name="ln87">using google::protobuf::Reflection;</a>
<a name="ln88">using google::protobuf::SimpleDescriptorDatabase;</a>
<a name="ln89">using yb::crc::Crc;</a>
<a name="ln90">using yb::pb_util::internal::SequentialFileFileInputStream;</a>
<a name="ln91">using yb::pb_util::internal::WritableFileOutputStream;</a>
<a name="ln92">using std::deque;</a>
<a name="ln93">using std::endl;</a>
<a name="ln94">using std::shared_ptr;</a>
<a name="ln95">using std::string;</a>
<a name="ln96">using std::unordered_set;</a>
<a name="ln97">using std::vector;</a>
<a name="ln98">using strings::Substitute;</a>
<a name="ln99">using strings::Utf8SafeCEscape;</a>
<a name="ln100"> </a>
<a name="ln101">static const char* const kTmpTemplateSuffix = &quot;.tmp.XXXXXX&quot;;</a>
<a name="ln102"> </a>
<a name="ln103">// Protobuf container constants.</a>
<a name="ln104">static const int kPBContainerVersion = 1;</a>
<a name="ln105">static const char kPBContainerMagic[] = &quot;yugacntr&quot;;</a>
<a name="ln106">static const int kPBContainerMagicLen = 8;</a>
<a name="ln107">static const int kPBContainerHeaderLen =</a>
<a name="ln108">    // magic number + version</a>
<a name="ln109">    kPBContainerMagicLen + sizeof(uint32_t);</a>
<a name="ln110">static const int kPBContainerChecksumLen = sizeof(uint32_t);</a>
<a name="ln111"> </a>
<a name="ln112">COMPILE_ASSERT((arraysize(kPBContainerMagic) - 1) == kPBContainerMagicLen,</a>
<a name="ln113">               kPBContainerMagic_does_not_match_expected_length);</a>
<a name="ln114"> </a>
<a name="ln115">namespace yb {</a>
<a name="ln116">namespace pb_util {</a>
<a name="ln117"> </a>
<a name="ln118">namespace {</a>
<a name="ln119"> </a>
<a name="ln120">// When serializing, we first compute the byte size, then serialize the message.</a>
<a name="ln121">// If serialization produces a different number of bytes than expected, we</a>
<a name="ln122">// call this function, which crashes.  The problem could be due to a bug in the</a>
<a name="ln123">// protobuf implementation but is more likely caused by concurrent modification</a>
<a name="ln124">// of the message.  This function attempts to distinguish between the two and</a>
<a name="ln125">// provide a useful error message.</a>
<a name="ln126">void ByteSizeConsistencyError(int byte_size_before_serialization,</a>
<a name="ln127">                              int byte_size_after_serialization,</a>
<a name="ln128">                              int bytes_produced_by_serialization) {</a>
<a name="ln129">  CHECK_EQ(byte_size_before_serialization, byte_size_after_serialization)</a>
<a name="ln130">      &lt;&lt; &quot;Protocol message was modified concurrently during serialization.&quot;;</a>
<a name="ln131">  CHECK_EQ(bytes_produced_by_serialization, byte_size_before_serialization)</a>
<a name="ln132">      &lt;&lt; &quot;Byte size calculation and serialization were inconsistent.  This &quot;</a>
<a name="ln133">         &quot;may indicate a bug in protocol buffers or it may be caused by &quot;</a>
<a name="ln134">         &quot;concurrent modification of the message.&quot;;</a>
<a name="ln135">  LOG(FATAL) &lt;&lt; &quot;This shouldn't be called if all the sizes are equal.&quot;;</a>
<a name="ln136">}</a>
<a name="ln137"> </a>
<a name="ln138">string InitializationErrorMessage(const char* action,</a>
<a name="ln139">                                  const MessageLite&amp; message) {</a>
<a name="ln140">  // Note:  We want to avoid depending on strutil in the lite library, otherwise</a>
<a name="ln141">  //   we'd use:</a>
<a name="ln142">  //</a>
<a name="ln143">  // return strings::Substitute(</a>
<a name="ln144">  //   &quot;Can't $0 message of type \&quot;$1\&quot; because it is missing required &quot;</a>
<a name="ln145">  //   &quot;fields: $2&quot;,</a>
<a name="ln146">  //   action, message.GetTypeName(),</a>
<a name="ln147">  //   message.InitializationErrorString());</a>
<a name="ln148"> </a>
<a name="ln149">  string result;</a>
<a name="ln150">  result += &quot;Can't &quot;;</a>
<a name="ln151">  result += action;</a>
<a name="ln152">  result += &quot; message of type \&quot;&quot;;</a>
<a name="ln153">  result += message.GetTypeName();</a>
<a name="ln154">  result += &quot;\&quot; because it is missing required fields: &quot;;</a>
<a name="ln155">  result += message.InitializationErrorString();</a>
<a name="ln156">  return result;</a>
<a name="ln157">}</a>
<a name="ln158"> </a>
<a name="ln159">} // anonymous namespace</a>
<a name="ln160"> </a>
<a name="ln161">bool AppendToString(const MessageLite &amp;msg, faststring *output) {</a>
<a name="ln162">  DCHECK(msg.IsInitialized()) &lt;&lt; InitializationErrorMessage(&quot;serialize&quot;, msg);</a>
<a name="ln163">  return AppendPartialToString(msg, output);</a>
<a name="ln164">}</a>
<a name="ln165"> </a>
<a name="ln166">bool AppendPartialToString(const MessageLite &amp;msg, faststring* output) {</a>
<a name="ln167">  int old_size = output-&gt;size();</a>
<a name="ln168">  int byte_size = msg.ByteSize();</a>
<a name="ln169"> </a>
<a name="ln170">  output-&gt;resize(old_size + byte_size);</a>
<a name="ln171"> </a>
<a name="ln172">  uint8* start = &amp;((*output)[old_size]);</a>
<a name="ln173">  uint8* end = msg.SerializeWithCachedSizesToArray(start);</a>
<a name="ln174">  if (end - start != byte_size) {</a>
<a name="ln175">    ByteSizeConsistencyError(byte_size, msg.ByteSize(), end - start);</a>
<a name="ln176">  }</a>
<a name="ln177">  return true;</a>
<a name="ln178">}</a>
<a name="ln179"> </a>
<a name="ln180">bool SerializeToString(const MessageLite &amp;msg, faststring *output) {</a>
<a name="ln181">  output-&gt;clear();</a>
<a name="ln182">  return AppendToString(msg, output);</a>
<a name="ln183">}</a>
<a name="ln184"> </a>
<a name="ln185">bool ParseFromSequentialFile(MessageLite *msg, SequentialFile *rfile) {</a>
<a name="ln186">  SequentialFileFileInputStream istream(rfile);</a>
<a name="ln187">  return msg-&gt;ParseFromZeroCopyStream(&amp;istream);</a>
<a name="ln188">}</a>
<a name="ln189"> </a>
<a name="ln190">Status ParseFromArray(MessageLite* msg, const uint8_t* data, uint32_t length) {</a>
<a name="ln191">  CodedInputStream in(data, length);</a>
<a name="ln192">  in.SetTotalBytesLimit(511 * 1024 * 1024, -1);</a>
<a name="ln193">  // Parse data into protobuf message</a>
<a name="ln194">  if (!msg-&gt;ParseFromCodedStream(&amp;in)) {</a>
<a name="ln195">    return STATUS(Corruption, &quot;Error parsing msg&quot;, InitializationErrorMessage(&quot;parse&quot;, *msg));</a>
<a name="ln196">  }</a>
<a name="ln197">  return Status::OK();</a>
<a name="ln198">}</a>
<a name="ln199"> </a>
<a name="ln200">Status WritePBToPath(Env* env, const std::string&amp; path,</a>
<a name="ln201">                     const MessageLite&amp; msg,</a>
<a name="ln202">                     SyncMode sync) {</a>
<a name="ln203">  const string tmp_template = path + kTmpTemplateSuffix;</a>
<a name="ln204">  string tmp_path;</a>
<a name="ln205"> </a>
<a name="ln206">  std::unique_ptr&lt;WritableFile&gt; file;</a>
<a name="ln207">  RETURN_NOT_OK(env-&gt;NewTempWritableFile(WritableFileOptions(), tmp_template, &amp;tmp_path, &amp;file));</a>
<a name="ln208">  env_util::ScopedFileDeleter tmp_deleter(env, tmp_path);</a>
<a name="ln209"> </a>
<a name="ln210">  WritableFileOutputStream ostream(file.get());</a>
<a name="ln211">  bool res = msg.SerializeToZeroCopyStream(&amp;ostream);</a>
<a name="ln212">  if (!res || !ostream.Flush()) {</a>
<a name="ln213">    return STATUS(IOError, &quot;Unable to serialize PB to file&quot;);</a>
<a name="ln214">  }</a>
<a name="ln215"> </a>
<a name="ln216">  if (sync == pb_util::SYNC) {</a>
<a name="ln217">    RETURN_NOT_OK_PREPEND(file-&gt;Sync(), &quot;Failed to Sync() &quot; + tmp_path);</a>
<a name="ln218">  }</a>
<a name="ln219">  RETURN_NOT_OK_PREPEND(file-&gt;Close(), &quot;Failed to Close() &quot; + tmp_path);</a>
<a name="ln220">  RETURN_NOT_OK_PREPEND(env-&gt;RenameFile(tmp_path, path), &quot;Failed to rename tmp file to &quot; + path);</a>
<a name="ln221">  tmp_deleter.Cancel();</a>
<a name="ln222">  if (sync == pb_util::SYNC) {</a>
<a name="ln223">    RETURN_NOT_OK_PREPEND(env-&gt;SyncDir(DirName(path)), &quot;Failed to SyncDir() parent of &quot; + path);</a>
<a name="ln224">  }</a>
<a name="ln225">  return Status::OK();</a>
<a name="ln226">}</a>
<a name="ln227"> </a>
<a name="ln228">Status ReadPBFromPath(Env* env, const std::string&amp; path, MessageLite* msg) {</a>
<a name="ln229">  shared_ptr&lt;SequentialFile&gt; rfile;</a>
<a name="ln230">  RETURN_NOT_OK(env_util::OpenFileForSequential(env, path, &amp;rfile));</a>
<a name="ln231">  if (!ParseFromSequentialFile(msg, rfile.get())) {</a>
<a name="ln232">    return STATUS(IOError, &quot;Unable to parse PB from path&quot;, path);</a>
<a name="ln233">  }</a>
<a name="ln234">  return Status::OK();</a>
<a name="ln235">}</a>
<a name="ln236"> </a>
<a name="ln237">static void TruncateString(string* s, int max_len) {</a>
<a name="ln238">  if (s-&gt;size() &gt; max_len) {</a>
<a name="ln239">    s-&gt;resize(max_len);</a>
<a name="ln240">    s-&gt;append(&quot;&lt;truncated&gt;&quot;);</a>
<a name="ln241">  }</a>
<a name="ln242">}</a>
<a name="ln243"> </a>
<a name="ln244">void TruncateFields(Message* message, int max_len) {</a>
<a name="ln245">  const Reflection* reflection = message-&gt;GetReflection();</a>
<a name="ln246">  vector&lt;const FieldDescriptor*&gt; fields;</a>
<a name="ln247">  reflection-&gt;ListFields(*message, &amp;fields);</a>
<a name="ln248">  for (const FieldDescriptor* field : fields) {</a>
<a name="ln249">    if (field-&gt;is_repeated()) {</a>
<a name="ln250">      for (int i = 0; i &lt; reflection-&gt;FieldSize(*message, field); i++) {</a>
<a name="ln251">        switch (field-&gt;cpp_type()) {</a>
<a name="ln252">          case FieldDescriptor::CPPTYPE_STRING: {</a>
<a name="ln253">            const string&amp; s_const = reflection-&gt;GetRepeatedStringReference(*message, field, i,</a>
<a name="ln254">                                                                           nullptr);</a>
<a name="ln255">            TruncateString(const_cast&lt;string*&gt;(&amp;s_const), max_len);</a>
<a name="ln256">            break;</a>
<a name="ln257">          }</a>
<a name="ln258">          case FieldDescriptor::CPPTYPE_MESSAGE: {</a>
<a name="ln259">            TruncateFields(reflection-&gt;MutableRepeatedMessage(message, field, i), max_len);</a>
<a name="ln260">            break;</a>
<a name="ln261">          }</a>
<a name="ln262">          default:</a>
<a name="ln263">            break;</a>
<a name="ln264">        }</a>
<a name="ln265">      }</a>
<a name="ln266">    } else {</a>
<a name="ln267">      switch (field-&gt;cpp_type()) {</a>
<a name="ln268">        case FieldDescriptor::CPPTYPE_STRING: {</a>
<a name="ln269">          const string&amp; s_const = reflection-&gt;GetStringReference(*message, field, nullptr);</a>
<a name="ln270">          TruncateString(const_cast&lt;string*&gt;(&amp;s_const), max_len);</a>
<a name="ln271">          break;</a>
<a name="ln272">        }</a>
<a name="ln273">        case FieldDescriptor::CPPTYPE_MESSAGE: {</a>
<a name="ln274">          TruncateFields(reflection-&gt;MutableMessage(message, field), max_len);</a>
<a name="ln275">          break;</a>
<a name="ln276">        }</a>
<a name="ln277">        default:</a>
<a name="ln278">          break;</a>
<a name="ln279">      }</a>
<a name="ln280">    }</a>
<a name="ln281">  }</a>
<a name="ln282">}</a>
<a name="ln283"> </a>
<a name="ln284">WritablePBContainerFile::WritablePBContainerFile(std::unique_ptr&lt;WritableFile&gt; writer)</a>
<a name="ln285">  : closed_(false),</a>
<a name="ln286">    writer_(std::move(writer)) {</a>
<a name="ln287">}</a>
<a name="ln288"> </a>
<a name="ln289">WritablePBContainerFile::~WritablePBContainerFile() {</a>
<a name="ln290">  WARN_NOT_OK(Close(), &quot;Could not Close() when destroying file&quot;);</a>
<a name="ln291">}</a>
<a name="ln292"> </a>
<a name="ln293">Status WritablePBContainerFile::Init(const Message&amp; msg) {</a>
<a name="ln294">  DCHECK(!closed_);</a>
<a name="ln295"> </a>
<a name="ln296">  faststring buf;</a>
<a name="ln297">  buf.resize(kPBContainerHeaderLen);</a>
<a name="ln298"> </a>
<a name="ln299">  // Serialize the magic.</a>
<a name="ln300">  strings::memcpy_inlined(buf.data(), kPBContainerMagic, kPBContainerMagicLen);</a>
<a name="ln301">  size_t offset = kPBContainerMagicLen;</a>
<a name="ln302"> </a>
<a name="ln303">  // Serialize the version.</a>
<a name="ln304">  InlineEncodeFixed32(buf.data() + offset, kPBContainerVersion);</a>
<a name="ln305">  offset += sizeof(uint32_t);</a>
<a name="ln306">  DCHECK_EQ(kPBContainerHeaderLen, offset)</a>
<a name="ln307">    &lt;&lt; &quot;Serialized unexpected number of total bytes&quot;;</a>
<a name="ln308"> </a>
<a name="ln309">  // Serialize the supplemental header.</a>
<a name="ln310">  ContainerSupHeaderPB sup_header;</a>
<a name="ln311">  PopulateDescriptorSet(msg.GetDescriptor()-&gt;file(),</a>
<a name="ln312">                        sup_header.mutable_protos());</a>
<a name="ln313">  sup_header.set_pb_type(msg.GetTypeName());</a>
<a name="ln314">  RETURN_NOT_OK_PREPEND(AppendMsgToBuffer(sup_header, &amp;buf),</a>
<a name="ln315">                        &quot;Failed to prepare supplemental header for writing&quot;);</a>
<a name="ln316"> </a>
<a name="ln317">  // Write the serialized buffer to the file.</a>
<a name="ln318">  RETURN_NOT_OK_PREPEND(writer_-&gt;Append(buf),</a>
<a name="ln319">                        &quot;Failed to Append() header to file&quot;);</a>
<a name="ln320">  return Status::OK();</a>
<a name="ln321">}</a>
<a name="ln322"> </a>
<a name="ln323">Status WritablePBContainerFile::Append(const Message&amp; msg) {</a>
<a name="ln324">  DCHECK(!closed_);</a>
<a name="ln325"> </a>
<a name="ln326">  faststring buf;</a>
<a name="ln327">  RETURN_NOT_OK_PREPEND(AppendMsgToBuffer(msg, &amp;buf),</a>
<a name="ln328">                        &quot;Failed to prepare buffer for writing&quot;);</a>
<a name="ln329">  RETURN_NOT_OK_PREPEND(writer_-&gt;Append(buf), &quot;Failed to Append() data to file&quot;);</a>
<a name="ln330"> </a>
<a name="ln331">  return Status::OK();</a>
<a name="ln332">}</a>
<a name="ln333"> </a>
<a name="ln334">Status WritablePBContainerFile::Flush() {</a>
<a name="ln335">  DCHECK(!closed_);</a>
<a name="ln336"> </a>
<a name="ln337">  // TODO: Flush just the dirty bytes.</a>
<a name="ln338">  RETURN_NOT_OK_PREPEND(writer_-&gt;Flush(WritableFile::FLUSH_ASYNC), &quot;Failed to Flush() file&quot;);</a>
<a name="ln339"> </a>
<a name="ln340">  return Status::OK();</a>
<a name="ln341">}</a>
<a name="ln342"> </a>
<a name="ln343">Status WritablePBContainerFile::Sync() {</a>
<a name="ln344">  DCHECK(!closed_);</a>
<a name="ln345"> </a>
<a name="ln346">  RETURN_NOT_OK_PREPEND(writer_-&gt;Sync(), &quot;Failed to Sync() file&quot;);</a>
<a name="ln347"> </a>
<a name="ln348">  return Status::OK();</a>
<a name="ln349">}</a>
<a name="ln350"> </a>
<a name="ln351">Status WritablePBContainerFile::Close() {</a>
<a name="ln352">  if (!closed_) {</a>
<a name="ln353">    closed_ = true;</a>
<a name="ln354"> </a>
<a name="ln355">    RETURN_NOT_OK_PREPEND(writer_-&gt;Close(), &quot;Failed to Close() file&quot;);</a>
<a name="ln356">  }</a>
<a name="ln357"> </a>
<a name="ln358">  return Status::OK();</a>
<a name="ln359">}</a>
<a name="ln360"> </a>
<a name="ln361">Status WritablePBContainerFile::AppendMsgToBuffer(const Message&amp; msg, faststring* buf) {</a>
<a name="ln362">  DCHECK(msg.IsInitialized()) &lt;&lt; InitializationErrorMessage(&quot;serialize&quot;, msg);</a>
<a name="ln363">  int data_size = msg.ByteSize();</a>
<a name="ln364">  uint64_t bufsize = sizeof(uint32_t) + data_size + kPBContainerChecksumLen;</a>
<a name="ln365"> </a>
<a name="ln366">  // Grow the buffer to hold the new data.</a>
<a name="ln367">  size_t orig_size = buf-&gt;size();</a>
<a name="ln368">  buf-&gt;resize(orig_size + bufsize);</a>
<a name="ln369">  uint8_t* dst = buf-&gt;data() + orig_size;</a>
<a name="ln370"> </a>
<a name="ln371">  // Serialize the data size.</a>
<a name="ln372">  InlineEncodeFixed32(dst, static_cast&lt;uint32_t&gt;(data_size));</a>
<a name="ln373">  size_t offset = sizeof(uint32_t);</a>
<a name="ln374"> </a>
<a name="ln375">  // Serialize the data.</a>
<a name="ln376">  if (PREDICT_FALSE(!msg.SerializeWithCachedSizesToArray(dst + offset))) {</a>
<a name="ln377">    return STATUS(IOError, &quot;Failed to serialize PB to array&quot;);</a>
<a name="ln378">  }</a>
<a name="ln379">  offset += data_size;</a>
<a name="ln380"> </a>
<a name="ln381">  // Calculate and serialize the checksum.</a>
<a name="ln382">  uint32_t checksum = crc::Crc32c(dst, offset);</a>
<a name="ln383">  InlineEncodeFixed32(dst + offset, checksum);</a>
<a name="ln384">  offset += kPBContainerChecksumLen;</a>
<a name="ln385"> </a>
<a name="ln386">  DCHECK_EQ(bufsize, offset) &lt;&lt; &quot;Serialized unexpected number of total bytes&quot;;</a>
<a name="ln387">  return Status::OK();</a>
<a name="ln388">}</a>
<a name="ln389"> </a>
<a name="ln390">void WritablePBContainerFile::PopulateDescriptorSet(</a>
<a name="ln391">    const FileDescriptor* desc, FileDescriptorSet* output) {</a>
<a name="ln392">  // Because we don't compile protobuf with TSAN enabled, copying the</a>
<a name="ln393">  // static PB descriptors in this function ends up triggering a lot of</a>
<a name="ln394">  // race reports. We suppress the reports, but TSAN still has to walk</a>
<a name="ln395">  // the stack, etc, and this function becomes very slow. So, we ignore</a>
<a name="ln396">  // TSAN here.</a>
<a name="ln397">  debug::ScopedTSANIgnoreReadsAndWrites ignore_tsan;</a>
<a name="ln398"> </a>
<a name="ln399">  FileDescriptorSet all_descs;</a>
<a name="ln400"> </a>
<a name="ln401">  // Tracks all schemas that have been added to 'unemitted' at one point</a>
<a name="ln402">  // or another. Is a superset of 'unemitted' and only ever grows.</a>
<a name="ln403">  unordered_set&lt;const FileDescriptor*&gt; processed;</a>
<a name="ln404"> </a>
<a name="ln405">  // Tracks all remaining unemitted schemas.</a>
<a name="ln406">  deque&lt;const FileDescriptor*&gt; unemitted;</a>
<a name="ln407"> </a>
<a name="ln408">  InsertOrDie(&amp;processed, desc);</a>
<a name="ln409">  unemitted.push_front(desc);</a>
<a name="ln410">  while (!unemitted.empty()) {</a>
<a name="ln411">    const FileDescriptor* proto = unemitted.front();</a>
<a name="ln412"> </a>
<a name="ln413">    // The current schema is emitted iff we've processed (i.e. emitted) all</a>
<a name="ln414">    // of its dependencies.</a>
<a name="ln415">    bool emit = true;</a>
<a name="ln416">    for (int i = 0; i &lt; proto-&gt;dependency_count(); i++) {</a>
<a name="ln417">      const FileDescriptor* dep = proto-&gt;dependency(i);</a>
<a name="ln418">      if (InsertIfNotPresent(&amp;processed, dep)) {</a>
<a name="ln419">        unemitted.push_front(dep);</a>
<a name="ln420">        emit = false;</a>
<a name="ln421">      }</a>
<a name="ln422">    }</a>
<a name="ln423">    if (emit) {</a>
<a name="ln424">      unemitted.pop_front();</a>
<a name="ln425">      proto-&gt;CopyTo(all_descs.mutable_file()-&gt;Add());</a>
<a name="ln426">    }</a>
<a name="ln427">  }</a>
<a name="ln428">  all_descs.Swap(output);</a>
<a name="ln429">}</a>
<a name="ln430"> </a>
<a name="ln431">ReadablePBContainerFile::ReadablePBContainerFile(std::unique_ptr&lt;RandomAccessFile&gt; reader)</a>
<a name="ln432">  : offset_(0),</a>
<a name="ln433">    reader_(std::move(reader)) {</a>
<a name="ln434">}</a>
<a name="ln435"> </a>
<a name="ln436">ReadablePBContainerFile::~ReadablePBContainerFile() {</a>
<a name="ln437">  WARN_NOT_OK(Close(), &quot;Could not Close() when destroying file&quot;);</a>
<a name="ln438">}</a>
<a name="ln439"> </a>
<a name="ln440">Status ReadablePBContainerFile::Init() {</a>
<a name="ln441">  // Read header data.</a>
<a name="ln442">  Slice header;</a>
<a name="ln443">  std::unique_ptr&lt;uint8_t[]&gt; scratch;</a>
<a name="ln444">  RETURN_NOT_OK_PREPEND(ValidateAndRead(kPBContainerHeaderLen, EOF_NOT_OK, &amp;header, &amp;scratch),</a>
<a name="ln445">                        Substitute(&quot;Could not read header for proto container file $0&quot;,</a>
<a name="ln446">                                   reader_-&gt;filename()));</a>
<a name="ln447"> </a>
<a name="ln448">  // Validate magic number.</a>
<a name="ln449">  if (PREDICT_FALSE(!strings::memeq(kPBContainerMagic, header.data(), kPBContainerMagicLen))) {</a>
<a name="ln450">    string file_magic(reinterpret_cast&lt;const char*&gt;(header.data()), kPBContainerMagicLen);</a>
<a name="ln451">    return STATUS(Corruption, &quot;Invalid magic number&quot;,</a>
<a name="ln452">                              Substitute(&quot;Expected: $0, found: $1&quot;,</a>
<a name="ln453">                                         Utf8SafeCEscape(kPBContainerMagic),</a>
<a name="ln454">                                         Utf8SafeCEscape(file_magic)));</a>
<a name="ln455">  }</a>
<a name="ln456"> </a>
<a name="ln457">  // Validate container file version.</a>
<a name="ln458">  uint32_t version = DecodeFixed32(header.data() + kPBContainerMagicLen);</a>
<a name="ln459">  if (PREDICT_FALSE(version != kPBContainerVersion)) {</a>
<a name="ln460">    // We only support version 1.</a>
<a name="ln461">    return STATUS(NotSupported,</a>
<a name="ln462">        Substitute(&quot;Protobuf container has version $0, we only support version $1&quot;,</a>
<a name="ln463">                   version, kPBContainerVersion));</a>
<a name="ln464">  }</a>
<a name="ln465"> </a>
<a name="ln466">  // Read the supplemental header.</a>
<a name="ln467">  ContainerSupHeaderPB sup_header;</a>
<a name="ln468">  RETURN_NOT_OK_PREPEND(ReadNextPB(&amp;sup_header), Substitute(</a>
<a name="ln469">      &quot;Could not read supplemental header from proto container file $0&quot;,</a>
<a name="ln470">      reader_-&gt;filename()));</a>
<a name="ln471">  protos_.reset(sup_header.release_protos());</a>
<a name="ln472">  pb_type_ = sup_header.pb_type();</a>
<a name="ln473"> </a>
<a name="ln474">  return Status::OK();</a>
<a name="ln475">}</a>
<a name="ln476"> </a>
<a name="ln477">Status ReadablePBContainerFile::ReadNextPB(Message* msg) {</a>
<a name="ln478">  VLOG(1) &lt;&lt; &quot;Reading PB from offset &quot; &lt;&lt; offset_;</a>
<a name="ln479"> </a>
<a name="ln480">  // Read the size from the file. EOF here is acceptable: it means we're</a>
<a name="ln481">  // out of PB entries.</a>
<a name="ln482">  Slice size;</a>
<a name="ln483">  std::unique_ptr&lt;uint8_t[]&gt; size_scratch;</a>
<a name="ln484">  RETURN_NOT_OK_PREPEND(ValidateAndRead(sizeof(uint32_t), EOF_OK, &amp;size, &amp;size_scratch),</a>
<a name="ln485">                        Substitute(&quot;Could not read data size from proto container file $0&quot;,</a>
<a name="ln486">                                   reader_-&gt;filename()));</a>
<a name="ln487">  uint32_t data_size = DecodeFixed32(size.data());</a>
<a name="ln488"> </a>
<a name="ln489">  // Read body into buffer for checksum &amp; parsing.</a>
<a name="ln490">  Slice body;</a>
<a name="ln491">  std::unique_ptr&lt;uint8_t[]&gt; body_scratch;</a>
<a name="ln492">  RETURN_NOT_OK_PREPEND(ValidateAndRead(data_size, EOF_NOT_OK, &amp;body, &amp;body_scratch),</a>
<a name="ln493">                        Substitute(&quot;Could not read body from proto container file $0&quot;,</a>
<a name="ln494">                                   reader_-&gt;filename()));</a>
<a name="ln495"> </a>
<a name="ln496">  // Read checksum.</a>
<a name="ln497">  uint32_t expected_checksum = 0;</a>
<a name="ln498">  {</a>
<a name="ln499">    Slice encoded_checksum;</a>
<a name="ln500">    std::unique_ptr&lt;uint8_t[]&gt; encoded_checksum_scratch;</a>
<a name="ln501">    RETURN_NOT_OK_PREPEND(ValidateAndRead(kPBContainerChecksumLen, EOF_NOT_OK,</a>
<a name="ln502">                                          &amp;encoded_checksum, &amp;encoded_checksum_scratch),</a>
<a name="ln503">                          Substitute(&quot;Could not read checksum from proto container file $0&quot;,</a>
<a name="ln504">                                     reader_-&gt;filename()));</a>
<a name="ln505">    expected_checksum = DecodeFixed32(encoded_checksum.data());</a>
<a name="ln506">  }</a>
<a name="ln507"> </a>
<a name="ln508">  // Validate CRC32C checksum.</a>
<a name="ln509">  Crc* crc32c = crc::GetCrc32cInstance();</a>
<a name="ln510">  uint64_t actual_checksum = 0;</a>
<a name="ln511">  // Compute a rolling checksum over the two byte arrays (size, body).</a>
<a name="ln512">  crc32c-&gt;Compute(size.data(), size.size(), &amp;actual_checksum);</a>
<a name="ln513">  crc32c-&gt;Compute(body.data(), body.size(), &amp;actual_checksum);</a>
<a name="ln514">  if (PREDICT_FALSE(actual_checksum != expected_checksum)) {</a>
<a name="ln515">    return STATUS(Corruption, Substitute(&quot;Incorrect checksum of file $0: actually $1, expected $2&quot;,</a>
<a name="ln516">                                         reader_-&gt;filename(), actual_checksum, expected_checksum));</a>
<a name="ln517">  }</a>
<a name="ln518"> </a>
<a name="ln519">  // The checksum is correct. Time to decode the body.</a>
<a name="ln520">  //</a>
<a name="ln521">  // We could compare pb_type_ against msg.GetTypeName(), but:</a>
<a name="ln522">  // 1. pb_type_ is not available when reading the supplemental header,</a>
<a name="ln523">  // 2. ParseFromArray() should fail if the data cannot be parsed into the</a>
<a name="ln524">  //    provided message type.</a>
<a name="ln525"> </a>
<a name="ln526">  // To permit parsing of very large PB messages, we must use parse through a</a>
<a name="ln527">  // CodedInputStream and bump the byte limit. The SetTotalBytesLimit() docs</a>
<a name="ln528">  // say that 512MB is the shortest theoretical message length that may produce</a>
<a name="ln529">  // integer overflow warnings, so that's what we'll use.</a>
<a name="ln530">  ArrayInputStream ais(body.data(), body.size());</a>
<a name="ln531">  CodedInputStream cis(&amp;ais);</a>
<a name="ln532">  cis.SetTotalBytesLimit(512 * 1024 * 1024, -1);</a>
<a name="ln533">  if (PREDICT_FALSE(!msg-&gt;ParseFromCodedStream(&amp;cis))) {</a>
<a name="ln534">    return STATUS(IOError, &quot;Unable to parse PB from path&quot;, reader_-&gt;filename());</a>
<a name="ln535">  }</a>
<a name="ln536"> </a>
<a name="ln537">  return Status::OK();</a>
<a name="ln538">}</a>
<a name="ln539"> </a>
<a name="ln540">Status ReadablePBContainerFile::Dump(ostream* os, bool oneline) {</a>
<a name="ln541">  // Use the embedded protobuf information from the container file to</a>
<a name="ln542">  // create the appropriate kind of protobuf Message.</a>
<a name="ln543">  //</a>
<a name="ln544">  // Loading the schemas into a DescriptorDatabase (and not directly into</a>
<a name="ln545">  // a DescriptorPool) defers resolution until FindMessageTypeByName()</a>
<a name="ln546">  // below, allowing for schemas to be loaded in any order.</a>
<a name="ln547">  SimpleDescriptorDatabase db;</a>
<a name="ln548">  for (int i = 0; i &lt; protos()-&gt;file_size(); i++) {</a>
<a name="ln549">    if (!db.Add(protos()-&gt;file(i))) {</a>
<a name="ln550">      return STATUS(Corruption, &quot;Descriptor not loaded&quot;, Substitute(</a>
<a name="ln551">          &quot;Could not load descriptor for PB type $0 referenced in container file&quot;,</a>
<a name="ln552">          pb_type()));</a>
<a name="ln553">    }</a>
<a name="ln554">  }</a>
<a name="ln555">  DescriptorPool pool(&amp;db);</a>
<a name="ln556">  const Descriptor* desc = pool.FindMessageTypeByName(pb_type());</a>
<a name="ln557">  if (!desc) {</a>
<a name="ln558">    return STATUS(NotFound, &quot;Descriptor not found&quot;, Substitute(</a>
<a name="ln559">        &quot;Could not find descriptor for PB type $0 referenced in container file&quot;,</a>
<a name="ln560">        pb_type()));</a>
<a name="ln561">  }</a>
<a name="ln562">  DynamicMessageFactory factory;</a>
<a name="ln563">  const Message* prototype = factory.GetPrototype(desc);</a>
<a name="ln564">  if (!prototype) {</a>
<a name="ln565">    return STATUS(NotSupported, &quot;Descriptor not supported&quot;, Substitute(</a>
<a name="ln566">        &quot;Descriptor $0 referenced in container file not supported&quot;,</a>
<a name="ln567">        pb_type()));</a>
<a name="ln568">  }</a>
<a name="ln569">  std::unique_ptr&lt;Message&gt; msg(prototype-&gt;New());</a>
<a name="ln570"> </a>
<a name="ln571">  // Dump each message in the container file.</a>
<a name="ln572">  int count = 0;</a>
<a name="ln573">  Status s;</a>
<a name="ln574">  for (s = ReadNextPB(msg.get());</a>
<a name="ln575">      s.ok();</a>
<a name="ln576">      s = ReadNextPB(msg.get())) {</a>
<a name="ln577">    if (oneline) {</a>
<a name="ln578">      *os &lt;&lt; count++ &lt;&lt; &quot;\t&quot; &lt;&lt; msg-&gt;ShortDebugString() &lt;&lt; endl;</a>
<a name="ln579">    } else {</a>
<a name="ln580">      *os &lt;&lt; &quot;Message &quot; &lt;&lt; count &lt;&lt; endl;</a>
<a name="ln581">      *os &lt;&lt; &quot;-------&quot; &lt;&lt; endl;</a>
<a name="ln582">      *os &lt;&lt; msg-&gt;DebugString() &lt;&lt; endl;</a>
<a name="ln583">      count++;</a>
<a name="ln584">    }</a>
<a name="ln585">  }</a>
<a name="ln586">  return s.IsEndOfFile() ? Status::OK() : s;</a>
<a name="ln587">}</a>
<a name="ln588"> </a>
<a name="ln589">Status ReadablePBContainerFile::Close() {</a>
<a name="ln590">  std::unique_ptr&lt;RandomAccessFile&gt; deleter;</a>
<a name="ln591">  deleter.swap(reader_);</a>
<a name="ln592">  return Status::OK();</a>
<a name="ln593">}</a>
<a name="ln594"> </a>
<a name="ln595">Status ReadablePBContainerFile::ValidateAndRead(size_t length, EofOK eofOK,</a>
<a name="ln596">                                                Slice* result,</a>
<a name="ln597">                                                std::unique_ptr&lt;uint8_t[]&gt;* scratch) {</a>
<a name="ln598">  // Validate the read length using the file size.</a>
<a name="ln599">  uint64_t file_size = VERIFY_RESULT(reader_-&gt;Size());</a>
<a name="ln600">  if (offset_ + length &gt; file_size) {</a>
<a name="ln601">    switch (eofOK) {</a>
<a name="ln602">      case EOF_OK:</a>
<a name="ln603">        return STATUS(EndOfFile, &quot;Reached end of file&quot;);</a>
<a name="ln604">      case EOF_NOT_OK:</a>
<a name="ln605">        return STATUS(Corruption, &quot;File size not large enough to be valid&quot;,</a>
<a name="ln606">                                  Substitute(&quot;Proto container file $0: &quot;</a>
<a name="ln607">                                      &quot;tried to read $0 bytes at offset &quot;</a>
<a name="ln608">                                      &quot;$1 but file size is only $2&quot;,</a>
<a name="ln609">                                      reader_-&gt;filename(), length,</a>
<a name="ln610">                                      offset_, file_size));</a>
<a name="ln611">      default:</a>
<a name="ln612">        LOG(FATAL) &lt;&lt; &quot;Unknown value for eofOK: &quot; &lt;&lt; eofOK;</a>
<a name="ln613">    }</a>
<a name="ln614">  }</a>
<a name="ln615"> </a>
<a name="ln616">  // Perform the read.</a>
<a name="ln617">  Slice s;</a>
<a name="ln618">  std::unique_ptr&lt;uint8_t[]&gt; local_scratch(new uint8_t[length]);</a>
<a name="ln619">  RETURN_NOT_OK(reader_-&gt;Read(offset_, length, &amp;s, local_scratch.get()));</a>
<a name="ln620"> </a>
<a name="ln621">  // Sanity check the result.</a>
<a name="ln622">  if (PREDICT_FALSE(s.size() &lt; length)) {</a>
<a name="ln623">    return STATUS(Corruption, &quot;Unexpected short read&quot;, Substitute(</a>
<a name="ln624">        &quot;Proto container file $0: tried to read $1 bytes; got $2 bytes&quot;,</a>
<a name="ln625">        reader_-&gt;filename(), length, s.size()));</a>
<a name="ln626">  }</a>
<a name="ln627"> </a>
<a name="ln628">  *result = s;</a>
<a name="ln629">  scratch-&gt;swap(local_scratch);</a>
<a name="ln630">  offset_ += s.size();</a>
<a name="ln631">  return Status::OK();</a>
<a name="ln632">}</a>
<a name="ln633"> </a>
<a name="ln634"> </a>
<a name="ln635">Status ReadPBContainerFromPath(Env* env, const std::string&amp; path, Message* msg) {</a>
<a name="ln636">  std::unique_ptr&lt;RandomAccessFile&gt; file;</a>
<a name="ln637">  RETURN_NOT_OK(env-&gt;NewRandomAccessFile(path, &amp;file));</a>
<a name="ln638"> </a>
<a name="ln639">  ReadablePBContainerFile pb_file(std::move(file));</a>
<a name="ln640">  RETURN_NOT_OK(pb_file.Init());</a>
<a name="ln641">  RETURN_NOT_OK(pb_file.ReadNextPB(msg));</a>
<a name="ln642">  return pb_file.Close();</a>
<a name="ln643">}</a>
<a name="ln644"> </a>
<a name="ln645">Status WritePBContainerToPath(Env* env, const std::string&amp; path,</a>
<a name="ln646">                              const Message&amp; msg,</a>
<a name="ln647">                              CreateMode create,</a>
<a name="ln648">                              SyncMode sync) {</a>
<a name="ln649">  TRACE_EVENT2(&quot;io&quot;, &quot;WritePBContainerToPath&quot;,</a>
<a name="ln650">               &quot;path&quot;, path,</a>
<a name="ln651">               &quot;msg_type&quot;, msg.GetTypeName());</a>
<a name="ln652"> </a>
<a name="ln653">  if (create == NO_OVERWRITE &amp;&amp; env-&gt;FileExists(path)) {</a>
<a name="ln654">    return STATUS(AlreadyPresent, Substitute(&quot;File $0 already exists&quot;, path));</a>
<a name="ln655">  }</a>
<a name="ln656"> </a>
<a name="ln657">  const string tmp_template = path + kTmpTemplateSuffix;</a>
<a name="ln658">  string tmp_path;</a>
<a name="ln659"> </a>
<a name="ln660">  std::unique_ptr&lt;WritableFile&gt; file;</a>
<a name="ln661">  RETURN_NOT_OK(env-&gt;NewTempWritableFile(WritableFileOptions(), tmp_template, &amp;tmp_path, &amp;file));</a>
<a name="ln662">  env_util::ScopedFileDeleter tmp_deleter(env, tmp_path);</a>
<a name="ln663"> </a>
<a name="ln664">  WritablePBContainerFile pb_file(std::move(file));</a>
<a name="ln665">  RETURN_NOT_OK(pb_file.Init(msg));</a>
<a name="ln666">  RETURN_NOT_OK(pb_file.Append(msg));</a>
<a name="ln667">  if (sync == pb_util::SYNC) {</a>
<a name="ln668">    RETURN_NOT_OK(pb_file.Sync());</a>
<a name="ln669">  }</a>
<a name="ln670">  RETURN_NOT_OK(pb_file.Close());</a>
<a name="ln671">  RETURN_NOT_OK_PREPEND(env-&gt;RenameFile(tmp_path, path),</a>
<a name="ln672">                        &quot;Failed to rename tmp file to &quot; + path);</a>
<a name="ln673">  tmp_deleter.Cancel();</a>
<a name="ln674">  if (sync == pb_util::SYNC) {</a>
<a name="ln675">    RETURN_NOT_OK_PREPEND(env-&gt;SyncDir(DirName(path)),</a>
<a name="ln676">                          &quot;Failed to SyncDir() parent of &quot; + path);</a>
<a name="ln677">  }</a>
<a name="ln678">  return Status::OK();</a>
<a name="ln679">}</a>
<a name="ln680"> </a>
<a name="ln681">bool ArePBsEqual(const google::protobuf::Message&amp; prev_pb,</a>
<a name="ln682">                 const google::protobuf::Message&amp; new_pb,</a>
<a name="ln683">                 std::string* diff_str) {</a>
<a name="ln684">  google::protobuf::util::MessageDifferencer md;</a>
<a name="ln685">  if (diff_str) {</a>
<a name="ln686">    md.ReportDifferencesToString(diff_str);</a>
<a name="ln687">  }</a>
<a name="ln688">  return md.Compare(prev_pb, new_pb);</a>
<a name="ln689">}</a>
<a name="ln690"> </a>
<a name="ln691">} // namespace pb_util</a>
<a name="ln692">} // namespace yb</a>

</code></pre>
<div class="balloon" rel="162"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="294"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="324"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="335"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="344"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="362"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="478"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
