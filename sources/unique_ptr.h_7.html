
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>unique_ptr.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// unique_ptr implementation -*- C++ -*-</a>
<a name="ln2"> </a>
<a name="ln3">// Copyright (C) 2008-2018 Free Software Foundation, Inc.</a>
<a name="ln4">//</a>
<a name="ln5">// This file is part of the GNU ISO C++ Library.  This library is free</a>
<a name="ln6">// software; you can redistribute it and/or modify it under the</a>
<a name="ln7">// terms of the GNU General Public License as published by the</a>
<a name="ln8">// Free Software Foundation; either version 3, or (at your option)</a>
<a name="ln9">// any later version.</a>
<a name="ln10"> </a>
<a name="ln11">// This library is distributed in the hope that it will be useful,</a>
<a name="ln12">// but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">// GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">// Under Section 7 of GPL version 3, you are granted additional</a>
<a name="ln17">// permissions described in the GCC Runtime Library Exception, version</a>
<a name="ln18">// 3.1, as published by the Free Software Foundation.</a>
<a name="ln19"> </a>
<a name="ln20">// You should have received a copy of the GNU General Public License and</a>
<a name="ln21">// a copy of the GCC Runtime Library Exception along with this program;</a>
<a name="ln22">// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see</a>
<a name="ln23">// &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln24"> </a>
<a name="ln25">/** @file bits/unique_ptr.h</a>
<a name="ln26"> *  This is an internal header file, included by other library headers.</a>
<a name="ln27"> *  Do not attempt to use it directly. @headername{memory}</a>
<a name="ln28"> */</a>
<a name="ln29"> </a>
<a name="ln30">#ifndef _UNIQUE_PTR_H</a>
<a name="ln31">#define _UNIQUE_PTR_H 1</a>
<a name="ln32"> </a>
<a name="ln33">#include &lt;bits/c++config.h&gt;</a>
<a name="ln34">#include &lt;debug/assertions.h&gt;</a>
<a name="ln35">#include &lt;type_traits&gt;</a>
<a name="ln36">#include &lt;utility&gt;</a>
<a name="ln37">#include &lt;tuple&gt;</a>
<a name="ln38">#include &lt;bits/stl_function.h&gt;</a>
<a name="ln39">#include &lt;bits/functional_hash.h&gt;</a>
<a name="ln40"> </a>
<a name="ln41">namespace std _GLIBCXX_VISIBILITY(default)</a>
<a name="ln42">{</a>
<a name="ln43">_GLIBCXX_BEGIN_NAMESPACE_VERSION</a>
<a name="ln44"> </a>
<a name="ln45">  /**</a>
<a name="ln46">   * @addtogroup pointer_abstractions</a>
<a name="ln47">   * @{</a>
<a name="ln48">   */</a>
<a name="ln49"> </a>
<a name="ln50">#if _GLIBCXX_USE_DEPRECATED</a>
<a name="ln51">#pragma GCC diagnostic push</a>
<a name="ln52">#pragma GCC diagnostic ignored &quot;-Wdeprecated-declarations&quot;</a>
<a name="ln53">  template&lt;typename&gt; class auto_ptr;</a>
<a name="ln54">#pragma GCC diagnostic pop</a>
<a name="ln55">#endif</a>
<a name="ln56"> </a>
<a name="ln57">  /// Primary template of default_delete, used by unique_ptr</a>
<a name="ln58">  template&lt;typename _Tp&gt;</a>
<a name="ln59">    struct default_delete</a>
<a name="ln60">    {</a>
<a name="ln61">      /// Default constructor</a>
<a name="ln62">      constexpr default_delete() noexcept = default;</a>
<a name="ln63"> </a>
<a name="ln64">      /** @brief Converting constructor.</a>
<a name="ln65">       *</a>
<a name="ln66">       * Allows conversion from a deleter for arrays of another type, @p _Up,</a>
<a name="ln67">       * only if @p _Up* is convertible to @p _Tp*.</a>
<a name="ln68">       */</a>
<a name="ln69">      template&lt;typename _Up, typename = typename</a>
<a name="ln70">	       enable_if&lt;is_convertible&lt;_Up*, _Tp*&gt;::value&gt;::type&gt;</a>
<a name="ln71">        default_delete(const default_delete&lt;_Up&gt;&amp;) noexcept { }</a>
<a name="ln72"> </a>
<a name="ln73">      /// Calls @c delete @p __ptr</a>
<a name="ln74">      void</a>
<a name="ln75">      operator()(_Tp* __ptr) const</a>
<a name="ln76">      {</a>
<a name="ln77">	static_assert(!is_void&lt;_Tp&gt;::value,</a>
<a name="ln78">		      &quot;can't delete pointer to incomplete type&quot;);</a>
<a name="ln79">	static_assert(sizeof(_Tp)&gt;0,</a>
<a name="ln80">		      &quot;can't delete pointer to incomplete type&quot;);</a>
<a name="ln81">	delete __ptr;</a>
<a name="ln82">      }</a>
<a name="ln83">    };</a>
<a name="ln84"> </a>
<a name="ln85">  // _GLIBCXX_RESOLVE_LIB_DEFECTS</a>
<a name="ln86">  // DR 740 - omit specialization for array objects with a compile time length</a>
<a name="ln87">  /// Specialization for arrays, default_delete.</a>
<a name="ln88">  template&lt;typename _Tp&gt;</a>
<a name="ln89">    struct default_delete&lt;_Tp[]&gt;</a>
<a name="ln90">    {</a>
<a name="ln91">    public:</a>
<a name="ln92">      /// Default constructor</a>
<a name="ln93">      constexpr default_delete() noexcept = default;</a>
<a name="ln94"> </a>
<a name="ln95">      /** @brief Converting constructor.</a>
<a name="ln96">       *</a>
<a name="ln97">       * Allows conversion from a deleter for arrays of another type, such as</a>
<a name="ln98">       * a const-qualified version of @p _Tp.</a>
<a name="ln99">       *</a>
<a name="ln100">       * Conversions from types derived from @c _Tp are not allowed because</a>
<a name="ln101">       * it is unsafe to @c delete[] an array of derived types through a</a>
<a name="ln102">       * pointer to the base type.</a>
<a name="ln103">       */</a>
<a name="ln104">      template&lt;typename _Up, typename = typename</a>
<a name="ln105">	       enable_if&lt;is_convertible&lt;_Up(*)[], _Tp(*)[]&gt;::value&gt;::type&gt;</a>
<a name="ln106">        default_delete(const default_delete&lt;_Up[]&gt;&amp;) noexcept { }</a>
<a name="ln107"> </a>
<a name="ln108">      /// Calls @c delete[] @p __ptr</a>
<a name="ln109">      template&lt;typename _Up&gt;</a>
<a name="ln110">      typename enable_if&lt;is_convertible&lt;_Up(*)[], _Tp(*)[]&gt;::value&gt;::type</a>
<a name="ln111">	operator()(_Up* __ptr) const</a>
<a name="ln112">      {</a>
<a name="ln113">	static_assert(sizeof(_Tp)&gt;0,</a>
<a name="ln114">		      &quot;can't delete pointer to incomplete type&quot;);</a>
<a name="ln115">	delete [] __ptr;</a>
<a name="ln116">      }</a>
<a name="ln117">    };</a>
<a name="ln118"> </a>
<a name="ln119">  template &lt;typename _Tp, typename _Dp&gt;</a>
<a name="ln120">    class __uniq_ptr_impl</a>
<a name="ln121">    {</a>
<a name="ln122">      template &lt;typename _Up, typename _Ep, typename = void&gt;</a>
<a name="ln123">	struct _Ptr</a>
<a name="ln124">	{</a>
<a name="ln125">	  using type = _Up*;</a>
<a name="ln126">	};</a>
<a name="ln127"> </a>
<a name="ln128">      template &lt;typename _Up, typename _Ep&gt;</a>
<a name="ln129">	struct</a>
<a name="ln130">	_Ptr&lt;_Up, _Ep, __void_t&lt;typename remove_reference&lt;_Ep&gt;::type::pointer&gt;&gt;</a>
<a name="ln131">	{</a>
<a name="ln132">	  using type = typename remove_reference&lt;_Ep&gt;::type::pointer;</a>
<a name="ln133">	};</a>
<a name="ln134"> </a>
<a name="ln135">    public:</a>
<a name="ln136">      using _DeleterConstraint = enable_if&lt;</a>
<a name="ln137">        __and_&lt;__not_&lt;is_pointer&lt;_Dp&gt;&gt;,</a>
<a name="ln138">	       is_default_constructible&lt;_Dp&gt;&gt;::value&gt;;</a>
<a name="ln139"> </a>
<a name="ln140">      using pointer = typename _Ptr&lt;_Tp, _Dp&gt;::type;</a>
<a name="ln141"> </a>
<a name="ln142">      __uniq_ptr_impl() = default;</a>
<a name="ln143">      __uniq_ptr_impl(pointer __p) : _M_t() { _M_ptr() = __p; }</a>
<a name="ln144"> </a>
<a name="ln145">      template&lt;typename _Del&gt;</a>
<a name="ln146">      __uniq_ptr_impl(pointer __p, _Del&amp;&amp; __d)</a>
<a name="ln147">	: _M_t(__p, std::forward&lt;_Del&gt;(__d)) { }</a>
<a name="ln148"> </a>
<a name="ln149">      pointer&amp;   _M_ptr() { return std::get&lt;0&gt;(_M_t); }</a>
<a name="ln150">      pointer    _M_ptr() const { return std::get&lt;0&gt;(_M_t); }</a>
<a name="ln151">      _Dp&amp;       _M_deleter() { return std::get&lt;1&gt;(_M_t); }</a>
<a name="ln152">      const _Dp&amp; _M_deleter() const { return std::get&lt;1&gt;(_M_t); }</a>
<a name="ln153"> </a>
<a name="ln154">    private:</a>
<a name="ln155">      tuple&lt;pointer, _Dp&gt; _M_t;</a>
<a name="ln156">    };</a>
<a name="ln157"> </a>
<a name="ln158">  /// 20.7.1.2 unique_ptr for single objects.</a>
<a name="ln159">  template &lt;typename _Tp, typename _Dp = default_delete&lt;_Tp&gt;&gt;</a>
<a name="ln160">    class unique_ptr</a>
<a name="ln161">    {</a>
<a name="ln162">      template &lt;class _Up&gt;</a>
<a name="ln163">      using _DeleterConstraint =</a>
<a name="ln164">	typename __uniq_ptr_impl&lt;_Tp, _Up&gt;::_DeleterConstraint::type;</a>
<a name="ln165"> </a>
<a name="ln166">      __uniq_ptr_impl&lt;_Tp, _Dp&gt; _M_t;</a>
<a name="ln167"> </a>
<a name="ln168">    public:</a>
<a name="ln169">      using pointer	  = typename __uniq_ptr_impl&lt;_Tp, _Dp&gt;::pointer;</a>
<a name="ln170">      using element_type  = _Tp;</a>
<a name="ln171">      using deleter_type  = _Dp;</a>
<a name="ln172"> </a>
<a name="ln173">      // helper template for detecting a safe conversion from another</a>
<a name="ln174">      // unique_ptr</a>
<a name="ln175">      template&lt;typename _Up, typename _Ep&gt;</a>
<a name="ln176">	using __safe_conversion_up = __and_&lt;</a>
<a name="ln177">	        is_convertible&lt;typename unique_ptr&lt;_Up, _Ep&gt;::pointer, pointer&gt;,</a>
<a name="ln178">                __not_&lt;is_array&lt;_Up&gt;&gt;,</a>
<a name="ln179">                __or_&lt;__and_&lt;is_reference&lt;deleter_type&gt;,</a>
<a name="ln180">                             is_same&lt;deleter_type, _Ep&gt;&gt;,</a>
<a name="ln181">                      __and_&lt;__not_&lt;is_reference&lt;deleter_type&gt;&gt;,</a>
<a name="ln182">                             is_convertible&lt;_Ep, deleter_type&gt;&gt;</a>
<a name="ln183">                &gt;</a>
<a name="ln184">              &gt;;</a>
<a name="ln185"> </a>
<a name="ln186">      // Constructors.</a>
<a name="ln187"> </a>
<a name="ln188">      /// Default constructor, creates a unique_ptr that owns nothing.</a>
<a name="ln189">      template &lt;typename _Up = _Dp,</a>
<a name="ln190">		typename = _DeleterConstraint&lt;_Up&gt;&gt;</a>
<a name="ln191">	constexpr unique_ptr() noexcept</a>
<a name="ln192">	: _M_t()</a>
<a name="ln193">	{ }</a>
<a name="ln194"> </a>
<a name="ln195">      /** Takes ownership of a pointer.</a>
<a name="ln196">       *</a>
<a name="ln197">       * @param __p  A pointer to an object of @c element_type</a>
<a name="ln198">       *</a>
<a name="ln199">       * The deleter will be value-initialized.</a>
<a name="ln200">       */</a>
<a name="ln201">      template &lt;typename _Up = _Dp,</a>
<a name="ln202">		typename = _DeleterConstraint&lt;_Up&gt;&gt;</a>
<a name="ln203">	explicit</a>
<a name="ln204">	unique_ptr(pointer __p) noexcept</a>
<a name="ln205">	: _M_t(__p)</a>
<a name="ln206">        { }</a>
<a name="ln207"> </a>
<a name="ln208">      /** Takes ownership of a pointer.</a>
<a name="ln209">       *</a>
<a name="ln210">       * @param __p  A pointer to an object of @c element_type</a>
<a name="ln211">       * @param __d  A reference to a deleter.</a>
<a name="ln212">       *</a>
<a name="ln213">       * The deleter will be initialized with @p __d</a>
<a name="ln214">       */</a>
<a name="ln215">      unique_ptr(pointer __p,</a>
<a name="ln216">	  typename conditional&lt;is_reference&lt;deleter_type&gt;::value,</a>
<a name="ln217">	    deleter_type, const deleter_type&amp;&gt;::type __d) noexcept</a>
<a name="ln218">      : _M_t(__p, __d) { }</a>
<a name="ln219"> </a>
<a name="ln220">      /** Takes ownership of a pointer.</a>
<a name="ln221">       *</a>
<a name="ln222">       * @param __p  A pointer to an object of @c element_type</a>
<a name="ln223">       * @param __d  An rvalue reference to a deleter.</a>
<a name="ln224">       *</a>
<a name="ln225">       * The deleter will be initialized with @p std::move(__d)</a>
<a name="ln226">       */</a>
<a name="ln227">      unique_ptr(pointer __p,</a>
<a name="ln228">	  typename remove_reference&lt;deleter_type&gt;::type&amp;&amp; __d) noexcept</a>
<a name="ln229">      : _M_t(std::move(__p), std::move(__d))</a>
<a name="ln230">      { static_assert(!std::is_reference&lt;deleter_type&gt;::value,</a>
<a name="ln231">		      &quot;rvalue deleter bound to reference&quot;); }</a>
<a name="ln232"> </a>
<a name="ln233">      /// Creates a unique_ptr that owns nothing.</a>
<a name="ln234">      template &lt;typename _Up = _Dp,</a>
<a name="ln235">		typename = _DeleterConstraint&lt;_Up&gt;&gt;</a>
<a name="ln236">	constexpr unique_ptr(nullptr_t) noexcept : _M_t() { }</a>
<a name="ln237"> </a>
<a name="ln238">      // Move constructors.</a>
<a name="ln239"> </a>
<a name="ln240">      /// Move constructor.</a>
<a name="ln241">      unique_ptr(unique_ptr&amp;&amp; __u) noexcept</a>
<a name="ln242">      : _M_t(__u.release(), std::forward&lt;deleter_type&gt;(__u.get_deleter())) { }</a>
<a name="ln243"> </a>
<a name="ln244">      /** @brief Converting constructor from another type</a>
<a name="ln245">       *</a>
<a name="ln246">       * Requires that the pointer owned by @p __u is convertible to the</a>
<a name="ln247">       * type of pointer owned by this object, @p __u does not own an array,</a>
<a name="ln248">       * and @p __u has a compatible deleter type.</a>
<a name="ln249">       */</a>
<a name="ln250">      template&lt;typename _Up, typename _Ep, typename = _Require&lt;</a>
<a name="ln251">               __safe_conversion_up&lt;_Up, _Ep&gt;,</a>
<a name="ln252">	       typename conditional&lt;is_reference&lt;_Dp&gt;::value,</a>
<a name="ln253">				    is_same&lt;_Ep, _Dp&gt;,</a>
<a name="ln254">				    is_convertible&lt;_Ep, _Dp&gt;&gt;::type&gt;&gt;</a>
<a name="ln255">	unique_ptr(unique_ptr&lt;_Up, _Ep&gt;&amp;&amp; __u) noexcept</a>
<a name="ln256">	: _M_t(__u.release(), std::forward&lt;_Ep&gt;(__u.get_deleter()))</a>
<a name="ln257">	{ }</a>
<a name="ln258"> </a>
<a name="ln259">#if _GLIBCXX_USE_DEPRECATED</a>
<a name="ln260">#pragma GCC diagnostic push</a>
<a name="ln261">#pragma GCC diagnostic ignored &quot;-Wdeprecated-declarations&quot;</a>
<a name="ln262">      /// Converting constructor from @c auto_ptr</a>
<a name="ln263">      template&lt;typename _Up, typename = _Require&lt;</a>
<a name="ln264">	       is_convertible&lt;_Up*, _Tp*&gt;, is_same&lt;_Dp, default_delete&lt;_Tp&gt;&gt;&gt;&gt;</a>
<a name="ln265">	unique_ptr(auto_ptr&lt;_Up&gt;&amp;&amp; __u) noexcept;</a>
<a name="ln266">#pragma GCC diagnostic pop</a>
<a name="ln267">#endif</a>
<a name="ln268"> </a>
<a name="ln269">      /// Destructor, invokes the deleter if the stored pointer is not null.</a>
<a name="ln270">      ~unique_ptr() noexcept</a>
<a name="ln271">      {</a>
<a name="ln272">	auto&amp; __ptr = _M_t._M_ptr();</a>
<a name="ln273">	if (__ptr != nullptr)</a>
<a name="ln274">	  get_deleter()(__ptr);</a>
<a name="ln275">	__ptr = pointer();</a>
<a name="ln276">      }</a>
<a name="ln277"> </a>
<a name="ln278">      // Assignment.</a>
<a name="ln279"> </a>
<a name="ln280">      /** @brief Move assignment operator.</a>
<a name="ln281">       *</a>
<a name="ln282">       * @param __u  The object to transfer ownership from.</a>
<a name="ln283">       *</a>
<a name="ln284">       * Invokes the deleter first if this object owns a pointer.</a>
<a name="ln285">       */</a>
<a name="ln286">      unique_ptr&amp;</a>
<a name="ln287">      operator=(unique_ptr&amp;&amp; __u) noexcept</a>
<a name="ln288">      {</a>
<a name="ln289">	reset(__u.release());</a>
<a name="ln290">	get_deleter() = std::forward&lt;deleter_type&gt;(__u.get_deleter());</a>
<a name="ln291">	return *this;</a>
<a name="ln292">      }</a>
<a name="ln293"> </a>
<a name="ln294">      /** @brief Assignment from another type.</a>
<a name="ln295">       *</a>
<a name="ln296">       * @param __u  The object to transfer ownership from, which owns a</a>
<a name="ln297">       *             convertible pointer to a non-array object.</a>
<a name="ln298">       *</a>
<a name="ln299">       * Invokes the deleter first if this object owns a pointer.</a>
<a name="ln300">       */</a>
<a name="ln301">      template&lt;typename _Up, typename _Ep&gt;</a>
<a name="ln302">        typename enable_if&lt; __and_&lt;</a>
<a name="ln303">          __safe_conversion_up&lt;_Up, _Ep&gt;,</a>
<a name="ln304">          is_assignable&lt;deleter_type&amp;, _Ep&amp;&amp;&gt;</a>
<a name="ln305">          &gt;::value,</a>
<a name="ln306">          unique_ptr&amp;&gt;::type</a>
<a name="ln307">	operator=(unique_ptr&lt;_Up, _Ep&gt;&amp;&amp; __u) noexcept</a>
<a name="ln308">	{</a>
<a name="ln309">	  reset(__u.release());</a>
<a name="ln310">	  get_deleter() = std::forward&lt;_Ep&gt;(__u.get_deleter());</a>
<a name="ln311">	  return *this;</a>
<a name="ln312">	}</a>
<a name="ln313"> </a>
<a name="ln314">      /// Reset the %unique_ptr to empty, invoking the deleter if necessary.</a>
<a name="ln315">      unique_ptr&amp;</a>
<a name="ln316">      operator=(nullptr_t) noexcept</a>
<a name="ln317">      {</a>
<a name="ln318">	reset();</a>
<a name="ln319">	return *this;</a>
<a name="ln320">      }</a>
<a name="ln321"> </a>
<a name="ln322">      // Observers.</a>
<a name="ln323"> </a>
<a name="ln324">      /// Dereference the stored pointer.</a>
<a name="ln325">      typename add_lvalue_reference&lt;element_type&gt;::type</a>
<a name="ln326">      operator*() const</a>
<a name="ln327">      {</a>
<a name="ln328">	__glibcxx_assert(get() != pointer());</a>
<a name="ln329">	return *get();</a>
<a name="ln330">      }</a>
<a name="ln331"> </a>
<a name="ln332">      /// Return the stored pointer.</a>
<a name="ln333">      pointer</a>
<a name="ln334">      operator-&gt;() const noexcept</a>
<a name="ln335">      {</a>
<a name="ln336">	_GLIBCXX_DEBUG_PEDASSERT(get() != pointer());</a>
<a name="ln337">	return get();</a>
<a name="ln338">      }</a>
<a name="ln339"> </a>
<a name="ln340">      /// Return the stored pointer.</a>
<a name="ln341">      pointer</a>
<a name="ln342">      get() const noexcept</a>
<a name="ln343">      { return _M_t._M_ptr(); }</a>
<a name="ln344"> </a>
<a name="ln345">      /// Return a reference to the stored deleter.</a>
<a name="ln346">      deleter_type&amp;</a>
<a name="ln347">      get_deleter() noexcept</a>
<a name="ln348">      { return _M_t._M_deleter(); }</a>
<a name="ln349"> </a>
<a name="ln350">      /// Return a reference to the stored deleter.</a>
<a name="ln351">      const deleter_type&amp;</a>
<a name="ln352">      get_deleter() const noexcept</a>
<a name="ln353">      { return _M_t._M_deleter(); }</a>
<a name="ln354"> </a>
<a name="ln355">      /// Return @c true if the stored pointer is not null.</a>
<a name="ln356">      explicit operator bool() const noexcept</a>
<a name="ln357">      { return get() == pointer() ? false : true; }</a>
<a name="ln358"> </a>
<a name="ln359">      // Modifiers.</a>
<a name="ln360"> </a>
<a name="ln361">      /// Release ownership of any stored pointer.</a>
<a name="ln362">      pointer</a>
<a name="ln363">      release() noexcept</a>
<a name="ln364">      {</a>
<a name="ln365">	pointer __p = get();</a>
<a name="ln366">	_M_t._M_ptr() = pointer();</a>
<a name="ln367">	return __p;</a>
<a name="ln368">      }</a>
<a name="ln369"> </a>
<a name="ln370">      /** @brief Replace the stored pointer.</a>
<a name="ln371">       *</a>
<a name="ln372">       * @param __p  The new pointer to store.</a>
<a name="ln373">       *</a>
<a name="ln374">       * The deleter will be invoked if a pointer is already owned.</a>
<a name="ln375">       */</a>
<a name="ln376">      void</a>
<a name="ln377">      reset(pointer __p = pointer()) noexcept</a>
<a name="ln378">      {</a>
<a name="ln379">	using std::swap;</a>
<a name="ln380">	swap(_M_t._M_ptr(), __p);</a>
<a name="ln381">	if (__p != pointer())</a>
<a name="ln382">	  get_deleter()(__p);</a>
<a name="ln383">      }</a>
<a name="ln384"> </a>
<a name="ln385">      /// Exchange the pointer and deleter with another object.</a>
<a name="ln386">      void</a>
<a name="ln387">      swap(unique_ptr&amp; __u) noexcept</a>
<a name="ln388">      {</a>
<a name="ln389">	using std::swap;</a>
<a name="ln390">	swap(_M_t, __u._M_t);</a>
<a name="ln391">      }</a>
<a name="ln392"> </a>
<a name="ln393">      // Disable copy from lvalue.</a>
<a name="ln394">      unique_ptr(const unique_ptr&amp;) = delete;</a>
<a name="ln395">      unique_ptr&amp; operator=(const unique_ptr&amp;) = delete;</a>
<a name="ln396">  };</a>
<a name="ln397"> </a>
<a name="ln398">  /// 20.7.1.3 unique_ptr for array objects with a runtime length</a>
<a name="ln399">  // [unique.ptr.runtime]</a>
<a name="ln400">  // _GLIBCXX_RESOLVE_LIB_DEFECTS</a>
<a name="ln401">  // DR 740 - omit specialization for array objects with a compile time length</a>
<a name="ln402">  template&lt;typename _Tp, typename _Dp&gt;</a>
<a name="ln403">    class unique_ptr&lt;_Tp[], _Dp&gt;</a>
<a name="ln404">    {</a>
<a name="ln405">      template &lt;typename _Up&gt;</a>
<a name="ln406">      using _DeleterConstraint =</a>
<a name="ln407">	typename __uniq_ptr_impl&lt;_Tp, _Up&gt;::_DeleterConstraint::type;</a>
<a name="ln408"> </a>
<a name="ln409">      __uniq_ptr_impl&lt;_Tp, _Dp&gt; _M_t;</a>
<a name="ln410"> </a>
<a name="ln411">      template&lt;typename _Up&gt;</a>
<a name="ln412">	using __remove_cv = typename remove_cv&lt;_Up&gt;::type;</a>
<a name="ln413"> </a>
<a name="ln414">      // like is_base_of&lt;_Tp, _Up&gt; but false if unqualified types are the same</a>
<a name="ln415">      template&lt;typename _Up&gt;</a>
<a name="ln416">	using __is_derived_Tp</a>
<a name="ln417">	  = __and_&lt; is_base_of&lt;_Tp, _Up&gt;,</a>
<a name="ln418">		    __not_&lt;is_same&lt;__remove_cv&lt;_Tp&gt;, __remove_cv&lt;_Up&gt;&gt;&gt; &gt;;</a>
<a name="ln419"> </a>
<a name="ln420">    public:</a>
<a name="ln421">      using pointer	  = typename __uniq_ptr_impl&lt;_Tp, _Dp&gt;::pointer;</a>
<a name="ln422">      using element_type  = _Tp;</a>
<a name="ln423">      using deleter_type  = _Dp;</a>
<a name="ln424"> </a>
<a name="ln425">      // helper template for detecting a safe conversion from another</a>
<a name="ln426">      // unique_ptr</a>
<a name="ln427">      template&lt;typename _Up, typename _Ep,</a>
<a name="ln428">               typename _Up_up = unique_ptr&lt;_Up, _Ep&gt;,</a>
<a name="ln429">	       typename _Up_element_type = typename _Up_up::element_type&gt;</a>
<a name="ln430">	using __safe_conversion_up = __and_&lt;</a>
<a name="ln431">          is_array&lt;_Up&gt;,</a>
<a name="ln432">          is_same&lt;pointer, element_type*&gt;,</a>
<a name="ln433">          is_same&lt;typename _Up_up::pointer, _Up_element_type*&gt;,</a>
<a name="ln434">          is_convertible&lt;_Up_element_type(*)[], element_type(*)[]&gt;,</a>
<a name="ln435">          __or_&lt;__and_&lt;is_reference&lt;deleter_type&gt;, is_same&lt;deleter_type, _Ep&gt;&gt;,</a>
<a name="ln436">                __and_&lt;__not_&lt;is_reference&lt;deleter_type&gt;&gt;,</a>
<a name="ln437">                       is_convertible&lt;_Ep, deleter_type&gt;&gt;&gt;</a>
<a name="ln438">        &gt;;</a>
<a name="ln439"> </a>
<a name="ln440">      // helper template for detecting a safe conversion from a raw pointer</a>
<a name="ln441">      template&lt;typename _Up&gt;</a>
<a name="ln442">        using __safe_conversion_raw = __and_&lt;</a>
<a name="ln443">          __or_&lt;__or_&lt;is_same&lt;_Up, pointer&gt;,</a>
<a name="ln444">                      is_same&lt;_Up, nullptr_t&gt;&gt;,</a>
<a name="ln445">                __and_&lt;is_pointer&lt;_Up&gt;,</a>
<a name="ln446">                       is_same&lt;pointer, element_type*&gt;,</a>
<a name="ln447">                       is_convertible&lt;</a>
<a name="ln448">                         typename remove_pointer&lt;_Up&gt;::type(*)[],</a>
<a name="ln449">                         element_type(*)[]&gt;</a>
<a name="ln450">                &gt;</a>
<a name="ln451">          &gt;</a>
<a name="ln452">        &gt;;</a>
<a name="ln453"> </a>
<a name="ln454">      // Constructors.</a>
<a name="ln455"> </a>
<a name="ln456">      /// Default constructor, creates a unique_ptr that owns nothing.</a>
<a name="ln457">      template &lt;typename _Up = _Dp,</a>
<a name="ln458">		typename = _DeleterConstraint&lt;_Up&gt;&gt;</a>
<a name="ln459">	constexpr unique_ptr() noexcept</a>
<a name="ln460">	: _M_t()</a>
<a name="ln461">	{ }</a>
<a name="ln462"> </a>
<a name="ln463">      /** Takes ownership of a pointer.</a>
<a name="ln464">       *</a>
<a name="ln465">       * @param __p  A pointer to an array of a type safely convertible</a>
<a name="ln466">       * to an array of @c element_type</a>
<a name="ln467">       *</a>
<a name="ln468">       * The deleter will be value-initialized.</a>
<a name="ln469">       */</a>
<a name="ln470">      template&lt;typename _Up,</a>
<a name="ln471">	       typename _Vp = _Dp,</a>
<a name="ln472">	       typename = _DeleterConstraint&lt;_Vp&gt;,</a>
<a name="ln473">	       typename = typename enable_if&lt;</a>
<a name="ln474">                 __safe_conversion_raw&lt;_Up&gt;::value, bool&gt;::type&gt;</a>
<a name="ln475">	explicit</a>
<a name="ln476">	unique_ptr(_Up __p) noexcept</a>
<a name="ln477">	: _M_t(__p)</a>
<a name="ln478">        { }</a>
<a name="ln479"> </a>
<a name="ln480">      /** Takes ownership of a pointer.</a>
<a name="ln481">       *</a>
<a name="ln482">       * @param __p  A pointer to an array of a type safely convertible</a>
<a name="ln483">       * to an array of @c element_type</a>
<a name="ln484">       * @param __d  A reference to a deleter.</a>
<a name="ln485">       *</a>
<a name="ln486">       * The deleter will be initialized with @p __d</a>
<a name="ln487">       */</a>
<a name="ln488">      template&lt;typename _Up,</a>
<a name="ln489">               typename = typename enable_if&lt;</a>
<a name="ln490">                 __safe_conversion_raw&lt;_Up&gt;::value, bool&gt;::type&gt;</a>
<a name="ln491">      unique_ptr(_Up __p,</a>
<a name="ln492">                 typename conditional&lt;is_reference&lt;deleter_type&gt;::value,</a>
<a name="ln493">                 deleter_type, const deleter_type&amp;&gt;::type __d) noexcept</a>
<a name="ln494">      : _M_t(__p, __d) { }</a>
<a name="ln495"> </a>
<a name="ln496">      /** Takes ownership of a pointer.</a>
<a name="ln497">       *</a>
<a name="ln498">       * @param __p  A pointer to an array of a type safely convertible</a>
<a name="ln499">       * to an array of @c element_type</a>
<a name="ln500">       * @param __d  A reference to a deleter.</a>
<a name="ln501">       *</a>
<a name="ln502">       * The deleter will be initialized with @p std::move(__d)</a>
<a name="ln503">       */</a>
<a name="ln504">      template&lt;typename _Up,</a>
<a name="ln505">               typename = typename enable_if&lt;</a>
<a name="ln506">                 __safe_conversion_raw&lt;_Up&gt;::value, bool&gt;::type&gt;</a>
<a name="ln507">      unique_ptr(_Up __p, typename</a>
<a name="ln508">		 remove_reference&lt;deleter_type&gt;::type&amp;&amp; __d) noexcept</a>
<a name="ln509">      : _M_t(std::move(__p), std::move(__d))</a>
<a name="ln510">      { static_assert(!is_reference&lt;deleter_type&gt;::value,</a>
<a name="ln511">		      &quot;rvalue deleter bound to reference&quot;); }</a>
<a name="ln512"> </a>
<a name="ln513">      /// Move constructor.</a>
<a name="ln514">      unique_ptr(unique_ptr&amp;&amp; __u) noexcept</a>
<a name="ln515">      : _M_t(__u.release(), std::forward&lt;deleter_type&gt;(__u.get_deleter())) { }</a>
<a name="ln516"> </a>
<a name="ln517">      /// Creates a unique_ptr that owns nothing.</a>
<a name="ln518">      template &lt;typename _Up = _Dp,</a>
<a name="ln519">		typename = _DeleterConstraint&lt;_Up&gt;&gt;</a>
<a name="ln520">	constexpr unique_ptr(nullptr_t) noexcept : _M_t() { }</a>
<a name="ln521"> </a>
<a name="ln522">      template&lt;typename _Up, typename _Ep,</a>
<a name="ln523">	       typename = _Require&lt;__safe_conversion_up&lt;_Up, _Ep&gt;&gt;&gt;</a>
<a name="ln524">	unique_ptr(unique_ptr&lt;_Up, _Ep&gt;&amp;&amp; __u) noexcept</a>
<a name="ln525">	: _M_t(__u.release(), std::forward&lt;_Ep&gt;(__u.get_deleter()))</a>
<a name="ln526">	{ }</a>
<a name="ln527"> </a>
<a name="ln528">      /// Destructor, invokes the deleter if the stored pointer is not null.</a>
<a name="ln529">      ~unique_ptr()</a>
<a name="ln530">      {</a>
<a name="ln531">	auto&amp; __ptr = _M_t._M_ptr();</a>
<a name="ln532">	if (__ptr != nullptr)</a>
<a name="ln533">	  get_deleter()(__ptr);</a>
<a name="ln534">	__ptr = pointer();</a>
<a name="ln535">      }</a>
<a name="ln536"> </a>
<a name="ln537">      // Assignment.</a>
<a name="ln538"> </a>
<a name="ln539">      /** @brief Move assignment operator.</a>
<a name="ln540">       *</a>
<a name="ln541">       * @param __u  The object to transfer ownership from.</a>
<a name="ln542">       *</a>
<a name="ln543">       * Invokes the deleter first if this object owns a pointer.</a>
<a name="ln544">       */</a>
<a name="ln545">      unique_ptr&amp;</a>
<a name="ln546">      operator=(unique_ptr&amp;&amp; __u) noexcept</a>
<a name="ln547">      {</a>
<a name="ln548">	reset(__u.release());</a>
<a name="ln549">	get_deleter() = std::forward&lt;deleter_type&gt;(__u.get_deleter());</a>
<a name="ln550">	return *this;</a>
<a name="ln551">      }</a>
<a name="ln552"> </a>
<a name="ln553">      /** @brief Assignment from another type.</a>
<a name="ln554">       *</a>
<a name="ln555">       * @param __u  The object to transfer ownership from, which owns a</a>
<a name="ln556">       *             convertible pointer to an array object.</a>
<a name="ln557">       *</a>
<a name="ln558">       * Invokes the deleter first if this object owns a pointer.</a>
<a name="ln559">       */</a>
<a name="ln560">      template&lt;typename _Up, typename _Ep&gt;</a>
<a name="ln561">	typename</a>
<a name="ln562">	enable_if&lt;__and_&lt;__safe_conversion_up&lt;_Up, _Ep&gt;,</a>
<a name="ln563">                         is_assignable&lt;deleter_type&amp;, _Ep&amp;&amp;&gt;</a>
<a name="ln564">                  &gt;::value,</a>
<a name="ln565">                  unique_ptr&amp;&gt;::type</a>
<a name="ln566">	operator=(unique_ptr&lt;_Up, _Ep&gt;&amp;&amp; __u) noexcept</a>
<a name="ln567">	{</a>
<a name="ln568">	  reset(__u.release());</a>
<a name="ln569">	  get_deleter() = std::forward&lt;_Ep&gt;(__u.get_deleter());</a>
<a name="ln570">	  return *this;</a>
<a name="ln571">	}</a>
<a name="ln572"> </a>
<a name="ln573">      /// Reset the %unique_ptr to empty, invoking the deleter if necessary.</a>
<a name="ln574">      unique_ptr&amp;</a>
<a name="ln575">      operator=(nullptr_t) noexcept</a>
<a name="ln576">      {</a>
<a name="ln577">	reset();</a>
<a name="ln578">	return *this;</a>
<a name="ln579">      }</a>
<a name="ln580"> </a>
<a name="ln581">      // Observers.</a>
<a name="ln582"> </a>
<a name="ln583">      /// Access an element of owned array.</a>
<a name="ln584">      typename std::add_lvalue_reference&lt;element_type&gt;::type</a>
<a name="ln585">      operator[](size_t __i) const</a>
<a name="ln586">      {</a>
<a name="ln587">	__glibcxx_assert(get() != pointer());</a>
<a name="ln588">	return get()[__i];</a>
<a name="ln589">      }</a>
<a name="ln590"> </a>
<a name="ln591">      /// Return the stored pointer.</a>
<a name="ln592">      pointer</a>
<a name="ln593">      get() const noexcept</a>
<a name="ln594">      { return _M_t._M_ptr(); }</a>
<a name="ln595"> </a>
<a name="ln596">      /// Return a reference to the stored deleter.</a>
<a name="ln597">      deleter_type&amp;</a>
<a name="ln598">      get_deleter() noexcept</a>
<a name="ln599">      { return _M_t._M_deleter(); }</a>
<a name="ln600"> </a>
<a name="ln601">      /// Return a reference to the stored deleter.</a>
<a name="ln602">      const deleter_type&amp;</a>
<a name="ln603">      get_deleter() const noexcept</a>
<a name="ln604">      { return _M_t._M_deleter(); }</a>
<a name="ln605"> </a>
<a name="ln606">      /// Return @c true if the stored pointer is not null.</a>
<a name="ln607">      explicit operator bool() const noexcept</a>
<a name="ln608">      { return get() == pointer() ? false : true; }</a>
<a name="ln609"> </a>
<a name="ln610">      // Modifiers.</a>
<a name="ln611"> </a>
<a name="ln612">      /// Release ownership of any stored pointer.</a>
<a name="ln613">      pointer</a>
<a name="ln614">      release() noexcept</a>
<a name="ln615">      {</a>
<a name="ln616">	pointer __p = get();</a>
<a name="ln617">	_M_t._M_ptr() = pointer();</a>
<a name="ln618">	return __p;</a>
<a name="ln619">      }</a>
<a name="ln620"> </a>
<a name="ln621">      /** @brief Replace the stored pointer.</a>
<a name="ln622">       *</a>
<a name="ln623">       * @param __p  The new pointer to store.</a>
<a name="ln624">       *</a>
<a name="ln625">       * The deleter will be invoked if a pointer is already owned.</a>
<a name="ln626">       */</a>
<a name="ln627">      template &lt;typename _Up,</a>
<a name="ln628">                typename = _Require&lt;</a>
<a name="ln629">                  __or_&lt;is_same&lt;_Up, pointer&gt;,</a>
<a name="ln630">                        __and_&lt;is_same&lt;pointer, element_type*&gt;,</a>
<a name="ln631">                               is_pointer&lt;_Up&gt;,</a>
<a name="ln632">                               is_convertible&lt;</a>
<a name="ln633">                                 typename remove_pointer&lt;_Up&gt;::type(*)[],</a>
<a name="ln634">                                 element_type(*)[]</a>
<a name="ln635">                               &gt;</a>
<a name="ln636">                        &gt;</a>
<a name="ln637">                  &gt;</a>
<a name="ln638">               &gt;&gt;</a>
<a name="ln639">      void</a>
<a name="ln640">      reset(_Up __p) noexcept</a>
<a name="ln641">      {</a>
<a name="ln642">	pointer __ptr = __p;</a>
<a name="ln643">	using std::swap;</a>
<a name="ln644">	swap(_M_t._M_ptr(), __ptr);</a>
<a name="ln645">	if (__ptr != nullptr)</a>
<a name="ln646">	  get_deleter()(__ptr);</a>
<a name="ln647">      }</a>
<a name="ln648"> </a>
<a name="ln649">      void reset(nullptr_t = nullptr) noexcept</a>
<a name="ln650">      {</a>
<a name="ln651">        reset(pointer());</a>
<a name="ln652">      }</a>
<a name="ln653"> </a>
<a name="ln654">      /// Exchange the pointer and deleter with another object.</a>
<a name="ln655">      void</a>
<a name="ln656">      swap(unique_ptr&amp; __u) noexcept</a>
<a name="ln657">      {</a>
<a name="ln658">	using std::swap;</a>
<a name="ln659">	swap(_M_t, __u._M_t);</a>
<a name="ln660">      }</a>
<a name="ln661"> </a>
<a name="ln662">      // Disable copy from lvalue.</a>
<a name="ln663">      unique_ptr(const unique_ptr&amp;) = delete;</a>
<a name="ln664">      unique_ptr&amp; operator=(const unique_ptr&amp;) = delete;</a>
<a name="ln665">    };</a>
<a name="ln666"> </a>
<a name="ln667">  template&lt;typename _Tp, typename _Dp&gt;</a>
<a name="ln668">    inline</a>
<a name="ln669">#if __cplusplus &gt; 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11</a>
<a name="ln670">    // Constrained free swap overload, see p0185r1</a>
<a name="ln671">    typename enable_if&lt;__is_swappable&lt;_Dp&gt;::value&gt;::type</a>
<a name="ln672">#else</a>
<a name="ln673">    void</a>
<a name="ln674">#endif</a>
<a name="ln675">    swap(unique_ptr&lt;_Tp, _Dp&gt;&amp; __x,</a>
<a name="ln676">	 unique_ptr&lt;_Tp, _Dp&gt;&amp; __y) noexcept</a>
<a name="ln677">    { __x.swap(__y); }</a>
<a name="ln678"> </a>
<a name="ln679">#if __cplusplus &gt; 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11</a>
<a name="ln680">  template&lt;typename _Tp, typename _Dp&gt;</a>
<a name="ln681">    typename enable_if&lt;!__is_swappable&lt;_Dp&gt;::value&gt;::type</a>
<a name="ln682">    swap(unique_ptr&lt;_Tp, _Dp&gt;&amp;,</a>
<a name="ln683">	 unique_ptr&lt;_Tp, _Dp&gt;&amp;) = delete;</a>
<a name="ln684">#endif</a>
<a name="ln685"> </a>
<a name="ln686">  template&lt;typename _Tp, typename _Dp,</a>
<a name="ln687">	   typename _Up, typename _Ep&gt;</a>
<a name="ln688">    inline bool</a>
<a name="ln689">    operator==(const unique_ptr&lt;_Tp, _Dp&gt;&amp; __x,</a>
<a name="ln690">	       const unique_ptr&lt;_Up, _Ep&gt;&amp; __y)</a>
<a name="ln691">    { return __x.get() == __y.get(); }</a>
<a name="ln692"> </a>
<a name="ln693">  template&lt;typename _Tp, typename _Dp&gt;</a>
<a name="ln694">    inline bool</a>
<a name="ln695">    operator==(const unique_ptr&lt;_Tp, _Dp&gt;&amp; __x, nullptr_t) noexcept</a>
<a name="ln696">    { return !__x; }</a>
<a name="ln697"> </a>
<a name="ln698">  template&lt;typename _Tp, typename _Dp&gt;</a>
<a name="ln699">    inline bool</a>
<a name="ln700">    operator==(nullptr_t, const unique_ptr&lt;_Tp, _Dp&gt;&amp; __x) noexcept</a>
<a name="ln701">    { return !__x; }</a>
<a name="ln702"> </a>
<a name="ln703">  template&lt;typename _Tp, typename _Dp,</a>
<a name="ln704">	   typename _Up, typename _Ep&gt;</a>
<a name="ln705">    inline bool</a>
<a name="ln706">    operator!=(const unique_ptr&lt;_Tp, _Dp&gt;&amp; __x,</a>
<a name="ln707">	       const unique_ptr&lt;_Up, _Ep&gt;&amp; __y)</a>
<a name="ln708">    { return __x.get() != __y.get(); }</a>
<a name="ln709"> </a>
<a name="ln710">  template&lt;typename _Tp, typename _Dp&gt;</a>
<a name="ln711">    inline bool</a>
<a name="ln712">    operator!=(const unique_ptr&lt;_Tp, _Dp&gt;&amp; __x, nullptr_t) noexcept</a>
<a name="ln713">    { return (bool)__x; }</a>
<a name="ln714"> </a>
<a name="ln715">  template&lt;typename _Tp, typename _Dp&gt;</a>
<a name="ln716">    inline bool</a>
<a name="ln717">    operator!=(nullptr_t, const unique_ptr&lt;_Tp, _Dp&gt;&amp; __x) noexcept</a>
<a name="ln718">    { return (bool)__x; }</a>
<a name="ln719"> </a>
<a name="ln720">  template&lt;typename _Tp, typename _Dp,</a>
<a name="ln721">	   typename _Up, typename _Ep&gt;</a>
<a name="ln722">    inline bool</a>
<a name="ln723">    operator&lt;(const unique_ptr&lt;_Tp, _Dp&gt;&amp; __x,</a>
<a name="ln724">	      const unique_ptr&lt;_Up, _Ep&gt;&amp; __y)</a>
<a name="ln725">    {</a>
<a name="ln726">      typedef typename</a>
<a name="ln727">	std::common_type&lt;typename unique_ptr&lt;_Tp, _Dp&gt;::pointer,</a>
<a name="ln728">	                 typename unique_ptr&lt;_Up, _Ep&gt;::pointer&gt;::type _CT;</a>
<a name="ln729">      return std::less&lt;_CT&gt;()(__x.get(), __y.get());</a>
<a name="ln730">    }</a>
<a name="ln731"> </a>
<a name="ln732">  template&lt;typename _Tp, typename _Dp&gt;</a>
<a name="ln733">    inline bool</a>
<a name="ln734">    operator&lt;(const unique_ptr&lt;_Tp, _Dp&gt;&amp; __x, nullptr_t)</a>
<a name="ln735">    { return std::less&lt;typename unique_ptr&lt;_Tp, _Dp&gt;::pointer&gt;()(__x.get(),</a>
<a name="ln736">								 nullptr); }</a>
<a name="ln737"> </a>
<a name="ln738">  template&lt;typename _Tp, typename _Dp&gt;</a>
<a name="ln739">    inline bool</a>
<a name="ln740">    operator&lt;(nullptr_t, const unique_ptr&lt;_Tp, _Dp&gt;&amp; __x)</a>
<a name="ln741">    { return std::less&lt;typename unique_ptr&lt;_Tp, _Dp&gt;::pointer&gt;()(nullptr,</a>
<a name="ln742">								 __x.get()); }</a>
<a name="ln743"> </a>
<a name="ln744">  template&lt;typename _Tp, typename _Dp,</a>
<a name="ln745">	   typename _Up, typename _Ep&gt;</a>
<a name="ln746">    inline bool</a>
<a name="ln747">    operator&lt;=(const unique_ptr&lt;_Tp, _Dp&gt;&amp; __x,</a>
<a name="ln748">	       const unique_ptr&lt;_Up, _Ep&gt;&amp; __y)</a>
<a name="ln749">    { return !(__y &lt; __x); }</a>
<a name="ln750"> </a>
<a name="ln751">  template&lt;typename _Tp, typename _Dp&gt;</a>
<a name="ln752">    inline bool</a>
<a name="ln753">    operator&lt;=(const unique_ptr&lt;_Tp, _Dp&gt;&amp; __x, nullptr_t)</a>
<a name="ln754">    { return !(nullptr &lt; __x); }</a>
<a name="ln755"> </a>
<a name="ln756">  template&lt;typename _Tp, typename _Dp&gt;</a>
<a name="ln757">    inline bool</a>
<a name="ln758">    operator&lt;=(nullptr_t, const unique_ptr&lt;_Tp, _Dp&gt;&amp; __x)</a>
<a name="ln759">    { return !(__x &lt; nullptr); }</a>
<a name="ln760"> </a>
<a name="ln761">  template&lt;typename _Tp, typename _Dp,</a>
<a name="ln762">	   typename _Up, typename _Ep&gt;</a>
<a name="ln763">    inline bool</a>
<a name="ln764">    operator&gt;(const unique_ptr&lt;_Tp, _Dp&gt;&amp; __x,</a>
<a name="ln765">	      const unique_ptr&lt;_Up, _Ep&gt;&amp; __y)</a>
<a name="ln766">    { return (__y &lt; __x); }</a>
<a name="ln767"> </a>
<a name="ln768">  template&lt;typename _Tp, typename _Dp&gt;</a>
<a name="ln769">    inline bool</a>
<a name="ln770">    operator&gt;(const unique_ptr&lt;_Tp, _Dp&gt;&amp; __x, nullptr_t)</a>
<a name="ln771">    { return std::less&lt;typename unique_ptr&lt;_Tp, _Dp&gt;::pointer&gt;()(nullptr,</a>
<a name="ln772">								 __x.get()); }</a>
<a name="ln773"> </a>
<a name="ln774">  template&lt;typename _Tp, typename _Dp&gt;</a>
<a name="ln775">    inline bool</a>
<a name="ln776">    operator&gt;(nullptr_t, const unique_ptr&lt;_Tp, _Dp&gt;&amp; __x)</a>
<a name="ln777">    { return std::less&lt;typename unique_ptr&lt;_Tp, _Dp&gt;::pointer&gt;()(__x.get(),</a>
<a name="ln778">								 nullptr); }</a>
<a name="ln779"> </a>
<a name="ln780">  template&lt;typename _Tp, typename _Dp,</a>
<a name="ln781">	   typename _Up, typename _Ep&gt;</a>
<a name="ln782">    inline bool</a>
<a name="ln783">    operator&gt;=(const unique_ptr&lt;_Tp, _Dp&gt;&amp; __x,</a>
<a name="ln784">	       const unique_ptr&lt;_Up, _Ep&gt;&amp; __y)</a>
<a name="ln785">    { return !(__x &lt; __y); }</a>
<a name="ln786"> </a>
<a name="ln787">  template&lt;typename _Tp, typename _Dp&gt;</a>
<a name="ln788">    inline bool</a>
<a name="ln789">    operator&gt;=(const unique_ptr&lt;_Tp, _Dp&gt;&amp; __x, nullptr_t)</a>
<a name="ln790">    { return !(__x &lt; nullptr); }</a>
<a name="ln791"> </a>
<a name="ln792">  template&lt;typename _Tp, typename _Dp&gt;</a>
<a name="ln793">    inline bool</a>
<a name="ln794">    operator&gt;=(nullptr_t, const unique_ptr&lt;_Tp, _Dp&gt;&amp; __x)</a>
<a name="ln795">    { return !(nullptr &lt; __x); }</a>
<a name="ln796"> </a>
<a name="ln797">  /// std::hash specialization for unique_ptr.</a>
<a name="ln798">  template&lt;typename _Tp, typename _Dp&gt;</a>
<a name="ln799">    struct hash&lt;unique_ptr&lt;_Tp, _Dp&gt;&gt;</a>
<a name="ln800">    : public __hash_base&lt;size_t, unique_ptr&lt;_Tp, _Dp&gt;&gt;,</a>
<a name="ln801">    private __poison_hash&lt;typename unique_ptr&lt;_Tp, _Dp&gt;::pointer&gt;</a>
<a name="ln802">    {</a>
<a name="ln803">      size_t</a>
<a name="ln804">      operator()(const unique_ptr&lt;_Tp, _Dp&gt;&amp; __u) const noexcept</a>
<a name="ln805">      {</a>
<a name="ln806">	typedef unique_ptr&lt;_Tp, _Dp&gt; _UP;</a>
<a name="ln807">	return std::hash&lt;typename _UP::pointer&gt;()(__u.get());</a>
<a name="ln808">      }</a>
<a name="ln809">    };</a>
<a name="ln810"> </a>
<a name="ln811">#if __cplusplus &gt; 201103L</a>
<a name="ln812"> </a>
<a name="ln813">#define __cpp_lib_make_unique 201304</a>
<a name="ln814"> </a>
<a name="ln815">  template&lt;typename _Tp&gt;</a>
<a name="ln816">    struct _MakeUniq</a>
<a name="ln817">    { typedef unique_ptr&lt;_Tp&gt; __single_object; };</a>
<a name="ln818"> </a>
<a name="ln819">  template&lt;typename _Tp&gt;</a>
<a name="ln820">    struct _MakeUniq&lt;_Tp[]&gt;</a>
<a name="ln821">    { typedef unique_ptr&lt;_Tp[]&gt; __array; };</a>
<a name="ln822"> </a>
<a name="ln823">  template&lt;typename _Tp, size_t _Bound&gt;</a>
<a name="ln824">    struct _MakeUniq&lt;_Tp[_Bound]&gt;</a>
<a name="ln825">    { struct __invalid_type { }; };</a>
<a name="ln826"> </a>
<a name="ln827">  /// std::make_unique for single objects</a>
<a name="ln828">  template&lt;typename _Tp, typename... _Args&gt;</a>
<a name="ln829">    inline typename _MakeUniq&lt;_Tp&gt;::__single_object</a>
<a name="ln830">    make_unique(_Args&amp;&amp;... __args)</a>
<a name="ln831">    { return unique_ptr&lt;_Tp&gt;(new _Tp(std::forward&lt;_Args&gt;(__args)...)); }</a>
<a name="ln832"> </a>
<a name="ln833">  /// std::make_unique for arrays of unknown bound</a>
<a name="ln834">  template&lt;typename _Tp&gt;</a>
<a name="ln835">    inline typename _MakeUniq&lt;_Tp&gt;::__array</a>
<a name="ln836">    make_unique(size_t __num)</a>
<a name="ln837">    { return unique_ptr&lt;_Tp&gt;(new remove_extent_t&lt;_Tp&gt;[__num]()); }</a>
<a name="ln838"> </a>
<a name="ln839">  /// Disable std::make_unique for arrays of known bound</a>
<a name="ln840">  template&lt;typename _Tp, typename... _Args&gt;</a>
<a name="ln841">    inline typename _MakeUniq&lt;_Tp&gt;::__invalid_type</a>
<a name="ln842">    make_unique(_Args&amp;&amp;...) = delete;</a>
<a name="ln843">#endif</a>
<a name="ln844"> </a>
<a name="ln845">  // @} group pointer_abstractions</a>
<a name="ln846"> </a>
<a name="ln847">_GLIBCXX_END_NAMESPACE_VERSION</a>
<a name="ln848">} // namespace</a>
<a name="ln849"> </a>
<a name="ln850">#endif /* _UNIQUE_PTR_H */</a>

</code></pre>
<div class="balloon" rel="288"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v794/" target="_blank">V794</a> The assignment operator should be protected from the case of 'this == &__u'.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
