
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ldb_cmd.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//  Copyright (c) 2011-present, Facebook, Inc.  All rights reserved.</a>
<a name="ln2">//  This source code is licensed under the BSD-style license found in the</a>
<a name="ln3">//  LICENSE file in the root directory of this source tree. An additional grant</a>
<a name="ln4">//  of patent rights can be found in the PATENTS file in the same directory.</a>
<a name="ln5">//</a>
<a name="ln6">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln7">//</a>
<a name="ln8">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln9">//</a>
<a name="ln10">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln11">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln12">//</a>
<a name="ln13">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln14">//</a>
<a name="ln15">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln16">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln17">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln18">// under the License.</a>
<a name="ln19">//</a>
<a name="ln20">#ifndef ROCKSDB_LITE</a>
<a name="ln21">#include &quot;yb/rocksdb/tools/ldb_cmd.h&quot;</a>
<a name="ln22"> </a>
<a name="ln23">#ifndef __STDC_FORMAT_MACROS</a>
<a name="ln24">#define __STDC_FORMAT_MACROS</a>
<a name="ln25">#endif</a>
<a name="ln26"> </a>
<a name="ln27">#include &lt;inttypes.h&gt;</a>
<a name="ln28"> </a>
<a name="ln29">#include &lt;cstdlib&gt;</a>
<a name="ln30">#include &lt;ctime&gt;</a>
<a name="ln31">#include &lt;limits&gt;</a>
<a name="ln32">#include &lt;sstream&gt;</a>
<a name="ln33">#include &lt;string&gt;</a>
<a name="ln34">#include &lt;stdexcept&gt;</a>
<a name="ln35"> </a>
<a name="ln36">#include &quot;yb/rocksdb/db/dbformat.h&quot;</a>
<a name="ln37">#include &quot;yb/rocksdb/db/db_impl.h&quot;</a>
<a name="ln38">#include &quot;yb/rocksdb/db/log_reader.h&quot;</a>
<a name="ln39">#include &quot;yb/rocksdb/db/filename.h&quot;</a>
<a name="ln40">#include &quot;yb/rocksdb/db/writebuffer.h&quot;</a>
<a name="ln41">#include &quot;yb/rocksdb/db/write_batch_internal.h&quot;</a>
<a name="ln42">#include &quot;yb/rocksdb/write_batch.h&quot;</a>
<a name="ln43">#include &quot;yb/rocksdb/cache.h&quot;</a>
<a name="ln44">#include &quot;yb/rocksdb/table_properties.h&quot;</a>
<a name="ln45">#include &quot;yb/rocksdb/table/scoped_arena_iterator.h&quot;</a>
<a name="ln46">#include &quot;yb/rocksdb/port/dirent.h&quot;</a>
<a name="ln47">#include &quot;yb/rocksdb/tools/sst_dump_tool_imp.h&quot;</a>
<a name="ln48">#include &quot;yb/rocksdb/util/coding.h&quot;</a>
<a name="ln49">#include &quot;yb/util/string_util.h&quot;</a>
<a name="ln50">#include &quot;yb/rocksdb/utilities/ttl/db_ttl_impl.h&quot;</a>
<a name="ln51"> </a>
<a name="ln52">namespace rocksdb {</a>
<a name="ln53"> </a>
<a name="ln54">using std::string;</a>
<a name="ln55"> </a>
<a name="ln56">const string LDBCommand::ARG_DB = &quot;db&quot;;</a>
<a name="ln57">const string LDBCommand::ARG_PATH = &quot;path&quot;;</a>
<a name="ln58">const string LDBCommand::ARG_HEX = &quot;hex&quot;;</a>
<a name="ln59">const string LDBCommand::ARG_KEY_HEX = &quot;key_hex&quot;;</a>
<a name="ln60">const string LDBCommand::ARG_VALUE_HEX = &quot;value_hex&quot;;</a>
<a name="ln61">const string LDBCommand::ARG_CF_NAME = &quot;column_family&quot;;</a>
<a name="ln62">const string LDBCommand::ARG_TTL = &quot;ttl&quot;;</a>
<a name="ln63">const string LDBCommand::ARG_TTL_START = &quot;start_time&quot;;</a>
<a name="ln64">const string LDBCommand::ARG_TTL_END = &quot;end_time&quot;;</a>
<a name="ln65">const string LDBCommand::ARG_TIMESTAMP = &quot;timestamp&quot;;</a>
<a name="ln66">const string LDBCommand::ARG_FROM = &quot;from&quot;;</a>
<a name="ln67">const string LDBCommand::ARG_TO = &quot;to&quot;;</a>
<a name="ln68">const string LDBCommand::ARG_MAX_KEYS = &quot;max_keys&quot;;</a>
<a name="ln69">const string LDBCommand::ARG_BLOOM_BITS = &quot;bloom_bits&quot;;</a>
<a name="ln70">const string LDBCommand::ARG_FIX_PREFIX_LEN = &quot;fix_prefix_len&quot;;</a>
<a name="ln71">const string LDBCommand::ARG_COMPRESSION_TYPE = &quot;compression_type&quot;;</a>
<a name="ln72">const string LDBCommand::ARG_BLOCK_SIZE = &quot;block_size&quot;;</a>
<a name="ln73">const string LDBCommand::ARG_AUTO_COMPACTION = &quot;auto_compaction&quot;;</a>
<a name="ln74">const string LDBCommand::ARG_DB_WRITE_BUFFER_SIZE = &quot;db_write_buffer_size&quot;;</a>
<a name="ln75">const string LDBCommand::ARG_WRITE_BUFFER_SIZE = &quot;write_buffer_size&quot;;</a>
<a name="ln76">const string LDBCommand::ARG_FILE_SIZE = &quot;file_size&quot;;</a>
<a name="ln77">const string LDBCommand::ARG_CREATE_IF_MISSING = &quot;create_if_missing&quot;;</a>
<a name="ln78">const string LDBCommand::ARG_NO_VALUE = &quot;no_value&quot;;</a>
<a name="ln79">const string LDBCommand::ARG_UNIVERSE_KEY_FILE = &quot;key_file&quot;;</a>
<a name="ln80">const string LDBCommand::ARG_ONLY_VERIFY_CHECKSUMS = &quot;only_verify_checksums&quot;;</a>
<a name="ln81"> </a>
<a name="ln82">const char* LDBCommand::DELIM = &quot; ==&gt; &quot;;</a>
<a name="ln83"> </a>
<a name="ln84">namespace {</a>
<a name="ln85"> </a>
<a name="ln86">void DumpWalFile(std::string wal_file, bool print_header, bool print_values,</a>
<a name="ln87">                 LDBCommandExecuteResult* exec_state);</a>
<a name="ln88"> </a>
<a name="ln89">void DumpSstFile(std::string filename, bool output_hex, bool show_properties);</a>
<a name="ln90">};</a>
<a name="ln91"> </a>
<a name="ln92">LDBCommand* LDBCommand::InitFromCmdLineArgs(</a>
<a name="ln93">    int argc, char** argv, const Options&amp; options,</a>
<a name="ln94">    const LDBOptions&amp; ldb_options,</a>
<a name="ln95">    const std::vector&lt;ColumnFamilyDescriptor&gt;* column_families) {</a>
<a name="ln96">  vector&lt;string&gt; args;</a>
<a name="ln97">  for (int i = 1; i &lt; argc; i++) {</a>
<a name="ln98">    args.push_back(argv[i]);</a>
<a name="ln99">  }</a>
<a name="ln100">  return InitFromCmdLineArgs(args, options, ldb_options, column_families);</a>
<a name="ln101">}</a>
<a name="ln102"> </a>
<a name="ln103">/**</a>
<a name="ln104"> * Parse the command-line arguments and create the appropriate LDBCommand2</a>
<a name="ln105"> * instance.</a>
<a name="ln106"> * The command line arguments must be in the following format:</a>
<a name="ln107"> * ./ldb --db=PATH_TO_DB [--commonOpt1=commonOpt1Val] ..</a>
<a name="ln108"> *        COMMAND &lt;PARAM1&gt; &lt;PARAM2&gt; ... [-cmdSpecificOpt1=cmdSpecificOpt1Val] ..</a>
<a name="ln109"> * This is similar to the command line format used by HBaseClientTool.</a>
<a name="ln110"> * Command name is not included in args.</a>
<a name="ln111"> * Returns nullptr if the command-line cannot be parsed.</a>
<a name="ln112"> */</a>
<a name="ln113">LDBCommand* LDBCommand::InitFromCmdLineArgs(</a>
<a name="ln114">    const vector&lt;string&gt;&amp; args, const Options&amp; options,</a>
<a name="ln115">    const LDBOptions&amp; ldb_options,</a>
<a name="ln116">    const std::vector&lt;ColumnFamilyDescriptor&gt;* column_families) {</a>
<a name="ln117">  // --x=y command line arguments are added as x-&gt;y map entries.</a>
<a name="ln118">  map&lt;string, string&gt; option_map;</a>
<a name="ln119"> </a>
<a name="ln120">  // Command-line arguments of the form --hex end up in this array as hex</a>
<a name="ln121">  vector&lt;string&gt; flags;</a>
<a name="ln122"> </a>
<a name="ln123">  // Everything other than option_map and flags. Represents commands</a>
<a name="ln124">  // and their parameters.  For eg: put key1 value1 go into this vector.</a>
<a name="ln125">  vector&lt;string&gt; cmdTokens;</a>
<a name="ln126"> </a>
<a name="ln127">  const string OPTION_PREFIX = &quot;--&quot;;</a>
<a name="ln128"> </a>
<a name="ln129">  for (const auto&amp; arg : args) {</a>
<a name="ln130">    if (arg[0] == '-' &amp;&amp; arg[1] == '-') {</a>
<a name="ln131">      auto pos = arg.find('=', 0);</a>
<a name="ln132">      if (pos != string::npos) {</a>
<a name="ln133">        string optionKey = arg.substr(OPTION_PREFIX.size(), pos - OPTION_PREFIX.size());</a>
<a name="ln134">        option_map[optionKey] = arg.substr(pos + 1);</a>
<a name="ln135">      } else {</a>
<a name="ln136">        string optionKey = arg.substr(OPTION_PREFIX.size());</a>
<a name="ln137">        flags.push_back(optionKey);</a>
<a name="ln138">      }</a>
<a name="ln139">    } else {</a>
<a name="ln140">      cmdTokens.push_back(arg);</a>
<a name="ln141">    }</a>
<a name="ln142">  }</a>
<a name="ln143"> </a>
<a name="ln144">  if (cmdTokens.size() &lt; 1) {</a>
<a name="ln145">    fprintf(stderr, &quot;Command not specified!&quot;);</a>
<a name="ln146">    return nullptr;</a>
<a name="ln147">  }</a>
<a name="ln148"> </a>
<a name="ln149">  string cmd = cmdTokens[0];</a>
<a name="ln150">  vector&lt;string&gt; cmdParams(cmdTokens.begin()+1, cmdTokens.end());</a>
<a name="ln151">  LDBCommand* command = LDBCommand::SelectCommand(</a>
<a name="ln152">    cmd,</a>
<a name="ln153">    cmdParams,</a>
<a name="ln154">    option_map,</a>
<a name="ln155">    flags</a>
<a name="ln156">  );</a>
<a name="ln157"> </a>
<a name="ln158">  if (command) {</a>
<a name="ln159">    command-&gt;SetDBOptions(options);</a>
<a name="ln160">    command-&gt;SetLDBOptions(ldb_options);</a>
<a name="ln161">  }</a>
<a name="ln162">  return command;</a>
<a name="ln163">}</a>
<a name="ln164"> </a>
<a name="ln165">LDBCommand* LDBCommand::SelectCommand(</a>
<a name="ln166">    const std::string&amp; cmd,</a>
<a name="ln167">    const vector&lt;string&gt;&amp; cmdParams,</a>
<a name="ln168">    const map&lt;string, string&gt;&amp; option_map,</a>
<a name="ln169">    const vector&lt;string&gt;&amp; flags</a>
<a name="ln170">  ) {</a>
<a name="ln171"> </a>
<a name="ln172">  if (cmd == GetCommand::Name()) {</a>
<a name="ln173">    return new GetCommand(cmdParams, option_map, flags);</a>
<a name="ln174">  } else if (cmd == PutCommand::Name()) {</a>
<a name="ln175">    return new PutCommand(cmdParams, option_map, flags);</a>
<a name="ln176">  } else if (cmd == BatchPutCommand::Name()) {</a>
<a name="ln177">    return new BatchPutCommand(cmdParams, option_map, flags);</a>
<a name="ln178">  } else if (cmd == ScanCommand::Name()) {</a>
<a name="ln179">    return new ScanCommand(cmdParams, option_map, flags);</a>
<a name="ln180">  } else if (cmd == DeleteCommand::Name()) {</a>
<a name="ln181">    return new DeleteCommand(cmdParams, option_map, flags);</a>
<a name="ln182">  } else if (cmd == ApproxSizeCommand::Name()) {</a>
<a name="ln183">    return new ApproxSizeCommand(cmdParams, option_map, flags);</a>
<a name="ln184">  } else if (cmd == DBQuerierCommand::Name()) {</a>
<a name="ln185">    return new DBQuerierCommand(cmdParams, option_map, flags);</a>
<a name="ln186">  } else if (cmd == CompactorCommand::Name()) {</a>
<a name="ln187">    return new CompactorCommand(cmdParams, option_map, flags);</a>
<a name="ln188">  } else if (cmd == WALDumperCommand::Name()) {</a>
<a name="ln189">    return new WALDumperCommand(cmdParams, option_map, flags);</a>
<a name="ln190">  } else if (cmd == ReduceDBLevelsCommand::Name()) {</a>
<a name="ln191">    return new ReduceDBLevelsCommand(cmdParams, option_map, flags);</a>
<a name="ln192">  } else if (cmd == ChangeCompactionStyleCommand::Name()) {</a>
<a name="ln193">    return new ChangeCompactionStyleCommand(cmdParams, option_map, flags);</a>
<a name="ln194">  } else if (cmd == DBDumperCommand::Name()) {</a>
<a name="ln195">    return new DBDumperCommand(cmdParams, option_map, flags);</a>
<a name="ln196">  } else if (cmd == DBLoaderCommand::Name()) {</a>
<a name="ln197">    return new DBLoaderCommand(cmdParams, option_map, flags);</a>
<a name="ln198">  } else if (cmd == ManifestDumpCommand::Name()) {</a>
<a name="ln199">    return new ManifestDumpCommand(cmdParams, option_map, flags);</a>
<a name="ln200">  } else if (cmd == ListColumnFamiliesCommand::Name()) {</a>
<a name="ln201">    return new ListColumnFamiliesCommand(cmdParams, option_map, flags);</a>
<a name="ln202">  } else if (cmd == CreateColumnFamilyCommand::Name()) {</a>
<a name="ln203">    return new CreateColumnFamilyCommand(cmdParams, option_map, flags);</a>
<a name="ln204">  } else if (cmd == DBFileDumperCommand::Name()) {</a>
<a name="ln205">    return new DBFileDumperCommand(cmdParams, option_map, flags);</a>
<a name="ln206">  } else if (cmd == InternalDumpCommand::Name()) {</a>
<a name="ln207">    return new InternalDumpCommand(cmdParams, option_map, flags);</a>
<a name="ln208">  } else if (cmd == CheckConsistencyCommand::Name()) {</a>
<a name="ln209">    return new CheckConsistencyCommand(cmdParams, option_map, flags);</a>
<a name="ln210">  }</a>
<a name="ln211">  return nullptr;</a>
<a name="ln212">}</a>
<a name="ln213"> </a>
<a name="ln214"> </a>
<a name="ln215">/**</a>
<a name="ln216"> * Parses the specific integer option and fills in the value.</a>
<a name="ln217"> * Returns true if the option is found.</a>
<a name="ln218"> * Returns false if the option is not found or if there is an error parsing the</a>
<a name="ln219"> * value.  If there is an error, the specified exec_state is also</a>
<a name="ln220"> * updated.</a>
<a name="ln221"> */</a>
<a name="ln222">bool LDBCommand::ParseIntOption(const map&lt;string, string&gt;&amp; options,</a>
<a name="ln223">                                const string&amp; option, int&amp; value,</a>
<a name="ln224">                                LDBCommandExecuteResult&amp; exec_state) {</a>
<a name="ln225"> </a>
<a name="ln226">  map&lt;string, string&gt;::const_iterator itr = option_map_.find(option);</a>
<a name="ln227">  if (itr != option_map_.end()) {</a>
<a name="ln228">    try {</a>
<a name="ln229">#if defined(CYGWIN)</a>
<a name="ln230">      value = strtol(itr-&gt;second.c_str(), 0, 10);</a>
<a name="ln231">#else</a>
<a name="ln232">      value = stoi(itr-&gt;second);</a>
<a name="ln233">#endif</a>
<a name="ln234">      return true;</a>
<a name="ln235">    } catch(const std::invalid_argument&amp;) {</a>
<a name="ln236">      exec_state =</a>
<a name="ln237">          LDBCommandExecuteResult::Failed(option + &quot; has an invalid value.&quot;);</a>
<a name="ln238">    } catch(const std::out_of_range&amp;) {</a>
<a name="ln239">      exec_state = LDBCommandExecuteResult::Failed(</a>
<a name="ln240">          option + &quot; has a value out-of-range.&quot;);</a>
<a name="ln241">    }</a>
<a name="ln242">  }</a>
<a name="ln243">  return false;</a>
<a name="ln244">}</a>
<a name="ln245"> </a>
<a name="ln246">/**</a>
<a name="ln247"> * Parses the specified option and fills in the value.</a>
<a name="ln248"> * Returns true if the option is found.</a>
<a name="ln249"> * Returns false otherwise.</a>
<a name="ln250"> */</a>
<a name="ln251">bool LDBCommand::ParseStringOption(const map&lt;string, string&gt;&amp; options,</a>
<a name="ln252">                                   const string&amp; option, string* value) {</a>
<a name="ln253">  auto itr = option_map_.find(option);</a>
<a name="ln254">  if (itr != option_map_.end()) {</a>
<a name="ln255">    *value = itr-&gt;second;</a>
<a name="ln256">    return true;</a>
<a name="ln257">  }</a>
<a name="ln258">  return false;</a>
<a name="ln259">}</a>
<a name="ln260"> </a>
<a name="ln261">Options LDBCommand::PrepareOptionsForOpenDB() {</a>
<a name="ln262">  Options opt = options_;</a>
<a name="ln263">  opt.create_if_missing = false;</a>
<a name="ln264"> </a>
<a name="ln265">  map&lt;string, string&gt;::const_iterator itr;</a>
<a name="ln266"> </a>
<a name="ln267">  BlockBasedTableOptions table_options;</a>
<a name="ln268">  bool use_table_options = false;</a>
<a name="ln269">  int bits;</a>
<a name="ln270">  if (ParseIntOption(option_map_, ARG_BLOOM_BITS, bits, exec_state_)) {</a>
<a name="ln271">    if (bits &gt; 0) {</a>
<a name="ln272">      use_table_options = true;</a>
<a name="ln273">      table_options.filter_policy.reset(NewBloomFilterPolicy(bits));</a>
<a name="ln274">    } else {</a>
<a name="ln275">      exec_state_ =</a>
<a name="ln276">          LDBCommandExecuteResult::Failed(ARG_BLOOM_BITS + &quot; must be &gt; 0.&quot;);</a>
<a name="ln277">    }</a>
<a name="ln278">  }</a>
<a name="ln279"> </a>
<a name="ln280">  int block_size;</a>
<a name="ln281">  if (ParseIntOption(option_map_, ARG_BLOCK_SIZE, block_size, exec_state_)) {</a>
<a name="ln282">    if (block_size &gt; 0) {</a>
<a name="ln283">      use_table_options = true;</a>
<a name="ln284">      table_options.block_size = block_size;</a>
<a name="ln285">    } else {</a>
<a name="ln286">      exec_state_ =</a>
<a name="ln287">          LDBCommandExecuteResult::Failed(ARG_BLOCK_SIZE + &quot; must be &gt; 0.&quot;);</a>
<a name="ln288">    }</a>
<a name="ln289">  }</a>
<a name="ln290"> </a>
<a name="ln291">  if (use_table_options) {</a>
<a name="ln292">    opt.table_factory.reset(NewBlockBasedTableFactory(table_options));</a>
<a name="ln293">  }</a>
<a name="ln294"> </a>
<a name="ln295">  itr = option_map_.find(ARG_AUTO_COMPACTION);</a>
<a name="ln296">  if (itr != option_map_.end()) {</a>
<a name="ln297">    opt.disable_auto_compactions = !StringToBool(itr-&gt;second);</a>
<a name="ln298">  }</a>
<a name="ln299"> </a>
<a name="ln300">  itr = option_map_.find(ARG_COMPRESSION_TYPE);</a>
<a name="ln301">  if (itr != option_map_.end()) {</a>
<a name="ln302">    string comp = itr-&gt;second;</a>
<a name="ln303">    if (comp == &quot;no&quot;) {</a>
<a name="ln304">      opt.compression = kNoCompression;</a>
<a name="ln305">    } else if (comp == &quot;snappy&quot;) {</a>
<a name="ln306">      opt.compression = kSnappyCompression;</a>
<a name="ln307">    } else if (comp == &quot;zlib&quot;) {</a>
<a name="ln308">      opt.compression = kZlibCompression;</a>
<a name="ln309">    } else if (comp == &quot;bzip2&quot;) {</a>
<a name="ln310">      opt.compression = kBZip2Compression;</a>
<a name="ln311">    } else if (comp == &quot;lz4&quot;) {</a>
<a name="ln312">      opt.compression = kLZ4Compression;</a>
<a name="ln313">    } else if (comp == &quot;lz4hc&quot;) {</a>
<a name="ln314">      opt.compression = kLZ4HCCompression;</a>
<a name="ln315">    } else if (comp == &quot;zstd&quot;) {</a>
<a name="ln316">      opt.compression = kZSTDNotFinalCompression;</a>
<a name="ln317">    } else {</a>
<a name="ln318">      // Unknown compression.</a>
<a name="ln319">      exec_state_ =</a>
<a name="ln320">          LDBCommandExecuteResult::Failed(&quot;Unknown compression level: &quot; + comp);</a>
<a name="ln321">    }</a>
<a name="ln322">  }</a>
<a name="ln323"> </a>
<a name="ln324">  int db_write_buffer_size;</a>
<a name="ln325">  if (ParseIntOption(option_map_, ARG_DB_WRITE_BUFFER_SIZE,</a>
<a name="ln326">        db_write_buffer_size, exec_state_)) {</a>
<a name="ln327">    if (db_write_buffer_size &gt;= 0) {</a>
<a name="ln328">      opt.db_write_buffer_size = db_write_buffer_size;</a>
<a name="ln329">    } else {</a>
<a name="ln330">      exec_state_ = LDBCommandExecuteResult::Failed(ARG_DB_WRITE_BUFFER_SIZE +</a>
<a name="ln331">                                                    &quot; must be &gt;= 0.&quot;);</a>
<a name="ln332">    }</a>
<a name="ln333">  }</a>
<a name="ln334"> </a>
<a name="ln335">  int write_buffer_size;</a>
<a name="ln336">  if (ParseIntOption(option_map_, ARG_WRITE_BUFFER_SIZE, write_buffer_size,</a>
<a name="ln337">        exec_state_)) {</a>
<a name="ln338">    if (write_buffer_size &gt; 0) {</a>
<a name="ln339">      opt.write_buffer_size = write_buffer_size;</a>
<a name="ln340">    } else {</a>
<a name="ln341">      exec_state_ = LDBCommandExecuteResult::Failed(ARG_WRITE_BUFFER_SIZE +</a>
<a name="ln342">                                                    &quot; must be &gt; 0.&quot;);</a>
<a name="ln343">    }</a>
<a name="ln344">  }</a>
<a name="ln345"> </a>
<a name="ln346">  int file_size;</a>
<a name="ln347">  if (ParseIntOption(option_map_, ARG_FILE_SIZE, file_size, exec_state_)) {</a>
<a name="ln348">    if (file_size &gt; 0) {</a>
<a name="ln349">      opt.target_file_size_base = file_size;</a>
<a name="ln350">    } else {</a>
<a name="ln351">      exec_state_ =</a>
<a name="ln352">          LDBCommandExecuteResult::Failed(ARG_FILE_SIZE + &quot; must be &gt; 0.&quot;);</a>
<a name="ln353">    }</a>
<a name="ln354">  }</a>
<a name="ln355"> </a>
<a name="ln356">  if (opt.db_paths.size() == 0) {</a>
<a name="ln357">    opt.db_paths.emplace_back(db_path_, std::numeric_limits&lt;uint64_t&gt;::max());</a>
<a name="ln358">  }</a>
<a name="ln359"> </a>
<a name="ln360">  int fix_prefix_len;</a>
<a name="ln361">  if (ParseIntOption(option_map_, ARG_FIX_PREFIX_LEN, fix_prefix_len,</a>
<a name="ln362">                     exec_state_)) {</a>
<a name="ln363">    if (fix_prefix_len &gt; 0) {</a>
<a name="ln364">      opt.prefix_extractor.reset(</a>
<a name="ln365">          NewFixedPrefixTransform(static_cast&lt;size_t&gt;(fix_prefix_len)));</a>
<a name="ln366">    } else {</a>
<a name="ln367">      exec_state_ =</a>
<a name="ln368">          LDBCommandExecuteResult::Failed(ARG_FIX_PREFIX_LEN + &quot; must be &gt; 0.&quot;);</a>
<a name="ln369">    }</a>
<a name="ln370">  }</a>
<a name="ln371"> </a>
<a name="ln372">  opt.env = env_ ? env_.get() : Env::Default();</a>
<a name="ln373">  opt.checkpoint_env = Env::Default();</a>
<a name="ln374"> </a>
<a name="ln375">  return opt;</a>
<a name="ln376">}</a>
<a name="ln377"> </a>
<a name="ln378">bool LDBCommand::ParseKeyValue(const string&amp; line, string* key, string* value,</a>
<a name="ln379">                              bool is_key_hex, bool is_value_hex) {</a>
<a name="ln380">  size_t pos = line.find(DELIM);</a>
<a name="ln381">  if (pos != string::npos) {</a>
<a name="ln382">    *key = line.substr(0, pos);</a>
<a name="ln383">    *value = line.substr(pos + strlen(DELIM));</a>
<a name="ln384">    if (is_key_hex) {</a>
<a name="ln385">      *key = HexToString(*key);</a>
<a name="ln386">    }</a>
<a name="ln387">    if (is_value_hex) {</a>
<a name="ln388">      *value = HexToString(*value);</a>
<a name="ln389">    }</a>
<a name="ln390">    return true;</a>
<a name="ln391">  } else {</a>
<a name="ln392">    return false;</a>
<a name="ln393">  }</a>
<a name="ln394">}</a>
<a name="ln395"> </a>
<a name="ln396">/**</a>
<a name="ln397"> * Make sure that ONLY the command-line options and flags expected by this</a>
<a name="ln398"> * command are specified on the command-line.  Extraneous options are usually</a>
<a name="ln399"> * the result of user error.</a>
<a name="ln400"> * Returns true if all checks pass.  Else returns false, and prints an</a>
<a name="ln401"> * appropriate error msg to stderr.</a>
<a name="ln402"> */</a>
<a name="ln403">bool LDBCommand::ValidateCmdLineOptions() {</a>
<a name="ln404"> </a>
<a name="ln405">  for (map&lt;string, string&gt;::const_iterator itr = option_map_.begin();</a>
<a name="ln406">        itr != option_map_.end(); ++itr) {</a>
<a name="ln407">    if (find(valid_cmd_line_options_.begin(),</a>
<a name="ln408">          valid_cmd_line_options_.end(), itr-&gt;first) ==</a>
<a name="ln409">          valid_cmd_line_options_.end()) {</a>
<a name="ln410">      fprintf(stderr, &quot;Invalid command-line option %s\n&quot;, itr-&gt;first.c_str());</a>
<a name="ln411">      return false;</a>
<a name="ln412">    }</a>
<a name="ln413">  }</a>
<a name="ln414"> </a>
<a name="ln415">  for (vector&lt;string&gt;::const_iterator itr = flags_.begin();</a>
<a name="ln416">        itr != flags_.end(); ++itr) {</a>
<a name="ln417">    if (find(valid_cmd_line_options_.begin(),</a>
<a name="ln418">          valid_cmd_line_options_.end(), *itr) ==</a>
<a name="ln419">          valid_cmd_line_options_.end()) {</a>
<a name="ln420">      fprintf(stderr, &quot;Invalid command-line flag %s\n&quot;, itr-&gt;c_str());</a>
<a name="ln421">      return false;</a>
<a name="ln422">    }</a>
<a name="ln423">  }</a>
<a name="ln424"> </a>
<a name="ln425">  if (!NoDBOpen() &amp;&amp; option_map_.find(ARG_DB) == option_map_.end() &amp;&amp;</a>
<a name="ln426">      option_map_.find(ARG_PATH) == option_map_.end()) {</a>
<a name="ln427">    fprintf(stderr, &quot;Either %s or %s must be specified.\n&quot;, ARG_DB.c_str(),</a>
<a name="ln428">            ARG_PATH.c_str());</a>
<a name="ln429">    return false;</a>
<a name="ln430">  }</a>
<a name="ln431"> </a>
<a name="ln432">  return true;</a>
<a name="ln433">}</a>
<a name="ln434"> </a>
<a name="ln435">CompactorCommand::CompactorCommand(const vector&lt;string&gt;&amp; params,</a>
<a name="ln436">      const map&lt;string, string&gt;&amp; options, const vector&lt;string&gt;&amp; flags) :</a>
<a name="ln437">    LDBCommand(options, flags, false,</a>
<a name="ln438">               BuildCmdLineOptions({ARG_FROM, ARG_TO, ARG_HEX, ARG_KEY_HEX,</a>
<a name="ln439">                                    ARG_VALUE_HEX, ARG_TTL})),</a>
<a name="ln440">    null_from_(true), null_to_(true) {</a>
<a name="ln441"> </a>
<a name="ln442">  map&lt;string, string&gt;::const_iterator itr = options.find(ARG_FROM);</a>
<a name="ln443">  if (itr != options.end()) {</a>
<a name="ln444">    null_from_ = false;</a>
<a name="ln445">    from_ = itr-&gt;second;</a>
<a name="ln446">  }</a>
<a name="ln447"> </a>
<a name="ln448">  itr = options.find(ARG_TO);</a>
<a name="ln449">  if (itr != options.end()) {</a>
<a name="ln450">    null_to_ = false;</a>
<a name="ln451">    to_ = itr-&gt;second;</a>
<a name="ln452">  }</a>
<a name="ln453"> </a>
<a name="ln454">  if (is_key_hex_) {</a>
<a name="ln455">    if (!null_from_) {</a>
<a name="ln456">      from_ = HexToString(from_);</a>
<a name="ln457">    }</a>
<a name="ln458">    if (!null_to_) {</a>
<a name="ln459">      to_ = HexToString(to_);</a>
<a name="ln460">    }</a>
<a name="ln461">  }</a>
<a name="ln462">}</a>
<a name="ln463"> </a>
<a name="ln464">void CompactorCommand::Help(string&amp; ret) {</a>
<a name="ln465">  ret.append(&quot;  &quot;);</a>
<a name="ln466">  ret.append(CompactorCommand::Name());</a>
<a name="ln467">  ret.append(HelpRangeCmdArgs());</a>
<a name="ln468">  ret.append(&quot;\n&quot;);</a>
<a name="ln469">}</a>
<a name="ln470"> </a>
<a name="ln471">void CompactorCommand::DoCommand() {</a>
<a name="ln472">  if (!db_) {</a>
<a name="ln473">    assert(GetExecuteState().IsFailed());</a>
<a name="ln474">    return;</a>
<a name="ln475">  }</a>
<a name="ln476"> </a>
<a name="ln477">  Slice* begin = nullptr;</a>
<a name="ln478">  Slice* end = nullptr;</a>
<a name="ln479">  if (!null_from_) {</a>
<a name="ln480">    begin = new Slice(from_);</a>
<a name="ln481">  }</a>
<a name="ln482">  if (!null_to_) {</a>
<a name="ln483">    end = new Slice(to_);</a>
<a name="ln484">  }</a>
<a name="ln485"> </a>
<a name="ln486">  CompactRangeOptions cro;</a>
<a name="ln487">  cro.bottommost_level_compaction = BottommostLevelCompaction::kForce;</a>
<a name="ln488"> </a>
<a name="ln489">  CHECK_OK(db_-&gt;CompactRange(cro, begin, end));</a>
<a name="ln490">  exec_state_ = LDBCommandExecuteResult::Succeed(&quot;&quot;);</a>
<a name="ln491"> </a>
<a name="ln492">  delete begin;</a>
<a name="ln493">  delete end;</a>
<a name="ln494">}</a>
<a name="ln495"> </a>
<a name="ln496">// ----------------------------------------------------------------------------</a>
<a name="ln497"> </a>
<a name="ln498">const string DBLoaderCommand::ARG_DISABLE_WAL = &quot;disable_wal&quot;;</a>
<a name="ln499">const string DBLoaderCommand::ARG_BULK_LOAD = &quot;bulk_load&quot;;</a>
<a name="ln500">const string DBLoaderCommand::ARG_COMPACT = &quot;compact&quot;;</a>
<a name="ln501"> </a>
<a name="ln502">DBLoaderCommand::DBLoaderCommand(const vector&lt;string&gt;&amp; params,</a>
<a name="ln503">      const map&lt;string, string&gt;&amp; options, const vector&lt;string&gt;&amp; flags) :</a>
<a name="ln504">    LDBCommand(options, flags, false,</a>
<a name="ln505">               BuildCmdLineOptions({ARG_HEX, ARG_KEY_HEX, ARG_VALUE_HEX,</a>
<a name="ln506">                                    ARG_FROM, ARG_TO, ARG_CREATE_IF_MISSING,</a>
<a name="ln507">                                    ARG_DISABLE_WAL, ARG_BULK_LOAD,</a>
<a name="ln508">                                    ARG_COMPACT})),</a>
<a name="ln509">    create_if_missing_(false), disable_wal_(false), bulk_load_(false),</a>
<a name="ln510">    compact_(false) {</a>
<a name="ln511"> </a>
<a name="ln512">  create_if_missing_ = IsFlagPresent(flags, ARG_CREATE_IF_MISSING);</a>
<a name="ln513">  disable_wal_ = IsFlagPresent(flags, ARG_DISABLE_WAL);</a>
<a name="ln514">  bulk_load_ = IsFlagPresent(flags, ARG_BULK_LOAD);</a>
<a name="ln515">  compact_ = IsFlagPresent(flags, ARG_COMPACT);</a>
<a name="ln516">}</a>
<a name="ln517"> </a>
<a name="ln518">void DBLoaderCommand::Help(string&amp; ret) {</a>
<a name="ln519">  ret.append(&quot;  &quot;);</a>
<a name="ln520">  ret.append(DBLoaderCommand::Name());</a>
<a name="ln521">  ret.append(&quot; [--&quot; + ARG_CREATE_IF_MISSING + &quot;]&quot;);</a>
<a name="ln522">  ret.append(&quot; [--&quot; + ARG_DISABLE_WAL + &quot;]&quot;);</a>
<a name="ln523">  ret.append(&quot; [--&quot; + ARG_BULK_LOAD + &quot;]&quot;);</a>
<a name="ln524">  ret.append(&quot; [--&quot; + ARG_COMPACT + &quot;]&quot;);</a>
<a name="ln525">  ret.append(&quot;\n&quot;);</a>
<a name="ln526">}</a>
<a name="ln527"> </a>
<a name="ln528">Options DBLoaderCommand::PrepareOptionsForOpenDB() {</a>
<a name="ln529">  Options opt = LDBCommand::PrepareOptionsForOpenDB();</a>
<a name="ln530">  opt.create_if_missing = create_if_missing_;</a>
<a name="ln531">  if (bulk_load_) {</a>
<a name="ln532">    opt.PrepareForBulkLoad();</a>
<a name="ln533">  }</a>
<a name="ln534">  return opt;</a>
<a name="ln535">}</a>
<a name="ln536"> </a>
<a name="ln537">void DBLoaderCommand::DoCommand() {</a>
<a name="ln538">  if (!db_) {</a>
<a name="ln539">    assert(GetExecuteState().IsFailed());</a>
<a name="ln540">    return;</a>
<a name="ln541">  }</a>
<a name="ln542"> </a>
<a name="ln543">  WriteOptions write_options;</a>
<a name="ln544">  if (disable_wal_) {</a>
<a name="ln545">    write_options.disableWAL = true;</a>
<a name="ln546">  }</a>
<a name="ln547"> </a>
<a name="ln548">  int bad_lines = 0;</a>
<a name="ln549">  string line;</a>
<a name="ln550">  while (getline(std::cin, line, '\n')) {</a>
<a name="ln551">    string key;</a>
<a name="ln552">    string value;</a>
<a name="ln553">    if (ParseKeyValue(line, &amp;key, &amp;value, is_key_hex_, is_value_hex_)) {</a>
<a name="ln554">      CHECK_OK(db_-&gt;Put(write_options, GetCfHandle(), Slice(key), Slice(value)));</a>
<a name="ln555">    } else if (0 == line.find(&quot;Keys in range:&quot;)) {</a>
<a name="ln556">      // ignore this line</a>
<a name="ln557">    } else if (0 == line.find(&quot;Created bg thread 0x&quot;)) {</a>
<a name="ln558">      // ignore this line</a>
<a name="ln559">    } else {</a>
<a name="ln560">      bad_lines++;</a>
<a name="ln561">    }</a>
<a name="ln562">  }</a>
<a name="ln563"> </a>
<a name="ln564">  if (bad_lines &gt; 0) {</a>
<a name="ln565">    std::cout &lt;&lt; &quot;Warning: &quot; &lt;&lt; bad_lines &lt;&lt; &quot; bad lines ignored.&quot; &lt;&lt; std::endl;</a>
<a name="ln566">  }</a>
<a name="ln567">  if (compact_) {</a>
<a name="ln568">    CHECK_OK(db_-&gt;CompactRange(CompactRangeOptions(), GetCfHandle(), nullptr, nullptr));</a>
<a name="ln569">  }</a>
<a name="ln570">}</a>
<a name="ln571"> </a>
<a name="ln572">// ----------------------------------------------------------------------------</a>
<a name="ln573"> </a>
<a name="ln574">namespace {</a>
<a name="ln575"> </a>
<a name="ln576">void DumpManifestFile(std::string file, bool verbose, bool hex) {</a>
<a name="ln577">  Options options;</a>
<a name="ln578">  EnvOptions sopt;</a>
<a name="ln579">  std::string dbname(&quot;dummy&quot;);</a>
<a name="ln580">  std::shared_ptr&lt;Cache&gt; tc(NewLRUCache(options.max_open_files - 10,</a>
<a name="ln581">                                        options.table_cache_numshardbits));</a>
<a name="ln582">  // Notice we are using the default options not through SanitizeOptions(),</a>
<a name="ln583">  // if VersionSet::DumpManifest() depends on any option done by</a>
<a name="ln584">  // SanitizeOptions(), we need to initialize it manually.</a>
<a name="ln585">  options.db_paths.emplace_back(&quot;dummy&quot;, 0);</a>
<a name="ln586">  options.num_levels = 64;</a>
<a name="ln587">  WriteController wc(options.delayed_write_rate);</a>
<a name="ln588">  WriteBuffer wb(options.db_write_buffer_size);</a>
<a name="ln589">  VersionSet versions(dbname, &amp;options, sopt, tc.get(), &amp;wb, &amp;wc);</a>
<a name="ln590">  Status s = versions.DumpManifest(options, file, verbose, hex);</a>
<a name="ln591">  if (!s.ok()) {</a>
<a name="ln592">    printf(&quot;Error in processing file %s %s\n&quot;, file.c_str(),</a>
<a name="ln593">           s.ToString().c_str());</a>
<a name="ln594">  }</a>
<a name="ln595">}</a>
<a name="ln596"> </a>
<a name="ln597">}  // namespace</a>
<a name="ln598"> </a>
<a name="ln599">const string ManifestDumpCommand::ARG_VERBOSE = &quot;verbose&quot;;</a>
<a name="ln600">const string ManifestDumpCommand::ARG_JSON = &quot;json&quot;;</a>
<a name="ln601">const string ManifestDumpCommand::ARG_PATH = &quot;path&quot;;</a>
<a name="ln602"> </a>
<a name="ln603">void ManifestDumpCommand::Help(string&amp; ret) {</a>
<a name="ln604">  ret.append(&quot;  &quot;);</a>
<a name="ln605">  ret.append(ManifestDumpCommand::Name());</a>
<a name="ln606">  ret.append(&quot; [--&quot; + ARG_VERBOSE + &quot;]&quot;);</a>
<a name="ln607">  ret.append(&quot; [--&quot; + ARG_JSON + &quot;]&quot;);</a>
<a name="ln608">  ret.append(&quot; [--&quot; + ARG_PATH + &quot;=&lt;path_to_manifest_file&gt;]&quot;);</a>
<a name="ln609">  ret.append(&quot;\n&quot;);</a>
<a name="ln610">}</a>
<a name="ln611"> </a>
<a name="ln612">ManifestDumpCommand::ManifestDumpCommand(const vector&lt;string&gt;&amp; params,</a>
<a name="ln613">      const map&lt;string, string&gt;&amp; options, const vector&lt;string&gt;&amp; flags) :</a>
<a name="ln614">    LDBCommand(options, flags, false,</a>
<a name="ln615">               BuildCmdLineOptions({ARG_VERBOSE, ARG_PATH, ARG_HEX, ARG_JSON})),</a>
<a name="ln616">    verbose_(false),</a>
<a name="ln617">    path_(&quot;&quot;) {</a>
<a name="ln618">  verbose_ = IsFlagPresent(flags, ARG_VERBOSE);</a>
<a name="ln619"> </a>
<a name="ln620">  map&lt;string, string&gt;::const_iterator itr = options.find(ARG_PATH);</a>
<a name="ln621">  if (itr != options.end()) {</a>
<a name="ln622">    path_ = itr-&gt;second;</a>
<a name="ln623">    if (path_.empty()) {</a>
<a name="ln624">      exec_state_ = LDBCommandExecuteResult::Failed(&quot;--path: missing pathname&quot;);</a>
<a name="ln625">    }</a>
<a name="ln626">  }</a>
<a name="ln627">}</a>
<a name="ln628"> </a>
<a name="ln629">void ManifestDumpCommand::DoCommand() {</a>
<a name="ln630"> </a>
<a name="ln631">  std::string manifestfile;</a>
<a name="ln632"> </a>
<a name="ln633">  if (!path_.empty()) {</a>
<a name="ln634">    manifestfile = path_;</a>
<a name="ln635">  } else {</a>
<a name="ln636">    bool found = false;</a>
<a name="ln637">    // We need to find the manifest file by searching the directory</a>
<a name="ln638">    // containing the db for files of the form MANIFEST_[0-9]+</a>
<a name="ln639"> </a>
<a name="ln640">    auto CloseDir = [](DIR* p) { closedir(p); };</a>
<a name="ln641">    std::unique_ptr&lt;DIR, decltype(CloseDir)&gt; d(opendir(db_path_.c_str()),</a>
<a name="ln642">                                               CloseDir);</a>
<a name="ln643"> </a>
<a name="ln644">    if (d == nullptr) {</a>
<a name="ln645">      exec_state_ =</a>
<a name="ln646">          LDBCommandExecuteResult::Failed(db_path_ + &quot; is not a directory&quot;);</a>
<a name="ln647">      return;</a>
<a name="ln648">    }</a>
<a name="ln649">    struct dirent* entry;</a>
<a name="ln650">    while ((entry = readdir(d.get())) != nullptr) {</a>
<a name="ln651">      unsigned int match;</a>
<a name="ln652">      uint64_t num;</a>
<a name="ln653">      if (sscanf(entry-&gt;d_name, &quot;MANIFEST-%&quot; PRIu64 &quot;%n&quot;, &amp;num, &amp;match) &amp;&amp;</a>
<a name="ln654">          match == strlen(entry-&gt;d_name)) {</a>
<a name="ln655">        if (!found) {</a>
<a name="ln656">          manifestfile = db_path_ + &quot;/&quot; + std::string(entry-&gt;d_name);</a>
<a name="ln657">          found = true;</a>
<a name="ln658">        } else {</a>
<a name="ln659">          exec_state_ = LDBCommandExecuteResult::Failed(</a>
<a name="ln660">              &quot;Multiple MANIFEST files found; use --path to select one&quot;);</a>
<a name="ln661">          return;</a>
<a name="ln662">        }</a>
<a name="ln663">      }</a>
<a name="ln664">    }</a>
<a name="ln665">  }</a>
<a name="ln666"> </a>
<a name="ln667">  if (verbose_) {</a>
<a name="ln668">    printf(&quot;Processing Manifest file %s\n&quot;, manifestfile.c_str());</a>
<a name="ln669">  }</a>
<a name="ln670"> </a>
<a name="ln671">  DumpManifestFile(manifestfile, verbose_, is_key_hex_);</a>
<a name="ln672"> </a>
<a name="ln673">  if (verbose_) {</a>
<a name="ln674">    printf(&quot;Processing Manifest file %s done\n&quot;, manifestfile.c_str());</a>
<a name="ln675">  }</a>
<a name="ln676">}</a>
<a name="ln677"> </a>
<a name="ln678">// ----------------------------------------------------------------------------</a>
<a name="ln679"> </a>
<a name="ln680">void ListColumnFamiliesCommand::Help(string&amp; ret) {</a>
<a name="ln681">  ret.append(&quot;  &quot;);</a>
<a name="ln682">  ret.append(ListColumnFamiliesCommand::Name());</a>
<a name="ln683">  ret.append(&quot; full_path_to_db_directory &quot;);</a>
<a name="ln684">  ret.append(&quot;\n&quot;);</a>
<a name="ln685">}</a>
<a name="ln686"> </a>
<a name="ln687">ListColumnFamiliesCommand::ListColumnFamiliesCommand(</a>
<a name="ln688">    const vector&lt;string&gt;&amp; params, const map&lt;string, string&gt;&amp; options,</a>
<a name="ln689">    const vector&lt;string&gt;&amp; flags)</a>
<a name="ln690">    : LDBCommand(options, flags, false, {}) {</a>
<a name="ln691"> </a>
<a name="ln692">  if (params.size() != 1) {</a>
<a name="ln693">    exec_state_ = LDBCommandExecuteResult::Failed(</a>
<a name="ln694">        &quot;dbname must be specified for the list_column_families command&quot;);</a>
<a name="ln695">  } else {</a>
<a name="ln696">    dbname_ = params[0];</a>
<a name="ln697">  }</a>
<a name="ln698">}</a>
<a name="ln699"> </a>
<a name="ln700">void ListColumnFamiliesCommand::DoCommand() {</a>
<a name="ln701">  vector&lt;string&gt; column_families;</a>
<a name="ln702">  Status s = DB::ListColumnFamilies(DBOptions(), dbname_, &amp;column_families);</a>
<a name="ln703">  if (!s.ok()) {</a>
<a name="ln704">    printf(&quot;Error in processing db %s %s\n&quot;, dbname_.c_str(),</a>
<a name="ln705">           s.ToString().c_str());</a>
<a name="ln706">  } else {</a>
<a name="ln707">    printf(&quot;Column families in %s: \n{&quot;, dbname_.c_str());</a>
<a name="ln708">    bool first = true;</a>
<a name="ln709">    for (auto cf : column_families) {</a>
<a name="ln710">      if (!first) {</a>
<a name="ln711">        printf(&quot;, &quot;);</a>
<a name="ln712">      }</a>
<a name="ln713">      first = false;</a>
<a name="ln714">      printf(&quot;%s&quot;, cf.c_str());</a>
<a name="ln715">    }</a>
<a name="ln716">    printf(&quot;}\n&quot;);</a>
<a name="ln717">  }</a>
<a name="ln718">}</a>
<a name="ln719"> </a>
<a name="ln720">void CreateColumnFamilyCommand::Help(string&amp; ret) {</a>
<a name="ln721">  ret.append(&quot;  &quot;);</a>
<a name="ln722">  ret.append(CreateColumnFamilyCommand::Name());</a>
<a name="ln723">  ret.append(&quot; --db=&lt;db_path&gt; &lt;new_column_family_name&gt;&quot;);</a>
<a name="ln724">  ret.append(&quot;\n&quot;);</a>
<a name="ln725">}</a>
<a name="ln726"> </a>
<a name="ln727">CreateColumnFamilyCommand::CreateColumnFamilyCommand(</a>
<a name="ln728">    const vector&lt;string&gt;&amp; params, const map&lt;string, string&gt;&amp; options,</a>
<a name="ln729">    const vector&lt;string&gt;&amp; flags)</a>
<a name="ln730">    : LDBCommand(options, flags, true, {ARG_DB}) {</a>
<a name="ln731">  if (params.size() != 1) {</a>
<a name="ln732">    exec_state_ = LDBCommandExecuteResult::Failed(</a>
<a name="ln733">        &quot;new column family name must be specified&quot;);</a>
<a name="ln734">  } else {</a>
<a name="ln735">    new_cf_name_ = params[0];</a>
<a name="ln736">  }</a>
<a name="ln737">}</a>
<a name="ln738"> </a>
<a name="ln739">void CreateColumnFamilyCommand::DoCommand() {</a>
<a name="ln740">  ColumnFamilyHandle* new_cf_handle;</a>
<a name="ln741">  Status st = db_-&gt;CreateColumnFamily(options_, new_cf_name_, &amp;new_cf_handle);</a>
<a name="ln742">  if (st.ok()) {</a>
<a name="ln743">    fprintf(stdout, &quot;OK\n&quot;);</a>
<a name="ln744">  } else {</a>
<a name="ln745">    exec_state_ = LDBCommandExecuteResult::Failed(</a>
<a name="ln746">        &quot;Fail to create new column family: &quot; + st.ToString());</a>
<a name="ln747">  }</a>
<a name="ln748">  delete new_cf_handle;</a>
<a name="ln749">  CloseDB();</a>
<a name="ln750">}</a>
<a name="ln751"> </a>
<a name="ln752">// ----------------------------------------------------------------------------</a>
<a name="ln753"> </a>
<a name="ln754">namespace {</a>
<a name="ln755"> </a>
<a name="ln756">string ReadableTime(int unixtime) {</a>
<a name="ln757">  char time_buffer[80];</a>
<a name="ln758">  time_t rawtime = unixtime;</a>
<a name="ln759">  struct tm tInfo;</a>
<a name="ln760">  struct tm* timeinfo = localtime_r(&amp;rawtime, &amp;tInfo);</a>
<a name="ln761">  assert(timeinfo == &amp;tInfo);</a>
<a name="ln762">  strftime(time_buffer, 80, &quot;%c&quot;, timeinfo);</a>
<a name="ln763">  return string(time_buffer);</a>
<a name="ln764">}</a>
<a name="ln765"> </a>
<a name="ln766">// This function only called when it's the sane case of &gt;1 buckets in time-range</a>
<a name="ln767">// Also called only when timekv falls between ttl_start and ttl_end provided</a>
<a name="ln768">void IncBucketCounts(vector&lt;uint64_t&gt;* bucket_counts, int ttl_start,</a>
<a name="ln769">      int time_range, int bucket_size, int timekv, int num_buckets) {</a>
<a name="ln770">  assert(time_range &gt; 0 &amp;&amp; timekv &gt;= ttl_start &amp;&amp; bucket_size &gt; 0 &amp;&amp;</a>
<a name="ln771">    timekv &lt; (ttl_start + time_range) &amp;&amp; num_buckets &gt; 1);</a>
<a name="ln772">  int bucket = (timekv - ttl_start) / bucket_size;</a>
<a name="ln773">  (*bucket_counts)[bucket]++;</a>
<a name="ln774">}</a>
<a name="ln775"> </a>
<a name="ln776">void PrintBucketCounts(const vector&lt;uint64_t&gt;&amp; bucket_counts, int ttl_start,</a>
<a name="ln777">      int ttl_end, int bucket_size, int num_buckets) {</a>
<a name="ln778">  int time_point = ttl_start;</a>
<a name="ln779">  for(int i = 0; i &lt; num_buckets - 1; i++, time_point += bucket_size) {</a>
<a name="ln780">    fprintf(stdout, &quot;Keys in range %s to %s : %&quot; PRIu64 &quot;\n&quot;,</a>
<a name="ln781">            ReadableTime(time_point).c_str(),</a>
<a name="ln782">            ReadableTime(time_point + bucket_size).c_str(),</a>
<a name="ln783">            bucket_counts[i]);</a>
<a name="ln784">  }</a>
<a name="ln785">  fprintf(stdout, &quot;Keys in range %s to %s : %&quot; PRIu64 &quot;\n&quot;,</a>
<a name="ln786">          ReadableTime(time_point).c_str(),</a>
<a name="ln787">          ReadableTime(ttl_end).c_str(),</a>
<a name="ln788">          bucket_counts[num_buckets - 1]);</a>
<a name="ln789">}</a>
<a name="ln790"> </a>
<a name="ln791">}  // namespace</a>
<a name="ln792"> </a>
<a name="ln793">const string InternalDumpCommand::ARG_COUNT_ONLY = &quot;count_only&quot;;</a>
<a name="ln794">const string InternalDumpCommand::ARG_COUNT_DELIM = &quot;count_delim&quot;;</a>
<a name="ln795">const string InternalDumpCommand::ARG_STATS = &quot;stats&quot;;</a>
<a name="ln796">const string InternalDumpCommand::ARG_INPUT_KEY_HEX = &quot;input_key_hex&quot;;</a>
<a name="ln797"> </a>
<a name="ln798">InternalDumpCommand::InternalDumpCommand(const vector&lt;string&gt;&amp; params,</a>
<a name="ln799">                                         const map&lt;string, string&gt;&amp; options,</a>
<a name="ln800">                                         const vector&lt;string&gt;&amp; flags)</a>
<a name="ln801">    : LDBCommand(</a>
<a name="ln802">          options, flags, true,</a>
<a name="ln803">          BuildCmdLineOptions({ARG_HEX, ARG_KEY_HEX, ARG_VALUE_HEX, ARG_FROM,</a>
<a name="ln804">                               ARG_TO, ARG_MAX_KEYS, ARG_COUNT_ONLY,</a>
<a name="ln805">                               ARG_COUNT_DELIM, ARG_STATS, ARG_INPUT_KEY_HEX})),</a>
<a name="ln806">      has_from_(false),</a>
<a name="ln807">      has_to_(false),</a>
<a name="ln808">      max_keys_(-1),</a>
<a name="ln809">      delim_(&quot;.&quot;),</a>
<a name="ln810">      count_only_(false),</a>
<a name="ln811">      count_delim_(false),</a>
<a name="ln812">      print_stats_(false),</a>
<a name="ln813">      is_input_key_hex_(false) {</a>
<a name="ln814">  has_from_ = ParseStringOption(options, ARG_FROM, &amp;from_);</a>
<a name="ln815">  has_to_ = ParseStringOption(options, ARG_TO, &amp;to_);</a>
<a name="ln816"> </a>
<a name="ln817">  ParseIntOption(options, ARG_MAX_KEYS, max_keys_, exec_state_);</a>
<a name="ln818">  map&lt;string, string&gt;::const_iterator itr = options.find(ARG_COUNT_DELIM);</a>
<a name="ln819">  if (itr != options.end()) {</a>
<a name="ln820">    delim_ = itr-&gt;second;</a>
<a name="ln821">    count_delim_ = true;</a>
<a name="ln822">    // fprintf(stdout,&quot;delim = %c\n&quot;,delim_[0]);</a>
<a name="ln823">  } else {</a>
<a name="ln824">    count_delim_ = IsFlagPresent(flags, ARG_COUNT_DELIM);</a>
<a name="ln825">    delim_ = &quot;.&quot;;</a>
<a name="ln826">  }</a>
<a name="ln827"> </a>
<a name="ln828">  print_stats_ = IsFlagPresent(flags, ARG_STATS);</a>
<a name="ln829">  count_only_ = IsFlagPresent(flags, ARG_COUNT_ONLY);</a>
<a name="ln830">  is_input_key_hex_ = IsFlagPresent(flags, ARG_INPUT_KEY_HEX);</a>
<a name="ln831"> </a>
<a name="ln832">  if (is_input_key_hex_) {</a>
<a name="ln833">    if (has_from_) {</a>
<a name="ln834">      from_ = HexToString(from_);</a>
<a name="ln835">    }</a>
<a name="ln836">    if (has_to_) {</a>
<a name="ln837">      to_ = HexToString(to_);</a>
<a name="ln838">    }</a>
<a name="ln839">  }</a>
<a name="ln840">}</a>
<a name="ln841"> </a>
<a name="ln842">void InternalDumpCommand::Help(string&amp; ret) {</a>
<a name="ln843">  ret.append(&quot;  &quot;);</a>
<a name="ln844">  ret.append(InternalDumpCommand::Name());</a>
<a name="ln845">  ret.append(HelpRangeCmdArgs());</a>
<a name="ln846">  ret.append(&quot; [--&quot; + ARG_INPUT_KEY_HEX + &quot;]&quot;);</a>
<a name="ln847">  ret.append(&quot; [--&quot; + ARG_MAX_KEYS + &quot;=&lt;N&gt;]&quot;);</a>
<a name="ln848">  ret.append(&quot; [--&quot; + ARG_COUNT_ONLY + &quot;]&quot;);</a>
<a name="ln849">  ret.append(&quot; [--&quot; + ARG_COUNT_DELIM + &quot;=&lt;char&gt;]&quot;);</a>
<a name="ln850">  ret.append(&quot; [--&quot; + ARG_STATS + &quot;]&quot;);</a>
<a name="ln851">  ret.append(&quot;\n&quot;);</a>
<a name="ln852">}</a>
<a name="ln853"> </a>
<a name="ln854">void InternalDumpCommand::DoCommand() {</a>
<a name="ln855">  if (!db_) {</a>
<a name="ln856">    assert(GetExecuteState().IsFailed());</a>
<a name="ln857">    return;</a>
<a name="ln858">  }</a>
<a name="ln859"> </a>
<a name="ln860">  if (print_stats_) {</a>
<a name="ln861">    string stats;</a>
<a name="ln862">    if (db_-&gt;GetProperty(GetCfHandle(), &quot;rocksdb.stats&quot;, &amp;stats)) {</a>
<a name="ln863">      fprintf(stdout, &quot;%s\n&quot;, stats.c_str());</a>
<a name="ln864">    }</a>
<a name="ln865">  }</a>
<a name="ln866"> </a>
<a name="ln867">  // Cast as DBImpl to get internal iterator</a>
<a name="ln868">  DBImpl* idb = dynamic_cast&lt;DBImpl*&gt;(db_);</a>
<a name="ln869">  if (!idb) {</a>
<a name="ln870">    exec_state_ = LDBCommandExecuteResult::Failed(&quot;DB is not DBImpl&quot;);</a>
<a name="ln871">    return;</a>
<a name="ln872">  }</a>
<a name="ln873">  string rtype1, rtype2, row, val;</a>
<a name="ln874">  rtype2 = &quot;&quot;;</a>
<a name="ln875">  uint64_t c = 0;</a>
<a name="ln876">  uint64_t s1 = 0, s2 = 0;</a>
<a name="ln877">  // Setup internal key iterator</a>
<a name="ln878">  Arena arena;</a>
<a name="ln879">  ScopedArenaIterator iter(idb-&gt;NewInternalIterator(&amp;arena));</a>
<a name="ln880">  Status st = iter-&gt;status();</a>
<a name="ln881">  if (!st.ok()) {</a>
<a name="ln882">    exec_state_ =</a>
<a name="ln883">        LDBCommandExecuteResult::Failed(&quot;Iterator error:&quot; + st.ToString());</a>
<a name="ln884">  }</a>
<a name="ln885"> </a>
<a name="ln886">  if (has_from_) {</a>
<a name="ln887">    InternalKey ikey = InternalKey::MaxPossibleForUserKey(from_);</a>
<a name="ln888">    iter-&gt;Seek(ikey.Encode());</a>
<a name="ln889">  } else {</a>
<a name="ln890">    iter-&gt;SeekToFirst();</a>
<a name="ln891">  }</a>
<a name="ln892"> </a>
<a name="ln893">  int64_t count = 0;</a>
<a name="ln894">  for (; iter-&gt;Valid(); iter-&gt;Next()) {</a>
<a name="ln895">    ParsedInternalKey ikey;</a>
<a name="ln896">    if (!ParseInternalKey(iter-&gt;key(), &amp;ikey)) {</a>
<a name="ln897">      fprintf(stderr, &quot;Internal Key [%s] parse error!\n&quot;,</a>
<a name="ln898">              iter-&gt;key().ToString(true /* in hex*/).data());</a>
<a name="ln899">      // TODO: add error counter</a>
<a name="ln900">      continue;</a>
<a name="ln901">    }</a>
<a name="ln902"> </a>
<a name="ln903">    // If end marker was specified, we stop before it</a>
<a name="ln904">    if (has_to_ &amp;&amp; options_.comparator-&gt;Compare(ikey.user_key, to_) &gt;= 0) {</a>
<a name="ln905">      break;</a>
<a name="ln906">    }</a>
<a name="ln907"> </a>
<a name="ln908">    ++count;</a>
<a name="ln909">    int k;</a>
<a name="ln910">    if (count_delim_) {</a>
<a name="ln911">      rtype1 = &quot;&quot;;</a>
<a name="ln912">      s1 = 0;</a>
<a name="ln913">      row = iter-&gt;key().ToString();</a>
<a name="ln914">      val = iter-&gt;value().ToString();</a>
<a name="ln915">      for (k = 0; row[k] != '\x01' &amp;&amp; row[k] != '\0'; k++)</a>
<a name="ln916">        s1++;</a>
<a name="ln917">      for (k = 0; val[k] != '\x01' &amp;&amp; val[k] != '\0'; k++)</a>
<a name="ln918">        s1++;</a>
<a name="ln919">      for (int j = 0; row[j] != delim_[0] &amp;&amp; row[j] != '\0' &amp;&amp; row[j] != '\x01'; j++)</a>
<a name="ln920">        rtype1 += row[j];</a>
<a name="ln921">      if (rtype2.compare(&quot;&quot;) &amp;&amp; rtype2.compare(rtype1) != 0) {</a>
<a name="ln922">        fprintf(stdout, &quot;%s =&gt; count:%&quot; PRIu64 &quot;\tsize:%&quot; PRIu64 &quot;\n&quot;, rtype2.c_str(), c, s2);</a>
<a name="ln923">        c = 1;</a>
<a name="ln924">        s2 = s1;</a>
<a name="ln925">        rtype2 = rtype1;</a>
<a name="ln926">      } else {</a>
<a name="ln927">        c++;</a>
<a name="ln928">        s2 += s1;</a>
<a name="ln929">        rtype2 = rtype1;</a>
<a name="ln930">    }</a>
<a name="ln931">  }</a>
<a name="ln932"> </a>
<a name="ln933">    if (!count_only_ &amp;&amp; !count_delim_) {</a>
<a name="ln934">      string key = ikey.DebugString(is_key_hex_);</a>
<a name="ln935">      string value = iter-&gt;value().ToString(is_value_hex_);</a>
<a name="ln936">      std::cout &lt;&lt; key &lt;&lt; &quot; =&gt; &quot; &lt;&lt; value &lt;&lt; &quot;\n&quot;;</a>
<a name="ln937">    }</a>
<a name="ln938"> </a>
<a name="ln939">    // Terminate if maximum number of keys have been dumped</a>
<a name="ln940">    if (max_keys_ &gt; 0 &amp;&amp; count &gt;= max_keys_) break;</a>
<a name="ln941">  }</a>
<a name="ln942">  if(count_delim_) {</a>
<a name="ln943">    fprintf(stdout, &quot;%s =&gt; count:%&quot; PRIu64 &quot;\tsize:%&quot; PRIu64 &quot;\n&quot;, rtype2.c_str(), c, s2);</a>
<a name="ln944">  } else {</a>
<a name="ln945">    fprintf(stdout, &quot;Internal keys in range: %&quot; PRId64 &quot;\n&quot;, count);</a>
<a name="ln946">  }</a>
<a name="ln947">}</a>
<a name="ln948"> </a>
<a name="ln949"> </a>
<a name="ln950">const string DBDumperCommand::ARG_COUNT_ONLY = &quot;count_only&quot;;</a>
<a name="ln951">const string DBDumperCommand::ARG_COUNT_DELIM = &quot;count_delim&quot;;</a>
<a name="ln952">const string DBDumperCommand::ARG_STATS = &quot;stats&quot;;</a>
<a name="ln953">const string DBDumperCommand::ARG_TTL_BUCKET = &quot;bucket&quot;;</a>
<a name="ln954"> </a>
<a name="ln955">DBDumperCommand::DBDumperCommand(const vector&lt;string&gt;&amp; params,</a>
<a name="ln956">                                 const map&lt;string, string&gt;&amp; options,</a>
<a name="ln957">                                 const vector&lt;string&gt;&amp; flags)</a>
<a name="ln958">    : LDBCommand(options, flags, true,</a>
<a name="ln959">                 BuildCmdLineOptions(</a>
<a name="ln960">                     {ARG_TTL, ARG_HEX, ARG_KEY_HEX, ARG_VALUE_HEX, ARG_FROM,</a>
<a name="ln961">                      ARG_TO, ARG_MAX_KEYS, ARG_COUNT_ONLY, ARG_COUNT_DELIM,</a>
<a name="ln962">                      ARG_STATS, ARG_TTL_START, ARG_TTL_END, ARG_TTL_BUCKET,</a>
<a name="ln963">                      ARG_TIMESTAMP, ARG_PATH})),</a>
<a name="ln964">      null_from_(true),</a>
<a name="ln965">      null_to_(true),</a>
<a name="ln966">      max_keys_(-1),</a>
<a name="ln967">      count_only_(false),</a>
<a name="ln968">      count_delim_(false),</a>
<a name="ln969">      print_stats_(false) {</a>
<a name="ln970">  map&lt;string, string&gt;::const_iterator itr = options.find(ARG_FROM);</a>
<a name="ln971">  if (itr != options.end()) {</a>
<a name="ln972">    null_from_ = false;</a>
<a name="ln973">    from_ = itr-&gt;second;</a>
<a name="ln974">  }</a>
<a name="ln975"> </a>
<a name="ln976">  itr = options.find(ARG_TO);</a>
<a name="ln977">  if (itr != options.end()) {</a>
<a name="ln978">    null_to_ = false;</a>
<a name="ln979">    to_ = itr-&gt;second;</a>
<a name="ln980">  }</a>
<a name="ln981"> </a>
<a name="ln982">  itr = options.find(ARG_MAX_KEYS);</a>
<a name="ln983">  if (itr != options.end()) {</a>
<a name="ln984">    try {</a>
<a name="ln985">#if defined(CYGWIN)</a>
<a name="ln986">      max_keys_ = strtol(itr-&gt;second.c_str(), 0, 10);</a>
<a name="ln987">#else</a>
<a name="ln988">      max_keys_ = stoi(itr-&gt;second);</a>
<a name="ln989">#endif</a>
<a name="ln990">    } catch(const std::invalid_argument&amp;) {</a>
<a name="ln991">      exec_state_ = LDBCommandExecuteResult::Failed(ARG_MAX_KEYS +</a>
<a name="ln992">                                                    &quot; has an invalid value&quot;);</a>
<a name="ln993">    } catch(const std::out_of_range&amp;) {</a>
<a name="ln994">      exec_state_ = LDBCommandExecuteResult::Failed(</a>
<a name="ln995">          ARG_MAX_KEYS + &quot; has a value out-of-range&quot;);</a>
<a name="ln996">    }</a>
<a name="ln997">  }</a>
<a name="ln998">  itr = options.find(ARG_COUNT_DELIM);</a>
<a name="ln999">  if (itr != options.end()) {</a>
<a name="ln1000">    delim_ = itr-&gt;second;</a>
<a name="ln1001">    count_delim_ = true;</a>
<a name="ln1002">  } else {</a>
<a name="ln1003">    count_delim_ = IsFlagPresent(flags, ARG_COUNT_DELIM);</a>
<a name="ln1004">    delim_ = &quot;.&quot;;</a>
<a name="ln1005">  }</a>
<a name="ln1006"> </a>
<a name="ln1007">  print_stats_ = IsFlagPresent(flags, ARG_STATS);</a>
<a name="ln1008">  count_only_ = IsFlagPresent(flags, ARG_COUNT_ONLY);</a>
<a name="ln1009"> </a>
<a name="ln1010">  if (is_key_hex_) {</a>
<a name="ln1011">    if (!null_from_) {</a>
<a name="ln1012">      from_ = HexToString(from_);</a>
<a name="ln1013">    }</a>
<a name="ln1014">    if (!null_to_) {</a>
<a name="ln1015">      to_ = HexToString(to_);</a>
<a name="ln1016">    }</a>
<a name="ln1017">  }</a>
<a name="ln1018"> </a>
<a name="ln1019">  itr = options.find(ARG_PATH);</a>
<a name="ln1020">  if (itr != options.end()) {</a>
<a name="ln1021">    path_ = itr-&gt;second;</a>
<a name="ln1022">  }</a>
<a name="ln1023">}</a>
<a name="ln1024"> </a>
<a name="ln1025">void DBDumperCommand::Help(string&amp; ret) {</a>
<a name="ln1026">  ret.append(&quot;  &quot;);</a>
<a name="ln1027">  ret.append(DBDumperCommand::Name());</a>
<a name="ln1028">  ret.append(HelpRangeCmdArgs());</a>
<a name="ln1029">  ret.append(&quot; [--&quot; + ARG_TTL + &quot;]&quot;);</a>
<a name="ln1030">  ret.append(&quot; [--&quot; + ARG_MAX_KEYS + &quot;=&lt;N&gt;]&quot;);</a>
<a name="ln1031">  ret.append(&quot; [--&quot; + ARG_TIMESTAMP + &quot;]&quot;);</a>
<a name="ln1032">  ret.append(&quot; [--&quot; + ARG_COUNT_ONLY + &quot;]&quot;);</a>
<a name="ln1033">  ret.append(&quot; [--&quot; + ARG_COUNT_DELIM + &quot;=&lt;char&gt;]&quot;);</a>
<a name="ln1034">  ret.append(&quot; [--&quot; + ARG_STATS + &quot;]&quot;);</a>
<a name="ln1035">  ret.append(&quot; [--&quot; + ARG_TTL_BUCKET + &quot;=&lt;N&gt;]&quot;);</a>
<a name="ln1036">  ret.append(&quot; [--&quot; + ARG_TTL_START + &quot;=&lt;N&gt;:- is inclusive]&quot;);</a>
<a name="ln1037">  ret.append(&quot; [--&quot; + ARG_TTL_END + &quot;=&lt;N&gt;:- is exclusive]&quot;);</a>
<a name="ln1038">  ret.append(&quot; [--&quot; + ARG_PATH + &quot;=&lt;path_to_a_file&gt;]&quot;);</a>
<a name="ln1039">  ret.append(&quot;\n&quot;);</a>
<a name="ln1040">}</a>
<a name="ln1041"> </a>
<a name="ln1042">/**</a>
<a name="ln1043"> * Handles two separate cases:</a>
<a name="ln1044"> *</a>
<a name="ln1045"> * 1) --db is specified - just dump the database.</a>
<a name="ln1046"> *</a>
<a name="ln1047"> * 2) --path is specified - determine based on file extension what dumping</a>
<a name="ln1048"> *    function to call. Please note that we intentionally use the extension</a>
<a name="ln1049"> *    and avoid probing the file contents under the assumption that renaming</a>
<a name="ln1050"> *    the files is not a supported scenario.</a>
<a name="ln1051"> *</a>
<a name="ln1052"> */</a>
<a name="ln1053">void DBDumperCommand::DoCommand() {</a>
<a name="ln1054">  if (!db_) {</a>
<a name="ln1055">    assert(!path_.empty());</a>
<a name="ln1056">    string fileName = GetFileNameFromPath(path_);</a>
<a name="ln1057">    uint64_t number;</a>
<a name="ln1058">    FileType type;</a>
<a name="ln1059"> </a>
<a name="ln1060">    exec_state_ = LDBCommandExecuteResult::Succeed(&quot;&quot;);</a>
<a name="ln1061"> </a>
<a name="ln1062">    if (!ParseFileName(fileName, &amp;number, &amp;type)) {</a>
<a name="ln1063">      exec_state_ =</a>
<a name="ln1064">          LDBCommandExecuteResult::Failed(&quot;Can't parse file type: &quot; + path_);</a>
<a name="ln1065">      return;</a>
<a name="ln1066">    }</a>
<a name="ln1067"> </a>
<a name="ln1068">    switch (type) {</a>
<a name="ln1069">      case kLogFile:</a>
<a name="ln1070">        DumpWalFile(path_, /* print_header_ */ true, /* print_values_ */ true,</a>
<a name="ln1071">                    &amp;exec_state_);</a>
<a name="ln1072">        break;</a>
<a name="ln1073">      case kTableFile:</a>
<a name="ln1074">        DumpSstFile(path_, is_key_hex_, /* show_properties */ true);</a>
<a name="ln1075">        break;</a>
<a name="ln1076">      case kDescriptorFile:</a>
<a name="ln1077">        DumpManifestFile(path_, /* verbose_ */ false, is_key_hex_);</a>
<a name="ln1078">        break;</a>
<a name="ln1079">      default:</a>
<a name="ln1080">        exec_state_ = LDBCommandExecuteResult::Failed(</a>
<a name="ln1081">            &quot;File type not supported: &quot; + path_);</a>
<a name="ln1082">        break;</a>
<a name="ln1083">    }</a>
<a name="ln1084"> </a>
<a name="ln1085">  } else {</a>
<a name="ln1086">    DoDumpCommand();</a>
<a name="ln1087">  }</a>
<a name="ln1088">}</a>
<a name="ln1089"> </a>
<a name="ln1090">void DBDumperCommand::DoDumpCommand() {</a>
<a name="ln1091">  assert(nullptr != db_);</a>
<a name="ln1092">  assert(path_.empty());</a>
<a name="ln1093"> </a>
<a name="ln1094">  // Parse command line args</a>
<a name="ln1095">  uint64_t count = 0;</a>
<a name="ln1096">  if (print_stats_) {</a>
<a name="ln1097">    string stats;</a>
<a name="ln1098">    if (db_-&gt;GetProperty(&quot;rocksdb.stats&quot;, &amp;stats)) {</a>
<a name="ln1099">      fprintf(stdout, &quot;%s\n&quot;, stats.c_str());</a>
<a name="ln1100">    }</a>
<a name="ln1101">  }</a>
<a name="ln1102"> </a>
<a name="ln1103">  // Setup key iterator</a>
<a name="ln1104">  Iterator* iter = db_-&gt;NewIterator(ReadOptions(), GetCfHandle());</a>
<a name="ln1105">  Status st = iter-&gt;status();</a>
<a name="ln1106">  if (!st.ok()) {</a>
<a name="ln1107">    exec_state_ =</a>
<a name="ln1108">        LDBCommandExecuteResult::Failed(&quot;Iterator error.&quot; + st.ToString());</a>
<a name="ln1109">  }</a>
<a name="ln1110"> </a>
<a name="ln1111">  if (!null_from_) {</a>
<a name="ln1112">    iter-&gt;Seek(from_);</a>
<a name="ln1113">  } else {</a>
<a name="ln1114">    iter-&gt;SeekToFirst();</a>
<a name="ln1115">  }</a>
<a name="ln1116"> </a>
<a name="ln1117">  int max_keys = max_keys_;</a>
<a name="ln1118">  int ttl_start;</a>
<a name="ln1119">  if (!ParseIntOption(option_map_, ARG_TTL_START, ttl_start, exec_state_)) {</a>
<a name="ln1120">    ttl_start = DBWithTTLImpl::kMinTimestamp;  // TTL introduction time</a>
<a name="ln1121">  }</a>
<a name="ln1122">  int ttl_end;</a>
<a name="ln1123">  if (!ParseIntOption(option_map_, ARG_TTL_END, ttl_end, exec_state_)) {</a>
<a name="ln1124">    ttl_end = DBWithTTLImpl::kMaxTimestamp;  // Max time allowed by TTL feature</a>
<a name="ln1125">  }</a>
<a name="ln1126">  if (ttl_end &lt; ttl_start) {</a>
<a name="ln1127">    fprintf(stderr, &quot;Error: End time can't be less than start time\n&quot;);</a>
<a name="ln1128">    delete iter;</a>
<a name="ln1129">    return;</a>
<a name="ln1130">  }</a>
<a name="ln1131">  int time_range = ttl_end - ttl_start;</a>
<a name="ln1132">  int bucket_size;</a>
<a name="ln1133">  if (!ParseIntOption(option_map_, ARG_TTL_BUCKET, bucket_size, exec_state_) ||</a>
<a name="ln1134">      bucket_size &lt;= 0) {</a>
<a name="ln1135">    bucket_size = time_range; // Will have just 1 bucket by default</a>
<a name="ln1136">  }</a>
<a name="ln1137">  // Creating variables for row count of each type</a>
<a name="ln1138">  string rtype1, rtype2, row, val;</a>
<a name="ln1139">  rtype2 = &quot;&quot;;</a>
<a name="ln1140">  uint64_t c = 0;</a>
<a name="ln1141">  uint64_t s1 = 0, s2 = 0;</a>
<a name="ln1142"> </a>
<a name="ln1143">  // At this point, bucket_size=0 =&gt; time_range=0</a>
<a name="ln1144">  int num_buckets = (bucket_size &gt;= time_range)</a>
<a name="ln1145">                        ? 1</a>
<a name="ln1146">                        : ((time_range + bucket_size - 1) / bucket_size);</a>
<a name="ln1147">  vector&lt;uint64_t&gt; bucket_counts(num_buckets, 0);</a>
<a name="ln1148">  if (is_db_ttl_ &amp;&amp; !count_only_ &amp;&amp; timestamp_ &amp;&amp; !count_delim_) {</a>
<a name="ln1149">    fprintf(stdout, &quot;Dumping key-values from %s to %s\n&quot;,</a>
<a name="ln1150">            ReadableTime(ttl_start).c_str(), ReadableTime(ttl_end).c_str());</a>
<a name="ln1151">  }</a>
<a name="ln1152"> </a>
<a name="ln1153">  for (; iter-&gt;Valid(); iter-&gt;Next()) {</a>
<a name="ln1154">    int rawtime = 0;</a>
<a name="ln1155">    // If end marker was specified, we stop before it</a>
<a name="ln1156">    if (!null_to_ &amp;&amp; (iter-&gt;key().ToString() &gt;= to_))</a>
<a name="ln1157">      break;</a>
<a name="ln1158">    // Terminate if maximum number of keys have been dumped</a>
<a name="ln1159">    if (max_keys == 0)</a>
<a name="ln1160">      break;</a>
<a name="ln1161">    if (is_db_ttl_) {</a>
<a name="ln1162">      TtlIterator* it_ttl = dynamic_cast&lt;TtlIterator*&gt;(iter);</a>
<a name="ln1163">      assert(it_ttl);</a>
<a name="ln1164">      rawtime = it_ttl-&gt;timestamp();</a>
<a name="ln1165">      if (rawtime &lt; ttl_start || rawtime &gt;= ttl_end) {</a>
<a name="ln1166">        continue;</a>
<a name="ln1167">      }</a>
<a name="ln1168">    }</a>
<a name="ln1169">    if (max_keys &gt; 0) {</a>
<a name="ln1170">      --max_keys;</a>
<a name="ln1171">    }</a>
<a name="ln1172">    if (is_db_ttl_ &amp;&amp; num_buckets &gt; 1) {</a>
<a name="ln1173">      IncBucketCounts(&amp;bucket_counts, ttl_start, time_range, bucket_size,</a>
<a name="ln1174">                      rawtime, num_buckets);</a>
<a name="ln1175">    }</a>
<a name="ln1176">    ++count;</a>
<a name="ln1177">    if (count_delim_) {</a>
<a name="ln1178">      rtype1 = &quot;&quot;;</a>
<a name="ln1179">      row = iter-&gt;key().ToString();</a>
<a name="ln1180">      val = iter-&gt;value().ToString();</a>
<a name="ln1181">      s1 = row.size()+val.size();</a>
<a name="ln1182">      for (int j = 0; row[j] != delim_[0] &amp;&amp; row[j] != '\0'; j++)</a>
<a name="ln1183">        rtype1 += row[j];</a>
<a name="ln1184">      if (rtype2.compare(&quot;&quot;) &amp;&amp; rtype2.compare(rtype1) != 0) {</a>
<a name="ln1185">        fprintf(stdout, &quot;%s =&gt; count:%&quot; PRIu64 &quot;\tsize:%&quot; PRIu64 &quot;\n&quot;, rtype2.c_str(), c, s2);</a>
<a name="ln1186">        c = 1;</a>
<a name="ln1187">        s2 = s1;</a>
<a name="ln1188">        rtype2 = rtype1;</a>
<a name="ln1189">      } else {</a>
<a name="ln1190">          c++;</a>
<a name="ln1191">          s2 += s1;</a>
<a name="ln1192">          rtype2 = rtype1;</a>
<a name="ln1193">      }</a>
<a name="ln1194"> </a>
<a name="ln1195">    }</a>
<a name="ln1196"> </a>
<a name="ln1197"> </a>
<a name="ln1198"> </a>
<a name="ln1199">    if (!count_only_ &amp;&amp; !count_delim_) {</a>
<a name="ln1200">      if (is_db_ttl_ &amp;&amp; timestamp_) {</a>
<a name="ln1201">        fprintf(stdout, &quot;%s &quot;, ReadableTime(rawtime).c_str());</a>
<a name="ln1202">      }</a>
<a name="ln1203">      string str = PrintKeyValue(iter-&gt;key().ToString(),</a>
<a name="ln1204">                                 iter-&gt;value().ToString(), is_key_hex_,</a>
<a name="ln1205">                                 is_value_hex_);</a>
<a name="ln1206">      fprintf(stdout, &quot;%s\n&quot;, str.c_str());</a>
<a name="ln1207">    }</a>
<a name="ln1208">  }</a>
<a name="ln1209"> </a>
<a name="ln1210">  if (num_buckets &gt; 1 &amp;&amp; is_db_ttl_) {</a>
<a name="ln1211">    PrintBucketCounts(bucket_counts, ttl_start, ttl_end, bucket_size,</a>
<a name="ln1212">                      num_buckets);</a>
<a name="ln1213">  } else if(count_delim_) {</a>
<a name="ln1214">    fprintf(stdout, &quot;%s =&gt; count:%&quot; PRIu64 &quot;\tsize:%&quot; PRIu64 &quot;\n&quot;, rtype2.c_str(), c, s2);</a>
<a name="ln1215">  } else {</a>
<a name="ln1216">    fprintf(stdout, &quot;Keys in range: %&quot; PRIu64 &quot;\n&quot;, count);</a>
<a name="ln1217">  }</a>
<a name="ln1218">  // Clean up</a>
<a name="ln1219">  delete iter;</a>
<a name="ln1220">}</a>
<a name="ln1221"> </a>
<a name="ln1222">const string ReduceDBLevelsCommand::ARG_NEW_LEVELS = &quot;new_levels&quot;;</a>
<a name="ln1223">const string  ReduceDBLevelsCommand::ARG_PRINT_OLD_LEVELS = &quot;print_old_levels&quot;;</a>
<a name="ln1224"> </a>
<a name="ln1225">ReduceDBLevelsCommand::ReduceDBLevelsCommand(const vector&lt;string&gt;&amp; params,</a>
<a name="ln1226">      const map&lt;string, string&gt;&amp; options, const vector&lt;string&gt;&amp; flags) :</a>
<a name="ln1227">    LDBCommand(options, flags, false,</a>
<a name="ln1228">               BuildCmdLineOptions({ARG_NEW_LEVELS, ARG_PRINT_OLD_LEVELS})),</a>
<a name="ln1229">    old_levels_(1 &lt;&lt; 7),</a>
<a name="ln1230">    new_levels_(-1),</a>
<a name="ln1231">    print_old_levels_(false) {</a>
<a name="ln1232"> </a>
<a name="ln1233"> </a>
<a name="ln1234">  ParseIntOption(option_map_, ARG_NEW_LEVELS, new_levels_, exec_state_);</a>
<a name="ln1235">  print_old_levels_ = IsFlagPresent(flags, ARG_PRINT_OLD_LEVELS);</a>
<a name="ln1236"> </a>
<a name="ln1237">  if(new_levels_ &lt;= 0) {</a>
<a name="ln1238">    exec_state_ = LDBCommandExecuteResult::Failed(</a>
<a name="ln1239">        &quot; Use --&quot; + ARG_NEW_LEVELS + &quot; to specify a new level number\n&quot;);</a>
<a name="ln1240">  }</a>
<a name="ln1241">}</a>
<a name="ln1242"> </a>
<a name="ln1243">vector&lt;string&gt; ReduceDBLevelsCommand::PrepareArgs(const string&amp; db_path,</a>
<a name="ln1244">    int new_levels, bool print_old_level) {</a>
<a name="ln1245">  vector&lt;string&gt; ret;</a>
<a name="ln1246">  ret.push_back(&quot;reduce_levels&quot;);</a>
<a name="ln1247">  ret.push_back(&quot;--&quot; + ARG_DB + &quot;=&quot; + db_path);</a>
<a name="ln1248">  ret.push_back(&quot;--&quot; + ARG_NEW_LEVELS + &quot;=&quot; + rocksdb::ToString(new_levels));</a>
<a name="ln1249">  if(print_old_level) {</a>
<a name="ln1250">    ret.push_back(&quot;--&quot; + ARG_PRINT_OLD_LEVELS);</a>
<a name="ln1251">  }</a>
<a name="ln1252">  return ret;</a>
<a name="ln1253">}</a>
<a name="ln1254"> </a>
<a name="ln1255">void ReduceDBLevelsCommand::Help(string&amp; ret) {</a>
<a name="ln1256">  ret.append(&quot;  &quot;);</a>
<a name="ln1257">  ret.append(ReduceDBLevelsCommand::Name());</a>
<a name="ln1258">  ret.append(&quot; --&quot; + ARG_NEW_LEVELS + &quot;=&lt;New number of levels&gt;&quot;);</a>
<a name="ln1259">  ret.append(&quot; [--&quot; + ARG_PRINT_OLD_LEVELS + &quot;]&quot;);</a>
<a name="ln1260">  ret.append(&quot;\n&quot;);</a>
<a name="ln1261">}</a>
<a name="ln1262"> </a>
<a name="ln1263">Options ReduceDBLevelsCommand::PrepareOptionsForOpenDB() {</a>
<a name="ln1264">  Options opt = LDBCommand::PrepareOptionsForOpenDB();</a>
<a name="ln1265">  opt.num_levels = old_levels_;</a>
<a name="ln1266">  opt.max_bytes_for_level_multiplier_additional.resize(opt.num_levels, 1);</a>
<a name="ln1267">  // Disable size compaction</a>
<a name="ln1268">  opt.max_bytes_for_level_base = 1ULL &lt;&lt; 50;</a>
<a name="ln1269">  opt.max_bytes_for_level_multiplier = 1;</a>
<a name="ln1270">  return opt;</a>
<a name="ln1271">}</a>
<a name="ln1272"> </a>
<a name="ln1273">Status ReduceDBLevelsCommand::GetOldNumOfLevels(Options&amp; opt,</a>
<a name="ln1274">    int* levels) {</a>
<a name="ln1275">  EnvOptions soptions;</a>
<a name="ln1276">  std::shared_ptr&lt;Cache&gt; tc(</a>
<a name="ln1277">      NewLRUCache(opt.max_open_files - 10, opt.table_cache_numshardbits));</a>
<a name="ln1278">  const InternalKeyComparator cmp(opt.comparator);</a>
<a name="ln1279">  WriteController wc(opt.delayed_write_rate);</a>
<a name="ln1280">  WriteBuffer wb(opt.db_write_buffer_size);</a>
<a name="ln1281">  VersionSet versions(db_path_, &amp;opt, soptions, tc.get(), &amp;wb, &amp;wc);</a>
<a name="ln1282">  std::vector&lt;ColumnFamilyDescriptor&gt; dummy;</a>
<a name="ln1283">  ColumnFamilyDescriptor dummy_descriptor(kDefaultColumnFamilyName,</a>
<a name="ln1284">                                          ColumnFamilyOptions(opt));</a>
<a name="ln1285">  dummy.push_back(dummy_descriptor);</a>
<a name="ln1286">  // We rely the VersionSet::Recover to tell us the internal data structures</a>
<a name="ln1287">  // in the db. And the Recover() should never do any change</a>
<a name="ln1288">  // (like LogAndApply) to the manifest file.</a>
<a name="ln1289">  Status st = versions.Recover(dummy);</a>
<a name="ln1290">  if (!st.ok()) {</a>
<a name="ln1291">    return st;</a>
<a name="ln1292">  }</a>
<a name="ln1293">  int max = -1;</a>
<a name="ln1294">  auto default_cfd = versions.GetColumnFamilySet()-&gt;GetDefault();</a>
<a name="ln1295">  for (int i = 0; i &lt; default_cfd-&gt;NumberLevels(); i++) {</a>
<a name="ln1296">    if (default_cfd-&gt;current()-&gt;storage_info()-&gt;NumLevelFiles(i)) {</a>
<a name="ln1297">      max = i;</a>
<a name="ln1298">    }</a>
<a name="ln1299">  }</a>
<a name="ln1300"> </a>
<a name="ln1301">  *levels = max + 1;</a>
<a name="ln1302">  return st;</a>
<a name="ln1303">}</a>
<a name="ln1304"> </a>
<a name="ln1305">void ReduceDBLevelsCommand::DoCommand() {</a>
<a name="ln1306">  if (new_levels_ &lt;= 1) {</a>
<a name="ln1307">    exec_state_ =</a>
<a name="ln1308">        LDBCommandExecuteResult::Failed(&quot;Invalid number of levels.\n&quot;);</a>
<a name="ln1309">    return;</a>
<a name="ln1310">  }</a>
<a name="ln1311"> </a>
<a name="ln1312">  Status st;</a>
<a name="ln1313">  Options opt = PrepareOptionsForOpenDB();</a>
<a name="ln1314">  int old_level_num = -1;</a>
<a name="ln1315">  st = GetOldNumOfLevels(opt, &amp;old_level_num);</a>
<a name="ln1316">  if (!st.ok()) {</a>
<a name="ln1317">    exec_state_ = LDBCommandExecuteResult::Failed(st.ToString());</a>
<a name="ln1318">    return;</a>
<a name="ln1319">  }</a>
<a name="ln1320"> </a>
<a name="ln1321">  if (print_old_levels_) {</a>
<a name="ln1322">    fprintf(stdout, &quot;The old number of levels in use is %d\n&quot;, old_level_num);</a>
<a name="ln1323">  }</a>
<a name="ln1324"> </a>
<a name="ln1325">  if (old_level_num &lt;= new_levels_) {</a>
<a name="ln1326">    return;</a>
<a name="ln1327">  }</a>
<a name="ln1328"> </a>
<a name="ln1329">  old_levels_ = old_level_num;</a>
<a name="ln1330"> </a>
<a name="ln1331">  OpenDB();</a>
<a name="ln1332">  if (!db_) {</a>
<a name="ln1333">    return;</a>
<a name="ln1334">  }</a>
<a name="ln1335">  // Compact the whole DB to put all files to the highest level.</a>
<a name="ln1336">  fprintf(stdout, &quot;Compacting the db...\n&quot;);</a>
<a name="ln1337">  CHECK_OK(db_-&gt;CompactRange(CompactRangeOptions(), GetCfHandle(), nullptr, nullptr));</a>
<a name="ln1338">  CloseDB();</a>
<a name="ln1339"> </a>
<a name="ln1340">  EnvOptions soptions;</a>
<a name="ln1341">  st = VersionSet::ReduceNumberOfLevels(db_path_, &amp;opt, soptions, new_levels_);</a>
<a name="ln1342">  if (!st.ok()) {</a>
<a name="ln1343">    exec_state_ = LDBCommandExecuteResult::Failed(st.ToString());</a>
<a name="ln1344">    return;</a>
<a name="ln1345">  }</a>
<a name="ln1346">}</a>
<a name="ln1347"> </a>
<a name="ln1348">const string ChangeCompactionStyleCommand::ARG_OLD_COMPACTION_STYLE =</a>
<a name="ln1349">  &quot;old_compaction_style&quot;;</a>
<a name="ln1350">const string ChangeCompactionStyleCommand::ARG_NEW_COMPACTION_STYLE =</a>
<a name="ln1351">  &quot;new_compaction_style&quot;;</a>
<a name="ln1352"> </a>
<a name="ln1353">ChangeCompactionStyleCommand::ChangeCompactionStyleCommand(</a>
<a name="ln1354">      const vector&lt;string&gt;&amp; params, const map&lt;string, string&gt;&amp; options,</a>
<a name="ln1355">      const vector&lt;string&gt;&amp; flags) :</a>
<a name="ln1356">    LDBCommand(options, flags, false,</a>
<a name="ln1357">               BuildCmdLineOptions({ARG_OLD_COMPACTION_STYLE,</a>
<a name="ln1358">                                    ARG_NEW_COMPACTION_STYLE})),</a>
<a name="ln1359">    old_compaction_style_(-1),</a>
<a name="ln1360">    new_compaction_style_(-1) {</a>
<a name="ln1361"> </a>
<a name="ln1362">  ParseIntOption(option_map_, ARG_OLD_COMPACTION_STYLE, old_compaction_style_,</a>
<a name="ln1363">    exec_state_);</a>
<a name="ln1364">  if (old_compaction_style_ != kCompactionStyleLevel &amp;&amp;</a>
<a name="ln1365">     old_compaction_style_ != kCompactionStyleUniversal) {</a>
<a name="ln1366">    exec_state_ = LDBCommandExecuteResult::Failed(</a>
<a name="ln1367">        &quot;Use --&quot; + ARG_OLD_COMPACTION_STYLE + &quot; to specify old compaction &quot; +</a>
<a name="ln1368">        &quot;style. Check ldb help for proper compaction style value.\n&quot;);</a>
<a name="ln1369">    return;</a>
<a name="ln1370">  }</a>
<a name="ln1371"> </a>
<a name="ln1372">  ParseIntOption(option_map_, ARG_NEW_COMPACTION_STYLE, new_compaction_style_,</a>
<a name="ln1373">    exec_state_);</a>
<a name="ln1374">  if (new_compaction_style_ != kCompactionStyleLevel &amp;&amp;</a>
<a name="ln1375">     new_compaction_style_ != kCompactionStyleUniversal) {</a>
<a name="ln1376">    exec_state_ = LDBCommandExecuteResult::Failed(</a>
<a name="ln1377">        &quot;Use --&quot; + ARG_NEW_COMPACTION_STYLE + &quot; to specify new compaction &quot; +</a>
<a name="ln1378">        &quot;style. Check ldb help for proper compaction style value.\n&quot;);</a>
<a name="ln1379">    return;</a>
<a name="ln1380">  }</a>
<a name="ln1381"> </a>
<a name="ln1382">  if (new_compaction_style_ == old_compaction_style_) {</a>
<a name="ln1383">    exec_state_ = LDBCommandExecuteResult::Failed(</a>
<a name="ln1384">        &quot;Old compaction style is the same as new compaction style. &quot;</a>
<a name="ln1385">        &quot;Nothing to do.\n&quot;);</a>
<a name="ln1386">    return;</a>
<a name="ln1387">  }</a>
<a name="ln1388"> </a>
<a name="ln1389">  if (old_compaction_style_ == kCompactionStyleUniversal &amp;&amp;</a>
<a name="ln1390">      new_compaction_style_ == kCompactionStyleLevel) {</a>
<a name="ln1391">    exec_state_ = LDBCommandExecuteResult::Failed(</a>
<a name="ln1392">        &quot;Convert from universal compaction to level compaction. &quot;</a>
<a name="ln1393">        &quot;Nothing to do.\n&quot;);</a>
<a name="ln1394">    return;</a>
<a name="ln1395">  }</a>
<a name="ln1396">}</a>
<a name="ln1397"> </a>
<a name="ln1398">void ChangeCompactionStyleCommand::Help(string&amp; ret) {</a>
<a name="ln1399">  ret.append(&quot;  &quot;);</a>
<a name="ln1400">  ret.append(ChangeCompactionStyleCommand::Name());</a>
<a name="ln1401">  ret.append(&quot; --&quot; + ARG_OLD_COMPACTION_STYLE + &quot;=&lt;Old compaction style: 0 &quot; +</a>
<a name="ln1402">             &quot;for level compaction, 1 for universal compaction&gt;&quot;);</a>
<a name="ln1403">  ret.append(&quot; --&quot; + ARG_NEW_COMPACTION_STYLE + &quot;=&lt;New compaction style: 0 &quot; +</a>
<a name="ln1404">             &quot;for level compaction, 1 for universal compaction&gt;&quot;);</a>
<a name="ln1405">  ret.append(&quot;\n&quot;);</a>
<a name="ln1406">}</a>
<a name="ln1407"> </a>
<a name="ln1408">Options ChangeCompactionStyleCommand::PrepareOptionsForOpenDB() {</a>
<a name="ln1409">  Options opt = LDBCommand::PrepareOptionsForOpenDB();</a>
<a name="ln1410"> </a>
<a name="ln1411">  if (old_compaction_style_ == kCompactionStyleLevel &amp;&amp;</a>
<a name="ln1412">      new_compaction_style_ == kCompactionStyleUniversal) {</a>
<a name="ln1413">    // In order to convert from level compaction to universal compaction, we</a>
<a name="ln1414">    // need to compact all data into a single file and move it to level 0.</a>
<a name="ln1415">    opt.disable_auto_compactions = true;</a>
<a name="ln1416">    opt.target_file_size_base = INT_MAX;</a>
<a name="ln1417">    opt.target_file_size_multiplier = 1;</a>
<a name="ln1418">    opt.max_bytes_for_level_base = INT_MAX;</a>
<a name="ln1419">    opt.max_bytes_for_level_multiplier = 1;</a>
<a name="ln1420">  }</a>
<a name="ln1421"> </a>
<a name="ln1422">  return opt;</a>
<a name="ln1423">}</a>
<a name="ln1424"> </a>
<a name="ln1425">void ChangeCompactionStyleCommand::DoCommand() {</a>
<a name="ln1426">  // print db stats before we have made any change</a>
<a name="ln1427">  std::string property;</a>
<a name="ln1428">  std::string files_per_level;</a>
<a name="ln1429">  for (int i = 0; i &lt; db_-&gt;NumberLevels(GetCfHandle()); i++) {</a>
<a name="ln1430">    db_-&gt;GetProperty(GetCfHandle(),</a>
<a name="ln1431">                     &quot;rocksdb.num-files-at-level&quot; + NumberToString(i),</a>
<a name="ln1432">                     &amp;property);</a>
<a name="ln1433"> </a>
<a name="ln1434">    // format print string</a>
<a name="ln1435">    char buf[100];</a>
<a name="ln1436">    snprintf(buf, sizeof(buf), &quot;%s%s&quot;, (i ? &quot;,&quot; : &quot;&quot;), property.c_str());</a>
<a name="ln1437">    files_per_level += buf;</a>
<a name="ln1438">  }</a>
<a name="ln1439">  fprintf(stdout, &quot;files per level before compaction: %s\n&quot;,</a>
<a name="ln1440">          files_per_level.c_str());</a>
<a name="ln1441"> </a>
<a name="ln1442">  // manual compact into a single file and move the file to level 0</a>
<a name="ln1443">  CompactRangeOptions compact_options;</a>
<a name="ln1444">  compact_options.change_level = true;</a>
<a name="ln1445">  compact_options.target_level = 0;</a>
<a name="ln1446">  CHECK_OK(db_-&gt;CompactRange(compact_options, GetCfHandle(), nullptr, nullptr));</a>
<a name="ln1447"> </a>
<a name="ln1448">  // verify compaction result</a>
<a name="ln1449">  files_per_level = &quot;&quot;;</a>
<a name="ln1450">  int num_files = 0;</a>
<a name="ln1451">  for (int i = 0; i &lt; db_-&gt;NumberLevels(); i++) {</a>
<a name="ln1452">    db_-&gt;GetProperty(GetCfHandle(),</a>
<a name="ln1453">                     &quot;rocksdb.num-files-at-level&quot; + NumberToString(i),</a>
<a name="ln1454">                     &amp;property);</a>
<a name="ln1455"> </a>
<a name="ln1456">    // format print string</a>
<a name="ln1457">    char buf[100];</a>
<a name="ln1458">    snprintf(buf, sizeof(buf), &quot;%s%s&quot;, (i ? &quot;,&quot; : &quot;&quot;), property.c_str());</a>
<a name="ln1459">    files_per_level += buf;</a>
<a name="ln1460"> </a>
<a name="ln1461">    num_files = atoi(property.c_str());</a>
<a name="ln1462"> </a>
<a name="ln1463">    // level 0 should have only 1 file</a>
<a name="ln1464">    if (i == 0 &amp;&amp; num_files != 1) {</a>
<a name="ln1465">      exec_state_ = LDBCommandExecuteResult::Failed(</a>
<a name="ln1466">          &quot;Number of db files at &quot;</a>
<a name="ln1467">          &quot;level 0 after compaction is &quot; +</a>
<a name="ln1468">          ToString(num_files) + &quot;, not 1.\n&quot;);</a>
<a name="ln1469">      return;</a>
<a name="ln1470">    }</a>
<a name="ln1471">    // other levels should have no file</a>
<a name="ln1472">    if (i &gt; 0 &amp;&amp; num_files != 0) {</a>
<a name="ln1473">      exec_state_ = LDBCommandExecuteResult::Failed(</a>
<a name="ln1474">          &quot;Number of db files at &quot;</a>
<a name="ln1475">          &quot;level &quot; +</a>
<a name="ln1476">          ToString(i) + &quot; after compaction is &quot; + ToString(num_files) +</a>
<a name="ln1477">          &quot;, not 0.\n&quot;);</a>
<a name="ln1478">      return;</a>
<a name="ln1479">    }</a>
<a name="ln1480">  }</a>
<a name="ln1481"> </a>
<a name="ln1482">  fprintf(stdout, &quot;files per level after compaction: %s\n&quot;,</a>
<a name="ln1483">          files_per_level.c_str());</a>
<a name="ln1484">}</a>
<a name="ln1485"> </a>
<a name="ln1486">// ----------------------------------------------------------------------------</a>
<a name="ln1487"> </a>
<a name="ln1488">namespace {</a>
<a name="ln1489"> </a>
<a name="ln1490">struct StdErrReporter : public log::Reader::Reporter {</a>
<a name="ln1491">  void Corruption(size_t bytes, const Status&amp; s) override {</a>
<a name="ln1492">    std::cerr &lt;&lt; &quot;Corruption detected in log file &quot; &lt;&lt; s.ToString() &lt;&lt; &quot;\n&quot;;</a>
<a name="ln1493">  }</a>
<a name="ln1494">};</a>
<a name="ln1495"> </a>
<a name="ln1496">class InMemoryHandler : public WriteBatch::Handler {</a>
<a name="ln1497"> public:</a>
<a name="ln1498">  InMemoryHandler(std::stringstream&amp; row, bool print_values) : Handler(), row_(row) {</a>
<a name="ln1499">    print_values_ = print_values;</a>
<a name="ln1500">  }</a>
<a name="ln1501"> </a>
<a name="ln1502">  void commonPutMerge(const Slice&amp; key, const Slice&amp; value) {</a>
<a name="ln1503">    string k = LDBCommand::StringToHex(key.ToString());</a>
<a name="ln1504">    if (print_values_) {</a>
<a name="ln1505">      string v = LDBCommand::StringToHex(value.ToString());</a>
<a name="ln1506">      row_ &lt;&lt; k &lt;&lt; &quot; : &quot;;</a>
<a name="ln1507">      row_ &lt;&lt; v &lt;&lt; &quot; &quot;;</a>
<a name="ln1508">    } else {</a>
<a name="ln1509">      row_ &lt;&lt; k &lt;&lt; &quot; &quot;;</a>
<a name="ln1510">    }</a>
<a name="ln1511">  }</a>
<a name="ln1512"> </a>
<a name="ln1513">  void Put(const Slice&amp; key, const Slice&amp; value) override {</a>
<a name="ln1514">    row_ &lt;&lt; &quot;PUT : &quot;;</a>
<a name="ln1515">    commonPutMerge(key, value);</a>
<a name="ln1516">  }</a>
<a name="ln1517"> </a>
<a name="ln1518">  void Merge(const Slice&amp; key, const Slice&amp; value) override {</a>
<a name="ln1519">    row_ &lt;&lt; &quot;MERGE : &quot;;</a>
<a name="ln1520">    commonPutMerge(key, value);</a>
<a name="ln1521">  }</a>
<a name="ln1522"> </a>
<a name="ln1523">  void Delete(const Slice&amp; key) override {</a>
<a name="ln1524">    row_ &lt;&lt; &quot;DELETE : &quot;;</a>
<a name="ln1525">    row_ &lt;&lt; LDBCommand::StringToHex(key.ToBuffer()) &lt;&lt; &quot; &quot;;</a>
<a name="ln1526">  }</a>
<a name="ln1527"> </a>
<a name="ln1528">  Status Frontiers(const UserFrontiers&amp; range) override {</a>
<a name="ln1529">    row_ &lt;&lt; &quot; MARGIN_RANGE : &quot; &lt;&lt; range.ToString() &lt;&lt; &quot; &quot;;</a>
<a name="ln1530">    return Status::OK();</a>
<a name="ln1531">  }</a>
<a name="ln1532"> </a>
<a name="ln1533">  virtual ~InMemoryHandler() {}</a>
<a name="ln1534"> </a>
<a name="ln1535"> private:</a>
<a name="ln1536">  std::stringstream &amp; row_;</a>
<a name="ln1537">  bool print_values_;</a>
<a name="ln1538">};</a>
<a name="ln1539"> </a>
<a name="ln1540">void DumpWalFile(std::string wal_file, bool print_header, bool print_values,</a>
<a name="ln1541">                 LDBCommandExecuteResult* exec_state) {</a>
<a name="ln1542">  Env* env_ = Env::Default();</a>
<a name="ln1543">  EnvOptions soptions;</a>
<a name="ln1544">  unique_ptr&lt;SequentialFileReader&gt; wal_file_reader;</a>
<a name="ln1545"> </a>
<a name="ln1546">  Status status;</a>
<a name="ln1547">  {</a>
<a name="ln1548">    unique_ptr&lt;SequentialFile&gt; file;</a>
<a name="ln1549">    status = env_-&gt;NewSequentialFile(wal_file, &amp;file, soptions);</a>
<a name="ln1550">    if (status.ok()) {</a>
<a name="ln1551">      wal_file_reader.reset(new SequentialFileReader(std::move(file)));</a>
<a name="ln1552">    }</a>
<a name="ln1553">  }</a>
<a name="ln1554">  if (!status.ok()) {</a>
<a name="ln1555">    if (exec_state) {</a>
<a name="ln1556">      *exec_state = LDBCommandExecuteResult::Failed(&quot;Failed to open WAL file &quot; +</a>
<a name="ln1557">                                                    status.ToString());</a>
<a name="ln1558">    } else {</a>
<a name="ln1559">      std::cerr &lt;&lt; &quot;Error: Failed to open WAL file &quot; &lt;&lt; status.ToString()</a>
<a name="ln1560">                &lt;&lt; std::endl;</a>
<a name="ln1561">    }</a>
<a name="ln1562">  } else {</a>
<a name="ln1563">    StdErrReporter reporter;</a>
<a name="ln1564">    uint64_t log_number;</a>
<a name="ln1565">    FileType type;</a>
<a name="ln1566"> </a>
<a name="ln1567">    // we need the log number, but ParseFilename expects dbname/NNN.log.</a>
<a name="ln1568">    string sanitized = wal_file;</a>
<a name="ln1569">    size_t lastslash = sanitized.rfind('/');</a>
<a name="ln1570">    if (lastslash != std::string::npos)</a>
<a name="ln1571">      sanitized = sanitized.substr(lastslash + 1);</a>
<a name="ln1572">    if (!ParseFileName(sanitized, &amp;log_number, &amp;type)) {</a>
<a name="ln1573">      // bogus input, carry on as best we can</a>
<a name="ln1574">      log_number = 0;</a>
<a name="ln1575">    }</a>
<a name="ln1576">    DBOptions db_options;</a>
<a name="ln1577">    log::Reader reader(db_options.info_log, move(wal_file_reader), &amp;reporter,</a>
<a name="ln1578">                       true, 0, log_number);</a>
<a name="ln1579">    string scratch;</a>
<a name="ln1580">    WriteBatch batch;</a>
<a name="ln1581">    Slice record;</a>
<a name="ln1582">    std::stringstream row;</a>
<a name="ln1583">    if (print_header) {</a>
<a name="ln1584">      std::cout &lt;&lt; &quot;Sequence,Count,ByteSize,Physical Offset,Key(s)&quot;;</a>
<a name="ln1585">      if (print_values) {</a>
<a name="ln1586">        std::cout &lt;&lt; &quot; : value &quot;;</a>
<a name="ln1587">      }</a>
<a name="ln1588">      std::cout &lt;&lt; &quot;\n&quot;;</a>
<a name="ln1589">    }</a>
<a name="ln1590">    while (reader.ReadRecord(&amp;record, &amp;scratch)) {</a>
<a name="ln1591">      row.str(&quot;&quot;);</a>
<a name="ln1592">      if (record.size() &lt; 12) {</a>
<a name="ln1593">        reporter.Corruption(record.size(),</a>
<a name="ln1594">                            STATUS(Corruption, &quot;log record too small&quot;));</a>
<a name="ln1595">      } else {</a>
<a name="ln1596">        WriteBatchInternal::SetContents(&amp;batch, record);</a>
<a name="ln1597">        row &lt;&lt; WriteBatchInternal::Sequence(&amp;batch) &lt;&lt; &quot;,&quot;;</a>
<a name="ln1598">        row &lt;&lt; WriteBatchInternal::Count(&amp;batch) &lt;&lt; &quot;,&quot;;</a>
<a name="ln1599">        row &lt;&lt; WriteBatchInternal::ByteSize(&amp;batch) &lt;&lt; &quot;,&quot;;</a>
<a name="ln1600">        row &lt;&lt; reader.LastRecordOffset() &lt;&lt; &quot;,&quot;;</a>
<a name="ln1601">        InMemoryHandler handler(row, print_values);</a>
<a name="ln1602">        CHECK_OK(batch.Iterate(&amp;handler));</a>
<a name="ln1603">        row &lt;&lt; &quot;\n&quot;;</a>
<a name="ln1604">      }</a>
<a name="ln1605">      std::cout &lt;&lt; row.str();</a>
<a name="ln1606">    }</a>
<a name="ln1607">  }</a>
<a name="ln1608">}</a>
<a name="ln1609"> </a>
<a name="ln1610">}  // namespace</a>
<a name="ln1611"> </a>
<a name="ln1612">const string WALDumperCommand::ARG_WAL_FILE = &quot;walfile&quot;;</a>
<a name="ln1613">const string WALDumperCommand::ARG_PRINT_VALUE = &quot;print_value&quot;;</a>
<a name="ln1614">const string WALDumperCommand::ARG_PRINT_HEADER = &quot;header&quot;;</a>
<a name="ln1615"> </a>
<a name="ln1616">WALDumperCommand::WALDumperCommand(const vector&lt;string&gt;&amp; params,</a>
<a name="ln1617">      const map&lt;string, string&gt;&amp; options, const vector&lt;string&gt;&amp; flags) :</a>
<a name="ln1618">    LDBCommand(options, flags, true,</a>
<a name="ln1619">               BuildCmdLineOptions(</a>
<a name="ln1620">                {ARG_WAL_FILE, ARG_PRINT_HEADER, ARG_PRINT_VALUE})),</a>
<a name="ln1621">    print_header_(false), print_values_(false) {</a>
<a name="ln1622"> </a>
<a name="ln1623">  wal_file_.clear();</a>
<a name="ln1624"> </a>
<a name="ln1625">  map&lt;string, string&gt;::const_iterator itr = options.find(ARG_WAL_FILE);</a>
<a name="ln1626">  if (itr != options.end()) {</a>
<a name="ln1627">    wal_file_ = itr-&gt;second;</a>
<a name="ln1628">  }</a>
<a name="ln1629"> </a>
<a name="ln1630"> </a>
<a name="ln1631">  print_header_ = IsFlagPresent(flags, ARG_PRINT_HEADER);</a>
<a name="ln1632">  print_values_ = IsFlagPresent(flags, ARG_PRINT_VALUE);</a>
<a name="ln1633">  if (wal_file_.empty()) {</a>
<a name="ln1634">    exec_state_ = LDBCommandExecuteResult::Failed(&quot;Argument &quot; + ARG_WAL_FILE +</a>
<a name="ln1635">                                                  &quot; must be specified.&quot;);</a>
<a name="ln1636">  }</a>
<a name="ln1637">}</a>
<a name="ln1638"> </a>
<a name="ln1639">void WALDumperCommand::Help(string&amp; ret) {</a>
<a name="ln1640">  ret.append(&quot;  &quot;);</a>
<a name="ln1641">  ret.append(WALDumperCommand::Name());</a>
<a name="ln1642">  ret.append(&quot; --&quot; + ARG_WAL_FILE + &quot;=&lt;write_ahead_log_file_path&gt;&quot;);</a>
<a name="ln1643">  ret.append(&quot; [--&quot; + ARG_PRINT_HEADER + &quot;] &quot;);</a>
<a name="ln1644">  ret.append(&quot; [--&quot; + ARG_PRINT_VALUE + &quot;] &quot;);</a>
<a name="ln1645">  ret.append(&quot;\n&quot;);</a>
<a name="ln1646">}</a>
<a name="ln1647"> </a>
<a name="ln1648">void WALDumperCommand::DoCommand() {</a>
<a name="ln1649">  DumpWalFile(wal_file_, print_header_, print_values_, &amp;exec_state_);</a>
<a name="ln1650">}</a>
<a name="ln1651"> </a>
<a name="ln1652">// ----------------------------------------------------------------------------</a>
<a name="ln1653"> </a>
<a name="ln1654">GetCommand::GetCommand(const vector&lt;string&gt;&amp; params,</a>
<a name="ln1655">      const map&lt;string, string&gt;&amp; options, const vector&lt;string&gt;&amp; flags) :</a>
<a name="ln1656">  LDBCommand(options, flags, true, BuildCmdLineOptions({ARG_TTL, ARG_HEX,</a>
<a name="ln1657">                                                        ARG_KEY_HEX,</a>
<a name="ln1658">                                                        ARG_VALUE_HEX})) {</a>
<a name="ln1659"> </a>
<a name="ln1660">  if (params.size() != 1) {</a>
<a name="ln1661">    exec_state_ = LDBCommandExecuteResult::Failed(</a>
<a name="ln1662">        &quot;&lt;key&gt; must be specified for the get command&quot;);</a>
<a name="ln1663">  } else {</a>
<a name="ln1664">    key_ = params.at(0);</a>
<a name="ln1665">  }</a>
<a name="ln1666"> </a>
<a name="ln1667">  if (is_key_hex_) {</a>
<a name="ln1668">    key_ = HexToString(key_);</a>
<a name="ln1669">  }</a>
<a name="ln1670">}</a>
<a name="ln1671"> </a>
<a name="ln1672">void GetCommand::Help(string&amp; ret) {</a>
<a name="ln1673">  ret.append(&quot;  &quot;);</a>
<a name="ln1674">  ret.append(GetCommand::Name());</a>
<a name="ln1675">  ret.append(&quot; &lt;key&gt;&quot;);</a>
<a name="ln1676">  ret.append(&quot; [--&quot; + ARG_TTL + &quot;]&quot;);</a>
<a name="ln1677">  ret.append(&quot;\n&quot;);</a>
<a name="ln1678">}</a>
<a name="ln1679"> </a>
<a name="ln1680">void GetCommand::DoCommand() {</a>
<a name="ln1681">  if (!db_) {</a>
<a name="ln1682">    assert(GetExecuteState().IsFailed());</a>
<a name="ln1683">    return;</a>
<a name="ln1684">  }</a>
<a name="ln1685">  string value;</a>
<a name="ln1686">  Status st = db_-&gt;Get(ReadOptions(), GetCfHandle(), key_, &amp;value);</a>
<a name="ln1687">  if (st.ok()) {</a>
<a name="ln1688">    fprintf(stdout, &quot;%s\n&quot;,</a>
<a name="ln1689">              (is_value_hex_ ? StringToHex(value) : value).c_str());</a>
<a name="ln1690">  } else {</a>
<a name="ln1691">    exec_state_ = LDBCommandExecuteResult::Failed(st.ToString());</a>
<a name="ln1692">  }</a>
<a name="ln1693">}</a>
<a name="ln1694"> </a>
<a name="ln1695">// ----------------------------------------------------------------------------</a>
<a name="ln1696"> </a>
<a name="ln1697">ApproxSizeCommand::ApproxSizeCommand(const vector&lt;string&gt;&amp; params,</a>
<a name="ln1698">      const map&lt;string, string&gt;&amp; options, const vector&lt;string&gt;&amp; flags) :</a>
<a name="ln1699">  LDBCommand(options, flags, true,</a>
<a name="ln1700">             BuildCmdLineOptions({ARG_HEX, ARG_KEY_HEX, ARG_VALUE_HEX,</a>
<a name="ln1701">                                  ARG_FROM, ARG_TO})) {</a>
<a name="ln1702"> </a>
<a name="ln1703">  if (options.find(ARG_FROM) != options.end()) {</a>
<a name="ln1704">    start_key_ = options.find(ARG_FROM)-&gt;second;</a>
<a name="ln1705">  } else {</a>
<a name="ln1706">    exec_state_ = LDBCommandExecuteResult::Failed(</a>
<a name="ln1707">        ARG_FROM + &quot; must be specified for approxsize command&quot;);</a>
<a name="ln1708">    return;</a>
<a name="ln1709">  }</a>
<a name="ln1710"> </a>
<a name="ln1711">  if (options.find(ARG_TO) != options.end()) {</a>
<a name="ln1712">    end_key_ = options.find(ARG_TO)-&gt;second;</a>
<a name="ln1713">  } else {</a>
<a name="ln1714">    exec_state_ = LDBCommandExecuteResult::Failed(</a>
<a name="ln1715">        ARG_TO + &quot; must be specified for approxsize command&quot;);</a>
<a name="ln1716">    return;</a>
<a name="ln1717">  }</a>
<a name="ln1718"> </a>
<a name="ln1719">  if (is_key_hex_) {</a>
<a name="ln1720">    start_key_ = HexToString(start_key_);</a>
<a name="ln1721">    end_key_ = HexToString(end_key_);</a>
<a name="ln1722">  }</a>
<a name="ln1723">}</a>
<a name="ln1724"> </a>
<a name="ln1725">void ApproxSizeCommand::Help(string&amp; ret) {</a>
<a name="ln1726">  ret.append(&quot;  &quot;);</a>
<a name="ln1727">  ret.append(ApproxSizeCommand::Name());</a>
<a name="ln1728">  ret.append(HelpRangeCmdArgs());</a>
<a name="ln1729">  ret.append(&quot;\n&quot;);</a>
<a name="ln1730">}</a>
<a name="ln1731"> </a>
<a name="ln1732">void ApproxSizeCommand::DoCommand() {</a>
<a name="ln1733">  if (!db_) {</a>
<a name="ln1734">    assert(GetExecuteState().IsFailed());</a>
<a name="ln1735">    return;</a>
<a name="ln1736">  }</a>
<a name="ln1737">  Range ranges[1];</a>
<a name="ln1738">  ranges[0] = Range(start_key_, end_key_);</a>
<a name="ln1739">  uint64_t sizes[1];</a>
<a name="ln1740">  db_-&gt;GetApproximateSizes(GetCfHandle(), ranges, 1, sizes);</a>
<a name="ln1741">  fprintf(stdout, &quot;%&quot; PRIu64 &quot;\n&quot;, sizes[0]);</a>
<a name="ln1742">  /* Weird that GetApproximateSizes() returns void, although documentation</a>
<a name="ln1743">   * says that it returns a Status object.</a>
<a name="ln1744">  if (!st.ok()) {</a>
<a name="ln1745">    exec_state_ = LDBCommandExecuteResult::Failed(st.ToString());</a>
<a name="ln1746">  }</a>
<a name="ln1747">  */</a>
<a name="ln1748">}</a>
<a name="ln1749"> </a>
<a name="ln1750">// ----------------------------------------------------------------------------</a>
<a name="ln1751"> </a>
<a name="ln1752">BatchPutCommand::BatchPutCommand(const vector&lt;string&gt;&amp; params,</a>
<a name="ln1753">      const map&lt;string, string&gt;&amp; options, const vector&lt;string&gt;&amp; flags) :</a>
<a name="ln1754">  LDBCommand(options, flags, false,</a>
<a name="ln1755">             BuildCmdLineOptions({ARG_TTL, ARG_HEX, ARG_KEY_HEX, ARG_VALUE_HEX,</a>
<a name="ln1756">                                  ARG_CREATE_IF_MISSING})) {</a>
<a name="ln1757"> </a>
<a name="ln1758">  if (params.size() &lt; 2) {</a>
<a name="ln1759">    exec_state_ = LDBCommandExecuteResult::Failed(</a>
<a name="ln1760">        &quot;At least one &lt;key&gt; &lt;value&gt; pair must be specified batchput.&quot;);</a>
<a name="ln1761">  } else if (params.size() % 2 != 0) {</a>
<a name="ln1762">    exec_state_ = LDBCommandExecuteResult::Failed(</a>
<a name="ln1763">        &quot;Equal number of &lt;key&gt;s and &lt;value&gt;s must be specified for batchput.&quot;);</a>
<a name="ln1764">  } else {</a>
<a name="ln1765">    for (size_t i = 0; i &lt; params.size(); i += 2) {</a>
<a name="ln1766">      string key = params.at(i);</a>
<a name="ln1767">      string value = params.at(i+1);</a>
<a name="ln1768">      key_values_.emplace_back(is_key_hex_ ? HexToString(key) : key,</a>
<a name="ln1769">                               is_value_hex_ ? HexToString(value) : value);</a>
<a name="ln1770">    }</a>
<a name="ln1771">  }</a>
<a name="ln1772">}</a>
<a name="ln1773"> </a>
<a name="ln1774">void BatchPutCommand::Help(string&amp; ret) {</a>
<a name="ln1775">  ret.append(&quot;  &quot;);</a>
<a name="ln1776">  ret.append(BatchPutCommand::Name());</a>
<a name="ln1777">  ret.append(&quot; &lt;key&gt; &lt;value&gt; [&lt;key&gt; &lt;value&gt;] [..]&quot;);</a>
<a name="ln1778">  ret.append(&quot; [--&quot; + ARG_TTL + &quot;]&quot;);</a>
<a name="ln1779">  ret.append(&quot;\n&quot;);</a>
<a name="ln1780">}</a>
<a name="ln1781"> </a>
<a name="ln1782">void BatchPutCommand::DoCommand() {</a>
<a name="ln1783">  if (!db_) {</a>
<a name="ln1784">    assert(GetExecuteState().IsFailed());</a>
<a name="ln1785">    return;</a>
<a name="ln1786">  }</a>
<a name="ln1787">  WriteBatch batch;</a>
<a name="ln1788"> </a>
<a name="ln1789">  for (auto itr = key_values_.begin(); itr != key_values_.end(); ++itr) {</a>
<a name="ln1790">    batch.Put(GetCfHandle(), itr-&gt;first, itr-&gt;second);</a>
<a name="ln1791">  }</a>
<a name="ln1792">  Status st = db_-&gt;Write(WriteOptions(), &amp;batch);</a>
<a name="ln1793">  if (st.ok()) {</a>
<a name="ln1794">    fprintf(stdout, &quot;OK\n&quot;);</a>
<a name="ln1795">  } else {</a>
<a name="ln1796">    exec_state_ = LDBCommandExecuteResult::Failed(st.ToString());</a>
<a name="ln1797">  }</a>
<a name="ln1798">}</a>
<a name="ln1799"> </a>
<a name="ln1800">Options BatchPutCommand::PrepareOptionsForOpenDB() {</a>
<a name="ln1801">  Options opt = LDBCommand::PrepareOptionsForOpenDB();</a>
<a name="ln1802">  opt.create_if_missing = IsFlagPresent(flags_, ARG_CREATE_IF_MISSING);</a>
<a name="ln1803">  return opt;</a>
<a name="ln1804">}</a>
<a name="ln1805"> </a>
<a name="ln1806">// ----------------------------------------------------------------------------</a>
<a name="ln1807"> </a>
<a name="ln1808">ScanCommand::ScanCommand(const vector&lt;string&gt;&amp; params,</a>
<a name="ln1809">                         const map&lt;string, string&gt;&amp; options,</a>
<a name="ln1810">                         const vector&lt;string&gt;&amp; flags)</a>
<a name="ln1811">    : LDBCommand(options, flags, true,</a>
<a name="ln1812">                 BuildCmdLineOptions(</a>
<a name="ln1813">                     {ARG_TTL,      ARG_NO_VALUE,  ARG_HEX,    ARG_KEY_HEX,</a>
<a name="ln1814">                      ARG_TO,       ARG_VALUE_HEX, ARG_FROM,   ARG_TIMESTAMP,</a>
<a name="ln1815">                      ARG_MAX_KEYS, ARG_TTL_START, ARG_TTL_END, ARG_ONLY_VERIFY_CHECKSUMS})),</a>
<a name="ln1816">      start_key_specified_(false),</a>
<a name="ln1817">      end_key_specified_(false),</a>
<a name="ln1818">      max_keys_scanned_(-1),</a>
<a name="ln1819">      no_value_(false) {</a>
<a name="ln1820"> </a>
<a name="ln1821">  map&lt;string, string&gt;::const_iterator itr = options.find(ARG_FROM);</a>
<a name="ln1822">  if (itr != options.end()) {</a>
<a name="ln1823">    start_key_ = itr-&gt;second;</a>
<a name="ln1824">    if (is_key_hex_) {</a>
<a name="ln1825">      start_key_ = HexToString(start_key_);</a>
<a name="ln1826">    }</a>
<a name="ln1827">    start_key_specified_ = true;</a>
<a name="ln1828">  }</a>
<a name="ln1829">  itr = options.find(ARG_TO);</a>
<a name="ln1830">  if (itr != options.end()) {</a>
<a name="ln1831">    end_key_ = itr-&gt;second;</a>
<a name="ln1832">    if (is_key_hex_) {</a>
<a name="ln1833">      end_key_ = HexToString(end_key_);</a>
<a name="ln1834">    }</a>
<a name="ln1835">    end_key_specified_ = true;</a>
<a name="ln1836">  }</a>
<a name="ln1837"> </a>
<a name="ln1838">  vector&lt;string&gt;::const_iterator vitr =</a>
<a name="ln1839">      std::find(flags.begin(), flags.end(), ARG_NO_VALUE);</a>
<a name="ln1840">  if (vitr != flags.end()) {</a>
<a name="ln1841">    no_value_ = true;</a>
<a name="ln1842">  }</a>
<a name="ln1843"> </a>
<a name="ln1844">  vitr =  std::find(flags.begin(), flags.end(), ARG_ONLY_VERIFY_CHECKSUMS);</a>
<a name="ln1845">  if (vitr != flags.end()) {</a>
<a name="ln1846">    LOG(INFO) &lt;&lt; &quot;Only verify checksums, don't print entries.&quot;;</a>
<a name="ln1847">    only_verify_checksums_ = true;</a>
<a name="ln1848">  }</a>
<a name="ln1849"> </a>
<a name="ln1850">  itr = options.find(ARG_MAX_KEYS);</a>
<a name="ln1851">  if (itr != options.end()) {</a>
<a name="ln1852">    try {</a>
<a name="ln1853">#if defined(CYGWIN)</a>
<a name="ln1854">      max_keys_scanned_ = strtol(itr-&gt;second.c_str(), 0, 10);</a>
<a name="ln1855">#else</a>
<a name="ln1856">      max_keys_scanned_ = stoi(itr-&gt;second);</a>
<a name="ln1857">#endif</a>
<a name="ln1858">    } catch(const std::invalid_argument&amp;) {</a>
<a name="ln1859">      exec_state_ = LDBCommandExecuteResult::Failed(ARG_MAX_KEYS +</a>
<a name="ln1860">                                                    &quot; has an invalid value&quot;);</a>
<a name="ln1861">    } catch(const std::out_of_range&amp;) {</a>
<a name="ln1862">      exec_state_ = LDBCommandExecuteResult::Failed(</a>
<a name="ln1863">          ARG_MAX_KEYS + &quot; has a value out-of-range&quot;);</a>
<a name="ln1864">    }</a>
<a name="ln1865">  }</a>
<a name="ln1866">}</a>
<a name="ln1867"> </a>
<a name="ln1868">void ScanCommand::Help(string&amp; ret) {</a>
<a name="ln1869">  ret.append(&quot;  &quot;);</a>
<a name="ln1870">  ret.append(ScanCommand::Name());</a>
<a name="ln1871">  ret.append(HelpRangeCmdArgs());</a>
<a name="ln1872">  ret.append(&quot; [--&quot; + ARG_TTL + &quot;]&quot;);</a>
<a name="ln1873">  ret.append(&quot; [--&quot; + ARG_TIMESTAMP + &quot;]&quot;);</a>
<a name="ln1874">  ret.append(&quot; [--&quot; + ARG_MAX_KEYS + &quot;=&lt;N&gt;q] &quot;);</a>
<a name="ln1875">  ret.append(&quot; [--&quot; + ARG_TTL_START + &quot;=&lt;N&gt;:- is inclusive]&quot;);</a>
<a name="ln1876">  ret.append(&quot; [--&quot; + ARG_TTL_END + &quot;=&lt;N&gt;:- is exclusive]&quot;);</a>
<a name="ln1877">  ret.append(&quot; [--&quot; + ARG_NO_VALUE + &quot;]&quot;);</a>
<a name="ln1878">  ret.append(&quot; [--&quot; + ARG_ONLY_VERIFY_CHECKSUMS + &quot;]&quot;);</a>
<a name="ln1879">  ret.append(&quot;\n&quot;);</a>
<a name="ln1880">}</a>
<a name="ln1881"> </a>
<a name="ln1882">void ScanCommand::DoCommand() {</a>
<a name="ln1883">  if (!db_) {</a>
<a name="ln1884">    assert(GetExecuteState().IsFailed());</a>
<a name="ln1885">    return;</a>
<a name="ln1886">  }</a>
<a name="ln1887"> </a>
<a name="ln1888">  int num_keys_scanned = 0;</a>
<a name="ln1889">  Iterator* it = db_-&gt;NewIterator(ReadOptions(), GetCfHandle());</a>
<a name="ln1890">  if (start_key_specified_) {</a>
<a name="ln1891">    it-&gt;Seek(start_key_);</a>
<a name="ln1892">  } else {</a>
<a name="ln1893">    it-&gt;SeekToFirst();</a>
<a name="ln1894">  }</a>
<a name="ln1895">  int ttl_start;</a>
<a name="ln1896">  if (!ParseIntOption(option_map_, ARG_TTL_START, ttl_start, exec_state_)) {</a>
<a name="ln1897">    ttl_start = DBWithTTLImpl::kMinTimestamp;  // TTL introduction time</a>
<a name="ln1898">  }</a>
<a name="ln1899">  int ttl_end;</a>
<a name="ln1900">  if (!ParseIntOption(option_map_, ARG_TTL_END, ttl_end, exec_state_)) {</a>
<a name="ln1901">    ttl_end = DBWithTTLImpl::kMaxTimestamp;  // Max time allowed by TTL feature</a>
<a name="ln1902">  }</a>
<a name="ln1903">  if (ttl_end &lt; ttl_start) {</a>
<a name="ln1904">    fprintf(stderr, &quot;Error: End time can't be less than start time\n&quot;);</a>
<a name="ln1905">    delete it;</a>
<a name="ln1906">    return;</a>
<a name="ln1907">  }</a>
<a name="ln1908">  if (is_db_ttl_ &amp;&amp; timestamp_) {</a>
<a name="ln1909">    fprintf(stdout, &quot;Scanning key-values from %s to %s\n&quot;,</a>
<a name="ln1910">            ReadableTime(ttl_start).c_str(), ReadableTime(ttl_end).c_str());</a>
<a name="ln1911">  }</a>
<a name="ln1912">  for ( ;</a>
<a name="ln1913">        it-&gt;Valid() &amp;&amp; (!end_key_specified_ || it-&gt;key().ToString() &lt; end_key_);</a>
<a name="ln1914">        it-&gt;Next()) {</a>
<a name="ln1915">    if (is_db_ttl_) {</a>
<a name="ln1916">      TtlIterator* it_ttl = dynamic_cast&lt;TtlIterator*&gt;(it);</a>
<a name="ln1917">      assert(it_ttl);</a>
<a name="ln1918">      int rawtime = it_ttl-&gt;timestamp();</a>
<a name="ln1919">      if (rawtime &lt; ttl_start || rawtime &gt;= ttl_end) {</a>
<a name="ln1920">        continue;</a>
<a name="ln1921">      }</a>
<a name="ln1922">      if (timestamp_ &amp;&amp; !only_verify_checksums_) {</a>
<a name="ln1923">        fprintf(stdout, &quot;%s &quot;, ReadableTime(rawtime).c_str());</a>
<a name="ln1924">      }</a>
<a name="ln1925">    }</a>
<a name="ln1926"> </a>
<a name="ln1927">    Slice key_slice = it-&gt;key();</a>
<a name="ln1928"> </a>
<a name="ln1929">    std::string formatted_key;</a>
<a name="ln1930">    if (is_key_hex_) {</a>
<a name="ln1931">      formatted_key = &quot;0x&quot; + key_slice.ToString(true /* hex */);</a>
<a name="ln1932">      key_slice = formatted_key;</a>
<a name="ln1933">    } else if (ldb_options_.key_formatter) {</a>
<a name="ln1934">      formatted_key = ldb_options_.key_formatter-&gt;Format(key_slice);</a>
<a name="ln1935">      key_slice = formatted_key;</a>
<a name="ln1936">    }</a>
<a name="ln1937"> </a>
<a name="ln1938">    if (no_value_ &amp;&amp; !only_verify_checksums_) {</a>
<a name="ln1939">      fprintf(stdout, &quot;%.*s\n&quot;, static_cast&lt;int&gt;(key_slice.size()),</a>
<a name="ln1940">              key_slice.data());</a>
<a name="ln1941">    } else {</a>
<a name="ln1942">      Slice val_slice = it-&gt;value();</a>
<a name="ln1943">      std::string formatted_value;</a>
<a name="ln1944">      if (is_value_hex_) {</a>
<a name="ln1945">        formatted_value = &quot;0x&quot; + val_slice.ToString(true /* hex */);</a>
<a name="ln1946">        val_slice = formatted_value;</a>
<a name="ln1947">      }</a>
<a name="ln1948">      if (!only_verify_checksums_) {</a>
<a name="ln1949">        fprintf(stdout, &quot;%.*s : %.*s\n&quot;, static_cast&lt;int&gt;(key_slice.size()),</a>
<a name="ln1950">                key_slice.data(), static_cast&lt;int&gt;(val_slice.size()),</a>
<a name="ln1951">                val_slice.data());</a>
<a name="ln1952">      }</a>
<a name="ln1953">    }</a>
<a name="ln1954"> </a>
<a name="ln1955">    num_keys_scanned++;</a>
<a name="ln1956">    if (max_keys_scanned_ &gt;= 0 &amp;&amp; num_keys_scanned &gt;= max_keys_scanned_) {</a>
<a name="ln1957">      break;</a>
<a name="ln1958">    }</a>
<a name="ln1959">  }</a>
<a name="ln1960">  if (!it-&gt;status().ok()) {  // Check for any errors found during the scan</a>
<a name="ln1961">    exec_state_ = LDBCommandExecuteResult::Failed(it-&gt;status().ToString());</a>
<a name="ln1962">  }</a>
<a name="ln1963">  delete it;</a>
<a name="ln1964">}</a>
<a name="ln1965"> </a>
<a name="ln1966">// ----------------------------------------------------------------------------</a>
<a name="ln1967"> </a>
<a name="ln1968">DeleteCommand::DeleteCommand(const vector&lt;string&gt;&amp; params,</a>
<a name="ln1969">      const map&lt;string, string&gt;&amp; options, const vector&lt;string&gt;&amp; flags) :</a>
<a name="ln1970">  LDBCommand(options, flags, false,</a>
<a name="ln1971">             BuildCmdLineOptions({ARG_HEX, ARG_KEY_HEX, ARG_VALUE_HEX})) {</a>
<a name="ln1972"> </a>
<a name="ln1973">  if (params.size() != 1) {</a>
<a name="ln1974">    exec_state_ = LDBCommandExecuteResult::Failed(</a>
<a name="ln1975">        &quot;KEY must be specified for the delete command&quot;);</a>
<a name="ln1976">  } else {</a>
<a name="ln1977">    key_ = params.at(0);</a>
<a name="ln1978">    if (is_key_hex_) {</a>
<a name="ln1979">      key_ = HexToString(key_);</a>
<a name="ln1980">    }</a>
<a name="ln1981">  }</a>
<a name="ln1982">}</a>
<a name="ln1983"> </a>
<a name="ln1984">void DeleteCommand::Help(string&amp; ret) {</a>
<a name="ln1985">  ret.append(&quot;  &quot;);</a>
<a name="ln1986">  ret.append(DeleteCommand::Name() + &quot; &lt;key&gt;&quot;);</a>
<a name="ln1987">  ret.append(&quot;\n&quot;);</a>
<a name="ln1988">}</a>
<a name="ln1989"> </a>
<a name="ln1990">void DeleteCommand::DoCommand() {</a>
<a name="ln1991">  if (!db_) {</a>
<a name="ln1992">    assert(GetExecuteState().IsFailed());</a>
<a name="ln1993">    return;</a>
<a name="ln1994">  }</a>
<a name="ln1995">  Status st = db_-&gt;Delete(WriteOptions(), GetCfHandle(), key_);</a>
<a name="ln1996">  if (st.ok()) {</a>
<a name="ln1997">    fprintf(stdout, &quot;OK\n&quot;);</a>
<a name="ln1998">  } else {</a>
<a name="ln1999">    exec_state_ = LDBCommandExecuteResult::Failed(st.ToString());</a>
<a name="ln2000">  }</a>
<a name="ln2001">}</a>
<a name="ln2002"> </a>
<a name="ln2003"> </a>
<a name="ln2004">PutCommand::PutCommand(const vector&lt;string&gt;&amp; params,</a>
<a name="ln2005">      const map&lt;string, string&gt;&amp; options, const vector&lt;string&gt;&amp; flags) :</a>
<a name="ln2006">  LDBCommand(options, flags, false,</a>
<a name="ln2007">             BuildCmdLineOptions({ARG_TTL, ARG_HEX, ARG_KEY_HEX, ARG_VALUE_HEX,</a>
<a name="ln2008">                                  ARG_CREATE_IF_MISSING})) {</a>
<a name="ln2009"> </a>
<a name="ln2010">  if (params.size() != 2) {</a>
<a name="ln2011">    exec_state_ = LDBCommandExecuteResult::Failed(</a>
<a name="ln2012">        &quot;&lt;key&gt; and &lt;value&gt; must be specified for the put command&quot;);</a>
<a name="ln2013">  } else {</a>
<a name="ln2014">    key_ = params.at(0);</a>
<a name="ln2015">    value_ = params.at(1);</a>
<a name="ln2016">  }</a>
<a name="ln2017"> </a>
<a name="ln2018">  if (is_key_hex_) {</a>
<a name="ln2019">    key_ = HexToString(key_);</a>
<a name="ln2020">  }</a>
<a name="ln2021"> </a>
<a name="ln2022">  if (is_value_hex_) {</a>
<a name="ln2023">    value_ = HexToString(value_);</a>
<a name="ln2024">  }</a>
<a name="ln2025">}</a>
<a name="ln2026"> </a>
<a name="ln2027">void PutCommand::Help(string&amp; ret) {</a>
<a name="ln2028">  ret.append(&quot;  &quot;);</a>
<a name="ln2029">  ret.append(PutCommand::Name());</a>
<a name="ln2030">  ret.append(&quot; &lt;key&gt; &lt;value&gt; &quot;);</a>
<a name="ln2031">  ret.append(&quot; [--&quot; + ARG_TTL + &quot;]&quot;);</a>
<a name="ln2032">  ret.append(&quot;\n&quot;);</a>
<a name="ln2033">}</a>
<a name="ln2034"> </a>
<a name="ln2035">void PutCommand::DoCommand() {</a>
<a name="ln2036">  if (!db_) {</a>
<a name="ln2037">    assert(GetExecuteState().IsFailed());</a>
<a name="ln2038">    return;</a>
<a name="ln2039">  }</a>
<a name="ln2040">  Status st = db_-&gt;Put(WriteOptions(), GetCfHandle(), key_, value_);</a>
<a name="ln2041">  if (st.ok()) {</a>
<a name="ln2042">    fprintf(stdout, &quot;OK\n&quot;);</a>
<a name="ln2043">  } else {</a>
<a name="ln2044">    exec_state_ = LDBCommandExecuteResult::Failed(st.ToString());</a>
<a name="ln2045">  }</a>
<a name="ln2046">}</a>
<a name="ln2047"> </a>
<a name="ln2048">Options PutCommand::PrepareOptionsForOpenDB() {</a>
<a name="ln2049">  Options opt = LDBCommand::PrepareOptionsForOpenDB();</a>
<a name="ln2050">  opt.create_if_missing = IsFlagPresent(flags_, ARG_CREATE_IF_MISSING);</a>
<a name="ln2051">  return opt;</a>
<a name="ln2052">}</a>
<a name="ln2053"> </a>
<a name="ln2054">// ----------------------------------------------------------------------------</a>
<a name="ln2055"> </a>
<a name="ln2056">const char* DBQuerierCommand::HELP_CMD = &quot;help&quot;;</a>
<a name="ln2057">const char* DBQuerierCommand::GET_CMD = &quot;get&quot;;</a>
<a name="ln2058">const char* DBQuerierCommand::PUT_CMD = &quot;put&quot;;</a>
<a name="ln2059">const char* DBQuerierCommand::DELETE_CMD = &quot;delete&quot;;</a>
<a name="ln2060"> </a>
<a name="ln2061">DBQuerierCommand::DBQuerierCommand(const vector&lt;string&gt;&amp; params,</a>
<a name="ln2062">    const map&lt;string, string&gt;&amp; options, const vector&lt;string&gt;&amp; flags) :</a>
<a name="ln2063">  LDBCommand(options, flags, false,</a>
<a name="ln2064">             BuildCmdLineOptions({ARG_TTL, ARG_HEX, ARG_KEY_HEX,</a>
<a name="ln2065">                                  ARG_VALUE_HEX})) {</a>
<a name="ln2066"> </a>
<a name="ln2067">}</a>
<a name="ln2068"> </a>
<a name="ln2069">void DBQuerierCommand::Help(string&amp; ret) {</a>
<a name="ln2070">  ret.append(&quot;  &quot;);</a>
<a name="ln2071">  ret.append(DBQuerierCommand::Name());</a>
<a name="ln2072">  ret.append(&quot; [--&quot; + ARG_TTL + &quot;]&quot;);</a>
<a name="ln2073">  ret.append(&quot;\n&quot;);</a>
<a name="ln2074">  ret.append(&quot;    Starts a REPL shell.  Type help for list of available &quot;</a>
<a name="ln2075">             &quot;commands.&quot;);</a>
<a name="ln2076">  ret.append(&quot;\n&quot;);</a>
<a name="ln2077">}</a>
<a name="ln2078"> </a>
<a name="ln2079">void DBQuerierCommand::DoCommand() {</a>
<a name="ln2080">  if (!db_) {</a>
<a name="ln2081">    assert(GetExecuteState().IsFailed());</a>
<a name="ln2082">    return;</a>
<a name="ln2083">  }</a>
<a name="ln2084"> </a>
<a name="ln2085">  ReadOptions read_options;</a>
<a name="ln2086">  WriteOptions write_options;</a>
<a name="ln2087"> </a>
<a name="ln2088">  string line;</a>
<a name="ln2089">  string key;</a>
<a name="ln2090">  string value;</a>
<a name="ln2091">  while (getline(std::cin, line, '\n')) {</a>
<a name="ln2092"> </a>
<a name="ln2093">    // Parse line into vector&lt;string&gt;</a>
<a name="ln2094">    vector&lt;string&gt; tokens;</a>
<a name="ln2095">    size_t pos = 0;</a>
<a name="ln2096">    while (true) {</a>
<a name="ln2097">      size_t pos2 = line.find(' ', pos);</a>
<a name="ln2098">      if (pos2 == string::npos) {</a>
<a name="ln2099">        break;</a>
<a name="ln2100">      }</a>
<a name="ln2101">      tokens.push_back(line.substr(pos, pos2-pos));</a>
<a name="ln2102">      pos = pos2 + 1;</a>
<a name="ln2103">    }</a>
<a name="ln2104">    tokens.push_back(line.substr(pos));</a>
<a name="ln2105"> </a>
<a name="ln2106">    const string&amp; cmd = tokens[0];</a>
<a name="ln2107"> </a>
<a name="ln2108">    if (cmd == HELP_CMD) {</a>
<a name="ln2109">      fprintf(stdout,</a>
<a name="ln2110">              &quot;get &lt;key&gt;\n&quot;</a>
<a name="ln2111">              &quot;put &lt;key&gt; &lt;value&gt;\n&quot;</a>
<a name="ln2112">              &quot;delete &lt;key&gt;\n&quot;);</a>
<a name="ln2113">    } else if (cmd == DELETE_CMD &amp;&amp; tokens.size() == 2) {</a>
<a name="ln2114">      key = (is_key_hex_ ? HexToString(tokens[1]) : tokens[1]);</a>
<a name="ln2115">      CHECK_OK(db_-&gt;Delete(write_options, GetCfHandle(), Slice(key)));</a>
<a name="ln2116">      fprintf(stdout, &quot;Successfully deleted %s\n&quot;, tokens[1].c_str());</a>
<a name="ln2117">    } else if (cmd == PUT_CMD &amp;&amp; tokens.size() == 3) {</a>
<a name="ln2118">      key = (is_key_hex_ ? HexToString(tokens[1]) : tokens[1]);</a>
<a name="ln2119">      value = (is_value_hex_ ? HexToString(tokens[2]) : tokens[2]);</a>
<a name="ln2120">      CHECK_OK(db_-&gt;Put(write_options, GetCfHandle(), Slice(key), Slice(value)));</a>
<a name="ln2121">      fprintf(stdout, &quot;Successfully put %s %s\n&quot;,</a>
<a name="ln2122">              tokens[1].c_str(), tokens[2].c_str());</a>
<a name="ln2123">    } else if (cmd == GET_CMD &amp;&amp; tokens.size() == 2) {</a>
<a name="ln2124">      key = (is_key_hex_ ? HexToString(tokens[1]) : tokens[1]);</a>
<a name="ln2125">      if (db_-&gt;Get(read_options, GetCfHandle(), Slice(key), &amp;value).ok()) {</a>
<a name="ln2126">        fprintf(stdout, &quot;%s\n&quot;, PrintKeyValue(key, value,</a>
<a name="ln2127">              is_key_hex_, is_value_hex_).c_str());</a>
<a name="ln2128">      } else {</a>
<a name="ln2129">        fprintf(stdout, &quot;Not found %s\n&quot;, tokens[1].c_str());</a>
<a name="ln2130">      }</a>
<a name="ln2131">    } else {</a>
<a name="ln2132">      fprintf(stdout, &quot;Unknown command %s\n&quot;, line.c_str());</a>
<a name="ln2133">    }</a>
<a name="ln2134">  }</a>
<a name="ln2135">}</a>
<a name="ln2136"> </a>
<a name="ln2137">// ----------------------------------------------------------------------------</a>
<a name="ln2138"> </a>
<a name="ln2139">CheckConsistencyCommand::CheckConsistencyCommand(const vector&lt;string&gt;&amp; params,</a>
<a name="ln2140">    const map&lt;string, string&gt;&amp; options, const vector&lt;string&gt;&amp; flags) :</a>
<a name="ln2141">  LDBCommand(options, flags, false,</a>
<a name="ln2142">             BuildCmdLineOptions({})) {</a>
<a name="ln2143">}</a>
<a name="ln2144"> </a>
<a name="ln2145">void CheckConsistencyCommand::Help(string&amp; ret) {</a>
<a name="ln2146">  ret.append(&quot;  &quot;);</a>
<a name="ln2147">  ret.append(CheckConsistencyCommand::Name());</a>
<a name="ln2148">  ret.append(&quot;\n&quot;);</a>
<a name="ln2149">}</a>
<a name="ln2150"> </a>
<a name="ln2151">void CheckConsistencyCommand::DoCommand() {</a>
<a name="ln2152">  Options opt = PrepareOptionsForOpenDB();</a>
<a name="ln2153">  opt.paranoid_checks = true;</a>
<a name="ln2154">  if (!exec_state_.IsNotStarted()) {</a>
<a name="ln2155">    return;</a>
<a name="ln2156">  }</a>
<a name="ln2157">  DB* db;</a>
<a name="ln2158">  Status st = DB::OpenForReadOnly(opt, db_path_, &amp;db, false);</a>
<a name="ln2159">  delete db;</a>
<a name="ln2160">  if (st.ok()) {</a>
<a name="ln2161">    fprintf(stdout, &quot;OK\n&quot;);</a>
<a name="ln2162">  } else {</a>
<a name="ln2163">    exec_state_ = LDBCommandExecuteResult::Failed(st.ToString());</a>
<a name="ln2164">  }</a>
<a name="ln2165">}</a>
<a name="ln2166"> </a>
<a name="ln2167">// ----------------------------------------------------------------------------</a>
<a name="ln2168"> </a>
<a name="ln2169">namespace {</a>
<a name="ln2170"> </a>
<a name="ln2171">void DumpSstFile(std::string filename, bool output_hex, bool show_properties) {</a>
<a name="ln2172">  std::string from_key;</a>
<a name="ln2173">  std::string to_key;</a>
<a name="ln2174">  if (filename.length() &lt;= 4 ||</a>
<a name="ln2175">      filename.rfind(&quot;.sst&quot;) != filename.length() - 4) {</a>
<a name="ln2176">    std::cout &lt;&lt; &quot;Invalid sst file name.&quot; &lt;&lt; std::endl;</a>
<a name="ln2177">    return;</a>
<a name="ln2178">  }</a>
<a name="ln2179">  // no verification</a>
<a name="ln2180">  rocksdb::SstFileReader reader(filename, false, output_hex);</a>
<a name="ln2181">  Status st = reader.ReadSequential(true, -1, false,  // has_from</a>
<a name="ln2182">                                    from_key, false,  // has_to</a>
<a name="ln2183">                                    to_key);</a>
<a name="ln2184">  if (!st.ok()) {</a>
<a name="ln2185">    std::cerr &lt;&lt; &quot;Error in reading SST file &quot; &lt;&lt; filename &lt;&lt; st.ToString()</a>
<a name="ln2186">              &lt;&lt; std::endl;</a>
<a name="ln2187">    return;</a>
<a name="ln2188">  }</a>
<a name="ln2189"> </a>
<a name="ln2190">  if (show_properties) {</a>
<a name="ln2191">    const rocksdb::TableProperties* table_properties;</a>
<a name="ln2192"> </a>
<a name="ln2193">    std::shared_ptr&lt;const rocksdb::TableProperties&gt;</a>
<a name="ln2194">        table_properties_from_reader;</a>
<a name="ln2195">    st = reader.ReadTableProperties(&amp;table_properties_from_reader);</a>
<a name="ln2196">    if (!st.ok()) {</a>
<a name="ln2197">      std::cerr &lt;&lt; filename &lt;&lt; &quot;: &quot; &lt;&lt; st.ToString()</a>
<a name="ln2198">                &lt;&lt; &quot;. Try to use initial table properties&quot; &lt;&lt; std::endl;</a>
<a name="ln2199">      table_properties = reader.GetInitTableProperties();</a>
<a name="ln2200">    } else {</a>
<a name="ln2201">      table_properties = table_properties_from_reader.get();</a>
<a name="ln2202">    }</a>
<a name="ln2203">    if (table_properties != nullptr) {</a>
<a name="ln2204">      std::cout &lt;&lt; std::endl &lt;&lt; &quot;Table Properties:&quot; &lt;&lt; std::endl;</a>
<a name="ln2205">      std::cout &lt;&lt; table_properties-&gt;ToString(&quot;\n&quot;) &lt;&lt; std::endl;</a>
<a name="ln2206">      std::cout &lt;&lt; &quot;# deleted keys: &quot;</a>
<a name="ln2207">                &lt;&lt; rocksdb::GetDeletedKeys(</a>
<a name="ln2208">                       table_properties-&gt;user_collected_properties)</a>
<a name="ln2209">                &lt;&lt; std::endl;</a>
<a name="ln2210">    }</a>
<a name="ln2211">  }</a>
<a name="ln2212">}</a>
<a name="ln2213"> </a>
<a name="ln2214">}  // namespace</a>
<a name="ln2215"> </a>
<a name="ln2216">DBFileDumperCommand::DBFileDumperCommand(const vector&lt;string&gt;&amp; params,</a>
<a name="ln2217">                                         const map&lt;string, string&gt;&amp; options,</a>
<a name="ln2218">                                         const vector&lt;string&gt;&amp; flags)</a>
<a name="ln2219">    : LDBCommand(options, flags, true, BuildCmdLineOptions({})) {}</a>
<a name="ln2220"> </a>
<a name="ln2221">void DBFileDumperCommand::Help(string&amp; ret) {</a>
<a name="ln2222">  ret.append(&quot;  &quot;);</a>
<a name="ln2223">  ret.append(DBFileDumperCommand::Name());</a>
<a name="ln2224">  ret.append(&quot;\n&quot;);</a>
<a name="ln2225">}</a>
<a name="ln2226"> </a>
<a name="ln2227">void DBFileDumperCommand::DoCommand() {</a>
<a name="ln2228">  if (!db_) {</a>
<a name="ln2229">    assert(GetExecuteState().IsFailed());</a>
<a name="ln2230">    return;</a>
<a name="ln2231">  }</a>
<a name="ln2232">  Status s;</a>
<a name="ln2233"> </a>
<a name="ln2234">  std::cout &lt;&lt; &quot;Manifest File&quot; &lt;&lt; std::endl;</a>
<a name="ln2235">  std::cout &lt;&lt; &quot;==============================&quot; &lt;&lt; std::endl;</a>
<a name="ln2236">  std::string manifest_filename;</a>
<a name="ln2237">  s = ReadFileToString(db_-&gt;GetEnv(), CurrentFileName(db_-&gt;GetName()),</a>
<a name="ln2238">                       &amp;manifest_filename);</a>
<a name="ln2239">  if (!s.ok() || manifest_filename.empty() ||</a>
<a name="ln2240">      manifest_filename.back() != '\n') {</a>
<a name="ln2241">    std::cerr &lt;&lt; &quot;Error when reading CURRENT file &quot;</a>
<a name="ln2242">              &lt;&lt; CurrentFileName(db_-&gt;GetName()) &lt;&lt; std::endl;</a>
<a name="ln2243">  }</a>
<a name="ln2244">  // remove the trailing '\n'</a>
<a name="ln2245">  manifest_filename.resize(manifest_filename.size() - 1);</a>
<a name="ln2246">  string manifest_filepath = db_-&gt;GetName() + &quot;/&quot; + manifest_filename;</a>
<a name="ln2247">  std::cout &lt;&lt; manifest_filepath &lt;&lt; std::endl;</a>
<a name="ln2248">  DumpManifestFile(manifest_filepath, false, false);</a>
<a name="ln2249">  std::cout &lt;&lt; std::endl;</a>
<a name="ln2250"> </a>
<a name="ln2251">  std::cout &lt;&lt; &quot;SST Files&quot; &lt;&lt; std::endl;</a>
<a name="ln2252">  std::cout &lt;&lt; &quot;==============================&quot; &lt;&lt; std::endl;</a>
<a name="ln2253">  std::vector&lt;LiveFileMetaData&gt; metadata;</a>
<a name="ln2254">  db_-&gt;GetLiveFilesMetaData(&amp;metadata);</a>
<a name="ln2255">  for (auto&amp; fileMetadata : metadata) {</a>
<a name="ln2256">    std::string filename = fileMetadata.db_path + fileMetadata.name;</a>
<a name="ln2257">    std::cout &lt;&lt; filename &lt;&lt; &quot; level:&quot; &lt;&lt; fileMetadata.level &lt;&lt; std::endl;</a>
<a name="ln2258">    std::cout &lt;&lt; &quot;------------------------------&quot; &lt;&lt; std::endl;</a>
<a name="ln2259">    DumpSstFile(filename, false, true);</a>
<a name="ln2260">    std::cout &lt;&lt; std::endl;</a>
<a name="ln2261">  }</a>
<a name="ln2262">  std::cout &lt;&lt; std::endl;</a>
<a name="ln2263"> </a>
<a name="ln2264">  std::cout &lt;&lt; &quot;Write Ahead Log Files&quot; &lt;&lt; std::endl;</a>
<a name="ln2265">  std::cout &lt;&lt; &quot;==============================&quot; &lt;&lt; std::endl;</a>
<a name="ln2266">  rocksdb::VectorLogPtr wal_files;</a>
<a name="ln2267">  s = db_-&gt;GetSortedWalFiles(&amp;wal_files);</a>
<a name="ln2268">  if (!s.ok()) {</a>
<a name="ln2269">    std::cerr &lt;&lt; &quot;Error when getting WAL files&quot; &lt;&lt; std::endl;</a>
<a name="ln2270">  } else {</a>
<a name="ln2271">    for (auto&amp; wal : wal_files) {</a>
<a name="ln2272">      // TODO(qyang): option.wal_dir should be passed into ldb command</a>
<a name="ln2273">      std::string filename = db_-&gt;GetOptions().wal_dir + wal-&gt;PathName();</a>
<a name="ln2274">      std::cout &lt;&lt; filename &lt;&lt; std::endl;</a>
<a name="ln2275">      DumpWalFile(filename, true, true, &amp;exec_state_);</a>
<a name="ln2276">    }</a>
<a name="ln2277">  }</a>
<a name="ln2278">}</a>
<a name="ln2279"> </a>
<a name="ln2280">}   // namespace rocksdb</a>
<a name="ln2281">#endif  // ROCKSDB_LITE</a>

</code></pre>
<div class="balloon" rel="489"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="554"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="568"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1164"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'it_ttl'.</p></div>
<div class="balloon" rel="1237"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'print_old_levels_' should be checked here.</p></div>
<div class="balloon" rel="1337"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1333"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1020/" target="_blank">V1020</a> The function exited without calling the 'CloseDB' function. Check lines: 1333, 1331.</p></div>
<div class="balloon" rel="1446"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1602"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1918"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'it_ttl'.</p></div>
<div class="balloon" rel="2115"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="2120"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
