
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>util.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//</a>
<a name="ln2">// Copyright (C) 1999-2005 Google, Inc.</a>
<a name="ln3">//</a>
<a name="ln4">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln5">//</a>
<a name="ln6">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln7">//</a>
<a name="ln8">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln9">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln10">//</a>
<a name="ln11">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln12">//</a>
<a name="ln13">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln14">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln15">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln16">// under the License.</a>
<a name="ln17">//</a>
<a name="ln18"> </a>
<a name="ln19">// TODO(user): visit each const_cast.  Some of them are no longer necessary</a>
<a name="ln20">// because last Single Unix Spec and grte v2 are more const-y.</a>
<a name="ln21"> </a>
<a name="ln22">#include &quot;yb/gutil/strings/util.h&quot;</a>
<a name="ln23"> </a>
<a name="ln24">#include &lt;assert.h&gt;</a>
<a name="ln25">#include &lt;stdarg.h&gt;</a>
<a name="ln26">#include &lt;stdio.h&gt;</a>
<a name="ln27">#include &lt;string.h&gt;</a>
<a name="ln28">#include &lt;time.h&gt;           // for FastTimeToBuffer()</a>
<a name="ln29">#include &lt;algorithm&gt;</a>
<a name="ln30">using std::copy;</a>
<a name="ln31">using std::max;</a>
<a name="ln32">using std::min;</a>
<a name="ln33">using std::reverse;</a>
<a name="ln34">using std::sort;</a>
<a name="ln35">using std::swap;</a>
<a name="ln36">#include &lt;string&gt;</a>
<a name="ln37">using std::string;</a>
<a name="ln38">#include &lt;vector&gt;</a>
<a name="ln39">using std::vector;</a>
<a name="ln40"> </a>
<a name="ln41">#include &lt;glog/logging.h&gt;</a>
<a name="ln42">#include &quot;yb/gutil/logging-inl.h&quot;</a>
<a name="ln43">#include &quot;yb/gutil/strings/ascii_ctype.h&quot;</a>
<a name="ln44">#include &quot;yb/gutil/strings/numbers.h&quot;</a>
<a name="ln45">#include &quot;yb/gutil/strings/stringpiece.h&quot;</a>
<a name="ln46">#include &quot;yb/gutil/stl_util.h&quot;  // for string_as_array, STLAppendToString</a>
<a name="ln47">#include &quot;yb/gutil/utf/utf.h&quot;</a>
<a name="ln48"> </a>
<a name="ln49">#ifdef OS_WINDOWS</a>
<a name="ln50">#ifdef min  // windows.h defines this to something silly</a>
<a name="ln51">#undef min</a>
<a name="ln52">#endif</a>
<a name="ln53">#endif</a>
<a name="ln54"> </a>
<a name="ln55">// Use this instead of gmtime_r if you want to build for Windows.</a>
<a name="ln56">// Windows doesn't have a 'gmtime_r', but it has the similar 'gmtime_s'.</a>
<a name="ln57">// TODO(user): Probably belongs in //base:time_support.{cc|h}.</a>
<a name="ln58">static struct tm* PortableSafeGmtime(const time_t* timep, struct tm* result) {</a>
<a name="ln59">#ifdef OS_WINDOWS</a>
<a name="ln60">  return gmtime_s(result, timep) == 0 ? result : NULL;</a>
<a name="ln61">#else</a>
<a name="ln62">  return gmtime_r(timep, result);</a>
<a name="ln63">#endif  // OS_WINDOWS</a>
<a name="ln64">}</a>
<a name="ln65"> </a>
<a name="ln66">char* strnstr(const char* haystack, const char* needle,</a>
<a name="ln67">                     size_t haystack_len) {</a>
<a name="ln68">  if (*needle == '\0') {</a>
<a name="ln69">    return const_cast&lt;char*&gt;(haystack);</a>
<a name="ln70">  }</a>
<a name="ln71">  size_t needle_len = strlen(needle);</a>
<a name="ln72">  char* where;</a>
<a name="ln73">  while ((where = strnchr(haystack, *needle, haystack_len)) != nullptr) {</a>
<a name="ln74">    if (where - haystack + needle_len &gt; haystack_len) {</a>
<a name="ln75">      return nullptr;</a>
<a name="ln76">    }</a>
<a name="ln77">    if (strncmp(where, needle, needle_len) == 0) {</a>
<a name="ln78">      return where;</a>
<a name="ln79">    }</a>
<a name="ln80">    haystack_len -= where + 1 - haystack;</a>
<a name="ln81">    haystack = where + 1;</a>
<a name="ln82">  }</a>
<a name="ln83">  return nullptr;</a>
<a name="ln84">}</a>
<a name="ln85"> </a>
<a name="ln86">const char* strnprefix(const char* haystack, int haystack_size,</a>
<a name="ln87">                              const char* needle, int needle_size) {</a>
<a name="ln88">  if (needle_size &gt; haystack_size) {</a>
<a name="ln89">    return nullptr;</a>
<a name="ln90">  } else {</a>
<a name="ln91">    if (strncmp(haystack, needle, needle_size) == 0) {</a>
<a name="ln92">      return haystack + needle_size;</a>
<a name="ln93">    } else {</a>
<a name="ln94">      return nullptr;</a>
<a name="ln95">    }</a>
<a name="ln96">  }</a>
<a name="ln97">}</a>
<a name="ln98"> </a>
<a name="ln99">const char* strncaseprefix(const char* haystack, int haystack_size,</a>
<a name="ln100">                                  const char* needle, int needle_size) {</a>
<a name="ln101">  if (needle_size &gt; haystack_size) {</a>
<a name="ln102">    return nullptr;</a>
<a name="ln103">  } else {</a>
<a name="ln104">    if (strncasecmp(haystack, needle, needle_size) == 0) {</a>
<a name="ln105">      return haystack + needle_size;</a>
<a name="ln106">    } else {</a>
<a name="ln107">      return nullptr;</a>
<a name="ln108">    }</a>
<a name="ln109">  }</a>
<a name="ln110">}</a>
<a name="ln111"> </a>
<a name="ln112">char* strcasesuffix(char* str, const char* suffix) {</a>
<a name="ln113">  const int lenstr = strlen(str);</a>
<a name="ln114">  const int lensuffix = strlen(suffix);</a>
<a name="ln115">  char* strbeginningoftheend = str + lenstr - lensuffix;</a>
<a name="ln116"> </a>
<a name="ln117">  if (lenstr &gt;= lensuffix &amp;&amp; 0 == strcasecmp(strbeginningoftheend, suffix)) {</a>
<a name="ln118">    return (strbeginningoftheend);</a>
<a name="ln119">  } else {</a>
<a name="ln120">    return (nullptr);</a>
<a name="ln121">  }</a>
<a name="ln122">}</a>
<a name="ln123"> </a>
<a name="ln124">const char* strnsuffix(const char* haystack, int haystack_size,</a>
<a name="ln125">                              const char* needle, int needle_size) {</a>
<a name="ln126">  if (needle_size &gt; haystack_size) {</a>
<a name="ln127">    return nullptr;</a>
<a name="ln128">  } else {</a>
<a name="ln129">    const char* start = haystack + haystack_size - needle_size;</a>
<a name="ln130">    if (strncmp(start, needle, needle_size) == 0) {</a>
<a name="ln131">      return start;</a>
<a name="ln132">    } else {</a>
<a name="ln133">      return nullptr;</a>
<a name="ln134">    }</a>
<a name="ln135">  }</a>
<a name="ln136">}</a>
<a name="ln137"> </a>
<a name="ln138">const char* strncasesuffix(const char* haystack, int haystack_size,</a>
<a name="ln139">                           const char* needle, int needle_size) {</a>
<a name="ln140">  if (needle_size &gt; haystack_size) {</a>
<a name="ln141">    return nullptr;</a>
<a name="ln142">  } else {</a>
<a name="ln143">    const char* start = haystack + haystack_size - needle_size;</a>
<a name="ln144">    if (strncasecmp(start, needle, needle_size) == 0) {</a>
<a name="ln145">      return start;</a>
<a name="ln146">    } else {</a>
<a name="ln147">      return nullptr;</a>
<a name="ln148">    }</a>
<a name="ln149">  }</a>
<a name="ln150">}</a>
<a name="ln151"> </a>
<a name="ln152">char* strchrnth(const char* str, const char&amp; c, int n) {</a>
<a name="ln153">  if (str == nullptr)</a>
<a name="ln154">    return nullptr;</a>
<a name="ln155">  if (n &lt;= 0)</a>
<a name="ln156">    return const_cast&lt;char*&gt;(str);</a>
<a name="ln157">  const char* sp;</a>
<a name="ln158">  int k = 0;</a>
<a name="ln159">  for (sp = str; *sp != '\0'; sp ++) {</a>
<a name="ln160">    if (*sp == c) {</a>
<a name="ln161">      ++k;</a>
<a name="ln162">      if (k &gt;= n)</a>
<a name="ln163">        break;</a>
<a name="ln164">    }</a>
<a name="ln165">  }</a>
<a name="ln166">  return (k &lt; n) ? nullptr : const_cast&lt;char*&gt;(sp);</a>
<a name="ln167">}</a>
<a name="ln168"> </a>
<a name="ln169">char* AdjustedLastPos(const char* str, char separator, int n) {</a>
<a name="ln170">  if ( str == nullptr )</a>
<a name="ln171">    return nullptr;</a>
<a name="ln172">  const char* pos = nullptr;</a>
<a name="ln173">  if ( n &gt; 0 )</a>
<a name="ln174">    pos = strchrnth(str, separator, n);</a>
<a name="ln175"> </a>
<a name="ln176">  // if n &lt;= 0 or separator appears fewer than n times, get the last occurrence</a>
<a name="ln177">  if ( pos == nullptr)</a>
<a name="ln178">    pos = strrchr(str, separator);</a>
<a name="ln179">  return const_cast&lt;char*&gt;(pos);</a>
<a name="ln180">}</a>
<a name="ln181"> </a>
<a name="ln182"> </a>
<a name="ln183">// ----------------------------------------------------------------------</a>
<a name="ln184">// Misc. routines</a>
<a name="ln185">// ----------------------------------------------------------------------</a>
<a name="ln186"> </a>
<a name="ln187">bool IsAscii(const char* str, int len) {</a>
<a name="ln188">  const char* end = str + len;</a>
<a name="ln189">  while (str &lt; end) {</a>
<a name="ln190">    if (!ascii_isascii(*str++)) {</a>
<a name="ln191">      return false;</a>
<a name="ln192">    }</a>
<a name="ln193">  }</a>
<a name="ln194">  return true;</a>
<a name="ln195">}</a>
<a name="ln196"> </a>
<a name="ln197">// ----------------------------------------------------------------------</a>
<a name="ln198">// StringReplace()</a>
<a name="ln199">//    Give me a string and two patterns &quot;old&quot; and &quot;new&quot;, and I replace</a>
<a name="ln200">//    the first instance of &quot;old&quot; in the string with &quot;new&quot;, if it</a>
<a name="ln201">//    exists.  If &quot;replace_all&quot; is true then call this repeatedly until it</a>
<a name="ln202">//    fails.  RETURN a new string, regardless of whether the replacement</a>
<a name="ln203">//    happened or not.</a>
<a name="ln204">// ----------------------------------------------------------------------</a>
<a name="ln205"> </a>
<a name="ln206">string StringReplace(const GStringPiece&amp; s, const GStringPiece&amp; oldsub,</a>
<a name="ln207">                     const GStringPiece&amp; newsub, bool replace_all) {</a>
<a name="ln208">  string ret;</a>
<a name="ln209">  StringReplace(s, oldsub, newsub, replace_all, &amp;ret);</a>
<a name="ln210">  return ret;</a>
<a name="ln211">}</a>
<a name="ln212"> </a>
<a name="ln213"> </a>
<a name="ln214">// ----------------------------------------------------------------------</a>
<a name="ln215">// StringReplace()</a>
<a name="ln216">//    Replace the &quot;old&quot; pattern with the &quot;new&quot; pattern in a string,</a>
<a name="ln217">//    and append the result to &quot;res&quot;.  If replace_all is false,</a>
<a name="ln218">//    it only replaces the first instance of &quot;old.&quot;</a>
<a name="ln219">// ----------------------------------------------------------------------</a>
<a name="ln220"> </a>
<a name="ln221">void StringReplace(const GStringPiece&amp; s, const GStringPiece&amp; oldsub,</a>
<a name="ln222">                   const GStringPiece&amp; newsub, bool replace_all,</a>
<a name="ln223">                   string* res) {</a>
<a name="ln224">  if (oldsub.empty()) {</a>
<a name="ln225">    res-&gt;append(s.data(), s.length());  // If empty, append the given string.</a>
<a name="ln226">    return;</a>
<a name="ln227">  }</a>
<a name="ln228"> </a>
<a name="ln229">  GStringPiece::size_type start_pos = 0;</a>
<a name="ln230">  GStringPiece::size_type pos;</a>
<a name="ln231">  do {</a>
<a name="ln232">    pos = s.find(oldsub, start_pos);</a>
<a name="ln233">    if (pos == GStringPiece::npos) {</a>
<a name="ln234">      break;</a>
<a name="ln235">    }</a>
<a name="ln236">    res-&gt;append(s.data() + start_pos, pos - start_pos);</a>
<a name="ln237">    res-&gt;append(newsub.data(), newsub.length());</a>
<a name="ln238">    // Start searching again after the &quot;old&quot;.</a>
<a name="ln239">    start_pos = pos + oldsub.length();</a>
<a name="ln240">  } while (replace_all);</a>
<a name="ln241">  res-&gt;append(s.data() + start_pos, s.length() - start_pos);</a>
<a name="ln242">}</a>
<a name="ln243"> </a>
<a name="ln244">// ----------------------------------------------------------------------</a>
<a name="ln245">// GlobalReplaceSubstring()</a>
<a name="ln246">//    Replaces all instances of a substring in a string.  Does nothing</a>
<a name="ln247">//    if 'substring' is empty.  Returns the number of replacements.</a>
<a name="ln248">//</a>
<a name="ln249">//    NOTE: The string pieces must not overlap s.</a>
<a name="ln250">// ----------------------------------------------------------------------</a>
<a name="ln251"> </a>
<a name="ln252">int GlobalReplaceSubstring(const GStringPiece&amp; substring,</a>
<a name="ln253">                           const GStringPiece&amp; replacement,</a>
<a name="ln254">                           string* s) {</a>
<a name="ln255">  CHECK(s != nullptr);</a>
<a name="ln256">  if (s-&gt;empty() || substring.empty())</a>
<a name="ln257">    return 0;</a>
<a name="ln258">  string tmp;</a>
<a name="ln259">  int num_replacements = 0;</a>
<a name="ln260">  size_t pos = 0;</a>
<a name="ln261">  for (size_t match_pos = s-&gt;find(substring.data(), pos, substring.length());</a>
<a name="ln262">       match_pos != string::npos;</a>
<a name="ln263">       pos = match_pos + substring.length(),</a>
<a name="ln264">           match_pos = s-&gt;find(substring.data(), pos, substring.length())) {</a>
<a name="ln265">    ++num_replacements;</a>
<a name="ln266">    // Append the original content before the match.</a>
<a name="ln267">    tmp.append(*s, pos, match_pos - pos);</a>
<a name="ln268">    // Append the replacement for the match.</a>
<a name="ln269">    tmp.append(replacement.begin(), replacement.end());</a>
<a name="ln270">  }</a>
<a name="ln271">  // Append the content after the last match. If no replacements were made, the</a>
<a name="ln272">  // original string is left untouched.</a>
<a name="ln273">  if (num_replacements &gt; 0) {</a>
<a name="ln274">    tmp.append(*s, pos, s-&gt;length() - pos);</a>
<a name="ln275">    s-&gt;swap(tmp);</a>
<a name="ln276">  }</a>
<a name="ln277">  return num_replacements;</a>
<a name="ln278">}</a>
<a name="ln279"> </a>
<a name="ln280">//---------------------------------------------------------------------------</a>
<a name="ln281">// RemoveStrings()</a>
<a name="ln282">//   Remove the strings from v given by the (sorted least -&gt; greatest)</a>
<a name="ln283">//   numbers in indices.</a>
<a name="ln284">//   Order of v is *not* preserved.</a>
<a name="ln285">//---------------------------------------------------------------------------</a>
<a name="ln286">void RemoveStrings(vector&lt;string&gt;* v, const vector&lt;int&gt;&amp; indices) {</a>
<a name="ln287">  assert(v);</a>
<a name="ln288">  assert(indices.size() &lt;= v-&gt;size());</a>
<a name="ln289">  // go from largest index to smallest so that smaller indices aren't</a>
<a name="ln290">  // invalidated</a>
<a name="ln291">  for (int lcv = indices.size() - 1; lcv &gt;= 0; --lcv) {</a>
<a name="ln292">#ifndef NDEBUG</a>
<a name="ln293">    // verify that indices is sorted least-&gt;greatest</a>
<a name="ln294">    if (indices.size() &gt;= 2 &amp;&amp; lcv &gt; 0)</a>
<a name="ln295">      // use LT and not LE because we should never see repeat indices</a>
<a name="ln296">      CHECK_LT(indices[lcv-1], indices[lcv]);</a>
<a name="ln297">#endif</a>
<a name="ln298">    assert(indices[lcv] &gt;= 0);</a>
<a name="ln299">    assert(indices[lcv] &lt; v-&gt;size());</a>
<a name="ln300">    swap((*v)[indices[lcv]], v-&gt;back());</a>
<a name="ln301">    v-&gt;pop_back();</a>
<a name="ln302">  }</a>
<a name="ln303">}</a>
<a name="ln304"> </a>
<a name="ln305">// ----------------------------------------------------------------------</a>
<a name="ln306">// gstrcasestr is a case-insensitive strstr. Eventually we should just</a>
<a name="ln307">// use the GNU libc version of strcasestr, but it isn't compiled into</a>
<a name="ln308">// RedHat Linux by default in version 6.1.</a>
<a name="ln309">//</a>
<a name="ln310">// This function uses ascii_tolower() instead of tolower(), for speed.</a>
<a name="ln311">// ----------------------------------------------------------------------</a>
<a name="ln312"> </a>
<a name="ln313">char *gstrcasestr(const char* haystack, const char* needle) {</a>
<a name="ln314">  char c, sc;</a>
<a name="ln315">  size_t len;</a>
<a name="ln316"> </a>
<a name="ln317">  if ((c = *needle++) != 0) {</a>
<a name="ln318">    c = ascii_tolower(c);</a>
<a name="ln319">    len = strlen(needle);</a>
<a name="ln320">    do {</a>
<a name="ln321">      do {</a>
<a name="ln322">        if ((sc = *haystack++) == 0)</a>
<a name="ln323">          return nullptr;</a>
<a name="ln324">      } while (ascii_tolower(sc) != c);</a>
<a name="ln325">    } while (strncasecmp(haystack, needle, len) != 0);</a>
<a name="ln326">    haystack--;</a>
<a name="ln327">  }</a>
<a name="ln328">  // This is a const violation but strstr() also returns a char*.</a>
<a name="ln329">  return const_cast&lt;char*&gt;(haystack);</a>
<a name="ln330">}</a>
<a name="ln331"> </a>
<a name="ln332">// ----------------------------------------------------------------------</a>
<a name="ln333">// gstrncasestr is a case-insensitive strnstr.</a>
<a name="ln334">//    Finds the occurence of the (null-terminated) needle in the</a>
<a name="ln335">//    haystack, where no more than len bytes of haystack is searched.</a>
<a name="ln336">//    Characters that appear after a '\0' in the haystack are not searched.</a>
<a name="ln337">//</a>
<a name="ln338">// This function uses ascii_tolower() instead of tolower(), for speed.</a>
<a name="ln339">// ----------------------------------------------------------------------</a>
<a name="ln340">const char *gstrncasestr(const char* haystack, const char* needle, size_t len) {</a>
<a name="ln341">  char c, sc;</a>
<a name="ln342"> </a>
<a name="ln343">  if ((c = *needle++) != 0) {</a>
<a name="ln344">    c = ascii_tolower(c);</a>
<a name="ln345">    size_t needle_len = strlen(needle);</a>
<a name="ln346">    do {</a>
<a name="ln347">      do {</a>
<a name="ln348">        if (len-- &lt;= needle_len</a>
<a name="ln349">            || 0 == (sc = *haystack++))</a>
<a name="ln350">          return nullptr;</a>
<a name="ln351">      } while (ascii_tolower(sc) != c);</a>
<a name="ln352">    } while (strncasecmp(haystack, needle, needle_len) != 0);</a>
<a name="ln353">    haystack--;</a>
<a name="ln354">  }</a>
<a name="ln355">  return haystack;</a>
<a name="ln356">}</a>
<a name="ln357"> </a>
<a name="ln358">// ----------------------------------------------------------------------</a>
<a name="ln359">// gstrncasestr is a case-insensitive strnstr.</a>
<a name="ln360">//    Finds the occurence of the (null-terminated) needle in the</a>
<a name="ln361">//    haystack, where no more than len bytes of haystack is searched.</a>
<a name="ln362">//    Characters that appear after a '\0' in the haystack are not searched.</a>
<a name="ln363">//</a>
<a name="ln364">//    This function uses ascii_tolower() instead of tolower(), for speed.</a>
<a name="ln365">// ----------------------------------------------------------------------</a>
<a name="ln366">char *gstrncasestr(char* haystack, const char* needle, size_t len) {</a>
<a name="ln367">  return const_cast&lt;char *&gt;(gstrncasestr(static_cast&lt;const char *&gt;(haystack),</a>
<a name="ln368">                                         needle, len));</a>
<a name="ln369">}</a>
<a name="ln370">// ----------------------------------------------------------------------</a>
<a name="ln371">// gstrncasestr_split performs a case insensitive search</a>
<a name="ln372">// on (prefix, non_alpha, suffix).</a>
<a name="ln373">// ----------------------------------------------------------------------</a>
<a name="ln374">char *gstrncasestr_split(const char* str,</a>
<a name="ln375">                         const char* prefix, char non_alpha,</a>
<a name="ln376">                         const char* suffix,</a>
<a name="ln377">                         size_t n) {</a>
<a name="ln378">  int prelen = prefix == nullptr ? 0 : strlen(prefix);</a>
<a name="ln379">  int suflen = suffix == nullptr ? 0 : strlen(suffix);</a>
<a name="ln380"> </a>
<a name="ln381">  // adjust the string and its length to avoid unnessary searching.</a>
<a name="ln382">  // an added benefit is to avoid unnecessary range checks in the if</a>
<a name="ln383">  // statement in the inner loop.</a>
<a name="ln384">  if (suflen + prelen &gt;= n)  return nullptr;</a>
<a name="ln385">  str += prelen;</a>
<a name="ln386">  n -= prelen;</a>
<a name="ln387">  n -= suflen;</a>
<a name="ln388"> </a>
<a name="ln389">  const char* where = nullptr;</a>
<a name="ln390"> </a>
<a name="ln391">  // for every occurance of non_alpha in the string ...</a>
<a name="ln392">  while ((where = static_cast&lt;const char*&gt;(</a>
<a name="ln393">            memchr(str, non_alpha, n))) != nullptr) {</a>
<a name="ln394">    // ... test whether it is followed by suffix and preceded by prefix</a>
<a name="ln395">    if ((!suflen || strncasecmp(where + 1, suffix, suflen) == 0) &amp;&amp;</a>
<a name="ln396">        (!prelen || strncasecmp(where - prelen, prefix, prelen) == 0)) {</a>
<a name="ln397">      return const_cast&lt;char*&gt;(where - prelen);</a>
<a name="ln398">    }</a>
<a name="ln399">    // if not, advance the pointer, and adjust the length according</a>
<a name="ln400">    n -= (where + 1) - str;</a>
<a name="ln401">    str = where + 1;</a>
<a name="ln402">  }</a>
<a name="ln403"> </a>
<a name="ln404">  return nullptr;</a>
<a name="ln405">}</a>
<a name="ln406"> </a>
<a name="ln407">// ----------------------------------------------------------------------</a>
<a name="ln408">// strcasestr_alnum is like a case-insensitive strstr, except that it</a>
<a name="ln409">// ignores non-alphanumeric characters in both strings for the sake of</a>
<a name="ln410">// comparison.</a>
<a name="ln411">//</a>
<a name="ln412">// This function uses ascii_isalnum() instead of isalnum() and</a>
<a name="ln413">// ascii_tolower() instead of tolower(), for speed.</a>
<a name="ln414">//</a>
<a name="ln415">// E.g. strcasestr_alnum(&quot;i use google all the time&quot;, &quot; !!Google!! &quot;)</a>
<a name="ln416">// returns pointer to &quot;google all the time&quot;</a>
<a name="ln417">// ----------------------------------------------------------------------</a>
<a name="ln418">char *strcasestr_alnum(const char *haystack, const char *needle) {</a>
<a name="ln419">  const char *haystack_ptr;</a>
<a name="ln420">  const char *needle_ptr;</a>
<a name="ln421"> </a>
<a name="ln422">  // Skip non-alnums at beginning</a>
<a name="ln423">  while ( !ascii_isalnum(*needle) )</a>
<a name="ln424">    if ( *needle++ == '\0' )</a>
<a name="ln425">      return const_cast&lt;char*&gt;(haystack);</a>
<a name="ln426">  needle_ptr = needle;</a>
<a name="ln427"> </a>
<a name="ln428">  // Skip non-alnums at beginning</a>
<a name="ln429">  while ( !ascii_isalnum(*haystack) )</a>
<a name="ln430">    if ( *haystack++ == '\0' )</a>
<a name="ln431">      return nullptr;</a>
<a name="ln432">  haystack_ptr = haystack;</a>
<a name="ln433"> </a>
<a name="ln434">  while ( *needle_ptr != '\0' ) {</a>
<a name="ln435">    // Non-alnums - advance</a>
<a name="ln436">    while ( !ascii_isalnum(*needle_ptr) )</a>
<a name="ln437">      if ( *needle_ptr++ == '\0' )</a>
<a name="ln438">        return const_cast&lt;char *&gt;(haystack);</a>
<a name="ln439"> </a>
<a name="ln440">    while ( !ascii_isalnum(*haystack_ptr) )</a>
<a name="ln441">      if ( *haystack_ptr++ == '\0' )</a>
<a name="ln442">        return nullptr;</a>
<a name="ln443"> </a>
<a name="ln444">    if ( ascii_tolower(*needle_ptr) == ascii_tolower(*haystack_ptr) ) {</a>
<a name="ln445">      // Case-insensitive match - advance</a>
<a name="ln446">      needle_ptr++;</a>
<a name="ln447">      haystack_ptr++;</a>
<a name="ln448">    } else {</a>
<a name="ln449">      // No match - rollback to next start point in haystack</a>
<a name="ln450">      haystack++;</a>
<a name="ln451">      while ( !ascii_isalnum(*haystack) )</a>
<a name="ln452">        if ( *haystack++ == '\0' )</a>
<a name="ln453">          return nullptr;</a>
<a name="ln454">      haystack_ptr = haystack;</a>
<a name="ln455">      needle_ptr = needle;</a>
<a name="ln456">    }</a>
<a name="ln457">  }</a>
<a name="ln458">  return const_cast&lt;char *&gt;(haystack);</a>
<a name="ln459">}</a>
<a name="ln460"> </a>
<a name="ln461"> </a>
<a name="ln462">// ----------------------------------------------------------------------</a>
<a name="ln463">// CountSubstring()</a>
<a name="ln464">//    Return the number times a &quot;substring&quot; appears in the &quot;text&quot;</a>
<a name="ln465">//    NOTE: this function's complexity is O(|text| * |substring|)</a>
<a name="ln466">//          It is meant for short &quot;text&quot; (such as to ensure the</a>
<a name="ln467">//          printf format string has the right number of arguments).</a>
<a name="ln468">//          DO NOT pass in long &quot;text&quot;.</a>
<a name="ln469">// ----------------------------------------------------------------------</a>
<a name="ln470">int CountSubstring(GStringPiece text, GStringPiece substring) {</a>
<a name="ln471">  CHECK_GT(substring.length(), 0);</a>
<a name="ln472"> </a>
<a name="ln473">  int count = 0;</a>
<a name="ln474">  GStringPiece::size_type curr = 0;</a>
<a name="ln475">  while (GStringPiece::npos != (curr = text.find(substring, curr))) {</a>
<a name="ln476">    ++count;</a>
<a name="ln477">    ++curr;</a>
<a name="ln478">  }</a>
<a name="ln479">  return count;</a>
<a name="ln480">}</a>
<a name="ln481"> </a>
<a name="ln482">// ----------------------------------------------------------------------</a>
<a name="ln483">// strstr_delimited()</a>
<a name="ln484">//    Just like strstr(), except it ensures that the needle appears as</a>
<a name="ln485">//    a complete item (or consecutive series of items) in a delimited</a>
<a name="ln486">//    list.</a>
<a name="ln487">//</a>
<a name="ln488">//    Like strstr(), returns haystack if needle is empty, or NULL if</a>
<a name="ln489">//    either needle/haystack is NULL.</a>
<a name="ln490">// ----------------------------------------------------------------------</a>
<a name="ln491">const char* strstr_delimited(const char* haystack,</a>
<a name="ln492">                             const char* needle,</a>
<a name="ln493">                             char delim) {</a>
<a name="ln494">  if (!needle || !haystack) return nullptr;</a>
<a name="ln495">  if (*needle == '\0') return haystack;</a>
<a name="ln496"> </a>
<a name="ln497">  int needle_len = strlen(needle);</a>
<a name="ln498"> </a>
<a name="ln499">  while (true) {</a>
<a name="ln500">    // Skip any leading delimiters.</a>
<a name="ln501">    while (*haystack == delim) ++haystack;</a>
<a name="ln502"> </a>
<a name="ln503">    // Walk down the haystack, matching every character in the needle.</a>
<a name="ln504">    const char* this_match = haystack;</a>
<a name="ln505">    int i = 0;</a>
<a name="ln506">    for (; i &lt; needle_len; i++) {</a>
<a name="ln507">      if (*haystack != needle[i]) {</a>
<a name="ln508">        // We ran out of haystack or found a non-matching character.</a>
<a name="ln509">        break;</a>
<a name="ln510">      }</a>
<a name="ln511">      ++haystack;</a>
<a name="ln512">    }</a>
<a name="ln513"> </a>
<a name="ln514">    // If we matched the whole needle, ensure that it's properly delimited.</a>
<a name="ln515">    if (i == needle_len &amp;&amp; (*haystack == '\0' || *haystack == delim)) {</a>
<a name="ln516">      return this_match;</a>
<a name="ln517">    }</a>
<a name="ln518"> </a>
<a name="ln519">    // No match. Consume non-delimiter characters until we run out of them.</a>
<a name="ln520">    while (*haystack != delim) {</a>
<a name="ln521">      if (*haystack == '\0') return nullptr;</a>
<a name="ln522">      ++haystack;</a>
<a name="ln523">    }</a>
<a name="ln524">  }</a>
<a name="ln525">  LOG(FATAL) &lt;&lt; &quot;Unreachable statement&quot;;</a>
<a name="ln526">  return nullptr;</a>
<a name="ln527">}</a>
<a name="ln528"> </a>
<a name="ln529"> </a>
<a name="ln530">// ----------------------------------------------------------------------</a>
<a name="ln531">// Older versions of libc have a buggy strsep.</a>
<a name="ln532">// ----------------------------------------------------------------------</a>
<a name="ln533"> </a>
<a name="ln534">char* gstrsep(char** stringp, const char* delim) {</a>
<a name="ln535">  char *s;</a>
<a name="ln536">  const char *spanp;</a>
<a name="ln537">  int c, sc;</a>
<a name="ln538">  char *tok;</a>
<a name="ln539"> </a>
<a name="ln540">  if ((s = *stringp) == nullptr)</a>
<a name="ln541">    return nullptr;</a>
<a name="ln542"> </a>
<a name="ln543">  tok = s;</a>
<a name="ln544">  while (true) {</a>
<a name="ln545">    c = *s++;</a>
<a name="ln546">    spanp = delim;</a>
<a name="ln547">    do {</a>
<a name="ln548">      if ((sc = *spanp++) == c) {</a>
<a name="ln549">        if (c == 0)</a>
<a name="ln550">          s = nullptr;</a>
<a name="ln551">        else</a>
<a name="ln552">          s[-1] = 0;</a>
<a name="ln553">        *stringp = s;</a>
<a name="ln554">        return tok;</a>
<a name="ln555">      }</a>
<a name="ln556">    } while (sc != 0);</a>
<a name="ln557">  }</a>
<a name="ln558"> </a>
<a name="ln559">  return nullptr; /* should not happen */</a>
<a name="ln560">}</a>
<a name="ln561"> </a>
<a name="ln562">void FastStringAppend(string* s, const char* data, int len) {</a>
<a name="ln563">  STLAppendToString(s, data, len);</a>
<a name="ln564">}</a>
<a name="ln565"> </a>
<a name="ln566"> </a>
<a name="ln567">// TODO(user): add a microbenchmark and revisit</a>
<a name="ln568">// the optimizations done here.</a>
<a name="ln569">//</a>
<a name="ln570">// Several converters use this table to reduce</a>
<a name="ln571">// division and modulo operations.</a>
<a name="ln572">extern const char two_ASCII_digits[100][2];</a>
<a name="ln573"> </a>
<a name="ln574">const char two_ASCII_digits[100][2] = {</a>
<a name="ln575">  {'0', '0'}, {'0', '1'}, {'0', '2'}, {'0', '3'}, {'0', '4'},</a>
<a name="ln576">  {'0', '5'}, {'0', '6'}, {'0', '7'}, {'0', '8'}, {'0', '9'},</a>
<a name="ln577">  {'1', '0'}, {'1', '1'}, {'1', '2'}, {'1', '3'}, {'1', '4'},</a>
<a name="ln578">  {'1', '5'}, {'1', '6'}, {'1', '7'}, {'1', '8'}, {'1', '9'},</a>
<a name="ln579">  {'2', '0'}, {'2', '1'}, {'2', '2'}, {'2', '3'}, {'2', '4'},</a>
<a name="ln580">  {'2', '5'}, {'2', '6'}, {'2', '7'}, {'2', '8'}, {'2', '9'},</a>
<a name="ln581">  {'3', '0'}, {'3', '1'}, {'3', '2'}, {'3', '3'}, {'3', '4'},</a>
<a name="ln582">  {'3', '5'}, {'3', '6'}, {'3', '7'}, {'3', '8'}, {'3', '9'},</a>
<a name="ln583">  {'4', '0'}, {'4', '1'}, {'4', '2'}, {'4', '3'}, {'4', '4'},</a>
<a name="ln584">  {'4', '5'}, {'4', '6'}, {'4', '7'}, {'4', '8'}, {'4', '9'},</a>
<a name="ln585">  {'5', '0'}, {'5', '1'}, {'5', '2'}, {'5', '3'}, {'5', '4'},</a>
<a name="ln586">  {'5', '5'}, {'5', '6'}, {'5', '7'}, {'5', '8'}, {'5', '9'},</a>
<a name="ln587">  {'6', '0'}, {'6', '1'}, {'6', '2'}, {'6', '3'}, {'6', '4'},</a>
<a name="ln588">  {'6', '5'}, {'6', '6'}, {'6', '7'}, {'6', '8'}, {'6', '9'},</a>
<a name="ln589">  {'7', '0'}, {'7', '1'}, {'7', '2'}, {'7', '3'}, {'7', '4'},</a>
<a name="ln590">  {'7', '5'}, {'7', '6'}, {'7', '7'}, {'7', '8'}, {'7', '9'},</a>
<a name="ln591">  {'8', '0'}, {'8', '1'}, {'8', '2'}, {'8', '3'}, {'8', '4'},</a>
<a name="ln592">  {'8', '5'}, {'8', '6'}, {'8', '7'}, {'8', '8'}, {'8', '9'},</a>
<a name="ln593">  {'9', '0'}, {'9', '1'}, {'9', '2'}, {'9', '3'}, {'9', '4'},</a>
<a name="ln594">  {'9', '5'}, {'9', '6'}, {'9', '7'}, {'9', '8'}, {'9', '9'}</a>
<a name="ln595">};</a>
<a name="ln596"> </a>
<a name="ln597">static inline void PutTwoDigits(int i, char* p) {</a>
<a name="ln598">  DCHECK_GE(i, 0);</a>
<a name="ln599">  DCHECK_LT(i, 100);</a>
<a name="ln600">  p[0] = two_ASCII_digits[i][0];</a>
<a name="ln601">  p[1] = two_ASCII_digits[i][1];</a>
<a name="ln602">}</a>
<a name="ln603"> </a>
<a name="ln604">char* FastTimeToBuffer(time_t s, char* buffer) {</a>
<a name="ln605">  if (s == 0) {</a>
<a name="ln606">    time(&amp;s);</a>
<a name="ln607">  }</a>
<a name="ln608"> </a>
<a name="ln609">  struct tm tm;</a>
<a name="ln610">  if (PortableSafeGmtime(&amp;s, &amp;tm) == nullptr) {</a>
<a name="ln611">    // Error message must fit in 30-char buffer.</a>
<a name="ln612">    memcpy(buffer, &quot;Invalid:&quot;, sizeof(&quot;Invalid:&quot;));</a>
<a name="ln613">    FastInt64ToBufferLeft(s, buffer+strlen(buffer));</a>
<a name="ln614">    return buffer;</a>
<a name="ln615">  }</a>
<a name="ln616"> </a>
<a name="ln617">  // strftime format: &quot;%a, %d %b %Y %H:%M:%S GMT&quot;,</a>
<a name="ln618">  // but strftime does locale stuff which we do not want</a>
<a name="ln619">  // plus strftime takes &gt; 10x the time of hard code</a>
<a name="ln620"> </a>
<a name="ln621">  const char* weekday_name = &quot;Xxx&quot;;</a>
<a name="ln622">  switch (tm.tm_wday) {</a>
<a name="ln623">    default: { DLOG(FATAL) &lt;&lt; &quot;tm.tm_wday: &quot; &lt;&lt; tm.tm_wday; } break;</a>
<a name="ln624">    case 0:  weekday_name = &quot;Sun&quot;; break;</a>
<a name="ln625">    case 1:  weekday_name = &quot;Mon&quot;; break;</a>
<a name="ln626">    case 2:  weekday_name = &quot;Tue&quot;; break;</a>
<a name="ln627">    case 3:  weekday_name = &quot;Wed&quot;; break;</a>
<a name="ln628">    case 4:  weekday_name = &quot;Thu&quot;; break;</a>
<a name="ln629">    case 5:  weekday_name = &quot;Fri&quot;; break;</a>
<a name="ln630">    case 6:  weekday_name = &quot;Sat&quot;; break;</a>
<a name="ln631">  }</a>
<a name="ln632"> </a>
<a name="ln633">  const char* month_name = &quot;Xxx&quot;;</a>
<a name="ln634">  switch (tm.tm_mon) {</a>
<a name="ln635">    default:  { DLOG(FATAL) &lt;&lt; &quot;tm.tm_mon: &quot; &lt;&lt; tm.tm_mon; } break;</a>
<a name="ln636">    case 0:   month_name = &quot;Jan&quot;; break;</a>
<a name="ln637">    case 1:   month_name = &quot;Feb&quot;; break;</a>
<a name="ln638">    case 2:   month_name = &quot;Mar&quot;; break;</a>
<a name="ln639">    case 3:   month_name = &quot;Apr&quot;; break;</a>
<a name="ln640">    case 4:   month_name = &quot;May&quot;; break;</a>
<a name="ln641">    case 5:   month_name = &quot;Jun&quot;; break;</a>
<a name="ln642">    case 6:   month_name = &quot;Jul&quot;; break;</a>
<a name="ln643">    case 7:   month_name = &quot;Aug&quot;; break;</a>
<a name="ln644">    case 8:   month_name = &quot;Sep&quot;; break;</a>
<a name="ln645">    case 9:   month_name = &quot;Oct&quot;; break;</a>
<a name="ln646">    case 10:  month_name = &quot;Nov&quot;; break;</a>
<a name="ln647">    case 11:  month_name = &quot;Dec&quot;; break;</a>
<a name="ln648">  }</a>
<a name="ln649"> </a>
<a name="ln650">  // Write out the buffer.</a>
<a name="ln651"> </a>
<a name="ln652">  memcpy(buffer+0, weekday_name, 3);</a>
<a name="ln653">  buffer[3] = ',';</a>
<a name="ln654">  buffer[4] = ' ';</a>
<a name="ln655"> </a>
<a name="ln656">  PutTwoDigits(tm.tm_mday, buffer+5);</a>
<a name="ln657">  buffer[7] = ' ';</a>
<a name="ln658"> </a>
<a name="ln659">  memcpy(buffer+8, month_name, 3);</a>
<a name="ln660">  buffer[11] = ' ';</a>
<a name="ln661"> </a>
<a name="ln662">  int32 year = tm.tm_year + 1900;</a>
<a name="ln663">  PutTwoDigits(year/100, buffer+12);</a>
<a name="ln664">  PutTwoDigits(year%100, buffer+14);</a>
<a name="ln665">  buffer[16] = ' ';</a>
<a name="ln666"> </a>
<a name="ln667">  PutTwoDigits(tm.tm_hour, buffer+17);</a>
<a name="ln668">  buffer[19] = ':';</a>
<a name="ln669"> </a>
<a name="ln670">  PutTwoDigits(tm.tm_min, buffer+20);</a>
<a name="ln671">  buffer[22] = ':';</a>
<a name="ln672"> </a>
<a name="ln673">  PutTwoDigits(tm.tm_sec, buffer+23);</a>
<a name="ln674"> </a>
<a name="ln675">  // includes ending NUL</a>
<a name="ln676">  memcpy(buffer+25, &quot; GMT&quot;, 5);</a>
<a name="ln677"> </a>
<a name="ln678">  return buffer;</a>
<a name="ln679">}</a>
<a name="ln680"> </a>
<a name="ln681">// ----------------------------------------------------------------------</a>
<a name="ln682">// strdup_with_new()</a>
<a name="ln683">// strndup_with_new()</a>
<a name="ln684">//</a>
<a name="ln685">//    strdup_with_new() is the same as strdup() except that the memory</a>
<a name="ln686">//    is allocated by new[] and hence an exception will be generated</a>
<a name="ln687">//    if out of memory.</a>
<a name="ln688">//</a>
<a name="ln689">//    strndup_with_new() is the same as strdup_with_new() except that it will</a>
<a name="ln690">//    copy up to the specified number of characters.  This function</a>
<a name="ln691">//    is useful when we want to copy a substring out of a string</a>
<a name="ln692">//    and didn't want to (or cannot) modify the string</a>
<a name="ln693">// ----------------------------------------------------------------------</a>
<a name="ln694">char* strdup_with_new(const char* the_string) {</a>
<a name="ln695">  if (the_string == nullptr)</a>
<a name="ln696">    return nullptr;</a>
<a name="ln697">  else</a>
<a name="ln698">    return strndup_with_new(the_string, strlen(the_string));</a>
<a name="ln699">}</a>
<a name="ln700"> </a>
<a name="ln701">char* strndup_with_new(const char* the_string, int max_length) {</a>
<a name="ln702">  if (the_string == nullptr)</a>
<a name="ln703">    return nullptr;</a>
<a name="ln704"> </a>
<a name="ln705">  auto result = new char[max_length + 1];</a>
<a name="ln706">  result[max_length] = '\0';  // terminate the string because strncpy might not</a>
<a name="ln707">  return strncpy(result, the_string, max_length);</a>
<a name="ln708">}</a>
<a name="ln709"> </a>
<a name="ln710"> </a>
<a name="ln711"> </a>
<a name="ln712"> </a>
<a name="ln713">// ----------------------------------------------------------------------</a>
<a name="ln714">// ScanForFirstWord()</a>
<a name="ln715">//    This function finds the first word in the string &quot;the_string&quot; given.</a>
<a name="ln716">//    A word is defined by consecutive !ascii_isspace() characters.</a>
<a name="ln717">//    If no valid words are found,</a>
<a name="ln718">//        return NULL and *end_ptr will contain junk</a>
<a name="ln719">//    else</a>
<a name="ln720">//        return the beginning of the first word and</a>
<a name="ln721">//        *end_ptr will store the address of the first invalid character</a>
<a name="ln722">//        (ascii_isspace() or '\0').</a>
<a name="ln723">//</a>
<a name="ln724">//    Precondition: (end_ptr != NULL)</a>
<a name="ln725">// ----------------------------------------------------------------------</a>
<a name="ln726">const char* ScanForFirstWord(const char* the_string, const char** end_ptr) {</a>
<a name="ln727">  CHECK(end_ptr != nullptr) &lt;&lt; &quot;: precondition violated&quot;;</a>
<a name="ln728"> </a>
<a name="ln729">  if (the_string == nullptr)  // empty string</a>
<a name="ln730">    return nullptr;</a>
<a name="ln731"> </a>
<a name="ln732">  const char* curr = the_string;</a>
<a name="ln733">  while ((*curr != '\0') &amp;&amp; ascii_isspace(*curr))  // skip initial spaces</a>
<a name="ln734">    ++curr;</a>
<a name="ln735"> </a>
<a name="ln736">  if (*curr == '\0')  // no valid word found</a>
<a name="ln737">    return nullptr;</a>
<a name="ln738"> </a>
<a name="ln739">  // else has a valid word</a>
<a name="ln740">  const char* first_word = curr;</a>
<a name="ln741"> </a>
<a name="ln742">  // now locate the end of the word</a>
<a name="ln743">  while ((*curr != '\0') &amp;&amp; !ascii_isspace(*curr))</a>
<a name="ln744">    ++curr;</a>
<a name="ln745"> </a>
<a name="ln746">  *end_ptr = curr;</a>
<a name="ln747">  return first_word;</a>
<a name="ln748">}</a>
<a name="ln749"> </a>
<a name="ln750">// ----------------------------------------------------------------------</a>
<a name="ln751">// AdvanceIdentifier()</a>
<a name="ln752">//    This function returns a pointer past the end of the longest C-style</a>
<a name="ln753">//    identifier that is a prefix of str or NULL if str does not start with</a>
<a name="ln754">//    one.  A C-style identifier begins with an ASCII letter or underscore</a>
<a name="ln755">//    and continues with ASCII letters, digits, or underscores.</a>
<a name="ln756">// ----------------------------------------------------------------------</a>
<a name="ln757">const char *AdvanceIdentifier(const char *str) {</a>
<a name="ln758">  // Not using isalpha and isalnum so as not to rely on the locale.</a>
<a name="ln759">  // We could have used ascii_isalpha and ascii_isalnum.</a>
<a name="ln760">  char ch = *str++;</a>
<a name="ln761">  if (!((ch &gt;= 'a' &amp;&amp; ch &lt;= 'z') || (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z') || ch == '_'))</a>
<a name="ln762">    return nullptr;</a>
<a name="ln763">  while (true) {</a>
<a name="ln764">    ch = *str;</a>
<a name="ln765">    if (!((ch &gt;= 'a' &amp;&amp; ch &lt;= 'z') || (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z') ||</a>
<a name="ln766">          (ch &gt;= '0' &amp;&amp; ch &lt;= '9') || ch == '_'))</a>
<a name="ln767">      return str;</a>
<a name="ln768">    str++;</a>
<a name="ln769">  }</a>
<a name="ln770">}</a>
<a name="ln771"> </a>
<a name="ln772"> </a>
<a name="ln773">// ----------------------------------------------------------------------</a>
<a name="ln774">// IsIdentifier()</a>
<a name="ln775">//    This function returns true if str is a C-style identifier.</a>
<a name="ln776">//    A C-style identifier begins with an ASCII letter or underscore</a>
<a name="ln777">//    and continues with ASCII letters, digits, or underscores.</a>
<a name="ln778">// ----------------------------------------------------------------------</a>
<a name="ln779">bool IsIdentifier(const char *str) {</a>
<a name="ln780">  const char *end = AdvanceIdentifier(str);</a>
<a name="ln781">  return end &amp;&amp; *end == '\0';</a>
<a name="ln782">}</a>
<a name="ln783"> </a>
<a name="ln784">static bool IsWildcard(Rune character) {</a>
<a name="ln785">  return character == '*' || character == '?';</a>
<a name="ln786">}</a>
<a name="ln787"> </a>
<a name="ln788">// Move the strings pointers to the point where they start to differ.</a>
<a name="ln789">template &lt;typename CHAR, typename NEXT&gt;</a>
<a name="ln790">static void EatSameChars(const CHAR** pattern, const CHAR* pattern_end,</a>
<a name="ln791">                         const CHAR** string, const CHAR* string_end,</a>
<a name="ln792">                         NEXT next) {</a>
<a name="ln793">  const CHAR* escape = nullptr;</a>
<a name="ln794">  while (*pattern != pattern_end &amp;&amp; *string != string_end) {</a>
<a name="ln795">    if (!escape &amp;&amp; IsWildcard(**pattern)) {</a>
<a name="ln796">      // We don't want to match wildcard here, except if it's escaped.</a>
<a name="ln797">      return;</a>
<a name="ln798">    }</a>
<a name="ln799"> </a>
<a name="ln800">    // Check if the escapement char is found. If so, skip it and move to the</a>
<a name="ln801">    // next character.</a>
<a name="ln802">    if (!escape &amp;&amp; **pattern == '\\') {</a>
<a name="ln803">      escape = *pattern;</a>
<a name="ln804">      next(pattern, pattern_end);</a>
<a name="ln805">      continue;</a>
<a name="ln806">    }</a>
<a name="ln807"> </a>
<a name="ln808">    // Check if the chars match, if so, increment the ptrs.</a>
<a name="ln809">    const CHAR* pattern_next = *pattern;</a>
<a name="ln810">    const CHAR* string_next = *string;</a>
<a name="ln811">    Rune pattern_char = next(&amp;pattern_next, pattern_end);</a>
<a name="ln812">    if (pattern_char == next(&amp;string_next, string_end) &amp;&amp;</a>
<a name="ln813">        pattern_char != Runeerror &amp;&amp;</a>
<a name="ln814">        pattern_char &lt;= Runemax) {</a>
<a name="ln815">      *pattern = pattern_next;</a>
<a name="ln816">      *string = string_next;</a>
<a name="ln817">    } else {</a>
<a name="ln818">      // Uh ho, it did not match, we are done. If the last char was an</a>
<a name="ln819">      // escapement, that means that it was an error to advance the ptr here,</a>
<a name="ln820">      // let's put it back where it was. This also mean that the MatchPattern</a>
<a name="ln821">      // function will return false because if we can't match an escape char</a>
<a name="ln822">      // here, then no one will.</a>
<a name="ln823">      if (escape) {</a>
<a name="ln824">        *pattern = escape;</a>
<a name="ln825">      }</a>
<a name="ln826">      return;</a>
<a name="ln827">    }</a>
<a name="ln828"> </a>
<a name="ln829">    escape = nullptr;</a>
<a name="ln830">  }</a>
<a name="ln831">}</a>
<a name="ln832"> </a>
<a name="ln833">template &lt;typename CHAR, typename NEXT&gt;</a>
<a name="ln834">static void EatWildcard(const CHAR** pattern, const CHAR* end, NEXT next) {</a>
<a name="ln835">  while (*pattern != end) {</a>
<a name="ln836">    if (!IsWildcard(**pattern))</a>
<a name="ln837">      return;</a>
<a name="ln838">    next(pattern, end);</a>
<a name="ln839">  }</a>
<a name="ln840">}</a>
<a name="ln841"> </a>
<a name="ln842">template &lt;typename CHAR, typename NEXT&gt;</a>
<a name="ln843">static bool MatchPatternT(const CHAR* eval, const CHAR* eval_end,</a>
<a name="ln844">                          const CHAR* pattern, const CHAR* pattern_end,</a>
<a name="ln845">                          int depth,</a>
<a name="ln846">                          NEXT next) {</a>
<a name="ln847">  const int kMaxDepth = 16;</a>
<a name="ln848">  if (depth &gt; kMaxDepth)</a>
<a name="ln849">    return false;</a>
<a name="ln850"> </a>
<a name="ln851">  // Eat all the matching chars.</a>
<a name="ln852">  EatSameChars(&amp;pattern, pattern_end, &amp;eval, eval_end, next);</a>
<a name="ln853"> </a>
<a name="ln854">  // If the string is empty, then the pattern must be empty too, or contains</a>
<a name="ln855">  // only wildcards.</a>
<a name="ln856">  if (eval == eval_end) {</a>
<a name="ln857">    EatWildcard(&amp;pattern, pattern_end, next);</a>
<a name="ln858">    return pattern == pattern_end;</a>
<a name="ln859">  }</a>
<a name="ln860"> </a>
<a name="ln861">  // Pattern is empty but not string, this is not a match.</a>
<a name="ln862">  if (pattern == pattern_end)</a>
<a name="ln863">    return false;</a>
<a name="ln864"> </a>
<a name="ln865">  // If this is a question mark, then we need to compare the rest with</a>
<a name="ln866">  // the current string or the string with one character eaten.</a>
<a name="ln867">  const CHAR* next_pattern = pattern;</a>
<a name="ln868">  next(&amp;next_pattern, pattern_end);</a>
<a name="ln869">  if (pattern[0] == '?') {</a>
<a name="ln870">    if (MatchPatternT(eval, eval_end, next_pattern, pattern_end,</a>
<a name="ln871">                      depth + 1, next))</a>
<a name="ln872">      return true;</a>
<a name="ln873">    const CHAR* next_eval = eval;</a>
<a name="ln874">    next(&amp;next_eval, eval_end);</a>
<a name="ln875">    if (MatchPatternT(next_eval, eval_end, next_pattern, pattern_end,</a>
<a name="ln876">                      depth + 1, next))</a>
<a name="ln877">      return true;</a>
<a name="ln878">  }</a>
<a name="ln879"> </a>
<a name="ln880">  // This is a *, try to match all the possible substrings with the remainder</a>
<a name="ln881">  // of the pattern.</a>
<a name="ln882">  if (pattern[0] == '*') {</a>
<a name="ln883">    // Collapse duplicate wild cards (********** into *) so that the</a>
<a name="ln884">    // method does not recurse unnecessarily. http://crbug.com/52839</a>
<a name="ln885">    EatWildcard(&amp;next_pattern, pattern_end, next);</a>
<a name="ln886"> </a>
<a name="ln887">    while (eval != eval_end) {</a>
<a name="ln888">      if (MatchPatternT(eval, eval_end, next_pattern, pattern_end,</a>
<a name="ln889">                        depth + 1, next))</a>
<a name="ln890">        return true;</a>
<a name="ln891">      eval++;</a>
<a name="ln892">    }</a>
<a name="ln893"> </a>
<a name="ln894">    // We reached the end of the string, let see if the pattern contains only</a>
<a name="ln895">    // wildcards.</a>
<a name="ln896">    if (eval == eval_end) {</a>
<a name="ln897">      EatWildcard(&amp;pattern, pattern_end, next);</a>
<a name="ln898">      if (pattern != pattern_end)</a>
<a name="ln899">        return false;</a>
<a name="ln900">      return true;</a>
<a name="ln901">    }</a>
<a name="ln902">  }</a>
<a name="ln903"> </a>
<a name="ln904">  return false;</a>
<a name="ln905">}</a>
<a name="ln906"> </a>
<a name="ln907">struct NextCharUTF8 {</a>
<a name="ln908">  Rune operator()(const char** p, const char* end) {</a>
<a name="ln909">    Rune c;</a>
<a name="ln910">    int offset = charntorune(&amp;c, *p, static_cast&lt;int&gt;(end - *p));</a>
<a name="ln911">    *p += offset;</a>
<a name="ln912">    return c;</a>
<a name="ln913">  }</a>
<a name="ln914">};</a>
<a name="ln915"> </a>
<a name="ln916">bool MatchPattern(const GStringPiece&amp; eval,</a>
<a name="ln917">                  const GStringPiece&amp; pattern) {</a>
<a name="ln918">  return MatchPatternT(eval.data(), eval.data() + eval.size(),</a>
<a name="ln919">                       pattern.data(), pattern.data() + pattern.size(),</a>
<a name="ln920">                       0, NextCharUTF8());</a>
<a name="ln921">}</a>
<a name="ln922"> </a>
<a name="ln923"> </a>
<a name="ln924"> </a>
<a name="ln925">// ----------------------------------------------------------------------</a>
<a name="ln926">// FindTagValuePair</a>
<a name="ln927">//    Given a string of the form</a>
<a name="ln928">//    &lt;something&gt;&lt;attr_sep&gt;&lt;tag&gt;&lt;tag_value_sep&gt;&lt;value&gt;&lt;attr_sep&gt;...&lt;string_term&gt;</a>
<a name="ln929">//    where the part before the first attr_sep is optional,</a>
<a name="ln930">//    this function extracts the first tag and value, if any.</a>
<a name="ln931">//    The function returns true if successful, in which case &quot;tag&quot; and &quot;value&quot;</a>
<a name="ln932">//    are set to point to the beginning of the tag and the value, respectively,</a>
<a name="ln933">//    and &quot;tag_len&quot; and &quot;value_len&quot; are set to the respective lengths.</a>
<a name="ln934">// ----------------------------------------------------------------------</a>
<a name="ln935"> </a>
<a name="ln936">bool FindTagValuePair(const char* arg_str, char tag_value_separator,</a>
<a name="ln937">                      char attribute_separator, char string_terminal,</a>
<a name="ln938">                      char **tag, int *tag_len,</a>
<a name="ln939">                      char **value, int *value_len) {</a>
<a name="ln940">  char* in_str = const_cast&lt;char*&gt;(arg_str);  // For msvc8.</a>
<a name="ln941">  if (in_str == nullptr)</a>
<a name="ln942">    return false;</a>
<a name="ln943">  char tv_sep_or_term[3] = {tag_value_separator, string_terminal, '\0'};</a>
<a name="ln944">  char attr_sep_or_term[3] = {attribute_separator, string_terminal, '\0'};</a>
<a name="ln945"> </a>
<a name="ln946">  // Look for beginning of tag</a>
<a name="ln947">  *tag = strpbrk(in_str, attr_sep_or_term);</a>
<a name="ln948">  // If string_terminal is '\0', strpbrk won't find it but return null.</a>
<a name="ln949">  if (*tag == nullptr || **tag == string_terminal)</a>
<a name="ln950">    *tag = in_str;</a>
<a name="ln951">  else</a>
<a name="ln952">    (*tag)++;   // Move past separator</a>
<a name="ln953">  // Now look for value...</a>
<a name="ln954">  char *tv_sep_pos = strpbrk(*tag, tv_sep_or_term);</a>
<a name="ln955">  if (tv_sep_pos == nullptr || *tv_sep_pos == string_terminal)</a>
<a name="ln956">    return false;</a>
<a name="ln957">  // ...and end of value</a>
<a name="ln958">  char *attr_sep_pos = strpbrk(tv_sep_pos, attr_sep_or_term);</a>
<a name="ln959"> </a>
<a name="ln960">  *tag_len = tv_sep_pos - *tag;</a>
<a name="ln961">  *value = tv_sep_pos + 1;</a>
<a name="ln962">  if (attr_sep_pos != nullptr)</a>
<a name="ln963">    *value_len = attr_sep_pos - *value;</a>
<a name="ln964">  else</a>
<a name="ln965">    *value_len = strlen(*value);</a>
<a name="ln966">  return true;</a>
<a name="ln967">}</a>
<a name="ln968"> </a>
<a name="ln969">void UniformInsertString(string* s, int interval, const char* separator) {</a>
<a name="ln970">  const size_t separator_len = strlen(separator);</a>
<a name="ln971"> </a>
<a name="ln972">  if (interval &lt; 1 ||      // invalid interval</a>
<a name="ln973">      s-&gt;empty() ||        // nothing to do</a>
<a name="ln974">      separator_len == 0)  // invalid separator</a>
<a name="ln975">    return;</a>
<a name="ln976"> </a>
<a name="ln977">  int num_inserts = (s-&gt;size() - 1) / interval;  // -1 to avoid appending at end</a>
<a name="ln978">  if (num_inserts == 0)  // nothing to do</a>
<a name="ln979">    return;</a>
<a name="ln980"> </a>
<a name="ln981">  string tmp;</a>
<a name="ln982">  tmp.reserve(s-&gt;size() + num_inserts * separator_len + 1);</a>
<a name="ln983"> </a>
<a name="ln984">  for (int i = 0; i &lt; num_inserts ; ++i) {</a>
<a name="ln985">    // append this interval</a>
<a name="ln986">    tmp.append(*s, i * interval, interval);</a>
<a name="ln987">    // append a separator</a>
<a name="ln988">    tmp.append(separator, separator_len);</a>
<a name="ln989">  }</a>
<a name="ln990"> </a>
<a name="ln991">  // append the tail</a>
<a name="ln992">  const size_t tail_pos = num_inserts * interval;</a>
<a name="ln993">  tmp.append(*s, tail_pos, s-&gt;size() - tail_pos);</a>
<a name="ln994"> </a>
<a name="ln995">  s-&gt;swap(tmp);</a>
<a name="ln996">}</a>
<a name="ln997"> </a>
<a name="ln998">void InsertString(string *const s,</a>
<a name="ln999">                  const vector&lt;uint32&gt; &amp;indices,</a>
<a name="ln1000">                  char const *const separator) {</a>
<a name="ln1001">  const unsigned num_indices(indices.size());</a>
<a name="ln1002">  if (num_indices == 0) {</a>
<a name="ln1003">    return;  // nothing to do...</a>
<a name="ln1004">  }</a>
<a name="ln1005"> </a>
<a name="ln1006">  const unsigned separator_len(strlen(separator));</a>
<a name="ln1007">  if (separator_len == 0) {</a>
<a name="ln1008">    return;  // still nothing to do...</a>
<a name="ln1009">  }</a>
<a name="ln1010"> </a>
<a name="ln1011">  string tmp;</a>
<a name="ln1012">  const unsigned s_len(s-&gt;size());</a>
<a name="ln1013">  tmp.reserve(s_len + separator_len * num_indices);</a>
<a name="ln1014"> </a>
<a name="ln1015">  vector&lt;uint32&gt;::const_iterator const ind_end(indices.end());</a>
<a name="ln1016">  auto ind_pos(indices.begin());</a>
<a name="ln1017"> </a>
<a name="ln1018">  uint32 last_pos(0);</a>
<a name="ln1019">  while (ind_pos != ind_end) {</a>
<a name="ln1020">    const uint32 pos(*ind_pos);</a>
<a name="ln1021">    DCHECK_GE(pos, last_pos);</a>
<a name="ln1022">    DCHECK_LE(pos, s_len);</a>
<a name="ln1023"> </a>
<a name="ln1024">    tmp.append(s-&gt;substr(last_pos, pos - last_pos));</a>
<a name="ln1025">    tmp.append(separator);</a>
<a name="ln1026"> </a>
<a name="ln1027">    last_pos = pos;</a>
<a name="ln1028">    ++ind_pos;</a>
<a name="ln1029">  }</a>
<a name="ln1030">  tmp.append(s-&gt;substr(last_pos));</a>
<a name="ln1031"> </a>
<a name="ln1032">  s-&gt;swap(tmp);</a>
<a name="ln1033">}</a>
<a name="ln1034"> </a>
<a name="ln1035">//------------------------------------------------------------------------</a>
<a name="ln1036">// FindNth()</a>
<a name="ln1037">//  return index of nth occurrence of c in the string,</a>
<a name="ln1038">//  or string::npos if n &gt; number of occurrences of c.</a>
<a name="ln1039">//  (returns string::npos = -1 if n &lt;= 0)</a>
<a name="ln1040">//------------------------------------------------------------------------</a>
<a name="ln1041">int FindNth(GStringPiece s, char c, int n) {</a>
<a name="ln1042">  size_t pos = string::npos;</a>
<a name="ln1043"> </a>
<a name="ln1044">  for ( int i = 0; i &lt; n; ++i ) {</a>
<a name="ln1045">    pos = s.find_first_of(c, pos + 1);</a>
<a name="ln1046">    if ( pos == GStringPiece::npos ) {</a>
<a name="ln1047">      break;</a>
<a name="ln1048">    }</a>
<a name="ln1049">  }</a>
<a name="ln1050">  return pos;</a>
<a name="ln1051">}</a>
<a name="ln1052"> </a>
<a name="ln1053">//------------------------------------------------------------------------</a>
<a name="ln1054">// ReverseFindNth()</a>
<a name="ln1055">//  return index of nth-to-last occurrence of c in the string,</a>
<a name="ln1056">//  or string::npos if n &gt; number of occurrences of c.</a>
<a name="ln1057">//  (returns string::npos if n &lt;= 0)</a>
<a name="ln1058">//------------------------------------------------------------------------</a>
<a name="ln1059">int ReverseFindNth(GStringPiece s, char c, int n) {</a>
<a name="ln1060">  if ( n &lt;= 0 ) {</a>
<a name="ln1061">    return static_cast&lt;int&gt;(GStringPiece::npos);</a>
<a name="ln1062">  }</a>
<a name="ln1063"> </a>
<a name="ln1064">  size_t pos = s.size();</a>
<a name="ln1065"> </a>
<a name="ln1066">  for ( int i = 0; i &lt; n; ++i ) {</a>
<a name="ln1067">    // If pos == 0, we return GStringPiece::npos right away. Otherwise,</a>
<a name="ln1068">    // the following find_last_of call would take (pos - 1) as string::npos,</a>
<a name="ln1069">    // which means it would again search the entire input string.</a>
<a name="ln1070">    if (pos == 0) {</a>
<a name="ln1071">      return static_cast&lt;int&gt;(GStringPiece::npos);</a>
<a name="ln1072">    }</a>
<a name="ln1073">    pos = s.find_last_of(c, pos - 1);</a>
<a name="ln1074">    if ( pos == string::npos ) {</a>
<a name="ln1075">      break;</a>
<a name="ln1076">    }</a>
<a name="ln1077">  }</a>
<a name="ln1078">  return pos;</a>
<a name="ln1079">}</a>
<a name="ln1080"> </a>
<a name="ln1081">namespace strings {</a>
<a name="ln1082"> </a>
<a name="ln1083">// FindEol()</a>
<a name="ln1084">// Returns the location of the next end-of-line sequence.</a>
<a name="ln1085"> </a>
<a name="ln1086">GStringPiece FindEol(GStringPiece s) {</a>
<a name="ln1087">  for (size_t i = 0; i &lt; s.length(); ++i) {</a>
<a name="ln1088">    if (s[i] == '\n') {</a>
<a name="ln1089">      return GStringPiece(s.data() + i, 1);</a>
<a name="ln1090">    }</a>
<a name="ln1091">    if (s[i] == '\r') {</a>
<a name="ln1092">      if (i+1 &lt; s.length() &amp;&amp; s[i+1] == '\n') {</a>
<a name="ln1093">        return GStringPiece(s.data() + i, 2);</a>
<a name="ln1094">      } else {</a>
<a name="ln1095">        return GStringPiece(s.data() + i, 1);</a>
<a name="ln1096">      }</a>
<a name="ln1097">    }</a>
<a name="ln1098">  }</a>
<a name="ln1099">  return GStringPiece(s.data() + s.length(), 0);</a>
<a name="ln1100">}</a>
<a name="ln1101"> </a>
<a name="ln1102">}  // namespace strings</a>
<a name="ln1103"> </a>
<a name="ln1104">//------------------------------------------------------------------------</a>
<a name="ln1105">// OnlyWhitespace()</a>
<a name="ln1106">//  return true if string s contains only whitespace characters</a>
<a name="ln1107">//------------------------------------------------------------------------</a>
<a name="ln1108">bool OnlyWhitespace(const GStringPiece&amp; s) {</a>
<a name="ln1109">  for (const auto&amp; c : s) {</a>
<a name="ln1110">    if ( !ascii_isspace(c) ) return false;</a>
<a name="ln1111">  }</a>
<a name="ln1112">  return true;</a>
<a name="ln1113">}</a>
<a name="ln1114"> </a>
<a name="ln1115">string PrefixSuccessor(const GStringPiece&amp; prefix) {</a>
<a name="ln1116">  // We can increment the last character in the string and be done</a>
<a name="ln1117">  // unless that character is 255, in which case we have to erase the</a>
<a name="ln1118">  // last character and increment the previous character, unless that</a>
<a name="ln1119">  // is 255, etc. If the string is empty or consists entirely of</a>
<a name="ln1120">  // 255's, we just return the empty string.</a>
<a name="ln1121">  bool done = false;</a>
<a name="ln1122">  string limit(prefix.data(), prefix.size());</a>
<a name="ln1123">  int index = limit.length() - 1;</a>
<a name="ln1124">  while (!done &amp;&amp; index &gt;= 0) {</a>
<a name="ln1125">    if (limit[index] == 255) {</a>
<a name="ln1126">      limit.erase(index);</a>
<a name="ln1127">      index--;</a>
<a name="ln1128">    } else {</a>
<a name="ln1129">      limit[index]++;</a>
<a name="ln1130">      done = true;</a>
<a name="ln1131">    }</a>
<a name="ln1132">  }</a>
<a name="ln1133">  if (!done) {</a>
<a name="ln1134">    return &quot;&quot;;</a>
<a name="ln1135">  } else {</a>
<a name="ln1136">    return limit;</a>
<a name="ln1137">  }</a>
<a name="ln1138">}</a>
<a name="ln1139"> </a>
<a name="ln1140">string ImmediateSuccessor(const GStringPiece&amp; s) {</a>
<a name="ln1141">  // Return the input string, with an additional NUL byte appended.</a>
<a name="ln1142">  string out;</a>
<a name="ln1143">  out.reserve(s.size() + 1);</a>
<a name="ln1144">  out.append(s.data(), s.size());</a>
<a name="ln1145">  out.push_back('\0');</a>
<a name="ln1146">  return out;</a>
<a name="ln1147">}</a>
<a name="ln1148"> </a>
<a name="ln1149">void FindShortestSeparator(const GStringPiece&amp; start,</a>
<a name="ln1150">                           const GStringPiece&amp; limit,</a>
<a name="ln1151">                           string* separator) {</a>
<a name="ln1152">  // Find length of common prefix</a>
<a name="ln1153">  size_t min_length = min(start.size(), limit.size());</a>
<a name="ln1154">  size_t diff_index = 0;</a>
<a name="ln1155">  while ((diff_index &lt; min_length) &amp;&amp;</a>
<a name="ln1156">         (start[diff_index] == limit[diff_index])) {</a>
<a name="ln1157">    diff_index++;</a>
<a name="ln1158">  }</a>
<a name="ln1159"> </a>
<a name="ln1160">  if (diff_index &gt;= min_length) {</a>
<a name="ln1161">    // Handle the case where either string is a prefix of the other</a>
<a name="ln1162">    // string, or both strings are identical.</a>
<a name="ln1163">    start.CopyToString(separator);</a>
<a name="ln1164">    return;</a>
<a name="ln1165">  }</a>
<a name="ln1166"> </a>
<a name="ln1167">  if (diff_index+1 == start.size()) {</a>
<a name="ln1168">    // If the first difference is in the last character, do not bother</a>
<a name="ln1169">    // incrementing that character since the separator will be no</a>
<a name="ln1170">    // shorter than &quot;start&quot;.</a>
<a name="ln1171">    start.CopyToString(separator);</a>
<a name="ln1172">    return;</a>
<a name="ln1173">  }</a>
<a name="ln1174"> </a>
<a name="ln1175">  if (start[diff_index] == 0xff) {</a>
<a name="ln1176">    // Avoid overflow when incrementing start[diff_index]</a>
<a name="ln1177">    start.CopyToString(separator);</a>
<a name="ln1178">    return;</a>
<a name="ln1179">  }</a>
<a name="ln1180"> </a>
<a name="ln1181">  separator-&gt;assign(start.data(), diff_index);</a>
<a name="ln1182">  separator-&gt;push_back(start[diff_index] + 1);</a>
<a name="ln1183">  if (*separator &gt;= limit) {</a>
<a name="ln1184">    // Never pick a separator that causes confusion with &quot;limit&quot;</a>
<a name="ln1185">    start.CopyToString(separator);</a>
<a name="ln1186">  }</a>
<a name="ln1187">}</a>
<a name="ln1188"> </a>
<a name="ln1189">int SafeSnprintf(char *str, size_t size, const char *format, ...) {</a>
<a name="ln1190">  va_list printargs;</a>
<a name="ln1191">  va_start(printargs, format);</a>
<a name="ln1192">  int ncw = vsnprintf(str, size, format, printargs);</a>
<a name="ln1193">  va_end(printargs);</a>
<a name="ln1194">  return (ncw &lt; size &amp;&amp; ncw &gt;= 0) ? ncw : 0;</a>
<a name="ln1195">}</a>
<a name="ln1196"> </a>
<a name="ln1197">bool GetlineFromStdioFile(FILE* file, string* str, char delim) {</a>
<a name="ln1198">  str-&gt;erase();</a>
<a name="ln1199">  while (true) {</a>
<a name="ln1200">    if (feof(file) || ferror(file)) {</a>
<a name="ln1201">      return false;</a>
<a name="ln1202">    }</a>
<a name="ln1203">    int c = getc(file);</a>
<a name="ln1204">    if (c == EOF) return false;</a>
<a name="ln1205">    if (c == delim) return true;</a>
<a name="ln1206">    str-&gt;push_back(c);</a>
<a name="ln1207">  }</a>
<a name="ln1208">}</a>
<a name="ln1209"> </a>
<a name="ln1210">namespace {</a>
<a name="ln1211"> </a>
<a name="ln1212">template &lt;typename CHAR&gt;</a>
<a name="ln1213">size_t lcpyT(CHAR* dst, const CHAR* src, size_t dst_size) {</a>
<a name="ln1214">  for (size_t i = 0; i &lt; dst_size; ++i) {</a>
<a name="ln1215">    if ((dst[i] = src[i]) == 0)  // We hit and copied the terminating NULL.</a>
<a name="ln1216">      return i;</a>
<a name="ln1217">  }</a>
<a name="ln1218"> </a>
<a name="ln1219">  // We were left off at dst_size.  We over copied 1 byte.  Null terminate.</a>
<a name="ln1220">  if (dst_size != 0)</a>
<a name="ln1221">    dst[dst_size - 1] = 0;</a>
<a name="ln1222"> </a>
<a name="ln1223">  // Count the rest of the |src|, and return it's length in characters.</a>
<a name="ln1224">  while (src[dst_size]) ++dst_size;</a>
<a name="ln1225">  return dst_size;</a>
<a name="ln1226">}</a>
<a name="ln1227"> </a>
<a name="ln1228">}  // namespace</a>
<a name="ln1229"> </a>
<a name="ln1230">size_t strings::strlcpy(char* dst, const char* src, size_t dst_size) {</a>
<a name="ln1231">  return lcpyT&lt;char&gt;(dst, src, dst_size);</a>
<a name="ln1232">}</a>

</code></pre>
<div class="balloon" rel="255"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="256"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1004/" target="_blank">V1004</a> The 's' pointer was used unsafely after it was verified against nullptr. Check lines: 255, 256.</p></div>
<div class="balloon" rel="727"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="746"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1004/" target="_blank">V1004</a> The 'end_ptr' pointer was used unsafely after it was verified against nullptr. Check lines: 727, 746.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
