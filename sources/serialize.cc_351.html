
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>serialize.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Copyright 2003, Google Inc.  All rights reserved.</a>
<a name="ln2">//</a>
<a name="ln3">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln4">//</a>
<a name="ln5">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln6">//</a>
<a name="ln7">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln8">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln9">//</a>
<a name="ln10">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln11">//</a>
<a name="ln12">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln13">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln14">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln15">// under the License.</a>
<a name="ln16">//</a>
<a name="ln17"> </a>
<a name="ln18">#include &quot;yb/gutil/strings/serialize.h&quot;</a>
<a name="ln19"> </a>
<a name="ln20">#include &lt;stddef.h&gt;</a>
<a name="ln21">#include &lt;stdlib.h&gt;</a>
<a name="ln22">#include &lt;ext/hash_map&gt;</a>
<a name="ln23">using __gnu_cxx::hash;</a>
<a name="ln24">using __gnu_cxx::hash_map;</a>
<a name="ln25">#include &lt;string&gt;</a>
<a name="ln26">using std::string;</a>
<a name="ln27">#include &lt;utility&gt;</a>
<a name="ln28">using std::make_pair;</a>
<a name="ln29">using std::pair;</a>
<a name="ln30">#include &lt;vector&gt;</a>
<a name="ln31">using std::vector;</a>
<a name="ln32"> </a>
<a name="ln33">#include &quot;yb/gutil/casts.h&quot;</a>
<a name="ln34">#include &quot;yb/gutil/integral_types.h&quot;</a>
<a name="ln35">#include &quot;yb/gutil/stringprintf.h&quot;</a>
<a name="ln36">#include &quot;yb/gutil/strtoint.h&quot;</a>
<a name="ln37">#include &quot;yb/gutil/strings/join.h&quot;</a>
<a name="ln38">#include &quot;yb/gutil/strings/split.h&quot;</a>
<a name="ln39">#include &quot;yb/gutil/hash/hash.h&quot;</a>
<a name="ln40"> </a>
<a name="ln41">// Convert a uint32 to a 4-byte string.</a>
<a name="ln42">string Uint32ToKey(uint32 u32) {</a>
<a name="ln43">  string key;</a>
<a name="ln44">  KeyFromUint32(u32, &amp;key);</a>
<a name="ln45">  return key;</a>
<a name="ln46">}</a>
<a name="ln47"> </a>
<a name="ln48">string Uint64ToKey(uint64 fp) {</a>
<a name="ln49">  string key;</a>
<a name="ln50">  KeyFromUint64(fp, &amp;key);</a>
<a name="ln51">  return key;</a>
<a name="ln52">}</a>
<a name="ln53"> </a>
<a name="ln54">// Convert a uint128 to a 16-byte string.</a>
<a name="ln55">string Uint128ToKey(uint128 u128) {</a>
<a name="ln56">  string key;</a>
<a name="ln57">  KeyFromUint128(u128, &amp;key);</a>
<a name="ln58">  return key;</a>
<a name="ln59">}</a>
<a name="ln60"> </a>
<a name="ln61">// Converts int32 to a 4-byte string key</a>
<a name="ln62">// NOTE: Lexicographic ordering of the resulting strings does not in</a>
<a name="ln63">// general correspond to any natural ordering of the corresponding</a>
<a name="ln64">// integers. For non-negative inputs, lexicographic ordering of the</a>
<a name="ln65">// resulting strings corresponds to increasing ordering of the</a>
<a name="ln66">// integers. However, negative inputs are sorted *after* the non-negative</a>
<a name="ln67">// inputs. To obtain keys such that lexicographic ordering corresponds</a>
<a name="ln68">// to the natural total order on the integers, use OrderedStringFromInt32()</a>
<a name="ln69">// or ReverseOrderedStringFromInt32() instead.</a>
<a name="ln70">void KeyFromInt32(int32 i32, string* key) {</a>
<a name="ln71">  // TODO(user): Redefine using bit_cast&lt;&gt; and KeyFromUint32()?</a>
<a name="ln72">  key-&gt;resize(sizeof(i32));</a>
<a name="ln73">  for (int i = sizeof(i32) - 1; i &gt;= 0; --i) {</a>
<a name="ln74">    (*key)[i] = i32 &amp; 0xff;</a>
<a name="ln75">    i32  = (i32 &gt;&gt; 8);</a>
<a name="ln76">  }</a>
<a name="ln77">}</a>
<a name="ln78"> </a>
<a name="ln79">// Converts a 4-byte string key (typically generated by KeyFromInt32)</a>
<a name="ln80">// into an int32 value</a>
<a name="ln81">int32 KeyToInt32(const GStringPiece&amp; key) {</a>
<a name="ln82">  int32 i32 = 0;</a>
<a name="ln83">  CHECK_EQ(key.size(), sizeof(i32));</a>
<a name="ln84">  for (size_t i = 0; i &lt; sizeof(i32); ++i) {</a>
<a name="ln85">    i32 = (i32 &lt;&lt; 8) | static_cast&lt;unsigned char&gt;(key[i]);</a>
<a name="ln86">  }</a>
<a name="ln87">  return i32;</a>
<a name="ln88">}</a>
<a name="ln89"> </a>
<a name="ln90">// Converts a double value to an 8-byte string key, so that</a>
<a name="ln91">// the string keys sort in the same order as the original double values.</a>
<a name="ln92">void KeyFromDouble(double x, string* key) {</a>
<a name="ln93">  uint64 n = bit_cast&lt;uint64&gt;(x);</a>
<a name="ln94">  // IEEE standard 754 floating point representation</a>
<a name="ln95">  //   [sign-bit] [exponent] [mantissa]</a>
<a name="ln96">  //</a>
<a name="ln97">  // Let &quot;a&quot;, &quot;b&quot; be two double values, and F(.) be following</a>
<a name="ln98">  // transformation.  We have:</a>
<a name="ln99">  //   If 0 &lt; a &lt; b:</a>
<a name="ln100">  //     0x80000000ULL &lt; uint64(F(a)) &lt; uint64(F(b))</a>
<a name="ln101">  //   If a == -0.0, b == +0.0:</a>
<a name="ln102">  //     uint64(F(-0.0)) == uint64(F(+0.0)) = 0x80000000ULL</a>
<a name="ln103">  //   If a &lt; b &lt; 0:</a>
<a name="ln104">  //     uint64(F(a)) &lt; uint64(F(b)) &lt; 0x80000000ULL</a>
<a name="ln105">  const uint64 sign_bit = GG_ULONGLONG(1) &lt;&lt; 63;</a>
<a name="ln106">  if ((n &amp; sign_bit) == 0) {</a>
<a name="ln107">    n += sign_bit;</a>
<a name="ln108">  } else {</a>
<a name="ln109">    n = -n;</a>
<a name="ln110">  }</a>
<a name="ln111">  KeyFromUint64(n, key);</a>
<a name="ln112">}</a>
<a name="ln113"> </a>
<a name="ln114">// Version of KeyFromDouble that returns the key.</a>
<a name="ln115">string DoubleToKey(double x) {</a>
<a name="ln116">  string key;</a>
<a name="ln117">  KeyFromDouble(x, &amp;key);</a>
<a name="ln118">  return key;</a>
<a name="ln119">}</a>
<a name="ln120"> </a>
<a name="ln121">// Converts key generated by KeyFromDouble() back to double.</a>
<a name="ln122">double KeyToDouble(const GStringPiece&amp; key) {</a>
<a name="ln123">  int64 n = KeyToUint64(key);</a>
<a name="ln124">  if (n &amp; (GG_ULONGLONG(1) &lt;&lt; 63))</a>
<a name="ln125">    n -= (GG_ULONGLONG(1) &lt;&lt; 63);</a>
<a name="ln126">  else</a>
<a name="ln127">    n = -n;</a>
<a name="ln128">  return bit_cast&lt;double&gt;(n);</a>
<a name="ln129">}</a>
<a name="ln130"> </a>
<a name="ln131">// Converts int32 to a 4-byte string key such that lexicographic</a>
<a name="ln132">// ordering of strings is equivalent to sorting in increasing order by</a>
<a name="ln133">// integer values. This can be useful when constructing secondary</a>
<a name="ln134">void OrderedStringFromInt32(int32 i32, string* key) {</a>
<a name="ln135">  uint32 ui32 = static_cast&lt;uint32&gt;(i32) ^ 0x80000000;</a>
<a name="ln136">  key-&gt;resize(sizeof ui32);</a>
<a name="ln137">  for ( int i = (sizeof ui32) - 1; i &gt;= 0; --i ) {</a>
<a name="ln138">    (*key)[i] = ui32 &amp; 0xff;</a>
<a name="ln139">    ui32  = (ui32 &gt;&gt; 8);</a>
<a name="ln140">  }</a>
<a name="ln141">}</a>
<a name="ln142"> </a>
<a name="ln143">string Int32ToOrderedString(int32 i32) {</a>
<a name="ln144">  string key;</a>
<a name="ln145">  OrderedStringFromInt32(i32, &amp;key);</a>
<a name="ln146">  return key;</a>
<a name="ln147">}</a>
<a name="ln148"> </a>
<a name="ln149">// The inverse of the above function.</a>
<a name="ln150">int32 OrderedStringToInt32(const GStringPiece&amp; key) {</a>
<a name="ln151">  uint32 ui32 = 0;</a>
<a name="ln152">  CHECK(key.size() == sizeof ui32);</a>
<a name="ln153">  for ( int i = 0; i &lt; sizeof ui32; ++i ) {</a>
<a name="ln154">    ui32 = (ui32 &lt;&lt; 8);</a>
<a name="ln155">    ui32 = ui32 | static_cast&lt;unsigned char&gt;(key[i]);</a>
<a name="ln156">  }</a>
<a name="ln157">  return static_cast&lt;int32&gt;(ui32 ^ 0x80000000);</a>
<a name="ln158">}</a>
<a name="ln159"> </a>
<a name="ln160">// Converts int64 to a 8-byte string key such that lexicographic</a>
<a name="ln161">// ordering of strings is equivalent to sorting in increasing order by</a>
<a name="ln162">// integer values.</a>
<a name="ln163">void OrderedStringFromInt64(int64 i64, string* key) {</a>
<a name="ln164">  uint64 ui64 = static_cast&lt;uint64&gt;(i64) ^ (GG_ULONGLONG(1) &lt;&lt; 63);</a>
<a name="ln165">  key-&gt;resize(sizeof ui64);</a>
<a name="ln166">  for ( int i = (sizeof ui64) - 1; i &gt;= 0; --i ) {</a>
<a name="ln167">    (*key)[i] = ui64 &amp; 0xff;</a>
<a name="ln168">    ui64  = (ui64 &gt;&gt; 8);</a>
<a name="ln169">  }</a>
<a name="ln170">}</a>
<a name="ln171"> </a>
<a name="ln172">string Int64ToOrderedString(int64 i64) {</a>
<a name="ln173">  string key;</a>
<a name="ln174">  OrderedStringFromInt64(i64, &amp;key);</a>
<a name="ln175">  return key;</a>
<a name="ln176">}</a>
<a name="ln177"> </a>
<a name="ln178">// The inverse of the above function.</a>
<a name="ln179">int64 OrderedStringToInt64(const GStringPiece&amp; key) {</a>
<a name="ln180">  uint64 ui64 = 0;</a>
<a name="ln181">  CHECK(key.size() == sizeof ui64);</a>
<a name="ln182">  for ( int i = 0; i &lt; sizeof ui64; ++i ) {</a>
<a name="ln183">    ui64 = (ui64 &lt;&lt; 8);</a>
<a name="ln184">    ui64 = ui64 | static_cast&lt;unsigned char&gt;(key[i]);</a>
<a name="ln185">  }</a>
<a name="ln186">  return static_cast&lt;int64&gt;(ui64 ^ (GG_ULONGLONG(1) &lt;&lt; 63));</a>
<a name="ln187">}</a>
<a name="ln188"> </a>
<a name="ln189">// Converts int32 to a 4-byte string key such that lexicographic</a>
<a name="ln190">// ordering of strings is equivalent to sorting in decreasing order</a>
<a name="ln191">// by integer values. This can be useful when constructing secondary</a>
<a name="ln192">void ReverseOrderedStringFromInt32(int32 i32, string* key) {</a>
<a name="ln193">  // ~ is like -, but works even for INT_MIN. (-INT_MIN == INT_MIN,</a>
<a name="ln194">  // but ~x = -x - 1, so ~INT_MIN = -INT_MIN - 1 = INT_MIN - 1 = INT_MAX).</a>
<a name="ln195">  OrderedStringFromInt32(~i32, key);</a>
<a name="ln196">}</a>
<a name="ln197"> </a>
<a name="ln198">string Int32ToReverseOrderedString(int32 i32) {</a>
<a name="ln199">  string key;</a>
<a name="ln200">  ReverseOrderedStringFromInt32(i32, &amp;key);</a>
<a name="ln201">  return key;</a>
<a name="ln202">}</a>
<a name="ln203"> </a>
<a name="ln204">// The inverse of the above function.</a>
<a name="ln205">int32 ReverseOrderedStringToInt32(const GStringPiece&amp; key) {</a>
<a name="ln206">  return ~OrderedStringToInt32(key);</a>
<a name="ln207">}</a>
<a name="ln208"> </a>
<a name="ln209">// Converts int64 to an 8-byte string key such that lexicographic</a>
<a name="ln210">// ordering of strings is equivalent to sorting in decreasing order</a>
<a name="ln211">// by integer values. This can be useful when constructing secondary</a>
<a name="ln212">void ReverseOrderedStringFromInt64(int64 i64, string* key) {</a>
<a name="ln213">  return OrderedStringFromInt64(~i64, key);</a>
<a name="ln214">}</a>
<a name="ln215"> </a>
<a name="ln216">string Int64ToReverseOrderedString(int64 i64) {</a>
<a name="ln217">  string key;</a>
<a name="ln218">  ReverseOrderedStringFromInt64(i64, &amp;key);</a>
<a name="ln219">  return key;</a>
<a name="ln220">}</a>
<a name="ln221"> </a>
<a name="ln222">// The inverse of the above function.</a>
<a name="ln223">int64 ReverseOrderedStringToInt64(const GStringPiece&amp; key) {</a>
<a name="ln224">  return ~OrderedStringToInt64(key);</a>
<a name="ln225">}</a>
<a name="ln226"> </a>
<a name="ln227">// --------------------------------------------------------------------------</a>
<a name="ln228">// DictionaryInt32Encode</a>
<a name="ln229">// DictionaryInt64Encode</a>
<a name="ln230">// DictionaryDoubleEncode</a>
<a name="ln231">// DictionaryInt32Decode</a>
<a name="ln232">// DictionaryInt64Decode</a>
<a name="ln233">// DictionaryDoubleDecode</a>
<a name="ln234">//   Routines to serialize/unserialize simple dictionaries</a>
<a name="ln235">//   (string-&gt;T hashmaps). We use ':' to separate keys and values,</a>
<a name="ln236">//   and commas to separate entries.</a>
<a name="ln237">// --------------------------------------------------------------------------</a>
<a name="ln238"> </a>
<a name="ln239">string DictionaryInt32Encode(const hash_map&lt;string, int32&gt;* dictionary) {</a>
<a name="ln240">  vector&lt;string&gt; entries;</a>
<a name="ln241">  for (const auto&amp; entry : *dictionary) {</a>
<a name="ln242">    entries.push_back(StringPrintf(&quot;%s:%d&quot;, entry.first.c_str(), entry.second));</a>
<a name="ln243">  }</a>
<a name="ln244"> </a>
<a name="ln245">  string result;</a>
<a name="ln246">  JoinStrings(entries, &quot;,&quot;, &amp;result);</a>
<a name="ln247">  return result;</a>
<a name="ln248">}</a>
<a name="ln249"> </a>
<a name="ln250">string DictionaryInt64Encode(const hash_map&lt;string, int64&gt;* dictionary) {</a>
<a name="ln251">  vector&lt;string&gt; entries;</a>
<a name="ln252">  for (const auto&amp; entry : *dictionary) {</a>
<a name="ln253">    entries.push_back(StringPrintf(&quot;%s:%&quot; PRId64,</a>
<a name="ln254">                                   entry.first.c_str(), entry.second));</a>
<a name="ln255">  }</a>
<a name="ln256"> </a>
<a name="ln257">  string result;</a>
<a name="ln258">  JoinStrings(entries, &quot;,&quot;, &amp;result);</a>
<a name="ln259">  return result;</a>
<a name="ln260">}</a>
<a name="ln261"> </a>
<a name="ln262">string DictionaryDoubleEncode(const hash_map&lt;string, double&gt;* dictionary) {</a>
<a name="ln263">  vector&lt;string&gt; entries;</a>
<a name="ln264">  for (const auto&amp; entry : *dictionary) {</a>
<a name="ln265">    entries.push_back(StringPrintf(&quot;%s:%g&quot;, entry.first.c_str(), entry.second));</a>
<a name="ln266">  }</a>
<a name="ln267"> </a>
<a name="ln268">  string result;</a>
<a name="ln269">  JoinStrings(entries, &quot;,&quot;, &amp;result);</a>
<a name="ln270">  return result;</a>
<a name="ln271">}</a>
<a name="ln272"> </a>
<a name="ln273">bool DictionaryParse(const string&amp; encoded_str,</a>
<a name="ln274">                     vector&lt;pair&lt;string, string&gt; &gt;* items) {</a>
<a name="ln275">  vector&lt;string&gt; entries;</a>
<a name="ln276">  SplitStringUsing(encoded_str, &quot;,&quot;, &amp;entries);</a>
<a name="ln277">  for (const auto&amp; entry : entries) {</a>
<a name="ln278">    vector&lt;string&gt; fields;</a>
<a name="ln279">    SplitStringAllowEmpty(entry, &quot;:&quot;, &amp;fields);</a>
<a name="ln280">    if (fields.size() != 2)  // parsing error</a>
<a name="ln281">      return false;</a>
<a name="ln282">    items-&gt;push_back(make_pair(fields[0], fields[1]));</a>
<a name="ln283">  }</a>
<a name="ln284">  return true;</a>
<a name="ln285">}</a>
<a name="ln286"> </a>
<a name="ln287">bool DictionaryInt32Decode(hash_map&lt;string, int32&gt;* dictionary,</a>
<a name="ln288">                           const string&amp; encoded_str) {</a>
<a name="ln289">  vector&lt;pair&lt;string, string&gt; &gt; items;</a>
<a name="ln290">  if (!DictionaryParse(encoded_str, &amp;items))</a>
<a name="ln291">    return false;</a>
<a name="ln292"> </a>
<a name="ln293">  dictionary-&gt;clear();</a>
<a name="ln294">  for (const auto&amp; item : items) {</a>
<a name="ln295">    char *error = nullptr;</a>
<a name="ln296">    const int32 value = strto32(item.second.c_str(), &amp;error, 0);</a>
<a name="ln297">    if (error == item.second.c_str() || *error != '\0') {</a>
<a name="ln298">      // parsing error</a>
<a name="ln299">      return false;</a>
<a name="ln300">    }</a>
<a name="ln301">    (*dictionary)[item.first] = value;</a>
<a name="ln302">  }</a>
<a name="ln303">  return true;</a>
<a name="ln304">}</a>
<a name="ln305"> </a>
<a name="ln306">bool DictionaryInt64Decode(hash_map&lt;string, int64&gt;* dictionary,</a>
<a name="ln307">                           const string&amp; encoded_str) {</a>
<a name="ln308">  vector&lt;pair&lt;string, string&gt; &gt; items;</a>
<a name="ln309">  if (!DictionaryParse(encoded_str, &amp;items))</a>
<a name="ln310">    return false;</a>
<a name="ln311"> </a>
<a name="ln312">  dictionary-&gt;clear();</a>
<a name="ln313">  for (const auto&amp; item : items) {</a>
<a name="ln314">    char *error = nullptr;</a>
<a name="ln315">    const int64 value = strto64(item.second.c_str(), &amp;error, 0);</a>
<a name="ln316">    if (error == item.second.c_str() || *error != '\0')  {</a>
<a name="ln317">      // parsing error</a>
<a name="ln318">      return false;</a>
<a name="ln319">    }</a>
<a name="ln320">    (*dictionary)[item.first] = value;</a>
<a name="ln321">  }</a>
<a name="ln322">  return true;</a>
<a name="ln323">}</a>
<a name="ln324"> </a>
<a name="ln325"> </a>
<a name="ln326">bool DictionaryDoubleDecode(hash_map&lt;string, double&gt;* dictionary,</a>
<a name="ln327">                            const string&amp; encoded_str) {</a>
<a name="ln328">  vector&lt;pair&lt;string, string&gt; &gt; items;</a>
<a name="ln329">  if (!DictionaryParse(encoded_str, &amp;items))</a>
<a name="ln330">    return false;</a>
<a name="ln331"> </a>
<a name="ln332">  dictionary-&gt;clear();</a>
<a name="ln333">  for (const auto&amp; item : items) {</a>
<a name="ln334">    char *error = nullptr;</a>
<a name="ln335">    const double value = strtod(item.second.c_str(), &amp;error);</a>
<a name="ln336">    if (error == item.second.c_str() || *error != '\0') {</a>
<a name="ln337">      // parsing error</a>
<a name="ln338">      return false;</a>
<a name="ln339">    }</a>
<a name="ln340">    (*dictionary)[item.first] = value;</a>
<a name="ln341">  }</a>
<a name="ln342">  return true;</a>
<a name="ln343">}</a>

</code></pre>
<div class="balloon" rel="152"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="181"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
