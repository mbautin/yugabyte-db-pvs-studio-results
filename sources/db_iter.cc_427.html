
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>db_iter.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//  Copyright (c) 2011-present, Facebook, Inc.  All rights reserved.</a>
<a name="ln2">//  This source code is licensed under the BSD-style license found in the</a>
<a name="ln3">//  LICENSE file in the root directory of this source tree. An additional grant</a>
<a name="ln4">//  of patent rights can be found in the PATENTS file in the same directory.</a>
<a name="ln5">//</a>
<a name="ln6">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln7">//</a>
<a name="ln8">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln9">//</a>
<a name="ln10">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln11">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln12">//</a>
<a name="ln13">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln14">//</a>
<a name="ln15">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln16">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln17">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln18">// under the License.</a>
<a name="ln19">//</a>
<a name="ln20">// Copyright (c) 2011 The LevelDB Authors. All rights reserved.</a>
<a name="ln21">// Use of this source code is governed by a BSD-style license that can be</a>
<a name="ln22">// found in the LICENSE file. See the AUTHORS file for names of contributors.</a>
<a name="ln23"> </a>
<a name="ln24">#include &quot;yb/rocksdb/db/db_iter.h&quot;</a>
<a name="ln25">#include &lt;stdexcept&gt;</a>
<a name="ln26">#include &lt;deque&gt;</a>
<a name="ln27">#include &lt;string&gt;</a>
<a name="ln28">#include &lt;limits&gt;</a>
<a name="ln29"> </a>
<a name="ln30">#include &quot;yb/rocksdb/db/dbformat.h&quot;</a>
<a name="ln31">#include &quot;yb/rocksdb/db/filename.h&quot;</a>
<a name="ln32">#include &quot;yb/rocksdb/port/port.h&quot;</a>
<a name="ln33">#include &quot;yb/rocksdb/env.h&quot;</a>
<a name="ln34">#include &quot;yb/rocksdb/iterator.h&quot;</a>
<a name="ln35">#include &quot;yb/rocksdb/merge_operator.h&quot;</a>
<a name="ln36">#include &quot;yb/rocksdb/options.h&quot;</a>
<a name="ln37">#include &quot;yb/rocksdb/table/internal_iterator.h&quot;</a>
<a name="ln38">#include &quot;yb/rocksdb/util/arena.h&quot;</a>
<a name="ln39">#include &quot;yb/rocksdb/util/logging.h&quot;</a>
<a name="ln40">#include &quot;yb/rocksdb/util/mutexlock.h&quot;</a>
<a name="ln41">#include &quot;yb/rocksdb/util/perf_context_imp.h&quot;</a>
<a name="ln42">#include &quot;yb/util/string_util.h&quot;</a>
<a name="ln43"> </a>
<a name="ln44">namespace rocksdb {</a>
<a name="ln45"> </a>
<a name="ln46">#if 0</a>
<a name="ln47">static void DumpInternalIter(Iterator* iter) {</a>
<a name="ln48">  for (iter-&gt;SeekToFirst(); iter-&gt;Valid(); iter-&gt;Next()) {</a>
<a name="ln49">    ParsedInternalKey k;</a>
<a name="ln50">    if (!ParseInternalKey(iter-&gt;key(), &amp;k)) {</a>
<a name="ln51">      fprintf(stderr, &quot;Corrupt '%s'\n&quot;, EscapeString(iter-&gt;key()).c_str());</a>
<a name="ln52">    } else {</a>
<a name="ln53">      fprintf(stderr, &quot;@ '%s'\n&quot;, k.DebugString().c_str());</a>
<a name="ln54">    }</a>
<a name="ln55">  }</a>
<a name="ln56">}</a>
<a name="ln57">#endif</a>
<a name="ln58"> </a>
<a name="ln59">// Memtables and sstables that make the DB representation contain</a>
<a name="ln60">// (userkey,seq,type) =&gt; uservalue entries.  DBIter</a>
<a name="ln61">// combines multiple entries for the same userkey found in the DB</a>
<a name="ln62">// representation into a single entry while accounting for sequence</a>
<a name="ln63">// numbers, deletion markers, overwrites, etc.</a>
<a name="ln64">class DBIter: public Iterator {</a>
<a name="ln65"> public:</a>
<a name="ln66">  // The following is grossly complicated. TODO: clean it up</a>
<a name="ln67">  // Which direction is the iterator currently moving?</a>
<a name="ln68">  // (1) When moving forward, the internal iterator is positioned at</a>
<a name="ln69">  //     the exact entry that yields this-&gt;key(), this-&gt;value()</a>
<a name="ln70">  // (2) When moving backwards, the internal iterator is positioned</a>
<a name="ln71">  //     just before all entries whose user key == this-&gt;key().</a>
<a name="ln72">  enum Direction {</a>
<a name="ln73">    kForward,</a>
<a name="ln74">    kReverse</a>
<a name="ln75">  };</a>
<a name="ln76"> </a>
<a name="ln77">  DBIter(Env* env, const ImmutableCFOptions&amp; ioptions, const Comparator* cmp,</a>
<a name="ln78">         InternalIterator* iter, SequenceNumber s, bool arena_mode,</a>
<a name="ln79">         uint64_t max_sequential_skip_in_iterations, uint64_t version_number,</a>
<a name="ln80">         const Slice* iterate_upper_bound = nullptr,</a>
<a name="ln81">         bool prefix_same_as_start = false)</a>
<a name="ln82">      : arena_mode_(arena_mode),</a>
<a name="ln83">        env_(env),</a>
<a name="ln84">        logger_(ioptions.info_log),</a>
<a name="ln85">        user_comparator_(cmp),</a>
<a name="ln86">        user_merge_operator_(ioptions.merge_operator),</a>
<a name="ln87">        iter_(iter),</a>
<a name="ln88">        sequence_(s),</a>
<a name="ln89">        direction_(kForward),</a>
<a name="ln90">        valid_(false),</a>
<a name="ln91">        current_entry_is_merged_(false),</a>
<a name="ln92">        statistics_(ioptions.statistics),</a>
<a name="ln93">        version_number_(version_number),</a>
<a name="ln94">        iterate_upper_bound_(iterate_upper_bound),</a>
<a name="ln95">        prefix_same_as_start_(prefix_same_as_start),</a>
<a name="ln96">        iter_pinned_(false) {</a>
<a name="ln97">    RecordTick(statistics_, NO_ITERATORS);</a>
<a name="ln98">    prefix_extractor_ = ioptions.prefix_extractor;</a>
<a name="ln99">    max_skip_ = max_sequential_skip_in_iterations;</a>
<a name="ln100">  }</a>
<a name="ln101">  virtual ~DBIter() {</a>
<a name="ln102">    RecordTick(statistics_, NO_ITERATORS, -1);</a>
<a name="ln103">    if (!arena_mode_) {</a>
<a name="ln104">      delete iter_;</a>
<a name="ln105">    } else {</a>
<a name="ln106">      iter_-&gt;~InternalIterator();</a>
<a name="ln107">    }</a>
<a name="ln108">  }</a>
<a name="ln109">  virtual void SetIter(InternalIterator* iter) {</a>
<a name="ln110">    assert(iter_ == nullptr);</a>
<a name="ln111">    iter_ = iter;</a>
<a name="ln112">    if (iter_ &amp;&amp; iter_pinned_) {</a>
<a name="ln113">      CHECK_OK(iter_-&gt;PinData());</a>
<a name="ln114">    }</a>
<a name="ln115">  }</a>
<a name="ln116">  bool Valid() const override { return valid_; }</a>
<a name="ln117">  Slice key() const override {</a>
<a name="ln118">    assert(valid_);</a>
<a name="ln119">    return saved_key_.GetKey();</a>
<a name="ln120">  }</a>
<a name="ln121">  Slice value() const override {</a>
<a name="ln122">    assert(valid_);</a>
<a name="ln123">    return (direction_ == kForward &amp;&amp; !current_entry_is_merged_) ?</a>
<a name="ln124">      iter_-&gt;value() : saved_value_;</a>
<a name="ln125">  }</a>
<a name="ln126">  Status status() const override {</a>
<a name="ln127">    if (status_.ok()) {</a>
<a name="ln128">      return iter_-&gt;status();</a>
<a name="ln129">    } else {</a>
<a name="ln130">      return status_;</a>
<a name="ln131">    }</a>
<a name="ln132">  }</a>
<a name="ln133">  virtual Status PinData() {</a>
<a name="ln134">    Status s;</a>
<a name="ln135">    if (iter_) {</a>
<a name="ln136">      s = iter_-&gt;PinData();</a>
<a name="ln137">    }</a>
<a name="ln138">    if (s.ok()) {</a>
<a name="ln139">      // Even if iter_ is nullptr, we set iter_pinned_ to true so that when</a>
<a name="ln140">      // iter_ is updated using SetIter, we Pin it.</a>
<a name="ln141">      iter_pinned_ = true;</a>
<a name="ln142">    }</a>
<a name="ln143">    return s;</a>
<a name="ln144">  }</a>
<a name="ln145">  virtual Status ReleasePinnedData() {</a>
<a name="ln146">    Status s;</a>
<a name="ln147">    if (iter_) {</a>
<a name="ln148">      s = iter_-&gt;ReleasePinnedData();</a>
<a name="ln149">    }</a>
<a name="ln150">    if (s.ok()) {</a>
<a name="ln151">      iter_pinned_ = false;</a>
<a name="ln152">    }</a>
<a name="ln153">    return s;</a>
<a name="ln154">  }</a>
<a name="ln155"> </a>
<a name="ln156">  virtual Status GetProperty(std::string prop_name,</a>
<a name="ln157">                             std::string* prop) override {</a>
<a name="ln158">    if (prop == nullptr) {</a>
<a name="ln159">      return STATUS(InvalidArgument, &quot;prop is nullptr&quot;);</a>
<a name="ln160">    }</a>
<a name="ln161">    if (prop_name == &quot;rocksdb.iterator.super-version-number&quot;) {</a>
<a name="ln162">      // First try to pass the value returned from inner iterator.</a>
<a name="ln163">      if (!iter_-&gt;GetProperty(prop_name, prop).ok()) {</a>
<a name="ln164">        *prop = ToString(version_number_);</a>
<a name="ln165">      }</a>
<a name="ln166">      return Status::OK();</a>
<a name="ln167">    } else if (prop_name == &quot;rocksdb.iterator.is-key-pinned&quot;) {</a>
<a name="ln168">      if (valid_) {</a>
<a name="ln169">        *prop = (iter_pinned_ &amp;&amp; saved_key_.IsKeyPinned()) ? &quot;1&quot; : &quot;0&quot;;</a>
<a name="ln170">      } else {</a>
<a name="ln171">        *prop = &quot;Iterator is not valid.&quot;;</a>
<a name="ln172">      }</a>
<a name="ln173">      return Status::OK();</a>
<a name="ln174">    }</a>
<a name="ln175">    return STATUS(InvalidArgument, &quot;Undentified property.&quot;);</a>
<a name="ln176">  }</a>
<a name="ln177"> </a>
<a name="ln178">  void Next() override;</a>
<a name="ln179">  void Prev() override;</a>
<a name="ln180">  void Seek(const Slice&amp; target) override;</a>
<a name="ln181">  void SeekToFirst() override;</a>
<a name="ln182">  void SeekToLast() override;</a>
<a name="ln183"> </a>
<a name="ln184">  void RevalidateAfterUpperBoundChange() override {</a>
<a name="ln185">    if (iter_-&gt;Valid() &amp;&amp; direction_ == kForward) {</a>
<a name="ln186">      valid_ = true;</a>
<a name="ln187">      FindNextUserEntry(/* skipping= */ false);</a>
<a name="ln188">    }</a>
<a name="ln189">  }</a>
<a name="ln190"> </a>
<a name="ln191"> private:</a>
<a name="ln192">  void ReverseToBackward();</a>
<a name="ln193">  void PrevInternal();</a>
<a name="ln194">  void FindParseableKey(ParsedInternalKey* ikey, Direction direction);</a>
<a name="ln195">  bool FindValueForCurrentKey();</a>
<a name="ln196">  bool FindValueForCurrentKeyUsingSeek();</a>
<a name="ln197">  void FindPrevUserKey();</a>
<a name="ln198">  void FindNextUserKey();</a>
<a name="ln199">  inline void FindNextUserEntry(bool skipping);</a>
<a name="ln200">  void FindNextUserEntryInternal(bool skipping);</a>
<a name="ln201">  bool ParseKey(ParsedInternalKey* key);</a>
<a name="ln202">  void MergeValuesNewToOld();</a>
<a name="ln203"> </a>
<a name="ln204">  inline void ClearSavedValue() {</a>
<a name="ln205">    if (saved_value_.capacity() &gt; 1048576) {</a>
<a name="ln206">      std::string empty;</a>
<a name="ln207">      swap(empty, saved_value_);</a>
<a name="ln208">    } else {</a>
<a name="ln209">      saved_value_.clear();</a>
<a name="ln210">    }</a>
<a name="ln211">  }</a>
<a name="ln212"> </a>
<a name="ln213">  const SliceTransform* prefix_extractor_;</a>
<a name="ln214">  bool arena_mode_;</a>
<a name="ln215">  Env* const env_;</a>
<a name="ln216">  Logger* logger_;</a>
<a name="ln217">  const Comparator* const user_comparator_;</a>
<a name="ln218">  const MergeOperator* const user_merge_operator_;</a>
<a name="ln219">  InternalIterator* iter_;</a>
<a name="ln220">  SequenceNumber const sequence_;</a>
<a name="ln221"> </a>
<a name="ln222">  Status status_;</a>
<a name="ln223">  IterKey saved_key_;</a>
<a name="ln224">  std::string saved_value_;</a>
<a name="ln225">  Direction direction_;</a>
<a name="ln226">  bool valid_;</a>
<a name="ln227">  bool current_entry_is_merged_;</a>
<a name="ln228">  Statistics* statistics_;</a>
<a name="ln229">  uint64_t max_skip_;</a>
<a name="ln230">  uint64_t version_number_;</a>
<a name="ln231">  const Slice* iterate_upper_bound_;</a>
<a name="ln232">  IterKey prefix_start_;</a>
<a name="ln233">  bool prefix_same_as_start_;</a>
<a name="ln234">  bool iter_pinned_;</a>
<a name="ln235">  // List of operands for merge operator.</a>
<a name="ln236">  std::deque&lt;std::string&gt; merge_operands_;</a>
<a name="ln237"> </a>
<a name="ln238">  // No copying allowed</a>
<a name="ln239">  DBIter(const DBIter&amp;);</a>
<a name="ln240">  void operator=(const DBIter&amp;);</a>
<a name="ln241">};</a>
<a name="ln242"> </a>
<a name="ln243">inline bool DBIter::ParseKey(ParsedInternalKey* ikey) {</a>
<a name="ln244">  if (!ParseInternalKey(iter_-&gt;key(), ikey)) {</a>
<a name="ln245">    status_ = STATUS(Corruption, &quot;corrupted internal key in DBIter&quot;);</a>
<a name="ln246">    RLOG(InfoLogLevel::ERROR_LEVEL,</a>
<a name="ln247">        logger_, &quot;corrupted internal key in DBIter: %s&quot;,</a>
<a name="ln248">        iter_-&gt;key().ToString(true).c_str());</a>
<a name="ln249">    return false;</a>
<a name="ln250">  } else {</a>
<a name="ln251">    return true;</a>
<a name="ln252">  }</a>
<a name="ln253">}</a>
<a name="ln254"> </a>
<a name="ln255">void DBIter::Next() {</a>
<a name="ln256">  assert(valid_);</a>
<a name="ln257"> </a>
<a name="ln258">  if (direction_ == kReverse) {</a>
<a name="ln259">    FindNextUserKey();</a>
<a name="ln260">    direction_ = kForward;</a>
<a name="ln261">    if (!iter_-&gt;Valid()) {</a>
<a name="ln262">      iter_-&gt;SeekToFirst();</a>
<a name="ln263">    }</a>
<a name="ln264">  } else if (iter_-&gt;Valid() &amp;&amp; !current_entry_is_merged_) {</a>
<a name="ln265">    // If the current value is not a merge, the iter position is the</a>
<a name="ln266">    // current key, which is already returned. We can safely issue a</a>
<a name="ln267">    // Next() without checking the current key.</a>
<a name="ln268">    // If the current key is a merge, very likely iter already points</a>
<a name="ln269">    // to the next internal position.</a>
<a name="ln270">    iter_-&gt;Next();</a>
<a name="ln271">    PERF_COUNTER_ADD(internal_key_skipped_count, 1);</a>
<a name="ln272">  }</a>
<a name="ln273"> </a>
<a name="ln274">  // Now we point to the next internal position, for both of merge and</a>
<a name="ln275">  // not merge cases.</a>
<a name="ln276">  if (!iter_-&gt;Valid()) {</a>
<a name="ln277">    valid_ = false;</a>
<a name="ln278">    return;</a>
<a name="ln279">  }</a>
<a name="ln280">  FindNextUserEntry(true /* skipping the current user key */);</a>
<a name="ln281">  if (statistics_ != nullptr) {</a>
<a name="ln282">    RecordTick(statistics_, NUMBER_DB_NEXT);</a>
<a name="ln283">    if (valid_) {</a>
<a name="ln284">      RecordTick(statistics_, NUMBER_DB_NEXT_FOUND);</a>
<a name="ln285">      RecordTick(statistics_, ITER_BYTES_READ, key().size() + value().size());</a>
<a name="ln286">    }</a>
<a name="ln287">  }</a>
<a name="ln288">  if (valid_ &amp;&amp; prefix_extractor_ &amp;&amp; prefix_same_as_start_ &amp;&amp;</a>
<a name="ln289">      prefix_extractor_-&gt;Transform(saved_key_.GetKey())</a>
<a name="ln290">              .compare(prefix_start_.GetKey()) != 0) {</a>
<a name="ln291">    valid_ = false;</a>
<a name="ln292">  }</a>
<a name="ln293">}</a>
<a name="ln294"> </a>
<a name="ln295">// PRE: saved_key_ has the current user key if skipping</a>
<a name="ln296">// POST: saved_key_ should have the next user key if valid_,</a>
<a name="ln297">//       if the current entry is a result of merge</a>
<a name="ln298">//           current_entry_is_merged_ =&gt; true</a>
<a name="ln299">//           saved_value_             =&gt; the merged value</a>
<a name="ln300">//</a>
<a name="ln301">// NOTE: In between, saved_key_ can point to a user key that has</a>
<a name="ln302">//       a delete marker</a>
<a name="ln303">inline void DBIter::FindNextUserEntry(bool skipping) {</a>
<a name="ln304">  PERF_TIMER_GUARD(find_next_user_entry_time);</a>
<a name="ln305">  FindNextUserEntryInternal(skipping);</a>
<a name="ln306">}</a>
<a name="ln307"> </a>
<a name="ln308">// Actual implementation of DBIter::FindNextUserEntry()</a>
<a name="ln309">void DBIter::FindNextUserEntryInternal(bool skipping) {</a>
<a name="ln310">  // Loop until we hit an acceptable entry to yield</a>
<a name="ln311">  assert(iter_-&gt;Valid());</a>
<a name="ln312">  assert(direction_ == kForward);</a>
<a name="ln313">  current_entry_is_merged_ = false;</a>
<a name="ln314">  uint64_t num_skipped = 0;</a>
<a name="ln315">  do {</a>
<a name="ln316">    ParsedInternalKey ikey;</a>
<a name="ln317"> </a>
<a name="ln318">    if (ParseKey(&amp;ikey)) {</a>
<a name="ln319">      if (iterate_upper_bound_ != nullptr &amp;&amp;</a>
<a name="ln320">          user_comparator_-&gt;Compare(ikey.user_key, *iterate_upper_bound_) &gt;= 0) {</a>
<a name="ln321">        break;</a>
<a name="ln322">      }</a>
<a name="ln323"> </a>
<a name="ln324">      if (ikey.sequence &lt;= sequence_) {</a>
<a name="ln325">        if (skipping &amp;&amp;</a>
<a name="ln326">           user_comparator_-&gt;Compare(ikey.user_key, saved_key_.GetKey()) &lt;= 0) {</a>
<a name="ln327">          num_skipped++;  // skip this entry</a>
<a name="ln328">          PERF_COUNTER_ADD(internal_key_skipped_count, 1);</a>
<a name="ln329">        } else {</a>
<a name="ln330">          switch (ikey.type) {</a>
<a name="ln331">            case kTypeDeletion:</a>
<a name="ln332">            case kTypeSingleDeletion:</a>
<a name="ln333">              // Arrange to skip all upcoming entries for this key since</a>
<a name="ln334">              // they are hidden by this deletion.</a>
<a name="ln335">              saved_key_.SetKey(ikey.user_key,</a>
<a name="ln336">                                !iter_-&gt;IsKeyPinned() /* copy */);</a>
<a name="ln337">              skipping = true;</a>
<a name="ln338">              num_skipped = 0;</a>
<a name="ln339">              PERF_COUNTER_ADD(internal_delete_skipped_count, 1);</a>
<a name="ln340">              break;</a>
<a name="ln341">            case kTypeValue:</a>
<a name="ln342">              valid_ = true;</a>
<a name="ln343">              saved_key_.SetKey(ikey.user_key,</a>
<a name="ln344">                                !iter_-&gt;IsKeyPinned() /* copy */);</a>
<a name="ln345">              return;</a>
<a name="ln346">            case kTypeMerge:</a>
<a name="ln347">              // By now, we are sure the current ikey is going to yield a value</a>
<a name="ln348">              saved_key_.SetKey(ikey.user_key,</a>
<a name="ln349">                                !iter_-&gt;IsKeyPinned() /* copy */);</a>
<a name="ln350">              current_entry_is_merged_ = true;</a>
<a name="ln351">              valid_ = true;</a>
<a name="ln352">              MergeValuesNewToOld();  // Go to a different state machine</a>
<a name="ln353">              return;</a>
<a name="ln354">            default:</a>
<a name="ln355">              assert(false);</a>
<a name="ln356">              break;</a>
<a name="ln357">          }</a>
<a name="ln358">        }</a>
<a name="ln359">      }</a>
<a name="ln360">    }</a>
<a name="ln361">    // If we have sequentially iterated via numerous keys and still not</a>
<a name="ln362">    // found the next user-key, then it is better to seek so that we can</a>
<a name="ln363">    // avoid too many key comparisons. We seek to the last occurrence of</a>
<a name="ln364">    // our current key by looking for sequence number 0 and type deletion</a>
<a name="ln365">    // (the smallest type).</a>
<a name="ln366">    if (skipping &amp;&amp; num_skipped &gt; max_skip_) {</a>
<a name="ln367">      num_skipped = 0;</a>
<a name="ln368">      std::string last_key;</a>
<a name="ln369">      AppendInternalKey(&amp;last_key, ParsedInternalKey(saved_key_.GetKey(), 0,</a>
<a name="ln370">                                                     kTypeDeletion));</a>
<a name="ln371">      iter_-&gt;Seek(last_key);</a>
<a name="ln372">      RecordTick(statistics_, NUMBER_OF_RESEEKS_IN_ITERATION);</a>
<a name="ln373">    } else {</a>
<a name="ln374">      iter_-&gt;Next();</a>
<a name="ln375">    }</a>
<a name="ln376">  } while (iter_-&gt;Valid());</a>
<a name="ln377">  valid_ = false;</a>
<a name="ln378">}</a>
<a name="ln379"> </a>
<a name="ln380">// Merge values of the same user key starting from the current iter_ position</a>
<a name="ln381">// Scan from the newer entries to older entries.</a>
<a name="ln382">// PRE: iter_-&gt;key() points to the first merge type entry</a>
<a name="ln383">//      saved_key_ stores the user key</a>
<a name="ln384">// POST: saved_value_ has the merged value for the user key</a>
<a name="ln385">//       iter_ points to the next entry (or invalid)</a>
<a name="ln386">void DBIter::MergeValuesNewToOld() {</a>
<a name="ln387">  if (!user_merge_operator_) {</a>
<a name="ln388">    RLOG(InfoLogLevel::ERROR_LEVEL,</a>
<a name="ln389">        logger_, &quot;Options::merge_operator is null.&quot;);</a>
<a name="ln390">    status_ = STATUS(InvalidArgument, &quot;user_merge_operator_ must be set.&quot;);</a>
<a name="ln391">    valid_ = false;</a>
<a name="ln392">    return;</a>
<a name="ln393">  }</a>
<a name="ln394"> </a>
<a name="ln395">  // Start the merge process by pushing the first operand</a>
<a name="ln396">  std::deque&lt;std::string&gt; operands;</a>
<a name="ln397">  operands.push_front(iter_-&gt;value().ToString());</a>
<a name="ln398"> </a>
<a name="ln399">  ParsedInternalKey ikey;</a>
<a name="ln400">  for (iter_-&gt;Next(); iter_-&gt;Valid(); iter_-&gt;Next()) {</a>
<a name="ln401">    if (!ParseKey(&amp;ikey)) {</a>
<a name="ln402">      // skip corrupted key</a>
<a name="ln403">      continue;</a>
<a name="ln404">    }</a>
<a name="ln405"> </a>
<a name="ln406">    if (!user_comparator_-&gt;Equal(ikey.user_key, saved_key_.GetKey())) {</a>
<a name="ln407">      // hit the next user key, stop right here</a>
<a name="ln408">      break;</a>
<a name="ln409">    } else if (kTypeDeletion == ikey.type || kTypeSingleDeletion == ikey.type) {</a>
<a name="ln410">      // hit a delete with the same user key, stop right here</a>
<a name="ln411">      // iter_ is positioned after delete</a>
<a name="ln412">      iter_-&gt;Next();</a>
<a name="ln413">      break;</a>
<a name="ln414">    } else if (kTypeValue == ikey.type) {</a>
<a name="ln415">      // hit a put, merge the put value with operands and store the</a>
<a name="ln416">      // final result in saved_value_. We are done!</a>
<a name="ln417">      // ignore corruption if there is any.</a>
<a name="ln418">      const Slice val = iter_-&gt;value();</a>
<a name="ln419">      {</a>
<a name="ln420">        StopWatchNano timer(env_, statistics_ != nullptr);</a>
<a name="ln421">        PERF_TIMER_GUARD(merge_operator_time_nanos);</a>
<a name="ln422">        user_merge_operator_-&gt;FullMerge(ikey.user_key, &amp;val, operands,</a>
<a name="ln423">                                        &amp;saved_value_, logger_);</a>
<a name="ln424">        RecordTick(statistics_, MERGE_OPERATION_TOTAL_TIME,</a>
<a name="ln425">                   timer.ElapsedNanos());</a>
<a name="ln426">      }</a>
<a name="ln427">      // iter_ is positioned after put</a>
<a name="ln428">      iter_-&gt;Next();</a>
<a name="ln429">      return;</a>
<a name="ln430">    } else if (kTypeMerge == ikey.type) {</a>
<a name="ln431">      // hit a merge, add the value as an operand and run associative merge.</a>
<a name="ln432">      // when complete, add result to operands and continue.</a>
<a name="ln433">      const Slice&amp; val = iter_-&gt;value();</a>
<a name="ln434">      operands.push_front(val.ToString());</a>
<a name="ln435">    } else {</a>
<a name="ln436">      assert(false);</a>
<a name="ln437">    }</a>
<a name="ln438">  }</a>
<a name="ln439"> </a>
<a name="ln440">  {</a>
<a name="ln441">    StopWatchNano timer(env_, statistics_ != nullptr);</a>
<a name="ln442">    PERF_TIMER_GUARD(merge_operator_time_nanos);</a>
<a name="ln443">    // we either exhausted all internal keys under this user key, or hit</a>
<a name="ln444">    // a deletion marker.</a>
<a name="ln445">    // feed null as the existing value to the merge operator, such that</a>
<a name="ln446">    // client can differentiate this scenario and do things accordingly.</a>
<a name="ln447">    user_merge_operator_-&gt;FullMerge(saved_key_.GetKey(), nullptr, operands,</a>
<a name="ln448">                                    &amp;saved_value_, logger_);</a>
<a name="ln449">    RecordTick(statistics_, MERGE_OPERATION_TOTAL_TIME, timer.ElapsedNanos());</a>
<a name="ln450">  }</a>
<a name="ln451">}</a>
<a name="ln452"> </a>
<a name="ln453">void DBIter::Prev() {</a>
<a name="ln454">  assert(valid_);</a>
<a name="ln455">  if (direction_ == kForward) {</a>
<a name="ln456">    ReverseToBackward();</a>
<a name="ln457">  }</a>
<a name="ln458">  PrevInternal();</a>
<a name="ln459">  if (statistics_ != nullptr) {</a>
<a name="ln460">    RecordTick(statistics_, NUMBER_DB_PREV);</a>
<a name="ln461">    if (valid_) {</a>
<a name="ln462">      RecordTick(statistics_, NUMBER_DB_PREV_FOUND);</a>
<a name="ln463">      RecordTick(statistics_, ITER_BYTES_READ, key().size() + value().size());</a>
<a name="ln464">    }</a>
<a name="ln465">  }</a>
<a name="ln466">  if (valid_ &amp;&amp; prefix_extractor_ &amp;&amp; prefix_same_as_start_ &amp;&amp;</a>
<a name="ln467">      prefix_extractor_-&gt;Transform(saved_key_.GetKey())</a>
<a name="ln468">              .compare(prefix_start_.GetKey()) != 0) {</a>
<a name="ln469">    valid_ = false;</a>
<a name="ln470">  }</a>
<a name="ln471">}</a>
<a name="ln472"> </a>
<a name="ln473">void DBIter::ReverseToBackward() {</a>
<a name="ln474">  if (current_entry_is_merged_) {</a>
<a name="ln475">    // Not placed in the same key. Need to call Prev() until finding the</a>
<a name="ln476">    // previous key.</a>
<a name="ln477">    if (!iter_-&gt;Valid()) {</a>
<a name="ln478">      iter_-&gt;SeekToLast();</a>
<a name="ln479">    }</a>
<a name="ln480">    ParsedInternalKey ikey;</a>
<a name="ln481">    FindParseableKey(&amp;ikey, kReverse);</a>
<a name="ln482">    while (iter_-&gt;Valid() &amp;&amp;</a>
<a name="ln483">           user_comparator_-&gt;Compare(ikey.user_key, saved_key_.GetKey()) &gt; 0) {</a>
<a name="ln484">      iter_-&gt;Prev();</a>
<a name="ln485">      FindParseableKey(&amp;ikey, kReverse);</a>
<a name="ln486">    }</a>
<a name="ln487">  }</a>
<a name="ln488">#ifndef NDEBUG</a>
<a name="ln489">  if (iter_-&gt;Valid()) {</a>
<a name="ln490">    ParsedInternalKey ikey;</a>
<a name="ln491">    assert(ParseKey(&amp;ikey));</a>
<a name="ln492">    assert(user_comparator_-&gt;Compare(ikey.user_key, saved_key_.GetKey()) &lt;= 0);</a>
<a name="ln493">  }</a>
<a name="ln494">#endif</a>
<a name="ln495"> </a>
<a name="ln496">  FindPrevUserKey();</a>
<a name="ln497">  direction_ = kReverse;</a>
<a name="ln498">}</a>
<a name="ln499"> </a>
<a name="ln500">void DBIter::PrevInternal() {</a>
<a name="ln501">  if (!iter_-&gt;Valid()) {</a>
<a name="ln502">    valid_ = false;</a>
<a name="ln503">    return;</a>
<a name="ln504">  }</a>
<a name="ln505"> </a>
<a name="ln506">  ParsedInternalKey ikey;</a>
<a name="ln507"> </a>
<a name="ln508">  while (iter_-&gt;Valid()) {</a>
<a name="ln509">    saved_key_.SetKey(ExtractUserKey(iter_-&gt;key()),</a>
<a name="ln510">                      !iter_-&gt;IsKeyPinned() /* copy */);</a>
<a name="ln511">    if (FindValueForCurrentKey()) {</a>
<a name="ln512">      valid_ = true;</a>
<a name="ln513">      if (!iter_-&gt;Valid()) {</a>
<a name="ln514">        return;</a>
<a name="ln515">      }</a>
<a name="ln516">      FindParseableKey(&amp;ikey, kReverse);</a>
<a name="ln517">      if (user_comparator_-&gt;Equal(ikey.user_key, saved_key_.GetKey())) {</a>
<a name="ln518">        FindPrevUserKey();</a>
<a name="ln519">      }</a>
<a name="ln520">      return;</a>
<a name="ln521">    }</a>
<a name="ln522">    if (!iter_-&gt;Valid()) {</a>
<a name="ln523">      break;</a>
<a name="ln524">    }</a>
<a name="ln525">    FindParseableKey(&amp;ikey, kReverse);</a>
<a name="ln526">    if (user_comparator_-&gt;Equal(ikey.user_key, saved_key_.GetKey())) {</a>
<a name="ln527">      FindPrevUserKey();</a>
<a name="ln528">    }</a>
<a name="ln529">  }</a>
<a name="ln530">  // We haven't found any key - iterator is not valid</a>
<a name="ln531">  assert(!iter_-&gt;Valid());</a>
<a name="ln532">  valid_ = false;</a>
<a name="ln533">}</a>
<a name="ln534"> </a>
<a name="ln535">// This function checks, if the entry with biggest sequence_number &lt;= sequence_</a>
<a name="ln536">// is non kTypeDeletion or kTypeSingleDeletion. If it's not, we save value in</a>
<a name="ln537">// saved_value_</a>
<a name="ln538">bool DBIter::FindValueForCurrentKey() {</a>
<a name="ln539">  assert(iter_-&gt;Valid());</a>
<a name="ln540">  merge_operands_.clear();</a>
<a name="ln541">  // last entry before merge (could be kTypeDeletion, kTypeSingleDeletion or</a>
<a name="ln542">  // kTypeValue)</a>
<a name="ln543">  ValueType last_not_merge_type = kTypeDeletion;</a>
<a name="ln544">  ValueType last_key_entry_type = kTypeDeletion;</a>
<a name="ln545"> </a>
<a name="ln546">  ParsedInternalKey ikey;</a>
<a name="ln547">  FindParseableKey(&amp;ikey, kReverse);</a>
<a name="ln548"> </a>
<a name="ln549">  size_t num_skipped = 0;</a>
<a name="ln550">  while (iter_-&gt;Valid() &amp;&amp; ikey.sequence &lt;= sequence_ &amp;&amp;</a>
<a name="ln551">         user_comparator_-&gt;Equal(ikey.user_key, saved_key_.GetKey())) {</a>
<a name="ln552">    // We iterate too much: let's use Seek() to avoid too much key comparisons</a>
<a name="ln553">    if (num_skipped &gt;= max_skip_) {</a>
<a name="ln554">      return FindValueForCurrentKeyUsingSeek();</a>
<a name="ln555">    }</a>
<a name="ln556"> </a>
<a name="ln557">    last_key_entry_type = ikey.type;</a>
<a name="ln558">    switch (last_key_entry_type) {</a>
<a name="ln559">      case kTypeValue:</a>
<a name="ln560">        merge_operands_.clear();</a>
<a name="ln561">        saved_value_ = iter_-&gt;value().ToString();</a>
<a name="ln562">        last_not_merge_type = kTypeValue;</a>
<a name="ln563">        break;</a>
<a name="ln564">      case kTypeDeletion:</a>
<a name="ln565">      case kTypeSingleDeletion:</a>
<a name="ln566">        merge_operands_.clear();</a>
<a name="ln567">        last_not_merge_type = last_key_entry_type;</a>
<a name="ln568">        PERF_COUNTER_ADD(internal_delete_skipped_count, 1);</a>
<a name="ln569">        break;</a>
<a name="ln570">      case kTypeMerge:</a>
<a name="ln571">        assert(user_merge_operator_ != nullptr);</a>
<a name="ln572">        merge_operands_.push_back(iter_-&gt;value().ToString());</a>
<a name="ln573">        break;</a>
<a name="ln574">      default:</a>
<a name="ln575">        assert(false);</a>
<a name="ln576">    }</a>
<a name="ln577"> </a>
<a name="ln578">    PERF_COUNTER_ADD(internal_key_skipped_count, 1);</a>
<a name="ln579">    assert(user_comparator_-&gt;Equal(ikey.user_key, saved_key_.GetKey()));</a>
<a name="ln580">    iter_-&gt;Prev();</a>
<a name="ln581">    ++num_skipped;</a>
<a name="ln582">    FindParseableKey(&amp;ikey, kReverse);</a>
<a name="ln583">  }</a>
<a name="ln584"> </a>
<a name="ln585">  switch (last_key_entry_type) {</a>
<a name="ln586">    case kTypeDeletion:</a>
<a name="ln587">    case kTypeSingleDeletion:</a>
<a name="ln588">      valid_ = false;</a>
<a name="ln589">      return false;</a>
<a name="ln590">    case kTypeMerge:</a>
<a name="ln591">      if (last_not_merge_type == kTypeDeletion) {</a>
<a name="ln592">        StopWatchNano timer(env_, statistics_ != nullptr);</a>
<a name="ln593">        PERF_TIMER_GUARD(merge_operator_time_nanos);</a>
<a name="ln594">        user_merge_operator_-&gt;FullMerge(saved_key_.GetKey(), nullptr,</a>
<a name="ln595">                                        merge_operands_, &amp;saved_value_,</a>
<a name="ln596">                                        logger_);</a>
<a name="ln597">        RecordTick(statistics_, MERGE_OPERATION_TOTAL_TIME,</a>
<a name="ln598">                   timer.ElapsedNanos());</a>
<a name="ln599">      } else {</a>
<a name="ln600">        assert(last_not_merge_type == kTypeValue);</a>
<a name="ln601">        std::string last_put_value = saved_value_;</a>
<a name="ln602">        Slice temp_slice(last_put_value);</a>
<a name="ln603">        {</a>
<a name="ln604">          StopWatchNano timer(env_, statistics_ != nullptr);</a>
<a name="ln605">          PERF_TIMER_GUARD(merge_operator_time_nanos);</a>
<a name="ln606">          user_merge_operator_-&gt;FullMerge(saved_key_.GetKey(), &amp;temp_slice,</a>
<a name="ln607">                                          merge_operands_, &amp;saved_value_,</a>
<a name="ln608">                                          logger_);</a>
<a name="ln609">          RecordTick(statistics_, MERGE_OPERATION_TOTAL_TIME,</a>
<a name="ln610">                     timer.ElapsedNanos());</a>
<a name="ln611">        }</a>
<a name="ln612">      }</a>
<a name="ln613">      break;</a>
<a name="ln614">    case kTypeValue:</a>
<a name="ln615">      // do nothing - we've already has value in saved_value_</a>
<a name="ln616">      break;</a>
<a name="ln617">    default:</a>
<a name="ln618">      assert(false);</a>
<a name="ln619">      break;</a>
<a name="ln620">  }</a>
<a name="ln621">  valid_ = true;</a>
<a name="ln622">  return true;</a>
<a name="ln623">}</a>
<a name="ln624"> </a>
<a name="ln625">// This function is used in FindValueForCurrentKey.</a>
<a name="ln626">// We use Seek() function instead of Prev() to find necessary value</a>
<a name="ln627">bool DBIter::FindValueForCurrentKeyUsingSeek() {</a>
<a name="ln628">  std::string last_key;</a>
<a name="ln629">  AppendInternalKey(&amp;last_key, ParsedInternalKey(saved_key_.GetKey(), sequence_,</a>
<a name="ln630">                                                 kValueTypeForSeek));</a>
<a name="ln631">  iter_-&gt;Seek(last_key);</a>
<a name="ln632">  RecordTick(statistics_, NUMBER_OF_RESEEKS_IN_ITERATION);</a>
<a name="ln633"> </a>
<a name="ln634">  // assume there is at least one parseable key for this user key</a>
<a name="ln635">  ParsedInternalKey ikey;</a>
<a name="ln636">  FindParseableKey(&amp;ikey, kForward);</a>
<a name="ln637"> </a>
<a name="ln638">  if (ikey.type == kTypeValue || ikey.type == kTypeDeletion ||</a>
<a name="ln639">      ikey.type == kTypeSingleDeletion) {</a>
<a name="ln640">    if (ikey.type == kTypeValue) {</a>
<a name="ln641">      saved_value_ = iter_-&gt;value().ToString();</a>
<a name="ln642">      valid_ = true;</a>
<a name="ln643">      return true;</a>
<a name="ln644">    }</a>
<a name="ln645">    valid_ = false;</a>
<a name="ln646">    return false;</a>
<a name="ln647">  }</a>
<a name="ln648"> </a>
<a name="ln649">  // kTypeMerge. We need to collect all kTypeMerge values and save them</a>
<a name="ln650">  // in operands</a>
<a name="ln651">  std::deque&lt;std::string&gt; operands;</a>
<a name="ln652">  while (iter_-&gt;Valid() &amp;&amp;</a>
<a name="ln653">         user_comparator_-&gt;Equal(ikey.user_key, saved_key_.GetKey()) &amp;&amp;</a>
<a name="ln654">         ikey.type == kTypeMerge) {</a>
<a name="ln655">    operands.push_front(iter_-&gt;value().ToString());</a>
<a name="ln656">    iter_-&gt;Next();</a>
<a name="ln657">    FindParseableKey(&amp;ikey, kForward);</a>
<a name="ln658">  }</a>
<a name="ln659"> </a>
<a name="ln660">  if (!iter_-&gt;Valid() ||</a>
<a name="ln661">      !user_comparator_-&gt;Equal(ikey.user_key, saved_key_.GetKey()) ||</a>
<a name="ln662">      ikey.type == kTypeDeletion || ikey.type == kTypeSingleDeletion) {</a>
<a name="ln663">    {</a>
<a name="ln664">      StopWatchNano timer(env_, statistics_ != nullptr);</a>
<a name="ln665">      PERF_TIMER_GUARD(merge_operator_time_nanos);</a>
<a name="ln666">      user_merge_operator_-&gt;FullMerge(saved_key_.GetKey(), nullptr, operands,</a>
<a name="ln667">                                      &amp;saved_value_, logger_);</a>
<a name="ln668">      RecordTick(statistics_, MERGE_OPERATION_TOTAL_TIME, timer.ElapsedNanos());</a>
<a name="ln669">    }</a>
<a name="ln670">    // Make iter_ valid and point to saved_key_</a>
<a name="ln671">    if (!iter_-&gt;Valid() ||</a>
<a name="ln672">        !user_comparator_-&gt;Equal(ikey.user_key, saved_key_.GetKey())) {</a>
<a name="ln673">      iter_-&gt;Seek(last_key);</a>
<a name="ln674">      RecordTick(statistics_, NUMBER_OF_RESEEKS_IN_ITERATION);</a>
<a name="ln675">    }</a>
<a name="ln676">    valid_ = true;</a>
<a name="ln677">    return true;</a>
<a name="ln678">  }</a>
<a name="ln679"> </a>
<a name="ln680">  const Slice&amp; val = iter_-&gt;value();</a>
<a name="ln681">  {</a>
<a name="ln682">    StopWatchNano timer(env_, statistics_ != nullptr);</a>
<a name="ln683">    PERF_TIMER_GUARD(merge_operator_time_nanos);</a>
<a name="ln684">    user_merge_operator_-&gt;FullMerge(saved_key_.GetKey(), &amp;val, operands,</a>
<a name="ln685">                                    &amp;saved_value_, logger_);</a>
<a name="ln686">    RecordTick(statistics_, MERGE_OPERATION_TOTAL_TIME, timer.ElapsedNanos());</a>
<a name="ln687">  }</a>
<a name="ln688">  valid_ = true;</a>
<a name="ln689">  return true;</a>
<a name="ln690">}</a>
<a name="ln691"> </a>
<a name="ln692">// Used in Next to change directions</a>
<a name="ln693">// Go to next user key</a>
<a name="ln694">// Don't use Seek(),</a>
<a name="ln695">// because next user key will be very close</a>
<a name="ln696">void DBIter::FindNextUserKey() {</a>
<a name="ln697">  if (!iter_-&gt;Valid()) {</a>
<a name="ln698">    return;</a>
<a name="ln699">  }</a>
<a name="ln700">  ParsedInternalKey ikey;</a>
<a name="ln701">  FindParseableKey(&amp;ikey, kForward);</a>
<a name="ln702">  while (iter_-&gt;Valid() &amp;&amp;</a>
<a name="ln703">         !user_comparator_-&gt;Equal(ikey.user_key, saved_key_.GetKey())) {</a>
<a name="ln704">    iter_-&gt;Next();</a>
<a name="ln705">    FindParseableKey(&amp;ikey, kForward);</a>
<a name="ln706">  }</a>
<a name="ln707">}</a>
<a name="ln708"> </a>
<a name="ln709">// Go to previous user_key</a>
<a name="ln710">void DBIter::FindPrevUserKey() {</a>
<a name="ln711">  if (!iter_-&gt;Valid()) {</a>
<a name="ln712">    return;</a>
<a name="ln713">  }</a>
<a name="ln714">  size_t num_skipped = 0;</a>
<a name="ln715">  ParsedInternalKey ikey;</a>
<a name="ln716">  FindParseableKey(&amp;ikey, kReverse);</a>
<a name="ln717">  int cmp;</a>
<a name="ln718">  while (iter_-&gt;Valid() &amp;&amp; ((cmp = user_comparator_-&gt;Compare(</a>
<a name="ln719">                                 ikey.user_key, saved_key_.GetKey())) == 0 ||</a>
<a name="ln720">                            (cmp &gt; 0 &amp;&amp; ikey.sequence &gt; sequence_))) {</a>
<a name="ln721">    if (cmp == 0) {</a>
<a name="ln722">      if (num_skipped &gt;= max_skip_) {</a>
<a name="ln723">        num_skipped = 0;</a>
<a name="ln724">        IterKey last_key;</a>
<a name="ln725">        last_key.SetInternalKey(ParsedInternalKey(</a>
<a name="ln726">            saved_key_.GetKey(), kMaxSequenceNumber, kValueTypeForSeek));</a>
<a name="ln727">        iter_-&gt;Seek(last_key.GetKey());</a>
<a name="ln728">        RecordTick(statistics_, NUMBER_OF_RESEEKS_IN_ITERATION);</a>
<a name="ln729">      } else {</a>
<a name="ln730">        ++num_skipped;</a>
<a name="ln731">      }</a>
<a name="ln732">    }</a>
<a name="ln733">    iter_-&gt;Prev();</a>
<a name="ln734">    FindParseableKey(&amp;ikey, kReverse);</a>
<a name="ln735">  }</a>
<a name="ln736">}</a>
<a name="ln737"> </a>
<a name="ln738">// Skip all unparseable keys</a>
<a name="ln739">void DBIter::FindParseableKey(ParsedInternalKey* ikey, Direction direction) {</a>
<a name="ln740">  while (iter_-&gt;Valid() &amp;&amp; !ParseKey(ikey)) {</a>
<a name="ln741">    if (direction == kReverse) {</a>
<a name="ln742">      iter_-&gt;Prev();</a>
<a name="ln743">    } else {</a>
<a name="ln744">      iter_-&gt;Next();</a>
<a name="ln745">    }</a>
<a name="ln746">  }</a>
<a name="ln747">}</a>
<a name="ln748"> </a>
<a name="ln749">void DBIter::Seek(const Slice&amp; target) {</a>
<a name="ln750">  saved_key_.Clear();</a>
<a name="ln751">  // now savved_key is used to store internal key.</a>
<a name="ln752">  saved_key_.SetInternalKey(target, sequence_);</a>
<a name="ln753"> </a>
<a name="ln754">  {</a>
<a name="ln755">    PERF_TIMER_GUARD(seek_internal_seek_time);</a>
<a name="ln756">    iter_-&gt;Seek(saved_key_.GetKey());</a>
<a name="ln757">  }</a>
<a name="ln758"> </a>
<a name="ln759">  RecordTick(statistics_, NUMBER_DB_SEEK);</a>
<a name="ln760">  if (iter_-&gt;Valid()) {</a>
<a name="ln761">    direction_ = kForward;</a>
<a name="ln762">    ClearSavedValue();</a>
<a name="ln763">    FindNextUserEntry(false /* not skipping */);</a>
<a name="ln764">    if (statistics_ != nullptr) {</a>
<a name="ln765">      if (valid_) {</a>
<a name="ln766">        RecordTick(statistics_, NUMBER_DB_SEEK_FOUND);</a>
<a name="ln767">        RecordTick(statistics_, ITER_BYTES_READ, key().size() + value().size());</a>
<a name="ln768">      }</a>
<a name="ln769">    }</a>
<a name="ln770">  } else {</a>
<a name="ln771">    valid_ = false;</a>
<a name="ln772">  }</a>
<a name="ln773">  if (valid_ &amp;&amp; prefix_extractor_ &amp;&amp; prefix_same_as_start_) {</a>
<a name="ln774">    prefix_start_.SetKey(prefix_extractor_-&gt;Transform(target));</a>
<a name="ln775">  }</a>
<a name="ln776">}</a>
<a name="ln777"> </a>
<a name="ln778">void DBIter::SeekToFirst() {</a>
<a name="ln779">  // Don't use iter_::Seek() if we set a prefix extractor</a>
<a name="ln780">  // because prefix seek will be used.</a>
<a name="ln781">  if (prefix_extractor_ != nullptr) {</a>
<a name="ln782">    max_skip_ = std::numeric_limits&lt;uint64_t&gt;::max();</a>
<a name="ln783">  }</a>
<a name="ln784">  direction_ = kForward;</a>
<a name="ln785">  ClearSavedValue();</a>
<a name="ln786"> </a>
<a name="ln787">  {</a>
<a name="ln788">    PERF_TIMER_GUARD(seek_internal_seek_time);</a>
<a name="ln789">    iter_-&gt;SeekToFirst();</a>
<a name="ln790">  }</a>
<a name="ln791"> </a>
<a name="ln792">  RecordTick(statistics_, NUMBER_DB_SEEK);</a>
<a name="ln793">  if (iter_-&gt;Valid()) {</a>
<a name="ln794">    FindNextUserEntry(false /* not skipping */);</a>
<a name="ln795">    if (statistics_ != nullptr) {</a>
<a name="ln796">      if (valid_) {</a>
<a name="ln797">        RecordTick(statistics_, NUMBER_DB_SEEK_FOUND);</a>
<a name="ln798">        RecordTick(statistics_, ITER_BYTES_READ, key().size() + value().size());</a>
<a name="ln799">      }</a>
<a name="ln800">    }</a>
<a name="ln801">  } else {</a>
<a name="ln802">    valid_ = false;</a>
<a name="ln803">  }</a>
<a name="ln804">  if (valid_ &amp;&amp; prefix_extractor_ &amp;&amp; prefix_same_as_start_) {</a>
<a name="ln805">    prefix_start_.SetKey(prefix_extractor_-&gt;Transform(saved_key_.GetKey()));</a>
<a name="ln806">  }</a>
<a name="ln807">}</a>
<a name="ln808"> </a>
<a name="ln809">void DBIter::SeekToLast() {</a>
<a name="ln810">  // Don't use iter_::Seek() if we set a prefix extractor</a>
<a name="ln811">  // because prefix seek will be used.</a>
<a name="ln812">  if (prefix_extractor_ != nullptr) {</a>
<a name="ln813">    max_skip_ = std::numeric_limits&lt;uint64_t&gt;::max();</a>
<a name="ln814">  }</a>
<a name="ln815">  direction_ = kReverse;</a>
<a name="ln816">  ClearSavedValue();</a>
<a name="ln817"> </a>
<a name="ln818">  {</a>
<a name="ln819">    PERF_TIMER_GUARD(seek_internal_seek_time);</a>
<a name="ln820">    iter_-&gt;SeekToLast();</a>
<a name="ln821">  }</a>
<a name="ln822">  // When the iterate_upper_bound is set to a value,</a>
<a name="ln823">  // it will seek to the last key before the</a>
<a name="ln824">  // ReadOptions.iterate_upper_bound</a>
<a name="ln825">  if (iter_-&gt;Valid() &amp;&amp; iterate_upper_bound_ != nullptr) {</a>
<a name="ln826">    saved_key_.SetKey(*iterate_upper_bound_, false /* copy */);</a>
<a name="ln827">    std::string last_key;</a>
<a name="ln828">    AppendInternalKey(&amp;last_key,</a>
<a name="ln829">                      ParsedInternalKey(saved_key_.GetKey(), kMaxSequenceNumber,</a>
<a name="ln830">                                        kValueTypeForSeek));</a>
<a name="ln831"> </a>
<a name="ln832">    iter_-&gt;Seek(last_key);</a>
<a name="ln833"> </a>
<a name="ln834">    if (!iter_-&gt;Valid()) {</a>
<a name="ln835">      iter_-&gt;SeekToLast();</a>
<a name="ln836">    } else {</a>
<a name="ln837">      iter_-&gt;Prev();</a>
<a name="ln838">      if (!iter_-&gt;Valid()) {</a>
<a name="ln839">        valid_ = false;</a>
<a name="ln840">        return;</a>
<a name="ln841">      }</a>
<a name="ln842">    }</a>
<a name="ln843">  }</a>
<a name="ln844">  PrevInternal();</a>
<a name="ln845">  if (statistics_ != nullptr) {</a>
<a name="ln846">    RecordTick(statistics_, NUMBER_DB_SEEK);</a>
<a name="ln847">    if (valid_) {</a>
<a name="ln848">      RecordTick(statistics_, NUMBER_DB_SEEK_FOUND);</a>
<a name="ln849">      RecordTick(statistics_, ITER_BYTES_READ, key().size() + value().size());</a>
<a name="ln850">    }</a>
<a name="ln851">  }</a>
<a name="ln852">  if (valid_ &amp;&amp; prefix_extractor_ &amp;&amp; prefix_same_as_start_) {</a>
<a name="ln853">    prefix_start_.SetKey(prefix_extractor_-&gt;Transform(saved_key_.GetKey()));</a>
<a name="ln854">  }</a>
<a name="ln855">}</a>
<a name="ln856"> </a>
<a name="ln857">Iterator* NewDBIterator(Env* env, const ImmutableCFOptions&amp; ioptions,</a>
<a name="ln858">                        const Comparator* user_key_comparator,</a>
<a name="ln859">                        InternalIterator* internal_iter,</a>
<a name="ln860">                        const SequenceNumber&amp; sequence,</a>
<a name="ln861">                        uint64_t max_sequential_skip_in_iterations,</a>
<a name="ln862">                        uint64_t version_number,</a>
<a name="ln863">                        const Slice* iterate_upper_bound,</a>
<a name="ln864">                        bool prefix_same_as_start, bool pin_data) {</a>
<a name="ln865">  DBIter* db_iter =</a>
<a name="ln866">      new DBIter(env, ioptions, user_key_comparator, internal_iter, sequence,</a>
<a name="ln867">                 false, max_sequential_skip_in_iterations, version_number,</a>
<a name="ln868">                 iterate_upper_bound, prefix_same_as_start);</a>
<a name="ln869">  if (pin_data) {</a>
<a name="ln870">    CHECK_OK(db_iter-&gt;PinData());</a>
<a name="ln871">  }</a>
<a name="ln872">  return db_iter;</a>
<a name="ln873">}</a>
<a name="ln874"> </a>
<a name="ln875">ArenaWrappedDBIter::~ArenaWrappedDBIter() { db_iter_-&gt;~DBIter(); }</a>
<a name="ln876"> </a>
<a name="ln877">void ArenaWrappedDBIter::SetDBIter(DBIter* iter) { db_iter_ = iter; }</a>
<a name="ln878"> </a>
<a name="ln879">void ArenaWrappedDBIter::SetIterUnderDBIter(InternalIterator* iter) {</a>
<a name="ln880">  static_cast&lt;DBIter*&gt;(db_iter_)-&gt;SetIter(iter);</a>
<a name="ln881">}</a>
<a name="ln882"> </a>
<a name="ln883">inline bool ArenaWrappedDBIter::Valid() const { return db_iter_-&gt;Valid(); }</a>
<a name="ln884">inline void ArenaWrappedDBIter::SeekToFirst() { db_iter_-&gt;SeekToFirst(); }</a>
<a name="ln885">inline void ArenaWrappedDBIter::SeekToLast() { db_iter_-&gt;SeekToLast(); }</a>
<a name="ln886">inline void ArenaWrappedDBIter::Seek(const Slice&amp; target) {</a>
<a name="ln887">  db_iter_-&gt;Seek(target);</a>
<a name="ln888">}</a>
<a name="ln889">inline void ArenaWrappedDBIter::Next() { db_iter_-&gt;Next(); }</a>
<a name="ln890">inline void ArenaWrappedDBIter::Prev() { db_iter_-&gt;Prev(); }</a>
<a name="ln891">inline Slice ArenaWrappedDBIter::key() const { return db_iter_-&gt;key(); }</a>
<a name="ln892">inline Slice ArenaWrappedDBIter::value() const { return db_iter_-&gt;value(); }</a>
<a name="ln893">inline Status ArenaWrappedDBIter::status() const { return db_iter_-&gt;status(); }</a>
<a name="ln894">inline Status ArenaWrappedDBIter::PinData() { return db_iter_-&gt;PinData(); }</a>
<a name="ln895">inline Status ArenaWrappedDBIter::GetProperty(std::string prop_name,</a>
<a name="ln896">                                              std::string* prop) {</a>
<a name="ln897">  return db_iter_-&gt;GetProperty(prop_name, prop);</a>
<a name="ln898">}</a>
<a name="ln899">inline Status ArenaWrappedDBIter::ReleasePinnedData() {</a>
<a name="ln900">  return db_iter_-&gt;ReleasePinnedData();</a>
<a name="ln901">}</a>
<a name="ln902">void ArenaWrappedDBIter::RegisterCleanup(CleanupFunction function, void* arg1,</a>
<a name="ln903">                                         void* arg2) {</a>
<a name="ln904">  db_iter_-&gt;RegisterCleanup(function, arg1, arg2);</a>
<a name="ln905">}</a>
<a name="ln906"> </a>
<a name="ln907">void ArenaWrappedDBIter::RevalidateAfterUpperBoundChange() {</a>
<a name="ln908">  db_iter_-&gt;RevalidateAfterUpperBoundChange();</a>
<a name="ln909">}</a>
<a name="ln910"> </a>
<a name="ln911">ArenaWrappedDBIter* NewArenaWrappedDbIterator(</a>
<a name="ln912">    Env* env, const ImmutableCFOptions&amp; ioptions,</a>
<a name="ln913">    const Comparator* user_key_comparator, const SequenceNumber&amp; sequence,</a>
<a name="ln914">    uint64_t max_sequential_skip_in_iterations, uint64_t version_number,</a>
<a name="ln915">    const Slice* iterate_upper_bound, bool prefix_same_as_start,</a>
<a name="ln916">    bool pin_data) {</a>
<a name="ln917">  ArenaWrappedDBIter* iter = new ArenaWrappedDBIter();</a>
<a name="ln918">  Arena* arena = iter-&gt;GetArena();</a>
<a name="ln919">  auto mem = arena-&gt;AllocateAligned(sizeof(DBIter));</a>
<a name="ln920">  DBIter* db_iter =</a>
<a name="ln921">      new (mem) DBIter(env, ioptions, user_key_comparator, nullptr, sequence,</a>
<a name="ln922">                       true, max_sequential_skip_in_iterations, version_number,</a>
<a name="ln923">                       iterate_upper_bound, prefix_same_as_start);</a>
<a name="ln924"> </a>
<a name="ln925">  iter-&gt;SetDBIter(db_iter);</a>
<a name="ln926">  if (pin_data) {</a>
<a name="ln927">    CHECK_OK(iter-&gt;PinData());</a>
<a name="ln928">  }</a>
<a name="ln929"> </a>
<a name="ln930">  return iter;</a>
<a name="ln931">}</a>
<a name="ln932"> </a>
<a name="ln933">}  // namespace rocksdb</a>

</code></pre>
<div class="balloon" rel="113"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="870"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="927"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
