
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>replica_state.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Licensed to the Apache Software Foundation (ASF) under one</a>
<a name="ln2">// or more contributor license agreements.  See the NOTICE file</a>
<a name="ln3">// distributed with this work for additional information</a>
<a name="ln4">// regarding copyright ownership.  The ASF licenses this file</a>
<a name="ln5">// to you under the Apache License, Version 2.0 (the</a>
<a name="ln6">// &quot;License&quot;); you may not use this file except in compliance</a>
<a name="ln7">// with the License.  You may obtain a copy of the License at</a>
<a name="ln8">//</a>
<a name="ln9">//   http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln10">//</a>
<a name="ln11">// Unless required by applicable law or agreed to in writing,</a>
<a name="ln12">// software distributed under the License is distributed on an</a>
<a name="ln13">// &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</a>
<a name="ln14">// KIND, either express or implied.  See the License for the</a>
<a name="ln15">// specific language governing permissions and limitations</a>
<a name="ln16">// under the License.</a>
<a name="ln17">//</a>
<a name="ln18">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln19">//</a>
<a name="ln20">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln21">//</a>
<a name="ln22">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln23">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln24">//</a>
<a name="ln25">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln26">//</a>
<a name="ln27">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln28">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln29">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln30">// under the License.</a>
<a name="ln31">//</a>
<a name="ln32">#ifndef YB_CONSENSUS_REPLICA_STATE_H</a>
<a name="ln33">#define YB_CONSENSUS_REPLICA_STATE_H</a>
<a name="ln34"> </a>
<a name="ln35">#include &lt;atomic&gt;</a>
<a name="ln36">#include &lt;deque&gt;</a>
<a name="ln37">#include &lt;mutex&gt;</a>
<a name="ln38">#include &lt;string&gt;</a>
<a name="ln39">#include &lt;utility&gt;</a>
<a name="ln40">#include &lt;vector&gt;</a>
<a name="ln41"> </a>
<a name="ln42">#include &lt;boost/atomic.hpp&gt;</a>
<a name="ln43"> </a>
<a name="ln44">#include &quot;yb/common/hybrid_time.h&quot;</a>
<a name="ln45">#include &quot;yb/consensus/consensus.pb.h&quot;</a>
<a name="ln46">#include &quot;yb/consensus/consensus_meta.h&quot;</a>
<a name="ln47">#include &quot;yb/consensus/consensus_queue.h&quot;</a>
<a name="ln48">#include &quot;yb/consensus/consensus_types.h&quot;</a>
<a name="ln49">#include &quot;yb/consensus/retryable_requests.h&quot;</a>
<a name="ln50">#include &quot;yb/consensus/log_util.h&quot;</a>
<a name="ln51">#include &quot;yb/consensus/leader_lease.h&quot;</a>
<a name="ln52">#include &quot;yb/gutil/port.h&quot;</a>
<a name="ln53">#include &quot;yb/util/locks.h&quot;</a>
<a name="ln54">#include &quot;yb/util/status.h&quot;</a>
<a name="ln55">#include &quot;yb/util/enums.h&quot;</a>
<a name="ln56"> </a>
<a name="ln57">namespace yb {</a>
<a name="ln58"> </a>
<a name="ln59">class HostPort;</a>
<a name="ln60">class ReplicaState;</a>
<a name="ln61">class ThreadPool;</a>
<a name="ln62"> </a>
<a name="ln63">namespace consensus {</a>
<a name="ln64"> </a>
<a name="ln65">class RetryableRequests;</a>
<a name="ln66"> </a>
<a name="ln67">YB_DEFINE_ENUM(SetMajorityReplicatedLeaseExpirationFlag,</a>
<a name="ln68">               (kResetOldLeaderLease)(kResetOldLeaderHtLease));</a>
<a name="ln69"> </a>
<a name="ln70">YB_STRONGLY_TYPED_BOOL(CouldStop);</a>
<a name="ln71"> </a>
<a name="ln72">// Class that coordinates access to the replica state (independently of Role).</a>
<a name="ln73">// This has a 1-1 relationship with RaftConsensus and is essentially responsible for</a>
<a name="ln74">// keeping state and checking if state changes are viable.</a>
<a name="ln75">//</a>
<a name="ln76">// Note that, in the case of a LEADER role, there are two configuration states that</a>
<a name="ln77">// that are tracked: a pending and a committed configuration. The &quot;active&quot; state is</a>
<a name="ln78">// considered to be the pending configuration if it is non-null, otherwise the</a>
<a name="ln79">// committed configuration is the active configuration.</a>
<a name="ln80">//</a>
<a name="ln81">// When a replica becomes a leader of a configuration, it sets the pending configuration to</a>
<a name="ln82">// a new configuration declaring itself as leader and sets its &quot;active&quot; role to LEADER.</a>
<a name="ln83">// It then starts up ConsensusPeers for each member of the pending configuration and</a>
<a name="ln84">// tries to push a new configuration to the peers. Once that configuration is</a>
<a name="ln85">// pushed to a majority of the cluster, it is considered committed and the</a>
<a name="ln86">// replica flushes that configuration to disk as the committed configuration.</a>
<a name="ln87">//</a>
<a name="ln88">// Each time an operation is to be performed on the replica the appropriate LockFor*()</a>
<a name="ln89">// method should be called. The LockFor*() methods check that the replica is in the</a>
<a name="ln90">// appropriate state to perform the requested operation and returns the lock or return</a>
<a name="ln91">// Status::IllegalState if that is not the case.</a>
<a name="ln92">//</a>
<a name="ln93">// All state reading/writing methods acquire the lock, unless suffixed by &quot;Unlocked&quot;, in</a>
<a name="ln94">// which case a lock should be obtained prior to calling them.</a>
<a name="ln95">class ReplicaState {</a>
<a name="ln96"> public:</a>
<a name="ln97">  enum State {</a>
<a name="ln98">    // State after the replica is built.</a>
<a name="ln99">    kInitialized,</a>
<a name="ln100"> </a>
<a name="ln101">    // State signaling the replica accepts requests (from clients</a>
<a name="ln102">    // if leader, from leader if follower)</a>
<a name="ln103">    kRunning,</a>
<a name="ln104"> </a>
<a name="ln105">    // State signaling that the replica is shutting down and no longer accepting</a>
<a name="ln106">    // new transactions or commits.</a>
<a name="ln107">    kShuttingDown,</a>
<a name="ln108"> </a>
<a name="ln109">    // State signaling the replica is shut down and does not accept</a>
<a name="ln110">    // any more requests.</a>
<a name="ln111">    kShutDown</a>
<a name="ln112">  };</a>
<a name="ln113"> </a>
<a name="ln114">  typedef std::unique_lock&lt;std::mutex&gt; UniqueLock;</a>
<a name="ln115"> </a>
<a name="ln116">  // split_op_id is the ID of Raft split operation requesting split of this tablet or unset.</a>
<a name="ln117">  ReplicaState(</a>
<a name="ln118">      ConsensusOptions options, std::string peer_uuid, std::unique_ptr&lt;ConsensusMetadata&gt; cmeta,</a>
<a name="ln119">      ConsensusContext* consensus_context, SafeOpIdWaiter* safe_op_id_waiter,</a>
<a name="ln120">      RetryableRequests* retryable_requests, const yb::OpId&amp; split_op_id,</a>
<a name="ln121">      std::function&lt;void(const OpIds&amp;)&gt; applied_ops_tracker);</a>
<a name="ln122"> </a>
<a name="ln123">  ~ReplicaState();</a>
<a name="ln124"> </a>
<a name="ln125">  CHECKED_STATUS StartUnlocked(const OpIdPB&amp; last_in_wal);</a>
<a name="ln126"> </a>
<a name="ln127">  // Should be used only to assert that the update_lock_ is held.</a>
<a name="ln128">  bool IsLocked() const WARN_UNUSED_RESULT;</a>
<a name="ln129"> </a>
<a name="ln130">  // Locks a replica in preparation for StartUnlocked(). Makes</a>
<a name="ln131">  // sure the replica is in kInitialized state.</a>
<a name="ln132">  CHECKED_STATUS LockForStart(UniqueLock* lock) const;</a>
<a name="ln133"> </a>
<a name="ln134">  // Locks a replica down until the critical section of an append completes,</a>
<a name="ln135">  // i.e. until the replicate message has been assigned an id and placed in</a>
<a name="ln136">  // the log queue.</a>
<a name="ln137">  // This also checks that the replica is in the appropriate</a>
<a name="ln138">  // state (role) to replicate the provided operation, that the operation</a>
<a name="ln139">  // contains a replicate message and is of the appropriate type, and returns</a>
<a name="ln140">  // Status::IllegalState if that is not the case.</a>
<a name="ln141">  CHECKED_STATUS LockForReplicate(UniqueLock* lock, const ReplicateMsg&amp; msg) const;</a>
<a name="ln142">  CHECKED_STATUS LockForReplicate(UniqueLock* lock) const;</a>
<a name="ln143"> </a>
<a name="ln144">  Status CheckIsActiveLeaderAndHasLease() const;</a>
<a name="ln145"> </a>
<a name="ln146">  // Locks a replica down until an the critical section of an update completes.</a>
<a name="ln147">  // Further updates from the same or some other leader will be blocked until</a>
<a name="ln148">  // this completes. This also checks that the replica is in the appropriate</a>
<a name="ln149">  // state (role) to be updated and returns Status::IllegalState if that</a>
<a name="ln150">  // is not the case.</a>
<a name="ln151">  CHECKED_STATUS LockForUpdate(UniqueLock* lock) const;</a>
<a name="ln152"> </a>
<a name="ln153">  // Changes the role to non-participant and returns a lock that can be</a>
<a name="ln154">  // used to make sure no state updates come in until Shutdown() is</a>
<a name="ln155">  // completed.</a>
<a name="ln156">  CHECKED_STATUS LockForShutdown(UniqueLock* lock);</a>
<a name="ln157"> </a>
<a name="ln158">  CHECKED_STATUS LockForConfigChange(UniqueLock* lock) const;</a>
<a name="ln159"> </a>
<a name="ln160">  // Obtains the lock for a state read, does not check state.</a>
<a name="ln161">  UniqueLock LockForRead() const;</a>
<a name="ln162"> </a>
<a name="ln163">  // Obtains the lock so that we can advance the majority replicated</a>
<a name="ln164">  // index and possibly the committed index.</a>
<a name="ln165">  // Requires that this peer is leader.</a>
<a name="ln166">  CHECKED_STATUS LockForMajorityReplicatedIndexUpdate(</a>
<a name="ln167">      UniqueLock* lock) const;</a>
<a name="ln168"> </a>
<a name="ln169">  // Ensure the local peer is the active leader.</a>
<a name="ln170">  // Returns OK if leader, IllegalState otherwise.</a>
<a name="ln171">  CHECKED_STATUS CheckActiveLeaderUnlocked(LeaderLeaseCheckMode lease_check_mode) const;</a>
<a name="ln172"> </a>
<a name="ln173">  LeaderState GetLeaderState(bool allow_stale = false) const;</a>
<a name="ln174"> </a>
<a name="ln175">  // now is used as a cache for current time. It is in/out parameter and could contain or receive</a>
<a name="ln176">  // current time if it was used during leader state calculation.</a>
<a name="ln177">  LeaderState GetLeaderStateUnlocked(</a>
<a name="ln178">      LeaderLeaseCheckMode lease_check_mode = LeaderLeaseCheckMode::NEED_LEASE,</a>
<a name="ln179">      CoarseTimePoint* now = nullptr) const;</a>
<a name="ln180"> </a>
<a name="ln181">  // Completes the Shutdown() of this replica. No more operations, local</a>
<a name="ln182">  // or otherwise can happen after this point.</a>
<a name="ln183">  // Called after the quiescing phase (started with LockForShutdown())</a>
<a name="ln184">  // finishes.</a>
<a name="ln185">  CHECKED_STATUS ShutdownUnlocked();</a>
<a name="ln186"> </a>
<a name="ln187">  // Return current consensus state summary.</a>
<a name="ln188">  ConsensusStatePB ConsensusStateUnlocked(ConsensusConfigType type) const;</a>
<a name="ln189"> </a>
<a name="ln190">  // Returns the currently active Raft role.</a>
<a name="ln191">  RaftPeerPB::Role GetActiveRoleUnlocked() const;</a>
<a name="ln192"> </a>
<a name="ln193">  // Returns true if there is a configuration change currently in-flight but not yet</a>
<a name="ln194">  // committed.</a>
<a name="ln195">  bool IsConfigChangePendingUnlocked() const;</a>
<a name="ln196"> </a>
<a name="ln197">  // Inverse of IsConfigChangePendingUnlocked(): returns OK if there is</a>
<a name="ln198">  // currently *no* configuration change pending, and IllegalState is there *is* a</a>
<a name="ln199">  // configuration change pending.</a>
<a name="ln200">  CHECKED_STATUS CheckNoConfigChangePendingUnlocked() const;</a>
<a name="ln201"> </a>
<a name="ln202">  // Returns true if an operation is in this replica's log, namely:</a>
<a name="ln203">  // - If the op's index is lower than or equal to our committed index</a>
<a name="ln204">  // - If the op id matches an inflight op.</a>
<a name="ln205">  // If an operation with the same index is in our log but the terms</a>
<a name="ln206">  // are different 'term_mismatch' is set to true, it is false otherwise.</a>
<a name="ln207">  bool IsOpCommittedOrPending(const yb::OpId&amp; op_id, bool* term_mismatch);</a>
<a name="ln208"> </a>
<a name="ln209">  // Sets the given configuration as pending commit. Does not persist into the peers</a>
<a name="ln210">  // metadata. In order to be persisted, SetCommittedConfigUnlocked() must be called.</a>
<a name="ln211">  CHECKED_STATUS SetPendingConfigUnlocked(const RaftConfigPB&amp; new_config);</a>
<a name="ln212"> </a>
<a name="ln213">  // Clears the pending config.</a>
<a name="ln214">  CHECKED_STATUS ClearPendingConfigUnlocked();</a>
<a name="ln215"> </a>
<a name="ln216">  // Return the pending configuration, or crash if one is not set.</a>
<a name="ln217">  const RaftConfigPB&amp; GetPendingConfigUnlocked() const;</a>
<a name="ln218"> </a>
<a name="ln219">  // Changes the committed config for this replica. Checks that there is a</a>
<a name="ln220">  // pending configuration and that it is equal to this one. Persists changes to disk.</a>
<a name="ln221">  // Resets the pending configuration to null.</a>
<a name="ln222">  CHECKED_STATUS SetCommittedConfigUnlocked(const RaftConfigPB&amp; new_config);</a>
<a name="ln223"> </a>
<a name="ln224">  // Return the persisted configuration.</a>
<a name="ln225">  const RaftConfigPB&amp; GetCommittedConfigUnlocked() const;</a>
<a name="ln226"> </a>
<a name="ln227">  // Return the &quot;active&quot; configuration - if there is a pending configuration return it;</a>
<a name="ln228">  // otherwise return the committed configuration.</a>
<a name="ln229">  const RaftConfigPB&amp; GetActiveConfigUnlocked() const;</a>
<a name="ln230"> </a>
<a name="ln231">  // Checks if the term change is legal. If so, sets 'current_term'</a>
<a name="ln232">  // to 'new_term' and sets 'has voted' to no for the current term.</a>
<a name="ln233">  CHECKED_STATUS SetCurrentTermUnlocked(int64_t new_term);</a>
<a name="ln234"> </a>
<a name="ln235">  // Returns the term set in the last config change round.</a>
<a name="ln236">  const int64_t GetCurrentTermUnlocked() const;</a>
<a name="ln237"> </a>
<a name="ln238">  // Accessors for the leader of the current term.</a>
<a name="ln239">  void SetLeaderUuidUnlocked(const std::string&amp; uuid);</a>
<a name="ln240">  const std::string&amp; GetLeaderUuidUnlocked() const;</a>
<a name="ln241">  bool HasLeaderUnlocked() const { return !GetLeaderUuidUnlocked().empty(); }</a>
<a name="ln242">  void ClearLeaderUnlocked() { SetLeaderUuidUnlocked(&quot;&quot;); }</a>
<a name="ln243"> </a>
<a name="ln244">  // Return whether this peer has voted in the current term.</a>
<a name="ln245">  const bool HasVotedCurrentTermUnlocked() const;</a>
<a name="ln246"> </a>
<a name="ln247">  // Record replica's vote for the current term, then flush the consensus</a>
<a name="ln248">  // metadata to disk.</a>
<a name="ln249">  CHECKED_STATUS SetVotedForCurrentTermUnlocked(const std::string&amp; uuid);</a>
<a name="ln250"> </a>
<a name="ln251">  // Return replica's vote for the current term.</a>
<a name="ln252">  // The vote must be set; use HasVotedCurrentTermUnlocked() to check.</a>
<a name="ln253">  const std::string&amp; GetVotedForCurrentTermUnlocked() const;</a>
<a name="ln254"> </a>
<a name="ln255">  ConsensusContext* context() const {</a>
<a name="ln256">    return context_;</a>
<a name="ln257">  }</a>
<a name="ln258"> </a>
<a name="ln259">  // Returns the uuid of the peer to which this replica state belongs.</a>
<a name="ln260">  // Safe to call with or without locks held.</a>
<a name="ln261">  const std::string&amp; GetPeerUuid() const;</a>
<a name="ln262"> </a>
<a name="ln263">  const ConsensusOptions&amp; GetOptions() const;</a>
<a name="ln264"> </a>
<a name="ln265">  // Aborts pending operations after, but not including 'index'. The OpId with 'index'</a>
<a name="ln266">  // will become our new last received id. If there are pending operations with indexes</a>
<a name="ln267">  // higher than 'index' those operations are aborted.</a>
<a name="ln268">  CHECKED_STATUS AbortOpsAfterUnlocked(int64_t index);</a>
<a name="ln269"> </a>
<a name="ln270">  // Returns the ConsensusRound with the provided index, if there is any, or NULL</a>
<a name="ln271">  // if there isn't.</a>
<a name="ln272">  scoped_refptr&lt;ConsensusRound&gt; GetPendingOpByIndexOrNullUnlocked(int64_t index);</a>
<a name="ln273"> </a>
<a name="ln274">  // Add 'round' to the set of rounds waiting to be committed.</a>
<a name="ln275">  CHECKED_STATUS AddPendingOperation(const scoped_refptr&lt;ConsensusRound&gt;&amp; round);</a>
<a name="ln276"> </a>
<a name="ln277">  // Marks ReplicaOperations up to 'id' as majority replicated, meaning the</a>
<a name="ln278">  // transaction may Apply() (immediately if Prepare() has completed or when Prepare()</a>
<a name="ln279">  // completes, if not).</a>
<a name="ln280">  //</a>
<a name="ln281">  // If this advanced the committed index, sets *committed_op_id_changed to true.</a>
<a name="ln282">  CHECKED_STATUS UpdateMajorityReplicatedUnlocked(</a>
<a name="ln283">      const OpIdPB&amp; majority_replicated, OpIdPB* committed_op_id, bool* committed_op_id_changed);</a>
<a name="ln284"> </a>
<a name="ln285">  // Advances the committed index.</a>
<a name="ln286">  // This is a no-op if the committed index has not changed.</a>
<a name="ln287">  // Returns in whether the operation actually advanced the index.</a>
<a name="ln288">  Result&lt;bool&gt; AdvanceCommittedOpIdUnlocked(const yb::OpId&amp; committed_op_id, CouldStop could_stop);</a>
<a name="ln289"> </a>
<a name="ln290">  // Initializes the committed index.</a>
<a name="ln291">  // Function checks that we are in initial state, then updates committed index.</a>
<a name="ln292">  CHECKED_STATUS InitCommittedOpIdUnlocked(const yb::OpId&amp; committed_op_id);</a>
<a name="ln293"> </a>
<a name="ln294">  // Returns the watermark below which all operations are known to</a>
<a name="ln295">  // be committed according to consensus.</a>
<a name="ln296">  //</a>
<a name="ln297">  // This must be called under a lock.</a>
<a name="ln298">  const yb::OpId&amp; GetCommittedOpIdUnlocked() const;</a>
<a name="ln299"> </a>
<a name="ln300">  // Returns the ID of the split operation requesting to split this Raft group if it has been added</a>
<a name="ln301">  // to Raft log and uninitialized OpId otherwise.</a>
<a name="ln302">  const yb::OpId&amp; GetSplitOpIdUnlocked() const;</a>
<a name="ln303"> </a>
<a name="ln304">  // Makes split_op_id uninitialized. To be used on split operation abort.</a>
<a name="ln305">  void ResetSplitOpIdUnlocked();</a>
<a name="ln306"> </a>
<a name="ln307">  // Returns true if an op from the current term has been committed.</a>
<a name="ln308">  bool AreCommittedAndCurrentTermsSameUnlocked() const;</a>
<a name="ln309"> </a>
<a name="ln310">  // Updates the last received operation.</a>
<a name="ln311">  // This must be called under a lock.</a>
<a name="ln312">  void UpdateLastReceivedOpIdUnlocked(const OpIdPB&amp; op_id);</a>
<a name="ln313"> </a>
<a name="ln314">  // Returns the last received op id. This must be called under the lock.</a>
<a name="ln315">  const yb::OpId&amp; GetLastReceivedOpIdUnlocked() const;</a>
<a name="ln316"> </a>
<a name="ln317">  // Returns the id of the last op received from the current leader.</a>
<a name="ln318">  const yb::OpId&amp; GetLastReceivedOpIdCurLeaderUnlocked() const;</a>
<a name="ln319"> </a>
<a name="ln320">  // Returns the id of the latest pending transaction (i.e. the one with the</a>
<a name="ln321">  // latest index). This must be called under the lock.</a>
<a name="ln322">  OpIdPB GetLastPendingOperationOpIdUnlocked() const;</a>
<a name="ln323"> </a>
<a name="ln324">  // Used by replicas to cancel pending transactions. Pending transaction are those</a>
<a name="ln325">  // that have completed prepare/replicate but are waiting on the LEADER's commit</a>
<a name="ln326">  // to complete. This does not cancel transactions being applied.</a>
<a name="ln327">  CHECKED_STATUS CancelPendingOperations();</a>
<a name="ln328"> </a>
<a name="ln329">  // API to dump pending transactions. Added to debug ENG-520.</a>
<a name="ln330">  void DumpPendingOperationsUnlocked();</a>
<a name="ln331"> </a>
<a name="ln332">  yb::OpId NewIdUnlocked();</a>
<a name="ln333"> </a>
<a name="ln334">  // Used when, for some reason, an operation that failed before it could be considered</a>
<a name="ln335">  // a part of the state machine. Basically restores the id gen to the state it was before</a>
<a name="ln336">  // generating 'id'. So that we reuse these ids later, when we can actually append to the</a>
<a name="ln337">  // state machine. This makes the state machine have continuous ids for the same term, even if</a>
<a name="ln338">  // the queue refused to add any more operations.</a>
<a name="ln339">  // should_exists indicates whether we expect that this operation is already added.</a>
<a name="ln340">  // Used for debugging purposes only.</a>
<a name="ln341">  void CancelPendingOperation(const OpIdPB&amp; id, bool should_exist);</a>
<a name="ln342"> </a>
<a name="ln343">  // Accessors for pending election op id. These must be called under a lock.</a>
<a name="ln344">  const OpIdPB&amp; GetPendingElectionOpIdUnlocked() { return pending_election_opid_; }</a>
<a name="ln345">  void SetPendingElectionOpIdUnlocked(const OpIdPB&amp; opid) { pending_election_opid_ = opid; }</a>
<a name="ln346">  void ClearPendingElectionOpIdUnlocked() { pending_election_opid_.Clear(); }</a>
<a name="ln347"> </a>
<a name="ln348">  std::string ToString() const;</a>
<a name="ln349">  std::string ToStringUnlocked() const;</a>
<a name="ln350"> </a>
<a name="ln351">  // A common prefix that should be in any log messages emitted,</a>
<a name="ln352">  // identifying the tablet and peer.</a>
<a name="ln353">  std::string LogPrefix() const;</a>
<a name="ln354"> </a>
<a name="ln355">  // Checks that 'current' correctly follows 'previous'. Specifically it checks</a>
<a name="ln356">  // that the term is the same or higher and that the index is sequential.</a>
<a name="ln357">  static CHECKED_STATUS CheckOpInSequence(const yb::OpId&amp; previous, const yb::OpId&amp; current);</a>
<a name="ln358"> </a>
<a name="ln359">  // Return the current state of this object.</a>
<a name="ln360">  // The update_lock_ must be held.</a>
<a name="ln361">  ReplicaState::State state() const;</a>
<a name="ln362"> </a>
<a name="ln363">  // Update the point in time we have to wait until before starting to act as a leader in case</a>
<a name="ln364">  // we win an election.</a>
<a name="ln365">  void UpdateOldLeaderLeaseExpirationOnNonLeaderUnlocked(</a>
<a name="ln366">      const CoarseTimeLease&amp; lease, const PhysicalComponentLease&amp; ht_lease);</a>
<a name="ln367"> </a>
<a name="ln368">  void SetMajorityReplicatedLeaseExpirationUnlocked(</a>
<a name="ln369">      const MajorityReplicatedData&amp; majority_replicated_data,</a>
<a name="ln370">      EnumBitSet&lt;SetMajorityReplicatedLeaseExpirationFlag&gt; flags);</a>
<a name="ln371"> </a>
<a name="ln372">  // Checks two conditions:</a>
<a name="ln373">  // - That the old leader definitely does not have a lease.</a>
<a name="ln374">  // - That this leader has a committed lease.</a>
<a name="ln375">  LeaderLeaseStatus GetLeaderLeaseStatusUnlocked(</a>
<a name="ln376">      MonoDelta* remaining_old_leader_lease = nullptr, CoarseTimePoint* now = nullptr) const;</a>
<a name="ln377"> </a>
<a name="ln378">  LeaderLeaseStatus GetHybridTimeLeaseStatusAtUnlocked(MicrosTime micros_time) const;</a>
<a name="ln379"> </a>
<a name="ln380">  // Get the remaining duration of the old leader's lease. Optionally, return the current time in</a>
<a name="ln381">  // the &quot;now&quot; output parameter. In case the old leader's lease has already expired or is not known,</a>
<a name="ln382">  // returns an uninitialized MonoDelta value.</a>
<a name="ln383">  MonoDelta RemainingOldLeaderLeaseDuration(CoarseTimePoint* now = nullptr) const;</a>
<a name="ln384"> </a>
<a name="ln385">  const PhysicalComponentLease&amp; old_leader_ht_lease() const {</a>
<a name="ln386">    return old_leader_ht_lease_;</a>
<a name="ln387">  }</a>
<a name="ln388"> </a>
<a name="ln389">  const CoarseTimeLease&amp; old_leader_lease() const {</a>
<a name="ln390">    return old_leader_lease_;</a>
<a name="ln391">  }</a>
<a name="ln392"> </a>
<a name="ln393">  bool MajorityReplicatedLeaderLeaseExpired(CoarseTimePoint* now = nullptr) const;</a>
<a name="ln394"> </a>
<a name="ln395">  bool MajorityReplicatedHybridTimeLeaseExpiredAt(MicrosTime hybrid_time) const;</a>
<a name="ln396"> </a>
<a name="ln397">  // Get the current majority-replicated hybrid time leader lease expiration time as a microsecond</a>
<a name="ln398">  // timestamp.</a>
<a name="ln399">  // @param min_allowed - will wait until the majority-replicated hybrid time leader lease reaches</a>
<a name="ln400">  //                      at least this microsecond timestamp.</a>
<a name="ln401">  // @param deadline - won't wait past this deadline.</a>
<a name="ln402">  // @return leader lease or 0 if timed out.</a>
<a name="ln403">  MicrosTime MajorityReplicatedHtLeaseExpiration(</a>
<a name="ln404">      MicrosTime min_allowed, CoarseTimePoint deadline) const;</a>
<a name="ln405"> </a>
<a name="ln406">  // The on-disk size of the consensus metadata.</a>
<a name="ln407">  uint64_t OnDiskSize() const;</a>
<a name="ln408"> </a>
<a name="ln409">  yb::OpId MinRetryableRequestOpId();</a>
<a name="ln410"> </a>
<a name="ln411">  RestartSafeCoarseMonoClock&amp; Clock();</a>
<a name="ln412"> </a>
<a name="ln413">  RetryableRequestsCounts TEST_CountRetryableRequests();</a>
<a name="ln414"> </a>
<a name="ln415">  void SetLeaderNoOpCommittedUnlocked(bool value);</a>
<a name="ln416"> </a>
<a name="ln417"> private:</a>
<a name="ln418">  typedef std::deque&lt;ConsensusRoundPtr&gt; PendingOperations;</a>
<a name="ln419"> </a>
<a name="ln420">  template &lt;class Policy&gt;</a>
<a name="ln421">  LeaderLeaseStatus GetLeaseStatusUnlocked(Policy policy) const;</a>
<a name="ln422"> </a>
<a name="ln423">  // Apply pending operations beginning at iter up to and including committed_op_id.</a>
<a name="ln424">  // Updates last_committed_op_id_ to committed_op_id.</a>
<a name="ln425">  CHECKED_STATUS ApplyPendingOperationsUnlocked(</a>
<a name="ln426">      const yb::OpId&amp; committed_op_id, CouldStop could_stop);</a>
<a name="ln427"> </a>
<a name="ln428">  void SetLastCommittedIndexUnlocked(const yb::OpId&amp; committed_op_id);</a>
<a name="ln429"> </a>
<a name="ln430">  // Applies committed config change.</a>
<a name="ln431">  void ApplyConfigChangeUnlocked(const ConsensusRoundPtr&amp; round);</a>
<a name="ln432"> </a>
<a name="ln433">  void NotifyReplicationFinishedUnlocked(</a>
<a name="ln434">      const ConsensusRoundPtr&amp; round, const Status&amp; status, int64_t leader_term,</a>
<a name="ln435">      OpIds* applied_op_ids);</a>
<a name="ln436"> </a>
<a name="ln437">  consensus::LeaderState RefreshLeaderStateCacheUnlocked(</a>
<a name="ln438">      CoarseTimePoint* now) const ATTRIBUTE_NONNULL(2);</a>
<a name="ln439"> </a>
<a name="ln440">  PendingOperations::iterator FindPendingOperation(int64_t index);</a>
<a name="ln441"> </a>
<a name="ln442">  const ConsensusOptions options_;</a>
<a name="ln443"> </a>
<a name="ln444">  // The UUID of the local peer.</a>
<a name="ln445">  const std::string peer_uuid_;</a>
<a name="ln446"> </a>
<a name="ln447">  mutable std::mutex update_lock_;</a>
<a name="ln448">  mutable std::condition_variable cond_;</a>
<a name="ln449"> </a>
<a name="ln450">  // Consensus metadata persistence object.</a>
<a name="ln451">  std::unique_ptr&lt;ConsensusMetadata&gt; cmeta_;</a>
<a name="ln452"> </a>
<a name="ln453">  // Used by the LEADER. This is the index of the next operation generated</a>
<a name="ln454">  // by this LEADER.</a>
<a name="ln455">  int64_t next_index_ = 0;</a>
<a name="ln456"> </a>
<a name="ln457">  // Queue of pending operations. Ordered by growing operation index.</a>
<a name="ln458">  PendingOperations pending_operations_;</a>
<a name="ln459"> </a>
<a name="ln460">  // When we receive a message from a remote peer telling us to start a operation, we use</a>
<a name="ln461">  // this factory to start it.</a>
<a name="ln462">  ConsensusContext* context_;</a>
<a name="ln463"> </a>
<a name="ln464">  // Used to wait for safe op id during apply of committed entries.</a>
<a name="ln465">  SafeOpIdWaiter* safe_op_id_waiter_;</a>
<a name="ln466"> </a>
<a name="ln467">  // The id of the last received operation, which corresponds to the last entry</a>
<a name="ln468">  // written to the local log. Operations whose id is lower than or equal to</a>
<a name="ln469">  // this id do not need to be resent by the leader. This is not guaranteed to</a>
<a name="ln470">  // be monotonically increasing due to the possibility for log truncation and</a>
<a name="ln471">  // aborted operations when a leader change occurs.</a>
<a name="ln472">  yb::OpId last_received_op_id_;</a>
<a name="ln473"> </a>
<a name="ln474">  // Same as last_received_op_id_ but only includes operations sent by the</a>
<a name="ln475">  // current leader. The &quot;term&quot; in this op may not actually match the current</a>
<a name="ln476">  // term, since leaders may replicate ops from prior terms.</a>
<a name="ln477">  //</a>
<a name="ln478">  // As an implementation detail, this field is reset to MinumumOpId() every</a>
<a name="ln479">  // time there is a term advancement on the local node, to simplify the logic</a>
<a name="ln480">  // involved in resetting this every time a new node becomes leader.</a>
<a name="ln481">  yb::OpId last_received_op_id_current_leader_;</a>
<a name="ln482"> </a>
<a name="ln483">  // The id of the Apply that was last triggered when the last message from the leader</a>
<a name="ln484">  // was received. Initialized to MinimumOpId().</a>
<a name="ln485">  yb::OpId last_committed_op_id_;</a>
<a name="ln486"> </a>
<a name="ln487">  // The id of the split operation requesting to split this tablet. This is set when split</a>
<a name="ln488">  // operation is added to log and cleared if this operation is aborted.</a>
<a name="ln489">  // Apply of tablet split operation does not change split_op_id_.</a>
<a name="ln490">  //</a>
<a name="ln491">  // Note: In tablets created as a result of split operation split_op_id_ is uninitialized until</a>
<a name="ln492">  // split operation requesting to split them will be added to their Raft log.</a>
<a name="ln493">  // After n-th split the latest after-split tablet created could have n split operations in its</a>
<a name="ln494">  // Raft log, but split_op_id will be uninitialized, because all these split operations are</a>
<a name="ln495">  // designated for &quot;ancestors&quot; of this tablet, but not for this tablet itself.</a>
<a name="ln496">  yb::OpId split_op_id_;</a>
<a name="ln497"> </a>
<a name="ln498">  // If set, a leader election is pending upon the specific op id commitment to this peer's log.</a>
<a name="ln499">  OpIdPB pending_election_opid_;</a>
<a name="ln500"> </a>
<a name="ln501">  State state_ = State::kInitialized;</a>
<a name="ln502"> </a>
<a name="ln503">  // When a follower becomes the leader, it uses this field to wait out the old leader's lease</a>
<a name="ln504">  // before accepting writes or serving up-to-date reads. This is also used by candidates by</a>
<a name="ln505">  // granting a vote. We compute the amount of time the new leader has to wait to make sure the old</a>
<a name="ln506">  // leader's lease has expired.</a>
<a name="ln507">  //</a>
<a name="ln508">  // This is marked mutable because it can be reset on to MonoTime::kMin on the read path after the</a>
<a name="ln509">  // deadline has passed, so that we avoid querying the clock unnecessarily from that point on.</a>
<a name="ln510">  mutable CoarseTimeLease old_leader_lease_;</a>
<a name="ln511"> </a>
<a name="ln512">  // The same as old_leader_lease_ but for hybrid time.</a>
<a name="ln513">  mutable PhysicalComponentLease old_leader_ht_lease_;</a>
<a name="ln514"> </a>
<a name="ln515">  // LEADER only: the latest committed lease expiration deadline for the current leader. The leader</a>
<a name="ln516">  // is allowed to serve up-to-date reads and accept writes only while the current time is less than</a>
<a name="ln517">  // this. However, the leader might manage to replicate a lease extension without losing its</a>
<a name="ln518">  // leadership.</a>
<a name="ln519">  CoarseTimePoint majority_replicated_lease_expiration_;</a>
<a name="ln520"> </a>
<a name="ln521">  // LEADER only: the latest committed hybrid time lease expiration deadline for the current leader.</a>
<a name="ln522">  // The leader is allowed to add new log entries only when lease of old leader is expired.</a>
<a name="ln523">  std::atomic&lt;MicrosTime&gt; majority_replicated_ht_lease_expiration_{</a>
<a name="ln524">      PhysicalComponentLease::NoneValue()};</a>
<a name="ln525"> </a>
<a name="ln526">  RetryableRequests retryable_requests_;</a>
<a name="ln527"> </a>
<a name="ln528">  // This leader is ready to serve only if NoOp was successfully committed</a>
<a name="ln529">  // after the new leader successful election.</a>
<a name="ln530">  bool leader_no_op_committed_ = false;</a>
<a name="ln531"> </a>
<a name="ln532">  std::function&lt;void(const OpIds&amp;)&gt; applied_ops_tracker_;</a>
<a name="ln533"> </a>
<a name="ln534">  struct LeaderStateCache {</a>
<a name="ln535">    static constexpr size_t kStatusBits = 3;</a>
<a name="ln536">    static_assert(kLeaderStatusMapSize &lt;= (1 &lt;&lt; kStatusBits),</a>
<a name="ln537">                  &quot;Leader status does not fit into kStatusBits&quot;);</a>
<a name="ln538"> </a>
<a name="ln539">    static constexpr uint64_t kStatusMask = (1 &lt;&lt; kStatusBits) -1;</a>
<a name="ln540"> </a>
<a name="ln541">    // Packed status consists on LeaderStatus and an extra value.</a>
<a name="ln542">    // Extra value meaning depends on actual status:</a>
<a name="ln543">    // LEADER_AND_READY: leader term.</a>
<a name="ln544">    // LEADER_BUT_OLD_LEADER_MAY_HAVE_LEASE: number of microseconds in remaining_old_leader_lease.</a>
<a name="ln545">    uint64_t packed_status;</a>
<a name="ln546">    CoarseTimePoint expire_at;</a>
<a name="ln547"> </a>
<a name="ln548">    LeaderStateCache() noexcept {}</a>
<a name="ln549"> </a>
<a name="ln550">    LeaderStatus status() const {</a>
<a name="ln551">      return static_cast&lt;LeaderStatus&gt;(packed_status &amp; kStatusMask);</a>
<a name="ln552">    }</a>
<a name="ln553"> </a>
<a name="ln554">    uint64_t extra_value() const {</a>
<a name="ln555">      return packed_status &gt;&gt; kStatusBits;</a>
<a name="ln556">    }</a>
<a name="ln557"> </a>
<a name="ln558">    void Set(LeaderStatus status, uint64_t extra_value, CoarseTimePoint expire_at_) {</a>
<a name="ln559">      DCHECK_EQ(extra_value &lt;&lt; kStatusBits &gt;&gt; kStatusBits, extra_value);</a>
<a name="ln560">      packed_status = static_cast&lt;uint64_t&gt;(status) | (extra_value &lt;&lt; kStatusBits);</a>
<a name="ln561">      expire_at = expire_at_;</a>
<a name="ln562">    }</a>
<a name="ln563">  };</a>
<a name="ln564"> </a>
<a name="ln565">  mutable boost::atomic&lt;LeaderStateCache&gt; leader_state_cache_;</a>
<a name="ln566">};</a>
<a name="ln567"> </a>
<a name="ln568">}  // namespace consensus</a>
<a name="ln569">}  // namespace yb</a>
<a name="ln570"> </a>
<a name="ln571">#endif // YB_CONSENSUS_REPLICA_STATE_H_</a>

</code></pre>
<div class="balloon" rel="548"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: packed_status.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
