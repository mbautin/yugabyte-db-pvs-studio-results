
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>multi_index_container.hpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* Multiply indexed container.</a>
<a name="ln2"> *</a>
<a name="ln3"> * Copyright 2003-2018 Joaquin M Lopez Munoz.</a>
<a name="ln4"> * Distributed under the Boost Software License, Version 1.0.</a>
<a name="ln5"> * (See accompanying file LICENSE_1_0.txt or copy at</a>
<a name="ln6"> * http://www.boost.org/LICENSE_1_0.txt)</a>
<a name="ln7"> *</a>
<a name="ln8"> * See http://www.boost.org/libs/multi_index for library home page.</a>
<a name="ln9"> */</a>
<a name="ln10"> </a>
<a name="ln11">#ifndef BOOST_MULTI_INDEX_HPP</a>
<a name="ln12">#define BOOST_MULTI_INDEX_HPP</a>
<a name="ln13"> </a>
<a name="ln14">#if defined(_MSC_VER)</a>
<a name="ln15">#pragma once</a>
<a name="ln16">#endif</a>
<a name="ln17"> </a>
<a name="ln18">#include &lt;boost/config.hpp&gt; /* keep it first to prevent nasty warns in MSVC */</a>
<a name="ln19">#include &lt;algorithm&gt;</a>
<a name="ln20">#include &lt;memory&gt;</a>
<a name="ln21">#include &lt;boost/core/addressof.hpp&gt;</a>
<a name="ln22">#include &lt;boost/detail/allocator_utilities.hpp&gt;</a>
<a name="ln23">#include &lt;boost/detail/no_exceptions_support.hpp&gt;</a>
<a name="ln24">#include &lt;boost/detail/workaround.hpp&gt;</a>
<a name="ln25">#include &lt;boost/move/core.hpp&gt;</a>
<a name="ln26">#include &lt;boost/mpl/at.hpp&gt;</a>
<a name="ln27">#include &lt;boost/mpl/contains.hpp&gt;</a>
<a name="ln28">#include &lt;boost/mpl/find_if.hpp&gt;</a>
<a name="ln29">#include &lt;boost/mpl/identity.hpp&gt;</a>
<a name="ln30">#include &lt;boost/mpl/int.hpp&gt;</a>
<a name="ln31">#include &lt;boost/mpl/size.hpp&gt;</a>
<a name="ln32">#include &lt;boost/mpl/deref.hpp&gt;</a>
<a name="ln33">#include &lt;boost/multi_index_container_fwd.hpp&gt;</a>
<a name="ln34">#include &lt;boost/multi_index/detail/access_specifier.hpp&gt;</a>
<a name="ln35">#include &lt;boost/multi_index/detail/adl_swap.hpp&gt;</a>
<a name="ln36">#include &lt;boost/multi_index/detail/base_type.hpp&gt;</a>
<a name="ln37">#include &lt;boost/multi_index/detail/do_not_copy_elements_tag.hpp&gt;</a>
<a name="ln38">#include &lt;boost/multi_index/detail/converter.hpp&gt;</a>
<a name="ln39">#include &lt;boost/multi_index/detail/header_holder.hpp&gt;</a>
<a name="ln40">#include &lt;boost/multi_index/detail/has_tag.hpp&gt;</a>
<a name="ln41">#include &lt;boost/multi_index/detail/no_duplicate_tags.hpp&gt;</a>
<a name="ln42">#include &lt;boost/multi_index/detail/safe_mode.hpp&gt;</a>
<a name="ln43">#include &lt;boost/multi_index/detail/scope_guard.hpp&gt;</a>
<a name="ln44">#include &lt;boost/multi_index/detail/vartempl_support.hpp&gt;</a>
<a name="ln45">#include &lt;boost/static_assert.hpp&gt;</a>
<a name="ln46">#include &lt;boost/type_traits/is_same.hpp&gt;</a>
<a name="ln47">#include &lt;boost/utility/base_from_member.hpp&gt;</a>
<a name="ln48"> </a>
<a name="ln49">#if !defined(BOOST_NO_CXX11_HDR_INITIALIZER_LIST)</a>
<a name="ln50">#include &lt;initializer_list&gt;</a>
<a name="ln51">#endif</a>
<a name="ln52"> </a>
<a name="ln53">#if !defined(BOOST_MULTI_INDEX_DISABLE_SERIALIZATION)</a>
<a name="ln54">#include &lt;boost/multi_index/detail/archive_constructed.hpp&gt;</a>
<a name="ln55">#include &lt;boost/multi_index/detail/serialization_version.hpp&gt;</a>
<a name="ln56">#include &lt;boost/serialization/collection_size_type.hpp&gt;</a>
<a name="ln57">#include &lt;boost/serialization/nvp.hpp&gt;</a>
<a name="ln58">#include &lt;boost/serialization/split_member.hpp&gt;</a>
<a name="ln59">#include &lt;boost/serialization/version.hpp&gt;</a>
<a name="ln60">#include &lt;boost/throw_exception.hpp&gt; </a>
<a name="ln61">#endif</a>
<a name="ln62"> </a>
<a name="ln63">#if defined(BOOST_MULTI_INDEX_ENABLE_INVARIANT_CHECKING)</a>
<a name="ln64">#include &lt;boost/multi_index/detail/invariant_assert.hpp&gt;</a>
<a name="ln65">#define BOOST_MULTI_INDEX_CHECK_INVARIANT_OF(x)                              \</a>
<a name="ln66">  detail::scope_guard BOOST_JOIN(check_invariant_,__LINE__)=                 \</a>
<a name="ln67">    detail::make_obj_guard(x,&amp;multi_index_container::check_invariant_);      \</a>
<a name="ln68">  BOOST_JOIN(check_invariant_,__LINE__).touch();</a>
<a name="ln69">#define BOOST_MULTI_INDEX_CHECK_INVARIANT                                    \</a>
<a name="ln70">  BOOST_MULTI_INDEX_CHECK_INVARIANT_OF(*this)</a>
<a name="ln71">#else</a>
<a name="ln72">#define BOOST_MULTI_INDEX_CHECK_INVARIANT_OF(x)</a>
<a name="ln73">#define BOOST_MULTI_INDEX_CHECK_INVARIANT</a>
<a name="ln74">#endif</a>
<a name="ln75"> </a>
<a name="ln76">namespace boost{</a>
<a name="ln77"> </a>
<a name="ln78">namespace multi_index{</a>
<a name="ln79"> </a>
<a name="ln80">#if BOOST_WORKAROUND(BOOST_MSVC,BOOST_TESTED_AT(1500))</a>
<a name="ln81">#pragma warning(push)</a>
<a name="ln82">#pragma warning(disable:4522) /* spurious warning on multiple operator=()'s */</a>
<a name="ln83">#endif</a>
<a name="ln84"> </a>
<a name="ln85">template&lt;typename Value,typename IndexSpecifierList,typename Allocator&gt;</a>
<a name="ln86">class multi_index_container:</a>
<a name="ln87">  private ::boost::base_from_member&lt;</a>
<a name="ln88">    typename boost::detail::allocator::rebind_to&lt;</a>
<a name="ln89">      Allocator,</a>
<a name="ln90">      typename detail::multi_index_node_type&lt;</a>
<a name="ln91">        Value,IndexSpecifierList,Allocator&gt;::type</a>
<a name="ln92">    &gt;::type&gt;,</a>
<a name="ln93">  BOOST_MULTI_INDEX_PRIVATE_IF_MEMBER_TEMPLATE_FRIENDS detail::header_holder&lt;</a>
<a name="ln94">#ifndef BOOST_NO_CXX11_ALLOCATOR</a>
<a name="ln95">    typename std::allocator_traits&lt;</a>
<a name="ln96">#endif</a>
<a name="ln97">      typename boost::detail::allocator::rebind_to&lt;</a>
<a name="ln98">        Allocator,</a>
<a name="ln99">        typename detail::multi_index_node_type&lt;</a>
<a name="ln100">          Value,IndexSpecifierList,Allocator&gt;::type</a>
<a name="ln101">      &gt;::type</a>
<a name="ln102">#ifdef BOOST_NO_CXX11_ALLOCATOR</a>
<a name="ln103">    ::pointer,</a>
<a name="ln104">#else</a>
<a name="ln105">    &gt;::pointer,</a>
<a name="ln106">#endif</a>
<a name="ln107">    multi_index_container&lt;Value,IndexSpecifierList,Allocator&gt; &gt;,</a>
<a name="ln108">  public detail::multi_index_base_type&lt;</a>
<a name="ln109">    Value,IndexSpecifierList,Allocator&gt;::type</a>
<a name="ln110">{</a>
<a name="ln111">#if defined(BOOST_MULTI_INDEX_ENABLE_INVARIANT_CHECKING)&amp;&amp;\</a>
<a name="ln112">    BOOST_WORKAROUND(__MWERKS__,&lt;=0x3003)</a>
<a name="ln113">/* The &quot;ISO C++ Template Parser&quot; option in CW8.3 has a problem with the</a>
<a name="ln114"> * lifetime of const references bound to temporaries --precisely what</a>
<a name="ln115"> * scopeguards are.</a>
<a name="ln116"> */</a>
<a name="ln117"> </a>
<a name="ln118">#pragma parse_mfunc_templ off</a>
<a name="ln119">#endif</a>
<a name="ln120"> </a>
<a name="ln121">private:</a>
<a name="ln122">  BOOST_COPYABLE_AND_MOVABLE(multi_index_container)</a>
<a name="ln123"> </a>
<a name="ln124">#if !defined(BOOST_NO_MEMBER_TEMPLATE_FRIENDS)</a>
<a name="ln125">  template &lt;typename,typename,typename&gt; friend class  detail::index_base;</a>
<a name="ln126">  template &lt;typename,typename&gt;          friend struct detail::header_holder;</a>
<a name="ln127">  template &lt;typename,typename&gt;          friend struct detail::converter;</a>
<a name="ln128">#endif</a>
<a name="ln129"> </a>
<a name="ln130">  typedef typename detail::multi_index_base_type&lt;</a>
<a name="ln131">      Value,IndexSpecifierList,Allocator&gt;::type   super;</a>
<a name="ln132">  typedef typename</a>
<a name="ln133">  boost::detail::allocator::rebind_to&lt;</a>
<a name="ln134">    Allocator,</a>
<a name="ln135">    typename super::node_type</a>
<a name="ln136">  &gt;::type                                         node_allocator;</a>
<a name="ln137">#ifdef BOOST_NO_CXX11_ALLOCATOR</a>
<a name="ln138">  typedef typename node_allocator::pointer        node_pointer;</a>
<a name="ln139">#else</a>
<a name="ln140">  typedef std::allocator_traits&lt;node_allocator&gt;   node_allocator_traits;</a>
<a name="ln141">  typedef typename node_allocator_traits::pointer node_pointer;</a>
<a name="ln142">#endif</a>
<a name="ln143">  typedef ::boost::base_from_member&lt;</a>
<a name="ln144">    node_allocator&gt;                               bfm_allocator;</a>
<a name="ln145">  typedef detail::header_holder&lt;</a>
<a name="ln146">    node_pointer,</a>
<a name="ln147">    multi_index_container&gt;                        bfm_header;</a>
<a name="ln148"> </a>
<a name="ln149">public:</a>
<a name="ln150">  /* All types are inherited from super, a few are explicitly</a>
<a name="ln151">   * brought forward here to save us some typename's.</a>
<a name="ln152">   */</a>
<a name="ln153"> </a>
<a name="ln154">  typedef typename super::ctor_args_list           ctor_args_list;</a>
<a name="ln155">  typedef IndexSpecifierList                       index_specifier_type_list;</a>
<a name="ln156"> </a>
<a name="ln157">  typedef typename super::index_type_list          index_type_list;</a>
<a name="ln158"> </a>
<a name="ln159">  typedef typename super::iterator_type_list       iterator_type_list;</a>
<a name="ln160">  typedef typename super::const_iterator_type_list const_iterator_type_list;</a>
<a name="ln161">  typedef typename super::value_type               value_type;</a>
<a name="ln162">  typedef typename super::final_allocator_type     allocator_type;</a>
<a name="ln163">  typedef typename super::iterator                 iterator;</a>
<a name="ln164">  typedef typename super::const_iterator           const_iterator;</a>
<a name="ln165"> </a>
<a name="ln166">  BOOST_STATIC_ASSERT(</a>
<a name="ln167">    detail::no_duplicate_tags_in_index_list&lt;index_type_list&gt;::value);</a>
<a name="ln168"> </a>
<a name="ln169">  /* global project() needs to see this publicly */</a>
<a name="ln170"> </a>
<a name="ln171">  typedef typename super::node_type node_type;</a>
<a name="ln172"> </a>
<a name="ln173">  /* construct/copy/destroy */</a>
<a name="ln174"> </a>
<a name="ln175">  multi_index_container():</a>
<a name="ln176">    bfm_allocator(allocator_type()),</a>
<a name="ln177">    super(ctor_args_list(),bfm_allocator::member),</a>
<a name="ln178">    node_count(0)</a>
<a name="ln179">  {</a>
<a name="ln180">    BOOST_MULTI_INDEX_CHECK_INVARIANT;</a>
<a name="ln181">  }</a>
<a name="ln182"> </a>
<a name="ln183">  explicit multi_index_container(</a>
<a name="ln184">    const ctor_args_list&amp; args_list,</a>
<a name="ln185"> </a>
<a name="ln186">#if BOOST_WORKAROUND(__IBMCPP__,&lt;=600)</a>
<a name="ln187">    /* VisualAge seems to have an ETI issue with the default value for</a>
<a name="ln188">     * argument al.</a>
<a name="ln189">     */</a>
<a name="ln190"> </a>
<a name="ln191">    const allocator_type&amp; al=</a>
<a name="ln192">      typename mpl::identity&lt;multi_index_container&gt;::type::</a>
<a name="ln193">        allocator_type()):</a>
<a name="ln194">#else</a>
<a name="ln195">    const allocator_type&amp; al=allocator_type()):</a>
<a name="ln196">#endif</a>
<a name="ln197"> </a>
<a name="ln198">    bfm_allocator(al),</a>
<a name="ln199">    super(args_list,bfm_allocator::member),</a>
<a name="ln200">    node_count(0)</a>
<a name="ln201">  {</a>
<a name="ln202">    BOOST_MULTI_INDEX_CHECK_INVARIANT;</a>
<a name="ln203">  }</a>
<a name="ln204"> </a>
<a name="ln205">  explicit multi_index_container(const allocator_type&amp; al):</a>
<a name="ln206">    bfm_allocator(al),</a>
<a name="ln207">    super(ctor_args_list(),bfm_allocator::member),</a>
<a name="ln208">    node_count(0)</a>
<a name="ln209">  {</a>
<a name="ln210">    BOOST_MULTI_INDEX_CHECK_INVARIANT;</a>
<a name="ln211">  }</a>
<a name="ln212">  </a>
<a name="ln213">  template&lt;typename InputIterator&gt;</a>
<a name="ln214">  multi_index_container(</a>
<a name="ln215">    InputIterator first,InputIterator last,</a>
<a name="ln216"> </a>
<a name="ln217">#if BOOST_WORKAROUND(__IBMCPP__,&lt;=600)</a>
<a name="ln218">    /* VisualAge seems to have an ETI issue with the default values</a>
<a name="ln219">     * for arguments args_list and al.</a>
<a name="ln220">     */</a>
<a name="ln221"> </a>
<a name="ln222">    const ctor_args_list&amp; args_list=</a>
<a name="ln223">      typename mpl::identity&lt;multi_index_container&gt;::type::</a>
<a name="ln224">        ctor_args_list(),</a>
<a name="ln225">    const allocator_type&amp; al=</a>
<a name="ln226">      typename mpl::identity&lt;multi_index_container&gt;::type::</a>
<a name="ln227">        allocator_type()):</a>
<a name="ln228">#else</a>
<a name="ln229">    const ctor_args_list&amp; args_list=ctor_args_list(),</a>
<a name="ln230">    const allocator_type&amp; al=allocator_type()):</a>
<a name="ln231">#endif</a>
<a name="ln232"> </a>
<a name="ln233">    bfm_allocator(al),</a>
<a name="ln234">    super(args_list,bfm_allocator::member),</a>
<a name="ln235">    node_count(0)</a>
<a name="ln236">  {</a>
<a name="ln237">    BOOST_MULTI_INDEX_CHECK_INVARIANT;</a>
<a name="ln238">    BOOST_TRY{</a>
<a name="ln239">      iterator hint=super::end();</a>
<a name="ln240">      for(;first!=last;++first){</a>
<a name="ln241">        hint=super::make_iterator(</a>
<a name="ln242">          insert_ref_(*first,hint.get_node()).first);</a>
<a name="ln243">        ++hint;</a>
<a name="ln244">      }</a>
<a name="ln245">    }</a>
<a name="ln246">    BOOST_CATCH(...){</a>
<a name="ln247">      clear_();</a>
<a name="ln248">      BOOST_RETHROW;</a>
<a name="ln249">    }</a>
<a name="ln250">    BOOST_CATCH_END</a>
<a name="ln251">  }</a>
<a name="ln252"> </a>
<a name="ln253">#if !defined(BOOST_NO_CXX11_HDR_INITIALIZER_LIST)</a>
<a name="ln254">  multi_index_container(</a>
<a name="ln255">    std::initializer_list&lt;Value&gt; list,</a>
<a name="ln256">    const ctor_args_list&amp; args_list=ctor_args_list(),</a>
<a name="ln257">    const allocator_type&amp; al=allocator_type()):</a>
<a name="ln258">    bfm_allocator(al),</a>
<a name="ln259">    super(args_list,bfm_allocator::member),</a>
<a name="ln260">    node_count(0)</a>
<a name="ln261">  {</a>
<a name="ln262">    BOOST_MULTI_INDEX_CHECK_INVARIANT;</a>
<a name="ln263">    BOOST_TRY{</a>
<a name="ln264">      typedef const Value* init_iterator;</a>
<a name="ln265"> </a>
<a name="ln266">      iterator hint=super::end();</a>
<a name="ln267">      for(init_iterator first=list.begin(),last=list.end();</a>
<a name="ln268">          first!=last;++first){</a>
<a name="ln269">        hint=super::make_iterator(insert_(*first,hint.get_node()).first);</a>
<a name="ln270">        ++hint;</a>
<a name="ln271">      }</a>
<a name="ln272">    }</a>
<a name="ln273">    BOOST_CATCH(...){</a>
<a name="ln274">      clear_();</a>
<a name="ln275">      BOOST_RETHROW;</a>
<a name="ln276">    }</a>
<a name="ln277">    BOOST_CATCH_END</a>
<a name="ln278">  }</a>
<a name="ln279">#endif</a>
<a name="ln280"> </a>
<a name="ln281">  multi_index_container(</a>
<a name="ln282">    const multi_index_container&lt;Value,IndexSpecifierList,Allocator&gt;&amp; x):</a>
<a name="ln283">    bfm_allocator(x.bfm_allocator::member),</a>
<a name="ln284">    bfm_header(),</a>
<a name="ln285">    super(x),</a>
<a name="ln286">    node_count(0)</a>
<a name="ln287">  {</a>
<a name="ln288">    copy_map_type map(bfm_allocator::member,x.size(),x.header(),header());</a>
<a name="ln289">    for(const_iterator it=x.begin(),it_end=x.end();it!=it_end;++it){</a>
<a name="ln290">      map.clone(it.get_node());</a>
<a name="ln291">    }</a>
<a name="ln292">    super::copy_(x,map);</a>
<a name="ln293">    map.release();</a>
<a name="ln294">    node_count=x.size();</a>
<a name="ln295"> </a>
<a name="ln296">    /* Not until this point are the indices required to be consistent,</a>
<a name="ln297">     * hence the position of the invariant checker.</a>
<a name="ln298">     */</a>
<a name="ln299"> </a>
<a name="ln300">    BOOST_MULTI_INDEX_CHECK_INVARIANT;</a>
<a name="ln301">  }</a>
<a name="ln302"> </a>
<a name="ln303">  multi_index_container(BOOST_RV_REF(multi_index_container) x):</a>
<a name="ln304">    bfm_allocator(x.bfm_allocator::member),</a>
<a name="ln305">    bfm_header(),</a>
<a name="ln306">    super(x,detail::do_not_copy_elements_tag()),</a>
<a name="ln307">    node_count(0)</a>
<a name="ln308">  {</a>
<a name="ln309">    BOOST_MULTI_INDEX_CHECK_INVARIANT;</a>
<a name="ln310">    BOOST_MULTI_INDEX_CHECK_INVARIANT_OF(x);</a>
<a name="ln311">    swap_elements_(x);</a>
<a name="ln312">  }</a>
<a name="ln313"> </a>
<a name="ln314">  ~multi_index_container()</a>
<a name="ln315">  {</a>
<a name="ln316">    delete_all_nodes_();</a>
<a name="ln317">  }</a>
<a name="ln318"> </a>
<a name="ln319">#if defined(BOOST_NO_CXX11_RVALUE_REFERENCES)</a>
<a name="ln320">  /* As per http://www.boost.org/doc/html/move/emulation_limitations.html</a>
<a name="ln321">   * #move.emulation_limitations.assignment_operator</a>
<a name="ln322">   */</a>
<a name="ln323"> </a>
<a name="ln324">  multi_index_container&lt;Value,IndexSpecifierList,Allocator&gt;&amp; operator=(</a>
<a name="ln325">    const multi_index_container&lt;Value,IndexSpecifierList,Allocator&gt;&amp; x)</a>
<a name="ln326">  {</a>
<a name="ln327">    multi_index_container y(x);</a>
<a name="ln328">    this-&gt;swap(y);</a>
<a name="ln329">    return *this;</a>
<a name="ln330">  }</a>
<a name="ln331">#endif</a>
<a name="ln332"> </a>
<a name="ln333">  multi_index_container&lt;Value,IndexSpecifierList,Allocator&gt;&amp; operator=(</a>
<a name="ln334">    BOOST_COPY_ASSIGN_REF(multi_index_container) x)</a>
<a name="ln335">  {</a>
<a name="ln336">    multi_index_container y(x);</a>
<a name="ln337">    this-&gt;swap(y);</a>
<a name="ln338">    return *this;</a>
<a name="ln339">  }</a>
<a name="ln340"> </a>
<a name="ln341">  multi_index_container&lt;Value,IndexSpecifierList,Allocator&gt;&amp; operator=(</a>
<a name="ln342">    BOOST_RV_REF(multi_index_container) x)</a>
<a name="ln343">  {</a>
<a name="ln344">    this-&gt;swap(x);</a>
<a name="ln345">    return *this;</a>
<a name="ln346">  }</a>
<a name="ln347"> </a>
<a name="ln348">#if !defined(BOOST_NO_CXX11_HDR_INITIALIZER_LIST)</a>
<a name="ln349">  multi_index_container&lt;Value,IndexSpecifierList,Allocator&gt;&amp; operator=(</a>
<a name="ln350">    std::initializer_list&lt;Value&gt; list)</a>
<a name="ln351">  {</a>
<a name="ln352">    BOOST_MULTI_INDEX_CHECK_INVARIANT;</a>
<a name="ln353">    typedef const Value* init_iterator;</a>
<a name="ln354"> </a>
<a name="ln355">    multi_index_container x(*this,detail::do_not_copy_elements_tag());    </a>
<a name="ln356">    iterator hint=x.end();</a>
<a name="ln357">    for(init_iterator first=list.begin(),last=list.end();</a>
<a name="ln358">        first!=last;++first){</a>
<a name="ln359">      hint=x.make_iterator(x.insert_(*first,hint.get_node()).first);</a>
<a name="ln360">      ++hint;</a>
<a name="ln361">    }</a>
<a name="ln362">    x.swap_elements_(*this);</a>
<a name="ln363">    return*this;</a>
<a name="ln364">  }</a>
<a name="ln365">#endif</a>
<a name="ln366"> </a>
<a name="ln367">  allocator_type get_allocator()const BOOST_NOEXCEPT</a>
<a name="ln368">  {</a>
<a name="ln369">    return allocator_type(bfm_allocator::member);</a>
<a name="ln370">  }</a>
<a name="ln371"> </a>
<a name="ln372">  /* retrieval of indices by number */</a>
<a name="ln373"> </a>
<a name="ln374">#if !defined(BOOST_NO_MEMBER_TEMPLATES)</a>
<a name="ln375">  template&lt;int N&gt;</a>
<a name="ln376">  struct nth_index</a>
<a name="ln377">  {</a>
<a name="ln378">    BOOST_STATIC_ASSERT(N&gt;=0&amp;&amp;N&lt;mpl::size&lt;index_type_list&gt;::type::value);</a>
<a name="ln379">    typedef typename mpl::at_c&lt;index_type_list,N&gt;::type type;</a>
<a name="ln380">  };</a>
<a name="ln381"> </a>
<a name="ln382">  template&lt;int N&gt;</a>
<a name="ln383">  typename nth_index&lt;N&gt;::type&amp; get()BOOST_NOEXCEPT</a>
<a name="ln384">  {</a>
<a name="ln385">    BOOST_STATIC_ASSERT(N&gt;=0&amp;&amp;N&lt;mpl::size&lt;index_type_list&gt;::type::value);</a>
<a name="ln386">    return *this;</a>
<a name="ln387">  }</a>
<a name="ln388"> </a>
<a name="ln389">  template&lt;int N&gt;</a>
<a name="ln390">  const typename nth_index&lt;N&gt;::type&amp; get()const BOOST_NOEXCEPT</a>
<a name="ln391">  {</a>
<a name="ln392">    BOOST_STATIC_ASSERT(N&gt;=0&amp;&amp;N&lt;mpl::size&lt;index_type_list&gt;::type::value);</a>
<a name="ln393">    return *this;</a>
<a name="ln394">  }</a>
<a name="ln395">#endif</a>
<a name="ln396"> </a>
<a name="ln397">  /* retrieval of indices by tag */</a>
<a name="ln398"> </a>
<a name="ln399">#if !defined(BOOST_NO_MEMBER_TEMPLATES)</a>
<a name="ln400">  template&lt;typename Tag&gt;</a>
<a name="ln401">  struct index</a>
<a name="ln402">  {</a>
<a name="ln403">    typedef typename mpl::find_if&lt;</a>
<a name="ln404">      index_type_list,</a>
<a name="ln405">      detail::has_tag&lt;Tag&gt;</a>
<a name="ln406">    &gt;::type                                    iter;</a>
<a name="ln407"> </a>
<a name="ln408">    BOOST_STATIC_CONSTANT(</a>
<a name="ln409">      bool,index_found=!(is_same&lt;iter,typename mpl::end&lt;index_type_list&gt;::type &gt;::value));</a>
<a name="ln410">    BOOST_STATIC_ASSERT(index_found);</a>
<a name="ln411"> </a>
<a name="ln412">    typedef typename mpl::deref&lt;iter&gt;::type    type;</a>
<a name="ln413">  };</a>
<a name="ln414"> </a>
<a name="ln415">  template&lt;typename Tag&gt;</a>
<a name="ln416">  typename index&lt;Tag&gt;::type&amp; get()BOOST_NOEXCEPT</a>
<a name="ln417">  {</a>
<a name="ln418">    return *this;</a>
<a name="ln419">  }</a>
<a name="ln420"> </a>
<a name="ln421">  template&lt;typename Tag&gt;</a>
<a name="ln422">  const typename index&lt;Tag&gt;::type&amp; get()const BOOST_NOEXCEPT</a>
<a name="ln423">  {</a>
<a name="ln424">    return *this;</a>
<a name="ln425">  }</a>
<a name="ln426">#endif</a>
<a name="ln427"> </a>
<a name="ln428">  /* projection of iterators by number */</a>
<a name="ln429"> </a>
<a name="ln430">#if !defined(BOOST_NO_MEMBER_TEMPLATES)</a>
<a name="ln431">  template&lt;int N&gt;</a>
<a name="ln432">  struct nth_index_iterator</a>
<a name="ln433">  {</a>
<a name="ln434">    typedef typename nth_index&lt;N&gt;::type::iterator type;</a>
<a name="ln435">  };</a>
<a name="ln436"> </a>
<a name="ln437">  template&lt;int N&gt;</a>
<a name="ln438">  struct nth_index_const_iterator</a>
<a name="ln439">  {</a>
<a name="ln440">    typedef typename nth_index&lt;N&gt;::type::const_iterator type;</a>
<a name="ln441">  };</a>
<a name="ln442"> </a>
<a name="ln443">  template&lt;int N,typename IteratorType&gt;</a>
<a name="ln444">  typename nth_index_iterator&lt;N&gt;::type project(IteratorType it)</a>
<a name="ln445">  {</a>
<a name="ln446">    typedef typename nth_index&lt;N&gt;::type index_type;</a>
<a name="ln447"> </a>
<a name="ln448">#if !defined(__SUNPRO_CC)||!(__SUNPRO_CC&lt;0x580) /* fails in Sun C++ 5.7 */</a>
<a name="ln449">    BOOST_STATIC_ASSERT(</a>
<a name="ln450">      (mpl::contains&lt;iterator_type_list,IteratorType&gt;::value));</a>
<a name="ln451">#endif</a>
<a name="ln452"> </a>
<a name="ln453">    BOOST_MULTI_INDEX_CHECK_VALID_ITERATOR(it);</a>
<a name="ln454">    BOOST_MULTI_INDEX_CHECK_IS_OWNER(</a>
<a name="ln455">      it,static_cast&lt;typename IteratorType::container_type&amp;&gt;(*this));</a>
<a name="ln456"> </a>
<a name="ln457">    return index_type::make_iterator(static_cast&lt;node_type*&gt;(it.get_node()));</a>
<a name="ln458">  }</a>
<a name="ln459"> </a>
<a name="ln460">  template&lt;int N,typename IteratorType&gt;</a>
<a name="ln461">  typename nth_index_const_iterator&lt;N&gt;::type project(IteratorType it)const</a>
<a name="ln462">  {</a>
<a name="ln463">    typedef typename nth_index&lt;N&gt;::type index_type;</a>
<a name="ln464"> </a>
<a name="ln465">#if !defined(__SUNPRO_CC)||!(__SUNPRO_CC&lt;0x580) /* fails in Sun C++ 5.7 */</a>
<a name="ln466">    BOOST_STATIC_ASSERT((</a>
<a name="ln467">      mpl::contains&lt;iterator_type_list,IteratorType&gt;::value||</a>
<a name="ln468">      mpl::contains&lt;const_iterator_type_list,IteratorType&gt;::value));</a>
<a name="ln469">#endif</a>
<a name="ln470"> </a>
<a name="ln471">    BOOST_MULTI_INDEX_CHECK_VALID_ITERATOR(it);</a>
<a name="ln472">    BOOST_MULTI_INDEX_CHECK_IS_OWNER(</a>
<a name="ln473">      it,static_cast&lt;const typename IteratorType::container_type&amp;&gt;(*this));</a>
<a name="ln474">    return index_type::make_iterator(static_cast&lt;node_type*&gt;(it.get_node()));</a>
<a name="ln475">  }</a>
<a name="ln476">#endif</a>
<a name="ln477"> </a>
<a name="ln478">  /* projection of iterators by tag */</a>
<a name="ln479"> </a>
<a name="ln480">#if !defined(BOOST_NO_MEMBER_TEMPLATES)</a>
<a name="ln481">  template&lt;typename Tag&gt;</a>
<a name="ln482">  struct index_iterator</a>
<a name="ln483">  {</a>
<a name="ln484">    typedef typename index&lt;Tag&gt;::type::iterator type;</a>
<a name="ln485">  };</a>
<a name="ln486"> </a>
<a name="ln487">  template&lt;typename Tag&gt;</a>
<a name="ln488">  struct index_const_iterator</a>
<a name="ln489">  {</a>
<a name="ln490">    typedef typename index&lt;Tag&gt;::type::const_iterator type;</a>
<a name="ln491">  };</a>
<a name="ln492"> </a>
<a name="ln493">  template&lt;typename Tag,typename IteratorType&gt;</a>
<a name="ln494">  typename index_iterator&lt;Tag&gt;::type project(IteratorType it)</a>
<a name="ln495">  {</a>
<a name="ln496">    typedef typename index&lt;Tag&gt;::type index_type;</a>
<a name="ln497"> </a>
<a name="ln498">#if !defined(__SUNPRO_CC)||!(__SUNPRO_CC&lt;0x580) /* fails in Sun C++ 5.7 */</a>
<a name="ln499">    BOOST_STATIC_ASSERT(</a>
<a name="ln500">      (mpl::contains&lt;iterator_type_list,IteratorType&gt;::value));</a>
<a name="ln501">#endif</a>
<a name="ln502"> </a>
<a name="ln503">    BOOST_MULTI_INDEX_CHECK_VALID_ITERATOR(it);</a>
<a name="ln504">    BOOST_MULTI_INDEX_CHECK_IS_OWNER(</a>
<a name="ln505">      it,static_cast&lt;typename IteratorType::container_type&amp;&gt;(*this));</a>
<a name="ln506">    return index_type::make_iterator(static_cast&lt;node_type*&gt;(it.get_node()));</a>
<a name="ln507">  }</a>
<a name="ln508"> </a>
<a name="ln509">  template&lt;typename Tag,typename IteratorType&gt;</a>
<a name="ln510">  typename index_const_iterator&lt;Tag&gt;::type project(IteratorType it)const</a>
<a name="ln511">  {</a>
<a name="ln512">    typedef typename index&lt;Tag&gt;::type index_type;</a>
<a name="ln513"> </a>
<a name="ln514">#if !defined(__SUNPRO_CC)||!(__SUNPRO_CC&lt;0x580) /* fails in Sun C++ 5.7 */</a>
<a name="ln515">    BOOST_STATIC_ASSERT((</a>
<a name="ln516">      mpl::contains&lt;iterator_type_list,IteratorType&gt;::value||</a>
<a name="ln517">      mpl::contains&lt;const_iterator_type_list,IteratorType&gt;::value));</a>
<a name="ln518">#endif</a>
<a name="ln519"> </a>
<a name="ln520">    BOOST_MULTI_INDEX_CHECK_VALID_ITERATOR(it);</a>
<a name="ln521">    BOOST_MULTI_INDEX_CHECK_IS_OWNER(</a>
<a name="ln522">      it,static_cast&lt;const typename IteratorType::container_type&amp;&gt;(*this));</a>
<a name="ln523">    return index_type::make_iterator(static_cast&lt;node_type*&gt;(it.get_node()));</a>
<a name="ln524">  }</a>
<a name="ln525">#endif</a>
<a name="ln526"> </a>
<a name="ln527">BOOST_MULTI_INDEX_PROTECTED_IF_MEMBER_TEMPLATE_FRIENDS:</a>
<a name="ln528">  typedef typename super::copy_map_type copy_map_type;</a>
<a name="ln529"> </a>
<a name="ln530">#if !defined(BOOST_NO_CXX11_HDR_INITIALIZER_LIST)</a>
<a name="ln531">  multi_index_container(</a>
<a name="ln532">    const multi_index_container&lt;Value,IndexSpecifierList,Allocator&gt;&amp; x,</a>
<a name="ln533">    detail::do_not_copy_elements_tag):</a>
<a name="ln534">    bfm_allocator(x.bfm_allocator::member),</a>
<a name="ln535">    bfm_header(),</a>
<a name="ln536">    super(x,detail::do_not_copy_elements_tag()),</a>
<a name="ln537">    node_count(0)</a>
<a name="ln538">  {</a>
<a name="ln539">    BOOST_MULTI_INDEX_CHECK_INVARIANT;</a>
<a name="ln540">  }</a>
<a name="ln541">#endif</a>
<a name="ln542"> </a>
<a name="ln543">  node_type* header()const</a>
<a name="ln544">  {</a>
<a name="ln545">    return &amp;*bfm_header::member;</a>
<a name="ln546">  }</a>
<a name="ln547"> </a>
<a name="ln548">  node_type* allocate_node()</a>
<a name="ln549">  {</a>
<a name="ln550">#ifdef BOOST_NO_CXX11_ALLOCATOR</a>
<a name="ln551">    return &amp;*bfm_allocator::member.allocate(1);</a>
<a name="ln552">#else</a>
<a name="ln553">    return &amp;*node_allocator_traits::allocate(bfm_allocator::member,1);</a>
<a name="ln554">#endif</a>
<a name="ln555">  }</a>
<a name="ln556"> </a>
<a name="ln557">  void deallocate_node(node_type* x)</a>
<a name="ln558">  {</a>
<a name="ln559">#ifdef BOOST_NO_CXX11_ALLOCATOR</a>
<a name="ln560">    bfm_allocator::member.deallocate(static_cast&lt;node_pointer&gt;(x),1);</a>
<a name="ln561">#else</a>
<a name="ln562">    node_allocator_traits::deallocate(bfm_allocator::member,static_cast&lt;node_pointer&gt;(x),1);</a>
<a name="ln563">#endif</a>
<a name="ln564">  }</a>
<a name="ln565"> </a>
<a name="ln566">  bool empty_()const</a>
<a name="ln567">  {</a>
<a name="ln568">    return node_count==0;</a>
<a name="ln569">  }</a>
<a name="ln570"> </a>
<a name="ln571">  std::size_t size_()const</a>
<a name="ln572">  {</a>
<a name="ln573">    return node_count;</a>
<a name="ln574">  }</a>
<a name="ln575"> </a>
<a name="ln576">  std::size_t max_size_()const</a>
<a name="ln577">  {</a>
<a name="ln578">    return static_cast&lt;std::size_t &gt;(-1);</a>
<a name="ln579">  }</a>
<a name="ln580"> </a>
<a name="ln581">  template&lt;typename Variant&gt;</a>
<a name="ln582">  std::pair&lt;node_type*,bool&gt; insert_(const Value&amp; v,Variant variant)</a>
<a name="ln583">  {</a>
<a name="ln584">    node_type* x=0;</a>
<a name="ln585">    node_type* res=super::insert_(v,x,variant);</a>
<a name="ln586">    if(res==x){</a>
<a name="ln587">      ++node_count;</a>
<a name="ln588">      return std::pair&lt;node_type*,bool&gt;(res,true);</a>
<a name="ln589">    }</a>
<a name="ln590">    else{</a>
<a name="ln591">      return std::pair&lt;node_type*,bool&gt;(res,false);</a>
<a name="ln592">    }</a>
<a name="ln593">  }</a>
<a name="ln594"> </a>
<a name="ln595">  std::pair&lt;node_type*,bool&gt; insert_(const Value&amp; v)</a>
<a name="ln596">  {</a>
<a name="ln597">    return insert_(v,detail::lvalue_tag());</a>
<a name="ln598">  }</a>
<a name="ln599"> </a>
<a name="ln600">  std::pair&lt;node_type*,bool&gt; insert_rv_(const Value&amp; v)</a>
<a name="ln601">  {</a>
<a name="ln602">    return insert_(v,detail::rvalue_tag());</a>
<a name="ln603">  }</a>
<a name="ln604"> </a>
<a name="ln605">  template&lt;typename T&gt;</a>
<a name="ln606">  std::pair&lt;node_type*,bool&gt; insert_ref_(T&amp; t)</a>
<a name="ln607">  {</a>
<a name="ln608">    node_type* x=allocate_node();</a>
<a name="ln609">    BOOST_TRY{</a>
<a name="ln610">      new(boost::addressof(x-&gt;value())) value_type(t);</a>
<a name="ln611">      BOOST_TRY{</a>
<a name="ln612">        node_type* res=super::insert_(x-&gt;value(),x,detail::emplaced_tag());</a>
<a name="ln613">        if(res==x){</a>
<a name="ln614">          ++node_count;</a>
<a name="ln615">          return std::pair&lt;node_type*,bool&gt;(res,true);</a>
<a name="ln616">        }</a>
<a name="ln617">        else{</a>
<a name="ln618">          boost::detail::allocator::destroy(boost::addressof(x-&gt;value()));</a>
<a name="ln619">          deallocate_node(x);</a>
<a name="ln620">          return std::pair&lt;node_type*,bool&gt;(res,false);</a>
<a name="ln621">        }</a>
<a name="ln622">      }</a>
<a name="ln623">      BOOST_CATCH(...){</a>
<a name="ln624">        boost::detail::allocator::destroy(boost::addressof(x-&gt;value()));</a>
<a name="ln625">        BOOST_RETHROW;</a>
<a name="ln626">      }</a>
<a name="ln627">      BOOST_CATCH_END</a>
<a name="ln628">    }</a>
<a name="ln629">    BOOST_CATCH(...){</a>
<a name="ln630">      deallocate_node(x);</a>
<a name="ln631">      BOOST_RETHROW;</a>
<a name="ln632">    }</a>
<a name="ln633">    BOOST_CATCH_END</a>
<a name="ln634">  }</a>
<a name="ln635"> </a>
<a name="ln636">  std::pair&lt;node_type*,bool&gt; insert_ref_(const value_type&amp; x)</a>
<a name="ln637">  {</a>
<a name="ln638">    return insert_(x);</a>
<a name="ln639">  }</a>
<a name="ln640"> </a>
<a name="ln641">  std::pair&lt;node_type*,bool&gt; insert_ref_(value_type&amp; x)</a>
<a name="ln642">  {</a>
<a name="ln643">    return insert_(x);</a>
<a name="ln644">  }</a>
<a name="ln645"> </a>
<a name="ln646">  template&lt;BOOST_MULTI_INDEX_TEMPLATE_PARAM_PACK&gt;</a>
<a name="ln647">  std::pair&lt;node_type*,bool&gt; emplace_(</a>
<a name="ln648">    BOOST_MULTI_INDEX_FUNCTION_PARAM_PACK)</a>
<a name="ln649">  {</a>
<a name="ln650">    node_type* x=allocate_node();</a>
<a name="ln651">    BOOST_TRY{</a>
<a name="ln652">      detail::vartempl_placement_new(</a>
<a name="ln653">        boost::addressof(x-&gt;value()),BOOST_MULTI_INDEX_FORWARD_PARAM_PACK);</a>
<a name="ln654">      BOOST_TRY{</a>
<a name="ln655">        node_type* res=super::insert_(x-&gt;value(),x,detail::emplaced_tag());</a>
<a name="ln656">        if(res==x){</a>
<a name="ln657">          ++node_count;</a>
<a name="ln658">          return std::pair&lt;node_type*,bool&gt;(res,true);</a>
<a name="ln659">        }</a>
<a name="ln660">        else{</a>
<a name="ln661">          boost::detail::allocator::destroy(boost::addressof(x-&gt;value()));</a>
<a name="ln662">          deallocate_node(x);</a>
<a name="ln663">          return std::pair&lt;node_type*,bool&gt;(res,false);</a>
<a name="ln664">        }</a>
<a name="ln665">      }</a>
<a name="ln666">      BOOST_CATCH(...){</a>
<a name="ln667">        boost::detail::allocator::destroy(boost::addressof(x-&gt;value()));</a>
<a name="ln668">        BOOST_RETHROW;</a>
<a name="ln669">      }</a>
<a name="ln670">      BOOST_CATCH_END</a>
<a name="ln671">    }</a>
<a name="ln672">    BOOST_CATCH(...){</a>
<a name="ln673">      deallocate_node(x);</a>
<a name="ln674">      BOOST_RETHROW;</a>
<a name="ln675">    }</a>
<a name="ln676">    BOOST_CATCH_END</a>
<a name="ln677">  }</a>
<a name="ln678"> </a>
<a name="ln679">  template&lt;typename Variant&gt;</a>
<a name="ln680">  std::pair&lt;node_type*,bool&gt; insert_(</a>
<a name="ln681">    const Value&amp; v,node_type* position,Variant variant)</a>
<a name="ln682">  {</a>
<a name="ln683">    node_type* x=0;</a>
<a name="ln684">    node_type* res=super::insert_(v,position,x,variant);</a>
<a name="ln685">    if(res==x){</a>
<a name="ln686">      ++node_count;</a>
<a name="ln687">      return std::pair&lt;node_type*,bool&gt;(res,true);</a>
<a name="ln688">    }</a>
<a name="ln689">    else{</a>
<a name="ln690">      return std::pair&lt;node_type*,bool&gt;(res,false);</a>
<a name="ln691">    }</a>
<a name="ln692">  }</a>
<a name="ln693"> </a>
<a name="ln694">  std::pair&lt;node_type*,bool&gt; insert_(const Value&amp; v,node_type* position)</a>
<a name="ln695">  {</a>
<a name="ln696">    return insert_(v,position,detail::lvalue_tag());</a>
<a name="ln697">  }</a>
<a name="ln698"> </a>
<a name="ln699">  std::pair&lt;node_type*,bool&gt; insert_rv_(const Value&amp; v,node_type* position)</a>
<a name="ln700">  {</a>
<a name="ln701">    return insert_(v,position,detail::rvalue_tag());</a>
<a name="ln702">  }</a>
<a name="ln703"> </a>
<a name="ln704">  template&lt;typename T&gt;</a>
<a name="ln705">  std::pair&lt;node_type*,bool&gt; insert_ref_(</a>
<a name="ln706">    T&amp; t,node_type* position)</a>
<a name="ln707">  {</a>
<a name="ln708">    node_type* x=allocate_node();</a>
<a name="ln709">    BOOST_TRY{</a>
<a name="ln710">      new(boost::addressof(x-&gt;value())) value_type(t);</a>
<a name="ln711">      BOOST_TRY{</a>
<a name="ln712">        node_type* res=super::insert_(</a>
<a name="ln713">          x-&gt;value(),position,x,detail::emplaced_tag());</a>
<a name="ln714">        if(res==x){</a>
<a name="ln715">          ++node_count;</a>
<a name="ln716">          return std::pair&lt;node_type*,bool&gt;(res,true);</a>
<a name="ln717">        }</a>
<a name="ln718">        else{</a>
<a name="ln719">          boost::detail::allocator::destroy(boost::addressof(x-&gt;value()));</a>
<a name="ln720">          deallocate_node(x);</a>
<a name="ln721">          return std::pair&lt;node_type*,bool&gt;(res,false);</a>
<a name="ln722">        }</a>
<a name="ln723">      }</a>
<a name="ln724">      BOOST_CATCH(...){</a>
<a name="ln725">        boost::detail::allocator::destroy(boost::addressof(x-&gt;value()));</a>
<a name="ln726">        BOOST_RETHROW;</a>
<a name="ln727">      }</a>
<a name="ln728">      BOOST_CATCH_END</a>
<a name="ln729">    }</a>
<a name="ln730">    BOOST_CATCH(...){</a>
<a name="ln731">      deallocate_node(x);</a>
<a name="ln732">      BOOST_RETHROW;</a>
<a name="ln733">    }</a>
<a name="ln734">    BOOST_CATCH_END</a>
<a name="ln735">  }</a>
<a name="ln736"> </a>
<a name="ln737">  std::pair&lt;node_type*,bool&gt; insert_ref_(</a>
<a name="ln738">    const value_type&amp; x,node_type* position)</a>
<a name="ln739">  {</a>
<a name="ln740">    return insert_(x,position);</a>
<a name="ln741">  }</a>
<a name="ln742"> </a>
<a name="ln743">  std::pair&lt;node_type*,bool&gt; insert_ref_(</a>
<a name="ln744">    value_type&amp; x,node_type* position)</a>
<a name="ln745">  {</a>
<a name="ln746">    return insert_(x,position);</a>
<a name="ln747">  }</a>
<a name="ln748"> </a>
<a name="ln749">  template&lt;BOOST_MULTI_INDEX_TEMPLATE_PARAM_PACK&gt;</a>
<a name="ln750">  std::pair&lt;node_type*,bool&gt; emplace_hint_(</a>
<a name="ln751">    node_type* position,</a>
<a name="ln752">    BOOST_MULTI_INDEX_FUNCTION_PARAM_PACK)</a>
<a name="ln753">  {</a>
<a name="ln754">    node_type* x=allocate_node();</a>
<a name="ln755">    BOOST_TRY{</a>
<a name="ln756">      detail::vartempl_placement_new(</a>
<a name="ln757">        boost::addressof(x-&gt;value()),BOOST_MULTI_INDEX_FORWARD_PARAM_PACK);</a>
<a name="ln758">      BOOST_TRY{</a>
<a name="ln759">        node_type* res=super::insert_(</a>
<a name="ln760">          x-&gt;value(),position,x,detail::emplaced_tag());</a>
<a name="ln761">        if(res==x){</a>
<a name="ln762">          ++node_count;</a>
<a name="ln763">          return std::pair&lt;node_type*,bool&gt;(res,true);</a>
<a name="ln764">        }</a>
<a name="ln765">        else{</a>
<a name="ln766">          boost::detail::allocator::destroy(boost::addressof(x-&gt;value()));</a>
<a name="ln767">          deallocate_node(x);</a>
<a name="ln768">          return std::pair&lt;node_type*,bool&gt;(res,false);</a>
<a name="ln769">        }</a>
<a name="ln770">      }</a>
<a name="ln771">      BOOST_CATCH(...){</a>
<a name="ln772">        boost::detail::allocator::destroy(boost::addressof(x-&gt;value()));</a>
<a name="ln773">        BOOST_RETHROW;</a>
<a name="ln774">      }</a>
<a name="ln775">      BOOST_CATCH_END</a>
<a name="ln776">    }</a>
<a name="ln777">    BOOST_CATCH(...){</a>
<a name="ln778">      deallocate_node(x);</a>
<a name="ln779">      BOOST_RETHROW;</a>
<a name="ln780">    }</a>
<a name="ln781">    BOOST_CATCH_END</a>
<a name="ln782">  }</a>
<a name="ln783"> </a>
<a name="ln784">  void erase_(node_type* x)</a>
<a name="ln785">  {</a>
<a name="ln786">    --node_count;</a>
<a name="ln787">    super::erase_(x);</a>
<a name="ln788">    deallocate_node(x);</a>
<a name="ln789">  }</a>
<a name="ln790"> </a>
<a name="ln791">  void delete_node_(node_type* x)</a>
<a name="ln792">  {</a>
<a name="ln793">    super::delete_node_(x);</a>
<a name="ln794">    deallocate_node(x);</a>
<a name="ln795">  }</a>
<a name="ln796"> </a>
<a name="ln797">  void delete_all_nodes_()</a>
<a name="ln798">  {</a>
<a name="ln799">    super::delete_all_nodes_();</a>
<a name="ln800">  }</a>
<a name="ln801"> </a>
<a name="ln802">  void clear_()</a>
<a name="ln803">  {</a>
<a name="ln804">    delete_all_nodes_();</a>
<a name="ln805">    super::clear_();</a>
<a name="ln806">    node_count=0;</a>
<a name="ln807">  }</a>
<a name="ln808"> </a>
<a name="ln809">  void swap_(multi_index_container&lt;Value,IndexSpecifierList,Allocator&gt;&amp; x)</a>
<a name="ln810">  {</a>
<a name="ln811">    if(bfm_allocator::member!=x.bfm_allocator::member){</a>
<a name="ln812">      detail::adl_swap(bfm_allocator::member,x.bfm_allocator::member);</a>
<a name="ln813">    }</a>
<a name="ln814">    std::swap(bfm_header::member,x.bfm_header::member);</a>
<a name="ln815">    super::swap_(x);</a>
<a name="ln816">    std::swap(node_count,x.node_count);</a>
<a name="ln817">  }</a>
<a name="ln818"> </a>
<a name="ln819">  void swap_elements_(</a>
<a name="ln820">    multi_index_container&lt;Value,IndexSpecifierList,Allocator&gt;&amp; x)</a>
<a name="ln821">  {</a>
<a name="ln822">    std::swap(bfm_header::member,x.bfm_header::member);</a>
<a name="ln823">    super::swap_elements_(x);</a>
<a name="ln824">    std::swap(node_count,x.node_count);</a>
<a name="ln825">  }</a>
<a name="ln826"> </a>
<a name="ln827">  bool replace_(const Value&amp; k,node_type* x)</a>
<a name="ln828">  {</a>
<a name="ln829">    return super::replace_(k,x,detail::lvalue_tag());</a>
<a name="ln830">  }</a>
<a name="ln831"> </a>
<a name="ln832">  bool replace_rv_(const Value&amp; k,node_type* x)</a>
<a name="ln833">  {</a>
<a name="ln834">    return super::replace_(k,x,detail::rvalue_tag());</a>
<a name="ln835">  }</a>
<a name="ln836"> </a>
<a name="ln837">  template&lt;typename Modifier&gt;</a>
<a name="ln838">  bool modify_(Modifier&amp; mod,node_type* x)</a>
<a name="ln839">  {</a>
<a name="ln840">    BOOST_TRY{</a>
<a name="ln841">      mod(const_cast&lt;value_type&amp;&gt;(x-&gt;value()));</a>
<a name="ln842">    }</a>
<a name="ln843">    BOOST_CATCH(...){</a>
<a name="ln844">      this-&gt;erase_(x);</a>
<a name="ln845">      BOOST_RETHROW;</a>
<a name="ln846">    }</a>
<a name="ln847">    BOOST_CATCH_END</a>
<a name="ln848"> </a>
<a name="ln849">    BOOST_TRY{</a>
<a name="ln850">      if(!super::modify_(x)){</a>
<a name="ln851">        deallocate_node(x);</a>
<a name="ln852">        --node_count;</a>
<a name="ln853">        return false;</a>
<a name="ln854">      }</a>
<a name="ln855">      else return true;</a>
<a name="ln856">    }</a>
<a name="ln857">    BOOST_CATCH(...){</a>
<a name="ln858">      deallocate_node(x);</a>
<a name="ln859">      --node_count;</a>
<a name="ln860">      BOOST_RETHROW;</a>
<a name="ln861">    }</a>
<a name="ln862">    BOOST_CATCH_END</a>
<a name="ln863">  }</a>
<a name="ln864"> </a>
<a name="ln865">  template&lt;typename Modifier,typename Rollback&gt;</a>
<a name="ln866">  bool modify_(Modifier&amp; mod,Rollback&amp; back_,node_type* x)</a>
<a name="ln867">  {</a>
<a name="ln868">    BOOST_TRY{</a>
<a name="ln869">      mod(const_cast&lt;value_type&amp;&gt;(x-&gt;value()));</a>
<a name="ln870">    }</a>
<a name="ln871">    BOOST_CATCH(...){</a>
<a name="ln872">      this-&gt;erase_(x);</a>
<a name="ln873">      BOOST_RETHROW;</a>
<a name="ln874">    }</a>
<a name="ln875">    BOOST_CATCH_END</a>
<a name="ln876"> </a>
<a name="ln877">    bool b;</a>
<a name="ln878">    BOOST_TRY{</a>
<a name="ln879">      b=super::modify_rollback_(x);</a>
<a name="ln880">    }</a>
<a name="ln881">    BOOST_CATCH(...){</a>
<a name="ln882">      BOOST_TRY{</a>
<a name="ln883">        back_(const_cast&lt;value_type&amp;&gt;(x-&gt;value()));</a>
<a name="ln884">        if(!super::check_rollback_(x))this-&gt;erase_(x);</a>
<a name="ln885">        BOOST_RETHROW;</a>
<a name="ln886">      }</a>
<a name="ln887">      BOOST_CATCH(...){</a>
<a name="ln888">        this-&gt;erase_(x);</a>
<a name="ln889">        BOOST_RETHROW;</a>
<a name="ln890">      }</a>
<a name="ln891">      BOOST_CATCH_END</a>
<a name="ln892">    }</a>
<a name="ln893">    BOOST_CATCH_END</a>
<a name="ln894"> </a>
<a name="ln895">    BOOST_TRY{</a>
<a name="ln896">      if(!b){</a>
<a name="ln897">        back_(const_cast&lt;value_type&amp;&gt;(x-&gt;value()));</a>
<a name="ln898">        if(!super::check_rollback_(x))this-&gt;erase_(x);</a>
<a name="ln899">        return false;</a>
<a name="ln900">      }</a>
<a name="ln901">      else return true;</a>
<a name="ln902">    }</a>
<a name="ln903">    BOOST_CATCH(...){</a>
<a name="ln904">      this-&gt;erase_(x);</a>
<a name="ln905">      BOOST_RETHROW;</a>
<a name="ln906">    }</a>
<a name="ln907">    BOOST_CATCH_END</a>
<a name="ln908">  }</a>
<a name="ln909"> </a>
<a name="ln910">#if !defined(BOOST_MULTI_INDEX_DISABLE_SERIALIZATION)</a>
<a name="ln911">  /* serialization */</a>
<a name="ln912"> </a>
<a name="ln913">  friend class boost::serialization::access;</a>
<a name="ln914"> </a>
<a name="ln915">  BOOST_SERIALIZATION_SPLIT_MEMBER()</a>
<a name="ln916"> </a>
<a name="ln917">  typedef typename super::index_saver_type        index_saver_type;</a>
<a name="ln918">  typedef typename super::index_loader_type       index_loader_type;</a>
<a name="ln919"> </a>
<a name="ln920">  template&lt;class Archive&gt;</a>
<a name="ln921">  void save(Archive&amp; ar,const unsigned int version)const</a>
<a name="ln922">  {</a>
<a name="ln923">    const serialization::collection_size_type       s(size_());</a>
<a name="ln924">    const detail::serialization_version&lt;value_type&gt; value_version;</a>
<a name="ln925">    ar&lt;&lt;serialization::make_nvp(&quot;count&quot;,s);</a>
<a name="ln926">    ar&lt;&lt;serialization::make_nvp(&quot;value_version&quot;,value_version);</a>
<a name="ln927"> </a>
<a name="ln928">    index_saver_type sm(bfm_allocator::member,s);</a>
<a name="ln929"> </a>
<a name="ln930">    for(iterator it=super::begin(),it_end=super::end();it!=it_end;++it){</a>
<a name="ln931">      serialization::save_construct_data_adl(</a>
<a name="ln932">        ar,boost::addressof(*it),value_version);</a>
<a name="ln933">      ar&lt;&lt;serialization::make_nvp(&quot;item&quot;,*it);</a>
<a name="ln934">      sm.add(it.get_node(),ar,version);</a>
<a name="ln935">    }</a>
<a name="ln936">    sm.add_track(header(),ar,version);</a>
<a name="ln937"> </a>
<a name="ln938">    super::save_(ar,version,sm);</a>
<a name="ln939">  }</a>
<a name="ln940"> </a>
<a name="ln941">  template&lt;class Archive&gt;</a>
<a name="ln942">  void load(Archive&amp; ar,const unsigned int version)</a>
<a name="ln943">  {</a>
<a name="ln944">    BOOST_MULTI_INDEX_CHECK_INVARIANT;</a>
<a name="ln945"> </a>
<a name="ln946">    clear_(); </a>
<a name="ln947">    serialization::collection_size_type       s;</a>
<a name="ln948">    detail::serialization_version&lt;value_type&gt; value_version;</a>
<a name="ln949">    if(version&lt;1){</a>
<a name="ln950">      std::size_t sz;</a>
<a name="ln951">      ar&gt;&gt;serialization::make_nvp(&quot;count&quot;,sz);</a>
<a name="ln952">      s=static_cast&lt;serialization::collection_size_type&gt;(sz);</a>
<a name="ln953">    }</a>
<a name="ln954">    else{</a>
<a name="ln955">      ar&gt;&gt;serialization::make_nvp(&quot;count&quot;,s);</a>
<a name="ln956">    }</a>
<a name="ln957">    if(version&lt;2){</a>
<a name="ln958">      value_version=0;</a>
<a name="ln959">    }</a>
<a name="ln960">    else{</a>
<a name="ln961">      ar&gt;&gt;serialization::make_nvp(&quot;value_version&quot;,value_version);</a>
<a name="ln962">    }</a>
<a name="ln963"> </a>
<a name="ln964">    index_loader_type lm(bfm_allocator::member,s);</a>
<a name="ln965"> </a>
<a name="ln966">    for(std::size_t n=0;n&lt;s;++n){</a>
<a name="ln967">      detail::archive_constructed&lt;Value&gt; value(&quot;item&quot;,ar,value_version);</a>
<a name="ln968">      std::pair&lt;node_type*,bool&gt; p=insert_rv_(</a>
<a name="ln969">        value.get(),super::end().get_node());</a>
<a name="ln970">      if(!p.second)throw_exception(</a>
<a name="ln971">        archive::archive_exception(</a>
<a name="ln972">          archive::archive_exception::other_exception));</a>
<a name="ln973">      ar.reset_object_address(</a>
<a name="ln974">        boost::addressof(p.first-&gt;value()),boost::addressof(value.get()));</a>
<a name="ln975">      lm.add(p.first,ar,version);</a>
<a name="ln976">    }</a>
<a name="ln977">    lm.add_track(header(),ar,version);</a>
<a name="ln978"> </a>
<a name="ln979">    super::load_(ar,version,lm);</a>
<a name="ln980">  }</a>
<a name="ln981">#endif</a>
<a name="ln982"> </a>
<a name="ln983">#if defined(BOOST_MULTI_INDEX_ENABLE_INVARIANT_CHECKING)</a>
<a name="ln984">  /* invariant stuff */</a>
<a name="ln985"> </a>
<a name="ln986">  bool invariant_()const</a>
<a name="ln987">  {</a>
<a name="ln988">    return super::invariant_();</a>
<a name="ln989">  }</a>
<a name="ln990"> </a>
<a name="ln991">  void check_invariant_()const</a>
<a name="ln992">  {</a>
<a name="ln993">    BOOST_MULTI_INDEX_INVARIANT_ASSERT(invariant_());</a>
<a name="ln994">  }</a>
<a name="ln995">#endif</a>
<a name="ln996"> </a>
<a name="ln997">private:</a>
<a name="ln998">  std::size_t node_count;</a>
<a name="ln999"> </a>
<a name="ln1000">#if defined(BOOST_MULTI_INDEX_ENABLE_INVARIANT_CHECKING)&amp;&amp;\</a>
<a name="ln1001">    BOOST_WORKAROUND(__MWERKS__,&lt;=0x3003)</a>
<a name="ln1002">#pragma parse_mfunc_templ reset</a>
<a name="ln1003">#endif</a>
<a name="ln1004">};</a>
<a name="ln1005"> </a>
<a name="ln1006">#if BOOST_WORKAROUND(BOOST_MSVC,BOOST_TESTED_AT(1500))</a>
<a name="ln1007">#pragma warning(pop) /* C4522 */</a>
<a name="ln1008">#endif</a>
<a name="ln1009"> </a>
<a name="ln1010">/* retrieval of indices by number */</a>
<a name="ln1011"> </a>
<a name="ln1012">template&lt;typename MultiIndexContainer,int N&gt;</a>
<a name="ln1013">struct nth_index</a>
<a name="ln1014">{</a>
<a name="ln1015">  BOOST_STATIC_CONSTANT(</a>
<a name="ln1016">    int,</a>
<a name="ln1017">    M=mpl::size&lt;typename MultiIndexContainer::index_type_list&gt;::type::value);</a>
<a name="ln1018">  BOOST_STATIC_ASSERT(N&gt;=0&amp;&amp;N&lt;M);</a>
<a name="ln1019">  typedef typename mpl::at_c&lt;</a>
<a name="ln1020">    typename MultiIndexContainer::index_type_list,N&gt;::type type;</a>
<a name="ln1021">};</a>
<a name="ln1022"> </a>
<a name="ln1023">template&lt;int N,typename Value,typename IndexSpecifierList,typename Allocator&gt;</a>
<a name="ln1024">typename nth_index&lt;</a>
<a name="ln1025">  multi_index_container&lt;Value,IndexSpecifierList,Allocator&gt;,N&gt;::type&amp;</a>
<a name="ln1026">get(</a>
<a name="ln1027">  multi_index_container&lt;Value,IndexSpecifierList,Allocator&gt;&amp; m)BOOST_NOEXCEPT</a>
<a name="ln1028">{</a>
<a name="ln1029">  typedef multi_index_container&lt;</a>
<a name="ln1030">    Value,IndexSpecifierList,Allocator&gt;    multi_index_type;</a>
<a name="ln1031">  typedef typename nth_index&lt;</a>
<a name="ln1032">    multi_index_container&lt;</a>
<a name="ln1033">      Value,IndexSpecifierList,Allocator&gt;,</a>
<a name="ln1034">    N</a>
<a name="ln1035">  &gt;::type                                  index_type;</a>
<a name="ln1036"> </a>
<a name="ln1037">  BOOST_STATIC_ASSERT(N&gt;=0&amp;&amp;</a>
<a name="ln1038">    N&lt;</a>
<a name="ln1039">    mpl::size&lt;</a>
<a name="ln1040">      BOOST_DEDUCED_TYPENAME multi_index_type::index_type_list</a>
<a name="ln1041">    &gt;::type::value);</a>
<a name="ln1042"> </a>
<a name="ln1043">  return detail::converter&lt;multi_index_type,index_type&gt;::index(m);</a>
<a name="ln1044">}</a>
<a name="ln1045"> </a>
<a name="ln1046">template&lt;int N,typename Value,typename IndexSpecifierList,typename Allocator&gt;</a>
<a name="ln1047">const typename nth_index&lt;</a>
<a name="ln1048">  multi_index_container&lt;Value,IndexSpecifierList,Allocator&gt;,N&gt;::type&amp;</a>
<a name="ln1049">get(</a>
<a name="ln1050">  const multi_index_container&lt;Value,IndexSpecifierList,Allocator&gt;&amp; m</a>
<a name="ln1051">)BOOST_NOEXCEPT</a>
<a name="ln1052">{</a>
<a name="ln1053">  typedef multi_index_container&lt;</a>
<a name="ln1054">    Value,IndexSpecifierList,Allocator&gt;    multi_index_type;</a>
<a name="ln1055">  typedef typename nth_index&lt;</a>
<a name="ln1056">    multi_index_container&lt;</a>
<a name="ln1057">      Value,IndexSpecifierList,Allocator&gt;,</a>
<a name="ln1058">    N</a>
<a name="ln1059">  &gt;::type                                  index_type;</a>
<a name="ln1060"> </a>
<a name="ln1061">  BOOST_STATIC_ASSERT(N&gt;=0&amp;&amp;</a>
<a name="ln1062">    N&lt;</a>
<a name="ln1063">    mpl::size&lt;</a>
<a name="ln1064">      BOOST_DEDUCED_TYPENAME multi_index_type::index_type_list</a>
<a name="ln1065">    &gt;::type::value);</a>
<a name="ln1066"> </a>
<a name="ln1067">  return detail::converter&lt;multi_index_type,index_type&gt;::index(m);</a>
<a name="ln1068">}</a>
<a name="ln1069"> </a>
<a name="ln1070">/* retrieval of indices by tag */</a>
<a name="ln1071"> </a>
<a name="ln1072">template&lt;typename MultiIndexContainer,typename Tag&gt;</a>
<a name="ln1073">struct index</a>
<a name="ln1074">{</a>
<a name="ln1075">  typedef typename MultiIndexContainer::index_type_list index_type_list;</a>
<a name="ln1076"> </a>
<a name="ln1077">  typedef typename mpl::find_if&lt;</a>
<a name="ln1078">    index_type_list,</a>
<a name="ln1079">    detail::has_tag&lt;Tag&gt;</a>
<a name="ln1080">  &gt;::type                                      iter;</a>
<a name="ln1081"> </a>
<a name="ln1082">  BOOST_STATIC_CONSTANT(</a>
<a name="ln1083">    bool,index_found=!(is_same&lt;iter,typename mpl::end&lt;index_type_list&gt;::type &gt;::value));</a>
<a name="ln1084">  BOOST_STATIC_ASSERT(index_found);</a>
<a name="ln1085"> </a>
<a name="ln1086">  typedef typename mpl::deref&lt;iter&gt;::type       type;</a>
<a name="ln1087">};</a>
<a name="ln1088"> </a>
<a name="ln1089">template&lt;</a>
<a name="ln1090">  typename Tag,typename Value,typename IndexSpecifierList,typename Allocator</a>
<a name="ln1091">&gt;</a>
<a name="ln1092">typename ::boost::multi_index::index&lt;</a>
<a name="ln1093">  multi_index_container&lt;Value,IndexSpecifierList,Allocator&gt;,Tag&gt;::type&amp;</a>
<a name="ln1094">get(</a>
<a name="ln1095">  multi_index_container&lt;Value,IndexSpecifierList,Allocator&gt;&amp; m)BOOST_NOEXCEPT</a>
<a name="ln1096">{</a>
<a name="ln1097">  typedef multi_index_container&lt;</a>
<a name="ln1098">    Value,IndexSpecifierList,Allocator&gt;         multi_index_type;</a>
<a name="ln1099">  typedef typename ::boost::multi_index::index&lt;</a>
<a name="ln1100">    multi_index_container&lt;</a>
<a name="ln1101">      Value,IndexSpecifierList,Allocator&gt;,</a>
<a name="ln1102">    Tag</a>
<a name="ln1103">  &gt;::type                                       index_type;</a>
<a name="ln1104"> </a>
<a name="ln1105">  return detail::converter&lt;multi_index_type,index_type&gt;::index(m);</a>
<a name="ln1106">}</a>
<a name="ln1107"> </a>
<a name="ln1108">template&lt;</a>
<a name="ln1109">  typename Tag,typename Value,typename IndexSpecifierList,typename Allocator</a>
<a name="ln1110">&gt;</a>
<a name="ln1111">const typename ::boost::multi_index::index&lt;</a>
<a name="ln1112">  multi_index_container&lt;Value,IndexSpecifierList,Allocator&gt;,Tag&gt;::type&amp;</a>
<a name="ln1113">get(</a>
<a name="ln1114">  const multi_index_container&lt;Value,IndexSpecifierList,Allocator&gt;&amp; m</a>
<a name="ln1115">)BOOST_NOEXCEPT</a>
<a name="ln1116">{</a>
<a name="ln1117">  typedef multi_index_container&lt;</a>
<a name="ln1118">    Value,IndexSpecifierList,Allocator&gt;         multi_index_type;</a>
<a name="ln1119">  typedef typename ::boost::multi_index::index&lt;</a>
<a name="ln1120">    multi_index_container&lt;</a>
<a name="ln1121">      Value,IndexSpecifierList,Allocator&gt;,</a>
<a name="ln1122">    Tag</a>
<a name="ln1123">  &gt;::type                                       index_type;</a>
<a name="ln1124"> </a>
<a name="ln1125">  return detail::converter&lt;multi_index_type,index_type&gt;::index(m);</a>
<a name="ln1126">}</a>
<a name="ln1127"> </a>
<a name="ln1128">/* projection of iterators by number */</a>
<a name="ln1129"> </a>
<a name="ln1130">template&lt;typename MultiIndexContainer,int N&gt;</a>
<a name="ln1131">struct nth_index_iterator</a>
<a name="ln1132">{</a>
<a name="ln1133">  typedef typename nth_index&lt;MultiIndexContainer,N&gt;::type::iterator type;</a>
<a name="ln1134">};</a>
<a name="ln1135"> </a>
<a name="ln1136">template&lt;typename MultiIndexContainer,int N&gt;</a>
<a name="ln1137">struct nth_index_const_iterator</a>
<a name="ln1138">{</a>
<a name="ln1139">  typedef typename nth_index&lt;MultiIndexContainer,N&gt;::type::const_iterator type;</a>
<a name="ln1140">};</a>
<a name="ln1141"> </a>
<a name="ln1142">template&lt;</a>
<a name="ln1143">  int N,typename IteratorType,</a>
<a name="ln1144">  typename Value,typename IndexSpecifierList,typename Allocator&gt;</a>
<a name="ln1145">typename nth_index_iterator&lt;</a>
<a name="ln1146">  multi_index_container&lt;Value,IndexSpecifierList,Allocator&gt;,N&gt;::type</a>
<a name="ln1147">project(</a>
<a name="ln1148">  multi_index_container&lt;Value,IndexSpecifierList,Allocator&gt;&amp; m,</a>
<a name="ln1149">  IteratorType it)</a>
<a name="ln1150">{</a>
<a name="ln1151">  typedef multi_index_container&lt;</a>
<a name="ln1152">    Value,IndexSpecifierList,Allocator&gt;                multi_index_type;</a>
<a name="ln1153">  typedef typename nth_index&lt;multi_index_type,N&gt;::type index_type;</a>
<a name="ln1154"> </a>
<a name="ln1155">#if !defined(__SUNPRO_CC)||!(__SUNPRO_CC&lt;0x580) /* Sun C++ 5.7 fails */</a>
<a name="ln1156">  BOOST_STATIC_ASSERT((</a>
<a name="ln1157">    mpl::contains&lt;</a>
<a name="ln1158">      BOOST_DEDUCED_TYPENAME multi_index_type::iterator_type_list,</a>
<a name="ln1159">      IteratorType&gt;::value));</a>
<a name="ln1160">#endif</a>
<a name="ln1161"> </a>
<a name="ln1162">  BOOST_MULTI_INDEX_CHECK_VALID_ITERATOR(it);</a>
<a name="ln1163"> </a>
<a name="ln1164">#if defined(BOOST_MULTI_INDEX_ENABLE_SAFE_MODE)</a>
<a name="ln1165">  typedef detail::converter&lt;</a>
<a name="ln1166">    multi_index_type,</a>
<a name="ln1167">    BOOST_DEDUCED_TYPENAME IteratorType::container_type&gt; converter;</a>
<a name="ln1168">  BOOST_MULTI_INDEX_CHECK_IS_OWNER(it,converter::index(m));</a>
<a name="ln1169">#endif</a>
<a name="ln1170"> </a>
<a name="ln1171">  return detail::converter&lt;multi_index_type,index_type&gt;::iterator(</a>
<a name="ln1172">    m,static_cast&lt;typename multi_index_type::node_type*&gt;(it.get_node()));</a>
<a name="ln1173">}</a>
<a name="ln1174"> </a>
<a name="ln1175">template&lt;</a>
<a name="ln1176">  int N,typename IteratorType,</a>
<a name="ln1177">  typename Value,typename IndexSpecifierList,typename Allocator&gt;</a>
<a name="ln1178">typename nth_index_const_iterator&lt;</a>
<a name="ln1179">  multi_index_container&lt;Value,IndexSpecifierList,Allocator&gt;,N&gt;::type</a>
<a name="ln1180">project(</a>
<a name="ln1181">  const multi_index_container&lt;Value,IndexSpecifierList,Allocator&gt;&amp; m,</a>
<a name="ln1182">  IteratorType it)</a>
<a name="ln1183">{</a>
<a name="ln1184">  typedef multi_index_container&lt;</a>
<a name="ln1185">    Value,IndexSpecifierList,Allocator&gt;                multi_index_type;</a>
<a name="ln1186">  typedef typename nth_index&lt;multi_index_type,N&gt;::type index_type;</a>
<a name="ln1187"> </a>
<a name="ln1188">#if !defined(__SUNPRO_CC)||!(__SUNPRO_CC&lt;0x580) /* Sun C++ 5.7 fails */</a>
<a name="ln1189">  BOOST_STATIC_ASSERT((</a>
<a name="ln1190">    mpl::contains&lt;</a>
<a name="ln1191">      BOOST_DEDUCED_TYPENAME multi_index_type::iterator_type_list,</a>
<a name="ln1192">      IteratorType&gt;::value||</a>
<a name="ln1193">    mpl::contains&lt;</a>
<a name="ln1194">      BOOST_DEDUCED_TYPENAME multi_index_type::const_iterator_type_list,</a>
<a name="ln1195">      IteratorType&gt;::value));</a>
<a name="ln1196">#endif</a>
<a name="ln1197"> </a>
<a name="ln1198">  BOOST_MULTI_INDEX_CHECK_VALID_ITERATOR(it);</a>
<a name="ln1199"> </a>
<a name="ln1200">#if defined(BOOST_MULTI_INDEX_ENABLE_SAFE_MODE)</a>
<a name="ln1201">  typedef detail::converter&lt;</a>
<a name="ln1202">    multi_index_type,</a>
<a name="ln1203">    BOOST_DEDUCED_TYPENAME IteratorType::container_type&gt; converter;</a>
<a name="ln1204">  BOOST_MULTI_INDEX_CHECK_IS_OWNER(it,converter::index(m));</a>
<a name="ln1205">#endif</a>
<a name="ln1206"> </a>
<a name="ln1207">  return detail::converter&lt;multi_index_type,index_type&gt;::const_iterator(</a>
<a name="ln1208">    m,static_cast&lt;typename multi_index_type::node_type*&gt;(it.get_node()));</a>
<a name="ln1209">}</a>
<a name="ln1210"> </a>
<a name="ln1211">/* projection of iterators by tag */</a>
<a name="ln1212"> </a>
<a name="ln1213">template&lt;typename MultiIndexContainer,typename Tag&gt;</a>
<a name="ln1214">struct index_iterator</a>
<a name="ln1215">{</a>
<a name="ln1216">  typedef typename ::boost::multi_index::index&lt;</a>
<a name="ln1217">    MultiIndexContainer,Tag&gt;::type::iterator    type;</a>
<a name="ln1218">};</a>
<a name="ln1219"> </a>
<a name="ln1220">template&lt;typename MultiIndexContainer,typename Tag&gt;</a>
<a name="ln1221">struct index_const_iterator</a>
<a name="ln1222">{</a>
<a name="ln1223">  typedef typename ::boost::multi_index::index&lt;</a>
<a name="ln1224">    MultiIndexContainer,Tag&gt;::type::const_iterator type;</a>
<a name="ln1225">};</a>
<a name="ln1226"> </a>
<a name="ln1227">template&lt;</a>
<a name="ln1228">  typename Tag,typename IteratorType,</a>
<a name="ln1229">  typename Value,typename IndexSpecifierList,typename Allocator&gt;</a>
<a name="ln1230">typename index_iterator&lt;</a>
<a name="ln1231">  multi_index_container&lt;Value,IndexSpecifierList,Allocator&gt;,Tag&gt;::type</a>
<a name="ln1232">project(</a>
<a name="ln1233">  multi_index_container&lt;Value,IndexSpecifierList,Allocator&gt;&amp; m,</a>
<a name="ln1234">  IteratorType it)</a>
<a name="ln1235">{</a>
<a name="ln1236">  typedef multi_index_container&lt;</a>
<a name="ln1237">    Value,IndexSpecifierList,Allocator&gt;         multi_index_type;</a>
<a name="ln1238">  typedef typename ::boost::multi_index::index&lt;</a>
<a name="ln1239">    multi_index_type,Tag&gt;::type                 index_type;</a>
<a name="ln1240"> </a>
<a name="ln1241">#if !defined(__SUNPRO_CC)||!(__SUNPRO_CC&lt;0x580) /* Sun C++ 5.7 fails */</a>
<a name="ln1242">  BOOST_STATIC_ASSERT((</a>
<a name="ln1243">    mpl::contains&lt;</a>
<a name="ln1244">      BOOST_DEDUCED_TYPENAME multi_index_type::iterator_type_list,</a>
<a name="ln1245">      IteratorType&gt;::value));</a>
<a name="ln1246">#endif</a>
<a name="ln1247"> </a>
<a name="ln1248">  BOOST_MULTI_INDEX_CHECK_VALID_ITERATOR(it);</a>
<a name="ln1249"> </a>
<a name="ln1250">#if defined(BOOST_MULTI_INDEX_ENABLE_SAFE_MODE)</a>
<a name="ln1251">  typedef detail::converter&lt;</a>
<a name="ln1252">    multi_index_type,</a>
<a name="ln1253">    BOOST_DEDUCED_TYPENAME IteratorType::container_type&gt; converter;</a>
<a name="ln1254">  BOOST_MULTI_INDEX_CHECK_IS_OWNER(it,converter::index(m));</a>
<a name="ln1255">#endif</a>
<a name="ln1256"> </a>
<a name="ln1257">  return detail::converter&lt;multi_index_type,index_type&gt;::iterator(</a>
<a name="ln1258">    m,static_cast&lt;typename multi_index_type::node_type*&gt;(it.get_node()));</a>
<a name="ln1259">}</a>
<a name="ln1260"> </a>
<a name="ln1261">template&lt;</a>
<a name="ln1262">  typename Tag,typename IteratorType,</a>
<a name="ln1263">  typename Value,typename IndexSpecifierList,typename Allocator&gt;</a>
<a name="ln1264">typename index_const_iterator&lt;</a>
<a name="ln1265">  multi_index_container&lt;Value,IndexSpecifierList,Allocator&gt;,Tag&gt;::type</a>
<a name="ln1266">project(</a>
<a name="ln1267">  const multi_index_container&lt;Value,IndexSpecifierList,Allocator&gt;&amp; m,</a>
<a name="ln1268">  IteratorType it)</a>
<a name="ln1269">{</a>
<a name="ln1270">  typedef multi_index_container&lt;</a>
<a name="ln1271">    Value,IndexSpecifierList,Allocator&gt;         multi_index_type;</a>
<a name="ln1272">  typedef typename ::boost::multi_index::index&lt;</a>
<a name="ln1273">    multi_index_type,Tag&gt;::type                 index_type;</a>
<a name="ln1274"> </a>
<a name="ln1275">#if !defined(__SUNPRO_CC)||!(__SUNPRO_CC&lt;0x580) /* Sun C++ 5.7 fails */</a>
<a name="ln1276">  BOOST_STATIC_ASSERT((</a>
<a name="ln1277">    mpl::contains&lt;</a>
<a name="ln1278">      BOOST_DEDUCED_TYPENAME multi_index_type::iterator_type_list,</a>
<a name="ln1279">      IteratorType&gt;::value||</a>
<a name="ln1280">    mpl::contains&lt;</a>
<a name="ln1281">      BOOST_DEDUCED_TYPENAME multi_index_type::const_iterator_type_list,</a>
<a name="ln1282">      IteratorType&gt;::value));</a>
<a name="ln1283">#endif</a>
<a name="ln1284"> </a>
<a name="ln1285">  BOOST_MULTI_INDEX_CHECK_VALID_ITERATOR(it);</a>
<a name="ln1286"> </a>
<a name="ln1287">#if defined(BOOST_MULTI_INDEX_ENABLE_SAFE_MODE)</a>
<a name="ln1288">  typedef detail::converter&lt;</a>
<a name="ln1289">    multi_index_type,</a>
<a name="ln1290">    BOOST_DEDUCED_TYPENAME IteratorType::container_type&gt; converter;</a>
<a name="ln1291">  BOOST_MULTI_INDEX_CHECK_IS_OWNER(it,converter::index(m));</a>
<a name="ln1292">#endif</a>
<a name="ln1293"> </a>
<a name="ln1294">  return detail::converter&lt;multi_index_type,index_type&gt;::const_iterator(</a>
<a name="ln1295">    m,static_cast&lt;typename multi_index_type::node_type*&gt;(it.get_node()));</a>
<a name="ln1296">}</a>
<a name="ln1297"> </a>
<a name="ln1298">/* Comparison. Simple forward to first index. */</a>
<a name="ln1299"> </a>
<a name="ln1300">template&lt;</a>
<a name="ln1301">  typename Value1,typename IndexSpecifierList1,typename Allocator1,</a>
<a name="ln1302">  typename Value2,typename IndexSpecifierList2,typename Allocator2</a>
<a name="ln1303">&gt;</a>
<a name="ln1304">bool operator==(</a>
<a name="ln1305">  const multi_index_container&lt;Value1,IndexSpecifierList1,Allocator1&gt;&amp; x,</a>
<a name="ln1306">  const multi_index_container&lt;Value2,IndexSpecifierList2,Allocator2&gt;&amp; y)</a>
<a name="ln1307">{</a>
<a name="ln1308">  return get&lt;0&gt;(x)==get&lt;0&gt;(y);</a>
<a name="ln1309">}</a>
<a name="ln1310"> </a>
<a name="ln1311">template&lt;</a>
<a name="ln1312">  typename Value1,typename IndexSpecifierList1,typename Allocator1,</a>
<a name="ln1313">  typename Value2,typename IndexSpecifierList2,typename Allocator2</a>
<a name="ln1314">&gt;</a>
<a name="ln1315">bool operator&lt;(</a>
<a name="ln1316">  const multi_index_container&lt;Value1,IndexSpecifierList1,Allocator1&gt;&amp; x,</a>
<a name="ln1317">  const multi_index_container&lt;Value2,IndexSpecifierList2,Allocator2&gt;&amp; y)</a>
<a name="ln1318">{</a>
<a name="ln1319">  return get&lt;0&gt;(x)&lt;get&lt;0&gt;(y);</a>
<a name="ln1320">}</a>
<a name="ln1321"> </a>
<a name="ln1322">template&lt;</a>
<a name="ln1323">  typename Value1,typename IndexSpecifierList1,typename Allocator1,</a>
<a name="ln1324">  typename Value2,typename IndexSpecifierList2,typename Allocator2</a>
<a name="ln1325">&gt;</a>
<a name="ln1326">bool operator!=(</a>
<a name="ln1327">  const multi_index_container&lt;Value1,IndexSpecifierList1,Allocator1&gt;&amp; x,</a>
<a name="ln1328">  const multi_index_container&lt;Value2,IndexSpecifierList2,Allocator2&gt;&amp; y)</a>
<a name="ln1329">{</a>
<a name="ln1330">  return get&lt;0&gt;(x)!=get&lt;0&gt;(y);</a>
<a name="ln1331">}</a>
<a name="ln1332"> </a>
<a name="ln1333">template&lt;</a>
<a name="ln1334">  typename Value1,typename IndexSpecifierList1,typename Allocator1,</a>
<a name="ln1335">  typename Value2,typename IndexSpecifierList2,typename Allocator2</a>
<a name="ln1336">&gt;</a>
<a name="ln1337">bool operator&gt;(</a>
<a name="ln1338">  const multi_index_container&lt;Value1,IndexSpecifierList1,Allocator1&gt;&amp; x,</a>
<a name="ln1339">  const multi_index_container&lt;Value2,IndexSpecifierList2,Allocator2&gt;&amp; y)</a>
<a name="ln1340">{</a>
<a name="ln1341">  return get&lt;0&gt;(x)&gt;get&lt;0&gt;(y);</a>
<a name="ln1342">}</a>
<a name="ln1343"> </a>
<a name="ln1344">template&lt;</a>
<a name="ln1345">  typename Value1,typename IndexSpecifierList1,typename Allocator1,</a>
<a name="ln1346">  typename Value2,typename IndexSpecifierList2,typename Allocator2</a>
<a name="ln1347">&gt;</a>
<a name="ln1348">bool operator&gt;=(</a>
<a name="ln1349">  const multi_index_container&lt;Value1,IndexSpecifierList1,Allocator1&gt;&amp; x,</a>
<a name="ln1350">  const multi_index_container&lt;Value2,IndexSpecifierList2,Allocator2&gt;&amp; y)</a>
<a name="ln1351">{</a>
<a name="ln1352">  return get&lt;0&gt;(x)&gt;=get&lt;0&gt;(y);</a>
<a name="ln1353">}</a>
<a name="ln1354"> </a>
<a name="ln1355">template&lt;</a>
<a name="ln1356">  typename Value1,typename IndexSpecifierList1,typename Allocator1,</a>
<a name="ln1357">  typename Value2,typename IndexSpecifierList2,typename Allocator2</a>
<a name="ln1358">&gt;</a>
<a name="ln1359">bool operator&lt;=(</a>
<a name="ln1360">  const multi_index_container&lt;Value1,IndexSpecifierList1,Allocator1&gt;&amp; x,</a>
<a name="ln1361">  const multi_index_container&lt;Value2,IndexSpecifierList2,Allocator2&gt;&amp; y)</a>
<a name="ln1362">{</a>
<a name="ln1363">  return get&lt;0&gt;(x)&lt;=get&lt;0&gt;(y);</a>
<a name="ln1364">}</a>
<a name="ln1365"> </a>
<a name="ln1366">/*  specialized algorithms */</a>
<a name="ln1367"> </a>
<a name="ln1368">template&lt;typename Value,typename IndexSpecifierList,typename Allocator&gt;</a>
<a name="ln1369">void swap(</a>
<a name="ln1370">  multi_index_container&lt;Value,IndexSpecifierList,Allocator&gt;&amp; x,</a>
<a name="ln1371">  multi_index_container&lt;Value,IndexSpecifierList,Allocator&gt;&amp; y)</a>
<a name="ln1372">{</a>
<a name="ln1373">  x.swap(y);</a>
<a name="ln1374">}</a>
<a name="ln1375"> </a>
<a name="ln1376">} /* namespace multi_index */</a>
<a name="ln1377"> </a>
<a name="ln1378">#if !defined(BOOST_MULTI_INDEX_DISABLE_SERIALIZATION)</a>
<a name="ln1379">/* class version = 1 : we now serialize the size through</a>
<a name="ln1380"> * boost::serialization::collection_size_type.</a>
<a name="ln1381"> * class version = 2 : proper use of {save|load}_construct_data.</a>
<a name="ln1382"> */</a>
<a name="ln1383"> </a>
<a name="ln1384">namespace serialization {</a>
<a name="ln1385">template&lt;typename Value,typename IndexSpecifierList,typename Allocator&gt;</a>
<a name="ln1386">struct version&lt;</a>
<a name="ln1387">  boost::multi_index_container&lt;Value,IndexSpecifierList,Allocator&gt;</a>
<a name="ln1388">&gt;</a>
<a name="ln1389">{</a>
<a name="ln1390">  BOOST_STATIC_CONSTANT(int,value=2);</a>
<a name="ln1391">};</a>
<a name="ln1392">} /* namespace serialization */</a>
<a name="ln1393">#endif</a>
<a name="ln1394"> </a>
<a name="ln1395">/* Associated global functions are promoted to namespace boost, except</a>
<a name="ln1396"> * comparison operators and swap, which are meant to be Koenig looked-up.</a>
<a name="ln1397"> */</a>
<a name="ln1398"> </a>
<a name="ln1399">using multi_index::get;</a>
<a name="ln1400">using multi_index::project;</a>
<a name="ln1401"> </a>
<a name="ln1402">} /* namespace boost */</a>
<a name="ln1403"> </a>
<a name="ln1404">#undef BOOST_MULTI_INDEX_CHECK_INVARIANT</a>
<a name="ln1405">#undef BOOST_MULTI_INDEX_CHECK_INVARIANT_OF</a>
<a name="ln1406"> </a>
<a name="ln1407">#endif</a>

</code></pre>
<div class="balloon" rel="885"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v667/" target="_blank">V667</a> The 'throw' operator does not possess any arguments and is not situated within the 'catch' block.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
