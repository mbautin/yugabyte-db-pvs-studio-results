
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>tablet_metadata.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Licensed to the Apache Software Foundation (ASF) under one</a>
<a name="ln2">// or more contributor license agreements.  See the NOTICE file</a>
<a name="ln3">// distributed with this work for additional information</a>
<a name="ln4">// regarding copyright ownership.  The ASF licenses this file</a>
<a name="ln5">// to you under the Apache License, Version 2.0 (the</a>
<a name="ln6">// &quot;License&quot;); you may not use this file except in compliance</a>
<a name="ln7">// with the License.  You may obtain a copy of the License at</a>
<a name="ln8">//</a>
<a name="ln9">//   http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln10">//</a>
<a name="ln11">// Unless required by applicable law or agreed to in writing,</a>
<a name="ln12">// software distributed under the License is distributed on an</a>
<a name="ln13">// &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</a>
<a name="ln14">// KIND, either express or implied.  See the License for the</a>
<a name="ln15">// specific language governing permissions and limitations</a>
<a name="ln16">// under the License.</a>
<a name="ln17">//</a>
<a name="ln18">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln19">//</a>
<a name="ln20">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln21">//</a>
<a name="ln22">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln23">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln24">//</a>
<a name="ln25">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln26">//</a>
<a name="ln27">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln28">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln29">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln30">// under the License.</a>
<a name="ln31">//</a>
<a name="ln32">#ifndef YB_TABLET_TABLET_METADATA_H</a>
<a name="ln33">#define YB_TABLET_TABLET_METADATA_H</a>
<a name="ln34"> </a>
<a name="ln35">#include &lt;memory&gt;</a>
<a name="ln36">#include &lt;string&gt;</a>
<a name="ln37">#include &lt;unordered_set&gt;</a>
<a name="ln38">#include &lt;vector&gt;</a>
<a name="ln39"> </a>
<a name="ln40">#include &lt;boost/optional/optional_fwd.hpp&gt;</a>
<a name="ln41"> </a>
<a name="ln42">#include &quot;yb/common/entity_ids.h&quot;</a>
<a name="ln43">#include &quot;yb/common/index.h&quot;</a>
<a name="ln44">#include &quot;yb/common/partition.h&quot;</a>
<a name="ln45">#include &quot;yb/common/schema.h&quot;</a>
<a name="ln46">#include &quot;yb/consensus/opid_util.h&quot;</a>
<a name="ln47">#include &quot;yb/fs/fs_manager.h&quot;</a>
<a name="ln48">#include &quot;yb/gutil/callback.h&quot;</a>
<a name="ln49">#include &quot;yb/gutil/dynamic_annotations.h&quot;</a>
<a name="ln50">#include &quot;yb/gutil/macros.h&quot;</a>
<a name="ln51">#include &quot;yb/gutil/ref_counted.h&quot;</a>
<a name="ln52"> </a>
<a name="ln53">#include &quot;yb/tablet/metadata.pb.h&quot;</a>
<a name="ln54">#include &quot;yb/tablet/tablet_fwd.h&quot;</a>
<a name="ln55"> </a>
<a name="ln56">#include &quot;yb/util/mutex.h&quot;</a>
<a name="ln57">#include &quot;yb/util/opid.h&quot;</a>
<a name="ln58">#include &quot;yb/util/opid.pb.h&quot;</a>
<a name="ln59">#include &quot;yb/util/status.h&quot;</a>
<a name="ln60">#include &quot;yb/util/status_callback.h&quot;</a>
<a name="ln61"> </a>
<a name="ln62">namespace yb {</a>
<a name="ln63">namespace tablet {</a>
<a name="ln64"> </a>
<a name="ln65">extern const int64 kNoDurableMemStore;</a>
<a name="ln66">extern const std::string kIntentsSubdir;</a>
<a name="ln67">extern const std::string kIntentsDBSuffix;</a>
<a name="ln68">extern const std::string kSnapshotsDirSuffix;</a>
<a name="ln69"> </a>
<a name="ln70">  // Table info.</a>
<a name="ln71">struct TableInfo {</a>
<a name="ln72">  // Table id, name and type.</a>
<a name="ln73">  std::string table_id;</a>
<a name="ln74">  std::string namespace_name;</a>
<a name="ln75">  std::string table_name;</a>
<a name="ln76">  TableType table_type;</a>
<a name="ln77"> </a>
<a name="ln78">  // The table schema, secondary index map, index info (for index table only) and schema version.</a>
<a name="ln79">  Schema schema;</a>
<a name="ln80">  IndexMap index_map;</a>
<a name="ln81">  std::unique_ptr&lt;IndexInfo&gt; index_info;</a>
<a name="ln82">  uint32_t schema_version = 0;</a>
<a name="ln83"> </a>
<a name="ln84">  // Partition schema of the table.</a>
<a name="ln85">  PartitionSchema partition_schema;</a>
<a name="ln86"> </a>
<a name="ln87">  // A vector of column IDs that have been deleted, so that the compaction filter can free the</a>
<a name="ln88">  // associated memory. As of 01/2019, deleted column IDs are persisted forever, even if all the</a>
<a name="ln89">  // associated data has been discarded. In the future, we can garbage collect such column IDs to</a>
<a name="ln90">  // make sure this vector doesn't grow too large.</a>
<a name="ln91">  std::vector&lt;DeletedColumn&gt; deleted_cols;</a>
<a name="ln92"> </a>
<a name="ln93">  // We use the retention time from the primary table.</a>
<a name="ln94">  uint32_t wal_retention_secs = 0;</a>
<a name="ln95"> </a>
<a name="ln96">  TableInfo() = default;</a>
<a name="ln97">  TableInfo(std::string table_id,</a>
<a name="ln98">            std::string namespace_name,</a>
<a name="ln99">            std::string table_name,</a>
<a name="ln100">            TableType table_type,</a>
<a name="ln101">            const Schema&amp; schema,</a>
<a name="ln102">            const IndexMap&amp; index_map,</a>
<a name="ln103">            const boost::optional&lt;IndexInfo&gt;&amp; index_info,</a>
<a name="ln104">            uint32_t schema_version,</a>
<a name="ln105">            PartitionSchema partition_schema);</a>
<a name="ln106">  TableInfo(const TableInfo&amp; other,</a>
<a name="ln107">            const Schema&amp; schema,</a>
<a name="ln108">            const IndexMap&amp; index_map,</a>
<a name="ln109">            const std::vector&lt;DeletedColumn&gt;&amp; deleted_cols,</a>
<a name="ln110">            uint32_t schema_version);</a>
<a name="ln111"> </a>
<a name="ln112">  CHECKED_STATUS LoadFromPB(const TableInfoPB&amp; pb);</a>
<a name="ln113">  void ToPB(TableInfoPB* pb) const;</a>
<a name="ln114"> </a>
<a name="ln115">  std::string ToString() const {</a>
<a name="ln116">    TableInfoPB pb;</a>
<a name="ln117">    ToPB(&amp;pb);</a>
<a name="ln118">    return pb.ShortDebugString();</a>
<a name="ln119">  }</a>
<a name="ln120">};</a>
<a name="ln121"> </a>
<a name="ln122">// Describes KV-store. Single KV-store is backed by one or two RocksDB instances, depending on</a>
<a name="ln123">// whether distributed transactions are enabled for the table. KV-store for sys catalog could</a>
<a name="ln124">// contain multiple tables.</a>
<a name="ln125">struct KvStoreInfo {</a>
<a name="ln126">  explicit KvStoreInfo(const KvStoreId&amp; kv_store_id_) : kv_store_id(kv_store_id_) {}</a>
<a name="ln127"> </a>
<a name="ln128">  KvStoreInfo(const KvStoreId&amp; kv_store_id_, const std::string&amp; rocksdb_dir_)</a>
<a name="ln129">      : kv_store_id(kv_store_id_),</a>
<a name="ln130">        rocksdb_dir(rocksdb_dir_) {}</a>
<a name="ln131"> </a>
<a name="ln132">  CHECKED_STATUS LoadFromPB(const KvStoreInfoPB&amp; pb, TableId primary_table_id);</a>
<a name="ln133"> </a>
<a name="ln134">  CHECKED_STATUS LoadTablesFromPB(</a>
<a name="ln135">      google::protobuf::RepeatedPtrField&lt;TableInfoPB&gt; pbs, TableId primary_table_id);</a>
<a name="ln136"> </a>
<a name="ln137">  void ToPB(TableId primary_table_id, KvStoreInfoPB* pb) const;</a>
<a name="ln138"> </a>
<a name="ln139">  KvStoreId kv_store_id;</a>
<a name="ln140"> </a>
<a name="ln141">  // The directory where the regular RocksDB data for this KV-store is stored. For KV-stores having</a>
<a name="ln142">  // tables with distributed transactions enabled an additional RocksDB is created in directory at</a>
<a name="ln143">  // `rocksdb_dir + kIntentsDBSuffix` path.</a>
<a name="ln144">  std::string rocksdb_dir;</a>
<a name="ln145"> </a>
<a name="ln146">  // Optional inclusive lower bound and exclusive upper bound for keys served by this KV-store.</a>
<a name="ln147">  // See docdb::KeyBounds.</a>
<a name="ln148">  std::string lower_bound_key;</a>
<a name="ln149">  std::string upper_bound_key;</a>
<a name="ln150"> </a>
<a name="ln151">  // See KvStoreInfoPB field with the same name.</a>
<a name="ln152">  bool has_been_fully_compacted = false;</a>
<a name="ln153"> </a>
<a name="ln154">  // Map of tables sharing this KV-store indexed by the table id.</a>
<a name="ln155">  // If pieces of the same table live in the same Raft group they should be located in different</a>
<a name="ln156">  // KV-stores.</a>
<a name="ln157">  std::unordered_map&lt;TableId, TableInfoPtr&gt; tables;</a>
<a name="ln158">};</a>
<a name="ln159"> </a>
<a name="ln160">// At startup, the TSTabletManager will load a RaftGroupMetadata for each</a>
<a name="ln161">// super block found in the tablets/ directory, and then instantiate</a>
<a name="ln162">// Raft groups from this data.</a>
<a name="ln163">class RaftGroupMetadata : public RefCountedThreadSafe&lt;RaftGroupMetadata&gt; {</a>
<a name="ln164"> public:</a>
<a name="ln165">  // Create metadata for a new Raft group. This assumes that the given superblock</a>
<a name="ln166">  // has not been written before, and writes out the initial superblock with</a>
<a name="ln167">  // the provided parameters.</a>
<a name="ln168">  // data_root_dir and wal_root_dir dictates which disk this Raft group will</a>
<a name="ln169">  // use in the respective directories.</a>
<a name="ln170">  // If empty string is passed in, it will be randomly chosen.</a>
<a name="ln171">  static CHECKED_STATUS CreateNew(FsManager* fs_manager,</a>
<a name="ln172">                                  const std::string&amp; table_id,</a>
<a name="ln173">                                  const RaftGroupId&amp; raft_group_id,</a>
<a name="ln174">                                  const std::string&amp; namespace_name,</a>
<a name="ln175">                                  const std::string&amp; table_name,</a>
<a name="ln176">                                  const TableType table_type,</a>
<a name="ln177">                                  const Schema&amp; schema,</a>
<a name="ln178">                                  const IndexMap&amp; index_map,</a>
<a name="ln179">                                  const PartitionSchema&amp; partition_schema,</a>
<a name="ln180">                                  const Partition&amp; partition,</a>
<a name="ln181">                                  const boost::optional&lt;IndexInfo&gt;&amp; index_info,</a>
<a name="ln182">                                  const uint32_t schema_version,</a>
<a name="ln183">                                  const TabletDataState&amp; initial_tablet_data_state,</a>
<a name="ln184">                                  RaftGroupMetadataPtr* metadata,</a>
<a name="ln185">                                  const std::string&amp; data_root_dir = std::string(),</a>
<a name="ln186">                                  const std::string&amp; wal_root_dir = std::string(),</a>
<a name="ln187">                                  const bool colocated = false);</a>
<a name="ln188"> </a>
<a name="ln189">  // Load existing metadata from disk.</a>
<a name="ln190">  static CHECKED_STATUS Load(FsManager* fs_manager,</a>
<a name="ln191">                             const RaftGroupId&amp; raft_group_id,</a>
<a name="ln192">                             RaftGroupMetadataPtr* metadata);</a>
<a name="ln193"> </a>
<a name="ln194">  // Try to load an existing Raft group. If it does not exist, create it.</a>
<a name="ln195">  // If it already existed, verifies that the schema of the Raft group matches the</a>
<a name="ln196">  // provided 'schema'.</a>
<a name="ln197">  //</a>
<a name="ln198">  // This is mostly useful for tests which instantiate Raft groups directly.</a>
<a name="ln199">  static CHECKED_STATUS LoadOrCreate(FsManager* fs_manager,</a>
<a name="ln200">                                     const std::string&amp; table_id,</a>
<a name="ln201">                                     const RaftGroupId&amp; raft_group_id,</a>
<a name="ln202">                                     const std::string&amp; namespace_name,</a>
<a name="ln203">                                     const std::string&amp; table_name,</a>
<a name="ln204">                                     const TableType table_type,</a>
<a name="ln205">                                     const Schema&amp; schema,</a>
<a name="ln206">                                     const PartitionSchema&amp; partition_schema,</a>
<a name="ln207">                                     const Partition&amp; partition,</a>
<a name="ln208">                                     const boost::optional&lt;IndexInfo&gt;&amp; index_info,</a>
<a name="ln209">                                     const TabletDataState&amp; initial_tablet_data_state,</a>
<a name="ln210">                                     RaftGroupMetadataPtr* metadata);</a>
<a name="ln211"> </a>
<a name="ln212">  Result&lt;TableInfoPtr&gt; GetTableInfo(const TableId&amp; table_id) const;</a>
<a name="ln213">  Result&lt;TableInfoPtr&gt; GetTableInfoUnlocked(const TableId&amp; table_id) const;</a>
<a name="ln214"> </a>
<a name="ln215">  const RaftGroupId&amp; raft_group_id() const {</a>
<a name="ln216">    DCHECK_NE(state_, kNotLoadedYet);</a>
<a name="ln217">    return raft_group_id_;</a>
<a name="ln218">  }</a>
<a name="ln219"> </a>
<a name="ln220">  // Returns the partition of the Raft group.</a>
<a name="ln221">  std::shared_ptr&lt;Partition&gt; partition() const {</a>
<a name="ln222">    DCHECK_NE(state_, kNotLoadedYet);</a>
<a name="ln223">    std::lock_guard&lt;MutexType&gt; lock(data_mutex_);</a>
<a name="ln224">    return partition_;</a>
<a name="ln225">  }</a>
<a name="ln226"> </a>
<a name="ln227">  // Returns the primary table id. For co-located tables, the primary table is the table this Raft</a>
<a name="ln228">  // group was first created for. For single-tenant table, it is the primary table.</a>
<a name="ln229">  TableId table_id() const {</a>
<a name="ln230">    DCHECK_NE(state_, kNotLoadedYet);</a>
<a name="ln231">    std::lock_guard&lt;MutexType&gt; lock(data_mutex_);</a>
<a name="ln232">    return primary_table_id_;</a>
<a name="ln233">  }</a>
<a name="ln234"> </a>
<a name="ln235">  // Returns the name, type, schema, index map, schema, etc of the table.</a>
<a name="ln236">  std::string namespace_name(const TableId&amp; table_id = &quot;&quot;) const {</a>
<a name="ln237">    DCHECK_NE(state_, kNotLoadedYet);</a>
<a name="ln238">    if (table_id.empty()) {</a>
<a name="ln239">      return primary_table_info()-&gt;namespace_name;</a>
<a name="ln240">    }</a>
<a name="ln241">    const auto&amp; table_info = CHECK_RESULT(GetTableInfo(table_id));</a>
<a name="ln242">    return table_info-&gt;namespace_name;</a>
<a name="ln243">  }</a>
<a name="ln244"> </a>
<a name="ln245">  std::string table_name(const TableId&amp; table_id = &quot;&quot;) const {</a>
<a name="ln246">    DCHECK_NE(state_, kNotLoadedYet);</a>
<a name="ln247">    if (table_id.empty()) {</a>
<a name="ln248">      return primary_table_info()-&gt;table_name;</a>
<a name="ln249">    }</a>
<a name="ln250">    const auto&amp; table_info = CHECK_RESULT(GetTableInfo(table_id));</a>
<a name="ln251">    return table_info-&gt;table_name;</a>
<a name="ln252">  }</a>
<a name="ln253"> </a>
<a name="ln254">  TableType table_type(const TableId&amp; table_id = &quot;&quot;) const {</a>
<a name="ln255">    DCHECK_NE(state_, kNotLoadedYet);</a>
<a name="ln256">    if (table_id.empty()) {</a>
<a name="ln257">      return primary_table_info()-&gt;table_type;</a>
<a name="ln258">    }</a>
<a name="ln259">    const auto&amp; table_info = CHECK_RESULT(GetTableInfo(table_id));</a>
<a name="ln260">    return table_info-&gt;table_type;</a>
<a name="ln261">  }</a>
<a name="ln262"> </a>
<a name="ln263">  yb::SchemaPtr schema(const TableId&amp; table_id = &quot;&quot;) const {</a>
<a name="ln264">    DCHECK_NE(state_, kNotLoadedYet);</a>
<a name="ln265">    const TableInfoPtr table_info =</a>
<a name="ln266">        table_id.empty() ? primary_table_info() : CHECK_RESULT(GetTableInfo(table_id));</a>
<a name="ln267">    return yb::SchemaPtr(table_info, &amp;table_info-&gt;schema);</a>
<a name="ln268">  }</a>
<a name="ln269"> </a>
<a name="ln270">  std::shared_ptr&lt;IndexMap&gt; index_map(const TableId&amp; table_id = &quot;&quot;) const {</a>
<a name="ln271">    DCHECK_NE(state_, kNotLoadedYet);</a>
<a name="ln272">    const TableInfoPtr table_info =</a>
<a name="ln273">        table_id.empty() ? primary_table_info() : CHECK_RESULT(GetTableInfo(table_id));</a>
<a name="ln274">    return std::shared_ptr&lt;IndexMap&gt;(table_info, &amp;table_info-&gt;index_map);</a>
<a name="ln275">  }</a>
<a name="ln276"> </a>
<a name="ln277">  uint32_t schema_version(const TableId&amp; table_id = &quot;&quot;) const {</a>
<a name="ln278">    DCHECK_NE(state_, kNotLoadedYet);</a>
<a name="ln279">    const TableInfoPtr table_info =</a>
<a name="ln280">        table_id.empty() ? primary_table_info() : CHECK_RESULT(GetTableInfo(table_id));</a>
<a name="ln281">    return table_info-&gt;schema_version;</a>
<a name="ln282">  }</a>
<a name="ln283"> </a>
<a name="ln284">  const std::string&amp; indexed_tablet_id(const TableId&amp; table_id = &quot;&quot;) const {</a>
<a name="ln285">    DCHECK_NE(state_, kNotLoadedYet);</a>
<a name="ln286">    static const std::string kEmptyString = &quot;&quot;;</a>
<a name="ln287">    std::lock_guard&lt;MutexType&gt; lock(data_mutex_);</a>
<a name="ln288">    const TableInfoPtr table_info = table_id.empty() ?</a>
<a name="ln289">        primary_table_info_unlocked() : CHECK_RESULT(GetTableInfoUnlocked(table_id));</a>
<a name="ln290">    const auto* index_info = table_info-&gt;index_info.get();</a>
<a name="ln291">    return index_info ? index_info-&gt;indexed_table_id() : kEmptyString;</a>
<a name="ln292">  }</a>
<a name="ln293"> </a>
<a name="ln294">  bool is_local_index(const TableId&amp; table_id = &quot;&quot;) const {</a>
<a name="ln295">    DCHECK_NE(state_, kNotLoadedYet);</a>
<a name="ln296">    std::lock_guard&lt;MutexType&gt; lock(data_mutex_);</a>
<a name="ln297">    const TableInfoPtr table_info = table_id.empty() ?</a>
<a name="ln298">        primary_table_info_unlocked() : CHECK_RESULT(GetTableInfoUnlocked(table_id));</a>
<a name="ln299">    const auto* index_info = table_info-&gt;index_info.get();</a>
<a name="ln300">    return index_info &amp;&amp; index_info-&gt;is_local();</a>
<a name="ln301">  }</a>
<a name="ln302"> </a>
<a name="ln303">  bool is_unique_index(const TableId&amp; table_id = &quot;&quot;) const {</a>
<a name="ln304">    DCHECK_NE(state_, kNotLoadedYet);</a>
<a name="ln305">    std::lock_guard&lt;MutexType&gt; lock(data_mutex_);</a>
<a name="ln306">    const TableInfoPtr table_info = table_id.empty() ?</a>
<a name="ln307">        primary_table_info_unlocked() : CHECK_RESULT(GetTableInfoUnlocked(table_id));</a>
<a name="ln308">    const auto* index_info = table_info-&gt;index_info.get();</a>
<a name="ln309">    return index_info &amp;&amp; index_info-&gt;is_unique();</a>
<a name="ln310">  }</a>
<a name="ln311"> </a>
<a name="ln312">  std::vector&lt;ColumnId&gt; index_key_column_ids(const TableId&amp; table_id = &quot;&quot;) const {</a>
<a name="ln313">    DCHECK_NE(state_, kNotLoadedYet);</a>
<a name="ln314">    std::lock_guard&lt;MutexType&gt; lock(data_mutex_);</a>
<a name="ln315">    const TableInfoPtr table_info = table_id.empty() ?</a>
<a name="ln316">        primary_table_info_unlocked() : CHECK_RESULT(GetTableInfoUnlocked(table_id));</a>
<a name="ln317">    const auto* index_info = table_info-&gt;index_info.get();</a>
<a name="ln318">    return index_info ? index_info-&gt;index_key_column_ids() : std::vector&lt;ColumnId&gt;();</a>
<a name="ln319">  }</a>
<a name="ln320"> </a>
<a name="ln321">  // Returns the partition schema of the Raft group's tables.</a>
<a name="ln322">  const std::shared_ptr&lt;PartitionSchema&gt; partition_schema() const {</a>
<a name="ln323">    DCHECK_NE(state_, kNotLoadedYet);</a>
<a name="ln324">    const TableInfoPtr table_info = primary_table_info();</a>
<a name="ln325">    return std::shared_ptr&lt;PartitionSchema&gt;(table_info, &amp;table_info-&gt;partition_schema);</a>
<a name="ln326">  }</a>
<a name="ln327"> </a>
<a name="ln328">  const std::shared_ptr&lt;std::vector&lt;DeletedColumn&gt;&gt; deleted_cols(</a>
<a name="ln329">      const TableId&amp; table_id = &quot;&quot;) const {</a>
<a name="ln330">    DCHECK_NE(state_, kNotLoadedYet);</a>
<a name="ln331">    const TableInfoPtr table_info =</a>
<a name="ln332">        table_id.empty() ? primary_table_info() : CHECK_RESULT(GetTableInfo(table_id));</a>
<a name="ln333">    return std::shared_ptr&lt;std::vector&lt;DeletedColumn&gt;&gt;(table_info, &amp;table_info-&gt;deleted_cols);</a>
<a name="ln334">  }</a>
<a name="ln335"> </a>
<a name="ln336">  std::string rocksdb_dir() const { return kv_store_.rocksdb_dir; }</a>
<a name="ln337">  std::string intents_rocksdb_dir() const { return kv_store_.rocksdb_dir + kIntentsDBSuffix; }</a>
<a name="ln338">  std::string snapshots_dir() const { return kv_store_.rocksdb_dir + kSnapshotsDirSuffix; }</a>
<a name="ln339"> </a>
<a name="ln340">  std::string lower_bound_key() const { return kv_store_.lower_bound_key; }</a>
<a name="ln341">  std::string upper_bound_key() const { return kv_store_.upper_bound_key; }</a>
<a name="ln342"> </a>
<a name="ln343">  std::string wal_dir() const { return wal_dir_; }</a>
<a name="ln344"> </a>
<a name="ln345">  // Set the WAL retention time for the primary table.</a>
<a name="ln346">  void set_wal_retention_secs(uint32 wal_retention_secs);</a>
<a name="ln347"> </a>
<a name="ln348">  // Returns the wal retention time for the primary table.</a>
<a name="ln349">  uint32_t wal_retention_secs() const;</a>
<a name="ln350"> </a>
<a name="ln351">  CHECKED_STATUS set_cdc_min_replicated_index(int64 cdc_min_replicated_index);</a>
<a name="ln352"> </a>
<a name="ln353">  int64_t cdc_min_replicated_index() const;</a>
<a name="ln354"> </a>
<a name="ln355">  bool has_been_fully_compacted() const {</a>
<a name="ln356">    std::lock_guard&lt;MutexType&gt; lock(data_mutex_);</a>
<a name="ln357">    return kv_store_.has_been_fully_compacted;</a>
<a name="ln358">  }</a>
<a name="ln359"> </a>
<a name="ln360">  void set_has_been_fully_compacted(const bool&amp; value) {</a>
<a name="ln361">    std::lock_guard&lt;MutexType&gt; lock(data_mutex_);</a>
<a name="ln362">    kv_store_.has_been_fully_compacted = value;</a>
<a name="ln363">  }</a>
<a name="ln364"> </a>
<a name="ln365">  // Returns the data root dir for this Raft group, for example:</a>
<a name="ln366">  // /mnt/d0/yb-data/tserver/data</a>
<a name="ln367">  // TODO(#79): rework when we have more than one KV-store (and data roots) per Raft group.</a>
<a name="ln368">  std::string data_root_dir() const;</a>
<a name="ln369"> </a>
<a name="ln370">  // Returns the WAL root dir for this Raft group, for example:</a>
<a name="ln371">  // /mnt/d0/yb-data/tserver/wals</a>
<a name="ln372">  std::string wal_root_dir() const;</a>
<a name="ln373"> </a>
<a name="ln374">  // Set table_id for altering the schema of a colocated user table.</a>
<a name="ln375">  void SetSchema(const Schema&amp; schema,</a>
<a name="ln376">                 const IndexMap&amp; index_map,</a>
<a name="ln377">                 const std::vector&lt;DeletedColumn&gt;&amp; deleted_cols,</a>
<a name="ln378">                 const uint32_t version,</a>
<a name="ln379">                 const TableId&amp; table_id = &quot;&quot;);</a>
<a name="ln380"> </a>
<a name="ln381">  void SetPartitionSchema(const PartitionSchema&amp; partition_schema);</a>
<a name="ln382"> </a>
<a name="ln383">  void SetTableName(</a>
<a name="ln384">      const std::string&amp; namespace_name, const std::string&amp; table_name,</a>
<a name="ln385">      const TableId&amp; table_id = &quot;&quot;);</a>
<a name="ln386"> </a>
<a name="ln387">  void AddTable(const std::string&amp; table_id,</a>
<a name="ln388">                const std::string&amp; namespace_name,</a>
<a name="ln389">                const std::string&amp; table_name,</a>
<a name="ln390">                const TableType table_type,</a>
<a name="ln391">                const Schema&amp; schema,</a>
<a name="ln392">                const IndexMap&amp; index_map,</a>
<a name="ln393">                const PartitionSchema&amp; partition_schema,</a>
<a name="ln394">                const boost::optional&lt;IndexInfo&gt;&amp; index_info,</a>
<a name="ln395">                const uint32_t schema_version);</a>
<a name="ln396"> </a>
<a name="ln397">  void RemoveTable(const TableId&amp; table_id);</a>
<a name="ln398"> </a>
<a name="ln399">  // Set / get the remote bootstrap / tablet data state.</a>
<a name="ln400">  void set_tablet_data_state(TabletDataState state);</a>
<a name="ln401">  TabletDataState tablet_data_state() const;</a>
<a name="ln402"> </a>
<a name="ln403">  CHECKED_STATUS Flush();</a>
<a name="ln404"> </a>
<a name="ln405">  // Mark the superblock to be in state 'delete_type', sync it to disk, and</a>
<a name="ln406">  // then delete all of the rowsets in this tablet.</a>
<a name="ln407">  // The metadata (superblock) is not deleted. For that, call DeleteSuperBlock().</a>
<a name="ln408">  //</a>
<a name="ln409">  // 'delete_type' must be one of TABLET_DATA_DELETED or TABLET_DATA_TOMBSTONED.</a>
<a name="ln410">  // 'last_logged_opid' should be set to the last opid in the log, if any is known.</a>
<a name="ln411">  // If 'last_logged_opid' is not set, then the current value of</a>
<a name="ln412">  // last_logged_opid is not modified. This is important for roll-forward of</a>
<a name="ln413">  // partially-tombstoned tablets during crash recovery.</a>
<a name="ln414">  //</a>
<a name="ln415">  // Returns only once all data has been removed.</a>
<a name="ln416">  // The OUT parameter 'was_deleted' can be used by caller to determine if the tablet data was</a>
<a name="ln417">  // actually deleted from disk or not. For example, in some cases, the tablet may have been</a>
<a name="ln418">  // already deleted (and are here on a retry) and this operation essentially ends up being a no-op;</a>
<a name="ln419">  // in such a case, 'was_deleted' will be set to FALSE.</a>
<a name="ln420">  CHECKED_STATUS DeleteTabletData(TabletDataState delete_type, const yb::OpId&amp; last_logged_opid);</a>
<a name="ln421"> </a>
<a name="ln422">  // Return true if this metadata references no regular data DB nor intents DB and is</a>
<a name="ln423">  // already marked as tombstoned. If this is the case, then calling DeleteTabletData</a>
<a name="ln424">  // would be a no-op.</a>
<a name="ln425">  bool IsTombstonedWithNoRocksDBData() const;</a>
<a name="ln426"> </a>
<a name="ln427">  // Permanently deletes the superblock from the disk.</a>
<a name="ln428">  // DeleteTabletData() must first be called and the tablet data state must be</a>
<a name="ln429">  // TABLET_DATA_DELETED.</a>
<a name="ln430">  // Returns Status::InvalidArgument if the list of orphaned blocks is not empty.</a>
<a name="ln431">  // Returns Status::IllegalState if the tablet data state is not TABLET_DATA_DELETED.</a>
<a name="ln432">  CHECKED_STATUS DeleteSuperBlock();</a>
<a name="ln433"> </a>
<a name="ln434">  FsManager *fs_manager() const { return fs_manager_; }</a>
<a name="ln435"> </a>
<a name="ln436">  yb::OpId tombstone_last_logged_opid() const { return tombstone_last_logged_opid_; }</a>
<a name="ln437"> </a>
<a name="ln438">  // Loads the currently-flushed superblock from disk into the given protobuf.</a>
<a name="ln439">  CHECKED_STATUS ReadSuperBlockFromDisk(RaftGroupReplicaSuperBlockPB* superblock) const;</a>
<a name="ln440"> </a>
<a name="ln441">  // Sets *superblock to the serialized form of the current metadata.</a>
<a name="ln442">  void ToSuperBlock(RaftGroupReplicaSuperBlockPB* superblock) const;</a>
<a name="ln443"> </a>
<a name="ln444">  // Fully replace a superblock (used for bootstrap).</a>
<a name="ln445">  CHECKED_STATUS ReplaceSuperBlock(const RaftGroupReplicaSuperBlockPB &amp;pb);</a>
<a name="ln446"> </a>
<a name="ln447">  // Returns a new WAL dir path to be used for new Raft group `raft_group_id` which will be created</a>
<a name="ln448">  // as a result of this Raft group splitting.</a>
<a name="ln449">  // Uses the same root dir as for `this` Raft group.</a>
<a name="ln450">  std::string GetSubRaftGroupWalDir(const RaftGroupId&amp; raft_group_id) const;</a>
<a name="ln451"> </a>
<a name="ln452">  // Returns a new Data dir path to be used for new Raft group `raft_group_id` which will be created</a>
<a name="ln453">  // as a result of this Raft group splitting.</a>
<a name="ln454">  // Uses the same root dir as for `this` Raft group.</a>
<a name="ln455">  std::string GetSubRaftGroupDataDir(const RaftGroupId&amp; raft_group_id) const;</a>
<a name="ln456"> </a>
<a name="ln457">  // Creates a new Raft group metadata for the part of existing tablet contained in this Raft group.</a>
<a name="ln458">  // Assigns specified Raft group ID, partition and key bounds for a new tablet.</a>
<a name="ln459">  Result&lt;RaftGroupMetadataPtr&gt; CreateSubtabletMetadata(</a>
<a name="ln460">      const RaftGroupId&amp; raft_group_id, const Partition&amp; partition,</a>
<a name="ln461">      const std::string&amp; lower_bound_key, const std::string&amp; upper_bound_key) const;</a>
<a name="ln462"> </a>
<a name="ln463">  TableInfoPtr primary_table_info() const {</a>
<a name="ln464">    std::lock_guard&lt;MutexType&gt; lock(data_mutex_);</a>
<a name="ln465">    return primary_table_info_unlocked();</a>
<a name="ln466">  }</a>
<a name="ln467"> </a>
<a name="ln468">  bool colocated() const { return colocated_; }</a>
<a name="ln469"> </a>
<a name="ln470">  // Return standard &quot;T xxx P yyy&quot; log prefix.</a>
<a name="ln471">  std::string LogPrefix() const;</a>
<a name="ln472"> </a>
<a name="ln473"> private:</a>
<a name="ln474">  typedef simple_spinlock MutexType;</a>
<a name="ln475"> </a>
<a name="ln476">  friend class RefCountedThreadSafe&lt;RaftGroupMetadata&gt;;</a>
<a name="ln477">  friend class MetadataTest;</a>
<a name="ln478"> </a>
<a name="ln479">  // Compile time assert that no one deletes RaftGroupMetadata objects.</a>
<a name="ln480">  ~RaftGroupMetadata();</a>
<a name="ln481"> </a>
<a name="ln482">  // Constructor for creating a new Raft group.</a>
<a name="ln483">  //</a>
<a name="ln484">  // TODO: get rid of this many-arg constructor in favor of just passing in a</a>
<a name="ln485">  // SuperBlock, which already contains all of these fields.</a>
<a name="ln486">  RaftGroupMetadata(FsManager* fs_manager,</a>
<a name="ln487">                    TableId table_id,</a>
<a name="ln488">                    RaftGroupId raft_group_id,</a>
<a name="ln489">                    std::string namespace_name,</a>
<a name="ln490">                    std::string table_name,</a>
<a name="ln491">                    TableType table_type,</a>
<a name="ln492">                    const std::string rocksdb_dir,</a>
<a name="ln493">                    const std::string wal_dir,</a>
<a name="ln494">                    const Schema&amp; schema,</a>
<a name="ln495">                    const IndexMap&amp; index_map,</a>
<a name="ln496">                    PartitionSchema partition_schema,</a>
<a name="ln497">                    Partition partition,</a>
<a name="ln498">                    const boost::optional&lt;IndexInfo&gt;&amp; index_info,</a>
<a name="ln499">                    const uint32_t schema_version,</a>
<a name="ln500">                    const TabletDataState&amp; tablet_data_state,</a>
<a name="ln501">                    const bool colocated = false);</a>
<a name="ln502"> </a>
<a name="ln503">  // Constructor for loading an existing Raft group.</a>
<a name="ln504">  RaftGroupMetadata(FsManager* fs_manager, RaftGroupId raft_group_id);</a>
<a name="ln505"> </a>
<a name="ln506">  CHECKED_STATUS LoadFromDisk();</a>
<a name="ln507"> </a>
<a name="ln508">  // Update state of metadata to that of the given superblock PB.</a>
<a name="ln509">  CHECKED_STATUS LoadFromSuperBlock(const RaftGroupReplicaSuperBlockPB&amp; superblock);</a>
<a name="ln510"> </a>
<a name="ln511">  CHECKED_STATUS ReadSuperBlock(RaftGroupReplicaSuperBlockPB *pb);</a>
<a name="ln512"> </a>
<a name="ln513">  // Fully replace superblock.</a>
<a name="ln514">  // Requires 'flush_lock_'.</a>
<a name="ln515">  CHECKED_STATUS ReplaceSuperBlockUnlocked(const RaftGroupReplicaSuperBlockPB &amp;pb);</a>
<a name="ln516"> </a>
<a name="ln517">  // Requires 'data_mutex_'.</a>
<a name="ln518">  void ToSuperBlockUnlocked(RaftGroupReplicaSuperBlockPB* superblock) const;</a>
<a name="ln519"> </a>
<a name="ln520">  const TableInfoPtr primary_table_info_unlocked() const {</a>
<a name="ln521">    const auto&amp; tables = kv_store_.tables;</a>
<a name="ln522">    const auto itr = tables.find(primary_table_id_);</a>
<a name="ln523">    CHECK(itr != tables.end());</a>
<a name="ln524">    return itr-&gt;second;</a>
<a name="ln525">  }</a>
<a name="ln526"> </a>
<a name="ln527">  enum State {</a>
<a name="ln528">    kNotLoadedYet,</a>
<a name="ln529">    kNotWrittenYet,</a>
<a name="ln530">    kInitialized</a>
<a name="ln531">  };</a>
<a name="ln532">  State state_;</a>
<a name="ln533"> </a>
<a name="ln534">  // Lock protecting the underlying data.</a>
<a name="ln535">  // TODO: consider switching to RW mutex.</a>
<a name="ln536">  mutable MutexType data_mutex_;</a>
<a name="ln537"> </a>
<a name="ln538">  // Lock protecting flushing the data to disk.</a>
<a name="ln539">  // If taken together with 'data_mutex_', must be acquired first.</a>
<a name="ln540">  mutable Mutex flush_lock_;</a>
<a name="ln541"> </a>
<a name="ln542">  RaftGroupId raft_group_id_;</a>
<a name="ln543">  std::shared_ptr&lt;Partition&gt; partition_;</a>
<a name="ln544"> </a>
<a name="ln545">  // The primary table id. Primary table is the first table this Raft group is created for.</a>
<a name="ln546">  // Additional tables can be added to this Raft group to co-locate with this table.</a>
<a name="ln547">  TableId primary_table_id_;</a>
<a name="ln548"> </a>
<a name="ln549">  // KV-store for this Raft group.</a>
<a name="ln550">  KvStoreInfo kv_store_;</a>
<a name="ln551"> </a>
<a name="ln552">  FsManager* const fs_manager_;</a>
<a name="ln553"> </a>
<a name="ln554">  // The directory where the write-ahead log for this Raft group is stored.</a>
<a name="ln555">  std::string wal_dir_;</a>
<a name="ln556"> </a>
<a name="ln557">  // The current state of remote bootstrap for the tablet.</a>
<a name="ln558">  TabletDataState tablet_data_state_;</a>
<a name="ln559"> </a>
<a name="ln560">  // Record of the last opid logged by the tablet before it was last tombstoned. Has no meaning for</a>
<a name="ln561">  // non-tombstoned tablets.</a>
<a name="ln562">  yb::OpId tombstone_last_logged_opid_;</a>
<a name="ln563"> </a>
<a name="ln564">  // True if the raft group is for a colocated tablet.</a>
<a name="ln565">  bool colocated_;</a>
<a name="ln566"> </a>
<a name="ln567">  // The minimum index that has been replicated by the cdc service.</a>
<a name="ln568">  int64_t cdc_min_replicated_index_ = std::numeric_limits&lt;int64_t&gt;::max();</a>
<a name="ln569"> </a>
<a name="ln570">  DISALLOW_COPY_AND_ASSIGN(RaftGroupMetadata);</a>
<a name="ln571">};</a>
<a name="ln572"> </a>
<a name="ln573">CHECKED_STATUS MigrateSuperblock(RaftGroupReplicaSuperBlockPB* superblock);</a>
<a name="ln574"> </a>
<a name="ln575">// Checks whether tablet data storage is ready for function, i.e. its creation or bootstrap process</a>
<a name="ln576">// has been completed and tablet is not deleted and not in process of being deleted.</a>
<a name="ln577">inline bool CanServeTabletData(TabletDataState state) {</a>
<a name="ln578">  return state == TabletDataState::TABLET_DATA_READY ||</a>
<a name="ln579">         state == TabletDataState::TABLET_DATA_SPLIT_COMPLETED;</a>
<a name="ln580">}</a>
<a name="ln581"> </a>
<a name="ln582">} // namespace tablet</a>
<a name="ln583">} // namespace yb</a>
<a name="ln584"> </a>
<a name="ln585">#endif /* YB_TABLET_TABLET_METADATA_H */</a>

</code></pre>
<div class="balloon" rel="241"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="250"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="259"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="266"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="273"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="280"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="289"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="298"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="307"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="316"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="332"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="523"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
