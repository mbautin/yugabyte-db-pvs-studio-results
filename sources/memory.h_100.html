
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>memory.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Copyright 2010 Google Inc.  All Rights Reserved</a>
<a name="ln2">//</a>
<a name="ln3">// Licensed to the Apache Software Foundation (ASF) under one</a>
<a name="ln4">// or more contributor license agreements.  See the NOTICE file</a>
<a name="ln5">// distributed with this work for additional information</a>
<a name="ln6">// regarding copyright ownership.  The ASF licenses this file</a>
<a name="ln7">// to you under the Apache License, Version 2.0 (the</a>
<a name="ln8">// &quot;License&quot;); you may not use this file except in compliance</a>
<a name="ln9">// with the License.  You may obtain a copy of the License at</a>
<a name="ln10">//</a>
<a name="ln11">//   http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln12">//</a>
<a name="ln13">// Unless required by applicable law or agreed to in writing,</a>
<a name="ln14">// software distributed under the License is distributed on an</a>
<a name="ln15">// &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</a>
<a name="ln16">// KIND, either express or implied.  See the License for the</a>
<a name="ln17">// specific language governing permissions and limitations</a>
<a name="ln18">// under the License.</a>
<a name="ln19">//</a>
<a name="ln20">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln21">//</a>
<a name="ln22">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln23">//</a>
<a name="ln24">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln25">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln26">//</a>
<a name="ln27">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln28">//</a>
<a name="ln29">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln30">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln31">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln32">// under the License.</a>
<a name="ln33">//</a>
<a name="ln34">//</a>
<a name="ln35">// Classes for memory management, used by materializations</a>
<a name="ln36">// (arenas, segments, and STL collections parametrized via arena allocators)</a>
<a name="ln37">// so that memory usage can be controlled at the application level.</a>
<a name="ln38">//</a>
<a name="ln39">// Materializations can be parametrized by specifying an instance of a</a>
<a name="ln40">// BufferAllocator. The allocator implements</a>
<a name="ln41">// memory management policy (e.g. setting allocation limits). Allocators may</a>
<a name="ln42">// be shared between multiple materializations; e.g. you can designate a</a>
<a name="ln43">// single allocator per a single user request, thus setting bounds on memory</a>
<a name="ln44">// usage on a per-request basis.</a>
<a name="ln45"> </a>
<a name="ln46">#ifndef YB_UTIL_MEMORY_MEMORY_H_</a>
<a name="ln47">#define YB_UTIL_MEMORY_MEMORY_H_</a>
<a name="ln48"> </a>
<a name="ln49">#include &lt;stddef.h&gt;</a>
<a name="ln50"> </a>
<a name="ln51">#include &lt;algorithm&gt;</a>
<a name="ln52">#include &lt;limits&gt;</a>
<a name="ln53">#include &lt;memory&gt;</a>
<a name="ln54">#include &lt;vector&gt;</a>
<a name="ln55"> </a>
<a name="ln56">#include &lt;boost/mpl/if.hpp&gt;</a>
<a name="ln57">#include &lt;boost/type_traits/is_const.hpp&gt;</a>
<a name="ln58"> </a>
<a name="ln59">#include &lt;glog/logging.h&gt;</a>
<a name="ln60"> </a>
<a name="ln61">#include &quot;yb/gutil/gscoped_ptr.h&quot;</a>
<a name="ln62">#include &quot;yb/gutil/logging-inl.h&quot;</a>
<a name="ln63">#include &quot;yb/gutil/macros.h&quot;</a>
<a name="ln64">#include &quot;yb/gutil/strings/stringpiece.h&quot;</a>
<a name="ln65">#include &quot;yb/gutil/singleton.h&quot;</a>
<a name="ln66"> </a>
<a name="ln67">#include &quot;yb/util/boost_mutex_utils.h&quot;</a>
<a name="ln68">#include &quot;yb/util/mutex.h&quot;</a>
<a name="ln69">#include &quot;yb/util/size_literals.h&quot;</a>
<a name="ln70"> </a>
<a name="ln71">using std::copy;</a>
<a name="ln72">using std::max;</a>
<a name="ln73">using std::min;</a>
<a name="ln74">using std::numeric_limits;</a>
<a name="ln75">using std::reverse;</a>
<a name="ln76">using std::sort;</a>
<a name="ln77">using std::swap;</a>
<a name="ln78">using std::vector;</a>
<a name="ln79"> </a>
<a name="ln80">namespace yb {</a>
<a name="ln81"> </a>
<a name="ln82">class BufferAllocator;</a>
<a name="ln83">class MemTracker;</a>
<a name="ln84"> </a>
<a name="ln85">void OverwriteWithPattern(char* p, size_t len, GStringPiece pattern);</a>
<a name="ln86"> </a>
<a name="ln87">// Wrapper for a block of data allocated by a BufferAllocator. Owns the block.</a>
<a name="ln88">// (To release the block, destroy the buffer - it will then return it via the</a>
<a name="ln89">// same allocator that has been used to create it).</a>
<a name="ln90">class Buffer {</a>
<a name="ln91"> public:</a>
<a name="ln92">  Buffer() : data_(nullptr), size_(0), allocator_(nullptr) {}</a>
<a name="ln93"> </a>
<a name="ln94">  Buffer(void* data, size_t size, BufferAllocator* allocator)</a>
<a name="ln95">      : data_(CHECK_NOTNULL(data)),</a>
<a name="ln96">        size_(size),</a>
<a name="ln97">        allocator_(allocator) {</a>
<a name="ln98">#ifndef NDEBUG</a>
<a name="ln99">    OverwriteWithPattern(reinterpret_cast&lt;char*&gt;(data_), size_,</a>
<a name="ln100">                         &quot;NEWNEWNEWNEWNEWNEWNEWNEWNEWNEWNEWNEW&quot;</a>
<a name="ln101">                         &quot;NEWNEWNEWNEWNEWNEWNEWNEWNEWNEWNEWNEW&quot;</a>
<a name="ln102">                         &quot;NEWNEWNEWNEWNEWNEWNEWNEWNEWNEWNEWNEW&quot;);</a>
<a name="ln103">#endif</a>
<a name="ln104">  }</a>
<a name="ln105"> </a>
<a name="ln106">  Buffer(Buffer&amp;&amp; rhs)</a>
<a name="ln107">    : data_(rhs.data_), size_(rhs.size_), allocator_(rhs.allocator_) {</a>
<a name="ln108">    rhs.Release();</a>
<a name="ln109">  }</a>
<a name="ln110"> </a>
<a name="ln111">  Buffer(const Buffer&amp; rhs) = delete;</a>
<a name="ln112">  void operator=(const Buffer&amp; rhs) = delete;</a>
<a name="ln113"> </a>
<a name="ln114">  ~Buffer();</a>
<a name="ln115"> </a>
<a name="ln116">  void* data() const { return data_; }   // The data buffer.</a>
<a name="ln117">  uint8_t* udata() const { return static_cast&lt;uint8_t*&gt;(data_); }</a>
<a name="ln118">  uint8_t* end() const { return udata() + size_; }</a>
<a name="ln119">  size_t size() const { return size_; }  // In bytes.</a>
<a name="ln120"> </a>
<a name="ln121">  void Release() {</a>
<a name="ln122">    data_ = nullptr;</a>
<a name="ln123">    allocator_ = nullptr;</a>
<a name="ln124">  }</a>
<a name="ln125"> </a>
<a name="ln126">  explicit operator bool() const {</a>
<a name="ln127">    return data_ != nullptr;</a>
<a name="ln128">  }</a>
<a name="ln129"> </a>
<a name="ln130">  bool operator!() const {</a>
<a name="ln131">    return data_ == nullptr;</a>
<a name="ln132">  }</a>
<a name="ln133"> private:</a>
<a name="ln134">  friend class BufferAllocator;</a>
<a name="ln135"> </a>
<a name="ln136">  // Called by a successful realloc.</a>
<a name="ln137">  void Update(void* new_data, size_t new_size) {</a>
<a name="ln138">#ifndef NDEBUG</a>
<a name="ln139">    if (new_size &gt; size_) {</a>
<a name="ln140">      OverwriteWithPattern(reinterpret_cast&lt;char*&gt;(new_data) + size_,</a>
<a name="ln141">                           new_size - size_, &quot;NEW&quot;);</a>
<a name="ln142">    }</a>
<a name="ln143">#endif</a>
<a name="ln144">    data_ = new_data;</a>
<a name="ln145">    size_ = new_size;</a>
<a name="ln146">  }</a>
<a name="ln147"> </a>
<a name="ln148">  void* data_;</a>
<a name="ln149">  size_t size_;</a>
<a name="ln150">  BufferAllocator* allocator_;</a>
<a name="ln151">};</a>
<a name="ln152"> </a>
<a name="ln153">// Allocators allow applications to control memory usage. They are</a>
<a name="ln154">// used by materializations to allocate blocks of memory arenas.</a>
<a name="ln155">// BufferAllocator is an abstract class that defines a common contract of</a>
<a name="ln156">// all implementations of allocators. Specific allocators provide specific</a>
<a name="ln157">// features, e.g. enforced resource limits, thread safety, etc.</a>
<a name="ln158">class BufferAllocator {</a>
<a name="ln159"> public:</a>
<a name="ln160">  virtual ~BufferAllocator() {}</a>
<a name="ln161"> </a>
<a name="ln162">  // Called by the user when a new block of memory is needed. The 'requested'</a>
<a name="ln163">  // parameter specifies how much memory (in bytes) the user would like to get.</a>
<a name="ln164">  // The 'minimal' parameter specifies how much he is willing to settle for.</a>
<a name="ln165">  // The allocator returns a buffer sized in the range [minimal, requested],</a>
<a name="ln166">  // or NULL if the request can't be satisfied. When the buffer is destroyed,</a>
<a name="ln167">  // its destructor calls the FreeInternal() method on its allocator.</a>
<a name="ln168">  // CAVEAT: The allocator must outlive all buffers returned by it.</a>
<a name="ln169">  //</a>
<a name="ln170">  // Corner cases:</a>
<a name="ln171">  // 1. If requested == 0, the allocator will always return a valid Buffer</a>
<a name="ln172">  //    with a non-NULL data pointer and zero capacity.</a>
<a name="ln173">  // 2. If minimal == 0, the allocator will always return a valid Buffer</a>
<a name="ln174">  //    with a non-NULL data pointer, possibly with zero capacity.</a>
<a name="ln175">  Buffer BestEffortAllocate(size_t requested, size_t minimal) {</a>
<a name="ln176">    DCHECK_LE(minimal, requested);</a>
<a name="ln177">    Buffer result = AllocateInternal(requested, minimal, this);</a>
<a name="ln178">    LogAllocation(requested, minimal, result);</a>
<a name="ln179">    return result;</a>
<a name="ln180">  }</a>
<a name="ln181"> </a>
<a name="ln182">  // Called by the user when a new block of memory is needed. Equivalent to</a>
<a name="ln183">  // BestEffortAllocate(requested, requested).</a>
<a name="ln184">  Buffer Allocate(size_t requested) {</a>
<a name="ln185">    return BestEffortAllocate(requested, requested);</a>
<a name="ln186">  }</a>
<a name="ln187"> </a>
<a name="ln188">  // Returns the amount of memory (in bytes) still available for this allocator.</a>
<a name="ln189">  // For unbounded allocators (like raw HeapBufferAllocator) this is the highest</a>
<a name="ln190">  // size_t value possible.</a>
<a name="ln191">  // TODO(user): consider making pure virtual.</a>
<a name="ln192">  virtual size_t Available() const { return numeric_limits&lt;size_t&gt;::max(); }</a>
<a name="ln193"> </a>
<a name="ln194"> protected:</a>
<a name="ln195">  friend class Buffer;</a>
<a name="ln196"> </a>
<a name="ln197">  BufferAllocator() {}</a>
<a name="ln198"> </a>
<a name="ln199">  // Expose the constructor to subclasses of BufferAllocator.</a>
<a name="ln200">  Buffer CreateBuffer(void* data, size_t size, BufferAllocator* allocator) {</a>
<a name="ln201">    return Buffer(data, size, allocator);</a>
<a name="ln202">  }</a>
<a name="ln203"> </a>
<a name="ln204">  // Expose Buffer::Update to subclasses of BufferAllocator.</a>
<a name="ln205">  void UpdateBuffer(void* new_data, size_t new_size, Buffer* buffer) {</a>
<a name="ln206">    buffer-&gt;Update(new_data, new_size);</a>
<a name="ln207">  }</a>
<a name="ln208"> </a>
<a name="ln209">  // Called by chained buffer allocators.</a>
<a name="ln210">  Buffer DelegateAllocate(BufferAllocator* delegate,</a>
<a name="ln211">                          size_t requested,</a>
<a name="ln212">                          size_t minimal,</a>
<a name="ln213">                          BufferAllocator* originator) {</a>
<a name="ln214">    return delegate-&gt;AllocateInternal(requested, minimal, originator);</a>
<a name="ln215">  }</a>
<a name="ln216"> </a>
<a name="ln217">  // Called by chained buffer allocators.</a>
<a name="ln218">  bool DelegateReallocate(BufferAllocator* delegate,</a>
<a name="ln219">                          size_t requested,</a>
<a name="ln220">                          size_t minimal,</a>
<a name="ln221">                          Buffer* buffer,</a>
<a name="ln222">                          BufferAllocator* originator) {</a>
<a name="ln223">    return delegate-&gt;ReallocateInternal(requested, minimal, buffer, originator);</a>
<a name="ln224">  }</a>
<a name="ln225"> </a>
<a name="ln226">  // Called by chained buffer allocators.</a>
<a name="ln227">  void DelegateFree(BufferAllocator* delegate, Buffer* buffer) {</a>
<a name="ln228">    delegate-&gt;FreeInternal(buffer);</a>
<a name="ln229">  }</a>
<a name="ln230"> </a>
<a name="ln231"> private:</a>
<a name="ln232">  // Implemented by concrete subclasses.</a>
<a name="ln233">  virtual Buffer AllocateInternal(size_t requested,</a>
<a name="ln234">                                  size_t minimal,</a>
<a name="ln235">                                  BufferAllocator* originator) = 0;</a>
<a name="ln236"> </a>
<a name="ln237">  // Implemented by concrete subclasses. Returns false on failure.</a>
<a name="ln238">  virtual bool ReallocateInternal(size_t requested,</a>
<a name="ln239">                                  size_t minimal,</a>
<a name="ln240">                                  Buffer* buffer,</a>
<a name="ln241">                                  BufferAllocator* originator) = 0;</a>
<a name="ln242"> </a>
<a name="ln243">  // Implemented by concrete subclasses.</a>
<a name="ln244">  virtual void FreeInternal(Buffer* buffer) = 0;</a>
<a name="ln245"> </a>
<a name="ln246">  // Logs a warning message if the allocation failed or if it returned less than</a>
<a name="ln247">  // the required number of bytes.</a>
<a name="ln248">  void LogAllocation(size_t required, size_t minimal, const Buffer&amp; buffer);</a>
<a name="ln249"> </a>
<a name="ln250">  DISALLOW_COPY_AND_ASSIGN(BufferAllocator);</a>
<a name="ln251">};</a>
<a name="ln252"> </a>
<a name="ln253">// Allocates buffers on the heap, with no memory limits. Uses standard C</a>
<a name="ln254">// allocation functions (malloc, realloc, free).</a>
<a name="ln255">class HeapBufferAllocator : public BufferAllocator {</a>
<a name="ln256"> public:</a>
<a name="ln257">  virtual ~HeapBufferAllocator() {}</a>
<a name="ln258"> </a>
<a name="ln259">  // Returns a singleton instance of the heap allocator.</a>
<a name="ln260">  static HeapBufferAllocator* Get() {</a>
<a name="ln261">    return Singleton&lt;HeapBufferAllocator&gt;::get();</a>
<a name="ln262">  }</a>
<a name="ln263"> </a>
<a name="ln264">  virtual size_t Available() const override {</a>
<a name="ln265">    return numeric_limits&lt;size_t&gt;::max();</a>
<a name="ln266">  }</a>
<a name="ln267"> </a>
<a name="ln268"> private:</a>
<a name="ln269">  // Allocates memory that is aligned to 16 way.</a>
<a name="ln270">  // Use if you want to boost SIMD operations on the memory area.</a>
<a name="ln271">  const bool aligned_mode_;</a>
<a name="ln272"> </a>
<a name="ln273">  friend class Singleton&lt;HeapBufferAllocator&gt;;</a>
<a name="ln274"> </a>
<a name="ln275">  // Always allocates 'requested'-sized buffer, or returns NULL on OOM.</a>
<a name="ln276">  virtual Buffer AllocateInternal(size_t requested,</a>
<a name="ln277">                                  size_t minimal,</a>
<a name="ln278">                                  BufferAllocator* originator) override;</a>
<a name="ln279"> </a>
<a name="ln280">  virtual bool ReallocateInternal(size_t requested,</a>
<a name="ln281">                                  size_t minimal,</a>
<a name="ln282">                                  Buffer* buffer,</a>
<a name="ln283">                                  BufferAllocator* originator) override;</a>
<a name="ln284"> </a>
<a name="ln285">  void* Malloc(size_t size);</a>
<a name="ln286">  void* Realloc(void* previousData, size_t previousSize, size_t newSize);</a>
<a name="ln287"> </a>
<a name="ln288">  virtual void FreeInternal(Buffer* buffer) override;</a>
<a name="ln289"> </a>
<a name="ln290">  HeapBufferAllocator();</a>
<a name="ln291">  explicit HeapBufferAllocator(bool aligned_mode)</a>
<a name="ln292">      : aligned_mode_(aligned_mode) {}</a>
<a name="ln293"> </a>
<a name="ln294">  DISALLOW_COPY_AND_ASSIGN(HeapBufferAllocator);</a>
<a name="ln295">};</a>
<a name="ln296"> </a>
<a name="ln297">// Wrapper around the delegate allocator, that clears all newly allocated</a>
<a name="ln298">// (and reallocated) memory.</a>
<a name="ln299">class ClearingBufferAllocator : public BufferAllocator {</a>
<a name="ln300"> public:</a>
<a name="ln301">  // Does not take ownership of the delegate.</a>
<a name="ln302">  explicit ClearingBufferAllocator(BufferAllocator* delegate)</a>
<a name="ln303">      : delegate_(delegate) {}</a>
<a name="ln304"> </a>
<a name="ln305">  virtual size_t Available() const override {</a>
<a name="ln306">    return delegate_-&gt;Available();</a>
<a name="ln307">  }</a>
<a name="ln308"> </a>
<a name="ln309"> private:</a>
<a name="ln310">  virtual Buffer AllocateInternal(size_t requested,</a>
<a name="ln311">                                  size_t minimal,</a>
<a name="ln312">                                  BufferAllocator* originator) override;</a>
<a name="ln313"> </a>
<a name="ln314">  virtual bool ReallocateInternal(size_t requested,</a>
<a name="ln315">                                  size_t minimal,</a>
<a name="ln316">                                  Buffer* buffer,</a>
<a name="ln317">                                  BufferAllocator* originator) override;</a>
<a name="ln318"> </a>
<a name="ln319">  virtual void FreeInternal(Buffer* buffer) override;</a>
<a name="ln320"> </a>
<a name="ln321">  BufferAllocator* delegate_;</a>
<a name="ln322">  DISALLOW_COPY_AND_ASSIGN(ClearingBufferAllocator);</a>
<a name="ln323">};</a>
<a name="ln324"> </a>
<a name="ln325">// Abstract policy for modifying allocation requests - e.g. enforcing quotas.</a>
<a name="ln326">class Mediator {</a>
<a name="ln327"> public:</a>
<a name="ln328">  Mediator() {}</a>
<a name="ln329">  virtual ~Mediator() {}</a>
<a name="ln330"> </a>
<a name="ln331">  // Called by an allocator when a allocation request is processed.</a>
<a name="ln332">  // Must return a value in the range [minimal, requested], or zero. Returning</a>
<a name="ln333">  // zero (if minimal is non-zero) indicates denial to allocate. Returning</a>
<a name="ln334">  // non-zero indicates that the request should be capped at that value.</a>
<a name="ln335">  virtual size_t Allocate(size_t requested, size_t minimal) = 0;</a>
<a name="ln336"> </a>
<a name="ln337">  // Called by an allocator when the specified amount (in bytes) is released.</a>
<a name="ln338">  virtual void Free(size_t amount) = 0;</a>
<a name="ln339"> </a>
<a name="ln340">  // TODO(user): consider making pure virtual.</a>
<a name="ln341">  virtual size_t Available() const { return numeric_limits&lt;size_t&gt;::max(); }</a>
<a name="ln342">};</a>
<a name="ln343"> </a>
<a name="ln344">// Optionally thread-safe skeletal implementation of a 'quota' abstraction,</a>
<a name="ln345">// providing methods to allocate resources against the quota, and return them.</a>
<a name="ln346">template&lt;bool thread_safe&gt;</a>
<a name="ln347">class Quota : public Mediator {</a>
<a name="ln348"> public:</a>
<a name="ln349">  explicit Quota(bool enforced) : usage_(0), enforced_(enforced) {}</a>
<a name="ln350">  virtual ~Quota() {}</a>
<a name="ln351"> </a>
<a name="ln352">  // Returns a value in range [minimal, requested] if not exceeding remaining</a>
<a name="ln353">  // quota or if the quota is not enforced (soft quota), and adjusts the usage</a>
<a name="ln354">  // value accordingly.  Otherwise, returns zero. The semantics of 'remaining</a>
<a name="ln355">  // quota' are defined by subclasses (that must supply GetQuotaInternal()</a>
<a name="ln356">  // method).</a>
<a name="ln357">  virtual size_t Allocate(size_t requested, size_t minimal) override;</a>
<a name="ln358"> </a>
<a name="ln359">  virtual void Free(size_t amount) override;</a>
<a name="ln360"> </a>
<a name="ln361">  // Returns memory still available in the quota. For unenforced Quota objects,</a>
<a name="ln362">  // you are still able to perform _minimal_ allocations when the available</a>
<a name="ln363">  // quota is 0 (or less than &quot;minimal&quot; param).</a>
<a name="ln364">  virtual size_t Available() const override {</a>
<a name="ln365">    lock_guard_maybe&lt;Mutex&gt; lock(Quota&lt;thread_safe&gt;::mutex());</a>
<a name="ln366">    const size_t quota = GetQuotaInternal();</a>
<a name="ln367">    return (usage_ &gt;= quota) ? 0 : (quota - usage_);</a>
<a name="ln368">  }</a>
<a name="ln369"> </a>
<a name="ln370">  // Returns the current quota value.</a>
<a name="ln371">  size_t GetQuota() const;</a>
<a name="ln372"> </a>
<a name="ln373">  // Returns the current usage value, defined as a sum of all the values</a>
<a name="ln374">  // granted by calls to Allocate, less these released via calls to Free.</a>
<a name="ln375">  size_t GetUsage() const;</a>
<a name="ln376"> </a>
<a name="ln377">  bool enforced() const {</a>
<a name="ln378">    return enforced_;</a>
<a name="ln379">  }</a>
<a name="ln380"> </a>
<a name="ln381"> protected:</a>
<a name="ln382">  // Overridden by specific implementations, to define semantics of</a>
<a name="ln383">  // the quota, i.e. the total amount of resources that the mediator will</a>
<a name="ln384">  // allocate. Called directly from GetQuota that optionally provides</a>
<a name="ln385">  // thread safety. An 'Allocate' request will succeed if</a>
<a name="ln386">  // GetUsage() + minimal &lt;= GetQuota() or if the quota is not enforced (soft</a>
<a name="ln387">  // quota).</a>
<a name="ln388">  virtual size_t GetQuotaInternal() const = 0;</a>
<a name="ln389"> </a>
<a name="ln390">  Mutex* mutex() const { return thread_safe ? &amp;mutex_ : NULL; }</a>
<a name="ln391"> </a>
<a name="ln392"> private:</a>
<a name="ln393">  mutable Mutex mutex_;</a>
<a name="ln394">  size_t usage_;</a>
<a name="ln395">  bool enforced_;</a>
<a name="ln396">  DISALLOW_COPY_AND_ASSIGN(Quota);</a>
<a name="ln397">};</a>
<a name="ln398"> </a>
<a name="ln399">// Optionally thread-safe static quota implementation (where quota is explicitly</a>
<a name="ln400">// set to a concrete numeric value).</a>
<a name="ln401">template&lt;bool thread_safe&gt;</a>
<a name="ln402">class StaticQuota : public Quota&lt;thread_safe&gt; {</a>
<a name="ln403"> public:</a>
<a name="ln404">  explicit StaticQuota(size_t quota)</a>
<a name="ln405">      : Quota&lt;thread_safe&gt;(true) {</a>
<a name="ln406">    SetQuota(quota);</a>
<a name="ln407">  }</a>
<a name="ln408">  StaticQuota(size_t quota, bool enforced)</a>
<a name="ln409">      : Quota&lt;thread_safe&gt;(enforced) {</a>
<a name="ln410">    SetQuota(quota);</a>
<a name="ln411">  }</a>
<a name="ln412">  virtual ~StaticQuota() {}</a>
<a name="ln413"> </a>
<a name="ln414">  // Sets quota to the new value.</a>
<a name="ln415">  void SetQuota(const size_t quota);</a>
<a name="ln416"> </a>
<a name="ln417"> protected:</a>
<a name="ln418">  virtual size_t GetQuotaInternal() const { return quota_; }</a>
<a name="ln419"> </a>
<a name="ln420"> private:</a>
<a name="ln421">  size_t quota_;</a>
<a name="ln422">  DISALLOW_COPY_AND_ASSIGN(StaticQuota);</a>
<a name="ln423">};</a>
<a name="ln424"> </a>
<a name="ln425">// Places resource limits on another allocator, using the specified Mediator</a>
<a name="ln426">// (e.g. quota) implementation.</a>
<a name="ln427">//</a>
<a name="ln428">// If the mediator and the delegate allocator are thread-safe, this allocator</a>
<a name="ln429">// is also thread-safe, to the extent that it will not introduce any</a>
<a name="ln430">// state inconsistencies. However, without additional synchronization,</a>
<a name="ln431">// allocation requests are not atomic end-to-end. This way, it is deadlock-</a>
<a name="ln432">// resilient (even if you have cyclic relationships between allocators) and</a>
<a name="ln433">// allows better concurrency. But, it may cause over-conservative</a>
<a name="ln434">// allocations under memory contention, if you have multiple levels of</a>
<a name="ln435">// mediating allocators. For example, if two requests that can't both be</a>
<a name="ln436">// satisfied are submitted concurrently, it may happen that one of them succeeds</a>
<a name="ln437">// but gets smaller buffer allocated than it would if the requests were strictly</a>
<a name="ln438">// ordered. This is usually not a problem, however, as you don't really want to</a>
<a name="ln439">// operate so close to memory limits that some of your allocations can't be</a>
<a name="ln440">// satisfied. If you do have a simple, cascading graph of allocators though,</a>
<a name="ln441">// and want to force requests be atomic end-to-end, put a</a>
<a name="ln442">// ThreadSafeBufferAllocator at the entry point.</a>
<a name="ln443">class MediatingBufferAllocator : public BufferAllocator {</a>
<a name="ln444"> public:</a>
<a name="ln445">  // Does not take ownership of the delegate, nor the mediator, allowing</a>
<a name="ln446">  // both to be reused.</a>
<a name="ln447">  MediatingBufferAllocator(BufferAllocator* const delegate,</a>
<a name="ln448">                           Mediator* const mediator)</a>
<a name="ln449">      : delegate_(delegate),</a>
<a name="ln450">        mediator_(mediator) {}</a>
<a name="ln451"> </a>
<a name="ln452">  virtual ~MediatingBufferAllocator() {}</a>
<a name="ln453"> </a>
<a name="ln454">  virtual size_t Available() const override {</a>
<a name="ln455">    return min(delegate_-&gt;Available(), mediator_-&gt;Available());</a>
<a name="ln456">  }</a>
<a name="ln457"> </a>
<a name="ln458"> private:</a>
<a name="ln459">  virtual Buffer AllocateInternal(size_t requested,</a>
<a name="ln460">                                  size_t minimal,</a>
<a name="ln461">                                  BufferAllocator* originator) override;</a>
<a name="ln462"> </a>
<a name="ln463">  virtual bool ReallocateInternal(size_t requested,</a>
<a name="ln464">                                  size_t minimal,</a>
<a name="ln465">                                  Buffer* buffer,</a>
<a name="ln466">                                  BufferAllocator* originator) override;</a>
<a name="ln467"> </a>
<a name="ln468">  virtual void FreeInternal(Buffer* buffer) override;</a>
<a name="ln469"> </a>
<a name="ln470">  BufferAllocator* delegate_;</a>
<a name="ln471">  Mediator* const mediator_;</a>
<a name="ln472">};</a>
<a name="ln473"> </a>
<a name="ln474">// Convenience non-thread-safe static memory bounds enforcer.</a>
<a name="ln475">// Combines MediatingBufferAllocator with a StaticQuota.</a>
<a name="ln476">class MemoryLimit : public BufferAllocator {</a>
<a name="ln477"> public:</a>
<a name="ln478">  // Creates a limiter based on the default, heap allocator. Quota is infinite.</a>
<a name="ln479">  // (Can be set using SetQuota).</a>
<a name="ln480">  MemoryLimit()</a>
<a name="ln481">      : quota_(std::numeric_limits&lt;size_t&gt;::max()),</a>
<a name="ln482">        allocator_(HeapBufferAllocator::Get(), &amp;quota_) {}</a>
<a name="ln483"> </a>
<a name="ln484">  // Creates a limiter based on the default, heap allocator.</a>
<a name="ln485">  explicit MemoryLimit(size_t quota)</a>
<a name="ln486">      : quota_(quota),</a>
<a name="ln487">        allocator_(HeapBufferAllocator::Get(), &amp;quota_) {}</a>
<a name="ln488"> </a>
<a name="ln489">  // Creates a limiter relaying to the specified delegate allocator.</a>
<a name="ln490">  MemoryLimit(size_t quota, BufferAllocator* const delegate)</a>
<a name="ln491">      : quota_(quota),</a>
<a name="ln492">        allocator_(delegate, &amp;quota_) {}</a>
<a name="ln493"> </a>
<a name="ln494">  // Creates a (possibly non-enforcing) limiter relaying to the specified</a>
<a name="ln495">  // delegate allocator.</a>
<a name="ln496">  MemoryLimit(size_t quota, bool enforced, BufferAllocator* const delegate)</a>
<a name="ln497">      : quota_(quota, enforced),</a>
<a name="ln498">        allocator_(delegate, &amp;quota_) {}</a>
<a name="ln499"> </a>
<a name="ln500">  virtual ~MemoryLimit() {}</a>
<a name="ln501"> </a>
<a name="ln502">  virtual size_t Available() const override {</a>
<a name="ln503">    return allocator_.Available();</a>
<a name="ln504">  }</a>
<a name="ln505"> </a>
<a name="ln506">  size_t GetQuota() const { return quota_.GetQuota(); }</a>
<a name="ln507">  size_t GetUsage() const { return quota_.GetUsage(); }</a>
<a name="ln508">  void SetQuota(const size_t quota) { quota_.SetQuota(quota); }</a>
<a name="ln509"> </a>
<a name="ln510"> private:</a>
<a name="ln511">  virtual Buffer AllocateInternal(size_t requested,</a>
<a name="ln512">                                  size_t minimal,</a>
<a name="ln513">                                  BufferAllocator* originator) override {</a>
<a name="ln514">    return DelegateAllocate(&amp;allocator_, requested, minimal, originator);</a>
<a name="ln515">  }</a>
<a name="ln516">  virtual bool ReallocateInternal(size_t requested,</a>
<a name="ln517">                                  size_t minimal,</a>
<a name="ln518">                                  Buffer* buffer,</a>
<a name="ln519">                                  BufferAllocator* originator) override {</a>
<a name="ln520">    return DelegateReallocate(&amp;allocator_, requested, minimal, buffer,</a>
<a name="ln521">                              originator);</a>
<a name="ln522">  }</a>
<a name="ln523">  virtual void FreeInternal(Buffer* buffer) override {</a>
<a name="ln524">    DelegateFree(&amp;allocator_, buffer);</a>
<a name="ln525">  }</a>
<a name="ln526"> </a>
<a name="ln527">  StaticQuota&lt;false&gt; quota_;</a>
<a name="ln528">  MediatingBufferAllocator allocator_;</a>
<a name="ln529">};</a>
<a name="ln530"> </a>
<a name="ln531">// An allocator that allows to bypass the (potential) soft quota below for a</a>
<a name="ln532">// given amount of memory usage. The goal is to make the allocation methods and</a>
<a name="ln533">// Available() work as if the allocator below had at least bypassed_amount of</a>
<a name="ln534">// soft quota. Of course this class doesn't allow to exceed the hard quota.</a>
<a name="ln535">class SoftQuotaBypassingBufferAllocator : public BufferAllocator {</a>
<a name="ln536"> public:</a>
<a name="ln537">  SoftQuotaBypassingBufferAllocator(BufferAllocator* allocator,</a>
<a name="ln538">                                    size_t bypassed_amount)</a>
<a name="ln539">      : allocator_(std::numeric_limits&lt;size_t&gt;::max(), allocator),</a>
<a name="ln540">        bypassed_amount_(bypassed_amount) {}</a>
<a name="ln541"> </a>
<a name="ln542">  virtual size_t Available() const override {</a>
<a name="ln543">    const size_t usage = allocator_.GetUsage();</a>
<a name="ln544">    size_t available = allocator_.Available();</a>
<a name="ln545">    if (bypassed_amount_ &gt; usage) {</a>
<a name="ln546">      available = max(bypassed_amount_ - usage, available);</a>
<a name="ln547">    }</a>
<a name="ln548">    return available;</a>
<a name="ln549">  }</a>
<a name="ln550"> </a>
<a name="ln551"> private:</a>
<a name="ln552">  // Calculates how much to increase the minimal parameter to allocate more</a>
<a name="ln553">  // aggressively in the underlying allocator. This is to avoid getting only</a>
<a name="ln554">  // very small allocations when we exceed the soft quota below. The request</a>
<a name="ln555">  // with increased minimal size is more likely to fail because of exceeding</a>
<a name="ln556">  // hard quota, so we also fall back to the original minimal size.</a>
<a name="ln557">  size_t AdjustMinimal(size_t requested, size_t minimal) const {</a>
<a name="ln558">    return min(requested, max(minimal, Available()));</a>
<a name="ln559">  }</a>
<a name="ln560"> </a>
<a name="ln561">  virtual Buffer AllocateInternal(size_t requested,</a>
<a name="ln562">                                  size_t minimal,</a>
<a name="ln563">                                  BufferAllocator* originator) override {</a>
<a name="ln564">    // Try increasing the &quot;minimal&quot; parameter to allocate more aggresively</a>
<a name="ln565">    // within the bypassed amount of soft quota.</a>
<a name="ln566">    Buffer result = DelegateAllocate(&amp;allocator_,</a>
<a name="ln567">                                     requested,</a>
<a name="ln568">                                     AdjustMinimal(requested, minimal),</a>
<a name="ln569">                                     originator);</a>
<a name="ln570">    if (result) {</a>
<a name="ln571">      return result;</a>
<a name="ln572">    } else {</a>
<a name="ln573">      return DelegateAllocate(&amp;allocator_, requested, minimal, originator);</a>
<a name="ln574">    }</a>
<a name="ln575">  }</a>
<a name="ln576"> </a>
<a name="ln577">  virtual bool ReallocateInternal(size_t requested,</a>
<a name="ln578">                                  size_t minimal,</a>
<a name="ln579">                                  Buffer* buffer,</a>
<a name="ln580">                                  BufferAllocator* originator) override {</a>
<a name="ln581">    size_t adjusted_minimal = AdjustMinimal(requested, minimal);</a>
<a name="ln582">    if (DelegateReallocate(&amp;allocator_, requested, adjusted_minimal, buffer, originator)) {</a>
<a name="ln583">      return true;</a>
<a name="ln584">    } else {</a>
<a name="ln585">      return DelegateReallocate(&amp;allocator_, requested, minimal, buffer, originator);</a>
<a name="ln586">    }</a>
<a name="ln587">  }</a>
<a name="ln588"> </a>
<a name="ln589">  virtual void FreeInternal(Buffer* buffer) override {</a>
<a name="ln590">    DelegateFree(&amp;allocator_, buffer);</a>
<a name="ln591">  }</a>
<a name="ln592"> </a>
<a name="ln593">  // Using MemoryLimit with &quot;infinite&quot; limit to get GetUsage().</a>
<a name="ln594">  MemoryLimit allocator_;</a>
<a name="ln595">  size_t bypassed_amount_;</a>
<a name="ln596">};</a>
<a name="ln597"> </a>
<a name="ln598">// An interface for a MemoryStatisticsCollector - an object which collects</a>
<a name="ln599">// information about the memory usage of the allocator. The collector will</a>
<a name="ln600">// gather statistics about memory usage based on information received from the</a>
<a name="ln601">// allocator.</a>
<a name="ln602">class MemoryStatisticsCollectorInterface {</a>
<a name="ln603"> public:</a>
<a name="ln604">  MemoryStatisticsCollectorInterface() {}</a>
<a name="ln605"> </a>
<a name="ln606">  virtual ~MemoryStatisticsCollectorInterface() {}</a>
<a name="ln607"> </a>
<a name="ln608">  // Informs the collector that the allocator granted bytes memory. Note that in</a>
<a name="ln609">  // the case of reallocation bytes should be the increase in total memory</a>
<a name="ln610">  // usage, not the total size of the buffer after reallocation.</a>
<a name="ln611">  virtual void AllocatedMemoryBytes(size_t bytes) = 0;</a>
<a name="ln612"> </a>
<a name="ln613">  // Informs the collector that the allocator received a request for at least</a>
<a name="ln614">  // bytes memory, and rejected it (meaning that it granted nothing).</a>
<a name="ln615">  virtual void RefusedMemoryBytes(size_t bytes) = 0;</a>
<a name="ln616"> </a>
<a name="ln617">  // Informs the collector that bytes memory have been released to the</a>
<a name="ln618">  // allocator.</a>
<a name="ln619">  virtual void FreedMemoryBytes(size_t bytes) = 0;</a>
<a name="ln620"> </a>
<a name="ln621"> private:</a>
<a name="ln622">  DISALLOW_COPY_AND_ASSIGN(MemoryStatisticsCollectorInterface);</a>
<a name="ln623">};</a>
<a name="ln624"> </a>
<a name="ln625">class MemoryStatisticsCollectingBufferAllocator : public BufferAllocator {</a>
<a name="ln626"> public:</a>
<a name="ln627">  // Does not take ownership of the delegate.</a>
<a name="ln628">  // Takes ownership of memory_stats_collector.</a>
<a name="ln629">  MemoryStatisticsCollectingBufferAllocator(</a>
<a name="ln630">      BufferAllocator* const delegate,</a>
<a name="ln631">      MemoryStatisticsCollectorInterface* const memory_stats_collector)</a>
<a name="ln632">      : delegate_(delegate),</a>
<a name="ln633">        memory_stats_collector_(memory_stats_collector) {}</a>
<a name="ln634"> </a>
<a name="ln635">  virtual ~MemoryStatisticsCollectingBufferAllocator() {}</a>
<a name="ln636"> </a>
<a name="ln637">  virtual size_t Available() const override {</a>
<a name="ln638">    return delegate_-&gt;Available();</a>
<a name="ln639">  }</a>
<a name="ln640"> </a>
<a name="ln641"> private:</a>
<a name="ln642">  virtual Buffer AllocateInternal(size_t requested,</a>
<a name="ln643">                                  size_t minimal,</a>
<a name="ln644">                                  BufferAllocator* originator) override;</a>
<a name="ln645"> </a>
<a name="ln646">  virtual bool ReallocateInternal(size_t requested,</a>
<a name="ln647">                                  size_t minimal,</a>
<a name="ln648">                                  Buffer* buffer,</a>
<a name="ln649">                                  BufferAllocator* originator) override;</a>
<a name="ln650"> </a>
<a name="ln651">  virtual void FreeInternal(Buffer* buffer) override;</a>
<a name="ln652"> </a>
<a name="ln653">  BufferAllocator* delegate_;</a>
<a name="ln654">  gscoped_ptr&lt;MemoryStatisticsCollectorInterface&gt;</a>
<a name="ln655">      memory_stats_collector_;</a>
<a name="ln656">};</a>
<a name="ln657"> </a>
<a name="ln658">// BufferAllocator which uses MemTracker to keep track of and optionally</a>
<a name="ln659">// (if a limit is set on the MemTracker) regulate memory consumption.</a>
<a name="ln660">class MemoryTrackingBufferAllocator : public BufferAllocator {</a>
<a name="ln661"> public:</a>
<a name="ln662">  // Does not take ownership of the delegate. The delegate must remain</a>
<a name="ln663">  // valid for the lifetime of this allocator. Increments reference</a>
<a name="ln664">  // count for 'mem_tracker'.</a>
<a name="ln665">  // If 'mem_tracker' has a limit and 'enforce_limit' is true, then</a>
<a name="ln666">  // the classes calling this buffer allocator (whether directly, or</a>
<a name="ln667">  // through an Arena) must be able to handle the case when allocation</a>
<a name="ln668">  // fails. If 'enforce_limit' is false (this is the default), then</a>
<a name="ln669">  // allocation will always succeed.</a>
<a name="ln670">  MemoryTrackingBufferAllocator(BufferAllocator* const delegate,</a>
<a name="ln671">                                std::shared_ptr&lt;MemTracker&gt; mem_tracker,</a>
<a name="ln672">                                bool enforce_limit = false)</a>
<a name="ln673">      : delegate_(delegate),</a>
<a name="ln674">        mem_tracker_(std::move(mem_tracker)),</a>
<a name="ln675">        enforce_limit_(enforce_limit) {}</a>
<a name="ln676"> </a>
<a name="ln677">  virtual ~MemoryTrackingBufferAllocator() {}</a>
<a name="ln678"> </a>
<a name="ln679">  // If enforce limit is false, this always returns maximum possible value</a>
<a name="ln680">  // for int64_t (std::numeric_limits&lt;int64_t&gt;::max()). Otherwise, this</a>
<a name="ln681">  // is equivalent to calling mem_tracker_-&gt;SpareCapacity();</a>
<a name="ln682">  virtual size_t Available() const override;</a>
<a name="ln683"> </a>
<a name="ln684"> private:</a>
<a name="ln685"> </a>
<a name="ln686">  // If enforce_limit_ is true, this is equivalent to calling</a>
<a name="ln687">  // mem_tracker_-&gt;TryConsume(bytes). If enforce_limit_ is false and</a>
<a name="ln688">  // mem_tracker_-&gt;TryConsume(bytes) is false, we call</a>
<a name="ln689">  // mem_tracker_-&gt;Consume(bytes) and always return true.</a>
<a name="ln690">  bool TryConsume(int64_t bytes);</a>
<a name="ln691"> </a>
<a name="ln692">  virtual Buffer AllocateInternal(size_t requested,</a>
<a name="ln693">                                  size_t minimal,</a>
<a name="ln694">                                  BufferAllocator* originator) override;</a>
<a name="ln695"> </a>
<a name="ln696">  virtual bool ReallocateInternal(size_t requested,</a>
<a name="ln697">                                  size_t minimal,</a>
<a name="ln698">                                  Buffer* buffer,</a>
<a name="ln699">                                  BufferAllocator* originator) override;</a>
<a name="ln700"> </a>
<a name="ln701">  virtual void FreeInternal(Buffer* buffer) override;</a>
<a name="ln702"> </a>
<a name="ln703">  BufferAllocator* delegate_;</a>
<a name="ln704">  std::shared_ptr&lt;MemTracker&gt; mem_tracker_;</a>
<a name="ln705">  bool enforce_limit_;</a>
<a name="ln706">};</a>
<a name="ln707"> </a>
<a name="ln708">// Synchronizes access to AllocateInternal and FreeInternal, and exposes the</a>
<a name="ln709">// mutex for use by subclasses. Allocation requests performed through this</a>
<a name="ln710">// allocator are atomic end-to-end. Template parameter DelegateAllocatorType</a>
<a name="ln711">// allows to specify a subclass of BufferAllocator for the delegate, to allow</a>
<a name="ln712">// subclasses of ThreadSafeBufferAllocator to access additional methods provided</a>
<a name="ln713">// by the allocator subclass. If this is not needed, it can be set to</a>
<a name="ln714">// BufferAllocator.</a>
<a name="ln715">template &lt;class DelegateAllocatorType&gt;</a>
<a name="ln716">class ThreadSafeBufferAllocator : public BufferAllocator {</a>
<a name="ln717"> public:</a>
<a name="ln718">  // Does not take ownership of the delegate.</a>
<a name="ln719">  explicit ThreadSafeBufferAllocator(DelegateAllocatorType* delegate)</a>
<a name="ln720">      : delegate_(delegate) {}</a>
<a name="ln721">  virtual ~ThreadSafeBufferAllocator() {}</a>
<a name="ln722"> </a>
<a name="ln723">  virtual size_t Available() const override {</a>
<a name="ln724">    lock_guard_maybe&lt;Mutex&gt; lock(mutex());</a>
<a name="ln725">    return delegate()-&gt;Available();</a>
<a name="ln726">  }</a>
<a name="ln727"> </a>
<a name="ln728"> protected:</a>
<a name="ln729">  Mutex* mutex() const { return &amp;mutex_; }</a>
<a name="ln730">  // Expose the delegate allocator, with the precise type of the allocator</a>
<a name="ln731">  // specified by the template parameter. The delegate() methods themselves</a>
<a name="ln732">  // don't give any thread-safety guarantees. Protect all uses taking the Mutex</a>
<a name="ln733">  // exposed by the mutex() method.</a>
<a name="ln734">  DelegateAllocatorType* delegate() { return delegate_; }</a>
<a name="ln735">  const DelegateAllocatorType* delegate() const { return delegate_; }</a>
<a name="ln736"> </a>
<a name="ln737"> private:</a>
<a name="ln738">  virtual Buffer AllocateInternal(size_t requested,</a>
<a name="ln739">                                  size_t minimal,</a>
<a name="ln740">                                  BufferAllocator* originator) override {</a>
<a name="ln741">    lock_guard_maybe&lt;Mutex&gt; lock(mutex());</a>
<a name="ln742">    return DelegateAllocate(delegate(), requested, minimal, originator);</a>
<a name="ln743">  }</a>
<a name="ln744"> </a>
<a name="ln745">  virtual bool ReallocateInternal(size_t requested,</a>
<a name="ln746">                                  size_t minimal,</a>
<a name="ln747">                                  Buffer* buffer,</a>
<a name="ln748">                                  BufferAllocator* originator) override {</a>
<a name="ln749">    lock_guard_maybe&lt;Mutex&gt; lock(mutex());</a>
<a name="ln750">    return DelegateReallocate(delegate(), requested, minimal, buffer,</a>
<a name="ln751">                              originator);</a>
<a name="ln752">  }</a>
<a name="ln753"> </a>
<a name="ln754">  virtual void FreeInternal(Buffer* buffer) override {</a>
<a name="ln755">    lock_guard_maybe&lt;Mutex&gt; lock(mutex());</a>
<a name="ln756">    DelegateFree(delegate(), buffer);</a>
<a name="ln757">  }</a>
<a name="ln758"> </a>
<a name="ln759">  DelegateAllocatorType* delegate_;</a>
<a name="ln760">  mutable Mutex mutex_;</a>
<a name="ln761">  DISALLOW_COPY_AND_ASSIGN(ThreadSafeBufferAllocator);</a>
<a name="ln762">};</a>
<a name="ln763"> </a>
<a name="ln764">// A version of ThreadSafeBufferAllocator that owns the supplied delegate</a>
<a name="ln765">// allocator.</a>
<a name="ln766">template &lt;class DelegateAllocatorType&gt;</a>
<a name="ln767">class OwningThreadSafeBufferAllocator</a>
<a name="ln768">    : public ThreadSafeBufferAllocator&lt;DelegateAllocatorType&gt; {</a>
<a name="ln769"> public:</a>
<a name="ln770">  explicit OwningThreadSafeBufferAllocator(DelegateAllocatorType* delegate)</a>
<a name="ln771">      : ThreadSafeBufferAllocator&lt;DelegateAllocatorType&gt;(delegate),</a>
<a name="ln772">        delegate_owned_(delegate) {}</a>
<a name="ln773">  virtual ~OwningThreadSafeBufferAllocator() {}</a>
<a name="ln774"> </a>
<a name="ln775"> private:</a>
<a name="ln776">  gscoped_ptr&lt;DelegateAllocatorType&gt; delegate_owned_;</a>
<a name="ln777">};</a>
<a name="ln778"> </a>
<a name="ln779">class ThreadSafeMemoryLimit</a>
<a name="ln780">    : public OwningThreadSafeBufferAllocator&lt;MemoryLimit&gt; {</a>
<a name="ln781"> public:</a>
<a name="ln782">  ThreadSafeMemoryLimit(size_t quota, bool enforced,</a>
<a name="ln783">                        BufferAllocator* const delegate)</a>
<a name="ln784">      : OwningThreadSafeBufferAllocator&lt;MemoryLimit&gt;(</a>
<a name="ln785">            new MemoryLimit(quota, enforced, delegate)) {}</a>
<a name="ln786">  virtual ~ThreadSafeMemoryLimit() {}</a>
<a name="ln787"> </a>
<a name="ln788">  size_t GetQuota() const {</a>
<a name="ln789">    lock_guard_maybe&lt;Mutex&gt; lock(mutex());</a>
<a name="ln790">    return delegate()-&gt;GetQuota();</a>
<a name="ln791">  }</a>
<a name="ln792">  size_t GetUsage() const {</a>
<a name="ln793">    lock_guard_maybe&lt;Mutex&gt; lock(mutex());</a>
<a name="ln794">    return delegate()-&gt;GetUsage();</a>
<a name="ln795">  }</a>
<a name="ln796">  void SetQuota(const size_t quota) {</a>
<a name="ln797">    lock_guard_maybe&lt;Mutex&gt; lock(mutex());</a>
<a name="ln798">    delegate()-&gt;SetQuota(quota);</a>
<a name="ln799">  }</a>
<a name="ln800">};</a>
<a name="ln801"> </a>
<a name="ln802">// A BufferAllocator that can be given ownership of many objects of given type.</a>
<a name="ln803">// These objects will then be deleted when the buffer allocator is destroyed.</a>
<a name="ln804">// The objects added last are deleted first (LIFO).</a>
<a name="ln805">template &lt;typename OwnedType&gt;</a>
<a name="ln806">class OwningBufferAllocator : public BufferAllocator {</a>
<a name="ln807"> public:</a>
<a name="ln808">  // Doesn't take ownership of delegate.</a>
<a name="ln809">  explicit OwningBufferAllocator(BufferAllocator* const delegate)</a>
<a name="ln810">      : delegate_(delegate) {}</a>
<a name="ln811"> </a>
<a name="ln812">  virtual ~OwningBufferAllocator() {</a>
<a name="ln813">    // Delete elements starting from the end.</a>
<a name="ln814">    while (!owned_.empty()) {</a>
<a name="ln815">      OwnedType* p = owned_.back();</a>
<a name="ln816">      owned_.pop_back();</a>
<a name="ln817">      delete p;</a>
<a name="ln818">    }</a>
<a name="ln819">  }</a>
<a name="ln820"> </a>
<a name="ln821">  // Add to the collection of objects owned by this allocator. The object added</a>
<a name="ln822">  // last is deleted first.</a>
<a name="ln823">  OwningBufferAllocator* Add(OwnedType* p) {</a>
<a name="ln824">    owned_.push_back(p);</a>
<a name="ln825">    return this;</a>
<a name="ln826">  }</a>
<a name="ln827"> </a>
<a name="ln828">  virtual size_t Available() const override {</a>
<a name="ln829">    return delegate_-&gt;Available();</a>
<a name="ln830">  }</a>
<a name="ln831"> </a>
<a name="ln832"> private:</a>
<a name="ln833">  virtual Buffer AllocateInternal(size_t requested,</a>
<a name="ln834">                                  size_t minimal,</a>
<a name="ln835">                                  BufferAllocator* originator) override {</a>
<a name="ln836">    return DelegateAllocate(delegate_, requested, minimal, originator);</a>
<a name="ln837">  }</a>
<a name="ln838"> </a>
<a name="ln839">  virtual bool ReallocateInternal(size_t requested,</a>
<a name="ln840">                                  size_t minimal,</a>
<a name="ln841">                                  Buffer* buffer,</a>
<a name="ln842">                                  BufferAllocator* originator) override {</a>
<a name="ln843">    return DelegateReallocate(delegate_, requested, minimal, buffer,</a>
<a name="ln844">                              originator);</a>
<a name="ln845">  }</a>
<a name="ln846"> </a>
<a name="ln847">  virtual void FreeInternal(Buffer* buffer) override {</a>
<a name="ln848">    DelegateFree(delegate_, buffer);</a>
<a name="ln849">  }</a>
<a name="ln850"> </a>
<a name="ln851">  // Not using PointerVector here because we want to guarantee certain order of</a>
<a name="ln852">  // deleting elements (starting from the ones added last).</a>
<a name="ln853">  vector&lt;OwnedType*&gt; owned_;</a>
<a name="ln854">  BufferAllocator* delegate_;</a>
<a name="ln855">};</a>
<a name="ln856"> </a>
<a name="ln857">// Buffer allocator that tries to guarantee the exact and consistent amount</a>
<a name="ln858">// of memory. Uses hard MemoryLimit to enforce the upper bound but also</a>
<a name="ln859">// guarantees consistent allocations by ignoring minimal requested amounts and</a>
<a name="ln860">// always returning the full amount of memory requested if available.</a>
<a name="ln861">// Allocations will fail if the memory requested would exceed the quota or if</a>
<a name="ln862">// the underlying allocator fails to provide the memory.</a>
<a name="ln863">class GuaranteeMemory : public BufferAllocator {</a>
<a name="ln864"> public:</a>
<a name="ln865">  // Doesn't take ownership of 'delegate'.</a>
<a name="ln866">  GuaranteeMemory(size_t memory_quota,</a>
<a name="ln867">                  BufferAllocator* delegate)</a>
<a name="ln868">      : limit_(memory_quota, true, delegate),</a>
<a name="ln869">        memory_guarantee_(memory_quota) {}</a>
<a name="ln870"> </a>
<a name="ln871">  virtual size_t Available() const override {</a>
<a name="ln872">    return memory_guarantee_ - limit_.GetUsage();</a>
<a name="ln873">  }</a>
<a name="ln874"> </a>
<a name="ln875"> private:</a>
<a name="ln876">  virtual Buffer AllocateInternal(size_t requested,</a>
<a name="ln877">                                  size_t minimal,</a>
<a name="ln878">                                  BufferAllocator* originator) override {</a>
<a name="ln879">    if (requested &gt; Available()) {</a>
<a name="ln880">      return Buffer();</a>
<a name="ln881">    } else {</a>
<a name="ln882">      return DelegateAllocate(&amp;limit_, requested, requested, originator);</a>
<a name="ln883">    }</a>
<a name="ln884">  }</a>
<a name="ln885"> </a>
<a name="ln886">  virtual bool ReallocateInternal(size_t requested,</a>
<a name="ln887">                                  size_t minimal,</a>
<a name="ln888">                                  Buffer* buffer,</a>
<a name="ln889">                                  BufferAllocator* originator) override {</a>
<a name="ln890">    int64 additional_memory = requested - (buffer != NULL ? buffer-&gt;size() : 0);</a>
<a name="ln891">    return additional_memory &lt;= static_cast&lt;int64&gt;(Available())</a>
<a name="ln892">        &amp;&amp; DelegateReallocate(&amp;limit_, requested, requested,</a>
<a name="ln893">                              buffer, originator);</a>
<a name="ln894">  }</a>
<a name="ln895"> </a>
<a name="ln896">  virtual void FreeInternal(Buffer* buffer) override {</a>
<a name="ln897">    DelegateFree(&amp;limit_, buffer);</a>
<a name="ln898">  }</a>
<a name="ln899"> </a>
<a name="ln900">  MemoryLimit limit_;</a>
<a name="ln901">  size_t memory_guarantee_;</a>
<a name="ln902">  DISALLOW_COPY_AND_ASSIGN(GuaranteeMemory);</a>
<a name="ln903">};</a>
<a name="ln904"> </a>
<a name="ln905">// Implementation of inline and template methods</a>
<a name="ln906"> </a>
<a name="ln907">template&lt;bool thread_safe&gt;</a>
<a name="ln908">size_t Quota&lt;thread_safe&gt;::Allocate(const size_t requested,</a>
<a name="ln909">                                    const size_t minimal) {</a>
<a name="ln910">  lock_guard_maybe&lt;Mutex&gt; lock(mutex());</a>
<a name="ln911">  DCHECK_LE(minimal, requested)</a>
<a name="ln912">      &lt;&lt; &quot;\&quot;minimal\&quot; shouldn't be bigger than \&quot;requested\&quot;&quot;;</a>
<a name="ln913">  const size_t quota = GetQuotaInternal();</a>
<a name="ln914">  size_t allocation;</a>
<a name="ln915">  if (usage_ &gt; quota || minimal &gt; quota - usage_) {</a>
<a name="ln916">    // OOQ (Out of quota).</a>
<a name="ln917">    if (!enforced() &amp;&amp; minimal &lt;= numeric_limits&lt;size_t&gt;::max() - usage_) {</a>
<a name="ln918">      // The quota is unenforced and the value of &quot;minimal&quot; won't cause an</a>
<a name="ln919">      // overflow. Perform a minimal allocation.</a>
<a name="ln920">      allocation = minimal;</a>
<a name="ln921">    } else {</a>
<a name="ln922">      allocation = 0;</a>
<a name="ln923">    }</a>
<a name="ln924">    LOG(WARNING) &lt;&lt; &quot;Out of quota. Requested: &quot; &lt;&lt; requested</a>
<a name="ln925">                 &lt;&lt; &quot; bytes, or at least minimal: &quot; &lt;&lt; minimal</a>
<a name="ln926">                 &lt;&lt; &quot;. Current quota value is: &quot; &lt;&lt; quota</a>
<a name="ln927">                 &lt;&lt; &quot; while current usage is: &quot; &lt;&lt; usage_</a>
<a name="ln928">                 &lt;&lt; &quot;. The quota is &quot; &lt;&lt; (enforced() ? &quot;&quot; : &quot;not &quot;)</a>
<a name="ln929">                 &lt;&lt; &quot;enforced. &quot;</a>
<a name="ln930">                 &lt;&lt; ((allocation == 0) ? &quot;Did not allocate any memory.&quot;</a>
<a name="ln931">                 : &quot;Allocated the minimal value requested.&quot;);</a>
<a name="ln932">  } else {</a>
<a name="ln933">    allocation = min(requested, quota - usage_);</a>
<a name="ln934">  }</a>
<a name="ln935">  usage_ += allocation;</a>
<a name="ln936">  return allocation;</a>
<a name="ln937">}</a>
<a name="ln938"> </a>
<a name="ln939">template&lt;bool thread_safe&gt;</a>
<a name="ln940">void Quota&lt;thread_safe&gt;::Free(size_t amount) {</a>
<a name="ln941">  lock_guard_maybe&lt;Mutex&gt; lock(mutex());</a>
<a name="ln942">  usage_ -= amount;</a>
<a name="ln943">  // threads allocate/free memory concurrently via the same Quota object that is</a>
<a name="ln944">  // not protected with a mutex (thread_safe == false).</a>
<a name="ln945">  if (usage_ &gt; (numeric_limits&lt;size_t&gt;::max() - (1 &lt;&lt; 28))) {</a>
<a name="ln946">    LOG(ERROR) &lt;&lt; &quot;Suspiciously big usage_ value: &quot; &lt;&lt; usage_</a>
<a name="ln947">               &lt;&lt; &quot; (could be a result size_t wrapping around below 0, &quot;</a>
<a name="ln948">               &lt;&lt; &quot;for example as a result of race condition).&quot;;</a>
<a name="ln949">  }</a>
<a name="ln950">}</a>
<a name="ln951"> </a>
<a name="ln952">template&lt;bool thread_safe&gt;</a>
<a name="ln953">size_t Quota&lt;thread_safe&gt;::GetQuota() const {</a>
<a name="ln954">  lock_guard_maybe&lt;Mutex&gt; lock(mutex());</a>
<a name="ln955">  return GetQuotaInternal();</a>
<a name="ln956">}</a>
<a name="ln957"> </a>
<a name="ln958">template&lt;bool thread_safe&gt;</a>
<a name="ln959">size_t Quota&lt;thread_safe&gt;::GetUsage() const {</a>
<a name="ln960">  lock_guard_maybe&lt;Mutex&gt; lock(mutex());</a>
<a name="ln961">  return usage_;</a>
<a name="ln962">}</a>
<a name="ln963"> </a>
<a name="ln964">template&lt;bool thread_safe&gt;</a>
<a name="ln965">void StaticQuota&lt;thread_safe&gt;::SetQuota(const size_t quota) {</a>
<a name="ln966">  lock_guard_maybe&lt;Mutex&gt; lock(Quota&lt;thread_safe&gt;::mutex());</a>
<a name="ln967">  quota_ = quota;</a>
<a name="ln968">}</a>
<a name="ln969"> </a>
<a name="ln970">template &lt;class T&gt;</a>
<a name="ln971">using EndOfObjectResultType =</a>
<a name="ln972">  typename boost::mpl::if_&lt;boost::is_const&lt;T&gt;, const char*, char*&gt;::type;</a>
<a name="ln973"> </a>
<a name="ln974">template &lt;class T&gt;</a>
<a name="ln975">EndOfObjectResultType&lt;T&gt;</a>
<a name="ln976">EndOfObject(T* t) {</a>
<a name="ln977">  typedef EndOfObjectResultType&lt;T&gt; ResultType;</a>
<a name="ln978">  return reinterpret_cast&lt;ResultType&gt;(t) + sizeof(T);</a>
<a name="ln979">}</a>
<a name="ln980"> </a>
<a name="ln981">// There is a shared_from_this() standard function injected into class by extending</a>
<a name="ln982">// std::enable_shared_from_this template. We use this for ReactorTask and MonitoredTask base</a>
<a name="ln983">// classes. But for their subclasses we sometimes need to get shared pointer to specific class</a>
<a name="ln984">// type, for example for DelayedTask we need to get shared_ptr&lt;DelayedTask&gt;.</a>
<a name="ln985">// shared_from_this defined in the base ReactorTask class will return shared_ptr&lt;ReactorTask&gt;.</a>
<a name="ln986">// That is why we defined template free function shared_from which will downcast to shared_pointer</a>
<a name="ln987">// to type deduced from whatever we pass as an argument, shared_ptr&lt;DelayedTask&gt; in this case.</a>
<a name="ln988">template &lt;typename U&gt;</a>
<a name="ln989">std::shared_ptr&lt;U&gt; shared_from(U* u) {</a>
<a name="ln990">  return std::static_pointer_cast&lt;U&gt;(u-&gt;shared_from_this());</a>
<a name="ln991">}</a>
<a name="ln992"> </a>
<a name="ln993">// Returns empty string if TCMalloc is not enabled.</a>
<a name="ln994">std::string TcMallocStats();</a>
<a name="ln995"> </a>
<a name="ln996">}  // namespace yb</a>
<a name="ln997"> </a>
<a name="ln998">#endif // YB_UTIL_MEMORY_MEMORY_H_</a>

</code></pre>
<div class="balloon" rel="90"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v690/" target="_blank">V690</a> The 'Buffer' class implements a move constructor, but lacks the move assignment operator. It is dangerous to use such a class.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
