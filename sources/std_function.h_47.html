
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>std_function.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Implementation of std::function -*- C++ -*-</a>
<a name="ln2"> </a>
<a name="ln3">// Copyright (C) 2004-2018 Free Software Foundation, Inc.</a>
<a name="ln4">//</a>
<a name="ln5">// This file is part of the GNU ISO C++ Library.  This library is free</a>
<a name="ln6">// software; you can redistribute it and/or modify it under the</a>
<a name="ln7">// terms of the GNU General Public License as published by the</a>
<a name="ln8">// Free Software Foundation; either version 3, or (at your option)</a>
<a name="ln9">// any later version.</a>
<a name="ln10"> </a>
<a name="ln11">// This library is distributed in the hope that it will be useful,</a>
<a name="ln12">// but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">// GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">// Under Section 7 of GPL version 3, you are granted additional</a>
<a name="ln17">// permissions described in the GCC Runtime Library Exception, version</a>
<a name="ln18">// 3.1, as published by the Free Software Foundation.</a>
<a name="ln19"> </a>
<a name="ln20">// You should have received a copy of the GNU General Public License and</a>
<a name="ln21">// a copy of the GCC Runtime Library Exception along with this program;</a>
<a name="ln22">// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see</a>
<a name="ln23">// &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln24"> </a>
<a name="ln25">/** @file include/bits/std_function.h</a>
<a name="ln26"> *  This is an internal header file, included by other library headers.</a>
<a name="ln27"> *  Do not attempt to use it directly. @headername{functional}</a>
<a name="ln28"> */</a>
<a name="ln29"> </a>
<a name="ln30">#ifndef _GLIBCXX_STD_FUNCTION_H</a>
<a name="ln31">#define _GLIBCXX_STD_FUNCTION_H 1</a>
<a name="ln32"> </a>
<a name="ln33">#pragma GCC system_header</a>
<a name="ln34"> </a>
<a name="ln35">#if __cplusplus &lt; 201103L</a>
<a name="ln36"># include &lt;bits/c++0x_warning.h&gt;</a>
<a name="ln37">#else</a>
<a name="ln38"> </a>
<a name="ln39">#if __cpp_rtti</a>
<a name="ln40"># include &lt;typeinfo&gt;</a>
<a name="ln41">#endif</a>
<a name="ln42">#include &lt;bits/stl_function.h&gt;</a>
<a name="ln43">#include &lt;bits/invoke.h&gt;</a>
<a name="ln44">#include &lt;bits/refwrap.h&gt;</a>
<a name="ln45">#include &lt;bits/functexcept.h&gt;</a>
<a name="ln46"> </a>
<a name="ln47">namespace std _GLIBCXX_VISIBILITY(default)</a>
<a name="ln48">{</a>
<a name="ln49">_GLIBCXX_BEGIN_NAMESPACE_VERSION</a>
<a name="ln50"> </a>
<a name="ln51">  /**</a>
<a name="ln52">   *  @brief Exception class thrown when class template function's</a>
<a name="ln53">   *  operator() is called with an empty target.</a>
<a name="ln54">   *  @ingroup exceptions</a>
<a name="ln55">   */</a>
<a name="ln56">  class bad_function_call : public std::exception</a>
<a name="ln57">  {</a>
<a name="ln58">  public:</a>
<a name="ln59">    virtual ~bad_function_call() noexcept;</a>
<a name="ln60"> </a>
<a name="ln61">    const char* what() const noexcept;</a>
<a name="ln62">  };</a>
<a name="ln63"> </a>
<a name="ln64">  /**</a>
<a name="ln65">   *  Trait identifying &quot;location-invariant&quot; types, meaning that the</a>
<a name="ln66">   *  address of the object (or any of its members) will not escape.</a>
<a name="ln67">   *  Trivially copyable types are location-invariant and users can</a>
<a name="ln68">   *  specialize this trait for other types.</a>
<a name="ln69">   */</a>
<a name="ln70">  template&lt;typename _Tp&gt;</a>
<a name="ln71">    struct __is_location_invariant</a>
<a name="ln72">    : is_trivially_copyable&lt;_Tp&gt;::type</a>
<a name="ln73">    { };</a>
<a name="ln74"> </a>
<a name="ln75">  class _Undefined_class;</a>
<a name="ln76"> </a>
<a name="ln77">  union _Nocopy_types</a>
<a name="ln78">  {</a>
<a name="ln79">    void*       _M_object;</a>
<a name="ln80">    const void* _M_const_object;</a>
<a name="ln81">    void (*_M_function_pointer)();</a>
<a name="ln82">    void (_Undefined_class::*_M_member_pointer)();</a>
<a name="ln83">  };</a>
<a name="ln84"> </a>
<a name="ln85">  union [[gnu::may_alias]] _Any_data</a>
<a name="ln86">  {</a>
<a name="ln87">    void*       _M_access()       { return &amp;_M_pod_data[0]; }</a>
<a name="ln88">    const void* _M_access() const { return &amp;_M_pod_data[0]; }</a>
<a name="ln89"> </a>
<a name="ln90">    template&lt;typename _Tp&gt;</a>
<a name="ln91">      _Tp&amp;</a>
<a name="ln92">      _M_access()</a>
<a name="ln93">      { return *static_cast&lt;_Tp*&gt;(_M_access()); }</a>
<a name="ln94"> </a>
<a name="ln95">    template&lt;typename _Tp&gt;</a>
<a name="ln96">      const _Tp&amp;</a>
<a name="ln97">      _M_access() const</a>
<a name="ln98">      { return *static_cast&lt;const _Tp*&gt;(_M_access()); }</a>
<a name="ln99"> </a>
<a name="ln100">    _Nocopy_types _M_unused;</a>
<a name="ln101">    char _M_pod_data[sizeof(_Nocopy_types)];</a>
<a name="ln102">  };</a>
<a name="ln103"> </a>
<a name="ln104">  enum _Manager_operation</a>
<a name="ln105">  {</a>
<a name="ln106">    __get_type_info,</a>
<a name="ln107">    __get_functor_ptr,</a>
<a name="ln108">    __clone_functor,</a>
<a name="ln109">    __destroy_functor</a>
<a name="ln110">  };</a>
<a name="ln111"> </a>
<a name="ln112">  // Simple type wrapper that helps avoid annoying const problems</a>
<a name="ln113">  // when casting between void pointers and pointers-to-pointers.</a>
<a name="ln114">  template&lt;typename _Tp&gt;</a>
<a name="ln115">    struct _Simple_type_wrapper</a>
<a name="ln116">    {</a>
<a name="ln117">      _Simple_type_wrapper(_Tp __value) : __value(__value) { }</a>
<a name="ln118"> </a>
<a name="ln119">      _Tp __value;</a>
<a name="ln120">    };</a>
<a name="ln121"> </a>
<a name="ln122">  template&lt;typename _Tp&gt;</a>
<a name="ln123">    struct __is_location_invariant&lt;_Simple_type_wrapper&lt;_Tp&gt; &gt;</a>
<a name="ln124">    : __is_location_invariant&lt;_Tp&gt;</a>
<a name="ln125">    { };</a>
<a name="ln126"> </a>
<a name="ln127">  template&lt;typename _Signature&gt;</a>
<a name="ln128">    class function;</a>
<a name="ln129"> </a>
<a name="ln130">  /// Base class of all polymorphic function object wrappers.</a>
<a name="ln131">  class _Function_base</a>
<a name="ln132">  {</a>
<a name="ln133">  public:</a>
<a name="ln134">    static const std::size_t _M_max_size = sizeof(_Nocopy_types);</a>
<a name="ln135">    static const std::size_t _M_max_align = __alignof__(_Nocopy_types);</a>
<a name="ln136"> </a>
<a name="ln137">    template&lt;typename _Functor&gt;</a>
<a name="ln138">      class _Base_manager</a>
<a name="ln139">      {</a>
<a name="ln140">      protected:</a>
<a name="ln141">	static const bool __stored_locally =</a>
<a name="ln142">	(__is_location_invariant&lt;_Functor&gt;::value</a>
<a name="ln143">	 &amp;&amp; sizeof(_Functor) &lt;= _M_max_size</a>
<a name="ln144">	 &amp;&amp; __alignof__(_Functor) &lt;= _M_max_align</a>
<a name="ln145">	 &amp;&amp; (_M_max_align % __alignof__(_Functor) == 0));</a>
<a name="ln146"> </a>
<a name="ln147">	typedef integral_constant&lt;bool, __stored_locally&gt; _Local_storage;</a>
<a name="ln148"> </a>
<a name="ln149">	// Retrieve a pointer to the function object</a>
<a name="ln150">	static _Functor*</a>
<a name="ln151">	_M_get_pointer(const _Any_data&amp; __source)</a>
<a name="ln152">	{</a>
<a name="ln153">	  const _Functor* __ptr =</a>
<a name="ln154">	    __stored_locally? std::__addressof(__source._M_access&lt;_Functor&gt;())</a>
<a name="ln155">	    /* have stored a pointer */ : __source._M_access&lt;_Functor*&gt;();</a>
<a name="ln156">	  return const_cast&lt;_Functor*&gt;(__ptr);</a>
<a name="ln157">	}</a>
<a name="ln158"> </a>
<a name="ln159">	// Clone a location-invariant function object that fits within</a>
<a name="ln160">	// an _Any_data structure.</a>
<a name="ln161">	static void</a>
<a name="ln162">	_M_clone(_Any_data&amp; __dest, const _Any_data&amp; __source, true_type)</a>
<a name="ln163">	{</a>
<a name="ln164">	  ::new (__dest._M_access()) _Functor(__source._M_access&lt;_Functor&gt;());</a>
<a name="ln165">	}</a>
<a name="ln166"> </a>
<a name="ln167">	// Clone a function object that is not location-invariant or</a>
<a name="ln168">	// that cannot fit into an _Any_data structure.</a>
<a name="ln169">	static void</a>
<a name="ln170">	_M_clone(_Any_data&amp; __dest, const _Any_data&amp; __source, false_type)</a>
<a name="ln171">	{</a>
<a name="ln172">	  __dest._M_access&lt;_Functor*&gt;() =</a>
<a name="ln173">	    new _Functor(*__source._M_access&lt;_Functor*&gt;());</a>
<a name="ln174">	}</a>
<a name="ln175"> </a>
<a name="ln176">	// Destroying a location-invariant object may still require</a>
<a name="ln177">	// destruction.</a>
<a name="ln178">	static void</a>
<a name="ln179">	_M_destroy(_Any_data&amp; __victim, true_type)</a>
<a name="ln180">	{</a>
<a name="ln181">	  __victim._M_access&lt;_Functor&gt;().~_Functor();</a>
<a name="ln182">	}</a>
<a name="ln183"> </a>
<a name="ln184">	// Destroying an object located on the heap.</a>
<a name="ln185">	static void</a>
<a name="ln186">	_M_destroy(_Any_data&amp; __victim, false_type)</a>
<a name="ln187">	{</a>
<a name="ln188">	  delete __victim._M_access&lt;_Functor*&gt;();</a>
<a name="ln189">	}</a>
<a name="ln190"> </a>
<a name="ln191">      public:</a>
<a name="ln192">	static bool</a>
<a name="ln193">	_M_manager(_Any_data&amp; __dest, const _Any_data&amp; __source,</a>
<a name="ln194">		   _Manager_operation __op)</a>
<a name="ln195">	{</a>
<a name="ln196">	  switch (__op)</a>
<a name="ln197">	    {</a>
<a name="ln198">#if __cpp_rtti</a>
<a name="ln199">	    case __get_type_info:</a>
<a name="ln200">	      __dest._M_access&lt;const type_info*&gt;() = &amp;typeid(_Functor);</a>
<a name="ln201">	      break;</a>
<a name="ln202">#endif</a>
<a name="ln203">	    case __get_functor_ptr:</a>
<a name="ln204">	      __dest._M_access&lt;_Functor*&gt;() = _M_get_pointer(__source);</a>
<a name="ln205">	      break;</a>
<a name="ln206"> </a>
<a name="ln207">	    case __clone_functor:</a>
<a name="ln208">	      _M_clone(__dest, __source, _Local_storage());</a>
<a name="ln209">	      break;</a>
<a name="ln210"> </a>
<a name="ln211">	    case __destroy_functor:</a>
<a name="ln212">	      _M_destroy(__dest, _Local_storage());</a>
<a name="ln213">	      break;</a>
<a name="ln214">	    }</a>
<a name="ln215">	  return false;</a>
<a name="ln216">	}</a>
<a name="ln217"> </a>
<a name="ln218">	static void</a>
<a name="ln219">	_M_init_functor(_Any_data&amp; __functor, _Functor&amp;&amp; __f)</a>
<a name="ln220">	{ _M_init_functor(__functor, std::move(__f), _Local_storage()); }</a>
<a name="ln221"> </a>
<a name="ln222">	template&lt;typename _Signature&gt;</a>
<a name="ln223">	  static bool</a>
<a name="ln224">	  _M_not_empty_function(const function&lt;_Signature&gt;&amp; __f)</a>
<a name="ln225">	  { return static_cast&lt;bool&gt;(__f); }</a>
<a name="ln226"> </a>
<a name="ln227">	template&lt;typename _Tp&gt;</a>
<a name="ln228">	  static bool</a>
<a name="ln229">	  _M_not_empty_function(_Tp* __fp)</a>
<a name="ln230">	  { return __fp != nullptr; }</a>
<a name="ln231"> </a>
<a name="ln232">	template&lt;typename _Class, typename _Tp&gt;</a>
<a name="ln233">	  static bool</a>
<a name="ln234">	  _M_not_empty_function(_Tp _Class::* __mp)</a>
<a name="ln235">	  { return __mp != nullptr; }</a>
<a name="ln236"> </a>
<a name="ln237">	template&lt;typename _Tp&gt;</a>
<a name="ln238">	  static bool</a>
<a name="ln239">	  _M_not_empty_function(const _Tp&amp;)</a>
<a name="ln240">	  { return true; }</a>
<a name="ln241"> </a>
<a name="ln242">      private:</a>
<a name="ln243">	static void</a>
<a name="ln244">	_M_init_functor(_Any_data&amp; __functor, _Functor&amp;&amp; __f, true_type)</a>
<a name="ln245">	{ ::new (__functor._M_access()) _Functor(std::move(__f)); }</a>
<a name="ln246"> </a>
<a name="ln247">	static void</a>
<a name="ln248">	_M_init_functor(_Any_data&amp; __functor, _Functor&amp;&amp; __f, false_type)</a>
<a name="ln249">	{ __functor._M_access&lt;_Functor*&gt;() = new _Functor(std::move(__f)); }</a>
<a name="ln250">      };</a>
<a name="ln251"> </a>
<a name="ln252">    _Function_base() : _M_manager(nullptr) { }</a>
<a name="ln253"> </a>
<a name="ln254">    ~_Function_base()</a>
<a name="ln255">    {</a>
<a name="ln256">      if (_M_manager)</a>
<a name="ln257">	_M_manager(_M_functor, _M_functor, __destroy_functor);</a>
<a name="ln258">    }</a>
<a name="ln259"> </a>
<a name="ln260">    bool _M_empty() const { return !_M_manager; }</a>
<a name="ln261"> </a>
<a name="ln262">    typedef bool (*_Manager_type)(_Any_data&amp;, const _Any_data&amp;,</a>
<a name="ln263">				  _Manager_operation);</a>
<a name="ln264"> </a>
<a name="ln265">    _Any_data     _M_functor;</a>
<a name="ln266">    _Manager_type _M_manager;</a>
<a name="ln267">  };</a>
<a name="ln268"> </a>
<a name="ln269">  template&lt;typename _Signature, typename _Functor&gt;</a>
<a name="ln270">    class _Function_handler;</a>
<a name="ln271"> </a>
<a name="ln272">  template&lt;typename _Res, typename _Functor, typename... _ArgTypes&gt;</a>
<a name="ln273">    class _Function_handler&lt;_Res(_ArgTypes...), _Functor&gt;</a>
<a name="ln274">    : public _Function_base::_Base_manager&lt;_Functor&gt;</a>
<a name="ln275">    {</a>
<a name="ln276">      typedef _Function_base::_Base_manager&lt;_Functor&gt; _Base;</a>
<a name="ln277"> </a>
<a name="ln278">    public:</a>
<a name="ln279">      static _Res</a>
<a name="ln280">      _M_invoke(const _Any_data&amp; __functor, _ArgTypes&amp;&amp;... __args)</a>
<a name="ln281">      {</a>
<a name="ln282">	return (*_Base::_M_get_pointer(__functor))(</a>
<a name="ln283">	    std::forward&lt;_ArgTypes&gt;(__args)...);</a>
<a name="ln284">      }</a>
<a name="ln285">    };</a>
<a name="ln286"> </a>
<a name="ln287">  template&lt;typename _Functor, typename... _ArgTypes&gt;</a>
<a name="ln288">    class _Function_handler&lt;void(_ArgTypes...), _Functor&gt;</a>
<a name="ln289">    : public _Function_base::_Base_manager&lt;_Functor&gt;</a>
<a name="ln290">    {</a>
<a name="ln291">      typedef _Function_base::_Base_manager&lt;_Functor&gt; _Base;</a>
<a name="ln292"> </a>
<a name="ln293">     public:</a>
<a name="ln294">      static void</a>
<a name="ln295">      _M_invoke(const _Any_data&amp; __functor, _ArgTypes&amp;&amp;... __args)</a>
<a name="ln296">      {</a>
<a name="ln297">	(*_Base::_M_get_pointer(__functor))(</a>
<a name="ln298">	    std::forward&lt;_ArgTypes&gt;(__args)...);</a>
<a name="ln299">      }</a>
<a name="ln300">    };</a>
<a name="ln301"> </a>
<a name="ln302">  template&lt;typename _Class, typename _Member, typename _Res,</a>
<a name="ln303">	   typename... _ArgTypes&gt;</a>
<a name="ln304">    class _Function_handler&lt;_Res(_ArgTypes...), _Member _Class::*&gt;</a>
<a name="ln305">    : public _Function_handler&lt;void(_ArgTypes...), _Member _Class::*&gt;</a>
<a name="ln306">    {</a>
<a name="ln307">      typedef _Function_handler&lt;void(_ArgTypes...), _Member _Class::*&gt;</a>
<a name="ln308">	_Base;</a>
<a name="ln309"> </a>
<a name="ln310">     public:</a>
<a name="ln311">      static _Res</a>
<a name="ln312">      _M_invoke(const _Any_data&amp; __functor, _ArgTypes&amp;&amp;... __args)</a>
<a name="ln313">      {</a>
<a name="ln314">	return std::__invoke(_Base::_M_get_pointer(__functor)-&gt;__value,</a>
<a name="ln315">			     std::forward&lt;_ArgTypes&gt;(__args)...);</a>
<a name="ln316">      }</a>
<a name="ln317">    };</a>
<a name="ln318"> </a>
<a name="ln319">  template&lt;typename _Class, typename _Member, typename... _ArgTypes&gt;</a>
<a name="ln320">    class _Function_handler&lt;void(_ArgTypes...), _Member _Class::*&gt;</a>
<a name="ln321">    : public _Function_base::_Base_manager&lt;</a>
<a name="ln322">		 _Simple_type_wrapper&lt; _Member _Class::* &gt; &gt;</a>
<a name="ln323">    {</a>
<a name="ln324">      typedef _Member _Class::* _Functor;</a>
<a name="ln325">      typedef _Simple_type_wrapper&lt;_Functor&gt; _Wrapper;</a>
<a name="ln326">      typedef _Function_base::_Base_manager&lt;_Wrapper&gt; _Base;</a>
<a name="ln327"> </a>
<a name="ln328">    public:</a>
<a name="ln329">      static bool</a>
<a name="ln330">      _M_manager(_Any_data&amp; __dest, const _Any_data&amp; __source,</a>
<a name="ln331">		 _Manager_operation __op)</a>
<a name="ln332">      {</a>
<a name="ln333">	switch (__op)</a>
<a name="ln334">	  {</a>
<a name="ln335">#if __cpp_rtti</a>
<a name="ln336">	  case __get_type_info:</a>
<a name="ln337">	    __dest._M_access&lt;const type_info*&gt;() = &amp;typeid(_Functor);</a>
<a name="ln338">	    break;</a>
<a name="ln339">#endif</a>
<a name="ln340">	  case __get_functor_ptr:</a>
<a name="ln341">	    __dest._M_access&lt;_Functor*&gt;() =</a>
<a name="ln342">	      &amp;_Base::_M_get_pointer(__source)-&gt;__value;</a>
<a name="ln343">	    break;</a>
<a name="ln344"> </a>
<a name="ln345">	  default:</a>
<a name="ln346">	    _Base::_M_manager(__dest, __source, __op);</a>
<a name="ln347">	  }</a>
<a name="ln348">	return false;</a>
<a name="ln349">      }</a>
<a name="ln350"> </a>
<a name="ln351">      static void</a>
<a name="ln352">      _M_invoke(const _Any_data&amp; __functor, _ArgTypes&amp;&amp;... __args)</a>
<a name="ln353">      {</a>
<a name="ln354">	std::__invoke(_Base::_M_get_pointer(__functor)-&gt;__value,</a>
<a name="ln355">		      std::forward&lt;_ArgTypes&gt;(__args)...);</a>
<a name="ln356">      }</a>
<a name="ln357">    };</a>
<a name="ln358"> </a>
<a name="ln359">  template&lt;typename _From, typename _To&gt;</a>
<a name="ln360">    using __check_func_return_type</a>
<a name="ln361">      = __or_&lt;is_void&lt;_To&gt;, is_same&lt;_From, _To&gt;, is_convertible&lt;_From, _To&gt;&gt;;</a>
<a name="ln362"> </a>
<a name="ln363">  /**</a>
<a name="ln364">   *  @brief Primary class template for std::function.</a>
<a name="ln365">   *  @ingroup functors</a>
<a name="ln366">   *</a>
<a name="ln367">   *  Polymorphic function wrapper.</a>
<a name="ln368">   */</a>
<a name="ln369">  template&lt;typename _Res, typename... _ArgTypes&gt;</a>
<a name="ln370">    class function&lt;_Res(_ArgTypes...)&gt;</a>
<a name="ln371">    : public _Maybe_unary_or_binary_function&lt;_Res, _ArgTypes...&gt;,</a>
<a name="ln372">      private _Function_base</a>
<a name="ln373">    {</a>
<a name="ln374">      template&lt;typename _Func,</a>
<a name="ln375">	       typename _Res2 = typename result_of&lt;_Func&amp;(_ArgTypes...)&gt;::type&gt;</a>
<a name="ln376">	struct _Callable : __check_func_return_type&lt;_Res2, _Res&gt; { };</a>
<a name="ln377"> </a>
<a name="ln378">      // Used so the return type convertibility checks aren't done when</a>
<a name="ln379">      // performing overload resolution for copy construction/assignment.</a>
<a name="ln380">      template&lt;typename _Tp&gt;</a>
<a name="ln381">	struct _Callable&lt;function, _Tp&gt; : false_type { };</a>
<a name="ln382"> </a>
<a name="ln383">      template&lt;typename _Cond, typename _Tp&gt;</a>
<a name="ln384">	using _Requires = typename enable_if&lt;_Cond::value, _Tp&gt;::type;</a>
<a name="ln385"> </a>
<a name="ln386">    public:</a>
<a name="ln387">      typedef _Res result_type;</a>
<a name="ln388"> </a>
<a name="ln389">      // [3.7.2.1] construct/copy/destroy</a>
<a name="ln390"> </a>
<a name="ln391">      /**</a>
<a name="ln392">       *  @brief Default construct creates an empty function call wrapper.</a>
<a name="ln393">       *  @post @c !(bool)*this</a>
<a name="ln394">       */</a>
<a name="ln395">      function() noexcept</a>
<a name="ln396">      : _Function_base() { }</a>
<a name="ln397"> </a>
<a name="ln398">      /**</a>
<a name="ln399">       *  @brief Creates an empty function call wrapper.</a>
<a name="ln400">       *  @post @c !(bool)*this</a>
<a name="ln401">       */</a>
<a name="ln402">      function(nullptr_t) noexcept</a>
<a name="ln403">      : _Function_base() { }</a>
<a name="ln404"> </a>
<a name="ln405">      /**</a>
<a name="ln406">       *  @brief %Function copy constructor.</a>
<a name="ln407">       *  @param __x A %function object with identical call signature.</a>
<a name="ln408">       *  @post @c bool(*this) == bool(__x)</a>
<a name="ln409">       *</a>
<a name="ln410">       *  The newly-created %function contains a copy of the target of @a</a>
<a name="ln411">       *  __x (if it has one).</a>
<a name="ln412">       */</a>
<a name="ln413">      function(const function&amp; __x);</a>
<a name="ln414"> </a>
<a name="ln415">      /**</a>
<a name="ln416">       *  @brief %Function move constructor.</a>
<a name="ln417">       *  @param __x A %function object rvalue with identical call signature.</a>
<a name="ln418">       *</a>
<a name="ln419">       *  The newly-created %function contains the target of @a __x</a>
<a name="ln420">       *  (if it has one).</a>
<a name="ln421">       */</a>
<a name="ln422">      function(function&amp;&amp; __x) noexcept : _Function_base()</a>
<a name="ln423">      {</a>
<a name="ln424">	__x.swap(*this);</a>
<a name="ln425">      }</a>
<a name="ln426"> </a>
<a name="ln427">      /**</a>
<a name="ln428">       *  @brief Builds a %function that targets a copy of the incoming</a>
<a name="ln429">       *  function object.</a>
<a name="ln430">       *  @param __f A %function object that is callable with parameters of</a>
<a name="ln431">       *  type @c T1, @c T2, ..., @c TN and returns a value convertible</a>
<a name="ln432">       *  to @c Res.</a>
<a name="ln433">       *</a>
<a name="ln434">       *  The newly-created %function object will target a copy of</a>
<a name="ln435">       *  @a __f. If @a __f is @c reference_wrapper&lt;F&gt;, then this function</a>
<a name="ln436">       *  object will contain a reference to the function object @c</a>
<a name="ln437">       *  __f.get(). If @a __f is a NULL function pointer or NULL</a>
<a name="ln438">       *  pointer-to-member, the newly-created object will be empty.</a>
<a name="ln439">       *</a>
<a name="ln440">       *  If @a __f is a non-NULL function pointer or an object of type @c</a>
<a name="ln441">       *  reference_wrapper&lt;F&gt;, this function will not throw.</a>
<a name="ln442">       */</a>
<a name="ln443">      template&lt;typename _Functor,</a>
<a name="ln444">	       typename = _Requires&lt;__not_&lt;is_same&lt;_Functor, function&gt;&gt;, void&gt;,</a>
<a name="ln445">	       typename = _Requires&lt;_Callable&lt;_Functor&gt;, void&gt;&gt;</a>
<a name="ln446">	function(_Functor);</a>
<a name="ln447"> </a>
<a name="ln448">      /**</a>
<a name="ln449">       *  @brief %Function assignment operator.</a>
<a name="ln450">       *  @param __x A %function with identical call signature.</a>
<a name="ln451">       *  @post @c (bool)*this == (bool)x</a>
<a name="ln452">       *  @returns @c *this</a>
<a name="ln453">       *</a>
<a name="ln454">       *  The target of @a __x is copied to @c *this. If @a __x has no</a>
<a name="ln455">       *  target, then @c *this will be empty.</a>
<a name="ln456">       *</a>
<a name="ln457">       *  If @a __x targets a function pointer or a reference to a function</a>
<a name="ln458">       *  object, then this operation will not throw an %exception.</a>
<a name="ln459">       */</a>
<a name="ln460">      function&amp;</a>
<a name="ln461">      operator=(const function&amp; __x)</a>
<a name="ln462">      {</a>
<a name="ln463">	function(__x).swap(*this);</a>
<a name="ln464">	return *this;</a>
<a name="ln465">      }</a>
<a name="ln466"> </a>
<a name="ln467">      /**</a>
<a name="ln468">       *  @brief %Function move-assignment operator.</a>
<a name="ln469">       *  @param __x A %function rvalue with identical call signature.</a>
<a name="ln470">       *  @returns @c *this</a>
<a name="ln471">       *</a>
<a name="ln472">       *  The target of @a __x is moved to @c *this. If @a __x has no</a>
<a name="ln473">       *  target, then @c *this will be empty.</a>
<a name="ln474">       *</a>
<a name="ln475">       *  If @a __x targets a function pointer or a reference to a function</a>
<a name="ln476">       *  object, then this operation will not throw an %exception.</a>
<a name="ln477">       */</a>
<a name="ln478">      function&amp;</a>
<a name="ln479">      operator=(function&amp;&amp; __x) noexcept</a>
<a name="ln480">      {</a>
<a name="ln481">	function(std::move(__x)).swap(*this);</a>
<a name="ln482">	return *this;</a>
<a name="ln483">      }</a>
<a name="ln484"> </a>
<a name="ln485">      /**</a>
<a name="ln486">       *  @brief %Function assignment to zero.</a>
<a name="ln487">       *  @post @c !(bool)*this</a>
<a name="ln488">       *  @returns @c *this</a>
<a name="ln489">       *</a>
<a name="ln490">       *  The target of @c *this is deallocated, leaving it empty.</a>
<a name="ln491">       */</a>
<a name="ln492">      function&amp;</a>
<a name="ln493">      operator=(nullptr_t) noexcept</a>
<a name="ln494">      {</a>
<a name="ln495">	if (_M_manager)</a>
<a name="ln496">	  {</a>
<a name="ln497">	    _M_manager(_M_functor, _M_functor, __destroy_functor);</a>
<a name="ln498">	    _M_manager = nullptr;</a>
<a name="ln499">	    _M_invoker = nullptr;</a>
<a name="ln500">	  }</a>
<a name="ln501">	return *this;</a>
<a name="ln502">      }</a>
<a name="ln503"> </a>
<a name="ln504">      /**</a>
<a name="ln505">       *  @brief %Function assignment to a new target.</a>
<a name="ln506">       *  @param __f A %function object that is callable with parameters of</a>
<a name="ln507">       *  type @c T1, @c T2, ..., @c TN and returns a value convertible</a>
<a name="ln508">       *  to @c Res.</a>
<a name="ln509">       *  @return @c *this</a>
<a name="ln510">       *</a>
<a name="ln511">       *  This  %function object wrapper will target a copy of @a</a>
<a name="ln512">       *  __f. If @a __f is @c reference_wrapper&lt;F&gt;, then this function</a>
<a name="ln513">       *  object will contain a reference to the function object @c</a>
<a name="ln514">       *  __f.get(). If @a __f is a NULL function pointer or NULL</a>
<a name="ln515">       *  pointer-to-member, @c this object will be empty.</a>
<a name="ln516">       *</a>
<a name="ln517">       *  If @a __f is a non-NULL function pointer or an object of type @c</a>
<a name="ln518">       *  reference_wrapper&lt;F&gt;, this function will not throw.</a>
<a name="ln519">       */</a>
<a name="ln520">      template&lt;typename _Functor&gt;</a>
<a name="ln521">	_Requires&lt;_Callable&lt;typename decay&lt;_Functor&gt;::type&gt;, function&amp;&gt;</a>
<a name="ln522">	operator=(_Functor&amp;&amp; __f)</a>
<a name="ln523">	{</a>
<a name="ln524">	  function(std::forward&lt;_Functor&gt;(__f)).swap(*this);</a>
<a name="ln525">	  return *this;</a>
<a name="ln526">	}</a>
<a name="ln527"> </a>
<a name="ln528">      /// @overload</a>
<a name="ln529">      template&lt;typename _Functor&gt;</a>
<a name="ln530">	function&amp;</a>
<a name="ln531">	operator=(reference_wrapper&lt;_Functor&gt; __f) noexcept</a>
<a name="ln532">	{</a>
<a name="ln533">	  function(__f).swap(*this);</a>
<a name="ln534">	  return *this;</a>
<a name="ln535">	}</a>
<a name="ln536"> </a>
<a name="ln537">      // [3.7.2.2] function modifiers</a>
<a name="ln538"> </a>
<a name="ln539">      /**</a>
<a name="ln540">       *  @brief Swap the targets of two %function objects.</a>
<a name="ln541">       *  @param __x A %function with identical call signature.</a>
<a name="ln542">       *</a>
<a name="ln543">       *  Swap the targets of @c this function object and @a __f. This</a>
<a name="ln544">       *  function will not throw an %exception.</a>
<a name="ln545">       */</a>
<a name="ln546">      void swap(function&amp; __x) noexcept</a>
<a name="ln547">      {</a>
<a name="ln548">	std::swap(_M_functor, __x._M_functor);</a>
<a name="ln549">	std::swap(_M_manager, __x._M_manager);</a>
<a name="ln550">	std::swap(_M_invoker, __x._M_invoker);</a>
<a name="ln551">      }</a>
<a name="ln552"> </a>
<a name="ln553">      // [3.7.2.3] function capacity</a>
<a name="ln554"> </a>
<a name="ln555">      /**</a>
<a name="ln556">       *  @brief Determine if the %function wrapper has a target.</a>
<a name="ln557">       *</a>
<a name="ln558">       *  @return @c true when this %function object contains a target,</a>
<a name="ln559">       *  or @c false when it is empty.</a>
<a name="ln560">       *</a>
<a name="ln561">       *  This function will not throw an %exception.</a>
<a name="ln562">       */</a>
<a name="ln563">      explicit operator bool() const noexcept</a>
<a name="ln564">      { return !_M_empty(); }</a>
<a name="ln565"> </a>
<a name="ln566">      // [3.7.2.4] function invocation</a>
<a name="ln567"> </a>
<a name="ln568">      /**</a>
<a name="ln569">       *  @brief Invokes the function targeted by @c *this.</a>
<a name="ln570">       *  @returns the result of the target.</a>
<a name="ln571">       *  @throws bad_function_call when @c !(bool)*this</a>
<a name="ln572">       *</a>
<a name="ln573">       *  The function call operator invokes the target function object</a>
<a name="ln574">       *  stored by @c this.</a>
<a name="ln575">       */</a>
<a name="ln576">      _Res operator()(_ArgTypes... __args) const;</a>
<a name="ln577"> </a>
<a name="ln578">#if __cpp_rtti</a>
<a name="ln579">      // [3.7.2.5] function target access</a>
<a name="ln580">      /**</a>
<a name="ln581">       *  @brief Determine the type of the target of this function object</a>
<a name="ln582">       *  wrapper.</a>
<a name="ln583">       *</a>
<a name="ln584">       *  @returns the type identifier of the target function object, or</a>
<a name="ln585">       *  @c typeid(void) if @c !(bool)*this.</a>
<a name="ln586">       *</a>
<a name="ln587">       *  This function will not throw an %exception.</a>
<a name="ln588">       */</a>
<a name="ln589">      const type_info&amp; target_type() const noexcept;</a>
<a name="ln590"> </a>
<a name="ln591">      /**</a>
<a name="ln592">       *  @brief Access the stored target function object.</a>
<a name="ln593">       *</a>
<a name="ln594">       *  @return Returns a pointer to the stored target function object,</a>
<a name="ln595">       *  if @c typeid(_Functor).equals(target_type()); otherwise, a NULL</a>
<a name="ln596">       *  pointer.</a>
<a name="ln597">       *</a>
<a name="ln598">       * This function does not throw exceptions.</a>
<a name="ln599">       *</a>
<a name="ln600">       * @{</a>
<a name="ln601">       */</a>
<a name="ln602">      template&lt;typename _Functor&gt;       _Functor* target() noexcept;</a>
<a name="ln603"> </a>
<a name="ln604">      template&lt;typename _Functor&gt; const _Functor* target() const noexcept;</a>
<a name="ln605">      // @}</a>
<a name="ln606">#endif</a>
<a name="ln607"> </a>
<a name="ln608">    private:</a>
<a name="ln609">      using _Invoker_type = _Res (*)(const _Any_data&amp;, _ArgTypes&amp;&amp;...);</a>
<a name="ln610">      _Invoker_type _M_invoker;</a>
<a name="ln611">  };</a>
<a name="ln612"> </a>
<a name="ln613">#if __cpp_deduction_guides &gt;= 201606</a>
<a name="ln614">  template&lt;typename&gt;</a>
<a name="ln615">    struct __function_guide_helper</a>
<a name="ln616">    { };</a>
<a name="ln617"> </a>
<a name="ln618">  template&lt;typename _Res, typename _Tp, bool _Nx, typename... _Args&gt;</a>
<a name="ln619">    struct __function_guide_helper&lt;</a>
<a name="ln620">      _Res (_Tp::*) (_Args...) noexcept(_Nx)</a>
<a name="ln621">    &gt;</a>
<a name="ln622">    { using type = _Res(_Args...); };</a>
<a name="ln623"> </a>
<a name="ln624">  template&lt;typename _Res, typename _Tp, bool _Nx, typename... _Args&gt;</a>
<a name="ln625">    struct __function_guide_helper&lt;</a>
<a name="ln626">      _Res (_Tp::*) (_Args...) &amp; noexcept(_Nx)</a>
<a name="ln627">    &gt;</a>
<a name="ln628">    { using type = _Res(_Args...); };</a>
<a name="ln629"> </a>
<a name="ln630">  template&lt;typename _Res, typename _Tp, bool _Nx, typename... _Args&gt;</a>
<a name="ln631">    struct __function_guide_helper&lt;</a>
<a name="ln632">      _Res (_Tp::*) (_Args...) const noexcept(_Nx)</a>
<a name="ln633">    &gt;</a>
<a name="ln634">    { using type = _Res(_Args...); };</a>
<a name="ln635"> </a>
<a name="ln636">  template&lt;typename _Res, typename _Tp, bool _Nx, typename... _Args&gt;</a>
<a name="ln637">    struct __function_guide_helper&lt;</a>
<a name="ln638">      _Res (_Tp::*) (_Args...) const &amp; noexcept(_Nx)</a>
<a name="ln639">    &gt;</a>
<a name="ln640">    { using type = _Res(_Args...); };</a>
<a name="ln641"> </a>
<a name="ln642">  template&lt;typename _Res, typename... _ArgTypes&gt;</a>
<a name="ln643">    function(_Res(*)(_ArgTypes...)) -&gt; function&lt;_Res(_ArgTypes...)&gt;;</a>
<a name="ln644"> </a>
<a name="ln645">  template&lt;typename _Functor, typename _Signature = typename</a>
<a name="ln646">	   __function_guide_helper&lt;decltype(&amp;_Functor::operator())&gt;::type&gt;</a>
<a name="ln647">    function(_Functor) -&gt; function&lt;_Signature&gt;;</a>
<a name="ln648">#endif</a>
<a name="ln649"> </a>
<a name="ln650">  // Out-of-line member definitions.</a>
<a name="ln651">  template&lt;typename _Res, typename... _ArgTypes&gt;</a>
<a name="ln652">    function&lt;_Res(_ArgTypes...)&gt;::</a>
<a name="ln653">    function(const function&amp; __x)</a>
<a name="ln654">    : _Function_base()</a>
<a name="ln655">    {</a>
<a name="ln656">      if (static_cast&lt;bool&gt;(__x))</a>
<a name="ln657">	{</a>
<a name="ln658">	  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);</a>
<a name="ln659">	  _M_invoker = __x._M_invoker;</a>
<a name="ln660">	  _M_manager = __x._M_manager;</a>
<a name="ln661">	}</a>
<a name="ln662">    }</a>
<a name="ln663"> </a>
<a name="ln664">  template&lt;typename _Res, typename... _ArgTypes&gt;</a>
<a name="ln665">    template&lt;typename _Functor, typename, typename&gt;</a>
<a name="ln666">      function&lt;_Res(_ArgTypes...)&gt;::</a>
<a name="ln667">      function(_Functor __f)</a>
<a name="ln668">      : _Function_base()</a>
<a name="ln669">      {</a>
<a name="ln670">	typedef _Function_handler&lt;_Res(_ArgTypes...), _Functor&gt; _My_handler;</a>
<a name="ln671"> </a>
<a name="ln672">	if (_My_handler::_M_not_empty_function(__f))</a>
<a name="ln673">	  {</a>
<a name="ln674">	    _My_handler::_M_init_functor(_M_functor, std::move(__f));</a>
<a name="ln675">	    _M_invoker = &amp;_My_handler::_M_invoke;</a>
<a name="ln676">	    _M_manager = &amp;_My_handler::_M_manager;</a>
<a name="ln677">	  }</a>
<a name="ln678">      }</a>
<a name="ln679"> </a>
<a name="ln680">  template&lt;typename _Res, typename... _ArgTypes&gt;</a>
<a name="ln681">    _Res</a>
<a name="ln682">    function&lt;_Res(_ArgTypes...)&gt;::</a>
<a name="ln683">    operator()(_ArgTypes... __args) const</a>
<a name="ln684">    {</a>
<a name="ln685">      if (_M_empty())</a>
<a name="ln686">	__throw_bad_function_call();</a>
<a name="ln687">      return _M_invoker(_M_functor, std::forward&lt;_ArgTypes&gt;(__args)...);</a>
<a name="ln688">    }</a>
<a name="ln689"> </a>
<a name="ln690">#if __cpp_rtti</a>
<a name="ln691">  template&lt;typename _Res, typename... _ArgTypes&gt;</a>
<a name="ln692">    const type_info&amp;</a>
<a name="ln693">    function&lt;_Res(_ArgTypes...)&gt;::</a>
<a name="ln694">    target_type() const noexcept</a>
<a name="ln695">    {</a>
<a name="ln696">      if (_M_manager)</a>
<a name="ln697">	{</a>
<a name="ln698">	  _Any_data __typeinfo_result;</a>
<a name="ln699">	  _M_manager(__typeinfo_result, _M_functor, __get_type_info);</a>
<a name="ln700">	  return *__typeinfo_result._M_access&lt;const type_info*&gt;();</a>
<a name="ln701">	}</a>
<a name="ln702">      else</a>
<a name="ln703">	return typeid(void);</a>
<a name="ln704">    }</a>
<a name="ln705"> </a>
<a name="ln706">  template&lt;typename _Res, typename... _ArgTypes&gt;</a>
<a name="ln707">    template&lt;typename _Functor&gt;</a>
<a name="ln708">      _Functor*</a>
<a name="ln709">      function&lt;_Res(_ArgTypes...)&gt;::</a>
<a name="ln710">      target() noexcept</a>
<a name="ln711">      {</a>
<a name="ln712">	const function* __const_this = this;</a>
<a name="ln713">	const _Functor* __func = __const_this-&gt;template target&lt;_Functor&gt;();</a>
<a name="ln714">	return const_cast&lt;_Functor*&gt;(__func);</a>
<a name="ln715">      }</a>
<a name="ln716"> </a>
<a name="ln717">  template&lt;typename _Res, typename... _ArgTypes&gt;</a>
<a name="ln718">    template&lt;typename _Functor&gt;</a>
<a name="ln719">      const _Functor*</a>
<a name="ln720">      function&lt;_Res(_ArgTypes...)&gt;::</a>
<a name="ln721">      target() const noexcept</a>
<a name="ln722">      {</a>
<a name="ln723">	if (typeid(_Functor) == target_type() &amp;&amp; _M_manager)</a>
<a name="ln724">	  {</a>
<a name="ln725">	    _Any_data __ptr;</a>
<a name="ln726">	    _M_manager(__ptr, _M_functor, __get_functor_ptr);</a>
<a name="ln727">	    return __ptr._M_access&lt;const _Functor*&gt;();</a>
<a name="ln728">	  }</a>
<a name="ln729">	else</a>
<a name="ln730">	  return nullptr;</a>
<a name="ln731">      }</a>
<a name="ln732">#endif</a>
<a name="ln733"> </a>
<a name="ln734">  // [20.7.15.2.6] null pointer comparisons</a>
<a name="ln735"> </a>
<a name="ln736">  /**</a>
<a name="ln737">   *  @brief Compares a polymorphic function object wrapper against 0</a>
<a name="ln738">   *  (the NULL pointer).</a>
<a name="ln739">   *  @returns @c true if the wrapper has no target, @c false otherwise</a>
<a name="ln740">   *</a>
<a name="ln741">   *  This function will not throw an %exception.</a>
<a name="ln742">   */</a>
<a name="ln743">  template&lt;typename _Res, typename... _Args&gt;</a>
<a name="ln744">    inline bool</a>
<a name="ln745">    operator==(const function&lt;_Res(_Args...)&gt;&amp; __f, nullptr_t) noexcept</a>
<a name="ln746">    { return !static_cast&lt;bool&gt;(__f); }</a>
<a name="ln747"> </a>
<a name="ln748">  /// @overload</a>
<a name="ln749">  template&lt;typename _Res, typename... _Args&gt;</a>
<a name="ln750">    inline bool</a>
<a name="ln751">    operator==(nullptr_t, const function&lt;_Res(_Args...)&gt;&amp; __f) noexcept</a>
<a name="ln752">    { return !static_cast&lt;bool&gt;(__f); }</a>
<a name="ln753"> </a>
<a name="ln754">  /**</a>
<a name="ln755">   *  @brief Compares a polymorphic function object wrapper against 0</a>
<a name="ln756">   *  (the NULL pointer).</a>
<a name="ln757">   *  @returns @c false if the wrapper has no target, @c true otherwise</a>
<a name="ln758">   *</a>
<a name="ln759">   *  This function will not throw an %exception.</a>
<a name="ln760">   */</a>
<a name="ln761">  template&lt;typename _Res, typename... _Args&gt;</a>
<a name="ln762">    inline bool</a>
<a name="ln763">    operator!=(const function&lt;_Res(_Args...)&gt;&amp; __f, nullptr_t) noexcept</a>
<a name="ln764">    { return static_cast&lt;bool&gt;(__f); }</a>
<a name="ln765"> </a>
<a name="ln766">  /// @overload</a>
<a name="ln767">  template&lt;typename _Res, typename... _Args&gt;</a>
<a name="ln768">    inline bool</a>
<a name="ln769">    operator!=(nullptr_t, const function&lt;_Res(_Args...)&gt;&amp; __f) noexcept</a>
<a name="ln770">    { return static_cast&lt;bool&gt;(__f); }</a>
<a name="ln771"> </a>
<a name="ln772"> </a>
<a name="ln773">  // [20.7.15.2.7] specialized algorithms</a>
<a name="ln774"> </a>
<a name="ln775">  /**</a>
<a name="ln776">   *  @brief Swap the targets of two polymorphic function object wrappers.</a>
<a name="ln777">   *</a>
<a name="ln778">   *  This function will not throw an %exception.</a>
<a name="ln779">   */</a>
<a name="ln780">  // _GLIBCXX_RESOLVE_LIB_DEFECTS</a>
<a name="ln781">  // 2062. Effect contradictions w/o no-throw guarantee of std::function swaps</a>
<a name="ln782">  template&lt;typename _Res, typename... _Args&gt;</a>
<a name="ln783">    inline void</a>
<a name="ln784">    swap(function&lt;_Res(_Args...)&gt;&amp; __x, function&lt;_Res(_Args...)&gt;&amp; __y) noexcept</a>
<a name="ln785">    { __x.swap(__y); }</a>
<a name="ln786"> </a>
<a name="ln787">_GLIBCXX_END_NAMESPACE_VERSION</a>
<a name="ln788">} // namespace std</a>
<a name="ln789"> </a>
<a name="ln790">#endif // C++11</a>
<a name="ln791"> </a>
<a name="ln792">#endif // _GLIBCXX_STD_FUNCTION_H</a>

</code></pre>
<div class="balloon" rel="188"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v772/" target="_blank">V772</a> Calling a 'delete' operator for a void pointer will cause undefined behavior.</p></div>
<div class="balloon" rel="252"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: _M_functor.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
