
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>remote_bootstrap_client.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Licensed to the Apache Software Foundation (ASF) under one</a>
<a name="ln2">// or more contributor license agreements.  See the NOTICE file</a>
<a name="ln3">// distributed with this work for additional information</a>
<a name="ln4">// regarding copyright ownership.  The ASF licenses this file</a>
<a name="ln5">// to you under the Apache License, Version 2.0 (the</a>
<a name="ln6">// &quot;License&quot;); you may not use this file except in compliance</a>
<a name="ln7">// with the License.  You may obtain a copy of the License at</a>
<a name="ln8">//</a>
<a name="ln9">//   http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln10">//</a>
<a name="ln11">// Unless required by applicable law or agreed to in writing,</a>
<a name="ln12">// software distributed under the License is distributed on an</a>
<a name="ln13">// &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</a>
<a name="ln14">// KIND, either express or implied.  See the License for the</a>
<a name="ln15">// specific language governing permissions and limitations</a>
<a name="ln16">// under the License.</a>
<a name="ln17">//</a>
<a name="ln18">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln19">//</a>
<a name="ln20">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln21">//</a>
<a name="ln22">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln23">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln24">//</a>
<a name="ln25">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln26">//</a>
<a name="ln27">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln28">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln29">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln30">// under the License.</a>
<a name="ln31">//</a>
<a name="ln32"> </a>
<a name="ln33">#include &quot;yb/tserver/remote_bootstrap_client.h&quot;</a>
<a name="ln34"> </a>
<a name="ln35">#include &lt;gflags/gflags.h&gt;</a>
<a name="ln36">#include &lt;glog/logging.h&gt;</a>
<a name="ln37"> </a>
<a name="ln38">#include &quot;yb/consensus/consensus.h&quot;</a>
<a name="ln39">#include &quot;yb/consensus/consensus_meta.h&quot;</a>
<a name="ln40">#include &quot;yb/consensus/metadata.pb.h&quot;</a>
<a name="ln41">#include &quot;yb/fs/fs_manager.h&quot;</a>
<a name="ln42">#include &quot;yb/gutil/strings/substitute.h&quot;</a>
<a name="ln43">#include &quot;yb/gutil/strings/util.h&quot;</a>
<a name="ln44">#include &quot;yb/gutil/walltime.h&quot;</a>
<a name="ln45">#include &quot;yb/rpc/messenger.h&quot;</a>
<a name="ln46">#include &quot;yb/rpc/rpc_controller.h&quot;</a>
<a name="ln47">#include &quot;yb/tablet/tablet.pb.h&quot;</a>
<a name="ln48">#include &quot;yb/tablet/tablet.h&quot;</a>
<a name="ln49">#include &quot;yb/tablet/tablet_bootstrap_if.h&quot;</a>
<a name="ln50">#include &quot;yb/tablet/tablet_metadata.h&quot;</a>
<a name="ln51">#include &quot;yb/tablet/tablet_peer.h&quot;</a>
<a name="ln52">#include &quot;yb/tserver/remote_bootstrap.pb.h&quot;</a>
<a name="ln53">#include &quot;yb/tserver/remote_bootstrap.proxy.h&quot;</a>
<a name="ln54">#include &quot;yb/tserver/remote_bootstrap_snapshots.h&quot;</a>
<a name="ln55">#include &quot;yb/tserver/tablet_server.h&quot;</a>
<a name="ln56">#include &quot;yb/tserver/ts_tablet_manager.h&quot;</a>
<a name="ln57">#include &quot;yb/util/env.h&quot;</a>
<a name="ln58">#include &quot;yb/util/env_util.h&quot;</a>
<a name="ln59">#include &quot;yb/util/fault_injection.h&quot;</a>
<a name="ln60">#include &quot;yb/util/flag_tags.h&quot;</a>
<a name="ln61">#include &quot;yb/util/net/net_util.h&quot;</a>
<a name="ln62">#include &quot;yb/util/scope_exit.h&quot;</a>
<a name="ln63">#include &quot;yb/util/size_literals.h&quot;</a>
<a name="ln64"> </a>
<a name="ln65">using namespace yb::size_literals;</a>
<a name="ln66"> </a>
<a name="ln67">DEFINE_int32(remote_bootstrap_begin_session_timeout_ms, 5000,</a>
<a name="ln68">             &quot;Tablet server RPC client timeout for BeginRemoteBootstrapSession calls.&quot;);</a>
<a name="ln69">TAG_FLAG(remote_bootstrap_begin_session_timeout_ms, hidden);</a>
<a name="ln70"> </a>
<a name="ln71">DEFINE_int32(remote_bootstrap_end_session_timeout_sec, 15,</a>
<a name="ln72">             &quot;Tablet server RPC client timeout for EndRemoteBootstrapSession calls. &quot;</a>
<a name="ln73">             &quot;The timeout is usually a large value because we have to wait for the remote server &quot;</a>
<a name="ln74">             &quot;to get a CHANGE_ROLE config change accepted.&quot;);</a>
<a name="ln75">TAG_FLAG(remote_bootstrap_end_session_timeout_sec, hidden);</a>
<a name="ln76"> </a>
<a name="ln77">DEFINE_bool(remote_bootstrap_save_downloaded_metadata, false,</a>
<a name="ln78">            &quot;Save copies of the downloaded remote bootstrap files for debugging purposes. &quot;</a>
<a name="ln79">            &quot;Note: This is only intended for debugging and should not be normally used!&quot;);</a>
<a name="ln80">TAG_FLAG(remote_bootstrap_save_downloaded_metadata, advanced);</a>
<a name="ln81">TAG_FLAG(remote_bootstrap_save_downloaded_metadata, hidden);</a>
<a name="ln82">TAG_FLAG(remote_bootstrap_save_downloaded_metadata, runtime);</a>
<a name="ln83"> </a>
<a name="ln84">DEFINE_int32(committed_config_change_role_timeout_sec, 30,</a>
<a name="ln85">             &quot;Number of seconds to wait for the CHANGE_ROLE to be in the committed config before &quot;</a>
<a name="ln86">             &quot;timing out. &quot;);</a>
<a name="ln87">TAG_FLAG(committed_config_change_role_timeout_sec, hidden);</a>
<a name="ln88"> </a>
<a name="ln89">DEFINE_test_flag(double, fault_crash_bootstrap_client_before_changing_role, 0.0,</a>
<a name="ln90">                 &quot;The remote bootstrap client will crash before closing the session with the &quot;</a>
<a name="ln91">                 &quot;leader. Because the session won't be closed successfully, the leader won't issue &quot;</a>
<a name="ln92">                 &quot;a ChangeConfig request to change this tserver role *(from PRE_VOTER or &quot;</a>
<a name="ln93">                 &quot;PRE_OBSERVER to VOTER or OBSERVER respectively).&quot;);</a>
<a name="ln94"> </a>
<a name="ln95">DEFINE_test_flag(int32, simulate_long_remote_bootstrap_sec, 0,</a>
<a name="ln96">                 &quot;The remote bootstrap client will take at least this number of seconds to finish. &quot;</a>
<a name="ln97">                 &quot;We use this for testing a scenario where a remote bootstrap takes longer than &quot;</a>
<a name="ln98">                 &quot;follower_unavailable_considered_failed_sec seconds.&quot;);</a>
<a name="ln99"> </a>
<a name="ln100">DEFINE_test_flag(bool, download_partial_wal_segments, false, &quot;&quot;);</a>
<a name="ln101"> </a>
<a name="ln102">DECLARE_int32(bytes_remote_bootstrap_durable_write_mb);</a>
<a name="ln103"> </a>
<a name="ln104">namespace yb {</a>
<a name="ln105">namespace tserver {</a>
<a name="ln106"> </a>
<a name="ln107">using consensus::ConsensusMetadata;</a>
<a name="ln108">using consensus::ConsensusStatePB;</a>
<a name="ln109">using consensus::RaftConfigPB;</a>
<a name="ln110">using consensus::RaftPeerPB;</a>
<a name="ln111">using env_util::CopyFile;</a>
<a name="ln112">using rpc::Messenger;</a>
<a name="ln113">using std::shared_ptr;</a>
<a name="ln114">using std::string;</a>
<a name="ln115">using std::vector;</a>
<a name="ln116">using strings::Substitute;</a>
<a name="ln117">using tablet::TabletDataState;</a>
<a name="ln118">using tablet::TabletDataState_Name;</a>
<a name="ln119">using tablet::RaftGroupMetadata;</a>
<a name="ln120">using tablet::RaftGroupMetadataPtr;</a>
<a name="ln121">using tablet::TabletStatusListener;</a>
<a name="ln122">using tablet::RaftGroupReplicaSuperBlockPB;</a>
<a name="ln123"> </a>
<a name="ln124">std::atomic&lt;int32_t&gt; remote_bootstrap_clients_started_{0};</a>
<a name="ln125"> </a>
<a name="ln126">RemoteBootstrapClient::RemoteBootstrapClient(std::string tablet_id, FsManager* fs_manager)</a>
<a name="ln127">    : tablet_id_(std::move(tablet_id)),</a>
<a name="ln128">      log_prefix_(Format(&quot;T $0 P $1: Remote bootstrap client: &quot;, tablet_id_, fs_manager-&gt;uuid())),</a>
<a name="ln129">      downloader_(&amp;log_prefix_, fs_manager) {</a>
<a name="ln130">  AddComponent&lt;RemoteBootstrapSnapshotsComponent&gt;();</a>
<a name="ln131">}</a>
<a name="ln132"> </a>
<a name="ln133">RemoteBootstrapClient::~RemoteBootstrapClient() {</a>
<a name="ln134">  // Note: Ending the remote bootstrap session releases anchors on the remote.</a>
<a name="ln135">  // This assumes that succeeded_ only gets set to true in Finish() just before calling</a>
<a name="ln136">  // EndRemoteSession. If this didn't happen, then close the session here.</a>
<a name="ln137">  if (!succeeded_) {</a>
<a name="ln138">    LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Closing remote bootstrap session &quot; &lt;&lt; session_id()</a>
<a name="ln139">                          &lt;&lt; &quot; in RemoteBootstrapClient destructor.&quot;;</a>
<a name="ln140">    WARN_NOT_OK(EndRemoteSession(),</a>
<a name="ln141">                LogPrefix() + &quot;Unable to close remote bootstrap session &quot; + session_id());</a>
<a name="ln142">  }</a>
<a name="ln143">  if (started_) {</a>
<a name="ln144">    auto old_count = remote_bootstrap_clients_started_.fetch_sub(1, std::memory_order_acq_rel);</a>
<a name="ln145">    if (old_count &lt; 1) {</a>
<a name="ln146">      LOG_WITH_PREFIX(DFATAL) &lt;&lt; &quot;Invalid number of remote bootstrap sessions: &quot; &lt;&lt; old_count;</a>
<a name="ln147">    }</a>
<a name="ln148">  }</a>
<a name="ln149">}</a>
<a name="ln150"> </a>
<a name="ln151">Status RemoteBootstrapClient::SetTabletToReplace(const RaftGroupMetadataPtr&amp; meta,</a>
<a name="ln152">                                                 int64_t caller_term) {</a>
<a name="ln153">  CHECK_EQ(tablet_id_, meta-&gt;raft_group_id());</a>
<a name="ln154">  TabletDataState data_state = meta-&gt;tablet_data_state();</a>
<a name="ln155">  if (data_state != tablet::TABLET_DATA_TOMBSTONED) {</a>
<a name="ln156">    return STATUS(IllegalState, Substitute(&quot;Tablet $0 not in tombstoned state: $1 ($2)&quot;,</a>
<a name="ln157">                                           tablet_id_,</a>
<a name="ln158">                                           TabletDataState_Name(data_state),</a>
<a name="ln159">                                           data_state));</a>
<a name="ln160">  }</a>
<a name="ln161"> </a>
<a name="ln162">  replace_tombstoned_tablet_ = true;</a>
<a name="ln163">  meta_ = meta;</a>
<a name="ln164"> </a>
<a name="ln165">  int64_t last_logged_term = meta-&gt;tombstone_last_logged_opid().term;</a>
<a name="ln166">  if (last_logged_term &gt; caller_term) {</a>
<a name="ln167">    return STATUS(InvalidArgument,</a>
<a name="ln168">        Substitute(&quot;Leader has term $0 but the last log entry written by the tombstoned replica &quot;</a>
<a name="ln169">                   &quot;for tablet $1 has higher term $2. Refusing remote bootstrap from leader&quot;,</a>
<a name="ln170">                   caller_term, tablet_id_, last_logged_term));</a>
<a name="ln171">  }</a>
<a name="ln172"> </a>
<a name="ln173">  // Load the old consensus metadata, if it exists.</a>
<a name="ln174">  std::unique_ptr&lt;ConsensusMetadata&gt; cmeta;</a>
<a name="ln175">  Status s = ConsensusMetadata::Load(</a>
<a name="ln176">      &amp;fs_manager(), tablet_id_, permanent_uuid(), &amp;cmeta);</a>
<a name="ln177">  if (s.IsNotFound()) {</a>
<a name="ln178">    // The consensus metadata was not written to disk, possibly due to a failed</a>
<a name="ln179">    // remote bootstrap.</a>
<a name="ln180">    return Status::OK();</a>
<a name="ln181">  }</a>
<a name="ln182">  RETURN_NOT_OK(s);</a>
<a name="ln183">  cmeta_ = std::move(cmeta);</a>
<a name="ln184">  return Status::OK();</a>
<a name="ln185">}</a>
<a name="ln186"> </a>
<a name="ln187">Status RemoteBootstrapClient::Start(const string&amp; bootstrap_peer_uuid,</a>
<a name="ln188">                                    rpc::ProxyCache* proxy_cache,</a>
<a name="ln189">                                    const HostPort&amp; bootstrap_peer_addr,</a>
<a name="ln190">                                    RaftGroupMetadataPtr* meta,</a>
<a name="ln191">                                    TSTabletManager* ts_manager) {</a>
<a name="ln192">  CHECK(!started_);</a>
<a name="ln193">  start_time_micros_ = GetCurrentTimeMicros();</a>
<a name="ln194"> </a>
<a name="ln195">  LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Beginning remote bootstrap session&quot;</a>
<a name="ln196">                        &lt;&lt; &quot; from remote peer at address &quot; &lt;&lt; bootstrap_peer_addr.ToString();</a>
<a name="ln197"> </a>
<a name="ln198">  // Set up an RPC proxy for the RemoteBootstrapService.</a>
<a name="ln199">  proxy_.reset(new RemoteBootstrapServiceProxy(proxy_cache, bootstrap_peer_addr));</a>
<a name="ln200"> </a>
<a name="ln201">  BeginRemoteBootstrapSessionRequestPB req;</a>
<a name="ln202">  req.set_requestor_uuid(permanent_uuid());</a>
<a name="ln203">  req.set_tablet_id(tablet_id_);</a>
<a name="ln204"> </a>
<a name="ln205">  rpc::RpcController controller;</a>
<a name="ln206">  controller.set_timeout(MonoDelta::FromMilliseconds(</a>
<a name="ln207">      FLAGS_remote_bootstrap_begin_session_timeout_ms));</a>
<a name="ln208"> </a>
<a name="ln209">  // Begin the remote bootstrap session with the remote peer.</a>
<a name="ln210">  BeginRemoteBootstrapSessionResponsePB resp;</a>
<a name="ln211">  auto status =</a>
<a name="ln212">      UnwindRemoteError(proxy_-&gt;BeginRemoteBootstrapSession(req, &amp;resp, &amp;controller), controller);</a>
<a name="ln213"> </a>
<a name="ln214">  if (!status.ok()) {</a>
<a name="ln215">    status = status.CloneAndPrepend(&quot;Unable to begin remote bootstrap session&quot;);</a>
<a name="ln216">    LOG_WITH_PREFIX(WARNING) &lt;&lt; status;</a>
<a name="ln217">    return status;</a>
<a name="ln218">  }</a>
<a name="ln219"> </a>
<a name="ln220">  remote_tablet_data_state_ = resp.superblock().tablet_data_state();</a>
<a name="ln221">  if (!CanServeTabletData(remote_tablet_data_state_)) {</a>
<a name="ln222">    Status s = STATUS(IllegalState, &quot;Remote peer (&quot; + bootstrap_peer_uuid + &quot;)&quot; +</a>
<a name="ln223">                                    &quot; is currently remotely bootstrapping itself!&quot;,</a>
<a name="ln224">                                    resp.superblock().ShortDebugString());</a>
<a name="ln225">    LOG_WITH_PREFIX(WARNING) &lt;&lt; s.ToString();</a>
<a name="ln226">    return s;</a>
<a name="ln227">  }</a>
<a name="ln228"> </a>
<a name="ln229">  LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Received superblock: &quot; &lt;&lt; resp.superblock().ShortDebugString();</a>
<a name="ln230">  RETURN_NOT_OK(MigrateSuperblock(resp.mutable_superblock()));</a>
<a name="ln231"> </a>
<a name="ln232">  auto* kv_store = resp.mutable_superblock()-&gt;mutable_kv_store();</a>
<a name="ln233">  LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;RocksDB files: &quot; &lt;&lt; yb::ToString(kv_store-&gt;rocksdb_files());</a>
<a name="ln234">  LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Snapshot files: &quot; &lt;&lt; yb::ToString(kv_store-&gt;snapshot_files());</a>
<a name="ln235">  if (first_wal_seqno_) {</a>
<a name="ln236">    LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;First WAL segment: &quot; &lt;&lt; first_wal_seqno_;</a>
<a name="ln237">  } else {</a>
<a name="ln238">    LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Log files: &quot; &lt;&lt; yb::ToString(resp.deprecated_wal_segment_seqnos());</a>
<a name="ln239">  }</a>
<a name="ln240"> </a>
<a name="ln241">  const TableId table_id = resp.superblock().primary_table_id();</a>
<a name="ln242">  const bool colocated = resp.superblock().colocated();</a>
<a name="ln243">  const tablet::TableInfoPB* table_ptr = nullptr;</a>
<a name="ln244">  for (auto&amp; table_pb : kv_store-&gt;tables()) {</a>
<a name="ln245">    if (table_pb.table_id() == table_id) {</a>
<a name="ln246">      table_ptr = &amp;table_pb;</a>
<a name="ln247">      break;</a>
<a name="ln248">    }</a>
<a name="ln249">  }</a>
<a name="ln250">  if (!table_ptr) {</a>
<a name="ln251">    return STATUS(InvalidArgument, Format(</a>
<a name="ln252">        &quot;Tablet $0: Superblock's KV-store doesn't contain primary table $1&quot;, tablet_id_,</a>
<a name="ln253">        table_id));</a>
<a name="ln254">  }</a>
<a name="ln255">  const auto&amp; table = *table_ptr;</a>
<a name="ln256"> </a>
<a name="ln257">  downloader_.Start(</a>
<a name="ln258">      proxy_, resp.session_id(), MonoDelta::FromMilliseconds(resp.session_idle_timeout_millis()));</a>
<a name="ln259">  LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Began remote bootstrap session &quot; &lt;&lt; session_id();</a>
<a name="ln260"> </a>
<a name="ln261">  superblock_.reset(resp.release_superblock());</a>
<a name="ln262"> </a>
<a name="ln263">  // Clear fields rocksdb_dir and wal_dir so we get an error if we try to use them without setting</a>
<a name="ln264">  // them to the right path.</a>
<a name="ln265">  kv_store-&gt;clear_rocksdb_dir();</a>
<a name="ln266">  superblock_-&gt;clear_wal_dir();</a>
<a name="ln267"> </a>
<a name="ln268">  superblock_-&gt;set_tablet_data_state(tablet::TABLET_DATA_COPYING);</a>
<a name="ln269">  wal_seqnos_.assign(resp.deprecated_wal_segment_seqnos().begin(),</a>
<a name="ln270">                     resp.deprecated_wal_segment_seqnos().end());</a>
<a name="ln271">  if (resp.has_first_wal_segment_seqno()) {</a>
<a name="ln272">    first_wal_seqno_ = resp.first_wal_segment_seqno();</a>
<a name="ln273">  } else {</a>
<a name="ln274">    first_wal_seqno_ = 0;</a>
<a name="ln275">  }</a>
<a name="ln276">  remote_committed_cstate_.reset(resp.release_initial_committed_cstate());</a>
<a name="ln277"> </a>
<a name="ln278">  Schema schema;</a>
<a name="ln279">  RETURN_NOT_OK_PREPEND(SchemaFromPB(</a>
<a name="ln280">      table.schema(), &amp;schema), &quot;Cannot deserialize schema from remote superblock&quot;);</a>
<a name="ln281">  string data_root_dir;</a>
<a name="ln282">  string wal_root_dir;</a>
<a name="ln283">  if (replace_tombstoned_tablet_) {</a>
<a name="ln284">    // Also validate the term of the bootstrap source peer, in case they are</a>
<a name="ln285">    // different. This is a sanity check that protects us in case a bug or</a>
<a name="ln286">    // misconfiguration causes us to attempt to bootstrap from an out-of-date</a>
<a name="ln287">    // source peer, even after passing the term check from the caller in</a>
<a name="ln288">    // SetTabletToReplace().</a>
<a name="ln289">    int64_t last_logged_term = meta_-&gt;tombstone_last_logged_opid().term;</a>
<a name="ln290">    if (last_logged_term &gt; remote_committed_cstate_-&gt;current_term()) {</a>
<a name="ln291">      return STATUS(InvalidArgument,</a>
<a name="ln292">          Substitute(&quot;Tablet $0: Bootstrap source has term $1 but &quot;</a>
<a name="ln293">                     &quot;tombstoned replica has last-logged opid with higher term $2. &quot;</a>
<a name="ln294">                      &quot;Refusing remote bootstrap from source peer $3&quot;,</a>
<a name="ln295">                      tablet_id_,</a>
<a name="ln296">                      remote_committed_cstate_-&gt;current_term(),</a>
<a name="ln297">                      last_logged_term,</a>
<a name="ln298">                      bootstrap_peer_uuid));</a>
<a name="ln299">    }</a>
<a name="ln300">    // Replace rocksdb_dir in the received superblock with our rocksdb_dir.</a>
<a name="ln301">    kv_store-&gt;set_rocksdb_dir(meta_-&gt;rocksdb_dir());</a>
<a name="ln302"> </a>
<a name="ln303">    // Replace wal_dir in the received superblock with our assigned wal_dir.</a>
<a name="ln304">    superblock_-&gt;set_wal_dir(meta_-&gt;wal_dir());</a>
<a name="ln305"> </a>
<a name="ln306">    // This will flush to disk, but we set the data state to COPYING above.</a>
<a name="ln307">    RETURN_NOT_OK_PREPEND(meta_-&gt;ReplaceSuperBlock(*superblock_),</a>
<a name="ln308">                          &quot;Remote bootstrap unable to replace superblock on tablet &quot; +</a>
<a name="ln309">                          tablet_id_);</a>
<a name="ln310">    // Update the directory assignment mapping.</a>
<a name="ln311">    data_root_dir = meta_-&gt;data_root_dir();</a>
<a name="ln312">    wal_root_dir = meta_-&gt;wal_root_dir();</a>
<a name="ln313">    if (ts_manager != nullptr) {</a>
<a name="ln314">      ts_manager-&gt;RegisterDataAndWalDir(&amp;fs_manager(),</a>
<a name="ln315">                                        table_id,</a>
<a name="ln316">                                        meta_-&gt;raft_group_id(),</a>
<a name="ln317">                                        data_root_dir,</a>
<a name="ln318">                                        wal_root_dir);</a>
<a name="ln319">    }</a>
<a name="ln320">  } else {</a>
<a name="ln321">    Partition partition;</a>
<a name="ln322">    Partition::FromPB(superblock_-&gt;partition(), &amp;partition);</a>
<a name="ln323">    PartitionSchema partition_schema;</a>
<a name="ln324">    RETURN_NOT_OK(PartitionSchema::FromPB(table.partition_schema(), schema, &amp;partition_schema));</a>
<a name="ln325">    // Create the superblock on disk.</a>
<a name="ln326">    if (ts_manager != nullptr) {</a>
<a name="ln327">      ts_manager-&gt;GetAndRegisterDataAndWalDir(&amp;fs_manager(),</a>
<a name="ln328">                                              table_id,</a>
<a name="ln329">                                              tablet_id_,</a>
<a name="ln330">                                              &amp;data_root_dir,</a>
<a name="ln331">                                              &amp;wal_root_dir);</a>
<a name="ln332">    }</a>
<a name="ln333">    Status create_status = RaftGroupMetadata::CreateNew(</a>
<a name="ln334">        &amp;fs_manager(),</a>
<a name="ln335">        table_id,</a>
<a name="ln336">        tablet_id_,</a>
<a name="ln337">        table.namespace_name(),</a>
<a name="ln338">        table.table_name(),</a>
<a name="ln339">        table.table_type(),</a>
<a name="ln340">        schema,</a>
<a name="ln341">        IndexMap(table.indexes()),</a>
<a name="ln342">        partition_schema,</a>
<a name="ln343">        partition,</a>
<a name="ln344">        table.has_index_info() ? boost::optional&lt;IndexInfo&gt;(table.index_info()) : boost::none,</a>
<a name="ln345">        table.schema_version(),</a>
<a name="ln346">        tablet::TABLET_DATA_COPYING,</a>
<a name="ln347">        &amp;meta_,</a>
<a name="ln348">        data_root_dir,</a>
<a name="ln349">        wal_root_dir,</a>
<a name="ln350">        colocated);</a>
<a name="ln351">    if (ts_manager != nullptr &amp;&amp; !create_status.ok()) {</a>
<a name="ln352">      ts_manager-&gt;UnregisterDataWalDir(table_id,</a>
<a name="ln353">                                       tablet_id_,</a>
<a name="ln354">                                       data_root_dir,</a>
<a name="ln355">                                       wal_root_dir);</a>
<a name="ln356">    }</a>
<a name="ln357">    RETURN_NOT_OK(create_status);</a>
<a name="ln358"> </a>
<a name="ln359">    vector&lt;DeletedColumn&gt; deleted_cols;</a>
<a name="ln360">    for (const DeletedColumnPB&amp; col_pb : table.deleted_cols()) {</a>
<a name="ln361">      DeletedColumn col;</a>
<a name="ln362">      RETURN_NOT_OK(DeletedColumn::FromPB(col_pb, &amp;col));</a>
<a name="ln363">      deleted_cols.push_back(col);</a>
<a name="ln364">    }</a>
<a name="ln365">    meta_-&gt;SetSchema(schema,</a>
<a name="ln366">                     IndexMap(table.indexes()),</a>
<a name="ln367">                     deleted_cols,</a>
<a name="ln368">                     table.schema_version());</a>
<a name="ln369"> </a>
<a name="ln370">    // Replace rocksdb_dir in the received superblock with our rocksdb_dir.</a>
<a name="ln371">    kv_store-&gt;set_rocksdb_dir(meta_-&gt;rocksdb_dir());</a>
<a name="ln372"> </a>
<a name="ln373">    // Replace wal_dir in the received superblock with our assigned wal_dir.</a>
<a name="ln374">    superblock_-&gt;set_wal_dir(meta_-&gt;wal_dir());</a>
<a name="ln375">  }</a>
<a name="ln376"> </a>
<a name="ln377">  started_ = true;</a>
<a name="ln378">  auto old_count = remote_bootstrap_clients_started_.fetch_add(1, std::memory_order_acq_rel);</a>
<a name="ln379">  if (old_count &lt; 0) {</a>
<a name="ln380">    LOG_WITH_PREFIX(DFATAL) &lt;&lt; &quot;Invalid number of remote bootstrap sessions: &quot; &lt;&lt; old_count;</a>
<a name="ln381">    remote_bootstrap_clients_started_.store(0, std::memory_order_release);</a>
<a name="ln382">  }</a>
<a name="ln383"> </a>
<a name="ln384">  if (meta) {</a>
<a name="ln385">    *meta = meta_;</a>
<a name="ln386">  }</a>
<a name="ln387">  return Status::OK();</a>
<a name="ln388">}</a>
<a name="ln389"> </a>
<a name="ln390">Status RemoteBootstrapClient::FetchAll(TabletStatusListener* status_listener) {</a>
<a name="ln391">  CHECK(started_);</a>
<a name="ln392">  status_listener_ = CHECK_NOTNULL(status_listener);</a>
<a name="ln393"> </a>
<a name="ln394">  VLOG_WITH_PREFIX(2) &lt;&lt; &quot;Fetching table_type: &quot; &lt;&lt; TableType_Name(meta_-&gt;table_type());</a>
<a name="ln395"> </a>
<a name="ln396">  new_superblock_ = *superblock_;</a>
<a name="ln397">  // Replace rocksdb_dir with our rocksdb_dir</a>
<a name="ln398">  new_superblock_.mutable_kv_store()-&gt;set_rocksdb_dir(meta_-&gt;rocksdb_dir());</a>
<a name="ln399"> </a>
<a name="ln400">  RETURN_NOT_OK(DownloadRocksDBFiles());</a>
<a name="ln401">  RETURN_NOT_OK(DownloadWALs());</a>
<a name="ln402">  for (const auto&amp; component : components_) {</a>
<a name="ln403">    RETURN_NOT_OK(component-&gt;Download());</a>
<a name="ln404">  }</a>
<a name="ln405"> </a>
<a name="ln406">  // We sleep here to simulate the transfer of very large files.</a>
<a name="ln407">  if (PREDICT_FALSE(FLAGS_TEST_simulate_long_remote_bootstrap_sec &gt; 0)) {</a>
<a name="ln408">    LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Sleeping &quot; &lt;&lt; FLAGS_TEST_simulate_long_remote_bootstrap_sec</a>
<a name="ln409">                          &lt;&lt; &quot; seconds to simulate the transfer of very large files&quot;;</a>
<a name="ln410">    SleepFor(MonoDelta::FromSeconds(FLAGS_TEST_simulate_long_remote_bootstrap_sec));</a>
<a name="ln411">  }</a>
<a name="ln412">  return Status::OK();</a>
<a name="ln413">}</a>
<a name="ln414"> </a>
<a name="ln415">Status RemoteBootstrapClient::Finish() {</a>
<a name="ln416">  CHECK(meta_);</a>
<a name="ln417">  CHECK(started_);</a>
<a name="ln418"> </a>
<a name="ln419">  CHECK(downloaded_wal_);</a>
<a name="ln420">  CHECK(downloaded_rocksdb_files_) &lt;&lt; &quot;files not downloaded&quot;;;</a>
<a name="ln421"> </a>
<a name="ln422">  RETURN_NOT_OK(WriteConsensusMetadata());</a>
<a name="ln423"> </a>
<a name="ln424">  // Replace tablet metadata superblock. This will set the tablet metadata state</a>
<a name="ln425">  // to remote_tablet_data_state_.</a>
<a name="ln426">  LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Remote bootstrap complete. Replacing tablet superblock.&quot;;</a>
<a name="ln427">  UpdateStatusMessage(&quot;Replacing tablet superblock&quot;);</a>
<a name="ln428">  new_superblock_.set_tablet_data_state(remote_tablet_data_state_);</a>
<a name="ln429">  RETURN_NOT_OK(meta_-&gt;ReplaceSuperBlock(new_superblock_));</a>
<a name="ln430"> </a>
<a name="ln431">  if (FLAGS_remote_bootstrap_save_downloaded_metadata) {</a>
<a name="ln432">    string meta_path = fs_manager().GetRaftGroupMetadataPath(tablet_id_);</a>
<a name="ln433">    string meta_copy_path = Substitute(&quot;$0.copy.$1.tmp&quot;, meta_path, start_time_micros_);</a>
<a name="ln434">    RETURN_NOT_OK_PREPEND(CopyFile(Env::Default(), meta_path, meta_copy_path,</a>
<a name="ln435">                                   WritableFileOptions()),</a>
<a name="ln436">                          &quot;Unable to make copy of tablet metadata&quot;);</a>
<a name="ln437">  }</a>
<a name="ln438"> </a>
<a name="ln439">  succeeded_ = true;</a>
<a name="ln440"> </a>
<a name="ln441">  MAYBE_FAULT(FLAGS_TEST_fault_crash_bootstrap_client_before_changing_role);</a>
<a name="ln442"> </a>
<a name="ln443">  RETURN_NOT_OK_PREPEND(</a>
<a name="ln444">      EndRemoteSession(), &quot;Error closing remote bootstrap session &quot; + session_id());</a>
<a name="ln445"> </a>
<a name="ln446">  return Status::OK();</a>
<a name="ln447">}</a>
<a name="ln448"> </a>
<a name="ln449">Status RemoteBootstrapClient::VerifyChangeRoleSucceeded(</a>
<a name="ln450">    const shared_ptr&lt;consensus::Consensus&gt;&amp; shared_consensus) {</a>
<a name="ln451"> </a>
<a name="ln452">  if (!shared_consensus) {</a>
<a name="ln453">    return STATUS(InvalidArgument, &quot;Invalid consensus object&quot;);</a>
<a name="ln454">  }</a>
<a name="ln455"> </a>
<a name="ln456">  auto start = MonoTime::Now();</a>
<a name="ln457">  auto timeout = MonoDelta::FromSeconds(FLAGS_committed_config_change_role_timeout_sec);</a>
<a name="ln458">  int backoff_ms = 1;</a>
<a name="ln459">  const int kMaxBackoffMs = 256;</a>
<a name="ln460">  RaftConfigPB committed_config;</a>
<a name="ln461"> </a>
<a name="ln462">  do {</a>
<a name="ln463">    committed_config = shared_consensus-&gt;CommittedConfig();</a>
<a name="ln464">    for (const auto &amp;peer : committed_config.peers()) {</a>
<a name="ln465">      if (peer.permanent_uuid() != permanent_uuid()) {</a>
<a name="ln466">        continue;</a>
<a name="ln467">      }</a>
<a name="ln468"> </a>
<a name="ln469">      if (peer.member_type() == RaftPeerPB::VOTER || peer.member_type() == RaftPeerPB::OBSERVER) {</a>
<a name="ln470">        return Status::OK();</a>
<a name="ln471">      } else {</a>
<a name="ln472">        SleepFor(MonoDelta::FromMilliseconds(backoff_ms));</a>
<a name="ln473">        backoff_ms = min(backoff_ms &lt;&lt; 1, kMaxBackoffMs);</a>
<a name="ln474">        break;</a>
<a name="ln475">      }</a>
<a name="ln476">    }</a>
<a name="ln477">  } while (MonoTime::Now().GetDeltaSince(start).LessThan(timeout));</a>
<a name="ln478"> </a>
<a name="ln479">  return STATUS(TimedOut,</a>
<a name="ln480">                Substitute(&quot;Timed out waiting member type of peer $0 to change in the committed &quot;</a>
<a name="ln481">                           &quot;config $1&quot;, permanent_uuid(),</a>
<a name="ln482">                           committed_config.ShortDebugString()));</a>
<a name="ln483">}</a>
<a name="ln484"> </a>
<a name="ln485">void RemoteBootstrapClient::UpdateStatusMessage(const string&amp; message) {</a>
<a name="ln486">  if (status_listener_ != nullptr) {</a>
<a name="ln487">    status_listener_-&gt;StatusMessage(&quot;RemoteBootstrap: &quot; + message);</a>
<a name="ln488">  }</a>
<a name="ln489">}</a>
<a name="ln490"> </a>
<a name="ln491">Status RemoteBootstrapClient::EndRemoteSession() {</a>
<a name="ln492">  if (!started_) {</a>
<a name="ln493">    return Status::OK();</a>
<a name="ln494">  }</a>
<a name="ln495"> </a>
<a name="ln496">  rpc::RpcController controller;</a>
<a name="ln497">  controller.set_timeout(MonoDelta::FromSeconds(FLAGS_remote_bootstrap_end_session_timeout_sec));</a>
<a name="ln498"> </a>
<a name="ln499">  EndRemoteBootstrapSessionRequestPB req;</a>
<a name="ln500">  req.set_session_id(session_id());</a>
<a name="ln501">  req.set_is_success(succeeded_);</a>
<a name="ln502">  req.set_keep_session(succeeded_);</a>
<a name="ln503">  EndRemoteBootstrapSessionResponsePB resp;</a>
<a name="ln504"> </a>
<a name="ln505">  LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Ending remote bootstrap session &quot; &lt;&lt; session_id();</a>
<a name="ln506">  auto status = proxy_-&gt;EndRemoteBootstrapSession(req, &amp;resp, &amp;controller);</a>
<a name="ln507">  if (status.ok()) {</a>
<a name="ln508">    remove_required_ = resp.session_kept();</a>
<a name="ln509">    LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Remote bootstrap session &quot; &lt;&lt; session_id()</a>
<a name="ln510">                          &lt;&lt; &quot; ended successfully&quot;;</a>
<a name="ln511">    return Status::OK();</a>
<a name="ln512">  }</a>
<a name="ln513"> </a>
<a name="ln514">  if (status.IsTimedOut()) {</a>
<a name="ln515">    // Ignore timeout errors since the server could have sent the ChangeConfig request and died</a>
<a name="ln516">    // before replying. We need to check the config to verify that this server's role changed as</a>
<a name="ln517">    // expected, in which case, the remote bootstrap was completed successfully.</a>
<a name="ln518">    LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Remote bootstrap session &quot; &lt;&lt; session_id() &lt;&lt; &quot; timed out&quot;;</a>
<a name="ln519">    return Status::OK();</a>
<a name="ln520">  }</a>
<a name="ln521"> </a>
<a name="ln522">  status = UnwindRemoteError(status, controller);</a>
<a name="ln523">  return status.CloneAndPrepend(</a>
<a name="ln524">      Format(&quot;Failed to end remote bootstrap session $0&quot;, session_id()));</a>
<a name="ln525">}</a>
<a name="ln526"> </a>
<a name="ln527">Status RemoteBootstrapClient::Remove() {</a>
<a name="ln528">  if (!remove_required_) {</a>
<a name="ln529">    return Status::OK();</a>
<a name="ln530">  }</a>
<a name="ln531"> </a>
<a name="ln532">  rpc::RpcController controller;</a>
<a name="ln533">  controller.set_timeout(MonoDelta::FromSeconds(FLAGS_remote_bootstrap_end_session_timeout_sec));</a>
<a name="ln534"> </a>
<a name="ln535">  RemoveSessionRequestPB req;</a>
<a name="ln536">  req.set_session_id(session_id());</a>
<a name="ln537">  RemoveSessionResponsePB resp;</a>
<a name="ln538"> </a>
<a name="ln539">  LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Removing remote bootstrap session &quot; &lt;&lt; session_id();</a>
<a name="ln540">  const auto status = proxy_-&gt;RemoveSession(req, &amp;resp, &amp;controller);</a>
<a name="ln541">  if (status.ok()) {</a>
<a name="ln542">    LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Remote bootstrap session &quot; &lt;&lt; session_id() &lt;&lt; &quot; removed successfully&quot;;</a>
<a name="ln543">    return Status::OK();</a>
<a name="ln544">  }</a>
<a name="ln545"> </a>
<a name="ln546">  return UnwindRemoteError(status, controller).CloneAndPrepend(</a>
<a name="ln547">      Format(&quot;Failure removing remote bootstrap session $0&quot;, session_id()));</a>
<a name="ln548">}</a>
<a name="ln549"> </a>
<a name="ln550">Status RemoteBootstrapClient::DownloadWALs() {</a>
<a name="ln551">  CHECK(started_);</a>
<a name="ln552"> </a>
<a name="ln553">  // Delete and recreate WAL dir if it already exists, to ensure stray files are</a>
<a name="ln554">  // not kept from previous bootstraps and runs.</a>
<a name="ln555">  const string&amp; wal_dir = meta_-&gt;wal_dir();</a>
<a name="ln556">  if (env().FileExists(wal_dir)) {</a>
<a name="ln557">    RETURN_NOT_OK(env().DeleteRecursively(wal_dir));</a>
<a name="ln558">  }</a>
<a name="ln559">  auto wal_table_top_dir = DirName(wal_dir);</a>
<a name="ln560">  RETURN_NOT_OK_PREPEND(fs_manager().CreateDirIfMissing(wal_table_top_dir),</a>
<a name="ln561">                        Substitute(&quot;Failed to create WAL table directory $0&quot;, wal_table_top_dir));</a>
<a name="ln562"> </a>
<a name="ln563">  // fsync() parent dir.</a>
<a name="ln564">  RETURN_NOT_OK_PREPEND(env().SyncDir(DirName(wal_table_top_dir)),</a>
<a name="ln565">                        Substitute(&quot;Failed to sync WAL root directory $0&quot;,</a>
<a name="ln566">                                   DirName(wal_table_top_dir)));</a>
<a name="ln567"> </a>
<a name="ln568">  RETURN_NOT_OK_PREPEND(env().CreateDir(wal_dir),</a>
<a name="ln569">                        Substitute(&quot;Failed to create WAL tablet directory $0&quot;, wal_dir));</a>
<a name="ln570"> </a>
<a name="ln571">  // fsync() parent dir.</a>
<a name="ln572">  RETURN_NOT_OK_PREPEND(env().SyncDir(wal_table_top_dir),</a>
<a name="ln573">                        Substitute(&quot;Failed to sync WAL table directory $0&quot;, wal_table_top_dir));</a>
<a name="ln574"> </a>
<a name="ln575">  // Download the WAL segments.</a>
<a name="ln576">  uint64_t counter = 0;</a>
<a name="ln577">  if (first_wal_seqno_) {</a>
<a name="ln578">    LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Starting download of WAL segments starting from sequence number &quot;</a>
<a name="ln579">                          &lt;&lt; first_wal_seqno_;</a>
<a name="ln580">    for (;;) {</a>
<a name="ln581">      uint64_t segment_seqno = first_wal_seqno_ + counter;</a>
<a name="ln582">      UpdateStatusMessage(</a>
<a name="ln583">          Format(&quot;Downloading WAL segment with seq. number $0 (#$1 in this session)&quot;,</a>
<a name="ln584">                 segment_seqno, counter + 1));</a>
<a name="ln585">      auto download_status = DownloadWAL(segment_seqno);</a>
<a name="ln586">      if (!download_status.ok()) {</a>
<a name="ln587">        std::string message_suffix;</a>
<a name="ln588">        if (counter &gt; 0) {</a>
<a name="ln589">          message_suffix = Format(&quot;, downloaded segments in range: $0..$1&quot;,</a>
<a name="ln590">                                      first_wal_seqno_, segment_seqno - 1);</a>
<a name="ln591">        } else {</a>
<a name="ln592">          message_suffix = &quot;, no segments were downloaded&quot;;</a>
<a name="ln593">        }</a>
<a name="ln594">        if (download_status.IsNotFound()) {</a>
<a name="ln595">          LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Stopped downloading WAL segments&quot; &lt;&lt; message_suffix;</a>
<a name="ln596">          break;</a>
<a name="ln597">        }</a>
<a name="ln598">        LOG_WITH_PREFIX(WARNING) &lt;&lt; &quot;Downloading WAL segments failed: &quot;</a>
<a name="ln599">                                 &lt;&lt; download_status &lt;&lt; message_suffix;</a>
<a name="ln600">        return download_status;</a>
<a name="ln601">      }</a>
<a name="ln602">      ++counter;</a>
<a name="ln603">      if (PREDICT_FALSE(FLAGS_TEST_download_partial_wal_segments) &amp;&amp; counter &gt; 0) {</a>
<a name="ln604">        LOG(INFO) &lt;&lt; &quot;Flag TEST_download_partial_wal_segments set to true. &quot;</a>
<a name="ln605">                  &lt;&lt; &quot;Stopping WAL files download after one file has been downloaded.&quot;;</a>
<a name="ln606">        break;</a>
<a name="ln607">      }</a>
<a name="ln608">    }</a>
<a name="ln609">  } else {</a>
<a name="ln610">    int num_segments = wal_seqnos_.size();</a>
<a name="ln611">    LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Starting download of &quot; &lt;&lt; num_segments &lt;&lt; &quot; WAL segments...&quot;;</a>
<a name="ln612">    for (uint64_t seg_seqno : wal_seqnos_) {</a>
<a name="ln613">      UpdateStatusMessage(Substitute(&quot;Downloading WAL segment with seq. number $0 ($1/$2)&quot;,</a>
<a name="ln614">                                     seg_seqno, counter + 1, num_segments));</a>
<a name="ln615">      RETURN_NOT_OK(DownloadWAL(seg_seqno));</a>
<a name="ln616">      ++counter;</a>
<a name="ln617">    }</a>
<a name="ln618">  }</a>
<a name="ln619"> </a>
<a name="ln620">  if (FLAGS_bytes_remote_bootstrap_durable_write_mb != 0) {</a>
<a name="ln621">    // Persist directory so that recently downloaded files are accessible.</a>
<a name="ln622">    RETURN_NOT_OK_PREPEND(env().SyncDir(wal_table_top_dir),</a>
<a name="ln623">                          Substitute(&quot;Failed to sync WAL table directory $0&quot;, wal_table_top_dir));</a>
<a name="ln624">  }</a>
<a name="ln625"> </a>
<a name="ln626">  downloaded_wal_ = true;</a>
<a name="ln627">  return Status::OK();</a>
<a name="ln628">}</a>
<a name="ln629"> </a>
<a name="ln630">Status RemoteBootstrapClient::CreateTabletDirectories(const string&amp; db_dir, FsManager* fs) {</a>
<a name="ln631">  // Create the directory table-uuid first.</a>
<a name="ln632">  RETURN_NOT_OK_PREPEND(fs-&gt;CreateDirIfMissing(DirName(db_dir)),</a>
<a name="ln633">                        Substitute(&quot;Failed to create RocksDB table directory $0&quot;,</a>
<a name="ln634">                                   DirName(db_dir)));</a>
<a name="ln635"> </a>
<a name="ln636">  RETURN_NOT_OK_PREPEND(fs-&gt;CreateDirIfMissing(db_dir),</a>
<a name="ln637">                        Substitute(&quot;Failed to create RocksDB tablet directory $0&quot;,</a>
<a name="ln638">                                   db_dir));</a>
<a name="ln639"> </a>
<a name="ln640">  for (const auto&amp; component : components_) {</a>
<a name="ln641">    RETURN_NOT_OK(component-&gt;CreateDirectories(db_dir, fs));</a>
<a name="ln642">  }</a>
<a name="ln643"> </a>
<a name="ln644">  return Status::OK();</a>
<a name="ln645">}</a>
<a name="ln646"> </a>
<a name="ln647">Status RemoteBootstrapClient::DownloadRocksDBFiles() {</a>
<a name="ln648">  const auto&amp; rocksdb_dir = meta_-&gt;rocksdb_dir();</a>
<a name="ln649"> </a>
<a name="ln650">  RETURN_NOT_OK(CreateTabletDirectories(rocksdb_dir, meta_-&gt;fs_manager()));</a>
<a name="ln651"> </a>
<a name="ln652">  DataIdPB data_id;</a>
<a name="ln653">  data_id.set_type(DataIdPB::ROCKSDB_FILE);</a>
<a name="ln654">  for (auto const&amp; file_pb : new_superblock_.kv_store().rocksdb_files()) {</a>
<a name="ln655">    auto start = MonoTime::Now();</a>
<a name="ln656">    RETURN_NOT_OK(downloader_.DownloadFile(file_pb, rocksdb_dir, &amp;data_id));</a>
<a name="ln657">    auto elapsed = MonoTime::Now().GetDeltaSince(start);</a>
<a name="ln658">    LOG_WITH_PREFIX(INFO)</a>
<a name="ln659">        &lt;&lt; &quot;Downloaded file &quot; &lt;&lt; file_pb.name() &lt;&lt; &quot; of size &quot; &lt;&lt; file_pb.size_bytes()</a>
<a name="ln660">        &lt;&lt; &quot; in &quot; &lt;&lt; elapsed.ToSeconds() &lt;&lt; &quot; seconds&quot;;</a>
<a name="ln661">  }</a>
<a name="ln662"> </a>
<a name="ln663">  // To avoid adding new file type to remote bootstrap we move intents as subdir of regular DB.</a>
<a name="ln664">  auto intents_tmp_dir = JoinPathSegments(rocksdb_dir, tablet::kIntentsSubdir);</a>
<a name="ln665">  if (env().FileExists(intents_tmp_dir)) {</a>
<a name="ln666">    auto intents_dir = rocksdb_dir + tablet::kIntentsDBSuffix;</a>
<a name="ln667">    LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Moving intents DB: &quot; &lt;&lt; intents_tmp_dir &lt;&lt; &quot; =&gt; &quot; &lt;&lt; intents_dir;</a>
<a name="ln668">    RETURN_NOT_OK(env().RenameFile(intents_tmp_dir, intents_dir));</a>
<a name="ln669">  }</a>
<a name="ln670">  if (FLAGS_bytes_remote_bootstrap_durable_write_mb != 0) {</a>
<a name="ln671">    // Persist directory so that recently downloaded files are accessible.</a>
<a name="ln672">    RETURN_NOT_OK(env().SyncDir(rocksdb_dir));</a>
<a name="ln673">  }</a>
<a name="ln674">  downloaded_rocksdb_files_ = true;</a>
<a name="ln675">  return Status::OK();</a>
<a name="ln676">}</a>
<a name="ln677"> </a>
<a name="ln678">Status RemoteBootstrapClient::DownloadWAL(uint64_t wal_segment_seqno) {</a>
<a name="ln679">  VLOG_WITH_PREFIX(1) &lt;&lt; &quot;Downloading WAL segment with seqno &quot; &lt;&lt; wal_segment_seqno;</a>
<a name="ln680">  DataIdPB data_id;</a>
<a name="ln681">  data_id.set_type(DataIdPB::LOG_SEGMENT);</a>
<a name="ln682">  data_id.set_wal_segment_seqno(wal_segment_seqno);</a>
<a name="ln683">  const string dest_path = fs_manager().GetWalSegmentFilePath(meta_-&gt;wal_dir(), wal_segment_seqno);</a>
<a name="ln684">  const auto temp_dest_path = dest_path + &quot;.tmp&quot;;</a>
<a name="ln685">  bool ok = false;</a>
<a name="ln686">  auto se = ScopeExit([this, &amp;temp_dest_path, &amp;ok] {</a>
<a name="ln687">    if (!ok) {</a>
<a name="ln688">      WARN_NOT_OK(env().DeleteFile(temp_dest_path),</a>
<a name="ln689">                  &quot;Failed to delete temporary WAL segment&quot;);</a>
<a name="ln690">    }</a>
<a name="ln691">  });</a>
<a name="ln692"> </a>
<a name="ln693">  WritableFileOptions opts;</a>
<a name="ln694">  opts.sync_on_close = true;</a>
<a name="ln695">  std::unique_ptr&lt;WritableFile&gt; writer;</a>
<a name="ln696">  RETURN_NOT_OK_PREPEND(env().NewWritableFile(opts, temp_dest_path, &amp;writer),</a>
<a name="ln697">                        &quot;Unable to open file for writing&quot;);</a>
<a name="ln698"> </a>
<a name="ln699">  auto start = MonoTime::Now();</a>
<a name="ln700">  RETURN_NOT_OK_PREPEND(downloader_.DownloadFile(data_id, writer.get()),</a>
<a name="ln701">                        Substitute(&quot;Unable to download WAL segment with seq. number $0&quot;,</a>
<a name="ln702">                                   wal_segment_seqno));</a>
<a name="ln703">  RETURN_NOT_OK(env().RenameFile(temp_dest_path, dest_path));</a>
<a name="ln704">  auto elapsed = MonoTime::Now().GetDeltaSince(start);</a>
<a name="ln705">  LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Downloaded WAL segment with seq. number &quot; &lt;&lt; wal_segment_seqno</a>
<a name="ln706">                        &lt;&lt; &quot; of size &quot; &lt;&lt; writer-&gt;Size() &lt;&lt; &quot; in &quot; &lt;&lt; elapsed.ToSeconds()</a>
<a name="ln707">                        &lt;&lt; &quot; seconds&quot;;</a>
<a name="ln708">  ok = true;</a>
<a name="ln709"> </a>
<a name="ln710">  return Status::OK();</a>
<a name="ln711">}</a>
<a name="ln712"> </a>
<a name="ln713">Status RemoteBootstrapClient::WriteConsensusMetadata() {</a>
<a name="ln714">  // If we didn't find a previous consensus meta file, create one.</a>
<a name="ln715">  if (!cmeta_) {</a>
<a name="ln716">    std::unique_ptr&lt;ConsensusMetadata&gt; cmeta;</a>
<a name="ln717">    return ConsensusMetadata::Create(&amp;fs_manager(), tablet_id_, fs_manager().uuid(),</a>
<a name="ln718">                                     remote_committed_cstate_-&gt;config(),</a>
<a name="ln719">                                     remote_committed_cstate_-&gt;current_term(),</a>
<a name="ln720">                                     &amp;cmeta);</a>
<a name="ln721">  }</a>
<a name="ln722"> </a>
<a name="ln723">  // Otherwise, update the consensus metadata to reflect the config and term</a>
<a name="ln724">  // sent by the remote bootstrap source.</a>
<a name="ln725">  cmeta_-&gt;MergeCommittedConsensusStatePB(*remote_committed_cstate_);</a>
<a name="ln726">  RETURN_NOT_OK(cmeta_-&gt;Flush());</a>
<a name="ln727"> </a>
<a name="ln728">  if (FLAGS_remote_bootstrap_save_downloaded_metadata) {</a>
<a name="ln729">    string cmeta_path = fs_manager().GetConsensusMetadataPath(tablet_id_);</a>
<a name="ln730">    string cmeta_copy_path = Substitute(&quot;$0.copy.$1.tmp&quot;, cmeta_path, start_time_micros_);</a>
<a name="ln731">    RETURN_NOT_OK_PREPEND(CopyFile(Env::Default(), cmeta_path, cmeta_copy_path,</a>
<a name="ln732">                                   WritableFileOptions()),</a>
<a name="ln733">                          &quot;Unable to make copy of consensus metadata&quot;);</a>
<a name="ln734">  }</a>
<a name="ln735"> </a>
<a name="ln736">  return Status::OK();</a>
<a name="ln737">}</a>
<a name="ln738"> </a>
<a name="ln739">Env&amp; RemoteBootstrapClient::env() const {</a>
<a name="ln740">  return *fs_manager().env();</a>
<a name="ln741">}</a>
<a name="ln742"> </a>
<a name="ln743">const std::string&amp; RemoteBootstrapClient::permanent_uuid() const {</a>
<a name="ln744">  return fs_manager().uuid();</a>
<a name="ln745">}</a>
<a name="ln746"> </a>
<a name="ln747">} // namespace tserver</a>
<a name="ln748">} // namespace yb</a>

</code></pre>
<div class="balloon" rel="192"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="391"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="394"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="416"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="417"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="419"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="420"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="551"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="679"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="126"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: remote_tablet_data_state_.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
