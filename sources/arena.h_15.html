
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>arena.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Protocol Buffers - Google's data interchange format</a>
<a name="ln2">// Copyright 2008 Google Inc.  All rights reserved.</a>
<a name="ln3">// https://developers.google.com/protocol-buffers/</a>
<a name="ln4">//</a>
<a name="ln5">// Redistribution and use in source and binary forms, with or without</a>
<a name="ln6">// modification, are permitted provided that the following conditions are</a>
<a name="ln7">// met:</a>
<a name="ln8">//</a>
<a name="ln9">//     * Redistributions of source code must retain the above copyright</a>
<a name="ln10">// notice, this list of conditions and the following disclaimer.</a>
<a name="ln11">//     * Redistributions in binary form must reproduce the above</a>
<a name="ln12">// copyright notice, this list of conditions and the following disclaimer</a>
<a name="ln13">// in the documentation and/or other materials provided with the</a>
<a name="ln14">// distribution.</a>
<a name="ln15">//     * Neither the name of Google Inc. nor the names of its</a>
<a name="ln16">// contributors may be used to endorse or promote products derived from</a>
<a name="ln17">// this software without specific prior written permission.</a>
<a name="ln18">//</a>
<a name="ln19">// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</a>
<a name="ln20">// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</a>
<a name="ln21">// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</a>
<a name="ln22">// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</a>
<a name="ln23">// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</a>
<a name="ln24">// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</a>
<a name="ln25">// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</a>
<a name="ln26">// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</a>
<a name="ln27">// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</a>
<a name="ln28">// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</a>
<a name="ln29">// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</a>
<a name="ln30"> </a>
<a name="ln31">// This file defines an Arena allocator for better allocation performance.</a>
<a name="ln32"> </a>
<a name="ln33">#ifndef GOOGLE_PROTOBUF_ARENA_H__</a>
<a name="ln34">#define GOOGLE_PROTOBUF_ARENA_H__</a>
<a name="ln35"> </a>
<a name="ln36">#include &lt;limits&gt;</a>
<a name="ln37">#ifdef max</a>
<a name="ln38">#undef max  // Visual Studio defines this macro</a>
<a name="ln39">#endif</a>
<a name="ln40">#if LANG_CXX11</a>
<a name="ln41">#include &lt;google/protobuf/stubs/type_traits.h&gt;</a>
<a name="ln42">#endif</a>
<a name="ln43">#if defined(_MSC_VER) &amp;&amp; !_HAS_EXCEPTIONS</a>
<a name="ln44">// Work around bugs in MSVC &lt;typeinfo&gt; header when _HAS_EXCEPTIONS=0.</a>
<a name="ln45">#include &lt;exception&gt;</a>
<a name="ln46">#include &lt;typeinfo&gt;</a>
<a name="ln47">namespace std {</a>
<a name="ln48">using type_info = ::type_info;</a>
<a name="ln49">}</a>
<a name="ln50">#else</a>
<a name="ln51">#include &lt;typeinfo&gt;</a>
<a name="ln52">#endif</a>
<a name="ln53"> </a>
<a name="ln54">#include &lt;google/protobuf/arena_impl.h&gt;</a>
<a name="ln55">#include &lt;google/protobuf/stubs/port.h&gt;</a>
<a name="ln56"> </a>
<a name="ln57">namespace google {</a>
<a name="ln58">namespace protobuf {</a>
<a name="ln59"> </a>
<a name="ln60">class Arena;       // defined below</a>
<a name="ln61">class Message;     // message.h</a>
<a name="ln62"> </a>
<a name="ln63">namespace internal {</a>
<a name="ln64">struct ArenaStringPtr;  // arenastring.h</a>
<a name="ln65">class LazyField;   // lazy_field.h</a>
<a name="ln66"> </a>
<a name="ln67">template&lt;typename Type&gt;</a>
<a name="ln68">class GenericTypeHandler; // repeated_field.h</a>
<a name="ln69"> </a>
<a name="ln70">// Templated cleanup methods.</a>
<a name="ln71">template&lt;typename T&gt; void arena_destruct_object(void* object) {</a>
<a name="ln72">  reinterpret_cast&lt;T*&gt;(object)-&gt;~T();</a>
<a name="ln73">}</a>
<a name="ln74">template&lt;typename T&gt; void arena_delete_object(void* object) {</a>
<a name="ln75">  delete reinterpret_cast&lt;T*&gt;(object);</a>
<a name="ln76">}</a>
<a name="ln77">inline void arena_free(void* object, size_t size) {</a>
<a name="ln78">#if defined(__GXX_DELETE_WITH_SIZE__) || defined(__cpp_sized_deallocation)</a>
<a name="ln79">  ::operator delete(object, size);</a>
<a name="ln80">#else</a>
<a name="ln81">  (void)size;</a>
<a name="ln82">  ::operator delete(object);</a>
<a name="ln83">#endif</a>
<a name="ln84">}</a>
<a name="ln85"> </a>
<a name="ln86">}  // namespace internal</a>
<a name="ln87"> </a>
<a name="ln88">// ArenaOptions provides optional additional parameters to arena construction</a>
<a name="ln89">// that control its block-allocation behavior.</a>
<a name="ln90">struct ArenaOptions {</a>
<a name="ln91">  // This defines the size of the first block requested from the system malloc.</a>
<a name="ln92">  // Subsequent block sizes will increase in a geometric series up to a maximum.</a>
<a name="ln93">  size_t start_block_size;</a>
<a name="ln94"> </a>
<a name="ln95">  // This defines the maximum block size requested from system malloc (unless an</a>
<a name="ln96">  // individual arena allocation request occurs with a size larger than this</a>
<a name="ln97">  // maximum). Requested block sizes increase up to this value, then remain</a>
<a name="ln98">  // here.</a>
<a name="ln99">  size_t max_block_size;</a>
<a name="ln100"> </a>
<a name="ln101">  // An initial block of memory for the arena to use, or NULL for none. If</a>
<a name="ln102">  // provided, the block must live at least as long as the arena itself. The</a>
<a name="ln103">  // creator of the Arena retains ownership of the block after the Arena is</a>
<a name="ln104">  // destroyed.</a>
<a name="ln105">  char* initial_block;</a>
<a name="ln106"> </a>
<a name="ln107">  // The size of the initial block, if provided.</a>
<a name="ln108">  size_t initial_block_size;</a>
<a name="ln109"> </a>
<a name="ln110">  // A function pointer to an alloc method that returns memory blocks of size</a>
<a name="ln111">  // requested. By default, it contains a ptr to the malloc function.</a>
<a name="ln112">  //</a>
<a name="ln113">  // NOTE: block_alloc and dealloc functions are expected to behave like</a>
<a name="ln114">  // malloc and free, including Asan poisoning.</a>
<a name="ln115">  void* (*block_alloc)(size_t);</a>
<a name="ln116">  // A function pointer to a dealloc method that takes ownership of the blocks</a>
<a name="ln117">  // from the arena. By default, it contains a ptr to a wrapper function that</a>
<a name="ln118">  // calls free.</a>
<a name="ln119">  void (*block_dealloc)(void*, size_t);</a>
<a name="ln120">  // Hooks for adding external functionality such as user-specific metrics</a>
<a name="ln121">  // collection, specific debugging abilities, etc.</a>
<a name="ln122">  // Init hook may return a pointer to a cookie to be stored in the arena.</a>
<a name="ln123">  // reset and destruction hooks will then be called with the same cookie</a>
<a name="ln124">  // pointer. This allows us to save an external object per arena instance and</a>
<a name="ln125">  // use it on the other hooks (Note: It is just as legal for init to return</a>
<a name="ln126">  // NULL and not use the cookie feature).</a>
<a name="ln127">  // on_arena_reset and on_arena_destruction also receive the space used in</a>
<a name="ln128">  // the arena just before the reset.</a>
<a name="ln129">  void* (*on_arena_init)(Arena* arena);</a>
<a name="ln130">  void (*on_arena_reset)(Arena* arena, void* cookie, uint64 space_used);</a>
<a name="ln131">  void (*on_arena_destruction)(Arena* arena, void* cookie, uint64 space_used);</a>
<a name="ln132"> </a>
<a name="ln133">  // type_info is promised to be static - its lifetime extends to</a>
<a name="ln134">  // match program's lifetime (It is given by typeid operator).</a>
<a name="ln135">  // Note: typeid(void) will be passed as allocated_type every time we</a>
<a name="ln136">  // intentionally want to avoid monitoring an allocation. (i.e. internal</a>
<a name="ln137">  // allocations for managing the arena)</a>
<a name="ln138">  void (*on_arena_allocation)(const std::type_info* allocated_type,</a>
<a name="ln139">      uint64 alloc_size, void* cookie);</a>
<a name="ln140"> </a>
<a name="ln141">  ArenaOptions()</a>
<a name="ln142">      : start_block_size(kDefaultStartBlockSize),</a>
<a name="ln143">        max_block_size(kDefaultMaxBlockSize),</a>
<a name="ln144">        initial_block(NULL),</a>
<a name="ln145">        initial_block_size(0),</a>
<a name="ln146">        block_alloc(&amp;::operator new),</a>
<a name="ln147">        block_dealloc(&amp;internal::arena_free),</a>
<a name="ln148">        on_arena_init(NULL),</a>
<a name="ln149">        on_arena_reset(NULL),</a>
<a name="ln150">        on_arena_destruction(NULL),</a>
<a name="ln151">        on_arena_allocation(NULL) {}</a>
<a name="ln152"> </a>
<a name="ln153"> private:</a>
<a name="ln154">  // Constants define default starting block size and max block size for</a>
<a name="ln155">  // arena allocator behavior -- see descriptions above.</a>
<a name="ln156">  static const size_t kDefaultStartBlockSize = 256;</a>
<a name="ln157">  static const size_t kDefaultMaxBlockSize   = 8192;</a>
<a name="ln158">};</a>
<a name="ln159"> </a>
<a name="ln160">// Support for non-RTTI environments. (The metrics hooks API uses type</a>
<a name="ln161">// information.)</a>
<a name="ln162">#ifndef GOOGLE_PROTOBUF_NO_RTTI</a>
<a name="ln163">#define RTTI_TYPE_ID(type) (&amp;typeid(type))</a>
<a name="ln164">#else</a>
<a name="ln165">#define RTTI_TYPE_ID(type) (NULL)</a>
<a name="ln166">#endif</a>
<a name="ln167"> </a>
<a name="ln168">// Arena allocator. Arena allocation replaces ordinary (heap-based) allocation</a>
<a name="ln169">// with new/delete, and improves performance by aggregating allocations into</a>
<a name="ln170">// larger blocks and freeing allocations all at once. Protocol messages are</a>
<a name="ln171">// allocated on an arena by using Arena::CreateMessage&lt;T&gt;(Arena*), below, and</a>
<a name="ln172">// are automatically freed when the arena is destroyed.</a>
<a name="ln173">//</a>
<a name="ln174">// This is a thread-safe implementation: multiple threads may allocate from the</a>
<a name="ln175">// arena concurrently. Destruction is not thread-safe and the destructing</a>
<a name="ln176">// thread must synchronize with users of the arena first.</a>
<a name="ln177">//</a>
<a name="ln178">// An arena provides two allocation interfaces: CreateMessage&lt;T&gt;, which works</a>
<a name="ln179">// for arena-enabled proto2 message types as well as other types that satisfy</a>
<a name="ln180">// the appropriate protocol (described below), and Create&lt;T&gt;, which works for</a>
<a name="ln181">// any arbitrary type T. CreateMessage&lt;T&gt; is better when the type T supports it,</a>
<a name="ln182">// because this interface (i) passes the arena pointer to the created object so</a>
<a name="ln183">// that its sub-objects and internal allocations can use the arena too, and (ii)</a>
<a name="ln184">// elides the object's destructor call when possible. Create&lt;T&gt; does not place</a>
<a name="ln185">// any special requirements on the type T, and will invoke the object's</a>
<a name="ln186">// destructor when the arena is destroyed.</a>
<a name="ln187">//</a>
<a name="ln188">// The arena message allocation protocol, required by CreateMessage&lt;T&gt;, is as</a>
<a name="ln189">// follows:</a>
<a name="ln190">//</a>
<a name="ln191">// - The type T must have (at least) two constructors: a constructor with no</a>
<a name="ln192">//   arguments, called when a T is allocated on the heap; and a constructor with</a>
<a name="ln193">//   a google::protobuf::Arena* argument, called when a T is allocated on an arena. If the</a>
<a name="ln194">//   second constructor is called with a NULL arena pointer, it must be</a>
<a name="ln195">//   equivalent to invoking the first (no-argument) constructor.</a>
<a name="ln196">//</a>
<a name="ln197">// - The type T must have a particular type trait: a nested type</a>
<a name="ln198">//   |InternalArenaConstructable_|. This is usually a typedef to |void|. If no</a>
<a name="ln199">//   such type trait exists, then the instantiation CreateMessage&lt;T&gt; will fail</a>
<a name="ln200">//   to compile.</a>
<a name="ln201">//</a>
<a name="ln202">// - The type T *may* have the type trait |DestructorSkippable_|. If this type</a>
<a name="ln203">//   trait is present in the type, then its destructor will not be called if and</a>
<a name="ln204">//   only if it was passed a non-NULL arena pointer. If this type trait is not</a>
<a name="ln205">//   present on the type, then its destructor is always called when the</a>
<a name="ln206">//   containing arena is destroyed.</a>
<a name="ln207">//</a>
<a name="ln208">// - One- and two-user-argument forms of CreateMessage&lt;T&gt;() also exist that</a>
<a name="ln209">//   forward these constructor arguments to T's constructor: for example,</a>
<a name="ln210">//   CreateMessage&lt;T&gt;(Arena*, arg1, arg2) forwards to a constructor T(Arena*,</a>
<a name="ln211">//   arg1, arg2).</a>
<a name="ln212">//</a>
<a name="ln213">// This protocol is implemented by all arena-enabled proto2 message classes as</a>
<a name="ln214">// well as RepeatedPtrField.</a>
<a name="ln215">//</a>
<a name="ln216">// Do NOT subclass Arena. This class will be marked as final when C++11 is</a>
<a name="ln217">// enabled.</a>
<a name="ln218">class LIBPROTOBUF_EXPORT Arena {</a>
<a name="ln219"> public:</a>
<a name="ln220">  // Arena constructor taking custom options. See ArenaOptions below for</a>
<a name="ln221">  // descriptions of the options available.</a>
<a name="ln222">  explicit Arena(const ArenaOptions&amp; options) : impl_(options) {</a>
<a name="ln223">    Init(options);</a>
<a name="ln224">  }</a>
<a name="ln225"> </a>
<a name="ln226">  // Block overhead.  Use this as a guide for how much to over-allocate the</a>
<a name="ln227">  // initial block if you want an allocation of size N to fit inside it.</a>
<a name="ln228">  //</a>
<a name="ln229">  // WARNING: if you allocate multiple objects, it is difficult to guarantee</a>
<a name="ln230">  // that a series of allocations will fit in the initial block, especially if</a>
<a name="ln231">  // Arena changes its alignment guarantees in the future!</a>
<a name="ln232">  static const size_t kBlockOverhead = internal::ArenaImpl::kHeaderSize;</a>
<a name="ln233"> </a>
<a name="ln234">  // Default constructor with sensible default options, tuned for average</a>
<a name="ln235">  // use-cases.</a>
<a name="ln236">  Arena() : impl_(ArenaOptions()) { Init(ArenaOptions()); }</a>
<a name="ln237"> </a>
<a name="ln238">  ~Arena() {</a>
<a name="ln239">    if (on_arena_reset_ != NULL || on_arena_destruction_ != NULL) {</a>
<a name="ln240">      CallDestructorHooks();</a>
<a name="ln241">    }</a>
<a name="ln242">  }</a>
<a name="ln243"> </a>
<a name="ln244">  void Init(const ArenaOptions&amp; options) {</a>
<a name="ln245">    on_arena_allocation_ = options.on_arena_allocation;</a>
<a name="ln246">    on_arena_reset_ = options.on_arena_reset;</a>
<a name="ln247">    on_arena_destruction_ = options.on_arena_destruction;</a>
<a name="ln248">    // Call the initialization hook</a>
<a name="ln249">    if (options.on_arena_init != NULL) {</a>
<a name="ln250">      hooks_cookie_ = options.on_arena_init(this);</a>
<a name="ln251">    } else {</a>
<a name="ln252">      hooks_cookie_ = NULL;</a>
<a name="ln253">    }</a>
<a name="ln254">  }</a>
<a name="ln255"> </a>
<a name="ln256">  // API to create proto2 message objects on the arena. If the arena passed in</a>
<a name="ln257">  // is NULL, then a heap allocated object is returned. Type T must be a message</a>
<a name="ln258">  // defined in a .proto file with cc_enable_arenas set to true, otherwise a</a>
<a name="ln259">  // compilation error will occur.</a>
<a name="ln260">  //</a>
<a name="ln261">  // RepeatedField and RepeatedPtrField may also be instantiated directly on an</a>
<a name="ln262">  // arena with this method.</a>
<a name="ln263">  //</a>
<a name="ln264">  // This function also accepts any type T that satisfies the arena message</a>
<a name="ln265">  // allocation protocol, documented above.</a>
<a name="ln266">#if LANG_CXX11</a>
<a name="ln267">  template &lt;typename T, typename... Args&gt;</a>
<a name="ln268">  GOOGLE_PROTOBUF_ATTRIBUTE_ALWAYS_INLINE static T* CreateMessage(</a>
<a name="ln269">      ::google::protobuf::Arena* arena, Args&amp;&amp;... args) {</a>
<a name="ln270">    static_assert(</a>
<a name="ln271">        InternalHelper&lt;T&gt;::is_arena_constructable::value,</a>
<a name="ln272">        &quot;CreateMessage can only construct types that are ArenaConstructable&quot;);</a>
<a name="ln273">    if (arena == NULL) {</a>
<a name="ln274">      return new T(NULL, std::forward&lt;Args&gt;(args)...);</a>
<a name="ln275">    } else {</a>
<a name="ln276">      return arena-&gt;CreateMessageInternal&lt;T&gt;(std::forward&lt;Args&gt;(args)...);</a>
<a name="ln277">    }</a>
<a name="ln278">  }</a>
<a name="ln279">#endif</a>
<a name="ln280">  template &lt;typename T&gt; GOOGLE_PROTOBUF_ATTRIBUTE_ALWAYS_INLINE</a>
<a name="ln281">  static T* CreateMessage(::google::protobuf::Arena* arena) {</a>
<a name="ln282">#if LANG_CXX11</a>
<a name="ln283">    static_assert(</a>
<a name="ln284">        InternalHelper&lt;T&gt;::is_arena_constructable::value,</a>
<a name="ln285">        &quot;CreateMessage can only construct types that are ArenaConstructable&quot;);</a>
<a name="ln286">#endif</a>
<a name="ln287">    if (arena == NULL) {</a>
<a name="ln288">      return new T;</a>
<a name="ln289">    } else {</a>
<a name="ln290">      return arena-&gt;CreateMessageInternal&lt;T&gt;();</a>
<a name="ln291">    }</a>
<a name="ln292">  }</a>
<a name="ln293"> </a>
<a name="ln294">  // One-argument form of CreateMessage. This is useful for constructing objects</a>
<a name="ln295">  // that implement the arena message construction protocol described above but</a>
<a name="ln296">  // take additional constructor arguments.</a>
<a name="ln297">  template &lt;typename T, typename Arg&gt; GOOGLE_PROTOBUF_ATTRIBUTE_ALWAYS_INLINE</a>
<a name="ln298">  static T* CreateMessage(::google::protobuf::Arena* arena, const Arg&amp; arg) {</a>
<a name="ln299">#if LANG_CXX11</a>
<a name="ln300">    static_assert(</a>
<a name="ln301">        InternalHelper&lt;T&gt;::is_arena_constructable::value,</a>
<a name="ln302">        &quot;CreateMessage can only construct types that are ArenaConstructable&quot;);</a>
<a name="ln303">#endif</a>
<a name="ln304">    if (arena == NULL) {</a>
<a name="ln305">      return new T(NULL, arg);</a>
<a name="ln306">    } else {</a>
<a name="ln307">      return arena-&gt;CreateMessageInternal&lt;T&gt;(arg);</a>
<a name="ln308">    }</a>
<a name="ln309">  }</a>
<a name="ln310"> </a>
<a name="ln311">  // Two-argument form of CreateMessage. This is useful for constructing objects</a>
<a name="ln312">  // that implement the arena message construction protocol described above but</a>
<a name="ln313">  // take additional constructor arguments.</a>
<a name="ln314">  template &lt;typename T, typename Arg1, typename Arg2&gt;</a>
<a name="ln315">  GOOGLE_PROTOBUF_ATTRIBUTE_ALWAYS_INLINE</a>
<a name="ln316">  static T* CreateMessage(::google::protobuf::Arena* arena,</a>
<a name="ln317">                          const Arg1&amp; arg1,</a>
<a name="ln318">                          const Arg2&amp; arg2) {</a>
<a name="ln319">#if LANG_CXX11</a>
<a name="ln320">    static_assert(</a>
<a name="ln321">        InternalHelper&lt;T&gt;::is_arena_constructable::value,</a>
<a name="ln322">        &quot;CreateMessage can only construct types that are ArenaConstructable&quot;);</a>
<a name="ln323">#endif</a>
<a name="ln324">    if (arena == NULL) {</a>
<a name="ln325">      return new T(NULL, arg1, arg2);</a>
<a name="ln326">    } else {</a>
<a name="ln327">      return arena-&gt;CreateMessageInternal&lt;T&gt;(arg1, arg2);</a>
<a name="ln328">    }</a>
<a name="ln329">  }</a>
<a name="ln330"> </a>
<a name="ln331">  // API to create any objects on the arena. Note that only the object will</a>
<a name="ln332">  // be created on the arena; the underlying ptrs (in case of a proto2 message)</a>
<a name="ln333">  // will be still heap allocated. Proto messages should usually be allocated</a>
<a name="ln334">  // with CreateMessage&lt;T&gt;() instead.</a>
<a name="ln335">  //</a>
<a name="ln336">  // Note that even if T satisfies the arena message construction protocol</a>
<a name="ln337">  // (InternalArenaConstructable_ trait and optional DestructorSkippable_</a>
<a name="ln338">  // trait), as described above, this function does not follow the protocol;</a>
<a name="ln339">  // instead, it treats T as a black-box type, just as if it did not have these</a>
<a name="ln340">  // traits. Specifically, T's constructor arguments will always be only those</a>
<a name="ln341">  // passed to Create&lt;T&gt;() -- no additional arena pointer is implicitly added.</a>
<a name="ln342">  // Furthermore, the destructor will always be called at arena destruction time</a>
<a name="ln343">  // (unless the destructor is trivial). Hence, from T's point of view, it is as</a>
<a name="ln344">  // if the object were allocated on the heap (except that the underlying memory</a>
<a name="ln345">  // is obtained from the arena).</a>
<a name="ln346">#if LANG_CXX11</a>
<a name="ln347">  template &lt;typename T, typename... Args&gt;</a>
<a name="ln348">  GOOGLE_PROTOBUF_ATTRIBUTE_ALWAYS_INLINE</a>
<a name="ln349">  static T* Create(::google::protobuf::Arena* arena, Args&amp;&amp;... args) {</a>
<a name="ln350">    if (arena == NULL) {</a>
<a name="ln351">      return new T(std::forward&lt;Args&gt;(args)...);</a>
<a name="ln352">    } else {</a>
<a name="ln353">      return arena-&gt;CreateInternal&lt;T&gt;(google::protobuf::internal::has_trivial_destructor&lt;T&gt;::value,</a>
<a name="ln354">                                      std::forward&lt;Args&gt;(args)...);</a>
<a name="ln355">    }</a>
<a name="ln356">  }</a>
<a name="ln357">#endif</a>
<a name="ln358">  template &lt;typename T&gt; GOOGLE_PROTOBUF_ATTRIBUTE_ALWAYS_INLINE</a>
<a name="ln359">  static T* Create(::google::protobuf::Arena* arena) {</a>
<a name="ln360">    if (arena == NULL) {</a>
<a name="ln361">      return new T();</a>
<a name="ln362">    } else {</a>
<a name="ln363">      return arena-&gt;CreateInternal&lt;T&gt;(google::protobuf::internal::has_trivial_destructor&lt;T&gt;::value);</a>
<a name="ln364">    }</a>
<a name="ln365">  }</a>
<a name="ln366"> </a>
<a name="ln367">  // Version of the above with one constructor argument for the created object.</a>
<a name="ln368">  template &lt;typename T, typename Arg&gt; GOOGLE_PROTOBUF_ATTRIBUTE_ALWAYS_INLINE</a>
<a name="ln369">  static T* Create(::google::protobuf::Arena* arena, const Arg&amp; arg) {</a>
<a name="ln370">    if (arena == NULL) {</a>
<a name="ln371">      return new T(arg);</a>
<a name="ln372">    } else {</a>
<a name="ln373">      return arena-&gt;CreateInternal&lt;T&gt;(google::protobuf::internal::has_trivial_destructor&lt;T&gt;::value,</a>
<a name="ln374">                                      arg);</a>
<a name="ln375">    }</a>
<a name="ln376">  }</a>
<a name="ln377"> </a>
<a name="ln378">  // Version of the above with two constructor arguments for the created object.</a>
<a name="ln379">  template &lt;typename T, typename Arg1, typename Arg2&gt;</a>
<a name="ln380">  GOOGLE_PROTOBUF_ATTRIBUTE_ALWAYS_INLINE</a>
<a name="ln381">  static T* Create(::google::protobuf::Arena* arena, const Arg1&amp; arg1, const Arg2&amp; arg2) {</a>
<a name="ln382">    if (arena == NULL) {</a>
<a name="ln383">      return new T(arg1, arg2);</a>
<a name="ln384">    } else {</a>
<a name="ln385">      return arena-&gt;CreateInternal&lt;T&gt;(google::protobuf::internal::has_trivial_destructor&lt;T&gt;::value,</a>
<a name="ln386">                                      arg1, arg2);</a>
<a name="ln387">    }</a>
<a name="ln388">  }</a>
<a name="ln389"> </a>
<a name="ln390">  // Version of the above with three constructor arguments for the created</a>
<a name="ln391">  // object.</a>
<a name="ln392">  template &lt;typename T, typename Arg1, typename Arg2, typename Arg3&gt;</a>
<a name="ln393">  GOOGLE_PROTOBUF_ATTRIBUTE_ALWAYS_INLINE</a>
<a name="ln394">  static T* Create(::google::protobuf::Arena* arena,</a>
<a name="ln395">                   const Arg1&amp; arg1,</a>
<a name="ln396">                   const Arg2&amp; arg2,</a>
<a name="ln397">                   const Arg3&amp; arg3) {</a>
<a name="ln398">    if (arena == NULL) {</a>
<a name="ln399">      return new T(arg1, arg2, arg3);</a>
<a name="ln400">    } else {</a>
<a name="ln401">      return arena-&gt;CreateInternal&lt;T&gt;(google::protobuf::internal::has_trivial_destructor&lt;T&gt;::value,</a>
<a name="ln402">                                      arg1, arg2, arg3);</a>
<a name="ln403">    }</a>
<a name="ln404">  }</a>
<a name="ln405"> </a>
<a name="ln406">  // Version of the above with four constructor arguments for the created</a>
<a name="ln407">  // object.</a>
<a name="ln408">  template &lt;typename T, typename Arg1, typename Arg2, typename Arg3,</a>
<a name="ln409">            typename Arg4&gt;</a>
<a name="ln410">  GOOGLE_PROTOBUF_ATTRIBUTE_ALWAYS_INLINE</a>
<a name="ln411">  static T* Create(::google::protobuf::Arena* arena,</a>
<a name="ln412">                   const Arg1&amp; arg1, const Arg2&amp; arg2,</a>
<a name="ln413">                   const Arg3&amp; arg3, const Arg4&amp; arg4) {</a>
<a name="ln414">    if (arena == NULL) {</a>
<a name="ln415">      return new T(arg1, arg2, arg3, arg4);</a>
<a name="ln416">    } else {</a>
<a name="ln417">      return arena-&gt;CreateInternal&lt;T&gt;(google::protobuf::internal::has_trivial_destructor&lt;T&gt;::value,</a>
<a name="ln418">                                      arg1, arg2, arg3, arg4);</a>
<a name="ln419">    }</a>
<a name="ln420">  }</a>
<a name="ln421"> </a>
<a name="ln422">  // Version of the above with five constructor arguments for the created</a>
<a name="ln423">  // object.</a>
<a name="ln424">  template &lt;typename T, typename Arg1, typename Arg2, typename Arg3,</a>
<a name="ln425">            typename Arg4, typename Arg5&gt;</a>
<a name="ln426">  GOOGLE_PROTOBUF_ATTRIBUTE_ALWAYS_INLINE</a>
<a name="ln427">  static T* Create(::google::protobuf::Arena* arena,</a>
<a name="ln428">                   const Arg1&amp; arg1, const Arg2&amp; arg2,</a>
<a name="ln429">                   const Arg3&amp; arg3, const Arg4&amp; arg4,</a>
<a name="ln430">                   const Arg5&amp; arg5) {</a>
<a name="ln431">    if (arena == NULL) {</a>
<a name="ln432">      return new T(arg1, arg2, arg3, arg4, arg5);</a>
<a name="ln433">    } else {</a>
<a name="ln434">      return arena-&gt;CreateInternal&lt;T&gt;(google::protobuf::internal::has_trivial_destructor&lt;T&gt;::value,</a>
<a name="ln435">                                      arg1, arg2, arg3, arg4, arg5);</a>
<a name="ln436">    }</a>
<a name="ln437">  }</a>
<a name="ln438"> </a>
<a name="ln439">  // Version of the above with six constructor arguments for the created</a>
<a name="ln440">  // object.</a>
<a name="ln441">  template &lt;typename T, typename Arg1, typename Arg2, typename Arg3,</a>
<a name="ln442">            typename Arg4, typename Arg5, typename Arg6&gt;</a>
<a name="ln443">  GOOGLE_PROTOBUF_ATTRIBUTE_ALWAYS_INLINE</a>
<a name="ln444">  static T* Create(::google::protobuf::Arena* arena,</a>
<a name="ln445">                   const Arg1&amp; arg1, const Arg2&amp; arg2,</a>
<a name="ln446">                   const Arg3&amp; arg3, const Arg4&amp; arg4,</a>
<a name="ln447">                   const Arg5&amp; arg5, const Arg6&amp; arg6) {</a>
<a name="ln448">    if (arena == NULL) {</a>
<a name="ln449">      return new T(arg1, arg2, arg3, arg4, arg5, arg6);</a>
<a name="ln450">    } else {</a>
<a name="ln451">      return arena-&gt;CreateInternal&lt;T&gt;(google::protobuf::internal::has_trivial_destructor&lt;T&gt;::value,</a>
<a name="ln452">                                      arg1, arg2, arg3, arg4, arg5, arg6);</a>
<a name="ln453">    }</a>
<a name="ln454">  }</a>
<a name="ln455"> </a>
<a name="ln456">  // Version of the above with seven constructor arguments for the created</a>
<a name="ln457">  // object.</a>
<a name="ln458">  template &lt;typename T, typename Arg1, typename Arg2, typename Arg3,</a>
<a name="ln459">            typename Arg4, typename Arg5, typename Arg6, typename Arg7&gt;</a>
<a name="ln460">  GOOGLE_PROTOBUF_ATTRIBUTE_ALWAYS_INLINE</a>
<a name="ln461">  static T* Create(::google::protobuf::Arena* arena,</a>
<a name="ln462">                   const Arg1&amp; arg1, const Arg2&amp; arg2,</a>
<a name="ln463">                   const Arg3&amp; arg3, const Arg4&amp; arg4,</a>
<a name="ln464">                   const Arg5&amp; arg5, const Arg6&amp; arg6,</a>
<a name="ln465">                   const Arg7&amp; arg7) {</a>
<a name="ln466">    if (arena == NULL) {</a>
<a name="ln467">      return new T(arg1, arg2, arg3, arg4, arg5, arg6, arg7);</a>
<a name="ln468">    } else {</a>
<a name="ln469">      return arena-&gt;CreateInternal&lt;T&gt;(google::protobuf::internal::has_trivial_destructor&lt;T&gt;::value,</a>
<a name="ln470">                                      arg1, arg2, arg3, arg4, arg5, arg6, arg7);</a>
<a name="ln471">    }</a>
<a name="ln472">  }</a>
<a name="ln473"> </a>
<a name="ln474">  // Version of the above with eight constructor arguments for the created</a>
<a name="ln475">  // object.</a>
<a name="ln476">  template &lt;typename T, typename Arg1, typename Arg2, typename Arg3,</a>
<a name="ln477">            typename Arg4, typename Arg5, typename Arg6, typename Arg7,</a>
<a name="ln478">            typename Arg8&gt;</a>
<a name="ln479">  GOOGLE_PROTOBUF_ATTRIBUTE_ALWAYS_INLINE</a>
<a name="ln480">  static T* Create(::google::protobuf::Arena* arena,</a>
<a name="ln481">                   const Arg1&amp; arg1, const Arg2&amp; arg2,</a>
<a name="ln482">                   const Arg3&amp; arg3, const Arg4&amp; arg4,</a>
<a name="ln483">                   const Arg5&amp; arg5, const Arg6&amp; arg6,</a>
<a name="ln484">                   const Arg7&amp; arg7, const Arg8&amp; arg8) {</a>
<a name="ln485">    if (arena == NULL) {</a>
<a name="ln486">      return new T(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);</a>
<a name="ln487">    } else {</a>
<a name="ln488">      return arena-&gt;CreateInternal&lt;T&gt;(</a>
<a name="ln489">          google::protobuf::internal::has_trivial_destructor&lt;T&gt;::value,</a>
<a name="ln490">          arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);</a>
<a name="ln491">    }</a>
<a name="ln492">  }</a>
<a name="ln493"> </a>
<a name="ln494">  // Create an array of object type T on the arena *without* invoking the</a>
<a name="ln495">  // constructor of T. If `arena` is null, then the return value should be freed</a>
<a name="ln496">  // with `delete[] x;` (or `::operator delete[](x);`).</a>
<a name="ln497">  // To ensure safe uses, this function checks at compile time</a>
<a name="ln498">  // (when compiled as C++11) that T is trivially default-constructible and</a>
<a name="ln499">  // trivially destructible.</a>
<a name="ln500">  template &lt;typename T&gt; GOOGLE_PROTOBUF_ATTRIBUTE_ALWAYS_INLINE</a>
<a name="ln501">  static T* CreateArray(::google::protobuf::Arena* arena, size_t num_elements) {</a>
<a name="ln502">    GOOGLE_CHECK_LE(num_elements,</a>
<a name="ln503">             std::numeric_limits&lt;size_t&gt;::max() / sizeof(T))</a>
<a name="ln504">        &lt;&lt; &quot;Requested size is too large to fit into size_t.&quot;;</a>
<a name="ln505">    if (arena == NULL) {</a>
<a name="ln506">      return static_cast&lt;T*&gt;(::operator new[](num_elements * sizeof(T)));</a>
<a name="ln507">    } else {</a>
<a name="ln508">      return arena-&gt;CreateInternalRawArray&lt;T&gt;(num_elements);</a>
<a name="ln509">    }</a>
<a name="ln510">  }</a>
<a name="ln511"> </a>
<a name="ln512">  // Returns the total space allocated by the arena, which is the sum of the</a>
<a name="ln513">  // sizes of the underlying blocks. This method is relatively fast; a counter</a>
<a name="ln514">  // is kept as blocks are allocated.</a>
<a name="ln515">  uint64 SpaceAllocated() const { return impl_.SpaceAllocated(); }</a>
<a name="ln516">  // Returns the total space used by the arena. Similar to SpaceAllocated but</a>
<a name="ln517">  // does not include free space and block overhead. The total space returned</a>
<a name="ln518">  // may not include space used by other threads executing concurrently with</a>
<a name="ln519">  // the call to this method.</a>
<a name="ln520">  uint64 SpaceUsed() const { return impl_.SpaceUsed(); }</a>
<a name="ln521">  // DEPRECATED. Please use SpaceAllocated() and SpaceUsed().</a>
<a name="ln522">  //</a>
<a name="ln523">  // Combines SpaceAllocated and SpaceUsed. Returns a pair of</a>
<a name="ln524">  // &lt;space_allocated, space_used&gt;.</a>
<a name="ln525">  std::pair&lt;uint64, uint64&gt; SpaceAllocatedAndUsed() const {</a>
<a name="ln526">    return std::make_pair(SpaceAllocated(), SpaceUsed());</a>
<a name="ln527">  }</a>
<a name="ln528"> </a>
<a name="ln529">  // Frees all storage allocated by this arena after calling destructors</a>
<a name="ln530">  // registered with OwnDestructor() and freeing objects registered with Own().</a>
<a name="ln531">  // Any objects allocated on this arena are unusable after this call. It also</a>
<a name="ln532">  // returns the total space used by the arena which is the sums of the sizes</a>
<a name="ln533">  // of the allocated blocks. This method is not thread-safe.</a>
<a name="ln534">  GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE uint64 Reset() {</a>
<a name="ln535">    // Call the reset hook</a>
<a name="ln536">    if (on_arena_reset_ != NULL) {</a>
<a name="ln537">      on_arena_reset_(this, hooks_cookie_, impl_.SpaceAllocated());</a>
<a name="ln538">    }</a>
<a name="ln539">    return impl_.Reset();</a>
<a name="ln540">  }</a>
<a name="ln541"> </a>
<a name="ln542">  // Adds |object| to a list of heap-allocated objects to be freed with |delete|</a>
<a name="ln543">  // when the arena is destroyed or reset.</a>
<a name="ln544">  template &lt;typename T&gt; GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE</a>
<a name="ln545">  void Own(T* object) {</a>
<a name="ln546">    OwnInternal(object, google::protobuf::internal::is_convertible&lt;T*, ::google::protobuf::Message*&gt;());</a>
<a name="ln547">  }</a>
<a name="ln548"> </a>
<a name="ln549">  // Adds |object| to a list of objects whose destructors will be manually</a>
<a name="ln550">  // called when the arena is destroyed or reset. This differs from Own() in</a>
<a name="ln551">  // that it does not free the underlying memory with |delete|; hence, it is</a>
<a name="ln552">  // normally only used for objects that are placement-newed into</a>
<a name="ln553">  // arena-allocated memory.</a>
<a name="ln554">  template &lt;typename T&gt; GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE</a>
<a name="ln555">  void OwnDestructor(T* object) {</a>
<a name="ln556">    if (object != NULL) {</a>
<a name="ln557">      impl_.AddCleanup(object, &amp;internal::arena_destruct_object&lt;T&gt;);</a>
<a name="ln558">    }</a>
<a name="ln559">  }</a>
<a name="ln560"> </a>
<a name="ln561">  // Adds a custom member function on an object to the list of destructors that</a>
<a name="ln562">  // will be manually called when the arena is destroyed or reset. This differs</a>
<a name="ln563">  // from OwnDestructor() in that any member function may be specified, not only</a>
<a name="ln564">  // the class destructor.</a>
<a name="ln565">  GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE void OwnCustomDestructor(</a>
<a name="ln566">      void* object, void (*destruct)(void*)) {</a>
<a name="ln567">    impl_.AddCleanup(object, destruct);</a>
<a name="ln568">  }</a>
<a name="ln569"> </a>
<a name="ln570">  // Retrieves the arena associated with |value| if |value| is an arena-capable</a>
<a name="ln571">  // message, or NULL otherwise. This differs from value-&gt;GetArena() in that the</a>
<a name="ln572">  // latter is a virtual call, while this method is a templated call that</a>
<a name="ln573">  // resolves at compile-time.</a>
<a name="ln574">  template&lt;typename T&gt; GOOGLE_PROTOBUF_ATTRIBUTE_ALWAYS_INLINE</a>
<a name="ln575">  static ::google::protobuf::Arena* GetArena(const T* value) {</a>
<a name="ln576">    return GetArenaInternal(value, is_arena_constructable&lt;T&gt;());</a>
<a name="ln577">  }</a>
<a name="ln578"> </a>
<a name="ln579">  template &lt;typename T&gt;</a>
<a name="ln580">  class InternalHelper {</a>
<a name="ln581">    template &lt;typename U&gt;</a>
<a name="ln582">    static char DestructorSkippable(const typename U::DestructorSkippable_*);</a>
<a name="ln583">    template &lt;typename U&gt;</a>
<a name="ln584">    static double DestructorSkippable(...);</a>
<a name="ln585"> </a>
<a name="ln586">    typedef google::protobuf::internal::integral_constant&lt;</a>
<a name="ln587">        bool, sizeof(DestructorSkippable&lt;T&gt;(static_cast&lt;const T*&gt;(0))) ==</a>
<a name="ln588">                      sizeof(char) ||</a>
<a name="ln589">                  google::protobuf::internal::has_trivial_destructor&lt;T&gt;::value&gt;</a>
<a name="ln590">        is_destructor_skippable;</a>
<a name="ln591"> </a>
<a name="ln592">    template&lt;typename U&gt;</a>
<a name="ln593">    static char ArenaConstructable(</a>
<a name="ln594">        const typename U::InternalArenaConstructable_*);</a>
<a name="ln595">    template&lt;typename U&gt;</a>
<a name="ln596">    static double ArenaConstructable(...);</a>
<a name="ln597"> </a>
<a name="ln598">    typedef google::protobuf::internal::integral_constant&lt;bool, sizeof(ArenaConstructable&lt;T&gt;(</a>
<a name="ln599">                                              static_cast&lt;const T*&gt;(0))) ==</a>
<a name="ln600">                                              sizeof(char)&gt;</a>
<a name="ln601">        is_arena_constructable;</a>
<a name="ln602"> </a>
<a name="ln603">#if LANG_CXX11</a>
<a name="ln604">    template &lt;typename... Args&gt;</a>
<a name="ln605">    static T* Construct(void* ptr, Args&amp;&amp;... args) {</a>
<a name="ln606">      return new (ptr) T(std::forward&lt;Args&gt;(args)...);</a>
<a name="ln607">    }</a>
<a name="ln608">#else</a>
<a name="ln609">    template &lt;typename Arg1&gt;</a>
<a name="ln610">    static T* Construct(void* ptr, const Arg1&amp; arg1) {</a>
<a name="ln611">      return new (ptr) T(arg1);</a>
<a name="ln612">    }</a>
<a name="ln613">    template &lt;typename Arg1, typename Arg2&gt;</a>
<a name="ln614">    static T* Construct(void* ptr, const Arg1&amp; arg1, const Arg2&amp; arg2) {</a>
<a name="ln615">      return new (ptr) T(arg1, arg2);</a>
<a name="ln616">    }</a>
<a name="ln617">    template &lt;typename Arg1, typename Arg2, typename Arg3&gt;</a>
<a name="ln618">    static T* Construct(void* ptr, const Arg1&amp; arg1,</a>
<a name="ln619">                        const Arg2&amp; arg2, const Arg3&amp; arg3) {</a>
<a name="ln620">      return new (ptr) T(arg1, arg2, arg3);</a>
<a name="ln621">    }</a>
<a name="ln622">#endif  // LANG_CXX11</a>
<a name="ln623"> </a>
<a name="ln624">    static Arena* GetArena(const T* p) { return p-&gt;GetArenaNoVirtual(); }</a>
<a name="ln625"> </a>
<a name="ln626">    friend class Arena;</a>
<a name="ln627">  };</a>
<a name="ln628"> </a>
<a name="ln629">  // Helper typetrait that indicates support for arenas in a type T at compile</a>
<a name="ln630">  // time. This is public only to allow construction of higher-level templated</a>
<a name="ln631">  // utilities. is_arena_constructable&lt;T&gt;::value is true if the message type T</a>
<a name="ln632">  // has arena support enabled, and false otherwise.</a>
<a name="ln633">  //</a>
<a name="ln634">  // This is inside Arena because only Arena has the friend relationships</a>
<a name="ln635">  // necessary to see the underlying generated code traits.</a>
<a name="ln636">  template &lt;typename T&gt;</a>
<a name="ln637">  struct is_arena_constructable : InternalHelper&lt;T&gt;::is_arena_constructable {};</a>
<a name="ln638"> </a>
<a name="ln639"> private:</a>
<a name="ln640">  void CallDestructorHooks();</a>
<a name="ln641">  void OnArenaAllocation(const std::type_info* allocated_type, size_t n) const;</a>
<a name="ln642">  inline void AllocHook(const std::type_info* allocated_type, size_t n) const {</a>
<a name="ln643">    if (GOOGLE_PREDICT_FALSE(hooks_cookie_ != NULL)) {</a>
<a name="ln644">      OnArenaAllocation(allocated_type, n);</a>
<a name="ln645">    }</a>
<a name="ln646">  }</a>
<a name="ln647"> </a>
<a name="ln648">  // Allocate and also optionally call on_arena_allocation callback with the</a>
<a name="ln649">  // allocated type info when the hooks are in place in ArenaOptions and</a>
<a name="ln650">  // the cookie is not null.</a>
<a name="ln651">  template&lt;typename T&gt; GOOGLE_PROTOBUF_ATTRIBUTE_ALWAYS_INLINE</a>
<a name="ln652">  void* AllocateInternal(bool skip_explicit_ownership) {</a>
<a name="ln653">    const size_t n = internal::AlignUpTo8(sizeof(T));</a>
<a name="ln654">    AllocHook(RTTI_TYPE_ID(T), n);</a>
<a name="ln655">    // Monitor allocation if needed.</a>
<a name="ln656">    if (skip_explicit_ownership) {</a>
<a name="ln657">      return impl_.AllocateAligned(n);</a>
<a name="ln658">    } else {</a>
<a name="ln659">      return impl_.AllocateAlignedAndAddCleanup(</a>
<a name="ln660">          n, &amp;internal::arena_destruct_object&lt;T&gt;);</a>
<a name="ln661">    }</a>
<a name="ln662">  }</a>
<a name="ln663"> </a>
<a name="ln664">  // CreateMessage&lt;T&gt; requires that T supports arenas, but this private method</a>
<a name="ln665">  // works whether or not T supports arenas. These are not exposed to user code</a>
<a name="ln666">  // as it can cause confusing API usages, and end up having double free in</a>
<a name="ln667">  // user code. These are used only internally from LazyField and Repeated</a>
<a name="ln668">  // fields, since they are designed to work in all mode combinations.</a>
<a name="ln669">  template &lt;typename Msg&gt; GOOGLE_PROTOBUF_ATTRIBUTE_ALWAYS_INLINE</a>
<a name="ln670">  static Msg* CreateMaybeMessage(Arena* arena, google::protobuf::internal::true_type) {</a>
<a name="ln671">    return CreateMessage&lt;Msg&gt;(arena);</a>
<a name="ln672">  }</a>
<a name="ln673"> </a>
<a name="ln674">  template &lt;typename T&gt; GOOGLE_PROTOBUF_ATTRIBUTE_ALWAYS_INLINE</a>
<a name="ln675">  static T* CreateMaybeMessage(Arena* arena, google::protobuf::internal::false_type) {</a>
<a name="ln676">    return Create&lt;T&gt;(arena);</a>
<a name="ln677">  }</a>
<a name="ln678"> </a>
<a name="ln679">  template &lt;typename T&gt; GOOGLE_PROTOBUF_ATTRIBUTE_ALWAYS_INLINE</a>
<a name="ln680">  static T* CreateMaybeMessage(Arena* arena) {</a>
<a name="ln681">    return CreateMaybeMessage&lt;T&gt;(arena, is_arena_constructable&lt;T&gt;());</a>
<a name="ln682">  }</a>
<a name="ln683"> </a>
<a name="ln684">  // Just allocate the required size for the given type assuming the</a>
<a name="ln685">  // type has a trivial constructor.</a>
<a name="ln686">  template&lt;typename T&gt; GOOGLE_PROTOBUF_ATTRIBUTE_ALWAYS_INLINE</a>
<a name="ln687">  T* CreateInternalRawArray(size_t num_elements) {</a>
<a name="ln688">    GOOGLE_CHECK_LE(num_elements,</a>
<a name="ln689">             std::numeric_limits&lt;size_t&gt;::max() / sizeof(T))</a>
<a name="ln690">        &lt;&lt; &quot;Requested size is too large to fit into size_t.&quot;;</a>
<a name="ln691">    const size_t n = internal::AlignUpTo8(sizeof(T) * num_elements);</a>
<a name="ln692">    // Monitor allocation if needed.</a>
<a name="ln693">    AllocHook(RTTI_TYPE_ID(T), n);</a>
<a name="ln694">    return static_cast&lt;T*&gt;(impl_.AllocateAligned(n));</a>
<a name="ln695">  }</a>
<a name="ln696"> </a>
<a name="ln697">#if LANG_CXX11</a>
<a name="ln698">  template &lt;typename T, typename... Args&gt;</a>
<a name="ln699">  GOOGLE_PROTOBUF_ATTRIBUTE_ALWAYS_INLINE</a>
<a name="ln700">  T* CreateInternal(bool skip_explicit_ownership, Args&amp;&amp;... args) {</a>
<a name="ln701">    return new (AllocateInternal&lt;T&gt;(skip_explicit_ownership))</a>
<a name="ln702">        T(std::forward&lt;Args&gt;(args)...);</a>
<a name="ln703">  }</a>
<a name="ln704">#else</a>
<a name="ln705">  template &lt;typename T&gt; GOOGLE_PROTOBUF_ATTRIBUTE_ALWAYS_INLINE</a>
<a name="ln706">  T* CreateInternal(bool skip_explicit_ownership) {</a>
<a name="ln707">    return new (AllocateInternal&lt;T&gt;(skip_explicit_ownership)) T();</a>
<a name="ln708">  }</a>
<a name="ln709"> </a>
<a name="ln710">  template &lt;typename T, typename Arg&gt; GOOGLE_PROTOBUF_ATTRIBUTE_ALWAYS_INLINE</a>
<a name="ln711">  T* CreateInternal(bool skip_explicit_ownership, const Arg&amp; arg) {</a>
<a name="ln712">    return new (AllocateInternal&lt;T&gt;(skip_explicit_ownership)) T(arg);</a>
<a name="ln713">  }</a>
<a name="ln714"> </a>
<a name="ln715">  template &lt;typename T, typename Arg1, typename Arg2&gt;</a>
<a name="ln716">  GOOGLE_PROTOBUF_ATTRIBUTE_ALWAYS_INLINE</a>
<a name="ln717">  T* CreateInternal(bool skip_explicit_ownership,</a>
<a name="ln718">                    const Arg1&amp; arg1,</a>
<a name="ln719">                    const Arg2&amp; arg2) {</a>
<a name="ln720">    return new (AllocateInternal&lt;T&gt;(skip_explicit_ownership)) T(arg1, arg2);</a>
<a name="ln721">  }</a>
<a name="ln722"> </a>
<a name="ln723">  template &lt;typename T, typename Arg1, typename Arg2, typename Arg3&gt;</a>
<a name="ln724">  GOOGLE_PROTOBUF_ATTRIBUTE_ALWAYS_INLINE</a>
<a name="ln725">  T* CreateInternal(bool skip_explicit_ownership,</a>
<a name="ln726">                    const Arg1&amp; arg1,</a>
<a name="ln727">                    const Arg2&amp; arg2,</a>
<a name="ln728">                    const Arg3&amp; arg3) {</a>
<a name="ln729">    return new (AllocateInternal&lt;T&gt;(skip_explicit_ownership))</a>
<a name="ln730">        T(arg1, arg2, arg3);</a>
<a name="ln731">  }</a>
<a name="ln732"> </a>
<a name="ln733">  template &lt;typename T, typename Arg1, typename Arg2, typename Arg3,</a>
<a name="ln734">            typename Arg4&gt;</a>
<a name="ln735">  GOOGLE_PROTOBUF_ATTRIBUTE_ALWAYS_INLINE</a>
<a name="ln736">  T* CreateInternal(bool skip_explicit_ownership,</a>
<a name="ln737">                    const Arg1&amp; arg1,</a>
<a name="ln738">                    const Arg2&amp; arg2,</a>
<a name="ln739">                    const Arg3&amp; arg3,</a>
<a name="ln740">                    const Arg4&amp; arg4) {</a>
<a name="ln741">    return new (AllocateInternal&lt;T&gt;(skip_explicit_ownership))</a>
<a name="ln742">        T(arg1, arg2, arg3, arg4);</a>
<a name="ln743">  }</a>
<a name="ln744"> </a>
<a name="ln745">  template &lt;typename T, typename Arg1, typename Arg2, typename Arg3,</a>
<a name="ln746">            typename Arg4, typename Arg5&gt;</a>
<a name="ln747">  GOOGLE_PROTOBUF_ATTRIBUTE_ALWAYS_INLINE</a>
<a name="ln748">  T* CreateInternal(bool skip_explicit_ownership,</a>
<a name="ln749">                    const Arg1&amp; arg1,</a>
<a name="ln750">                    const Arg2&amp; arg2,</a>
<a name="ln751">                    const Arg3&amp; arg3,</a>
<a name="ln752">                    const Arg4&amp; arg4,</a>
<a name="ln753">                    const Arg5&amp; arg5) {</a>
<a name="ln754">    return new (AllocateInternal&lt;T&gt;(skip_explicit_ownership))</a>
<a name="ln755">        T(arg1, arg2, arg3, arg4, arg5);</a>
<a name="ln756">  }</a>
<a name="ln757"> </a>
<a name="ln758">  template &lt;typename T, typename Arg1, typename Arg2, typename Arg3,</a>
<a name="ln759">            typename Arg4, typename Arg5, typename Arg6&gt;</a>
<a name="ln760">  GOOGLE_PROTOBUF_ATTRIBUTE_ALWAYS_INLINE</a>
<a name="ln761">  T* CreateInternal(bool skip_explicit_ownership,</a>
<a name="ln762">                    const Arg1&amp; arg1,</a>
<a name="ln763">                    const Arg2&amp; arg2,</a>
<a name="ln764">                    const Arg3&amp; arg3,</a>
<a name="ln765">                    const Arg4&amp; arg4,</a>
<a name="ln766">                    const Arg5&amp; arg5,</a>
<a name="ln767">                    const Arg6&amp; arg6) {</a>
<a name="ln768">    return new (AllocateInternal&lt;T&gt;(skip_explicit_ownership))</a>
<a name="ln769">        T(arg1, arg2, arg3, arg4, arg5, arg6);</a>
<a name="ln770">  }</a>
<a name="ln771"> </a>
<a name="ln772">  template &lt;typename T, typename Arg1, typename Arg2, typename Arg3,</a>
<a name="ln773">            typename Arg4, typename Arg5, typename Arg6, typename Arg7&gt;</a>
<a name="ln774">  GOOGLE_PROTOBUF_ATTRIBUTE_ALWAYS_INLINE</a>
<a name="ln775">  T* CreateInternal(bool skip_explicit_ownership,</a>
<a name="ln776">                    const Arg1&amp; arg1,</a>
<a name="ln777">                    const Arg2&amp; arg2,</a>
<a name="ln778">                    const Arg3&amp; arg3,</a>
<a name="ln779">                    const Arg4&amp; arg4,</a>
<a name="ln780">                    const Arg5&amp; arg5,</a>
<a name="ln781">                    const Arg6&amp; arg6,</a>
<a name="ln782">                    const Arg7&amp; arg7) {</a>
<a name="ln783">    return new (AllocateInternal&lt;T&gt;(skip_explicit_ownership))</a>
<a name="ln784">        T(arg1, arg2, arg3, arg4, arg5, arg6, arg7);</a>
<a name="ln785">  }</a>
<a name="ln786"> </a>
<a name="ln787">  template &lt;typename T, typename Arg1, typename Arg2, typename Arg3,</a>
<a name="ln788">            typename Arg4, typename Arg5, typename Arg6, typename Arg7,</a>
<a name="ln789">            typename Arg8&gt;</a>
<a name="ln790">  GOOGLE_PROTOBUF_ATTRIBUTE_ALWAYS_INLINE</a>
<a name="ln791">  T* CreateInternal(bool skip_explicit_ownership,</a>
<a name="ln792">                    const Arg1&amp; arg1,</a>
<a name="ln793">                    const Arg2&amp; arg2,</a>
<a name="ln794">                    const Arg3&amp; arg3,</a>
<a name="ln795">                    const Arg4&amp; arg4,</a>
<a name="ln796">                    const Arg5&amp; arg5,</a>
<a name="ln797">                    const Arg6&amp; arg6,</a>
<a name="ln798">                    const Arg7&amp; arg7,</a>
<a name="ln799">                    const Arg8&amp; arg8) {</a>
<a name="ln800">    return new (AllocateInternal&lt;T&gt;(skip_explicit_ownership))</a>
<a name="ln801">        T(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);</a>
<a name="ln802">  }</a>
<a name="ln803">#endif</a>
<a name="ln804">#if LANG_CXX11</a>
<a name="ln805">  template &lt;typename T, typename... Args&gt;</a>
<a name="ln806">  GOOGLE_PROTOBUF_ATTRIBUTE_ALWAYS_INLINE T* CreateMessageInternal(</a>
<a name="ln807">      Args&amp;&amp;... args) {</a>
<a name="ln808">    return InternalHelper&lt;T&gt;::Construct(</a>
<a name="ln809">        AllocateInternal&lt;T&gt;(InternalHelper&lt;T&gt;::is_destructor_skippable::value),</a>
<a name="ln810">        this, std::forward&lt;Args&gt;(args)...);</a>
<a name="ln811">  }</a>
<a name="ln812">#endif</a>
<a name="ln813">  template &lt;typename T&gt;</a>
<a name="ln814">  GOOGLE_PROTOBUF_ATTRIBUTE_ALWAYS_INLINE T* CreateMessageInternal() {</a>
<a name="ln815">    return InternalHelper&lt;T&gt;::Construct(</a>
<a name="ln816">        AllocateInternal&lt;T&gt;(InternalHelper&lt;T&gt;::is_destructor_skippable::value),</a>
<a name="ln817">        this);</a>
<a name="ln818">  }</a>
<a name="ln819"> </a>
<a name="ln820">  template &lt;typename T, typename Arg&gt; GOOGLE_PROTOBUF_ATTRIBUTE_ALWAYS_INLINE</a>
<a name="ln821">  T* CreateMessageInternal(const Arg&amp; arg) {</a>
<a name="ln822">    return InternalHelper&lt;T&gt;::Construct(</a>
<a name="ln823">        AllocateInternal&lt;T&gt;(InternalHelper&lt;T&gt;::is_destructor_skippable::value),</a>
<a name="ln824">        this, arg);</a>
<a name="ln825">  }</a>
<a name="ln826"> </a>
<a name="ln827">  template &lt;typename T, typename Arg1, typename Arg2&gt;</a>
<a name="ln828">  GOOGLE_PROTOBUF_ATTRIBUTE_ALWAYS_INLINE</a>
<a name="ln829">  T* CreateMessageInternal(const Arg1&amp; arg1, const Arg2&amp; arg2) {</a>
<a name="ln830">    return InternalHelper&lt;T&gt;::Construct(</a>
<a name="ln831">        AllocateInternal&lt;T&gt;(InternalHelper&lt;T&gt;::is_destructor_skippable::value),</a>
<a name="ln832">        this, arg1, arg2);</a>
<a name="ln833">  }</a>
<a name="ln834"> </a>
<a name="ln835">  // CreateInArenaStorage is used to implement map field. Without it,</a>
<a name="ln836">  // google::protobuf::Map need to call generated message's protected arena constructor,</a>
<a name="ln837">  // which needs to declare google::protobuf::Map as friend of generated message.</a>
<a name="ln838">  template &lt;typename T&gt;</a>
<a name="ln839">  static void CreateInArenaStorage(T* ptr, Arena* arena) {</a>
<a name="ln840">    CreateInArenaStorageInternal(ptr, arena,</a>
<a name="ln841">                                 typename is_arena_constructable&lt;T&gt;::type());</a>
<a name="ln842">    RegisterDestructorInternal(</a>
<a name="ln843">        ptr, arena,</a>
<a name="ln844">        typename InternalHelper&lt;T&gt;::is_destructor_skippable::type());</a>
<a name="ln845">  }</a>
<a name="ln846"> </a>
<a name="ln847">  template &lt;typename T&gt;</a>
<a name="ln848">  static void CreateInArenaStorageInternal(</a>
<a name="ln849">      T* ptr, Arena* arena, google::protobuf::internal::true_type) {</a>
<a name="ln850">    InternalHelper&lt;T&gt;::Construct(ptr, arena);</a>
<a name="ln851">  }</a>
<a name="ln852">  template &lt;typename T&gt;</a>
<a name="ln853">  static void CreateInArenaStorageInternal(</a>
<a name="ln854">      T* ptr, Arena* /* arena */, google::protobuf::internal::false_type) {</a>
<a name="ln855">    new (ptr) T();</a>
<a name="ln856">  }</a>
<a name="ln857"> </a>
<a name="ln858">  template &lt;typename T&gt;</a>
<a name="ln859">  static void RegisterDestructorInternal(</a>
<a name="ln860">      T* /* ptr */, Arena* /* arena */, google::protobuf::internal::true_type) {}</a>
<a name="ln861">  template &lt;typename T&gt;</a>
<a name="ln862">  static void RegisterDestructorInternal(</a>
<a name="ln863">      T* ptr, Arena* arena, google::protobuf::internal::false_type) {</a>
<a name="ln864">    arena-&gt;OwnDestructor(ptr);</a>
<a name="ln865">  }</a>
<a name="ln866"> </a>
<a name="ln867">  // These implement Own(), which registers an object for deletion (destructor</a>
<a name="ln868">  // call and operator delete()). The second parameter has type 'true_type' if T</a>
<a name="ln869">  // is a subtype of ::google::protobuf::Message and 'false_type' otherwise. Collapsing</a>
<a name="ln870">  // all template instantiations to one for generic Message reduces code size,</a>
<a name="ln871">  // using the virtual destructor instead.</a>
<a name="ln872">  template&lt;typename T&gt; GOOGLE_PROTOBUF_ATTRIBUTE_ALWAYS_INLINE</a>
<a name="ln873">  void OwnInternal(T* object, google::protobuf::internal::true_type) {</a>
<a name="ln874">    if (object != NULL) {</a>
<a name="ln875">      impl_.AddCleanup(object,</a>
<a name="ln876">                       &amp;internal::arena_delete_object&lt; ::google::protobuf::Message&gt;);</a>
<a name="ln877">    }</a>
<a name="ln878">  }</a>
<a name="ln879">  template&lt;typename T&gt; GOOGLE_PROTOBUF_ATTRIBUTE_ALWAYS_INLINE</a>
<a name="ln880">  void OwnInternal(T* object, google::protobuf::internal::false_type) {</a>
<a name="ln881">    if (object != NULL) {</a>
<a name="ln882">      impl_.AddCleanup(object, &amp;internal::arena_delete_object&lt;T&gt;);</a>
<a name="ln883">    }</a>
<a name="ln884">  }</a>
<a name="ln885"> </a>
<a name="ln886">  // Implementation for GetArena(). Only message objects with</a>
<a name="ln887">  // InternalArenaConstructable_ tags can be associated with an arena, and such</a>
<a name="ln888">  // objects must implement a GetArenaNoVirtual() method.</a>
<a name="ln889">  template &lt;typename T&gt; GOOGLE_PROTOBUF_ATTRIBUTE_ALWAYS_INLINE</a>
<a name="ln890">  static ::google::protobuf::Arena* GetArenaInternal(</a>
<a name="ln891">      const T* value, google::protobuf::internal::true_type) {</a>
<a name="ln892">    return InternalHelper&lt;T&gt;::GetArena(value);</a>
<a name="ln893">  }</a>
<a name="ln894"> </a>
<a name="ln895">  template &lt;typename T&gt;</a>
<a name="ln896">  GOOGLE_PROTOBUF_ATTRIBUTE_ALWAYS_INLINE</a>
<a name="ln897">  static ::google::protobuf::Arena* GetArenaInternal(</a>
<a name="ln898">      const T* /* value */, google::protobuf::internal::false_type) {</a>
<a name="ln899">    return NULL;</a>
<a name="ln900">  }</a>
<a name="ln901"> </a>
<a name="ln902">  // For friends of arena.</a>
<a name="ln903">  void* AllocateAligned(size_t n) {</a>
<a name="ln904">    AllocHook(NULL, n);</a>
<a name="ln905">    return impl_.AllocateAligned(internal::AlignUpTo8(n));</a>
<a name="ln906">  }</a>
<a name="ln907"> </a>
<a name="ln908">  internal::ArenaImpl impl_;</a>
<a name="ln909"> </a>
<a name="ln910">  void* (*on_arena_init_)(Arena* arena);</a>
<a name="ln911">  void (*on_arena_allocation_)(const std::type_info* allocated_type,</a>
<a name="ln912">                               uint64 alloc_size, void* cookie);</a>
<a name="ln913">  void (*on_arena_reset_)(Arena* arena, void* cookie, uint64 space_used);</a>
<a name="ln914">  void (*on_arena_destruction_)(Arena* arena, void* cookie, uint64 space_used);</a>
<a name="ln915"> </a>
<a name="ln916">  // The arena may save a cookie it receives from the external on_init hook</a>
<a name="ln917">  // and then use it when calling the on_reset and on_destruction hooks.</a>
<a name="ln918">  void* hooks_cookie_;</a>
<a name="ln919"> </a>
<a name="ln920">  template &lt;typename Type&gt;</a>
<a name="ln921">  friend class ::google::protobuf::internal::GenericTypeHandler;</a>
<a name="ln922">  friend struct internal::ArenaStringPtr;  // For AllocateAligned.</a>
<a name="ln923">  friend class internal::LazyField;    // For CreateMaybeMessage.</a>
<a name="ln924">  template &lt;typename Key, typename T&gt;</a>
<a name="ln925">  friend class Map;</a>
<a name="ln926">};</a>
<a name="ln927"> </a>
<a name="ln928">// Defined above for supporting environments without RTTI.</a>
<a name="ln929">#undef RTTI_TYPE_ID</a>
<a name="ln930"> </a>
<a name="ln931">}  // namespace protobuf</a>
<a name="ln932"> </a>
<a name="ln933">}  // namespace google</a>
<a name="ln934">#endif  // GOOGLE_PROTOBUF_ARENA_H__</a>

</code></pre>
<div class="balloon" rel="222"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> It is possible that not all members of a class are initialized inside the constructor. Consider inspecting: on_arena_init_.</p></div>
<div class="balloon" rel="236"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> It is possible that not all members of a class are initialized inside the constructor. Consider inspecting: on_arena_init_.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
