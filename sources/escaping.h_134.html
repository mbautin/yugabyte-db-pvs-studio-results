
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>escaping.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Copyright 2006 Google Inc. All Rights Reserved.</a>
<a name="ln2">// Authors: Numerous. Principal maintainers are csilvers and zunger.</a>
<a name="ln3">//</a>
<a name="ln4">// This is a grab-bag file for string utilities involved in escaping and</a>
<a name="ln5">// unescaping strings in various ways. Who knew there were so many?</a>
<a name="ln6">//</a>
<a name="ln7">// NOTE: Although the functions declared here have been imported into</a>
<a name="ln8">// the global namespace, the using statements are slated for removal.</a>
<a name="ln9">// Do not refer to these symbols without properly namespace-qualifying</a>
<a name="ln10">// them with &quot;strings::&quot;. Of course you may also use &quot;using&quot; statements</a>
<a name="ln11">// within a .cc file.</a>
<a name="ln12">//</a>
<a name="ln13">// There are more escaping functions in:</a>
<a name="ln14">//   webutil/html/tagutils.h (Escaping strings for HTML, PRE, JavaScript, etc.)</a>
<a name="ln15">//   webutil/url/url.h (Escaping for URL's, both RFC-2396 and other methods)</a>
<a name="ln16">//   template/template_modifiers.h (All sorts of stuff)</a>
<a name="ln17">//   util/regex/re2/re2.h (Escaping for literals within regular expressions</a>
<a name="ln18">//                         - see RE2::QuoteMeta).</a>
<a name="ln19">// And probably many more places, as well.</a>
<a name="ln20"> </a>
<a name="ln21">//</a>
<a name="ln22">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln23">//</a>
<a name="ln24">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln25">//</a>
<a name="ln26">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln27">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln28">//</a>
<a name="ln29">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln30">//</a>
<a name="ln31">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln32">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln33">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln34">// under the License.</a>
<a name="ln35">//</a>
<a name="ln36">#ifndef STRINGS_ESCAPING_H_</a>
<a name="ln37">#define STRINGS_ESCAPING_H_</a>
<a name="ln38"> </a>
<a name="ln39">#include &lt;stddef.h&gt;</a>
<a name="ln40">#include &lt;string&gt;</a>
<a name="ln41">using std::string;</a>
<a name="ln42">#include &lt;vector&gt;</a>
<a name="ln43">using std::vector;</a>
<a name="ln44"> </a>
<a name="ln45">#include &lt;glog/logging.h&gt;</a>
<a name="ln46"> </a>
<a name="ln47">#include &quot;yb/gutil/logging-inl.h&quot;</a>
<a name="ln48">#include &quot;yb/gutil/strings/ascii_ctype.h&quot;</a>
<a name="ln49">#include &quot;yb/gutil/strings/charset.h&quot;</a>
<a name="ln50">#include &quot;yb/gutil/strings/stringpiece.h&quot;</a>
<a name="ln51"> </a>
<a name="ln52">namespace strings {</a>
<a name="ln53"> </a>
<a name="ln54">// ----------------------------------------------------------------------</a>
<a name="ln55">// EscapeStrForCSV()</a>
<a name="ln56">//    Escapes the quotes in 'src' by doubling them. This is necessary</a>
<a name="ln57">//    for generating CSV files (see SplitCSVLine).</a>
<a name="ln58">//    Returns the number of characters written into dest (not counting</a>
<a name="ln59">//    the \0) or -1 if there was insufficient space.</a>
<a name="ln60">//</a>
<a name="ln61">//    Example: [some &quot;string&quot; to test] --&gt; [some &quot;&quot;string&quot;&quot; to test]</a>
<a name="ln62">// ----------------------------------------------------------------------</a>
<a name="ln63">int EscapeStrForCSV(const char* src, char* dest, int dest_len);</a>
<a name="ln64"> </a>
<a name="ln65">// ----------------------------------------------------------------------</a>
<a name="ln66">// UnescapeCEscapeSequences()</a>
<a name="ln67">//    Copies &quot;source&quot; to &quot;dest&quot;, rewriting C-style escape sequences</a>
<a name="ln68">//    -- '\n', '\r', '\\', '\ooo', etc -- to their ASCII</a>
<a name="ln69">//    equivalents.  &quot;dest&quot; must be sufficiently large to hold all</a>
<a name="ln70">//    the characters in the rewritten string (i.e. at least as large</a>
<a name="ln71">//    as strlen(source) + 1 should be safe, since the replacements</a>
<a name="ln72">//    are always shorter than the original escaped sequences).  It's</a>
<a name="ln73">//    safe for source and dest to be the same.  RETURNS the length</a>
<a name="ln74">//    of dest.</a>
<a name="ln75">//</a>
<a name="ln76">//    It allows hex sequences \xhh, or generally \xhhhhh with an</a>
<a name="ln77">//    arbitrary number of hex digits, but all of them together must</a>
<a name="ln78">//    specify a value of a single byte (e.g. \x0045 is equivalent</a>
<a name="ln79">//    to \x45, and \x1234 is erroneous). If the value is too large,</a>
<a name="ln80">//    it is truncated to 8 bits and an error is set. This is also</a>
<a name="ln81">//    true of octal values that exceed 0xff.</a>
<a name="ln82">//</a>
<a name="ln83">//    It also allows escape sequences of the form \uhhhh (exactly four</a>
<a name="ln84">//    hex digits, upper or lower case) or \Uhhhhhhhh (exactly eight</a>
<a name="ln85">//    hex digits, upper or lower case) to specify a Unicode code</a>
<a name="ln86">//    point. The dest array will contain the UTF8-encoded version of</a>
<a name="ln87">//    that code-point (e.g., if source contains \u2019, then dest will</a>
<a name="ln88">//    contain the three bytes 0xE2, 0x80, and 0x99). For the inverse</a>
<a name="ln89">//    transformation, use UniLib::UTF8EscapeString</a>
<a name="ln90">//    (util/utf8/public/unilib.h), not CEscapeString.</a>
<a name="ln91">//</a>
<a name="ln92">//    Errors: In the first form of the call, errors are reported with</a>
<a name="ln93">//    LOG(ERROR). The same is true for the second form of the call if</a>
<a name="ln94">//    the pointer to the string vector is NULL; otherwise, error</a>
<a name="ln95">//    messages are stored in the vector. In either case, the effect on</a>
<a name="ln96">//    the dest array is not defined, but rest of the source will be</a>
<a name="ln97">//    processed.</a>
<a name="ln98">//</a>
<a name="ln99">//    *** DEPRECATED: Use CUnescape() in new code ***</a>
<a name="ln100">//    ----------------------------------------------------------------------</a>
<a name="ln101">int UnescapeCEscapeSequences(const char* source, char* dest);</a>
<a name="ln102">int UnescapeCEscapeSequences(const char* source, char* dest,</a>
<a name="ln103">                             vector&lt;string&gt;* errors);</a>
<a name="ln104"> </a>
<a name="ln105">// ----------------------------------------------------------------------</a>
<a name="ln106">// UnescapeCEscapeString()</a>
<a name="ln107">//    This does the same thing as UnescapeCEscapeSequences, but creates</a>
<a name="ln108">//    a new string. The caller does not need to worry about allocating</a>
<a name="ln109">//    a dest buffer. This should be used for non performance critical</a>
<a name="ln110">//    tasks such as printing debug messages. It is safe for src and dest</a>
<a name="ln111">//    to be the same.</a>
<a name="ln112">//</a>
<a name="ln113">//    The second call stores its errors in a supplied string vector.</a>
<a name="ln114">//    If the string vector pointer is NULL, it reports the errors with LOG().</a>
<a name="ln115">//</a>
<a name="ln116">//    In the first and second calls, the length of dest is returned. In the</a>
<a name="ln117">//    the third call, the new string is returned.</a>
<a name="ln118">//</a>
<a name="ln119">//    *** DEPRECATED: Use CUnescape() in new code ***</a>
<a name="ln120">// ----------------------------------------------------------------------</a>
<a name="ln121">int UnescapeCEscapeString(const string&amp; src, string* dest);</a>
<a name="ln122">int UnescapeCEscapeString(const string&amp; src, string* dest,</a>
<a name="ln123">                          vector&lt;string&gt;* errors);</a>
<a name="ln124">string UnescapeCEscapeString(const string&amp; src);</a>
<a name="ln125"> </a>
<a name="ln126">// ----------------------------------------------------------------------</a>
<a name="ln127">// CUnescape()</a>
<a name="ln128">//    Copies &quot;source&quot; to &quot;dest&quot;, rewriting C-style escape sequences</a>
<a name="ln129">//    -- '\n', '\r', '\\', '\ooo', etc -- to their ASCII</a>
<a name="ln130">//    equivalents.  &quot;dest&quot; must be sufficiently large to hold all</a>
<a name="ln131">//    the characters in the rewritten string (i.e. at least as large</a>
<a name="ln132">//    as source.size() should be safe, since the replacements</a>
<a name="ln133">//    are never longer than the original escaped sequences).  It's</a>
<a name="ln134">//    safe for source and dest to be the same.  RETURNS true if</a>
<a name="ln135">//    conversion was successful, false otherwise. Stores the size of</a>
<a name="ln136">//    the result in 'dest_len'.</a>
<a name="ln137">//</a>
<a name="ln138">//    It allows hex sequences \xhh, or generally \xhhhhh with an</a>
<a name="ln139">//    arbitrary number of hex digits, but all of them together must</a>
<a name="ln140">//    specify a value of a single byte (e.g. \x0045 is equivalent</a>
<a name="ln141">//    to \x45, and \x1234 is erroneous). If the value is too large,</a>
<a name="ln142">//    an error is set. This is also true of octal values that exceed 0xff.</a>
<a name="ln143">//</a>
<a name="ln144">//    It also allows escape sequences of the form \uhhhh (exactly four</a>
<a name="ln145">//    hex digits, upper or lower case) or \Uhhhhhhhh (exactly eight</a>
<a name="ln146">//    hex digits, upper or lower case) to specify a Unicode code</a>
<a name="ln147">//    point. The dest array will contain the UTF8-encoded version of</a>
<a name="ln148">//    that code-point (e.g., if source contains \u2019, then dest will</a>
<a name="ln149">//    contain the three bytes 0xE2, 0x80, and 0x99). For the inverse</a>
<a name="ln150">//    transformation, use UniLib::UTF8EscapeString</a>
<a name="ln151">//    (util/utf8/public/unilib.h), not CEscapeString.</a>
<a name="ln152">//</a>
<a name="ln153">//    Errors: Sets the description of the first encountered error in</a>
<a name="ln154">//    'error'. To disable error reporting, set 'error' to NULL.</a>
<a name="ln155">// ----------------------------------------------------------------------</a>
<a name="ln156">bool CUnescape(const GStringPiece&amp; source, char* dest, int* dest_len,</a>
<a name="ln157">               string* error);</a>
<a name="ln158"> </a>
<a name="ln159">bool CUnescape(const GStringPiece&amp; source, string* dest, string* error);</a>
<a name="ln160"> </a>
<a name="ln161">// A version with no error reporting.</a>
<a name="ln162">inline bool CUnescape(const GStringPiece&amp; source, string* dest) {</a>
<a name="ln163">  return CUnescape(source, dest, NULL);</a>
<a name="ln164">}</a>
<a name="ln165"> </a>
<a name="ln166">// ----------------------------------------------------------------------</a>
<a name="ln167">// CUnescapeForNullTerminatedString()</a>
<a name="ln168">//</a>
<a name="ln169">// This has the same behavior as CUnescape, except that each octal, hex,</a>
<a name="ln170">// or Unicode escape sequence that resolves to a null character ('\0')</a>
<a name="ln171">// is left in its original escaped form.  The result is a</a>
<a name="ln172">// display-formatted string that can be interpreted as a null-terminated</a>
<a name="ln173">// const char* and will not be cut short if it contains embedded null</a>
<a name="ln174">// characters.</a>
<a name="ln175">//</a>
<a name="ln176">// ----------------------------------------------------------------------</a>
<a name="ln177"> </a>
<a name="ln178">bool CUnescapeForNullTerminatedString(const GStringPiece&amp; source,</a>
<a name="ln179">                                      char* dest,</a>
<a name="ln180">                                      int* dest_len,</a>
<a name="ln181">                                      string* error);</a>
<a name="ln182"> </a>
<a name="ln183">bool CUnescapeForNullTerminatedString(const GStringPiece&amp; source,</a>
<a name="ln184">                                      string* dest,</a>
<a name="ln185">                                      string* error);</a>
<a name="ln186"> </a>
<a name="ln187">// A version with no error reporting.</a>
<a name="ln188">inline bool CUnescapeForNullTerminatedString(const GStringPiece&amp; source,</a>
<a name="ln189">                                             string* dest) {</a>
<a name="ln190">  return CUnescapeForNullTerminatedString(source, dest, NULL);</a>
<a name="ln191">}</a>
<a name="ln192"> </a>
<a name="ln193">// ----------------------------------------------------------------------</a>
<a name="ln194">// CEscapeString()</a>
<a name="ln195">// CHexEscapeString()</a>
<a name="ln196">// Utf8SafeCEscapeString()</a>
<a name="ln197">// Utf8SafeCHexEscapeString()</a>
<a name="ln198">//    Copies 'src' to 'dest', escaping dangerous characters using</a>
<a name="ln199">//    C-style escape sequences. This is very useful for preparing query</a>
<a name="ln200">//    flags. 'src' and 'dest' should not overlap. The 'Hex' version uses</a>
<a name="ln201">//    hexadecimal rather than octal sequences. The 'Utf8Safe' version</a>
<a name="ln202">//    doesn't touch UTF-8 bytes.</a>
<a name="ln203">//    Returns the number of bytes written to 'dest' (not including the \0)</a>
<a name="ln204">//    or -1 if there was insufficient space.</a>
<a name="ln205">//</a>
<a name="ln206">//    Currently only \n, \r, \t, &quot;, ', \ and !ascii_isprint() chars are escaped.</a>
<a name="ln207">// ----------------------------------------------------------------------</a>
<a name="ln208">int CEscapeString(const char* src, int src_len, char* dest, int dest_len);</a>
<a name="ln209">int CHexEscapeString(const char* src, int src_len, char* dest, int dest_len);</a>
<a name="ln210">int Utf8SafeCEscapeString(const char* src, int src_len, char* dest,</a>
<a name="ln211">                          int dest_len);</a>
<a name="ln212">int Utf8SafeCHexEscapeString(const char* src, int src_len, char* dest,</a>
<a name="ln213">                             int dest_len);</a>
<a name="ln214"> </a>
<a name="ln215">// ----------------------------------------------------------------------</a>
<a name="ln216">// CEscape()</a>
<a name="ln217">// CHexEscape()</a>
<a name="ln218">// Utf8SafeCEscape()</a>
<a name="ln219">// Utf8SafeCHexEscape()</a>
<a name="ln220">//    More convenient form of CEscapeString: returns result as a &quot;string&quot;.</a>
<a name="ln221">//    This version is slower than CEscapeString() because it does more</a>
<a name="ln222">//    allocation.  However, it is much more convenient to use in</a>
<a name="ln223">//    non-speed-critical code like logging messages etc.</a>
<a name="ln224">// ----------------------------------------------------------------------</a>
<a name="ln225">string CEscape(const GStringPiece&amp; src);</a>
<a name="ln226">string CHexEscape(const GStringPiece&amp; src);</a>
<a name="ln227">string Utf8SafeCEscape(const GStringPiece&amp; src);</a>
<a name="ln228">string Utf8SafeCHexEscape(const GStringPiece&amp; src);</a>
<a name="ln229"> </a>
<a name="ln230">// ----------------------------------------------------------------------</a>
<a name="ln231">// BackslashEscape()</a>
<a name="ln232">//    Given a string and a list of characters to escape, replace any</a>
<a name="ln233">//    instance of one of those characters with \ + that character. For</a>
<a name="ln234">//    example, when exporting maps to /varz, label values need to have</a>
<a name="ln235">//    all dots escaped. Appends the result to dest.</a>
<a name="ln236">// BackslashUnescape()</a>
<a name="ln237">//    Replace \ + any of the indicated &quot;unescape me&quot; characters with just</a>
<a name="ln238">//    that character. Appends the result to dest.</a>
<a name="ln239">//</a>
<a name="ln240">//    IMPORTANT:</a>
<a name="ln241">//    This function does not escape \ by default, so if you do not include</a>
<a name="ln242">//    it in the chars to escape you will most certainly get an undesirable</a>
<a name="ln243">//    result. That is, it won't be a reversible operation:</a>
<a name="ln244">//      string src = &quot;foo\\:bar&quot;;</a>
<a name="ln245">//      BackslashUnescape(BackslashEscape(src, &quot;:&quot;), &quot;:&quot;) == &quot;foo\\\\:bar&quot;</a>
<a name="ln246">//    On the other hand, for all strings &quot;src&quot;, the following is true:</a>
<a name="ln247">//      BackslashUnescape(BackslashEscape(src, &quot;:\\&quot;), &quot;:\\&quot;) == src</a>
<a name="ln248">// ----------------------------------------------------------------------</a>
<a name="ln249">void BackslashEscape(const GStringPiece&amp; src,</a>
<a name="ln250">                     const strings::CharSet&amp; to_escape,</a>
<a name="ln251">                     string* dest);</a>
<a name="ln252">void BackslashUnescape(const GStringPiece&amp; src,</a>
<a name="ln253">                       const strings::CharSet&amp; to_unescape,</a>
<a name="ln254">                       string* dest);</a>
<a name="ln255"> </a>
<a name="ln256">inline string BackslashEscape(const GStringPiece&amp; src,</a>
<a name="ln257">                              const strings::CharSet&amp; to_escape) {</a>
<a name="ln258">  string s;</a>
<a name="ln259">  BackslashEscape(src, to_escape, &amp;s);</a>
<a name="ln260">  return s;</a>
<a name="ln261">}</a>
<a name="ln262"> </a>
<a name="ln263">inline string BackslashUnescape(const GStringPiece&amp; src,</a>
<a name="ln264">                                const strings::CharSet&amp; to_unescape) {</a>
<a name="ln265">  string s;</a>
<a name="ln266">  BackslashUnescape(src, to_unescape, &amp;s);</a>
<a name="ln267">  return s;</a>
<a name="ln268">}</a>
<a name="ln269"> </a>
<a name="ln270">// ----------------------------------------------------------------------</a>
<a name="ln271">// QuotedPrintableUnescape()</a>
<a name="ln272">//    Check out http://www.cis.ohio-state.edu/htbin/rfc/rfc2045.html for</a>
<a name="ln273">//    more details, only briefly implemented. But from the web...</a>
<a name="ln274">//    Quoted-printable is an encoding method defined in the MIME</a>
<a name="ln275">//    standard. It is used primarily to encode 8-bit text (such as text</a>
<a name="ln276">//    that includes foreign characters) into 7-bit US ASCII, creating a</a>
<a name="ln277">//    document that is mostly readable by humans, even in its encoded</a>
<a name="ln278">//    form. All MIME compliant applications can decode quoted-printable</a>
<a name="ln279">//    text, though they may not necessarily be able to properly display the</a>
<a name="ln280">//    document as it was originally intended. As quoted-printable encoding</a>
<a name="ln281">//    is implemented most commonly, printable ASCII characters (values 33</a>
<a name="ln282">//    through 126, excluding 61), tabs and spaces that do not appear at the</a>
<a name="ln283">//    end of lines, and end-of-line characters are not encoded. Other</a>
<a name="ln284">//    characters are represented by an equal sign (=) immediately followed</a>
<a name="ln285">//    by that character's hexadecimal value. Lines that are longer than 76</a>
<a name="ln286">//    characters are shortened by line breaks, with the equal sign marking</a>
<a name="ln287">//    where the breaks occurred.</a>
<a name="ln288">//</a>
<a name="ln289">//    Note that QuotedPrintableUnescape is different from 'Q'-encoding as</a>
<a name="ln290">//    defined in rfc2047. In particular, This does not treat '_'s as spaces.</a>
<a name="ln291">//</a>
<a name="ln292">//    See QEncodingUnescape().</a>
<a name="ln293">//</a>
<a name="ln294">//    Copies &quot;src&quot; to &quot;dest&quot;, rewriting quoted printable escape sequences</a>
<a name="ln295">//    =XX to their ASCII equivalents. src is not null terminated, instead</a>
<a name="ln296">//    specify len. I recommend that slen&lt;szdest, but we honor szdest</a>
<a name="ln297">//    anyway.</a>
<a name="ln298">//    RETURNS the length of dest.</a>
<a name="ln299">// ----------------------------------------------------------------------</a>
<a name="ln300">int QuotedPrintableUnescape(const char* src, int slen, char* dest, int szdest);</a>
<a name="ln301"> </a>
<a name="ln302">// ----------------------------------------------------------------------</a>
<a name="ln303">// QEncodingUnescape()</a>
<a name="ln304">//    This is very similar to QuotedPrintableUnescape except that we convert</a>
<a name="ln305">//    '_'s into spaces. (See RFC 2047)</a>
<a name="ln306">//    http://www.faqs.org/rfcs/rfc2047.html.</a>
<a name="ln307">//</a>
<a name="ln308">//    Copies &quot;src&quot; to &quot;dest&quot;, rewriting q-encoding escape sequences</a>
<a name="ln309">//    =XX to their ASCII equivalents. src is not null terminated, instead</a>
<a name="ln310">//    specify len. I recommend that slen&lt;szdest, but we honour szdest</a>
<a name="ln311">//    anyway.</a>
<a name="ln312">//    RETURNS the length of dest.</a>
<a name="ln313">// ----------------------------------------------------------------------</a>
<a name="ln314">int QEncodingUnescape(const char* src, int slen, char* dest, int szdest);</a>
<a name="ln315"> </a>
<a name="ln316">// ----------------------------------------------------------------------</a>
<a name="ln317">// Base64Unescape()</a>
<a name="ln318">// WebSafeBase64Unescape()</a>
<a name="ln319">//    Copies &quot;src&quot; to &quot;dest&quot;, where src is in base64 and is written to its</a>
<a name="ln320">//    ASCII equivalents. src is not null terminated, instead specify len.</a>
<a name="ln321">//    I recommend that slen&lt;szdest, but we honor szdest anyway.</a>
<a name="ln322">//    RETURNS the length of dest, or -1 if src contains invalid chars.</a>
<a name="ln323">//    The WebSafe variation use '-' instead of '+' and '_' instead of '/'.</a>
<a name="ln324">//    The variations that store into a string clear the string first, and</a>
<a name="ln325">//    return false (with dest empty) if src contains invalid chars; for</a>
<a name="ln326">//    these versions src and dest must be different strings.</a>
<a name="ln327">// ----------------------------------------------------------------------</a>
<a name="ln328">int Base64Unescape(const char* src, int slen, char* dest, int szdest);</a>
<a name="ln329">bool Base64Unescape(const char* src, int slen, string* dest);</a>
<a name="ln330">inline bool Base64Unescape(const string&amp; src, string* dest) {</a>
<a name="ln331">  return Base64Unescape(src.data(), src.size(), dest);</a>
<a name="ln332">}</a>
<a name="ln333"> </a>
<a name="ln334">int WebSafeBase64Unescape(const char* src, int slen, char* dest, int szdest);</a>
<a name="ln335">bool WebSafeBase64Unescape(const char* src, int slen, string* dest);</a>
<a name="ln336">inline bool WebSafeBase64Unescape(const string&amp; src, string* dest) {</a>
<a name="ln337">  return WebSafeBase64Unescape(src.data(), src.size(), dest);</a>
<a name="ln338">}</a>
<a name="ln339"> </a>
<a name="ln340">// Return the length to use for the output buffer given to the base64 escape</a>
<a name="ln341">// routines. Make sure to use the same value for do_padding in both.</a>
<a name="ln342">// This function may return incorrect results if given input_len values that</a>
<a name="ln343">// are extremely high, which should happen rarely.</a>
<a name="ln344">int CalculateBase64EscapedLen(int input_len, bool do_padding);</a>
<a name="ln345">// Use this version when calling Base64Escape without a do_padding arg.</a>
<a name="ln346">int CalculateBase64EscapedLen(int input_len);</a>
<a name="ln347"> </a>
<a name="ln348">// ----------------------------------------------------------------------</a>
<a name="ln349">// Base64Escape()</a>
<a name="ln350">// WebSafeBase64Escape()</a>
<a name="ln351">//    Encode &quot;src&quot; to &quot;dest&quot; using base64 encoding.</a>
<a name="ln352">//    src is not null terminated, instead specify len.</a>
<a name="ln353">//    'dest' should have at least CalculateBase64EscapedLen() length.</a>
<a name="ln354">//    RETURNS the length of dest.</a>
<a name="ln355">//    The WebSafe variation use '-' instead of '+' and '_' instead of '/'</a>
<a name="ln356">//    so that we can place the out in the URL or cookies without having</a>
<a name="ln357">//    to escape them.  It also has an extra parameter &quot;do_padding&quot;,</a>
<a name="ln358">//    which when set to false will prevent padding with &quot;=&quot;.</a>
<a name="ln359">// ----------------------------------------------------------------------</a>
<a name="ln360">int Base64Escape(const unsigned char* src, int slen, char* dest, int szdest);</a>
<a name="ln361">int WebSafeBase64Escape(const unsigned char* src, int slen, char* dest,</a>
<a name="ln362">                        int szdest, bool do_padding);</a>
<a name="ln363">// Encode src into dest with padding.</a>
<a name="ln364">void Base64Escape(const string&amp; src, string* dest);</a>
<a name="ln365">// Encode src into dest web-safely without padding.</a>
<a name="ln366">void WebSafeBase64Escape(const string&amp; src, string* dest);</a>
<a name="ln367">// Encode src into dest web-safely with padding.</a>
<a name="ln368">void WebSafeBase64EscapeWithPadding(const string&amp; src, string* dest);</a>
<a name="ln369"> </a>
<a name="ln370">void Base64Escape(const unsigned char* src, int szsrc,</a>
<a name="ln371">                  string* dest, bool do_padding);</a>
<a name="ln372">void WebSafeBase64Escape(const unsigned char* src, int szsrc,</a>
<a name="ln373">                         string* dest, bool do_padding);</a>
<a name="ln374"> </a>
<a name="ln375">// ----------------------------------------------------------------------</a>
<a name="ln376">// Base32Unescape()</a>
<a name="ln377">//    Copies &quot;src&quot; to &quot;dest&quot;, where src is in base32 and is written to its</a>
<a name="ln378">//    ASCII equivalents. src is not null terminated, instead specify len.</a>
<a name="ln379">//    RETURNS the length of dest, or -1 if src contains invalid chars.</a>
<a name="ln380">// ----------------------------------------------------------------------</a>
<a name="ln381">int Base32Unescape(const char* src, int slen, char* dest, int szdest);</a>
<a name="ln382">bool Base32Unescape(const char* src, int slen, string* dest);</a>
<a name="ln383">inline bool Base32Unescape(const string&amp; src, string* dest) {</a>
<a name="ln384">  return Base32Unescape(src.data(), src.size(), dest);</a>
<a name="ln385">}</a>
<a name="ln386"> </a>
<a name="ln387">// ----------------------------------------------------------------------</a>
<a name="ln388">// Base32Escape()</a>
<a name="ln389">//    Encode &quot;src&quot; to &quot;dest&quot; using base32 encoding.</a>
<a name="ln390">//    src is not null terminated, instead specify len.</a>
<a name="ln391">//    'dest' should have at least CalculateBase32EscapedLen() length.</a>
<a name="ln392">//    RETURNS the length of dest. RETURNS 0 if szsrc is zero, or szdest is</a>
<a name="ln393">//    too small to fit the fully encoded result.  'dest' is padded with '='.</a>
<a name="ln394">//</a>
<a name="ln395">//    Note that this is &quot;Base 32 Encoding&quot; from RFC 4648 section 6.</a>
<a name="ln396">// ----------------------------------------------------------------------</a>
<a name="ln397">int Base32Escape(const unsigned char* src, size_t szsrc,</a>
<a name="ln398">                 char* dest, size_t szdest);</a>
<a name="ln399">bool Base32Escape(const string&amp; src, string* dest);</a>
<a name="ln400"> </a>
<a name="ln401">// ----------------------------------------------------------------------</a>
<a name="ln402">// Base32HexEscape()</a>
<a name="ln403">//    Encode &quot;src&quot; to &quot;dest&quot; using base32hex encoding.</a>
<a name="ln404">//    src is not null terminated, instead specify len.</a>
<a name="ln405">//    'dest' should have at least CalculateBase32EscapedLen() length.</a>
<a name="ln406">//    RETURNS the length of dest. RETURNS 0 if szsrc is zero, or szdest is</a>
<a name="ln407">//    too small to fit the fully encoded result.  'dest' is padded with '='.</a>
<a name="ln408">//</a>
<a name="ln409">//    Note that this is &quot;Base 32 Encoding with Extended Hex Alphabet&quot;</a>
<a name="ln410">//    from RFC 4648 section 7.</a>
<a name="ln411">// ----------------------------------------------------------------------</a>
<a name="ln412">int Base32HexEscape(const unsigned char* src, size_t szsrc,</a>
<a name="ln413">                    char* dest, size_t szdest);</a>
<a name="ln414">bool Base32HexEscape(const string&amp; src, string* dest);</a>
<a name="ln415"> </a>
<a name="ln416">// Return the length to use for the output buffer given to the base32 escape</a>
<a name="ln417">// routines.  This function may return incorrect results if given input_len</a>
<a name="ln418">// values that are extremely high, which should happen rarely.</a>
<a name="ln419">int CalculateBase32EscapedLen(size_t input_len);</a>
<a name="ln420"> </a>
<a name="ln421">// ----------------------------------------------------------------------</a>
<a name="ln422">// EightBase32DigitsToTenHexDigits()</a>
<a name="ln423">// TenHexDigitsToEightBase32Digits()</a>
<a name="ln424">//    Convert base32 to and from hex.</a>
<a name="ln425">//</a>
<a name="ln426">//   for EightBase32DigitsToTenHexDigits():</a>
<a name="ln427">//     *in must point to 8 base32 digits.</a>
<a name="ln428">//     *out must point to 10 bytes.</a>
<a name="ln429">//</a>
<a name="ln430">//   for TenHexDigitsToEightBase32Digits():</a>
<a name="ln431">//     *in must point to 10 hex digits.</a>
<a name="ln432">//     *out must point to 8 bytes.</a>
<a name="ln433">//</a>
<a name="ln434">//   Note that the Base64 functions above are different. They convert base64</a>
<a name="ln435">//   to and from binary data. We convert to and from string representations</a>
<a name="ln436">//   of hex. They deal with arbitrary lengths and we deal with single,</a>
<a name="ln437">//   whole base32 quanta.</a>
<a name="ln438">//</a>
<a name="ln439">//   See RFC3548 at http://www.ietf.org/rfc/rfc3548.txt</a>
<a name="ln440">//   for details on base32.</a>
<a name="ln441">// ----------------------------------------------------------------------</a>
<a name="ln442">void EightBase32DigitsToTenHexDigits(const char* in, char* out);</a>
<a name="ln443">void TenHexDigitsToEightBase32Digits(const char* in, char* out);</a>
<a name="ln444"> </a>
<a name="ln445">// ----------------------------------------------------------------------</a>
<a name="ln446">// EightBase32DigitsToFiveBytes()</a>
<a name="ln447">// FiveBytesToEightBase32Digits()</a>
<a name="ln448">//   Convert base32 to and from binary</a>
<a name="ln449">//</a>
<a name="ln450">//   for EightBase32DigitsToTenHexDigits():</a>
<a name="ln451">//     *in must point to 8 base32 digits.</a>
<a name="ln452">//     *out must point to 5 bytes.</a>
<a name="ln453">//</a>
<a name="ln454">//   for TenHexDigitsToEightBase32Digits():</a>
<a name="ln455">//     *in must point to 5 bytes.</a>
<a name="ln456">//     *out must point to 8 bytes.</a>
<a name="ln457">//</a>
<a name="ln458">//   Note that the Base64 functions above are different.  They deal with</a>
<a name="ln459">//   arbitrary lengths and we deal with single, whole base32 quanta.</a>
<a name="ln460">// ----------------------------------------------------------------------</a>
<a name="ln461">void EightBase32DigitsToFiveBytes(const char* in, unsigned char* bytes_out);</a>
<a name="ln462">void FiveBytesToEightBase32Digits(const unsigned char* in_bytes, char* out);</a>
<a name="ln463"> </a>
<a name="ln464">// ----------------------------------------------------------------------</a>
<a name="ln465">// EscapeFileName()</a>
<a name="ln466">// UnescapeFileName()</a>
<a name="ln467">//   Utility functions to (un)escape strings to make them suitable for use in</a>
<a name="ln468">//   filenames. Characters not in [a-zA-Z0-9-_.] will be escaped into %XX.</a>
<a name="ln469">//   E.g: &quot;Hello, world!&quot; will be escaped as &quot;Hello%2c%20world%21&quot;</a>
<a name="ln470">//</a>
<a name="ln471">//   NB that this function escapes slashes, so the output will be a flat</a>
<a name="ln472">//   filename and will not keep the directory structure. Slashes are replaced</a>
<a name="ln473">//   with '~', instead of a %XX sequence to make it easier for people to</a>
<a name="ln474">//   understand the escaped form when the original string is a file path.</a>
<a name="ln475">//</a>
<a name="ln476">//   WARNING: filenames produced by these functions may not be compatible with</a>
<a name="ln477">//   Colossus FS. In particular, the '%' character has a special meaning in</a>
<a name="ln478">//   CFS.</a>
<a name="ln479">//</a>
<a name="ln480">//   The versions that receive a string for the output will append to it.</a>
<a name="ln481">// ----------------------------------------------------------------------</a>
<a name="ln482">void EscapeFileName(const GStringPiece&amp; src, string* dst);</a>
<a name="ln483">void UnescapeFileName(const GStringPiece&amp; src, string* dst);</a>
<a name="ln484">inline string EscapeFileName(const GStringPiece&amp; src) {</a>
<a name="ln485">  string r;</a>
<a name="ln486">  EscapeFileName(src, &amp;r);</a>
<a name="ln487">  return r;</a>
<a name="ln488">}</a>
<a name="ln489">inline string UnescapeFileName(const GStringPiece&amp; src) {</a>
<a name="ln490">  string r;</a>
<a name="ln491">  UnescapeFileName(src, &amp;r);</a>
<a name="ln492">  return r;</a>
<a name="ln493">}</a>
<a name="ln494"> </a>
<a name="ln495">// ----------------------------------------------------------------------</a>
<a name="ln496">// Here are a couple utility methods to change ints to hex chars &amp; back</a>
<a name="ln497">// ----------------------------------------------------------------------</a>
<a name="ln498"> </a>
<a name="ln499">inline int int_to_hex_digit(int i) {</a>
<a name="ln500">  DCHECK((i &gt;= 0) &amp;&amp; (i &lt;= 15));</a>
<a name="ln501">  return ((i &lt; 10) ? (i + '0') : ((i - 10) + 'A'));</a>
<a name="ln502">}</a>
<a name="ln503"> </a>
<a name="ln504">inline int int_to_lower_hex_digit(int i) {</a>
<a name="ln505">  DCHECK((i &gt;= 0) &amp;&amp; (i &lt;= 15));</a>
<a name="ln506">  return (i &lt; 10) ? (i + '0') : ((i - 10) + 'a');</a>
<a name="ln507">}</a>
<a name="ln508"> </a>
<a name="ln509">inline int hex_digit_to_int(char c) {</a>
<a name="ln510">  /* Assume ASCII. */</a>
<a name="ln511">  DCHECK('0' == 0x30 &amp;&amp; 'A' == 0x41 &amp;&amp; 'a' == 0x61);</a>
<a name="ln512">  DCHECK(ascii_isxdigit(c));</a>
<a name="ln513">  int x = static_cast&lt;unsigned char&gt;(c);</a>
<a name="ln514">  if (x &gt; '9') {</a>
<a name="ln515">    x += 9;</a>
<a name="ln516">  }</a>
<a name="ln517">  return x &amp; 0xf;</a>
<a name="ln518">}</a>
<a name="ln519"> </a>
<a name="ln520">// ----------------------------------------------------------------------</a>
<a name="ln521">// a2b_hex()</a>
<a name="ln522">//  Description: Ascii-to-Binary hex conversion.  This converts</a>
<a name="ln523">//         2*'num' hexadecimal characters to 'num' binary data.</a>
<a name="ln524">//        Return value: 'num' bytes of binary data (via the 'to' argument)</a>
<a name="ln525">// ----------------------------------------------------------------------</a>
<a name="ln526">void a2b_hex(const char* from, unsigned char* to, int num);</a>
<a name="ln527">void a2b_hex(const char* from, char* to, int num);</a>
<a name="ln528">void a2b_hex(const char* from, string* to, int num);</a>
<a name="ln529">string a2b_hex(const string&amp; a);</a>
<a name="ln530"> </a>
<a name="ln531">// ----------------------------------------------------------------------</a>
<a name="ln532">// a2b_bin()</a>
<a name="ln533">//  Description: Ascii-to-Binary binary conversion.  This converts</a>
<a name="ln534">//        a.size() binary characters (ascii '0' or '1') to</a>
<a name="ln535">//        ceil(a.size()/8) bytes of binary data.  The first character is</a>
<a name="ln536">//        considered the most significant if byte_order_msb is set.  a is</a>
<a name="ln537">//        considered to be padded with trailing 0s if its size is not a</a>
<a name="ln538">//        multiple of 8.</a>
<a name="ln539">//        Return value: ceil(a.size()/8) bytes of binary data</a>
<a name="ln540">// ----------------------------------------------------------------------</a>
<a name="ln541">string a2b_bin(const string&amp; a, bool byte_order_msb);</a>
<a name="ln542"> </a>
<a name="ln543">// ----------------------------------------------------------------------</a>
<a name="ln544">// b2a_hex()</a>
<a name="ln545">//  Description: Binary-to-Ascii hex conversion.  This converts</a>
<a name="ln546">//   'num' bytes of binary to a 2*'num'-character hexadecimal representation</a>
<a name="ln547">//    Return value: 2*'num' characters of ascii text (via the 'to' argument)</a>
<a name="ln548">// ----------------------------------------------------------------------</a>
<a name="ln549">void b2a_hex(const unsigned char* from, char* to, int num);</a>
<a name="ln550">void b2a_hex(const unsigned char* from, string* to, int num);</a>
<a name="ln551"> </a>
<a name="ln552">// ----------------------------------------------------------------------</a>
<a name="ln553">// b2a_hex()</a>
<a name="ln554">//  Description: Binary-to-Ascii hex conversion.  This converts</a>
<a name="ln555">//   'num' bytes of binary to a 2*'num'-character hexadecimal representation</a>
<a name="ln556">//    Return value: 2*'num' characters of ascii string</a>
<a name="ln557">// ----------------------------------------------------------------------</a>
<a name="ln558">string b2a_hex(const char* from, int num);</a>
<a name="ln559">string b2a_hex(const GStringPiece&amp; b);</a>
<a name="ln560"> </a>
<a name="ln561">// ----------------------------------------------------------------------</a>
<a name="ln562">// b2a_bin()</a>
<a name="ln563">//  Description: Binary-to-Ascii binary conversion.  This converts</a>
<a name="ln564">//   b.size() bytes of binary to a 8*b.size() character representation</a>
<a name="ln565">//   (ascii '0' or '1').  The highest order bit in each byte is returned</a>
<a name="ln566">//   first in the string if byte_order_msb is set.</a>
<a name="ln567">//   Return value: 8*b.size() characters of ascii text</a>
<a name="ln568">// ----------------------------------------------------------------------</a>
<a name="ln569">string b2a_bin(const string&amp; b, bool byte_order_msb);</a>
<a name="ln570"> </a>
<a name="ln571">// ----------------------------------------------------------------------</a>
<a name="ln572">// ShellEscape</a>
<a name="ln573">//   Make a shell command argument from a string.</a>
<a name="ln574">//   Returns a Bourne shell string literal such that, once the shell finishes</a>
<a name="ln575">//   expanding the argument, the argument passed on to the program being</a>
<a name="ln576">//   run will be the same as whatever you passed in.</a>
<a name="ln577">//   NOTE: This is &quot;ported&quot; from python2.2's commands.mkarg(); it should be</a>
<a name="ln578">//         safe for Bourne shell syntax (i.e. sh, bash), but mileage may vary</a>
<a name="ln579">//         with other shells.</a>
<a name="ln580">// ----------------------------------------------------------------------</a>
<a name="ln581">string ShellEscape(GStringPiece src);</a>
<a name="ln582"> </a>
<a name="ln583">// Runs ShellEscape() on the arguments, concatenates them with a space, and</a>
<a name="ln584">// returns the resulting string.</a>
<a name="ln585">template &lt;class InputIterator&gt;</a>
<a name="ln586">string ShellEscapeCommandLine(InputIterator begin, const InputIterator&amp; end) {</a>
<a name="ln587">  string result;</a>
<a name="ln588">  for (; begin != end; ++begin) {</a>
<a name="ln589">    if (!result.empty()) result.append(&quot; &quot;);</a>
<a name="ln590">    result.append(ShellEscape(*begin));</a>
<a name="ln591">  }</a>
<a name="ln592">  return result;</a>
<a name="ln593">}</a>
<a name="ln594"> </a>
<a name="ln595">// Reads at most bytes_to_read from binary_string and writes it to</a>
<a name="ln596">// ascii_string in lower case hex.</a>
<a name="ln597">void ByteStringToAscii(const string&amp; binary_string, int bytes_to_read,</a>
<a name="ln598">                       string* ascii_string);</a>
<a name="ln599"> </a>
<a name="ln600">inline string ByteStringToAscii(const string&amp; binary_string,</a>
<a name="ln601">                                int bytes_to_read) {</a>
<a name="ln602">  string result;</a>
<a name="ln603">  ByteStringToAscii(binary_string, bytes_to_read, &amp;result);</a>
<a name="ln604">  return result;</a>
<a name="ln605">}</a>
<a name="ln606"> </a>
<a name="ln607">// Converts the hex from ascii_string into binary data and</a>
<a name="ln608">// writes the binary data into binary_string.</a>
<a name="ln609">// Empty input successfully converts to empty output.</a>
<a name="ln610">// Returns false and may modify output if it is</a>
<a name="ln611">// unable to parse the hex string.</a>
<a name="ln612">bool ByteStringFromAscii(const string&amp; ascii_string, string* binary_string);</a>
<a name="ln613"> </a>
<a name="ln614">// Clean up a multi-line string to conform to Unix line endings.</a>
<a name="ln615">// Reads from src and appends to dst, so usually dst should be empty.</a>
<a name="ln616">// If there is no line ending at the end of a non-empty string, it can</a>
<a name="ln617">// be added automatically.</a>
<a name="ln618">//</a>
<a name="ln619">// Four different types of input are correctly handled:</a>
<a name="ln620">//</a>
<a name="ln621">//   - Unix/Linux files: line ending is LF, pass through unchanged</a>
<a name="ln622">//</a>
<a name="ln623">//   - DOS/Windows files: line ending is CRLF: convert to LF</a>
<a name="ln624">//</a>
<a name="ln625">//   - Legacy Mac files: line ending is CR: convert to LF</a>
<a name="ln626">//</a>
<a name="ln627">//   - Garbled files: random line endings, covert gracefully</a>
<a name="ln628">//                    lonely CR, lonely LF, CRLF: convert to LF</a>
<a name="ln629">//</a>
<a name="ln630">//   @param src The multi-line string to convert</a>
<a name="ln631">//   @param dst The converted string is appended to this string</a>
<a name="ln632">//   @param auto_end_last_line Automatically terminate the last line</a>
<a name="ln633">//</a>
<a name="ln634">//   Limitations:</a>
<a name="ln635">//</a>
<a name="ln636">//     This does not do the right thing for CRCRLF files created by</a>
<a name="ln637">//     broken programs that do another Unix-&gt;DOS conversion on files</a>
<a name="ln638">//     that are already in CRLF format.</a>
<a name="ln639">void CleanStringLineEndings(const string&amp; src, string* dst,</a>
<a name="ln640">                            bool auto_end_last_line);</a>
<a name="ln641"> </a>
<a name="ln642">// Same as above, but transforms the argument in place.</a>
<a name="ln643">void CleanStringLineEndings(string* str, bool auto_end_last_line);</a>
<a name="ln644"> </a>
<a name="ln645">}  // namespace strings</a>
<a name="ln646"> </a>
<a name="ln647">// The following functions used to be defined in strutil.h in the top-level</a>
<a name="ln648">// namespace, so we alias them here. Do not add new functions here.</a>
<a name="ln649">//</a>
<a name="ln650">//             Talk to him if you want to help.</a>
<a name="ln651">//</a>
<a name="ln652">// DEPRECATED(mec): Using these names in the global namespace is deprecated.</a>
<a name="ln653">// Use the strings:: names.</a>
<a name="ln654"> </a>
<a name="ln655">using strings::EscapeStrForCSV;</a>
<a name="ln656">using strings::UnescapeCEscapeSequences;</a>
<a name="ln657">using strings::UnescapeCEscapeString;</a>
<a name="ln658">using strings::CEscapeString;</a>
<a name="ln659">using strings::CHexEscapeString;</a>
<a name="ln660">using strings::CEscape;</a>
<a name="ln661">using strings::CHexEscape;</a>
<a name="ln662">using strings::BackslashEscape;</a>
<a name="ln663">using strings::BackslashUnescape;</a>
<a name="ln664">using strings::QuotedPrintableUnescape;</a>
<a name="ln665">using strings::QEncodingUnescape;</a>
<a name="ln666">using strings::Base64Unescape;</a>
<a name="ln667">using strings::WebSafeBase64Unescape;</a>
<a name="ln668">using strings::CalculateBase64EscapedLen;</a>
<a name="ln669">using strings::Base64Escape;</a>
<a name="ln670">using strings::WebSafeBase64Escape;</a>
<a name="ln671">using strings::WebSafeBase64EscapeWithPadding;</a>
<a name="ln672">using strings::Base32Escape;</a>
<a name="ln673">using strings::Base32HexEscape;</a>
<a name="ln674">using strings::CalculateBase32EscapedLen;</a>
<a name="ln675">using strings::EightBase32DigitsToTenHexDigits;</a>
<a name="ln676">using strings::TenHexDigitsToEightBase32Digits;</a>
<a name="ln677">using strings::EightBase32DigitsToFiveBytes;</a>
<a name="ln678">using strings::FiveBytesToEightBase32Digits;</a>
<a name="ln679">using strings::int_to_hex_digit;</a>
<a name="ln680">using strings::int_to_lower_hex_digit;</a>
<a name="ln681">using strings::hex_digit_to_int;</a>
<a name="ln682">using strings::a2b_hex;</a>
<a name="ln683">using strings::a2b_bin;</a>
<a name="ln684">using strings::b2a_hex;</a>
<a name="ln685">using strings::b2a_bin;</a>
<a name="ln686">using strings::ShellEscape;</a>
<a name="ln687">using strings::ShellEscapeCommandLine;</a>
<a name="ln688">using strings::ByteStringFromAscii;</a>
<a name="ln689">using strings::ByteStringToAscii;</a>
<a name="ln690">using strings::CleanStringLineEndings;</a>
<a name="ln691"> </a>
<a name="ln692">#endif  // STRINGS_ESCAPING_H_</a>

</code></pre>
<div class="balloon" rel="500"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="505"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="511"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="512"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
