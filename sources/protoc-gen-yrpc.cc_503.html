
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>protoc-gen-yrpc.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Licensed to the Apache Software Foundation (ASF) under one</a>
<a name="ln2">// or more contributor license agreements.  See the NOTICE file</a>
<a name="ln3">// distributed with this work for additional information</a>
<a name="ln4">// regarding copyright ownership.  The ASF licenses this file</a>
<a name="ln5">// to you under the Apache License, Version 2.0 (the</a>
<a name="ln6">// &quot;License&quot;); you may not use this file except in compliance</a>
<a name="ln7">// with the License.  You may obtain a copy of the License at</a>
<a name="ln8">//</a>
<a name="ln9">//   http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln10">//</a>
<a name="ln11">// Unless required by applicable law or agreed to in writing,</a>
<a name="ln12">// software distributed under the License is distributed on an</a>
<a name="ln13">// &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</a>
<a name="ln14">// KIND, either express or implied.  See the License for the</a>
<a name="ln15">// specific language governing permissions and limitations</a>
<a name="ln16">// under the License.</a>
<a name="ln17">//</a>
<a name="ln18">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln19">//</a>
<a name="ln20">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln21">//</a>
<a name="ln22">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln23">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln24">//</a>
<a name="ln25">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln26">//</a>
<a name="ln27">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln28">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln29">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln30">// under the License.</a>
<a name="ln31">//</a>
<a name="ln32"> </a>
<a name="ln33">////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln34">// Example usage:</a>
<a name="ln35">// protoc --plugin=protoc-gen-yrpc --yrpc_out . --proto_path . &lt;file&gt;.proto</a>
<a name="ln36">////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln37"> </a>
<a name="ln38">#include &lt;ctype.h&gt;</a>
<a name="ln39"> </a>
<a name="ln40">#include &lt;iostream&gt;</a>
<a name="ln41">#include &lt;map&gt;</a>
<a name="ln42">#include &lt;memory&gt;</a>
<a name="ln43">#include &lt;sstream&gt;</a>
<a name="ln44">#include &lt;string&gt;</a>
<a name="ln45"> </a>
<a name="ln46">#include &lt;glog/logging.h&gt;</a>
<a name="ln47">#include &lt;google/protobuf/compiler/code_generator.h&gt;</a>
<a name="ln48">#include &lt;google/protobuf/compiler/plugin.h&gt;</a>
<a name="ln49">#include &lt;google/protobuf/descriptor.h&gt;</a>
<a name="ln50">#include &lt;google/protobuf/io/printer.h&gt;</a>
<a name="ln51">#include &lt;google/protobuf/io/zero_copy_stream.h&gt;</a>
<a name="ln52">#include &lt;google/protobuf/stubs/common.h&gt;</a>
<a name="ln53"> </a>
<a name="ln54">#include &quot;yb/gutil/gscoped_ptr.h&quot;</a>
<a name="ln55">#include &quot;yb/gutil/strings/split.h&quot;</a>
<a name="ln56">#include &quot;yb/gutil/strings/join.h&quot;</a>
<a name="ln57">#include &quot;yb/gutil/strings/numbers.h&quot;</a>
<a name="ln58">#include &quot;yb/gutil/strings/strip.h&quot;</a>
<a name="ln59">#include &quot;yb/gutil/strings/stringpiece.h&quot;</a>
<a name="ln60">#include &quot;yb/gutil/strings/substitute.h&quot;</a>
<a name="ln61">#include &quot;yb/gutil/strings/util.h&quot;</a>
<a name="ln62">#include &quot;yb/util/status.h&quot;</a>
<a name="ln63">#include &quot;yb/util/string_case.h&quot;</a>
<a name="ln64"> </a>
<a name="ln65">using google::protobuf::FileDescriptor;</a>
<a name="ln66">using google::protobuf::io::Printer;</a>
<a name="ln67">using google::protobuf::MethodDescriptor;</a>
<a name="ln68">using google::protobuf::ServiceDescriptor;</a>
<a name="ln69">using std::map;</a>
<a name="ln70">using std::shared_ptr;</a>
<a name="ln71">using std::string;</a>
<a name="ln72">using std::vector;</a>
<a name="ln73"> </a>
<a name="ln74">namespace yb {</a>
<a name="ln75">namespace rpc {</a>
<a name="ln76"> </a>
<a name="ln77">class Substituter {</a>
<a name="ln78"> public:</a>
<a name="ln79">  virtual ~Substituter() {}</a>
<a name="ln80">  virtual void InitSubstitutionMap(map&lt;string, string&gt; *map) const = 0;</a>
<a name="ln81">};</a>
<a name="ln82"> </a>
<a name="ln83">// NameInfo contains information about the output names.</a>
<a name="ln84">class FileSubstitutions : public Substituter {</a>
<a name="ln85"> public:</a>
<a name="ln86">  static const std::string PROTO_EXTENSION;</a>
<a name="ln87"> </a>
<a name="ln88">  Status Init(const FileDescriptor *file) {</a>
<a name="ln89">    string path = file-&gt;name();</a>
<a name="ln90">    map_[&quot;path&quot;] = path;</a>
<a name="ln91"> </a>
<a name="ln92">    // Initialize path_</a>
<a name="ln93">    // If path = /foo/bar/baz_stuff.proto, path_ = /foo/bar/baz_stuff</a>
<a name="ln94">    if (!TryStripSuffixString(path, PROTO_EXTENSION, &amp;path_no_extension_)) {</a>
<a name="ln95">      return STATUS(InvalidArgument, &quot;file name &quot; + path +</a>
<a name="ln96">                                     &quot; did not end in &quot; + PROTO_EXTENSION);</a>
<a name="ln97">    }</a>
<a name="ln98">    map_[&quot;path_no_extension&quot;] = path_no_extension_;</a>
<a name="ln99"> </a>
<a name="ln100">    // If path = /foo/bar/baz_stuff.proto, base_ = baz_stuff</a>
<a name="ln101">    string base;</a>
<a name="ln102">    GetBaseName(path_no_extension_, &amp;base);</a>
<a name="ln103">    map_[&quot;base&quot;] = base;</a>
<a name="ln104"> </a>
<a name="ln105">    // If path = /foo/bar/baz_stuff.proto, camel_case_ = BazStuff</a>
<a name="ln106">    string camel_case;</a>
<a name="ln107">    SnakeToCamelCase(base, &amp;camel_case);</a>
<a name="ln108">    map_[&quot;camel_case&quot;] = camel_case;</a>
<a name="ln109"> </a>
<a name="ln110">    // If path = /foo/bar/baz_stuff.proto, upper_case_ = BAZ_STUFF</a>
<a name="ln111">    string upper_case;</a>
<a name="ln112">    ToUpperCase(base, &amp;upper_case);</a>
<a name="ln113">    map_[&quot;upper_case&quot;] = upper_case;</a>
<a name="ln114"> </a>
<a name="ln115">    map_[&quot;open_namespace&quot;] = GenerateOpenNamespace(file-&gt;package());</a>
<a name="ln116">    map_[&quot;close_namespace&quot;] = GenerateCloseNamespace(file-&gt;package());</a>
<a name="ln117"> </a>
<a name="ln118">    return Status::OK();</a>
<a name="ln119">  }</a>
<a name="ln120"> </a>
<a name="ln121">  void InitSubstitutionMap(map&lt;string, string&gt; *map) const override {</a>
<a name="ln122">    typedef std::map&lt;string, string&gt;::value_type kv_pair;</a>
<a name="ln123">    for (const kv_pair &amp;pair : map_) {</a>
<a name="ln124">      (*map)[pair.first] = pair.second;</a>
<a name="ln125">    }</a>
<a name="ln126">  }</a>
<a name="ln127"> </a>
<a name="ln128">  std::string service_header() const {</a>
<a name="ln129">    return path_no_extension_ + &quot;.service.h&quot;;</a>
<a name="ln130">  }</a>
<a name="ln131"> </a>
<a name="ln132">  std::string service() const {</a>
<a name="ln133">    return path_no_extension_ + &quot;.service.cc&quot;;</a>
<a name="ln134">  }</a>
<a name="ln135"> </a>
<a name="ln136">  std::string proxy_header() const {</a>
<a name="ln137">    return path_no_extension_ + &quot;.proxy.h&quot;;</a>
<a name="ln138">  }</a>
<a name="ln139"> </a>
<a name="ln140">  std::string proxy() const {</a>
<a name="ln141">    return path_no_extension_ + &quot;.proxy.cc&quot;;</a>
<a name="ln142">  }</a>
<a name="ln143"> </a>
<a name="ln144"> private:</a>
<a name="ln145">  // Extract the last filename component.</a>
<a name="ln146">  static void GetBaseName(const string &amp;path,</a>
<a name="ln147">                          string *base) {</a>
<a name="ln148">    size_t last_slash = path.find_last_of(&quot;/&quot;);</a>
<a name="ln149">    if (last_slash != string::npos) {</a>
<a name="ln150">      *base = path.substr(last_slash + 1);</a>
<a name="ln151">    } else {</a>
<a name="ln152">      *base = path;</a>
<a name="ln153">    }</a>
<a name="ln154">  }</a>
<a name="ln155"> </a>
<a name="ln156">  static string GenerateOpenNamespace(const string &amp;str) {</a>
<a name="ln157">    vector&lt;string&gt; components = strings::Split(str, &quot;.&quot;);</a>
<a name="ln158">    string out;</a>
<a name="ln159">    for (const string &amp;c : components) {</a>
<a name="ln160">      out.append(&quot;namespace &quot;).append(c).append(&quot; {\n&quot;);</a>
<a name="ln161">    }</a>
<a name="ln162">    return out;</a>
<a name="ln163">  }</a>
<a name="ln164"> </a>
<a name="ln165">  static string GenerateCloseNamespace(const string &amp;str) {</a>
<a name="ln166">    vector&lt;string&gt; components = strings::Split(str, &quot;.&quot;);</a>
<a name="ln167">    string out;</a>
<a name="ln168">    for (auto c = components.crbegin(); c != components.crend(); c++) {</a>
<a name="ln169">      out.append(&quot;} // namespace &quot;).append(*c).append(&quot;\n&quot;);</a>
<a name="ln170">    }</a>
<a name="ln171">    return out;</a>
<a name="ln172">  }</a>
<a name="ln173"> </a>
<a name="ln174">  std::string path_no_extension_;</a>
<a name="ln175">  map&lt;string, string&gt; map_;</a>
<a name="ln176">};</a>
<a name="ln177"> </a>
<a name="ln178">const std::string FileSubstitutions::PROTO_EXTENSION(&quot;.proto&quot;);</a>
<a name="ln179"> </a>
<a name="ln180">class MethodSubstitutions : public Substituter {</a>
<a name="ln181"> public:</a>
<a name="ln182">  explicit MethodSubstitutions(const MethodDescriptor *method)</a>
<a name="ln183">    : method_(method) {</a>
<a name="ln184">  }</a>
<a name="ln185"> </a>
<a name="ln186">  void InitSubstitutionMap(map&lt;string, string&gt; *map) const override {</a>
<a name="ln187">    (*map)[&quot;rpc_name&quot;] = method_-&gt;name();</a>
<a name="ln188">    (*map)[&quot;rpc_full_name&quot;] = method_-&gt;full_name();</a>
<a name="ln189">    (*map)[&quot;rpc_full_name_plainchars&quot;] =</a>
<a name="ln190">        StringReplace(method_-&gt;full_name(), &quot;.&quot;, &quot;_&quot;, true);</a>
<a name="ln191">    (*map)[&quot;request&quot;] =</a>
<a name="ln192">        ReplaceNamespaceDelimiters(</a>
<a name="ln193">            StripNamespaceIfPossible(method_-&gt;service()-&gt;full_name(),</a>
<a name="ln194">                                     method_-&gt;input_type()-&gt;full_name()));</a>
<a name="ln195">    (*map)[&quot;response&quot;] =</a>
<a name="ln196">        ReplaceNamespaceDelimiters(</a>
<a name="ln197">            StripNamespaceIfPossible(method_-&gt;service()-&gt;full_name(),</a>
<a name="ln198">                                     method_-&gt;output_type()-&gt;full_name()));</a>
<a name="ln199">    (*map)[&quot;metric_enum_key&quot;] = strings::Substitute(&quot;kMetricIndex$0&quot;, method_-&gt;name());</a>
<a name="ln200">  }</a>
<a name="ln201"> </a>
<a name="ln202">  // Strips the package from method arguments if they are in the same package as</a>
<a name="ln203">  // the service, otherwise leaves them so that we can have fully qualified</a>
<a name="ln204">  // namespaces for method arguments.</a>
<a name="ln205">  static std::string StripNamespaceIfPossible(const std::string&amp; service_full_name,</a>
<a name="ln206">                                              const std::string&amp; arg_full_name) {</a>
<a name="ln207">    GStringPiece service_package(service_full_name);</a>
<a name="ln208">    if (!service_package.contains(&quot;.&quot;)) {</a>
<a name="ln209">      return arg_full_name;</a>
<a name="ln210">    }</a>
<a name="ln211">    // remove the service name so that we are left with only the package, including</a>
<a name="ln212">    // the last '.' so that we account for different packages with the same prefix.</a>
<a name="ln213">    service_package.remove_suffix(service_package.length() -</a>
<a name="ln214">                                  service_package.find_last_of(&quot;.&quot;) - 1);</a>
<a name="ln215"> </a>
<a name="ln216">    GStringPiece argfqn(arg_full_name);</a>
<a name="ln217">    if (argfqn.starts_with(service_package)) {</a>
<a name="ln218">      argfqn.remove_prefix(argfqn.find_last_of(&quot;.&quot;) + 1);</a>
<a name="ln219">    }</a>
<a name="ln220">    return argfqn.ToString();</a>
<a name="ln221">  }</a>
<a name="ln222"> </a>
<a name="ln223">  static std::string ReplaceNamespaceDelimiters(const std::string&amp; arg_full_name) {</a>
<a name="ln224">    return JoinStrings(strings::Split(arg_full_name, &quot;.&quot;), &quot;::&quot;);</a>
<a name="ln225">  }</a>
<a name="ln226"> </a>
<a name="ln227"> private:</a>
<a name="ln228">  const MethodDescriptor *method_;</a>
<a name="ln229">};</a>
<a name="ln230"> </a>
<a name="ln231">class ServiceSubstitutions : public Substituter {</a>
<a name="ln232"> public:</a>
<a name="ln233">  explicit ServiceSubstitutions(const ServiceDescriptor *service)</a>
<a name="ln234">    : service_(service)</a>
<a name="ln235">  {}</a>
<a name="ln236"> </a>
<a name="ln237">  void InitSubstitutionMap(map&lt;string, string&gt; *map) const override {</a>
<a name="ln238">    (*map)[&quot;service_name&quot;] = service_-&gt;name();</a>
<a name="ln239">    (*map)[&quot;full_service_name&quot;] = service_-&gt;full_name();</a>
<a name="ln240">    (*map)[&quot;service_method_count&quot;] = SimpleItoa(service_-&gt;method_count());</a>
<a name="ln241"> </a>
<a name="ln242">    // TODO: upgrade to protobuf 2.5.x and attach service comments</a>
<a name="ln243">    // to the generated service classes using the SourceLocation API.</a>
<a name="ln244">  }</a>
<a name="ln245"> </a>
<a name="ln246"> private:</a>
<a name="ln247">  const ServiceDescriptor *service_;</a>
<a name="ln248">};</a>
<a name="ln249"> </a>
<a name="ln250"> </a>
<a name="ln251">class SubstitutionContext {</a>
<a name="ln252"> public:</a>
<a name="ln253">  // Takes ownership of the substituter</a>
<a name="ln254">  void Push(const Substituter *sub) {</a>
<a name="ln255">    subs_.push_back(shared_ptr&lt;const Substituter&gt;(sub));</a>
<a name="ln256">  }</a>
<a name="ln257"> </a>
<a name="ln258">  void PushMethod(const MethodDescriptor *method) {</a>
<a name="ln259">    Push(new MethodSubstitutions(method));</a>
<a name="ln260">  }</a>
<a name="ln261"> </a>
<a name="ln262">  void PushService(const ServiceDescriptor *service) {</a>
<a name="ln263">    Push(new ServiceSubstitutions(service));</a>
<a name="ln264">  }</a>
<a name="ln265"> </a>
<a name="ln266">  void Pop() {</a>
<a name="ln267">    CHECK(!subs_.empty());</a>
<a name="ln268">    subs_.pop_back();</a>
<a name="ln269">  }</a>
<a name="ln270"> </a>
<a name="ln271">  void InitSubstitutionMap(map&lt;string, string&gt; *subs) const {</a>
<a name="ln272">    for (const shared_ptr&lt;const Substituter&gt; &amp;sub : subs_) {</a>
<a name="ln273">      sub-&gt;InitSubstitutionMap(subs);</a>
<a name="ln274">    }</a>
<a name="ln275">  }</a>
<a name="ln276"> </a>
<a name="ln277"> private:</a>
<a name="ln278">  vector&lt;shared_ptr&lt;const Substituter&gt; &gt; subs_;</a>
<a name="ln279">};</a>
<a name="ln280"> </a>
<a name="ln281"> </a>
<a name="ln282"> </a>
<a name="ln283">class CodeGenerator : public ::google::protobuf::compiler::CodeGenerator {</a>
<a name="ln284"> public:</a>
<a name="ln285">  CodeGenerator() { }</a>
<a name="ln286"> </a>
<a name="ln287">  ~CodeGenerator() { }</a>
<a name="ln288"> </a>
<a name="ln289">  bool Generate(const google::protobuf::FileDescriptor *file,</a>
<a name="ln290">        const std::string &amp;/* parameter */,</a>
<a name="ln291">        google::protobuf::compiler::GeneratorContext *gen_context,</a>
<a name="ln292">        std::string *error) const override {</a>
<a name="ln293">    auto name_info = new FileSubstitutions();</a>
<a name="ln294">    Status ret = name_info-&gt;Init(file);</a>
<a name="ln295">    if (!ret.ok()) {</a>
<a name="ln296">      *error = &quot;name_info.Init failed: &quot; + ret.ToString();</a>
<a name="ln297">      return false;</a>
<a name="ln298">    }</a>
<a name="ln299"> </a>
<a name="ln300">    SubstitutionContext subs;</a>
<a name="ln301">    subs.Push(name_info);</a>
<a name="ln302"> </a>
<a name="ln303">    gscoped_ptr&lt;google::protobuf::io::ZeroCopyOutputStream&gt; ih_output(</a>
<a name="ln304">        gen_context-&gt;Open(name_info-&gt;service_header()));</a>
<a name="ln305">    Printer ih_printer(ih_output.get(), '$');</a>
<a name="ln306">    GenerateServiceIfHeader(&amp;ih_printer, &amp;subs, file);</a>
<a name="ln307"> </a>
<a name="ln308">    gscoped_ptr&lt;google::protobuf::io::ZeroCopyOutputStream&gt; i_output(</a>
<a name="ln309">        gen_context-&gt;Open(name_info-&gt;service()));</a>
<a name="ln310">    Printer i_printer(i_output.get(), '$');</a>
<a name="ln311">    GenerateServiceIf(&amp;i_printer, &amp;subs, file);</a>
<a name="ln312"> </a>
<a name="ln313">    gscoped_ptr&lt;google::protobuf::io::ZeroCopyOutputStream&gt; ph_output(</a>
<a name="ln314">        gen_context-&gt;Open(name_info-&gt;proxy_header()));</a>
<a name="ln315">    Printer ph_printer(ph_output.get(), '$');</a>
<a name="ln316">    GenerateProxyHeader(&amp;ph_printer, &amp;subs, file);</a>
<a name="ln317"> </a>
<a name="ln318">    gscoped_ptr&lt;google::protobuf::io::ZeroCopyOutputStream&gt; p_output(</a>
<a name="ln319">        gen_context-&gt;Open(name_info-&gt;proxy()));</a>
<a name="ln320">    Printer p_printer(p_output.get(), '$');</a>
<a name="ln321">    GenerateProxy(&amp;p_printer, &amp;subs, file);</a>
<a name="ln322"> </a>
<a name="ln323">    return true;</a>
<a name="ln324">  }</a>
<a name="ln325"> </a>
<a name="ln326"> private:</a>
<a name="ln327">  void Print(Printer *printer,</a>
<a name="ln328">             const SubstitutionContext &amp;sub,</a>
<a name="ln329">             const char *text) const {</a>
<a name="ln330">    map&lt;string, string&gt; subs;</a>
<a name="ln331">    sub.InitSubstitutionMap(&amp;subs);</a>
<a name="ln332">    printer-&gt;Print(subs, text);</a>
<a name="ln333">  }</a>
<a name="ln334"> </a>
<a name="ln335">  void GenerateServiceIfHeader(Printer *printer,</a>
<a name="ln336">                               SubstitutionContext *subs,</a>
<a name="ln337">                               const FileDescriptor *file) const {</a>
<a name="ln338">    Print(printer, *subs,</a>
<a name="ln339">      &quot;// THIS FILE IS AUTOGENERATED FROM $path$\n&quot;</a>
<a name="ln340">      &quot;\n&quot;</a>
<a name="ln341">      &quot;#ifndef YB_RPC_$upper_case$_SERVICE_IF_DOT_H\n&quot;</a>
<a name="ln342">      &quot;#define YB_RPC_$upper_case$_SERVICE_IF_DOT_H\n&quot;</a>
<a name="ln343">      &quot;\n&quot;</a>
<a name="ln344">      &quot;#include \&quot;$path_no_extension$.pb.h\&quot;\n&quot;</a>
<a name="ln345">      &quot;\n&quot;</a>
<a name="ln346">      &quot;#include &lt;string&gt;\n&quot;</a>
<a name="ln347">      &quot;\n&quot;</a>
<a name="ln348">      &quot;#include \&quot;yb/rpc/rpc_fwd.h\&quot;\n&quot;</a>
<a name="ln349">      &quot;#include \&quot;yb/rpc/rpc_header.pb.h\&quot;\n&quot;</a>
<a name="ln350">      &quot;#include \&quot;yb/rpc/service_if.h\&quot;\n&quot;</a>
<a name="ln351">      &quot;\n&quot;</a>
<a name="ln352">      &quot;namespace yb {\n&quot;</a>
<a name="ln353">      &quot;class MetricEntity;\n&quot;</a>
<a name="ln354">      &quot;} // namespace yb\n&quot;</a>
<a name="ln355">      &quot;\n&quot;</a>
<a name="ln356">      &quot;$open_namespace$&quot;</a>
<a name="ln357">      &quot;\n&quot;</a>
<a name="ln358">      );</a>
<a name="ln359"> </a>
<a name="ln360">    for (int service_idx = 0; service_idx &lt; file-&gt;service_count();</a>
<a name="ln361">         ++service_idx) {</a>
<a name="ln362">      const ServiceDescriptor *service = file-&gt;service(service_idx);</a>
<a name="ln363">      subs-&gt;PushService(service);</a>
<a name="ln364"> </a>
<a name="ln365">      Print(printer, *subs,</a>
<a name="ln366">        &quot;\n&quot;</a>
<a name="ln367">        &quot;class $service_name$If : public ::yb::rpc::ServiceIf {\n&quot;</a>
<a name="ln368">        &quot; public:\n&quot;</a>
<a name="ln369">        &quot;  explicit $service_name$If(const scoped_refptr&lt;MetricEntity&gt;&amp; entity);\n&quot;</a>
<a name="ln370">        &quot;  virtual ~$service_name$If();\n&quot;</a>
<a name="ln371">        &quot;  virtual void Handle(::yb::rpc::InboundCallPtr call);\n&quot;</a>
<a name="ln372">        &quot;  virtual std::string service_name() const;\n&quot;</a>
<a name="ln373">        &quot;  static std::string static_service_name();\n&quot;</a>
<a name="ln374">        &quot;\n&quot;</a>
<a name="ln375">        );</a>
<a name="ln376"> </a>
<a name="ln377">      for (int method_idx = 0; method_idx &lt; service-&gt;method_count();</a>
<a name="ln378">           ++method_idx) {</a>
<a name="ln379">        const MethodDescriptor *method = service-&gt;method(method_idx);</a>
<a name="ln380">        subs-&gt;PushMethod(method);</a>
<a name="ln381"> </a>
<a name="ln382">        Print(printer, *subs,</a>
<a name="ln383">        &quot;  virtual void $rpc_name$(\n&quot;</a>
<a name="ln384">        &quot;      const $request$ *req,\n&quot;</a>
<a name="ln385">        &quot;      $response$ *resp,\n&quot;</a>
<a name="ln386">        &quot;      ::yb::rpc::RpcContext context) = 0;\n&quot;</a>
<a name="ln387">        );</a>
<a name="ln388"> </a>
<a name="ln389">        subs-&gt;Pop();</a>
<a name="ln390">      }</a>
<a name="ln391"> </a>
<a name="ln392">      Print(printer, *subs,</a>
<a name="ln393">            &quot;  enum RpcMetricIndexes {\n&quot;</a>
<a name="ln394">      );</a>
<a name="ln395">      for (int method_idx = 0; method_idx &lt; service-&gt;method_count();</a>
<a name="ln396">          ++method_idx) {</a>
<a name="ln397">        const MethodDescriptor *method = service-&gt;method(method_idx);</a>
<a name="ln398">        subs-&gt;PushMethod(method);</a>
<a name="ln399"> </a>
<a name="ln400">        Print(printer, *subs,</a>
<a name="ln401">              &quot;    $metric_enum_key$,\n&quot;</a>
<a name="ln402">        );</a>
<a name="ln403"> </a>
<a name="ln404">        subs-&gt;Pop();</a>
<a name="ln405">      }</a>
<a name="ln406"> </a>
<a name="ln407">      Print(printer, *subs,</a>
<a name="ln408">            &quot;  };\n&quot; // enum</a>
<a name="ln409">      );</a>
<a name="ln410"> </a>
<a name="ln411">      Print(printer, *subs,</a>
<a name="ln412">            &quot;\n&quot;</a>
<a name="ln413">                &quot;  ::yb::rpc::RpcMethodMetrics GetMetric(RpcMetricIndexes index) {\n&quot;</a>
<a name="ln414">                &quot;    return metrics_[index];\n&quot;</a>
<a name="ln415">                &quot;  }\n&quot;</a>
<a name="ln416">      );</a>
<a name="ln417"> </a>
<a name="ln418">      Print(printer, *subs,</a>
<a name="ln419">        &quot;\n&quot;</a>
<a name="ln420">        &quot; private:\n&quot;</a>
<a name="ln421">      );</a>
<a name="ln422"> </a>
<a name="ln423">      Print(printer, *subs,</a>
<a name="ln424">        &quot;  static const int kMethodCount = $service_method_count$;\n&quot;</a>
<a name="ln425">        &quot;\n&quot;</a>
<a name="ln426">        &quot;  // Pre-initialize metrics because calling METRIC_foo.Instantiate() is expensive.\n&quot;</a>
<a name="ln427">        &quot;  void InitMetrics(const scoped_refptr&lt;MetricEntity&gt;&amp; ent);\n&quot;</a>
<a name="ln428">        &quot;\n&quot;</a>
<a name="ln429">        &quot;  ::yb::rpc::RpcMethodMetrics metrics_[kMethodCount];\n&quot;</a>
<a name="ln430">        &quot;};\n&quot;</a>
<a name="ln431">      );</a>
<a name="ln432"> </a>
<a name="ln433">      subs-&gt;Pop(); // Service</a>
<a name="ln434">    }</a>
<a name="ln435"> </a>
<a name="ln436">    Print(printer, *subs,</a>
<a name="ln437">      &quot;\n&quot;</a>
<a name="ln438">      &quot;$close_namespace$\n&quot;</a>
<a name="ln439">      &quot;#endif\n&quot;);</a>
<a name="ln440">  }</a>
<a name="ln441"> </a>
<a name="ln442">  void GenerateServiceIf(Printer *printer,</a>
<a name="ln443">                         SubstitutionContext *subs,</a>
<a name="ln444">                         const FileDescriptor *file) const {</a>
<a name="ln445">    Print(printer, *subs,</a>
<a name="ln446">      &quot;// THIS FILE IS AUTOGENERATED FROM $path$\n&quot;</a>
<a name="ln447">      &quot;\n&quot;</a>
<a name="ln448">      &quot;#include \&quot;$path_no_extension$.pb.h\&quot;\n&quot;</a>
<a name="ln449">      &quot;#include \&quot;$path_no_extension$.service.h\&quot;\n&quot;</a>
<a name="ln450">      &quot;\n&quot;</a>
<a name="ln451">      &quot;#include &lt;glog/logging.h&gt;\n&quot;</a>
<a name="ln452">      &quot;\n&quot;</a>
<a name="ln453">      &quot;#include \&quot;yb/rpc/inbound_call.h\&quot;\n&quot;</a>
<a name="ln454">      &quot;#include \&quot;yb/rpc/local_call.h\&quot;\n&quot;</a>
<a name="ln455">      &quot;#include \&quot;yb/rpc/remote_method.h\&quot;\n&quot;</a>
<a name="ln456">      &quot;#include \&quot;yb/rpc/rpc_context.h\&quot;\n&quot;</a>
<a name="ln457">      &quot;#include \&quot;yb/rpc/service_if.h\&quot;\n&quot;</a>
<a name="ln458">      &quot;#include \&quot;yb/util/metrics.h\&quot;\n&quot;</a>
<a name="ln459">      &quot;\n&quot;);</a>
<a name="ln460"> </a>
<a name="ln461">    // Define metric prototypes for each method in the service.</a>
<a name="ln462">    for (int service_idx = 0; service_idx &lt; file-&gt;service_count();</a>
<a name="ln463">        ++service_idx) {</a>
<a name="ln464">      const ServiceDescriptor *service = file-&gt;service(service_idx);</a>
<a name="ln465">      subs-&gt;PushService(service);</a>
<a name="ln466"> </a>
<a name="ln467">      for (int method_idx = 0; method_idx &lt; service-&gt;method_count();</a>
<a name="ln468">          ++method_idx) {</a>
<a name="ln469">        const MethodDescriptor *method = service-&gt;method(method_idx);</a>
<a name="ln470">        subs-&gt;PushMethod(method);</a>
<a name="ln471">        Print(printer, *subs,</a>
<a name="ln472">          &quot;METRIC_DEFINE_histogram_with_percentiles(server,&quot;</a>
<a name="ln473">          &quot; handler_latency_$rpc_full_name_plainchars$,\n&quot;</a>
<a name="ln474">          &quot;  \&quot;$rpc_full_name$ RPC Time\&quot;,\n&quot;</a>
<a name="ln475">          &quot;  yb::MetricUnit::kMicroseconds,\n&quot;</a>
<a name="ln476">          &quot;  \&quot;Microseconds spent handling $rpc_full_name$() RPC requests\&quot;,\n&quot;</a>
<a name="ln477">          &quot;  60000000LU, 2);\n&quot;</a>
<a name="ln478">          &quot;\n&quot;);</a>
<a name="ln479">        subs-&gt;Pop();</a>
<a name="ln480">      }</a>
<a name="ln481"> </a>
<a name="ln482">      subs-&gt;Pop();</a>
<a name="ln483">    }</a>
<a name="ln484"> </a>
<a name="ln485">    Print(printer, *subs,</a>
<a name="ln486">      &quot;$open_namespace$&quot;</a>
<a name="ln487">      &quot;\n&quot;);</a>
<a name="ln488"> </a>
<a name="ln489">    for (int service_idx = 0; service_idx &lt; file-&gt;service_count();</a>
<a name="ln490">         ++service_idx) {</a>
<a name="ln491">      const ServiceDescriptor *service = file-&gt;service(service_idx);</a>
<a name="ln492">      subs-&gt;PushService(service);</a>
<a name="ln493"> </a>
<a name="ln494">      Print(printer, *subs,</a>
<a name="ln495">        &quot;$service_name$If::$service_name$If(const scoped_refptr&lt;MetricEntity&gt;&amp; entity) {\n&quot;</a>
<a name="ln496">        &quot;  InitMetrics(entity);\n&quot;</a>
<a name="ln497">        &quot;}\n&quot;</a>
<a name="ln498">        &quot;\n&quot;</a>
<a name="ln499">        &quot;$service_name$If::~$service_name$If() {\n&quot;</a>
<a name="ln500">        &quot;}\n&quot;</a>
<a name="ln501">        &quot;\n&quot;</a>
<a name="ln502">        &quot;void $service_name$If::Handle(::yb::rpc::InboundCallPtr call) {\n&quot;</a>
<a name="ln503">        &quot;  auto yb_call = std::static_pointer_cast&lt;::yb::rpc::YBInboundCall&gt;(call);\n&quot;);</a>
<a name="ln504"> </a>
<a name="ln505">      for (int method_idx = 0; method_idx &lt; service-&gt;method_count();</a>
<a name="ln506">           ++method_idx) {</a>
<a name="ln507">        const MethodDescriptor *method = service-&gt;method(method_idx);</a>
<a name="ln508">        subs-&gt;PushMethod(method);</a>
<a name="ln509"> </a>
<a name="ln510">        Print(printer, *subs,</a>
<a name="ln511">        &quot;  if (call-&gt;method_name() == \&quot;$rpc_name$\&quot;) {\n&quot;</a>
<a name="ln512">        &quot;    auto rpc_context = yb_call-&gt;IsLocalCall() ?\n&quot;</a>
<a name="ln513">        &quot;        ::yb::rpc::RpcContext(\n&quot;</a>
<a name="ln514">        &quot;            std::static_pointer_cast&lt;::yb::rpc::LocalYBInboundCall&gt;(yb_call), \n&quot;</a>
<a name="ln515">        &quot;            metrics_[$metric_enum_key$]) :\n&quot;</a>
<a name="ln516">        &quot;        ::yb::rpc::RpcContext(\n&quot;</a>
<a name="ln517">        &quot;            yb_call, \n&quot;</a>
<a name="ln518">        &quot;            std::make_shared&lt;$request$&gt;(),\n&quot;</a>
<a name="ln519">        &quot;            std::make_shared&lt;$response$&gt;(),\n&quot;</a>
<a name="ln520">        &quot;            metrics_[$metric_enum_key$]);\n&quot;</a>
<a name="ln521">        &quot;    if (!rpc_context.responded()) {\n&quot;</a>
<a name="ln522">        &quot;      const auto* req = static_cast&lt;const $request$*&gt;(rpc_context.request_pb());\n&quot;</a>
<a name="ln523">        &quot;      auto* resp = static_cast&lt;$response$*&gt;(rpc_context.response_pb());\n&quot;</a>
<a name="ln524">        &quot;      $rpc_name$(req, resp, std::move(rpc_context));\n&quot;</a>
<a name="ln525">        &quot;    }\n&quot;</a>
<a name="ln526">        &quot;    return;\n&quot;</a>
<a name="ln527">        &quot;  }\n&quot;</a>
<a name="ln528">        &quot;\n&quot;);</a>
<a name="ln529">        subs-&gt;Pop();</a>
<a name="ln530">      }</a>
<a name="ln531">      Print(printer, *subs,</a>
<a name="ln532">        &quot;  yb_call-&gt;RespondBadMethod();\n&quot;</a>
<a name="ln533">        &quot;}\n&quot;</a>
<a name="ln534">        &quot;\n&quot;</a>
<a name="ln535">        &quot;std::string $service_name$If::service_name() const {\n&quot;</a>
<a name="ln536">        &quot;  return \&quot;$full_service_name$\&quot;;\n&quot;</a>
<a name="ln537">        &quot;}\n&quot;</a>
<a name="ln538">        &quot;std::string $service_name$If::static_service_name() {\n&quot;</a>
<a name="ln539">        &quot;  return \&quot;$full_service_name$\&quot;;\n&quot;</a>
<a name="ln540">        &quot;}\n&quot;</a>
<a name="ln541">        &quot;\n&quot;</a>
<a name="ln542">      );</a>
<a name="ln543"> </a>
<a name="ln544">      Print(printer, *subs,</a>
<a name="ln545">        &quot;void $service_name$If::InitMetrics(const scoped_refptr&lt;MetricEntity&gt;&amp; entity) {\n&quot;</a>
<a name="ln546">      );</a>
<a name="ln547">      // Expose per-RPC metrics.</a>
<a name="ln548">      for (int method_idx = 0; method_idx &lt; service-&gt;method_count();</a>
<a name="ln549">           ++method_idx) {</a>
<a name="ln550">        const MethodDescriptor *method = service-&gt;method(method_idx);</a>
<a name="ln551">        subs-&gt;PushMethod(method);</a>
<a name="ln552"> </a>
<a name="ln553">        Print(printer, *subs,</a>
<a name="ln554">          &quot;  metrics_[$metric_enum_key$].handler_latency = \n&quot;</a>
<a name="ln555">          &quot;      METRIC_handler_latency_$rpc_full_name_plainchars$.Instantiate(entity);\n&quot;</a>
<a name="ln556">        );</a>
<a name="ln557"> </a>
<a name="ln558">        subs-&gt;Pop();</a>
<a name="ln559">      }</a>
<a name="ln560">      Print(printer, *subs,</a>
<a name="ln561">        &quot;}\n&quot;</a>
<a name="ln562">        &quot;\n&quot;</a>
<a name="ln563">      );</a>
<a name="ln564"> </a>
<a name="ln565">      subs-&gt;Pop();</a>
<a name="ln566">    }</a>
<a name="ln567"> </a>
<a name="ln568">    Print(printer, *subs,</a>
<a name="ln569">      &quot;$close_namespace$&quot;</a>
<a name="ln570">      );</a>
<a name="ln571">  }</a>
<a name="ln572"> </a>
<a name="ln573">  void GenerateProxyHeader(Printer *printer,</a>
<a name="ln574">                           SubstitutionContext *subs,</a>
<a name="ln575">                           const FileDescriptor *file) const {</a>
<a name="ln576">    Print(printer, *subs,</a>
<a name="ln577">      &quot;// THIS FILE IS AUTOGENERATED FROM $path$\n&quot;</a>
<a name="ln578">      &quot;\n&quot;</a>
<a name="ln579">      &quot;#ifndef YB_RPC_$upper_case$_PROXY_DOT_H\n&quot;</a>
<a name="ln580">      &quot;#define YB_RPC_$upper_case$_PROXY_DOT_H\n&quot;</a>
<a name="ln581">      &quot;\n&quot;</a>
<a name="ln582">      &quot;#include \&quot;$path_no_extension$.pb.h\&quot;\n&quot;</a>
<a name="ln583">      &quot;\n&quot;</a>
<a name="ln584">      &quot;#include \&quot;yb/rpc/proxy.h\&quot;\n&quot;</a>
<a name="ln585">      &quot;#include \&quot;yb/util/status.h\&quot;\n&quot;</a>
<a name="ln586">      &quot;#include \&quot;yb/util/net/net_fwd.h\&quot;\n&quot;</a>
<a name="ln587">      &quot;\n&quot;</a>
<a name="ln588">      &quot;namespace yb {\n&quot;</a>
<a name="ln589">      &quot;namespace rpc {\n&quot;</a>
<a name="ln590">      &quot;class Proxy;\n&quot;</a>
<a name="ln591">      &quot;}\n&quot;</a>
<a name="ln592">      &quot;}\n&quot;</a>
<a name="ln593">      &quot;\n&quot;</a>
<a name="ln594">      &quot;$open_namespace$&quot;</a>
<a name="ln595">      &quot;\n&quot;</a>
<a name="ln596">      &quot;\n&quot;</a>
<a name="ln597">    );</a>
<a name="ln598"> </a>
<a name="ln599">    for (int service_idx = 0; service_idx &lt; file-&gt;service_count();</a>
<a name="ln600">         ++service_idx) {</a>
<a name="ln601">      const ServiceDescriptor *service = file-&gt;service(service_idx);</a>
<a name="ln602">      subs-&gt;PushService(service);</a>
<a name="ln603"> </a>
<a name="ln604">      Print(printer, *subs,</a>
<a name="ln605">        &quot;class $service_name$Proxy {\n&quot;</a>
<a name="ln606">        &quot; public:\n&quot;</a>
<a name="ln607">        &quot;  $service_name$Proxy(\n&quot;</a>
<a name="ln608">        &quot;      ::yb::rpc::ProxyCache* cache,\n&quot;</a>
<a name="ln609">        &quot;      const ::yb::HostPort &amp;endpoint,\n&quot;</a>
<a name="ln610">        &quot;     const ::yb::rpc::Protocol* protocol = nullptr);\n&quot;</a>
<a name="ln611">        &quot;  ~$service_name$Proxy();\n&quot;</a>
<a name="ln612">        &quot;\n&quot;</a>
<a name="ln613">        );</a>
<a name="ln614"> </a>
<a name="ln615">      for (int method_idx = 0; method_idx &lt; service-&gt;method_count();</a>
<a name="ln616">           ++method_idx) {</a>
<a name="ln617">        const MethodDescriptor *method = service-&gt;method(method_idx);</a>
<a name="ln618">        subs-&gt;PushMethod(method);</a>
<a name="ln619"> </a>
<a name="ln620">        Print(printer, *subs,</a>
<a name="ln621">        &quot;\n&quot;</a>
<a name="ln622">        &quot;  ::yb::Status $rpc_name$(const $request$ &amp;req, $response$ *resp,\n&quot;</a>
<a name="ln623">        &quot;                          ::yb::rpc::RpcController *controller);\n&quot;</a>
<a name="ln624">        &quot;  void $rpc_name$Async(const $request$ &amp;req,\n&quot;</a>
<a name="ln625">        &quot;                       $response$ *response,\n&quot;</a>
<a name="ln626">        &quot;                       ::yb::rpc::RpcController *controller,\n&quot;</a>
<a name="ln627">        &quot;                       ::yb::rpc::ResponseCallback callback);\n&quot;</a>
<a name="ln628">        );</a>
<a name="ln629">        subs-&gt;Pop();</a>
<a name="ln630">      }</a>
<a name="ln631">      subs-&gt;Pop();</a>
<a name="ln632">    }</a>
<a name="ln633">    Print(printer, *subs,</a>
<a name="ln634">      &quot;  ::yb::rpc::Proxy&amp; proxy() { return *proxy_; }\n&quot;</a>
<a name="ln635">      &quot;\n&quot;</a>
<a name="ln636">      &quot;private:\n&quot;</a>
<a name="ln637">      &quot;  std::shared_ptr&lt;::yb::rpc::Proxy&gt; const proxy_;\n&quot;</a>
<a name="ln638">      &quot;};\n&quot;</a>
<a name="ln639">      &quot;\n&quot;</a>
<a name="ln640">      &quot;$close_namespace$&quot;</a>
<a name="ln641">      &quot;\n&quot;</a>
<a name="ln642">      &quot;#endif\n&quot;</a>
<a name="ln643">      );</a>
<a name="ln644">  }</a>
<a name="ln645"> </a>
<a name="ln646">  void GenerateProxy(Printer *printer,</a>
<a name="ln647">                     SubstitutionContext *subs,</a>
<a name="ln648">                     const FileDescriptor *file) const {</a>
<a name="ln649">    Print(printer, *subs,</a>
<a name="ln650">      &quot;// THIS FILE IS AUTOGENERATED FROM $path$\n&quot;</a>
<a name="ln651">      &quot;\n&quot;</a>
<a name="ln652">      &quot;#include \&quot;$path_no_extension$.proxy.h\&quot;\n&quot;</a>
<a name="ln653">      &quot;\n&quot;</a>
<a name="ln654">      &quot;#include \&quot;yb/rpc/proxy.h\&quot;\n&quot;</a>
<a name="ln655">      &quot;#include \&quot;yb/rpc/outbound_call.h\&quot;\n&quot;</a>
<a name="ln656">      &quot;#include \&quot;yb/util/net/sockaddr.h\&quot;\n&quot;</a>
<a name="ln657">      &quot;\n&quot;</a>
<a name="ln658">      &quot;$open_namespace$&quot;</a>
<a name="ln659">      &quot;\n&quot;</a>
<a name="ln660">      );</a>
<a name="ln661"> </a>
<a name="ln662">    for (int service_idx = 0; service_idx &lt; file-&gt;service_count();</a>
<a name="ln663">         ++service_idx) {</a>
<a name="ln664">      const ServiceDescriptor *service = file-&gt;service(service_idx);</a>
<a name="ln665">      subs-&gt;PushService(service);</a>
<a name="ln666">      Print(printer, *subs,</a>
<a name="ln667">        &quot;$service_name$Proxy::$service_name$Proxy(\n&quot;</a>
<a name="ln668">        &quot;   ::yb::rpc::ProxyCache* cache,\n&quot;</a>
<a name="ln669">        &quot;   const ::yb::HostPort &amp;remote,\n&quot;</a>
<a name="ln670">        &quot;   const ::yb::rpc::Protocol* protocol)\n&quot;</a>
<a name="ln671">        &quot;  : proxy_(cache-&gt;Get(remote, protocol)) {\n&quot;</a>
<a name="ln672">        &quot;}\n&quot;</a>
<a name="ln673">        &quot;\n&quot;</a>
<a name="ln674">        &quot;$service_name$Proxy::~$service_name$Proxy() {\n&quot;</a>
<a name="ln675">        &quot;}\n&quot;</a>
<a name="ln676">        &quot;\n&quot;);</a>
<a name="ln677">      for (int method_idx = 0; method_idx &lt; service-&gt;method_count();</a>
<a name="ln678">           ++method_idx) {</a>
<a name="ln679">        const MethodDescriptor *method = service-&gt;method(method_idx);</a>
<a name="ln680">        subs-&gt;PushMethod(method);</a>
<a name="ln681">        Print(printer, *subs,</a>
<a name="ln682">        &quot;::yb::Status $service_name$Proxy::$rpc_name$(const $request$ &amp;req, $response$ *resp,\n&quot;</a>
<a name="ln683">        &quot;                                     ::yb::rpc::RpcController *controller) {\n&quot;</a>
<a name="ln684">        &quot;  static ::yb::rpc::RemoteMethod method(\&quot;$full_service_name$\&quot;, \&quot;$rpc_name$\&quot;);\n&quot;</a>
<a name="ln685">        &quot;  return proxy_-&gt;SyncRequest(&amp;method, req, resp, controller);\n&quot;</a>
<a name="ln686">        &quot;}\n&quot;</a>
<a name="ln687">        &quot;\n&quot;</a>
<a name="ln688">        &quot;void $service_name$Proxy::$rpc_name$Async(const $request$ &amp;req,\n&quot;</a>
<a name="ln689">        &quot;                     $response$ *resp, ::yb::rpc::RpcController *controller,\n&quot;</a>
<a name="ln690">        &quot;                     ::yb::rpc::ResponseCallback callback) {\n&quot;</a>
<a name="ln691">        &quot;  static ::yb::rpc::RemoteMethod method(\&quot;$full_service_name$\&quot;, \&quot;$rpc_name$\&quot;);\n&quot;</a>
<a name="ln692">        &quot;  proxy_-&gt;AsyncRequest(&amp;method, req, resp, controller, std::move(callback));\n&quot;</a>
<a name="ln693">        &quot;}\n&quot;</a>
<a name="ln694">        &quot;\n&quot;);</a>
<a name="ln695">        subs-&gt;Pop();</a>
<a name="ln696">      }</a>
<a name="ln697"> </a>
<a name="ln698">      subs-&gt;Pop();</a>
<a name="ln699">    }</a>
<a name="ln700">    Print(printer, *subs,</a>
<a name="ln701">      &quot;$close_namespace$&quot;);</a>
<a name="ln702">  }</a>
<a name="ln703">};</a>
<a name="ln704">} // namespace rpc</a>
<a name="ln705">} // namespace yb</a>
<a name="ln706"> </a>
<a name="ln707">int main(int argc, char *argv[]) {</a>
<a name="ln708">  yb::rpc::CodeGenerator generator;</a>
<a name="ln709">  return google::protobuf::compiler::PluginMain(argc, argv, &amp;generator);</a>
<a name="ln710">}</a>

</code></pre>
<div class="balloon" rel="267"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="297"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'name_info' pointer. A memory leak is possible.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
