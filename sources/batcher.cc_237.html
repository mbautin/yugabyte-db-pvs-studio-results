
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>batcher.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Licensed to the Apache Software Foundation (ASF) under one</a>
<a name="ln2">// or more contributor license agreements.  See the NOTICE file</a>
<a name="ln3">// distributed with this work for additional information</a>
<a name="ln4">// regarding copyright ownership.  The ASF licenses this file</a>
<a name="ln5">// to you under the Apache License, Version 2.0 (the</a>
<a name="ln6">// &quot;License&quot;); you may not use this file except in compliance</a>
<a name="ln7">// with the License.  You may obtain a copy of the License at</a>
<a name="ln8">//</a>
<a name="ln9">//   http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln10">//</a>
<a name="ln11">// Unless required by applicable law or agreed to in writing,</a>
<a name="ln12">// software distributed under the License is distributed on an</a>
<a name="ln13">// &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</a>
<a name="ln14">// KIND, either express or implied.  See the License for the</a>
<a name="ln15">// specific language governing permissions and limitations</a>
<a name="ln16">// under the License.</a>
<a name="ln17">//</a>
<a name="ln18">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln19">//</a>
<a name="ln20">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln21">//</a>
<a name="ln22">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln23">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln24">//</a>
<a name="ln25">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln26">//</a>
<a name="ln27">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln28">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln29">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln30">// under the License.</a>
<a name="ln31">//</a>
<a name="ln32"> </a>
<a name="ln33">#include &quot;yb/client/batcher.h&quot;</a>
<a name="ln34"> </a>
<a name="ln35">#include &lt;algorithm&gt;</a>
<a name="ln36">#include &lt;memory&gt;</a>
<a name="ln37">#include &lt;mutex&gt;</a>
<a name="ln38">#include &lt;set&gt;</a>
<a name="ln39">#include &lt;string&gt;</a>
<a name="ln40">#include &lt;unordered_map&gt;</a>
<a name="ln41">#include &lt;utility&gt;</a>
<a name="ln42">#include &lt;vector&gt;</a>
<a name="ln43"> </a>
<a name="ln44">#include &lt;glog/logging.h&gt;</a>
<a name="ln45"> </a>
<a name="ln46">#include &quot;yb/client/async_rpc.h&quot;</a>
<a name="ln47">#include &quot;yb/client/callbacks.h&quot;</a>
<a name="ln48">#include &quot;yb/client/client.h&quot;</a>
<a name="ln49">#include &quot;yb/client/client-internal.h&quot;</a>
<a name="ln50">#include &quot;yb/client/client_error.h&quot;</a>
<a name="ln51">#include &quot;yb/client/error_collector.h&quot;</a>
<a name="ln52">#include &quot;yb/client/in_flight_op.h&quot;</a>
<a name="ln53">#include &quot;yb/client/meta_cache.h&quot;</a>
<a name="ln54">#include &quot;yb/client/rejection_score_source.h&quot;</a>
<a name="ln55">#include &quot;yb/client/session.h&quot;</a>
<a name="ln56">#include &quot;yb/client/table.h&quot;</a>
<a name="ln57">#include &quot;yb/client/transaction.h&quot;</a>
<a name="ln58">#include &quot;yb/client/yb_op.h&quot;</a>
<a name="ln59"> </a>
<a name="ln60">#include &quot;yb/common/wire_protocol.h&quot;</a>
<a name="ln61">#include &quot;yb/gutil/strings/human_readable.h&quot;</a>
<a name="ln62">#include &quot;yb/gutil/strings/join.h&quot;</a>
<a name="ln63"> </a>
<a name="ln64">#include &quot;yb/util/debug-util.h&quot;</a>
<a name="ln65">#include &quot;yb/util/flag_tags.h&quot;</a>
<a name="ln66">#include &quot;yb/util/logging.h&quot;</a>
<a name="ln67"> </a>
<a name="ln68">// When this flag is set to false and we have separate errors for operation, then batcher would</a>
<a name="ln69">// report IO Error status. Otherwise we will try to combine errors from separate operation to</a>
<a name="ln70">// status of batch. Useful in tests, when we don't need complex error analysis.</a>
<a name="ln71">DEFINE_test_flag(bool, combine_batcher_errors, false,</a>
<a name="ln72">                 &quot;Whether combine errors into batcher status.&quot;);</a>
<a name="ln73"> </a>
<a name="ln74">using std::pair;</a>
<a name="ln75">using std::set;</a>
<a name="ln76">using std::unique_ptr;</a>
<a name="ln77">using std::shared_ptr;</a>
<a name="ln78">using std::unordered_map;</a>
<a name="ln79">using strings::Substitute;</a>
<a name="ln80"> </a>
<a name="ln81">using namespace std::placeholders;</a>
<a name="ln82"> </a>
<a name="ln83">namespace yb {</a>
<a name="ln84"> </a>
<a name="ln85">using tserver::WriteResponsePB;</a>
<a name="ln86">using tserver::WriteResponsePB_PerRowErrorPB;</a>
<a name="ln87"> </a>
<a name="ln88">namespace client {</a>
<a name="ln89"> </a>
<a name="ln90">namespace internal {</a>
<a name="ln91"> </a>
<a name="ln92">// TODO: instead of using a string error message, make Batcher return a status other than IOError.</a>
<a name="ln93">// (https://github.com/YugaByte/yugabyte-db/issues/702)</a>
<a name="ln94">const std::string Batcher::kErrorReachingOutToTServersMsg(</a>
<a name="ln95">    &quot;Errors occured while reaching out to the tablet servers&quot;);</a>
<a name="ln96"> </a>
<a name="ln97">// About lock ordering in this file:</a>
<a name="ln98">// ------------------------------</a>
<a name="ln99">// The locks must be acquired in the following order:</a>
<a name="ln100">//   - Batcher::lock_</a>
<a name="ln101">//   - InFlightOp::lock_</a>
<a name="ln102">//</a>
<a name="ln103">// It's generally important to release all the locks before either calling</a>
<a name="ln104">// a user callback, or chaining to another async function, since that function</a>
<a name="ln105">// may also chain directly to the callback. Without releasing locks first,</a>
<a name="ln106">// the lock ordering may be violated, or a lock may deadlock on itself (these</a>
<a name="ln107">// locks are non-reentrant).</a>
<a name="ln108">// ------------------------------------------------------------</a>
<a name="ln109"> </a>
<a name="ln110">Batcher::Batcher(YBClient* client,</a>
<a name="ln111">                 ErrorCollector* error_collector,</a>
<a name="ln112">                 const YBSessionPtr&amp; session,</a>
<a name="ln113">                 YBTransactionPtr transaction,</a>
<a name="ln114">                 ConsistentReadPoint* read_point,</a>
<a name="ln115">                 bool force_consistent_read)</a>
<a name="ln116">  : client_(client),</a>
<a name="ln117">    weak_session_(session),</a>
<a name="ln118">    error_collector_(error_collector),</a>
<a name="ln119">    next_op_sequence_number_(0),</a>
<a name="ln120">    async_rpc_metrics_(session-&gt;async_rpc_metrics()),</a>
<a name="ln121">    transaction_(std::move(transaction)),</a>
<a name="ln122">    read_point_(read_point),</a>
<a name="ln123">    force_consistent_read_(force_consistent_read) {</a>
<a name="ln124">}</a>
<a name="ln125"> </a>
<a name="ln126">void Batcher::Abort(const Status&amp; status) {</a>
<a name="ln127">  bool run_callback;</a>
<a name="ln128">  {</a>
<a name="ln129">    std::lock_guard&lt;decltype(mutex_)&gt; lock(mutex_);</a>
<a name="ln130">    state_ = BatcherState::kAborted;</a>
<a name="ln131"> </a>
<a name="ln132">    InFlightOps to_abort;</a>
<a name="ln133">    for (auto&amp; op : ops_) {</a>
<a name="ln134">      if (op-&gt;state.load(std::memory_order_acquire) == InFlightOpState::kBufferedToTabletServer) {</a>
<a name="ln135">        to_abort.push_back(op);</a>
<a name="ln136">      }</a>
<a name="ln137">    }</a>
<a name="ln138"> </a>
<a name="ln139">    for (auto&amp; op : to_abort) {</a>
<a name="ln140">      VLOG_WITH_PREFIX(1) &lt;&lt; &quot;Aborting op: &quot; &lt;&lt; op-&gt;ToString();</a>
<a name="ln141">      MarkInFlightOpFailedUnlocked(op, status);</a>
<a name="ln142">    }</a>
<a name="ln143"> </a>
<a name="ln144">    run_callback = flush_callback_;</a>
<a name="ln145">  }</a>
<a name="ln146"> </a>
<a name="ln147">  if (run_callback) {</a>
<a name="ln148">    RunCallback(status);</a>
<a name="ln149">  }</a>
<a name="ln150">}</a>
<a name="ln151"> </a>
<a name="ln152">Batcher::~Batcher() {</a>
<a name="ln153">  if (PREDICT_FALSE(!ops_.empty())) {</a>
<a name="ln154">    for (auto&amp; op : ops_) {</a>
<a name="ln155">      LOG_WITH_PREFIX(ERROR) &lt;&lt; &quot;Orphaned op: &quot; &lt;&lt; op-&gt;ToString();</a>
<a name="ln156">    }</a>
<a name="ln157">    LOG_WITH_PREFIX(FATAL) &lt;&lt; &quot;ops_ not empty&quot;;</a>
<a name="ln158">  }</a>
<a name="ln159">  CHECK(state_ == BatcherState::kComplete || state_ == BatcherState::kAborted)</a>
<a name="ln160">      &lt;&lt; &quot;Bad state: &quot; &lt;&lt; state_;</a>
<a name="ln161">}</a>
<a name="ln162"> </a>
<a name="ln163">void Batcher::SetTimeout(MonoDelta timeout) {</a>
<a name="ln164">  CHECK_GE(timeout, MonoDelta::kZero);</a>
<a name="ln165">  std::lock_guard&lt;decltype(mutex_)&gt; lock(mutex_);</a>
<a name="ln166">  timeout_ = timeout;</a>
<a name="ln167">}</a>
<a name="ln168"> </a>
<a name="ln169">bool Batcher::HasPendingOperations() const {</a>
<a name="ln170">  std::lock_guard&lt;decltype(mutex_)&gt; lock(mutex_);</a>
<a name="ln171">  return !ops_.empty();</a>
<a name="ln172">}</a>
<a name="ln173"> </a>
<a name="ln174">int Batcher::CountBufferedOperations() const {</a>
<a name="ln175">  std::lock_guard&lt;decltype(mutex_)&gt; lock(mutex_);</a>
<a name="ln176">  if (state_ == BatcherState::kGatheringOps) {</a>
<a name="ln177">    return ops_.size();</a>
<a name="ln178">  } else {</a>
<a name="ln179">    // If we've already started to flush, then the ops aren't</a>
<a name="ln180">    // considered &quot;buffered&quot;.</a>
<a name="ln181">    return 0;</a>
<a name="ln182">  }</a>
<a name="ln183">}</a>
<a name="ln184"> </a>
<a name="ln185">void Batcher::CheckForFinishedFlush() {</a>
<a name="ln186">  YBSessionPtr session;</a>
<a name="ln187">  {</a>
<a name="ln188">    std::lock_guard&lt;decltype(mutex_)&gt; lock(mutex_);</a>
<a name="ln189">    if (!ops_.empty()) {</a>
<a name="ln190">      // Did not finish yet.</a>
<a name="ln191">      return;</a>
<a name="ln192">    }</a>
<a name="ln193"> </a>
<a name="ln194">    // Possible cases when we should ignore this check:</a>
<a name="ln195">    // kComplete - because of race condition CheckForFinishedFlush could be invoked from 2 threads</a>
<a name="ln196">    //             and one of them just finished last operation.</a>
<a name="ln197">    // kGatheringOps - lookup failure happened while batcher is getting filled with operations.</a>
<a name="ln198">    if (state_ == BatcherState::kComplete || state_ == BatcherState::kGatheringOps) {</a>
<a name="ln199">      return;</a>
<a name="ln200">    }</a>
<a name="ln201"> </a>
<a name="ln202">    if (state_ != BatcherState::kResolvingTablets &amp;&amp;</a>
<a name="ln203">        state_ != BatcherState::kTransactionReady) {</a>
<a name="ln204">      LOG_WITH_PREFIX(DFATAL) &lt;&lt; &quot;Batcher finished in a wrong state: &quot; &lt;&lt; state_;</a>
<a name="ln205">      return;</a>
<a name="ln206">    }</a>
<a name="ln207"> </a>
<a name="ln208">    session = weak_session_.lock();</a>
<a name="ln209">    state_ = BatcherState::kComplete;</a>
<a name="ln210">  }</a>
<a name="ln211"> </a>
<a name="ln212">  if (session) {</a>
<a name="ln213">    // Important to do this outside of the lock so that we don't have</a>
<a name="ln214">    // a lock inversion deadlock -- the session lock should always</a>
<a name="ln215">    // come before the batcher lock.</a>
<a name="ln216">    session-&gt;FlushFinished(this);</a>
<a name="ln217">  }</a>
<a name="ln218"> </a>
<a name="ln219">  Status s;</a>
<a name="ln220">  if (!combined_error_.ok()) {</a>
<a name="ln221">    s = combined_error_;</a>
<a name="ln222">  } else if (had_errors_.load(std::memory_order_acquire)) {</a>
<a name="ln223">    // In the general case, the user is responsible for fetching errors from the error collector.</a>
<a name="ln224">    // TODO: use the Combined status here, so it is easy to recognize.</a>
<a name="ln225">    // https://github.com/YugaByte/yugabyte-db/issues/702</a>
<a name="ln226">    s = STATUS(IOError, kErrorReachingOutToTServersMsg);</a>
<a name="ln227">  }</a>
<a name="ln228"> </a>
<a name="ln229">  RunCallback(s);</a>
<a name="ln230">}</a>
<a name="ln231"> </a>
<a name="ln232">void Batcher::RunCallback(const Status&amp; status) {</a>
<a name="ln233">  auto runnable = std::make_shared&lt;yb::FunctionRunnable&gt;(</a>
<a name="ln234">      [ cb{std::move(flush_callback_)}, status ]() { cb(status); });</a>
<a name="ln235">  if (!client_-&gt;callback_threadpool() || !client_-&gt;callback_threadpool()-&gt;Submit(runnable).ok()) {</a>
<a name="ln236">    runnable-&gt;Run();</a>
<a name="ln237">  }</a>
<a name="ln238">}</a>
<a name="ln239"> </a>
<a name="ln240">CoarseTimePoint Batcher::ComputeDeadlineUnlocked() const {</a>
<a name="ln241">  MonoDelta timeout = timeout_;</a>
<a name="ln242">  if (PREDICT_FALSE(!timeout.Initialized())) {</a>
<a name="ln243">    YB_LOG_EVERY_N(WARNING, 100000) &lt;&lt; &quot;Client writing with no timeout set, using 60 seconds.\n&quot;</a>
<a name="ln244">                                    &lt;&lt; GetStackTrace();</a>
<a name="ln245">    timeout = MonoDelta::FromSeconds(60);</a>
<a name="ln246">  }</a>
<a name="ln247">  return CoarseMonoClock::now() + timeout;</a>
<a name="ln248">}</a>
<a name="ln249"> </a>
<a name="ln250">void Batcher::FlushAsync(StatusFunctor callback) {</a>
<a name="ln251">  size_t operations_count;</a>
<a name="ln252">  {</a>
<a name="ln253">    std::lock_guard&lt;decltype(mutex_)&gt; lock(mutex_);</a>
<a name="ln254">    CHECK_EQ(state_, BatcherState::kGatheringOps);</a>
<a name="ln255">    state_ = BatcherState::kResolvingTablets;</a>
<a name="ln256">    flush_callback_ = std::move(callback);</a>
<a name="ln257">    deadline_ = ComputeDeadlineUnlocked();</a>
<a name="ln258">    operations_count = ops_.size();</a>
<a name="ln259">  }</a>
<a name="ln260"> </a>
<a name="ln261">  auto transaction = this-&gt;transaction();</a>
<a name="ln262">  if (transaction) {</a>
<a name="ln263">    transaction-&gt;ExpectOperations(operations_count);</a>
<a name="ln264">  }</a>
<a name="ln265"> </a>
<a name="ln266">  // In the case that we have nothing buffered, just call the callback</a>
<a name="ln267">  // immediately. Otherwise, the callback will be called by the last callback</a>
<a name="ln268">  // when it sees that the ops_ list has drained.</a>
<a name="ln269">  CheckForFinishedFlush();</a>
<a name="ln270"> </a>
<a name="ln271">  // Trigger flushing of all of the buffers. Some of these may already have</a>
<a name="ln272">  // been flushed through an async path, but it's idempotent - a second call</a>
<a name="ln273">  // to flush would just be a no-op.</a>
<a name="ln274">  //</a>
<a name="ln275">  // If some of the operations are still in-flight, then they'll get sent</a>
<a name="ln276">  // when they hit 'per_tablet_ops', since our state is now kResolvingTablets.</a>
<a name="ln277">  FlushBuffersIfReady();</a>
<a name="ln278">}</a>
<a name="ln279"> </a>
<a name="ln280">Status Batcher::Add(shared_ptr&lt;YBOperation&gt; yb_op) {</a>
<a name="ln281">  // As soon as we get the op, start looking up where it belongs,</a>
<a name="ln282">  // so that when the user calls Flush, we are ready to go.</a>
<a name="ln283">  auto in_flight_op = std::make_shared&lt;InFlightOp&gt;(yb_op);</a>
<a name="ln284">  RETURN_NOT_OK(yb_op-&gt;GetPartitionKey(&amp;in_flight_op-&gt;partition_key));</a>
<a name="ln285"> </a>
<a name="ln286">  if (VERIFY_RESULT(yb_op-&gt;MaybeRefreshTablePartitions())) {</a>
<a name="ln287">    client_-&gt;data_-&gt;meta_cache_-&gt;InvalidateTableCache(yb_op-&gt;table()-&gt;id());</a>
<a name="ln288">  }</a>
<a name="ln289"> </a>
<a name="ln290">  if (yb_op-&gt;table()-&gt;partition_schema().IsHashPartitioning()) {</a>
<a name="ln291">    switch (yb_op-&gt;type()) {</a>
<a name="ln292">      case YBOperation::Type::QL_READ:</a>
<a name="ln293">        if (!in_flight_op-&gt;partition_key.empty()) {</a>
<a name="ln294">          down_cast&lt;YBqlOp *&gt;(yb_op.get())-&gt;SetHashCode(</a>
<a name="ln295">              PartitionSchema::DecodeMultiColumnHashValue(in_flight_op-&gt;partition_key));</a>
<a name="ln296">        }</a>
<a name="ln297">        break;</a>
<a name="ln298">      case YBOperation::Type::QL_WRITE:</a>
<a name="ln299">        down_cast&lt;YBqlOp*&gt;(yb_op.get())-&gt;SetHashCode(</a>
<a name="ln300">            PartitionSchema::DecodeMultiColumnHashValue(in_flight_op-&gt;partition_key));</a>
<a name="ln301">        break;</a>
<a name="ln302">      case YBOperation::Type::REDIS_READ:</a>
<a name="ln303">        down_cast&lt;YBRedisReadOp*&gt;(yb_op.get())-&gt;SetHashCode(</a>
<a name="ln304">            PartitionSchema::DecodeMultiColumnHashValue(in_flight_op-&gt;partition_key));</a>
<a name="ln305">        break;</a>
<a name="ln306">      case YBOperation::Type::REDIS_WRITE:</a>
<a name="ln307">        down_cast&lt;YBRedisWriteOp*&gt;(yb_op.get())-&gt;SetHashCode(</a>
<a name="ln308">            PartitionSchema::DecodeMultiColumnHashValue(in_flight_op-&gt;partition_key));</a>
<a name="ln309">        break;</a>
<a name="ln310">      case YBOperation::Type::PGSQL_READ:</a>
<a name="ln311">        if (!in_flight_op-&gt;partition_key.empty()) {</a>
<a name="ln312">          down_cast&lt;YBPgsqlReadOp *&gt;(yb_op.get())-&gt;SetHashCode(</a>
<a name="ln313">              PartitionSchema::DecodeMultiColumnHashValue(in_flight_op-&gt;partition_key));</a>
<a name="ln314">        }</a>
<a name="ln315">        break;</a>
<a name="ln316">      case YBOperation::Type::PGSQL_WRITE:</a>
<a name="ln317">        down_cast&lt;YBPgsqlWriteOp*&gt;(yb_op.get())-&gt;SetHashCode(</a>
<a name="ln318">            PartitionSchema::DecodeMultiColumnHashValue(in_flight_op-&gt;partition_key));</a>
<a name="ln319">        break;</a>
<a name="ln320">    }</a>
<a name="ln321">  }</a>
<a name="ln322"> </a>
<a name="ln323">  AddInFlightOp(in_flight_op);</a>
<a name="ln324">  VLOG_WITH_PREFIX(3) &lt;&lt; &quot;Looking up tablet for &quot; &lt;&lt; in_flight_op-&gt;yb_op-&gt;ToString()</a>
<a name="ln325">                      &lt;&lt; &quot; partition key: &quot;</a>
<a name="ln326">                      &lt;&lt; Slice(in_flight_op-&gt;partition_key).ToDebugHexString();</a>
<a name="ln327"> </a>
<a name="ln328">  if (yb_op-&gt;tablet()) {</a>
<a name="ln329">    TabletLookupFinished(std::move(in_flight_op), yb_op-&gt;tablet());</a>
<a name="ln330">  } else {</a>
<a name="ln331">    // deadline_ is set in FlushAsync(), after all Add() calls are done, so</a>
<a name="ln332">    // here we're forced to create a new deadline.</a>
<a name="ln333">    auto deadline = ComputeDeadlineUnlocked();</a>
<a name="ln334">    client_-&gt;data_-&gt;meta_cache_-&gt;LookupTabletByKey(</a>
<a name="ln335">        in_flight_op-&gt;yb_op-&gt;table(), in_flight_op-&gt;partition_key, deadline,</a>
<a name="ln336">        std::bind(&amp;Batcher::TabletLookupFinished, BatcherPtr(this), in_flight_op, _1));</a>
<a name="ln337">  }</a>
<a name="ln338">  return Status::OK();</a>
<a name="ln339">}</a>
<a name="ln340"> </a>
<a name="ln341">void Batcher::AddInFlightOp(const InFlightOpPtr&amp; op) {</a>
<a name="ln342">  LOG_IF(DFATAL, op-&gt;state != InFlightOpState::kLookingUpTablet)</a>
<a name="ln343">      &lt;&lt; &quot;Adding in flight op in a wrong state: &quot; &lt;&lt; op-&gt;state;</a>
<a name="ln344"> </a>
<a name="ln345">  std::lock_guard&lt;decltype(mutex_)&gt; lock(mutex_);</a>
<a name="ln346">  CHECK_EQ(state_, BatcherState::kGatheringOps);</a>
<a name="ln347">  CHECK(ops_.insert(op).second);</a>
<a name="ln348">  op-&gt;sequence_number_ = next_op_sequence_number_++;</a>
<a name="ln349">  ++outstanding_lookups_;</a>
<a name="ln350">}</a>
<a name="ln351"> </a>
<a name="ln352">bool Batcher::IsAbortedUnlocked() const {</a>
<a name="ln353">  return state_ == BatcherState::kAborted;</a>
<a name="ln354">}</a>
<a name="ln355"> </a>
<a name="ln356">void Batcher::CombineErrorUnlocked(const InFlightOpPtr&amp; in_flight_op, const Status&amp; status) {</a>
<a name="ln357">  error_collector_-&gt;AddError(in_flight_op-&gt;yb_op, status);</a>
<a name="ln358">  if (FLAGS_TEST_combine_batcher_errors) {</a>
<a name="ln359">    if (combined_error_.ok()) {</a>
<a name="ln360">      combined_error_ = status.CloneAndPrepend(in_flight_op-&gt;ToString());</a>
<a name="ln361">    } else if (!combined_error_.IsCombined() &amp;&amp; combined_error_.code() != status.code()) {</a>
<a name="ln362">      combined_error_ = STATUS(Combined, &quot;Multiple failures&quot;);</a>
<a name="ln363">    }</a>
<a name="ln364">  }</a>
<a name="ln365">  had_errors_.store(true, std::memory_order_release);</a>
<a name="ln366">}</a>
<a name="ln367"> </a>
<a name="ln368">void Batcher::MarkInFlightOpFailedUnlocked(const InFlightOpPtr&amp; in_flight_op, const Status&amp; s) {</a>
<a name="ln369">  CHECK_EQ(1, ops_.erase(in_flight_op)) &lt;&lt; &quot;Could not remove op &quot; &lt;&lt; in_flight_op-&gt;ToString()</a>
<a name="ln370">                                        &lt;&lt; &quot; from in-flight list&quot;;</a>
<a name="ln371">  if (ClientError(s) == ClientErrorCode::kTablePartitionsAreStale) {</a>
<a name="ln372">    // MetaCache returns ClientErrorCode::kTablePartitionsAreStale error for tablet lookup request</a>
<a name="ln373">    // in case GetTabletLocations from master returns newer version of table partitions.</a>
<a name="ln374">    // Since MetaCache has no write access to YBTable, it just returns an error which we receive</a>
<a name="ln375">    // here and mark the table partitions as stale, so they will be refetched on retry.</a>
<a name="ln376">    // TODO(tsplit): handle splitting-related retries on YB level instead of returning back to</a>
<a name="ln377">    // client app/driver.</a>
<a name="ln378">    in_flight_op-&gt;yb_op-&gt;MarkTablePartitionsAsStale();</a>
<a name="ln379">  }</a>
<a name="ln380">  CombineErrorUnlocked(in_flight_op, s);</a>
<a name="ln381">}</a>
<a name="ln382"> </a>
<a name="ln383">void Batcher::TabletLookupFinished(</a>
<a name="ln384">    InFlightOpPtr op, const Result&lt;internal::RemoteTabletPtr&gt;&amp; lookup_result) {</a>
<a name="ln385">  // Acquire the batcher lock early to atomically:</a>
<a name="ln386">  // 1. Test if the batcher was aborted, and</a>
<a name="ln387">  // 2. Change the op state.</a>
<a name="ln388"> </a>
<a name="ln389">  bool all_lookups_finished;</a>
<a name="ln390">  {</a>
<a name="ln391">    std::lock_guard&lt;decltype(mutex_)&gt; lock(mutex_);</a>
<a name="ln392"> </a>
<a name="ln393">    --outstanding_lookups_;</a>
<a name="ln394">    all_lookups_finished = outstanding_lookups_ == 0;</a>
<a name="ln395"> </a>
<a name="ln396">    if (IsAbortedUnlocked()) {</a>
<a name="ln397">      VLOG_WITH_PREFIX(1) &lt;&lt; &quot;Aborted batch: TabletLookupFinished for &quot; &lt;&lt; op-&gt;yb_op-&gt;ToString();</a>
<a name="ln398">      MarkInFlightOpFailedUnlocked(op, STATUS(Aborted, &quot;Batch aborted&quot;));</a>
<a name="ln399">      // 'op' is deleted by above function.</a>
<a name="ln400">      return;</a>
<a name="ln401">    }</a>
<a name="ln402"> </a>
<a name="ln403">    if (state_ != BatcherState::kResolvingTablets &amp;&amp; state_ != BatcherState::kGatheringOps) {</a>
<a name="ln404">      LOG_WITH_PREFIX(DFATAL) &lt;&lt; &quot;Lookup finished in wrong state: &quot; &lt;&lt; ToString(state_);</a>
<a name="ln405">      return;</a>
<a name="ln406">    }</a>
<a name="ln407"> </a>
<a name="ln408">    if (lookup_result.ok()) {</a>
<a name="ln409">      op-&gt;tablet = *lookup_result;</a>
<a name="ln410">#ifndef NDEBUG</a>
<a name="ln411">      const Partition&amp; partition = op-&gt;tablet-&gt;partition();</a>
<a name="ln412"> </a>
<a name="ln413">      bool partition_contains_row = false;</a>
<a name="ln414">      std::string partition_key;</a>
<a name="ln415">      switch (op-&gt;yb_op-&gt;type()) {</a>
<a name="ln416">        case YBOperation::QL_READ: FALLTHROUGH_INTENDED;</a>
<a name="ln417">        case YBOperation::QL_WRITE: FALLTHROUGH_INTENDED;</a>
<a name="ln418">        case YBOperation::PGSQL_READ: FALLTHROUGH_INTENDED;</a>
<a name="ln419">        case YBOperation::PGSQL_WRITE: FALLTHROUGH_INTENDED;</a>
<a name="ln420">        case YBOperation::REDIS_READ: FALLTHROUGH_INTENDED;</a>
<a name="ln421">        case YBOperation::REDIS_WRITE: {</a>
<a name="ln422">          CHECK_OK(op-&gt;yb_op-&gt;GetPartitionKey(&amp;partition_key));</a>
<a name="ln423">          partition_contains_row = partition.ContainsKey(partition_key);</a>
<a name="ln424">          break;</a>
<a name="ln425">        }</a>
<a name="ln426">      }</a>
<a name="ln427"> </a>
<a name="ln428">      if (!partition_contains_row) {</a>
<a name="ln429">        const Schema&amp; schema = GetSchema(op-&gt;yb_op-&gt;table()-&gt;schema());</a>
<a name="ln430">        const PartitionSchema&amp; partition_schema = op-&gt;yb_op-&gt;table()-&gt;partition_schema();</a>
<a name="ln431">        LOG_WITH_PREFIX(DFATAL)</a>
<a name="ln432">            &lt;&lt; &quot;Row &quot; &lt;&lt; op-&gt;yb_op-&gt;ToString()</a>
<a name="ln433">            &lt;&lt; &quot; not in partition &quot; &lt;&lt; partition_schema.PartitionDebugString(partition, schema)</a>
<a name="ln434">            &lt;&lt; &quot; partition_key: '&quot; &lt;&lt; Slice(partition_key).ToDebugHexString() &lt;&lt; &quot;'&quot;;</a>
<a name="ln435">      }</a>
<a name="ln436">#endif</a>
<a name="ln437">    }</a>
<a name="ln438"> </a>
<a name="ln439">    VLOG_WITH_PREFIX(3) &lt;&lt; &quot;TabletLookupFinished for &quot; &lt;&lt; op-&gt;yb_op-&gt;ToString() &lt;&lt; &quot;: &quot;</a>
<a name="ln440">                        &lt;&lt; lookup_result &lt;&lt; &quot;, outstanding lookups: &quot; &lt;&lt; outstanding_lookups_;</a>
<a name="ln441"> </a>
<a name="ln442">    if (lookup_result.ok()) {</a>
<a name="ln443">      CHECK(*lookup_result);</a>
<a name="ln444"> </a>
<a name="ln445">      auto expected_state = InFlightOpState::kLookingUpTablet;</a>
<a name="ln446">      if (op-&gt;state.compare_exchange_strong(</a>
<a name="ln447">          expected_state, InFlightOpState::kBufferedToTabletServer, std::memory_order_acq_rel)) {</a>
<a name="ln448">        ops_queue_.push_back(op);</a>
<a name="ln449">      } else {</a>
<a name="ln450">        LOG_WITH_PREFIX(DFATAL) &lt;&lt; &quot;Finished lookup for operation in a bad state: &quot;</a>
<a name="ln451">                                &lt;&lt; ToString(expected_state);</a>
<a name="ln452">      }</a>
<a name="ln453">    } else {</a>
<a name="ln454">      MarkInFlightOpFailedUnlocked(op, lookup_result.status());</a>
<a name="ln455">    }</a>
<a name="ln456">  }</a>
<a name="ln457"> </a>
<a name="ln458">  if (!lookup_result.ok()) {</a>
<a name="ln459">    CheckForFinishedFlush();</a>
<a name="ln460">  }</a>
<a name="ln461"> </a>
<a name="ln462">  if (all_lookups_finished) {</a>
<a name="ln463">    FlushBuffersIfReady();</a>
<a name="ln464">  }</a>
<a name="ln465">}</a>
<a name="ln466"> </a>
<a name="ln467">void Batcher::TransactionReady(const Status&amp; status, const BatcherPtr&amp; self) {</a>
<a name="ln468">  if (status.ok()) {</a>
<a name="ln469">    ExecuteOperations(Initial::kFalse);</a>
<a name="ln470">  } else {</a>
<a name="ln471">    Abort(status);</a>
<a name="ln472">  }</a>
<a name="ln473">}</a>
<a name="ln474"> </a>
<a name="ln475">void Batcher::FlushBuffersIfReady() {</a>
<a name="ln476">  // We're only ready to flush if both of the following conditions are true:</a>
<a name="ln477">  // 1. The batcher is in the &quot;resolving tablets&quot; state (i.e. FlushAsync was called).</a>
<a name="ln478">  // 2. All outstanding ops have finished lookup. Why? To avoid a situation</a>
<a name="ln479">  //    where ops are flushed one by one as they finish lookup.</a>
<a name="ln480"> </a>
<a name="ln481">  {</a>
<a name="ln482">    std::lock_guard&lt;decltype(mutex_)&gt; lock(mutex_);</a>
<a name="ln483">    if (outstanding_lookups_ != 0) {</a>
<a name="ln484">      // FlushBuffersIfReady is also invoked when all lookups finished, so it ok to just return</a>
<a name="ln485">      // here.</a>
<a name="ln486">      VLOG_WITH_PREFIX(3) &lt;&lt; &quot;FlushBuffersIfReady: &quot; &lt;&lt; outstanding_lookups_</a>
<a name="ln487">                          &lt;&lt; &quot; ops still in lookup&quot;;</a>
<a name="ln488">      return;</a>
<a name="ln489">    }</a>
<a name="ln490"> </a>
<a name="ln491">    if (state_ != BatcherState::kResolvingTablets) {</a>
<a name="ln492">      return;</a>
<a name="ln493">    }</a>
<a name="ln494"> </a>
<a name="ln495">    state_ = BatcherState::kTransactionPrepare;</a>
<a name="ln496">  }</a>
<a name="ln497"> </a>
<a name="ln498">  // All operations were added, and tablets for them were resolved.</a>
<a name="ln499">  // So we could sort them.</a>
<a name="ln500">  std::sort(ops_queue_.begin(),</a>
<a name="ln501">            ops_queue_.end(),</a>
<a name="ln502">            [](const InFlightOpPtr&amp; lhs, const InFlightOpPtr&amp; rhs) {</a>
<a name="ln503">    if (lhs-&gt;tablet.get() == rhs-&gt;tablet.get()) {</a>
<a name="ln504">      auto lgroup = lhs-&gt;yb_op-&gt;group();</a>
<a name="ln505">      auto rgroup = rhs-&gt;yb_op-&gt;group();</a>
<a name="ln506">      if (lgroup != rgroup) {</a>
<a name="ln507">        return lgroup &lt; rgroup;</a>
<a name="ln508">      }</a>
<a name="ln509">      return lhs-&gt;sequence_number_ &lt; rhs-&gt;sequence_number_;</a>
<a name="ln510">    }</a>
<a name="ln511">    return lhs-&gt;tablet.get() &lt; rhs-&gt;tablet.get();</a>
<a name="ln512">  });</a>
<a name="ln513"> </a>
<a name="ln514">  ExecuteOperations(Initial::kTrue);</a>
<a name="ln515">}</a>
<a name="ln516"> </a>
<a name="ln517">void Batcher::ExecuteOperations(Initial initial) {</a>
<a name="ln518">  auto transaction = this-&gt;transaction();</a>
<a name="ln519">  if (transaction) {</a>
<a name="ln520">    // If this Batcher is executed in context of transaction,</a>
<a name="ln521">    // then this transaction should initialize metadata used by RPC calls.</a>
<a name="ln522">    //</a>
<a name="ln523">    // If transaction is not yet ready to do it, then it will notify as via provided when</a>
<a name="ln524">    // it could be done.</a>
<a name="ln525">    if (!transaction-&gt;Prepare(ops_queue_,</a>
<a name="ln526">                              force_consistent_read_,</a>
<a name="ln527">                              deadline_,</a>
<a name="ln528">                              initial,</a>
<a name="ln529">                              std::bind(&amp;Batcher::TransactionReady, this, _1, BatcherPtr(this)),</a>
<a name="ln530">                              &amp;transaction_metadata_)) {</a>
<a name="ln531">      return;</a>
<a name="ln532">    }</a>
<a name="ln533">  }</a>
<a name="ln534"> </a>
<a name="ln535">  {</a>
<a name="ln536">    std::lock_guard&lt;decltype(mutex_)&gt; lock(mutex_);</a>
<a name="ln537">    if (state_ != BatcherState::kTransactionPrepare) {</a>
<a name="ln538">      // Batcher was aborted.</a>
<a name="ln539">      LOG_IF(DFATAL, state_ != BatcherState::kAborted)</a>
<a name="ln540">          &lt;&lt; &quot;Batcher in a wrong state at the moment the transaction became ready: &quot; &lt;&lt; state_;</a>
<a name="ln541">      return;</a>
<a name="ln542">    }</a>
<a name="ln543">    state_ = BatcherState::kTransactionReady;</a>
<a name="ln544">  }</a>
<a name="ln545"> </a>
<a name="ln546">  // All asynchronous requests were completed, so we could access ops_queue_ w/o holding the lock.</a>
<a name="ln547">  if (ops_queue_.empty()) {</a>
<a name="ln548">    return;</a>
<a name="ln549">  }</a>
<a name="ln550"> </a>
<a name="ln551">  const bool force_consistent_read = force_consistent_read_ || this-&gt;transaction();</a>
<a name="ln552"> </a>
<a name="ln553">  const size_t ops_number = ops_queue_.size();</a>
<a name="ln554"> </a>
<a name="ln555">  // Use big enough value for preallocated storage, to avoid unnecessary allocations.</a>
<a name="ln556">  boost::container::small_vector&lt;std::shared_ptr&lt;AsyncRpc&gt;, 40&gt; rpcs;</a>
<a name="ln557"> </a>
<a name="ln558">  // Now flush the ops for each tablet.</a>
<a name="ln559">  auto start = ops_queue_.begin();</a>
<a name="ln560">  auto start_group = (**start).yb_op-&gt;group();</a>
<a name="ln561">  for (auto it = start; it != ops_queue_.end(); ++it) {</a>
<a name="ln562">    auto it_group = (**it).yb_op-&gt;group();</a>
<a name="ln563">    // Aggregate and flush the ops so far if either:</a>
<a name="ln564">    //   - we reached the next tablet or group</a>
<a name="ln565">    if ((**it).tablet.get() != (**start).tablet.get() ||</a>
<a name="ln566">        start_group != it_group) {</a>
<a name="ln567">      // Consistent read is not required when whole batch fits into one command.</a>
<a name="ln568">      bool need_consistent_read = force_consistent_read || start != ops_queue_.begin() ||</a>
<a name="ln569">                                  it != ops_queue_.end();</a>
<a name="ln570">      rpcs.push_back(CreateRpc(</a>
<a name="ln571">          start-&gt;get()-&gt;tablet.get(), start, it, /* allow_local_calls_in_curr_thread */ false,</a>
<a name="ln572">          need_consistent_read));</a>
<a name="ln573">      start = it;</a>
<a name="ln574">      start_group = it_group;</a>
<a name="ln575">    }</a>
<a name="ln576">  }</a>
<a name="ln577"> </a>
<a name="ln578">  // Consistent read is not required when whole batch fits into one command.</a>
<a name="ln579">  bool need_consistent_read = force_consistent_read || start != ops_queue_.begin();</a>
<a name="ln580">  rpcs.push_back(CreateRpc(</a>
<a name="ln581">      start-&gt;get()-&gt;tablet.get(), start, ops_queue_.end(),</a>
<a name="ln582">      allow_local_calls_in_curr_thread_, need_consistent_read));</a>
<a name="ln583"> </a>
<a name="ln584">  LOG_IF(DFATAL, ops_number != ops_queue_.size())</a>
<a name="ln585">    &lt;&lt; &quot;Ops queue was modified while creating RPCs&quot;;</a>
<a name="ln586">  ops_queue_.clear();</a>
<a name="ln587"> </a>
<a name="ln588">  for (const auto&amp; rpc : rpcs) {</a>
<a name="ln589">    rpc-&gt;SendRpc();</a>
<a name="ln590">  }</a>
<a name="ln591">}</a>
<a name="ln592"> </a>
<a name="ln593">rpc::Messenger* Batcher::messenger() const {</a>
<a name="ln594">  return client_-&gt;messenger();</a>
<a name="ln595">}</a>
<a name="ln596"> </a>
<a name="ln597">rpc::ProxyCache&amp; Batcher::proxy_cache() const {</a>
<a name="ln598">  return client_-&gt;proxy_cache();</a>
<a name="ln599">}</a>
<a name="ln600"> </a>
<a name="ln601">YBTransactionPtr Batcher::transaction() const {</a>
<a name="ln602">  return transaction_;</a>
<a name="ln603">}</a>
<a name="ln604"> </a>
<a name="ln605">const std::string&amp; Batcher::proxy_uuid() const {</a>
<a name="ln606">  return client_-&gt;proxy_uuid();</a>
<a name="ln607">}</a>
<a name="ln608"> </a>
<a name="ln609">const ClientId&amp; Batcher::client_id() const {</a>
<a name="ln610">  return client_-&gt;id();</a>
<a name="ln611">}</a>
<a name="ln612"> </a>
<a name="ln613">std::pair&lt;RetryableRequestId, RetryableRequestId&gt; Batcher::NextRequestIdAndMinRunningRequestId(</a>
<a name="ln614">    const TabletId&amp; tablet_id) {</a>
<a name="ln615">  return client_-&gt;NextRequestIdAndMinRunningRequestId(tablet_id);</a>
<a name="ln616">}</a>
<a name="ln617"> </a>
<a name="ln618">void Batcher::RequestFinished(const TabletId&amp; tablet_id, RetryableRequestId request_id) {</a>
<a name="ln619">  client_-&gt;RequestFinished(tablet_id, request_id);</a>
<a name="ln620">}</a>
<a name="ln621"> </a>
<a name="ln622">std::shared_ptr&lt;AsyncRpc&gt; Batcher::CreateRpc(</a>
<a name="ln623">    RemoteTablet* tablet, InFlightOps::const_iterator begin, InFlightOps::const_iterator end,</a>
<a name="ln624">    const bool allow_local_calls_in_curr_thread, const bool need_consistent_read) {</a>
<a name="ln625">  VLOG_WITH_PREFIX(3) &lt;&lt; &quot;FlushBuffersIfReady: already in flushing state, immediately flushing to &quot;</a>
<a name="ln626">                      &lt;&lt; tablet-&gt;tablet_id();</a>
<a name="ln627"> </a>
<a name="ln628">  CHECK(begin != end);</a>
<a name="ln629"> </a>
<a name="ln630">  // Create and send an RPC that aggregates the ops. The RPC is freed when</a>
<a name="ln631">  // its callback completes.</a>
<a name="ln632">  //</a>
<a name="ln633">  // The RPC object takes ownership of the in flight ops.</a>
<a name="ln634">  // The underlying YB OP is not directly owned, only a reference is kept.</a>
<a name="ln635"> </a>
<a name="ln636">  // Split the read operations according to consistency levels since based on consistency</a>
<a name="ln637">  // levels the read algorithm would differ.</a>
<a name="ln638">  InFlightOps ops(begin, end);</a>
<a name="ln639">  auto op_group = (**begin).yb_op-&gt;group();</a>
<a name="ln640">  AsyncRpcData data{this, tablet, allow_local_calls_in_curr_thread, need_consistent_read,</a>
<a name="ln641">                    hybrid_time_for_write_, std::move(ops)};</a>
<a name="ln642">  switch (op_group) {</a>
<a name="ln643">    case OpGroup::kWrite:</a>
<a name="ln644">      return std::make_shared&lt;WriteRpc&gt;(&amp;data);</a>
<a name="ln645">    case OpGroup::kLeaderRead:</a>
<a name="ln646">      return std::make_shared&lt;ReadRpc&gt;(&amp;data, YBConsistencyLevel::STRONG);</a>
<a name="ln647">    case OpGroup::kConsistentPrefixRead:</a>
<a name="ln648">      return std::make_shared&lt;ReadRpc&gt;(&amp;data, YBConsistencyLevel::CONSISTENT_PREFIX);</a>
<a name="ln649">  }</a>
<a name="ln650">  FATAL_INVALID_ENUM_VALUE(OpGroup, op_group);</a>
<a name="ln651">}</a>
<a name="ln652"> </a>
<a name="ln653">using tserver::ReadResponsePB;</a>
<a name="ln654"> </a>
<a name="ln655">void Batcher::AddOpCountMismatchError() {</a>
<a name="ln656">  // TODO: how to handle this kind of error where the array of response PB's don't match</a>
<a name="ln657">  //       the size of the array of requests. We don't have a specific YBOperation to</a>
<a name="ln658">  //       create an error with, because there are multiple YBOps in one Rpc.</a>
<a name="ln659">  LOG_WITH_PREFIX(DFATAL) &lt;&lt; &quot;Received wrong number of responses compared to request(s) sent.&quot;;</a>
<a name="ln660">}</a>
<a name="ln661"> </a>
<a name="ln662">void Batcher::RemoveInFlightOpsAfterFlushing(</a>
<a name="ln663">    const InFlightOps&amp; ops, const Status&amp; status, FlushExtraResult flush_extra_result) {</a>
<a name="ln664">  auto transaction = this-&gt;transaction();</a>
<a name="ln665">  if (transaction) {</a>
<a name="ln666">    transaction-&gt;Flushed(ops, flush_extra_result.used_read_time, status);</a>
<a name="ln667">  }</a>
<a name="ln668">  if (status.ok() &amp;&amp; read_point_) {</a>
<a name="ln669">    read_point_-&gt;UpdateClock(flush_extra_result.propagated_hybrid_time);</a>
<a name="ln670">  }</a>
<a name="ln671"> </a>
<a name="ln672">  std::lock_guard&lt;decltype(mutex_)&gt; lock(mutex_);</a>
<a name="ln673">  for (auto&amp; op : ops) {</a>
<a name="ln674">    CHECK_EQ(1, ops_.erase(op))</a>
<a name="ln675">      &lt;&lt; &quot;Could not remove op &quot; &lt;&lt; op-&gt;ToString() &lt;&lt; &quot; from in-flight list&quot;;</a>
<a name="ln676">  }</a>
<a name="ln677">}</a>
<a name="ln678"> </a>
<a name="ln679">void Batcher::ProcessRpcStatus(const AsyncRpc &amp;rpc, const Status &amp;s) {</a>
<a name="ln680">  // TODO: there is a potential race here -- if the Batcher gets destructed while</a>
<a name="ln681">  // RPCs are in-flight, then accessing state_ will crash. We probably need to keep</a>
<a name="ln682">  // track of the in-flight RPCs, and in the destructor, change each of them to an</a>
<a name="ln683">  // &quot;aborted&quot; state.</a>
<a name="ln684">  std::lock_guard&lt;decltype(mutex_)&gt; lock(mutex_);</a>
<a name="ln685">  if (state_ != BatcherState::kTransactionReady) {</a>
<a name="ln686">    LOG_WITH_PREFIX(DFATAL) &lt;&lt; &quot;ProcessRpcStatus in wrong state &quot; &lt;&lt; ToString(state_) &lt;&lt; &quot;: &quot;</a>
<a name="ln687">                            &lt;&lt; rpc.ToString() &lt;&lt; &quot;, &quot; &lt;&lt; s;</a>
<a name="ln688">    return;</a>
<a name="ln689">  }</a>
<a name="ln690"> </a>
<a name="ln691">  if (PREDICT_FALSE(!s.ok())) {</a>
<a name="ln692">    // Mark each of the ops as failed, since the whole RPC failed.</a>
<a name="ln693">    for (auto&amp; in_flight_op : rpc.ops()) {</a>
<a name="ln694">      CombineErrorUnlocked(in_flight_op, s);</a>
<a name="ln695">    }</a>
<a name="ln696">  }</a>
<a name="ln697">}</a>
<a name="ln698"> </a>
<a name="ln699">void Batcher::ProcessReadResponse(const ReadRpc &amp;rpc, const Status &amp;s) {</a>
<a name="ln700">  ProcessRpcStatus(rpc, s);</a>
<a name="ln701">}</a>
<a name="ln702"> </a>
<a name="ln703">void Batcher::ProcessWriteResponse(const WriteRpc &amp;rpc, const Status &amp;s) {</a>
<a name="ln704">  ProcessRpcStatus(rpc, s);</a>
<a name="ln705"> </a>
<a name="ln706">  if (s.ok() &amp;&amp; rpc.resp().has_propagated_hybrid_time()) {</a>
<a name="ln707">    client_-&gt;data_-&gt;UpdateLatestObservedHybridTime(rpc.resp().propagated_hybrid_time());</a>
<a name="ln708">  }</a>
<a name="ln709"> </a>
<a name="ln710">  // Check individual row errors.</a>
<a name="ln711">  for (const WriteResponsePB_PerRowErrorPB&amp; err_pb : rpc.resp().per_row_errors()) {</a>
<a name="ln712">    // TODO: handle case where we get one of the more specific TS errors</a>
<a name="ln713">    // like the tablet not being hosted?</a>
<a name="ln714"> </a>
<a name="ln715">    if (err_pb.row_index() &gt;= rpc.ops().size()) {</a>
<a name="ln716">      LOG_WITH_PREFIX(ERROR) &lt;&lt; &quot;Received a per_row_error for an out-of-bound op index &quot;</a>
<a name="ln717">                             &lt;&lt; err_pb.row_index() &lt;&lt; &quot; (sent only &quot;</a>
<a name="ln718">                             &lt;&lt; rpc.ops().size() &lt;&lt; &quot; ops)&quot;;</a>
<a name="ln719">      LOG_WITH_PREFIX(ERROR) &lt;&lt; &quot;Response from tablet &quot; &lt;&lt; rpc.tablet().tablet_id() &lt;&lt; &quot;:\n&quot;</a>
<a name="ln720">                 &lt;&lt; rpc.resp().DebugString();</a>
<a name="ln721">      continue;</a>
<a name="ln722">    }</a>
<a name="ln723">    shared_ptr&lt;YBOperation&gt; yb_op = rpc.ops()[err_pb.row_index()]-&gt;yb_op;</a>
<a name="ln724">    VLOG_WITH_PREFIX(1) &lt;&lt; &quot;Error on op &quot; &lt;&lt; yb_op-&gt;ToString() &lt;&lt; &quot;: &quot;</a>
<a name="ln725">                        &lt;&lt; err_pb.error().ShortDebugString();</a>
<a name="ln726">    std::lock_guard&lt;decltype(mutex_)&gt; lock(mutex_);</a>
<a name="ln727">    CombineErrorUnlocked(rpc.ops()[err_pb.row_index()], StatusFromPB(err_pb.error()));</a>
<a name="ln728">  }</a>
<a name="ln729">}</a>
<a name="ln730"> </a>
<a name="ln731">double Batcher::RejectionScore(int attempt_num) {</a>
<a name="ln732">  if (!rejection_score_source_) {</a>
<a name="ln733">    return 0.0;</a>
<a name="ln734">  }</a>
<a name="ln735"> </a>
<a name="ln736">  return rejection_score_source_-&gt;Get(attempt_num);</a>
<a name="ln737">}</a>
<a name="ln738"> </a>
<a name="ln739">std::string Batcher::LogPrefix() const {</a>
<a name="ln740">  const void* self = this;</a>
<a name="ln741">  return Format(&quot;Batcher ($0): &quot;, self);</a>
<a name="ln742">}</a>
<a name="ln743"> </a>
<a name="ln744">}  // namespace internal</a>
<a name="ln745">}  // namespace client</a>
<a name="ln746">}  // namespace yb</a>

</code></pre>
<div class="balloon" rel="140"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="159"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="324"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="342"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="347"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="397"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="422"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="439"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="443"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="486"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="539"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="584"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="625"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="628"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="724"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="110"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: transaction_metadata_.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
