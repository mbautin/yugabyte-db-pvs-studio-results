
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>extension_set.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Protocol Buffers - Google's data interchange format</a>
<a name="ln2">// Copyright 2008 Google Inc.  All rights reserved.</a>
<a name="ln3">// https://developers.google.com/protocol-buffers/</a>
<a name="ln4">//</a>
<a name="ln5">// Redistribution and use in source and binary forms, with or without</a>
<a name="ln6">// modification, are permitted provided that the following conditions are</a>
<a name="ln7">// met:</a>
<a name="ln8">//</a>
<a name="ln9">//     * Redistributions of source code must retain the above copyright</a>
<a name="ln10">// notice, this list of conditions and the following disclaimer.</a>
<a name="ln11">//     * Redistributions in binary form must reproduce the above</a>
<a name="ln12">// copyright notice, this list of conditions and the following disclaimer</a>
<a name="ln13">// in the documentation and/or other materials provided with the</a>
<a name="ln14">// distribution.</a>
<a name="ln15">//     * Neither the name of Google Inc. nor the names of its</a>
<a name="ln16">// contributors may be used to endorse or promote products derived from</a>
<a name="ln17">// this software without specific prior written permission.</a>
<a name="ln18">//</a>
<a name="ln19">// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</a>
<a name="ln20">// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</a>
<a name="ln21">// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</a>
<a name="ln22">// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</a>
<a name="ln23">// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</a>
<a name="ln24">// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</a>
<a name="ln25">// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</a>
<a name="ln26">// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</a>
<a name="ln27">// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</a>
<a name="ln28">// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</a>
<a name="ln29">// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</a>
<a name="ln30"> </a>
<a name="ln31">// Author: kenton@google.com (Kenton Varda)</a>
<a name="ln32">//  Based on original Protocol Buffers design by</a>
<a name="ln33">//  Sanjay Ghemawat, Jeff Dean, and others.</a>
<a name="ln34">//</a>
<a name="ln35">// This header is logically internal, but is made public because it is used</a>
<a name="ln36">// from protocol-compiler-generated code, which may reside in other components.</a>
<a name="ln37"> </a>
<a name="ln38">#ifndef GOOGLE_PROTOBUF_EXTENSION_SET_H__</a>
<a name="ln39">#define GOOGLE_PROTOBUF_EXTENSION_SET_H__</a>
<a name="ln40"> </a>
<a name="ln41">#include &lt;vector&gt;</a>
<a name="ln42">#include &lt;map&gt;</a>
<a name="ln43">#include &lt;utility&gt;</a>
<a name="ln44">#include &lt;string&gt;</a>
<a name="ln45"> </a>
<a name="ln46"> </a>
<a name="ln47">#include &lt;google/protobuf/stubs/common.h&gt;</a>
<a name="ln48">#include &lt;google/protobuf/stubs/logging.h&gt;</a>
<a name="ln49">#include &lt;google/protobuf/stubs/once.h&gt;</a>
<a name="ln50"> </a>
<a name="ln51">#include &lt;google/protobuf/repeated_field.h&gt;</a>
<a name="ln52"> </a>
<a name="ln53">namespace google {</a>
<a name="ln54"> </a>
<a name="ln55">namespace protobuf {</a>
<a name="ln56">  class Arena;</a>
<a name="ln57">  class Descriptor;                                    // descriptor.h</a>
<a name="ln58">  class FieldDescriptor;                               // descriptor.h</a>
<a name="ln59">  class DescriptorPool;                                // descriptor.h</a>
<a name="ln60">  class MessageLite;                                   // message_lite.h</a>
<a name="ln61">  class Message;                                       // message.h</a>
<a name="ln62">  class MessageFactory;                                // message.h</a>
<a name="ln63">  class UnknownFieldSet;                               // unknown_field_set.h</a>
<a name="ln64">  namespace io {</a>
<a name="ln65">    class CodedInputStream;                              // coded_stream.h</a>
<a name="ln66">    class CodedOutputStream;                             // coded_stream.h</a>
<a name="ln67">  }</a>
<a name="ln68">  namespace internal {</a>
<a name="ln69">    class FieldSkipper;                                  // wire_format_lite.h</a>
<a name="ln70">  }</a>
<a name="ln71">}</a>
<a name="ln72"> </a>
<a name="ln73">namespace protobuf {</a>
<a name="ln74">namespace internal {</a>
<a name="ln75"> </a>
<a name="ln76">// Used to store values of type WireFormatLite::FieldType without having to</a>
<a name="ln77">// #include wire_format_lite.h.  Also, ensures that we use only one byte to</a>
<a name="ln78">// store these values, which is important to keep the layout of</a>
<a name="ln79">// ExtensionSet::Extension small.</a>
<a name="ln80">typedef uint8 FieldType;</a>
<a name="ln81"> </a>
<a name="ln82">// A function which, given an integer value, returns true if the number</a>
<a name="ln83">// matches one of the defined values for the corresponding enum type.  This</a>
<a name="ln84">// is used with RegisterEnumExtension, below.</a>
<a name="ln85">typedef bool EnumValidityFunc(int number);</a>
<a name="ln86"> </a>
<a name="ln87">// Version of the above which takes an argument.  This is needed to deal with</a>
<a name="ln88">// extensions that are not compiled in.</a>
<a name="ln89">typedef bool EnumValidityFuncWithArg(const void* arg, int number);</a>
<a name="ln90"> </a>
<a name="ln91">// Information about a registered extension.</a>
<a name="ln92">struct ExtensionInfo {</a>
<a name="ln93">  inline ExtensionInfo() {}</a>
<a name="ln94">  inline ExtensionInfo(FieldType type_param, bool isrepeated, bool ispacked)</a>
<a name="ln95">      : type(type_param), is_repeated(isrepeated), is_packed(ispacked),</a>
<a name="ln96">        descriptor(NULL) {}</a>
<a name="ln97"> </a>
<a name="ln98">  FieldType type;</a>
<a name="ln99">  bool is_repeated;</a>
<a name="ln100">  bool is_packed;</a>
<a name="ln101"> </a>
<a name="ln102">  struct EnumValidityCheck {</a>
<a name="ln103">    EnumValidityFuncWithArg* func;</a>
<a name="ln104">    const void* arg;</a>
<a name="ln105">  };</a>
<a name="ln106"> </a>
<a name="ln107">  union {</a>
<a name="ln108">    EnumValidityCheck enum_validity_check;</a>
<a name="ln109">    const MessageLite* message_prototype;</a>
<a name="ln110">  };</a>
<a name="ln111"> </a>
<a name="ln112">  // The descriptor for this extension, if one exists and is known.  May be</a>
<a name="ln113">  // NULL.  Must not be NULL if the descriptor for the extension does not</a>
<a name="ln114">  // live in the same pool as the descriptor for the containing type.</a>
<a name="ln115">  const FieldDescriptor* descriptor;</a>
<a name="ln116">};</a>
<a name="ln117"> </a>
<a name="ln118">// Abstract interface for an object which looks up extension definitions.  Used</a>
<a name="ln119">// when parsing.</a>
<a name="ln120">class LIBPROTOBUF_EXPORT ExtensionFinder {</a>
<a name="ln121"> public:</a>
<a name="ln122">  virtual ~ExtensionFinder();</a>
<a name="ln123"> </a>
<a name="ln124">  // Find the extension with the given containing type and number.</a>
<a name="ln125">  virtual bool Find(int number, ExtensionInfo* output) = 0;</a>
<a name="ln126">};</a>
<a name="ln127"> </a>
<a name="ln128">// Implementation of ExtensionFinder which finds extensions defined in .proto</a>
<a name="ln129">// files which have been compiled into the binary.</a>
<a name="ln130">class LIBPROTOBUF_EXPORT GeneratedExtensionFinder : public ExtensionFinder {</a>
<a name="ln131"> public:</a>
<a name="ln132">  GeneratedExtensionFinder(const MessageLite* containing_type)</a>
<a name="ln133">      : containing_type_(containing_type) {}</a>
<a name="ln134">  virtual ~GeneratedExtensionFinder() {}</a>
<a name="ln135"> </a>
<a name="ln136">  // Returns true and fills in *output if found, otherwise returns false.</a>
<a name="ln137">  virtual bool Find(int number, ExtensionInfo* output);</a>
<a name="ln138"> </a>
<a name="ln139"> private:</a>
<a name="ln140">  const MessageLite* containing_type_;</a>
<a name="ln141">};</a>
<a name="ln142"> </a>
<a name="ln143">// A FieldSkipper used for parsing MessageSet.</a>
<a name="ln144">class MessageSetFieldSkipper;</a>
<a name="ln145"> </a>
<a name="ln146">// Note:  extension_set_heavy.cc defines DescriptorPoolExtensionFinder for</a>
<a name="ln147">// finding extensions from a DescriptorPool.</a>
<a name="ln148"> </a>
<a name="ln149">// This is an internal helper class intended for use within the protocol buffer</a>
<a name="ln150">// library and generated classes.  Clients should not use it directly.  Instead,</a>
<a name="ln151">// use the generated accessors such as GetExtension() of the class being</a>
<a name="ln152">// extended.</a>
<a name="ln153">//</a>
<a name="ln154">// This class manages extensions for a protocol message object.  The</a>
<a name="ln155">// message's HasExtension(), GetExtension(), MutableExtension(), and</a>
<a name="ln156">// ClearExtension() methods are just thin wrappers around the embedded</a>
<a name="ln157">// ExtensionSet.  When parsing, if a tag number is encountered which is</a>
<a name="ln158">// inside one of the message type's extension ranges, the tag is passed</a>
<a name="ln159">// off to the ExtensionSet for parsing.  Etc.</a>
<a name="ln160">class LIBPROTOBUF_EXPORT ExtensionSet {</a>
<a name="ln161"> public:</a>
<a name="ln162">  ExtensionSet();</a>
<a name="ln163">  explicit ExtensionSet(::google::protobuf::Arena* arena);</a>
<a name="ln164">  ~ExtensionSet();</a>
<a name="ln165"> </a>
<a name="ln166">  // These are called at startup by protocol-compiler-generated code to</a>
<a name="ln167">  // register known extensions.  The registrations are used by ParseField()</a>
<a name="ln168">  // to look up extensions for parsed field numbers.  Note that dynamic parsing</a>
<a name="ln169">  // does not use ParseField(); only protocol-compiler-generated parsing</a>
<a name="ln170">  // methods do.</a>
<a name="ln171">  static void RegisterExtension(const MessageLite* containing_type,</a>
<a name="ln172">                                int number, FieldType type,</a>
<a name="ln173">                                bool is_repeated, bool is_packed);</a>
<a name="ln174">  static void RegisterEnumExtension(const MessageLite* containing_type,</a>
<a name="ln175">                                    int number, FieldType type,</a>
<a name="ln176">                                    bool is_repeated, bool is_packed,</a>
<a name="ln177">                                    EnumValidityFunc* is_valid);</a>
<a name="ln178">  static void RegisterMessageExtension(const MessageLite* containing_type,</a>
<a name="ln179">                                       int number, FieldType type,</a>
<a name="ln180">                                       bool is_repeated, bool is_packed,</a>
<a name="ln181">                                       const MessageLite* prototype);</a>
<a name="ln182"> </a>
<a name="ln183">  // =================================================================</a>
<a name="ln184"> </a>
<a name="ln185">  // Add all fields which are currently present to the given vector.  This</a>
<a name="ln186">  // is useful to implement Reflection::ListFields().</a>
<a name="ln187">  void AppendToList(const Descriptor* containing_type,</a>
<a name="ln188">                    const DescriptorPool* pool,</a>
<a name="ln189">                    std::vector&lt;const FieldDescriptor*&gt;* output) const;</a>
<a name="ln190"> </a>
<a name="ln191">  // =================================================================</a>
<a name="ln192">  // Accessors</a>
<a name="ln193">  //</a>
<a name="ln194">  // Generated message classes include type-safe templated wrappers around</a>
<a name="ln195">  // these methods.  Generally you should use those rather than call these</a>
<a name="ln196">  // directly, unless you are doing low-level memory management.</a>
<a name="ln197">  //</a>
<a name="ln198">  // When calling any of these accessors, the extension number requested</a>
<a name="ln199">  // MUST exist in the DescriptorPool provided to the constructor.  Otherwise,</a>
<a name="ln200">  // the method will fail an assert.  Normally, though, you would not call</a>
<a name="ln201">  // these directly; you would either call the generated accessors of your</a>
<a name="ln202">  // message class (e.g. GetExtension()) or you would call the accessors</a>
<a name="ln203">  // of the reflection interface.  In both cases, it is impossible to</a>
<a name="ln204">  // trigger this assert failure:  the generated accessors only accept</a>
<a name="ln205">  // linked-in extension types as parameters, while the Reflection interface</a>
<a name="ln206">  // requires you to provide the FieldDescriptor describing the extension.</a>
<a name="ln207">  //</a>
<a name="ln208">  // When calling any of these accessors, a protocol-compiler-generated</a>
<a name="ln209">  // implementation of the extension corresponding to the number MUST</a>
<a name="ln210">  // be linked in, and the FieldDescriptor used to refer to it MUST be</a>
<a name="ln211">  // the one generated by that linked-in code.  Otherwise, the method will</a>
<a name="ln212">  // die on an assert failure.  The message objects returned by the message</a>
<a name="ln213">  // accessors are guaranteed to be of the correct linked-in type.</a>
<a name="ln214">  //</a>
<a name="ln215">  // These methods pretty much match Reflection except that:</a>
<a name="ln216">  // - They're not virtual.</a>
<a name="ln217">  // - They identify fields by number rather than FieldDescriptors.</a>
<a name="ln218">  // - They identify enum values using integers rather than descriptors.</a>
<a name="ln219">  // - Strings provide Mutable() in addition to Set() accessors.</a>
<a name="ln220"> </a>
<a name="ln221">  bool Has(int number) const;</a>
<a name="ln222">  int ExtensionSize(int number) const;   // Size of a repeated extension.</a>
<a name="ln223">  int NumExtensions() const;  // The number of extensions</a>
<a name="ln224">  FieldType ExtensionType(int number) const;</a>
<a name="ln225">  void ClearExtension(int number);</a>
<a name="ln226"> </a>
<a name="ln227">  // singular fields -------------------------------------------------</a>
<a name="ln228"> </a>
<a name="ln229">  int32  GetInt32 (int number, int32  default_value) const;</a>
<a name="ln230">  int64  GetInt64 (int number, int64  default_value) const;</a>
<a name="ln231">  uint32 GetUInt32(int number, uint32 default_value) const;</a>
<a name="ln232">  uint64 GetUInt64(int number, uint64 default_value) const;</a>
<a name="ln233">  float  GetFloat (int number, float  default_value) const;</a>
<a name="ln234">  double GetDouble(int number, double default_value) const;</a>
<a name="ln235">  bool   GetBool  (int number, bool   default_value) const;</a>
<a name="ln236">  int    GetEnum  (int number, int    default_value) const;</a>
<a name="ln237">  const string &amp; GetString (int number, const string&amp;  default_value) const;</a>
<a name="ln238">  const MessageLite&amp; GetMessage(int number,</a>
<a name="ln239">                                const MessageLite&amp; default_value) const;</a>
<a name="ln240">  const MessageLite&amp; GetMessage(int number, const Descriptor* message_type,</a>
<a name="ln241">                                MessageFactory* factory) const;</a>
<a name="ln242"> </a>
<a name="ln243">  // |descriptor| may be NULL so long as it is known that the descriptor for</a>
<a name="ln244">  // the extension lives in the same pool as the descriptor for the containing</a>
<a name="ln245">  // type.</a>
<a name="ln246">#define desc const FieldDescriptor* descriptor  // avoid line wrapping</a>
<a name="ln247">  void SetInt32 (int number, FieldType type, int32  value, desc);</a>
<a name="ln248">  void SetInt64 (int number, FieldType type, int64  value, desc);</a>
<a name="ln249">  void SetUInt32(int number, FieldType type, uint32 value, desc);</a>
<a name="ln250">  void SetUInt64(int number, FieldType type, uint64 value, desc);</a>
<a name="ln251">  void SetFloat (int number, FieldType type, float  value, desc);</a>
<a name="ln252">  void SetDouble(int number, FieldType type, double value, desc);</a>
<a name="ln253">  void SetBool  (int number, FieldType type, bool   value, desc);</a>
<a name="ln254">  void SetEnum  (int number, FieldType type, int    value, desc);</a>
<a name="ln255">  void SetString(int number, FieldType type, const string&amp; value, desc);</a>
<a name="ln256">  string * MutableString (int number, FieldType type, desc);</a>
<a name="ln257">  MessageLite* MutableMessage(int number, FieldType type,</a>
<a name="ln258">                              const MessageLite&amp; prototype, desc);</a>
<a name="ln259">  MessageLite* MutableMessage(const FieldDescriptor* decsriptor,</a>
<a name="ln260">                              MessageFactory* factory);</a>
<a name="ln261">  // Adds the given message to the ExtensionSet, taking ownership of the</a>
<a name="ln262">  // message object. Existing message with the same number will be deleted.</a>
<a name="ln263">  // If &quot;message&quot; is NULL, this is equivalent to &quot;ClearExtension(number)&quot;.</a>
<a name="ln264">  void SetAllocatedMessage(int number, FieldType type,</a>
<a name="ln265">                           const FieldDescriptor* descriptor,</a>
<a name="ln266">                           MessageLite* message);</a>
<a name="ln267">  void UnsafeArenaSetAllocatedMessage(int number, FieldType type,</a>
<a name="ln268">                                      const FieldDescriptor* descriptor,</a>
<a name="ln269">                                      MessageLite* message);</a>
<a name="ln270">  MessageLite* ReleaseMessage(int number, const MessageLite&amp; prototype);</a>
<a name="ln271">  MessageLite* UnsafeArenaReleaseMessage(</a>
<a name="ln272">      int number, const MessageLite&amp; prototype);</a>
<a name="ln273"> </a>
<a name="ln274">  MessageLite* ReleaseMessage(const FieldDescriptor* descriptor,</a>
<a name="ln275">                              MessageFactory* factory);</a>
<a name="ln276">  MessageLite* UnsafeArenaReleaseMessage(const FieldDescriptor* descriptor,</a>
<a name="ln277">                                         MessageFactory* factory);</a>
<a name="ln278">#undef desc</a>
<a name="ln279">  ::google::protobuf::Arena* GetArenaNoVirtual() const { return arena_; }</a>
<a name="ln280"> </a>
<a name="ln281">  // repeated fields -------------------------------------------------</a>
<a name="ln282"> </a>
<a name="ln283">  // Fetches a RepeatedField extension by number; returns |default_value|</a>
<a name="ln284">  // if no such extension exists. User should not touch this directly; it is</a>
<a name="ln285">  // used by the GetRepeatedExtension() method.</a>
<a name="ln286">  const void* GetRawRepeatedField(int number, const void* default_value) const;</a>
<a name="ln287">  // Fetches a mutable version of a RepeatedField extension by number,</a>
<a name="ln288">  // instantiating one if none exists. Similar to above, user should not use</a>
<a name="ln289">  // this directly; it underlies MutableRepeatedExtension().</a>
<a name="ln290">  void* MutableRawRepeatedField(int number, FieldType field_type,</a>
<a name="ln291">                                bool packed, const FieldDescriptor* desc);</a>
<a name="ln292"> </a>
<a name="ln293">  // This is an overload of MutableRawRepeatedField to maintain compatibility</a>
<a name="ln294">  // with old code using a previous API. This version of</a>
<a name="ln295">  // MutableRawRepeatedField() will GOOGLE_CHECK-fail on a missing extension.</a>
<a name="ln296">  // (E.g.: borg/clients/internal/proto1/proto2_reflection.cc.)</a>
<a name="ln297">  void* MutableRawRepeatedField(int number);</a>
<a name="ln298"> </a>
<a name="ln299">  int32  GetRepeatedInt32 (int number, int index) const;</a>
<a name="ln300">  int64  GetRepeatedInt64 (int number, int index) const;</a>
<a name="ln301">  uint32 GetRepeatedUInt32(int number, int index) const;</a>
<a name="ln302">  uint64 GetRepeatedUInt64(int number, int index) const;</a>
<a name="ln303">  float  GetRepeatedFloat (int number, int index) const;</a>
<a name="ln304">  double GetRepeatedDouble(int number, int index) const;</a>
<a name="ln305">  bool   GetRepeatedBool  (int number, int index) const;</a>
<a name="ln306">  int    GetRepeatedEnum  (int number, int index) const;</a>
<a name="ln307">  const string &amp; GetRepeatedString (int number, int index) const;</a>
<a name="ln308">  const MessageLite&amp; GetRepeatedMessage(int number, int index) const;</a>
<a name="ln309"> </a>
<a name="ln310">  void SetRepeatedInt32 (int number, int index, int32  value);</a>
<a name="ln311">  void SetRepeatedInt64 (int number, int index, int64  value);</a>
<a name="ln312">  void SetRepeatedUInt32(int number, int index, uint32 value);</a>
<a name="ln313">  void SetRepeatedUInt64(int number, int index, uint64 value);</a>
<a name="ln314">  void SetRepeatedFloat (int number, int index, float  value);</a>
<a name="ln315">  void SetRepeatedDouble(int number, int index, double value);</a>
<a name="ln316">  void SetRepeatedBool  (int number, int index, bool   value);</a>
<a name="ln317">  void SetRepeatedEnum  (int number, int index, int    value);</a>
<a name="ln318">  void SetRepeatedString(int number, int index, const string&amp; value);</a>
<a name="ln319">  string * MutableRepeatedString (int number, int index);</a>
<a name="ln320">  MessageLite* MutableRepeatedMessage(int number, int index);</a>
<a name="ln321"> </a>
<a name="ln322">#define desc const FieldDescriptor* descriptor  // avoid line wrapping</a>
<a name="ln323">  void AddInt32 (int number, FieldType type, bool packed, int32  value, desc);</a>
<a name="ln324">  void AddInt64 (int number, FieldType type, bool packed, int64  value, desc);</a>
<a name="ln325">  void AddUInt32(int number, FieldType type, bool packed, uint32 value, desc);</a>
<a name="ln326">  void AddUInt64(int number, FieldType type, bool packed, uint64 value, desc);</a>
<a name="ln327">  void AddFloat (int number, FieldType type, bool packed, float  value, desc);</a>
<a name="ln328">  void AddDouble(int number, FieldType type, bool packed, double value, desc);</a>
<a name="ln329">  void AddBool  (int number, FieldType type, bool packed, bool   value, desc);</a>
<a name="ln330">  void AddEnum  (int number, FieldType type, bool packed, int    value, desc);</a>
<a name="ln331">  void AddString(int number, FieldType type, const string&amp; value, desc);</a>
<a name="ln332">  string * AddString (int number, FieldType type, desc);</a>
<a name="ln333">  MessageLite* AddMessage(int number, FieldType type,</a>
<a name="ln334">                          const MessageLite&amp; prototype, desc);</a>
<a name="ln335">  MessageLite* AddMessage(const FieldDescriptor* descriptor,</a>
<a name="ln336">                          MessageFactory* factory);</a>
<a name="ln337">  void AddAllocatedMessage(const FieldDescriptor* descriptor,</a>
<a name="ln338">                           MessageLite* new_entry);</a>
<a name="ln339">#undef desc</a>
<a name="ln340"> </a>
<a name="ln341">  void RemoveLast(int number);</a>
<a name="ln342">  MessageLite* ReleaseLast(int number);</a>
<a name="ln343">  void SwapElements(int number, int index1, int index2);</a>
<a name="ln344"> </a>
<a name="ln345">  // -----------------------------------------------------------------</a>
<a name="ln346">  // TODO(kenton):  Hardcore memory management accessors</a>
<a name="ln347"> </a>
<a name="ln348">  // =================================================================</a>
<a name="ln349">  // convenience methods for implementing methods of Message</a>
<a name="ln350">  //</a>
<a name="ln351">  // These could all be implemented in terms of the other methods of this</a>
<a name="ln352">  // class, but providing them here helps keep the generated code size down.</a>
<a name="ln353"> </a>
<a name="ln354">  void Clear();</a>
<a name="ln355">  void MergeFrom(const ExtensionSet&amp; other);</a>
<a name="ln356">  void Swap(ExtensionSet* other);</a>
<a name="ln357">  void SwapExtension(ExtensionSet* other, int number);</a>
<a name="ln358">  bool IsInitialized() const;</a>
<a name="ln359"> </a>
<a name="ln360">  // Parses a single extension from the input. The input should start out</a>
<a name="ln361">  // positioned immediately after the tag.</a>
<a name="ln362">  bool ParseField(uint32 tag, io::CodedInputStream* input,</a>
<a name="ln363">                  ExtensionFinder* extension_finder,</a>
<a name="ln364">                  FieldSkipper* field_skipper);</a>
<a name="ln365"> </a>
<a name="ln366">  // Specific versions for lite or full messages (constructs the appropriate</a>
<a name="ln367">  // FieldSkipper automatically).  |containing_type| is the default</a>
<a name="ln368">  // instance for the containing message; it is used only to look up the</a>
<a name="ln369">  // extension by number.  See RegisterExtension(), above.  Unlike the other</a>
<a name="ln370">  // methods of ExtensionSet, this only works for generated message types --</a>
<a name="ln371">  // it looks up extensions registered using RegisterExtension().</a>
<a name="ln372">  bool ParseField(uint32 tag, io::CodedInputStream* input,</a>
<a name="ln373">                  const MessageLite* containing_type);</a>
<a name="ln374">  bool ParseField(uint32 tag, io::CodedInputStream* input,</a>
<a name="ln375">                  const Message* containing_type,</a>
<a name="ln376">                  UnknownFieldSet* unknown_fields);</a>
<a name="ln377">  bool ParseField(uint32 tag, io::CodedInputStream* input,</a>
<a name="ln378">                  const MessageLite* containing_type,</a>
<a name="ln379">                  io::CodedOutputStream* unknown_fields);</a>
<a name="ln380"> </a>
<a name="ln381">  // Parse an entire message in MessageSet format.  Such messages have no</a>
<a name="ln382">  // fields, only extensions.</a>
<a name="ln383">  bool ParseMessageSet(io::CodedInputStream* input,</a>
<a name="ln384">                       ExtensionFinder* extension_finder,</a>
<a name="ln385">                       MessageSetFieldSkipper* field_skipper);</a>
<a name="ln386"> </a>
<a name="ln387">  // Specific versions for lite or full messages (constructs the appropriate</a>
<a name="ln388">  // FieldSkipper automatically).</a>
<a name="ln389">  bool ParseMessageSet(io::CodedInputStream* input,</a>
<a name="ln390">                       const MessageLite* containing_type);</a>
<a name="ln391">  bool ParseMessageSet(io::CodedInputStream* input,</a>
<a name="ln392">                       const Message* containing_type,</a>
<a name="ln393">                       UnknownFieldSet* unknown_fields);</a>
<a name="ln394"> </a>
<a name="ln395">  // Write all extension fields with field numbers in the range</a>
<a name="ln396">  //   [start_field_number, end_field_number)</a>
<a name="ln397">  // to the output stream, using the cached sizes computed when ByteSize() was</a>
<a name="ln398">  // last called.  Note that the range bounds are inclusive-exclusive.</a>
<a name="ln399">  void SerializeWithCachedSizes(int start_field_number,</a>
<a name="ln400">                                int end_field_number,</a>
<a name="ln401">                                io::CodedOutputStream* output) const;</a>
<a name="ln402"> </a>
<a name="ln403">  // Same as SerializeWithCachedSizes, but without any bounds checking.</a>
<a name="ln404">  // The caller must ensure that target has sufficient capacity for the</a>
<a name="ln405">  // serialized extensions.</a>
<a name="ln406">  //</a>
<a name="ln407">  // Returns a pointer past the last written byte.</a>
<a name="ln408">  uint8* InternalSerializeWithCachedSizesToArray(int start_field_number,</a>
<a name="ln409">                                                 int end_field_number,</a>
<a name="ln410">                                                 bool deterministic,</a>
<a name="ln411">                                                 uint8* target) const;</a>
<a name="ln412"> </a>
<a name="ln413">  // Like above but serializes in MessageSet format.</a>
<a name="ln414">  void SerializeMessageSetWithCachedSizes(io::CodedOutputStream* output) const;</a>
<a name="ln415">  uint8* InternalSerializeMessageSetWithCachedSizesToArray(bool deterministic,</a>
<a name="ln416">                                                           uint8* target) const;</a>
<a name="ln417"> </a>
<a name="ln418">  // For backward-compatibility, versions of two of the above methods that</a>
<a name="ln419">  // serialize deterministically iff SetDefaultSerializationDeterministic()</a>
<a name="ln420">  // has been called.</a>
<a name="ln421">  uint8* SerializeWithCachedSizesToArray(int start_field_number,</a>
<a name="ln422">                                         int end_field_number,</a>
<a name="ln423">                                         uint8* target) const;</a>
<a name="ln424">  uint8* SerializeMessageSetWithCachedSizesToArray(uint8* target) const;</a>
<a name="ln425"> </a>
<a name="ln426">  // Returns the total serialized size of all the extensions.</a>
<a name="ln427">  size_t ByteSize() const;</a>
<a name="ln428"> </a>
<a name="ln429">  // Like ByteSize() but uses MessageSet format.</a>
<a name="ln430">  size_t MessageSetByteSize() const;</a>
<a name="ln431"> </a>
<a name="ln432">  // Returns (an estimate of) the total number of bytes used for storing the</a>
<a name="ln433">  // extensions in memory, excluding sizeof(*this).  If the ExtensionSet is</a>
<a name="ln434">  // for a lite message (and thus possibly contains lite messages), the results</a>
<a name="ln435">  // are undefined (might work, might crash, might corrupt data, might not even</a>
<a name="ln436">  // be linked in).  It's up to the protocol compiler to avoid calling this on</a>
<a name="ln437">  // such ExtensionSets (easy enough since lite messages don't implement</a>
<a name="ln438">  // SpaceUsed()).</a>
<a name="ln439">  size_t SpaceUsedExcludingSelfLong() const;</a>
<a name="ln440"> </a>
<a name="ln441">  // This method just calls SpaceUsedExcludingSelfLong() but it can not be</a>
<a name="ln442">  // inlined because the definition of SpaceUsedExcludingSelfLong() is not</a>
<a name="ln443">  // included in lite runtime and when an inline method refers to it MSVC</a>
<a name="ln444">  // will complain about unresolved symbols when building the lite runtime</a>
<a name="ln445">  // as .dll.</a>
<a name="ln446">  int SpaceUsedExcludingSelf() const;</a>
<a name="ln447"> </a>
<a name="ln448"> private:</a>
<a name="ln449"> </a>
<a name="ln450">  // Interface of a lazily parsed singular message extension.</a>
<a name="ln451">  class LIBPROTOBUF_EXPORT LazyMessageExtension {</a>
<a name="ln452">   public:</a>
<a name="ln453">    LazyMessageExtension() {}</a>
<a name="ln454">    virtual ~LazyMessageExtension() {}</a>
<a name="ln455"> </a>
<a name="ln456">    virtual LazyMessageExtension* New(::google::protobuf::Arena* arena) const = 0;</a>
<a name="ln457">    virtual const MessageLite&amp; GetMessage(</a>
<a name="ln458">        const MessageLite&amp; prototype) const = 0;</a>
<a name="ln459">    virtual MessageLite* MutableMessage(const MessageLite&amp; prototype) = 0;</a>
<a name="ln460">    virtual void SetAllocatedMessage(MessageLite *message) = 0;</a>
<a name="ln461">    virtual void UnsafeArenaSetAllocatedMessage(MessageLite *message) = 0;</a>
<a name="ln462">    virtual MessageLite* ReleaseMessage(const MessageLite&amp; prototype) = 0;</a>
<a name="ln463">    virtual MessageLite* UnsafeArenaReleaseMessage(</a>
<a name="ln464">        const MessageLite&amp; prototype) = 0;</a>
<a name="ln465"> </a>
<a name="ln466">    virtual bool IsInitialized() const = 0;</a>
<a name="ln467">    virtual int ByteSize() const = 0;</a>
<a name="ln468">    virtual size_t SpaceUsedLong() const = 0;</a>
<a name="ln469"> </a>
<a name="ln470">    virtual void MergeFrom(const LazyMessageExtension&amp; other) = 0;</a>
<a name="ln471">    virtual void Clear() = 0;</a>
<a name="ln472"> </a>
<a name="ln473">    virtual bool ReadMessage(const MessageLite&amp; prototype,</a>
<a name="ln474">                             io::CodedInputStream* input) = 0;</a>
<a name="ln475">    virtual void WriteMessage(int number,</a>
<a name="ln476">                              io::CodedOutputStream* output) const = 0;</a>
<a name="ln477">    virtual uint8* WriteMessageToArray(int number, uint8* target) const = 0;</a>
<a name="ln478">    virtual uint8* InternalWriteMessageToArray(int number, bool,</a>
<a name="ln479">                                               uint8* target) const {</a>
<a name="ln480">      // TODO(gpike): make this pure virtual. This is a placeholder because we</a>
<a name="ln481">      // need to update third_party/upb, for example.</a>
<a name="ln482">      return WriteMessageToArray(number, target);</a>
<a name="ln483">    }</a>
<a name="ln484"> </a>
<a name="ln485">   private:</a>
<a name="ln486">    GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(LazyMessageExtension);</a>
<a name="ln487">  };</a>
<a name="ln488">  struct Extension {</a>
<a name="ln489">    // The order of these fields packs Extension into 24 bytes when using 8</a>
<a name="ln490">    // byte alignment. Consider this when adding or removing fields here.</a>
<a name="ln491">    union {</a>
<a name="ln492">      int32                 int32_value;</a>
<a name="ln493">      int64                 int64_value;</a>
<a name="ln494">      uint32                uint32_value;</a>
<a name="ln495">      uint64                uint64_value;</a>
<a name="ln496">      float                 float_value;</a>
<a name="ln497">      double                double_value;</a>
<a name="ln498">      bool                  bool_value;</a>
<a name="ln499">      int                   enum_value;</a>
<a name="ln500">      string*               string_value;</a>
<a name="ln501">      MessageLite*          message_value;</a>
<a name="ln502">      LazyMessageExtension* lazymessage_value;</a>
<a name="ln503"> </a>
<a name="ln504">      RepeatedField   &lt;int32      &gt;* repeated_int32_value;</a>
<a name="ln505">      RepeatedField   &lt;int64      &gt;* repeated_int64_value;</a>
<a name="ln506">      RepeatedField   &lt;uint32     &gt;* repeated_uint32_value;</a>
<a name="ln507">      RepeatedField   &lt;uint64     &gt;* repeated_uint64_value;</a>
<a name="ln508">      RepeatedField   &lt;float      &gt;* repeated_float_value;</a>
<a name="ln509">      RepeatedField   &lt;double     &gt;* repeated_double_value;</a>
<a name="ln510">      RepeatedField   &lt;bool       &gt;* repeated_bool_value;</a>
<a name="ln511">      RepeatedField   &lt;int        &gt;* repeated_enum_value;</a>
<a name="ln512">      RepeatedPtrField&lt;string     &gt;* repeated_string_value;</a>
<a name="ln513">      RepeatedPtrField&lt;MessageLite&gt;* repeated_message_value;</a>
<a name="ln514">    };</a>
<a name="ln515"> </a>
<a name="ln516">    FieldType type;</a>
<a name="ln517">    bool is_repeated;</a>
<a name="ln518"> </a>
<a name="ln519">    // For singular types, indicates if the extension is &quot;cleared&quot;.  This</a>
<a name="ln520">    // happens when an extension is set and then later cleared by the caller.</a>
<a name="ln521">    // We want to keep the Extension object around for reuse, so instead of</a>
<a name="ln522">    // removing it from the map, we just set is_cleared = true.  This has no</a>
<a name="ln523">    // meaning for repeated types; for those, the size of the RepeatedField</a>
<a name="ln524">    // simply becomes zero when cleared.</a>
<a name="ln525">    bool is_cleared : 4;</a>
<a name="ln526"> </a>
<a name="ln527">    // For singular message types, indicates whether lazy parsing is enabled</a>
<a name="ln528">    // for this extension. This field is only valid when type == TYPE_MESSAGE</a>
<a name="ln529">    // and !is_repeated because we only support lazy parsing for singular</a>
<a name="ln530">    // message types currently. If is_lazy = true, the extension is stored in</a>
<a name="ln531">    // lazymessage_value. Otherwise, the extension will be message_value.</a>
<a name="ln532">    bool is_lazy : 4;</a>
<a name="ln533"> </a>
<a name="ln534">    // For repeated types, this indicates if the [packed=true] option is set.</a>
<a name="ln535">    bool is_packed;</a>
<a name="ln536"> </a>
<a name="ln537">    // For packed fields, the size of the packed data is recorded here when</a>
<a name="ln538">    // ByteSize() is called then used during serialization.</a>
<a name="ln539">    // TODO(kenton):  Use atomic&lt;int&gt; when C++ supports it.</a>
<a name="ln540">    mutable int cached_size;</a>
<a name="ln541"> </a>
<a name="ln542">    // The descriptor for this extension, if one exists and is known.  May be</a>
<a name="ln543">    // NULL.  Must not be NULL if the descriptor for the extension does not</a>
<a name="ln544">    // live in the same pool as the descriptor for the containing type.</a>
<a name="ln545">    const FieldDescriptor* descriptor;</a>
<a name="ln546"> </a>
<a name="ln547">    // Some helper methods for operations on a single Extension.</a>
<a name="ln548">    void SerializeFieldWithCachedSizes(</a>
<a name="ln549">        int number,</a>
<a name="ln550">        io::CodedOutputStream* output) const;</a>
<a name="ln551">    uint8* InternalSerializeFieldWithCachedSizesToArray(</a>
<a name="ln552">        int number,</a>
<a name="ln553">        bool deterministic,</a>
<a name="ln554">        uint8* target) const;</a>
<a name="ln555">    void SerializeMessageSetItemWithCachedSizes(</a>
<a name="ln556">        int number,</a>
<a name="ln557">        io::CodedOutputStream* output) const;</a>
<a name="ln558">    uint8* InternalSerializeMessageSetItemWithCachedSizesToArray(</a>
<a name="ln559">        int number,</a>
<a name="ln560">        bool deterministic,</a>
<a name="ln561">        uint8* target) const;</a>
<a name="ln562">    size_t ByteSize(int number) const;</a>
<a name="ln563">    size_t MessageSetItemByteSize(int number) const;</a>
<a name="ln564">    void Clear();</a>
<a name="ln565">    int GetSize() const;</a>
<a name="ln566">    void Free();</a>
<a name="ln567">    size_t SpaceUsedExcludingSelfLong() const;</a>
<a name="ln568">  };</a>
<a name="ln569">  typedef std::map&lt;int, Extension&gt; ExtensionMap;</a>
<a name="ln570"> </a>
<a name="ln571"> </a>
<a name="ln572">  // Merges existing Extension from other_extension</a>
<a name="ln573">  void InternalExtensionMergeFrom(int number, const Extension&amp; other_extension);</a>
<a name="ln574"> </a>
<a name="ln575">  // Returns true and fills field_number and extension if extension is found.</a>
<a name="ln576">  // Note to support packed repeated field compatibility, it also fills whether</a>
<a name="ln577">  // the tag on wire is packed, which can be different from</a>
<a name="ln578">  // extension-&gt;is_packed (whether packed=true is specified).</a>
<a name="ln579">  bool FindExtensionInfoFromTag(uint32 tag, ExtensionFinder* extension_finder,</a>
<a name="ln580">                                int* field_number, ExtensionInfo* extension,</a>
<a name="ln581">                                bool* was_packed_on_wire);</a>
<a name="ln582"> </a>
<a name="ln583">  // Returns true and fills extension if extension is found.</a>
<a name="ln584">  // Note to support packed repeated field compatibility, it also fills whether</a>
<a name="ln585">  // the tag on wire is packed, which can be different from</a>
<a name="ln586">  // extension-&gt;is_packed (whether packed=true is specified).</a>
<a name="ln587">  bool FindExtensionInfoFromFieldNumber(int wire_type, int field_number,</a>
<a name="ln588">                                        ExtensionFinder* extension_finder,</a>
<a name="ln589">                                        ExtensionInfo* extension,</a>
<a name="ln590">                                        bool* was_packed_on_wire);</a>
<a name="ln591"> </a>
<a name="ln592">  // Parses a single extension from the input. The input should start out</a>
<a name="ln593">  // positioned immediately after the wire tag. This method is called in</a>
<a name="ln594">  // ParseField() after field number and was_packed_on_wire is extracted from</a>
<a name="ln595">  // the wire tag and ExtensionInfo is found by the field number.</a>
<a name="ln596">  bool ParseFieldWithExtensionInfo(int field_number,</a>
<a name="ln597">                                   bool was_packed_on_wire,</a>
<a name="ln598">                                   const ExtensionInfo&amp; extension,</a>
<a name="ln599">                                   io::CodedInputStream* input,</a>
<a name="ln600">                                   FieldSkipper* field_skipper);</a>
<a name="ln601"> </a>
<a name="ln602">  // Like ParseField(), but this method may parse singular message extensions</a>
<a name="ln603">  // lazily depending on the value of FLAGS_eagerly_parse_message_sets.</a>
<a name="ln604">  bool ParseFieldMaybeLazily(int wire_type, int field_number,</a>
<a name="ln605">                             io::CodedInputStream* input,</a>
<a name="ln606">                             ExtensionFinder* extension_finder,</a>
<a name="ln607">                             MessageSetFieldSkipper* field_skipper);</a>
<a name="ln608"> </a>
<a name="ln609">  // Gets the extension with the given number, creating it if it does not</a>
<a name="ln610">  // already exist.  Returns true if the extension did not already exist.</a>
<a name="ln611">  bool MaybeNewExtension(int number, const FieldDescriptor* descriptor,</a>
<a name="ln612">                         Extension** result);</a>
<a name="ln613"> </a>
<a name="ln614">  // Gets the repeated extension for the given descriptor, creating it if</a>
<a name="ln615">  // it does not exist.</a>
<a name="ln616">  Extension* MaybeNewRepeatedExtension(const FieldDescriptor* descriptor);</a>
<a name="ln617"> </a>
<a name="ln618">  // Parse a single MessageSet item -- called just after the item group start</a>
<a name="ln619">  // tag has been read.</a>
<a name="ln620">  bool ParseMessageSetItem(io::CodedInputStream* input,</a>
<a name="ln621">                           ExtensionFinder* extension_finder,</a>
<a name="ln622">                           MessageSetFieldSkipper* field_skipper);</a>
<a name="ln623"> </a>
<a name="ln624">  // Hack:  RepeatedPtrFieldBase declares ExtensionSet as a friend.  This</a>
<a name="ln625">  //   friendship should automatically extend to ExtensionSet::Extension, but</a>
<a name="ln626">  //   unfortunately some older compilers (e.g. GCC 3.4.4) do not implement this</a>
<a name="ln627">  //   correctly.  So, we must provide helpers for calling methods of that</a>
<a name="ln628">  //   class.</a>
<a name="ln629"> </a>
<a name="ln630">  // Defined in extension_set_heavy.cc.</a>
<a name="ln631">  static inline size_t RepeatedMessage_SpaceUsedExcludingSelfLong(</a>
<a name="ln632">      RepeatedPtrFieldBase* field);</a>
<a name="ln633"> </a>
<a name="ln634">  // The Extension struct is small enough to be passed by value, so we use it</a>
<a name="ln635">  // directly as the value type in the map rather than use pointers.  We use</a>
<a name="ln636">  // a map rather than hash_map here because we expect most ExtensionSets will</a>
<a name="ln637">  // only contain a small number of extensions whereas hash_map is optimized</a>
<a name="ln638">  // for 100 elements or more.  Also, we want AppendToList() to order fields</a>
<a name="ln639">  // by field number.</a>
<a name="ln640">  ExtensionMap extensions_;</a>
<a name="ln641">  ::google::protobuf::Arena* arena_;</a>
<a name="ln642">  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(ExtensionSet);</a>
<a name="ln643">};</a>
<a name="ln644"> </a>
<a name="ln645">// These are just for convenience...</a>
<a name="ln646">inline void ExtensionSet::SetString(int number, FieldType type,</a>
<a name="ln647">                                    const string&amp; value,</a>
<a name="ln648">                                    const FieldDescriptor* descriptor) {</a>
<a name="ln649">  MutableString(number, type, descriptor)-&gt;assign(value);</a>
<a name="ln650">}</a>
<a name="ln651">inline void ExtensionSet::SetRepeatedString(int number, int index,</a>
<a name="ln652">                                            const string&amp; value) {</a>
<a name="ln653">  MutableRepeatedString(number, index)-&gt;assign(value);</a>
<a name="ln654">}</a>
<a name="ln655">inline void ExtensionSet::AddString(int number, FieldType type,</a>
<a name="ln656">                                    const string&amp; value,</a>
<a name="ln657">                                    const FieldDescriptor* descriptor) {</a>
<a name="ln658">  AddString(number, type, descriptor)-&gt;assign(value);</a>
<a name="ln659">}</a>
<a name="ln660"> </a>
<a name="ln661">// ===================================================================</a>
<a name="ln662">// Glue for generated extension accessors</a>
<a name="ln663"> </a>
<a name="ln664">// -------------------------------------------------------------------</a>
<a name="ln665">// Template magic</a>
<a name="ln666"> </a>
<a name="ln667">// First we have a set of classes representing &quot;type traits&quot; for different</a>
<a name="ln668">// field types.  A type traits class knows how to implement basic accessors</a>
<a name="ln669">// for extensions of a particular type given an ExtensionSet.  The signature</a>
<a name="ln670">// for a type traits class looks like this:</a>
<a name="ln671">//</a>
<a name="ln672">//   class TypeTraits {</a>
<a name="ln673">//    public:</a>
<a name="ln674">//     typedef ? ConstType;</a>
<a name="ln675">//     typedef ? MutableType;</a>
<a name="ln676">//     // TypeTraits for singular fields and repeated fields will define the</a>
<a name="ln677">//     // symbol &quot;Singular&quot; or &quot;Repeated&quot; respectively. These two symbols will</a>
<a name="ln678">//     // be used in extension accessors to distinguish between singular</a>
<a name="ln679">//     // extensions and repeated extensions. If the TypeTraits for the passed</a>
<a name="ln680">//     // in extension doesn't have the expected symbol defined, it means the</a>
<a name="ln681">//     // user is passing a repeated extension to a singular accessor, or the</a>
<a name="ln682">//     // opposite. In that case the C++ compiler will generate an error</a>
<a name="ln683">//     // message &quot;no matching member function&quot; to inform the user.</a>
<a name="ln684">//     typedef ? Singular</a>
<a name="ln685">//     typedef ? Repeated</a>
<a name="ln686">//</a>
<a name="ln687">//     static inline ConstType Get(int number, const ExtensionSet&amp; set);</a>
<a name="ln688">//     static inline void Set(int number, ConstType value, ExtensionSet* set);</a>
<a name="ln689">//     static inline MutableType Mutable(int number, ExtensionSet* set);</a>
<a name="ln690">//</a>
<a name="ln691">//     // Variants for repeated fields.</a>
<a name="ln692">//     static inline ConstType Get(int number, const ExtensionSet&amp; set,</a>
<a name="ln693">//                                 int index);</a>
<a name="ln694">//     static inline void Set(int number, int index,</a>
<a name="ln695">//                            ConstType value, ExtensionSet* set);</a>
<a name="ln696">//     static inline MutableType Mutable(int number, int index,</a>
<a name="ln697">//                                       ExtensionSet* set);</a>
<a name="ln698">//     static inline void Add(int number, ConstType value, ExtensionSet* set);</a>
<a name="ln699">//     static inline MutableType Add(int number, ExtensionSet* set);</a>
<a name="ln700">//     This is used by the ExtensionIdentifier constructor to register</a>
<a name="ln701">//     the extension at dynamic initialization.</a>
<a name="ln702">//     template &lt;typename ExtendeeT&gt;</a>
<a name="ln703">//     static void Register(int number, FieldType type, bool is_packed);</a>
<a name="ln704">//   };</a>
<a name="ln705">//</a>
<a name="ln706">// Not all of these methods make sense for all field types.  For example, the</a>
<a name="ln707">// &quot;Mutable&quot; methods only make sense for strings and messages, and the</a>
<a name="ln708">// repeated methods only make sense for repeated types.  So, each type</a>
<a name="ln709">// traits class implements only the set of methods from this signature that it</a>
<a name="ln710">// actually supports.  This will cause a compiler error if the user tries to</a>
<a name="ln711">// access an extension using a method that doesn't make sense for its type.</a>
<a name="ln712">// For example, if &quot;foo&quot; is an extension of type &quot;optional int32&quot;, then if you</a>
<a name="ln713">// try to write code like:</a>
<a name="ln714">//   my_message.MutableExtension(foo)</a>
<a name="ln715">// you will get a compile error because PrimitiveTypeTraits&lt;int32&gt; does not</a>
<a name="ln716">// have a &quot;Mutable()&quot; method.</a>
<a name="ln717"> </a>
<a name="ln718">// -------------------------------------------------------------------</a>
<a name="ln719">// PrimitiveTypeTraits</a>
<a name="ln720"> </a>
<a name="ln721">// Since the ExtensionSet has different methods for each primitive type,</a>
<a name="ln722">// we must explicitly define the methods of the type traits class for each</a>
<a name="ln723">// known type.</a>
<a name="ln724">template &lt;typename Type&gt;</a>
<a name="ln725">class PrimitiveTypeTraits {</a>
<a name="ln726"> public:</a>
<a name="ln727">  typedef Type ConstType;</a>
<a name="ln728">  typedef Type MutableType;</a>
<a name="ln729">  typedef PrimitiveTypeTraits&lt;Type&gt; Singular;</a>
<a name="ln730"> </a>
<a name="ln731">  static inline ConstType Get(int number, const ExtensionSet&amp; set,</a>
<a name="ln732">                              ConstType default_value);</a>
<a name="ln733">  static inline void Set(int number, FieldType field_type,</a>
<a name="ln734">                         ConstType value, ExtensionSet* set);</a>
<a name="ln735">  template &lt;typename ExtendeeT&gt;</a>
<a name="ln736">  static void Register(int number, FieldType type, bool is_packed) {</a>
<a name="ln737">    ExtensionSet::RegisterExtension(&amp;ExtendeeT::default_instance(), number,</a>
<a name="ln738">                                    type, false, is_packed);</a>
<a name="ln739">  }</a>
<a name="ln740">};</a>
<a name="ln741"> </a>
<a name="ln742">template &lt;typename Type&gt;</a>
<a name="ln743">class RepeatedPrimitiveTypeTraits {</a>
<a name="ln744"> public:</a>
<a name="ln745">  typedef Type ConstType;</a>
<a name="ln746">  typedef Type MutableType;</a>
<a name="ln747">  typedef RepeatedPrimitiveTypeTraits&lt;Type&gt; Repeated;</a>
<a name="ln748"> </a>
<a name="ln749">  typedef RepeatedField&lt;Type&gt; RepeatedFieldType;</a>
<a name="ln750"> </a>
<a name="ln751">  static inline Type Get(int number, const ExtensionSet&amp; set, int index);</a>
<a name="ln752">  static inline void Set(int number, int index, Type value, ExtensionSet* set);</a>
<a name="ln753">  static inline void Add(int number, FieldType field_type,</a>
<a name="ln754">                         bool is_packed, Type value, ExtensionSet* set);</a>
<a name="ln755"> </a>
<a name="ln756">  static inline const RepeatedField&lt;ConstType&gt;&amp;</a>
<a name="ln757">      GetRepeated(int number, const ExtensionSet&amp; set);</a>
<a name="ln758">  static inline RepeatedField&lt;Type&gt;*</a>
<a name="ln759">      MutableRepeated(int number, FieldType field_type,</a>
<a name="ln760">                      bool is_packed, ExtensionSet* set);</a>
<a name="ln761"> </a>
<a name="ln762">  static const RepeatedFieldType* GetDefaultRepeatedField();</a>
<a name="ln763">  template &lt;typename ExtendeeT&gt;</a>
<a name="ln764">  static void Register(int number, FieldType type, bool is_packed) {</a>
<a name="ln765">    ExtensionSet::RegisterExtension(&amp;ExtendeeT::default_instance(), number,</a>
<a name="ln766">                                    type, true, is_packed);</a>
<a name="ln767">  }</a>
<a name="ln768">};</a>
<a name="ln769"> </a>
<a name="ln770">LIBPROTOBUF_EXPORT extern ProtobufOnceType repeated_primitive_generic_type_traits_once_init_;</a>
<a name="ln771"> </a>
<a name="ln772">class LIBPROTOBUF_EXPORT RepeatedPrimitiveGenericTypeTraits {</a>
<a name="ln773"> private:</a>
<a name="ln774">  template&lt;typename Type&gt; friend class RepeatedPrimitiveTypeTraits;</a>
<a name="ln775">  static void InitializeDefaultRepeatedFields();</a>
<a name="ln776">  static void DestroyDefaultRepeatedFields();</a>
<a name="ln777">  static const RepeatedField&lt;int32&gt;* default_repeated_field_int32_;</a>
<a name="ln778">  static const RepeatedField&lt;int64&gt;* default_repeated_field_int64_;</a>
<a name="ln779">  static const RepeatedField&lt;uint32&gt;* default_repeated_field_uint32_;</a>
<a name="ln780">  static const RepeatedField&lt;uint64&gt;* default_repeated_field_uint64_;</a>
<a name="ln781">  static const RepeatedField&lt;double&gt;* default_repeated_field_double_;</a>
<a name="ln782">  static const RepeatedField&lt;float&gt;* default_repeated_field_float_;</a>
<a name="ln783">  static const RepeatedField&lt;bool&gt;* default_repeated_field_bool_;</a>
<a name="ln784">};</a>
<a name="ln785"> </a>
<a name="ln786">#define PROTOBUF_DEFINE_PRIMITIVE_TYPE(TYPE, METHOD)                       \</a>
<a name="ln787">template&lt;&gt; inline TYPE PrimitiveTypeTraits&lt;TYPE&gt;::Get(                     \</a>
<a name="ln788">    int number, const ExtensionSet&amp; set, TYPE default_value) {             \</a>
<a name="ln789">  return set.Get##METHOD(number, default_value);                           \</a>
<a name="ln790">}                                                                          \</a>
<a name="ln791">template&lt;&gt; inline void PrimitiveTypeTraits&lt;TYPE&gt;::Set(                     \</a>
<a name="ln792">    int number, FieldType field_type, TYPE value, ExtensionSet* set) {     \</a>
<a name="ln793">  set-&gt;Set##METHOD(number, field_type, value, NULL);                       \</a>
<a name="ln794">}                                                                          \</a>
<a name="ln795">                                                                           \</a>
<a name="ln796">template&lt;&gt; inline TYPE RepeatedPrimitiveTypeTraits&lt;TYPE&gt;::Get(             \</a>
<a name="ln797">    int number, const ExtensionSet&amp; set, int index) {                      \</a>
<a name="ln798">  return set.GetRepeated##METHOD(number, index);                           \</a>
<a name="ln799">}                                                                          \</a>
<a name="ln800">template&lt;&gt; inline void RepeatedPrimitiveTypeTraits&lt;TYPE&gt;::Set(             \</a>
<a name="ln801">    int number, int index, TYPE value, ExtensionSet* set) {                \</a>
<a name="ln802">  set-&gt;SetRepeated##METHOD(number, index, value);                          \</a>
<a name="ln803">}                                                                          \</a>
<a name="ln804">template&lt;&gt; inline void RepeatedPrimitiveTypeTraits&lt;TYPE&gt;::Add(             \</a>
<a name="ln805">    int number, FieldType field_type, bool is_packed,                      \</a>
<a name="ln806">    TYPE value, ExtensionSet* set) {                                       \</a>
<a name="ln807">  set-&gt;Add##METHOD(number, field_type, is_packed, value, NULL);            \</a>
<a name="ln808">}                                                                          \</a>
<a name="ln809">template&lt;&gt; inline const RepeatedField&lt;TYPE&gt;*                               \</a>
<a name="ln810">    RepeatedPrimitiveTypeTraits&lt;TYPE&gt;::GetDefaultRepeatedField() {         \</a>
<a name="ln811">  ::google::protobuf::GoogleOnceInit(                                                          \</a>
<a name="ln812">      &amp;repeated_primitive_generic_type_traits_once_init_,                  \</a>
<a name="ln813">      &amp;RepeatedPrimitiveGenericTypeTraits::InitializeDefaultRepeatedFields); \</a>
<a name="ln814">  return RepeatedPrimitiveGenericTypeTraits::                              \</a>
<a name="ln815">      default_repeated_field_##TYPE##_;                                    \</a>
<a name="ln816">}                                                                          \</a>
<a name="ln817">template&lt;&gt; inline const RepeatedField&lt;TYPE&gt;&amp;                               \</a>
<a name="ln818">    RepeatedPrimitiveTypeTraits&lt;TYPE&gt;::GetRepeated(int number,             \</a>
<a name="ln819">                                               const ExtensionSet&amp; set) {  \</a>
<a name="ln820">  return *reinterpret_cast&lt;const RepeatedField&lt;TYPE&gt;*&gt;(                    \</a>
<a name="ln821">                            set.GetRawRepeatedField(                       \</a>
<a name="ln822">                                number, GetDefaultRepeatedField()));       \</a>
<a name="ln823">}                                                                          \</a>
<a name="ln824">template&lt;&gt; inline RepeatedField&lt;TYPE&gt;*                                     \</a>
<a name="ln825">    RepeatedPrimitiveTypeTraits&lt;TYPE&gt;::MutableRepeated(int number,         \</a>
<a name="ln826">                                                   FieldType field_type,   \</a>
<a name="ln827">                                                   bool is_packed,         \</a>
<a name="ln828">                                                   ExtensionSet* set) {    \</a>
<a name="ln829">  return reinterpret_cast&lt;RepeatedField&lt;TYPE&gt;*&gt;(                           \</a>
<a name="ln830">      set-&gt;MutableRawRepeatedField(number, field_type, is_packed, NULL));  \</a>
<a name="ln831">}</a>
<a name="ln832"> </a>
<a name="ln833">PROTOBUF_DEFINE_PRIMITIVE_TYPE( int32,  Int32)</a>
<a name="ln834">PROTOBUF_DEFINE_PRIMITIVE_TYPE( int64,  Int64)</a>
<a name="ln835">PROTOBUF_DEFINE_PRIMITIVE_TYPE(uint32, UInt32)</a>
<a name="ln836">PROTOBUF_DEFINE_PRIMITIVE_TYPE(uint64, UInt64)</a>
<a name="ln837">PROTOBUF_DEFINE_PRIMITIVE_TYPE( float,  Float)</a>
<a name="ln838">PROTOBUF_DEFINE_PRIMITIVE_TYPE(double, Double)</a>
<a name="ln839">PROTOBUF_DEFINE_PRIMITIVE_TYPE(  bool,   Bool)</a>
<a name="ln840"> </a>
<a name="ln841">#undef PROTOBUF_DEFINE_PRIMITIVE_TYPE</a>
<a name="ln842"> </a>
<a name="ln843">// -------------------------------------------------------------------</a>
<a name="ln844">// StringTypeTraits</a>
<a name="ln845"> </a>
<a name="ln846">// Strings support both Set() and Mutable().</a>
<a name="ln847">class LIBPROTOBUF_EXPORT StringTypeTraits {</a>
<a name="ln848"> public:</a>
<a name="ln849">  typedef const string&amp; ConstType;</a>
<a name="ln850">  typedef string* MutableType;</a>
<a name="ln851">  typedef StringTypeTraits Singular;</a>
<a name="ln852"> </a>
<a name="ln853">  static inline const string&amp; Get(int number, const ExtensionSet&amp; set,</a>
<a name="ln854">                                  ConstType default_value) {</a>
<a name="ln855">    return set.GetString(number, default_value);</a>
<a name="ln856">  }</a>
<a name="ln857">  static inline void Set(int number, FieldType field_type,</a>
<a name="ln858">                         const string&amp; value, ExtensionSet* set) {</a>
<a name="ln859">    set-&gt;SetString(number, field_type, value, NULL);</a>
<a name="ln860">  }</a>
<a name="ln861">  static inline string* Mutable(int number, FieldType field_type,</a>
<a name="ln862">                                ExtensionSet* set) {</a>
<a name="ln863">    return set-&gt;MutableString(number, field_type, NULL);</a>
<a name="ln864">  }</a>
<a name="ln865">  template &lt;typename ExtendeeT&gt;</a>
<a name="ln866">  static void Register(int number, FieldType type, bool is_packed) {</a>
<a name="ln867">    ExtensionSet::RegisterExtension(&amp;ExtendeeT::default_instance(), number,</a>
<a name="ln868">                                    type, false, is_packed);</a>
<a name="ln869">  }</a>
<a name="ln870">};</a>
<a name="ln871"> </a>
<a name="ln872">LIBPROTOBUF_EXPORT extern ProtobufOnceType repeated_string_type_traits_once_init_;</a>
<a name="ln873"> </a>
<a name="ln874">class LIBPROTOBUF_EXPORT RepeatedStringTypeTraits {</a>
<a name="ln875"> public:</a>
<a name="ln876">  typedef const string&amp; ConstType;</a>
<a name="ln877">  typedef string* MutableType;</a>
<a name="ln878">  typedef RepeatedStringTypeTraits Repeated;</a>
<a name="ln879"> </a>
<a name="ln880">  typedef RepeatedPtrField&lt;string&gt; RepeatedFieldType;</a>
<a name="ln881"> </a>
<a name="ln882">  static inline const string&amp; Get(int number, const ExtensionSet&amp; set,</a>
<a name="ln883">                                  int index) {</a>
<a name="ln884">    return set.GetRepeatedString(number, index);</a>
<a name="ln885">  }</a>
<a name="ln886">  static inline void Set(int number, int index,</a>
<a name="ln887">                         const string&amp; value, ExtensionSet* set) {</a>
<a name="ln888">    set-&gt;SetRepeatedString(number, index, value);</a>
<a name="ln889">  }</a>
<a name="ln890">  static inline string* Mutable(int number, int index, ExtensionSet* set) {</a>
<a name="ln891">    return set-&gt;MutableRepeatedString(number, index);</a>
<a name="ln892">  }</a>
<a name="ln893">  static inline void Add(int number, FieldType field_type,</a>
<a name="ln894">                         bool /*is_packed*/, const string&amp; value,</a>
<a name="ln895">                         ExtensionSet* set) {</a>
<a name="ln896">    set-&gt;AddString(number, field_type, value, NULL);</a>
<a name="ln897">  }</a>
<a name="ln898">  static inline string* Add(int number, FieldType field_type,</a>
<a name="ln899">                            ExtensionSet* set) {</a>
<a name="ln900">    return set-&gt;AddString(number, field_type, NULL);</a>
<a name="ln901">  }</a>
<a name="ln902">  static inline const RepeatedPtrField&lt;string&gt;&amp;</a>
<a name="ln903">      GetRepeated(int number, const ExtensionSet&amp; set) {</a>
<a name="ln904">    return *reinterpret_cast&lt;const RepeatedPtrField&lt;string&gt;*&gt;(</a>
<a name="ln905">        set.GetRawRepeatedField(number, GetDefaultRepeatedField()));</a>
<a name="ln906">  }</a>
<a name="ln907"> </a>
<a name="ln908">  static inline RepeatedPtrField&lt;string&gt;*</a>
<a name="ln909">      MutableRepeated(int number, FieldType field_type,</a>
<a name="ln910">                      bool is_packed, ExtensionSet* set) {</a>
<a name="ln911">    return reinterpret_cast&lt;RepeatedPtrField&lt;string&gt;*&gt;(</a>
<a name="ln912">        set-&gt;MutableRawRepeatedField(number, field_type,</a>
<a name="ln913">                                     is_packed, NULL));</a>
<a name="ln914">  }</a>
<a name="ln915"> </a>
<a name="ln916">  static const RepeatedFieldType* GetDefaultRepeatedField() {</a>
<a name="ln917">    ::google::protobuf::GoogleOnceInit(&amp;repeated_string_type_traits_once_init_,</a>
<a name="ln918">                   &amp;InitializeDefaultRepeatedFields);</a>
<a name="ln919">    return default_repeated_field_;</a>
<a name="ln920">  }</a>
<a name="ln921"> </a>
<a name="ln922">  template &lt;typename ExtendeeT&gt;</a>
<a name="ln923">  static void Register(int number, FieldType type, bool is_packed) {</a>
<a name="ln924">    ExtensionSet::RegisterExtension(&amp;ExtendeeT::default_instance(), number,</a>
<a name="ln925">                                    type, true, is_packed);</a>
<a name="ln926">  }</a>
<a name="ln927"> </a>
<a name="ln928"> private:</a>
<a name="ln929">  static void InitializeDefaultRepeatedFields();</a>
<a name="ln930">  static void DestroyDefaultRepeatedFields();</a>
<a name="ln931">  static const RepeatedFieldType *default_repeated_field_;</a>
<a name="ln932">};</a>
<a name="ln933"> </a>
<a name="ln934">// -------------------------------------------------------------------</a>
<a name="ln935">// EnumTypeTraits</a>
<a name="ln936"> </a>
<a name="ln937">// ExtensionSet represents enums using integers internally, so we have to</a>
<a name="ln938">// static_cast around.</a>
<a name="ln939">template &lt;typename Type, bool IsValid(int)&gt;</a>
<a name="ln940">class EnumTypeTraits {</a>
<a name="ln941"> public:</a>
<a name="ln942">  typedef Type ConstType;</a>
<a name="ln943">  typedef Type MutableType;</a>
<a name="ln944">  typedef EnumTypeTraits&lt;Type, IsValid&gt; Singular;</a>
<a name="ln945"> </a>
<a name="ln946">  static inline ConstType Get(int number, const ExtensionSet&amp; set,</a>
<a name="ln947">                              ConstType default_value) {</a>
<a name="ln948">    return static_cast&lt;Type&gt;(set.GetEnum(number, default_value));</a>
<a name="ln949">  }</a>
<a name="ln950">  static inline void Set(int number, FieldType field_type,</a>
<a name="ln951">                         ConstType value, ExtensionSet* set) {</a>
<a name="ln952">    GOOGLE_DCHECK(IsValid(value));</a>
<a name="ln953">    set-&gt;SetEnum(number, field_type, value, NULL);</a>
<a name="ln954">  }</a>
<a name="ln955">  template &lt;typename ExtendeeT&gt;</a>
<a name="ln956">  static void Register(int number, FieldType type, bool is_packed) {</a>
<a name="ln957">    ExtensionSet::RegisterEnumExtension(&amp;ExtendeeT::default_instance(), number,</a>
<a name="ln958">                                        type, false, is_packed, IsValid);</a>
<a name="ln959">  }</a>
<a name="ln960">};</a>
<a name="ln961"> </a>
<a name="ln962">template &lt;typename Type, bool IsValid(int)&gt;</a>
<a name="ln963">class RepeatedEnumTypeTraits {</a>
<a name="ln964"> public:</a>
<a name="ln965">  typedef Type ConstType;</a>
<a name="ln966">  typedef Type MutableType;</a>
<a name="ln967">  typedef RepeatedEnumTypeTraits&lt;Type, IsValid&gt; Repeated;</a>
<a name="ln968"> </a>
<a name="ln969">  typedef RepeatedField&lt;Type&gt; RepeatedFieldType;</a>
<a name="ln970"> </a>
<a name="ln971">  static inline ConstType Get(int number, const ExtensionSet&amp; set, int index) {</a>
<a name="ln972">    return static_cast&lt;Type&gt;(set.GetRepeatedEnum(number, index));</a>
<a name="ln973">  }</a>
<a name="ln974">  static inline void Set(int number, int index,</a>
<a name="ln975">                         ConstType value, ExtensionSet* set) {</a>
<a name="ln976">    GOOGLE_DCHECK(IsValid(value));</a>
<a name="ln977">    set-&gt;SetRepeatedEnum(number, index, value);</a>
<a name="ln978">  }</a>
<a name="ln979">  static inline void Add(int number, FieldType field_type,</a>
<a name="ln980">                         bool is_packed, ConstType value, ExtensionSet* set) {</a>
<a name="ln981">    GOOGLE_DCHECK(IsValid(value));</a>
<a name="ln982">    set-&gt;AddEnum(number, field_type, is_packed, value, NULL);</a>
<a name="ln983">  }</a>
<a name="ln984">  static inline const RepeatedField&lt;Type&gt;&amp; GetRepeated(int number,</a>
<a name="ln985">                                                       const ExtensionSet&amp;</a>
<a name="ln986">                                                       set) {</a>
<a name="ln987">    // Hack: the `Extension` struct stores a RepeatedField&lt;int&gt; for enums.</a>
<a name="ln988">    // RepeatedField&lt;int&gt; cannot implicitly convert to RepeatedField&lt;EnumType&gt;</a>
<a name="ln989">    // so we need to do some casting magic. See message.h for similar</a>
<a name="ln990">    // contortions for non-extension fields.</a>
<a name="ln991">    return *reinterpret_cast&lt;const RepeatedField&lt;Type&gt;*&gt;(</a>
<a name="ln992">        set.GetRawRepeatedField(number, GetDefaultRepeatedField()));</a>
<a name="ln993">  }</a>
<a name="ln994"> </a>
<a name="ln995">  static inline RepeatedField&lt;Type&gt;* MutableRepeated(int number,</a>
<a name="ln996">                                                     FieldType field_type,</a>
<a name="ln997">                                                     bool is_packed,</a>
<a name="ln998">                                                     ExtensionSet* set) {</a>
<a name="ln999">    return reinterpret_cast&lt;RepeatedField&lt;Type&gt;*&gt;(</a>
<a name="ln1000">        set-&gt;MutableRawRepeatedField(number, field_type, is_packed, NULL));</a>
<a name="ln1001">  }</a>
<a name="ln1002"> </a>
<a name="ln1003">  static const RepeatedFieldType* GetDefaultRepeatedField() {</a>
<a name="ln1004">    // Hack: as noted above, repeated enum fields are internally stored as a</a>
<a name="ln1005">    // RepeatedField&lt;int&gt;. We need to be able to instantiate global static</a>
<a name="ln1006">    // objects to return as default (empty) repeated fields on non-existent</a>
<a name="ln1007">    // extensions. We would not be able to know a-priori all of the enum types</a>
<a name="ln1008">    // (values of |Type|) to instantiate all of these, so we just re-use int32's</a>
<a name="ln1009">    // default repeated field object.</a>
<a name="ln1010">    return reinterpret_cast&lt;const RepeatedField&lt;Type&gt;*&gt;(</a>
<a name="ln1011">        RepeatedPrimitiveTypeTraits&lt;int32&gt;::GetDefaultRepeatedField());</a>
<a name="ln1012">  }</a>
<a name="ln1013">  template &lt;typename ExtendeeT&gt;</a>
<a name="ln1014">  static void Register(int number, FieldType type, bool is_packed) {</a>
<a name="ln1015">    ExtensionSet::RegisterEnumExtension(&amp;ExtendeeT::default_instance(), number,</a>
<a name="ln1016">                                        type, true, is_packed, IsValid);</a>
<a name="ln1017">  }</a>
<a name="ln1018">};</a>
<a name="ln1019"> </a>
<a name="ln1020">// -------------------------------------------------------------------</a>
<a name="ln1021">// MessageTypeTraits</a>
<a name="ln1022"> </a>
<a name="ln1023">// ExtensionSet guarantees that when manipulating extensions with message</a>
<a name="ln1024">// types, the implementation used will be the compiled-in class representing</a>
<a name="ln1025">// that type.  So, we can static_cast down to the exact type we expect.</a>
<a name="ln1026">template &lt;typename Type&gt;</a>
<a name="ln1027">class MessageTypeTraits {</a>
<a name="ln1028"> public:</a>
<a name="ln1029">  typedef const Type&amp; ConstType;</a>
<a name="ln1030">  typedef Type* MutableType;</a>
<a name="ln1031">  typedef MessageTypeTraits&lt;Type&gt; Singular;</a>
<a name="ln1032"> </a>
<a name="ln1033">  static inline ConstType Get(int number, const ExtensionSet&amp; set,</a>
<a name="ln1034">                              ConstType default_value) {</a>
<a name="ln1035">    return static_cast&lt;const Type&amp;&gt;(</a>
<a name="ln1036">        set.GetMessage(number, default_value));</a>
<a name="ln1037">  }</a>
<a name="ln1038">  static inline MutableType Mutable(int number, FieldType field_type,</a>
<a name="ln1039">                                    ExtensionSet* set) {</a>
<a name="ln1040">    return static_cast&lt;Type*&gt;(</a>
<a name="ln1041">      set-&gt;MutableMessage(number, field_type, Type::default_instance(), NULL));</a>
<a name="ln1042">  }</a>
<a name="ln1043">  static inline void SetAllocated(int number, FieldType field_type,</a>
<a name="ln1044">                                  MutableType message, ExtensionSet* set) {</a>
<a name="ln1045">    set-&gt;SetAllocatedMessage(number, field_type, NULL, message);</a>
<a name="ln1046">  }</a>
<a name="ln1047">  static inline void UnsafeArenaSetAllocated(int number, FieldType field_type,</a>
<a name="ln1048">                                             MutableType message,</a>
<a name="ln1049">                                             ExtensionSet* set) {</a>
<a name="ln1050">    set-&gt;UnsafeArenaSetAllocatedMessage(number, field_type, NULL, message);</a>
<a name="ln1051">  }</a>
<a name="ln1052">  static inline MutableType Release(int number, FieldType /* field_type */,</a>
<a name="ln1053">                                    ExtensionSet* set) {</a>
<a name="ln1054">    return static_cast&lt;Type*&gt;(set-&gt;ReleaseMessage(</a>
<a name="ln1055">        number, Type::default_instance()));</a>
<a name="ln1056">  }</a>
<a name="ln1057">  static inline MutableType UnsafeArenaRelease(int number,</a>
<a name="ln1058">                                               FieldType /* field_type */,</a>
<a name="ln1059">                                               ExtensionSet* set) {</a>
<a name="ln1060">    return static_cast&lt;Type*&gt;(set-&gt;UnsafeArenaReleaseMessage(</a>
<a name="ln1061">        number, Type::default_instance()));</a>
<a name="ln1062">  }</a>
<a name="ln1063">  template &lt;typename ExtendeeT&gt;</a>
<a name="ln1064">  static void Register(int number, FieldType type, bool is_packed) {</a>
<a name="ln1065">    ExtensionSet::RegisterMessageExtension(&amp;ExtendeeT::default_instance(),</a>
<a name="ln1066">                                           number, type, false, is_packed,</a>
<a name="ln1067">                                           &amp;Type::default_instance());</a>
<a name="ln1068">  }</a>
<a name="ln1069">};</a>
<a name="ln1070"> </a>
<a name="ln1071">// forward declaration</a>
<a name="ln1072">class RepeatedMessageGenericTypeTraits;</a>
<a name="ln1073"> </a>
<a name="ln1074">template &lt;typename Type&gt;</a>
<a name="ln1075">class RepeatedMessageTypeTraits {</a>
<a name="ln1076"> public:</a>
<a name="ln1077">  typedef const Type&amp; ConstType;</a>
<a name="ln1078">  typedef Type* MutableType;</a>
<a name="ln1079">  typedef RepeatedMessageTypeTraits&lt;Type&gt; Repeated;</a>
<a name="ln1080"> </a>
<a name="ln1081">  typedef RepeatedPtrField&lt;Type&gt; RepeatedFieldType;</a>
<a name="ln1082"> </a>
<a name="ln1083">  static inline ConstType Get(int number, const ExtensionSet&amp; set, int index) {</a>
<a name="ln1084">    return static_cast&lt;const Type&amp;&gt;(set.GetRepeatedMessage(number, index));</a>
<a name="ln1085">  }</a>
<a name="ln1086">  static inline MutableType Mutable(int number, int index, ExtensionSet* set) {</a>
<a name="ln1087">    return static_cast&lt;Type*&gt;(set-&gt;MutableRepeatedMessage(number, index));</a>
<a name="ln1088">  }</a>
<a name="ln1089">  static inline MutableType Add(int number, FieldType field_type,</a>
<a name="ln1090">                                ExtensionSet* set) {</a>
<a name="ln1091">    return static_cast&lt;Type*&gt;(</a>
<a name="ln1092">        set-&gt;AddMessage(number, field_type, Type::default_instance(), NULL));</a>
<a name="ln1093">  }</a>
<a name="ln1094">  static inline const RepeatedPtrField&lt;Type&gt;&amp; GetRepeated(int number,</a>
<a name="ln1095">                                                          const ExtensionSet&amp;</a>
<a name="ln1096">                                                          set) {</a>
<a name="ln1097">    // See notes above in RepeatedEnumTypeTraits::GetRepeated(): same</a>
<a name="ln1098">    // casting hack applies here, because a RepeatedPtrField&lt;MessageLite&gt;</a>
<a name="ln1099">    // cannot naturally become a RepeatedPtrType&lt;Type&gt; even though Type is</a>
<a name="ln1100">    // presumably a message. google::protobuf::Message goes through similar contortions</a>
<a name="ln1101">    // with a reinterpret_cast&lt;&gt;.</a>
<a name="ln1102">    return *reinterpret_cast&lt;const RepeatedPtrField&lt;Type&gt;*&gt;(</a>
<a name="ln1103">        set.GetRawRepeatedField(number, GetDefaultRepeatedField()));</a>
<a name="ln1104">  }</a>
<a name="ln1105">  static inline RepeatedPtrField&lt;Type&gt;* MutableRepeated(int number,</a>
<a name="ln1106">                                                        FieldType field_type,</a>
<a name="ln1107">                                                        bool is_packed,</a>
<a name="ln1108">                                                        ExtensionSet* set) {</a>
<a name="ln1109">    return reinterpret_cast&lt;RepeatedPtrField&lt;Type&gt;*&gt;(</a>
<a name="ln1110">        set-&gt;MutableRawRepeatedField(number, field_type, is_packed, NULL));</a>
<a name="ln1111">  }</a>
<a name="ln1112"> </a>
<a name="ln1113">  static const RepeatedFieldType* GetDefaultRepeatedField();</a>
<a name="ln1114">  template &lt;typename ExtendeeT&gt;</a>
<a name="ln1115">  static void Register(int number, FieldType type, bool is_packed) {</a>
<a name="ln1116">    ExtensionSet::RegisterMessageExtension(&amp;ExtendeeT::default_instance(),</a>
<a name="ln1117">                                           number, type, true, is_packed,</a>
<a name="ln1118">                                           &amp;Type::default_instance());</a>
<a name="ln1119">  }</a>
<a name="ln1120">};</a>
<a name="ln1121"> </a>
<a name="ln1122">LIBPROTOBUF_EXPORT extern ProtobufOnceType repeated_message_generic_type_traits_once_init_;</a>
<a name="ln1123"> </a>
<a name="ln1124">// This class exists only to hold a generic default empty repeated field for all</a>
<a name="ln1125">// message-type repeated field extensions.</a>
<a name="ln1126">class LIBPROTOBUF_EXPORT RepeatedMessageGenericTypeTraits {</a>
<a name="ln1127"> public:</a>
<a name="ln1128">  typedef RepeatedPtrField&lt; ::google::protobuf::MessageLite*&gt; RepeatedFieldType;</a>
<a name="ln1129"> private:</a>
<a name="ln1130">  template&lt;typename Type&gt; friend class RepeatedMessageTypeTraits;</a>
<a name="ln1131">  static void InitializeDefaultRepeatedFields();</a>
<a name="ln1132">  static void DestroyDefaultRepeatedFields();</a>
<a name="ln1133">  static const RepeatedFieldType* default_repeated_field_;</a>
<a name="ln1134">};</a>
<a name="ln1135"> </a>
<a name="ln1136">template&lt;typename Type&gt; inline</a>
<a name="ln1137">    const typename RepeatedMessageTypeTraits&lt;Type&gt;::RepeatedFieldType*</a>
<a name="ln1138">    RepeatedMessageTypeTraits&lt;Type&gt;::GetDefaultRepeatedField() {</a>
<a name="ln1139">  ::google::protobuf::GoogleOnceInit(</a>
<a name="ln1140">      &amp;repeated_message_generic_type_traits_once_init_,</a>
<a name="ln1141">      &amp;RepeatedMessageGenericTypeTraits::InitializeDefaultRepeatedFields);</a>
<a name="ln1142">  return reinterpret_cast&lt;const RepeatedFieldType*&gt;(</a>
<a name="ln1143">      RepeatedMessageGenericTypeTraits::default_repeated_field_);</a>
<a name="ln1144">}</a>
<a name="ln1145"> </a>
<a name="ln1146">// -------------------------------------------------------------------</a>
<a name="ln1147">// ExtensionIdentifier</a>
<a name="ln1148"> </a>
<a name="ln1149">// This is the type of actual extension objects.  E.g. if you have:</a>
<a name="ln1150">//   extends Foo with optional int32 bar = 1234;</a>
<a name="ln1151">// then &quot;bar&quot; will be defined in C++ as:</a>
<a name="ln1152">//   ExtensionIdentifier&lt;Foo, PrimitiveTypeTraits&lt;int32&gt;, 1, false&gt; bar(1234);</a>
<a name="ln1153">//</a>
<a name="ln1154">// Note that we could, in theory, supply the field number as a template</a>
<a name="ln1155">// parameter, and thus make an instance of ExtensionIdentifier have no</a>
<a name="ln1156">// actual contents.  However, if we did that, then using at extension</a>
<a name="ln1157">// identifier would not necessarily cause the compiler to output any sort</a>
<a name="ln1158">// of reference to any symbol defined in the extension's .pb.o file.  Some</a>
<a name="ln1159">// linkers will actually drop object files that are not explicitly referenced,</a>
<a name="ln1160">// but that would be bad because it would cause this extension to not be</a>
<a name="ln1161">// registered at static initialization, and therefore using it would crash.</a>
<a name="ln1162"> </a>
<a name="ln1163">template &lt;typename ExtendeeType, typename TypeTraitsType,</a>
<a name="ln1164">          FieldType field_type, bool is_packed&gt;</a>
<a name="ln1165">class ExtensionIdentifier {</a>
<a name="ln1166"> public:</a>
<a name="ln1167">  typedef TypeTraitsType TypeTraits;</a>
<a name="ln1168">  typedef ExtendeeType Extendee;</a>
<a name="ln1169"> </a>
<a name="ln1170">  ExtensionIdentifier(int number, typename TypeTraits::ConstType default_value)</a>
<a name="ln1171">      : number_(number), default_value_(default_value) {</a>
<a name="ln1172">    Register(number);</a>
<a name="ln1173">  }</a>
<a name="ln1174">  inline int number() const { return number_; }</a>
<a name="ln1175">  typename TypeTraits::ConstType default_value() const {</a>
<a name="ln1176">    return default_value_;</a>
<a name="ln1177">  }</a>
<a name="ln1178"> </a>
<a name="ln1179">  static void Register(int number) {</a>
<a name="ln1180">    TypeTraits::template Register&lt;ExtendeeType&gt;(number, field_type, is_packed);</a>
<a name="ln1181">  }</a>
<a name="ln1182"> </a>
<a name="ln1183"> private:</a>
<a name="ln1184">  const int number_;</a>
<a name="ln1185">  typename TypeTraits::ConstType default_value_;</a>
<a name="ln1186">};</a>
<a name="ln1187"> </a>
<a name="ln1188">// -------------------------------------------------------------------</a>
<a name="ln1189">// Generated accessors</a>
<a name="ln1190"> </a>
<a name="ln1191">// This macro should be expanded in the context of a generated type which</a>
<a name="ln1192">// has extensions.</a>
<a name="ln1193">//</a>
<a name="ln1194">// We use &quot;_proto_TypeTraits&quot; as a type name below because &quot;TypeTraits&quot;</a>
<a name="ln1195">// causes problems if the class has a nested message or enum type with that</a>
<a name="ln1196">// name and &quot;_TypeTraits&quot; is technically reserved for the C++ library since</a>
<a name="ln1197">// it starts with an underscore followed by a capital letter.</a>
<a name="ln1198">//</a>
<a name="ln1199">// For similar reason, we use &quot;_field_type&quot; and &quot;_is_packed&quot; as parameter names</a>
<a name="ln1200">// below, so that &quot;field_type&quot; and &quot;is_packed&quot; can be used as field names.</a>
<a name="ln1201">#define GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(CLASSNAME)                        \</a>
<a name="ln1202">  /* Has, Size, Clear */                                                      \</a>
<a name="ln1203">  template &lt;typename _proto_TypeTraits,                                       \</a>
<a name="ln1204">            ::google::protobuf::internal::FieldType _field_type,                        \</a>
<a name="ln1205">            bool _is_packed&gt;                                                  \</a>
<a name="ln1206">  inline bool HasExtension(                                                   \</a>
<a name="ln1207">      const ::google::protobuf::internal::ExtensionIdentifier&lt;                          \</a>
<a name="ln1208">        CLASSNAME, _proto_TypeTraits, _field_type, _is_packed&gt;&amp; id) const {   \</a>
<a name="ln1209">    return _extensions_.Has(id.number());                                     \</a>
<a name="ln1210">  }                                                                           \</a>
<a name="ln1211">                                                                              \</a>
<a name="ln1212">  template &lt;typename _proto_TypeTraits,                                       \</a>
<a name="ln1213">            ::google::protobuf::internal::FieldType _field_type,                        \</a>
<a name="ln1214">            bool _is_packed&gt;                                                  \</a>
<a name="ln1215">  inline void ClearExtension(                                                 \</a>
<a name="ln1216">      const ::google::protobuf::internal::ExtensionIdentifier&lt;                          \</a>
<a name="ln1217">        CLASSNAME, _proto_TypeTraits, _field_type, _is_packed&gt;&amp; id) {         \</a>
<a name="ln1218">    _extensions_.ClearExtension(id.number());                                 \</a>
<a name="ln1219">  }                                                                           \</a>
<a name="ln1220">                                                                              \</a>
<a name="ln1221">  template &lt;typename _proto_TypeTraits,                                       \</a>
<a name="ln1222">            ::google::protobuf::internal::FieldType _field_type,                        \</a>
<a name="ln1223">            bool _is_packed&gt;                                                  \</a>
<a name="ln1224">  inline int ExtensionSize(                                                   \</a>
<a name="ln1225">      const ::google::protobuf::internal::ExtensionIdentifier&lt;                          \</a>
<a name="ln1226">        CLASSNAME, _proto_TypeTraits, _field_type, _is_packed&gt;&amp; id) const {   \</a>
<a name="ln1227">    return _extensions_.ExtensionSize(id.number());                           \</a>
<a name="ln1228">  }                                                                           \</a>
<a name="ln1229">                                                                              \</a>
<a name="ln1230">  /* Singular accessors */                                                    \</a>
<a name="ln1231">  template &lt;typename _proto_TypeTraits,                                       \</a>
<a name="ln1232">            ::google::protobuf::internal::FieldType _field_type,                        \</a>
<a name="ln1233">            bool _is_packed&gt;                                                  \</a>
<a name="ln1234">  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(        \</a>
<a name="ln1235">      const ::google::protobuf::internal::ExtensionIdentifier&lt;                          \</a>
<a name="ln1236">        CLASSNAME, _proto_TypeTraits, _field_type, _is_packed&gt;&amp; id) const {   \</a>
<a name="ln1237">    return _proto_TypeTraits::Get(id.number(), _extensions_,                  \</a>
<a name="ln1238">                                  id.default_value());                        \</a>
<a name="ln1239">  }                                                                           \</a>
<a name="ln1240">                                                                              \</a>
<a name="ln1241">  template &lt;typename _proto_TypeTraits,                                       \</a>
<a name="ln1242">            ::google::protobuf::internal::FieldType _field_type,                        \</a>
<a name="ln1243">            bool _is_packed&gt;                                                  \</a>
<a name="ln1244">  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(  \</a>
<a name="ln1245">      const ::google::protobuf::internal::ExtensionIdentifier&lt;                          \</a>
<a name="ln1246">        CLASSNAME, _proto_TypeTraits, _field_type, _is_packed&gt;&amp; id) {         \</a>
<a name="ln1247">    return _proto_TypeTraits::Mutable(id.number(), _field_type,               \</a>
<a name="ln1248">                                      &amp;_extensions_);                         \</a>
<a name="ln1249">  }                                                                           \</a>
<a name="ln1250">                                                                              \</a>
<a name="ln1251">  template &lt;typename _proto_TypeTraits,                                       \</a>
<a name="ln1252">            ::google::protobuf::internal::FieldType _field_type,                        \</a>
<a name="ln1253">            bool _is_packed&gt;                                                  \</a>
<a name="ln1254">  inline void SetExtension(                                                   \</a>
<a name="ln1255">      const ::google::protobuf::internal::ExtensionIdentifier&lt;                          \</a>
<a name="ln1256">        CLASSNAME, _proto_TypeTraits, _field_type, _is_packed&gt;&amp; id,           \</a>
<a name="ln1257">      typename _proto_TypeTraits::Singular::ConstType value) {                \</a>
<a name="ln1258">    _proto_TypeTraits::Set(id.number(), _field_type, value, &amp;_extensions_);   \</a>
<a name="ln1259">  }                                                                           \</a>
<a name="ln1260">                                                                              \</a>
<a name="ln1261">  template &lt;typename _proto_TypeTraits,                                       \</a>
<a name="ln1262">            ::google::protobuf::internal::FieldType _field_type,                        \</a>
<a name="ln1263">            bool _is_packed&gt;                                                  \</a>
<a name="ln1264">  inline void SetAllocatedExtension(                                          \</a>
<a name="ln1265">      const ::google::protobuf::internal::ExtensionIdentifier&lt;                          \</a>
<a name="ln1266">        CLASSNAME, _proto_TypeTraits, _field_type, _is_packed&gt;&amp; id,           \</a>
<a name="ln1267">      typename _proto_TypeTraits::Singular::MutableType value) {              \</a>
<a name="ln1268">    _proto_TypeTraits::SetAllocated(id.number(), _field_type,                 \</a>
<a name="ln1269">                                    value, &amp;_extensions_);                    \</a>
<a name="ln1270">  }                                                                           \</a>
<a name="ln1271">  template &lt;typename _proto_TypeTraits,                                       \</a>
<a name="ln1272">            ::google::protobuf::internal::FieldType _field_type,                        \</a>
<a name="ln1273">            bool _is_packed&gt;                                                  \</a>
<a name="ln1274">  inline void UnsafeArenaSetAllocatedExtension(                               \</a>
<a name="ln1275">      const ::google::protobuf::internal::ExtensionIdentifier&lt;                          \</a>
<a name="ln1276">        CLASSNAME, _proto_TypeTraits, _field_type, _is_packed&gt;&amp; id,           \</a>
<a name="ln1277">      typename _proto_TypeTraits::Singular::MutableType value) {              \</a>
<a name="ln1278">    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,      \</a>
<a name="ln1279">                                               value, &amp;_extensions_);         \</a>
<a name="ln1280">  }                                                                           \</a>
<a name="ln1281">  template &lt;typename _proto_TypeTraits,                                       \</a>
<a name="ln1282">            ::google::protobuf::internal::FieldType _field_type,                        \</a>
<a name="ln1283">            bool _is_packed&gt;                                                  \</a>
<a name="ln1284">  inline typename _proto_TypeTraits::Singular::MutableType ReleaseExtension(  \</a>
<a name="ln1285">      const ::google::protobuf::internal::ExtensionIdentifier&lt;                          \</a>
<a name="ln1286">        CLASSNAME, _proto_TypeTraits, _field_type, _is_packed&gt;&amp; id) {         \</a>
<a name="ln1287">    return _proto_TypeTraits::Release(id.number(), _field_type,               \</a>
<a name="ln1288">                                      &amp;_extensions_);                         \</a>
<a name="ln1289">  }                                                                           \</a>
<a name="ln1290">  template &lt;typename _proto_TypeTraits,                                       \</a>
<a name="ln1291">            ::google::protobuf::internal::FieldType _field_type,                        \</a>
<a name="ln1292">            bool _is_packed&gt;                                                  \</a>
<a name="ln1293">  inline typename _proto_TypeTraits::Singular::MutableType                    \</a>
<a name="ln1294">      UnsafeArenaReleaseExtension(                                            \</a>
<a name="ln1295">          const ::google::protobuf::internal::ExtensionIdentifier&lt;                      \</a>
<a name="ln1296">            CLASSNAME, _proto_TypeTraits, _field_type, _is_packed&gt;&amp; id) {     \</a>
<a name="ln1297">    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,    \</a>
<a name="ln1298">                                                 &amp;_extensions_);              \</a>
<a name="ln1299">  }                                                                           \</a>
<a name="ln1300">                                                                              \</a>
<a name="ln1301">  /* Repeated accessors */                                                    \</a>
<a name="ln1302">  template &lt;typename _proto_TypeTraits,                                       \</a>
<a name="ln1303">            ::google::protobuf::internal::FieldType _field_type,                        \</a>
<a name="ln1304">            bool _is_packed&gt;                                                  \</a>
<a name="ln1305">  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(        \</a>
<a name="ln1306">      const ::google::protobuf::internal::ExtensionIdentifier&lt;                          \</a>
<a name="ln1307">        CLASSNAME, _proto_TypeTraits, _field_type, _is_packed&gt;&amp; id,           \</a>
<a name="ln1308">      int index) const {                                                      \</a>
<a name="ln1309">    return _proto_TypeTraits::Get(id.number(), _extensions_, index);          \</a>
<a name="ln1310">  }                                                                           \</a>
<a name="ln1311">                                                                              \</a>
<a name="ln1312">  template &lt;typename _proto_TypeTraits,                                       \</a>
<a name="ln1313">            ::google::protobuf::internal::FieldType _field_type,                        \</a>
<a name="ln1314">            bool _is_packed&gt;                                                  \</a>
<a name="ln1315">  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(  \</a>
<a name="ln1316">      const ::google::protobuf::internal::ExtensionIdentifier&lt;                          \</a>
<a name="ln1317">        CLASSNAME, _proto_TypeTraits, _field_type, _is_packed&gt;&amp; id,           \</a>
<a name="ln1318">      int index) {                                                            \</a>
<a name="ln1319">    return _proto_TypeTraits::Mutable(id.number(), index, &amp;_extensions_);     \</a>
<a name="ln1320">  }                                                                           \</a>
<a name="ln1321">                                                                              \</a>
<a name="ln1322">  template &lt;typename _proto_TypeTraits,                                       \</a>
<a name="ln1323">            ::google::protobuf::internal::FieldType _field_type,                        \</a>
<a name="ln1324">            bool _is_packed&gt;                                                  \</a>
<a name="ln1325">  inline void SetExtension(                                                   \</a>
<a name="ln1326">      const ::google::protobuf::internal::ExtensionIdentifier&lt;                          \</a>
<a name="ln1327">        CLASSNAME, _proto_TypeTraits, _field_type, _is_packed&gt;&amp; id,           \</a>
<a name="ln1328">      int index, typename _proto_TypeTraits::Repeated::ConstType value) {     \</a>
<a name="ln1329">    _proto_TypeTraits::Set(id.number(), index, value, &amp;_extensions_);         \</a>
<a name="ln1330">  }                                                                           \</a>
<a name="ln1331">                                                                              \</a>
<a name="ln1332">  template &lt;typename _proto_TypeTraits,                                       \</a>
<a name="ln1333">            ::google::protobuf::internal::FieldType _field_type,                        \</a>
<a name="ln1334">            bool _is_packed&gt;                                                  \</a>
<a name="ln1335">  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(      \</a>
<a name="ln1336">      const ::google::protobuf::internal::ExtensionIdentifier&lt;                          \</a>
<a name="ln1337">        CLASSNAME, _proto_TypeTraits, _field_type, _is_packed&gt;&amp; id) {         \</a>
<a name="ln1338">    return _proto_TypeTraits::Add(id.number(), _field_type, &amp;_extensions_);   \</a>
<a name="ln1339">  }                                                                           \</a>
<a name="ln1340">                                                                              \</a>
<a name="ln1341">  template &lt;typename _proto_TypeTraits,                                       \</a>
<a name="ln1342">            ::google::protobuf::internal::FieldType _field_type,                        \</a>
<a name="ln1343">            bool _is_packed&gt;                                                  \</a>
<a name="ln1344">  inline void AddExtension(                                                   \</a>
<a name="ln1345">      const ::google::protobuf::internal::ExtensionIdentifier&lt;                          \</a>
<a name="ln1346">        CLASSNAME, _proto_TypeTraits, _field_type, _is_packed&gt;&amp; id,           \</a>
<a name="ln1347">      typename _proto_TypeTraits::Repeated::ConstType value) {                \</a>
<a name="ln1348">    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed,              \</a>
<a name="ln1349">                           value, &amp;_extensions_);                             \</a>
<a name="ln1350">  }                                                                           \</a>
<a name="ln1351">                                                                              \</a>
<a name="ln1352">  template &lt;typename _proto_TypeTraits,                                       \</a>
<a name="ln1353">            ::google::protobuf::internal::FieldType _field_type,                        \</a>
<a name="ln1354">            bool _is_packed&gt;                                                  \</a>
<a name="ln1355">  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&amp;       \</a>
<a name="ln1356">      GetRepeatedExtension(                                                   \</a>
<a name="ln1357">          const ::google::protobuf::internal::ExtensionIdentifier&lt;                      \</a>
<a name="ln1358">            CLASSNAME, _proto_TypeTraits, _field_type,                        \</a>
<a name="ln1359">            _is_packed&gt;&amp; id) const {                                          \</a>
<a name="ln1360">    return _proto_TypeTraits::GetRepeated(id.number(), _extensions_);         \</a>
<a name="ln1361">  }                                                                           \</a>
<a name="ln1362">                                                                              \</a>
<a name="ln1363">  template &lt;typename _proto_TypeTraits,                                       \</a>
<a name="ln1364">            ::google::protobuf::internal::FieldType _field_type,                        \</a>
<a name="ln1365">            bool _is_packed&gt;                                                  \</a>
<a name="ln1366">  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*             \</a>
<a name="ln1367">      MutableRepeatedExtension(                                               \</a>
<a name="ln1368">          const ::google::protobuf::internal::ExtensionIdentifier&lt;                      \</a>
<a name="ln1369">              CLASSNAME, _proto_TypeTraits, _field_type,                      \</a>
<a name="ln1370">              _is_packed&gt;&amp; id) {                                              \</a>
<a name="ln1371">    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,       \</a>
<a name="ln1372">                                              _is_packed, &amp;_extensions_);     \</a>
<a name="ln1373">  }</a>
<a name="ln1374"> </a>
<a name="ln1375">}  // namespace internal</a>
<a name="ln1376">}  // namespace protobuf</a>
<a name="ln1377"> </a>
<a name="ln1378">}  // namespace google</a>
<a name="ln1379">#endif  // GOOGLE_PROTOBUF_EXTENSION_SET_H__</a>

</code></pre>
<div class="balloon" rel="93"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: type, is_repeated, is_packed, descriptor.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
