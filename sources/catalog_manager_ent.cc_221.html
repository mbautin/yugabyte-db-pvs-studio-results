
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>catalog_manager_ent.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Copyright (c) YugaByte, Inc.</a>
<a name="ln2">//</a>
<a name="ln3">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln4">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln5">//</a>
<a name="ln6">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln7">//</a>
<a name="ln8">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln9">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln10">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln11">// under the License.</a>
<a name="ln12"> </a>
<a name="ln13">#include &lt;set&gt;</a>
<a name="ln14">#include &lt;google/protobuf/util/message_differencer.h&gt;</a>
<a name="ln15"> </a>
<a name="ln16">#include &quot;yb/master/catalog_manager.h&quot;</a>
<a name="ln17">#include &quot;yb/master/catalog_manager-internal.h&quot;</a>
<a name="ln18">#include &quot;yb/master/catalog_entity_info.h&quot;</a>
<a name="ln19">#include &quot;yb/master/cdc_rpc_tasks.h&quot;</a>
<a name="ln20">#include &quot;yb/master/cluster_balance.h&quot;</a>
<a name="ln21"> </a>
<a name="ln22">#include &quot;yb/cdc/cdc_service.h&quot;</a>
<a name="ln23">#include &quot;yb/client/schema.h&quot;</a>
<a name="ln24">#include &quot;yb/client/session.h&quot;</a>
<a name="ln25">#include &quot;yb/client/table.h&quot;</a>
<a name="ln26">#include &quot;yb/client/table_handle.h&quot;</a>
<a name="ln27">#include &quot;yb/client/table_alterer.h&quot;</a>
<a name="ln28">#include &quot;yb/client/yb_op.h&quot;</a>
<a name="ln29">#include &quot;yb/common/common.pb.h&quot;</a>
<a name="ln30">#include &quot;yb/common/ql_name.h&quot;</a>
<a name="ln31">#include &quot;yb/common/wire_protocol.h&quot;</a>
<a name="ln32">#include &quot;yb/consensus/consensus.h&quot;</a>
<a name="ln33">#include &quot;yb/gutil/bind.h&quot;</a>
<a name="ln34">#include &quot;yb/gutil/strings/join.h&quot;</a>
<a name="ln35">#include &quot;yb/gutil/strings/substitute.h&quot;</a>
<a name="ln36">#include &quot;yb/master/master_defaults.h&quot;</a>
<a name="ln37">#include &quot;yb/master/master_util.h&quot;</a>
<a name="ln38">#include &quot;yb/master/sys_catalog.h&quot;</a>
<a name="ln39">#include &quot;yb/master/sys_catalog-internal.h&quot;</a>
<a name="ln40">#include &quot;yb/master/async_snapshot_tasks.h&quot;</a>
<a name="ln41">#include &quot;yb/master/async_rpc_tasks.h&quot;</a>
<a name="ln42">#include &quot;yb/master/encryption_manager.h&quot;</a>
<a name="ln43"> </a>
<a name="ln44">#include &quot;yb/rpc/messenger.h&quot;</a>
<a name="ln45"> </a>
<a name="ln46">#include &quot;yb/tablet/operations/snapshot_operation.h&quot;</a>
<a name="ln47"> </a>
<a name="ln48">#include &quot;yb/tserver/backup.proxy.h&quot;</a>
<a name="ln49">#include &quot;yb/tserver/service_util.h&quot;</a>
<a name="ln50"> </a>
<a name="ln51">#include &quot;yb/util/cast.h&quot;</a>
<a name="ln52">#include &quot;yb/util/flag_tags.h&quot;</a>
<a name="ln53">#include &quot;yb/util/scope_exit.h&quot;</a>
<a name="ln54">#include &quot;yb/util/service_util.h&quot;</a>
<a name="ln55">#include &quot;yb/util/status.h&quot;</a>
<a name="ln56">#include &quot;yb/util/tostring.h&quot;</a>
<a name="ln57">#include &quot;yb/util/string_util.h&quot;</a>
<a name="ln58">#include &quot;yb/util/random_util.h&quot;</a>
<a name="ln59">#include &quot;yb/cdc/cdc_consumer.pb.h&quot;</a>
<a name="ln60"> </a>
<a name="ln61">using namespace std::literals;</a>
<a name="ln62">using namespace std::placeholders;</a>
<a name="ln63"> </a>
<a name="ln64">using std::string;</a>
<a name="ln65">using std::unique_ptr;</a>
<a name="ln66">using std::vector;</a>
<a name="ln67"> </a>
<a name="ln68">using google::protobuf::RepeatedPtrField;</a>
<a name="ln69">using google::protobuf::util::MessageDifferencer;</a>
<a name="ln70">using strings::Substitute;</a>
<a name="ln71"> </a>
<a name="ln72">DEFINE_uint64(cdc_state_table_num_tablets, 0,</a>
<a name="ln73">    &quot;Number of tablets to use when creating the CDC state table.&quot;</a>
<a name="ln74">    &quot;0 to use the same default num tablets as for regular tables.&quot;);</a>
<a name="ln75"> </a>
<a name="ln76">DEFINE_int32(cdc_wal_retention_time_secs, 4 * 3600,</a>
<a name="ln77">             &quot;WAL retention time in seconds to be used for tables for which a CDC stream was &quot;</a>
<a name="ln78">             &quot;created.&quot;);</a>
<a name="ln79">DECLARE_int32(master_rpc_timeout_ms);</a>
<a name="ln80"> </a>
<a name="ln81">DEFINE_bool(enable_transaction_snapshots, true,</a>
<a name="ln82">            &quot;The flag enables usage of transaction aware snapshots.&quot;);</a>
<a name="ln83">TAG_FLAG(enable_transaction_snapshots, hidden);</a>
<a name="ln84">TAG_FLAG(enable_transaction_snapshots, advanced);</a>
<a name="ln85">TAG_FLAG(enable_transaction_snapshots, runtime);</a>
<a name="ln86"> </a>
<a name="ln87">namespace yb {</a>
<a name="ln88"> </a>
<a name="ln89">using rpc::RpcContext;</a>
<a name="ln90">using pb_util::ParseFromSlice;</a>
<a name="ln91"> </a>
<a name="ln92">namespace master {</a>
<a name="ln93">namespace enterprise {</a>
<a name="ln94"> </a>
<a name="ln95">////////////////////////////////////////////////////////////</a>
<a name="ln96">// Snapshot Loader</a>
<a name="ln97">////////////////////////////////////////////////////////////</a>
<a name="ln98"> </a>
<a name="ln99">class SnapshotLoader : public Visitor&lt;PersistentSnapshotInfo&gt; {</a>
<a name="ln100"> public:</a>
<a name="ln101">  explicit SnapshotLoader(CatalogManager* catalog_manager) : catalog_manager_(catalog_manager) {}</a>
<a name="ln102"> </a>
<a name="ln103">  CHECKED_STATUS Visit(const SnapshotId&amp; snapshot_id, const SysSnapshotEntryPB&amp; metadata) override {</a>
<a name="ln104">    if (TryFullyDecodeTxnSnapshotId(snapshot_id)) {</a>
<a name="ln105">      // Transaction aware snapshots should be already loaded.</a>
<a name="ln106">      return Status::OK();</a>
<a name="ln107">    }</a>
<a name="ln108">    return VisitNonTransactionAwareSnapshot(snapshot_id, metadata);</a>
<a name="ln109">  }</a>
<a name="ln110"> </a>
<a name="ln111">  CHECKED_STATUS VisitNonTransactionAwareSnapshot(</a>
<a name="ln112">      const SnapshotId&amp; snapshot_id, const SysSnapshotEntryPB&amp; metadata) {</a>
<a name="ln113"> </a>
<a name="ln114">    // Setup the snapshot info.</a>
<a name="ln115">    auto snapshot_info = make_scoped_refptr&lt;SnapshotInfo&gt;(snapshot_id);</a>
<a name="ln116">    auto l = snapshot_info-&gt;LockForWrite();</a>
<a name="ln117">    l-&gt;mutable_data()-&gt;pb.CopyFrom(metadata);</a>
<a name="ln118"> </a>
<a name="ln119">    // Add the snapshot to the IDs map (if the snapshot is not deleted).</a>
<a name="ln120">    auto emplace_result = catalog_manager_-&gt;non_txn_snapshot_ids_map_.emplace(</a>
<a name="ln121">        snapshot_id, std::move(snapshot_info));</a>
<a name="ln122">    CHECK(emplace_result.second) &lt;&lt; &quot;Snapshot already exists: &quot; &lt;&lt; snapshot_id;</a>
<a name="ln123"> </a>
<a name="ln124">    LOG(INFO) &lt;&lt; &quot;Loaded metadata for snapshot (id=&quot; &lt;&lt; snapshot_id &lt;&lt; &quot;): &quot;</a>
<a name="ln125">              &lt;&lt; emplace_result.first-&gt;second-&gt;ToString() &lt;&lt; &quot;: &quot; &lt;&lt; metadata.ShortDebugString();</a>
<a name="ln126">    l-&gt;Commit();</a>
<a name="ln127">    return Status::OK();</a>
<a name="ln128">  }</a>
<a name="ln129"> </a>
<a name="ln130"> private:</a>
<a name="ln131">  CatalogManager *catalog_manager_;</a>
<a name="ln132"> </a>
<a name="ln133">  DISALLOW_COPY_AND_ASSIGN(SnapshotLoader);</a>
<a name="ln134">};</a>
<a name="ln135"> </a>
<a name="ln136"> </a>
<a name="ln137">////////////////////////////////////////////////////////////</a>
<a name="ln138">// CDC Stream Loader</a>
<a name="ln139">////////////////////////////////////////////////////////////</a>
<a name="ln140"> </a>
<a name="ln141">class CDCStreamLoader : public Visitor&lt;PersistentCDCStreamInfo&gt; {</a>
<a name="ln142"> public:</a>
<a name="ln143">  explicit CDCStreamLoader(CatalogManager* catalog_manager) : catalog_manager_(catalog_manager) {}</a>
<a name="ln144"> </a>
<a name="ln145">  Status Visit(const CDCStreamId&amp; stream_id, const SysCDCStreamEntryPB&amp; metadata)</a>
<a name="ln146">      REQUIRES(catalog_manager_-&gt;lock_) {</a>
<a name="ln147">    DCHECK(!ContainsKey(catalog_manager_-&gt;cdc_stream_map_, stream_id))</a>
<a name="ln148">        &lt;&lt; &quot;CDC stream already exists: &quot; &lt;&lt; stream_id;</a>
<a name="ln149"> </a>
<a name="ln150">    scoped_refptr&lt;TableInfo&gt; table =</a>
<a name="ln151">        FindPtrOrNull(*catalog_manager_-&gt;table_ids_map_, metadata.table_id());</a>
<a name="ln152"> </a>
<a name="ln153">    if (!table) {</a>
<a name="ln154">      LOG(ERROR) &lt;&lt; &quot;Invalid table ID &quot; &lt;&lt; metadata.table_id() &lt;&lt; &quot; for stream &quot; &lt;&lt; stream_id;</a>
<a name="ln155">      // TODO (#2059): Potentially signals a race condition that table got deleted while stream was</a>
<a name="ln156">      // being created.</a>
<a name="ln157">      // Log error and continue without loading the stream.</a>
<a name="ln158">      return Status::OK();</a>
<a name="ln159">    }</a>
<a name="ln160"> </a>
<a name="ln161">    // Setup the CDC stream info.</a>
<a name="ln162">    auto stream = make_scoped_refptr&lt;CDCStreamInfo&gt;(stream_id);</a>
<a name="ln163">    auto l = stream-&gt;LockForWrite();</a>
<a name="ln164">    l-&gt;mutable_data()-&gt;pb.CopyFrom(metadata);</a>
<a name="ln165"> </a>
<a name="ln166">    // If the table has been deleted, then mark this stream as DELETING so it can be deleted by the</a>
<a name="ln167">    // catalog manager background thread.</a>
<a name="ln168">    if (table-&gt;LockForRead()-&gt;data().is_deleting() &amp;&amp; !l-&gt;data().is_deleting()) {</a>
<a name="ln169">      l-&gt;mutable_data()-&gt;pb.set_state(SysCDCStreamEntryPB::DELETING);</a>
<a name="ln170">    }</a>
<a name="ln171"> </a>
<a name="ln172">    // Add the CDC stream to the CDC stream map.</a>
<a name="ln173">    catalog_manager_-&gt;cdc_stream_map_[stream-&gt;id()] = stream;</a>
<a name="ln174"> </a>
<a name="ln175">    l-&gt;Commit();</a>
<a name="ln176"> </a>
<a name="ln177">    LOG(INFO) &lt;&lt; &quot;Loaded metadata for CDC stream &quot; &lt;&lt; stream-&gt;ToString() &lt;&lt; &quot;: &quot;</a>
<a name="ln178">              &lt;&lt; metadata.ShortDebugString();</a>
<a name="ln179"> </a>
<a name="ln180">    return Status::OK();</a>
<a name="ln181">  }</a>
<a name="ln182"> </a>
<a name="ln183"> private:</a>
<a name="ln184">  CatalogManager *catalog_manager_;</a>
<a name="ln185"> </a>
<a name="ln186">  DISALLOW_COPY_AND_ASSIGN(CDCStreamLoader);</a>
<a name="ln187">};</a>
<a name="ln188"> </a>
<a name="ln189">////////////////////////////////////////////////////////////</a>
<a name="ln190">// Universe Replication Loader</a>
<a name="ln191">////////////////////////////////////////////////////////////</a>
<a name="ln192"> </a>
<a name="ln193">class UniverseReplicationLoader : public Visitor&lt;PersistentUniverseReplicationInfo&gt; {</a>
<a name="ln194"> public:</a>
<a name="ln195">  explicit UniverseReplicationLoader(CatalogManager* catalog_manager)</a>
<a name="ln196">      : catalog_manager_(catalog_manager) {}</a>
<a name="ln197"> </a>
<a name="ln198">  Status Visit(const std::string&amp; producer_id, const SysUniverseReplicationEntryPB&amp; metadata) {</a>
<a name="ln199">    DCHECK(!ContainsKey(catalog_manager_-&gt;universe_replication_map_, producer_id))</a>
<a name="ln200">        &lt;&lt; &quot;Producer universe already exists: &quot; &lt;&lt; producer_id;</a>
<a name="ln201"> </a>
<a name="ln202">    // Setup the universe replication info.</a>
<a name="ln203">    UniverseReplicationInfo* const ri = new UniverseReplicationInfo(producer_id);</a>
<a name="ln204">    auto l = ri-&gt;LockForWrite();</a>
<a name="ln205">    l-&gt;mutable_data()-&gt;pb.CopyFrom(metadata);</a>
<a name="ln206"> </a>
<a name="ln207">    if (!l-&gt;data().is_active() &amp;&amp; !l-&gt;data().is_deleted_or_failed()) {</a>
<a name="ln208">      // Replication was not fully setup.</a>
<a name="ln209">      LOG(WARNING) &lt;&lt; &quot;Universe replication in transient state: &quot; &lt;&lt; producer_id;</a>
<a name="ln210"> </a>
<a name="ln211">      // TODO: Should we delete all failed universe replication items?</a>
<a name="ln212">    }</a>
<a name="ln213"> </a>
<a name="ln214">    // Add universe replication info to the universe replication map.</a>
<a name="ln215">    catalog_manager_-&gt;universe_replication_map_[ri-&gt;id()] = ri;</a>
<a name="ln216">    l-&gt;Commit();</a>
<a name="ln217"> </a>
<a name="ln218">    LOG(INFO) &lt;&lt; &quot;Loaded metadata for universe replication &quot; &lt;&lt; ri-&gt;ToString();</a>
<a name="ln219">    VLOG(1) &lt;&lt; &quot;Metadata for universe replication &quot; &lt;&lt; ri-&gt;ToString() &lt;&lt; &quot;: &quot;</a>
<a name="ln220">            &lt;&lt; metadata.ShortDebugString();</a>
<a name="ln221"> </a>
<a name="ln222">    return Status::OK();</a>
<a name="ln223">  }</a>
<a name="ln224"> </a>
<a name="ln225"> private:</a>
<a name="ln226">  CatalogManager *catalog_manager_;</a>
<a name="ln227"> </a>
<a name="ln228">  DISALLOW_COPY_AND_ASSIGN(UniverseReplicationLoader);</a>
<a name="ln229">};</a>
<a name="ln230"> </a>
<a name="ln231">////////////////////////////////////////////////////////////</a>
<a name="ln232">// CatalogManager</a>
<a name="ln233">////////////////////////////////////////////////////////////</a>
<a name="ln234"> </a>
<a name="ln235">CatalogManager::~CatalogManager() {</a>
<a name="ln236">  Shutdown();</a>
<a name="ln237">}</a>
<a name="ln238"> </a>
<a name="ln239">void CatalogManager::Shutdown() {</a>
<a name="ln240">  snapshot_coordinator_.Shutdown();</a>
<a name="ln241">  if (cdc_ybclient_) {</a>
<a name="ln242">    cdc_ybclient_-&gt;Shutdown();</a>
<a name="ln243">  }</a>
<a name="ln244">  // Call shutdown on base class before exiting derived class destructor</a>
<a name="ln245">  // because BgTasks is part of base &amp; uses this derived class on Shutdown.</a>
<a name="ln246">  super::Shutdown();</a>
<a name="ln247">}</a>
<a name="ln248"> </a>
<a name="ln249">Status CatalogManager::RunLoaders(int64_t term) {</a>
<a name="ln250">  RETURN_NOT_OK(super::RunLoaders(term));</a>
<a name="ln251"> </a>
<a name="ln252">  // Clear the snapshots.</a>
<a name="ln253">  non_txn_snapshot_ids_map_.clear();</a>
<a name="ln254"> </a>
<a name="ln255">  // Clear CDC stream map.</a>
<a name="ln256">  cdc_stream_map_.clear();</a>
<a name="ln257"> </a>
<a name="ln258">  // Clear universe replication map.</a>
<a name="ln259">  universe_replication_map_.clear();</a>
<a name="ln260"> </a>
<a name="ln261">  LOG(INFO) &lt;&lt; __func__ &lt;&lt; &quot;: Loading snapshots into memory.&quot;;</a>
<a name="ln262">  unique_ptr&lt;SnapshotLoader&gt; snapshot_loader(new SnapshotLoader(this));</a>
<a name="ln263">  RETURN_NOT_OK_PREPEND(</a>
<a name="ln264">      sys_catalog_-&gt;Visit(snapshot_loader.get()),</a>
<a name="ln265">      &quot;Failed while visiting snapshots in sys catalog&quot;);</a>
<a name="ln266"> </a>
<a name="ln267">  LOG(INFO) &lt;&lt; __func__ &lt;&lt; &quot;: Loading CDC streams into memory.&quot;;</a>
<a name="ln268">  auto cdc_stream_loader = std::make_unique&lt;CDCStreamLoader&gt;(this);</a>
<a name="ln269">  RETURN_NOT_OK_PREPEND(</a>
<a name="ln270">      sys_catalog_-&gt;Visit(cdc_stream_loader.get()),</a>
<a name="ln271">      &quot;Failed while visiting CDC streams in sys catalog&quot;);</a>
<a name="ln272"> </a>
<a name="ln273">  LOG(INFO) &lt;&lt; __func__ &lt;&lt; &quot;: Loading universe replication info into memory.&quot;;</a>
<a name="ln274">  auto universe_replication_loader = std::make_unique&lt;UniverseReplicationLoader&gt;(this);</a>
<a name="ln275">  RETURN_NOT_OK_PREPEND(</a>
<a name="ln276">      sys_catalog_-&gt;Visit(universe_replication_loader.get()),</a>
<a name="ln277">      &quot;Failed while visiting universe replication info in sys catalog&quot;);</a>
<a name="ln278"> </a>
<a name="ln279">  return Status::OK();</a>
<a name="ln280">}</a>
<a name="ln281"> </a>
<a name="ln282">Status CatalogManager::CreateSnapshot(const CreateSnapshotRequestPB* req,</a>
<a name="ln283">                                      CreateSnapshotResponsePB* resp,</a>
<a name="ln284">                                      RpcContext* rpc) {</a>
<a name="ln285">  LOG(INFO) &lt;&lt; &quot;Servicing CreateSnapshot request: &quot; &lt;&lt; req-&gt;ShortDebugString();</a>
<a name="ln286">  RETURN_NOT_OK(CheckOnline());</a>
<a name="ln287"> </a>
<a name="ln288">  if (FLAGS_enable_transaction_snapshots &amp;&amp; req-&gt;transaction_aware()) {</a>
<a name="ln289">    return CreateTransactionAwareSnapshot(*req, resp, rpc);</a>
<a name="ln290">  }</a>
<a name="ln291"> </a>
<a name="ln292">  return CreateNonTransactionAwareSnapshot(req, resp, rpc);</a>
<a name="ln293">}</a>
<a name="ln294"> </a>
<a name="ln295">Status CatalogManager::CreateNonTransactionAwareSnapshot(</a>
<a name="ln296">    const CreateSnapshotRequestPB* req,</a>
<a name="ln297">    CreateSnapshotResponsePB* resp,</a>
<a name="ln298">    RpcContext* rpc) {</a>
<a name="ln299">  SnapshotId snapshot_id;</a>
<a name="ln300">  {</a>
<a name="ln301">    std::lock_guard&lt;LockType&gt; l(lock_);</a>
<a name="ln302">    TRACE(&quot;Acquired catalog manager lock&quot;);</a>
<a name="ln303"> </a>
<a name="ln304">    // Verify that the system is not in snapshot creating/restoring state.</a>
<a name="ln305">    if (!current_snapshot_id_.empty()) {</a>
<a name="ln306">      return STATUS(IllegalState,</a>
<a name="ln307">                    Format(</a>
<a name="ln308">                        &quot;Current snapshot id: $0. Parallel snapshot operations are not supported&quot;</a>
<a name="ln309">                        &quot;: $1&quot;, current_snapshot_id_, req),</a>
<a name="ln310">                    MasterError(MasterErrorPB::PARALLEL_SNAPSHOT_OPERATION));</a>
<a name="ln311">    }</a>
<a name="ln312"> </a>
<a name="ln313">    // Create a new snapshot UUID.</a>
<a name="ln314">    snapshot_id = GenerateIdUnlocked(SysRowEntry::SNAPSHOT);</a>
<a name="ln315">  }</a>
<a name="ln316"> </a>
<a name="ln317">  vector&lt;scoped_refptr&lt;TabletInfo&gt;&gt; all_tablets;</a>
<a name="ln318"> </a>
<a name="ln319">  // Create in memory snapshot data descriptor.</a>
<a name="ln320">  scoped_refptr&lt;SnapshotInfo&gt; snapshot(new SnapshotInfo(snapshot_id));</a>
<a name="ln321">  snapshot-&gt;mutable_metadata()-&gt;StartMutation();</a>
<a name="ln322">  snapshot-&gt;mutable_metadata()-&gt;mutable_dirty()-&gt;pb.set_state(SysSnapshotEntryPB::CREATING);</a>
<a name="ln323"> </a>
<a name="ln324">  auto tables = VERIFY_RESULT(CollectTables(req-&gt;tables(), req-&gt;add_indexes()));</a>
<a name="ln325">  for (const auto&amp; table : tables) {</a>
<a name="ln326">    RETURN_NOT_OK(snapshot-&gt;AddEntries(table));</a>
<a name="ln327">    all_tablets.insert(all_tablets.end(), table.tablet_infos.begin(), table.tablet_infos.end());</a>
<a name="ln328">  }</a>
<a name="ln329"> </a>
<a name="ln330">  VLOG(1) &lt;&lt; &quot;Snapshot &quot; &lt;&lt; snapshot-&gt;ToString()</a>
<a name="ln331">          &lt;&lt; &quot;: PB=&quot; &lt;&lt; snapshot-&gt;mutable_metadata()-&gt;mutable_dirty()-&gt;pb.DebugString();</a>
<a name="ln332"> </a>
<a name="ln333">  // Write the snapshot data descriptor to the system catalog (in &quot;creating&quot; state).</a>
<a name="ln334">  RETURN_NOT_OK(CheckLeaderStatus(</a>
<a name="ln335">      sys_catalog_-&gt;AddItem(snapshot.get(), leader_ready_term()),</a>
<a name="ln336">      &quot;inserting snapshot into sys-catalog&quot;));</a>
<a name="ln337">  TRACE(&quot;Wrote snapshot to system catalog&quot;);</a>
<a name="ln338"> </a>
<a name="ln339">  // Commit in memory snapshot data descriptor.</a>
<a name="ln340">  snapshot-&gt;mutable_metadata()-&gt;CommitMutation();</a>
<a name="ln341"> </a>
<a name="ln342">  // Put the snapshot data descriptor to the catalog manager.</a>
<a name="ln343">  {</a>
<a name="ln344">    std::lock_guard&lt;LockType&gt; l(lock_);</a>
<a name="ln345">    TRACE(&quot;Acquired catalog manager lock&quot;);</a>
<a name="ln346"> </a>
<a name="ln347">    // Verify that the snapshot does not exist.</a>
<a name="ln348">    auto inserted = non_txn_snapshot_ids_map_.emplace(snapshot_id, snapshot).second;</a>
<a name="ln349">    DSCHECK(inserted, IllegalState, Format(&quot;Snapshot already exists: $0&quot;, snapshot_id));</a>
<a name="ln350">    current_snapshot_id_ = snapshot_id;</a>
<a name="ln351">  }</a>
<a name="ln352"> </a>
<a name="ln353">  // Send CreateSnapshot requests to all TServers (one tablet - one request).</a>
<a name="ln354">  for (const scoped_refptr&lt;TabletInfo&gt;&amp; tablet : all_tablets) {</a>
<a name="ln355">    TRACE(&quot;Locking tablet&quot;);</a>
<a name="ln356">    auto l = tablet-&gt;LockForRead();</a>
<a name="ln357"> </a>
<a name="ln358">    LOG(INFO) &lt;&lt; &quot;Sending CreateTabletSnapshot to tablet: &quot; &lt;&lt; tablet-&gt;ToString();</a>
<a name="ln359"> </a>
<a name="ln360">    // Send Create Tablet Snapshot request to each tablet leader.</a>
<a name="ln361">    SendCreateTabletSnapshotRequest(</a>
<a name="ln362">        tablet, snapshot_id, HybridTime::kInvalid, TabletSnapshotOperationCallback());</a>
<a name="ln363">  }</a>
<a name="ln364"> </a>
<a name="ln365">  resp-&gt;set_snapshot_id(snapshot_id);</a>
<a name="ln366">  LOG(INFO) &lt;&lt; &quot;Successfully started snapshot &quot; &lt;&lt; snapshot_id &lt;&lt; &quot; creation&quot;;</a>
<a name="ln367">  return Status::OK();</a>
<a name="ln368">}</a>
<a name="ln369"> </a>
<a name="ln370">void CatalogManager::Submit(std::unique_ptr&lt;tablet::Operation&gt; operation) {</a>
<a name="ln371">  operation-&gt;state()-&gt;SetTablet(tablet_peer()-&gt;tablet());</a>
<a name="ln372">  tablet_peer()-&gt;Submit(std::move(operation), leader_ready_term());</a>
<a name="ln373">}</a>
<a name="ln374"> </a>
<a name="ln375">Status CatalogManager::CreateTransactionAwareSnapshot(</a>
<a name="ln376">    const CreateSnapshotRequestPB&amp; req, CreateSnapshotResponsePB* resp, rpc::RpcContext* rpc) {</a>
<a name="ln377">  SysRowEntries entries;</a>
<a name="ln378">  auto tables = VERIFY_RESULT(CollectTables(req.tables(), req.add_indexes()));</a>
<a name="ln379">  for (const auto&amp; table : tables) {</a>
<a name="ln380">    // TODO(txn_snapshot) use single lock to resolve all tables to tablets</a>
<a name="ln381">    SnapshotInfo::AddEntries(table, entries.mutable_entries(), /* tablet_infos= */ nullptr);</a>
<a name="ln382">  }</a>
<a name="ln383"> </a>
<a name="ln384">  auto snapshot_id = VERIFY_RESULT(snapshot_coordinator_.Create(</a>
<a name="ln385">      entries, req.imported(), master_-&gt;clock()-&gt;MaxGlobalNow(), rpc-&gt;GetClientDeadline()));</a>
<a name="ln386">  resp-&gt;set_snapshot_id(snapshot_id.data(), snapshot_id.size());</a>
<a name="ln387">  return Status::OK();</a>
<a name="ln388">}</a>
<a name="ln389"> </a>
<a name="ln390">Status CatalogManager::ListSnapshots(const ListSnapshotsRequestPB* req,</a>
<a name="ln391">                                     ListSnapshotsResponsePB* resp) {</a>
<a name="ln392">  RETURN_NOT_OK(CheckOnline());</a>
<a name="ln393"> </a>
<a name="ln394">  auto txn_snapshot_id = TryFullyDecodeTxnSnapshotId(req-&gt;snapshot_id());</a>
<a name="ln395">  {</a>
<a name="ln396">    std::shared_lock&lt;LockType&gt; l(lock_);</a>
<a name="ln397">    TRACE(&quot;Acquired catalog manager lock&quot;);</a>
<a name="ln398"> </a>
<a name="ln399">    if (!current_snapshot_id_.empty()) {</a>
<a name="ln400">      resp-&gt;set_current_snapshot_id(current_snapshot_id_);</a>
<a name="ln401">    }</a>
<a name="ln402"> </a>
<a name="ln403">    auto setup_snapshot_pb_lambda = [resp](scoped_refptr&lt;SnapshotInfo&gt; snapshot_info) {</a>
<a name="ln404">      auto snapshot_lock = snapshot_info-&gt;LockForRead();</a>
<a name="ln405"> </a>
<a name="ln406">      SnapshotInfoPB* const snapshot = resp-&gt;add_snapshots();</a>
<a name="ln407">      snapshot-&gt;set_id(snapshot_info-&gt;id());</a>
<a name="ln408">      *snapshot-&gt;mutable_entry() = snapshot_info-&gt;metadata().state().pb;</a>
<a name="ln409">    };</a>
<a name="ln410"> </a>
<a name="ln411">    if (req-&gt;has_snapshot_id()) {</a>
<a name="ln412">      if (!txn_snapshot_id) {</a>
<a name="ln413">        TRACE(&quot;Looking up snapshot&quot;);</a>
<a name="ln414">        scoped_refptr&lt;SnapshotInfo&gt; snapshot_info =</a>
<a name="ln415">            FindPtrOrNull(non_txn_snapshot_ids_map_, req-&gt;snapshot_id());</a>
<a name="ln416">        if (snapshot_info == nullptr) {</a>
<a name="ln417">          return STATUS(InvalidArgument, &quot;Could not find snapshot&quot;, req-&gt;snapshot_id(),</a>
<a name="ln418">                        MasterError(MasterErrorPB::SNAPSHOT_NOT_FOUND));</a>
<a name="ln419">        }</a>
<a name="ln420"> </a>
<a name="ln421">        setup_snapshot_pb_lambda(snapshot_info);</a>
<a name="ln422">      }</a>
<a name="ln423">    } else {</a>
<a name="ln424">      for (const SnapshotInfoMap::value_type&amp; entry : non_txn_snapshot_ids_map_) {</a>
<a name="ln425">        setup_snapshot_pb_lambda(entry.second);</a>
<a name="ln426">      }</a>
<a name="ln427">    }</a>
<a name="ln428">  }</a>
<a name="ln429"> </a>
<a name="ln430">  return snapshot_coordinator_.ListSnapshots(</a>
<a name="ln431">      txn_snapshot_id, req-&gt;list_deleted_snapshots(), resp);</a>
<a name="ln432">}</a>
<a name="ln433"> </a>
<a name="ln434">Status CatalogManager::ListSnapshotRestorations(const ListSnapshotRestorationsRequestPB* req,</a>
<a name="ln435">                                                ListSnapshotRestorationsResponsePB* resp) {</a>
<a name="ln436">  RETURN_NOT_OK(CheckOnline());</a>
<a name="ln437"> </a>
<a name="ln438">  TxnSnapshotRestorationId restoration_id = TxnSnapshotRestorationId::Nil();</a>
<a name="ln439">  if (!req-&gt;restoration_id().empty()) {</a>
<a name="ln440">    restoration_id = VERIFY_RESULT(FullyDecodeTxnSnapshotRestorationId(req-&gt;restoration_id()));</a>
<a name="ln441">  }</a>
<a name="ln442">  TxnSnapshotId snapshot_id = TxnSnapshotId::Nil();</a>
<a name="ln443">  if (!req-&gt;snapshot_id().empty()) {</a>
<a name="ln444">    snapshot_id = VERIFY_RESULT(FullyDecodeTxnSnapshotId(req-&gt;snapshot_id()));</a>
<a name="ln445">  }</a>
<a name="ln446"> </a>
<a name="ln447">  return snapshot_coordinator_.ListRestorations(restoration_id, snapshot_id, resp);</a>
<a name="ln448">}</a>
<a name="ln449"> </a>
<a name="ln450">Status CatalogManager::RestoreSnapshot(const RestoreSnapshotRequestPB* req,</a>
<a name="ln451">                                       RestoreSnapshotResponsePB* resp) {</a>
<a name="ln452">  LOG(INFO) &lt;&lt; &quot;Servicing RestoreSnapshot request: &quot; &lt;&lt; req-&gt;ShortDebugString();</a>
<a name="ln453">  RETURN_NOT_OK(CheckOnline());</a>
<a name="ln454"> </a>
<a name="ln455">  auto txn_snapshot_id = TryFullyDecodeTxnSnapshotId(req-&gt;snapshot_id());</a>
<a name="ln456">  if (txn_snapshot_id) {</a>
<a name="ln457">    TxnSnapshotRestorationId id = VERIFY_RESULT(snapshot_coordinator_.Restore(txn_snapshot_id));</a>
<a name="ln458">    resp-&gt;set_restoration_id(id.data(), id.size());</a>
<a name="ln459">    return Status::OK();</a>
<a name="ln460">  }</a>
<a name="ln461"> </a>
<a name="ln462">  return RestoreNonTransactionAwareSnapshot(req-&gt;snapshot_id());</a>
<a name="ln463">}</a>
<a name="ln464"> </a>
<a name="ln465">Status CatalogManager::RestoreNonTransactionAwareSnapshot(const string&amp; snapshot_id) {</a>
<a name="ln466">  std::lock_guard&lt;LockType&gt; l(lock_);</a>
<a name="ln467">  TRACE(&quot;Acquired catalog manager lock&quot;);</a>
<a name="ln468"> </a>
<a name="ln469">  if (!current_snapshot_id_.empty()) {</a>
<a name="ln470">    return STATUS(</a>
<a name="ln471">        IllegalState,</a>
<a name="ln472">        Format(</a>
<a name="ln473">            &quot;Current snapshot id: $0. Parallel snapshot operations are not supported: $1&quot;,</a>
<a name="ln474">            current_snapshot_id_, snapshot_id),</a>
<a name="ln475">        MasterError(MasterErrorPB::PARALLEL_SNAPSHOT_OPERATION));</a>
<a name="ln476">  }</a>
<a name="ln477"> </a>
<a name="ln478">  TRACE(&quot;Looking up snapshot&quot;);</a>
<a name="ln479">  scoped_refptr&lt;SnapshotInfo&gt; snapshot = FindPtrOrNull(non_txn_snapshot_ids_map_, snapshot_id);</a>
<a name="ln480">  if (snapshot == nullptr) {</a>
<a name="ln481">    return STATUS(InvalidArgument, &quot;Could not find snapshot&quot;, snapshot_id,</a>
<a name="ln482">                  MasterError(MasterErrorPB::SNAPSHOT_NOT_FOUND));</a>
<a name="ln483">  }</a>
<a name="ln484"> </a>
<a name="ln485">  auto snapshot_lock = snapshot-&gt;LockForWrite();</a>
<a name="ln486"> </a>
<a name="ln487">  if (snapshot_lock-&gt;data().started_deleting()) {</a>
<a name="ln488">    return STATUS(NotFound, &quot;The snapshot was deleted&quot;, snapshot_id,</a>
<a name="ln489">                  MasterError(MasterErrorPB::SNAPSHOT_NOT_FOUND));</a>
<a name="ln490">  }</a>
<a name="ln491"> </a>
<a name="ln492">  if (!snapshot_lock-&gt;data().is_complete()) {</a>
<a name="ln493">    return STATUS(IllegalState, &quot;The snapshot state is not complete&quot;, snapshot_id,</a>
<a name="ln494">                  MasterError(MasterErrorPB::SNAPSHOT_IS_NOT_READY));</a>
<a name="ln495">  }</a>
<a name="ln496"> </a>
<a name="ln497">  TRACE(&quot;Updating snapshot metadata on disk&quot;);</a>
<a name="ln498">  SysSnapshotEntryPB&amp; snapshot_pb = snapshot_lock-&gt;mutable_data()-&gt;pb;</a>
<a name="ln499">  snapshot_pb.set_state(SysSnapshotEntryPB::RESTORING);</a>
<a name="ln500"> </a>
<a name="ln501">  // Update tablet states.</a>
<a name="ln502">  SetTabletSnapshotsState(SysSnapshotEntryPB::RESTORING, &amp;snapshot_pb);</a>
<a name="ln503"> </a>
<a name="ln504">  // Update sys-catalog with the updated snapshot state.</a>
<a name="ln505">  // The mutation will be aborted when 'l' exits the scope on early return.</a>
<a name="ln506">  RETURN_NOT_OK(CheckLeaderStatus(</a>
<a name="ln507">      sys_catalog_-&gt;UpdateItem(snapshot.get(), leader_ready_term()),</a>
<a name="ln508">      &quot;updating snapshot in sys-catalog&quot;));</a>
<a name="ln509"> </a>
<a name="ln510">  // CataloManager lock 'lock_' is still locked here.</a>
<a name="ln511">  current_snapshot_id_ = snapshot_id;</a>
<a name="ln512"> </a>
<a name="ln513">  // Restore all entries.</a>
<a name="ln514">  for (const SysRowEntry&amp; entry : snapshot_pb.entries()) {</a>
<a name="ln515">    RETURN_NOT_OK(RestoreEntry(entry, snapshot_id));</a>
<a name="ln516">  }</a>
<a name="ln517"> </a>
<a name="ln518">  // Commit in memory snapshot data descriptor.</a>
<a name="ln519">  TRACE(&quot;Committing in-memory snapshot state&quot;);</a>
<a name="ln520">  snapshot_lock-&gt;Commit();</a>
<a name="ln521"> </a>
<a name="ln522">  LOG(INFO) &lt;&lt; &quot;Successfully started snapshot &quot; &lt;&lt; snapshot-&gt;ToString() &lt;&lt; &quot; restoring&quot;;</a>
<a name="ln523">  return Status::OK();</a>
<a name="ln524">}</a>
<a name="ln525"> </a>
<a name="ln526">Status CatalogManager::RestoreEntry(const SysRowEntry&amp; entry, const SnapshotId&amp; snapshot_id) {</a>
<a name="ln527">  switch (entry.type()) {</a>
<a name="ln528">    case SysRowEntry::NAMESPACE: { // Restore NAMESPACES.</a>
<a name="ln529">      TRACE(&quot;Looking up namespace&quot;);</a>
<a name="ln530">      scoped_refptr&lt;NamespaceInfo&gt; ns = FindPtrOrNull(namespace_ids_map_, entry.id());</a>
<a name="ln531">      if (ns == nullptr) {</a>
<a name="ln532">        // Restore Namespace.</a>
<a name="ln533">        // TODO: implement</a>
<a name="ln534">        LOG(INFO) &lt;&lt; &quot;Restoring: NAMESPACE id = &quot; &lt;&lt; entry.id();</a>
<a name="ln535"> </a>
<a name="ln536">        return STATUS(NotSupported, Substitute(</a>
<a name="ln537">            &quot;Not implemented: restoring namespace: id=$0&quot;, entry.type()));</a>
<a name="ln538">      }</a>
<a name="ln539">      break;</a>
<a name="ln540">    }</a>
<a name="ln541">    case SysRowEntry::TABLE: { // Restore TABLES.</a>
<a name="ln542">      TRACE(&quot;Looking up table&quot;);</a>
<a name="ln543">      scoped_refptr&lt;TableInfo&gt; table = FindPtrOrNull(*table_ids_map_, entry.id());</a>
<a name="ln544">      if (table == nullptr) {</a>
<a name="ln545">        // Restore Table.</a>
<a name="ln546">        // TODO: implement</a>
<a name="ln547">        LOG(INFO) &lt;&lt; &quot;Restoring: TABLE id = &quot; &lt;&lt; entry.id();</a>
<a name="ln548"> </a>
<a name="ln549">        return STATUS(NotSupported, Substitute(</a>
<a name="ln550">            &quot;Not implemented: restoring table: id=$0&quot;, entry.type()));</a>
<a name="ln551">      }</a>
<a name="ln552">      break;</a>
<a name="ln553">    }</a>
<a name="ln554">    case SysRowEntry::TABLET: { // Restore TABLETS.</a>
<a name="ln555">      TRACE(&quot;Looking up tablet&quot;);</a>
<a name="ln556">      scoped_refptr&lt;TabletInfo&gt; tablet = FindPtrOrNull(*tablet_map_, entry.id());</a>
<a name="ln557">      if (tablet == nullptr) {</a>
<a name="ln558">        // Restore Tablet.</a>
<a name="ln559">        // TODO: implement</a>
<a name="ln560">        LOG(INFO) &lt;&lt; &quot;Restoring: TABLET id = &quot; &lt;&lt; entry.id();</a>
<a name="ln561"> </a>
<a name="ln562">        return STATUS(NotSupported, Substitute(</a>
<a name="ln563">            &quot;Not implemented: restoring tablet: id=$0&quot;, entry.type()));</a>
<a name="ln564">      } else {</a>
<a name="ln565">        TRACE(&quot;Locking tablet&quot;);</a>
<a name="ln566">        auto l = tablet-&gt;LockForRead();</a>
<a name="ln567"> </a>
<a name="ln568">        LOG(INFO) &lt;&lt; &quot;Sending RestoreTabletSnapshot to tablet: &quot; &lt;&lt; tablet-&gt;ToString();</a>
<a name="ln569">        // Send RestoreSnapshot requests to all TServers (one tablet - one request).</a>
<a name="ln570">        SendRestoreTabletSnapshotRequest(tablet, snapshot_id, TabletSnapshotOperationCallback());</a>
<a name="ln571">      }</a>
<a name="ln572">      break;</a>
<a name="ln573">    }</a>
<a name="ln574">    default:</a>
<a name="ln575">      return STATUS_FORMAT(</a>
<a name="ln576">          InternalError, &quot;Unexpected entry type in the snapshot: $0&quot;, entry.type());</a>
<a name="ln577">  }</a>
<a name="ln578"> </a>
<a name="ln579">  return Status::OK();</a>
<a name="ln580">}</a>
<a name="ln581"> </a>
<a name="ln582">Status CatalogManager::DeleteSnapshot(const DeleteSnapshotRequestPB* req,</a>
<a name="ln583">                                      DeleteSnapshotResponsePB* resp,</a>
<a name="ln584">                                      RpcContext* rpc) {</a>
<a name="ln585">  LOG(INFO) &lt;&lt; &quot;Servicing DeleteSnapshot request: &quot; &lt;&lt; req-&gt;ShortDebugString();</a>
<a name="ln586">  RETURN_NOT_OK(CheckOnline());</a>
<a name="ln587"> </a>
<a name="ln588">  auto txn_snapshot_id = TryFullyDecodeTxnSnapshotId(req-&gt;snapshot_id());</a>
<a name="ln589">  if (txn_snapshot_id) {</a>
<a name="ln590">    return snapshot_coordinator_.Delete(txn_snapshot_id, rpc-&gt;GetClientDeadline());</a>
<a name="ln591">  }</a>
<a name="ln592"> </a>
<a name="ln593">  return DeleteNonTransactionAwareSnapshot(req-&gt;snapshot_id());</a>
<a name="ln594">}</a>
<a name="ln595"> </a>
<a name="ln596">Status CatalogManager::DeleteNonTransactionAwareSnapshot(const SnapshotId&amp; snapshot_id) {</a>
<a name="ln597">  std::lock_guard&lt;LockType&gt; l(lock_);</a>
<a name="ln598">  TRACE(&quot;Acquired catalog manager lock&quot;);</a>
<a name="ln599"> </a>
<a name="ln600">  TRACE(&quot;Looking up snapshot&quot;);</a>
<a name="ln601">  scoped_refptr&lt;SnapshotInfo&gt; snapshot = FindPtrOrNull(</a>
<a name="ln602">      non_txn_snapshot_ids_map_, snapshot_id);</a>
<a name="ln603">  if (snapshot == nullptr) {</a>
<a name="ln604">    return STATUS(InvalidArgument, &quot;Could not find snapshot&quot;, snapshot_id,</a>
<a name="ln605">                  MasterError(MasterErrorPB::SNAPSHOT_NOT_FOUND));</a>
<a name="ln606">  }</a>
<a name="ln607"> </a>
<a name="ln608">  auto snapshot_lock = snapshot-&gt;LockForWrite();</a>
<a name="ln609"> </a>
<a name="ln610">  if (snapshot_lock-&gt;data().started_deleting()) {</a>
<a name="ln611">    return STATUS(NotFound, &quot;The snapshot was deleted&quot;, snapshot_id,</a>
<a name="ln612">                  MasterError(MasterErrorPB::SNAPSHOT_NOT_FOUND));</a>
<a name="ln613">  }</a>
<a name="ln614"> </a>
<a name="ln615">  if (snapshot_lock-&gt;data().is_restoring()) {</a>
<a name="ln616">    return STATUS(InvalidArgument, &quot;The snapshot is being restored now&quot;, snapshot_id,</a>
<a name="ln617">                  MasterError(MasterErrorPB::PARALLEL_SNAPSHOT_OPERATION));</a>
<a name="ln618">  }</a>
<a name="ln619"> </a>
<a name="ln620">  TRACE(&quot;Updating snapshot metadata on disk&quot;);</a>
<a name="ln621">  SysSnapshotEntryPB&amp; snapshot_pb = snapshot_lock-&gt;mutable_data()-&gt;pb;</a>
<a name="ln622">  snapshot_pb.set_state(SysSnapshotEntryPB::DELETING);</a>
<a name="ln623"> </a>
<a name="ln624">  // Update tablet states.</a>
<a name="ln625">  SetTabletSnapshotsState(SysSnapshotEntryPB::DELETING, &amp;snapshot_pb);</a>
<a name="ln626"> </a>
<a name="ln627">  // Update sys-catalog with the updated snapshot state.</a>
<a name="ln628">  // The mutation will be aborted when 'l' exits the scope on early return.</a>
<a name="ln629">  RETURN_NOT_OK(CheckStatus(</a>
<a name="ln630">      sys_catalog_-&gt;UpdateItem(snapshot.get(), leader_ready_term()),</a>
<a name="ln631">      &quot;updating snapshot in sys-catalog&quot;));</a>
<a name="ln632"> </a>
<a name="ln633">  // Send DeleteSnapshot requests to all TServers (one tablet - one request).</a>
<a name="ln634">  for (const SysRowEntry&amp; entry : snapshot_pb.entries()) {</a>
<a name="ln635">    if (entry.type() == SysRowEntry::TABLET) {</a>
<a name="ln636">      TRACE(&quot;Looking up tablet&quot;);</a>
<a name="ln637">      scoped_refptr&lt;TabletInfo&gt; tablet = FindPtrOrNull(*tablet_map_, entry.id());</a>
<a name="ln638">      if (tablet == nullptr) {</a>
<a name="ln639">        LOG(WARNING) &lt;&lt; &quot;Deleting tablet not found &quot; &lt;&lt; entry.id();</a>
<a name="ln640">      } else {</a>
<a name="ln641">        TRACE(&quot;Locking tablet&quot;);</a>
<a name="ln642">        auto l = tablet-&gt;LockForRead();</a>
<a name="ln643"> </a>
<a name="ln644">        LOG(INFO) &lt;&lt; &quot;Sending DeleteTabletSnapshot to tablet: &quot; &lt;&lt; tablet-&gt;ToString();</a>
<a name="ln645">        // Send DeleteSnapshot requests to all TServers (one tablet - one request).</a>
<a name="ln646">        SendDeleteTabletSnapshotRequest(tablet, snapshot_id, TabletSnapshotOperationCallback());</a>
<a name="ln647">      }</a>
<a name="ln648">    }</a>
<a name="ln649">  }</a>
<a name="ln650"> </a>
<a name="ln651">  // Commit in memory snapshot data descriptor.</a>
<a name="ln652">  TRACE(&quot;Committing in-memory snapshot state&quot;);</a>
<a name="ln653">  snapshot_lock-&gt;Commit();</a>
<a name="ln654"> </a>
<a name="ln655">  LOG(INFO) &lt;&lt; &quot;Successfully started snapshot &quot; &lt;&lt; snapshot-&gt;ToString() &lt;&lt; &quot; deletion&quot;;</a>
<a name="ln656">  return Status::OK();</a>
<a name="ln657">}</a>
<a name="ln658"> </a>
<a name="ln659">Status CatalogManager::ImportSnapshotPreprocess(const SysSnapshotEntryPB&amp; snapshot_pb,</a>
<a name="ln660">                                                ImportSnapshotMetaResponsePB* resp,</a>
<a name="ln661">                                                NamespaceMap* namespace_map,</a>
<a name="ln662">                                                ExternalTableSnapshotDataMap* tables_data) {</a>
<a name="ln663">  for (const SysRowEntry&amp; entry : snapshot_pb.entries()) {</a>
<a name="ln664">    switch (entry.type()) {</a>
<a name="ln665">      case SysRowEntry::NAMESPACE: // Recreate NAMESPACE.</a>
<a name="ln666">        RETURN_NOT_OK(ImportNamespaceEntry(entry, namespace_map));</a>
<a name="ln667">        break;</a>
<a name="ln668">      case SysRowEntry::TABLE: { // Create TABLE metadata.</a>
<a name="ln669">          LOG_IF(DFATAL, entry.id().empty()) &lt;&lt; &quot;Empty entry id&quot;;</a>
<a name="ln670">          ExternalTableSnapshotData&amp; data = (*tables_data)[entry.id()];</a>
<a name="ln671"> </a>
<a name="ln672">          if (data.old_table_id.empty()) {</a>
<a name="ln673">            data.old_table_id = entry.id();</a>
<a name="ln674">            data.table_meta = resp-&gt;mutable_tables_meta()-&gt;Add();</a>
<a name="ln675">            data.tablet_id_map = data.table_meta-&gt;mutable_tablets_ids();</a>
<a name="ln676">            data.table_entry_pb = VERIFY_RESULT(ParseFromSlice&lt;SysTablesEntryPB&gt;(entry.data()));</a>
<a name="ln677">          } else {</a>
<a name="ln678">            LOG(WARNING) &lt;&lt; &quot;Ignoring duplicate table with id &quot; &lt;&lt; entry.id();</a>
<a name="ln679">          }</a>
<a name="ln680"> </a>
<a name="ln681">          LOG_IF(DFATAL, data.old_table_id.empty()) &lt;&lt; &quot;Not initialized table id&quot;;</a>
<a name="ln682">        }</a>
<a name="ln683">        break;</a>
<a name="ln684">      case SysRowEntry::TABLET: // Preprocess original tablets.</a>
<a name="ln685">        RETURN_NOT_OK(PreprocessTabletEntry(entry, tables_data));</a>
<a name="ln686">        break;</a>
<a name="ln687">      case SysRowEntry::UNKNOWN: FALLTHROUGH_INTENDED;</a>
<a name="ln688">      case SysRowEntry::CLUSTER_CONFIG: FALLTHROUGH_INTENDED;</a>
<a name="ln689">      case SysRowEntry::REDIS_CONFIG: FALLTHROUGH_INTENDED;</a>
<a name="ln690">      case SysRowEntry::UDTYPE: FALLTHROUGH_INTENDED;</a>
<a name="ln691">      case SysRowEntry::ROLE: FALLTHROUGH_INTENDED;</a>
<a name="ln692">      case SysRowEntry::SYS_CONFIG: FALLTHROUGH_INTENDED;</a>
<a name="ln693">      case SysRowEntry::CDC_STREAM: FALLTHROUGH_INTENDED;</a>
<a name="ln694">      case SysRowEntry::UNIVERSE_REPLICATION: FALLTHROUGH_INTENDED;</a>
<a name="ln695">      case SysRowEntry::SNAPSHOT:</a>
<a name="ln696">        FATAL_INVALID_ENUM_VALUE(SysRowEntry::Type, entry.type());</a>
<a name="ln697">    }</a>
<a name="ln698">  }</a>
<a name="ln699"> </a>
<a name="ln700">  return Status::OK();</a>
<a name="ln701">}</a>
<a name="ln702"> </a>
<a name="ln703">Status CatalogManager::ImportSnapshotCreateObject(const SysSnapshotEntryPB&amp; snapshot_pb,</a>
<a name="ln704">                                                  ImportSnapshotMetaResponsePB* resp,</a>
<a name="ln705">                                                  NamespaceMap* namespace_map,</a>
<a name="ln706">                                                  ExternalTableSnapshotDataMap* tables_data,</a>
<a name="ln707">                                                  CreateObjects create_objects) {</a>
<a name="ln708">  // Create ONLY TABLES or ONLY INDEXES in accordance to the argument.</a>
<a name="ln709">  for (const SysRowEntry&amp; entry : snapshot_pb.entries()) {</a>
<a name="ln710">    if (entry.type() == SysRowEntry::TABLE) {</a>
<a name="ln711">      ExternalTableSnapshotData&amp; data = (*tables_data)[entry.id()];</a>
<a name="ln712">      if ((create_objects == CreateObjects::kOnlyIndexes) == data.is_index()) {</a>
<a name="ln713">        RETURN_NOT_OK(ImportTableEntry(*namespace_map, *tables_data, &amp;data));</a>
<a name="ln714">      }</a>
<a name="ln715">    }</a>
<a name="ln716">  }</a>
<a name="ln717"> </a>
<a name="ln718">  return Status::OK();</a>
<a name="ln719">}</a>
<a name="ln720"> </a>
<a name="ln721">Status CatalogManager::ImportSnapshotWaitForTables(const SysSnapshotEntryPB&amp; snapshot_pb,</a>
<a name="ln722">                                                   ImportSnapshotMetaResponsePB* resp,</a>
<a name="ln723">                                                   ExternalTableSnapshotDataMap* tables_data) {</a>
<a name="ln724">  for (const SysRowEntry&amp; entry : snapshot_pb.entries()) {</a>
<a name="ln725">    if (entry.type() == SysRowEntry::TABLE) {</a>
<a name="ln726">      ExternalTableSnapshotData&amp; data = (*tables_data)[entry.id()];</a>
<a name="ln727">      if (!data.is_index()) {</a>
<a name="ln728">        RETURN_NOT_OK(WaitForCreateTableToFinish(data.new_table_id));</a>
<a name="ln729">      }</a>
<a name="ln730">    }</a>
<a name="ln731">  }</a>
<a name="ln732"> </a>
<a name="ln733">  return Status::OK();</a>
<a name="ln734">}</a>
<a name="ln735"> </a>
<a name="ln736">Status CatalogManager::ImportSnapshotProcessTablets(const SysSnapshotEntryPB&amp; snapshot_pb,</a>
<a name="ln737">                                                    ImportSnapshotMetaResponsePB* resp,</a>
<a name="ln738">                                                    ExternalTableSnapshotDataMap* tables_data) {</a>
<a name="ln739">  for (const SysRowEntry&amp; entry : snapshot_pb.entries()) {</a>
<a name="ln740">    if (entry.type() == SysRowEntry::TABLET) {</a>
<a name="ln741">      // Create tablets IDs map.</a>
<a name="ln742">      RETURN_NOT_OK(ImportTabletEntry(entry, tables_data));</a>
<a name="ln743">    }</a>
<a name="ln744">  }</a>
<a name="ln745"> </a>
<a name="ln746">  return Status::OK();</a>
<a name="ln747">}</a>
<a name="ln748"> </a>
<a name="ln749">template &lt;class RespClass&gt;</a>
<a name="ln750">void ProcessDeleteObjectStatus(const string&amp; obj_name,</a>
<a name="ln751">                               const string&amp; id,</a>
<a name="ln752">                               const RespClass&amp; resp,</a>
<a name="ln753">                               const Status&amp; s) {</a>
<a name="ln754">  Status result = s;</a>
<a name="ln755">  if (result.ok() &amp;&amp; resp.has_error()) {</a>
<a name="ln756">    result = StatusFromPB(resp.error().status());</a>
<a name="ln757">    LOG_IF(DFATAL, result.ok()) &lt;&lt; &quot;Expecting error status&quot;;</a>
<a name="ln758">  }</a>
<a name="ln759"> </a>
<a name="ln760">  if (!result.ok()) {</a>
<a name="ln761">    LOG(WARNING) &lt;&lt; &quot;Failed to delete new &quot; &lt;&lt; obj_name &lt;&lt; &quot; with id=&quot; &lt;&lt; id &lt;&lt; &quot;: &quot; &lt;&lt; result;</a>
<a name="ln762">  }</a>
<a name="ln763">}</a>
<a name="ln764"> </a>
<a name="ln765">void CatalogManager::DeleteNewSnapshotObjects(const NamespaceMap&amp; namespace_map,</a>
<a name="ln766">                                              const ExternalTableSnapshotDataMap&amp; tables_data) {</a>
<a name="ln767">  for (const ExternalTableSnapshotDataMap::value_type&amp; entry : tables_data) {</a>
<a name="ln768">    const TableId&amp; old_id = entry.first;</a>
<a name="ln769">    const TableId&amp; new_id = entry.second.new_table_id;</a>
<a name="ln770">    const TableType type = entry.second.table_entry_pb.table_type();</a>
<a name="ln771"> </a>
<a name="ln772">    // Do not delete YSQL objects - it must be deleted via PG API.</a>
<a name="ln773">    if (new_id.empty() || new_id == old_id || type == TableType::PGSQL_TABLE_TYPE) {</a>
<a name="ln774">      continue;</a>
<a name="ln775">    }</a>
<a name="ln776"> </a>
<a name="ln777">    LOG(INFO) &lt;&lt; &quot;Deleting new table with id=&quot; &lt;&lt; new_id &lt;&lt; &quot; old id=&quot; &lt;&lt; old_id;</a>
<a name="ln778">    DeleteTableRequestPB req;</a>
<a name="ln779">    DeleteTableResponsePB resp;</a>
<a name="ln780">    req.mutable_table()-&gt;set_table_id(new_id);</a>
<a name="ln781">    req.set_is_index_table(entry.second.is_index());</a>
<a name="ln782">    ProcessDeleteObjectStatus(&quot;table&quot;, new_id, resp, DeleteTable(&amp;req, &amp;resp, nullptr));</a>
<a name="ln783">  }</a>
<a name="ln784"> </a>
<a name="ln785">  for (const NamespaceMap::value_type&amp; entry : namespace_map) {</a>
<a name="ln786">    const NamespaceId&amp; old_id = entry.first;</a>
<a name="ln787">    const NamespaceId&amp; new_id = entry.second.first;</a>
<a name="ln788">    const YQLDatabase&amp; db_type = entry.second.second;</a>
<a name="ln789"> </a>
<a name="ln790">    // Do not delete YSQL objects - it must be deleted via PG API.</a>
<a name="ln791">    if (new_id.empty() || new_id == old_id || db_type == YQL_DATABASE_PGSQL) {</a>
<a name="ln792">      continue;</a>
<a name="ln793">    }</a>
<a name="ln794"> </a>
<a name="ln795">    LOG(INFO) &lt;&lt; &quot;Deleting new namespace with id=&quot; &lt;&lt; new_id &lt;&lt; &quot; old id=&quot; &lt;&lt; old_id;</a>
<a name="ln796">    DeleteNamespaceRequestPB req;</a>
<a name="ln797">    DeleteNamespaceResponsePB resp;</a>
<a name="ln798">    req.mutable_namespace_()-&gt;set_id(new_id);</a>
<a name="ln799">    ProcessDeleteObjectStatus(</a>
<a name="ln800">        &quot;namespace&quot;, new_id, resp, DeleteNamespace(&amp;req, &amp;resp, nullptr));</a>
<a name="ln801">  }</a>
<a name="ln802">}</a>
<a name="ln803"> </a>
<a name="ln804">Status CatalogManager::ImportSnapshotMeta(const ImportSnapshotMetaRequestPB* req,</a>
<a name="ln805">                                          ImportSnapshotMetaResponsePB* resp) {</a>
<a name="ln806">  LOG(INFO) &lt;&lt; &quot;Servicing ImportSnapshotMeta request: &quot; &lt;&lt; req-&gt;ShortDebugString();</a>
<a name="ln807">  RETURN_NOT_OK(CheckOnline());</a>
<a name="ln808"> </a>
<a name="ln809">  NamespaceMap namespace_map;</a>
<a name="ln810">  ExternalTableSnapshotDataMap tables_data;</a>
<a name="ln811">  bool successful_exit = false;</a>
<a name="ln812"> </a>
<a name="ln813">  auto se = ScopeExit([this, &amp;namespace_map, &amp;tables_data, &amp;successful_exit] {</a>
<a name="ln814">    if (!successful_exit) {</a>
<a name="ln815">      DeleteNewSnapshotObjects(namespace_map, tables_data);</a>
<a name="ln816">    }</a>
<a name="ln817">  });</a>
<a name="ln818"> </a>
<a name="ln819">  const SysSnapshotEntryPB&amp; snapshot_pb = req-&gt;snapshot().entry();</a>
<a name="ln820"> </a>
<a name="ln821">  // PHASE 1: Recreate namespaces, create table's meta data.</a>
<a name="ln822">  RETURN_NOT_OK(ImportSnapshotPreprocess(snapshot_pb, resp, &amp;namespace_map, &amp;tables_data));</a>
<a name="ln823"> </a>
<a name="ln824">  // PHASE 2: Recreate ONLY tables.</a>
<a name="ln825">  RETURN_NOT_OK(ImportSnapshotCreateObject(</a>
<a name="ln826">      snapshot_pb, resp, &amp;namespace_map, &amp;tables_data, CreateObjects::kOnlyTables));</a>
<a name="ln827"> </a>
<a name="ln828">  // PHASE 3: Wait for all tables creation complete.</a>
<a name="ln829">  RETURN_NOT_OK(ImportSnapshotWaitForTables(snapshot_pb, resp, &amp;tables_data));</a>
<a name="ln830"> </a>
<a name="ln831">  // PHASE 4: Recreate ONLY indexes.</a>
<a name="ln832">  RETURN_NOT_OK(ImportSnapshotCreateObject(</a>
<a name="ln833">      snapshot_pb, resp, &amp;namespace_map, &amp;tables_data, CreateObjects::kOnlyIndexes));</a>
<a name="ln834"> </a>
<a name="ln835">  // PHASE 5: Restore tablets.</a>
<a name="ln836">  RETURN_NOT_OK(ImportSnapshotProcessTablets(snapshot_pb, resp, &amp;tables_data));</a>
<a name="ln837"> </a>
<a name="ln838">  successful_exit = true;</a>
<a name="ln839">  return Status::OK();</a>
<a name="ln840">}</a>
<a name="ln841"> </a>
<a name="ln842">Status CatalogManager::ChangeEncryptionInfo(const ChangeEncryptionInfoRequestPB* req,</a>
<a name="ln843">                                            ChangeEncryptionInfoResponsePB* resp) {</a>
<a name="ln844">  auto l = cluster_config_-&gt;LockForWrite();</a>
<a name="ln845">  auto encryption_info = l-&gt;mutable_data()-&gt;pb.mutable_encryption_info();</a>
<a name="ln846"> </a>
<a name="ln847">  RETURN_NOT_OK(encryption_manager_-&gt;ChangeEncryptionInfo(req, encryption_info));</a>
<a name="ln848"> </a>
<a name="ln849">  l-&gt;mutable_data()-&gt;pb.set_version(l-&gt;mutable_data()-&gt;pb.version() + 1);</a>
<a name="ln850">  RETURN_NOT_OK(CheckStatus(</a>
<a name="ln851">      sys_catalog_-&gt;UpdateItem(cluster_config_.get(), leader_ready_term()),</a>
<a name="ln852">      &quot;updating cluster config in sys-catalog&quot;));</a>
<a name="ln853">  l-&gt;Commit();</a>
<a name="ln854"> </a>
<a name="ln855">  std::lock_guard&lt;simple_spinlock&gt; lock(should_send_universe_key_registry_mutex_);</a>
<a name="ln856">  for (auto&amp; entry : should_send_universe_key_registry_) {</a>
<a name="ln857">    entry.second = true;</a>
<a name="ln858">  }</a>
<a name="ln859"> </a>
<a name="ln860">  return Status::OK();</a>
<a name="ln861">}</a>
<a name="ln862"> </a>
<a name="ln863">Status CatalogManager::IsEncryptionEnabled(const IsEncryptionEnabledRequestPB* req,</a>
<a name="ln864">                                           IsEncryptionEnabledResponsePB* resp) {</a>
<a name="ln865">  auto l = cluster_config_-&gt;LockForRead();</a>
<a name="ln866">  const auto&amp; encryption_info = l-&gt;data().pb.encryption_info();</a>
<a name="ln867">  return encryption_manager_-&gt;IsEncryptionEnabled(encryption_info, resp);</a>
<a name="ln868">}</a>
<a name="ln869"> </a>
<a name="ln870">Status CatalogManager::ImportNamespaceEntry(const SysRowEntry&amp; entry,</a>
<a name="ln871">                                            NamespaceMap* namespace_map) {</a>
<a name="ln872">  LOG_IF(DFATAL, entry.type() != SysRowEntry::NAMESPACE)</a>
<a name="ln873">      &lt;&lt; &quot;Unexpected entry type: &quot; &lt;&lt; entry.type();</a>
<a name="ln874"> </a>
<a name="ln875">  SysNamespaceEntryPB meta = VERIFY_RESULT(ParseFromSlice&lt;SysNamespaceEntryPB&gt;(entry.data()));</a>
<a name="ln876">  const YQLDatabase db_type = GetDatabaseType(meta);</a>
<a name="ln877">  NamespaceData&amp; ns_data = (*namespace_map)[entry.id()];</a>
<a name="ln878">  ns_data.second = db_type;</a>
<a name="ln879"> </a>
<a name="ln880">  TRACE(&quot;Looking up namespace&quot;);</a>
<a name="ln881">  scoped_refptr&lt;NamespaceInfo&gt; ns;</a>
<a name="ln882">  {</a>
<a name="ln883">    SharedLock&lt;LockType&gt; l(lock_);</a>
<a name="ln884">    ns = FindPtrOrNull(namespace_ids_map_, entry.id());</a>
<a name="ln885">  }</a>
<a name="ln886"> </a>
<a name="ln887">  if (ns != nullptr &amp;&amp; ns-&gt;name() == meta.name()) {</a>
<a name="ln888">    ns_data.first = entry.id();</a>
<a name="ln889">    return Status::OK();</a>
<a name="ln890">  }</a>
<a name="ln891"> </a>
<a name="ln892">  if (db_type == YQL_DATABASE_PGSQL) {</a>
<a name="ln893">    // YSQL database must be created via external call. Find it by name.</a>
<a name="ln894">    {</a>
<a name="ln895">      SharedLock&lt;LockType&gt; l(lock_);</a>
<a name="ln896">      ns = FindPtrOrNull(namespace_names_mapper_[db_type], meta.name());</a>
<a name="ln897">    }</a>
<a name="ln898"> </a>
<a name="ln899">    if (ns == nullptr) {</a>
<a name="ln900">      return STATUS(InvalidArgument, &quot;YSQL database must exist&quot;, meta.name(),</a>
<a name="ln901">                    MasterError(MasterErrorPB::NAMESPACE_NOT_FOUND));</a>
<a name="ln902">    }</a>
<a name="ln903"> </a>
<a name="ln904">    auto ns_lock = ns-&gt;LockForRead();</a>
<a name="ln905">    ns_data.first = ns-&gt;id();</a>
<a name="ln906">  } else {</a>
<a name="ln907">    CreateNamespaceRequestPB req;</a>
<a name="ln908">    CreateNamespaceResponsePB resp;</a>
<a name="ln909">    req.set_name(meta.name());</a>
<a name="ln910">    const Status s = CreateNamespace(&amp;req, &amp;resp, nullptr);</a>
<a name="ln911"> </a>
<a name="ln912">    if (!s.ok() &amp;&amp; !s.IsAlreadyPresent()) {</a>
<a name="ln913">      return s.CloneAndAppend(&quot;Failed to create namespace&quot;);</a>
<a name="ln914">    }</a>
<a name="ln915"> </a>
<a name="ln916">    if (s.IsAlreadyPresent()) {</a>
<a name="ln917">      LOG(INFO) &lt;&lt; &quot;Using existing namespace &quot; &lt;&lt; meta.name() &lt;&lt; &quot;: &quot; &lt;&lt; resp.id();</a>
<a name="ln918">    }</a>
<a name="ln919"> </a>
<a name="ln920">    ns_data.first = resp.id();</a>
<a name="ln921">  }</a>
<a name="ln922">  return Status::OK();</a>
<a name="ln923">}</a>
<a name="ln924"> </a>
<a name="ln925">Status CatalogManager::RecreateTable(const NamespaceId&amp; new_namespace_id,</a>
<a name="ln926">                                     const ExternalTableSnapshotDataMap&amp; table_map,</a>
<a name="ln927">                                     ExternalTableSnapshotData* table_data) {</a>
<a name="ln928">  const SysTablesEntryPB&amp; meta = DCHECK_NOTNULL(table_data)-&gt;table_entry_pb;</a>
<a name="ln929"> </a>
<a name="ln930">  CreateTableRequestPB req;</a>
<a name="ln931">  CreateTableResponsePB resp;</a>
<a name="ln932">  req.set_name(meta.name());</a>
<a name="ln933">  req.set_table_type(meta.table_type());</a>
<a name="ln934">  req.set_num_tablets(table_data-&gt;num_tablets);</a>
<a name="ln935">  req.mutable_namespace_()-&gt;set_id(new_namespace_id);</a>
<a name="ln936">  *req.mutable_partition_schema() = meta.partition_schema();</a>
<a name="ln937">  *req.mutable_replication_info() = meta.replication_info();</a>
<a name="ln938"> </a>
<a name="ln939">  // Clear column IDs.</a>
<a name="ln940">  SchemaPB* const schema = req.mutable_schema();</a>
<a name="ln941">  schema-&gt;mutable_table_properties()-&gt;set_num_tablets(table_data-&gt;num_tablets);</a>
<a name="ln942">  *schema = meta.schema();</a>
<a name="ln943">  for (int i = 0; i &lt; schema-&gt;columns_size(); ++i) {</a>
<a name="ln944">    DCHECK_NOTNULL(schema-&gt;mutable_columns(i))-&gt;clear_id();</a>
<a name="ln945">  }</a>
<a name="ln946"> </a>
<a name="ln947">  // Setup Index info.</a>
<a name="ln948">  if (table_data-&gt;is_index()) {</a>
<a name="ln949">    TRACE(&quot;Looking up indexed table&quot;);</a>
<a name="ln950">    // First of all try to attach to the new copy of the referenced table,</a>
<a name="ln951">    // because the table restored from the snapshot is preferred.</a>
<a name="ln952">    // For that try to map old indexed table ID into new table ID.</a>
<a name="ln953">    ExternalTableSnapshotDataMap::const_iterator it = table_map.find(meta.indexed_table_id());</a>
<a name="ln954"> </a>
<a name="ln955">    if (it != table_map.end()) {</a>
<a name="ln956">      LOG(INFO) &lt;&lt; &quot;Found new table ID &quot; &lt;&lt; it-&gt;second.new_table_id &lt;&lt; &quot; for old table ID &quot;</a>
<a name="ln957">                &lt;&lt; meta.indexed_table_id() &lt;&lt; &quot; from the snapshot.&quot;;</a>
<a name="ln958">      req.set_indexed_table_id(it-&gt;second.new_table_id);</a>
<a name="ln959">    } else {</a>
<a name="ln960">      LOG(INFO) &lt;&lt; &quot;Try to use old indexed table ID &quot; &lt;&lt; meta.indexed_table_id();</a>
<a name="ln961">      req.set_indexed_table_id(meta.indexed_table_id());</a>
<a name="ln962">    }</a>
<a name="ln963"> </a>
<a name="ln964">    scoped_refptr&lt;TableInfo&gt; indexed_table;</a>
<a name="ln965">    {</a>
<a name="ln966">      SharedLock&lt;LockType&gt; l(lock_);</a>
<a name="ln967">      // Try to find the specified indexed table by id.</a>
<a name="ln968">      indexed_table = FindPtrOrNull(*table_ids_map_, req.indexed_table_id());</a>
<a name="ln969">    }</a>
<a name="ln970"> </a>
<a name="ln971">    if (indexed_table == nullptr) {</a>
<a name="ln972">      return STATUS(</a>
<a name="ln973">          InvalidArgument, Format(&quot;Indexed table not found by id: $0&quot;, req.indexed_table_id()),</a>
<a name="ln974">          MasterError(MasterErrorPB::OBJECT_NOT_FOUND));</a>
<a name="ln975">    }</a>
<a name="ln976"> </a>
<a name="ln977">    LOG(INFO) &lt;&lt; &quot;Found indexed table by ID &quot; &lt;&lt; req.indexed_table_id();</a>
<a name="ln978">    Schema indexed_schema;</a>
<a name="ln979">    RETURN_NOT_OK(indexed_table-&gt;GetSchema(&amp;indexed_schema));</a>
<a name="ln980"> </a>
<a name="ln981">    req.set_is_local_index(meta.is_local_index());</a>
<a name="ln982">    req.set_is_unique_index(meta.is_unique_index());</a>
<a name="ln983">    req.set_skip_index_backfill(true);</a>
<a name="ln984">    // Setup IndexInfoPB - self descriptor.</a>
<a name="ln985">    IndexInfoPB* const index_info_pb = req.mutable_index_info();</a>
<a name="ln986">    *index_info_pb = meta.index_info();</a>
<a name="ln987">    index_info_pb-&gt;clear_table_id();</a>
<a name="ln988">    index_info_pb-&gt;set_indexed_table_id(req.indexed_table_id());</a>
<a name="ln989">    map&lt;ColumnIdRep, ColumnIdRep&gt; col_ids_map; // Old column id -&gt; new column id.</a>
<a name="ln990"> </a>
<a name="ln991">    // Column ids can be changed during the indexed table recreation.</a>
<a name="ln992">    // Update the Column ids from the recreated indexed table schema.</a>
<a name="ln993">    for (int i = 0; i &lt; index_info_pb-&gt;columns_size(); ++i) {</a>
<a name="ln994">      IndexInfoPB_IndexColumnPB* const column = index_info_pb-&gt;mutable_columns(i);</a>
<a name="ln995">      column-&gt;clear_column_id();</a>
<a name="ln996"> </a>
<a name="ln997">      if (column-&gt;has_column_name()) {</a>
<a name="ln998">        const string name = column-&gt;column_name();</a>
<a name="ln999">        const ColumnId new_id = VERIFY_RESULT(indexed_schema.ColumnIdByName(</a>
<a name="ln1000">           index_info_pb-&gt;use_mangled_column_name() ? YcqlName::DemangleName(name) : name));</a>
<a name="ln1001">        col_ids_map[column-&gt;indexed_column_id()] = new_id.rep();</a>
<a name="ln1002">        column-&gt;set_indexed_column_id(new_id.rep());</a>
<a name="ln1003">      } else { // No name, keep the column ID as it is.</a>
<a name="ln1004">        col_ids_map[column-&gt;indexed_column_id()] = column-&gt;indexed_column_id();</a>
<a name="ln1005">      }</a>
<a name="ln1006">    }</a>
<a name="ln1007"> </a>
<a name="ln1008">    // Update column expressions.</a>
<a name="ln1009">    for (int i = 0; i &lt; index_info_pb-&gt;columns_size(); ++i) {</a>
<a name="ln1010">      IndexInfoPB_IndexColumnPB* const column = index_info_pb-&gt;mutable_columns(i);</a>
<a name="ln1011">      if (column-&gt;has_colexpr()) {</a>
<a name="ln1012">        QLExpressionPB* const colexpr = column-&gt;mutable_colexpr();</a>
<a name="ln1013">        if (colexpr-&gt;has_column_id()) {</a>
<a name="ln1014">          LOG_IF(DFATAL, colexpr-&gt;expr_case() != QLExpressionPB::kColumnId)</a>
<a name="ln1015">              &lt;&lt; &quot;Unexpected expression case: &quot; &lt;&lt; colexpr-&gt;expr_case();</a>
<a name="ln1016">          map&lt;ColumnIdRep, ColumnIdRep&gt;::iterator it = col_ids_map.find(colexpr-&gt;column_id());</a>
<a name="ln1017">          if (it == col_ids_map.end()) {</a>
<a name="ln1018">            return STATUS(InvalidArgument,</a>
<a name="ln1019">                          Format(&quot;Unknown column id in the column expression: $0&quot;,</a>
<a name="ln1020">                                 colexpr-&gt;column_id()),</a>
<a name="ln1021">                          MasterError(MasterErrorPB::OBJECT_NOT_FOUND));</a>
<a name="ln1022">          }</a>
<a name="ln1023"> </a>
<a name="ln1024">          colexpr-&gt;set_column_id(it-&gt;second);</a>
<a name="ln1025">        } else {</a>
<a name="ln1026">          // Other column expression cases are not supported yet.</a>
<a name="ln1027">          // TODO: Support ExprCase::kJsonColumn = 9</a>
<a name="ln1028">          return STATUS(NotSupported,</a>
<a name="ln1029">                        Format(&quot;Restore is not yet supported for index by an expression &quot;</a>
<a name="ln1030">                               &quot;of column: $0&quot;, colexpr-&gt;ShortDebugString()),</a>
<a name="ln1031">                        MasterError(MasterErrorPB::SNAPSHOT_FAILED));</a>
<a name="ln1032">        }</a>
<a name="ln1033">      }</a>
<a name="ln1034">    }</a>
<a name="ln1035"> </a>
<a name="ln1036">    for (int i = 0; i &lt; index_info_pb-&gt;indexed_hash_column_ids_size(); ++i) {</a>
<a name="ln1037">      map&lt;ColumnIdRep, ColumnIdRep&gt;::iterator it =</a>
<a name="ln1038">          col_ids_map.find(index_info_pb-&gt;indexed_hash_column_ids(i));</a>
<a name="ln1039">      if (it == col_ids_map.end()) {</a>
<a name="ln1040">        return STATUS(InvalidArgument,</a>
<a name="ln1041">                      Format(&quot;Unknown indexed hash column id in the index info: $0&quot;,</a>
<a name="ln1042">                             index_info_pb-&gt;indexed_hash_column_ids(i)),</a>
<a name="ln1043">                      MasterError(MasterErrorPB::OBJECT_NOT_FOUND));</a>
<a name="ln1044">      }</a>
<a name="ln1045"> </a>
<a name="ln1046">      index_info_pb-&gt;set_indexed_hash_column_ids(i, it-&gt;second);</a>
<a name="ln1047">    }</a>
<a name="ln1048"> </a>
<a name="ln1049">    for (int i = 0; i &lt; index_info_pb-&gt;indexed_range_column_ids_size(); ++i) {</a>
<a name="ln1050">      map&lt;ColumnIdRep, ColumnIdRep&gt;::iterator it =</a>
<a name="ln1051">          col_ids_map.find(index_info_pb-&gt;indexed_range_column_ids(i));</a>
<a name="ln1052">      if (it == col_ids_map.end()) {</a>
<a name="ln1053">        return STATUS(InvalidArgument,</a>
<a name="ln1054">                      Format(&quot;Unknown indexed range column id in the index info: $0&quot;,</a>
<a name="ln1055">                             index_info_pb-&gt;indexed_range_column_ids(i)),</a>
<a name="ln1056">                      MasterError(MasterErrorPB::OBJECT_NOT_FOUND));</a>
<a name="ln1057">      }</a>
<a name="ln1058"> </a>
<a name="ln1059">      index_info_pb-&gt;set_indexed_range_column_ids(i, it-&gt;second);</a>
<a name="ln1060">    }</a>
<a name="ln1061">  }</a>
<a name="ln1062"> </a>
<a name="ln1063">  RETURN_NOT_OK(CreateTable(&amp;req, &amp;resp, /* RpcContext */nullptr));</a>
<a name="ln1064">  table_data-&gt;new_table_id = resp.table_id();</a>
<a name="ln1065">  return Status::OK();</a>
<a name="ln1066">}</a>
<a name="ln1067"> </a>
<a name="ln1068">Status CatalogManager::ImportTableEntry(const NamespaceMap&amp; namespace_map,</a>
<a name="ln1069">                                        const ExternalTableSnapshotDataMap&amp; table_map,</a>
<a name="ln1070">                                        ExternalTableSnapshotData* table_data) {</a>
<a name="ln1071">  const SysTablesEntryPB&amp; meta = DCHECK_NOTNULL(table_data)-&gt;table_entry_pb;</a>
<a name="ln1072"> </a>
<a name="ln1073">  table_data-&gt;old_namespace_id = meta.namespace_id();</a>
<a name="ln1074">  LOG_IF(DFATAL, table_data-&gt;old_namespace_id.empty()) &lt;&lt; &quot;No namespace id&quot;;</a>
<a name="ln1075"> </a>
<a name="ln1076">  LOG_IF(DFATAL, namespace_map.find(table_data-&gt;old_namespace_id) == namespace_map.end())</a>
<a name="ln1077">      &lt;&lt; &quot;Namespace not found: &quot; &lt;&lt; table_data-&gt;old_namespace_id;</a>
<a name="ln1078">  const NamespaceId new_namespace_id =</a>
<a name="ln1079">      namespace_map.find(table_data-&gt;old_namespace_id)-&gt;second.first;</a>
<a name="ln1080">  LOG_IF(DFATAL, new_namespace_id.empty()) &lt;&lt; &quot;No namespace id&quot;;</a>
<a name="ln1081"> </a>
<a name="ln1082">  scoped_refptr&lt;TableInfo&gt; table;</a>
<a name="ln1083"> </a>
<a name="ln1084">  // Create new table if namespace was changed.</a>
<a name="ln1085">  if (new_namespace_id == table_data-&gt;old_namespace_id) {</a>
<a name="ln1086">    TRACE(&quot;Looking up table&quot;);</a>
<a name="ln1087">    SharedLock&lt;LockType&gt; l(lock_);</a>
<a name="ln1088">    table = FindPtrOrNull(*table_ids_map_, table_data-&gt;old_table_id);</a>
<a name="ln1089"> </a>
<a name="ln1090">    // Check table is active OR table name was changed.</a>
<a name="ln1091">    if (table != nullptr &amp;&amp; (!table-&gt;is_running() || table-&gt;name() != meta.name())) {</a>
<a name="ln1092">      table.reset();</a>
<a name="ln1093">    }</a>
<a name="ln1094">  }</a>
<a name="ln1095"> </a>
<a name="ln1096">  if (table == nullptr) {</a>
<a name="ln1097">    if (table_data-&gt;table_entry_pb.table_type() == TableType::PGSQL_TABLE_TYPE) {</a>
<a name="ln1098">      // YSQL table must be created via external call. Find it by name.</a>
<a name="ln1099">      // Expecting the table name is unique in the YSQL database.</a>
<a name="ln1100">      SharedLock&lt;LockType&gt; l(lock_);</a>
<a name="ln1101">      DCHECK(table_data-&gt;new_table_id.empty());</a>
<a name="ln1102"> </a>
<a name="ln1103">      for (const auto&amp; entry : *table_ids_map_) {</a>
<a name="ln1104">        const auto&amp; table_info = *entry.second;</a>
<a name="ln1105">        auto ltm = table_info.LockForRead();</a>
<a name="ln1106"> </a>
<a name="ln1107">        if (table_info.is_running() &amp;&amp;</a>
<a name="ln1108">            new_namespace_id == table_info.namespace_id() &amp;&amp;</a>
<a name="ln1109">            meta.name() == ltm-&gt;data().name() &amp;&amp;</a>
<a name="ln1110">            ((table_data-&gt;is_index() &amp;&amp; IsUserIndexUnlocked(table_info)) ||</a>
<a name="ln1111">                (!table_data-&gt;is_index() &amp;&amp; IsUserTableUnlocked(table_info)))) {</a>
<a name="ln1112">          // Found the new YSQL table by name.</a>
<a name="ln1113">          if (table_data-&gt;new_table_id.empty()) {</a>
<a name="ln1114">              table_data-&gt;new_table_id = entry.first;</a>
<a name="ln1115">          } else if (table_data-&gt;new_table_id != entry.first) {</a>
<a name="ln1116">            return STATUS(InvalidArgument,</a>
<a name="ln1117">                          Format(&quot;Found 2 YSQL tables with the same name: $0 - $1, $2&quot;,</a>
<a name="ln1118">                                 meta.name(), table_data-&gt;new_table_id, entry.first),</a>
<a name="ln1119">                          MasterError(MasterErrorPB::SNAPSHOT_FAILED));</a>
<a name="ln1120">          }</a>
<a name="ln1121">        }</a>
<a name="ln1122">      }</a>
<a name="ln1123"> </a>
<a name="ln1124">      if (table_data-&gt;new_table_id.empty()) {</a>
<a name="ln1125">        return STATUS(InvalidArgument, Format(&quot;YSQL table not found: $0&quot;, meta.name()),</a>
<a name="ln1126">                      MasterError(MasterErrorPB::OBJECT_NOT_FOUND));</a>
<a name="ln1127">      }</a>
<a name="ln1128">    } else {</a>
<a name="ln1129">      RETURN_NOT_OK(RecreateTable(new_namespace_id, table_map, table_data));</a>
<a name="ln1130">    }</a>
<a name="ln1131"> </a>
<a name="ln1132">    TRACE(&quot;Looking up new table&quot;);</a>
<a name="ln1133">    SharedLock&lt;LockType&gt; l(lock_);</a>
<a name="ln1134">    table = FindPtrOrNull(*table_ids_map_, table_data-&gt;new_table_id);</a>
<a name="ln1135"> </a>
<a name="ln1136">    if (table == nullptr) {</a>
<a name="ln1137">      return STATUS(InternalError, Format(&quot;Created table not found: $0&quot;, table_data-&gt;new_table_id),</a>
<a name="ln1138">                    MasterError(MasterErrorPB::OBJECT_NOT_FOUND));</a>
<a name="ln1139">    }</a>
<a name="ln1140">  } else {</a>
<a name="ln1141">    table_data-&gt;new_table_id = table_data-&gt;old_table_id;</a>
<a name="ln1142">  }</a>
<a name="ln1143"> </a>
<a name="ln1144">  TRACE(&quot;Locking table&quot;);</a>
<a name="ln1145">  auto l = table-&gt;LockForRead();</a>
<a name="ln1146">  vector&lt;scoped_refptr&lt;TabletInfo&gt;&gt; new_tablets;</a>
<a name="ln1147">  table-&gt;GetAllTablets(&amp;new_tablets);</a>
<a name="ln1148"> </a>
<a name="ln1149">  for (const scoped_refptr&lt;TabletInfo&gt;&amp; tablet : new_tablets) {</a>
<a name="ln1150">    auto l = tablet-&gt;LockForRead();</a>
<a name="ln1151">    const PartitionPB&amp; partition_pb = tablet-&gt;metadata().state().pb.partition();</a>
<a name="ln1152">    const ExternalTableSnapshotData::PartitionKeys key(</a>
<a name="ln1153">        partition_pb.partition_key_start(), partition_pb.partition_key_end());</a>
<a name="ln1154">    table_data-&gt;new_tablets_map[key] = tablet-&gt;id();</a>
<a name="ln1155">  }</a>
<a name="ln1156"> </a>
<a name="ln1157">  IdPairPB* const namespace_ids = table_data-&gt;table_meta-&gt;mutable_namespace_ids();</a>
<a name="ln1158">  namespace_ids-&gt;set_new_id(new_namespace_id);</a>
<a name="ln1159">  namespace_ids-&gt;set_old_id(table_data-&gt;old_namespace_id);</a>
<a name="ln1160"> </a>
<a name="ln1161">  IdPairPB* const table_ids = table_data-&gt;table_meta-&gt;mutable_table_ids();</a>
<a name="ln1162">  table_ids-&gt;set_new_id(table_data-&gt;new_table_id);</a>
<a name="ln1163">  table_ids-&gt;set_old_id(table_data-&gt;old_table_id);</a>
<a name="ln1164"> </a>
<a name="ln1165">  return Status::OK();</a>
<a name="ln1166">}</a>
<a name="ln1167"> </a>
<a name="ln1168">Status CatalogManager::PreprocessTabletEntry(const SysRowEntry&amp; entry,</a>
<a name="ln1169">                                             ExternalTableSnapshotDataMap* table_map) {</a>
<a name="ln1170">  LOG_IF(DFATAL, entry.type() != SysRowEntry::TABLET) &lt;&lt; &quot;Unexpected entry type: &quot; &lt;&lt; entry.type();</a>
<a name="ln1171"> </a>
<a name="ln1172">  SysTabletsEntryPB meta = VERIFY_RESULT(ParseFromSlice&lt;SysTabletsEntryPB&gt;(entry.data()));</a>
<a name="ln1173"> </a>
<a name="ln1174">  ExternalTableSnapshotData&amp; table_data = (*table_map)[meta.table_id()];</a>
<a name="ln1175">  ++table_data.num_tablets;</a>
<a name="ln1176">  return Status::OK();</a>
<a name="ln1177">}</a>
<a name="ln1178"> </a>
<a name="ln1179">Status CatalogManager::ImportTabletEntry(const SysRowEntry&amp; entry,</a>
<a name="ln1180">                                         ExternalTableSnapshotDataMap* table_map) {</a>
<a name="ln1181">  LOG_IF(DFATAL, entry.type() != SysRowEntry::TABLET) &lt;&lt; &quot;Unexpected entry type: &quot; &lt;&lt; entry.type();</a>
<a name="ln1182"> </a>
<a name="ln1183">  SysTabletsEntryPB meta = VERIFY_RESULT(ParseFromSlice&lt;SysTabletsEntryPB&gt;(entry.data()));</a>
<a name="ln1184"> </a>
<a name="ln1185">  LOG_IF(DFATAL, table_map-&gt;find(meta.table_id()) == table_map-&gt;end())</a>
<a name="ln1186">      &lt;&lt; &quot;Table not found: &quot; &lt;&lt; meta.table_id();</a>
<a name="ln1187">  ExternalTableSnapshotData&amp; table_data = (*table_map)[meta.table_id()];</a>
<a name="ln1188"> </a>
<a name="ln1189">  // Update tablets IDs map.</a>
<a name="ln1190">  if (table_data.new_table_id == table_data.old_table_id) {</a>
<a name="ln1191">    TRACE(&quot;Looking up tablet&quot;);</a>
<a name="ln1192">    SharedLock&lt;LockType&gt; l(lock_);</a>
<a name="ln1193">    scoped_refptr&lt;TabletInfo&gt; tablet = FindPtrOrNull(*tablet_map_, entry.id());</a>
<a name="ln1194"> </a>
<a name="ln1195">    if (tablet != nullptr) {</a>
<a name="ln1196">      IdPairPB* const pair = table_data.tablet_id_map-&gt;Add();</a>
<a name="ln1197">      pair-&gt;set_old_id(entry.id());</a>
<a name="ln1198">      pair-&gt;set_new_id(entry.id());</a>
<a name="ln1199">      return Status::OK();</a>
<a name="ln1200">    }</a>
<a name="ln1201">  }</a>
<a name="ln1202"> </a>
<a name="ln1203">  const PartitionPB&amp; partition_pb = meta.partition();</a>
<a name="ln1204">  const ExternalTableSnapshotData::PartitionKeys key(</a>
<a name="ln1205">      partition_pb.partition_key_start(), partition_pb.partition_key_end());</a>
<a name="ln1206">  const ExternalTableSnapshotData::PartitionToIdMap::const_iterator it =</a>
<a name="ln1207">      table_data.new_tablets_map.find(key);</a>
<a name="ln1208"> </a>
<a name="ln1209">  if (it == table_data.new_tablets_map.end()) {</a>
<a name="ln1210">    return STATUS(NotFound,</a>
<a name="ln1211">                  Format(&quot;Not found new tablet with expected partition keys: $0 - $1&quot;,</a>
<a name="ln1212">                         partition_pb.partition_key_start(),</a>
<a name="ln1213">                         partition_pb.partition_key_end()),</a>
<a name="ln1214">                  MasterError(MasterErrorPB::INTERNAL_ERROR));</a>
<a name="ln1215">  }</a>
<a name="ln1216"> </a>
<a name="ln1217">  IdPairPB* const pair = table_data.tablet_id_map-&gt;Add();</a>
<a name="ln1218">  pair-&gt;set_old_id(entry.id());</a>
<a name="ln1219">  pair-&gt;set_new_id(it-&gt;second);</a>
<a name="ln1220">  return Status::OK();</a>
<a name="ln1221">}</a>
<a name="ln1222"> </a>
<a name="ln1223">const Schema&amp; CatalogManager::schema() {</a>
<a name="ln1224">  return sys_catalog()-&gt;schema();</a>
<a name="ln1225">}</a>
<a name="ln1226"> </a>
<a name="ln1227">TabletInfos CatalogManager::GetTabletInfos(const std::vector&lt;TabletId&gt;&amp; ids) {</a>
<a name="ln1228">  TabletInfos result;</a>
<a name="ln1229">  result.reserve(ids.size());</a>
<a name="ln1230">  SharedLock&lt;LockType&gt; l(lock_);</a>
<a name="ln1231">  for (const auto&amp; id : ids) {</a>
<a name="ln1232">    auto it = tablet_map_-&gt;find(id);</a>
<a name="ln1233">    result.push_back(it != tablet_map_-&gt;end() ? it-&gt;second : nullptr);</a>
<a name="ln1234">  }</a>
<a name="ln1235">  return result;</a>
<a name="ln1236">}</a>
<a name="ln1237"> </a>
<a name="ln1238">void CatalogManager::SendCreateTabletSnapshotRequest(</a>
<a name="ln1239">    const scoped_refptr&lt;TabletInfo&gt;&amp; tablet, const std::string&amp; snapshot_id,</a>
<a name="ln1240">    HybridTime snapshot_hybrid_time, TabletSnapshotOperationCallback callback) {</a>
<a name="ln1241">  auto call = std::make_shared&lt;AsyncTabletSnapshotOp&gt;(</a>
<a name="ln1242">      master_, AsyncTaskPool(), tablet, snapshot_id,</a>
<a name="ln1243">      tserver::TabletSnapshotOpRequestPB::CREATE_ON_TABLET);</a>
<a name="ln1244">  call-&gt;SetSnapshotHybridTime(snapshot_hybrid_time);</a>
<a name="ln1245">  call-&gt;SetCallback(std::move(callback));</a>
<a name="ln1246">  tablet-&gt;table()-&gt;AddTask(call);</a>
<a name="ln1247">  WARN_NOT_OK(ScheduleTask(call), &quot;Failed to send create snapshot request&quot;);</a>
<a name="ln1248">}</a>
<a name="ln1249"> </a>
<a name="ln1250">void CatalogManager::SendRestoreTabletSnapshotRequest(</a>
<a name="ln1251">    const scoped_refptr&lt;TabletInfo&gt;&amp; tablet,</a>
<a name="ln1252">    const string&amp; snapshot_id,</a>
<a name="ln1253">    TabletSnapshotOperationCallback callback) {</a>
<a name="ln1254">  auto call = std::make_shared&lt;AsyncTabletSnapshotOp&gt;(</a>
<a name="ln1255">      master_, AsyncTaskPool(), tablet, snapshot_id,</a>
<a name="ln1256">      tserver::TabletSnapshotOpRequestPB::RESTORE);</a>
<a name="ln1257">  call-&gt;SetCallback(std::move(callback));</a>
<a name="ln1258">  tablet-&gt;table()-&gt;AddTask(call);</a>
<a name="ln1259">  WARN_NOT_OK(ScheduleTask(call), &quot;Failed to send restore snapshot request&quot;);</a>
<a name="ln1260">}</a>
<a name="ln1261"> </a>
<a name="ln1262">void CatalogManager::SendDeleteTabletSnapshotRequest(const scoped_refptr&lt;TabletInfo&gt;&amp; tablet,</a>
<a name="ln1263">                                                     const string&amp; snapshot_id,</a>
<a name="ln1264">                                                     TabletSnapshotOperationCallback callback) {</a>
<a name="ln1265">  auto call = std::make_shared&lt;AsyncTabletSnapshotOp&gt;(</a>
<a name="ln1266">      master_, AsyncTaskPool(), tablet, snapshot_id,</a>
<a name="ln1267">      tserver::TabletSnapshotOpRequestPB::DELETE_ON_TABLET);</a>
<a name="ln1268">  call-&gt;SetCallback(std::move(callback));</a>
<a name="ln1269">  tablet-&gt;table()-&gt;AddTask(call);</a>
<a name="ln1270">  WARN_NOT_OK(ScheduleTask(call), &quot;Failed to send delete snapshot request&quot;);</a>
<a name="ln1271">}</a>
<a name="ln1272"> </a>
<a name="ln1273">rpc::Scheduler&amp; CatalogManager::Scheduler() {</a>
<a name="ln1274">  return master_-&gt;messenger()-&gt;scheduler();</a>
<a name="ln1275">}</a>
<a name="ln1276"> </a>
<a name="ln1277">bool CatalogManager::IsLeader() {</a>
<a name="ln1278">  auto peer = tablet_peer();</a>
<a name="ln1279">  if (!peer) {</a>
<a name="ln1280">    return false;</a>
<a name="ln1281">  }</a>
<a name="ln1282">  auto consensus = peer-&gt;shared_consensus();</a>
<a name="ln1283">  if (!consensus) {</a>
<a name="ln1284">    return false;</a>
<a name="ln1285">  }</a>
<a name="ln1286">  auto leader_status = consensus-&gt;GetLeaderStatus(/* allow_stale= */ true);</a>
<a name="ln1287">  return leader_status == consensus::LeaderStatus::LEADER_AND_READY;</a>
<a name="ln1288">}</a>
<a name="ln1289"> </a>
<a name="ln1290">void CatalogManager::HandleCreateTabletSnapshotResponse(TabletInfo *tablet, bool error) {</a>
<a name="ln1291">  LOG(INFO) &lt;&lt; &quot;Handling Create Tablet Snapshot Response for tablet &quot;</a>
<a name="ln1292">            &lt;&lt; DCHECK_NOTNULL(tablet)-&gt;ToString() &lt;&lt; (error ? &quot;  ERROR&quot; : &quot;  OK&quot;);</a>
<a name="ln1293"> </a>
<a name="ln1294">  // Get the snapshot data descriptor from the catalog manager.</a>
<a name="ln1295">  scoped_refptr&lt;SnapshotInfo&gt; snapshot;</a>
<a name="ln1296">  {</a>
<a name="ln1297">    std::lock_guard&lt;LockType&gt; manager_l(lock_);</a>
<a name="ln1298">    TRACE(&quot;Acquired catalog manager lock&quot;);</a>
<a name="ln1299"> </a>
<a name="ln1300">    if (current_snapshot_id_.empty()) {</a>
<a name="ln1301">      LOG(WARNING) &lt;&lt; &quot;No active snapshot: &quot; &lt;&lt; current_snapshot_id_;</a>
<a name="ln1302">      return;</a>
<a name="ln1303">    }</a>
<a name="ln1304"> </a>
<a name="ln1305">    snapshot = FindPtrOrNull(non_txn_snapshot_ids_map_, current_snapshot_id_);</a>
<a name="ln1306"> </a>
<a name="ln1307">    if (!snapshot) {</a>
<a name="ln1308">      LOG(WARNING) &lt;&lt; &quot;Snapshot not found: &quot; &lt;&lt; current_snapshot_id_;</a>
<a name="ln1309">      return;</a>
<a name="ln1310">    }</a>
<a name="ln1311">  }</a>
<a name="ln1312"> </a>
<a name="ln1313">  if (!snapshot-&gt;IsCreateInProgress()) {</a>
<a name="ln1314">    LOG(WARNING) &lt;&lt; &quot;Snapshot is not in creating state: &quot; &lt;&lt; snapshot-&gt;id();</a>
<a name="ln1315">    return;</a>
<a name="ln1316">  }</a>
<a name="ln1317"> </a>
<a name="ln1318">  auto tablet_l = tablet-&gt;LockForRead();</a>
<a name="ln1319">  auto l = snapshot-&gt;LockForWrite();</a>
<a name="ln1320">  RepeatedPtrField&lt;SysSnapshotEntryPB_TabletSnapshotPB&gt;* tablet_snapshots =</a>
<a name="ln1321">      l-&gt;mutable_data()-&gt;pb.mutable_tablet_snapshots();</a>
<a name="ln1322">  int num_tablets_complete = 0;</a>
<a name="ln1323"> </a>
<a name="ln1324">  for (int i = 0; i &lt; tablet_snapshots-&gt;size(); ++i) {</a>
<a name="ln1325">    SysSnapshotEntryPB_TabletSnapshotPB* tablet_info = tablet_snapshots-&gt;Mutable(i);</a>
<a name="ln1326"> </a>
<a name="ln1327">    if (tablet_info-&gt;id() == tablet-&gt;id()) {</a>
<a name="ln1328">      tablet_info-&gt;set_state(error ? SysSnapshotEntryPB::FAILED : SysSnapshotEntryPB::COMPLETE);</a>
<a name="ln1329">    }</a>
<a name="ln1330"> </a>
<a name="ln1331">    if (tablet_info-&gt;state() == SysSnapshotEntryPB::COMPLETE) {</a>
<a name="ln1332">      ++num_tablets_complete;</a>
<a name="ln1333">    }</a>
<a name="ln1334">  }</a>
<a name="ln1335"> </a>
<a name="ln1336">  // Finish the snapshot.</a>
<a name="ln1337">  bool finished = true;</a>
<a name="ln1338">  if (error) {</a>
<a name="ln1339">    l-&gt;mutable_data()-&gt;pb.set_state(SysSnapshotEntryPB::FAILED);</a>
<a name="ln1340">    LOG(WARNING) &lt;&lt; &quot;Failed snapshot &quot; &lt;&lt; snapshot-&gt;id() &lt;&lt; &quot; on tablet &quot; &lt;&lt; tablet-&gt;id();</a>
<a name="ln1341">  } else if (num_tablets_complete == tablet_snapshots-&gt;size()) {</a>
<a name="ln1342">    l-&gt;mutable_data()-&gt;pb.set_state(SysSnapshotEntryPB::COMPLETE);</a>
<a name="ln1343">    LOG(INFO) &lt;&lt; &quot;Completed snapshot &quot; &lt;&lt; snapshot-&gt;id();</a>
<a name="ln1344">  } else {</a>
<a name="ln1345">    finished = false;</a>
<a name="ln1346">  }</a>
<a name="ln1347"> </a>
<a name="ln1348">  if (finished) {</a>
<a name="ln1349">    std::lock_guard&lt;LockType&gt; manager_l(lock_);</a>
<a name="ln1350">    TRACE(&quot;Acquired catalog manager lock&quot;);</a>
<a name="ln1351">    current_snapshot_id_ = &quot;&quot;;</a>
<a name="ln1352">  }</a>
<a name="ln1353"> </a>
<a name="ln1354">  VLOG(1) &lt;&lt; &quot;Snapshot: &quot; &lt;&lt; snapshot-&gt;id()</a>
<a name="ln1355">          &lt;&lt; &quot; PB: &quot; &lt;&lt; l-&gt;mutable_data()-&gt;pb.DebugString()</a>
<a name="ln1356">          &lt;&lt; &quot; Complete &quot; &lt;&lt; num_tablets_complete &lt;&lt; &quot; tablets from &quot; &lt;&lt; tablet_snapshots-&gt;size();</a>
<a name="ln1357"> </a>
<a name="ln1358">  const Status s = sys_catalog_-&gt;UpdateItem(snapshot.get(), leader_ready_term());</a>
<a name="ln1359">  if (!s.ok()) {</a>
<a name="ln1360">    return (void)CheckStatus(s, &quot;updating snapshot in sys-catalog&quot;);</a>
<a name="ln1361">  }</a>
<a name="ln1362"> </a>
<a name="ln1363">  l-&gt;Commit();</a>
<a name="ln1364">}</a>
<a name="ln1365"> </a>
<a name="ln1366">void CatalogManager::HandleRestoreTabletSnapshotResponse(TabletInfo *tablet, bool error) {</a>
<a name="ln1367">  LOG(INFO) &lt;&lt; &quot;Handling Restore Tablet Snapshot Response for tablet &quot;</a>
<a name="ln1368">            &lt;&lt; DCHECK_NOTNULL(tablet)-&gt;ToString() &lt;&lt; (error ? &quot;  ERROR&quot; : &quot;  OK&quot;);</a>
<a name="ln1369"> </a>
<a name="ln1370">  // Get the snapshot data descriptor from the catalog manager.</a>
<a name="ln1371">  scoped_refptr&lt;SnapshotInfo&gt; snapshot;</a>
<a name="ln1372">  {</a>
<a name="ln1373">    std::lock_guard&lt;LockType&gt; manager_l(lock_);</a>
<a name="ln1374">    TRACE(&quot;Acquired catalog manager lock&quot;);</a>
<a name="ln1375"> </a>
<a name="ln1376">    if (current_snapshot_id_.empty()) {</a>
<a name="ln1377">      LOG(WARNING) &lt;&lt; &quot;No restoring snapshot: &quot; &lt;&lt; current_snapshot_id_;</a>
<a name="ln1378">      return;</a>
<a name="ln1379">    }</a>
<a name="ln1380"> </a>
<a name="ln1381">    snapshot = FindPtrOrNull(non_txn_snapshot_ids_map_, current_snapshot_id_);</a>
<a name="ln1382"> </a>
<a name="ln1383">    if (!snapshot) {</a>
<a name="ln1384">      LOG(WARNING) &lt;&lt; &quot;Restoring snapshot not found: &quot; &lt;&lt; current_snapshot_id_;</a>
<a name="ln1385">      return;</a>
<a name="ln1386">    }</a>
<a name="ln1387">  }</a>
<a name="ln1388"> </a>
<a name="ln1389">  if (!snapshot-&gt;IsRestoreInProgress()) {</a>
<a name="ln1390">    LOG(WARNING) &lt;&lt; &quot;Snapshot is not in restoring state: &quot; &lt;&lt; snapshot-&gt;id();</a>
<a name="ln1391">    return;</a>
<a name="ln1392">  }</a>
<a name="ln1393"> </a>
<a name="ln1394">  auto tablet_l = tablet-&gt;LockForRead();</a>
<a name="ln1395">  auto l = snapshot-&gt;LockForWrite();</a>
<a name="ln1396">  RepeatedPtrField&lt;SysSnapshotEntryPB_TabletSnapshotPB&gt;* tablet_snapshots =</a>
<a name="ln1397">      l-&gt;mutable_data()-&gt;pb.mutable_tablet_snapshots();</a>
<a name="ln1398">  int num_tablets_complete = 0;</a>
<a name="ln1399"> </a>
<a name="ln1400">  for (int i = 0; i &lt; tablet_snapshots-&gt;size(); ++i) {</a>
<a name="ln1401">    SysSnapshotEntryPB_TabletSnapshotPB* tablet_info = tablet_snapshots-&gt;Mutable(i);</a>
<a name="ln1402"> </a>
<a name="ln1403">    if (tablet_info-&gt;id() == tablet-&gt;id()) {</a>
<a name="ln1404">      tablet_info-&gt;set_state(error ? SysSnapshotEntryPB::FAILED : SysSnapshotEntryPB::COMPLETE);</a>
<a name="ln1405">    }</a>
<a name="ln1406"> </a>
<a name="ln1407">    if (tablet_info-&gt;state() == SysSnapshotEntryPB::COMPLETE) {</a>
<a name="ln1408">      ++num_tablets_complete;</a>
<a name="ln1409">    }</a>
<a name="ln1410">  }</a>
<a name="ln1411"> </a>
<a name="ln1412">  // Finish the snapshot.</a>
<a name="ln1413">  if (error || num_tablets_complete == tablet_snapshots-&gt;size()) {</a>
<a name="ln1414">    if (error) {</a>
<a name="ln1415">      l-&gt;mutable_data()-&gt;pb.set_state(SysSnapshotEntryPB::FAILED);</a>
<a name="ln1416">      LOG(WARNING) &lt;&lt; &quot;Failed restoring snapshot &quot; &lt;&lt; snapshot-&gt;id()</a>
<a name="ln1417">                   &lt;&lt; &quot; on tablet &quot; &lt;&lt; tablet-&gt;id();</a>
<a name="ln1418">    } else {</a>
<a name="ln1419">      LOG_IF(DFATAL, num_tablets_complete != tablet_snapshots-&gt;size())</a>
<a name="ln1420">          &lt;&lt; &quot;Wrong number of tablets&quot;;</a>
<a name="ln1421">      l-&gt;mutable_data()-&gt;pb.set_state(SysSnapshotEntryPB::COMPLETE);</a>
<a name="ln1422">      LOG(INFO) &lt;&lt; &quot;Restored snapshot &quot; &lt;&lt; snapshot-&gt;id();</a>
<a name="ln1423">    }</a>
<a name="ln1424"> </a>
<a name="ln1425">    std::lock_guard&lt;LockType&gt; manager_l(lock_);</a>
<a name="ln1426">    TRACE(&quot;Acquired catalog manager lock&quot;);</a>
<a name="ln1427">    current_snapshot_id_ = &quot;&quot;;</a>
<a name="ln1428">  }</a>
<a name="ln1429"> </a>
<a name="ln1430">  VLOG(1) &lt;&lt; &quot;Snapshot: &quot; &lt;&lt; snapshot-&gt;id()</a>
<a name="ln1431">          &lt;&lt; &quot; PB: &quot; &lt;&lt; l-&gt;mutable_data()-&gt;pb.DebugString()</a>
<a name="ln1432">          &lt;&lt; &quot; Complete &quot; &lt;&lt; num_tablets_complete &lt;&lt; &quot; tablets from &quot; &lt;&lt; tablet_snapshots-&gt;size();</a>
<a name="ln1433"> </a>
<a name="ln1434">  const Status s = sys_catalog_-&gt;UpdateItem(snapshot.get(), leader_ready_term());</a>
<a name="ln1435">  if (!s.ok()) {</a>
<a name="ln1436">    return (void)CheckStatus(s, &quot;updating snapshot in sys-catalog&quot;);</a>
<a name="ln1437">  }</a>
<a name="ln1438"> </a>
<a name="ln1439">  l-&gt;Commit();</a>
<a name="ln1440">}</a>
<a name="ln1441"> </a>
<a name="ln1442">void CatalogManager::HandleDeleteTabletSnapshotResponse(</a>
<a name="ln1443">    SnapshotId snapshot_id, TabletInfo *tablet, bool error) {</a>
<a name="ln1444">  LOG(INFO) &lt;&lt; &quot;Handling Delete Tablet Snapshot Response for tablet &quot;</a>
<a name="ln1445">            &lt;&lt; DCHECK_NOTNULL(tablet)-&gt;ToString() &lt;&lt; (error ? &quot;  ERROR&quot; : &quot;  OK&quot;);</a>
<a name="ln1446"> </a>
<a name="ln1447">  // Get the snapshot data descriptor from the catalog manager.</a>
<a name="ln1448">  scoped_refptr&lt;SnapshotInfo&gt; snapshot;</a>
<a name="ln1449">  {</a>
<a name="ln1450">    std::lock_guard&lt;LockType&gt; manager_l(lock_);</a>
<a name="ln1451">    TRACE(&quot;Acquired catalog manager lock&quot;);</a>
<a name="ln1452"> </a>
<a name="ln1453">    snapshot = FindPtrOrNull(non_txn_snapshot_ids_map_, snapshot_id);</a>
<a name="ln1454"> </a>
<a name="ln1455">    if (!snapshot) {</a>
<a name="ln1456">      LOG(WARNING) &lt;&lt; &quot;Snapshot not found: &quot; &lt;&lt; snapshot_id;</a>
<a name="ln1457">      return;</a>
<a name="ln1458">    }</a>
<a name="ln1459">  }</a>
<a name="ln1460"> </a>
<a name="ln1461">  if (!snapshot-&gt;IsDeleteInProgress()) {</a>
<a name="ln1462">    LOG(WARNING) &lt;&lt; &quot;Snapshot is not in deleting state: &quot; &lt;&lt; snapshot-&gt;id();</a>
<a name="ln1463">    return;</a>
<a name="ln1464">  }</a>
<a name="ln1465"> </a>
<a name="ln1466">  auto tablet_l = tablet-&gt;LockForRead();</a>
<a name="ln1467">  auto l = snapshot-&gt;LockForWrite();</a>
<a name="ln1468">  RepeatedPtrField&lt;SysSnapshotEntryPB_TabletSnapshotPB&gt;* tablet_snapshots =</a>
<a name="ln1469">      l-&gt;mutable_data()-&gt;pb.mutable_tablet_snapshots();</a>
<a name="ln1470">  int num_tablets_complete = 0;</a>
<a name="ln1471"> </a>
<a name="ln1472">  for (int i = 0; i &lt; tablet_snapshots-&gt;size(); ++i) {</a>
<a name="ln1473">    SysSnapshotEntryPB_TabletSnapshotPB* tablet_info = tablet_snapshots-&gt;Mutable(i);</a>
<a name="ln1474"> </a>
<a name="ln1475">    if (tablet_info-&gt;id() == tablet-&gt;id()) {</a>
<a name="ln1476">      tablet_info-&gt;set_state(error ? SysSnapshotEntryPB::FAILED : SysSnapshotEntryPB::DELETED);</a>
<a name="ln1477">    }</a>
<a name="ln1478"> </a>
<a name="ln1479">    if (tablet_info-&gt;state() != SysSnapshotEntryPB::DELETING) {</a>
<a name="ln1480">      ++num_tablets_complete;</a>
<a name="ln1481">    }</a>
<a name="ln1482">  }</a>
<a name="ln1483"> </a>
<a name="ln1484">  if (num_tablets_complete == tablet_snapshots-&gt;size()) {</a>
<a name="ln1485">    // Delete the snapshot.</a>
<a name="ln1486">    l-&gt;mutable_data()-&gt;pb.set_state(SysSnapshotEntryPB::DELETED);</a>
<a name="ln1487">    LOG(INFO) &lt;&lt; &quot;Deleted snapshot &quot; &lt;&lt; snapshot-&gt;id();</a>
<a name="ln1488"> </a>
<a name="ln1489">    const Status s = sys_catalog_-&gt;DeleteItem(snapshot.get(), leader_ready_term());</a>
<a name="ln1490"> </a>
<a name="ln1491">    std::lock_guard&lt;LockType&gt; manager_l(lock_);</a>
<a name="ln1492">    TRACE(&quot;Acquired catalog manager lock&quot;);</a>
<a name="ln1493"> </a>
<a name="ln1494">    if (current_snapshot_id_ == snapshot_id) {</a>
<a name="ln1495">      current_snapshot_id_ = &quot;&quot;;</a>
<a name="ln1496">    }</a>
<a name="ln1497"> </a>
<a name="ln1498">    // Remove it from the maps.</a>
<a name="ln1499">    TRACE(&quot;Removing from maps&quot;);</a>
<a name="ln1500">    if (non_txn_snapshot_ids_map_.erase(snapshot_id) &lt; 1) {</a>
<a name="ln1501">      LOG(WARNING) &lt;&lt; &quot;Could not remove snapshot &quot; &lt;&lt; snapshot_id &lt;&lt; &quot; from map&quot;;</a>
<a name="ln1502">    }</a>
<a name="ln1503"> </a>
<a name="ln1504">    if (!s.ok()) {</a>
<a name="ln1505">      return (void)CheckStatus(s, &quot;deleting snapshot from sys-catalog&quot;);</a>
<a name="ln1506">    }</a>
<a name="ln1507">  } else if (error) {</a>
<a name="ln1508">    l-&gt;mutable_data()-&gt;pb.set_state(SysSnapshotEntryPB::FAILED);</a>
<a name="ln1509">    LOG(WARNING) &lt;&lt; &quot;Failed snapshot &quot; &lt;&lt; snapshot-&gt;id() &lt;&lt; &quot; deletion on tablet &quot; &lt;&lt; tablet-&gt;id();</a>
<a name="ln1510"> </a>
<a name="ln1511">    const Status s = sys_catalog_-&gt;UpdateItem(snapshot.get(), leader_ready_term());</a>
<a name="ln1512">    if (!s.ok()) {</a>
<a name="ln1513">      return (void)CheckStatus(s, &quot;updating snapshot in sys-catalog&quot;);</a>
<a name="ln1514">    }</a>
<a name="ln1515">  }</a>
<a name="ln1516"> </a>
<a name="ln1517">  l-&gt;Commit();</a>
<a name="ln1518"> </a>
<a name="ln1519">  VLOG(1) &lt;&lt; &quot;Deleting snapshot: &quot; &lt;&lt; snapshot-&gt;id()</a>
<a name="ln1520">          &lt;&lt; &quot; PB: &quot; &lt;&lt; l-&gt;mutable_data()-&gt;pb.DebugString()</a>
<a name="ln1521">          &lt;&lt; &quot; Complete &quot; &lt;&lt; num_tablets_complete &lt;&lt; &quot; tablets from &quot; &lt;&lt; tablet_snapshots-&gt;size();</a>
<a name="ln1522">}</a>
<a name="ln1523"> </a>
<a name="ln1524">void CatalogManager::DumpState(std::ostream* out, bool on_disk_dump) const {</a>
<a name="ln1525">  super::DumpState(out, on_disk_dump);</a>
<a name="ln1526"> </a>
<a name="ln1527">  // TODO: dump snapshots</a>
<a name="ln1528">}</a>
<a name="ln1529"> </a>
<a name="ln1530">Status CatalogManager::CheckValidReplicationInfo(const ReplicationInfoPB&amp; replication_info,</a>
<a name="ln1531">                                                 const TSDescriptorVector&amp; all_ts_descs,</a>
<a name="ln1532">                                                 const vector&lt;Partition&gt;&amp; partitions,</a>
<a name="ln1533">                                                 CreateTableResponsePB* resp) {</a>
<a name="ln1534">  TSDescriptorVector ts_descs;</a>
<a name="ln1535">  GetTsDescsFromPlacementInfo(replication_info.live_replicas(), all_ts_descs, &amp;ts_descs);</a>
<a name="ln1536">  RETURN_NOT_OK(super::CheckValidPlacementInfo(replication_info.live_replicas(), ts_descs,</a>
<a name="ln1537">                                               partitions, resp));</a>
<a name="ln1538">  for (int i = 0; i &lt; replication_info.read_replicas_size(); i++) {</a>
<a name="ln1539">    GetTsDescsFromPlacementInfo(replication_info.read_replicas(i), all_ts_descs, &amp;ts_descs);</a>
<a name="ln1540">    RETURN_NOT_OK(super::CheckValidPlacementInfo(replication_info.read_replicas(i), ts_descs,</a>
<a name="ln1541">                                                 partitions, resp));</a>
<a name="ln1542">  }</a>
<a name="ln1543">  return Status::OK();</a>
<a name="ln1544">}</a>
<a name="ln1545"> </a>
<a name="ln1546">Status CatalogManager::HandlePlacementUsingReplicationInfo(</a>
<a name="ln1547">    const ReplicationInfoPB&amp; replication_info,</a>
<a name="ln1548">    const TSDescriptorVector&amp; all_ts_descs,</a>
<a name="ln1549">    consensus::RaftConfigPB* config) {</a>
<a name="ln1550">  TSDescriptorVector ts_descs;</a>
<a name="ln1551">  GetTsDescsFromPlacementInfo(replication_info.live_replicas(), all_ts_descs, &amp;ts_descs);</a>
<a name="ln1552">  RETURN_NOT_OK(super::HandlePlacementUsingPlacementInfo(replication_info.live_replicas(),</a>
<a name="ln1553">                                                      ts_descs,</a>
<a name="ln1554">                                                      consensus::RaftPeerPB::VOTER, config));</a>
<a name="ln1555">  for (int i = 0; i &lt; replication_info.read_replicas_size(); i++) {</a>
<a name="ln1556">    GetTsDescsFromPlacementInfo(replication_info.read_replicas(i), all_ts_descs, &amp;ts_descs);</a>
<a name="ln1557">    RETURN_NOT_OK(super::HandlePlacementUsingPlacementInfo(replication_info.read_replicas(i),</a>
<a name="ln1558">                                                           ts_descs,</a>
<a name="ln1559">                                                           consensus::RaftPeerPB::OBSERVER,</a>
<a name="ln1560">                                                           config));</a>
<a name="ln1561">  }</a>
<a name="ln1562">  return Status::OK();</a>
<a name="ln1563">}</a>
<a name="ln1564"> </a>
<a name="ln1565">void CatalogManager::GetTsDescsFromPlacementInfo(const PlacementInfoPB&amp; placement_info,</a>
<a name="ln1566">                                                 const TSDescriptorVector&amp; all_ts_descs,</a>
<a name="ln1567">                                                 TSDescriptorVector* ts_descs) {</a>
<a name="ln1568">  ts_descs-&gt;clear();</a>
<a name="ln1569">  for (const auto&amp; ts_desc : all_ts_descs) {</a>
<a name="ln1570">    TSDescriptor* ts_desc_ent = down_cast&lt;TSDescriptor*&gt;(ts_desc.get());</a>
<a name="ln1571">    if (placement_info.has_placement_uuid()) {</a>
<a name="ln1572">      string placement_uuid = placement_info.placement_uuid();</a>
<a name="ln1573">      if (ts_desc_ent-&gt;placement_uuid() == placement_uuid) {</a>
<a name="ln1574">        ts_descs-&gt;push_back(ts_desc);</a>
<a name="ln1575">      }</a>
<a name="ln1576">    } else if (ts_desc_ent-&gt;placement_uuid() == &quot;&quot;) {</a>
<a name="ln1577">      // Since the placement info has no placement id, we know it is live, so we add this ts.</a>
<a name="ln1578">      ts_descs-&gt;push_back(ts_desc);</a>
<a name="ln1579">    }</a>
<a name="ln1580">  }</a>
<a name="ln1581">}</a>
<a name="ln1582"> </a>
<a name="ln1583">template &lt;typename Registry, typename Mutex&gt;</a>
<a name="ln1584">bool ShouldResendRegistry(</a>
<a name="ln1585">    const std::string&amp; ts_uuid, bool has_registration, Registry* registry, Mutex* mutex) {</a>
<a name="ln1586">  bool should_resend_registry;</a>
<a name="ln1587">  {</a>
<a name="ln1588">    std::lock_guard&lt;Mutex&gt; lock(*mutex);</a>
<a name="ln1589">    auto it = registry-&gt;find(ts_uuid);</a>
<a name="ln1590">    should_resend_registry = (it == registry-&gt;end() || it-&gt;second || has_registration);</a>
<a name="ln1591">    if (it == registry-&gt;end()) {</a>
<a name="ln1592">      registry-&gt;emplace(ts_uuid, false);</a>
<a name="ln1593">    } else {</a>
<a name="ln1594">      it-&gt;second = false;</a>
<a name="ln1595">    }</a>
<a name="ln1596">  }</a>
<a name="ln1597">  return should_resend_registry;</a>
<a name="ln1598">}</a>
<a name="ln1599"> </a>
<a name="ln1600">Status CatalogManager::FillHeartbeatResponse(const TSHeartbeatRequestPB* req,</a>
<a name="ln1601">                                             TSHeartbeatResponsePB* resp) {</a>
<a name="ln1602">  SysClusterConfigEntryPB cluster_config;</a>
<a name="ln1603">  RETURN_NOT_OK(GetClusterConfig(&amp;cluster_config));</a>
<a name="ln1604">  RETURN_NOT_OK(FillHeartbeatResponseEncryption(cluster_config, req, resp));</a>
<a name="ln1605">  return FillHeartbeatResponseCDC(cluster_config, req, resp);</a>
<a name="ln1606">}</a>
<a name="ln1607"> </a>
<a name="ln1608"> </a>
<a name="ln1609">Status CatalogManager::FillHeartbeatResponseCDC(const SysClusterConfigEntryPB&amp; cluster_config,</a>
<a name="ln1610">                                                const TSHeartbeatRequestPB* req,</a>
<a name="ln1611">                                                TSHeartbeatResponsePB* resp) {</a>
<a name="ln1612">  resp-&gt;set_cluster_config_version(cluster_config.version());</a>
<a name="ln1613">  if (!cluster_config.has_consumer_registry() ||</a>
<a name="ln1614">      req-&gt;cluster_config_version() &gt;= cluster_config.version()) {</a>
<a name="ln1615">    return Status::OK();</a>
<a name="ln1616">  }</a>
<a name="ln1617">  *resp-&gt;mutable_consumer_registry() = cluster_config.consumer_registry();</a>
<a name="ln1618">  return Status::OK();</a>
<a name="ln1619">}</a>
<a name="ln1620"> </a>
<a name="ln1621">Status CatalogManager::FillHeartbeatResponseEncryption(</a>
<a name="ln1622">    const SysClusterConfigEntryPB&amp; cluster_config,</a>
<a name="ln1623">    const TSHeartbeatRequestPB* req,</a>
<a name="ln1624">    TSHeartbeatResponsePB* resp) {</a>
<a name="ln1625">  const auto&amp; ts_uuid = req-&gt;common().ts_instance().permanent_uuid();</a>
<a name="ln1626">  if (!cluster_config.has_encryption_info() ||</a>
<a name="ln1627">      !ShouldResendRegistry(ts_uuid, req-&gt;has_registration(), &amp;should_send_universe_key_registry_,</a>
<a name="ln1628">                            &amp;should_send_universe_key_registry_mutex_)) {</a>
<a name="ln1629">    return Status::OK();</a>
<a name="ln1630">  }</a>
<a name="ln1631"> </a>
<a name="ln1632">  const auto&amp; encryption_info = cluster_config.encryption_info();</a>
<a name="ln1633">  RETURN_NOT_OK(encryption_manager_-&gt;FillHeartbeatResponseEncryption(encryption_info, resp));</a>
<a name="ln1634"> </a>
<a name="ln1635">  return Status::OK();</a>
<a name="ln1636">}</a>
<a name="ln1637"> </a>
<a name="ln1638">void CatalogManager::SetTabletSnapshotsState(SysSnapshotEntryPB::State state,</a>
<a name="ln1639">                                             SysSnapshotEntryPB* snapshot_pb) {</a>
<a name="ln1640">  RepeatedPtrField&lt;SysSnapshotEntryPB_TabletSnapshotPB&gt;* tablet_snapshots =</a>
<a name="ln1641">      snapshot_pb-&gt;mutable_tablet_snapshots();</a>
<a name="ln1642"> </a>
<a name="ln1643">  for (int i = 0; i &lt; tablet_snapshots-&gt;size(); ++i) {</a>
<a name="ln1644">    SysSnapshotEntryPB_TabletSnapshotPB* tablet_info = tablet_snapshots-&gt;Mutable(i);</a>
<a name="ln1645">    tablet_info-&gt;set_state(state);</a>
<a name="ln1646">  }</a>
<a name="ln1647">}</a>
<a name="ln1648"> </a>
<a name="ln1649">Status CatalogManager::CreateCdcStateTableIfNeeded(rpc::RpcContext *rpc) {</a>
<a name="ln1650">  TableIdentifierPB table_identifier;</a>
<a name="ln1651">  table_identifier.set_table_name(kCdcStateTableName);</a>
<a name="ln1652">  table_identifier.mutable_namespace_()-&gt;set_name(kSystemNamespaceName);</a>
<a name="ln1653"> </a>
<a name="ln1654">  // Check that the namespace exists.</a>
<a name="ln1655">  scoped_refptr&lt;NamespaceInfo&gt; ns_info;</a>
<a name="ln1656">  RETURN_NOT_OK(FindNamespace(table_identifier.namespace_(), &amp;ns_info));</a>
<a name="ln1657">  if (!ns_info) {</a>
<a name="ln1658">    return STATUS(NotFound, &quot;Namespace does not exist&quot;, kSystemNamespaceName);</a>
<a name="ln1659">  }</a>
<a name="ln1660"> </a>
<a name="ln1661">  // If CDC state table exists do nothing, otherwise create it.</a>
<a name="ln1662">  scoped_refptr&lt;TableInfo&gt; table_info;</a>
<a name="ln1663">  RETURN_NOT_OK(FindTable(table_identifier, &amp;table_info));</a>
<a name="ln1664"> </a>
<a name="ln1665">  if (!table_info) {</a>
<a name="ln1666">    // Set up a CreateTable request internally.</a>
<a name="ln1667">    CreateTableRequestPB req;</a>
<a name="ln1668">    CreateTableResponsePB resp;</a>
<a name="ln1669">    req.set_name(kCdcStateTableName);</a>
<a name="ln1670">    req.mutable_namespace_()-&gt;CopyFrom(table_identifier.namespace_());</a>
<a name="ln1671">    req.set_table_type(TableType::YQL_TABLE_TYPE);</a>
<a name="ln1672"> </a>
<a name="ln1673">    client::YBSchemaBuilder schema_builder;</a>
<a name="ln1674">    schema_builder.AddColumn(master::kCdcTabletId)-&gt;HashPrimaryKey()-&gt;Type(DataType::STRING);</a>
<a name="ln1675">    schema_builder.AddColumn(master::kCdcStreamId)-&gt;PrimaryKey()-&gt;Type(DataType::STRING);</a>
<a name="ln1676">    schema_builder.AddColumn(master::kCdcCheckpoint)-&gt;Type(DataType::STRING);</a>
<a name="ln1677">    schema_builder.AddColumn(master::kCdcData)-&gt;Type(QLType::CreateTypeMap(</a>
<a name="ln1678">        DataType::STRING, DataType::STRING));</a>
<a name="ln1679">    schema_builder.AddColumn(master::kCdcLastReplicationTime)-&gt;Type(DataType::TIMESTAMP);</a>
<a name="ln1680"> </a>
<a name="ln1681">    client::YBSchema yb_schema;</a>
<a name="ln1682">    CHECK_OK(schema_builder.Build(&amp;yb_schema));</a>
<a name="ln1683"> </a>
<a name="ln1684">    auto schema = yb::client::internal::GetSchema(yb_schema);</a>
<a name="ln1685">    SchemaToPB(schema, req.mutable_schema());</a>
<a name="ln1686">    // Explicitly set the number tablets if the corresponding flag is set, otherwise CreateTable</a>
<a name="ln1687">    // will use the same defaults as for regular tables.</a>
<a name="ln1688">    if (FLAGS_cdc_state_table_num_tablets &gt; 0) {</a>
<a name="ln1689">      req.mutable_schema()-&gt;mutable_table_properties()-&gt;set_num_tablets(</a>
<a name="ln1690">          FLAGS_cdc_state_table_num_tablets);</a>
<a name="ln1691">    }</a>
<a name="ln1692"> </a>
<a name="ln1693">    Status s = CreateTable(&amp;req, &amp;resp, rpc);</a>
<a name="ln1694">    // We do not lock here so it is technically possible that the table was already created.</a>
<a name="ln1695">    // If so, there is nothing to do so we just ignore the &quot;AlreadyPresent&quot; error.</a>
<a name="ln1696">    if (!s.ok() &amp;&amp; !s.IsAlreadyPresent()) {</a>
<a name="ln1697">      return s;</a>
<a name="ln1698">    }</a>
<a name="ln1699">  }</a>
<a name="ln1700">  return Status::OK();</a>
<a name="ln1701">}</a>
<a name="ln1702"> </a>
<a name="ln1703">Status CatalogManager::IsCdcStateTableCreated(IsCreateTableDoneResponsePB* resp) {</a>
<a name="ln1704">  IsCreateTableDoneRequestPB req;</a>
<a name="ln1705"> </a>
<a name="ln1706">  req.mutable_table()-&gt;set_table_name(kCdcStateTableName);</a>
<a name="ln1707">  req.mutable_table()-&gt;mutable_namespace_()-&gt;set_name(kSystemNamespaceName);</a>
<a name="ln1708"> </a>
<a name="ln1709">  return IsCreateTableDone(&amp;req, resp);</a>
<a name="ln1710">}</a>
<a name="ln1711"> </a>
<a name="ln1712">// Helper class to print a vector of CDCStreamInfo pointers.</a>
<a name="ln1713">namespace {</a>
<a name="ln1714">  template&lt;class CDCStreamInfoPointer&gt;</a>
<a name="ln1715">  std::string JoinStreamsCSVLine(std::vector&lt;CDCStreamInfoPointer&gt; cdc_streams) {</a>
<a name="ln1716">    std::vector&lt;CDCStreamId&gt; cdc_stream_ids;</a>
<a name="ln1717">    for (const auto&amp; cdc_stream : cdc_streams) {</a>
<a name="ln1718">      cdc_stream_ids.push_back(cdc_stream-&gt;id());</a>
<a name="ln1719">    }</a>
<a name="ln1720">    return JoinCSVLine(cdc_stream_ids);</a>
<a name="ln1721">  }</a>
<a name="ln1722">} // namespace</a>
<a name="ln1723"> </a>
<a name="ln1724"> </a>
<a name="ln1725">Status CatalogManager::DeleteCDCStreamsForTable(const TableId&amp; table_id) {</a>
<a name="ln1726">  return DeleteCDCStreamsForTables({table_id});</a>
<a name="ln1727">}</a>
<a name="ln1728"> </a>
<a name="ln1729">Status CatalogManager::DeleteCDCStreamsForTables(const vector&lt;TableId&gt;&amp; table_ids) {</a>
<a name="ln1730">  std::ostringstream tid_stream;</a>
<a name="ln1731">  for (const auto&amp; tid : table_ids) {</a>
<a name="ln1732">    tid_stream &lt;&lt; &quot; &quot; &lt;&lt; tid;</a>
<a name="ln1733">  }</a>
<a name="ln1734">  LOG(INFO) &lt;&lt; &quot;Deleting CDC streams for tables:&quot; &lt;&lt; tid_stream.str();</a>
<a name="ln1735"> </a>
<a name="ln1736">  std::vector&lt;scoped_refptr&lt;CDCStreamInfo&gt;&gt; streams;</a>
<a name="ln1737">  for (const auto&amp; tid : table_ids) {</a>
<a name="ln1738">    auto newstreams = FindCDCStreamsForTable(tid);</a>
<a name="ln1739">    streams.insert(streams.end(), newstreams.begin(), newstreams.end());</a>
<a name="ln1740">  }</a>
<a name="ln1741"> </a>
<a name="ln1742">  if (streams.empty()) {</a>
<a name="ln1743">    return Status::OK();</a>
<a name="ln1744">  }</a>
<a name="ln1745"> </a>
<a name="ln1746">  // Do not delete them here, just mark them as DELETING and the catalog manager background thread</a>
<a name="ln1747">  // will handle the deletion.</a>
<a name="ln1748">  return MarkCDCStreamsAsDeleting(streams);</a>
<a name="ln1749">}</a>
<a name="ln1750"> </a>
<a name="ln1751">std::vector&lt;scoped_refptr&lt;CDCStreamInfo&gt;&gt; CatalogManager::FindCDCStreamsForTable(</a>
<a name="ln1752">    const TableId&amp; table_id) {</a>
<a name="ln1753">  std::vector&lt;scoped_refptr&lt;CDCStreamInfo&gt;&gt; streams;</a>
<a name="ln1754">  std::shared_lock&lt;LockType&gt; l(lock_);</a>
<a name="ln1755"> </a>
<a name="ln1756">  for (const auto&amp; entry : cdc_stream_map_) {</a>
<a name="ln1757">    auto ltm = entry.second-&gt;LockForRead();</a>
<a name="ln1758"> </a>
<a name="ln1759">    if (ltm-&gt;data().table_id() == table_id &amp;&amp; !ltm-&gt;data().started_deleting()) {</a>
<a name="ln1760">      streams.push_back(entry.second);</a>
<a name="ln1761">    }</a>
<a name="ln1762">  }</a>
<a name="ln1763">  return streams;</a>
<a name="ln1764">}</a>
<a name="ln1765"> </a>
<a name="ln1766">void CatalogManager::GetAllCDCStreams(std::vector&lt;scoped_refptr&lt;CDCStreamInfo&gt;&gt;* streams) {</a>
<a name="ln1767">  streams-&gt;clear();</a>
<a name="ln1768">  streams-&gt;reserve(cdc_stream_map_.size());</a>
<a name="ln1769">  std::shared_lock&lt;LockType&gt; l(lock_);</a>
<a name="ln1770">  for (const CDCStreamInfoMap::value_type&amp; e : cdc_stream_map_) {</a>
<a name="ln1771">    if (!e.second-&gt;LockForRead()-&gt;data().is_deleting()) {</a>
<a name="ln1772">      streams-&gt;push_back(e.second);</a>
<a name="ln1773">    }</a>
<a name="ln1774">  }</a>
<a name="ln1775">}</a>
<a name="ln1776"> </a>
<a name="ln1777">Status CatalogManager::CreateCDCStream(const CreateCDCStreamRequestPB* req,</a>
<a name="ln1778">                                       CreateCDCStreamResponsePB* resp,</a>
<a name="ln1779">                                       rpc::RpcContext* rpc) {</a>
<a name="ln1780">  LOG(INFO) &lt;&lt; &quot;CreateCDCStream from &quot; &lt;&lt; RequestorString(rpc)</a>
<a name="ln1781">            &lt;&lt; &quot;: &quot; &lt;&lt; req-&gt;DebugString();</a>
<a name="ln1782"> </a>
<a name="ln1783">  RETURN_NOT_OK(CheckOnline());</a>
<a name="ln1784"> </a>
<a name="ln1785">  TableIdentifierPB table_identifier;</a>
<a name="ln1786">  table_identifier.set_table_id(req-&gt;table_id());</a>
<a name="ln1787"> </a>
<a name="ln1788">  scoped_refptr&lt;TableInfo&gt; table;</a>
<a name="ln1789">  RETURN_NOT_OK(FindTable(table_identifier, &amp;table));</a>
<a name="ln1790">  if (table == nullptr) {</a>
<a name="ln1791">    return STATUS(NotFound, &quot;Table not found&quot;, req-&gt;table_id(),</a>
<a name="ln1792">                  MasterError(MasterErrorPB::OBJECT_NOT_FOUND));</a>
<a name="ln1793">  }</a>
<a name="ln1794"> </a>
<a name="ln1795">  {</a>
<a name="ln1796">    auto l = table-&gt;LockForRead();</a>
<a name="ln1797">    if (l-&gt;data().started_deleting()) {</a>
<a name="ln1798">      return STATUS(NotFound, &quot;Table does not exist&quot;, req-&gt;table_id(),</a>
<a name="ln1799">                    MasterError(MasterErrorPB::OBJECT_NOT_FOUND));</a>
<a name="ln1800">    }</a>
<a name="ln1801">  }</a>
<a name="ln1802"> </a>
<a name="ln1803">  AlterTableRequestPB alter_table_req;</a>
<a name="ln1804">  alter_table_req.mutable_table()-&gt;set_table_id(req-&gt;table_id());</a>
<a name="ln1805">  alter_table_req.set_wal_retention_secs(FLAGS_cdc_wal_retention_time_secs);</a>
<a name="ln1806">  AlterTableResponsePB alter_table_resp;</a>
<a name="ln1807">  Status s = this-&gt;AlterTable(&amp;alter_table_req, &amp;alter_table_resp, rpc);</a>
<a name="ln1808">  if (!s.ok()) {</a>
<a name="ln1809">    return STATUS(InternalError,</a>
<a name="ln1810">                  &quot;Unable to change the WAL retention time for table&quot;, req-&gt;table_id(),</a>
<a name="ln1811">                  MasterError(MasterErrorPB::INTERNAL_ERROR));</a>
<a name="ln1812">  }</a>
<a name="ln1813"> </a>
<a name="ln1814">  scoped_refptr&lt;CDCStreamInfo&gt; stream;</a>
<a name="ln1815">  {</a>
<a name="ln1816">    TRACE(&quot;Acquired catalog manager lock&quot;);</a>
<a name="ln1817">    std::lock_guard&lt;LockType&gt; l(lock_);</a>
<a name="ln1818"> </a>
<a name="ln1819">    // Construct the CDC stream if the producer wasn't bootstrapped.</a>
<a name="ln1820">    CDCStreamId stream_id;</a>
<a name="ln1821">    stream_id = GenerateIdUnlocked(SysRowEntry::CDC_STREAM);</a>
<a name="ln1822"> </a>
<a name="ln1823">    stream = make_scoped_refptr&lt;CDCStreamInfo&gt;(stream_id);</a>
<a name="ln1824">    stream-&gt;mutable_metadata()-&gt;StartMutation();</a>
<a name="ln1825">    SysCDCStreamEntryPB *metadata = &amp;stream-&gt;mutable_metadata()-&gt;mutable_dirty()-&gt;pb;</a>
<a name="ln1826">    metadata-&gt;set_table_id(table-&gt;id());</a>
<a name="ln1827">    metadata-&gt;mutable_options()-&gt;CopyFrom(req-&gt;options());</a>
<a name="ln1828"> </a>
<a name="ln1829">    // Add the stream to the in-memory map.</a>
<a name="ln1830">    cdc_stream_map_[stream-&gt;id()] = stream;</a>
<a name="ln1831">    resp-&gt;set_stream_id(stream-&gt;id());</a>
<a name="ln1832">  }</a>
<a name="ln1833">  TRACE(&quot;Inserted new CDC stream into CatalogManager maps&quot;);</a>
<a name="ln1834"> </a>
<a name="ln1835">  // Update the on-disk system catalog.</a>
<a name="ln1836">  RETURN_NOT_OK(CheckLeaderStatusAndSetupError(</a>
<a name="ln1837">      sys_catalog_-&gt;AddItem(stream.get(), leader_ready_term()),</a>
<a name="ln1838">      &quot;inserting CDC stream into sys-catalog&quot;, resp));</a>
<a name="ln1839">  TRACE(&quot;Wrote CDC stream to sys-catalog&quot;);</a>
<a name="ln1840"> </a>
<a name="ln1841">  // Commit the in-memory state.</a>
<a name="ln1842">  stream-&gt;mutable_metadata()-&gt;CommitMutation();</a>
<a name="ln1843">  LOG(INFO) &lt;&lt; &quot;Created CDC stream &quot; &lt;&lt; stream-&gt;ToString();</a>
<a name="ln1844"> </a>
<a name="ln1845">  RETURN_NOT_OK(CreateCdcStateTableIfNeeded(rpc));</a>
<a name="ln1846">  return Status::OK();</a>
<a name="ln1847">}</a>
<a name="ln1848"> </a>
<a name="ln1849">Status CatalogManager::DeleteCDCStream(const DeleteCDCStreamRequestPB* req,</a>
<a name="ln1850">                                       DeleteCDCStreamResponsePB* resp,</a>
<a name="ln1851">                                       rpc::RpcContext* rpc) {</a>
<a name="ln1852">  LOG(INFO) &lt;&lt; &quot;Servicing DeleteCDCStream request from &quot; &lt;&lt; RequestorString(rpc)</a>
<a name="ln1853">            &lt;&lt; &quot;: &quot; &lt;&lt; req-&gt;ShortDebugString();</a>
<a name="ln1854"> </a>
<a name="ln1855">  RETURN_NOT_OK(CheckOnline());</a>
<a name="ln1856"> </a>
<a name="ln1857">  if (req-&gt;stream_id_size() &lt; 1) {</a>
<a name="ln1858">    return STATUS(InvalidArgument, &quot;No CDC Stream ID given&quot;, req-&gt;ShortDebugString(),</a>
<a name="ln1859">                  MasterError(MasterErrorPB::INVALID_REQUEST));</a>
<a name="ln1860">  }</a>
<a name="ln1861"> </a>
<a name="ln1862">  std::vector&lt;scoped_refptr&lt;CDCStreamInfo&gt;&gt; streams;</a>
<a name="ln1863">  {</a>
<a name="ln1864">    std::shared_lock&lt;LockType&gt; l(lock_);</a>
<a name="ln1865">    for (const auto&amp; stream_id : req-&gt;stream_id()) {</a>
<a name="ln1866">      auto stream = FindPtrOrNull(cdc_stream_map_, stream_id);</a>
<a name="ln1867"> </a>
<a name="ln1868">      if (stream == nullptr || stream-&gt;LockForRead()-&gt;data().is_deleting()) {</a>
<a name="ln1869">        return STATUS(NotFound, &quot;CDC stream does not exist&quot;, req-&gt;ShortDebugString(),</a>
<a name="ln1870">                      MasterError(MasterErrorPB::OBJECT_NOT_FOUND));</a>
<a name="ln1871">      }</a>
<a name="ln1872">      streams.push_back(stream);</a>
<a name="ln1873">    }</a>
<a name="ln1874">  }</a>
<a name="ln1875"> </a>
<a name="ln1876">  // Do not delete them here, just mark them as DELETING and the catalog manager background thread</a>
<a name="ln1877">  // will handle the deletion.</a>
<a name="ln1878">  Status s = MarkCDCStreamsAsDeleting(streams);</a>
<a name="ln1879">  if (!s.ok()) {</a>
<a name="ln1880">    if (s.IsIllegalState()) {</a>
<a name="ln1881">      PANIC_RPC(rpc, s.message().ToString());</a>
<a name="ln1882">    }</a>
<a name="ln1883">    return CheckIfNoLongerLeaderAndSetupError(s, resp);</a>
<a name="ln1884">  }</a>
<a name="ln1885"> </a>
<a name="ln1886">  LOG(INFO) &lt;&lt; &quot;Successfully deleted CDC streams &quot; &lt;&lt; JoinStreamsCSVLine(streams)</a>
<a name="ln1887">            &lt;&lt; &quot; per request from &quot; &lt;&lt; RequestorString(rpc);</a>
<a name="ln1888"> </a>
<a name="ln1889">  return Status::OK();</a>
<a name="ln1890">}</a>
<a name="ln1891"> </a>
<a name="ln1892">Status CatalogManager::MarkCDCStreamsAsDeleting(</a>
<a name="ln1893">    const std::vector&lt;scoped_refptr&lt;CDCStreamInfo&gt;&gt;&amp; streams) {</a>
<a name="ln1894">  std::vector&lt;std::unique_ptr&lt;CDCStreamInfo::lock_type&gt;&gt; locks;</a>
<a name="ln1895">  std::vector&lt;CDCStreamInfo*&gt; streams_to_mark;</a>
<a name="ln1896">  locks.reserve(streams.size());</a>
<a name="ln1897">  for (auto&amp; stream : streams) {</a>
<a name="ln1898">    auto l = stream-&gt;LockForWrite();</a>
<a name="ln1899">    l-&gt;mutable_data()-&gt;pb.set_state(SysCDCStreamEntryPB::DELETING);</a>
<a name="ln1900">    locks.push_back(std::move(l));</a>
<a name="ln1901">    streams_to_mark.push_back(stream.get());</a>
<a name="ln1902">  }</a>
<a name="ln1903">  // The mutation will be aborted when 'l' exits the scope on early return.</a>
<a name="ln1904">  RETURN_NOT_OK(CheckStatus(</a>
<a name="ln1905">      sys_catalog_-&gt;UpdateItems(streams_to_mark, leader_ready_term()),</a>
<a name="ln1906">      &quot;updating CDC streams in sys-catalog&quot;));</a>
<a name="ln1907">  LOG(INFO) &lt;&lt; &quot;Successfully marked streams &quot; &lt;&lt; JoinStreamsCSVLine(streams_to_mark)</a>
<a name="ln1908">            &lt;&lt; &quot; as DELETING in sys catalog&quot;;</a>
<a name="ln1909">  for (auto&amp; lock : locks) {</a>
<a name="ln1910">    lock-&gt;Commit();</a>
<a name="ln1911">  }</a>
<a name="ln1912">  return Status::OK();</a>
<a name="ln1913">}</a>
<a name="ln1914"> </a>
<a name="ln1915">Status CatalogManager::FindCDCStreamsMarkedAsDeleting(</a>
<a name="ln1916">    std::vector&lt;scoped_refptr&lt;CDCStreamInfo&gt;&gt;* streams) {</a>
<a name="ln1917">  TRACE(&quot;Acquired catalog manager lock&quot;);</a>
<a name="ln1918">  std::shared_lock&lt;LockType&gt; l(lock_);</a>
<a name="ln1919">  for (const CDCStreamInfoMap::value_type&amp; entry : cdc_stream_map_) {</a>
<a name="ln1920">    auto ltm = entry.second-&gt;LockForRead();</a>
<a name="ln1921">    if (ltm-&gt;data().is_deleting()) {</a>
<a name="ln1922">      LOG(INFO) &lt;&lt; &quot;Stream &quot; &lt;&lt; entry.second-&gt;id() &lt;&lt; &quot; was marked as DELETING&quot;;</a>
<a name="ln1923">      streams-&gt;push_back(entry.second);</a>
<a name="ln1924">    }</a>
<a name="ln1925">  }</a>
<a name="ln1926">  return Status::OK();</a>
<a name="ln1927">}</a>
<a name="ln1928"> </a>
<a name="ln1929">Status CatalogManager::CleanUpDeletedCDCStreams(</a>
<a name="ln1930">    const std::vector&lt;scoped_refptr&lt;CDCStreamInfo&gt;&gt;&amp; streams) {</a>
<a name="ln1931">  RETURN_NOT_OK(CheckOnline());</a>
<a name="ln1932"> </a>
<a name="ln1933">  if (!cdc_ybclient_) {</a>
<a name="ln1934">    // First. For each deleted stream, delete the cdc state rows.</a>
<a name="ln1935">    std::vector&lt;std::string&gt; addrs;</a>
<a name="ln1936">    for (auto const&amp; master_address : *master_-&gt;opts().GetMasterAddresses()) {</a>
<a name="ln1937">      for (auto const&amp; host_port : master_address) {</a>
<a name="ln1938">        addrs.push_back(host_port.ToString());</a>
<a name="ln1939">      }</a>
<a name="ln1940">    }</a>
<a name="ln1941">    if (addrs.empty()) {</a>
<a name="ln1942">      YB_LOG_EVERY_N_SECS(ERROR, 30) &lt;&lt; &quot;Unable to get master addresses for yb client&quot;;</a>
<a name="ln1943">      return STATUS(InternalError, &quot;Unable to get master address for yb client&quot;);</a>
<a name="ln1944">    }</a>
<a name="ln1945">    LOG(INFO) &lt;&lt; &quot;Using master addresses &quot; &lt;&lt; JoinCSVLine(addrs) &lt;&lt; &quot; to create cdc yb client&quot;;</a>
<a name="ln1946">    auto result = yb::client::YBClientBuilder()</a>
<a name="ln1947">        .master_server_addrs(addrs)</a>
<a name="ln1948">        .default_admin_operation_timeout(MonoDelta::FromMilliseconds(FLAGS_master_rpc_timeout_ms))</a>
<a name="ln1949">        .Build();</a>
<a name="ln1950"> </a>
<a name="ln1951">    std::unique_ptr&lt;client::YBClient&gt; client;</a>
<a name="ln1952">    if (!result.ok()) {</a>
<a name="ln1953">      YB_LOG_EVERY_N_SECS(ERROR, 30) &lt;&lt; &quot;Unable to create client: &quot; &lt;&lt; result.status();</a>
<a name="ln1954">      return result.status().CloneAndPrepend(&quot;Unable to create yb client&quot;);</a>
<a name="ln1955">    } else {</a>
<a name="ln1956">      cdc_ybclient_ = std::move(*result);</a>
<a name="ln1957">    }</a>
<a name="ln1958">  }</a>
<a name="ln1959"> </a>
<a name="ln1960">  // Delete all the entries in cdc_state table that contain all the deleted cdc streams.</a>
<a name="ln1961">  client::TableHandle cdc_table;</a>
<a name="ln1962">  const client::YBTableName cdc_state_table_name(</a>
<a name="ln1963">      YQL_DATABASE_CQL, master::kSystemNamespaceName, master::kCdcStateTableName);</a>
<a name="ln1964">  Status s = cdc_table.Open(cdc_state_table_name, cdc_ybclient_.get());</a>
<a name="ln1965">  if (!s.ok()) {</a>
<a name="ln1966">    LOG(WARNING) &lt;&lt; &quot;Unable to open table &quot; &lt;&lt; master::kCdcStateTableName</a>
<a name="ln1967">                 &lt;&lt; &quot; to delete stream ids entries: &quot; &lt;&lt; s;</a>
<a name="ln1968">    return s.CloneAndPrepend(&quot;Unable to open cdc_state table&quot;);</a>
<a name="ln1969">  }</a>
<a name="ln1970"> </a>
<a name="ln1971">  std::shared_ptr&lt;client::YBSession&gt; session = cdc_ybclient_-&gt;NewSession();</a>
<a name="ln1972">  std::vector&lt;std::pair&lt;CDCStreamId, std::shared_ptr&lt;client::YBqlWriteOp&gt;&gt;&gt; stream_ops;</a>
<a name="ln1973">  std::set&lt;CDCStreamId&gt; failed_streams;</a>
<a name="ln1974">  for (const auto&amp; stream : streams) {</a>
<a name="ln1975">    LOG(INFO) &lt;&lt; &quot;Deleting rows for stream &quot; &lt;&lt; stream-&gt;id();</a>
<a name="ln1976">    vector&lt;scoped_refptr&lt;TabletInfo&gt;&gt; tablets;</a>
<a name="ln1977">    scoped_refptr&lt;TableInfo&gt; table;</a>
<a name="ln1978">    {</a>
<a name="ln1979">      TRACE(&quot;Acquired catalog manager lock&quot;);</a>
<a name="ln1980">      SharedLock&lt;LockType&gt; l(lock_);</a>
<a name="ln1981">      table = FindPtrOrNull(*table_ids_map_, stream-&gt;table_id());</a>
<a name="ln1982">    }</a>
<a name="ln1983">    // GetAllTablets locks lock_ in shared mode.</a>
<a name="ln1984">    if (table) {</a>
<a name="ln1985">      table-&gt;GetAllTablets(&amp;tablets);</a>
<a name="ln1986">    }</a>
<a name="ln1987"> </a>
<a name="ln1988">    for (const auto&amp; tablet : tablets) {</a>
<a name="ln1989">      const auto delete_op = cdc_table.NewDeleteOp();</a>
<a name="ln1990">      auto* delete_req = delete_op-&gt;mutable_request();</a>
<a name="ln1991"> </a>
<a name="ln1992">      QLAddStringHashValue(delete_req, tablet-&gt;tablet_id());</a>
<a name="ln1993">      QLAddStringRangeValue(delete_req, stream-&gt;id());</a>
<a name="ln1994">      s = session-&gt;Apply(delete_op);</a>
<a name="ln1995">      stream_ops.push_back(std::make_pair(stream-&gt;id(), delete_op));</a>
<a name="ln1996">      LOG(INFO) &lt;&lt; &quot;Deleting stream &quot; &lt;&lt; stream-&gt;id() &lt;&lt; &quot; for tablet &quot; &lt;&lt; tablet-&gt;tablet_id()</a>
<a name="ln1997">              &lt;&lt; &quot; with request &quot; &lt;&lt; delete_req-&gt;ShortDebugString();</a>
<a name="ln1998">      if (!s.ok()) {</a>
<a name="ln1999">        LOG(WARNING) &lt;&lt; &quot;Unable to delete stream with id &quot;</a>
<a name="ln2000">                     &lt;&lt; stream-&gt;id() &lt;&lt; &quot; from table &quot; &lt;&lt; master::kCdcStateTableName</a>
<a name="ln2001">                     &lt;&lt; &quot; for tablet &quot; &lt;&lt; tablet-&gt;tablet_id()</a>
<a name="ln2002">                     &lt;&lt; &quot;. Status: &quot; &lt;&lt; s</a>
<a name="ln2003">                     &lt;&lt; &quot;, Response: &quot; &lt;&lt; delete_op-&gt;response().ShortDebugString();</a>
<a name="ln2004">      }</a>
<a name="ln2005">    }</a>
<a name="ln2006">  }</a>
<a name="ln2007">  // Flush all the delete operations.</a>
<a name="ln2008">  s = session-&gt;Flush();</a>
<a name="ln2009">  if (!s.ok()) {</a>
<a name="ln2010">    LOG(ERROR) &lt;&lt; &quot;Unable to flush operations to delete cdc streams: &quot; &lt;&lt; s;</a>
<a name="ln2011">    return s.CloneAndPrepend(&quot;Error deleting cdc stream rows from cdc_state table&quot;);</a>
<a name="ln2012">  }</a>
<a name="ln2013"> </a>
<a name="ln2014">  for (const auto&amp; e : stream_ops) {</a>
<a name="ln2015">    if (!e.second-&gt;succeeded()) {</a>
<a name="ln2016">      LOG(WARNING) &lt;&lt; &quot;Error deleting cdc_state row with tablet id &quot;</a>
<a name="ln2017">                   &lt;&lt; e.second-&gt;request().hashed_column_values(0).value().string_value()</a>
<a name="ln2018">                   &lt;&lt; &quot; and stream id &quot;</a>
<a name="ln2019">                   &lt;&lt; e.second-&gt;request().range_column_values(0).value().string_value()</a>
<a name="ln2020">                   &lt;&lt; &quot;: &quot; &lt;&lt; e.second-&gt;response().status();</a>
<a name="ln2021">      failed_streams.insert(e.first);</a>
<a name="ln2022">    }</a>
<a name="ln2023">  }</a>
<a name="ln2024"> </a>
<a name="ln2025">  // TODO: Read cdc_state table and verify that there are not rows with the specified cdc stream</a>
<a name="ln2026">  // and keep those in the map in the DELETED state to retry later.</a>
<a name="ln2027"> </a>
<a name="ln2028">  std::vector&lt;std::unique_ptr&lt;CDCStreamInfo::lock_type&gt;&gt; locks;</a>
<a name="ln2029">  locks.reserve(streams.size() - failed_streams.size());</a>
<a name="ln2030">  std::vector&lt;CDCStreamInfo*&gt; streams_to_delete;</a>
<a name="ln2031">  streams_to_delete.reserve(streams.size() - failed_streams.size());</a>
<a name="ln2032"> </a>
<a name="ln2033">  // Delete from sys catalog only those streams that were successfully delete from cdc_state.</a>
<a name="ln2034">  for (auto&amp; stream : streams) {</a>
<a name="ln2035">    if (failed_streams.find(stream-&gt;id()) == failed_streams.end()) {</a>
<a name="ln2036">      locks.push_back(stream-&gt;LockForWrite());</a>
<a name="ln2037">      streams_to_delete.push_back(stream.get());</a>
<a name="ln2038">    }</a>
<a name="ln2039">  }</a>
<a name="ln2040"> </a>
<a name="ln2041">  // The mutation will be aborted when 'l' exits the scope on early return.</a>
<a name="ln2042">  RETURN_NOT_OK(CheckStatus(</a>
<a name="ln2043">      sys_catalog_-&gt;DeleteItems(streams_to_delete, leader_ready_term()),</a>
<a name="ln2044">      &quot;deleting CDC streams from sys-catalog&quot;));</a>
<a name="ln2045">  LOG(INFO) &lt;&lt; &quot;Successfully deleted streams &quot; &lt;&lt; JoinStreamsCSVLine(streams_to_delete)</a>
<a name="ln2046">            &lt;&lt; &quot; from sys catalog&quot;;</a>
<a name="ln2047"> </a>
<a name="ln2048">  // Remove it from the map.</a>
<a name="ln2049">  TRACE(&quot;Removing from CDC stream maps&quot;);</a>
<a name="ln2050">  {</a>
<a name="ln2051">    std::lock_guard&lt;LockType&gt; l(lock_);</a>
<a name="ln2052">    for (const auto&amp; stream : streams_to_delete) {</a>
<a name="ln2053">      if (cdc_stream_map_.erase(stream-&gt;id()) &lt; 1) {</a>
<a name="ln2054">        return STATUS(IllegalState, &quot;Could not remove CDC stream from map&quot;, stream-&gt;id());</a>
<a name="ln2055">      }</a>
<a name="ln2056">    }</a>
<a name="ln2057">  }</a>
<a name="ln2058">  LOG(INFO) &lt;&lt; &quot;Successfully deleted streams &quot; &lt;&lt; JoinStreamsCSVLine(streams_to_delete)</a>
<a name="ln2059">            &lt;&lt; &quot; from stream map&quot;;</a>
<a name="ln2060"> </a>
<a name="ln2061">  for (auto&amp; lock : locks) {</a>
<a name="ln2062">    lock-&gt;Commit();</a>
<a name="ln2063">  }</a>
<a name="ln2064">  return Status::OK();</a>
<a name="ln2065">}</a>
<a name="ln2066"> </a>
<a name="ln2067">Status CatalogManager::GetCDCStream(const GetCDCStreamRequestPB* req,</a>
<a name="ln2068">                                    GetCDCStreamResponsePB* resp,</a>
<a name="ln2069">                                    rpc::RpcContext* rpc) {</a>
<a name="ln2070">  LOG(INFO) &lt;&lt; &quot;GetCDCStream from &quot; &lt;&lt; RequestorString(rpc)</a>
<a name="ln2071">            &lt;&lt; &quot;: &quot; &lt;&lt; req-&gt;DebugString();</a>
<a name="ln2072">  RETURN_NOT_OK(CheckOnline());</a>
<a name="ln2073"> </a>
<a name="ln2074"> </a>
<a name="ln2075">  if (!req-&gt;has_stream_id()) {</a>
<a name="ln2076">    return STATUS(InvalidArgument, &quot;CDC Stream ID must be provided&quot;, req-&gt;ShortDebugString(),</a>
<a name="ln2077">                  MasterError(MasterErrorPB::INVALID_REQUEST));</a>
<a name="ln2078">  }</a>
<a name="ln2079"> </a>
<a name="ln2080">  scoped_refptr&lt;CDCStreamInfo&gt; stream;</a>
<a name="ln2081">  {</a>
<a name="ln2082">    std::shared_lock&lt;LockType&gt; l(lock_);</a>
<a name="ln2083">    stream = FindPtrOrNull(cdc_stream_map_, req-&gt;stream_id());</a>
<a name="ln2084">  }</a>
<a name="ln2085"> </a>
<a name="ln2086">  if (stream == nullptr || stream-&gt;LockForRead()-&gt;data().is_deleting()) {</a>
<a name="ln2087">    return STATUS(NotFound, &quot;Could not find CDC stream&quot;, req-&gt;ShortDebugString(),</a>
<a name="ln2088">                  MasterError(MasterErrorPB::OBJECT_NOT_FOUND));</a>
<a name="ln2089">  }</a>
<a name="ln2090"> </a>
<a name="ln2091">  auto stream_lock = stream-&gt;LockForRead();</a>
<a name="ln2092"> </a>
<a name="ln2093">  CDCStreamInfoPB* stream_info = resp-&gt;mutable_stream();</a>
<a name="ln2094"> </a>
<a name="ln2095">  stream_info-&gt;set_stream_id(stream-&gt;id());</a>
<a name="ln2096">  stream_info-&gt;set_table_id(stream_lock-&gt;data().table_id());</a>
<a name="ln2097">  stream_info-&gt;mutable_options()-&gt;CopyFrom(stream_lock-&gt;data().options());</a>
<a name="ln2098"> </a>
<a name="ln2099">  return Status::OK();</a>
<a name="ln2100">}</a>
<a name="ln2101"> </a>
<a name="ln2102">Status CatalogManager::ListCDCStreams(const ListCDCStreamsRequestPB* req,</a>
<a name="ln2103">                                      ListCDCStreamsResponsePB* resp) {</a>
<a name="ln2104"> </a>
<a name="ln2105">  RETURN_NOT_OK(CheckOnline());</a>
<a name="ln2106"> </a>
<a name="ln2107">  scoped_refptr&lt;TableInfo&gt; table;</a>
<a name="ln2108">  bool filter_table = req-&gt;has_table_id();</a>
<a name="ln2109">  if (filter_table) {</a>
<a name="ln2110">    // Lookup the table and verify that it exists.</a>
<a name="ln2111">    TableIdentifierPB table_identifier;</a>
<a name="ln2112">    table_identifier.set_table_id(req-&gt;table_id());</a>
<a name="ln2113"> </a>
<a name="ln2114">    RETURN_NOT_OK(FindTable(table_identifier, &amp;table));</a>
<a name="ln2115">    if (table == nullptr) {</a>
<a name="ln2116">      return STATUS(NotFound, &quot;Table not found&quot;, req-&gt;table_id(),</a>
<a name="ln2117">                    MasterError(MasterErrorPB::OBJECT_NOT_FOUND));</a>
<a name="ln2118">    }</a>
<a name="ln2119">  }</a>
<a name="ln2120"> </a>
<a name="ln2121">  std::shared_lock&lt;LockType&gt; l(lock_);</a>
<a name="ln2122"> </a>
<a name="ln2123">  for (const CDCStreamInfoMap::value_type&amp; entry : cdc_stream_map_) {</a>
<a name="ln2124">    auto ltm = entry.second-&gt;LockForRead();</a>
<a name="ln2125"> </a>
<a name="ln2126">    if ((filter_table &amp;&amp; table-&gt;id() != ltm-&gt;data().table_id()) || ltm-&gt;data().is_deleting()) {</a>
<a name="ln2127">      continue; // Skip deleting/deleted streams and streams from other tables.</a>
<a name="ln2128">    }</a>
<a name="ln2129"> </a>
<a name="ln2130">    CDCStreamInfoPB* stream = resp-&gt;add_streams();</a>
<a name="ln2131">    stream-&gt;set_stream_id(entry.second-&gt;id());</a>
<a name="ln2132">    stream-&gt;set_table_id(ltm-&gt;data().table_id());</a>
<a name="ln2133">    stream-&gt;mutable_options()-&gt;CopyFrom(ltm-&gt;data().options());</a>
<a name="ln2134">  }</a>
<a name="ln2135">  return Status::OK();</a>
<a name="ln2136">}</a>
<a name="ln2137"> </a>
<a name="ln2138">bool CatalogManager::CDCStreamExistsUnlocked(const CDCStreamId&amp; stream_id) {</a>
<a name="ln2139">  LOG_IF(DFATAL, !lock_.is_locked()) &lt;&lt; &quot;CatalogManager lock must be taken&quot;;</a>
<a name="ln2140">  scoped_refptr&lt;CDCStreamInfo&gt; stream = FindPtrOrNull(cdc_stream_map_, stream_id);</a>
<a name="ln2141">  if (stream == nullptr || stream-&gt;LockForRead()-&gt;data().is_deleting()) {</a>
<a name="ln2142">    return false;</a>
<a name="ln2143">  }</a>
<a name="ln2144">  return true;</a>
<a name="ln2145">}</a>
<a name="ln2146"> </a>
<a name="ln2147">/*</a>
<a name="ln2148"> * UniverseReplication is setup in 4 stages within the Catalog Manager</a>
<a name="ln2149"> * 1. SetupUniverseReplication: Validates user input &amp; requests Producer schema.</a>
<a name="ln2150"> * 2. GetTableSchemaCallback:   Validates Schema compatibility &amp; requests Producer CDC init.</a>
<a name="ln2151"> * 3. AddCDCStreamToUniverseAndInitConsumer:  Setup RPC connections for CDC Streaming</a>
<a name="ln2152"> * 4. InitCDCConsumer:          Initializes the Consumer settings to begin tailing data</a>
<a name="ln2153"> */</a>
<a name="ln2154">Status CatalogManager::SetupUniverseReplication(const SetupUniverseReplicationRequestPB* req,</a>
<a name="ln2155">                                                SetupUniverseReplicationResponsePB* resp,</a>
<a name="ln2156">                                                rpc::RpcContext* rpc) {</a>
<a name="ln2157">  LOG(INFO) &lt;&lt; &quot;SetupUniverseReplication from &quot; &lt;&lt; RequestorString(rpc)</a>
<a name="ln2158">            &lt;&lt; &quot;: &quot; &lt;&lt; req-&gt;DebugString();</a>
<a name="ln2159"> </a>
<a name="ln2160">  // Sanity checking section.</a>
<a name="ln2161">  RETURN_NOT_OK(CheckOnline());</a>
<a name="ln2162"> </a>
<a name="ln2163">  if (!req-&gt;has_producer_id()) {</a>
<a name="ln2164">    return STATUS(InvalidArgument, &quot;Producer universe ID must be provided&quot;,</a>
<a name="ln2165">                  req-&gt;ShortDebugString(), MasterError(MasterErrorPB::INVALID_REQUEST));</a>
<a name="ln2166">  }</a>
<a name="ln2167"> </a>
<a name="ln2168">  if (req-&gt;producer_master_addresses_size() &lt;= 0) {</a>
<a name="ln2169">    return STATUS(InvalidArgument, &quot;Producer master address must be provided&quot;,</a>
<a name="ln2170">                  req-&gt;ShortDebugString(), MasterError(MasterErrorPB::INVALID_REQUEST));</a>
<a name="ln2171">  }</a>
<a name="ln2172"> </a>
<a name="ln2173">  if (req-&gt;producer_bootstrap_ids().size() &gt; 0 &amp;&amp;</a>
<a name="ln2174">      req-&gt;producer_bootstrap_ids().size() != req-&gt;producer_table_ids().size()) {</a>
<a name="ln2175">    return STATUS(InvalidArgument, &quot;Number of bootstrap ids must be equal to number of tables&quot;,</a>
<a name="ln2176">                  req-&gt;ShortDebugString(), MasterError(MasterErrorPB::INVALID_REQUEST));</a>
<a name="ln2177">  }</a>
<a name="ln2178"> </a>
<a name="ln2179">  std::unordered_map&lt;TableId, std::string&gt; table_id_to_bootstrap_id;</a>
<a name="ln2180"> </a>
<a name="ln2181">  if (req-&gt;producer_bootstrap_ids_size() &gt; 0) {</a>
<a name="ln2182">    for (int i = 0; i &lt; req-&gt;producer_table_ids().size(); i++) {</a>
<a name="ln2183">      table_id_to_bootstrap_id[req-&gt;producer_table_ids(i)] = req-&gt;producer_bootstrap_ids(i);</a>
<a name="ln2184">    }</a>
<a name="ln2185">  }</a>
<a name="ln2186"> </a>
<a name="ln2187">  // We assume that the list of table ids is unique.</a>
<a name="ln2188">  if (req-&gt;producer_bootstrap_ids().size() &gt; 0 &amp;&amp;</a>
<a name="ln2189">      req-&gt;producer_table_ids().size() != table_id_to_bootstrap_id.size()) {</a>
<a name="ln2190">    return STATUS(InvalidArgument, &quot;When providing bootstrap ids, &quot;</a>
<a name="ln2191">                  &quot;the list of tables must be unique&quot;, req-&gt;ShortDebugString(),</a>
<a name="ln2192">                  MasterError(MasterErrorPB::INVALID_REQUEST));</a>
<a name="ln2193">  }</a>
<a name="ln2194"> </a>
<a name="ln2195">  scoped_refptr&lt;UniverseReplicationInfo&gt; ri;</a>
<a name="ln2196">  {</a>
<a name="ln2197">    TRACE(&quot;Acquired catalog manager lock&quot;);</a>
<a name="ln2198">    std::shared_lock&lt;LockType&gt; l(lock_);</a>
<a name="ln2199"> </a>
<a name="ln2200">    if (FindPtrOrNull(universe_replication_map_, req-&gt;producer_id()) != nullptr) {</a>
<a name="ln2201">      return STATUS(InvalidArgument, &quot;Producer already present&quot;, req-&gt;producer_id(),</a>
<a name="ln2202">                    MasterError(MasterErrorPB::INVALID_REQUEST));</a>
<a name="ln2203">    }</a>
<a name="ln2204">  }</a>
<a name="ln2205"> </a>
<a name="ln2206">  // Create an entry in the system catalog DocDB for this new universe replication.</a>
<a name="ln2207">  ri = new UniverseReplicationInfo(req-&gt;producer_id());</a>
<a name="ln2208">  ri-&gt;mutable_metadata()-&gt;StartMutation();</a>
<a name="ln2209">  SysUniverseReplicationEntryPB *metadata = &amp;ri-&gt;mutable_metadata()-&gt;mutable_dirty()-&gt;pb;</a>
<a name="ln2210">  metadata-&gt;set_producer_id(req-&gt;producer_id());</a>
<a name="ln2211">  metadata-&gt;mutable_producer_master_addresses()-&gt;CopyFrom(req-&gt;producer_master_addresses());</a>
<a name="ln2212">  metadata-&gt;mutable_tables()-&gt;CopyFrom(req-&gt;producer_table_ids());</a>
<a name="ln2213">  metadata-&gt;set_state(SysUniverseReplicationEntryPB::INITIALIZING);</a>
<a name="ln2214"> </a>
<a name="ln2215">  RETURN_NOT_OK(CheckLeaderStatusAndSetupError(</a>
<a name="ln2216">      sys_catalog_-&gt;AddItem(ri.get(), leader_ready_term()),</a>
<a name="ln2217">      &quot;inserting universe replication info into sys-catalog&quot;, resp));</a>
<a name="ln2218">  TRACE(&quot;Wrote universe replication info to sys-catalog&quot;);</a>
<a name="ln2219"> </a>
<a name="ln2220">  // Commit the in-memory state now that it's added to the persistent catalog.</a>
<a name="ln2221">  ri-&gt;mutable_metadata()-&gt;CommitMutation();</a>
<a name="ln2222">  LOG(INFO) &lt;&lt; &quot;Setup universe replication from producer &quot; &lt;&lt; ri-&gt;ToString();</a>
<a name="ln2223"> </a>
<a name="ln2224">  {</a>
<a name="ln2225">    std::lock_guard&lt;LockType&gt; l(lock_);</a>
<a name="ln2226">    universe_replication_map_[ri-&gt;id()] = ri;</a>
<a name="ln2227">  }</a>
<a name="ln2228"> </a>
<a name="ln2229">  // Initialize the CDC Stream by querying the Producer server for RPC sanity checks.</a>
<a name="ln2230">  auto result = ri-&gt;GetOrCreateCDCRpcTasks(req-&gt;producer_master_addresses());</a>
<a name="ln2231">  if (!result.ok()) {</a>
<a name="ln2232">    MarkUniverseReplicationFailed(ri);</a>
<a name="ln2233">    return result.status().CloneAndAddErrorCode(MasterError(MasterErrorPB::INVALID_REQUEST));</a>
<a name="ln2234">  }</a>
<a name="ln2235">  std::shared_ptr&lt;CDCRpcTasks&gt; cdc_rpc = *result;</a>
<a name="ln2236"> </a>
<a name="ln2237">  // For each table, run an async RPC task to verify a sufficient Producer:Consumer schema match.</a>
<a name="ln2238">  for (int i = 0; i &lt; req-&gt;producer_table_ids_size(); i++) {</a>
<a name="ln2239">    auto table_info = std::make_shared&lt;client::YBTableInfo&gt;();</a>
<a name="ln2240"> </a>
<a name="ln2241">    // SETUP CONTINUES after this async call.</a>
<a name="ln2242">    const Status s = cdc_rpc-&gt;client()-&gt;GetTableSchemaById(</a>
<a name="ln2243">        req-&gt;producer_table_ids(i), table_info,</a>
<a name="ln2244">        Bind(&amp;enterprise::CatalogManager::GetTableSchemaCallback, Unretained(this),</a>
<a name="ln2245">             ri-&gt;id(), table_info, table_id_to_bootstrap_id));</a>
<a name="ln2246">    if (!s.ok()) {</a>
<a name="ln2247">      MarkUniverseReplicationFailed(ri);</a>
<a name="ln2248">      return SetupError(resp-&gt;mutable_error(), MasterErrorPB::INVALID_REQUEST, s);</a>
<a name="ln2249">    }</a>
<a name="ln2250">  }</a>
<a name="ln2251"> </a>
<a name="ln2252">  LOG(INFO) &lt;&lt; &quot;Started schema validation for universe replication &quot; &lt;&lt; ri-&gt;ToString();</a>
<a name="ln2253">  return Status::OK();</a>
<a name="ln2254">}</a>
<a name="ln2255"> </a>
<a name="ln2256">void CatalogManager::MarkUniverseReplicationFailed(</a>
<a name="ln2257">    scoped_refptr&lt;UniverseReplicationInfo&gt; universe) {</a>
<a name="ln2258">  auto l = universe-&gt;LockForWrite();</a>
<a name="ln2259">  if (l-&gt;data().pb.state() == SysUniverseReplicationEntryPB::DELETED) {</a>
<a name="ln2260">    l-&gt;mutable_data()-&gt;pb.set_state(SysUniverseReplicationEntryPB::DELETED_ERROR);</a>
<a name="ln2261">  } else {</a>
<a name="ln2262">    l-&gt;mutable_data()-&gt;pb.set_state(SysUniverseReplicationEntryPB::FAILED);</a>
<a name="ln2263">  }</a>
<a name="ln2264"> </a>
<a name="ln2265">  // Update sys_catalog.</a>
<a name="ln2266">  const Status s = sys_catalog_-&gt;UpdateItem(universe.get(), leader_ready_term());</a>
<a name="ln2267">  if (!s.ok()) {</a>
<a name="ln2268">    return (void)CheckStatus(s, &quot;updating universe replication info in sys-catalog&quot;);</a>
<a name="ln2269">  }</a>
<a name="ln2270">  l-&gt;Commit();</a>
<a name="ln2271">}</a>
<a name="ln2272"> </a>
<a name="ln2273">void CatalogManager::GetTableSchemaCallback(</a>
<a name="ln2274">    const std::string&amp; universe_id, const std::shared_ptr&lt;client::YBTableInfo&gt;&amp; info,</a>
<a name="ln2275">    const std::unordered_map&lt;TableId, std::string&gt;&amp; table_bootstrap_ids, const Status&amp; s) {</a>
<a name="ln2276">  scoped_refptr&lt;UniverseReplicationInfo&gt; universe;</a>
<a name="ln2277">  {</a>
<a name="ln2278">    std::shared_lock&lt;LockType&gt; catalog_lock(lock_);</a>
<a name="ln2279">    TRACE(&quot;Acquired catalog manager lock&quot;);</a>
<a name="ln2280"> </a>
<a name="ln2281">    universe = FindPtrOrNull(universe_replication_map_, universe_id);</a>
<a name="ln2282">    if (universe == nullptr) {</a>
<a name="ln2283">      LOG(ERROR) &lt;&lt; &quot;Universe not found: &quot; &lt;&lt; universe_id;</a>
<a name="ln2284">      return;</a>
<a name="ln2285">    }</a>
<a name="ln2286">  }</a>
<a name="ln2287"> </a>
<a name="ln2288">  if (!s.ok()) {</a>
<a name="ln2289">    MarkUniverseReplicationFailed(universe);</a>
<a name="ln2290">    LOG(ERROR) &lt;&lt; &quot;Error getting schema for table &quot; &lt;&lt; info-&gt;table_id &lt;&lt; &quot;: &quot; &lt;&lt; s;</a>
<a name="ln2291">    return;</a>
<a name="ln2292">  }</a>
<a name="ln2293"> </a>
<a name="ln2294">  // Get corresponding table schema on local universe.</a>
<a name="ln2295">  GetTableSchemaRequestPB req;</a>
<a name="ln2296">  GetTableSchemaResponsePB resp;</a>
<a name="ln2297"> </a>
<a name="ln2298">  auto* table = req.mutable_table();</a>
<a name="ln2299">  table-&gt;set_table_name(info-&gt;table_name.table_name());</a>
<a name="ln2300">  table-&gt;mutable_namespace_()-&gt;set_name(info-&gt;table_name.namespace_name());</a>
<a name="ln2301">  table-&gt;mutable_namespace_()-&gt;set_database_type(</a>
<a name="ln2302">      GetDatabaseTypeForTable(client::YBTable::ClientToPBTableType(info-&gt;table_type)));</a>
<a name="ln2303"> </a>
<a name="ln2304">  // Since YSQL tables are not present in table map, we first need to list tables to get the table</a>
<a name="ln2305">  // ID and then get table schema.</a>
<a name="ln2306">  // Remove this once table maps are fixed for YSQL.</a>
<a name="ln2307">  ListTablesRequestPB list_req;</a>
<a name="ln2308">  ListTablesResponsePB list_resp;</a>
<a name="ln2309"> </a>
<a name="ln2310">  list_req.set_name_filter(info-&gt;table_name.table_name());</a>
<a name="ln2311">  Status status = ListTables(&amp;list_req, &amp;list_resp);</a>
<a name="ln2312">  if (!status.ok() || list_resp.has_error()) {</a>
<a name="ln2313">    LOG(ERROR) &lt;&lt; &quot;Error while listing table: &quot; &lt;&lt; status;</a>
<a name="ln2314">    MarkUniverseReplicationFailed(universe);</a>
<a name="ln2315">    return;</a>
<a name="ln2316">  }</a>
<a name="ln2317"> </a>
<a name="ln2318">  // TODO: This does not work for situation where tables in different YSQL schemas have the same</a>
<a name="ln2319">  // name. This will be fixed as part of #1476.</a>
<a name="ln2320">  for (const auto&amp; t : list_resp.tables()) {</a>
<a name="ln2321">    if (t.name() == info-&gt;table_name.table_name() &amp;&amp;</a>
<a name="ln2322">        t.namespace_().name() == info-&gt;table_name.namespace_name()) {</a>
<a name="ln2323">      table-&gt;set_table_id(t.id());</a>
<a name="ln2324">      break;</a>
<a name="ln2325">    }</a>
<a name="ln2326">  }</a>
<a name="ln2327"> </a>
<a name="ln2328">  if (!table-&gt;has_table_id()) {</a>
<a name="ln2329">    LOG(ERROR) &lt;&lt; &quot;Could not find matching table for &quot; &lt;&lt; info-&gt;table_name.ToString();</a>
<a name="ln2330">    MarkUniverseReplicationFailed(universe);</a>
<a name="ln2331">    return;</a>
<a name="ln2332">  }</a>
<a name="ln2333"> </a>
<a name="ln2334">  // We have a table match.  Now get the table schema and validate</a>
<a name="ln2335">  status = GetTableSchema(&amp;req, &amp;resp);</a>
<a name="ln2336">  if (!status.ok() || resp.has_error()) {</a>
<a name="ln2337">    LOG(ERROR) &lt;&lt; &quot;Error while getting table schema: &quot; &lt;&lt; status;</a>
<a name="ln2338">    MarkUniverseReplicationFailed(universe);</a>
<a name="ln2339">    return;</a>
<a name="ln2340">  }</a>
<a name="ln2341"> </a>
<a name="ln2342">  auto result = info-&gt;schema.EquivalentForDataCopy(resp.schema());</a>
<a name="ln2343">  if (!result.ok() || !*result) {</a>
<a name="ln2344">    LOG(ERROR) &lt;&lt; &quot;Source and target schemas don't match: Source: &quot; &lt;&lt; info-&gt;table_id</a>
<a name="ln2345">               &lt;&lt; &quot;, Target: &quot; &lt;&lt; resp.identifier().table_id()</a>
<a name="ln2346">               &lt;&lt; &quot;, Source schema: &quot; &lt;&lt; info-&gt;schema.ToString()</a>
<a name="ln2347">               &lt;&lt; &quot;, Target schema: &quot; &lt;&lt; resp.schema().DebugString();</a>
<a name="ln2348">    MarkUniverseReplicationFailed(universe);</a>
<a name="ln2349">    return;</a>
<a name="ln2350">  }</a>
<a name="ln2351"> </a>
<a name="ln2352">  auto l = universe-&gt;LockForWrite();</a>
<a name="ln2353">  auto master_addresses = l-&gt;data().pb.producer_master_addresses();</a>
<a name="ln2354"> </a>
<a name="ln2355">  auto res = universe-&gt;GetOrCreateCDCRpcTasks(master_addresses);</a>
<a name="ln2356">  if (!res.ok()) {</a>
<a name="ln2357">    LOG(ERROR) &lt;&lt; &quot;Error while setting up client for producer &quot; &lt;&lt; universe-&gt;id();</a>
<a name="ln2358">    l-&gt;mutable_data()-&gt;pb.set_state(SysUniverseReplicationEntryPB::FAILED);</a>
<a name="ln2359"> </a>
<a name="ln2360">    const Status s = sys_catalog_-&gt;UpdateItem(universe.get(), leader_ready_term());</a>
<a name="ln2361">    if (!s.ok()) {</a>
<a name="ln2362">      return (void)CheckStatus(s, &quot;updating universe replication info in sys-catalog&quot;);</a>
<a name="ln2363">    }</a>
<a name="ln2364">    l-&gt;Commit();</a>
<a name="ln2365">    return;</a>
<a name="ln2366">  }</a>
<a name="ln2367">  std::shared_ptr&lt;CDCRpcTasks&gt; cdc_rpc = *res;</a>
<a name="ln2368">  vector&lt;TableId&gt; validated_tables;</a>
<a name="ln2369"> </a>
<a name="ln2370">  if (l-&gt;data().is_deleted_or_failed()) {</a>
<a name="ln2371">    // Nothing to do since universe is being deleted.</a>
<a name="ln2372">    return;</a>
<a name="ln2373">  }</a>
<a name="ln2374"> </a>
<a name="ln2375">  auto map = l-&gt;mutable_data()-&gt;pb.mutable_validated_tables();</a>
<a name="ln2376">  (*map)[info-&gt;table_id] = resp.identifier().table_id();</a>
<a name="ln2377"> </a>
<a name="ln2378">  // Now, all tables are validated.</a>
<a name="ln2379">  if (l-&gt;mutable_data()-&gt;pb.validated_tables_size() == l-&gt;mutable_data()-&gt;pb.tables_size()) {</a>
<a name="ln2380">    l-&gt;mutable_data()-&gt;pb.set_state(SysUniverseReplicationEntryPB::VALIDATED);</a>
<a name="ln2381">    auto tbl_iter = l-&gt;data().pb.tables();</a>
<a name="ln2382">    validated_tables.insert(validated_tables.begin(), tbl_iter.begin(), tbl_iter.end());</a>
<a name="ln2383">  }</a>
<a name="ln2384"> </a>
<a name="ln2385">  // TODO: end of config validation should be where SetupUniverseReplication exits back to user</a>
<a name="ln2386">  LOG(INFO) &lt;&lt; &quot;UpdateItem in GetTableSchemaCallback&quot;;</a>
<a name="ln2387"> </a>
<a name="ln2388">  // Update sys_catalog.</a>
<a name="ln2389">  status = sys_catalog_-&gt;UpdateItem(universe.get(), leader_ready_term());</a>
<a name="ln2390">  if (!status.ok()) {</a>
<a name="ln2391">    return (void)CheckStatus(status, &quot;updating universe replication info in sys-catalog&quot;);</a>
<a name="ln2392">  }</a>
<a name="ln2393">  l-&gt;Commit();</a>
<a name="ln2394"> </a>
<a name="ln2395">  // Create CDC stream for each validated table, after persisting the replication state change.</a>
<a name="ln2396">  if (!validated_tables.empty()) {</a>
<a name="ln2397">    std::unordered_map&lt;std::string, std::string&gt; options;</a>
<a name="ln2398">    options.reserve(2);</a>
<a name="ln2399">    options.emplace(cdc::kRecordType, CDCRecordType_Name(cdc::CDCRecordType::CHANGE));</a>
<a name="ln2400">    options.emplace(cdc::kRecordFormat, CDCRecordFormat_Name(cdc::CDCRecordFormat::WAL));</a>
<a name="ln2401"> </a>
<a name="ln2402">    for (const auto&amp; table : validated_tables) {</a>
<a name="ln2403">      string producer_bootstrap_id;</a>
<a name="ln2404">      auto it = table_bootstrap_ids.find(table);</a>
<a name="ln2405">      if (it != table_bootstrap_ids.end()) {</a>
<a name="ln2406">        producer_bootstrap_id = it-&gt;second;</a>
<a name="ln2407">      }</a>
<a name="ln2408">      if (!producer_bootstrap_id.empty()) {</a>
<a name="ln2409">        auto table_id = std::make_shared&lt;TableId&gt;();</a>
<a name="ln2410">        auto stream_options = std::make_shared&lt;std::unordered_map&lt;std::string, std::string&gt;&gt;();</a>
<a name="ln2411">        cdc_rpc-&gt;client()-&gt;GetCDCStream(producer_bootstrap_id, table_id, stream_options,</a>
<a name="ln2412">            std::bind(&amp;enterprise::CatalogManager::GetCDCStreamCallback, this,</a>
<a name="ln2413">                producer_bootstrap_id, table_id, stream_options, universe-&gt;id(), table,</a>
<a name="ln2414">                std::placeholders::_1));</a>
<a name="ln2415">      } else {</a>
<a name="ln2416">        cdc_rpc-&gt;client()-&gt;CreateCDCStream(</a>
<a name="ln2417">            table, options,</a>
<a name="ln2418">            std::bind(&amp;enterprise::CatalogManager::AddCDCStreamToUniverseAndInitConsumer, this,</a>
<a name="ln2419">                universe-&gt;id(), table, std::placeholders::_1));</a>
<a name="ln2420">      }</a>
<a name="ln2421">    }</a>
<a name="ln2422">  }</a>
<a name="ln2423">}</a>
<a name="ln2424"> </a>
<a name="ln2425">void CatalogManager::GetCDCStreamCallback(</a>
<a name="ln2426">    const CDCStreamId&amp; bootstrap_id,</a>
<a name="ln2427">    std::shared_ptr&lt;TableId&gt; table_id,</a>
<a name="ln2428">    std::shared_ptr&lt;std::unordered_map&lt;std::string, std::string&gt;&gt; options,</a>
<a name="ln2429">    const std::string&amp; universe_id,</a>
<a name="ln2430">    const TableId&amp; table,</a>
<a name="ln2431">    const Status&amp; s) {</a>
<a name="ln2432">  if (!s.ok()) {</a>
<a name="ln2433">    LOG(ERROR) &lt;&lt; &quot;Unable to find bootstrap id &quot; &lt;&lt; bootstrap_id;</a>
<a name="ln2434">    AddCDCStreamToUniverseAndInitConsumer(universe_id, table, s);</a>
<a name="ln2435">  } else {</a>
<a name="ln2436">    if (*table_id != table) {</a>
<a name="ln2437">      const Status invalid_bootstrap_id_status = STATUS_FORMAT(</a>
<a name="ln2438">          InvalidArgument, &quot;Invalid bootstrap id for table $0. Bootstrap id $1 belongs to table $2&quot;,</a>
<a name="ln2439">          table, bootstrap_id, *table_id);</a>
<a name="ln2440">      LOG(ERROR) &lt;&lt; invalid_bootstrap_id_status;</a>
<a name="ln2441">      AddCDCStreamToUniverseAndInitConsumer(universe_id, table, invalid_bootstrap_id_status);</a>
<a name="ln2442">    }</a>
<a name="ln2443">    // todo check options</a>
<a name="ln2444">    AddCDCStreamToUniverseAndInitConsumer(universe_id, table, bootstrap_id);</a>
<a name="ln2445">  }</a>
<a name="ln2446">}</a>
<a name="ln2447"> </a>
<a name="ln2448">void CatalogManager::AddCDCStreamToUniverseAndInitConsumer(</a>
<a name="ln2449">    const std::string&amp; universe_id, const TableId&amp; table_id, const Result&lt;CDCStreamId&gt;&amp; stream_id) {</a>
<a name="ln2450">  scoped_refptr&lt;UniverseReplicationInfo&gt; universe;</a>
<a name="ln2451">  {</a>
<a name="ln2452">    std::shared_lock&lt;LockType&gt; catalog_lock(lock_);</a>
<a name="ln2453">    TRACE(&quot;Acquired catalog manager lock&quot;);</a>
<a name="ln2454"> </a>
<a name="ln2455">    universe = FindPtrOrNull(universe_replication_map_, universe_id);</a>
<a name="ln2456">    if (universe == nullptr) {</a>
<a name="ln2457">      LOG(ERROR) &lt;&lt; &quot;Universe not found: &quot; &lt;&lt; universe_id;</a>
<a name="ln2458">      return;</a>
<a name="ln2459">    }</a>
<a name="ln2460">  }</a>
<a name="ln2461"> </a>
<a name="ln2462">  if (!stream_id.ok()) {</a>
<a name="ln2463">    LOG(ERROR) &lt;&lt; &quot;Error setting up CDC stream for table &quot; &lt;&lt; table_id;</a>
<a name="ln2464">    MarkUniverseReplicationFailed(universe);</a>
<a name="ln2465">    return;</a>
<a name="ln2466">  }</a>
<a name="ln2467"> </a>
<a name="ln2468">  bool merge_alter = false;</a>
<a name="ln2469">  {</a>
<a name="ln2470">    auto l = universe-&gt;LockForWrite();</a>
<a name="ln2471">    if (l-&gt;data().is_deleted_or_failed()) {</a>
<a name="ln2472">      // Nothing to do if universe is being deleted.</a>
<a name="ln2473">      return;</a>
<a name="ln2474">    }</a>
<a name="ln2475"> </a>
<a name="ln2476">    auto map = l-&gt;mutable_data()-&gt;pb.mutable_table_streams();</a>
<a name="ln2477">    (*map)[table_id] = *stream_id;</a>
<a name="ln2478"> </a>
<a name="ln2479">    // This functions as a barrier: waiting for the last RPC call from GetTableSchemaCallback.</a>
<a name="ln2480">    if (l-&gt;mutable_data()-&gt;pb.table_streams_size() == l-&gt;data().pb.tables_size()) {</a>
<a name="ln2481">      // All tables successfully validated! Register CDC consumers &amp; start replication.</a>
<a name="ln2482">      LOG(INFO) &lt;&lt; &quot;Registering CDC consumers for universe &quot; &lt;&lt; universe-&gt;id();</a>
<a name="ln2483"> </a>
<a name="ln2484">      auto validated_tables = l-&gt;data().pb.validated_tables();</a>
<a name="ln2485"> </a>
<a name="ln2486">      std::vector&lt;CDCConsumerStreamInfo&gt; consumer_info;</a>
<a name="ln2487">      consumer_info.reserve(l-&gt;data().pb.tables_size());</a>
<a name="ln2488">      for (const auto&amp; table : validated_tables) {</a>
<a name="ln2489">        CDCConsumerStreamInfo info;</a>
<a name="ln2490">        info.producer_table_id = table.first;</a>
<a name="ln2491">        info.consumer_table_id = table.second;</a>
<a name="ln2492">        info.stream_id = (*map)[info.producer_table_id];</a>
<a name="ln2493">        consumer_info.push_back(info);</a>
<a name="ln2494">      }</a>
<a name="ln2495"> </a>
<a name="ln2496">      std::vector&lt;HostPort&gt; hp;</a>
<a name="ln2497">      HostPortsFromPBs(l-&gt;data().pb.producer_master_addresses(), &amp;hp);</a>
<a name="ln2498"> </a>
<a name="ln2499">      Status s = InitCDCConsumer(consumer_info, HostPort::ToCommaSeparatedString(hp),</a>
<a name="ln2500">          l-&gt;data().pb.producer_id());</a>
<a name="ln2501">      if (!s.ok()) {</a>
<a name="ln2502">        LOG(ERROR) &lt;&lt; &quot;Error registering subscriber: &quot; &lt;&lt; s;</a>
<a name="ln2503">        l-&gt;mutable_data()-&gt;pb.set_state(SysUniverseReplicationEntryPB::FAILED);</a>
<a name="ln2504">      } else {</a>
<a name="ln2505">        GStringPiece original_producer_id(universe-&gt;id());</a>
<a name="ln2506">        if (original_producer_id.ends_with(&quot;.ALTER&quot;)) {</a>
<a name="ln2507">          // Don't enable ALTER universes, merge them into the main universe instead.</a>
<a name="ln2508">          merge_alter = true;</a>
<a name="ln2509">        } else {</a>
<a name="ln2510">          l-&gt;mutable_data()-&gt;pb.set_state(SysUniverseReplicationEntryPB::ACTIVE);</a>
<a name="ln2511">        }</a>
<a name="ln2512">      }</a>
<a name="ln2513">    }</a>
<a name="ln2514"> </a>
<a name="ln2515">    // Update sys_catalog with new producer table id info.</a>
<a name="ln2516">    Status status = sys_catalog_-&gt;UpdateItem(universe.get(), leader_ready_term());</a>
<a name="ln2517">    if (!status.ok()) {</a>
<a name="ln2518">      return (void)CheckStatus(status, &quot;updating universe replication info in sys-catalog&quot;);</a>
<a name="ln2519">    }</a>
<a name="ln2520">    l-&gt;Commit();</a>
<a name="ln2521">  }</a>
<a name="ln2522"> </a>
<a name="ln2523">  // If this is an 'alter', merge back into primary command now that setup is a success.</a>
<a name="ln2524">  if (merge_alter) {</a>
<a name="ln2525">    MergeUniverseReplication(universe);</a>
<a name="ln2526">  }</a>
<a name="ln2527">}</a>
<a name="ln2528"> </a>
<a name="ln2529">Status CatalogManager::InitCDCConsumer(</a>
<a name="ln2530">    const std::vector&lt;CDCConsumerStreamInfo&gt;&amp; consumer_info,</a>
<a name="ln2531">    const std::string&amp; master_addrs,</a>
<a name="ln2532">    const std::string&amp; producer_universe_uuid) {</a>
<a name="ln2533"> </a>
<a name="ln2534">  std::unordered_set&lt;HostPort, HostPortHash&gt; tserver_addrs;</a>
<a name="ln2535">  // Get the tablets in the consumer table.</a>
<a name="ln2536">  cdc::ProducerEntryPB producer_entry;</a>
<a name="ln2537">  for (const auto&amp; stream_info : consumer_info) {</a>
<a name="ln2538">    GetTableLocationsRequestPB consumer_table_req;</a>
<a name="ln2539">    consumer_table_req.set_max_returned_locations(std::numeric_limits&lt;int32_t&gt;::max());</a>
<a name="ln2540">    GetTableLocationsResponsePB consumer_table_resp;</a>
<a name="ln2541">    TableIdentifierPB table_identifer;</a>
<a name="ln2542">    table_identifer.set_table_id(stream_info.consumer_table_id);</a>
<a name="ln2543">    *(consumer_table_req.mutable_table()) = table_identifer;</a>
<a name="ln2544">    RETURN_NOT_OK(GetTableLocations(&amp;consumer_table_req, &amp;consumer_table_resp));</a>
<a name="ln2545">    cdc::StreamEntryPB stream_entry;</a>
<a name="ln2546">    // Get producer tablets and map them to the consumer tablets</a>
<a name="ln2547">    RETURN_NOT_OK(CreateTabletMapping(</a>
<a name="ln2548">        stream_info.producer_table_id, stream_info.consumer_table_id, producer_universe_uuid,</a>
<a name="ln2549">        master_addrs, consumer_table_resp, &amp;tserver_addrs, &amp;stream_entry));</a>
<a name="ln2550">    (*producer_entry.mutable_stream_map())[stream_info.stream_id] = std::move(stream_entry);</a>
<a name="ln2551">  }</a>
<a name="ln2552"> </a>
<a name="ln2553">  // Log the Network topology of the Producer Cluster</a>
<a name="ln2554">  auto master_addrs_list = StringSplit(master_addrs, ',');</a>
<a name="ln2555">  producer_entry.mutable_master_addrs()-&gt;Reserve(master_addrs_list.size());</a>
<a name="ln2556">  for (const auto&amp; addr : master_addrs_list) {</a>
<a name="ln2557">    auto hp = VERIFY_RESULT(HostPort::FromString(addr, 0));</a>
<a name="ln2558">    HostPortToPB(hp, producer_entry.add_master_addrs());</a>
<a name="ln2559">  }</a>
<a name="ln2560"> </a>
<a name="ln2561">  producer_entry.mutable_tserver_addrs()-&gt;Reserve(tserver_addrs.size());</a>
<a name="ln2562">  for (const auto&amp; addr : tserver_addrs) {</a>
<a name="ln2563">    HostPortToPB(addr, producer_entry.add_tserver_addrs());</a>
<a name="ln2564">  }</a>
<a name="ln2565"> </a>
<a name="ln2566">  auto l = cluster_config_-&gt;LockForWrite();</a>
<a name="ln2567">  auto producer_map = l-&gt;mutable_data()-&gt;pb.mutable_consumer_registry()-&gt;mutable_producer_map();</a>
<a name="ln2568">  auto it = producer_map-&gt;find(producer_universe_uuid);</a>
<a name="ln2569">  if (it != producer_map-&gt;end()) {</a>
<a name="ln2570">    return STATUS(InvalidArgument, &quot;Already created a consumer for this universe&quot;);</a>
<a name="ln2571">  }</a>
<a name="ln2572"> </a>
<a name="ln2573">  // TServers will use the ClusterConfig to create CDC Consumers for applicable local tablets.</a>
<a name="ln2574">  (*producer_map)[producer_universe_uuid] = std::move(producer_entry);</a>
<a name="ln2575">  l-&gt;mutable_data()-&gt;pb.set_version(l-&gt;mutable_data()-&gt;pb.version() + 1);</a>
<a name="ln2576">  RETURN_NOT_OK(CheckStatus(</a>
<a name="ln2577">      sys_catalog_-&gt;UpdateItem(cluster_config_.get(), leader_ready_term()),</a>
<a name="ln2578">      &quot;updating cluster config in sys-catalog&quot;));</a>
<a name="ln2579">  l-&gt;Commit();</a>
<a name="ln2580"> </a>
<a name="ln2581">  return Status::OK();</a>
<a name="ln2582">}</a>
<a name="ln2583"> </a>
<a name="ln2584">void CatalogManager::MergeUniverseReplication(scoped_refptr&lt;UniverseReplicationInfo&gt; universe) {</a>
<a name="ln2585">  // Merge back into primary command now that setup is a success.</a>
<a name="ln2586">  GStringPiece original_producer_id(universe-&gt;id());</a>
<a name="ln2587">  if (!original_producer_id.ends_with(&quot;.ALTER&quot;)) {</a>
<a name="ln2588">    return;</a>
<a name="ln2589">  }</a>
<a name="ln2590">  original_producer_id.remove_suffix(sizeof(&quot;.ALTER&quot;)-1 /* exclude \0 ending */);</a>
<a name="ln2591">  LOG(INFO) &lt;&lt; &quot;Merging CDC universe: &quot; &lt;&lt; universe-&gt;id()</a>
<a name="ln2592">            &lt;&lt; &quot; into &quot; &lt;&lt; original_producer_id.ToString();</a>
<a name="ln2593"> </a>
<a name="ln2594">  scoped_refptr&lt;UniverseReplicationInfo&gt; original_universe;</a>
<a name="ln2595">  {</a>
<a name="ln2596">    std::shared_lock&lt;LockType&gt; catalog_lock(lock_);</a>
<a name="ln2597">    TRACE(&quot;Acquired catalog manager lock&quot;);</a>
<a name="ln2598"> </a>
<a name="ln2599">    original_universe = FindPtrOrNull(universe_replication_map_, original_producer_id.ToString());</a>
<a name="ln2600">    if (original_universe == nullptr) {</a>
<a name="ln2601">      LOG(ERROR) &lt;&lt; &quot;Universe not found: &quot; &lt;&lt; original_producer_id.ToString();</a>
<a name="ln2602">      return;</a>
<a name="ln2603">    }</a>
<a name="ln2604">  }</a>
<a name="ln2605">  // Merge Cluster Config for TServers.</a>
<a name="ln2606">  {</a>
<a name="ln2607">    auto cl = cluster_config_-&gt;LockForWrite();</a>
<a name="ln2608">    auto pm = cl-&gt;mutable_data()-&gt;pb.mutable_consumer_registry()-&gt;mutable_producer_map();</a>
<a name="ln2609">    auto original_producer_entry = pm-&gt;find(original_universe-&gt;id());</a>
<a name="ln2610">    auto alter_producer_entry = pm-&gt;find(universe-&gt;id());</a>
<a name="ln2611">    if (original_producer_entry != pm-&gt;end() &amp;&amp; alter_producer_entry != pm-&gt;end()) {</a>
<a name="ln2612">      // Merge the Tables from the Alter into the original.</a>
<a name="ln2613">      auto as = alter_producer_entry-&gt;second.stream_map();</a>
<a name="ln2614">      original_producer_entry-&gt;second.mutable_stream_map()-&gt;insert(as.begin(), as.end());</a>
<a name="ln2615">      // Delete the Alter</a>
<a name="ln2616">      pm-&gt;erase(alter_producer_entry);</a>
<a name="ln2617">    } else {</a>
<a name="ln2618">      LOG(WARNING) &lt;&lt; &quot;Could not find both universes in Cluster Config: &quot; &lt;&lt; universe-&gt;id();</a>
<a name="ln2619">    }</a>
<a name="ln2620">    cl-&gt;mutable_data()-&gt;pb.set_version(cl-&gt;mutable_data()-&gt;pb.version() + 1);</a>
<a name="ln2621">    const Status s = sys_catalog_-&gt;UpdateItem(cluster_config_.get(), leader_ready_term());</a>
<a name="ln2622">    if (!s.ok()) {</a>
<a name="ln2623">      return (void)CheckStatus(s, &quot;updating cluster config in sys-catalog&quot;);</a>
<a name="ln2624">    }</a>
<a name="ln2625">    cl-&gt;Commit();</a>
<a name="ln2626">  }</a>
<a name="ln2627">  // Merge Master Config on Consumer. (no need for Producer changes, since it uses stream_id)</a>
<a name="ln2628">  {</a>
<a name="ln2629">    auto original_lock = original_universe-&gt;LockForWrite();</a>
<a name="ln2630">    auto alter_lock = universe-&gt;LockForWrite();</a>
<a name="ln2631">    // Merge Table-&gt;StreamID mapping.</a>
<a name="ln2632">    auto at = alter_lock-&gt;mutable_data()-&gt;pb.mutable_tables();</a>
<a name="ln2633">    original_lock-&gt;mutable_data()-&gt;pb.mutable_tables()-&gt;MergeFrom(*at);</a>
<a name="ln2634">    at-&gt;Clear();</a>
<a name="ln2635">    auto as = alter_lock-&gt;mutable_data()-&gt;pb.mutable_table_streams();</a>
<a name="ln2636">    original_lock-&gt;mutable_data()-&gt;pb.mutable_table_streams()-&gt;insert(as-&gt;begin(), as-&gt;end());</a>
<a name="ln2637">    as-&gt;clear();</a>
<a name="ln2638">    auto av = alter_lock-&gt;mutable_data()-&gt;pb.mutable_validated_tables();</a>
<a name="ln2639">    original_lock-&gt;mutable_data()-&gt;pb.mutable_validated_tables()-&gt;insert(av-&gt;begin(), av-&gt;end());</a>
<a name="ln2640">    av-&gt;clear();</a>
<a name="ln2641">    alter_lock-&gt;mutable_data()-&gt;pb.set_state(SysUniverseReplicationEntryPB::DELETED);</a>
<a name="ln2642"> </a>
<a name="ln2643">    vector&lt;UniverseReplicationInfo*&gt; universes{original_universe.get(), universe.get()};</a>
<a name="ln2644">    const Status s = sys_catalog_-&gt;UpdateItems(universes, leader_ready_term());</a>
<a name="ln2645">    if (!s.ok()) {</a>
<a name="ln2646">      return (void)CheckStatus(s, &quot;updating universe replication entries in sys-catalog&quot;);</a>
<a name="ln2647">    }</a>
<a name="ln2648">    alter_lock-&gt;Commit();</a>
<a name="ln2649">    original_lock-&gt;Commit();</a>
<a name="ln2650">  }</a>
<a name="ln2651">  // TODO: universe_replication_map_.erase(universe-&gt;id()) at a later time.</a>
<a name="ln2652">  //       TwoDCTest.AlterUniverseReplicationTables crashes due to undiagnosed race right now.</a>
<a name="ln2653">  LOG(INFO) &lt;&lt; &quot;Done with Merging &quot; &lt;&lt; universe-&gt;id() &lt;&lt; &quot; into &quot; &lt;&lt; original_universe-&gt;id();</a>
<a name="ln2654">}</a>
<a name="ln2655"> </a>
<a name="ln2656">Status CatalogManager::DeleteUniverseReplication(const DeleteUniverseReplicationRequestPB* req,</a>
<a name="ln2657">                                                 DeleteUniverseReplicationResponsePB* resp,</a>
<a name="ln2658">                                                 rpc::RpcContext* rpc) {</a>
<a name="ln2659">  LOG(INFO) &lt;&lt; &quot;Servicing DeleteUniverseReplication request from &quot; &lt;&lt; RequestorString(rpc)</a>
<a name="ln2660">            &lt;&lt; &quot;: &quot; &lt;&lt; req-&gt;ShortDebugString();</a>
<a name="ln2661"> </a>
<a name="ln2662">  RETURN_NOT_OK(CheckOnline());</a>
<a name="ln2663"> </a>
<a name="ln2664">  if (!req-&gt;has_producer_id()) {</a>
<a name="ln2665">    return STATUS(InvalidArgument, &quot;Producer universe ID required&quot;, req-&gt;ShortDebugString(),</a>
<a name="ln2666">                  MasterError(MasterErrorPB::INVALID_REQUEST));</a>
<a name="ln2667">  }</a>
<a name="ln2668"> </a>
<a name="ln2669">  scoped_refptr&lt;UniverseReplicationInfo&gt; ri;</a>
<a name="ln2670">  {</a>
<a name="ln2671">    std::shared_lock&lt;LockType&gt; catalog_lock(lock_);</a>
<a name="ln2672">    TRACE(&quot;Acquired catalog manager lock&quot;);</a>
<a name="ln2673"> </a>
<a name="ln2674">    ri = FindPtrOrNull(universe_replication_map_, req-&gt;producer_id());</a>
<a name="ln2675">    if (ri == nullptr) {</a>
<a name="ln2676">      return STATUS(NotFound, &quot;Universe replication info does not exist&quot;,</a>
<a name="ln2677">                    req-&gt;ShortDebugString(), MasterError(MasterErrorPB::OBJECT_NOT_FOUND));</a>
<a name="ln2678">    }</a>
<a name="ln2679">  }</a>
<a name="ln2680"> </a>
<a name="ln2681">  auto l = ri-&gt;LockForWrite();</a>
<a name="ln2682">  l-&gt;mutable_data()-&gt;pb.set_state(SysUniverseReplicationEntryPB::DELETED);</a>
<a name="ln2683"> </a>
<a name="ln2684">  // Delete subscribers on the Consumer Registry (removes from TServers).</a>
<a name="ln2685">  LOG(INFO) &lt;&lt; &quot;Deleting subscribers for producer &quot; &lt;&lt; req-&gt;producer_id();</a>
<a name="ln2686">  {</a>
<a name="ln2687">    auto cl = cluster_config_-&gt;LockForWrite();</a>
<a name="ln2688">    auto producer_map = cl-&gt;mutable_data()-&gt;pb.mutable_consumer_registry()-&gt;mutable_producer_map();</a>
<a name="ln2689">    auto it = producer_map-&gt;find(req-&gt;producer_id());</a>
<a name="ln2690">    if (it != producer_map-&gt;end()) {</a>
<a name="ln2691">      producer_map-&gt;erase(it);</a>
<a name="ln2692">      cl-&gt;mutable_data()-&gt;pb.set_version(cl-&gt;mutable_data()-&gt;pb.version() + 1);</a>
<a name="ln2693">      RETURN_NOT_OK(CheckStatus(</a>
<a name="ln2694">          sys_catalog_-&gt;UpdateItem(cluster_config_.get(), leader_ready_term()),</a>
<a name="ln2695">          &quot;updating cluster config in sys-catalog&quot;));</a>
<a name="ln2696">      cl-&gt;Commit();</a>
<a name="ln2697">    }</a>
<a name="ln2698">  }</a>
<a name="ln2699"> </a>
<a name="ln2700">  // Delete CDC stream config on the Producer.</a>
<a name="ln2701">  if (!l-&gt;data().pb.table_streams().empty()) {</a>
<a name="ln2702">    auto result = ri-&gt;GetOrCreateCDCRpcTasks(l-&gt;data().pb.producer_master_addresses());</a>
<a name="ln2703">    if (!result.ok()) {</a>
<a name="ln2704">      LOG(WARNING) &lt;&lt; &quot;Unable to create cdc rpc task. CDC streams won't be deleted: &quot; &lt;&lt; result;</a>
<a name="ln2705">    } else {</a>
<a name="ln2706">      auto cdc_rpc = *result;</a>
<a name="ln2707">      vector&lt;CDCStreamId&gt; streams;</a>
<a name="ln2708">      for (const auto&amp; table : l-&gt;data().pb.table_streams()) {</a>
<a name="ln2709">        streams.push_back(table.second);</a>
<a name="ln2710">      }</a>
<a name="ln2711">      auto s = cdc_rpc-&gt;client()-&gt;DeleteCDCStream(streams);</a>
<a name="ln2712">      if (!s.ok()) {</a>
<a name="ln2713">        LOG(WARNING) &lt;&lt; &quot;Unable to delete CDC stream &quot; &lt;&lt; s;</a>
<a name="ln2714">      }</a>
<a name="ln2715">    }</a>
<a name="ln2716">  }</a>
<a name="ln2717"> </a>
<a name="ln2718">  // Delete universe in the Universe Config.</a>
<a name="ln2719">  DeleteUniverseReplicationUnlocked(ri);</a>
<a name="ln2720">  l-&gt;Commit();</a>
<a name="ln2721"> </a>
<a name="ln2722">  LOG(INFO) &lt;&lt; &quot;Processed delete universe replication &quot; &lt;&lt; ri-&gt;ToString()</a>
<a name="ln2723">            &lt;&lt; &quot; per request from &quot; &lt;&lt; RequestorString(rpc);</a>
<a name="ln2724"> </a>
<a name="ln2725">  return Status::OK();</a>
<a name="ln2726">}</a>
<a name="ln2727"> </a>
<a name="ln2728">void CatalogManager::DeleteUniverseReplicationUnlocked(</a>
<a name="ln2729">    scoped_refptr&lt;UniverseReplicationInfo&gt; universe) {</a>
<a name="ln2730">  // Assumes that caller has locked universe.</a>
<a name="ln2731">  Status s = sys_catalog_-&gt;DeleteItem(universe.get(), leader_ready_term());</a>
<a name="ln2732">  if (!s.ok()) {</a>
<a name="ln2733">    LOG(ERROR) &lt;&lt; &quot;An error occured while updating sys-catalog: &quot; &lt;&lt; s</a>
<a name="ln2734">               &lt;&lt; &quot;: universe_id: &quot; &lt;&lt; universe-&gt;id();</a>
<a name="ln2735">    return;</a>
<a name="ln2736">  }</a>
<a name="ln2737">  // Remove it from the map.</a>
<a name="ln2738">  std::lock_guard&lt;LockType&gt; catalog_lock(lock_);</a>
<a name="ln2739">  if (universe_replication_map_.erase(universe-&gt;id()) &lt; 1) {</a>
<a name="ln2740">    LOG(ERROR) &lt;&lt; &quot;An error occured while removing replication info from map: &quot; &lt;&lt; s</a>
<a name="ln2741">               &lt;&lt; &quot;: universe_id: &quot; &lt;&lt; universe-&gt;id();</a>
<a name="ln2742">  }</a>
<a name="ln2743">}</a>
<a name="ln2744"> </a>
<a name="ln2745">Status CatalogManager::SetUniverseReplicationEnabled(</a>
<a name="ln2746">    const SetUniverseReplicationEnabledRequestPB* req,</a>
<a name="ln2747">    SetUniverseReplicationEnabledResponsePB* resp,</a>
<a name="ln2748">    rpc::RpcContext* rpc) {</a>
<a name="ln2749">  LOG(INFO) &lt;&lt; &quot;Servicing SetUniverseReplicationEnabled request from &quot; &lt;&lt; RequestorString(rpc)</a>
<a name="ln2750">            &lt;&lt; &quot;: &quot; &lt;&lt; req-&gt;ShortDebugString();</a>
<a name="ln2751"> </a>
<a name="ln2752">  // Sanity Checking Cluster State and Input.</a>
<a name="ln2753">  RETURN_NOT_OK(CheckOnline());</a>
<a name="ln2754"> </a>
<a name="ln2755">  if (!req-&gt;has_producer_id()) {</a>
<a name="ln2756">    return STATUS(InvalidArgument, &quot;Producer universe ID must be provided&quot;,</a>
<a name="ln2757">                  req-&gt;ShortDebugString(), MasterError(MasterErrorPB::INVALID_REQUEST));</a>
<a name="ln2758">  }</a>
<a name="ln2759">  if (!req-&gt;has_is_enabled()) {</a>
<a name="ln2760">    return STATUS(InvalidArgument, &quot;Must explicitly set whether to enable&quot;,</a>
<a name="ln2761">                  req-&gt;ShortDebugString(), MasterError(MasterErrorPB::INVALID_REQUEST));</a>
<a name="ln2762">  }</a>
<a name="ln2763"> </a>
<a name="ln2764">  scoped_refptr&lt;UniverseReplicationInfo&gt; universe;</a>
<a name="ln2765">  {</a>
<a name="ln2766">    std::shared_lock&lt;LockType&gt; l(lock_);</a>
<a name="ln2767"> </a>
<a name="ln2768">    universe = FindPtrOrNull(universe_replication_map_, req-&gt;producer_id());</a>
<a name="ln2769">    if (universe == nullptr) {</a>
<a name="ln2770">      return STATUS(NotFound, &quot;Could not find CDC producer universe&quot;,</a>
<a name="ln2771">                    req-&gt;ShortDebugString(), MasterError(MasterErrorPB::OBJECT_NOT_FOUND));</a>
<a name="ln2772">    }</a>
<a name="ln2773">  }</a>
<a name="ln2774"> </a>
<a name="ln2775">  // Update the Master's Universe Config with the new state.</a>
<a name="ln2776">  {</a>
<a name="ln2777">    auto l = universe-&gt;LockForWrite();</a>
<a name="ln2778">    if (l-&gt;data().pb.state() != SysUniverseReplicationEntryPB::DISABLED &amp;&amp;</a>
<a name="ln2779">        l-&gt;data().pb.state() != SysUniverseReplicationEntryPB::ACTIVE) {</a>
<a name="ln2780">      return STATUS(</a>
<a name="ln2781">          InvalidArgument,</a>
<a name="ln2782">          Format(&quot;Universe Replication in invalid state: $0.  Retry or Delete.&quot;,</a>
<a name="ln2783">              SysUniverseReplicationEntryPB::State_Name(l-&gt;data().pb.state())),</a>
<a name="ln2784">          req-&gt;ShortDebugString(),</a>
<a name="ln2785">          MasterError(MasterErrorPB::INVALID_REQUEST));</a>
<a name="ln2786">    }</a>
<a name="ln2787">    if (req-&gt;is_enabled()) {</a>
<a name="ln2788">        l-&gt;mutable_data()-&gt;pb.set_state(SysUniverseReplicationEntryPB::ACTIVE);</a>
<a name="ln2789">    } else { // DISABLE.</a>
<a name="ln2790">        l-&gt;mutable_data()-&gt;pb.set_state(SysUniverseReplicationEntryPB::DISABLED);</a>
<a name="ln2791">    }</a>
<a name="ln2792">    RETURN_NOT_OK(CheckStatus(</a>
<a name="ln2793">        sys_catalog_-&gt;UpdateItem(universe.get(), leader_ready_term()),</a>
<a name="ln2794">        &quot;updating universe replication info in sys-catalog&quot;));</a>
<a name="ln2795">    l-&gt;Commit();</a>
<a name="ln2796">  }</a>
<a name="ln2797"> </a>
<a name="ln2798">  // Modify the Consumer Registry, which will fan out this info to all TServers on heartbeat.</a>
<a name="ln2799">  {</a>
<a name="ln2800">    auto l = cluster_config_-&gt;LockForWrite();</a>
<a name="ln2801">    auto producer_map = l-&gt;mutable_data()-&gt;pb.mutable_consumer_registry()-&gt;mutable_producer_map();</a>
<a name="ln2802">    auto it = producer_map-&gt;find(req-&gt;producer_id());</a>
<a name="ln2803">    if (it == producer_map-&gt;end()) {</a>
<a name="ln2804">      LOG(WARNING) &lt;&lt; &quot;Valid Producer Universe not in Consumer Registry: &quot; &lt;&lt; req-&gt;producer_id();</a>
<a name="ln2805">      return STATUS(NotFound, &quot;Could not find CDC producer universe&quot;,</a>
<a name="ln2806">                    req-&gt;ShortDebugString(), MasterError(MasterErrorPB::OBJECT_NOT_FOUND));</a>
<a name="ln2807">    }</a>
<a name="ln2808">    (*it).second.set_disable_stream(!req-&gt;is_enabled());</a>
<a name="ln2809">    l-&gt;mutable_data()-&gt;pb.set_version(l-&gt;mutable_data()-&gt;pb.version() + 1);</a>
<a name="ln2810">    RETURN_NOT_OK(CheckStatus(</a>
<a name="ln2811">        sys_catalog_-&gt;UpdateItem(cluster_config_.get(), leader_ready_term()),</a>
<a name="ln2812">        &quot;updating cluster config in sys-catalog&quot;));</a>
<a name="ln2813">    l-&gt;Commit();</a>
<a name="ln2814">  }</a>
<a name="ln2815"> </a>
<a name="ln2816">  return Status::OK();</a>
<a name="ln2817">}</a>
<a name="ln2818"> </a>
<a name="ln2819">Status CatalogManager::AlterUniverseReplication(const AlterUniverseReplicationRequestPB* req,</a>
<a name="ln2820">                                                AlterUniverseReplicationResponsePB* resp,</a>
<a name="ln2821">                                                rpc::RpcContext* rpc) {</a>
<a name="ln2822">  LOG(INFO) &lt;&lt; &quot;Servicing AlterUniverseReplication request from &quot; &lt;&lt; RequestorString(rpc)</a>
<a name="ln2823">            &lt;&lt; &quot;: &quot; &lt;&lt; req-&gt;ShortDebugString();</a>
<a name="ln2824"> </a>
<a name="ln2825">  // Sanity Checking Cluster State and Input.</a>
<a name="ln2826">  RETURN_NOT_OK(CheckOnline());</a>
<a name="ln2827"> </a>
<a name="ln2828">  if (!req-&gt;has_producer_id()) {</a>
<a name="ln2829">    return STATUS(InvalidArgument, &quot;Producer universe ID must be provided&quot;,</a>
<a name="ln2830">                  req-&gt;ShortDebugString(), MasterError(MasterErrorPB::INVALID_REQUEST));</a>
<a name="ln2831">  }</a>
<a name="ln2832"> </a>
<a name="ln2833">  // Verify that there is an existing Universe config</a>
<a name="ln2834">  scoped_refptr&lt;UniverseReplicationInfo&gt; original_ri;</a>
<a name="ln2835">  {</a>
<a name="ln2836">    std::shared_lock&lt;LockType&gt; l(lock_);</a>
<a name="ln2837"> </a>
<a name="ln2838">    original_ri = FindPtrOrNull(universe_replication_map_, req-&gt;producer_id());</a>
<a name="ln2839">    if (original_ri == nullptr) {</a>
<a name="ln2840">      return STATUS(NotFound, &quot;Could not find CDC producer universe&quot;,</a>
<a name="ln2841">                    req-&gt;ShortDebugString(), MasterError(MasterErrorPB::OBJECT_NOT_FOUND));</a>
<a name="ln2842">    }</a>
<a name="ln2843">  }</a>
<a name="ln2844"> </a>
<a name="ln2845">  // Currently, config options are mutually exclusive to simplify transactionality.</a>
<a name="ln2846">  int config_count = (req-&gt;producer_master_addresses_size() &gt; 0 ? 1 : 0) +</a>
<a name="ln2847">                     (req-&gt;producer_table_ids_to_remove_size() &gt; 0 ? 1 : 0) +</a>
<a name="ln2848">                     (req-&gt;producer_table_ids_to_add_size() &gt; 0 ? 1 : 0);</a>
<a name="ln2849">  if (config_count != 1) {</a>
<a name="ln2850">    return STATUS(InvalidArgument, &quot;Only 1 Alter operation per request currently supported&quot;,</a>
<a name="ln2851">                  req-&gt;ShortDebugString(), MasterError(MasterErrorPB::INVALID_REQUEST));</a>
<a name="ln2852">  }</a>
<a name="ln2853"> </a>
<a name="ln2854">  // Config logic...</a>
<a name="ln2855">  if (req-&gt;producer_master_addresses_size() &gt; 0) {</a>
<a name="ln2856">    // 'set_master_addresses'</a>
<a name="ln2857">    // TODO: Verify the input. Setup an RPC Task, ListTables, ensure same.</a>
<a name="ln2858"> </a>
<a name="ln2859">    // 1a. Persistent Config: Update the Universe Config for Master.</a>
<a name="ln2860">    {</a>
<a name="ln2861">      auto l = original_ri-&gt;LockForWrite();</a>
<a name="ln2862">      l-&gt;mutable_data()-&gt;pb.mutable_producer_master_addresses()-&gt;CopyFrom(</a>
<a name="ln2863">          req-&gt;producer_master_addresses());</a>
<a name="ln2864">      RETURN_NOT_OK(CheckStatus(</a>
<a name="ln2865">          sys_catalog_-&gt;UpdateItem(original_ri.get(), leader_ready_term()),</a>
<a name="ln2866">          &quot;updating universe replication info in sys-catalog&quot;));</a>
<a name="ln2867">      l-&gt;Commit();</a>
<a name="ln2868">    }</a>
<a name="ln2869">    // 1b. Persistent Config: Update the Consumer Registry (updates TServers)</a>
<a name="ln2870">    {</a>
<a name="ln2871">      auto l = cluster_config_-&gt;LockForWrite();</a>
<a name="ln2872">      auto producer_map = l-&gt;mutable_data()-&gt;pb.mutable_consumer_registry()-&gt;mutable_producer_map();</a>
<a name="ln2873">      auto it = producer_map-&gt;find(req-&gt;producer_id());</a>
<a name="ln2874">      if (it == producer_map-&gt;end()) {</a>
<a name="ln2875">        LOG(WARNING) &lt;&lt; &quot;Valid Producer Universe not in Consumer Registry: &quot; &lt;&lt; req-&gt;producer_id();</a>
<a name="ln2876">        return STATUS(NotFound, &quot;Could not find CDC producer universe&quot;,</a>
<a name="ln2877">                      req-&gt;ShortDebugString(), MasterError(MasterErrorPB::OBJECT_NOT_FOUND));</a>
<a name="ln2878">      }</a>
<a name="ln2879">      (*it).second.mutable_master_addrs()-&gt;CopyFrom(req-&gt;producer_master_addresses());</a>
<a name="ln2880">      l-&gt;mutable_data()-&gt;pb.set_version(l-&gt;mutable_data()-&gt;pb.version() + 1);</a>
<a name="ln2881">      RETURN_NOT_OK(CheckStatus(</a>
<a name="ln2882">          sys_catalog_-&gt;UpdateItem(cluster_config_.get(), leader_ready_term()),</a>
<a name="ln2883">          &quot;updating cluster config in sys-catalog&quot;));</a>
<a name="ln2884">      l-&gt;Commit();</a>
<a name="ln2885">    }</a>
<a name="ln2886">    // 2. Memory Update: Change cdc_rpc_tasks (Master cache)</a>
<a name="ln2887">    {</a>
<a name="ln2888">      auto result = original_ri-&gt;GetOrCreateCDCRpcTasks(req-&gt;producer_master_addresses());</a>
<a name="ln2889">      if (!result.ok()) {</a>
<a name="ln2890">        return result.status().CloneAndAddErrorCode(MasterError(MasterErrorPB::INTERNAL_ERROR));</a>
<a name="ln2891">      }</a>
<a name="ln2892">    }</a>
<a name="ln2893">  } else if (req-&gt;producer_table_ids_to_remove_size() &gt; 0) {</a>
<a name="ln2894">    // 'remove_table'</a>
<a name="ln2895">    auto it = req-&gt;producer_table_ids_to_remove();</a>
<a name="ln2896">    std::set&lt;string&gt; table_ids_to_remove(it.begin(), it.end());</a>
<a name="ln2897">    // Filter out any tables that aren't in the existing replication config.</a>
<a name="ln2898">    {</a>
<a name="ln2899">      auto l = original_ri-&gt;LockForRead();</a>
<a name="ln2900">      auto tbl_iter = l-&gt;data().pb.tables();</a>
<a name="ln2901">      std::set&lt;string&gt; existing_tables(tbl_iter.begin(), tbl_iter.end()), filtered_list;</a>
<a name="ln2902">      set_intersection(table_ids_to_remove.begin(), table_ids_to_remove.end(),</a>
<a name="ln2903">                       existing_tables.begin(), existing_tables.end(),</a>
<a name="ln2904">                       std::inserter(filtered_list, filtered_list.begin()));</a>
<a name="ln2905">      filtered_list.swap(table_ids_to_remove);</a>
<a name="ln2906">    }</a>
<a name="ln2907"> </a>
<a name="ln2908">    vector&lt;CDCStreamId&gt; streams_to_remove;</a>
<a name="ln2909">    // 1. Update the Consumer Registry (removes from TServers).</a>
<a name="ln2910">    {</a>
<a name="ln2911">      auto cl = cluster_config_-&gt;LockForWrite();</a>
<a name="ln2912">      auto pm = cl-&gt;mutable_data()-&gt;pb.mutable_consumer_registry()-&gt;mutable_producer_map();</a>
<a name="ln2913">      auto producer_entry = pm-&gt;find(req-&gt;producer_id());</a>
<a name="ln2914">      if (producer_entry != pm-&gt;end()) {</a>
<a name="ln2915">        // Remove the Tables Specified (not part of the key).</a>
<a name="ln2916">        auto stream_map = producer_entry-&gt;second.mutable_stream_map();</a>
<a name="ln2917">        for (auto&amp; p : *stream_map) {</a>
<a name="ln2918">          if (table_ids_to_remove.count(p.second.producer_table_id()) &gt; 0) {</a>
<a name="ln2919">            streams_to_remove.push_back(p.first);</a>
<a name="ln2920">          }</a>
<a name="ln2921">        }</a>
<a name="ln2922">        if (streams_to_remove.size() == stream_map-&gt;size()) {</a>
<a name="ln2923">          // If this ends with an empty Map, disallow and force user to delete.</a>
<a name="ln2924">          LOG(WARNING) &lt;&lt; &quot;CDC 'remove_table' tried to remove all tables.&quot; &lt;&lt; req-&gt;producer_id();</a>
<a name="ln2925">          return STATUS(</a>
<a name="ln2926">              InvalidArgument,</a>
<a name="ln2927">              &quot;Cannot remove all tables with alter. Use delete_universe_replication instead.&quot;,</a>
<a name="ln2928">              req-&gt;ShortDebugString(), MasterError(MasterErrorPB::INVALID_REQUEST));</a>
<a name="ln2929">        } else if (streams_to_remove.empty()) {</a>
<a name="ln2930">          // If this doesn't delete anything, notify the user.</a>
<a name="ln2931">          return STATUS(InvalidArgument, &quot;Removal matched no entries.&quot;,</a>
<a name="ln2932">                        req-&gt;ShortDebugString(), MasterError(MasterErrorPB::INVALID_REQUEST));</a>
<a name="ln2933">        }</a>
<a name="ln2934">        for (auto&amp; key : streams_to_remove) {</a>
<a name="ln2935">          stream_map-&gt;erase(stream_map-&gt;find(key));</a>
<a name="ln2936">        }</a>
<a name="ln2937">      }</a>
<a name="ln2938">      cl-&gt;mutable_data()-&gt;pb.set_version(cl-&gt;mutable_data()-&gt;pb.version() + 1);</a>
<a name="ln2939">      RETURN_NOT_OK(CheckStatus(</a>
<a name="ln2940">          sys_catalog_-&gt;UpdateItem(cluster_config_.get(), leader_ready_term()),</a>
<a name="ln2941">          &quot;updating cluster config in sys-catalog&quot;));</a>
<a name="ln2942">      cl-&gt;Commit();</a>
<a name="ln2943">    }</a>
<a name="ln2944">    // 2. Remove from Master Configs on Producer and Consumer.</a>
<a name="ln2945">    {</a>
<a name="ln2946">      auto l = original_ri-&gt;LockForWrite();</a>
<a name="ln2947">      if (!l-&gt;data().pb.table_streams().empty()) {</a>
<a name="ln2948">        // Delete Relevant Table-&gt;StreamID mappings on Consumer.</a>
<a name="ln2949">        auto table_streams = l-&gt;mutable_data()-&gt;pb.mutable_table_streams();</a>
<a name="ln2950">        auto validated_tables = l-&gt;mutable_data()-&gt;pb.mutable_validated_tables();</a>
<a name="ln2951">        for (auto&amp; key : table_ids_to_remove) {</a>
<a name="ln2952">          table_streams-&gt;erase(table_streams-&gt;find(key));</a>
<a name="ln2953">          validated_tables-&gt;erase(validated_tables-&gt;find(key));</a>
<a name="ln2954">        }</a>
<a name="ln2955">        for (int i = 0; i &lt; l-&gt;mutable_data()-&gt;pb.tables_size(); i++) {</a>
<a name="ln2956">          if (table_ids_to_remove.count(l-&gt;mutable_data()-&gt;pb.tables(i)) &gt; 0) {</a>
<a name="ln2957">            l-&gt;mutable_data()-&gt;pb.mutable_tables()-&gt;DeleteSubrange(i, 1);</a>
<a name="ln2958">            --i;</a>
<a name="ln2959">          }</a>
<a name="ln2960">        }</a>
<a name="ln2961">        // Delete CDC stream config on the Producer.</a>
<a name="ln2962">        auto result = original_ri-&gt;GetOrCreateCDCRpcTasks(l-&gt;data().pb.producer_master_addresses());</a>
<a name="ln2963">        if (!result.ok()) {</a>
<a name="ln2964">          LOG(WARNING) &lt;&lt; &quot;Unable to create cdc rpc task. CDC streams won't be deleted: &quot; &lt;&lt; result;</a>
<a name="ln2965">        } else {</a>
<a name="ln2966">          auto s = (*result)-&gt;client()-&gt;DeleteCDCStream(streams_to_remove);</a>
<a name="ln2967">          if (!s.ok()) {</a>
<a name="ln2968">            std::stringstream os;</a>
<a name="ln2969">            std::copy(streams_to_remove.begin(), streams_to_remove.end(),</a>
<a name="ln2970">                      std::ostream_iterator&lt;CDCStreamId&gt;(os, &quot;, &quot;));</a>
<a name="ln2971">            LOG(WARNING) &lt;&lt; &quot;Unable to delete CDC streams: &quot; &lt;&lt; os.str() &lt;&lt; s;</a>
<a name="ln2972">          }</a>
<a name="ln2973">        }</a>
<a name="ln2974">      }</a>
<a name="ln2975">      RETURN_NOT_OK(CheckStatus(</a>
<a name="ln2976">          sys_catalog_-&gt;UpdateItem(original_ri.get(), leader_ready_term()),</a>
<a name="ln2977">          &quot;updating universe replication info in sys-catalog&quot;));</a>
<a name="ln2978">      l-&gt;Commit();</a>
<a name="ln2979">    }</a>
<a name="ln2980">  } else if (req-&gt;producer_table_ids_to_add_size() &gt; 0) {</a>
<a name="ln2981">    // 'add_table'</a>
<a name="ln2982">    string alter_producer_id = req-&gt;producer_id() + &quot;.ALTER&quot;;</a>
<a name="ln2983"> </a>
<a name="ln2984">    // Verify no 'alter' command running.</a>
<a name="ln2985">    scoped_refptr&lt;UniverseReplicationInfo&gt; alter_ri;</a>
<a name="ln2986">    {</a>
<a name="ln2987">      std::shared_lock&lt;LockType&gt; l(lock_);</a>
<a name="ln2988">      alter_ri = FindPtrOrNull(universe_replication_map_, alter_producer_id);</a>
<a name="ln2989">    }</a>
<a name="ln2990">    {</a>
<a name="ln2991">      if (alter_ri != nullptr) {</a>
<a name="ln2992">        LOG(INFO) &lt;&lt; &quot;Found &quot; &lt;&lt; alter_producer_id &lt;&lt; &quot;... Removing&quot;;</a>
<a name="ln2993">        if (alter_ri-&gt;LockForRead()-&gt;data().is_deleted_or_failed()) {</a>
<a name="ln2994">          // Delete previous Alter if it's completed but failed.</a>
<a name="ln2995">          master::DeleteUniverseReplicationRequestPB delete_req;</a>
<a name="ln2996">          delete_req.set_producer_id(alter_ri-&gt;id());</a>
<a name="ln2997">          master::DeleteUniverseReplicationResponsePB delete_resp;</a>
<a name="ln2998">          Status s = DeleteUniverseReplication(&amp;delete_req, &amp;delete_resp, rpc);</a>
<a name="ln2999">          if (!s.ok()) {</a>
<a name="ln3000">            resp-&gt;mutable_error()-&gt;Swap(delete_resp.mutable_error());</a>
<a name="ln3001">            return s;</a>
<a name="ln3002">          }</a>
<a name="ln3003">        } else {</a>
<a name="ln3004">          return STATUS(InvalidArgument, &quot;Alter for CDC producer currently running&quot;,</a>
<a name="ln3005">                        req-&gt;ShortDebugString(), MasterError(MasterErrorPB::INVALID_REQUEST));</a>
<a name="ln3006">        }</a>
<a name="ln3007">      }</a>
<a name="ln3008">    }</a>
<a name="ln3009">    // Only add new tables.  Ignore tables that are currently being replicated.</a>
<a name="ln3010">    auto tid_iter = req-&gt;producer_table_ids_to_add();</a>
<a name="ln3011">    unordered_set&lt;string&gt; new_tables(tid_iter.begin(), tid_iter.end());</a>
<a name="ln3012">    {</a>
<a name="ln3013">      auto l = original_ri-&gt;LockForRead();</a>
<a name="ln3014">      for(auto t : l-&gt;data().pb.tables()) {</a>
<a name="ln3015">        auto pos = new_tables.find(t);</a>
<a name="ln3016">        if (pos != new_tables.end()) {</a>
<a name="ln3017">          new_tables.erase(pos);</a>
<a name="ln3018">        }</a>
<a name="ln3019">      }</a>
<a name="ln3020">    }</a>
<a name="ln3021">    if (new_tables.empty()) {</a>
<a name="ln3022">      return STATUS(InvalidArgument, &quot;CDC producer already contains all requested tables&quot;,</a>
<a name="ln3023">                    req-&gt;ShortDebugString(), MasterError(MasterErrorPB::INVALID_REQUEST));</a>
<a name="ln3024">    }</a>
<a name="ln3025"> </a>
<a name="ln3026">    // 1. create an ALTER table request that mirrors the original 'setup_replication'.</a>
<a name="ln3027">    master::SetupUniverseReplicationRequestPB setup_req;</a>
<a name="ln3028">    master::SetupUniverseReplicationResponsePB setup_resp;</a>
<a name="ln3029">    setup_req.set_producer_id(alter_producer_id);</a>
<a name="ln3030">    setup_req.mutable_producer_master_addresses()-&gt;CopyFrom(</a>
<a name="ln3031">        original_ri-&gt;LockForRead()-&gt;data().pb.producer_master_addresses());</a>
<a name="ln3032">    for (auto t : new_tables) {</a>
<a name="ln3033">      setup_req.add_producer_table_ids(t);</a>
<a name="ln3034">    }</a>
<a name="ln3035"> </a>
<a name="ln3036">    // 2. run the 'setup_replication' pipeline on the ALTER Table</a>
<a name="ln3037">    Status s = SetupUniverseReplication(&amp;setup_req, &amp;setup_resp, rpc);</a>
<a name="ln3038">    if (!s.ok()) {</a>
<a name="ln3039">      resp-&gt;mutable_error()-&gt;Swap(setup_resp.mutable_error());</a>
<a name="ln3040">      return s;</a>
<a name="ln3041">    }</a>
<a name="ln3042">    // NOTE: ALTER merges back into original after completion.</a>
<a name="ln3043">  }</a>
<a name="ln3044"> </a>
<a name="ln3045">  return Status::OK();</a>
<a name="ln3046">}</a>
<a name="ln3047"> </a>
<a name="ln3048">Status CatalogManager::GetUniverseReplication(const GetUniverseReplicationRequestPB* req,</a>
<a name="ln3049">                                              GetUniverseReplicationResponsePB* resp,</a>
<a name="ln3050">                                              rpc::RpcContext* rpc) {</a>
<a name="ln3051">  LOG(INFO) &lt;&lt; &quot;GetUniverseReplication from &quot; &lt;&lt; RequestorString(rpc)</a>
<a name="ln3052">            &lt;&lt; &quot;: &quot; &lt;&lt; req-&gt;DebugString();</a>
<a name="ln3053">  RETURN_NOT_OK(CheckOnline());</a>
<a name="ln3054"> </a>
<a name="ln3055">  if (!req-&gt;has_producer_id()) {</a>
<a name="ln3056">    return STATUS(InvalidArgument, &quot;Producer universe ID must be provided&quot;,</a>
<a name="ln3057">                  req-&gt;ShortDebugString(), MasterError(MasterErrorPB::INVALID_REQUEST));</a>
<a name="ln3058">  }</a>
<a name="ln3059"> </a>
<a name="ln3060">  scoped_refptr&lt;UniverseReplicationInfo&gt; universe;</a>
<a name="ln3061">  {</a>
<a name="ln3062">    std::shared_lock&lt;LockType&gt; l(lock_);</a>
<a name="ln3063"> </a>
<a name="ln3064">    universe = FindPtrOrNull(universe_replication_map_, req-&gt;producer_id());</a>
<a name="ln3065">    if (universe == nullptr) {</a>
<a name="ln3066">      return STATUS(NotFound, &quot;Could not find CDC producer universe&quot;,</a>
<a name="ln3067">                    req-&gt;ShortDebugString(), MasterError(MasterErrorPB::OBJECT_NOT_FOUND));</a>
<a name="ln3068">    }</a>
<a name="ln3069">  }</a>
<a name="ln3070"> </a>
<a name="ln3071">  auto l = universe-&gt;LockForRead();</a>
<a name="ln3072">  resp-&gt;mutable_entry()-&gt;CopyFrom(l-&gt;data().pb);</a>
<a name="ln3073">  return Status::OK();</a>
<a name="ln3074">}</a>
<a name="ln3075"> </a>
<a name="ln3076">void CatalogManager::Started() {</a>
<a name="ln3077">  snapshot_coordinator_.Start();</a>
<a name="ln3078">}</a>
<a name="ln3079"> </a>
<a name="ln3080">} // namespace enterprise</a>
<a name="ln3081">}  // namespace master</a>
<a name="ln3082">}  // namespace yb</a>

</code></pre>
<div class="balloon" rel="122"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="147"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="199"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="219"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="330"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="669"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="681"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="757"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="872"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1014"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1074"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1076"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1080"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1101"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1150"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v561/" target="_blank">V561</a> It's probably better to assign value to 'l' variable than to declare it anew. Previous declaration: catalog_manager_ent.cc, line 1145.</p></div>
<div class="balloon" rel="1170"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1181"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1185"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1354"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1419"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1430"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1519"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1682"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="2139"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
