
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>plain_table_reader.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Copyright (c) 2011 The LevelDB Authors. All rights reserved.</a>
<a name="ln2">// Use of this source code is governed by a BSD-style license that can be</a>
<a name="ln3">// found in the LICENSE file. See the AUTHORS file for names of contributors.</a>
<a name="ln4">//</a>
<a name="ln5">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln6">//</a>
<a name="ln7">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln8">//</a>
<a name="ln9">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln10">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln11">//</a>
<a name="ln12">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln13">//</a>
<a name="ln14">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln15">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln16">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln17">// under the License.</a>
<a name="ln18">//</a>
<a name="ln19"> </a>
<a name="ln20">#ifndef ROCKSDB_LITE</a>
<a name="ln21"> </a>
<a name="ln22">#include &quot;yb/rocksdb/table/plain_table_reader.h&quot;</a>
<a name="ln23"> </a>
<a name="ln24">#include &lt;string&gt;</a>
<a name="ln25">#include &lt;vector&gt;</a>
<a name="ln26"> </a>
<a name="ln27">#include &quot;yb/rocksdb/db/dbformat.h&quot;</a>
<a name="ln28"> </a>
<a name="ln29">#include &quot;yb/rocksdb/cache.h&quot;</a>
<a name="ln30">#include &quot;yb/rocksdb/comparator.h&quot;</a>
<a name="ln31">#include &quot;yb/rocksdb/env.h&quot;</a>
<a name="ln32">#include &quot;yb/rocksdb/filter_policy.h&quot;</a>
<a name="ln33">#include &quot;yb/rocksdb/options.h&quot;</a>
<a name="ln34">#include &quot;yb/rocksdb/statistics.h&quot;</a>
<a name="ln35"> </a>
<a name="ln36">#include &quot;yb/rocksdb/table/block.h&quot;</a>
<a name="ln37">#include &quot;yb/rocksdb/table/bloom_block.h&quot;</a>
<a name="ln38">#include &quot;yb/rocksdb/table/filter_block.h&quot;</a>
<a name="ln39">#include &quot;yb/rocksdb/table/format.h&quot;</a>
<a name="ln40">#include &quot;yb/rocksdb/table/internal_iterator.h&quot;</a>
<a name="ln41">#include &quot;yb/rocksdb/table/meta_blocks.h&quot;</a>
<a name="ln42">#include &quot;yb/rocksdb/table/two_level_iterator.h&quot;</a>
<a name="ln43">#include &quot;yb/rocksdb/table/plain_table_factory.h&quot;</a>
<a name="ln44">#include &quot;yb/rocksdb/table/plain_table_key_coding.h&quot;</a>
<a name="ln45">#include &quot;yb/rocksdb/table/get_context.h&quot;</a>
<a name="ln46"> </a>
<a name="ln47">#include &quot;yb/rocksdb/util/arena.h&quot;</a>
<a name="ln48">#include &quot;yb/rocksdb/util/coding.h&quot;</a>
<a name="ln49">#include &quot;yb/rocksdb/util/dynamic_bloom.h&quot;</a>
<a name="ln50">#include &quot;yb/rocksdb/util/hash.h&quot;</a>
<a name="ln51">#include &quot;yb/rocksdb/util/histogram.h&quot;</a>
<a name="ln52">#include &quot;yb/rocksdb/util/murmurhash.h&quot;</a>
<a name="ln53">#include &quot;yb/rocksdb/util/perf_context_imp.h&quot;</a>
<a name="ln54">#include &quot;yb/rocksdb/util/stop_watch.h&quot;</a>
<a name="ln55"> </a>
<a name="ln56">#include &quot;yb/util/mem_tracker.h&quot;</a>
<a name="ln57">#include &quot;yb/util/string_util.h&quot;</a>
<a name="ln58"> </a>
<a name="ln59"> </a>
<a name="ln60">namespace rocksdb {</a>
<a name="ln61"> </a>
<a name="ln62">namespace {</a>
<a name="ln63"> </a>
<a name="ln64">// Safely getting a uint32_t element from a char array, where, starting from</a>
<a name="ln65">// `base`, every 4 bytes are considered as an fixed 32 bit integer.</a>
<a name="ln66">inline uint32_t GetFixed32Element(const char* base, size_t offset) {</a>
<a name="ln67">  return DecodeFixed32(base + offset * sizeof(uint32_t));</a>
<a name="ln68">}</a>
<a name="ln69">}  // namespace</a>
<a name="ln70"> </a>
<a name="ln71">// Iterator to iterate IndexedTable</a>
<a name="ln72">class PlainTableIterator : public InternalIterator {</a>
<a name="ln73"> public:</a>
<a name="ln74">  explicit PlainTableIterator(PlainTableReader* table, bool use_prefix_seek);</a>
<a name="ln75">  ~PlainTableIterator();</a>
<a name="ln76"> </a>
<a name="ln77">  bool Valid() const override;</a>
<a name="ln78"> </a>
<a name="ln79">  void SeekToFirst() override;</a>
<a name="ln80"> </a>
<a name="ln81">  void SeekToLast() override;</a>
<a name="ln82"> </a>
<a name="ln83">  void Seek(const Slice&amp; target) override;</a>
<a name="ln84"> </a>
<a name="ln85">  void Next() override;</a>
<a name="ln86"> </a>
<a name="ln87">  void Prev() override;</a>
<a name="ln88"> </a>
<a name="ln89">  Slice key() const override;</a>
<a name="ln90"> </a>
<a name="ln91">  Slice value() const override;</a>
<a name="ln92"> </a>
<a name="ln93">  Status status() const override;</a>
<a name="ln94"> </a>
<a name="ln95"> private:</a>
<a name="ln96">  PlainTableReader* table_;</a>
<a name="ln97">  PlainTableKeyDecoder decoder_;</a>
<a name="ln98">  bool use_prefix_seek_;</a>
<a name="ln99">  uint32_t offset_;</a>
<a name="ln100">  uint32_t next_offset_;</a>
<a name="ln101">  Slice key_;</a>
<a name="ln102">  Slice value_;</a>
<a name="ln103">  Status status_;</a>
<a name="ln104">  // No copying allowed</a>
<a name="ln105">  PlainTableIterator(const PlainTableIterator&amp;) = delete;</a>
<a name="ln106">  void operator=(const Iterator&amp;) = delete;</a>
<a name="ln107">};</a>
<a name="ln108"> </a>
<a name="ln109">extern const uint64_t kPlainTableMagicNumber;</a>
<a name="ln110">PlainTableReader::PlainTableReader(const ImmutableCFOptions&amp; ioptions,</a>
<a name="ln111">                                   unique_ptr&lt;RandomAccessFileReader&gt;&amp;&amp; file,</a>
<a name="ln112">                                   const EnvOptions&amp; storage_options,</a>
<a name="ln113">                                   const InternalKeyComparatorPtr&amp; icomparator,</a>
<a name="ln114">                                   EncodingType encoding_type,</a>
<a name="ln115">                                   uint64_t file_size,</a>
<a name="ln116">                                   const TableProperties* table_properties)</a>
<a name="ln117">    : internal_comparator_(icomparator),</a>
<a name="ln118">      encoding_type_(encoding_type),</a>
<a name="ln119">      full_scan_mode_(false),</a>
<a name="ln120">      user_key_len_(static_cast&lt;uint32_t&gt;(table_properties-&gt;fixed_key_len)),</a>
<a name="ln121">      prefix_extractor_(ioptions.prefix_extractor),</a>
<a name="ln122">      enable_bloom_(false),</a>
<a name="ln123">      bloom_(6, nullptr),</a>
<a name="ln124">      file_info_(std::move(file), storage_options,</a>
<a name="ln125">                 static_cast&lt;uint32_t&gt;(table_properties-&gt;data_size)),</a>
<a name="ln126">      ioptions_(ioptions),</a>
<a name="ln127">      file_size_(file_size),</a>
<a name="ln128">      table_properties_(nullptr) {</a>
<a name="ln129">  if (ioptions.mem_tracker) {</a>
<a name="ln130">    mem_tracker_ = yb::MemTracker::FindOrCreateTracker(&quot;PlainTableReader&quot;, ioptions.mem_tracker);</a>
<a name="ln131">  }</a>
<a name="ln132">}</a>
<a name="ln133"> </a>
<a name="ln134">PlainTableReader::~PlainTableReader() {</a>
<a name="ln135">  if (mem_tracker_ &amp;&amp; tracked_consumption_) {</a>
<a name="ln136">    mem_tracker_-&gt;Release(tracked_consumption_);</a>
<a name="ln137">  }</a>
<a name="ln138">}</a>
<a name="ln139"> </a>
<a name="ln140">Status PlainTableReader::Open(const ImmutableCFOptions&amp; ioptions,</a>
<a name="ln141">                              const EnvOptions&amp; env_options,</a>
<a name="ln142">                              const InternalKeyComparatorPtr&amp; internal_comparator,</a>
<a name="ln143">                              unique_ptr&lt;RandomAccessFileReader&gt;&amp;&amp; file,</a>
<a name="ln144">                              uint64_t file_size,</a>
<a name="ln145">                              unique_ptr&lt;TableReader&gt;* table_reader,</a>
<a name="ln146">                              const int bloom_bits_per_key,</a>
<a name="ln147">                              double hash_table_ratio, size_t index_sparseness,</a>
<a name="ln148">                              size_t huge_page_tlb_size, bool full_scan_mode) {</a>
<a name="ln149">  if (file_size &gt; PlainTableIndex::kMaxFileSize) {</a>
<a name="ln150">    return STATUS(NotSupported, &quot;File is too large for PlainTableReader!&quot;);</a>
<a name="ln151">  }</a>
<a name="ln152"> </a>
<a name="ln153">  TableProperties* props = nullptr;</a>
<a name="ln154">  auto s = ReadTableProperties(file.get(), file_size, kPlainTableMagicNumber,</a>
<a name="ln155">                               ioptions.env, ioptions.info_log, &amp;props);</a>
<a name="ln156">  if (!s.ok()) {</a>
<a name="ln157">    return s;</a>
<a name="ln158">  }</a>
<a name="ln159"> </a>
<a name="ln160">  assert(hash_table_ratio &gt;= 0.0);</a>
<a name="ln161">  auto&amp; user_props = props-&gt;user_collected_properties;</a>
<a name="ln162">  auto prefix_extractor_in_file =</a>
<a name="ln163">      user_props.find(PlainTablePropertyNames::kPrefixExtractorName);</a>
<a name="ln164"> </a>
<a name="ln165">  if (!full_scan_mode &amp;&amp; prefix_extractor_in_file != user_props.end()) {</a>
<a name="ln166">    if (!ioptions.prefix_extractor) {</a>
<a name="ln167">      return STATUS(InvalidArgument,</a>
<a name="ln168">          &quot;Prefix extractor is missing when opening a PlainTable built &quot;</a>
<a name="ln169">          &quot;using a prefix extractor&quot;);</a>
<a name="ln170">    } else if (prefix_extractor_in_file-&gt;second.compare(</a>
<a name="ln171">                   ioptions.prefix_extractor-&gt;Name()) != 0) {</a>
<a name="ln172">      return STATUS(InvalidArgument,</a>
<a name="ln173">          &quot;Prefix extractor given doesn't match the one used to build &quot;</a>
<a name="ln174">          &quot;PlainTable&quot;);</a>
<a name="ln175">    }</a>
<a name="ln176">  }</a>
<a name="ln177"> </a>
<a name="ln178">  EncodingType encoding_type = kPlain;</a>
<a name="ln179">  auto encoding_type_prop =</a>
<a name="ln180">      user_props.find(PlainTablePropertyNames::kEncodingType);</a>
<a name="ln181">  if (encoding_type_prop != user_props.end()) {</a>
<a name="ln182">    encoding_type = static_cast&lt;EncodingType&gt;(</a>
<a name="ln183">        DecodeFixed32(encoding_type_prop-&gt;second.c_str()));</a>
<a name="ln184">  }</a>
<a name="ln185"> </a>
<a name="ln186">  std::unique_ptr&lt;PlainTableReader&gt; new_reader(new PlainTableReader(</a>
<a name="ln187">      ioptions, std::move(file), env_options, internal_comparator,</a>
<a name="ln188">      encoding_type, file_size, props));</a>
<a name="ln189"> </a>
<a name="ln190">  s = new_reader-&gt;MmapDataIfNeeded();</a>
<a name="ln191">  if (!s.ok()) {</a>
<a name="ln192">    return s;</a>
<a name="ln193">  }</a>
<a name="ln194"> </a>
<a name="ln195">  if (!full_scan_mode) {</a>
<a name="ln196">    s = new_reader-&gt;PopulateIndex(props, bloom_bits_per_key, hash_table_ratio,</a>
<a name="ln197">                                  index_sparseness, huge_page_tlb_size);</a>
<a name="ln198">    if (!s.ok()) {</a>
<a name="ln199">      return s;</a>
<a name="ln200">    }</a>
<a name="ln201">  } else {</a>
<a name="ln202">    // Flag to indicate it is a full scan mode so that none of the indexes</a>
<a name="ln203">    // can be used.</a>
<a name="ln204">    new_reader-&gt;full_scan_mode_ = true;</a>
<a name="ln205">  }</a>
<a name="ln206"> </a>
<a name="ln207">  *table_reader = std::move(new_reader);</a>
<a name="ln208">  return s;</a>
<a name="ln209">}</a>
<a name="ln210"> </a>
<a name="ln211">void PlainTableReader::SetupForCompaction() {</a>
<a name="ln212">}</a>
<a name="ln213"> </a>
<a name="ln214">InternalIterator* PlainTableReader::NewIterator(const ReadOptions&amp; options,</a>
<a name="ln215">                                                Arena* arena,</a>
<a name="ln216">                                                bool skip_filters) {</a>
<a name="ln217">  if (options.total_order_seek &amp;&amp; !IsTotalOrderMode()) {</a>
<a name="ln218">    return NewErrorInternalIterator(</a>
<a name="ln219">        STATUS(InvalidArgument, &quot;total_order_seek not supported&quot;), arena);</a>
<a name="ln220">  }</a>
<a name="ln221">  if (arena == nullptr) {</a>
<a name="ln222">    return new PlainTableIterator(this, prefix_extractor_ != nullptr);</a>
<a name="ln223">  } else {</a>
<a name="ln224">    auto mem = arena-&gt;AllocateAligned(sizeof(PlainTableIterator));</a>
<a name="ln225">    return new (mem) PlainTableIterator(this, prefix_extractor_ != nullptr);</a>
<a name="ln226">  }</a>
<a name="ln227">}</a>
<a name="ln228"> </a>
<a name="ln229">Status PlainTableReader::PopulateIndexRecordList(</a>
<a name="ln230">    PlainTableIndexBuilder* index_builder, vector&lt;uint32_t&gt;* prefix_hashes) {</a>
<a name="ln231">  Slice prev_key_prefix_slice;</a>
<a name="ln232">  std::string prev_key_prefix_buf;</a>
<a name="ln233">  uint32_t pos = data_start_offset_;</a>
<a name="ln234"> </a>
<a name="ln235">  bool is_first_record = true;</a>
<a name="ln236">  Slice key_prefix_slice;</a>
<a name="ln237">  PlainTableKeyDecoder decoder(&amp;file_info_, encoding_type_, user_key_len_,</a>
<a name="ln238">                               ioptions_.prefix_extractor);</a>
<a name="ln239">  while (pos &lt; file_info_.data_end_offset) {</a>
<a name="ln240">    uint32_t key_offset = pos;</a>
<a name="ln241">    ParsedInternalKey key;</a>
<a name="ln242">    Slice value_slice;</a>
<a name="ln243">    bool seekable = false;</a>
<a name="ln244">    Status s = Next(&amp;decoder, &amp;pos, &amp;key, nullptr, &amp;value_slice, &amp;seekable);</a>
<a name="ln245">    if (!s.ok()) {</a>
<a name="ln246">      return s;</a>
<a name="ln247">    }</a>
<a name="ln248"> </a>
<a name="ln249">    key_prefix_slice = GetPrefix(key);</a>
<a name="ln250">    if (enable_bloom_) {</a>
<a name="ln251">      bloom_.AddHash(GetSliceHash(key.user_key));</a>
<a name="ln252">    } else {</a>
<a name="ln253">      if (is_first_record || prev_key_prefix_slice != key_prefix_slice) {</a>
<a name="ln254">        if (!is_first_record) {</a>
<a name="ln255">          prefix_hashes-&gt;push_back(GetSliceHash(prev_key_prefix_slice));</a>
<a name="ln256">        }</a>
<a name="ln257">        if (file_info_.is_mmap_mode) {</a>
<a name="ln258">          prev_key_prefix_slice = key_prefix_slice;</a>
<a name="ln259">        } else {</a>
<a name="ln260">          prev_key_prefix_buf = key_prefix_slice.ToString();</a>
<a name="ln261">          prev_key_prefix_slice = prev_key_prefix_buf;</a>
<a name="ln262">        }</a>
<a name="ln263">      }</a>
<a name="ln264">    }</a>
<a name="ln265"> </a>
<a name="ln266">    index_builder-&gt;AddKeyPrefix(GetPrefix(key), key_offset);</a>
<a name="ln267"> </a>
<a name="ln268">    if (!seekable &amp;&amp; is_first_record) {</a>
<a name="ln269">      return STATUS(Corruption, &quot;Key for a prefix is not seekable&quot;);</a>
<a name="ln270">    }</a>
<a name="ln271"> </a>
<a name="ln272">    is_first_record = false;</a>
<a name="ln273">  }</a>
<a name="ln274"> </a>
<a name="ln275">  prefix_hashes-&gt;push_back(GetSliceHash(key_prefix_slice));</a>
<a name="ln276">  auto s = index_.InitFromRawData(index_builder-&gt;Finish());</a>
<a name="ln277">  return s;</a>
<a name="ln278">}</a>
<a name="ln279"> </a>
<a name="ln280">void PlainTableReader::AllocateAndFillBloom(int bloom_bits_per_key,</a>
<a name="ln281">                                            int num_prefixes,</a>
<a name="ln282">                                            size_t huge_page_tlb_size,</a>
<a name="ln283">                                            vector&lt;uint32_t&gt;* prefix_hashes) {</a>
<a name="ln284">  if (!IsTotalOrderMode()) {</a>
<a name="ln285">    uint32_t bloom_total_bits = num_prefixes * bloom_bits_per_key;</a>
<a name="ln286">    if (bloom_total_bits &gt; 0) {</a>
<a name="ln287">      enable_bloom_ = true;</a>
<a name="ln288">      bloom_.SetTotalBits(&amp;arena_, bloom_total_bits, ioptions_.bloom_locality,</a>
<a name="ln289">                          huge_page_tlb_size, ioptions_.info_log);</a>
<a name="ln290">      FillBloom(prefix_hashes);</a>
<a name="ln291">    }</a>
<a name="ln292">  }</a>
<a name="ln293">}</a>
<a name="ln294"> </a>
<a name="ln295">void PlainTableReader::FillBloom(vector&lt;uint32_t&gt;* prefix_hashes) {</a>
<a name="ln296">  assert(bloom_.IsInitialized());</a>
<a name="ln297">  for (auto prefix_hash : *prefix_hashes) {</a>
<a name="ln298">    bloom_.AddHash(prefix_hash);</a>
<a name="ln299">  }</a>
<a name="ln300">}</a>
<a name="ln301"> </a>
<a name="ln302">Status PlainTableReader::MmapDataIfNeeded() {</a>
<a name="ln303">  if (file_info_.is_mmap_mode) {</a>
<a name="ln304">    // Get mmapped memory.</a>
<a name="ln305">    return file_info_.file-&gt;Read(0, file_size_, &amp;file_info_.file_data, nullptr);</a>
<a name="ln306">  }</a>
<a name="ln307">  return Status::OK();</a>
<a name="ln308">}</a>
<a name="ln309"> </a>
<a name="ln310">Status PlainTableReader::PopulateIndex(TableProperties* props,</a>
<a name="ln311">                                       int bloom_bits_per_key,</a>
<a name="ln312">                                       double hash_table_ratio,</a>
<a name="ln313">                                       size_t index_sparseness,</a>
<a name="ln314">                                       size_t huge_page_tlb_size) {</a>
<a name="ln315">  assert(props != nullptr);</a>
<a name="ln316">  table_properties_.reset(props);</a>
<a name="ln317"> </a>
<a name="ln318">  BlockContents bloom_block_contents;</a>
<a name="ln319">  auto s = ReadMetaBlock(file_info_.file.get(), file_size_,</a>
<a name="ln320">                         kPlainTableMagicNumber, ioptions_.env,</a>
<a name="ln321">                         BloomBlockBuilder::kBloomBlock, mem_tracker_, &amp;bloom_block_contents);</a>
<a name="ln322">  bool index_in_file = s.ok();</a>
<a name="ln323"> </a>
<a name="ln324">  BlockContents index_block_contents;</a>
<a name="ln325">  s = ReadMetaBlock(</a>
<a name="ln326">      file_info_.file.get(), file_size_, kPlainTableMagicNumber, ioptions_.env,</a>
<a name="ln327">      PlainTableIndexBuilder::kPlainTableIndexBlock, mem_tracker_, &amp;index_block_contents);</a>
<a name="ln328"> </a>
<a name="ln329">  index_in_file &amp;= s.ok();</a>
<a name="ln330"> </a>
<a name="ln331">  Slice* bloom_block;</a>
<a name="ln332">  if (index_in_file) {</a>
<a name="ln333">    // If bloom_block_contents.allocation is not empty (which will be the case</a>
<a name="ln334">    // for non-mmap mode), it holds the alloated memory for the bloom block.</a>
<a name="ln335">    // It needs to be kept alive to keep `bloom_block` valid.</a>
<a name="ln336">    bloom_block_alloc_ = std::move(bloom_block_contents.allocation);</a>
<a name="ln337">    bloom_block = &amp;bloom_block_contents.data;</a>
<a name="ln338">    tracked_consumption_ += bloom_block-&gt;size();</a>
<a name="ln339">  } else {</a>
<a name="ln340">    bloom_block = nullptr;</a>
<a name="ln341">  }</a>
<a name="ln342"> </a>
<a name="ln343">  // index_in_file == true only if there are kBloomBlock and</a>
<a name="ln344">  // kPlainTableIndexBlock in file</a>
<a name="ln345">  Slice* index_block;</a>
<a name="ln346">  if (index_in_file) {</a>
<a name="ln347">    // If index_block_contents.allocation is not empty (which will be the case</a>
<a name="ln348">    // for non-mmap mode), it holds the alloated memory for the index block.</a>
<a name="ln349">    // It needs to be kept alive to keep `index_block` valid.</a>
<a name="ln350">    index_block_alloc_ = std::move(index_block_contents.allocation);</a>
<a name="ln351">    index_block = &amp;index_block_contents.data;</a>
<a name="ln352">  } else {</a>
<a name="ln353">    index_block = nullptr;</a>
<a name="ln354">  }</a>
<a name="ln355"> </a>
<a name="ln356">  if ((ioptions_.prefix_extractor == nullptr) &amp;&amp;</a>
<a name="ln357">      (hash_table_ratio != 0)) {</a>
<a name="ln358">    // ioptions.prefix_extractor is requried for a hash-based look-up.</a>
<a name="ln359">    return STATUS(NotSupported,</a>
<a name="ln360">        &quot;PlainTable requires a prefix extractor enable prefix hash mode.&quot;);</a>
<a name="ln361">  }</a>
<a name="ln362"> </a>
<a name="ln363">  // First, read the whole file, for every kIndexIntervalForSamePrefixKeys rows</a>
<a name="ln364">  // for a prefix (starting from the first one), generate a record of (hash,</a>
<a name="ln365">  // offset) and append it to IndexRecordList, which is a data structure created</a>
<a name="ln366">  // to store them.</a>
<a name="ln367"> </a>
<a name="ln368">  if (!index_in_file) {</a>
<a name="ln369">    // Allocate bloom filter here for total order mode.</a>
<a name="ln370">    if (IsTotalOrderMode()) {</a>
<a name="ln371">      uint32_t num_bloom_bits =</a>
<a name="ln372">          static_cast&lt;uint32_t&gt;(table_properties_-&gt;num_entries) *</a>
<a name="ln373">          bloom_bits_per_key;</a>
<a name="ln374">      if (num_bloom_bits &gt; 0) {</a>
<a name="ln375">        enable_bloom_ = true;</a>
<a name="ln376">        bloom_.SetTotalBits(&amp;arena_, num_bloom_bits, ioptions_.bloom_locality,</a>
<a name="ln377">                            huge_page_tlb_size, ioptions_.info_log);</a>
<a name="ln378">      }</a>
<a name="ln379">    }</a>
<a name="ln380">  } else {</a>
<a name="ln381">    enable_bloom_ = true;</a>
<a name="ln382">    auto num_blocks_property = props-&gt;user_collected_properties.find(</a>
<a name="ln383">        PlainTablePropertyNames::kNumBloomBlocks);</a>
<a name="ln384"> </a>
<a name="ln385">    uint32_t num_blocks = 0;</a>
<a name="ln386">    if (num_blocks_property != props-&gt;user_collected_properties.end()) {</a>
<a name="ln387">      Slice temp_slice(num_blocks_property-&gt;second);</a>
<a name="ln388">      if (!GetVarint32(&amp;temp_slice, &amp;num_blocks)) {</a>
<a name="ln389">        num_blocks = 0;</a>
<a name="ln390">      }</a>
<a name="ln391">    }</a>
<a name="ln392">    // cast away const qualifier, because bloom_ won't be changed</a>
<a name="ln393">    bloom_.SetRawData(</a>
<a name="ln394">        const_cast&lt;unsigned char*&gt;(</a>
<a name="ln395">            reinterpret_cast&lt;const unsigned char*&gt;(bloom_block-&gt;data())),</a>
<a name="ln396">        static_cast&lt;uint32_t&gt;(bloom_block-&gt;size()) * 8, num_blocks);</a>
<a name="ln397">  }</a>
<a name="ln398"> </a>
<a name="ln399">  PlainTableIndexBuilder index_builder(&amp;arena_, ioptions_, index_sparseness,</a>
<a name="ln400">                                       hash_table_ratio, huge_page_tlb_size);</a>
<a name="ln401"> </a>
<a name="ln402">  std::vector&lt;uint32_t&gt; prefix_hashes;</a>
<a name="ln403">  if (!index_in_file) {</a>
<a name="ln404">    s = PopulateIndexRecordList(&amp;index_builder, &amp;prefix_hashes);</a>
<a name="ln405">    if (!s.ok()) {</a>
<a name="ln406">      return s;</a>
<a name="ln407">    }</a>
<a name="ln408">  } else {</a>
<a name="ln409">    s = index_.InitFromRawData(*index_block);</a>
<a name="ln410">    if (!s.ok()) {</a>
<a name="ln411">      return s;</a>
<a name="ln412">    }</a>
<a name="ln413">  }</a>
<a name="ln414"> </a>
<a name="ln415">  if (!index_in_file) {</a>
<a name="ln416">    // Calculated bloom filter size and allocate memory for</a>
<a name="ln417">    // bloom filter based on the number of prefixes, then fill it.</a>
<a name="ln418">    AllocateAndFillBloom(bloom_bits_per_key, index_.GetNumPrefixes(),</a>
<a name="ln419">                         huge_page_tlb_size, &amp;prefix_hashes);</a>
<a name="ln420">  }</a>
<a name="ln421"> </a>
<a name="ln422">  // Fill two table properties.</a>
<a name="ln423">  if (!index_in_file) {</a>
<a name="ln424">    props-&gt;user_collected_properties[&quot;plain_table_hash_table_size&quot;] =</a>
<a name="ln425">        ToString(index_.GetIndexSize() * PlainTableIndex::kOffsetLen);</a>
<a name="ln426">    props-&gt;user_collected_properties[&quot;plain_table_sub_index_size&quot;] =</a>
<a name="ln427">        ToString(index_.GetSubIndexSize());</a>
<a name="ln428">  } else {</a>
<a name="ln429">    props-&gt;user_collected_properties[&quot;plain_table_hash_table_size&quot;] =</a>
<a name="ln430">        ToString(0);</a>
<a name="ln431">    props-&gt;user_collected_properties[&quot;plain_table_sub_index_size&quot;] =</a>
<a name="ln432">        ToString(0);</a>
<a name="ln433">  }</a>
<a name="ln434"> </a>
<a name="ln435">  return Status::OK();</a>
<a name="ln436">}</a>
<a name="ln437"> </a>
<a name="ln438">Status PlainTableReader::GetOffset(PlainTableKeyDecoder* decoder,</a>
<a name="ln439">                                   const Slice&amp; target, const Slice&amp; prefix,</a>
<a name="ln440">                                   uint32_t prefix_hash, bool* prefix_matched,</a>
<a name="ln441">                                   uint32_t* offset) const {</a>
<a name="ln442">  *prefix_matched = false;</a>
<a name="ln443">  uint32_t prefix_index_offset;</a>
<a name="ln444">  auto res = index_.GetOffset(prefix_hash, &amp;prefix_index_offset);</a>
<a name="ln445">  if (res == PlainTableIndex::kNoPrefixForBucket) {</a>
<a name="ln446">    *offset = file_info_.data_end_offset;</a>
<a name="ln447">    return Status::OK();</a>
<a name="ln448">  } else if (res == PlainTableIndex::kDirectToFile) {</a>
<a name="ln449">    *offset = prefix_index_offset;</a>
<a name="ln450">    return Status::OK();</a>
<a name="ln451">  }</a>
<a name="ln452"> </a>
<a name="ln453">  // point to sub-index, need to do a binary search</a>
<a name="ln454">  uint32_t upper_bound;</a>
<a name="ln455">  const char* base_ptr =</a>
<a name="ln456">      index_.GetSubIndexBasePtrAndUpperBound(prefix_index_offset, &amp;upper_bound);</a>
<a name="ln457">  uint32_t low = 0;</a>
<a name="ln458">  uint32_t high = upper_bound;</a>
<a name="ln459">  ParsedInternalKey mid_key;</a>
<a name="ln460">  ParsedInternalKey parsed_target;</a>
<a name="ln461">  if (!ParseInternalKey(target, &amp;parsed_target)) {</a>
<a name="ln462">    return STATUS(Corruption, Slice());</a>
<a name="ln463">  }</a>
<a name="ln464"> </a>
<a name="ln465">  // The key is between [low, high). Do a binary search between it.</a>
<a name="ln466">  while (high - low &gt; 1) {</a>
<a name="ln467">    uint32_t mid = (high + low) / 2;</a>
<a name="ln468">    uint32_t file_offset = GetFixed32Element(base_ptr, mid);</a>
<a name="ln469">    uint32_t tmp;</a>
<a name="ln470">    Status s = decoder-&gt;NextKeyNoValue(file_offset, &amp;mid_key, nullptr, &amp;tmp);</a>
<a name="ln471">    if (!s.ok()) {</a>
<a name="ln472">      return s;</a>
<a name="ln473">    }</a>
<a name="ln474">    int cmp_result = internal_comparator_-&gt;Compare(mid_key, parsed_target);</a>
<a name="ln475">    if (cmp_result &lt; 0) {</a>
<a name="ln476">      low = mid;</a>
<a name="ln477">    } else {</a>
<a name="ln478">      if (cmp_result == 0) {</a>
<a name="ln479">        // Happen to have found the exact key or target is smaller than the</a>
<a name="ln480">        // first key after base_offset.</a>
<a name="ln481">        *prefix_matched = true;</a>
<a name="ln482">        *offset = file_offset;</a>
<a name="ln483">        return Status::OK();</a>
<a name="ln484">      } else {</a>
<a name="ln485">        high = mid;</a>
<a name="ln486">      }</a>
<a name="ln487">    }</a>
<a name="ln488">  }</a>
<a name="ln489">  // Both of the key at the position low or low+1 could share the same</a>
<a name="ln490">  // prefix as target. We need to rule out one of them to avoid to go</a>
<a name="ln491">  // to the wrong prefix.</a>
<a name="ln492">  ParsedInternalKey low_key;</a>
<a name="ln493">  uint32_t tmp;</a>
<a name="ln494">  uint32_t low_key_offset = GetFixed32Element(base_ptr, low);</a>
<a name="ln495">  Status s = decoder-&gt;NextKeyNoValue(low_key_offset, &amp;low_key, nullptr, &amp;tmp);</a>
<a name="ln496">  if (!s.ok()) {</a>
<a name="ln497">    return s;</a>
<a name="ln498">  }</a>
<a name="ln499"> </a>
<a name="ln500">  if (GetPrefix(low_key) == prefix) {</a>
<a name="ln501">    *prefix_matched = true;</a>
<a name="ln502">    *offset = low_key_offset;</a>
<a name="ln503">  } else if (low + 1 &lt; upper_bound) {</a>
<a name="ln504">    // There is possible a next prefix, return it</a>
<a name="ln505">    *prefix_matched = false;</a>
<a name="ln506">    *offset = GetFixed32Element(base_ptr, low + 1);</a>
<a name="ln507">  } else {</a>
<a name="ln508">    // target is larger than a key of the last prefix in this bucket</a>
<a name="ln509">    // but with a different prefix. Key does not exist.</a>
<a name="ln510">    *offset = file_info_.data_end_offset;</a>
<a name="ln511">  }</a>
<a name="ln512">  return Status::OK();</a>
<a name="ln513">}</a>
<a name="ln514"> </a>
<a name="ln515">bool PlainTableReader::MatchBloom(uint32_t hash) const {</a>
<a name="ln516">  if (!enable_bloom_) {</a>
<a name="ln517">    return true;</a>
<a name="ln518">  }</a>
<a name="ln519"> </a>
<a name="ln520">  if (bloom_.MayContainHash(hash)) {</a>
<a name="ln521">    PERF_COUNTER_ADD(bloom_sst_hit_count, 1);</a>
<a name="ln522">    return true;</a>
<a name="ln523">  } else {</a>
<a name="ln524">    PERF_COUNTER_ADD(bloom_sst_miss_count, 1);</a>
<a name="ln525">    return false;</a>
<a name="ln526">  }</a>
<a name="ln527">}</a>
<a name="ln528"> </a>
<a name="ln529">Status PlainTableReader::Next(PlainTableKeyDecoder* decoder, uint32_t* offset,</a>
<a name="ln530">                              ParsedInternalKey* parsed_key,</a>
<a name="ln531">                              Slice* internal_key, Slice* value,</a>
<a name="ln532">                              bool* seekable) const {</a>
<a name="ln533">  if (*offset == file_info_.data_end_offset) {</a>
<a name="ln534">    *offset = file_info_.data_end_offset;</a>
<a name="ln535">    return Status::OK();</a>
<a name="ln536">  }</a>
<a name="ln537"> </a>
<a name="ln538">  if (*offset &gt; file_info_.data_end_offset) {</a>
<a name="ln539">    return STATUS(Corruption, &quot;Offset is out of file size&quot;);</a>
<a name="ln540">  }</a>
<a name="ln541"> </a>
<a name="ln542">  uint32_t bytes_read;</a>
<a name="ln543">  Status s = decoder-&gt;NextKey(*offset, parsed_key, internal_key, value,</a>
<a name="ln544">                              &amp;bytes_read, seekable);</a>
<a name="ln545">  if (!s.ok()) {</a>
<a name="ln546">    return s;</a>
<a name="ln547">  }</a>
<a name="ln548">  *offset = *offset + bytes_read;</a>
<a name="ln549">  return Status::OK();</a>
<a name="ln550">}</a>
<a name="ln551"> </a>
<a name="ln552">void PlainTableReader::Prepare(const Slice&amp; target) {</a>
<a name="ln553">  if (enable_bloom_) {</a>
<a name="ln554">    uint32_t prefix_hash = GetSliceHash(GetPrefix(target));</a>
<a name="ln555">    bloom_.Prefetch(prefix_hash);</a>
<a name="ln556">  }</a>
<a name="ln557">}</a>
<a name="ln558"> </a>
<a name="ln559">Status PlainTableReader::Get(const ReadOptions&amp; ro, const Slice&amp; target,</a>
<a name="ln560">                             GetContext* get_context, bool skip_filters) {</a>
<a name="ln561">  // Check bloom filter first.</a>
<a name="ln562">  Slice prefix_slice;</a>
<a name="ln563">  uint32_t prefix_hash;</a>
<a name="ln564">  if (IsTotalOrderMode()) {</a>
<a name="ln565">    if (full_scan_mode_) {</a>
<a name="ln566">      status_ =</a>
<a name="ln567">          STATUS(InvalidArgument, &quot;Get() is not allowed in full scan mode.&quot;);</a>
<a name="ln568">    }</a>
<a name="ln569">    // Match whole user key for bloom filter check.</a>
<a name="ln570">    if (!MatchBloom(GetSliceHash(GetUserKey(target)))) {</a>
<a name="ln571">      return Status::OK();</a>
<a name="ln572">    }</a>
<a name="ln573">    // in total order mode, there is only one bucket 0, and we always use empty</a>
<a name="ln574">    // prefix.</a>
<a name="ln575">    prefix_slice = Slice();</a>
<a name="ln576">    prefix_hash = 0;</a>
<a name="ln577">  } else {</a>
<a name="ln578">    prefix_slice = GetPrefix(target);</a>
<a name="ln579">    prefix_hash = GetSliceHash(prefix_slice);</a>
<a name="ln580">    if (!MatchBloom(prefix_hash)) {</a>
<a name="ln581">      return Status::OK();</a>
<a name="ln582">    }</a>
<a name="ln583">  }</a>
<a name="ln584">  uint32_t offset;</a>
<a name="ln585">  bool prefix_match;</a>
<a name="ln586">  PlainTableKeyDecoder decoder(&amp;file_info_, encoding_type_, user_key_len_,</a>
<a name="ln587">                               ioptions_.prefix_extractor);</a>
<a name="ln588">  Status s = GetOffset(&amp;decoder, target, prefix_slice, prefix_hash,</a>
<a name="ln589">                       &amp;prefix_match, &amp;offset);</a>
<a name="ln590"> </a>
<a name="ln591">  if (!s.ok()) {</a>
<a name="ln592">    return s;</a>
<a name="ln593">  }</a>
<a name="ln594">  ParsedInternalKey found_key;</a>
<a name="ln595">  ParsedInternalKey parsed_target;</a>
<a name="ln596">  if (!ParseInternalKey(target, &amp;parsed_target)) {</a>
<a name="ln597">    return STATUS(Corruption, Slice());</a>
<a name="ln598">  }</a>
<a name="ln599">  Slice found_value;</a>
<a name="ln600">  while (offset &lt; file_info_.data_end_offset) {</a>
<a name="ln601">    s = Next(&amp;decoder, &amp;offset, &amp;found_key, nullptr, &amp;found_value);</a>
<a name="ln602">    if (!s.ok()) {</a>
<a name="ln603">      return s;</a>
<a name="ln604">    }</a>
<a name="ln605">    if (!prefix_match) {</a>
<a name="ln606">      // Need to verify prefix for the first key found if it is not yet</a>
<a name="ln607">      // checked.</a>
<a name="ln608">      if (GetPrefix(found_key) != prefix_slice) {</a>
<a name="ln609">        return Status::OK();</a>
<a name="ln610">      }</a>
<a name="ln611">      prefix_match = true;</a>
<a name="ln612">    }</a>
<a name="ln613">    // TODO(ljin): since we know the key comparison result here,</a>
<a name="ln614">    // can we enable the fast path?</a>
<a name="ln615">    if (internal_comparator_-&gt;Compare(found_key, parsed_target) &gt;= 0) {</a>
<a name="ln616">      if (!get_context-&gt;SaveValue(found_key, found_value)) {</a>
<a name="ln617">        break;</a>
<a name="ln618">      }</a>
<a name="ln619">    }</a>
<a name="ln620">  }</a>
<a name="ln621">  return Status::OK();</a>
<a name="ln622">}</a>
<a name="ln623"> </a>
<a name="ln624">uint64_t PlainTableReader::ApproximateOffsetOf(const Slice&amp; key) {</a>
<a name="ln625">  return 0;</a>
<a name="ln626">}</a>
<a name="ln627"> </a>
<a name="ln628">PlainTableIterator::PlainTableIterator(PlainTableReader* table,</a>
<a name="ln629">                                       bool use_prefix_seek)</a>
<a name="ln630">    : table_(table),</a>
<a name="ln631">      decoder_(&amp;table_-&gt;file_info_, table_-&gt;encoding_type_,</a>
<a name="ln632">               table_-&gt;user_key_len_, table_-&gt;prefix_extractor_),</a>
<a name="ln633">      use_prefix_seek_(use_prefix_seek) {</a>
<a name="ln634">  next_offset_ = offset_ = table_-&gt;file_info_.data_end_offset;</a>
<a name="ln635">}</a>
<a name="ln636"> </a>
<a name="ln637">PlainTableIterator::~PlainTableIterator() {</a>
<a name="ln638">}</a>
<a name="ln639"> </a>
<a name="ln640">bool PlainTableIterator::Valid() const {</a>
<a name="ln641">  return offset_ &lt; table_-&gt;file_info_.data_end_offset &amp;&amp;</a>
<a name="ln642">         offset_ &gt;= table_-&gt;data_start_offset_;</a>
<a name="ln643">}</a>
<a name="ln644"> </a>
<a name="ln645">void PlainTableIterator::SeekToFirst() {</a>
<a name="ln646">  next_offset_ = table_-&gt;data_start_offset_;</a>
<a name="ln647">  if (next_offset_ &gt;= table_-&gt;file_info_.data_end_offset) {</a>
<a name="ln648">    next_offset_ = offset_ = table_-&gt;file_info_.data_end_offset;</a>
<a name="ln649">  } else {</a>
<a name="ln650">    Next();</a>
<a name="ln651">  }</a>
<a name="ln652">}</a>
<a name="ln653"> </a>
<a name="ln654">void PlainTableIterator::SeekToLast() {</a>
<a name="ln655">  assert(false);</a>
<a name="ln656">  status_ = STATUS(NotSupported, &quot;SeekToLast() is not supported in PlainTable&quot;);</a>
<a name="ln657">}</a>
<a name="ln658"> </a>
<a name="ln659">void PlainTableIterator::Seek(const Slice&amp; target) {</a>
<a name="ln660">  // If the user doesn't set prefix seek option and we are not able to do a</a>
<a name="ln661">  // total Seek(). assert failure.</a>
<a name="ln662">  if (!use_prefix_seek_) {</a>
<a name="ln663">    if (table_-&gt;full_scan_mode_) {</a>
<a name="ln664">      status_ =</a>
<a name="ln665">          STATUS(InvalidArgument, &quot;Seek() is not allowed in full scan mode.&quot;);</a>
<a name="ln666">      offset_ = next_offset_ = table_-&gt;file_info_.data_end_offset;</a>
<a name="ln667">      return;</a>
<a name="ln668">    } else if (table_-&gt;GetIndexSize() &gt; 1) {</a>
<a name="ln669">      assert(false);</a>
<a name="ln670">      status_ = STATUS(NotSupported,</a>
<a name="ln671">          &quot;PlainTable cannot issue non-prefix seek unless in total order &quot;</a>
<a name="ln672">          &quot;mode.&quot;);</a>
<a name="ln673">      offset_ = next_offset_ = table_-&gt;file_info_.data_end_offset;</a>
<a name="ln674">      return;</a>
<a name="ln675">    }</a>
<a name="ln676">  }</a>
<a name="ln677"> </a>
<a name="ln678">  Slice prefix_slice = table_-&gt;GetPrefix(target);</a>
<a name="ln679">  uint32_t prefix_hash = 0;</a>
<a name="ln680">  // Bloom filter is ignored in total-order mode.</a>
<a name="ln681">  if (!table_-&gt;IsTotalOrderMode()) {</a>
<a name="ln682">    prefix_hash = GetSliceHash(prefix_slice);</a>
<a name="ln683">    if (!table_-&gt;MatchBloom(prefix_hash)) {</a>
<a name="ln684">      offset_ = next_offset_ = table_-&gt;file_info_.data_end_offset;</a>
<a name="ln685">      return;</a>
<a name="ln686">    }</a>
<a name="ln687">  }</a>
<a name="ln688">  bool prefix_match;</a>
<a name="ln689">  status_ = table_-&gt;GetOffset(&amp;decoder_, target, prefix_slice, prefix_hash,</a>
<a name="ln690">                              &amp;prefix_match, &amp;next_offset_);</a>
<a name="ln691">  if (!status_.ok()) {</a>
<a name="ln692">    offset_ = next_offset_ = table_-&gt;file_info_.data_end_offset;</a>
<a name="ln693">    return;</a>
<a name="ln694">  }</a>
<a name="ln695"> </a>
<a name="ln696">  if (next_offset_ &lt; table_-&gt;file_info_.data_end_offset) {</a>
<a name="ln697">    for (Next(); status_.ok() &amp;&amp; Valid(); Next()) {</a>
<a name="ln698">      if (!prefix_match) {</a>
<a name="ln699">        // Need to verify the first key's prefix</a>
<a name="ln700">        if (table_-&gt;GetPrefix(key()) != prefix_slice) {</a>
<a name="ln701">          offset_ = next_offset_ = table_-&gt;file_info_.data_end_offset;</a>
<a name="ln702">          break;</a>
<a name="ln703">        }</a>
<a name="ln704">        prefix_match = true;</a>
<a name="ln705">      }</a>
<a name="ln706">      if (table_-&gt;internal_comparator_-&gt;Compare(key(), target) &gt;= 0) {</a>
<a name="ln707">        break;</a>
<a name="ln708">      }</a>
<a name="ln709">    }</a>
<a name="ln710">  } else {</a>
<a name="ln711">    offset_ = table_-&gt;file_info_.data_end_offset;</a>
<a name="ln712">  }</a>
<a name="ln713">}</a>
<a name="ln714"> </a>
<a name="ln715">void PlainTableIterator::Next() {</a>
<a name="ln716">  offset_ = next_offset_;</a>
<a name="ln717">  if (offset_ &lt; table_-&gt;file_info_.data_end_offset) {</a>
<a name="ln718">    Slice tmp_slice;</a>
<a name="ln719">    ParsedInternalKey parsed_key;</a>
<a name="ln720">    status_ =</a>
<a name="ln721">        table_-&gt;Next(&amp;decoder_, &amp;next_offset_, &amp;parsed_key, &amp;key_, &amp;value_);</a>
<a name="ln722">    if (!status_.ok()) {</a>
<a name="ln723">      offset_ = next_offset_ = table_-&gt;file_info_.data_end_offset;</a>
<a name="ln724">    }</a>
<a name="ln725">  }</a>
<a name="ln726">}</a>
<a name="ln727"> </a>
<a name="ln728">void PlainTableIterator::Prev() {</a>
<a name="ln729">  assert(false);</a>
<a name="ln730">}</a>
<a name="ln731"> </a>
<a name="ln732">Slice PlainTableIterator::key() const {</a>
<a name="ln733">  assert(Valid());</a>
<a name="ln734">  return key_;</a>
<a name="ln735">}</a>
<a name="ln736"> </a>
<a name="ln737">Slice PlainTableIterator::value() const {</a>
<a name="ln738">  assert(Valid());</a>
<a name="ln739">  return value_;</a>
<a name="ln740">}</a>
<a name="ln741"> </a>
<a name="ln742">Status PlainTableIterator::status() const {</a>
<a name="ln743">  return status_;</a>
<a name="ln744">}</a>
<a name="ln745"> </a>
<a name="ln746">}  // namespace rocksdb</a>
<a name="ln747">#endif  // ROCKSDB_LITE</a>

</code></pre>
<div class="balloon" rel="534"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The '* offset' variable was assigned the same value.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
