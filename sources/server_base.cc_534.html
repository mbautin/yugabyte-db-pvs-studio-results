
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>server_base.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Licensed to the Apache Software Foundation (ASF) under one</a>
<a name="ln2">// or more contributor license agreements.  See the NOTICE file</a>
<a name="ln3">// distributed with this work for additional information</a>
<a name="ln4">// regarding copyright ownership.  The ASF licenses this file</a>
<a name="ln5">// to you under the Apache License, Version 2.0 (the</a>
<a name="ln6">// &quot;License&quot;); you may not use this file except in compliance</a>
<a name="ln7">// with the License.  You may obtain a copy of the License at</a>
<a name="ln8">//</a>
<a name="ln9">//   http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln10">//</a>
<a name="ln11">// Unless required by applicable law or agreed to in writing,</a>
<a name="ln12">// software distributed under the License is distributed on an</a>
<a name="ln13">// &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</a>
<a name="ln14">// KIND, either express or implied.  See the License for the</a>
<a name="ln15">// specific language governing permissions and limitations</a>
<a name="ln16">// under the License.</a>
<a name="ln17">//</a>
<a name="ln18">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln19">//</a>
<a name="ln20">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln21">//</a>
<a name="ln22">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln23">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln24">//</a>
<a name="ln25">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln26">//</a>
<a name="ln27">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln28">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln29">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln30">// under the License.</a>
<a name="ln31">//</a>
<a name="ln32">#include &quot;yb/server/server_base.h&quot;</a>
<a name="ln33"> </a>
<a name="ln34">#include &lt;algorithm&gt;</a>
<a name="ln35">#include &lt;string&gt;</a>
<a name="ln36">#include &lt;thread&gt;</a>
<a name="ln37">#include &lt;vector&gt;</a>
<a name="ln38"> </a>
<a name="ln39">#include &lt;boost/algorithm/string/predicate.hpp&gt;</a>
<a name="ln40">#include &lt;gflags/gflags.h&gt;</a>
<a name="ln41"> </a>
<a name="ln42">#include &quot;yb/common/wire_protocol.h&quot;</a>
<a name="ln43">#include &quot;yb/fs/fs_manager.h&quot;</a>
<a name="ln44">#include &quot;yb/gutil/strings/strcat.h&quot;</a>
<a name="ln45">#include &quot;yb/gutil/strings/substitute.h&quot;</a>
<a name="ln46">#include &quot;yb/gutil/walltime.h&quot;</a>
<a name="ln47">#include &quot;yb/rpc/messenger.h&quot;</a>
<a name="ln48">#include &quot;yb/server/default-path-handlers.h&quot;</a>
<a name="ln49">#include &quot;yb/server/generic_service.h&quot;</a>
<a name="ln50">#include &quot;yb/server/glog_metrics.h&quot;</a>
<a name="ln51">#include &quot;yb/server/hybrid_clock.h&quot;</a>
<a name="ln52">#include &quot;yb/server/logical_clock.h&quot;</a>
<a name="ln53">#include &quot;yb/server/rpc_server.h&quot;</a>
<a name="ln54">#include &quot;yb/server/rpcz-path-handler.h&quot;</a>
<a name="ln55">#include &quot;yb/server/server_base.pb.h&quot;</a>
<a name="ln56">#include &quot;yb/server/server_base_options.h&quot;</a>
<a name="ln57">#include &quot;yb/server/tcmalloc_metrics.h&quot;</a>
<a name="ln58">#include &quot;yb/server/skewed_clock.h&quot;</a>
<a name="ln59">#include &quot;yb/server/tracing-path-handlers.h&quot;</a>
<a name="ln60">#include &quot;yb/server/webserver.h&quot;</a>
<a name="ln61">#include &quot;yb/util/atomic.h&quot;</a>
<a name="ln62">#include &quot;yb/util/env.h&quot;</a>
<a name="ln63">#include &quot;yb/util/flag_tags.h&quot;</a>
<a name="ln64">#include &quot;yb/util/jsonwriter.h&quot;</a>
<a name="ln65">#include &quot;yb/util/mem_tracker.h&quot;</a>
<a name="ln66">#include &quot;yb/util/metrics.h&quot;</a>
<a name="ln67">#include &quot;yb/util/monotime.h&quot;</a>
<a name="ln68">#include &quot;yb/util/net/sockaddr.h&quot;</a>
<a name="ln69">#include &quot;yb/util/net/net_util.h&quot;</a>
<a name="ln70">#include &quot;yb/util/user.h&quot;</a>
<a name="ln71">#include &quot;yb/util/pb_util.h&quot;</a>
<a name="ln72">#include &quot;yb/util/rolling_log.h&quot;</a>
<a name="ln73">#include &quot;yb/util/spinlock_profiling.h&quot;</a>
<a name="ln74">#include &quot;yb/util/thread.h&quot;</a>
<a name="ln75">#include &quot;yb/util/version_info.h&quot;</a>
<a name="ln76">#include &quot;yb/util/encryption_util.h&quot;</a>
<a name="ln77">#include &quot;yb/gutil/sysinfo.h&quot;</a>
<a name="ln78"> </a>
<a name="ln79">DEFINE_int32(num_reactor_threads, -1,</a>
<a name="ln80">             &quot;Number of libev reactor threads to start. If -1, the value is automatically set.&quot;);</a>
<a name="ln81">TAG_FLAG(num_reactor_threads, advanced);</a>
<a name="ln82"> </a>
<a name="ln83">DECLARE_bool(use_hybrid_clock);</a>
<a name="ln84"> </a>
<a name="ln85">DEFINE_int32(generic_svc_num_threads, 10,</a>
<a name="ln86">             &quot;Number of RPC worker threads to run for the generic service&quot;);</a>
<a name="ln87">TAG_FLAG(generic_svc_num_threads, advanced);</a>
<a name="ln88"> </a>
<a name="ln89">DEFINE_int32(generic_svc_queue_length, 50,</a>
<a name="ln90">             &quot;RPC Queue length for the generic service&quot;);</a>
<a name="ln91">TAG_FLAG(generic_svc_queue_length, advanced);</a>
<a name="ln92"> </a>
<a name="ln93">DEFINE_string(yb_test_name, &quot;&quot;,</a>
<a name="ln94">              &quot;Specifies test name this daemon is running as part of.&quot;);</a>
<a name="ln95"> </a>
<a name="ln96">DEFINE_bool(TEST_check_broadcast_address, true, &quot;Break connectivity in test mini cluster to &quot;</a>
<a name="ln97">            &quot;check broadcast address.&quot;);</a>
<a name="ln98"> </a>
<a name="ln99">DEFINE_test_flag(string, public_hostname_suffix, &quot;.ip.yugabyte&quot;, &quot;Suffix for public hostnames.&quot;);</a>
<a name="ln100"> </a>
<a name="ln101">using namespace std::literals;</a>
<a name="ln102">using namespace std::placeholders;</a>
<a name="ln103"> </a>
<a name="ln104">using std::shared_ptr;</a>
<a name="ln105">using std::string;</a>
<a name="ln106">using std::stringstream;</a>
<a name="ln107">using std::vector;</a>
<a name="ln108">using strings::Substitute;</a>
<a name="ln109"> </a>
<a name="ln110">namespace yb {</a>
<a name="ln111">namespace server {</a>
<a name="ln112"> </a>
<a name="ln113">namespace {</a>
<a name="ln114"> </a>
<a name="ln115">// Disambiguates between servers when in a minicluster.</a>
<a name="ln116">AtomicInt&lt;int32_t&gt; mem_tracker_id_counter(-1);</a>
<a name="ln117"> </a>
<a name="ln118">std::string kServerMemTrackerName = &quot;server&quot;;</a>
<a name="ln119"> </a>
<a name="ln120">struct CommonMemTrackers {</a>
<a name="ln121">  std::vector&lt;MemTrackerPtr&gt; trackers;</a>
<a name="ln122"> </a>
<a name="ln123">  ~CommonMemTrackers() {</a>
<a name="ln124">#if defined(TCMALLOC_ENABLED)</a>
<a name="ln125">    // Prevent root mem tracker from accessing common mem trackers.</a>
<a name="ln126">    auto root = MemTracker::GetRootTracker();</a>
<a name="ln127">    root-&gt;SetPollChildrenConsumptionFunctors(nullptr);</a>
<a name="ln128">#endif</a>
<a name="ln129">  }</a>
<a name="ln130">};</a>
<a name="ln131"> </a>
<a name="ln132">std::unique_ptr&lt;CommonMemTrackers&gt; common_mem_trackers;</a>
<a name="ln133"> </a>
<a name="ln134">} // anonymous namespace</a>
<a name="ln135"> </a>
<a name="ln136">std::shared_ptr&lt;MemTracker&gt; CreateMemTrackerForServer() {</a>
<a name="ln137">  int32_t id = mem_tracker_id_counter.Increment();</a>
<a name="ln138">  std::string id_str = kServerMemTrackerName;</a>
<a name="ln139">  if (id != 0) {</a>
<a name="ln140">    StrAppend(&amp;id_str, &quot; &quot;, id);</a>
<a name="ln141">  }</a>
<a name="ln142">  return MemTracker::CreateTracker(id_str);</a>
<a name="ln143">}</a>
<a name="ln144"> </a>
<a name="ln145">#if defined(TCMALLOC_ENABLED)</a>
<a name="ln146">void RegisterTCMallocTracker(const char* name, const char* prop) {</a>
<a name="ln147">  common_mem_trackers-&gt;trackers.push_back(MemTracker::CreateTracker(</a>
<a name="ln148">      -1, &quot;TCMalloc &quot;s + name, std::bind(&amp;MemTracker::GetTCMallocProperty, prop)));</a>
<a name="ln149">}</a>
<a name="ln150">#endif</a>
<a name="ln151"> </a>
<a name="ln152">RpcServerBase::RpcServerBase(string name, const ServerBaseOptions&amp; options,</a>
<a name="ln153">                             const string&amp; metric_namespace,</a>
<a name="ln154">                             MemTrackerPtr mem_tracker)</a>
<a name="ln155">    : name_(std::move(name)),</a>
<a name="ln156">      mem_tracker_(std::move(mem_tracker)),</a>
<a name="ln157">      metric_registry_(new MetricRegistry()),</a>
<a name="ln158">      metric_entity_(METRIC_ENTITY_server.Instantiate(metric_registry_.get(),</a>
<a name="ln159">                                                      metric_namespace)),</a>
<a name="ln160">      is_first_run_(false),</a>
<a name="ln161">      options_(options),</a>
<a name="ln162">      initialized_(false),</a>
<a name="ln163">      stop_metrics_logging_latch_(1) {</a>
<a name="ln164">  mem_tracker_-&gt;SetMetricEntity(metric_entity_);</a>
<a name="ln165"> </a>
<a name="ln166">#if defined(TCMALLOC_ENABLED)</a>
<a name="ln167">  // When mem tracker for first server is created we register mem trackers that report tc malloc</a>
<a name="ln168">  // status.</a>
<a name="ln169">  if (mem_tracker_-&gt;id() == kServerMemTrackerName) {</a>
<a name="ln170">    common_mem_trackers = std::make_unique&lt;CommonMemTrackers&gt;();</a>
<a name="ln171"> </a>
<a name="ln172">    RegisterTCMallocTracker(&quot;Thread Cache&quot;, &quot;tcmalloc.thread_cache_free_bytes&quot;);</a>
<a name="ln173">    RegisterTCMallocTracker(&quot;Central Cache&quot;, &quot;tcmalloc.central_cache_free_bytes&quot;);</a>
<a name="ln174">    RegisterTCMallocTracker(&quot;Transfer Cache&quot;, &quot;tcmalloc.transfer_cache_free_bytes&quot;);</a>
<a name="ln175">    RegisterTCMallocTracker(&quot;PageHeap Free&quot;, &quot;tcmalloc.pageheap_free_bytes&quot;);</a>
<a name="ln176"> </a>
<a name="ln177">    auto root = MemTracker::GetRootTracker();</a>
<a name="ln178">    root-&gt;SetPollChildrenConsumptionFunctors([]() {</a>
<a name="ln179">          for (auto&amp; tracker : common_mem_trackers-&gt;trackers) {</a>
<a name="ln180">            tracker-&gt;UpdateConsumption();</a>
<a name="ln181">          }</a>
<a name="ln182">        });</a>
<a name="ln183">  }</a>
<a name="ln184">#endif</a>
<a name="ln185"> </a>
<a name="ln186">  if (FLAGS_use_hybrid_clock) {</a>
<a name="ln187">    clock_ = new HybridClock();</a>
<a name="ln188">  } else {</a>
<a name="ln189">    clock_ = LogicalClock::CreateStartingAt(HybridTime::kInitial);</a>
<a name="ln190">  }</a>
<a name="ln191">}</a>
<a name="ln192"> </a>
<a name="ln193">void RpcServerBase::SetConnectionContextFactory(</a>
<a name="ln194">    rpc::ConnectionContextFactoryPtr connection_context_factory) {</a>
<a name="ln195">  rpc_server_.reset(new RpcServer(name_, options_.rpc_opts, std::move(connection_context_factory)));</a>
<a name="ln196">}</a>
<a name="ln197"> </a>
<a name="ln198">RpcServerBase::~RpcServerBase() {</a>
<a name="ln199">  Shutdown();</a>
<a name="ln200">  rpc_server_.reset();</a>
<a name="ln201">  messenger_.reset();</a>
<a name="ln202">  if (mem_tracker_-&gt;parent()) {</a>
<a name="ln203">    mem_tracker_-&gt;UnregisterFromParent();</a>
<a name="ln204">  }</a>
<a name="ln205">}</a>
<a name="ln206"> </a>
<a name="ln207">Endpoint RpcServerBase::first_rpc_address() const {</a>
<a name="ln208">  const auto&amp; addrs = rpc_server_-&gt;GetBoundAddresses();</a>
<a name="ln209">  CHECK(!addrs.empty()) &lt;&lt; &quot;Not bound&quot;;</a>
<a name="ln210">  return addrs[0];</a>
<a name="ln211">}</a>
<a name="ln212"> </a>
<a name="ln213">const std::string RpcServerBase::get_hostname() const {</a>
<a name="ln214">  auto hostname = GetHostname();</a>
<a name="ln215">  if (hostname.ok()) {</a>
<a name="ln216">    YB_LOG_FIRST_N(INFO, 1) &lt;&lt; &quot;Running on host: &quot; &lt;&lt; *hostname;</a>
<a name="ln217">    return *hostname;</a>
<a name="ln218">  } else {</a>
<a name="ln219">    YB_LOG_FIRST_N(WARNING, 1) &lt;&lt; &quot;Failed to get current host name: &quot; &lt;&lt; hostname.status();</a>
<a name="ln220">    return &quot;unknown_hostname&quot;;</a>
<a name="ln221">  }</a>
<a name="ln222">}</a>
<a name="ln223"> </a>
<a name="ln224">const std::string RpcServerBase::get_current_user() const {</a>
<a name="ln225">  string user_name;</a>
<a name="ln226">  auto s = GetLoggedInUser(&amp;user_name);</a>
<a name="ln227">  if (s.ok()) {</a>
<a name="ln228">    YB_LOG_FIRST_N(INFO, 1) &lt;&lt; &quot;Logged in user: &quot; &lt;&lt; user_name;</a>
<a name="ln229">    return user_name;</a>
<a name="ln230">  } else {</a>
<a name="ln231">    YB_LOG_FIRST_N(WARNING, 1) &lt;&lt; &quot;Failed to get current user&quot;;</a>
<a name="ln232">    return &quot;unknown_user&quot;;</a>
<a name="ln233">  }</a>
<a name="ln234">}</a>
<a name="ln235"> </a>
<a name="ln236">const NodeInstancePB&amp; RpcServerBase::instance_pb() const {</a>
<a name="ln237">  return *DCHECK_NOTNULL(instance_pb_.get());</a>
<a name="ln238">}</a>
<a name="ln239"> </a>
<a name="ln240">Status RpcServerBase::SetupMessengerBuilder(rpc::MessengerBuilder* builder) {</a>
<a name="ln241">  if (FLAGS_num_reactor_threads == -1) {</a>
<a name="ln242">    // Auto set the number of reactors based on the number of cores.</a>
<a name="ln243">    FLAGS_num_reactor_threads =</a>
<a name="ln244">        std::min(16, static_cast&lt;int&gt;(base::NumCPUs()));</a>
<a name="ln245">    LOG(INFO) &lt;&lt; &quot;Auto setting FLAGS_num_reactor_threads to &quot; &lt;&lt; FLAGS_num_reactor_threads;</a>
<a name="ln246">  }</a>
<a name="ln247"> </a>
<a name="ln248">  builder-&gt;set_num_reactors(FLAGS_num_reactor_threads);</a>
<a name="ln249">  builder-&gt;set_metric_entity(metric_entity());</a>
<a name="ln250">  builder-&gt;set_connection_keepalive_time(options_.rpc_opts.connection_keepalive_time_ms * 1ms);</a>
<a name="ln251"> </a>
<a name="ln252">  return Status::OK();</a>
<a name="ln253">}</a>
<a name="ln254"> </a>
<a name="ln255">Status RpcServerBase::Init() {</a>
<a name="ln256">  CHECK(!initialized_);</a>
<a name="ln257"> </a>
<a name="ln258">  glog_metrics_.reset(new ScopedGLogMetrics(metric_entity_));</a>
<a name="ln259">  tcmalloc::RegisterMetrics(metric_entity_);</a>
<a name="ln260">  RegisterSpinLockContentionMetrics(metric_entity_);</a>
<a name="ln261"> </a>
<a name="ln262">  InitSpinLockContentionProfiling();</a>
<a name="ln263"> </a>
<a name="ln264">  RETURN_NOT_OK(SetStackTraceSignal(SIGUSR2));</a>
<a name="ln265"> </a>
<a name="ln266">  // Initialize the clock immediately. This checks that the clock is synchronized</a>
<a name="ln267">  // so we're less likely to get into a partially initialized state on disk during startup</a>
<a name="ln268">  // if we're having clock problems.</a>
<a name="ln269">  RETURN_NOT_OK_PREPEND(clock_-&gt;Init(), &quot;Cannot initialize clock&quot;);</a>
<a name="ln270"> </a>
<a name="ln271">  // Create the Messenger.</a>
<a name="ln272">  rpc::MessengerBuilder builder(name_);</a>
<a name="ln273">  builder.UseDefaultConnectionContextFactory(mem_tracker());</a>
<a name="ln274">  RETURN_NOT_OK(SetupMessengerBuilder(&amp;builder));</a>
<a name="ln275">  messenger_ = VERIFY_RESULT(builder.Build());</a>
<a name="ln276">  proxy_cache_ = std::make_unique&lt;rpc::ProxyCache&gt;(messenger_.get());</a>
<a name="ln277"> </a>
<a name="ln278">  RETURN_NOT_OK(rpc_server_-&gt;Init(messenger_.get()));</a>
<a name="ln279">  RETURN_NOT_OK(rpc_server_-&gt;Bind());</a>
<a name="ln280">  clock_-&gt;RegisterMetrics(metric_entity_);</a>
<a name="ln281"> </a>
<a name="ln282">  RETURN_NOT_OK_PREPEND(StartMetricsLogging(), &quot;Could not enable metrics logging&quot;);</a>
<a name="ln283"> </a>
<a name="ln284">  initialized_ = true;</a>
<a name="ln285">  return Status::OK();</a>
<a name="ln286">}</a>
<a name="ln287"> </a>
<a name="ln288">string RpcServerBase::ToString() const {</a>
<a name="ln289">  return strings::Substitute(&quot;$0 : rpc=$1&quot;, name_, yb::ToString(first_rpc_address()));</a>
<a name="ln290">}</a>
<a name="ln291"> </a>
<a name="ln292">void RpcServerBase::GetStatusPB(ServerStatusPB* status) const {</a>
<a name="ln293">  // Node instance</a>
<a name="ln294">  status-&gt;mutable_node_instance()-&gt;CopyFrom(*instance_pb_);</a>
<a name="ln295"> </a>
<a name="ln296">  // RPC ports</a>
<a name="ln297">  {</a>
<a name="ln298">    for (const auto&amp; addr : rpc_server_-&gt;GetBoundAddresses()) {</a>
<a name="ln299">      HostPortPB* pb = status-&gt;add_bound_rpc_addresses();</a>
<a name="ln300">      pb-&gt;set_host(addr.address().to_string());</a>
<a name="ln301">      pb-&gt;set_port(addr.port());</a>
<a name="ln302">    }</a>
<a name="ln303">  }</a>
<a name="ln304"> </a>
<a name="ln305">  VersionInfo::GetVersionInfoPB(status-&gt;mutable_version_info());</a>
<a name="ln306">}</a>
<a name="ln307"> </a>
<a name="ln308">Status RpcServerBase::DumpServerInfo(const string&amp; path,</a>
<a name="ln309">                                     const string&amp; format) const {</a>
<a name="ln310">  ServerStatusPB status;</a>
<a name="ln311">  GetStatusPB(&amp;status);</a>
<a name="ln312"> </a>
<a name="ln313">  if (boost::iequals(format, &quot;json&quot;)) {</a>
<a name="ln314">    string json = JsonWriter::ToJson(status, JsonWriter::PRETTY);</a>
<a name="ln315">    RETURN_NOT_OK(WriteStringToFile(options_.env, Slice(json), path));</a>
<a name="ln316">  } else if (boost::iequals(format, &quot;pb&quot;)) {</a>
<a name="ln317">    // TODO: Use PB container format?</a>
<a name="ln318">    RETURN_NOT_OK(pb_util::WritePBToPath(options_.env, path, status,</a>
<a name="ln319">                                         pb_util::NO_SYNC)); // durability doesn't matter</a>
<a name="ln320">  } else {</a>
<a name="ln321">    return STATUS(InvalidArgument, &quot;bad format&quot;, format);</a>
<a name="ln322">  }</a>
<a name="ln323"> </a>
<a name="ln324">  LOG(INFO) &lt;&lt; &quot;Dumped server information to &quot; &lt;&lt; path;</a>
<a name="ln325">  return Status::OK();</a>
<a name="ln326">}</a>
<a name="ln327"> </a>
<a name="ln328">Status RpcServerBase::RegisterService(size_t queue_limit,</a>
<a name="ln329">                                      rpc::ServiceIfPtr rpc_impl,</a>
<a name="ln330">                                      rpc::ServicePriority priority) {</a>
<a name="ln331">  return rpc_server_-&gt;RegisterService(queue_limit, std::move(rpc_impl), priority);</a>
<a name="ln332">}</a>
<a name="ln333"> </a>
<a name="ln334">Status RpcServerBase::StartMetricsLogging() {</a>
<a name="ln335">  if (options_.metrics_log_interval_ms &lt;= 0) {</a>
<a name="ln336">    return Status::OK();</a>
<a name="ln337">  }</a>
<a name="ln338"> </a>
<a name="ln339">  return Thread::Create(&quot;server&quot;, &quot;metrics-logger&quot;, &amp;RpcAndWebServerBase::MetricsLoggingThread,</a>
<a name="ln340">                        this, &amp;metrics_logging_thread_);</a>
<a name="ln341">}</a>
<a name="ln342"> </a>
<a name="ln343">void RpcServerBase::MetricsLoggingThread() {</a>
<a name="ln344">  RollingLog log(Env::Default(), FLAGS_log_dir, &quot;metrics&quot;);</a>
<a name="ln345"> </a>
<a name="ln346">  // How long to wait before trying again if we experience a failure</a>
<a name="ln347">  // logging metrics.</a>
<a name="ln348">  const MonoDelta kWaitBetweenFailures = MonoDelta::FromSeconds(60);</a>
<a name="ln349"> </a>
<a name="ln350">  MonoTime next_log = MonoTime::Now();</a>
<a name="ln351">  while (!stop_metrics_logging_latch_.WaitUntil(next_log)) {</a>
<a name="ln352">    next_log = MonoTime::Now();</a>
<a name="ln353">    next_log.AddDelta(MonoDelta::FromMilliseconds(options_.metrics_log_interval_ms));</a>
<a name="ln354"> </a>
<a name="ln355">    std::stringstream buf;</a>
<a name="ln356">    buf &lt;&lt; &quot;metrics &quot; &lt;&lt; GetCurrentTimeMicros() &lt;&lt; &quot; &quot;;</a>
<a name="ln357"> </a>
<a name="ln358">    // Collect the metrics JSON string.</a>
<a name="ln359">    vector&lt;string&gt; metrics;</a>
<a name="ln360">    metrics.push_back(&quot;*&quot;);</a>
<a name="ln361">    MetricJsonOptions opts;</a>
<a name="ln362">    opts.include_raw_histograms = true;</a>
<a name="ln363"> </a>
<a name="ln364">    JsonWriter writer(&amp;buf, JsonWriter::COMPACT);</a>
<a name="ln365">    Status s = metric_registry_-&gt;WriteAsJson(&amp;writer, metrics, opts);</a>
<a name="ln366">    if (!s.ok()) {</a>
<a name="ln367">      WARN_NOT_OK(s, &quot;Unable to collect metrics to log&quot;);</a>
<a name="ln368">      next_log.AddDelta(kWaitBetweenFailures);</a>
<a name="ln369">      continue;</a>
<a name="ln370">    }</a>
<a name="ln371"> </a>
<a name="ln372">    buf &lt;&lt; &quot;\n&quot;;</a>
<a name="ln373"> </a>
<a name="ln374">    s = log.Append(buf.str());</a>
<a name="ln375">    if (!s.ok()) {</a>
<a name="ln376">      WARN_NOT_OK(s, &quot;Unable to write metrics to log&quot;);</a>
<a name="ln377">      next_log.AddDelta(kWaitBetweenFailures);</a>
<a name="ln378">      continue;</a>
<a name="ln379">    }</a>
<a name="ln380">  }</a>
<a name="ln381"> </a>
<a name="ln382">  WARN_NOT_OK(log.Close(), &quot;Unable to close metric log&quot;);</a>
<a name="ln383">}</a>
<a name="ln384"> </a>
<a name="ln385">Status RpcServerBase::Start() {</a>
<a name="ln386">  std::unique_ptr&lt;rpc::ServiceIf&gt; gsvc_impl(new GenericServiceImpl(this));</a>
<a name="ln387">  RETURN_NOT_OK(RegisterService(FLAGS_generic_svc_queue_length, std::move(gsvc_impl)));</a>
<a name="ln388"> </a>
<a name="ln389">  RETURN_NOT_OK(StartRpcServer());</a>
<a name="ln390"> </a>
<a name="ln391">  return Status::OK();</a>
<a name="ln392">}</a>
<a name="ln393"> </a>
<a name="ln394">Status RpcServerBase::StartRpcServer() {</a>
<a name="ln395">  CHECK(initialized_);</a>
<a name="ln396"> </a>
<a name="ln397">  RETURN_NOT_OK(rpc_server_-&gt;Start());</a>
<a name="ln398"> </a>
<a name="ln399">  if (!options_.dump_info_path.empty()) {</a>
<a name="ln400">    RETURN_NOT_OK_PREPEND(DumpServerInfo(options_.dump_info_path, options_.dump_info_format),</a>
<a name="ln401">                          &quot;Failed to dump server info to &quot; + options_.dump_info_path);</a>
<a name="ln402">  }</a>
<a name="ln403"> </a>
<a name="ln404">  return Status::OK();</a>
<a name="ln405">}</a>
<a name="ln406"> </a>
<a name="ln407">void RpcServerBase::Shutdown() {</a>
<a name="ln408">  if (metrics_logging_thread_) {</a>
<a name="ln409">    stop_metrics_logging_latch_.CountDown();</a>
<a name="ln410">    metrics_logging_thread_-&gt;Join();</a>
<a name="ln411">  }</a>
<a name="ln412">  if (rpc_server_) {</a>
<a name="ln413">    rpc_server_-&gt;Shutdown();</a>
<a name="ln414">  }</a>
<a name="ln415">  if (messenger_) {</a>
<a name="ln416">    messenger_-&gt;Shutdown();</a>
<a name="ln417">  }</a>
<a name="ln418">}</a>
<a name="ln419"> </a>
<a name="ln420">RpcAndWebServerBase::RpcAndWebServerBase(</a>
<a name="ln421">    string name, const ServerBaseOptions&amp; options,</a>
<a name="ln422">    const std::string&amp; metric_namespace,</a>
<a name="ln423">    MemTrackerPtr mem_tracker)</a>
<a name="ln424">    : RpcServerBase(name, options, metric_namespace, std::move(mem_tracker)),</a>
<a name="ln425">      web_server_(new Webserver(options.webserver_opts, name_)) {</a>
<a name="ln426">  FsManagerOpts fs_opts;</a>
<a name="ln427">  fs_opts.metric_entity = metric_entity_;</a>
<a name="ln428">  fs_opts.parent_mem_tracker = mem_tracker_;</a>
<a name="ln429">  fs_opts.wal_paths = options.fs_opts.wal_paths;</a>
<a name="ln430">  fs_opts.data_paths = options.fs_opts.data_paths;</a>
<a name="ln431">  fs_opts.server_type = options.server_type;</a>
<a name="ln432">  fs_manager_.reset(new FsManager(options.env, fs_opts));</a>
<a name="ln433"> </a>
<a name="ln434">  CHECK_OK(StartThreadInstrumentation(metric_entity_, web_server_.get()));</a>
<a name="ln435">}</a>
<a name="ln436"> </a>
<a name="ln437">RpcAndWebServerBase::~RpcAndWebServerBase() {</a>
<a name="ln438">  Shutdown();</a>
<a name="ln439">}</a>
<a name="ln440"> </a>
<a name="ln441">Endpoint RpcAndWebServerBase::first_http_address() const {</a>
<a name="ln442">  std::vector&lt;Endpoint&gt; addrs;</a>
<a name="ln443">  WARN_NOT_OK(web_server_-&gt;GetBoundAddresses(&amp;addrs),</a>
<a name="ln444">              &quot;Couldn't get bound webserver addresses&quot;);</a>
<a name="ln445">  CHECK(!addrs.empty()) &lt;&lt; &quot;Not bound&quot;;</a>
<a name="ln446">  return addrs[0];</a>
<a name="ln447">}</a>
<a name="ln448"> </a>
<a name="ln449">void RpcAndWebServerBase::GenerateInstanceID() {</a>
<a name="ln450">  instance_pb_.reset(new NodeInstancePB);</a>
<a name="ln451">  instance_pb_-&gt;set_permanent_uuid(fs_manager_-&gt;uuid());</a>
<a name="ln452">  // TODO: maybe actually bump a sequence number on local disk instead of</a>
<a name="ln453">  // using time.</a>
<a name="ln454">  instance_pb_-&gt;set_instance_seqno(Env::Default()-&gt;NowMicros());</a>
<a name="ln455">}</a>
<a name="ln456"> </a>
<a name="ln457">Status RpcAndWebServerBase::Init() {</a>
<a name="ln458">  yb::enterprise::InitOpenSSL();</a>
<a name="ln459"> </a>
<a name="ln460">  Status s = fs_manager_-&gt;Open();</a>
<a name="ln461">  if (s.IsNotFound() || (!s.ok() &amp;&amp; fs_manager_-&gt;HasAnyLockFiles())) {</a>
<a name="ln462">    LOG(INFO) &lt;&lt; &quot;Could not load existing FS layout: &quot; &lt;&lt; s.ToString();</a>
<a name="ln463">    LOG(INFO) &lt;&lt; &quot;Creating new FS layout&quot;;</a>
<a name="ln464">    is_first_run_ = true;</a>
<a name="ln465">    RETURN_NOT_OK_PREPEND(fs_manager_-&gt;CreateInitialFileSystemLayout(true),</a>
<a name="ln466">                          &quot;Could not create new FS layout&quot;);</a>
<a name="ln467">    s = fs_manager_-&gt;Open();</a>
<a name="ln468">  }</a>
<a name="ln469">  RETURN_NOT_OK_PREPEND(s, &quot;Failed to load FS layout&quot;);</a>
<a name="ln470"> </a>
<a name="ln471">  s = RpcServerBase::Init();</a>
<a name="ln472">  if (!s.ok() &amp;&amp; is_first_run_) {</a>
<a name="ln473">    // TODO (julien) : Remove this once #5276 is fixed.</a>
<a name="ln474">    LOG(ERROR) &lt;&lt; &quot;Encountered an error, deleting FS files in order to reset run state: &quot; &lt;&lt; s;</a>
<a name="ln475">    RETURN_NOT_OK_PREPEND(fs_manager_-&gt;DeleteFileSystemLayout(),</a>
<a name="ln476">                          &quot;Failed deleting FS layout after RPCServerBase init failed.&quot;);</a>
<a name="ln477">  }</a>
<a name="ln478">  RETURN_NOT_OK_PREPEND(s, &quot;Failed to initialize FS layout&quot;);</a>
<a name="ln479"> </a>
<a name="ln480">  return Status::OK();</a>
<a name="ln481">}</a>
<a name="ln482"> </a>
<a name="ln483">void RpcAndWebServerBase::GetStatusPB(ServerStatusPB* status) const {</a>
<a name="ln484">  RpcServerBase::GetStatusPB(status);</a>
<a name="ln485"> </a>
<a name="ln486">  // HTTP ports</a>
<a name="ln487">  {</a>
<a name="ln488">    std::vector&lt;Endpoint&gt; addrs;</a>
<a name="ln489">    CHECK_OK(web_server_-&gt;GetBoundAddresses(&amp;addrs));</a>
<a name="ln490">    for (const auto&amp; addr : addrs) {</a>
<a name="ln491">      HostPortPB* pb = status-&gt;add_bound_http_addresses();</a>
<a name="ln492">      pb-&gt;set_host(addr.address().to_string());</a>
<a name="ln493">      pb-&gt;set_port(addr.port());</a>
<a name="ln494">    }</a>
<a name="ln495">  }</a>
<a name="ln496">}</a>
<a name="ln497"> </a>
<a name="ln498">Status RpcAndWebServerBase::GetRegistration(ServerRegistrationPB* reg, RpcOnly rpc_only) const {</a>
<a name="ln499">  std::vector&lt;HostPort&gt; addrs = CHECK_NOTNULL(rpc_server())-&gt;GetRpcHostPort();</a>
<a name="ln500">  DCHECK_GE(addrs.size(), 1);</a>
<a name="ln501"> </a>
<a name="ln502">  // Fall back to hostname resolution if the rpc hostname is a wildcard.</a>
<a name="ln503">  if (addrs.size() != 1 || IsWildcardAddress(addrs[0].host()) || addrs[0].port() == 0) {</a>
<a name="ln504">    vector&lt;Endpoint&gt; endpoints =</a>
<a name="ln505">        CHECK_NOTNULL(rpc_server())-&gt;GetBoundAddresses();</a>
<a name="ln506">    RETURN_NOT_OK_PREPEND(</a>
<a name="ln507">        AddHostPortPBs(endpoints, reg-&gt;mutable_private_rpc_addresses()),</a>
<a name="ln508">        &quot;Failed to add RPC endpoints to registration&quot;);</a>
<a name="ln509">    for (const auto &amp;addr : reg-&gt;private_rpc_addresses()) {</a>
<a name="ln510">      LOG(INFO) &lt;&lt; &quot; Using private rpc addresses: ( &quot; &lt;&lt; addr.ShortDebugString()</a>
<a name="ln511">                &lt;&lt; &quot; )&quot;;</a>
<a name="ln512">    }</a>
<a name="ln513">  } else {</a>
<a name="ln514">    HostPortsToPBs(addrs, reg-&gt;mutable_private_rpc_addresses());</a>
<a name="ln515">    LOG(INFO) &lt;&lt; &quot;Using private rpc address &quot;</a>
<a name="ln516">              &lt;&lt; reg-&gt;private_rpc_addresses(0).host();</a>
<a name="ln517">  }</a>
<a name="ln518"> </a>
<a name="ln519">  HostPortsToPBs(options_.broadcast_addresses, reg-&gt;mutable_broadcast_addresses());</a>
<a name="ln520"> </a>
<a name="ln521">  if (!rpc_only) {</a>
<a name="ln522">    HostPort web_input_hp;</a>
<a name="ln523">    RETURN_NOT_OK(CHECK_NOTNULL(web_server())-&gt;GetInputHostPort(&amp;web_input_hp));</a>
<a name="ln524">    if (IsWildcardAddress(web_input_hp.host()) || web_input_hp.port() == 0) {</a>
<a name="ln525">      std::vector&lt;Endpoint&gt; web_addrs;</a>
<a name="ln526">      RETURN_NOT_OK_PREPEND(</a>
<a name="ln527">          CHECK_NOTNULL(web_server())-&gt;GetBoundAddresses(&amp;web_addrs),</a>
<a name="ln528">          &quot;Unable to get bound HTTP addresses&quot;);</a>
<a name="ln529">      RETURN_NOT_OK_PREPEND(AddHostPortPBs(</a>
<a name="ln530">          web_addrs, reg-&gt;mutable_http_addresses()),</a>
<a name="ln531">          &quot;Failed to add HTTP addresses to registration&quot;);</a>
<a name="ln532">      for (const auto &amp;addr : reg-&gt;http_addresses()) {</a>
<a name="ln533">        LOG(INFO) &lt;&lt; &quot;Using http addresses: ( &quot; &lt;&lt; addr.ShortDebugString() &lt;&lt; &quot; )&quot;;</a>
<a name="ln534">      }</a>
<a name="ln535">    } else {</a>
<a name="ln536">      HostPortsToPBs({ web_input_hp }, reg-&gt;mutable_http_addresses());</a>
<a name="ln537">      LOG(INFO) &lt;&lt; &quot;Using http address &quot; &lt;&lt; reg-&gt;http_addresses(0).host();</a>
<a name="ln538">    }</a>
<a name="ln539">  }</a>
<a name="ln540">  reg-&gt;mutable_cloud_info()-&gt;set_placement_cloud(options_.placement_cloud());</a>
<a name="ln541">  reg-&gt;mutable_cloud_info()-&gt;set_placement_region(options_.placement_region());</a>
<a name="ln542">  reg-&gt;mutable_cloud_info()-&gt;set_placement_zone(options_.placement_zone());</a>
<a name="ln543">  reg-&gt;set_placement_uuid(options_.placement_uuid);</a>
<a name="ln544">  return Status::OK();</a>
<a name="ln545">}</a>
<a name="ln546"> </a>
<a name="ln547">string RpcAndWebServerBase::GetEasterEggMessage() const {</a>
<a name="ln548">  return &quot;Congratulations on installing YugabyteDB. &quot;</a>
<a name="ln549">         &quot;We'd like to welcome you to the community with a free t-shirt and pack of stickers! &quot;</a>
<a name="ln550">         &quot;Please claim your reward here: &lt;a href='https://www.yugabyte.com/community-rewards/'&gt;&quot;</a>
<a name="ln551">         &quot;https://www.yugabyte.com/community-rewards/&lt;/a&gt;&quot;;</a>
<a name="ln552"> </a>
<a name="ln553">}</a>
<a name="ln554"> </a>
<a name="ln555">string RpcAndWebServerBase::FooterHtml() const {</a>
<a name="ln556">  return Substitute(&quot;&lt;pre class='message'&gt;&lt;i class=\&quot;fa-lg fa fa-gift\&quot; aria-hidden=\&quot;true\&quot;&gt;&lt;/i&gt;&quot;</a>
<a name="ln557">                    &quot; $0&lt;/pre&gt;&lt;pre&gt;$1\nserver uuid $2&lt;/pre&gt;&quot;,</a>
<a name="ln558">                    GetEasterEggMessage(),</a>
<a name="ln559">                    VersionInfo::GetShortVersionString(),</a>
<a name="ln560">                    instance_pb_-&gt;permanent_uuid());</a>
<a name="ln561">}</a>
<a name="ln562"> </a>
<a name="ln563">void RpcAndWebServerBase::DisplayIconTile(std::stringstream* output, const string icon,</a>
<a name="ln564">                                          const string caption, const string url) {</a>
<a name="ln565">  *output &lt;&lt; &quot;  &lt;div class='col-sm-4 col-md-4 dbg-tile'&gt;\n&quot;</a>
<a name="ln566">          &lt;&lt; &quot;    &lt;a href='&quot; &lt;&lt; url &lt;&lt; &quot;' class='thumbnail'&gt;\n&quot;</a>
<a name="ln567">          &lt;&lt; &quot;      &lt;div class='dbg-icon'&gt;\n&quot;</a>
<a name="ln568">          &lt;&lt; &quot;        &lt;i class='fa &quot; &lt;&lt; icon &lt;&lt; &quot;' aria-hidden='true'&gt;&lt;/i&gt;\n&quot;</a>
<a name="ln569">          &lt;&lt; &quot;      &lt;/div&gt;\n&quot;</a>
<a name="ln570">          &lt;&lt; &quot;      &lt;div class='caption dbg-caption'&gt;\n&quot;</a>
<a name="ln571">          &lt;&lt; &quot;        &lt;h3&gt;&quot; &lt;&lt; caption &lt;&lt; &quot;&lt;/h3&gt;\n&quot;</a>
<a name="ln572">          &lt;&lt; &quot;      &lt;/div&gt; &lt;!-- caption --&gt;\n&quot;</a>
<a name="ln573">          &lt;&lt; &quot;    &lt;/a&gt; &lt;!-- thumbnail --&gt;\n&quot;</a>
<a name="ln574">          &lt;&lt; &quot;  &lt;/div&gt; &lt;!-- col-sm-4 col-md-4 --&gt;\n&quot;;</a>
<a name="ln575">}</a>
<a name="ln576"> </a>
<a name="ln577">void RpcAndWebServerBase::DisplayGeneralInfoIcons(std::stringstream* output) {</a>
<a name="ln578">  // Logs.</a>
<a name="ln579">  DisplayIconTile(output, &quot;fa-files-o&quot;, &quot;Logs&quot;, &quot;/logs&quot;);</a>
<a name="ln580">  // GFlags.</a>
<a name="ln581">  DisplayIconTile(output, &quot;fa-flag-o&quot;, &quot;GFlags&quot;, &quot;/varz&quot;);</a>
<a name="ln582">  // Memory trackers.</a>
<a name="ln583">  DisplayIconTile(output, &quot;fa-bar-chart&quot;, &quot;Memory Breakdown&quot;, &quot;/mem-trackers&quot;);</a>
<a name="ln584">  // Total memory.</a>
<a name="ln585">  DisplayIconTile(output, &quot;fa-cog&quot;, &quot;Total Memory&quot;, &quot;/memz&quot;);</a>
<a name="ln586">  // Metrics.</a>
<a name="ln587">  DisplayIconTile(output, &quot;fa-line-chart&quot;, &quot;Metrics&quot;, &quot;/metrics&quot;);</a>
<a name="ln588">  // Threads.</a>
<a name="ln589">  DisplayIconTile(output, &quot;fa-list-ul&quot;, &quot;Threads&quot;, &quot;/threadz&quot;);</a>
<a name="ln590">}</a>
<a name="ln591"> </a>
<a name="ln592">Status RpcAndWebServerBase::DisplayRpcIcons(std::stringstream* output) {</a>
<a name="ln593">  // RPCs in Progress.</a>
<a name="ln594">  DisplayIconTile(output, &quot;fa-tasks&quot;, &quot;Server RPCs&quot;, &quot;/rpcz&quot;);</a>
<a name="ln595">  return Status::OK();</a>
<a name="ln596">}</a>
<a name="ln597"> </a>
<a name="ln598">Status RpcAndWebServerBase::HandleDebugPage(const Webserver::WebRequest&amp; req,</a>
<a name="ln599">                                            Webserver::WebResponse* resp) {</a>
<a name="ln600">  std::stringstream *output = &amp;resp-&gt;output;</a>
<a name="ln601">  *output &lt;&lt; &quot;&lt;h1&gt;Debug Utilities&lt;/h1&gt;\n&quot;;</a>
<a name="ln602"> </a>
<a name="ln603">  *output &lt;&lt; &quot;&lt;div class='row debug-tiles'&gt;\n&quot;;</a>
<a name="ln604">  *output &lt;&lt; &quot;&lt;h2&gt; General Info &lt;/h2&gt;&quot;;</a>
<a name="ln605">  DisplayGeneralInfoIcons(output);</a>
<a name="ln606">  *output &lt;&lt; &quot;&lt;/div&gt; &lt;!-- row --&gt;\n&quot;;</a>
<a name="ln607">  *output &lt;&lt; &quot;&lt;h2&gt; RPCs In Progress &lt;/h2&gt;&quot;;</a>
<a name="ln608">  *output &lt;&lt; &quot;&lt;div class='row debug-tiles'&gt;\n&quot;;</a>
<a name="ln609">  RETURN_NOT_OK(DisplayRpcIcons(output));</a>
<a name="ln610">  *output &lt;&lt; &quot;&lt;/div&gt; &lt;!-- row --&gt;\n&quot;;</a>
<a name="ln611">  return Status::OK();</a>
<a name="ln612">}</a>
<a name="ln613"> </a>
<a name="ln614">Status RpcAndWebServerBase::Start() {</a>
<a name="ln615">  GenerateInstanceID();</a>
<a name="ln616"> </a>
<a name="ln617">  AddDefaultPathHandlers(web_server_.get());</a>
<a name="ln618">  AddRpczPathHandlers(messenger_.get(), web_server_.get());</a>
<a name="ln619">  RegisterMetricsJsonHandler(web_server_.get(), metric_registry_.get());</a>
<a name="ln620">  TracingPathHandlers::RegisterHandlers(web_server_.get());</a>
<a name="ln621">  web_server_-&gt;RegisterPathHandler(&quot;/utilz&quot;, &quot;Utilities&quot;,</a>
<a name="ln622">                                   std::bind(&amp;RpcAndWebServerBase::HandleDebugPage, this, _1, _2),</a>
<a name="ln623">                                   true, true, &quot;fa fa-wrench&quot;);</a>
<a name="ln624">  web_server_-&gt;set_footer_html(FooterHtml());</a>
<a name="ln625">  RETURN_NOT_OK(web_server_-&gt;Start());</a>
<a name="ln626"> </a>
<a name="ln627">  RETURN_NOT_OK(RpcServerBase::Start());</a>
<a name="ln628"> </a>
<a name="ln629">  return Status::OK();</a>
<a name="ln630">}</a>
<a name="ln631"> </a>
<a name="ln632">void RpcAndWebServerBase::Shutdown() {</a>
<a name="ln633">  RpcServerBase::Shutdown();</a>
<a name="ln634">  web_server_-&gt;Stop();</a>
<a name="ln635">}</a>
<a name="ln636"> </a>
<a name="ln637">std::string TEST_RpcAddress(int index, Private priv) {</a>
<a name="ln638">  return Format(&quot;127.0.0.$0$1&quot;,</a>
<a name="ln639">                index * 2 + (priv ? 0 : 1), priv ? &quot;&quot; : FLAGS_TEST_public_hostname_suffix);</a>
<a name="ln640">}</a>
<a name="ln641"> </a>
<a name="ln642">string TEST_RpcBindEndpoint(int index, uint16_t port) {</a>
<a name="ln643">  return HostPortToString(TEST_RpcAddress(index, Private::kTrue), port);</a>
<a name="ln644">}</a>
<a name="ln645"> </a>
<a name="ln646">constexpr int kMaxServers = 20;</a>
<a name="ln647"> </a>
<a name="ln648">void TEST_SetupConnectivity(rpc::Messenger* messenger, int index) {</a>
<a name="ln649">  if (!FLAGS_TEST_check_broadcast_address) {</a>
<a name="ln650">    return;</a>
<a name="ln651">  }</a>
<a name="ln652"> </a>
<a name="ln653">  CHECK_GE(index, 1);</a>
<a name="ln654">  CHECK_LE(index, kMaxServers);</a>
<a name="ln655"> </a>
<a name="ln656">  messenger-&gt;TEST_SetOutboundIpBase(</a>
<a name="ln657">      CHECK_RESULT(HostToAddress(TEST_RpcAddress(index, Private::kTrue))));</a>
<a name="ln658">  for (int i = 1; i &lt;= kMaxServers; ++i) {</a>
<a name="ln659">    // We group servers by 2. When servers belongs to the same group, they should use</a>
<a name="ln660">    // private ip for communication, otherwise public ip should be used.</a>
<a name="ln661">    bool same_group = (i - 1) / 2 == (index - 1) / 2;</a>
<a name="ln662">    auto broken_address = CHECK_RESULT(HostToAddress(TEST_RpcAddress(i, Private(!same_group))));</a>
<a name="ln663">    LOG(INFO) &lt;&lt; &quot;Break &quot; &lt;&lt; index &lt;&lt; &quot; =&gt; &quot; &lt;&lt; broken_address;</a>
<a name="ln664">    messenger-&gt;BreakConnectivityWith(broken_address);</a>
<a name="ln665">    auto working_address = CHECK_RESULT(HostToAddress(TEST_RpcAddress(i, Private(same_group))));</a>
<a name="ln666">    messenger-&gt;RestoreConnectivityWith(working_address);</a>
<a name="ln667">  }</a>
<a name="ln668">}</a>
<a name="ln669"> </a>
<a name="ln670">void TEST_Isolate(rpc::Messenger* messenger) {</a>
<a name="ln671">  for (int i = 1; i &lt;= kMaxServers; ++i) {</a>
<a name="ln672">    messenger-&gt;BreakConnectivityWith(</a>
<a name="ln673">        CHECK_RESULT(HostToAddress(TEST_RpcAddress(i, Private::kFalse))));</a>
<a name="ln674">    messenger-&gt;BreakConnectivityWith(</a>
<a name="ln675">        CHECK_RESULT(HostToAddress(TEST_RpcAddress(i, Private::kTrue))));</a>
<a name="ln676">  }</a>
<a name="ln677">}</a>
<a name="ln678"> </a>
<a name="ln679">} // namespace server</a>
<a name="ln680">} // namespace yb</a>

</code></pre>
<div class="balloon" rel="209"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="256"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="395"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="434"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="445"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="489"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="657"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="662"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="665"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="673"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="675"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
