
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>stable_vector.hpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//////////////////////////////////////////////////////////////////////////////</a>
<a name="ln2">//</a>
<a name="ln3">// (C) Copyright Ion Gaztanaga 2008-2015. Distributed under the Boost</a>
<a name="ln4">// Software License, Version 1.0. (See accompanying file</a>
<a name="ln5">// LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)</a>
<a name="ln6">//</a>
<a name="ln7">// See http://www.boost.org/libs/container for documentation.</a>
<a name="ln8">//</a>
<a name="ln9">//////////////////////////////////////////////////////////////////////////////</a>
<a name="ln10">// Stable vector.</a>
<a name="ln11">//</a>
<a name="ln12">// Copyright 2008 Joaquin M Lopez Munoz.</a>
<a name="ln13">// Distributed under the Boost Software License, Version 1.0.</a>
<a name="ln14">// (See accompanying file LICENSE_1_0.txt or copy at</a>
<a name="ln15">// http://www.boost.org/LICENSE_1_0.txt)</a>
<a name="ln16">//</a>
<a name="ln17">//////////////////////////////////////////////////////////////////////////////</a>
<a name="ln18"> </a>
<a name="ln19">#ifndef BOOST_CONTAINER_STABLE_VECTOR_HPP</a>
<a name="ln20">#define BOOST_CONTAINER_STABLE_VECTOR_HPP</a>
<a name="ln21"> </a>
<a name="ln22">#ifndef BOOST_CONFIG_HPP</a>
<a name="ln23">#  include &lt;boost/config.hpp&gt;</a>
<a name="ln24">#endif</a>
<a name="ln25"> </a>
<a name="ln26">#if defined(BOOST_HAS_PRAGMA_ONCE)</a>
<a name="ln27">#  pragma once</a>
<a name="ln28">#endif</a>
<a name="ln29"> </a>
<a name="ln30">#include &lt;boost/container/detail/config_begin.hpp&gt;</a>
<a name="ln31">#include &lt;boost/container/detail/workaround.hpp&gt;</a>
<a name="ln32"> </a>
<a name="ln33">// container</a>
<a name="ln34">#include &lt;boost/container/allocator_traits.hpp&gt;</a>
<a name="ln35">#include &lt;boost/container/container_fwd.hpp&gt;</a>
<a name="ln36">#include &lt;boost/container/new_allocator.hpp&gt; //new_allocator</a>
<a name="ln37">#include &lt;boost/container/throw_exception.hpp&gt;</a>
<a name="ln38">// container/detail</a>
<a name="ln39">#include &lt;boost/container/detail/addressof.hpp&gt;</a>
<a name="ln40">#include &lt;boost/container/detail/algorithm.hpp&gt; //algo_equal(), algo_lexicographical_compare</a>
<a name="ln41">#include &lt;boost/container/detail/alloc_helpers.hpp&gt;</a>
<a name="ln42">#include &lt;boost/container/detail/allocator_version_traits.hpp&gt;</a>
<a name="ln43">#include &lt;boost/container/detail/construct_in_place.hpp&gt;</a>
<a name="ln44">#include &lt;boost/container/detail/iterator.hpp&gt;</a>
<a name="ln45">#include &lt;boost/container/detail/iterators.hpp&gt;</a>
<a name="ln46">#include &lt;boost/container/detail/placement_new.hpp&gt;</a>
<a name="ln47">#include &lt;boost/move/detail/to_raw_pointer.hpp&gt;</a>
<a name="ln48">#include &lt;boost/container/detail/type_traits.hpp&gt;</a>
<a name="ln49">// intrusive</a>
<a name="ln50">#include &lt;boost/intrusive/pointer_traits.hpp&gt;</a>
<a name="ln51">// intrusive/detail</a>
<a name="ln52">#include &lt;boost/intrusive/detail/minimal_pair_header.hpp&gt;   //pair</a>
<a name="ln53">// move</a>
<a name="ln54">#include &lt;boost/move/utility_core.hpp&gt;</a>
<a name="ln55">#include &lt;boost/move/iterator.hpp&gt;</a>
<a name="ln56">#include &lt;boost/move/adl_move_swap.hpp&gt;</a>
<a name="ln57">// move/detail</a>
<a name="ln58">#include &lt;boost/move/detail/move_helpers.hpp&gt;</a>
<a name="ln59">// other</a>
<a name="ln60">#include &lt;boost/assert.hpp&gt;</a>
<a name="ln61">#include &lt;boost/core/no_exceptions_support.hpp&gt;</a>
<a name="ln62">// std</a>
<a name="ln63">#if !defined(BOOST_NO_CXX11_HDR_INITIALIZER_LIST)</a>
<a name="ln64">#include &lt;initializer_list&gt;</a>
<a name="ln65">#endif</a>
<a name="ln66"> </a>
<a name="ln67">#ifndef BOOST_CONTAINER_DOXYGEN_INVOKED</a>
<a name="ln68">   #include &lt;boost/container/vector.hpp&gt;</a>
<a name="ln69">   //#define STABLE_VECTOR_ENABLE_INVARIANT_CHECKING</a>
<a name="ln70">#endif   //#ifndef BOOST_CONTAINER_DOXYGEN_INVOKED</a>
<a name="ln71"> </a>
<a name="ln72">namespace boost {</a>
<a name="ln73">namespace container {</a>
<a name="ln74"> </a>
<a name="ln75">#ifndef BOOST_CONTAINER_DOXYGEN_INVOKED</a>
<a name="ln76"> </a>
<a name="ln77">namespace stable_vector_detail{</a>
<a name="ln78"> </a>
<a name="ln79">template &lt;class C&gt;</a>
<a name="ln80">class clear_on_destroy</a>
<a name="ln81">{</a>
<a name="ln82">   public:</a>
<a name="ln83">   clear_on_destroy(C &amp;c)</a>
<a name="ln84">      :  c_(c), do_clear_(true)</a>
<a name="ln85">   {}</a>
<a name="ln86"> </a>
<a name="ln87">   void release()</a>
<a name="ln88">   {  do_clear_ = false; }</a>
<a name="ln89"> </a>
<a name="ln90">   ~clear_on_destroy()</a>
<a name="ln91">   {</a>
<a name="ln92">      if(do_clear_){</a>
<a name="ln93">         c_.clear();</a>
<a name="ln94">         c_.priv_clear_pool();</a>
<a name="ln95">      }</a>
<a name="ln96">   }</a>
<a name="ln97"> </a>
<a name="ln98">   private:</a>
<a name="ln99">   clear_on_destroy(const clear_on_destroy &amp;);</a>
<a name="ln100">   clear_on_destroy &amp;operator=(const clear_on_destroy &amp;);</a>
<a name="ln101">   C &amp;c_;</a>
<a name="ln102">   bool do_clear_;</a>
<a name="ln103">};</a>
<a name="ln104"> </a>
<a name="ln105">template&lt;typename Pointer&gt;</a>
<a name="ln106">struct node;</a>
<a name="ln107"> </a>
<a name="ln108">template&lt;class VoidPtr&gt;</a>
<a name="ln109">struct node_base</a>
<a name="ln110">{</a>
<a name="ln111">   private:</a>
<a name="ln112">   typedef typename boost::intrusive::</a>
<a name="ln113">      pointer_traits&lt;VoidPtr&gt;                   void_ptr_traits;</a>
<a name="ln114">   typedef typename void_ptr_traits::</a>
<a name="ln115">      template rebind_pointer</a>
<a name="ln116">         &lt;node_base&gt;::type                      node_base_ptr;</a>
<a name="ln117"> </a>
<a name="ln118">   public:</a>
<a name="ln119">   typedef typename void_ptr_traits::</a>
<a name="ln120">      template rebind_pointer</a>
<a name="ln121">         &lt;node_base_ptr&gt;::type                  node_base_ptr_ptr;</a>
<a name="ln122"> </a>
<a name="ln123">   public:</a>
<a name="ln124">   explicit node_base(const node_base_ptr_ptr &amp;n)</a>
<a name="ln125">      : up(n)</a>
<a name="ln126">   {}</a>
<a name="ln127"> </a>
<a name="ln128">   node_base()</a>
<a name="ln129">      : up()</a>
<a name="ln130">   {}</a>
<a name="ln131"> </a>
<a name="ln132">   node_base_ptr_ptr up;</a>
<a name="ln133">};</a>
<a name="ln134"> </a>
<a name="ln135"> </a>
<a name="ln136">template&lt;typename Pointer&gt;</a>
<a name="ln137">struct node</a>
<a name="ln138">   : public node_base</a>
<a name="ln139">      &lt;typename ::boost::intrusive::pointer_traits&lt;Pointer&gt;::template</a>
<a name="ln140">         rebind_pointer&lt;void&gt;::type</a>
<a name="ln141">      &gt;</a>
<a name="ln142">{</a>
<a name="ln143">   public:</a>
<a name="ln144">   typedef typename ::boost::intrusive::pointer_traits&lt;Pointer&gt;::element_type T;</a>
<a name="ln145">   typedef node_base</a>
<a name="ln146">      &lt;typename ::boost::intrusive::pointer_traits&lt;Pointer&gt;::template</a>
<a name="ln147">         rebind_pointer&lt;void&gt;::type</a>
<a name="ln148">      &gt; hook_type;</a>
<a name="ln149"> </a>
<a name="ln150">   typedef typename boost::container::dtl::aligned_storage</a>
<a name="ln151">      &lt;sizeof(T), boost::container::dtl::alignment_of&lt;T&gt;::value&gt;::type storage_t;</a>
<a name="ln152">   storage_t m_storage;</a>
<a name="ln153"> </a>
<a name="ln154">   BOOST_CONTAINER_FORCEINLINE explicit node(const typename hook_type::node_base_ptr_ptr &amp;n)</a>
<a name="ln155">      : hook_type(n)</a>
<a name="ln156">   {}</a>
<a name="ln157"> </a>
<a name="ln158">   BOOST_CONTAINER_FORCEINLINE node()</a>
<a name="ln159">   {}</a>
<a name="ln160"> </a>
<a name="ln161">   #if defined(BOOST_GCC) &amp;&amp; (BOOST_GCC &gt;= 40600) &amp;&amp; (BOOST_GCC &lt; 80000)</a>
<a name="ln162">      #pragma GCC diagnostic push</a>
<a name="ln163">      #pragma GCC diagnostic ignored &quot;-Wstrict-aliasing&quot;</a>
<a name="ln164">      #define BOOST_CONTAINER_DISABLE_ALIASING_WARNING</a>
<a name="ln165">   #  endif</a>
<a name="ln166"> </a>
<a name="ln167">   BOOST_CONTAINER_FORCEINLINE T &amp;get_data()</a>
<a name="ln168">   {  return *reinterpret_cast&lt;T*&gt;(this-&gt;m_storage.data);   }</a>
<a name="ln169"> </a>
<a name="ln170">   BOOST_CONTAINER_FORCEINLINE const T &amp;get_data() const</a>
<a name="ln171">   {  return *reinterpret_cast&lt;const T*&gt;(this-&gt;m_storage.data);  }</a>
<a name="ln172"> </a>
<a name="ln173">   BOOST_CONTAINER_FORCEINLINE T *get_data_ptr()</a>
<a name="ln174">   {  return reinterpret_cast&lt;T*&gt;(this-&gt;m_storage.data);  }</a>
<a name="ln175"> </a>
<a name="ln176">   BOOST_CONTAINER_FORCEINLINE const T *get_data_ptr() const</a>
<a name="ln177">   {  return reinterpret_cast&lt;T*&gt;(this-&gt;m_storage.data);  }</a>
<a name="ln178"> </a>
<a name="ln179">   BOOST_CONTAINER_FORCEINLINE ~node()</a>
<a name="ln180">   {  reinterpret_cast&lt;T*&gt;(this-&gt;m_storage.data)-&gt;~T();  }</a>
<a name="ln181"> </a>
<a name="ln182">   #if defined(BOOST_CONTAINER_DISABLE_ALIASING_WARNING)</a>
<a name="ln183">      #pragma GCC diagnostic pop</a>
<a name="ln184">      #undef BOOST_CONTAINER_DISABLE_ALIASING_WARNING</a>
<a name="ln185">   #  endif</a>
<a name="ln186"> </a>
<a name="ln187">   BOOST_CONTAINER_FORCEINLINE void destroy_header()</a>
<a name="ln188">   {  static_cast&lt;hook_type*&gt;(this)-&gt;~hook_type();  }</a>
<a name="ln189">};</a>
<a name="ln190"> </a>
<a name="ln191">template&lt;class VoidPtr, class VoidAllocator&gt;</a>
<a name="ln192">struct index_traits</a>
<a name="ln193">{</a>
<a name="ln194">   typedef boost::intrusive::</a>
<a name="ln195">      pointer_traits</a>
<a name="ln196">         &lt;VoidPtr&gt;                                    void_ptr_traits;</a>
<a name="ln197">   typedef stable_vector_detail::</a>
<a name="ln198">      node_base&lt;VoidPtr&gt;                              node_base_type;</a>
<a name="ln199">   typedef typename void_ptr_traits::template</a>
<a name="ln200">         rebind_pointer&lt;node_base_type&gt;::type         node_base_ptr;</a>
<a name="ln201">   typedef typename void_ptr_traits::template</a>
<a name="ln202">         rebind_pointer&lt;node_base_ptr&gt;::type          node_base_ptr_ptr;</a>
<a name="ln203">   typedef boost::intrusive::</a>
<a name="ln204">      pointer_traits&lt;node_base_ptr&gt;                   node_base_ptr_traits;</a>
<a name="ln205">   typedef boost::intrusive::</a>
<a name="ln206">      pointer_traits&lt;node_base_ptr_ptr&gt;               node_base_ptr_ptr_traits;</a>
<a name="ln207">   typedef typename allocator_traits&lt;VoidAllocator&gt;::</a>
<a name="ln208">         template portable_rebind_alloc</a>
<a name="ln209">            &lt;node_base_ptr&gt;::type                     node_base_ptr_allocator;</a>
<a name="ln210">   typedef ::boost::container::vector</a>
<a name="ln211">      &lt;node_base_ptr, node_base_ptr_allocator&gt;        index_type;</a>
<a name="ln212">   typedef typename index_type::iterator              index_iterator;</a>
<a name="ln213">   typedef typename index_type::const_iterator        const_index_iterator;</a>
<a name="ln214">   typedef typename index_type::size_type             size_type;</a>
<a name="ln215"> </a>
<a name="ln216">   static const size_type ExtraPointers = 3;</a>
<a name="ln217">   //Stable vector stores metadata at the end of the index (node_base_ptr vector) with additional 3 pointers:</a>
<a name="ln218">   //    back() is this-&gt;index.back() - ExtraPointers;</a>
<a name="ln219">   //    end node index is    *(this-&gt;index.end() - 3)</a>
<a name="ln220">   //    Node cache first is  *(this-&gt;index.end() - 2);</a>
<a name="ln221">   //    Node cache last is   this-&gt;index.back();</a>
<a name="ln222"> </a>
<a name="ln223">   static node_base_ptr_ptr ptr_to_node_base_ptr(node_base_ptr &amp;n)</a>
<a name="ln224">   {  return node_base_ptr_ptr_traits::pointer_to(n);   }</a>
<a name="ln225"> </a>
<a name="ln226">   static void fix_up_pointers(index_iterator first, index_iterator last)</a>
<a name="ln227">   {</a>
<a name="ln228">      while(first != last){</a>
<a name="ln229">         typedef typename index_type::reference node_base_ptr_ref;</a>
<a name="ln230">         node_base_ptr_ref nbp = *first;</a>
<a name="ln231">         nbp-&gt;up = index_traits::ptr_to_node_base_ptr(nbp);</a>
<a name="ln232">         ++first;</a>
<a name="ln233">      }</a>
<a name="ln234">   }</a>
<a name="ln235"> </a>
<a name="ln236">   static index_iterator get_fix_up_end(index_type &amp;index)</a>
<a name="ln237">   {  return index.end() - (ExtraPointers - 1); }</a>
<a name="ln238"> </a>
<a name="ln239">   static void fix_up_pointers_from(index_type &amp; index, index_iterator first)</a>
<a name="ln240">   {  index_traits::fix_up_pointers(first, index_traits::get_fix_up_end(index));   }</a>
<a name="ln241"> </a>
<a name="ln242">   static void readjust_end_node(index_type &amp;index, node_base_type &amp;end_node)</a>
<a name="ln243">   {</a>
<a name="ln244">      if(!index.empty()){</a>
<a name="ln245">         index_iterator end_node_it(index_traits::get_fix_up_end(index));</a>
<a name="ln246">         node_base_ptr &amp;end_node_idx_ref = *(--end_node_it);</a>
<a name="ln247">         end_node_idx_ref = node_base_ptr_traits::pointer_to(end_node);</a>
<a name="ln248">         end_node.up      = node_base_ptr_ptr_traits::pointer_to(end_node_idx_ref);</a>
<a name="ln249">      }</a>
<a name="ln250">      else{</a>
<a name="ln251">         end_node.up = node_base_ptr_ptr();</a>
<a name="ln252">      }</a>
<a name="ln253">   }</a>
<a name="ln254"> </a>
<a name="ln255">   static void initialize_end_node(index_type &amp;index, node_base_type &amp;end_node, const size_type index_capacity_if_empty)</a>
<a name="ln256">   {</a>
<a name="ln257">      if(index.empty()){</a>
<a name="ln258">         index.reserve(index_capacity_if_empty + ExtraPointers);</a>
<a name="ln259">         index.resize(ExtraPointers);</a>
<a name="ln260">         node_base_ptr &amp;end_node_ref = *index.data();</a>
<a name="ln261">         end_node_ref = node_base_ptr_traits::pointer_to(end_node);</a>
<a name="ln262">         end_node.up = index_traits::ptr_to_node_base_ptr(end_node_ref);</a>
<a name="ln263">      }</a>
<a name="ln264">   }</a>
<a name="ln265"> </a>
<a name="ln266">   #ifdef STABLE_VECTOR_ENABLE_INVARIANT_CHECKING</a>
<a name="ln267">   static bool invariants(index_type &amp;index)</a>
<a name="ln268">   {</a>
<a name="ln269">      for( index_iterator it = index.begin()</a>
<a name="ln270">         , it_end = index_traits::get_fix_up_end(index)</a>
<a name="ln271">         ; it != it_end</a>
<a name="ln272">         ; ++it){</a>
<a name="ln273">         if((*it)-&gt;up != index_traits::ptr_to_node_base_ptr(*it)){</a>
<a name="ln274">            return false;</a>
<a name="ln275">         }</a>
<a name="ln276">      }</a>
<a name="ln277">      return true;</a>
<a name="ln278">   }</a>
<a name="ln279">   #endif   //STABLE_VECTOR_ENABLE_INVARIANT_CHECKING</a>
<a name="ln280">};</a>
<a name="ln281"> </a>
<a name="ln282">} //namespace stable_vector_detail</a>
<a name="ln283"> </a>
<a name="ln284">template&lt;typename Pointer, bool IsConst&gt;</a>
<a name="ln285">class stable_vector_iterator</a>
<a name="ln286">{</a>
<a name="ln287">   typedef boost::intrusive::pointer_traits&lt;Pointer&gt;                                non_const_ptr_traits;</a>
<a name="ln288">   public:</a>
<a name="ln289">   typedef std::random_access_iterator_tag                                          iterator_category;</a>
<a name="ln290">   typedef typename non_const_ptr_traits::element_type                              value_type;</a>
<a name="ln291">   typedef typename non_const_ptr_traits::difference_type                           difference_type;</a>
<a name="ln292">   typedef typename ::boost::container::dtl::if_c</a>
<a name="ln293">      &lt; IsConst</a>
<a name="ln294">      , typename non_const_ptr_traits::template</a>
<a name="ln295">         rebind_pointer&lt;const value_type&gt;::type</a>
<a name="ln296">      , Pointer</a>
<a name="ln297">      &gt;::type                                                                       pointer;</a>
<a name="ln298">   typedef boost::intrusive::pointer_traits&lt;pointer&gt;                                ptr_traits;</a>
<a name="ln299">   typedef typename ptr_traits::reference                                           reference;</a>
<a name="ln300"> </a>
<a name="ln301">   private:</a>
<a name="ln302">   typedef typename non_const_ptr_traits::template</a>
<a name="ln303">         rebind_pointer&lt;void&gt;::type             void_ptr;</a>
<a name="ln304">   typedef stable_vector_detail::node&lt;Pointer&gt;         node_type;</a>
<a name="ln305">   typedef stable_vector_detail::node_base&lt;void_ptr&gt;   node_base_type;</a>
<a name="ln306">   typedef typename non_const_ptr_traits::template</a>
<a name="ln307">         rebind_pointer&lt;node_type&gt;::type        node_ptr;</a>
<a name="ln308">   typedef boost::intrusive::</a>
<a name="ln309">      pointer_traits&lt;node_ptr&gt;                  node_ptr_traits;</a>
<a name="ln310">   typedef typename non_const_ptr_traits::template</a>
<a name="ln311">         rebind_pointer&lt;node_base_type&gt;::type   node_base_ptr;</a>
<a name="ln312">   typedef typename non_const_ptr_traits::template</a>
<a name="ln313">         rebind_pointer&lt;node_base_ptr&gt;::type    node_base_ptr_ptr;</a>
<a name="ln314"> </a>
<a name="ln315">   node_base_ptr m_pn;</a>
<a name="ln316"> </a>
<a name="ln317">   public:</a>
<a name="ln318"> </a>
<a name="ln319">   explicit stable_vector_iterator(node_base_ptr p) BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln320">      : m_pn(p)</a>
<a name="ln321">   {}</a>
<a name="ln322"> </a>
<a name="ln323">   stable_vector_iterator() BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln324">      : m_pn() //Value initialization to achieve &quot;null iterators&quot; (N3644)</a>
<a name="ln325">   {}</a>
<a name="ln326"> </a>
<a name="ln327">   stable_vector_iterator(stable_vector_iterator&lt;Pointer, false&gt; const&amp; other) BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln328">      :  m_pn(other.node_pointer())</a>
<a name="ln329">   {}</a>
<a name="ln330"> </a>
<a name="ln331">   node_ptr node_pointer() const BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln332">   {  return node_ptr_traits::static_cast_from(m_pn);  }</a>
<a name="ln333"> </a>
<a name="ln334">   public:</a>
<a name="ln335">   //Pointer like operators</a>
<a name="ln336">   reference operator*()  const BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln337">   {  return  node_pointer()-&gt;get_data();  }</a>
<a name="ln338"> </a>
<a name="ln339">   pointer   operator-&gt;() const BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln340">   {  return ptr_traits::pointer_to(this-&gt;operator*());  }</a>
<a name="ln341"> </a>
<a name="ln342">   //Increment / Decrement</a>
<a name="ln343">   stable_vector_iterator&amp; operator++() BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln344">   {</a>
<a name="ln345">      node_base_ptr_ptr p(this-&gt;m_pn-&gt;up);</a>
<a name="ln346">      this-&gt;m_pn = *(++p);</a>
<a name="ln347">      return *this;</a>
<a name="ln348">   }</a>
<a name="ln349"> </a>
<a name="ln350">   stable_vector_iterator operator++(int) BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln351">   {  stable_vector_iterator tmp(*this);  ++*this; return stable_vector_iterator(tmp); }</a>
<a name="ln352"> </a>
<a name="ln353">   stable_vector_iterator&amp; operator--() BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln354">   {</a>
<a name="ln355">      node_base_ptr_ptr p(this-&gt;m_pn-&gt;up);</a>
<a name="ln356">      this-&gt;m_pn = *(--p);</a>
<a name="ln357">      return *this;</a>
<a name="ln358">   }</a>
<a name="ln359"> </a>
<a name="ln360">   stable_vector_iterator operator--(int) BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln361">   {  stable_vector_iterator tmp(*this);  --*this; return stable_vector_iterator(tmp);  }</a>
<a name="ln362"> </a>
<a name="ln363">   reference operator[](difference_type off) const BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln364">   {  return node_ptr_traits::static_cast_from(this-&gt;m_pn-&gt;up[off])-&gt;get_data();  }</a>
<a name="ln365"> </a>
<a name="ln366">   stable_vector_iterator&amp; operator+=(difference_type off) BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln367">   {</a>
<a name="ln368">      if(off) this-&gt;m_pn = this-&gt;m_pn-&gt;up[off];</a>
<a name="ln369">      return *this;</a>
<a name="ln370">   }</a>
<a name="ln371"> </a>
<a name="ln372">   friend stable_vector_iterator operator+(const stable_vector_iterator &amp;left, difference_type off) BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln373">   {</a>
<a name="ln374">      stable_vector_iterator tmp(left);</a>
<a name="ln375">      tmp += off;</a>
<a name="ln376">      return tmp;</a>
<a name="ln377">   }</a>
<a name="ln378"> </a>
<a name="ln379">   friend stable_vector_iterator operator+(difference_type off, const stable_vector_iterator&amp; right) BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln380">   {</a>
<a name="ln381">      stable_vector_iterator tmp(right);</a>
<a name="ln382">      tmp += off;</a>
<a name="ln383">      return tmp;</a>
<a name="ln384">   }</a>
<a name="ln385"> </a>
<a name="ln386">   stable_vector_iterator&amp; operator-=(difference_type off) BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln387">   {  *this += -off; return *this;   }</a>
<a name="ln388"> </a>
<a name="ln389">   friend stable_vector_iterator operator-(const stable_vector_iterator &amp;left, difference_type off) BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln390">   {</a>
<a name="ln391">      stable_vector_iterator tmp(left);</a>
<a name="ln392">      tmp -= off;</a>
<a name="ln393">      return tmp;</a>
<a name="ln394">   }</a>
<a name="ln395"> </a>
<a name="ln396">   friend difference_type operator-(const stable_vector_iterator &amp;left, const stable_vector_iterator &amp;right) BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln397">   {  return left.m_pn-&gt;up - right.m_pn-&gt;up;  }</a>
<a name="ln398"> </a>
<a name="ln399">   //Comparison operators</a>
<a name="ln400">   friend bool operator==   (const stable_vector_iterator&amp; l, const stable_vector_iterator&amp; r) BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln401">   {  return l.m_pn == r.m_pn;  }</a>
<a name="ln402"> </a>
<a name="ln403">   friend bool operator!=   (const stable_vector_iterator&amp; l, const stable_vector_iterator&amp; r) BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln404">   {  return l.m_pn != r.m_pn;  }</a>
<a name="ln405"> </a>
<a name="ln406">   friend bool operator&lt;    (const stable_vector_iterator&amp; l, const stable_vector_iterator&amp; r) BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln407">   {  return l.m_pn-&gt;up &lt; r.m_pn-&gt;up;  }</a>
<a name="ln408"> </a>
<a name="ln409">   friend bool operator&lt;=   (const stable_vector_iterator&amp; l, const stable_vector_iterator&amp; r) BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln410">   {  return l.m_pn-&gt;up &lt;= r.m_pn-&gt;up;  }</a>
<a name="ln411"> </a>
<a name="ln412">   friend bool operator&gt;    (const stable_vector_iterator&amp; l, const stable_vector_iterator&amp; r) BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln413">   {  return l.m_pn-&gt;up &gt; r.m_pn-&gt;up;  }</a>
<a name="ln414"> </a>
<a name="ln415">   friend bool operator&gt;=   (const stable_vector_iterator&amp; l, const stable_vector_iterator&amp; r) BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln416">   {  return l.m_pn-&gt;up &gt;= r.m_pn-&gt;up;  }</a>
<a name="ln417">};</a>
<a name="ln418"> </a>
<a name="ln419">   #if defined(STABLE_VECTOR_ENABLE_INVARIANT_CHECKING)</a>
<a name="ln420"> </a>
<a name="ln421">      #define STABLE_VECTOR_CHECK_INVARIANT \</a>
<a name="ln422">               invariant_checker BOOST_JOIN(check_invariant_,__LINE__)(*this); \</a>
<a name="ln423">               BOOST_JOIN(check_invariant_,__LINE__).touch();</a>
<a name="ln424"> </a>
<a name="ln425">   #else //STABLE_VECTOR_ENABLE_INVARIANT_CHECKING</a>
<a name="ln426"> </a>
<a name="ln427">      #define STABLE_VECTOR_CHECK_INVARIANT</a>
<a name="ln428"> </a>
<a name="ln429">   #endif   //#if defined(STABLE_VECTOR_ENABLE_INVARIANT_CHECKING)</a>
<a name="ln430"> </a>
<a name="ln431">#endif   //#ifndef BOOST_CONTAINER_DOXYGEN_INVOKED</a>
<a name="ln432"> </a>
<a name="ln433">//! Originally developed by Joaquin M. Lopez Munoz, stable_vector is a std::vector</a>
<a name="ln434">//! drop-in replacement implemented as a node container, offering iterator and reference</a>
<a name="ln435">//! stability.</a>
<a name="ln436">//!</a>
<a name="ln437">//! Here are the details taken from the author's blog</a>
<a name="ln438">//! (&lt;a href=&quot;http://bannalia.blogspot.com/2008/09/introducing-stablevector.html&quot; &gt;</a>
<a name="ln439">//! Introducing stable_vector&lt;/a&gt;):</a>
<a name="ln440">//!</a>
<a name="ln441">//! We present stable_vector, a fully STL-compliant stable container that provides</a>
<a name="ln442">//! most of the features of std::vector except element contiguity.</a>
<a name="ln443">//!</a>
<a name="ln444">//! General properties: stable_vector satisfies all the requirements of a container,</a>
<a name="ln445">//! a reversible container and a sequence and provides all the optional operations</a>
<a name="ln446">//! present in std::vector. Like std::vector, iterators are random access.</a>
<a name="ln447">//! stable_vector does not provide element contiguity; in exchange for this absence,</a>
<a name="ln448">//! the container is stable, i.e. references and iterators to an element of a stable_vector</a>
<a name="ln449">//! remain valid as long as the element is not erased, and an iterator that has been</a>
<a name="ln450">//! assigned the return value of end() always remain valid until the destruction of</a>
<a name="ln451">//! the associated  stable_vector.</a>
<a name="ln452">//!</a>
<a name="ln453">//! Operation complexity: The big-O complexities of stable_vector operations match</a>
<a name="ln454">//! exactly those of std::vector. In general, insertion/deletion is constant time at</a>
<a name="ln455">//! the end of the sequence and linear elsewhere. Unlike std::vector, stable_vector</a>
<a name="ln456">//! does not internally perform any value_type destruction, copy or assignment</a>
<a name="ln457">//! operations other than those exactly corresponding to the insertion of new</a>
<a name="ln458">//! elements or deletion of stored elements, which can sometimes compensate in terms</a>
<a name="ln459">//! of performance for the extra burden of doing more pointer manipulation and an</a>
<a name="ln460">//! additional allocation per element.</a>
<a name="ln461">//!</a>
<a name="ln462">//! Exception safety: As stable_vector does not internally copy elements around, some</a>
<a name="ln463">//! operations provide stronger exception safety guarantees than in std::vector.</a>
<a name="ln464">//!</a>
<a name="ln465">//! \tparam T The type of object that is stored in the stable_vector</a>
<a name="ln466">//! \tparam Allocator The allocator used for all internal memory management</a>
<a name="ln467">#ifdef BOOST_CONTAINER_DOXYGEN_INVOKED</a>
<a name="ln468">template &lt;class T, class Allocator = new_allocator&lt;T&gt; &gt;</a>
<a name="ln469">#else</a>
<a name="ln470">template &lt;class T, class Allocator&gt;</a>
<a name="ln471">#endif</a>
<a name="ln472">class stable_vector</a>
<a name="ln473">{</a>
<a name="ln474">   #ifndef BOOST_CONTAINER_DOXYGEN_INVOKED</a>
<a name="ln475">   typedef allocator_traits&lt;Allocator&gt;                allocator_traits_type;</a>
<a name="ln476">   typedef boost::intrusive::</a>
<a name="ln477">      pointer_traits</a>
<a name="ln478">         &lt;typename allocator_traits_type::pointer&gt;    ptr_traits;</a>
<a name="ln479">   typedef typename ptr_traits::</a>
<a name="ln480">         template rebind_pointer&lt;void&gt;::type          void_ptr;</a>
<a name="ln481">   typedef typename allocator_traits_type::</a>
<a name="ln482">      template portable_rebind_alloc</a>
<a name="ln483">         &lt;void&gt;::type                                 void_allocator_type;</a>
<a name="ln484">   typedef stable_vector_detail::index_traits</a>
<a name="ln485">      &lt;void_ptr, void_allocator_type&gt;                 index_traits_type;</a>
<a name="ln486">   typedef typename index_traits_type::node_base_type node_base_type;</a>
<a name="ln487">   typedef typename index_traits_type::node_base_ptr  node_base_ptr;</a>
<a name="ln488">   typedef typename index_traits_type::</a>
<a name="ln489">      node_base_ptr_ptr                               node_base_ptr_ptr;</a>
<a name="ln490">   typedef typename index_traits_type::</a>
<a name="ln491">      node_base_ptr_traits                            node_base_ptr_traits;</a>
<a name="ln492">   typedef typename index_traits_type::</a>
<a name="ln493">      node_base_ptr_ptr_traits                        node_base_ptr_ptr_traits;</a>
<a name="ln494">   typedef typename index_traits_type::index_type     index_type;</a>
<a name="ln495">   typedef typename index_traits_type::index_iterator index_iterator;</a>
<a name="ln496">   typedef typename index_traits_type::</a>
<a name="ln497">      const_index_iterator                            const_index_iterator;</a>
<a name="ln498">   typedef stable_vector_detail::node</a>
<a name="ln499">      &lt;typename ptr_traits::pointer&gt;                  node_type;</a>
<a name="ln500">   typedef typename ptr_traits::template</a>
<a name="ln501">      rebind_pointer&lt;node_type&gt;::type                 node_ptr;</a>
<a name="ln502">   typedef boost::intrusive::</a>
<a name="ln503">      pointer_traits&lt;node_ptr&gt;                        node_ptr_traits;</a>
<a name="ln504">   typedef typename ptr_traits::template</a>
<a name="ln505">      rebind_pointer&lt;const node_type&gt;::type           const_node_ptr;</a>
<a name="ln506">   typedef boost::intrusive::</a>
<a name="ln507">      pointer_traits&lt;const_node_ptr&gt;                  const_node_ptr_traits;</a>
<a name="ln508">   typedef typename node_ptr_traits::reference        node_reference;</a>
<a name="ln509">   typedef typename const_node_ptr_traits::reference  const_node_reference;</a>
<a name="ln510"> </a>
<a name="ln511">   typedef ::boost::container::dtl::integral_constant</a>
<a name="ln512">      &lt;unsigned, boost::container::dtl::</a>
<a name="ln513">      version&lt;Allocator&gt;::value&gt;                              alloc_version;</a>
<a name="ln514">   typedef typename allocator_traits_type::</a>
<a name="ln515">      template portable_rebind_alloc</a>
<a name="ln516">         &lt;node_type&gt;::type                            node_allocator_type;</a>
<a name="ln517"> </a>
<a name="ln518">   typedef ::boost::container::dtl::</a>
<a name="ln519">      allocator_version_traits&lt;node_allocator_type&gt;                    allocator_version_traits_t;</a>
<a name="ln520">   typedef typename allocator_version_traits_t::multiallocation_chain  multiallocation_chain;</a>
<a name="ln521"> </a>
<a name="ln522">   node_ptr allocate_one()</a>
<a name="ln523">   {  return allocator_version_traits_t::allocate_one(this-&gt;priv_node_alloc());   }</a>
<a name="ln524"> </a>
<a name="ln525">   void deallocate_one(const node_ptr &amp;p)</a>
<a name="ln526">   {  allocator_version_traits_t::deallocate_one(this-&gt;priv_node_alloc(), p);   }</a>
<a name="ln527"> </a>
<a name="ln528">   void allocate_individual(typename allocator_traits_type::size_type n, multiallocation_chain &amp;m)</a>
<a name="ln529">   {  allocator_version_traits_t::allocate_individual(this-&gt;priv_node_alloc(), n, m);   }</a>
<a name="ln530"> </a>
<a name="ln531">   void deallocate_individual(multiallocation_chain &amp;holder)</a>
<a name="ln532">   {  allocator_version_traits_t::deallocate_individual(this-&gt;priv_node_alloc(), holder);   }</a>
<a name="ln533"> </a>
<a name="ln534">   friend class stable_vector_detail::clear_on_destroy&lt;stable_vector&gt;;</a>
<a name="ln535">   typedef stable_vector_iterator</a>
<a name="ln536">      &lt; typename allocator_traits&lt;Allocator&gt;::pointer</a>
<a name="ln537">      , false&gt;                                           iterator_impl;</a>
<a name="ln538">   typedef stable_vector_iterator</a>
<a name="ln539">      &lt; typename allocator_traits&lt;Allocator&gt;::pointer</a>
<a name="ln540">      , true&gt;                                            const_iterator_impl;</a>
<a name="ln541">   #endif   //#ifndef BOOST_CONTAINER_DOXYGEN_INVOKED</a>
<a name="ln542">   public:</a>
<a name="ln543"> </a>
<a name="ln544">   //////////////////////////////////////////////</a>
<a name="ln545">   //</a>
<a name="ln546">   //                    types</a>
<a name="ln547">   //</a>
<a name="ln548">   //////////////////////////////////////////////</a>
<a name="ln549">   typedef T                                                                           value_type;</a>
<a name="ln550">   typedef typename ::boost::container::allocator_traits&lt;Allocator&gt;::pointer           pointer;</a>
<a name="ln551">   typedef typename ::boost::container::allocator_traits&lt;Allocator&gt;::const_pointer     const_pointer;</a>
<a name="ln552">   typedef typename ::boost::container::allocator_traits&lt;Allocator&gt;::reference         reference;</a>
<a name="ln553">   typedef typename ::boost::container::allocator_traits&lt;Allocator&gt;::const_reference   const_reference;</a>
<a name="ln554">   typedef typename ::boost::container::allocator_traits&lt;Allocator&gt;::size_type         size_type;</a>
<a name="ln555">   typedef typename ::boost::container::allocator_traits&lt;Allocator&gt;::difference_type   difference_type;</a>
<a name="ln556">   typedef Allocator                                                                   allocator_type;</a>
<a name="ln557">   typedef node_allocator_type                                                         stored_allocator_type;</a>
<a name="ln558">   typedef BOOST_CONTAINER_IMPDEF(iterator_impl)                                       iterator;</a>
<a name="ln559">   typedef BOOST_CONTAINER_IMPDEF(const_iterator_impl)                                 const_iterator;</a>
<a name="ln560">   typedef BOOST_CONTAINER_IMPDEF(boost::container::reverse_iterator&lt;iterator&gt;)        reverse_iterator;</a>
<a name="ln561">   typedef BOOST_CONTAINER_IMPDEF(boost::container::reverse_iterator&lt;const_iterator&gt;)  const_reverse_iterator;</a>
<a name="ln562"> </a>
<a name="ln563">   #ifndef BOOST_CONTAINER_DOXYGEN_INVOKED</a>
<a name="ln564">   private:</a>
<a name="ln565">   BOOST_COPYABLE_AND_MOVABLE(stable_vector)</a>
<a name="ln566">   static const size_type ExtraPointers = index_traits_type::ExtraPointers;</a>
<a name="ln567"> </a>
<a name="ln568">   class insert_rollback;</a>
<a name="ln569">   friend class insert_rollback;</a>
<a name="ln570"> </a>
<a name="ln571">   class push_back_rollback;</a>
<a name="ln572">   friend class push_back_rollback;</a>
<a name="ln573">   #endif   //#ifndef BOOST_CONTAINER_DOXYGEN_INVOKED</a>
<a name="ln574"> </a>
<a name="ln575">   public:</a>
<a name="ln576">   //////////////////////////////////////////////</a>
<a name="ln577">   //</a>
<a name="ln578">   //          construct/copy/destroy</a>
<a name="ln579">   //</a>
<a name="ln580">   //////////////////////////////////////////////</a>
<a name="ln581"> </a>
<a name="ln582">   //! &lt;b&gt;Effects&lt;/b&gt;: Default constructs a stable_vector.</a>
<a name="ln583">   //!</a>
<a name="ln584">   //! &lt;b&gt;Throws&lt;/b&gt;: If allocator_type's default constructor throws.</a>
<a name="ln585">   //!</a>
<a name="ln586">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln587">   stable_vector() BOOST_NOEXCEPT_IF(dtl::is_nothrow_default_constructible&lt;Allocator&gt;::value)</a>
<a name="ln588">      : internal_data(), index()</a>
<a name="ln589">   {</a>
<a name="ln590">      STABLE_VECTOR_CHECK_INVARIANT;</a>
<a name="ln591">   }</a>
<a name="ln592"> </a>
<a name="ln593">   //! &lt;b&gt;Effects&lt;/b&gt;: Constructs a stable_vector taking the allocator as parameter.</a>
<a name="ln594">   //!</a>
<a name="ln595">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing</a>
<a name="ln596">   //!</a>
<a name="ln597">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln598">   explicit stable_vector(const allocator_type&amp; al) BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln599">      : internal_data(al), index(al)</a>
<a name="ln600">   {</a>
<a name="ln601">      STABLE_VECTOR_CHECK_INVARIANT;</a>
<a name="ln602">   }</a>
<a name="ln603"> </a>
<a name="ln604">   //! &lt;b&gt;Effects&lt;/b&gt;: Constructs a stable_vector</a>
<a name="ln605">   //!   and inserts n value initialized values.</a>
<a name="ln606">   //!</a>
<a name="ln607">   //! &lt;b&gt;Throws&lt;/b&gt;: If allocator_type's default constructor</a>
<a name="ln608">   //!   throws or T's default or copy constructor throws.</a>
<a name="ln609">   //!</a>
<a name="ln610">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear to n.</a>
<a name="ln611">   explicit stable_vector(size_type n)</a>
<a name="ln612">      : internal_data(), index()</a>
<a name="ln613">   {</a>
<a name="ln614">      stable_vector_detail::clear_on_destroy&lt;stable_vector&gt; cod(*this);</a>
<a name="ln615">      this-&gt;resize(n);</a>
<a name="ln616">      STABLE_VECTOR_CHECK_INVARIANT;</a>
<a name="ln617">      cod.release();</a>
<a name="ln618">   }</a>
<a name="ln619"> </a>
<a name="ln620">   //! &lt;b&gt;Effects&lt;/b&gt;: Constructs a stable_vector</a>
<a name="ln621">   //!   and inserts n default initialized values.</a>
<a name="ln622">   //!</a>
<a name="ln623">   //! &lt;b&gt;Throws&lt;/b&gt;: If allocator_type's default constructor</a>
<a name="ln624">   //!   throws or T's default or copy constructor throws.</a>
<a name="ln625">   //!</a>
<a name="ln626">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear to n.</a>
<a name="ln627">   //!</a>
<a name="ln628">   //! &lt;b&gt;Note&lt;/b&gt;: Non-standard extension</a>
<a name="ln629">   stable_vector(size_type n, default_init_t)</a>
<a name="ln630">      : internal_data(), index()</a>
<a name="ln631">   {</a>
<a name="ln632">      stable_vector_detail::clear_on_destroy&lt;stable_vector&gt; cod(*this);</a>
<a name="ln633">      this-&gt;resize(n, default_init);</a>
<a name="ln634">      STABLE_VECTOR_CHECK_INVARIANT;</a>
<a name="ln635">      cod.release();</a>
<a name="ln636">   }</a>
<a name="ln637"> </a>
<a name="ln638">   //! &lt;b&gt;Effects&lt;/b&gt;: Constructs a stable_vector that will use a copy of allocator a</a>
<a name="ln639">   //!   and inserts n value initialized values.</a>
<a name="ln640">   //!</a>
<a name="ln641">   //! &lt;b&gt;Throws&lt;/b&gt;: If allocator_type's default constructor</a>
<a name="ln642">   //!   throws or T's default or copy constructor throws.</a>
<a name="ln643">   //!</a>
<a name="ln644">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear to n.</a>
<a name="ln645">   explicit stable_vector(size_type n, const allocator_type &amp;a)</a>
<a name="ln646">      : internal_data(), index(a)</a>
<a name="ln647">   {</a>
<a name="ln648">      stable_vector_detail::clear_on_destroy&lt;stable_vector&gt; cod(*this);</a>
<a name="ln649">      this-&gt;resize(n);</a>
<a name="ln650">      STABLE_VECTOR_CHECK_INVARIANT;</a>
<a name="ln651">      cod.release();</a>
<a name="ln652">   }</a>
<a name="ln653"> </a>
<a name="ln654">   //! &lt;b&gt;Effects&lt;/b&gt;: Constructs a stable_vector that will use a copy of allocator a</a>
<a name="ln655">   //!   and inserts n default initialized values.</a>
<a name="ln656">   //!</a>
<a name="ln657">   //! &lt;b&gt;Throws&lt;/b&gt;: If allocator_type's default constructor</a>
<a name="ln658">   //!   throws or T's default or copy constructor throws.</a>
<a name="ln659">   //!</a>
<a name="ln660">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear to n.</a>
<a name="ln661">   //!</a>
<a name="ln662">   //! &lt;b&gt;Note&lt;/b&gt;: Non-standard extension</a>
<a name="ln663">   stable_vector(size_type n, default_init_t, const allocator_type &amp;a)</a>
<a name="ln664">      : internal_data(), index(a)</a>
<a name="ln665">   {</a>
<a name="ln666">      stable_vector_detail::clear_on_destroy&lt;stable_vector&gt; cod(*this);</a>
<a name="ln667">      this-&gt;resize(n, default_init);</a>
<a name="ln668">      STABLE_VECTOR_CHECK_INVARIANT;</a>
<a name="ln669">      cod.release();</a>
<a name="ln670">   }</a>
<a name="ln671"> </a>
<a name="ln672">   //! &lt;b&gt;Effects&lt;/b&gt;: Constructs a stable_vector that will use a copy of allocator a</a>
<a name="ln673">   //!   and inserts n copies of value.</a>
<a name="ln674">   //!</a>
<a name="ln675">   //! &lt;b&gt;Throws&lt;/b&gt;: If allocator_type's default constructor</a>
<a name="ln676">   //!   throws or T's default or copy constructor throws.</a>
<a name="ln677">   //!</a>
<a name="ln678">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear to n.</a>
<a name="ln679">   stable_vector(size_type n, const T&amp; t, const allocator_type&amp; al = allocator_type())</a>
<a name="ln680">      : internal_data(al), index(al)</a>
<a name="ln681">   {</a>
<a name="ln682">      stable_vector_detail::clear_on_destroy&lt;stable_vector&gt; cod(*this);</a>
<a name="ln683">      this-&gt;insert(this-&gt;cend(), n, t);</a>
<a name="ln684">      STABLE_VECTOR_CHECK_INVARIANT;</a>
<a name="ln685">      cod.release();</a>
<a name="ln686">   }</a>
<a name="ln687"> </a>
<a name="ln688">   //! &lt;b&gt;Effects&lt;/b&gt;: Constructs a stable_vector that will use a copy of allocator a</a>
<a name="ln689">   //!   and inserts a copy of the range [first, last) in the stable_vector.</a>
<a name="ln690">   //!</a>
<a name="ln691">   //! &lt;b&gt;Throws&lt;/b&gt;: If allocator_type's default constructor</a>
<a name="ln692">   //!   throws or T's constructor taking a dereferenced InIt throws.</a>
<a name="ln693">   //!</a>
<a name="ln694">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear to the range [first, last).</a>
<a name="ln695">   template &lt;class InputIterator&gt;</a>
<a name="ln696">   stable_vector(InputIterator first,InputIterator last, const allocator_type&amp; al = allocator_type())</a>
<a name="ln697">      : internal_data(al), index(al)</a>
<a name="ln698">   {</a>
<a name="ln699">      stable_vector_detail::clear_on_destroy&lt;stable_vector&gt; cod(*this);</a>
<a name="ln700">      this-&gt;insert(this-&gt;cend(), first, last);</a>
<a name="ln701">      STABLE_VECTOR_CHECK_INVARIANT;</a>
<a name="ln702">      cod.release();</a>
<a name="ln703">   }</a>
<a name="ln704"> </a>
<a name="ln705">   //! &lt;b&gt;Effects&lt;/b&gt;: Copy constructs a stable_vector.</a>
<a name="ln706">   //!</a>
<a name="ln707">   //! &lt;b&gt;Postcondition&lt;/b&gt;: x == *this.</a>
<a name="ln708">   //!</a>
<a name="ln709">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear to the elements x contains.</a>
<a name="ln710">   stable_vector(const stable_vector&amp; x)</a>
<a name="ln711">      : internal_data(allocator_traits&lt;node_allocator_type&gt;::</a>
<a name="ln712">         select_on_container_copy_construction(x.priv_node_alloc()))</a>
<a name="ln713">      , index(allocator_traits&lt;allocator_type&gt;::</a>
<a name="ln714">         select_on_container_copy_construction(x.index.get_stored_allocator()))</a>
<a name="ln715">   {</a>
<a name="ln716">      stable_vector_detail::clear_on_destroy&lt;stable_vector&gt; cod(*this);</a>
<a name="ln717">      this-&gt;insert(this-&gt;cend(), x.begin(), x.end());</a>
<a name="ln718">      STABLE_VECTOR_CHECK_INVARIANT;</a>
<a name="ln719">      cod.release();</a>
<a name="ln720">   }</a>
<a name="ln721"> </a>
<a name="ln722">#if !defined(BOOST_NO_CXX11_HDR_INITIALIZER_LIST)</a>
<a name="ln723">   //! &lt;b&gt;Effects&lt;/b&gt;: Constructs a stable_vector that will use a copy of allocator a</a>
<a name="ln724">   //!  and inserts a copy of the range [il.begin(), il.last()) in the stable_vector</a>
<a name="ln725">   //!</a>
<a name="ln726">   //! &lt;b&gt;Throws&lt;/b&gt;: If allocator_type's default constructor</a>
<a name="ln727">   //!   throws or T's constructor taking a dereferenced initializer_list iterator throws.</a>
<a name="ln728">   //!</a>
<a name="ln729">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear to the range [il.begin(), il.end()).</a>
<a name="ln730">   stable_vector(std::initializer_list&lt;value_type&gt; il, const allocator_type&amp; l = allocator_type())</a>
<a name="ln731">      : internal_data(l), index(l)</a>
<a name="ln732">   {</a>
<a name="ln733">      stable_vector_detail::clear_on_destroy&lt;stable_vector&gt; cod(*this);</a>
<a name="ln734">      insert(cend(), il.begin(), il.end());</a>
<a name="ln735">      STABLE_VECTOR_CHECK_INVARIANT;</a>
<a name="ln736">      cod.release();</a>
<a name="ln737">   }</a>
<a name="ln738">#endif</a>
<a name="ln739"> </a>
<a name="ln740">   //! &lt;b&gt;Effects&lt;/b&gt;: Move constructor. Moves x's resources to *this.</a>
<a name="ln741">   //!</a>
<a name="ln742">   //! &lt;b&gt;Throws&lt;/b&gt;: If allocator_type's copy constructor throws.</a>
<a name="ln743">   //!</a>
<a name="ln744">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln745">   stable_vector(BOOST_RV_REF(stable_vector) x) BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln746">      : internal_data(boost::move(x.priv_node_alloc())), index(boost::move(x.index))</a>
<a name="ln747">   {</a>
<a name="ln748">      this-&gt;priv_swap_members(x);</a>
<a name="ln749">   }</a>
<a name="ln750"> </a>
<a name="ln751">   //! &lt;b&gt;Effects&lt;/b&gt;: Copy constructs a stable_vector using the specified allocator.</a>
<a name="ln752">   //!</a>
<a name="ln753">   //! &lt;b&gt;Postcondition&lt;/b&gt;: x == *this.</a>
<a name="ln754">   //!</a>
<a name="ln755">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear to the elements x contains.</a>
<a name="ln756">   stable_vector(const stable_vector&amp; x, const allocator_type &amp;a)</a>
<a name="ln757">      : internal_data(a), index(a)</a>
<a name="ln758">   {</a>
<a name="ln759">      stable_vector_detail::clear_on_destroy&lt;stable_vector&gt; cod(*this);</a>
<a name="ln760">      this-&gt;insert(this-&gt;cend(), x.begin(), x.end());</a>
<a name="ln761">      STABLE_VECTOR_CHECK_INVARIANT;</a>
<a name="ln762">      cod.release();</a>
<a name="ln763">   }</a>
<a name="ln764"> </a>
<a name="ln765">   //! &lt;b&gt;Effects&lt;/b&gt;: Move constructor using the specified allocator.</a>
<a name="ln766">   //!                 Moves x's resources to *this.</a>
<a name="ln767">   //!</a>
<a name="ln768">   //! &lt;b&gt;Throws&lt;/b&gt;: If allocator_type's copy constructor throws.</a>
<a name="ln769">   //!</a>
<a name="ln770">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant if a == x.get_allocator(), linear otherwise</a>
<a name="ln771">   stable_vector(BOOST_RV_REF(stable_vector) x, const allocator_type &amp;a)</a>
<a name="ln772">      : internal_data(a), index(a)</a>
<a name="ln773">   {</a>
<a name="ln774">      if(this-&gt;priv_node_alloc() == x.priv_node_alloc()){</a>
<a name="ln775">         this-&gt;index.swap(x.index);         </a>
<a name="ln776">         this-&gt;priv_swap_members(x);</a>
<a name="ln777">      }</a>
<a name="ln778">      else{</a>
<a name="ln779">         stable_vector_detail::clear_on_destroy&lt;stable_vector&gt; cod(*this);</a>
<a name="ln780">         this-&gt;insert(this-&gt;cend(), boost::make_move_iterator(x.begin()), boost::make_move_iterator(x.end()));</a>
<a name="ln781">         STABLE_VECTOR_CHECK_INVARIANT;</a>
<a name="ln782">         cod.release();</a>
<a name="ln783">      }</a>
<a name="ln784">   }</a>
<a name="ln785"> </a>
<a name="ln786">   //! &lt;b&gt;Effects&lt;/b&gt;: Destroys the stable_vector. All stored values are destroyed</a>
<a name="ln787">   //!   and used memory is deallocated.</a>
<a name="ln788">   //!</a>
<a name="ln789">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln790">   //!</a>
<a name="ln791">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear to the number of elements.</a>
<a name="ln792">   ~stable_vector()</a>
<a name="ln793">   {</a>
<a name="ln794">      this-&gt;clear();</a>
<a name="ln795">      this-&gt;priv_clear_pool();</a>
<a name="ln796">   }</a>
<a name="ln797"> </a>
<a name="ln798">   //! &lt;b&gt;Effects&lt;/b&gt;: Makes *this contain the same elements as x.</a>
<a name="ln799">   //!</a>
<a name="ln800">   //! &lt;b&gt;Postcondition&lt;/b&gt;: this-&gt;size() == x.size(). *this contains a copy</a>
<a name="ln801">   //! of each of x's elements.</a>
<a name="ln802">   //!</a>
<a name="ln803">   //! &lt;b&gt;Throws&lt;/b&gt;: If memory allocation throws or T's copy constructor throws.</a>
<a name="ln804">   //!</a>
<a name="ln805">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear to the number of elements in x.</a>
<a name="ln806">   stable_vector&amp; operator=(BOOST_COPY_ASSIGN_REF(stable_vector) x)</a>
<a name="ln807">   {</a>
<a name="ln808">      STABLE_VECTOR_CHECK_INVARIANT;</a>
<a name="ln809">      if (&amp;x != this){</a>
<a name="ln810">         node_allocator_type &amp;this_alloc     = this-&gt;priv_node_alloc();</a>
<a name="ln811">         const node_allocator_type &amp;x_alloc  = x.priv_node_alloc();</a>
<a name="ln812">         dtl::bool_&lt;allocator_traits_type::</a>
<a name="ln813">            propagate_on_container_copy_assignment::value&gt; flag;</a>
<a name="ln814">         if(flag &amp;&amp; this_alloc != x_alloc){</a>
<a name="ln815">            this-&gt;clear();</a>
<a name="ln816">            this-&gt;shrink_to_fit();</a>
<a name="ln817">         }</a>
<a name="ln818">         dtl::assign_alloc(this-&gt;priv_node_alloc(), x.priv_node_alloc(), flag);</a>
<a name="ln819">         dtl::assign_alloc(this-&gt;index.get_stored_allocator(), x.index.get_stored_allocator(), flag);</a>
<a name="ln820">         this-&gt;assign(x.begin(), x.end());</a>
<a name="ln821">      }</a>
<a name="ln822">      return *this;</a>
<a name="ln823">   }</a>
<a name="ln824"> </a>
<a name="ln825">   //! &lt;b&gt;Effects&lt;/b&gt;: Move assignment. All x's values are transferred to *this.</a>
<a name="ln826">   //!</a>
<a name="ln827">   //! &lt;b&gt;Postcondition&lt;/b&gt;: x.empty(). *this contains a the elements x had</a>
<a name="ln828">   //!   before the function.</a>
<a name="ln829">   //!</a>
<a name="ln830">   //! &lt;b&gt;Throws&lt;/b&gt;: If allocator_traits_type::propagate_on_container_move_assignment</a>
<a name="ln831">   //!   is false and (allocation throws or T's move constructor throws)</a>
<a name="ln832">   //!</a>
<a name="ln833">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant if allocator_traits_type::</a>
<a name="ln834">   //!   propagate_on_container_move_assignment is true or</a>
<a name="ln835">   //!   this-&gt;get&gt;allocator() == x.get_allocator(). Linear otherwise.</a>
<a name="ln836">   stable_vector&amp; operator=(BOOST_RV_REF(stable_vector) x)</a>
<a name="ln837">      BOOST_NOEXCEPT_IF(allocator_traits_type::propagate_on_container_move_assignment::value</a>
<a name="ln838">                                  || allocator_traits_type::is_always_equal::value)</a>
<a name="ln839">   {</a>
<a name="ln840">      //for move constructor, no aliasing (&amp;x != this) is assumed.</a>
<a name="ln841">      BOOST_ASSERT(this != &amp;x);</a>
<a name="ln842">      node_allocator_type &amp;this_alloc = this-&gt;priv_node_alloc();</a>
<a name="ln843">      node_allocator_type &amp;x_alloc    = x.priv_node_alloc();</a>
<a name="ln844">      const bool propagate_alloc = allocator_traits_type::</a>
<a name="ln845">            propagate_on_container_move_assignment::value;</a>
<a name="ln846">      dtl::bool_&lt;propagate_alloc&gt; flag;</a>
<a name="ln847">      const bool allocators_equal = this_alloc == x_alloc; (void)allocators_equal;</a>
<a name="ln848">      //Resources can be transferred if both allocators are</a>
<a name="ln849">      //going to be equal after this function (either propagated or already equal)</a>
<a name="ln850">      if(propagate_alloc || allocators_equal){</a>
<a name="ln851">         STABLE_VECTOR_CHECK_INVARIANT</a>
<a name="ln852">         //Destroy objects but retain memory in case x reuses it in the future</a>
<a name="ln853">         this-&gt;clear();</a>
<a name="ln854">         //Move allocator if needed</a>
<a name="ln855">         dtl::move_alloc(this_alloc, x_alloc, flag);</a>
<a name="ln856">         //Take resources</a>
<a name="ln857">         this-&gt;index.swap(x.index);</a>
<a name="ln858">         this-&gt;priv_swap_members(x);</a>
<a name="ln859">      }</a>
<a name="ln860">      //Else do a one by one move</a>
<a name="ln861">      else{</a>
<a name="ln862">         this-&gt;assign( boost::make_move_iterator(x.begin())</a>
<a name="ln863">                     , boost::make_move_iterator(x.end()));</a>
<a name="ln864">      }</a>
<a name="ln865">      return *this;</a>
<a name="ln866">   }</a>
<a name="ln867"> </a>
<a name="ln868">#if !defined(BOOST_NO_CXX11_HDR_INITIALIZER_LIST)</a>
<a name="ln869">   //! &lt;b&gt;Effects&lt;/b&gt;: Make *this container contains elements from il.</a>
<a name="ln870">   //!</a>
<a name="ln871">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear to the range [il.begin(), il.end()).</a>
<a name="ln872">   stable_vector&amp; operator=(std::initializer_list&lt;value_type&gt; il)</a>
<a name="ln873">   {</a>
<a name="ln874">      STABLE_VECTOR_CHECK_INVARIANT;</a>
<a name="ln875">      assign(il.begin(), il.end());</a>
<a name="ln876">      return *this;</a>
<a name="ln877">   }</a>
<a name="ln878">#endif</a>
<a name="ln879"> </a>
<a name="ln880">   //! &lt;b&gt;Effects&lt;/b&gt;: Assigns the n copies of val to *this.</a>
<a name="ln881">   //!</a>
<a name="ln882">   //! &lt;b&gt;Throws&lt;/b&gt;: If memory allocation throws or T's copy constructor throws.</a>
<a name="ln883">   //!</a>
<a name="ln884">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear to n.</a>
<a name="ln885">   void assign(size_type n, const T&amp; t)</a>
<a name="ln886">   {</a>
<a name="ln887">      typedef constant_iterator&lt;value_type, difference_type&gt; cvalue_iterator;</a>
<a name="ln888">      this-&gt;assign(cvalue_iterator(t, n), cvalue_iterator());</a>
<a name="ln889">   }</a>
<a name="ln890"> </a>
<a name="ln891">   //! &lt;b&gt;Effects&lt;/b&gt;: Assigns the the range [first, last) to *this.</a>
<a name="ln892">   //!</a>
<a name="ln893">   //! &lt;b&gt;Throws&lt;/b&gt;: If memory allocation throws or</a>
<a name="ln894">   //!   T's constructor from dereferencing InpIt throws.</a>
<a name="ln895">   //!</a>
<a name="ln896">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear to n.</a>
<a name="ln897">   template&lt;typename InputIterator&gt;</a>
<a name="ln898">   #if !defined(BOOST_CONTAINER_DOXYGEN_INVOKED)</a>
<a name="ln899">   typename dtl::disable_if_convertible&lt;InputIterator, size_type&gt;::type</a>
<a name="ln900">   #else</a>
<a name="ln901">   void</a>
<a name="ln902">   #endif</a>
<a name="ln903">      assign(InputIterator first,InputIterator last)</a>
<a name="ln904">   {</a>
<a name="ln905">      STABLE_VECTOR_CHECK_INVARIANT;</a>
<a name="ln906">      iterator first1   = this-&gt;begin();</a>
<a name="ln907">      iterator last1    = this-&gt;end();</a>
<a name="ln908">      for ( ; first1 != last1 &amp;&amp; first != last; ++first1, ++first)</a>
<a name="ln909">         *first1 = *first;</a>
<a name="ln910">      if (first == last){</a>
<a name="ln911">         this-&gt;erase(first1, last1);</a>
<a name="ln912">      }</a>
<a name="ln913">      else{</a>
<a name="ln914">         this-&gt;insert(last1, first, last);</a>
<a name="ln915">      }</a>
<a name="ln916">   }</a>
<a name="ln917"> </a>
<a name="ln918">#if !defined(BOOST_NO_CXX11_HDR_INITIALIZER_LIST)</a>
<a name="ln919">   //! &lt;b&gt;Effects&lt;/b&gt;: Assigns the the range [il.begin(), il.end()) to *this.</a>
<a name="ln920">   //!</a>
<a name="ln921">   //! &lt;b&gt;Throws&lt;/b&gt;: If memory allocation throws or</a>
<a name="ln922">   //!   T's constructor from dereferencing initializer_list iterator throws.</a>
<a name="ln923">   //!</a>
<a name="ln924">   void assign(std::initializer_list&lt;value_type&gt; il)</a>
<a name="ln925">   {</a>
<a name="ln926">      STABLE_VECTOR_CHECK_INVARIANT;</a>
<a name="ln927">      assign(il.begin(), il.end());</a>
<a name="ln928">   }</a>
<a name="ln929">#endif</a>
<a name="ln930"> </a>
<a name="ln931">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns a copy of the internal allocator.</a>
<a name="ln932">   //!</a>
<a name="ln933">   //! &lt;b&gt;Throws&lt;/b&gt;: If allocator's copy constructor throws.</a>
<a name="ln934">   //!</a>
<a name="ln935">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln936">   allocator_type get_allocator() const</a>
<a name="ln937">   {  return this-&gt;priv_node_alloc();  }</a>
<a name="ln938"> </a>
<a name="ln939">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns a reference to the internal allocator.</a>
<a name="ln940">   //!</a>
<a name="ln941">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing</a>
<a name="ln942">   //!</a>
<a name="ln943">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln944">   //!</a>
<a name="ln945">   //! &lt;b&gt;Note&lt;/b&gt;: Non-standard extension.</a>
<a name="ln946">   const stored_allocator_type &amp;get_stored_allocator() const BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln947">   {  return this-&gt;priv_node_alloc(); }</a>
<a name="ln948"> </a>
<a name="ln949">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns a reference to the internal allocator.</a>
<a name="ln950">   //!</a>
<a name="ln951">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing</a>
<a name="ln952">   //!</a>
<a name="ln953">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln954">   //!</a>
<a name="ln955">   //! &lt;b&gt;Note&lt;/b&gt;: Non-standard extension.</a>
<a name="ln956">   stored_allocator_type &amp;get_stored_allocator() BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln957">   {  return this-&gt;priv_node_alloc(); }</a>
<a name="ln958"> </a>
<a name="ln959">   //////////////////////////////////////////////</a>
<a name="ln960">   //</a>
<a name="ln961">   //                iterators</a>
<a name="ln962">   //</a>
<a name="ln963">   //////////////////////////////////////////////</a>
<a name="ln964"> </a>
<a name="ln965">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns an iterator to the first element contained in the stable_vector.</a>
<a name="ln966">   //!</a>
<a name="ln967">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln968">   //!</a>
<a name="ln969">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln970">   iterator  begin() BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln971">   {   return (this-&gt;index.empty()) ? this-&gt;end(): iterator(node_ptr_traits::static_cast_from(this-&gt;index.front())); }</a>
<a name="ln972"> </a>
<a name="ln973">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns a const_iterator to the first element contained in the stable_vector.</a>
<a name="ln974">   //!</a>
<a name="ln975">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln976">   //!</a>
<a name="ln977">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln978">   const_iterator  begin() const BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln979">   {   return (this-&gt;index.empty()) ? this-&gt;cend() : const_iterator(node_ptr_traits::static_cast_from(this-&gt;index.front())) ;   }</a>
<a name="ln980"> </a>
<a name="ln981">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns an iterator to the end of the stable_vector.</a>
<a name="ln982">   //!</a>
<a name="ln983">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln984">   //!</a>
<a name="ln985">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln986">   iterator        end() BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln987">   {  return iterator(this-&gt;priv_get_end_node());  }</a>
<a name="ln988"> </a>
<a name="ln989">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns a const_iterator to the end of the stable_vector.</a>
<a name="ln990">   //!</a>
<a name="ln991">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln992">   //!</a>
<a name="ln993">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln994">   const_iterator  end() const BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln995">   {  return const_iterator(this-&gt;priv_get_end_node());  }</a>
<a name="ln996"> </a>
<a name="ln997">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns a reverse_iterator pointing to the beginning</a>
<a name="ln998">   //! of the reversed stable_vector.</a>
<a name="ln999">   //!</a>
<a name="ln1000">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln1001">   //!</a>
<a name="ln1002">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln1003">   reverse_iterator       rbegin() BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln1004">   {  return reverse_iterator(this-&gt;end());  }</a>
<a name="ln1005"> </a>
<a name="ln1006">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns a const_reverse_iterator pointing to the beginning</a>
<a name="ln1007">   //! of the reversed stable_vector.</a>
<a name="ln1008">   //!</a>
<a name="ln1009">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln1010">   //!</a>
<a name="ln1011">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln1012">   const_reverse_iterator rbegin() const BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln1013">   {  return const_reverse_iterator(this-&gt;end());  }</a>
<a name="ln1014"> </a>
<a name="ln1015">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns a reverse_iterator pointing to the end</a>
<a name="ln1016">   //! of the reversed stable_vector.</a>
<a name="ln1017">   //!</a>
<a name="ln1018">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln1019">   //!</a>
<a name="ln1020">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln1021">   reverse_iterator       rend() BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln1022">   {  return reverse_iterator(this-&gt;begin());   }</a>
<a name="ln1023"> </a>
<a name="ln1024">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns a const_reverse_iterator pointing to the end</a>
<a name="ln1025">   //! of the reversed stable_vector.</a>
<a name="ln1026">   //!</a>
<a name="ln1027">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln1028">   //!</a>
<a name="ln1029">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln1030">   const_reverse_iterator rend() const BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln1031">   {  return const_reverse_iterator(this-&gt;begin());   }</a>
<a name="ln1032"> </a>
<a name="ln1033">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns a const_iterator to the first element contained in the stable_vector.</a>
<a name="ln1034">   //!</a>
<a name="ln1035">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln1036">   //!</a>
<a name="ln1037">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln1038">   const_iterator         cbegin() const BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln1039">   {  return this-&gt;begin();   }</a>
<a name="ln1040"> </a>
<a name="ln1041">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns a const_iterator to the end of the stable_vector.</a>
<a name="ln1042">   //!</a>
<a name="ln1043">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln1044">   //!</a>
<a name="ln1045">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln1046">   const_iterator         cend() const BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln1047">   {  return this-&gt;end();  }</a>
<a name="ln1048"> </a>
<a name="ln1049">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns a const_reverse_iterator pointing to the beginning</a>
<a name="ln1050">   //! of the reversed stable_vector.</a>
<a name="ln1051">   //!</a>
<a name="ln1052">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln1053">   //!</a>
<a name="ln1054">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln1055">   const_reverse_iterator crbegin() const BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln1056">   {  return this-&gt;rbegin();  }</a>
<a name="ln1057"> </a>
<a name="ln1058">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns a const_reverse_iterator pointing to the end</a>
<a name="ln1059">   //! of the reversed stable_vector.</a>
<a name="ln1060">   //!</a>
<a name="ln1061">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln1062">   //!</a>
<a name="ln1063">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln1064">   const_reverse_iterator crend()const BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln1065">   {  return this-&gt;rend(); }</a>
<a name="ln1066"> </a>
<a name="ln1067">   //////////////////////////////////////////////</a>
<a name="ln1068">   //</a>
<a name="ln1069">   //                capacity</a>
<a name="ln1070">   //</a>
<a name="ln1071">   //////////////////////////////////////////////</a>
<a name="ln1072"> </a>
<a name="ln1073">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns true if the stable_vector contains no elements.</a>
<a name="ln1074">   //!</a>
<a name="ln1075">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln1076">   //!</a>
<a name="ln1077">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln1078">   bool empty() const BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln1079">   {  return this-&gt;index.size() &lt;= ExtraPointers;  }</a>
<a name="ln1080"> </a>
<a name="ln1081">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns the number of the elements contained in the stable_vector.</a>
<a name="ln1082">   //!</a>
<a name="ln1083">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln1084">   //!</a>
<a name="ln1085">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln1086">   size_type size() const BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln1087">   {</a>
<a name="ln1088">      const size_type index_size = this-&gt;index.size();</a>
<a name="ln1089">      return (index_size - ExtraPointers) &amp; (size_type(0u) -size_type(index_size != 0));</a>
<a name="ln1090">   }</a>
<a name="ln1091"> </a>
<a name="ln1092">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns the largest possible size of the stable_vector.</a>
<a name="ln1093">   //!</a>
<a name="ln1094">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln1095">   //!</a>
<a name="ln1096">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln1097">   size_type max_size() const BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln1098">   {  return this-&gt;index.max_size() - ExtraPointers;  }</a>
<a name="ln1099"> </a>
<a name="ln1100">   //! &lt;b&gt;Effects&lt;/b&gt;: Inserts or erases elements at the end such that</a>
<a name="ln1101">   //!   the size becomes n. New elements are value initialized.</a>
<a name="ln1102">   //!</a>
<a name="ln1103">   //! &lt;b&gt;Throws&lt;/b&gt;: If memory allocation throws, or T's value initialization throws.</a>
<a name="ln1104">   //!</a>
<a name="ln1105">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear to the difference between size() and new_size.</a>
<a name="ln1106">   void resize(size_type n)</a>
<a name="ln1107">   {</a>
<a name="ln1108">      typedef value_init_construct_iterator&lt;value_type, difference_type&gt; value_init_iterator;</a>
<a name="ln1109">      STABLE_VECTOR_CHECK_INVARIANT;</a>
<a name="ln1110">      if(n &gt; this-&gt;size())</a>
<a name="ln1111">         this-&gt;insert(this-&gt;cend(), value_init_iterator(n - this-&gt;size()), value_init_iterator());</a>
<a name="ln1112">      else if(n &lt; this-&gt;size())</a>
<a name="ln1113">         this-&gt;erase(this-&gt;cbegin() + n, this-&gt;cend());</a>
<a name="ln1114">   }</a>
<a name="ln1115"> </a>
<a name="ln1116">   //! &lt;b&gt;Effects&lt;/b&gt;: Inserts or erases elements at the end such that</a>
<a name="ln1117">   //!   the size becomes n. New elements are default initialized.</a>
<a name="ln1118">   //!</a>
<a name="ln1119">   //! &lt;b&gt;Throws&lt;/b&gt;: If memory allocation throws, or T's default initialization throws.</a>
<a name="ln1120">   //!</a>
<a name="ln1121">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear to the difference between size() and new_size.</a>
<a name="ln1122">   //!</a>
<a name="ln1123">   //! &lt;b&gt;Note&lt;/b&gt;: Non-standard extension</a>
<a name="ln1124">   void resize(size_type n, default_init_t)</a>
<a name="ln1125">   {</a>
<a name="ln1126">      typedef default_init_construct_iterator&lt;value_type, difference_type&gt; default_init_iterator;</a>
<a name="ln1127">      STABLE_VECTOR_CHECK_INVARIANT;</a>
<a name="ln1128">      if(n &gt; this-&gt;size())</a>
<a name="ln1129">         this-&gt;insert(this-&gt;cend(), default_init_iterator(n - this-&gt;size()), default_init_iterator());</a>
<a name="ln1130">      else if(n &lt; this-&gt;size())</a>
<a name="ln1131">         this-&gt;erase(this-&gt;cbegin() + n, this-&gt;cend());</a>
<a name="ln1132">   }</a>
<a name="ln1133"> </a>
<a name="ln1134">   //! &lt;b&gt;Effects&lt;/b&gt;: Inserts or erases elements at the end such that</a>
<a name="ln1135">   //!   the size becomes n. New elements are copy constructed from x.</a>
<a name="ln1136">   //!</a>
<a name="ln1137">   //! &lt;b&gt;Throws&lt;/b&gt;: If memory allocation throws, or T's copy constructor throws.</a>
<a name="ln1138">   //!</a>
<a name="ln1139">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear to the difference between size() and new_size.</a>
<a name="ln1140">   void resize(size_type n, const T&amp; t)</a>
<a name="ln1141">   {</a>
<a name="ln1142">      STABLE_VECTOR_CHECK_INVARIANT;</a>
<a name="ln1143">      if(n &gt; this-&gt;size())</a>
<a name="ln1144">         this-&gt;insert(this-&gt;cend(), n - this-&gt;size(), t);</a>
<a name="ln1145">      else if(n &lt; this-&gt;size())</a>
<a name="ln1146">         this-&gt;erase(this-&gt;cbegin() + n, this-&gt;cend());</a>
<a name="ln1147">   }</a>
<a name="ln1148"> </a>
<a name="ln1149">   //! &lt;b&gt;Effects&lt;/b&gt;: Number of elements for which memory has been allocated.</a>
<a name="ln1150">   //!   capacity() is always greater than or equal to size().</a>
<a name="ln1151">   //!</a>
<a name="ln1152">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln1153">   //!</a>
<a name="ln1154">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln1155">   size_type capacity() const BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln1156">   {</a>
<a name="ln1157">      const size_type index_size             = this-&gt;index.size();</a>
<a name="ln1158">      BOOST_ASSERT(!index_size || index_size &gt;= ExtraPointers);</a>
<a name="ln1159">      const size_type node_extra_capacity   = this-&gt;internal_data.pool_size;</a>
<a name="ln1160">      //Pool count must be less than index capacity, as index is a vector</a>
<a name="ln1161">      BOOST_ASSERT(node_extra_capacity &lt;= (this-&gt;index.capacity()- index_size));</a>
<a name="ln1162">      const size_type index_offset =</a>
<a name="ln1163">         (node_extra_capacity - ExtraPointers) &amp; (size_type(0u) - size_type(index_size != 0));</a>
<a name="ln1164">      return index_size + index_offset;</a>
<a name="ln1165">   }</a>
<a name="ln1166"> </a>
<a name="ln1167">   //! &lt;b&gt;Effects&lt;/b&gt;: If n is less than or equal to capacity(), this call has no</a>
<a name="ln1168">   //!   effect. Otherwise, it is a request for allocation of additional memory.</a>
<a name="ln1169">   //!   If the request is successful, then capacity() is greater than or equal to</a>
<a name="ln1170">   //!   n; otherwise, capacity() is unchanged. In either case, size() is unchanged.</a>
<a name="ln1171">   //!</a>
<a name="ln1172">   //! &lt;b&gt;Throws&lt;/b&gt;: If memory allocation allocation throws.</a>
<a name="ln1173">   void reserve(size_type n)</a>
<a name="ln1174">   {</a>
<a name="ln1175">      STABLE_VECTOR_CHECK_INVARIANT;</a>
<a name="ln1176">      if(n &gt; this-&gt;max_size()){</a>
<a name="ln1177">         throw_length_error(&quot;stable_vector::reserve max_size() exceeded&quot;);</a>
<a name="ln1178">      }</a>
<a name="ln1179"> </a>
<a name="ln1180">      size_type sz         = this-&gt;size();</a>
<a name="ln1181">      size_type old_capacity = this-&gt;capacity();</a>
<a name="ln1182">      if(n &gt; old_capacity){</a>
<a name="ln1183">         index_traits_type::initialize_end_node(this-&gt;index, this-&gt;internal_data.end_node, n);</a>
<a name="ln1184">         const void * old_ptr = &amp;index[0];</a>
<a name="ln1185">         this-&gt;index.reserve(n + ExtraPointers);</a>
<a name="ln1186">         bool realloced = &amp;index[0] != old_ptr;</a>
<a name="ln1187">         //Fix the pointers for the newly allocated buffer</a>
<a name="ln1188">         if(realloced){</a>
<a name="ln1189">            index_traits_type::fix_up_pointers_from(this-&gt;index, this-&gt;index.begin());</a>
<a name="ln1190">         }</a>
<a name="ln1191">         //Now fill pool if data is not enough</a>
<a name="ln1192">         if((n - sz) &gt; this-&gt;internal_data.pool_size){</a>
<a name="ln1193">            this-&gt;priv_increase_pool((n - sz) - this-&gt;internal_data.pool_size);</a>
<a name="ln1194">         }</a>
<a name="ln1195">      }</a>
<a name="ln1196">   }</a>
<a name="ln1197"> </a>
<a name="ln1198">   //! &lt;b&gt;Effects&lt;/b&gt;: Tries to deallocate the excess of memory created</a>
<a name="ln1199">   //!   with previous allocations. The size of the stable_vector is unchanged</a>
<a name="ln1200">   //!</a>
<a name="ln1201">   //! &lt;b&gt;Throws&lt;/b&gt;: If memory allocation throws.</a>
<a name="ln1202">   //!</a>
<a name="ln1203">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear to size().</a>
<a name="ln1204">   void shrink_to_fit()</a>
<a name="ln1205">   {</a>
<a name="ln1206">      if(this-&gt;capacity()){</a>
<a name="ln1207">         //First empty allocated node pool</a>
<a name="ln1208">         this-&gt;priv_clear_pool();</a>
<a name="ln1209">         //If empty completely destroy the index, let's recover default-constructed state</a>
<a name="ln1210">         if(this-&gt;empty()){</a>
<a name="ln1211">            this-&gt;index.clear();</a>
<a name="ln1212">            this-&gt;index.shrink_to_fit();</a>
<a name="ln1213">            this-&gt;internal_data.end_node.up = node_base_ptr_ptr();</a>
<a name="ln1214">         }</a>
<a name="ln1215">         //Otherwise, try to shrink-to-fit the index and readjust pointers if necessary</a>
<a name="ln1216">         else{</a>
<a name="ln1217">            const void* old_ptr = &amp;index[0];</a>
<a name="ln1218">            this-&gt;index.shrink_to_fit();</a>
<a name="ln1219">            bool realloced = &amp;index[0] != old_ptr;</a>
<a name="ln1220">            //Fix the pointers for the newly allocated buffer</a>
<a name="ln1221">            if(realloced){</a>
<a name="ln1222">               index_traits_type::fix_up_pointers_from(this-&gt;index, this-&gt;index.begin());</a>
<a name="ln1223">            }</a>
<a name="ln1224">         }</a>
<a name="ln1225">      }</a>
<a name="ln1226">   }</a>
<a name="ln1227"> </a>
<a name="ln1228">   //////////////////////////////////////////////</a>
<a name="ln1229">   //</a>
<a name="ln1230">   //               element access</a>
<a name="ln1231">   //</a>
<a name="ln1232">   //////////////////////////////////////////////</a>
<a name="ln1233"> </a>
<a name="ln1234">   //! &lt;b&gt;Requires&lt;/b&gt;: !empty()</a>
<a name="ln1235">   //!</a>
<a name="ln1236">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns a reference to the first</a>
<a name="ln1237">   //!   element of the container.</a>
<a name="ln1238">   //!</a>
<a name="ln1239">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln1240">   //!</a>
<a name="ln1241">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln1242">   reference front() BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln1243">   {</a>
<a name="ln1244">      BOOST_ASSERT(!this-&gt;empty());</a>
<a name="ln1245">      return static_cast&lt;node_reference&gt;(*this-&gt;index.front()).get_data();</a>
<a name="ln1246">   }</a>
<a name="ln1247"> </a>
<a name="ln1248">   //! &lt;b&gt;Requires&lt;/b&gt;: !empty()</a>
<a name="ln1249">   //!</a>
<a name="ln1250">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns a const reference to the first</a>
<a name="ln1251">   //!   element of the container.</a>
<a name="ln1252">   //!</a>
<a name="ln1253">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln1254">   //!</a>
<a name="ln1255">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln1256">   const_reference front() const BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln1257">   {</a>
<a name="ln1258">      BOOST_ASSERT(!this-&gt;empty());</a>
<a name="ln1259">      return static_cast&lt;const_node_reference&gt;(*this-&gt;index.front()).get_data();</a>
<a name="ln1260">   }</a>
<a name="ln1261"> </a>
<a name="ln1262">   //! &lt;b&gt;Requires&lt;/b&gt;: !empty()</a>
<a name="ln1263">   //!</a>
<a name="ln1264">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns a reference to the last</a>
<a name="ln1265">   //!   element of the container.</a>
<a name="ln1266">   //!</a>
<a name="ln1267">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln1268">   //!</a>
<a name="ln1269">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln1270">   reference back() BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln1271">   {</a>
<a name="ln1272">      BOOST_ASSERT(!this-&gt;empty());</a>
<a name="ln1273">      return static_cast&lt;node_reference&gt;(*this-&gt;index[this-&gt;size()-1u]).get_data();</a>
<a name="ln1274">   }</a>
<a name="ln1275"> </a>
<a name="ln1276">   //! &lt;b&gt;Requires&lt;/b&gt;: !empty()</a>
<a name="ln1277">   //!</a>
<a name="ln1278">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns a const reference to the last</a>
<a name="ln1279">   //!   element of the container.</a>
<a name="ln1280">   //!</a>
<a name="ln1281">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln1282">   //!</a>
<a name="ln1283">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln1284">   const_reference back() const BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln1285">   {</a>
<a name="ln1286">      BOOST_ASSERT(!this-&gt;empty());</a>
<a name="ln1287">      return static_cast&lt;const_node_reference&gt;(*this-&gt;index[this-&gt;size()-1u]).get_data();</a>
<a name="ln1288">   }</a>
<a name="ln1289"> </a>
<a name="ln1290">   //! &lt;b&gt;Requires&lt;/b&gt;: size() &gt; n.</a>
<a name="ln1291">   //!</a>
<a name="ln1292">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns a reference to the nth element</a>
<a name="ln1293">   //!   from the beginning of the container.</a>
<a name="ln1294">   //!</a>
<a name="ln1295">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln1296">   //!</a>
<a name="ln1297">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln1298">   reference operator[](size_type n) BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln1299">   {</a>
<a name="ln1300">      BOOST_ASSERT(this-&gt;size() &gt; n);</a>
<a name="ln1301">      return static_cast&lt;node_reference&gt;(*this-&gt;index[n]).get_data();</a>
<a name="ln1302">   }</a>
<a name="ln1303"> </a>
<a name="ln1304">   //! &lt;b&gt;Requires&lt;/b&gt;: size() &gt; n.</a>
<a name="ln1305">   //!</a>
<a name="ln1306">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns a const reference to the nth element</a>
<a name="ln1307">   //!   from the beginning of the container.</a>
<a name="ln1308">   //!</a>
<a name="ln1309">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln1310">   //!</a>
<a name="ln1311">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln1312">   const_reference operator[](size_type n) const BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln1313">   {</a>
<a name="ln1314">      BOOST_ASSERT(this-&gt;size() &gt; n);</a>
<a name="ln1315">      return static_cast&lt;const_node_reference&gt;(*this-&gt;index[n]).get_data();</a>
<a name="ln1316">   }</a>
<a name="ln1317"> </a>
<a name="ln1318">   //! &lt;b&gt;Requires&lt;/b&gt;: size() &gt;= n.</a>
<a name="ln1319">   //!</a>
<a name="ln1320">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns an iterator to the nth element</a>
<a name="ln1321">   //!   from the beginning of the container. Returns end()</a>
<a name="ln1322">   //!   if n == size().</a>
<a name="ln1323">   //!</a>
<a name="ln1324">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln1325">   //!</a>
<a name="ln1326">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln1327">   //!</a>
<a name="ln1328">   //! &lt;b&gt;Note&lt;/b&gt;: Non-standard extension</a>
<a name="ln1329">   iterator nth(size_type n) BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln1330">   {</a>
<a name="ln1331">      BOOST_ASSERT(this-&gt;size() &gt;= n);</a>
<a name="ln1332">      return (this-&gt;index.empty()) ? this-&gt;end() : iterator(node_ptr_traits::static_cast_from(this-&gt;index[n]));</a>
<a name="ln1333">   }</a>
<a name="ln1334"> </a>
<a name="ln1335">   //! &lt;b&gt;Requires&lt;/b&gt;: size() &gt;= n.</a>
<a name="ln1336">   //!</a>
<a name="ln1337">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns a const_iterator to the nth element</a>
<a name="ln1338">   //!   from the beginning of the container. Returns end()</a>
<a name="ln1339">   //!   if n == size().</a>
<a name="ln1340">   //!</a>
<a name="ln1341">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln1342">   //!</a>
<a name="ln1343">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln1344">   //!</a>
<a name="ln1345">   //! &lt;b&gt;Note&lt;/b&gt;: Non-standard extension</a>
<a name="ln1346">   const_iterator nth(size_type n) const BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln1347">   {</a>
<a name="ln1348">      BOOST_ASSERT(this-&gt;size() &gt;= n);</a>
<a name="ln1349">      return (this-&gt;index.empty()) ? this-&gt;cend() : iterator(node_ptr_traits::static_cast_from(this-&gt;index[n]));</a>
<a name="ln1350">   }</a>
<a name="ln1351"> </a>
<a name="ln1352">   //! &lt;b&gt;Requires&lt;/b&gt;: begin() &lt;= p &lt;= end().</a>
<a name="ln1353">   //!</a>
<a name="ln1354">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns the index of the element pointed by p</a>
<a name="ln1355">   //!   and size() if p == end().</a>
<a name="ln1356">   //!</a>
<a name="ln1357">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln1358">   //!</a>
<a name="ln1359">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln1360">   //!</a>
<a name="ln1361">   //! &lt;b&gt;Note&lt;/b&gt;: Non-standard extension</a>
<a name="ln1362">   size_type index_of(iterator p) BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln1363">   {  return this-&gt;priv_index_of(p.node_pointer());  }</a>
<a name="ln1364"> </a>
<a name="ln1365">   //! &lt;b&gt;Requires&lt;/b&gt;: begin() &lt;= p &lt;= end().</a>
<a name="ln1366">   //!</a>
<a name="ln1367">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns the index of the element pointed by p</a>
<a name="ln1368">   //!   and size() if p == end().</a>
<a name="ln1369">   //!</a>
<a name="ln1370">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln1371">   //!</a>
<a name="ln1372">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln1373">   //!</a>
<a name="ln1374">   //! &lt;b&gt;Note&lt;/b&gt;: Non-standard extension</a>
<a name="ln1375">   size_type index_of(const_iterator p) const BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln1376">   {  return this-&gt;priv_index_of(p.node_pointer());  }</a>
<a name="ln1377"> </a>
<a name="ln1378">   //! &lt;b&gt;Requires&lt;/b&gt;: size() &gt; n.</a>
<a name="ln1379">   //!</a>
<a name="ln1380">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns a reference to the nth element</a>
<a name="ln1381">   //!   from the beginning of the container.</a>
<a name="ln1382">   //!</a>
<a name="ln1383">   //! &lt;b&gt;Throws&lt;/b&gt;: std::range_error if n &gt;= size()</a>
<a name="ln1384">   //!</a>
<a name="ln1385">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln1386">   reference at(size_type n)</a>
<a name="ln1387">   {</a>
<a name="ln1388">      if(n &gt;= this-&gt;size()){</a>
<a name="ln1389">         throw_out_of_range(&quot;vector::at invalid subscript&quot;);</a>
<a name="ln1390">      }</a>
<a name="ln1391">      return operator[](n);</a>
<a name="ln1392">   }</a>
<a name="ln1393"> </a>
<a name="ln1394">   //! &lt;b&gt;Requires&lt;/b&gt;: size() &gt; n.</a>
<a name="ln1395">   //!</a>
<a name="ln1396">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns a const reference to the nth element</a>
<a name="ln1397">   //!   from the beginning of the container.</a>
<a name="ln1398">   //!</a>
<a name="ln1399">   //! &lt;b&gt;Throws&lt;/b&gt;: std::range_error if n &gt;= size()</a>
<a name="ln1400">   //!</a>
<a name="ln1401">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln1402">   const_reference at(size_type n)const</a>
<a name="ln1403">   {</a>
<a name="ln1404">      if(n &gt;= this-&gt;size()){</a>
<a name="ln1405">         throw_out_of_range(&quot;vector::at invalid subscript&quot;);</a>
<a name="ln1406">      }</a>
<a name="ln1407">      return operator[](n);</a>
<a name="ln1408">   }</a>
<a name="ln1409"> </a>
<a name="ln1410">   //////////////////////////////////////////////</a>
<a name="ln1411">   //</a>
<a name="ln1412">   //                modifiers</a>
<a name="ln1413">   //</a>
<a name="ln1414">   //////////////////////////////////////////////</a>
<a name="ln1415"> </a>
<a name="ln1416">   #if !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) || defined(BOOST_CONTAINER_DOXYGEN_INVOKED)</a>
<a name="ln1417"> </a>
<a name="ln1418">   //! &lt;b&gt;Effects&lt;/b&gt;: Inserts an object of type T constructed with</a>
<a name="ln1419">   //!   std::forward&lt;Args&gt;(args)... in the end of the stable_vector.</a>
<a name="ln1420">   //!</a>
<a name="ln1421">   //! &lt;b&gt;Returns&lt;/b&gt;: A reference to the created object.</a>
<a name="ln1422">   //!</a>
<a name="ln1423">   //! &lt;b&gt;Throws&lt;/b&gt;: If memory allocation throws or the in-place constructor throws.</a>
<a name="ln1424">   //!</a>
<a name="ln1425">   //! &lt;b&gt;Complexity&lt;/b&gt;: Amortized constant time.</a>
<a name="ln1426">   template&lt;class ...Args&gt;</a>
<a name="ln1427">   reference emplace_back(Args &amp;&amp;...args)</a>
<a name="ln1428">   {</a>
<a name="ln1429">      typedef emplace_functor&lt;Args...&gt;         EmplaceFunctor;</a>
<a name="ln1430">      typedef emplace_iterator&lt;value_type, EmplaceFunctor, difference_type&gt; EmplaceIterator;</a>
<a name="ln1431">      EmplaceFunctor &amp;&amp;ef = EmplaceFunctor(boost::forward&lt;Args&gt;(args)...);</a>
<a name="ln1432">      return *this-&gt;insert(this-&gt;cend(), EmplaceIterator(ef), EmplaceIterator());</a>
<a name="ln1433">   }</a>
<a name="ln1434"> </a>
<a name="ln1435">   //! &lt;b&gt;Requires&lt;/b&gt;: p must be a valid iterator of *this.</a>
<a name="ln1436">   //!</a>
<a name="ln1437">   //! &lt;b&gt;Effects&lt;/b&gt;: Inserts an object of type T constructed with</a>
<a name="ln1438">   //!   std::forward&lt;Args&gt;(args)... before p</a>
<a name="ln1439">   //!</a>
<a name="ln1440">   //! &lt;b&gt;Throws&lt;/b&gt;: If memory allocation throws or the in-place constructor throws.</a>
<a name="ln1441">   //!</a>
<a name="ln1442">   //! &lt;b&gt;Complexity&lt;/b&gt;: If p is end(), amortized constant time</a>
<a name="ln1443">   //!   Linear time otherwise.</a>
<a name="ln1444">   template&lt;class ...Args&gt;</a>
<a name="ln1445">   iterator emplace(const_iterator p, Args &amp;&amp; ...args)</a>
<a name="ln1446">   {</a>
<a name="ln1447">      BOOST_ASSERT(this-&gt;priv_in_range_or_end(p));</a>
<a name="ln1448">      size_type pos_n = p - cbegin();</a>
<a name="ln1449">      typedef emplace_functor&lt;Args...&gt;         EmplaceFunctor;</a>
<a name="ln1450">      typedef emplace_iterator&lt;value_type, EmplaceFunctor, difference_type&gt; EmplaceIterator;</a>
<a name="ln1451">      EmplaceFunctor &amp;&amp;ef = EmplaceFunctor(boost::forward&lt;Args&gt;(args)...);</a>
<a name="ln1452">      this-&gt;insert(p, EmplaceIterator(ef), EmplaceIterator());</a>
<a name="ln1453">      return iterator(this-&gt;begin() + pos_n);</a>
<a name="ln1454">   }</a>
<a name="ln1455"> </a>
<a name="ln1456">   #else</a>
<a name="ln1457"> </a>
<a name="ln1458">   #define BOOST_CONTAINER_STABLE_VECTOR_EMPLACE_CODE(N) \</a>
<a name="ln1459">   BOOST_MOVE_TMPL_LT##N BOOST_MOVE_CLASS##N BOOST_MOVE_GT##N \</a>
<a name="ln1460">   reference emplace_back(BOOST_MOVE_UREF##N)\</a>
<a name="ln1461">   {\</a>
<a name="ln1462">      typedef emplace_functor##N\</a>
<a name="ln1463">         BOOST_MOVE_LT##N BOOST_MOVE_TARG##N BOOST_MOVE_GT##N EmplaceFunctor;\</a>
<a name="ln1464">      typedef emplace_iterator&lt;value_type, EmplaceFunctor, difference_type&gt;  EmplaceIterator;\</a>
<a name="ln1465">      EmplaceFunctor ef BOOST_MOVE_LP##N BOOST_MOVE_FWD##N BOOST_MOVE_RP##N;\</a>
<a name="ln1466">      return *this-&gt;insert(this-&gt;cend() , EmplaceIterator(ef), EmplaceIterator());\</a>
<a name="ln1467">   }\</a>
<a name="ln1468">   \</a>
<a name="ln1469">   BOOST_MOVE_TMPL_LT##N BOOST_MOVE_CLASS##N BOOST_MOVE_GT##N \</a>
<a name="ln1470">   iterator emplace(const_iterator p BOOST_MOVE_I##N BOOST_MOVE_UREF##N)\</a>
<a name="ln1471">   {\</a>
<a name="ln1472">      BOOST_ASSERT(this-&gt;priv_in_range_or_end(p));\</a>
<a name="ln1473">      typedef emplace_functor##N\</a>
<a name="ln1474">         BOOST_MOVE_LT##N BOOST_MOVE_TARG##N BOOST_MOVE_GT##N EmplaceFunctor;\</a>
<a name="ln1475">      typedef emplace_iterator&lt;value_type, EmplaceFunctor, difference_type&gt;  EmplaceIterator;\</a>
<a name="ln1476">      EmplaceFunctor ef BOOST_MOVE_LP##N BOOST_MOVE_FWD##N BOOST_MOVE_RP##N;\</a>
<a name="ln1477">      const size_type pos_n = p - this-&gt;cbegin();\</a>
<a name="ln1478">      this-&gt;insert(p, EmplaceIterator(ef), EmplaceIterator());\</a>
<a name="ln1479">      return this-&gt;begin() += pos_n;\</a>
<a name="ln1480">   }\</a>
<a name="ln1481">   //</a>
<a name="ln1482">   BOOST_MOVE_ITERATE_0TO9(BOOST_CONTAINER_STABLE_VECTOR_EMPLACE_CODE)</a>
<a name="ln1483">   #undef BOOST_CONTAINER_STABLE_VECTOR_EMPLACE_CODE</a>
<a name="ln1484"> </a>
<a name="ln1485">   #endif   // !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES)</a>
<a name="ln1486"> </a>
<a name="ln1487">   #if defined(BOOST_CONTAINER_DOXYGEN_INVOKED)</a>
<a name="ln1488">   //! &lt;b&gt;Effects&lt;/b&gt;: Inserts a copy of x at the end of the stable_vector.</a>
<a name="ln1489">   //!</a>
<a name="ln1490">   //! &lt;b&gt;Throws&lt;/b&gt;: If memory allocation throws or</a>
<a name="ln1491">   //!   T's copy constructor throws.</a>
<a name="ln1492">   //!</a>
<a name="ln1493">   //! &lt;b&gt;Complexity&lt;/b&gt;: Amortized constant time.</a>
<a name="ln1494">   void push_back(const T &amp;x);</a>
<a name="ln1495"> </a>
<a name="ln1496">   //! &lt;b&gt;Effects&lt;/b&gt;: Constructs a new element in the end of the stable_vector</a>
<a name="ln1497">   //!   and moves the resources of x to this new element.</a>
<a name="ln1498">   //!</a>
<a name="ln1499">   //! &lt;b&gt;Throws&lt;/b&gt;: If memory allocation throws.</a>
<a name="ln1500">   //!</a>
<a name="ln1501">   //! &lt;b&gt;Complexity&lt;/b&gt;: Amortized constant time.</a>
<a name="ln1502">   void push_back(T &amp;&amp;x);</a>
<a name="ln1503">   #else</a>
<a name="ln1504">   BOOST_MOVE_CONVERSION_AWARE_CATCH(push_back, T, void, priv_push_back)</a>
<a name="ln1505">   #endif</a>
<a name="ln1506"> </a>
<a name="ln1507">   #if defined(BOOST_CONTAINER_DOXYGEN_INVOKED)</a>
<a name="ln1508">   //! &lt;b&gt;Requires&lt;/b&gt;: p must be a valid iterator of *this.</a>
<a name="ln1509">   //!</a>
<a name="ln1510">   //! &lt;b&gt;Effects&lt;/b&gt;: Insert a copy of x before p.</a>
<a name="ln1511">   //!</a>
<a name="ln1512">   //! &lt;b&gt;Returns&lt;/b&gt;: An iterator to the inserted element.</a>
<a name="ln1513">   //!</a>
<a name="ln1514">   //! &lt;b&gt;Throws&lt;/b&gt;: If memory allocation throws or x's copy constructor throws.</a>
<a name="ln1515">   //!</a>
<a name="ln1516">   //! &lt;b&gt;Complexity&lt;/b&gt;: If p is end(), amortized constant time</a>
<a name="ln1517">   //!   Linear time otherwise.</a>
<a name="ln1518">   iterator insert(const_iterator p, const T &amp;x);</a>
<a name="ln1519"> </a>
<a name="ln1520">   //! &lt;b&gt;Requires&lt;/b&gt;: p must be a valid iterator of *this.</a>
<a name="ln1521">   //!</a>
<a name="ln1522">   //! &lt;b&gt;Effects&lt;/b&gt;: Insert a new element before p with x's resources.</a>
<a name="ln1523">   //!</a>
<a name="ln1524">   //! &lt;b&gt;Returns&lt;/b&gt;: an iterator to the inserted element.</a>
<a name="ln1525">   //!</a>
<a name="ln1526">   //! &lt;b&gt;Throws&lt;/b&gt;: If memory allocation throws.</a>
<a name="ln1527">   //!</a>
<a name="ln1528">   //! &lt;b&gt;Complexity&lt;/b&gt;: If p is end(), amortized constant time</a>
<a name="ln1529">   //!   Linear time otherwise.</a>
<a name="ln1530">   iterator insert(const_iterator p, T &amp;&amp;x);</a>
<a name="ln1531">   #else</a>
<a name="ln1532">   BOOST_MOVE_CONVERSION_AWARE_CATCH_1ARG(insert, T, iterator, priv_insert, const_iterator, const_iterator)</a>
<a name="ln1533">   #endif</a>
<a name="ln1534"> </a>
<a name="ln1535">   //! &lt;b&gt;Requires&lt;/b&gt;: p must be a valid iterator of *this.</a>
<a name="ln1536">   //!</a>
<a name="ln1537">   //! &lt;b&gt;Effects&lt;/b&gt;: Insert n copies of x before p.</a>
<a name="ln1538">   //!</a>
<a name="ln1539">   //! &lt;b&gt;Returns&lt;/b&gt;: an iterator to the first inserted element or p if n is 0.</a>
<a name="ln1540">   //!</a>
<a name="ln1541">   //! &lt;b&gt;Throws&lt;/b&gt;: If memory allocation throws or T's copy constructor throws.</a>
<a name="ln1542">   //!</a>
<a name="ln1543">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear to n.</a>
<a name="ln1544">   iterator insert(const_iterator p, size_type n, const T&amp; t)</a>
<a name="ln1545">   {</a>
<a name="ln1546">      BOOST_ASSERT(this-&gt;priv_in_range_or_end(p));</a>
<a name="ln1547">      STABLE_VECTOR_CHECK_INVARIANT;</a>
<a name="ln1548">      typedef constant_iterator&lt;value_type, difference_type&gt; cvalue_iterator;</a>
<a name="ln1549">      return this-&gt;insert(p, cvalue_iterator(t, n), cvalue_iterator());</a>
<a name="ln1550">   }</a>
<a name="ln1551"> </a>
<a name="ln1552">   //! &lt;b&gt;Requires&lt;/b&gt;: p must be a valid iterator of *this.</a>
<a name="ln1553">#if !defined(BOOST_NO_CXX11_HDR_INITIALIZER_LIST)</a>
<a name="ln1554">   //! &lt;b&gt;Requires&lt;/b&gt;: p must be a valid iterator of *this.</a>
<a name="ln1555">   //!</a>
<a name="ln1556">   //! &lt;b&gt;Effects&lt;/b&gt;: Insert a copy of the [il.begin(), il.end()) range before p.</a>
<a name="ln1557">   //!</a>
<a name="ln1558">   //! &lt;b&gt;Returns&lt;/b&gt;: an iterator to the first inserted element or p if first == last.</a>
<a name="ln1559">   //!</a>
<a name="ln1560">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear to distance [il.begin(), il.end()).</a>
<a name="ln1561">   iterator insert(const_iterator p, std::initializer_list&lt;value_type&gt; il)</a>
<a name="ln1562">   {</a>
<a name="ln1563">      //Position checks done by insert()</a>
<a name="ln1564">      STABLE_VECTOR_CHECK_INVARIANT;</a>
<a name="ln1565">      return insert(p, il.begin(), il.end());</a>
<a name="ln1566">   }</a>
<a name="ln1567">#endif</a>
<a name="ln1568"> </a>
<a name="ln1569">   //! &lt;b&gt;Requires&lt;/b&gt;: pos must be a valid iterator of *this.</a>
<a name="ln1570">   //!</a>
<a name="ln1571">   //! &lt;b&gt;Effects&lt;/b&gt;: Insert a copy of the [first, last) range before p.</a>
<a name="ln1572">   //!</a>
<a name="ln1573">   //! &lt;b&gt;Returns&lt;/b&gt;: an iterator to the first inserted element or p if first == last.</a>
<a name="ln1574">   //!</a>
<a name="ln1575">   //! &lt;b&gt;Throws&lt;/b&gt;: If memory allocation throws, T's constructor from a</a>
<a name="ln1576">   //!   dereferenced InpIt throws or T's copy constructor throws.</a>
<a name="ln1577">   //!</a>
<a name="ln1578">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear to distance [first, last).</a>
<a name="ln1579">   template &lt;class InputIterator&gt;</a>
<a name="ln1580">   iterator insert(const_iterator p, InputIterator first, InputIterator last</a>
<a name="ln1581">         #if !defined(BOOST_CONTAINER_DOXYGEN_INVOKED)</a>
<a name="ln1582">         //Put this as argument instead of the return type as old GCC's like 3.4</a>
<a name="ln1583">         //detect this and the next disable_if_or as overloads</a>
<a name="ln1584">         ,  typename dtl::disable_if_or</a>
<a name="ln1585">               &lt; void</a>
<a name="ln1586">               , dtl::is_convertible&lt;InputIterator, size_type&gt;</a>
<a name="ln1587">               , dtl::is_not_input_iterator&lt;InputIterator&gt;</a>
<a name="ln1588">               &gt;::type* = 0</a>
<a name="ln1589">         #endif</a>
<a name="ln1590">         )</a>
<a name="ln1591">   {</a>
<a name="ln1592">      BOOST_ASSERT(this-&gt;priv_in_range_or_end(p));</a>
<a name="ln1593">      STABLE_VECTOR_CHECK_INVARIANT;</a>
<a name="ln1594">      const size_type pos_n = p - this-&gt;cbegin();</a>
<a name="ln1595">      for(; first != last; ++first){</a>
<a name="ln1596">         this-&gt;emplace(p, *first);</a>
<a name="ln1597">      }</a>
<a name="ln1598">      return this-&gt;begin() + pos_n;</a>
<a name="ln1599">   }</a>
<a name="ln1600"> </a>
<a name="ln1601">   #if !defined(BOOST_CONTAINER_DOXYGEN_INVOKED)</a>
<a name="ln1602">   template &lt;class FwdIt&gt;</a>
<a name="ln1603">   typename dtl::disable_if_or</a>
<a name="ln1604">      &lt; iterator</a>
<a name="ln1605">      , dtl::is_convertible&lt;FwdIt, size_type&gt;</a>
<a name="ln1606">      , dtl::is_input_iterator&lt;FwdIt&gt;</a>
<a name="ln1607">      &gt;::type</a>
<a name="ln1608">      insert(const_iterator p, FwdIt first, FwdIt last)</a>
<a name="ln1609">   {</a>
<a name="ln1610">      BOOST_ASSERT(this-&gt;priv_in_range_or_end(p));</a>
<a name="ln1611">      const size_type num_new = static_cast&lt;size_type&gt;(boost::container::iterator_distance(first, last));</a>
<a name="ln1612">      const size_type idx     = static_cast&lt;size_type&gt;(p - this-&gt;cbegin());</a>
<a name="ln1613">      if(num_new){</a>
<a name="ln1614">         //Fills the node pool and inserts num_new null pointers in idx.</a>
<a name="ln1615">         //If a new buffer was needed fixes up pointers up to idx so</a>
<a name="ln1616">         //past-new nodes are not aligned until the end of this function</a>
<a name="ln1617">         //or in a rollback in case of exception</a>
<a name="ln1618">         index_iterator it_past_newly_constructed(this-&gt;priv_insert_forward_non_templated(idx, num_new));</a>
<a name="ln1619">         const index_iterator it_past_new(it_past_newly_constructed + num_new);</a>
<a name="ln1620">         {</a>
<a name="ln1621">            //Prepare rollback</a>
<a name="ln1622">            insert_rollback rollback(*this, it_past_newly_constructed, it_past_new);</a>
<a name="ln1623">            while(first != last){</a>
<a name="ln1624">               const node_ptr n = this-&gt;priv_get_from_pool();</a>
<a name="ln1625">               BOOST_ASSERT(!!n);</a>
<a name="ln1626">               //Put it in the index so rollback can return it in pool if construct_in_place throws</a>
<a name="ln1627">               *it_past_newly_constructed = n;</a>
<a name="ln1628">               //Constructs and fixes up pointers This can throw</a>
<a name="ln1629">               this-&gt;priv_build_node_from_it(n, it_past_newly_constructed, first);</a>
<a name="ln1630">               ++first;</a>
<a name="ln1631">               ++it_past_newly_constructed;</a>
<a name="ln1632">            }</a>
<a name="ln1633">            //rollback.~insert_rollback() called in case of exception</a>
<a name="ln1634">         }</a>
<a name="ln1635">         //Fix up pointers for past-new nodes (new nodes were fixed during construction) and</a>
<a name="ln1636">         //nodes before insertion p in priv_insert_forward_non_templated(...)</a>
<a name="ln1637">         index_traits_type::fix_up_pointers_from(this-&gt;index, it_past_newly_constructed);</a>
<a name="ln1638">      }</a>
<a name="ln1639">      return this-&gt;begin() + idx;</a>
<a name="ln1640">   }</a>
<a name="ln1641">   #endif</a>
<a name="ln1642"> </a>
<a name="ln1643">   //! &lt;b&gt;Effects&lt;/b&gt;: Removes the last element from the stable_vector.</a>
<a name="ln1644">   //!</a>
<a name="ln1645">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln1646">   //!</a>
<a name="ln1647">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant time.</a>
<a name="ln1648">   void pop_back() BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln1649">   {</a>
<a name="ln1650">      BOOST_ASSERT(!this-&gt;empty());</a>
<a name="ln1651">      this-&gt;erase(--this-&gt;cend());</a>
<a name="ln1652">   }</a>
<a name="ln1653"> </a>
<a name="ln1654">   //! &lt;b&gt;Effects&lt;/b&gt;: Erases the element at p.</a>
<a name="ln1655">   //!</a>
<a name="ln1656">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln1657">   //!</a>
<a name="ln1658">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear to the elements between p and the</a>
<a name="ln1659">   //!   last element. Constant if p is the last element.</a>
<a name="ln1660">   iterator erase(const_iterator p) BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln1661">   {</a>
<a name="ln1662">      BOOST_ASSERT(this-&gt;priv_in_range(p));</a>
<a name="ln1663">      STABLE_VECTOR_CHECK_INVARIANT;</a>
<a name="ln1664">      const size_type d = p - this-&gt;cbegin();</a>
<a name="ln1665">      index_iterator it = this-&gt;index.begin() + d;</a>
<a name="ln1666">      this-&gt;priv_delete_node(p.node_pointer());</a>
<a name="ln1667">      it = this-&gt;index.erase(it);</a>
<a name="ln1668">      index_traits_type::fix_up_pointers_from(this-&gt;index, it);</a>
<a name="ln1669">      return iterator(node_ptr_traits::static_cast_from(*it));</a>
<a name="ln1670">   }</a>
<a name="ln1671"> </a>
<a name="ln1672">   //! &lt;b&gt;Effects&lt;/b&gt;: Erases the elements pointed by [first, last).</a>
<a name="ln1673">   //!</a>
<a name="ln1674">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln1675">   //!</a>
<a name="ln1676">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear to the distance between first and last</a>
<a name="ln1677">   //!   plus linear to the elements between p and the last element.</a>
<a name="ln1678">   iterator erase(const_iterator first, const_iterator last) BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln1679">   {</a>
<a name="ln1680">      BOOST_ASSERT(first == last ||</a>
<a name="ln1681">         (first &lt; last &amp;&amp; this-&gt;priv_in_range(first) &amp;&amp; this-&gt;priv_in_range_or_end(last)));</a>
<a name="ln1682">      STABLE_VECTOR_CHECK_INVARIANT;</a>
<a name="ln1683">      const const_iterator cbeg(this-&gt;cbegin());</a>
<a name="ln1684">      const size_type d1 = static_cast&lt;size_type&gt;(first - cbeg),</a>
<a name="ln1685">                      d2 = static_cast&lt;size_type&gt;(last  - cbeg);</a>
<a name="ln1686">      size_type d_dif = d2 - d1;</a>
<a name="ln1687">      if(d_dif){</a>
<a name="ln1688">         multiallocation_chain holder;</a>
<a name="ln1689">         const index_iterator it1(this-&gt;index.begin() + d1);</a>
<a name="ln1690">         const index_iterator it2(it1 + d_dif);</a>
<a name="ln1691">         index_iterator it(it1);</a>
<a name="ln1692">         while(d_dif--){</a>
<a name="ln1693">            node_base_ptr &amp;nb = *it;</a>
<a name="ln1694">            ++it;</a>
<a name="ln1695">            node_type &amp;n = *node_ptr_traits::static_cast_from(nb);</a>
<a name="ln1696">            this-&gt;priv_destroy_node(n);</a>
<a name="ln1697">            holder.push_back(node_ptr_traits::pointer_to(n));</a>
<a name="ln1698">         }</a>
<a name="ln1699">         this-&gt;priv_put_in_pool(holder);</a>
<a name="ln1700">         const index_iterator e = this-&gt;index.erase(it1, it2);</a>
<a name="ln1701">         index_traits_type::fix_up_pointers_from(this-&gt;index, e);</a>
<a name="ln1702">      }</a>
<a name="ln1703">      return iterator(last.node_pointer());</a>
<a name="ln1704">   }</a>
<a name="ln1705"> </a>
<a name="ln1706">   //! &lt;b&gt;Effects&lt;/b&gt;: Swaps the contents of *this and x.</a>
<a name="ln1707">   //!</a>
<a name="ln1708">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln1709">   //!</a>
<a name="ln1710">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln1711">   void swap(stable_vector &amp; x)</a>
<a name="ln1712">      BOOST_NOEXCEPT_IF( allocator_traits_type::propagate_on_container_swap::value</a>
<a name="ln1713">                                || allocator_traits_type::is_always_equal::value)</a>
<a name="ln1714">   {</a>
<a name="ln1715">      BOOST_ASSERT(allocator_traits_type::propagate_on_container_swap::value ||</a>
<a name="ln1716">                   allocator_traits_type::is_always_equal::value ||</a>
<a name="ln1717">                   this-&gt;get_stored_allocator() == x.get_stored_allocator());</a>
<a name="ln1718">      STABLE_VECTOR_CHECK_INVARIANT;</a>
<a name="ln1719">      dtl::bool_&lt;allocator_traits_type::propagate_on_container_swap::value&gt; flag;</a>
<a name="ln1720">      dtl::swap_alloc(this-&gt;priv_node_alloc(), x.priv_node_alloc(), flag);</a>
<a name="ln1721">      //vector's allocator is swapped here</a>
<a name="ln1722">      this-&gt;index.swap(x.index);</a>
<a name="ln1723">      this-&gt;priv_swap_members(x);</a>
<a name="ln1724">   }</a>
<a name="ln1725"> </a>
<a name="ln1726">   //! &lt;b&gt;Effects&lt;/b&gt;: Erases all the elements of the stable_vector.</a>
<a name="ln1727">   //!</a>
<a name="ln1728">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln1729">   //!</a>
<a name="ln1730">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear to the number of elements in the stable_vector.</a>
<a name="ln1731">   void clear() BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln1732">   {   this-&gt;erase(this-&gt;cbegin(),this-&gt;cend()); }</a>
<a name="ln1733"> </a>
<a name="ln1734">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns true if x and y are equal</a>
<a name="ln1735">   //!</a>
<a name="ln1736">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear to the number of elements in the container.</a>
<a name="ln1737">   friend bool operator==(const stable_vector&amp; x, const stable_vector&amp; y)</a>
<a name="ln1738">   {  return x.size() == y.size() &amp;&amp; ::boost::container::algo_equal(x.begin(), x.end(), y.begin());  }</a>
<a name="ln1739"> </a>
<a name="ln1740">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns true if x and y are unequal</a>
<a name="ln1741">   //!</a>
<a name="ln1742">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear to the number of elements in the container.</a>
<a name="ln1743">   friend bool operator!=(const stable_vector&amp; x, const stable_vector&amp; y)</a>
<a name="ln1744">   {  return !(x == y); }</a>
<a name="ln1745"> </a>
<a name="ln1746">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns true if x is less than y</a>
<a name="ln1747">   //!</a>
<a name="ln1748">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear to the number of elements in the container.</a>
<a name="ln1749">   friend bool operator&lt;(const stable_vector&amp; x, const stable_vector&amp; y)</a>
<a name="ln1750">   {  return ::boost::container::algo_lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());  }</a>
<a name="ln1751"> </a>
<a name="ln1752">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns true if x is greater than y</a>
<a name="ln1753">   //!</a>
<a name="ln1754">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear to the number of elements in the container.</a>
<a name="ln1755">   friend bool operator&gt;(const stable_vector&amp; x, const stable_vector&amp; y)</a>
<a name="ln1756">   {  return y &lt; x;  }</a>
<a name="ln1757"> </a>
<a name="ln1758">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns true if x is equal or less than y</a>
<a name="ln1759">   //!</a>
<a name="ln1760">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear to the number of elements in the container.</a>
<a name="ln1761">   friend bool operator&lt;=(const stable_vector&amp; x, const stable_vector&amp; y)</a>
<a name="ln1762">   {  return !(y &lt; x);  }</a>
<a name="ln1763"> </a>
<a name="ln1764">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns true if x is equal or greater than y</a>
<a name="ln1765">   //!</a>
<a name="ln1766">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear to the number of elements in the container.</a>
<a name="ln1767">   friend bool operator&gt;=(const stable_vector&amp; x, const stable_vector&amp; y)</a>
<a name="ln1768">   {  return !(x &lt; y);  }</a>
<a name="ln1769"> </a>
<a name="ln1770">   //! &lt;b&gt;Effects&lt;/b&gt;: x.swap(y)</a>
<a name="ln1771">   //!</a>
<a name="ln1772">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln1773">   friend void swap(stable_vector&amp; x, stable_vector&amp; y)</a>
<a name="ln1774">   {  x.swap(y);  }</a>
<a name="ln1775"> </a>
<a name="ln1776">   #ifndef BOOST_CONTAINER_DOXYGEN_INVOKED</a>
<a name="ln1777">   private:</a>
<a name="ln1778"> </a>
<a name="ln1779">   bool priv_in_range(const_iterator pos) const</a>
<a name="ln1780">   {</a>
<a name="ln1781">      return (this-&gt;begin() &lt;= pos) &amp;&amp; (pos &lt; this-&gt;end());</a>
<a name="ln1782">   }</a>
<a name="ln1783"> </a>
<a name="ln1784">   bool priv_in_range_or_end(const_iterator pos) const</a>
<a name="ln1785">   {</a>
<a name="ln1786">      return (this-&gt;begin() &lt;= pos) &amp;&amp; (pos &lt;= this-&gt;end());</a>
<a name="ln1787">   }</a>
<a name="ln1788"> </a>
<a name="ln1789">   size_type priv_index_of(node_ptr p) const</a>
<a name="ln1790">   {</a>
<a name="ln1791">      //Check range</a>
<a name="ln1792">      BOOST_ASSERT(this-&gt;index.empty() || (this-&gt;index.data() &lt;= p-&gt;up));</a>
<a name="ln1793">      BOOST_ASSERT(this-&gt;index.empty() || p-&gt;up &lt;= (this-&gt;index.data() + this-&gt;index.size()));</a>
<a name="ln1794">      return this-&gt;index.empty() ? 0 : p-&gt;up - this-&gt;index.data();</a>
<a name="ln1795">   }</a>
<a name="ln1796"> </a>
<a name="ln1797">   class insert_rollback</a>
<a name="ln1798">   {</a>
<a name="ln1799">      public:</a>
<a name="ln1800"> </a>
<a name="ln1801">      insert_rollback(stable_vector &amp;sv, index_iterator &amp;it_past_constructed, const index_iterator &amp;it_past_new)</a>
<a name="ln1802">         : m_sv(sv), m_it_past_constructed(it_past_constructed), m_it_past_new(it_past_new)</a>
<a name="ln1803">      {}</a>
<a name="ln1804"> </a>
<a name="ln1805">      ~insert_rollback()</a>
<a name="ln1806">      {</a>
<a name="ln1807">         if(m_it_past_constructed != m_it_past_new){</a>
<a name="ln1808">            m_sv.priv_put_in_pool(node_ptr_traits::static_cast_from(*m_it_past_constructed));</a>
<a name="ln1809">            index_iterator e = m_sv.index.erase(m_it_past_constructed, m_it_past_new);</a>
<a name="ln1810">            index_traits_type::fix_up_pointers_from(m_sv.index, e);</a>
<a name="ln1811">         }</a>
<a name="ln1812">      }</a>
<a name="ln1813"> </a>
<a name="ln1814">      private:</a>
<a name="ln1815">      stable_vector &amp;m_sv;</a>
<a name="ln1816">      index_iterator &amp;m_it_past_constructed;</a>
<a name="ln1817">      const index_iterator &amp;m_it_past_new;</a>
<a name="ln1818">   };</a>
<a name="ln1819"> </a>
<a name="ln1820">   class push_back_rollback</a>
<a name="ln1821">   {</a>
<a name="ln1822">      public:</a>
<a name="ln1823">      push_back_rollback(stable_vector &amp;sv, const node_ptr &amp;p)</a>
<a name="ln1824">         : m_sv(sv), m_p(p)</a>
<a name="ln1825">      {}</a>
<a name="ln1826"> </a>
<a name="ln1827">      ~push_back_rollback()</a>
<a name="ln1828">      {</a>
<a name="ln1829">         if(m_p){</a>
<a name="ln1830">            m_sv.priv_put_in_pool(m_p);</a>
<a name="ln1831">         }</a>
<a name="ln1832">      }</a>
<a name="ln1833"> </a>
<a name="ln1834">      void release()</a>
<a name="ln1835">      {  m_p = node_ptr();  }</a>
<a name="ln1836"> </a>
<a name="ln1837">      private:</a>
<a name="ln1838">      stable_vector &amp;m_sv;</a>
<a name="ln1839">      node_ptr m_p;</a>
<a name="ln1840">   };</a>
<a name="ln1841"> </a>
<a name="ln1842">   index_iterator priv_insert_forward_non_templated(size_type idx, size_type num_new)</a>
<a name="ln1843">   {</a>
<a name="ln1844">      index_traits_type::initialize_end_node(this-&gt;index, this-&gt;internal_data.end_node, num_new);</a>
<a name="ln1845"> </a>
<a name="ln1846">      //Now try to fill the pool with new data</a>
<a name="ln1847">      if(this-&gt;internal_data.pool_size &lt; num_new){</a>
<a name="ln1848">         this-&gt;priv_increase_pool(num_new - this-&gt;internal_data.pool_size);</a>
<a name="ln1849">      }</a>
<a name="ln1850"> </a>
<a name="ln1851">      //Now try to make room in the vector</a>
<a name="ln1852">      const node_base_ptr_ptr old_buffer = this-&gt;index.data();</a>
<a name="ln1853">      this-&gt;index.insert(this-&gt;index.begin() + idx, num_new, node_ptr());</a>
<a name="ln1854">      bool new_buffer = this-&gt;index.data() != old_buffer;</a>
<a name="ln1855"> </a>
<a name="ln1856">      //Fix the pointers for the newly allocated buffer</a>
<a name="ln1857">      const index_iterator index_beg = this-&gt;index.begin();</a>
<a name="ln1858">      if(new_buffer){</a>
<a name="ln1859">         index_traits_type::fix_up_pointers(index_beg, index_beg + idx);</a>
<a name="ln1860">      }</a>
<a name="ln1861">      return index_beg + idx;</a>
<a name="ln1862">   }</a>
<a name="ln1863"> </a>
<a name="ln1864">   bool priv_capacity_bigger_than_size() const</a>
<a name="ln1865">   {</a>
<a name="ln1866">      return this-&gt;index.capacity() &gt; this-&gt;index.size() &amp;&amp;</a>
<a name="ln1867">             this-&gt;internal_data.pool_size &gt; 0;</a>
<a name="ln1868">   }</a>
<a name="ln1869"> </a>
<a name="ln1870">   template &lt;class U&gt;</a>
<a name="ln1871">   void priv_push_back(BOOST_MOVE_CATCH_FWD(U) x)</a>
<a name="ln1872">   {</a>
<a name="ln1873">      if(BOOST_LIKELY(this-&gt;priv_capacity_bigger_than_size())){</a>
<a name="ln1874">         //Enough memory in the pool and in the index</a>
<a name="ln1875">         const node_ptr p = this-&gt;priv_get_from_pool();</a>
<a name="ln1876">         BOOST_ASSERT(!!p);</a>
<a name="ln1877">         {</a>
<a name="ln1878">            push_back_rollback rollback(*this, p);</a>
<a name="ln1879">            //This might throw</a>
<a name="ln1880">            this-&gt;priv_build_node_from_convertible(p, ::boost::forward&lt;U&gt;(x));</a>
<a name="ln1881">            rollback.release();</a>
<a name="ln1882">         }</a>
<a name="ln1883">         //This can't throw as there is room for a new elements in the index</a>
<a name="ln1884">         index_iterator new_index = this-&gt;index.insert(this-&gt;index.end() - ExtraPointers, p);</a>
<a name="ln1885">         index_traits_type::fix_up_pointers_from(this-&gt;index, new_index);</a>
<a name="ln1886">      }</a>
<a name="ln1887">      else{</a>
<a name="ln1888">         this-&gt;insert(this-&gt;cend(), ::boost::forward&lt;U&gt;(x));</a>
<a name="ln1889">      }</a>
<a name="ln1890">   }</a>
<a name="ln1891"> </a>
<a name="ln1892">   iterator priv_insert(const_iterator p, const value_type &amp;t)</a>
<a name="ln1893">   {</a>
<a name="ln1894">      BOOST_ASSERT(this-&gt;priv_in_range_or_end(p));</a>
<a name="ln1895">      typedef constant_iterator&lt;value_type, difference_type&gt; cvalue_iterator;</a>
<a name="ln1896">      return this-&gt;insert(p, cvalue_iterator(t, 1), cvalue_iterator());</a>
<a name="ln1897">   }</a>
<a name="ln1898"> </a>
<a name="ln1899">   iterator priv_insert(const_iterator p, BOOST_RV_REF(T) x)</a>
<a name="ln1900">   {</a>
<a name="ln1901">      BOOST_ASSERT(this-&gt;priv_in_range_or_end(p));</a>
<a name="ln1902">      typedef repeat_iterator&lt;T, difference_type&gt;  repeat_it;</a>
<a name="ln1903">      typedef boost::move_iterator&lt;repeat_it&gt;      repeat_move_it;</a>
<a name="ln1904">      //Just call more general insert(p, size, value) and return iterator</a>
<a name="ln1905">      return this-&gt;insert(p, repeat_move_it(repeat_it(x, 1)), repeat_move_it(repeat_it()));</a>
<a name="ln1906">   }</a>
<a name="ln1907"> </a>
<a name="ln1908">   void priv_clear_pool()</a>
<a name="ln1909">   {</a>
<a name="ln1910">      if(!this-&gt;index.empty() &amp;&amp; this-&gt;index.back()){</a>
<a name="ln1911">         node_base_ptr &amp;pool_first_ref = *(this-&gt;index.end() - 2);</a>
<a name="ln1912">         node_base_ptr &amp;pool_last_ref  = this-&gt;index.back();</a>
<a name="ln1913"> </a>
<a name="ln1914">         multiallocation_chain holder;</a>
<a name="ln1915">         holder.incorporate_after( holder.before_begin()</a>
<a name="ln1916">                                 , node_ptr_traits::static_cast_from(pool_first_ref)</a>
<a name="ln1917">                                 , node_ptr_traits::static_cast_from(pool_last_ref)</a>
<a name="ln1918">                                 , internal_data.pool_size);</a>
<a name="ln1919">         this-&gt;deallocate_individual(holder);</a>
<a name="ln1920">         pool_first_ref = pool_last_ref = 0;</a>
<a name="ln1921">         this-&gt;internal_data.pool_size = 0;</a>
<a name="ln1922">      }</a>
<a name="ln1923">   }</a>
<a name="ln1924"> </a>
<a name="ln1925">   void priv_increase_pool(size_type n)</a>
<a name="ln1926">   {</a>
<a name="ln1927">      node_base_ptr &amp;pool_first_ref = *(this-&gt;index.end() - 2);</a>
<a name="ln1928">      node_base_ptr &amp;pool_last_ref  = this-&gt;index.back();</a>
<a name="ln1929">      multiallocation_chain holder;</a>
<a name="ln1930">      holder.incorporate_after( holder.before_begin()</a>
<a name="ln1931">                              , node_ptr_traits::static_cast_from(pool_first_ref)</a>
<a name="ln1932">                              , node_ptr_traits::static_cast_from(pool_last_ref)</a>
<a name="ln1933">                              , internal_data.pool_size);</a>
<a name="ln1934">      multiallocation_chain m;</a>
<a name="ln1935">      this-&gt;allocate_individual(n, m);</a>
<a name="ln1936">      holder.splice_after(holder.before_begin(), m, m.before_begin(), m.last(), n);</a>
<a name="ln1937">      this-&gt;internal_data.pool_size += n;</a>
<a name="ln1938">      std::pair&lt;node_ptr, node_ptr&gt; data(holder.extract_data());</a>
<a name="ln1939">      pool_first_ref = data.first;</a>
<a name="ln1940">      pool_last_ref = data.second;</a>
<a name="ln1941">   }</a>
<a name="ln1942"> </a>
<a name="ln1943">   void priv_put_in_pool(const node_ptr &amp;p)</a>
<a name="ln1944">   {</a>
<a name="ln1945">      node_base_ptr &amp;pool_first_ref = *(this-&gt;index.end()-2);</a>
<a name="ln1946">      node_base_ptr &amp;pool_last_ref  = this-&gt;index.back();</a>
<a name="ln1947">      multiallocation_chain holder;</a>
<a name="ln1948">      holder.incorporate_after( holder.before_begin()</a>
<a name="ln1949">                              , node_ptr_traits::static_cast_from(pool_first_ref)</a>
<a name="ln1950">                              , node_ptr_traits::static_cast_from(pool_last_ref)</a>
<a name="ln1951">                              , internal_data.pool_size);</a>
<a name="ln1952">      holder.push_front(p);</a>
<a name="ln1953">      ++this-&gt;internal_data.pool_size;</a>
<a name="ln1954">      std::pair&lt;node_ptr, node_ptr&gt; ret(holder.extract_data());</a>
<a name="ln1955">      pool_first_ref = ret.first;</a>
<a name="ln1956">      pool_last_ref  = ret.second;</a>
<a name="ln1957">   }</a>
<a name="ln1958"> </a>
<a name="ln1959">   void priv_put_in_pool(multiallocation_chain &amp;ch)</a>
<a name="ln1960">   {</a>
<a name="ln1961">      node_base_ptr &amp;pool_first_ref = *(this-&gt;index.end()-(ExtraPointers-1));</a>
<a name="ln1962">      node_base_ptr &amp;pool_last_ref  = this-&gt;index.back();</a>
<a name="ln1963">      ch.incorporate_after( ch.before_begin()</a>
<a name="ln1964">                          , node_ptr_traits::static_cast_from(pool_first_ref)</a>
<a name="ln1965">                          , node_ptr_traits::static_cast_from(pool_last_ref)</a>
<a name="ln1966">                          , internal_data.pool_size);</a>
<a name="ln1967">      this-&gt;internal_data.pool_size = ch.size();</a>
<a name="ln1968">      const std::pair&lt;node_ptr, node_ptr&gt; ret(ch.extract_data());</a>
<a name="ln1969">      pool_first_ref = ret.first;</a>
<a name="ln1970">      pool_last_ref  = ret.second;</a>
<a name="ln1971">   }</a>
<a name="ln1972"> </a>
<a name="ln1973">   node_ptr priv_get_from_pool()</a>
<a name="ln1974">   {</a>
<a name="ln1975">      //Precondition: index is not empty</a>
<a name="ln1976">      BOOST_ASSERT(!this-&gt;index.empty());</a>
<a name="ln1977">      node_base_ptr &amp;pool_first_ref = *(this-&gt;index.end() - (ExtraPointers-1));</a>
<a name="ln1978">      node_base_ptr &amp;pool_last_ref  = this-&gt;index.back();</a>
<a name="ln1979">      multiallocation_chain holder;</a>
<a name="ln1980">      holder.incorporate_after( holder.before_begin()</a>
<a name="ln1981">                              , node_ptr_traits::static_cast_from(pool_first_ref)</a>
<a name="ln1982">                              , node_ptr_traits::static_cast_from(pool_last_ref)</a>
<a name="ln1983">                              , internal_data.pool_size);</a>
<a name="ln1984">      node_ptr ret = holder.pop_front();</a>
<a name="ln1985">      --this-&gt;internal_data.pool_size;</a>
<a name="ln1986">      if(!internal_data.pool_size){</a>
<a name="ln1987">         pool_first_ref = pool_last_ref = node_ptr();</a>
<a name="ln1988">      }</a>
<a name="ln1989">      else{</a>
<a name="ln1990">         const std::pair&lt;node_ptr, node_ptr&gt; data(holder.extract_data());</a>
<a name="ln1991">         pool_first_ref = data.first;</a>
<a name="ln1992">         pool_last_ref  = data.second;</a>
<a name="ln1993">      }</a>
<a name="ln1994">      return ret;</a>
<a name="ln1995">   }</a>
<a name="ln1996"> </a>
<a name="ln1997">   node_base_ptr priv_get_end_node() const</a>
<a name="ln1998">   {  return node_base_ptr_traits::pointer_to(const_cast&lt;node_base_type&amp;&gt;(this-&gt;internal_data.end_node));  }</a>
<a name="ln1999"> </a>
<a name="ln2000">   void priv_destroy_node(const node_type &amp;n)</a>
<a name="ln2001">   {</a>
<a name="ln2002">      allocator_traits&lt;node_allocator_type&gt;::</a>
<a name="ln2003">         destroy(this-&gt;priv_node_alloc(), &amp;n);</a>
<a name="ln2004">   }</a>
<a name="ln2005"> </a>
<a name="ln2006">   void priv_delete_node(const node_ptr &amp;n)</a>
<a name="ln2007">   {</a>
<a name="ln2008">      this-&gt;priv_destroy_node(*n);</a>
<a name="ln2009">      this-&gt;priv_put_in_pool(n);</a>
<a name="ln2010">   }</a>
<a name="ln2011"> </a>
<a name="ln2012">   template&lt;class Iterator&gt;</a>
<a name="ln2013">   void priv_build_node_from_it(const node_ptr &amp;p, const index_iterator &amp;up_index, const Iterator &amp;it)</a>
<a name="ln2014">   {</a>
<a name="ln2015">      node_type *praw = ::new(boost::movelib::iterator_to_raw_pointer(p), boost_container_new_t())</a>
<a name="ln2016">         node_type(index_traits_type::ptr_to_node_base_ptr(*up_index));</a>
<a name="ln2017">      BOOST_TRY{</a>
<a name="ln2018">         //This can throw</a>
<a name="ln2019">         boost::container::construct_in_place</a>
<a name="ln2020">            ( this-&gt;priv_node_alloc()</a>
<a name="ln2021">            , praw-&gt;get_data_ptr()</a>
<a name="ln2022">            , it);</a>
<a name="ln2023">      }</a>
<a name="ln2024">      BOOST_CATCH(...) {</a>
<a name="ln2025">         praw-&gt;destroy_header();</a>
<a name="ln2026">         this-&gt;priv_node_alloc().deallocate(p, 1);</a>
<a name="ln2027">         BOOST_RETHROW</a>
<a name="ln2028">      }</a>
<a name="ln2029">      BOOST_CATCH_END</a>
<a name="ln2030">   }</a>
<a name="ln2031"> </a>
<a name="ln2032">   template&lt;class ValueConvertible&gt;</a>
<a name="ln2033">   void priv_build_node_from_convertible(const node_ptr &amp;p, BOOST_FWD_REF(ValueConvertible) value_convertible)</a>
<a name="ln2034">   {</a>
<a name="ln2035">      node_type *praw = ::new(boost::movelib::iterator_to_raw_pointer(p), boost_container_new_t()) node_type;</a>
<a name="ln2036">      BOOST_TRY{</a>
<a name="ln2037">         //This can throw</a>
<a name="ln2038">         boost::container::allocator_traits&lt;node_allocator_type&gt;::construct</a>
<a name="ln2039">            ( this-&gt;priv_node_alloc()</a>
<a name="ln2040">            , p-&gt;get_data_ptr()</a>
<a name="ln2041">            , ::boost::forward&lt;ValueConvertible&gt;(value_convertible));</a>
<a name="ln2042">      }</a>
<a name="ln2043">      BOOST_CATCH(...) {</a>
<a name="ln2044">         praw-&gt;destroy_header();</a>
<a name="ln2045">         this-&gt;priv_node_alloc().deallocate(p, 1);</a>
<a name="ln2046">         BOOST_RETHROW</a>
<a name="ln2047">      }</a>
<a name="ln2048">      BOOST_CATCH_END</a>
<a name="ln2049">   }</a>
<a name="ln2050"> </a>
<a name="ln2051">   void priv_swap_members(stable_vector &amp;x)</a>
<a name="ln2052">   {</a>
<a name="ln2053">      boost::adl_move_swap(this-&gt;internal_data.pool_size, x.internal_data.pool_size);</a>
<a name="ln2054">      index_traits_type::readjust_end_node(this-&gt;index, this-&gt;internal_data.end_node);</a>
<a name="ln2055">      index_traits_type::readjust_end_node(x.index, x.internal_data.end_node);</a>
<a name="ln2056">   }</a>
<a name="ln2057"> </a>
<a name="ln2058">   #if defined(STABLE_VECTOR_ENABLE_INVARIANT_CHECKING)</a>
<a name="ln2059">   bool priv_invariant()const</a>
<a name="ln2060">   {</a>
<a name="ln2061">      index_type &amp; index_ref =  const_cast&lt;index_type&amp;&gt;(this-&gt;index);</a>
<a name="ln2062"> </a>
<a name="ln2063">      const size_type index_size = this-&gt;index.size();</a>
<a name="ln2064">      if(!index_size)</a>
<a name="ln2065">         return !this-&gt;capacity() &amp;&amp; !this-&gt;size();</a>
<a name="ln2066"> </a>
<a name="ln2067">      if(index_size &lt; ExtraPointers)</a>
<a name="ln2068">         return false;</a>
<a name="ln2069"> </a>
<a name="ln2070">      const size_type bucket_extra_capacity = this-&gt;index.capacity()- index_size;</a>
<a name="ln2071">      const size_type node_extra_capacity   = this-&gt;internal_data.pool_size;</a>
<a name="ln2072">      if(bucket_extra_capacity &lt; node_extra_capacity){</a>
<a name="ln2073">         return false;</a>
<a name="ln2074">      }</a>
<a name="ln2075"> </a>
<a name="ln2076">      if(this-&gt;priv_get_end_node() != *(index.end() - ExtraPointers)){</a>
<a name="ln2077">         return false;</a>
<a name="ln2078">      }</a>
<a name="ln2079"> </a>
<a name="ln2080">      if(!index_traits_type::invariants(index_ref)){</a>
<a name="ln2081">         return false;</a>
<a name="ln2082">      }</a>
<a name="ln2083"> </a>
<a name="ln2084">      size_type n = this-&gt;capacity() - this-&gt;size();</a>
<a name="ln2085">      node_base_ptr &amp;pool_first_ref = *(index_ref.end() - (ExtraPointers-1));</a>
<a name="ln2086">      node_base_ptr &amp;pool_last_ref  = index_ref.back();</a>
<a name="ln2087">      multiallocation_chain holder;</a>
<a name="ln2088">      holder.incorporate_after( holder.before_begin()</a>
<a name="ln2089">                              , node_ptr_traits::static_cast_from(pool_first_ref)</a>
<a name="ln2090">                              , node_ptr_traits::static_cast_from(pool_last_ref)</a>
<a name="ln2091">                              , internal_data.pool_size);</a>
<a name="ln2092">      typename multiallocation_chain::iterator beg(holder.begin()), end(holder.end());</a>
<a name="ln2093">      size_type num_pool = 0;</a>
<a name="ln2094">      while(beg != end){</a>
<a name="ln2095">         ++num_pool;</a>
<a name="ln2096">         ++beg;</a>
<a name="ln2097">      }</a>
<a name="ln2098">      return n &gt;= num_pool &amp;&amp; num_pool == internal_data.pool_size;</a>
<a name="ln2099">   }</a>
<a name="ln2100"> </a>
<a name="ln2101">   class invariant_checker</a>
<a name="ln2102">   {</a>
<a name="ln2103">      invariant_checker(const invariant_checker &amp;);</a>
<a name="ln2104">      invariant_checker &amp; operator=(const invariant_checker &amp;);</a>
<a name="ln2105">      const stable_vector* p;</a>
<a name="ln2106"> </a>
<a name="ln2107">      public:</a>
<a name="ln2108">      invariant_checker(const stable_vector&amp; v):p(&amp;v){}</a>
<a name="ln2109">      ~invariant_checker(){BOOST_ASSERT(p-&gt;priv_invariant());}</a>
<a name="ln2110">      void touch(){}</a>
<a name="ln2111">   };</a>
<a name="ln2112">   #endif</a>
<a name="ln2113"> </a>
<a name="ln2114">   class ebo_holder</a>
<a name="ln2115">      : public node_allocator_type</a>
<a name="ln2116">   {</a>
<a name="ln2117">      private:</a>
<a name="ln2118">      BOOST_MOVABLE_BUT_NOT_COPYABLE(ebo_holder)</a>
<a name="ln2119"> </a>
<a name="ln2120">      public:</a>
<a name="ln2121">      template&lt;class AllocatorRLValue&gt;</a>
<a name="ln2122">      explicit ebo_holder(BOOST_FWD_REF(AllocatorRLValue) a)</a>
<a name="ln2123">         : node_allocator_type(boost::forward&lt;AllocatorRLValue&gt;(a))</a>
<a name="ln2124">         , pool_size(0)</a>
<a name="ln2125">         , end_node()</a>
<a name="ln2126">      {}</a>
<a name="ln2127"> </a>
<a name="ln2128">      ebo_holder()</a>
<a name="ln2129">         : node_allocator_type()</a>
<a name="ln2130">         , pool_size(0)</a>
<a name="ln2131">         , end_node()</a>
<a name="ln2132">      {}</a>
<a name="ln2133"> </a>
<a name="ln2134">      size_type pool_size;</a>
<a name="ln2135">      node_base_type end_node;</a>
<a name="ln2136">   } internal_data;</a>
<a name="ln2137"> </a>
<a name="ln2138">   node_allocator_type &amp;priv_node_alloc()              { return internal_data;  }</a>
<a name="ln2139">   const node_allocator_type &amp;priv_node_alloc() const  { return internal_data;  }</a>
<a name="ln2140"> </a>
<a name="ln2141">   index_type                           index;</a>
<a name="ln2142">   #endif   //#ifndef BOOST_CONTAINER_DOXYGEN_INVOKED</a>
<a name="ln2143">};</a>
<a name="ln2144"> </a>
<a name="ln2145">#ifndef BOOST_CONTAINER_NO_CXX17_CTAD</a>
<a name="ln2146"> </a>
<a name="ln2147">template &lt;typename InputIterator&gt;</a>
<a name="ln2148">stable_vector(InputIterator, InputIterator) -&gt;</a>
<a name="ln2149">   stable_vector&lt;typename iterator_traits&lt;InputIterator&gt;::value_type&gt;;</a>
<a name="ln2150"> </a>
<a name="ln2151">template &lt;typename InputIterator, typename Allocator&gt;</a>
<a name="ln2152">stable_vector(InputIterator, InputIterator, Allocator const&amp;) -&gt;</a>
<a name="ln2153">   stable_vector&lt;typename iterator_traits&lt;InputIterator&gt;::value_type, Allocator&gt;;</a>
<a name="ln2154"> </a>
<a name="ln2155">#endif</a>
<a name="ln2156"> </a>
<a name="ln2157">#ifndef BOOST_CONTAINER_DOXYGEN_INVOKED</a>
<a name="ln2158"> </a>
<a name="ln2159">#undef STABLE_VECTOR_CHECK_INVARIANT</a>
<a name="ln2160"> </a>
<a name="ln2161">}  //namespace container {</a>
<a name="ln2162"> </a>
<a name="ln2163">//!has_trivial_destructor_after_move&lt;&gt; == true_type</a>
<a name="ln2164">//!specialization for optimizations</a>
<a name="ln2165">template &lt;class T, class Allocator&gt;</a>
<a name="ln2166">struct has_trivial_destructor_after_move&lt;boost::container::stable_vector&lt;T, Allocator&gt; &gt;</a>
<a name="ln2167">{</a>
<a name="ln2168">   typedef typename ::boost::container::allocator_traits&lt;Allocator&gt;::pointer pointer;</a>
<a name="ln2169">   static const bool value = ::boost::has_trivial_destructor_after_move&lt;Allocator&gt;::value &amp;&amp;</a>
<a name="ln2170">                             ::boost::has_trivial_destructor_after_move&lt;pointer&gt;::value;</a>
<a name="ln2171">};</a>
<a name="ln2172"> </a>
<a name="ln2173">namespace container {</a>
<a name="ln2174"> </a>
<a name="ln2175">#endif   //#ifndef BOOST_CONTAINER_DOXYGEN_INVOKED</a>
<a name="ln2176"> </a>
<a name="ln2177">}} //namespace boost{  namespace container {</a>
<a name="ln2178"> </a>
<a name="ln2179">#include &lt;boost/container/detail/config_end.hpp&gt;</a>
<a name="ln2180"> </a>
<a name="ln2181">#endif   //BOOST_CONTAINER_STABLE_VECTOR_HPP</a>

</code></pre>
<div class="balloon" rel="154"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: m_storage.</p></div>
<div class="balloon" rel="158"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: m_storage.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
