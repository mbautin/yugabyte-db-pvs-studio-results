
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>block_based_table_builder.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//  Copyright (c) 2011-present, Facebook, Inc.  All rights reserved.</a>
<a name="ln2">//  This source code is licensed under the BSD-style license found in the</a>
<a name="ln3">//  LICENSE file in the root directory of this source tree. An additional grant</a>
<a name="ln4">//  of patent rights can be found in the PATENTS file in the same directory.</a>
<a name="ln5">//</a>
<a name="ln6">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln7">//</a>
<a name="ln8">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln9">//</a>
<a name="ln10">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln11">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln12">//</a>
<a name="ln13">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln14">//</a>
<a name="ln15">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln16">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln17">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln18">// under the License.</a>
<a name="ln19">//</a>
<a name="ln20">// Copyright (c) 2011 The LevelDB Authors. All rights reserved.</a>
<a name="ln21">// Use of this source code is governed by a BSD-style license that can be</a>
<a name="ln22">// found in the LICENSE file. See the AUTHORS file for names of contributors.</a>
<a name="ln23"> </a>
<a name="ln24">#include &quot;yb/rocksdb/table/block_based_table_builder.h&quot;</a>
<a name="ln25"> </a>
<a name="ln26">#include &lt;assert.h&gt;</a>
<a name="ln27">#include &lt;inttypes.h&gt;</a>
<a name="ln28">#include &lt;stdio.h&gt;</a>
<a name="ln29"> </a>
<a name="ln30">#include &lt;map&gt;</a>
<a name="ln31">#include &lt;memory&gt;</a>
<a name="ln32">#include &lt;string&gt;</a>
<a name="ln33">#include &lt;unordered_map&gt;</a>
<a name="ln34">#include &lt;utility&gt;</a>
<a name="ln35"> </a>
<a name="ln36">#include &quot;yb/rocksdb/db/dbformat.h&quot;</a>
<a name="ln37"> </a>
<a name="ln38">#include &quot;yb/rocksdb/cache.h&quot;</a>
<a name="ln39">#include &quot;yb/rocksdb/comparator.h&quot;</a>
<a name="ln40">#include &quot;yb/rocksdb/env.h&quot;</a>
<a name="ln41">#include &quot;yb/rocksdb/filter_policy.h&quot;</a>
<a name="ln42">#include &quot;yb/rocksdb/flush_block_policy.h&quot;</a>
<a name="ln43">#include &quot;yb/rocksdb/table.h&quot;</a>
<a name="ln44"> </a>
<a name="ln45">#include &quot;yb/rocksdb/table/block.h&quot;</a>
<a name="ln46">#include &quot;yb/rocksdb/table/block_based_table_internal.h&quot;</a>
<a name="ln47">#include &quot;yb/rocksdb/table/block_builder.h&quot;</a>
<a name="ln48">#include &quot;yb/rocksdb/table/filter_block.h&quot;</a>
<a name="ln49">#include &quot;yb/rocksdb/table/block_based_filter_block.h&quot;</a>
<a name="ln50">#include &quot;yb/rocksdb/table/block_based_table_factory.h&quot;</a>
<a name="ln51">#include &quot;yb/rocksdb/table/fixed_size_filter_block.h&quot;</a>
<a name="ln52">#include &quot;yb/rocksdb/table/full_filter_block.h&quot;</a>
<a name="ln53">#include &quot;yb/rocksdb/table/format.h&quot;</a>
<a name="ln54">#include &quot;yb/rocksdb/table/index_builder.h&quot;</a>
<a name="ln55">#include &quot;yb/rocksdb/table/meta_blocks.h&quot;</a>
<a name="ln56">#include &quot;yb/rocksdb/table/table_builder.h&quot;</a>
<a name="ln57"> </a>
<a name="ln58">#include &quot;yb/rocksdb/util/coding.h&quot;</a>
<a name="ln59">#include &quot;yb/rocksdb/util/compression.h&quot;</a>
<a name="ln60">#include &quot;yb/rocksdb/util/crc32c.h&quot;</a>
<a name="ln61">#include &quot;yb/rocksdb/util/stop_watch.h&quot;</a>
<a name="ln62">#include &quot;yb/rocksdb/util/xxhash.h&quot;</a>
<a name="ln63"> </a>
<a name="ln64">#include &quot;yb/util/mem_tracker.h&quot;</a>
<a name="ln65">#include &quot;yb/util/string_util.h&quot;</a>
<a name="ln66"> </a>
<a name="ln67">#include &quot;yb/gutil/macros.h&quot;</a>
<a name="ln68"> </a>
<a name="ln69">namespace rocksdb {</a>
<a name="ln70"> </a>
<a name="ln71">extern const char kHashIndexPrefixesBlock[];</a>
<a name="ln72">extern const char kHashIndexPrefixesMetadataBlock[];</a>
<a name="ln73"> </a>
<a name="ln74">typedef FilterPolicy::FilterType FilterType;</a>
<a name="ln75"> </a>
<a name="ln76">// Without anonymous namespace here, we fail the warning -Wmissing-prototypes</a>
<a name="ln77">namespace {</a>
<a name="ln78"> </a>
<a name="ln79">FilterType GetFilterType(const BlockBasedTableOptions&amp; table_opt) {</a>
<a name="ln80">  std::shared_ptr&lt;const FilterPolicy&gt; policy(table_opt.filter_policy);</a>
<a name="ln81">  return policy != nullptr ? policy-&gt;GetFilterType() : FilterType::kNoFilter;</a>
<a name="ln82">}</a>
<a name="ln83"> </a>
<a name="ln84">// Create a filter builder based on its type.</a>
<a name="ln85">FilterBlockBuilder* CreateFilterBlockBuilder(const ImmutableCFOptions&amp; opt,</a>
<a name="ln86">    const BlockBasedTableOptions&amp; table_opt, FilterType filter_type) {</a>
<a name="ln87">  switch (filter_type) {</a>
<a name="ln88">    case FilterType::kBlockBasedFilter:</a>
<a name="ln89">      return new BlockBasedFilterBlockBuilder(opt.prefix_extractor, table_opt);</a>
<a name="ln90">    case FilterType::kFixedSizeFilter:</a>
<a name="ln91">      return new FixedSizeFilterBlockBuilder(opt.prefix_extractor, table_opt);</a>
<a name="ln92">    case FilterType::kFullFilter:</a>
<a name="ln93">      return new FullFilterBlockBuilder(opt.prefix_extractor,</a>
<a name="ln94">                                        table_opt.whole_key_filtering,</a>
<a name="ln95">                                        table_opt.filter_policy-&gt;GetFilterBitsBuilder());</a>
<a name="ln96">    case FilterType::kNoFilter:</a>
<a name="ln97">      return nullptr;</a>
<a name="ln98">  }</a>
<a name="ln99">  RLOG(InfoLogLevel::FATAL_LEVEL, opt.info_log, &quot;Corrupted filter_type: %d&quot;, filter_type);</a>
<a name="ln100">  assert(false);</a>
<a name="ln101">  return nullptr;</a>
<a name="ln102">}</a>
<a name="ln103"> </a>
<a name="ln104">bool GoodCompressionRatio(size_t compressed_size, size_t raw_size) {</a>
<a name="ln105">  // Check to see if compressed less than 12.5%</a>
<a name="ln106">  return compressed_size &lt; raw_size - (raw_size / 8u);</a>
<a name="ln107">}</a>
<a name="ln108"> </a>
<a name="ln109">// format_version is the block format as defined in include/rocksdb/table.h</a>
<a name="ln110">Slice CompressBlock(const Slice&amp; raw,</a>
<a name="ln111">                    const CompressionOptions&amp; compression_options,</a>
<a name="ln112">                    CompressionType* type, uint32_t format_version,</a>
<a name="ln113">                    std::string* compressed_output) {</a>
<a name="ln114">  if (*type == kNoCompression) {</a>
<a name="ln115">    return raw;</a>
<a name="ln116">  }</a>
<a name="ln117"> </a>
<a name="ln118">  // Will return compressed block contents if (1) the compression method is</a>
<a name="ln119">  // supported in this platform and (2) the compression rate is &quot;good enough&quot;.</a>
<a name="ln120">  switch (*type) {</a>
<a name="ln121">    case kSnappyCompression:</a>
<a name="ln122">      if (Snappy_Compress(compression_options, raw.cdata(), raw.size(),</a>
<a name="ln123">                          compressed_output) &amp;&amp;</a>
<a name="ln124">          GoodCompressionRatio(compressed_output-&gt;size(), raw.size())) {</a>
<a name="ln125">        return *compressed_output;</a>
<a name="ln126">      }</a>
<a name="ln127">      break;  // fall back to no compression.</a>
<a name="ln128">    case kZlibCompression:</a>
<a name="ln129">      if (Zlib_Compress(</a>
<a name="ln130">              compression_options,</a>
<a name="ln131">              GetCompressFormatForVersion(kZlibCompression, format_version),</a>
<a name="ln132">              raw.cdata(), raw.size(), compressed_output) &amp;&amp;</a>
<a name="ln133">          GoodCompressionRatio(compressed_output-&gt;size(), raw.size())) {</a>
<a name="ln134">        return *compressed_output;</a>
<a name="ln135">      }</a>
<a name="ln136">      break;  // fall back to no compression.</a>
<a name="ln137">    case kBZip2Compression:</a>
<a name="ln138">      if (BZip2_Compress(</a>
<a name="ln139">              compression_options,</a>
<a name="ln140">              GetCompressFormatForVersion(kBZip2Compression, format_version),</a>
<a name="ln141">              raw.cdata(), raw.size(), compressed_output) &amp;&amp;</a>
<a name="ln142">          GoodCompressionRatio(compressed_output-&gt;size(), raw.size())) {</a>
<a name="ln143">        return *compressed_output;</a>
<a name="ln144">      }</a>
<a name="ln145">      break;  // fall back to no compression.</a>
<a name="ln146">    case kLZ4Compression:</a>
<a name="ln147">      if (LZ4_Compress(</a>
<a name="ln148">              compression_options,</a>
<a name="ln149">              GetCompressFormatForVersion(kLZ4Compression, format_version),</a>
<a name="ln150">              raw.cdata(), raw.size(), compressed_output) &amp;&amp;</a>
<a name="ln151">          GoodCompressionRatio(compressed_output-&gt;size(), raw.size())) {</a>
<a name="ln152">        return *compressed_output;</a>
<a name="ln153">      }</a>
<a name="ln154">      break;  // fall back to no compression.</a>
<a name="ln155">    case kLZ4HCCompression:</a>
<a name="ln156">      if (LZ4HC_Compress(</a>
<a name="ln157">              compression_options,</a>
<a name="ln158">              GetCompressFormatForVersion(kLZ4HCCompression, format_version),</a>
<a name="ln159">              raw.cdata(), raw.size(), compressed_output) &amp;&amp;</a>
<a name="ln160">          GoodCompressionRatio(compressed_output-&gt;size(), raw.size())) {</a>
<a name="ln161">        return *compressed_output;</a>
<a name="ln162">      }</a>
<a name="ln163">      break;     // fall back to no compression.</a>
<a name="ln164">    case kZSTDNotFinalCompression:</a>
<a name="ln165">      if (ZSTD_Compress(compression_options, raw.cdata(), raw.size(),</a>
<a name="ln166">                        compressed_output) &amp;&amp;</a>
<a name="ln167">          GoodCompressionRatio(compressed_output-&gt;size(), raw.size())) {</a>
<a name="ln168">        return *compressed_output;</a>
<a name="ln169">      }</a>
<a name="ln170">      break;     // fall back to no compression.</a>
<a name="ln171">    default: {}  // Do not recognize this compression type</a>
<a name="ln172">  }</a>
<a name="ln173"> </a>
<a name="ln174">  // Compression method is not supported, or not good compression ratio, so just</a>
<a name="ln175">  // fall back to uncompressed form.</a>
<a name="ln176">  *type = kNoCompression;</a>
<a name="ln177">  return raw;</a>
<a name="ln178">}</a>
<a name="ln179"> </a>
<a name="ln180">}  // namespace</a>
<a name="ln181"> </a>
<a name="ln182">// kBlockBasedTableMagicNumber was picked by running</a>
<a name="ln183">//    echo rocksdb.table.block_based | sha1sum</a>
<a name="ln184">// and taking the leading 64 bits.</a>
<a name="ln185">// Please note that kBlockBasedTableMagicNumber may also be accessed by other</a>
<a name="ln186">// .cc files</a>
<a name="ln187">// for that reason we declare it extern in the header but to get the space</a>
<a name="ln188">// allocated</a>
<a name="ln189">// it must be not extern in one place.</a>
<a name="ln190">const uint64_t kBlockBasedTableMagicNumber = 0x88e241b785f4cff7ull;</a>
<a name="ln191">// We also support reading and writing legacy block based table format (for</a>
<a name="ln192">// backwards compatibility)</a>
<a name="ln193">const uint64_t kLegacyBlockBasedTableMagicNumber = 0xdb4775248b80fb57ull;</a>
<a name="ln194"> </a>
<a name="ln195">// A collector that collects properties of interest to block-based table.</a>
<a name="ln196">// For now this class looks heavy-weight since we only write one additional</a>
<a name="ln197">// property.</a>
<a name="ln198">// But in the foreseeable future, we will add more and more properties that are</a>
<a name="ln199">// specific to block-based table.</a>
<a name="ln200">class BlockBasedTableBuilder::BlockBasedTablePropertiesCollector</a>
<a name="ln201">    : public IntTblPropCollector {</a>
<a name="ln202"> public:</a>
<a name="ln203">  explicit BlockBasedTablePropertiesCollector(</a>
<a name="ln204">      BlockBasedTableBuilder::Rep* rep, IndexType index_type,</a>
<a name="ln205">      bool whole_key_filtering, bool prefix_filtering)</a>
<a name="ln206">      : rep_(rep),</a>
<a name="ln207">        index_type_(index_type),</a>
<a name="ln208">        whole_key_filtering_(whole_key_filtering),</a>
<a name="ln209">        prefix_filtering_(prefix_filtering) {}</a>
<a name="ln210"> </a>
<a name="ln211">  virtual Status InternalAdd(const Slice&amp; key, const Slice&amp; value,</a>
<a name="ln212">                             uint64_t file_size) override {</a>
<a name="ln213">    // Intentionally left blank. Have no interest in collecting stats for</a>
<a name="ln214">    // individual key/value pairs.</a>
<a name="ln215">    return Status::OK();</a>
<a name="ln216">  }</a>
<a name="ln217"> </a>
<a name="ln218">  Status Finish(UserCollectedProperties* properties) override;</a>
<a name="ln219"> </a>
<a name="ln220">  // The name of the properties collector can be used for debugging purpose.</a>
<a name="ln221">  const char* Name() const override {</a>
<a name="ln222">    return &quot;BlockBasedTablePropertiesCollector&quot;;</a>
<a name="ln223">  }</a>
<a name="ln224"> </a>
<a name="ln225">  UserCollectedProperties GetReadableProperties() const override {</a>
<a name="ln226">    // Intentionally left blank.</a>
<a name="ln227">    return UserCollectedProperties();</a>
<a name="ln228">  }</a>
<a name="ln229"> </a>
<a name="ln230"> private:</a>
<a name="ln231">  BlockBasedTableBuilder::Rep* rep_;</a>
<a name="ln232">  IndexType index_type_;</a>
<a name="ln233">  bool whole_key_filtering_;</a>
<a name="ln234">  bool prefix_filtering_;</a>
<a name="ln235">};</a>
<a name="ln236"> </a>
<a name="ln237">// Originally following data was stored in BlockBasedTableBuilder::Rep and related to a single SST</a>
<a name="ln238">// file. Since SST file is now split into two types of files - data file and metadata file,</a>
<a name="ln239">// all file-related data was moved into dedicated structure for each file.</a>
<a name="ln240">struct BlockBasedTableBuilder::FileWriterWithOffsetAndCachePrefix {</a>
<a name="ln241">  // Pointer to file writer. BlockBasedTableBuilder constructor accepts raw pointers to</a>
<a name="ln242">  // WritableFileWriter and it is responsibility of client code to delete writer instance after</a>
<a name="ln243">  // usage.</a>
<a name="ln244">  WritableFileWriter* writer = nullptr;</a>
<a name="ln245"> </a>
<a name="ln246">  // Current offset.</a>
<a name="ln247">  uint64_t offset = 0;</a>
<a name="ln248"> </a>
<a name="ln249">  // BlockBasedTableBuilder uses compressed block cache passed to BlockBasedTableBuilder constructor</a>
<a name="ln250">  // inside BlockBasedTableOptions instance. If that cache is set in options (off by default)</a>
<a name="ln251">  // all data written to files is also put into compressed block cache to reduce number of file</a>
<a name="ln252">  // read requests later during read operations.</a>
<a name="ln253">  // File blocks are referred in cache by keys, which are composed from following data (see</a>
<a name="ln254">  // BlockBasedTableBuilder::InsertBlockInCache):</a>
<a name="ln255">  // - cache key prefix (unique for each file), generated by GenerateCachePrefix</a>
<a name="ln256">  // - block offset within a file.</a>
<a name="ln257">  block_based_table::CacheKeyPrefixBuffer compressed_cache_key_prefix;</a>
<a name="ln258">};</a>
<a name="ln259"> </a>
<a name="ln260">struct BlockBasedTableBuilder::Rep {</a>
<a name="ln261">  const ImmutableCFOptions ioptions;</a>
<a name="ln262">  const BlockBasedTableOptions table_options;</a>
<a name="ln263">  InternalKeyComparatorPtr internal_comparator;</a>
<a name="ln264">  // When two file writers are passed to BlockBasedTableBuilder during creation - we</a>
<a name="ln265">  // use separate writers for data and metadata. In case BlockBasedTableBuilder was created for</a>
<a name="ln266">  // single file - both data_writer and metadata_writer will actually point to the same structure,</a>
<a name="ln267">  // so data and metadata will both go into one file. As of 2017-03-10 we support both cases.</a>
<a name="ln268">  // Actually it is only allowed to pass nullptr as data_writer at BlockBasedTableBuilder::Rep</a>
<a name="ln269">  // constructor and higher levels in order to support one method signature (with default nullptr</a>
<a name="ln270">  // value) for handling both cases. At the level of BlockBasedTableBuilder implementation both</a>
<a name="ln271">  // writers (inside BlockBasedTableBuilder::Rep) are not null and refer to</a>
<a name="ln272">  // the same file or separate files.</a>
<a name="ln273">  std::shared_ptr&lt;FileWriterWithOffsetAndCachePrefix&gt; metadata_writer;</a>
<a name="ln274">  std::shared_ptr&lt;FileWriterWithOffsetAndCachePrefix&gt; data_writer;</a>
<a name="ln275">  Status status;</a>
<a name="ln276"> </a>
<a name="ln277">  FilterType filter_type;</a>
<a name="ln278">  std::unique_ptr&lt;FilterBlockBuilder&gt; filter_block_builder;</a>
<a name="ln279">  BlockBuilder data_block_builder;</a>
<a name="ln280"> </a>
<a name="ln281">  InternalKeySliceTransform internal_prefix_transform;</a>
<a name="ln282">  const FilterPolicy::KeyTransformer* const filter_key_transformer;</a>
<a name="ln283">  std::unique_ptr&lt;IndexBuilder&gt; data_index_builder;</a>
<a name="ln284">  IndexBuilder::IndexBlocks data_index_blocks;</a>
<a name="ln285">  BlockHandle last_index_block_handle;</a>
<a name="ln286">  std::unique_ptr&lt;IndexBuilder&gt; filter_index_builder;</a>
<a name="ln287"> </a>
<a name="ln288">  std::string last_key;</a>
<a name="ln289">  std::string last_filter_key;</a>
<a name="ln290">  const CompressionType compression_type;</a>
<a name="ln291">  const CompressionOptions compression_opts;</a>
<a name="ln292">  TableProperties props;</a>
<a name="ln293"> </a>
<a name="ln294">  bool closed = false;  // Either Finish() or Abandon() has been called.</a>
<a name="ln295"> </a>
<a name="ln296">  BlockHandle data_pending_handle;    // Handle to add to data index block</a>
<a name="ln297">  BlockHandle filter_pending_handle;  // Handle to add to filter index block</a>
<a name="ln298"> </a>
<a name="ln299">  std::string compressed_output;</a>
<a name="ln300">  std::unique_ptr&lt;FlushBlockPolicy&gt; flush_block_policy;</a>
<a name="ln301"> </a>
<a name="ln302">  std::vector&lt;std::unique_ptr&lt;IntTblPropCollector&gt;&gt; table_properties_collectors;</a>
<a name="ln303"> </a>
<a name="ln304">  yb::MemTrackerPtr mem_tracker;</a>
<a name="ln305"> </a>
<a name="ln306">  Rep(const ImmutableCFOptions&amp; _ioptions,</a>
<a name="ln307">      const BlockBasedTableOptions&amp; table_opt,</a>
<a name="ln308">      const InternalKeyComparatorPtr&amp; icomparator,</a>
<a name="ln309">      const IntTblPropCollectorFactories&amp; int_tbl_prop_collector_factories,</a>
<a name="ln310">      uint32_t column_family_id,</a>
<a name="ln311">      WritableFileWriter* metadata_file,</a>
<a name="ln312">      WritableFileWriter* data_file,</a>
<a name="ln313">      const CompressionType _compression_type,</a>
<a name="ln314">      const CompressionOptions&amp; _compression_opts,</a>
<a name="ln315">      const bool skip_filters);</a>
<a name="ln316"> </a>
<a name="ln317">  bool is_split_sst() const { return data_writer != metadata_writer; }</a>
<a name="ln318">};</a>
<a name="ln319"> </a>
<a name="ln320">Status BlockBasedTableBuilder::BlockBasedTablePropertiesCollector::Finish(</a>
<a name="ln321">    UserCollectedProperties* properties) {</a>
<a name="ln322">  std::string val;</a>
<a name="ln323">  PutFixed32(&amp;val, static_cast&lt;uint32_t&gt;(index_type_));</a>
<a name="ln324">  properties-&gt;emplace(BlockBasedTablePropertyNames::kIndexType, val);</a>
<a name="ln325">  properties-&gt;emplace(</a>
<a name="ln326">      BlockBasedTablePropertyNames::kWholeKeyFiltering,</a>
<a name="ln327">      ToBlockBasedTablePropertyValue(whole_key_filtering_));</a>
<a name="ln328">  properties-&gt;emplace(</a>
<a name="ln329">      BlockBasedTablePropertyNames::kPrefixFiltering,</a>
<a name="ln330">      ToBlockBasedTablePropertyValue(prefix_filtering_));</a>
<a name="ln331">  val.clear();</a>
<a name="ln332">  PutFixed32(&amp;val, rep_-&gt;data_index_builder-&gt;NumLevels());</a>
<a name="ln333">  properties-&gt;emplace(BlockBasedTablePropertyNames::kNumIndexLevels, val);</a>
<a name="ln334">  return Status::OK();</a>
<a name="ln335">}</a>
<a name="ln336"> </a>
<a name="ln337">BlockBasedTableBuilder::Rep::Rep(</a>
<a name="ln338">    const ImmutableCFOptions&amp; _ioptions,</a>
<a name="ln339">    const BlockBasedTableOptions&amp; table_opt,</a>
<a name="ln340">    const InternalKeyComparatorPtr&amp; icomparator,</a>
<a name="ln341">    const IntTblPropCollectorFactories&amp; int_tbl_prop_collector_factories,</a>
<a name="ln342">    uint32_t column_family_id,</a>
<a name="ln343">    WritableFileWriter* metadata_file,</a>
<a name="ln344">    WritableFileWriter* data_file,</a>
<a name="ln345">    const CompressionType _compression_type,</a>
<a name="ln346">    const CompressionOptions&amp; _compression_opts,</a>
<a name="ln347">    const bool skip_filters)</a>
<a name="ln348">    : ioptions(_ioptions),</a>
<a name="ln349">      table_options(table_opt),</a>
<a name="ln350">      internal_comparator(icomparator),</a>
<a name="ln351">      filter_type(GetFilterType(table_options)),</a>
<a name="ln352">      filter_block_builder(skip_filters ? nullptr : CreateFilterBlockBuilder(</a>
<a name="ln353">          _ioptions, table_options, filter_type)),</a>
<a name="ln354">      data_block_builder(table_options.block_restart_interval,</a>
<a name="ln355">                 table_options.use_delta_encoding),</a>
<a name="ln356">      internal_prefix_transform(_ioptions.prefix_extractor),</a>
<a name="ln357">      filter_key_transformer(table_opt.filter_policy ?</a>
<a name="ln358">          table_opt.filter_policy-&gt;GetKeyTransformer() : nullptr),</a>
<a name="ln359">      data_index_builder(</a>
<a name="ln360">          IndexBuilder::CreateIndexBuilder(</a>
<a name="ln361">              table_options.index_type, internal_comparator.get(), &amp;internal_prefix_transform,</a>
<a name="ln362">              table_options)),</a>
<a name="ln363">      filter_index_builder(</a>
<a name="ln364">          // Prefix_extractor is not used by binary search index which we use for bloom filter</a>
<a name="ln365">          // blocks indexing.</a>
<a name="ln366">          IndexBuilder::CreateIndexBuilder(</a>
<a name="ln367">              IndexType::kBinarySearch, BytewiseComparator(),</a>
<a name="ln368">              nullptr /* prefix_extractor */, table_options)),</a>
<a name="ln369">      compression_type(_compression_type),</a>
<a name="ln370">      compression_opts(_compression_opts),</a>
<a name="ln371">      flush_block_policy(</a>
<a name="ln372">          table_options.flush_block_policy_factory-&gt;NewFlushBlockPolicy(</a>
<a name="ln373">              table_options, data_block_builder)) {</a>
<a name="ln374">  if (_ioptions.mem_tracker) {</a>
<a name="ln375">    mem_tracker = yb::MemTracker::FindOrCreateTracker(</a>
<a name="ln376">        &quot;BlockBasedTableBuilder&quot;, _ioptions.mem_tracker);</a>
<a name="ln377">  }</a>
<a name="ln378"> </a>
<a name="ln379">  metadata_writer = std::make_shared&lt;FileWriterWithOffsetAndCachePrefix&gt;();</a>
<a name="ln380">  metadata_writer-&gt;writer = metadata_file;</a>
<a name="ln381">  if (data_file != nullptr) {</a>
<a name="ln382">    data_writer = std::make_shared&lt;FileWriterWithOffsetAndCachePrefix&gt;();</a>
<a name="ln383">    data_writer-&gt;writer = data_file;</a>
<a name="ln384">  } else {</a>
<a name="ln385">    data_writer = metadata_writer;</a>
<a name="ln386">  }</a>
<a name="ln387">  for (auto&amp; collector_factories : int_tbl_prop_collector_factories) {</a>
<a name="ln388">    table_properties_collectors.emplace_back(</a>
<a name="ln389">        collector_factories-&gt;CreateIntTblPropCollector(column_family_id));</a>
<a name="ln390">  }</a>
<a name="ln391">  table_properties_collectors.emplace_back(</a>
<a name="ln392">      new BlockBasedTablePropertiesCollector(</a>
<a name="ln393">          this, table_options.index_type, table_options.whole_key_filtering,</a>
<a name="ln394">          _ioptions.prefix_extractor != nullptr));</a>
<a name="ln395">}</a>
<a name="ln396"> </a>
<a name="ln397">BlockBasedTableBuilder::BlockBasedTableBuilder(</a>
<a name="ln398">    const ImmutableCFOptions&amp; ioptions,</a>
<a name="ln399">    const BlockBasedTableOptions&amp; table_options,</a>
<a name="ln400">    const InternalKeyComparatorPtr&amp; internal_comparator,</a>
<a name="ln401">    const IntTblPropCollectorFactories&amp; int_tbl_prop_collector_factories,</a>
<a name="ln402">    uint32_t column_family_id,</a>
<a name="ln403">    WritableFileWriter* metadata_file,</a>
<a name="ln404">    WritableFileWriter* data_file,</a>
<a name="ln405">    const CompressionType compression_type,</a>
<a name="ln406">    const CompressionOptions&amp; compression_opts,</a>
<a name="ln407">    const bool skip_filters) {</a>
<a name="ln408">  BlockBasedTableOptions sanitized_table_options(table_options);</a>
<a name="ln409">  if (sanitized_table_options.format_version == 0 &amp;&amp;</a>
<a name="ln410">      sanitized_table_options.checksum != kCRC32c) {</a>
<a name="ln411">    RLOG(InfoLogLevel::WARN_LEVEL, ioptions.info_log,</a>
<a name="ln412">        &quot;Silently converting format_version to 1 because checksum is &quot;</a>
<a name="ln413">        &quot;non-default&quot;);</a>
<a name="ln414">    // silently convert format_version to 1 to keep consistent with current</a>
<a name="ln415">    // behavior</a>
<a name="ln416">    sanitized_table_options.format_version = 1;</a>
<a name="ln417">  }</a>
<a name="ln418"> </a>
<a name="ln419">  rep_ = new Rep(ioptions, sanitized_table_options, internal_comparator,</a>
<a name="ln420">                 int_tbl_prop_collector_factories, column_family_id, metadata_file, data_file,</a>
<a name="ln421">                 compression_type, compression_opts, skip_filters);</a>
<a name="ln422"> </a>
<a name="ln423">  if (rep_-&gt;filter_block_builder != nullptr) {</a>
<a name="ln424">    rep_-&gt;filter_block_builder-&gt;StartBlock(0);</a>
<a name="ln425">  }</a>
<a name="ln426">  if (table_options.block_cache_compressed.get() != nullptr) {</a>
<a name="ln427">    GenerateCachePrefix(</a>
<a name="ln428">        table_options.block_cache_compressed.get(), metadata_file-&gt;writable_file(),</a>
<a name="ln429">        &amp;rep_-&gt;metadata_writer-&gt;compressed_cache_key_prefix);</a>
<a name="ln430">    if (rep_-&gt;is_split_sst()) {</a>
<a name="ln431">      GenerateCachePrefix(</a>
<a name="ln432">          table_options.block_cache_compressed.get(), data_file-&gt;writable_file(),</a>
<a name="ln433">          &amp;rep_-&gt;metadata_writer-&gt;compressed_cache_key_prefix);</a>
<a name="ln434">    }</a>
<a name="ln435">  }</a>
<a name="ln436">}</a>
<a name="ln437"> </a>
<a name="ln438">BlockBasedTableBuilder::~BlockBasedTableBuilder() {</a>
<a name="ln439">  assert(rep_-&gt;closed);  // Catch errors where caller forgot to call Finish()</a>
<a name="ln440">  delete rep_;</a>
<a name="ln441">}</a>
<a name="ln442"> </a>
<a name="ln443">void BlockBasedTableBuilder::Add(const Slice&amp; key, const Slice&amp; value) {</a>
<a name="ln444">  Rep* const r = rep_;</a>
<a name="ln445">  DCHECK(!r-&gt;closed);</a>
<a name="ln446">  if (!ok()) return;</a>
<a name="ln447">  if (r-&gt;props.num_entries &gt; 0) {</a>
<a name="ln448">    DCHECK_GT(r-&gt;internal_comparator-&gt;Compare(key, Slice(r-&gt;last_key)), 0);</a>
<a name="ln449">  }</a>
<a name="ln450"> </a>
<a name="ln451">  const auto should_flush_data = r-&gt;flush_block_policy-&gt;Update(key, value);</a>
<a name="ln452">  if (should_flush_data) {</a>
<a name="ln453">    DCHECK(!r-&gt;data_block_builder.empty());</a>
<a name="ln454">    FlushDataBlock(key);</a>
<a name="ln455">  }</a>
<a name="ln456"> </a>
<a name="ln457">  if (r-&gt;filter_block_builder != nullptr) {</a>
<a name="ln458">    const Slice user_key = ExtractUserKey(key);</a>
<a name="ln459">    const Slice filter_key = r-&gt;filter_key_transformer ?</a>
<a name="ln460">        r-&gt;filter_key_transformer-&gt;Transform(user_key) : user_key;</a>
<a name="ln461">    if (r-&gt;props.num_entries == 0 ||</a>
<a name="ln462">        BytewiseComparator()-&gt;Compare(r-&gt;last_filter_key, filter_key) != 0) {</a>
<a name="ln463">      // No need to insert duplicate keys into Bloom filter.</a>
<a name="ln464">      if (r-&gt;filter_block_builder-&gt;ShouldFlush()) {</a>
<a name="ln465">        FlushFilterBlock(key);</a>
<a name="ln466">      }</a>
<a name="ln467">      r-&gt;filter_block_builder-&gt;Add(filter_key);</a>
<a name="ln468">      r-&gt;last_filter_key.assign(filter_key.cdata(), filter_key.size());</a>
<a name="ln469">    }</a>
<a name="ln470">  }</a>
<a name="ln471"> </a>
<a name="ln472">  r-&gt;last_key.assign(key.cdata(), key.size());</a>
<a name="ln473">  r-&gt;data_block_builder.Add(key, value);</a>
<a name="ln474">  r-&gt;props.num_entries++;</a>
<a name="ln475">  r-&gt;props.raw_key_size += key.size();</a>
<a name="ln476">  r-&gt;props.raw_value_size += value.size();</a>
<a name="ln477"> </a>
<a name="ln478">  r-&gt;data_index_builder-&gt;OnKeyAdded(key);</a>
<a name="ln479"> </a>
<a name="ln480">  NotifyCollectTableCollectorsOnAdd(key, value, r-&gt;data_writer-&gt;offset,</a>
<a name="ln481">      r-&gt;table_properties_collectors,</a>
<a name="ln482">      r-&gt;ioptions.info_log);</a>
<a name="ln483">}</a>
<a name="ln484"> </a>
<a name="ln485">void BlockBasedTableBuilder::FlushDataBlock(const Slice&amp; next_block_first_key) {</a>
<a name="ln486">  Rep* const r = rep_;</a>
<a name="ln487">  assert(!r-&gt;closed);</a>
<a name="ln488">  if (!ok()) return;</a>
<a name="ln489">  size_t data_block_size = 0;</a>
<a name="ln490"> </a>
<a name="ln491">  if (!r-&gt;data_block_builder.empty()) {</a>
<a name="ln492">    data_block_size = WriteBlock(&amp;r-&gt;data_block_builder, &amp;r-&gt;data_pending_handle,</a>
<a name="ln493">        r-&gt;data_writer.get());</a>
<a name="ln494">  }</a>
<a name="ln495">  if (!ok()) return;</a>
<a name="ln496"> </a>
<a name="ln497">  if (!r-&gt;table_options.skip_table_builder_flush) {</a>
<a name="ln498">    r-&gt;status = r-&gt;data_writer-&gt;writer-&gt;Flush();</a>
<a name="ln499">  }</a>
<a name="ln500">  if (!ok()) return;</a>
<a name="ln501"> </a>
<a name="ln502">  if (r-&gt;filter_block_builder != nullptr &amp;&amp; r-&gt;filter_type == FilterType::kBlockBasedFilter) {</a>
<a name="ln503">    // For FilterType::kBlockBasedFilter separate block of bloom filter is written per data block.</a>
<a name="ln504">    r-&gt;filter_block_builder-&gt;StartBlock(r-&gt;data_writer-&gt;offset);</a>
<a name="ln505">  }</a>
<a name="ln506"> </a>
<a name="ln507">  r-&gt;props.data_size += data_block_size;</a>
<a name="ln508">  ++r-&gt;props.num_data_blocks;</a>
<a name="ln509">  // Add item to index block.</a>
<a name="ln510">  // We do not emit the index entry for a block until we have seen the</a>
<a name="ln511">  // first key for the next data block.  This allows us to use shorter</a>
<a name="ln512">  // keys in the index block.  For example, consider a block boundary</a>
<a name="ln513">  // between the keys &quot;the quick brown fox&quot; and &quot;the who&quot;.  We can use</a>
<a name="ln514">  // &quot;the r&quot; as the key for the index block entry since it is &gt;= all</a>
<a name="ln515">  // entries in the first block and &lt; all entries in subsequent</a>
<a name="ln516">  // blocks.</a>
<a name="ln517">  r-&gt;data_index_builder-&gt;AddIndexEntry(&amp;r-&gt;last_key,</a>
<a name="ln518">      next_block_first_key.empty() ? nullptr : &amp;next_block_first_key,</a>
<a name="ln519">      r-&gt;data_pending_handle);</a>
<a name="ln520">  while (r-&gt;data_index_builder-&gt;ShouldFlush()) {</a>
<a name="ln521">    auto result = r-&gt;data_index_builder-&gt;FlushNextBlock(</a>
<a name="ln522">        &amp;r-&gt;data_index_blocks, r-&gt;last_index_block_handle);</a>
<a name="ln523">    if (!result.ok()) {</a>
<a name="ln524">      r-&gt;status = result.status();</a>
<a name="ln525">      return;</a>
<a name="ln526">    }</a>
<a name="ln527">    DCHECK(result.get());</a>
<a name="ln528">    WriteBlock(</a>
<a name="ln529">        r-&gt;data_index_blocks.index_block_contents, &amp;r-&gt;last_index_block_handle,</a>
<a name="ln530">        r-&gt;metadata_writer.get());</a>
<a name="ln531">    if (!ok()) return;</a>
<a name="ln532">    ++r-&gt;props.num_data_index_blocks;</a>
<a name="ln533">  }</a>
<a name="ln534">}</a>
<a name="ln535"> </a>
<a name="ln536">void BlockBasedTableBuilder::FlushFilterBlock(const Slice&amp; next_block_first_key) {</a>
<a name="ln537">  Rep* const r = rep_;</a>
<a name="ln538">  assert(!r-&gt;closed);</a>
<a name="ln539">  assert(r-&gt;filter_block_builder != nullptr);</a>
<a name="ln540">  if (!ok()) return;</a>
<a name="ln541"> </a>
<a name="ln542">  const size_t filter_block_size = WriteRawBlock(r-&gt;filter_block_builder-&gt;Finish(), kNoCompression,</a>
<a name="ln543">      &amp;r-&gt;filter_pending_handle, r-&gt;metadata_writer.get());</a>
<a name="ln544">  if (!ok()) return;</a>
<a name="ln545"> </a>
<a name="ln546">  if (!r-&gt;table_options.skip_table_builder_flush) {</a>
<a name="ln547">    r-&gt;status = r-&gt;metadata_writer-&gt;writer-&gt;Flush();</a>
<a name="ln548">  }</a>
<a name="ln549">  if (!ok()) return;</a>
<a name="ln550"> </a>
<a name="ln551">  r-&gt;props.filter_size += filter_block_size;</a>
<a name="ln552">  ++r-&gt;props.num_filter_blocks;</a>
<a name="ln553"> </a>
<a name="ln554">  const bool is_last_flush = next_block_first_key.empty();</a>
<a name="ln555">  if (!is_last_flush) {</a>
<a name="ln556">    r-&gt;filter_block_builder-&gt;StartBlock(0);</a>
<a name="ln557">  }</a>
<a name="ln558"> </a>
<a name="ln559">  // See explanation in BlockBasedTableBuilder::FlushDataBlock.</a>
<a name="ln560">  r-&gt;filter_index_builder-&gt;AddIndexEntry(&amp;r-&gt;last_filter_key,</a>
<a name="ln561">      is_last_flush ? nullptr : &amp;next_block_first_key,  r-&gt;filter_pending_handle);</a>
<a name="ln562">}</a>
<a name="ln563"> </a>
<a name="ln564">size_t BlockBasedTableBuilder::WriteBlock(BlockBuilder* block,</a>
<a name="ln565">                                          BlockHandle* handle,</a>
<a name="ln566">                                          FileWriterWithOffsetAndCachePrefix* writer_info) {</a>
<a name="ln567">  size_t block_size = WriteBlock(block-&gt;Finish(), handle, writer_info);</a>
<a name="ln568">  block-&gt;Reset();</a>
<a name="ln569">  return block_size;</a>
<a name="ln570">}</a>
<a name="ln571"> </a>
<a name="ln572">size_t BlockBasedTableBuilder::WriteBlock(const Slice&amp; raw_block_contents,</a>
<a name="ln573">                                          BlockHandle* handle,</a>
<a name="ln574">                                          FileWriterWithOffsetAndCachePrefix* writer_info) {</a>
<a name="ln575">  // File format contains a sequence of blocks where each block has:</a>
<a name="ln576">  //    block_data: uint8[n]</a>
<a name="ln577">  //    type: uint8</a>
<a name="ln578">  //    crc: uint32</a>
<a name="ln579">  assert(ok());</a>
<a name="ln580">  Rep* r = rep_;</a>
<a name="ln581"> </a>
<a name="ln582">  auto type = r-&gt;compression_type;</a>
<a name="ln583">  Slice block_contents;</a>
<a name="ln584">  if (raw_block_contents.size() &lt; kCompressionSizeLimit) {</a>
<a name="ln585">    block_contents =</a>
<a name="ln586">        CompressBlock(raw_block_contents, r-&gt;compression_opts, &amp;type,</a>
<a name="ln587">                      r-&gt;table_options.format_version, &amp;r-&gt;compressed_output);</a>
<a name="ln588">  } else {</a>
<a name="ln589">    RecordTick(r-&gt;ioptions.statistics, NUMBER_BLOCK_NOT_COMPRESSED);</a>
<a name="ln590">    type = kNoCompression;</a>
<a name="ln591">    block_contents = raw_block_contents;</a>
<a name="ln592">  }</a>
<a name="ln593">  size_t block_size = WriteRawBlock(block_contents, type, handle, writer_info);</a>
<a name="ln594">  r-&gt;compressed_output.clear();</a>
<a name="ln595">  return block_size;</a>
<a name="ln596">}</a>
<a name="ln597"> </a>
<a name="ln598">size_t BlockBasedTableBuilder::WriteRawBlock(const Slice&amp; block_contents,</a>
<a name="ln599">                                             CompressionType type,</a>
<a name="ln600">                                             BlockHandle* handle,</a>
<a name="ln601">                                             FileWriterWithOffsetAndCachePrefix* writer_info) {</a>
<a name="ln602">  Rep* r = rep_;</a>
<a name="ln603">  StopWatch sw(r-&gt;ioptions.env, r-&gt;ioptions.statistics, WRITE_RAW_BLOCK_MICROS);</a>
<a name="ln604">  const auto start_offset = writer_info-&gt;offset;</a>
<a name="ln605">  handle-&gt;set_offset(writer_info-&gt;offset);</a>
<a name="ln606">  handle-&gt;set_size(block_contents.size());</a>
<a name="ln607">  r-&gt;status = writer_info-&gt;writer-&gt;Append(block_contents);</a>
<a name="ln608">  if (r-&gt;status.ok()) {</a>
<a name="ln609">    char trailer[kBlockTrailerSize];</a>
<a name="ln610">    trailer[0] = type;</a>
<a name="ln611">    char* trailer_without_type = trailer + 1;</a>
<a name="ln612">    switch (r-&gt;table_options.checksum) {</a>
<a name="ln613">      case kNoChecksum:</a>
<a name="ln614">        // we don't support no checksum yet</a>
<a name="ln615">        assert(false);</a>
<a name="ln616">        // intentional fallthrough in release binary</a>
<a name="ln617">        // We add a fallthrough annotation in release mode only -- otherwise we get a compile error</a>
<a name="ln618">        // in debug mode (&quot;fallthrough annotation in unreachable code&quot;).</a>
<a name="ln619">#ifdef NDEBUG</a>
<a name="ln620">        FALLTHROUGH_INTENDED;</a>
<a name="ln621">#endif</a>
<a name="ln622">      case kCRC32c: {</a>
<a name="ln623">        auto crc = crc32c::Value(block_contents.data(), block_contents.size());</a>
<a name="ln624">        crc = crc32c::Extend(crc, trailer, 1);  // Extend to cover block type</a>
<a name="ln625">        EncodeFixed32(trailer_without_type, crc32c::Mask(crc));</a>
<a name="ln626">        break;</a>
<a name="ln627">      }</a>
<a name="ln628">      case kxxHash: {</a>
<a name="ln629">        void* xxh = XXH32_init(0);</a>
<a name="ln630">        XXH32_update(xxh, block_contents.data(),</a>
<a name="ln631">                     static_cast&lt;uint32_t&gt;(block_contents.size()));</a>
<a name="ln632">        XXH32_update(xxh, trailer, 1);  // Extend  to cover block type</a>
<a name="ln633">        EncodeFixed32(trailer_without_type, XXH32_digest(xxh));</a>
<a name="ln634">        break;</a>
<a name="ln635">      }</a>
<a name="ln636">    }</a>
<a name="ln637"> </a>
<a name="ln638">    r-&gt;status = writer_info-&gt;writer-&gt;Append(Slice(trailer, kBlockTrailerSize));</a>
<a name="ln639">    if (r-&gt;status.ok()) {</a>
<a name="ln640">      r-&gt;status = InsertBlockInCache(block_contents, type, handle, writer_info);</a>
<a name="ln641">    }</a>
<a name="ln642">    if (r-&gt;status.ok()) {</a>
<a name="ln643">      writer_info-&gt;offset += block_contents.size() + kBlockTrailerSize;</a>
<a name="ln644">    }</a>
<a name="ln645">  }</a>
<a name="ln646">  return writer_info-&gt;offset - start_offset;</a>
<a name="ln647">}</a>
<a name="ln648"> </a>
<a name="ln649">Status BlockBasedTableBuilder::status() const {</a>
<a name="ln650">  return rep_-&gt;status;</a>
<a name="ln651">}</a>
<a name="ln652"> </a>
<a name="ln653">static void DeleteCachedBlock(const Slice&amp; key, void* value) {</a>
<a name="ln654">  Block* block = reinterpret_cast&lt;Block*&gt;(value);</a>
<a name="ln655">  delete block;</a>
<a name="ln656">}</a>
<a name="ln657"> </a>
<a name="ln658">//</a>
<a name="ln659">// Make a copy of the block contents and insert into compressed block cache</a>
<a name="ln660">//</a>
<a name="ln661">Status BlockBasedTableBuilder::InsertBlockInCache(const Slice&amp; block_contents,</a>
<a name="ln662">                                                  const CompressionType type,</a>
<a name="ln663">                                                  const BlockHandle* handle,</a>
<a name="ln664">                                                  FileWriterWithOffsetAndCachePrefix* writer_info) {</a>
<a name="ln665">  Rep* r = rep_;</a>
<a name="ln666">  Cache* block_cache_compressed = r-&gt;table_options.block_cache_compressed.get();</a>
<a name="ln667"> </a>
<a name="ln668">  if (type != kNoCompression &amp;&amp; block_cache_compressed != nullptr) {</a>
<a name="ln669"> </a>
<a name="ln670">    size_t size = block_contents.size();</a>
<a name="ln671"> </a>
<a name="ln672">    std::unique_ptr&lt;char[]&gt; ubuf(new char[size + 1]);</a>
<a name="ln673">    memcpy(ubuf.get(), block_contents.data(), size);</a>
<a name="ln674">    ubuf[size] = type;</a>
<a name="ln675"> </a>
<a name="ln676">    BlockContents results(std::move(ubuf), size, true, type, r-&gt;mem_tracker);</a>
<a name="ln677"> </a>
<a name="ln678">    Block* block = new Block(std::move(results));</a>
<a name="ln679"> </a>
<a name="ln680">    // make cache key by appending the file offset to the cache prefix id</a>
<a name="ln681">    char* end = EncodeVarint64(</a>
<a name="ln682">                  writer_info-&gt;compressed_cache_key_prefix.data +</a>
<a name="ln683">                  writer_info-&gt;compressed_cache_key_prefix.size,</a>
<a name="ln684">                  handle-&gt;offset());</a>
<a name="ln685">    Slice key(writer_info-&gt;compressed_cache_key_prefix.data,</a>
<a name="ln686">        static_cast&lt;size_t&gt; (end - writer_info-&gt;compressed_cache_key_prefix.data));</a>
<a name="ln687"> </a>
<a name="ln688">    // Insert into compressed block cache.</a>
<a name="ln689">    RETURN_NOT_OK(block_cache_compressed-&gt;Insert(</a>
<a name="ln690">        key, kDefaultQueryId, block, block-&gt;usable_size(), &amp;DeleteCachedBlock));</a>
<a name="ln691"> </a>
<a name="ln692">    // Invalidate OS cache.</a>
<a name="ln693">    auto status = writer_info-&gt;writer-&gt;InvalidateCache(</a>
<a name="ln694">        static_cast&lt;size_t&gt;(writer_info-&gt;offset), size);</a>
<a name="ln695">    if (!status.ok() &amp;&amp; !status.IsNotSupported()) {</a>
<a name="ln696">      return status;</a>
<a name="ln697">    }</a>
<a name="ln698">  }</a>
<a name="ln699">  return Status::OK();</a>
<a name="ln700">}</a>
<a name="ln701"> </a>
<a name="ln702">Status BlockBasedTableBuilder::Finish() {</a>
<a name="ln703">  Rep* r = rep_;</a>
<a name="ln704">  Slice end_slice;</a>
<a name="ln705">  if (!r-&gt;data_block_builder.empty()) {</a>
<a name="ln706">    FlushDataBlock(end_slice);  // no more data block</a>
<a name="ln707">  }</a>
<a name="ln708">  if (r-&gt;filter_block_builder != nullptr) {</a>
<a name="ln709">    FlushFilterBlock(end_slice);  // no more filter block</a>
<a name="ln710">  }</a>
<a name="ln711">  assert(!r-&gt;closed);</a>
<a name="ln712">  r-&gt;closed = true;</a>
<a name="ln713"> </a>
<a name="ln714">  auto index_finish_result = r-&gt;data_index_builder-&gt;FlushNextBlock(</a>
<a name="ln715">      &amp;r-&gt;data_index_blocks, r-&gt;last_index_block_handle);</a>
<a name="ln716">  RETURN_NOT_OK(index_finish_result);</a>
<a name="ln717">  if (index_finish_result.get()) {</a>
<a name="ln718">    ++r-&gt;props.num_data_index_blocks;</a>
<a name="ln719">  }</a>
<a name="ln720"> </a>
<a name="ln721">  // Write meta blocks and metaindex block with the following order.</a>
<a name="ln722">  //    1. [meta block: filter]</a>
<a name="ln723">  //    2. [other meta blocks]</a>
<a name="ln724">  //    3. [meta block: properties]</a>
<a name="ln725">  //    4. [metaindex block]</a>
<a name="ln726">  // write meta blocks</a>
<a name="ln727">  MetaIndexBuilder meta_index_builder;</a>
<a name="ln728">  for (const auto&amp; item : r-&gt;data_index_blocks.meta_blocks) {</a>
<a name="ln729">    BlockHandle block_handle;</a>
<a name="ln730">    WriteBlock(item.second, &amp;block_handle, r-&gt;metadata_writer.get());</a>
<a name="ln731">    meta_index_builder.Add(item.first, block_handle);</a>
<a name="ln732">  }</a>
<a name="ln733"> </a>
<a name="ln734">  if (ok()) {</a>
<a name="ln735">    if (r-&gt;filter_block_builder != nullptr) {</a>
<a name="ln736">      // Add mapping from &quot;&lt;filter_block_prefix&gt;.Name&quot; to location of either filter block or</a>
<a name="ln737">      // filter index (for fixed-size bloom filter). We only need filter index for fixed-size bloom</a>
<a name="ln738">      // filter, which is stored as separate blocks in SST file. Filters of other types are stored</a>
<a name="ln739">      // as single block in SST file, so we just need an offset to that block instead of index.</a>
<a name="ln740">      std::string key;</a>
<a name="ln741">      switch (r-&gt;filter_type) {</a>
<a name="ln742">        case FilterType::kFullFilter:</a>
<a name="ln743">          key = block_based_table::kFullFilterBlockPrefix;</a>
<a name="ln744">          break;</a>
<a name="ln745">        case FilterType::kBlockBasedFilter:</a>
<a name="ln746">          key = block_based_table::kFilterBlockPrefix;</a>
<a name="ln747">          break;</a>
<a name="ln748">        case FilterType::kFixedSizeFilter:</a>
<a name="ln749">          key = block_based_table::kFixedSizeFilterBlockPrefix;</a>
<a name="ln750">          break;</a>
<a name="ln751">        case FilterType::kNoFilter:</a>
<a name="ln752">          RLOG(InfoLogLevel::FATAL_LEVEL, r-&gt;ioptions.info_log,</a>
<a name="ln753">              &quot;r-&gt;filter_block_builder should be null for FilterType::kNoFilter&quot;);</a>
<a name="ln754">          assert(false);</a>
<a name="ln755">      }</a>
<a name="ln756">      key.append(r-&gt;table_options.filter_policy-&gt;Name());</a>
<a name="ln757">      if (r-&gt;filter_type == FilterType::kFixedSizeFilter) {</a>
<a name="ln758">        // Flush the fixed-size bloom filter index and add its offset under the corresponding</a>
<a name="ln759">        // key to meta index.</a>
<a name="ln760">        IndexBuilder::IndexBlocks filter_index_blocks;</a>
<a name="ln761">        RETURN_NOT_OK(r-&gt;filter_index_builder-&gt;Finish(&amp;filter_index_blocks));</a>
<a name="ln762">        BlockHandle filter_index_block_handle;</a>
<a name="ln763">        WriteBlock(filter_index_blocks.index_block_contents, &amp;filter_index_block_handle,</a>
<a name="ln764">            r-&gt;metadata_writer.get());</a>
<a name="ln765">        meta_index_builder.Add(key, filter_index_block_handle);</a>
<a name="ln766">        r-&gt;props.filter_index_size = r-&gt;filter_index_builder-&gt;EstimatedSize() + kBlockTrailerSize;</a>
<a name="ln767">      } else {</a>
<a name="ln768">        meta_index_builder.Add(key, r-&gt;filter_pending_handle);</a>
<a name="ln769">      }</a>
<a name="ln770">    }</a>
<a name="ln771"> </a>
<a name="ln772">    // Write properties block.</a>
<a name="ln773">    {</a>
<a name="ln774">      PropertyBlockBuilder property_block_builder;</a>
<a name="ln775">      r-&gt;props.filter_policy_name = r-&gt;table_options.filter_policy != nullptr ?</a>
<a name="ln776">          r-&gt;table_options.filter_policy-&gt;Name() : &quot;&quot;;</a>
<a name="ln777">      r-&gt;props.data_index_size =</a>
<a name="ln778">          r-&gt;data_index_builder-&gt;EstimatedSize() + kBlockTrailerSize;</a>
<a name="ln779"> </a>
<a name="ln780">      // Add basic properties</a>
<a name="ln781">      property_block_builder.AddTableProperty(r-&gt;props);</a>
<a name="ln782"> </a>
<a name="ln783">      // Add use collected properties</a>
<a name="ln784">      NotifyCollectTableCollectorsOnFinish(r-&gt;table_properties_collectors,</a>
<a name="ln785">          r-&gt;ioptions.info_log,</a>
<a name="ln786">          &amp;property_block_builder);</a>
<a name="ln787"> </a>
<a name="ln788">      BlockHandle properties_block_handle;</a>
<a name="ln789">      WriteRawBlock(</a>
<a name="ln790">          property_block_builder.Finish(),</a>
<a name="ln791">          kNoCompression,</a>
<a name="ln792">          &amp;properties_block_handle,</a>
<a name="ln793">          r-&gt;metadata_writer.get()</a>
<a name="ln794">      );</a>
<a name="ln795"> </a>
<a name="ln796">      meta_index_builder.Add(kPropertiesBlock, properties_block_handle);</a>
<a name="ln797">    }  // end of properties block writing</a>
<a name="ln798">  }    // meta blocks</a>
<a name="ln799"> </a>
<a name="ln800">  BlockHandle meta_index_block_handle;</a>
<a name="ln801">  // Write meta index and index block.</a>
<a name="ln802">  if (ok()) {</a>
<a name="ln803">    // Flush the meta index block.</a>
<a name="ln804">    WriteRawBlock(</a>
<a name="ln805">        meta_index_builder.Finish(), kNoCompression, &amp;meta_index_block_handle,</a>
<a name="ln806">        r-&gt;metadata_writer.get());</a>
<a name="ln807">    // Flush index block if not already flushed.</a>
<a name="ln808">    if (index_finish_result.get()) {</a>
<a name="ln809">      WriteBlock(</a>
<a name="ln810">          r-&gt;data_index_blocks.index_block_contents, &amp;r-&gt;last_index_block_handle,</a>
<a name="ln811">          r-&gt;metadata_writer.get());</a>
<a name="ln812">    }</a>
<a name="ln813">  }</a>
<a name="ln814"> </a>
<a name="ln815">  // Write footer</a>
<a name="ln816">  if (ok()) {</a>
<a name="ln817">    // No need to write out new footer if we're using default checksum.</a>
<a name="ln818">    // We're writing legacy magic number because we want old versions of RocksDB</a>
<a name="ln819">    // be able to read files generated with new release (just in case if</a>
<a name="ln820">    // somebody wants to roll back after an upgrade)</a>
<a name="ln821">    // TODO(icanadi) at some point in the future, when we're absolutely sure</a>
<a name="ln822">    // nobody will roll back to RocksDB 2.x versions, retire the legacy magic</a>
<a name="ln823">    // number and always write new table files with new magic number</a>
<a name="ln824">    bool legacy = (r-&gt;table_options.format_version == 0);</a>
<a name="ln825">    // this is guaranteed by BlockBasedTableBuilder's constructor</a>
<a name="ln826">    assert(r-&gt;table_options.checksum == kCRC32c ||</a>
<a name="ln827">        r-&gt;table_options.format_version != 0);</a>
<a name="ln828">    Footer footer(legacy ? kLegacyBlockBasedTableMagicNumber</a>
<a name="ln829">            : kBlockBasedTableMagicNumber,</a>
<a name="ln830">        r-&gt;table_options.format_version);</a>
<a name="ln831">    footer.set_metaindex_handle(meta_index_block_handle);</a>
<a name="ln832">    footer.set_index_handle(r-&gt;last_index_block_handle);</a>
<a name="ln833">    footer.set_checksum(r-&gt;table_options.checksum);</a>
<a name="ln834">    std::string footer_encoding;</a>
<a name="ln835">    footer.AppendEncodedTo(&amp;footer_encoding);</a>
<a name="ln836">    r-&gt;status = r-&gt;metadata_writer-&gt;writer-&gt;Append(footer_encoding);</a>
<a name="ln837">    if (r-&gt;status.ok()) {</a>
<a name="ln838">      r-&gt;metadata_writer-&gt;offset += footer_encoding.size();</a>
<a name="ln839">    }</a>
<a name="ln840">  }</a>
<a name="ln841"> </a>
<a name="ln842">  return r-&gt;status;</a>
<a name="ln843">}</a>
<a name="ln844"> </a>
<a name="ln845">void BlockBasedTableBuilder::Abandon() {</a>
<a name="ln846">  Rep* r = rep_;</a>
<a name="ln847">  assert(!r-&gt;closed);</a>
<a name="ln848">  r-&gt;closed = true;</a>
<a name="ln849">}</a>
<a name="ln850"> </a>
<a name="ln851">uint64_t BlockBasedTableBuilder::NumEntries() const {</a>
<a name="ln852">  return rep_-&gt;props.num_entries;</a>
<a name="ln853">}</a>
<a name="ln854"> </a>
<a name="ln855">uint64_t BlockBasedTableBuilder::TotalFileSize() const {</a>
<a name="ln856">  return rep_-&gt;is_split_sst() ? rep_-&gt;metadata_writer-&gt;offset + rep_-&gt;data_writer-&gt;offset :</a>
<a name="ln857">      rep_-&gt;metadata_writer-&gt;offset;</a>
<a name="ln858">}</a>
<a name="ln859"> </a>
<a name="ln860">uint64_t BlockBasedTableBuilder::BaseFileSize() const {</a>
<a name="ln861">  return rep_-&gt;metadata_writer-&gt;offset;</a>
<a name="ln862">}</a>
<a name="ln863"> </a>
<a name="ln864">bool BlockBasedTableBuilder::NeedCompact() const {</a>
<a name="ln865">  for (const auto&amp; collector : rep_-&gt;table_properties_collectors) {</a>
<a name="ln866">    if (collector-&gt;NeedCompact()) {</a>
<a name="ln867">      return true;</a>
<a name="ln868">    }</a>
<a name="ln869">  }</a>
<a name="ln870">  return false;</a>
<a name="ln871">}</a>
<a name="ln872"> </a>
<a name="ln873">TableProperties BlockBasedTableBuilder::GetTableProperties() const {</a>
<a name="ln874">  TableProperties ret = rep_-&gt;props;</a>
<a name="ln875">  for (const auto&amp; collector : rep_-&gt;table_properties_collectors) {</a>
<a name="ln876">    for (const auto&amp; prop : collector-&gt;GetReadableProperties()) {</a>
<a name="ln877">      ret.readable_properties.insert(prop);</a>
<a name="ln878">    }</a>
<a name="ln879">    CHECK_OK(collector-&gt;Finish(&amp;ret.user_collected_properties));</a>
<a name="ln880">  }</a>
<a name="ln881">  return ret;</a>
<a name="ln882">}</a>
<a name="ln883"> </a>
<a name="ln884">}  // namespace rocksdb</a>

</code></pre>
<div class="balloon" rel="391"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1023/" target="_blank">V1023</a> A pointer without owner is added to the 'table_properties_collectors' container by the 'emplace_back' method. A memory leak will occur in case of an exception.</p></div>
<div class="balloon" rel="445"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="453"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="527"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="879"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="240"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the compiler generated constructor. Consider inspecting: compressed_cache_key_prefix.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
