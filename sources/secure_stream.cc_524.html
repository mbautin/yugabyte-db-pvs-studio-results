
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>secure_stream.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Copyright (c) YugaByte, Inc.</a>
<a name="ln2">//</a>
<a name="ln3">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln4">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln5">//</a>
<a name="ln6">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln7">//</a>
<a name="ln8">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln9">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln10">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln11">// under the License.</a>
<a name="ln12">//</a>
<a name="ln13"> </a>
<a name="ln14">#include &quot;yb/rpc/secure_stream.h&quot;</a>
<a name="ln15"> </a>
<a name="ln16">#include &lt;openssl/evp.h&gt;</a>
<a name="ln17">#include &lt;openssl/err.h&gt;</a>
<a name="ln18">#include &lt;openssl/ssl.h&gt;</a>
<a name="ln19">#include &lt;openssl/x509.h&gt;</a>
<a name="ln20">#include &lt;openssl/x509v3.h&gt;</a>
<a name="ln21"> </a>
<a name="ln22">#include &quot;yb/rpc/outbound_call.h&quot;</a>
<a name="ln23">#include &quot;yb/rpc/outbound_data.h&quot;</a>
<a name="ln24">#include &quot;yb/rpc/rpc_util.h&quot;</a>
<a name="ln25"> </a>
<a name="ln26">#include &quot;yb/util/errno.h&quot;</a>
<a name="ln27">#include &quot;yb/util/memory/memory.h&quot;</a>
<a name="ln28">#include &quot;yb/util/logging.h&quot;</a>
<a name="ln29">#include &quot;yb/util/scope_exit.h&quot;</a>
<a name="ln30">#include &quot;yb/util/size_literals.h&quot;</a>
<a name="ln31">#include &quot;yb/util/encryption_util.h&quot;</a>
<a name="ln32"> </a>
<a name="ln33">using namespace std::literals;</a>
<a name="ln34"> </a>
<a name="ln35">DEFINE_bool(allow_insecure_connections, true, &quot;Whether we should allow insecure connections.&quot;);</a>
<a name="ln36">DEFINE_bool(dump_certificate_entries, false, &quot;Whether we should dump certificate entries.&quot;);</a>
<a name="ln37"> </a>
<a name="ln38">namespace yb {</a>
<a name="ln39">namespace rpc {</a>
<a name="ln40"> </a>
<a name="ln41">namespace {</a>
<a name="ln42"> </a>
<a name="ln43">const unsigned char kContextId[] = { 'Y', 'u', 'g', 'a', 'B', 'y', 't', 'e' };</a>
<a name="ln44"> </a>
<a name="ln45">std::string SSLErrorMessage(int error) {</a>
<a name="ln46">  auto message = ERR_reason_error_string(error);</a>
<a name="ln47">  return message ? message : &quot;no error&quot;;</a>
<a name="ln48">}</a>
<a name="ln49"> </a>
<a name="ln50">class SecureOutboundData : public OutboundData {</a>
<a name="ln51"> public:</a>
<a name="ln52">  SecureOutboundData(RefCntBuffer buffer, OutboundDataPtr lower_data)</a>
<a name="ln53">      : buffer_(std::move(buffer)), lower_data_(std::move(lower_data)) {}</a>
<a name="ln54"> </a>
<a name="ln55">  void Transferred(const Status&amp; status, Connection* conn) override {</a>
<a name="ln56">    if (lower_data_) {</a>
<a name="ln57">      lower_data_-&gt;Transferred(status, conn);</a>
<a name="ln58">    }</a>
<a name="ln59">  }</a>
<a name="ln60"> </a>
<a name="ln61">  bool DumpPB(const DumpRunningRpcsRequestPB&amp; req, RpcCallInProgressPB* resp) override {</a>
<a name="ln62">    return false;</a>
<a name="ln63">  }</a>
<a name="ln64"> </a>
<a name="ln65">  void Serialize(boost::container::small_vector_base&lt;RefCntBuffer&gt;* output) override {</a>
<a name="ln66">    output-&gt;push_back(std::move(buffer_));</a>
<a name="ln67">  }</a>
<a name="ln68"> </a>
<a name="ln69">  std::string ToString() const override {</a>
<a name="ln70">    return Format(&quot;Secure[$0]&quot;, lower_data_);</a>
<a name="ln71">  }</a>
<a name="ln72"> </a>
<a name="ln73">  size_t ObjectSize() const override { return sizeof(*this); }</a>
<a name="ln74"> </a>
<a name="ln75">  size_t DynamicMemoryUsage() const override { return DynamicMemoryUsageOf(buffer_, lower_data_); }</a>
<a name="ln76"> </a>
<a name="ln77"> private:</a>
<a name="ln78">  RefCntBuffer buffer_;</a>
<a name="ln79">  OutboundDataPtr lower_data_;</a>
<a name="ln80">};</a>
<a name="ln81"> </a>
<a name="ln82">#define YB_RPC_SSL_TYPE_DEFINE(name) \</a>
<a name="ln83">  void BOOST_PP_CAT(name, Free)::operator()(name* value) const { \</a>
<a name="ln84">    BOOST_PP_CAT(name, _free)(value); \</a>
<a name="ln85">  } \</a>
<a name="ln86"> </a>
<a name="ln87">#define YB_RPC_SSL_TYPE(name) YB_RPC_SSL_TYPE_DECLARE(name) YB_RPC_SSL_TYPE_DEFINE(name)</a>
<a name="ln88"> </a>
<a name="ln89">#define SSL_STATUS(type, format) STATUS_FORMAT(type, format, SSLErrorMessage(ERR_get_error()))</a>
<a name="ln90"> </a>
<a name="ln91">Result&lt;detail::BIOPtr&gt; BIOFromSlice(const Slice&amp; data) {</a>
<a name="ln92">  detail::BIOPtr bio(BIO_new_mem_buf(data.data(), data.size()));</a>
<a name="ln93">  if (!bio) {</a>
<a name="ln94">    return SSL_STATUS(IOError, &quot;Create BIO failed: $0&quot;);</a>
<a name="ln95">  }</a>
<a name="ln96">  return std::move(bio);</a>
<a name="ln97">}</a>
<a name="ln98"> </a>
<a name="ln99">Result&lt;detail::X509Ptr&gt; X509FromSlice(const Slice&amp; data) {</a>
<a name="ln100">  ERR_clear_error();</a>
<a name="ln101"> </a>
<a name="ln102">  auto bio = VERIFY_RESULT(BIOFromSlice(data));</a>
<a name="ln103"> </a>
<a name="ln104">  detail::X509Ptr cert(PEM_read_bio_X509(bio.get(), nullptr, nullptr, nullptr));</a>
<a name="ln105">  if (!cert) {</a>
<a name="ln106">    return SSL_STATUS(IOError, &quot;Read cert failed: $0&quot;);</a>
<a name="ln107">  }</a>
<a name="ln108"> </a>
<a name="ln109">  return std::move(cert);</a>
<a name="ln110">}</a>
<a name="ln111"> </a>
<a name="ln112">YB_RPC_SSL_TYPE(ASN1_INTEGER);</a>
<a name="ln113">YB_RPC_SSL_TYPE(RSA);</a>
<a name="ln114">YB_RPC_SSL_TYPE(X509_NAME);</a>
<a name="ln115"> </a>
<a name="ln116">Result&lt;detail::EVP_PKEYPtr&gt; GeneratePrivateKey(int bits) {</a>
<a name="ln117">  RSAPtr rsa(RSA_generate_key(bits, 65537, nullptr, nullptr));</a>
<a name="ln118">  if (!rsa) {</a>
<a name="ln119">    return SSL_STATUS(InvalidArgument, &quot;Failed to generate private key: $0&quot;);</a>
<a name="ln120">  }</a>
<a name="ln121"> </a>
<a name="ln122">  detail::EVP_PKEYPtr pkey(EVP_PKEY_new());</a>
<a name="ln123">  auto res = EVP_PKEY_assign_RSA(pkey.get(), rsa.release());</a>
<a name="ln124">  if (res != 1) {</a>
<a name="ln125">    return SSL_STATUS(InvalidArgument, &quot;Failed to assign private key: $0&quot;);</a>
<a name="ln126">  }</a>
<a name="ln127"> </a>
<a name="ln128">  return std::move(pkey);</a>
<a name="ln129">}</a>
<a name="ln130"> </a>
<a name="ln131">Result&lt;detail::X509Ptr&gt; CreateCertificate(</a>
<a name="ln132">    EVP_PKEY* key, const std::string&amp; common_name, EVP_PKEY* ca_pkey, X509* ca_cert) {</a>
<a name="ln133">  detail::X509Ptr cert(X509_new());</a>
<a name="ln134">  if (!cert) {</a>
<a name="ln135">    return SSL_STATUS(IOError, &quot;Failed to create new certificate: $0&quot;);</a>
<a name="ln136">  }</a>
<a name="ln137"> </a>
<a name="ln138">  if (X509_set_version(cert.get(), 2) != 1) {</a>
<a name="ln139">    return SSL_STATUS(IOError, &quot;Failed to set certificate version: $0&quot;);</a>
<a name="ln140">  }</a>
<a name="ln141"> </a>
<a name="ln142">  ASN1_INTEGERPtr aserial(ASN1_INTEGER_new());</a>
<a name="ln143">  ASN1_INTEGER_set(aserial.get(), 0);</a>
<a name="ln144">  if (!X509_set_serialNumber(cert.get(), aserial.get())) {</a>
<a name="ln145">    return SSL_STATUS(IOError, &quot;Failed to set serial number: $0&quot;);</a>
<a name="ln146">  }</a>
<a name="ln147"> </a>
<a name="ln148">  X509_NAMEPtr name(X509_NAME_new());</a>
<a name="ln149">  auto bytes = pointer_cast&lt;const unsigned char*&gt;(common_name.c_str());</a>
<a name="ln150">  if (!X509_NAME_add_entry_by_txt(</a>
<a name="ln151">      name.get(), &quot;CN&quot;, MBSTRING_ASC, bytes, common_name.length(), -1, 0)) {</a>
<a name="ln152">    return SSL_STATUS(IOError, &quot;Failed to create subject: $0&quot;);</a>
<a name="ln153">  }</a>
<a name="ln154"> </a>
<a name="ln155">  if (X509_set_subject_name(cert.get(), name.get()) != 1) {</a>
<a name="ln156">    return SSL_STATUS(IOError, &quot;Failed to set subject: $0&quot;);</a>
<a name="ln157">  }</a>
<a name="ln158"> </a>
<a name="ln159">  X509_NAME* issuer = name.get();</a>
<a name="ln160">  if (ca_cert) {</a>
<a name="ln161">    issuer = X509_get_subject_name(ca_cert);</a>
<a name="ln162">    if (!issuer) {</a>
<a name="ln163">      return SSL_STATUS(IOError, &quot;Failed to get CA subject name: $0&quot;);</a>
<a name="ln164">    }</a>
<a name="ln165">  }</a>
<a name="ln166"> </a>
<a name="ln167">  if (X509_set_issuer_name(cert.get(), issuer) != 1) {</a>
<a name="ln168">    return SSL_STATUS(IOError, &quot;Failed to set issuer: $0&quot;);</a>
<a name="ln169">  }</a>
<a name="ln170"> </a>
<a name="ln171">  if (X509_set_pubkey(cert.get(), key) != 1) {</a>
<a name="ln172">    return SSL_STATUS(IOError, &quot;Failed to set public key: $0&quot;);</a>
<a name="ln173">  }</a>
<a name="ln174"> </a>
<a name="ln175">  if (!X509_gmtime_adj(X509_get_notBefore(cert.get()), 0)) {</a>
<a name="ln176">    return SSL_STATUS(IOError, &quot;Failed to set not before: $0&quot;);</a>
<a name="ln177">  }</a>
<a name="ln178"> </a>
<a name="ln179">  const auto k1Year = 365 * 24h;</a>
<a name="ln180">  auto seconds = std::chrono::duration_cast&lt;std::chrono::seconds&gt;(k1Year).count();</a>
<a name="ln181">  if (!X509_gmtime_adj(X509_get_notAfter(cert.get()), seconds)) {</a>
<a name="ln182">    return SSL_STATUS(IOError, &quot;Failed to set not after: $0&quot;);</a>
<a name="ln183">  }</a>
<a name="ln184"> </a>
<a name="ln185">  if (ca_cert) {</a>
<a name="ln186">    X509V3_CTX ctx;</a>
<a name="ln187">    X509V3_set_ctx(&amp;ctx, ca_cert, cert.get(), nullptr, nullptr, 0);</a>
<a name="ln188">  }</a>
<a name="ln189"> </a>
<a name="ln190">  if (!X509_sign(cert.get(), ca_pkey, EVP_sha256())) {</a>
<a name="ln191">    return SSL_STATUS(IOError, &quot;Sign failed: $0&quot;);</a>
<a name="ln192">  }</a>
<a name="ln193"> </a>
<a name="ln194">  return std::move(cert);</a>
<a name="ln195">}</a>
<a name="ln196"> </a>
<a name="ln197">} // namespace</a>
<a name="ln198"> </a>
<a name="ln199">namespace detail {</a>
<a name="ln200"> </a>
<a name="ln201">YB_RPC_SSL_TYPE_DEFINE(BIO)</a>
<a name="ln202">YB_RPC_SSL_TYPE_DEFINE(EVP_PKEY)</a>
<a name="ln203">YB_RPC_SSL_TYPE_DEFINE(SSL)</a>
<a name="ln204">YB_RPC_SSL_TYPE_DEFINE(SSL_CTX)</a>
<a name="ln205">YB_RPC_SSL_TYPE_DEFINE(X509)</a>
<a name="ln206"> </a>
<a name="ln207">}</a>
<a name="ln208"> </a>
<a name="ln209">SecureContext::SecureContext() {</a>
<a name="ln210">  yb::enterprise::InitOpenSSL();</a>
<a name="ln211"> </a>
<a name="ln212">  context_.reset(SSL_CTX_new(SSLv23_method()));</a>
<a name="ln213">  DCHECK(context_);</a>
<a name="ln214"> </a>
<a name="ln215">  SSL_CTX_set_options(context_.get(), SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3 | SSL_OP_NO_COMPRESSION);</a>
<a name="ln216">  auto res = SSL_CTX_set_session_id_context(context_.get(), kContextId, sizeof(kContextId));</a>
<a name="ln217">  LOG_IF(DFATAL, res != 1) &lt;&lt; &quot;Failed to set session id for SSL context: &quot;</a>
<a name="ln218">                           &lt;&lt; SSLErrorMessage(ERR_get_error());</a>
<a name="ln219">}</a>
<a name="ln220"> </a>
<a name="ln221">detail::SSLPtr SecureContext::Create() const {</a>
<a name="ln222">  return detail::SSLPtr(SSL_new(context_.get()));</a>
<a name="ln223">}</a>
<a name="ln224"> </a>
<a name="ln225">Status SecureContext::AddCertificateAuthorityFile(const std::string&amp; file) {</a>
<a name="ln226">  X509_STORE* store = SSL_CTX_get_cert_store(context_.get());</a>
<a name="ln227">  if (!store) {</a>
<a name="ln228">    return SSL_STATUS(IllegalState, &quot;Failed to get store: $0&quot;);</a>
<a name="ln229">  }</a>
<a name="ln230"> </a>
<a name="ln231">  auto bytes = pointer_cast&lt;const char*&gt;(file.c_str());</a>
<a name="ln232">  auto res = X509_STORE_load_locations(store, bytes, nullptr);</a>
<a name="ln233">  if (res != 1) {</a>
<a name="ln234">    return SSL_STATUS(InvalidArgument, &quot;Failed to add certificate file: $0&quot;);</a>
<a name="ln235">  }</a>
<a name="ln236"> </a>
<a name="ln237">  return Status::OK();</a>
<a name="ln238">}</a>
<a name="ln239"> </a>
<a name="ln240">Status SecureContext::AddCertificateAuthority(const Slice&amp; data) {</a>
<a name="ln241">  return AddCertificateAuthority(VERIFY_RESULT(X509FromSlice(data)).get());</a>
<a name="ln242">}</a>
<a name="ln243"> </a>
<a name="ln244">Status SecureContext::AddCertificateAuthority(X509* cert) {</a>
<a name="ln245">  X509_STORE* store = SSL_CTX_get_cert_store(context_.get());</a>
<a name="ln246">  if (!store) {</a>
<a name="ln247">    return SSL_STATUS(IllegalState, &quot;Failed to get store: $0&quot;);</a>
<a name="ln248">  }</a>
<a name="ln249"> </a>
<a name="ln250">  auto res = X509_STORE_add_cert(store, cert);</a>
<a name="ln251">  if (res != 1) {</a>
<a name="ln252">    return SSL_STATUS(InvalidArgument, &quot;Failed to add certificate: $0&quot;);</a>
<a name="ln253">  }</a>
<a name="ln254"> </a>
<a name="ln255">  return Status::OK();</a>
<a name="ln256">}</a>
<a name="ln257"> </a>
<a name="ln258">Status SecureContext::TEST_GenerateKeys(int bits, const std::string&amp; common_name) {</a>
<a name="ln259">  auto ca_key = VERIFY_RESULT(GeneratePrivateKey(bits));</a>
<a name="ln260">  auto ca_cert = VERIFY_RESULT(CreateCertificate(ca_key.get(), &quot;YugaByte&quot;, ca_key.get(), nullptr));</a>
<a name="ln261">  auto key = VERIFY_RESULT(GeneratePrivateKey(bits));</a>
<a name="ln262">  auto cert = VERIFY_RESULT(CreateCertificate(key.get(), common_name, ca_key.get(), ca_cert.get()));</a>
<a name="ln263"> </a>
<a name="ln264">  RETURN_NOT_OK(AddCertificateAuthority(ca_cert.get()));</a>
<a name="ln265">  pkey_ = std::move(key);</a>
<a name="ln266">  certificate_ = std::move(cert);</a>
<a name="ln267"> </a>
<a name="ln268">  return Status::OK();</a>
<a name="ln269">}</a>
<a name="ln270"> </a>
<a name="ln271">Status SecureContext::UsePrivateKey(const Slice&amp; slice) {</a>
<a name="ln272">  ERR_clear_error();</a>
<a name="ln273"> </a>
<a name="ln274">  auto bio = VERIFY_RESULT(BIOFromSlice(slice));</a>
<a name="ln275"> </a>
<a name="ln276">  auto pkey = PEM_read_bio_PrivateKey(bio.get(), nullptr, nullptr, nullptr);</a>
<a name="ln277">  if (!pkey) {</a>
<a name="ln278">    return SSL_STATUS(IOError, &quot;Failed to read private key: $0&quot;);</a>
<a name="ln279">  }</a>
<a name="ln280"> </a>
<a name="ln281">  pkey_.reset(pkey);</a>
<a name="ln282">  return Status::OK();</a>
<a name="ln283">}</a>
<a name="ln284"> </a>
<a name="ln285">Status SecureContext::UseCertificate(const Slice&amp; data) {</a>
<a name="ln286">  ERR_clear_error();</a>
<a name="ln287"> </a>
<a name="ln288">  certificate_ = VERIFY_RESULT(X509FromSlice(data));</a>
<a name="ln289"> </a>
<a name="ln290">  return Status::OK();</a>
<a name="ln291">}</a>
<a name="ln292"> </a>
<a name="ln293">namespace {</a>
<a name="ln294"> </a>
<a name="ln295">class SecureStream : public Stream, public StreamContext {</a>
<a name="ln296"> public:</a>
<a name="ln297">  SecureStream(const SecureContext&amp; context, std::unique_ptr&lt;Stream&gt; lower_stream,</a>
<a name="ln298">               size_t receive_buffer_size, const MemTrackerPtr&amp; buffer_tracker,</a>
<a name="ln299">               const StreamCreateData&amp; data)</a>
<a name="ln300">    : secure_context_(context), lower_stream_(std::move(lower_stream)),</a>
<a name="ln301">      remote_hostname_(data.remote_hostname),</a>
<a name="ln302">      encrypted_read_buffer_(receive_buffer_size, buffer_tracker) {</a>
<a name="ln303">  }</a>
<a name="ln304"> </a>
<a name="ln305">  SecureStream(const SecureStream&amp;) = delete;</a>
<a name="ln306">  void operator=(const SecureStream&amp;) = delete;</a>
<a name="ln307"> </a>
<a name="ln308">  size_t GetPendingWriteBytes() override {</a>
<a name="ln309">    return lower_stream_-&gt;GetPendingWriteBytes();</a>
<a name="ln310">  }</a>
<a name="ln311"> </a>
<a name="ln312"> private:</a>
<a name="ln313">  CHECKED_STATUS Start(bool connect, ev::loop_ref* loop, StreamContext* context) override;</a>
<a name="ln314">  void Close() override;</a>
<a name="ln315">  void Shutdown(const Status&amp; status) override;</a>
<a name="ln316">  size_t Send(OutboundDataPtr data) override;</a>
<a name="ln317">  CHECKED_STATUS TryWrite() override;</a>
<a name="ln318">  void ParseReceived() override;</a>
<a name="ln319"> </a>
<a name="ln320">  void Cancelled(size_t handle) override {</a>
<a name="ln321">    LOG_WITH_PREFIX(DFATAL) &lt;&lt; &quot;Cancel is not supported for secure stream: &quot; &lt;&lt; handle;</a>
<a name="ln322">  }</a>
<a name="ln323"> </a>
<a name="ln324">  bool Idle(std::string* reason_not_idle) override;</a>
<a name="ln325">  bool IsConnected() override;</a>
<a name="ln326">  void DumpPB(const DumpRunningRpcsRequestPB&amp; req, RpcConnectionPB* resp) override;</a>
<a name="ln327"> </a>
<a name="ln328">  const Endpoint&amp; Remote() override;</a>
<a name="ln329">  const Endpoint&amp; Local() override;</a>
<a name="ln330"> </a>
<a name="ln331">  const Protocol* GetProtocol() override {</a>
<a name="ln332">    return SecureStreamProtocol();</a>
<a name="ln333">  }</a>
<a name="ln334"> </a>
<a name="ln335">  // Implementation StreamContext</a>
<a name="ln336">  void UpdateLastActivity() override;</a>
<a name="ln337">  void UpdateLastRead() override;</a>
<a name="ln338">  void UpdateLastWrite() override;</a>
<a name="ln339">  void Transferred(const OutboundDataPtr&amp; data, const Status&amp; status) override;</a>
<a name="ln340">  void Destroy(const Status&amp; status) override;</a>
<a name="ln341">  Result&lt;ProcessDataResult&gt; ProcessReceived(</a>
<a name="ln342">      const IoVecs&amp; data, ReadBufferFull read_buffer_full) override;</a>
<a name="ln343">  void Connected() override;</a>
<a name="ln344"> </a>
<a name="ln345">  StreamReadBuffer&amp; ReadBuffer() override {</a>
<a name="ln346">    return encrypted_read_buffer_;</a>
<a name="ln347">  }</a>
<a name="ln348"> </a>
<a name="ln349">  CHECKED_STATUS Handshake();</a>
<a name="ln350"> </a>
<a name="ln351">  CHECKED_STATUS Init();</a>
<a name="ln352">  void Established(SecureState state);</a>
<a name="ln353">  static int VerifyCallback(int preverified, X509_STORE_CTX* store_context);</a>
<a name="ln354">  bool Verify(bool preverified, X509_STORE_CTX* store_context);</a>
<a name="ln355">  void WriteEncrypted(OutboundDataPtr data);</a>
<a name="ln356">  CHECKED_STATUS ReadDecrypted();</a>
<a name="ln357">  Result&lt;size_t&gt; SslRead(void* buf, int num);</a>
<a name="ln358"> </a>
<a name="ln359">  std::string ToString() override;</a>
<a name="ln360"> </a>
<a name="ln361">  const SecureContext&amp; secure_context_;</a>
<a name="ln362">  std::unique_ptr&lt;Stream&gt; lower_stream_;</a>
<a name="ln363">  const std::string remote_hostname_;</a>
<a name="ln364">  StreamContext* context_;</a>
<a name="ln365">  size_t decrypted_bytes_to_skip_ = 0;</a>
<a name="ln366">  SecureState state_ = SecureState::kInitial;</a>
<a name="ln367">  bool need_connect_ = false;</a>
<a name="ln368">  bool connected_ = false;</a>
<a name="ln369">  std::vector&lt;OutboundDataPtr&gt; pending_data_;</a>
<a name="ln370">  std::vector&lt;std::string&gt; certificate_entries_;</a>
<a name="ln371"> </a>
<a name="ln372">  CircularReadBuffer encrypted_read_buffer_;</a>
<a name="ln373"> </a>
<a name="ln374">  detail::BIOPtr bio_;</a>
<a name="ln375">  detail::SSLPtr ssl_;</a>
<a name="ln376">};</a>
<a name="ln377"> </a>
<a name="ln378">Status SecureStream::Start(bool connect, ev::loop_ref* loop, StreamContext* context) {</a>
<a name="ln379">  context_ = context;</a>
<a name="ln380">  need_connect_ = connect;</a>
<a name="ln381">  return lower_stream_-&gt;Start(connect, loop, this);</a>
<a name="ln382">}</a>
<a name="ln383"> </a>
<a name="ln384">void SecureStream::Close() {</a>
<a name="ln385">  lower_stream_-&gt;Close();</a>
<a name="ln386">}</a>
<a name="ln387"> </a>
<a name="ln388">void SecureStream::Shutdown(const Status&amp; status) {</a>
<a name="ln389">  VLOG_WITH_PREFIX(1) &lt;&lt; &quot;SecureStream::Shutdown with status: &quot; &lt;&lt; status;</a>
<a name="ln390"> </a>
<a name="ln391">  for (auto&amp; data : pending_data_) {</a>
<a name="ln392">    if (data) {</a>
<a name="ln393">      context_-&gt;Transferred(data, status);</a>
<a name="ln394">    }</a>
<a name="ln395">  }</a>
<a name="ln396">  pending_data_.clear();</a>
<a name="ln397"> </a>
<a name="ln398">  lower_stream_-&gt;Shutdown(status);</a>
<a name="ln399">}</a>
<a name="ln400"> </a>
<a name="ln401">size_t SecureStream::Send(OutboundDataPtr data) {</a>
<a name="ln402">  switch (state_) {</a>
<a name="ln403">  case SecureState::kInitial:</a>
<a name="ln404">  case SecureState::kHandshake:</a>
<a name="ln405">    pending_data_.push_back(std::move(data));</a>
<a name="ln406">    return std::numeric_limits&lt;size_t&gt;::max();</a>
<a name="ln407">  case SecureState::kEnabled: {</a>
<a name="ln408">      boost::container::small_vector&lt;RefCntBuffer, 10&gt; queue;</a>
<a name="ln409">      data-&gt;Serialize(&amp;queue);</a>
<a name="ln410">      for (const auto&amp; buf : queue) {</a>
<a name="ln411">        Slice slice(buf.data(), buf.size());</a>
<a name="ln412">        for (;;) {</a>
<a name="ln413">          auto len = SSL_write(ssl_.get(), slice.data(), slice.size());</a>
<a name="ln414">          if (len == slice.size()) {</a>
<a name="ln415">            break;</a>
<a name="ln416">          }</a>
<a name="ln417">          VLOG_WITH_PREFIX(4) &lt;&lt; &quot;SSL_write was not full: &quot; &lt;&lt; slice.size() &lt;&lt; &quot;, written: &quot; &lt;&lt; len;</a>
<a name="ln418">          WriteEncrypted(nullptr);</a>
<a name="ln419">          slice.remove_prefix(len);</a>
<a name="ln420">        }</a>
<a name="ln421">      }</a>
<a name="ln422">      WriteEncrypted(std::move(data));</a>
<a name="ln423">    }</a>
<a name="ln424">    return std::numeric_limits&lt;size_t&gt;::max();</a>
<a name="ln425">  case SecureState::kDisabled:</a>
<a name="ln426">    return lower_stream_-&gt;Send(std::move(data));</a>
<a name="ln427">  }</a>
<a name="ln428"> </a>
<a name="ln429">  return std::numeric_limits&lt;size_t&gt;::max();</a>
<a name="ln430">}</a>
<a name="ln431"> </a>
<a name="ln432">void SecureStream::WriteEncrypted(OutboundDataPtr data) {</a>
<a name="ln433">  RefCntBuffer buf(BIO_ctrl_pending(bio_.get()));</a>
<a name="ln434">  auto len = BIO_read(bio_.get(), buf.data(), buf.size());</a>
<a name="ln435">  LOG_IF_WITH_PREFIX(DFATAL, len != buf.size())</a>
<a name="ln436">      &lt;&lt; &quot;BIO_read was not full: &quot; &lt;&lt; buf.size() &lt;&lt; &quot;, read: &quot; &lt;&lt; len;</a>
<a name="ln437">  VLOG_WITH_PREFIX(4) &lt;&lt; &quot;Write encrypted: &quot; &lt;&lt; len &lt;&lt; &quot;, &quot; &lt;&lt; yb::ToString(data);</a>
<a name="ln438">  lower_stream_-&gt;Send(std::make_shared&lt;SecureOutboundData&gt;(buf, std::move(data)));</a>
<a name="ln439">}</a>
<a name="ln440"> </a>
<a name="ln441">Status SecureStream::TryWrite() {</a>
<a name="ln442">  return lower_stream_-&gt;TryWrite();</a>
<a name="ln443">}</a>
<a name="ln444"> </a>
<a name="ln445">void SecureStream::ParseReceived() {</a>
<a name="ln446">  lower_stream_-&gt;ParseReceived();</a>
<a name="ln447">}</a>
<a name="ln448"> </a>
<a name="ln449">bool SecureStream::Idle(std::string* reason) {</a>
<a name="ln450">  return lower_stream_-&gt;Idle(reason);</a>
<a name="ln451">}</a>
<a name="ln452"> </a>
<a name="ln453">bool SecureStream::IsConnected() {</a>
<a name="ln454">  return connected_;</a>
<a name="ln455">}</a>
<a name="ln456"> </a>
<a name="ln457">void SecureStream::DumpPB(const DumpRunningRpcsRequestPB&amp; req, RpcConnectionPB* resp) {</a>
<a name="ln458">  lower_stream_-&gt;DumpPB(req, resp);</a>
<a name="ln459">}</a>
<a name="ln460"> </a>
<a name="ln461">const Endpoint&amp; SecureStream::Remote() {</a>
<a name="ln462">  return lower_stream_-&gt;Remote();</a>
<a name="ln463">}</a>
<a name="ln464"> </a>
<a name="ln465">const Endpoint&amp; SecureStream::Local() {</a>
<a name="ln466">  return lower_stream_-&gt;Local();</a>
<a name="ln467">}</a>
<a name="ln468"> </a>
<a name="ln469">std::string SecureStream::ToString() {</a>
<a name="ln470">  return Format(&quot;SECURE $0 $1&quot;, state_, lower_stream_-&gt;ToString());</a>
<a name="ln471">}</a>
<a name="ln472"> </a>
<a name="ln473">void SecureStream::UpdateLastActivity() {</a>
<a name="ln474">  context_-&gt;UpdateLastActivity();</a>
<a name="ln475">}</a>
<a name="ln476"> </a>
<a name="ln477">void SecureStream::UpdateLastRead() {</a>
<a name="ln478">  context_-&gt;UpdateLastRead();</a>
<a name="ln479">}</a>
<a name="ln480"> </a>
<a name="ln481">void SecureStream::UpdateLastWrite() {</a>
<a name="ln482">  context_-&gt;UpdateLastWrite();</a>
<a name="ln483">}</a>
<a name="ln484"> </a>
<a name="ln485">void SecureStream::Transferred(const OutboundDataPtr&amp; data, const Status&amp; status) {</a>
<a name="ln486">  context_-&gt;Transferred(data, status);</a>
<a name="ln487">}</a>
<a name="ln488"> </a>
<a name="ln489">void SecureStream::Destroy(const Status&amp; status) {</a>
<a name="ln490">  context_-&gt;Destroy(status);</a>
<a name="ln491">}</a>
<a name="ln492"> </a>
<a name="ln493">Result&lt;ProcessDataResult&gt; SecureStream::ProcessReceived(</a>
<a name="ln494">    const IoVecs&amp; data, ReadBufferFull read_buffer_full) {</a>
<a name="ln495">  switch (state_) {</a>
<a name="ln496">    case SecureState::kInitial: {</a>
<a name="ln497">      if (data[0].iov_len &lt; 2) {</a>
<a name="ln498">        return ProcessDataResult{0, Slice()};</a>
<a name="ln499">      }</a>
<a name="ln500">      const uint8_t* bytes = static_cast&lt;const uint8_t*&gt;(data[0].iov_base);</a>
<a name="ln501">      if (bytes[0] == 0x16 &amp;&amp; bytes[1] == 0x03) { // TLS handshake header</a>
<a name="ln502">        state_ = SecureState::kHandshake;</a>
<a name="ln503">        ResetLogPrefix();</a>
<a name="ln504">        RETURN_NOT_OK(Init());</a>
<a name="ln505">      } else if (FLAGS_allow_insecure_connections) {</a>
<a name="ln506">        Established(SecureState::kDisabled);</a>
<a name="ln507">      } else {</a>
<a name="ln508">        return STATUS_FORMAT(NetworkError, &quot;Insecure connection header: $0&quot;,</a>
<a name="ln509">                             Slice(bytes, 2).ToDebugHexString());</a>
<a name="ln510">      }</a>
<a name="ln511">      return ProcessReceived(data, read_buffer_full);</a>
<a name="ln512">    }</a>
<a name="ln513"> </a>
<a name="ln514">    case SecureState::kDisabled:</a>
<a name="ln515">      return context_-&gt;ProcessReceived(data, read_buffer_full);</a>
<a name="ln516"> </a>
<a name="ln517">    case SecureState::kHandshake: {</a>
<a name="ln518">      size_t result = 0;</a>
<a name="ln519">      for (const auto&amp; iov : data) {</a>
<a name="ln520">        auto written = BIO_write(bio_.get(), iov.iov_base, iov.iov_len);</a>
<a name="ln521">        result += written;</a>
<a name="ln522">        DCHECK_EQ(written, iov.iov_len);</a>
<a name="ln523">      }</a>
<a name="ln524">      auto handshake_status = Handshake();</a>
<a name="ln525">      LOG_IF_WITH_PREFIX(INFO, !handshake_status.ok()) &lt;&lt; &quot;Handshake failed: &quot; &lt;&lt; handshake_status;</a>
<a name="ln526">      RETURN_NOT_OK(handshake_status);</a>
<a name="ln527">      return ProcessDataResult{ result, Slice() };</a>
<a name="ln528">    }</a>
<a name="ln529"> </a>
<a name="ln530">    case SecureState::kEnabled: {</a>
<a name="ln531">      size_t result = 0;</a>
<a name="ln532">      for (const auto&amp; iov : data) {</a>
<a name="ln533">        Slice slice(static_cast&lt;char*&gt;(iov.iov_base), iov.iov_len);</a>
<a name="ln534">        for (;;) {</a>
<a name="ln535">          auto len = BIO_write(bio_.get(), slice.data(), slice.size());</a>
<a name="ln536">          result += len;</a>
<a name="ln537">          if (len == slice.size()) {</a>
<a name="ln538">            break;</a>
<a name="ln539">          }</a>
<a name="ln540">          slice.remove_prefix(len);</a>
<a name="ln541">          RETURN_NOT_OK(ReadDecrypted());</a>
<a name="ln542">        }</a>
<a name="ln543">      }</a>
<a name="ln544">      RETURN_NOT_OK(ReadDecrypted());</a>
<a name="ln545">      return ProcessDataResult{ result, Slice() };</a>
<a name="ln546">    }</a>
<a name="ln547">  }</a>
<a name="ln548"> </a>
<a name="ln549">  return STATUS_FORMAT(IllegalState, &quot;Unexpected state: $0&quot;, to_underlying(state_));</a>
<a name="ln550">}</a>
<a name="ln551"> </a>
<a name="ln552">// Tries to do SSL_read up to num bytes from buf. Possible results:</a>
<a name="ln553">// &gt; 0 - number of bytes actually read.</a>
<a name="ln554">// = 0 - in case of SSL_ERROR_WANT_READ.</a>
<a name="ln555">// Status with network error - in case of other errors.</a>
<a name="ln556">Result&lt;size_t&gt; SecureStream::SslRead(void* buf, int num) {</a>
<a name="ln557">  auto len = SSL_read(ssl_.get(), buf, num);</a>
<a name="ln558">  if (len &lt;= 0) {</a>
<a name="ln559">    auto error = SSL_get_error(ssl_.get(), len);</a>
<a name="ln560">    if (error == SSL_ERROR_WANT_READ) {</a>
<a name="ln561">      return 0;</a>
<a name="ln562">    } else {</a>
<a name="ln563">      LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;SSL read error: &quot; &lt;&lt; error;</a>
<a name="ln564">      return STATUS_FORMAT(NetworkError, &quot;SSL read failed: $0&quot;, error);</a>
<a name="ln565">    }</a>
<a name="ln566">  }</a>
<a name="ln567">  return len;</a>
<a name="ln568">}</a>
<a name="ln569"> </a>
<a name="ln570">Status SecureStream::ReadDecrypted() {</a>
<a name="ln571">  // TODO handle IsBusy</a>
<a name="ln572">  auto&amp; decrypted_read_buffer = context_-&gt;ReadBuffer();</a>
<a name="ln573">  bool done = false;</a>
<a name="ln574">  while (!done) {</a>
<a name="ln575">    if (decrypted_bytes_to_skip_ &gt; 0) {</a>
<a name="ln576">      auto global_skip_buffer = GetGlobalSkipBuffer();</a>
<a name="ln577">      do {</a>
<a name="ln578">        auto len = VERIFY_RESULT(SslRead(</a>
<a name="ln579">            global_skip_buffer.mutable_data(),</a>
<a name="ln580">            std::min(global_skip_buffer.size(), decrypted_bytes_to_skip_)));</a>
<a name="ln581">        if (len == 0) {</a>
<a name="ln582">          done = true;</a>
<a name="ln583">          break;</a>
<a name="ln584">        }</a>
<a name="ln585">        VLOG_WITH_PREFIX(4) &lt;&lt; &quot;Skip decrypted: &quot; &lt;&lt; len;</a>
<a name="ln586">        decrypted_bytes_to_skip_ -= len;</a>
<a name="ln587">      } while (decrypted_bytes_to_skip_ &gt; 0);</a>
<a name="ln588">    }</a>
<a name="ln589">    auto out = VERIFY_RESULT(decrypted_read_buffer.PrepareAppend());</a>
<a name="ln590">    size_t appended = 0;</a>
<a name="ln591">    for (auto iov = out.begin(); iov != out.end();) {</a>
<a name="ln592">      auto len = VERIFY_RESULT(SslRead(iov-&gt;iov_base, iov-&gt;iov_len));</a>
<a name="ln593">      if (len == 0) {</a>
<a name="ln594">        done = true;</a>
<a name="ln595">        break;</a>
<a name="ln596">      }</a>
<a name="ln597">      VLOG_WITH_PREFIX(4) &lt;&lt; &quot;Read decrypted: &quot; &lt;&lt; len;</a>
<a name="ln598">      appended += len;</a>
<a name="ln599">      iov-&gt;iov_base = static_cast&lt;char*&gt;(iov-&gt;iov_base) + len;</a>
<a name="ln600">      iov-&gt;iov_len -= len;</a>
<a name="ln601">      if (iov-&gt;iov_len &lt;= 0) {</a>
<a name="ln602">        ++iov;</a>
<a name="ln603">      }</a>
<a name="ln604">    }</a>
<a name="ln605">    decrypted_read_buffer.DataAppended(appended);</a>
<a name="ln606">    if (decrypted_read_buffer.ReadyToRead()) {</a>
<a name="ln607">      auto temp = VERIFY_RESULT(context_-&gt;ProcessReceived(</a>
<a name="ln608">          decrypted_read_buffer.AppendedVecs(), ReadBufferFull(decrypted_read_buffer.Full())));</a>
<a name="ln609">      decrypted_read_buffer.Consume(temp.consumed, temp.buffer);</a>
<a name="ln610">      DCHECK_EQ(decrypted_bytes_to_skip_, 0);</a>
<a name="ln611">      decrypted_bytes_to_skip_ = temp.bytes_to_skip;</a>
<a name="ln612">    }</a>
<a name="ln613">  }</a>
<a name="ln614"> </a>
<a name="ln615">  return Status::OK();</a>
<a name="ln616">}</a>
<a name="ln617"> </a>
<a name="ln618">void SecureStream::Connected() {</a>
<a name="ln619">  if (need_connect_) {</a>
<a name="ln620">    auto status = Init();</a>
<a name="ln621">    if (status.ok()) {</a>
<a name="ln622">      status = Handshake();</a>
<a name="ln623">    }</a>
<a name="ln624">    if (!status.ok()) {</a>
<a name="ln625">      context_-&gt;Destroy(status);</a>
<a name="ln626">    }</a>
<a name="ln627">  }</a>
<a name="ln628">}</a>
<a name="ln629"> </a>
<a name="ln630">Status SecureStream::Handshake() {</a>
<a name="ln631">  for (;;) {</a>
<a name="ln632">    if (state_ == SecureState::kEnabled) {</a>
<a name="ln633">      return Status::OK();</a>
<a name="ln634">    }</a>
<a name="ln635"> </a>
<a name="ln636">    auto pending_before = BIO_ctrl_pending(bio_.get());</a>
<a name="ln637">    ERR_clear_error();</a>
<a name="ln638">    int result = need_connect_ ? SSL_connect(ssl_.get()) : SSL_accept(ssl_.get());</a>
<a name="ln639">    int ssl_error = SSL_get_error(ssl_.get(), result);</a>
<a name="ln640">    int sys_error = static_cast&lt;int&gt;(ERR_get_error());</a>
<a name="ln641">    auto pending_after = BIO_ctrl_pending(bio_.get());</a>
<a name="ln642"> </a>
<a name="ln643">    if (ssl_error == SSL_ERROR_SSL || ssl_error == SSL_ERROR_SYSCALL) {</a>
<a name="ln644">      std::string message =</a>
<a name="ln645">          ssl_error == SSL_ERROR_SSL ? SSLErrorMessage(sys_error) : ErrnoToString(sys_error);</a>
<a name="ln646">      std::string certificate_entries;</a>
<a name="ln647">      if (FLAGS_dump_certificate_entries) {</a>
<a name="ln648">        certificate_entries = Format(&quot;, certificate entries: $0&quot;, certificate_entries_);</a>
<a name="ln649">      }</a>
<a name="ln650">      return STATUS_FORMAT(NetworkError, &quot;Handshake failed: $0, address: $1, hostname: $2$3&quot;,</a>
<a name="ln651">                           message, Remote().address(), remote_hostname_, certificate_entries);</a>
<a name="ln652">    }</a>
<a name="ln653"> </a>
<a name="ln654">    if (ssl_error == SSL_ERROR_WANT_WRITE || pending_after &gt; pending_before) {</a>
<a name="ln655">      // SSL expects that we would write to underlying transport.</a>
<a name="ln656">      RefCntBuffer buffer(pending_after);</a>
<a name="ln657">      int len = BIO_read(bio_.get(), buffer.data(), buffer.size());</a>
<a name="ln658">      DCHECK_EQ(len, pending_after);</a>
<a name="ln659">      auto data = std::make_shared&lt;SecureOutboundData&gt;(buffer, nullptr);</a>
<a name="ln660">      lower_stream_-&gt;Send(data);</a>
<a name="ln661">      // If SSL_connect/SSL_accept returned positive result it means that TLS connection</a>
<a name="ln662">      // was succesfully established. We just have to send last portion of data.</a>
<a name="ln663">      if (result &gt; 0) {</a>
<a name="ln664">        Established(SecureState::kEnabled);</a>
<a name="ln665">      }</a>
<a name="ln666">    } else if (ssl_error == SSL_ERROR_WANT_READ) {</a>
<a name="ln667">      // SSL expects that we would read from underlying transport.</a>
<a name="ln668">      return Status::OK();</a>
<a name="ln669">    } else if (SSL_get_shutdown(ssl_.get()) &amp; SSL_RECEIVED_SHUTDOWN) {</a>
<a name="ln670">      return STATUS(Aborted, &quot;Handshake aborted&quot;);</a>
<a name="ln671">    } else {</a>
<a name="ln672">      Established(SecureState::kEnabled);</a>
<a name="ln673">      return Status::OK();</a>
<a name="ln674">    }</a>
<a name="ln675">  }</a>
<a name="ln676">}</a>
<a name="ln677"> </a>
<a name="ln678">Status SecureStream::Init() {</a>
<a name="ln679">  if (!ssl_) {</a>
<a name="ln680">    ssl_ = secure_context_.Create();</a>
<a name="ln681">    SSL_set_mode(ssl_.get(), SSL_MODE_ENABLE_PARTIAL_WRITE);</a>
<a name="ln682">    SSL_set_mode(ssl_.get(), SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER);</a>
<a name="ln683">    SSL_set_mode(ssl_.get(), SSL_MODE_RELEASE_BUFFERS);</a>
<a name="ln684">    SSL_set_app_data(ssl_.get(), this);</a>
<a name="ln685"> </a>
<a name="ln686">    if (!need_connect_) {</a>
<a name="ln687">      auto res = SSL_use_PrivateKey(ssl_.get(), secure_context_.private_key());</a>
<a name="ln688">      if (res != 1) {</a>
<a name="ln689">        return SSL_STATUS(InvalidArgument, &quot;Failed to use private key: $0&quot;);</a>
<a name="ln690">      }</a>
<a name="ln691">      res = SSL_use_certificate(ssl_.get(), secure_context_.certificate());</a>
<a name="ln692">      if (res != 1) {</a>
<a name="ln693">        return SSL_STATUS(InvalidArgument, &quot;Failed to use certificate: $0&quot;);</a>
<a name="ln694">      }</a>
<a name="ln695">    }</a>
<a name="ln696"> </a>
<a name="ln697">    BIO* int_bio = nullptr;</a>
<a name="ln698">    BIO* temp_bio = nullptr;</a>
<a name="ln699">    BIO_new_bio_pair(&amp;int_bio, 0, &amp;temp_bio, 0);</a>
<a name="ln700">    SSL_set_bio(ssl_.get(), int_bio, int_bio);</a>
<a name="ln701">    bio_.reset(temp_bio);</a>
<a name="ln702"> </a>
<a name="ln703">    SSL_set_verify(ssl_.get(), SSL_VERIFY_PEER, &amp;VerifyCallback);</a>
<a name="ln704">  }</a>
<a name="ln705"> </a>
<a name="ln706">  return Status::OK();</a>
<a name="ln707">}</a>
<a name="ln708"> </a>
<a name="ln709">void SecureStream::Established(SecureState state) {</a>
<a name="ln710">  VLOG_WITH_PREFIX(4) &lt;&lt; &quot;Established with state: &quot; &lt;&lt; state;</a>
<a name="ln711"> </a>
<a name="ln712">  state_ = state;</a>
<a name="ln713">  ResetLogPrefix();</a>
<a name="ln714">  connected_ = true;</a>
<a name="ln715">  context_-&gt;Connected();</a>
<a name="ln716">  for (auto&amp; data : pending_data_) {</a>
<a name="ln717">    Send(std::move(data));</a>
<a name="ln718">  }</a>
<a name="ln719">  pending_data_.clear();</a>
<a name="ln720">}</a>
<a name="ln721"> </a>
<a name="ln722">int SecureStream::VerifyCallback(int preverified, X509_STORE_CTX* store_context) {</a>
<a name="ln723">  if (store_context) {</a>
<a name="ln724">    auto ssl = static_cast&lt;SSL*&gt;(X509_STORE_CTX_get_ex_data(</a>
<a name="ln725">        store_context, SSL_get_ex_data_X509_STORE_CTX_idx()));</a>
<a name="ln726">    if (ssl) {</a>
<a name="ln727">      auto stream = static_cast&lt;SecureStream*&gt;(SSL_get_app_data(ssl));</a>
<a name="ln728">      if (stream) {</a>
<a name="ln729">        return stream-&gt;Verify(preverified != 0, store_context) ? 1 : 0;</a>
<a name="ln730">      }</a>
<a name="ln731">    }</a>
<a name="ln732">  }</a>
<a name="ln733"> </a>
<a name="ln734">  return preverified;</a>
<a name="ln735">}</a>
<a name="ln736"> </a>
<a name="ln737">namespace {</a>
<a name="ln738"> </a>
<a name="ln739">// Matches pattern from RFC 2818:</a>
<a name="ln740">// Names may contain the wildcard character * which is considered to match any single domain name</a>
<a name="ln741">// component or component fragment. E.g., *.a.com matches foo.a.com but not bar.foo.a.com.</a>
<a name="ln742">// f*.com matches foo.com but not bar.com.</a>
<a name="ln743">bool MatchPattern(Slice pattern, Slice host) {</a>
<a name="ln744">  const char* p = pattern.cdata();</a>
<a name="ln745">  const char* p_end = pattern.cend();</a>
<a name="ln746">  const char* h = host.cdata();</a>
<a name="ln747">  const char* h_end = host.cend();</a>
<a name="ln748"> </a>
<a name="ln749">  while (p != p_end &amp;&amp; h != h_end) {</a>
<a name="ln750">    if (*p == '*') {</a>
<a name="ln751">      ++p;</a>
<a name="ln752">      while (h != h_end &amp;&amp; *h != '.') {</a>
<a name="ln753">        if (MatchPattern(Slice(p, p_end), Slice(h, h_end))) {</a>
<a name="ln754">          return true;</a>
<a name="ln755">        }</a>
<a name="ln756">        ++h;</a>
<a name="ln757">      }</a>
<a name="ln758">    } else if (std::tolower(*p) == std::tolower(*h)) {</a>
<a name="ln759">      ++p;</a>
<a name="ln760">      ++h;</a>
<a name="ln761">    } else {</a>
<a name="ln762">      return false;</a>
<a name="ln763">    }</a>
<a name="ln764">  }</a>
<a name="ln765"> </a>
<a name="ln766">  return p == p_end &amp;&amp; h == h_end;</a>
<a name="ln767">}</a>
<a name="ln768"> </a>
<a name="ln769">} // namespace</a>
<a name="ln770"> </a>
<a name="ln771">// Verify according to RFC 2818.</a>
<a name="ln772">bool SecureStream::Verify(bool preverified, X509_STORE_CTX* store_context) {</a>
<a name="ln773">  // Don't bother looking at certificates that have failed pre-verification.</a>
<a name="ln774">  if (!preverified) {</a>
<a name="ln775">    VLOG_WITH_PREFIX(4) &lt;&lt; &quot;Unverified certificate&quot;;</a>
<a name="ln776">    return false;</a>
<a name="ln777">  }</a>
<a name="ln778"> </a>
<a name="ln779">  // We're only interested in checking the certificate at the end of the chain.</a>
<a name="ln780">  int depth = X509_STORE_CTX_get_error_depth(store_context);</a>
<a name="ln781">  if (depth &gt; 0) {</a>
<a name="ln782">    VLOG_WITH_PREFIX(4) &lt;&lt; &quot;Intermediate certificate&quot;;</a>
<a name="ln783">    return true;</a>
<a name="ln784">  }</a>
<a name="ln785"> </a>
<a name="ln786">  X509* cert = X509_STORE_CTX_get_current_cert(store_context);</a>
<a name="ln787"> </a>
<a name="ln788">  auto gens = static_cast&lt;GENERAL_NAMES*&gt;(X509_get_ext_d2i(cert, NID_subject_alt_name, 0, 0));</a>
<a name="ln789">  auto se = ScopeExit([gens] {</a>
<a name="ln790">    GENERAL_NAMES_free(gens);</a>
<a name="ln791">  });</a>
<a name="ln792"> </a>
<a name="ln793">  auto address = Remote().address();</a>
<a name="ln794"> </a>
<a name="ln795">  for (int i = 0; i &lt; sk_GENERAL_NAME_num(gens); ++i) {</a>
<a name="ln796">    GENERAL_NAME* gen = sk_GENERAL_NAME_value(gens, i);</a>
<a name="ln797">    if (gen-&gt;type == GEN_DNS) {</a>
<a name="ln798">      ASN1_IA5STRING* domain = gen-&gt;d.dNSName;</a>
<a name="ln799">      if (domain-&gt;type == V_ASN1_IA5STRING &amp;&amp; domain-&gt;data &amp;&amp; domain-&gt;length) {</a>
<a name="ln800">        Slice domain_slice(domain-&gt;data, domain-&gt;length);</a>
<a name="ln801">        VLOG_WITH_PREFIX(4) &lt;&lt; &quot;Domain: &quot; &lt;&lt; domain_slice.ToBuffer() &lt;&lt; &quot; vs &quot; &lt;&lt; remote_hostname_;</a>
<a name="ln802">        if (FLAGS_dump_certificate_entries) {</a>
<a name="ln803">          certificate_entries_.push_back(Format(&quot;DNS:$0&quot;, domain_slice.ToBuffer()));</a>
<a name="ln804">        }</a>
<a name="ln805">        if (MatchPattern(domain_slice, remote_hostname_)) {</a>
<a name="ln806">          return true;</a>
<a name="ln807">        }</a>
<a name="ln808">      }</a>
<a name="ln809">    } else if (gen-&gt;type == GEN_IPADD) {</a>
<a name="ln810">      ASN1_OCTET_STRING* ip_address = gen-&gt;d.iPAddress;</a>
<a name="ln811">      if (ip_address-&gt;type == V_ASN1_OCTET_STRING &amp;&amp; ip_address-&gt;data) {</a>
<a name="ln812">        if (ip_address-&gt;length == 4) {</a>
<a name="ln813">          boost::asio::ip::address_v4::bytes_type bytes;</a>
<a name="ln814">          memcpy(&amp;bytes, ip_address-&gt;data, bytes.size());</a>
<a name="ln815">          auto allowed_address = boost::asio::ip::address_v4(bytes);</a>
<a name="ln816">          VLOG_WITH_PREFIX(4) &lt;&lt; &quot;IPv4: &quot; &lt;&lt; allowed_address.to_string() &lt;&lt; &quot; vs &quot; &lt;&lt; address;</a>
<a name="ln817">          if (FLAGS_dump_certificate_entries) {</a>
<a name="ln818">            certificate_entries_.push_back(Format(&quot;IP Address:$0&quot;, allowed_address));</a>
<a name="ln819">          }</a>
<a name="ln820">          if (address == allowed_address) {</a>
<a name="ln821">            return true;</a>
<a name="ln822">          }</a>
<a name="ln823">        } else if (ip_address-&gt;length == 16) {</a>
<a name="ln824">          boost::asio::ip::address_v6::bytes_type bytes;</a>
<a name="ln825">          memcpy(&amp;bytes, ip_address-&gt;data, bytes.size());</a>
<a name="ln826">          auto allowed_address = boost::asio::ip::address_v6(bytes);</a>
<a name="ln827">          VLOG_WITH_PREFIX(4) &lt;&lt; &quot;IPv6: &quot; &lt;&lt; allowed_address.to_string() &lt;&lt; &quot; vs &quot; &lt;&lt; address;</a>
<a name="ln828">          if (FLAGS_dump_certificate_entries) {</a>
<a name="ln829">            certificate_entries_.push_back(Format(&quot;IP Address:$0&quot;, allowed_address));</a>
<a name="ln830">          }</a>
<a name="ln831">          if (address == allowed_address) {</a>
<a name="ln832">            return true;</a>
<a name="ln833">          }</a>
<a name="ln834">        }</a>
<a name="ln835">      }</a>
<a name="ln836">    }</a>
<a name="ln837">  }</a>
<a name="ln838"> </a>
<a name="ln839">  // No match in the alternate names, so try the common names. We should only</a>
<a name="ln840">  // use the &quot;most specific&quot; common name, which is the last one in the list.</a>
<a name="ln841">  X509_NAME* name = X509_get_subject_name(cert);</a>
<a name="ln842">  int i = -1;</a>
<a name="ln843">  ASN1_STRING* common_name = 0;</a>
<a name="ln844">  while ((i = X509_NAME_get_index_by_NID(name, NID_commonName, i)) &gt;= 0) {</a>
<a name="ln845">    X509_NAME_ENTRY* name_entry = X509_NAME_get_entry(name, i);</a>
<a name="ln846">    common_name = X509_NAME_ENTRY_get_data(name_entry);</a>
<a name="ln847">  }</a>
<a name="ln848">  if (common_name &amp;&amp; common_name-&gt;data &amp;&amp; common_name-&gt;length) {</a>
<a name="ln849">    Slice common_name_slice(common_name-&gt;data, common_name-&gt;length);</a>
<a name="ln850">    VLOG_WITH_PREFIX(4) &lt;&lt; &quot;Common name: &quot; &lt;&lt; common_name_slice.ToBuffer() &lt;&lt; &quot; vs &quot;</a>
<a name="ln851">                        &lt;&lt; Remote().address() &lt;&lt; &quot;/&quot; &lt;&lt; remote_hostname_;</a>
<a name="ln852">    if (FLAGS_dump_certificate_entries) {</a>
<a name="ln853">      certificate_entries_.push_back(Format(&quot;CN:$0&quot;, common_name_slice.ToBuffer()));</a>
<a name="ln854">    }</a>
<a name="ln855">    if (common_name_slice == Remote().address().to_string() ||</a>
<a name="ln856">        MatchPattern(common_name_slice, remote_hostname_)) {</a>
<a name="ln857">      return true;</a>
<a name="ln858">    }</a>
<a name="ln859">  }</a>
<a name="ln860"> </a>
<a name="ln861">  VLOG_WITH_PREFIX(4) &lt;&lt; &quot;Nothing suitable for &quot; &lt;&lt; Remote().address() &lt;&lt; &quot;/&quot; &lt;&lt; remote_hostname_;</a>
<a name="ln862">  return false;</a>
<a name="ln863">}</a>
<a name="ln864"> </a>
<a name="ln865">} // namespace</a>
<a name="ln866"> </a>
<a name="ln867">const Protocol* SecureStreamProtocol() {</a>
<a name="ln868">  static Protocol result(&quot;tcps&quot;);</a>
<a name="ln869">  return &amp;result;</a>
<a name="ln870">}</a>
<a name="ln871"> </a>
<a name="ln872">StreamFactoryPtr SecureStreamFactory(</a>
<a name="ln873">    StreamFactoryPtr lower_layer_factory, const MemTrackerPtr&amp; buffer_tracker,</a>
<a name="ln874">    SecureContext* context) {</a>
<a name="ln875">  class SecureStreamFactory : public StreamFactory {</a>
<a name="ln876">   public:</a>
<a name="ln877">    SecureStreamFactory(</a>
<a name="ln878">        StreamFactoryPtr lower_layer_factory, const MemTrackerPtr&amp; buffer_tracker,</a>
<a name="ln879">        SecureContext* context)</a>
<a name="ln880">        : lower_layer_factory_(std::move(lower_layer_factory)), buffer_tracker_(buffer_tracker),</a>
<a name="ln881">          context_(context) {</a>
<a name="ln882">    }</a>
<a name="ln883"> </a>
<a name="ln884">   private:</a>
<a name="ln885">    std::unique_ptr&lt;Stream&gt; Create(const StreamCreateData&amp; data) override {</a>
<a name="ln886">      auto receive_buffer_size = data.socket-&gt;GetReceiveBufferSize();</a>
<a name="ln887">      if (!receive_buffer_size.ok()) {</a>
<a name="ln888">        LOG(WARNING) &lt;&lt; &quot;Secure stream failure: &quot; &lt;&lt; receive_buffer_size.status();</a>
<a name="ln889">        receive_buffer_size = 256_KB;</a>
<a name="ln890">      }</a>
<a name="ln891">      auto lower_stream = lower_layer_factory_-&gt;Create(data);</a>
<a name="ln892">      return std::make_unique&lt;SecureStream&gt;(</a>
<a name="ln893">          *context_, std::move(lower_stream), *receive_buffer_size, buffer_tracker_, data);</a>
<a name="ln894">    }</a>
<a name="ln895"> </a>
<a name="ln896">    StreamFactoryPtr lower_layer_factory_;</a>
<a name="ln897">    MemTrackerPtr buffer_tracker_;</a>
<a name="ln898">    SecureContext* context_;</a>
<a name="ln899">  };</a>
<a name="ln900"> </a>
<a name="ln901">  return std::make_shared&lt;SecureStreamFactory&gt;(</a>
<a name="ln902">      std::move(lower_layer_factory), buffer_tracker, context);</a>
<a name="ln903">}</a>
<a name="ln904"> </a>
<a name="ln905">} // namespace rpc</a>
<a name="ln906">} // namespace yb</a>

</code></pre>
<div class="balloon" rel="213"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="217"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="389"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="417"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="435"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="437"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="525"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="585"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="597"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="710"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="775"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="782"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="801"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="816"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="827"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="850"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="861"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="297"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: context_.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
