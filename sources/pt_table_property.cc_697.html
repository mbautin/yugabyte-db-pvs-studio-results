
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>pt_table_property.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Copyright (c) YugaByte, Inc.</a>
<a name="ln2">//</a>
<a name="ln3">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln4">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln5">//</a>
<a name="ln6">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln7">//</a>
<a name="ln8">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln9">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln10">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln11">// under the License.</a>
<a name="ln12">//</a>
<a name="ln13"> </a>
<a name="ln14">#include &lt;set&gt;</a>
<a name="ln15"> </a>
<a name="ln16">#include &quot;yb/client/schema.h&quot;</a>
<a name="ln17">#include &quot;yb/client/table.h&quot;</a>
<a name="ln18"> </a>
<a name="ln19">#include &quot;yb/yql/cql/ql/ptree/pt_table_property.h&quot;</a>
<a name="ln20">#include &quot;yb/yql/cql/ql/ptree/sem_context.h&quot;</a>
<a name="ln21">#include &quot;yb/util/stol_utils.h&quot;</a>
<a name="ln22">#include &quot;yb/util/string_case.h&quot;</a>
<a name="ln23">#include &quot;yb/util/string_util.h&quot;</a>
<a name="ln24"> </a>
<a name="ln25">namespace yb {</a>
<a name="ln26">namespace ql {</a>
<a name="ln27"> </a>
<a name="ln28">using strings::Substitute;</a>
<a name="ln29">using client::YBColumnSchema;</a>
<a name="ln30"> </a>
<a name="ln31">// These property names need to be lowercase, since identifiers are converted to lowercase by the</a>
<a name="ln32">// scanner phase and as a result if we're doing string matching everything should be lowercase.</a>
<a name="ln33">const std::map&lt;std::string, PTTableProperty::KVProperty&gt; PTTableProperty::kPropertyDataTypes</a>
<a name="ln34">    = {</a>
<a name="ln35">    {&quot;bloom_filter_fp_chance&quot;, KVProperty::kBloomFilterFpChance},</a>
<a name="ln36">    {&quot;caching&quot;, KVProperty::kCaching},</a>
<a name="ln37">    {&quot;comment&quot;, KVProperty::kComment},</a>
<a name="ln38">    {&quot;compaction&quot;, KVProperty::kCompaction},</a>
<a name="ln39">    {&quot;compression&quot;, KVProperty::kCompression},</a>
<a name="ln40">    {&quot;crc_check_chance&quot;, KVProperty::kCrcCheckChance},</a>
<a name="ln41">    {&quot;dclocal_read_repair_chance&quot;, KVProperty::kDclocalReadRepairChance},</a>
<a name="ln42">    {&quot;default_time_to_live&quot;, KVProperty::kDefaultTimeToLive},</a>
<a name="ln43">    {&quot;gc_grace_seconds&quot;, KVProperty::kGcGraceSeconds},</a>
<a name="ln44">    {&quot;index_interval&quot;, KVProperty::kIndexInterval},</a>
<a name="ln45">    {&quot;memtable_flush_period_in_ms&quot;, KVProperty::kMemtableFlushPeriodInMs},</a>
<a name="ln46">    {&quot;min_index_interval&quot;, KVProperty::kMinIndexInterval},</a>
<a name="ln47">    {&quot;max_index_interval&quot;, KVProperty::kMaxIndexInterval},</a>
<a name="ln48">    {&quot;read_repair_chance&quot;, KVProperty::kReadRepairChance},</a>
<a name="ln49">    {&quot;speculative_retry&quot;, KVProperty::kSpeculativeRetry},</a>
<a name="ln50">    {&quot;transactions&quot;, KVProperty::kTransactions},</a>
<a name="ln51">    {&quot;tablets&quot;, KVProperty::kNumTablets}</a>
<a name="ln52">};</a>
<a name="ln53"> </a>
<a name="ln54">PTTableProperty::PTTableProperty(MemoryContext *memctx,</a>
<a name="ln55">                                 YBLocation::SharedPtr loc,</a>
<a name="ln56">                                 const MCSharedPtr&lt;MCString&gt;&amp; lhs,</a>
<a name="ln57">                                 const PTExpr::SharedPtr&amp; rhs)</a>
<a name="ln58">    : PTProperty(memctx, loc, lhs, rhs),</a>
<a name="ln59">      property_type_(PropertyType::kTableProperty) {}</a>
<a name="ln60"> </a>
<a name="ln61">PTTableProperty::PTTableProperty(MemoryContext *memctx,</a>
<a name="ln62">                                 YBLocation::SharedPtr loc,</a>
<a name="ln63">                                 const PTExpr::SharedPtr&amp; expr,</a>
<a name="ln64">                                 const PTOrderBy::Direction direction)</a>
<a name="ln65">    : PTProperty(memctx, loc), order_expr_(expr), direction_(direction),</a>
<a name="ln66">      property_type_(PropertyType::kClusteringOrder) {}</a>
<a name="ln67"> </a>
<a name="ln68">PTTableProperty::PTTableProperty(MemoryContext *memctx,</a>
<a name="ln69">                                 YBLocation::SharedPtr loc,</a>
<a name="ln70">                                 const PTQualifiedName::SharedPtr tname)</a>
<a name="ln71">    : PTProperty(memctx, loc), property_type_(PropertyType::kCoPartitionTable),</a>
<a name="ln72">      copartition_table_name_(tname) {}</a>
<a name="ln73"> </a>
<a name="ln74">PTTableProperty::PTTableProperty(MemoryContext *memctx,</a>
<a name="ln75">                                 YBLocation::SharedPtr loc)</a>
<a name="ln76">    : PTProperty(memctx, loc) {</a>
<a name="ln77">}</a>
<a name="ln78"> </a>
<a name="ln79">PTTableProperty::~PTTableProperty() {</a>
<a name="ln80">}</a>
<a name="ln81"> </a>
<a name="ln82"> </a>
<a name="ln83">Status PTTableProperty::AnalyzeSpeculativeRetry(const string &amp;val) {</a>
<a name="ln84">  string generic_error = Substitute(&quot;Invalid value $0 for option 'speculative_retry'&quot;, val);</a>
<a name="ln85"> </a>
<a name="ln86">  // Accepted values: ALWAYS, Xpercentile, Nms, NONE.</a>
<a name="ln87">  if (val == common::kSpeculativeRetryAlways || val == common::kSpeculativeRetryNone) {</a>
<a name="ln88">    return Status::OK();</a>
<a name="ln89">  }</a>
<a name="ln90"> </a>
<a name="ln91">  string numeric_val;</a>
<a name="ln92">  if (StringEndsWith(val, common::kSpeculativeRetryMs, common::kSpeculativeRetryMsLen,</a>
<a name="ln93">                     &amp;numeric_val)) {</a>
<a name="ln94">    RETURN_NOT_OK(CheckedStold(numeric_val));</a>
<a name="ln95">    return Status::OK();</a>
<a name="ln96">  }</a>
<a name="ln97"> </a>
<a name="ln98">  if (StringEndsWith(val, common::kSpeculativeRetryPercentile,</a>
<a name="ln99">                     common::kSpeculativeRetryPercentileLen, &amp;numeric_val)) {</a>
<a name="ln100">    auto percentile = CheckedStold(numeric_val);</a>
<a name="ln101">    RETURN_NOT_OK(percentile);</a>
<a name="ln102"> </a>
<a name="ln103">    if (*percentile &lt; 0.0 || *percentile &gt; 100.0) {</a>
<a name="ln104">      return STATUS(InvalidArgument, Substitute(</a>
<a name="ln105">          &quot;Invalid value $0 for PERCENTILE option 'speculative_retry': &quot;</a>
<a name="ln106">          &quot;must be between 0.0 and 100.0&quot;, numeric_val));</a>
<a name="ln107">    }</a>
<a name="ln108">    return Status::OK();</a>
<a name="ln109">  }</a>
<a name="ln110">  return STATUS(InvalidArgument, generic_error);</a>
<a name="ln111">}</a>
<a name="ln112"> </a>
<a name="ln113">CHECKED_STATUS PTTableProperty::Analyze(SemContext *sem_context) {</a>
<a name="ln114"> </a>
<a name="ln115">  if (property_type_ == PropertyType::kCoPartitionTable) {</a>
<a name="ln116">    RETURN_NOT_OK(copartition_table_name_-&gt;AnalyzeName(sem_context, OBJECT_TABLE));</a>
<a name="ln117"> </a>
<a name="ln118">    bool is_system; // ignored</a>
<a name="ln119">    MCVector&lt;ColumnDesc&gt; copartition_table_columns(sem_context-&gt;PTempMem());</a>
<a name="ln120"> </a>
<a name="ln121">    // Permissions check happen in LookupTable if flag use_cassandra_authentication is enabled.</a>
<a name="ln122">    // TODO(hector): We need to revisit this once this feature is supported so we can decided</a>
<a name="ln123">    // which privileges will be needed.</a>
<a name="ln124">    RETURN_NOT_OK(sem_context-&gt;LookupTable(copartition_table_name_-&gt;ToTableName(),</a>
<a name="ln125">                                           copartition_table_name_-&gt;loc(), /* write_table = */ true,</a>
<a name="ln126">                                           PermissionType::CREATE_PERMISSION,</a>
<a name="ln127">                                           &amp;copartition_table_, &amp;is_system,</a>
<a name="ln128">                                           &amp;copartition_table_columns));</a>
<a name="ln129">    if (sem_context-&gt;current_create_table_stmt()-&gt;hash_columns().size() !=</a>
<a name="ln130">        copartition_table_-&gt;schema().num_hash_key_columns()) {</a>
<a name="ln131">      return sem_context-&gt;Error(this, Substitute(&quot;The number of hash keys in the current table &quot;</a>
<a name="ln132">                                &quot;differ from the number of hash keys in '$0'.&quot;,</a>
<a name="ln133">                                copartition_table_name_-&gt;ToTableName().table_name()).c_str(),</a>
<a name="ln134">                                ErrorCode::INCOMPATIBLE_COPARTITION_SCHEMA);</a>
<a name="ln135">    }</a>
<a name="ln136"> </a>
<a name="ln137">    int index = 0;</a>
<a name="ln138">    for (auto hash_col : sem_context-&gt;current_create_table_stmt()-&gt;hash_columns()) {</a>
<a name="ln139">      auto type = hash_col-&gt;ql_type();</a>
<a name="ln140">      auto base_type = copartition_table_columns[index].ql_type();</a>
<a name="ln141">      if (type != base_type) {</a>
<a name="ln142">        return sem_context-&gt;Error(this, Substitute(&quot;The hash key '$0' in the current table has a &quot;</a>
<a name="ln143">                                  &quot;different datatype from the corresponding hash key in '$1'&quot;,</a>
<a name="ln144">                                  hash_col-&gt;yb_name(),</a>
<a name="ln145">                                  copartition_table_name_-&gt;ToTableName().table_name()).c_str(),</a>
<a name="ln146">                                  ErrorCode::INCOMPATIBLE_COPARTITION_SCHEMA);</a>
<a name="ln147">      }</a>
<a name="ln148">      index++;</a>
<a name="ln149">    }</a>
<a name="ln150"> </a>
<a name="ln151">    return Status::OK();</a>
<a name="ln152">  }</a>
<a name="ln153"> </a>
<a name="ln154">  // Verify we have a valid property name in the lhs.</a>
<a name="ln155">  const auto&amp; table_property_name = lhs_-&gt;c_str();</a>
<a name="ln156">  auto iterator = kPropertyDataTypes.find(table_property_name);</a>
<a name="ln157">  if (iterator == kPropertyDataTypes.end()) {</a>
<a name="ln158">    return sem_context-&gt;Error(this, Substitute(&quot;Unknown property '$0'&quot;, lhs_-&gt;c_str()).c_str(),</a>
<a name="ln159">                              ErrorCode::INVALID_TABLE_PROPERTY);</a>
<a name="ln160">  }</a>
<a name="ln161"> </a>
<a name="ln162">  long double double_val;</a>
<a name="ln163">  int64_t int_val;</a>
<a name="ln164">  string str_val;</a>
<a name="ln165"> </a>
<a name="ln166">  switch (iterator-&gt;second) {</a>
<a name="ln167">    case KVProperty::kBloomFilterFpChance:</a>
<a name="ln168">      RETURN_SEM_CONTEXT_ERROR_NOT_OK(GetDoubleValueFromExpr(rhs_, table_property_name,</a>
<a name="ln169">                                                             &amp;double_val));</a>
<a name="ln170">      if (double_val &lt;= 0.0 || double_val &gt; 1.0) {</a>
<a name="ln171">        return sem_context-&gt;Error(this,</a>
<a name="ln172">            Substitute(&quot;$0 must be larger than 0 and less than or equal to 1.0 (got $1)&quot;,</a>
<a name="ln173">                       table_property_name, std::to_string(double_val)).c_str(),</a>
<a name="ln174">            ErrorCode::INVALID_ARGUMENTS);</a>
<a name="ln175">      }</a>
<a name="ln176">      break;</a>
<a name="ln177">    case KVProperty::kCrcCheckChance: FALLTHROUGH_INTENDED;</a>
<a name="ln178">    case KVProperty::kDclocalReadRepairChance: FALLTHROUGH_INTENDED;</a>
<a name="ln179">    case KVProperty::kReadRepairChance:</a>
<a name="ln180">      RETURN_SEM_CONTEXT_ERROR_NOT_OK(GetDoubleValueFromExpr(rhs_, table_property_name,</a>
<a name="ln181">                                                             &amp;double_val));</a>
<a name="ln182">      if (double_val &lt; 0.0 || double_val &gt; 1.0) {</a>
<a name="ln183">        return sem_context-&gt;Error(this,</a>
<a name="ln184">            Substitute(</a>
<a name="ln185">                &quot;$0 must be larger than or equal to 0 and smaller than or equal to 1.0 (got $1)&quot;,</a>
<a name="ln186">                table_property_name, std::to_string(double_val)).c_str(),</a>
<a name="ln187">            ErrorCode::INVALID_ARGUMENTS);</a>
<a name="ln188">      }</a>
<a name="ln189">      break;</a>
<a name="ln190">    case KVProperty::kDefaultTimeToLive:</a>
<a name="ln191">      RETURN_SEM_CONTEXT_ERROR_NOT_OK(GetIntValueFromExpr(rhs_, table_property_name, &amp;int_val));</a>
<a name="ln192">      // TTL value is entered by user in seconds, but we store internally in milliseconds.</a>
<a name="ln193">      if (!common::IsValidTTLSeconds(int_val)) {</a>
<a name="ln194">        return sem_context-&gt;Error(this, Substitute(&quot;Valid ttl range : [$0, $1]&quot;,</a>
<a name="ln195">                                                   common::kCassandraMinTtlSeconds,</a>
<a name="ln196">                                                   common::kCassandraMaxTtlSeconds).c_str(),</a>
<a name="ln197">                                  ErrorCode::INVALID_ARGUMENTS);</a>
<a name="ln198">      }</a>
<a name="ln199">      break;</a>
<a name="ln200">    case KVProperty::kGcGraceSeconds: FALLTHROUGH_INTENDED;</a>
<a name="ln201">    case KVProperty::kMemtableFlushPeriodInMs:</a>
<a name="ln202">      RETURN_SEM_CONTEXT_ERROR_NOT_OK(GetIntValueFromExpr(rhs_, table_property_name, &amp;int_val));</a>
<a name="ln203">      if (int_val &lt; 0) {</a>
<a name="ln204">        return sem_context-&gt;Error(this,</a>
<a name="ln205">                                  Substitute(&quot;$0 must be greater than or equal to 0 (got $1)&quot;,</a>
<a name="ln206">                                             table_property_name, std::to_string(int_val)).c_str(),</a>
<a name="ln207">                                  ErrorCode::INVALID_ARGUMENTS);</a>
<a name="ln208">      }</a>
<a name="ln209">      break;</a>
<a name="ln210">    case KVProperty::kIndexInterval: FALLTHROUGH_INTENDED;</a>
<a name="ln211">    case KVProperty::kMinIndexInterval: FALLTHROUGH_INTENDED;</a>
<a name="ln212">    case KVProperty::kMaxIndexInterval:</a>
<a name="ln213">      // TODO(hector): Check that kMaxIndexInterval is greater than kMinIndexInterval.</a>
<a name="ln214">      RETURN_SEM_CONTEXT_ERROR_NOT_OK(GetIntValueFromExpr(rhs_, table_property_name, &amp;int_val));</a>
<a name="ln215">      if (int_val &lt; 1) {</a>
<a name="ln216">        return sem_context-&gt;Error(this,</a>
<a name="ln217">                                  Substitute(&quot;$0 must be greater than or equal to 1 (got $1)&quot;,</a>
<a name="ln218">                                             table_property_name, std::to_string(int_val)).c_str(),</a>
<a name="ln219">                                  ErrorCode::INVALID_ARGUMENTS);</a>
<a name="ln220">      }</a>
<a name="ln221">      break;</a>
<a name="ln222">    case KVProperty::kSpeculativeRetry:</a>
<a name="ln223">      RETURN_SEM_CONTEXT_ERROR_NOT_OK(GetStringValueFromExpr(rhs_, true, table_property_name,</a>
<a name="ln224">                                                             &amp;str_val));</a>
<a name="ln225">      RETURN_SEM_CONTEXT_ERROR_NOT_OK(AnalyzeSpeculativeRetry(str_val));</a>
<a name="ln226">      break;</a>
<a name="ln227">    case KVProperty::kComment:</a>
<a name="ln228">      RETURN_SEM_CONTEXT_ERROR_NOT_OK(GetStringValueFromExpr(rhs_, true, table_property_name,</a>
<a name="ln229">                                                             &amp;str_val));</a>
<a name="ln230">      break;</a>
<a name="ln231">    case KVProperty::kCompaction: FALLTHROUGH_INTENDED;</a>
<a name="ln232">    case KVProperty::kCaching: FALLTHROUGH_INTENDED;</a>
<a name="ln233">    case KVProperty::kCompression: FALLTHROUGH_INTENDED;</a>
<a name="ln234">    case KVProperty::kTransactions:</a>
<a name="ln235">      return sem_context-&gt;Error(this,</a>
<a name="ln236">                                Substitute(&quot;Invalid value for option '$0'. Value must be a map&quot;,</a>
<a name="ln237">                                           table_property_name).c_str(),</a>
<a name="ln238">                                ErrorCode::DATATYPE_MISMATCH);</a>
<a name="ln239">    case KVProperty::kNumTablets:</a>
<a name="ln240">      RETURN_SEM_CONTEXT_ERROR_NOT_OK(GetIntValueFromExpr(rhs_, table_property_name, &amp;int_val));</a>
<a name="ln241">      if (int_val &gt; FLAGS_max_num_tablets_for_table) {</a>
<a name="ln242">        return sem_context-&gt;Error(</a>
<a name="ln243">            this, &quot;Number of tablets exceeds system limit&quot;, ErrorCode::INVALID_ARGUMENTS);</a>
<a name="ln244">      }</a>
<a name="ln245">      break;</a>
<a name="ln246">  }</a>
<a name="ln247"> </a>
<a name="ln248">  PTAlterTable *alter_table = sem_context-&gt;current_alter_table();</a>
<a name="ln249">  if (alter_table != nullptr) {</a>
<a name="ln250">    RETURN_NOT_OK(alter_table-&gt;AppendAlterProperty(sem_context, this));</a>
<a name="ln251">  }</a>
<a name="ln252">  return Status::OK();</a>
<a name="ln253">}</a>
<a name="ln254"> </a>
<a name="ln255">std::ostream&amp; operator&lt;&lt;(ostream&amp; os, const PropertyType&amp; property_type) {</a>
<a name="ln256">  switch(property_type) {</a>
<a name="ln257">    case PropertyType::kTableProperty:</a>
<a name="ln258">      os &lt;&lt; &quot;kTableProperty&quot;;</a>
<a name="ln259">      break;</a>
<a name="ln260">    case PropertyType::kClusteringOrder:</a>
<a name="ln261">      os &lt;&lt; &quot;kClusteringOrder&quot;;</a>
<a name="ln262">      break;</a>
<a name="ln263">    case PropertyType::kTablePropertyMap:</a>
<a name="ln264">      os &lt;&lt; &quot;kTablePropertyMap&quot;;</a>
<a name="ln265">      break;</a>
<a name="ln266">    case PropertyType::kCoPartitionTable:</a>
<a name="ln267">      os &lt;&lt; &quot;kCoPartitionTable&quot;;</a>
<a name="ln268">      break;</a>
<a name="ln269">  }</a>
<a name="ln270">  return os;</a>
<a name="ln271">}</a>
<a name="ln272"> </a>
<a name="ln273">void PTTableProperty::PrintSemanticAnalysisResult(SemContext *sem_context) {</a>
<a name="ln274">  VLOG(3) &lt;&lt; &quot;SEMANTIC ANALYSIS RESULT (&quot; &lt;&lt; *loc_ &lt;&lt; &quot;):\n&quot; &lt;&lt; &quot;Not yet avail&quot;;</a>
<a name="ln275">}</a>
<a name="ln276"> </a>
<a name="ln277">CHECKED_STATUS PTTablePropertyListNode::Analyze(SemContext *sem_context) {</a>
<a name="ln278">  // Set to ensure we don't have duplicate table properties.</a>
<a name="ln279">  std::set&lt;string&gt; table_properties;</a>
<a name="ln280">  unordered_map&lt;string, PTTableProperty::SharedPtr&gt; order_tnodes;</a>
<a name="ln281">  vector&lt;string&gt; order_columns;</a>
<a name="ln282">  for (PTTableProperty::SharedPtr tnode : node_list()) {</a>
<a name="ln283">    if (tnode == nullptr) {</a>
<a name="ln284">      // This shouldn't happen because AppendList ignores null nodes.</a>
<a name="ln285">      LOG(ERROR) &lt;&lt; &quot;Invalid null property&quot;;</a>
<a name="ln286">      continue;</a>
<a name="ln287">      }</a>
<a name="ln288">    switch(tnode-&gt;property_type()) {</a>
<a name="ln289">      case PropertyType::kTableProperty: FALLTHROUGH_INTENDED;</a>
<a name="ln290">      case PropertyType::kTablePropertyMap: {</a>
<a name="ln291">        string table_property_name = tnode-&gt;lhs()-&gt;c_str();</a>
<a name="ln292">        if (table_properties.find(table_property_name) != table_properties.end()) {</a>
<a name="ln293">          return sem_context-&gt;Error(this, ErrorCode::DUPLICATE_TABLE_PROPERTY);</a>
<a name="ln294">        }</a>
<a name="ln295">        RETURN_NOT_OK(tnode-&gt;Analyze(sem_context));</a>
<a name="ln296">        table_properties.insert(table_property_name);</a>
<a name="ln297">        break;</a>
<a name="ln298">      }</a>
<a name="ln299">      case PropertyType ::kCoPartitionTable: {</a>
<a name="ln300">        RETURN_NOT_OK(tnode-&gt;Analyze(sem_context));</a>
<a name="ln301">        break;</a>
<a name="ln302">      }</a>
<a name="ln303">      case PropertyType::kClusteringOrder: {</a>
<a name="ln304">        const MCString column_name(tnode-&gt;name().c_str(), sem_context-&gt;PTempMem());</a>
<a name="ln305">        const PTColumnDefinition *col = sem_context-&gt;GetColumnDefinition(column_name);</a>
<a name="ln306">        if (col == nullptr || !col-&gt;is_primary_key() || col-&gt;is_hash_key()) {</a>
<a name="ln307">          return sem_context-&gt;Error(tnode, &quot;Not a clustering key column&quot;,</a>
<a name="ln308">                                    ErrorCode::INVALID_TABLE_PROPERTY);</a>
<a name="ln309">        }</a>
<a name="ln310">        // Insert column_name only the first time we see it.</a>
<a name="ln311">        if (order_tnodes.find(column_name.c_str()) == order_tnodes.end()) {</a>
<a name="ln312">          order_columns.push_back(column_name.c_str());</a>
<a name="ln313">        }</a>
<a name="ln314">        // If a column ordering was set more than once, we use the last order provided.</a>
<a name="ln315">        order_tnodes[column_name.c_str()] = tnode;</a>
<a name="ln316">        break;</a>
<a name="ln317">      }</a>
<a name="ln318">    }</a>
<a name="ln319">  }</a>
<a name="ln320"> </a>
<a name="ln321">  auto order_column_iter = order_columns.begin();</a>
<a name="ln322">  for (auto &amp;pc : sem_context-&gt;current_create_table_stmt()-&gt;primary_columns()) {</a>
<a name="ln323">    if (order_column_iter == order_columns.end()) {</a>
<a name="ln324">      break;</a>
<a name="ln325">    }</a>
<a name="ln326">    const auto &amp;tnode = order_tnodes[*order_column_iter];</a>
<a name="ln327">    if (strcmp(pc-&gt;yb_name(), order_column_iter-&gt;c_str()) != 0) {</a>
<a name="ln328">      string msg;</a>
<a name="ln329">      // If we can find pc-&gt;yb_name() in the order-by list, it means the order of the columns is</a>
<a name="ln330">      // incorrect.</a>
<a name="ln331">      if (order_tnodes.find(pc-&gt;yb_name()) != order_tnodes.end()) {</a>
<a name="ln332">        msg = Substitute(&quot;Columns in the CLUSTERING ORDER directive must be in same order as &quot;</a>
<a name="ln333">                         &quot;the clustering key columns order ($0 must appear before $1)&quot;,</a>
<a name="ln334">                         pc-&gt;yb_name(), *order_column_iter);</a>
<a name="ln335">      } else {</a>
<a name="ln336">        msg = Substitute(&quot;Missing CLUSTERING ORDER for column $0&quot;, pc-&gt;yb_name());</a>
<a name="ln337">      }</a>
<a name="ln338">      return sem_context-&gt;Error(tnode, msg.c_str(), ErrorCode::INVALID_TABLE_PROPERTY);</a>
<a name="ln339">    }</a>
<a name="ln340">    if (tnode-&gt;direction() == PTOrderBy::Direction::kASC) {</a>
<a name="ln341">      pc-&gt;set_sorting_type(ColumnSchema::SortingType::kAscending);</a>
<a name="ln342">    } else if (tnode-&gt;direction() == PTOrderBy::Direction::kDESC) {</a>
<a name="ln343">      pc-&gt;set_sorting_type(ColumnSchema::SortingType::kDescending);</a>
<a name="ln344">    }</a>
<a name="ln345">    ++order_column_iter;</a>
<a name="ln346">  }</a>
<a name="ln347">  if (order_column_iter != order_columns.end()) {</a>
<a name="ln348">    const auto &amp;tnode = order_tnodes[*order_column_iter];</a>
<a name="ln349">    return sem_context-&gt;Error(tnode,</a>
<a name="ln350">                              &quot;Only clustering key columns can be defined in &quot;</a>
<a name="ln351">                              &quot;CLUSTERING ORDER directive&quot;, ErrorCode::INVALID_TABLE_PROPERTY);</a>
<a name="ln352">  }</a>
<a name="ln353">  return Status::OK();</a>
<a name="ln354">}</a>
<a name="ln355"> </a>
<a name="ln356">Status PTTableProperty::SetTableProperty(yb::TableProperties *table_property) const {</a>
<a name="ln357">  // TODO: Also reject properties that cannot be changed during alter table (like clustering order)</a>
<a name="ln358"> </a>
<a name="ln359">  // Clustering order not handled here.</a>
<a name="ln360">  if (property_type_ == PropertyType::kClusteringOrder) {</a>
<a name="ln361">    return Status::OK();</a>
<a name="ln362">  }</a>
<a name="ln363"> </a>
<a name="ln364">  if (property_type_ == PropertyType::kCoPartitionTable) {</a>
<a name="ln365">    table_property-&gt;SetCopartitionTableId(copartition_table_id());</a>
<a name="ln366">    return Status::OK();</a>
<a name="ln367">  }</a>
<a name="ln368"> </a>
<a name="ln369">  string table_property_name;</a>
<a name="ln370">  ToLowerCase(lhs_-&gt;c_str(), &amp;table_property_name);</a>
<a name="ln371">  auto iterator = kPropertyDataTypes.find(table_property_name);</a>
<a name="ln372">  if (iterator == kPropertyDataTypes.end()) {</a>
<a name="ln373">    return STATUS(InvalidArgument, Substitute(&quot;$0 is not a valid table property&quot;, lhs_-&gt;c_str()));</a>
<a name="ln374">  }</a>
<a name="ln375">  switch (iterator-&gt;second) {</a>
<a name="ln376">    case KVProperty::kDefaultTimeToLive: {</a>
<a name="ln377">      // TTL value is entered by user in seconds, but we store internally in milliseconds.</a>
<a name="ln378">      int64_t val;</a>
<a name="ln379">      if (!GetIntValueFromExpr(rhs_, table_property_name, &amp;val).ok()) {</a>
<a name="ln380">        return STATUS(InvalidArgument, Substitute(&quot;Invalid value for default_time_to_live&quot;));</a>
<a name="ln381">      }</a>
<a name="ln382">      table_property-&gt;SetDefaultTimeToLive(val * MonoTime::kMillisecondsPerSecond);</a>
<a name="ln383">      break;</a>
<a name="ln384">    }</a>
<a name="ln385">    case KVProperty::kBloomFilterFpChance: FALLTHROUGH_INTENDED;</a>
<a name="ln386">    case KVProperty::kComment: FALLTHROUGH_INTENDED;</a>
<a name="ln387">    case KVProperty::kCrcCheckChance: FALLTHROUGH_INTENDED;</a>
<a name="ln388">    case KVProperty::kDclocalReadRepairChance: FALLTHROUGH_INTENDED;</a>
<a name="ln389">    case KVProperty::kGcGraceSeconds: FALLTHROUGH_INTENDED;</a>
<a name="ln390">    case KVProperty::kIndexInterval: FALLTHROUGH_INTENDED;</a>
<a name="ln391">    case KVProperty::kMemtableFlushPeriodInMs: FALLTHROUGH_INTENDED;</a>
<a name="ln392">    case KVProperty::kMinIndexInterval: FALLTHROUGH_INTENDED;</a>
<a name="ln393">    case KVProperty::kMaxIndexInterval: FALLTHROUGH_INTENDED;</a>
<a name="ln394">    case KVProperty::kReadRepairChance: FALLTHROUGH_INTENDED;</a>
<a name="ln395">    case KVProperty::kSpeculativeRetry:</a>
<a name="ln396">      LOG(WARNING) &lt;&lt; &quot;Ignoring table property &quot; &lt;&lt; table_property_name;</a>
<a name="ln397">      break;</a>
<a name="ln398">    case KVProperty::kCaching: FALLTHROUGH_INTENDED;</a>
<a name="ln399">    case KVProperty::kCompaction: FALLTHROUGH_INTENDED;</a>
<a name="ln400">    case KVProperty::kCompression: FALLTHROUGH_INTENDED;</a>
<a name="ln401">    case KVProperty::kTransactions:</a>
<a name="ln402">      LOG(ERROR) &lt;&lt; &quot;Not primitive table property &quot; &lt;&lt; table_property_name;</a>
<a name="ln403">      break;</a>
<a name="ln404">    case KVProperty::kNumTablets:</a>
<a name="ln405">      int64_t val;</a>
<a name="ln406">      if (!GetIntValueFromExpr(rhs_, table_property_name, &amp;val).ok()) {</a>
<a name="ln407">        return STATUS(InvalidArgument, Substitute(&quot;Invalid value for tablets&quot;));</a>
<a name="ln408">      }</a>
<a name="ln409">      table_property-&gt;SetNumTablets(val);</a>
<a name="ln410">      break;</a>
<a name="ln411">  }</a>
<a name="ln412">  return Status::OK();</a>
<a name="ln413">}</a>
<a name="ln414"> </a>
<a name="ln415">TableId PTTableProperty::copartition_table_id() const {</a>
<a name="ln416">  DCHECK_EQ(property_type_, PropertyType::kCoPartitionTable);</a>
<a name="ln417">  return copartition_table_-&gt;id();</a>
<a name="ln418">}</a>
<a name="ln419"> </a>
<a name="ln420">const std::map&lt;string, PTTablePropertyMap::PropertyMapType&gt; PTTablePropertyMap::kPropertyDataTypes</a>
<a name="ln421">    = {</a>
<a name="ln422">    {&quot;caching&quot;, PTTablePropertyMap::PropertyMapType::kCaching},</a>
<a name="ln423">    {&quot;compaction&quot;, PTTablePropertyMap::PropertyMapType::kCompaction},</a>
<a name="ln424">    {&quot;compression&quot;, PTTablePropertyMap::PropertyMapType::kCompression},</a>
<a name="ln425">    {&quot;transactions&quot;, PTTablePropertyMap::PropertyMapType::kTransactions}</a>
<a name="ln426">};</a>
<a name="ln427"> </a>
<a name="ln428">PTTablePropertyMap::PTTablePropertyMap(MemoryContext *memctx,</a>
<a name="ln429">                                       YBLocation::SharedPtr loc)</a>
<a name="ln430">    : PTTableProperty(memctx, loc) {</a>
<a name="ln431">  property_type_ = PropertyType::kTablePropertyMap;</a>
<a name="ln432">  map_elements_ = TreeListNode&lt;PTTableProperty&gt;::MakeShared(memctx, loc);</a>
<a name="ln433">}</a>
<a name="ln434"> </a>
<a name="ln435">PTTablePropertyMap::~PTTablePropertyMap() {</a>
<a name="ln436">}</a>
<a name="ln437"> </a>
<a name="ln438">CHECKED_STATUS PTTablePropertyMap::Analyze(SemContext *sem_context) {</a>
<a name="ln439">  // Verify we have a valid property name in the lhs.</a>
<a name="ln440">  const auto &amp;property_name = lhs_-&gt;c_str();</a>
<a name="ln441">  auto iterator = kPropertyDataTypes.find(property_name);</a>
<a name="ln442">  if (iterator == kPropertyDataTypes.end()) {</a>
<a name="ln443">    if (IsValidProperty(property_name)) {</a>
<a name="ln444">      return sem_context-&gt;Error(this, Substitute(&quot;Invalid map value for property '$0'&quot;,</a>
<a name="ln445">                                                 property_name).c_str(),</a>
<a name="ln446">                                ErrorCode::DATATYPE_MISMATCH);</a>
<a name="ln447">    }</a>
<a name="ln448">    return sem_context-&gt;Error(this, Substitute(&quot;Unknown property '$0'&quot;, property_name).c_str(),</a>
<a name="ln449">                              ErrorCode::INVALID_TABLE_PROPERTY);</a>
<a name="ln450">  }</a>
<a name="ln451"> </a>
<a name="ln452">  const auto &amp;property_type = iterator-&gt;second;</a>
<a name="ln453"> </a>
<a name="ln454">  switch (property_type) {</a>
<a name="ln455">    case PropertyMapType::kCaching:</a>
<a name="ln456">      RETURN_SEM_CONTEXT_ERROR_NOT_OK(AnalyzeCaching());</a>
<a name="ln457">      break;</a>
<a name="ln458">    case PropertyMapType::kCompaction:</a>
<a name="ln459">      RETURN_SEM_CONTEXT_ERROR_NOT_OK(AnalyzeCompaction());</a>
<a name="ln460">      break;</a>
<a name="ln461">    case PropertyMapType::kCompression:</a>
<a name="ln462">      RETURN_SEM_CONTEXT_ERROR_NOT_OK(AnalyzeCompression());</a>
<a name="ln463">      break;</a>
<a name="ln464">    case PropertyMapType::kTransactions:</a>
<a name="ln465">      RETURN_SEM_CONTEXT_ERROR_NOT_OK(AnalyzeTransactions(sem_context));</a>
<a name="ln466">      break;</a>
<a name="ln467">  }</a>
<a name="ln468">  return Status::OK();</a>
<a name="ln469">}</a>
<a name="ln470"> </a>
<a name="ln471">void PTTablePropertyMap::PrintSemanticAnalysisResult(SemContext *sem_context) {</a>
<a name="ln472">  VLOG(3) &lt;&lt; &quot;SEMANTIC ANALYSIS RESULT (&quot; &lt;&lt; *loc_ &lt;&lt; &quot;):\n&quot; &lt;&lt; &quot;Not yet avail&quot;;</a>
<a name="ln473">}</a>
<a name="ln474"> </a>
<a name="ln475">Status PTTablePropertyMap::SetTableProperty(yb::TableProperties *table_property) const {</a>
<a name="ln476">  string table_property_name;</a>
<a name="ln477">  ToLowerCase(lhs_-&gt;c_str(), &amp;table_property_name);</a>
<a name="ln478">  auto iterator = kPropertyDataTypes.find(table_property_name);</a>
<a name="ln479">  if (iterator == kPropertyDataTypes.end()) {</a>
<a name="ln480">    return STATUS(InvalidArgument, Substitute(&quot;$0 is not a valid table property&quot;, lhs_-&gt;c_str()));</a>
<a name="ln481">  }</a>
<a name="ln482">  switch (iterator-&gt;second) {</a>
<a name="ln483">    case PropertyMapType::kCaching: FALLTHROUGH_INTENDED;</a>
<a name="ln484">    case PropertyMapType::kCompaction: FALLTHROUGH_INTENDED;</a>
<a name="ln485">    case PropertyMapType::kCompression:</a>
<a name="ln486">      LOG(WARNING) &lt;&lt; &quot;Ignoring table property &quot; &lt;&lt; table_property_name;</a>
<a name="ln487">      break;</a>
<a name="ln488">    case PropertyMapType::kTransactions:</a>
<a name="ln489">      for (const auto&amp; subproperty : map_elements_-&gt;node_list()) {</a>
<a name="ln490">        string subproperty_name;</a>
<a name="ln491">        ToLowerCase(subproperty-&gt;lhs()-&gt;c_str(), &amp;subproperty_name);</a>
<a name="ln492">        auto iter = Transactions::kSubpropertyDataTypes.find(subproperty_name);</a>
<a name="ln493">        DCHECK(iter != Transactions::kSubpropertyDataTypes.end());</a>
<a name="ln494">        bool bool_val;</a>
<a name="ln495">        string str_val;</a>
<a name="ln496">        switch(iter-&gt;second) {</a>
<a name="ln497">          case Transactions::Subproperty::kEnabled:</a>
<a name="ln498">            RETURN_NOT_OK(GetBoolValueFromExpr(subproperty-&gt;rhs(), subproperty_name, &amp;bool_val));</a>
<a name="ln499">            table_property-&gt;SetTransactional(bool_val);</a>
<a name="ln500">            break;</a>
<a name="ln501">          case Transactions::Subproperty::kConsistencyLevel:</a>
<a name="ln502">            RETURN_NOT_OK(</a>
<a name="ln503">                GetStringValueFromExpr(subproperty-&gt;rhs(), true, subproperty_name, &amp;str_val));</a>
<a name="ln504">            if (str_val == Transactions::kConsistencyLevelUserEnforced) {</a>
<a name="ln505">              table_property-&gt;SetConsistencyLevel(YBConsistencyLevel::USER_ENFORCED);</a>
<a name="ln506">            }</a>
<a name="ln507">            break;</a>
<a name="ln508">        }</a>
<a name="ln509">      }</a>
<a name="ln510">      break;</a>
<a name="ln511">  }</a>
<a name="ln512">  return Status::OK();</a>
<a name="ln513">}</a>
<a name="ln514"> </a>
<a name="ln515">Status PTTablePropertyMap::AnalyzeCompaction() {</a>
<a name="ln516">  vector&lt;string&gt; invalid_subproperties;</a>
<a name="ln517">  vector&lt;PTTableProperty::SharedPtr&gt; subproperties;</a>
<a name="ln518">  auto class_subproperties_iter = Compaction::kClassSubproperties.end();</a>
<a name="ln519">  string class_name;</a>
<a name="ln520">  for (PTTableProperty::SharedPtr tnode : map_elements_-&gt;node_list()) {</a>
<a name="ln521">    string subproperty_name;</a>
<a name="ln522">    ToLowerCase(tnode-&gt;lhs()-&gt;c_str(), &amp;subproperty_name);</a>
<a name="ln523">    // 'class' is a special compaction subproperty. It tell us which other subproperties are valid.</a>
<a name="ln524">    // We intentionally don't check if class_name is non_empty. If several 'class' subproperties</a>
<a name="ln525">    // have been set, we use the last one.</a>
<a name="ln526">    if (subproperty_name == &quot;class&quot;) {</a>
<a name="ln527">      if (tnode-&gt;rhs()-&gt;ql_type_id() != DataType::STRING) {</a>
<a name="ln528">        return STATUS(InvalidArgument,</a>
<a name="ln529">                      &quot;Property value for property 'class' has and invalid data type&quot;);</a>
<a name="ln530">      }</a>
<a name="ln531">      class_name = std::dynamic_pointer_cast&lt;PTConstText&gt;(tnode-&gt;rhs())-&gt;Eval()-&gt;c_str();</a>
<a name="ln532">      if (class_name.find('.') == string::npos) {</a>
<a name="ln533">        if (class_name.length() &lt; Compaction::kClassPrefixLen ||</a>
<a name="ln534">            class_name.substr(Compaction::kClassPrefixLen) !=</a>
<a name="ln535">            Compaction::kClassPrefix) {</a>
<a name="ln536">          LOG(INFO) &lt;&lt; &quot;Inserting prefix into class name&quot;;</a>
<a name="ln537">          class_name.insert(0, Compaction::kClassPrefix);</a>
<a name="ln538">        }</a>
<a name="ln539">      }</a>
<a name="ln540">      class_subproperties_iter = Compaction::kClassSubproperties.find(class_name);</a>
<a name="ln541">      if (class_subproperties_iter == Compaction::kClassSubproperties.end()) {</a>
<a name="ln542">        return STATUS(InvalidArgument,</a>
<a name="ln543">                      Substitute(&quot;Unable to find compaction strategy class '$0'&quot;, class_name));</a>
<a name="ln544">      }</a>
<a name="ln545">      continue;</a>
<a name="ln546">    }</a>
<a name="ln547">    auto iter = Compaction::kSubpropertyDataTypes.find(subproperty_name);</a>
<a name="ln548">    if (iter == Compaction::kSubpropertyDataTypes.end()) {</a>
<a name="ln549">      invalid_subproperties.push_back(subproperty_name);</a>
<a name="ln550">    } else {</a>
<a name="ln551">      // iter-&gt;second is of type std::pair&lt;CompactionSubproperty, DataType&gt;.</a>
<a name="ln552">      subproperties.push_back(tnode);</a>
<a name="ln553">    }</a>
<a name="ln554">  }</a>
<a name="ln555">  LOG(INFO) &lt;&lt; &quot;AnalyzeCompaction 2&quot;;</a>
<a name="ln556"> </a>
<a name="ln557">  if (class_subproperties_iter == Compaction::kClassSubproperties.end()) {</a>
<a name="ln558">    LOG(INFO) &lt;&lt; &quot;AnalyzeCompaction 3&quot;;</a>
<a name="ln559">    return STATUS(InvalidArgument, &quot;Missing sub-option 'class' for the 'compaction' option&quot;);</a>
<a name="ln560">  }</a>
<a name="ln561"> </a>
<a name="ln562">  // Verify that the types for subproperties values are valid. Also verify that elements in</a>
<a name="ln563">  // subproperties are valid for the given class.</a>
<a name="ln564">  auto const&amp; valid_subproperties_for_class = class_subproperties_iter-&gt;second;</a>
<a name="ln565">  long double bucket_high = 1.5, bucket_low = 0.5;</a>
<a name="ln566">  int64_t max_threshold = 32, min_threshold = 4;</a>
<a name="ln567">  for (const auto&amp; subproperty : subproperties) {</a>
<a name="ln568">    string subproperty_name;</a>
<a name="ln569">    ToLowerCase(subproperty-&gt;lhs()-&gt;c_str(), &amp;subproperty_name);</a>
<a name="ln570">    auto subproperty_enum = Compaction::kSubpropertyDataTypes.at(subproperty_name);</a>
<a name="ln571">    if (valid_subproperties_for_class.find(subproperty_enum) ==</a>
<a name="ln572">        valid_subproperties_for_class.end()) {</a>
<a name="ln573">      invalid_subproperties.push_back(subproperty_name);</a>
<a name="ln574">      continue;</a>
<a name="ln575">    }</a>
<a name="ln576">    // Even if we already know that we have a subproperty that is not valid for a given class,</a>
<a name="ln577">    // Cassandra will first complain about invalid values for a valid subproperty.</a>
<a name="ln578">    int64_t int_val;</a>
<a name="ln579">    long double double_val;</a>
<a name="ln580">    bool bool_val;</a>
<a name="ln581">    string str_val;</a>
<a name="ln582">    switch(subproperty_enum) {</a>
<a name="ln583">      case Compaction::Subproperty::kBaseTimeSeconds: FALLTHROUGH_INTENDED;</a>
<a name="ln584">      case Compaction::Subproperty::kCompactionWindowSize: FALLTHROUGH_INTENDED;</a>
<a name="ln585">      case Compaction::Subproperty::kSstableSizeInMb: FALLTHROUGH_INTENDED;</a>
<a name="ln586">      case Compaction::Subproperty::kTombstoneCompactionInterval:</a>
<a name="ln587">        RETURN_NOT_OK(GetIntValueFromExpr(subproperty-&gt;rhs(), subproperty_name, &amp;int_val));</a>
<a name="ln588">        if (int_val &lt;= 0) {</a>
<a name="ln589">          return STATUS(InvalidArgument, Substitute(&quot;$0 must be greater than 0, but was $1&quot;,</a>
<a name="ln590">                                                    subproperty_name, std::to_string(int_val)));</a>
<a name="ln591">        }</a>
<a name="ln592">        break;</a>
<a name="ln593">      case Compaction::Subproperty::kBucketHigh:</a>
<a name="ln594">        RETURN_NOT_OK(GetDoubleValueFromExpr(subproperty-&gt;rhs(), subproperty_name, &amp;bucket_high));</a>
<a name="ln595">        break;</a>
<a name="ln596">      case Compaction::Subproperty::kBucketLow:</a>
<a name="ln597">        RETURN_NOT_OK(GetDoubleValueFromExpr(subproperty-&gt;rhs(), subproperty_name, &amp;bucket_low));</a>
<a name="ln598">        break;</a>
<a name="ln599">      case Compaction::Subproperty::kClass:</a>
<a name="ln600">        LOG(FATAL) &lt;&lt; &quot;Invalid subproperty&quot;;</a>
<a name="ln601">      case Compaction::Subproperty::kCompactionWindowUnit:</a>
<a name="ln602">        RETURN_NOT_OK(GetStringValueFromExpr(subproperty-&gt;rhs(), true, subproperty_name, &amp;str_val));</a>
<a name="ln603">        if (Compaction::kWindowUnits.find(str_val) ==</a>
<a name="ln604">            Compaction::kWindowUnits.end()) {</a>
<a name="ln605">          return STATUS(InvalidArgument,</a>
<a name="ln606">                        Substitute(&quot;$0 is not valid for '$1'&quot;, str_val, subproperty_name));</a>
<a name="ln607">        }</a>
<a name="ln608">        break;</a>
<a name="ln609">      case Compaction::Subproperty::kEnabled: FALLTHROUGH_INTENDED;</a>
<a name="ln610">      case Compaction::Subproperty::kLogAll: FALLTHROUGH_INTENDED;</a>
<a name="ln611">      case Compaction::Subproperty::kOnlyPurgeRepairedTombstones: FALLTHROUGH_INTENDED;</a>
<a name="ln612">      case Compaction::Subproperty::kUncheckedTombstoneCompaction:</a>
<a name="ln613">        RETURN_NOT_OK(GetBoolValueFromExpr(subproperty-&gt;rhs(), subproperty_name, &amp;bool_val));</a>
<a name="ln614">        break;</a>
<a name="ln615">      case Compaction::Subproperty::kMaxSstableAgeDays:</a>
<a name="ln616">        RETURN_NOT_OK(GetDoubleValueFromExpr(subproperty-&gt;rhs(), subproperty_name, &amp;double_val));</a>
<a name="ln617">        if (double_val &lt; 0) {</a>
<a name="ln618">          return STATUS(InvalidArgument, Substitute(&quot;$0 must be non-negative, but was $1&quot;,</a>
<a name="ln619">                                                    subproperty_name, std::to_string(double_val)));</a>
<a name="ln620">        }</a>
<a name="ln621">        break;;</a>
<a name="ln622">      case Compaction::Subproperty::kMaxThreshold:</a>
<a name="ln623">        RETURN_NOT_OK(GetIntValueFromExpr(subproperty-&gt;rhs(), subproperty_name, &amp;max_threshold));</a>
<a name="ln624">        break;</a>
<a name="ln625">      case Compaction::Subproperty::kMaxWindowSizeSeconds: FALLTHROUGH_INTENDED;</a>
<a name="ln626">      case Compaction::Subproperty::kMinSstableSize:</a>
<a name="ln627">        RETURN_NOT_OK(GetIntValueFromExpr(subproperty-&gt;rhs(), subproperty_name, &amp;int_val));</a>
<a name="ln628">        if (int_val &lt; 0) {</a>
<a name="ln629">          return STATUS(InvalidArgument, Substitute(&quot;$0 must be non-negative, but was $1&quot;,</a>
<a name="ln630">                                                    subproperty_name, std::to_string(int_val)));</a>
<a name="ln631">        }</a>
<a name="ln632">        break;</a>
<a name="ln633">      case Compaction::Subproperty::kMinThreshold:</a>
<a name="ln634">        RETURN_NOT_OK(GetIntValueFromExpr(subproperty-&gt;rhs(), subproperty_name, &amp;min_threshold));</a>
<a name="ln635">        if (min_threshold &lt;= 0) {</a>
<a name="ln636">          return STATUS(InvalidArgument,</a>
<a name="ln637">                        &quot;Disabling compaction by setting compaction thresholds to 0 has been &quot;</a>
<a name="ln638">                            &quot;removed, set the compaction option 'enabled' to false instead&quot;);</a>
<a name="ln639">        } else if (min_threshold &lt; 2) {</a>
<a name="ln640">          return STATUS(InvalidArgument,</a>
<a name="ln641">                        Substitute(&quot;Min compaction threshold cannot be less than 2 (got $0)&quot;,</a>
<a name="ln642">                                   min_threshold));</a>
<a name="ln643">        }</a>
<a name="ln644">        break;</a>
<a name="ln645">      case Compaction::Subproperty::kTimestampResolution:</a>
<a name="ln646">        RETURN_NOT_OK(GetStringValueFromExpr(subproperty-&gt;rhs(), true, subproperty_name, &amp;str_val));</a>
<a name="ln647">        if (Compaction::kTimestampResolutionUnits.find(str_val) ==</a>
<a name="ln648">            Compaction::kTimestampResolutionUnits.end()) {</a>
<a name="ln649">          return STATUS(InvalidArgument,</a>
<a name="ln650">                        Substitute(&quot;$0 is not valid for '$1'&quot;, str_val, subproperty_name));</a>
<a name="ln651">        }</a>
<a name="ln652">        break;</a>
<a name="ln653">      case Compaction::Subproperty::kTombstoneThreshold:</a>
<a name="ln654">        RETURN_NOT_OK(GetDoubleValueFromExpr(subproperty-&gt;rhs(), subproperty_name, &amp;double_val));</a>
<a name="ln655">        if (double_val &lt;= 0) {</a>
<a name="ln656">          return STATUS(InvalidArgument, Substitute(&quot;$0 must be greater than 0, but was $1&quot;,</a>
<a name="ln657">                                                    subproperty_name, std::to_string(double_val)));</a>
<a name="ln658">        }</a>
<a name="ln659">        break;</a>
<a name="ln660">    }</a>
<a name="ln661">  }</a>
<a name="ln662"> </a>
<a name="ln663">  if (bucket_high &lt;= bucket_low) {</a>
<a name="ln664">    return STATUS(InvalidArgument, Substitute(&quot;'bucket_high' value ($0) is less than or equal to &quot;</a>
<a name="ln665">        &quot;'bucket_low' value ($1)&quot;, std::to_string(bucket_high), std::to_string(bucket_low)));</a>
<a name="ln666">  }</a>
<a name="ln667"> </a>
<a name="ln668">  if (max_threshold &lt;= min_threshold) {</a>
<a name="ln669">    return STATUS(InvalidArgument, Substitute(&quot;'max_threshold' value ($0) is less than or equal to &quot;</a>
<a name="ln670">        &quot;'min_threshold' value ($1)&quot;, std::to_string(max_threshold),</a>
<a name="ln671">        std::to_string(min_threshold)));</a>
<a name="ln672">  }</a>
<a name="ln673"> </a>
<a name="ln674">  if (!invalid_subproperties.empty()) {</a>
<a name="ln675">    string list = &quot;[&quot;;</a>
<a name="ln676">    for (auto i = 0; i &lt; invalid_subproperties.size() - 1; i++) {</a>
<a name="ln677">      list += (invalid_subproperties[i] + &quot;, &quot;);</a>
<a name="ln678">    }</a>
<a name="ln679">    list += (invalid_subproperties.back() + &quot;]&quot;);</a>
<a name="ln680">    return STATUS(InvalidArgument,</a>
<a name="ln681">                  Substitute(&quot;Properties specified $0 are not understood by $1&quot;, list, class_name));</a>
<a name="ln682">  }</a>
<a name="ln683">  return Status::OK();</a>
<a name="ln684">}</a>
<a name="ln685"> </a>
<a name="ln686">Status PTTablePropertyMap::AnalyzeCaching() {</a>
<a name="ln687">  string str_val;</a>
<a name="ln688">  int64_t int_val;</a>
<a name="ln689">  for (const auto&amp; subproperty : map_elements_-&gt;node_list()) {</a>
<a name="ln690">    string subproperty_name;</a>
<a name="ln691">    ToLowerCase(subproperty-&gt;lhs()-&gt;c_str(), &amp;subproperty_name);</a>
<a name="ln692">    if (subproperty_name == common::kCachingKeys) {</a>
<a name="ln693">      // First try to read the value as a string.</a>
<a name="ln694">      RETURN_NOT_OK(GetStringValueFromExpr(subproperty-&gt;rhs(), true, subproperty_name, &amp;str_val));</a>
<a name="ln695">      if (common::IsValidCachingKeysString(str_val)) {</a>
<a name="ln696">        continue;</a>
<a name="ln697">      }</a>
<a name="ln698">      return STATUS(InvalidArgument, Substitute(&quot;Invalid value for caching sub-option '$0': only &quot;</a>
<a name="ln699">          &quot;'$1' and '$2' are allowed&quot;, common::kCachingKeys, common::kCachingAll,</a>
<a name="ln700">          common::kCachingNone));</a>
<a name="ln701">    } else if (subproperty_name == common::kCachingRowsPerPartition) {</a>
<a name="ln702">      if (GetStringValueFromExpr(subproperty-&gt;rhs(), true, subproperty_name, &amp;str_val).ok()) {</a>
<a name="ln703">        if (common::IsValidCachingRowsPerPartitionString(str_val)) {</a>
<a name="ln704">          continue;</a>
<a name="ln705">        }</a>
<a name="ln706">      }</a>
<a name="ln707">      if (GetIntValueFromExpr(subproperty-&gt;rhs(), subproperty_name, &amp;int_val).ok()) {</a>
<a name="ln708">        if (common::IsValidCachingRowsPerPartitionInt(int_val)) {</a>
<a name="ln709">          continue;</a>
<a name="ln710">        }</a>
<a name="ln711">      }</a>
<a name="ln712">      return STATUS(InvalidArgument, Substitute(&quot;Invalid value for caching sub-option '$0': only &quot;</a>
<a name="ln713">          &quot;'$1', '$2' and integer values are allowed&quot;, common::kCachingRowsPerPartition,</a>
<a name="ln714">          common::kCachingAll, common::kCachingNone));</a>
<a name="ln715">    }</a>
<a name="ln716">    return STATUS(InvalidArgument, Substitute(&quot;Invalid caching sub-options $0: only '$1' and &quot;</a>
<a name="ln717">        &quot;'$2' are allowed&quot;, subproperty_name, common::kCachingKeys,</a>
<a name="ln718">        common::kCachingRowsPerPartition));</a>
<a name="ln719">  }</a>
<a name="ln720">  return Status::OK();</a>
<a name="ln721">}</a>
<a name="ln722"> </a>
<a name="ln723">Status PTTablePropertyMap::AnalyzeCompression() {</a>
<a name="ln724">  string class_name, sstable_compression;</a>
<a name="ln725">  bool has_sstable_compression = false;</a>
<a name="ln726">  // 'class' and 'sstable_compression' are treated differently.</a>
<a name="ln727">  for (const auto&amp; subproperty : map_elements_-&gt;node_list()) {</a>
<a name="ln728">    string subproperty_name;</a>
<a name="ln729">    ToLowerCase(subproperty-&gt;lhs()-&gt;c_str(), &amp;subproperty_name);</a>
<a name="ln730">    if (subproperty_name == &quot;class&quot;) {</a>
<a name="ln731">      RETURN_NOT_OK(GetStringValueFromExpr(subproperty-&gt;rhs(), true, subproperty_name,</a>
<a name="ln732">                                           &amp;class_name));</a>
<a name="ln733">      if (class_name.empty()) {</a>
<a name="ln734">        return STATUS(InvalidArgument,</a>
<a name="ln735">            &quot;The 'class' option must not be empty. To disable compression use 'enabled' : false&quot;);</a>
<a name="ln736">      }</a>
<a name="ln737">    } else if (subproperty_name == &quot;sstable_compression&quot;) {</a>
<a name="ln738">      RETURN_NOT_OK(GetStringValueFromExpr(subproperty-&gt;rhs(), true, subproperty_name,</a>
<a name="ln739">                                           &amp;sstable_compression));</a>
<a name="ln740">      has_sstable_compression = true;</a>
<a name="ln741">    }</a>
<a name="ln742">  }</a>
<a name="ln743">  if (!class_name.empty() &amp;&amp; has_sstable_compression) {</a>
<a name="ln744">    return STATUS(InvalidArgument, &quot;The 'sstable_compression' option must not be used if the &quot;</a>
<a name="ln745">        &quot;compression algorithm is already specified by the 'class' option&quot;);</a>
<a name="ln746">  }</a>
<a name="ln747">  if (class_name.empty() &amp;&amp; !has_sstable_compression) {</a>
<a name="ln748">    return STATUS(InvalidArgument, &quot;Missing sub-option 'class' for the 'compression' option&quot;);</a>
<a name="ln749">  }</a>
<a name="ln750"> </a>
<a name="ln751">  for (const auto&amp; subproperty : map_elements_-&gt;node_list()) {</a>
<a name="ln752">    string subproperty_name;</a>
<a name="ln753">    ToLowerCase(subproperty-&gt;lhs()-&gt;c_str(), &amp;subproperty_name);</a>
<a name="ln754">    auto iter = Compression::kSubpropertyDataTypes.find(subproperty_name);</a>
<a name="ln755">    if (iter == Compression::kSubpropertyDataTypes.end()) {</a>
<a name="ln756">      return STATUS(InvalidArgument, Substitute(&quot;Unknown compression option $0&quot;, subproperty_name));</a>
<a name="ln757">    }</a>
<a name="ln758"> </a>
<a name="ln759">    int64_t int_val;</a>
<a name="ln760">    long double double_val;</a>
<a name="ln761">    bool bool_val;</a>
<a name="ln762">    switch(iter-&gt;second) {</a>
<a name="ln763">      case Compression::Subproperty::kChunkLengthKb:</a>
<a name="ln764">        RETURN_NOT_OK(GetIntValueFromExpr(subproperty-&gt;rhs(), subproperty_name, &amp;int_val));</a>
<a name="ln765">        if (int_val &gt; std::numeric_limits&lt;int32_t&gt;::max() / 1024) {</a>
<a name="ln766">          return STATUS(InvalidArgument, Substitute(&quot;Value of $0 is too large ($1)&quot;,</a>
<a name="ln767">                                                    subproperty_name, int_val));</a>
<a name="ln768">        }</a>
<a name="ln769">        break;</a>
<a name="ln770">      case Compression::Subproperty::kClass:</a>
<a name="ln771">        break;</a>
<a name="ln772">      case Compression::Subproperty::kCrcCheckChance:</a>
<a name="ln773">        RETURN_NOT_OK(GetDoubleValueFromExpr(subproperty-&gt;rhs(), subproperty_name, &amp;double_val));</a>
<a name="ln774">        if (double_val &lt; 0.0 || double_val &gt; 1.0) {</a>
<a name="ln775">          return STATUS(InvalidArgument, Substitute(&quot;$0 should be between 0.0 and 1.0&quot;,</a>
<a name="ln776">                                                    subproperty_name));</a>
<a name="ln777">        }</a>
<a name="ln778">        break;</a>
<a name="ln779">      case Compression::Subproperty::kEnabled:</a>
<a name="ln780">        RETURN_NOT_OK(GetBoolValueFromExpr(subproperty-&gt;rhs(), subproperty_name, &amp;bool_val));</a>
<a name="ln781">        break;</a>
<a name="ln782">      case Compression::Subproperty::kSstableCompression:</a>
<a name="ln783">        break;</a>
<a name="ln784">    }</a>
<a name="ln785">  }</a>
<a name="ln786">  return Status::OK();</a>
<a name="ln787">}</a>
<a name="ln788"> </a>
<a name="ln789">Status PTTablePropertyMap::AnalyzeTransactions(SemContext *sem_context) {</a>
<a name="ln790">  for (const auto&amp; subproperty : map_elements_-&gt;node_list()) {</a>
<a name="ln791">    string subproperty_name;</a>
<a name="ln792">    ToLowerCase(subproperty-&gt;lhs()-&gt;c_str(), &amp;subproperty_name);</a>
<a name="ln793">    auto iter = Transactions::kSubpropertyDataTypes.find(subproperty_name);</a>
<a name="ln794">    if (iter == Transactions::kSubpropertyDataTypes.end()) {</a>
<a name="ln795">      return STATUS(InvalidArgument, Substitute(&quot;Unknown transactions option $0&quot;,</a>
<a name="ln796">                                                subproperty_name));</a>
<a name="ln797">    }</a>
<a name="ln798"> </a>
<a name="ln799">    bool bool_val;</a>
<a name="ln800">    string str_val;</a>
<a name="ln801">    switch(iter-&gt;second) {</a>
<a name="ln802">      case Transactions::Subproperty::kEnabled:</a>
<a name="ln803">        RETURN_NOT_OK(GetBoolValueFromExpr(subproperty-&gt;rhs(), subproperty_name, &amp;bool_val));</a>
<a name="ln804">        break;</a>
<a name="ln805">      case Transactions::Subproperty::kConsistencyLevel:</a>
<a name="ln806">        if (sem_context-&gt;current_create_table_stmt()-&gt;opcode() != TreeNodeOpcode::kPTCreateIndex) {</a>
<a name="ln807">          return STATUS(InvalidArgument,</a>
<a name="ln808">                        Substitute(&quot;Unknown property '$0'&quot;, subproperty_name).c_str());</a>
<a name="ln809">        }</a>
<a name="ln810">        RETURN_NOT_OK(GetStringValueFromExpr(subproperty-&gt;rhs(), true, subproperty_name, &amp;str_val));</a>
<a name="ln811">        if (str_val != Transactions::kConsistencyLevelUserEnforced) {</a>
<a name="ln812">          return STATUS(InvalidArgument,</a>
<a name="ln813">                        Substitute(&quot;Invalid value for property '$0'&quot;, subproperty_name).c_str());</a>
<a name="ln814">        }</a>
<a name="ln815">        break;</a>
<a name="ln816">    }</a>
<a name="ln817">  }</a>
<a name="ln818">  return Status::OK();</a>
<a name="ln819">}</a>
<a name="ln820"> </a>
<a name="ln821">const std::map&lt;std::string, Compression::Subproperty&gt; Compression::kSubpropertyDataTypes = {</a>
<a name="ln822">    {&quot;chunk_length_kb&quot;,     Compression::Subproperty::kChunkLengthKb},</a>
<a name="ln823">    {&quot;chunk_length_in_kb&quot;,  Compression::Subproperty::kChunkLengthKb},</a>
<a name="ln824">    {&quot;class&quot;,               Compression::Subproperty::kClass},</a>
<a name="ln825">    {&quot;crc_check_chance&quot;,    Compression::Subproperty::kCrcCheckChance},</a>
<a name="ln826">    {&quot;enabled&quot;,             Compression::Subproperty::kEnabled},</a>
<a name="ln827">    {&quot;sstable_compression&quot;, Compression::Subproperty::kSstableCompression}</a>
<a name="ln828">};</a>
<a name="ln829"> </a>
<a name="ln830">const std::map&lt;std::string, Compaction::Subproperty&gt; Compaction::kSubpropertyDataTypes = {</a>
<a name="ln831">    {&quot;base_time_seconds&quot;, Compaction::Subproperty::kBaseTimeSeconds},</a>
<a name="ln832">    {&quot;bucket_high&quot;, Compaction::Subproperty::kBucketHigh},</a>
<a name="ln833">    {&quot;bucket_low&quot;, Compaction::Subproperty::kBucketLow},</a>
<a name="ln834">    {&quot;class&quot;, Compaction::Subproperty::kClass},</a>
<a name="ln835">    {&quot;compaction_window_size&quot;, Compaction::Subproperty::kCompactionWindowSize},</a>
<a name="ln836">    {&quot;compaction_window_unit&quot;, Compaction::Subproperty::kCompactionWindowUnit},</a>
<a name="ln837">    {&quot;enabled&quot;, Compaction::Subproperty::kEnabled},</a>
<a name="ln838">    {&quot;log_all&quot;, Compaction::Subproperty::kLogAll},</a>
<a name="ln839">    {&quot;max_sstable_age_days&quot;, Compaction::Subproperty::kMaxSstableAgeDays},</a>
<a name="ln840">    {&quot;max_threshold&quot;, Compaction::Subproperty::kMaxThreshold},</a>
<a name="ln841">    {&quot;max_window_size_seconds&quot;, Compaction::Subproperty::kMaxWindowSizeSeconds},</a>
<a name="ln842">    {&quot;min_sstable_size&quot;, Compaction::Subproperty::kMinSstableSize},</a>
<a name="ln843">    {&quot;min_threshold&quot;, Compaction::Subproperty::kMinThreshold},</a>
<a name="ln844">    {&quot;only_purge_repaired_tombstones&quot;, Compaction::Subproperty::kOnlyPurgeRepairedTombstones},</a>
<a name="ln845">    {&quot;sstable_size_in_mb&quot;, Compaction::Subproperty::kSstableSizeInMb},</a>
<a name="ln846">    {&quot;timestamp_resolution&quot;, Compaction::Subproperty::kTimestampResolution},</a>
<a name="ln847">    {&quot;tombstone_compaction_interval&quot;, Compaction::Subproperty::kTombstoneCompactionInterval},</a>
<a name="ln848">    {&quot;tombstone_threshold&quot;, Compaction::Subproperty::kTombstoneThreshold},</a>
<a name="ln849">    {&quot;unchecked_tombstone_compaction&quot;, Compaction::Subproperty::kUncheckedTombstoneCompaction}</a>
<a name="ln850">};</a>
<a name="ln851"> </a>
<a name="ln852">const std::map&lt;std::string, Transactions::Subproperty&gt;</a>
<a name="ln853">Transactions::kSubpropertyDataTypes = {</a>
<a name="ln854">    {&quot;enabled&quot;, Transactions::Subproperty::kEnabled},</a>
<a name="ln855">    {&quot;consistency_level&quot;, Transactions::Subproperty::kConsistencyLevel}</a>
<a name="ln856">};</a>
<a name="ln857"> </a>
<a name="ln858">const std::map&lt;std::string, std::set&lt;Compaction::Subproperty&gt;&gt; Compaction::kClassSubproperties = {</a>
<a name="ln859">    {&quot;org.apache.cassandra.db.compaction.SizeTieredCompactionStrategy&quot;,</a>
<a name="ln860">        {</a>
<a name="ln861">            Compaction::Subproperty::kBucketHigh,</a>
<a name="ln862">            Compaction::Subproperty::kBucketLow,</a>
<a name="ln863">            Compaction::Subproperty::kEnabled,</a>
<a name="ln864">            Compaction::Subproperty::kLogAll,</a>
<a name="ln865">            Compaction::Subproperty::kMaxThreshold,</a>
<a name="ln866">            Compaction::Subproperty::kMinThreshold,</a>
<a name="ln867">            Compaction::Subproperty::kMinSstableSize,</a>
<a name="ln868">            Compaction::Subproperty::kOnlyPurgeRepairedTombstones,</a>
<a name="ln869">            Compaction::Subproperty::kTombstoneCompactionInterval,</a>
<a name="ln870">            Compaction::Subproperty::kTombstoneThreshold,</a>
<a name="ln871">            Compaction::Subproperty::kUncheckedTombstoneCompaction</a>
<a name="ln872">        }</a>
<a name="ln873">    },</a>
<a name="ln874">    {&quot;org.apache.cassandra.db.compaction.DateTieredCompactionStrategy&quot;,</a>
<a name="ln875">        {</a>
<a name="ln876">            Compaction::Subproperty::kBaseTimeSeconds,</a>
<a name="ln877">            Compaction::Subproperty::kEnabled,</a>
<a name="ln878">            Compaction::Subproperty::kLogAll,</a>
<a name="ln879">            Compaction::Subproperty::kMaxSstableAgeDays,</a>
<a name="ln880">            Compaction::Subproperty::kMaxWindowSizeSeconds,</a>
<a name="ln881">            Compaction::Subproperty::kMaxThreshold,</a>
<a name="ln882">            Compaction::Subproperty::kMinThreshold,</a>
<a name="ln883">            Compaction::Subproperty::kTimestampResolution,</a>
<a name="ln884">            Compaction::Subproperty::kTombstoneCompactionInterval,</a>
<a name="ln885">            Compaction::Subproperty::kTombstoneThreshold,</a>
<a name="ln886">            Compaction::Subproperty::kUncheckedTombstoneCompaction</a>
<a name="ln887">        }</a>
<a name="ln888">    },</a>
<a name="ln889">    {&quot;org.apache.cassandra.db.compaction.LeveledCompactionStrategy&quot;,</a>
<a name="ln890">        {</a>
<a name="ln891">            Compaction::Subproperty::kEnabled,</a>
<a name="ln892">            Compaction::Subproperty::kLogAll,</a>
<a name="ln893">            Compaction::Subproperty::kSstableSizeInMb,</a>
<a name="ln894">            Compaction::Subproperty::kTombstoneCompactionInterval,</a>
<a name="ln895">            Compaction::Subproperty::kTombstoneThreshold,</a>
<a name="ln896">            Compaction::Subproperty::kUncheckedTombstoneCompaction</a>
<a name="ln897">        }</a>
<a name="ln898">    },</a>
<a name="ln899">    {&quot;org.apache.cassandra.db.compaction.TimeWindowCompactionStrategy&quot;,</a>
<a name="ln900">        {</a>
<a name="ln901">            Compaction::Subproperty::kCompactionWindowUnit,</a>
<a name="ln902">            Compaction::Subproperty::kCompactionWindowSize,</a>
<a name="ln903">            Compaction::Subproperty::kLogAll</a>
<a name="ln904">        }</a>
<a name="ln905">    }</a>
<a name="ln906">};</a>
<a name="ln907"> </a>
<a name="ln908">std::set&lt;std::string&gt; Compaction::kWindowUnits = {&quot;minutes&quot;, &quot;hours&quot;, &quot;days&quot;};</a>
<a name="ln909">std::set&lt;std::string&gt; Compaction::kTimestampResolutionUnits = {</a>
<a name="ln910">    &quot;days&quot;, &quot;hours&quot;, &quot;microseconds&quot;, &quot;milliseconds&quot;, &quot;minutes&quot;, &quot;nanoseconds&quot;, &quot;seconds&quot;</a>
<a name="ln911">};</a>
<a name="ln912"> </a>
<a name="ln913"> </a>
<a name="ln914">} // namespace ql</a>
<a name="ln915">} // namespace yb</a>

</code></pre>
<div class="balloon" rel="274"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="472"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="493"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="54"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: direction_.</p></div>
<div class="balloon" rel="68"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: direction_.</p></div>
<div class="balloon" rel="74"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: direction_, property_type_.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
