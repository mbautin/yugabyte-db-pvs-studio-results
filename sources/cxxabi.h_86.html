
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>cxxabi.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// ABI Support -*- C++ -*-</a>
<a name="ln2"> </a>
<a name="ln3">// Copyright (C) 2000-2018 Free Software Foundation, Inc.</a>
<a name="ln4">//</a>
<a name="ln5">// This file is part of GCC.</a>
<a name="ln6">//</a>
<a name="ln7">// GCC is free software; you can redistribute it and/or modify</a>
<a name="ln8">// it under the terms of the GNU General Public License as published by</a>
<a name="ln9">// the Free Software Foundation; either version 3, or (at your option)</a>
<a name="ln10">// any later version.</a>
<a name="ln11">//</a>
<a name="ln12">// GCC is distributed in the hope that it will be useful,</a>
<a name="ln13">// but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln14">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln15">// GNU General Public License for more details.</a>
<a name="ln16">//</a>
<a name="ln17">// Under Section 7 of GPL version 3, you are granted additional</a>
<a name="ln18">// permissions described in the GCC Runtime Library Exception, version</a>
<a name="ln19">// 3.1, as published by the Free Software Foundation.</a>
<a name="ln20"> </a>
<a name="ln21">// You should have received a copy of the GNU General Public License and</a>
<a name="ln22">// a copy of the GCC Runtime Library Exception along with this program;</a>
<a name="ln23">// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see</a>
<a name="ln24">// &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln25"> </a>
<a name="ln26">// Written by Nathan Sidwell, Codesourcery LLC, &lt;nathan@codesourcery.com&gt;</a>
<a name="ln27"> </a>
<a name="ln28">/* This file declares the new abi entry points into the runtime. It is not</a>
<a name="ln29">   normally necessary for user programs to include this header, or use the</a>
<a name="ln30">   entry points directly. However, this header is available should that be</a>
<a name="ln31">   needed.</a>
<a name="ln32"> </a>
<a name="ln33">   Some of the entry points are intended for both C and C++, thus this header</a>
<a name="ln34">   is includable from both C and C++. Though the C++ specific parts are not</a>
<a name="ln35">   available in C, naturally enough.  */</a>
<a name="ln36"> </a>
<a name="ln37">/** @file cxxabi.h</a>
<a name="ln38"> *  The header provides an interface to the C++ ABI.</a>
<a name="ln39"> */</a>
<a name="ln40"> </a>
<a name="ln41">#ifndef _CXXABI_H</a>
<a name="ln42">#define _CXXABI_H 1</a>
<a name="ln43"> </a>
<a name="ln44">#pragma GCC system_header</a>
<a name="ln45"> </a>
<a name="ln46">#pragma GCC visibility push(default)</a>
<a name="ln47"> </a>
<a name="ln48">#include &lt;stddef.h&gt;</a>
<a name="ln49">#include &lt;bits/c++config.h&gt;</a>
<a name="ln50">#include &lt;bits/cxxabi_tweaks.h&gt;</a>
<a name="ln51">#include &lt;bits/cxxabi_forced.h&gt;</a>
<a name="ln52">#include &lt;bits/cxxabi_init_exception.h&gt;</a>
<a name="ln53"> </a>
<a name="ln54">#ifdef __cplusplus</a>
<a name="ln55">namespace __cxxabiv1</a>
<a name="ln56">{</a>
<a name="ln57">  extern &quot;C&quot;</a>
<a name="ln58">  {</a>
<a name="ln59">#endif</a>
<a name="ln60"> </a>
<a name="ln61">  typedef __cxa_cdtor_return_type (*__cxa_cdtor_type)(void *);</a>
<a name="ln62"> </a>
<a name="ln63">  // Allocate array.</a>
<a name="ln64">  void*</a>
<a name="ln65">  __cxa_vec_new(size_t __element_count, size_t __element_size,</a>
<a name="ln66">		size_t __padding_size, __cxa_cdtor_type __constructor,</a>
<a name="ln67">		__cxa_cdtor_type __destructor);</a>
<a name="ln68"> </a>
<a name="ln69">  void*</a>
<a name="ln70">  __cxa_vec_new2(size_t __element_count, size_t __element_size,</a>
<a name="ln71">		 size_t __padding_size, __cxa_cdtor_type __constructor,</a>
<a name="ln72">		 __cxa_cdtor_type __destructor, void *(*__alloc) (size_t),</a>
<a name="ln73">		 void (*__dealloc) (void*));</a>
<a name="ln74"> </a>
<a name="ln75">  void*</a>
<a name="ln76">  __cxa_vec_new3(size_t __element_count, size_t __element_size,</a>
<a name="ln77">		 size_t __padding_size, __cxa_cdtor_type __constructor,</a>
<a name="ln78">		 __cxa_cdtor_type __destructor, void *(*__alloc) (size_t),</a>
<a name="ln79">		 void (*__dealloc) (void*, size_t));</a>
<a name="ln80"> </a>
<a name="ln81">  // Construct array.</a>
<a name="ln82">  __cxa_vec_ctor_return_type</a>
<a name="ln83">  __cxa_vec_ctor(void* __array_address, size_t __element_count,</a>
<a name="ln84">		 size_t __element_size, __cxa_cdtor_type __constructor,</a>
<a name="ln85">		 __cxa_cdtor_type __destructor);</a>
<a name="ln86"> </a>
<a name="ln87">  __cxa_vec_ctor_return_type</a>
<a name="ln88">  __cxa_vec_cctor(void* __dest_array, void* __src_array,</a>
<a name="ln89">		  size_t __element_count, size_t __element_size,</a>
<a name="ln90">		  __cxa_cdtor_return_type (*__constructor) (void*, void*),</a>
<a name="ln91">		  __cxa_cdtor_type __destructor);</a>
<a name="ln92"> </a>
<a name="ln93">  // Destruct array.</a>
<a name="ln94">  void</a>
<a name="ln95">  __cxa_vec_dtor(void* __array_address, size_t __element_count,</a>
<a name="ln96">		 size_t __element_size, __cxa_cdtor_type __destructor);</a>
<a name="ln97"> </a>
<a name="ln98">  void</a>
<a name="ln99">  __cxa_vec_cleanup(void* __array_address, size_t __element_count, size_t __s,</a>
<a name="ln100">		    __cxa_cdtor_type __destructor) _GLIBCXX_NOTHROW;</a>
<a name="ln101"> </a>
<a name="ln102">  // Destruct and release array.</a>
<a name="ln103">  void</a>
<a name="ln104">  __cxa_vec_delete(void* __array_address, size_t __element_size,</a>
<a name="ln105">		   size_t __padding_size, __cxa_cdtor_type __destructor);</a>
<a name="ln106"> </a>
<a name="ln107">  void</a>
<a name="ln108">  __cxa_vec_delete2(void* __array_address, size_t __element_size,</a>
<a name="ln109">		    size_t __padding_size, __cxa_cdtor_type __destructor,</a>
<a name="ln110">		    void (*__dealloc) (void*));</a>
<a name="ln111"> </a>
<a name="ln112">  void</a>
<a name="ln113">  __cxa_vec_delete3(void* __array_address, size_t __element_size,</a>
<a name="ln114">		    size_t __padding_size, __cxa_cdtor_type __destructor,</a>
<a name="ln115">		    void (*__dealloc) (void*, size_t));</a>
<a name="ln116"> </a>
<a name="ln117">  int</a>
<a name="ln118">  __cxa_guard_acquire(__guard*);</a>
<a name="ln119"> </a>
<a name="ln120">  void</a>
<a name="ln121">  __cxa_guard_release(__guard*) _GLIBCXX_NOTHROW;</a>
<a name="ln122"> </a>
<a name="ln123">  void</a>
<a name="ln124">  __cxa_guard_abort(__guard*) _GLIBCXX_NOTHROW;</a>
<a name="ln125"> </a>
<a name="ln126">  // DSO destruction.</a>
<a name="ln127">  int</a>
<a name="ln128">  __cxa_atexit(void (*)(void*), void*, void*) _GLIBCXX_NOTHROW;</a>
<a name="ln129"> </a>
<a name="ln130">  int</a>
<a name="ln131">  __cxa_finalize(void*);</a>
<a name="ln132"> </a>
<a name="ln133">  // TLS destruction.</a>
<a name="ln134">  int</a>
<a name="ln135">  __cxa_thread_atexit(void (*)(void*), void*, void *) _GLIBCXX_NOTHROW;</a>
<a name="ln136"> </a>
<a name="ln137">  // Pure virtual functions.</a>
<a name="ln138">  void</a>
<a name="ln139">  __cxa_pure_virtual(void) __attribute__ ((__noreturn__));</a>
<a name="ln140"> </a>
<a name="ln141">  void</a>
<a name="ln142">  __cxa_deleted_virtual(void) __attribute__ ((__noreturn__));</a>
<a name="ln143"> </a>
<a name="ln144">  // Exception handling auxiliary.</a>
<a name="ln145">  void </a>
<a name="ln146">  __cxa_bad_cast() __attribute__((__noreturn__));</a>
<a name="ln147"> </a>
<a name="ln148">  void </a>
<a name="ln149">  __cxa_bad_typeid() __attribute__((__noreturn__));</a>
<a name="ln150"> </a>
<a name="ln151">  void</a>
<a name="ln152">  __cxa_throw_bad_array_new_length() __attribute__((__noreturn__));</a>
<a name="ln153"> </a>
<a name="ln154">  /**</a>
<a name="ln155">   *  @brief Demangling routine.</a>
<a name="ln156">   *  ABI-mandated entry point in the C++ runtime library for demangling.</a>
<a name="ln157">   *</a>
<a name="ln158">   *  @param __mangled_name A NUL-terminated character string</a>
<a name="ln159">   *  containing the name to be demangled.</a>
<a name="ln160">   *</a>
<a name="ln161">   *  @param __output_buffer A region of memory, allocated with</a>
<a name="ln162">   *  malloc, of @a *__length bytes, into which the demangled name is</a>
<a name="ln163">   *  stored.  If @a __output_buffer is not long enough, it is</a>
<a name="ln164">   *  expanded using realloc.  @a __output_buffer may instead be NULL;</a>
<a name="ln165">   *  in that case, the demangled name is placed in a region of memory</a>
<a name="ln166">   *  allocated with malloc.</a>
<a name="ln167">   *</a>
<a name="ln168">   *  @param __length If @a __length is non-NULL, the length of the</a>
<a name="ln169">   *  buffer containing the demangled name is placed in @a *__length.</a>
<a name="ln170">   *</a>
<a name="ln171">   *  @param __status @a *__status is set to one of the following values:</a>
<a name="ln172">   *   0: The demangling operation succeeded.</a>
<a name="ln173">   *  -1: A memory allocation failure occurred.</a>
<a name="ln174">   *  -2: @a mangled_name is not a valid name under the C++ ABI mangling rules.</a>
<a name="ln175">   *  -3: One of the arguments is invalid.</a>
<a name="ln176">   *</a>
<a name="ln177">   *  @return A pointer to the start of the NUL-terminated demangled</a>
<a name="ln178">   *  name, or NULL if the demangling fails.  The caller is</a>
<a name="ln179">   *  responsible for deallocating this memory using @c free.</a>
<a name="ln180">   *</a>
<a name="ln181">   *  The demangling is performed using the C++ ABI mangling rules,</a>
<a name="ln182">   *  with GNU extensions. For example, this function is used in</a>
<a name="ln183">   *  __gnu_cxx::__verbose_terminate_handler.</a>
<a name="ln184">   *</a>
<a name="ln185">   *  See https://gcc.gnu.org/onlinedocs/libstdc++/manual/ext_demangling.html</a>
<a name="ln186">   *  for other examples of use.</a>
<a name="ln187">   *</a>
<a name="ln188">   *  @note The same demangling functionality is available via</a>
<a name="ln189">   *  libiberty (@c &lt;libiberty/demangle.h&gt; and @c libiberty.a) in GCC</a>
<a name="ln190">   *  3.1 and later, but that requires explicit installation (@c</a>
<a name="ln191">   *  --enable-install-libiberty) and uses a different API, although</a>
<a name="ln192">   *  the ABI is unchanged.</a>
<a name="ln193">   */</a>
<a name="ln194">  char*</a>
<a name="ln195">  __cxa_demangle(const char* __mangled_name, char* __output_buffer,</a>
<a name="ln196">		 size_t* __length, int* __status);</a>
<a name="ln197"> </a>
<a name="ln198">#ifdef __cplusplus</a>
<a name="ln199">  }</a>
<a name="ln200">} // namespace __cxxabiv1</a>
<a name="ln201">#endif</a>
<a name="ln202"> </a>
<a name="ln203">#ifdef __cplusplus</a>
<a name="ln204"> </a>
<a name="ln205">#include &lt;typeinfo&gt;</a>
<a name="ln206"> </a>
<a name="ln207">namespace __cxxabiv1</a>
<a name="ln208">{</a>
<a name="ln209">  // Type information for int, float etc.</a>
<a name="ln210">  class __fundamental_type_info : public std::type_info</a>
<a name="ln211">  {</a>
<a name="ln212">  public:</a>
<a name="ln213">    explicit</a>
<a name="ln214">    __fundamental_type_info(const char* __n) : std::type_info(__n) { }</a>
<a name="ln215"> </a>
<a name="ln216">    virtual</a>
<a name="ln217">    ~__fundamental_type_info();</a>
<a name="ln218">  };</a>
<a name="ln219"> </a>
<a name="ln220">  // Type information for array objects.</a>
<a name="ln221">  class __array_type_info : public std::type_info</a>
<a name="ln222">  {</a>
<a name="ln223">  public:</a>
<a name="ln224">    explicit</a>
<a name="ln225">    __array_type_info(const char* __n) : std::type_info(__n) { }</a>
<a name="ln226"> </a>
<a name="ln227">    virtual</a>
<a name="ln228">    ~__array_type_info();</a>
<a name="ln229">  };</a>
<a name="ln230"> </a>
<a name="ln231">  // Type information for functions (both member and non-member).</a>
<a name="ln232">  class __function_type_info : public std::type_info</a>
<a name="ln233">  {</a>
<a name="ln234">  public:</a>
<a name="ln235">    explicit</a>
<a name="ln236">    __function_type_info(const char* __n) : std::type_info(__n) { }</a>
<a name="ln237"> </a>
<a name="ln238">    virtual</a>
<a name="ln239">    ~__function_type_info();</a>
<a name="ln240"> </a>
<a name="ln241">  protected:</a>
<a name="ln242">    // Implementation defined member function.</a>
<a name="ln243">    virtual bool</a>
<a name="ln244">    __is_function_p() const;</a>
<a name="ln245">  };</a>
<a name="ln246"> </a>
<a name="ln247">  // Type information for enumerations.</a>
<a name="ln248">  class __enum_type_info : public std::type_info</a>
<a name="ln249">  {</a>
<a name="ln250">  public:</a>
<a name="ln251">    explicit</a>
<a name="ln252">    __enum_type_info(const char* __n) : std::type_info(__n) { }</a>
<a name="ln253"> </a>
<a name="ln254">    virtual</a>
<a name="ln255">    ~__enum_type_info();</a>
<a name="ln256">  };</a>
<a name="ln257"> </a>
<a name="ln258">  // Common type information for simple pointers and pointers to member.</a>
<a name="ln259">  class __pbase_type_info : public std::type_info</a>
<a name="ln260">  {</a>
<a name="ln261">  public:</a>
<a name="ln262">    unsigned int 		__flags; // Qualification of the target object.</a>
<a name="ln263">    const std::type_info* 	__pointee; // Type of pointed to object.</a>
<a name="ln264"> </a>
<a name="ln265">    explicit</a>
<a name="ln266">    __pbase_type_info(const char* __n, int __quals,</a>
<a name="ln267">		      const std::type_info* __type)</a>
<a name="ln268">    : std::type_info(__n), __flags(__quals), __pointee(__type)</a>
<a name="ln269">    { }</a>
<a name="ln270"> </a>
<a name="ln271">    virtual</a>
<a name="ln272">    ~__pbase_type_info();</a>
<a name="ln273"> </a>
<a name="ln274">    // Implementation defined type.</a>
<a name="ln275">    enum __masks</a>
<a name="ln276">      {</a>
<a name="ln277">	__const_mask = 0x1,</a>
<a name="ln278">	__volatile_mask = 0x2,</a>
<a name="ln279">	__restrict_mask = 0x4,</a>
<a name="ln280">	__incomplete_mask = 0x8,</a>
<a name="ln281">	__incomplete_class_mask = 0x10,</a>
<a name="ln282">	__transaction_safe_mask = 0x20,</a>
<a name="ln283">	__noexcept_mask = 0x40</a>
<a name="ln284">      };</a>
<a name="ln285"> </a>
<a name="ln286">  protected:</a>
<a name="ln287">    __pbase_type_info(const __pbase_type_info&amp;);</a>
<a name="ln288"> </a>
<a name="ln289">    __pbase_type_info&amp;</a>
<a name="ln290">    operator=(const __pbase_type_info&amp;);</a>
<a name="ln291"> </a>
<a name="ln292">    // Implementation defined member functions.</a>
<a name="ln293">    virtual bool</a>
<a name="ln294">    __do_catch(const std::type_info* __thr_type, void** __thr_obj,</a>
<a name="ln295">	       unsigned int __outer) const;</a>
<a name="ln296"> </a>
<a name="ln297">    inline virtual bool</a>
<a name="ln298">    __pointer_catch(const __pbase_type_info* __thr_type, void** __thr_obj,</a>
<a name="ln299">		    unsigned __outer) const;</a>
<a name="ln300">  };</a>
<a name="ln301"> </a>
<a name="ln302">  inline bool __pbase_type_info::</a>
<a name="ln303">  __pointer_catch (const __pbase_type_info *thrown_type,</a>
<a name="ln304">		   void **thr_obj,</a>
<a name="ln305">		   unsigned outer) const</a>
<a name="ln306">  {</a>
<a name="ln307">    return __pointee-&gt;__do_catch (thrown_type-&gt;__pointee, thr_obj, outer + 2);</a>
<a name="ln308">  }</a>
<a name="ln309"> </a>
<a name="ln310">  // Type information for simple pointers.</a>
<a name="ln311">  class __pointer_type_info : public __pbase_type_info</a>
<a name="ln312">  {</a>
<a name="ln313">  public:</a>
<a name="ln314">    explicit</a>
<a name="ln315">    __pointer_type_info(const char* __n, int __quals,</a>
<a name="ln316">			const std::type_info* __type)</a>
<a name="ln317">    : __pbase_type_info (__n, __quals, __type) { }</a>
<a name="ln318"> </a>
<a name="ln319"> </a>
<a name="ln320">    virtual</a>
<a name="ln321">    ~__pointer_type_info();</a>
<a name="ln322"> </a>
<a name="ln323">  protected:</a>
<a name="ln324">    // Implementation defined member functions.</a>
<a name="ln325">    virtual bool</a>
<a name="ln326">    __is_pointer_p() const;</a>
<a name="ln327"> </a>
<a name="ln328">    virtual bool</a>
<a name="ln329">    __pointer_catch(const __pbase_type_info* __thr_type, void** __thr_obj,</a>
<a name="ln330">		    unsigned __outer) const;</a>
<a name="ln331">  };</a>
<a name="ln332"> </a>
<a name="ln333">  class __class_type_info;</a>
<a name="ln334"> </a>
<a name="ln335">  // Type information for a pointer to member variable.</a>
<a name="ln336">  class __pointer_to_member_type_info : public __pbase_type_info</a>
<a name="ln337">  {</a>
<a name="ln338">  public:</a>
<a name="ln339">    __class_type_info* __context;   // Class of the member.</a>
<a name="ln340"> </a>
<a name="ln341">    explicit</a>
<a name="ln342">    __pointer_to_member_type_info(const char* __n, int __quals,</a>
<a name="ln343">				  const std::type_info* __type,</a>
<a name="ln344">				  __class_type_info* __klass)</a>
<a name="ln345">    : __pbase_type_info(__n, __quals, __type), __context(__klass) { }</a>
<a name="ln346"> </a>
<a name="ln347">    virtual</a>
<a name="ln348">    ~__pointer_to_member_type_info();</a>
<a name="ln349"> </a>
<a name="ln350">  protected:</a>
<a name="ln351">    __pointer_to_member_type_info(const __pointer_to_member_type_info&amp;);</a>
<a name="ln352"> </a>
<a name="ln353">    __pointer_to_member_type_info&amp;</a>
<a name="ln354">    operator=(const __pointer_to_member_type_info&amp;);</a>
<a name="ln355"> </a>
<a name="ln356">    // Implementation defined member function.</a>
<a name="ln357">    virtual bool</a>
<a name="ln358">    __pointer_catch(const __pbase_type_info* __thr_type, void** __thr_obj,</a>
<a name="ln359">		    unsigned __outer) const;</a>
<a name="ln360">  };</a>
<a name="ln361"> </a>
<a name="ln362">  // Helper class for __vmi_class_type.</a>
<a name="ln363">  class __base_class_type_info</a>
<a name="ln364">  {</a>
<a name="ln365">  public:</a>
<a name="ln366">    const __class_type_info* 	__base_type;  // Base class type.</a>
<a name="ln367">#ifdef _GLIBCXX_LLP64</a>
<a name="ln368">    long long			__offset_flags;  // Offset and info.</a>
<a name="ln369">#else</a>
<a name="ln370">    long 			__offset_flags;  // Offset and info.</a>
<a name="ln371">#endif</a>
<a name="ln372"> </a>
<a name="ln373">    enum __offset_flags_masks</a>
<a name="ln374">      {</a>
<a name="ln375">	__virtual_mask = 0x1,</a>
<a name="ln376">	__public_mask = 0x2,</a>
<a name="ln377">	__hwm_bit = 2,</a>
<a name="ln378">	__offset_shift = 8          // Bits to shift offset.</a>
<a name="ln379">      };</a>
<a name="ln380"> </a>
<a name="ln381">    // Implementation defined member functions.</a>
<a name="ln382">    bool</a>
<a name="ln383">    __is_virtual_p() const</a>
<a name="ln384">    { return __offset_flags &amp; __virtual_mask; }</a>
<a name="ln385"> </a>
<a name="ln386">    bool</a>
<a name="ln387">    __is_public_p() const</a>
<a name="ln388">    { return __offset_flags &amp; __public_mask; }</a>
<a name="ln389"> </a>
<a name="ln390">    ptrdiff_t</a>
<a name="ln391">    __offset() const</a>
<a name="ln392">    {</a>
<a name="ln393">      // This shift, being of a signed type, is implementation</a>
<a name="ln394">      // defined. GCC implements such shifts as arithmetic, which is</a>
<a name="ln395">      // what we want.</a>
<a name="ln396">      return static_cast&lt;ptrdiff_t&gt;(__offset_flags) &gt;&gt; __offset_shift;</a>
<a name="ln397">    }</a>
<a name="ln398">  };</a>
<a name="ln399"> </a>
<a name="ln400">  // Type information for a class.</a>
<a name="ln401">  class __class_type_info : public std::type_info</a>
<a name="ln402">  {</a>
<a name="ln403">  public:</a>
<a name="ln404">    explicit</a>
<a name="ln405">    __class_type_info (const char *__n) : type_info(__n) { }</a>
<a name="ln406"> </a>
<a name="ln407">    virtual</a>
<a name="ln408">    ~__class_type_info ();</a>
<a name="ln409"> </a>
<a name="ln410">    // Implementation defined types.</a>
<a name="ln411">    // The type sub_kind tells us about how a base object is contained</a>
<a name="ln412">    // within a derived object. We often do this lazily, hence the</a>
<a name="ln413">    // UNKNOWN value. At other times we may use NOT_CONTAINED to mean</a>
<a name="ln414">    // not publicly contained.</a>
<a name="ln415">    enum __sub_kind</a>
<a name="ln416">      {</a>
<a name="ln417">	// We have no idea.</a>
<a name="ln418">	__unknown = 0,</a>
<a name="ln419"> </a>
<a name="ln420">	// Not contained within us (in some circumstances this might</a>
<a name="ln421">	// mean not contained publicly)</a>
<a name="ln422">	__not_contained,</a>
<a name="ln423"> </a>
<a name="ln424">	// Contained ambiguously.</a>
<a name="ln425">	__contained_ambig,</a>
<a name="ln426"> </a>
<a name="ln427">	// Via a virtual path.</a>
<a name="ln428">	__contained_virtual_mask = __base_class_type_info::__virtual_mask,</a>
<a name="ln429"> </a>
<a name="ln430">	// Via a public path.</a>
<a name="ln431">	__contained_public_mask = __base_class_type_info::__public_mask,</a>
<a name="ln432"> </a>
<a name="ln433">	// Contained within us.</a>
<a name="ln434">	__contained_mask = 1 &lt;&lt; __base_class_type_info::__hwm_bit,</a>
<a name="ln435"> </a>
<a name="ln436">	__contained_private = __contained_mask,</a>
<a name="ln437">	__contained_public = __contained_mask | __contained_public_mask</a>
<a name="ln438">      };</a>
<a name="ln439"> </a>
<a name="ln440">    struct __upcast_result;</a>
<a name="ln441">    struct __dyncast_result;</a>
<a name="ln442"> </a>
<a name="ln443">  protected:</a>
<a name="ln444">    // Implementation defined member functions.</a>
<a name="ln445">    virtual bool</a>
<a name="ln446">    __do_upcast(const __class_type_info* __dst_type, void**__obj_ptr) const;</a>
<a name="ln447"> </a>
<a name="ln448">    virtual bool</a>
<a name="ln449">    __do_catch(const type_info* __thr_type, void** __thr_obj,</a>
<a name="ln450">	       unsigned __outer) const;</a>
<a name="ln451"> </a>
<a name="ln452">  public:</a>
<a name="ln453">    // Helper for upcast. See if DST is us, or one of our bases.</a>
<a name="ln454">    // Return false if not found, true if found.</a>
<a name="ln455">    virtual bool</a>
<a name="ln456">    __do_upcast(const __class_type_info* __dst, const void* __obj,</a>
<a name="ln457">		__upcast_result&amp; __restrict __result) const;</a>
<a name="ln458"> </a>
<a name="ln459">    // Indicate whether SRC_PTR of type SRC_TYPE is contained publicly</a>
<a name="ln460">    // within OBJ_PTR. OBJ_PTR points to a base object of our type,</a>
<a name="ln461">    // which is the destination type. SRC2DST indicates how SRC</a>
<a name="ln462">    // objects might be contained within this type.  If SRC_PTR is one</a>
<a name="ln463">    // of our SRC_TYPE bases, indicate the virtuality. Returns</a>
<a name="ln464">    // not_contained for non containment or private containment.</a>
<a name="ln465">    inline __sub_kind</a>
<a name="ln466">    __find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr,</a>
<a name="ln467">		      const __class_type_info* __src_type,</a>
<a name="ln468">		      const void* __src_ptr) const;</a>
<a name="ln469"> </a>
<a name="ln470">    // Helper for dynamic cast. ACCESS_PATH gives the access from the</a>
<a name="ln471">    // most derived object to this base. DST_TYPE indicates the</a>
<a name="ln472">    // desired type we want. OBJ_PTR points to a base of our type</a>
<a name="ln473">    // within the complete object. SRC_TYPE indicates the static type</a>
<a name="ln474">    // started from and SRC_PTR points to that base within the most</a>
<a name="ln475">    // derived object. Fill in RESULT with what we find. Return true</a>
<a name="ln476">    // if we have located an ambiguous match.</a>
<a name="ln477">    virtual bool</a>
<a name="ln478">    __do_dyncast(ptrdiff_t __src2dst, __sub_kind __access_path,</a>
<a name="ln479">		 const __class_type_info* __dst_type, const void* __obj_ptr,</a>
<a name="ln480">		 const __class_type_info* __src_type, const void* __src_ptr,</a>
<a name="ln481">		 __dyncast_result&amp; __result) const;</a>
<a name="ln482"> </a>
<a name="ln483">    // Helper for find_public_subobj. SRC2DST indicates how SRC_TYPE</a>
<a name="ln484">    // bases are inherited by the type started from -- which is not</a>
<a name="ln485">    // necessarily the current type. The current type will be a base</a>
<a name="ln486">    // of the destination type.  OBJ_PTR points to the current base.</a>
<a name="ln487">    virtual __sub_kind</a>
<a name="ln488">    __do_find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr,</a>
<a name="ln489">			 const __class_type_info* __src_type,</a>
<a name="ln490">			 const void* __src_ptr) const;</a>
<a name="ln491">  };</a>
<a name="ln492"> </a>
<a name="ln493">  // Type information for a class with a single non-virtual base.</a>
<a name="ln494">  class __si_class_type_info : public __class_type_info</a>
<a name="ln495">  {</a>
<a name="ln496">  public:</a>
<a name="ln497">    const __class_type_info* __base_type;</a>
<a name="ln498"> </a>
<a name="ln499">    explicit</a>
<a name="ln500">    __si_class_type_info(const char *__n, const __class_type_info *__base)</a>
<a name="ln501">    : __class_type_info(__n), __base_type(__base) { }</a>
<a name="ln502"> </a>
<a name="ln503">    virtual</a>
<a name="ln504">    ~__si_class_type_info();</a>
<a name="ln505"> </a>
<a name="ln506">  protected:</a>
<a name="ln507">    __si_class_type_info(const __si_class_type_info&amp;);</a>
<a name="ln508"> </a>
<a name="ln509">    __si_class_type_info&amp;</a>
<a name="ln510">    operator=(const __si_class_type_info&amp;);</a>
<a name="ln511"> </a>
<a name="ln512">    // Implementation defined member functions.</a>
<a name="ln513">    virtual bool</a>
<a name="ln514">    __do_dyncast(ptrdiff_t __src2dst, __sub_kind __access_path,</a>
<a name="ln515">		 const __class_type_info* __dst_type, const void* __obj_ptr,</a>
<a name="ln516">		 const __class_type_info* __src_type, const void* __src_ptr,</a>
<a name="ln517">		 __dyncast_result&amp; __result) const;</a>
<a name="ln518"> </a>
<a name="ln519">    virtual __sub_kind</a>
<a name="ln520">    __do_find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr,</a>
<a name="ln521">			 const __class_type_info* __src_type,</a>
<a name="ln522">			 const void* __sub_ptr) const;</a>
<a name="ln523"> </a>
<a name="ln524">    virtual bool</a>
<a name="ln525">    __do_upcast(const __class_type_info*__dst, const void*__obj,</a>
<a name="ln526">		__upcast_result&amp; __restrict __result) const;</a>
<a name="ln527">  };</a>
<a name="ln528"> </a>
<a name="ln529">  // Type information for a class with multiple and/or virtual bases.</a>
<a name="ln530">  class __vmi_class_type_info : public __class_type_info</a>
<a name="ln531">  {</a>
<a name="ln532">  public:</a>
<a name="ln533">    unsigned int 		__flags;  // Details about the class hierarchy.</a>
<a name="ln534">    unsigned int 		__base_count;  // Number of direct bases.</a>
<a name="ln535"> </a>
<a name="ln536">    // The array of bases uses the trailing array struct hack so this</a>
<a name="ln537">    // class is not constructable with a normal constructor. It is</a>
<a name="ln538">    // internally generated by the compiler.</a>
<a name="ln539">    __base_class_type_info 	__base_info[1];  // Array of bases.</a>
<a name="ln540"> </a>
<a name="ln541">    explicit</a>
<a name="ln542">    __vmi_class_type_info(const char* __n, int ___flags)</a>
<a name="ln543">    : __class_type_info(__n), __flags(___flags), __base_count(0) { }</a>
<a name="ln544"> </a>
<a name="ln545">    virtual</a>
<a name="ln546">    ~__vmi_class_type_info();</a>
<a name="ln547"> </a>
<a name="ln548">    // Implementation defined types.</a>
<a name="ln549">    enum __flags_masks</a>
<a name="ln550">      {</a>
<a name="ln551">	__non_diamond_repeat_mask = 0x1, // Distinct instance of repeated base.</a>
<a name="ln552">	__diamond_shaped_mask = 0x2, // Diamond shaped multiple inheritance.</a>
<a name="ln553">	__flags_unknown_mask = 0x10</a>
<a name="ln554">      };</a>
<a name="ln555"> </a>
<a name="ln556">  protected:</a>
<a name="ln557">    // Implementation defined member functions.</a>
<a name="ln558">    virtual bool</a>
<a name="ln559">    __do_dyncast(ptrdiff_t __src2dst, __sub_kind __access_path,</a>
<a name="ln560">		 const __class_type_info* __dst_type, const void* __obj_ptr,</a>
<a name="ln561">		 const __class_type_info* __src_type, const void* __src_ptr,</a>
<a name="ln562">		 __dyncast_result&amp; __result) const;</a>
<a name="ln563"> </a>
<a name="ln564">    virtual __sub_kind</a>
<a name="ln565">    __do_find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr,</a>
<a name="ln566">			 const __class_type_info* __src_type,</a>
<a name="ln567">			 const void* __src_ptr) const;</a>
<a name="ln568"> </a>
<a name="ln569">    virtual bool</a>
<a name="ln570">    __do_upcast(const __class_type_info* __dst, const void* __obj,</a>
<a name="ln571">		__upcast_result&amp; __restrict __result) const;</a>
<a name="ln572">  };</a>
<a name="ln573"> </a>
<a name="ln574">  // Exception handling forward declarations.</a>
<a name="ln575">  struct __cxa_exception;</a>
<a name="ln576">  struct __cxa_refcounted_exception;</a>
<a name="ln577">  struct __cxa_dependent_exception;</a>
<a name="ln578">  struct __cxa_eh_globals;</a>
<a name="ln579"> </a>
<a name="ln580">  extern &quot;C&quot;</a>
<a name="ln581">  {</a>
<a name="ln582">  // Dynamic cast runtime.</a>
<a name="ln583"> </a>
<a name="ln584">  // src2dst has the following possible values</a>
<a name="ln585">  //  &gt;-1: src_type is a unique public non-virtual base of dst_type</a>
<a name="ln586">  //       dst_ptr + src2dst == src_ptr</a>
<a name="ln587">  //   -1: unspecified relationship</a>
<a name="ln588">  //   -2: src_type is not a public base of dst_type</a>
<a name="ln589">  //   -3: src_type is a multiple public non-virtual base of dst_type</a>
<a name="ln590">  void*</a>
<a name="ln591">  __dynamic_cast(const void* __src_ptr, // Starting object.</a>
<a name="ln592">		 const __class_type_info* __src_type, // Static type of object.</a>
<a name="ln593">		 const __class_type_info* __dst_type, // Desired target type.</a>
<a name="ln594">		 ptrdiff_t __src2dst); // How src and dst are related.</a>
<a name="ln595"> </a>
<a name="ln596"> </a>
<a name="ln597">  // Exception handling runtime.</a>
<a name="ln598"> </a>
<a name="ln599">  // The __cxa_eh_globals for the current thread can be obtained by using</a>
<a name="ln600">  // either of the following functions.  The &quot;fast&quot; version assumes at least</a>
<a name="ln601">  // one prior call of __cxa_get_globals has been made from the current</a>
<a name="ln602">  // thread, so no initialization is necessary.</a>
<a name="ln603">  __cxa_eh_globals*</a>
<a name="ln604">  __cxa_get_globals() _GLIBCXX_NOTHROW __attribute__ ((__const__));</a>
<a name="ln605"> </a>
<a name="ln606">  __cxa_eh_globals*</a>
<a name="ln607">  __cxa_get_globals_fast() _GLIBCXX_NOTHROW __attribute__ ((__const__));</a>
<a name="ln608"> </a>
<a name="ln609">  // Free the space allocated for the primary exception.</a>
<a name="ln610">  void </a>
<a name="ln611">  __cxa_free_exception(void*) _GLIBCXX_NOTHROW;</a>
<a name="ln612"> </a>
<a name="ln613">  // Throw the exception.</a>
<a name="ln614">  void</a>
<a name="ln615">  __cxa_throw(void*, std::type_info*, void (_GLIBCXX_CDTOR_CALLABI *) (void *))</a>
<a name="ln616">  __attribute__((__noreturn__));</a>
<a name="ln617"> </a>
<a name="ln618">  // Used to implement exception handlers.</a>
<a name="ln619">  void*</a>
<a name="ln620">  __cxa_get_exception_ptr(void*) _GLIBCXX_NOTHROW __attribute__ ((__pure__));</a>
<a name="ln621"> </a>
<a name="ln622">  void*</a>
<a name="ln623">  __cxa_begin_catch(void*) _GLIBCXX_NOTHROW;</a>
<a name="ln624"> </a>
<a name="ln625">  void </a>
<a name="ln626">  __cxa_end_catch();</a>
<a name="ln627"> </a>
<a name="ln628">  void </a>
<a name="ln629">  __cxa_rethrow() __attribute__((__noreturn__));</a>
<a name="ln630"> </a>
<a name="ln631">  // Returns the type_info for the currently handled exception [15.3/8], or</a>
<a name="ln632">  // null if there is none.</a>
<a name="ln633">  std::type_info*</a>
<a name="ln634">  __cxa_current_exception_type() _GLIBCXX_NOTHROW __attribute__ ((__pure__));</a>
<a name="ln635"> </a>
<a name="ln636">  // GNU Extensions.</a>
<a name="ln637"> </a>
<a name="ln638">  // Allocate memory for a dependent exception.</a>
<a name="ln639">  __cxa_dependent_exception*</a>
<a name="ln640">  __cxa_allocate_dependent_exception() _GLIBCXX_NOTHROW;</a>
<a name="ln641"> </a>
<a name="ln642">  // Free the space allocated for the dependent exception.</a>
<a name="ln643">  void</a>
<a name="ln644">  __cxa_free_dependent_exception(__cxa_dependent_exception*) _GLIBCXX_NOTHROW;</a>
<a name="ln645"> </a>
<a name="ln646">  } // extern &quot;C&quot;</a>
<a name="ln647"> </a>
<a name="ln648">  // A magic placeholder class that can be caught by reference</a>
<a name="ln649">  // to recognize foreign exceptions.</a>
<a name="ln650">  class __foreign_exception</a>
<a name="ln651">  {</a>
<a name="ln652">    virtual ~__foreign_exception() throw();</a>
<a name="ln653">    virtual void __pure_dummy() = 0; // prevent catch by value</a>
<a name="ln654">  };</a>
<a name="ln655"> </a>
<a name="ln656">} // namespace __cxxabiv1</a>
<a name="ln657"> </a>
<a name="ln658">/** @namespace abi</a>
<a name="ln659"> *  @brief The cross-vendor C++ Application Binary Interface. A</a>
<a name="ln660"> *  namespace alias to __cxxabiv1, but user programs should use the</a>
<a name="ln661"> *  alias 'abi'.</a>
<a name="ln662"> *</a>
<a name="ln663"> *  A brief overview of an ABI is given in the libstdc++ FAQ, question</a>
<a name="ln664"> *  5.8 (you may have a copy of the FAQ locally, or you can view the online</a>
<a name="ln665"> *  version at http://gcc.gnu.org/onlinedocs/libstdc++/faq.html#5_8 ).</a>
<a name="ln666"> *</a>
<a name="ln667"> *  GCC subscribes to a cross-vendor ABI for C++, sometimes</a>
<a name="ln668"> *  called the IA64 ABI because it happens to be the native ABI for that</a>
<a name="ln669"> *  platform.  It is summarized at http://www.codesourcery.com/cxx-abi/</a>
<a name="ln670"> *  along with the current specification.</a>
<a name="ln671"> *</a>
<a name="ln672"> *  For users of GCC greater than or equal to 3.x, entry points are</a>
<a name="ln673"> *  available in &lt;cxxabi.h&gt;, which notes, &lt;em&gt;'It is not normally</a>
<a name="ln674"> *  necessary for user programs to include this header, or use the</a>
<a name="ln675"> *  entry points directly.  However, this header is available should</a>
<a name="ln676"> *  that be needed.'&lt;/em&gt;</a>
<a name="ln677">*/</a>
<a name="ln678">namespace abi = __cxxabiv1;</a>
<a name="ln679"> </a>
<a name="ln680">namespace __gnu_cxx</a>
<a name="ln681">{</a>
<a name="ln682">  /**</a>
<a name="ln683">   *  @brief Exception thrown by __cxa_guard_acquire.</a>
<a name="ln684">   *  @ingroup exceptions</a>
<a name="ln685">   *</a>
<a name="ln686">   *  6.7[stmt.dcl]/4: If control re-enters the declaration (recursively)</a>
<a name="ln687">   *  while the object is being initialized, the behavior is undefined.</a>
<a name="ln688">   *</a>
<a name="ln689">   *  Since we already have a library function to handle locking, we might</a>
<a name="ln690">   *  as well check for this situation and throw an exception.</a>
<a name="ln691">   *  We use the second byte of the guard variable to remember that we're</a>
<a name="ln692">   *  in the middle of an initialization.</a>
<a name="ln693">   */</a>
<a name="ln694">  class recursive_init_error: public std::exception</a>
<a name="ln695">  {</a>
<a name="ln696">  public:</a>
<a name="ln697">    recursive_init_error() throw() { }</a>
<a name="ln698">    virtual ~recursive_init_error() throw ();</a>
<a name="ln699">  };</a>
<a name="ln700">}</a>
<a name="ln701">#endif // __cplusplus</a>
<a name="ln702"> </a>
<a name="ln703">#pragma GCC visibility pop</a>
<a name="ln704"> </a>
<a name="ln705">#endif // __CXXABI_H</a>

</code></pre>
<div class="balloon" rel="541"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: __base_info.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
