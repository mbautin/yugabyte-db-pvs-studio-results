
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>split.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Copyright 2008 and onwards Google Inc.  All rights reserved.</a>
<a name="ln2">//</a>
<a name="ln3">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln4">//</a>
<a name="ln5">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln6">//</a>
<a name="ln7">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln8">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln9">//</a>
<a name="ln10">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln11">//</a>
<a name="ln12">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln13">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln14">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln15">// under the License.</a>
<a name="ln16">//</a>
<a name="ln17">// Maintainer: Greg Miller &lt;jgm@google.com&gt;</a>
<a name="ln18"> </a>
<a name="ln19">#include &quot;yb/gutil/strings/split.h&quot;</a>
<a name="ln20"> </a>
<a name="ln21">#include &lt;assert.h&gt;</a>
<a name="ln22">#include &lt;stdlib.h&gt;</a>
<a name="ln23">#include &lt;string.h&gt;</a>
<a name="ln24">#include &lt;iterator&gt;</a>
<a name="ln25">using std::back_insert_iterator;</a>
<a name="ln26">using std::iterator_traits;</a>
<a name="ln27">#include &lt;limits&gt;</a>
<a name="ln28">using std::numeric_limits;</a>
<a name="ln29"> </a>
<a name="ln30">#include &quot;yb/gutil/integral_types.h&quot;</a>
<a name="ln31">#include &lt;glog/logging.h&gt;</a>
<a name="ln32">#include &quot;yb/gutil/logging-inl.h&quot;</a>
<a name="ln33">#include &quot;yb/gutil/macros.h&quot;</a>
<a name="ln34">#include &quot;yb/gutil/strtoint.h&quot;</a>
<a name="ln35">#include &quot;yb/gutil/strings/ascii_ctype.h&quot;</a>
<a name="ln36">#include &quot;yb/gutil/strings/util.h&quot;</a>
<a name="ln37">#include &quot;yb/gutil/hash/hash.h&quot;</a>
<a name="ln38"> </a>
<a name="ln39">// Implementations for some of the Split2 API. Much of the Split2 API is</a>
<a name="ln40">// templated so it exists in header files, either strings/split.h or</a>
<a name="ln41">// strings/split_iternal.h.</a>
<a name="ln42">namespace strings {</a>
<a name="ln43">namespace delimiter {</a>
<a name="ln44"> </a>
<a name="ln45">namespace {</a>
<a name="ln46"> </a>
<a name="ln47">// This GenericFind() template function encapsulates the finding algorithm</a>
<a name="ln48">// shared between the Literal and AnyOf delimiters. The FindPolicy template</a>
<a name="ln49">// parameter allows each delimiter to customize the actual find function to use</a>
<a name="ln50">// and the length of the found delimiter. For example, the Literal delimiter</a>
<a name="ln51">// will ultimately use GStringPiece::find(), and the AnyOf delimiter will use</a>
<a name="ln52">// GStringPiece::find_first_of().</a>
<a name="ln53">template &lt;typename FindPolicy&gt;</a>
<a name="ln54">GStringPiece GenericFind(</a>
<a name="ln55">    GStringPiece text,</a>
<a name="ln56">    GStringPiece delimiter,</a>
<a name="ln57">    FindPolicy find_policy) {</a>
<a name="ln58">  if (delimiter.empty() &amp;&amp; text.length() &gt; 0) {</a>
<a name="ln59">    // Special case for empty string delimiters: always return a zero-length</a>
<a name="ln60">    // GStringPiece referring to the item at position 1.</a>
<a name="ln61">    return GStringPiece(text.begin() + 1, 0);</a>
<a name="ln62">  }</a>
<a name="ln63">  int found_pos = GStringPiece::npos;</a>
<a name="ln64">  GStringPiece found(text.end(), 0);  // By default, not found</a>
<a name="ln65">  found_pos = find_policy.Find(text, delimiter);</a>
<a name="ln66">  if (found_pos != GStringPiece::npos) {</a>
<a name="ln67">    found.set(text.data() + found_pos, find_policy.Length(delimiter));</a>
<a name="ln68">  }</a>
<a name="ln69">  return found;</a>
<a name="ln70">}</a>
<a name="ln71"> </a>
<a name="ln72">// Finds using GStringPiece::find(), therefore the length of the found delimiter</a>
<a name="ln73">// is delimiter.length().</a>
<a name="ln74">struct LiteralPolicy {</a>
<a name="ln75">  int Find(GStringPiece text, GStringPiece delimiter) {</a>
<a name="ln76">    return text.find(delimiter);</a>
<a name="ln77">  }</a>
<a name="ln78">  int Length(GStringPiece delimiter) {</a>
<a name="ln79">    return delimiter.length();</a>
<a name="ln80">  }</a>
<a name="ln81">};</a>
<a name="ln82"> </a>
<a name="ln83">// Finds using GStringPiece::find_first_of(), therefore the length of the found</a>
<a name="ln84">// delimiter is 1.</a>
<a name="ln85">struct AnyOfPolicy {</a>
<a name="ln86">  size_t Find(GStringPiece text, GStringPiece delimiter) {</a>
<a name="ln87">    return text.find_first_of(delimiter);</a>
<a name="ln88">  }</a>
<a name="ln89">  int Length(GStringPiece delimiter) {</a>
<a name="ln90">    return 1;</a>
<a name="ln91">  }</a>
<a name="ln92">};</a>
<a name="ln93"> </a>
<a name="ln94">}  // namespace</a>
<a name="ln95"> </a>
<a name="ln96">//</a>
<a name="ln97">// Literal</a>
<a name="ln98">//</a>
<a name="ln99"> </a>
<a name="ln100">Literal::Literal(GStringPiece sp) : delimiter_(sp.ToString()) {</a>
<a name="ln101">}</a>
<a name="ln102"> </a>
<a name="ln103">GStringPiece Literal::Find(GStringPiece text) const {</a>
<a name="ln104">  return GenericFind(text, delimiter_, LiteralPolicy());</a>
<a name="ln105">}</a>
<a name="ln106"> </a>
<a name="ln107">//</a>
<a name="ln108">// AnyOf</a>
<a name="ln109">//</a>
<a name="ln110"> </a>
<a name="ln111">AnyOf::AnyOf(GStringPiece sp) : delimiters_(sp.ToString()) {</a>
<a name="ln112">}</a>
<a name="ln113"> </a>
<a name="ln114">GStringPiece AnyOf::Find(GStringPiece text) const {</a>
<a name="ln115">  return GenericFind(text, delimiters_, AnyOfPolicy());</a>
<a name="ln116">}</a>
<a name="ln117"> </a>
<a name="ln118">}  // namespace delimiter</a>
<a name="ln119">}  // namespace strings</a>
<a name="ln120"> </a>
<a name="ln121">//</a>
<a name="ln122">// ==================== LEGACY SPLIT FUNCTIONS ====================</a>
<a name="ln123">//</a>
<a name="ln124"> </a>
<a name="ln125">using ::strings::SkipEmpty;</a>
<a name="ln126">using ::strings::delimiter::AnyOf;</a>
<a name="ln127">using ::strings::delimiter::Limit;</a>
<a name="ln128"> </a>
<a name="ln129">namespace {</a>
<a name="ln130"> </a>
<a name="ln131">// Appends the results of a split to the specified container. This function has</a>
<a name="ln132">// the following overloads:</a>
<a name="ln133">// - vector&lt;string&gt;           - for better performance</a>
<a name="ln134">// - map&lt;string, string&gt;      - to change append semantics</a>
<a name="ln135">// - hash_map&lt;string, string&gt; - to change append semantics</a>
<a name="ln136">template &lt;typename Container, typename Splitter&gt;</a>
<a name="ln137">void AppendToImpl(Container* container, Splitter splitter) {</a>
<a name="ln138">  Container c = splitter;  // Calls implicit conversion operator.</a>
<a name="ln139">  std::copy(c.begin(), c.end(), std::inserter(*container, container-&gt;end()));</a>
<a name="ln140">}</a>
<a name="ln141"> </a>
<a name="ln142">// Overload of AppendToImpl() that is optimized for appending to vector&lt;string&gt;.</a>
<a name="ln143">// This version eliminates a couple string copies by using a vector&lt;GStringPiece&gt;</a>
<a name="ln144">// as the intermediate container.</a>
<a name="ln145">template &lt;typename Splitter&gt;</a>
<a name="ln146">void AppendToImpl(vector&lt;string&gt;* container, Splitter splitter) {</a>
<a name="ln147">  vector&lt;GStringPiece&gt; vsp = splitter;  // Calls implicit conversion operator.</a>
<a name="ln148">  size_t container_size = container-&gt;size();</a>
<a name="ln149">  container-&gt;resize(container_size + vsp.size());</a>
<a name="ln150">  for (const auto&amp; sp : vsp) {</a>
<a name="ln151">    sp.CopyToString(&amp;(*container)[container_size++]);</a>
<a name="ln152">  }</a>
<a name="ln153">}</a>
<a name="ln154"> </a>
<a name="ln155">// Here we define two AppendToImpl() overloads for map&lt;&gt; and hash_map&lt;&gt;. Both of</a>
<a name="ln156">// these overloads call through to this AppendToMap() function. This is needed</a>
<a name="ln157">// because inserting a duplicate key into a map does NOT overwrite the previous</a>
<a name="ln158">// value, which was not the behavior of the split1 Split*() functions. Consider</a>
<a name="ln159">// this example:</a>
<a name="ln160">//</a>
<a name="ln161">//   map&lt;string, string&gt; m;</a>
<a name="ln162">//   m.insert(std::make_pair(&quot;a&quot;, &quot;1&quot;));</a>
<a name="ln163">//   m.insert(std::make_pair(&quot;a&quot;, &quot;2&quot;));  // &lt;-- doesn't actually insert.</a>
<a name="ln164">//   ASSERT_EQ(m[&quot;a&quot;], &quot;1&quot;);  // &lt;-- &quot;a&quot; has value &quot;1&quot; not &quot;2&quot;.</a>
<a name="ln165">//</a>
<a name="ln166">// Due to this behavior of map::insert, we can't rely on a normal std::inserter</a>
<a name="ln167">// for a maps. Instead, maps and hash_maps need to be special cased to implement</a>
<a name="ln168">// the desired append semantic of inserting an existing value overwrites the</a>
<a name="ln169">// previous value.</a>
<a name="ln170">//</a>
<a name="ln171">// This same issue is true with sets as well. However, since sets don't have a</a>
<a name="ln172">// separate key and value, failing to overwrite an existing value in a set is</a>
<a name="ln173">// fine because the value already exists in the set.</a>
<a name="ln174">//</a>
<a name="ln175">template &lt;typename Map, typename Splitter&gt;</a>
<a name="ln176">void AppendToMap(Map* m, Splitter splitter) {</a>
<a name="ln177">  Map tmp = splitter;  // Calls implicit conversion operator.</a>
<a name="ln178">  for (typename Map::const_iterator it = tmp.begin(); it != tmp.end(); ++it) {</a>
<a name="ln179">    (*m)[it-&gt;first] = it-&gt;second;</a>
<a name="ln180">  }</a>
<a name="ln181">}</a>
<a name="ln182"> </a>
<a name="ln183">template &lt;typename Splitter&gt;</a>
<a name="ln184">void AppendToImpl(map&lt;string, string&gt;* map_container, Splitter splitter) {</a>
<a name="ln185">  AppendToMap(map_container, splitter);</a>
<a name="ln186">}</a>
<a name="ln187"> </a>
<a name="ln188">template &lt;typename Splitter&gt;</a>
<a name="ln189">void AppendToImpl(hash_map&lt;string, string&gt;* map_container, Splitter splitter) {</a>
<a name="ln190">  AppendToMap(map_container, splitter);</a>
<a name="ln191">}</a>
<a name="ln192"> </a>
<a name="ln193">// Appends the results of a call to strings::Split() to the specified container.</a>
<a name="ln194">// This function is used with the new strings::Split() API to implement the</a>
<a name="ln195">// append semantics of the legacy Split*() functions.</a>
<a name="ln196">//</a>
<a name="ln197">// The &quot;Splitter&quot; template parameter is intended to be a</a>
<a name="ln198">// ::strings::internal::Splitter&lt;&gt;, which is the return value of a call to</a>
<a name="ln199">// strings::Split(). Sample usage:</a>
<a name="ln200">//</a>
<a name="ln201">//   vector&lt;string&gt; v;</a>
<a name="ln202">//   ... add stuff to &quot;v&quot; ...</a>
<a name="ln203">//   AppendTo(&amp;v, strings::Split(&quot;a,b,c&quot;, &quot;,&quot;));</a>
<a name="ln204">//</a>
<a name="ln205">template &lt;typename Container, typename Splitter&gt;</a>
<a name="ln206">void AppendTo(Container* container, Splitter splitter) {</a>
<a name="ln207">  if (container-&gt;empty()) {</a>
<a name="ln208">    // &quot;Appending&quot; to an empty container is by far the common case. For this we</a>
<a name="ln209">    // assign directly to the output container, which is more efficient than</a>
<a name="ln210">    // explicitly appending.</a>
<a name="ln211">    *container = splitter;  // Calls implicit conversion operator.</a>
<a name="ln212">  } else {</a>
<a name="ln213">    AppendToImpl(container, splitter);</a>
<a name="ln214">  }</a>
<a name="ln215">}</a>
<a name="ln216"> </a>
<a name="ln217">}  // anonymous namespace</a>
<a name="ln218"> </a>
<a name="ln219">// Constants for ClipString()</a>
<a name="ln220">static const int kMaxOverCut = 12;</a>
<a name="ln221">// The ellipsis to add to strings that are too long</a>
<a name="ln222">static const char kCutStr[] = &quot;...&quot;;</a>
<a name="ln223">static const int kCutStrSize = sizeof(kCutStr) - 1;</a>
<a name="ln224"> </a>
<a name="ln225">// ----------------------------------------------------------------------</a>
<a name="ln226">// Return the place to clip the string at, or -1</a>
<a name="ln227">// if the string doesn't need to be clipped.</a>
<a name="ln228">// ----------------------------------------------------------------------</a>
<a name="ln229">static int ClipStringHelper(const char* str, int max_len, bool use_ellipsis) {</a>
<a name="ln230">  if (strlen(str) &lt;= max_len)</a>
<a name="ln231">    return -1;</a>
<a name="ln232"> </a>
<a name="ln233">  int max_substr_len = max_len;</a>
<a name="ln234"> </a>
<a name="ln235">  if (use_ellipsis &amp;&amp; max_len &gt; kCutStrSize) {</a>
<a name="ln236">    max_substr_len -= kCutStrSize;</a>
<a name="ln237">  }</a>
<a name="ln238"> </a>
<a name="ln239">  const char* cut_by =</a>
<a name="ln240">      (max_substr_len &lt; kMaxOverCut ? str : str + max_len - kMaxOverCut);</a>
<a name="ln241">  const char* cut_at = str + max_substr_len;</a>
<a name="ln242">  while (!ascii_isspace(*cut_at) &amp;&amp; cut_at &gt; cut_by)</a>
<a name="ln243">    cut_at--;</a>
<a name="ln244"> </a>
<a name="ln245">  if (cut_at == cut_by) {</a>
<a name="ln246">    // No space was found</a>
<a name="ln247">    return max_substr_len;</a>
<a name="ln248">  } else {</a>
<a name="ln249">    return cut_at-str;</a>
<a name="ln250">  }</a>
<a name="ln251">}</a>
<a name="ln252"> </a>
<a name="ln253">// ----------------------------------------------------------------------</a>
<a name="ln254">// ClipString</a>
<a name="ln255">//    Clip a string to a max length. We try to clip on a word boundary</a>
<a name="ln256">//    if this is possible. If the string is clipped, we append an</a>
<a name="ln257">//    ellipsis.</a>
<a name="ln258">// ----------------------------------------------------------------------</a>
<a name="ln259"> </a>
<a name="ln260">void ClipString(char* str, int max_len) {</a>
<a name="ln261">  int cut_at = ClipStringHelper(str, max_len, true);</a>
<a name="ln262">  if (cut_at != -1) {</a>
<a name="ln263">    if (max_len &gt; kCutStrSize) {</a>
<a name="ln264">      strcpy(str+cut_at, kCutStr);</a>
<a name="ln265">    } else {</a>
<a name="ln266">      strcpy(str+cut_at, &quot;&quot;);</a>
<a name="ln267">    }</a>
<a name="ln268">  }</a>
<a name="ln269">}</a>
<a name="ln270"> </a>
<a name="ln271">// ----------------------------------------------------------------------</a>
<a name="ln272">// ClipString</a>
<a name="ln273">//    Version of ClipString() that uses string instead of char*.</a>
<a name="ln274">// ----------------------------------------------------------------------</a>
<a name="ln275">void ClipString(string* full_str, int max_len) {</a>
<a name="ln276">  int cut_at = ClipStringHelper(full_str-&gt;c_str(), max_len, true);</a>
<a name="ln277">  if (cut_at != -1) {</a>
<a name="ln278">    full_str-&gt;erase(cut_at);</a>
<a name="ln279">    if (max_len &gt; kCutStrSize) {</a>
<a name="ln280">      full_str-&gt;append(kCutStr);</a>
<a name="ln281">    }</a>
<a name="ln282">  }</a>
<a name="ln283">}</a>
<a name="ln284"> </a>
<a name="ln285">// ----------------------------------------------------------------------</a>
<a name="ln286">// SplitStringToIteratorAllowEmpty()</a>
<a name="ln287">//    Split a string using a character delimiter. Append the components</a>
<a name="ln288">//    to 'result'.  If there are consecutive delimiters, this function</a>
<a name="ln289">//    will return corresponding empty strings. The string is split into</a>
<a name="ln290">//    at most the specified number of pieces greedily. This means that the</a>
<a name="ln291">//    last piece may possibly be split further. To split into as many pieces</a>
<a name="ln292">//    as possible, specify 0 as the number of pieces.</a>
<a name="ln293">//</a>
<a name="ln294">//    If &quot;full&quot; is the empty string, yields an empty string as the only value.</a>
<a name="ln295">//</a>
<a name="ln296">//    If &quot;pieces&quot; is negative for some reason, it returns the whole string</a>
<a name="ln297">// ----------------------------------------------------------------------</a>
<a name="ln298">template &lt;typename StringType, typename ITR&gt;</a>
<a name="ln299">static inline</a>
<a name="ln300">void SplitStringToIteratorAllowEmpty(const StringType&amp; full,</a>
<a name="ln301">                                     const char* delim,</a>
<a name="ln302">                                     int pieces,</a>
<a name="ln303">                                     ITR&amp; result) {</a>
<a name="ln304">  string::size_type begin_index, end_index;</a>
<a name="ln305">  begin_index = 0;</a>
<a name="ln306"> </a>
<a name="ln307">  for (int i = 0; (i &lt; pieces-1) || (pieces == 0); i++) {</a>
<a name="ln308">    end_index = full.find_first_of(delim, begin_index);</a>
<a name="ln309">    if (end_index == string::npos) {</a>
<a name="ln310">      *result++ = full.substr(begin_index);</a>
<a name="ln311">      return;</a>
<a name="ln312">    }</a>
<a name="ln313">    *result++ = full.substr(begin_index, (end_index - begin_index));</a>
<a name="ln314">    begin_index = end_index + 1;</a>
<a name="ln315">  }</a>
<a name="ln316">  *result++ = full.substr(begin_index);</a>
<a name="ln317">}</a>
<a name="ln318"> </a>
<a name="ln319">void SplitStringIntoNPiecesAllowEmpty(const string&amp; full,</a>
<a name="ln320">                                      const char* delim,</a>
<a name="ln321">                                      int pieces,</a>
<a name="ln322">                                      vector&lt;string&gt;* result) {</a>
<a name="ln323">  if (pieces == 0) {</a>
<a name="ln324">    // No limit when pieces is 0.</a>
<a name="ln325">    AppendTo(result, strings::Split(full, AnyOf(delim)));</a>
<a name="ln326">  } else {</a>
<a name="ln327">    // The input argument &quot;pieces&quot; specifies the max size that *result should</a>
<a name="ln328">    // be. However, the argument to the Limit() delimiter is the max number of</a>
<a name="ln329">    // delimiters, which should be one less than &quot;pieces&quot;. Example: &quot;a,b,c&quot; has</a>
<a name="ln330">    // 3 pieces and two comma delimiters.</a>
<a name="ln331">    int limit = std::max(pieces - 1, 0);</a>
<a name="ln332">    AppendTo(result, strings::Split(full, Limit(AnyOf(delim), limit)));</a>
<a name="ln333">  }</a>
<a name="ln334">}</a>
<a name="ln335"> </a>
<a name="ln336">// ----------------------------------------------------------------------</a>
<a name="ln337">// SplitStringAllowEmpty</a>
<a name="ln338">//    Split a string using a character delimiter. Append the components</a>
<a name="ln339">//    to 'result'.  If there are consecutive delimiters, this function</a>
<a name="ln340">//    will return corresponding empty strings.</a>
<a name="ln341">// ----------------------------------------------------------------------</a>
<a name="ln342">void SplitStringAllowEmpty(const string&amp; full, const char* delim,</a>
<a name="ln343">                           vector&lt;string&gt;* result) {</a>
<a name="ln344">  AppendTo(result, strings::Split(full, AnyOf(delim)));</a>
<a name="ln345">}</a>
<a name="ln346"> </a>
<a name="ln347">// If we know how much to allocate for a vector of strings, we can</a>
<a name="ln348">// allocate the vector&lt;string&gt; only once and directly to the right size.</a>
<a name="ln349">// This saves in between 33-66 % of memory space needed for the result,</a>
<a name="ln350">// and runs faster in the microbenchmarks.</a>
<a name="ln351">//</a>
<a name="ln352">// The reserve is only implemented for the single character delim.</a>
<a name="ln353">//</a>
<a name="ln354">// The implementation for counting is cut-and-pasted from</a>
<a name="ln355">// SplitStringToIteratorUsing. I could have written my own counting iterator,</a>
<a name="ln356">// and use the existing template function, but probably this is more clear</a>
<a name="ln357">// and more sure to get optimized to reasonable code.</a>
<a name="ln358">static int CalculateReserveForVector(const string&amp; full, const char* delim) {</a>
<a name="ln359">  int count = 0;</a>
<a name="ln360">  if (delim[0] != '\0' &amp;&amp; delim[1] == '\0') {</a>
<a name="ln361">    // Optimize the common case where delim is a single character.</a>
<a name="ln362">    char c = delim[0];</a>
<a name="ln363">    const char* p = full.data();</a>
<a name="ln364">    const char* end = p + full.size();</a>
<a name="ln365">    while (p != end) {</a>
<a name="ln366">      if (*p == c) {  // This could be optimized with hasless(v,1) trick.</a>
<a name="ln367">        ++p;</a>
<a name="ln368">      } else {</a>
<a name="ln369">        while (++p != end &amp;&amp; *p != c) {</a>
<a name="ln370">          // Skip to the next occurence of the delimiter.</a>
<a name="ln371">        }</a>
<a name="ln372">        ++count;</a>
<a name="ln373">      }</a>
<a name="ln374">    }</a>
<a name="ln375">  }</a>
<a name="ln376">  return count;</a>
<a name="ln377">}</a>
<a name="ln378"> </a>
<a name="ln379">// ----------------------------------------------------------------------</a>
<a name="ln380">// SplitStringUsing()</a>
<a name="ln381">// SplitStringToHashsetUsing()</a>
<a name="ln382">// SplitStringToSetUsing()</a>
<a name="ln383">// SplitStringToMapUsing()</a>
<a name="ln384">// SplitStringToHashmapUsing()</a>
<a name="ln385">//    Split a string using a character delimiter. Append the components</a>
<a name="ln386">//    to 'result'.</a>
<a name="ln387">//</a>
<a name="ln388">// Note: For multi-character delimiters, this routine will split on *ANY* of</a>
<a name="ln389">// the characters in the string, not the entire string as a single delimiter.</a>
<a name="ln390">// ----------------------------------------------------------------------</a>
<a name="ln391">template &lt;typename StringType, typename ITR&gt;</a>
<a name="ln392">static inline</a>
<a name="ln393">void SplitStringToIteratorUsing(const StringType&amp; full,</a>
<a name="ln394">                                const char* delim,</a>
<a name="ln395">                                ITR&amp; result) {</a>
<a name="ln396">  // Optimize the common case where delim is a single character.</a>
<a name="ln397">  if (delim[0] != '\0' &amp;&amp; delim[1] == '\0') {</a>
<a name="ln398">    char c = delim[0];</a>
<a name="ln399">    const char* p = full.data();</a>
<a name="ln400">    const char* end = p + full.size();</a>
<a name="ln401">    while (p != end) {</a>
<a name="ln402">      if (*p == c) {</a>
<a name="ln403">        ++p;</a>
<a name="ln404">      } else {</a>
<a name="ln405">        const char* start = p;</a>
<a name="ln406">        while (++p != end &amp;&amp; *p != c) {</a>
<a name="ln407">          // Skip to the next occurence of the delimiter.</a>
<a name="ln408">        }</a>
<a name="ln409">        *result++ = StringType(start, p - start);</a>
<a name="ln410">      }</a>
<a name="ln411">    }</a>
<a name="ln412">    return;</a>
<a name="ln413">  }</a>
<a name="ln414"> </a>
<a name="ln415">  string::size_type begin_index, end_index;</a>
<a name="ln416">  begin_index = full.find_first_not_of(delim);</a>
<a name="ln417">  while (begin_index != string::npos) {</a>
<a name="ln418">    end_index = full.find_first_of(delim, begin_index);</a>
<a name="ln419">    if (end_index == string::npos) {</a>
<a name="ln420">      *result++ = full.substr(begin_index);</a>
<a name="ln421">      return;</a>
<a name="ln422">    }</a>
<a name="ln423">    *result++ = full.substr(begin_index, (end_index - begin_index));</a>
<a name="ln424">    begin_index = full.find_first_not_of(delim, end_index);</a>
<a name="ln425">  }</a>
<a name="ln426">}</a>
<a name="ln427"> </a>
<a name="ln428">void SplitStringUsing(const string&amp; full,</a>
<a name="ln429">                      const char* delim,</a>
<a name="ln430">                      vector&lt;string&gt;* result) {</a>
<a name="ln431">  result-&gt;reserve(result-&gt;size() + CalculateReserveForVector(full, delim));</a>
<a name="ln432">  std::back_insert_iterator&lt; vector&lt;string&gt; &gt; it(*result);</a>
<a name="ln433">  SplitStringToIteratorUsing(full, delim, it);</a>
<a name="ln434">}</a>
<a name="ln435"> </a>
<a name="ln436">void SplitStringToHashsetUsing(const string&amp; full, const char* delim,</a>
<a name="ln437">                               hash_set&lt;string&gt;* result) {</a>
<a name="ln438">  AppendTo(result, strings::Split(full, AnyOf(delim), strings::SkipEmpty()));</a>
<a name="ln439">}</a>
<a name="ln440"> </a>
<a name="ln441">void SplitStringToSetUsing(const string&amp; full, const char* delim,</a>
<a name="ln442">                           set&lt;string&gt;* result) {</a>
<a name="ln443">  AppendTo(result, strings::Split(full, AnyOf(delim), strings::SkipEmpty()));</a>
<a name="ln444">}</a>
<a name="ln445"> </a>
<a name="ln446">void SplitStringToMapUsing(const string&amp; full, const char* delim,</a>
<a name="ln447">                           map&lt;string, string&gt;* result) {</a>
<a name="ln448">  AppendTo(result, strings::Split(full, AnyOf(delim), strings::SkipEmpty()));</a>
<a name="ln449">}</a>
<a name="ln450"> </a>
<a name="ln451">void SplitStringToHashmapUsing(const string&amp; full, const char* delim,</a>
<a name="ln452">                               hash_map&lt;string, string&gt;* result) {</a>
<a name="ln453">  AppendTo(result, strings::Split(full, AnyOf(delim), strings::SkipEmpty()));</a>
<a name="ln454">}</a>
<a name="ln455"> </a>
<a name="ln456">// ----------------------------------------------------------------------</a>
<a name="ln457">// SplitGStringPieceToVector()</a>
<a name="ln458">//    Split a GStringPiece into sub-GStringPieces based on delim</a>
<a name="ln459">//    and appends the pieces to 'vec'.</a>
<a name="ln460">//    If omit empty strings is true, empty strings are omitted</a>
<a name="ln461">//    from the resulting vector.</a>
<a name="ln462">// ----------------------------------------------------------------------</a>
<a name="ln463">void SplitGStringPieceToVector(const GStringPiece&amp; full,</a>
<a name="ln464">                              const char* delim,</a>
<a name="ln465">                              vector&lt;GStringPiece&gt;* vec,</a>
<a name="ln466">                              bool omit_empty_strings) {</a>
<a name="ln467">  if (omit_empty_strings) {</a>
<a name="ln468">    AppendTo(vec, strings::Split(full, AnyOf(delim), SkipEmpty()));</a>
<a name="ln469">  } else {</a>
<a name="ln470">    AppendTo(vec, strings::Split(full, AnyOf(delim)));</a>
<a name="ln471">  }</a>
<a name="ln472">}</a>
<a name="ln473"> </a>
<a name="ln474">// ----------------------------------------------------------------------</a>
<a name="ln475">// SplitUsing()</a>
<a name="ln476">//    Split a string using a string of delimiters, returning vector</a>
<a name="ln477">//    of strings. The original string is modified to insert nulls.</a>
<a name="ln478">// ----------------------------------------------------------------------</a>
<a name="ln479"> </a>
<a name="ln480">vector&lt;char*&gt;* SplitUsing(char* full, const char* delim) {</a>
<a name="ln481">  auto vec = new vector&lt;char*&gt;;</a>
<a name="ln482">  SplitToVector(full, delim, vec, true);        // Omit empty strings</a>
<a name="ln483">  return vec;</a>
<a name="ln484">}</a>
<a name="ln485"> </a>
<a name="ln486">void SplitToVector(char* full, const char* delim, vector&lt;char*&gt;* vec,</a>
<a name="ln487">                   bool omit_empty_strings) {</a>
<a name="ln488">  char* next  = full;</a>
<a name="ln489">  while ((next = gstrsep(&amp;full, delim)) != nullptr) {</a>
<a name="ln490">    if (omit_empty_strings &amp;&amp; next[0] == '\0') continue;</a>
<a name="ln491">    vec-&gt;push_back(next);</a>
<a name="ln492">  }</a>
<a name="ln493">  // Add last element (or full string if no delimeter found):</a>
<a name="ln494">  if (full != nullptr) {</a>
<a name="ln495">    vec-&gt;push_back(full);</a>
<a name="ln496">  }</a>
<a name="ln497">}</a>
<a name="ln498"> </a>
<a name="ln499">void SplitToVector(char* full, const char* delim, vector&lt;const char*&gt;* vec,</a>
<a name="ln500">                   bool omit_empty_strings) {</a>
<a name="ln501">  char* next  = full;</a>
<a name="ln502">  while ((next = gstrsep(&amp;full, delim)) != nullptr) {</a>
<a name="ln503">    if (omit_empty_strings &amp;&amp; next[0] == '\0') continue;</a>
<a name="ln504">    vec-&gt;push_back(next);</a>
<a name="ln505">  }</a>
<a name="ln506">  // Add last element (or full string if no delimeter found):</a>
<a name="ln507">  if (full != nullptr) {</a>
<a name="ln508">    vec-&gt;push_back(full);</a>
<a name="ln509">  }</a>
<a name="ln510">}</a>
<a name="ln511"> </a>
<a name="ln512">// ----------------------------------------------------------------------</a>
<a name="ln513">// SplitOneStringToken()</a>
<a name="ln514">//   Mainly a stringified wrapper around strpbrk()</a>
<a name="ln515">// ----------------------------------------------------------------------</a>
<a name="ln516">string SplitOneStringToken(const char ** source, const char * delim) {</a>
<a name="ln517">  assert(source);</a>
<a name="ln518">  assert(delim);</a>
<a name="ln519">  if (!*source) {</a>
<a name="ln520">    return string();</a>
<a name="ln521">  }</a>
<a name="ln522">  const char * begin = *source;</a>
<a name="ln523">  // Optimize the common case where delim is a single character.</a>
<a name="ln524">  if (delim[0] != '\0' &amp;&amp; delim[1] == '\0') {</a>
<a name="ln525">    *source = strchr(*source, delim[0]);</a>
<a name="ln526">  } else {</a>
<a name="ln527">    *source = strpbrk(*source, delim);</a>
<a name="ln528">  }</a>
<a name="ln529">  if (*source) {</a>
<a name="ln530">    return string(begin, (*source)++);</a>
<a name="ln531">  } else {</a>
<a name="ln532">    return string(begin);</a>
<a name="ln533">  }</a>
<a name="ln534">}</a>
<a name="ln535"> </a>
<a name="ln536">// ----------------------------------------------------------------------</a>
<a name="ln537">// SplitStringWithEscaping()</a>
<a name="ln538">// SplitStringWithEscapingAllowEmpty()</a>
<a name="ln539">// SplitStringWithEscapingToSet()</a>
<a name="ln540">// SplitStringWithWithEscapingToHashset()</a>
<a name="ln541">//   Split the string using the specified delimiters, taking escaping into</a>
<a name="ln542">//   account. '\' is not allowed as a delimiter.</a>
<a name="ln543">// ----------------------------------------------------------------------</a>
<a name="ln544">template &lt;typename ITR&gt;</a>
<a name="ln545">static inline</a>
<a name="ln546">void SplitStringWithEscapingToIterator(const string&amp; src,</a>
<a name="ln547">                                       const strings::CharSet&amp; delimiters,</a>
<a name="ln548">                                       const bool allow_empty,</a>
<a name="ln549">                                       ITR* result) {</a>
<a name="ln550">  CHECK(!delimiters.Test('\\')) &lt;&lt; &quot;\\ is not allowed as a delimiter.&quot;;</a>
<a name="ln551">  CHECK(result);</a>
<a name="ln552">  string part;</a>
<a name="ln553"> </a>
<a name="ln554">  for (uint32 i = 0; i &lt; src.size(); ++i) {</a>
<a name="ln555">    char current_char = src[i];</a>
<a name="ln556">    if (delimiters.Test(current_char)) {</a>
<a name="ln557">      // Push substrings when we encounter delimiters.</a>
<a name="ln558">      if (allow_empty || !part.empty()) {</a>
<a name="ln559">        *(*result)++ = part;</a>
<a name="ln560">        part.clear();</a>
<a name="ln561">      }</a>
<a name="ln562">    } else if (current_char == '\\' &amp;&amp; ++i &lt; src.size()) {</a>
<a name="ln563">      // If we see a backslash, the next delimiter or backslash is literal.</a>
<a name="ln564">      current_char = src[i];</a>
<a name="ln565">      if (current_char != '\\' &amp;&amp; !delimiters.Test(current_char)) {</a>
<a name="ln566">        // Don't honour unknown escape sequences: emit \f for \f.</a>
<a name="ln567">        part.push_back('\\');</a>
<a name="ln568">      }</a>
<a name="ln569">      part.push_back(current_char);</a>
<a name="ln570">    } else {</a>
<a name="ln571">      // Otherwise, we have a normal character or trailing backslash.</a>
<a name="ln572">      part.push_back(current_char);</a>
<a name="ln573">    }</a>
<a name="ln574">  }</a>
<a name="ln575"> </a>
<a name="ln576">  // Push the trailing part.</a>
<a name="ln577">  if (allow_empty || !part.empty()) {</a>
<a name="ln578">    *(*result)++ = part;</a>
<a name="ln579">  }</a>
<a name="ln580">}</a>
<a name="ln581"> </a>
<a name="ln582">void SplitStringWithEscaping(const string &amp;full,</a>
<a name="ln583">                             const strings::CharSet&amp; delimiters,</a>
<a name="ln584">                             vector&lt;string&gt; *result) {</a>
<a name="ln585">  std::back_insert_iterator&lt; vector&lt;string&gt; &gt; it(*result);</a>
<a name="ln586">  SplitStringWithEscapingToIterator(full, delimiters, false, &amp;it);</a>
<a name="ln587">}</a>
<a name="ln588"> </a>
<a name="ln589">void SplitStringWithEscapingAllowEmpty(const string &amp;full,</a>
<a name="ln590">                                       const strings::CharSet&amp; delimiters,</a>
<a name="ln591">                                       vector&lt;string&gt; *result) {</a>
<a name="ln592">  std::back_insert_iterator&lt; vector&lt;string&gt; &gt; it(*result);</a>
<a name="ln593">  SplitStringWithEscapingToIterator(full, delimiters, true, &amp;it);</a>
<a name="ln594">}</a>
<a name="ln595"> </a>
<a name="ln596">void SplitStringWithEscapingToSet(const string &amp;full,</a>
<a name="ln597">                                  const strings::CharSet&amp; delimiters,</a>
<a name="ln598">                                  set&lt;string&gt; *result) {</a>
<a name="ln599">  std::insert_iterator&lt; set&lt;string&gt; &gt; it(*result, result-&gt;end());</a>
<a name="ln600">  SplitStringWithEscapingToIterator(full, delimiters, false, &amp;it);</a>
<a name="ln601">}</a>
<a name="ln602"> </a>
<a name="ln603">void SplitStringWithEscapingToHashset(const string &amp;full,</a>
<a name="ln604">                                      const strings::CharSet&amp; delimiters,</a>
<a name="ln605">                                      hash_set&lt;string&gt; *result) {</a>
<a name="ln606">  std::insert_iterator&lt; hash_set&lt;string&gt; &gt; it(*result, result-&gt;end());</a>
<a name="ln607">  SplitStringWithEscapingToIterator(full, delimiters, false, &amp;it);</a>
<a name="ln608">}</a>
<a name="ln609"> </a>
<a name="ln610"> </a>
<a name="ln611">// ----------------------------------------------------------------------</a>
<a name="ln612">// SplitOneIntToken()</a>
<a name="ln613">// SplitOneInt32Token()</a>
<a name="ln614">// SplitOneUint32Token()</a>
<a name="ln615">// SplitOneInt64Token()</a>
<a name="ln616">// SplitOneUint64Token()</a>
<a name="ln617">// SplitOneDoubleToken()</a>
<a name="ln618">// SplitOneFloatToken()</a>
<a name="ln619">// SplitOneDecimalIntToken()</a>
<a name="ln620">// SplitOneDecimalInt32Token()</a>
<a name="ln621">// SplitOneDecimalUint32Token()</a>
<a name="ln622">// SplitOneDecimalInt64Token()</a>
<a name="ln623">// SplitOneDecimalUint64Token()</a>
<a name="ln624">// SplitOneHexUint32Token()</a>
<a name="ln625">// SplitOneHexUint64Token()</a>
<a name="ln626">//   Mainly a stringified wrapper around strtol/strtoul/strtod</a>
<a name="ln627">// ----------------------------------------------------------------------</a>
<a name="ln628">// Curried functions for the macro below</a>
<a name="ln629">static inline long strto32_0(const char * source, char ** end) {</a>
<a name="ln630">  return strto32(source, end, 0); }</a>
<a name="ln631">static inline unsigned long strtou32_0(const char * source, char ** end) {</a>
<a name="ln632">  return strtou32(source, end, 0); }</a>
<a name="ln633">static inline int64 strto64_0(const char * source, char ** end) {</a>
<a name="ln634">  return strto64(source, end, 0); }</a>
<a name="ln635">static inline uint64 strtou64_0(const char * source, char ** end) {</a>
<a name="ln636">  return strtou64(source, end, 0); }</a>
<a name="ln637">static inline long strto32_10(const char * source, char ** end) {</a>
<a name="ln638">  return strto32(source, end, 10); }</a>
<a name="ln639">static inline unsigned long strtou32_10(const char * source, char ** end) {</a>
<a name="ln640">  return strtou32(source, end, 10); }</a>
<a name="ln641">static inline int64 strto64_10(const char * source, char ** end) {</a>
<a name="ln642">  return strto64(source, end, 10); }</a>
<a name="ln643">static inline uint64 strtou64_10(const char * source, char ** end) {</a>
<a name="ln644">  return strtou64(source, end, 10); }</a>
<a name="ln645">static inline uint32 strtou32_16(const char * source, char ** end) {</a>
<a name="ln646">  return strtou32(source, end, 16); }</a>
<a name="ln647">static inline uint64 strtou64_16(const char * source, char ** end) {</a>
<a name="ln648">  return strtou64(source, end, 16); }</a>
<a name="ln649"> </a>
<a name="ln650">#define DEFINE_SPLIT_ONE_NUMBER_TOKEN(name, type, function) \</a>
<a name="ln651">bool SplitOne##name##Token(const char ** source, const char * delim, \</a>
<a name="ln652">                           type * value) {                      \</a>
<a name="ln653">  assert(source);                                               \</a>
<a name="ln654">  assert(delim);                                                \</a>
<a name="ln655">  assert(value);                                                \</a>
<a name="ln656">  if (!*source)                                                 \</a>
<a name="ln657">    return false;                                               \</a>
<a name="ln658">  /* Parse int */                                               \</a>
<a name="ln659">  char * end;                                                   \</a>
<a name="ln660">  *value = function(*source, &amp;end);                             \</a>
<a name="ln661">  if (end == *source)                                           \</a>
<a name="ln662">    return false; /* number not present at start of string */   \</a>
<a name="ln663">  if (end[0] &amp;&amp; !strchr(delim, end[0]))                         \</a>
<a name="ln664">    return false; /* Garbage characters after int */            \</a>
<a name="ln665">  /* Advance past token */                                      \</a>
<a name="ln666">  if (*end != '\0')                                             \</a>
<a name="ln667">    *source = const_cast&lt;const char *&gt;(end+1);                  \</a>
<a name="ln668">  else                                                          \</a>
<a name="ln669">    *source = NULL;                                             \</a>
<a name="ln670">  return true;                                                  \</a>
<a name="ln671">}</a>
<a name="ln672"> </a>
<a name="ln673">DEFINE_SPLIT_ONE_NUMBER_TOKEN(Int, int, strto32_0)</a>
<a name="ln674">DEFINE_SPLIT_ONE_NUMBER_TOKEN(Int32, int32, strto32_0)</a>
<a name="ln675">DEFINE_SPLIT_ONE_NUMBER_TOKEN(Uint32, uint32, strtou32_0)</a>
<a name="ln676">DEFINE_SPLIT_ONE_NUMBER_TOKEN(Int64, int64, strto64_0)</a>
<a name="ln677">DEFINE_SPLIT_ONE_NUMBER_TOKEN(Uint64, uint64, strtou64_0)</a>
<a name="ln678">DEFINE_SPLIT_ONE_NUMBER_TOKEN(Double, double, strtod)</a>
<a name="ln679">#ifdef _MSC_VER  // has no strtof()</a>
<a name="ln680">// Note: does an implicit cast to float.</a>
<a name="ln681">DEFINE_SPLIT_ONE_NUMBER_TOKEN(Float, float, strtod)</a>
<a name="ln682">#else</a>
<a name="ln683">DEFINE_SPLIT_ONE_NUMBER_TOKEN(Float, float, strtof)</a>
<a name="ln684">#endif</a>
<a name="ln685">DEFINE_SPLIT_ONE_NUMBER_TOKEN(DecimalInt, int, strto32_10)</a>
<a name="ln686">DEFINE_SPLIT_ONE_NUMBER_TOKEN(DecimalInt32, int32, strto32_10)</a>
<a name="ln687">DEFINE_SPLIT_ONE_NUMBER_TOKEN(DecimalUint32, uint32, strtou32_10)</a>
<a name="ln688">DEFINE_SPLIT_ONE_NUMBER_TOKEN(DecimalInt64, int64, strto64_10)</a>
<a name="ln689">DEFINE_SPLIT_ONE_NUMBER_TOKEN(DecimalUint64, uint64, strtou64_10)</a>
<a name="ln690">DEFINE_SPLIT_ONE_NUMBER_TOKEN(HexUint32, uint32, strtou32_16)</a>
<a name="ln691">DEFINE_SPLIT_ONE_NUMBER_TOKEN(HexUint64, uint64, strtou64_16)</a>
<a name="ln692"> </a>
<a name="ln693"> </a>
<a name="ln694">// ----------------------------------------------------------------------</a>
<a name="ln695">// SplitRange()</a>
<a name="ln696">//    Splits a string of the form &quot;&lt;from&gt;-&lt;to&gt;&quot;.  Either or both can be</a>
<a name="ln697">//    missing.  A raw number (&lt;to&gt;) is interpreted as &quot;&lt;to&gt;-&quot;.  Modifies</a>
<a name="ln698">//    parameters insofar as they're specified by the string.  RETURNS</a>
<a name="ln699">//    true iff the input is a well-formed range.  If it RETURNS false,</a>
<a name="ln700">//    from and to remain unchanged.  The range in rangestr should be</a>
<a name="ln701">//    terminated either by &quot;\0&quot; or by whitespace.</a>
<a name="ln702">// ----------------------------------------------------------------------</a>
<a name="ln703"> </a>
<a name="ln704">#define EOS(ch)  ( (ch) == '\0' || ascii_isspace(ch) )</a>
<a name="ln705">bool SplitRange(const char* rangestr, int* from, int* to) {</a>
<a name="ln706">  // We need to do the const-cast because strol takes a char**, not const char**</a>
<a name="ln707">  char* val = const_cast&lt;char*&gt;(rangestr);</a>
<a name="ln708">  if (val == nullptr || EOS(*val))  return true;  // we'll say nothingness is ok</a>
<a name="ln709"> </a>
<a name="ln710">  if ( val[0] == '-' &amp;&amp; EOS(val[1]) )    // CASE 1: -</a>
<a name="ln711">    return true;                         // nothing changes</a>
<a name="ln712"> </a>
<a name="ln713">  if ( val[0] == '-' ) {                 // CASE 2: -&lt;i2&gt;</a>
<a name="ln714">    const int int2 = strto32(val+1, &amp;val, 10);</a>
<a name="ln715">    if ( !EOS(*val) )  return false;     // not a valid integer</a>
<a name="ln716">    *to = int2;                          // only &quot;to&quot; changes</a>
<a name="ln717">    return true;</a>
<a name="ln718"> </a>
<a name="ln719">  } else {</a>
<a name="ln720">    const int int1 = strto32(val, &amp;val, 10);</a>
<a name="ln721">    if ( EOS(*val) || (*val == '-' &amp;&amp; EOS(*(val+1))) ) {</a>
<a name="ln722">      *from = int1;                      // CASE 3: &lt;i1&gt;, same as &lt;i1&gt;-</a>
<a name="ln723">      return true;                       // only &quot;from&quot; changes</a>
<a name="ln724">    } else if (*val != '-') {            // not a valid range</a>
<a name="ln725">      return false;</a>
<a name="ln726">    }</a>
<a name="ln727">    const int int2 = strto32(val+1, &amp;val, 10);</a>
<a name="ln728">    if ( !EOS(*val) )  return false;     // not a valid integer</a>
<a name="ln729">    *from = int1;                        // CASE 4: &lt;i1&gt;-&lt;i2&gt;</a>
<a name="ln730">    *to = int2;</a>
<a name="ln731">    return true;</a>
<a name="ln732">  }</a>
<a name="ln733">}</a>
<a name="ln734"> </a>
<a name="ln735">void SplitCSVLineWithDelimiter(char* line, char delimiter,</a>
<a name="ln736">                               vector&lt;char*&gt;* cols) {</a>
<a name="ln737">  char* end_of_line = line + strlen(line);</a>
<a name="ln738">  char* end;</a>
<a name="ln739">  char* start;</a>
<a name="ln740"> </a>
<a name="ln741">  for (; line &lt; end_of_line; line++) {</a>
<a name="ln742">    // Skip leading whitespace, unless said whitespace is the delimiter.</a>
<a name="ln743">    while (ascii_isspace(*line) &amp;&amp; *line != delimiter)</a>
<a name="ln744">      ++line;</a>
<a name="ln745"> </a>
<a name="ln746">    if (*line == '&quot;' &amp;&amp; delimiter == ',') {     // Quoted value...</a>
<a name="ln747">      start = ++line;</a>
<a name="ln748">      end = start;</a>
<a name="ln749">      for (; *line; line++) {</a>
<a name="ln750">        if (*line == '&quot;') {</a>
<a name="ln751">          line++;</a>
<a name="ln752">          if (*line != '&quot;')  // [&quot;&quot;] is an escaped [&quot;]</a>
<a name="ln753">            break;           // but just [&quot;] is end of value</a>
<a name="ln754">        }</a>
<a name="ln755">        *end++ = *line;</a>
<a name="ln756">      }</a>
<a name="ln757">      // All characters after the closing quote and before the comma</a>
<a name="ln758">      // are ignored.</a>
<a name="ln759">      line = strchr(line, delimiter);</a>
<a name="ln760">      if (!line) line = end_of_line;</a>
<a name="ln761">    } else {</a>
<a name="ln762">      start = line;</a>
<a name="ln763">      line = strchr(line, delimiter);</a>
<a name="ln764">      if (!line) line = end_of_line;</a>
<a name="ln765">      // Skip all trailing whitespace, unless said whitespace is the delimiter.</a>
<a name="ln766">      for (end = line; end &gt; start; --end) {</a>
<a name="ln767">        if (!ascii_isspace(end[-1]) || end[-1] == delimiter)</a>
<a name="ln768">          break;</a>
<a name="ln769">      }</a>
<a name="ln770">    }</a>
<a name="ln771">    const bool need_another_column =</a>
<a name="ln772">      (*line == delimiter) &amp;&amp; (line == end_of_line - 1);</a>
<a name="ln773">    *end = '\0';</a>
<a name="ln774">    cols-&gt;push_back(start);</a>
<a name="ln775">    // If line was something like [paul,] (comma is the last character</a>
<a name="ln776">    // and is not proceeded by whitespace or quote) then we are about</a>
<a name="ln777">    // to eliminate the last column (which is empty). This would be</a>
<a name="ln778">    // incorrect.</a>
<a name="ln779">    if (need_another_column)</a>
<a name="ln780">      cols-&gt;push_back(end);</a>
<a name="ln781"> </a>
<a name="ln782">    assert(*line == '\0' || *line == delimiter);</a>
<a name="ln783">  }</a>
<a name="ln784">}</a>
<a name="ln785"> </a>
<a name="ln786">void SplitCSVLine(char* line, vector&lt;char*&gt;* cols) {</a>
<a name="ln787">  SplitCSVLineWithDelimiter(line, ',', cols);</a>
<a name="ln788">}</a>
<a name="ln789"> </a>
<a name="ln790">void SplitCSVLineWithDelimiterForStrings(const string &amp;line,</a>
<a name="ln791">                                         char delimiter,</a>
<a name="ln792">                                         vector&lt;string&gt; *cols) {</a>
<a name="ln793">  // Unfortunately, the interface requires char* instead of const char*</a>
<a name="ln794">  // which requires copying the string.</a>
<a name="ln795">  char *cline = strndup_with_new(line.c_str(), line.size());</a>
<a name="ln796">  vector&lt;char *&gt; v;</a>
<a name="ln797">  SplitCSVLineWithDelimiter(cline, delimiter, &amp;v);</a>
<a name="ln798">  for (vector&lt;char*&gt;::const_iterator ci = v.begin(); ci != v.end(); ++ci) {</a>
<a name="ln799">    cols-&gt;push_back(*ci);</a>
<a name="ln800">  }</a>
<a name="ln801">  delete[] cline;</a>
<a name="ln802">}</a>
<a name="ln803"> </a>
<a name="ln804">// ----------------------------------------------------------------------</a>
<a name="ln805">namespace {</a>
<a name="ln806"> </a>
<a name="ln807">// Helper class used by SplitStructuredLineInternal.</a>
<a name="ln808">class ClosingSymbolLookup {</a>
<a name="ln809"> public:</a>
<a name="ln810">  explicit ClosingSymbolLookup(const char* symbol_pairs)</a>
<a name="ln811">      : closing_(),</a>
<a name="ln812">        valid_closing_() {</a>
<a name="ln813">    // Initialize the opening/closing arrays.</a>
<a name="ln814">    for (const char* symbol = symbol_pairs; *symbol != 0; ++symbol) {</a>
<a name="ln815">      unsigned char opening = *symbol;</a>
<a name="ln816">      ++symbol;</a>
<a name="ln817">      // If the string ends before the closing character has been found,</a>
<a name="ln818">      // use the opening character as the closing character.</a>
<a name="ln819">      unsigned char closing = *symbol != 0 ? *symbol : opening;</a>
<a name="ln820">      closing_[opening] = closing;</a>
<a name="ln821">      valid_closing_[closing] = true;</a>
<a name="ln822">      if (*symbol == 0) break;</a>
<a name="ln823">    }</a>
<a name="ln824">  }</a>
<a name="ln825"> </a>
<a name="ln826">  // Returns the closing character corresponding to an opening one,</a>
<a name="ln827">  // or 0 if the argument is not an opening character.</a>
<a name="ln828">  char GetClosingChar(char opening) const {</a>
<a name="ln829">    return closing_[static_cast&lt;unsigned char&gt;(opening)];</a>
<a name="ln830">  }</a>
<a name="ln831"> </a>
<a name="ln832">  // Returns true if the argument is a closing character.</a>
<a name="ln833">  bool IsClosing(char c) const {</a>
<a name="ln834">    return valid_closing_[static_cast&lt;unsigned char&gt;(c)];</a>
<a name="ln835">  }</a>
<a name="ln836"> </a>
<a name="ln837"> private:</a>
<a name="ln838">  // Maps an opening character to its closing. If the entry contains 0,</a>
<a name="ln839">  // the character is not in the opening set.</a>
<a name="ln840">  char closing_[256];</a>
<a name="ln841">  // Valid closing characters.</a>
<a name="ln842">  bool valid_closing_[256];</a>
<a name="ln843"> </a>
<a name="ln844">  DISALLOW_COPY_AND_ASSIGN(ClosingSymbolLookup);</a>
<a name="ln845">};</a>
<a name="ln846"> </a>
<a name="ln847">char* SplitStructuredLineInternal(char* line,</a>
<a name="ln848">                                  char delimiter,</a>
<a name="ln849">                                  const char* symbol_pairs,</a>
<a name="ln850">                                  vector&lt;char*&gt;* cols,</a>
<a name="ln851">                                  bool with_escapes) {</a>
<a name="ln852">  ClosingSymbolLookup lookup(symbol_pairs);</a>
<a name="ln853"> </a>
<a name="ln854">  // Stack of symbols expected to close the current opened expressions.</a>
<a name="ln855">  vector&lt;char&gt; expected_to_close;</a>
<a name="ln856">  bool in_escape = false;</a>
<a name="ln857"> </a>
<a name="ln858">  CHECK(cols);</a>
<a name="ln859">  cols-&gt;push_back(line);</a>
<a name="ln860">  char* current;</a>
<a name="ln861">  for (current = line; *current; ++current) {</a>
<a name="ln862">    char c = *current;</a>
<a name="ln863">    if (in_escape) {</a>
<a name="ln864">      in_escape = false;</a>
<a name="ln865">    } else if (with_escapes &amp;&amp; c == '\\') {</a>
<a name="ln866">      // We are escaping the next character. Note the escape still appears</a>
<a name="ln867">      // in the output.</a>
<a name="ln868">      in_escape = true;</a>
<a name="ln869">    } else if (expected_to_close.empty() &amp;&amp; c == delimiter) {</a>
<a name="ln870">      // We don't have any open expression, this is a valid separator.</a>
<a name="ln871">      *current = 0;</a>
<a name="ln872">      cols-&gt;push_back(current + 1);</a>
<a name="ln873">    } else if (!expected_to_close.empty() &amp;&amp; c == expected_to_close.back()) {</a>
<a name="ln874">      // Can we close the currently open expression?</a>
<a name="ln875">      expected_to_close.pop_back();</a>
<a name="ln876">    } else if (lookup.GetClosingChar(c)) {</a>
<a name="ln877">      // If this is an opening symbol, we open a new expression and push</a>
<a name="ln878">      // the expected closing symbol on the stack.</a>
<a name="ln879">      expected_to_close.push_back(lookup.GetClosingChar(c));</a>
<a name="ln880">    } else if (lookup.IsClosing(c)) {</a>
<a name="ln881">      // Error: mismatched closing symbol.</a>
<a name="ln882">      return current;</a>
<a name="ln883">    }</a>
<a name="ln884">  }</a>
<a name="ln885">  if (!expected_to_close.empty()) {</a>
<a name="ln886">    return current;  // Missing closing symbol(s)</a>
<a name="ln887">  }</a>
<a name="ln888">  return nullptr;  // Success</a>
<a name="ln889">}</a>
<a name="ln890"> </a>
<a name="ln891">bool SplitStructuredLineInternal(GStringPiece line,</a>
<a name="ln892">                                 char delimiter,</a>
<a name="ln893">                                 const char* symbol_pairs,</a>
<a name="ln894">                                 vector&lt;GStringPiece&gt;* cols,</a>
<a name="ln895">                                 bool with_escapes) {</a>
<a name="ln896">  ClosingSymbolLookup lookup(symbol_pairs);</a>
<a name="ln897"> </a>
<a name="ln898">  // Stack of symbols expected to close the current opened expressions.</a>
<a name="ln899">  vector&lt;char&gt; expected_to_close;</a>
<a name="ln900">  bool in_escape = false;</a>
<a name="ln901"> </a>
<a name="ln902">  CHECK_NOTNULL(cols);</a>
<a name="ln903">  cols-&gt;push_back(line);</a>
<a name="ln904">  for (int i = 0; i &lt; line.size(); ++i) {</a>
<a name="ln905">    char c = line[i];</a>
<a name="ln906">    if (in_escape) {</a>
<a name="ln907">      in_escape = false;</a>
<a name="ln908">    } else if (with_escapes &amp;&amp; c == '\\') {</a>
<a name="ln909">      // We are escaping the next character. Note the escape still appears</a>
<a name="ln910">      // in the output.</a>
<a name="ln911">      in_escape = true;</a>
<a name="ln912">    } else if (expected_to_close.empty() &amp;&amp; c == delimiter) {</a>
<a name="ln913">      // We don't have any open expression, this is a valid separator.</a>
<a name="ln914">      cols-&gt;back().remove_suffix(line.size() - i);</a>
<a name="ln915">      cols-&gt;push_back(GStringPiece(line, i + 1));</a>
<a name="ln916">    } else if (!expected_to_close.empty() &amp;&amp; c == expected_to_close.back()) {</a>
<a name="ln917">      // Can we close the currently open expression?</a>
<a name="ln918">      expected_to_close.pop_back();</a>
<a name="ln919">    } else if (lookup.GetClosingChar(c)) {</a>
<a name="ln920">      // If this is an opening symbol, we open a new expression and push</a>
<a name="ln921">      // the expected closing symbol on the stack.</a>
<a name="ln922">      expected_to_close.push_back(lookup.GetClosingChar(c));</a>
<a name="ln923">    } else if (lookup.IsClosing(c)) {</a>
<a name="ln924">      // Error: mismatched closing symbol.</a>
<a name="ln925">      return false;</a>
<a name="ln926">    }</a>
<a name="ln927">  }</a>
<a name="ln928">  if (!expected_to_close.empty()) {</a>
<a name="ln929">    return false;  // Missing closing symbol(s)</a>
<a name="ln930">  }</a>
<a name="ln931">  return true;  // Success</a>
<a name="ln932">}</a>
<a name="ln933"> </a>
<a name="ln934">}  // anonymous namespace</a>
<a name="ln935"> </a>
<a name="ln936">char* SplitStructuredLine(char* line,</a>
<a name="ln937">                          char delimiter,</a>
<a name="ln938">                          const char *symbol_pairs,</a>
<a name="ln939">                          vector&lt;char*&gt;* cols) {</a>
<a name="ln940">  return SplitStructuredLineInternal(line, delimiter, symbol_pairs, cols,</a>
<a name="ln941">                                     false);</a>
<a name="ln942">}</a>
<a name="ln943"> </a>
<a name="ln944">bool SplitStructuredLine(GStringPiece line,</a>
<a name="ln945">                         char delimiter,</a>
<a name="ln946">                         const char* symbol_pairs,</a>
<a name="ln947">                         vector&lt;GStringPiece&gt;* cols) {</a>
<a name="ln948">  return SplitStructuredLineInternal(line, delimiter, symbol_pairs, cols,</a>
<a name="ln949">                                     false);</a>
<a name="ln950">}</a>
<a name="ln951"> </a>
<a name="ln952">char* SplitStructuredLineWithEscapes(char* line,</a>
<a name="ln953">                                     char delimiter,</a>
<a name="ln954">                                     const char *symbol_pairs,</a>
<a name="ln955">                                     vector&lt;char*&gt;* cols) {</a>
<a name="ln956">  return SplitStructuredLineInternal(line, delimiter, symbol_pairs, cols,</a>
<a name="ln957">                                     true);</a>
<a name="ln958">}</a>
<a name="ln959"> </a>
<a name="ln960">bool SplitStructuredLineWithEscapes(GStringPiece line,</a>
<a name="ln961">                                     char delimiter,</a>
<a name="ln962">                                     const char* symbol_pairs,</a>
<a name="ln963">                                     vector&lt;GStringPiece&gt;* cols) {</a>
<a name="ln964">  return SplitStructuredLineInternal(line, delimiter, symbol_pairs, cols,</a>
<a name="ln965">                                     true);</a>
<a name="ln966">}</a>
<a name="ln967"> </a>
<a name="ln968"> </a>
<a name="ln969">// ----------------------------------------------------------------------</a>
<a name="ln970">// SplitStringIntoKeyValues()</a>
<a name="ln971">// ----------------------------------------------------------------------</a>
<a name="ln972">bool SplitStringIntoKeyValues(const string&amp; line,</a>
<a name="ln973">                              const string&amp; key_value_delimiters,</a>
<a name="ln974">                              const string&amp; value_value_delimiters,</a>
<a name="ln975">                              string *key, vector&lt;string&gt; *values) {</a>
<a name="ln976">  key-&gt;clear();</a>
<a name="ln977">  values-&gt;clear();</a>
<a name="ln978"> </a>
<a name="ln979">  // find the key string</a>
<a name="ln980">  size_t end_key_pos = line.find_first_of(key_value_delimiters);</a>
<a name="ln981">  if (end_key_pos == string::npos) {</a>
<a name="ln982">    VLOG(1) &lt;&lt; &quot;cannot parse key from line: &quot; &lt;&lt; line;</a>
<a name="ln983">    return false;    // no key</a>
<a name="ln984">  }</a>
<a name="ln985">  key-&gt;assign(line, 0, end_key_pos);</a>
<a name="ln986"> </a>
<a name="ln987">  // find the values string</a>
<a name="ln988">  string remains(line, end_key_pos, line.size() - end_key_pos);</a>
<a name="ln989">  size_t begin_values_pos = remains.find_first_not_of(key_value_delimiters);</a>
<a name="ln990">  if (begin_values_pos == string::npos) {</a>
<a name="ln991">    VLOG(1) &lt;&lt; &quot;cannot parse value from line: &quot; &lt;&lt; line;</a>
<a name="ln992">    return false;   // no value</a>
<a name="ln993">  }</a>
<a name="ln994">  string values_string(remains,</a>
<a name="ln995">                       begin_values_pos,</a>
<a name="ln996">                       remains.size() - begin_values_pos);</a>
<a name="ln997"> </a>
<a name="ln998">  // construct the values vector</a>
<a name="ln999">  if (value_value_delimiters.empty()) {  // one value</a>
<a name="ln1000">    values-&gt;push_back(values_string);</a>
<a name="ln1001">  } else {                               // multiple values</a>
<a name="ln1002">    SplitStringUsing(values_string, value_value_delimiters.c_str(), values);</a>
<a name="ln1003">    if (values-&gt;size() &lt; 1) {</a>
<a name="ln1004">      VLOG(1) &lt;&lt; &quot;cannot parse value from line: &quot; &lt;&lt; line;</a>
<a name="ln1005">      return false;  // no value</a>
<a name="ln1006">    }</a>
<a name="ln1007">  }</a>
<a name="ln1008">  return true;</a>
<a name="ln1009">}</a>
<a name="ln1010"> </a>
<a name="ln1011">bool SplitStringIntoKeyValuePairs(const string&amp; line,</a>
<a name="ln1012">                                  const string&amp; key_value_delimiters,</a>
<a name="ln1013">                                  const string&amp; key_value_pair_delimiters,</a>
<a name="ln1014">                                  vector&lt;pair&lt;string, string&gt; &gt;* kv_pairs) {</a>
<a name="ln1015">  kv_pairs-&gt;clear();</a>
<a name="ln1016"> </a>
<a name="ln1017">  vector&lt;string&gt; pairs;</a>
<a name="ln1018">  SplitStringUsing(line, key_value_pair_delimiters.c_str(), &amp;pairs);</a>
<a name="ln1019"> </a>
<a name="ln1020">  bool success = true;</a>
<a name="ln1021">  for (const auto&amp; pair : pairs) {</a>
<a name="ln1022">    string key;</a>
<a name="ln1023">    vector&lt;string&gt; value;</a>
<a name="ln1024">    if (!SplitStringIntoKeyValues(pair,</a>
<a name="ln1025">                                  key_value_delimiters,</a>
<a name="ln1026">                                  &quot;&quot;, &amp;key, &amp;value)) {</a>
<a name="ln1027">      // Don't return here, to allow for keys without associated</a>
<a name="ln1028">      // values; just record that our split failed.</a>
<a name="ln1029">      success = false;</a>
<a name="ln1030">    }</a>
<a name="ln1031">    // we expect atmost one value because we passed in an empty vsep to</a>
<a name="ln1032">    // SplitStringIntoKeyValues</a>
<a name="ln1033">    DCHECK_LE(value.size(), 1);</a>
<a name="ln1034">    kv_pairs-&gt;push_back(make_pair(key, value.empty()? &quot;&quot; : value[0]));</a>
<a name="ln1035">  }</a>
<a name="ln1036">  return success;</a>
<a name="ln1037">}</a>
<a name="ln1038"> </a>
<a name="ln1039">// ----------------------------------------------------------------------</a>
<a name="ln1040">// SplitLeadingDec32Values()</a>
<a name="ln1041">// SplitLeadingDec64Values()</a>
<a name="ln1042">//    A simple parser for space-separated decimal int32/int64 values.</a>
<a name="ln1043">//    Appends parsed integers to the end of the result vector, stopping</a>
<a name="ln1044">//    at the first unparsable spot.  Skips past leading and repeated</a>
<a name="ln1045">//    whitespace (does not consume trailing whitespace), and returns</a>
<a name="ln1046">//    a pointer beyond the last character parsed.</a>
<a name="ln1047">// --------------------------------------------------------------------</a>
<a name="ln1048">const char* SplitLeadingDec32Values(const char *str, vector&lt;int32&gt; *result) {</a>
<a name="ln1049">  for (;;) {</a>
<a name="ln1050">    char *end = nullptr;</a>
<a name="ln1051">    long value = strtol(str, &amp;end, 10);</a>
<a name="ln1052">    if (end == str)</a>
<a name="ln1053">      break;</a>
<a name="ln1054">    // Limit long values to int32 min/max.  Needed for lp64.</a>
<a name="ln1055">    if (value &gt; numeric_limits&lt;int32&gt;::max()) {</a>
<a name="ln1056">      value = numeric_limits&lt;int32&gt;::max();</a>
<a name="ln1057">    } else if (value &lt; numeric_limits&lt;int32&gt;::min()) {</a>
<a name="ln1058">      value = numeric_limits&lt;int32&gt;::min();</a>
<a name="ln1059">    }</a>
<a name="ln1060">    result-&gt;push_back(value);</a>
<a name="ln1061">    str = end;</a>
<a name="ln1062">    if (!ascii_isspace(*end))</a>
<a name="ln1063">      break;</a>
<a name="ln1064">  }</a>
<a name="ln1065">  return str;</a>
<a name="ln1066">}</a>
<a name="ln1067"> </a>
<a name="ln1068">const char* SplitLeadingDec64Values(const char *str, vector&lt;int64&gt; *result) {</a>
<a name="ln1069">  for (;;) {</a>
<a name="ln1070">    char *end = nullptr;</a>
<a name="ln1071">    const int64 value = strtoll(str, &amp;end, 10);</a>
<a name="ln1072">    if (end == str)</a>
<a name="ln1073">      break;</a>
<a name="ln1074">    result-&gt;push_back(value);</a>
<a name="ln1075">    str = end;</a>
<a name="ln1076">    if (!ascii_isspace(*end))</a>
<a name="ln1077">      break;</a>
<a name="ln1078">  }</a>
<a name="ln1079">  return str;</a>
<a name="ln1080">}</a>
<a name="ln1081"> </a>
<a name="ln1082">void SplitStringToLines(const char* full,</a>
<a name="ln1083">                        int max_len,</a>
<a name="ln1084">                        int num_lines,</a>
<a name="ln1085">                        vector&lt;string&gt;* result) {</a>
<a name="ln1086">  if (max_len &lt;= 0) {</a>
<a name="ln1087">    return;</a>
<a name="ln1088">  }</a>
<a name="ln1089">  int pos = 0;</a>
<a name="ln1090">  for (int i = 0; (i &lt; num_lines || num_lines &lt;= 0); i++) {</a>
<a name="ln1091">    int cut_at = ClipStringHelper(full+pos, max_len, (i == num_lines - 1));</a>
<a name="ln1092">    if (cut_at == -1) {</a>
<a name="ln1093">      result-&gt;push_back(string(full+pos));</a>
<a name="ln1094">      return;</a>
<a name="ln1095">    }</a>
<a name="ln1096">    result-&gt;push_back(string(full+pos, cut_at));</a>
<a name="ln1097">    if (i == num_lines - 1 &amp;&amp; max_len &gt; kCutStrSize) {</a>
<a name="ln1098">      result-&gt;at(i).append(kCutStr);</a>
<a name="ln1099">    }</a>
<a name="ln1100">    pos += cut_at;</a>
<a name="ln1101">  }</a>
<a name="ln1102">}</a>

</code></pre>
<div class="balloon" rel="550"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="551"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="858"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="859"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1004/" target="_blank">V1004</a> The 'cols' pointer was used unsafely after it was verified against nullptr. Check lines: 858, 859.</p></div>
<div class="balloon" rel="982"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="991"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1004"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
