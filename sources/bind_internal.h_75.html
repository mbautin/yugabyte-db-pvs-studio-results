
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>bind_internal.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This file was GENERATED by command:</a>
<a name="ln2">//     pump.py bind_internal.h.pump</a>
<a name="ln3">// DO NOT EDIT BY HAND!!!</a>
<a name="ln4"> </a>
<a name="ln5"> </a>
<a name="ln6">// Copyright (c) 2011 The Chromium Authors. All rights reserved.</a>
<a name="ln7">// Use of this source code is governed by a BSD-style license that can be</a>
<a name="ln8">// found in the LICENSE file.</a>
<a name="ln9">//</a>
<a name="ln10">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln11">//</a>
<a name="ln12">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln13">//</a>
<a name="ln14">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln15">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln16">//</a>
<a name="ln17">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln18">//</a>
<a name="ln19">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln20">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln21">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln22">// under the License.</a>
<a name="ln23">//</a>
<a name="ln24"> </a>
<a name="ln25">#ifndef YB_GUTIL_BIND_INTERNAL_H_</a>
<a name="ln26">#define YB_GUTIL_BIND_INTERNAL_H_</a>
<a name="ln27"> </a>
<a name="ln28">#include &quot;yb/gutil/bind_helpers.h&quot;</a>
<a name="ln29">#include &quot;yb/gutil/callback_internal.h&quot;</a>
<a name="ln30">#include &quot;yb/gutil/raw_scoped_refptr_mismatch_checker.h&quot;</a>
<a name="ln31">#include &quot;yb/gutil/template_util.h&quot;</a>
<a name="ln32"> </a>
<a name="ln33">#if defined(OS_WIN)</a>
<a name="ln34">#include &quot;yb/gutil/bind_internal_win.h&quot;</a>
<a name="ln35">#endif</a>
<a name="ln36"> </a>
<a name="ln37">// During Chromium import, WeakPtr-related code was removed.</a>
<a name="ln38"> </a>
<a name="ln39">namespace yb {</a>
<a name="ln40">namespace internal {</a>
<a name="ln41"> </a>
<a name="ln42">// See yb/gutil/callback.h for user documentation.</a>
<a name="ln43">//</a>
<a name="ln44">//</a>
<a name="ln45">// CONCEPTS:</a>
<a name="ln46">//  Runnable -- A type (really a type class) that has a single Run() method</a>
<a name="ln47">//              and a RunType typedef that corresponds to the type of Run().</a>
<a name="ln48">//              A Runnable can declare that it should treated like a method</a>
<a name="ln49">//              call by including a typedef named IsMethod.  The value of</a>
<a name="ln50">//              this typedef is NOT inspected, only the existence.  When a</a>
<a name="ln51">//              Runnable declares itself a method, Bind() will enforce special</a>
<a name="ln52">//              refcounting + WeakPtr handling semantics for the first</a>
<a name="ln53">//              parameter which is expected to be an object.</a>
<a name="ln54">//  Functor -- A copyable type representing something that should be called.</a>
<a name="ln55">//             All function pointers, Callback&lt;&gt;, and Runnables are functors</a>
<a name="ln56">//             even if the invocation syntax differs.</a>
<a name="ln57">//  RunType -- A function type (as opposed to function _pointer_ type) for</a>
<a name="ln58">//             a Run() function.  Usually just a convenience typedef.</a>
<a name="ln59">//  (Bound)ArgsType -- A function type that is being (ab)used to store the</a>
<a name="ln60">//                     types of set of arguments.  The &quot;return&quot; type is always</a>
<a name="ln61">//                     void here.  We use this hack so that we do not need</a>
<a name="ln62">//                     a new type name for each arity of type. (eg.,</a>
<a name="ln63">//                     BindState1, BindState2).  This makes forward</a>
<a name="ln64">//                     declarations and friending much much easier.</a>
<a name="ln65">//</a>
<a name="ln66">// Types:</a>
<a name="ln67">//  RunnableAdapter&lt;&gt; -- Wraps the various &quot;function&quot; pointer types into an</a>
<a name="ln68">//                       object that adheres to the Runnable interface.</a>
<a name="ln69">//                       There are |3*ARITY| RunnableAdapter types.</a>
<a name="ln70">//  FunctionTraits&lt;&gt; -- Type traits that unwrap a function signature into a</a>
<a name="ln71">//                      a set of easier to use typedefs.  Used mainly for</a>
<a name="ln72">//                      compile time asserts.</a>
<a name="ln73">//                      There are |ARITY| FunctionTraits types.</a>
<a name="ln74">//  ForceVoidReturn&lt;&gt; -- Helper class for translating function signatures to</a>
<a name="ln75">//                       equivalent forms with a &quot;void&quot; return type.</a>
<a name="ln76">//                    There are |ARITY| ForceVoidReturn types.</a>
<a name="ln77">//  FunctorTraits&lt;&gt; -- Type traits used determine the correct RunType and</a>
<a name="ln78">//                     RunnableType for a Functor.  This is where function</a>
<a name="ln79">//                     signature adapters are applied.</a>
<a name="ln80">//                    There are |ARITY| ForceVoidReturn types.</a>
<a name="ln81">//  MakeRunnable&lt;&gt; -- Takes a Functor and returns an object in the Runnable</a>
<a name="ln82">//                    type class that represents the underlying Functor.</a>
<a name="ln83">//                    There are |O(1)| MakeRunnable types.</a>
<a name="ln84">//  InvokeHelper&lt;&gt; -- Take a Runnable + arguments and actully invokes it.</a>
<a name="ln85">// Handle the differing syntaxes needed for WeakPtr&lt;&gt; support,</a>
<a name="ln86">//                    and for ignoring return values.  This is separate from</a>
<a name="ln87">//                    Invoker to avoid creating multiple version of Invoker&lt;&gt;</a>
<a name="ln88">//                    which grows at O(n^2) with the arity.</a>
<a name="ln89">//                    There are |k*ARITY| InvokeHelper types.</a>
<a name="ln90">//  Invoker&lt;&gt; -- Unwraps the curried parameters and executes the Runnable.</a>
<a name="ln91">//               There are |(ARITY^2 + ARITY)/2| Invoketypes.</a>
<a name="ln92">//  BindState&lt;&gt; -- Stores the curried parameters, and is the main entry point</a>
<a name="ln93">//                 into the Bind() system, doing most of the type resolution.</a>
<a name="ln94">//                 There are ARITY BindState types.</a>
<a name="ln95"> </a>
<a name="ln96">// RunnableAdapter&lt;&gt;</a>
<a name="ln97">//</a>
<a name="ln98">// The RunnableAdapter&lt;&gt; templates provide a uniform interface for invoking</a>
<a name="ln99">// a function pointer, method pointer, or const method pointer. The adapter</a>
<a name="ln100">// exposes a Run() method with an appropriate signature. Using this wrapper</a>
<a name="ln101">// allows for writing code that supports all three pointer types without</a>
<a name="ln102">// undue repetition.  Without it, a lot of code would need to be repeated 3</a>
<a name="ln103">// times.</a>
<a name="ln104">//</a>
<a name="ln105">// For method pointers and const method pointers the first argument to Run()</a>
<a name="ln106">// is considered to be the received of the method.  This is similar to STL's</a>
<a name="ln107">// mem_fun().</a>
<a name="ln108">//</a>
<a name="ln109">// This class also exposes a RunType typedef that is the function type of the</a>
<a name="ln110">// Run() function.</a>
<a name="ln111">//</a>
<a name="ln112">// If and only if the wrapper contains a method or const method pointer, an</a>
<a name="ln113">// IsMethod typedef is exposed.  The existence of this typedef (NOT the value)</a>
<a name="ln114">// marks that the wrapper should be considered a method wrapper.</a>
<a name="ln115"> </a>
<a name="ln116">template &lt;typename Functor&gt;</a>
<a name="ln117">class RunnableAdapter;</a>
<a name="ln118"> </a>
<a name="ln119">// Function: Arity 0.</a>
<a name="ln120">template &lt;typename R&gt;</a>
<a name="ln121">class RunnableAdapter&lt;R(*)()&gt; {</a>
<a name="ln122"> public:</a>
<a name="ln123">  typedef R (RunType)();</a>
<a name="ln124"> </a>
<a name="ln125">  explicit RunnableAdapter(R(*function)())</a>
<a name="ln126">      : function_(function) {</a>
<a name="ln127">  }</a>
<a name="ln128"> </a>
<a name="ln129">  R Run() {</a>
<a name="ln130">    return function_();</a>
<a name="ln131">  }</a>
<a name="ln132"> </a>
<a name="ln133"> private:</a>
<a name="ln134">  R (*function_)();</a>
<a name="ln135">};</a>
<a name="ln136"> </a>
<a name="ln137">// Method: Arity 0.</a>
<a name="ln138">template &lt;typename R, typename T&gt;</a>
<a name="ln139">class RunnableAdapter&lt;R(T::*)()&gt; {</a>
<a name="ln140"> public:</a>
<a name="ln141">  typedef R (RunType)(T*);</a>
<a name="ln142">  typedef base::true_type IsMethod;</a>
<a name="ln143"> </a>
<a name="ln144">  explicit RunnableAdapter(R(T::*method)())</a>
<a name="ln145">      : method_(method) {</a>
<a name="ln146">  }</a>
<a name="ln147"> </a>
<a name="ln148">  R Run(T* object) {</a>
<a name="ln149">    return (object-&gt;*method_)();</a>
<a name="ln150">  }</a>
<a name="ln151"> </a>
<a name="ln152"> private:</a>
<a name="ln153">  R (T::*method_)();</a>
<a name="ln154">};</a>
<a name="ln155"> </a>
<a name="ln156">// Const Method: Arity 0.</a>
<a name="ln157">template &lt;typename R, typename T&gt;</a>
<a name="ln158">class RunnableAdapter&lt;R(T::*)() const&gt; {</a>
<a name="ln159"> public:</a>
<a name="ln160">  typedef R (RunType)(const T*);</a>
<a name="ln161">  typedef base::true_type IsMethod;</a>
<a name="ln162"> </a>
<a name="ln163">  explicit RunnableAdapter(R(T::*method)() const)</a>
<a name="ln164">      : method_(method) {</a>
<a name="ln165">  }</a>
<a name="ln166"> </a>
<a name="ln167">  R Run(const T* object) {</a>
<a name="ln168">    return (object-&gt;*method_)();</a>
<a name="ln169">  }</a>
<a name="ln170"> </a>
<a name="ln171"> private:</a>
<a name="ln172">  R (T::*method_)() const;</a>
<a name="ln173">};</a>
<a name="ln174"> </a>
<a name="ln175">// Function: Arity 1.</a>
<a name="ln176">template &lt;typename R, typename A1&gt;</a>
<a name="ln177">class RunnableAdapter&lt;R(*)(A1)&gt; {</a>
<a name="ln178"> public:</a>
<a name="ln179">  typedef R (RunType)(A1);</a>
<a name="ln180"> </a>
<a name="ln181">  explicit RunnableAdapter(R(*function)(A1))</a>
<a name="ln182">      : function_(function) {</a>
<a name="ln183">  }</a>
<a name="ln184"> </a>
<a name="ln185">  R Run(typename CallbackParamTraits&lt;A1&gt;::ForwardType a1) {</a>
<a name="ln186">    return function_(CallbackForward(a1));</a>
<a name="ln187">  }</a>
<a name="ln188"> </a>
<a name="ln189"> private:</a>
<a name="ln190">  R (*function_)(A1);</a>
<a name="ln191">};</a>
<a name="ln192"> </a>
<a name="ln193">// Method: Arity 1.</a>
<a name="ln194">template &lt;typename R, typename T, typename A1&gt;</a>
<a name="ln195">class RunnableAdapter&lt;R(T::*)(A1)&gt; {</a>
<a name="ln196"> public:</a>
<a name="ln197">  typedef R (RunType)(T*, A1);</a>
<a name="ln198">  typedef base::true_type IsMethod;</a>
<a name="ln199"> </a>
<a name="ln200">  explicit RunnableAdapter(R(T::*method)(A1))</a>
<a name="ln201">      : method_(method) {</a>
<a name="ln202">  }</a>
<a name="ln203"> </a>
<a name="ln204">  R Run(T* object, typename CallbackParamTraits&lt;A1&gt;::ForwardType a1) {</a>
<a name="ln205">    return (object-&gt;*method_)(CallbackForward(a1));</a>
<a name="ln206">  }</a>
<a name="ln207"> </a>
<a name="ln208"> private:</a>
<a name="ln209">  R (T::*method_)(A1);</a>
<a name="ln210">};</a>
<a name="ln211"> </a>
<a name="ln212">// Const Method: Arity 1.</a>
<a name="ln213">template &lt;typename R, typename T, typename A1&gt;</a>
<a name="ln214">class RunnableAdapter&lt;R(T::*)(A1) const&gt; {</a>
<a name="ln215"> public:</a>
<a name="ln216">  typedef R (RunType)(const T*, A1);</a>
<a name="ln217">  typedef base::true_type IsMethod;</a>
<a name="ln218"> </a>
<a name="ln219">  explicit RunnableAdapter(R(T::*method)(A1) const)</a>
<a name="ln220">      : method_(method) {</a>
<a name="ln221">  }</a>
<a name="ln222"> </a>
<a name="ln223">  R Run(const T* object, typename CallbackParamTraits&lt;A1&gt;::ForwardType a1) {</a>
<a name="ln224">    return (object-&gt;*method_)(CallbackForward(a1));</a>
<a name="ln225">  }</a>
<a name="ln226"> </a>
<a name="ln227"> private:</a>
<a name="ln228">  R (T::*method_)(A1) const;</a>
<a name="ln229">};</a>
<a name="ln230"> </a>
<a name="ln231">// Function: Arity 2.</a>
<a name="ln232">template &lt;typename R, typename A1, typename A2&gt;</a>
<a name="ln233">class RunnableAdapter&lt;R(*)(A1, A2)&gt; {</a>
<a name="ln234"> public:</a>
<a name="ln235">  typedef R (RunType)(A1, A2);</a>
<a name="ln236"> </a>
<a name="ln237">  explicit RunnableAdapter(R(*function)(A1, A2))</a>
<a name="ln238">      : function_(function) {</a>
<a name="ln239">  }</a>
<a name="ln240"> </a>
<a name="ln241">  R Run(typename CallbackParamTraits&lt;A1&gt;::ForwardType a1,</a>
<a name="ln242">      typename CallbackParamTraits&lt;A2&gt;::ForwardType a2) {</a>
<a name="ln243">    return function_(CallbackForward(a1), CallbackForward(a2));</a>
<a name="ln244">  }</a>
<a name="ln245"> </a>
<a name="ln246"> private:</a>
<a name="ln247">  R (*function_)(A1, A2);</a>
<a name="ln248">};</a>
<a name="ln249"> </a>
<a name="ln250">// Method: Arity 2.</a>
<a name="ln251">template &lt;typename R, typename T, typename A1, typename A2&gt;</a>
<a name="ln252">class RunnableAdapter&lt;R(T::*)(A1, A2)&gt; {</a>
<a name="ln253"> public:</a>
<a name="ln254">  typedef R (RunType)(T*, A1, A2);</a>
<a name="ln255">  typedef base::true_type IsMethod;</a>
<a name="ln256"> </a>
<a name="ln257">  explicit RunnableAdapter(R(T::*method)(A1, A2))</a>
<a name="ln258">      : method_(method) {</a>
<a name="ln259">  }</a>
<a name="ln260"> </a>
<a name="ln261">  R Run(T* object, typename CallbackParamTraits&lt;A1&gt;::ForwardType a1,</a>
<a name="ln262">      typename CallbackParamTraits&lt;A2&gt;::ForwardType a2) {</a>
<a name="ln263">    return (object-&gt;*method_)(CallbackForward(a1), CallbackForward(a2));</a>
<a name="ln264">  }</a>
<a name="ln265"> </a>
<a name="ln266"> private:</a>
<a name="ln267">  R (T::*method_)(A1, A2);</a>
<a name="ln268">};</a>
<a name="ln269"> </a>
<a name="ln270">// Const Method: Arity 2.</a>
<a name="ln271">template &lt;typename R, typename T, typename A1, typename A2&gt;</a>
<a name="ln272">class RunnableAdapter&lt;R(T::*)(A1, A2) const&gt; {</a>
<a name="ln273"> public:</a>
<a name="ln274">  typedef R (RunType)(const T*, A1, A2);</a>
<a name="ln275">  typedef base::true_type IsMethod;</a>
<a name="ln276"> </a>
<a name="ln277">  explicit RunnableAdapter(R(T::*method)(A1, A2) const)</a>
<a name="ln278">      : method_(method) {</a>
<a name="ln279">  }</a>
<a name="ln280"> </a>
<a name="ln281">  R Run(const T* object, typename CallbackParamTraits&lt;A1&gt;::ForwardType a1,</a>
<a name="ln282">      typename CallbackParamTraits&lt;A2&gt;::ForwardType a2) {</a>
<a name="ln283">    return (object-&gt;*method_)(CallbackForward(a1), CallbackForward(a2));</a>
<a name="ln284">  }</a>
<a name="ln285"> </a>
<a name="ln286"> private:</a>
<a name="ln287">  R (T::*method_)(A1, A2) const;</a>
<a name="ln288">};</a>
<a name="ln289"> </a>
<a name="ln290">// Function: Arity 3.</a>
<a name="ln291">template &lt;typename R, typename A1, typename A2, typename A3&gt;</a>
<a name="ln292">class RunnableAdapter&lt;R(*)(A1, A2, A3)&gt; {</a>
<a name="ln293"> public:</a>
<a name="ln294">  typedef R (RunType)(A1, A2, A3);</a>
<a name="ln295"> </a>
<a name="ln296">  explicit RunnableAdapter(R(*function)(A1, A2, A3))</a>
<a name="ln297">      : function_(function) {</a>
<a name="ln298">  }</a>
<a name="ln299"> </a>
<a name="ln300">  R Run(typename CallbackParamTraits&lt;A1&gt;::ForwardType a1,</a>
<a name="ln301">      typename CallbackParamTraits&lt;A2&gt;::ForwardType a2,</a>
<a name="ln302">      typename CallbackParamTraits&lt;A3&gt;::ForwardType a3) {</a>
<a name="ln303">    return function_(CallbackForward(a1), CallbackForward(a2),</a>
<a name="ln304">        CallbackForward(a3));</a>
<a name="ln305">  }</a>
<a name="ln306"> </a>
<a name="ln307"> private:</a>
<a name="ln308">  R (*function_)(A1, A2, A3);</a>
<a name="ln309">};</a>
<a name="ln310"> </a>
<a name="ln311">// Method: Arity 3.</a>
<a name="ln312">template &lt;typename R, typename T, typename A1, typename A2, typename A3&gt;</a>
<a name="ln313">class RunnableAdapter&lt;R(T::*)(A1, A2, A3)&gt; {</a>
<a name="ln314"> public:</a>
<a name="ln315">  typedef R (RunType)(T*, A1, A2, A3);</a>
<a name="ln316">  typedef base::true_type IsMethod;</a>
<a name="ln317"> </a>
<a name="ln318">  explicit RunnableAdapter(R(T::*method)(A1, A2, A3))</a>
<a name="ln319">      : method_(method) {</a>
<a name="ln320">  }</a>
<a name="ln321"> </a>
<a name="ln322">  R Run(T* object, typename CallbackParamTraits&lt;A1&gt;::ForwardType a1,</a>
<a name="ln323">      typename CallbackParamTraits&lt;A2&gt;::ForwardType a2,</a>
<a name="ln324">      typename CallbackParamTraits&lt;A3&gt;::ForwardType a3) {</a>
<a name="ln325">    return (object-&gt;*method_)(CallbackForward(a1), CallbackForward(a2),</a>
<a name="ln326">        CallbackForward(a3));</a>
<a name="ln327">  }</a>
<a name="ln328"> </a>
<a name="ln329"> private:</a>
<a name="ln330">  R (T::*method_)(A1, A2, A3);</a>
<a name="ln331">};</a>
<a name="ln332"> </a>
<a name="ln333">// Const Method: Arity 3.</a>
<a name="ln334">template &lt;typename R, typename T, typename A1, typename A2, typename A3&gt;</a>
<a name="ln335">class RunnableAdapter&lt;R(T::*)(A1, A2, A3) const&gt; {</a>
<a name="ln336"> public:</a>
<a name="ln337">  typedef R (RunType)(const T*, A1, A2, A3);</a>
<a name="ln338">  typedef base::true_type IsMethod;</a>
<a name="ln339"> </a>
<a name="ln340">  explicit RunnableAdapter(R(T::*method)(A1, A2, A3) const)</a>
<a name="ln341">      : method_(method) {</a>
<a name="ln342">  }</a>
<a name="ln343"> </a>
<a name="ln344">  R Run(const T* object, typename CallbackParamTraits&lt;A1&gt;::ForwardType a1,</a>
<a name="ln345">      typename CallbackParamTraits&lt;A2&gt;::ForwardType a2,</a>
<a name="ln346">      typename CallbackParamTraits&lt;A3&gt;::ForwardType a3) {</a>
<a name="ln347">    return (object-&gt;*method_)(CallbackForward(a1), CallbackForward(a2),</a>
<a name="ln348">        CallbackForward(a3));</a>
<a name="ln349">  }</a>
<a name="ln350"> </a>
<a name="ln351"> private:</a>
<a name="ln352">  R (T::*method_)(A1, A2, A3) const;</a>
<a name="ln353">};</a>
<a name="ln354"> </a>
<a name="ln355">// Function: Arity 4.</a>
<a name="ln356">template &lt;typename R, typename A1, typename A2, typename A3, typename A4&gt;</a>
<a name="ln357">class RunnableAdapter&lt;R(*)(A1, A2, A3, A4)&gt; {</a>
<a name="ln358"> public:</a>
<a name="ln359">  typedef R (RunType)(A1, A2, A3, A4);</a>
<a name="ln360"> </a>
<a name="ln361">  explicit RunnableAdapter(R(*function)(A1, A2, A3, A4))</a>
<a name="ln362">      : function_(function) {</a>
<a name="ln363">  }</a>
<a name="ln364"> </a>
<a name="ln365">  R Run(typename CallbackParamTraits&lt;A1&gt;::ForwardType a1,</a>
<a name="ln366">      typename CallbackParamTraits&lt;A2&gt;::ForwardType a2,</a>
<a name="ln367">      typename CallbackParamTraits&lt;A3&gt;::ForwardType a3,</a>
<a name="ln368">      typename CallbackParamTraits&lt;A4&gt;::ForwardType a4) {</a>
<a name="ln369">    return function_(CallbackForward(a1), CallbackForward(a2),</a>
<a name="ln370">        CallbackForward(a3), CallbackForward(a4));</a>
<a name="ln371">  }</a>
<a name="ln372"> </a>
<a name="ln373"> private:</a>
<a name="ln374">  R (*function_)(A1, A2, A3, A4);</a>
<a name="ln375">};</a>
<a name="ln376"> </a>
<a name="ln377">// Method: Arity 4.</a>
<a name="ln378">template &lt;typename R, typename T, typename A1, typename A2, typename A3,</a>
<a name="ln379">    typename A4&gt;</a>
<a name="ln380">class RunnableAdapter&lt;R(T::*)(A1, A2, A3, A4)&gt; {</a>
<a name="ln381"> public:</a>
<a name="ln382">  typedef R (RunType)(T*, A1, A2, A3, A4);</a>
<a name="ln383">  typedef base::true_type IsMethod;</a>
<a name="ln384"> </a>
<a name="ln385">  explicit RunnableAdapter(R(T::*method)(A1, A2, A3, A4))</a>
<a name="ln386">      : method_(method) {</a>
<a name="ln387">  }</a>
<a name="ln388"> </a>
<a name="ln389">  R Run(T* object, typename CallbackParamTraits&lt;A1&gt;::ForwardType a1,</a>
<a name="ln390">      typename CallbackParamTraits&lt;A2&gt;::ForwardType a2,</a>
<a name="ln391">      typename CallbackParamTraits&lt;A3&gt;::ForwardType a3,</a>
<a name="ln392">      typename CallbackParamTraits&lt;A4&gt;::ForwardType a4) {</a>
<a name="ln393">    return (object-&gt;*method_)(CallbackForward(a1), CallbackForward(a2),</a>
<a name="ln394">        CallbackForward(a3), CallbackForward(a4));</a>
<a name="ln395">  }</a>
<a name="ln396"> </a>
<a name="ln397"> private:</a>
<a name="ln398">  R (T::*method_)(A1, A2, A3, A4);</a>
<a name="ln399">};</a>
<a name="ln400"> </a>
<a name="ln401">// Const Method: Arity 4.</a>
<a name="ln402">template &lt;typename R, typename T, typename A1, typename A2, typename A3,</a>
<a name="ln403">    typename A4&gt;</a>
<a name="ln404">class RunnableAdapter&lt;R(T::*)(A1, A2, A3, A4) const&gt; {</a>
<a name="ln405"> public:</a>
<a name="ln406">  typedef R (RunType)(const T*, A1, A2, A3, A4);</a>
<a name="ln407">  typedef base::true_type IsMethod;</a>
<a name="ln408"> </a>
<a name="ln409">  explicit RunnableAdapter(R(T::*method)(A1, A2, A3, A4) const)</a>
<a name="ln410">      : method_(method) {</a>
<a name="ln411">  }</a>
<a name="ln412"> </a>
<a name="ln413">  R Run(const T* object, typename CallbackParamTraits&lt;A1&gt;::ForwardType a1,</a>
<a name="ln414">      typename CallbackParamTraits&lt;A2&gt;::ForwardType a2,</a>
<a name="ln415">      typename CallbackParamTraits&lt;A3&gt;::ForwardType a3,</a>
<a name="ln416">      typename CallbackParamTraits&lt;A4&gt;::ForwardType a4) {</a>
<a name="ln417">    return (object-&gt;*method_)(CallbackForward(a1), CallbackForward(a2),</a>
<a name="ln418">        CallbackForward(a3), CallbackForward(a4));</a>
<a name="ln419">  }</a>
<a name="ln420"> </a>
<a name="ln421"> private:</a>
<a name="ln422">  R (T::*method_)(A1, A2, A3, A4) const;</a>
<a name="ln423">};</a>
<a name="ln424"> </a>
<a name="ln425">// Function: Arity 5.</a>
<a name="ln426">template &lt;typename R, typename A1, typename A2, typename A3, typename A4,</a>
<a name="ln427">    typename A5&gt;</a>
<a name="ln428">class RunnableAdapter&lt;R(*)(A1, A2, A3, A4, A5)&gt; {</a>
<a name="ln429"> public:</a>
<a name="ln430">  typedef R (RunType)(A1, A2, A3, A4, A5);</a>
<a name="ln431"> </a>
<a name="ln432">  explicit RunnableAdapter(R(*function)(A1, A2, A3, A4, A5))</a>
<a name="ln433">      : function_(function) {</a>
<a name="ln434">  }</a>
<a name="ln435"> </a>
<a name="ln436">  R Run(typename CallbackParamTraits&lt;A1&gt;::ForwardType a1,</a>
<a name="ln437">      typename CallbackParamTraits&lt;A2&gt;::ForwardType a2,</a>
<a name="ln438">      typename CallbackParamTraits&lt;A3&gt;::ForwardType a3,</a>
<a name="ln439">      typename CallbackParamTraits&lt;A4&gt;::ForwardType a4,</a>
<a name="ln440">      typename CallbackParamTraits&lt;A5&gt;::ForwardType a5) {</a>
<a name="ln441">    return function_(CallbackForward(a1), CallbackForward(a2),</a>
<a name="ln442">        CallbackForward(a3), CallbackForward(a4), CallbackForward(a5));</a>
<a name="ln443">  }</a>
<a name="ln444"> </a>
<a name="ln445"> private:</a>
<a name="ln446">  R (*function_)(A1, A2, A3, A4, A5);</a>
<a name="ln447">};</a>
<a name="ln448"> </a>
<a name="ln449">// Method: Arity 5.</a>
<a name="ln450">template &lt;typename R, typename T, typename A1, typename A2, typename A3,</a>
<a name="ln451">    typename A4, typename A5&gt;</a>
<a name="ln452">class RunnableAdapter&lt;R(T::*)(A1, A2, A3, A4, A5)&gt; {</a>
<a name="ln453"> public:</a>
<a name="ln454">  typedef R (RunType)(T*, A1, A2, A3, A4, A5);</a>
<a name="ln455">  typedef base::true_type IsMethod;</a>
<a name="ln456"> </a>
<a name="ln457">  explicit RunnableAdapter(R(T::*method)(A1, A2, A3, A4, A5))</a>
<a name="ln458">      : method_(method) {</a>
<a name="ln459">  }</a>
<a name="ln460"> </a>
<a name="ln461">  R Run(T* object, typename CallbackParamTraits&lt;A1&gt;::ForwardType a1,</a>
<a name="ln462">      typename CallbackParamTraits&lt;A2&gt;::ForwardType a2,</a>
<a name="ln463">      typename CallbackParamTraits&lt;A3&gt;::ForwardType a3,</a>
<a name="ln464">      typename CallbackParamTraits&lt;A4&gt;::ForwardType a4,</a>
<a name="ln465">      typename CallbackParamTraits&lt;A5&gt;::ForwardType a5) {</a>
<a name="ln466">    return (object-&gt;*method_)(CallbackForward(a1), CallbackForward(a2),</a>
<a name="ln467">        CallbackForward(a3), CallbackForward(a4), CallbackForward(a5));</a>
<a name="ln468">  }</a>
<a name="ln469"> </a>
<a name="ln470"> private:</a>
<a name="ln471">  R (T::*method_)(A1, A2, A3, A4, A5);</a>
<a name="ln472">};</a>
<a name="ln473"> </a>
<a name="ln474">// Const Method: Arity 5.</a>
<a name="ln475">template &lt;typename R, typename T, typename A1, typename A2, typename A3,</a>
<a name="ln476">    typename A4, typename A5&gt;</a>
<a name="ln477">class RunnableAdapter&lt;R(T::*)(A1, A2, A3, A4, A5) const&gt; {</a>
<a name="ln478"> public:</a>
<a name="ln479">  typedef R (RunType)(const T*, A1, A2, A3, A4, A5);</a>
<a name="ln480">  typedef base::true_type IsMethod;</a>
<a name="ln481"> </a>
<a name="ln482">  explicit RunnableAdapter(R(T::*method)(A1, A2, A3, A4, A5) const)</a>
<a name="ln483">      : method_(method) {</a>
<a name="ln484">  }</a>
<a name="ln485"> </a>
<a name="ln486">  R Run(const T* object, typename CallbackParamTraits&lt;A1&gt;::ForwardType a1,</a>
<a name="ln487">      typename CallbackParamTraits&lt;A2&gt;::ForwardType a2,</a>
<a name="ln488">      typename CallbackParamTraits&lt;A3&gt;::ForwardType a3,</a>
<a name="ln489">      typename CallbackParamTraits&lt;A4&gt;::ForwardType a4,</a>
<a name="ln490">      typename CallbackParamTraits&lt;A5&gt;::ForwardType a5) {</a>
<a name="ln491">    return (object-&gt;*method_)(CallbackForward(a1), CallbackForward(a2),</a>
<a name="ln492">        CallbackForward(a3), CallbackForward(a4), CallbackForward(a5));</a>
<a name="ln493">  }</a>
<a name="ln494"> </a>
<a name="ln495"> private:</a>
<a name="ln496">  R (T::*method_)(A1, A2, A3, A4, A5) const;</a>
<a name="ln497">};</a>
<a name="ln498"> </a>
<a name="ln499">// Function: Arity 6.</a>
<a name="ln500">template &lt;typename R, typename A1, typename A2, typename A3, typename A4,</a>
<a name="ln501">    typename A5, typename A6&gt;</a>
<a name="ln502">class RunnableAdapter&lt;R(*)(A1, A2, A3, A4, A5, A6)&gt; {</a>
<a name="ln503"> public:</a>
<a name="ln504">  typedef R (RunType)(A1, A2, A3, A4, A5, A6);</a>
<a name="ln505"> </a>
<a name="ln506">  explicit RunnableAdapter(R(*function)(A1, A2, A3, A4, A5, A6))</a>
<a name="ln507">      : function_(function) {</a>
<a name="ln508">  }</a>
<a name="ln509"> </a>
<a name="ln510">  R Run(typename CallbackParamTraits&lt;A1&gt;::ForwardType a1,</a>
<a name="ln511">      typename CallbackParamTraits&lt;A2&gt;::ForwardType a2,</a>
<a name="ln512">      typename CallbackParamTraits&lt;A3&gt;::ForwardType a3,</a>
<a name="ln513">      typename CallbackParamTraits&lt;A4&gt;::ForwardType a4,</a>
<a name="ln514">      typename CallbackParamTraits&lt;A5&gt;::ForwardType a5,</a>
<a name="ln515">      typename CallbackParamTraits&lt;A6&gt;::ForwardType a6) {</a>
<a name="ln516">    return function_(CallbackForward(a1), CallbackForward(a2),</a>
<a name="ln517">        CallbackForward(a3), CallbackForward(a4), CallbackForward(a5),</a>
<a name="ln518">        CallbackForward(a6));</a>
<a name="ln519">  }</a>
<a name="ln520"> </a>
<a name="ln521"> private:</a>
<a name="ln522">  R (*function_)(A1, A2, A3, A4, A5, A6);</a>
<a name="ln523">};</a>
<a name="ln524"> </a>
<a name="ln525">// Method: Arity 6.</a>
<a name="ln526">template &lt;typename R, typename T, typename A1, typename A2, typename A3,</a>
<a name="ln527">    typename A4, typename A5, typename A6&gt;</a>
<a name="ln528">class RunnableAdapter&lt;R(T::*)(A1, A2, A3, A4, A5, A6)&gt; {</a>
<a name="ln529"> public:</a>
<a name="ln530">  typedef R (RunType)(T*, A1, A2, A3, A4, A5, A6);</a>
<a name="ln531">  typedef base::true_type IsMethod;</a>
<a name="ln532"> </a>
<a name="ln533">  explicit RunnableAdapter(R(T::*method)(A1, A2, A3, A4, A5, A6))</a>
<a name="ln534">      : method_(method) {</a>
<a name="ln535">  }</a>
<a name="ln536"> </a>
<a name="ln537">  R Run(T* object, typename CallbackParamTraits&lt;A1&gt;::ForwardType a1,</a>
<a name="ln538">      typename CallbackParamTraits&lt;A2&gt;::ForwardType a2,</a>
<a name="ln539">      typename CallbackParamTraits&lt;A3&gt;::ForwardType a3,</a>
<a name="ln540">      typename CallbackParamTraits&lt;A4&gt;::ForwardType a4,</a>
<a name="ln541">      typename CallbackParamTraits&lt;A5&gt;::ForwardType a5,</a>
<a name="ln542">      typename CallbackParamTraits&lt;A6&gt;::ForwardType a6) {</a>
<a name="ln543">    return (object-&gt;*method_)(CallbackForward(a1), CallbackForward(a2),</a>
<a name="ln544">        CallbackForward(a3), CallbackForward(a4), CallbackForward(a5),</a>
<a name="ln545">        CallbackForward(a6));</a>
<a name="ln546">  }</a>
<a name="ln547"> </a>
<a name="ln548"> private:</a>
<a name="ln549">  R (T::*method_)(A1, A2, A3, A4, A5, A6);</a>
<a name="ln550">};</a>
<a name="ln551"> </a>
<a name="ln552">// Const Method: Arity 6.</a>
<a name="ln553">template &lt;typename R, typename T, typename A1, typename A2, typename A3,</a>
<a name="ln554">    typename A4, typename A5, typename A6&gt;</a>
<a name="ln555">class RunnableAdapter&lt;R(T::*)(A1, A2, A3, A4, A5, A6) const&gt; {</a>
<a name="ln556"> public:</a>
<a name="ln557">  typedef R (RunType)(const T*, A1, A2, A3, A4, A5, A6);</a>
<a name="ln558">  typedef base::true_type IsMethod;</a>
<a name="ln559"> </a>
<a name="ln560">  explicit RunnableAdapter(R(T::*method)(A1, A2, A3, A4, A5, A6) const)</a>
<a name="ln561">      : method_(method) {</a>
<a name="ln562">  }</a>
<a name="ln563"> </a>
<a name="ln564">  R Run(const T* object, typename CallbackParamTraits&lt;A1&gt;::ForwardType a1,</a>
<a name="ln565">      typename CallbackParamTraits&lt;A2&gt;::ForwardType a2,</a>
<a name="ln566">      typename CallbackParamTraits&lt;A3&gt;::ForwardType a3,</a>
<a name="ln567">      typename CallbackParamTraits&lt;A4&gt;::ForwardType a4,</a>
<a name="ln568">      typename CallbackParamTraits&lt;A5&gt;::ForwardType a5,</a>
<a name="ln569">      typename CallbackParamTraits&lt;A6&gt;::ForwardType a6) {</a>
<a name="ln570">    return (object-&gt;*method_)(CallbackForward(a1), CallbackForward(a2),</a>
<a name="ln571">        CallbackForward(a3), CallbackForward(a4), CallbackForward(a5),</a>
<a name="ln572">        CallbackForward(a6));</a>
<a name="ln573">  }</a>
<a name="ln574"> </a>
<a name="ln575"> private:</a>
<a name="ln576">  R (T::*method_)(A1, A2, A3, A4, A5, A6) const;</a>
<a name="ln577">};</a>
<a name="ln578"> </a>
<a name="ln579">// Function: Arity 7.</a>
<a name="ln580">template &lt;typename R, typename A1, typename A2, typename A3, typename A4,</a>
<a name="ln581">    typename A5, typename A6, typename A7&gt;</a>
<a name="ln582">class RunnableAdapter&lt;R(*)(A1, A2, A3, A4, A5, A6, A7)&gt; {</a>
<a name="ln583"> public:</a>
<a name="ln584">  typedef R (RunType)(A1, A2, A3, A4, A5, A6, A7);</a>
<a name="ln585"> </a>
<a name="ln586">  explicit RunnableAdapter(R(*function)(A1, A2, A3, A4, A5, A6, A7))</a>
<a name="ln587">      : function_(function) {</a>
<a name="ln588">  }</a>
<a name="ln589"> </a>
<a name="ln590">  R Run(typename CallbackParamTraits&lt;A1&gt;::ForwardType a1,</a>
<a name="ln591">      typename CallbackParamTraits&lt;A2&gt;::ForwardType a2,</a>
<a name="ln592">      typename CallbackParamTraits&lt;A3&gt;::ForwardType a3,</a>
<a name="ln593">      typename CallbackParamTraits&lt;A4&gt;::ForwardType a4,</a>
<a name="ln594">      typename CallbackParamTraits&lt;A5&gt;::ForwardType a5,</a>
<a name="ln595">      typename CallbackParamTraits&lt;A6&gt;::ForwardType a6,</a>
<a name="ln596">      typename CallbackParamTraits&lt;A7&gt;::ForwardType a7) {</a>
<a name="ln597">    return function_(CallbackForward(a1), CallbackForward(a2),</a>
<a name="ln598">        CallbackForward(a3), CallbackForward(a4), CallbackForward(a5),</a>
<a name="ln599">        CallbackForward(a6), CallbackForward(a7));</a>
<a name="ln600">  }</a>
<a name="ln601"> </a>
<a name="ln602"> private:</a>
<a name="ln603">  R (*function_)(A1, A2, A3, A4, A5, A6, A7);</a>
<a name="ln604">};</a>
<a name="ln605"> </a>
<a name="ln606">// Method: Arity 7.</a>
<a name="ln607">template &lt;typename R, typename T, typename A1, typename A2, typename A3,</a>
<a name="ln608">    typename A4, typename A5, typename A6, typename A7&gt;</a>
<a name="ln609">class RunnableAdapter&lt;R(T::*)(A1, A2, A3, A4, A5, A6, A7)&gt; {</a>
<a name="ln610"> public:</a>
<a name="ln611">  typedef R (RunType)(T*, A1, A2, A3, A4, A5, A6, A7);</a>
<a name="ln612">  typedef base::true_type IsMethod;</a>
<a name="ln613"> </a>
<a name="ln614">  explicit RunnableAdapter(R(T::*method)(A1, A2, A3, A4, A5, A6, A7))</a>
<a name="ln615">      : method_(method) {</a>
<a name="ln616">  }</a>
<a name="ln617"> </a>
<a name="ln618">  R Run(T* object, typename CallbackParamTraits&lt;A1&gt;::ForwardType a1,</a>
<a name="ln619">      typename CallbackParamTraits&lt;A2&gt;::ForwardType a2,</a>
<a name="ln620">      typename CallbackParamTraits&lt;A3&gt;::ForwardType a3,</a>
<a name="ln621">      typename CallbackParamTraits&lt;A4&gt;::ForwardType a4,</a>
<a name="ln622">      typename CallbackParamTraits&lt;A5&gt;::ForwardType a5,</a>
<a name="ln623">      typename CallbackParamTraits&lt;A6&gt;::ForwardType a6,</a>
<a name="ln624">      typename CallbackParamTraits&lt;A7&gt;::ForwardType a7) {</a>
<a name="ln625">    return (object-&gt;*method_)(CallbackForward(a1), CallbackForward(a2),</a>
<a name="ln626">        CallbackForward(a3), CallbackForward(a4), CallbackForward(a5),</a>
<a name="ln627">        CallbackForward(a6), CallbackForward(a7));</a>
<a name="ln628">  }</a>
<a name="ln629"> </a>
<a name="ln630"> private:</a>
<a name="ln631">  R (T::*method_)(A1, A2, A3, A4, A5, A6, A7);</a>
<a name="ln632">};</a>
<a name="ln633"> </a>
<a name="ln634">// Const Method: Arity 7.</a>
<a name="ln635">template &lt;typename R, typename T, typename A1, typename A2, typename A3,</a>
<a name="ln636">    typename A4, typename A5, typename A6, typename A7&gt;</a>
<a name="ln637">class RunnableAdapter&lt;R(T::*)(A1, A2, A3, A4, A5, A6, A7) const&gt; {</a>
<a name="ln638"> public:</a>
<a name="ln639">  typedef R (RunType)(const T*, A1, A2, A3, A4, A5, A6, A7);</a>
<a name="ln640">  typedef base::true_type IsMethod;</a>
<a name="ln641"> </a>
<a name="ln642">  explicit RunnableAdapter(R(T::*method)(A1, A2, A3, A4, A5, A6, A7) const)</a>
<a name="ln643">      : method_(method) {</a>
<a name="ln644">  }</a>
<a name="ln645"> </a>
<a name="ln646">  R Run(const T* object, typename CallbackParamTraits&lt;A1&gt;::ForwardType a1,</a>
<a name="ln647">      typename CallbackParamTraits&lt;A2&gt;::ForwardType a2,</a>
<a name="ln648">      typename CallbackParamTraits&lt;A3&gt;::ForwardType a3,</a>
<a name="ln649">      typename CallbackParamTraits&lt;A4&gt;::ForwardType a4,</a>
<a name="ln650">      typename CallbackParamTraits&lt;A5&gt;::ForwardType a5,</a>
<a name="ln651">      typename CallbackParamTraits&lt;A6&gt;::ForwardType a6,</a>
<a name="ln652">      typename CallbackParamTraits&lt;A7&gt;::ForwardType a7) {</a>
<a name="ln653">    return (object-&gt;*method_)(CallbackForward(a1), CallbackForward(a2),</a>
<a name="ln654">        CallbackForward(a3), CallbackForward(a4), CallbackForward(a5),</a>
<a name="ln655">        CallbackForward(a6), CallbackForward(a7));</a>
<a name="ln656">  }</a>
<a name="ln657"> </a>
<a name="ln658"> private:</a>
<a name="ln659">  R (T::*method_)(A1, A2, A3, A4, A5, A6, A7) const;</a>
<a name="ln660">};</a>
<a name="ln661"> </a>
<a name="ln662"> </a>
<a name="ln663">// FunctionTraits&lt;&gt;</a>
<a name="ln664">//</a>
<a name="ln665">// Breaks a function signature apart into typedefs for easier introspection.</a>
<a name="ln666">template &lt;typename Sig&gt;</a>
<a name="ln667">struct FunctionTraits;</a>
<a name="ln668"> </a>
<a name="ln669">template &lt;typename R&gt;</a>
<a name="ln670">struct FunctionTraits&lt;R()&gt; {</a>
<a name="ln671">  typedef R ReturnType;</a>
<a name="ln672">};</a>
<a name="ln673"> </a>
<a name="ln674">template &lt;typename R, typename A1&gt;</a>
<a name="ln675">struct FunctionTraits&lt;R(A1)&gt; {</a>
<a name="ln676">  typedef R ReturnType;</a>
<a name="ln677">  typedef A1 A1Type;</a>
<a name="ln678">};</a>
<a name="ln679"> </a>
<a name="ln680">template &lt;typename R, typename A1, typename A2&gt;</a>
<a name="ln681">struct FunctionTraits&lt;R(A1, A2)&gt; {</a>
<a name="ln682">  typedef R ReturnType;</a>
<a name="ln683">  typedef A1 A1Type;</a>
<a name="ln684">  typedef A2 A2Type;</a>
<a name="ln685">};</a>
<a name="ln686"> </a>
<a name="ln687">template &lt;typename R, typename A1, typename A2, typename A3&gt;</a>
<a name="ln688">struct FunctionTraits&lt;R(A1, A2, A3)&gt; {</a>
<a name="ln689">  typedef R ReturnType;</a>
<a name="ln690">  typedef A1 A1Type;</a>
<a name="ln691">  typedef A2 A2Type;</a>
<a name="ln692">  typedef A3 A3Type;</a>
<a name="ln693">};</a>
<a name="ln694"> </a>
<a name="ln695">template &lt;typename R, typename A1, typename A2, typename A3, typename A4&gt;</a>
<a name="ln696">struct FunctionTraits&lt;R(A1, A2, A3, A4)&gt; {</a>
<a name="ln697">  typedef R ReturnType;</a>
<a name="ln698">  typedef A1 A1Type;</a>
<a name="ln699">  typedef A2 A2Type;</a>
<a name="ln700">  typedef A3 A3Type;</a>
<a name="ln701">  typedef A4 A4Type;</a>
<a name="ln702">};</a>
<a name="ln703"> </a>
<a name="ln704">template &lt;typename R, typename A1, typename A2, typename A3, typename A4,</a>
<a name="ln705">    typename A5&gt;</a>
<a name="ln706">struct FunctionTraits&lt;R(A1, A2, A3, A4, A5)&gt; {</a>
<a name="ln707">  typedef R ReturnType;</a>
<a name="ln708">  typedef A1 A1Type;</a>
<a name="ln709">  typedef A2 A2Type;</a>
<a name="ln710">  typedef A3 A3Type;</a>
<a name="ln711">  typedef A4 A4Type;</a>
<a name="ln712">  typedef A5 A5Type;</a>
<a name="ln713">};</a>
<a name="ln714"> </a>
<a name="ln715">template &lt;typename R, typename A1, typename A2, typename A3, typename A4,</a>
<a name="ln716">    typename A5, typename A6&gt;</a>
<a name="ln717">struct FunctionTraits&lt;R(A1, A2, A3, A4, A5, A6)&gt; {</a>
<a name="ln718">  typedef R ReturnType;</a>
<a name="ln719">  typedef A1 A1Type;</a>
<a name="ln720">  typedef A2 A2Type;</a>
<a name="ln721">  typedef A3 A3Type;</a>
<a name="ln722">  typedef A4 A4Type;</a>
<a name="ln723">  typedef A5 A5Type;</a>
<a name="ln724">  typedef A6 A6Type;</a>
<a name="ln725">};</a>
<a name="ln726"> </a>
<a name="ln727">template &lt;typename R, typename A1, typename A2, typename A3, typename A4,</a>
<a name="ln728">    typename A5, typename A6, typename A7&gt;</a>
<a name="ln729">struct FunctionTraits&lt;R(A1, A2, A3, A4, A5, A6, A7)&gt; {</a>
<a name="ln730">  typedef R ReturnType;</a>
<a name="ln731">  typedef A1 A1Type;</a>
<a name="ln732">  typedef A2 A2Type;</a>
<a name="ln733">  typedef A3 A3Type;</a>
<a name="ln734">  typedef A4 A4Type;</a>
<a name="ln735">  typedef A5 A5Type;</a>
<a name="ln736">  typedef A6 A6Type;</a>
<a name="ln737">  typedef A7 A7Type;</a>
<a name="ln738">};</a>
<a name="ln739"> </a>
<a name="ln740"> </a>
<a name="ln741">// ForceVoidReturn&lt;&gt;</a>
<a name="ln742">//</a>
<a name="ln743">// Set of templates that support forcing the function return type to void.</a>
<a name="ln744">template &lt;typename Sig&gt;</a>
<a name="ln745">struct ForceVoidReturn;</a>
<a name="ln746"> </a>
<a name="ln747">template &lt;typename R&gt;</a>
<a name="ln748">struct ForceVoidReturn&lt;R()&gt; {</a>
<a name="ln749">  typedef void(RunType)();</a>
<a name="ln750">};</a>
<a name="ln751"> </a>
<a name="ln752">template &lt;typename R, typename A1&gt;</a>
<a name="ln753">struct ForceVoidReturn&lt;R(A1)&gt; {</a>
<a name="ln754">  typedef void(RunType)(A1);</a>
<a name="ln755">};</a>
<a name="ln756"> </a>
<a name="ln757">template &lt;typename R, typename A1, typename A2&gt;</a>
<a name="ln758">struct ForceVoidReturn&lt;R(A1, A2)&gt; {</a>
<a name="ln759">  typedef void(RunType)(A1, A2);</a>
<a name="ln760">};</a>
<a name="ln761"> </a>
<a name="ln762">template &lt;typename R, typename A1, typename A2, typename A3&gt;</a>
<a name="ln763">struct ForceVoidReturn&lt;R(A1, A2, A3)&gt; {</a>
<a name="ln764">  typedef void(RunType)(A1, A2, A3);</a>
<a name="ln765">};</a>
<a name="ln766"> </a>
<a name="ln767">template &lt;typename R, typename A1, typename A2, typename A3, typename A4&gt;</a>
<a name="ln768">struct ForceVoidReturn&lt;R(A1, A2, A3, A4)&gt; {</a>
<a name="ln769">  typedef void(RunType)(A1, A2, A3, A4);</a>
<a name="ln770">};</a>
<a name="ln771"> </a>
<a name="ln772">template &lt;typename R, typename A1, typename A2, typename A3, typename A4,</a>
<a name="ln773">    typename A5&gt;</a>
<a name="ln774">struct ForceVoidReturn&lt;R(A1, A2, A3, A4, A5)&gt; {</a>
<a name="ln775">  typedef void(RunType)(A1, A2, A3, A4, A5);</a>
<a name="ln776">};</a>
<a name="ln777"> </a>
<a name="ln778">template &lt;typename R, typename A1, typename A2, typename A3, typename A4,</a>
<a name="ln779">    typename A5, typename A6&gt;</a>
<a name="ln780">struct ForceVoidReturn&lt;R(A1, A2, A3, A4, A5, A6)&gt; {</a>
<a name="ln781">  typedef void(RunType)(A1, A2, A3, A4, A5, A6);</a>
<a name="ln782">};</a>
<a name="ln783"> </a>
<a name="ln784">template &lt;typename R, typename A1, typename A2, typename A3, typename A4,</a>
<a name="ln785">    typename A5, typename A6, typename A7&gt;</a>
<a name="ln786">struct ForceVoidReturn&lt;R(A1, A2, A3, A4, A5, A6, A7)&gt; {</a>
<a name="ln787">  typedef void(RunType)(A1, A2, A3, A4, A5, A6, A7);</a>
<a name="ln788">};</a>
<a name="ln789"> </a>
<a name="ln790"> </a>
<a name="ln791">// FunctorTraits&lt;&gt;</a>
<a name="ln792">//</a>
<a name="ln793">// See description at top of file.</a>
<a name="ln794">template &lt;typename T&gt;</a>
<a name="ln795">struct FunctorTraits {</a>
<a name="ln796">  typedef RunnableAdapter&lt;T&gt; RunnableType;</a>
<a name="ln797">  typedef typename RunnableType::RunType RunType;</a>
<a name="ln798">};</a>
<a name="ln799"> </a>
<a name="ln800">template &lt;typename T&gt;</a>
<a name="ln801">struct FunctorTraits&lt;IgnoreResultHelper&lt;T&gt; &gt; {</a>
<a name="ln802">  typedef typename FunctorTraits&lt;T&gt;::RunnableType RunnableType;</a>
<a name="ln803">  typedef typename ForceVoidReturn&lt;</a>
<a name="ln804">      typename RunnableType::RunType&gt;::RunType RunType;</a>
<a name="ln805">};</a>
<a name="ln806"> </a>
<a name="ln807">template &lt;typename T&gt;</a>
<a name="ln808">struct FunctorTraits&lt;Callback&lt;T&gt; &gt; {</a>
<a name="ln809">  typedef Callback&lt;T&gt; RunnableType;</a>
<a name="ln810">  typedef typename Callback&lt;T&gt;::RunType RunType;</a>
<a name="ln811">};</a>
<a name="ln812"> </a>
<a name="ln813"> </a>
<a name="ln814">// MakeRunnable&lt;&gt;</a>
<a name="ln815">//</a>
<a name="ln816">// Converts a passed in functor to a RunnableType using type inference.</a>
<a name="ln817"> </a>
<a name="ln818">template &lt;typename T&gt;</a>
<a name="ln819">typename FunctorTraits&lt;T&gt;::RunnableType MakeRunnable(const T&amp; t) {</a>
<a name="ln820">  return RunnableAdapter&lt;T&gt;(t);</a>
<a name="ln821">}</a>
<a name="ln822"> </a>
<a name="ln823">template &lt;typename T&gt;</a>
<a name="ln824">typename FunctorTraits&lt;T&gt;::RunnableType</a>
<a name="ln825">MakeRunnable(const IgnoreResultHelper&lt;T&gt;&amp; t) {</a>
<a name="ln826">  return MakeRunnable(t.functor_);</a>
<a name="ln827">}</a>
<a name="ln828"> </a>
<a name="ln829">template &lt;typename T&gt;</a>
<a name="ln830">const typename FunctorTraits&lt;Callback&lt;T&gt; &gt;::RunnableType&amp;</a>
<a name="ln831">MakeRunnable(const Callback&lt;T&gt;&amp; t) {</a>
<a name="ln832">  DCHECK(!t.is_null());</a>
<a name="ln833">  return t;</a>
<a name="ln834">}</a>
<a name="ln835"> </a>
<a name="ln836"> </a>
<a name="ln837">// InvokeHelper&lt;&gt;</a>
<a name="ln838">//</a>
<a name="ln839">// There are 3 logical InvokeHelper&lt;&gt; specializations: normal, void-return,</a>
<a name="ln840">// WeakCalls.</a>
<a name="ln841">//</a>
<a name="ln842">// The normal type just calls the underlying runnable.</a>
<a name="ln843">//</a>
<a name="ln844">// We need a InvokeHelper to handle void return types in order to support</a>
<a name="ln845">// IgnoreResult().  Normally, if the Runnable's RunType had a void return,</a>
<a name="ln846">// the template system would just accept &quot;return functor.Run()&quot; ignoring</a>
<a name="ln847">// the fact that a void function is being used with return. This piece of</a>
<a name="ln848">// sugar breaks though when the Runnable's RunType is not void.  Thus, we</a>
<a name="ln849">// need a partial specialization to change the syntax to drop the &quot;return&quot;</a>
<a name="ln850">// from the invocation call.</a>
<a name="ln851">//</a>
<a name="ln852">// WeakCalls similarly need special syntax that is applied to the first</a>
<a name="ln853">// argument to check if they should no-op themselves.</a>
<a name="ln854">template &lt;bool IsWeakCall, typename ReturnType, typename Runnable,</a>
<a name="ln855">          typename ArgsType&gt;</a>
<a name="ln856">struct InvokeHelper;</a>
<a name="ln857"> </a>
<a name="ln858">template &lt;typename ReturnType, typename Runnable&gt;</a>
<a name="ln859">struct InvokeHelper&lt;false, ReturnType, Runnable,</a>
<a name="ln860">    void()&gt;  {</a>
<a name="ln861">  static ReturnType MakeItSo(Runnable runnable) {</a>
<a name="ln862">    return runnable.Run();</a>
<a name="ln863">  }</a>
<a name="ln864">};</a>
<a name="ln865"> </a>
<a name="ln866">template &lt;typename Runnable&gt;</a>
<a name="ln867">struct InvokeHelper&lt;false, void, Runnable,</a>
<a name="ln868">    void()&gt;  {</a>
<a name="ln869">  static void MakeItSo(Runnable runnable) {</a>
<a name="ln870">    runnable.Run();</a>
<a name="ln871">  }</a>
<a name="ln872">};</a>
<a name="ln873"> </a>
<a name="ln874">template &lt;typename ReturnType, typename Runnable,typename A1&gt;</a>
<a name="ln875">struct InvokeHelper&lt;false, ReturnType, Runnable,</a>
<a name="ln876">    void(A1)&gt;  {</a>
<a name="ln877">  static ReturnType MakeItSo(Runnable runnable, A1 a1) {</a>
<a name="ln878">    return runnable.Run(CallbackForward(a1));</a>
<a name="ln879">  }</a>
<a name="ln880">};</a>
<a name="ln881"> </a>
<a name="ln882">template &lt;typename Runnable,typename A1&gt;</a>
<a name="ln883">struct InvokeHelper&lt;false, void, Runnable,</a>
<a name="ln884">    void(A1)&gt;  {</a>
<a name="ln885">  static void MakeItSo(Runnable runnable, A1 a1) {</a>
<a name="ln886">    runnable.Run(CallbackForward(a1));</a>
<a name="ln887">  }</a>
<a name="ln888">};</a>
<a name="ln889"> </a>
<a name="ln890">template &lt;typename ReturnType, typename Runnable,typename A1, typename A2&gt;</a>
<a name="ln891">struct InvokeHelper&lt;false, ReturnType, Runnable,</a>
<a name="ln892">    void(A1, A2)&gt;  {</a>
<a name="ln893">  static ReturnType MakeItSo(Runnable runnable, A1 a1, A2 a2) {</a>
<a name="ln894">    return runnable.Run(CallbackForward(a1), CallbackForward(a2));</a>
<a name="ln895">  }</a>
<a name="ln896">};</a>
<a name="ln897"> </a>
<a name="ln898">template &lt;typename Runnable,typename A1, typename A2&gt;</a>
<a name="ln899">struct InvokeHelper&lt;false, void, Runnable,</a>
<a name="ln900">    void(A1, A2)&gt;  {</a>
<a name="ln901">  static void MakeItSo(Runnable runnable, A1 a1, A2 a2) {</a>
<a name="ln902">    runnable.Run(CallbackForward(a1), CallbackForward(a2));</a>
<a name="ln903">  }</a>
<a name="ln904">};</a>
<a name="ln905"> </a>
<a name="ln906">template &lt;typename ReturnType, typename Runnable,typename A1, typename A2,</a>
<a name="ln907">    typename A3&gt;</a>
<a name="ln908">struct InvokeHelper&lt;false, ReturnType, Runnable,</a>
<a name="ln909">    void(A1, A2, A3)&gt;  {</a>
<a name="ln910">  static ReturnType MakeItSo(Runnable runnable, A1 a1, A2 a2, A3 a3) {</a>
<a name="ln911">    return runnable.Run(CallbackForward(a1), CallbackForward(a2),</a>
<a name="ln912">        CallbackForward(a3));</a>
<a name="ln913">  }</a>
<a name="ln914">};</a>
<a name="ln915"> </a>
<a name="ln916">template &lt;typename Runnable,typename A1, typename A2, typename A3&gt;</a>
<a name="ln917">struct InvokeHelper&lt;false, void, Runnable,</a>
<a name="ln918">    void(A1, A2, A3)&gt;  {</a>
<a name="ln919">  static void MakeItSo(Runnable runnable, A1 a1, A2 a2, A3 a3) {</a>
<a name="ln920">    runnable.Run(CallbackForward(a1), CallbackForward(a2), CallbackForward(a3));</a>
<a name="ln921">  }</a>
<a name="ln922">};</a>
<a name="ln923"> </a>
<a name="ln924">template &lt;typename ReturnType, typename Runnable,typename A1, typename A2,</a>
<a name="ln925">    typename A3, typename A4&gt;</a>
<a name="ln926">struct InvokeHelper&lt;false, ReturnType, Runnable,</a>
<a name="ln927">    void(A1, A2, A3, A4)&gt;  {</a>
<a name="ln928">  static ReturnType MakeItSo(Runnable runnable, A1 a1, A2 a2, A3 a3, A4 a4) {</a>
<a name="ln929">    return runnable.Run(CallbackForward(a1), CallbackForward(a2),</a>
<a name="ln930">        CallbackForward(a3), CallbackForward(a4));</a>
<a name="ln931">  }</a>
<a name="ln932">};</a>
<a name="ln933"> </a>
<a name="ln934">template &lt;typename Runnable,typename A1, typename A2, typename A3, typename A4&gt;</a>
<a name="ln935">struct InvokeHelper&lt;false, void, Runnable,</a>
<a name="ln936">    void(A1, A2, A3, A4)&gt;  {</a>
<a name="ln937">  static void MakeItSo(Runnable runnable, A1 a1, A2 a2, A3 a3, A4 a4) {</a>
<a name="ln938">    runnable.Run(CallbackForward(a1), CallbackForward(a2), CallbackForward(a3),</a>
<a name="ln939">        CallbackForward(a4));</a>
<a name="ln940">  }</a>
<a name="ln941">};</a>
<a name="ln942"> </a>
<a name="ln943">template &lt;typename ReturnType, typename Runnable,typename A1, typename A2,</a>
<a name="ln944">    typename A3, typename A4, typename A5&gt;</a>
<a name="ln945">struct InvokeHelper&lt;false, ReturnType, Runnable,</a>
<a name="ln946">    void(A1, A2, A3, A4, A5)&gt;  {</a>
<a name="ln947">  static ReturnType MakeItSo(Runnable runnable, A1 a1, A2 a2, A3 a3, A4 a4,</a>
<a name="ln948">      A5 a5) {</a>
<a name="ln949">    return runnable.Run(CallbackForward(a1), CallbackForward(a2),</a>
<a name="ln950">        CallbackForward(a3), CallbackForward(a4), CallbackForward(a5));</a>
<a name="ln951">  }</a>
<a name="ln952">};</a>
<a name="ln953"> </a>
<a name="ln954">template &lt;typename Runnable,typename A1, typename A2, typename A3, typename A4,</a>
<a name="ln955">    typename A5&gt;</a>
<a name="ln956">struct InvokeHelper&lt;false, void, Runnable,</a>
<a name="ln957">    void(A1, A2, A3, A4, A5)&gt;  {</a>
<a name="ln958">  static void MakeItSo(Runnable runnable, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) {</a>
<a name="ln959">    runnable.Run(CallbackForward(a1), CallbackForward(a2), CallbackForward(a3),</a>
<a name="ln960">        CallbackForward(a4), CallbackForward(a5));</a>
<a name="ln961">  }</a>
<a name="ln962">};</a>
<a name="ln963"> </a>
<a name="ln964">template &lt;typename ReturnType, typename Runnable,typename A1, typename A2,</a>
<a name="ln965">    typename A3, typename A4, typename A5, typename A6&gt;</a>
<a name="ln966">struct InvokeHelper&lt;false, ReturnType, Runnable,</a>
<a name="ln967">    void(A1, A2, A3, A4, A5, A6)&gt;  {</a>
<a name="ln968">  static ReturnType MakeItSo(Runnable runnable, A1 a1, A2 a2, A3 a3, A4 a4,</a>
<a name="ln969">      A5 a5, A6 a6) {</a>
<a name="ln970">    return runnable.Run(CallbackForward(a1), CallbackForward(a2),</a>
<a name="ln971">        CallbackForward(a3), CallbackForward(a4), CallbackForward(a5),</a>
<a name="ln972">        CallbackForward(a6));</a>
<a name="ln973">  }</a>
<a name="ln974">};</a>
<a name="ln975"> </a>
<a name="ln976">template &lt;typename Runnable,typename A1, typename A2, typename A3, typename A4,</a>
<a name="ln977">    typename A5, typename A6&gt;</a>
<a name="ln978">struct InvokeHelper&lt;false, void, Runnable,</a>
<a name="ln979">    void(A1, A2, A3, A4, A5, A6)&gt;  {</a>
<a name="ln980">  static void MakeItSo(Runnable runnable, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5,</a>
<a name="ln981">      A6 a6) {</a>
<a name="ln982">    runnable.Run(CallbackForward(a1), CallbackForward(a2), CallbackForward(a3),</a>
<a name="ln983">        CallbackForward(a4), CallbackForward(a5), CallbackForward(a6));</a>
<a name="ln984">  }</a>
<a name="ln985">};</a>
<a name="ln986"> </a>
<a name="ln987">template &lt;typename ReturnType, typename Runnable,typename A1, typename A2,</a>
<a name="ln988">    typename A3, typename A4, typename A5, typename A6, typename A7&gt;</a>
<a name="ln989">struct InvokeHelper&lt;false, ReturnType, Runnable,</a>
<a name="ln990">    void(A1, A2, A3, A4, A5, A6, A7)&gt;  {</a>
<a name="ln991">  static ReturnType MakeItSo(Runnable runnable, A1 a1, A2 a2, A3 a3, A4 a4,</a>
<a name="ln992">      A5 a5, A6 a6, A7 a7) {</a>
<a name="ln993">    return runnable.Run(CallbackForward(a1), CallbackForward(a2),</a>
<a name="ln994">        CallbackForward(a3), CallbackForward(a4), CallbackForward(a5),</a>
<a name="ln995">        CallbackForward(a6), CallbackForward(a7));</a>
<a name="ln996">  }</a>
<a name="ln997">};</a>
<a name="ln998"> </a>
<a name="ln999">template &lt;typename Runnable,typename A1, typename A2, typename A3, typename A4,</a>
<a name="ln1000">    typename A5, typename A6, typename A7&gt;</a>
<a name="ln1001">struct InvokeHelper&lt;false, void, Runnable,</a>
<a name="ln1002">    void(A1, A2, A3, A4, A5, A6, A7)&gt;  {</a>
<a name="ln1003">  static void MakeItSo(Runnable runnable, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5,</a>
<a name="ln1004">      A6 a6, A7 a7) {</a>
<a name="ln1005">    runnable.Run(CallbackForward(a1), CallbackForward(a2), CallbackForward(a3),</a>
<a name="ln1006">        CallbackForward(a4), CallbackForward(a5), CallbackForward(a6),</a>
<a name="ln1007">        CallbackForward(a7));</a>
<a name="ln1008">  }</a>
<a name="ln1009">};</a>
<a name="ln1010"> </a>
<a name="ln1011">// Invoker&lt;&gt;</a>
<a name="ln1012">//</a>
<a name="ln1013">// See description at the top of the file.</a>
<a name="ln1014">template &lt;int NumBound, typename Storage, typename RunType&gt;</a>
<a name="ln1015">struct Invoker;</a>
<a name="ln1016"> </a>
<a name="ln1017">// Arity 0 -&gt; 0.</a>
<a name="ln1018">template &lt;typename StorageType, typename R&gt;</a>
<a name="ln1019">struct Invoker&lt;0, StorageType, R()&gt; {</a>
<a name="ln1020">  typedef R(RunType)(BindStateBase*);</a>
<a name="ln1021"> </a>
<a name="ln1022">  typedef R(UnboundRunType)();</a>
<a name="ln1023"> </a>
<a name="ln1024">  static R Run(BindStateBase* base) {</a>
<a name="ln1025">    StorageType* storage = static_cast&lt;StorageType*&gt;(base);</a>
<a name="ln1026"> </a>
<a name="ln1027">    // Local references to make debugger stepping easier. If in a debugger,</a>
<a name="ln1028">    // you really want to warp ahead and step through the</a>
<a name="ln1029">    // InvokeHelper&lt;&gt;::MakeItSo() call below.</a>
<a name="ln1030"> </a>
<a name="ln1031">    return InvokeHelper&lt;StorageType::IsWeakCall::value, R,</a>
<a name="ln1032">           typename StorageType::RunnableType,</a>
<a name="ln1033">           void()&gt;</a>
<a name="ln1034">               ::MakeItSo(storage-&gt;runnable_);</a>
<a name="ln1035">  }</a>
<a name="ln1036">};</a>
<a name="ln1037"> </a>
<a name="ln1038">// Arity 1 -&gt; 1.</a>
<a name="ln1039">template &lt;typename StorageType, typename R,typename X1&gt;</a>
<a name="ln1040">struct Invoker&lt;0, StorageType, R(X1)&gt; {</a>
<a name="ln1041">  typedef R(RunType)(BindStateBase*,</a>
<a name="ln1042">      typename CallbackParamTraits&lt;X1&gt;::ForwardType);</a>
<a name="ln1043"> </a>
<a name="ln1044">  typedef R(UnboundRunType)(X1);</a>
<a name="ln1045"> </a>
<a name="ln1046">  static R Run(BindStateBase* base,</a>
<a name="ln1047">      typename CallbackParamTraits&lt;X1&gt;::ForwardType x1) {</a>
<a name="ln1048">    StorageType* storage = static_cast&lt;StorageType*&gt;(base);</a>
<a name="ln1049"> </a>
<a name="ln1050">    // Local references to make debugger stepping easier. If in a debugger,</a>
<a name="ln1051">    // you really want to warp ahead and step through the</a>
<a name="ln1052">    // InvokeHelper&lt;&gt;::MakeItSo() call below.</a>
<a name="ln1053"> </a>
<a name="ln1054">    return InvokeHelper&lt;StorageType::IsWeakCall::value, R,</a>
<a name="ln1055">           typename StorageType::RunnableType,</a>
<a name="ln1056">           void(typename CallbackParamTraits&lt;X1&gt;::ForwardType x1)&gt;</a>
<a name="ln1057">               ::MakeItSo(storage-&gt;runnable_, CallbackForward(x1));</a>
<a name="ln1058">  }</a>
<a name="ln1059">};</a>
<a name="ln1060"> </a>
<a name="ln1061">// Arity 1 -&gt; 0.</a>
<a name="ln1062">template &lt;typename StorageType, typename R,typename X1&gt;</a>
<a name="ln1063">struct Invoker&lt;1, StorageType, R(X1)&gt; {</a>
<a name="ln1064">  typedef R(RunType)(BindStateBase*);</a>
<a name="ln1065"> </a>
<a name="ln1066">  typedef R(UnboundRunType)();</a>
<a name="ln1067"> </a>
<a name="ln1068">  static R Run(BindStateBase* base) {</a>
<a name="ln1069">    StorageType* storage = static_cast&lt;StorageType*&gt;(base);</a>
<a name="ln1070"> </a>
<a name="ln1071">    // Local references to make debugger stepping easier. If in a debugger,</a>
<a name="ln1072">    // you really want to warp ahead and step through the</a>
<a name="ln1073">    // InvokeHelper&lt;&gt;::MakeItSo() call below.</a>
<a name="ln1074">    typedef typename StorageType::Bound1UnwrapTraits Bound1UnwrapTraits;</a>
<a name="ln1075"> </a>
<a name="ln1076">    typename Bound1UnwrapTraits::ForwardType x1 =</a>
<a name="ln1077">        Bound1UnwrapTraits::Unwrap(storage-&gt;p1_);</a>
<a name="ln1078">    return InvokeHelper&lt;StorageType::IsWeakCall::value, R,</a>
<a name="ln1079">           typename StorageType::RunnableType,</a>
<a name="ln1080">           void(typename Bound1UnwrapTraits::ForwardType)&gt;</a>
<a name="ln1081">               ::MakeItSo(storage-&gt;runnable_, CallbackForward(x1));</a>
<a name="ln1082">  }</a>
<a name="ln1083">};</a>
<a name="ln1084"> </a>
<a name="ln1085">// Arity 2 -&gt; 2.</a>
<a name="ln1086">template &lt;typename StorageType, typename R,typename X1, typename X2&gt;</a>
<a name="ln1087">struct Invoker&lt;0, StorageType, R(X1, X2)&gt; {</a>
<a name="ln1088">  typedef R(RunType)(BindStateBase*,</a>
<a name="ln1089">      typename CallbackParamTraits&lt;X1&gt;::ForwardType,</a>
<a name="ln1090">      typename CallbackParamTraits&lt;X2&gt;::ForwardType);</a>
<a name="ln1091"> </a>
<a name="ln1092">  typedef R(UnboundRunType)(X1, X2);</a>
<a name="ln1093"> </a>
<a name="ln1094">  static R Run(BindStateBase* base,</a>
<a name="ln1095">      typename CallbackParamTraits&lt;X1&gt;::ForwardType x1,</a>
<a name="ln1096">      typename CallbackParamTraits&lt;X2&gt;::ForwardType x2) {</a>
<a name="ln1097">    StorageType* storage = static_cast&lt;StorageType*&gt;(base);</a>
<a name="ln1098"> </a>
<a name="ln1099">    // Local references to make debugger stepping easier. If in a debugger,</a>
<a name="ln1100">    // you really want to warp ahead and step through the</a>
<a name="ln1101">    // InvokeHelper&lt;&gt;::MakeItSo() call below.</a>
<a name="ln1102"> </a>
<a name="ln1103">    return InvokeHelper&lt;StorageType::IsWeakCall::value, R,</a>
<a name="ln1104">           typename StorageType::RunnableType,</a>
<a name="ln1105">           void(typename CallbackParamTraits&lt;X1&gt;::ForwardType x1,</a>
<a name="ln1106">               typename CallbackParamTraits&lt;X2&gt;::ForwardType x2)&gt;</a>
<a name="ln1107">               ::MakeItSo(storage-&gt;runnable_, CallbackForward(x1),</a>
<a name="ln1108">                   CallbackForward(x2));</a>
<a name="ln1109">  }</a>
<a name="ln1110">};</a>
<a name="ln1111"> </a>
<a name="ln1112">// Arity 2 -&gt; 1.</a>
<a name="ln1113">template &lt;typename StorageType, typename R,typename X1, typename X2&gt;</a>
<a name="ln1114">struct Invoker&lt;1, StorageType, R(X1, X2)&gt; {</a>
<a name="ln1115">  typedef R(RunType)(BindStateBase*,</a>
<a name="ln1116">      typename CallbackParamTraits&lt;X2&gt;::ForwardType);</a>
<a name="ln1117"> </a>
<a name="ln1118">  typedef R(UnboundRunType)(X2);</a>
<a name="ln1119"> </a>
<a name="ln1120">  static R Run(BindStateBase* base,</a>
<a name="ln1121">      typename CallbackParamTraits&lt;X2&gt;::ForwardType x2) {</a>
<a name="ln1122">    StorageType* storage = static_cast&lt;StorageType*&gt;(base);</a>
<a name="ln1123"> </a>
<a name="ln1124">    // Local references to make debugger stepping easier. If in a debugger,</a>
<a name="ln1125">    // you really want to warp ahead and step through the</a>
<a name="ln1126">    // InvokeHelper&lt;&gt;::MakeItSo() call below.</a>
<a name="ln1127">    typedef typename StorageType::Bound1UnwrapTraits Bound1UnwrapTraits;</a>
<a name="ln1128"> </a>
<a name="ln1129">    typename Bound1UnwrapTraits::ForwardType x1 =</a>
<a name="ln1130">        Bound1UnwrapTraits::Unwrap(storage-&gt;p1_);</a>
<a name="ln1131">    return InvokeHelper&lt;StorageType::IsWeakCall::value, R,</a>
<a name="ln1132">           typename StorageType::RunnableType,</a>
<a name="ln1133">           void(typename Bound1UnwrapTraits::ForwardType,</a>
<a name="ln1134">               typename CallbackParamTraits&lt;X2&gt;::ForwardType x2)&gt;</a>
<a name="ln1135">               ::MakeItSo(storage-&gt;runnable_, CallbackForward(x1),</a>
<a name="ln1136">                   CallbackForward(x2));</a>
<a name="ln1137">  }</a>
<a name="ln1138">};</a>
<a name="ln1139"> </a>
<a name="ln1140">// Arity 2 -&gt; 0.</a>
<a name="ln1141">template &lt;typename StorageType, typename R,typename X1, typename X2&gt;</a>
<a name="ln1142">struct Invoker&lt;2, StorageType, R(X1, X2)&gt; {</a>
<a name="ln1143">  typedef R(RunType)(BindStateBase*);</a>
<a name="ln1144"> </a>
<a name="ln1145">  typedef R(UnboundRunType)();</a>
<a name="ln1146"> </a>
<a name="ln1147">  static R Run(BindStateBase* base) {</a>
<a name="ln1148">    StorageType* storage = static_cast&lt;StorageType*&gt;(base);</a>
<a name="ln1149"> </a>
<a name="ln1150">    // Local references to make debugger stepping easier. If in a debugger,</a>
<a name="ln1151">    // you really want to warp ahead and step through the</a>
<a name="ln1152">    // InvokeHelper&lt;&gt;::MakeItSo() call below.</a>
<a name="ln1153">    typedef typename StorageType::Bound1UnwrapTraits Bound1UnwrapTraits;</a>
<a name="ln1154">    typedef typename StorageType::Bound2UnwrapTraits Bound2UnwrapTraits;</a>
<a name="ln1155"> </a>
<a name="ln1156">    typename Bound1UnwrapTraits::ForwardType x1 =</a>
<a name="ln1157">        Bound1UnwrapTraits::Unwrap(storage-&gt;p1_);</a>
<a name="ln1158">    typename Bound2UnwrapTraits::ForwardType x2 =</a>
<a name="ln1159">        Bound2UnwrapTraits::Unwrap(storage-&gt;p2_);</a>
<a name="ln1160">    return InvokeHelper&lt;StorageType::IsWeakCall::value, R,</a>
<a name="ln1161">           typename StorageType::RunnableType,</a>
<a name="ln1162">           void(typename Bound1UnwrapTraits::ForwardType,</a>
<a name="ln1163">               typename Bound2UnwrapTraits::ForwardType)&gt;</a>
<a name="ln1164">               ::MakeItSo(storage-&gt;runnable_, CallbackForward(x1),</a>
<a name="ln1165">                   CallbackForward(x2));</a>
<a name="ln1166">  }</a>
<a name="ln1167">};</a>
<a name="ln1168"> </a>
<a name="ln1169">// Arity 3 -&gt; 3.</a>
<a name="ln1170">template &lt;typename StorageType, typename R,typename X1, typename X2,</a>
<a name="ln1171">    typename X3&gt;</a>
<a name="ln1172">struct Invoker&lt;0, StorageType, R(X1, X2, X3)&gt; {</a>
<a name="ln1173">  typedef R(RunType)(BindStateBase*,</a>
<a name="ln1174">      typename CallbackParamTraits&lt;X1&gt;::ForwardType,</a>
<a name="ln1175">      typename CallbackParamTraits&lt;X2&gt;::ForwardType,</a>
<a name="ln1176">      typename CallbackParamTraits&lt;X3&gt;::ForwardType);</a>
<a name="ln1177"> </a>
<a name="ln1178">  typedef R(UnboundRunType)(X1, X2, X3);</a>
<a name="ln1179"> </a>
<a name="ln1180">  static R Run(BindStateBase* base,</a>
<a name="ln1181">      typename CallbackParamTraits&lt;X1&gt;::ForwardType x1,</a>
<a name="ln1182">      typename CallbackParamTraits&lt;X2&gt;::ForwardType x2,</a>
<a name="ln1183">      typename CallbackParamTraits&lt;X3&gt;::ForwardType x3) {</a>
<a name="ln1184">    StorageType* storage = static_cast&lt;StorageType*&gt;(base);</a>
<a name="ln1185"> </a>
<a name="ln1186">    // Local references to make debugger stepping easier. If in a debugger,</a>
<a name="ln1187">    // you really want to warp ahead and step through the</a>
<a name="ln1188">    // InvokeHelper&lt;&gt;::MakeItSo() call below.</a>
<a name="ln1189"> </a>
<a name="ln1190">    return InvokeHelper&lt;StorageType::IsWeakCall::value, R,</a>
<a name="ln1191">           typename StorageType::RunnableType,</a>
<a name="ln1192">           void(typename CallbackParamTraits&lt;X1&gt;::ForwardType x1,</a>
<a name="ln1193">               typename CallbackParamTraits&lt;X2&gt;::ForwardType x2,</a>
<a name="ln1194">               typename CallbackParamTraits&lt;X3&gt;::ForwardType x3)&gt;</a>
<a name="ln1195">               ::MakeItSo(storage-&gt;runnable_, CallbackForward(x1),</a>
<a name="ln1196">                   CallbackForward(x2), CallbackForward(x3));</a>
<a name="ln1197">  }</a>
<a name="ln1198">};</a>
<a name="ln1199"> </a>
<a name="ln1200">// Arity 3 -&gt; 2.</a>
<a name="ln1201">template &lt;typename StorageType, typename R,typename X1, typename X2,</a>
<a name="ln1202">    typename X3&gt;</a>
<a name="ln1203">struct Invoker&lt;1, StorageType, R(X1, X2, X3)&gt; {</a>
<a name="ln1204">  typedef R(RunType)(BindStateBase*,</a>
<a name="ln1205">      typename CallbackParamTraits&lt;X2&gt;::ForwardType,</a>
<a name="ln1206">      typename CallbackParamTraits&lt;X3&gt;::ForwardType);</a>
<a name="ln1207"> </a>
<a name="ln1208">  typedef R(UnboundRunType)(X2, X3);</a>
<a name="ln1209"> </a>
<a name="ln1210">  static R Run(BindStateBase* base,</a>
<a name="ln1211">      typename CallbackParamTraits&lt;X2&gt;::ForwardType x2,</a>
<a name="ln1212">      typename CallbackParamTraits&lt;X3&gt;::ForwardType x3) {</a>
<a name="ln1213">    StorageType* storage = static_cast&lt;StorageType*&gt;(base);</a>
<a name="ln1214"> </a>
<a name="ln1215">    // Local references to make debugger stepping easier. If in a debugger,</a>
<a name="ln1216">    // you really want to warp ahead and step through the</a>
<a name="ln1217">    // InvokeHelper&lt;&gt;::MakeItSo() call below.</a>
<a name="ln1218">    typedef typename StorageType::Bound1UnwrapTraits Bound1UnwrapTraits;</a>
<a name="ln1219"> </a>
<a name="ln1220">    typename Bound1UnwrapTraits::ForwardType x1 =</a>
<a name="ln1221">        Bound1UnwrapTraits::Unwrap(storage-&gt;p1_);</a>
<a name="ln1222">    return InvokeHelper&lt;StorageType::IsWeakCall::value, R,</a>
<a name="ln1223">           typename StorageType::RunnableType,</a>
<a name="ln1224">           void(typename Bound1UnwrapTraits::ForwardType,</a>
<a name="ln1225">               typename CallbackParamTraits&lt;X2&gt;::ForwardType x2,</a>
<a name="ln1226">               typename CallbackParamTraits&lt;X3&gt;::ForwardType x3)&gt;</a>
<a name="ln1227">               ::MakeItSo(storage-&gt;runnable_, CallbackForward(x1),</a>
<a name="ln1228">                   CallbackForward(x2), CallbackForward(x3));</a>
<a name="ln1229">  }</a>
<a name="ln1230">};</a>
<a name="ln1231"> </a>
<a name="ln1232">// Arity 3 -&gt; 1.</a>
<a name="ln1233">template &lt;typename StorageType, typename R,typename X1, typename X2,</a>
<a name="ln1234">    typename X3&gt;</a>
<a name="ln1235">struct Invoker&lt;2, StorageType, R(X1, X2, X3)&gt; {</a>
<a name="ln1236">  typedef R(RunType)(BindStateBase*,</a>
<a name="ln1237">      typename CallbackParamTraits&lt;X3&gt;::ForwardType);</a>
<a name="ln1238"> </a>
<a name="ln1239">  typedef R(UnboundRunType)(X3);</a>
<a name="ln1240"> </a>
<a name="ln1241">  static R Run(BindStateBase* base,</a>
<a name="ln1242">      typename CallbackParamTraits&lt;X3&gt;::ForwardType x3) {</a>
<a name="ln1243">    StorageType* storage = static_cast&lt;StorageType*&gt;(base);</a>
<a name="ln1244"> </a>
<a name="ln1245">    // Local references to make debugger stepping easier. If in a debugger,</a>
<a name="ln1246">    // you really want to warp ahead and step through the</a>
<a name="ln1247">    // InvokeHelper&lt;&gt;::MakeItSo() call below.</a>
<a name="ln1248">    typedef typename StorageType::Bound1UnwrapTraits Bound1UnwrapTraits;</a>
<a name="ln1249">    typedef typename StorageType::Bound2UnwrapTraits Bound2UnwrapTraits;</a>
<a name="ln1250"> </a>
<a name="ln1251">    typename Bound1UnwrapTraits::ForwardType x1 =</a>
<a name="ln1252">        Bound1UnwrapTraits::Unwrap(storage-&gt;p1_);</a>
<a name="ln1253">    typename Bound2UnwrapTraits::ForwardType x2 =</a>
<a name="ln1254">        Bound2UnwrapTraits::Unwrap(storage-&gt;p2_);</a>
<a name="ln1255">    return InvokeHelper&lt;StorageType::IsWeakCall::value, R,</a>
<a name="ln1256">           typename StorageType::RunnableType,</a>
<a name="ln1257">           void(typename Bound1UnwrapTraits::ForwardType,</a>
<a name="ln1258">               typename Bound2UnwrapTraits::ForwardType,</a>
<a name="ln1259">               typename CallbackParamTraits&lt;X3&gt;::ForwardType x3)&gt;</a>
<a name="ln1260">               ::MakeItSo(storage-&gt;runnable_, CallbackForward(x1),</a>
<a name="ln1261">                   CallbackForward(x2), CallbackForward(x3));</a>
<a name="ln1262">  }</a>
<a name="ln1263">};</a>
<a name="ln1264"> </a>
<a name="ln1265">// Arity 3 -&gt; 0.</a>
<a name="ln1266">template &lt;typename StorageType, typename R,typename X1, typename X2,</a>
<a name="ln1267">    typename X3&gt;</a>
<a name="ln1268">struct Invoker&lt;3, StorageType, R(X1, X2, X3)&gt; {</a>
<a name="ln1269">  typedef R(RunType)(BindStateBase*);</a>
<a name="ln1270"> </a>
<a name="ln1271">  typedef R(UnboundRunType)();</a>
<a name="ln1272"> </a>
<a name="ln1273">  static R Run(BindStateBase* base) {</a>
<a name="ln1274">    StorageType* storage = static_cast&lt;StorageType*&gt;(base);</a>
<a name="ln1275"> </a>
<a name="ln1276">    // Local references to make debugger stepping easier. If in a debugger,</a>
<a name="ln1277">    // you really want to warp ahead and step through the</a>
<a name="ln1278">    // InvokeHelper&lt;&gt;::MakeItSo() call below.</a>
<a name="ln1279">    typedef typename StorageType::Bound1UnwrapTraits Bound1UnwrapTraits;</a>
<a name="ln1280">    typedef typename StorageType::Bound2UnwrapTraits Bound2UnwrapTraits;</a>
<a name="ln1281">    typedef typename StorageType::Bound3UnwrapTraits Bound3UnwrapTraits;</a>
<a name="ln1282"> </a>
<a name="ln1283">    typename Bound1UnwrapTraits::ForwardType x1 =</a>
<a name="ln1284">        Bound1UnwrapTraits::Unwrap(storage-&gt;p1_);</a>
<a name="ln1285">    typename Bound2UnwrapTraits::ForwardType x2 =</a>
<a name="ln1286">        Bound2UnwrapTraits::Unwrap(storage-&gt;p2_);</a>
<a name="ln1287">    typename Bound3UnwrapTraits::ForwardType x3 =</a>
<a name="ln1288">        Bound3UnwrapTraits::Unwrap(storage-&gt;p3_);</a>
<a name="ln1289">    return InvokeHelper&lt;StorageType::IsWeakCall::value, R,</a>
<a name="ln1290">           typename StorageType::RunnableType,</a>
<a name="ln1291">           void(typename Bound1UnwrapTraits::ForwardType,</a>
<a name="ln1292">               typename Bound2UnwrapTraits::ForwardType,</a>
<a name="ln1293">               typename Bound3UnwrapTraits::ForwardType)&gt;</a>
<a name="ln1294">               ::MakeItSo(storage-&gt;runnable_, CallbackForward(x1),</a>
<a name="ln1295">                   CallbackForward(x2), CallbackForward(x3));</a>
<a name="ln1296">  }</a>
<a name="ln1297">};</a>
<a name="ln1298"> </a>
<a name="ln1299">// Arity 4 -&gt; 4.</a>
<a name="ln1300">template &lt;typename StorageType, typename R,typename X1, typename X2,</a>
<a name="ln1301">    typename X3, typename X4&gt;</a>
<a name="ln1302">struct Invoker&lt;0, StorageType, R(X1, X2, X3, X4)&gt; {</a>
<a name="ln1303">  typedef R(RunType)(BindStateBase*,</a>
<a name="ln1304">      typename CallbackParamTraits&lt;X1&gt;::ForwardType,</a>
<a name="ln1305">      typename CallbackParamTraits&lt;X2&gt;::ForwardType,</a>
<a name="ln1306">      typename CallbackParamTraits&lt;X3&gt;::ForwardType,</a>
<a name="ln1307">      typename CallbackParamTraits&lt;X4&gt;::ForwardType);</a>
<a name="ln1308"> </a>
<a name="ln1309">  typedef R(UnboundRunType)(X1, X2, X3, X4);</a>
<a name="ln1310"> </a>
<a name="ln1311">  static R Run(BindStateBase* base,</a>
<a name="ln1312">      typename CallbackParamTraits&lt;X1&gt;::ForwardType x1,</a>
<a name="ln1313">      typename CallbackParamTraits&lt;X2&gt;::ForwardType x2,</a>
<a name="ln1314">      typename CallbackParamTraits&lt;X3&gt;::ForwardType x3,</a>
<a name="ln1315">      typename CallbackParamTraits&lt;X4&gt;::ForwardType x4) {</a>
<a name="ln1316">    StorageType* storage = static_cast&lt;StorageType*&gt;(base);</a>
<a name="ln1317"> </a>
<a name="ln1318">    // Local references to make debugger stepping easier. If in a debugger,</a>
<a name="ln1319">    // you really want to warp ahead and step through the</a>
<a name="ln1320">    // InvokeHelper&lt;&gt;::MakeItSo() call below.</a>
<a name="ln1321"> </a>
<a name="ln1322">    return InvokeHelper&lt;StorageType::IsWeakCall::value, R,</a>
<a name="ln1323">           typename StorageType::RunnableType,</a>
<a name="ln1324">           void(typename CallbackParamTraits&lt;X1&gt;::ForwardType x1,</a>
<a name="ln1325">               typename CallbackParamTraits&lt;X2&gt;::ForwardType x2,</a>
<a name="ln1326">               typename CallbackParamTraits&lt;X3&gt;::ForwardType x3,</a>
<a name="ln1327">               typename CallbackParamTraits&lt;X4&gt;::ForwardType x4)&gt;</a>
<a name="ln1328">               ::MakeItSo(storage-&gt;runnable_, CallbackForward(x1),</a>
<a name="ln1329">                   CallbackForward(x2), CallbackForward(x3),</a>
<a name="ln1330">                   CallbackForward(x4));</a>
<a name="ln1331">  }</a>
<a name="ln1332">};</a>
<a name="ln1333"> </a>
<a name="ln1334">// Arity 4 -&gt; 3.</a>
<a name="ln1335">template &lt;typename StorageType, typename R,typename X1, typename X2,</a>
<a name="ln1336">    typename X3, typename X4&gt;</a>
<a name="ln1337">struct Invoker&lt;1, StorageType, R(X1, X2, X3, X4)&gt; {</a>
<a name="ln1338">  typedef R(RunType)(BindStateBase*,</a>
<a name="ln1339">      typename CallbackParamTraits&lt;X2&gt;::ForwardType,</a>
<a name="ln1340">      typename CallbackParamTraits&lt;X3&gt;::ForwardType,</a>
<a name="ln1341">      typename CallbackParamTraits&lt;X4&gt;::ForwardType);</a>
<a name="ln1342"> </a>
<a name="ln1343">  typedef R(UnboundRunType)(X2, X3, X4);</a>
<a name="ln1344"> </a>
<a name="ln1345">  static R Run(BindStateBase* base,</a>
<a name="ln1346">      typename CallbackParamTraits&lt;X2&gt;::ForwardType x2,</a>
<a name="ln1347">      typename CallbackParamTraits&lt;X3&gt;::ForwardType x3,</a>
<a name="ln1348">      typename CallbackParamTraits&lt;X4&gt;::ForwardType x4) {</a>
<a name="ln1349">    StorageType* storage = static_cast&lt;StorageType*&gt;(base);</a>
<a name="ln1350"> </a>
<a name="ln1351">    // Local references to make debugger stepping easier. If in a debugger,</a>
<a name="ln1352">    // you really want to warp ahead and step through the</a>
<a name="ln1353">    // InvokeHelper&lt;&gt;::MakeItSo() call below.</a>
<a name="ln1354">    typedef typename StorageType::Bound1UnwrapTraits Bound1UnwrapTraits;</a>
<a name="ln1355"> </a>
<a name="ln1356">    typename Bound1UnwrapTraits::ForwardType x1 =</a>
<a name="ln1357">        Bound1UnwrapTraits::Unwrap(storage-&gt;p1_);</a>
<a name="ln1358">    return InvokeHelper&lt;StorageType::IsWeakCall::value, R,</a>
<a name="ln1359">           typename StorageType::RunnableType,</a>
<a name="ln1360">           void(typename Bound1UnwrapTraits::ForwardType,</a>
<a name="ln1361">               typename CallbackParamTraits&lt;X2&gt;::ForwardType x2,</a>
<a name="ln1362">               typename CallbackParamTraits&lt;X3&gt;::ForwardType x3,</a>
<a name="ln1363">               typename CallbackParamTraits&lt;X4&gt;::ForwardType x4)&gt;</a>
<a name="ln1364">               ::MakeItSo(storage-&gt;runnable_, CallbackForward(x1),</a>
<a name="ln1365">                   CallbackForward(x2), CallbackForward(x3),</a>
<a name="ln1366">                   CallbackForward(x4));</a>
<a name="ln1367">  }</a>
<a name="ln1368">};</a>
<a name="ln1369"> </a>
<a name="ln1370">// Arity 4 -&gt; 2.</a>
<a name="ln1371">template &lt;typename StorageType, typename R,typename X1, typename X2,</a>
<a name="ln1372">    typename X3, typename X4&gt;</a>
<a name="ln1373">struct Invoker&lt;2, StorageType, R(X1, X2, X3, X4)&gt; {</a>
<a name="ln1374">  typedef R(RunType)(BindStateBase*,</a>
<a name="ln1375">      typename CallbackParamTraits&lt;X3&gt;::ForwardType,</a>
<a name="ln1376">      typename CallbackParamTraits&lt;X4&gt;::ForwardType);</a>
<a name="ln1377"> </a>
<a name="ln1378">  typedef R(UnboundRunType)(X3, X4);</a>
<a name="ln1379"> </a>
<a name="ln1380">  static R Run(BindStateBase* base,</a>
<a name="ln1381">      typename CallbackParamTraits&lt;X3&gt;::ForwardType x3,</a>
<a name="ln1382">      typename CallbackParamTraits&lt;X4&gt;::ForwardType x4) {</a>
<a name="ln1383">    StorageType* storage = static_cast&lt;StorageType*&gt;(base);</a>
<a name="ln1384"> </a>
<a name="ln1385">    // Local references to make debugger stepping easier. If in a debugger,</a>
<a name="ln1386">    // you really want to warp ahead and step through the</a>
<a name="ln1387">    // InvokeHelper&lt;&gt;::MakeItSo() call below.</a>
<a name="ln1388">    typedef typename StorageType::Bound1UnwrapTraits Bound1UnwrapTraits;</a>
<a name="ln1389">    typedef typename StorageType::Bound2UnwrapTraits Bound2UnwrapTraits;</a>
<a name="ln1390"> </a>
<a name="ln1391">    typename Bound1UnwrapTraits::ForwardType x1 =</a>
<a name="ln1392">        Bound1UnwrapTraits::Unwrap(storage-&gt;p1_);</a>
<a name="ln1393">    typename Bound2UnwrapTraits::ForwardType x2 =</a>
<a name="ln1394">        Bound2UnwrapTraits::Unwrap(storage-&gt;p2_);</a>
<a name="ln1395">    return InvokeHelper&lt;StorageType::IsWeakCall::value, R,</a>
<a name="ln1396">           typename StorageType::RunnableType,</a>
<a name="ln1397">           void(typename Bound1UnwrapTraits::ForwardType,</a>
<a name="ln1398">               typename Bound2UnwrapTraits::ForwardType,</a>
<a name="ln1399">               typename CallbackParamTraits&lt;X3&gt;::ForwardType x3,</a>
<a name="ln1400">               typename CallbackParamTraits&lt;X4&gt;::ForwardType x4)&gt;</a>
<a name="ln1401">               ::MakeItSo(storage-&gt;runnable_, CallbackForward(x1),</a>
<a name="ln1402">                   CallbackForward(x2), CallbackForward(x3),</a>
<a name="ln1403">                   CallbackForward(x4));</a>
<a name="ln1404">  }</a>
<a name="ln1405">};</a>
<a name="ln1406"> </a>
<a name="ln1407">// Arity 4 -&gt; 1.</a>
<a name="ln1408">template &lt;typename StorageType, typename R,typename X1, typename X2,</a>
<a name="ln1409">    typename X3, typename X4&gt;</a>
<a name="ln1410">struct Invoker&lt;3, StorageType, R(X1, X2, X3, X4)&gt; {</a>
<a name="ln1411">  typedef R(RunType)(BindStateBase*,</a>
<a name="ln1412">      typename CallbackParamTraits&lt;X4&gt;::ForwardType);</a>
<a name="ln1413"> </a>
<a name="ln1414">  typedef R(UnboundRunType)(X4);</a>
<a name="ln1415"> </a>
<a name="ln1416">  static R Run(BindStateBase* base,</a>
<a name="ln1417">      typename CallbackParamTraits&lt;X4&gt;::ForwardType x4) {</a>
<a name="ln1418">    StorageType* storage = static_cast&lt;StorageType*&gt;(base);</a>
<a name="ln1419"> </a>
<a name="ln1420">    // Local references to make debugger stepping easier. If in a debugger,</a>
<a name="ln1421">    // you really want to warp ahead and step through the</a>
<a name="ln1422">    // InvokeHelper&lt;&gt;::MakeItSo() call below.</a>
<a name="ln1423">    typedef typename StorageType::Bound1UnwrapTraits Bound1UnwrapTraits;</a>
<a name="ln1424">    typedef typename StorageType::Bound2UnwrapTraits Bound2UnwrapTraits;</a>
<a name="ln1425">    typedef typename StorageType::Bound3UnwrapTraits Bound3UnwrapTraits;</a>
<a name="ln1426"> </a>
<a name="ln1427">    typename Bound1UnwrapTraits::ForwardType x1 =</a>
<a name="ln1428">        Bound1UnwrapTraits::Unwrap(storage-&gt;p1_);</a>
<a name="ln1429">    typename Bound2UnwrapTraits::ForwardType x2 =</a>
<a name="ln1430">        Bound2UnwrapTraits::Unwrap(storage-&gt;p2_);</a>
<a name="ln1431">    typename Bound3UnwrapTraits::ForwardType x3 =</a>
<a name="ln1432">        Bound3UnwrapTraits::Unwrap(storage-&gt;p3_);</a>
<a name="ln1433">    return InvokeHelper&lt;StorageType::IsWeakCall::value, R,</a>
<a name="ln1434">           typename StorageType::RunnableType,</a>
<a name="ln1435">           void(typename Bound1UnwrapTraits::ForwardType,</a>
<a name="ln1436">               typename Bound2UnwrapTraits::ForwardType,</a>
<a name="ln1437">               typename Bound3UnwrapTraits::ForwardType,</a>
<a name="ln1438">               typename CallbackParamTraits&lt;X4&gt;::ForwardType x4)&gt;</a>
<a name="ln1439">               ::MakeItSo(storage-&gt;runnable_, CallbackForward(x1),</a>
<a name="ln1440">                   CallbackForward(x2), CallbackForward(x3),</a>
<a name="ln1441">                   CallbackForward(x4));</a>
<a name="ln1442">  }</a>
<a name="ln1443">};</a>
<a name="ln1444"> </a>
<a name="ln1445">// Arity 4 -&gt; 0.</a>
<a name="ln1446">template &lt;typename StorageType, typename R,typename X1, typename X2,</a>
<a name="ln1447">    typename X3, typename X4&gt;</a>
<a name="ln1448">struct Invoker&lt;4, StorageType, R(X1, X2, X3, X4)&gt; {</a>
<a name="ln1449">  typedef R(RunType)(BindStateBase*);</a>
<a name="ln1450"> </a>
<a name="ln1451">  typedef R(UnboundRunType)();</a>
<a name="ln1452"> </a>
<a name="ln1453">  static R Run(BindStateBase* base) {</a>
<a name="ln1454">    StorageType* storage = static_cast&lt;StorageType*&gt;(base);</a>
<a name="ln1455"> </a>
<a name="ln1456">    // Local references to make debugger stepping easier. If in a debugger,</a>
<a name="ln1457">    // you really want to warp ahead and step through the</a>
<a name="ln1458">    // InvokeHelper&lt;&gt;::MakeItSo() call below.</a>
<a name="ln1459">    typedef typename StorageType::Bound1UnwrapTraits Bound1UnwrapTraits;</a>
<a name="ln1460">    typedef typename StorageType::Bound2UnwrapTraits Bound2UnwrapTraits;</a>
<a name="ln1461">    typedef typename StorageType::Bound3UnwrapTraits Bound3UnwrapTraits;</a>
<a name="ln1462">    typedef typename StorageType::Bound4UnwrapTraits Bound4UnwrapTraits;</a>
<a name="ln1463"> </a>
<a name="ln1464">    typename Bound1UnwrapTraits::ForwardType x1 =</a>
<a name="ln1465">        Bound1UnwrapTraits::Unwrap(storage-&gt;p1_);</a>
<a name="ln1466">    typename Bound2UnwrapTraits::ForwardType x2 =</a>
<a name="ln1467">        Bound2UnwrapTraits::Unwrap(storage-&gt;p2_);</a>
<a name="ln1468">    typename Bound3UnwrapTraits::ForwardType x3 =</a>
<a name="ln1469">        Bound3UnwrapTraits::Unwrap(storage-&gt;p3_);</a>
<a name="ln1470">    typename Bound4UnwrapTraits::ForwardType x4 =</a>
<a name="ln1471">        Bound4UnwrapTraits::Unwrap(storage-&gt;p4_);</a>
<a name="ln1472">    return InvokeHelper&lt;StorageType::IsWeakCall::value, R,</a>
<a name="ln1473">           typename StorageType::RunnableType,</a>
<a name="ln1474">           void(typename Bound1UnwrapTraits::ForwardType,</a>
<a name="ln1475">               typename Bound2UnwrapTraits::ForwardType,</a>
<a name="ln1476">               typename Bound3UnwrapTraits::ForwardType,</a>
<a name="ln1477">               typename Bound4UnwrapTraits::ForwardType)&gt;</a>
<a name="ln1478">               ::MakeItSo(storage-&gt;runnable_, CallbackForward(x1),</a>
<a name="ln1479">                   CallbackForward(x2), CallbackForward(x3),</a>
<a name="ln1480">                   CallbackForward(x4));</a>
<a name="ln1481">  }</a>
<a name="ln1482">};</a>
<a name="ln1483"> </a>
<a name="ln1484">// Arity 5 -&gt; 5.</a>
<a name="ln1485">template &lt;typename StorageType, typename R,typename X1, typename X2,</a>
<a name="ln1486">    typename X3, typename X4, typename X5&gt;</a>
<a name="ln1487">struct Invoker&lt;0, StorageType, R(X1, X2, X3, X4, X5)&gt; {</a>
<a name="ln1488">  typedef R(RunType)(BindStateBase*,</a>
<a name="ln1489">      typename CallbackParamTraits&lt;X1&gt;::ForwardType,</a>
<a name="ln1490">      typename CallbackParamTraits&lt;X2&gt;::ForwardType,</a>
<a name="ln1491">      typename CallbackParamTraits&lt;X3&gt;::ForwardType,</a>
<a name="ln1492">      typename CallbackParamTraits&lt;X4&gt;::ForwardType,</a>
<a name="ln1493">      typename CallbackParamTraits&lt;X5&gt;::ForwardType);</a>
<a name="ln1494"> </a>
<a name="ln1495">  typedef R(UnboundRunType)(X1, X2, X3, X4, X5);</a>
<a name="ln1496"> </a>
<a name="ln1497">  static R Run(BindStateBase* base,</a>
<a name="ln1498">      typename CallbackParamTraits&lt;X1&gt;::ForwardType x1,</a>
<a name="ln1499">      typename CallbackParamTraits&lt;X2&gt;::ForwardType x2,</a>
<a name="ln1500">      typename CallbackParamTraits&lt;X3&gt;::ForwardType x3,</a>
<a name="ln1501">      typename CallbackParamTraits&lt;X4&gt;::ForwardType x4,</a>
<a name="ln1502">      typename CallbackParamTraits&lt;X5&gt;::ForwardType x5) {</a>
<a name="ln1503">    StorageType* storage = static_cast&lt;StorageType*&gt;(base);</a>
<a name="ln1504"> </a>
<a name="ln1505">    // Local references to make debugger stepping easier. If in a debugger,</a>
<a name="ln1506">    // you really want to warp ahead and step through the</a>
<a name="ln1507">    // InvokeHelper&lt;&gt;::MakeItSo() call below.</a>
<a name="ln1508"> </a>
<a name="ln1509">    return InvokeHelper&lt;StorageType::IsWeakCall::value, R,</a>
<a name="ln1510">           typename StorageType::RunnableType,</a>
<a name="ln1511">           void(typename CallbackParamTraits&lt;X1&gt;::ForwardType x1,</a>
<a name="ln1512">               typename CallbackParamTraits&lt;X2&gt;::ForwardType x2,</a>
<a name="ln1513">               typename CallbackParamTraits&lt;X3&gt;::ForwardType x3,</a>
<a name="ln1514">               typename CallbackParamTraits&lt;X4&gt;::ForwardType x4,</a>
<a name="ln1515">               typename CallbackParamTraits&lt;X5&gt;::ForwardType x5)&gt;</a>
<a name="ln1516">               ::MakeItSo(storage-&gt;runnable_, CallbackForward(x1),</a>
<a name="ln1517">                   CallbackForward(x2), CallbackForward(x3),</a>
<a name="ln1518">                   CallbackForward(x4), CallbackForward(x5));</a>
<a name="ln1519">  }</a>
<a name="ln1520">};</a>
<a name="ln1521"> </a>
<a name="ln1522">// Arity 5 -&gt; 4.</a>
<a name="ln1523">template &lt;typename StorageType, typename R,typename X1, typename X2,</a>
<a name="ln1524">    typename X3, typename X4, typename X5&gt;</a>
<a name="ln1525">struct Invoker&lt;1, StorageType, R(X1, X2, X3, X4, X5)&gt; {</a>
<a name="ln1526">  typedef R(RunType)(BindStateBase*,</a>
<a name="ln1527">      typename CallbackParamTraits&lt;X2&gt;::ForwardType,</a>
<a name="ln1528">      typename CallbackParamTraits&lt;X3&gt;::ForwardType,</a>
<a name="ln1529">      typename CallbackParamTraits&lt;X4&gt;::ForwardType,</a>
<a name="ln1530">      typename CallbackParamTraits&lt;X5&gt;::ForwardType);</a>
<a name="ln1531"> </a>
<a name="ln1532">  typedef R(UnboundRunType)(X2, X3, X4, X5);</a>
<a name="ln1533"> </a>
<a name="ln1534">  static R Run(BindStateBase* base,</a>
<a name="ln1535">      typename CallbackParamTraits&lt;X2&gt;::ForwardType x2,</a>
<a name="ln1536">      typename CallbackParamTraits&lt;X3&gt;::ForwardType x3,</a>
<a name="ln1537">      typename CallbackParamTraits&lt;X4&gt;::ForwardType x4,</a>
<a name="ln1538">      typename CallbackParamTraits&lt;X5&gt;::ForwardType x5) {</a>
<a name="ln1539">    StorageType* storage = static_cast&lt;StorageType*&gt;(base);</a>
<a name="ln1540"> </a>
<a name="ln1541">    // Local references to make debugger stepping easier. If in a debugger,</a>
<a name="ln1542">    // you really want to warp ahead and step through the</a>
<a name="ln1543">    // InvokeHelper&lt;&gt;::MakeItSo() call below.</a>
<a name="ln1544">    typedef typename StorageType::Bound1UnwrapTraits Bound1UnwrapTraits;</a>
<a name="ln1545"> </a>
<a name="ln1546">    typename Bound1UnwrapTraits::ForwardType x1 =</a>
<a name="ln1547">        Bound1UnwrapTraits::Unwrap(storage-&gt;p1_);</a>
<a name="ln1548">    return InvokeHelper&lt;StorageType::IsWeakCall::value, R,</a>
<a name="ln1549">           typename StorageType::RunnableType,</a>
<a name="ln1550">           void(typename Bound1UnwrapTraits::ForwardType,</a>
<a name="ln1551">               typename CallbackParamTraits&lt;X2&gt;::ForwardType x2,</a>
<a name="ln1552">               typename CallbackParamTraits&lt;X3&gt;::ForwardType x3,</a>
<a name="ln1553">               typename CallbackParamTraits&lt;X4&gt;::ForwardType x4,</a>
<a name="ln1554">               typename CallbackParamTraits&lt;X5&gt;::ForwardType x5)&gt;</a>
<a name="ln1555">               ::MakeItSo(storage-&gt;runnable_, CallbackForward(x1),</a>
<a name="ln1556">                   CallbackForward(x2), CallbackForward(x3),</a>
<a name="ln1557">                   CallbackForward(x4), CallbackForward(x5));</a>
<a name="ln1558">  }</a>
<a name="ln1559">};</a>
<a name="ln1560"> </a>
<a name="ln1561">// Arity 5 -&gt; 3.</a>
<a name="ln1562">template &lt;typename StorageType, typename R,typename X1, typename X2,</a>
<a name="ln1563">    typename X3, typename X4, typename X5&gt;</a>
<a name="ln1564">struct Invoker&lt;2, StorageType, R(X1, X2, X3, X4, X5)&gt; {</a>
<a name="ln1565">  typedef R(RunType)(BindStateBase*,</a>
<a name="ln1566">      typename CallbackParamTraits&lt;X3&gt;::ForwardType,</a>
<a name="ln1567">      typename CallbackParamTraits&lt;X4&gt;::ForwardType,</a>
<a name="ln1568">      typename CallbackParamTraits&lt;X5&gt;::ForwardType);</a>
<a name="ln1569"> </a>
<a name="ln1570">  typedef R(UnboundRunType)(X3, X4, X5);</a>
<a name="ln1571"> </a>
<a name="ln1572">  static R Run(BindStateBase* base,</a>
<a name="ln1573">      typename CallbackParamTraits&lt;X3&gt;::ForwardType x3,</a>
<a name="ln1574">      typename CallbackParamTraits&lt;X4&gt;::ForwardType x4,</a>
<a name="ln1575">      typename CallbackParamTraits&lt;X5&gt;::ForwardType x5) {</a>
<a name="ln1576">    StorageType* storage = static_cast&lt;StorageType*&gt;(base);</a>
<a name="ln1577"> </a>
<a name="ln1578">    // Local references to make debugger stepping easier. If in a debugger,</a>
<a name="ln1579">    // you really want to warp ahead and step through the</a>
<a name="ln1580">    // InvokeHelper&lt;&gt;::MakeItSo() call below.</a>
<a name="ln1581">    typedef typename StorageType::Bound1UnwrapTraits Bound1UnwrapTraits;</a>
<a name="ln1582">    typedef typename StorageType::Bound2UnwrapTraits Bound2UnwrapTraits;</a>
<a name="ln1583"> </a>
<a name="ln1584">    typename Bound1UnwrapTraits::ForwardType x1 =</a>
<a name="ln1585">        Bound1UnwrapTraits::Unwrap(storage-&gt;p1_);</a>
<a name="ln1586">    typename Bound2UnwrapTraits::ForwardType x2 =</a>
<a name="ln1587">        Bound2UnwrapTraits::Unwrap(storage-&gt;p2_);</a>
<a name="ln1588">    return InvokeHelper&lt;StorageType::IsWeakCall::value, R,</a>
<a name="ln1589">           typename StorageType::RunnableType,</a>
<a name="ln1590">           void(typename Bound1UnwrapTraits::ForwardType,</a>
<a name="ln1591">               typename Bound2UnwrapTraits::ForwardType,</a>
<a name="ln1592">               typename CallbackParamTraits&lt;X3&gt;::ForwardType x3,</a>
<a name="ln1593">               typename CallbackParamTraits&lt;X4&gt;::ForwardType x4,</a>
<a name="ln1594">               typename CallbackParamTraits&lt;X5&gt;::ForwardType x5)&gt;</a>
<a name="ln1595">               ::MakeItSo(storage-&gt;runnable_, CallbackForward(x1),</a>
<a name="ln1596">                   CallbackForward(x2), CallbackForward(x3),</a>
<a name="ln1597">                   CallbackForward(x4), CallbackForward(x5));</a>
<a name="ln1598">  }</a>
<a name="ln1599">};</a>
<a name="ln1600"> </a>
<a name="ln1601">// Arity 5 -&gt; 2.</a>
<a name="ln1602">template &lt;typename StorageType, typename R,typename X1, typename X2,</a>
<a name="ln1603">    typename X3, typename X4, typename X5&gt;</a>
<a name="ln1604">struct Invoker&lt;3, StorageType, R(X1, X2, X3, X4, X5)&gt; {</a>
<a name="ln1605">  typedef R(RunType)(BindStateBase*,</a>
<a name="ln1606">      typename CallbackParamTraits&lt;X4&gt;::ForwardType,</a>
<a name="ln1607">      typename CallbackParamTraits&lt;X5&gt;::ForwardType);</a>
<a name="ln1608"> </a>
<a name="ln1609">  typedef R(UnboundRunType)(X4, X5);</a>
<a name="ln1610"> </a>
<a name="ln1611">  static R Run(BindStateBase* base,</a>
<a name="ln1612">      typename CallbackParamTraits&lt;X4&gt;::ForwardType x4,</a>
<a name="ln1613">      typename CallbackParamTraits&lt;X5&gt;::ForwardType x5) {</a>
<a name="ln1614">    StorageType* storage = static_cast&lt;StorageType*&gt;(base);</a>
<a name="ln1615"> </a>
<a name="ln1616">    // Local references to make debugger stepping easier. If in a debugger,</a>
<a name="ln1617">    // you really want to warp ahead and step through the</a>
<a name="ln1618">    // InvokeHelper&lt;&gt;::MakeItSo() call below.</a>
<a name="ln1619">    typedef typename StorageType::Bound1UnwrapTraits Bound1UnwrapTraits;</a>
<a name="ln1620">    typedef typename StorageType::Bound2UnwrapTraits Bound2UnwrapTraits;</a>
<a name="ln1621">    typedef typename StorageType::Bound3UnwrapTraits Bound3UnwrapTraits;</a>
<a name="ln1622"> </a>
<a name="ln1623">    typename Bound1UnwrapTraits::ForwardType x1 =</a>
<a name="ln1624">        Bound1UnwrapTraits::Unwrap(storage-&gt;p1_);</a>
<a name="ln1625">    typename Bound2UnwrapTraits::ForwardType x2 =</a>
<a name="ln1626">        Bound2UnwrapTraits::Unwrap(storage-&gt;p2_);</a>
<a name="ln1627">    typename Bound3UnwrapTraits::ForwardType x3 =</a>
<a name="ln1628">        Bound3UnwrapTraits::Unwrap(storage-&gt;p3_);</a>
<a name="ln1629">    return InvokeHelper&lt;StorageType::IsWeakCall::value, R,</a>
<a name="ln1630">           typename StorageType::RunnableType,</a>
<a name="ln1631">           void(typename Bound1UnwrapTraits::ForwardType,</a>
<a name="ln1632">               typename Bound2UnwrapTraits::ForwardType,</a>
<a name="ln1633">               typename Bound3UnwrapTraits::ForwardType,</a>
<a name="ln1634">               typename CallbackParamTraits&lt;X4&gt;::ForwardType x4,</a>
<a name="ln1635">               typename CallbackParamTraits&lt;X5&gt;::ForwardType x5)&gt;</a>
<a name="ln1636">               ::MakeItSo(storage-&gt;runnable_, CallbackForward(x1),</a>
<a name="ln1637">                   CallbackForward(x2), CallbackForward(x3),</a>
<a name="ln1638">                   CallbackForward(x4), CallbackForward(x5));</a>
<a name="ln1639">  }</a>
<a name="ln1640">};</a>
<a name="ln1641"> </a>
<a name="ln1642">// Arity 5 -&gt; 1.</a>
<a name="ln1643">template &lt;typename StorageType, typename R,typename X1, typename X2,</a>
<a name="ln1644">    typename X3, typename X4, typename X5&gt;</a>
<a name="ln1645">struct Invoker&lt;4, StorageType, R(X1, X2, X3, X4, X5)&gt; {</a>
<a name="ln1646">  typedef R(RunType)(BindStateBase*,</a>
<a name="ln1647">      typename CallbackParamTraits&lt;X5&gt;::ForwardType);</a>
<a name="ln1648"> </a>
<a name="ln1649">  typedef R(UnboundRunType)(X5);</a>
<a name="ln1650"> </a>
<a name="ln1651">  static R Run(BindStateBase* base,</a>
<a name="ln1652">      typename CallbackParamTraits&lt;X5&gt;::ForwardType x5) {</a>
<a name="ln1653">    StorageType* storage = static_cast&lt;StorageType*&gt;(base);</a>
<a name="ln1654"> </a>
<a name="ln1655">    // Local references to make debugger stepping easier. If in a debugger,</a>
<a name="ln1656">    // you really want to warp ahead and step through the</a>
<a name="ln1657">    // InvokeHelper&lt;&gt;::MakeItSo() call below.</a>
<a name="ln1658">    typedef typename StorageType::Bound1UnwrapTraits Bound1UnwrapTraits;</a>
<a name="ln1659">    typedef typename StorageType::Bound2UnwrapTraits Bound2UnwrapTraits;</a>
<a name="ln1660">    typedef typename StorageType::Bound3UnwrapTraits Bound3UnwrapTraits;</a>
<a name="ln1661">    typedef typename StorageType::Bound4UnwrapTraits Bound4UnwrapTraits;</a>
<a name="ln1662"> </a>
<a name="ln1663">    typename Bound1UnwrapTraits::ForwardType x1 =</a>
<a name="ln1664">        Bound1UnwrapTraits::Unwrap(storage-&gt;p1_);</a>
<a name="ln1665">    typename Bound2UnwrapTraits::ForwardType x2 =</a>
<a name="ln1666">        Bound2UnwrapTraits::Unwrap(storage-&gt;p2_);</a>
<a name="ln1667">    typename Bound3UnwrapTraits::ForwardType x3 =</a>
<a name="ln1668">        Bound3UnwrapTraits::Unwrap(storage-&gt;p3_);</a>
<a name="ln1669">    typename Bound4UnwrapTraits::ForwardType x4 =</a>
<a name="ln1670">        Bound4UnwrapTraits::Unwrap(storage-&gt;p4_);</a>
<a name="ln1671">    return InvokeHelper&lt;StorageType::IsWeakCall::value, R,</a>
<a name="ln1672">           typename StorageType::RunnableType,</a>
<a name="ln1673">           void(typename Bound1UnwrapTraits::ForwardType,</a>
<a name="ln1674">               typename Bound2UnwrapTraits::ForwardType,</a>
<a name="ln1675">               typename Bound3UnwrapTraits::ForwardType,</a>
<a name="ln1676">               typename Bound4UnwrapTraits::ForwardType,</a>
<a name="ln1677">               typename CallbackParamTraits&lt;X5&gt;::ForwardType x5)&gt;</a>
<a name="ln1678">               ::MakeItSo(storage-&gt;runnable_, CallbackForward(x1),</a>
<a name="ln1679">                   CallbackForward(x2), CallbackForward(x3),</a>
<a name="ln1680">                   CallbackForward(x4), CallbackForward(x5));</a>
<a name="ln1681">  }</a>
<a name="ln1682">};</a>
<a name="ln1683"> </a>
<a name="ln1684">// Arity 5 -&gt; 0.</a>
<a name="ln1685">template &lt;typename StorageType, typename R,typename X1, typename X2,</a>
<a name="ln1686">    typename X3, typename X4, typename X5&gt;</a>
<a name="ln1687">struct Invoker&lt;5, StorageType, R(X1, X2, X3, X4, X5)&gt; {</a>
<a name="ln1688">  typedef R(RunType)(BindStateBase*);</a>
<a name="ln1689"> </a>
<a name="ln1690">  typedef R(UnboundRunType)();</a>
<a name="ln1691"> </a>
<a name="ln1692">  static R Run(BindStateBase* base) {</a>
<a name="ln1693">    StorageType* storage = static_cast&lt;StorageType*&gt;(base);</a>
<a name="ln1694"> </a>
<a name="ln1695">    // Local references to make debugger stepping easier. If in a debugger,</a>
<a name="ln1696">    // you really want to warp ahead and step through the</a>
<a name="ln1697">    // InvokeHelper&lt;&gt;::MakeItSo() call below.</a>
<a name="ln1698">    typedef typename StorageType::Bound1UnwrapTraits Bound1UnwrapTraits;</a>
<a name="ln1699">    typedef typename StorageType::Bound2UnwrapTraits Bound2UnwrapTraits;</a>
<a name="ln1700">    typedef typename StorageType::Bound3UnwrapTraits Bound3UnwrapTraits;</a>
<a name="ln1701">    typedef typename StorageType::Bound4UnwrapTraits Bound4UnwrapTraits;</a>
<a name="ln1702">    typedef typename StorageType::Bound5UnwrapTraits Bound5UnwrapTraits;</a>
<a name="ln1703"> </a>
<a name="ln1704">    typename Bound1UnwrapTraits::ForwardType x1 =</a>
<a name="ln1705">        Bound1UnwrapTraits::Unwrap(storage-&gt;p1_);</a>
<a name="ln1706">    typename Bound2UnwrapTraits::ForwardType x2 =</a>
<a name="ln1707">        Bound2UnwrapTraits::Unwrap(storage-&gt;p2_);</a>
<a name="ln1708">    typename Bound3UnwrapTraits::ForwardType x3 =</a>
<a name="ln1709">        Bound3UnwrapTraits::Unwrap(storage-&gt;p3_);</a>
<a name="ln1710">    typename Bound4UnwrapTraits::ForwardType x4 =</a>
<a name="ln1711">        Bound4UnwrapTraits::Unwrap(storage-&gt;p4_);</a>
<a name="ln1712">    typename Bound5UnwrapTraits::ForwardType x5 =</a>
<a name="ln1713">        Bound5UnwrapTraits::Unwrap(storage-&gt;p5_);</a>
<a name="ln1714">    return InvokeHelper&lt;StorageType::IsWeakCall::value, R,</a>
<a name="ln1715">           typename StorageType::RunnableType,</a>
<a name="ln1716">           void(typename Bound1UnwrapTraits::ForwardType,</a>
<a name="ln1717">               typename Bound2UnwrapTraits::ForwardType,</a>
<a name="ln1718">               typename Bound3UnwrapTraits::ForwardType,</a>
<a name="ln1719">               typename Bound4UnwrapTraits::ForwardType,</a>
<a name="ln1720">               typename Bound5UnwrapTraits::ForwardType)&gt;</a>
<a name="ln1721">               ::MakeItSo(storage-&gt;runnable_, CallbackForward(x1),</a>
<a name="ln1722">                   CallbackForward(x2), CallbackForward(x3),</a>
<a name="ln1723">                   CallbackForward(x4), CallbackForward(x5));</a>
<a name="ln1724">  }</a>
<a name="ln1725">};</a>
<a name="ln1726"> </a>
<a name="ln1727">// Arity 6 -&gt; 6.</a>
<a name="ln1728">template &lt;typename StorageType, typename R,typename X1, typename X2,</a>
<a name="ln1729">    typename X3, typename X4, typename X5, typename X6&gt;</a>
<a name="ln1730">struct Invoker&lt;0, StorageType, R(X1, X2, X3, X4, X5, X6)&gt; {</a>
<a name="ln1731">  typedef R(RunType)(BindStateBase*,</a>
<a name="ln1732">      typename CallbackParamTraits&lt;X1&gt;::ForwardType,</a>
<a name="ln1733">      typename CallbackParamTraits&lt;X2&gt;::ForwardType,</a>
<a name="ln1734">      typename CallbackParamTraits&lt;X3&gt;::ForwardType,</a>
<a name="ln1735">      typename CallbackParamTraits&lt;X4&gt;::ForwardType,</a>
<a name="ln1736">      typename CallbackParamTraits&lt;X5&gt;::ForwardType,</a>
<a name="ln1737">      typename CallbackParamTraits&lt;X6&gt;::ForwardType);</a>
<a name="ln1738"> </a>
<a name="ln1739">  typedef R(UnboundRunType)(X1, X2, X3, X4, X5, X6);</a>
<a name="ln1740"> </a>
<a name="ln1741">  static R Run(BindStateBase* base,</a>
<a name="ln1742">      typename CallbackParamTraits&lt;X1&gt;::ForwardType x1,</a>
<a name="ln1743">      typename CallbackParamTraits&lt;X2&gt;::ForwardType x2,</a>
<a name="ln1744">      typename CallbackParamTraits&lt;X3&gt;::ForwardType x3,</a>
<a name="ln1745">      typename CallbackParamTraits&lt;X4&gt;::ForwardType x4,</a>
<a name="ln1746">      typename CallbackParamTraits&lt;X5&gt;::ForwardType x5,</a>
<a name="ln1747">      typename CallbackParamTraits&lt;X6&gt;::ForwardType x6) {</a>
<a name="ln1748">    StorageType* storage = static_cast&lt;StorageType*&gt;(base);</a>
<a name="ln1749"> </a>
<a name="ln1750">    // Local references to make debugger stepping easier. If in a debugger,</a>
<a name="ln1751">    // you really want to warp ahead and step through the</a>
<a name="ln1752">    // InvokeHelper&lt;&gt;::MakeItSo() call below.</a>
<a name="ln1753"> </a>
<a name="ln1754">    return InvokeHelper&lt;StorageType::IsWeakCall::value, R,</a>
<a name="ln1755">           typename StorageType::RunnableType,</a>
<a name="ln1756">           void(typename CallbackParamTraits&lt;X1&gt;::ForwardType x1,</a>
<a name="ln1757">               typename CallbackParamTraits&lt;X2&gt;::ForwardType x2,</a>
<a name="ln1758">               typename CallbackParamTraits&lt;X3&gt;::ForwardType x3,</a>
<a name="ln1759">               typename CallbackParamTraits&lt;X4&gt;::ForwardType x4,</a>
<a name="ln1760">               typename CallbackParamTraits&lt;X5&gt;::ForwardType x5,</a>
<a name="ln1761">               typename CallbackParamTraits&lt;X6&gt;::ForwardType x6)&gt;</a>
<a name="ln1762">               ::MakeItSo(storage-&gt;runnable_, CallbackForward(x1),</a>
<a name="ln1763">                   CallbackForward(x2), CallbackForward(x3),</a>
<a name="ln1764">                   CallbackForward(x4), CallbackForward(x5),</a>
<a name="ln1765">                   CallbackForward(x6));</a>
<a name="ln1766">  }</a>
<a name="ln1767">};</a>
<a name="ln1768"> </a>
<a name="ln1769">// Arity 6 -&gt; 5.</a>
<a name="ln1770">template &lt;typename StorageType, typename R,typename X1, typename X2,</a>
<a name="ln1771">    typename X3, typename X4, typename X5, typename X6&gt;</a>
<a name="ln1772">struct Invoker&lt;1, StorageType, R(X1, X2, X3, X4, X5, X6)&gt; {</a>
<a name="ln1773">  typedef R(RunType)(BindStateBase*,</a>
<a name="ln1774">      typename CallbackParamTraits&lt;X2&gt;::ForwardType,</a>
<a name="ln1775">      typename CallbackParamTraits&lt;X3&gt;::ForwardType,</a>
<a name="ln1776">      typename CallbackParamTraits&lt;X4&gt;::ForwardType,</a>
<a name="ln1777">      typename CallbackParamTraits&lt;X5&gt;::ForwardType,</a>
<a name="ln1778">      typename CallbackParamTraits&lt;X6&gt;::ForwardType);</a>
<a name="ln1779"> </a>
<a name="ln1780">  typedef R(UnboundRunType)(X2, X3, X4, X5, X6);</a>
<a name="ln1781"> </a>
<a name="ln1782">  static R Run(BindStateBase* base,</a>
<a name="ln1783">      typename CallbackParamTraits&lt;X2&gt;::ForwardType x2,</a>
<a name="ln1784">      typename CallbackParamTraits&lt;X3&gt;::ForwardType x3,</a>
<a name="ln1785">      typename CallbackParamTraits&lt;X4&gt;::ForwardType x4,</a>
<a name="ln1786">      typename CallbackParamTraits&lt;X5&gt;::ForwardType x5,</a>
<a name="ln1787">      typename CallbackParamTraits&lt;X6&gt;::ForwardType x6) {</a>
<a name="ln1788">    StorageType* storage = static_cast&lt;StorageType*&gt;(base);</a>
<a name="ln1789"> </a>
<a name="ln1790">    // Local references to make debugger stepping easier. If in a debugger,</a>
<a name="ln1791">    // you really want to warp ahead and step through the</a>
<a name="ln1792">    // InvokeHelper&lt;&gt;::MakeItSo() call below.</a>
<a name="ln1793">    typedef typename StorageType::Bound1UnwrapTraits Bound1UnwrapTraits;</a>
<a name="ln1794"> </a>
<a name="ln1795">    typename Bound1UnwrapTraits::ForwardType x1 =</a>
<a name="ln1796">        Bound1UnwrapTraits::Unwrap(storage-&gt;p1_);</a>
<a name="ln1797">    return InvokeHelper&lt;StorageType::IsWeakCall::value, R,</a>
<a name="ln1798">           typename StorageType::RunnableType,</a>
<a name="ln1799">           void(typename Bound1UnwrapTraits::ForwardType,</a>
<a name="ln1800">               typename CallbackParamTraits&lt;X2&gt;::ForwardType x2,</a>
<a name="ln1801">               typename CallbackParamTraits&lt;X3&gt;::ForwardType x3,</a>
<a name="ln1802">               typename CallbackParamTraits&lt;X4&gt;::ForwardType x4,</a>
<a name="ln1803">               typename CallbackParamTraits&lt;X5&gt;::ForwardType x5,</a>
<a name="ln1804">               typename CallbackParamTraits&lt;X6&gt;::ForwardType x6)&gt;</a>
<a name="ln1805">               ::MakeItSo(storage-&gt;runnable_, CallbackForward(x1),</a>
<a name="ln1806">                   CallbackForward(x2), CallbackForward(x3),</a>
<a name="ln1807">                   CallbackForward(x4), CallbackForward(x5),</a>
<a name="ln1808">                   CallbackForward(x6));</a>
<a name="ln1809">  }</a>
<a name="ln1810">};</a>
<a name="ln1811"> </a>
<a name="ln1812">// Arity 6 -&gt; 4.</a>
<a name="ln1813">template &lt;typename StorageType, typename R,typename X1, typename X2,</a>
<a name="ln1814">    typename X3, typename X4, typename X5, typename X6&gt;</a>
<a name="ln1815">struct Invoker&lt;2, StorageType, R(X1, X2, X3, X4, X5, X6)&gt; {</a>
<a name="ln1816">  typedef R(RunType)(BindStateBase*,</a>
<a name="ln1817">      typename CallbackParamTraits&lt;X3&gt;::ForwardType,</a>
<a name="ln1818">      typename CallbackParamTraits&lt;X4&gt;::ForwardType,</a>
<a name="ln1819">      typename CallbackParamTraits&lt;X5&gt;::ForwardType,</a>
<a name="ln1820">      typename CallbackParamTraits&lt;X6&gt;::ForwardType);</a>
<a name="ln1821"> </a>
<a name="ln1822">  typedef R(UnboundRunType)(X3, X4, X5, X6);</a>
<a name="ln1823"> </a>
<a name="ln1824">  static R Run(BindStateBase* base,</a>
<a name="ln1825">      typename CallbackParamTraits&lt;X3&gt;::ForwardType x3,</a>
<a name="ln1826">      typename CallbackParamTraits&lt;X4&gt;::ForwardType x4,</a>
<a name="ln1827">      typename CallbackParamTraits&lt;X5&gt;::ForwardType x5,</a>
<a name="ln1828">      typename CallbackParamTraits&lt;X6&gt;::ForwardType x6) {</a>
<a name="ln1829">    StorageType* storage = static_cast&lt;StorageType*&gt;(base);</a>
<a name="ln1830"> </a>
<a name="ln1831">    // Local references to make debugger stepping easier. If in a debugger,</a>
<a name="ln1832">    // you really want to warp ahead and step through the</a>
<a name="ln1833">    // InvokeHelper&lt;&gt;::MakeItSo() call below.</a>
<a name="ln1834">    typedef typename StorageType::Bound1UnwrapTraits Bound1UnwrapTraits;</a>
<a name="ln1835">    typedef typename StorageType::Bound2UnwrapTraits Bound2UnwrapTraits;</a>
<a name="ln1836"> </a>
<a name="ln1837">    typename Bound1UnwrapTraits::ForwardType x1 =</a>
<a name="ln1838">        Bound1UnwrapTraits::Unwrap(storage-&gt;p1_);</a>
<a name="ln1839">    typename Bound2UnwrapTraits::ForwardType x2 =</a>
<a name="ln1840">        Bound2UnwrapTraits::Unwrap(storage-&gt;p2_);</a>
<a name="ln1841">    return InvokeHelper&lt;StorageType::IsWeakCall::value, R,</a>
<a name="ln1842">           typename StorageType::RunnableType,</a>
<a name="ln1843">           void(typename Bound1UnwrapTraits::ForwardType,</a>
<a name="ln1844">               typename Bound2UnwrapTraits::ForwardType,</a>
<a name="ln1845">               typename CallbackParamTraits&lt;X3&gt;::ForwardType x3,</a>
<a name="ln1846">               typename CallbackParamTraits&lt;X4&gt;::ForwardType x4,</a>
<a name="ln1847">               typename CallbackParamTraits&lt;X5&gt;::ForwardType x5,</a>
<a name="ln1848">               typename CallbackParamTraits&lt;X6&gt;::ForwardType x6)&gt;</a>
<a name="ln1849">               ::MakeItSo(storage-&gt;runnable_, CallbackForward(x1),</a>
<a name="ln1850">                   CallbackForward(x2), CallbackForward(x3),</a>
<a name="ln1851">                   CallbackForward(x4), CallbackForward(x5),</a>
<a name="ln1852">                   CallbackForward(x6));</a>
<a name="ln1853">  }</a>
<a name="ln1854">};</a>
<a name="ln1855"> </a>
<a name="ln1856">// Arity 6 -&gt; 3.</a>
<a name="ln1857">template &lt;typename StorageType, typename R,typename X1, typename X2,</a>
<a name="ln1858">    typename X3, typename X4, typename X5, typename X6&gt;</a>
<a name="ln1859">struct Invoker&lt;3, StorageType, R(X1, X2, X3, X4, X5, X6)&gt; {</a>
<a name="ln1860">  typedef R(RunType)(BindStateBase*,</a>
<a name="ln1861">      typename CallbackParamTraits&lt;X4&gt;::ForwardType,</a>
<a name="ln1862">      typename CallbackParamTraits&lt;X5&gt;::ForwardType,</a>
<a name="ln1863">      typename CallbackParamTraits&lt;X6&gt;::ForwardType);</a>
<a name="ln1864"> </a>
<a name="ln1865">  typedef R(UnboundRunType)(X4, X5, X6);</a>
<a name="ln1866"> </a>
<a name="ln1867">  static R Run(BindStateBase* base,</a>
<a name="ln1868">      typename CallbackParamTraits&lt;X4&gt;::ForwardType x4,</a>
<a name="ln1869">      typename CallbackParamTraits&lt;X5&gt;::ForwardType x5,</a>
<a name="ln1870">      typename CallbackParamTraits&lt;X6&gt;::ForwardType x6) {</a>
<a name="ln1871">    StorageType* storage = static_cast&lt;StorageType*&gt;(base);</a>
<a name="ln1872"> </a>
<a name="ln1873">    // Local references to make debugger stepping easier. If in a debugger,</a>
<a name="ln1874">    // you really want to warp ahead and step through the</a>
<a name="ln1875">    // InvokeHelper&lt;&gt;::MakeItSo() call below.</a>
<a name="ln1876">    typedef typename StorageType::Bound1UnwrapTraits Bound1UnwrapTraits;</a>
<a name="ln1877">    typedef typename StorageType::Bound2UnwrapTraits Bound2UnwrapTraits;</a>
<a name="ln1878">    typedef typename StorageType::Bound3UnwrapTraits Bound3UnwrapTraits;</a>
<a name="ln1879"> </a>
<a name="ln1880">    typename Bound1UnwrapTraits::ForwardType x1 =</a>
<a name="ln1881">        Bound1UnwrapTraits::Unwrap(storage-&gt;p1_);</a>
<a name="ln1882">    typename Bound2UnwrapTraits::ForwardType x2 =</a>
<a name="ln1883">        Bound2UnwrapTraits::Unwrap(storage-&gt;p2_);</a>
<a name="ln1884">    typename Bound3UnwrapTraits::ForwardType x3 =</a>
<a name="ln1885">        Bound3UnwrapTraits::Unwrap(storage-&gt;p3_);</a>
<a name="ln1886">    return InvokeHelper&lt;StorageType::IsWeakCall::value, R,</a>
<a name="ln1887">           typename StorageType::RunnableType,</a>
<a name="ln1888">           void(typename Bound1UnwrapTraits::ForwardType,</a>
<a name="ln1889">               typename Bound2UnwrapTraits::ForwardType,</a>
<a name="ln1890">               typename Bound3UnwrapTraits::ForwardType,</a>
<a name="ln1891">               typename CallbackParamTraits&lt;X4&gt;::ForwardType x4,</a>
<a name="ln1892">               typename CallbackParamTraits&lt;X5&gt;::ForwardType x5,</a>
<a name="ln1893">               typename CallbackParamTraits&lt;X6&gt;::ForwardType x6)&gt;</a>
<a name="ln1894">               ::MakeItSo(storage-&gt;runnable_, CallbackForward(x1),</a>
<a name="ln1895">                   CallbackForward(x2), CallbackForward(x3),</a>
<a name="ln1896">                   CallbackForward(x4), CallbackForward(x5),</a>
<a name="ln1897">                   CallbackForward(x6));</a>
<a name="ln1898">  }</a>
<a name="ln1899">};</a>
<a name="ln1900"> </a>
<a name="ln1901">// Arity 6 -&gt; 2.</a>
<a name="ln1902">template &lt;typename StorageType, typename R,typename X1, typename X2,</a>
<a name="ln1903">    typename X3, typename X4, typename X5, typename X6&gt;</a>
<a name="ln1904">struct Invoker&lt;4, StorageType, R(X1, X2, X3, X4, X5, X6)&gt; {</a>
<a name="ln1905">  typedef R(RunType)(BindStateBase*,</a>
<a name="ln1906">      typename CallbackParamTraits&lt;X5&gt;::ForwardType,</a>
<a name="ln1907">      typename CallbackParamTraits&lt;X6&gt;::ForwardType);</a>
<a name="ln1908"> </a>
<a name="ln1909">  typedef R(UnboundRunType)(X5, X6);</a>
<a name="ln1910"> </a>
<a name="ln1911">  static R Run(BindStateBase* base,</a>
<a name="ln1912">      typename CallbackParamTraits&lt;X5&gt;::ForwardType x5,</a>
<a name="ln1913">      typename CallbackParamTraits&lt;X6&gt;::ForwardType x6) {</a>
<a name="ln1914">    StorageType* storage = static_cast&lt;StorageType*&gt;(base);</a>
<a name="ln1915"> </a>
<a name="ln1916">    // Local references to make debugger stepping easier. If in a debugger,</a>
<a name="ln1917">    // you really want to warp ahead and step through the</a>
<a name="ln1918">    // InvokeHelper&lt;&gt;::MakeItSo() call below.</a>
<a name="ln1919">    typedef typename StorageType::Bound1UnwrapTraits Bound1UnwrapTraits;</a>
<a name="ln1920">    typedef typename StorageType::Bound2UnwrapTraits Bound2UnwrapTraits;</a>
<a name="ln1921">    typedef typename StorageType::Bound3UnwrapTraits Bound3UnwrapTraits;</a>
<a name="ln1922">    typedef typename StorageType::Bound4UnwrapTraits Bound4UnwrapTraits;</a>
<a name="ln1923"> </a>
<a name="ln1924">    typename Bound1UnwrapTraits::ForwardType x1 =</a>
<a name="ln1925">        Bound1UnwrapTraits::Unwrap(storage-&gt;p1_);</a>
<a name="ln1926">    typename Bound2UnwrapTraits::ForwardType x2 =</a>
<a name="ln1927">        Bound2UnwrapTraits::Unwrap(storage-&gt;p2_);</a>
<a name="ln1928">    typename Bound3UnwrapTraits::ForwardType x3 =</a>
<a name="ln1929">        Bound3UnwrapTraits::Unwrap(storage-&gt;p3_);</a>
<a name="ln1930">    typename Bound4UnwrapTraits::ForwardType x4 =</a>
<a name="ln1931">        Bound4UnwrapTraits::Unwrap(storage-&gt;p4_);</a>
<a name="ln1932">    return InvokeHelper&lt;StorageType::IsWeakCall::value, R,</a>
<a name="ln1933">           typename StorageType::RunnableType,</a>
<a name="ln1934">           void(typename Bound1UnwrapTraits::ForwardType,</a>
<a name="ln1935">               typename Bound2UnwrapTraits::ForwardType,</a>
<a name="ln1936">               typename Bound3UnwrapTraits::ForwardType,</a>
<a name="ln1937">               typename Bound4UnwrapTraits::ForwardType,</a>
<a name="ln1938">               typename CallbackParamTraits&lt;X5&gt;::ForwardType x5,</a>
<a name="ln1939">               typename CallbackParamTraits&lt;X6&gt;::ForwardType x6)&gt;</a>
<a name="ln1940">               ::MakeItSo(storage-&gt;runnable_, CallbackForward(x1),</a>
<a name="ln1941">                   CallbackForward(x2), CallbackForward(x3),</a>
<a name="ln1942">                   CallbackForward(x4), CallbackForward(x5),</a>
<a name="ln1943">                   CallbackForward(x6));</a>
<a name="ln1944">  }</a>
<a name="ln1945">};</a>
<a name="ln1946"> </a>
<a name="ln1947">// Arity 6 -&gt; 1.</a>
<a name="ln1948">template &lt;typename StorageType, typename R,typename X1, typename X2,</a>
<a name="ln1949">    typename X3, typename X4, typename X5, typename X6&gt;</a>
<a name="ln1950">struct Invoker&lt;5, StorageType, R(X1, X2, X3, X4, X5, X6)&gt; {</a>
<a name="ln1951">  typedef R(RunType)(BindStateBase*,</a>
<a name="ln1952">      typename CallbackParamTraits&lt;X6&gt;::ForwardType);</a>
<a name="ln1953"> </a>
<a name="ln1954">  typedef R(UnboundRunType)(X6);</a>
<a name="ln1955"> </a>
<a name="ln1956">  static R Run(BindStateBase* base,</a>
<a name="ln1957">      typename CallbackParamTraits&lt;X6&gt;::ForwardType x6) {</a>
<a name="ln1958">    StorageType* storage = static_cast&lt;StorageType*&gt;(base);</a>
<a name="ln1959"> </a>
<a name="ln1960">    // Local references to make debugger stepping easier. If in a debugger,</a>
<a name="ln1961">    // you really want to warp ahead and step through the</a>
<a name="ln1962">    // InvokeHelper&lt;&gt;::MakeItSo() call below.</a>
<a name="ln1963">    typedef typename StorageType::Bound1UnwrapTraits Bound1UnwrapTraits;</a>
<a name="ln1964">    typedef typename StorageType::Bound2UnwrapTraits Bound2UnwrapTraits;</a>
<a name="ln1965">    typedef typename StorageType::Bound3UnwrapTraits Bound3UnwrapTraits;</a>
<a name="ln1966">    typedef typename StorageType::Bound4UnwrapTraits Bound4UnwrapTraits;</a>
<a name="ln1967">    typedef typename StorageType::Bound5UnwrapTraits Bound5UnwrapTraits;</a>
<a name="ln1968"> </a>
<a name="ln1969">    typename Bound1UnwrapTraits::ForwardType x1 =</a>
<a name="ln1970">        Bound1UnwrapTraits::Unwrap(storage-&gt;p1_);</a>
<a name="ln1971">    typename Bound2UnwrapTraits::ForwardType x2 =</a>
<a name="ln1972">        Bound2UnwrapTraits::Unwrap(storage-&gt;p2_);</a>
<a name="ln1973">    typename Bound3UnwrapTraits::ForwardType x3 =</a>
<a name="ln1974">        Bound3UnwrapTraits::Unwrap(storage-&gt;p3_);</a>
<a name="ln1975">    typename Bound4UnwrapTraits::ForwardType x4 =</a>
<a name="ln1976">        Bound4UnwrapTraits::Unwrap(storage-&gt;p4_);</a>
<a name="ln1977">    typename Bound5UnwrapTraits::ForwardType x5 =</a>
<a name="ln1978">        Bound5UnwrapTraits::Unwrap(storage-&gt;p5_);</a>
<a name="ln1979">    return InvokeHelper&lt;StorageType::IsWeakCall::value, R,</a>
<a name="ln1980">           typename StorageType::RunnableType,</a>
<a name="ln1981">           void(typename Bound1UnwrapTraits::ForwardType,</a>
<a name="ln1982">               typename Bound2UnwrapTraits::ForwardType,</a>
<a name="ln1983">               typename Bound3UnwrapTraits::ForwardType,</a>
<a name="ln1984">               typename Bound4UnwrapTraits::ForwardType,</a>
<a name="ln1985">               typename Bound5UnwrapTraits::ForwardType,</a>
<a name="ln1986">               typename CallbackParamTraits&lt;X6&gt;::ForwardType x6)&gt;</a>
<a name="ln1987">               ::MakeItSo(storage-&gt;runnable_, CallbackForward(x1),</a>
<a name="ln1988">                   CallbackForward(x2), CallbackForward(x3),</a>
<a name="ln1989">                   CallbackForward(x4), CallbackForward(x5),</a>
<a name="ln1990">                   CallbackForward(x6));</a>
<a name="ln1991">  }</a>
<a name="ln1992">};</a>
<a name="ln1993"> </a>
<a name="ln1994">// Arity 6 -&gt; 0.</a>
<a name="ln1995">template &lt;typename StorageType, typename R,typename X1, typename X2,</a>
<a name="ln1996">    typename X3, typename X4, typename X5, typename X6&gt;</a>
<a name="ln1997">struct Invoker&lt;6, StorageType, R(X1, X2, X3, X4, X5, X6)&gt; {</a>
<a name="ln1998">  typedef R(RunType)(BindStateBase*);</a>
<a name="ln1999"> </a>
<a name="ln2000">  typedef R(UnboundRunType)();</a>
<a name="ln2001"> </a>
<a name="ln2002">  static R Run(BindStateBase* base) {</a>
<a name="ln2003">    StorageType* storage = static_cast&lt;StorageType*&gt;(base);</a>
<a name="ln2004"> </a>
<a name="ln2005">    // Local references to make debugger stepping easier. If in a debugger,</a>
<a name="ln2006">    // you really want to warp ahead and step through the</a>
<a name="ln2007">    // InvokeHelper&lt;&gt;::MakeItSo() call below.</a>
<a name="ln2008">    typedef typename StorageType::Bound1UnwrapTraits Bound1UnwrapTraits;</a>
<a name="ln2009">    typedef typename StorageType::Bound2UnwrapTraits Bound2UnwrapTraits;</a>
<a name="ln2010">    typedef typename StorageType::Bound3UnwrapTraits Bound3UnwrapTraits;</a>
<a name="ln2011">    typedef typename StorageType::Bound4UnwrapTraits Bound4UnwrapTraits;</a>
<a name="ln2012">    typedef typename StorageType::Bound5UnwrapTraits Bound5UnwrapTraits;</a>
<a name="ln2013">    typedef typename StorageType::Bound6UnwrapTraits Bound6UnwrapTraits;</a>
<a name="ln2014"> </a>
<a name="ln2015">    typename Bound1UnwrapTraits::ForwardType x1 =</a>
<a name="ln2016">        Bound1UnwrapTraits::Unwrap(storage-&gt;p1_);</a>
<a name="ln2017">    typename Bound2UnwrapTraits::ForwardType x2 =</a>
<a name="ln2018">        Bound2UnwrapTraits::Unwrap(storage-&gt;p2_);</a>
<a name="ln2019">    typename Bound3UnwrapTraits::ForwardType x3 =</a>
<a name="ln2020">        Bound3UnwrapTraits::Unwrap(storage-&gt;p3_);</a>
<a name="ln2021">    typename Bound4UnwrapTraits::ForwardType x4 =</a>
<a name="ln2022">        Bound4UnwrapTraits::Unwrap(storage-&gt;p4_);</a>
<a name="ln2023">    typename Bound5UnwrapTraits::ForwardType x5 =</a>
<a name="ln2024">        Bound5UnwrapTraits::Unwrap(storage-&gt;p5_);</a>
<a name="ln2025">    typename Bound6UnwrapTraits::ForwardType x6 =</a>
<a name="ln2026">        Bound6UnwrapTraits::Unwrap(storage-&gt;p6_);</a>
<a name="ln2027">    return InvokeHelper&lt;StorageType::IsWeakCall::value, R,</a>
<a name="ln2028">           typename StorageType::RunnableType,</a>
<a name="ln2029">           void(typename Bound1UnwrapTraits::ForwardType,</a>
<a name="ln2030">               typename Bound2UnwrapTraits::ForwardType,</a>
<a name="ln2031">               typename Bound3UnwrapTraits::ForwardType,</a>
<a name="ln2032">               typename Bound4UnwrapTraits::ForwardType,</a>
<a name="ln2033">               typename Bound5UnwrapTraits::ForwardType,</a>
<a name="ln2034">               typename Bound6UnwrapTraits::ForwardType)&gt;</a>
<a name="ln2035">               ::MakeItSo(storage-&gt;runnable_, CallbackForward(x1),</a>
<a name="ln2036">                   CallbackForward(x2), CallbackForward(x3),</a>
<a name="ln2037">                   CallbackForward(x4), CallbackForward(x5),</a>
<a name="ln2038">                   CallbackForward(x6));</a>
<a name="ln2039">  }</a>
<a name="ln2040">};</a>
<a name="ln2041"> </a>
<a name="ln2042">// Arity 7 -&gt; 7.</a>
<a name="ln2043">template &lt;typename StorageType, typename R,typename X1, typename X2,</a>
<a name="ln2044">    typename X3, typename X4, typename X5, typename X6, typename X7&gt;</a>
<a name="ln2045">struct Invoker&lt;0, StorageType, R(X1, X2, X3, X4, X5, X6, X7)&gt; {</a>
<a name="ln2046">  typedef R(RunType)(BindStateBase*,</a>
<a name="ln2047">      typename CallbackParamTraits&lt;X1&gt;::ForwardType,</a>
<a name="ln2048">      typename CallbackParamTraits&lt;X2&gt;::ForwardType,</a>
<a name="ln2049">      typename CallbackParamTraits&lt;X3&gt;::ForwardType,</a>
<a name="ln2050">      typename CallbackParamTraits&lt;X4&gt;::ForwardType,</a>
<a name="ln2051">      typename CallbackParamTraits&lt;X5&gt;::ForwardType,</a>
<a name="ln2052">      typename CallbackParamTraits&lt;X6&gt;::ForwardType,</a>
<a name="ln2053">      typename CallbackParamTraits&lt;X7&gt;::ForwardType);</a>
<a name="ln2054"> </a>
<a name="ln2055">  typedef R(UnboundRunType)(X1, X2, X3, X4, X5, X6, X7);</a>
<a name="ln2056"> </a>
<a name="ln2057">  static R Run(BindStateBase* base,</a>
<a name="ln2058">      typename CallbackParamTraits&lt;X1&gt;::ForwardType x1,</a>
<a name="ln2059">      typename CallbackParamTraits&lt;X2&gt;::ForwardType x2,</a>
<a name="ln2060">      typename CallbackParamTraits&lt;X3&gt;::ForwardType x3,</a>
<a name="ln2061">      typename CallbackParamTraits&lt;X4&gt;::ForwardType x4,</a>
<a name="ln2062">      typename CallbackParamTraits&lt;X5&gt;::ForwardType x5,</a>
<a name="ln2063">      typename CallbackParamTraits&lt;X6&gt;::ForwardType x6,</a>
<a name="ln2064">      typename CallbackParamTraits&lt;X7&gt;::ForwardType x7) {</a>
<a name="ln2065">    StorageType* storage = static_cast&lt;StorageType*&gt;(base);</a>
<a name="ln2066"> </a>
<a name="ln2067">    // Local references to make debugger stepping easier. If in a debugger,</a>
<a name="ln2068">    // you really want to warp ahead and step through the</a>
<a name="ln2069">    // InvokeHelper&lt;&gt;::MakeItSo() call below.</a>
<a name="ln2070"> </a>
<a name="ln2071">    return InvokeHelper&lt;StorageType::IsWeakCall::value, R,</a>
<a name="ln2072">           typename StorageType::RunnableType,</a>
<a name="ln2073">           void(typename CallbackParamTraits&lt;X1&gt;::ForwardType x1,</a>
<a name="ln2074">               typename CallbackParamTraits&lt;X2&gt;::ForwardType x2,</a>
<a name="ln2075">               typename CallbackParamTraits&lt;X3&gt;::ForwardType x3,</a>
<a name="ln2076">               typename CallbackParamTraits&lt;X4&gt;::ForwardType x4,</a>
<a name="ln2077">               typename CallbackParamTraits&lt;X5&gt;::ForwardType x5,</a>
<a name="ln2078">               typename CallbackParamTraits&lt;X6&gt;::ForwardType x6,</a>
<a name="ln2079">               typename CallbackParamTraits&lt;X7&gt;::ForwardType x7)&gt;</a>
<a name="ln2080">               ::MakeItSo(storage-&gt;runnable_, CallbackForward(x1),</a>
<a name="ln2081">                   CallbackForward(x2), CallbackForward(x3),</a>
<a name="ln2082">                   CallbackForward(x4), CallbackForward(x5),</a>
<a name="ln2083">                   CallbackForward(x6), CallbackForward(x7));</a>
<a name="ln2084">  }</a>
<a name="ln2085">};</a>
<a name="ln2086"> </a>
<a name="ln2087">// Arity 7 -&gt; 6.</a>
<a name="ln2088">template &lt;typename StorageType, typename R,typename X1, typename X2,</a>
<a name="ln2089">    typename X3, typename X4, typename X5, typename X6, typename X7&gt;</a>
<a name="ln2090">struct Invoker&lt;1, StorageType, R(X1, X2, X3, X4, X5, X6, X7)&gt; {</a>
<a name="ln2091">  typedef R(RunType)(BindStateBase*,</a>
<a name="ln2092">      typename CallbackParamTraits&lt;X2&gt;::ForwardType,</a>
<a name="ln2093">      typename CallbackParamTraits&lt;X3&gt;::ForwardType,</a>
<a name="ln2094">      typename CallbackParamTraits&lt;X4&gt;::ForwardType,</a>
<a name="ln2095">      typename CallbackParamTraits&lt;X5&gt;::ForwardType,</a>
<a name="ln2096">      typename CallbackParamTraits&lt;X6&gt;::ForwardType,</a>
<a name="ln2097">      typename CallbackParamTraits&lt;X7&gt;::ForwardType);</a>
<a name="ln2098"> </a>
<a name="ln2099">  typedef R(UnboundRunType)(X2, X3, X4, X5, X6, X7);</a>
<a name="ln2100"> </a>
<a name="ln2101">  static R Run(BindStateBase* base,</a>
<a name="ln2102">      typename CallbackParamTraits&lt;X2&gt;::ForwardType x2,</a>
<a name="ln2103">      typename CallbackParamTraits&lt;X3&gt;::ForwardType x3,</a>
<a name="ln2104">      typename CallbackParamTraits&lt;X4&gt;::ForwardType x4,</a>
<a name="ln2105">      typename CallbackParamTraits&lt;X5&gt;::ForwardType x5,</a>
<a name="ln2106">      typename CallbackParamTraits&lt;X6&gt;::ForwardType x6,</a>
<a name="ln2107">      typename CallbackParamTraits&lt;X7&gt;::ForwardType x7) {</a>
<a name="ln2108">    StorageType* storage = static_cast&lt;StorageType*&gt;(base);</a>
<a name="ln2109"> </a>
<a name="ln2110">    // Local references to make debugger stepping easier. If in a debugger,</a>
<a name="ln2111">    // you really want to warp ahead and step through the</a>
<a name="ln2112">    // InvokeHelper&lt;&gt;::MakeItSo() call below.</a>
<a name="ln2113">    typedef typename StorageType::Bound1UnwrapTraits Bound1UnwrapTraits;</a>
<a name="ln2114"> </a>
<a name="ln2115">    typename Bound1UnwrapTraits::ForwardType x1 =</a>
<a name="ln2116">        Bound1UnwrapTraits::Unwrap(storage-&gt;p1_);</a>
<a name="ln2117">    return InvokeHelper&lt;StorageType::IsWeakCall::value, R,</a>
<a name="ln2118">           typename StorageType::RunnableType,</a>
<a name="ln2119">           void(typename Bound1UnwrapTraits::ForwardType,</a>
<a name="ln2120">               typename CallbackParamTraits&lt;X2&gt;::ForwardType x2,</a>
<a name="ln2121">               typename CallbackParamTraits&lt;X3&gt;::ForwardType x3,</a>
<a name="ln2122">               typename CallbackParamTraits&lt;X4&gt;::ForwardType x4,</a>
<a name="ln2123">               typename CallbackParamTraits&lt;X5&gt;::ForwardType x5,</a>
<a name="ln2124">               typename CallbackParamTraits&lt;X6&gt;::ForwardType x6,</a>
<a name="ln2125">               typename CallbackParamTraits&lt;X7&gt;::ForwardType x7)&gt;</a>
<a name="ln2126">               ::MakeItSo(storage-&gt;runnable_, CallbackForward(x1),</a>
<a name="ln2127">                   CallbackForward(x2), CallbackForward(x3),</a>
<a name="ln2128">                   CallbackForward(x4), CallbackForward(x5),</a>
<a name="ln2129">                   CallbackForward(x6), CallbackForward(x7));</a>
<a name="ln2130">  }</a>
<a name="ln2131">};</a>
<a name="ln2132"> </a>
<a name="ln2133">// Arity 7 -&gt; 5.</a>
<a name="ln2134">template &lt;typename StorageType, typename R,typename X1, typename X2,</a>
<a name="ln2135">    typename X3, typename X4, typename X5, typename X6, typename X7&gt;</a>
<a name="ln2136">struct Invoker&lt;2, StorageType, R(X1, X2, X3, X4, X5, X6, X7)&gt; {</a>
<a name="ln2137">  typedef R(RunType)(BindStateBase*,</a>
<a name="ln2138">      typename CallbackParamTraits&lt;X3&gt;::ForwardType,</a>
<a name="ln2139">      typename CallbackParamTraits&lt;X4&gt;::ForwardType,</a>
<a name="ln2140">      typename CallbackParamTraits&lt;X5&gt;::ForwardType,</a>
<a name="ln2141">      typename CallbackParamTraits&lt;X6&gt;::ForwardType,</a>
<a name="ln2142">      typename CallbackParamTraits&lt;X7&gt;::ForwardType);</a>
<a name="ln2143"> </a>
<a name="ln2144">  typedef R(UnboundRunType)(X3, X4, X5, X6, X7);</a>
<a name="ln2145"> </a>
<a name="ln2146">  static R Run(BindStateBase* base,</a>
<a name="ln2147">      typename CallbackParamTraits&lt;X3&gt;::ForwardType x3,</a>
<a name="ln2148">      typename CallbackParamTraits&lt;X4&gt;::ForwardType x4,</a>
<a name="ln2149">      typename CallbackParamTraits&lt;X5&gt;::ForwardType x5,</a>
<a name="ln2150">      typename CallbackParamTraits&lt;X6&gt;::ForwardType x6,</a>
<a name="ln2151">      typename CallbackParamTraits&lt;X7&gt;::ForwardType x7) {</a>
<a name="ln2152">    StorageType* storage = static_cast&lt;StorageType*&gt;(base);</a>
<a name="ln2153"> </a>
<a name="ln2154">    // Local references to make debugger stepping easier. If in a debugger,</a>
<a name="ln2155">    // you really want to warp ahead and step through the</a>
<a name="ln2156">    // InvokeHelper&lt;&gt;::MakeItSo() call below.</a>
<a name="ln2157">    typedef typename StorageType::Bound1UnwrapTraits Bound1UnwrapTraits;</a>
<a name="ln2158">    typedef typename StorageType::Bound2UnwrapTraits Bound2UnwrapTraits;</a>
<a name="ln2159"> </a>
<a name="ln2160">    typename Bound1UnwrapTraits::ForwardType x1 =</a>
<a name="ln2161">        Bound1UnwrapTraits::Unwrap(storage-&gt;p1_);</a>
<a name="ln2162">    typename Bound2UnwrapTraits::ForwardType x2 =</a>
<a name="ln2163">        Bound2UnwrapTraits::Unwrap(storage-&gt;p2_);</a>
<a name="ln2164">    return InvokeHelper&lt;StorageType::IsWeakCall::value, R,</a>
<a name="ln2165">           typename StorageType::RunnableType,</a>
<a name="ln2166">           void(typename Bound1UnwrapTraits::ForwardType,</a>
<a name="ln2167">               typename Bound2UnwrapTraits::ForwardType,</a>
<a name="ln2168">               typename CallbackParamTraits&lt;X3&gt;::ForwardType x3,</a>
<a name="ln2169">               typename CallbackParamTraits&lt;X4&gt;::ForwardType x4,</a>
<a name="ln2170">               typename CallbackParamTraits&lt;X5&gt;::ForwardType x5,</a>
<a name="ln2171">               typename CallbackParamTraits&lt;X6&gt;::ForwardType x6,</a>
<a name="ln2172">               typename CallbackParamTraits&lt;X7&gt;::ForwardType x7)&gt;</a>
<a name="ln2173">               ::MakeItSo(storage-&gt;runnable_, CallbackForward(x1),</a>
<a name="ln2174">                   CallbackForward(x2), CallbackForward(x3),</a>
<a name="ln2175">                   CallbackForward(x4), CallbackForward(x5),</a>
<a name="ln2176">                   CallbackForward(x6), CallbackForward(x7));</a>
<a name="ln2177">  }</a>
<a name="ln2178">};</a>
<a name="ln2179"> </a>
<a name="ln2180">// Arity 7 -&gt; 4.</a>
<a name="ln2181">template &lt;typename StorageType, typename R,typename X1, typename X2,</a>
<a name="ln2182">    typename X3, typename X4, typename X5, typename X6, typename X7&gt;</a>
<a name="ln2183">struct Invoker&lt;3, StorageType, R(X1, X2, X3, X4, X5, X6, X7)&gt; {</a>
<a name="ln2184">  typedef R(RunType)(BindStateBase*,</a>
<a name="ln2185">      typename CallbackParamTraits&lt;X4&gt;::ForwardType,</a>
<a name="ln2186">      typename CallbackParamTraits&lt;X5&gt;::ForwardType,</a>
<a name="ln2187">      typename CallbackParamTraits&lt;X6&gt;::ForwardType,</a>
<a name="ln2188">      typename CallbackParamTraits&lt;X7&gt;::ForwardType);</a>
<a name="ln2189"> </a>
<a name="ln2190">  typedef R(UnboundRunType)(X4, X5, X6, X7);</a>
<a name="ln2191"> </a>
<a name="ln2192">  static R Run(BindStateBase* base,</a>
<a name="ln2193">      typename CallbackParamTraits&lt;X4&gt;::ForwardType x4,</a>
<a name="ln2194">      typename CallbackParamTraits&lt;X5&gt;::ForwardType x5,</a>
<a name="ln2195">      typename CallbackParamTraits&lt;X6&gt;::ForwardType x6,</a>
<a name="ln2196">      typename CallbackParamTraits&lt;X7&gt;::ForwardType x7) {</a>
<a name="ln2197">    StorageType* storage = static_cast&lt;StorageType*&gt;(base);</a>
<a name="ln2198"> </a>
<a name="ln2199">    // Local references to make debugger stepping easier. If in a debugger,</a>
<a name="ln2200">    // you really want to warp ahead and step through the</a>
<a name="ln2201">    // InvokeHelper&lt;&gt;::MakeItSo() call below.</a>
<a name="ln2202">    typedef typename StorageType::Bound1UnwrapTraits Bound1UnwrapTraits;</a>
<a name="ln2203">    typedef typename StorageType::Bound2UnwrapTraits Bound2UnwrapTraits;</a>
<a name="ln2204">    typedef typename StorageType::Bound3UnwrapTraits Bound3UnwrapTraits;</a>
<a name="ln2205"> </a>
<a name="ln2206">    typename Bound1UnwrapTraits::ForwardType x1 =</a>
<a name="ln2207">        Bound1UnwrapTraits::Unwrap(storage-&gt;p1_);</a>
<a name="ln2208">    typename Bound2UnwrapTraits::ForwardType x2 =</a>
<a name="ln2209">        Bound2UnwrapTraits::Unwrap(storage-&gt;p2_);</a>
<a name="ln2210">    typename Bound3UnwrapTraits::ForwardType x3 =</a>
<a name="ln2211">        Bound3UnwrapTraits::Unwrap(storage-&gt;p3_);</a>
<a name="ln2212">    return InvokeHelper&lt;StorageType::IsWeakCall::value, R,</a>
<a name="ln2213">           typename StorageType::RunnableType,</a>
<a name="ln2214">           void(typename Bound1UnwrapTraits::ForwardType,</a>
<a name="ln2215">               typename Bound2UnwrapTraits::ForwardType,</a>
<a name="ln2216">               typename Bound3UnwrapTraits::ForwardType,</a>
<a name="ln2217">               typename CallbackParamTraits&lt;X4&gt;::ForwardType x4,</a>
<a name="ln2218">               typename CallbackParamTraits&lt;X5&gt;::ForwardType x5,</a>
<a name="ln2219">               typename CallbackParamTraits&lt;X6&gt;::ForwardType x6,</a>
<a name="ln2220">               typename CallbackParamTraits&lt;X7&gt;::ForwardType x7)&gt;</a>
<a name="ln2221">               ::MakeItSo(storage-&gt;runnable_, CallbackForward(x1),</a>
<a name="ln2222">                   CallbackForward(x2), CallbackForward(x3),</a>
<a name="ln2223">                   CallbackForward(x4), CallbackForward(x5),</a>
<a name="ln2224">                   CallbackForward(x6), CallbackForward(x7));</a>
<a name="ln2225">  }</a>
<a name="ln2226">};</a>
<a name="ln2227"> </a>
<a name="ln2228">// Arity 7 -&gt; 3.</a>
<a name="ln2229">template &lt;typename StorageType, typename R,typename X1, typename X2,</a>
<a name="ln2230">    typename X3, typename X4, typename X5, typename X6, typename X7&gt;</a>
<a name="ln2231">struct Invoker&lt;4, StorageType, R(X1, X2, X3, X4, X5, X6, X7)&gt; {</a>
<a name="ln2232">  typedef R(RunType)(BindStateBase*,</a>
<a name="ln2233">      typename CallbackParamTraits&lt;X5&gt;::ForwardType,</a>
<a name="ln2234">      typename CallbackParamTraits&lt;X6&gt;::ForwardType,</a>
<a name="ln2235">      typename CallbackParamTraits&lt;X7&gt;::ForwardType);</a>
<a name="ln2236"> </a>
<a name="ln2237">  typedef R(UnboundRunType)(X5, X6, X7);</a>
<a name="ln2238"> </a>
<a name="ln2239">  static R Run(BindStateBase* base,</a>
<a name="ln2240">      typename CallbackParamTraits&lt;X5&gt;::ForwardType x5,</a>
<a name="ln2241">      typename CallbackParamTraits&lt;X6&gt;::ForwardType x6,</a>
<a name="ln2242">      typename CallbackParamTraits&lt;X7&gt;::ForwardType x7) {</a>
<a name="ln2243">    StorageType* storage = static_cast&lt;StorageType*&gt;(base);</a>
<a name="ln2244"> </a>
<a name="ln2245">    // Local references to make debugger stepping easier. If in a debugger,</a>
<a name="ln2246">    // you really want to warp ahead and step through the</a>
<a name="ln2247">    // InvokeHelper&lt;&gt;::MakeItSo() call below.</a>
<a name="ln2248">    typedef typename StorageType::Bound1UnwrapTraits Bound1UnwrapTraits;</a>
<a name="ln2249">    typedef typename StorageType::Bound2UnwrapTraits Bound2UnwrapTraits;</a>
<a name="ln2250">    typedef typename StorageType::Bound3UnwrapTraits Bound3UnwrapTraits;</a>
<a name="ln2251">    typedef typename StorageType::Bound4UnwrapTraits Bound4UnwrapTraits;</a>
<a name="ln2252"> </a>
<a name="ln2253">    typename Bound1UnwrapTraits::ForwardType x1 =</a>
<a name="ln2254">        Bound1UnwrapTraits::Unwrap(storage-&gt;p1_);</a>
<a name="ln2255">    typename Bound2UnwrapTraits::ForwardType x2 =</a>
<a name="ln2256">        Bound2UnwrapTraits::Unwrap(storage-&gt;p2_);</a>
<a name="ln2257">    typename Bound3UnwrapTraits::ForwardType x3 =</a>
<a name="ln2258">        Bound3UnwrapTraits::Unwrap(storage-&gt;p3_);</a>
<a name="ln2259">    typename Bound4UnwrapTraits::ForwardType x4 =</a>
<a name="ln2260">        Bound4UnwrapTraits::Unwrap(storage-&gt;p4_);</a>
<a name="ln2261">    return InvokeHelper&lt;StorageType::IsWeakCall::value, R,</a>
<a name="ln2262">           typename StorageType::RunnableType,</a>
<a name="ln2263">           void(typename Bound1UnwrapTraits::ForwardType,</a>
<a name="ln2264">               typename Bound2UnwrapTraits::ForwardType,</a>
<a name="ln2265">               typename Bound3UnwrapTraits::ForwardType,</a>
<a name="ln2266">               typename Bound4UnwrapTraits::ForwardType,</a>
<a name="ln2267">               typename CallbackParamTraits&lt;X5&gt;::ForwardType x5,</a>
<a name="ln2268">               typename CallbackParamTraits&lt;X6&gt;::ForwardType x6,</a>
<a name="ln2269">               typename CallbackParamTraits&lt;X7&gt;::ForwardType x7)&gt;</a>
<a name="ln2270">               ::MakeItSo(storage-&gt;runnable_, CallbackForward(x1),</a>
<a name="ln2271">                   CallbackForward(x2), CallbackForward(x3),</a>
<a name="ln2272">                   CallbackForward(x4), CallbackForward(x5),</a>
<a name="ln2273">                   CallbackForward(x6), CallbackForward(x7));</a>
<a name="ln2274">  }</a>
<a name="ln2275">};</a>
<a name="ln2276"> </a>
<a name="ln2277">// Arity 7 -&gt; 2.</a>
<a name="ln2278">template &lt;typename StorageType, typename R,typename X1, typename X2,</a>
<a name="ln2279">    typename X3, typename X4, typename X5, typename X6, typename X7&gt;</a>
<a name="ln2280">struct Invoker&lt;5, StorageType, R(X1, X2, X3, X4, X5, X6, X7)&gt; {</a>
<a name="ln2281">  typedef R(RunType)(BindStateBase*,</a>
<a name="ln2282">      typename CallbackParamTraits&lt;X6&gt;::ForwardType,</a>
<a name="ln2283">      typename CallbackParamTraits&lt;X7&gt;::ForwardType);</a>
<a name="ln2284"> </a>
<a name="ln2285">  typedef R(UnboundRunType)(X6, X7);</a>
<a name="ln2286"> </a>
<a name="ln2287">  static R Run(BindStateBase* base,</a>
<a name="ln2288">      typename CallbackParamTraits&lt;X6&gt;::ForwardType x6,</a>
<a name="ln2289">      typename CallbackParamTraits&lt;X7&gt;::ForwardType x7) {</a>
<a name="ln2290">    StorageType* storage = static_cast&lt;StorageType*&gt;(base);</a>
<a name="ln2291"> </a>
<a name="ln2292">    // Local references to make debugger stepping easier. If in a debugger,</a>
<a name="ln2293">    // you really want to warp ahead and step through the</a>
<a name="ln2294">    // InvokeHelper&lt;&gt;::MakeItSo() call below.</a>
<a name="ln2295">    typedef typename StorageType::Bound1UnwrapTraits Bound1UnwrapTraits;</a>
<a name="ln2296">    typedef typename StorageType::Bound2UnwrapTraits Bound2UnwrapTraits;</a>
<a name="ln2297">    typedef typename StorageType::Bound3UnwrapTraits Bound3UnwrapTraits;</a>
<a name="ln2298">    typedef typename StorageType::Bound4UnwrapTraits Bound4UnwrapTraits;</a>
<a name="ln2299">    typedef typename StorageType::Bound5UnwrapTraits Bound5UnwrapTraits;</a>
<a name="ln2300"> </a>
<a name="ln2301">    typename Bound1UnwrapTraits::ForwardType x1 =</a>
<a name="ln2302">        Bound1UnwrapTraits::Unwrap(storage-&gt;p1_);</a>
<a name="ln2303">    typename Bound2UnwrapTraits::ForwardType x2 =</a>
<a name="ln2304">        Bound2UnwrapTraits::Unwrap(storage-&gt;p2_);</a>
<a name="ln2305">    typename Bound3UnwrapTraits::ForwardType x3 =</a>
<a name="ln2306">        Bound3UnwrapTraits::Unwrap(storage-&gt;p3_);</a>
<a name="ln2307">    typename Bound4UnwrapTraits::ForwardType x4 =</a>
<a name="ln2308">        Bound4UnwrapTraits::Unwrap(storage-&gt;p4_);</a>
<a name="ln2309">    typename Bound5UnwrapTraits::ForwardType x5 =</a>
<a name="ln2310">        Bound5UnwrapTraits::Unwrap(storage-&gt;p5_);</a>
<a name="ln2311">    return InvokeHelper&lt;StorageType::IsWeakCall::value, R,</a>
<a name="ln2312">           typename StorageType::RunnableType,</a>
<a name="ln2313">           void(typename Bound1UnwrapTraits::ForwardType,</a>
<a name="ln2314">               typename Bound2UnwrapTraits::ForwardType,</a>
<a name="ln2315">               typename Bound3UnwrapTraits::ForwardType,</a>
<a name="ln2316">               typename Bound4UnwrapTraits::ForwardType,</a>
<a name="ln2317">               typename Bound5UnwrapTraits::ForwardType,</a>
<a name="ln2318">               typename CallbackParamTraits&lt;X6&gt;::ForwardType x6,</a>
<a name="ln2319">               typename CallbackParamTraits&lt;X7&gt;::ForwardType x7)&gt;</a>
<a name="ln2320">               ::MakeItSo(storage-&gt;runnable_, CallbackForward(x1),</a>
<a name="ln2321">                   CallbackForward(x2), CallbackForward(x3),</a>
<a name="ln2322">                   CallbackForward(x4), CallbackForward(x5),</a>
<a name="ln2323">                   CallbackForward(x6), CallbackForward(x7));</a>
<a name="ln2324">  }</a>
<a name="ln2325">};</a>
<a name="ln2326"> </a>
<a name="ln2327">// Arity 7 -&gt; 1.</a>
<a name="ln2328">template &lt;typename StorageType, typename R,typename X1, typename X2,</a>
<a name="ln2329">    typename X3, typename X4, typename X5, typename X6, typename X7&gt;</a>
<a name="ln2330">struct Invoker&lt;6, StorageType, R(X1, X2, X3, X4, X5, X6, X7)&gt; {</a>
<a name="ln2331">  typedef R(RunType)(BindStateBase*,</a>
<a name="ln2332">      typename CallbackParamTraits&lt;X7&gt;::ForwardType);</a>
<a name="ln2333"> </a>
<a name="ln2334">  typedef R(UnboundRunType)(X7);</a>
<a name="ln2335"> </a>
<a name="ln2336">  static R Run(BindStateBase* base,</a>
<a name="ln2337">      typename CallbackParamTraits&lt;X7&gt;::ForwardType x7) {</a>
<a name="ln2338">    StorageType* storage = static_cast&lt;StorageType*&gt;(base);</a>
<a name="ln2339"> </a>
<a name="ln2340">    // Local references to make debugger stepping easier. If in a debugger,</a>
<a name="ln2341">    // you really want to warp ahead and step through the</a>
<a name="ln2342">    // InvokeHelper&lt;&gt;::MakeItSo() call below.</a>
<a name="ln2343">    typedef typename StorageType::Bound1UnwrapTraits Bound1UnwrapTraits;</a>
<a name="ln2344">    typedef typename StorageType::Bound2UnwrapTraits Bound2UnwrapTraits;</a>
<a name="ln2345">    typedef typename StorageType::Bound3UnwrapTraits Bound3UnwrapTraits;</a>
<a name="ln2346">    typedef typename StorageType::Bound4UnwrapTraits Bound4UnwrapTraits;</a>
<a name="ln2347">    typedef typename StorageType::Bound5UnwrapTraits Bound5UnwrapTraits;</a>
<a name="ln2348">    typedef typename StorageType::Bound6UnwrapTraits Bound6UnwrapTraits;</a>
<a name="ln2349"> </a>
<a name="ln2350">    typename Bound1UnwrapTraits::ForwardType x1 =</a>
<a name="ln2351">        Bound1UnwrapTraits::Unwrap(storage-&gt;p1_);</a>
<a name="ln2352">    typename Bound2UnwrapTraits::ForwardType x2 =</a>
<a name="ln2353">        Bound2UnwrapTraits::Unwrap(storage-&gt;p2_);</a>
<a name="ln2354">    typename Bound3UnwrapTraits::ForwardType x3 =</a>
<a name="ln2355">        Bound3UnwrapTraits::Unwrap(storage-&gt;p3_);</a>
<a name="ln2356">    typename Bound4UnwrapTraits::ForwardType x4 =</a>
<a name="ln2357">        Bound4UnwrapTraits::Unwrap(storage-&gt;p4_);</a>
<a name="ln2358">    typename Bound5UnwrapTraits::ForwardType x5 =</a>
<a name="ln2359">        Bound5UnwrapTraits::Unwrap(storage-&gt;p5_);</a>
<a name="ln2360">    typename Bound6UnwrapTraits::ForwardType x6 =</a>
<a name="ln2361">        Bound6UnwrapTraits::Unwrap(storage-&gt;p6_);</a>
<a name="ln2362">    return InvokeHelper&lt;StorageType::IsWeakCall::value, R,</a>
<a name="ln2363">           typename StorageType::RunnableType,</a>
<a name="ln2364">           void(typename Bound1UnwrapTraits::ForwardType,</a>
<a name="ln2365">               typename Bound2UnwrapTraits::ForwardType,</a>
<a name="ln2366">               typename Bound3UnwrapTraits::ForwardType,</a>
<a name="ln2367">               typename Bound4UnwrapTraits::ForwardType,</a>
<a name="ln2368">               typename Bound5UnwrapTraits::ForwardType,</a>
<a name="ln2369">               typename Bound6UnwrapTraits::ForwardType,</a>
<a name="ln2370">               typename CallbackParamTraits&lt;X7&gt;::ForwardType x7)&gt;</a>
<a name="ln2371">               ::MakeItSo(storage-&gt;runnable_, CallbackForward(x1),</a>
<a name="ln2372">                   CallbackForward(x2), CallbackForward(x3),</a>
<a name="ln2373">                   CallbackForward(x4), CallbackForward(x5),</a>
<a name="ln2374">                   CallbackForward(x6), CallbackForward(x7));</a>
<a name="ln2375">  }</a>
<a name="ln2376">};</a>
<a name="ln2377"> </a>
<a name="ln2378">// Arity 7 -&gt; 0.</a>
<a name="ln2379">template &lt;typename StorageType, typename R,typename X1, typename X2,</a>
<a name="ln2380">    typename X3, typename X4, typename X5, typename X6, typename X7&gt;</a>
<a name="ln2381">struct Invoker&lt;7, StorageType, R(X1, X2, X3, X4, X5, X6, X7)&gt; {</a>
<a name="ln2382">  typedef R(RunType)(BindStateBase*);</a>
<a name="ln2383"> </a>
<a name="ln2384">  typedef R(UnboundRunType)();</a>
<a name="ln2385"> </a>
<a name="ln2386">  static R Run(BindStateBase* base) {</a>
<a name="ln2387">    StorageType* storage = static_cast&lt;StorageType*&gt;(base);</a>
<a name="ln2388"> </a>
<a name="ln2389">    // Local references to make debugger stepping easier. If in a debugger,</a>
<a name="ln2390">    // you really want to warp ahead and step through the</a>
<a name="ln2391">    // InvokeHelper&lt;&gt;::MakeItSo() call below.</a>
<a name="ln2392">    typedef typename StorageType::Bound1UnwrapTraits Bound1UnwrapTraits;</a>
<a name="ln2393">    typedef typename StorageType::Bound2UnwrapTraits Bound2UnwrapTraits;</a>
<a name="ln2394">    typedef typename StorageType::Bound3UnwrapTraits Bound3UnwrapTraits;</a>
<a name="ln2395">    typedef typename StorageType::Bound4UnwrapTraits Bound4UnwrapTraits;</a>
<a name="ln2396">    typedef typename StorageType::Bound5UnwrapTraits Bound5UnwrapTraits;</a>
<a name="ln2397">    typedef typename StorageType::Bound6UnwrapTraits Bound6UnwrapTraits;</a>
<a name="ln2398">    typedef typename StorageType::Bound7UnwrapTraits Bound7UnwrapTraits;</a>
<a name="ln2399"> </a>
<a name="ln2400">    typename Bound1UnwrapTraits::ForwardType x1 =</a>
<a name="ln2401">        Bound1UnwrapTraits::Unwrap(storage-&gt;p1_);</a>
<a name="ln2402">    typename Bound2UnwrapTraits::ForwardType x2 =</a>
<a name="ln2403">        Bound2UnwrapTraits::Unwrap(storage-&gt;p2_);</a>
<a name="ln2404">    typename Bound3UnwrapTraits::ForwardType x3 =</a>
<a name="ln2405">        Bound3UnwrapTraits::Unwrap(storage-&gt;p3_);</a>
<a name="ln2406">    typename Bound4UnwrapTraits::ForwardType x4 =</a>
<a name="ln2407">        Bound4UnwrapTraits::Unwrap(storage-&gt;p4_);</a>
<a name="ln2408">    typename Bound5UnwrapTraits::ForwardType x5 =</a>
<a name="ln2409">        Bound5UnwrapTraits::Unwrap(storage-&gt;p5_);</a>
<a name="ln2410">    typename Bound6UnwrapTraits::ForwardType x6 =</a>
<a name="ln2411">        Bound6UnwrapTraits::Unwrap(storage-&gt;p6_);</a>
<a name="ln2412">    typename Bound7UnwrapTraits::ForwardType x7 =</a>
<a name="ln2413">        Bound7UnwrapTraits::Unwrap(storage-&gt;p7_);</a>
<a name="ln2414">    return InvokeHelper&lt;StorageType::IsWeakCall::value, R,</a>
<a name="ln2415">           typename StorageType::RunnableType,</a>
<a name="ln2416">           void(typename Bound1UnwrapTraits::ForwardType,</a>
<a name="ln2417">               typename Bound2UnwrapTraits::ForwardType,</a>
<a name="ln2418">               typename Bound3UnwrapTraits::ForwardType,</a>
<a name="ln2419">               typename Bound4UnwrapTraits::ForwardType,</a>
<a name="ln2420">               typename Bound5UnwrapTraits::ForwardType,</a>
<a name="ln2421">               typename Bound6UnwrapTraits::ForwardType,</a>
<a name="ln2422">               typename Bound7UnwrapTraits::ForwardType)&gt;</a>
<a name="ln2423">               ::MakeItSo(storage-&gt;runnable_, CallbackForward(x1),</a>
<a name="ln2424">                   CallbackForward(x2), CallbackForward(x3),</a>
<a name="ln2425">                   CallbackForward(x4), CallbackForward(x5),</a>
<a name="ln2426">                   CallbackForward(x6), CallbackForward(x7));</a>
<a name="ln2427">  }</a>
<a name="ln2428">};</a>
<a name="ln2429"> </a>
<a name="ln2430"> </a>
<a name="ln2431">// BindState&lt;&gt;</a>
<a name="ln2432">//</a>
<a name="ln2433">// This stores all the state passed into Bind() and is also where most</a>
<a name="ln2434">// of the template resolution magic occurs.</a>
<a name="ln2435">//</a>
<a name="ln2436">// Runnable is the functor we are binding arguments to.</a>
<a name="ln2437">// RunType is type of the Run() function that the Invoker&lt;&gt; should use.</a>
<a name="ln2438">// Normally, this is the same as the RunType of the Runnable, but it can</a>
<a name="ln2439">// be different if an adapter like IgnoreResult() has been used.</a>
<a name="ln2440">//</a>
<a name="ln2441">// BoundArgsType contains the storage type for all the bound arguments by</a>
<a name="ln2442">// (ab)using a function type.</a>
<a name="ln2443">template &lt;typename Runnable, typename RunType, typename BoundArgsType&gt;</a>
<a name="ln2444">struct BindState;</a>
<a name="ln2445"> </a>
<a name="ln2446">template &lt;typename Runnable, typename RunType&gt;</a>
<a name="ln2447">struct BindState&lt;Runnable, RunType, void()&gt; : public BindStateBase {</a>
<a name="ln2448">  typedef Runnable RunnableType;</a>
<a name="ln2449"> </a>
<a name="ln2450">  typedef base::false_type IsWeakCall;</a>
<a name="ln2451"> </a>
<a name="ln2452">  typedef Invoker&lt;0, BindState, RunType&gt; InvokerType;</a>
<a name="ln2453">  typedef typename InvokerType::UnboundRunType UnboundRunType;</a>
<a name="ln2454">  explicit BindState(Runnable runnable) : runnable_(std::move(runnable)) {}</a>
<a name="ln2455"> </a>
<a name="ln2456">  virtual ~BindState() {  }</a>
<a name="ln2457"> </a>
<a name="ln2458">  RunnableType runnable_;</a>
<a name="ln2459">};</a>
<a name="ln2460"> </a>
<a name="ln2461">template &lt;typename Runnable, typename RunType, typename P1&gt;</a>
<a name="ln2462">struct BindState&lt;Runnable, RunType, void(P1)&gt; : public BindStateBase {</a>
<a name="ln2463">  typedef Runnable RunnableType;</a>
<a name="ln2464"> </a>
<a name="ln2465">  typedef base::false_type IsWeakCall;</a>
<a name="ln2466"> </a>
<a name="ln2467">  typedef Invoker&lt;1, BindState, RunType&gt; InvokerType;</a>
<a name="ln2468">  typedef typename InvokerType::UnboundRunType UnboundRunType;</a>
<a name="ln2469"> </a>
<a name="ln2470">  // Convenience typedefs for bound argument types.</a>
<a name="ln2471">  typedef UnwrapTraits&lt;P1&gt; Bound1UnwrapTraits;</a>
<a name="ln2472"> </a>
<a name="ln2473">  BindState(Runnable runnable, P1 p1)</a>
<a name="ln2474">      : runnable_(std::move(runnable)), p1_(std::move(p1)) {</a>
<a name="ln2475">    MaybeRefcount&lt;HasIsMethodTag&lt;Runnable&gt;::value, P1&gt;::AddRef(p1_);</a>
<a name="ln2476">  }</a>
<a name="ln2477"> </a>
<a name="ln2478">  virtual ~BindState() {    MaybeRefcount&lt;HasIsMethodTag&lt;Runnable&gt;::value,</a>
<a name="ln2479">      P1&gt;::Release(p1_);  }</a>
<a name="ln2480"> </a>
<a name="ln2481">  RunnableType runnable_;</a>
<a name="ln2482">  P1 p1_;</a>
<a name="ln2483">};</a>
<a name="ln2484"> </a>
<a name="ln2485">template &lt;typename Runnable, typename RunType, typename P1, typename P2&gt;</a>
<a name="ln2486">struct BindState&lt;Runnable, RunType, void(P1, P2)&gt; : public BindStateBase {</a>
<a name="ln2487">  typedef Runnable RunnableType;</a>
<a name="ln2488"> </a>
<a name="ln2489">  typedef base::false_type IsWeakCall;</a>
<a name="ln2490"> </a>
<a name="ln2491">  typedef Invoker&lt;2, BindState, RunType&gt; InvokerType;</a>
<a name="ln2492">  typedef typename InvokerType::UnboundRunType UnboundRunType;</a>
<a name="ln2493"> </a>
<a name="ln2494">  // Convenience typedefs for bound argument types.</a>
<a name="ln2495">  typedef UnwrapTraits&lt;P1&gt; Bound1UnwrapTraits;</a>
<a name="ln2496">  typedef UnwrapTraits&lt;P2&gt; Bound2UnwrapTraits;</a>
<a name="ln2497"> </a>
<a name="ln2498">  BindState(Runnable runnable, P1 p1, P2 p2)</a>
<a name="ln2499">      : runnable_(std::move(runnable)), p1_(std::move(p1)), p2_(std::move(p2)) {</a>
<a name="ln2500">    MaybeRefcount&lt;HasIsMethodTag&lt;Runnable&gt;::value, P1&gt;::AddRef(p1_);</a>
<a name="ln2501">  }</a>
<a name="ln2502"> </a>
<a name="ln2503">  virtual ~BindState() {    MaybeRefcount&lt;HasIsMethodTag&lt;Runnable&gt;::value,</a>
<a name="ln2504">      P1&gt;::Release(p1_);  }</a>
<a name="ln2505"> </a>
<a name="ln2506">  RunnableType runnable_;</a>
<a name="ln2507">  P1 p1_;</a>
<a name="ln2508">  P2 p2_;</a>
<a name="ln2509">};</a>
<a name="ln2510"> </a>
<a name="ln2511">template &lt;typename Runnable, typename RunType, typename P1, typename P2,</a>
<a name="ln2512">    typename P3&gt;</a>
<a name="ln2513">struct BindState&lt;Runnable, RunType, void(P1, P2, P3)&gt; : public BindStateBase {</a>
<a name="ln2514">  typedef Runnable RunnableType;</a>
<a name="ln2515"> </a>
<a name="ln2516">  typedef base::false_type IsWeakCall;</a>
<a name="ln2517"> </a>
<a name="ln2518">  typedef Invoker&lt;3, BindState, RunType&gt; InvokerType;</a>
<a name="ln2519">  typedef typename InvokerType::UnboundRunType UnboundRunType;</a>
<a name="ln2520"> </a>
<a name="ln2521">  // Convenience typedefs for bound argument types.</a>
<a name="ln2522">  typedef UnwrapTraits&lt;P1&gt; Bound1UnwrapTraits;</a>
<a name="ln2523">  typedef UnwrapTraits&lt;P2&gt; Bound2UnwrapTraits;</a>
<a name="ln2524">  typedef UnwrapTraits&lt;P3&gt; Bound3UnwrapTraits;</a>
<a name="ln2525"> </a>
<a name="ln2526">  BindState(Runnable runnable, P1 p1, P2 p2, P3 p3)</a>
<a name="ln2527">      : runnable_(std::move(runnable)),</a>
<a name="ln2528">        p1_(std::move(p1)),</a>
<a name="ln2529">        p2_(std::move(p2)),</a>
<a name="ln2530">        p3_(std::move(p3)) {</a>
<a name="ln2531">    MaybeRefcount&lt;HasIsMethodTag&lt;Runnable&gt;::value, P1&gt;::AddRef(p1_);</a>
<a name="ln2532">  }</a>
<a name="ln2533"> </a>
<a name="ln2534">  virtual ~BindState() {    MaybeRefcount&lt;HasIsMethodTag&lt;Runnable&gt;::value,</a>
<a name="ln2535">      P1&gt;::Release(p1_);  }</a>
<a name="ln2536"> </a>
<a name="ln2537">  RunnableType runnable_;</a>
<a name="ln2538">  P1 p1_;</a>
<a name="ln2539">  P2 p2_;</a>
<a name="ln2540">  P3 p3_;</a>
<a name="ln2541">};</a>
<a name="ln2542"> </a>
<a name="ln2543">template &lt;typename Runnable, typename RunType, typename P1, typename P2,</a>
<a name="ln2544">    typename P3, typename P4&gt;</a>
<a name="ln2545">struct BindState&lt;Runnable, RunType, void(P1, P2, P3,</a>
<a name="ln2546">    P4)&gt; : public BindStateBase {</a>
<a name="ln2547">  typedef Runnable RunnableType;</a>
<a name="ln2548"> </a>
<a name="ln2549">  typedef base::false_type IsWeakCall;</a>
<a name="ln2550"> </a>
<a name="ln2551">  typedef Invoker&lt;4, BindState, RunType&gt; InvokerType;</a>
<a name="ln2552">  typedef typename InvokerType::UnboundRunType UnboundRunType;</a>
<a name="ln2553"> </a>
<a name="ln2554">  // Convenience typedefs for bound argument types.</a>
<a name="ln2555">  typedef UnwrapTraits&lt;P1&gt; Bound1UnwrapTraits;</a>
<a name="ln2556">  typedef UnwrapTraits&lt;P2&gt; Bound2UnwrapTraits;</a>
<a name="ln2557">  typedef UnwrapTraits&lt;P3&gt; Bound3UnwrapTraits;</a>
<a name="ln2558">  typedef UnwrapTraits&lt;P4&gt; Bound4UnwrapTraits;</a>
<a name="ln2559"> </a>
<a name="ln2560">  BindState(Runnable runnable, P1 p1, P2 p2, const P3&amp; p3, P4 p4)</a>
<a name="ln2561">      : runnable_(std::move(runnable)),</a>
<a name="ln2562">        p1_(std::move(p1)),</a>
<a name="ln2563">        p2_(std::move(p2)),</a>
<a name="ln2564">        p3_(p3),</a>
<a name="ln2565">        p4_(std::move(p4)) {</a>
<a name="ln2566">    MaybeRefcount&lt;HasIsMethodTag&lt;Runnable&gt;::value, P1&gt;::AddRef(p1_);</a>
<a name="ln2567">  }</a>
<a name="ln2568"> </a>
<a name="ln2569">  virtual ~BindState() {    MaybeRefcount&lt;HasIsMethodTag&lt;Runnable&gt;::value,</a>
<a name="ln2570">      P1&gt;::Release(p1_);  }</a>
<a name="ln2571"> </a>
<a name="ln2572">  RunnableType runnable_;</a>
<a name="ln2573">  P1 p1_;</a>
<a name="ln2574">  P2 p2_;</a>
<a name="ln2575">  P3 p3_;</a>
<a name="ln2576">  P4 p4_;</a>
<a name="ln2577">};</a>
<a name="ln2578"> </a>
<a name="ln2579">template &lt;typename Runnable, typename RunType, typename P1, typename P2,</a>
<a name="ln2580">    typename P3, typename P4, typename P5&gt;</a>
<a name="ln2581">struct BindState&lt;Runnable, RunType, void(P1, P2, P3, P4,</a>
<a name="ln2582">    P5)&gt; : public BindStateBase {</a>
<a name="ln2583">  typedef Runnable RunnableType;</a>
<a name="ln2584"> </a>
<a name="ln2585">  typedef base::false_type IsWeakCall;</a>
<a name="ln2586"> </a>
<a name="ln2587">  typedef Invoker&lt;5, BindState, RunType&gt; InvokerType;</a>
<a name="ln2588">  typedef typename InvokerType::UnboundRunType UnboundRunType;</a>
<a name="ln2589"> </a>
<a name="ln2590">  // Convenience typedefs for bound argument types.</a>
<a name="ln2591">  typedef UnwrapTraits&lt;P1&gt; Bound1UnwrapTraits;</a>
<a name="ln2592">  typedef UnwrapTraits&lt;P2&gt; Bound2UnwrapTraits;</a>
<a name="ln2593">  typedef UnwrapTraits&lt;P3&gt; Bound3UnwrapTraits;</a>
<a name="ln2594">  typedef UnwrapTraits&lt;P4&gt; Bound4UnwrapTraits;</a>
<a name="ln2595">  typedef UnwrapTraits&lt;P5&gt; Bound5UnwrapTraits;</a>
<a name="ln2596"> </a>
<a name="ln2597">  BindState(Runnable runnable, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5)</a>
<a name="ln2598">      : runnable_(std::move(runnable)),</a>
<a name="ln2599">        p1_(std::move(p1)),</a>
<a name="ln2600">        p2_(std::move(p2)),</a>
<a name="ln2601">        p3_(std::move(p3)),</a>
<a name="ln2602">        p4_(std::move(p4)),</a>
<a name="ln2603">        p5_(std::move(p5)) {</a>
<a name="ln2604">    MaybeRefcount&lt;HasIsMethodTag&lt;Runnable&gt;::value, P1&gt;::AddRef(p1_);</a>
<a name="ln2605">  }</a>
<a name="ln2606"> </a>
<a name="ln2607">  virtual ~BindState() {    MaybeRefcount&lt;HasIsMethodTag&lt;Runnable&gt;::value,</a>
<a name="ln2608">      P1&gt;::Release(p1_);  }</a>
<a name="ln2609"> </a>
<a name="ln2610">  RunnableType runnable_;</a>
<a name="ln2611">  P1 p1_;</a>
<a name="ln2612">  P2 p2_;</a>
<a name="ln2613">  P3 p3_;</a>
<a name="ln2614">  P4 p4_;</a>
<a name="ln2615">  P5 p5_;</a>
<a name="ln2616">};</a>
<a name="ln2617"> </a>
<a name="ln2618">template &lt;typename Runnable, typename RunType, typename P1, typename P2,</a>
<a name="ln2619">    typename P3, typename P4, typename P5, typename P6&gt;</a>
<a name="ln2620">struct BindState&lt;Runnable, RunType, void(P1, P2, P3, P4, P5,</a>
<a name="ln2621">    P6)&gt; : public BindStateBase {</a>
<a name="ln2622">  typedef Runnable RunnableType;</a>
<a name="ln2623"> </a>
<a name="ln2624">  typedef base::false_type IsWeakCall;</a>
<a name="ln2625"> </a>
<a name="ln2626">  typedef Invoker&lt;6, BindState, RunType&gt; InvokerType;</a>
<a name="ln2627">  typedef typename InvokerType::UnboundRunType UnboundRunType;</a>
<a name="ln2628"> </a>
<a name="ln2629">  // Convenience typedefs for bound argument types.</a>
<a name="ln2630">  typedef UnwrapTraits&lt;P1&gt; Bound1UnwrapTraits;</a>
<a name="ln2631">  typedef UnwrapTraits&lt;P2&gt; Bound2UnwrapTraits;</a>
<a name="ln2632">  typedef UnwrapTraits&lt;P3&gt; Bound3UnwrapTraits;</a>
<a name="ln2633">  typedef UnwrapTraits&lt;P4&gt; Bound4UnwrapTraits;</a>
<a name="ln2634">  typedef UnwrapTraits&lt;P5&gt; Bound5UnwrapTraits;</a>
<a name="ln2635">  typedef UnwrapTraits&lt;P6&gt; Bound6UnwrapTraits;</a>
<a name="ln2636"> </a>
<a name="ln2637">  BindState(const Runnable&amp; runnable, const P1&amp; p1, const P2&amp; p2, const P3&amp; p3,</a>
<a name="ln2638">      const P4&amp; p4, const P5&amp; p5, const P6&amp; p6)</a>
<a name="ln2639">      : runnable_(runnable),</a>
<a name="ln2640">        p1_(p1),</a>
<a name="ln2641">        p2_(p2),</a>
<a name="ln2642">        p3_(p3),</a>
<a name="ln2643">        p4_(p4),</a>
<a name="ln2644">        p5_(p5),</a>
<a name="ln2645">        p6_(p6) {</a>
<a name="ln2646">    MaybeRefcount&lt;HasIsMethodTag&lt;Runnable&gt;::value, P1&gt;::AddRef(p1_);</a>
<a name="ln2647">  }</a>
<a name="ln2648"> </a>
<a name="ln2649">  virtual ~BindState() {    MaybeRefcount&lt;HasIsMethodTag&lt;Runnable&gt;::value,</a>
<a name="ln2650">      P1&gt;::Release(p1_);  }</a>
<a name="ln2651"> </a>
<a name="ln2652">  RunnableType runnable_;</a>
<a name="ln2653">  P1 p1_;</a>
<a name="ln2654">  P2 p2_;</a>
<a name="ln2655">  P3 p3_;</a>
<a name="ln2656">  P4 p4_;</a>
<a name="ln2657">  P5 p5_;</a>
<a name="ln2658">  P6 p6_;</a>
<a name="ln2659">};</a>
<a name="ln2660"> </a>
<a name="ln2661">template &lt;typename Runnable, typename RunType, typename P1, typename P2,</a>
<a name="ln2662">    typename P3, typename P4, typename P5, typename P6, typename P7&gt;</a>
<a name="ln2663">struct BindState&lt;Runnable, RunType, void(P1, P2, P3, P4, P5, P6,</a>
<a name="ln2664">    P7)&gt; : public BindStateBase {</a>
<a name="ln2665">  typedef Runnable RunnableType;</a>
<a name="ln2666"> </a>
<a name="ln2667">  typedef base::false_type IsWeakCall;</a>
<a name="ln2668"> </a>
<a name="ln2669">  typedef Invoker&lt;7, BindState, RunType&gt; InvokerType;</a>
<a name="ln2670">  typedef typename InvokerType::UnboundRunType UnboundRunType;</a>
<a name="ln2671"> </a>
<a name="ln2672">  // Convenience typedefs for bound argument types.</a>
<a name="ln2673">  typedef UnwrapTraits&lt;P1&gt; Bound1UnwrapTraits;</a>
<a name="ln2674">  typedef UnwrapTraits&lt;P2&gt; Bound2UnwrapTraits;</a>
<a name="ln2675">  typedef UnwrapTraits&lt;P3&gt; Bound3UnwrapTraits;</a>
<a name="ln2676">  typedef UnwrapTraits&lt;P4&gt; Bound4UnwrapTraits;</a>
<a name="ln2677">  typedef UnwrapTraits&lt;P5&gt; Bound5UnwrapTraits;</a>
<a name="ln2678">  typedef UnwrapTraits&lt;P6&gt; Bound6UnwrapTraits;</a>
<a name="ln2679">  typedef UnwrapTraits&lt;P7&gt; Bound7UnwrapTraits;</a>
<a name="ln2680"> </a>
<a name="ln2681">  BindState(const Runnable&amp; runnable, const P1&amp; p1, const P2&amp; p2, const P3&amp; p3,</a>
<a name="ln2682">      const P4&amp; p4, const P5&amp; p5, const P6&amp; p6, const P7&amp; p7)</a>
<a name="ln2683">      : runnable_(runnable),</a>
<a name="ln2684">        p1_(p1),</a>
<a name="ln2685">        p2_(p2),</a>
<a name="ln2686">        p3_(p3),</a>
<a name="ln2687">        p4_(p4),</a>
<a name="ln2688">        p5_(p5),</a>
<a name="ln2689">        p6_(p6),</a>
<a name="ln2690">        p7_(p7) {</a>
<a name="ln2691">    MaybeRefcount&lt;HasIsMethodTag&lt;Runnable&gt;::value, P1&gt;::AddRef(p1_);</a>
<a name="ln2692">  }</a>
<a name="ln2693"> </a>
<a name="ln2694">  virtual ~BindState() {    MaybeRefcount&lt;HasIsMethodTag&lt;Runnable&gt;::value,</a>
<a name="ln2695">      P1&gt;::Release(p1_);  }</a>
<a name="ln2696"> </a>
<a name="ln2697">  RunnableType runnable_;</a>
<a name="ln2698">  P1 p1_;</a>
<a name="ln2699">  P2 p2_;</a>
<a name="ln2700">  P3 p3_;</a>
<a name="ln2701">  P4 p4_;</a>
<a name="ln2702">  P5 p5_;</a>
<a name="ln2703">  P6 p6_;</a>
<a name="ln2704">  P7 p7_;</a>
<a name="ln2705">};</a>
<a name="ln2706"> </a>
<a name="ln2707">}  // namespace internal</a>
<a name="ln2708">}  // namespace yb</a>
<a name="ln2709"> </a>
<a name="ln2710">#endif // YB_GUTIL_BIND_INTERNAL_H_</a>

</code></pre>
<div class="balloon" rel="832"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
