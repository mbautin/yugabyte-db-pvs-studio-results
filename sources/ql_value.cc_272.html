
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ql_value.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Copyright (c) YugaByte, Inc.</a>
<a name="ln2">//</a>
<a name="ln3">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln4">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln5">//</a>
<a name="ln6">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln7">//</a>
<a name="ln8">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln9">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln10">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln11">// under the License.</a>
<a name="ln12">//</a>
<a name="ln13">//</a>
<a name="ln14">// This file contains the QLValue class that represents QL values.</a>
<a name="ln15"> </a>
<a name="ln16">#include &quot;yb/common/ql_value.h&quot;</a>
<a name="ln17"> </a>
<a name="ln18">#include &lt;cfloat&gt;</a>
<a name="ln19"> </a>
<a name="ln20">#include &lt;glog/logging.h&gt;</a>
<a name="ln21"> </a>
<a name="ln22">#include &quot;yb/common/jsonb.h&quot;</a>
<a name="ln23">#include &quot;yb/common/wire_protocol.h&quot;</a>
<a name="ln24">#include &quot;yb/gutil/strings/escaping.h&quot;</a>
<a name="ln25">#include &quot;yb/util/bytes_formatter.h&quot;</a>
<a name="ln26">#include &quot;yb/util/date_time.h&quot;</a>
<a name="ln27">#include &quot;yb/util/decimal.h&quot;</a>
<a name="ln28">#include &quot;yb/util/varint.h&quot;</a>
<a name="ln29">#include &quot;yb/util/enums.h&quot;</a>
<a name="ln30"> </a>
<a name="ln31">#include &quot;yb/util/size_literals.h&quot;</a>
<a name="ln32"> </a>
<a name="ln33">using yb::operator&quot;&quot; _MB;</a>
<a name="ln34"> </a>
<a name="ln35">// Maximumum value size is 64MB</a>
<a name="ln36">DEFINE_int32(yql_max_value_size, 64_MB,</a>
<a name="ln37">             &quot;Maximum size of a value in the Yugabyte Query Layer&quot;);</a>
<a name="ln38"> </a>
<a name="ln39">// The list of unsupported datypes to use in switch statements</a>
<a name="ln40">#define QL_UNSUPPORTED_TYPES_IN_SWITCH \</a>
<a name="ln41">  case NULL_VALUE_TYPE: FALLTHROUGH_INTENDED; \</a>
<a name="ln42">  case TUPLE: FALLTHROUGH_INTENDED;     \</a>
<a name="ln43">  case TYPEARGS: FALLTHROUGH_INTENDED;  \</a>
<a name="ln44">  case UNKNOWN_DATA</a>
<a name="ln45"> </a>
<a name="ln46">#define QL_INVALID_TYPES_IN_SWITCH     \</a>
<a name="ln47">  case UINT8:  FALLTHROUGH_INTENDED;    \</a>
<a name="ln48">  case UINT16: FALLTHROUGH_INTENDED;    \</a>
<a name="ln49">  case UINT32: FALLTHROUGH_INTENDED;    \</a>
<a name="ln50">  case UINT64</a>
<a name="ln51"> </a>
<a name="ln52">namespace yb {</a>
<a name="ln53"> </a>
<a name="ln54">using std::string;</a>
<a name="ln55">using std::shared_ptr;</a>
<a name="ln56">using std::to_string;</a>
<a name="ln57">using util::Decimal;</a>
<a name="ln58">using common::Jsonb;</a>
<a name="ln59"> </a>
<a name="ln60">template&lt;typename T&gt;</a>
<a name="ln61">static int GenericCompare(const T&amp; lhs, const T&amp; rhs) {</a>
<a name="ln62">  if (lhs &lt; rhs) return -1;</a>
<a name="ln63">  if (lhs &gt; rhs) return 1;</a>
<a name="ln64">  return 0;</a>
<a name="ln65">}</a>
<a name="ln66"> </a>
<a name="ln67">QLValue::~QLValue() {}</a>
<a name="ln68"> </a>
<a name="ln69">//------------------------- instance methods for abstract QLValue class -----------------------</a>
<a name="ln70"> </a>
<a name="ln71">int QLValue::CompareTo(const QLValue&amp; other) const {</a>
<a name="ln72">  CHECK_EQ(type(), other.type());</a>
<a name="ln73">  CHECK(!IsNull());</a>
<a name="ln74">  CHECK(!other.IsNull());</a>
<a name="ln75">  switch (type()) {</a>
<a name="ln76">    case InternalType::kInt8Value:   return GenericCompare(int8_value(), other.int8_value());</a>
<a name="ln77">    case InternalType::kInt16Value:  return GenericCompare(int16_value(), other.int16_value());</a>
<a name="ln78">    case InternalType::kInt32Value:  return GenericCompare(int32_value(), other.int32_value());</a>
<a name="ln79">    case InternalType::kInt64Value:  return GenericCompare(int64_value(), other.int64_value());</a>
<a name="ln80">    case InternalType::kUint32Value:  return GenericCompare(uint32_value(), other.uint32_value());</a>
<a name="ln81">    case InternalType::kUint64Value:  return GenericCompare(uint64_value(), other.uint64_value());</a>
<a name="ln82">    case InternalType::kFloatValue:  {</a>
<a name="ln83">      bool is_nan_0 = util::IsNanFloat(float_value());</a>
<a name="ln84">      bool is_nan_1 = util::IsNanFloat(other.float_value());</a>
<a name="ln85">      if (is_nan_0 &amp;&amp; is_nan_1) return 0;</a>
<a name="ln86">      if (is_nan_0 &amp;&amp; !is_nan_1) return 1;</a>
<a name="ln87">      if (!is_nan_0 &amp;&amp; is_nan_1) return -1;</a>
<a name="ln88">      return GenericCompare(float_value(), other.float_value());</a>
<a name="ln89">    }</a>
<a name="ln90">    case InternalType::kDoubleValue: {</a>
<a name="ln91">      bool is_nan_0 = util::IsNanDouble(double_value());</a>
<a name="ln92">      bool is_nan_1 = util::IsNanDouble(other.double_value());</a>
<a name="ln93">      if (is_nan_0 &amp;&amp; is_nan_1) return 0;</a>
<a name="ln94">      if (is_nan_0 &amp;&amp; !is_nan_1) return 1;</a>
<a name="ln95">      if (!is_nan_0 &amp;&amp; is_nan_1) return -1;</a>
<a name="ln96">      return GenericCompare(double_value(), other.double_value());</a>
<a name="ln97">    }</a>
<a name="ln98">    // Encoded decimal is byte-comparable.</a>
<a name="ln99">    case InternalType::kDecimalValue: return decimal_value().compare(other.decimal_value());</a>
<a name="ln100">    case InternalType::kVarintValue:  return varint_value().CompareTo(other.varint_value());</a>
<a name="ln101">    case InternalType::kStringValue: return string_value().compare(other.string_value());</a>
<a name="ln102">    case InternalType::kBoolValue: return Compare(bool_value(), other.bool_value());</a>
<a name="ln103">    case InternalType::kTimestampValue:</a>
<a name="ln104">      return GenericCompare(timestamp_value(), other.timestamp_value());</a>
<a name="ln105">    case InternalType::kBinaryValue: return binary_value().compare(other.binary_value());</a>
<a name="ln106">    case InternalType::kInetaddressValue:</a>
<a name="ln107">      return GenericCompare(inetaddress_value(), other.inetaddress_value());</a>
<a name="ln108">    case InternalType::kJsonbValue:</a>
<a name="ln109">      return GenericCompare(jsonb_value(), other.jsonb_value());</a>
<a name="ln110">    case InternalType::kUuidValue:</a>
<a name="ln111">      return GenericCompare(uuid_value(), other.uuid_value());</a>
<a name="ln112">    case InternalType::kTimeuuidValue:</a>
<a name="ln113">      return GenericCompare(timeuuid_value(), other.timeuuid_value());</a>
<a name="ln114">    case InternalType::kDateValue: return GenericCompare(date_value(), other.date_value());</a>
<a name="ln115">    case InternalType::kTimeValue: return GenericCompare(time_value(), other.time_value());</a>
<a name="ln116">    case QLValuePB::kFrozenValue: {</a>
<a name="ln117">      return Compare(frozen_value(), other.frozen_value());</a>
<a name="ln118">    }</a>
<a name="ln119">    case QLValuePB::kMapValue: FALLTHROUGH_INTENDED;</a>
<a name="ln120">    case QLValuePB::kSetValue: FALLTHROUGH_INTENDED;</a>
<a name="ln121">    case QLValuePB::kListValue:</a>
<a name="ln122">      LOG(FATAL) &lt;&lt; &quot;Internal error: collection types are not comparable&quot;;</a>
<a name="ln123">      return 0;</a>
<a name="ln124"> </a>
<a name="ln125">    case InternalType::VALUE_NOT_SET:</a>
<a name="ln126">      LOG(FATAL) &lt;&lt; &quot;Internal error: value should not be null&quot;;</a>
<a name="ln127">      break;</a>
<a name="ln128"> </a>
<a name="ln129">    // default: fall through</a>
<a name="ln130">  }</a>
<a name="ln131"> </a>
<a name="ln132">  LOG(FATAL) &lt;&lt; &quot;Internal error: unsupported type &quot; &lt;&lt; type();</a>
<a name="ln133">  return 0;</a>
<a name="ln134">}</a>
<a name="ln135"> </a>
<a name="ln136">// TODO(mihnea) After the hash changes, this method does not do the key encoding anymore</a>
<a name="ln137">// (not needed for hash computation), so AppendToBytes() is better describes what this method does.</a>
<a name="ln138">// The internal methods such as AppendIntToKey should be renamed accordingly.</a>
<a name="ln139">void AppendToKey(const QLValuePB &amp;value_pb, string *bytes) {</a>
<a name="ln140">  switch (value_pb.value_case()) {</a>
<a name="ln141">    case InternalType::kBoolValue: {</a>
<a name="ln142">      YBPartition::AppendIntToKey&lt;bool, uint8&gt;(value_pb.bool_value() ? 1 : 0, bytes);</a>
<a name="ln143">      break;</a>
<a name="ln144">    }</a>
<a name="ln145">    case InternalType::kInt8Value: {</a>
<a name="ln146">      YBPartition::AppendIntToKey&lt;int8, uint8&gt;(value_pb.int8_value(), bytes);</a>
<a name="ln147">      break;</a>
<a name="ln148">    }</a>
<a name="ln149">    case InternalType::kInt16Value: {</a>
<a name="ln150">      YBPartition::AppendIntToKey&lt;int16, uint16&gt;(value_pb.int16_value(), bytes);</a>
<a name="ln151">      break;</a>
<a name="ln152">    }</a>
<a name="ln153">    case InternalType::kInt32Value: {</a>
<a name="ln154">      YBPartition::AppendIntToKey&lt;int32, uint32&gt;(value_pb.int32_value(), bytes);</a>
<a name="ln155">      break;</a>
<a name="ln156">    }</a>
<a name="ln157">    case InternalType::kInt64Value: {</a>
<a name="ln158">      YBPartition::AppendIntToKey&lt;int64, uint64&gt;(value_pb.int64_value(), bytes);</a>
<a name="ln159">      break;</a>
<a name="ln160">    }</a>
<a name="ln161">    case InternalType::kUint32Value: {</a>
<a name="ln162">      YBPartition::AppendIntToKey&lt;uint32, uint32&gt;(value_pb.uint32_value(), bytes);</a>
<a name="ln163">      break;</a>
<a name="ln164">    }</a>
<a name="ln165">    case InternalType::kUint64Value: {</a>
<a name="ln166">      YBPartition::AppendIntToKey&lt;uint64, uint64&gt;(value_pb.uint64_value(), bytes);</a>
<a name="ln167">      break;</a>
<a name="ln168">    }</a>
<a name="ln169">    case InternalType::kTimestampValue: {</a>
<a name="ln170">      YBPartition::AppendIntToKey&lt;int64, uint64&gt;(value_pb.timestamp_value(), bytes);</a>
<a name="ln171">      break;</a>
<a name="ln172">    }</a>
<a name="ln173">    case InternalType::kDateValue: {</a>
<a name="ln174">      YBPartition::AppendIntToKey&lt;uint32, uint32&gt;(value_pb.date_value(), bytes);</a>
<a name="ln175">      break;</a>
<a name="ln176">    }</a>
<a name="ln177">    case InternalType::kTimeValue: {</a>
<a name="ln178">      YBPartition::AppendIntToKey&lt;int64, uint64&gt;(value_pb.time_value(), bytes);</a>
<a name="ln179">      break;</a>
<a name="ln180">    }</a>
<a name="ln181">    case InternalType::kStringValue: {</a>
<a name="ln182">      const string&amp; str = value_pb.string_value();</a>
<a name="ln183">      YBPartition::AppendBytesToKey(str.c_str(), str.length(), bytes);</a>
<a name="ln184">      break;</a>
<a name="ln185">    }</a>
<a name="ln186">    case InternalType::kUuidValue: {</a>
<a name="ln187">      const string&amp; str = value_pb.uuid_value();</a>
<a name="ln188">      YBPartition::AppendBytesToKey(str.c_str(), str.length(), bytes);</a>
<a name="ln189">      break;</a>
<a name="ln190">    }</a>
<a name="ln191">    case InternalType::kTimeuuidValue: {</a>
<a name="ln192">      const string&amp; str = value_pb.timeuuid_value();</a>
<a name="ln193">      YBPartition::AppendBytesToKey(str.c_str(), str.length(), bytes);</a>
<a name="ln194">      break;</a>
<a name="ln195">    }</a>
<a name="ln196">    case InternalType::kInetaddressValue: {</a>
<a name="ln197">      const string&amp; str = value_pb.inetaddress_value();</a>
<a name="ln198">      YBPartition::AppendBytesToKey(str.c_str(), str.length(), bytes);</a>
<a name="ln199">      break;</a>
<a name="ln200">    }</a>
<a name="ln201">    case InternalType::kDecimalValue: {</a>
<a name="ln202">      const string&amp; str = value_pb.decimal_value();</a>
<a name="ln203">      YBPartition::AppendBytesToKey(str.c_str(), str.length(), bytes);</a>
<a name="ln204">      break;</a>
<a name="ln205">    }</a>
<a name="ln206">    case InternalType::kVarintValue: {</a>
<a name="ln207">      const string&amp; str = value_pb.varint_value();</a>
<a name="ln208">      YBPartition::AppendBytesToKey(str.c_str(), str.length(), bytes);</a>
<a name="ln209">      break;</a>
<a name="ln210">    }</a>
<a name="ln211">    case InternalType::kBinaryValue: {</a>
<a name="ln212">      const string&amp; str = value_pb.binary_value();</a>
<a name="ln213">      YBPartition::AppendBytesToKey(str.c_str(), str.length(), bytes);</a>
<a name="ln214">      break;</a>
<a name="ln215">    }</a>
<a name="ln216">    case InternalType::kFloatValue: {</a>
<a name="ln217">      YBPartition::AppendIntToKey&lt;float, uint32&gt;(util::CanonicalizeFloat(value_pb.float_value()),</a>
<a name="ln218">                                                 bytes);</a>
<a name="ln219">      break;</a>
<a name="ln220">    }</a>
<a name="ln221">    case InternalType::kDoubleValue: {</a>
<a name="ln222">      YBPartition::AppendIntToKey&lt;double, uint64&gt;(util::CanonicalizeDouble(value_pb.double_value()),</a>
<a name="ln223">                                                  bytes);</a>
<a name="ln224">      break;</a>
<a name="ln225">    }</a>
<a name="ln226">    case InternalType::kFrozenValue: {</a>
<a name="ln227">      for (const auto&amp; elem_pb : value_pb.frozen_value().elems()) {</a>
<a name="ln228">        AppendToKey(elem_pb, bytes);</a>
<a name="ln229">      }</a>
<a name="ln230">      break;</a>
<a name="ln231">    }</a>
<a name="ln232">    case InternalType::VALUE_NOT_SET:</a>
<a name="ln233">      break;</a>
<a name="ln234">    case InternalType::kMapValue: FALLTHROUGH_INTENDED;</a>
<a name="ln235">    case InternalType::kSetValue: FALLTHROUGH_INTENDED;</a>
<a name="ln236">    case InternalType::kListValue: FALLTHROUGH_INTENDED;</a>
<a name="ln237">    case InternalType::kJsonbValue:</a>
<a name="ln238">      LOG(FATAL) &lt;&lt; &quot;Runtime error: This datatype(&quot;</a>
<a name="ln239">                 &lt;&lt; int(value_pb.value_case())</a>
<a name="ln240">                 &lt;&lt; &quot;) is not supported in hash key&quot;;</a>
<a name="ln241">  }</a>
<a name="ln242">}</a>
<a name="ln243"> </a>
<a name="ln244">void QLValue::Serialize(</a>
<a name="ln245">    const std::shared_ptr&lt;QLType&gt;&amp; ql_type, const QLClient&amp; client, const QLValuePB&amp; pb,</a>
<a name="ln246">    faststring* buffer) {</a>
<a name="ln247">  CHECK_EQ(client, YQL_CLIENT_CQL);</a>
<a name="ln248">  if (IsNull(pb)) {</a>
<a name="ln249">    CQLEncodeLength(-1, buffer);</a>
<a name="ln250">    return;</a>
<a name="ln251">  }</a>
<a name="ln252"> </a>
<a name="ln253">  switch (ql_type-&gt;main()) {</a>
<a name="ln254">    case INT8:</a>
<a name="ln255">      CQLEncodeNum(Store8, int8_value(pb), buffer);</a>
<a name="ln256">      return;</a>
<a name="ln257">    case INT16:</a>
<a name="ln258">      CQLEncodeNum(NetworkByteOrder::Store16, int16_value(pb), buffer);</a>
<a name="ln259">      return;</a>
<a name="ln260">    case INT32:</a>
<a name="ln261">      CQLEncodeNum(NetworkByteOrder::Store32, int32_value(pb), buffer);</a>
<a name="ln262">      return;</a>
<a name="ln263">    case INT64:</a>
<a name="ln264">      CQLEncodeNum(NetworkByteOrder::Store64, int64_value(pb), buffer);</a>
<a name="ln265">      return;</a>
<a name="ln266">    case FLOAT:</a>
<a name="ln267">      CQLEncodeFloat(NetworkByteOrder::Store32, float_value(pb), buffer);</a>
<a name="ln268">      return;</a>
<a name="ln269">    case DOUBLE:</a>
<a name="ln270">      CQLEncodeFloat(NetworkByteOrder::Store64, double_value(pb), buffer);</a>
<a name="ln271">      return;</a>
<a name="ln272">    case DECIMAL: {</a>
<a name="ln273">      auto decimal = util::DecimalFromComparable(decimal_value(pb));</a>
<a name="ln274">      bool is_out_of_range = false;</a>
<a name="ln275">      CQLEncodeBytes(decimal.EncodeToSerializedBigDecimal(&amp;is_out_of_range), buffer);</a>
<a name="ln276">      if(is_out_of_range) {</a>
<a name="ln277">        LOG(ERROR) &lt;&lt; &quot;Out of range: Unable to encode decimal &quot; &lt;&lt; decimal.ToString()</a>
<a name="ln278">                   &lt;&lt; &quot; into a BigDecimal serialized representation&quot;;</a>
<a name="ln279">      }</a>
<a name="ln280">      return;</a>
<a name="ln281">    }</a>
<a name="ln282">    case VARINT: {</a>
<a name="ln283">      CQLEncodeBytes(varint_value(pb).EncodeToTwosComplement(), buffer);</a>
<a name="ln284">      return;</a>
<a name="ln285">    }</a>
<a name="ln286">    case STRING:</a>
<a name="ln287">      CQLEncodeBytes(string_value(pb), buffer);</a>
<a name="ln288">      return;</a>
<a name="ln289">    case BOOL:</a>
<a name="ln290">      CQLEncodeNum(Store8, static_cast&lt;uint8&gt;(bool_value(pb) ? 1 : 0), buffer);</a>
<a name="ln291">      return;</a>
<a name="ln292">    case BINARY:</a>
<a name="ln293">      CQLEncodeBytes(binary_value(pb), buffer);</a>
<a name="ln294">      return;</a>
<a name="ln295">    case TIMESTAMP: {</a>
<a name="ln296">      int64_t val = DateTime::AdjustPrecision(timestamp_value_pb(pb),</a>
<a name="ln297">                                              DateTime::kInternalPrecision,</a>
<a name="ln298">                                              DateTime::CqlInputFormat.input_precision);</a>
<a name="ln299">      CQLEncodeNum(NetworkByteOrder::Store64, val, buffer);</a>
<a name="ln300">      return;</a>
<a name="ln301">    }</a>
<a name="ln302">    case DATE: {</a>
<a name="ln303">      CQLEncodeNum(NetworkByteOrder::Store32, date_value(pb), buffer);</a>
<a name="ln304">      return;</a>
<a name="ln305">    }</a>
<a name="ln306">    case TIME: {</a>
<a name="ln307">      CQLEncodeNum(NetworkByteOrder::Store64, time_value(pb), buffer);</a>
<a name="ln308">      return;</a>
<a name="ln309">    }</a>
<a name="ln310">    case INET: {</a>
<a name="ln311">      std::string bytes;</a>
<a name="ln312">      CHECK_OK(inetaddress_value(pb).ToBytes(&amp;bytes));</a>
<a name="ln313">      CQLEncodeBytes(bytes, buffer);</a>
<a name="ln314">      return;</a>
<a name="ln315">    }</a>
<a name="ln316">    case JSONB: {</a>
<a name="ln317">      std::string json;</a>
<a name="ln318">      Jsonb jsonb(jsonb_value(pb));</a>
<a name="ln319">      CHECK_OK(jsonb.ToJsonString(&amp;json));</a>
<a name="ln320">      CQLEncodeBytes(json, buffer);</a>
<a name="ln321">      return;</a>
<a name="ln322">    }</a>
<a name="ln323">    case UUID: {</a>
<a name="ln324">      std::string bytes;</a>
<a name="ln325">      CHECK_OK(uuid_value(pb).ToBytes(&amp;bytes));</a>
<a name="ln326">      CQLEncodeBytes(bytes, buffer);</a>
<a name="ln327">      return;</a>
<a name="ln328">    }</a>
<a name="ln329">    case TIMEUUID: {</a>
<a name="ln330">      std::string bytes;</a>
<a name="ln331">      Uuid uuid = timeuuid_value(pb);</a>
<a name="ln332">      CHECK_OK(uuid.IsTimeUuid());</a>
<a name="ln333">      CHECK_OK(uuid.ToBytes(&amp;bytes));</a>
<a name="ln334">      CQLEncodeBytes(bytes, buffer);</a>
<a name="ln335">      return;</a>
<a name="ln336">    }</a>
<a name="ln337">    case MAP: {</a>
<a name="ln338">      const QLMapValuePB&amp; map = map_value(pb);</a>
<a name="ln339">      DCHECK_EQ(map.keys_size(), map.values_size());</a>
<a name="ln340">      int32_t start_pos = CQLStartCollection(buffer);</a>
<a name="ln341">      int32_t length = static_cast&lt;int32_t&gt;(map.keys_size());</a>
<a name="ln342">      CQLEncodeLength(length, buffer);</a>
<a name="ln343">      const shared_ptr&lt;QLType&gt;&amp; keys_type = ql_type-&gt;params()[0];</a>
<a name="ln344">      const shared_ptr&lt;QLType&gt;&amp; values_type = ql_type-&gt;params()[1];</a>
<a name="ln345">      for (int i = 0; i &lt; length; i++) {</a>
<a name="ln346">        QLValue::Serialize(keys_type, client, map.keys(i), buffer);</a>
<a name="ln347">        QLValue::Serialize(values_type, client, map.values(i), buffer);</a>
<a name="ln348">      }</a>
<a name="ln349">      CQLFinishCollection(start_pos, buffer);</a>
<a name="ln350">      return;</a>
<a name="ln351">    }</a>
<a name="ln352">    case SET: {</a>
<a name="ln353">      const QLSeqValuePB&amp; set = set_value(pb);</a>
<a name="ln354">      int32_t start_pos = CQLStartCollection(buffer);</a>
<a name="ln355">      int32_t length = static_cast&lt;int32_t&gt;(set.elems_size());</a>
<a name="ln356">      CQLEncodeLength(length, buffer); // number of elements in collection</a>
<a name="ln357">      const shared_ptr&lt;QLType&gt;&amp; elems_type = ql_type-&gt;param_type(0);</a>
<a name="ln358">      for (auto&amp; elem : set.elems()) {</a>
<a name="ln359">        QLValue::Serialize(elems_type, client, elem, buffer);</a>
<a name="ln360">      }</a>
<a name="ln361">      CQLFinishCollection(start_pos, buffer);</a>
<a name="ln362">      return;</a>
<a name="ln363">    }</a>
<a name="ln364">    case LIST: {</a>
<a name="ln365">      const QLSeqValuePB&amp; list = list_value(pb);</a>
<a name="ln366">      int32_t start_pos = CQLStartCollection(buffer);</a>
<a name="ln367">      int32_t length = static_cast&lt;int32_t&gt;(list.elems_size());</a>
<a name="ln368">      CQLEncodeLength(length, buffer);</a>
<a name="ln369">      const shared_ptr&lt;QLType&gt;&amp; elems_type = ql_type-&gt;param_type(0);</a>
<a name="ln370">      for (auto&amp; elem : list.elems()) {</a>
<a name="ln371">        QLValue::Serialize(elems_type, client, elem, buffer);</a>
<a name="ln372">      }</a>
<a name="ln373">      CQLFinishCollection(start_pos, buffer);</a>
<a name="ln374">      return;</a>
<a name="ln375">    }</a>
<a name="ln376"> </a>
<a name="ln377">    case USER_DEFINED_TYPE: {</a>
<a name="ln378">      const QLMapValuePB&amp; map = map_value(pb);</a>
<a name="ln379">      DCHECK_EQ(map.keys_size(), map.values_size());</a>
<a name="ln380">      int32_t start_pos = CQLStartCollection(buffer);</a>
<a name="ln381"> </a>
<a name="ln382">      // For every field the UDT has, we try to find a corresponding map entry. If found we</a>
<a name="ln383">      // serialize the value, else null. Map keys should always be in ascending order.</a>
<a name="ln384">      int key_idx = 0;</a>
<a name="ln385">      for (int i = 0; i &lt; ql_type-&gt;udtype_field_names().size(); i++) {</a>
<a name="ln386">        if (key_idx &lt; map.keys_size() &amp;&amp; map.keys(key_idx).int16_value() == i) {</a>
<a name="ln387">          QLValue::Serialize(ql_type-&gt;param_type(i), client, map.values(key_idx), buffer);</a>
<a name="ln388">          key_idx++;</a>
<a name="ln389">        } else { // entry not found -&gt; writing null</a>
<a name="ln390">          CQLEncodeLength(-1, buffer);</a>
<a name="ln391">        }</a>
<a name="ln392">      }</a>
<a name="ln393"> </a>
<a name="ln394">      CQLFinishCollection(start_pos, buffer);</a>
<a name="ln395">      return;</a>
<a name="ln396">    }</a>
<a name="ln397">    case FROZEN: {</a>
<a name="ln398">      const QLSeqValuePB&amp; frozen = frozen_value(pb);</a>
<a name="ln399">      const auto&amp; type = ql_type-&gt;param_type(0);</a>
<a name="ln400">      switch (type-&gt;main()) {</a>
<a name="ln401">        case MAP: {</a>
<a name="ln402">          DCHECK_EQ(frozen.elems_size() % 2, 0);</a>
<a name="ln403">          int32_t start_pos = CQLStartCollection(buffer);</a>
<a name="ln404">          int32_t length = static_cast&lt;int32_t&gt;(frozen.elems_size() / 2);</a>
<a name="ln405">          CQLEncodeLength(length, buffer);</a>
<a name="ln406">          const shared_ptr&lt;QLType&gt; &amp;keys_type = type-&gt;params()[0];</a>
<a name="ln407">          const shared_ptr&lt;QLType&gt; &amp;values_type = type-&gt;params()[1];</a>
<a name="ln408">          for (int i = 0; i &lt; length; i++) {</a>
<a name="ln409">            QLValue::Serialize(keys_type, client, frozen.elems(2 * i), buffer);</a>
<a name="ln410">            QLValue::Serialize(values_type, client, frozen.elems(2 * i + 1), buffer);</a>
<a name="ln411">          }</a>
<a name="ln412">          CQLFinishCollection(start_pos, buffer);</a>
<a name="ln413">          return;</a>
<a name="ln414">        }</a>
<a name="ln415">        case SET: FALLTHROUGH_INTENDED;</a>
<a name="ln416">        case LIST: {</a>
<a name="ln417">          int32_t start_pos = CQLStartCollection(buffer);</a>
<a name="ln418">          int32_t length = static_cast&lt;int32_t&gt;(frozen.elems_size());</a>
<a name="ln419">          CQLEncodeLength(length, buffer); // number of elements in collection</a>
<a name="ln420">          const shared_ptr&lt;QLType&gt; &amp;elems_type = type-&gt;param_type(0);</a>
<a name="ln421">          for (auto &amp;elem : frozen.elems()) {</a>
<a name="ln422">            QLValue::Serialize(elems_type, client, elem, buffer);</a>
<a name="ln423">          }</a>
<a name="ln424">          CQLFinishCollection(start_pos, buffer);</a>
<a name="ln425">          return;</a>
<a name="ln426">        }</a>
<a name="ln427">        case USER_DEFINED_TYPE: {</a>
<a name="ln428">          int32_t start_pos = CQLStartCollection(buffer);</a>
<a name="ln429">          for (int i = 0; i &lt; frozen.elems_size(); i++) {</a>
<a name="ln430">            QLValue::Serialize(type-&gt;param_type(i), client, frozen.elems(i), buffer);</a>
<a name="ln431">          }</a>
<a name="ln432">          CQLFinishCollection(start_pos, buffer);</a>
<a name="ln433">          return;</a>
<a name="ln434">        }</a>
<a name="ln435"> </a>
<a name="ln436">        default:</a>
<a name="ln437">          break;</a>
<a name="ln438">      }</a>
<a name="ln439">      break;</a>
<a name="ln440">    }</a>
<a name="ln441"> </a>
<a name="ln442">    QL_UNSUPPORTED_TYPES_IN_SWITCH:</a>
<a name="ln443">      break;</a>
<a name="ln444"> </a>
<a name="ln445">    QL_INVALID_TYPES_IN_SWITCH:</a>
<a name="ln446">      break;</a>
<a name="ln447">    // default: fall through</a>
<a name="ln448">  }</a>
<a name="ln449"> </a>
<a name="ln450">  LOG(FATAL) &lt;&lt; &quot;Internal error: unsupported type &quot; &lt;&lt; ql_type-&gt;ToString();</a>
<a name="ln451">}</a>
<a name="ln452"> </a>
<a name="ln453">void QLValue::Serialize(</a>
<a name="ln454">    const std::shared_ptr&lt;QLType&gt;&amp; ql_type, const QLClient&amp; client, faststring* buffer) const {</a>
<a name="ln455">  return Serialize(ql_type, client, pb_, buffer);</a>
<a name="ln456">}</a>
<a name="ln457"> </a>
<a name="ln458">Status QLValue::Deserialize(</a>
<a name="ln459">    const std::shared_ptr&lt;QLType&gt;&amp; ql_type, const QLClient&amp; client, Slice* data) {</a>
<a name="ln460">  CHECK_EQ(client, YQL_CLIENT_CQL);</a>
<a name="ln461">  int32_t len = 0;</a>
<a name="ln462">  RETURN_NOT_OK(CQLDecodeNum(sizeof(len), NetworkByteOrder::Load32, data, &amp;len));</a>
<a name="ln463">  if (len == -1) {</a>
<a name="ln464">    SetNull();</a>
<a name="ln465">    return Status::OK();</a>
<a name="ln466">  }</a>
<a name="ln467">  if (len &gt; FLAGS_yql_max_value_size) {</a>
<a name="ln468">    return STATUS_SUBSTITUTE(NotSupported,</a>
<a name="ln469">        &quot;Value size ($0) is longer than max value size supported ($1)&quot;,</a>
<a name="ln470">        len, FLAGS_yql_max_value_size);</a>
<a name="ln471">  }</a>
<a name="ln472"> </a>
<a name="ln473">  switch (ql_type-&gt;main()) {</a>
<a name="ln474">    case INT8:</a>
<a name="ln475">      return CQLDeserializeNum(</a>
<a name="ln476">          len, Load8, static_cast&lt;void (QLValue::*)(int8_t)&gt;(&amp;QLValue::set_int8_value), data);</a>
<a name="ln477">    case INT16:</a>
<a name="ln478">      return CQLDeserializeNum(</a>
<a name="ln479">          len, NetworkByteOrder::Load16,</a>
<a name="ln480">          static_cast&lt;void (QLValue::*)(int16_t)&gt;(&amp;QLValue::set_int16_value), data);</a>
<a name="ln481">    case INT32:</a>
<a name="ln482">      return CQLDeserializeNum(</a>
<a name="ln483">          len, NetworkByteOrder::Load32,</a>
<a name="ln484">          static_cast&lt;void (QLValue::*)(int32_t)&gt;(&amp;QLValue::set_int32_value), data);</a>
<a name="ln485">    case INT64:</a>
<a name="ln486">      return CQLDeserializeNum(</a>
<a name="ln487">          len, NetworkByteOrder::Load64,</a>
<a name="ln488">          static_cast&lt;void (QLValue::*)(int64_t)&gt;(&amp;QLValue::set_int64_value), data);</a>
<a name="ln489">    case FLOAT:</a>
<a name="ln490">      return CQLDeserializeFloat(</a>
<a name="ln491">          len, NetworkByteOrder::Load32,</a>
<a name="ln492">          static_cast&lt;void (QLValue::*)(float)&gt;(&amp;QLValue::set_float_value), data);</a>
<a name="ln493">    case DOUBLE:</a>
<a name="ln494">      return CQLDeserializeFloat(</a>
<a name="ln495">          len, NetworkByteOrder::Load64,</a>
<a name="ln496">          static_cast&lt;void (QLValue::*)(double)&gt;(&amp;QLValue::set_double_value), data);</a>
<a name="ln497">    case DECIMAL: {</a>
<a name="ln498">      string value;</a>
<a name="ln499">      RETURN_NOT_OK(CQLDecodeBytes(len, data, &amp;value));</a>
<a name="ln500">      Decimal decimal;</a>
<a name="ln501">      RETURN_NOT_OK(decimal.DecodeFromSerializedBigDecimal(value));</a>
<a name="ln502">      set_decimal_value(decimal.EncodeToComparable());</a>
<a name="ln503">      return Status::OK();</a>
<a name="ln504">    }</a>
<a name="ln505">    case VARINT: {</a>
<a name="ln506">      string value;</a>
<a name="ln507">      RETURN_NOT_OK(CQLDecodeBytes(len, data, &amp;value));</a>
<a name="ln508">      util::VarInt varint;</a>
<a name="ln509">      RETURN_NOT_OK(varint.DecodeFromTwosComplement(value));</a>
<a name="ln510">      set_varint_value(varint);</a>
<a name="ln511">      return Status::OK();</a>
<a name="ln512">    }</a>
<a name="ln513">    case STRING:</a>
<a name="ln514">      return CQLDecodeBytes(len, data, mutable_string_value());</a>
<a name="ln515">    case BOOL: {</a>
<a name="ln516">      uint8_t value = 0;</a>
<a name="ln517">      RETURN_NOT_OK(CQLDecodeNum(len, Load8, data, &amp;value));</a>
<a name="ln518">      set_bool_value(value != 0);</a>
<a name="ln519">      return Status::OK();</a>
<a name="ln520">    }</a>
<a name="ln521">    case BINARY:</a>
<a name="ln522">      return CQLDecodeBytes(len, data, mutable_binary_value());</a>
<a name="ln523">    case TIMESTAMP: {</a>
<a name="ln524">      int64_t value = 0;</a>
<a name="ln525">      RETURN_NOT_OK(CQLDecodeNum(len, NetworkByteOrder::Load64, data, &amp;value));</a>
<a name="ln526">      value = DateTime::AdjustPrecision(value,</a>
<a name="ln527">                                        DateTime::CqlInputFormat.input_precision,</a>
<a name="ln528">                                        DateTime::kInternalPrecision);</a>
<a name="ln529">      set_timestamp_value(value);</a>
<a name="ln530">      return Status::OK();</a>
<a name="ln531">    }</a>
<a name="ln532">    case DATE: {</a>
<a name="ln533">      uint32_t value = 0;</a>
<a name="ln534">      RETURN_NOT_OK(CQLDecodeNum(len, NetworkByteOrder::Load32, data, &amp;value));</a>
<a name="ln535">      set_date_value(value);</a>
<a name="ln536">      return Status::OK();</a>
<a name="ln537">    }</a>
<a name="ln538">    case TIME: {</a>
<a name="ln539">      int64_t value = 0;</a>
<a name="ln540">      RETURN_NOT_OK(CQLDecodeNum(len, NetworkByteOrder::Load64, data, &amp;value));</a>
<a name="ln541">      set_time_value(value);</a>
<a name="ln542">      return Status::OK();</a>
<a name="ln543">    }</a>
<a name="ln544">    case INET: {</a>
<a name="ln545">      string bytes;</a>
<a name="ln546">      RETURN_NOT_OK(CQLDecodeBytes(len, data, &amp;bytes));</a>
<a name="ln547">      InetAddress addr;</a>
<a name="ln548">      RETURN_NOT_OK(addr.FromBytes(bytes));</a>
<a name="ln549">      set_inetaddress_value(addr);</a>
<a name="ln550">      return Status::OK();</a>
<a name="ln551">    }</a>
<a name="ln552">    case JSONB: {</a>
<a name="ln553">      string json;</a>
<a name="ln554">      RETURN_NOT_OK(CQLDecodeBytes(len, data, &amp;json));</a>
<a name="ln555">      Jsonb jsonb;</a>
<a name="ln556">      RETURN_NOT_OK(jsonb.FromString(json));</a>
<a name="ln557">      set_jsonb_value(jsonb.MoveSerializedJsonb());</a>
<a name="ln558">      return Status::OK();</a>
<a name="ln559">    }</a>
<a name="ln560">    case UUID: {</a>
<a name="ln561">      string bytes;</a>
<a name="ln562">      RETURN_NOT_OK(CQLDecodeBytes(len, data, &amp;bytes));</a>
<a name="ln563">      Uuid uuid;</a>
<a name="ln564">      RETURN_NOT_OK(uuid.FromBytes(bytes));</a>
<a name="ln565">      set_uuid_value(uuid);</a>
<a name="ln566">      return Status::OK();</a>
<a name="ln567">    }</a>
<a name="ln568">    case TIMEUUID: {</a>
<a name="ln569">      string bytes;</a>
<a name="ln570">      RETURN_NOT_OK(CQLDecodeBytes(len, data, &amp;bytes));</a>
<a name="ln571">      Uuid uuid;</a>
<a name="ln572">      RETURN_NOT_OK(uuid.FromBytes(bytes));</a>
<a name="ln573">      RETURN_NOT_OK(uuid.IsTimeUuid());</a>
<a name="ln574">      set_timeuuid_value(uuid);</a>
<a name="ln575">      return Status::OK();</a>
<a name="ln576">    }</a>
<a name="ln577">    case MAP: {</a>
<a name="ln578">      const shared_ptr&lt;QLType&gt;&amp; keys_type = ql_type-&gt;param_type(0);</a>
<a name="ln579">      const shared_ptr&lt;QLType&gt;&amp; values_type = ql_type-&gt;param_type(1);</a>
<a name="ln580">      set_map_value();</a>
<a name="ln581">      int32_t nr_elems = 0;</a>
<a name="ln582">      RETURN_NOT_OK(CQLDecodeNum(sizeof(nr_elems), NetworkByteOrder::Load32, data, &amp;nr_elems));</a>
<a name="ln583">      for (int i = 0; i &lt; nr_elems; i++) {</a>
<a name="ln584">        QLValue key;</a>
<a name="ln585">        RETURN_NOT_OK(key.Deserialize(keys_type, client, data));</a>
<a name="ln586">        *add_map_key() = std::move(*key.mutable_value());</a>
<a name="ln587">        QLValue value;</a>
<a name="ln588">        RETURN_NOT_OK(value.Deserialize(values_type, client, data));</a>
<a name="ln589">        *add_map_value() = std::move(*value.mutable_value());</a>
<a name="ln590">      }</a>
<a name="ln591">      return Status::OK();</a>
<a name="ln592">    }</a>
<a name="ln593">    case SET: {</a>
<a name="ln594">      const shared_ptr&lt;QLType&gt;&amp; elems_type = ql_type-&gt;param_type(0);</a>
<a name="ln595">      set_set_value();</a>
<a name="ln596">      int32_t nr_elems = 0;</a>
<a name="ln597">      RETURN_NOT_OK(CQLDecodeNum(sizeof(nr_elems), NetworkByteOrder::Load32, data, &amp;nr_elems));</a>
<a name="ln598">      for (int i = 0; i &lt; nr_elems; i++) {</a>
<a name="ln599">        QLValue elem;</a>
<a name="ln600">        RETURN_NOT_OK(elem.Deserialize(elems_type, client, data));</a>
<a name="ln601">        *add_set_elem() = std::move(*elem.mutable_value());</a>
<a name="ln602">      }</a>
<a name="ln603">      return Status::OK();</a>
<a name="ln604">    }</a>
<a name="ln605">    case LIST: {</a>
<a name="ln606">      const shared_ptr&lt;QLType&gt;&amp; elems_type = ql_type-&gt;param_type(0);</a>
<a name="ln607">      set_list_value();</a>
<a name="ln608">      int32_t nr_elems = 0;</a>
<a name="ln609">      RETURN_NOT_OK(CQLDecodeNum(sizeof(nr_elems), NetworkByteOrder::Load32, data, &amp;nr_elems));</a>
<a name="ln610">      for (int i = 0; i &lt; nr_elems; i++) {</a>
<a name="ln611">        QLValue elem;</a>
<a name="ln612">        RETURN_NOT_OK(elem.Deserialize(elems_type, client, data));</a>
<a name="ln613">        *add_list_elem() = std::move(*elem.mutable_value());</a>
<a name="ln614">      }</a>
<a name="ln615">      return Status::OK();</a>
<a name="ln616">    }</a>
<a name="ln617"> </a>
<a name="ln618">    case USER_DEFINED_TYPE: {</a>
<a name="ln619">      set_map_value();</a>
<a name="ln620">      size_t fields_size = ql_type-&gt;udtype_field_names().size();</a>
<a name="ln621">      for (size_t i = 0; i &lt; fields_size; i++) {</a>
<a name="ln622">        // TODO (mihnea) default to null if value missing (CQL behavior)</a>
<a name="ln623">        QLValue value;</a>
<a name="ln624">        RETURN_NOT_OK(value.Deserialize(ql_type-&gt;param_type(i), client, data));</a>
<a name="ln625">        if (!value.IsNull()) {</a>
<a name="ln626">          add_map_key()-&gt;set_int16_value(i);</a>
<a name="ln627">          *add_map_value() = std::move(*value.mutable_value());</a>
<a name="ln628">        }</a>
<a name="ln629">      }</a>
<a name="ln630">      return Status::OK();</a>
<a name="ln631">    }</a>
<a name="ln632"> </a>
<a name="ln633">    case FROZEN: {</a>
<a name="ln634">      set_frozen_value();</a>
<a name="ln635">      const auto&amp; type = ql_type-&gt;param_type(0);</a>
<a name="ln636">      switch (type-&gt;main()) {</a>
<a name="ln637">        case MAP: {</a>
<a name="ln638">          std::map&lt;QLValue, QLValue&gt; map_values;</a>
<a name="ln639">          const shared_ptr&lt;QLType&gt; &amp;keys_type = type-&gt;param_type(0);</a>
<a name="ln640">          const shared_ptr&lt;QLType&gt; &amp;values_type = type-&gt;param_type(1);</a>
<a name="ln641">          int32_t nr_elems = 0;</a>
<a name="ln642">          RETURN_NOT_OK(CQLDecodeNum(sizeof(nr_elems), NetworkByteOrder::Load32, data, &amp;nr_elems));</a>
<a name="ln643">          for (int i = 0; i &lt; nr_elems; i++) {</a>
<a name="ln644">            QLValue key;</a>
<a name="ln645">            RETURN_NOT_OK(key.Deserialize(keys_type, client, data));</a>
<a name="ln646">            QLValue value;</a>
<a name="ln647">            RETURN_NOT_OK(value.Deserialize(values_type, client, data));</a>
<a name="ln648">            map_values[key] = value;</a>
<a name="ln649">          }</a>
<a name="ln650"> </a>
<a name="ln651">          for (auto &amp;pair : map_values) {</a>
<a name="ln652">            *add_frozen_elem() = std::move(pair.first.value());</a>
<a name="ln653">            *add_frozen_elem() = std::move(pair.second.value());</a>
<a name="ln654">          }</a>
<a name="ln655"> </a>
<a name="ln656">          return Status::OK();</a>
<a name="ln657">        }</a>
<a name="ln658">        case SET: {</a>
<a name="ln659">          const shared_ptr&lt;QLType&gt; &amp;elems_type = type-&gt;param_type(0);</a>
<a name="ln660">          int32_t nr_elems = 0;</a>
<a name="ln661"> </a>
<a name="ln662">          std::set&lt;QLValue&gt; set_values;</a>
<a name="ln663">          RETURN_NOT_OK(CQLDecodeNum(sizeof(nr_elems), NetworkByteOrder::Load32, data, &amp;nr_elems));</a>
<a name="ln664">          for (int i = 0; i &lt; nr_elems; i++) {</a>
<a name="ln665">            QLValue elem;</a>
<a name="ln666">            RETURN_NOT_OK(elem.Deserialize(elems_type, client, data));</a>
<a name="ln667">            set_values.insert(std::move(elem));</a>
<a name="ln668">          }</a>
<a name="ln669">          for (auto &amp;elem : set_values) {</a>
<a name="ln670">            *add_frozen_elem() = std::move(elem.value());</a>
<a name="ln671">          }</a>
<a name="ln672">          return Status::OK();</a>
<a name="ln673">        }</a>
<a name="ln674">        case LIST: {</a>
<a name="ln675">          const shared_ptr&lt;QLType&gt; &amp;elems_type = type-&gt;param_type(0);</a>
<a name="ln676">          int32_t nr_elems = 0;</a>
<a name="ln677">          RETURN_NOT_OK(CQLDecodeNum(sizeof(nr_elems), NetworkByteOrder::Load32, data, &amp;nr_elems));</a>
<a name="ln678">          for (int i = 0; i &lt; nr_elems; i++) {</a>
<a name="ln679">            QLValue elem;</a>
<a name="ln680">            RETURN_NOT_OK(elem.Deserialize(elems_type, client, data));</a>
<a name="ln681">            *add_frozen_elem() = std::move(*elem.mutable_value());</a>
<a name="ln682">          }</a>
<a name="ln683">          return Status::OK();</a>
<a name="ln684">        }</a>
<a name="ln685"> </a>
<a name="ln686">        case USER_DEFINED_TYPE: {</a>
<a name="ln687">          const size_t fields_size = type-&gt;udtype_field_names().size();</a>
<a name="ln688">          for (size_t i = 0; i &lt; fields_size; i++) {</a>
<a name="ln689">            // TODO (mihnea) default to null if value missing (CQL behavior)</a>
<a name="ln690">            QLValue value;</a>
<a name="ln691">            RETURN_NOT_OK(value.Deserialize(type-&gt;param_type(i), client, data));</a>
<a name="ln692">            *add_frozen_elem() = std::move(*value.mutable_value());</a>
<a name="ln693">          }</a>
<a name="ln694">          return Status::OK();</a>
<a name="ln695">        }</a>
<a name="ln696">        default:</a>
<a name="ln697">          break;</a>
<a name="ln698"> </a>
<a name="ln699">      }</a>
<a name="ln700">      break;</a>
<a name="ln701">    }</a>
<a name="ln702"> </a>
<a name="ln703">    QL_UNSUPPORTED_TYPES_IN_SWITCH:</a>
<a name="ln704">      break;</a>
<a name="ln705"> </a>
<a name="ln706">    QL_INVALID_TYPES_IN_SWITCH:</a>
<a name="ln707">      break;</a>
<a name="ln708"> </a>
<a name="ln709">    // default: fall through</a>
<a name="ln710">  }</a>
<a name="ln711"> </a>
<a name="ln712">  LOG(FATAL) &lt;&lt; &quot;Internal error: unsupported type &quot; &lt;&lt; ql_type-&gt;ToString();</a>
<a name="ln713">  return STATUS(InternalError, &quot;unsupported type&quot;);</a>
<a name="ln714">}</a>
<a name="ln715"> </a>
<a name="ln716">string QLValue::ToString() const {</a>
<a name="ln717">  if (IsNull()) {</a>
<a name="ln718">    return &quot;null&quot;;</a>
<a name="ln719">  }</a>
<a name="ln720"> </a>
<a name="ln721">  switch (type()) {</a>
<a name="ln722">    case InternalType::kInt8Value: return &quot;int8:&quot; + to_string(int8_value());</a>
<a name="ln723">    case InternalType::kInt16Value: return &quot;int16:&quot; + to_string(int16_value());</a>
<a name="ln724">    case InternalType::kInt32Value: return &quot;int32:&quot; + to_string(int32_value());</a>
<a name="ln725">    case InternalType::kInt64Value: return &quot;int64:&quot; + to_string(int64_value());</a>
<a name="ln726">    case InternalType::kUint32Value: return &quot;uint32:&quot; + to_string(uint32_value());</a>
<a name="ln727">    case InternalType::kUint64Value: return &quot;uint64:&quot; + to_string(uint64_value());</a>
<a name="ln728">    case InternalType::kFloatValue: return &quot;float:&quot; + to_string(float_value());</a>
<a name="ln729">    case InternalType::kDoubleValue: return &quot;double:&quot; + to_string(double_value());</a>
<a name="ln730">    case InternalType::kDecimalValue:</a>
<a name="ln731">      return &quot;decimal: &quot; + util::DecimalFromComparable(decimal_value()).ToString();</a>
<a name="ln732">    case InternalType::kVarintValue:</a>
<a name="ln733">      return &quot;varint: &quot; + varint_value().ToString();</a>
<a name="ln734">    case InternalType::kStringValue: return &quot;string:&quot; + FormatBytesAsStr(string_value());</a>
<a name="ln735">    case InternalType::kTimestampValue: return &quot;timestamp:&quot; + timestamp_value().ToFormattedString();</a>
<a name="ln736">    case InternalType::kDateValue: return &quot;date:&quot; + to_string(date_value());</a>
<a name="ln737">    case InternalType::kTimeValue: return &quot;time:&quot; + to_string(time_value());</a>
<a name="ln738">    case InternalType::kInetaddressValue: return &quot;inetaddress:&quot; + inetaddress_value().ToString();</a>
<a name="ln739">    case InternalType::kJsonbValue: return &quot;jsonb:&quot; + FormatBytesAsStr(jsonb_value());</a>
<a name="ln740">    case InternalType::kUuidValue: return &quot;uuid:&quot; + uuid_value().ToString();</a>
<a name="ln741">    case InternalType::kTimeuuidValue: return &quot;timeuuid:&quot; + timeuuid_value().ToString();</a>
<a name="ln742">    case InternalType::kBoolValue: return (bool_value() ? &quot;bool:true&quot; : &quot;bool:false&quot;);</a>
<a name="ln743">    case InternalType::kBinaryValue: return &quot;binary:0x&quot; + b2a_hex(binary_value());</a>
<a name="ln744"> </a>
<a name="ln745">    case InternalType::kMapValue: {</a>
<a name="ln746">      std::stringstream ss;</a>
<a name="ln747">      QLMapValuePB map = map_value();</a>
<a name="ln748">      DCHECK_EQ(map.keys_size(), map.values_size());</a>
<a name="ln749">      ss &lt;&lt; &quot;map:{&quot;;</a>
<a name="ln750">      for (int i = 0; i &lt; map.keys_size(); i++) {</a>
<a name="ln751">        if (i &gt; 0) {</a>
<a name="ln752">          ss &lt;&lt; &quot;, &quot;;</a>
<a name="ln753">        }</a>
<a name="ln754">        ss &lt;&lt; QLValue(map.keys(i)).ToString() &lt;&lt; &quot; -&gt; &quot;</a>
<a name="ln755">           &lt;&lt; QLValue(map.values(i)).ToString();</a>
<a name="ln756">      }</a>
<a name="ln757">      ss &lt;&lt; &quot;}&quot;;</a>
<a name="ln758">      return ss.str();</a>
<a name="ln759">    }</a>
<a name="ln760">    case InternalType::kSetValue: {</a>
<a name="ln761">      std::stringstream ss;</a>
<a name="ln762">      QLSeqValuePB set = set_value();</a>
<a name="ln763">      ss &lt;&lt; &quot;set:{&quot;;</a>
<a name="ln764">      for (int i = 0; i &lt; set.elems_size(); i++) {</a>
<a name="ln765">        if (i &gt; 0) {</a>
<a name="ln766">          ss &lt;&lt; &quot;, &quot;;</a>
<a name="ln767">        }</a>
<a name="ln768">        ss &lt;&lt; QLValue(set.elems(i)).ToString();</a>
<a name="ln769">      }</a>
<a name="ln770">      ss &lt;&lt; &quot;}&quot;;</a>
<a name="ln771">      return ss.str();</a>
<a name="ln772">    }</a>
<a name="ln773">    case InternalType::kListValue: {</a>
<a name="ln774">      std::stringstream ss;</a>
<a name="ln775">      QLSeqValuePB list = list_value();</a>
<a name="ln776">      ss &lt;&lt; &quot;list:[&quot;;</a>
<a name="ln777">      for (int i = 0; i &lt; list.elems_size(); i++) {</a>
<a name="ln778">        if (i &gt; 0) {</a>
<a name="ln779">          ss &lt;&lt; &quot;, &quot;;</a>
<a name="ln780">        }</a>
<a name="ln781">        ss &lt;&lt; QLValue(list.elems(i)).ToString();</a>
<a name="ln782">      }</a>
<a name="ln783">      ss &lt;&lt; &quot;]&quot;;</a>
<a name="ln784">      return ss.str();</a>
<a name="ln785">    }</a>
<a name="ln786"> </a>
<a name="ln787">    case InternalType::kFrozenValue: {</a>
<a name="ln788">      std::stringstream ss;</a>
<a name="ln789">      QLSeqValuePB frozen = frozen_value();</a>
<a name="ln790">      ss &lt;&lt; &quot;frozen:&lt;&quot;;</a>
<a name="ln791">      for (int i = 0; i &lt; frozen.elems_size(); i++) {</a>
<a name="ln792">        if (i &gt; 0) {</a>
<a name="ln793">          ss &lt;&lt; &quot;, &quot;;</a>
<a name="ln794">        }</a>
<a name="ln795">        ss &lt;&lt; QLValue(frozen.elems(i)).ToString();</a>
<a name="ln796">      }</a>
<a name="ln797">      ss &lt;&lt; &quot;&gt;&quot;;</a>
<a name="ln798">      return ss.str();</a>
<a name="ln799">    }</a>
<a name="ln800"> </a>
<a name="ln801">    case InternalType::VALUE_NOT_SET:</a>
<a name="ln802">      LOG(FATAL) &lt;&lt; &quot;Internal error: value should not be null&quot;;</a>
<a name="ln803">      return &quot;null&quot;;</a>
<a name="ln804">    // default: fall through</a>
<a name="ln805">  }</a>
<a name="ln806"> </a>
<a name="ln807">  LOG(FATAL) &lt;&lt; &quot;Internal error: unknown or unsupported type &quot; &lt;&lt; type();</a>
<a name="ln808">  return &quot;unknown&quot;;</a>
<a name="ln809">}</a>
<a name="ln810"> </a>
<a name="ln811">//----------------------------------- QLValuePB operators --------------------------------</a>
<a name="ln812"> </a>
<a name="ln813">InternalType type(const QLValuePB&amp; v) {</a>
<a name="ln814">  return v.value_case();</a>
<a name="ln815">}</a>
<a name="ln816">bool IsNull(const QLValuePB&amp; v) {</a>
<a name="ln817">  return v.value_case() == QLValuePB::VALUE_NOT_SET;</a>
<a name="ln818">}</a>
<a name="ln819">void SetNull(QLValuePB* v) {</a>
<a name="ln820">  v-&gt;Clear();</a>
<a name="ln821">}</a>
<a name="ln822">bool EitherIsNull(const QLValuePB&amp; lhs, const QLValuePB&amp; rhs) {</a>
<a name="ln823">  return IsNull(lhs) || IsNull(rhs);</a>
<a name="ln824">}</a>
<a name="ln825">bool BothNotNull(const QLValuePB&amp; lhs, const QLValuePB&amp; rhs) {</a>
<a name="ln826">  return !IsNull(lhs) &amp;&amp; !IsNull(rhs);</a>
<a name="ln827">}</a>
<a name="ln828">bool BothNull(const QLValuePB&amp; lhs, const QLValuePB&amp; rhs) {</a>
<a name="ln829">  return IsNull(lhs) &amp;&amp; IsNull(rhs);</a>
<a name="ln830">}</a>
<a name="ln831">bool Comparable(const QLValuePB&amp; lhs, const QLValuePB&amp; rhs) {</a>
<a name="ln832">  return lhs.value_case() == rhs.value_case() || EitherIsNull(lhs, rhs);</a>
<a name="ln833">}</a>
<a name="ln834">bool EitherIsNull(const QLValuePB&amp; lhs, const QLValue&amp; rhs) {</a>
<a name="ln835">  return IsNull(lhs) || rhs.IsNull();</a>
<a name="ln836">}</a>
<a name="ln837">bool Comparable(const QLValuePB&amp; lhs, const QLValue&amp; rhs) {</a>
<a name="ln838">  return lhs.value_case() == rhs.type() || EitherIsNull(lhs, rhs);</a>
<a name="ln839">}</a>
<a name="ln840">bool BothNotNull(const QLValuePB&amp; lhs, const QLValue&amp; rhs) {</a>
<a name="ln841">  return !IsNull(lhs) &amp;&amp; !rhs.IsNull();</a>
<a name="ln842">}</a>
<a name="ln843">bool BothNull(const QLValuePB&amp; lhs, const QLValue&amp; rhs) {</a>
<a name="ln844">  return IsNull(lhs) &amp;&amp; rhs.IsNull();</a>
<a name="ln845">}</a>
<a name="ln846">int Compare(const QLValuePB&amp; lhs, const QLValuePB&amp; rhs) {</a>
<a name="ln847">  CHECK(Comparable(lhs, rhs));</a>
<a name="ln848">  CHECK(BothNotNull(lhs, rhs));</a>
<a name="ln849">  switch (lhs.value_case()) {</a>
<a name="ln850">    case QLValuePB::kInt8Value:   return GenericCompare(lhs.int8_value(), rhs.int8_value());</a>
<a name="ln851">    case QLValuePB::kInt16Value:  return GenericCompare(lhs.int16_value(), rhs.int16_value());</a>
<a name="ln852">    case QLValuePB::kInt32Value:  return GenericCompare(lhs.int32_value(), rhs.int32_value());</a>
<a name="ln853">    case QLValuePB::kInt64Value:  return GenericCompare(lhs.int64_value(), rhs.int64_value());</a>
<a name="ln854">    case QLValuePB::kUint32Value:  return GenericCompare(lhs.uint32_value(), rhs.uint32_value());</a>
<a name="ln855">    case QLValuePB::kUint64Value:  return GenericCompare(lhs.uint64_value(), rhs.uint64_value());</a>
<a name="ln856">    case QLValuePB::kFloatValue:  {</a>
<a name="ln857">      bool is_nan_0 = util::IsNanFloat(lhs.float_value());</a>
<a name="ln858">      bool is_nan_1 = util::IsNanFloat(rhs.float_value());</a>
<a name="ln859">      if (is_nan_0 &amp;&amp; is_nan_1) return 0;</a>
<a name="ln860">      if (is_nan_0 &amp;&amp; !is_nan_1) return 1;</a>
<a name="ln861">      if (!is_nan_0 &amp;&amp; is_nan_1) return -1;</a>
<a name="ln862">      return GenericCompare(lhs.float_value(), rhs.float_value());</a>
<a name="ln863">    }</a>
<a name="ln864">    case QLValuePB::kDoubleValue: {</a>
<a name="ln865">      bool is_nan_0 = util::IsNanDouble(lhs.double_value());</a>
<a name="ln866">      bool is_nan_1 = util::IsNanDouble(rhs.double_value());</a>
<a name="ln867">      if (is_nan_0 &amp;&amp; is_nan_1) return 0;</a>
<a name="ln868">      if (is_nan_0 &amp;&amp; !is_nan_1) return 1;</a>
<a name="ln869">      if (!is_nan_0 &amp;&amp; is_nan_1) return -1;</a>
<a name="ln870">      return GenericCompare(lhs.double_value(), rhs.double_value());</a>
<a name="ln871">    }</a>
<a name="ln872">    // Encoded decimal is byte-comparable.</a>
<a name="ln873">    case QLValuePB::kDecimalValue: return lhs.decimal_value().compare(rhs.decimal_value());</a>
<a name="ln874">    case QLValuePB::kVarintValue: return lhs.varint_value().compare(rhs.varint_value());</a>
<a name="ln875">    case QLValuePB::kStringValue: return lhs.string_value().compare(rhs.string_value());</a>
<a name="ln876">    case QLValuePB::kBoolValue: return Compare(lhs.bool_value(), rhs.bool_value());</a>
<a name="ln877">    case QLValuePB::kTimestampValue:</a>
<a name="ln878">      return GenericCompare(lhs.timestamp_value(), rhs.timestamp_value());</a>
<a name="ln879">    case QLValuePB::kDateValue: return GenericCompare(lhs.date_value(), rhs.date_value());</a>
<a name="ln880">    case QLValuePB::kTimeValue: return GenericCompare(lhs.time_value(), rhs.time_value());</a>
<a name="ln881">    case QLValuePB::kBinaryValue: return lhs.binary_value().compare(rhs.binary_value());</a>
<a name="ln882">    case QLValuePB::kInetaddressValue:</a>
<a name="ln883">      return GenericCompare(lhs.inetaddress_value(), rhs.inetaddress_value());</a>
<a name="ln884">    case QLValuePB::kJsonbValue:</a>
<a name="ln885">      return GenericCompare(lhs.jsonb_value(), rhs.jsonb_value());</a>
<a name="ln886">    case QLValuePB::kUuidValue:</a>
<a name="ln887">      return GenericCompare(QLValue::uuid_value(lhs), QLValue::uuid_value(rhs));</a>
<a name="ln888">    case QLValuePB::kTimeuuidValue:</a>
<a name="ln889">      return GenericCompare(QLValue::timeuuid_value(lhs), QLValue::timeuuid_value(rhs));</a>
<a name="ln890">    case QLValuePB::kFrozenValue:</a>
<a name="ln891">      return Compare(lhs.frozen_value(), rhs.frozen_value());</a>
<a name="ln892">    case QLValuePB::kMapValue: FALLTHROUGH_INTENDED;</a>
<a name="ln893">    case QLValuePB::kSetValue: FALLTHROUGH_INTENDED;</a>
<a name="ln894">    case QLValuePB::kListValue:</a>
<a name="ln895">      LOG(FATAL) &lt;&lt; &quot;Internal error: collection types are not comparable&quot;;</a>
<a name="ln896">      return 0;</a>
<a name="ln897">    case QLValuePB::VALUE_NOT_SET:</a>
<a name="ln898">      LOG(FATAL) &lt;&lt; &quot;Internal error: value should not be null&quot;;</a>
<a name="ln899">      break;</a>
<a name="ln900"> </a>
<a name="ln901">    // default: fall through</a>
<a name="ln902">  }</a>
<a name="ln903"> </a>
<a name="ln904">  LOG(FATAL) &lt;&lt; &quot;Internal error: unknown or unsupported type &quot; &lt;&lt; lhs.value_case();</a>
<a name="ln905">  return 0;</a>
<a name="ln906">}</a>
<a name="ln907"> </a>
<a name="ln908">int Compare(const QLValuePB&amp; lhs, const QLValue&amp; rhs) {</a>
<a name="ln909">  CHECK(Comparable(lhs, rhs));</a>
<a name="ln910">  CHECK(BothNotNull(lhs, rhs));</a>
<a name="ln911">  switch (type(lhs)) {</a>
<a name="ln912">    case QLValuePB::kInt8Value:</a>
<a name="ln913">      return GenericCompare(static_cast&lt;int8_t&gt;(lhs.int8_value()), rhs.int8_value());</a>
<a name="ln914">    case QLValuePB::kInt16Value:</a>
<a name="ln915">      return GenericCompare(static_cast&lt;int16_t&gt;(lhs.int16_value()), rhs.int16_value());</a>
<a name="ln916">    case QLValuePB::kInt32Value:  return GenericCompare(lhs.int32_value(), rhs.int32_value());</a>
<a name="ln917">    case QLValuePB::kInt64Value:  return GenericCompare(lhs.int64_value(), rhs.int64_value());</a>
<a name="ln918">    case QLValuePB::kUint32Value:  return GenericCompare(lhs.uint32_value(), rhs.uint32_value());</a>
<a name="ln919">    case QLValuePB::kUint64Value:  return GenericCompare(lhs.uint64_value(), rhs.uint64_value());</a>
<a name="ln920">    case QLValuePB::kFloatValue:  {</a>
<a name="ln921">      bool is_nan_0 = util::IsNanFloat(lhs.float_value());</a>
<a name="ln922">      bool is_nan_1 = util::IsNanFloat(rhs.float_value());</a>
<a name="ln923">      if (is_nan_0 &amp;&amp; is_nan_1) return 0;</a>
<a name="ln924">      if (is_nan_0 &amp;&amp; !is_nan_1) return 1;</a>
<a name="ln925">      if (!is_nan_0 &amp;&amp; is_nan_1) return -1;</a>
<a name="ln926">      return GenericCompare(lhs.float_value(), rhs.float_value());</a>
<a name="ln927">    }</a>
<a name="ln928">    case QLValuePB::kDoubleValue: {</a>
<a name="ln929">      bool is_nan_0 = util::IsNanDouble(lhs.double_value());</a>
<a name="ln930">      bool is_nan_1 = util::IsNanDouble(rhs.double_value());</a>
<a name="ln931">      if (is_nan_0 &amp;&amp; is_nan_1) return 0;</a>
<a name="ln932">      if (is_nan_0 &amp;&amp; !is_nan_1) return 1;</a>
<a name="ln933">      if (!is_nan_0 &amp;&amp; is_nan_1) return -1;</a>
<a name="ln934">      return GenericCompare(lhs.double_value(), rhs.double_value());</a>
<a name="ln935">    }</a>
<a name="ln936">    // Encoded decimal is byte-comparable.</a>
<a name="ln937">    case QLValuePB::kDecimalValue: return lhs.decimal_value().compare(rhs.decimal_value());</a>
<a name="ln938">    case QLValuePB::kVarintValue: return lhs.varint_value().compare(rhs.value().varint_value());</a>
<a name="ln939">    case QLValuePB::kStringValue: return lhs.string_value().compare(rhs.string_value());</a>
<a name="ln940">    case QLValuePB::kBoolValue: return Compare(lhs.bool_value(), rhs.bool_value());</a>
<a name="ln941">    case QLValuePB::kTimestampValue:</a>
<a name="ln942">      return GenericCompare(lhs.timestamp_value(), rhs.timestamp_value_pb());</a>
<a name="ln943">    case QLValuePB::kDateValue: return GenericCompare(lhs.date_value(), rhs.date_value());</a>
<a name="ln944">    case QLValuePB::kTimeValue: return GenericCompare(lhs.time_value(), rhs.time_value());</a>
<a name="ln945">    case QLValuePB::kBinaryValue: return lhs.binary_value().compare(rhs.binary_value());</a>
<a name="ln946">    case QLValuePB::kInetaddressValue:</a>
<a name="ln947">      return GenericCompare(QLValue::inetaddress_value(lhs), rhs.inetaddress_value());</a>
<a name="ln948">    case QLValuePB::kJsonbValue:</a>
<a name="ln949">      return GenericCompare(QLValue::jsonb_value(lhs), rhs.jsonb_value());</a>
<a name="ln950">    case QLValuePB::kUuidValue:</a>
<a name="ln951">      return GenericCompare(QLValue::uuid_value(lhs), rhs.uuid_value());</a>
<a name="ln952">    case QLValuePB::kTimeuuidValue:</a>
<a name="ln953">      return GenericCompare(QLValue::timeuuid_value(lhs), rhs.timeuuid_value());</a>
<a name="ln954">    case QLValuePB::kFrozenValue:</a>
<a name="ln955">      return Compare(lhs.frozen_value(), rhs.frozen_value());</a>
<a name="ln956">    case QLValuePB::kMapValue: FALLTHROUGH_INTENDED;</a>
<a name="ln957">    case QLValuePB::kSetValue: FALLTHROUGH_INTENDED;</a>
<a name="ln958">    case QLValuePB::kListValue:</a>
<a name="ln959">      LOG(FATAL) &lt;&lt; &quot;Internal error: collection types are not comparable&quot;;</a>
<a name="ln960">      return 0;</a>
<a name="ln961">    case QLValuePB::VALUE_NOT_SET:</a>
<a name="ln962">      LOG(FATAL) &lt;&lt; &quot;Internal error: value should not be null&quot;;</a>
<a name="ln963">      break;</a>
<a name="ln964"> </a>
<a name="ln965">    // default: fall through</a>
<a name="ln966">  }</a>
<a name="ln967"> </a>
<a name="ln968">  FATAL_INVALID_ENUM_VALUE(QLValuePB::ValueCase, type(lhs));</a>
<a name="ln969">}</a>
<a name="ln970"> </a>
<a name="ln971">int Compare(const QLSeqValuePB&amp; lhs, const QLSeqValuePB&amp; rhs) {</a>
<a name="ln972">  // Compare elements one by one.</a>
<a name="ln973">  int result = 0;</a>
<a name="ln974">  int min_size = std::min(lhs.elems_size(), rhs.elems_size());</a>
<a name="ln975">  for (int i = 0; i &lt; min_size; i++) {</a>
<a name="ln976">    bool lhs_is_null = IsNull(lhs.elems(i));</a>
<a name="ln977">    bool rhs_is_null = IsNull(rhs.elems(i));</a>
<a name="ln978"> </a>
<a name="ln979">    if (lhs_is_null &amp;&amp; rhs_is_null) result = 0;</a>
<a name="ln980">    else if (lhs_is_null) result = -1;</a>
<a name="ln981">    else if (rhs_is_null) result = 1;</a>
<a name="ln982">    else</a>
<a name="ln983">      result = Compare(lhs.elems(i), rhs.elems(i));</a>
<a name="ln984"> </a>
<a name="ln985">    if (result != 0) {</a>
<a name="ln986">      return result;</a>
<a name="ln987">    }</a>
<a name="ln988">  }</a>
<a name="ln989"> </a>
<a name="ln990">  // If elements are equal, compare lengths.</a>
<a name="ln991">  return GenericCompare(lhs.elems_size(), rhs.elems_size());</a>
<a name="ln992">}</a>
<a name="ln993"> </a>
<a name="ln994">int Compare(const bool lhs, const bool rhs) {</a>
<a name="ln995">  // Using Cassandra semantics: true &gt; false.</a>
<a name="ln996">  if (lhs) {</a>
<a name="ln997">    return rhs ? 0 : 1;</a>
<a name="ln998">  } else {</a>
<a name="ln999">    return rhs ? -1 : 0;</a>
<a name="ln1000">  }</a>
<a name="ln1001">}</a>
<a name="ln1002"> </a>
<a name="ln1003">// In YCQL null is not comparable with regular values (w.r.t. ordering).</a>
<a name="ln1004">bool operator &lt;(const QLValuePB&amp; lhs, const QLValuePB&amp; rhs) {</a>
<a name="ln1005">  return BothNotNull(lhs, rhs) &amp;&amp; Compare(lhs, rhs) &lt; 0;</a>
<a name="ln1006">}</a>
<a name="ln1007">bool operator &gt;(const QLValuePB&amp; lhs, const QLValuePB&amp; rhs) {</a>
<a name="ln1008">  return BothNotNull(lhs, rhs) &amp;&amp; Compare(lhs, rhs) &gt; 0;</a>
<a name="ln1009">}</a>
<a name="ln1010"> </a>
<a name="ln1011">// In YCQL equality holds for null values.</a>
<a name="ln1012">bool operator &lt;=(const QLValuePB&amp; lhs, const QLValuePB&amp; rhs) {</a>
<a name="ln1013">  return (BothNotNull(lhs, rhs) &amp;&amp; Compare(lhs, rhs) &lt;= 0) || BothNull(lhs, rhs);</a>
<a name="ln1014">}</a>
<a name="ln1015">bool operator &gt;=(const QLValuePB&amp; lhs, const QLValuePB&amp; rhs) {</a>
<a name="ln1016">  return (BothNotNull(lhs, rhs) &amp;&amp; Compare(lhs, rhs) &gt;= 0) || BothNull(lhs, rhs);</a>
<a name="ln1017">}</a>
<a name="ln1018">bool operator ==(const QLValuePB&amp; lhs, const QLValuePB&amp; rhs) {</a>
<a name="ln1019">  return (BothNotNull(lhs, rhs) &amp;&amp; Compare(lhs, rhs) == 0) || BothNull(lhs, rhs);</a>
<a name="ln1020">}</a>
<a name="ln1021">bool operator !=(const QLValuePB&amp; lhs, const QLValuePB&amp; rhs) {</a>
<a name="ln1022">  return !(lhs == rhs);</a>
<a name="ln1023">}</a>
<a name="ln1024"> </a>
<a name="ln1025">// In YCQL null is not comparable with regular values (w.r.t. ordering).</a>
<a name="ln1026">bool operator &lt;(const QLValuePB&amp; lhs, const QLValue&amp; rhs) {</a>
<a name="ln1027">  return BothNotNull(lhs, rhs) &amp;&amp; Compare(lhs, rhs) &lt; 0;</a>
<a name="ln1028">}</a>
<a name="ln1029">bool operator &gt;(const QLValuePB&amp; lhs, const QLValue&amp; rhs) {</a>
<a name="ln1030">  return BothNotNull(lhs, rhs) &amp;&amp; Compare(lhs, rhs) &gt; 0;</a>
<a name="ln1031">}</a>
<a name="ln1032"> </a>
<a name="ln1033">// In YCQL equality holds for null values.</a>
<a name="ln1034">bool operator &lt;=(const QLValuePB&amp; lhs, const QLValue&amp; rhs) {</a>
<a name="ln1035">  return (BothNotNull(lhs, rhs) &amp;&amp; Compare(lhs, rhs) &lt;= 0) || BothNull(lhs, rhs);</a>
<a name="ln1036">}</a>
<a name="ln1037">bool operator &gt;=(const QLValuePB&amp; lhs, const QLValue&amp; rhs) {</a>
<a name="ln1038">  return (BothNotNull(lhs, rhs) &amp;&amp; Compare(lhs, rhs) &gt;= 0) || BothNull(lhs, rhs);</a>
<a name="ln1039">}</a>
<a name="ln1040">bool operator ==(const QLValuePB&amp; lhs, const QLValue&amp; rhs) {</a>
<a name="ln1041">  return (BothNotNull(lhs, rhs) &amp;&amp; Compare(lhs, rhs) == 0) || BothNull(lhs, rhs);</a>
<a name="ln1042">}</a>
<a name="ln1043">bool operator !=(const QLValuePB&amp; lhs, const QLValue&amp; rhs) {</a>
<a name="ln1044">  return !(lhs == rhs);</a>
<a name="ln1045">}</a>
<a name="ln1046"> </a>
<a name="ln1047">} // namespace yb</a>

</code></pre>
<div class="balloon" rel="73"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="74"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="312"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="319"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="325"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="332"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="333"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="847"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="848"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="909"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="910"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
