
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>schema.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Licensed to the Apache Software Foundation (ASF) under one</a>
<a name="ln2">// or more contributor license agreements.  See the NOTICE file</a>
<a name="ln3">// distributed with this work for additional information</a>
<a name="ln4">// regarding copyright ownership.  The ASF licenses this file</a>
<a name="ln5">// to you under the Apache License, Version 2.0 (the</a>
<a name="ln6">// &quot;License&quot;); you may not use this file except in compliance</a>
<a name="ln7">// with the License.  You may obtain a copy of the License at</a>
<a name="ln8">//</a>
<a name="ln9">//   http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln10">//</a>
<a name="ln11">// Unless required by applicable law or agreed to in writing,</a>
<a name="ln12">// software distributed under the License is distributed on an</a>
<a name="ln13">// &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</a>
<a name="ln14">// KIND, either express or implied.  See the License for the</a>
<a name="ln15">// specific language governing permissions and limitations</a>
<a name="ln16">// under the License.</a>
<a name="ln17">//</a>
<a name="ln18">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln19">//</a>
<a name="ln20">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln21">//</a>
<a name="ln22">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln23">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln24">//</a>
<a name="ln25">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln26">//</a>
<a name="ln27">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln28">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln29">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln30">// under the License.</a>
<a name="ln31">//</a>
<a name="ln32"> </a>
<a name="ln33">#include &quot;yb/common/schema.h&quot;</a>
<a name="ln34"> </a>
<a name="ln35">#include &lt;set&gt;</a>
<a name="ln36">#include &lt;algorithm&gt;</a>
<a name="ln37"> </a>
<a name="ln38">#include &quot;yb/gutil/stringprintf.h&quot;</a>
<a name="ln39">#include &quot;yb/gutil/strings/join.h&quot;</a>
<a name="ln40">#include &quot;yb/gutil/strings/strcat.h&quot;</a>
<a name="ln41">#include &quot;yb/util/malloc.h&quot;</a>
<a name="ln42">#include &quot;yb/util/status.h&quot;</a>
<a name="ln43">#include &quot;yb/common/row.h&quot;</a>
<a name="ln44"> </a>
<a name="ln45">namespace yb {</a>
<a name="ln46"> </a>
<a name="ln47">using std::shared_ptr;</a>
<a name="ln48">using std::set;</a>
<a name="ln49">using std::unordered_map;</a>
<a name="ln50">using std::unordered_set;</a>
<a name="ln51"> </a>
<a name="ln52">// ------------------------------------------------------------------------------------------------</a>
<a name="ln53">// ColumnSchema</a>
<a name="ln54">// ------------------------------------------------------------------------------------------------</a>
<a name="ln55"> </a>
<a name="ln56">// TODO: include attributes_.ToString() -- need to fix unit tests</a>
<a name="ln57">// first</a>
<a name="ln58">string ColumnSchema::ToString() const {</a>
<a name="ln59">  return strings::Substitute(&quot;$0[$1]&quot;,</a>
<a name="ln60">                             name_,</a>
<a name="ln61">                             TypeToString());</a>
<a name="ln62">}</a>
<a name="ln63"> </a>
<a name="ln64">string ColumnSchema::TypeToString() const {</a>
<a name="ln65">  return strings::Substitute(&quot;$0 $1 $2&quot;,</a>
<a name="ln66">                             type_info()-&gt;name(),</a>
<a name="ln67">                             is_nullable_ ? &quot;NULLABLE&quot; : &quot;NOT NULL&quot;,</a>
<a name="ln68">                             is_hash_key_ ? &quot;PARTITION KEY&quot; : &quot;NOT A PARTITION KEY&quot;);</a>
<a name="ln69">}</a>
<a name="ln70"> </a>
<a name="ln71">size_t ColumnSchema::memory_footprint_excluding_this() const {</a>
<a name="ln72">  // Rough approximation.</a>
<a name="ln73">  return name_.capacity();</a>
<a name="ln74">}</a>
<a name="ln75"> </a>
<a name="ln76">size_t ColumnSchema::memory_footprint_including_this() const {</a>
<a name="ln77">  return malloc_usable_size(this) + memory_footprint_excluding_this();</a>
<a name="ln78">}</a>
<a name="ln79"> </a>
<a name="ln80">// ------------------------------------------------------------------------------------------------</a>
<a name="ln81">// TableProperties</a>
<a name="ln82">// ------------------------------------------------------------------------------------------------</a>
<a name="ln83"> </a>
<a name="ln84">void TableProperties::ToTablePropertiesPB(TablePropertiesPB *pb) const {</a>
<a name="ln85">  if (HasDefaultTimeToLive()) {</a>
<a name="ln86">    pb-&gt;set_default_time_to_live(default_time_to_live_);</a>
<a name="ln87">  }</a>
<a name="ln88">  pb-&gt;set_contain_counters(contain_counters_);</a>
<a name="ln89">  pb-&gt;set_is_transactional(is_transactional_);</a>
<a name="ln90">  pb-&gt;set_consistency_level(consistency_level_);</a>
<a name="ln91">  if (HasCopartitionTableId()) {</a>
<a name="ln92">    pb-&gt;set_copartition_table_id(copartition_table_id_);</a>
<a name="ln93">  }</a>
<a name="ln94">  pb-&gt;set_use_mangled_column_name(use_mangled_column_name_);</a>
<a name="ln95">  if (HasNumTablets()) {</a>
<a name="ln96">    pb-&gt;set_num_tablets(num_tablets_);</a>
<a name="ln97">  }</a>
<a name="ln98">  pb-&gt;set_is_ysql_catalog_table(is_ysql_catalog_table_);</a>
<a name="ln99">  pb-&gt;set_is_backfilling(is_backfilling_);</a>
<a name="ln100">}</a>
<a name="ln101"> </a>
<a name="ln102">TableProperties TableProperties::FromTablePropertiesPB(const TablePropertiesPB&amp; pb) {</a>
<a name="ln103">  TableProperties table_properties;</a>
<a name="ln104">  if (pb.has_default_time_to_live()) {</a>
<a name="ln105">    table_properties.SetDefaultTimeToLive(pb.default_time_to_live());</a>
<a name="ln106">  }</a>
<a name="ln107">  if (pb.has_contain_counters()) {</a>
<a name="ln108">    table_properties.SetContainCounters(pb.contain_counters());</a>
<a name="ln109">  }</a>
<a name="ln110">  if (pb.has_is_transactional()) {</a>
<a name="ln111">    table_properties.SetTransactional(pb.is_transactional());</a>
<a name="ln112">  }</a>
<a name="ln113">  if (pb.has_consistency_level()) {</a>
<a name="ln114">    table_properties.SetConsistencyLevel(pb.consistency_level());</a>
<a name="ln115">  }</a>
<a name="ln116">  if (pb.has_copartition_table_id()) {</a>
<a name="ln117">    table_properties.SetCopartitionTableId(pb.copartition_table_id());</a>
<a name="ln118">  }</a>
<a name="ln119">  if (pb.has_use_mangled_column_name()) {</a>
<a name="ln120">    table_properties.SetUseMangledColumnName(pb.use_mangled_column_name());</a>
<a name="ln121">  }</a>
<a name="ln122">  if (pb.has_num_tablets()) {</a>
<a name="ln123">    table_properties.SetNumTablets(pb.num_tablets());</a>
<a name="ln124">  }</a>
<a name="ln125">  if (pb.has_is_ysql_catalog_table()) {</a>
<a name="ln126">    table_properties.set_is_ysql_catalog_table(pb.is_ysql_catalog_table());</a>
<a name="ln127">  }</a>
<a name="ln128">  if (pb.has_is_backfilling()) {</a>
<a name="ln129">    table_properties.SetIsBackfilling(pb.is_backfilling());</a>
<a name="ln130">  }</a>
<a name="ln131">  return table_properties;</a>
<a name="ln132">}</a>
<a name="ln133"> </a>
<a name="ln134">void TableProperties::AlterFromTablePropertiesPB(const TablePropertiesPB&amp; pb) {</a>
<a name="ln135">  if (pb.has_default_time_to_live()) {</a>
<a name="ln136">    SetDefaultTimeToLive(pb.default_time_to_live());</a>
<a name="ln137">  }</a>
<a name="ln138">  if (pb.has_is_transactional()) {</a>
<a name="ln139">    SetTransactional(pb.is_transactional());</a>
<a name="ln140">  }</a>
<a name="ln141">  if (pb.has_consistency_level()) {</a>
<a name="ln142">    SetConsistencyLevel(pb.consistency_level());</a>
<a name="ln143">  }</a>
<a name="ln144">  if (pb.has_copartition_table_id()) {</a>
<a name="ln145">    SetCopartitionTableId(pb.copartition_table_id());</a>
<a name="ln146">  }</a>
<a name="ln147">  if (pb.has_use_mangled_column_name()) {</a>
<a name="ln148">    SetUseMangledColumnName(pb.use_mangled_column_name());</a>
<a name="ln149">  }</a>
<a name="ln150">  if (pb.has_num_tablets()) {</a>
<a name="ln151">    SetNumTablets(pb.num_tablets());</a>
<a name="ln152">  }</a>
<a name="ln153">  if (pb.has_is_ysql_catalog_table()) {</a>
<a name="ln154">    set_is_ysql_catalog_table(pb.is_ysql_catalog_table());</a>
<a name="ln155">  }</a>
<a name="ln156">  if (pb.has_is_backfilling()) {</a>
<a name="ln157">    SetIsBackfilling(pb.is_backfilling());</a>
<a name="ln158">  }</a>
<a name="ln159">}</a>
<a name="ln160"> </a>
<a name="ln161">void TableProperties::Reset() {</a>
<a name="ln162">  default_time_to_live_ = kNoDefaultTtl;</a>
<a name="ln163">  contain_counters_ = false;</a>
<a name="ln164">  is_transactional_ = false;</a>
<a name="ln165">  consistency_level_ = YBConsistencyLevel::STRONG;</a>
<a name="ln166">  copartition_table_id_ = kNoCopartitionTableId;</a>
<a name="ln167">  use_mangled_column_name_ = false;</a>
<a name="ln168">  num_tablets_ = 0;</a>
<a name="ln169">  is_ysql_catalog_table_ = false;</a>
<a name="ln170">  is_backfilling_ = false;</a>
<a name="ln171">}</a>
<a name="ln172"> </a>
<a name="ln173">string TableProperties::ToString() const {</a>
<a name="ln174">  std::string result(&quot;{ &quot;);</a>
<a name="ln175">  if (HasDefaultTimeToLive()) {</a>
<a name="ln176">    result += Format(&quot;default_time_to_live: $0 &quot;, default_time_to_live_);</a>
<a name="ln177">  }</a>
<a name="ln178">  result += Format(&quot;contain_counters: $0 is_transactional: $1 &quot;,</a>
<a name="ln179">                   contain_counters_, is_transactional_);</a>
<a name="ln180">  if (HasCopartitionTableId()) {</a>
<a name="ln181">    result += Format(&quot;copartition_table_id: $0 &quot;, copartition_table_id_);</a>
<a name="ln182">  }</a>
<a name="ln183">  return result + Format(</a>
<a name="ln184">      &quot;consistency_level: $0 is_ysql_catalog_table: $1 }&quot;,</a>
<a name="ln185">      consistency_level_,</a>
<a name="ln186">      is_ysql_catalog_table_);</a>
<a name="ln187">}</a>
<a name="ln188"> </a>
<a name="ln189">// ------------------------------------------------------------------------------------------------</a>
<a name="ln190">// Schema</a>
<a name="ln191">// ------------------------------------------------------------------------------------------------</a>
<a name="ln192"> </a>
<a name="ln193">Schema::Schema(const Schema&amp; other)</a>
<a name="ln194">  : name_to_index_bytes_(0),</a>
<a name="ln195">    // TODO: C++11 provides a single-arg constructor</a>
<a name="ln196">    name_to_index_(10,</a>
<a name="ln197">                   NameToIndexMap::hasher(),</a>
<a name="ln198">                   NameToIndexMap::key_equal(),</a>
<a name="ln199">                   NameToIndexMapAllocator(&amp;name_to_index_bytes_)) {</a>
<a name="ln200">  CopyFrom(other);</a>
<a name="ln201">}</a>
<a name="ln202"> </a>
<a name="ln203">Schema&amp; Schema::operator=(const Schema&amp; other) {</a>
<a name="ln204">  if (&amp;other != this) {</a>
<a name="ln205">    CopyFrom(other);</a>
<a name="ln206">  }</a>
<a name="ln207">  return *this;</a>
<a name="ln208">}</a>
<a name="ln209"> </a>
<a name="ln210">void Schema::CopyFrom(const Schema&amp; other) {</a>
<a name="ln211">  num_key_columns_ = other.num_key_columns_;</a>
<a name="ln212">  num_hash_key_columns_ = other.num_hash_key_columns_;</a>
<a name="ln213">  cols_ = other.cols_;</a>
<a name="ln214">  col_ids_ = other.col_ids_;</a>
<a name="ln215">  col_offsets_ = other.col_offsets_;</a>
<a name="ln216">  id_to_index_ = other.id_to_index_;</a>
<a name="ln217"> </a>
<a name="ln218">  // We can't simply copy name_to_index_ since the GStringPiece keys</a>
<a name="ln219">  // reference the other Schema's ColumnSchema objects.</a>
<a name="ln220">  name_to_index_.clear();</a>
<a name="ln221">  int i = 0;</a>
<a name="ln222">  for (const ColumnSchema &amp;col : cols_) {</a>
<a name="ln223">    // The map uses the 'name' string from within the ColumnSchema object.</a>
<a name="ln224">    name_to_index_[col.name()] = i++;</a>
<a name="ln225">  }</a>
<a name="ln226"> </a>
<a name="ln227">  has_nullables_ = other.has_nullables_;</a>
<a name="ln228">  has_statics_ = other.has_statics_;</a>
<a name="ln229">  table_properties_ = other.table_properties_;</a>
<a name="ln230">  cotable_id_ = other.cotable_id_;</a>
<a name="ln231">  pgtable_id_ = other.pgtable_id_;</a>
<a name="ln232"> </a>
<a name="ln233">  // Schema cannot have both, cotable ID and pgtable ID.</a>
<a name="ln234">  DCHECK(cotable_id_.IsNil() || pgtable_id_ == 0);</a>
<a name="ln235">}</a>
<a name="ln236"> </a>
<a name="ln237">void Schema::swap(Schema&amp; other) {</a>
<a name="ln238">  std::swap(num_key_columns_, other.num_key_columns_);</a>
<a name="ln239">  std::swap(num_hash_key_columns_, other.num_hash_key_columns_);</a>
<a name="ln240">  cols_.swap(other.cols_);</a>
<a name="ln241">  col_ids_.swap(other.col_ids_);</a>
<a name="ln242">  col_offsets_.swap(other.col_offsets_);</a>
<a name="ln243">  name_to_index_.swap(other.name_to_index_);</a>
<a name="ln244">  id_to_index_.swap(other.id_to_index_);</a>
<a name="ln245">  std::swap(has_nullables_, other.has_nullables_);</a>
<a name="ln246">  std::swap(has_statics_, other.has_statics_);</a>
<a name="ln247">  std::swap(table_properties_, other.table_properties_);</a>
<a name="ln248">  std::swap(cotable_id_, other.cotable_id_);</a>
<a name="ln249">  std::swap(pgtable_id_, other.pgtable_id_);</a>
<a name="ln250"> </a>
<a name="ln251">  // Schema cannot have both, cotable ID or pgtable ID.</a>
<a name="ln252">  DCHECK(cotable_id_.IsNil() || pgtable_id_ == 0);</a>
<a name="ln253">}</a>
<a name="ln254"> </a>
<a name="ln255">Status Schema::Reset(const vector&lt;ColumnSchema&gt;&amp; cols,</a>
<a name="ln256">                     const vector&lt;ColumnId&gt;&amp; ids,</a>
<a name="ln257">                     int key_columns,</a>
<a name="ln258">                     const TableProperties&amp; table_properties,</a>
<a name="ln259">                     const Uuid&amp; cotable_id,</a>
<a name="ln260">                     const PgTableOid pgtable_id) {</a>
<a name="ln261">  cols_ = cols;</a>
<a name="ln262">  num_key_columns_ = key_columns;</a>
<a name="ln263">  num_hash_key_columns_ = 0;</a>
<a name="ln264">  table_properties_ = table_properties;</a>
<a name="ln265">  cotable_id_ = cotable_id;</a>
<a name="ln266">  pgtable_id_ = pgtable_id;</a>
<a name="ln267"> </a>
<a name="ln268">  // Determine whether any column is nullable or static, and count number of hash columns.</a>
<a name="ln269">  has_nullables_ = false;</a>
<a name="ln270">  has_statics_ = false;</a>
<a name="ln271">  for (const ColumnSchema&amp; col : cols_) {</a>
<a name="ln272">    if (col.is_hash_key()) {</a>
<a name="ln273">      num_hash_key_columns_++;</a>
<a name="ln274">    }</a>
<a name="ln275">    if (col.is_nullable()) {</a>
<a name="ln276">      has_nullables_ = true;</a>
<a name="ln277">    }</a>
<a name="ln278">    if (col.is_static()) {</a>
<a name="ln279">      has_statics_ = true;</a>
<a name="ln280">    }</a>
<a name="ln281">  }</a>
<a name="ln282"> </a>
<a name="ln283">  if (PREDICT_FALSE(key_columns &gt; cols_.size())) {</a>
<a name="ln284">    return STATUS(InvalidArgument,</a>
<a name="ln285">      &quot;Bad schema&quot;, &quot;More key columns than columns&quot;);</a>
<a name="ln286">  }</a>
<a name="ln287"> </a>
<a name="ln288">  if (PREDICT_FALSE(key_columns &lt; 0)) {</a>
<a name="ln289">    return STATUS(InvalidArgument,</a>
<a name="ln290">      &quot;Bad schema&quot;, &quot;Cannot specify a negative number of key columns&quot;);</a>
<a name="ln291">  }</a>
<a name="ln292"> </a>
<a name="ln293">  if (PREDICT_FALSE(!ids.empty() &amp;&amp; ids.size() != cols_.size())) {</a>
<a name="ln294">    return STATUS(InvalidArgument, &quot;Bad schema&quot;,</a>
<a name="ln295">      &quot;The number of ids does not match with the number of columns&quot;);</a>
<a name="ln296">  }</a>
<a name="ln297"> </a>
<a name="ln298">  if (PREDICT_FALSE(!cotable_id.IsNil() &amp;&amp; pgtable_id &gt; 0)) {</a>
<a name="ln299">    return STATUS(InvalidArgument,</a>
<a name="ln300">                  &quot;Bad schema&quot;, &quot;Cannot have both cotable ID and pgtable ID&quot;);</a>
<a name="ln301">  }</a>
<a name="ln302"> </a>
<a name="ln303">  // Verify that the key columns are not nullable nor static</a>
<a name="ln304">  for (int i = 0; i &lt; key_columns; ++i) {</a>
<a name="ln305">    if (PREDICT_FALSE(cols_[i].is_nullable())) {</a>
<a name="ln306">      return STATUS(InvalidArgument,</a>
<a name="ln307">        &quot;Bad schema&quot;, strings::Substitute(&quot;Nullable key columns are not &quot;</a>
<a name="ln308">                                          &quot;supported: $0&quot;, cols_[i].name()));</a>
<a name="ln309">    }</a>
<a name="ln310">    if (PREDICT_FALSE(cols_[i].is_static())) {</a>
<a name="ln311">      return STATUS(InvalidArgument,</a>
<a name="ln312">        &quot;Bad schema&quot;, strings::Substitute(&quot;Static key columns are not &quot;</a>
<a name="ln313">                                          &quot;allowed: $0&quot;, cols_[i].name()));</a>
<a name="ln314">    }</a>
<a name="ln315">    if (PREDICT_FALSE(cols_[i].is_counter())) {</a>
<a name="ln316">      return STATUS(InvalidArgument,</a>
<a name="ln317">        &quot;Bad schema&quot;, strings::Substitute(&quot;Counter key columns are not allowed: $0&quot;,</a>
<a name="ln318">                                          cols_[i].name()));</a>
<a name="ln319">    }</a>
<a name="ln320">  }</a>
<a name="ln321"> </a>
<a name="ln322">  // Calculate the offset of each column in the row format.</a>
<a name="ln323">  col_offsets_.reserve(cols_.size() + 1);  // Include space for total byte size at the end.</a>
<a name="ln324">  size_t off = 0;</a>
<a name="ln325">  size_t i = 0;</a>
<a name="ln326">  name_to_index_.clear();</a>
<a name="ln327">  for (const ColumnSchema &amp;col : cols_) {</a>
<a name="ln328">    // The map uses the 'name' string from within the ColumnSchema object.</a>
<a name="ln329">    if (!InsertIfNotPresent(&amp;name_to_index_, col.name(), i++)) {</a>
<a name="ln330">      return STATUS(InvalidArgument, &quot;Duplicate column name&quot;, col.name());</a>
<a name="ln331">    }</a>
<a name="ln332"> </a>
<a name="ln333">    col_offsets_.push_back(off);</a>
<a name="ln334">    off += col.type_info()-&gt;size();</a>
<a name="ln335">  }</a>
<a name="ln336"> </a>
<a name="ln337">  // Add an extra element on the end for the total</a>
<a name="ln338">  // byte size</a>
<a name="ln339">  col_offsets_.push_back(off);</a>
<a name="ln340"> </a>
<a name="ln341">  // Initialize IDs mapping</a>
<a name="ln342">  col_ids_ = ids;</a>
<a name="ln343">  id_to_index_.clear();</a>
<a name="ln344">  max_col_id_ = 0;</a>
<a name="ln345">  for (int i = 0; i &lt; ids.size(); ++i) {</a>
<a name="ln346">    if (ids[i] &gt; max_col_id_) {</a>
<a name="ln347">      max_col_id_ = ids[i];</a>
<a name="ln348">    }</a>
<a name="ln349">    id_to_index_.set(ids[i], i);</a>
<a name="ln350">  }</a>
<a name="ln351"> </a>
<a name="ln352">  // Ensure clustering columns have a default sorting type of 'ASC' if not specified.</a>
<a name="ln353">  for (int i = num_hash_key_columns_; i &lt; num_key_columns(); i++) {</a>
<a name="ln354">    ColumnSchema&amp; col = cols_[i];</a>
<a name="ln355">    if (col.sorting_type() == ColumnSchema::SortingType::kNotSpecified) {</a>
<a name="ln356">      col.set_sorting_type(ColumnSchema::SortingType::kAscending);</a>
<a name="ln357">    }</a>
<a name="ln358">  }</a>
<a name="ln359"> </a>
<a name="ln360">  return Status::OK();</a>
<a name="ln361">}</a>
<a name="ln362"> </a>
<a name="ln363">Status Schema::CreateProjectionByNames(const std::vector&lt;GStringPiece&gt;&amp; col_names,</a>
<a name="ln364">                                       Schema* out, size_t num_key_columns) const {</a>
<a name="ln365">  vector&lt;ColumnId&gt; ids;</a>
<a name="ln366">  vector&lt;ColumnSchema&gt; cols;</a>
<a name="ln367">  for (const GStringPiece&amp; name : col_names) {</a>
<a name="ln368">    int idx = find_column(name);</a>
<a name="ln369">    if (idx == -1) {</a>
<a name="ln370">      return STATUS(NotFound, &quot;column not found&quot;, name);</a>
<a name="ln371">    }</a>
<a name="ln372">    if (has_column_ids()) {</a>
<a name="ln373">      ids.push_back(column_id(idx));</a>
<a name="ln374">    }</a>
<a name="ln375">    cols.push_back(column(idx));</a>
<a name="ln376">  }</a>
<a name="ln377">  return out-&gt;Reset(cols, ids, num_key_columns, TableProperties(), cotable_id_, pgtable_id_);</a>
<a name="ln378">}</a>
<a name="ln379"> </a>
<a name="ln380">Status Schema::CreateProjectionByIdsIgnoreMissing(const std::vector&lt;ColumnId&gt;&amp; col_ids,</a>
<a name="ln381">                                                  Schema* out) const {</a>
<a name="ln382">  vector&lt;ColumnSchema&gt; cols;</a>
<a name="ln383">  vector&lt;ColumnId&gt; filtered_col_ids;</a>
<a name="ln384">  for (ColumnId id : col_ids) {</a>
<a name="ln385">    int idx = find_column_by_id(id);</a>
<a name="ln386">    if (idx == -1) {</a>
<a name="ln387">      continue;</a>
<a name="ln388">    }</a>
<a name="ln389">    cols.push_back(column(idx));</a>
<a name="ln390">    filtered_col_ids.push_back(id);</a>
<a name="ln391">  }</a>
<a name="ln392">  return out-&gt;Reset(cols, filtered_col_ids, 0, TableProperties(), cotable_id_, pgtable_id_);</a>
<a name="ln393">}</a>
<a name="ln394"> </a>
<a name="ln395">Schema Schema::CopyWithColumnIds() const {</a>
<a name="ln396">  CHECK(!has_column_ids());</a>
<a name="ln397">  vector&lt;ColumnId&gt; ids;</a>
<a name="ln398">  for (int32_t i = 0; i &lt; num_columns(); i++) {</a>
<a name="ln399">    ids.push_back(ColumnId(kFirstColumnId + i));</a>
<a name="ln400">  }</a>
<a name="ln401">  return Schema(cols_, ids, num_key_columns_, table_properties_, cotable_id_, pgtable_id_);</a>
<a name="ln402">}</a>
<a name="ln403"> </a>
<a name="ln404">Schema Schema::CopyWithoutColumnIds() const {</a>
<a name="ln405">  CHECK(has_column_ids());</a>
<a name="ln406">  return Schema(cols_, num_key_columns_, table_properties_, cotable_id_, pgtable_id_);</a>
<a name="ln407">}</a>
<a name="ln408"> </a>
<a name="ln409">Status Schema::VerifyProjectionCompatibility(const Schema&amp; projection) const {</a>
<a name="ln410">  DCHECK(has_column_ids()) &lt;&lt; &quot;The server schema must have IDs&quot;;</a>
<a name="ln411"> </a>
<a name="ln412">  if (projection.has_column_ids()) {</a>
<a name="ln413">    return STATUS(InvalidArgument, &quot;User requests should not have Column IDs&quot;);</a>
<a name="ln414">  }</a>
<a name="ln415"> </a>
<a name="ln416">  vector&lt;string&gt; missing_columns;</a>
<a name="ln417">  for (const ColumnSchema&amp; pcol : projection.columns()) {</a>
<a name="ln418">    int index = find_column(pcol.name());</a>
<a name="ln419">    if (index &lt; 0) {</a>
<a name="ln420">      missing_columns.push_back(pcol.name());</a>
<a name="ln421">    } else if (!pcol.EqualsType(cols_[index])) {</a>
<a name="ln422">      // TODO: We don't support query with type adaptors yet</a>
<a name="ln423">      return STATUS(InvalidArgument, &quot;The column '&quot; + pcol.name() + &quot;' must have type &quot; +</a>
<a name="ln424">                                     cols_[index].TypeToString() + &quot; found &quot; + pcol.TypeToString());</a>
<a name="ln425">    }</a>
<a name="ln426">  }</a>
<a name="ln427"> </a>
<a name="ln428">  if (!missing_columns.empty()) {</a>
<a name="ln429">    return STATUS(InvalidArgument, &quot;Some columns are not present in the current schema&quot;,</a>
<a name="ln430">                                   JoinStrings(missing_columns, &quot;, &quot;));</a>
<a name="ln431">  }</a>
<a name="ln432">  return Status::OK();</a>
<a name="ln433">}</a>
<a name="ln434"> </a>
<a name="ln435">Status Schema::GetMappedReadProjection(const Schema&amp; projection,</a>
<a name="ln436">                                       Schema *mapped_projection) const {</a>
<a name="ln437">  // - The user projection may have different columns from the ones on the tablet</a>
<a name="ln438">  // - User columns non present in the tablet are considered errors</a>
<a name="ln439">  // - The user projection is not supposed to have the defaults or the nullable</a>
<a name="ln440">  //   information on each field. The current tablet schema is supposed to.</a>
<a name="ln441">  RETURN_NOT_OK(VerifyProjectionCompatibility(projection));</a>
<a name="ln442"> </a>
<a name="ln443">  // Get the Projection Mapping</a>
<a name="ln444">  vector&lt;ColumnSchema&gt; mapped_cols;</a>
<a name="ln445">  vector&lt;ColumnId&gt; mapped_ids;</a>
<a name="ln446"> </a>
<a name="ln447">  mapped_cols.reserve(projection.num_columns());</a>
<a name="ln448">  mapped_ids.reserve(projection.num_columns());</a>
<a name="ln449"> </a>
<a name="ln450">  for (const ColumnSchema&amp; col : projection.columns()) {</a>
<a name="ln451">    int index = find_column(col.name());</a>
<a name="ln452">    DCHECK_GE(index, 0) &lt;&lt; col.name();</a>
<a name="ln453">    mapped_cols.push_back(cols_[index]);</a>
<a name="ln454">    mapped_ids.push_back(col_ids_[index]);</a>
<a name="ln455">  }</a>
<a name="ln456"> </a>
<a name="ln457">  CHECK_OK(mapped_projection-&gt;Reset(mapped_cols, mapped_ids, projection.num_key_columns()));</a>
<a name="ln458">  return Status::OK();</a>
<a name="ln459">}</a>
<a name="ln460"> </a>
<a name="ln461">string Schema::ToString() const {</a>
<a name="ln462">  vector&lt;string&gt; col_strs;</a>
<a name="ln463">  if (has_column_ids()) {</a>
<a name="ln464">    for (int i = 0; i &lt; cols_.size(); ++i) {</a>
<a name="ln465">      col_strs.push_back(strings::Substitute(&quot;$0:$1&quot;, col_ids_[i], cols_[i].ToString()));</a>
<a name="ln466">    }</a>
<a name="ln467">  } else {</a>
<a name="ln468">    for (const ColumnSchema &amp;col : cols_) {</a>
<a name="ln469">      col_strs.push_back(col.ToString());</a>
<a name="ln470">    }</a>
<a name="ln471">  }</a>
<a name="ln472"> </a>
<a name="ln473">  TablePropertiesPB tablet_properties_pb;</a>
<a name="ln474">  table_properties_.ToTablePropertiesPB(&amp;tablet_properties_pb);</a>
<a name="ln475"> </a>
<a name="ln476">  return StrCat(&quot;Schema [\n\t&quot;,</a>
<a name="ln477">                JoinStrings(col_strs, &quot;,\n\t&quot;),</a>
<a name="ln478">                &quot;\n]\nproperties: &quot;,</a>
<a name="ln479">                tablet_properties_pb.ShortDebugString(),</a>
<a name="ln480">                cotable_id_.IsNil() ? &quot;&quot; : (&quot;\ncotable_id: &quot; + cotable_id_.ToString()),</a>
<a name="ln481">                pgtable_id_ == 0 ? &quot;&quot; : (&quot;\npgtable_id: &quot; + std::to_string(pgtable_id_)));</a>
<a name="ln482">}</a>
<a name="ln483"> </a>
<a name="ln484">Status Schema::DecodeRowKey(Slice encoded_key,</a>
<a name="ln485">                            uint8_t* buffer,</a>
<a name="ln486">                            Arena* arena) const {</a>
<a name="ln487">  ContiguousRow row(this, buffer);</a>
<a name="ln488"> </a>
<a name="ln489">  for (size_t col_idx = 0; col_idx &lt; num_key_columns(); ++col_idx) {</a>
<a name="ln490">    const ColumnSchema&amp; col = column(col_idx);</a>
<a name="ln491">    const KeyEncoder&lt;faststring&gt;&amp; key_encoder = GetKeyEncoder&lt;faststring&gt;(col.type_info());</a>
<a name="ln492">    bool is_last = col_idx == (num_key_columns() - 1);</a>
<a name="ln493">    RETURN_NOT_OK_PREPEND(key_encoder.Decode(&amp;encoded_key,</a>
<a name="ln494">                                             is_last,</a>
<a name="ln495">                                             arena,</a>
<a name="ln496">                                             row.mutable_cell_ptr(col_idx)),</a>
<a name="ln497">                          strings::Substitute(&quot;Error decoding composite key component '$0'&quot;,</a>
<a name="ln498">                                              col.name()));</a>
<a name="ln499">  }</a>
<a name="ln500">  return Status::OK();</a>
<a name="ln501">}</a>
<a name="ln502"> </a>
<a name="ln503">string Schema::DebugEncodedRowKey(Slice encoded_key, StartOrEnd start_or_end) const {</a>
<a name="ln504">  if (encoded_key.empty()) {</a>
<a name="ln505">    switch (start_or_end) {</a>
<a name="ln506">      case START_KEY: return &quot;&lt;start of table&gt;&quot;;</a>
<a name="ln507">      case END_KEY:   return &quot;&lt;end of table&gt;&quot;;</a>
<a name="ln508">    }</a>
<a name="ln509">  }</a>
<a name="ln510"> </a>
<a name="ln511">  Arena arena(1024, 128 * 1024);</a>
<a name="ln512">  uint8_t* buf = reinterpret_cast&lt;uint8_t*&gt;(arena.AllocateBytes(key_byte_size()));</a>
<a name="ln513">  Status s = DecodeRowKey(encoded_key, buf, &amp;arena);</a>
<a name="ln514">  if (!s.ok()) {</a>
<a name="ln515">    return &quot;&lt;invalid key: &quot; + s.ToString(/* no file/line */ false) + &quot;&gt;&quot;;</a>
<a name="ln516">  }</a>
<a name="ln517">  ConstContiguousRow row(this, buf);</a>
<a name="ln518">  return DebugRowKey(row);</a>
<a name="ln519">}</a>
<a name="ln520"> </a>
<a name="ln521">size_t Schema::memory_footprint_excluding_this() const {</a>
<a name="ln522">  size_t size = 0;</a>
<a name="ln523">  for (const ColumnSchema&amp; col : cols_) {</a>
<a name="ln524">    size += col.memory_footprint_excluding_this();</a>
<a name="ln525">  }</a>
<a name="ln526"> </a>
<a name="ln527">  if (cols_.capacity() &gt; 0) {</a>
<a name="ln528">    size += malloc_usable_size(cols_.data());</a>
<a name="ln529">  }</a>
<a name="ln530">  if (col_ids_.capacity() &gt; 0) {</a>
<a name="ln531">    size += malloc_usable_size(col_ids_.data());</a>
<a name="ln532">  }</a>
<a name="ln533">  if (col_offsets_.capacity() &gt; 0) {</a>
<a name="ln534">    size += malloc_usable_size(col_offsets_.data());</a>
<a name="ln535">  }</a>
<a name="ln536">  size += name_to_index_bytes_;</a>
<a name="ln537">  size += id_to_index_.memory_footprint_excluding_this();</a>
<a name="ln538"> </a>
<a name="ln539">  return size;</a>
<a name="ln540">}</a>
<a name="ln541"> </a>
<a name="ln542">size_t Schema::memory_footprint_including_this() const {</a>
<a name="ln543">  return malloc_usable_size(this) + memory_footprint_excluding_this();</a>
<a name="ln544">}</a>
<a name="ln545"> </a>
<a name="ln546">Result&lt;int&gt; Schema::ColumnIndexByName(GStringPiece col_name) const {</a>
<a name="ln547">  auto index = find_column(col_name);</a>
<a name="ln548">  if (index == kColumnNotFound) {</a>
<a name="ln549">    return STATUS_FORMAT(Corruption, &quot;$0 not found in schema $1&quot;, col_name, name_to_index_);</a>
<a name="ln550">  }</a>
<a name="ln551">  return index;</a>
<a name="ln552">}</a>
<a name="ln553"> </a>
<a name="ln554">Result&lt;ColumnId&gt; Schema::ColumnIdByName(const std::string&amp; column_name) const {</a>
<a name="ln555">  size_t column_index = find_column(column_name);</a>
<a name="ln556">  if (column_index == Schema::kColumnNotFound) {</a>
<a name="ln557">    return STATUS_FORMAT(NotFound, &quot;Couldn't find column $0 in the schema&quot;, column_name);</a>
<a name="ln558">  }</a>
<a name="ln559">  return ColumnId(column_id(column_index));</a>
<a name="ln560">}</a>
<a name="ln561"> </a>
<a name="ln562">ColumnId Schema::first_column_id() {</a>
<a name="ln563">  return kFirstColumnId;</a>
<a name="ln564">}</a>
<a name="ln565"> </a>
<a name="ln566">// ============================================================================</a>
<a name="ln567">//  Schema Builder</a>
<a name="ln568">// ============================================================================</a>
<a name="ln569">void SchemaBuilder::Reset() {</a>
<a name="ln570">  cols_.clear();</a>
<a name="ln571">  col_ids_.clear();</a>
<a name="ln572">  col_names_.clear();</a>
<a name="ln573">  num_key_columns_ = 0;</a>
<a name="ln574">  next_id_ = kFirstColumnId;</a>
<a name="ln575">  table_properties_.Reset();</a>
<a name="ln576">  pgtable_id_ = 0;</a>
<a name="ln577">  cotable_id_ = Uuid(boost::uuids::nil_uuid());</a>
<a name="ln578">}</a>
<a name="ln579"> </a>
<a name="ln580">void SchemaBuilder::Reset(const Schema&amp; schema) {</a>
<a name="ln581">  cols_ = schema.cols_;</a>
<a name="ln582">  col_ids_ = schema.col_ids_;</a>
<a name="ln583">  num_key_columns_ = schema.num_key_columns_;</a>
<a name="ln584">  for (const auto&amp; column : cols_) {</a>
<a name="ln585">    col_names_.insert(column.name());</a>
<a name="ln586">  }</a>
<a name="ln587"> </a>
<a name="ln588">  if (col_ids_.empty()) {</a>
<a name="ln589">    for (int32_t i = 0; i &lt; cols_.size(); ++i) {</a>
<a name="ln590">      col_ids_.push_back(ColumnId(kFirstColumnId + i));</a>
<a name="ln591">    }</a>
<a name="ln592">  }</a>
<a name="ln593">  if (col_ids_.empty()) {</a>
<a name="ln594">    next_id_ = kFirstColumnId;</a>
<a name="ln595">  } else {</a>
<a name="ln596">    next_id_ = *std::max_element(col_ids_.begin(), col_ids_.end()) + 1;</a>
<a name="ln597">  }</a>
<a name="ln598">  table_properties_ = schema.table_properties_;</a>
<a name="ln599">  pgtable_id_ = schema.pgtable_id_;</a>
<a name="ln600">  cotable_id_ = schema.cotable_id_;</a>
<a name="ln601">}</a>
<a name="ln602"> </a>
<a name="ln603">Status SchemaBuilder::AddKeyColumn(const string&amp; name, const shared_ptr&lt;QLType&gt;&amp; type) {</a>
<a name="ln604">  return AddColumn(ColumnSchema(name, type), /* is_nullable */ true);</a>
<a name="ln605">}</a>
<a name="ln606"> </a>
<a name="ln607">Status SchemaBuilder::AddKeyColumn(const string&amp; name, DataType type) {</a>
<a name="ln608">  return AddColumn(ColumnSchema(name, QLType::Create(type)), /* is_nullable */ true);</a>
<a name="ln609">}</a>
<a name="ln610"> </a>
<a name="ln611">Status SchemaBuilder::AddHashKeyColumn(const string&amp; name, const shared_ptr&lt;QLType&gt;&amp; type) {</a>
<a name="ln612">  return AddColumn(ColumnSchema(name, type, false, true), true);</a>
<a name="ln613">}</a>
<a name="ln614"> </a>
<a name="ln615">Status SchemaBuilder::AddHashKeyColumn(const string&amp; name, DataType type) {</a>
<a name="ln616">  return AddColumn(ColumnSchema(name, QLType::Create(type), false, true), true);</a>
<a name="ln617">}</a>
<a name="ln618"> </a>
<a name="ln619">Status SchemaBuilder::AddColumn(const string&amp; name,</a>
<a name="ln620">                                const std::shared_ptr&lt;QLType&gt;&amp; type,</a>
<a name="ln621">                                bool is_nullable,</a>
<a name="ln622">                                bool is_hash_key,</a>
<a name="ln623">                                bool is_static,</a>
<a name="ln624">                                bool is_counter,</a>
<a name="ln625">                                int32_t order,</a>
<a name="ln626">                                ColumnSchema::SortingType sorting_type) {</a>
<a name="ln627">  return AddColumn(ColumnSchema(name, type, is_nullable, is_hash_key, is_static, is_counter,</a>
<a name="ln628">                                order, sorting_type), false);</a>
<a name="ln629">}</a>
<a name="ln630"> </a>
<a name="ln631">Status SchemaBuilder::RemoveColumn(const string&amp; name) {</a>
<a name="ln632">  unordered_set&lt;string&gt;::const_iterator it_names;</a>
<a name="ln633">  if ((it_names = col_names_.find(name)) == col_names_.end()) {</a>
<a name="ln634">    return STATUS(NotFound, &quot;The specified column does not exist&quot;, name);</a>
<a name="ln635">  }</a>
<a name="ln636"> </a>
<a name="ln637">  col_names_.erase(it_names);</a>
<a name="ln638">  for (int i = 0; i &lt; cols_.size(); ++i) {</a>
<a name="ln639">    if (name == cols_[i].name()) {</a>
<a name="ln640">      cols_.erase(cols_.begin() + i);</a>
<a name="ln641">      col_ids_.erase(col_ids_.begin() + i);</a>
<a name="ln642">      if (i &lt; num_key_columns_) {</a>
<a name="ln643">        num_key_columns_--;</a>
<a name="ln644">      }</a>
<a name="ln645">      return Status::OK();</a>
<a name="ln646">    }</a>
<a name="ln647">  }</a>
<a name="ln648"> </a>
<a name="ln649">  LOG(FATAL) &lt;&lt; &quot;Should not reach here&quot;;</a>
<a name="ln650">  return STATUS(Corruption, &quot;Unable to remove existing column&quot;);</a>
<a name="ln651">}</a>
<a name="ln652"> </a>
<a name="ln653">Status SchemaBuilder::RenameColumn(const string&amp; old_name, const string&amp; new_name) {</a>
<a name="ln654">  unordered_set&lt;string&gt;::const_iterator it_names;</a>
<a name="ln655"> </a>
<a name="ln656">  // check if 'new_name' is already in use</a>
<a name="ln657">  if ((it_names = col_names_.find(new_name)) != col_names_.end()) {</a>
<a name="ln658">    return STATUS(AlreadyPresent, &quot;The column already exists&quot;, new_name);</a>
<a name="ln659">  }</a>
<a name="ln660"> </a>
<a name="ln661">  // check if the 'old_name' column exists</a>
<a name="ln662">  if ((it_names = col_names_.find(old_name)) == col_names_.end()) {</a>
<a name="ln663">    return STATUS(NotFound, &quot;The specified column does not exist&quot;, old_name);</a>
<a name="ln664">  }</a>
<a name="ln665"> </a>
<a name="ln666">  col_names_.erase(it_names);   // TODO: Should this one stay and marked as alias?</a>
<a name="ln667">  col_names_.insert(new_name);</a>
<a name="ln668"> </a>
<a name="ln669">  for (ColumnSchema&amp; col_schema : cols_) {</a>
<a name="ln670">    if (old_name == col_schema.name()) {</a>
<a name="ln671">      col_schema.set_name(new_name);</a>
<a name="ln672">      return Status::OK();</a>
<a name="ln673">    }</a>
<a name="ln674">  }</a>
<a name="ln675"> </a>
<a name="ln676">  LOG(FATAL) &lt;&lt; &quot;Should not reach here&quot;;</a>
<a name="ln677">  return STATUS(IllegalState, &quot;Unable to rename existing column&quot;);</a>
<a name="ln678">}</a>
<a name="ln679"> </a>
<a name="ln680">Status SchemaBuilder::AddColumn(const ColumnSchema&amp; column, bool is_key) {</a>
<a name="ln681">  if (ContainsKey(col_names_, column.name())) {</a>
<a name="ln682">    return STATUS(AlreadyPresent, &quot;The column already exists&quot;, column.name());</a>
<a name="ln683">  }</a>
<a name="ln684"> </a>
<a name="ln685">  col_names_.insert(column.name());</a>
<a name="ln686">  if (is_key) {</a>
<a name="ln687">    cols_.insert(cols_.begin() + num_key_columns_, column);</a>
<a name="ln688">    col_ids_.insert(col_ids_.begin() + num_key_columns_, next_id_);</a>
<a name="ln689">    num_key_columns_++;</a>
<a name="ln690">  } else {</a>
<a name="ln691">    cols_.push_back(column);</a>
<a name="ln692">    col_ids_.push_back(next_id_);</a>
<a name="ln693">  }</a>
<a name="ln694"> </a>
<a name="ln695">  next_id_ = ColumnId(next_id_ + 1);</a>
<a name="ln696">  return Status::OK();</a>
<a name="ln697">}</a>
<a name="ln698"> </a>
<a name="ln699">Status SchemaBuilder::AlterProperties(const TablePropertiesPB&amp; pb) {</a>
<a name="ln700">  table_properties_.AlterFromTablePropertiesPB(pb);</a>
<a name="ln701">  return Status::OK();</a>
<a name="ln702">}</a>
<a name="ln703"> </a>
<a name="ln704"> </a>
<a name="ln705">Status DeletedColumn::FromPB(const DeletedColumnPB&amp; col, DeletedColumn* ret) {</a>
<a name="ln706">  ret-&gt;id = col.column_id();</a>
<a name="ln707">  ret-&gt;ht = HybridTime(col.deleted_hybrid_time());</a>
<a name="ln708">  return Status::OK();</a>
<a name="ln709">}</a>
<a name="ln710"> </a>
<a name="ln711">void DeletedColumn::CopyToPB(DeletedColumnPB* pb) const {</a>
<a name="ln712">  pb-&gt;set_column_id(id);</a>
<a name="ln713">  pb-&gt;set_deleted_hybrid_time(ht.ToUint64());</a>
<a name="ln714">}</a>
<a name="ln715"> </a>
<a name="ln716">} // namespace yb</a>

</code></pre>
<div class="balloon" rel="234"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="252"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="396"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="405"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="410"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="457"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
