
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>block_based_table_reader.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//  Copyright (c) 2011-present, Facebook, Inc.  All rights reserved.</a>
<a name="ln2">//  This source code is licensed under the BSD-style license found in the</a>
<a name="ln3">//  LICENSE file in the root directory of this source tree. An additional grant</a>
<a name="ln4">//  of patent rights can be found in the PATENTS file in the same directory.</a>
<a name="ln5">//</a>
<a name="ln6">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln7">//</a>
<a name="ln8">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln9">//</a>
<a name="ln10">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln11">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln12">//</a>
<a name="ln13">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln14">//</a>
<a name="ln15">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln16">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln17">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln18">// under the License.</a>
<a name="ln19">//</a>
<a name="ln20">// Copyright (c) 2011 The LevelDB Authors. All rights reserved.</a>
<a name="ln21">// Use of this source code is governed by a BSD-style license that can be</a>
<a name="ln22">// found in the LICENSE file. See the AUTHORS file for names of contributors.</a>
<a name="ln23"> </a>
<a name="ln24">#include &quot;yb/rocksdb/table/block_based_table_reader.h&quot;</a>
<a name="ln25"> </a>
<a name="ln26">#include &lt;string&gt;</a>
<a name="ln27">#include &lt;utility&gt;</a>
<a name="ln28">#include &lt;cinttypes&gt;</a>
<a name="ln29"> </a>
<a name="ln30">#include &quot;yb/rocksdb/db/dbformat.h&quot;</a>
<a name="ln31"> </a>
<a name="ln32">#include &quot;yb/rocksdb/cache.h&quot;</a>
<a name="ln33">#include &quot;yb/rocksdb/comparator.h&quot;</a>
<a name="ln34">#include &quot;yb/rocksdb/env.h&quot;</a>
<a name="ln35">#include &quot;yb/rocksdb/filter_policy.h&quot;</a>
<a name="ln36">#include &quot;yb/rocksdb/iterator.h&quot;</a>
<a name="ln37">#include &quot;yb/rocksdb/options.h&quot;</a>
<a name="ln38">#include &quot;yb/rocksdb/statistics.h&quot;</a>
<a name="ln39">#include &quot;yb/rocksdb/table.h&quot;</a>
<a name="ln40">#include &quot;yb/rocksdb/table_properties.h&quot;</a>
<a name="ln41">#include &quot;yb/rocksdb/table/block.h&quot;</a>
<a name="ln42">#include &quot;yb/rocksdb/table/block_based_filter_block.h&quot;</a>
<a name="ln43">#include &quot;yb/rocksdb/table/block_based_table_factory.h&quot;</a>
<a name="ln44">#include &quot;yb/rocksdb/table/block_based_table_internal.h&quot;</a>
<a name="ln45">#include &quot;yb/rocksdb/table/block_hash_index.h&quot;</a>
<a name="ln46">#include &quot;yb/rocksdb/table/block_prefix_index.h&quot;</a>
<a name="ln47">#include &quot;yb/rocksdb/table/filter_block.h&quot;</a>
<a name="ln48">#include &quot;yb/rocksdb/table/format.h&quot;</a>
<a name="ln49">#include &quot;yb/rocksdb/table/forwarding_iterator.h&quot;</a>
<a name="ln50">#include &quot;yb/rocksdb/table/fixed_size_filter_block.h&quot;</a>
<a name="ln51">#include &quot;yb/rocksdb/table/full_filter_block.h&quot;</a>
<a name="ln52">#include &quot;yb/rocksdb/table/get_context.h&quot;</a>
<a name="ln53">#include &quot;yb/rocksdb/table/index_reader.h&quot;</a>
<a name="ln54">#include &quot;yb/rocksdb/table/internal_iterator.h&quot;</a>
<a name="ln55">#include &quot;yb/rocksdb/table/meta_blocks.h&quot;</a>
<a name="ln56">#include &quot;yb/rocksdb/table/two_level_iterator.h&quot;</a>
<a name="ln57"> </a>
<a name="ln58">#include &quot;yb/rocksdb/util/coding.h&quot;</a>
<a name="ln59">#include &quot;yb/rocksdb/util/file_reader_writer.h&quot;</a>
<a name="ln60">#include &quot;yb/rocksdb/util/perf_context_imp.h&quot;</a>
<a name="ln61">#include &quot;yb/rocksdb/util/stop_watch.h&quot;</a>
<a name="ln62"> </a>
<a name="ln63">#include &quot;yb/gutil/macros.h&quot;</a>
<a name="ln64"> </a>
<a name="ln65">#include &quot;yb/util/logging.h&quot;</a>
<a name="ln66">#include &quot;yb/util/atomic.h&quot;</a>
<a name="ln67">#include &quot;yb/util/mem_tracker.h&quot;</a>
<a name="ln68">#include &quot;yb/util/scope_exit.h&quot;</a>
<a name="ln69">#include &quot;yb/util/string_util.h&quot;</a>
<a name="ln70"> </a>
<a name="ln71">namespace rocksdb {</a>
<a name="ln72"> </a>
<a name="ln73">extern const uint64_t kBlockBasedTableMagicNumber;</a>
<a name="ln74">extern const char kHashIndexPrefixesBlock[];</a>
<a name="ln75">extern const char kHashIndexPrefixesMetadataBlock[];</a>
<a name="ln76">using std::unique_ptr;</a>
<a name="ln77"> </a>
<a name="ln78">typedef FilterPolicy::FilterType FilterType;</a>
<a name="ln79"> </a>
<a name="ln80">namespace {</a>
<a name="ln81"> </a>
<a name="ln82">// Delete the resource that is held by the iterator.</a>
<a name="ln83">template &lt;class ResourceType&gt;</a>
<a name="ln84">void DeleteHeldResource(void* arg, void* ignored) {</a>
<a name="ln85">  delete reinterpret_cast&lt;ResourceType*&gt;(arg);</a>
<a name="ln86">}</a>
<a name="ln87"> </a>
<a name="ln88">// Delete the entry resided in the cache.</a>
<a name="ln89">template &lt;class Entry&gt;</a>
<a name="ln90">void DeleteCachedEntry(const Slice&amp; key, void* value) {</a>
<a name="ln91">  auto entry = reinterpret_cast&lt;Entry*&gt;(value);</a>
<a name="ln92">  delete entry;</a>
<a name="ln93">}</a>
<a name="ln94"> </a>
<a name="ln95">// Release the cached entry and decrement its ref count.</a>
<a name="ln96">void ReleaseCachedEntry(void* arg, void* h) {</a>
<a name="ln97">  Cache* cache = reinterpret_cast&lt;Cache*&gt;(arg);</a>
<a name="ln98">  Cache::Handle* handle = reinterpret_cast&lt;Cache::Handle*&gt;(h);</a>
<a name="ln99">  cache-&gt;Release(handle);</a>
<a name="ln100">}</a>
<a name="ln101"> </a>
<a name="ln102">Cache::Handle* GetEntryFromCache(Cache* block_cache, const Slice&amp; key,</a>
<a name="ln103">                                 Tickers block_cache_miss_ticker,</a>
<a name="ln104">                                 Tickers block_cache_hit_ticker,</a>
<a name="ln105">                                 Statistics* statistics,</a>
<a name="ln106">                                 const QueryId query_id) {</a>
<a name="ln107">  auto cache_handle = block_cache-&gt;Lookup(key, query_id, statistics);</a>
<a name="ln108">  if (cache_handle != nullptr) {</a>
<a name="ln109">    PERF_COUNTER_ADD(block_cache_hit_count, 1);</a>
<a name="ln110">    // block-type specific cache hit</a>
<a name="ln111">    RecordTick(statistics, block_cache_hit_ticker);</a>
<a name="ln112">  } else {</a>
<a name="ln113">    // block-type specific cache miss</a>
<a name="ln114">    RecordTick(statistics, block_cache_miss_ticker);</a>
<a name="ln115">  }</a>
<a name="ln116"> </a>
<a name="ln117">  return cache_handle;</a>
<a name="ln118">}</a>
<a name="ln119"> </a>
<a name="ln120">class NotMatchingFilterBlockReader : public FilterBlockReader {</a>
<a name="ln121"> public:</a>
<a name="ln122">  NotMatchingFilterBlockReader() {}</a>
<a name="ln123">  NotMatchingFilterBlockReader(const NotMatchingFilterBlockReader&amp;) = delete;</a>
<a name="ln124">  void operator=(const NotMatchingFilterBlockReader&amp;) = delete;</a>
<a name="ln125">  virtual bool KeyMayMatch(const Slice&amp; key, uint64_t block_offset = 0) override {</a>
<a name="ln126">    return false; }</a>
<a name="ln127">  virtual bool PrefixMayMatch(const Slice&amp; prefix, uint64_t block_offset = 0) override {</a>
<a name="ln128">    return false; }</a>
<a name="ln129">  virtual size_t ApproximateMemoryUsage() const override { return 0; }</a>
<a name="ln130">};</a>
<a name="ln131"> </a>
<a name="ln132">}  // namespace</a>
<a name="ln133"> </a>
<a name="ln134">// Originally following data was stored in BlockBasedTable::Rep and related to a single SST file.</a>
<a name="ln135">// Since SST file is now split into two files - data file and metadata file, all file-related data</a>
<a name="ln136">// was moved into dedicated structure for each file.</a>
<a name="ln137">struct BlockBasedTable::FileReaderWithCachePrefix {</a>
<a name="ln138">  // Pointer to file reader.</a>
<a name="ln139">  unique_ptr&lt;RandomAccessFileReader&gt; reader;</a>
<a name="ln140"> </a>
<a name="ln141">  // BlockBasedTableReader uses the block cache passed to BlockBasedTableReader::Open inside</a>
<a name="ln142">  // a BlockBasedTableOptions instance to reduce the number of file read requests. If block cache</a>
<a name="ln143">  // pointer in options is nullptr, cache is not used. File blocks are referred in cache by keys,</a>
<a name="ln144">  // which are composed from the following data (see GetCacheKey helper function):</a>
<a name="ln145">  // - cache key prefix (unique for each file), generated by BlockBasedTable::GenerateCachePrefix</a>
<a name="ln146">  // - block offset within a file.</a>
<a name="ln147">  block_based_table::CacheKeyPrefixBuffer cache_key_prefix;</a>
<a name="ln148"> </a>
<a name="ln149">  // Similar prefix, but for compressed blocks cache:</a>
<a name="ln150">  block_based_table::CacheKeyPrefixBuffer compressed_cache_key_prefix;</a>
<a name="ln151"> </a>
<a name="ln152">  explicit FileReaderWithCachePrefix(unique_ptr&lt;RandomAccessFileReader&gt;&amp;&amp; _reader) :</a>
<a name="ln153">      reader(std::move(_reader)) {}</a>
<a name="ln154">};</a>
<a name="ln155"> </a>
<a name="ln156">// CachableEntry represents the entries that *may* be fetched from block cache.</a>
<a name="ln157">//  field `value` is the item we want to get.</a>
<a name="ln158">//  field `cache_handle` is the cache handle to the block cache. If the value</a>
<a name="ln159">//    was not read from cache, `cache_handle` will be nullptr.</a>
<a name="ln160">template &lt;class TValue&gt;</a>
<a name="ln161">struct BlockBasedTable::CachableEntry {</a>
<a name="ln162">  CachableEntry(TValue* _value, Cache::Handle* _cache_handle)</a>
<a name="ln163">      : value(_value), cache_handle(_cache_handle) {}</a>
<a name="ln164">  CachableEntry() : CachableEntry(nullptr, nullptr) {}</a>
<a name="ln165">  void Release(Cache* cache) {</a>
<a name="ln166">    if (cache_handle) {</a>
<a name="ln167">      cache-&gt;Release(cache_handle);</a>
<a name="ln168">      value = nullptr;</a>
<a name="ln169">      cache_handle = nullptr;</a>
<a name="ln170">    }</a>
<a name="ln171">  }</a>
<a name="ln172"> </a>
<a name="ln173">  TValue* value = nullptr;</a>
<a name="ln174">  // if the entry is from the cache, cache_handle will be populated.</a>
<a name="ln175">  Cache::Handle* cache_handle = nullptr;</a>
<a name="ln176">};</a>
<a name="ln177"> </a>
<a name="ln178">struct BlockBasedTable::Rep {</a>
<a name="ln179">  struct NotMatchingFilterEntry : public CachableEntry&lt;FilterBlockReader&gt; {</a>
<a name="ln180">    NotMatchingFilterEntry() : CachableEntry(&amp;filter, nullptr) {}</a>
<a name="ln181">    NotMatchingFilterBlockReader filter;</a>
<a name="ln182">  };</a>
<a name="ln183"> </a>
<a name="ln184">  Rep(const ImmutableCFOptions&amp; _ioptions, const EnvOptions&amp; _env_options,</a>
<a name="ln185">      const BlockBasedTableOptions&amp; _table_opt,</a>
<a name="ln186">      const InternalKeyComparatorPtr&amp; _internal_comparator, bool skip_filters,</a>
<a name="ln187">      const DataIndexLoadMode data_index_load_mode_)</a>
<a name="ln188">      : ioptions(_ioptions),</a>
<a name="ln189">        env_options(_env_options),</a>
<a name="ln190">        table_options(_table_opt),</a>
<a name="ln191">        filter_policy(skip_filters ? nullptr : _table_opt.filter_policy.get()),</a>
<a name="ln192">        filter_key_transformer(filter_policy ? filter_policy-&gt;GetKeyTransformer() : nullptr),</a>
<a name="ln193">        comparator(_internal_comparator),</a>
<a name="ln194">        filter_type(FilterType::kNoFilter),</a>
<a name="ln195">        whole_key_filtering(_table_opt.whole_key_filtering),</a>
<a name="ln196">        prefix_filtering(true),</a>
<a name="ln197">        data_index_load_mode(data_index_load_mode_) {</a>
<a name="ln198">    if (ioptions.block_based_table_mem_tracker) {</a>
<a name="ln199">      mem_tracker = ioptions.block_based_table_mem_tracker;</a>
<a name="ln200">    } else if (ioptions.mem_tracker) {</a>
<a name="ln201">      mem_tracker = yb::MemTracker::FindOrCreateTracker(&quot;BlockBasedTable&quot;, ioptions.mem_tracker);</a>
<a name="ln202">    }</a>
<a name="ln203">  }</a>
<a name="ln204"> </a>
<a name="ln205">  const ImmutableCFOptions&amp; ioptions;</a>
<a name="ln206">  const EnvOptions&amp; env_options;</a>
<a name="ln207">  const BlockBasedTableOptions&amp; table_options;</a>
<a name="ln208">  const FilterPolicy* filter_policy;</a>
<a name="ln209">  const FilterPolicy::KeyTransformer* filter_key_transformer;</a>
<a name="ln210">  InternalKeyComparatorPtr comparator;</a>
<a name="ln211">  const NotMatchingFilterEntry not_matching_filter_entry;</a>
<a name="ln212">  Status status;</a>
<a name="ln213">  std::shared_ptr&lt;FileReaderWithCachePrefix&gt; base_reader_with_cache_prefix;</a>
<a name="ln214">  std::shared_ptr&lt;FileReaderWithCachePrefix&gt; data_reader_with_cache_prefix;</a>
<a name="ln215"> </a>
<a name="ln216">  // Footer contains the fixed table information</a>
<a name="ln217">  Footer footer;</a>
<a name="ln218">  std::mutex data_index_reader_mutex;</a>
<a name="ln219">  yb::AtomicUniquePtr&lt;IndexReader&gt; data_index_reader;</a>
<a name="ln220">  unique_ptr&lt;BlockEntryIteratorState&gt; data_index_iterator_state;</a>
<a name="ln221">  unique_ptr&lt;IndexReader&gt; filter_index_reader;</a>
<a name="ln222">  unique_ptr&lt;FilterBlockReader&gt; filter;</a>
<a name="ln223"> </a>
<a name="ln224">  FilterType filter_type;</a>
<a name="ln225"> </a>
<a name="ln226">  // Handle of fixed-size bloom filter index block or simply filter block for filters of other</a>
<a name="ln227">  // types.</a>
<a name="ln228">  BlockHandle filter_handle;</a>
<a name="ln229"> </a>
<a name="ln230">  std::shared_ptr&lt;const TableProperties&gt; table_properties;</a>
<a name="ln231">  IndexType index_type;</a>
<a name="ln232">  bool hash_index_allow_collision;</a>
<a name="ln233">  bool whole_key_filtering;</a>
<a name="ln234">  bool prefix_filtering;</a>
<a name="ln235">  // TODO(kailiu) It is very ugly to use internal key in table, since table</a>
<a name="ln236">  // module should not be relying on db module. However to make things easier</a>
<a name="ln237">  // and compatible with existing code, we introduce a wrapper that allows</a>
<a name="ln238">  // block to extract prefix without knowing if a key is internal or not.</a>
<a name="ln239">  unique_ptr&lt;SliceTransform&gt; internal_prefix_transform;</a>
<a name="ln240">  DataIndexLoadMode data_index_load_mode;</a>
<a name="ln241">  yb::MemTrackerPtr mem_tracker;</a>
<a name="ln242">};</a>
<a name="ln243"> </a>
<a name="ln244">// BlockEntryIteratorState doesn't actually store any iterator state and is only used as an adapter</a>
<a name="ln245">// to BlockBasedTable. It is used by TwoLevelIterator and MultiLevelIterator to call BlockBasedTable</a>
<a name="ln246">// functions in order to check if prefix may match or to create a secondary iterator.</a>
<a name="ln247">class BlockBasedTable::BlockEntryIteratorState : public TwoLevelIteratorState {</a>
<a name="ln248"> public:</a>
<a name="ln249">  BlockEntryIteratorState(</a>
<a name="ln250">      BlockBasedTable* table, const ReadOptions&amp; read_options, bool skip_filters,</a>
<a name="ln251">      BlockType block_type)</a>
<a name="ln252">      : TwoLevelIteratorState(table-&gt;rep_-&gt;ioptions.prefix_extractor != nullptr),</a>
<a name="ln253">        table_(table),</a>
<a name="ln254">        read_options_(read_options),</a>
<a name="ln255">        skip_filters_(skip_filters),</a>
<a name="ln256">        block_type_(block_type) {}</a>
<a name="ln257"> </a>
<a name="ln258">  InternalIterator* NewSecondaryIterator(const Slice&amp; index_value) override {</a>
<a name="ln259">    return table_-&gt;NewDataBlockIterator(read_options_, index_value, block_type_);</a>
<a name="ln260">  }</a>
<a name="ln261"> </a>
<a name="ln262">  bool PrefixMayMatch(const Slice&amp; internal_key) override {</a>
<a name="ln263">    if (read_options_.total_order_seek || skip_filters_) {</a>
<a name="ln264">      return true;</a>
<a name="ln265">    }</a>
<a name="ln266">    return table_-&gt;PrefixMayMatch(internal_key);</a>
<a name="ln267">  }</a>
<a name="ln268"> </a>
<a name="ln269"> private:</a>
<a name="ln270">  // Don't own table_. BlockEntryIteratorState should only be stored in iterators or in</a>
<a name="ln271">  // corresponding BlockBasedTable. TableReader (superclass of BlockBasedTable) is only destroyed</a>
<a name="ln272">  // after iterator is deleted.</a>
<a name="ln273">  BlockBasedTable* const table_;</a>
<a name="ln274">  const ReadOptions read_options_;</a>
<a name="ln275">  const bool skip_filters_;</a>
<a name="ln276">  const BlockType block_type_;</a>
<a name="ln277">};</a>
<a name="ln278"> </a>
<a name="ln279"> </a>
<a name="ln280">class BlockBasedTable::IndexIteratorHolder {</a>
<a name="ln281"> public:</a>
<a name="ln282">  IndexIteratorHolder(BlockBasedTable* table_reader, ReadOptions read_options)</a>
<a name="ln283">      : iter_holder_(table_reader-&gt;NewIndexIterator(read_options, &amp;iter_)),</a>
<a name="ln284">        iter_ptr_(iter_holder_ ? iter_holder_.get() : implicit_cast&lt;InternalIterator*&gt;(&amp;iter_)) {}</a>
<a name="ln285"> </a>
<a name="ln286">  InternalIterator* iter() const { return iter_ptr_; }</a>
<a name="ln287"> </a>
<a name="ln288"> private:</a>
<a name="ln289">  BlockIter iter_;</a>
<a name="ln290">  std::unique_ptr&lt;InternalIterator&gt; iter_holder_;</a>
<a name="ln291">  InternalIterator* iter_ptr_;</a>
<a name="ln292">};</a>
<a name="ln293"> </a>
<a name="ln294">BlockBasedTable::~BlockBasedTable() {</a>
<a name="ln295">  delete rep_;</a>
<a name="ln296">}</a>
<a name="ln297"> </a>
<a name="ln298">void BlockBasedTable::SetupCacheKeyPrefix(Rep* rep,</a>
<a name="ln299">    FileReaderWithCachePrefix* reader_with_cache_prefix) {</a>
<a name="ln300">  reader_with_cache_prefix-&gt;cache_key_prefix.size = 0;</a>
<a name="ln301">  reader_with_cache_prefix-&gt;compressed_cache_key_prefix.size = 0;</a>
<a name="ln302">  if (rep-&gt;table_options.block_cache != nullptr) {</a>
<a name="ln303">    GenerateCachePrefix(rep-&gt;table_options.block_cache.get(),</a>
<a name="ln304">        reader_with_cache_prefix-&gt;reader-&gt;file(),</a>
<a name="ln305">        &amp;reader_with_cache_prefix-&gt;cache_key_prefix);</a>
<a name="ln306">  }</a>
<a name="ln307">  if (rep-&gt;table_options.block_cache_compressed != nullptr) {</a>
<a name="ln308">    GenerateCachePrefix(rep-&gt;table_options.block_cache_compressed.get(),</a>
<a name="ln309">        reader_with_cache_prefix-&gt;reader-&gt;file(),</a>
<a name="ln310">        &amp;reader_with_cache_prefix-&gt;compressed_cache_key_prefix);</a>
<a name="ln311">  }</a>
<a name="ln312">}</a>
<a name="ln313"> </a>
<a name="ln314">BlockBasedTable::FileReaderWithCachePrefix* BlockBasedTable::GetBlockReader(BlockType block_type) {</a>
<a name="ln315">  switch (block_type) {</a>
<a name="ln316">    case BlockType::kData:</a>
<a name="ln317">      return rep_-&gt;data_reader_with_cache_prefix.get();</a>
<a name="ln318">    case BlockType::kIndex:</a>
<a name="ln319">      return rep_-&gt;base_reader_with_cache_prefix.get();</a>
<a name="ln320">  }</a>
<a name="ln321">  FATAL_INVALID_ENUM_VALUE(BlockType, block_type);</a>
<a name="ln322">}</a>
<a name="ln323"> </a>
<a name="ln324">BloomFilterAwareFileFilter::BloomFilterAwareFileFilter(</a>
<a name="ln325">    const ReadOptions&amp; read_options, const Slice&amp; user_key)</a>
<a name="ln326">    : read_options_(read_options), user_key_(user_key.ToBuffer()) {}</a>
<a name="ln327"> </a>
<a name="ln328">bool BloomFilterAwareFileFilter::Filter(TableReader* reader) const {</a>
<a name="ln329">  auto table = down_cast&lt;BlockBasedTable*&gt;(reader);</a>
<a name="ln330">  if (table-&gt;rep_-&gt;filter_type == FilterType::kFixedSizeFilter) {</a>
<a name="ln331">    const auto filter_key = table-&gt;GetFilterKeyFromUserKey(user_key_);</a>
<a name="ln332">    auto filter_entry = table-&gt;GetFilter(read_options_.query_id,</a>
<a name="ln333">        read_options_.read_tier == kBlockCacheTier /* no_io */, &amp;filter_key);</a>
<a name="ln334">    FilterBlockReader* filter = filter_entry.value;</a>
<a name="ln335">    // If bloom filter was not useful, then take this file into account.</a>
<a name="ln336">    const bool use_file = table-&gt;NonBlockBasedFilterKeyMayMatch(filter, filter_key);</a>
<a name="ln337">    if (!use_file) {</a>
<a name="ln338">      // Record that the bloom filter was useful.</a>
<a name="ln339">      RecordTick(table-&gt;rep_-&gt;ioptions.statistics, BLOOM_FILTER_USEFUL);</a>
<a name="ln340">    }</a>
<a name="ln341">    filter_entry.Release(table-&gt;rep_-&gt;table_options.block_cache.get());</a>
<a name="ln342">    return use_file;</a>
<a name="ln343">  } else {</a>
<a name="ln344">    // For non fixed-size filters - take file into account. We are only using fixed-size bloom</a>
<a name="ln345">    // filters for DocDB, so not need to support others.</a>
<a name="ln346">    return true;</a>
<a name="ln347">  }</a>
<a name="ln348">}</a>
<a name="ln349"> </a>
<a name="ln350">namespace {</a>
<a name="ln351">// Return True if table_properties has `user_prop_name` has a `true` value</a>
<a name="ln352">// or it doesn't contain this property (for backward compatible).</a>
<a name="ln353">bool IsFeatureSupported(const TableProperties&amp; table_properties,</a>
<a name="ln354">                        const std::string&amp; user_prop_name, Logger* info_log) {</a>
<a name="ln355">  auto&amp; props = table_properties.user_collected_properties;</a>
<a name="ln356">  auto pos = props.find(user_prop_name);</a>
<a name="ln357">  // Older version doesn't have this value set. Skip this check.</a>
<a name="ln358">  if (pos != props.end()) {</a>
<a name="ln359">    if (pos-&gt;second == kPropFalse) {</a>
<a name="ln360">      return false;</a>
<a name="ln361">    } else if (pos-&gt;second != kPropTrue) {</a>
<a name="ln362">      RLOG(InfoLogLevel::WARN_LEVEL, info_log,</a>
<a name="ln363">          &quot;Property %s has invalidate value %s&quot;, user_prop_name.c_str(),</a>
<a name="ln364">          pos-&gt;second.c_str());</a>
<a name="ln365">    }</a>
<a name="ln366">  }</a>
<a name="ln367">  return true;</a>
<a name="ln368">}</a>
<a name="ln369">}  // namespace</a>
<a name="ln370"> </a>
<a name="ln371">Status BlockBasedTable::Open(const ImmutableCFOptions&amp; ioptions,</a>
<a name="ln372">                             const EnvOptions&amp; env_options,</a>
<a name="ln373">                             const BlockBasedTableOptions&amp; table_options,</a>
<a name="ln374">                             const InternalKeyComparatorPtr&amp; internal_comparator,</a>
<a name="ln375">                             unique_ptr&lt;RandomAccessFileReader&gt;&amp;&amp; base_file,</a>
<a name="ln376">                             uint64_t base_file_size,</a>
<a name="ln377">                             unique_ptr&lt;TableReader&gt;* table_reader,</a>
<a name="ln378">                             DataIndexLoadMode data_index_load_mode,</a>
<a name="ln379">                             PrefetchFilter prefetch_filter,</a>
<a name="ln380">                             const bool skip_filters) {</a>
<a name="ln381">  table_reader-&gt;reset();</a>
<a name="ln382"> </a>
<a name="ln383">  Footer footer;</a>
<a name="ln384">  RETURN_NOT_OK(ReadFooterFromFile(</a>
<a name="ln385">      base_file.get(), base_file_size, &amp;footer, kBlockBasedTableMagicNumber));</a>
<a name="ln386">  if (!BlockBasedTableSupportedVersion(footer.version())) {</a>
<a name="ln387">    return STATUS(Corruption,</a>
<a name="ln388">        &quot;Unknown Footer version. Maybe this file was created with newer &quot;</a>
<a name="ln389">        &quot;version of RocksDB?&quot;);</a>
<a name="ln390">  }</a>
<a name="ln391"> </a>
<a name="ln392">  // We've successfully read the footer and the index block: we're</a>
<a name="ln393">  // ready to serve requests.</a>
<a name="ln394">  Rep* rep = new BlockBasedTable::Rep(ioptions, env_options, table_options,</a>
<a name="ln395">                                      internal_comparator, skip_filters, data_index_load_mode);</a>
<a name="ln396">  rep-&gt;base_reader_with_cache_prefix =</a>
<a name="ln397">      std::make_shared&lt;FileReaderWithCachePrefix&gt;(std::move(base_file));</a>
<a name="ln398">  rep-&gt;data_reader_with_cache_prefix = rep-&gt;base_reader_with_cache_prefix;</a>
<a name="ln399">  rep-&gt;footer = footer;</a>
<a name="ln400">  rep-&gt;index_type = table_options.index_type;</a>
<a name="ln401">  rep-&gt;hash_index_allow_collision = table_options.hash_index_allow_collision;</a>
<a name="ln402">  SetupCacheKeyPrefix(rep, rep-&gt;base_reader_with_cache_prefix.get());</a>
<a name="ln403">  unique_ptr&lt;BlockBasedTable&gt; new_table(new BlockBasedTable(rep));</a>
<a name="ln404"> </a>
<a name="ln405">  // Read meta index</a>
<a name="ln406">  std::unique_ptr&lt;Block&gt; meta;</a>
<a name="ln407">  std::unique_ptr&lt;InternalIterator&gt; meta_iter;</a>
<a name="ln408">  RETURN_NOT_OK(ReadMetaBlock(rep, &amp;meta, &amp;meta_iter));</a>
<a name="ln409"> </a>
<a name="ln410">  RETURN_NOT_OK(new_table-&gt;ReadPropertiesBlock(meta_iter.get()));</a>
<a name="ln411"> </a>
<a name="ln412">  RETURN_NOT_OK(new_table-&gt;SetupFilter(meta_iter.get()));</a>
<a name="ln413"> </a>
<a name="ln414">  if (data_index_load_mode == DataIndexLoadMode::PRELOAD_ON_OPEN) {</a>
<a name="ln415">    // Will use block cache for data index access?</a>
<a name="ln416">    if (table_options.cache_index_and_filter_blocks) {</a>
<a name="ln417">      DCHECK_ONLY_NOTNULL(table_options.block_cache.get());</a>
<a name="ln418">      // Hack: Call NewIndexIterator() to implicitly add index to the</a>
<a name="ln419">      // block_cache</a>
<a name="ln420">      unique_ptr&lt;InternalIterator&gt; iter(new_table-&gt;NewIndexIterator(ReadOptions::kDefault));</a>
<a name="ln421">      RETURN_NOT_OK(iter-&gt;status());</a>
<a name="ln422">    } else {</a>
<a name="ln423">      // If we don't use block cache for data index access, we'll pre-load it, which will kept in</a>
<a name="ln424">      // member variables in Rep and with a same life-time as this table object.</a>
<a name="ln425">      // NOTE: Table reader objects are cached in table cache (table_cache.cc).</a>
<a name="ln426">      std::unique_ptr&lt;IndexReader&gt; index_reader;</a>
<a name="ln427">      RETURN_NOT_OK(new_table-&gt;CreateDataBlockIndexReader(&amp;index_reader, meta_iter.get()));</a>
<a name="ln428">      rep-&gt;data_index_reader.reset(index_reader.release());</a>
<a name="ln429">    }</a>
<a name="ln430">  }</a>
<a name="ln431"> </a>
<a name="ln432">  if (prefetch_filter == PrefetchFilter::YES) {</a>
<a name="ln433">    // pre-fetching of blocks is turned on</a>
<a name="ln434">    // NOTE: Table reader objects are cached in table cache (table_cache.cc).</a>
<a name="ln435">    if (rep-&gt;filter_policy &amp;&amp; rep-&gt;filter_type == FilterType::kFixedSizeFilter) {</a>
<a name="ln436">      // TODO: may be put it in block cache instead of table reader in case</a>
<a name="ln437">      // table_options.cache_index_and_filter_blocks is set?</a>
<a name="ln438">      RETURN_NOT_OK(new_table-&gt;CreateFilterIndexReader(&amp;rep-&gt;filter_index_reader));</a>
<a name="ln439">    }</a>
<a name="ln440"> </a>
<a name="ln441">    // Will use block cache for filter blocks access?</a>
<a name="ln442">    if (table_options.cache_index_and_filter_blocks) {</a>
<a name="ln443">      assert(table_options.block_cache != nullptr);</a>
<a name="ln444">      bool corrupted_filter_type = true;</a>
<a name="ln445">      switch (rep-&gt;filter_type) {</a>
<a name="ln446">        case FilterType::kFullFilter:</a>
<a name="ln447">          FALLTHROUGH_INTENDED;</a>
<a name="ln448">        case FilterType::kBlockBasedFilter: {</a>
<a name="ln449">          // Hack: Call GetFilter() to implicitly add filter to the block_cache</a>
<a name="ln450">          auto filter_entry = new_table-&gt;GetFilter(kDefaultQueryId);</a>
<a name="ln451">          filter_entry.Release(table_options.block_cache.get());</a>
<a name="ln452">          corrupted_filter_type = false;</a>
<a name="ln453">          break;</a>
<a name="ln454">        }</a>
<a name="ln455">        case FilterType::kFixedSizeFilter:</a>
<a name="ln456">          // We never pre-cache fixed-size bloom filters.</a>
<a name="ln457">          FALLTHROUGH_INTENDED;</a>
<a name="ln458">        case FilterType::kNoFilter:</a>
<a name="ln459">          corrupted_filter_type = false;</a>
<a name="ln460">          break;</a>
<a name="ln461">      }</a>
<a name="ln462">      if (corrupted_filter_type) {</a>
<a name="ln463">        RLOG(InfoLogLevel::FATAL_LEVEL, rep-&gt;ioptions.info_log, &quot;Corrupted bloom filter type: %d&quot;,</a>
<a name="ln464">            rep-&gt;filter_type);</a>
<a name="ln465">        assert(false);</a>
<a name="ln466">        return STATUS_SUBSTITUTE(Corruption, &quot;Corrupted bloom filter type: $0&quot;, rep-&gt;filter_type);</a>
<a name="ln467">      }</a>
<a name="ln468">    } else {</a>
<a name="ln469">      // If we don't use block cache for filter access, we'll pre-load these blocks, which will</a>
<a name="ln470">      // kept in member variables in Rep and with a same life-time as this table object.</a>
<a name="ln471">      bool corrupted_filter_type = true;</a>
<a name="ln472">      switch (rep-&gt;filter_type) {</a>
<a name="ln473">        case FilterType::kFullFilter:</a>
<a name="ln474">          FALLTHROUGH_INTENDED;</a>
<a name="ln475">        case FilterType::kBlockBasedFilter:</a>
<a name="ln476">          rep-&gt;filter.reset(ReadFilterBlock(rep-&gt;filter_handle, rep, nullptr));</a>
<a name="ln477">          corrupted_filter_type = false;</a>
<a name="ln478">          break;</a>
<a name="ln479">        case FilterType::kFixedSizeFilter:</a>
<a name="ln480">          // We never pre-load fixed-size bloom filters.</a>
<a name="ln481">          FALLTHROUGH_INTENDED;</a>
<a name="ln482">        case FilterType::kNoFilter:</a>
<a name="ln483">          corrupted_filter_type = false;</a>
<a name="ln484">          break;</a>
<a name="ln485">      }</a>
<a name="ln486">      if (corrupted_filter_type) {</a>
<a name="ln487">        RLOG(InfoLogLevel::FATAL_LEVEL, rep-&gt;ioptions.info_log, &quot;Corrupted bloom filter type: %d&quot;,</a>
<a name="ln488">            rep-&gt;filter_type);</a>
<a name="ln489">        assert(false);</a>
<a name="ln490">        return STATUS_SUBSTITUTE(Corruption, &quot;Corrupted bloom filter type: $0&quot;, rep-&gt;filter_type);</a>
<a name="ln491">      }</a>
<a name="ln492">    }</a>
<a name="ln493">  }</a>
<a name="ln494"> </a>
<a name="ln495">  // Filters are checked before seeking the index.</a>
<a name="ln496">  const bool skip_filters_for_index = true;</a>
<a name="ln497">  rep-&gt;data_index_iterator_state = std::make_unique&lt;BlockEntryIteratorState&gt;(</a>
<a name="ln498">      new_table.get(), ReadOptions::kDefault, skip_filters_for_index, BlockType::kIndex);</a>
<a name="ln499"> </a>
<a name="ln500">  *table_reader = std::move(new_table);</a>
<a name="ln501"> </a>
<a name="ln502">  return Status::OK();</a>
<a name="ln503">}</a>
<a name="ln504"> </a>
<a name="ln505">Status BlockBasedTable::ReadPropertiesBlock(InternalIterator* meta_iter) {</a>
<a name="ln506">  // Read the properties</a>
<a name="ln507">  bool found_properties_block = true;</a>
<a name="ln508">  auto s = SeekToPropertiesBlock(meta_iter, &amp;found_properties_block);</a>
<a name="ln509"> </a>
<a name="ln510">  if (!s.ok()) {</a>
<a name="ln511">    RLOG(InfoLogLevel::WARN_LEVEL, rep_-&gt;ioptions.info_log,</a>
<a name="ln512">        &quot;Cannot seek to properties block from file: %s&quot;,</a>
<a name="ln513">        s.ToString().c_str());</a>
<a name="ln514">    return s;</a>
<a name="ln515">  }</a>
<a name="ln516"> </a>
<a name="ln517">  if (found_properties_block) {</a>
<a name="ln518">    s = meta_iter-&gt;status();</a>
<a name="ln519">    TableProperties* table_properties = nullptr;</a>
<a name="ln520">    if (s.ok()) {</a>
<a name="ln521">      s = ReadProperties(</a>
<a name="ln522">            meta_iter-&gt;value(), rep_-&gt;base_reader_with_cache_prefix-&gt;reader.get(),</a>
<a name="ln523">            rep_-&gt;footer, rep_-&gt;ioptions.env, rep_-&gt;ioptions.info_log, &amp;table_properties);</a>
<a name="ln524">    }</a>
<a name="ln525"> </a>
<a name="ln526">    if (!s.ok()) {</a>
<a name="ln527">      RLOG(InfoLogLevel::WARN_LEVEL, rep_-&gt;ioptions.info_log,</a>
<a name="ln528">        &quot;Encountered error while reading data from properties &quot;</a>
<a name="ln529">        &quot;block %s&quot;, s.ToString().c_str());</a>
<a name="ln530">      return s;</a>
<a name="ln531">    }</a>
<a name="ln532">    rep_-&gt;table_properties.reset(table_properties);</a>
<a name="ln533">  } else {</a>
<a name="ln534">    RLOG(InfoLogLevel::ERROR_LEVEL, rep_-&gt;ioptions.info_log,</a>
<a name="ln535">        &quot;Cannot find Properties block from file.&quot;);</a>
<a name="ln536">  }</a>
<a name="ln537"> </a>
<a name="ln538">  // Determine whether whole key filtering is supported.</a>
<a name="ln539">  if (rep_-&gt;table_properties) {</a>
<a name="ln540">    rep_-&gt;whole_key_filtering &amp;=</a>
<a name="ln541">        IsFeatureSupported(*(rep_-&gt;table_properties),</a>
<a name="ln542">                           BlockBasedTablePropertyNames::kWholeKeyFiltering,</a>
<a name="ln543">                           rep_-&gt;ioptions.info_log);</a>
<a name="ln544">    rep_-&gt;prefix_filtering &amp;= IsFeatureSupported(</a>
<a name="ln545">        *(rep_-&gt;table_properties),</a>
<a name="ln546">        BlockBasedTablePropertyNames::kPrefixFiltering, rep_-&gt;ioptions.info_log);</a>
<a name="ln547">  }</a>
<a name="ln548"> </a>
<a name="ln549">  return Status::OK();</a>
<a name="ln550">}</a>
<a name="ln551"> </a>
<a name="ln552">Status BlockBasedTable::SetupFilter(InternalIterator* meta_iter) {</a>
<a name="ln553">  // Find filter handle and filter type.</a>
<a name="ln554">  if (!rep_-&gt;filter_policy) {</a>
<a name="ln555">    return Status::OK();</a>
<a name="ln556">  }</a>
<a name="ln557">  const auto&amp; table_filter_policy_name = rep_-&gt;table_properties-&gt;filter_policy_name;</a>
<a name="ln558">  if (rep_-&gt;filter_policy-&gt;Name() != table_filter_policy_name &amp;&amp;</a>
<a name="ln559">      !table_filter_policy_name.empty()) {</a>
<a name="ln560">    // SST file has been written using another filter policy - use it for reading if it is still</a>
<a name="ln561">    // supported.</a>
<a name="ln562">    const FilterPolicy* table_filter_policy = nullptr;</a>
<a name="ln563">    const auto&amp; policies = rep_-&gt;table_options.supported_filter_policies;</a>
<a name="ln564">    if (policies) {</a>
<a name="ln565">      const auto it = policies-&gt;find(table_filter_policy_name);</a>
<a name="ln566">      if (it != policies-&gt;end()) {</a>
<a name="ln567">        table_filter_policy = it-&gt;second.get();</a>
<a name="ln568">      }</a>
<a name="ln569">    }</a>
<a name="ln570">    if (!table_filter_policy) {</a>
<a name="ln571">      rep_-&gt;filter_policy = nullptr;</a>
<a name="ln572">      rep_-&gt;filter_key_transformer = nullptr;</a>
<a name="ln573">      const auto error_message = yb::Format(</a>
<a name="ln574">        &quot;Filter policy '$0' is not supported, not using use bloom filters for reading '$1'&quot;,</a>
<a name="ln575">          table_filter_policy_name,</a>
<a name="ln576">          rep_-&gt;base_reader_with_cache_prefix-&gt;reader-&gt;file()-&gt;filename());</a>
<a name="ln577">      RLOG(InfoLogLevel::ERROR_LEVEL, rep_-&gt;ioptions.info_log, error_message.c_str());</a>
<a name="ln578">      // For testing in debug build we want to fail in case some filter policy is not supported, but</a>
<a name="ln579">      // for production we prefer to continue operation with lower performance due to lack of</a>
<a name="ln580">      // supported bloom filters for this file. And eventually during compaction this file will</a>
<a name="ln581">      // be replaced and latest version of filter policy will be used.</a>
<a name="ln582">#ifndef NDEBUG</a>
<a name="ln583">      return STATUS(IllegalState, error_message);</a>
<a name="ln584">#else</a>
<a name="ln585">      return Status::OK();</a>
<a name="ln586">#endif</a>
<a name="ln587">    }</a>
<a name="ln588">    rep_-&gt;filter_policy = table_filter_policy;</a>
<a name="ln589">    rep_-&gt;filter_key_transformer = table_filter_policy-&gt;GetKeyTransformer();</a>
<a name="ln590">  }</a>
<a name="ln591"> </a>
<a name="ln592">  for (const auto&amp; prefix : {block_based_table::kFullFilterBlockPrefix,</a>
<a name="ln593">                             block_based_table::kFilterBlockPrefix,</a>
<a name="ln594">                             block_based_table::kFixedSizeFilterBlockPrefix}) {</a>
<a name="ln595">    // Unsuccessful read implies we should not use filter.</a>
<a name="ln596">    std::string filter_block_key = prefix;</a>
<a name="ln597">    filter_block_key.append(rep_-&gt;filter_policy-&gt;Name());</a>
<a name="ln598">    if (FindMetaBlock(meta_iter, filter_block_key, &amp;rep_-&gt;filter_handle).ok()) {</a>
<a name="ln599">      if (prefix == block_based_table::kFullFilterBlockPrefix) {</a>
<a name="ln600">        rep_-&gt;filter_type = FilterType::kFullFilter;</a>
<a name="ln601">      } else if (prefix == block_based_table::kFilterBlockPrefix) {</a>
<a name="ln602">        rep_-&gt;filter_type = FilterType::kBlockBasedFilter;</a>
<a name="ln603">      } else if (prefix == block_based_table::kFixedSizeFilterBlockPrefix) {</a>
<a name="ln604">        rep_-&gt;filter_type = FilterType::kFixedSizeFilter;</a>
<a name="ln605">      } else {</a>
<a name="ln606">        // That means we have memory corruption, so we should fail.</a>
<a name="ln607">        RLOG(</a>
<a name="ln608">            InfoLogLevel::FATAL_LEVEL, rep_-&gt;ioptions.info_log, &quot;Invalid filter block prefix: %s&quot;,</a>
<a name="ln609">            prefix);</a>
<a name="ln610">        assert(false);</a>
<a name="ln611">        return STATUS(Corruption, &quot;Invalid filter block prefix&quot;, prefix);</a>
<a name="ln612">      }</a>
<a name="ln613">      break;</a>
<a name="ln614">    }</a>
<a name="ln615">  }</a>
<a name="ln616"> </a>
<a name="ln617">  return Status::OK();</a>
<a name="ln618">}</a>
<a name="ln619"> </a>
<a name="ln620">void BlockBasedTable::SetDataFileReader(unique_ptr&lt;RandomAccessFileReader&gt; &amp;&amp;data_file) {</a>
<a name="ln621">  rep_-&gt;data_reader_with_cache_prefix =</a>
<a name="ln622">      std::make_shared&lt;FileReaderWithCachePrefix&gt;(std::move(data_file));</a>
<a name="ln623">  SetupCacheKeyPrefix(rep_, rep_-&gt;data_reader_with_cache_prefix.get());</a>
<a name="ln624">}</a>
<a name="ln625"> </a>
<a name="ln626">namespace {</a>
<a name="ln627">void SetupFileReaderForCompaction(const Options::AccessHint &amp;access_hint,</a>
<a name="ln628">    RandomAccessFileReader *reader) {</a>
<a name="ln629">  if (reader != nullptr) {</a>
<a name="ln630">    switch (access_hint) {</a>
<a name="ln631">      case Options::NONE:</a>
<a name="ln632">        break;</a>
<a name="ln633">      case Options::NORMAL:</a>
<a name="ln634">        reader-&gt;file()-&gt;Hint(RandomAccessFile::NORMAL);</a>
<a name="ln635">        break;</a>
<a name="ln636">      case Options::SEQUENTIAL:</a>
<a name="ln637">        reader-&gt;file()-&gt;Hint(RandomAccessFile::SEQUENTIAL);</a>
<a name="ln638">        break;</a>
<a name="ln639">      case Options::WILLNEED:</a>
<a name="ln640">        reader-&gt;file()-&gt;Hint(RandomAccessFile::WILLNEED);</a>
<a name="ln641">        break;</a>
<a name="ln642">      default:</a>
<a name="ln643">        assert(false);</a>
<a name="ln644">    }</a>
<a name="ln645">  }</a>
<a name="ln646">}</a>
<a name="ln647">} // anonymous namespace</a>
<a name="ln648"> </a>
<a name="ln649">void BlockBasedTable::SetupForCompaction() {</a>
<a name="ln650">  auto access_hint = rep_-&gt;ioptions.access_hint_on_compaction_start;</a>
<a name="ln651">  ::rocksdb::SetupFileReaderForCompaction(access_hint,</a>
<a name="ln652">      rep_-&gt;base_reader_with_cache_prefix-&gt;reader.get());</a>
<a name="ln653">  ::rocksdb::SetupFileReaderForCompaction(access_hint,</a>
<a name="ln654">      rep_-&gt;data_reader_with_cache_prefix-&gt;reader.get());</a>
<a name="ln655">}</a>
<a name="ln656"> </a>
<a name="ln657">std::shared_ptr&lt;const TableProperties&gt; BlockBasedTable::GetTableProperties()</a>
<a name="ln658">    const {</a>
<a name="ln659">  return rep_-&gt;table_properties;</a>
<a name="ln660">}</a>
<a name="ln661"> </a>
<a name="ln662">size_t BlockBasedTable::ApproximateMemoryUsage() const {</a>
<a name="ln663">  size_t usage = 0;</a>
<a name="ln664">  if (rep_-&gt;filter) {</a>
<a name="ln665">    usage += rep_-&gt;filter-&gt;ApproximateMemoryUsage();</a>
<a name="ln666">  }</a>
<a name="ln667">  if (rep_-&gt;filter_index_reader) {</a>
<a name="ln668">    usage += rep_-&gt;filter_index_reader-&gt;ApproximateMemoryUsage();</a>
<a name="ln669">  }</a>
<a name="ln670">  IndexReader* data_index_reader = rep_-&gt;data_index_reader.get(std::memory_order_relaxed);</a>
<a name="ln671">  if (data_index_reader) {</a>
<a name="ln672">    usage += data_index_reader-&gt;ApproximateMemoryUsage();</a>
<a name="ln673">  }</a>
<a name="ln674">  return usage;</a>
<a name="ln675">}</a>
<a name="ln676"> </a>
<a name="ln677">// Load the meta-block from the file. On success, return the loaded meta block</a>
<a name="ln678">// and its iterator.</a>
<a name="ln679">Status BlockBasedTable::ReadMetaBlock(Rep* rep,</a>
<a name="ln680">                                      std::unique_ptr&lt;Block&gt;* meta_block,</a>
<a name="ln681">                                      std::unique_ptr&lt;InternalIterator&gt;* iter) {</a>
<a name="ln682">  // TODO(sanjay): Skip this if footer.metaindex_handle() size indicates</a>
<a name="ln683">  // it is an empty block.</a>
<a name="ln684">  // TODO: we never really verify check sum for meta index block</a>
<a name="ln685">  std::unique_ptr&lt;Block&gt; meta;</a>
<a name="ln686">  Status s = block_based_table::ReadBlockFromFile(</a>
<a name="ln687">      rep-&gt;base_reader_with_cache_prefix-&gt;reader.get(),</a>
<a name="ln688">      rep-&gt;footer,</a>
<a name="ln689">      ReadOptions::kDefault,</a>
<a name="ln690">      rep-&gt;footer.metaindex_handle(),</a>
<a name="ln691">      &amp;meta,</a>
<a name="ln692">      rep-&gt;ioptions.env,</a>
<a name="ln693">      rep-&gt;mem_tracker);</a>
<a name="ln694"> </a>
<a name="ln695">  if (!s.ok()) {</a>
<a name="ln696">    RLOG(InfoLogLevel::ERROR_LEVEL, rep-&gt;ioptions.info_log,</a>
<a name="ln697">        &quot;Encountered error while reading data from properties&quot;</a>
<a name="ln698">        &quot; block %s&quot;, s.ToString().c_str());</a>
<a name="ln699">    return s;</a>
<a name="ln700">  }</a>
<a name="ln701"> </a>
<a name="ln702">  *meta_block = std::move(meta);</a>
<a name="ln703">  // meta block uses bytewise comparator.</a>
<a name="ln704">  iter-&gt;reset(meta_block-&gt;get()-&gt;NewIterator(BytewiseComparator()));</a>
<a name="ln705">  return Status::OK();</a>
<a name="ln706">}</a>
<a name="ln707"> </a>
<a name="ln708">namespace {</a>
<a name="ln709"> </a>
<a name="ln710">Tickers GetBlockCacheMissTicker(BlockType block_type) {</a>
<a name="ln711">  switch (block_type) {</a>
<a name="ln712">    case BlockType::kData:</a>
<a name="ln713">      return BLOCK_CACHE_DATA_MISS;</a>
<a name="ln714">    case BlockType::kIndex:</a>
<a name="ln715">      return BLOCK_CACHE_INDEX_MISS;</a>
<a name="ln716">  }</a>
<a name="ln717">  FATAL_INVALID_ENUM_VALUE(BlockType, block_type);</a>
<a name="ln718">}</a>
<a name="ln719"> </a>
<a name="ln720">Tickers GetBlockCacheHitTicker(BlockType block_type) {</a>
<a name="ln721">  switch (block_type) {</a>
<a name="ln722">    case BlockType::kData:</a>
<a name="ln723">      return BLOCK_CACHE_DATA_HIT;</a>
<a name="ln724">    case BlockType::kIndex:</a>
<a name="ln725">      return BLOCK_CACHE_INDEX_HIT;</a>
<a name="ln726">  }</a>
<a name="ln727">  FATAL_INVALID_ENUM_VALUE(BlockType, block_type);</a>
<a name="ln728">}</a>
<a name="ln729"> </a>
<a name="ln730">} // namespace</a>
<a name="ln731"> </a>
<a name="ln732">Status BlockBasedTable::GetDataBlockFromCache(</a>
<a name="ln733">    const Slice&amp; block_cache_key, const Slice&amp; compressed_block_cache_key,</a>
<a name="ln734">    Cache* block_cache, Cache* block_cache_compressed, Statistics* statistics,</a>
<a name="ln735">    const ReadOptions&amp; read_options, BlockBasedTable::CachableEntry&lt;Block&gt;* block,</a>
<a name="ln736">    uint32_t format_version, BlockType block_type,</a>
<a name="ln737">    const std::shared_ptr&lt;yb::MemTracker&gt;&amp; mem_tracker) {</a>
<a name="ln738">  Status s;</a>
<a name="ln739">  Block* compressed_block = nullptr;</a>
<a name="ln740">  Cache::Handle* block_cache_compressed_handle = nullptr;</a>
<a name="ln741"> </a>
<a name="ln742">  // Lookup uncompressed cache first</a>
<a name="ln743">  if (block_cache != nullptr) {</a>
<a name="ln744">    block-&gt;cache_handle =</a>
<a name="ln745">        GetEntryFromCache(</a>
<a name="ln746">            block_cache, block_cache_key, GetBlockCacheMissTicker(block_type),</a>
<a name="ln747">            GetBlockCacheHitTicker(block_type), statistics, read_options.query_id);</a>
<a name="ln748">    if (block-&gt;cache_handle != nullptr) {</a>
<a name="ln749">      block-&gt;value =</a>
<a name="ln750">          static_cast&lt;Block*&gt;(block_cache-&gt;Value(block-&gt;cache_handle));</a>
<a name="ln751">      return s;</a>
<a name="ln752">    }</a>
<a name="ln753">  }</a>
<a name="ln754"> </a>
<a name="ln755">  // If not found, search from the compressed block cache.</a>
<a name="ln756">  assert(block-&gt;cache_handle == nullptr &amp;&amp; block-&gt;value == nullptr);</a>
<a name="ln757"> </a>
<a name="ln758">  if (block_cache_compressed == nullptr) {</a>
<a name="ln759">    return s;</a>
<a name="ln760">  }</a>
<a name="ln761"> </a>
<a name="ln762">  assert(!compressed_block_cache_key.empty());</a>
<a name="ln763">  block_cache_compressed_handle =</a>
<a name="ln764">      block_cache_compressed-&gt;Lookup(compressed_block_cache_key, read_options.query_id);</a>
<a name="ln765">  // if we found in the compressed cache, then uncompress and insert into</a>
<a name="ln766">  // uncompressed cache</a>
<a name="ln767">  if (block_cache_compressed_handle == nullptr) {</a>
<a name="ln768">    RecordTick(statistics, BLOCK_CACHE_COMPRESSED_MISS);</a>
<a name="ln769">    return s;</a>
<a name="ln770">  }</a>
<a name="ln771"> </a>
<a name="ln772">  // found compressed block</a>
<a name="ln773">  RecordTick(statistics, BLOCK_CACHE_COMPRESSED_HIT);</a>
<a name="ln774">  compressed_block = static_cast&lt;Block*&gt;(</a>
<a name="ln775">      block_cache_compressed-&gt;Value(block_cache_compressed_handle));</a>
<a name="ln776">  assert(compressed_block-&gt;compression_type() != kNoCompression);</a>
<a name="ln777"> </a>
<a name="ln778">  // Retrieve the uncompressed contents into a new buffer</a>
<a name="ln779">  BlockContents contents;</a>
<a name="ln780">  s = UncompressBlockContents(compressed_block-&gt;data(), compressed_block-&gt;size(), &amp;contents,</a>
<a name="ln781">                              format_version, mem_tracker);</a>
<a name="ln782"> </a>
<a name="ln783">  // Insert uncompressed block into block cache</a>
<a name="ln784">  if (s.ok()) {</a>
<a name="ln785">    block-&gt;value = new Block(std::move(contents));  // uncompressed block</a>
<a name="ln786">    assert(block-&gt;value-&gt;compression_type() == kNoCompression);</a>
<a name="ln787">    if (block_cache != nullptr &amp;&amp; block-&gt;value-&gt;cachable() &amp;&amp;</a>
<a name="ln788">        read_options.fill_cache) {</a>
<a name="ln789">      s = block_cache-&gt;Insert(block_cache_key, read_options.query_id, block-&gt;value,</a>
<a name="ln790">                              block-&gt;value-&gt;usable_size(), &amp;DeleteCachedEntry&lt;Block&gt;,</a>
<a name="ln791">                              &amp;block-&gt;cache_handle, statistics);</a>
<a name="ln792">      if (!s.ok()) {</a>
<a name="ln793">        delete block-&gt;value;</a>
<a name="ln794">        block-&gt;value = nullptr;</a>
<a name="ln795">      }</a>
<a name="ln796">    }</a>
<a name="ln797">  }</a>
<a name="ln798"> </a>
<a name="ln799">  // Release hold on compressed cache entry</a>
<a name="ln800">  block_cache_compressed-&gt;Release(block_cache_compressed_handle);</a>
<a name="ln801">  return s;</a>
<a name="ln802">}</a>
<a name="ln803"> </a>
<a name="ln804">Status BlockBasedTable::PutDataBlockToCache(</a>
<a name="ln805">    const Slice&amp; block_cache_key, const Slice&amp; compressed_block_cache_key,</a>
<a name="ln806">    Cache* block_cache, Cache* block_cache_compressed,</a>
<a name="ln807">    const ReadOptions&amp; read_options, Statistics* statistics,</a>
<a name="ln808">    CachableEntry&lt;Block&gt;* block, Block* raw_block, uint32_t format_version,</a>
<a name="ln809">    const std::shared_ptr&lt;yb::MemTracker&gt;&amp; mem_tracker) {</a>
<a name="ln810">  assert(raw_block-&gt;compression_type() == kNoCompression ||</a>
<a name="ln811">         block_cache_compressed != nullptr);</a>
<a name="ln812"> </a>
<a name="ln813">  Status s;</a>
<a name="ln814">  // Retrieve the uncompressed contents into a new buffer</a>
<a name="ln815">  BlockContents contents;</a>
<a name="ln816">  if (raw_block-&gt;compression_type() != kNoCompression) {</a>
<a name="ln817">    s = UncompressBlockContents(raw_block-&gt;data(), raw_block-&gt;size(), &amp;contents,</a>
<a name="ln818">                                format_version, mem_tracker);</a>
<a name="ln819">  }</a>
<a name="ln820">  if (!s.ok()) {</a>
<a name="ln821">    delete raw_block;</a>
<a name="ln822">    return s;</a>
<a name="ln823">  }</a>
<a name="ln824"> </a>
<a name="ln825">  if (raw_block-&gt;compression_type() != kNoCompression) {</a>
<a name="ln826">    block-&gt;value = new Block(std::move(contents));  // uncompressed block</a>
<a name="ln827">  } else {</a>
<a name="ln828">    block-&gt;value = raw_block;</a>
<a name="ln829">    raw_block = nullptr;</a>
<a name="ln830">  }</a>
<a name="ln831"> </a>
<a name="ln832">  // Insert compressed block into compressed block cache.</a>
<a name="ln833">  // Release the hold on the compressed cache entry immediately.</a>
<a name="ln834">  if (block_cache_compressed != nullptr &amp;&amp; raw_block != nullptr &amp;&amp;</a>
<a name="ln835">      raw_block-&gt;cachable()) {</a>
<a name="ln836">    s = block_cache_compressed-&gt;Insert(compressed_block_cache_key, read_options.query_id, raw_block,</a>
<a name="ln837">                                       raw_block-&gt;usable_size(), &amp;DeleteCachedEntry&lt;Block&gt;);</a>
<a name="ln838">    if (s.ok()) {</a>
<a name="ln839">      // Avoid the following code to delete this cached block.</a>
<a name="ln840">      raw_block = nullptr;</a>
<a name="ln841">      RecordTick(statistics, BLOCK_CACHE_COMPRESSED_ADD);</a>
<a name="ln842">    } else {</a>
<a name="ln843">      RecordTick(statistics, BLOCK_CACHE_COMPRESSED_ADD_FAILURES);</a>
<a name="ln844">    }</a>
<a name="ln845">  }</a>
<a name="ln846">  delete raw_block;</a>
<a name="ln847"> </a>
<a name="ln848">  // insert into uncompressed block cache</a>
<a name="ln849">  assert((block-&gt;value-&gt;compression_type() == kNoCompression));</a>
<a name="ln850">  if (block_cache != nullptr &amp;&amp; block-&gt;value-&gt;cachable()) {</a>
<a name="ln851">    s = block_cache-&gt;Insert(block_cache_key, read_options.query_id, block-&gt;value,</a>
<a name="ln852">                            block-&gt;value-&gt;usable_size(),</a>
<a name="ln853">                            &amp;DeleteCachedEntry&lt;Block&gt;, &amp;block-&gt;cache_handle, statistics);</a>
<a name="ln854">    if (!s.ok()) {</a>
<a name="ln855">      delete block-&gt;value;</a>
<a name="ln856">      block-&gt;value = nullptr;</a>
<a name="ln857">    }</a>
<a name="ln858">  }</a>
<a name="ln859"> </a>
<a name="ln860">  return s;</a>
<a name="ln861">}</a>
<a name="ln862"> </a>
<a name="ln863">Status BlockBasedTable::CreateFilterIndexReader(std::unique_ptr&lt;IndexReader&gt;* filter_index_reader) {</a>
<a name="ln864">  auto base_file_reader = rep_-&gt;base_reader_with_cache_prefix-&gt;reader.get();</a>
<a name="ln865">  auto env = rep_-&gt;ioptions.env;</a>
<a name="ln866">  auto footer = rep_-&gt;footer;</a>
<a name="ln867">  return BinarySearchIndexReader::Create(base_file_reader, footer, rep_-&gt;filter_handle, env,</a>
<a name="ln868">      SharedBytewiseComparator(), filter_index_reader, rep_-&gt;mem_tracker);</a>
<a name="ln869">}</a>
<a name="ln870"> </a>
<a name="ln871">FilterBlockReader* BlockBasedTable::ReadFilterBlock(const BlockHandle&amp; filter_handle, Rep* rep,</a>
<a name="ln872">    size_t* filter_size) {</a>
<a name="ln873">  // TODO: We might want to unify with ReadBlockFromFile() if we start</a>
<a name="ln874">  // requiring checksum verification in Table::Open.</a>
<a name="ln875">  if (rep-&gt;filter_type == FilterType::kNoFilter) {</a>
<a name="ln876">    return nullptr;</a>
<a name="ln877">  }</a>
<a name="ln878">  BlockContents block;</a>
<a name="ln879">  if (!ReadBlockContents(</a>
<a name="ln880">           rep-&gt;base_reader_with_cache_prefix-&gt;reader.get(), rep-&gt;footer, ReadOptions::kDefault,</a>
<a name="ln881">           filter_handle, &amp;block, rep-&gt;ioptions.env, rep-&gt;mem_tracker, false).ok()) {</a>
<a name="ln882">    // Error reading the block</a>
<a name="ln883">    return nullptr;</a>
<a name="ln884">  }</a>
<a name="ln885"> </a>
<a name="ln886">  if (filter_size) {</a>
<a name="ln887">    *filter_size = block.data.size();</a>
<a name="ln888">  }</a>
<a name="ln889"> </a>
<a name="ln890">  assert(rep-&gt;filter_policy);</a>
<a name="ln891"> </a>
<a name="ln892">  switch (rep-&gt;filter_type) {</a>
<a name="ln893">    case FilterType::kNoFilter:</a>
<a name="ln894">      // Shouldn't happen, since we already checked for that above. In case of memory corruption</a>
<a name="ln895">      // will be caught after switch statement.</a>
<a name="ln896">      break;</a>
<a name="ln897">    case FilterType::kBlockBasedFilter:</a>
<a name="ln898">      return new BlockBasedFilterBlockReader(</a>
<a name="ln899">          rep-&gt;prefix_filtering ? rep-&gt;ioptions.prefix_extractor : nullptr,</a>
<a name="ln900">          rep-&gt;table_options, rep-&gt;whole_key_filtering, std::move(block));</a>
<a name="ln901">    case FilterType::kFullFilter: {</a>
<a name="ln902">      auto filter_bits_reader = rep-&gt;filter_policy-&gt;GetFilterBitsReader(block.data);</a>
<a name="ln903">      assert(filter_bits_reader);</a>
<a name="ln904">      return new FullFilterBlockReader(</a>
<a name="ln905">          rep-&gt;prefix_filtering ? rep-&gt;ioptions.prefix_extractor : nullptr,</a>
<a name="ln906">          rep-&gt;whole_key_filtering, std::move(block), filter_bits_reader);</a>
<a name="ln907">    }</a>
<a name="ln908">    case FilterType::kFixedSizeFilter:</a>
<a name="ln909">      return new FixedSizeFilterBlockReader(</a>
<a name="ln910">          rep-&gt;prefix_filtering ? rep-&gt;ioptions.prefix_extractor : nullptr,</a>
<a name="ln911">          rep-&gt;table_options, rep-&gt;whole_key_filtering, std::move(block));</a>
<a name="ln912">      break;</a>
<a name="ln913">  }</a>
<a name="ln914">  RLOG(InfoLogLevel::FATAL_LEVEL, rep-&gt;ioptions.info_log, &quot;Corrupted filter_type: %d&quot;,</a>
<a name="ln915">      rep-&gt;filter_type);</a>
<a name="ln916">  return nullptr;</a>
<a name="ln917">}</a>
<a name="ln918"> </a>
<a name="ln919">Status BlockBasedTable::GetFixedSizeFilterBlockHandle(const Slice&amp; filter_key,</a>
<a name="ln920">    BlockHandle* filter_block_handle) const {</a>
<a name="ln921">  // Determine block of fixed-size bloom filter using filter index.</a>
<a name="ln922">  BlockIter fiter;</a>
<a name="ln923">  rep_-&gt;filter_index_reader-&gt;NewIterator(&amp;fiter,</a>
<a name="ln924">      // Following parameters are ignored by BinarySearchIndexReader which we use as</a>
<a name="ln925">      // filter_index_reader.</a>
<a name="ln926">      nullptr /* index_iterator_state */, true /* total_order_seek */);</a>
<a name="ln927">  fiter.Seek(filter_key);</a>
<a name="ln928">  if (fiter.Valid()) {</a>
<a name="ln929">    Slice filter_block_handle_encoded = fiter.value();</a>
<a name="ln930">    return filter_block_handle-&gt;DecodeFrom(&amp;filter_block_handle_encoded);</a>
<a name="ln931">  } else {</a>
<a name="ln932">    // We are beyond the index, that means key is absent in filter, we use null block handle</a>
<a name="ln933">    // stub to indicate that.</a>
<a name="ln934">    filter_block_handle-&gt;set_offset(0);</a>
<a name="ln935">    filter_block_handle-&gt;set_size(0);</a>
<a name="ln936">    return Status::OK();</a>
<a name="ln937">  }</a>
<a name="ln938">}</a>
<a name="ln939"> </a>
<a name="ln940">Slice BlockBasedTable::GetFilterKeyFromInternalKey(const Slice &amp;internal_key) const {</a>
<a name="ln941">  return GetFilterKeyFromUserKey(ExtractUserKey(internal_key));</a>
<a name="ln942">}</a>
<a name="ln943"> </a>
<a name="ln944">Slice BlockBasedTable::GetFilterKeyFromUserKey(const Slice &amp;user_key) const {</a>
<a name="ln945">  return rep_-&gt;filter_key_transformer ?</a>
<a name="ln946">      rep_-&gt;filter_key_transformer-&gt;Transform(user_key) : user_key;</a>
<a name="ln947">}</a>
<a name="ln948"> </a>
<a name="ln949">BlockBasedTable::CachableEntry&lt;FilterBlockReader&gt; BlockBasedTable::GetFilter(</a>
<a name="ln950">    const QueryId query_id,</a>
<a name="ln951">    bool no_io,</a>
<a name="ln952">    const Slice* filter_key) const {</a>
<a name="ln953">  const bool is_fixed_size_filter = rep_-&gt;filter_type == FilterType::kFixedSizeFilter;</a>
<a name="ln954"> </a>
<a name="ln955">  // Key is required for fixed size filter.</a>
<a name="ln956">  assert(!is_fixed_size_filter || filter_key != nullptr);</a>
<a name="ln957"> </a>
<a name="ln958">  // If cache_index_and_filter_blocks is false, filter (except fixed-size filter) should be</a>
<a name="ln959">  // pre-populated.</a>
<a name="ln960">  // We will return rep_-&gt;filter anyway. rep_-&gt;filter can be nullptr if filter</a>
<a name="ln961">  // read fails at Open() time. We don't want to reload again since it will</a>
<a name="ln962">  // most probably fail again.</a>
<a name="ln963">  // Note: rep_-&gt;filter can be nullptr also if Open was called with</a>
<a name="ln964">  // prefetch_index_and_filter == false. That means bloom filters are not be used if</a>
<a name="ln965">  // both prefetch_index_and_filter and table_options.cache_index_and_filter_blocks are false.</a>
<a name="ln966">  if (!rep_-&gt;table_options.cache_index_and_filter_blocks &amp;&amp; !is_fixed_size_filter) {</a>
<a name="ln967">    return {rep_-&gt;filter.get(), nullptr /* cache handle */};</a>
<a name="ln968">  }</a>
<a name="ln969"> </a>
<a name="ln970">  PERF_TIMER_GUARD(read_filter_block_nanos);</a>
<a name="ln971"> </a>
<a name="ln972">  Cache* block_cache = rep_-&gt;table_options.block_cache.get();</a>
<a name="ln973">  if (rep_-&gt;filter_policy == nullptr /* do not use filter */ ||</a>
<a name="ln974">      block_cache == nullptr /* no block cache at all */) {</a>
<a name="ln975">    // If we get here, we have:</a>
<a name="ln976">    // table_options.cache_index_and_filter_blocks || is_fixed_size_filter</a>
<a name="ln977">    // table_options.block_cache == nullptr</a>
<a name="ln978">    return {nullptr /* filter */, nullptr /* cache handle */};</a>
<a name="ln979">  }</a>
<a name="ln980"> </a>
<a name="ln981">  const BlockHandle* filter_block_handle;</a>
<a name="ln982">  // Determine filter block handle</a>
<a name="ln983">  BlockHandle fixed_size_filter_block_handle;</a>
<a name="ln984">  if (is_fixed_size_filter) {</a>
<a name="ln985">    Status s = GetFixedSizeFilterBlockHandle(*filter_key, &amp;fixed_size_filter_block_handle);</a>
<a name="ln986">    if (s.ok()) {</a>
<a name="ln987">      if (fixed_size_filter_block_handle.IsNull()) {</a>
<a name="ln988">        // Key is beyond filter index - return stub filter.</a>
<a name="ln989">        return rep_-&gt;not_matching_filter_entry;</a>
<a name="ln990">      }</a>
<a name="ln991">      filter_block_handle = &amp;fixed_size_filter_block_handle;</a>
<a name="ln992">    } else {</a>
<a name="ln993">      // If we failed to decode filter block handle from filter index we will just log error in</a>
<a name="ln994">      // production to continue operation in case of just filter corruption,</a>
<a name="ln995">      // but we should fail in debug and under tests to be able to catch possible bugs.</a>
<a name="ln996">      RLOG(InfoLogLevel::ERROR_LEVEL, rep_-&gt;ioptions.info_log,</a>
<a name="ln997">          &quot;Failed to decode fixed-size filter block handle from filter index.&quot;);</a>
<a name="ln998">      FAIL_IF_NOT_PRODUCTION();</a>
<a name="ln999">      return {nullptr /* filter */, nullptr /* cache handle */};</a>
<a name="ln1000">    }</a>
<a name="ln1001">  } else {</a>
<a name="ln1002">    filter_block_handle = &amp;rep_-&gt;filter_handle;</a>
<a name="ln1003">  }</a>
<a name="ln1004"> </a>
<a name="ln1005">  // Fetching from the cache</a>
<a name="ln1006">  char cache_key_buffer[block_based_table::kCacheKeyBufferSize];</a>
<a name="ln1007">  auto filter_block_cache_key = GetCacheKey(rep_-&gt;base_reader_with_cache_prefix-&gt;cache_key_prefix,</a>
<a name="ln1008">      *filter_block_handle, cache_key_buffer);</a>
<a name="ln1009"> </a>
<a name="ln1010">  Statistics* statistics = rep_-&gt;ioptions.statistics;</a>
<a name="ln1011">  auto cache_handle = GetEntryFromCache(block_cache, filter_block_cache_key,</a>
<a name="ln1012">      BLOCK_CACHE_FILTER_MISS, BLOCK_CACHE_FILTER_HIT, statistics, query_id);</a>
<a name="ln1013"> </a>
<a name="ln1014">  FilterBlockReader* filter = nullptr;</a>
<a name="ln1015">  if (cache_handle != nullptr) {</a>
<a name="ln1016">    filter = static_cast&lt;FilterBlockReader*&gt;(block_cache-&gt;Value(cache_handle));</a>
<a name="ln1017">  } else if (no_io &amp;&amp; rep_-&gt;filter_type != FilterType::kFixedSizeFilter) {</a>
<a name="ln1018">    // Do not invoke any io.</a>
<a name="ln1019">    return CachableEntry&lt;FilterBlockReader&gt;();</a>
<a name="ln1020">  } else {</a>
<a name="ln1021">    // For fixed-size filter we don't prefetch all filter blocks and ignore no_io parameter always</a>
<a name="ln1022">    // loading necessary filter block through block cache.</a>
<a name="ln1023">    size_t filter_size = 0;</a>
<a name="ln1024">    filter = ReadFilterBlock(*filter_block_handle, rep_, &amp;filter_size);</a>
<a name="ln1025">    if (filter != nullptr) {</a>
<a name="ln1026">      assert(filter_size &gt; 0);</a>
<a name="ln1027">      Status s = block_cache-&gt;Insert(filter_block_cache_key, query_id,</a>
<a name="ln1028">                                     filter, filter_size,</a>
<a name="ln1029">                                     &amp;DeleteCachedEntry&lt;FilterBlockReader&gt;, &amp;cache_handle,</a>
<a name="ln1030">                                     statistics);</a>
<a name="ln1031">      if (!s.ok()) {</a>
<a name="ln1032">        delete filter;</a>
<a name="ln1033">        return CachableEntry&lt;FilterBlockReader&gt;();</a>
<a name="ln1034">      }</a>
<a name="ln1035">    }</a>
<a name="ln1036">  }</a>
<a name="ln1037"> </a>
<a name="ln1038">  return { filter, cache_handle };</a>
<a name="ln1039">}</a>
<a name="ln1040"> </a>
<a name="ln1041">namespace {</a>
<a name="ln1042"> </a>
<a name="ln1043">InternalIterator* ReturnErrorIterator(const Status&amp; status, BlockIter* input_iter) {</a>
<a name="ln1044">  if (input_iter != nullptr) {</a>
<a name="ln1045">    input_iter-&gt;SetStatus(status);</a>
<a name="ln1046">    return input_iter;</a>
<a name="ln1047">  } else {</a>
<a name="ln1048">    return NewErrorInternalIterator(status);</a>
<a name="ln1049">  }</a>
<a name="ln1050">}</a>
<a name="ln1051"> </a>
<a name="ln1052">Status ReturnNoIOError() {</a>
<a name="ln1053">  return STATUS(Incomplete, &quot;no blocking io&quot;);</a>
<a name="ln1054">}</a>
<a name="ln1055"> </a>
<a name="ln1056">} // namespace</a>
<a name="ln1057"> </a>
<a name="ln1058">yb::Result&lt;BlockBasedTable::CachableEntry&lt;IndexReader&gt;&gt; BlockBasedTable::GetIndexReader(</a>
<a name="ln1059">    const ReadOptions&amp; read_options) {</a>
<a name="ln1060">  auto* index_reader = rep_-&gt;data_index_reader.get(std::memory_order_acquire);</a>
<a name="ln1061">  if (index_reader) {</a>
<a name="ln1062">    // Index reader has already been pre-populated.</a>
<a name="ln1063">    return BlockBasedTable::CachableEntry&lt;IndexReader&gt;{index_reader, /* cache_handle =*/ nullptr};</a>
<a name="ln1064">  }</a>
<a name="ln1065">  PERF_TIMER_GUARD(read_index_block_nanos);</a>
<a name="ln1066"> </a>
<a name="ln1067">  const bool no_io = read_options.read_tier == kBlockCacheTier;</a>
<a name="ln1068">  Cache* const block_cache = rep_-&gt;table_options.block_cache.get();</a>
<a name="ln1069"> </a>
<a name="ln1070">  if (block_cache &amp;&amp; (rep_-&gt;data_index_load_mode == DataIndexLoadMode::USE_CACHE ||</a>
<a name="ln1071">      rep_-&gt;table_options.cache_index_and_filter_blocks)) {</a>
<a name="ln1072">    char cache_key[block_based_table::kCacheKeyBufferSize];</a>
<a name="ln1073">    auto key = GetCacheKey(rep_-&gt;base_reader_with_cache_prefix-&gt;cache_key_prefix,</a>
<a name="ln1074">        rep_-&gt;footer.index_handle(), cache_key);</a>
<a name="ln1075">    Statistics* statistics = rep_-&gt;ioptions.statistics;</a>
<a name="ln1076">    auto cache_handle =</a>
<a name="ln1077">        GetEntryFromCache(block_cache, key, BLOCK_CACHE_INDEX_MISS,</a>
<a name="ln1078">            BLOCK_CACHE_INDEX_HIT, statistics, read_options.query_id);</a>
<a name="ln1079"> </a>
<a name="ln1080">    if (cache_handle == nullptr &amp;&amp; no_io) {</a>
<a name="ln1081">      return ReturnNoIOError();</a>
<a name="ln1082">    }</a>
<a name="ln1083"> </a>
<a name="ln1084">    if (cache_handle != nullptr) {</a>
<a name="ln1085">      index_reader = static_cast&lt;IndexReader*&gt;(block_cache-&gt;Value(cache_handle));</a>
<a name="ln1086">    } else {</a>
<a name="ln1087">      // Create index reader and put it in the cache.</a>
<a name="ln1088">      std::unique_ptr&lt;IndexReader&gt; index_reader_unique;</a>
<a name="ln1089">      RETURN_NOT_OK(CreateDataBlockIndexReader(&amp;index_reader_unique));</a>
<a name="ln1090">      RETURN_NOT_OK(block_cache-&gt;Insert(</a>
<a name="ln1091">          key, read_options.query_id, index_reader_unique.get(), index_reader_unique-&gt;usable_size(),</a>
<a name="ln1092">          &amp;DeleteCachedEntry&lt;IndexReader&gt;, &amp;cache_handle, statistics));</a>
<a name="ln1093">      assert(cache_handle);</a>
<a name="ln1094">      index_reader = index_reader_unique.release();</a>
<a name="ln1095">    }</a>
<a name="ln1096"> </a>
<a name="ln1097">    return BlockBasedTable::CachableEntry&lt;IndexReader&gt;{index_reader, cache_handle};</a>
<a name="ln1098">  } else {</a>
<a name="ln1099">    if (no_io) {</a>
<a name="ln1100">      return ReturnNoIOError();</a>
<a name="ln1101">    }</a>
<a name="ln1102">    // Note that we've already performed first check at the beginning of method.</a>
<a name="ln1103">    std::lock_guard&lt;std::mutex&gt; lock(rep_-&gt;data_index_reader_mutex);</a>
<a name="ln1104">    index_reader = rep_-&gt;data_index_reader.get(std::memory_order_relaxed);</a>
<a name="ln1105">    if (!index_reader) {</a>
<a name="ln1106">      // preloaded_meta_index_iter is not needed for kBinarySearch data index which DocDB uses,</a>
<a name="ln1107">      // for kHashSearch data index it will do one more access to file to load it.</a>
<a name="ln1108">      // TODO: if we need to optimize kHashSearch data index load, we can preload and store in</a>
<a name="ln1109">      // rep_ meta index with iterator during Open.</a>
<a name="ln1110">      std::unique_ptr&lt;IndexReader&gt; index_reader_holder;</a>
<a name="ln1111">      RETURN_NOT_OK(CreateDataBlockIndexReader(</a>
<a name="ln1112">          &amp;index_reader_holder, /* preloaded_meta_index_iter =*/ nullptr));</a>
<a name="ln1113">      index_reader = index_reader_holder.release();</a>
<a name="ln1114">      rep_-&gt;data_index_reader.reset(index_reader, std::memory_order_acq_rel);</a>
<a name="ln1115">    }</a>
<a name="ln1116">    return BlockBasedTable::CachableEntry&lt;IndexReader&gt;{index_reader, /* cache_handle =*/ nullptr};</a>
<a name="ln1117">  }</a>
<a name="ln1118">}</a>
<a name="ln1119"> </a>
<a name="ln1120">InternalIterator* BlockBasedTable::NewIndexIterator(</a>
<a name="ln1121">    const ReadOptions&amp; read_options, BlockIter* input_iter) {</a>
<a name="ln1122">  const auto index_reader_result = GetIndexReader(read_options);</a>
<a name="ln1123">  if (!index_reader_result.ok()) {</a>
<a name="ln1124">    return ReturnErrorIterator(index_reader_result.status(), input_iter);</a>
<a name="ln1125">  }</a>
<a name="ln1126"> </a>
<a name="ln1127">  auto* new_iter = index_reader_result-&gt;value-&gt;NewIterator(</a>
<a name="ln1128">      input_iter, rep_-&gt;data_index_iterator_state.get(), read_options.total_order_seek);</a>
<a name="ln1129"> </a>
<a name="ln1130">  if (index_reader_result-&gt;cache_handle) {</a>
<a name="ln1131">    auto iter = new_iter ? new_iter : input_iter;</a>
<a name="ln1132">    iter-&gt;RegisterCleanup(</a>
<a name="ln1133">        &amp;ReleaseCachedEntry, rep_-&gt;table_options.block_cache.get(),</a>
<a name="ln1134">        index_reader_result-&gt;cache_handle);</a>
<a name="ln1135">  }</a>
<a name="ln1136"> </a>
<a name="ln1137">  return new_iter;</a>
<a name="ln1138">}</a>
<a name="ln1139"> </a>
<a name="ln1140">// Convert an index iterator value (i.e., an encoded BlockHandle)</a>
<a name="ln1141">// into an iterator over the contents of the corresponding block.</a>
<a name="ln1142">// If input_iter is null, new a iterator</a>
<a name="ln1143">// If input_iter is not null, update this iter and return it</a>
<a name="ln1144">InternalIterator* BlockBasedTable::NewDataBlockIterator(const ReadOptions&amp; ro,</a>
<a name="ln1145">    const Slice&amp; index_value, BlockType block_type, BlockIter* input_iter) {</a>
<a name="ln1146">  PERF_TIMER_GUARD(new_table_block_iter_nanos);</a>
<a name="ln1147"> </a>
<a name="ln1148">  const bool no_io = (ro.read_tier == kBlockCacheTier);</a>
<a name="ln1149">  Cache* block_cache = rep_-&gt;table_options.block_cache.get();</a>
<a name="ln1150">  Cache* block_cache_compressed =</a>
<a name="ln1151">      rep_-&gt;table_options.block_cache_compressed.get();</a>
<a name="ln1152">  CachableEntry&lt;Block&gt; block;</a>
<a name="ln1153"> </a>
<a name="ln1154">  BlockHandle handle;</a>
<a name="ln1155">  Slice input = index_value;</a>
<a name="ln1156">  // We intentionally allow extra stuff in index_value so that we</a>
<a name="ln1157">  // can add more features in the future.</a>
<a name="ln1158">  Status s = handle.DecodeFrom(&amp;input);</a>
<a name="ln1159"> </a>
<a name="ln1160">  if (!s.ok()) {</a>
<a name="ln1161">    if (input_iter != nullptr) {</a>
<a name="ln1162">      input_iter-&gt;SetStatus(s);</a>
<a name="ln1163">      return input_iter;</a>
<a name="ln1164">    } else {</a>
<a name="ln1165">      return NewErrorInternalIterator(s);</a>
<a name="ln1166">    }</a>
<a name="ln1167">  }</a>
<a name="ln1168"> </a>
<a name="ln1169">  FileReaderWithCachePrefix* reader = GetBlockReader(block_type);</a>
<a name="ln1170"> </a>
<a name="ln1171">  // If either block cache is enabled, we'll try to read from it.</a>
<a name="ln1172">  if (block_cache != nullptr || block_cache_compressed != nullptr) {</a>
<a name="ln1173">    Statistics* statistics = rep_-&gt;ioptions.statistics;</a>
<a name="ln1174">    char cache_key[block_based_table::kCacheKeyBufferSize];</a>
<a name="ln1175">    char compressed_cache_key[block_based_table::kCacheKeyBufferSize];</a>
<a name="ln1176">    Slice key, /* key to the block cache */</a>
<a name="ln1177">        ckey /* key to the compressed block cache */;</a>
<a name="ln1178"> </a>
<a name="ln1179">    // create key for block cache</a>
<a name="ln1180">    if (block_cache != nullptr) {</a>
<a name="ln1181">      key = GetCacheKey(reader-&gt;cache_key_prefix, handle, cache_key);</a>
<a name="ln1182">    }</a>
<a name="ln1183"> </a>
<a name="ln1184">    if (block_cache_compressed != nullptr) {</a>
<a name="ln1185">      ckey = GetCacheKey(reader-&gt;compressed_cache_key_prefix, handle, compressed_cache_key);</a>
<a name="ln1186">    }</a>
<a name="ln1187"> </a>
<a name="ln1188">    s = GetDataBlockFromCache(</a>
<a name="ln1189">        key, ckey, block_cache, block_cache_compressed, statistics, ro, &amp;block,</a>
<a name="ln1190">        rep_-&gt;table_options.format_version, block_type, rep_-&gt;mem_tracker);</a>
<a name="ln1191"> </a>
<a name="ln1192">    if (block.value == nullptr &amp;&amp; !no_io &amp;&amp; ro.fill_cache) {</a>
<a name="ln1193">      std::unique_ptr&lt;Block&gt; raw_block;</a>
<a name="ln1194">      {</a>
<a name="ln1195">        StopWatch sw(rep_-&gt;ioptions.env, statistics, READ_BLOCK_GET_MICROS);</a>
<a name="ln1196">        s = block_based_table::ReadBlockFromFile(</a>
<a name="ln1197">            reader-&gt;reader.get(), rep_-&gt;footer, ro, handle, &amp;raw_block, rep_-&gt;ioptions.env,</a>
<a name="ln1198">            rep_-&gt;mem_tracker, block_cache_compressed == nullptr);</a>
<a name="ln1199">      }</a>
<a name="ln1200"> </a>
<a name="ln1201">      if (s.ok()) {</a>
<a name="ln1202">        s = PutDataBlockToCache(key, ckey, block_cache, block_cache_compressed,</a>
<a name="ln1203">                                ro, statistics, &amp;block, raw_block.release(),</a>
<a name="ln1204">                                rep_-&gt;table_options.format_version, rep_-&gt;mem_tracker);</a>
<a name="ln1205">      }</a>
<a name="ln1206">    }</a>
<a name="ln1207">  }</a>
<a name="ln1208"> </a>
<a name="ln1209">  // Didn't get any data from block caches.</a>
<a name="ln1210">  if (s.ok() &amp;&amp; block.value == nullptr) {</a>
<a name="ln1211">    if (no_io) {</a>
<a name="ln1212">      // Could not read from block_cache and can't do IO</a>
<a name="ln1213">      if (input_iter != nullptr) {</a>
<a name="ln1214">        input_iter-&gt;SetStatus(ReturnNoIOError());</a>
<a name="ln1215">        return input_iter;</a>
<a name="ln1216">      } else {</a>
<a name="ln1217">        return NewErrorInternalIterator(ReturnNoIOError());</a>
<a name="ln1218">      }</a>
<a name="ln1219">    }</a>
<a name="ln1220">    std::unique_ptr&lt;Block&gt; block_value;</a>
<a name="ln1221">    s = block_based_table::ReadBlockFromFile(</a>
<a name="ln1222">        reader-&gt;reader.get(), rep_-&gt;footer, ro, handle, &amp;block_value, rep_-&gt;ioptions.env,</a>
<a name="ln1223">        rep_-&gt;mem_tracker);</a>
<a name="ln1224">    if (s.ok()) {</a>
<a name="ln1225">      block.value = block_value.release();</a>
<a name="ln1226">    }</a>
<a name="ln1227">  }</a>
<a name="ln1228"> </a>
<a name="ln1229">  InternalIterator* iter;</a>
<a name="ln1230">  if (s.ok() &amp;&amp; block.value != nullptr) {</a>
<a name="ln1231">    iter = block.value-&gt;NewIterator(rep_-&gt;comparator.get(), input_iter);</a>
<a name="ln1232">    if (block.cache_handle != nullptr) {</a>
<a name="ln1233">      iter-&gt;RegisterCleanup(&amp;ReleaseCachedEntry, block_cache,</a>
<a name="ln1234">          block.cache_handle);</a>
<a name="ln1235">    } else {</a>
<a name="ln1236">      iter-&gt;RegisterCleanup(&amp;DeleteHeldResource&lt;Block&gt;, block.value, nullptr);</a>
<a name="ln1237">    }</a>
<a name="ln1238">  } else {</a>
<a name="ln1239">    if (input_iter != nullptr) {</a>
<a name="ln1240">      input_iter-&gt;SetStatus(s);</a>
<a name="ln1241">      iter = input_iter;</a>
<a name="ln1242">    } else {</a>
<a name="ln1243">      iter = NewErrorInternalIterator(s);</a>
<a name="ln1244">    }</a>
<a name="ln1245">  }</a>
<a name="ln1246">  return iter;</a>
<a name="ln1247">}</a>
<a name="ln1248"> </a>
<a name="ln1249">// This will be broken if the user specifies an unusual implementation</a>
<a name="ln1250">// of Options.comparator, or if the user specifies an unusual</a>
<a name="ln1251">// definition of prefixes in BlockBasedTableOptions.filter_policy.</a>
<a name="ln1252">// In particular, we require the following three properties:</a>
<a name="ln1253">//</a>
<a name="ln1254">// 1) key.starts_with(prefix(key))</a>
<a name="ln1255">// 2) Compare(prefix(key), key) &lt;= 0.</a>
<a name="ln1256">// 3) If Compare(key1, key2) &lt;= 0, then Compare(prefix(key1), prefix(key2)) &lt;= 0</a>
<a name="ln1257">//</a>
<a name="ln1258">// Otherwise, this method guarantees no I/O will be incurred.</a>
<a name="ln1259">//</a>
<a name="ln1260">// REQUIRES: this method shouldn't be called while the DB lock is held.</a>
<a name="ln1261">bool BlockBasedTable::PrefixMayMatch(const Slice&amp; internal_key) {</a>
<a name="ln1262">  if (!rep_-&gt;filter_policy) {</a>
<a name="ln1263">    return true;</a>
<a name="ln1264">  }</a>
<a name="ln1265"> </a>
<a name="ln1266">  assert(rep_-&gt;ioptions.prefix_extractor != nullptr);</a>
<a name="ln1267">  auto user_key = ExtractUserKey(internal_key);</a>
<a name="ln1268">  auto filter_key = rep_-&gt;filter_key_transformer ?</a>
<a name="ln1269">      rep_-&gt;filter_key_transformer-&gt;Transform(user_key) : user_key;</a>
<a name="ln1270">  if (!rep_-&gt;ioptions.prefix_extractor-&gt;InDomain(filter_key) ||</a>
<a name="ln1271">      !rep_-&gt;ioptions.prefix_extractor-&gt;InDomain(user_key)) {</a>
<a name="ln1272">    return true;</a>
<a name="ln1273">  }</a>
<a name="ln1274">  auto user_key_prefix = rep_-&gt;ioptions.prefix_extractor-&gt;Transform(user_key);</a>
<a name="ln1275">  auto filter_key_prefix = rep_-&gt;ioptions.prefix_extractor-&gt;Transform(filter_key);</a>
<a name="ln1276">  InternalKey internal_key_prefix(user_key_prefix, kMaxSequenceNumber, kTypeValue);</a>
<a name="ln1277">  auto internal_prefix = internal_key_prefix.Encode();</a>
<a name="ln1278"> </a>
<a name="ln1279">  bool may_match = true;</a>
<a name="ln1280">  Status s;</a>
<a name="ln1281"> </a>
<a name="ln1282">  // To prevent any io operation in this method, we set `read_tier` to make</a>
<a name="ln1283">  // sure we always read index or filter only when they have already been</a>
<a name="ln1284">  // loaded to memory.</a>
<a name="ln1285">  ReadOptions no_io_read_options;</a>
<a name="ln1286">  no_io_read_options.read_tier = kBlockCacheTier;</a>
<a name="ln1287"> </a>
<a name="ln1288">  // First check non block-based filter.</a>
<a name="ln1289">  auto filter_entry = GetFilter(no_io_read_options.query_id, true /* no io */, &amp;filter_key);</a>
<a name="ln1290">  FilterBlockReader* filter = filter_entry.value;</a>
<a name="ln1291">  const bool is_block_based_filter = rep_-&gt;filter_type == FilterType::kBlockBasedFilter;</a>
<a name="ln1292">  if (filter != nullptr &amp;&amp; !is_block_based_filter) {</a>
<a name="ln1293">    may_match = filter-&gt;PrefixMayMatch(filter_key_prefix);</a>
<a name="ln1294">  }</a>
<a name="ln1295"> </a>
<a name="ln1296">  // If filter is block-based or checking filter was not successful we need to get data block</a>
<a name="ln1297">  // offset. For block-based filter we need to know offset of data block to get and check</a>
<a name="ln1298">  // corresponding filter block. For non block-based filter we just need offset to try to get data</a>
<a name="ln1299">  // for the key.</a>
<a name="ln1300">  if (may_match) {</a>
<a name="ln1301">    unique_ptr&lt;InternalIterator&gt; iiter(NewIndexIterator(no_io_read_options));</a>
<a name="ln1302">    iiter-&gt;Seek(internal_prefix);</a>
<a name="ln1303"> </a>
<a name="ln1304">    if (!iiter-&gt;Valid()) {</a>
<a name="ln1305">      // we're past end of file</a>
<a name="ln1306">      // if it's incomplete, it means that we avoided I/O</a>
<a name="ln1307">      // and we're not really sure that we're past the end</a>
<a name="ln1308">      // of the file</a>
<a name="ln1309">      may_match = iiter-&gt;status().IsIncomplete();</a>
<a name="ln1310">    } else if (ExtractUserKey(iiter-&gt;key()).starts_with(</a>
<a name="ln1311">                ExtractUserKey(internal_prefix))) {</a>
<a name="ln1312">      // we need to check for this subtle case because our only</a>
<a name="ln1313">      // guarantee is that &quot;the key is a string &gt;= last key in that data</a>
<a name="ln1314">      // block&quot; according to the doc/table_format.txt spec.</a>
<a name="ln1315">      //</a>
<a name="ln1316">      // Suppose iiter.key() starts with the desired prefix; it is not</a>
<a name="ln1317">      // necessarily the case that the corresponding data block will</a>
<a name="ln1318">      // contain the prefix, since iiter.key() need not be in the</a>
<a name="ln1319">      // block.  However, the next data block may contain the prefix, so</a>
<a name="ln1320">      // we return true to play it safe.</a>
<a name="ln1321">      may_match = true;</a>
<a name="ln1322">    } else if (filter != nullptr &amp;&amp; is_block_based_filter) {</a>
<a name="ln1323">      // iiter.key() does NOT start with the desired prefix.  Because</a>
<a name="ln1324">      // Seek() finds the first key that is &gt;= the seek target, this</a>
<a name="ln1325">      // means that iiter.key() &gt; prefix.  Thus, any data blocks coming</a>
<a name="ln1326">      // after the data block corresponding to iiter.key() cannot</a>
<a name="ln1327">      // possibly contain the key.  Thus, the corresponding data block</a>
<a name="ln1328">      // is the only on could potentially contain the prefix.</a>
<a name="ln1329">      Slice handle_value = iiter-&gt;value();</a>
<a name="ln1330">      BlockHandle handle;</a>
<a name="ln1331">      s = handle.DecodeFrom(&amp;handle_value);</a>
<a name="ln1332">      assert(s.ok());</a>
<a name="ln1333">      may_match = filter-&gt;PrefixMayMatch(filter_key_prefix, handle.offset());</a>
<a name="ln1334">    }</a>
<a name="ln1335">  }</a>
<a name="ln1336"> </a>
<a name="ln1337">  Statistics* statistics = rep_-&gt;ioptions.statistics;</a>
<a name="ln1338">  RecordTick(statistics, BLOOM_FILTER_PREFIX_CHECKED);</a>
<a name="ln1339">  if (!may_match) {</a>
<a name="ln1340">    RecordTick(statistics, BLOOM_FILTER_PREFIX_USEFUL);</a>
<a name="ln1341">  }</a>
<a name="ln1342"> </a>
<a name="ln1343">  filter_entry.Release(rep_-&gt;table_options.block_cache.get());</a>
<a name="ln1344">  return may_match;</a>
<a name="ln1345">}</a>
<a name="ln1346"> </a>
<a name="ln1347">InternalIterator* BlockBasedTable::NewIterator(const ReadOptions&amp; read_options,</a>
<a name="ln1348">                                               Arena* arena,</a>
<a name="ln1349">                                               bool skip_filters) {</a>
<a name="ln1350">  auto state = std::make_unique&lt;BlockEntryIteratorState&gt;(</a>
<a name="ln1351">      this, read_options, skip_filters, BlockType::kData);</a>
<a name="ln1352">  // TODO: unify the semantics across NewIterator callsites, so that we can pass an arena across</a>
<a name="ln1353">  // them, and decide the free / no free based on that. This callsite, for example, allows us to</a>
<a name="ln1354">  // put the top level iterator on the arena and potentially even the State object, however, not</a>
<a name="ln1355">  // the IndexIterator, as that does not expose arena allocation semantics...</a>
<a name="ln1356">  return NewTwoLevelIterator(</a>
<a name="ln1357">      state.release(), NewIndexIterator(read_options), arena, true /* need_free_iter_and_state */</a>
<a name="ln1358">  );</a>
<a name="ln1359">}</a>
<a name="ln1360"> </a>
<a name="ln1361">bool BlockBasedTable::NonBlockBasedFilterKeyMayMatch(FilterBlockReader* filter,</a>
<a name="ln1362">    const Slice&amp; filter_key) const {</a>
<a name="ln1363">  assert(rep_-&gt;filter_type != FilterType::kBlockBasedFilter);</a>
<a name="ln1364">  if (filter == nullptr) {</a>
<a name="ln1365">    return true;</a>
<a name="ln1366">  }</a>
<a name="ln1367">  RecordTick(rep_-&gt;ioptions.statistics, BLOOM_FILTER_CHECKED);</a>
<a name="ln1368">  if (!filter-&gt;KeyMayMatch(filter_key)) {</a>
<a name="ln1369">    return false;</a>
<a name="ln1370">  }</a>
<a name="ln1371">  if (rep_-&gt;ioptions.prefix_extractor &amp;&amp;</a>
<a name="ln1372">      rep_-&gt;ioptions.prefix_extractor-&gt;InDomain(filter_key) &amp;&amp;</a>
<a name="ln1373">      !filter-&gt;PrefixMayMatch(</a>
<a name="ln1374">          rep_-&gt;ioptions.prefix_extractor-&gt;Transform(filter_key))) {</a>
<a name="ln1375">    return false;</a>
<a name="ln1376">  }</a>
<a name="ln1377">  return true;</a>
<a name="ln1378">}</a>
<a name="ln1379"> </a>
<a name="ln1380">Status BlockBasedTable::Get(const ReadOptions&amp; read_options, const Slice&amp; internal_key,</a>
<a name="ln1381">                            GetContext* get_context, bool skip_filters) {</a>
<a name="ln1382">  Status s;</a>
<a name="ln1383">  CachableEntry&lt;FilterBlockReader&gt; filter_entry;</a>
<a name="ln1384">  Slice filter_key;</a>
<a name="ln1385">  if (!skip_filters) {</a>
<a name="ln1386">    filter_key = GetFilterKeyFromInternalKey(internal_key);</a>
<a name="ln1387">    filter_entry = GetFilter(read_options.query_id,</a>
<a name="ln1388">                             read_options.read_tier == kBlockCacheTier,</a>
<a name="ln1389">                             &amp;filter_key);</a>
<a name="ln1390">  }</a>
<a name="ln1391">  FilterBlockReader* filter = filter_entry.value;</a>
<a name="ln1392"> </a>
<a name="ln1393">  const bool is_block_based_filter = rep_-&gt;filter_type == FilterType::kBlockBasedFilter;</a>
<a name="ln1394"> </a>
<a name="ln1395">  // First check non block-based filter.</a>
<a name="ln1396">  if (!is_block_based_filter &amp;&amp; !NonBlockBasedFilterKeyMayMatch(filter, filter_key)) {</a>
<a name="ln1397">    RecordTick(rep_-&gt;ioptions.statistics, BLOOM_FILTER_USEFUL);</a>
<a name="ln1398">  } else {</a>
<a name="ln1399"> </a>
<a name="ln1400">    // Either filter is block-based or key may match.</a>
<a name="ln1401">    IndexIteratorHolder iiter_holder(this, read_options);</a>
<a name="ln1402">    InternalIterator&amp; iiter = *iiter_holder.iter();</a>
<a name="ln1403"> </a>
<a name="ln1404">    RETURN_NOT_OK(iiter.status());</a>
<a name="ln1405"> </a>
<a name="ln1406">    bool done = false;</a>
<a name="ln1407">    for (iiter.Seek(internal_key); iiter.Valid() &amp;&amp; !done; iiter.Next()) {</a>
<a name="ln1408">      {</a>
<a name="ln1409">        Slice data_block_handle_encoded = iiter.value();</a>
<a name="ln1410"> </a>
<a name="ln1411">        if (!skip_filters &amp;&amp; is_block_based_filter) {</a>
<a name="ln1412">          RecordTick(rep_-&gt;ioptions.statistics, BLOOM_FILTER_CHECKED);</a>
<a name="ln1413">          BlockHandle data_block_handle;</a>
<a name="ln1414">          const bool absent_from_filter =</a>
<a name="ln1415">              data_block_handle.DecodeFrom(&amp;data_block_handle_encoded).ok()</a>
<a name="ln1416">              &amp;&amp; !filter-&gt;KeyMayMatch(filter_key, data_block_handle.offset());</a>
<a name="ln1417"> </a>
<a name="ln1418">          if (absent_from_filter) {</a>
<a name="ln1419">            // Not found</a>
<a name="ln1420">            // TODO: think about interaction with Merge. If a user key cannot</a>
<a name="ln1421">            // cross one data block, we should be fine.</a>
<a name="ln1422">            RecordTick(rep_-&gt;ioptions.statistics, BLOOM_FILTER_USEFUL);</a>
<a name="ln1423">            break;</a>
<a name="ln1424">          }</a>
<a name="ln1425">        }</a>
<a name="ln1426">      }</a>
<a name="ln1427"> </a>
<a name="ln1428">      BlockIter biter;</a>
<a name="ln1429">      NewDataBlockIterator(read_options, iiter.value(), BlockType::kData, &amp;biter);</a>
<a name="ln1430"> </a>
<a name="ln1431">      if (read_options.read_tier == kBlockCacheTier &amp;&amp;</a>
<a name="ln1432">          biter.status().IsIncomplete()) {</a>
<a name="ln1433">        // couldn't get block from block_cache</a>
<a name="ln1434">        // Update Saver.state to Found because we are only looking for whether</a>
<a name="ln1435">        // we can guarantee the key is not there when &quot;no_io&quot; is set</a>
<a name="ln1436">        get_context-&gt;MarkKeyMayExist();</a>
<a name="ln1437">        break;</a>
<a name="ln1438">      }</a>
<a name="ln1439">      if (!biter.status().ok()) {</a>
<a name="ln1440">        s = biter.status();</a>
<a name="ln1441">        break;</a>
<a name="ln1442">      }</a>
<a name="ln1443"> </a>
<a name="ln1444">      // Call the *saver function on each entry/block until it returns false</a>
<a name="ln1445">      for (biter.Seek(internal_key); biter.Valid(); biter.Next()) {</a>
<a name="ln1446">        ParsedInternalKey parsed_key;</a>
<a name="ln1447">        if (!ParseInternalKey(biter.key(), &amp;parsed_key)) {</a>
<a name="ln1448">          s = STATUS(Corruption, Slice());</a>
<a name="ln1449">        }</a>
<a name="ln1450"> </a>
<a name="ln1451">        if (!get_context-&gt;SaveValue(parsed_key, biter.value())) {</a>
<a name="ln1452">          done = true;</a>
<a name="ln1453">          break;</a>
<a name="ln1454">        }</a>
<a name="ln1455">      }</a>
<a name="ln1456">      s = biter.status();</a>
<a name="ln1457">    }</a>
<a name="ln1458">    if (s.ok()) {</a>
<a name="ln1459">      s = iiter.status();</a>
<a name="ln1460">    }</a>
<a name="ln1461">  }</a>
<a name="ln1462"> </a>
<a name="ln1463">  filter_entry.Release(rep_-&gt;table_options.block_cache.get());</a>
<a name="ln1464">  return s;</a>
<a name="ln1465">}</a>
<a name="ln1466"> </a>
<a name="ln1467">Status BlockBasedTable::Prefetch(const Slice* const begin,</a>
<a name="ln1468">                                 const Slice* const end) {</a>
<a name="ln1469">  auto&amp; comparator = *rep_-&gt;comparator;</a>
<a name="ln1470">  // pre-condition</a>
<a name="ln1471">  if (begin &amp;&amp; end &amp;&amp; comparator.Compare(*begin, *end) &gt; 0) {</a>
<a name="ln1472">    return STATUS(InvalidArgument, *begin, *end);</a>
<a name="ln1473">  }</a>
<a name="ln1474"> </a>
<a name="ln1475">  IndexIteratorHolder iiter_holder(this, ReadOptions::kDefault);</a>
<a name="ln1476">  InternalIterator&amp; iiter = *iiter_holder.iter();</a>
<a name="ln1477"> </a>
<a name="ln1478">  RETURN_NOT_OK(iiter.status());</a>
<a name="ln1479"> </a>
<a name="ln1480">  // indicates if we are on the last page that need to be pre-fetched</a>
<a name="ln1481">  bool prefetching_boundary_page = false;</a>
<a name="ln1482"> </a>
<a name="ln1483">  for (begin ? iiter.Seek(*begin) : iiter.SeekToFirst(); iiter.Valid();</a>
<a name="ln1484">       iiter.Next()) {</a>
<a name="ln1485">    Slice block_handle = iiter.value();</a>
<a name="ln1486"> </a>
<a name="ln1487">    if (end &amp;&amp; comparator.Compare(iiter.key(), *end) &gt;= 0) {</a>
<a name="ln1488">      if (prefetching_boundary_page) {</a>
<a name="ln1489">        break;</a>
<a name="ln1490">      }</a>
<a name="ln1491"> </a>
<a name="ln1492">      // The index entry represents the last key in the data block.</a>
<a name="ln1493">      // We should load this page into memory as well, but no more</a>
<a name="ln1494">      prefetching_boundary_page = true;</a>
<a name="ln1495">    }</a>
<a name="ln1496"> </a>
<a name="ln1497">    // Load the block specified by the block_handle into the block cache</a>
<a name="ln1498">    BlockIter biter;</a>
<a name="ln1499">    NewDataBlockIterator(ReadOptions::kDefault, block_handle, BlockType::kData, &amp;biter);</a>
<a name="ln1500"> </a>
<a name="ln1501">    if (!biter.status().ok()) {</a>
<a name="ln1502">      // there was an unexpected error while pre-fetching</a>
<a name="ln1503">      return biter.status();</a>
<a name="ln1504">    }</a>
<a name="ln1505">  }</a>
<a name="ln1506"> </a>
<a name="ln1507">  return Status::OK();</a>
<a name="ln1508">}</a>
<a name="ln1509"> </a>
<a name="ln1510">bool BlockBasedTable::TEST_KeyInCache(const ReadOptions&amp; options,</a>
<a name="ln1511">                                      const Slice&amp; key) {</a>
<a name="ln1512">  std::unique_ptr&lt;InternalIterator&gt; iiter(NewIndexIterator(options));</a>
<a name="ln1513">  iiter-&gt;Seek(key);</a>
<a name="ln1514">  assert(iiter-&gt;Valid());</a>
<a name="ln1515">  CachableEntry&lt;Block&gt; block;</a>
<a name="ln1516"> </a>
<a name="ln1517">  BlockHandle handle;</a>
<a name="ln1518">  Slice input = iiter-&gt;value();</a>
<a name="ln1519">  Status s = handle.DecodeFrom(&amp;input);</a>
<a name="ln1520">  assert(s.ok());</a>
<a name="ln1521">  Cache* block_cache = rep_-&gt;table_options.block_cache.get();</a>
<a name="ln1522">  assert(block_cache != nullptr);</a>
<a name="ln1523"> </a>
<a name="ln1524">  char cache_key_storage[block_based_table::kCacheKeyBufferSize];</a>
<a name="ln1525">  Slice cache_key =</a>
<a name="ln1526">      GetCacheKey(rep_-&gt;data_reader_with_cache_prefix-&gt;cache_key_prefix, handle, cache_key_storage);</a>
<a name="ln1527">  Slice ckey;</a>
<a name="ln1528"> </a>
<a name="ln1529">  s = GetDataBlockFromCache(cache_key, ckey, block_cache, nullptr, nullptr, options, &amp;block,</a>
<a name="ln1530">      rep_-&gt;table_options.format_version, BlockType::kData, rep_-&gt;mem_tracker);</a>
<a name="ln1531">  assert(s.ok());</a>
<a name="ln1532">  bool in_cache = block.value != nullptr;</a>
<a name="ln1533">  if (in_cache) {</a>
<a name="ln1534">    ReleaseCachedEntry(block_cache, block.cache_handle);</a>
<a name="ln1535">  }</a>
<a name="ln1536">  return in_cache;</a>
<a name="ln1537">}</a>
<a name="ln1538"> </a>
<a name="ln1539">// REQUIRES: The following fields of rep_ should have already been populated:</a>
<a name="ln1540">//  1. file</a>
<a name="ln1541">//  2. index_handle,</a>
<a name="ln1542">//  3. options</a>
<a name="ln1543">//  4. internal_comparator</a>
<a name="ln1544">//  5. index_type</a>
<a name="ln1545">Status BlockBasedTable::CreateDataBlockIndexReader(</a>
<a name="ln1546">    std::unique_ptr&lt;IndexReader&gt;* index_reader, InternalIterator* preloaded_meta_index_iter) {</a>
<a name="ln1547">  // Some old version of block-based tables don't have index type present in</a>
<a name="ln1548">  // table properties. If that's the case we can safely use the kBinarySearch.</a>
<a name="ln1549">  auto index_type_on_file = IndexType::kBinarySearch;</a>
<a name="ln1550">  if (rep_-&gt;table_properties) {</a>
<a name="ln1551">    auto&amp; props = rep_-&gt;table_properties-&gt;user_collected_properties;</a>
<a name="ln1552">    auto pos = props.find(BlockBasedTablePropertyNames::kIndexType);</a>
<a name="ln1553">    if (pos != props.end()) {</a>
<a name="ln1554">      index_type_on_file = static_cast&lt;IndexType&gt;(</a>
<a name="ln1555">          DecodeFixed32(pos-&gt;second.c_str()));</a>
<a name="ln1556">    }</a>
<a name="ln1557">  }</a>
<a name="ln1558"> </a>
<a name="ln1559">  auto file = rep_-&gt;base_reader_with_cache_prefix-&gt;reader.get();</a>
<a name="ln1560">  auto env = rep_-&gt;ioptions.env;</a>
<a name="ln1561">  const auto&amp; comparator = rep_-&gt;comparator;</a>
<a name="ln1562">  const Footer&amp; footer = rep_-&gt;footer;</a>
<a name="ln1563"> </a>
<a name="ln1564">  if (index_type_on_file == IndexType::kHashSearch &amp;&amp;</a>
<a name="ln1565">      rep_-&gt;ioptions.prefix_extractor == nullptr) {</a>
<a name="ln1566">    RLOG(InfoLogLevel::WARN_LEVEL, rep_-&gt;ioptions.info_log,</a>
<a name="ln1567">        &quot;IndexType::kHashSearch requires &quot;</a>
<a name="ln1568">        &quot;options.prefix_extractor to be set.&quot;</a>
<a name="ln1569">        &quot; Fall back to binary search index.&quot;);</a>
<a name="ln1570">    index_type_on_file = IndexType::kBinarySearch;</a>
<a name="ln1571">  }</a>
<a name="ln1572"> </a>
<a name="ln1573">  switch (index_type_on_file) {</a>
<a name="ln1574">    case IndexType::kBinarySearch: {</a>
<a name="ln1575">      return BinarySearchIndexReader::Create(</a>
<a name="ln1576">          file, footer, footer.index_handle(), env, comparator, index_reader, rep_-&gt;mem_tracker);</a>
<a name="ln1577">    }</a>
<a name="ln1578">    case IndexType::kHashSearch: {</a>
<a name="ln1579">      std::unique_ptr&lt;Block&gt; meta_guard;</a>
<a name="ln1580">      std::unique_ptr&lt;InternalIterator&gt; meta_iter_guard;</a>
<a name="ln1581">      auto meta_index_iter = preloaded_meta_index_iter;</a>
<a name="ln1582">      if (meta_index_iter == nullptr) {</a>
<a name="ln1583">        auto s = ReadMetaBlock(rep_, &amp;meta_guard, &amp;meta_iter_guard);</a>
<a name="ln1584">        if (!s.ok()) {</a>
<a name="ln1585">          // we simply fall back to binary search in case there is any</a>
<a name="ln1586">          // problem with prefix hash index loading.</a>
<a name="ln1587">          RLOG(InfoLogLevel::WARN_LEVEL, rep_-&gt;ioptions.info_log,</a>
<a name="ln1588">              &quot;Unable to read the metaindex block.&quot;</a>
<a name="ln1589">              &quot; Fall back to binary search index.&quot;);</a>
<a name="ln1590">          return BinarySearchIndexReader::Create(</a>
<a name="ln1591">            file, footer, footer.index_handle(), env, comparator, index_reader, rep_-&gt;mem_tracker);</a>
<a name="ln1592">        }</a>
<a name="ln1593">        meta_index_iter = meta_iter_guard.get();</a>
<a name="ln1594">      }</a>
<a name="ln1595"> </a>
<a name="ln1596">      // We need to wrap data with internal_prefix_transform to make sure it can</a>
<a name="ln1597">      // handle prefix correctly.</a>
<a name="ln1598">      rep_-&gt;internal_prefix_transform.reset(</a>
<a name="ln1599">          new InternalKeySliceTransform(rep_-&gt;ioptions.prefix_extractor));</a>
<a name="ln1600">      return HashIndexReader::Create(</a>
<a name="ln1601">          rep_-&gt;internal_prefix_transform.get(), footer, file, env, comparator,</a>
<a name="ln1602">          footer.index_handle(), meta_index_iter, index_reader,</a>
<a name="ln1603">          rep_-&gt;hash_index_allow_collision, rep_-&gt;mem_tracker);</a>
<a name="ln1604">    }</a>
<a name="ln1605">    case IndexType::kMultiLevelBinarySearch: {</a>
<a name="ln1606">      auto&amp; props = DCHECK_NOTNULL(rep_-&gt;table_properties.get())-&gt;user_collected_properties;</a>
<a name="ln1607">      auto pos = props.find(BlockBasedTablePropertyNames::kNumIndexLevels);</a>
<a name="ln1608">      if (pos == props.end()) {</a>
<a name="ln1609">        return STATUS_FORMAT(</a>
<a name="ln1610">            NotFound, &quot;Missed table property $0 for multi-level binary-search index&quot;,</a>
<a name="ln1611">            BlockBasedTablePropertyNames::kNumIndexLevels);</a>
<a name="ln1612">      }</a>
<a name="ln1613">      int num_levels = DecodeFixed32(pos-&gt;second.c_str());</a>
<a name="ln1614">      auto result = MultiLevelIndexReader::Create(</a>
<a name="ln1615">          file, footer, num_levels, footer.index_handle(), env, comparator, rep_-&gt;mem_tracker);</a>
<a name="ln1616">      RETURN_NOT_OK(result);</a>
<a name="ln1617">      *index_reader = std::move(*result);</a>
<a name="ln1618">      return Status::OK();</a>
<a name="ln1619">    }</a>
<a name="ln1620">    default: {</a>
<a name="ln1621">      std::string error_message =</a>
<a name="ln1622">          &quot;Unrecognized index type: &quot; + ToString(rep_-&gt;index_type);</a>
<a name="ln1623">      return STATUS(InvalidArgument, error_message.c_str());</a>
<a name="ln1624">    }</a>
<a name="ln1625">  }</a>
<a name="ln1626">}</a>
<a name="ln1627"> </a>
<a name="ln1628">uint64_t BlockBasedTable::ApproximateOffsetOf(const Slice&amp; key) {</a>
<a name="ln1629">  unique_ptr&lt;InternalIterator&gt; index_iter(NewIndexIterator(ReadOptions::kDefault));</a>
<a name="ln1630"> </a>
<a name="ln1631">  index_iter-&gt;Seek(key);</a>
<a name="ln1632">  uint64_t result;</a>
<a name="ln1633">  if (index_iter-&gt;Valid()) {</a>
<a name="ln1634">    BlockHandle handle;</a>
<a name="ln1635">    Slice input = index_iter-&gt;value();</a>
<a name="ln1636">    Status s = handle.DecodeFrom(&amp;input);</a>
<a name="ln1637">    if (s.ok()) {</a>
<a name="ln1638">      result = handle.offset();</a>
<a name="ln1639">    } else {</a>
<a name="ln1640">      // Strange: we can't decode the block handle in the index block.</a>
<a name="ln1641">      // We'll just return the offset of the metaindex block, which is</a>
<a name="ln1642">      // close to the whole file size for this case.</a>
<a name="ln1643">      result = rep_-&gt;footer.metaindex_handle().offset();</a>
<a name="ln1644">    }</a>
<a name="ln1645">  } else {</a>
<a name="ln1646">    // key is past the last key in the file. If table_properties is not</a>
<a name="ln1647">    // available, approximate the offset by returning the offset of the</a>
<a name="ln1648">    // metaindex block (which is right near the end of the file).</a>
<a name="ln1649">    result = 0;</a>
<a name="ln1650">    if (rep_-&gt;table_properties) {</a>
<a name="ln1651">      result = rep_-&gt;table_properties-&gt;data_size;</a>
<a name="ln1652">    }</a>
<a name="ln1653">    // table_properties is not present in the table.</a>
<a name="ln1654">    if (result == 0) {</a>
<a name="ln1655">      result = rep_-&gt;footer.metaindex_handle().offset();</a>
<a name="ln1656">    }</a>
<a name="ln1657">  }</a>
<a name="ln1658">  return result;</a>
<a name="ln1659">}</a>
<a name="ln1660"> </a>
<a name="ln1661">bool BlockBasedTable::TEST_filter_block_preloaded() const {</a>
<a name="ln1662">  return rep_-&gt;filter != nullptr;</a>
<a name="ln1663">}</a>
<a name="ln1664"> </a>
<a name="ln1665">bool BlockBasedTable::TEST_index_reader_loaded() const {</a>
<a name="ln1666">  return rep_-&gt;data_index_reader.get() != nullptr;</a>
<a name="ln1667">}</a>
<a name="ln1668"> </a>
<a name="ln1669">Status BlockBasedTable::DumpTable(WritableFile* out_file) {</a>
<a name="ln1670">  // Output Footer</a>
<a name="ln1671">  RETURN_NOT_OK(out_file-&gt;Append(</a>
<a name="ln1672">      &quot;Footer Details:\n&quot;</a>
<a name="ln1673">      &quot;--------------------------------------\n&quot;</a>
<a name="ln1674">      &quot;  &quot;));</a>
<a name="ln1675">  RETURN_NOT_OK(out_file-&gt;Append(rep_-&gt;footer.ToString().c_str()));</a>
<a name="ln1676">  RETURN_NOT_OK(out_file-&gt;Append(&quot;\n&quot;));</a>
<a name="ln1677"> </a>
<a name="ln1678">  // Output MetaIndex</a>
<a name="ln1679">  RETURN_NOT_OK(out_file-&gt;Append(</a>
<a name="ln1680">      &quot;Metaindex Details:\n&quot;</a>
<a name="ln1681">      &quot;--------------------------------------\n&quot;));</a>
<a name="ln1682">  std::unique_ptr&lt;Block&gt; meta;</a>
<a name="ln1683">  std::unique_ptr&lt;InternalIterator&gt; meta_iter;</a>
<a name="ln1684">  Status s = ReadMetaBlock(rep_, &amp;meta, &amp;meta_iter);</a>
<a name="ln1685">  if (s.ok()) {</a>
<a name="ln1686">    for (meta_iter-&gt;SeekToFirst(); meta_iter-&gt;Valid(); meta_iter-&gt;Next()) {</a>
<a name="ln1687">      s = meta_iter-&gt;status();</a>
<a name="ln1688">      if (!s.ok()) {</a>
<a name="ln1689">        return s;</a>
<a name="ln1690">      }</a>
<a name="ln1691">      if (meta_iter-&gt;key() == rocksdb::kPropertiesBlock) {</a>
<a name="ln1692">        RETURN_NOT_OK(out_file-&gt;Append(&quot;  Properties block handle: &quot;));</a>
<a name="ln1693">        RETURN_NOT_OK(out_file-&gt;Append(meta_iter-&gt;value().ToString(true).c_str()));</a>
<a name="ln1694">        RETURN_NOT_OK(out_file-&gt;Append(&quot;\n&quot;));</a>
<a name="ln1695">      } else if (strstr(meta_iter-&gt;key().ToString().c_str(),</a>
<a name="ln1696">                        &quot;filter.rocksdb.&quot;) != nullptr) {</a>
<a name="ln1697">        RETURN_NOT_OK(out_file-&gt;Append(&quot;  Filter block handle: &quot;));</a>
<a name="ln1698">        RETURN_NOT_OK(out_file-&gt;Append(meta_iter-&gt;value().ToString(true).c_str()));</a>
<a name="ln1699">        RETURN_NOT_OK(out_file-&gt;Append(&quot;\n&quot;));</a>
<a name="ln1700">      }</a>
<a name="ln1701">    }</a>
<a name="ln1702">    RETURN_NOT_OK(out_file-&gt;Append(&quot;\n&quot;));</a>
<a name="ln1703">  } else {</a>
<a name="ln1704">    return s;</a>
<a name="ln1705">  }</a>
<a name="ln1706"> </a>
<a name="ln1707">  // Output TableProperties</a>
<a name="ln1708">  const rocksdb::TableProperties* table_properties;</a>
<a name="ln1709">  table_properties = rep_-&gt;table_properties.get();</a>
<a name="ln1710"> </a>
<a name="ln1711">  if (table_properties != nullptr) {</a>
<a name="ln1712">    RETURN_NOT_OK(out_file-&gt;Append(</a>
<a name="ln1713">        &quot;Table Properties:\n&quot;</a>
<a name="ln1714">        &quot;--------------------------------------\n&quot;</a>
<a name="ln1715">        &quot;  &quot;));</a>
<a name="ln1716">    RETURN_NOT_OK(out_file-&gt;Append(table_properties-&gt;ToString(&quot;\n  &quot;, &quot;: &quot;).c_str()));</a>
<a name="ln1717">    RETURN_NOT_OK(out_file-&gt;Append(&quot;\n&quot;));</a>
<a name="ln1718">  }</a>
<a name="ln1719"> </a>
<a name="ln1720">  // Output Filter blocks</a>
<a name="ln1721">  if (!rep_-&gt;filter &amp;&amp; !table_properties-&gt;filter_policy_name.empty()) {</a>
<a name="ln1722">    // Support only BloomFilter as off now</a>
<a name="ln1723">    rocksdb::BlockBasedTableOptions table_options;</a>
<a name="ln1724">    table_options.filter_policy.reset(rocksdb::NewBloomFilterPolicy(1));</a>
<a name="ln1725">    if (table_properties-&gt;filter_policy_name.compare(</a>
<a name="ln1726">            table_options.filter_policy-&gt;Name()) == 0) {</a>
<a name="ln1727">      std::string filter_block_key = block_based_table::kFilterBlockPrefix;</a>
<a name="ln1728">      filter_block_key.append(table_properties-&gt;filter_policy_name);</a>
<a name="ln1729">      BlockHandle handle;</a>
<a name="ln1730">      if (FindMetaBlock(meta_iter.get(), filter_block_key, &amp;handle).ok()) {</a>
<a name="ln1731">        BlockContents block;</a>
<a name="ln1732">        if (ReadBlockContents(</a>
<a name="ln1733">                rep_-&gt;base_reader_with_cache_prefix-&gt;reader.get(), rep_-&gt;footer,</a>
<a name="ln1734">                ReadOptions::kDefault, handle, &amp;block, rep_-&gt;ioptions.env, rep_-&gt;mem_tracker,</a>
<a name="ln1735">                false).ok()) {</a>
<a name="ln1736">          rep_-&gt;filter.reset(new BlockBasedFilterBlockReader(</a>
<a name="ln1737">              rep_-&gt;ioptions.prefix_extractor, table_options,</a>
<a name="ln1738">              table_options.whole_key_filtering, std::move(block)));</a>
<a name="ln1739">        }</a>
<a name="ln1740">      }</a>
<a name="ln1741">    }</a>
<a name="ln1742">  }</a>
<a name="ln1743">  if (rep_-&gt;filter) {</a>
<a name="ln1744">    RETURN_NOT_OK(out_file-&gt;Append(</a>
<a name="ln1745">        &quot;Filter Details:\n&quot;</a>
<a name="ln1746">        &quot;--------------------------------------\n&quot;</a>
<a name="ln1747">        &quot;  &quot;));</a>
<a name="ln1748">    RETURN_NOT_OK(out_file-&gt;Append(rep_-&gt;filter-&gt;ToString().c_str()));</a>
<a name="ln1749">    RETURN_NOT_OK(out_file-&gt;Append(&quot;\n&quot;));</a>
<a name="ln1750">  }</a>
<a name="ln1751"> </a>
<a name="ln1752">  // Output Index block</a>
<a name="ln1753">  s = DumpIndexBlock(out_file);</a>
<a name="ln1754">  if (!s.ok()) {</a>
<a name="ln1755">    return s;</a>
<a name="ln1756">  }</a>
<a name="ln1757">  // Output Data blocks</a>
<a name="ln1758">  s = DumpDataBlocks(out_file);</a>
<a name="ln1759"> </a>
<a name="ln1760">  return s;</a>
<a name="ln1761">}</a>
<a name="ln1762"> </a>
<a name="ln1763">Status BlockBasedTable::DumpIndexBlock(WritableFile* out_file) {</a>
<a name="ln1764">  RETURN_NOT_OK(out_file-&gt;Append(</a>
<a name="ln1765">      &quot;Index Details:\n&quot;</a>
<a name="ln1766">      &quot;--------------------------------------\n&quot;));</a>
<a name="ln1767"> </a>
<a name="ln1768">  std::unique_ptr&lt;InternalIterator&gt; blockhandles_iter(</a>
<a name="ln1769">      NewIndexIterator(ReadOptions::kDefault));</a>
<a name="ln1770">  Status s = blockhandles_iter-&gt;status();</a>
<a name="ln1771">  if (!s.ok()) {</a>
<a name="ln1772">    RETURN_NOT_OK(out_file-&gt;Append(&quot;Can not read Index Block \n\n&quot;));</a>
<a name="ln1773">    return s;</a>
<a name="ln1774">  }</a>
<a name="ln1775"> </a>
<a name="ln1776">  RETURN_NOT_OK(out_file-&gt;Append(&quot;  Block key hex dump: Data block handle\n&quot;));</a>
<a name="ln1777">  RETURN_NOT_OK(out_file-&gt;Append(&quot;  Block key ascii\n\n&quot;));</a>
<a name="ln1778">  for (blockhandles_iter-&gt;SeekToFirst(); blockhandles_iter-&gt;Valid();</a>
<a name="ln1779">       blockhandles_iter-&gt;Next()) {</a>
<a name="ln1780">    s = blockhandles_iter-&gt;status();</a>
<a name="ln1781">    if (!s.ok()) {</a>
<a name="ln1782">      break;</a>
<a name="ln1783">    }</a>
<a name="ln1784">    Slice key = blockhandles_iter-&gt;key();</a>
<a name="ln1785">    InternalKey ikey = InternalKey::DecodeFrom(key);</a>
<a name="ln1786"> </a>
<a name="ln1787">    RETURN_NOT_OK(out_file-&gt;Append(&quot;  HEX    &quot;));</a>
<a name="ln1788">    RETURN_NOT_OK(out_file-&gt;Append(ikey.user_key().ToString(true).c_str()));</a>
<a name="ln1789">    RETURN_NOT_OK(out_file-&gt;Append(&quot;: &quot;));</a>
<a name="ln1790">    RETURN_NOT_OK(out_file-&gt;Append(blockhandles_iter-&gt;value().ToString(true).c_str()));</a>
<a name="ln1791">    RETURN_NOT_OK(out_file-&gt;Append(&quot;\n&quot;));</a>
<a name="ln1792"> </a>
<a name="ln1793">    std::string str_key = ikey.user_key().ToString();</a>
<a name="ln1794">    std::string res_key(&quot;&quot;);</a>
<a name="ln1795">    char cspace = ' ';</a>
<a name="ln1796">    for (size_t i = 0; i &lt; str_key.size(); i++) {</a>
<a name="ln1797">      res_key.append(&amp;str_key[i], 1);</a>
<a name="ln1798">      res_key.append(1, cspace);</a>
<a name="ln1799">    }</a>
<a name="ln1800">    RETURN_NOT_OK(out_file-&gt;Append(&quot;  ASCII  &quot;));</a>
<a name="ln1801">    RETURN_NOT_OK(out_file-&gt;Append(res_key.c_str()));</a>
<a name="ln1802">    RETURN_NOT_OK(out_file-&gt;Append(&quot;\n  ------\n&quot;));</a>
<a name="ln1803">  }</a>
<a name="ln1804">  RETURN_NOT_OK(out_file-&gt;Append(&quot;\n&quot;));</a>
<a name="ln1805">  return Status::OK();</a>
<a name="ln1806">}</a>
<a name="ln1807"> </a>
<a name="ln1808">Status BlockBasedTable::DumpDataBlocks(WritableFile* out_file) {</a>
<a name="ln1809">  std::unique_ptr&lt;InternalIterator&gt; blockhandles_iter(</a>
<a name="ln1810">      NewIndexIterator(ReadOptions::kDefault));</a>
<a name="ln1811">  Status s = blockhandles_iter-&gt;status();</a>
<a name="ln1812">  if (!s.ok()) {</a>
<a name="ln1813">    RETURN_NOT_OK(out_file-&gt;Append(&quot;Can not read Index Block \n\n&quot;));</a>
<a name="ln1814">    return s;</a>
<a name="ln1815">  }</a>
<a name="ln1816"> </a>
<a name="ln1817">  size_t block_id = 1;</a>
<a name="ln1818">  for (blockhandles_iter-&gt;SeekToFirst(); blockhandles_iter-&gt;Valid();</a>
<a name="ln1819">       block_id++, blockhandles_iter-&gt;Next()) {</a>
<a name="ln1820">    s = blockhandles_iter-&gt;status();</a>
<a name="ln1821">    if (!s.ok()) {</a>
<a name="ln1822">      break;</a>
<a name="ln1823">    }</a>
<a name="ln1824"> </a>
<a name="ln1825">    RETURN_NOT_OK(out_file-&gt;Append(&quot;Data Block # &quot;));</a>
<a name="ln1826">    RETURN_NOT_OK(out_file-&gt;Append(rocksdb::ToString(block_id)));</a>
<a name="ln1827">    RETURN_NOT_OK(out_file-&gt;Append(&quot; @ &quot;));</a>
<a name="ln1828">    RETURN_NOT_OK(out_file-&gt;Append(blockhandles_iter-&gt;value().ToString(true).c_str()));</a>
<a name="ln1829">    RETURN_NOT_OK(out_file-&gt;Append(&quot;\n&quot;));</a>
<a name="ln1830">    RETURN_NOT_OK(out_file-&gt;Append(&quot;--------------------------------------\n&quot;));</a>
<a name="ln1831"> </a>
<a name="ln1832">    std::unique_ptr&lt;InternalIterator&gt; datablock_iter;</a>
<a name="ln1833">    datablock_iter.reset(</a>
<a name="ln1834">        NewDataBlockIterator(</a>
<a name="ln1835">            ReadOptions::kDefault, blockhandles_iter-&gt;value(), BlockType::kData));</a>
<a name="ln1836">    s = datablock_iter-&gt;status();</a>
<a name="ln1837"> </a>
<a name="ln1838">    if (!s.ok()) {</a>
<a name="ln1839">      RETURN_NOT_OK(out_file-&gt;Append(&quot;Error reading the block - Skipped \n\n&quot;));</a>
<a name="ln1840">      continue;</a>
<a name="ln1841">    }</a>
<a name="ln1842"> </a>
<a name="ln1843">    for (datablock_iter-&gt;SeekToFirst(); datablock_iter-&gt;Valid();</a>
<a name="ln1844">         datablock_iter-&gt;Next()) {</a>
<a name="ln1845">      s = datablock_iter-&gt;status();</a>
<a name="ln1846">      if (!s.ok()) {</a>
<a name="ln1847">        RETURN_NOT_OK(out_file-&gt;Append(&quot;Error reading the block - Skipped \n&quot;));</a>
<a name="ln1848">        break;</a>
<a name="ln1849">      }</a>
<a name="ln1850">      Slice key = datablock_iter-&gt;key();</a>
<a name="ln1851">      Slice value = datablock_iter-&gt;value();</a>
<a name="ln1852">      InternalKey ikey = InternalKey::DecodeFrom(key);</a>
<a name="ln1853"> </a>
<a name="ln1854">      RETURN_NOT_OK(out_file-&gt;Append(&quot;  HEX    &quot;));</a>
<a name="ln1855">      RETURN_NOT_OK(out_file-&gt;Append(ikey.user_key().ToString(true).c_str()));</a>
<a name="ln1856">      RETURN_NOT_OK(out_file-&gt;Append(&quot;: &quot;));</a>
<a name="ln1857">      RETURN_NOT_OK(out_file-&gt;Append(value.ToString(true).c_str()));</a>
<a name="ln1858">      RETURN_NOT_OK(out_file-&gt;Append(&quot;\n&quot;));</a>
<a name="ln1859"> </a>
<a name="ln1860">      std::string str_key = ikey.user_key().ToString();</a>
<a name="ln1861">      std::string str_value = value.ToString();</a>
<a name="ln1862">      std::string res_key(&quot;&quot;), res_value(&quot;&quot;);</a>
<a name="ln1863">      char cspace = ' ';</a>
<a name="ln1864">      for (size_t i = 0; i &lt; str_key.size(); i++) {</a>
<a name="ln1865">        res_key.append(&amp;str_key[i], 1);</a>
<a name="ln1866">        res_key.append(1, cspace);</a>
<a name="ln1867">      }</a>
<a name="ln1868">      for (size_t i = 0; i &lt; str_value.size(); i++) {</a>
<a name="ln1869">        res_value.append(&amp;str_value[i], 1);</a>
<a name="ln1870">        res_value.append(1, cspace);</a>
<a name="ln1871">      }</a>
<a name="ln1872"> </a>
<a name="ln1873">      RETURN_NOT_OK(out_file-&gt;Append(&quot;  ASCII  &quot;));</a>
<a name="ln1874">      RETURN_NOT_OK(out_file-&gt;Append(res_key.c_str()));</a>
<a name="ln1875">      RETURN_NOT_OK(out_file-&gt;Append(&quot;: &quot;));</a>
<a name="ln1876">      RETURN_NOT_OK(out_file-&gt;Append(res_value.c_str()));</a>
<a name="ln1877">      RETURN_NOT_OK(out_file-&gt;Append(&quot;\n  ------\n&quot;));</a>
<a name="ln1878">    }</a>
<a name="ln1879">    RETURN_NOT_OK(out_file-&gt;Append(&quot;\n&quot;));</a>
<a name="ln1880">  }</a>
<a name="ln1881">  return Status::OK();</a>
<a name="ln1882">}</a>
<a name="ln1883"> </a>
<a name="ln1884">const ImmutableCFOptions&amp; BlockBasedTable::ioptions() {</a>
<a name="ln1885">  return rep_-&gt;ioptions;</a>
<a name="ln1886">}</a>
<a name="ln1887"> </a>
<a name="ln1888">yb::Result&lt;std::string&gt; BlockBasedTable::GetMiddleKey() {</a>
<a name="ln1889">  auto index_reader = VERIFY_RESULT(GetIndexReader(ReadOptions::kDefault));</a>
<a name="ln1890"> </a>
<a name="ln1891">  // TODO: remove this trick after https://github.com/yugabyte/yugabyte-db/issues/4720 is resolved.</a>
<a name="ln1892">  auto se = yb::ScopeExit([this, &amp;index_reader] {</a>
<a name="ln1893">    index_reader.Release(rep_-&gt;table_options.block_cache.get());</a>
<a name="ln1894">  });</a>
<a name="ln1895"> </a>
<a name="ln1896">  const auto index_middle_key = VERIFY_RESULT(index_reader.value-&gt;GetMiddleKey());</a>
<a name="ln1897">  std::unique_ptr&lt;InternalIterator&gt; iter(</a>
<a name="ln1898">      NewIterator(ReadOptions::kDefault, nullptr, /* skip_filters =*/ true));</a>
<a name="ln1899">  iter-&gt;Seek(index_middle_key);</a>
<a name="ln1900">  if (!iter-&gt;Valid()) {</a>
<a name="ln1901">    // There are no keys in SST that are &gt;= index_middle_key. That means SST is empty or just have</a>
<a name="ln1902">    // the single data block.</a>
<a name="ln1903">    // For tablet splitting we don't need to handle such small files, but if needed for other cases</a>
<a name="ln1904">    // we can update this function to return the middle key of the data block in case there is data</a>
<a name="ln1905">    // in the SST.</a>
<a name="ln1906">    return STATUS(Incomplete, &quot;Empty or to small SST&quot;);</a>
<a name="ln1907">  }</a>
<a name="ln1908">  return iter-&gt;key().ToBuffer();</a>
<a name="ln1909">}</a>
<a name="ln1910"> </a>
<a name="ln1911">}  // namespace rocksdb</a>

</code></pre>
<div class="balloon" rel="1721"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1004/" target="_blank">V1004</a> The 'table_properties' pointer was used unsafely after it was verified against nullptr. Check lines: 1711, 1721.</p></div>
<div class="balloon" rel="152"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: cache_key_prefix, compressed_cache_key_prefix.</p></div>
<div class="balloon" rel="184"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> It is possible that not all members of a class are initialized inside the constructor. Consider inspecting: index_type, hash_index_allow_collision.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
