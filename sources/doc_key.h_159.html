
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>doc_key.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Copyright (c) YugaByte, Inc.</a>
<a name="ln2">//</a>
<a name="ln3">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln4">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln5">//</a>
<a name="ln6">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln7">//</a>
<a name="ln8">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln9">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln10">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln11">// under the License.</a>
<a name="ln12">//</a>
<a name="ln13"> </a>
<a name="ln14">#ifndef YB_DOCDB_DOC_KEY_H_</a>
<a name="ln15">#define YB_DOCDB_DOC_KEY_H_</a>
<a name="ln16"> </a>
<a name="ln17">#include &lt;ostream&gt;</a>
<a name="ln18">#include &lt;vector&gt;</a>
<a name="ln19"> </a>
<a name="ln20">#include &lt;boost/container/small_vector.hpp&gt;</a>
<a name="ln21"> </a>
<a name="ln22">#include &quot;yb/rocksdb/env.h&quot;</a>
<a name="ln23">#include &quot;yb/rocksdb/filter_policy.h&quot;</a>
<a name="ln24"> </a>
<a name="ln25">#include &quot;yb/common/schema.h&quot;</a>
<a name="ln26"> </a>
<a name="ln27">#include &quot;yb/docdb/docdb_fwd.h&quot;</a>
<a name="ln28">#include &quot;yb/docdb/primitive_value.h&quot;</a>
<a name="ln29"> </a>
<a name="ln30">#include &quot;yb/util/ref_cnt_buffer.h&quot;</a>
<a name="ln31">#include &quot;yb/util/slice.h&quot;</a>
<a name="ln32">#include &quot;yb/util/strongly_typed_bool.h&quot;</a>
<a name="ln33"> </a>
<a name="ln34">namespace yb {</a>
<a name="ln35">namespace docdb {</a>
<a name="ln36"> </a>
<a name="ln37">using DocKeyHash = uint16_t;</a>
<a name="ln38"> </a>
<a name="ln39">// ------------------------------------------------------------------------------------------------</a>
<a name="ln40">// DocKey</a>
<a name="ln41">// ------------------------------------------------------------------------------------------------</a>
<a name="ln42"> </a>
<a name="ln43">// A key that allows us to locate a document. This is the prefix of all RocksDB keys of records</a>
<a name="ln44">// inside this document. A document key contains:</a>
<a name="ln45">//   - An optional ID (cotable id or pgtable id).</a>
<a name="ln46">//   - An optional fixed-width hash prefix.</a>
<a name="ln47">//   - A group of primitive values representing &quot;hashed&quot; components (this is what the hash is</a>
<a name="ln48">//     computed based on, so this group is present/absent together with the hash).</a>
<a name="ln49">//   - A group of &quot;range&quot; components suitable for doing ordered scans.</a>
<a name="ln50">//</a>
<a name="ln51">// The encoded representation of the key is as follows:</a>
<a name="ln52">//   - Optional ID:</a>
<a name="ln53">//     * For cotable id, the byte ValueType::kTableId followed by a sixteen byte UUID.</a>
<a name="ln54">//     * For pgtable id, the byte ValueType::kPgTableOid followed by a four byte PgTableId.</a>
<a name="ln55">//   - Optional fixed-width hash prefix, followed by hashed components:</a>
<a name="ln56">//     * The byte ValueType::kUInt16Hash, followed by two bytes of the hash prefix.</a>
<a name="ln57">//     * Hashed components:</a>
<a name="ln58">//       1. Each hash component consists of a type byte (ValueType) followed by the encoded</a>
<a name="ln59">//          representation of the respective type (see PrimitiveValue's key encoding).</a>
<a name="ln60">//       2. ValueType::kGroupEnd terminates the sequence.</a>
<a name="ln61">//   - Range components are stored similarly to the hashed components:</a>
<a name="ln62">//     1. Each range component consists of a type byte (ValueType) followed by the encoded</a>
<a name="ln63">//        representation of the respective type (see PrimitiveValue's key encoding).</a>
<a name="ln64">//     2. ValueType::kGroupEnd terminates the sequence.</a>
<a name="ln65">YB_DEFINE_ENUM(</a>
<a name="ln66">    DocKeyPart,</a>
<a name="ln67">    (kUpToHashCode)</a>
<a name="ln68">    (kUpToHash)</a>
<a name="ln69">    (kUpToId)</a>
<a name="ln70">    // Includes all doc key components up to hashed ones. If there are no hashed components -</a>
<a name="ln71">    // includes the first range component.</a>
<a name="ln72">    (kUpToHashOrFirstRange)</a>
<a name="ln73">    (kWholeDocKey));</a>
<a name="ln74"> </a>
<a name="ln75">class DocKeyDecoder;</a>
<a name="ln76"> </a>
<a name="ln77">YB_STRONGLY_TYPED_BOOL(HybridTimeRequired)</a>
<a name="ln78"> </a>
<a name="ln79">// Whether to allow parts of the range component of a doc key that should not be present in stored</a>
<a name="ln80">// doc key, but could be used during read, for instance kLowest and kHighest.</a>
<a name="ln81">YB_STRONGLY_TYPED_BOOL(AllowSpecial)</a>
<a name="ln82"> </a>
<a name="ln83">class DocKey {</a>
<a name="ln84"> public:</a>
<a name="ln85">  // Constructs an empty document key with no hash component.</a>
<a name="ln86">  DocKey();</a>
<a name="ln87"> </a>
<a name="ln88">  // Construct a document key with only a range component, but no hashed component.</a>
<a name="ln89">  explicit DocKey(std::vector&lt;PrimitiveValue&gt; range_components);</a>
<a name="ln90"> </a>
<a name="ln91">  // Construct a document key including a hashed component and a range component. The hash value has</a>
<a name="ln92">  // to be calculated outside of the constructor, and we're not assuming any specific hash function</a>
<a name="ln93">  // here.</a>
<a name="ln94">  // @param hash A hash value calculated using the appropriate hash function based on</a>
<a name="ln95">  //             hashed_components.</a>
<a name="ln96">  // @param hashed_components Components of the key that go into computing the hash prefix.</a>
<a name="ln97">  // @param range_components Components of the key that we want to be able to do range scans on.</a>
<a name="ln98">  DocKey(DocKeyHash hash,</a>
<a name="ln99">         std::vector&lt;PrimitiveValue&gt; hashed_components,</a>
<a name="ln100">         std::vector&lt;PrimitiveValue&gt; range_components = std::vector&lt;PrimitiveValue&gt;());</a>
<a name="ln101"> </a>
<a name="ln102">  DocKey(const Uuid&amp; cotable_id,</a>
<a name="ln103">         DocKeyHash hash,</a>
<a name="ln104">         std::vector&lt;PrimitiveValue&gt; hashed_components,</a>
<a name="ln105">         std::vector&lt;PrimitiveValue&gt; range_components = std::vector&lt;PrimitiveValue&gt;());</a>
<a name="ln106"> </a>
<a name="ln107">  DocKey(PgTableOid pgtable_id,</a>
<a name="ln108">         DocKeyHash hash,</a>
<a name="ln109">         std::vector&lt;PrimitiveValue&gt; hashed_components,</a>
<a name="ln110">         std::vector&lt;PrimitiveValue&gt; range_components = std::vector&lt;PrimitiveValue&gt;());</a>
<a name="ln111"> </a>
<a name="ln112">  explicit DocKey(const Uuid&amp; cotable_id);</a>
<a name="ln113"> </a>
<a name="ln114">  explicit DocKey(PgTableOid pgtable_id);</a>
<a name="ln115"> </a>
<a name="ln116">  // Constructors to create a DocKey for the given schema to support co-located tables.</a>
<a name="ln117">  explicit DocKey(const Schema&amp; schema);</a>
<a name="ln118">  DocKey(const Schema&amp; schema, DocKeyHash hash);</a>
<a name="ln119">  DocKey(const Schema&amp; schema, std::vector&lt;PrimitiveValue&gt; range_components);</a>
<a name="ln120">  DocKey(const Schema&amp; schema, DocKeyHash hash,</a>
<a name="ln121">         std::vector&lt;PrimitiveValue&gt; hashed_components,</a>
<a name="ln122">         std::vector&lt;PrimitiveValue&gt; range_components = std::vector&lt;PrimitiveValue&gt;());</a>
<a name="ln123"> </a>
<a name="ln124">  KeyBytes Encode() const;</a>
<a name="ln125">  void AppendTo(KeyBytes* out) const;</a>
<a name="ln126"> </a>
<a name="ln127">  // Encodes DocKey to binary representation returning result as RefCntPrefix.</a>
<a name="ln128">  RefCntPrefix EncodeAsRefCntPrefix() const;</a>
<a name="ln129"> </a>
<a name="ln130">  // Resets the state to an empty document key.</a>
<a name="ln131">  void Clear();</a>
<a name="ln132"> </a>
<a name="ln133">  // Clear the range components of the document key only.</a>
<a name="ln134">  void ClearRangeComponents();</a>
<a name="ln135"> </a>
<a name="ln136">  // Resize the range components:</a>
<a name="ln137">  //  - drop elements (primitive values) from the end if new_size is smaller than the old size.</a>
<a name="ln138">  //  - append default primitive values (kNullLow) if new_size is bigger than the old size.</a>
<a name="ln139">  void ResizeRangeComponents(int new_size);</a>
<a name="ln140"> </a>
<a name="ln141">  const Uuid&amp; cotable_id() const {</a>
<a name="ln142">    return cotable_id_;</a>
<a name="ln143">  }</a>
<a name="ln144"> </a>
<a name="ln145">  bool has_cotable_id() const {</a>
<a name="ln146">    return !cotable_id_.IsNil();</a>
<a name="ln147">  }</a>
<a name="ln148"> </a>
<a name="ln149">  const PgTableOid pgtable_id() const {</a>
<a name="ln150">    return pgtable_id_;</a>
<a name="ln151">  }</a>
<a name="ln152"> </a>
<a name="ln153">  bool has_pgtable_id() const {</a>
<a name="ln154">    return pgtable_id_ &gt; 0;</a>
<a name="ln155">  }</a>
<a name="ln156"> </a>
<a name="ln157">  DocKeyHash hash() const {</a>
<a name="ln158">    return hash_;</a>
<a name="ln159">  }</a>
<a name="ln160"> </a>
<a name="ln161">  const std::vector&lt;PrimitiveValue&gt;&amp; hashed_group() const {</a>
<a name="ln162">    return hashed_group_;</a>
<a name="ln163">  }</a>
<a name="ln164"> </a>
<a name="ln165">  const std::vector&lt;PrimitiveValue&gt;&amp; range_group() const {</a>
<a name="ln166">    return range_group_;</a>
<a name="ln167">  }</a>
<a name="ln168"> </a>
<a name="ln169">  std::vector&lt;PrimitiveValue&gt;&amp; hashed_group() {</a>
<a name="ln170">    return hashed_group_;</a>
<a name="ln171">  }</a>
<a name="ln172"> </a>
<a name="ln173">  std::vector&lt;PrimitiveValue&gt;&amp; range_group() {</a>
<a name="ln174">    return range_group_;</a>
<a name="ln175">  }</a>
<a name="ln176"> </a>
<a name="ln177">  // Decodes a document key from the given RocksDB key.</a>
<a name="ln178">  // slice (in/out) - a slice corresponding to a RocksDB key. Any consumed bytes are removed.</a>
<a name="ln179">  // part_to_decode specifies which part of key to decode.</a>
<a name="ln180">  CHECKED_STATUS DecodeFrom(</a>
<a name="ln181">      Slice* slice,</a>
<a name="ln182">      DocKeyPart part_to_decode = DocKeyPart::kWholeDocKey,</a>
<a name="ln183">      AllowSpecial allow_special = AllowSpecial::kFalse);</a>
<a name="ln184"> </a>
<a name="ln185">  // Decodes a document key from the given RocksDB key similar to the above but return the number</a>
<a name="ln186">  // of bytes decoded from the input slice.</a>
<a name="ln187">  Result&lt;size_t&gt; DecodeFrom(</a>
<a name="ln188">      const Slice&amp; slice,</a>
<a name="ln189">      DocKeyPart part_to_decode = DocKeyPart::kWholeDocKey,</a>
<a name="ln190">      AllowSpecial allow_special = AllowSpecial::kFalse);</a>
<a name="ln191"> </a>
<a name="ln192">  // Splits given RocksDB key into vector of slices that forms range_group of document key.</a>
<a name="ln193">  static CHECKED_STATUS PartiallyDecode(Slice* slice,</a>
<a name="ln194">                                        boost::container::small_vector_base&lt;Slice&gt;* out);</a>
<a name="ln195"> </a>
<a name="ln196">  // Decode just the hash code of a DocKey.</a>
<a name="ln197">  static Result&lt;DocKeyHash&gt; DecodeHash(const Slice&amp; slice);</a>
<a name="ln198"> </a>
<a name="ln199">  static Result&lt;size_t&gt; EncodedSize(</a>
<a name="ln200">      Slice slice, DocKeyPart part, AllowSpecial allow_special = AllowSpecial::kFalse);</a>
<a name="ln201"> </a>
<a name="ln202">  // Returns size of encoded hash part and whole part of DocKey.</a>
<a name="ln203">  static Result&lt;std::pair&lt;size_t, size_t&gt;&gt; EncodedHashPartAndDocKeySizes(</a>
<a name="ln204">      Slice slice, AllowSpecial allow_special = AllowSpecial::kFalse);</a>
<a name="ln205"> </a>
<a name="ln206">  // Decode the current document key from the given slice, but expect all bytes to be consumed, and</a>
<a name="ln207">  // return an error status if that is not the case.</a>
<a name="ln208">  CHECKED_STATUS FullyDecodeFrom(const rocksdb::Slice&amp; slice);</a>
<a name="ln209"> </a>
<a name="ln210">  // Converts the document key to a human-readable representation.</a>
<a name="ln211">  std::string ToString() const;</a>
<a name="ln212">  static std::string DebugSliceToString(Slice slice);</a>
<a name="ln213"> </a>
<a name="ln214">  // Check if it is an empty key.</a>
<a name="ln215">  bool empty() const {</a>
<a name="ln216">    return !hash_present_ &amp;&amp; range_group_.empty();</a>
<a name="ln217">  }</a>
<a name="ln218"> </a>
<a name="ln219">  bool operator ==(const DocKey&amp; other) const;</a>
<a name="ln220"> </a>
<a name="ln221">  bool operator !=(const DocKey&amp; other) const {</a>
<a name="ln222">    return !(*this == other);</a>
<a name="ln223">  }</a>
<a name="ln224"> </a>
<a name="ln225">  bool HashedComponentsEqual(const DocKey&amp; other) const;</a>
<a name="ln226"> </a>
<a name="ln227">  void AddRangeComponent(const PrimitiveValue&amp; val);</a>
<a name="ln228"> </a>
<a name="ln229">  void SetRangeComponent(const PrimitiveValue&amp; val, int idx);</a>
<a name="ln230"> </a>
<a name="ln231">  int CompareTo(const DocKey&amp; other) const;</a>
<a name="ln232"> </a>
<a name="ln233">  bool operator &lt;(const DocKey&amp; other) const {</a>
<a name="ln234">    return CompareTo(other) &lt; 0;</a>
<a name="ln235">  }</a>
<a name="ln236"> </a>
<a name="ln237">  bool operator &lt;=(const DocKey&amp; other) const {</a>
<a name="ln238">    return CompareTo(other) &lt;= 0;</a>
<a name="ln239">  }</a>
<a name="ln240"> </a>
<a name="ln241">  bool operator &gt;(const DocKey&amp; other) const {</a>
<a name="ln242">    return CompareTo(other) &gt; 0;</a>
<a name="ln243">  }</a>
<a name="ln244"> </a>
<a name="ln245">  bool operator &gt;=(const DocKey&amp; other) const {</a>
<a name="ln246">    return CompareTo(other) &gt;= 0;</a>
<a name="ln247">  }</a>
<a name="ln248"> </a>
<a name="ln249">  bool BelongsTo(const Schema&amp; schema) const {</a>
<a name="ln250">    if (!cotable_id_.IsNil()) {</a>
<a name="ln251">      return cotable_id_ == schema.cotable_id();</a>
<a name="ln252">    } else if (pgtable_id_ &gt; 0) {</a>
<a name="ln253">      return pgtable_id_ == schema.pgtable_id();</a>
<a name="ln254">    }</a>
<a name="ln255">    return schema.cotable_id().IsNil() &amp;&amp; schema.pgtable_id() == 0;</a>
<a name="ln256">  }</a>
<a name="ln257"> </a>
<a name="ln258">  void set_cotable_id(const Uuid&amp; cotable_id) {</a>
<a name="ln259">    if (!cotable_id.IsNil()) {</a>
<a name="ln260">      DCHECK_EQ(pgtable_id_, 0);</a>
<a name="ln261">    }</a>
<a name="ln262">    cotable_id_ = cotable_id;</a>
<a name="ln263">  }</a>
<a name="ln264"> </a>
<a name="ln265">  void set_pgtable_id(const PgTableOid pgtable_id) {</a>
<a name="ln266">    if (pgtable_id &gt; 0) {</a>
<a name="ln267">      DCHECK(cotable_id_.IsNil());</a>
<a name="ln268">    }</a>
<a name="ln269">    pgtable_id_ = pgtable_id;</a>
<a name="ln270">  }</a>
<a name="ln271"> </a>
<a name="ln272">  void set_hash(DocKeyHash hash) {</a>
<a name="ln273">    hash_ = hash;</a>
<a name="ln274">    hash_present_ = true;</a>
<a name="ln275">  }</a>
<a name="ln276"> </a>
<a name="ln277">  bool has_hash() const {</a>
<a name="ln278">    return hash_present_;</a>
<a name="ln279">  }</a>
<a name="ln280"> </a>
<a name="ln281">  // Converts a redis string key to a doc key</a>
<a name="ln282">  static DocKey FromRedisKey(uint16_t hash, const string&amp; key);</a>
<a name="ln283">  static KeyBytes EncodedFromRedisKey(uint16_t hash, const std::string &amp;key);</a>
<a name="ln284"> </a>
<a name="ln285"> private:</a>
<a name="ln286">  class DecodeFromCallback;</a>
<a name="ln287">  friend class DecodeFromCallback;</a>
<a name="ln288"> </a>
<a name="ln289">  template&lt;class Callback&gt;</a>
<a name="ln290">  static CHECKED_STATUS DoDecode(DocKeyDecoder* decoder,</a>
<a name="ln291">                                 DocKeyPart part_to_decode,</a>
<a name="ln292">                                 AllowSpecial allow_special,</a>
<a name="ln293">                                 const Callback&amp; callback);</a>
<a name="ln294"> </a>
<a name="ln295">  // Uuid of the non-primary table this DocKey belongs to co-located in a tablet. Nil for the</a>
<a name="ln296">  // primary or single-tenant table.</a>
<a name="ln297">  Uuid cotable_id_;</a>
<a name="ln298"> </a>
<a name="ln299">  // Postgres table OID of the non-primary table this DocKey belongs to in colocated tables.</a>
<a name="ln300">  // 0 for primary or single tenant table.</a>
<a name="ln301">  PgTableOid pgtable_id_;</a>
<a name="ln302"> </a>
<a name="ln303">  // TODO: can we get rid of this field and just use !hashed_group_.empty() instead?</a>
<a name="ln304">  bool hash_present_;</a>
<a name="ln305"> </a>
<a name="ln306">  DocKeyHash hash_;</a>
<a name="ln307">  std::vector&lt;PrimitiveValue&gt; hashed_group_;</a>
<a name="ln308">  std::vector&lt;PrimitiveValue&gt; range_group_;</a>
<a name="ln309">};</a>
<a name="ln310"> </a>
<a name="ln311">template &lt;class Collection&gt;</a>
<a name="ln312">void AppendDocKeyItems(const Collection&amp; doc_key_items, KeyBytes* result) {</a>
<a name="ln313">  for (const auto&amp; item : doc_key_items) {</a>
<a name="ln314">    item.AppendToKey(result);</a>
<a name="ln315">  }</a>
<a name="ln316">  result-&gt;AppendValueType(ValueType::kGroupEnd);</a>
<a name="ln317">}</a>
<a name="ln318"> </a>
<a name="ln319">class DocKeyEncoderAfterHashStep {</a>
<a name="ln320"> public:</a>
<a name="ln321">  explicit DocKeyEncoderAfterHashStep(KeyBytes* out) : out_(out) {}</a>
<a name="ln322"> </a>
<a name="ln323">  template &lt;class Collection&gt;</a>
<a name="ln324">  void Range(const Collection&amp; range_group) {</a>
<a name="ln325">    AppendDocKeyItems(range_group, out_);</a>
<a name="ln326">  }</a>
<a name="ln327"> </a>
<a name="ln328"> private:</a>
<a name="ln329">  KeyBytes* out_;</a>
<a name="ln330">};</a>
<a name="ln331"> </a>
<a name="ln332">class DocKeyEncoderAfterTableIdStep {</a>
<a name="ln333"> public:</a>
<a name="ln334">  explicit DocKeyEncoderAfterTableIdStep(KeyBytes* out) : out_(out) {</a>
<a name="ln335">  }</a>
<a name="ln336"> </a>
<a name="ln337">  template &lt;class Collection&gt;</a>
<a name="ln338">  DocKeyEncoderAfterHashStep Hash(</a>
<a name="ln339">      bool hash_present, uint16_t hash, const Collection&amp; hashed_group) {</a>
<a name="ln340">    if (!hash_present) {</a>
<a name="ln341">      return DocKeyEncoderAfterHashStep(out_);</a>
<a name="ln342">    }</a>
<a name="ln343"> </a>
<a name="ln344">    return Hash(hash, hashed_group);</a>
<a name="ln345">  }</a>
<a name="ln346"> </a>
<a name="ln347">  template &lt;class Collection&gt;</a>
<a name="ln348">  DocKeyEncoderAfterHashStep Hash(uint16_t hash, const Collection&amp; hashed_group) {</a>
<a name="ln349">    // We are not setting the &quot;more items in group&quot; bit on the hash field because it is not part</a>
<a name="ln350">    // of &quot;hashed&quot; or &quot;range&quot; groups.</a>
<a name="ln351">    out_-&gt;AppendValueType(ValueType::kUInt16Hash);</a>
<a name="ln352">    out_-&gt;AppendUInt16(hash);</a>
<a name="ln353">    AppendDocKeyItems(hashed_group, out_);</a>
<a name="ln354"> </a>
<a name="ln355">    return DocKeyEncoderAfterHashStep(out_);</a>
<a name="ln356">  }</a>
<a name="ln357"> </a>
<a name="ln358">  template &lt;class HashCollection, class RangeCollection&gt;</a>
<a name="ln359">  void HashAndRange(uint16_t hash, const HashCollection&amp; hashed_group,</a>
<a name="ln360">                    const RangeCollection&amp; range_collection) {</a>
<a name="ln361">    Hash(hash, hashed_group).Range(range_collection);</a>
<a name="ln362">  }</a>
<a name="ln363"> </a>
<a name="ln364">  void HashAndRange(uint16_t hash, const std::initializer_list&lt;PrimitiveValue&gt;&amp; hashed_group,</a>
<a name="ln365">                    const std::initializer_list&lt;PrimitiveValue&gt;&amp; range_collection) {</a>
<a name="ln366">    Hash(hash, hashed_group).Range(range_collection);</a>
<a name="ln367">  }</a>
<a name="ln368"> </a>
<a name="ln369"> private:</a>
<a name="ln370">  KeyBytes* out_;</a>
<a name="ln371">};</a>
<a name="ln372"> </a>
<a name="ln373">class DocKeyEncoder {</a>
<a name="ln374"> public:</a>
<a name="ln375">  explicit DocKeyEncoder(KeyBytes* out) : out_(out) {}</a>
<a name="ln376"> </a>
<a name="ln377">  DocKeyEncoderAfterTableIdStep CotableId(const Uuid&amp; cotable_id);</a>
<a name="ln378"> </a>
<a name="ln379">  DocKeyEncoderAfterTableIdStep PgtableId(const PgTableOid pgtable_id);</a>
<a name="ln380"> </a>
<a name="ln381">  DocKeyEncoderAfterTableIdStep Schema(const Schema&amp; schema);</a>
<a name="ln382"> </a>
<a name="ln383"> private:</a>
<a name="ln384">  KeyBytes* out_;</a>
<a name="ln385">};</a>
<a name="ln386"> </a>
<a name="ln387">class DocKeyDecoder {</a>
<a name="ln388"> public:</a>
<a name="ln389">  explicit DocKeyDecoder(const Slice&amp; input) : input_(input) {}</a>
<a name="ln390"> </a>
<a name="ln391">  Result&lt;bool&gt; DecodeCotableId(Uuid* uuid = nullptr);</a>
<a name="ln392">  Result&lt;bool&gt; DecodePgtableId(PgTableOid* pgtable_id = nullptr);</a>
<a name="ln393"> </a>
<a name="ln394">  Result&lt;bool&gt; HasPrimitiveValue();</a>
<a name="ln395"> </a>
<a name="ln396">  Result&lt;bool&gt; DecodeHashCode(</a>
<a name="ln397">      uint16_t* out = nullptr, AllowSpecial allow_special = AllowSpecial::kFalse);</a>
<a name="ln398"> </a>
<a name="ln399">  Result&lt;bool&gt; DecodeHashCode(AllowSpecial allow_special) {</a>
<a name="ln400">    return DecodeHashCode(nullptr /* out */, allow_special);</a>
<a name="ln401">  }</a>
<a name="ln402"> </a>
<a name="ln403">  CHECKED_STATUS DecodePrimitiveValue(</a>
<a name="ln404">      PrimitiveValue* out = nullptr, AllowSpecial allow_special = AllowSpecial::kFalse);</a>
<a name="ln405"> </a>
<a name="ln406">  CHECKED_STATUS DecodePrimitiveValue(AllowSpecial allow_special) {</a>
<a name="ln407">    return DecodePrimitiveValue(nullptr /* out */, allow_special);</a>
<a name="ln408">  }</a>
<a name="ln409"> </a>
<a name="ln410">  CHECKED_STATUS ConsumeGroupEnd();</a>
<a name="ln411"> </a>
<a name="ln412">  bool GroupEnded() const;</a>
<a name="ln413"> </a>
<a name="ln414">  const Slice&amp; left_input() const {</a>
<a name="ln415">    return input_;</a>
<a name="ln416">  }</a>
<a name="ln417"> </a>
<a name="ln418">  size_t ConsumedSizeFrom(const uint8_t* start) const {</a>
<a name="ln419">    return input_.data() - start;</a>
<a name="ln420">  }</a>
<a name="ln421"> </a>
<a name="ln422">  Slice* mutable_input() {</a>
<a name="ln423">    return &amp;input_;</a>
<a name="ln424">  }</a>
<a name="ln425"> </a>
<a name="ln426">  CHECKED_STATUS DecodeToRangeGroup();</a>
<a name="ln427"> </a>
<a name="ln428"> private:</a>
<a name="ln429">  Slice input_;</a>
<a name="ln430">};</a>
<a name="ln431"> </a>
<a name="ln432">// Clears range components from provided key. Returns true if they were exists.</a>
<a name="ln433">Result&lt;bool&gt; ClearRangeComponents(KeyBytes* out, AllowSpecial allow_special = AllowSpecial::kFalse);</a>
<a name="ln434"> </a>
<a name="ln435">// Returns true if both keys have hashed components and them are equal or both keys don't have</a>
<a name="ln436">// hashed components and first range components are equal and false otherwise.</a>
<a name="ln437">Result&lt;bool&gt; HashedOrFirstRangeComponentsEqual(const Slice&amp; lhs, const Slice&amp; rhs);</a>
<a name="ln438"> </a>
<a name="ln439">bool DocKeyBelongsTo(Slice doc_key, const Schema&amp; schema);</a>
<a name="ln440"> </a>
<a name="ln441">// Consumes single primitive value from start of slice.</a>
<a name="ln442">// Returns true when value was consumed, false when group end is found. The group end byte is</a>
<a name="ln443">// consumed in the latter case.</a>
<a name="ln444">Result&lt;bool&gt; ConsumePrimitiveValueFromKey(Slice* slice);</a>
<a name="ln445"> </a>
<a name="ln446">// Consume a group of document key components, ending with ValueType::kGroupEnd.</a>
<a name="ln447">// @param slice - the current point at which we are decoding a key</a>
<a name="ln448">// @param result - vector to append decoded values to.</a>
<a name="ln449">Status ConsumePrimitiveValuesFromKey(rocksdb::Slice* slice,</a>
<a name="ln450">                                     std::vector&lt;PrimitiveValue&gt;* result);</a>
<a name="ln451"> </a>
<a name="ln452">Result&lt;boost::optional&lt;DocKeyHash&gt;&gt; DecodeDocKeyHash(const Slice&amp; encoded_key);</a>
<a name="ln453"> </a>
<a name="ln454">inline std::ostream&amp; operator &lt;&lt;(std::ostream&amp; out, const DocKey&amp; doc_key) {</a>
<a name="ln455">  out &lt;&lt; doc_key.ToString();</a>
<a name="ln456">  return out;</a>
<a name="ln457">}</a>
<a name="ln458"> </a>
<a name="ln459">// ------------------------------------------------------------------------------------------------</a>
<a name="ln460">// SubDocKey</a>
<a name="ln461">// ------------------------------------------------------------------------------------------------</a>
<a name="ln462"> </a>
<a name="ln463">// A key pointing to a subdocument. Consists of a DocKey identifying the document, a list of</a>
<a name="ln464">// primitive values leading to the subdocument in question, from the outermost to innermost order,</a>
<a name="ln465">// and an optional hybrid_time of when the subdocument (which may itself be a primitive value) was</a>
<a name="ln466">// last fully overwritten or deleted.</a>
<a name="ln467">//</a>
<a name="ln468">// Keys stored in RocksDB should always have the hybrid_time field set. However, it is useful to</a>
<a name="ln469">// make the hybrid_time field optional while a SubDocKey is being constructed. If the hybrid_time</a>
<a name="ln470">// is not set, it is omitted from the encoded representation of a SubDocKey.</a>
<a name="ln471">//</a>
<a name="ln472">// Implementation note: we use HybridTime::kInvalid to represent an omitted hybrid_time.</a>
<a name="ln473">// We rely on that being the default-constructed value of a HybridTime.</a>
<a name="ln474">//</a>
<a name="ln475">// TODO: this should be renamed to something more generic, e.g. Key or LogicalKey, to reflect that</a>
<a name="ln476">// this is actually the logical representation of keys that we store in the RocksDB key-value store.</a>
<a name="ln477">class SubDocKey {</a>
<a name="ln478"> public:</a>
<a name="ln479">  SubDocKey() {}</a>
<a name="ln480">  explicit SubDocKey(const DocKey&amp; doc_key) : doc_key_(doc_key) {}</a>
<a name="ln481">  explicit SubDocKey(DocKey&amp;&amp; doc_key) : doc_key_(std::move(doc_key)) {}</a>
<a name="ln482"> </a>
<a name="ln483">  SubDocKey(const DocKey&amp; doc_key, HybridTime hybrid_time)</a>
<a name="ln484">      : doc_key_(doc_key),</a>
<a name="ln485">        doc_ht_(DocHybridTime(hybrid_time)) {</a>
<a name="ln486">  }</a>
<a name="ln487"> </a>
<a name="ln488">  SubDocKey(DocKey&amp;&amp; doc_key,</a>
<a name="ln489">            HybridTime hybrid_time)</a>
<a name="ln490">      : doc_key_(std::move(doc_key)),</a>
<a name="ln491">        doc_ht_(DocHybridTime(hybrid_time)) {</a>
<a name="ln492">  }</a>
<a name="ln493"> </a>
<a name="ln494">  SubDocKey(const DocKey&amp; doc_key, const DocHybridTime&amp; hybrid_time)</a>
<a name="ln495">      : doc_key_(doc_key),</a>
<a name="ln496">        doc_ht_(std::move(hybrid_time)) {</a>
<a name="ln497">  }</a>
<a name="ln498"> </a>
<a name="ln499">  SubDocKey(const DocKey&amp; doc_key,</a>
<a name="ln500">            DocHybridTime doc_hybrid_time,</a>
<a name="ln501">            const std::vector&lt;PrimitiveValue&gt;&amp; subkeys)</a>
<a name="ln502">      : doc_key_(doc_key),</a>
<a name="ln503">        doc_ht_(doc_hybrid_time),</a>
<a name="ln504">        subkeys_(subkeys) {</a>
<a name="ln505">  }</a>
<a name="ln506"> </a>
<a name="ln507">  SubDocKey(const DocKey&amp; doc_key,</a>
<a name="ln508">            HybridTime hybrid_time,</a>
<a name="ln509">            const std::vector&lt;PrimitiveValue&gt;&amp; subkeys)</a>
<a name="ln510">      : doc_key_(doc_key),</a>
<a name="ln511">        doc_ht_(DocHybridTime(hybrid_time)),</a>
<a name="ln512">        subkeys_(subkeys) {</a>
<a name="ln513">  }</a>
<a name="ln514"> </a>
<a name="ln515">  template &lt;class ...T&gt;</a>
<a name="ln516">  SubDocKey(const DocKey&amp; doc_key, T... subkeys_and_maybe_hybrid_time)</a>
<a name="ln517">      : doc_key_(doc_key),</a>
<a name="ln518">        doc_ht_(DocHybridTime::kInvalid) {</a>
<a name="ln519">    AppendSubKeysAndMaybeHybridTime(subkeys_and_maybe_hybrid_time...);</a>
<a name="ln520">  }</a>
<a name="ln521"> </a>
<a name="ln522">  CHECKED_STATUS FromDocPath(const DocPath&amp; doc_path);</a>
<a name="ln523"> </a>
<a name="ln524">  // Return the subkeys within this SubDocKey</a>
<a name="ln525">  const std::vector&lt;PrimitiveValue&gt;&amp; subkeys() const {</a>
<a name="ln526">    return subkeys_;</a>
<a name="ln527">  }</a>
<a name="ln528"> </a>
<a name="ln529">  std::vector&lt;PrimitiveValue&gt;&amp; subkeys() {</a>
<a name="ln530">    return subkeys_;</a>
<a name="ln531">  }</a>
<a name="ln532"> </a>
<a name="ln533">  // Append a sequence of sub-keys to this key.</a>
<a name="ln534">  template&lt;class ...T&gt;</a>
<a name="ln535">  void AppendSubKeysAndMaybeHybridTime(PrimitiveValue subdoc_key,</a>
<a name="ln536">                                       T... subkeys_and_maybe_hybrid_time) {</a>
<a name="ln537">    subkeys_.push_back(std::move(subdoc_key));</a>
<a name="ln538">    AppendSubKeysAndMaybeHybridTime(subkeys_and_maybe_hybrid_time...);</a>
<a name="ln539">  }</a>
<a name="ln540"> </a>
<a name="ln541">  void AppendSubKey(PrimitiveValue subkey) {</a>
<a name="ln542">    subkeys_.emplace_back(std::move(subkey));</a>
<a name="ln543">  }</a>
<a name="ln544"> </a>
<a name="ln545">  template&lt;class ...T&gt;</a>
<a name="ln546">  void AppendSubKeysAndMaybeHybridTime(PrimitiveValue subdoc_key) {</a>
<a name="ln547">    subkeys_.emplace_back(std::move(subdoc_key));</a>
<a name="ln548">  }</a>
<a name="ln549"> </a>
<a name="ln550">  template&lt;class ...T&gt;</a>
<a name="ln551">  void AppendSubKeysAndMaybeHybridTime(PrimitiveValue subdoc_key, HybridTime hybrid_time) {</a>
<a name="ln552">    DCHECK(!has_hybrid_time());</a>
<a name="ln553">    subkeys_.emplace_back(subdoc_key);</a>
<a name="ln554">    DCHECK(hybrid_time.is_valid());</a>
<a name="ln555">    doc_ht_ = DocHybridTime(hybrid_time);</a>
<a name="ln556">  }</a>
<a name="ln557"> </a>
<a name="ln558">  void RemoveLastSubKey() {</a>
<a name="ln559">    DCHECK(!subkeys_.empty());</a>
<a name="ln560">    subkeys_.pop_back();</a>
<a name="ln561">  }</a>
<a name="ln562"> </a>
<a name="ln563">  void KeepPrefix(int num_sub_keys_to_keep) {</a>
<a name="ln564">    if (subkeys_.size() &gt; num_sub_keys_to_keep) {</a>
<a name="ln565">      subkeys_.resize(num_sub_keys_to_keep);</a>
<a name="ln566">    }</a>
<a name="ln567">  }</a>
<a name="ln568"> </a>
<a name="ln569">  void remove_hybrid_time() {</a>
<a name="ln570">    doc_ht_ = DocHybridTime::kInvalid;</a>
<a name="ln571">  }</a>
<a name="ln572"> </a>
<a name="ln573">  void Clear();</a>
<a name="ln574"> </a>
<a name="ln575">  bool IsValid() const {</a>
<a name="ln576">    return !doc_key_.empty();</a>
<a name="ln577">  }</a>
<a name="ln578"> </a>
<a name="ln579">  KeyBytes Encode() const { return DoEncode(true /* include_hybrid_time */); }</a>
<a name="ln580">  KeyBytes EncodeWithoutHt() const { return DoEncode(false /* include_hybrid_time */); }</a>
<a name="ln581"> </a>
<a name="ln582">  // Decodes a SubDocKey from the given slice, typically retrieved from a RocksDB key.</a>
<a name="ln583">  // @param slice</a>
<a name="ln584">  //     A pointer to the slice containing the bytes to decode the SubDocKey from. This slice is</a>
<a name="ln585">  //     modified, with consumed bytes being removed.</a>
<a name="ln586">  // @param require_hybrid_time</a>
<a name="ln587">  //     Whether a hybrid_time is required in the end of the SubDocKey. If this is true, we require</a>
<a name="ln588">  //     a ValueType::kHybridTime byte followed by a hybrid_time to be present in the input slice.</a>
<a name="ln589">  //     Otherwise, we allow decoding an incomplete SubDocKey without a hybrid_time in the end. Note</a>
<a name="ln590">  //     that we also allow input that has a few bytes in the end but not enough to represent a</a>
<a name="ln591">  //     hybrid_time.</a>
<a name="ln592">  // @param allow_special</a>
<a name="ln593">  //     Whether it is allowed to have special value types in slice, that are used during seek.</a>
<a name="ln594">  //     If such value type is found, decoding is stopped w/o error.</a>
<a name="ln595">  CHECKED_STATUS DecodeFrom(rocksdb::Slice* slice,</a>
<a name="ln596">                            HybridTimeRequired require_hybrid_time = HybridTimeRequired::kTrue,</a>
<a name="ln597">                            AllowSpecial allow_special = AllowSpecial::kFalse);</a>
<a name="ln598"> </a>
<a name="ln599">  // Similar to DecodeFrom, but requires that the entire slice is decoded, and thus takes a const</a>
<a name="ln600">  // reference to a slice. This still respects the require_hybrid_time parameter, but in case a</a>
<a name="ln601">  // hybrid_time is omitted, we don't allow any extra bytes to be present in the slice.</a>
<a name="ln602">  CHECKED_STATUS FullyDecodeFrom(</a>
<a name="ln603">      const rocksdb::Slice&amp; slice,</a>
<a name="ln604">      HybridTimeRequired hybrid_time_required = HybridTimeRequired::kTrue);</a>
<a name="ln605"> </a>
<a name="ln606">  // Splits given RocksDB key into vector of slices that forms range_group of document key and</a>
<a name="ln607">  // hybrid_time.</a>
<a name="ln608">  static CHECKED_STATUS PartiallyDecode(Slice* slice,</a>
<a name="ln609">                                        boost::container::small_vector_base&lt;Slice&gt;* out);</a>
<a name="ln610"> </a>
<a name="ln611">  // Splits the given RocksDB sub key into a vector of slices that forms the range group of document</a>
<a name="ln612">  // key and sub keys.</a>
<a name="ln613">  //</a>
<a name="ln614">  // We don't use Result&lt;...&gt; to be able to reuse memory allocated by out.</a>
<a name="ln615">  //</a>
<a name="ln616">  // When key does not start with a hash component, the returned prefix would start with the first</a>
<a name="ln617">  // range component.</a>
<a name="ln618">  //</a>
<a name="ln619">  // For instance, for a (hash_value, h1, h2, r1, r2, s1) doc key the following values will be</a>
<a name="ln620">  // returned:</a>
<a name="ln621">  // encoded_length(hash_value, h1, h2) &lt;-------------- (includes the kGroupEnd of the hashed part)</a>
<a name="ln622">  // encoded_length(hash_value, h1, h2, r1)</a>
<a name="ln623">  // encoded_length(hash_value, h1, h2, r1, r2)</a>
<a name="ln624">  // encoded_length(hash_value, h1, h2, r1, r2, s1) &lt;------- (includes kGroupEnd of the range part).</a>
<a name="ln625">  static CHECKED_STATUS DecodePrefixLengths(</a>
<a name="ln626">      Slice slice, boost::container::small_vector_base&lt;size_t&gt;* out);</a>
<a name="ln627"> </a>
<a name="ln628">  // Fills out with ends of SubDocKey components.  First item in out will be size of ID part</a>
<a name="ln629">  // (cotable id or pgtable id) of DocKey (0 if ID is not present), second size of whole DocKey,</a>
<a name="ln630">  // third size of DocKey + size of first subkey, and so on.</a>
<a name="ln631">  //</a>
<a name="ln632">  // To illustrate,</a>
<a name="ln633">  // * for key</a>
<a name="ln634">  //     SubDocKey(DocKey(0xfca0, [3], []), [SystemColumnId(0); HT{ physical: 1581475435181551 }])</a>
<a name="ln635">  //   aka</a>
<a name="ln636">  //     47FCA0488000000321214A80238001B5E605A0CA10804A</a>
<a name="ln637">  //   (and with spaces to make it clearer)</a>
<a name="ln638">  //     47FCA0 4880000003 21 21 4A80 238001B5E605A0CA10804A</a>
<a name="ln639">  //   the ends will be</a>
<a name="ln640">  //     {0, 10, 12}</a>
<a name="ln641">  // * for key</a>
<a name="ln642">  //     SubDocKey(DocKey(PgTableId=16385, [], [5]), [SystemColumnId(0); HT{ physical: ... }])</a>
<a name="ln643">  //   aka</a>
<a name="ln644">  //     30000040014880000005214A80238001B5E700309553804A</a>
<a name="ln645">  //   (and with spaces to make it clearer)</a>
<a name="ln646">  //     3000004001 4880000005 21 4A80 238001B5E700309553804A</a>
<a name="ln647">  //   the ends will be</a>
<a name="ln648">  //     {5, 11, 13}</a>
<a name="ln649">  // * for key</a>
<a name="ln650">  //     SubDocKey(DocKey(PgTableId=16385, [], []), [HT{ physical: 1581471227403848 }])</a>
<a name="ln651">  //   aka</a>
<a name="ln652">  //     300000400121238001B5E7006E61B7804A</a>
<a name="ln653">  //   (and with spaces to make it clearer)</a>
<a name="ln654">  //     3000004001 21 238001B5E7006E61B7804A</a>
<a name="ln655">  //   the ends will be</a>
<a name="ln656">  //     {5}</a>
<a name="ln657">  //</a>
<a name="ln658">  // If out is not empty, then it will be interpreted as partial result for this decoding operation</a>
<a name="ln659">  // and the appropriate prefix will be skipped.</a>
<a name="ln660">  static CHECKED_STATUS DecodeDocKeyAndSubKeyEnds(</a>
<a name="ln661">      Slice slice, boost::container::small_vector_base&lt;size_t&gt;* out);</a>
<a name="ln662"> </a>
<a name="ln663">  // Attempts to decode a subkey at the beginning of the given slice, consuming the corresponding</a>
<a name="ln664">  // prefix of the slice. Returns false if there is no next subkey, as indicated by the slice being</a>
<a name="ln665">  // empty or encountering an encoded hybrid time.</a>
<a name="ln666">  static Result&lt;bool&gt; DecodeSubkey(Slice* slice);</a>
<a name="ln667"> </a>
<a name="ln668">  CHECKED_STATUS FullyDecodeFromKeyWithOptionalHybridTime(const rocksdb::Slice&amp; slice) {</a>
<a name="ln669">    return FullyDecodeFrom(slice, HybridTimeRequired::kFalse);</a>
<a name="ln670">  }</a>
<a name="ln671"> </a>
<a name="ln672">  std::string ToString() const;</a>
<a name="ln673">  static std::string DebugSliceToString(Slice slice);</a>
<a name="ln674">  static Result&lt;std::string&gt; DebugSliceToStringAsResult(Slice slice);</a>
<a name="ln675"> </a>
<a name="ln676">  const DocKey&amp; doc_key() const {</a>
<a name="ln677">    return doc_key_;</a>
<a name="ln678">  }</a>
<a name="ln679"> </a>
<a name="ln680">  DocKey&amp; doc_key() {</a>
<a name="ln681">    return doc_key_;</a>
<a name="ln682">  }</a>
<a name="ln683"> </a>
<a name="ln684">  int num_subkeys() const {</a>
<a name="ln685">    return subkeys_.size();</a>
<a name="ln686">  }</a>
<a name="ln687"> </a>
<a name="ln688">  bool StartsWith(const SubDocKey&amp; prefix) const;</a>
<a name="ln689"> </a>
<a name="ln690">  bool operator ==(const SubDocKey&amp; other) const;</a>
<a name="ln691"> </a>
<a name="ln692">  bool operator !=(const SubDocKey&amp; other) const {</a>
<a name="ln693">    return !(*this == other);</a>
<a name="ln694">  }</a>
<a name="ln695"> </a>
<a name="ln696">  const PrimitiveValue&amp; last_subkey() const {</a>
<a name="ln697">    assert(!subkeys_.empty());</a>
<a name="ln698">    return subkeys_.back();</a>
<a name="ln699">  }</a>
<a name="ln700"> </a>
<a name="ln701">  int CompareTo(const SubDocKey&amp; other) const;</a>
<a name="ln702">  int CompareToIgnoreHt(const SubDocKey&amp; other) const;</a>
<a name="ln703"> </a>
<a name="ln704">  bool operator &lt;(const SubDocKey&amp; other) const {</a>
<a name="ln705">    return CompareTo(other) &lt; 0;</a>
<a name="ln706">  }</a>
<a name="ln707"> </a>
<a name="ln708">  bool operator &lt;=(const SubDocKey&amp; other) const {</a>
<a name="ln709">    return CompareTo(other) &lt;= 0;</a>
<a name="ln710">  }</a>
<a name="ln711"> </a>
<a name="ln712">  bool operator &gt;(const SubDocKey&amp; other) const {</a>
<a name="ln713">    return CompareTo(other) &gt; 0;</a>
<a name="ln714">  }</a>
<a name="ln715"> </a>
<a name="ln716">  bool operator &gt;=(const SubDocKey&amp; other) const {</a>
<a name="ln717">    return CompareTo(other) &gt;= 0;</a>
<a name="ln718">  }</a>
<a name="ln719"> </a>
<a name="ln720">  HybridTime hybrid_time() const {</a>
<a name="ln721">    DCHECK(has_hybrid_time());</a>
<a name="ln722">    return doc_ht_.hybrid_time();</a>
<a name="ln723">  }</a>
<a name="ln724"> </a>
<a name="ln725">  const DocHybridTime&amp; doc_hybrid_time() const {</a>
<a name="ln726">    DCHECK(has_hybrid_time());</a>
<a name="ln727">    return doc_ht_;</a>
<a name="ln728">  }</a>
<a name="ln729"> </a>
<a name="ln730">  void set_hybrid_time(const DocHybridTime&amp; hybrid_time) {</a>
<a name="ln731">    DCHECK(hybrid_time.is_valid());</a>
<a name="ln732">    doc_ht_ = hybrid_time;</a>
<a name="ln733">  }</a>
<a name="ln734"> </a>
<a name="ln735">  bool has_hybrid_time() const {</a>
<a name="ln736">    return doc_ht_.is_valid();</a>
<a name="ln737">  }</a>
<a name="ln738"> </a>
<a name="ln739">  // Generate a RocksDB key that would allow us to seek to the smallest SubDocKey that has a</a>
<a name="ln740">  // lexicographically higher sequence of subkeys than this one, but is not an extension of this</a>
<a name="ln741">  // sequence of subkeys.  In other words, ensure we advance to the next field (subkey) either</a>
<a name="ln742">  // within the object (subdocument) we are currently scanning, or at any higher level, including</a>
<a name="ln743">  // advancing to the next document key.</a>
<a name="ln744">  //</a>
<a name="ln745">  // E.g. assuming the SubDocKey this is being called on is #2 from the following example,</a>
<a name="ln746">  // performing a RocksDB seek on the return value of this takes us to #7.</a>
<a name="ln747">  //</a>
<a name="ln748">  // 1. SubDocKey(DocKey([], [&quot;a&quot;]), [HT(1)]) -&gt; {}</a>
<a name="ln749">  // 2. SubDocKey(DocKey([], [&quot;a&quot;]), [&quot;x&quot;, HT(1)]) -&gt; {} ---------------------------.</a>
<a name="ln750">  // 3. SubDocKey(DocKey([], [&quot;a&quot;]), [&quot;x&quot;, &quot;x&quot;, HT(2)]) -&gt; null                     |</a>
<a name="ln751">  // 4. SubDocKey(DocKey([], [&quot;a&quot;]), [&quot;x&quot;, &quot;x&quot;, HT(1)]) -&gt; {}                       |</a>
<a name="ln752">  // 5. SubDocKey(DocKey([], [&quot;a&quot;]), [&quot;x&quot;, &quot;x&quot;, &quot;y&quot;, HT(1)]) -&gt; {}                  |</a>
<a name="ln753">  // 6. SubDocKey(DocKey([], [&quot;a&quot;]), [&quot;x&quot;, &quot;x&quot;, &quot;y&quot;, &quot;x&quot;, HT(1)]) -&gt; true           |</a>
<a name="ln754">  // 7. SubDocKey(DocKey([], [&quot;a&quot;]), [&quot;y&quot;, HT(3)]) -&gt; {}                  &lt;---------</a>
<a name="ln755">  // 8. SubDocKey(DocKey([], [&quot;a&quot;]), [&quot;y&quot;, &quot;y&quot;, HT(3)]) -&gt; {}</a>
<a name="ln756">  // 9. SubDocKey(DocKey([], [&quot;a&quot;]), [&quot;y&quot;, &quot;y&quot;, &quot;x&quot;, HT(3)]) -&gt;</a>
<a name="ln757">  //</a>
<a name="ln758">  // This is achieved by simply appending a byte that is higher than any ValueType in an encoded</a>
<a name="ln759">  // representation of a SubDocKey that extends the vector of subkeys present in the current one,</a>
<a name="ln760">  // or has the same vector of subkeys, i.e. key/value pairs #3-6 in the above example. HybridTime</a>
<a name="ln761">  // is omitted from the resulting encoded representation.</a>
<a name="ln762">  KeyBytes AdvanceOutOfSubDoc() const;</a>
<a name="ln763"> </a>
<a name="ln764">  // Similar to AdvanceOutOfSubDoc, but seek to the smallest key that skips documents with this</a>
<a name="ln765">  // DocKey and DocKeys that have the same hash components but add more range components to it.</a>
<a name="ln766">  //</a>
<a name="ln767">  // E.g. assuming the SubDocKey this is being called on is #2 from the following example:</a>
<a name="ln768">  //</a>
<a name="ln769">  //  1. SubDocKey(DocKey(0x1234, [&quot;a&quot;, &quot;b&quot;], [&quot;c&quot;, &quot;d&quot;]), [HT(1)]) -&gt; {}</a>
<a name="ln770">  //  2. SubDocKey(DocKey(0x1234, [&quot;a&quot;, &quot;b&quot;], [&quot;c&quot;, &quot;d&quot;]), [&quot;x&quot;, HT(1)]) -&gt; {} &lt;----------------.</a>
<a name="ln771">  //  3. SubDocKey(DocKey(0x1234, [&quot;a&quot;, &quot;b&quot;], [&quot;c&quot;, &quot;d&quot;]), [&quot;x&quot;, &quot;x&quot;, HT(2)]) -&gt; null           |</a>
<a name="ln772">  //  4. SubDocKey(DocKey(0x1234, [&quot;a&quot;, &quot;b&quot;], [&quot;c&quot;, &quot;d&quot;]), [&quot;x&quot;, &quot;x&quot;, HT(1)]) -&gt; {}             |</a>
<a name="ln773">  //  5. SubDocKey(DocKey(0x1234, [&quot;a&quot;, &quot;b&quot;], [&quot;c&quot;, &quot;d&quot;]), [&quot;x&quot;, &quot;x&quot;, &quot;y&quot;, HT(1)]) -&gt; {}        |</a>
<a name="ln774">  //  6. SubDocKey(DocKey(0x1234, [&quot;a&quot;, &quot;b&quot;], [&quot;c&quot;, &quot;d&quot;]), [&quot;x&quot;, &quot;x&quot;, &quot;y&quot;, &quot;x&quot;, HT(1)]) -&gt; true |</a>
<a name="ln775">  //  7. SubDocKey(DocKey(0x1234, [&quot;a&quot;, &quot;b&quot;], [&quot;c&quot;, &quot;d&quot;]), [&quot;y&quot;, HT(3)]) -&gt; {}                  |</a>
<a name="ln776">  //  8. SubDocKey(DocKey(0x1234, [&quot;a&quot;, &quot;b&quot;], [&quot;c&quot;, &quot;d&quot;]), [&quot;y&quot;, &quot;y&quot;, HT(3)]) -&gt; {}             |</a>
<a name="ln777">  //  9. SubDocKey(DocKey(0x1234, [&quot;a&quot;, &quot;b&quot;], [&quot;c&quot;, &quot;d&quot;]), [&quot;y&quot;, &quot;y&quot;, &quot;x&quot;, HT(3)]) -&gt; {}        |</a>
<a name="ln778">  // ...                                                                                        |</a>
<a name="ln779">  // 20. SubDocKey(DocKey(0x1234, [&quot;a&quot;, &quot;b&quot;], [&quot;c&quot;, &quot;d&quot;, &quot;e&quot;]), [&quot;y&quot;, HT(3)]) -&gt; {}             |</a>
<a name="ln780">  // 21. SubDocKey(DocKey(0x1234, [&quot;a&quot;, &quot;b&quot;], [&quot;c&quot;, &quot;d&quot;, &quot;e&quot;]), [&quot;z&quot;, HT(3)]) -&gt; {}             |</a>
<a name="ln781">  // 22. SubDocKey(DocKey(0x1234, [&quot;a&quot;, &quot;b&quot;], [&quot;c&quot;, &quot;f&quot;]), [HT(1)]) -&gt; {}      &lt;--- (*** 1 ***)-|</a>
<a name="ln782">  // 23. SubDocKey(DocKey(0x1234, [&quot;a&quot;, &quot;b&quot;], [&quot;c&quot;, &quot;f&quot;]), [&quot;x&quot;, HT(1)]) -&gt; {}                  |</a>
<a name="ln783">  // ...                                                                                        |</a>
<a name="ln784">  // 30. SubDocKey(DocKey(0x2345, [&quot;a&quot;, &quot;c&quot;], [&quot;c&quot;, &quot;f&quot;]), [HT(1)]) -&gt; {}      &lt;--- (*** 2 ***)-</a>
<a name="ln785">  // 31. SubDocKey(DocKey(0x2345, [&quot;a&quot;, &quot;c&quot;], [&quot;c&quot;, &quot;f&quot;]), [&quot;x&quot;, HT(1)]) -&gt; {}</a>
<a name="ln786">  //</a>
<a name="ln787">  // SubDocKey(DocKey(0x1234, [&quot;a&quot;, &quot;b&quot;], [&quot;c&quot;, &quot;d&quot;])).AdvanceOutOfDocKeyPrefix() will seek to #22</a>
<a name="ln788">  // (*** 1 ***), pass doc keys with additional range components when they are present.</a>
<a name="ln789">  //</a>
<a name="ln790">  // And when given a doc key without range component like below, it can help seek pass all doc</a>
<a name="ln791">  // keys with the same hash components, e.g.</a>
<a name="ln792">  // SubDocKey(DocKey(0x1234, [&quot;a&quot;, &quot;b&quot;], [])).AdvanceOutOfDocKeyPrefix() will seek to #30</a>
<a name="ln793">  // (*** 2 ***).</a>
<a name="ln794"> </a>
<a name="ln795">  KeyBytes AdvanceOutOfDocKeyPrefix() const;</a>
<a name="ln796"> </a>
<a name="ln797"> private:</a>
<a name="ln798">  class DecodeCallback;</a>
<a name="ln799">  friend class DecodeCallback;</a>
<a name="ln800"> </a>
<a name="ln801">  // Attempts to decode and consume a subkey from the beginning of the given slice.</a>
<a name="ln802">  // A non-error false result means e.g. that the slice is empty or if the next thing is an encoded</a>
<a name="ln803">  // hybrid time.</a>
<a name="ln804">  template&lt;class Callback&gt;</a>
<a name="ln805">  static Result&lt;bool&gt; DecodeSubkey(Slice* slice, const Callback&amp; callback);</a>
<a name="ln806"> </a>
<a name="ln807">  template&lt;class Callback&gt;</a>
<a name="ln808">  static Status DoDecode(rocksdb::Slice* slice,</a>
<a name="ln809">                         HybridTimeRequired require_hybrid_time,</a>
<a name="ln810">                         AllowSpecial allow_special,</a>
<a name="ln811">                         const Callback&amp; callback);</a>
<a name="ln812"> </a>
<a name="ln813">  KeyBytes DoEncode(bool include_hybrid_time) const;</a>
<a name="ln814"> </a>
<a name="ln815">  DocKey doc_key_;</a>
<a name="ln816">  DocHybridTime doc_ht_;</a>
<a name="ln817"> </a>
<a name="ln818">  // TODO: make this a small_vector.</a>
<a name="ln819">  std::vector&lt;PrimitiveValue&gt; subkeys_;</a>
<a name="ln820">};</a>
<a name="ln821"> </a>
<a name="ln822">inline std::ostream&amp; operator &lt;&lt;(std::ostream&amp; out, const SubDocKey&amp; subdoc_key) {</a>
<a name="ln823">  out &lt;&lt; subdoc_key.ToString();</a>
<a name="ln824">  return out;</a>
<a name="ln825">}</a>
<a name="ln826"> </a>
<a name="ln827">// A best-effort to decode the given sequence of key bytes as either a DocKey or a SubDocKey.</a>
<a name="ln828">// If not possible to decode, return the key_bytes directly as a readable string.</a>
<a name="ln829">std::string BestEffortDocDBKeyToStr(const KeyBytes &amp;key_bytes);</a>
<a name="ln830">std::string BestEffortDocDBKeyToStr(const rocksdb::Slice &amp;slice);</a>
<a name="ln831"> </a>
<a name="ln832">class DocDbAwareFilterPolicyBase : public rocksdb::FilterPolicy {</a>
<a name="ln833"> public:</a>
<a name="ln834">  explicit DocDbAwareFilterPolicyBase(size_t filter_block_size_bits, rocksdb::Logger* logger) {</a>
<a name="ln835">    builtin_policy_.reset(rocksdb::NewFixedSizeFilterPolicy(</a>
<a name="ln836">        filter_block_size_bits, rocksdb::FilterPolicy::kDefaultFixedSizeFilterErrorRate, logger));</a>
<a name="ln837">  }</a>
<a name="ln838"> </a>
<a name="ln839">  void CreateFilter(const rocksdb::Slice* keys, int n, std::string* dst) const override;</a>
<a name="ln840"> </a>
<a name="ln841">  bool KeyMayMatch(const rocksdb::Slice&amp; key, const rocksdb::Slice&amp; filter) const override;</a>
<a name="ln842"> </a>
<a name="ln843">  rocksdb::FilterBitsBuilder* GetFilterBitsBuilder() const override;</a>
<a name="ln844"> </a>
<a name="ln845">  rocksdb::FilterBitsReader* GetFilterBitsReader(const rocksdb::Slice&amp; contents) const override;</a>
<a name="ln846"> </a>
<a name="ln847">  FilterType GetFilterType() const override;</a>
<a name="ln848"> </a>
<a name="ln849"> private:</a>
<a name="ln850">  std::unique_ptr&lt;const rocksdb::FilterPolicy&gt; builtin_policy_;</a>
<a name="ln851">};</a>
<a name="ln852"> </a>
<a name="ln853">// This filter policy only takes into account hashed components of keys for filtering.</a>
<a name="ln854">class DocDbAwareHashedComponentsFilterPolicy : public DocDbAwareFilterPolicyBase {</a>
<a name="ln855"> public:</a>
<a name="ln856">  DocDbAwareHashedComponentsFilterPolicy(size_t filter_block_size_bits, rocksdb::Logger* logger)</a>
<a name="ln857">      : DocDbAwareFilterPolicyBase(filter_block_size_bits, logger) {}</a>
<a name="ln858"> </a>
<a name="ln859">  const char* Name() const override { return &quot;DocKeyHashedComponentsFilter&quot;; }</a>
<a name="ln860"> </a>
<a name="ln861">  const KeyTransformer* GetKeyTransformer() const override;</a>
<a name="ln862">};</a>
<a name="ln863"> </a>
<a name="ln864">// This filter policy takes into account following parts of keys for filtering:</a>
<a name="ln865">// - For range-based partitioned tables (such tables have 0 hashed components):</a>
<a name="ln866">// use all hash components of the doc key.</a>
<a name="ln867">// - For hash-based partitioned tables (such tables have &gt;0 hashed components):</a>
<a name="ln868">// use first range component of the doc key.</a>
<a name="ln869">class DocDbAwareV2FilterPolicy : public DocDbAwareFilterPolicyBase {</a>
<a name="ln870"> public:</a>
<a name="ln871">  DocDbAwareV2FilterPolicy(size_t filter_block_size_bits, rocksdb::Logger* logger)</a>
<a name="ln872">      : DocDbAwareFilterPolicyBase(filter_block_size_bits, logger) {}</a>
<a name="ln873"> </a>
<a name="ln874">  const char* Name() const override { return &quot;DocKeyV2Filter&quot;; }</a>
<a name="ln875"> </a>
<a name="ln876">  const KeyTransformer* GetKeyTransformer() const override;</a>
<a name="ln877">};</a>
<a name="ln878"> </a>
<a name="ln879">// Optional inclusive lower bound and exclusive upper bound for keys served by DocDB.</a>
<a name="ln880">// Could be used to split tablet without doing actual splitting of RocksDB files.</a>
<a name="ln881">// DocDBCompactionFilter also respects these bounds, so it will filter out non-relevant keys</a>
<a name="ln882">// during compaction.</a>
<a name="ln883">// Both bounds should be encoded DocKey or its part to avoid splitting DocDB row.</a>
<a name="ln884">struct KeyBounds {</a>
<a name="ln885">  KeyBytes lower;</a>
<a name="ln886">  KeyBytes upper;</a>
<a name="ln887"> </a>
<a name="ln888">  static const KeyBounds kNoBounds;</a>
<a name="ln889"> </a>
<a name="ln890">  KeyBounds() = default;</a>
<a name="ln891">  KeyBounds(const Slice&amp; _lower, const Slice&amp; _upper) : lower(_lower), upper(_upper) {}</a>
<a name="ln892"> </a>
<a name="ln893">  bool IsWithinBounds(const Slice&amp; key) const {</a>
<a name="ln894">    return (lower.empty() || key.compare(lower) &gt;= 0) &amp;&amp;</a>
<a name="ln895">           (upper.empty() || key.compare(upper) &lt; 0);</a>
<a name="ln896">  }</a>
<a name="ln897"> </a>
<a name="ln898">  bool IsInitialized() const {</a>
<a name="ln899">    return !lower.empty() || !upper.empty();</a>
<a name="ln900">  }</a>
<a name="ln901"> </a>
<a name="ln902">  std::string ToString() const {</a>
<a name="ln903">    return Format(&quot;{ lower: $0 upper: $1 }&quot;, lower, upper);</a>
<a name="ln904">  }</a>
<a name="ln905">};</a>
<a name="ln906"> </a>
<a name="ln907">// Combined DB to store regular records and intents.</a>
<a name="ln908">// TODO: move this to a more appropriate header file.</a>
<a name="ln909">struct DocDB {</a>
<a name="ln910">  rocksdb::DB* regular = nullptr;</a>
<a name="ln911">  rocksdb::DB* intents = nullptr;</a>
<a name="ln912">  const KeyBounds* key_bounds = nullptr;</a>
<a name="ln913"> </a>
<a name="ln914">  static DocDB FromRegularUnbounded(rocksdb::DB* regular) {</a>
<a name="ln915">    return {regular, nullptr /* intents */, &amp;KeyBounds::kNoBounds};</a>
<a name="ln916">  }</a>
<a name="ln917"> </a>
<a name="ln918">  DocDB WithoutIntents() {</a>
<a name="ln919">    return {regular, nullptr /* intents */, key_bounds};</a>
<a name="ln920">  }</a>
<a name="ln921">};</a>
<a name="ln922"> </a>
<a name="ln923">}  // namespace docdb</a>
<a name="ln924">}  // namespace yb</a>
<a name="ln925"> </a>
<a name="ln926">#endif  // YB_DOCDB_DOC_KEY_H_</a>

</code></pre>
<div class="balloon" rel="267"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="552"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="554"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="559"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="721"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="726"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="731"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
