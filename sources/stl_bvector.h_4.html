
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>stl_bvector.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// vector&lt;bool&gt; specialization -*- C++ -*-</a>
<a name="ln2"> </a>
<a name="ln3">// Copyright (C) 2001-2018 Free Software Foundation, Inc.</a>
<a name="ln4">//</a>
<a name="ln5">// This file is part of the GNU ISO C++ Library.  This library is free</a>
<a name="ln6">// software; you can redistribute it and/or modify it under the</a>
<a name="ln7">// terms of the GNU General Public License as published by the</a>
<a name="ln8">// Free Software Foundation; either version 3, or (at your option)</a>
<a name="ln9">// any later version.</a>
<a name="ln10"> </a>
<a name="ln11">// This library is distributed in the hope that it will be useful,</a>
<a name="ln12">// but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">// GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">// Under Section 7 of GPL version 3, you are granted additional</a>
<a name="ln17">// permissions described in the GCC Runtime Library Exception, version</a>
<a name="ln18">// 3.1, as published by the Free Software Foundation.</a>
<a name="ln19"> </a>
<a name="ln20">// You should have received a copy of the GNU General Public License and</a>
<a name="ln21">// a copy of the GCC Runtime Library Exception along with this program;</a>
<a name="ln22">// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see</a>
<a name="ln23">// &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln24"> </a>
<a name="ln25">/*</a>
<a name="ln26"> *</a>
<a name="ln27"> * Copyright (c) 1994</a>
<a name="ln28"> * Hewlett-Packard Company</a>
<a name="ln29"> *</a>
<a name="ln30"> * Permission to use, copy, modify, distribute and sell this software</a>
<a name="ln31"> * and its documentation for any purpose is hereby granted without fee,</a>
<a name="ln32"> * provided that the above copyright notice appear in all copies and</a>
<a name="ln33"> * that both that copyright notice and this permission notice appear</a>
<a name="ln34"> * in supporting documentation.  Hewlett-Packard Company makes no</a>
<a name="ln35"> * representations about the suitability of this software for any</a>
<a name="ln36"> * purpose.  It is provided &quot;as is&quot; without express or implied warranty.</a>
<a name="ln37"> *</a>
<a name="ln38"> *</a>
<a name="ln39"> * Copyright (c) 1996-1999</a>
<a name="ln40"> * Silicon Graphics Computer Systems, Inc.</a>
<a name="ln41"> *</a>
<a name="ln42"> * Permission to use, copy, modify, distribute and sell this software</a>
<a name="ln43"> * and its documentation for any purpose is hereby granted without fee,</a>
<a name="ln44"> * provided that the above copyright notice appear in all copies and</a>
<a name="ln45"> * that both that copyright notice and this permission notice appear</a>
<a name="ln46"> * in supporting documentation.  Silicon Graphics makes no</a>
<a name="ln47"> * representations about the suitability of this software for any</a>
<a name="ln48"> * purpose.  It is provided &quot;as is&quot; without express or implied warranty.</a>
<a name="ln49"> */</a>
<a name="ln50"> </a>
<a name="ln51">/** @file bits/stl_bvector.h</a>
<a name="ln52"> *  This is an internal header file, included by other library headers.</a>
<a name="ln53"> *  Do not attempt to use it directly. @headername{vector}</a>
<a name="ln54"> */</a>
<a name="ln55"> </a>
<a name="ln56">#ifndef _STL_BVECTOR_H</a>
<a name="ln57">#define _STL_BVECTOR_H 1</a>
<a name="ln58"> </a>
<a name="ln59">#if __cplusplus &gt;= 201103L</a>
<a name="ln60">#include &lt;initializer_list&gt;</a>
<a name="ln61">#include &lt;bits/functional_hash.h&gt;</a>
<a name="ln62">#endif</a>
<a name="ln63"> </a>
<a name="ln64">namespace std _GLIBCXX_VISIBILITY(default)</a>
<a name="ln65">{</a>
<a name="ln66">_GLIBCXX_BEGIN_NAMESPACE_VERSION</a>
<a name="ln67">_GLIBCXX_BEGIN_NAMESPACE_CONTAINER</a>
<a name="ln68"> </a>
<a name="ln69">  typedef unsigned long _Bit_type;</a>
<a name="ln70">  enum { _S_word_bit = int(__CHAR_BIT__ * sizeof(_Bit_type)) };</a>
<a name="ln71"> </a>
<a name="ln72">  struct _Bit_reference</a>
<a name="ln73">  {</a>
<a name="ln74">    _Bit_type * _M_p;</a>
<a name="ln75">    _Bit_type _M_mask;</a>
<a name="ln76"> </a>
<a name="ln77">    _Bit_reference(_Bit_type * __x, _Bit_type __y)</a>
<a name="ln78">    : _M_p(__x), _M_mask(__y) { }</a>
<a name="ln79"> </a>
<a name="ln80">    _Bit_reference() _GLIBCXX_NOEXCEPT : _M_p(0), _M_mask(0) { }</a>
<a name="ln81"> </a>
<a name="ln82">    operator bool() const _GLIBCXX_NOEXCEPT</a>
<a name="ln83">    { return !!(*_M_p &amp; _M_mask); }</a>
<a name="ln84"> </a>
<a name="ln85">    _Bit_reference&amp;</a>
<a name="ln86">    operator=(bool __x) _GLIBCXX_NOEXCEPT</a>
<a name="ln87">    {</a>
<a name="ln88">      if (__x)</a>
<a name="ln89">	*_M_p |= _M_mask;</a>
<a name="ln90">      else</a>
<a name="ln91">	*_M_p &amp;= ~_M_mask;</a>
<a name="ln92">      return *this;</a>
<a name="ln93">    }</a>
<a name="ln94"> </a>
<a name="ln95">    _Bit_reference&amp;</a>
<a name="ln96">    operator=(const _Bit_reference&amp; __x) _GLIBCXX_NOEXCEPT</a>
<a name="ln97">    { return *this = bool(__x); }</a>
<a name="ln98"> </a>
<a name="ln99">    bool</a>
<a name="ln100">    operator==(const _Bit_reference&amp; __x) const</a>
<a name="ln101">    { return bool(*this) == bool(__x); }</a>
<a name="ln102"> </a>
<a name="ln103">    bool</a>
<a name="ln104">    operator&lt;(const _Bit_reference&amp; __x) const</a>
<a name="ln105">    { return !bool(*this) &amp;&amp; bool(__x); }</a>
<a name="ln106"> </a>
<a name="ln107">    void</a>
<a name="ln108">    flip() _GLIBCXX_NOEXCEPT</a>
<a name="ln109">    { *_M_p ^= _M_mask; }</a>
<a name="ln110">  };</a>
<a name="ln111"> </a>
<a name="ln112">#if __cplusplus &gt;= 201103L</a>
<a name="ln113">  inline void</a>
<a name="ln114">  swap(_Bit_reference __x, _Bit_reference __y) noexcept</a>
<a name="ln115">  {</a>
<a name="ln116">    bool __tmp = __x;</a>
<a name="ln117">    __x = __y;</a>
<a name="ln118">    __y = __tmp;</a>
<a name="ln119">  }</a>
<a name="ln120"> </a>
<a name="ln121">  inline void</a>
<a name="ln122">  swap(_Bit_reference __x, bool&amp; __y) noexcept</a>
<a name="ln123">  {</a>
<a name="ln124">    bool __tmp = __x;</a>
<a name="ln125">    __x = __y;</a>
<a name="ln126">    __y = __tmp;</a>
<a name="ln127">  }</a>
<a name="ln128"> </a>
<a name="ln129">  inline void</a>
<a name="ln130">  swap(bool&amp; __x, _Bit_reference __y) noexcept</a>
<a name="ln131">  {</a>
<a name="ln132">    bool __tmp = __x;</a>
<a name="ln133">    __x = __y;</a>
<a name="ln134">    __y = __tmp;</a>
<a name="ln135">  }</a>
<a name="ln136">#endif</a>
<a name="ln137"> </a>
<a name="ln138">  struct _Bit_iterator_base</a>
<a name="ln139">  : public std::iterator&lt;std::random_access_iterator_tag, bool&gt;</a>
<a name="ln140">  {</a>
<a name="ln141">    _Bit_type * _M_p;</a>
<a name="ln142">    unsigned int _M_offset;</a>
<a name="ln143"> </a>
<a name="ln144">    _Bit_iterator_base(_Bit_type * __x, unsigned int __y)</a>
<a name="ln145">    : _M_p(__x), _M_offset(__y) { }</a>
<a name="ln146"> </a>
<a name="ln147">    void</a>
<a name="ln148">    _M_bump_up()</a>
<a name="ln149">    {</a>
<a name="ln150">      if (_M_offset++ == int(_S_word_bit) - 1)</a>
<a name="ln151">	{</a>
<a name="ln152">	  _M_offset = 0;</a>
<a name="ln153">	  ++_M_p;</a>
<a name="ln154">	}</a>
<a name="ln155">    }</a>
<a name="ln156"> </a>
<a name="ln157">    void</a>
<a name="ln158">    _M_bump_down()</a>
<a name="ln159">    {</a>
<a name="ln160">      if (_M_offset-- == 0)</a>
<a name="ln161">	{</a>
<a name="ln162">	  _M_offset = int(_S_word_bit) - 1;</a>
<a name="ln163">	  --_M_p;</a>
<a name="ln164">	}</a>
<a name="ln165">    }</a>
<a name="ln166"> </a>
<a name="ln167">    void</a>
<a name="ln168">    _M_incr(ptrdiff_t __i)</a>
<a name="ln169">    {</a>
<a name="ln170">      difference_type __n = __i + _M_offset;</a>
<a name="ln171">      _M_p += __n / int(_S_word_bit);</a>
<a name="ln172">      __n = __n % int(_S_word_bit);</a>
<a name="ln173">      if (__n &lt; 0)</a>
<a name="ln174">	{</a>
<a name="ln175">	  __n += int(_S_word_bit);</a>
<a name="ln176">	  --_M_p;</a>
<a name="ln177">	}</a>
<a name="ln178">      _M_offset = static_cast&lt;unsigned int&gt;(__n);</a>
<a name="ln179">    }</a>
<a name="ln180"> </a>
<a name="ln181">    bool</a>
<a name="ln182">    operator==(const _Bit_iterator_base&amp; __i) const</a>
<a name="ln183">    { return _M_p == __i._M_p &amp;&amp; _M_offset == __i._M_offset; }</a>
<a name="ln184"> </a>
<a name="ln185">    bool</a>
<a name="ln186">    operator&lt;(const _Bit_iterator_base&amp; __i) const</a>
<a name="ln187">    {</a>
<a name="ln188">      return _M_p &lt; __i._M_p</a>
<a name="ln189">	    || (_M_p == __i._M_p &amp;&amp; _M_offset &lt; __i._M_offset);</a>
<a name="ln190">    }</a>
<a name="ln191"> </a>
<a name="ln192">    bool</a>
<a name="ln193">    operator!=(const _Bit_iterator_base&amp; __i) const</a>
<a name="ln194">    { return !(*this == __i); }</a>
<a name="ln195"> </a>
<a name="ln196">    bool</a>
<a name="ln197">    operator&gt;(const _Bit_iterator_base&amp; __i) const</a>
<a name="ln198">    { return __i &lt; *this; }</a>
<a name="ln199"> </a>
<a name="ln200">    bool</a>
<a name="ln201">    operator&lt;=(const _Bit_iterator_base&amp; __i) const</a>
<a name="ln202">    { return !(__i &lt; *this); }</a>
<a name="ln203"> </a>
<a name="ln204">    bool</a>
<a name="ln205">    operator&gt;=(const _Bit_iterator_base&amp; __i) const</a>
<a name="ln206">    { return !(*this &lt; __i); }</a>
<a name="ln207">  };</a>
<a name="ln208"> </a>
<a name="ln209">  inline ptrdiff_t</a>
<a name="ln210">  operator-(const _Bit_iterator_base&amp; __x, const _Bit_iterator_base&amp; __y)</a>
<a name="ln211">  {</a>
<a name="ln212">    return (int(_S_word_bit) * (__x._M_p - __y._M_p)</a>
<a name="ln213">	    + __x._M_offset - __y._M_offset);</a>
<a name="ln214">  }</a>
<a name="ln215"> </a>
<a name="ln216">  struct _Bit_iterator : public _Bit_iterator_base</a>
<a name="ln217">  {</a>
<a name="ln218">    typedef _Bit_reference  reference;</a>
<a name="ln219">    typedef _Bit_reference* pointer;</a>
<a name="ln220">    typedef _Bit_iterator   iterator;</a>
<a name="ln221"> </a>
<a name="ln222">    _Bit_iterator() : _Bit_iterator_base(0, 0) { }</a>
<a name="ln223"> </a>
<a name="ln224">    _Bit_iterator(_Bit_type * __x, unsigned int __y)</a>
<a name="ln225">    : _Bit_iterator_base(__x, __y) { }</a>
<a name="ln226"> </a>
<a name="ln227">    iterator</a>
<a name="ln228">    _M_const_cast() const</a>
<a name="ln229">    { return *this; }</a>
<a name="ln230"> </a>
<a name="ln231">    reference</a>
<a name="ln232">    operator*() const</a>
<a name="ln233">    { return reference(_M_p, 1UL &lt;&lt; _M_offset); }</a>
<a name="ln234"> </a>
<a name="ln235">    iterator&amp;</a>
<a name="ln236">    operator++()</a>
<a name="ln237">    {</a>
<a name="ln238">      _M_bump_up();</a>
<a name="ln239">      return *this;</a>
<a name="ln240">    }</a>
<a name="ln241"> </a>
<a name="ln242">    iterator</a>
<a name="ln243">    operator++(int)</a>
<a name="ln244">    {</a>
<a name="ln245">      iterator __tmp = *this;</a>
<a name="ln246">      _M_bump_up();</a>
<a name="ln247">      return __tmp;</a>
<a name="ln248">    }</a>
<a name="ln249"> </a>
<a name="ln250">    iterator&amp;</a>
<a name="ln251">    operator--()</a>
<a name="ln252">    {</a>
<a name="ln253">      _M_bump_down();</a>
<a name="ln254">      return *this;</a>
<a name="ln255">    }</a>
<a name="ln256"> </a>
<a name="ln257">    iterator</a>
<a name="ln258">    operator--(int)</a>
<a name="ln259">    {</a>
<a name="ln260">      iterator __tmp = *this;</a>
<a name="ln261">      _M_bump_down();</a>
<a name="ln262">      return __tmp;</a>
<a name="ln263">    }</a>
<a name="ln264"> </a>
<a name="ln265">    iterator&amp;</a>
<a name="ln266">    operator+=(difference_type __i)</a>
<a name="ln267">    {</a>
<a name="ln268">      _M_incr(__i);</a>
<a name="ln269">      return *this;</a>
<a name="ln270">    }</a>
<a name="ln271"> </a>
<a name="ln272">    iterator&amp;</a>
<a name="ln273">    operator-=(difference_type __i)</a>
<a name="ln274">    {</a>
<a name="ln275">      *this += -__i;</a>
<a name="ln276">      return *this;</a>
<a name="ln277">    }</a>
<a name="ln278"> </a>
<a name="ln279">    iterator</a>
<a name="ln280">    operator+(difference_type __i) const</a>
<a name="ln281">    {</a>
<a name="ln282">      iterator __tmp = *this;</a>
<a name="ln283">      return __tmp += __i;</a>
<a name="ln284">    }</a>
<a name="ln285"> </a>
<a name="ln286">    iterator</a>
<a name="ln287">    operator-(difference_type __i) const</a>
<a name="ln288">    {</a>
<a name="ln289">      iterator __tmp = *this;</a>
<a name="ln290">      return __tmp -= __i;</a>
<a name="ln291">    }</a>
<a name="ln292"> </a>
<a name="ln293">    reference</a>
<a name="ln294">    operator[](difference_type __i) const</a>
<a name="ln295">    { return *(*this + __i); }</a>
<a name="ln296">  };</a>
<a name="ln297"> </a>
<a name="ln298">  inline _Bit_iterator</a>
<a name="ln299">  operator+(ptrdiff_t __n, const _Bit_iterator&amp; __x)</a>
<a name="ln300">  { return __x + __n; }</a>
<a name="ln301"> </a>
<a name="ln302">  struct _Bit_const_iterator : public _Bit_iterator_base</a>
<a name="ln303">  {</a>
<a name="ln304">    typedef bool                 reference;</a>
<a name="ln305">    typedef bool                 const_reference;</a>
<a name="ln306">    typedef const bool*          pointer;</a>
<a name="ln307">    typedef _Bit_const_iterator  const_iterator;</a>
<a name="ln308"> </a>
<a name="ln309">    _Bit_const_iterator() : _Bit_iterator_base(0, 0) { }</a>
<a name="ln310"> </a>
<a name="ln311">    _Bit_const_iterator(_Bit_type * __x, unsigned int __y)</a>
<a name="ln312">    : _Bit_iterator_base(__x, __y) { }</a>
<a name="ln313"> </a>
<a name="ln314">    _Bit_const_iterator(const _Bit_iterator&amp; __x)</a>
<a name="ln315">    : _Bit_iterator_base(__x._M_p, __x._M_offset) { }</a>
<a name="ln316"> </a>
<a name="ln317">    _Bit_iterator</a>
<a name="ln318">    _M_const_cast() const</a>
<a name="ln319">    { return _Bit_iterator(_M_p, _M_offset); }</a>
<a name="ln320"> </a>
<a name="ln321">    const_reference</a>
<a name="ln322">    operator*() const</a>
<a name="ln323">    { return _Bit_reference(_M_p, 1UL &lt;&lt; _M_offset); }</a>
<a name="ln324"> </a>
<a name="ln325">    const_iterator&amp;</a>
<a name="ln326">    operator++()</a>
<a name="ln327">    {</a>
<a name="ln328">      _M_bump_up();</a>
<a name="ln329">      return *this;</a>
<a name="ln330">    }</a>
<a name="ln331"> </a>
<a name="ln332">    const_iterator</a>
<a name="ln333">    operator++(int)</a>
<a name="ln334">    {</a>
<a name="ln335">      const_iterator __tmp = *this;</a>
<a name="ln336">      _M_bump_up();</a>
<a name="ln337">      return __tmp;</a>
<a name="ln338">    }</a>
<a name="ln339"> </a>
<a name="ln340">    const_iterator&amp;</a>
<a name="ln341">    operator--()</a>
<a name="ln342">    {</a>
<a name="ln343">      _M_bump_down();</a>
<a name="ln344">      return *this;</a>
<a name="ln345">    }</a>
<a name="ln346"> </a>
<a name="ln347">    const_iterator</a>
<a name="ln348">    operator--(int)</a>
<a name="ln349">    {</a>
<a name="ln350">      const_iterator __tmp = *this;</a>
<a name="ln351">      _M_bump_down();</a>
<a name="ln352">      return __tmp;</a>
<a name="ln353">    }</a>
<a name="ln354"> </a>
<a name="ln355">    const_iterator&amp;</a>
<a name="ln356">    operator+=(difference_type __i)</a>
<a name="ln357">    {</a>
<a name="ln358">      _M_incr(__i);</a>
<a name="ln359">      return *this;</a>
<a name="ln360">    }</a>
<a name="ln361"> </a>
<a name="ln362">    const_iterator&amp;</a>
<a name="ln363">    operator-=(difference_type __i)</a>
<a name="ln364">    {</a>
<a name="ln365">      *this += -__i;</a>
<a name="ln366">      return *this;</a>
<a name="ln367">    }</a>
<a name="ln368"> </a>
<a name="ln369">    const_iterator</a>
<a name="ln370">    operator+(difference_type __i) const</a>
<a name="ln371">    {</a>
<a name="ln372">      const_iterator __tmp = *this;</a>
<a name="ln373">      return __tmp += __i;</a>
<a name="ln374">    }</a>
<a name="ln375"> </a>
<a name="ln376">    const_iterator</a>
<a name="ln377">    operator-(difference_type __i) const</a>
<a name="ln378">    {</a>
<a name="ln379">      const_iterator __tmp = *this;</a>
<a name="ln380">      return __tmp -= __i;</a>
<a name="ln381">    }</a>
<a name="ln382"> </a>
<a name="ln383">    const_reference</a>
<a name="ln384">    operator[](difference_type __i) const</a>
<a name="ln385">    { return *(*this + __i); }</a>
<a name="ln386">  };</a>
<a name="ln387"> </a>
<a name="ln388">  inline _Bit_const_iterator</a>
<a name="ln389">  operator+(ptrdiff_t __n, const _Bit_const_iterator&amp; __x)</a>
<a name="ln390">  { return __x + __n; }</a>
<a name="ln391"> </a>
<a name="ln392">  inline void</a>
<a name="ln393">  __fill_bvector(_Bit_type * __v,</a>
<a name="ln394">		 unsigned int __first, unsigned int __last, bool __x)</a>
<a name="ln395">  {</a>
<a name="ln396">    const _Bit_type __fmask = ~0ul &lt;&lt; __first;</a>
<a name="ln397">    const _Bit_type __lmask = ~0ul &gt;&gt; (_S_word_bit - __last);</a>
<a name="ln398">    const _Bit_type __mask = __fmask &amp; __lmask;</a>
<a name="ln399"> </a>
<a name="ln400">    if (__x)</a>
<a name="ln401">      *__v |= __mask;</a>
<a name="ln402">    else</a>
<a name="ln403">      *__v &amp;= ~__mask;</a>
<a name="ln404">  }</a>
<a name="ln405"> </a>
<a name="ln406">  inline void</a>
<a name="ln407">  fill(_Bit_iterator __first, _Bit_iterator __last, const bool&amp; __x)</a>
<a name="ln408">  {</a>
<a name="ln409">    if (__first._M_p != __last._M_p)</a>
<a name="ln410">      {</a>
<a name="ln411">	_Bit_type* __first_p = __first._M_p;</a>
<a name="ln412">	if (__first._M_offset != 0)</a>
<a name="ln413">	  __fill_bvector(__first_p++, __first._M_offset, _S_word_bit, __x);</a>
<a name="ln414"> </a>
<a name="ln415">	__builtin_memset(__first_p, __x ? ~0 : 0,</a>
<a name="ln416">			 (__last._M_p - __first_p) * sizeof(_Bit_type));</a>
<a name="ln417"> </a>
<a name="ln418">	if (__last._M_offset != 0)</a>
<a name="ln419">	  __fill_bvector(__last._M_p, 0, __last._M_offset, __x);</a>
<a name="ln420">      }</a>
<a name="ln421">    else if (__first._M_offset != __last._M_offset)</a>
<a name="ln422">      __fill_bvector(__first._M_p, __first._M_offset, __last._M_offset, __x);</a>
<a name="ln423">  }</a>
<a name="ln424"> </a>
<a name="ln425">  template&lt;typename _Alloc&gt;</a>
<a name="ln426">    struct _Bvector_base</a>
<a name="ln427">    {</a>
<a name="ln428">      typedef typename __gnu_cxx::__alloc_traits&lt;_Alloc&gt;::template</a>
<a name="ln429">        rebind&lt;_Bit_type&gt;::other _Bit_alloc_type;</a>
<a name="ln430">      typedef typename __gnu_cxx::__alloc_traits&lt;_Bit_alloc_type&gt;</a>
<a name="ln431">	_Bit_alloc_traits;</a>
<a name="ln432">      typedef typename _Bit_alloc_traits::pointer _Bit_pointer;</a>
<a name="ln433"> </a>
<a name="ln434">      struct _Bvector_impl_data</a>
<a name="ln435">      {</a>
<a name="ln436">	_Bit_iterator 	_M_start;</a>
<a name="ln437">	_Bit_iterator 	_M_finish;</a>
<a name="ln438">	_Bit_pointer 	_M_end_of_storage;</a>
<a name="ln439"> </a>
<a name="ln440">	_Bvector_impl_data() _GLIBCXX_NOEXCEPT</a>
<a name="ln441">	: _M_start(), _M_finish(), _M_end_of_storage()</a>
<a name="ln442">	{ }</a>
<a name="ln443"> </a>
<a name="ln444">#if __cplusplus &gt;= 201103L</a>
<a name="ln445">	_Bvector_impl_data(_Bvector_impl_data&amp;&amp; __x) noexcept</a>
<a name="ln446">	: _M_start(__x._M_start), _M_finish(__x._M_finish)</a>
<a name="ln447">	, _M_end_of_storage(__x._M_end_of_storage)</a>
<a name="ln448">	{ __x._M_reset(); }</a>
<a name="ln449"> </a>
<a name="ln450">	void</a>
<a name="ln451">	_M_move_data(_Bvector_impl_data&amp;&amp; __x) noexcept</a>
<a name="ln452">	{</a>
<a name="ln453">	  this-&gt;_M_start = __x._M_start;</a>
<a name="ln454">	  this-&gt;_M_finish = __x._M_finish;</a>
<a name="ln455">	  this-&gt;_M_end_of_storage = __x._M_end_of_storage;</a>
<a name="ln456">	  __x._M_reset();</a>
<a name="ln457">	}</a>
<a name="ln458">#endif</a>
<a name="ln459"> </a>
<a name="ln460">	void</a>
<a name="ln461">	_M_reset() _GLIBCXX_NOEXCEPT</a>
<a name="ln462">	{</a>
<a name="ln463">	  _M_start = _M_finish = _Bit_iterator();</a>
<a name="ln464">	  _M_end_of_storage = _Bit_pointer();</a>
<a name="ln465">	}</a>
<a name="ln466">      };</a>
<a name="ln467"> </a>
<a name="ln468">      struct _Bvector_impl</a>
<a name="ln469">	: public _Bit_alloc_type, public _Bvector_impl_data</a>
<a name="ln470">	{</a>
<a name="ln471">	public:</a>
<a name="ln472">	  _Bvector_impl() _GLIBCXX_NOEXCEPT_IF(</a>
<a name="ln473">		is_nothrow_default_constructible&lt;_Bit_alloc_type&gt;::value)</a>
<a name="ln474">	  : _Bit_alloc_type()</a>
<a name="ln475">	  { }</a>
<a name="ln476"> </a>
<a name="ln477">	  _Bvector_impl(const _Bit_alloc_type&amp; __a) _GLIBCXX_NOEXCEPT</a>
<a name="ln478">	  : _Bit_alloc_type(__a)</a>
<a name="ln479">	  { }</a>
<a name="ln480"> </a>
<a name="ln481">#if __cplusplus &gt;= 201103L</a>
<a name="ln482">	_Bvector_impl(_Bvector_impl&amp;&amp;) = default;</a>
<a name="ln483">#endif</a>
<a name="ln484"> </a>
<a name="ln485">	_Bit_type*</a>
<a name="ln486">	_M_end_addr() const _GLIBCXX_NOEXCEPT</a>
<a name="ln487">	{</a>
<a name="ln488">	  if (this-&gt;_M_end_of_storage)</a>
<a name="ln489">	    return std::__addressof(this-&gt;_M_end_of_storage[-1]) + 1;</a>
<a name="ln490">	  return 0;</a>
<a name="ln491">	}</a>
<a name="ln492">      };</a>
<a name="ln493"> </a>
<a name="ln494">    public:</a>
<a name="ln495">      typedef _Alloc allocator_type;</a>
<a name="ln496"> </a>
<a name="ln497">      _Bit_alloc_type&amp;</a>
<a name="ln498">      _M_get_Bit_allocator() _GLIBCXX_NOEXCEPT</a>
<a name="ln499">      { return this-&gt;_M_impl; }</a>
<a name="ln500"> </a>
<a name="ln501">      const _Bit_alloc_type&amp;</a>
<a name="ln502">      _M_get_Bit_allocator() const _GLIBCXX_NOEXCEPT</a>
<a name="ln503">      { return this-&gt;_M_impl; }</a>
<a name="ln504"> </a>
<a name="ln505">      allocator_type</a>
<a name="ln506">      get_allocator() const _GLIBCXX_NOEXCEPT</a>
<a name="ln507">      { return allocator_type(_M_get_Bit_allocator()); }</a>
<a name="ln508"> </a>
<a name="ln509">#if __cplusplus &gt;= 201103L</a>
<a name="ln510">      _Bvector_base() = default;</a>
<a name="ln511">#else</a>
<a name="ln512">      _Bvector_base() { }</a>
<a name="ln513">#endif</a>
<a name="ln514"> </a>
<a name="ln515">      _Bvector_base(const allocator_type&amp; __a)</a>
<a name="ln516">      : _M_impl(__a) { }</a>
<a name="ln517"> </a>
<a name="ln518">#if __cplusplus &gt;= 201103L</a>
<a name="ln519">      _Bvector_base(_Bvector_base&amp;&amp;) = default;</a>
<a name="ln520">#endif</a>
<a name="ln521"> </a>
<a name="ln522">      ~_Bvector_base()</a>
<a name="ln523">      { this-&gt;_M_deallocate(); }</a>
<a name="ln524"> </a>
<a name="ln525">    protected:</a>
<a name="ln526">      _Bvector_impl _M_impl;</a>
<a name="ln527"> </a>
<a name="ln528">      _Bit_pointer</a>
<a name="ln529">      _M_allocate(size_t __n)</a>
<a name="ln530">      { return _Bit_alloc_traits::allocate(_M_impl, _S_nword(__n)); }</a>
<a name="ln531"> </a>
<a name="ln532">      void</a>
<a name="ln533">      _M_deallocate()</a>
<a name="ln534">      {</a>
<a name="ln535">	if (_M_impl._M_start._M_p)</a>
<a name="ln536">	  {</a>
<a name="ln537">	    const size_t __n = _M_impl._M_end_addr() - _M_impl._M_start._M_p;</a>
<a name="ln538">	    _Bit_alloc_traits::deallocate(_M_impl,</a>
<a name="ln539">					  _M_impl._M_end_of_storage - __n,</a>
<a name="ln540">					  __n);</a>
<a name="ln541">	    _M_impl._M_reset();</a>
<a name="ln542">	  }</a>
<a name="ln543">      }</a>
<a name="ln544"> </a>
<a name="ln545">#if __cplusplus &gt;= 201103L</a>
<a name="ln546">      void</a>
<a name="ln547">      _M_move_data(_Bvector_base&amp;&amp; __x) noexcept</a>
<a name="ln548">      { _M_impl._M_move_data(std::move(__x._M_impl)); }</a>
<a name="ln549">#endif</a>
<a name="ln550"> </a>
<a name="ln551">      static size_t</a>
<a name="ln552">      _S_nword(size_t __n)</a>
<a name="ln553">      { return (__n + int(_S_word_bit) - 1) / int(_S_word_bit); }</a>
<a name="ln554">    };</a>
<a name="ln555"> </a>
<a name="ln556">_GLIBCXX_END_NAMESPACE_CONTAINER</a>
<a name="ln557">_GLIBCXX_END_NAMESPACE_VERSION</a>
<a name="ln558">} // namespace std</a>
<a name="ln559"> </a>
<a name="ln560">// Declare a partial specialization of vector&lt;T, Alloc&gt;.</a>
<a name="ln561">#include &lt;bits/stl_vector.h&gt;</a>
<a name="ln562"> </a>
<a name="ln563">namespace std _GLIBCXX_VISIBILITY(default)</a>
<a name="ln564">{</a>
<a name="ln565">_GLIBCXX_BEGIN_NAMESPACE_VERSION</a>
<a name="ln566">_GLIBCXX_BEGIN_NAMESPACE_CONTAINER</a>
<a name="ln567"> </a>
<a name="ln568">  /**</a>
<a name="ln569">   *  @brief  A specialization of vector for booleans which offers fixed time</a>
<a name="ln570">   *  access to individual elements in any order.</a>
<a name="ln571">   *</a>
<a name="ln572">   *  @ingroup sequences</a>
<a name="ln573">   *</a>
<a name="ln574">   *  @tparam _Alloc  Allocator type.</a>
<a name="ln575">   *</a>
<a name="ln576">   *  Note that vector&lt;bool&gt; does not actually meet the requirements for being</a>
<a name="ln577">   *  a container.  This is because the reference and pointer types are not</a>
<a name="ln578">   *  really references and pointers to bool.  See DR96 for details.  @see</a>
<a name="ln579">   *  vector for function documentation.</a>
<a name="ln580">   *</a>
<a name="ln581">   *  In some terminology a %vector can be described as a dynamic</a>
<a name="ln582">   *  C-style array, it offers fast and efficient access to individual</a>
<a name="ln583">   *  elements in any order and saves the user from worrying about</a>
<a name="ln584">   *  memory and size allocation.  Subscripting ( @c [] ) access is</a>
<a name="ln585">   *  also provided as with C-style arrays.</a>
<a name="ln586">  */</a>
<a name="ln587">  template&lt;typename _Alloc&gt;</a>
<a name="ln588">    class vector&lt;bool, _Alloc&gt; : protected _Bvector_base&lt;_Alloc&gt;</a>
<a name="ln589">    {</a>
<a name="ln590">      typedef _Bvector_base&lt;_Alloc&gt;			_Base;</a>
<a name="ln591">      typedef typename _Base::_Bit_pointer		_Bit_pointer;</a>
<a name="ln592">      typedef typename _Base::_Bit_alloc_traits		_Bit_alloc_traits;</a>
<a name="ln593"> </a>
<a name="ln594">#if __cplusplus &gt;= 201103L</a>
<a name="ln595">      friend struct std::hash&lt;vector&gt;;</a>
<a name="ln596">#endif</a>
<a name="ln597"> </a>
<a name="ln598">    public:</a>
<a name="ln599">      typedef bool					value_type;</a>
<a name="ln600">      typedef size_t					size_type;</a>
<a name="ln601">      typedef ptrdiff_t					difference_type;</a>
<a name="ln602">      typedef _Bit_reference				reference;</a>
<a name="ln603">      typedef bool					const_reference;</a>
<a name="ln604">      typedef _Bit_reference*				pointer;</a>
<a name="ln605">      typedef const bool*				const_pointer;</a>
<a name="ln606">      typedef _Bit_iterator				iterator;</a>
<a name="ln607">      typedef _Bit_const_iterator			const_iterator;</a>
<a name="ln608">      typedef std::reverse_iterator&lt;const_iterator&gt;	const_reverse_iterator;</a>
<a name="ln609">      typedef std::reverse_iterator&lt;iterator&gt;		reverse_iterator;</a>
<a name="ln610">      typedef _Alloc					allocator_type;</a>
<a name="ln611"> </a>
<a name="ln612">      allocator_type</a>
<a name="ln613">      get_allocator() const</a>
<a name="ln614">      { return _Base::get_allocator(); }</a>
<a name="ln615"> </a>
<a name="ln616">    protected:</a>
<a name="ln617">      using _Base::_M_allocate;</a>
<a name="ln618">      using _Base::_M_deallocate;</a>
<a name="ln619">      using _Base::_S_nword;</a>
<a name="ln620">      using _Base::_M_get_Bit_allocator;</a>
<a name="ln621"> </a>
<a name="ln622">    public:</a>
<a name="ln623">#if __cplusplus &gt;= 201103L</a>
<a name="ln624">      vector() = default;</a>
<a name="ln625">#else</a>
<a name="ln626">      vector() { }</a>
<a name="ln627">#endif</a>
<a name="ln628"> </a>
<a name="ln629">      explicit</a>
<a name="ln630">      vector(const allocator_type&amp; __a)</a>
<a name="ln631">      : _Base(__a) { }</a>
<a name="ln632"> </a>
<a name="ln633">#if __cplusplus &gt;= 201103L</a>
<a name="ln634">      explicit</a>
<a name="ln635">      vector(size_type __n, const allocator_type&amp; __a = allocator_type())</a>
<a name="ln636">      : vector(__n, false, __a)</a>
<a name="ln637">      { }</a>
<a name="ln638"> </a>
<a name="ln639">      vector(size_type __n, const bool&amp; __value,</a>
<a name="ln640">	     const allocator_type&amp; __a = allocator_type())</a>
<a name="ln641">#else</a>
<a name="ln642">      explicit</a>
<a name="ln643">      vector(size_type __n, const bool&amp; __value = bool(),</a>
<a name="ln644">	     const allocator_type&amp; __a = allocator_type())</a>
<a name="ln645">#endif</a>
<a name="ln646">      : _Base(__a)</a>
<a name="ln647">      {</a>
<a name="ln648">	_M_initialize(__n);</a>
<a name="ln649">	_M_initialize_value(__value);</a>
<a name="ln650">      }</a>
<a name="ln651"> </a>
<a name="ln652">      vector(const vector&amp; __x)</a>
<a name="ln653">      : _Base(_Bit_alloc_traits::_S_select_on_copy(__x._M_get_Bit_allocator()))</a>
<a name="ln654">      {</a>
<a name="ln655">	_M_initialize(__x.size());</a>
<a name="ln656">	_M_copy_aligned(__x.begin(), __x.end(), this-&gt;_M_impl._M_start);</a>
<a name="ln657">      }</a>
<a name="ln658"> </a>
<a name="ln659">#if __cplusplus &gt;= 201103L</a>
<a name="ln660">      vector(vector&amp;&amp;) = default;</a>
<a name="ln661"> </a>
<a name="ln662">      vector(vector&amp;&amp; __x, const allocator_type&amp; __a)</a>
<a name="ln663">      noexcept(_Bit_alloc_traits::_S_always_equal())</a>
<a name="ln664">      : _Base(__a)</a>
<a name="ln665">      {</a>
<a name="ln666">	if (__x.get_allocator() == __a)</a>
<a name="ln667">	  this-&gt;_M_move_data(std::move(__x));</a>
<a name="ln668">	else</a>
<a name="ln669">	  {</a>
<a name="ln670">	    _M_initialize(__x.size());</a>
<a name="ln671">	    _M_copy_aligned(__x.begin(), __x.end(), begin());</a>
<a name="ln672">	    __x.clear();</a>
<a name="ln673">	  }</a>
<a name="ln674">      }</a>
<a name="ln675"> </a>
<a name="ln676">      vector(const vector&amp; __x, const allocator_type&amp; __a)</a>
<a name="ln677">      : _Base(__a)</a>
<a name="ln678">      {</a>
<a name="ln679">	_M_initialize(__x.size());</a>
<a name="ln680">	_M_copy_aligned(__x.begin(), __x.end(), this-&gt;_M_impl._M_start);</a>
<a name="ln681">      }</a>
<a name="ln682"> </a>
<a name="ln683">      vector(initializer_list&lt;bool&gt; __l,</a>
<a name="ln684">	     const allocator_type&amp; __a = allocator_type())</a>
<a name="ln685">      : _Base(__a)</a>
<a name="ln686">      {</a>
<a name="ln687">	_M_initialize_range(__l.begin(), __l.end(),</a>
<a name="ln688">			    random_access_iterator_tag());</a>
<a name="ln689">      }</a>
<a name="ln690">#endif</a>
<a name="ln691"> </a>
<a name="ln692">#if __cplusplus &gt;= 201103L</a>
<a name="ln693">      template&lt;typename _InputIterator,</a>
<a name="ln694">	       typename = std::_RequireInputIter&lt;_InputIterator&gt;&gt;</a>
<a name="ln695">	vector(_InputIterator __first, _InputIterator __last,</a>
<a name="ln696">	       const allocator_type&amp; __a = allocator_type())</a>
<a name="ln697">	: _Base(__a)</a>
<a name="ln698">	{ _M_initialize_dispatch(__first, __last, __false_type()); }</a>
<a name="ln699">#else</a>
<a name="ln700">      template&lt;typename _InputIterator&gt;</a>
<a name="ln701">	vector(_InputIterator __first, _InputIterator __last,</a>
<a name="ln702">	       const allocator_type&amp; __a = allocator_type())</a>
<a name="ln703">	: _Base(__a)</a>
<a name="ln704">	{</a>
<a name="ln705">	  typedef typename std::__is_integer&lt;_InputIterator&gt;::__type _Integral;</a>
<a name="ln706">	  _M_initialize_dispatch(__first, __last, _Integral());</a>
<a name="ln707">	}</a>
<a name="ln708">#endif</a>
<a name="ln709"> </a>
<a name="ln710">      ~vector() _GLIBCXX_NOEXCEPT { }</a>
<a name="ln711"> </a>
<a name="ln712">      vector&amp;</a>
<a name="ln713">      operator=(const vector&amp; __x)</a>
<a name="ln714">      {</a>
<a name="ln715">	if (&amp;__x == this)</a>
<a name="ln716">	  return *this;</a>
<a name="ln717">#if __cplusplus &gt;= 201103L</a>
<a name="ln718">	if (_Bit_alloc_traits::_S_propagate_on_copy_assign())</a>
<a name="ln719">	  {</a>
<a name="ln720">	    if (this-&gt;_M_get_Bit_allocator() != __x._M_get_Bit_allocator())</a>
<a name="ln721">	      {</a>
<a name="ln722">		this-&gt;_M_deallocate();</a>
<a name="ln723">		std::__alloc_on_copy(_M_get_Bit_allocator(),</a>
<a name="ln724">				     __x._M_get_Bit_allocator());</a>
<a name="ln725">		_M_initialize(__x.size());</a>
<a name="ln726">	      }</a>
<a name="ln727">	    else</a>
<a name="ln728">	      std::__alloc_on_copy(_M_get_Bit_allocator(),</a>
<a name="ln729">				   __x._M_get_Bit_allocator());</a>
<a name="ln730">	  }</a>
<a name="ln731">#endif</a>
<a name="ln732">	if (__x.size() &gt; capacity())</a>
<a name="ln733">	  {</a>
<a name="ln734">	    this-&gt;_M_deallocate();</a>
<a name="ln735">	    _M_initialize(__x.size());</a>
<a name="ln736">	  }</a>
<a name="ln737">	this-&gt;_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),</a>
<a name="ln738">						  begin());</a>
<a name="ln739">	return *this;</a>
<a name="ln740">      }</a>
<a name="ln741"> </a>
<a name="ln742">#if __cplusplus &gt;= 201103L</a>
<a name="ln743">      vector&amp;</a>
<a name="ln744">      operator=(vector&amp;&amp; __x) noexcept(_Bit_alloc_traits::_S_nothrow_move())</a>
<a name="ln745">      {</a>
<a name="ln746">	if (_Bit_alloc_traits::_S_propagate_on_move_assign()</a>
<a name="ln747">	    || this-&gt;_M_get_Bit_allocator() == __x._M_get_Bit_allocator())</a>
<a name="ln748">	  {</a>
<a name="ln749">	    this-&gt;_M_deallocate();</a>
<a name="ln750">	    this-&gt;_M_move_data(std::move(__x));</a>
<a name="ln751">	    std::__alloc_on_move(_M_get_Bit_allocator(),</a>
<a name="ln752">				 __x._M_get_Bit_allocator());</a>
<a name="ln753">	  }</a>
<a name="ln754">	else</a>
<a name="ln755">	  {</a>
<a name="ln756">	    if (__x.size() &gt; capacity())</a>
<a name="ln757">	      {</a>
<a name="ln758">		this-&gt;_M_deallocate();</a>
<a name="ln759">		_M_initialize(__x.size());</a>
<a name="ln760">	      }</a>
<a name="ln761">	    this-&gt;_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),</a>
<a name="ln762">						      begin());</a>
<a name="ln763">	    __x.clear();</a>
<a name="ln764">	  }</a>
<a name="ln765">	return *this;</a>
<a name="ln766">      }</a>
<a name="ln767"> </a>
<a name="ln768">      vector&amp;</a>
<a name="ln769">      operator=(initializer_list&lt;bool&gt; __l)</a>
<a name="ln770">      {</a>
<a name="ln771">	this-&gt;assign (__l.begin(), __l.end());</a>
<a name="ln772">	return *this;</a>
<a name="ln773">      }</a>
<a name="ln774">#endif</a>
<a name="ln775"> </a>
<a name="ln776">      // assign(), a generalized assignment member function.  Two</a>
<a name="ln777">      // versions: one that takes a count, and one that takes a range.</a>
<a name="ln778">      // The range version is a member template, so we dispatch on whether</a>
<a name="ln779">      // or not the type is an integer.</a>
<a name="ln780">      void</a>
<a name="ln781">      assign(size_type __n, const bool&amp; __x)</a>
<a name="ln782">      { _M_fill_assign(__n, __x); }</a>
<a name="ln783"> </a>
<a name="ln784">#if __cplusplus &gt;= 201103L</a>
<a name="ln785">      template&lt;typename _InputIterator,</a>
<a name="ln786">	       typename = std::_RequireInputIter&lt;_InputIterator&gt;&gt;</a>
<a name="ln787">	void</a>
<a name="ln788">	assign(_InputIterator __first, _InputIterator __last)</a>
<a name="ln789">	{ _M_assign_aux(__first, __last, std::__iterator_category(__first)); }</a>
<a name="ln790">#else</a>
<a name="ln791">      template&lt;typename _InputIterator&gt;</a>
<a name="ln792">	void</a>
<a name="ln793">	assign(_InputIterator __first, _InputIterator __last)</a>
<a name="ln794">	{</a>
<a name="ln795">	  typedef typename std::__is_integer&lt;_InputIterator&gt;::__type _Integral;</a>
<a name="ln796">	  _M_assign_dispatch(__first, __last, _Integral());</a>
<a name="ln797">	}</a>
<a name="ln798">#endif</a>
<a name="ln799"> </a>
<a name="ln800">#if __cplusplus &gt;= 201103L</a>
<a name="ln801">      void</a>
<a name="ln802">      assign(initializer_list&lt;bool&gt; __l)</a>
<a name="ln803">      { _M_assign_aux(__l.begin(), __l.end(), random_access_iterator_tag()); }</a>
<a name="ln804">#endif</a>
<a name="ln805"> </a>
<a name="ln806">      iterator</a>
<a name="ln807">      begin() _GLIBCXX_NOEXCEPT</a>
<a name="ln808">      { return this-&gt;_M_impl._M_start; }</a>
<a name="ln809"> </a>
<a name="ln810">      const_iterator</a>
<a name="ln811">      begin() const _GLIBCXX_NOEXCEPT</a>
<a name="ln812">      { return this-&gt;_M_impl._M_start; }</a>
<a name="ln813"> </a>
<a name="ln814">      iterator</a>
<a name="ln815">      end() _GLIBCXX_NOEXCEPT</a>
<a name="ln816">      { return this-&gt;_M_impl._M_finish; }</a>
<a name="ln817"> </a>
<a name="ln818">      const_iterator</a>
<a name="ln819">      end() const _GLIBCXX_NOEXCEPT</a>
<a name="ln820">      { return this-&gt;_M_impl._M_finish; }</a>
<a name="ln821"> </a>
<a name="ln822">      reverse_iterator</a>
<a name="ln823">      rbegin() _GLIBCXX_NOEXCEPT</a>
<a name="ln824">      { return reverse_iterator(end()); }</a>
<a name="ln825"> </a>
<a name="ln826">      const_reverse_iterator</a>
<a name="ln827">      rbegin() const _GLIBCXX_NOEXCEPT</a>
<a name="ln828">      { return const_reverse_iterator(end()); }</a>
<a name="ln829"> </a>
<a name="ln830">      reverse_iterator</a>
<a name="ln831">      rend() _GLIBCXX_NOEXCEPT</a>
<a name="ln832">      { return reverse_iterator(begin()); }</a>
<a name="ln833"> </a>
<a name="ln834">      const_reverse_iterator</a>
<a name="ln835">      rend() const _GLIBCXX_NOEXCEPT</a>
<a name="ln836">      { return const_reverse_iterator(begin()); }</a>
<a name="ln837"> </a>
<a name="ln838">#if __cplusplus &gt;= 201103L</a>
<a name="ln839">      const_iterator</a>
<a name="ln840">      cbegin() const noexcept</a>
<a name="ln841">      { return this-&gt;_M_impl._M_start; }</a>
<a name="ln842"> </a>
<a name="ln843">      const_iterator</a>
<a name="ln844">      cend() const noexcept</a>
<a name="ln845">      { return this-&gt;_M_impl._M_finish; }</a>
<a name="ln846"> </a>
<a name="ln847">      const_reverse_iterator</a>
<a name="ln848">      crbegin() const noexcept</a>
<a name="ln849">      { return const_reverse_iterator(end()); }</a>
<a name="ln850"> </a>
<a name="ln851">      const_reverse_iterator</a>
<a name="ln852">      crend() const noexcept</a>
<a name="ln853">      { return const_reverse_iterator(begin()); }</a>
<a name="ln854">#endif</a>
<a name="ln855"> </a>
<a name="ln856">      size_type</a>
<a name="ln857">      size() const _GLIBCXX_NOEXCEPT</a>
<a name="ln858">      { return size_type(end() - begin()); }</a>
<a name="ln859"> </a>
<a name="ln860">      size_type</a>
<a name="ln861">      max_size() const _GLIBCXX_NOEXCEPT</a>
<a name="ln862">      {</a>
<a name="ln863">	const size_type __isize =</a>
<a name="ln864">	  __gnu_cxx::__numeric_traits&lt;difference_type&gt;::__max</a>
<a name="ln865">	  - int(_S_word_bit) + 1;</a>
<a name="ln866">	const size_type __asize</a>
<a name="ln867">	  = _Bit_alloc_traits::max_size(_M_get_Bit_allocator());</a>
<a name="ln868">	return (__asize &lt;= __isize / int(_S_word_bit)</a>
<a name="ln869">		? __asize * int(_S_word_bit) : __isize);</a>
<a name="ln870">      }</a>
<a name="ln871"> </a>
<a name="ln872">      size_type</a>
<a name="ln873">      capacity() const _GLIBCXX_NOEXCEPT</a>
<a name="ln874">      { return size_type(const_iterator(this-&gt;_M_impl._M_end_addr(), 0)</a>
<a name="ln875">			 - begin()); }</a>
<a name="ln876"> </a>
<a name="ln877">      bool</a>
<a name="ln878">      empty() const _GLIBCXX_NOEXCEPT</a>
<a name="ln879">      { return begin() == end(); }</a>
<a name="ln880"> </a>
<a name="ln881">      reference</a>
<a name="ln882">      operator[](size_type __n)</a>
<a name="ln883">      {</a>
<a name="ln884">	return *iterator(this-&gt;_M_impl._M_start._M_p</a>
<a name="ln885">			 + __n / int(_S_word_bit), __n % int(_S_word_bit));</a>
<a name="ln886">      }</a>
<a name="ln887"> </a>
<a name="ln888">      const_reference</a>
<a name="ln889">      operator[](size_type __n) const</a>
<a name="ln890">      {</a>
<a name="ln891">	return *const_iterator(this-&gt;_M_impl._M_start._M_p</a>
<a name="ln892">			     + __n / int(_S_word_bit), __n % int(_S_word_bit));</a>
<a name="ln893">      }</a>
<a name="ln894"> </a>
<a name="ln895">    protected:</a>
<a name="ln896">      void</a>
<a name="ln897">      _M_range_check(size_type __n) const</a>
<a name="ln898">      {</a>
<a name="ln899">	if (__n &gt;= this-&gt;size())</a>
<a name="ln900">	  __throw_out_of_range_fmt(__N(&quot;vector&lt;bool&gt;::_M_range_check: __n &quot;</a>
<a name="ln901">				       &quot;(which is %zu) &gt;= this-&gt;size() &quot;</a>
<a name="ln902">				       &quot;(which is %zu)&quot;),</a>
<a name="ln903">				   __n, this-&gt;size());</a>
<a name="ln904">      }</a>
<a name="ln905"> </a>
<a name="ln906">    public:</a>
<a name="ln907">      reference</a>
<a name="ln908">      at(size_type __n)</a>
<a name="ln909">      { _M_range_check(__n); return (*this)[__n]; }</a>
<a name="ln910"> </a>
<a name="ln911">      const_reference</a>
<a name="ln912">      at(size_type __n) const</a>
<a name="ln913">      { _M_range_check(__n); return (*this)[__n]; }</a>
<a name="ln914"> </a>
<a name="ln915">      void</a>
<a name="ln916">      reserve(size_type __n)</a>
<a name="ln917">      {</a>
<a name="ln918">	if (__n &gt; max_size())</a>
<a name="ln919">	  __throw_length_error(__N(&quot;vector::reserve&quot;));</a>
<a name="ln920">	if (capacity() &lt; __n)</a>
<a name="ln921">	  _M_reallocate(__n);</a>
<a name="ln922">      }</a>
<a name="ln923"> </a>
<a name="ln924">      reference</a>
<a name="ln925">      front()</a>
<a name="ln926">      { return *begin(); }</a>
<a name="ln927"> </a>
<a name="ln928">      const_reference</a>
<a name="ln929">      front() const</a>
<a name="ln930">      { return *begin(); }</a>
<a name="ln931"> </a>
<a name="ln932">      reference</a>
<a name="ln933">      back()</a>
<a name="ln934">      { return *(end() - 1); }</a>
<a name="ln935"> </a>
<a name="ln936">      const_reference</a>
<a name="ln937">      back() const</a>
<a name="ln938">      { return *(end() - 1); }</a>
<a name="ln939"> </a>
<a name="ln940">      // _GLIBCXX_RESOLVE_LIB_DEFECTS</a>
<a name="ln941">      // DR 464. Suggestion for new member functions in standard containers.</a>
<a name="ln942">      // N.B. DR 464 says nothing about vector&lt;bool&gt; but we need something</a>
<a name="ln943">      // here due to the way we are implementing DR 464 in the debug-mode</a>
<a name="ln944">      // vector class.</a>
<a name="ln945">      void</a>
<a name="ln946">      data() _GLIBCXX_NOEXCEPT { }</a>
<a name="ln947"> </a>
<a name="ln948">      void</a>
<a name="ln949">      push_back(bool __x)</a>
<a name="ln950">      {</a>
<a name="ln951">	if (this-&gt;_M_impl._M_finish._M_p != this-&gt;_M_impl._M_end_addr())</a>
<a name="ln952">	  *this-&gt;_M_impl._M_finish++ = __x;</a>
<a name="ln953">	else</a>
<a name="ln954">	  _M_insert_aux(end(), __x);</a>
<a name="ln955">      }</a>
<a name="ln956"> </a>
<a name="ln957">      void</a>
<a name="ln958">      swap(vector&amp; __x) _GLIBCXX_NOEXCEPT</a>
<a name="ln959">      {</a>
<a name="ln960">	std::swap(this-&gt;_M_impl._M_start, __x._M_impl._M_start);</a>
<a name="ln961">	std::swap(this-&gt;_M_impl._M_finish, __x._M_impl._M_finish);</a>
<a name="ln962">	std::swap(this-&gt;_M_impl._M_end_of_storage,</a>
<a name="ln963">		  __x._M_impl._M_end_of_storage);</a>
<a name="ln964">	_Bit_alloc_traits::_S_on_swap(_M_get_Bit_allocator(),</a>
<a name="ln965">				      __x._M_get_Bit_allocator());</a>
<a name="ln966">      }</a>
<a name="ln967"> </a>
<a name="ln968">      // [23.2.5]/1, third-to-last entry in synopsis listing</a>
<a name="ln969">      static void</a>
<a name="ln970">      swap(reference __x, reference __y) _GLIBCXX_NOEXCEPT</a>
<a name="ln971">      {</a>
<a name="ln972">	bool __tmp = __x;</a>
<a name="ln973">	__x = __y;</a>
<a name="ln974">	__y = __tmp;</a>
<a name="ln975">      }</a>
<a name="ln976"> </a>
<a name="ln977">      iterator</a>
<a name="ln978">#if __cplusplus &gt;= 201103L</a>
<a name="ln979">      insert(const_iterator __position, const bool&amp; __x = bool())</a>
<a name="ln980">#else</a>
<a name="ln981">      insert(iterator __position, const bool&amp; __x = bool())</a>
<a name="ln982">#endif</a>
<a name="ln983">      {</a>
<a name="ln984">	const difference_type __n = __position - begin();</a>
<a name="ln985">	if (this-&gt;_M_impl._M_finish._M_p != this-&gt;_M_impl._M_end_addr()</a>
<a name="ln986">	    &amp;&amp; __position == end())</a>
<a name="ln987">	  *this-&gt;_M_impl._M_finish++ = __x;</a>
<a name="ln988">	else</a>
<a name="ln989">	  _M_insert_aux(__position._M_const_cast(), __x);</a>
<a name="ln990">	return begin() + __n;</a>
<a name="ln991">      }</a>
<a name="ln992"> </a>
<a name="ln993">#if __cplusplus &gt;= 201103L</a>
<a name="ln994">      template&lt;typename _InputIterator,</a>
<a name="ln995">	       typename = std::_RequireInputIter&lt;_InputIterator&gt;&gt;</a>
<a name="ln996">	iterator</a>
<a name="ln997">	insert(const_iterator __position,</a>
<a name="ln998">	       _InputIterator __first, _InputIterator __last)</a>
<a name="ln999">	{</a>
<a name="ln1000">	  difference_type __offset = __position - cbegin();</a>
<a name="ln1001">	  _M_insert_dispatch(__position._M_const_cast(),</a>
<a name="ln1002">			     __first, __last, __false_type());</a>
<a name="ln1003">	  return begin() + __offset;</a>
<a name="ln1004">	}</a>
<a name="ln1005">#else</a>
<a name="ln1006">      template&lt;typename _InputIterator&gt;</a>
<a name="ln1007">	void</a>
<a name="ln1008">	insert(iterator __position,</a>
<a name="ln1009">	       _InputIterator __first, _InputIterator __last)</a>
<a name="ln1010">	{</a>
<a name="ln1011">	  typedef typename std::__is_integer&lt;_InputIterator&gt;::__type _Integral;</a>
<a name="ln1012">	  _M_insert_dispatch(__position, __first, __last, _Integral());</a>
<a name="ln1013">	}</a>
<a name="ln1014">#endif</a>
<a name="ln1015"> </a>
<a name="ln1016">#if __cplusplus &gt;= 201103L</a>
<a name="ln1017">      iterator</a>
<a name="ln1018">      insert(const_iterator __position, size_type __n, const bool&amp; __x)</a>
<a name="ln1019">      {</a>
<a name="ln1020">	difference_type __offset = __position - cbegin();</a>
<a name="ln1021">	_M_fill_insert(__position._M_const_cast(), __n, __x);</a>
<a name="ln1022">	return begin() + __offset;</a>
<a name="ln1023">      }</a>
<a name="ln1024">#else</a>
<a name="ln1025">      void</a>
<a name="ln1026">      insert(iterator __position, size_type __n, const bool&amp; __x)</a>
<a name="ln1027">      { _M_fill_insert(__position, __n, __x); }</a>
<a name="ln1028">#endif</a>
<a name="ln1029"> </a>
<a name="ln1030">#if __cplusplus &gt;= 201103L</a>
<a name="ln1031">      iterator</a>
<a name="ln1032">      insert(const_iterator __p, initializer_list&lt;bool&gt; __l)</a>
<a name="ln1033">      { return this-&gt;insert(__p, __l.begin(), __l.end()); }</a>
<a name="ln1034">#endif</a>
<a name="ln1035"> </a>
<a name="ln1036">      void</a>
<a name="ln1037">      pop_back()</a>
<a name="ln1038">      { --this-&gt;_M_impl._M_finish; }</a>
<a name="ln1039"> </a>
<a name="ln1040">      iterator</a>
<a name="ln1041">#if __cplusplus &gt;= 201103L</a>
<a name="ln1042">      erase(const_iterator __position)</a>
<a name="ln1043">#else</a>
<a name="ln1044">      erase(iterator __position)</a>
<a name="ln1045">#endif</a>
<a name="ln1046">      { return _M_erase(__position._M_const_cast()); }</a>
<a name="ln1047"> </a>
<a name="ln1048">      iterator</a>
<a name="ln1049">#if __cplusplus &gt;= 201103L</a>
<a name="ln1050">      erase(const_iterator __first, const_iterator __last)</a>
<a name="ln1051">#else</a>
<a name="ln1052">      erase(iterator __first, iterator __last)</a>
<a name="ln1053">#endif</a>
<a name="ln1054">      { return _M_erase(__first._M_const_cast(), __last._M_const_cast()); }</a>
<a name="ln1055"> </a>
<a name="ln1056">      void</a>
<a name="ln1057">      resize(size_type __new_size, bool __x = bool())</a>
<a name="ln1058">      {</a>
<a name="ln1059">	if (__new_size &lt; size())</a>
<a name="ln1060">	  _M_erase_at_end(begin() + difference_type(__new_size));</a>
<a name="ln1061">	else</a>
<a name="ln1062">	  insert(end(), __new_size - size(), __x);</a>
<a name="ln1063">      }</a>
<a name="ln1064"> </a>
<a name="ln1065">#if __cplusplus &gt;= 201103L</a>
<a name="ln1066">      void</a>
<a name="ln1067">      shrink_to_fit()</a>
<a name="ln1068">      { _M_shrink_to_fit(); }</a>
<a name="ln1069">#endif</a>
<a name="ln1070"> </a>
<a name="ln1071">      void</a>
<a name="ln1072">      flip() _GLIBCXX_NOEXCEPT</a>
<a name="ln1073">      {</a>
<a name="ln1074">	_Bit_type * const __end = this-&gt;_M_impl._M_end_addr();</a>
<a name="ln1075">	for (_Bit_type * __p = this-&gt;_M_impl._M_start._M_p; __p != __end; ++__p)</a>
<a name="ln1076">	  *__p = ~*__p;</a>
<a name="ln1077">      }</a>
<a name="ln1078"> </a>
<a name="ln1079">      void</a>
<a name="ln1080">      clear() _GLIBCXX_NOEXCEPT</a>
<a name="ln1081">      { _M_erase_at_end(begin()); }</a>
<a name="ln1082"> </a>
<a name="ln1083">#if __cplusplus &gt;= 201103L</a>
<a name="ln1084">      template&lt;typename... _Args&gt;</a>
<a name="ln1085">#if __cplusplus &gt; 201402L</a>
<a name="ln1086">	reference</a>
<a name="ln1087">#else</a>
<a name="ln1088">	void</a>
<a name="ln1089">#endif</a>
<a name="ln1090">	emplace_back(_Args&amp;&amp;... __args)</a>
<a name="ln1091">	{</a>
<a name="ln1092">	  push_back(bool(__args...));</a>
<a name="ln1093">#if __cplusplus &gt; 201402L</a>
<a name="ln1094">	  return back();</a>
<a name="ln1095">#endif</a>
<a name="ln1096">	}</a>
<a name="ln1097"> </a>
<a name="ln1098">      template&lt;typename... _Args&gt;</a>
<a name="ln1099">	iterator</a>
<a name="ln1100">	emplace(const_iterator __pos, _Args&amp;&amp;... __args)</a>
<a name="ln1101">	{ return insert(__pos, bool(__args...)); }</a>
<a name="ln1102">#endif</a>
<a name="ln1103"> </a>
<a name="ln1104">    protected:</a>
<a name="ln1105">      // Precondition: __first._M_offset == 0 &amp;&amp; __result._M_offset == 0.</a>
<a name="ln1106">      iterator</a>
<a name="ln1107">      _M_copy_aligned(const_iterator __first, const_iterator __last,</a>
<a name="ln1108">		      iterator __result)</a>
<a name="ln1109">      {</a>
<a name="ln1110">	_Bit_type* __q = std::copy(__first._M_p, __last._M_p, __result._M_p);</a>
<a name="ln1111">	return std::copy(const_iterator(__last._M_p, 0), __last,</a>
<a name="ln1112">			 iterator(__q, 0));</a>
<a name="ln1113">      }</a>
<a name="ln1114"> </a>
<a name="ln1115">      void</a>
<a name="ln1116">      _M_initialize(size_type __n)</a>
<a name="ln1117">      {</a>
<a name="ln1118">	if (__n)</a>
<a name="ln1119">	  {</a>
<a name="ln1120">	    _Bit_pointer __q = this-&gt;_M_allocate(__n);</a>
<a name="ln1121">	    this-&gt;_M_impl._M_end_of_storage = __q + _S_nword(__n);</a>
<a name="ln1122">	    this-&gt;_M_impl._M_start = iterator(std::__addressof(*__q), 0);</a>
<a name="ln1123">	  }</a>
<a name="ln1124">	else</a>
<a name="ln1125">	  {</a>
<a name="ln1126">	    this-&gt;_M_impl._M_end_of_storage = _Bit_pointer();</a>
<a name="ln1127">	    this-&gt;_M_impl._M_start = iterator(0, 0);</a>
<a name="ln1128">	  }</a>
<a name="ln1129">	this-&gt;_M_impl._M_finish = this-&gt;_M_impl._M_start + difference_type(__n);</a>
<a name="ln1130"> </a>
<a name="ln1131">      }</a>
<a name="ln1132"> </a>
<a name="ln1133">      void</a>
<a name="ln1134">      _M_initialize_value(bool __x)</a>
<a name="ln1135">      {</a>
<a name="ln1136">	if (_Bit_type* __p = this-&gt;_M_impl._M_start._M_p)</a>
<a name="ln1137">	  __builtin_memset(__p, __x ? ~0 : 0,</a>
<a name="ln1138">			   (this-&gt;_M_impl._M_end_addr() - __p)</a>
<a name="ln1139">			   * sizeof(_Bit_type));</a>
<a name="ln1140">      }</a>
<a name="ln1141"> </a>
<a name="ln1142">      void</a>
<a name="ln1143">      _M_reallocate(size_type __n);</a>
<a name="ln1144"> </a>
<a name="ln1145">#if __cplusplus &gt;= 201103L</a>
<a name="ln1146">      bool</a>
<a name="ln1147">      _M_shrink_to_fit();</a>
<a name="ln1148">#endif</a>
<a name="ln1149"> </a>
<a name="ln1150">      // Check whether it's an integral type.  If so, it's not an iterator.</a>
<a name="ln1151"> </a>
<a name="ln1152">      // _GLIBCXX_RESOLVE_LIB_DEFECTS</a>
<a name="ln1153">      // 438. Ambiguity in the &quot;do the right thing&quot; clause</a>
<a name="ln1154">      template&lt;typename _Integer&gt;</a>
<a name="ln1155">	void</a>
<a name="ln1156">	_M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)</a>
<a name="ln1157">	{</a>
<a name="ln1158">	  _M_initialize(static_cast&lt;size_type&gt;(__n));</a>
<a name="ln1159">	  _M_initialize_value(__x);</a>
<a name="ln1160">	}</a>
<a name="ln1161"> </a>
<a name="ln1162">      template&lt;typename _InputIterator&gt;</a>
<a name="ln1163">	void</a>
<a name="ln1164">	_M_initialize_dispatch(_InputIterator __first, _InputIterator __last,</a>
<a name="ln1165">			       __false_type)</a>
<a name="ln1166">	{ _M_initialize_range(__first, __last,</a>
<a name="ln1167">			      std::__iterator_category(__first)); }</a>
<a name="ln1168"> </a>
<a name="ln1169">      template&lt;typename _InputIterator&gt;</a>
<a name="ln1170">	void</a>
<a name="ln1171">	_M_initialize_range(_InputIterator __first, _InputIterator __last,</a>
<a name="ln1172">			    std::input_iterator_tag)</a>
<a name="ln1173">	{</a>
<a name="ln1174">	  for (; __first != __last; ++__first)</a>
<a name="ln1175">	    push_back(*__first);</a>
<a name="ln1176">	}</a>
<a name="ln1177"> </a>
<a name="ln1178">      template&lt;typename _ForwardIterator&gt;</a>
<a name="ln1179">	void</a>
<a name="ln1180">	_M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,</a>
<a name="ln1181">			    std::forward_iterator_tag)</a>
<a name="ln1182">	{</a>
<a name="ln1183">	  const size_type __n = std::distance(__first, __last);</a>
<a name="ln1184">	  _M_initialize(__n);</a>
<a name="ln1185">	  std::copy(__first, __last, this-&gt;_M_impl._M_start);</a>
<a name="ln1186">	}</a>
<a name="ln1187"> </a>
<a name="ln1188">#if __cplusplus &lt; 201103L</a>
<a name="ln1189">      // _GLIBCXX_RESOLVE_LIB_DEFECTS</a>
<a name="ln1190">      // 438. Ambiguity in the &quot;do the right thing&quot; clause</a>
<a name="ln1191">      template&lt;typename _Integer&gt;</a>
<a name="ln1192">	void</a>
<a name="ln1193">	_M_assign_dispatch(_Integer __n, _Integer __val, __true_type)</a>
<a name="ln1194">	{ _M_fill_assign(__n, __val); }</a>
<a name="ln1195"> </a>
<a name="ln1196">      template&lt;class _InputIterator&gt;</a>
<a name="ln1197">	void</a>
<a name="ln1198">	_M_assign_dispatch(_InputIterator __first, _InputIterator __last,</a>
<a name="ln1199">			   __false_type)</a>
<a name="ln1200">	{ _M_assign_aux(__first, __last, std::__iterator_category(__first)); }</a>
<a name="ln1201">#endif</a>
<a name="ln1202"> </a>
<a name="ln1203">      void</a>
<a name="ln1204">      _M_fill_assign(size_t __n, bool __x)</a>
<a name="ln1205">      {</a>
<a name="ln1206">	if (__n &gt; size())</a>
<a name="ln1207">	  {</a>
<a name="ln1208">	    _M_initialize_value(__x);</a>
<a name="ln1209">	    insert(end(), __n - size(), __x);</a>
<a name="ln1210">	  }</a>
<a name="ln1211">	else</a>
<a name="ln1212">	  {</a>
<a name="ln1213">	    _M_erase_at_end(begin() + __n);</a>
<a name="ln1214">	    _M_initialize_value(__x);</a>
<a name="ln1215">	  }</a>
<a name="ln1216">      }</a>
<a name="ln1217"> </a>
<a name="ln1218">      template&lt;typename _InputIterator&gt;</a>
<a name="ln1219">	void</a>
<a name="ln1220">	_M_assign_aux(_InputIterator __first, _InputIterator __last,</a>
<a name="ln1221">		      std::input_iterator_tag)</a>
<a name="ln1222">	{</a>
<a name="ln1223">	  iterator __cur = begin();</a>
<a name="ln1224">	  for (; __first != __last &amp;&amp; __cur != end(); ++__cur, ++__first)</a>
<a name="ln1225">	    *__cur = *__first;</a>
<a name="ln1226">	  if (__first == __last)</a>
<a name="ln1227">	    _M_erase_at_end(__cur);</a>
<a name="ln1228">	  else</a>
<a name="ln1229">	    insert(end(), __first, __last);</a>
<a name="ln1230">	}</a>
<a name="ln1231"> </a>
<a name="ln1232">      template&lt;typename _ForwardIterator&gt;</a>
<a name="ln1233">	void</a>
<a name="ln1234">	_M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,</a>
<a name="ln1235">		      std::forward_iterator_tag)</a>
<a name="ln1236">	{</a>
<a name="ln1237">	  const size_type __len = std::distance(__first, __last);</a>
<a name="ln1238">	  if (__len &lt; size())</a>
<a name="ln1239">	    _M_erase_at_end(std::copy(__first, __last, begin()));</a>
<a name="ln1240">	  else</a>
<a name="ln1241">	    {</a>
<a name="ln1242">	      _ForwardIterator __mid = __first;</a>
<a name="ln1243">	      std::advance(__mid, size());</a>
<a name="ln1244">	      std::copy(__first, __mid, begin());</a>
<a name="ln1245">	      insert(end(), __mid, __last);</a>
<a name="ln1246">	    }</a>
<a name="ln1247">	}</a>
<a name="ln1248"> </a>
<a name="ln1249">      // Check whether it's an integral type.  If so, it's not an iterator.</a>
<a name="ln1250"> </a>
<a name="ln1251">      // _GLIBCXX_RESOLVE_LIB_DEFECTS</a>
<a name="ln1252">      // 438. Ambiguity in the &quot;do the right thing&quot; clause</a>
<a name="ln1253">      template&lt;typename _Integer&gt;</a>
<a name="ln1254">	void</a>
<a name="ln1255">	_M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,</a>
<a name="ln1256">			   __true_type)</a>
<a name="ln1257">	{ _M_fill_insert(__pos, __n, __x); }</a>
<a name="ln1258"> </a>
<a name="ln1259">      template&lt;typename _InputIterator&gt;</a>
<a name="ln1260">	void</a>
<a name="ln1261">	_M_insert_dispatch(iterator __pos,</a>
<a name="ln1262">			   _InputIterator __first, _InputIterator __last,</a>
<a name="ln1263">			   __false_type)</a>
<a name="ln1264">	{ _M_insert_range(__pos, __first, __last,</a>
<a name="ln1265">			  std::__iterator_category(__first)); }</a>
<a name="ln1266"> </a>
<a name="ln1267">      void</a>
<a name="ln1268">      _M_fill_insert(iterator __position, size_type __n, bool __x);</a>
<a name="ln1269"> </a>
<a name="ln1270">      template&lt;typename _InputIterator&gt;</a>
<a name="ln1271">	void</a>
<a name="ln1272">	_M_insert_range(iterator __pos, _InputIterator __first,</a>
<a name="ln1273">			_InputIterator __last, std::input_iterator_tag)</a>
<a name="ln1274">	{</a>
<a name="ln1275">	  for (; __first != __last; ++__first)</a>
<a name="ln1276">	    {</a>
<a name="ln1277">	      __pos = insert(__pos, *__first);</a>
<a name="ln1278">	      ++__pos;</a>
<a name="ln1279">	    }</a>
<a name="ln1280">	}</a>
<a name="ln1281"> </a>
<a name="ln1282">      template&lt;typename _ForwardIterator&gt;</a>
<a name="ln1283">	void</a>
<a name="ln1284">	_M_insert_range(iterator __position, _ForwardIterator __first,</a>
<a name="ln1285">			_ForwardIterator __last, std::forward_iterator_tag);</a>
<a name="ln1286"> </a>
<a name="ln1287">      void</a>
<a name="ln1288">      _M_insert_aux(iterator __position, bool __x);</a>
<a name="ln1289"> </a>
<a name="ln1290">      size_type</a>
<a name="ln1291">      _M_check_len(size_type __n, const char* __s) const</a>
<a name="ln1292">      {</a>
<a name="ln1293">	if (max_size() - size() &lt; __n)</a>
<a name="ln1294">	  __throw_length_error(__N(__s));</a>
<a name="ln1295"> </a>
<a name="ln1296">	const size_type __len = size() + std::max(size(), __n);</a>
<a name="ln1297">	return (__len &lt; size() || __len &gt; max_size()) ? max_size() : __len;</a>
<a name="ln1298">      }</a>
<a name="ln1299"> </a>
<a name="ln1300">      void</a>
<a name="ln1301">      _M_erase_at_end(iterator __pos)</a>
<a name="ln1302">      { this-&gt;_M_impl._M_finish = __pos; }</a>
<a name="ln1303"> </a>
<a name="ln1304">      iterator</a>
<a name="ln1305">      _M_erase(iterator __pos);</a>
<a name="ln1306"> </a>
<a name="ln1307">      iterator</a>
<a name="ln1308">      _M_erase(iterator __first, iterator __last);</a>
<a name="ln1309">  };</a>
<a name="ln1310"> </a>
<a name="ln1311">_GLIBCXX_END_NAMESPACE_CONTAINER</a>
<a name="ln1312">_GLIBCXX_END_NAMESPACE_VERSION</a>
<a name="ln1313">} // namespace std</a>
<a name="ln1314"> </a>
<a name="ln1315">#if __cplusplus &gt;= 201103L</a>
<a name="ln1316"> </a>
<a name="ln1317">namespace std _GLIBCXX_VISIBILITY(default)</a>
<a name="ln1318">{</a>
<a name="ln1319">_GLIBCXX_BEGIN_NAMESPACE_VERSION</a>
<a name="ln1320"> </a>
<a name="ln1321">  // DR 1182.</a>
<a name="ln1322">  /// std::hash specialization for vector&lt;bool&gt;.</a>
<a name="ln1323">  template&lt;typename _Alloc&gt;</a>
<a name="ln1324">    struct hash&lt;_GLIBCXX_STD_C::vector&lt;bool, _Alloc&gt;&gt;</a>
<a name="ln1325">    : public __hash_base&lt;size_t, _GLIBCXX_STD_C::vector&lt;bool, _Alloc&gt;&gt;</a>
<a name="ln1326">    {</a>
<a name="ln1327">      size_t</a>
<a name="ln1328">      operator()(const _GLIBCXX_STD_C::vector&lt;bool, _Alloc&gt;&amp;) const noexcept;</a>
<a name="ln1329">    };</a>
<a name="ln1330"> </a>
<a name="ln1331">_GLIBCXX_END_NAMESPACE_VERSION</a>
<a name="ln1332">}// namespace std</a>
<a name="ln1333"> </a>
<a name="ln1334">#endif // C++11</a>
<a name="ln1335"> </a>
<a name="ln1336">#endif</a>

</code></pre>
<div class="balloon" rel="72"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v690/" target="_blank">V690</a> The '_Bit_reference' class implements the copy assignment operator, but lacks a copy constructor. It is dangerous to use such a class.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
