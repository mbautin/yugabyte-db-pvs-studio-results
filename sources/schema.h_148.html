
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>schema.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Licensed to the Apache Software Foundation (ASF) under one</a>
<a name="ln2">// or more contributor license agreements.  See the NOTICE file</a>
<a name="ln3">// distributed with this work for additional information</a>
<a name="ln4">// regarding copyright ownership.  The ASF licenses this file</a>
<a name="ln5">// to you under the Apache License, Version 2.0 (the</a>
<a name="ln6">// &quot;License&quot;); you may not use this file except in compliance</a>
<a name="ln7">// with the License.  You may obtain a copy of the License at</a>
<a name="ln8">//</a>
<a name="ln9">//   http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln10">//</a>
<a name="ln11">// Unless required by applicable law or agreed to in writing,</a>
<a name="ln12">// software distributed under the License is distributed on an</a>
<a name="ln13">// &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</a>
<a name="ln14">// KIND, either express or implied.  See the License for the</a>
<a name="ln15">// specific language governing permissions and limitations</a>
<a name="ln16">// under the License.</a>
<a name="ln17">//</a>
<a name="ln18">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln19">//</a>
<a name="ln20">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln21">//</a>
<a name="ln22">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln23">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln24">//</a>
<a name="ln25">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln26">//</a>
<a name="ln27">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln28">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln29">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln30">// under the License.</a>
<a name="ln31">//</a>
<a name="ln32">#ifndef YB_COMMON_SCHEMA_H</a>
<a name="ln33">#define YB_COMMON_SCHEMA_H</a>
<a name="ln34"> </a>
<a name="ln35">#include &lt;functional&gt;</a>
<a name="ln36">#include &lt;memory&gt;</a>
<a name="ln37">#include &lt;string&gt;</a>
<a name="ln38">#include &lt;unordered_map&gt;</a>
<a name="ln39">#include &lt;unordered_set&gt;</a>
<a name="ln40">#include &lt;utility&gt;</a>
<a name="ln41">#include &lt;vector&gt;</a>
<a name="ln42"> </a>
<a name="ln43">#include &lt;glog/logging.h&gt;</a>
<a name="ln44"> </a>
<a name="ln45">#include &quot;yb/common/ql_type.h&quot;</a>
<a name="ln46">#include &quot;yb/common/id_mapping.h&quot;</a>
<a name="ln47">#include &quot;yb/common/key_encoder.h&quot;</a>
<a name="ln48">#include &quot;yb/common/hybrid_time.h&quot;</a>
<a name="ln49">#include &quot;yb/common/transaction.h&quot;</a>
<a name="ln50">#include &quot;yb/common/common.pb.h&quot;</a>
<a name="ln51">#include &quot;yb/gutil/stl_util.h&quot;</a>
<a name="ln52">#include &quot;yb/gutil/strings/strcat.h&quot;</a>
<a name="ln53">#include &quot;yb/gutil/strings/substitute.h&quot;</a>
<a name="ln54">#include &quot;yb/util/enums.h&quot;</a>
<a name="ln55">#include &quot;yb/util/status.h&quot;</a>
<a name="ln56"> </a>
<a name="ln57">// Check that two schemas are equal, yielding a useful error message in the case that</a>
<a name="ln58">// they are not.</a>
<a name="ln59">#define DCHECK_SCHEMA_EQ(s1, s2) \</a>
<a name="ln60">  do { \</a>
<a name="ln61">    DCHECK((s1).Equals((s2))) &lt;&lt; &quot;Schema &quot; &lt;&lt; (s1).ToString() \</a>
<a name="ln62">                              &lt;&lt; &quot; does not match &quot; &lt;&lt; (s2).ToString(); \</a>
<a name="ln63">  } while (0);</a>
<a name="ln64"> </a>
<a name="ln65">#define DCHECK_KEY_PROJECTION_SCHEMA_EQ(s1, s2) \</a>
<a name="ln66">  do { \</a>
<a name="ln67">    DCHECK((s1).KeyEquals((s2))) &lt;&lt; &quot;Key-Projection Schema &quot; \</a>
<a name="ln68">                                 &lt;&lt; (s1).ToString() &lt;&lt; &quot; does not match &quot; \</a>
<a name="ln69">                                 &lt;&lt; (s2).ToString(); \</a>
<a name="ln70">  } while (0);</a>
<a name="ln71"> </a>
<a name="ln72">namespace yb {</a>
<a name="ln73"> </a>
<a name="ln74">class DeletedColumnPB;</a>
<a name="ln75"> </a>
<a name="ln76">using std::vector;</a>
<a name="ln77">using std::unordered_map;</a>
<a name="ln78">using std::unordered_set;</a>
<a name="ln79"> </a>
<a name="ln80">template&lt;char digit1, char... digits&gt;</a>
<a name="ln81">struct ColumnIdHelper {</a>
<a name="ln82">  typedef ColumnIdHelper&lt;digit1&gt; Current;</a>
<a name="ln83">  typedef ColumnIdHelper&lt;digits...&gt; Next;</a>
<a name="ln84">  static constexpr int mul = Next::mul * 10;</a>
<a name="ln85">  static constexpr int value = Current::value * mul + Next::value;</a>
<a name="ln86">  static_assert(value &lt;= std::numeric_limits&lt;int32_t&gt;::max(), &quot;Too big constant&quot;);</a>
<a name="ln87">};</a>
<a name="ln88"> </a>
<a name="ln89">template&lt;char digit&gt;</a>
<a name="ln90">struct ColumnIdHelper&lt;digit&gt; {</a>
<a name="ln91">  static_assert(digit &gt;= '0' &amp;&amp; digit &lt;= '9', &quot;Only digits is allowed&quot;);</a>
<a name="ln92">  static constexpr int value = digit - '0';</a>
<a name="ln93">  static constexpr int mul = 1;</a>
<a name="ln94">};</a>
<a name="ln95"> </a>
<a name="ln96">// The ID of a column. Each column in a table has a unique ID.</a>
<a name="ln97">typedef int32_t ColumnIdRep;</a>
<a name="ln98">struct ColumnId {</a>
<a name="ln99">  explicit ColumnId(ColumnIdRep t_) : t(t_) {</a>
<a name="ln100">    DCHECK_GE(t_, 0);</a>
<a name="ln101">  }</a>
<a name="ln102">  template&lt;char... digits&gt;</a>
<a name="ln103">  constexpr explicit ColumnId(ColumnIdHelper&lt;digits...&gt;) : t(ColumnIdHelper&lt;digits...&gt;::value) {}</a>
<a name="ln104"> </a>
<a name="ln105">  ColumnId() : t() {}</a>
<a name="ln106">  constexpr ColumnId(const ColumnId&amp; t_) : t(t_.t) {}</a>
<a name="ln107">  ColumnId&amp; operator=(const ColumnId&amp; rhs) { t = rhs.t; return *this; }</a>
<a name="ln108">  ColumnId&amp; operator=(const ColumnIdRep&amp; rhs) { DCHECK_GE(rhs, 0); t = rhs; return *this; }</a>
<a name="ln109">  operator const ColumnIdRep() const { return t; }</a>
<a name="ln110">  operator const strings::internal::SubstituteArg() const { return t; }</a>
<a name="ln111">  operator const AlphaNum() const { return t; }</a>
<a name="ln112">  ColumnIdRep rep() const { return t; }</a>
<a name="ln113"> </a>
<a name="ln114">  bool operator==(const ColumnId&amp; rhs) const { return t == rhs.t; }</a>
<a name="ln115">  bool operator!=(const ColumnId&amp; rhs) const { return t != rhs.t; }</a>
<a name="ln116">  bool operator&lt;(const ColumnId&amp; rhs) const { return t &lt; rhs.t; }</a>
<a name="ln117">  bool operator&gt;(const ColumnId&amp; rhs) const { return t &gt; rhs.t; }</a>
<a name="ln118"> </a>
<a name="ln119">  friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, ColumnId column_id) {</a>
<a name="ln120">    return os &lt;&lt; column_id.t;</a>
<a name="ln121">  }</a>
<a name="ln122"> </a>
<a name="ln123">  std::string ToString() const {</a>
<a name="ln124">    return std::to_string(t);</a>
<a name="ln125">  }</a>
<a name="ln126"> </a>
<a name="ln127">  uint64_t ToUint64() const {</a>
<a name="ln128">    DCHECK_GE(t, 0);</a>
<a name="ln129">    return static_cast&lt;uint64_t&gt;(t);</a>
<a name="ln130">  }</a>
<a name="ln131"> </a>
<a name="ln132">  static CHECKED_STATUS FromInt64(int64_t value, ColumnId *column_id) {</a>
<a name="ln133">    if (value &gt; std::numeric_limits&lt;ColumnIdRep&gt;::max() || value &lt; 0) {</a>
<a name="ln134">      return STATUS(Corruption, strings::Substitute(&quot;$0 not valid for column id representation&quot;,</a>
<a name="ln135">                                                    value));</a>
<a name="ln136">    }</a>
<a name="ln137">    column_id-&gt;t = static_cast&lt;ColumnIdRep&gt;(value);</a>
<a name="ln138">    return Status::OK();</a>
<a name="ln139">  }</a>
<a name="ln140"> </a>
<a name="ln141"> private:</a>
<a name="ln142">  ColumnIdRep t;</a>
<a name="ln143">};</a>
<a name="ln144">static const ColumnId kInvalidColumnId = ColumnId(std::numeric_limits&lt;ColumnIdRep&gt;::max());</a>
<a name="ln145">// In a new schema, we typically would start assigning column IDs at 0. However, this</a>
<a name="ln146">// makes it likely that in many test cases, the column IDs and the column indexes are</a>
<a name="ln147">// equal to each other, and it's easy to accidentally pass an index where we meant to pass</a>
<a name="ln148">// an ID, without having any issues. So, in DEBUG builds, we start assigning columns at ID</a>
<a name="ln149">// 10, ensuring that if we accidentally mix up IDs and indexes, we're likely to fire an</a>
<a name="ln150">// assertion or bad memory access.</a>
<a name="ln151">#ifdef NDEBUG</a>
<a name="ln152">constexpr ColumnIdRep kFirstColumnIdRep = 0;</a>
<a name="ln153">#else</a>
<a name="ln154">constexpr ColumnIdRep kFirstColumnIdRep = 10;</a>
<a name="ln155">#endif</a>
<a name="ln156">const ColumnId kFirstColumnId(kFirstColumnIdRep);</a>
<a name="ln157"> </a>
<a name="ln158">template&lt;char... digits&gt;</a>
<a name="ln159">ColumnId operator&quot;&quot; _ColId() {</a>
<a name="ln160">  return ColumnId(ColumnIdHelper&lt;digits...&gt;());</a>
<a name="ln161">}</a>
<a name="ln162"> </a>
<a name="ln163">// Struct for storing information about deleted columns for cleanup.</a>
<a name="ln164">struct DeletedColumn {</a>
<a name="ln165">  ColumnId id;</a>
<a name="ln166">  HybridTime ht;</a>
<a name="ln167"> </a>
<a name="ln168">  DeletedColumn() { }</a>
<a name="ln169"> </a>
<a name="ln170">  DeletedColumn(ColumnId id, const HybridTime&amp; ht) : id(id), ht(ht) { }</a>
<a name="ln171"> </a>
<a name="ln172">  static CHECKED_STATUS FromPB(const DeletedColumnPB&amp; col, DeletedColumn* ret);</a>
<a name="ln173">  void CopyToPB(DeletedColumnPB* pb) const;</a>
<a name="ln174">};</a>
<a name="ln175"> </a>
<a name="ln176">typedef std::unordered_set&lt;ColumnId&gt; ColumnIds;</a>
<a name="ln177">typedef std::shared_ptr&lt;ColumnIds&gt; ColumnIdsPtr;</a>
<a name="ln178"> </a>
<a name="ln179">// The schema for a given column.</a>
<a name="ln180">//</a>
<a name="ln181">// Holds the data type as well as information about nullability &amp; column name.</a>
<a name="ln182">// In the future, it may hold information about annotations, etc.</a>
<a name="ln183">class ColumnSchema {</a>
<a name="ln184"> public:</a>
<a name="ln185">  enum SortingType : uint8_t {</a>
<a name="ln186">    kNotSpecified = 0,</a>
<a name="ln187">    kAscending,          // ASC, NULLS FIRST</a>
<a name="ln188">    kDescending,         // DESC, NULLS FIRST</a>
<a name="ln189">    kAscendingNullsLast, // ASC, NULLS LAST</a>
<a name="ln190">    kDescendingNullsLast // DESC, NULLS LAST</a>
<a name="ln191">  };</a>
<a name="ln192"> </a>
<a name="ln193">  // name: column name</a>
<a name="ln194">  // type: column type (e.g. UINT8, INT32, STRING, MAP&lt;INT32, STRING&gt; ...)</a>
<a name="ln195">  // is_nullable: true if a row value can be null</a>
<a name="ln196">  // is_hash_key: true if a column's hash value can be used for partitioning.</a>
<a name="ln197">  //</a>
<a name="ln198">  // Example:</a>
<a name="ln199">  //   ColumnSchema col_a(&quot;a&quot;, UINT32)</a>
<a name="ln200">  //   ColumnSchema col_b(&quot;b&quot;, STRING, true);</a>
<a name="ln201">  //   uint32_t default_i32 = -15;</a>
<a name="ln202">  //   ColumnSchema col_c(&quot;c&quot;, INT32, false, &amp;default_i32);</a>
<a name="ln203">  //   Slice default_str(&quot;Hello&quot;);</a>
<a name="ln204">  //   ColumnSchema col_d(&quot;d&quot;, STRING, false, &amp;default_str);</a>
<a name="ln205">  ColumnSchema(string name,</a>
<a name="ln206">               const std::shared_ptr&lt;QLType&gt;&amp; type,</a>
<a name="ln207">               bool is_nullable = false,</a>
<a name="ln208">               bool is_hash_key = false,</a>
<a name="ln209">               bool is_static = false,</a>
<a name="ln210">               bool is_counter = false,</a>
<a name="ln211">               int32_t order = 0,</a>
<a name="ln212">               SortingType sorting_type = SortingType::kNotSpecified)</a>
<a name="ln213">      : name_(std::move(name)),</a>
<a name="ln214">        type_(type),</a>
<a name="ln215">        is_nullable_(is_nullable),</a>
<a name="ln216">        is_hash_key_(is_hash_key),</a>
<a name="ln217">        is_static_(is_static),</a>
<a name="ln218">        is_counter_(is_counter),</a>
<a name="ln219">        order_(order),</a>
<a name="ln220">        sorting_type_(sorting_type) {</a>
<a name="ln221">  }</a>
<a name="ln222"> </a>
<a name="ln223">  // convenience constructor for creating columns with simple (non-parametric) data types</a>
<a name="ln224">  ColumnSchema(string name,</a>
<a name="ln225">               DataType type,</a>
<a name="ln226">               bool is_nullable = false,</a>
<a name="ln227">               bool is_hash_key = false,</a>
<a name="ln228">               bool is_static = false,</a>
<a name="ln229">               bool is_counter = false,</a>
<a name="ln230">               int32_t order = 0,</a>
<a name="ln231">               SortingType sorting_type = SortingType::kNotSpecified)</a>
<a name="ln232">      : ColumnSchema(name, QLType::Create(type), is_nullable, is_hash_key, is_static, is_counter,</a>
<a name="ln233">                     order, sorting_type) {</a>
<a name="ln234">  }</a>
<a name="ln235"> </a>
<a name="ln236">  const std::shared_ptr&lt;QLType&gt;&amp; type() const {</a>
<a name="ln237">    return type_;</a>
<a name="ln238">  }</a>
<a name="ln239"> </a>
<a name="ln240">  void set_type(const std::shared_ptr&lt;QLType&gt;&amp; type) {</a>
<a name="ln241">    type_ = type;</a>
<a name="ln242">  }</a>
<a name="ln243"> </a>
<a name="ln244">  const TypeInfo* type_info() const {</a>
<a name="ln245">    return type_-&gt;type_info();</a>
<a name="ln246">  }</a>
<a name="ln247"> </a>
<a name="ln248">  bool is_nullable() const {</a>
<a name="ln249">    return is_nullable_;</a>
<a name="ln250">  }</a>
<a name="ln251"> </a>
<a name="ln252">  bool is_hash_key() const {</a>
<a name="ln253">    return is_hash_key_;</a>
<a name="ln254">  }</a>
<a name="ln255"> </a>
<a name="ln256">  bool is_static() const {</a>
<a name="ln257">    return is_static_;</a>
<a name="ln258">  }</a>
<a name="ln259"> </a>
<a name="ln260">  bool is_counter() const {</a>
<a name="ln261">    return is_counter_;</a>
<a name="ln262">  }</a>
<a name="ln263"> </a>
<a name="ln264">  int32_t order() const {</a>
<a name="ln265">    return order_;</a>
<a name="ln266">  }</a>
<a name="ln267"> </a>
<a name="ln268">  SortingType sorting_type() const {</a>
<a name="ln269">    return sorting_type_;</a>
<a name="ln270">  }</a>
<a name="ln271"> </a>
<a name="ln272">  void set_sorting_type(SortingType sorting_type) {</a>
<a name="ln273">    sorting_type_ = sorting_type;</a>
<a name="ln274">  }</a>
<a name="ln275"> </a>
<a name="ln276">  const std::string sorting_type_string() const {</a>
<a name="ln277">    switch (sorting_type_) {</a>
<a name="ln278">      case kNotSpecified:</a>
<a name="ln279">        return &quot;none&quot;;</a>
<a name="ln280">      case kAscending:</a>
<a name="ln281">        return &quot;asc&quot;;</a>
<a name="ln282">      case kDescending:</a>
<a name="ln283">        return &quot;desc&quot;;</a>
<a name="ln284">      case kAscendingNullsLast:</a>
<a name="ln285">        return &quot;asc nulls last&quot;;</a>
<a name="ln286">      case kDescendingNullsLast:</a>
<a name="ln287">        return &quot;desc nulls last&quot;;</a>
<a name="ln288">    }</a>
<a name="ln289">    LOG (FATAL) &lt;&lt; &quot;Invalid sorting type: &quot; &lt;&lt; sorting_type_;</a>
<a name="ln290">  }</a>
<a name="ln291"> </a>
<a name="ln292">  const std::string &amp;name() const {</a>
<a name="ln293">    return name_;</a>
<a name="ln294">  }</a>
<a name="ln295"> </a>
<a name="ln296">  // Return a string identifying this column, including its</a>
<a name="ln297">  // name.</a>
<a name="ln298">  std::string ToString() const;</a>
<a name="ln299"> </a>
<a name="ln300">  // Same as above, but only including the type information.</a>
<a name="ln301">  // For example, &quot;STRING NOT NULL&quot;.</a>
<a name="ln302">  std::string TypeToString() const;</a>
<a name="ln303"> </a>
<a name="ln304">  bool EqualsType(const ColumnSchema &amp;other) const {</a>
<a name="ln305">    return is_nullable_ == other.is_nullable_ &amp;&amp;</a>
<a name="ln306">           is_hash_key_ == other.is_hash_key_ &amp;&amp;</a>
<a name="ln307">           sorting_type_ == other.sorting_type_ &amp;&amp;</a>
<a name="ln308">           type_info()-&gt;type() == other.type_info()-&gt;type();</a>
<a name="ln309">  }</a>
<a name="ln310"> </a>
<a name="ln311">  bool Equals(const ColumnSchema &amp;other) const {</a>
<a name="ln312">    return EqualsType(other) &amp;&amp; this-&gt;name_ == other.name_;</a>
<a name="ln313">  }</a>
<a name="ln314"> </a>
<a name="ln315">  int Compare(const void *lhs, const void *rhs) const {</a>
<a name="ln316">    return type_info()-&gt;Compare(lhs, rhs);</a>
<a name="ln317">  }</a>
<a name="ln318"> </a>
<a name="ln319">  // Stringify the given cell. This just stringifies the cell contents,</a>
<a name="ln320">  // and doesn't include the column name or type.</a>
<a name="ln321">  std::string Stringify(const void *cell) const {</a>
<a name="ln322">    std::string ret;</a>
<a name="ln323">    type_info()-&gt;AppendDebugStringForValue(cell, &amp;ret);</a>
<a name="ln324">    return ret;</a>
<a name="ln325">  }</a>
<a name="ln326"> </a>
<a name="ln327">  // Append a debug string for this cell. This differs from Stringify above</a>
<a name="ln328">  // in that it also includes the column info, for example 'STRING foo=bar'.</a>
<a name="ln329">  template&lt;class CellType&gt;</a>
<a name="ln330">  void DebugCellAppend(const CellType&amp; cell, std::string* ret) const {</a>
<a name="ln331">    ret-&gt;append(type_info()-&gt;name());</a>
<a name="ln332">    ret-&gt;append(&quot; &quot;);</a>
<a name="ln333">    ret-&gt;append(name_);</a>
<a name="ln334">    ret-&gt;append(&quot;=&quot;);</a>
<a name="ln335">    if (is_nullable_ &amp;&amp; cell.is_null()) {</a>
<a name="ln336">      ret-&gt;append(&quot;NULL&quot;);</a>
<a name="ln337">    } else {</a>
<a name="ln338">      type_info()-&gt;AppendDebugStringForValue(cell.ptr(), ret);</a>
<a name="ln339">    }</a>
<a name="ln340">  }</a>
<a name="ln341"> </a>
<a name="ln342">  // Returns the memory usage of this object without the object itself. Should</a>
<a name="ln343">  // be used when embedded inside another object.</a>
<a name="ln344">  size_t memory_footprint_excluding_this() const;</a>
<a name="ln345"> </a>
<a name="ln346">  // Returns the memory usage of this object including the object itself.</a>
<a name="ln347">  // Should be used when allocated on the heap.</a>
<a name="ln348">  size_t memory_footprint_including_this() const;</a>
<a name="ln349"> </a>
<a name="ln350"> private:</a>
<a name="ln351">  friend class SchemaBuilder;</a>
<a name="ln352"> </a>
<a name="ln353">  void set_name(const std::string&amp; name) {</a>
<a name="ln354">    name_ = name;</a>
<a name="ln355">  }</a>
<a name="ln356"> </a>
<a name="ln357">  std::string name_;</a>
<a name="ln358">  std::shared_ptr&lt;QLType&gt; type_;</a>
<a name="ln359">  bool is_nullable_;</a>
<a name="ln360">  bool is_hash_key_;</a>
<a name="ln361">  bool is_static_;</a>
<a name="ln362">  bool is_counter_;</a>
<a name="ln363">  int32_t order_;</a>
<a name="ln364">  SortingType sorting_type_;</a>
<a name="ln365">};</a>
<a name="ln366"> </a>
<a name="ln367">class ContiguousRow;</a>
<a name="ln368">const TableId kNoCopartitionTableId = &quot;&quot;;</a>
<a name="ln369"> </a>
<a name="ln370">class TableProperties {</a>
<a name="ln371"> public:</a>
<a name="ln372">  // Containing counters is a internal property instead of a user-defined property, so we don't use</a>
<a name="ln373">  // it when comparing table properties.</a>
<a name="ln374">  bool operator==(const TableProperties&amp; other) const {</a>
<a name="ln375">    if (!Equivalent(other)) {</a>
<a name="ln376">      return false;</a>
<a name="ln377">    }</a>
<a name="ln378"> </a>
<a name="ln379">    return default_time_to_live_ == other.default_time_to_live_ &amp;&amp;</a>
<a name="ln380">           use_mangled_column_name_ == other.use_mangled_column_name_ &amp;&amp;</a>
<a name="ln381">           contain_counters_ == other.contain_counters_;</a>
<a name="ln382"> </a>
<a name="ln383">    // Ignoring num_tablets_.</a>
<a name="ln384">    // Ignoring is_backfilling_.</a>
<a name="ln385">    // Ignoring wal_retention_secs_.</a>
<a name="ln386">  }</a>
<a name="ln387"> </a>
<a name="ln388">  bool operator!=(const TableProperties&amp; other) const {</a>
<a name="ln389">    return !(*this == other);</a>
<a name="ln390">  }</a>
<a name="ln391"> </a>
<a name="ln392">  bool Equivalent(const TableProperties&amp; other) const {</a>
<a name="ln393">    if (is_ysql_catalog_table_ != other.is_ysql_catalog_table_) {</a>
<a name="ln394">      return false;</a>
<a name="ln395">    }</a>
<a name="ln396"> </a>
<a name="ln397">    if (is_transactional_ != other.is_transactional_) {</a>
<a name="ln398">      return false;</a>
<a name="ln399">    }</a>
<a name="ln400"> </a>
<a name="ln401">    if (consistency_level_ != other.consistency_level_) {</a>
<a name="ln402">      return false;</a>
<a name="ln403">    }</a>
<a name="ln404"> </a>
<a name="ln405">    if ((copartition_table_id_ == kNoCopartitionTableId ||</a>
<a name="ln406">         other.copartition_table_id_ == kNoCopartitionTableId) &amp;&amp;</a>
<a name="ln407">        copartition_table_id_ != other.copartition_table_id_) {</a>
<a name="ln408">      return false;</a>
<a name="ln409">    }</a>
<a name="ln410"> </a>
<a name="ln411">    // Ignoring default_time_to_live_.</a>
<a name="ln412">    // Ignoring num_tablets_.</a>
<a name="ln413">    // Ignoring use_mangled_column_name_.</a>
<a name="ln414">    // Ignoring contain_counters_.</a>
<a name="ln415">    // Ignoring is_backfilling_.</a>
<a name="ln416">    // Ignoring wal_retention_secs_.</a>
<a name="ln417">    return true;</a>
<a name="ln418">  }</a>
<a name="ln419"> </a>
<a name="ln420">  bool HasDefaultTimeToLive() const {</a>
<a name="ln421">    return (default_time_to_live_ != kNoDefaultTtl);</a>
<a name="ln422">  }</a>
<a name="ln423"> </a>
<a name="ln424">  void SetDefaultTimeToLive(uint64_t default_time_to_live) {</a>
<a name="ln425">    default_time_to_live_ = default_time_to_live;</a>
<a name="ln426">  }</a>
<a name="ln427"> </a>
<a name="ln428">  int64_t DefaultTimeToLive() const {</a>
<a name="ln429">    return default_time_to_live_;</a>
<a name="ln430">  }</a>
<a name="ln431"> </a>
<a name="ln432">  bool contain_counters() const {</a>
<a name="ln433">    return contain_counters_;</a>
<a name="ln434">  }</a>
<a name="ln435"> </a>
<a name="ln436">  bool is_transactional() const {</a>
<a name="ln437">    return is_transactional_;</a>
<a name="ln438">  }</a>
<a name="ln439"> </a>
<a name="ln440">  YBConsistencyLevel consistency_level() const {</a>
<a name="ln441">    return consistency_level_;</a>
<a name="ln442">  }</a>
<a name="ln443"> </a>
<a name="ln444">  void SetContainCounters(bool contain_counters) {</a>
<a name="ln445">    contain_counters_ = contain_counters;</a>
<a name="ln446">  }</a>
<a name="ln447"> </a>
<a name="ln448">  void SetTransactional(bool is_transactional) {</a>
<a name="ln449">    is_transactional_ = is_transactional;</a>
<a name="ln450">  }</a>
<a name="ln451"> </a>
<a name="ln452">  void SetConsistencyLevel(YBConsistencyLevel consistency_level) {</a>
<a name="ln453">    consistency_level_ = consistency_level;</a>
<a name="ln454">  }</a>
<a name="ln455"> </a>
<a name="ln456">  TableId CopartitionTableId() const {</a>
<a name="ln457">    return copartition_table_id_;</a>
<a name="ln458">  }</a>
<a name="ln459"> </a>
<a name="ln460">  bool HasCopartitionTableId() const {</a>
<a name="ln461">    return copartition_table_id_ != kNoCopartitionTableId;</a>
<a name="ln462">  }</a>
<a name="ln463"> </a>
<a name="ln464">  void SetCopartitionTableId(const TableId&amp; copartition_table_id) {</a>
<a name="ln465">    copartition_table_id_ = copartition_table_id;</a>
<a name="ln466">  }</a>
<a name="ln467"> </a>
<a name="ln468">  void SetUseMangledColumnName(bool value) {</a>
<a name="ln469">    use_mangled_column_name_ = value;</a>
<a name="ln470">  }</a>
<a name="ln471"> </a>
<a name="ln472">  bool use_mangled_column_name() const {</a>
<a name="ln473">    return use_mangled_column_name_;</a>
<a name="ln474">  }</a>
<a name="ln475"> </a>
<a name="ln476">  void SetNumTablets(int num_tablets) {</a>
<a name="ln477">    num_tablets_ = num_tablets;</a>
<a name="ln478">  }</a>
<a name="ln479"> </a>
<a name="ln480">  bool HasNumTablets() const {</a>
<a name="ln481">    return num_tablets_ &gt; 0;</a>
<a name="ln482">  }</a>
<a name="ln483"> </a>
<a name="ln484">  int num_tablets() const {</a>
<a name="ln485">    return num_tablets_;</a>
<a name="ln486">  }</a>
<a name="ln487"> </a>
<a name="ln488">  void set_is_ysql_catalog_table(bool is_ysql_catalog_table) {</a>
<a name="ln489">    is_ysql_catalog_table_ = is_ysql_catalog_table;</a>
<a name="ln490">  }</a>
<a name="ln491"> </a>
<a name="ln492">  bool is_ysql_catalog_table() const {</a>
<a name="ln493">    return is_ysql_catalog_table_;</a>
<a name="ln494">  }</a>
<a name="ln495"> </a>
<a name="ln496">  bool IsBackfilling() const { return is_backfilling_; }</a>
<a name="ln497"> </a>
<a name="ln498">  void SetIsBackfilling(bool is_backfilling) { is_backfilling_ = is_backfilling; }</a>
<a name="ln499"> </a>
<a name="ln500">  void ToTablePropertiesPB(TablePropertiesPB *pb) const;</a>
<a name="ln501"> </a>
<a name="ln502">  static TableProperties FromTablePropertiesPB(const TablePropertiesPB&amp; pb);</a>
<a name="ln503"> </a>
<a name="ln504">  void AlterFromTablePropertiesPB(const TablePropertiesPB&amp; pb);</a>
<a name="ln505"> </a>
<a name="ln506">  void Reset();</a>
<a name="ln507"> </a>
<a name="ln508">  std::string ToString() const;</a>
<a name="ln509"> </a>
<a name="ln510"> private:</a>
<a name="ln511">  // IMPORTANT: Every time a new property is added, we need to revisit</a>
<a name="ln512">  // operator== and Equivalent methods to make sure that the new property</a>
<a name="ln513">  // is being taken into consideration when deciding whether properties between</a>
<a name="ln514">  // two different tables are equal or equivalent.</a>
<a name="ln515">  static const int kNoDefaultTtl = -1;</a>
<a name="ln516">  int64_t default_time_to_live_ = kNoDefaultTtl;</a>
<a name="ln517">  bool contain_counters_ = false;</a>
<a name="ln518">  bool is_transactional_ = false;</a>
<a name="ln519">  bool is_backfilling_ = false;</a>
<a name="ln520">  YBConsistencyLevel consistency_level_ = YBConsistencyLevel::STRONG;</a>
<a name="ln521">  TableId copartition_table_id_ = kNoCopartitionTableId;</a>
<a name="ln522">  boost::optional&lt;uint32_t&gt; wal_retention_secs_;</a>
<a name="ln523">  bool use_mangled_column_name_ = false;</a>
<a name="ln524">  int num_tablets_ = 0;</a>
<a name="ln525">  bool is_ysql_catalog_table_ = false;</a>
<a name="ln526">};</a>
<a name="ln527"> </a>
<a name="ln528">typedef uint32_t PgTableOid;</a>
<a name="ln529"> </a>
<a name="ln530">// The schema for a set of rows.</a>
<a name="ln531">//</a>
<a name="ln532">// A Schema is simply a set of columns, along with information about</a>
<a name="ln533">// which prefix of columns makes up the primary key.</a>
<a name="ln534">//</a>
<a name="ln535">// Note that, while Schema is copyable and assignable, it is a complex</a>
<a name="ln536">// object that is not inexpensive to copy. You should generally prefer</a>
<a name="ln537">// passing by pointer or reference, and functions that create new</a>
<a name="ln538">// Schemas should generally prefer taking a Schema pointer and using</a>
<a name="ln539">// Schema::swap() or Schema::Reset() rather than returning by value.</a>
<a name="ln540">class Schema {</a>
<a name="ln541"> public:</a>
<a name="ln542"> </a>
<a name="ln543">  static const int kColumnNotFound = -1;</a>
<a name="ln544"> </a>
<a name="ln545">  Schema()</a>
<a name="ln546">    : num_key_columns_(0),</a>
<a name="ln547">      num_hash_key_columns_(0),</a>
<a name="ln548">      name_to_index_bytes_(0),</a>
<a name="ln549">      // TODO: C++11 provides a single-arg constructor</a>
<a name="ln550">      name_to_index_(10,</a>
<a name="ln551">                     NameToIndexMap::hasher(),</a>
<a name="ln552">                     NameToIndexMap::key_equal(),</a>
<a name="ln553">                     NameToIndexMapAllocator(&amp;name_to_index_bytes_)),</a>
<a name="ln554">      has_nullables_(false),</a>
<a name="ln555">      cotable_id_(boost::uuids::nil_uuid()),</a>
<a name="ln556">      pgtable_id_(0) {</a>
<a name="ln557">  }</a>
<a name="ln558"> </a>
<a name="ln559">  Schema(const Schema&amp; other);</a>
<a name="ln560">  Schema&amp; operator=(const Schema&amp; other);</a>
<a name="ln561"> </a>
<a name="ln562">  void swap(Schema&amp; other); // NOLINT(build/include_what_you_use)</a>
<a name="ln563"> </a>
<a name="ln564">  void CopyFrom(const Schema&amp; other);</a>
<a name="ln565"> </a>
<a name="ln566">  // Construct a schema with the given information.</a>
<a name="ln567">  //</a>
<a name="ln568">  // NOTE: if the schema is user-provided, it's better to construct an</a>
<a name="ln569">  // empty schema and then use Reset(...)  so that errors can be</a>
<a name="ln570">  // caught. If an invalid schema is passed to this constructor, an</a>
<a name="ln571">  // assertion will be fired!</a>
<a name="ln572">  Schema(const vector&lt;ColumnSchema&gt;&amp; cols,</a>
<a name="ln573">         int key_columns,</a>
<a name="ln574">         const TableProperties&amp; table_properties = TableProperties(),</a>
<a name="ln575">         const Uuid&amp; cotable_id = Uuid(boost::uuids::nil_uuid()),</a>
<a name="ln576">         const PgTableOid pgtable_id = 0)</a>
<a name="ln577">    : name_to_index_bytes_(0),</a>
<a name="ln578">      // TODO: C++11 provides a single-arg constructor</a>
<a name="ln579">      name_to_index_(10,</a>
<a name="ln580">                     NameToIndexMap::hasher(),</a>
<a name="ln581">                     NameToIndexMap::key_equal(),</a>
<a name="ln582">                     NameToIndexMapAllocator(&amp;name_to_index_bytes_)) {</a>
<a name="ln583">    CHECK_OK(Reset(cols, key_columns, table_properties, cotable_id, pgtable_id));</a>
<a name="ln584">  }</a>
<a name="ln585"> </a>
<a name="ln586">  // Construct a schema with the given information.</a>
<a name="ln587">  //</a>
<a name="ln588">  // NOTE: if the schema is user-provided, it's better to construct an</a>
<a name="ln589">  // empty schema and then use Reset(...)  so that errors can be</a>
<a name="ln590">  // caught. If an invalid schema is passed to this constructor, an</a>
<a name="ln591">  // assertion will be fired!</a>
<a name="ln592">  Schema(const vector&lt;ColumnSchema&gt;&amp; cols,</a>
<a name="ln593">         const vector&lt;ColumnId&gt;&amp; ids,</a>
<a name="ln594">         int key_columns,</a>
<a name="ln595">         const TableProperties&amp; table_properties = TableProperties(),</a>
<a name="ln596">         const Uuid&amp; cotable_id = Uuid(boost::uuids::nil_uuid()),</a>
<a name="ln597">         const PgTableOid pgtable_id = 0)</a>
<a name="ln598">    : name_to_index_bytes_(0),</a>
<a name="ln599">      // TODO: C++11 provides a single-arg constructor</a>
<a name="ln600">      name_to_index_(10,</a>
<a name="ln601">                     NameToIndexMap::hasher(),</a>
<a name="ln602">                     NameToIndexMap::key_equal(),</a>
<a name="ln603">                     NameToIndexMapAllocator(&amp;name_to_index_bytes_)) {</a>
<a name="ln604">    CHECK_OK(Reset(cols, ids, key_columns, table_properties, cotable_id, pgtable_id));</a>
<a name="ln605">  }</a>
<a name="ln606"> </a>
<a name="ln607">  // Reset this Schema object to the given schema.</a>
<a name="ln608">  // If this fails, the Schema object is left in an inconsistent</a>
<a name="ln609">  // state and may not be used.</a>
<a name="ln610">  CHECKED_STATUS Reset(const vector&lt;ColumnSchema&gt;&amp; cols, int key_columns,</a>
<a name="ln611">                       const TableProperties&amp; table_properties = TableProperties(),</a>
<a name="ln612">                       const Uuid&amp; cotable_id = Uuid(boost::uuids::nil_uuid()),</a>
<a name="ln613">                       const PgTableOid pgtable_id = 0) {</a>
<a name="ln614">    std::vector&lt;ColumnId&gt; ids;</a>
<a name="ln615">    return Reset(cols, ids, key_columns, table_properties, cotable_id, pgtable_id);</a>
<a name="ln616">  }</a>
<a name="ln617"> </a>
<a name="ln618">  // Reset this Schema object to the given schema.</a>
<a name="ln619">  // If this fails, the Schema object is left in an inconsistent</a>
<a name="ln620">  // state and may not be used.</a>
<a name="ln621">  CHECKED_STATUS Reset(const vector&lt;ColumnSchema&gt;&amp; cols,</a>
<a name="ln622">                       const vector&lt;ColumnId&gt;&amp; ids,</a>
<a name="ln623">                       int key_columns,</a>
<a name="ln624">                       const TableProperties&amp; table_properties = TableProperties(),</a>
<a name="ln625">                       const Uuid&amp; cotable_id = Uuid(boost::uuids::nil_uuid()),</a>
<a name="ln626">                       const PgTableOid pgtable_id = 0);</a>
<a name="ln627"> </a>
<a name="ln628">  // Return the number of bytes needed to represent a single row of this schema.</a>
<a name="ln629">  //</a>
<a name="ln630">  // This size does not include any indirected (variable length) data (eg strings)</a>
<a name="ln631">  size_t byte_size() const {</a>
<a name="ln632">    DCHECK(initialized());</a>
<a name="ln633">    return col_offsets_.back();</a>
<a name="ln634">  }</a>
<a name="ln635"> </a>
<a name="ln636">  // Return the number of bytes needed to represent</a>
<a name="ln637">  // only the key portion of this schema.</a>
<a name="ln638">  size_t key_byte_size() const {</a>
<a name="ln639">    return col_offsets_[num_key_columns_];</a>
<a name="ln640">  }</a>
<a name="ln641"> </a>
<a name="ln642">  // Return the number of columns in this schema</a>
<a name="ln643">  size_t num_columns() const {</a>
<a name="ln644">    return cols_.size();</a>
<a name="ln645">  }</a>
<a name="ln646"> </a>
<a name="ln647">  // Return the length of the key prefix in this schema.</a>
<a name="ln648">  size_t num_key_columns() const {</a>
<a name="ln649">    return num_key_columns_;</a>
<a name="ln650">  }</a>
<a name="ln651"> </a>
<a name="ln652">  // Number of hash key columns.</a>
<a name="ln653">  size_t num_hash_key_columns() const {</a>
<a name="ln654">    return num_hash_key_columns_;</a>
<a name="ln655">  }</a>
<a name="ln656"> </a>
<a name="ln657">  // Number of range key columns.</a>
<a name="ln658">  size_t num_range_key_columns() const {</a>
<a name="ln659">    return num_key_columns_ - num_hash_key_columns_;</a>
<a name="ln660">  }</a>
<a name="ln661"> </a>
<a name="ln662">  // Return the byte offset within the row for the given column index.</a>
<a name="ln663">  size_t column_offset(size_t col_idx) const {</a>
<a name="ln664">    DCHECK_LT(col_idx, cols_.size());</a>
<a name="ln665">    return col_offsets_[col_idx];</a>
<a name="ln666">  }</a>
<a name="ln667"> </a>
<a name="ln668">  // Return the ColumnSchema corresponding to the given column index.</a>
<a name="ln669">  inline const ColumnSchema &amp;column(size_t idx) const {</a>
<a name="ln670">    DCHECK_LT(idx, cols_.size());</a>
<a name="ln671">    return cols_[idx];</a>
<a name="ln672">  }</a>
<a name="ln673"> </a>
<a name="ln674">  // Return the ColumnSchema corresponding to the given column ID.</a>
<a name="ln675">  inline Result&lt;const ColumnSchema&amp;&gt; column_by_id(ColumnId id) const {</a>
<a name="ln676">    int idx = find_column_by_id(id);</a>
<a name="ln677">    if (idx &lt; 0) {</a>
<a name="ln678">      return STATUS_FORMAT(InvalidArgument, &quot;Column id $0 not found&quot;, id.ToString());</a>
<a name="ln679">    }</a>
<a name="ln680">    return cols_[idx];</a>
<a name="ln681">  }</a>
<a name="ln682"> </a>
<a name="ln683">  // Return the column ID corresponding to the given column index</a>
<a name="ln684">  ColumnId column_id(size_t idx) const {</a>
<a name="ln685">    DCHECK(has_column_ids());</a>
<a name="ln686">    DCHECK_LT(idx, cols_.size());</a>
<a name="ln687">    return col_ids_[idx];</a>
<a name="ln688">  }</a>
<a name="ln689"> </a>
<a name="ln690">  // Return true if the schema contains an ID mapping for its columns.</a>
<a name="ln691">  // In the case of an empty schema, this is false.</a>
<a name="ln692">  bool has_column_ids() const {</a>
<a name="ln693">    return !col_ids_.empty();</a>
<a name="ln694">  }</a>
<a name="ln695"> </a>
<a name="ln696">  const std::vector&lt;ColumnSchema&gt;&amp; columns() const {</a>
<a name="ln697">    return cols_;</a>
<a name="ln698">  }</a>
<a name="ln699"> </a>
<a name="ln700">  const std::vector&lt;ColumnId&gt;&amp; column_ids() const {</a>
<a name="ln701">    return col_ids_;</a>
<a name="ln702">  }</a>
<a name="ln703"> </a>
<a name="ln704">  const std::vector&lt;string&gt; column_names() const {</a>
<a name="ln705">    vector&lt;string&gt; column_names;</a>
<a name="ln706">    for (const auto&amp; col : cols_) {</a>
<a name="ln707">      column_names.push_back(col.name());</a>
<a name="ln708">    }</a>
<a name="ln709">    return column_names;</a>
<a name="ln710">  }</a>
<a name="ln711"> </a>
<a name="ln712">  const TableProperties&amp; table_properties() const {</a>
<a name="ln713">    return table_properties_;</a>
<a name="ln714">  }</a>
<a name="ln715"> </a>
<a name="ln716">  TableProperties* mutable_table_properties() {</a>
<a name="ln717">    return &amp;table_properties_;</a>
<a name="ln718">  }</a>
<a name="ln719"> </a>
<a name="ln720">  void SetDefaultTimeToLive(const uint64_t&amp; ttl_msec) {</a>
<a name="ln721">    table_properties_.SetDefaultTimeToLive(ttl_msec);</a>
<a name="ln722">  }</a>
<a name="ln723"> </a>
<a name="ln724">  void SetCopartitionTableId(const TableId&amp; copartition_table_id) {</a>
<a name="ln725">    table_properties_.SetCopartitionTableId(copartition_table_id);</a>
<a name="ln726">  }</a>
<a name="ln727"> </a>
<a name="ln728">  void SetTransactional(bool is_transactional) {</a>
<a name="ln729">    table_properties_.SetTransactional(is_transactional);</a>
<a name="ln730">  }</a>
<a name="ln731"> </a>
<a name="ln732">  void SetIsBackfilling(bool is_backfilling) { table_properties_.SetIsBackfilling(is_backfilling); }</a>
<a name="ln733"> </a>
<a name="ln734">  // Return the column index corresponding to the given column,</a>
<a name="ln735">  // or kColumnNotFound if the column is not in this schema.</a>
<a name="ln736">  int find_column(const GStringPiece col_name) const {</a>
<a name="ln737">    auto iter = name_to_index_.find(col_name);</a>
<a name="ln738">    if (PREDICT_FALSE(iter == name_to_index_.end())) {</a>
<a name="ln739">      return kColumnNotFound;</a>
<a name="ln740">    } else {</a>
<a name="ln741">      return (*iter).second;</a>
<a name="ln742">    }</a>
<a name="ln743">  }</a>
<a name="ln744"> </a>
<a name="ln745">  Result&lt;ColumnId&gt; ColumnIdByName(const std::string&amp; name) const;</a>
<a name="ln746"> </a>
<a name="ln747">  Result&lt;int&gt; ColumnIndexByName(GStringPiece col_name) const;</a>
<a name="ln748"> </a>
<a name="ln749">  // Returns true if the schema contains nullable columns</a>
<a name="ln750">  bool has_nullables() const {</a>
<a name="ln751">    return has_nullables_;</a>
<a name="ln752">  }</a>
<a name="ln753"> </a>
<a name="ln754">  // Returns true if the schema contains static columns</a>
<a name="ln755">  bool has_statics() const {</a>
<a name="ln756">    return has_statics_;</a>
<a name="ln757">  }</a>
<a name="ln758"> </a>
<a name="ln759">  // Returns true if the specified column (by index) is a key</a>
<a name="ln760">  bool is_key_column(size_t idx) const {</a>
<a name="ln761">    return idx &lt; num_key_columns_;</a>
<a name="ln762">  }</a>
<a name="ln763"> </a>
<a name="ln764">  // Returns true if the specified column (by column id) is a key</a>
<a name="ln765">  bool is_key_column(ColumnId column_id) const {</a>
<a name="ln766">    return is_key_column(find_column_by_id(column_id));</a>
<a name="ln767">  }</a>
<a name="ln768"> </a>
<a name="ln769">  // Returns true if the specified column (by name) is a key</a>
<a name="ln770">  bool is_key_column(const GStringPiece col_name) const {</a>
<a name="ln771">    return is_key_column(find_column(col_name));</a>
<a name="ln772">  }</a>
<a name="ln773"> </a>
<a name="ln774">  // Returns true if the specified column (by index) is a hash key</a>
<a name="ln775">  bool is_hash_key_column(size_t idx) const {</a>
<a name="ln776">    return idx &lt; num_hash_key_columns_;</a>
<a name="ln777">  }</a>
<a name="ln778"> </a>
<a name="ln779">  // Returns true if the specified column (by column id) is a hash key</a>
<a name="ln780">  bool is_hash_key_column(ColumnId column_id) const {</a>
<a name="ln781">    return is_hash_key_column(find_column_by_id(column_id));</a>
<a name="ln782">  }</a>
<a name="ln783"> </a>
<a name="ln784">  // Returns true if the specified column (by name) is a hash key</a>
<a name="ln785">  bool is_hash_key_column(const GStringPiece col_name) const {</a>
<a name="ln786">    return is_hash_key_column(find_column(col_name));</a>
<a name="ln787">  }</a>
<a name="ln788"> </a>
<a name="ln789">  // Returns true if the specified column (by index) is a range column</a>
<a name="ln790">  bool is_range_column(size_t idx) const {</a>
<a name="ln791">    return is_key_column(idx) &amp;&amp; !is_hash_key_column(idx);</a>
<a name="ln792">  }</a>
<a name="ln793"> </a>
<a name="ln794">  // Returns true if the specified column (by column id) is a range column</a>
<a name="ln795">  bool is_range_column(ColumnId column_id) const {</a>
<a name="ln796">    return is_range_column(find_column_by_id(column_id));</a>
<a name="ln797">  }</a>
<a name="ln798"> </a>
<a name="ln799">  // Returns true if the specified column (by name) is a range column</a>
<a name="ln800">  bool is_range_column(const GStringPiece col_name) const {</a>
<a name="ln801">    return is_range_column(find_column(col_name));</a>
<a name="ln802">  }</a>
<a name="ln803"> </a>
<a name="ln804">  // Return true if this Schema is initialized and valid.</a>
<a name="ln805">  bool initialized() const {</a>
<a name="ln806">    return !col_offsets_.empty();</a>
<a name="ln807">  }</a>
<a name="ln808"> </a>
<a name="ln809">  // Returns the highest column id in this Schema.</a>
<a name="ln810">  ColumnId max_col_id() const {</a>
<a name="ln811">    return max_col_id_;</a>
<a name="ln812">  }</a>
<a name="ln813"> </a>
<a name="ln814">  // Gets and sets the uuid of the non-primary table this schema belongs to co-located in a tablet.</a>
<a name="ln815">  const Uuid&amp; cotable_id() const {</a>
<a name="ln816">    return cotable_id_;</a>
<a name="ln817">  }</a>
<a name="ln818"> </a>
<a name="ln819">  bool has_cotable_id() const {</a>
<a name="ln820">    return !cotable_id_.IsNil();</a>
<a name="ln821">  }</a>
<a name="ln822"> </a>
<a name="ln823">  void set_cotable_id(const Uuid&amp; cotable_id) {</a>
<a name="ln824">    if (!cotable_id.IsNil()) {</a>
<a name="ln825">      DCHECK_EQ(pgtable_id_, 0);</a>
<a name="ln826">    }</a>
<a name="ln827">    cotable_id_ = cotable_id;</a>
<a name="ln828">  }</a>
<a name="ln829"> </a>
<a name="ln830">  // Gets and sets the PG table OID of the non-primary table this schema belongs to in a tablet</a>
<a name="ln831">  // with colocated tables.</a>
<a name="ln832">  const PgTableOid pgtable_id() const {</a>
<a name="ln833">    return pgtable_id_;</a>
<a name="ln834">  }</a>
<a name="ln835"> </a>
<a name="ln836">  bool has_pgtable_id() const {</a>
<a name="ln837">    return pgtable_id_ &gt; 0;</a>
<a name="ln838">  }</a>
<a name="ln839"> </a>
<a name="ln840">  void set_pgtable_id(const PgTableOid pgtable_id) {</a>
<a name="ln841">    if (pgtable_id &gt; 0) {</a>
<a name="ln842">      DCHECK(cotable_id_.IsNil());</a>
<a name="ln843">    }</a>
<a name="ln844">    pgtable_id_ = pgtable_id;</a>
<a name="ln845">  }</a>
<a name="ln846"> </a>
<a name="ln847">  // Extract a given column from a row where the type is</a>
<a name="ln848">  // known at compile-time. The type is checked with a debug</a>
<a name="ln849">  // assertion -- but if the wrong type is used and these assertions</a>
<a name="ln850">  // are off, incorrect data may result.</a>
<a name="ln851">  //</a>
<a name="ln852">  // This is mostly useful for tests at this point.</a>
<a name="ln853">  // TODO: consider removing it.</a>
<a name="ln854">  template&lt;DataType Type, class RowType&gt;</a>
<a name="ln855">  const typename DataTypeTraits&lt;Type&gt;::cpp_type *</a>
<a name="ln856">  ExtractColumnFromRow(const RowType&amp; row, size_t idx) const {</a>
<a name="ln857">    DCHECK_SCHEMA_EQ(*this, *row.schema());</a>
<a name="ln858">    const ColumnSchema&amp; col_schema = cols_[idx];</a>
<a name="ln859">    DCHECK_LT(idx, cols_.size());</a>
<a name="ln860">    DCHECK_EQ(col_schema.type_info()-&gt;type(), Type);</a>
<a name="ln861"> </a>
<a name="ln862">    const void *val;</a>
<a name="ln863">    if (col_schema.is_nullable()) {</a>
<a name="ln864">      val = row.nullable_cell_ptr(idx);</a>
<a name="ln865">    } else {</a>
<a name="ln866">      val = row.cell_ptr(idx);</a>
<a name="ln867">    }</a>
<a name="ln868"> </a>
<a name="ln869">    return reinterpret_cast&lt;const typename DataTypeTraits&lt;Type&gt;::cpp_type *&gt;(val);</a>
<a name="ln870">  }</a>
<a name="ln871"> </a>
<a name="ln872">  // Stringify the given row, which conforms to this schema,</a>
<a name="ln873">  // in a way suitable for debugging. This isn't currently optimized</a>
<a name="ln874">  // so should be avoided in hot paths.</a>
<a name="ln875">  template&lt;class RowType&gt;</a>
<a name="ln876">  std::string DebugRow(const RowType&amp; row) const {</a>
<a name="ln877">    DCHECK_SCHEMA_EQ(*this, *row.schema());</a>
<a name="ln878">    return DebugRowColumns(row, num_columns());</a>
<a name="ln879">  }</a>
<a name="ln880"> </a>
<a name="ln881">  // Stringify the given row, which must have a schema which is</a>
<a name="ln882">  // key-compatible with this one. Per above, this is not for use in</a>
<a name="ln883">  // hot paths.</a>
<a name="ln884">  template&lt;class RowType&gt;</a>
<a name="ln885">  std::string DebugRowKey(const RowType&amp; row) const {</a>
<a name="ln886">    DCHECK_KEY_PROJECTION_SCHEMA_EQ(*this, *row.schema());</a>
<a name="ln887">    return DebugRowColumns(row, num_key_columns());</a>
<a name="ln888">  }</a>
<a name="ln889"> </a>
<a name="ln890">  // Decode the specified encoded key into the given 'buffer', which</a>
<a name="ln891">  // must be at least as large as this-&gt;key_byte_size().</a>
<a name="ln892">  //</a>
<a name="ln893">  // 'arena' is used for allocating indirect strings, but is unused</a>
<a name="ln894">  // for other datatypes.</a>
<a name="ln895">  CHECKED_STATUS DecodeRowKey(Slice encoded_key, uint8_t* buffer,</a>
<a name="ln896">                      Arena* arena) const WARN_UNUSED_RESULT;</a>
<a name="ln897"> </a>
<a name="ln898">  // Decode and stringify the given contiguous encoded row key in</a>
<a name="ln899">  // order to, e.g., provide print human-readable information about a</a>
<a name="ln900">  // tablet's start and end keys.</a>
<a name="ln901">  //</a>
<a name="ln902">  // If the encoded key is empty then '&lt;start of table&gt;' or '&lt;end of table&gt;'</a>
<a name="ln903">  // will be returned based on the value of 'start_or_end'.</a>
<a name="ln904">  //</a>
<a name="ln905">  // See also: DebugRowKey, DecodeRowKey.</a>
<a name="ln906">  enum StartOrEnd {</a>
<a name="ln907">    START_KEY,</a>
<a name="ln908">    END_KEY</a>
<a name="ln909">  };</a>
<a name="ln910">  std::string DebugEncodedRowKey(Slice encoded_key, StartOrEnd start_or_end) const;</a>
<a name="ln911"> </a>
<a name="ln912">  // Compare two rows of this schema.</a>
<a name="ln913">  template&lt;class RowTypeA, class RowTypeB&gt;</a>
<a name="ln914">  int Compare(const RowTypeA&amp; lhs, const RowTypeB&amp; rhs) const {</a>
<a name="ln915">    DCHECK(KeyEquals(*lhs.schema()) &amp;&amp; KeyEquals(*rhs.schema()));</a>
<a name="ln916"> </a>
<a name="ln917">    for (size_t col = 0; col &lt; num_key_columns_; col++) {</a>
<a name="ln918">      int col_compare = column(col).Compare(lhs.cell_ptr(col), rhs.cell_ptr(col));</a>
<a name="ln919">      if (col_compare != 0) {</a>
<a name="ln920">        return col_compare;</a>
<a name="ln921">      }</a>
<a name="ln922">    }</a>
<a name="ln923">    return 0;</a>
<a name="ln924">  }</a>
<a name="ln925"> </a>
<a name="ln926">  // Return the projection of this schema which contains only</a>
<a name="ln927">  // the key columns.</a>
<a name="ln928">  // TODO: this should take a Schema* out-parameter to avoid an</a>
<a name="ln929">  // extra copy of the ColumnSchemas.</a>
<a name="ln930">  // TODO this should probably be cached since the key projection</a>
<a name="ln931">  // is not supposed to change, for a single schema.</a>
<a name="ln932">  Schema CreateKeyProjection() const {</a>
<a name="ln933">    vector&lt;ColumnSchema&gt; key_cols(cols_.begin(),</a>
<a name="ln934">                                  cols_.begin() + num_key_columns_);</a>
<a name="ln935">    vector&lt;ColumnId&gt; col_ids;</a>
<a name="ln936">    if (!col_ids_.empty()) {</a>
<a name="ln937">      col_ids.assign(col_ids_.begin(), col_ids_.begin() + num_key_columns_);</a>
<a name="ln938">    }</a>
<a name="ln939"> </a>
<a name="ln940">    return Schema(key_cols, col_ids, num_key_columns_);</a>
<a name="ln941">  }</a>
<a name="ln942"> </a>
<a name="ln943">  // Return a new Schema which is the same as this one, but with IDs assigned.</a>
<a name="ln944">  // Requires that this schema has no column IDs.</a>
<a name="ln945">  Schema CopyWithColumnIds() const;</a>
<a name="ln946"> </a>
<a name="ln947">  // Return a new Schema which is the same as this one, but without any column</a>
<a name="ln948">  // IDs assigned.</a>
<a name="ln949">  //</a>
<a name="ln950">  // Requires that this schema has column IDs.</a>
<a name="ln951">  Schema CopyWithoutColumnIds() const;</a>
<a name="ln952"> </a>
<a name="ln953">  // Create a new schema containing only the selected columns.</a>
<a name="ln954">  // The resulting schema will have no key columns defined.</a>
<a name="ln955">  // If this schema has IDs, the resulting schema will as well.</a>
<a name="ln956">  CHECKED_STATUS CreateProjectionByNames(const std::vector&lt;GStringPiece&gt;&amp; col_names,</a>
<a name="ln957">                                         Schema* out, size_t num_key_columns = 0) const;</a>
<a name="ln958"> </a>
<a name="ln959">  // Create a new schema containing only the selected column IDs.</a>
<a name="ln960">  //</a>
<a name="ln961">  // If any column IDs are invalid, then they will be ignored and the</a>
<a name="ln962">  // result will have fewer columns than requested.</a>
<a name="ln963">  //</a>
<a name="ln964">  // The resulting schema will have no key columns defined.</a>
<a name="ln965">  CHECKED_STATUS CreateProjectionByIdsIgnoreMissing(const std::vector&lt;ColumnId&gt;&amp; col_ids,</a>
<a name="ln966">                                                    Schema* out) const;</a>
<a name="ln967"> </a>
<a name="ln968">  // Encode the key portion of the given row into a buffer</a>
<a name="ln969">  // such that the buffer's lexicographic comparison represents</a>
<a name="ln970">  // the proper comparison order of the underlying types.</a>
<a name="ln971">  //</a>
<a name="ln972">  // The key is encoded into the given buffer, replacing its current</a>
<a name="ln973">  // contents.</a>
<a name="ln974">  // Returns the encoded key.</a>
<a name="ln975">  template &lt;class RowType&gt;</a>
<a name="ln976">  Slice EncodeComparableKey(const RowType&amp; row, faststring *dst) const {</a>
<a name="ln977">    DCHECK_KEY_PROJECTION_SCHEMA_EQ(*this, *row.schema());</a>
<a name="ln978"> </a>
<a name="ln979">    dst-&gt;clear();</a>
<a name="ln980">    for (size_t i = 0; i &lt; num_key_columns_; i++) {</a>
<a name="ln981">      DCHECK(!cols_[i].is_nullable());</a>
<a name="ln982">      const TypeInfo* ti = cols_[i].type_info();</a>
<a name="ln983">      bool is_last = i == num_key_columns_ - 1;</a>
<a name="ln984">      GetKeyEncoder&lt;faststring&gt;(ti).Encode(row.cell_ptr(i), is_last, dst);</a>
<a name="ln985">    }</a>
<a name="ln986">    return Slice(*dst);</a>
<a name="ln987">  }</a>
<a name="ln988"> </a>
<a name="ln989">  // Stringify this Schema. This is not particularly efficient,</a>
<a name="ln990">  // so should only be used when necessary for output.</a>
<a name="ln991">  std::string ToString() const;</a>
<a name="ln992"> </a>
<a name="ln993">  // Return true if the schemas have exactly the same set of columns</a>
<a name="ln994">  // and respective types, and the same table properties.</a>
<a name="ln995">  bool Equals(const Schema &amp;other) const {</a>
<a name="ln996">    if (this == &amp;other) return true;</a>
<a name="ln997">    if (this-&gt;num_key_columns_ != other.num_key_columns_) return false;</a>
<a name="ln998">    if (this-&gt;table_properties_ != other.table_properties_) return false;</a>
<a name="ln999">    if (this-&gt;cols_.size() != other.cols_.size()) return false;</a>
<a name="ln1000"> </a>
<a name="ln1001">    for (size_t i = 0; i &lt; other.cols_.size(); i++) {</a>
<a name="ln1002">      if (!this-&gt;cols_[i].Equals(other.cols_[i])) return false;</a>
<a name="ln1003">    }</a>
<a name="ln1004"> </a>
<a name="ln1005">    return true;</a>
<a name="ln1006">  }</a>
<a name="ln1007"> </a>
<a name="ln1008">  // Return true if the schemas have exactly the same set of columns</a>
<a name="ln1009">  // and respective types, and equivalent properties.</a>
<a name="ln1010">  // For example, one table property could have a different properties like wal_retention_secs_</a>
<a name="ln1011">  // is_backfilling_ but still be equivalent.</a>
<a name="ln1012">  bool EquivalentForDataCopy(const Schema&amp; other) const {</a>
<a name="ln1013">    if (this == &amp;other) return true;</a>
<a name="ln1014">    if (this-&gt;num_key_columns_ != other.num_key_columns_) return false;</a>
<a name="ln1015">    if (!this-&gt;table_properties_.Equivalent(other.table_properties_)) return false;</a>
<a name="ln1016">    if (this-&gt;cols_.size() != other.cols_.size()) return false;</a>
<a name="ln1017"> </a>
<a name="ln1018">    for (size_t i = 0; i &lt; other.cols_.size(); i++) {</a>
<a name="ln1019">      if (!this-&gt;cols_[i].Equals(other.cols_[i])) return false;</a>
<a name="ln1020">    }</a>
<a name="ln1021"> </a>
<a name="ln1022">    return true;</a>
<a name="ln1023">  }</a>
<a name="ln1024"> </a>
<a name="ln1025">  // Return true if the key projection schemas have exactly the same set of</a>
<a name="ln1026">  // columns and respective types. Doesn't check column names.</a>
<a name="ln1027">  bool KeyEquals(const Schema&amp; other) const {</a>
<a name="ln1028">    if (this-&gt;num_key_columns_ != other.num_key_columns_) return false;</a>
<a name="ln1029">    for (size_t i = 0; i &lt; this-&gt;num_key_columns_; i++) {</a>
<a name="ln1030">      if (!this-&gt;cols_[i].EqualsType(other.cols_[i])) return false;</a>
<a name="ln1031">    }</a>
<a name="ln1032">    return true;</a>
<a name="ln1033">  }</a>
<a name="ln1034"> </a>
<a name="ln1035">  // Return a non-OK status if the project is not compatible with the current schema</a>
<a name="ln1036">  // - User columns non present in the tablet are considered errors</a>
<a name="ln1037">  // - Matching columns with different types, at the moment, are considered errors</a>
<a name="ln1038">  CHECKED_STATUS VerifyProjectionCompatibility(const Schema&amp; projection) const;</a>
<a name="ln1039"> </a>
<a name="ln1040">  // Returns the projection schema mapped on the current one</a>
<a name="ln1041">  // If the project is invalid, return a non-OK status.</a>
<a name="ln1042">  CHECKED_STATUS GetMappedReadProjection(const Schema&amp; projection,</a>
<a name="ln1043">                                 Schema *mapped_projection) const;</a>
<a name="ln1044"> </a>
<a name="ln1045">  // Loops through this schema (the projection) and calls the projector methods once for</a>
<a name="ln1046">  // each column.</a>
<a name="ln1047">  //</a>
<a name="ln1048">  // - CHECKED_STATUS ProjectBaseColumn(size_t proj_col_idx, size_t base_col_idx)</a>
<a name="ln1049">  //</a>
<a name="ln1050">  //     Called if the column in this schema matches one of the columns in 'base_schema'.</a>
<a name="ln1051">  //     The column type must match exactly.</a>
<a name="ln1052">  //</a>
<a name="ln1053">  // - CHECKED_STATUS ProjectDefaultColumn(size_t proj_idx)</a>
<a name="ln1054">  //</a>
<a name="ln1055">  //     Called if the column in this schema does not match any column in 'base_schema',</a>
<a name="ln1056">  //     but has a default or is nullable.</a>
<a name="ln1057">  //</a>
<a name="ln1058">  // - CHECKED_STATUS ProjectExtraColumn(size_t proj_idx, const ColumnSchema&amp; col)</a>
<a name="ln1059">  //</a>
<a name="ln1060">  //     Called if the column in this schema does not match any column in 'base_schema',</a>
<a name="ln1061">  //     and does not have a default, and is not nullable.</a>
<a name="ln1062">  //</a>
<a name="ln1063">  // If both schemas have column IDs, then the matching is done by ID. Otherwise, it is</a>
<a name="ln1064">  // done by name.</a>
<a name="ln1065">  //</a>
<a name="ln1066">  // TODO(MAYBE): Pass the ColumnSchema and not only the column index?</a>
<a name="ln1067">  template &lt;class Projector&gt;</a>
<a name="ln1068">  CHECKED_STATUS GetProjectionMapping(const Schema&amp; base_schema, Projector *projector) const {</a>
<a name="ln1069">    const bool use_column_ids = base_schema.has_column_ids() &amp;&amp; has_column_ids();</a>
<a name="ln1070"> </a>
<a name="ln1071">    int proj_idx = 0;</a>
<a name="ln1072">    for (int i = 0; i &lt; cols_.size(); ++i) {</a>
<a name="ln1073">      const ColumnSchema&amp; col_schema = cols_[i];</a>
<a name="ln1074"> </a>
<a name="ln1075">      // try to lookup the column by ID if present or just by name.</a>
<a name="ln1076">      // Unit tests and Iter-Projections are probably always using the</a>
<a name="ln1077">      // lookup by name. The IDs are generally set by the server on AlterTable().</a>
<a name="ln1078">      int base_idx;</a>
<a name="ln1079">      if (use_column_ids) {</a>
<a name="ln1080">        base_idx = base_schema.find_column_by_id(col_ids_[i]);</a>
<a name="ln1081">      } else {</a>
<a name="ln1082">        base_idx = base_schema.find_column(col_schema.name());</a>
<a name="ln1083">      }</a>
<a name="ln1084"> </a>
<a name="ln1085">      if (base_idx &gt;= 0) {</a>
<a name="ln1086">        const ColumnSchema&amp; base_col_schema = base_schema.column(base_idx);</a>
<a name="ln1087">        // Column present in the Base Schema...</a>
<a name="ln1088">        if (!col_schema.EqualsType(base_col_schema)) {</a>
<a name="ln1089">          // ...but with a different type, (TODO: try with an adaptor)</a>
<a name="ln1090">          return STATUS(InvalidArgument, &quot;The column '&quot; + col_schema.name() +</a>
<a name="ln1091">                                         &quot;' must have type &quot; +</a>
<a name="ln1092">                                         base_col_schema.TypeToString() +</a>
<a name="ln1093">                                         &quot; found &quot; + col_schema.TypeToString());</a>
<a name="ln1094">        } else {</a>
<a name="ln1095">          RETURN_NOT_OK(projector-&gt;ProjectBaseColumn(proj_idx, base_idx));</a>
<a name="ln1096">        }</a>
<a name="ln1097">      } else {</a>
<a name="ln1098">        if (!col_schema.is_nullable()) {</a>
<a name="ln1099">          RETURN_NOT_OK(projector-&gt;ProjectExtraColumn(proj_idx));</a>
<a name="ln1100">        }</a>
<a name="ln1101">      }</a>
<a name="ln1102">      proj_idx++;</a>
<a name="ln1103">    }</a>
<a name="ln1104">    return Status::OK();</a>
<a name="ln1105">  }</a>
<a name="ln1106"> </a>
<a name="ln1107">  // Returns the column index given the column ID.</a>
<a name="ln1108">  // If no such column exists, returns kColumnNotFound.</a>
<a name="ln1109">  int find_column_by_id(ColumnId id) const {</a>
<a name="ln1110">    DCHECK(cols_.empty() || has_column_ids());</a>
<a name="ln1111">    int ret = id_to_index_[id];</a>
<a name="ln1112">    if (ret == -1) {</a>
<a name="ln1113">      return kColumnNotFound;</a>
<a name="ln1114">    }</a>
<a name="ln1115">    return ret;</a>
<a name="ln1116">  }</a>
<a name="ln1117"> </a>
<a name="ln1118">  // Returns the memory usage of this object without the object itself. Should</a>
<a name="ln1119">  // be used when embedded inside another object.</a>
<a name="ln1120">  size_t memory_footprint_excluding_this() const;</a>
<a name="ln1121"> </a>
<a name="ln1122">  // Returns the memory usage of this object including the object itself.</a>
<a name="ln1123">  // Should be used when allocated on the heap.</a>
<a name="ln1124">  size_t memory_footprint_including_this() const;</a>
<a name="ln1125"> </a>
<a name="ln1126">  static ColumnId first_column_id();</a>
<a name="ln1127"> </a>
<a name="ln1128"> private:</a>
<a name="ln1129"> </a>
<a name="ln1130">  // Return a stringified version of the first 'num_columns' columns of the</a>
<a name="ln1131">  // row.</a>
<a name="ln1132">  template&lt;class RowType&gt;</a>
<a name="ln1133">  std::string DebugRowColumns(const RowType&amp; row, int num_columns) const {</a>
<a name="ln1134">    std::string ret;</a>
<a name="ln1135">    ret.append(&quot;(&quot;);</a>
<a name="ln1136"> </a>
<a name="ln1137">    for (size_t col_idx = 0; col_idx &lt; num_columns; col_idx++) {</a>
<a name="ln1138">      if (col_idx &gt; 0) {</a>
<a name="ln1139">        ret.append(&quot;, &quot;);</a>
<a name="ln1140">      }</a>
<a name="ln1141">      const ColumnSchema&amp; col = cols_[col_idx];</a>
<a name="ln1142">      col.DebugCellAppend(row.cell(col_idx), &amp;ret);</a>
<a name="ln1143">    }</a>
<a name="ln1144">    ret.append(&quot;)&quot;);</a>
<a name="ln1145">    return ret;</a>
<a name="ln1146">  }</a>
<a name="ln1147"> </a>
<a name="ln1148">  friend class SchemaBuilder;</a>
<a name="ln1149"> </a>
<a name="ln1150">  vector&lt;ColumnSchema&gt; cols_;</a>
<a name="ln1151">  size_t num_key_columns_;</a>
<a name="ln1152">  size_t num_hash_key_columns_;</a>
<a name="ln1153">  ColumnId max_col_id_;</a>
<a name="ln1154">  vector&lt;ColumnId&gt; col_ids_;</a>
<a name="ln1155">  vector&lt;size_t&gt; col_offsets_;</a>
<a name="ln1156"> </a>
<a name="ln1157">  // The keys of this map are GStringPiece references to the actual name members of the</a>
<a name="ln1158">  // ColumnSchema objects inside cols_. This avoids an extra copy of those strings,</a>
<a name="ln1159">  // and also allows us to do lookups on the map using GStringPiece keys, sometimes</a>
<a name="ln1160">  // avoiding copies.</a>
<a name="ln1161">  //</a>
<a name="ln1162">  // The map is instrumented with a counting allocator so that we can accurately</a>
<a name="ln1163">  // measure its memory footprint.</a>
<a name="ln1164">  int64_t name_to_index_bytes_;</a>
<a name="ln1165">  typedef STLCountingAllocator&lt;std::pair&lt;const GStringPiece, size_t&gt; &gt; NameToIndexMapAllocator;</a>
<a name="ln1166">  typedef unordered_map&lt;</a>
<a name="ln1167">      GStringPiece,</a>
<a name="ln1168">      size_t,</a>
<a name="ln1169">      std::hash&lt;GStringPiece&gt;,</a>
<a name="ln1170">      std::equal_to&lt;GStringPiece&gt;,</a>
<a name="ln1171">      NameToIndexMapAllocator&gt; NameToIndexMap;</a>
<a name="ln1172">  NameToIndexMap name_to_index_;</a>
<a name="ln1173"> </a>
<a name="ln1174">  IdMapping id_to_index_;</a>
<a name="ln1175"> </a>
<a name="ln1176">  // Cached indicator whether any columns are nullable.</a>
<a name="ln1177">  bool has_nullables_;</a>
<a name="ln1178"> </a>
<a name="ln1179">  // Cached indicator whether any columns are static.</a>
<a name="ln1180">  bool has_statics_ = false;</a>
<a name="ln1181"> </a>
<a name="ln1182">  TableProperties table_properties_;</a>
<a name="ln1183"> </a>
<a name="ln1184">  // Uuid of the non-primary table this schema belongs to co-located in a tablet. Nil for the</a>
<a name="ln1185">  // primary or single-tenant table.</a>
<a name="ln1186">  Uuid cotable_id_;</a>
<a name="ln1187"> </a>
<a name="ln1188">  // PG table OID of the non-primary table this schema belongs to in a tablet with colocated</a>
<a name="ln1189">  // tables. Nil for the primary or single-tenant table.</a>
<a name="ln1190">  PgTableOid pgtable_id_;</a>
<a name="ln1191"> </a>
<a name="ln1192">  // NOTE: if you add more members, make sure to add the appropriate</a>
<a name="ln1193">  // code to swap() and CopyFrom() as well to prevent subtle bugs.</a>
<a name="ln1194">};</a>
<a name="ln1195"> </a>
<a name="ln1196">// Helper used for schema creation/editing.</a>
<a name="ln1197">//</a>
<a name="ln1198">// Example:</a>
<a name="ln1199">//   Status s;</a>
<a name="ln1200">//   SchemaBuilder builder(base_schema);</a>
<a name="ln1201">//   s = builder.RemoveColumn(&quot;value&quot;);</a>
<a name="ln1202">//   s = builder.AddKeyColumn(&quot;key2&quot;, STRING);</a>
<a name="ln1203">//   s = builder.AddColumn(&quot;new_c1&quot;, UINT32);</a>
<a name="ln1204">//   ...</a>
<a name="ln1205">//   Schema new_schema = builder.Build();</a>
<a name="ln1206">//</a>
<a name="ln1207">// TODO(neil): Must introduce hash_key in this builder. Currently, only YBSchemaBuilder support</a>
<a name="ln1208">// hash key, and YBSchemaBuilder don't use this builder.</a>
<a name="ln1209">class SchemaBuilder {</a>
<a name="ln1210"> public:</a>
<a name="ln1211">  SchemaBuilder() { Reset(); }</a>
<a name="ln1212">  explicit SchemaBuilder(const Schema&amp; schema) { Reset(schema); }</a>
<a name="ln1213"> </a>
<a name="ln1214">  void Reset();</a>
<a name="ln1215">  void Reset(const Schema&amp; schema);</a>
<a name="ln1216"> </a>
<a name="ln1217">  bool is_valid() const { return cols_.size() &gt; 0; }</a>
<a name="ln1218"> </a>
<a name="ln1219">  // Set the next column ID to be assigned to columns added with</a>
<a name="ln1220">  // AddColumn.</a>
<a name="ln1221">  void set_next_column_id(ColumnId next_id) {</a>
<a name="ln1222">    DCHECK_GE(next_id, ColumnId(0));</a>
<a name="ln1223">    next_id_ = next_id;</a>
<a name="ln1224">  }</a>
<a name="ln1225"> </a>
<a name="ln1226">  // Return the next column ID that would be assigned with AddColumn.</a>
<a name="ln1227">  ColumnId next_column_id() const {</a>
<a name="ln1228">    return next_id_;</a>
<a name="ln1229">  }</a>
<a name="ln1230"> </a>
<a name="ln1231">  void set_pgtable_id(PgTableOid pgtable_id) {</a>
<a name="ln1232">    pgtable_id_ = pgtable_id;</a>
<a name="ln1233">  }</a>
<a name="ln1234"> </a>
<a name="ln1235">  PgTableOid pgtable_id() const {</a>
<a name="ln1236">    return pgtable_id_;</a>
<a name="ln1237">  }</a>
<a name="ln1238"> </a>
<a name="ln1239">  void set_cotable_id(Uuid cotable_id) {</a>
<a name="ln1240">    cotable_id_ = cotable_id;</a>
<a name="ln1241">  }</a>
<a name="ln1242"> </a>
<a name="ln1243">  Uuid cotable_id() const {</a>
<a name="ln1244">    return cotable_id_;</a>
<a name="ln1245">  }</a>
<a name="ln1246"> </a>
<a name="ln1247">  Schema Build() const {</a>
<a name="ln1248">    return Schema(cols_, col_ids_, num_key_columns_, table_properties_, cotable_id_, pgtable_id_);</a>
<a name="ln1249">  }</a>
<a name="ln1250">  Schema BuildWithoutIds() const {</a>
<a name="ln1251">    return Schema(cols_, num_key_columns_, table_properties_, cotable_id_,  pgtable_id_);</a>
<a name="ln1252">  }</a>
<a name="ln1253"> </a>
<a name="ln1254">  // assumes type is allowed in primary key -- this should be checked before getting here</a>
<a name="ln1255">  // using DataType (not QLType) since primary key columns only support elementary types</a>
<a name="ln1256">  CHECKED_STATUS AddKeyColumn(const std::string&amp; name, const std::shared_ptr&lt;QLType&gt;&amp; type);</a>
<a name="ln1257">  CHECKED_STATUS AddKeyColumn(const std::string&amp; name, DataType type);</a>
<a name="ln1258"> </a>
<a name="ln1259">  // assumes type is allowed in hash key -- this should be checked before getting here</a>
<a name="ln1260">  // using DataType (not QLType) since hash key columns only support elementary types</a>
<a name="ln1261">  CHECKED_STATUS AddHashKeyColumn(const std::string&amp; name, const std::shared_ptr&lt;QLType&gt;&amp; type);</a>
<a name="ln1262">  CHECKED_STATUS AddHashKeyColumn(const std::string&amp; name, DataType type);</a>
<a name="ln1263"> </a>
<a name="ln1264">  CHECKED_STATUS AddColumn(const ColumnSchema&amp; column, bool is_key);</a>
<a name="ln1265"> </a>
<a name="ln1266">  CHECKED_STATUS AddColumn(const std::string&amp; name, const std::shared_ptr&lt;QLType&gt;&amp; type) {</a>
<a name="ln1267">    return AddColumn(name, type, false, false, false, false, 0,</a>
<a name="ln1268">                     ColumnSchema::SortingType::kNotSpecified);</a>
<a name="ln1269">  }</a>
<a name="ln1270"> </a>
<a name="ln1271">  // convenience function for adding columns with simple (non-parametric) data types</a>
<a name="ln1272">  CHECKED_STATUS AddColumn(const std::string&amp; name, DataType type) {</a>
<a name="ln1273">    return AddColumn(name, QLType::Create(type));</a>
<a name="ln1274">  }</a>
<a name="ln1275"> </a>
<a name="ln1276">  CHECKED_STATUS AddNullableColumn(const std::string&amp; name, const std::shared_ptr&lt;QLType&gt;&amp; type) {</a>
<a name="ln1277">    return AddColumn(name, type, true, false, false, false, 0,</a>
<a name="ln1278">                     ColumnSchema::SortingType::kNotSpecified);</a>
<a name="ln1279">  }</a>
<a name="ln1280"> </a>
<a name="ln1281">  // convenience function for adding columns with simple (non-parametric) data types</a>
<a name="ln1282">  CHECKED_STATUS AddNullableColumn(const std::string&amp; name, DataType type) {</a>
<a name="ln1283">    return AddNullableColumn(name, QLType::Create(type));</a>
<a name="ln1284">  }</a>
<a name="ln1285"> </a>
<a name="ln1286">  CHECKED_STATUS AddColumn(const std::string&amp; name,</a>
<a name="ln1287">                           const std::shared_ptr&lt;QLType&gt;&amp; type,</a>
<a name="ln1288">                           bool is_nullable,</a>
<a name="ln1289">                           bool is_hash_key,</a>
<a name="ln1290">                           bool is_static,</a>
<a name="ln1291">                           bool is_counter,</a>
<a name="ln1292">                           int32_t order,</a>
<a name="ln1293">                           yb::ColumnSchema::SortingType sorting_type);</a>
<a name="ln1294"> </a>
<a name="ln1295">  // convenience function for adding columns with simple (non-parametric) data types</a>
<a name="ln1296">  CHECKED_STATUS AddColumn(const std::string&amp; name,</a>
<a name="ln1297">                           DataType type,</a>
<a name="ln1298">                           bool is_nullable,</a>
<a name="ln1299">                           bool is_hash_key,</a>
<a name="ln1300">                           bool is_static,</a>
<a name="ln1301">                           bool is_counter,</a>
<a name="ln1302">                           int32_t order,</a>
<a name="ln1303">                           yb::ColumnSchema::SortingType sorting_type) {</a>
<a name="ln1304">    return AddColumn(name, QLType::Create(type), is_nullable, is_hash_key, is_static, is_counter,</a>
<a name="ln1305">                     order, sorting_type);</a>
<a name="ln1306">  }</a>
<a name="ln1307"> </a>
<a name="ln1308">  CHECKED_STATUS RemoveColumn(const std::string&amp; name);</a>
<a name="ln1309">  CHECKED_STATUS RenameColumn(const std::string&amp; old_name, const std::string&amp; new_name);</a>
<a name="ln1310">  CHECKED_STATUS AlterProperties(const TablePropertiesPB&amp; pb);</a>
<a name="ln1311"> </a>
<a name="ln1312"> private:</a>
<a name="ln1313"> </a>
<a name="ln1314">  ColumnId next_id_;</a>
<a name="ln1315">  vector&lt;ColumnId&gt; col_ids_;</a>
<a name="ln1316">  vector&lt;ColumnSchema&gt; cols_;</a>
<a name="ln1317">  unordered_set&lt;string&gt; col_names_;</a>
<a name="ln1318">  size_t num_key_columns_;</a>
<a name="ln1319">  TableProperties table_properties_;</a>
<a name="ln1320">  PgTableOid pgtable_id_ = 0;</a>
<a name="ln1321">  Uuid cotable_id_ = Uuid(boost::uuids::nil_uuid());</a>
<a name="ln1322"> </a>
<a name="ln1323">  DISALLOW_COPY_AND_ASSIGN(SchemaBuilder);</a>
<a name="ln1324">};</a>
<a name="ln1325">} // namespace yb</a>
<a name="ln1326"> </a>
<a name="ln1327">// Specialize std::hash for ColumnId</a>
<a name="ln1328">namespace std {</a>
<a name="ln1329">template&lt;&gt;</a>
<a name="ln1330">struct hash&lt;yb::ColumnId&gt; {</a>
<a name="ln1331">  int operator()(const yb::ColumnId&amp; col_id) const {</a>
<a name="ln1332">    return col_id;</a>
<a name="ln1333">  }</a>
<a name="ln1334">};</a>
<a name="ln1335">} // namespace std</a>
<a name="ln1336"> </a>
<a name="ln1337">#endif  // YB_COMMON_SCHEMA_H</a>

</code></pre>
<div class="balloon" rel="583"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="604"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="632"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="685"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="842"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="857"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="877"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="886"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="915"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="977"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="981"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1110"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
