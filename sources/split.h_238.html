
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>split.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Copyright 2008 and onwards Google, Inc.</a>
<a name="ln2">//</a>
<a name="ln3">// #status: RECOMMENDED</a>
<a name="ln4">// #category: operations on strings</a>
<a name="ln5">// #summary: Functions for splitting strings into substrings.</a>
<a name="ln6">//</a>
<a name="ln7">// This file contains functions for splitting strings. The new and recommended</a>
<a name="ln8">// API for string splitting is the strings::Split() function. The old API is a</a>
<a name="ln9">// large collection of standalone functions declared at the bottom of this file</a>
<a name="ln10">// in the global scope.</a>
<a name="ln11">//</a>
<a name="ln12">// TODO(user): Rough migration plan from old API to new API</a>
<a name="ln13">// (1) Add comments to old Split*() functions showing how to do the same things</a>
<a name="ln14">//     with the new API.</a>
<a name="ln15">// (2) Reimplement some of the old Split*() functions in terms of the new</a>
<a name="ln16">//     Split() API. This will allow deletion of code in split.cc.</a>
<a name="ln17">// (3) (Optional) Replace old Split*() API calls at call sites with calls to new</a>
<a name="ln18">//     Split() API.</a>
<a name="ln19">//</a>
<a name="ln20">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln21">//</a>
<a name="ln22">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln23">//</a>
<a name="ln24">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln25">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln26">//</a>
<a name="ln27">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln28">//</a>
<a name="ln29">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln30">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln31">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln32">// under the License.</a>
<a name="ln33">//</a>
<a name="ln34">#ifndef STRINGS_SPLIT_H_</a>
<a name="ln35">#define STRINGS_SPLIT_H_</a>
<a name="ln36"> </a>
<a name="ln37">#include &lt;stddef.h&gt;</a>
<a name="ln38">#include &lt;algorithm&gt;</a>
<a name="ln39">using std::copy;</a>
<a name="ln40">using std::max;</a>
<a name="ln41">using std::min;</a>
<a name="ln42">using std::reverse;</a>
<a name="ln43">using std::sort;</a>
<a name="ln44">using std::swap;</a>
<a name="ln45">#include &lt;ext/hash_map&gt;</a>
<a name="ln46">using __gnu_cxx::hash;</a>
<a name="ln47">using __gnu_cxx::hash_map;</a>
<a name="ln48">#include &lt;ext/hash_set&gt;</a>
<a name="ln49">using __gnu_cxx::hash;</a>
<a name="ln50">using __gnu_cxx::hash_set;</a>
<a name="ln51">#include &lt;iterator&gt;</a>
<a name="ln52">using std::back_insert_iterator;</a>
<a name="ln53">using std::iterator_traits;</a>
<a name="ln54">#include &lt;map&gt;</a>
<a name="ln55">using std::map;</a>
<a name="ln56">using std::multimap;</a>
<a name="ln57">#include &lt;set&gt;</a>
<a name="ln58">using std::multiset;</a>
<a name="ln59">using std::set;</a>
<a name="ln60">#include &lt;string&gt;</a>
<a name="ln61">using std::string;</a>
<a name="ln62">#include &lt;utility&gt;</a>
<a name="ln63">using std::make_pair;</a>
<a name="ln64">using std::pair;</a>
<a name="ln65">#include &lt;vector&gt;</a>
<a name="ln66">using std::vector;</a>
<a name="ln67"> </a>
<a name="ln68">#include &lt;glog/logging.h&gt;</a>
<a name="ln69"> </a>
<a name="ln70">#include &quot;yb/gutil/integral_types.h&quot;</a>
<a name="ln71">#include &quot;yb/gutil/logging-inl.h&quot;</a>
<a name="ln72">#include &quot;yb/gutil/strings/charset.h&quot;</a>
<a name="ln73">#include &quot;yb/gutil/strings/split_internal.h&quot;</a>
<a name="ln74">#include &quot;yb/gutil/strings/stringpiece.h&quot;</a>
<a name="ln75">#include &quot;yb/gutil/strings/strip.h&quot;</a>
<a name="ln76"> </a>
<a name="ln77">namespace strings {</a>
<a name="ln78"> </a>
<a name="ln79">//                              The new Split API</a>
<a name="ln80">//                                  aka Split2</a>
<a name="ln81">//                              aka strings::Split()</a>
<a name="ln82">//</a>
<a name="ln83">// This string splitting API consists of a Split() function in the ::strings</a>
<a name="ln84">// namespace and a handful of delimiter objects in the ::strings::delimiter</a>
<a name="ln85">// namespace (more on delimiter objects below). The Split() function always</a>
<a name="ln86">// takes two arguments: the text to be split and the delimiter on which to split</a>
<a name="ln87">// the text. An optional third argument may also be given, which is a Predicate</a>
<a name="ln88">// functor that will be used to filter the results, e.g., to skip empty strings</a>
<a name="ln89">// (more on predicates below). The Split() function adapts the returned</a>
<a name="ln90">// collection to the type specified by the caller.</a>
<a name="ln91">//</a>
<a name="ln92">// Example 1:</a>
<a name="ln93">//   // Splits the given string on commas. Returns the results in a</a>
<a name="ln94">//   // vector of strings.</a>
<a name="ln95">//   vector&lt;string&gt; v = strings::Split(&quot;a,b,c&quot;, &quot;,&quot;);</a>
<a name="ln96">//   assert(v.size() == 3);</a>
<a name="ln97">//</a>
<a name="ln98">// Example 2:</a>
<a name="ln99">//   // By default, empty strings are *included* in the output. See the</a>
<a name="ln100">//   // strings::SkipEmpty predicate below to omit them.</a>
<a name="ln101">//   vector&lt;string&gt; v = strings::Split(&quot;a,b,,c&quot;, &quot;,&quot;);</a>
<a name="ln102">//   assert(v.size() == 4);  // &quot;a&quot;, &quot;b&quot;, &quot;&quot;, &quot;c&quot;</a>
<a name="ln103">//   v = strings::Split(&quot;&quot;, &quot;,&quot;);</a>
<a name="ln104">//   assert(v.size() == 1);  // v contains a single &quot;&quot;</a>
<a name="ln105">//</a>
<a name="ln106">// Example 3:</a>
<a name="ln107">//   // Splits the string as in the previous example, except that the results</a>
<a name="ln108">//   // are returned as GStringPiece objects. Note that because we are storing</a>
<a name="ln109">//   // the results within GStringPiece objects, we have to ensure that the input</a>
<a name="ln110">//   // string outlives any results.</a>
<a name="ln111">//   vector&lt;GStringPiece&gt; v = strings::Split(&quot;a,b,c&quot;, &quot;,&quot;);</a>
<a name="ln112">//   assert(v.size() == 3);</a>
<a name="ln113">//</a>
<a name="ln114">// Example 4:</a>
<a name="ln115">//   // Stores results in a set&lt;string&gt;.</a>
<a name="ln116">//   set&lt;string&gt; a = strings::Split(&quot;a,b,c,a,b,c&quot;, &quot;,&quot;);</a>
<a name="ln117">//   assert(a.size() == 3);</a>
<a name="ln118">//</a>
<a name="ln119">// Example 5:</a>
<a name="ln120">//   // Stores results in a map. The map implementation assumes that the input</a>
<a name="ln121">//   // is provided as a series of key/value pairs. For example, the 0th element</a>
<a name="ln122">//   // resulting from the split will be stored as a key to the 1st element. If</a>
<a name="ln123">//   // an odd number of elements are resolved, the last element is paired with</a>
<a name="ln124">//   // a default-constructed value (e.g., empty string).</a>
<a name="ln125">//   map&lt;string, string&gt; m = strings::Split(&quot;a,b,c&quot;, &quot;,&quot;);</a>
<a name="ln126">//   assert(m.size() == 2);</a>
<a name="ln127">//   assert(m[&quot;a&quot;] == &quot;b&quot;);</a>
<a name="ln128">//   assert(m[&quot;c&quot;] == &quot;&quot;);  // last component value equals &quot;&quot;</a>
<a name="ln129">//</a>
<a name="ln130">// Example 6:</a>
<a name="ln131">//   // Splits on the empty string, which results in each character of the input</a>
<a name="ln132">//   // string becoming one element in the output collection.</a>
<a name="ln133">//   vector&lt;string&gt; v = strings::Split(&quot;abc&quot;, &quot;&quot;);</a>
<a name="ln134">//   assert(v.size() == 3);</a>
<a name="ln135">//</a>
<a name="ln136">// Example 7:</a>
<a name="ln137">//   // Stores first two split strings as the members in an std::pair.</a>
<a name="ln138">//   std::pair&lt;string, string&gt; p = strings::Split(&quot;a,b,c&quot;, &quot;,&quot;);</a>
<a name="ln139">//   EXPECT_EQ(&quot;a&quot;, p.first);</a>
<a name="ln140">//   EXPECT_EQ(&quot;b&quot;, p.second);</a>
<a name="ln141">//   // &quot;c&quot; is omitted because std::pair can hold only two elements.</a>
<a name="ln142">//</a>
<a name="ln143">// As illustrated above, the Split() function adapts the returned collection to</a>
<a name="ln144">// the type specified by the caller. The returned collections may contain</a>
<a name="ln145">// string, GStringPiece, Cord, or any object that has a constructor (explicit or</a>
<a name="ln146">// not) that takes a single GStringPiece argument. This pattern works for all</a>
<a name="ln147">// standard STL containers including vector, list, deque, set, multiset, map,</a>
<a name="ln148">// and multimap, non-standard containers including hash_set and hash_map, and</a>
<a name="ln149">// even std::pair which is not actually a container.</a>
<a name="ln150">//</a>
<a name="ln151">// Splitting to std::pair is an interesting case because it can hold only two</a>
<a name="ln152">// elements and is not a collection type. When splitting to an std::pair the</a>
<a name="ln153">// first two split strings become the std::pair's .first and .second members</a>
<a name="ln154">// respectively. The remaining split substrings are discarded. If there are less</a>
<a name="ln155">// than two split substrings, the empty string is used for the corresponding</a>
<a name="ln156">// std::pair member.</a>
<a name="ln157">//</a>
<a name="ln158">// The strings::Split() function can be used multiple times to perform more</a>
<a name="ln159">// complicated splitting logic, such as intelligently parsing key-value pairs.</a>
<a name="ln160">// For example</a>
<a name="ln161">//</a>
<a name="ln162">//   // The input string &quot;a=b=c,d=e,f=,g&quot; becomes</a>
<a name="ln163">//   // { &quot;a&quot; =&gt; &quot;b=c&quot;, &quot;d&quot; =&gt; &quot;e&quot;, &quot;f&quot; =&gt; &quot;&quot;, &quot;g&quot; =&gt; &quot;&quot; }</a>
<a name="ln164">//   map&lt;string, string&gt; m;</a>
<a name="ln165">//   for (GStringPiece sp : strings::Split(&quot;a=b=c,d=e,f=,g&quot;, &quot;,&quot;)) {</a>
<a name="ln166">//     m.insert(strings::Split(sp, strings::delimiter::Limit(&quot;=&quot;, 1)));</a>
<a name="ln167">//   }</a>
<a name="ln168">//   EXPECT_EQ(&quot;b=c&quot;, m.find(&quot;a&quot;)-&gt;second);</a>
<a name="ln169">//   EXPECT_EQ(&quot;e&quot;, m.find(&quot;d&quot;)-&gt;second);</a>
<a name="ln170">//   EXPECT_EQ(&quot;&quot;, m.find(&quot;f&quot;)-&gt;second);</a>
<a name="ln171">//   EXPECT_EQ(&quot;&quot;, m.find(&quot;g&quot;)-&gt;second);</a>
<a name="ln172">//</a>
<a name="ln173">// The above example stores the results in an std::map. But depending on your</a>
<a name="ln174">// data requirements, you can just as easily store the results in an</a>
<a name="ln175">// std::multimap or even a vector&lt;std::pair&lt;&gt;&gt;.</a>
<a name="ln176">//</a>
<a name="ln177">//</a>
<a name="ln178">//                                  Delimiters</a>
<a name="ln179">//</a>
<a name="ln180">// The Split() function also takes a second argument that is a delimiter. This</a>
<a name="ln181">// delimiter is actually an object that defines the boundaries between elements</a>
<a name="ln182">// in the provided input. If a string (const char*, ::string, or GStringPiece) is</a>
<a name="ln183">// passed in place of an explicit Delimiter object, the argument is implicitly</a>
<a name="ln184">// converted to a ::strings::delimiter::Literal.</a>
<a name="ln185">//</a>
<a name="ln186">// With this split API comes the formal concept of a Delimiter (big D). A</a>
<a name="ln187">// Delimiter is an object with a Find() function that knows how find the first</a>
<a name="ln188">// occurrence of itself in a given GStringPiece. Models of the Delimiter concept</a>
<a name="ln189">// represent specific kinds of delimiters, such as single characters,</a>
<a name="ln190">// substrings, or even regular expressions.</a>
<a name="ln191">//</a>
<a name="ln192">// The following Delimiter objects are provided as part of the Split() API:</a>
<a name="ln193">//</a>
<a name="ln194">//   - Literal (default)</a>
<a name="ln195">//   - AnyOf</a>
<a name="ln196">//   - Limit</a>
<a name="ln197">//</a>
<a name="ln198">// The following are examples of using some provided Delimiter objects:</a>
<a name="ln199">//</a>
<a name="ln200">// Example 1:</a>
<a name="ln201">//   // Because a string literal is converted to a strings::delimiter::Literal,</a>
<a name="ln202">//   // the following two splits are equivalent.</a>
<a name="ln203">//   vector&lt;string&gt; v1 = strings::Split(&quot;a,b,c&quot;, &quot;,&quot;);           // (1)</a>
<a name="ln204">//   using ::strings::delimiter::Literal;</a>
<a name="ln205">//   vector&lt;string&gt; v2 = strings::Split(&quot;a,b,c&quot;, Literal(&quot;,&quot;));  // (2)</a>
<a name="ln206">//</a>
<a name="ln207">// Example 2:</a>
<a name="ln208">//   // Splits on any of the characters specified in the delimiter string.</a>
<a name="ln209">//   using ::strings::delimiter::AnyOf;</a>
<a name="ln210">//   vector&lt;string&gt; v = strings::Split(&quot;a,b;c-d&quot;, AnyOf(&quot;,;-&quot;));</a>
<a name="ln211">//   assert(v.size() == 4);</a>
<a name="ln212">//</a>
<a name="ln213">// Example 3:</a>
<a name="ln214">//   // Uses the Limit meta-delimiter to limit the number of matches a delimiter</a>
<a name="ln215">//   // can have. In this case, the delimiter of a Literal comma is limited to</a>
<a name="ln216">//   // to matching at most one time. The last element in the returned</a>
<a name="ln217">//   // collection will contain all unsplit pieces, which may contain instances</a>
<a name="ln218">//   // of the delimiter.</a>
<a name="ln219">//   using ::strings::delimiter::Limit;</a>
<a name="ln220">//   vector&lt;string&gt; v = strings::Split(&quot;a,b,c&quot;, Limit(&quot;,&quot;, 1));</a>
<a name="ln221">//   assert(v.size() == 2);  // Limited to 1 delimiter; so two elements found</a>
<a name="ln222">//   assert(v[0] == &quot;a&quot;);</a>
<a name="ln223">//   assert(v[1] == &quot;b,c&quot;);</a>
<a name="ln224">//</a>
<a name="ln225">//</a>
<a name="ln226">//                                  Predicates</a>
<a name="ln227">//</a>
<a name="ln228">// Predicates can filter the results of a Split() operation by determining</a>
<a name="ln229">// whether or not a resultant element is included in the result set. A predicate</a>
<a name="ln230">// may be passed as an *optional* third argument to the Split() function.</a>
<a name="ln231">//</a>
<a name="ln232">// Predicates are unary functions (or functors) that take a single GStringPiece</a>
<a name="ln233">// argument and return bool indicating whether the argument should be included</a>
<a name="ln234">// (true) or excluded (false).</a>
<a name="ln235">//</a>
<a name="ln236">// One example where this is useful is when filtering out empty substrings. By</a>
<a name="ln237">// default, empty substrings may be returned by strings::Split(), which is</a>
<a name="ln238">// similar to the way split functions work in other programming languages. For</a>
<a name="ln239">// example:</a>
<a name="ln240">//</a>
<a name="ln241">//   // Empty strings *are* included in the returned collection.</a>
<a name="ln242">//   vector&lt;string&gt; v = strings::Split(&quot;,a,,b,&quot;, &quot;,&quot;);</a>
<a name="ln243">//   assert(v.size() ==  5);  // v[0] == &quot;&quot;, v[1] == &quot;a&quot;, v[2] == &quot;&quot;, ...</a>
<a name="ln244">//</a>
<a name="ln245">// These empty strings can be filtered out of the results by simply passing the</a>
<a name="ln246">// provided SkipEmpty predicate as the third argument to the Split() function.</a>
<a name="ln247">// SkipEmpty does not consider a string containing all whitespace to be empty.</a>
<a name="ln248">// For that behavior use the SkipWhitespace predicate. For example:</a>
<a name="ln249">//</a>
<a name="ln250">// Example 1:</a>
<a name="ln251">//   // Uses SkipEmpty to omit empty strings. Strings containing whitespace are</a>
<a name="ln252">//   // not empty and are therefore not skipped.</a>
<a name="ln253">//   using strings::SkipEmpty;</a>
<a name="ln254">//   vector&lt;string&gt; v = strings::Split(&quot;,a, ,b,&quot;, &quot;,&quot;, SkipEmpty());</a>
<a name="ln255">//   assert(v.size() == 3);</a>
<a name="ln256">//   assert(v[0] == &quot;a&quot;);</a>
<a name="ln257">//   assert(v[1] == &quot; &quot;);  // &lt;-- The whitespace makes the string not empty.</a>
<a name="ln258">//   assert(v[2] == &quot;b&quot;);</a>
<a name="ln259">//</a>
<a name="ln260">// Example 2:</a>
<a name="ln261">//   // Uses SkipWhitespace to skip all strings that are either empty or contain</a>
<a name="ln262">//   // only whitespace.</a>
<a name="ln263">//   using strings::SkipWhitespace;</a>
<a name="ln264">//   vector&lt;string&gt; v = strings::Split(&quot;,a, ,b,&quot;, &quot;,&quot;,  SkipWhitespace());</a>
<a name="ln265">//   assert(v.size() == 2);</a>
<a name="ln266">//   assert(v[0] == &quot;a&quot;);</a>
<a name="ln267">//   assert(v[1] == &quot;b&quot;);</a>
<a name="ln268">//</a>
<a name="ln269">//</a>
<a name="ln270">//                     Differences between Split1 and Split2</a>
<a name="ln271">//</a>
<a name="ln272">// Split2 is the strings::Split() API described above. Split1 is a name for the</a>
<a name="ln273">// collection of legacy Split*() functions declared later in this file. Most of</a>
<a name="ln274">// the Split1 functions follow a set of conventions that don't necessarily match</a>
<a name="ln275">// the conventions used in Split2. The following are some of the important</a>
<a name="ln276">// differences between Split1 and Split2:</a>
<a name="ln277">//</a>
<a name="ln278">// Split1 -&gt; Split2</a>
<a name="ln279">// ----------------</a>
<a name="ln280">// Append -&gt; Assign:</a>
<a name="ln281">//   The Split1 functions all returned their output collections via a pointer to</a>
<a name="ln282">//   an out parameter as is typical in Google code. In some cases the comments</a>
<a name="ln283">//   explicitly stated that results would be *appended* to the output</a>
<a name="ln284">//   collection. In some cases it was ambiguous whether results were appended.</a>
<a name="ln285">//   This ambiguity is gone in the Split2 API as results are always assigned to</a>
<a name="ln286">//   the output collection, never appended.</a>
<a name="ln287">//</a>
<a name="ln288">// AnyOf -&gt; Literal:</a>
<a name="ln289">//   Most Split1 functions treated their delimiter argument as a string of</a>
<a name="ln290">//   individual byte delimiters. For example, a delimiter of &quot;,;&quot; would split on</a>
<a name="ln291">//   &quot;,&quot; and &quot;;&quot;, not the substring &quot;,;&quot;. This behavior is equivalent to the</a>
<a name="ln292">//   Split2 delimiter strings::delimiter::AnyOf, which is *not* the default. By</a>
<a name="ln293">//   default, strings::Split() splits using strings::delimiter::Literal() which</a>
<a name="ln294">//   would treat the whole string &quot;,;&quot; as a single delimiter string.</a>
<a name="ln295">//</a>
<a name="ln296">// SkipEmpty -&gt; allow empty:</a>
<a name="ln297">//   Most Split1 functions omitted empty substrings in the results. To keep</a>
<a name="ln298">//   empty substrings one would have to use an explicitly named</a>
<a name="ln299">//   Split*AllowEmpty() function. This behavior is reversed in Split2. By</a>
<a name="ln300">//   default, strings::Split() *allows* empty substrings in the output. To skip</a>
<a name="ln301">//   them, use the strings::SkipEmpty predicate.</a>
<a name="ln302">//</a>
<a name="ln303">// string -&gt; user's choice:</a>
<a name="ln304">//   Most Split1 functions return collections of string objects. Some return</a>
<a name="ln305">//   char*, but the type returned is dictated by each Split1 function. With</a>
<a name="ln306">//   Split2 the caller can choose which string-like object to return. (Note:</a>
<a name="ln307">//   char* C-strings are not supported in Split2--use GStringPiece instead).</a>
<a name="ln308">//</a>
<a name="ln309"> </a>
<a name="ln310">// Definitions of the main Split() function.</a>
<a name="ln311">template &lt;typename Delimiter&gt;</a>
<a name="ln312">inline internal::Splitter&lt;Delimiter&gt; Split(GStringPiece text, Delimiter d) {</a>
<a name="ln313">  return internal::Splitter&lt;Delimiter&gt;(text, d);</a>
<a name="ln314">}</a>
<a name="ln315"> </a>
<a name="ln316">template &lt;typename Delimiter, typename Predicate&gt;</a>
<a name="ln317">inline internal::Splitter&lt;Delimiter, Predicate&gt; Split(</a>
<a name="ln318">    GStringPiece text, Delimiter d, Predicate p) {</a>
<a name="ln319">  return internal::Splitter&lt;Delimiter, Predicate&gt;(text, d, p);</a>
<a name="ln320">}</a>
<a name="ln321"> </a>
<a name="ln322">namespace delimiter {</a>
<a name="ln323">// A Delimiter object represents a single separator, such as a character,</a>
<a name="ln324">// literal string, or regular expression. A Delimiter object must have the</a>
<a name="ln325">// following member:</a>
<a name="ln326">//</a>
<a name="ln327">//   GStringPiece Find(GStringPiece text);</a>
<a name="ln328">//</a>
<a name="ln329">// This Find() member function should return a GStringPiece referring to the next</a>
<a name="ln330">// occurrence of the represented delimiter within the given string text. If no</a>
<a name="ln331">// delimiter is found in the given text, a zero-length GStringPiece referring to</a>
<a name="ln332">// text.end() should be returned (e.g., GStringPiece(text.end(), 0)). It is</a>
<a name="ln333">// important that the returned GStringPiece always be within the bounds of the</a>
<a name="ln334">// GStringPiece given as an argument--it must not refer to a string that is</a>
<a name="ln335">// physically located outside of the given string. The following example is a</a>
<a name="ln336">// simple Delimiter object that is created with a single char and will look for</a>
<a name="ln337">// that char in the text given to the Find() function:</a>
<a name="ln338">//</a>
<a name="ln339">//   struct SimpleDelimiter {</a>
<a name="ln340">//     const char c_;</a>
<a name="ln341">//     explicit SimpleDelimiter(char c) : c_(c) {}</a>
<a name="ln342">//     GStringPiece Find(GStringPiece text) {</a>
<a name="ln343">//       int pos = text.find(c_);</a>
<a name="ln344">//       if (pos == GStringPiece::npos) return GStringPiece(text.end(), 0);</a>
<a name="ln345">//       return GStringPiece(text, pos, 1);</a>
<a name="ln346">//     }</a>
<a name="ln347">//   };</a>
<a name="ln348"> </a>
<a name="ln349">// Represents a literal string delimiter. Examples:</a>
<a name="ln350">//</a>
<a name="ln351">//   using ::strings::delimiter::Literal;</a>
<a name="ln352">//   vector&lt;string&gt; v = strings::Split(&quot;a=&gt;b=&gt;c&quot;, Literal(&quot;=&gt;&quot;));</a>
<a name="ln353">//   assert(v.size() == 3);</a>
<a name="ln354">//   assert(v[0] == &quot;a&quot;);</a>
<a name="ln355">//   assert(v[1] == &quot;b&quot;);</a>
<a name="ln356">//   assert(v[2] == &quot;c&quot;);</a>
<a name="ln357">//</a>
<a name="ln358">// The next example uses the empty string as a delimiter.</a>
<a name="ln359">//</a>
<a name="ln360">//   using ::strings::delimiter::Literal;</a>
<a name="ln361">//   vector&lt;string&gt; v = strings::Split(&quot;abc&quot;, Literal(&quot;&quot;));</a>
<a name="ln362">//   assert(v.size() == 3);</a>
<a name="ln363">//   assert(v[0] == &quot;a&quot;);</a>
<a name="ln364">//   assert(v[1] == &quot;b&quot;);</a>
<a name="ln365">//   assert(v[2] == &quot;c&quot;);</a>
<a name="ln366">//</a>
<a name="ln367">class Literal {</a>
<a name="ln368"> public:</a>
<a name="ln369">  explicit Literal(GStringPiece sp);</a>
<a name="ln370">  GStringPiece Find(GStringPiece text) const;</a>
<a name="ln371"> </a>
<a name="ln372"> private:</a>
<a name="ln373">  const string delimiter_;</a>
<a name="ln374">};</a>
<a name="ln375"> </a>
<a name="ln376">// Represents a delimiter that will match any of the given byte-sized</a>
<a name="ln377">// characters. AnyOf is similar to Literal, except that AnyOf uses</a>
<a name="ln378">// GStringPiece::find_first_of() and Literal uses GStringPiece::find(). AnyOf</a>
<a name="ln379">// examples:</a>
<a name="ln380">//</a>
<a name="ln381">//   using ::strings::delimiter::AnyOf;</a>
<a name="ln382">//   vector&lt;string&gt; v = strings::Split(&quot;a,b=c&quot;, AnyOf(&quot;,=&quot;));</a>
<a name="ln383">//</a>
<a name="ln384">//   assert(v.size() == 3);</a>
<a name="ln385">//   assert(v[0] == &quot;a&quot;);</a>
<a name="ln386">//   assert(v[1] == &quot;b&quot;);</a>
<a name="ln387">//   assert(v[2] == &quot;c&quot;);</a>
<a name="ln388">//</a>
<a name="ln389">// If AnyOf is given the empty string, it behaves exactly like Literal and</a>
<a name="ln390">// matches each individual character in the input string.</a>
<a name="ln391">//</a>
<a name="ln392">// Note: The string passed to AnyOf is assumed to be a string of single-byte</a>
<a name="ln393">// ASCII characters. AnyOf does not work with multi-byte characters.</a>
<a name="ln394">class AnyOf {</a>
<a name="ln395"> public:</a>
<a name="ln396">  explicit AnyOf(GStringPiece sp);</a>
<a name="ln397">  GStringPiece Find(GStringPiece text) const;</a>
<a name="ln398"> </a>
<a name="ln399"> private:</a>
<a name="ln400">  const string delimiters_;</a>
<a name="ln401">};</a>
<a name="ln402"> </a>
<a name="ln403">// Wraps another delimiter and sets a max number of matches for that delimiter.</a>
<a name="ln404">// Create LimitImpls using the Limit() function. Example:</a>
<a name="ln405">//</a>
<a name="ln406">//   using ::strings::delimiter::Limit;</a>
<a name="ln407">//   vector&lt;string&gt; v = strings::Split(&quot;a,b,c,d&quot;, Limit(&quot;,&quot;, 2));</a>
<a name="ln408">//</a>
<a name="ln409">//   assert(v.size() == 3);  // Split on 2 commas, giving a vector with 3 items</a>
<a name="ln410">//   assert(v[0] == &quot;a&quot;);</a>
<a name="ln411">//   assert(v[1] == &quot;b&quot;);</a>
<a name="ln412">//   assert(v[2] == &quot;c,d&quot;);</a>
<a name="ln413">//</a>
<a name="ln414">template &lt;typename Delimiter&gt;</a>
<a name="ln415">class LimitImpl {</a>
<a name="ln416"> public:</a>
<a name="ln417">  LimitImpl(Delimiter delimiter, int limit)</a>
<a name="ln418">      : delimiter_(std::move(delimiter)), limit_(limit), count_(0) {}</a>
<a name="ln419">  GStringPiece Find(GStringPiece text) {</a>
<a name="ln420">    if (count_++ == limit_) {</a>
<a name="ln421">      return GStringPiece(text.end(), 0);  // No more matches.</a>
<a name="ln422">    }</a>
<a name="ln423">    return delimiter_.Find(text);</a>
<a name="ln424">  }</a>
<a name="ln425"> </a>
<a name="ln426"> private:</a>
<a name="ln427">  Delimiter delimiter_;</a>
<a name="ln428">  const int limit_;</a>
<a name="ln429">  int count_;</a>
<a name="ln430">};</a>
<a name="ln431"> </a>
<a name="ln432">// Overloaded Limit() function to create LimitImpl&lt;&gt; objects. Uses the Delimiter</a>
<a name="ln433">// Literal as the default if string-like objects are passed as the delimiter</a>
<a name="ln434">// parameter. This is similar to the overloads for Split() below.</a>
<a name="ln435">template &lt;typename Delimiter&gt;</a>
<a name="ln436">inline LimitImpl&lt;Delimiter&gt; Limit(Delimiter delim, int limit) {</a>
<a name="ln437">  return LimitImpl&lt;Delimiter&gt;(delim, limit);</a>
<a name="ln438">}</a>
<a name="ln439"> </a>
<a name="ln440">inline LimitImpl&lt;Literal&gt; Limit(const char* s, int limit) {</a>
<a name="ln441">  return LimitImpl&lt;Literal&gt;(Literal(s), limit);</a>
<a name="ln442">}</a>
<a name="ln443"> </a>
<a name="ln444">inline LimitImpl&lt;Literal&gt; Limit(const string&amp; s, int limit) {</a>
<a name="ln445">  return LimitImpl&lt;Literal&gt;(Literal(s), limit);</a>
<a name="ln446">}</a>
<a name="ln447"> </a>
<a name="ln448">inline LimitImpl&lt;Literal&gt; Limit(GStringPiece s, int limit) {</a>
<a name="ln449">  return LimitImpl&lt;Literal&gt;(Literal(s), limit);</a>
<a name="ln450">}</a>
<a name="ln451"> </a>
<a name="ln452">}  // namespace delimiter</a>
<a name="ln453"> </a>
<a name="ln454">//</a>
<a name="ln455">// Predicates are functors that return bool indicating whether the given</a>
<a name="ln456">// GStringPiece should be included in the split output. If the predicate returns</a>
<a name="ln457">// false then the string will be excluded from the output from strings::Split().</a>
<a name="ln458">//</a>
<a name="ln459"> </a>
<a name="ln460">// Always returns true, indicating that all strings--including empty</a>
<a name="ln461">// strings--should be included in the split output. This predicate is not</a>
<a name="ln462">// strictly needed because this is the default behavior of the strings::Split()</a>
<a name="ln463">// function. But it might be useful at some call sites to make the intent</a>
<a name="ln464">// explicit.</a>
<a name="ln465">//</a>
<a name="ln466">// vector&lt;string&gt; v = Split(&quot; a , ,,b,&quot;, &quot;,&quot;, AllowEmpty());</a>
<a name="ln467">// EXPECT_THAT(v, ElementsAre(&quot; a &quot;, &quot; &quot;, &quot;&quot;, &quot;b&quot;, &quot;&quot;));</a>
<a name="ln468">struct AllowEmpty {</a>
<a name="ln469">  bool operator()(GStringPiece sp) const {</a>
<a name="ln470">    return true;</a>
<a name="ln471">  }</a>
<a name="ln472">};</a>
<a name="ln473"> </a>
<a name="ln474">// Returns false if the given GStringPiece is empty, indicating that the</a>
<a name="ln475">// strings::Split() API should omit the empty string.</a>
<a name="ln476">//</a>
<a name="ln477">// vector&lt;string&gt; v = Split(&quot; a , ,,b,&quot;, &quot;,&quot;, SkipEmpty());</a>
<a name="ln478">// EXPECT_THAT(v, ElementsAre(&quot; a &quot;, &quot; &quot;, &quot;b&quot;));</a>
<a name="ln479">struct SkipEmpty {</a>
<a name="ln480">  bool operator()(GStringPiece sp) const {</a>
<a name="ln481">    return !sp.empty();</a>
<a name="ln482">  }</a>
<a name="ln483">};</a>
<a name="ln484"> </a>
<a name="ln485">// Returns false if the given GStringPiece is empty or contains only whitespace,</a>
<a name="ln486">// indicating that the strings::Split() API should omit the string.</a>
<a name="ln487">//</a>
<a name="ln488">// vector&lt;string&gt; v = Split(&quot; a , ,,b,&quot;, &quot;,&quot;, SkipWhitespace());</a>
<a name="ln489">// EXPECT_THAT(v, ElementsAre(&quot; a &quot;, &quot;b&quot;));</a>
<a name="ln490">struct SkipWhitespace {</a>
<a name="ln491">  bool operator()(GStringPiece sp) const {</a>
<a name="ln492">    StripWhiteSpace(&amp;sp);</a>
<a name="ln493">    return !sp.empty();</a>
<a name="ln494">  }</a>
<a name="ln495">};</a>
<a name="ln496"> </a>
<a name="ln497">// Split() function overloads to effectively give Split() a default Delimiter</a>
<a name="ln498">// type of Literal. If Split() is called and a string is passed as the delimiter</a>
<a name="ln499">// instead of an actual Delimiter object, then one of these overloads will be</a>
<a name="ln500">// invoked and will create a Splitter&lt;Literal&gt; with the delimiter string.</a>
<a name="ln501">//</a>
<a name="ln502">// Since Split() is a function template above, these overload signatures need to</a>
<a name="ln503">// be explicit about the string type so they match better than the templated</a>
<a name="ln504">// version. These functions are overloaded for:</a>
<a name="ln505">//</a>
<a name="ln506">//   - const char*</a>
<a name="ln507">//   - const string&amp;</a>
<a name="ln508">//   - GStringPiece</a>
<a name="ln509"> </a>
<a name="ln510">inline internal::Splitter&lt;delimiter::Literal&gt; Split(</a>
<a name="ln511">    GStringPiece text, const char* delimiter) {</a>
<a name="ln512">  return internal::Splitter&lt;delimiter::Literal&gt;(</a>
<a name="ln513">      text, delimiter::Literal(delimiter));</a>
<a name="ln514">}</a>
<a name="ln515"> </a>
<a name="ln516">inline internal::Splitter&lt;delimiter::Literal&gt; Split(</a>
<a name="ln517">    GStringPiece text, const string&amp; delimiter) {</a>
<a name="ln518">  return internal::Splitter&lt;delimiter::Literal&gt;(</a>
<a name="ln519">      text, delimiter::Literal(delimiter));</a>
<a name="ln520">}</a>
<a name="ln521"> </a>
<a name="ln522">inline internal::Splitter&lt;delimiter::Literal&gt; Split(</a>
<a name="ln523">    GStringPiece text, GStringPiece delimiter) {</a>
<a name="ln524">  return internal::Splitter&lt;delimiter::Literal&gt;(</a>
<a name="ln525">      text, delimiter::Literal(delimiter));</a>
<a name="ln526">}</a>
<a name="ln527"> </a>
<a name="ln528">// Same overloads as above, but also including a Predicate argument.</a>
<a name="ln529">template &lt;typename Predicate&gt;</a>
<a name="ln530">inline internal::Splitter&lt;delimiter::Literal, Predicate&gt; Split(</a>
<a name="ln531">    GStringPiece text, const char* delimiter, Predicate p) {</a>
<a name="ln532">  return internal::Splitter&lt;delimiter::Literal, Predicate&gt;(</a>
<a name="ln533">      text, delimiter::Literal(delimiter), p);</a>
<a name="ln534">}</a>
<a name="ln535"> </a>
<a name="ln536">template &lt;typename Predicate&gt;</a>
<a name="ln537">inline internal::Splitter&lt;delimiter::Literal, Predicate&gt; Split(</a>
<a name="ln538">    GStringPiece text, const string&amp; delimiter, Predicate p) {</a>
<a name="ln539">  return internal::Splitter&lt;delimiter::Literal, Predicate&gt;(</a>
<a name="ln540">      text, delimiter::Literal(delimiter), p);</a>
<a name="ln541">}</a>
<a name="ln542"> </a>
<a name="ln543">template &lt;typename Predicate&gt;</a>
<a name="ln544">inline internal::Splitter&lt;delimiter::Literal, Predicate&gt; Split(</a>
<a name="ln545">    GStringPiece text, GStringPiece delimiter, Predicate p) {</a>
<a name="ln546">  return internal::Splitter&lt;delimiter::Literal, Predicate&gt;(</a>
<a name="ln547">      text, delimiter::Literal(delimiter), p);</a>
<a name="ln548">}</a>
<a name="ln549"> </a>
<a name="ln550">}  // namespace strings</a>
<a name="ln551"> </a>
<a name="ln552">//</a>
<a name="ln553">// ==================== LEGACY SPLIT FUNCTIONS ====================</a>
<a name="ln554">//</a>
<a name="ln555"> </a>
<a name="ln556">// NOTE: The instruction below creates a Module titled</a>
<a name="ln557">// GlobalSplitFunctions within the auto-generated Doxygen documentation.</a>
<a name="ln558">// This instruction is needed to expose global functions that are not</a>
<a name="ln559">// within a namespace.</a>
<a name="ln560">//</a>
<a name="ln561">// START DOXYGEN SplitFunctions grouping</a>
<a name="ln562">/* @defgroup SplitFunctions</a>
<a name="ln563"> * @{ */</a>
<a name="ln564"> </a>
<a name="ln565">// ----------------------------------------------------------------------</a>
<a name="ln566">// ClipString</a>
<a name="ln567">//    Clip a string to a max length. We try to clip on a word boundary</a>
<a name="ln568">//    if this is possible. If the string is clipped, we append an</a>
<a name="ln569">//    ellipsis.</a>
<a name="ln570">//</a>
<a name="ln571">//    ***NOTE***</a>
<a name="ln572">//    ClipString counts length with strlen.  If you have non-ASCII</a>
<a name="ln573">//    strings like UTF-8, this is wrong.  If you are displaying the</a>
<a name="ln574">//    clipped strings to users in a frontend, consider using</a>
<a name="ln575">//    ClipStringOnWordBoundary in</a>
<a name="ln576">//    webserver/util/snippets/rewriteboldtags, which considers the width</a>
<a name="ln577">//    of the string, not just the number of bytes.</a>
<a name="ln578">//</a>
<a name="ln579">//    TODO(user) Move ClipString back to strutil.  The problem with this is</a>
<a name="ln580">//    that ClipStringHelper is used behind the scenes by SplitStringToLines, but</a>
<a name="ln581">//    probably shouldn't be exposed in the .h files.</a>
<a name="ln582">// ----------------------------------------------------------------------</a>
<a name="ln583">void ClipString(char* str, int max_len);</a>
<a name="ln584"> </a>
<a name="ln585">// ----------------------------------------------------------------------</a>
<a name="ln586">// ClipString</a>
<a name="ln587">//    Version of ClipString() that uses string instead of char*.</a>
<a name="ln588">//    NOTE: See comment above.</a>
<a name="ln589">// ----------------------------------------------------------------------</a>
<a name="ln590">void ClipString(string* full_str, int max_len);</a>
<a name="ln591"> </a>
<a name="ln592">// ----------------------------------------------------------------------</a>
<a name="ln593">// SplitStringToLines() Split a string into lines of maximum length</a>
<a name="ln594">// 'max_len'. Append the resulting lines to 'result'. Will attempt</a>
<a name="ln595">// to split on word boundaries.  If 'num_lines'</a>
<a name="ln596">// is zero it splits up the whole string regardless of length. If</a>
<a name="ln597">// 'num_lines' is positive, it returns at most num_lines lines, and</a>
<a name="ln598">// appends a &quot;...&quot; to the end of the last line if the string is too</a>
<a name="ln599">// long to fit completely into 'num_lines' lines.</a>
<a name="ln600">// ----------------------------------------------------------------------</a>
<a name="ln601">void SplitStringToLines(const char* full,</a>
<a name="ln602">                        int max_len,</a>
<a name="ln603">                        int num_lines,</a>
<a name="ln604">                        vector&lt;string&gt;* result);</a>
<a name="ln605"> </a>
<a name="ln606">// ----------------------------------------------------------------------</a>
<a name="ln607">// SplitOneStringToken()</a>
<a name="ln608">//   Returns the first &quot;delim&quot; delimited string from &quot;*source&quot; and modifies</a>
<a name="ln609">//   *source to point after the delimiter that was found. If no delimiter is</a>
<a name="ln610">//   found, *source is set to NULL.</a>
<a name="ln611">//</a>
<a name="ln612">//   If the start of *source is a delimiter, an empty string is returned.</a>
<a name="ln613">//   If *source is NULL, an empty string is returned.</a>
<a name="ln614">//</a>
<a name="ln615">//   &quot;delim&quot; is treated as a sequence of 1 or more character delimiters. Any one</a>
<a name="ln616">//   of the characters present in &quot;delim&quot; is considered to be a single</a>
<a name="ln617">//   delimiter; The delimiter is not &quot;delim&quot; as a whole. For example:</a>
<a name="ln618">//</a>
<a name="ln619">//     const char* s = &quot;abc=;de&quot;;</a>
<a name="ln620">//     string r = SplitOneStringToken(&amp;s, &quot;;=&quot;);</a>
<a name="ln621">//     // r = &quot;abc&quot;</a>
<a name="ln622">//     // s points to &quot;;de&quot;</a>
<a name="ln623">// ----------------------------------------------------------------------</a>
<a name="ln624">string SplitOneStringToken(const char** source, const char* delim);</a>
<a name="ln625"> </a>
<a name="ln626">// ----------------------------------------------------------------------</a>
<a name="ln627">// SplitUsing()</a>
<a name="ln628">//    Split a string into substrings based on the nul-terminated list</a>
<a name="ln629">//    of bytes at delimiters (uses strsep) and return a vector of</a>
<a name="ln630">//    those strings. Modifies 'full' We allocate the return vector,</a>
<a name="ln631">//    and you should free it.  Note that empty fields are ignored.</a>
<a name="ln632">//    Use SplitToVector with last argument 'false' if you want the</a>
<a name="ln633">//    empty fields.</a>
<a name="ln634">//    ----------------------------------------------------------------------</a>
<a name="ln635">vector&lt;char*&gt;* SplitUsing(char* full, const char* delimiters);</a>
<a name="ln636"> </a>
<a name="ln637">// ----------------------------------------------------------------------</a>
<a name="ln638">// SplitToVector()</a>
<a name="ln639">//    Split a string into substrings based on the nul-terminated list</a>
<a name="ln640">//    of bytes at delim (uses strsep) and appends the split</a>
<a name="ln641">//    strings to 'vec'.  Modifies &quot;full&quot;.  If omit empty strings is</a>
<a name="ln642">//    true, empty strings are omitted from the resulting vector.</a>
<a name="ln643">// ----------------------------------------------------------------------</a>
<a name="ln644">void SplitToVector(char* full, const char* delimiters,</a>
<a name="ln645">                   vector&lt;char*&gt;* vec,</a>
<a name="ln646">                   bool omit_empty_strings);</a>
<a name="ln647">void SplitToVector(char* full, const char* delimiters,</a>
<a name="ln648">                   vector&lt;const char*&gt;* vec,</a>
<a name="ln649">                   bool omit_empty_strings);</a>
<a name="ln650"> </a>
<a name="ln651">// ----------------------------------------------------------------------</a>
<a name="ln652">// SplitGStringPieceToVector</a>
<a name="ln653">//    Split a GStringPiece into sub-GStringPieces based on the</a>
<a name="ln654">//    nul-terminated list of bytes at delim and appends the</a>
<a name="ln655">//    pieces to 'vec'.  If omit empty strings is true, empty strings</a>
<a name="ln656">//    are omitted from the resulting vector.</a>
<a name="ln657">//    Expects the original string (from which 'full' is derived) to exist</a>
<a name="ln658">//    for the full lifespan of 'vec'.</a>
<a name="ln659">// ----------------------------------------------------------------------</a>
<a name="ln660">void SplitGStringPieceToVector(const GStringPiece&amp; full,</a>
<a name="ln661">                              const char* delim,</a>
<a name="ln662">                              vector&lt;GStringPiece&gt;* vec,</a>
<a name="ln663">                              bool omit_empty_strings);</a>
<a name="ln664"> </a>
<a name="ln665">// ----------------------------------------------------------------------</a>
<a name="ln666">// SplitStringUsing()</a>
<a name="ln667">// SplitStringToHashsetUsing()</a>
<a name="ln668">// SplitStringToSetUsing()</a>
<a name="ln669">// SplitStringToMapUsing()</a>
<a name="ln670">// SplitStringToHashmapUsing()</a>
<a name="ln671"> </a>
<a name="ln672">// Splits a string using one or more byte delimiters, presented as a</a>
<a name="ln673">// nul-terminated c string. Append the components to 'result'. If there are</a>
<a name="ln674">// consecutive delimiters, this function skips over all of them: in other words,</a>
<a name="ln675">// empty components are dropped. If you want to keep empty components, try</a>
<a name="ln676">// SplitStringAllowEmpty().</a>
<a name="ln677">//</a>
<a name="ln678">// NOTE: Do not use this for multi-byte delimiters such as UTF-8 strings. Use</a>
<a name="ln679">// strings::Split() with strings::delimiter::Literal as the delimiter.</a>
<a name="ln680">//</a>
<a name="ln681">// ==&gt; NEW API: Consider using the new Split API defined above. &lt;==</a>
<a name="ln682">// Example:</a>
<a name="ln683">//</a>
<a name="ln684">//   using strings::SkipEmpty;</a>
<a name="ln685">//   using strings::Split;</a>
<a name="ln686">//   using strings::delimiter::AnyOf;</a>
<a name="ln687">//</a>
<a name="ln688">//   vector&lt;string&gt; v = Split(full, AnyOf(delimiter), SkipEmpty());</a>
<a name="ln689">//</a>
<a name="ln690">// For even better performance, store the result in a vector&lt;GStringPiece&gt;</a>
<a name="ln691">// to avoid string copies.</a>
<a name="ln692">// ----------------------------------------------------------------------</a>
<a name="ln693">void SplitStringUsing(const string&amp; full, const char* delimiters,</a>
<a name="ln694">                      vector&lt;string&gt;* result);</a>
<a name="ln695">void SplitStringToHashsetUsing(const string&amp; full, const char* delimiters,</a>
<a name="ln696">                               hash_set&lt;string&gt;* result);</a>
<a name="ln697">void SplitStringToSetUsing(const string&amp; full, const char* delimiters,</a>
<a name="ln698">                           set&lt;string&gt;* result);</a>
<a name="ln699">// The even-positioned (0-based) components become the keys for the</a>
<a name="ln700">// odd-positioned components that follow them. When there is an odd</a>
<a name="ln701">// number of components, the value for the last key will be unchanged</a>
<a name="ln702">// if the key was already present in the hash table, or will be the</a>
<a name="ln703">// empty string if the key is a newly inserted key.</a>
<a name="ln704">void SplitStringToMapUsing(const string&amp; full, const char* delim,</a>
<a name="ln705">                           map&lt;string, string&gt;* result);</a>
<a name="ln706">void SplitStringToHashmapUsing(const string&amp; full, const char* delim,</a>
<a name="ln707">                               hash_map&lt;string, string&gt;* result);</a>
<a name="ln708"> </a>
<a name="ln709">// ----------------------------------------------------------------------</a>
<a name="ln710">// SplitStringAllowEmpty()</a>
<a name="ln711">//</a>
<a name="ln712">// Split a string using one or more byte delimiters, presented as a</a>
<a name="ln713">// nul-terminated c string. Append the components to 'result'. If there are</a>
<a name="ln714">// consecutive delimiters, this function will return corresponding empty</a>
<a name="ln715">// strings.  If you want to drop the empty strings, try SplitStringUsing().</a>
<a name="ln716">//</a>
<a name="ln717">// If &quot;full&quot; is the empty string, yields an empty string as the only value.</a>
<a name="ln718">//</a>
<a name="ln719">// ==&gt; NEW API: Consider using the new Split API defined above. &lt;==</a>
<a name="ln720">//</a>
<a name="ln721">//   using strings::Split;</a>
<a name="ln722">//   using strings::delimiter::AnyOf;</a>
<a name="ln723">//</a>
<a name="ln724">//   vector&lt;string&gt; v = Split(full, AnyOf(delimiter));</a>
<a name="ln725">//</a>
<a name="ln726">// For even better performance, store the result in a vector&lt;GStringPiece&gt; to</a>
<a name="ln727">// avoid string copies.</a>
<a name="ln728">// ----------------------------------------------------------------------</a>
<a name="ln729">void SplitStringAllowEmpty(const string&amp; full, const char* delim,</a>
<a name="ln730">                           vector&lt;string&gt;* result);</a>
<a name="ln731"> </a>
<a name="ln732">// ----------------------------------------------------------------------</a>
<a name="ln733">// SplitStringWithEscaping()</a>
<a name="ln734">// SplitStringWithEscapingAllowEmpty()</a>
<a name="ln735">// SplitStringWithEscapingToSet()</a>
<a name="ln736">// SplitStringWithEscapingToHashset()</a>
<a name="ln737"> </a>
<a name="ln738">//   Split the string using the specified delimiters, taking escaping into</a>
<a name="ln739">//   account. '\' is not allowed as a delimiter.</a>
<a name="ln740">//</a>
<a name="ln741">//   Within the string, preserve a delimiter preceded by a backslash as a</a>
<a name="ln742">//   literal delimiter. In addition, preserve two consecutive backslashes as</a>
<a name="ln743">//   a single literal backslash. Do not unescape any other backslash-character</a>
<a name="ln744">//   sequence.</a>
<a name="ln745">//</a>
<a name="ln746">//   Eg. 'foo\=bar=baz\\qu\ux' split on '=' becomes ('foo=bar', 'baz\qu\ux')</a>
<a name="ln747">//</a>
<a name="ln748">//   All versions other than &quot;AllowEmpty&quot; discard any empty substrings.</a>
<a name="ln749">// ----------------------------------------------------------------------</a>
<a name="ln750">void SplitStringWithEscaping(const string&amp; full,</a>
<a name="ln751">                             const strings::CharSet&amp; delimiters,</a>
<a name="ln752">                             vector&lt;string&gt;* result);</a>
<a name="ln753">void SplitStringWithEscapingAllowEmpty(const string&amp; full,</a>
<a name="ln754">                                       const strings::CharSet&amp; delimiters,</a>
<a name="ln755">                                       vector&lt;string&gt;* result);</a>
<a name="ln756">void SplitStringWithEscapingToSet(const string&amp; full,</a>
<a name="ln757">                                  const strings::CharSet&amp; delimiters,</a>
<a name="ln758">                                  set&lt;string&gt;* result);</a>
<a name="ln759">void SplitStringWithEscapingToHashset(const string&amp; full,</a>
<a name="ln760">                                      const strings::CharSet&amp; delimiters,</a>
<a name="ln761">                                      hash_set&lt;string&gt;* result);</a>
<a name="ln762"> </a>
<a name="ln763">// ----------------------------------------------------------------------</a>
<a name="ln764">// SplitStringIntoNPiecesAllowEmpty()</a>
<a name="ln765"> </a>
<a name="ln766">//    Split a string using a nul-terminated list of byte</a>
<a name="ln767">//    delimiters. Append the components to 'result'.  If there are</a>
<a name="ln768">//    consecutive delimiters, this function will return corresponding</a>
<a name="ln769">//    empty strings. The string is split into at most the specified</a>
<a name="ln770">//    number of pieces greedily. This means that the last piece may</a>
<a name="ln771">//    possibly be split further. To split into as many pieces as</a>
<a name="ln772">//    possible, specify 0 as the number of pieces.</a>
<a name="ln773">//</a>
<a name="ln774">//    If &quot;full&quot; is the empty string, yields an empty string as the only value.</a>
<a name="ln775">// ----------------------------------------------------------------------</a>
<a name="ln776">void SplitStringIntoNPiecesAllowEmpty(const string&amp; full,</a>
<a name="ln777">                                      const char* delimiters,</a>
<a name="ln778">                                      int pieces,</a>
<a name="ln779">                                      vector&lt;string&gt;* result);</a>
<a name="ln780"> </a>
<a name="ln781">// ----------------------------------------------------------------------</a>
<a name="ln782">// SplitStringAndParse()</a>
<a name="ln783">// SplitStringAndParseToContainer()</a>
<a name="ln784">// SplitStringAndParseToList()</a>
<a name="ln785">//    Split a string using a nul-terminated list of character</a>
<a name="ln786">//    delimiters.  For each component, parse using the provided</a>
<a name="ln787">//    parsing function and if successful, append it to 'result'.</a>
<a name="ln788">//    Return true if and only if all components parse successfully.</a>
<a name="ln789">//    If there are consecutive delimiters, this function skips over</a>
<a name="ln790">//    all of them.  This function will correctly handle parsing</a>
<a name="ln791">//    strings that have embedded \0s.</a>
<a name="ln792">//</a>
<a name="ln793">// SplitStringAndParse fills into a vector.</a>
<a name="ln794">// SplitStringAndParseToContainer fills into any container that implements</a>
<a name="ln795">//    a single-argument insert function. (i.e. insert(const value_type&amp; x) ).</a>
<a name="ln796">// SplitStringAndParseToList fills into any container that implements a single-</a>
<a name="ln797">//    argument push_back function (i.e. push_back(const value_type&amp; x) ), plus</a>
<a name="ln798">//    value_type&amp; back() and pop_back().</a>
<a name="ln799">//    NOTE: This implementation relies on parsing in-place into the &quot;back()&quot;</a>
<a name="ln800">//    reference, so its performance may depend on the efficiency of back().</a>
<a name="ln801">//</a>
<a name="ln802">// Example Usage:</a>
<a name="ln803">//  vector&lt;double&gt; values;</a>
<a name="ln804">//  CHECK(SplitStringAndParse(&quot;1.0,2.0,3.0&quot;, &quot;,&quot;, &amp;safe_strtod, &amp;values));</a>
<a name="ln805">//  CHECK_EQ(3, values.size());</a>
<a name="ln806">//</a>
<a name="ln807">//  vector&lt;int64&gt; values;</a>
<a name="ln808">//  CHECK(SplitStringAndParse(&quot;1M,2M,3M&quot;, &quot;,&quot;,</a>
<a name="ln809">//        &amp;HumanReadableNumBytes::ToInt64, &amp;values));</a>
<a name="ln810">//  CHECK_EQ(3, values.size());</a>
<a name="ln811">//</a>
<a name="ln812">//  set&lt;int64&gt; values;</a>
<a name="ln813">//  CHECK(SplitStringAndParseToContainer(&quot;3,1,1,2&quot;, &quot;,&quot;,</a>
<a name="ln814">//        &amp;safe_strto64, &amp;values));</a>
<a name="ln815">//  CHECK_EQ(4, values.size());</a>
<a name="ln816">//</a>
<a name="ln817">//  deque&lt;int64&gt; values;</a>
<a name="ln818">//  CHECK(SplitStringAndParseToList(&quot;3,1,1,2&quot;, &quot;,&quot;, &amp;safe_strto64, &amp;values));</a>
<a name="ln819">//  CHECK_EQ(4, values.size());</a>
<a name="ln820">// ----------------------------------------------------------------------</a>
<a name="ln821">template &lt;class T&gt;</a>
<a name="ln822">bool SplitStringAndParse(GStringPiece source, GStringPiece delim,</a>
<a name="ln823">                         bool (*parse)(const string&amp; str, T* value),</a>
<a name="ln824">                         vector&lt;T&gt;* result);</a>
<a name="ln825">template &lt;class Container&gt;</a>
<a name="ln826">bool SplitStringAndParseToContainer(</a>
<a name="ln827">    GStringPiece source, GStringPiece delim,</a>
<a name="ln828">    bool (*parse)(const string&amp; str, typename Container::value_type* value),</a>
<a name="ln829">    Container* result);</a>
<a name="ln830"> </a>
<a name="ln831">template &lt;class List&gt;</a>
<a name="ln832">bool SplitStringAndParseToList(</a>
<a name="ln833">    GStringPiece source, GStringPiece delim,</a>
<a name="ln834">    bool (*parse)(const string&amp; str, typename List::value_type* value),</a>
<a name="ln835">    List* result);</a>
<a name="ln836">// ----------------------------------------------------------------------</a>
<a name="ln837">// SplitRange()</a>
<a name="ln838">//    Splits a string of the form &quot;&lt;from&gt;-&lt;to&gt;&quot;.  Either or both can be</a>
<a name="ln839">//    missing.  A raw number (&lt;to&gt;) is interpreted as &quot;&lt;to&gt;-&quot;.  Modifies</a>
<a name="ln840">//    parameters insofar as they're specified by the string.  RETURNS</a>
<a name="ln841">//    true iff the input is a well-formed range.  If it RETURNS false,</a>
<a name="ln842">//    from and to remain unchanged.  The range in rangestr should be</a>
<a name="ln843">//    terminated either by &quot;\0&quot; or by whitespace.</a>
<a name="ln844">// ----------------------------------------------------------------------</a>
<a name="ln845">bool SplitRange(const char* rangestr, int* from, int* to);</a>
<a name="ln846"> </a>
<a name="ln847">// ----------------------------------------------------------------------</a>
<a name="ln848">// SplitCSVLineWithDelimiter()</a>
<a name="ln849">//    CSV lines come in many guises.  There's the Comma Separated Values</a>
<a name="ln850">//    variety, in which fields are separated by (surprise!) commas.  There's</a>
<a name="ln851">//    also the tab-separated values variant, in which tabs separate the</a>
<a name="ln852">//    fields.  This routine handles both, which makes it almost like</a>
<a name="ln853">//    SplitUsing(line, delimiter), but for some special processing.  For both</a>
<a name="ln854">//    delimiters, whitespace is trimmed from either side of the field value.</a>
<a name="ln855">//    If the delimiter is ',', we play additional games with quotes.  A</a>
<a name="ln856">//    field value surrounded by double quotes is allowed to contain commas,</a>
<a name="ln857">//    which are not treated as field separators.  Within a double-quoted</a>
<a name="ln858">//    string, a series of two double quotes signals an escaped single double</a>
<a name="ln859">//    quote.  It'll be clearer in the examples.</a>
<a name="ln860">//    Example:</a>
<a name="ln861">//     Google , x , &quot;Buchheit, Paul&quot;, &quot;string with &quot;&quot; quote in it&quot;</a>
<a name="ln862">//     --&gt;  [Google], [x], [Buchheit, Paul], [string with &quot; quote in it]</a>
<a name="ln863">//</a>
<a name="ln864">// SplitCSVLine()</a>
<a name="ln865">//    A convenience wrapper around SplitCSVLineWithDelimiter which uses</a>
<a name="ln866">//    ',' as the delimiter.</a>
<a name="ln867">//</a>
<a name="ln868">// The following variants of SplitCSVLine() are not recommended for new code.</a>
<a name="ln869">// Please consider the CSV parser in //util/csv as an alternative.  Examples:</a>
<a name="ln870">// To parse a single line:</a>
<a name="ln871">//     #include &quot;yb/util/csv/parser.h&quot;</a>
<a name="ln872">//     vector&lt;string&gt; fields = util::csv::ParseLine(line).fields();</a>
<a name="ln873">//</a>
<a name="ln874">// To parse an entire file:</a>
<a name="ln875">//     #include &quot;yb/util/csv/parser.h&quot;</a>
<a name="ln876">//     for (Record rec : Parser(source)) {</a>
<a name="ln877">//       vector&lt;string&gt; fields = rec.fields();</a>
<a name="ln878">//     }</a>
<a name="ln879">//</a>
<a name="ln880">// See //util/csv/parser.h for more complete documentation.</a>
<a name="ln881">//</a>
<a name="ln882">// ----------------------------------------------------------------------</a>
<a name="ln883">void SplitCSVLine(char* line, vector&lt;char*&gt;* cols);</a>
<a name="ln884">void SplitCSVLineWithDelimiter(char* line, char delimiter,</a>
<a name="ln885">                               vector&lt;char*&gt;* cols);</a>
<a name="ln886">// SplitCSVLine string wrapper that internally makes a copy of string line.</a>
<a name="ln887">void SplitCSVLineWithDelimiterForStrings(const string&amp; line, char delimiter,</a>
<a name="ln888">                                         vector&lt;string&gt;* cols);</a>
<a name="ln889"> </a>
<a name="ln890">// ----------------------------------------------------------------------</a>
<a name="ln891">// SplitStructuredLine()</a>
<a name="ln892">//    Splits a line using the given delimiter, and places the columns</a>
<a name="ln893">//    into 'cols'. This is unlike 'SplitUsing(line, &quot;,&quot;)' because you can</a>
<a name="ln894">//    define pairs of opening closing symbols inside which the delimiter should</a>
<a name="ln895">//    be ignored. If the symbol_pair string has an odd number of characters,</a>
<a name="ln896">//    the last character (which cannot be paired) will be assumed to be both an</a>
<a name="ln897">//    opening and closing symbol.</a>
<a name="ln898">//    WARNING : The input string 'line' is destroyed in the process.</a>
<a name="ln899">//    The function returns 0 if the line was parsed correctly (i.e all the</a>
<a name="ln900">//    opened braces had their closing braces) otherwise, it returns the position</a>
<a name="ln901">//    of the error.</a>
<a name="ln902">//    Example:</a>
<a name="ln903">//     SplitStructuredLine(&quot;item1,item2,{subitem1,subitem2},item4,[5,{6,7}]&quot;,</a>
<a name="ln904">//                         ',',</a>
<a name="ln905">//                         &quot;{}[]&quot;, &amp;output)</a>
<a name="ln906">//     --&gt; output = { &quot;item1&quot;, &quot;item2&quot;, &quot;{subitem1,subitem2}&quot;, &quot;item4&quot;,</a>
<a name="ln907">//                    &quot;[5,{6,7}]&quot; }</a>
<a name="ln908">//    Example2: trying to split &quot;item1,[item2,{4,5],5}&quot; will fail and the</a>
<a name="ln909">//              function will return the position of the problem : ]</a>
<a name="ln910">//</a>
<a name="ln911">// ----------------------------------------------------------------------</a>
<a name="ln912">char* SplitStructuredLine(char* line,</a>
<a name="ln913">                          char delimiter,</a>
<a name="ln914">                          const char* symbol_pairs,</a>
<a name="ln915">                          vector&lt;char*&gt;* cols);</a>
<a name="ln916"> </a>
<a name="ln917">// Similar to the function with the same name above, but splits a GStringPiece</a>
<a name="ln918">// into GStringPiece parts. Returns true if successful.</a>
<a name="ln919">bool SplitStructuredLine(GStringPiece line,</a>
<a name="ln920">                         char delimiter,</a>
<a name="ln921">                         const char* symbol_pairs,</a>
<a name="ln922">                         vector&lt;GStringPiece&gt;* cols);</a>
<a name="ln923"> </a>
<a name="ln924">// ----------------------------------------------------------------------</a>
<a name="ln925">// SplitStructuredLineWithEscapes()</a>
<a name="ln926">//    Like SplitStructuredLine but also allows characters to be escaped.</a>
<a name="ln927">//</a>
<a name="ln928">//    WARNING: the escape characters will be replicated in the output</a>
<a name="ln929">//    columns rather than being consumed, i.e. if {} were the opening and</a>
<a name="ln930">//    closing symbols, using \{ to quote a curly brace in the middle of</a>
<a name="ln931">//    an option would pass this unchanged.</a>
<a name="ln932">//</a>
<a name="ln933">//    Example:</a>
<a name="ln934">//     SplitStructuredLineWithEscapes(</a>
<a name="ln935">//       &quot;\{item1\},it\\em2,{\{subitem1\},sub\\item2},item4\,item5,[5,{6,7}]&quot;,</a>
<a name="ln936">//                     ',',</a>
<a name="ln937">//                     &quot;{}[]&quot;,</a>
<a name="ln938">//                     &amp;output)</a>
<a name="ln939">//     --&gt; output = { &quot;\{item1\}&quot;, &quot;it\\em2&quot;, &quot;{\{subitem1\},sub\\item2}&quot;,</a>
<a name="ln940">//                    &quot;item4\,item5&quot;, &quot;[5,{6,7}]&quot; }</a>
<a name="ln941">//</a>
<a name="ln942">// ----------------------------------------------------------------------</a>
<a name="ln943">char* SplitStructuredLineWithEscapes(char* line,</a>
<a name="ln944">                                     char delimiter,</a>
<a name="ln945">                                     const char* symbol_pairs,</a>
<a name="ln946">                                     vector&lt;char*&gt;* cols);</a>
<a name="ln947"> </a>
<a name="ln948">// Similar to the function with the same name above, but splits a GStringPiece</a>
<a name="ln949">// into GStringPiece parts. Returns true if successful.</a>
<a name="ln950">bool SplitStructuredLineWithEscapes(GStringPiece line,</a>
<a name="ln951">                                    char delimiter,</a>
<a name="ln952">                                    const char* symbol_pairs,</a>
<a name="ln953">                                    vector&lt;GStringPiece&gt;* cols);</a>
<a name="ln954"> </a>
<a name="ln955">// ----------------------------------------------------------------------</a>
<a name="ln956">// DEPRECATED(jgm): See the &quot;NEW API&quot; comment about this function below for</a>
<a name="ln957">// example code showing an alternative.</a>
<a name="ln958">//</a>
<a name="ln959">// SplitStringIntoKeyValues()</a>
<a name="ln960">// Split a line into a key string and a vector of value strings. The line has</a>
<a name="ln961">// the following format:</a>
<a name="ln962">//</a>
<a name="ln963">// &lt;key&gt;&lt;kvsep&gt;+&lt;vvsep&gt;*&lt;value1&gt;&lt;vvsep&gt;+&lt;value2&gt;&lt;vvsep&gt;+&lt;value3&gt;...&lt;vvsep&gt;*</a>
<a name="ln964">//</a>
<a name="ln965">// where key and value are strings; */+ means zero/one or more; &lt;kvsep&gt; is</a>
<a name="ln966">// a delimiter character to separate key and value; and &lt;vvsep&gt; is a delimiter</a>
<a name="ln967">// character to separate between values. The user can specify a bunch of</a>
<a name="ln968">// delimiter characters using a string. For example, if the user specifies</a>
<a name="ln969">// the separator string as &quot;\t &quot;, then either ' ' or '\t' or any combination</a>
<a name="ln970">// of them wil be treated as separator. For &lt;vvsep&gt;, the user can specify a</a>
<a name="ln971">// empty string to indicate there is only one value.</a>
<a name="ln972">//</a>
<a name="ln973">// Note: this function assumes the input string begins exactly with a</a>
<a name="ln974">// key. Therefore, if you use whitespaces to separate key and value, you</a>
<a name="ln975">// should not let whitespace precedes the key in the input. Otherwise, you</a>
<a name="ln976">// will get an empty string as the key.</a>
<a name="ln977">//</a>
<a name="ln978">// A line with no &lt;kvsep&gt; will return an empty string as the key, even if</a>
<a name="ln979">// &lt;key&gt; is non-empty!</a>
<a name="ln980">//</a>
<a name="ln981">// The syntax makes it impossible for a value to be the empty string.</a>
<a name="ln982">// It is possible for the number of values to be zero.</a>
<a name="ln983">//</a>
<a name="ln984">// Returns false if the line has no &lt;kvsep&gt; or if the number of values is</a>
<a name="ln985">// zero.</a>
<a name="ln986">//</a>
<a name="ln987">// ==&gt; NEW API: Consider using the new Split API defined above. &lt;==</a>
<a name="ln988">//</a>
<a name="ln989">// The SplitStringIntoKeyValues() function has some subtle and surprising</a>
<a name="ln990">// semantics in various corner cases. To avoid this the strings::Split API is</a>
<a name="ln991">// recommended. The following example shows how to split a string of delimited</a>
<a name="ln992">// key-value pairs into a vector of pairs using the strings::Split API.</a>
<a name="ln993">//</a>
<a name="ln994">//   using strings::Split;</a>
<a name="ln995">//   using strings::delimiter::AnyOf;</a>
<a name="ln996">//   using strings::delimiter::Limit;</a>
<a name="ln997">//</a>
<a name="ln998">//   pair&lt;string, GStringPiece&gt; key_values =</a>
<a name="ln999">//       Split(line, Limit(AnyOf(kv_delim), 1));</a>
<a name="ln1000">//   string key = key_values.first;</a>
<a name="ln1001">//   vector&lt;string&gt; values = Split(key_values.second, AnyOf(vv_delim));</a>
<a name="ln1002">//</a>
<a name="ln1003">// ----------------------------------------------------------------------</a>
<a name="ln1004">bool SplitStringIntoKeyValues(const string&amp; line,</a>
<a name="ln1005">                              const string&amp; key_value_delimiters,</a>
<a name="ln1006">                              const string&amp; value_value_delimiters,</a>
<a name="ln1007">                              string* key, vector&lt;string&gt;* values);</a>
<a name="ln1008"> </a>
<a name="ln1009">// ----------------------------------------------------------------------</a>
<a name="ln1010">// SplitStringIntoKeyValuePairs()</a>
<a name="ln1011">// Split a line into a vector of &lt;key, value&gt; pairs. The line has</a>
<a name="ln1012">// the following format:</a>
<a name="ln1013">//</a>
<a name="ln1014">// &lt;kvpsep&gt;*&lt;key1&gt;&lt;kvsep&gt;+&lt;value1&gt;&lt;kvpsep&gt;+&lt;key2&gt;&lt;kvsep&gt;+&lt;value2&gt;...&lt;kvpsep&gt;*</a>
<a name="ln1015">//</a>
<a name="ln1016">// Where key and value are strings; */+ means zero/one or more. &lt;kvsep&gt; is</a>
<a name="ln1017">// a delimiter character to separate key and value and &lt;kvpsep&gt; is a delimiter</a>
<a name="ln1018">// character to separate key value pairs. The user can specify a bunch of</a>
<a name="ln1019">// delimiter characters using a string.</a>
<a name="ln1020">//</a>
<a name="ln1021">// Note: this function assumes each key-value pair begins exactly with a</a>
<a name="ln1022">// key. Therefore, if you use whitespaces to separate key and value, you</a>
<a name="ln1023">// should not let whitespace precede the key in the pair. Otherwise, you</a>
<a name="ln1024">// will get an empty string as the key.</a>
<a name="ln1025">//</a>
<a name="ln1026">// A pair with no &lt;kvsep&gt; will return empty strings as the key and value,</a>
<a name="ln1027">// even if &lt;key&gt; is non-empty!</a>
<a name="ln1028">//</a>
<a name="ln1029">// Returns false for pairs with no &lt;kvsep&gt; specified and for pairs with</a>
<a name="ln1030">// empty strings as values.</a>
<a name="ln1031">//</a>
<a name="ln1032">// ==&gt; NEW API: Consider using the new Split API defined above. &lt;==</a>
<a name="ln1033">//</a>
<a name="ln1034">// The SplitStringIntoKeyValuePairs() function has some subtle and surprising</a>
<a name="ln1035">// semantics in various corner cases. To avoid this the strings::Split API is</a>
<a name="ln1036">// recommended. The following example shows how to split a string of delimited</a>
<a name="ln1037">// key-value pairs into a vector of pairs using the strings::Split API.</a>
<a name="ln1038">//</a>
<a name="ln1039">//   using strings::SkipEmpty;</a>
<a name="ln1040">//   using strings::Split;</a>
<a name="ln1041">//   using strings::delimiter::AnyOf;</a>
<a name="ln1042">//   using strings::delimiter::Limit;</a>
<a name="ln1043">//</a>
<a name="ln1044">//   vector&lt;pair&lt;string, string&gt;&gt; pairs;  // or even map&lt;string, string&gt;</a>
<a name="ln1045">//   for (GStringPiece sp : Split(line, AnyOf(pair_delim), SkipEmpty())) {</a>
<a name="ln1046">//     pairs.push_back(Split(sp, Limit(AnyOf(kv_delim), 1), SkipEmpty()));</a>
<a name="ln1047">//   }</a>
<a name="ln1048">//</a>
<a name="ln1049">// ----------------------------------------------------------------------</a>
<a name="ln1050">bool SplitStringIntoKeyValuePairs(const string&amp; line,</a>
<a name="ln1051">                                  const string&amp; key_value_delimiters,</a>
<a name="ln1052">                                  const string&amp; key_value_pair_delimiters,</a>
<a name="ln1053">                                  vector&lt;pair&lt;string, string&gt; &gt;* kv_pairs);</a>
<a name="ln1054"> </a>
<a name="ln1055"> </a>
<a name="ln1056">// ----------------------------------------------------------------------</a>
<a name="ln1057">// SplitLeadingDec32Values()</a>
<a name="ln1058">// SplitLeadingDec64Values()</a>
<a name="ln1059">//    A simple parser for space-separated decimal int32/int64 values.</a>
<a name="ln1060">//    Appends parsed integers to the end of the result vector, stopping</a>
<a name="ln1061">//    at the first unparsable spot.  Skips past leading and repeated</a>
<a name="ln1062">//    whitespace (does not consume trailing whitespace), and returns</a>
<a name="ln1063">//    a pointer beyond the last character parsed.</a>
<a name="ln1064">// --------------------------------------------------------------------</a>
<a name="ln1065">const char* SplitLeadingDec32Values(const char* next, vector&lt;int32&gt;* result);</a>
<a name="ln1066">const char* SplitLeadingDec64Values(const char* next, vector&lt;int64&gt;* result);</a>
<a name="ln1067"> </a>
<a name="ln1068">// ----------------------------------------------------------------------</a>
<a name="ln1069">// SplitOneIntToken()</a>
<a name="ln1070">// SplitOneInt32Token()</a>
<a name="ln1071">// SplitOneUint32Token()</a>
<a name="ln1072">// SplitOneInt64Token()</a>
<a name="ln1073">// SplitOneUint64Token()</a>
<a name="ln1074">// SplitOneDoubleToken()</a>
<a name="ln1075">// SplitOneFloatToken()</a>
<a name="ln1076">//   Parse a single &quot;delim&quot; delimited number from &quot;*source&quot; into &quot;*value&quot;.</a>
<a name="ln1077">//   Modify *source to point after the delimiter.</a>
<a name="ln1078">//   If no delimiter is present after the number, set *source to NULL.</a>
<a name="ln1079">//</a>
<a name="ln1080">//   If the start of *source is not an number, return false.</a>
<a name="ln1081">//   If the int is followed by the null character, return true.</a>
<a name="ln1082">//   If the int is not followed by a character from delim, return false.</a>
<a name="ln1083">//   If *source is NULL, return false.</a>
<a name="ln1084">//</a>
<a name="ln1085">//   They cannot handle decimal numbers with leading 0s, since they will be</a>
<a name="ln1086">//   treated as octal.</a>
<a name="ln1087">// ----------------------------------------------------------------------</a>
<a name="ln1088">bool SplitOneIntToken(const char** source, const char* delim,</a>
<a name="ln1089">                      int* value);</a>
<a name="ln1090">bool SplitOneInt32Token(const char** source, const char* delim,</a>
<a name="ln1091">                        int32* value);</a>
<a name="ln1092">bool SplitOneUint32Token(const char** source, const char* delim,</a>
<a name="ln1093">                         uint32* value);</a>
<a name="ln1094">bool SplitOneInt64Token(const char** source, const char* delim,</a>
<a name="ln1095">                        int64* value);</a>
<a name="ln1096">bool SplitOneUint64Token(const char** source, const char* delim,</a>
<a name="ln1097">                         uint64* value);</a>
<a name="ln1098">bool SplitOneDoubleToken(const char** source, const char* delim,</a>
<a name="ln1099">                         double* value);</a>
<a name="ln1100">bool SplitOneFloatToken(const char** source, const char* delim,</a>
<a name="ln1101">                        float* value);</a>
<a name="ln1102"> </a>
<a name="ln1103">// Some aliases, so that the function names are standardized against the names</a>
<a name="ln1104">// of the reflection setters/getters in proto2. This makes it easier to use</a>
<a name="ln1105">// certain macros with reflection when creating custom text formats for protos.</a>
<a name="ln1106"> </a>
<a name="ln1107">inline bool SplitOneUInt32Token(const char** source, const char* delim,</a>
<a name="ln1108">                         uint32* value) {</a>
<a name="ln1109">  return SplitOneUint32Token(source, delim, value);</a>
<a name="ln1110">}</a>
<a name="ln1111"> </a>
<a name="ln1112">inline bool SplitOneUInt64Token(const char** source, const char* delim,</a>
<a name="ln1113">                         uint64* value) {</a>
<a name="ln1114">  return SplitOneUint64Token(source, delim, value);</a>
<a name="ln1115">}</a>
<a name="ln1116"> </a>
<a name="ln1117">// ----------------------------------------------------------------------</a>
<a name="ln1118">// SplitOneDecimalIntToken()</a>
<a name="ln1119">// SplitOneDecimalInt32Token()</a>
<a name="ln1120">// SplitOneDecimalUint32Token()</a>
<a name="ln1121">// SplitOneDecimalInt64Token()</a>
<a name="ln1122">// SplitOneDecimalUint64Token()</a>
<a name="ln1123">// Parse a single &quot;delim&quot;-delimited number from &quot;*source&quot; into &quot;*value&quot;.</a>
<a name="ln1124">// Unlike SplitOneIntToken, etc., this function always interprets</a>
<a name="ln1125">// the numbers as decimal.</a>
<a name="ln1126">bool SplitOneDecimalIntToken(const char** source, const char* delim,</a>
<a name="ln1127">                             int* value);</a>
<a name="ln1128">bool SplitOneDecimalInt32Token(const char** source, const char* delim,</a>
<a name="ln1129">                               int32* value);</a>
<a name="ln1130">bool SplitOneDecimalUint32Token(const char** source, const char* delim,</a>
<a name="ln1131">                                uint32* value);</a>
<a name="ln1132">bool SplitOneDecimalInt64Token(const char** source, const char* delim,</a>
<a name="ln1133">                               int64* value);</a>
<a name="ln1134">bool SplitOneDecimalUint64Token(const char** source, const char* delim,</a>
<a name="ln1135">                                uint64* value);</a>
<a name="ln1136"> </a>
<a name="ln1137">// ----------------------------------------------------------------------</a>
<a name="ln1138">// SplitOneHexUint32Token()</a>
<a name="ln1139">// SplitOneHexUint64Token()</a>
<a name="ln1140">// Once more, for hexadecimal numbers (unsigned only).</a>
<a name="ln1141">bool SplitOneHexUint32Token(const char** source, const char* delim,</a>
<a name="ln1142">                            uint32* value);</a>
<a name="ln1143">bool SplitOneHexUint64Token(const char** source, const char* delim,</a>
<a name="ln1144">                            uint64* value);</a>
<a name="ln1145"> </a>
<a name="ln1146"> </a>
<a name="ln1147">// ###################### TEMPLATE INSTANTIATIONS BELOW #######################</a>
<a name="ln1148"> </a>
<a name="ln1149">// SplitStringAndParse() -- see description above</a>
<a name="ln1150">template &lt;class T&gt;</a>
<a name="ln1151">bool SplitStringAndParse(GStringPiece source, GStringPiece delim,</a>
<a name="ln1152">                         bool (*parse)(const string&amp; str, T* value),</a>
<a name="ln1153">                         vector&lt;T&gt;* result) {</a>
<a name="ln1154">  return SplitStringAndParseToList(source, delim, parse, result);</a>
<a name="ln1155">}</a>
<a name="ln1156"> </a>
<a name="ln1157">namespace strings {</a>
<a name="ln1158">namespace internal {</a>
<a name="ln1159"> </a>
<a name="ln1160">template &lt;class Container, class InsertPolicy&gt;</a>
<a name="ln1161">bool SplitStringAndParseToInserter(</a>
<a name="ln1162">    GStringPiece source, GStringPiece delim,</a>
<a name="ln1163">    bool (*parse)(const string&amp; str, typename Container::value_type* value),</a>
<a name="ln1164">    Container* result, InsertPolicy insert_policy) {</a>
<a name="ln1165">  CHECK(NULL != parse);</a>
<a name="ln1166">  CHECK(NULL != result);</a>
<a name="ln1167">  CHECK(NULL != delim.data());</a>
<a name="ln1168">  CHECK_GT(delim.size(), 0);</a>
<a name="ln1169">  bool retval = true;</a>
<a name="ln1170">  vector&lt;GStringPiece&gt; pieces = strings::Split(source,</a>
<a name="ln1171">                                              strings::delimiter::AnyOf(delim),</a>
<a name="ln1172">                                              strings::SkipEmpty());</a>
<a name="ln1173">  for (const auto&amp; piece : pieces) {</a>
<a name="ln1174">    typename Container::value_type t;</a>
<a name="ln1175">    if (parse(piece.as_string(), &amp;t)) {</a>
<a name="ln1176">      insert_policy(result, t);</a>
<a name="ln1177">    } else {</a>
<a name="ln1178">      retval = false;</a>
<a name="ln1179">    }</a>
<a name="ln1180">  }</a>
<a name="ln1181">  return retval;</a>
<a name="ln1182">}</a>
<a name="ln1183"> </a>
<a name="ln1184">// Cannot use output iterator here (e.g. std::inserter, std::back_inserter)</a>
<a name="ln1185">// because some callers use non-standard containers that don't have iterators,</a>
<a name="ln1186">// only an insert() or push_back() method.</a>
<a name="ln1187">struct BasicInsertPolicy {</a>
<a name="ln1188">  template &lt;class C, class V&gt;</a>
<a name="ln1189">  void operator()(C* c, const V&amp; v) const { c-&gt;insert(v); }</a>
<a name="ln1190">};</a>
<a name="ln1191"> </a>
<a name="ln1192">struct BackInsertPolicy {</a>
<a name="ln1193">  template &lt;class C, class V&gt;</a>
<a name="ln1194">  void operator()(C* c, const V&amp; v) const { c-&gt;push_back(v); }</a>
<a name="ln1195">};</a>
<a name="ln1196"> </a>
<a name="ln1197">}  // namespace internal</a>
<a name="ln1198">}  // namespace strings</a>
<a name="ln1199"> </a>
<a name="ln1200">// SplitStringAndParseToContainer() -- see description above</a>
<a name="ln1201">template &lt;class Container&gt;</a>
<a name="ln1202">bool SplitStringAndParseToContainer(</a>
<a name="ln1203">    GStringPiece source, GStringPiece delim,</a>
<a name="ln1204">    bool (*parse)(const string&amp; str, typename Container::value_type* value),</a>
<a name="ln1205">    Container* result) {</a>
<a name="ln1206">  return strings::internal::SplitStringAndParseToInserter(</a>
<a name="ln1207">      source, delim, parse, result, strings::internal::BasicInsertPolicy());</a>
<a name="ln1208">}</a>
<a name="ln1209"> </a>
<a name="ln1210">// SplitStringAndParseToList() -- see description above</a>
<a name="ln1211">template &lt;class List&gt;</a>
<a name="ln1212">bool SplitStringAndParseToList(</a>
<a name="ln1213">    GStringPiece source, GStringPiece delim,</a>
<a name="ln1214">    bool (*parse)(const string&amp; str, typename List::value_type* value),</a>
<a name="ln1215">    List* result) {</a>
<a name="ln1216">  return strings::internal::SplitStringAndParseToInserter(</a>
<a name="ln1217">      source, delim, parse, result, strings::internal::BackInsertPolicy());</a>
<a name="ln1218">}</a>
<a name="ln1219"> </a>
<a name="ln1220">// END DOXYGEN SplitFunctions grouping</a>
<a name="ln1221">/* @} */</a>
<a name="ln1222"> </a>
<a name="ln1223">#endif  // STRINGS_SPLIT_H_</a>

</code></pre>
<div class="balloon" rel="1165"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1166"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1167"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
