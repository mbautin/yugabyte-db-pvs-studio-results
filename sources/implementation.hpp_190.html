
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>implementation.hpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Copyright (C) 2003-2004 Jeremy B. Maitin-Shepard.</a>
<a name="ln2">// Copyright (C) 2005-2016 Daniel James</a>
<a name="ln3">//</a>
<a name="ln4">// Distributed under the Boost Software License, Version 1.0. (See accompanying</a>
<a name="ln5">// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)</a>
<a name="ln6"> </a>
<a name="ln7">#ifndef BOOST_UNORDERED_DETAIL_IMPLEMENTATION_HPP</a>
<a name="ln8">#define BOOST_UNORDERED_DETAIL_IMPLEMENTATION_HPP</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;boost/config.hpp&gt;</a>
<a name="ln11">#if defined(BOOST_HAS_PRAGMA_ONCE)</a>
<a name="ln12">#pragma once</a>
<a name="ln13">#endif</a>
<a name="ln14"> </a>
<a name="ln15">#include &lt;boost/assert.hpp&gt;</a>
<a name="ln16">#include &lt;boost/core/no_exceptions_support.hpp&gt;</a>
<a name="ln17">#include &lt;boost/core/pointer_traits.hpp&gt;</a>
<a name="ln18">#include &lt;boost/detail/select_type.hpp&gt;</a>
<a name="ln19">#include &lt;boost/limits.hpp&gt;</a>
<a name="ln20">#include &lt;boost/move/move.hpp&gt;</a>
<a name="ln21">#include &lt;boost/preprocessor/arithmetic/inc.hpp&gt;</a>
<a name="ln22">#include &lt;boost/preprocessor/cat.hpp&gt;</a>
<a name="ln23">#include &lt;boost/preprocessor/repetition/enum.hpp&gt;</a>
<a name="ln24">#include &lt;boost/preprocessor/repetition/enum_binary_params.hpp&gt;</a>
<a name="ln25">#include &lt;boost/preprocessor/repetition/enum_params.hpp&gt;</a>
<a name="ln26">#include &lt;boost/preprocessor/repetition/repeat_from_to.hpp&gt;</a>
<a name="ln27">#include &lt;boost/preprocessor/seq/enum.hpp&gt;</a>
<a name="ln28">#include &lt;boost/preprocessor/seq/size.hpp&gt;</a>
<a name="ln29">#include &lt;boost/swap.hpp&gt;</a>
<a name="ln30">#include &lt;boost/throw_exception.hpp&gt;</a>
<a name="ln31">#include &lt;boost/tuple/tuple.hpp&gt;</a>
<a name="ln32">#include &lt;boost/type_traits/add_lvalue_reference.hpp&gt;</a>
<a name="ln33">#include &lt;boost/type_traits/aligned_storage.hpp&gt;</a>
<a name="ln34">#include &lt;boost/type_traits/alignment_of.hpp&gt;</a>
<a name="ln35">#include &lt;boost/type_traits/integral_constant.hpp&gt;</a>
<a name="ln36">#include &lt;boost/type_traits/is_base_of.hpp&gt;</a>
<a name="ln37">#include &lt;boost/type_traits/is_class.hpp&gt;</a>
<a name="ln38">#include &lt;boost/type_traits/is_empty.hpp&gt;</a>
<a name="ln39">#include &lt;boost/type_traits/is_nothrow_move_assignable.hpp&gt;</a>
<a name="ln40">#include &lt;boost/type_traits/is_nothrow_move_constructible.hpp&gt;</a>
<a name="ln41">#include &lt;boost/type_traits/is_nothrow_swappable.hpp&gt;</a>
<a name="ln42">#include &lt;boost/type_traits/is_same.hpp&gt;</a>
<a name="ln43">#include &lt;boost/type_traits/remove_const.hpp&gt;</a>
<a name="ln44">#include &lt;boost/unordered/detail/fwd.hpp&gt;</a>
<a name="ln45">#include &lt;boost/utility/addressof.hpp&gt;</a>
<a name="ln46">#include &lt;boost/utility/enable_if.hpp&gt;</a>
<a name="ln47">#include &lt;cmath&gt;</a>
<a name="ln48">#include &lt;iterator&gt;</a>
<a name="ln49">#include &lt;stdexcept&gt;</a>
<a name="ln50">#include &lt;utility&gt;</a>
<a name="ln51"> </a>
<a name="ln52">#if !defined(BOOST_NO_CXX11_HDR_TYPE_TRAITS)</a>
<a name="ln53">#include &lt;type_traits&gt;</a>
<a name="ln54">#endif</a>
<a name="ln55"> </a>
<a name="ln56">////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln57">// Configuration</a>
<a name="ln58">//</a>
<a name="ln59">// Unless documented elsewhere these configuration macros should be considered</a>
<a name="ln60">// an implementation detail, I'll try not to break them, but you never know.</a>
<a name="ln61"> </a>
<a name="ln62">// Use Sun C++ workarounds</a>
<a name="ln63">// I'm not sure which versions of the compiler require these workarounds, so</a>
<a name="ln64">// I'm just using them of everything older than the current test compilers</a>
<a name="ln65">// (as of May 2017).</a>
<a name="ln66"> </a>
<a name="ln67">#if !defined(BOOST_UNORDERED_SUN_WORKAROUNDS1)</a>
<a name="ln68">#if BOOST_COMP_SUNPRO &amp;&amp; BOOST_COMP_SUNPRO &lt; BOOST_VERSION_NUMBER(5, 20, 0)</a>
<a name="ln69">#define BOOST_UNORDERED_SUN_WORKAROUNDS1 1</a>
<a name="ln70">#else</a>
<a name="ln71">#define BOOST_UNORDERED_SUN_WORKAROUNDS1 0</a>
<a name="ln72">#endif</a>
<a name="ln73">#endif</a>
<a name="ln74"> </a>
<a name="ln75">// BOOST_UNORDERED_EMPLACE_LIMIT = The maximum number of parameters in</a>
<a name="ln76">// emplace (not including things like hints). Don't set it to a lower value, as</a>
<a name="ln77">// that might break something.</a>
<a name="ln78"> </a>
<a name="ln79">#if !defined BOOST_UNORDERED_EMPLACE_LIMIT</a>
<a name="ln80">#define BOOST_UNORDERED_EMPLACE_LIMIT 10</a>
<a name="ln81">#endif</a>
<a name="ln82"> </a>
<a name="ln83">// BOOST_UNORDERED_USE_ALLOCATOR_TRAITS - Pick which version of</a>
<a name="ln84">// allocator_traits to use.</a>
<a name="ln85">//</a>
<a name="ln86">// 0 = Own partial implementation</a>
<a name="ln87">// 1 = std::allocator_traits</a>
<a name="ln88">// 2 = boost::container::allocator_traits</a>
<a name="ln89"> </a>
<a name="ln90">#if !defined(BOOST_UNORDERED_USE_ALLOCATOR_TRAITS)</a>
<a name="ln91">#if !defined(BOOST_NO_CXX11_ALLOCATOR)</a>
<a name="ln92">#define BOOST_UNORDERED_USE_ALLOCATOR_TRAITS 1</a>
<a name="ln93">#elif defined(BOOST_MSVC)</a>
<a name="ln94">#if BOOST_MSVC &lt; 1400</a>
<a name="ln95">// Use container's allocator_traits for older versions of Visual</a>
<a name="ln96">// C++ as I don't test with them.</a>
<a name="ln97">#define BOOST_UNORDERED_USE_ALLOCATOR_TRAITS 2</a>
<a name="ln98">#endif</a>
<a name="ln99">#endif</a>
<a name="ln100">#endif</a>
<a name="ln101"> </a>
<a name="ln102">#if !defined(BOOST_UNORDERED_USE_ALLOCATOR_TRAITS)</a>
<a name="ln103">#define BOOST_UNORDERED_USE_ALLOCATOR_TRAITS 0</a>
<a name="ln104">#endif</a>
<a name="ln105"> </a>
<a name="ln106">// BOOST_UNORDERED_TUPLE_ARGS</a>
<a name="ln107">//</a>
<a name="ln108">// Maximum number of std::tuple members to support, or 0 if std::tuple</a>
<a name="ln109">// isn't avaiable. More are supported when full C++11 is used.</a>
<a name="ln110"> </a>
<a name="ln111">// Already defined, so do nothing</a>
<a name="ln112">#if defined(BOOST_UNORDERED_TUPLE_ARGS)</a>
<a name="ln113"> </a>
<a name="ln114">// Assume if we have C++11 tuple it's properly variadic,</a>
<a name="ln115">// and just use a max number of 10 arguments.</a>
<a name="ln116">#elif !defined(BOOST_NO_CXX11_HDR_TUPLE)</a>
<a name="ln117">#define BOOST_UNORDERED_TUPLE_ARGS 10</a>
<a name="ln118"> </a>
<a name="ln119">// Visual C++ has a decent enough tuple for piecewise construction,</a>
<a name="ln120">// so use that if available, using _VARIADIC_MAX for the maximum</a>
<a name="ln121">// number of parameters. Note that this comes after the check</a>
<a name="ln122">// for a full C++11 tuple.</a>
<a name="ln123">#elif defined(BOOST_MSVC)</a>
<a name="ln124">#if !BOOST_UNORDERED_HAVE_PIECEWISE_CONSTRUCT</a>
<a name="ln125">#define BOOST_UNORDERED_TUPLE_ARGS 0</a>
<a name="ln126">#elif defined(_VARIADIC_MAX)</a>
<a name="ln127">#define BOOST_UNORDERED_TUPLE_ARGS _VARIADIC_MAX</a>
<a name="ln128">#else</a>
<a name="ln129">#define BOOST_UNORDERED_TUPLE_ARGS 5</a>
<a name="ln130">#endif</a>
<a name="ln131"> </a>
<a name="ln132">// Assume that we don't have std::tuple</a>
<a name="ln133">#else</a>
<a name="ln134">#define BOOST_UNORDERED_TUPLE_ARGS 0</a>
<a name="ln135">#endif</a>
<a name="ln136"> </a>
<a name="ln137">#if BOOST_UNORDERED_TUPLE_ARGS</a>
<a name="ln138">#include &lt;tuple&gt;</a>
<a name="ln139">#endif</a>
<a name="ln140"> </a>
<a name="ln141">// BOOST_UNORDERED_CXX11_CONSTRUCTION</a>
<a name="ln142">//</a>
<a name="ln143">// Use C++11 construction, requires variadic arguments, good construct support</a>
<a name="ln144">// in allocator_traits and piecewise construction of std::pair</a>
<a name="ln145">// Otherwise allocators aren't used for construction/destruction</a>
<a name="ln146"> </a>
<a name="ln147">#if BOOST_UNORDERED_HAVE_PIECEWISE_CONSTRUCT &amp;&amp;                                \</a>
<a name="ln148">  !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) &amp;&amp; BOOST_UNORDERED_TUPLE_ARGS</a>
<a name="ln149">#if BOOST_COMP_SUNPRO &amp;&amp; BOOST_LIB_STD_GNU</a>
<a name="ln150">// Sun C++ std::pair piecewise construction doesn't seem to be exception safe.</a>
<a name="ln151">// (At least for Sun C++ 12.5 using libstdc++).</a>
<a name="ln152">#define BOOST_UNORDERED_CXX11_CONSTRUCTION 0</a>
<a name="ln153">#elif BOOST_COMP_GNUC &amp;&amp; BOOST_COMP_GNUC &lt; BOOST_VERSION_NUMBER(4, 7, 0)</a>
<a name="ln154">// Piecewise construction in GCC 4.6 doesn't work for uncopyable types.</a>
<a name="ln155">#define BOOST_UNORDERED_CXX11_CONSTRUCTION 0</a>
<a name="ln156">#elif BOOST_UNORDERED_USE_ALLOCATOR_TRAITS == 0 &amp;&amp;                             \</a>
<a name="ln157">  !defined(BOOST_NO_SFINAE_EXPR)</a>
<a name="ln158">#define BOOST_UNORDERED_CXX11_CONSTRUCTION 1</a>
<a name="ln159">#elif BOOST_UNORDERED_USE_ALLOCATOR_TRAITS == 1</a>
<a name="ln160">#define BOOST_UNORDERED_CXX11_CONSTRUCTION 1</a>
<a name="ln161">#endif</a>
<a name="ln162">#endif</a>
<a name="ln163"> </a>
<a name="ln164">#if !defined(BOOST_UNORDERED_CXX11_CONSTRUCTION)</a>
<a name="ln165">#define BOOST_UNORDERED_CXX11_CONSTRUCTION 0</a>
<a name="ln166">#endif</a>
<a name="ln167"> </a>
<a name="ln168">// BOOST_UNORDERED_SUPPRESS_DEPRECATED</a>
<a name="ln169">//</a>
<a name="ln170">// Define to stop deprecation attributes</a>
<a name="ln171"> </a>
<a name="ln172">#if defined(BOOST_UNORDERED_SUPPRESS_DEPRECATED)</a>
<a name="ln173">#define BOOST_UNORDERED_DEPRECATED(msg)</a>
<a name="ln174">#endif</a>
<a name="ln175"> </a>
<a name="ln176">// BOOST_UNORDERED_DEPRECATED</a>
<a name="ln177">//</a>
<a name="ln178">// Wrapper around various depreaction attributes.</a>
<a name="ln179"> </a>
<a name="ln180">#if defined(__has_cpp_attribute) &amp;&amp;                                            \</a>
<a name="ln181">  (!defined(__cplusplus) || __cplusplus &gt;= 201402)</a>
<a name="ln182">#if __has_cpp_attribute(deprecated) &amp;&amp; !defined(BOOST_UNORDERED_DEPRECATED)</a>
<a name="ln183">#define BOOST_UNORDERED_DEPRECATED(msg) [[deprecated(msg)]]</a>
<a name="ln184">#endif</a>
<a name="ln185">#endif</a>
<a name="ln186"> </a>
<a name="ln187">#if !defined(BOOST_UNORDERED_DEPRECATED)</a>
<a name="ln188">#if defined(__GNUC__) &amp;&amp; __GNUC__ &gt;= 4</a>
<a name="ln189">#define BOOST_UNORDERED_DEPRECATED(msg) __attribute__((deprecated))</a>
<a name="ln190">#elif defined(_MSC_VER) &amp;&amp; _MSC_VER &gt;= 1400</a>
<a name="ln191">#define BOOST_UNORDERED_DEPRECATED(msg) __declspec(deprecated(msg))</a>
<a name="ln192">#elif defined(_MSC_VER) &amp;&amp; _MSC_VER &gt;= 1310</a>
<a name="ln193">#define BOOST_UNORDERED_DEPRECATED(msg) __declspec(deprecated)</a>
<a name="ln194">#else</a>
<a name="ln195">#define BOOST_UNORDERED_DEPRECATED(msg)</a>
<a name="ln196">#endif</a>
<a name="ln197">#endif</a>
<a name="ln198"> </a>
<a name="ln199">// BOOST_UNORDERED_TEMPLATE_DEDUCTION_GUIDES</a>
<a name="ln200"> </a>
<a name="ln201">#if !defined(BOOST_UNORDERED_TEMPLATE_DEDUCTION_GUIDES)</a>
<a name="ln202">#if BOOST_COMP_CLANG &amp;&amp; __cplusplus &gt;= 201703</a>
<a name="ln203">#define BOOST_UNORDERED_TEMPLATE_DEDUCTION_GUIDES 1</a>
<a name="ln204">#endif</a>
<a name="ln205">#endif</a>
<a name="ln206"> </a>
<a name="ln207">#if !defined(BOOST_UNORDERED_TEMPLATE_DEDUCTION_GUIDES)</a>
<a name="ln208">#define BOOST_UNORDERED_TEMPLATE_DEDUCTION_GUIDES 0</a>
<a name="ln209">#endif</a>
<a name="ln210"> </a>
<a name="ln211">namespace boost {</a>
<a name="ln212">  namespace unordered {</a>
<a name="ln213">    namespace iterator_detail {</a>
<a name="ln214">      template &lt;typename Node&gt; struct iterator;</a>
<a name="ln215">      template &lt;typename Node&gt; struct c_iterator;</a>
<a name="ln216">      template &lt;typename Node&gt; struct l_iterator;</a>
<a name="ln217">      template &lt;typename Node&gt; struct cl_iterator;</a>
<a name="ln218">    }</a>
<a name="ln219">  }</a>
<a name="ln220">}</a>
<a name="ln221"> </a>
<a name="ln222">namespace boost {</a>
<a name="ln223">  namespace unordered {</a>
<a name="ln224">    namespace detail {</a>
<a name="ln225"> </a>
<a name="ln226">      template &lt;typename Types&gt; struct table;</a>
<a name="ln227">      template &lt;typename NodePointer&gt; struct bucket;</a>
<a name="ln228">      struct ptr_bucket;</a>
<a name="ln229"> </a>
<a name="ln230">      template &lt;typename A, typename T&gt; struct node;</a>
<a name="ln231">      template &lt;typename T&gt; struct ptr_node;</a>
<a name="ln232"> </a>
<a name="ln233">      static const float minimum_max_load_factor = 1e-3f;</a>
<a name="ln234">      static const std::size_t default_bucket_count = 11;</a>
<a name="ln235"> </a>
<a name="ln236">      struct move_tag</a>
<a name="ln237">      {</a>
<a name="ln238">      };</a>
<a name="ln239"> </a>
<a name="ln240">      struct empty_emplace</a>
<a name="ln241">      {</a>
<a name="ln242">      };</a>
<a name="ln243"> </a>
<a name="ln244">      struct no_key</a>
<a name="ln245">      {</a>
<a name="ln246">        no_key() {}</a>
<a name="ln247">        template &lt;class T&gt; no_key(T const&amp;) {}</a>
<a name="ln248">      };</a>
<a name="ln249"> </a>
<a name="ln250">      namespace func {</a>
<a name="ln251">        template &lt;class T&gt; inline void ignore_unused_variable_warning(T const&amp;)</a>
<a name="ln252">        {</a>
<a name="ln253">        }</a>
<a name="ln254">      }</a>
<a name="ln255"> </a>
<a name="ln256">      //////////////////////////////////////////////////////////////////////////</a>
<a name="ln257">      // iterator SFINAE</a>
<a name="ln258"> </a>
<a name="ln259">      template &lt;typename I&gt;</a>
<a name="ln260">      struct is_forward : boost::is_base_of&lt;std::forward_iterator_tag,</a>
<a name="ln261">                            typename std::iterator_traits&lt;I&gt;::iterator_category&gt;</a>
<a name="ln262">      {</a>
<a name="ln263">      };</a>
<a name="ln264"> </a>
<a name="ln265">      template &lt;typename I, typename ReturnType&gt;</a>
<a name="ln266">      struct enable_if_forward</a>
<a name="ln267">        : boost::enable_if_c&lt;boost::unordered::detail::is_forward&lt;I&gt;::value,</a>
<a name="ln268">            ReturnType&gt;</a>
<a name="ln269">      {</a>
<a name="ln270">      };</a>
<a name="ln271"> </a>
<a name="ln272">      template &lt;typename I, typename ReturnType&gt;</a>
<a name="ln273">      struct disable_if_forward</a>
<a name="ln274">        : boost::disable_if_c&lt;boost::unordered::detail::is_forward&lt;I&gt;::value,</a>
<a name="ln275">            ReturnType&gt;</a>
<a name="ln276">      {</a>
<a name="ln277">      };</a>
<a name="ln278">    }</a>
<a name="ln279">  }</a>
<a name="ln280">}</a>
<a name="ln281"> </a>
<a name="ln282">////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln283">// primes</a>
<a name="ln284"> </a>
<a name="ln285">// clang-format off</a>
<a name="ln286">#define BOOST_UNORDERED_PRIMES \</a>
<a name="ln287">    (17ul)(29ul)(37ul)(53ul)(67ul)(79ul) \</a>
<a name="ln288">    (97ul)(131ul)(193ul)(257ul)(389ul)(521ul)(769ul) \</a>
<a name="ln289">    (1031ul)(1543ul)(2053ul)(3079ul)(6151ul)(12289ul)(24593ul) \</a>
<a name="ln290">    (49157ul)(98317ul)(196613ul)(393241ul)(786433ul) \</a>
<a name="ln291">    (1572869ul)(3145739ul)(6291469ul)(12582917ul)(25165843ul) \</a>
<a name="ln292">    (50331653ul)(100663319ul)(201326611ul)(402653189ul)(805306457ul) \</a>
<a name="ln293">    (1610612741ul)(3221225473ul)(4294967291ul)</a>
<a name="ln294">// clang-format on</a>
<a name="ln295"> </a>
<a name="ln296">namespace boost {</a>
<a name="ln297">  namespace unordered {</a>
<a name="ln298">    namespace detail {</a>
<a name="ln299">      template &lt;class T&gt; struct prime_list_template</a>
<a name="ln300">      {</a>
<a name="ln301">        static std::size_t const value[];</a>
<a name="ln302"> </a>
<a name="ln303">#if !BOOST_UNORDERED_SUN_WORKAROUNDS1</a>
<a name="ln304">        static std::ptrdiff_t const length;</a>
<a name="ln305">#else</a>
<a name="ln306">        static std::ptrdiff_t const length =</a>
<a name="ln307">          BOOST_PP_SEQ_SIZE(BOOST_UNORDERED_PRIMES);</a>
<a name="ln308">#endif</a>
<a name="ln309">      };</a>
<a name="ln310"> </a>
<a name="ln311">      template &lt;class T&gt;</a>
<a name="ln312">      std::size_t const prime_list_template&lt;T&gt;::value[] = {</a>
<a name="ln313">        BOOST_PP_SEQ_ENUM(BOOST_UNORDERED_PRIMES)};</a>
<a name="ln314"> </a>
<a name="ln315">#if !BOOST_UNORDERED_SUN_WORKAROUNDS1</a>
<a name="ln316">      template &lt;class T&gt;</a>
<a name="ln317">      std::ptrdiff_t const prime_list_template&lt;T&gt;::length = BOOST_PP_SEQ_SIZE(</a>
<a name="ln318">        BOOST_UNORDERED_PRIMES);</a>
<a name="ln319">#endif</a>
<a name="ln320"> </a>
<a name="ln321">#undef BOOST_UNORDERED_PRIMES</a>
<a name="ln322"> </a>
<a name="ln323">      typedef prime_list_template&lt;std::size_t&gt; prime_list;</a>
<a name="ln324"> </a>
<a name="ln325">      // no throw</a>
<a name="ln326">      inline std::size_t next_prime(std::size_t num)</a>
<a name="ln327">      {</a>
<a name="ln328">        std::size_t const* const prime_list_begin = prime_list::value;</a>
<a name="ln329">        std::size_t const* const prime_list_end =</a>
<a name="ln330">          prime_list_begin + prime_list::length;</a>
<a name="ln331">        std::size_t const* bound =</a>
<a name="ln332">          std::lower_bound(prime_list_begin, prime_list_end, num);</a>
<a name="ln333">        if (bound == prime_list_end)</a>
<a name="ln334">          bound--;</a>
<a name="ln335">        return *bound;</a>
<a name="ln336">      }</a>
<a name="ln337"> </a>
<a name="ln338">      // no throw</a>
<a name="ln339">      inline std::size_t prev_prime(std::size_t num)</a>
<a name="ln340">      {</a>
<a name="ln341">        std::size_t const* const prime_list_begin = prime_list::value;</a>
<a name="ln342">        std::size_t const* const prime_list_end =</a>
<a name="ln343">          prime_list_begin + prime_list::length;</a>
<a name="ln344">        std::size_t const* bound =</a>
<a name="ln345">          std::upper_bound(prime_list_begin, prime_list_end, num);</a>
<a name="ln346">        if (bound != prime_list_begin)</a>
<a name="ln347">          bound--;</a>
<a name="ln348">        return *bound;</a>
<a name="ln349">      }</a>
<a name="ln350"> </a>
<a name="ln351">      //////////////////////////////////////////////////////////////////////////</a>
<a name="ln352">      // insert_size/initial_size</a>
<a name="ln353"> </a>
<a name="ln354">      template &lt;class I&gt;</a>
<a name="ln355">      inline std::size_t insert_size(I i, I j,</a>
<a name="ln356">        typename boost::unordered::detail::enable_if_forward&lt;I, void*&gt;::type =</a>
<a name="ln357">          0)</a>
<a name="ln358">      {</a>
<a name="ln359">        return static_cast&lt;std::size_t&gt;(std::distance(i, j));</a>
<a name="ln360">      }</a>
<a name="ln361"> </a>
<a name="ln362">      template &lt;class I&gt;</a>
<a name="ln363">      inline std::size_t insert_size(I, I,</a>
<a name="ln364">        typename boost::unordered::detail::disable_if_forward&lt;I, void*&gt;::type =</a>
<a name="ln365">          0)</a>
<a name="ln366">      {</a>
<a name="ln367">        return 1;</a>
<a name="ln368">      }</a>
<a name="ln369"> </a>
<a name="ln370">      template &lt;class I&gt;</a>
<a name="ln371">      inline std::size_t initial_size(I i, I j,</a>
<a name="ln372">        std::size_t num_buckets =</a>
<a name="ln373">          boost::unordered::detail::default_bucket_count)</a>
<a name="ln374">      {</a>
<a name="ln375">        return (std::max)(</a>
<a name="ln376">          boost::unordered::detail::insert_size(i, j), num_buckets);</a>
<a name="ln377">      }</a>
<a name="ln378"> </a>
<a name="ln379">      //////////////////////////////////////////////////////////////////////////</a>
<a name="ln380">      // compressed</a>
<a name="ln381"> </a>
<a name="ln382">      template &lt;typename T, int Index&gt; struct compressed_base : private T</a>
<a name="ln383">      {</a>
<a name="ln384">        compressed_base(T const&amp; x) : T(x) {}</a>
<a name="ln385">        compressed_base(T&amp; x, move_tag) : T(boost::move(x)) {}</a>
<a name="ln386"> </a>
<a name="ln387">        T&amp; get() { return *this; }</a>
<a name="ln388">        T const&amp; get() const { return *this; }</a>
<a name="ln389">      };</a>
<a name="ln390"> </a>
<a name="ln391">      template &lt;typename T, int Index&gt; struct uncompressed_base</a>
<a name="ln392">      {</a>
<a name="ln393">        uncompressed_base(T const&amp; x) : value_(x) {}</a>
<a name="ln394">        uncompressed_base(T&amp; x, move_tag) : value_(boost::move(x)) {}</a>
<a name="ln395"> </a>
<a name="ln396">        T&amp; get() { return value_; }</a>
<a name="ln397">        T const&amp; get() const { return value_; }</a>
<a name="ln398"> </a>
<a name="ln399">      private:</a>
<a name="ln400">        T value_;</a>
<a name="ln401">      };</a>
<a name="ln402"> </a>
<a name="ln403">      template &lt;typename T, int Index&gt;</a>
<a name="ln404">      struct generate_base</a>
<a name="ln405">        : boost::detail::if_true&lt;</a>
<a name="ln406">            boost::is_empty&lt;T&gt;::value&gt;::BOOST_NESTED_TEMPLATE</a>
<a name="ln407">            then&lt;boost::unordered::detail::compressed_base&lt;T, Index&gt;,</a>
<a name="ln408">              boost::unordered::detail::uncompressed_base&lt;T, Index&gt; &gt;</a>
<a name="ln409">      {</a>
<a name="ln410">      };</a>
<a name="ln411"> </a>
<a name="ln412">      template &lt;typename T1, typename T2&gt;</a>
<a name="ln413">      struct compressed</a>
<a name="ln414">        : private boost::unordered::detail::generate_base&lt;T1, 1&gt;::type,</a>
<a name="ln415">          private boost::unordered::detail::generate_base&lt;T2, 2&gt;::type</a>
<a name="ln416">      {</a>
<a name="ln417">        typedef typename generate_base&lt;T1, 1&gt;::type base1;</a>
<a name="ln418">        typedef typename generate_base&lt;T2, 2&gt;::type base2;</a>
<a name="ln419"> </a>
<a name="ln420">        typedef T1 first_type;</a>
<a name="ln421">        typedef T2 second_type;</a>
<a name="ln422"> </a>
<a name="ln423">        first_type&amp; first() { return static_cast&lt;base1*&gt;(this)-&gt;get(); }</a>
<a name="ln424"> </a>
<a name="ln425">        first_type const&amp; first() const</a>
<a name="ln426">        {</a>
<a name="ln427">          return static_cast&lt;base1 const*&gt;(this)-&gt;get();</a>
<a name="ln428">        }</a>
<a name="ln429"> </a>
<a name="ln430">        second_type&amp; second() { return static_cast&lt;base2*&gt;(this)-&gt;get(); }</a>
<a name="ln431"> </a>
<a name="ln432">        second_type const&amp; second() const</a>
<a name="ln433">        {</a>
<a name="ln434">          return static_cast&lt;base2 const*&gt;(this)-&gt;get();</a>
<a name="ln435">        }</a>
<a name="ln436"> </a>
<a name="ln437">        template &lt;typename First, typename Second&gt;</a>
<a name="ln438">        compressed(First const&amp; x1, Second const&amp; x2) : base1(x1), base2(x2)</a>
<a name="ln439">        {</a>
<a name="ln440">        }</a>
<a name="ln441"> </a>
<a name="ln442">        compressed(compressed const&amp; x) : base1(x.first()), base2(x.second()) {}</a>
<a name="ln443"> </a>
<a name="ln444">        compressed(compressed&amp; x, move_tag m)</a>
<a name="ln445">            : base1(x.first(), m), base2(x.second(), m)</a>
<a name="ln446">        {</a>
<a name="ln447">        }</a>
<a name="ln448"> </a>
<a name="ln449">        void assign(compressed const&amp; x)</a>
<a name="ln450">        {</a>
<a name="ln451">          first() = x.first();</a>
<a name="ln452">          second() = x.second();</a>
<a name="ln453">        }</a>
<a name="ln454"> </a>
<a name="ln455">        void move_assign(compressed&amp; x)</a>
<a name="ln456">        {</a>
<a name="ln457">          first() = boost::move(x.first());</a>
<a name="ln458">          second() = boost::move(x.second());</a>
<a name="ln459">        }</a>
<a name="ln460"> </a>
<a name="ln461">        void swap(compressed&amp; x)</a>
<a name="ln462">        {</a>
<a name="ln463">          boost::swap(first(), x.first());</a>
<a name="ln464">          boost::swap(second(), x.second());</a>
<a name="ln465">        }</a>
<a name="ln466"> </a>
<a name="ln467">      private:</a>
<a name="ln468">        // Prevent assignment just to make use of assign or</a>
<a name="ln469">        // move_assign explicit.</a>
<a name="ln470">        compressed&amp; operator=(compressed const&amp;);</a>
<a name="ln471">      };</a>
<a name="ln472"> </a>
<a name="ln473">      //////////////////////////////////////////////////////////////////////////</a>
<a name="ln474">      // pair_traits</a>
<a name="ln475">      //</a>
<a name="ln476">      // Used to get the types from a pair without instantiating it.</a>
<a name="ln477"> </a>
<a name="ln478">      template &lt;typename Pair&gt; struct pair_traits</a>
<a name="ln479">      {</a>
<a name="ln480">        typedef typename Pair::first_type first_type;</a>
<a name="ln481">        typedef typename Pair::second_type second_type;</a>
<a name="ln482">      };</a>
<a name="ln483"> </a>
<a name="ln484">      template &lt;typename T1, typename T2&gt; struct pair_traits&lt;std::pair&lt;T1, T2&gt; &gt;</a>
<a name="ln485">      {</a>
<a name="ln486">        typedef T1 first_type;</a>
<a name="ln487">        typedef T2 second_type;</a>
<a name="ln488">      };</a>
<a name="ln489"> </a>
<a name="ln490">#if defined(BOOST_MSVC)</a>
<a name="ln491">#pragma warning(push)</a>
<a name="ln492">#pragma warning(disable : 4512) // assignment operator could not be generated.</a>
<a name="ln493">#pragma warning(disable : 4345) // behavior change: an object of POD type</a>
<a name="ln494">// constructed with an initializer of the form ()</a>
<a name="ln495">// will be default-initialized.</a>
<a name="ln496">#endif</a>
<a name="ln497"> </a>
<a name="ln498">      //////////////////////////////////////////////////////////////////////////</a>
<a name="ln499">      // Bits and pieces for implementing traits</a>
<a name="ln500"> </a>
<a name="ln501">      template &lt;typename T&gt;</a>
<a name="ln502">      typename boost::add_lvalue_reference&lt;T&gt;::type make();</a>
<a name="ln503">      struct choice9</a>
<a name="ln504">      {</a>
<a name="ln505">        typedef char (&amp;type)[9];</a>
<a name="ln506">      };</a>
<a name="ln507">      struct choice8 : choice9</a>
<a name="ln508">      {</a>
<a name="ln509">        typedef char (&amp;type)[8];</a>
<a name="ln510">      };</a>
<a name="ln511">      struct choice7 : choice8</a>
<a name="ln512">      {</a>
<a name="ln513">        typedef char (&amp;type)[7];</a>
<a name="ln514">      };</a>
<a name="ln515">      struct choice6 : choice7</a>
<a name="ln516">      {</a>
<a name="ln517">        typedef char (&amp;type)[6];</a>
<a name="ln518">      };</a>
<a name="ln519">      struct choice5 : choice6</a>
<a name="ln520">      {</a>
<a name="ln521">        typedef char (&amp;type)[5];</a>
<a name="ln522">      };</a>
<a name="ln523">      struct choice4 : choice5</a>
<a name="ln524">      {</a>
<a name="ln525">        typedef char (&amp;type)[4];</a>
<a name="ln526">      };</a>
<a name="ln527">      struct choice3 : choice4</a>
<a name="ln528">      {</a>
<a name="ln529">        typedef char (&amp;type)[3];</a>
<a name="ln530">      };</a>
<a name="ln531">      struct choice2 : choice3</a>
<a name="ln532">      {</a>
<a name="ln533">        typedef char (&amp;type)[2];</a>
<a name="ln534">      };</a>
<a name="ln535">      struct choice1 : choice2</a>
<a name="ln536">      {</a>
<a name="ln537">        typedef char (&amp;type)[1];</a>
<a name="ln538">      };</a>
<a name="ln539">      choice1 choose();</a>
<a name="ln540"> </a>
<a name="ln541">      typedef choice1::type yes_type;</a>
<a name="ln542">      typedef choice2::type no_type;</a>
<a name="ln543"> </a>
<a name="ln544">      struct private_type</a>
<a name="ln545">      {</a>
<a name="ln546">        private_type const&amp; operator,(int) const;</a>
<a name="ln547">      };</a>
<a name="ln548"> </a>
<a name="ln549">      template &lt;typename T&gt; no_type is_private_type(T const&amp;);</a>
<a name="ln550">      yes_type is_private_type(private_type const&amp;);</a>
<a name="ln551"> </a>
<a name="ln552">      struct convert_from_anything</a>
<a name="ln553">      {</a>
<a name="ln554">        template &lt;typename T&gt; convert_from_anything(T const&amp;);</a>
<a name="ln555">      };</a>
<a name="ln556">    }</a>
<a name="ln557">  }</a>
<a name="ln558">}</a>
<a name="ln559"> </a>
<a name="ln560">////////////////////////////////////////////////////////////////////////////</a>
<a name="ln561">// emplace_args</a>
<a name="ln562">//</a>
<a name="ln563">// Either forwarding variadic arguments, or storing the arguments in</a>
<a name="ln564">// emplace_args##n</a>
<a name="ln565"> </a>
<a name="ln566">#if !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES)</a>
<a name="ln567"> </a>
<a name="ln568">#define BOOST_UNORDERED_EMPLACE_TEMPLATE typename... Args</a>
<a name="ln569">#define BOOST_UNORDERED_EMPLACE_ARGS BOOST_FWD_REF(Args)... args</a>
<a name="ln570">#define BOOST_UNORDERED_EMPLACE_FORWARD boost::forward&lt;Args&gt;(args)...</a>
<a name="ln571"> </a>
<a name="ln572">#else</a>
<a name="ln573"> </a>
<a name="ln574">#define BOOST_UNORDERED_EMPLACE_TEMPLATE typename Args</a>
<a name="ln575">#define BOOST_UNORDERED_EMPLACE_ARGS Args const&amp; args</a>
<a name="ln576">#define BOOST_UNORDERED_EMPLACE_FORWARD args</a>
<a name="ln577"> </a>
<a name="ln578">#if defined(BOOST_NO_CXX11_RVALUE_REFERENCES)</a>
<a name="ln579"> </a>
<a name="ln580">#define BOOST_UNORDERED_EARGS_MEMBER(z, n, _)                                  \</a>
<a name="ln581">  typedef BOOST_FWD_REF(BOOST_PP_CAT(A, n)) BOOST_PP_CAT(Arg, n);              \</a>
<a name="ln582">  BOOST_PP_CAT(Arg, n) BOOST_PP_CAT(a, n);</a>
<a name="ln583"> </a>
<a name="ln584">#else</a>
<a name="ln585"> </a>
<a name="ln586">#define BOOST_UNORDERED_EARGS_MEMBER(z, n, _)                                  \</a>
<a name="ln587">  typedef typename boost::add_lvalue_reference&lt;BOOST_PP_CAT(A, n)&gt;::type       \</a>
<a name="ln588">    BOOST_PP_CAT(Arg, n);                                                      \</a>
<a name="ln589">  BOOST_PP_CAT(Arg, n) BOOST_PP_CAT(a, n);</a>
<a name="ln590"> </a>
<a name="ln591">#endif</a>
<a name="ln592"> </a>
<a name="ln593">#define BOOST_UNORDERED_FWD_PARAM(z, n, a)                                     \</a>
<a name="ln594">  BOOST_FWD_REF(BOOST_PP_CAT(A, n)) BOOST_PP_CAT(a, n)</a>
<a name="ln595"> </a>
<a name="ln596">#define BOOST_UNORDERED_CALL_FORWARD(z, i, a)                                  \</a>
<a name="ln597">  boost::forward&lt;BOOST_PP_CAT(A, i)&gt;(BOOST_PP_CAT(a, i))</a>
<a name="ln598"> </a>
<a name="ln599">#define BOOST_UNORDERED_EARGS_INIT(z, n, _)                                    \</a>
<a name="ln600">  BOOST_PP_CAT(a, n)(BOOST_PP_CAT(b, n))</a>
<a name="ln601"> </a>
<a name="ln602">#define BOOST_UNORDERED_EARGS(z, n, _)                                         \</a>
<a name="ln603">  template &lt;BOOST_PP_ENUM_PARAMS_Z(z, n, typename A)&gt;                          \</a>
<a name="ln604">  struct BOOST_PP_CAT(emplace_args, n)                                         \</a>
<a name="ln605">  {                                                                            \</a>
<a name="ln606">    BOOST_PP_REPEAT_##z(n, BOOST_UNORDERED_EARGS_MEMBER, _) BOOST_PP_CAT(      \</a>
<a name="ln607">      emplace_args, n)(BOOST_PP_ENUM_BINARY_PARAMS_Z(z, n, Arg, b))            \</a>
<a name="ln608">        : BOOST_PP_ENUM_##z(n, BOOST_UNORDERED_EARGS_INIT, _)                  \</a>
<a name="ln609">    {                                                                          \</a>
<a name="ln610">    }                                                                          \</a>
<a name="ln611">  };                                                                           \</a>
<a name="ln612">                                                                               \</a>
<a name="ln613">  template &lt;BOOST_PP_ENUM_PARAMS_Z(z, n, typename A)&gt;                          \</a>
<a name="ln614">  inline BOOST_PP_CAT(emplace_args, n)&lt;BOOST_PP_ENUM_PARAMS_Z(z, n, A)&gt;        \</a>
<a name="ln615">    create_emplace_args(BOOST_PP_ENUM_##z(n, BOOST_UNORDERED_FWD_PARAM, b))    \</a>
<a name="ln616">  {                                                                            \</a>
<a name="ln617">    BOOST_PP_CAT(emplace_args, n)&lt;BOOST_PP_ENUM_PARAMS_Z(z, n, A)&gt; e(          \</a>
<a name="ln618">      BOOST_PP_ENUM_PARAMS_Z(z, n, b));                                        \</a>
<a name="ln619">    return e;                                                                  \</a>
<a name="ln620">  }</a>
<a name="ln621"> </a>
<a name="ln622">namespace boost {</a>
<a name="ln623">  namespace unordered {</a>
<a name="ln624">    namespace detail {</a>
<a name="ln625">      template &lt;typename A0&gt; struct emplace_args1</a>
<a name="ln626">      {</a>
<a name="ln627">        BOOST_UNORDERED_EARGS_MEMBER(1, 0, _)</a>
<a name="ln628"> </a>
<a name="ln629">        explicit emplace_args1(Arg0 b0) : a0(b0) {}</a>
<a name="ln630">      };</a>
<a name="ln631"> </a>
<a name="ln632">      template &lt;typename A0&gt;</a>
<a name="ln633">      inline emplace_args1&lt;A0&gt; create_emplace_args(BOOST_FWD_REF(A0) b0)</a>
<a name="ln634">      {</a>
<a name="ln635">        emplace_args1&lt;A0&gt; e(b0);</a>
<a name="ln636">        return e;</a>
<a name="ln637">      }</a>
<a name="ln638"> </a>
<a name="ln639">      template &lt;typename A0, typename A1&gt; struct emplace_args2</a>
<a name="ln640">      {</a>
<a name="ln641">        BOOST_UNORDERED_EARGS_MEMBER(1, 0, _)</a>
<a name="ln642">        BOOST_UNORDERED_EARGS_MEMBER(1, 1, _)</a>
<a name="ln643"> </a>
<a name="ln644">        emplace_args2(Arg0 b0, Arg1 b1) : a0(b0), a1(b1) {}</a>
<a name="ln645">      };</a>
<a name="ln646"> </a>
<a name="ln647">      template &lt;typename A0, typename A1&gt;</a>
<a name="ln648">      inline emplace_args2&lt;A0, A1&gt; create_emplace_args(</a>
<a name="ln649">        BOOST_FWD_REF(A0) b0, BOOST_FWD_REF(A1) b1)</a>
<a name="ln650">      {</a>
<a name="ln651">        emplace_args2&lt;A0, A1&gt; e(b0, b1);</a>
<a name="ln652">        return e;</a>
<a name="ln653">      }</a>
<a name="ln654"> </a>
<a name="ln655">      template &lt;typename A0, typename A1, typename A2&gt; struct emplace_args3</a>
<a name="ln656">      {</a>
<a name="ln657">        BOOST_UNORDERED_EARGS_MEMBER(1, 0, _)</a>
<a name="ln658">        BOOST_UNORDERED_EARGS_MEMBER(1, 1, _)</a>
<a name="ln659">        BOOST_UNORDERED_EARGS_MEMBER(1, 2, _)</a>
<a name="ln660"> </a>
<a name="ln661">        emplace_args3(Arg0 b0, Arg1 b1, Arg2 b2) : a0(b0), a1(b1), a2(b2) {}</a>
<a name="ln662">      };</a>
<a name="ln663"> </a>
<a name="ln664">      template &lt;typename A0, typename A1, typename A2&gt;</a>
<a name="ln665">      inline emplace_args3&lt;A0, A1, A2&gt; create_emplace_args(</a>
<a name="ln666">        BOOST_FWD_REF(A0) b0, BOOST_FWD_REF(A1) b1, BOOST_FWD_REF(A2) b2)</a>
<a name="ln667">      {</a>
<a name="ln668">        emplace_args3&lt;A0, A1, A2&gt; e(b0, b1, b2);</a>
<a name="ln669">        return e;</a>
<a name="ln670">      }</a>
<a name="ln671"> </a>
<a name="ln672">      BOOST_UNORDERED_EARGS(1, 4, _)</a>
<a name="ln673">      BOOST_UNORDERED_EARGS(1, 5, _)</a>
<a name="ln674">      BOOST_UNORDERED_EARGS(1, 6, _)</a>
<a name="ln675">      BOOST_UNORDERED_EARGS(1, 7, _)</a>
<a name="ln676">      BOOST_UNORDERED_EARGS(1, 8, _)</a>
<a name="ln677">      BOOST_UNORDERED_EARGS(1, 9, _)</a>
<a name="ln678">      BOOST_PP_REPEAT_FROM_TO(10, BOOST_PP_INC(BOOST_UNORDERED_EMPLACE_LIMIT),</a>
<a name="ln679">        BOOST_UNORDERED_EARGS, _)</a>
<a name="ln680">    }</a>
<a name="ln681">  }</a>
<a name="ln682">}</a>
<a name="ln683"> </a>
<a name="ln684">#undef BOOST_UNORDERED_DEFINE_EMPLACE_ARGS</a>
<a name="ln685">#undef BOOST_UNORDERED_EARGS_MEMBER</a>
<a name="ln686">#undef BOOST_UNORDERED_EARGS_INIT</a>
<a name="ln687"> </a>
<a name="ln688">#endif</a>
<a name="ln689"> </a>
<a name="ln690">////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln691">//</a>
<a name="ln692">// Some utilities for implementing allocator_traits, but useful elsewhere so</a>
<a name="ln693">// they're always defined.</a>
<a name="ln694"> </a>
<a name="ln695">namespace boost {</a>
<a name="ln696">  namespace unordered {</a>
<a name="ln697">    namespace detail {</a>
<a name="ln698"> </a>
<a name="ln699">////////////////////////////////////////////////////////////////////////////</a>
<a name="ln700">// Integral_constrant, true_type, false_type</a>
<a name="ln701">//</a>
<a name="ln702">// Uses the standard versions if available.</a>
<a name="ln703"> </a>
<a name="ln704">#if !defined(BOOST_NO_CXX11_HDR_TYPE_TRAITS)</a>
<a name="ln705"> </a>
<a name="ln706">      using std::integral_constant;</a>
<a name="ln707">      using std::true_type;</a>
<a name="ln708">      using std::false_type;</a>
<a name="ln709"> </a>
<a name="ln710">#else</a>
<a name="ln711"> </a>
<a name="ln712">      template &lt;typename T, T Value&gt; struct integral_constant</a>
<a name="ln713">      {</a>
<a name="ln714">        enum</a>
<a name="ln715">        {</a>
<a name="ln716">          value = Value</a>
<a name="ln717">        };</a>
<a name="ln718">      };</a>
<a name="ln719"> </a>
<a name="ln720">      typedef boost::unordered::detail::integral_constant&lt;bool, true&gt; true_type;</a>
<a name="ln721">      typedef boost::unordered::detail::integral_constant&lt;bool, false&gt;</a>
<a name="ln722">        false_type;</a>
<a name="ln723"> </a>
<a name="ln724">#endif</a>
<a name="ln725"> </a>
<a name="ln726">////////////////////////////////////////////////////////////////////////////</a>
<a name="ln727">// Explicitly call a destructor</a>
<a name="ln728"> </a>
<a name="ln729">#if defined(BOOST_MSVC)</a>
<a name="ln730">#pragma warning(push)</a>
<a name="ln731">#pragma warning(disable : 4100) // unreferenced formal parameter</a>
<a name="ln732">#endif</a>
<a name="ln733"> </a>
<a name="ln734">      namespace func {</a>
<a name="ln735">        template &lt;class T&gt; inline void destroy(T* x) { x-&gt;~T(); }</a>
<a name="ln736">      }</a>
<a name="ln737"> </a>
<a name="ln738">#if defined(BOOST_MSVC)</a>
<a name="ln739">#pragma warning(pop)</a>
<a name="ln740">#endif</a>
<a name="ln741"> </a>
<a name="ln742">      //////////////////////////////////////////////////////////////////////////</a>
<a name="ln743">      // value_base</a>
<a name="ln744">      //</a>
<a name="ln745">      // Space used to store values.</a>
<a name="ln746"> </a>
<a name="ln747">      template &lt;typename ValueType&gt; struct value_base</a>
<a name="ln748">      {</a>
<a name="ln749">        typedef ValueType value_type;</a>
<a name="ln750"> </a>
<a name="ln751">        typename boost::aligned_storage&lt;sizeof(value_type),</a>
<a name="ln752">          boost::alignment_of&lt;value_type&gt;::value&gt;::type data_;</a>
<a name="ln753"> </a>
<a name="ln754">        value_base() : data_() {}</a>
<a name="ln755"> </a>
<a name="ln756">        void* address() { return this; }</a>
<a name="ln757"> </a>
<a name="ln758">        value_type&amp; value() { return *(ValueType*)this; }</a>
<a name="ln759"> </a>
<a name="ln760">        value_type const&amp; value() const { return *(ValueType const*)this; }</a>
<a name="ln761"> </a>
<a name="ln762">        value_type* value_ptr() { return (ValueType*)this; }</a>
<a name="ln763"> </a>
<a name="ln764">        value_type const* value_ptr() const { return (ValueType const*)this; }</a>
<a name="ln765"> </a>
<a name="ln766">      private:</a>
<a name="ln767">        value_base&amp; operator=(value_base const&amp;);</a>
<a name="ln768">      };</a>
<a name="ln769"> </a>
<a name="ln770">      //////////////////////////////////////////////////////////////////////////</a>
<a name="ln771">      // optional</a>
<a name="ln772">      // TODO: Use std::optional when available.</a>
<a name="ln773"> </a>
<a name="ln774">      template &lt;typename T&gt; class optional</a>
<a name="ln775">      {</a>
<a name="ln776">        BOOST_MOVABLE_BUT_NOT_COPYABLE(optional)</a>
<a name="ln777"> </a>
<a name="ln778">        boost::unordered::detail::value_base&lt;T&gt; value_;</a>
<a name="ln779">        bool has_value_;</a>
<a name="ln780"> </a>
<a name="ln781">        void destroy()</a>
<a name="ln782">        {</a>
<a name="ln783">          if (has_value_) {</a>
<a name="ln784">            boost::unordered::detail::func::destroy(value_.value_ptr());</a>
<a name="ln785">            has_value_ = false;</a>
<a name="ln786">          }</a>
<a name="ln787">        }</a>
<a name="ln788"> </a>
<a name="ln789">        void move(optional&lt;T&gt;&amp; x)</a>
<a name="ln790">        {</a>
<a name="ln791">          BOOST_ASSERT(!has_value_ &amp;&amp; x.has_value_);</a>
<a name="ln792">          new (value_.value_ptr()) T(boost::move(x.value_.value()));</a>
<a name="ln793">          boost::unordered::detail::func::destroy(x.value_.value_ptr());</a>
<a name="ln794">          has_value_ = true;</a>
<a name="ln795">          x.has_value_ = false;</a>
<a name="ln796">        }</a>
<a name="ln797"> </a>
<a name="ln798">      public:</a>
<a name="ln799">        optional() BOOST_NOEXCEPT : has_value_(false) {}</a>
<a name="ln800"> </a>
<a name="ln801">        optional(BOOST_RV_REF(optional&lt;T&gt;) x) : has_value_(false)</a>
<a name="ln802">        {</a>
<a name="ln803">          if (x.has_value_) {</a>
<a name="ln804">            move(x);</a>
<a name="ln805">          }</a>
<a name="ln806">        }</a>
<a name="ln807"> </a>
<a name="ln808">        explicit optional(T const&amp; x) : has_value_(true)</a>
<a name="ln809">        {</a>
<a name="ln810">          new (value_.value_ptr()) T(x);</a>
<a name="ln811">        }</a>
<a name="ln812"> </a>
<a name="ln813">        optional&amp; operator=(BOOST_RV_REF(optional&lt;T&gt;) x)</a>
<a name="ln814">        {</a>
<a name="ln815">          destroy();</a>
<a name="ln816">          if (x.has_value_) {</a>
<a name="ln817">            move(x);</a>
<a name="ln818">          }</a>
<a name="ln819">          return *this;</a>
<a name="ln820">        }</a>
<a name="ln821"> </a>
<a name="ln822">        ~optional() { destroy(); }</a>
<a name="ln823"> </a>
<a name="ln824">        bool has_value() const { return has_value_; }</a>
<a name="ln825">        T&amp; operator*() { return value_.value(); }</a>
<a name="ln826">        T const&amp; operator*() const { return value_.value(); }</a>
<a name="ln827">        T* operator-&gt;() { return value_.value_ptr(); }</a>
<a name="ln828">        T const* operator-&gt;() const { return value_.value_ptr(); }</a>
<a name="ln829"> </a>
<a name="ln830">        bool operator==(optional&lt;T&gt; const&amp; x)</a>
<a name="ln831">        {</a>
<a name="ln832">          return has_value_ ? x.has_value_ &amp;&amp; value_.value() == x.value_.value()</a>
<a name="ln833">                            : !x.has_value_;</a>
<a name="ln834">        }</a>
<a name="ln835"> </a>
<a name="ln836">        bool operator!=(optional&lt;T&gt; const&amp; x) { return !((*this) == x); }</a>
<a name="ln837"> </a>
<a name="ln838">        void swap(optional&lt;T&gt;&amp; x)</a>
<a name="ln839">        {</a>
<a name="ln840">          if (has_value_ != x.has_value_) {</a>
<a name="ln841">            if (has_value_) {</a>
<a name="ln842">              x.move(*this);</a>
<a name="ln843">            } else {</a>
<a name="ln844">              move(x);</a>
<a name="ln845">            }</a>
<a name="ln846">          } else if (has_value_) {</a>
<a name="ln847">            boost::swap(value_.value(), x.value_.value());</a>
<a name="ln848">          }</a>
<a name="ln849">        }</a>
<a name="ln850"> </a>
<a name="ln851">        friend void swap(optional&lt;T&gt;&amp; x, optional&lt;T&gt;&amp; y) { x.swap(y); }</a>
<a name="ln852">      };</a>
<a name="ln853">    }</a>
<a name="ln854">  }</a>
<a name="ln855">}</a>
<a name="ln856"> </a>
<a name="ln857">////////////////////////////////////////////////////////////////////////////</a>
<a name="ln858">// Expression test mechanism</a>
<a name="ln859">//</a>
<a name="ln860">// When SFINAE expressions are available, define</a>
<a name="ln861">// BOOST_UNORDERED_HAS_FUNCTION which can check if a function call is</a>
<a name="ln862">// supported by a class, otherwise define BOOST_UNORDERED_HAS_MEMBER which</a>
<a name="ln863">// can detect if a class has the specified member, but not that it has the</a>
<a name="ln864">// correct type, this is good enough for a passable impression of</a>
<a name="ln865">// allocator_traits.</a>
<a name="ln866"> </a>
<a name="ln867">#if !defined(BOOST_NO_SFINAE_EXPR)</a>
<a name="ln868"> </a>
<a name="ln869">namespace boost {</a>
<a name="ln870">  namespace unordered {</a>
<a name="ln871">    namespace detail {</a>
<a name="ln872">      template &lt;typename T, long unsigned int&gt; struct expr_test;</a>
<a name="ln873">      template &lt;typename T&gt; struct expr_test&lt;T, sizeof(char)&gt; : T</a>
<a name="ln874">      {</a>
<a name="ln875">      };</a>
<a name="ln876">    }</a>
<a name="ln877">  }</a>
<a name="ln878">}</a>
<a name="ln879"> </a>
<a name="ln880">#define BOOST_UNORDERED_CHECK_EXPRESSION(count, result, expression)            \</a>
<a name="ln881">  template &lt;typename U&gt;                                                        \</a>
<a name="ln882">  static                                                                       \</a>
<a name="ln883">    typename boost::unordered::detail::expr_test&lt;BOOST_PP_CAT(choice, result), \</a>
<a name="ln884">      sizeof(for_expr_test(((expression), 0)))&gt;::type                          \</a>
<a name="ln885">      test(BOOST_PP_CAT(choice, count))</a>
<a name="ln886"> </a>
<a name="ln887">#define BOOST_UNORDERED_DEFAULT_EXPRESSION(count, result)                      \</a>
<a name="ln888">  template &lt;typename U&gt;                                                        \</a>
<a name="ln889">  static BOOST_PP_CAT(choice, result)::type test(BOOST_PP_CAT(choice, count))</a>
<a name="ln890"> </a>
<a name="ln891">#define BOOST_UNORDERED_HAS_FUNCTION(name, thing, args, _)                     \</a>
<a name="ln892">  struct BOOST_PP_CAT(has_, name)                                              \</a>
<a name="ln893">  {                                                                            \</a>
<a name="ln894">    template &lt;typename U&gt; static char for_expr_test(U const&amp;);                 \</a>
<a name="ln895">    BOOST_UNORDERED_CHECK_EXPRESSION(                                          \</a>
<a name="ln896">      1, 1, boost::unordered::detail::make&lt;thing&gt;().name args);                \</a>
<a name="ln897">    BOOST_UNORDERED_DEFAULT_EXPRESSION(2, 2);                                  \</a>
<a name="ln898">                                                                               \</a>
<a name="ln899">    enum                                                                       \</a>
<a name="ln900">    {                                                                          \</a>
<a name="ln901">      value = sizeof(test&lt;T&gt;(choose())) == sizeof(choice1::type)               \</a>
<a name="ln902">    };                                                                         \</a>
<a name="ln903">  }</a>
<a name="ln904"> </a>
<a name="ln905">#else</a>
<a name="ln906"> </a>
<a name="ln907">namespace boost {</a>
<a name="ln908">  namespace unordered {</a>
<a name="ln909">    namespace detail {</a>
<a name="ln910">      template &lt;typename T&gt; struct identity</a>
<a name="ln911">      {</a>
<a name="ln912">        typedef T type;</a>
<a name="ln913">      };</a>
<a name="ln914">    }</a>
<a name="ln915">  }</a>
<a name="ln916">}</a>
<a name="ln917"> </a>
<a name="ln918">#define BOOST_UNORDERED_CHECK_MEMBER(count, result, name, member)              \</a>
<a name="ln919">                                                                               \</a>
<a name="ln920">  typedef                                                                      \</a>
<a name="ln921">    typename boost::unordered::detail::identity&lt;member&gt;::type BOOST_PP_CAT(    \</a>
<a name="ln922">      check, count);                                                           \</a>
<a name="ln923">                                                                               \</a>
<a name="ln924">  template &lt;BOOST_PP_CAT(check, count) e&gt; struct BOOST_PP_CAT(test, count)     \</a>
<a name="ln925">  {                                                                            \</a>
<a name="ln926">    typedef BOOST_PP_CAT(choice, result) type;                                 \</a>
<a name="ln927">  };                                                                           \</a>
<a name="ln928">                                                                               \</a>
<a name="ln929">  template &lt;class U&gt;                                                           \</a>
<a name="ln930">  static typename BOOST_PP_CAT(test, count)&lt;&amp;U::name&gt;::type test(              \</a>
<a name="ln931">    BOOST_PP_CAT(choice, count))</a>
<a name="ln932"> </a>
<a name="ln933">#define BOOST_UNORDERED_DEFAULT_MEMBER(count, result)                          \</a>
<a name="ln934">  template &lt;class U&gt;                                                           \</a>
<a name="ln935">  static BOOST_PP_CAT(choice, result)::type test(BOOST_PP_CAT(choice, count))</a>
<a name="ln936"> </a>
<a name="ln937">#define BOOST_UNORDERED_HAS_MEMBER(name)                                       \</a>
<a name="ln938">  struct BOOST_PP_CAT(has_, name)                                              \</a>
<a name="ln939">  {                                                                            \</a>
<a name="ln940">    struct impl                                                                \</a>
<a name="ln941">    {                                                                          \</a>
<a name="ln942">      struct base_mixin                                                        \</a>
<a name="ln943">      {                                                                        \</a>
<a name="ln944">        int name;                                                              \</a>
<a name="ln945">      };                                                                       \</a>
<a name="ln946">      struct base : public T, public base_mixin                                \</a>
<a name="ln947">      {                                                                        \</a>
<a name="ln948">      };                                                                       \</a>
<a name="ln949">                                                                               \</a>
<a name="ln950">      BOOST_UNORDERED_CHECK_MEMBER(1, 1, name, int base_mixin::*);             \</a>
<a name="ln951">      BOOST_UNORDERED_DEFAULT_MEMBER(2, 2);                                    \</a>
<a name="ln952">                                                                               \</a>
<a name="ln953">      enum                                                                     \</a>
<a name="ln954">      {                                                                        \</a>
<a name="ln955">        value = sizeof(choice2::type) == sizeof(test&lt;base&gt;(choose()))          \</a>
<a name="ln956">      };                                                                       \</a>
<a name="ln957">    };                                                                         \</a>
<a name="ln958">                                                                               \</a>
<a name="ln959">    enum                                                                       \</a>
<a name="ln960">    {                                                                          \</a>
<a name="ln961">      value = impl::value                                                      \</a>
<a name="ln962">    };                                                                         \</a>
<a name="ln963">  }</a>
<a name="ln964"> </a>
<a name="ln965">#endif</a>
<a name="ln966"> </a>
<a name="ln967">////////////////////////////////////////////////////////////////////////////</a>
<a name="ln968">// TRAITS TYPE DETECTION MECHANISM</a>
<a name="ln969">//</a>
<a name="ln970">// Used to implement traits that use a type if present, or a</a>
<a name="ln971">// default otherwise.</a>
<a name="ln972"> </a>
<a name="ln973">#if defined(BOOST_MSVC) &amp;&amp; BOOST_MSVC &lt;= 1400</a>
<a name="ln974"> </a>
<a name="ln975">#define BOOST_UNORDERED_DEFAULT_TYPE_TMPLT(tname)                              \</a>
<a name="ln976">  template &lt;typename Tp, typename Default&gt; struct default_type_##tname         \</a>
<a name="ln977">  {                                                                            \</a>
<a name="ln978">                                                                               \</a>
<a name="ln979">    template &lt;typename X&gt;                                                      \</a>
<a name="ln980">    static choice1::type test(choice1, typename X::tname* = 0);                \</a>
<a name="ln981">                                                                               \</a>
<a name="ln982">    template &lt;typename X&gt; static choice2::type test(choice2, void* = 0);       \</a>
<a name="ln983">                                                                               \</a>
<a name="ln984">    struct DefaultWrap                                                         \</a>
<a name="ln985">    {                                                                          \</a>
<a name="ln986">      typedef Default tname;                                                   \</a>
<a name="ln987">    };                                                                         \</a>
<a name="ln988">                                                                               \</a>
<a name="ln989">    enum                                                                       \</a>
<a name="ln990">    {                                                                          \</a>
<a name="ln991">      value = (1 == sizeof(test&lt;Tp&gt;(choose())))                                \</a>
<a name="ln992">    };                                                                         \</a>
<a name="ln993">                                                                               \</a>
<a name="ln994">    typedef typename boost::detail::if_true&lt;value&gt;::BOOST_NESTED_TEMPLATE      \</a>
<a name="ln995">      then&lt;Tp, DefaultWrap&gt;::type::tname type;                                 \</a>
<a name="ln996">  }</a>
<a name="ln997"> </a>
<a name="ln998">#else</a>
<a name="ln999"> </a>
<a name="ln1000">namespace boost {</a>
<a name="ln1001">  namespace unordered {</a>
<a name="ln1002">    namespace detail {</a>
<a name="ln1003">      template &lt;typename T, typename T2&gt; struct sfinae : T2</a>
<a name="ln1004">      {</a>
<a name="ln1005">      };</a>
<a name="ln1006">    }</a>
<a name="ln1007">  }</a>
<a name="ln1008">}</a>
<a name="ln1009"> </a>
<a name="ln1010">#define BOOST_UNORDERED_DEFAULT_TYPE_TMPLT(tname)                              \</a>
<a name="ln1011">  template &lt;typename Tp, typename Default&gt; struct default_type_##tname         \</a>
<a name="ln1012">  {                                                                            \</a>
<a name="ln1013">                                                                               \</a>
<a name="ln1014">    template &lt;typename X&gt;                                                      \</a>
<a name="ln1015">    static typename boost::unordered::detail::sfinae&lt;typename X::tname,        \</a>
<a name="ln1016">      choice1&gt;::type test(choice1);                                            \</a>
<a name="ln1017">                                                                               \</a>
<a name="ln1018">    template &lt;typename X&gt; static choice2::type test(choice2);                  \</a>
<a name="ln1019">                                                                               \</a>
<a name="ln1020">    struct DefaultWrap                                                         \</a>
<a name="ln1021">    {                                                                          \</a>
<a name="ln1022">      typedef Default tname;                                                   \</a>
<a name="ln1023">    };                                                                         \</a>
<a name="ln1024">                                                                               \</a>
<a name="ln1025">    enum                                                                       \</a>
<a name="ln1026">    {                                                                          \</a>
<a name="ln1027">      value = (1 == sizeof(test&lt;Tp&gt;(choose())))                                \</a>
<a name="ln1028">    };                                                                         \</a>
<a name="ln1029">                                                                               \</a>
<a name="ln1030">    typedef typename boost::detail::if_true&lt;value&gt;::BOOST_NESTED_TEMPLATE      \</a>
<a name="ln1031">      then&lt;Tp, DefaultWrap&gt;::type::tname type;                                 \</a>
<a name="ln1032">  }</a>
<a name="ln1033"> </a>
<a name="ln1034">#endif</a>
<a name="ln1035"> </a>
<a name="ln1036">#define BOOST_UNORDERED_DEFAULT_TYPE(T, tname, arg)                            \</a>
<a name="ln1037">  typename default_type_##tname&lt;T, arg&gt;::type</a>
<a name="ln1038"> </a>
<a name="ln1039">////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln1040">//</a>
<a name="ln1041">// Allocator traits</a>
<a name="ln1042">//</a>
<a name="ln1043">// First our implementation, then later light wrappers around the alternatives</a>
<a name="ln1044"> </a>
<a name="ln1045">#if BOOST_UNORDERED_USE_ALLOCATOR_TRAITS == 0</a>
<a name="ln1046"> </a>
<a name="ln1047">#include &lt;boost/limits.hpp&gt;</a>
<a name="ln1048">#include &lt;boost/pointer_to_other.hpp&gt;</a>
<a name="ln1049">#include &lt;boost/utility/enable_if.hpp&gt;</a>
<a name="ln1050"> </a>
<a name="ln1051">namespace boost {</a>
<a name="ln1052">  namespace unordered {</a>
<a name="ln1053">    namespace detail {</a>
<a name="ln1054"> </a>
<a name="ln1055">      template &lt;typename Alloc, typename T&gt; struct rebind_alloc;</a>
<a name="ln1056"> </a>
<a name="ln1057">#if !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES)</a>
<a name="ln1058"> </a>
<a name="ln1059">      template &lt;template &lt;typename, typename...&gt; class Alloc, typename U,</a>
<a name="ln1060">        typename T, typename... Args&gt;</a>
<a name="ln1061">      struct rebind_alloc&lt;Alloc&lt;U, Args...&gt;, T&gt;</a>
<a name="ln1062">      {</a>
<a name="ln1063">        typedef Alloc&lt;T, Args...&gt; type;</a>
<a name="ln1064">      };</a>
<a name="ln1065"> </a>
<a name="ln1066">#else</a>
<a name="ln1067"> </a>
<a name="ln1068">      template &lt;template &lt;typename&gt; class Alloc, typename U, typename T&gt;</a>
<a name="ln1069">      struct rebind_alloc&lt;Alloc&lt;U&gt;, T&gt;</a>
<a name="ln1070">      {</a>
<a name="ln1071">        typedef Alloc&lt;T&gt; type;</a>
<a name="ln1072">      };</a>
<a name="ln1073"> </a>
<a name="ln1074">      template &lt;template &lt;typename, typename&gt; class Alloc, typename U,</a>
<a name="ln1075">        typename T, typename A0&gt;</a>
<a name="ln1076">      struct rebind_alloc&lt;Alloc&lt;U, A0&gt;, T&gt;</a>
<a name="ln1077">      {</a>
<a name="ln1078">        typedef Alloc&lt;T, A0&gt; type;</a>
<a name="ln1079">      };</a>
<a name="ln1080"> </a>
<a name="ln1081">      template &lt;template &lt;typename, typename, typename&gt; class Alloc, typename U,</a>
<a name="ln1082">        typename T, typename A0, typename A1&gt;</a>
<a name="ln1083">      struct rebind_alloc&lt;Alloc&lt;U, A0, A1&gt;, T&gt;</a>
<a name="ln1084">      {</a>
<a name="ln1085">        typedef Alloc&lt;T, A0, A1&gt; type;</a>
<a name="ln1086">      };</a>
<a name="ln1087"> </a>
<a name="ln1088">#endif</a>
<a name="ln1089"> </a>
<a name="ln1090">      template &lt;typename Alloc, typename T&gt; struct rebind_wrap</a>
<a name="ln1091">      {</a>
<a name="ln1092">        template &lt;typename X&gt;</a>
<a name="ln1093">        static choice1::type test(</a>
<a name="ln1094">          choice1, typename X::BOOST_NESTED_TEMPLATE rebind&lt;T&gt;::other* = 0);</a>
<a name="ln1095">        template &lt;typename X&gt; static choice2::type test(choice2, void* = 0);</a>
<a name="ln1096"> </a>
<a name="ln1097">        enum</a>
<a name="ln1098">        {</a>
<a name="ln1099">          value = (1 == sizeof(test&lt;Alloc&gt;(choose())))</a>
<a name="ln1100">        };</a>
<a name="ln1101"> </a>
<a name="ln1102">        struct fallback</a>
<a name="ln1103">        {</a>
<a name="ln1104">          template &lt;typename U&gt; struct rebind</a>
<a name="ln1105">          {</a>
<a name="ln1106">            typedef typename rebind_alloc&lt;Alloc, T&gt;::type other;</a>
<a name="ln1107">          };</a>
<a name="ln1108">        };</a>
<a name="ln1109"> </a>
<a name="ln1110">        typedef</a>
<a name="ln1111">          typename boost::detail::if_true&lt;value&gt;::BOOST_NESTED_TEMPLATE then&lt;</a>
<a name="ln1112">            Alloc, fallback&gt;::type::BOOST_NESTED_TEMPLATE rebind&lt;T&gt;::other type;</a>
<a name="ln1113">      };</a>
<a name="ln1114">    }</a>
<a name="ln1115">  }</a>
<a name="ln1116">}</a>
<a name="ln1117"> </a>
<a name="ln1118">namespace boost {</a>
<a name="ln1119">  namespace unordered {</a>
<a name="ln1120">    namespace detail {</a>
<a name="ln1121">      BOOST_UNORDERED_DEFAULT_TYPE_TMPLT(pointer);</a>
<a name="ln1122">      BOOST_UNORDERED_DEFAULT_TYPE_TMPLT(const_pointer);</a>
<a name="ln1123">      BOOST_UNORDERED_DEFAULT_TYPE_TMPLT(void_pointer);</a>
<a name="ln1124">      BOOST_UNORDERED_DEFAULT_TYPE_TMPLT(const_void_pointer);</a>
<a name="ln1125">      BOOST_UNORDERED_DEFAULT_TYPE_TMPLT(difference_type);</a>
<a name="ln1126">      BOOST_UNORDERED_DEFAULT_TYPE_TMPLT(size_type);</a>
<a name="ln1127">      BOOST_UNORDERED_DEFAULT_TYPE_TMPLT(</a>
<a name="ln1128">        propagate_on_container_copy_assignment);</a>
<a name="ln1129">      BOOST_UNORDERED_DEFAULT_TYPE_TMPLT(</a>
<a name="ln1130">        propagate_on_container_move_assignment);</a>
<a name="ln1131">      BOOST_UNORDERED_DEFAULT_TYPE_TMPLT(propagate_on_container_swap);</a>
<a name="ln1132">      BOOST_UNORDERED_DEFAULT_TYPE_TMPLT(is_always_equal);</a>
<a name="ln1133"> </a>
<a name="ln1134">#if !defined(BOOST_NO_SFINAE_EXPR)</a>
<a name="ln1135"> </a>
<a name="ln1136">      template &lt;typename T&gt;</a>
<a name="ln1137">      BOOST_UNORDERED_HAS_FUNCTION(</a>
<a name="ln1138">        select_on_container_copy_construction, U const, (), 0);</a>
<a name="ln1139"> </a>
<a name="ln1140">      template &lt;typename T&gt;</a>
<a name="ln1141">      BOOST_UNORDERED_HAS_FUNCTION(max_size, U const, (), 0);</a>
<a name="ln1142"> </a>
<a name="ln1143">#if !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES)</a>
<a name="ln1144"> </a>
<a name="ln1145">      template &lt;typename T, typename ValueType, typename... Args&gt;</a>
<a name="ln1146">      BOOST_UNORDERED_HAS_FUNCTION(construct, U,</a>
<a name="ln1147">        (boost::unordered::detail::make&lt;ValueType*&gt;(),</a>
<a name="ln1148">          boost::unordered::detail::make&lt;Args const&gt;()...),</a>
<a name="ln1149">        2);</a>
<a name="ln1150"> </a>
<a name="ln1151">#else</a>
<a name="ln1152"> </a>
<a name="ln1153">      template &lt;typename T, typename ValueType&gt;</a>
<a name="ln1154">      BOOST_UNORDERED_HAS_FUNCTION(construct, U,</a>
<a name="ln1155">        (boost::unordered::detail::make&lt;ValueType*&gt;(),</a>
<a name="ln1156">          boost::unordered::detail::make&lt;ValueType const&gt;()),</a>
<a name="ln1157">        2);</a>
<a name="ln1158"> </a>
<a name="ln1159">#endif</a>
<a name="ln1160"> </a>
<a name="ln1161">      template &lt;typename T, typename ValueType&gt;</a>
<a name="ln1162">      BOOST_UNORDERED_HAS_FUNCTION(</a>
<a name="ln1163">        destroy, U, (boost::unordered::detail::make&lt;ValueType*&gt;()), 1);</a>
<a name="ln1164"> </a>
<a name="ln1165">#else</a>
<a name="ln1166"> </a>
<a name="ln1167">      template &lt;typename T&gt;</a>
<a name="ln1168">      BOOST_UNORDERED_HAS_MEMBER(select_on_container_copy_construction);</a>
<a name="ln1169"> </a>
<a name="ln1170">      template &lt;typename T&gt; BOOST_UNORDERED_HAS_MEMBER(max_size);</a>
<a name="ln1171"> </a>
<a name="ln1172">      template &lt;typename T, typename ValueType&gt;</a>
<a name="ln1173">      BOOST_UNORDERED_HAS_MEMBER(construct);</a>
<a name="ln1174"> </a>
<a name="ln1175">      template &lt;typename T, typename ValueType&gt;</a>
<a name="ln1176">      BOOST_UNORDERED_HAS_MEMBER(destroy);</a>
<a name="ln1177"> </a>
<a name="ln1178">#endif</a>
<a name="ln1179">    }</a>
<a name="ln1180">  }</a>
<a name="ln1181">}</a>
<a name="ln1182"> </a>
<a name="ln1183">namespace boost {</a>
<a name="ln1184">  namespace unordered {</a>
<a name="ln1185">    namespace detail {</a>
<a name="ln1186">      namespace func {</a>
<a name="ln1187"> </a>
<a name="ln1188">        template &lt;typename Alloc&gt;</a>
<a name="ln1189">        inline Alloc call_select_on_container_copy_construction(</a>
<a name="ln1190">          const Alloc&amp; rhs,</a>
<a name="ln1191">          typename boost::enable_if_c&lt;</a>
<a name="ln1192">            boost::unordered::detail::has_select_on_container_copy_construction&lt;</a>
<a name="ln1193">              Alloc&gt;::value,</a>
<a name="ln1194">            void*&gt;::type = 0)</a>
<a name="ln1195">        {</a>
<a name="ln1196">          return rhs.select_on_container_copy_construction();</a>
<a name="ln1197">        }</a>
<a name="ln1198"> </a>
<a name="ln1199">        template &lt;typename Alloc&gt;</a>
<a name="ln1200">        inline Alloc call_select_on_container_copy_construction(</a>
<a name="ln1201">          const Alloc&amp; rhs,</a>
<a name="ln1202">          typename boost::disable_if_c&lt;</a>
<a name="ln1203">            boost::unordered::detail::has_select_on_container_copy_construction&lt;</a>
<a name="ln1204">              Alloc&gt;::value,</a>
<a name="ln1205">            void*&gt;::type = 0)</a>
<a name="ln1206">        {</a>
<a name="ln1207">          return rhs;</a>
<a name="ln1208">        }</a>
<a name="ln1209"> </a>
<a name="ln1210">        template &lt;typename SizeType, typename Alloc&gt;</a>
<a name="ln1211">        inline SizeType call_max_size(const Alloc&amp; a,</a>
<a name="ln1212">          typename boost::enable_if_c&lt;</a>
<a name="ln1213">            boost::unordered::detail::has_max_size&lt;Alloc&gt;::value, void*&gt;::type =</a>
<a name="ln1214">            0)</a>
<a name="ln1215">        {</a>
<a name="ln1216">          return a.max_size();</a>
<a name="ln1217">        }</a>
<a name="ln1218"> </a>
<a name="ln1219">        template &lt;typename SizeType, typename Alloc&gt;</a>
<a name="ln1220">        inline SizeType call_max_size(const Alloc&amp;,</a>
<a name="ln1221">          typename boost::disable_if_c&lt;</a>
<a name="ln1222">            boost::unordered::detail::has_max_size&lt;Alloc&gt;::value, void*&gt;::type =</a>
<a name="ln1223">            0)</a>
<a name="ln1224">        {</a>
<a name="ln1225">          return (std::numeric_limits&lt;SizeType&gt;::max)();</a>
<a name="ln1226">        }</a>
<a name="ln1227">      } // namespace func.</a>
<a name="ln1228">    }</a>
<a name="ln1229">  }</a>
<a name="ln1230">}</a>
<a name="ln1231"> </a>
<a name="ln1232">namespace boost {</a>
<a name="ln1233">  namespace unordered {</a>
<a name="ln1234">    namespace detail {</a>
<a name="ln1235">      template &lt;typename Alloc&gt; struct allocator_traits</a>
<a name="ln1236">      {</a>
<a name="ln1237">        typedef Alloc allocator_type;</a>
<a name="ln1238">        typedef typename Alloc::value_type value_type;</a>
<a name="ln1239"> </a>
<a name="ln1240">        typedef BOOST_UNORDERED_DEFAULT_TYPE(</a>
<a name="ln1241">          Alloc, pointer, value_type*) pointer;</a>
<a name="ln1242"> </a>
<a name="ln1243">        template &lt;typename T&gt;</a>
<a name="ln1244">        struct pointer_to_other : boost::pointer_to_other&lt;pointer, T&gt;</a>
<a name="ln1245">        {</a>
<a name="ln1246">        };</a>
<a name="ln1247"> </a>
<a name="ln1248">        typedef BOOST_UNORDERED_DEFAULT_TYPE(Alloc, const_pointer,</a>
<a name="ln1249">          typename pointer_to_other&lt;const value_type&gt;::type) const_pointer;</a>
<a name="ln1250"> </a>
<a name="ln1251">        // typedef BOOST_UNORDERED_DEFAULT_TYPE(Alloc, void_pointer,</a>
<a name="ln1252">        //    typename pointer_to_other&lt;void&gt;::type)</a>
<a name="ln1253">        //    void_pointer;</a>
<a name="ln1254">        //</a>
<a name="ln1255">        // typedef BOOST_UNORDERED_DEFAULT_TYPE(Alloc, const_void_pointer,</a>
<a name="ln1256">        //    typename pointer_to_other&lt;const void&gt;::type)</a>
<a name="ln1257">        //    const_void_pointer;</a>
<a name="ln1258"> </a>
<a name="ln1259">        typedef BOOST_UNORDERED_DEFAULT_TYPE(</a>
<a name="ln1260">          Alloc, difference_type, std::ptrdiff_t) difference_type;</a>
<a name="ln1261"> </a>
<a name="ln1262">        typedef BOOST_UNORDERED_DEFAULT_TYPE(</a>
<a name="ln1263">          Alloc, size_type, std::size_t) size_type;</a>
<a name="ln1264"> </a>
<a name="ln1265">#if !defined(BOOST_NO_CXX11_TEMPLATE_ALIASES)</a>
<a name="ln1266">        template &lt;typename T&gt;</a>
<a name="ln1267">        using rebind_alloc = typename rebind_wrap&lt;Alloc, T&gt;::type;</a>
<a name="ln1268"> </a>
<a name="ln1269">        template &lt;typename T&gt;</a>
<a name="ln1270">        using rebind_traits =</a>
<a name="ln1271">          boost::unordered::detail::allocator_traits&lt;rebind_alloc&lt;T&gt; &gt;;</a>
<a name="ln1272">#endif</a>
<a name="ln1273"> </a>
<a name="ln1274">        static pointer allocate(Alloc&amp; a, size_type n) { return a.allocate(n); }</a>
<a name="ln1275"> </a>
<a name="ln1276">        // I never use this, so I'll just comment it out for now.</a>
<a name="ln1277">        //</a>
<a name="ln1278">        // static pointer allocate(Alloc&amp; a, size_type n,</a>
<a name="ln1279">        //        const_void_pointer hint)</a>
<a name="ln1280">        //    { return DEFAULT_FUNC(allocate, pointer)(a, n, hint); }</a>
<a name="ln1281"> </a>
<a name="ln1282">        static void deallocate(Alloc&amp; a, pointer p, size_type n)</a>
<a name="ln1283">        {</a>
<a name="ln1284">          a.deallocate(p, n);</a>
<a name="ln1285">        }</a>
<a name="ln1286"> </a>
<a name="ln1287">      public:</a>
<a name="ln1288">#if BOOST_UNORDERED_CXX11_CONSTRUCTION</a>
<a name="ln1289"> </a>
<a name="ln1290">        template &lt;typename T, typename... Args&gt;</a>
<a name="ln1291">        static</a>
<a name="ln1292">          typename boost::enable_if_c&lt;boost::unordered::detail::has_construct&lt;</a>
<a name="ln1293">            Alloc, T, Args...&gt;::value&gt;::type</a>
<a name="ln1294">          construct(Alloc&amp; a, T* p, BOOST_FWD_REF(Args)... x)</a>
<a name="ln1295">        {</a>
<a name="ln1296">          a.construct(p, boost::forward&lt;Args&gt;(x)...);</a>
<a name="ln1297">        }</a>
<a name="ln1298"> </a>
<a name="ln1299">        template &lt;typename T, typename... Args&gt;</a>
<a name="ln1300">        static</a>
<a name="ln1301">          typename boost::disable_if_c&lt;boost::unordered::detail::has_construct&lt;</a>
<a name="ln1302">            Alloc, T, Args...&gt;::value&gt;::type</a>
<a name="ln1303">          construct(Alloc&amp;, T* p, BOOST_FWD_REF(Args)... x)</a>
<a name="ln1304">        {</a>
<a name="ln1305">          new (static_cast&lt;void*&gt;(p)) T(boost::forward&lt;Args&gt;(x)...);</a>
<a name="ln1306">        }</a>
<a name="ln1307"> </a>
<a name="ln1308">        template &lt;typename T&gt;</a>
<a name="ln1309">        static typename boost::enable_if_c&lt;</a>
<a name="ln1310">          boost::unordered::detail::has_destroy&lt;Alloc, T&gt;::value&gt;::type</a>
<a name="ln1311">        destroy(Alloc&amp; a, T* p)</a>
<a name="ln1312">        {</a>
<a name="ln1313">          a.destroy(p);</a>
<a name="ln1314">        }</a>
<a name="ln1315"> </a>
<a name="ln1316">        template &lt;typename T&gt;</a>
<a name="ln1317">        static typename boost::disable_if_c&lt;</a>
<a name="ln1318">          boost::unordered::detail::has_destroy&lt;Alloc, T&gt;::value&gt;::type</a>
<a name="ln1319">        destroy(Alloc&amp;, T* p)</a>
<a name="ln1320">        {</a>
<a name="ln1321">          boost::unordered::detail::func::destroy(p);</a>
<a name="ln1322">        }</a>
<a name="ln1323"> </a>
<a name="ln1324">#elif !defined(BOOST_NO_SFINAE_EXPR)</a>
<a name="ln1325"> </a>
<a name="ln1326">        template &lt;typename T&gt;</a>
<a name="ln1327">        static typename boost::enable_if_c&lt;</a>
<a name="ln1328">          boost::unordered::detail::has_construct&lt;Alloc, T&gt;::value&gt;::type</a>
<a name="ln1329">        construct(Alloc&amp; a, T* p, T const&amp; x)</a>
<a name="ln1330">        {</a>
<a name="ln1331">          a.construct(p, x);</a>
<a name="ln1332">        }</a>
<a name="ln1333"> </a>
<a name="ln1334">        template &lt;typename T&gt;</a>
<a name="ln1335">        static typename boost::disable_if_c&lt;</a>
<a name="ln1336">          boost::unordered::detail::has_construct&lt;Alloc, T&gt;::value&gt;::type</a>
<a name="ln1337">        construct(Alloc&amp;, T* p, T const&amp; x)</a>
<a name="ln1338">        {</a>
<a name="ln1339">          new (static_cast&lt;void*&gt;(p)) T(x);</a>
<a name="ln1340">        }</a>
<a name="ln1341"> </a>
<a name="ln1342">        template &lt;typename T&gt;</a>
<a name="ln1343">        static typename boost::enable_if_c&lt;</a>
<a name="ln1344">          boost::unordered::detail::has_destroy&lt;Alloc, T&gt;::value&gt;::type</a>
<a name="ln1345">        destroy(Alloc&amp; a, T* p)</a>
<a name="ln1346">        {</a>
<a name="ln1347">          a.destroy(p);</a>
<a name="ln1348">        }</a>
<a name="ln1349"> </a>
<a name="ln1350">        template &lt;typename T&gt;</a>
<a name="ln1351">        static typename boost::disable_if_c&lt;</a>
<a name="ln1352">          boost::unordered::detail::has_destroy&lt;Alloc, T&gt;::value&gt;::type</a>
<a name="ln1353">        destroy(Alloc&amp;, T* p)</a>
<a name="ln1354">        {</a>
<a name="ln1355">          boost::unordered::detail::func::destroy(p);</a>
<a name="ln1356">        }</a>
<a name="ln1357"> </a>
<a name="ln1358">#else</a>
<a name="ln1359"> </a>
<a name="ln1360">        // If we don't have SFINAE expressions, only call construct for the</a>
<a name="ln1361">        // copy constructor for the allocator's value_type - as that's</a>
<a name="ln1362">        // the only construct method that old fashioned allocators support.</a>
<a name="ln1363"> </a>
<a name="ln1364">        template &lt;typename T&gt;</a>
<a name="ln1365">        static void construct(Alloc&amp; a, T* p, T const&amp; x,</a>
<a name="ln1366">          typename boost::enable_if_c&lt;</a>
<a name="ln1367">            boost::unordered::detail::has_construct&lt;Alloc, T&gt;::value &amp;&amp;</a>
<a name="ln1368">              boost::is_same&lt;T, value_type&gt;::value,</a>
<a name="ln1369">            void*&gt;::type = 0)</a>
<a name="ln1370">        {</a>
<a name="ln1371">          a.construct(p, x);</a>
<a name="ln1372">        }</a>
<a name="ln1373"> </a>
<a name="ln1374">        template &lt;typename T&gt;</a>
<a name="ln1375">        static void construct(Alloc&amp;, T* p, T const&amp; x,</a>
<a name="ln1376">          typename boost::disable_if_c&lt;</a>
<a name="ln1377">            boost::unordered::detail::has_construct&lt;Alloc, T&gt;::value &amp;&amp;</a>
<a name="ln1378">              boost::is_same&lt;T, value_type&gt;::value,</a>
<a name="ln1379">            void*&gt;::type = 0)</a>
<a name="ln1380">        {</a>
<a name="ln1381">          new (static_cast&lt;void*&gt;(p)) T(x);</a>
<a name="ln1382">        }</a>
<a name="ln1383"> </a>
<a name="ln1384">        template &lt;typename T&gt;</a>
<a name="ln1385">        static void destroy(Alloc&amp; a, T* p,</a>
<a name="ln1386">          typename boost::enable_if_c&lt;</a>
<a name="ln1387">            boost::unordered::detail::has_destroy&lt;Alloc, T&gt;::value &amp;&amp;</a>
<a name="ln1388">              boost::is_same&lt;T, value_type&gt;::value,</a>
<a name="ln1389">            void*&gt;::type = 0)</a>
<a name="ln1390">        {</a>
<a name="ln1391">          a.destroy(p);</a>
<a name="ln1392">        }</a>
<a name="ln1393"> </a>
<a name="ln1394">        template &lt;typename T&gt;</a>
<a name="ln1395">        static void destroy(Alloc&amp;, T* p,</a>
<a name="ln1396">          typename boost::disable_if_c&lt;</a>
<a name="ln1397">            boost::unordered::detail::has_destroy&lt;Alloc, T&gt;::value &amp;&amp;</a>
<a name="ln1398">              boost::is_same&lt;T, value_type&gt;::value,</a>
<a name="ln1399">            void*&gt;::type = 0)</a>
<a name="ln1400">        {</a>
<a name="ln1401">          boost::unordered::detail::func::destroy(p);</a>
<a name="ln1402">        }</a>
<a name="ln1403"> </a>
<a name="ln1404">#endif</a>
<a name="ln1405"> </a>
<a name="ln1406">        static size_type max_size(const Alloc&amp; a)</a>
<a name="ln1407">        {</a>
<a name="ln1408">          return boost::unordered::detail::func::call_max_size&lt;size_type&gt;(a);</a>
<a name="ln1409">        }</a>
<a name="ln1410"> </a>
<a name="ln1411">        // Allocator propagation on construction</a>
<a name="ln1412"> </a>
<a name="ln1413">        static Alloc select_on_container_copy_construction(Alloc const&amp; rhs)</a>
<a name="ln1414">        {</a>
<a name="ln1415">          return boost::unordered::detail::func::</a>
<a name="ln1416">            call_select_on_container_copy_construction(rhs);</a>
<a name="ln1417">        }</a>
<a name="ln1418"> </a>
<a name="ln1419">        // Allocator propagation on assignment and swap.</a>
<a name="ln1420">        // Return true if lhs is modified.</a>
<a name="ln1421">        typedef BOOST_UNORDERED_DEFAULT_TYPE(Alloc,</a>
<a name="ln1422">          propagate_on_container_copy_assignment,</a>
<a name="ln1423">          false_type) propagate_on_container_copy_assignment;</a>
<a name="ln1424">        typedef BOOST_UNORDERED_DEFAULT_TYPE(Alloc,</a>
<a name="ln1425">          propagate_on_container_move_assignment,</a>
<a name="ln1426">          false_type) propagate_on_container_move_assignment;</a>
<a name="ln1427">        typedef BOOST_UNORDERED_DEFAULT_TYPE(Alloc, propagate_on_container_swap,</a>
<a name="ln1428">          false_type) propagate_on_container_swap;</a>
<a name="ln1429"> </a>
<a name="ln1430">        typedef BOOST_UNORDERED_DEFAULT_TYPE(Alloc, is_always_equal,</a>
<a name="ln1431">          typename boost::is_empty&lt;Alloc&gt;::type) is_always_equal;</a>
<a name="ln1432">      };</a>
<a name="ln1433">    }</a>
<a name="ln1434">  }</a>
<a name="ln1435">}</a>
<a name="ln1436"> </a>
<a name="ln1437">#undef BOOST_UNORDERED_DEFAULT_TYPE_TMPLT</a>
<a name="ln1438">#undef BOOST_UNORDERED_DEFAULT_TYPE</a>
<a name="ln1439"> </a>
<a name="ln1440">////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln1441">//</a>
<a name="ln1442">// std::allocator_traits</a>
<a name="ln1443"> </a>
<a name="ln1444">#elif BOOST_UNORDERED_USE_ALLOCATOR_TRAITS == 1</a>
<a name="ln1445"> </a>
<a name="ln1446">#include &lt;memory&gt;</a>
<a name="ln1447"> </a>
<a name="ln1448">namespace boost {</a>
<a name="ln1449">  namespace unordered {</a>
<a name="ln1450">    namespace detail {</a>
<a name="ln1451"> </a>
<a name="ln1452">      BOOST_UNORDERED_DEFAULT_TYPE_TMPLT(is_always_equal);</a>
<a name="ln1453"> </a>
<a name="ln1454">      template &lt;typename Alloc&gt;</a>
<a name="ln1455">      struct allocator_traits : std::allocator_traits&lt;Alloc&gt;</a>
<a name="ln1456">      {</a>
<a name="ln1457">        // As is_always_equal was introduced in C++17, std::allocator_traits</a>
<a name="ln1458">        // doesn't always have it. So use it when available, implement it</a>
<a name="ln1459">        // ourselves when not. Would be simpler not to bother with</a>
<a name="ln1460">        // std::allocator_traits, but I feel like I should try to use</a>
<a name="ln1461">        // it where possible.</a>
<a name="ln1462">        typedef BOOST_UNORDERED_DEFAULT_TYPE(std::allocator_traits&lt;Alloc&gt;,</a>
<a name="ln1463">          is_always_equal,</a>
<a name="ln1464">          BOOST_UNORDERED_DEFAULT_TYPE(Alloc, is_always_equal,</a>
<a name="ln1465">            typename boost::is_empty&lt;Alloc&gt;::type)) is_always_equal;</a>
<a name="ln1466">      };</a>
<a name="ln1467"> </a>
<a name="ln1468">      template &lt;typename Alloc, typename T&gt; struct rebind_wrap</a>
<a name="ln1469">      {</a>
<a name="ln1470">        typedef typename std::allocator_traits&lt;Alloc&gt;::template rebind_alloc&lt;T&gt;</a>
<a name="ln1471">          type;</a>
<a name="ln1472">      };</a>
<a name="ln1473">    }</a>
<a name="ln1474">  }</a>
<a name="ln1475">}</a>
<a name="ln1476"> </a>
<a name="ln1477">////////////////////////////////////////////////////////////////////////////////</a>
<a name="ln1478">//</a>
<a name="ln1479">// boost::container::allocator_traits</a>
<a name="ln1480"> </a>
<a name="ln1481">#elif BOOST_UNORDERED_USE_ALLOCATOR_TRAITS == 2</a>
<a name="ln1482"> </a>
<a name="ln1483">#include &lt;boost/container/allocator_traits.hpp&gt;</a>
<a name="ln1484"> </a>
<a name="ln1485">namespace boost {</a>
<a name="ln1486">  namespace unordered {</a>
<a name="ln1487">    namespace detail {</a>
<a name="ln1488"> </a>
<a name="ln1489">      template &lt;typename Alloc&gt;</a>
<a name="ln1490">      struct allocator_traits : boost::container::allocator_traits&lt;Alloc&gt;</a>
<a name="ln1491">      {</a>
<a name="ln1492">      };</a>
<a name="ln1493"> </a>
<a name="ln1494">      template &lt;typename Alloc, typename T&gt;</a>
<a name="ln1495">      struct rebind_wrap : boost::container::allocator_traits&lt;</a>
<a name="ln1496">                             Alloc&gt;::template portable_rebind_alloc&lt;T&gt;</a>
<a name="ln1497">      {</a>
<a name="ln1498">      };</a>
<a name="ln1499">    }</a>
<a name="ln1500">  }</a>
<a name="ln1501">}</a>
<a name="ln1502"> </a>
<a name="ln1503">#else</a>
<a name="ln1504"> </a>
<a name="ln1505">#error &quot;Invalid BOOST_UNORDERED_USE_ALLOCATOR_TRAITS value.&quot;</a>
<a name="ln1506"> </a>
<a name="ln1507">#endif</a>
<a name="ln1508"> </a>
<a name="ln1509">////////////////////////////////////////////////////////////////////////////</a>
<a name="ln1510">// Functions used to construct nodes. Emulates variadic construction,</a>
<a name="ln1511">// piecewise construction etc.</a>
<a name="ln1512"> </a>
<a name="ln1513">////////////////////////////////////////////////////////////////////////////</a>
<a name="ln1514">// construct_value</a>
<a name="ln1515">//</a>
<a name="ln1516">// Only use allocator_traits::construct, allocator_traits::destroy when full</a>
<a name="ln1517">// C++11 support is available.</a>
<a name="ln1518"> </a>
<a name="ln1519">#if BOOST_UNORDERED_CXX11_CONSTRUCTION</a>
<a name="ln1520"> </a>
<a name="ln1521">#define BOOST_UNORDERED_CALL_CONSTRUCT1(Traits, alloc, address, a0)            \</a>
<a name="ln1522">  Traits::construct(alloc, address, a0)</a>
<a name="ln1523">#define BOOST_UNORDERED_CALL_DESTROY(Traits, alloc, x) Traits::destroy(alloc, x)</a>
<a name="ln1524"> </a>
<a name="ln1525">#elif !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES)</a>
<a name="ln1526"> </a>
<a name="ln1527">namespace boost {</a>
<a name="ln1528">  namespace unordered {</a>
<a name="ln1529">    namespace detail {</a>
<a name="ln1530">      namespace func {</a>
<a name="ln1531">        template &lt;typename T, typename... Args&gt;</a>
<a name="ln1532">        inline void construct_value(T* address, BOOST_FWD_REF(Args)... args)</a>
<a name="ln1533">        {</a>
<a name="ln1534">          new ((void*)address) T(boost::forward&lt;Args&gt;(args)...);</a>
<a name="ln1535">        }</a>
<a name="ln1536">      }</a>
<a name="ln1537">    }</a>
<a name="ln1538">  }</a>
<a name="ln1539">}</a>
<a name="ln1540"> </a>
<a name="ln1541">#define BOOST_UNORDERED_CALL_CONSTRUCT1(Traits, alloc, address, a0)            \</a>
<a name="ln1542">  boost::unordered::detail::func::construct_value(address, a0)</a>
<a name="ln1543">#define BOOST_UNORDERED_CALL_DESTROY(Traits, alloc, x)                         \</a>
<a name="ln1544">  boost::unordered::detail::func::destroy(x)</a>
<a name="ln1545"> </a>
<a name="ln1546">#else</a>
<a name="ln1547"> </a>
<a name="ln1548">namespace boost {</a>
<a name="ln1549">  namespace unordered {</a>
<a name="ln1550">    namespace detail {</a>
<a name="ln1551">      namespace func {</a>
<a name="ln1552">        template &lt;typename T&gt; inline void construct_value(T* address)</a>
<a name="ln1553">        {</a>
<a name="ln1554">          new ((void*)address) T();</a>
<a name="ln1555">        }</a>
<a name="ln1556"> </a>
<a name="ln1557">        template &lt;typename T, typename A0&gt;</a>
<a name="ln1558">        inline void construct_value(T* address, BOOST_FWD_REF(A0) a0)</a>
<a name="ln1559">        {</a>
<a name="ln1560">          new ((void*)address) T(boost::forward&lt;A0&gt;(a0));</a>
<a name="ln1561">        }</a>
<a name="ln1562">      }</a>
<a name="ln1563">    }</a>
<a name="ln1564">  }</a>
<a name="ln1565">}</a>
<a name="ln1566"> </a>
<a name="ln1567">#define BOOST_UNORDERED_CALL_CONSTRUCT1(Traits, alloc, address, a0)            \</a>
<a name="ln1568">  boost::unordered::detail::func::construct_value(address, a0)</a>
<a name="ln1569">#define BOOST_UNORDERED_CALL_DESTROY(Traits, alloc, x)                         \</a>
<a name="ln1570">  boost::unordered::detail::func::destroy(x)</a>
<a name="ln1571"> </a>
<a name="ln1572">#endif</a>
<a name="ln1573"> </a>
<a name="ln1574">////////////////////////////////////////////////////////////////////////////</a>
<a name="ln1575">// Construct from tuple</a>
<a name="ln1576">//</a>
<a name="ln1577">// Used to emulate piecewise construction.</a>
<a name="ln1578"> </a>
<a name="ln1579">#define BOOST_UNORDERED_CONSTRUCT_FROM_TUPLE(z, n, namespace_)                 \</a>
<a name="ln1580">  template &lt;typename Alloc, typename T,                                        \</a>
<a name="ln1581">    BOOST_PP_ENUM_PARAMS_Z(z, n, typename A)&gt;                                  \</a>
<a name="ln1582">  void construct_from_tuple(Alloc&amp;, T* ptr,                                    \</a>
<a name="ln1583">    namespace_::tuple&lt;BOOST_PP_ENUM_PARAMS_Z(z, n, A)&gt; const&amp; x)               \</a>
<a name="ln1584">  {                                                                            \</a>
<a name="ln1585">    new ((void*)ptr)                                                           \</a>
<a name="ln1586">      T(BOOST_PP_ENUM_##z(n, BOOST_UNORDERED_GET_TUPLE_ARG, namespace_));      \</a>
<a name="ln1587">  }</a>
<a name="ln1588"> </a>
<a name="ln1589">#define BOOST_UNORDERED_GET_TUPLE_ARG(z, n, namespace_) namespace_::get&lt;n&gt;(x)</a>
<a name="ln1590"> </a>
<a name="ln1591">// construct_from_tuple for boost::tuple</a>
<a name="ln1592">// The workaround for old Sun compilers comes later in the file.</a>
<a name="ln1593"> </a>
<a name="ln1594">#if !BOOST_UNORDERED_SUN_WORKAROUNDS1</a>
<a name="ln1595"> </a>
<a name="ln1596">namespace boost {</a>
<a name="ln1597">  namespace unordered {</a>
<a name="ln1598">    namespace detail {</a>
<a name="ln1599">      namespace func {</a>
<a name="ln1600">        template &lt;typename Alloc, typename T&gt;</a>
<a name="ln1601">        void construct_from_tuple(Alloc&amp;, T* ptr, boost::tuple&lt;&gt;)</a>
<a name="ln1602">        {</a>
<a name="ln1603">          new ((void*)ptr) T();</a>
<a name="ln1604">        }</a>
<a name="ln1605"> </a>
<a name="ln1606">        BOOST_UNORDERED_CONSTRUCT_FROM_TUPLE(1, 1, boost)</a>
<a name="ln1607">        BOOST_UNORDERED_CONSTRUCT_FROM_TUPLE(1, 2, boost)</a>
<a name="ln1608">        BOOST_UNORDERED_CONSTRUCT_FROM_TUPLE(1, 3, boost)</a>
<a name="ln1609">        BOOST_UNORDERED_CONSTRUCT_FROM_TUPLE(1, 4, boost)</a>
<a name="ln1610">        BOOST_UNORDERED_CONSTRUCT_FROM_TUPLE(1, 5, boost)</a>
<a name="ln1611">        BOOST_UNORDERED_CONSTRUCT_FROM_TUPLE(1, 6, boost)</a>
<a name="ln1612">        BOOST_UNORDERED_CONSTRUCT_FROM_TUPLE(1, 7, boost)</a>
<a name="ln1613">        BOOST_UNORDERED_CONSTRUCT_FROM_TUPLE(1, 8, boost)</a>
<a name="ln1614">        BOOST_UNORDERED_CONSTRUCT_FROM_TUPLE(1, 9, boost)</a>
<a name="ln1615">        BOOST_UNORDERED_CONSTRUCT_FROM_TUPLE(1, 10, boost)</a>
<a name="ln1616">      }</a>
<a name="ln1617">    }</a>
<a name="ln1618">  }</a>
<a name="ln1619">}</a>
<a name="ln1620"> </a>
<a name="ln1621">#endif</a>
<a name="ln1622"> </a>
<a name="ln1623">// construct_from_tuple for std::tuple</a>
<a name="ln1624"> </a>
<a name="ln1625">#if !BOOST_UNORDERED_CXX11_CONSTRUCTION &amp;&amp; BOOST_UNORDERED_TUPLE_ARGS</a>
<a name="ln1626"> </a>
<a name="ln1627">namespace boost {</a>
<a name="ln1628">  namespace unordered {</a>
<a name="ln1629">    namespace detail {</a>
<a name="ln1630">      namespace func {</a>
<a name="ln1631">        template &lt;typename Alloc, typename T&gt;</a>
<a name="ln1632">        void construct_from_tuple(Alloc&amp;, T* ptr, std::tuple&lt;&gt;)</a>
<a name="ln1633">        {</a>
<a name="ln1634">          new ((void*)ptr) T();</a>
<a name="ln1635">        }</a>
<a name="ln1636"> </a>
<a name="ln1637">        BOOST_UNORDERED_CONSTRUCT_FROM_TUPLE(1, 1, std)</a>
<a name="ln1638">        BOOST_UNORDERED_CONSTRUCT_FROM_TUPLE(1, 2, std)</a>
<a name="ln1639">        BOOST_UNORDERED_CONSTRUCT_FROM_TUPLE(1, 3, std)</a>
<a name="ln1640">        BOOST_UNORDERED_CONSTRUCT_FROM_TUPLE(1, 4, std)</a>
<a name="ln1641">        BOOST_UNORDERED_CONSTRUCT_FROM_TUPLE(1, 5, std)</a>
<a name="ln1642"> </a>
<a name="ln1643">#if BOOST_UNORDERED_TUPLE_ARGS &gt;= 6</a>
<a name="ln1644">        BOOST_PP_REPEAT_FROM_TO(6, BOOST_PP_INC(BOOST_UNORDERED_TUPLE_ARGS),</a>
<a name="ln1645">          BOOST_UNORDERED_CONSTRUCT_FROM_TUPLE, std)</a>
<a name="ln1646">#endif</a>
<a name="ln1647">      }</a>
<a name="ln1648">    }</a>
<a name="ln1649">  }</a>
<a name="ln1650">}</a>
<a name="ln1651"> </a>
<a name="ln1652">#endif</a>
<a name="ln1653"> </a>
<a name="ln1654">#undef BOOST_UNORDERED_CONSTRUCT_FROM_TUPLE</a>
<a name="ln1655">#undef BOOST_UNORDERED_GET_TUPLE_ARG</a>
<a name="ln1656"> </a>
<a name="ln1657">// construct_from_tuple for boost::tuple on old versions of sunpro.</a>
<a name="ln1658">//</a>
<a name="ln1659">// Old versions of Sun C++ had problems with template overloads of</a>
<a name="ln1660">// boost::tuple, so to fix it I added a distinct type for each length to</a>
<a name="ln1661">// the overloads. That means there's no possible ambiguity between the</a>
<a name="ln1662">// different overloads, so that the compiler doesn't get confused</a>
<a name="ln1663"> </a>
<a name="ln1664">#if BOOST_UNORDERED_SUN_WORKAROUNDS1</a>
<a name="ln1665"> </a>
<a name="ln1666">#define BOOST_UNORDERED_CONSTRUCT_FROM_TUPLE(z, n, namespace_)                 \</a>
<a name="ln1667">  template &lt;typename Alloc, typename T,                                        \</a>
<a name="ln1668">    BOOST_PP_ENUM_PARAMS_Z(z, n, typename A)&gt;                                  \</a>
<a name="ln1669">  void construct_from_tuple_impl(boost::unordered::detail::func::length&lt;n&gt;,    \</a>
<a name="ln1670">    Alloc&amp;, T* ptr,                                                            \</a>
<a name="ln1671">    namespace_::tuple&lt;BOOST_PP_ENUM_PARAMS_Z(z, n, A)&gt; const&amp; x)               \</a>
<a name="ln1672">  {                                                                            \</a>
<a name="ln1673">    new ((void*)ptr)                                                           \</a>
<a name="ln1674">      T(BOOST_PP_ENUM_##z(n, BOOST_UNORDERED_GET_TUPLE_ARG, namespace_));      \</a>
<a name="ln1675">  }</a>
<a name="ln1676"> </a>
<a name="ln1677">#define BOOST_UNORDERED_GET_TUPLE_ARG(z, n, namespace_) namespace_::get&lt;n&gt;(x)</a>
<a name="ln1678"> </a>
<a name="ln1679">namespace boost {</a>
<a name="ln1680">  namespace unordered {</a>
<a name="ln1681">    namespace detail {</a>
<a name="ln1682">      namespace func {</a>
<a name="ln1683">        template &lt;int N&gt; struct length</a>
<a name="ln1684">        {</a>
<a name="ln1685">        };</a>
<a name="ln1686"> </a>
<a name="ln1687">        template &lt;typename Alloc, typename T&gt;</a>
<a name="ln1688">        void construct_from_tuple_impl(</a>
<a name="ln1689">          boost::unordered::detail::func::length&lt;0&gt;, Alloc&amp;, T* ptr,</a>
<a name="ln1690">          boost::tuple&lt;&gt;)</a>
<a name="ln1691">        {</a>
<a name="ln1692">          new ((void*)ptr) T();</a>
<a name="ln1693">        }</a>
<a name="ln1694"> </a>
<a name="ln1695">        BOOST_UNORDERED_CONSTRUCT_FROM_TUPLE(1, 1, boost)</a>
<a name="ln1696">        BOOST_UNORDERED_CONSTRUCT_FROM_TUPLE(1, 2, boost)</a>
<a name="ln1697">        BOOST_UNORDERED_CONSTRUCT_FROM_TUPLE(1, 3, boost)</a>
<a name="ln1698">        BOOST_UNORDERED_CONSTRUCT_FROM_TUPLE(1, 4, boost)</a>
<a name="ln1699">        BOOST_UNORDERED_CONSTRUCT_FROM_TUPLE(1, 5, boost)</a>
<a name="ln1700">        BOOST_UNORDERED_CONSTRUCT_FROM_TUPLE(1, 6, boost)</a>
<a name="ln1701">        BOOST_UNORDERED_CONSTRUCT_FROM_TUPLE(1, 7, boost)</a>
<a name="ln1702">        BOOST_UNORDERED_CONSTRUCT_FROM_TUPLE(1, 8, boost)</a>
<a name="ln1703">        BOOST_UNORDERED_CONSTRUCT_FROM_TUPLE(1, 9, boost)</a>
<a name="ln1704">        BOOST_UNORDERED_CONSTRUCT_FROM_TUPLE(1, 10, boost)</a>
<a name="ln1705"> </a>
<a name="ln1706">        template &lt;typename Alloc, typename T, typename Tuple&gt;</a>
<a name="ln1707">        void construct_from_tuple(Alloc&amp; alloc, T* ptr, Tuple const&amp; x)</a>
<a name="ln1708">        {</a>
<a name="ln1709">          construct_from_tuple_impl(boost::unordered::detail::func::length&lt;</a>
<a name="ln1710">                                      boost::tuples::length&lt;Tuple&gt;::value&gt;(),</a>
<a name="ln1711">            alloc, ptr, x);</a>
<a name="ln1712">        }</a>
<a name="ln1713">      }</a>
<a name="ln1714">    }</a>
<a name="ln1715">  }</a>
<a name="ln1716">}</a>
<a name="ln1717"> </a>
<a name="ln1718">#undef BOOST_UNORDERED_CONSTRUCT_FROM_TUPLE</a>
<a name="ln1719">#undef BOOST_UNORDERED_GET_TUPLE_ARG</a>
<a name="ln1720"> </a>
<a name="ln1721">#endif</a>
<a name="ln1722"> </a>
<a name="ln1723">namespace boost {</a>
<a name="ln1724">  namespace unordered {</a>
<a name="ln1725">    namespace detail {</a>
<a name="ln1726">      namespace func {</a>
<a name="ln1727">        ////////////////////////////////////////////////////////////////////////</a>
<a name="ln1728">        // Trait to check for piecewise construction.</a>
<a name="ln1729"> </a>
<a name="ln1730">        template &lt;typename A0&gt; struct use_piecewise</a>
<a name="ln1731">        {</a>
<a name="ln1732">          static choice1::type test(</a>
<a name="ln1733">            choice1, boost::unordered::piecewise_construct_t);</a>
<a name="ln1734"> </a>
<a name="ln1735">          static choice2::type test(choice2, ...);</a>
<a name="ln1736"> </a>
<a name="ln1737">          enum</a>
<a name="ln1738">          {</a>
<a name="ln1739">            value = sizeof(choice1::type) ==</a>
<a name="ln1740">                    sizeof(test(choose(), boost::unordered::detail::make&lt;A0&gt;()))</a>
<a name="ln1741">          };</a>
<a name="ln1742">        };</a>
<a name="ln1743"> </a>
<a name="ln1744">#if BOOST_UNORDERED_CXX11_CONSTRUCTION</a>
<a name="ln1745"> </a>
<a name="ln1746">        ////////////////////////////////////////////////////////////////////////</a>
<a name="ln1747">        // Construct from variadic parameters</a>
<a name="ln1748"> </a>
<a name="ln1749">        template &lt;typename Alloc, typename T, typename... Args&gt;</a>
<a name="ln1750">        inline void construct_from_args(</a>
<a name="ln1751">          Alloc&amp; alloc, T* address, BOOST_FWD_REF(Args)... args)</a>
<a name="ln1752">        {</a>
<a name="ln1753">          boost::unordered::detail::allocator_traits&lt;Alloc&gt;::construct(</a>
<a name="ln1754">            alloc, address, boost::forward&lt;Args&gt;(args)...);</a>
<a name="ln1755">        }</a>
<a name="ln1756"> </a>
<a name="ln1757">        // For backwards compatibility, implement a special case for</a>
<a name="ln1758">        // piecewise_construct with boost::tuple</a>
<a name="ln1759"> </a>
<a name="ln1760">        template &lt;typename A0&gt; struct detect_boost_tuple</a>
<a name="ln1761">        {</a>
<a name="ln1762">          template &lt;typename T0, typename T1, typename T2, typename T3,</a>
<a name="ln1763">            typename T4, typename T5, typename T6, typename T7, typename T8,</a>
<a name="ln1764">            typename T9&gt;</a>
<a name="ln1765">          static choice1::type test(choice1,</a>
<a name="ln1766">            boost::tuple&lt;T0, T1, T2, T3, T4, T5, T6, T7, T8, T9&gt; const&amp;);</a>
<a name="ln1767"> </a>
<a name="ln1768">          static choice2::type test(choice2, ...);</a>
<a name="ln1769"> </a>
<a name="ln1770">          enum</a>
<a name="ln1771">          {</a>
<a name="ln1772">            value = sizeof(choice1::type) ==</a>
<a name="ln1773">                    sizeof(test(choose(), boost::unordered::detail::make&lt;A0&gt;()))</a>
<a name="ln1774">          };</a>
<a name="ln1775">        };</a>
<a name="ln1776"> </a>
<a name="ln1777">        // Special case for piecewise_construct</a>
<a name="ln1778"> </a>
<a name="ln1779">        template &lt;typename Alloc, typename A, typename B, typename A0,</a>
<a name="ln1780">          typename A1, typename A2&gt;</a>
<a name="ln1781">        inline typename boost::enable_if_c&lt;use_piecewise&lt;A0&gt;::value &amp;&amp;</a>
<a name="ln1782">                                             detect_boost_tuple&lt;A1&gt;::value &amp;&amp;</a>
<a name="ln1783">                                             detect_boost_tuple&lt;A2&gt;::value,</a>
<a name="ln1784">          void&gt;::type</a>
<a name="ln1785">        construct_from_args(Alloc&amp; alloc, std::pair&lt;A, B&gt;* address,</a>
<a name="ln1786">          BOOST_FWD_REF(A0), BOOST_FWD_REF(A1) a1, BOOST_FWD_REF(A2) a2)</a>
<a name="ln1787">        {</a>
<a name="ln1788">          boost::unordered::detail::func::construct_from_tuple(</a>
<a name="ln1789">            alloc, boost::addressof(address-&gt;first), boost::forward&lt;A1&gt;(a1));</a>
<a name="ln1790">          BOOST_TRY</a>
<a name="ln1791">          {</a>
<a name="ln1792">            boost::unordered::detail::func::construct_from_tuple(</a>
<a name="ln1793">              alloc, boost::addressof(address-&gt;second), boost::forward&lt;A2&gt;(a2));</a>
<a name="ln1794">          }</a>
<a name="ln1795">          BOOST_CATCH(...)</a>
<a name="ln1796">          {</a>
<a name="ln1797">            boost::unordered::detail::func::destroy(</a>
<a name="ln1798">              boost::addressof(address-&gt;first));</a>
<a name="ln1799">            BOOST_RETHROW</a>
<a name="ln1800">          }</a>
<a name="ln1801">          BOOST_CATCH_END</a>
<a name="ln1802">        }</a>
<a name="ln1803"> </a>
<a name="ln1804">#elif !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES)</a>
<a name="ln1805"> </a>
<a name="ln1806">        ////////////////////////////////////////////////////////////////////////</a>
<a name="ln1807">        // Construct from variadic parameters</a>
<a name="ln1808"> </a>
<a name="ln1809">        template &lt;typename Alloc, typename T, typename... Args&gt;</a>
<a name="ln1810">        inline void construct_from_args(</a>
<a name="ln1811">          Alloc&amp;, T* address, BOOST_FWD_REF(Args)... args)</a>
<a name="ln1812">        {</a>
<a name="ln1813">          new ((void*)address) T(boost::forward&lt;Args&gt;(args)...);</a>
<a name="ln1814">        }</a>
<a name="ln1815"> </a>
<a name="ln1816">        // Special case for piecewise_construct</a>
<a name="ln1817"> </a>
<a name="ln1818">        template &lt;typename Alloc, typename A, typename B, typename A0,</a>
<a name="ln1819">          typename A1, typename A2&gt;</a>
<a name="ln1820">        inline typename enable_if&lt;use_piecewise&lt;A0&gt;, void&gt;::type</a>
<a name="ln1821">        construct_from_args(Alloc&amp; alloc, std::pair&lt;A, B&gt;* address,</a>
<a name="ln1822">          BOOST_FWD_REF(A0), BOOST_FWD_REF(A1) a1, BOOST_FWD_REF(A2) a2)</a>
<a name="ln1823">        {</a>
<a name="ln1824">          boost::unordered::detail::func::construct_from_tuple(</a>
<a name="ln1825">            alloc, boost::addressof(address-&gt;first), boost::forward&lt;A1&gt;(a1));</a>
<a name="ln1826">          BOOST_TRY</a>
<a name="ln1827">          {</a>
<a name="ln1828">            boost::unordered::detail::func::construct_from_tuple(</a>
<a name="ln1829">              alloc, boost::addressof(address-&gt;second), boost::forward&lt;A2&gt;(a2));</a>
<a name="ln1830">          }</a>
<a name="ln1831">          BOOST_CATCH(...)</a>
<a name="ln1832">          {</a>
<a name="ln1833">            boost::unordered::detail::func::destroy(</a>
<a name="ln1834">              boost::addressof(address-&gt;first));</a>
<a name="ln1835">            BOOST_RETHROW</a>
<a name="ln1836">          }</a>
<a name="ln1837">          BOOST_CATCH_END</a>
<a name="ln1838">        }</a>
<a name="ln1839"> </a>
<a name="ln1840">#else // BOOST_NO_CXX11_VARIADIC_TEMPLATES</a>
<a name="ln1841"> </a>
<a name="ln1842">        ////////////////////////////////////////////////////////////////////////</a>
<a name="ln1843">        // Construct from emplace_args</a>
<a name="ln1844"> </a>
<a name="ln1845">        // Explicitly write out first three overloads for the sake of sane</a>
<a name="ln1846">        // error messages.</a>
<a name="ln1847"> </a>
<a name="ln1848">        template &lt;typename Alloc, typename T, typename A0&gt;</a>
<a name="ln1849">        inline void construct_from_args(</a>
<a name="ln1850">          Alloc&amp;, T* address, emplace_args1&lt;A0&gt; const&amp; args)</a>
<a name="ln1851">        {</a>
<a name="ln1852">          new ((void*)address) T(boost::forward&lt;A0&gt;(args.a0));</a>
<a name="ln1853">        }</a>
<a name="ln1854"> </a>
<a name="ln1855">        template &lt;typename Alloc, typename T, typename A0, typename A1&gt;</a>
<a name="ln1856">        inline void construct_from_args(</a>
<a name="ln1857">          Alloc&amp;, T* address, emplace_args2&lt;A0, A1&gt; const&amp; args)</a>
<a name="ln1858">        {</a>
<a name="ln1859">          new ((void*)address)</a>
<a name="ln1860">            T(boost::forward&lt;A0&gt;(args.a0), boost::forward&lt;A1&gt;(args.a1));</a>
<a name="ln1861">        }</a>
<a name="ln1862"> </a>
<a name="ln1863">        template &lt;typename Alloc, typename T, typename A0, typename A1,</a>
<a name="ln1864">          typename A2&gt;</a>
<a name="ln1865">        inline void construct_from_args(</a>
<a name="ln1866">          Alloc&amp;, T* address, emplace_args3&lt;A0, A1, A2&gt; const&amp; args)</a>
<a name="ln1867">        {</a>
<a name="ln1868">          new ((void*)address) T(boost::forward&lt;A0&gt;(args.a0),</a>
<a name="ln1869">            boost::forward&lt;A1&gt;(args.a1), boost::forward&lt;A2&gt;(args.a2));</a>
<a name="ln1870">        }</a>
<a name="ln1871"> </a>
<a name="ln1872">// Use a macro for the rest.</a>
<a name="ln1873"> </a>
<a name="ln1874">#define BOOST_UNORDERED_CONSTRUCT_IMPL(z, num_params, _)                       \</a>
<a name="ln1875">  template &lt;typename Alloc, typename T,                                        \</a>
<a name="ln1876">    BOOST_PP_ENUM_PARAMS_Z(z, num_params, typename A)&gt;                         \</a>
<a name="ln1877">  inline void construct_from_args(Alloc&amp;, T* address,                          \</a>
<a name="ln1878">    boost::unordered::detail::BOOST_PP_CAT(emplace_args, num_params) &lt;         \</a>
<a name="ln1879">      BOOST_PP_ENUM_PARAMS_Z(z, num_params, A) &gt; const&amp; args)                  \</a>
<a name="ln1880">  {                                                                            \</a>
<a name="ln1881">    new ((void*)address)                                                       \</a>
<a name="ln1882">      T(BOOST_PP_ENUM_##z(num_params, BOOST_UNORDERED_CALL_FORWARD, args.a));  \</a>
<a name="ln1883">  }</a>
<a name="ln1884"> </a>
<a name="ln1885">        BOOST_UNORDERED_CONSTRUCT_IMPL(1, 4, _)</a>
<a name="ln1886">        BOOST_UNORDERED_CONSTRUCT_IMPL(1, 5, _)</a>
<a name="ln1887">        BOOST_UNORDERED_CONSTRUCT_IMPL(1, 6, _)</a>
<a name="ln1888">        BOOST_UNORDERED_CONSTRUCT_IMPL(1, 7, _)</a>
<a name="ln1889">        BOOST_UNORDERED_CONSTRUCT_IMPL(1, 8, _)</a>
<a name="ln1890">        BOOST_UNORDERED_CONSTRUCT_IMPL(1, 9, _)</a>
<a name="ln1891">        BOOST_PP_REPEAT_FROM_TO(10, BOOST_PP_INC(BOOST_UNORDERED_EMPLACE_LIMIT),</a>
<a name="ln1892">          BOOST_UNORDERED_CONSTRUCT_IMPL, _)</a>
<a name="ln1893"> </a>
<a name="ln1894">#undef BOOST_UNORDERED_CONSTRUCT_IMPL</a>
<a name="ln1895"> </a>
<a name="ln1896">        // Construct with piecewise_construct</a>
<a name="ln1897"> </a>
<a name="ln1898">        template &lt;typename Alloc, typename A, typename B, typename A0,</a>
<a name="ln1899">          typename A1, typename A2&gt;</a>
<a name="ln1900">        inline void construct_from_args(Alloc&amp; alloc, std::pair&lt;A, B&gt;* address,</a>
<a name="ln1901">          boost::unordered::detail::emplace_args3&lt;A0, A1, A2&gt; const&amp; args,</a>
<a name="ln1902">          typename enable_if&lt;use_piecewise&lt;A0&gt;, void*&gt;::type = 0)</a>
<a name="ln1903">        {</a>
<a name="ln1904">          boost::unordered::detail::func::construct_from_tuple(</a>
<a name="ln1905">            alloc, boost::addressof(address-&gt;first), args.a1);</a>
<a name="ln1906">          BOOST_TRY</a>
<a name="ln1907">          {</a>
<a name="ln1908">            boost::unordered::detail::func::construct_from_tuple(</a>
<a name="ln1909">              alloc, boost::addressof(address-&gt;second), args.a2);</a>
<a name="ln1910">          }</a>
<a name="ln1911">          BOOST_CATCH(...)</a>
<a name="ln1912">          {</a>
<a name="ln1913">            boost::unordered::detail::func::destroy(</a>
<a name="ln1914">              boost::addressof(address-&gt;first));</a>
<a name="ln1915">            BOOST_RETHROW</a>
<a name="ln1916">          }</a>
<a name="ln1917">          BOOST_CATCH_END</a>
<a name="ln1918">        }</a>
<a name="ln1919"> </a>
<a name="ln1920">#endif // BOOST_NO_CXX11_VARIADIC_TEMPLATES</a>
<a name="ln1921">      }</a>
<a name="ln1922">    }</a>
<a name="ln1923">  }</a>
<a name="ln1924">}</a>
<a name="ln1925"> </a>
<a name="ln1926">namespace boost {</a>
<a name="ln1927">  namespace unordered {</a>
<a name="ln1928">    namespace detail {</a>
<a name="ln1929"> </a>
<a name="ln1930">      ///////////////////////////////////////////////////////////////////</a>
<a name="ln1931">      //</a>
<a name="ln1932">      // Node construction</a>
<a name="ln1933"> </a>
<a name="ln1934">      template &lt;typename NodeAlloc&gt; struct node_constructor</a>
<a name="ln1935">      {</a>
<a name="ln1936">        typedef NodeAlloc node_allocator;</a>
<a name="ln1937">        typedef boost::unordered::detail::allocator_traits&lt;NodeAlloc&gt;</a>
<a name="ln1938">          node_allocator_traits;</a>
<a name="ln1939">        typedef typename node_allocator_traits::value_type node;</a>
<a name="ln1940">        typedef typename node_allocator_traits::pointer node_pointer;</a>
<a name="ln1941">        typedef typename node::value_type value_type;</a>
<a name="ln1942"> </a>
<a name="ln1943">        node_allocator&amp; alloc_;</a>
<a name="ln1944">        node_pointer node_;</a>
<a name="ln1945"> </a>
<a name="ln1946">        node_constructor(node_allocator&amp; n) : alloc_(n), node_() {}</a>
<a name="ln1947"> </a>
<a name="ln1948">        ~node_constructor();</a>
<a name="ln1949"> </a>
<a name="ln1950">        void create_node();</a>
<a name="ln1951"> </a>
<a name="ln1952">        // no throw</a>
<a name="ln1953">        node_pointer release()</a>
<a name="ln1954">        {</a>
<a name="ln1955">          BOOST_ASSERT(node_);</a>
<a name="ln1956">          node_pointer p = node_;</a>
<a name="ln1957">          node_ = node_pointer();</a>
<a name="ln1958">          return p;</a>
<a name="ln1959">        }</a>
<a name="ln1960"> </a>
<a name="ln1961">        void reclaim(node_pointer p)</a>
<a name="ln1962">        {</a>
<a name="ln1963">          BOOST_ASSERT(!node_);</a>
<a name="ln1964">          node_ = p;</a>
<a name="ln1965">          BOOST_UNORDERED_CALL_DESTROY(</a>
<a name="ln1966">            node_allocator_traits, alloc_, node_-&gt;value_ptr());</a>
<a name="ln1967">        }</a>
<a name="ln1968"> </a>
<a name="ln1969">      private:</a>
<a name="ln1970">        node_constructor(node_constructor const&amp;);</a>
<a name="ln1971">        node_constructor&amp; operator=(node_constructor const&amp;);</a>
<a name="ln1972">      };</a>
<a name="ln1973"> </a>
<a name="ln1974">      template &lt;typename Alloc&gt; node_constructor&lt;Alloc&gt;::~node_constructor()</a>
<a name="ln1975">      {</a>
<a name="ln1976">        if (node_) {</a>
<a name="ln1977">          boost::unordered::detail::func::destroy(boost::to_address(node_));</a>
<a name="ln1978">          node_allocator_traits::deallocate(alloc_, node_, 1);</a>
<a name="ln1979">        }</a>
<a name="ln1980">      }</a>
<a name="ln1981"> </a>
<a name="ln1982">      template &lt;typename Alloc&gt; void node_constructor&lt;Alloc&gt;::create_node()</a>
<a name="ln1983">      {</a>
<a name="ln1984">        BOOST_ASSERT(!node_);</a>
<a name="ln1985">        node_ = node_allocator_traits::allocate(alloc_, 1);</a>
<a name="ln1986">        new ((void*)boost::to_address(node_)) node();</a>
<a name="ln1987">      }</a>
<a name="ln1988"> </a>
<a name="ln1989">      template &lt;typename NodeAlloc&gt; struct node_tmp</a>
<a name="ln1990">      {</a>
<a name="ln1991">        typedef boost::unordered::detail::allocator_traits&lt;NodeAlloc&gt;</a>
<a name="ln1992">          node_allocator_traits;</a>
<a name="ln1993">        typedef typename node_allocator_traits::pointer node_pointer;</a>
<a name="ln1994">        typedef typename node_allocator_traits::value_type node;</a>
<a name="ln1995"> </a>
<a name="ln1996">        NodeAlloc&amp; alloc_;</a>
<a name="ln1997">        node_pointer node_;</a>
<a name="ln1998"> </a>
<a name="ln1999">        explicit node_tmp(node_pointer n, NodeAlloc&amp; a) : alloc_(a), node_(n) {}</a>
<a name="ln2000"> </a>
<a name="ln2001">        ~node_tmp();</a>
<a name="ln2002"> </a>
<a name="ln2003">        // no throw</a>
<a name="ln2004">        node_pointer release()</a>
<a name="ln2005">        {</a>
<a name="ln2006">          node_pointer p = node_;</a>
<a name="ln2007">          node_ = node_pointer();</a>
<a name="ln2008">          return p;</a>
<a name="ln2009">        }</a>
<a name="ln2010">      };</a>
<a name="ln2011"> </a>
<a name="ln2012">      template &lt;typename Alloc&gt; node_tmp&lt;Alloc&gt;::~node_tmp()</a>
<a name="ln2013">      {</a>
<a name="ln2014">        if (node_) {</a>
<a name="ln2015">          BOOST_UNORDERED_CALL_DESTROY(</a>
<a name="ln2016">            node_allocator_traits, alloc_, node_-&gt;value_ptr());</a>
<a name="ln2017">          boost::unordered::detail::func::destroy(boost::to_address(node_));</a>
<a name="ln2018">          node_allocator_traits::deallocate(alloc_, node_, 1);</a>
<a name="ln2019">        }</a>
<a name="ln2020">      }</a>
<a name="ln2021">    }</a>
<a name="ln2022">  }</a>
<a name="ln2023">}</a>
<a name="ln2024"> </a>
<a name="ln2025">namespace boost {</a>
<a name="ln2026">  namespace unordered {</a>
<a name="ln2027">    namespace detail {</a>
<a name="ln2028">      namespace func {</a>
<a name="ln2029"> </a>
<a name="ln2030">        // Some nicer construct_node functions, might try to</a>
<a name="ln2031">        // improve implementation later.</a>
<a name="ln2032"> </a>
<a name="ln2033">        template &lt;typename Alloc, BOOST_UNORDERED_EMPLACE_TEMPLATE&gt;</a>
<a name="ln2034">        inline</a>
<a name="ln2035">          typename boost::unordered::detail::allocator_traits&lt;Alloc&gt;::pointer</a>
<a name="ln2036">          construct_node_from_args(Alloc&amp; alloc, BOOST_UNORDERED_EMPLACE_ARGS)</a>
<a name="ln2037">        {</a>
<a name="ln2038">          node_constructor&lt;Alloc&gt; a(alloc);</a>
<a name="ln2039">          a.create_node();</a>
<a name="ln2040">          construct_from_args(</a>
<a name="ln2041">            alloc, a.node_-&gt;value_ptr(), BOOST_UNORDERED_EMPLACE_FORWARD);</a>
<a name="ln2042">          return a.release();</a>
<a name="ln2043">        }</a>
<a name="ln2044"> </a>
<a name="ln2045">        template &lt;typename Alloc, typename U&gt;</a>
<a name="ln2046">        inline</a>
<a name="ln2047">          typename boost::unordered::detail::allocator_traits&lt;Alloc&gt;::pointer</a>
<a name="ln2048">          construct_node(Alloc&amp; alloc, BOOST_FWD_REF(U) x)</a>
<a name="ln2049">        {</a>
<a name="ln2050">          node_constructor&lt;Alloc&gt; a(alloc);</a>
<a name="ln2051">          a.create_node();</a>
<a name="ln2052">          BOOST_UNORDERED_CALL_CONSTRUCT1(</a>
<a name="ln2053">            boost::unordered::detail::allocator_traits&lt;Alloc&gt;, alloc,</a>
<a name="ln2054">            a.node_-&gt;value_ptr(), boost::forward&lt;U&gt;(x));</a>
<a name="ln2055">          return a.release();</a>
<a name="ln2056">        }</a>
<a name="ln2057"> </a>
<a name="ln2058">#if BOOST_UNORDERED_CXX11_CONSTRUCTION</a>
<a name="ln2059"> </a>
<a name="ln2060">        template &lt;typename Alloc, typename Key&gt;</a>
<a name="ln2061">        inline</a>
<a name="ln2062">          typename boost::unordered::detail::allocator_traits&lt;Alloc&gt;::pointer</a>
<a name="ln2063">          construct_node_pair(Alloc&amp; alloc, BOOST_FWD_REF(Key) k)</a>
<a name="ln2064">        {</a>
<a name="ln2065">          node_constructor&lt;Alloc&gt; a(alloc);</a>
<a name="ln2066">          a.create_node();</a>
<a name="ln2067">          boost::unordered::detail::allocator_traits&lt;Alloc&gt;::construct(alloc,</a>
<a name="ln2068">            a.node_-&gt;value_ptr(), std::piecewise_construct,</a>
<a name="ln2069">            std::forward_as_tuple(boost::forward&lt;Key&gt;(k)),</a>
<a name="ln2070">            std::forward_as_tuple());</a>
<a name="ln2071">          return a.release();</a>
<a name="ln2072">        }</a>
<a name="ln2073"> </a>
<a name="ln2074">        template &lt;typename Alloc, typename Key, typename Mapped&gt;</a>
<a name="ln2075">        inline</a>
<a name="ln2076">          typename boost::unordered::detail::allocator_traits&lt;Alloc&gt;::pointer</a>
<a name="ln2077">          construct_node_pair(</a>
<a name="ln2078">            Alloc&amp; alloc, BOOST_FWD_REF(Key) k, BOOST_FWD_REF(Mapped) m)</a>
<a name="ln2079">        {</a>
<a name="ln2080">          node_constructor&lt;Alloc&gt; a(alloc);</a>
<a name="ln2081">          a.create_node();</a>
<a name="ln2082">          boost::unordered::detail::allocator_traits&lt;Alloc&gt;::construct(alloc,</a>
<a name="ln2083">            a.node_-&gt;value_ptr(), std::piecewise_construct,</a>
<a name="ln2084">            std::forward_as_tuple(boost::forward&lt;Key&gt;(k)),</a>
<a name="ln2085">            std::forward_as_tuple(boost::forward&lt;Mapped&gt;(m)));</a>
<a name="ln2086">          return a.release();</a>
<a name="ln2087">        }</a>
<a name="ln2088"> </a>
<a name="ln2089">        template &lt;typename Alloc, typename Key, typename... Args&gt;</a>
<a name="ln2090">        inline</a>
<a name="ln2091">          typename boost::unordered::detail::allocator_traits&lt;Alloc&gt;::pointer</a>
<a name="ln2092">          construct_node_pair_from_args(</a>
<a name="ln2093">            Alloc&amp; alloc, BOOST_FWD_REF(Key) k, BOOST_FWD_REF(Args)... args)</a>
<a name="ln2094">        {</a>
<a name="ln2095">          node_constructor&lt;Alloc&gt; a(alloc);</a>
<a name="ln2096">          a.create_node();</a>
<a name="ln2097">#if !(BOOST_COMP_CLANG &amp;&amp; BOOST_COMP_CLANG &lt; BOOST_VERSION_NUMBER(3, 8, 0) &amp;&amp;  \</a>
<a name="ln2098">      defined(BOOST_LIBSTDCXX11))</a>
<a name="ln2099">          boost::unordered::detail::allocator_traits&lt;Alloc&gt;::construct(alloc,</a>
<a name="ln2100">            a.node_-&gt;value_ptr(), std::piecewise_construct,</a>
<a name="ln2101">            std::forward_as_tuple(boost::forward&lt;Key&gt;(k)),</a>
<a name="ln2102">            std::forward_as_tuple(boost::forward&lt;Args&gt;(args)...));</a>
<a name="ln2103">#else</a>
<a name="ln2104">          // It doesn't seem to be possible to construct a tuple with 3 variadic</a>
<a name="ln2105">          // rvalue reference members when using older versions of clang with</a>
<a name="ln2106">          // libstdc++, so just use std::make_tuple instead of</a>
<a name="ln2107">          // std::forward_as_tuple.</a>
<a name="ln2108">          boost::unordered::detail::allocator_traits&lt;Alloc&gt;::construct(alloc,</a>
<a name="ln2109">            a.node_-&gt;value_ptr(), std::piecewise_construct,</a>
<a name="ln2110">            std::forward_as_tuple(boost::forward&lt;Key&gt;(k)),</a>
<a name="ln2111">            std::make_tuple(boost::forward&lt;Args&gt;(args)...));</a>
<a name="ln2112">#endif</a>
<a name="ln2113">          return a.release();</a>
<a name="ln2114">        }</a>
<a name="ln2115"> </a>
<a name="ln2116">#else</a>
<a name="ln2117"> </a>
<a name="ln2118">        template &lt;typename Alloc, typename Key&gt;</a>
<a name="ln2119">        inline</a>
<a name="ln2120">          typename boost::unordered::detail::allocator_traits&lt;Alloc&gt;::pointer</a>
<a name="ln2121">          construct_node_pair(Alloc&amp; alloc, BOOST_FWD_REF(Key) k)</a>
<a name="ln2122">        {</a>
<a name="ln2123">          node_constructor&lt;Alloc&gt; a(alloc);</a>
<a name="ln2124">          a.create_node();</a>
<a name="ln2125">          boost::unordered::detail::func::construct_value(</a>
<a name="ln2126">            boost::addressof(a.node_-&gt;value_ptr()-&gt;first),</a>
<a name="ln2127">            boost::forward&lt;Key&gt;(k));</a>
<a name="ln2128">          BOOST_TRY</a>
<a name="ln2129">          {</a>
<a name="ln2130">            boost::unordered::detail::func::construct_value(</a>
<a name="ln2131">              boost::addressof(a.node_-&gt;value_ptr()-&gt;second));</a>
<a name="ln2132">          }</a>
<a name="ln2133">          BOOST_CATCH(...)</a>
<a name="ln2134">          {</a>
<a name="ln2135">            boost::unordered::detail::func::destroy(</a>
<a name="ln2136">              boost::addressof(a.node_-&gt;value_ptr()-&gt;first));</a>
<a name="ln2137">            BOOST_RETHROW</a>
<a name="ln2138">          }</a>
<a name="ln2139">          BOOST_CATCH_END</a>
<a name="ln2140">          return a.release();</a>
<a name="ln2141">        }</a>
<a name="ln2142"> </a>
<a name="ln2143">        template &lt;typename Alloc, typename Key, typename Mapped&gt;</a>
<a name="ln2144">        inline</a>
<a name="ln2145">          typename boost::unordered::detail::allocator_traits&lt;Alloc&gt;::pointer</a>
<a name="ln2146">          construct_node_pair(</a>
<a name="ln2147">            Alloc&amp; alloc, BOOST_FWD_REF(Key) k, BOOST_FWD_REF(Mapped) m)</a>
<a name="ln2148">        {</a>
<a name="ln2149">          node_constructor&lt;Alloc&gt; a(alloc);</a>
<a name="ln2150">          a.create_node();</a>
<a name="ln2151">          boost::unordered::detail::func::construct_value(</a>
<a name="ln2152">            boost::addressof(a.node_-&gt;value_ptr()-&gt;first),</a>
<a name="ln2153">            boost::forward&lt;Key&gt;(k));</a>
<a name="ln2154">          BOOST_TRY</a>
<a name="ln2155">          {</a>
<a name="ln2156">            boost::unordered::detail::func::construct_value(</a>
<a name="ln2157">              boost::addressof(a.node_-&gt;value_ptr()-&gt;second),</a>
<a name="ln2158">              boost::forward&lt;Mapped&gt;(m));</a>
<a name="ln2159">          }</a>
<a name="ln2160">          BOOST_CATCH(...)</a>
<a name="ln2161">          {</a>
<a name="ln2162">            boost::unordered::detail::func::destroy(</a>
<a name="ln2163">              boost::addressof(a.node_-&gt;value_ptr()-&gt;first));</a>
<a name="ln2164">            BOOST_RETHROW</a>
<a name="ln2165">          }</a>
<a name="ln2166">          BOOST_CATCH_END</a>
<a name="ln2167">          return a.release();</a>
<a name="ln2168">        }</a>
<a name="ln2169"> </a>
<a name="ln2170">        template &lt;typename Alloc, typename Key,</a>
<a name="ln2171">          BOOST_UNORDERED_EMPLACE_TEMPLATE&gt;</a>
<a name="ln2172">        inline</a>
<a name="ln2173">          typename boost::unordered::detail::allocator_traits&lt;Alloc&gt;::pointer</a>
<a name="ln2174">          construct_node_pair_from_args(</a>
<a name="ln2175">            Alloc&amp; alloc, BOOST_FWD_REF(Key) k, BOOST_UNORDERED_EMPLACE_ARGS)</a>
<a name="ln2176">        {</a>
<a name="ln2177">          node_constructor&lt;Alloc&gt; a(alloc);</a>
<a name="ln2178">          a.create_node();</a>
<a name="ln2179">          boost::unordered::detail::func::construct_value(</a>
<a name="ln2180">            boost::addressof(a.node_-&gt;value_ptr()-&gt;first),</a>
<a name="ln2181">            boost::forward&lt;Key&gt;(k));</a>
<a name="ln2182">          BOOST_TRY</a>
<a name="ln2183">          {</a>
<a name="ln2184">            boost::unordered::detail::func::construct_from_args(alloc,</a>
<a name="ln2185">              boost::addressof(a.node_-&gt;value_ptr()-&gt;second),</a>
<a name="ln2186">              BOOST_UNORDERED_EMPLACE_FORWARD);</a>
<a name="ln2187">          }</a>
<a name="ln2188">          BOOST_CATCH(...)</a>
<a name="ln2189">          {</a>
<a name="ln2190">            boost::unordered::detail::func::destroy(</a>
<a name="ln2191">              boost::addressof(a.node_-&gt;value_ptr()-&gt;first));</a>
<a name="ln2192">            BOOST_RETHROW</a>
<a name="ln2193">          }</a>
<a name="ln2194">          BOOST_CATCH_END</a>
<a name="ln2195">          return a.release();</a>
<a name="ln2196">        }</a>
<a name="ln2197"> </a>
<a name="ln2198">#endif</a>
<a name="ln2199">      }</a>
<a name="ln2200">    }</a>
<a name="ln2201">  }</a>
<a name="ln2202">}</a>
<a name="ln2203"> </a>
<a name="ln2204">#if defined(BOOST_MSVC)</a>
<a name="ln2205">#pragma warning(pop)</a>
<a name="ln2206">#endif</a>
<a name="ln2207"> </a>
<a name="ln2208">// The 'iterator_detail' namespace was a misguided attempt at avoiding ADL</a>
<a name="ln2209">// in the detail namespace. It didn't work because the template parameters</a>
<a name="ln2210">// were in detail. I'm not changing it at the moment to be safe. I might</a>
<a name="ln2211">// do in the future if I change the iterator types.</a>
<a name="ln2212">namespace boost {</a>
<a name="ln2213">  namespace unordered {</a>
<a name="ln2214">    namespace iterator_detail {</a>
<a name="ln2215"> </a>
<a name="ln2216">      //////////////////////////////////////////////////////////////////////////</a>
<a name="ln2217">      // Iterators</a>
<a name="ln2218">      //</a>
<a name="ln2219">      // all no throw</a>
<a name="ln2220"> </a>
<a name="ln2221">      template &lt;typename Node&gt; struct l_iterator</a>
<a name="ln2222">      {</a>
<a name="ln2223">#if !defined(BOOST_NO_MEMBER_TEMPLATE_FRIENDS)</a>
<a name="ln2224">        template &lt;typename Node2&gt;</a>
<a name="ln2225">        friend struct boost::unordered::iterator_detail::cl_iterator;</a>
<a name="ln2226"> </a>
<a name="ln2227">      private:</a>
<a name="ln2228">#endif</a>
<a name="ln2229">        typedef typename Node::node_pointer node_pointer;</a>
<a name="ln2230">        node_pointer ptr_;</a>
<a name="ln2231">        std::size_t bucket_;</a>
<a name="ln2232">        std::size_t bucket_count_;</a>
<a name="ln2233"> </a>
<a name="ln2234">      public:</a>
<a name="ln2235">        typedef typename Node::value_type element_type;</a>
<a name="ln2236">        typedef typename Node::value_type value_type;</a>
<a name="ln2237">        typedef value_type* pointer;</a>
<a name="ln2238">        typedef value_type&amp; reference;</a>
<a name="ln2239">        typedef std::ptrdiff_t difference_type;</a>
<a name="ln2240">        typedef std::forward_iterator_tag iterator_category;</a>
<a name="ln2241"> </a>
<a name="ln2242">        l_iterator() BOOST_NOEXCEPT : ptr_() {}</a>
<a name="ln2243"> </a>
<a name="ln2244">        l_iterator(node_pointer n, std::size_t b, std::size_t c) BOOST_NOEXCEPT</a>
<a name="ln2245">          : ptr_(n),</a>
<a name="ln2246">            bucket_(b),</a>
<a name="ln2247">            bucket_count_(c)</a>
<a name="ln2248">        {</a>
<a name="ln2249">        }</a>
<a name="ln2250"> </a>
<a name="ln2251">        value_type&amp; operator*() const { return ptr_-&gt;value(); }</a>
<a name="ln2252"> </a>
<a name="ln2253">        value_type* operator-&gt;() const { return ptr_-&gt;value_ptr(); }</a>
<a name="ln2254"> </a>
<a name="ln2255">        l_iterator&amp; operator++()</a>
<a name="ln2256">        {</a>
<a name="ln2257">          ptr_ = static_cast&lt;node_pointer&gt;(ptr_-&gt;next_);</a>
<a name="ln2258">          if (ptr_ &amp;&amp; ptr_-&gt;get_bucket() != bucket_)</a>
<a name="ln2259">            ptr_ = node_pointer();</a>
<a name="ln2260">          return *this;</a>
<a name="ln2261">        }</a>
<a name="ln2262"> </a>
<a name="ln2263">        l_iterator operator++(int)</a>
<a name="ln2264">        {</a>
<a name="ln2265">          l_iterator tmp(*this);</a>
<a name="ln2266">          ++(*this);</a>
<a name="ln2267">          return tmp;</a>
<a name="ln2268">        }</a>
<a name="ln2269"> </a>
<a name="ln2270">        bool operator==(l_iterator x) const BOOST_NOEXCEPT</a>
<a name="ln2271">        {</a>
<a name="ln2272">          return ptr_ == x.ptr_;</a>
<a name="ln2273">        }</a>
<a name="ln2274"> </a>
<a name="ln2275">        bool operator!=(l_iterator x) const BOOST_NOEXCEPT</a>
<a name="ln2276">        {</a>
<a name="ln2277">          return ptr_ != x.ptr_;</a>
<a name="ln2278">        }</a>
<a name="ln2279">      };</a>
<a name="ln2280"> </a>
<a name="ln2281">      template &lt;typename Node&gt; struct cl_iterator</a>
<a name="ln2282">      {</a>
<a name="ln2283">        friend struct boost::unordered::iterator_detail::l_iterator&lt;Node&gt;;</a>
<a name="ln2284"> </a>
<a name="ln2285">      private:</a>
<a name="ln2286">        typedef typename Node::node_pointer node_pointer;</a>
<a name="ln2287">        node_pointer ptr_;</a>
<a name="ln2288">        std::size_t bucket_;</a>
<a name="ln2289">        std::size_t bucket_count_;</a>
<a name="ln2290"> </a>
<a name="ln2291">      public:</a>
<a name="ln2292">        typedef typename Node::value_type const element_type;</a>
<a name="ln2293">        typedef typename Node::value_type value_type;</a>
<a name="ln2294">        typedef value_type const* pointer;</a>
<a name="ln2295">        typedef value_type const&amp; reference;</a>
<a name="ln2296">        typedef std::ptrdiff_t difference_type;</a>
<a name="ln2297">        typedef std::forward_iterator_tag iterator_category;</a>
<a name="ln2298"> </a>
<a name="ln2299">        cl_iterator() BOOST_NOEXCEPT : ptr_() {}</a>
<a name="ln2300"> </a>
<a name="ln2301">        cl_iterator(node_pointer n, std::size_t b, std::size_t c) BOOST_NOEXCEPT</a>
<a name="ln2302">          : ptr_(n),</a>
<a name="ln2303">            bucket_(b),</a>
<a name="ln2304">            bucket_count_(c)</a>
<a name="ln2305">        {</a>
<a name="ln2306">        }</a>
<a name="ln2307"> </a>
<a name="ln2308">        cl_iterator(</a>
<a name="ln2309">          boost::unordered::iterator_detail::l_iterator&lt;Node&gt; const&amp; x)</a>
<a name="ln2310">          BOOST_NOEXCEPT : ptr_(x.ptr_),</a>
<a name="ln2311">                           bucket_(x.bucket_),</a>
<a name="ln2312">                           bucket_count_(x.bucket_count_)</a>
<a name="ln2313">        {</a>
<a name="ln2314">        }</a>
<a name="ln2315"> </a>
<a name="ln2316">        value_type const&amp; operator*() const { return ptr_-&gt;value(); }</a>
<a name="ln2317"> </a>
<a name="ln2318">        value_type const* operator-&gt;() const { return ptr_-&gt;value_ptr(); }</a>
<a name="ln2319"> </a>
<a name="ln2320">        cl_iterator&amp; operator++()</a>
<a name="ln2321">        {</a>
<a name="ln2322">          ptr_ = static_cast&lt;node_pointer&gt;(ptr_-&gt;next_);</a>
<a name="ln2323">          if (ptr_ &amp;&amp; ptr_-&gt;get_bucket() != bucket_)</a>
<a name="ln2324">            ptr_ = node_pointer();</a>
<a name="ln2325">          return *this;</a>
<a name="ln2326">        }</a>
<a name="ln2327"> </a>
<a name="ln2328">        cl_iterator operator++(int)</a>
<a name="ln2329">        {</a>
<a name="ln2330">          cl_iterator tmp(*this);</a>
<a name="ln2331">          ++(*this);</a>
<a name="ln2332">          return tmp;</a>
<a name="ln2333">        }</a>
<a name="ln2334"> </a>
<a name="ln2335">        friend bool operator==(</a>
<a name="ln2336">          cl_iterator const&amp; x, cl_iterator const&amp; y) BOOST_NOEXCEPT</a>
<a name="ln2337">        {</a>
<a name="ln2338">          return x.ptr_ == y.ptr_;</a>
<a name="ln2339">        }</a>
<a name="ln2340"> </a>
<a name="ln2341">        friend bool operator!=(</a>
<a name="ln2342">          cl_iterator const&amp; x, cl_iterator const&amp; y) BOOST_NOEXCEPT</a>
<a name="ln2343">        {</a>
<a name="ln2344">          return x.ptr_ != y.ptr_;</a>
<a name="ln2345">        }</a>
<a name="ln2346">      };</a>
<a name="ln2347"> </a>
<a name="ln2348">      template &lt;typename Node&gt; struct iterator</a>
<a name="ln2349">      {</a>
<a name="ln2350">#if !defined(BOOST_NO_MEMBER_TEMPLATE_FRIENDS)</a>
<a name="ln2351">        template &lt;typename&gt;</a>
<a name="ln2352">        friend struct boost::unordered::iterator_detail::c_iterator;</a>
<a name="ln2353">        template &lt;typename&gt; friend struct boost::unordered::detail::table;</a>
<a name="ln2354"> </a>
<a name="ln2355">      private:</a>
<a name="ln2356">#endif</a>
<a name="ln2357">        typedef typename Node::node_pointer node_pointer;</a>
<a name="ln2358">        node_pointer node_;</a>
<a name="ln2359"> </a>
<a name="ln2360">      public:</a>
<a name="ln2361">        typedef typename Node::value_type element_type;</a>
<a name="ln2362">        typedef typename Node::value_type value_type;</a>
<a name="ln2363">        typedef value_type* pointer;</a>
<a name="ln2364">        typedef value_type&amp; reference;</a>
<a name="ln2365">        typedef std::ptrdiff_t difference_type;</a>
<a name="ln2366">        typedef std::forward_iterator_tag iterator_category;</a>
<a name="ln2367"> </a>
<a name="ln2368">        iterator() BOOST_NOEXCEPT : node_() {}</a>
<a name="ln2369"> </a>
<a name="ln2370">        explicit iterator(typename Node::link_pointer x) BOOST_NOEXCEPT</a>
<a name="ln2371">          : node_(static_cast&lt;node_pointer&gt;(x))</a>
<a name="ln2372">        {</a>
<a name="ln2373">        }</a>
<a name="ln2374"> </a>
<a name="ln2375">        value_type&amp; operator*() const { return node_-&gt;value(); }</a>
<a name="ln2376"> </a>
<a name="ln2377">        value_type* operator-&gt;() const { return node_-&gt;value_ptr(); }</a>
<a name="ln2378"> </a>
<a name="ln2379">        iterator&amp; operator++()</a>
<a name="ln2380">        {</a>
<a name="ln2381">          node_ = static_cast&lt;node_pointer&gt;(node_-&gt;next_);</a>
<a name="ln2382">          return *this;</a>
<a name="ln2383">        }</a>
<a name="ln2384"> </a>
<a name="ln2385">        iterator operator++(int)</a>
<a name="ln2386">        {</a>
<a name="ln2387">          iterator tmp(node_);</a>
<a name="ln2388">          node_ = static_cast&lt;node_pointer&gt;(node_-&gt;next_);</a>
<a name="ln2389">          return tmp;</a>
<a name="ln2390">        }</a>
<a name="ln2391"> </a>
<a name="ln2392">        bool operator==(iterator const&amp; x) const BOOST_NOEXCEPT</a>
<a name="ln2393">        {</a>
<a name="ln2394">          return node_ == x.node_;</a>
<a name="ln2395">        }</a>
<a name="ln2396"> </a>
<a name="ln2397">        bool operator!=(iterator const&amp; x) const BOOST_NOEXCEPT</a>
<a name="ln2398">        {</a>
<a name="ln2399">          return node_ != x.node_;</a>
<a name="ln2400">        }</a>
<a name="ln2401">      };</a>
<a name="ln2402"> </a>
<a name="ln2403">      template &lt;typename Node&gt; struct c_iterator</a>
<a name="ln2404">      {</a>
<a name="ln2405">        friend struct boost::unordered::iterator_detail::iterator&lt;Node&gt;;</a>
<a name="ln2406"> </a>
<a name="ln2407">#if !defined(BOOST_NO_MEMBER_TEMPLATE_FRIENDS)</a>
<a name="ln2408">        template &lt;typename&gt; friend struct boost::unordered::detail::table;</a>
<a name="ln2409"> </a>
<a name="ln2410">      private:</a>
<a name="ln2411">#endif</a>
<a name="ln2412">        typedef typename Node::node_pointer node_pointer;</a>
<a name="ln2413">        typedef boost::unordered::iterator_detail::iterator&lt;Node&gt; n_iterator;</a>
<a name="ln2414">        node_pointer node_;</a>
<a name="ln2415"> </a>
<a name="ln2416">      public:</a>
<a name="ln2417">        typedef typename Node::value_type const element_type;</a>
<a name="ln2418">        typedef typename Node::value_type value_type;</a>
<a name="ln2419">        typedef value_type const* pointer;</a>
<a name="ln2420">        typedef value_type const&amp; reference;</a>
<a name="ln2421">        typedef std::ptrdiff_t difference_type;</a>
<a name="ln2422">        typedef std::forward_iterator_tag iterator_category;</a>
<a name="ln2423"> </a>
<a name="ln2424">        c_iterator() BOOST_NOEXCEPT : node_() {}</a>
<a name="ln2425"> </a>
<a name="ln2426">        explicit c_iterator(typename Node::link_pointer x) BOOST_NOEXCEPT</a>
<a name="ln2427">          : node_(static_cast&lt;node_pointer&gt;(x))</a>
<a name="ln2428">        {</a>
<a name="ln2429">        }</a>
<a name="ln2430"> </a>
<a name="ln2431">        c_iterator(n_iterator const&amp; x) BOOST_NOEXCEPT : node_(x.node_) {}</a>
<a name="ln2432"> </a>
<a name="ln2433">        value_type const&amp; operator*() const { return node_-&gt;value(); }</a>
<a name="ln2434"> </a>
<a name="ln2435">        value_type const* operator-&gt;() const { return node_-&gt;value_ptr(); }</a>
<a name="ln2436"> </a>
<a name="ln2437">        c_iterator&amp; operator++()</a>
<a name="ln2438">        {</a>
<a name="ln2439">          node_ = static_cast&lt;node_pointer&gt;(node_-&gt;next_);</a>
<a name="ln2440">          return *this;</a>
<a name="ln2441">        }</a>
<a name="ln2442"> </a>
<a name="ln2443">        c_iterator operator++(int)</a>
<a name="ln2444">        {</a>
<a name="ln2445">          c_iterator tmp(node_);</a>
<a name="ln2446">          node_ = static_cast&lt;node_pointer&gt;(node_-&gt;next_);</a>
<a name="ln2447">          return tmp;</a>
<a name="ln2448">        }</a>
<a name="ln2449"> </a>
<a name="ln2450">        friend bool operator==(</a>
<a name="ln2451">          c_iterator const&amp; x, c_iterator const&amp; y) BOOST_NOEXCEPT</a>
<a name="ln2452">        {</a>
<a name="ln2453">          return x.node_ == y.node_;</a>
<a name="ln2454">        }</a>
<a name="ln2455"> </a>
<a name="ln2456">        friend bool operator!=(</a>
<a name="ln2457">          c_iterator const&amp; x, c_iterator const&amp; y) BOOST_NOEXCEPT</a>
<a name="ln2458">        {</a>
<a name="ln2459">          return x.node_ != y.node_;</a>
<a name="ln2460">        }</a>
<a name="ln2461">      };</a>
<a name="ln2462">    }</a>
<a name="ln2463">  }</a>
<a name="ln2464">}</a>
<a name="ln2465"> </a>
<a name="ln2466">namespace boost {</a>
<a name="ln2467">  namespace unordered {</a>
<a name="ln2468">    namespace detail {</a>
<a name="ln2469"> </a>
<a name="ln2470">      ///////////////////////////////////////////////////////////////////</a>
<a name="ln2471">      //</a>
<a name="ln2472">      // Node Holder</a>
<a name="ln2473">      //</a>
<a name="ln2474">      // Temporary store for nodes. Deletes any that aren't used.</a>
<a name="ln2475"> </a>
<a name="ln2476">      template &lt;typename NodeAlloc&gt; struct node_holder</a>
<a name="ln2477">      {</a>
<a name="ln2478">      private:</a>
<a name="ln2479">        typedef NodeAlloc node_allocator;</a>
<a name="ln2480">        typedef boost::unordered::detail::allocator_traits&lt;NodeAlloc&gt;</a>
<a name="ln2481">          node_allocator_traits;</a>
<a name="ln2482">        typedef typename node_allocator_traits::value_type node;</a>
<a name="ln2483">        typedef typename node_allocator_traits::pointer node_pointer;</a>
<a name="ln2484">        typedef typename node::value_type value_type;</a>
<a name="ln2485">        typedef typename node::link_pointer link_pointer;</a>
<a name="ln2486">        typedef boost::unordered::iterator_detail::iterator&lt;node&gt; iterator;</a>
<a name="ln2487"> </a>
<a name="ln2488">        node_constructor&lt;NodeAlloc&gt; constructor_;</a>
<a name="ln2489">        node_pointer nodes_;</a>
<a name="ln2490"> </a>
<a name="ln2491">      public:</a>
<a name="ln2492">        template &lt;typename Table&gt;</a>
<a name="ln2493">        explicit node_holder(Table&amp; b) : constructor_(b.node_alloc()), nodes_()</a>
<a name="ln2494">        {</a>
<a name="ln2495">          if (b.size_) {</a>
<a name="ln2496">            typename Table::link_pointer prev = b.get_previous_start();</a>
<a name="ln2497">            nodes_ = static_cast&lt;node_pointer&gt;(prev-&gt;next_);</a>
<a name="ln2498">            prev-&gt;next_ = link_pointer();</a>
<a name="ln2499">            b.size_ = 0;</a>
<a name="ln2500">          }</a>
<a name="ln2501">        }</a>
<a name="ln2502"> </a>
<a name="ln2503">        ~node_holder();</a>
<a name="ln2504"> </a>
<a name="ln2505">        node_pointer pop_node()</a>
<a name="ln2506">        {</a>
<a name="ln2507">          node_pointer n = nodes_;</a>
<a name="ln2508">          nodes_ = static_cast&lt;node_pointer&gt;(nodes_-&gt;next_);</a>
<a name="ln2509">          n-&gt;next_ = link_pointer();</a>
<a name="ln2510">          return n;</a>
<a name="ln2511">        }</a>
<a name="ln2512"> </a>
<a name="ln2513">        template &lt;typename T&gt; inline node_pointer copy_of(T const&amp; v)</a>
<a name="ln2514">        {</a>
<a name="ln2515">          if (nodes_) {</a>
<a name="ln2516">            constructor_.reclaim(pop_node());</a>
<a name="ln2517">          } else {</a>
<a name="ln2518">            constructor_.create_node();</a>
<a name="ln2519">          }</a>
<a name="ln2520">          BOOST_UNORDERED_CALL_CONSTRUCT1(node_allocator_traits,</a>
<a name="ln2521">            constructor_.alloc_, constructor_.node_-&gt;value_ptr(), v);</a>
<a name="ln2522">          return constructor_.release();</a>
<a name="ln2523">        }</a>
<a name="ln2524"> </a>
<a name="ln2525">        template &lt;typename T&gt; inline node_pointer move_copy_of(T&amp; v)</a>
<a name="ln2526">        {</a>
<a name="ln2527">          if (nodes_) {</a>
<a name="ln2528">            constructor_.reclaim(pop_node());</a>
<a name="ln2529">          } else {</a>
<a name="ln2530">            constructor_.create_node();</a>
<a name="ln2531">          }</a>
<a name="ln2532">          BOOST_UNORDERED_CALL_CONSTRUCT1(node_allocator_traits,</a>
<a name="ln2533">            constructor_.alloc_, constructor_.node_-&gt;value_ptr(),</a>
<a name="ln2534">            boost::move(v));</a>
<a name="ln2535">          return constructor_.release();</a>
<a name="ln2536">        }</a>
<a name="ln2537"> </a>
<a name="ln2538">        iterator begin() const { return iterator(nodes_); }</a>
<a name="ln2539">      };</a>
<a name="ln2540"> </a>
<a name="ln2541">      template &lt;typename Alloc&gt; node_holder&lt;Alloc&gt;::~node_holder()</a>
<a name="ln2542">      {</a>
<a name="ln2543">        while (nodes_) {</a>
<a name="ln2544">          node_pointer p = nodes_;</a>
<a name="ln2545">          nodes_ = static_cast&lt;node_pointer&gt;(p-&gt;next_);</a>
<a name="ln2546"> </a>
<a name="ln2547">          BOOST_UNORDERED_CALL_DESTROY(</a>
<a name="ln2548">            node_allocator_traits, constructor_.alloc_, p-&gt;value_ptr());</a>
<a name="ln2549">          boost::unordered::detail::func::destroy(boost::to_address(p));</a>
<a name="ln2550">          node_allocator_traits::deallocate(constructor_.alloc_, p, 1);</a>
<a name="ln2551">        }</a>
<a name="ln2552">      }</a>
<a name="ln2553"> </a>
<a name="ln2554">      ///////////////////////////////////////////////////////////////////</a>
<a name="ln2555">      //</a>
<a name="ln2556">      // Bucket</a>
<a name="ln2557"> </a>
<a name="ln2558">      template &lt;typename NodePointer&gt; struct bucket</a>
<a name="ln2559">      {</a>
<a name="ln2560">        typedef NodePointer link_pointer;</a>
<a name="ln2561">        link_pointer next_;</a>
<a name="ln2562"> </a>
<a name="ln2563">        bucket() : next_() {}</a>
<a name="ln2564">        bucket(link_pointer n) : next_(n) {}</a>
<a name="ln2565"> </a>
<a name="ln2566">        link_pointer first_from_start() { return next_; }</a>
<a name="ln2567"> </a>
<a name="ln2568">        enum</a>
<a name="ln2569">        {</a>
<a name="ln2570">          extra_node = true</a>
<a name="ln2571">        };</a>
<a name="ln2572">      };</a>
<a name="ln2573"> </a>
<a name="ln2574">      struct ptr_bucket</a>
<a name="ln2575">      {</a>
<a name="ln2576">        typedef ptr_bucket* link_pointer;</a>
<a name="ln2577">        link_pointer next_;</a>
<a name="ln2578"> </a>
<a name="ln2579">        ptr_bucket() : next_(0) {}</a>
<a name="ln2580">        ptr_bucket(link_pointer n) : next_(n) {}</a>
<a name="ln2581"> </a>
<a name="ln2582">        link_pointer first_from_start() { return this; }</a>
<a name="ln2583"> </a>
<a name="ln2584">        enum</a>
<a name="ln2585">        {</a>
<a name="ln2586">          extra_node = false</a>
<a name="ln2587">        };</a>
<a name="ln2588">      };</a>
<a name="ln2589"> </a>
<a name="ln2590">      ///////////////////////////////////////////////////////////////////</a>
<a name="ln2591">      //</a>
<a name="ln2592">      // Hash Policy</a>
<a name="ln2593"> </a>
<a name="ln2594">      template &lt;typename SizeT&gt; struct prime_policy</a>
<a name="ln2595">      {</a>
<a name="ln2596">        template &lt;typename Hash, typename T&gt;</a>
<a name="ln2597">        static inline SizeT apply_hash(Hash const&amp; hf, T const&amp; x)</a>
<a name="ln2598">        {</a>
<a name="ln2599">          return hf(x);</a>
<a name="ln2600">        }</a>
<a name="ln2601"> </a>
<a name="ln2602">        static inline SizeT to_bucket(SizeT bucket_count, SizeT hash)</a>
<a name="ln2603">        {</a>
<a name="ln2604">          return hash % bucket_count;</a>
<a name="ln2605">        }</a>
<a name="ln2606"> </a>
<a name="ln2607">        static inline SizeT new_bucket_count(SizeT min)</a>
<a name="ln2608">        {</a>
<a name="ln2609">          return boost::unordered::detail::next_prime(min);</a>
<a name="ln2610">        }</a>
<a name="ln2611"> </a>
<a name="ln2612">        static inline SizeT prev_bucket_count(SizeT max)</a>
<a name="ln2613">        {</a>
<a name="ln2614">          return boost::unordered::detail::prev_prime(max);</a>
<a name="ln2615">        }</a>
<a name="ln2616">      };</a>
<a name="ln2617"> </a>
<a name="ln2618">      template &lt;typename SizeT&gt; struct mix64_policy</a>
<a name="ln2619">      {</a>
<a name="ln2620">        template &lt;typename Hash, typename T&gt;</a>
<a name="ln2621">        static inline SizeT apply_hash(Hash const&amp; hf, T const&amp; x)</a>
<a name="ln2622">        {</a>
<a name="ln2623">          SizeT key = hf(x);</a>
<a name="ln2624">          key = (~key) + (key &lt;&lt; 21); // key = (key &lt;&lt; 21) - key - 1;</a>
<a name="ln2625">          key = key ^ (key &gt;&gt; 24);</a>
<a name="ln2626">          key = (key + (key &lt;&lt; 3)) + (key &lt;&lt; 8); // key * 265</a>
<a name="ln2627">          key = key ^ (key &gt;&gt; 14);</a>
<a name="ln2628">          key = (key + (key &lt;&lt; 2)) + (key &lt;&lt; 4); // key * 21</a>
<a name="ln2629">          key = key ^ (key &gt;&gt; 28);</a>
<a name="ln2630">          key = key + (key &lt;&lt; 31);</a>
<a name="ln2631">          return key;</a>
<a name="ln2632">        }</a>
<a name="ln2633"> </a>
<a name="ln2634">        static inline SizeT to_bucket(SizeT bucket_count, SizeT hash)</a>
<a name="ln2635">        {</a>
<a name="ln2636">          return hash &amp; (bucket_count - 1);</a>
<a name="ln2637">        }</a>
<a name="ln2638"> </a>
<a name="ln2639">        static inline SizeT new_bucket_count(SizeT min)</a>
<a name="ln2640">        {</a>
<a name="ln2641">          if (min &lt;= 4)</a>
<a name="ln2642">            return 4;</a>
<a name="ln2643">          --min;</a>
<a name="ln2644">          min |= min &gt;&gt; 1;</a>
<a name="ln2645">          min |= min &gt;&gt; 2;</a>
<a name="ln2646">          min |= min &gt;&gt; 4;</a>
<a name="ln2647">          min |= min &gt;&gt; 8;</a>
<a name="ln2648">          min |= min &gt;&gt; 16;</a>
<a name="ln2649">          min |= min &gt;&gt; 32;</a>
<a name="ln2650">          return min + 1;</a>
<a name="ln2651">        }</a>
<a name="ln2652"> </a>
<a name="ln2653">        static inline SizeT prev_bucket_count(SizeT max)</a>
<a name="ln2654">        {</a>
<a name="ln2655">          max |= max &gt;&gt; 1;</a>
<a name="ln2656">          max |= max &gt;&gt; 2;</a>
<a name="ln2657">          max |= max &gt;&gt; 4;</a>
<a name="ln2658">          max |= max &gt;&gt; 8;</a>
<a name="ln2659">          max |= max &gt;&gt; 16;</a>
<a name="ln2660">          max |= max &gt;&gt; 32;</a>
<a name="ln2661">          return (max &gt;&gt; 1) + 1;</a>
<a name="ln2662">        }</a>
<a name="ln2663">      };</a>
<a name="ln2664"> </a>
<a name="ln2665">      template &lt;int digits, int radix&gt; struct pick_policy_impl</a>
<a name="ln2666">      {</a>
<a name="ln2667">        typedef prime_policy&lt;std::size_t&gt; type;</a>
<a name="ln2668">      };</a>
<a name="ln2669"> </a>
<a name="ln2670">      template &lt;&gt; struct pick_policy_impl&lt;64, 2&gt;</a>
<a name="ln2671">      {</a>
<a name="ln2672">        typedef mix64_policy&lt;std::size_t&gt; type;</a>
<a name="ln2673">      };</a>
<a name="ln2674"> </a>
<a name="ln2675">      template &lt;typename T&gt;</a>
<a name="ln2676">      struct pick_policy2</a>
<a name="ln2677">        : pick_policy_impl&lt;std::numeric_limits&lt;std::size_t&gt;::digits,</a>
<a name="ln2678">            std::numeric_limits&lt;std::size_t&gt;::radix&gt;</a>
<a name="ln2679">      {</a>
<a name="ln2680">      };</a>
<a name="ln2681"> </a>
<a name="ln2682">      // While the mix policy is generally faster, the prime policy is a lot</a>
<a name="ln2683">      // faster when a large number consecutive integers are used, because</a>
<a name="ln2684">      // there are no collisions. Since that is probably quite common, use</a>
<a name="ln2685">      // prime policy for integeral types. But not the smaller ones, as they</a>
<a name="ln2686">      // don't have enough unique values for this to be an issue.</a>
<a name="ln2687"> </a>
<a name="ln2688">      template &lt;&gt; struct pick_policy2&lt;int&gt;</a>
<a name="ln2689">      {</a>
<a name="ln2690">        typedef prime_policy&lt;std::size_t&gt; type;</a>
<a name="ln2691">      };</a>
<a name="ln2692"> </a>
<a name="ln2693">      template &lt;&gt; struct pick_policy2&lt;unsigned int&gt;</a>
<a name="ln2694">      {</a>
<a name="ln2695">        typedef prime_policy&lt;std::size_t&gt; type;</a>
<a name="ln2696">      };</a>
<a name="ln2697"> </a>
<a name="ln2698">      template &lt;&gt; struct pick_policy2&lt;long&gt;</a>
<a name="ln2699">      {</a>
<a name="ln2700">        typedef prime_policy&lt;std::size_t&gt; type;</a>
<a name="ln2701">      };</a>
<a name="ln2702"> </a>
<a name="ln2703">      template &lt;&gt; struct pick_policy2&lt;unsigned long&gt;</a>
<a name="ln2704">      {</a>
<a name="ln2705">        typedef prime_policy&lt;std::size_t&gt; type;</a>
<a name="ln2706">      };</a>
<a name="ln2707"> </a>
<a name="ln2708">#if !defined(BOOST_NO_LONG_LONG)</a>
<a name="ln2709">      template &lt;&gt; struct pick_policy2&lt;boost::long_long_type&gt;</a>
<a name="ln2710">      {</a>
<a name="ln2711">        typedef prime_policy&lt;std::size_t&gt; type;</a>
<a name="ln2712">      };</a>
<a name="ln2713"> </a>
<a name="ln2714">      template &lt;&gt; struct pick_policy2&lt;boost::ulong_long_type&gt;</a>
<a name="ln2715">      {</a>
<a name="ln2716">        typedef prime_policy&lt;std::size_t&gt; type;</a>
<a name="ln2717">      };</a>
<a name="ln2718">#endif</a>
<a name="ln2719"> </a>
<a name="ln2720">      template &lt;typename T&gt;</a>
<a name="ln2721">      struct pick_policy : pick_policy2&lt;typename boost::remove_cv&lt;T&gt;::type&gt;</a>
<a name="ln2722">      {</a>
<a name="ln2723">      };</a>
<a name="ln2724"> </a>
<a name="ln2725">      //////////////////////////////////////////////////////////////////////////</a>
<a name="ln2726">      // Functions</a>
<a name="ln2727">      //</a>
<a name="ln2728">      // This double buffers the storage for the hash function and key equality</a>
<a name="ln2729">      // predicate in order to have exception safe copy/swap. To do so,</a>
<a name="ln2730">      // use 'construct_spare' to construct in the spare space, and then when</a>
<a name="ln2731">      // ready to use 'switch_functions' to switch to the new functions.</a>
<a name="ln2732">      // If an exception is thrown between these two calls, use</a>
<a name="ln2733">      // 'cleanup_spare_functions' to destroy the unused constructed functions.</a>
<a name="ln2734"> </a>
<a name="ln2735">      template &lt;class H, class P&gt; class functions</a>
<a name="ln2736">      {</a>
<a name="ln2737">      public:</a>
<a name="ln2738">        static const bool nothrow_move_assignable =</a>
<a name="ln2739">          boost::is_nothrow_move_assignable&lt;H&gt;::value &amp;&amp;</a>
<a name="ln2740">          boost::is_nothrow_move_assignable&lt;P&gt;::value;</a>
<a name="ln2741">        static const bool nothrow_move_constructible =</a>
<a name="ln2742">          boost::is_nothrow_move_constructible&lt;H&gt;::value &amp;&amp;</a>
<a name="ln2743">          boost::is_nothrow_move_constructible&lt;P&gt;::value;</a>
<a name="ln2744">        static const bool nothrow_swappable =</a>
<a name="ln2745">          boost::is_nothrow_swappable&lt;H&gt;::value &amp;&amp;</a>
<a name="ln2746">          boost::is_nothrow_swappable&lt;P&gt;::value;</a>
<a name="ln2747"> </a>
<a name="ln2748">      private:</a>
<a name="ln2749">        functions&amp; operator=(functions const&amp;);</a>
<a name="ln2750"> </a>
<a name="ln2751">        typedef compressed&lt;H, P&gt; function_pair;</a>
<a name="ln2752"> </a>
<a name="ln2753">        typedef typename boost::aligned_storage&lt;sizeof(function_pair),</a>
<a name="ln2754">          boost::alignment_of&lt;function_pair&gt;::value&gt;::type aligned_function;</a>
<a name="ln2755"> </a>
<a name="ln2756">        unsigned char current_; // 0/1 - Currently active functions</a>
<a name="ln2757">                                // +2 - Both constructed</a>
<a name="ln2758">        aligned_function funcs_[2];</a>
<a name="ln2759"> </a>
<a name="ln2760">      public:</a>
<a name="ln2761">        functions(H const&amp; hf, P const&amp; eq) : current_(0)</a>
<a name="ln2762">        {</a>
<a name="ln2763">          construct_functions(current_, hf, eq);</a>
<a name="ln2764">        }</a>
<a name="ln2765"> </a>
<a name="ln2766">        functions(functions const&amp; bf) : current_(0)</a>
<a name="ln2767">        {</a>
<a name="ln2768">          construct_functions(current_, bf.current_functions());</a>
<a name="ln2769">        }</a>
<a name="ln2770"> </a>
<a name="ln2771">        functions(functions&amp; bf, boost::unordered::detail::move_tag)</a>
<a name="ln2772">            : current_(0)</a>
<a name="ln2773">        {</a>
<a name="ln2774">          construct_functions(current_, bf.current_functions(),</a>
<a name="ln2775">            boost::unordered::detail::integral_constant&lt;bool,</a>
<a name="ln2776">              nothrow_move_constructible&gt;());</a>
<a name="ln2777">        }</a>
<a name="ln2778"> </a>
<a name="ln2779">        ~functions()</a>
<a name="ln2780">        {</a>
<a name="ln2781">          BOOST_ASSERT(!(current_ &amp; 2));</a>
<a name="ln2782">          destroy_functions(current_);</a>
<a name="ln2783">        }</a>
<a name="ln2784"> </a>
<a name="ln2785">        H const&amp; hash_function() const { return current_functions().first(); }</a>
<a name="ln2786"> </a>
<a name="ln2787">        P const&amp; key_eq() const { return current_functions().second(); }</a>
<a name="ln2788"> </a>
<a name="ln2789">        function_pair const&amp; current_functions() const</a>
<a name="ln2790">        {</a>
<a name="ln2791">          return *static_cast&lt;function_pair const*&gt;(</a>
<a name="ln2792">            static_cast&lt;void const*&gt;(funcs_[current_ &amp; 1].address()));</a>
<a name="ln2793">        }</a>
<a name="ln2794"> </a>
<a name="ln2795">        function_pair&amp; current_functions()</a>
<a name="ln2796">        {</a>
<a name="ln2797">          return *static_cast&lt;function_pair*&gt;(</a>
<a name="ln2798">            static_cast&lt;void*&gt;(funcs_[current_ &amp; 1].address()));</a>
<a name="ln2799">        }</a>
<a name="ln2800"> </a>
<a name="ln2801">        void construct_spare_functions(function_pair const&amp; f)</a>
<a name="ln2802">        {</a>
<a name="ln2803">          BOOST_ASSERT(!(current_ &amp; 2));</a>
<a name="ln2804">          construct_functions(current_ ^ 1, f);</a>
<a name="ln2805">          current_ |= 2;</a>
<a name="ln2806">        }</a>
<a name="ln2807"> </a>
<a name="ln2808">        void cleanup_spare_functions()</a>
<a name="ln2809">        {</a>
<a name="ln2810">          if (current_ &amp; 2) {</a>
<a name="ln2811">            current_ = static_cast&lt;unsigned char&gt;(current_ &amp; 1);</a>
<a name="ln2812">            destroy_functions(current_ ^ 1);</a>
<a name="ln2813">          }</a>
<a name="ln2814">        }</a>
<a name="ln2815"> </a>
<a name="ln2816">        void switch_functions()</a>
<a name="ln2817">        {</a>
<a name="ln2818">          BOOST_ASSERT(current_ &amp; 2);</a>
<a name="ln2819">          destroy_functions(static_cast&lt;unsigned char&gt;(current_ &amp; 1));</a>
<a name="ln2820">          current_ ^= 3;</a>
<a name="ln2821">        }</a>
<a name="ln2822"> </a>
<a name="ln2823">      private:</a>
<a name="ln2824">        void construct_functions(unsigned char which, H const&amp; hf, P const&amp; eq)</a>
<a name="ln2825">        {</a>
<a name="ln2826">          BOOST_ASSERT(!(which &amp; 2));</a>
<a name="ln2827">          new ((void*)&amp;funcs_[which]) function_pair(hf, eq);</a>
<a name="ln2828">        }</a>
<a name="ln2829"> </a>
<a name="ln2830">        void construct_functions(unsigned char which, function_pair const&amp; f,</a>
<a name="ln2831">          boost::unordered::detail::false_type =</a>
<a name="ln2832">            boost::unordered::detail::false_type())</a>
<a name="ln2833">        {</a>
<a name="ln2834">          BOOST_ASSERT(!(which &amp; 2));</a>
<a name="ln2835">          new ((void*)&amp;funcs_[which]) function_pair(f);</a>
<a name="ln2836">        }</a>
<a name="ln2837"> </a>
<a name="ln2838">        void construct_functions(unsigned char which, function_pair&amp; f,</a>
<a name="ln2839">          boost::unordered::detail::true_type)</a>
<a name="ln2840">        {</a>
<a name="ln2841">          BOOST_ASSERT(!(which &amp; 2));</a>
<a name="ln2842">          new ((void*)&amp;funcs_[which])</a>
<a name="ln2843">            function_pair(f, boost::unordered::detail::move_tag());</a>
<a name="ln2844">        }</a>
<a name="ln2845"> </a>
<a name="ln2846">        void destroy_functions(unsigned char which)</a>
<a name="ln2847">        {</a>
<a name="ln2848">          BOOST_ASSERT(!(which &amp; 2));</a>
<a name="ln2849">          boost::unordered::detail::func::destroy(</a>
<a name="ln2850">            (function_pair*)(&amp;funcs_[which]));</a>
<a name="ln2851">        }</a>
<a name="ln2852">      };</a>
<a name="ln2853"> </a>
<a name="ln2854">////////////////////////////////////////////////////////////////////////////</a>
<a name="ln2855">// rvalue parameters when type can't be a BOOST_RV_REF(T) parameter</a>
<a name="ln2856">// e.g. for int</a>
<a name="ln2857"> </a>
<a name="ln2858">#if !defined(BOOST_NO_CXX11_RVALUE_REFERENCES)</a>
<a name="ln2859">#define BOOST_UNORDERED_RV_REF(T) BOOST_RV_REF(T)</a>
<a name="ln2860">#else</a>
<a name="ln2861">      struct please_ignore_this_overload</a>
<a name="ln2862">      {</a>
<a name="ln2863">        typedef please_ignore_this_overload type;</a>
<a name="ln2864">      };</a>
<a name="ln2865"> </a>
<a name="ln2866">      template &lt;typename T&gt; struct rv_ref_impl</a>
<a name="ln2867">      {</a>
<a name="ln2868">        typedef BOOST_RV_REF(T) type;</a>
<a name="ln2869">      };</a>
<a name="ln2870"> </a>
<a name="ln2871">      template &lt;typename T&gt;</a>
<a name="ln2872">      struct rv_ref</a>
<a name="ln2873">        : boost::detail::if_true&lt;boost::is_class&lt;T&gt;::value&gt;::</a>
<a name="ln2874">            BOOST_NESTED_TEMPLATE then&lt;boost::unordered::detail::rv_ref_impl&lt;T&gt;,</a>
<a name="ln2875">              please_ignore_this_overload&gt;::type</a>
<a name="ln2876">      {</a>
<a name="ln2877">      };</a>
<a name="ln2878"> </a>
<a name="ln2879">#define BOOST_UNORDERED_RV_REF(T)                                              \</a>
<a name="ln2880">  typename boost::unordered::detail::rv_ref&lt;T&gt;::type</a>
<a name="ln2881">#endif</a>
<a name="ln2882"> </a>
<a name="ln2883">#if defined(BOOST_MSVC)</a>
<a name="ln2884">#pragma warning(push)</a>
<a name="ln2885">#pragma warning(disable : 4127) // conditional expression is constant</a>
<a name="ln2886">#endif</a>
<a name="ln2887"> </a>
<a name="ln2888">      //////////////////////////////////////////////////////////////////////////</a>
<a name="ln2889">      // convert double to std::size_t</a>
<a name="ln2890"> </a>
<a name="ln2891">      inline std::size_t double_to_size(double f)</a>
<a name="ln2892">      {</a>
<a name="ln2893">        return f &gt;= static_cast&lt;double&gt;(</a>
<a name="ln2894">                      (std::numeric_limits&lt;std::size_t&gt;::max)())</a>
<a name="ln2895">                 ? (std::numeric_limits&lt;std::size_t&gt;::max)()</a>
<a name="ln2896">                 : static_cast&lt;std::size_t&gt;(f);</a>
<a name="ln2897">      }</a>
<a name="ln2898"> </a>
<a name="ln2899">      template &lt;typename Types&gt;</a>
<a name="ln2900">      struct table : boost::unordered::detail::functions&lt;typename Types::hasher,</a>
<a name="ln2901">                       typename Types::key_equal&gt;</a>
<a name="ln2902">      {</a>
<a name="ln2903">      private:</a>
<a name="ln2904">        table(table const&amp;);</a>
<a name="ln2905">        table&amp; operator=(table const&amp;);</a>
<a name="ln2906"> </a>
<a name="ln2907">      public:</a>
<a name="ln2908">        typedef typename Types::node node;</a>
<a name="ln2909">        typedef typename Types::bucket bucket;</a>
<a name="ln2910">        typedef typename Types::hasher hasher;</a>
<a name="ln2911">        typedef typename Types::key_equal key_equal;</a>
<a name="ln2912">        typedef typename Types::const_key_type const_key_type;</a>
<a name="ln2913">        typedef typename Types::extractor extractor;</a>
<a name="ln2914">        typedef typename Types::value_type value_type;</a>
<a name="ln2915">        typedef typename Types::table table_impl;</a>
<a name="ln2916">        typedef typename Types::link_pointer link_pointer;</a>
<a name="ln2917">        typedef typename Types::policy policy;</a>
<a name="ln2918">        typedef typename Types::iterator iterator;</a>
<a name="ln2919">        typedef typename Types::c_iterator c_iterator;</a>
<a name="ln2920">        typedef typename Types::l_iterator l_iterator;</a>
<a name="ln2921">        typedef typename Types::cl_iterator cl_iterator;</a>
<a name="ln2922"> </a>
<a name="ln2923">        typedef boost::unordered::detail::functions&lt;typename Types::hasher,</a>
<a name="ln2924">          typename Types::key_equal&gt;</a>
<a name="ln2925">          functions;</a>
<a name="ln2926"> </a>
<a name="ln2927">        typedef typename Types::value_allocator value_allocator;</a>
<a name="ln2928">        typedef typename boost::unordered::detail::rebind_wrap&lt;value_allocator,</a>
<a name="ln2929">          node&gt;::type node_allocator;</a>
<a name="ln2930">        typedef typename boost::unordered::detail::rebind_wrap&lt;value_allocator,</a>
<a name="ln2931">          bucket&gt;::type bucket_allocator;</a>
<a name="ln2932">        typedef boost::unordered::detail::allocator_traits&lt;node_allocator&gt;</a>
<a name="ln2933">          node_allocator_traits;</a>
<a name="ln2934">        typedef boost::unordered::detail::allocator_traits&lt;bucket_allocator&gt;</a>
<a name="ln2935">          bucket_allocator_traits;</a>
<a name="ln2936">        typedef typename node_allocator_traits::pointer node_pointer;</a>
<a name="ln2937">        typedef</a>
<a name="ln2938">          typename node_allocator_traits::const_pointer const_node_pointer;</a>
<a name="ln2939">        typedef typename bucket_allocator_traits::pointer bucket_pointer;</a>
<a name="ln2940">        typedef boost::unordered::detail::node_constructor&lt;node_allocator&gt;</a>
<a name="ln2941">          node_constructor;</a>
<a name="ln2942">        typedef boost::unordered::detail::node_tmp&lt;node_allocator&gt; node_tmp;</a>
<a name="ln2943"> </a>
<a name="ln2944">        typedef std::pair&lt;iterator, bool&gt; emplace_return;</a>
<a name="ln2945"> </a>
<a name="ln2946">        ////////////////////////////////////////////////////////////////////////</a>
<a name="ln2947">        // Members</a>
<a name="ln2948"> </a>
<a name="ln2949">        boost::unordered::detail::compressed&lt;bucket_allocator, node_allocator&gt;</a>
<a name="ln2950">          allocators_;</a>
<a name="ln2951">        std::size_t bucket_count_;</a>
<a name="ln2952">        std::size_t size_;</a>
<a name="ln2953">        float mlf_;</a>
<a name="ln2954">        std::size_t max_load_;</a>
<a name="ln2955">        bucket_pointer buckets_;</a>
<a name="ln2956"> </a>
<a name="ln2957">        ////////////////////////////////////////////////////////////////////////</a>
<a name="ln2958">        // Data access</a>
<a name="ln2959"> </a>
<a name="ln2960">        static node_pointer get_node(c_iterator it) { return it.node_; }</a>
<a name="ln2961"> </a>
<a name="ln2962">        static node_pointer next_node(link_pointer n)</a>
<a name="ln2963">        {</a>
<a name="ln2964">          return static_cast&lt;node_pointer&gt;(n-&gt;next_);</a>
<a name="ln2965">        }</a>
<a name="ln2966"> </a>
<a name="ln2967">        static node_pointer next_for_find(link_pointer n)</a>
<a name="ln2968">        {</a>
<a name="ln2969">          node_pointer n2 = static_cast&lt;node_pointer&gt;(n);</a>
<a name="ln2970">          do {</a>
<a name="ln2971">            n2 = next_node(n2);</a>
<a name="ln2972">          } while (n2 &amp;&amp; !n2-&gt;is_first_in_group());</a>
<a name="ln2973">          return n2;</a>
<a name="ln2974">        }</a>
<a name="ln2975"> </a>
<a name="ln2976">        node_pointer next_group(node_pointer n) const</a>
<a name="ln2977">        {</a>
<a name="ln2978">          node_pointer n1 = n;</a>
<a name="ln2979">          do {</a>
<a name="ln2980">            n1 = next_node(n1);</a>
<a name="ln2981">          } while (n1 &amp;&amp; !n1-&gt;is_first_in_group());</a>
<a name="ln2982">          return n1;</a>
<a name="ln2983">        }</a>
<a name="ln2984"> </a>
<a name="ln2985">        std::size_t group_count(node_pointer n) const</a>
<a name="ln2986">        {</a>
<a name="ln2987">          std::size_t x = 0;</a>
<a name="ln2988">          node_pointer it = n;</a>
<a name="ln2989">          do {</a>
<a name="ln2990">            ++x;</a>
<a name="ln2991">            it = next_node(it);</a>
<a name="ln2992">          } while (it &amp;&amp; !it-&gt;is_first_in_group());</a>
<a name="ln2993"> </a>
<a name="ln2994">          return x;</a>
<a name="ln2995">        }</a>
<a name="ln2996"> </a>
<a name="ln2997">        std::size_t node_bucket(node_pointer n) const</a>
<a name="ln2998">        {</a>
<a name="ln2999">          return n-&gt;get_bucket();</a>
<a name="ln3000">        }</a>
<a name="ln3001"> </a>
<a name="ln3002">        bucket_allocator const&amp; bucket_alloc() const</a>
<a name="ln3003">        {</a>
<a name="ln3004">          return allocators_.first();</a>
<a name="ln3005">        }</a>
<a name="ln3006"> </a>
<a name="ln3007">        node_allocator const&amp; node_alloc() const</a>
<a name="ln3008">        {</a>
<a name="ln3009">          return allocators_.second();</a>
<a name="ln3010">        }</a>
<a name="ln3011"> </a>
<a name="ln3012">        bucket_allocator&amp; bucket_alloc() { return allocators_.first(); }</a>
<a name="ln3013"> </a>
<a name="ln3014">        node_allocator&amp; node_alloc() { return allocators_.second(); }</a>
<a name="ln3015"> </a>
<a name="ln3016">        std::size_t max_bucket_count() const</a>
<a name="ln3017">        {</a>
<a name="ln3018">          // -1 to account for the start bucket.</a>
<a name="ln3019">          return policy::prev_bucket_count(</a>
<a name="ln3020">            bucket_allocator_traits::max_size(bucket_alloc()) - 1);</a>
<a name="ln3021">        }</a>
<a name="ln3022"> </a>
<a name="ln3023">        bucket_pointer get_bucket_pointer(std::size_t bucket_index) const</a>
<a name="ln3024">        {</a>
<a name="ln3025">          BOOST_ASSERT(buckets_);</a>
<a name="ln3026">          return buckets_ + static_cast&lt;std::ptrdiff_t&gt;(bucket_index);</a>
<a name="ln3027">        }</a>
<a name="ln3028"> </a>
<a name="ln3029">        link_pointer get_previous_start() const</a>
<a name="ln3030">        {</a>
<a name="ln3031">          return get_bucket_pointer(bucket_count_)-&gt;first_from_start();</a>
<a name="ln3032">        }</a>
<a name="ln3033"> </a>
<a name="ln3034">        link_pointer get_previous_start(std::size_t bucket_index) const</a>
<a name="ln3035">        {</a>
<a name="ln3036">          return get_bucket_pointer(bucket_index)-&gt;next_;</a>
<a name="ln3037">        }</a>
<a name="ln3038"> </a>
<a name="ln3039">        node_pointer begin() const</a>
<a name="ln3040">        {</a>
<a name="ln3041">          return size_ ? next_node(get_previous_start()) : node_pointer();</a>
<a name="ln3042">        }</a>
<a name="ln3043"> </a>
<a name="ln3044">        node_pointer begin(std::size_t bucket_index) const</a>
<a name="ln3045">        {</a>
<a name="ln3046">          if (!size_)</a>
<a name="ln3047">            return node_pointer();</a>
<a name="ln3048">          link_pointer prev = get_previous_start(bucket_index);</a>
<a name="ln3049">          return prev ? next_node(prev) : node_pointer();</a>
<a name="ln3050">        }</a>
<a name="ln3051"> </a>
<a name="ln3052">        std::size_t hash_to_bucket(std::size_t hash_value) const</a>
<a name="ln3053">        {</a>
<a name="ln3054">          return policy::to_bucket(bucket_count_, hash_value);</a>
<a name="ln3055">        }</a>
<a name="ln3056"> </a>
<a name="ln3057">        std::size_t bucket_size(std::size_t index) const</a>
<a name="ln3058">        {</a>
<a name="ln3059">          node_pointer n = begin(index);</a>
<a name="ln3060">          if (!n)</a>
<a name="ln3061">            return 0;</a>
<a name="ln3062"> </a>
<a name="ln3063">          std::size_t count = 0;</a>
<a name="ln3064">          while (n &amp;&amp; node_bucket(n) == index) {</a>
<a name="ln3065">            ++count;</a>
<a name="ln3066">            n = next_node(n);</a>
<a name="ln3067">          }</a>
<a name="ln3068"> </a>
<a name="ln3069">          return count;</a>
<a name="ln3070">        }</a>
<a name="ln3071"> </a>
<a name="ln3072">        ////////////////////////////////////////////////////////////////////////</a>
<a name="ln3073">        // Load methods</a>
<a name="ln3074"> </a>
<a name="ln3075">        void recalculate_max_load()</a>
<a name="ln3076">        {</a>
<a name="ln3077">          using namespace std;</a>
<a name="ln3078"> </a>
<a name="ln3079">          // From 6.3.1/13:</a>
<a name="ln3080">          // Only resize when size &gt;= mlf_ * count</a>
<a name="ln3081">          max_load_ = buckets_ ? boost::unordered::detail::double_to_size(</a>
<a name="ln3082">                                   ceil(static_cast&lt;double&gt;(mlf_) *</a>
<a name="ln3083">                                        static_cast&lt;double&gt;(bucket_count_)))</a>
<a name="ln3084">                               : 0;</a>
<a name="ln3085">        }</a>
<a name="ln3086"> </a>
<a name="ln3087">        void max_load_factor(float z)</a>
<a name="ln3088">        {</a>
<a name="ln3089">          BOOST_ASSERT(z &gt; 0);</a>
<a name="ln3090">          mlf_ = (std::max)(z, minimum_max_load_factor);</a>
<a name="ln3091">          recalculate_max_load();</a>
<a name="ln3092">        }</a>
<a name="ln3093"> </a>
<a name="ln3094">        std::size_t min_buckets_for_size(std::size_t size) const</a>
<a name="ln3095">        {</a>
<a name="ln3096">          BOOST_ASSERT(mlf_ &gt;= minimum_max_load_factor);</a>
<a name="ln3097"> </a>
<a name="ln3098">          using namespace std;</a>
<a name="ln3099"> </a>
<a name="ln3100">          // From insert/emplace requirements:</a>
<a name="ln3101">          //</a>
<a name="ln3102">          // size &lt;= mlf_ * count</a>
<a name="ln3103">          // =&gt; count &gt;= size / mlf_</a>
<a name="ln3104">          //</a>
<a name="ln3105">          // Or from rehash post-condition:</a>
<a name="ln3106">          //</a>
<a name="ln3107">          // count &gt;= size / mlf_</a>
<a name="ln3108"> </a>
<a name="ln3109">          return policy::new_bucket_count(</a>
<a name="ln3110">            boost::unordered::detail::double_to_size(</a>
<a name="ln3111">              floor(static_cast&lt;double&gt;(size) / static_cast&lt;double&gt;(mlf_)) +</a>
<a name="ln3112">              1));</a>
<a name="ln3113">        }</a>
<a name="ln3114"> </a>
<a name="ln3115">        ////////////////////////////////////////////////////////////////////////</a>
<a name="ln3116">        // Constructors</a>
<a name="ln3117"> </a>
<a name="ln3118">        table(std::size_t num_buckets, hasher const&amp; hf, key_equal const&amp; eq,</a>
<a name="ln3119">          node_allocator const&amp; a)</a>
<a name="ln3120">            : functions(hf, eq), allocators_(a, a),</a>
<a name="ln3121">              bucket_count_(policy::new_bucket_count(num_buckets)), size_(0),</a>
<a name="ln3122">              mlf_(1.0f), max_load_(0), buckets_()</a>
<a name="ln3123">        {</a>
<a name="ln3124">        }</a>
<a name="ln3125"> </a>
<a name="ln3126">        table(table const&amp; x, node_allocator const&amp; a)</a>
<a name="ln3127">            : functions(x), allocators_(a, a),</a>
<a name="ln3128">              bucket_count_(x.min_buckets_for_size(x.size_)), size_(0),</a>
<a name="ln3129">              mlf_(x.mlf_), max_load_(0), buckets_()</a>
<a name="ln3130">        {</a>
<a name="ln3131">        }</a>
<a name="ln3132"> </a>
<a name="ln3133">        table(table&amp; x, boost::unordered::detail::move_tag m)</a>
<a name="ln3134">            : functions(x, m), allocators_(x.allocators_, m),</a>
<a name="ln3135">              bucket_count_(x.bucket_count_), size_(x.size_), mlf_(x.mlf_),</a>
<a name="ln3136">              max_load_(x.max_load_), buckets_(x.buckets_)</a>
<a name="ln3137">        {</a>
<a name="ln3138">          x.buckets_ = bucket_pointer();</a>
<a name="ln3139">          x.size_ = 0;</a>
<a name="ln3140">          x.max_load_ = 0;</a>
<a name="ln3141">        }</a>
<a name="ln3142"> </a>
<a name="ln3143">        table(table&amp; x, node_allocator const&amp; a,</a>
<a name="ln3144">          boost::unordered::detail::move_tag m)</a>
<a name="ln3145">            : functions(x, m), allocators_(a, a),</a>
<a name="ln3146">              bucket_count_(x.bucket_count_), size_(0), mlf_(x.mlf_),</a>
<a name="ln3147">              max_load_(0), buckets_()</a>
<a name="ln3148">        {</a>
<a name="ln3149">        }</a>
<a name="ln3150"> </a>
<a name="ln3151">        ////////////////////////////////////////////////////////////////////////</a>
<a name="ln3152">        // Clear buckets and Create buckets</a>
<a name="ln3153">        //</a>
<a name="ln3154">        // IMPORTANT: If the container already contains any elements, the</a>
<a name="ln3155">        //            buckets will not contain any links to them. This will</a>
<a name="ln3156">        //            need to be dealt with, for example by:</a>
<a name="ln3157">        //            - deleting them</a>
<a name="ln3158">        //            - putting them in a 'node_holder' for future use</a>
<a name="ln3159">        //              (as in assignment)</a>
<a name="ln3160">        //            - placing them in buckets (see rehash_impl)</a>
<a name="ln3161"> </a>
<a name="ln3162">        // Clear the bucket pointers.</a>
<a name="ln3163">        void clear_buckets()</a>
<a name="ln3164">        {</a>
<a name="ln3165">          bucket_pointer end = get_bucket_pointer(bucket_count_);</a>
<a name="ln3166">          for (bucket_pointer it = buckets_; it != end; ++it) {</a>
<a name="ln3167">            it-&gt;next_ = node_pointer();</a>
<a name="ln3168">          }</a>
<a name="ln3169">        }</a>
<a name="ln3170"> </a>
<a name="ln3171">        // Create container buckets. If the container already contains any</a>
<a name="ln3172">        // buckets</a>
<a name="ln3173">        // the linked list will be transferred to the new buckets, but none</a>
<a name="ln3174">        // of the bucket pointers will be set. See above note.</a>
<a name="ln3175">        //</a>
<a name="ln3176">        // Strong exception safety.</a>
<a name="ln3177">        void create_buckets(std::size_t new_count)</a>
<a name="ln3178">        {</a>
<a name="ln3179">          link_pointer dummy_node;</a>
<a name="ln3180"> </a>
<a name="ln3181">          // Construct the new buckets and dummy node, and destroy the old</a>
<a name="ln3182">          // buckets</a>
<a name="ln3183">          if (buckets_) {</a>
<a name="ln3184">            dummy_node =</a>
<a name="ln3185">              (buckets_ + static_cast&lt;std::ptrdiff_t&gt;(bucket_count_))-&gt;next_;</a>
<a name="ln3186">            bucket_pointer new_buckets =</a>
<a name="ln3187">              bucket_allocator_traits::allocate(bucket_alloc(), new_count + 1);</a>
<a name="ln3188">            destroy_buckets();</a>
<a name="ln3189">            buckets_ = new_buckets;</a>
<a name="ln3190">          } else if (bucket::extra_node) {</a>
<a name="ln3191">            node_constructor a(node_alloc());</a>
<a name="ln3192">            a.create_node();</a>
<a name="ln3193">            buckets_ =</a>
<a name="ln3194">              bucket_allocator_traits::allocate(bucket_alloc(), new_count + 1);</a>
<a name="ln3195">            dummy_node = a.release();</a>
<a name="ln3196">          } else {</a>
<a name="ln3197">            dummy_node = link_pointer();</a>
<a name="ln3198">            buckets_ =</a>
<a name="ln3199">              bucket_allocator_traits::allocate(bucket_alloc(), new_count + 1);</a>
<a name="ln3200">          }</a>
<a name="ln3201"> </a>
<a name="ln3202">          // nothrow from here...</a>
<a name="ln3203">          bucket_count_ = new_count;</a>
<a name="ln3204">          recalculate_max_load();</a>
<a name="ln3205"> </a>
<a name="ln3206">          bucket_pointer end =</a>
<a name="ln3207">            buckets_ + static_cast&lt;std::ptrdiff_t&gt;(new_count);</a>
<a name="ln3208">          for (bucket_pointer i = buckets_; i != end; ++i) {</a>
<a name="ln3209">            new ((void*)boost::to_address(i)) bucket();</a>
<a name="ln3210">          }</a>
<a name="ln3211">          new ((void*)boost::to_address(end)) bucket(dummy_node);</a>
<a name="ln3212">        }</a>
<a name="ln3213"> </a>
<a name="ln3214">        ////////////////////////////////////////////////////////////////////////</a>
<a name="ln3215">        // Swap and Move</a>
<a name="ln3216"> </a>
<a name="ln3217">        void swap_allocators(table&amp; other, false_type)</a>
<a name="ln3218">        {</a>
<a name="ln3219">          boost::unordered::detail::func::ignore_unused_variable_warning(other);</a>
<a name="ln3220"> </a>
<a name="ln3221">          // According to 23.2.1.8, if propagate_on_container_swap is</a>
<a name="ln3222">          // false the behaviour is undefined unless the allocators</a>
<a name="ln3223">          // are equal.</a>
<a name="ln3224">          BOOST_ASSERT(node_alloc() == other.node_alloc());</a>
<a name="ln3225">        }</a>
<a name="ln3226"> </a>
<a name="ln3227">        void swap_allocators(table&amp; other, true_type)</a>
<a name="ln3228">        {</a>
<a name="ln3229">          allocators_.swap(other.allocators_);</a>
<a name="ln3230">        }</a>
<a name="ln3231"> </a>
<a name="ln3232">        // Not nothrow swappable</a>
<a name="ln3233">        void swap(table&amp; x, false_type)</a>
<a name="ln3234">        {</a>
<a name="ln3235">          if (this == &amp;x) {</a>
<a name="ln3236">            return;</a>
<a name="ln3237">          }</a>
<a name="ln3238"> </a>
<a name="ln3239">          this-&gt;construct_spare_functions(x.current_functions());</a>
<a name="ln3240">          BOOST_TRY { x.construct_spare_functions(this-&gt;current_functions()); }</a>
<a name="ln3241">          BOOST_CATCH(...)</a>
<a name="ln3242">          {</a>
<a name="ln3243">            this-&gt;cleanup_spare_functions();</a>
<a name="ln3244">            BOOST_RETHROW</a>
<a name="ln3245">          }</a>
<a name="ln3246">          BOOST_CATCH_END</a>
<a name="ln3247">          this-&gt;switch_functions();</a>
<a name="ln3248">          x.switch_functions();</a>
<a name="ln3249"> </a>
<a name="ln3250">          swap_allocators(</a>
<a name="ln3251">            x, boost::unordered::detail::integral_constant&lt;bool,</a>
<a name="ln3252">                 allocator_traits&lt;</a>
<a name="ln3253">                   node_allocator&gt;::propagate_on_container_swap::value&gt;());</a>
<a name="ln3254"> </a>
<a name="ln3255">          boost::swap(buckets_, x.buckets_);</a>
<a name="ln3256">          boost::swap(bucket_count_, x.bucket_count_);</a>
<a name="ln3257">          boost::swap(size_, x.size_);</a>
<a name="ln3258">          std::swap(mlf_, x.mlf_);</a>
<a name="ln3259">          std::swap(max_load_, x.max_load_);</a>
<a name="ln3260">        }</a>
<a name="ln3261"> </a>
<a name="ln3262">        // Nothrow swappable</a>
<a name="ln3263">        void swap(table&amp; x, true_type)</a>
<a name="ln3264">        {</a>
<a name="ln3265">          swap_allocators(</a>
<a name="ln3266">            x, boost::unordered::detail::integral_constant&lt;bool,</a>
<a name="ln3267">                 allocator_traits&lt;</a>
<a name="ln3268">                   node_allocator&gt;::propagate_on_container_swap::value&gt;());</a>
<a name="ln3269"> </a>
<a name="ln3270">          boost::swap(buckets_, x.buckets_);</a>
<a name="ln3271">          boost::swap(bucket_count_, x.bucket_count_);</a>
<a name="ln3272">          boost::swap(size_, x.size_);</a>
<a name="ln3273">          std::swap(mlf_, x.mlf_);</a>
<a name="ln3274">          std::swap(max_load_, x.max_load_);</a>
<a name="ln3275">          this-&gt;current_functions().swap(x.current_functions());</a>
<a name="ln3276">        }</a>
<a name="ln3277"> </a>
<a name="ln3278">        // Only swaps the allocators if propagate_on_container_swap.</a>
<a name="ln3279">        // If not propagate_on_container_swap and allocators aren't</a>
<a name="ln3280">        // equal, behaviour is undefined.</a>
<a name="ln3281">        void swap(table&amp; x)</a>
<a name="ln3282">        {</a>
<a name="ln3283">          BOOST_ASSERT(allocator_traits&lt;</a>
<a name="ln3284">                         node_allocator&gt;::propagate_on_container_swap::value ||</a>
<a name="ln3285">                       node_alloc() == x.node_alloc());</a>
<a name="ln3286">          swap(x, boost::unordered::detail::integral_constant&lt;bool,</a>
<a name="ln3287">                    functions::nothrow_swappable&gt;());</a>
<a name="ln3288">        }</a>
<a name="ln3289"> </a>
<a name="ln3290">        // Only call with nodes allocated with the currect allocator, or</a>
<a name="ln3291">        // one that is equal to it. (Can't assert because other's</a>
<a name="ln3292">        // allocators might have already been moved).</a>
<a name="ln3293">        void move_buckets_from(table&amp; other)</a>
<a name="ln3294">        {</a>
<a name="ln3295">          BOOST_ASSERT(!buckets_);</a>
<a name="ln3296">          buckets_ = other.buckets_;</a>
<a name="ln3297">          bucket_count_ = other.bucket_count_;</a>
<a name="ln3298">          size_ = other.size_;</a>
<a name="ln3299">          max_load_ = other.max_load_;</a>
<a name="ln3300">          other.buckets_ = bucket_pointer();</a>
<a name="ln3301">          other.size_ = 0;</a>
<a name="ln3302">          other.max_load_ = 0;</a>
<a name="ln3303">        }</a>
<a name="ln3304"> </a>
<a name="ln3305">        // For use in the constructor when allocators might be different.</a>
<a name="ln3306">        void move_construct_buckets(table&amp; src)</a>
<a name="ln3307">        {</a>
<a name="ln3308">          if (this-&gt;node_alloc() == src.node_alloc()) {</a>
<a name="ln3309">            move_buckets_from(src);</a>
<a name="ln3310">          } else {</a>
<a name="ln3311">            this-&gt;create_buckets(this-&gt;bucket_count_);</a>
<a name="ln3312">            link_pointer prev = this-&gt;get_previous_start();</a>
<a name="ln3313">            std::size_t last_bucket = this-&gt;bucket_count_;</a>
<a name="ln3314">            for (node_pointer n = src.begin(); n; n = next_node(n)) {</a>
<a name="ln3315">              std::size_t n_bucket = n-&gt;get_bucket();</a>
<a name="ln3316">              if (n_bucket != last_bucket) {</a>
<a name="ln3317">                this-&gt;get_bucket_pointer(n_bucket)-&gt;next_ = prev;</a>
<a name="ln3318">              }</a>
<a name="ln3319">              node_pointer n2 = boost::unordered::detail::func::construct_node(</a>
<a name="ln3320">                this-&gt;node_alloc(), boost::move(n-&gt;value()));</a>
<a name="ln3321">              n2-&gt;bucket_info_ = n-&gt;bucket_info_;</a>
<a name="ln3322">              prev-&gt;next_ = n2;</a>
<a name="ln3323">              ++size_;</a>
<a name="ln3324">              prev = n2;</a>
<a name="ln3325">              last_bucket = n_bucket;</a>
<a name="ln3326">            }</a>
<a name="ln3327">          }</a>
<a name="ln3328">        }</a>
<a name="ln3329"> </a>
<a name="ln3330">        ////////////////////////////////////////////////////////////////////////</a>
<a name="ln3331">        // Delete/destruct</a>
<a name="ln3332"> </a>
<a name="ln3333">        ~table() { delete_buckets(); }</a>
<a name="ln3334"> </a>
<a name="ln3335">        void destroy_node(node_pointer n)</a>
<a name="ln3336">        {</a>
<a name="ln3337">          BOOST_UNORDERED_CALL_DESTROY(</a>
<a name="ln3338">            node_allocator_traits, node_alloc(), n-&gt;value_ptr());</a>
<a name="ln3339">          boost::unordered::detail::func::destroy(boost::to_address(n));</a>
<a name="ln3340">          node_allocator_traits::deallocate(node_alloc(), n, 1);</a>
<a name="ln3341">        }</a>
<a name="ln3342"> </a>
<a name="ln3343">        void delete_buckets()</a>
<a name="ln3344">        {</a>
<a name="ln3345">          if (buckets_) {</a>
<a name="ln3346">            node_pointer n = static_cast&lt;node_pointer&gt;(</a>
<a name="ln3347">              get_bucket_pointer(bucket_count_)-&gt;next_);</a>
<a name="ln3348"> </a>
<a name="ln3349">            if (bucket::extra_node) {</a>
<a name="ln3350">              node_pointer next = next_node(n);</a>
<a name="ln3351">              boost::unordered::detail::func::destroy(boost::to_address(n));</a>
<a name="ln3352">              node_allocator_traits::deallocate(node_alloc(), n, 1);</a>
<a name="ln3353">              n = next;</a>
<a name="ln3354">            }</a>
<a name="ln3355"> </a>
<a name="ln3356">            while (n) {</a>
<a name="ln3357">              node_pointer next = next_node(n);</a>
<a name="ln3358">              destroy_node(n);</a>
<a name="ln3359">              n = next;</a>
<a name="ln3360">            }</a>
<a name="ln3361"> </a>
<a name="ln3362">            destroy_buckets();</a>
<a name="ln3363">            buckets_ = bucket_pointer();</a>
<a name="ln3364">            max_load_ = 0;</a>
<a name="ln3365">            size_ = 0;</a>
<a name="ln3366">          }</a>
<a name="ln3367">        }</a>
<a name="ln3368"> </a>
<a name="ln3369">        void destroy_buckets()</a>
<a name="ln3370">        {</a>
<a name="ln3371">          bucket_pointer end = get_bucket_pointer(bucket_count_ + 1);</a>
<a name="ln3372">          for (bucket_pointer it = buckets_; it != end; ++it) {</a>
<a name="ln3373">            boost::unordered::detail::func::destroy(boost::to_address(it));</a>
<a name="ln3374">          }</a>
<a name="ln3375"> </a>
<a name="ln3376">          bucket_allocator_traits::deallocate(</a>
<a name="ln3377">            bucket_alloc(), buckets_, bucket_count_ + 1);</a>
<a name="ln3378">        }</a>
<a name="ln3379"> </a>
<a name="ln3380">        ////////////////////////////////////////////////////////////////////////</a>
<a name="ln3381">        // Fix buckets after delete/extract</a>
<a name="ln3382">        //</a>
<a name="ln3383">        // (prev,next) should mark an open range of nodes in a single bucket</a>
<a name="ln3384">        // which</a>
<a name="ln3385">        // have either been unlinked, or are about to be.</a>
<a name="ln3386"> </a>
<a name="ln3387">        std::size_t fix_bucket(</a>
<a name="ln3388">          std::size_t bucket_index, link_pointer prev, node_pointer next)</a>
<a name="ln3389">        {</a>
<a name="ln3390">          std::size_t bucket_index2 = bucket_index;</a>
<a name="ln3391"> </a>
<a name="ln3392">          if (next) {</a>
<a name="ln3393">            bucket_index2 = node_bucket(next);</a>
<a name="ln3394"> </a>
<a name="ln3395">            // If next is in the same bucket, then there's nothing to do.</a>
<a name="ln3396">            if (bucket_index == bucket_index2) {</a>
<a name="ln3397">              return bucket_index2;</a>
<a name="ln3398">            }</a>
<a name="ln3399"> </a>
<a name="ln3400">            // Update the bucket containing next.</a>
<a name="ln3401">            get_bucket_pointer(bucket_index2)-&gt;next_ = prev;</a>
<a name="ln3402">          }</a>
<a name="ln3403"> </a>
<a name="ln3404">          // Check if this bucket is now empty.</a>
<a name="ln3405">          bucket_pointer this_bucket = get_bucket_pointer(bucket_index);</a>
<a name="ln3406">          if (this_bucket-&gt;next_ == prev) {</a>
<a name="ln3407">            this_bucket-&gt;next_ = link_pointer();</a>
<a name="ln3408">          }</a>
<a name="ln3409"> </a>
<a name="ln3410">          return bucket_index2;</a>
<a name="ln3411">        }</a>
<a name="ln3412"> </a>
<a name="ln3413">        ////////////////////////////////////////////////////////////////////////</a>
<a name="ln3414">        // Clear</a>
<a name="ln3415"> </a>
<a name="ln3416">        void clear_impl();</a>
<a name="ln3417"> </a>
<a name="ln3418">        ////////////////////////////////////////////////////////////////////////</a>
<a name="ln3419">        // Assignment</a>
<a name="ln3420"> </a>
<a name="ln3421">        template &lt;typename UniqueType&gt;</a>
<a name="ln3422">        void assign(table const&amp; x, UniqueType is_unique)</a>
<a name="ln3423">        {</a>
<a name="ln3424">          if (this != &amp;x) {</a>
<a name="ln3425">            assign(x, is_unique,</a>
<a name="ln3426">              boost::unordered::detail::integral_constant&lt;bool,</a>
<a name="ln3427">                allocator_traits&lt;node_allocator&gt;::</a>
<a name="ln3428">                  propagate_on_container_copy_assignment::value&gt;());</a>
<a name="ln3429">          }</a>
<a name="ln3430">        }</a>
<a name="ln3431"> </a>
<a name="ln3432">        template &lt;typename UniqueType&gt;</a>
<a name="ln3433">        void assign(table const&amp; x, UniqueType is_unique, false_type)</a>
<a name="ln3434">        {</a>
<a name="ln3435">          // Strong exception safety.</a>
<a name="ln3436">          this-&gt;construct_spare_functions(x.current_functions());</a>
<a name="ln3437">          BOOST_TRY</a>
<a name="ln3438">          {</a>
<a name="ln3439">            mlf_ = x.mlf_;</a>
<a name="ln3440">            recalculate_max_load();</a>
<a name="ln3441"> </a>
<a name="ln3442">            if (x.size_ &gt; max_load_) {</a>
<a name="ln3443">              create_buckets(min_buckets_for_size(x.size_));</a>
<a name="ln3444">            } else if (size_) {</a>
<a name="ln3445">              clear_buckets();</a>
<a name="ln3446">            }</a>
<a name="ln3447">          }</a>
<a name="ln3448">          BOOST_CATCH(...)</a>
<a name="ln3449">          {</a>
<a name="ln3450">            this-&gt;cleanup_spare_functions();</a>
<a name="ln3451">            BOOST_RETHROW</a>
<a name="ln3452">          }</a>
<a name="ln3453">          BOOST_CATCH_END</a>
<a name="ln3454">          this-&gt;switch_functions();</a>
<a name="ln3455">          assign_buckets(x, is_unique);</a>
<a name="ln3456">        }</a>
<a name="ln3457"> </a>
<a name="ln3458">        template &lt;typename UniqueType&gt;</a>
<a name="ln3459">        void assign(table const&amp; x, UniqueType is_unique, true_type)</a>
<a name="ln3460">        {</a>
<a name="ln3461">          if (node_alloc() == x.node_alloc()) {</a>
<a name="ln3462">            allocators_.assign(x.allocators_);</a>
<a name="ln3463">            assign(x, is_unique, false_type());</a>
<a name="ln3464">          } else {</a>
<a name="ln3465">            this-&gt;construct_spare_functions(x.current_functions());</a>
<a name="ln3466">            this-&gt;switch_functions();</a>
<a name="ln3467"> </a>
<a name="ln3468">            // Delete everything with current allocators before assigning</a>
<a name="ln3469">            // the new ones.</a>
<a name="ln3470">            delete_buckets();</a>
<a name="ln3471">            allocators_.assign(x.allocators_);</a>
<a name="ln3472"> </a>
<a name="ln3473">            // Copy over other data, all no throw.</a>
<a name="ln3474">            mlf_ = x.mlf_;</a>
<a name="ln3475">            bucket_count_ = min_buckets_for_size(x.size_);</a>
<a name="ln3476"> </a>
<a name="ln3477">            // Finally copy the elements.</a>
<a name="ln3478">            if (x.size_) {</a>
<a name="ln3479">              copy_buckets(x, is_unique);</a>
<a name="ln3480">            }</a>
<a name="ln3481">          }</a>
<a name="ln3482">        }</a>
<a name="ln3483"> </a>
<a name="ln3484">        template &lt;typename UniqueType&gt;</a>
<a name="ln3485">        void move_assign(table&amp; x, UniqueType is_unique)</a>
<a name="ln3486">        {</a>
<a name="ln3487">          if (this != &amp;x) {</a>
<a name="ln3488">            move_assign(x, is_unique,</a>
<a name="ln3489">              boost::unordered::detail::integral_constant&lt;bool,</a>
<a name="ln3490">                allocator_traits&lt;node_allocator&gt;::</a>
<a name="ln3491">                  propagate_on_container_move_assignment::value&gt;());</a>
<a name="ln3492">          }</a>
<a name="ln3493">        }</a>
<a name="ln3494"> </a>
<a name="ln3495">        // Propagate allocator</a>
<a name="ln3496">        template &lt;typename UniqueType&gt;</a>
<a name="ln3497">        void move_assign(table&amp; x, UniqueType, true_type)</a>
<a name="ln3498">        {</a>
<a name="ln3499">          if (!functions::nothrow_move_assignable) {</a>
<a name="ln3500">            this-&gt;construct_spare_functions(x.current_functions());</a>
<a name="ln3501">            this-&gt;switch_functions();</a>
<a name="ln3502">          } else {</a>
<a name="ln3503">            this-&gt;current_functions().move_assign(x.current_functions());</a>
<a name="ln3504">          }</a>
<a name="ln3505">          delete_buckets();</a>
<a name="ln3506">          allocators_.move_assign(x.allocators_);</a>
<a name="ln3507">          mlf_ = x.mlf_;</a>
<a name="ln3508">          move_buckets_from(x);</a>
<a name="ln3509">        }</a>
<a name="ln3510"> </a>
<a name="ln3511">        // Don't propagate allocator</a>
<a name="ln3512">        template &lt;typename UniqueType&gt;</a>
<a name="ln3513">        void move_assign(table&amp; x, UniqueType is_unique, false_type)</a>
<a name="ln3514">        {</a>
<a name="ln3515">          if (node_alloc() == x.node_alloc()) {</a>
<a name="ln3516">            move_assign_equal_alloc(x);</a>
<a name="ln3517">          } else {</a>
<a name="ln3518">            move_assign_realloc(x, is_unique);</a>
<a name="ln3519">          }</a>
<a name="ln3520">        }</a>
<a name="ln3521"> </a>
<a name="ln3522">        void move_assign_equal_alloc(table&amp; x)</a>
<a name="ln3523">        {</a>
<a name="ln3524">          if (!functions::nothrow_move_assignable) {</a>
<a name="ln3525">            this-&gt;construct_spare_functions(x.current_functions());</a>
<a name="ln3526">            this-&gt;switch_functions();</a>
<a name="ln3527">          } else {</a>
<a name="ln3528">            this-&gt;current_functions().move_assign(x.current_functions());</a>
<a name="ln3529">          }</a>
<a name="ln3530">          delete_buckets();</a>
<a name="ln3531">          mlf_ = x.mlf_;</a>
<a name="ln3532">          move_buckets_from(x);</a>
<a name="ln3533">        }</a>
<a name="ln3534"> </a>
<a name="ln3535">        template &lt;typename UniqueType&gt;</a>
<a name="ln3536">        void move_assign_realloc(table&amp; x, UniqueType is_unique)</a>
<a name="ln3537">        {</a>
<a name="ln3538">          this-&gt;construct_spare_functions(x.current_functions());</a>
<a name="ln3539">          BOOST_TRY</a>
<a name="ln3540">          {</a>
<a name="ln3541">            mlf_ = x.mlf_;</a>
<a name="ln3542">            recalculate_max_load();</a>
<a name="ln3543"> </a>
<a name="ln3544">            if (x.size_ &gt; max_load_) {</a>
<a name="ln3545">              create_buckets(min_buckets_for_size(x.size_));</a>
<a name="ln3546">            } else if (size_) {</a>
<a name="ln3547">              clear_buckets();</a>
<a name="ln3548">            }</a>
<a name="ln3549">          }</a>
<a name="ln3550">          BOOST_CATCH(...)</a>
<a name="ln3551">          {</a>
<a name="ln3552">            this-&gt;cleanup_spare_functions();</a>
<a name="ln3553">            BOOST_RETHROW</a>
<a name="ln3554">          }</a>
<a name="ln3555">          BOOST_CATCH_END</a>
<a name="ln3556">          this-&gt;switch_functions();</a>
<a name="ln3557">          move_assign_buckets(x, is_unique);</a>
<a name="ln3558">        }</a>
<a name="ln3559"> </a>
<a name="ln3560">        // Accessors</a>
<a name="ln3561"> </a>
<a name="ln3562">        const_key_type&amp; get_key(node_pointer n) const</a>
<a name="ln3563">        {</a>
<a name="ln3564">          return extractor::extract(n-&gt;value());</a>
<a name="ln3565">        }</a>
<a name="ln3566"> </a>
<a name="ln3567">        std::size_t hash(const_key_type&amp; k) const</a>
<a name="ln3568">        {</a>
<a name="ln3569">          return policy::apply_hash(this-&gt;hash_function(), k);</a>
<a name="ln3570">        }</a>
<a name="ln3571"> </a>
<a name="ln3572">        // Find Node</a>
<a name="ln3573"> </a>
<a name="ln3574">        node_pointer find_node(std::size_t key_hash, const_key_type&amp; k) const</a>
<a name="ln3575">        {</a>
<a name="ln3576">          return this-&gt;find_node_impl(key_hash, k, this-&gt;key_eq());</a>
<a name="ln3577">        }</a>
<a name="ln3578"> </a>
<a name="ln3579">        node_pointer find_node(const_key_type&amp; k) const</a>
<a name="ln3580">        {</a>
<a name="ln3581">          return this-&gt;find_node_impl(hash(k), k, this-&gt;key_eq());</a>
<a name="ln3582">        }</a>
<a name="ln3583"> </a>
<a name="ln3584">        template &lt;class Key, class Pred&gt;</a>
<a name="ln3585">        node_pointer find_node_impl(</a>
<a name="ln3586">          std::size_t key_hash, Key const&amp; k, Pred const&amp; eq) const</a>
<a name="ln3587">        {</a>
<a name="ln3588">          std::size_t bucket_index = this-&gt;hash_to_bucket(key_hash);</a>
<a name="ln3589">          node_pointer n = this-&gt;begin(bucket_index);</a>
<a name="ln3590"> </a>
<a name="ln3591">          for (;;) {</a>
<a name="ln3592">            if (!n)</a>
<a name="ln3593">              return n;</a>
<a name="ln3594"> </a>
<a name="ln3595">            if (eq(k, this-&gt;get_key(n))) {</a>
<a name="ln3596">              return n;</a>
<a name="ln3597">            } else if (this-&gt;node_bucket(n) != bucket_index) {</a>
<a name="ln3598">              return node_pointer();</a>
<a name="ln3599">            }</a>
<a name="ln3600"> </a>
<a name="ln3601">            n = next_for_find(n);</a>
<a name="ln3602">          }</a>
<a name="ln3603">        }</a>
<a name="ln3604"> </a>
<a name="ln3605">        // Find the node before the key, so that it can be erased.</a>
<a name="ln3606">        link_pointer find_previous_node(</a>
<a name="ln3607">          const_key_type&amp; k, std::size_t bucket_index)</a>
<a name="ln3608">        {</a>
<a name="ln3609">          link_pointer prev = this-&gt;get_previous_start(bucket_index);</a>
<a name="ln3610">          if (!prev) {</a>
<a name="ln3611">            return prev;</a>
<a name="ln3612">          }</a>
<a name="ln3613"> </a>
<a name="ln3614">          for (;;) {</a>
<a name="ln3615">            node_pointer n = next_node(prev);</a>
<a name="ln3616">            if (!n) {</a>
<a name="ln3617">              return link_pointer();</a>
<a name="ln3618">            } else if (n-&gt;is_first_in_group()) {</a>
<a name="ln3619">              if (node_bucket(n) != bucket_index) {</a>
<a name="ln3620">                return link_pointer();</a>
<a name="ln3621">              } else if (this-&gt;key_eq()(k, this-&gt;get_key(n))) {</a>
<a name="ln3622">                return prev;</a>
<a name="ln3623">              }</a>
<a name="ln3624">            }</a>
<a name="ln3625">            prev = n;</a>
<a name="ln3626">          }</a>
<a name="ln3627">        }</a>
<a name="ln3628"> </a>
<a name="ln3629">        // Extract and erase</a>
<a name="ln3630"> </a>
<a name="ln3631">        inline node_pointer extract_by_key(const_key_type&amp; k)</a>
<a name="ln3632">        {</a>
<a name="ln3633">          if (!this-&gt;size_) {</a>
<a name="ln3634">            return node_pointer();</a>
<a name="ln3635">          }</a>
<a name="ln3636">          std::size_t key_hash = this-&gt;hash(k);</a>
<a name="ln3637">          std::size_t bucket_index = this-&gt;hash_to_bucket(key_hash);</a>
<a name="ln3638">          link_pointer prev = this-&gt;find_previous_node(k, bucket_index);</a>
<a name="ln3639">          if (!prev) {</a>
<a name="ln3640">            return node_pointer();</a>
<a name="ln3641">          }</a>
<a name="ln3642">          node_pointer n = next_node(prev);</a>
<a name="ln3643">          node_pointer n2 = next_node(n);</a>
<a name="ln3644">          if (n2) {</a>
<a name="ln3645">            n2-&gt;set_first_in_group();</a>
<a name="ln3646">          }</a>
<a name="ln3647">          prev-&gt;next_ = n2;</a>
<a name="ln3648">          --this-&gt;size_;</a>
<a name="ln3649">          this-&gt;fix_bucket(bucket_index, prev, n2);</a>
<a name="ln3650">          n-&gt;next_ = link_pointer();</a>
<a name="ln3651"> </a>
<a name="ln3652">          return n;</a>
<a name="ln3653">        }</a>
<a name="ln3654"> </a>
<a name="ln3655">        // Reserve and rehash</a>
<a name="ln3656"> </a>
<a name="ln3657">        void reserve_for_insert(std::size_t);</a>
<a name="ln3658">        void rehash(std::size_t);</a>
<a name="ln3659">        void reserve(std::size_t);</a>
<a name="ln3660">        void rehash_impl(std::size_t);</a>
<a name="ln3661"> </a>
<a name="ln3662">        ////////////////////////////////////////////////////////////////////////</a>
<a name="ln3663">        // Unique keys</a>
<a name="ln3664"> </a>
<a name="ln3665">        // equals</a>
<a name="ln3666"> </a>
<a name="ln3667">        bool equals_unique(table const&amp; other) const</a>
<a name="ln3668">        {</a>
<a name="ln3669">          if (this-&gt;size_ != other.size_)</a>
<a name="ln3670">            return false;</a>
<a name="ln3671"> </a>
<a name="ln3672">          for (node_pointer n1 = this-&gt;begin(); n1; n1 = next_node(n1)) {</a>
<a name="ln3673">            node_pointer n2 = other.find_node(other.get_key(n1));</a>
<a name="ln3674"> </a>
<a name="ln3675">            if (!n2 || n1-&gt;value() != n2-&gt;value())</a>
<a name="ln3676">              return false;</a>
<a name="ln3677">          }</a>
<a name="ln3678"> </a>
<a name="ln3679">          return true;</a>
<a name="ln3680">        }</a>
<a name="ln3681"> </a>
<a name="ln3682">        // Emplace/Insert</a>
<a name="ln3683"> </a>
<a name="ln3684">        inline node_pointer add_node_unique(</a>
<a name="ln3685">          node_pointer n, std::size_t key_hash)</a>
<a name="ln3686">        {</a>
<a name="ln3687">          std::size_t bucket_index = this-&gt;hash_to_bucket(key_hash);</a>
<a name="ln3688">          bucket_pointer b = this-&gt;get_bucket_pointer(bucket_index);</a>
<a name="ln3689"> </a>
<a name="ln3690">          n-&gt;bucket_info_ = bucket_index;</a>
<a name="ln3691">          n-&gt;set_first_in_group();</a>
<a name="ln3692"> </a>
<a name="ln3693">          if (!b-&gt;next_) {</a>
<a name="ln3694">            link_pointer start_node = this-&gt;get_previous_start();</a>
<a name="ln3695"> </a>
<a name="ln3696">            if (start_node-&gt;next_) {</a>
<a name="ln3697">              this-&gt;get_bucket_pointer(node_bucket(next_node(start_node)))</a>
<a name="ln3698">                -&gt;next_ = n;</a>
<a name="ln3699">            }</a>
<a name="ln3700"> </a>
<a name="ln3701">            b-&gt;next_ = start_node;</a>
<a name="ln3702">            n-&gt;next_ = start_node-&gt;next_;</a>
<a name="ln3703">            start_node-&gt;next_ = n;</a>
<a name="ln3704">          } else {</a>
<a name="ln3705">            n-&gt;next_ = b-&gt;next_-&gt;next_;</a>
<a name="ln3706">            b-&gt;next_-&gt;next_ = n;</a>
<a name="ln3707">          }</a>
<a name="ln3708"> </a>
<a name="ln3709">          ++this-&gt;size_;</a>
<a name="ln3710">          return n;</a>
<a name="ln3711">        }</a>
<a name="ln3712"> </a>
<a name="ln3713">        inline node_pointer resize_and_add_node_unique(</a>
<a name="ln3714">          node_pointer n, std::size_t key_hash)</a>
<a name="ln3715">        {</a>
<a name="ln3716">          node_tmp b(n, this-&gt;node_alloc());</a>
<a name="ln3717">          this-&gt;reserve_for_insert(this-&gt;size_ + 1);</a>
<a name="ln3718">          return this-&gt;add_node_unique(b.release(), key_hash);</a>
<a name="ln3719">        }</a>
<a name="ln3720"> </a>
<a name="ln3721">        template &lt;BOOST_UNORDERED_EMPLACE_TEMPLATE&gt;</a>
<a name="ln3722">        iterator emplace_hint_unique(</a>
<a name="ln3723">          c_iterator hint, const_key_type&amp; k, BOOST_UNORDERED_EMPLACE_ARGS)</a>
<a name="ln3724">        {</a>
<a name="ln3725">          if (hint.node_ &amp;&amp; this-&gt;key_eq()(k, this-&gt;get_key(hint.node_))) {</a>
<a name="ln3726">            return iterator(hint.node_);</a>
<a name="ln3727">          } else {</a>
<a name="ln3728">            return emplace_unique(k, BOOST_UNORDERED_EMPLACE_FORWARD).first;</a>
<a name="ln3729">          }</a>
<a name="ln3730">        }</a>
<a name="ln3731"> </a>
<a name="ln3732">        template &lt;BOOST_UNORDERED_EMPLACE_TEMPLATE&gt;</a>
<a name="ln3733">        emplace_return emplace_unique(</a>
<a name="ln3734">          const_key_type&amp; k, BOOST_UNORDERED_EMPLACE_ARGS)</a>
<a name="ln3735">        {</a>
<a name="ln3736">          std::size_t key_hash = this-&gt;hash(k);</a>
<a name="ln3737">          node_pointer pos = this-&gt;find_node(key_hash, k);</a>
<a name="ln3738">          if (pos) {</a>
<a name="ln3739">            return emplace_return(iterator(pos), false);</a>
<a name="ln3740">          } else {</a>
<a name="ln3741">            return emplace_return(</a>
<a name="ln3742">              iterator(this-&gt;resize_and_add_node_unique(</a>
<a name="ln3743">                boost::unordered::detail::func::construct_node_from_args(</a>
<a name="ln3744">                  this-&gt;node_alloc(), BOOST_UNORDERED_EMPLACE_FORWARD),</a>
<a name="ln3745">                key_hash)),</a>
<a name="ln3746">              true);</a>
<a name="ln3747">          }</a>
<a name="ln3748">        }</a>
<a name="ln3749"> </a>
<a name="ln3750">        template &lt;BOOST_UNORDERED_EMPLACE_TEMPLATE&gt;</a>
<a name="ln3751">        iterator emplace_hint_unique(</a>
<a name="ln3752">          c_iterator hint, no_key, BOOST_UNORDERED_EMPLACE_ARGS)</a>
<a name="ln3753">        {</a>
<a name="ln3754">          node_tmp b(boost::unordered::detail::func::construct_node_from_args(</a>
<a name="ln3755">                       this-&gt;node_alloc(), BOOST_UNORDERED_EMPLACE_FORWARD),</a>
<a name="ln3756">            this-&gt;node_alloc());</a>
<a name="ln3757">          const_key_type&amp; k = this-&gt;get_key(b.node_);</a>
<a name="ln3758">          if (hint.node_ &amp;&amp; this-&gt;key_eq()(k, this-&gt;get_key(hint.node_))) {</a>
<a name="ln3759">            return iterator(hint.node_);</a>
<a name="ln3760">          }</a>
<a name="ln3761">          std::size_t key_hash = this-&gt;hash(k);</a>
<a name="ln3762">          node_pointer pos = this-&gt;find_node(key_hash, k);</a>
<a name="ln3763">          if (pos) {</a>
<a name="ln3764">            return iterator(pos);</a>
<a name="ln3765">          } else {</a>
<a name="ln3766">            return iterator(</a>
<a name="ln3767">              this-&gt;resize_and_add_node_unique(b.release(), key_hash));</a>
<a name="ln3768">          }</a>
<a name="ln3769">        }</a>
<a name="ln3770"> </a>
<a name="ln3771">        template &lt;BOOST_UNORDERED_EMPLACE_TEMPLATE&gt;</a>
<a name="ln3772">        emplace_return emplace_unique(no_key, BOOST_UNORDERED_EMPLACE_ARGS)</a>
<a name="ln3773">        {</a>
<a name="ln3774">          node_tmp b(boost::unordered::detail::func::construct_node_from_args(</a>
<a name="ln3775">                       this-&gt;node_alloc(), BOOST_UNORDERED_EMPLACE_FORWARD),</a>
<a name="ln3776">            this-&gt;node_alloc());</a>
<a name="ln3777">          const_key_type&amp; k = this-&gt;get_key(b.node_);</a>
<a name="ln3778">          std::size_t key_hash = this-&gt;hash(k);</a>
<a name="ln3779">          node_pointer pos = this-&gt;find_node(key_hash, k);</a>
<a name="ln3780">          if (pos) {</a>
<a name="ln3781">            return emplace_return(iterator(pos), false);</a>
<a name="ln3782">          } else {</a>
<a name="ln3783">            return emplace_return(</a>
<a name="ln3784">              iterator(this-&gt;resize_and_add_node_unique(b.release(), key_hash)),</a>
<a name="ln3785">              true);</a>
<a name="ln3786">          }</a>
<a name="ln3787">        }</a>
<a name="ln3788"> </a>
<a name="ln3789">        template &lt;typename Key&gt;</a>
<a name="ln3790">        emplace_return try_emplace_unique(BOOST_FWD_REF(Key) k)</a>
<a name="ln3791">        {</a>
<a name="ln3792">          std::size_t key_hash = this-&gt;hash(k);</a>
<a name="ln3793">          node_pointer pos = this-&gt;find_node(key_hash, k);</a>
<a name="ln3794">          if (pos) {</a>
<a name="ln3795">            return emplace_return(iterator(pos), false);</a>
<a name="ln3796">          } else {</a>
<a name="ln3797">            return emplace_return(</a>
<a name="ln3798">              iterator(this-&gt;resize_and_add_node_unique(</a>
<a name="ln3799">                boost::unordered::detail::func::construct_node_pair(</a>
<a name="ln3800">                  this-&gt;node_alloc(), boost::forward&lt;Key&gt;(k)),</a>
<a name="ln3801">                key_hash)),</a>
<a name="ln3802">              true);</a>
<a name="ln3803">          }</a>
<a name="ln3804">        }</a>
<a name="ln3805"> </a>
<a name="ln3806">        template &lt;typename Key&gt;</a>
<a name="ln3807">        iterator try_emplace_hint_unique(c_iterator hint, BOOST_FWD_REF(Key) k)</a>
<a name="ln3808">        {</a>
<a name="ln3809">          if (hint.node_ &amp;&amp; this-&gt;key_eq()(hint-&gt;first, k)) {</a>
<a name="ln3810">            return iterator(hint.node_);</a>
<a name="ln3811">          } else {</a>
<a name="ln3812">            return try_emplace_unique(k).first;</a>
<a name="ln3813">          }</a>
<a name="ln3814">        }</a>
<a name="ln3815"> </a>
<a name="ln3816">        template &lt;typename Key, BOOST_UNORDERED_EMPLACE_TEMPLATE&gt;</a>
<a name="ln3817">        emplace_return try_emplace_unique(</a>
<a name="ln3818">          BOOST_FWD_REF(Key) k, BOOST_UNORDERED_EMPLACE_ARGS)</a>
<a name="ln3819">        {</a>
<a name="ln3820">          std::size_t key_hash = this-&gt;hash(k);</a>
<a name="ln3821">          node_pointer pos = this-&gt;find_node(key_hash, k);</a>
<a name="ln3822">          if (pos) {</a>
<a name="ln3823">            return emplace_return(iterator(pos), false);</a>
<a name="ln3824">          } else {</a>
<a name="ln3825">            return emplace_return(</a>
<a name="ln3826">              iterator(this-&gt;resize_and_add_node_unique(</a>
<a name="ln3827">                boost::unordered::detail::func::construct_node_pair_from_args(</a>
<a name="ln3828">                  this-&gt;node_alloc(), boost::forward&lt;Key&gt;(k),</a>
<a name="ln3829">                  BOOST_UNORDERED_EMPLACE_FORWARD),</a>
<a name="ln3830">                key_hash)),</a>
<a name="ln3831">              true);</a>
<a name="ln3832">          }</a>
<a name="ln3833">        }</a>
<a name="ln3834"> </a>
<a name="ln3835">        template &lt;typename Key, BOOST_UNORDERED_EMPLACE_TEMPLATE&gt;</a>
<a name="ln3836">        iterator try_emplace_hint_unique(</a>
<a name="ln3837">          c_iterator hint, BOOST_FWD_REF(Key) k, BOOST_UNORDERED_EMPLACE_ARGS)</a>
<a name="ln3838">        {</a>
<a name="ln3839">          if (hint.node_ &amp;&amp; this-&gt;key_eq()(hint-&gt;first, k)) {</a>
<a name="ln3840">            return iterator(hint.node_);</a>
<a name="ln3841">          } else {</a>
<a name="ln3842">            return try_emplace_unique(k, BOOST_UNORDERED_EMPLACE_FORWARD).first;</a>
<a name="ln3843">          }</a>
<a name="ln3844">        }</a>
<a name="ln3845"> </a>
<a name="ln3846">        template &lt;typename Key, typename M&gt;</a>
<a name="ln3847">        emplace_return insert_or_assign_unique(</a>
<a name="ln3848">          BOOST_FWD_REF(Key) k, BOOST_FWD_REF(M) obj)</a>
<a name="ln3849">        {</a>
<a name="ln3850">          std::size_t key_hash = this-&gt;hash(k);</a>
<a name="ln3851">          node_pointer pos = this-&gt;find_node(key_hash, k);</a>
<a name="ln3852"> </a>
<a name="ln3853">          if (pos) {</a>
<a name="ln3854">            pos-&gt;value().second = boost::forward&lt;M&gt;(obj);</a>
<a name="ln3855">            return emplace_return(iterator(pos), false);</a>
<a name="ln3856">          } else {</a>
<a name="ln3857">            return emplace_return(</a>
<a name="ln3858">              iterator(this-&gt;resize_and_add_node_unique(</a>
<a name="ln3859">                boost::unordered::detail::func::construct_node_pair(</a>
<a name="ln3860">                  this-&gt;node_alloc(), boost::forward&lt;Key&gt;(k),</a>
<a name="ln3861">                  boost::forward&lt;M&gt;(obj)),</a>
<a name="ln3862">                key_hash)),</a>
<a name="ln3863">              true);</a>
<a name="ln3864">          }</a>
<a name="ln3865">        }</a>
<a name="ln3866"> </a>
<a name="ln3867">        template &lt;typename NodeType, typename InsertReturnType&gt;</a>
<a name="ln3868">        void move_insert_node_type_unique(</a>
<a name="ln3869">          NodeType&amp; np, InsertReturnType&amp; result)</a>
<a name="ln3870">        {</a>
<a name="ln3871">          if (np) {</a>
<a name="ln3872">            const_key_type&amp; k = this-&gt;get_key(np.ptr_);</a>
<a name="ln3873">            std::size_t key_hash = this-&gt;hash(k);</a>
<a name="ln3874">            node_pointer pos = this-&gt;find_node(key_hash, k);</a>
<a name="ln3875"> </a>
<a name="ln3876">            if (pos) {</a>
<a name="ln3877">              result.node = boost::move(np);</a>
<a name="ln3878">              result.position = iterator(pos);</a>
<a name="ln3879">            } else {</a>
<a name="ln3880">              this-&gt;reserve_for_insert(this-&gt;size_ + 1);</a>
<a name="ln3881">              result.position =</a>
<a name="ln3882">                iterator(this-&gt;add_node_unique(np.ptr_, key_hash));</a>
<a name="ln3883">              result.inserted = true;</a>
<a name="ln3884">              np.ptr_ = node_pointer();</a>
<a name="ln3885">            }</a>
<a name="ln3886">          }</a>
<a name="ln3887">        }</a>
<a name="ln3888"> </a>
<a name="ln3889">        template &lt;typename NodeType&gt;</a>
<a name="ln3890">        iterator move_insert_node_type_with_hint_unique(</a>
<a name="ln3891">          c_iterator hint, NodeType&amp; np)</a>
<a name="ln3892">        {</a>
<a name="ln3893">          if (!np) {</a>
<a name="ln3894">            return iterator();</a>
<a name="ln3895">          }</a>
<a name="ln3896">          const_key_type&amp; k = this-&gt;get_key(np.ptr_);</a>
<a name="ln3897">          if (hint.node_ &amp;&amp; this-&gt;key_eq()(k, this-&gt;get_key(hint.node_))) {</a>
<a name="ln3898">            return iterator(hint.node_);</a>
<a name="ln3899">          }</a>
<a name="ln3900">          std::size_t key_hash = this-&gt;hash(k);</a>
<a name="ln3901">          node_pointer pos = this-&gt;find_node(key_hash, k);</a>
<a name="ln3902">          if (!pos) {</a>
<a name="ln3903">            this-&gt;reserve_for_insert(this-&gt;size_ + 1);</a>
<a name="ln3904">            pos = this-&gt;add_node_unique(np.ptr_, key_hash);</a>
<a name="ln3905">            np.ptr_ = node_pointer();</a>
<a name="ln3906">          }</a>
<a name="ln3907">          return iterator(pos);</a>
<a name="ln3908">        }</a>
<a name="ln3909"> </a>
<a name="ln3910">        template &lt;typename Types2&gt;</a>
<a name="ln3911">        void merge_unique(boost::unordered::detail::table&lt;Types2&gt;&amp; other)</a>
<a name="ln3912">        {</a>
<a name="ln3913">          typedef boost::unordered::detail::table&lt;Types2&gt; other_table;</a>
<a name="ln3914">          BOOST_STATIC_ASSERT(</a>
<a name="ln3915">            (boost::is_same&lt;node, typename other_table::node&gt;::value));</a>
<a name="ln3916">          BOOST_ASSERT(this-&gt;node_alloc() == other.node_alloc());</a>
<a name="ln3917"> </a>
<a name="ln3918">          if (other.size_) {</a>
<a name="ln3919">            link_pointer prev = other.get_previous_start();</a>
<a name="ln3920"> </a>
<a name="ln3921">            while (prev-&gt;next_) {</a>
<a name="ln3922">              node_pointer n = other_table::next_node(prev);</a>
<a name="ln3923">              const_key_type&amp; k = this-&gt;get_key(n);</a>
<a name="ln3924">              std::size_t key_hash = this-&gt;hash(k);</a>
<a name="ln3925">              node_pointer pos = this-&gt;find_node(key_hash, k);</a>
<a name="ln3926"> </a>
<a name="ln3927">              if (pos) {</a>
<a name="ln3928">                prev = n;</a>
<a name="ln3929">              } else {</a>
<a name="ln3930">                this-&gt;reserve_for_insert(this-&gt;size_ + 1);</a>
<a name="ln3931">                node_pointer n2 = next_node(n);</a>
<a name="ln3932">                prev-&gt;next_ = n2;</a>
<a name="ln3933">                if (n2 &amp;&amp; n-&gt;is_first_in_group()) {</a>
<a name="ln3934">                  n2-&gt;set_first_in_group();</a>
<a name="ln3935">                }</a>
<a name="ln3936">                --other.size_;</a>
<a name="ln3937">                other.fix_bucket(other.node_bucket(n), prev, n2);</a>
<a name="ln3938">                this-&gt;add_node_unique(n, key_hash);</a>
<a name="ln3939">              }</a>
<a name="ln3940">            }</a>
<a name="ln3941">          }</a>
<a name="ln3942">        }</a>
<a name="ln3943"> </a>
<a name="ln3944">        ////////////////////////////////////////////////////////////////////////</a>
<a name="ln3945">        // Insert range methods</a>
<a name="ln3946">        //</a>
<a name="ln3947">        // if hash function throws, or inserting &gt; 1 element, basic exception</a>
<a name="ln3948">        // safety strong otherwise</a>
<a name="ln3949"> </a>
<a name="ln3950">        template &lt;class InputIt&gt;</a>
<a name="ln3951">        void insert_range_unique(const_key_type&amp; k, InputIt i, InputIt j)</a>
<a name="ln3952">        {</a>
<a name="ln3953">          insert_range_unique2(k, i, j);</a>
<a name="ln3954"> </a>
<a name="ln3955">          while (++i != j) {</a>
<a name="ln3956">            // Note: can't use get_key as '*i' might not be value_type - it</a>
<a name="ln3957">            // could be a pair with first_types as key_type without const or</a>
<a name="ln3958">            // a different second_type.</a>
<a name="ln3959">            insert_range_unique2(extractor::extract(*i), i, j);</a>
<a name="ln3960">          }</a>
<a name="ln3961">        }</a>
<a name="ln3962"> </a>
<a name="ln3963">        template &lt;class InputIt&gt;</a>
<a name="ln3964">        void insert_range_unique2(const_key_type&amp; k, InputIt i, InputIt j)</a>
<a name="ln3965">        {</a>
<a name="ln3966">          // No side effects in this initial code</a>
<a name="ln3967">          std::size_t key_hash = this-&gt;hash(k);</a>
<a name="ln3968">          node_pointer pos = this-&gt;find_node(key_hash, k);</a>
<a name="ln3969"> </a>
<a name="ln3970">          if (!pos) {</a>
<a name="ln3971">            node_tmp b(boost::unordered::detail::func::construct_node(</a>
<a name="ln3972">                         this-&gt;node_alloc(), *i),</a>
<a name="ln3973">              this-&gt;node_alloc());</a>
<a name="ln3974">            if (this-&gt;size_ + 1 &gt; this-&gt;max_load_)</a>
<a name="ln3975">              this-&gt;reserve_for_insert(</a>
<a name="ln3976">                this-&gt;size_ + boost::unordered::detail::insert_size(i, j));</a>
<a name="ln3977">            this-&gt;add_node_unique(b.release(), key_hash);</a>
<a name="ln3978">          }</a>
<a name="ln3979">        }</a>
<a name="ln3980"> </a>
<a name="ln3981">        template &lt;class InputIt&gt;</a>
<a name="ln3982">        void insert_range_unique(no_key, InputIt i, InputIt j)</a>
<a name="ln3983">        {</a>
<a name="ln3984">          node_constructor a(this-&gt;node_alloc());</a>
<a name="ln3985"> </a>
<a name="ln3986">          do {</a>
<a name="ln3987">            if (!a.node_) {</a>
<a name="ln3988">              a.create_node();</a>
<a name="ln3989">            }</a>
<a name="ln3990">            BOOST_UNORDERED_CALL_CONSTRUCT1(</a>
<a name="ln3991">              node_allocator_traits, a.alloc_, a.node_-&gt;value_ptr(), *i);</a>
<a name="ln3992">            node_tmp b(a.release(), a.alloc_);</a>
<a name="ln3993"> </a>
<a name="ln3994">            const_key_type&amp; k = this-&gt;get_key(b.node_);</a>
<a name="ln3995">            std::size_t key_hash = this-&gt;hash(k);</a>
<a name="ln3996">            node_pointer pos = this-&gt;find_node(key_hash, k);</a>
<a name="ln3997"> </a>
<a name="ln3998">            if (pos) {</a>
<a name="ln3999">              a.reclaim(b.release());</a>
<a name="ln4000">            } else {</a>
<a name="ln4001">              // reserve has basic exception safety if the hash function</a>
<a name="ln4002">              // throws, strong otherwise.</a>
<a name="ln4003">              this-&gt;reserve_for_insert(this-&gt;size_ + 1);</a>
<a name="ln4004">              this-&gt;add_node_unique(b.release(), key_hash);</a>
<a name="ln4005">            }</a>
<a name="ln4006">          } while (++i != j);</a>
<a name="ln4007">        }</a>
<a name="ln4008"> </a>
<a name="ln4009">        ////////////////////////////////////////////////////////////////////////</a>
<a name="ln4010">        // Extract</a>
<a name="ln4011"> </a>
<a name="ln4012">        inline node_pointer extract_by_iterator_unique(c_iterator i)</a>
<a name="ln4013">        {</a>
<a name="ln4014">          node_pointer n = i.node_;</a>
<a name="ln4015">          BOOST_ASSERT(n);</a>
<a name="ln4016">          std::size_t bucket_index = this-&gt;node_bucket(n);</a>
<a name="ln4017">          link_pointer prev = this-&gt;get_previous_start(bucket_index);</a>
<a name="ln4018">          while (prev-&gt;next_ != n) {</a>
<a name="ln4019">            prev = prev-&gt;next_;</a>
<a name="ln4020">          }</a>
<a name="ln4021">          node_pointer n2 = next_node(n);</a>
<a name="ln4022">          prev-&gt;next_ = n2;</a>
<a name="ln4023">          --this-&gt;size_;</a>
<a name="ln4024">          this-&gt;fix_bucket(bucket_index, prev, n2);</a>
<a name="ln4025">          n-&gt;next_ = link_pointer();</a>
<a name="ln4026">          return n;</a>
<a name="ln4027">        }</a>
<a name="ln4028"> </a>
<a name="ln4029">        ////////////////////////////////////////////////////////////////////////</a>
<a name="ln4030">        // Erase</a>
<a name="ln4031">        //</a>
<a name="ln4032">        // no throw</a>
<a name="ln4033"> </a>
<a name="ln4034">        std::size_t erase_key_unique(const_key_type&amp; k)</a>
<a name="ln4035">        {</a>
<a name="ln4036">          if (!this-&gt;size_)</a>
<a name="ln4037">            return 0;</a>
<a name="ln4038">          std::size_t key_hash = this-&gt;hash(k);</a>
<a name="ln4039">          std::size_t bucket_index = this-&gt;hash_to_bucket(key_hash);</a>
<a name="ln4040">          link_pointer prev = this-&gt;find_previous_node(k, bucket_index);</a>
<a name="ln4041">          if (!prev)</a>
<a name="ln4042">            return 0;</a>
<a name="ln4043">          node_pointer n = next_node(prev);</a>
<a name="ln4044">          node_pointer n2 = next_node(n);</a>
<a name="ln4045">          prev-&gt;next_ = n2;</a>
<a name="ln4046">          --size_;</a>
<a name="ln4047">          this-&gt;fix_bucket(bucket_index, prev, n2);</a>
<a name="ln4048">          this-&gt;destroy_node(n);</a>
<a name="ln4049">          return 1;</a>
<a name="ln4050">        }</a>
<a name="ln4051"> </a>
<a name="ln4052">        void erase_nodes_unique(node_pointer i, node_pointer j)</a>
<a name="ln4053">        {</a>
<a name="ln4054">          std::size_t bucket_index = this-&gt;node_bucket(i);</a>
<a name="ln4055"> </a>
<a name="ln4056">          // Find the node before i.</a>
<a name="ln4057">          link_pointer prev = this-&gt;get_previous_start(bucket_index);</a>
<a name="ln4058">          while (prev-&gt;next_ != i)</a>
<a name="ln4059">            prev = prev-&gt;next_;</a>
<a name="ln4060"> </a>
<a name="ln4061">          // Delete the nodes.</a>
<a name="ln4062">          prev-&gt;next_ = j;</a>
<a name="ln4063">          do {</a>
<a name="ln4064">            node_pointer next = next_node(i);</a>
<a name="ln4065">            destroy_node(i);</a>
<a name="ln4066">            --size_;</a>
<a name="ln4067">            bucket_index = this-&gt;fix_bucket(bucket_index, prev, next);</a>
<a name="ln4068">            i = next;</a>
<a name="ln4069">          } while (i != j);</a>
<a name="ln4070">        }</a>
<a name="ln4071"> </a>
<a name="ln4072">        ////////////////////////////////////////////////////////////////////////</a>
<a name="ln4073">        // fill_buckets_unique</a>
<a name="ln4074"> </a>
<a name="ln4075">        void copy_buckets(table const&amp; src, true_type)</a>
<a name="ln4076">        {</a>
<a name="ln4077">          this-&gt;create_buckets(this-&gt;bucket_count_);</a>
<a name="ln4078"> </a>
<a name="ln4079">          for (node_pointer n = src.begin(); n; n = next_node(n)) {</a>
<a name="ln4080">            std::size_t key_hash = this-&gt;hash(this-&gt;get_key(n));</a>
<a name="ln4081">            this-&gt;add_node_unique(</a>
<a name="ln4082">              boost::unordered::detail::func::construct_node(</a>
<a name="ln4083">                this-&gt;node_alloc(), n-&gt;value()),</a>
<a name="ln4084">              key_hash);</a>
<a name="ln4085">          }</a>
<a name="ln4086">        }</a>
<a name="ln4087"> </a>
<a name="ln4088">        void assign_buckets(table const&amp; src, true_type)</a>
<a name="ln4089">        {</a>
<a name="ln4090">          node_holder&lt;node_allocator&gt; holder(*this);</a>
<a name="ln4091">          for (node_pointer n = src.begin(); n; n = next_node(n)) {</a>
<a name="ln4092">            std::size_t key_hash = this-&gt;hash(this-&gt;get_key(n));</a>
<a name="ln4093">            this-&gt;add_node_unique(holder.copy_of(n-&gt;value()), key_hash);</a>
<a name="ln4094">          }</a>
<a name="ln4095">        }</a>
<a name="ln4096"> </a>
<a name="ln4097">        void move_assign_buckets(table&amp; src, true_type)</a>
<a name="ln4098">        {</a>
<a name="ln4099">          node_holder&lt;node_allocator&gt; holder(*this);</a>
<a name="ln4100">          for (node_pointer n = src.begin(); n; n = next_node(n)) {</a>
<a name="ln4101">            std::size_t key_hash = this-&gt;hash(this-&gt;get_key(n));</a>
<a name="ln4102">            this-&gt;add_node_unique(holder.move_copy_of(n-&gt;value()), key_hash);</a>
<a name="ln4103">          }</a>
<a name="ln4104">        }</a>
<a name="ln4105"> </a>
<a name="ln4106">        ////////////////////////////////////////////////////////////////////////</a>
<a name="ln4107">        // Equivalent keys</a>
<a name="ln4108"> </a>
<a name="ln4109">        // Equality</a>
<a name="ln4110"> </a>
<a name="ln4111">        bool equals_equiv(table const&amp; other) const</a>
<a name="ln4112">        {</a>
<a name="ln4113">          if (this-&gt;size_ != other.size_)</a>
<a name="ln4114">            return false;</a>
<a name="ln4115"> </a>
<a name="ln4116">          for (node_pointer n1 = this-&gt;begin(); n1;) {</a>
<a name="ln4117">            node_pointer n2 = other.find_node(other.get_key(n1));</a>
<a name="ln4118">            if (!n2)</a>
<a name="ln4119">              return false;</a>
<a name="ln4120">            node_pointer end1 = next_group(n1);</a>
<a name="ln4121">            node_pointer end2 = next_group(n2);</a>
<a name="ln4122">            if (!group_equals_equiv(n1, end1, n2, end2))</a>
<a name="ln4123">              return false;</a>
<a name="ln4124">            n1 = end1;</a>
<a name="ln4125">          }</a>
<a name="ln4126"> </a>
<a name="ln4127">          return true;</a>
<a name="ln4128">        }</a>
<a name="ln4129"> </a>
<a name="ln4130">        static bool group_equals_equiv(node_pointer n1, node_pointer end1,</a>
<a name="ln4131">          node_pointer n2, node_pointer end2)</a>
<a name="ln4132">        {</a>
<a name="ln4133">          for (;;) {</a>
<a name="ln4134">            if (n1-&gt;value() != n2-&gt;value())</a>
<a name="ln4135">              break;</a>
<a name="ln4136"> </a>
<a name="ln4137">            n1 = next_node(n1);</a>
<a name="ln4138">            n2 = next_node(n2);</a>
<a name="ln4139"> </a>
<a name="ln4140">            if (n1 == end1)</a>
<a name="ln4141">              return n2 == end2;</a>
<a name="ln4142">            if (n2 == end2)</a>
<a name="ln4143">              return false;</a>
<a name="ln4144">          }</a>
<a name="ln4145"> </a>
<a name="ln4146">          for (node_pointer n1a = n1, n2a = n2;;) {</a>
<a name="ln4147">            n1a = next_node(n1a);</a>
<a name="ln4148">            n2a = next_node(n2a);</a>
<a name="ln4149"> </a>
<a name="ln4150">            if (n1a == end1) {</a>
<a name="ln4151">              if (n2a == end2)</a>
<a name="ln4152">                break;</a>
<a name="ln4153">              else</a>
<a name="ln4154">                return false;</a>
<a name="ln4155">            }</a>
<a name="ln4156"> </a>
<a name="ln4157">            if (n2a == end2)</a>
<a name="ln4158">              return false;</a>
<a name="ln4159">          }</a>
<a name="ln4160"> </a>
<a name="ln4161">          node_pointer start = n1;</a>
<a name="ln4162">          for (; n1 != end1; n1 = next_node(n1)) {</a>
<a name="ln4163">            value_type const&amp; v = n1-&gt;value();</a>
<a name="ln4164">            if (!find_equiv(start, n1, v)) {</a>
<a name="ln4165">              std::size_t matches = count_equal_equiv(n2, end2, v);</a>
<a name="ln4166">              if (!matches)</a>
<a name="ln4167">                return false;</a>
<a name="ln4168">              if (matches != 1 + count_equal_equiv(next_node(n1), end1, v))</a>
<a name="ln4169">                return false;</a>
<a name="ln4170">            }</a>
<a name="ln4171">          }</a>
<a name="ln4172"> </a>
<a name="ln4173">          return true;</a>
<a name="ln4174">        }</a>
<a name="ln4175"> </a>
<a name="ln4176">        static bool find_equiv(</a>
<a name="ln4177">          node_pointer n, node_pointer end, value_type const&amp; v)</a>
<a name="ln4178">        {</a>
<a name="ln4179">          for (; n != end; n = next_node(n))</a>
<a name="ln4180">            if (n-&gt;value() == v)</a>
<a name="ln4181">              return true;</a>
<a name="ln4182">          return false;</a>
<a name="ln4183">        }</a>
<a name="ln4184"> </a>
<a name="ln4185">        static std::size_t count_equal_equiv(</a>
<a name="ln4186">          node_pointer n, node_pointer end, value_type const&amp; v)</a>
<a name="ln4187">        {</a>
<a name="ln4188">          std::size_t count = 0;</a>
<a name="ln4189">          for (; n != end; n = next_node(n))</a>
<a name="ln4190">            if (n-&gt;value() == v)</a>
<a name="ln4191">              ++count;</a>
<a name="ln4192">          return count;</a>
<a name="ln4193">        }</a>
<a name="ln4194"> </a>
<a name="ln4195">        // Emplace/Insert</a>
<a name="ln4196"> </a>
<a name="ln4197">        inline node_pointer add_node_equiv(</a>
<a name="ln4198">          node_pointer n, std::size_t key_hash, node_pointer pos)</a>
<a name="ln4199">        {</a>
<a name="ln4200">          std::size_t bucket_index = this-&gt;hash_to_bucket(key_hash);</a>
<a name="ln4201">          n-&gt;bucket_info_ = bucket_index;</a>
<a name="ln4202"> </a>
<a name="ln4203">          if (pos) {</a>
<a name="ln4204">            n-&gt;reset_first_in_group();</a>
<a name="ln4205">            n-&gt;next_ = pos-&gt;next_;</a>
<a name="ln4206">            pos-&gt;next_ = n;</a>
<a name="ln4207">            if (n-&gt;next_) {</a>
<a name="ln4208">              std::size_t next_bucket = this-&gt;node_bucket(next_node(n));</a>
<a name="ln4209">              if (next_bucket != bucket_index) {</a>
<a name="ln4210">                this-&gt;get_bucket_pointer(next_bucket)-&gt;next_ = n;</a>
<a name="ln4211">              }</a>
<a name="ln4212">            }</a>
<a name="ln4213">          } else {</a>
<a name="ln4214">            n-&gt;set_first_in_group();</a>
<a name="ln4215">            bucket_pointer b = this-&gt;get_bucket_pointer(bucket_index);</a>
<a name="ln4216"> </a>
<a name="ln4217">            if (!b-&gt;next_) {</a>
<a name="ln4218">              link_pointer start_node = this-&gt;get_previous_start();</a>
<a name="ln4219"> </a>
<a name="ln4220">              if (start_node-&gt;next_) {</a>
<a name="ln4221">                this</a>
<a name="ln4222">                  -&gt;get_bucket_pointer(this-&gt;node_bucket(next_node(start_node)))</a>
<a name="ln4223">                  -&gt;next_ = n;</a>
<a name="ln4224">              }</a>
<a name="ln4225"> </a>
<a name="ln4226">              b-&gt;next_ = start_node;</a>
<a name="ln4227">              n-&gt;next_ = start_node-&gt;next_;</a>
<a name="ln4228">              start_node-&gt;next_ = n;</a>
<a name="ln4229">            } else {</a>
<a name="ln4230">              n-&gt;next_ = b-&gt;next_-&gt;next_;</a>
<a name="ln4231">              b-&gt;next_-&gt;next_ = n;</a>
<a name="ln4232">            }</a>
<a name="ln4233">          }</a>
<a name="ln4234">          ++this-&gt;size_;</a>
<a name="ln4235">          return n;</a>
<a name="ln4236">        }</a>
<a name="ln4237"> </a>
<a name="ln4238">        inline node_pointer add_using_hint_equiv(</a>
<a name="ln4239">          node_pointer n, node_pointer hint)</a>
<a name="ln4240">        {</a>
<a name="ln4241">          n-&gt;bucket_info_ = hint-&gt;bucket_info_;</a>
<a name="ln4242">          n-&gt;reset_first_in_group();</a>
<a name="ln4243">          n-&gt;next_ = hint-&gt;next_;</a>
<a name="ln4244">          hint-&gt;next_ = n;</a>
<a name="ln4245">          if (n-&gt;next_) {</a>
<a name="ln4246">            std::size_t next_bucket = this-&gt;node_bucket(next_node(n));</a>
<a name="ln4247">            if (next_bucket != this-&gt;node_bucket(n)) {</a>
<a name="ln4248">              this-&gt;get_bucket_pointer(next_bucket)-&gt;next_ = n;</a>
<a name="ln4249">            }</a>
<a name="ln4250">          }</a>
<a name="ln4251">          ++this-&gt;size_;</a>
<a name="ln4252">          return n;</a>
<a name="ln4253">        }</a>
<a name="ln4254"> </a>
<a name="ln4255">        iterator emplace_equiv(node_pointer n)</a>
<a name="ln4256">        {</a>
<a name="ln4257">          node_tmp a(n, this-&gt;node_alloc());</a>
<a name="ln4258">          const_key_type&amp; k = this-&gt;get_key(a.node_);</a>
<a name="ln4259">          std::size_t key_hash = this-&gt;hash(k);</a>
<a name="ln4260">          node_pointer position = this-&gt;find_node(key_hash, k);</a>
<a name="ln4261">          this-&gt;reserve_for_insert(this-&gt;size_ + 1);</a>
<a name="ln4262">          return iterator(</a>
<a name="ln4263">            this-&gt;add_node_equiv(a.release(), key_hash, position));</a>
<a name="ln4264">        }</a>
<a name="ln4265"> </a>
<a name="ln4266">        iterator emplace_hint_equiv(c_iterator hint, node_pointer n)</a>
<a name="ln4267">        {</a>
<a name="ln4268">          node_tmp a(n, this-&gt;node_alloc());</a>
<a name="ln4269">          const_key_type&amp; k = this-&gt;get_key(a.node_);</a>
<a name="ln4270">          if (hint.node_ &amp;&amp; this-&gt;key_eq()(k, this-&gt;get_key(hint.node_))) {</a>
<a name="ln4271">            this-&gt;reserve_for_insert(this-&gt;size_ + 1);</a>
<a name="ln4272">            return iterator(</a>
<a name="ln4273">              this-&gt;add_using_hint_equiv(a.release(), hint.node_));</a>
<a name="ln4274">          } else {</a>
<a name="ln4275">            std::size_t key_hash = this-&gt;hash(k);</a>
<a name="ln4276">            node_pointer position = this-&gt;find_node(key_hash, k);</a>
<a name="ln4277">            this-&gt;reserve_for_insert(this-&gt;size_ + 1);</a>
<a name="ln4278">            return iterator(</a>
<a name="ln4279">              this-&gt;add_node_equiv(a.release(), key_hash, position));</a>
<a name="ln4280">          }</a>
<a name="ln4281">        }</a>
<a name="ln4282"> </a>
<a name="ln4283">        void emplace_no_rehash_equiv(node_pointer n)</a>
<a name="ln4284">        {</a>
<a name="ln4285">          node_tmp a(n, this-&gt;node_alloc());</a>
<a name="ln4286">          const_key_type&amp; k = this-&gt;get_key(a.node_);</a>
<a name="ln4287">          std::size_t key_hash = this-&gt;hash(k);</a>
<a name="ln4288">          node_pointer position = this-&gt;find_node(key_hash, k);</a>
<a name="ln4289">          this-&gt;add_node_equiv(a.release(), key_hash, position);</a>
<a name="ln4290">        }</a>
<a name="ln4291"> </a>
<a name="ln4292">        template &lt;typename NodeType&gt;</a>
<a name="ln4293">        iterator move_insert_node_type_equiv(NodeType&amp; np)</a>
<a name="ln4294">        {</a>
<a name="ln4295">          iterator result;</a>
<a name="ln4296"> </a>
<a name="ln4297">          if (np) {</a>
<a name="ln4298">            const_key_type&amp; k = this-&gt;get_key(np.ptr_);</a>
<a name="ln4299">            std::size_t key_hash = this-&gt;hash(k);</a>
<a name="ln4300">            node_pointer pos = this-&gt;find_node(key_hash, k);</a>
<a name="ln4301">            this-&gt;reserve_for_insert(this-&gt;size_ + 1);</a>
<a name="ln4302">            result = iterator(this-&gt;add_node_equiv(np.ptr_, key_hash, pos));</a>
<a name="ln4303">            np.ptr_ = node_pointer();</a>
<a name="ln4304">          }</a>
<a name="ln4305"> </a>
<a name="ln4306">          return result;</a>
<a name="ln4307">        }</a>
<a name="ln4308"> </a>
<a name="ln4309">        template &lt;typename NodeType&gt;</a>
<a name="ln4310">        iterator move_insert_node_type_with_hint_equiv(</a>
<a name="ln4311">          c_iterator hint, NodeType&amp; np)</a>
<a name="ln4312">        {</a>
<a name="ln4313">          iterator result;</a>
<a name="ln4314"> </a>
<a name="ln4315">          if (np) {</a>
<a name="ln4316">            const_key_type&amp; k = this-&gt;get_key(np.ptr_);</a>
<a name="ln4317"> </a>
<a name="ln4318">            if (hint.node_ &amp;&amp; this-&gt;key_eq()(k, this-&gt;get_key(hint.node_))) {</a>
<a name="ln4319">              this-&gt;reserve_for_insert(this-&gt;size_ + 1);</a>
<a name="ln4320">              result =</a>
<a name="ln4321">                iterator(this-&gt;add_using_hint_equiv(np.ptr_, hint.node_));</a>
<a name="ln4322">            } else {</a>
<a name="ln4323">              std::size_t key_hash = this-&gt;hash(k);</a>
<a name="ln4324">              node_pointer pos = this-&gt;find_node(key_hash, k);</a>
<a name="ln4325">              this-&gt;reserve_for_insert(this-&gt;size_ + 1);</a>
<a name="ln4326">              result = iterator(this-&gt;add_node_equiv(np.ptr_, key_hash, pos));</a>
<a name="ln4327">            }</a>
<a name="ln4328">            np.ptr_ = node_pointer();</a>
<a name="ln4329">          }</a>
<a name="ln4330"> </a>
<a name="ln4331">          return result;</a>
<a name="ln4332">        }</a>
<a name="ln4333"> </a>
<a name="ln4334">        ////////////////////////////////////////////////////////////////////////</a>
<a name="ln4335">        // Insert range methods</a>
<a name="ln4336"> </a>
<a name="ln4337">        // if hash function throws, or inserting &gt; 1 element, basic exception</a>
<a name="ln4338">        // safety. Strong otherwise</a>
<a name="ln4339">        template &lt;class I&gt;</a>
<a name="ln4340">        void insert_range_equiv(I i, I j,</a>
<a name="ln4341">          typename boost::unordered::detail::enable_if_forward&lt;I, void*&gt;::type =</a>
<a name="ln4342">            0)</a>
<a name="ln4343">        {</a>
<a name="ln4344">          if (i == j)</a>
<a name="ln4345">            return;</a>
<a name="ln4346"> </a>
<a name="ln4347">          std::size_t distance = static_cast&lt;std::size_t&gt;(std::distance(i, j));</a>
<a name="ln4348">          if (distance == 1) {</a>
<a name="ln4349">            emplace_equiv(boost::unordered::detail::func::construct_node(</a>
<a name="ln4350">              this-&gt;node_alloc(), *i));</a>
<a name="ln4351">          } else {</a>
<a name="ln4352">            // Only require basic exception safety here</a>
<a name="ln4353">            this-&gt;reserve_for_insert(this-&gt;size_ + distance);</a>
<a name="ln4354"> </a>
<a name="ln4355">            for (; i != j; ++i) {</a>
<a name="ln4356">              emplace_no_rehash_equiv(</a>
<a name="ln4357">                boost::unordered::detail::func::construct_node(</a>
<a name="ln4358">                  this-&gt;node_alloc(), *i));</a>
<a name="ln4359">            }</a>
<a name="ln4360">          }</a>
<a name="ln4361">        }</a>
<a name="ln4362"> </a>
<a name="ln4363">        template &lt;class I&gt;</a>
<a name="ln4364">        void insert_range_equiv(I i, I j,</a>
<a name="ln4365">          typename boost::unordered::detail::disable_if_forward&lt;I,</a>
<a name="ln4366">            void*&gt;::type = 0)</a>
<a name="ln4367">        {</a>
<a name="ln4368">          for (; i != j; ++i) {</a>
<a name="ln4369">            emplace_equiv(boost::unordered::detail::func::construct_node(</a>
<a name="ln4370">              this-&gt;node_alloc(), *i));</a>
<a name="ln4371">          }</a>
<a name="ln4372">        }</a>
<a name="ln4373"> </a>
<a name="ln4374">        ////////////////////////////////////////////////////////////////////////</a>
<a name="ln4375">        // Extract</a>
<a name="ln4376"> </a>
<a name="ln4377">        inline node_pointer extract_by_iterator_equiv(c_iterator n)</a>
<a name="ln4378">        {</a>
<a name="ln4379">          node_pointer i = n.node_;</a>
<a name="ln4380">          BOOST_ASSERT(i);</a>
<a name="ln4381">          node_pointer j(next_node(i));</a>
<a name="ln4382">          std::size_t bucket_index = this-&gt;node_bucket(i);</a>
<a name="ln4383"> </a>
<a name="ln4384">          link_pointer prev = this-&gt;get_previous_start(bucket_index);</a>
<a name="ln4385">          while (prev-&gt;next_ != i) {</a>
<a name="ln4386">            prev = next_node(prev);</a>
<a name="ln4387">          }</a>
<a name="ln4388"> </a>
<a name="ln4389">          prev-&gt;next_ = j;</a>
<a name="ln4390">          if (j &amp;&amp; i-&gt;is_first_in_group()) {</a>
<a name="ln4391">            j-&gt;set_first_in_group();</a>
<a name="ln4392">          }</a>
<a name="ln4393">          --this-&gt;size_;</a>
<a name="ln4394">          this-&gt;fix_bucket(bucket_index, prev, j);</a>
<a name="ln4395">          i-&gt;next_ = link_pointer();</a>
<a name="ln4396"> </a>
<a name="ln4397">          return i;</a>
<a name="ln4398">        }</a>
<a name="ln4399"> </a>
<a name="ln4400">        ////////////////////////////////////////////////////////////////////////</a>
<a name="ln4401">        // Erase</a>
<a name="ln4402">        //</a>
<a name="ln4403">        // no throw</a>
<a name="ln4404"> </a>
<a name="ln4405">        std::size_t erase_key_equiv(const_key_type&amp; k)</a>
<a name="ln4406">        {</a>
<a name="ln4407">          if (!this-&gt;size_)</a>
<a name="ln4408">            return 0;</a>
<a name="ln4409"> </a>
<a name="ln4410">          std::size_t key_hash = this-&gt;hash(k);</a>
<a name="ln4411">          std::size_t bucket_index = this-&gt;hash_to_bucket(key_hash);</a>
<a name="ln4412">          link_pointer prev = this-&gt;find_previous_node(k, bucket_index);</a>
<a name="ln4413">          if (!prev)</a>
<a name="ln4414">            return 0;</a>
<a name="ln4415"> </a>
<a name="ln4416">          std::size_t deleted_count = 0;</a>
<a name="ln4417">          node_pointer n = next_node(prev);</a>
<a name="ln4418">          do {</a>
<a name="ln4419">            node_pointer n2 = next_node(n);</a>
<a name="ln4420">            destroy_node(n);</a>
<a name="ln4421">            ++deleted_count;</a>
<a name="ln4422">            n = n2;</a>
<a name="ln4423">          } while (n &amp;&amp; !n-&gt;is_first_in_group());</a>
<a name="ln4424">          size_ -= deleted_count;</a>
<a name="ln4425">          prev-&gt;next_ = n;</a>
<a name="ln4426">          this-&gt;fix_bucket(bucket_index, prev, n);</a>
<a name="ln4427">          return deleted_count;</a>
<a name="ln4428">        }</a>
<a name="ln4429"> </a>
<a name="ln4430">        link_pointer erase_nodes_equiv(node_pointer i, node_pointer j)</a>
<a name="ln4431">        {</a>
<a name="ln4432">          std::size_t bucket_index = this-&gt;node_bucket(i);</a>
<a name="ln4433"> </a>
<a name="ln4434">          link_pointer prev = this-&gt;get_previous_start(bucket_index);</a>
<a name="ln4435">          while (prev-&gt;next_ != i) {</a>
<a name="ln4436">            prev = next_node(prev);</a>
<a name="ln4437">          }</a>
<a name="ln4438"> </a>
<a name="ln4439">          // Delete the nodes.</a>
<a name="ln4440">          // Is it inefficient to call fix_bucket for every node?</a>
<a name="ln4441">          bool includes_first = false;</a>
<a name="ln4442">          prev-&gt;next_ = j;</a>
<a name="ln4443">          do {</a>
<a name="ln4444">            includes_first = includes_first || i-&gt;is_first_in_group();</a>
<a name="ln4445">            node_pointer next = next_node(i);</a>
<a name="ln4446">            destroy_node(i);</a>
<a name="ln4447">            --size_;</a>
<a name="ln4448">            bucket_index = this-&gt;fix_bucket(bucket_index, prev, next);</a>
<a name="ln4449">            i = next;</a>
<a name="ln4450">          } while (i != j);</a>
<a name="ln4451">          if (j &amp;&amp; includes_first) {</a>
<a name="ln4452">            j-&gt;set_first_in_group();</a>
<a name="ln4453">          }</a>
<a name="ln4454"> </a>
<a name="ln4455">          return prev;</a>
<a name="ln4456">        }</a>
<a name="ln4457"> </a>
<a name="ln4458">        ////////////////////////////////////////////////////////////////////////</a>
<a name="ln4459">        // fill_buckets</a>
<a name="ln4460"> </a>
<a name="ln4461">        void copy_buckets(table const&amp; src, false_type)</a>
<a name="ln4462">        {</a>
<a name="ln4463">          this-&gt;create_buckets(this-&gt;bucket_count_);</a>
<a name="ln4464"> </a>
<a name="ln4465">          for (node_pointer n = src.begin(); n;) {</a>
<a name="ln4466">            std::size_t key_hash = this-&gt;hash(this-&gt;get_key(n));</a>
<a name="ln4467">            node_pointer group_end(next_group(n));</a>
<a name="ln4468">            node_pointer pos = this-&gt;add_node_equiv(</a>
<a name="ln4469">              boost::unordered::detail::func::construct_node(</a>
<a name="ln4470">                this-&gt;node_alloc(), n-&gt;value()),</a>
<a name="ln4471">              key_hash, node_pointer());</a>
<a name="ln4472">            for (n = next_node(n); n != group_end; n = next_node(n)) {</a>
<a name="ln4473">              this-&gt;add_node_equiv(</a>
<a name="ln4474">                boost::unordered::detail::func::construct_node(</a>
<a name="ln4475">                  this-&gt;node_alloc(), n-&gt;value()),</a>
<a name="ln4476">                key_hash, pos);</a>
<a name="ln4477">            }</a>
<a name="ln4478">          }</a>
<a name="ln4479">        }</a>
<a name="ln4480"> </a>
<a name="ln4481">        void assign_buckets(table const&amp; src, false_type)</a>
<a name="ln4482">        {</a>
<a name="ln4483">          node_holder&lt;node_allocator&gt; holder(*this);</a>
<a name="ln4484">          for (node_pointer n = src.begin(); n;) {</a>
<a name="ln4485">            std::size_t key_hash = this-&gt;hash(this-&gt;get_key(n));</a>
<a name="ln4486">            node_pointer group_end(next_group(n));</a>
<a name="ln4487">            node_pointer pos = this-&gt;add_node_equiv(</a>
<a name="ln4488">              holder.copy_of(n-&gt;value()), key_hash, node_pointer());</a>
<a name="ln4489">            for (n = next_node(n); n != group_end; n = next_node(n)) {</a>
<a name="ln4490">              this-&gt;add_node_equiv(holder.copy_of(n-&gt;value()), key_hash, pos);</a>
<a name="ln4491">            }</a>
<a name="ln4492">          }</a>
<a name="ln4493">        }</a>
<a name="ln4494"> </a>
<a name="ln4495">        void move_assign_buckets(table&amp; src, false_type)</a>
<a name="ln4496">        {</a>
<a name="ln4497">          node_holder&lt;node_allocator&gt; holder(*this);</a>
<a name="ln4498">          for (node_pointer n = src.begin(); n;) {</a>
<a name="ln4499">            std::size_t key_hash = this-&gt;hash(this-&gt;get_key(n));</a>
<a name="ln4500">            node_pointer group_end(next_group(n));</a>
<a name="ln4501">            node_pointer pos = this-&gt;add_node_equiv(</a>
<a name="ln4502">              holder.move_copy_of(n-&gt;value()), key_hash, node_pointer());</a>
<a name="ln4503">            for (n = next_node(n); n != group_end; n = next_node(n)) {</a>
<a name="ln4504">              this-&gt;add_node_equiv(</a>
<a name="ln4505">                holder.move_copy_of(n-&gt;value()), key_hash, pos);</a>
<a name="ln4506">            }</a>
<a name="ln4507">          }</a>
<a name="ln4508">        }</a>
<a name="ln4509">      };</a>
<a name="ln4510"> </a>
<a name="ln4511">      //////////////////////////////////////////////////////////////////////////</a>
<a name="ln4512">      // Clear</a>
<a name="ln4513"> </a>
<a name="ln4514">      template &lt;typename Types&gt; inline void table&lt;Types&gt;::clear_impl()</a>
<a name="ln4515">      {</a>
<a name="ln4516">        if (size_) {</a>
<a name="ln4517">          bucket_pointer end = get_bucket_pointer(bucket_count_);</a>
<a name="ln4518">          for (bucket_pointer it = buckets_; it != end; ++it) {</a>
<a name="ln4519">            it-&gt;next_ = node_pointer();</a>
<a name="ln4520">          }</a>
<a name="ln4521"> </a>
<a name="ln4522">          link_pointer prev = end-&gt;first_from_start();</a>
<a name="ln4523">          node_pointer n = next_node(prev);</a>
<a name="ln4524">          prev-&gt;next_ = node_pointer();</a>
<a name="ln4525">          size_ = 0;</a>
<a name="ln4526"> </a>
<a name="ln4527">          while (n) {</a>
<a name="ln4528">            node_pointer next = next_node(n);</a>
<a name="ln4529">            destroy_node(n);</a>
<a name="ln4530">            n = next;</a>
<a name="ln4531">          }</a>
<a name="ln4532">        }</a>
<a name="ln4533">      }</a>
<a name="ln4534"> </a>
<a name="ln4535">      //////////////////////////////////////////////////////////////////////////</a>
<a name="ln4536">      // Reserve &amp; Rehash</a>
<a name="ln4537"> </a>
<a name="ln4538">      // basic exception safety</a>
<a name="ln4539">      template &lt;typename Types&gt;</a>
<a name="ln4540">      inline void table&lt;Types&gt;::reserve_for_insert(std::size_t size)</a>
<a name="ln4541">      {</a>
<a name="ln4542">        if (!buckets_) {</a>
<a name="ln4543">          create_buckets((std::max)(bucket_count_, min_buckets_for_size(size)));</a>
<a name="ln4544">        } else if (size &gt; max_load_) {</a>
<a name="ln4545">          std::size_t num_buckets =</a>
<a name="ln4546">            min_buckets_for_size((std::max)(size, size_ + (size_ &gt;&gt; 1)));</a>
<a name="ln4547"> </a>
<a name="ln4548">          if (num_buckets != bucket_count_)</a>
<a name="ln4549">            this-&gt;rehash_impl(num_buckets);</a>
<a name="ln4550">        }</a>
<a name="ln4551">      }</a>
<a name="ln4552"> </a>
<a name="ln4553">      // if hash function throws, basic exception safety</a>
<a name="ln4554">      // strong otherwise.</a>
<a name="ln4555"> </a>
<a name="ln4556">      template &lt;typename Types&gt;</a>
<a name="ln4557">      inline void table&lt;Types&gt;::rehash(std::size_t min_buckets)</a>
<a name="ln4558">      {</a>
<a name="ln4559">        using namespace std;</a>
<a name="ln4560"> </a>
<a name="ln4561">        if (!size_) {</a>
<a name="ln4562">          delete_buckets();</a>
<a name="ln4563">          bucket_count_ = policy::new_bucket_count(min_buckets);</a>
<a name="ln4564">        } else {</a>
<a name="ln4565">          min_buckets = policy::new_bucket_count((std::max)(min_buckets,</a>
<a name="ln4566">            boost::unordered::detail::double_to_size(</a>
<a name="ln4567">              floor(static_cast&lt;double&gt;(size_) / static_cast&lt;double&gt;(mlf_))) +</a>
<a name="ln4568">              1));</a>
<a name="ln4569"> </a>
<a name="ln4570">          if (min_buckets != bucket_count_)</a>
<a name="ln4571">            this-&gt;rehash_impl(min_buckets);</a>
<a name="ln4572">        }</a>
<a name="ln4573">      }</a>
<a name="ln4574"> </a>
<a name="ln4575">      template &lt;typename Types&gt;</a>
<a name="ln4576">      inline void table&lt;Types&gt;::rehash_impl(std::size_t num_buckets)</a>
<a name="ln4577">      {</a>
<a name="ln4578">        BOOST_ASSERT(this-&gt;buckets_);</a>
<a name="ln4579"> </a>
<a name="ln4580">        this-&gt;create_buckets(num_buckets);</a>
<a name="ln4581">        link_pointer prev = this-&gt;get_previous_start();</a>
<a name="ln4582">        BOOST_TRY</a>
<a name="ln4583">        {</a>
<a name="ln4584">          while (prev-&gt;next_) {</a>
<a name="ln4585">            node_pointer n = next_node(prev);</a>
<a name="ln4586">            std::size_t key_hash = this-&gt;hash(this-&gt;get_key(n));</a>
<a name="ln4587">            std::size_t bucket_index = this-&gt;hash_to_bucket(key_hash);</a>
<a name="ln4588"> </a>
<a name="ln4589">            n-&gt;bucket_info_ = bucket_index;</a>
<a name="ln4590">            n-&gt;set_first_in_group();</a>
<a name="ln4591"> </a>
<a name="ln4592">            // Iterator through the rest of the group of equal nodes,</a>
<a name="ln4593">            // setting the bucket.</a>
<a name="ln4594">            for (;;) {</a>
<a name="ln4595">              node_pointer next = next_node(n);</a>
<a name="ln4596">              if (!next || next-&gt;is_first_in_group()) {</a>
<a name="ln4597">                break;</a>
<a name="ln4598">              }</a>
<a name="ln4599">              n = next;</a>
<a name="ln4600">              n-&gt;bucket_info_ = bucket_index;</a>
<a name="ln4601">              n-&gt;reset_first_in_group();</a>
<a name="ln4602">            }</a>
<a name="ln4603"> </a>
<a name="ln4604">            // n is now the last node in the group</a>
<a name="ln4605">            bucket_pointer b = this-&gt;get_bucket_pointer(bucket_index);</a>
<a name="ln4606">            if (!b-&gt;next_) {</a>
<a name="ln4607">              b-&gt;next_ = prev;</a>
<a name="ln4608">              prev = n;</a>
<a name="ln4609">            } else {</a>
<a name="ln4610">              link_pointer next = n-&gt;next_;</a>
<a name="ln4611">              n-&gt;next_ = b-&gt;next_-&gt;next_;</a>
<a name="ln4612">              b-&gt;next_-&gt;next_ = prev-&gt;next_;</a>
<a name="ln4613">              prev-&gt;next_ = next;</a>
<a name="ln4614">            }</a>
<a name="ln4615">          }</a>
<a name="ln4616">        }</a>
<a name="ln4617">        BOOST_CATCH(...)</a>
<a name="ln4618">        {</a>
<a name="ln4619">          node_pointer n = next_node(prev);</a>
<a name="ln4620">          prev-&gt;next_ = node_pointer();</a>
<a name="ln4621">          while (n) {</a>
<a name="ln4622">            node_pointer next = next_node(n);</a>
<a name="ln4623">            destroy_node(n);</a>
<a name="ln4624">            --size_;</a>
<a name="ln4625">            n = next;</a>
<a name="ln4626">          }</a>
<a name="ln4627">          BOOST_RETHROW</a>
<a name="ln4628">        }</a>
<a name="ln4629">        BOOST_CATCH_END</a>
<a name="ln4630">      }</a>
<a name="ln4631"> </a>
<a name="ln4632">#if defined(BOOST_MSVC)</a>
<a name="ln4633">#pragma warning(pop)</a>
<a name="ln4634">#endif</a>
<a name="ln4635"> </a>
<a name="ln4636">      ////////////////////////////////////////////////////////////////////////</a>
<a name="ln4637">      // key extractors</a>
<a name="ln4638">      //</a>
<a name="ln4639">      // no throw</a>
<a name="ln4640">      //</a>
<a name="ln4641">      // 'extract_key' is called with the emplace parameters to return a</a>
<a name="ln4642">      // key if available or 'no_key' is one isn't and will need to be</a>
<a name="ln4643">      // constructed. This could be done by overloading the emplace</a>
<a name="ln4644">      // implementation</a>
<a name="ln4645">      // for the different cases, but that's a bit tricky on compilers without</a>
<a name="ln4646">      // variadic templates.</a>
<a name="ln4647"> </a>
<a name="ln4648">      template &lt;typename Key, typename T&gt; struct is_key</a>
<a name="ln4649">      {</a>
<a name="ln4650">        template &lt;typename T2&gt; static choice1::type test(T2 const&amp;);</a>
<a name="ln4651">        static choice2::type test(Key const&amp;);</a>
<a name="ln4652"> </a>
<a name="ln4653">        enum</a>
<a name="ln4654">        {</a>
<a name="ln4655">          value = sizeof(test(boost::unordered::detail::make&lt;T&gt;())) ==</a>
<a name="ln4656">                  sizeof(choice2::type)</a>
<a name="ln4657">        };</a>
<a name="ln4658"> </a>
<a name="ln4659">        typedef typename boost::detail::if_true&lt;value&gt;::BOOST_NESTED_TEMPLATE</a>
<a name="ln4660">          then&lt;Key const&amp;, no_key&gt;::type type;</a>
<a name="ln4661">      };</a>
<a name="ln4662"> </a>
<a name="ln4663">      template &lt;class ValueType&gt; struct set_extractor</a>
<a name="ln4664">      {</a>
<a name="ln4665">        typedef ValueType value_type;</a>
<a name="ln4666">        typedef ValueType key_type;</a>
<a name="ln4667"> </a>
<a name="ln4668">        static key_type const&amp; extract(value_type const&amp; v) { return v; }</a>
<a name="ln4669"> </a>
<a name="ln4670">        static key_type const&amp; extract(BOOST_UNORDERED_RV_REF(value_type) v)</a>
<a name="ln4671">        {</a>
<a name="ln4672">          return v;</a>
<a name="ln4673">        }</a>
<a name="ln4674"> </a>
<a name="ln4675">        static no_key extract() { return no_key(); }</a>
<a name="ln4676"> </a>
<a name="ln4677">        template &lt;class Arg&gt; static no_key extract(Arg const&amp;)</a>
<a name="ln4678">        {</a>
<a name="ln4679">          return no_key();</a>
<a name="ln4680">        }</a>
<a name="ln4681"> </a>
<a name="ln4682">#if !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES)</a>
<a name="ln4683">        template &lt;class Arg1, class Arg2, class... Args&gt;</a>
<a name="ln4684">        static no_key extract(Arg1 const&amp;, Arg2 const&amp;, Args const&amp;...)</a>
<a name="ln4685">        {</a>
<a name="ln4686">          return no_key();</a>
<a name="ln4687">        }</a>
<a name="ln4688">#else</a>
<a name="ln4689">        template &lt;class Arg1, class Arg2&gt;</a>
<a name="ln4690">        static no_key extract(Arg1 const&amp;, Arg2 const&amp;)</a>
<a name="ln4691">        {</a>
<a name="ln4692">          return no_key();</a>
<a name="ln4693">        }</a>
<a name="ln4694">#endif</a>
<a name="ln4695">      };</a>
<a name="ln4696"> </a>
<a name="ln4697">      template &lt;class ValueType&gt; struct map_extractor</a>
<a name="ln4698">      {</a>
<a name="ln4699">        typedef ValueType value_type;</a>
<a name="ln4700">        typedef typename boost::remove_const&lt;typename boost::unordered::detail::</a>
<a name="ln4701">            pair_traits&lt;ValueType&gt;::first_type&gt;::type key_type;</a>
<a name="ln4702"> </a>
<a name="ln4703">        static key_type const&amp; extract(value_type const&amp; v) { return v.first; }</a>
<a name="ln4704"> </a>
<a name="ln4705">        template &lt;class Second&gt;</a>
<a name="ln4706">        static key_type const&amp; extract(std::pair&lt;key_type, Second&gt; const&amp; v)</a>
<a name="ln4707">        {</a>
<a name="ln4708">          return v.first;</a>
<a name="ln4709">        }</a>
<a name="ln4710"> </a>
<a name="ln4711">        template &lt;class Second&gt;</a>
<a name="ln4712">        static key_type const&amp; extract(</a>
<a name="ln4713">          std::pair&lt;key_type const, Second&gt; const&amp; v)</a>
<a name="ln4714">        {</a>
<a name="ln4715">          return v.first;</a>
<a name="ln4716">        }</a>
<a name="ln4717"> </a>
<a name="ln4718">#if defined(BOOST_NO_CXX11_RVALUE_REFERENCES)</a>
<a name="ln4719">        template &lt;class Second&gt;</a>
<a name="ln4720">        static key_type const&amp; extract(</a>
<a name="ln4721">          boost::rv&lt;std::pair&lt;key_type, Second&gt; &gt; const&amp; v)</a>
<a name="ln4722">        {</a>
<a name="ln4723">          return v.first;</a>
<a name="ln4724">        }</a>
<a name="ln4725"> </a>
<a name="ln4726">        template &lt;class Second&gt;</a>
<a name="ln4727">        static key_type const&amp; extract(</a>
<a name="ln4728">          boost::rv&lt;std::pair&lt;key_type const, Second&gt; &gt; const&amp; v)</a>
<a name="ln4729">        {</a>
<a name="ln4730">          return v.first;</a>
<a name="ln4731">        }</a>
<a name="ln4732">#endif</a>
<a name="ln4733"> </a>
<a name="ln4734">        template &lt;class Arg1&gt;</a>
<a name="ln4735">        static key_type const&amp; extract(key_type const&amp; k, Arg1 const&amp;)</a>
<a name="ln4736">        {</a>
<a name="ln4737">          return k;</a>
<a name="ln4738">        }</a>
<a name="ln4739"> </a>
<a name="ln4740">        static no_key extract() { return no_key(); }</a>
<a name="ln4741"> </a>
<a name="ln4742">        template &lt;class Arg&gt; static no_key extract(Arg const&amp;)</a>
<a name="ln4743">        {</a>
<a name="ln4744">          return no_key();</a>
<a name="ln4745">        }</a>
<a name="ln4746"> </a>
<a name="ln4747">        template &lt;class Arg1, class Arg2&gt;</a>
<a name="ln4748">        static no_key extract(Arg1 const&amp;, Arg2 const&amp;)</a>
<a name="ln4749">        {</a>
<a name="ln4750">          return no_key();</a>
<a name="ln4751">        }</a>
<a name="ln4752"> </a>
<a name="ln4753">#if !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES)</a>
<a name="ln4754">        template &lt;class Arg1, class Arg2, class Arg3, class... Args&gt;</a>
<a name="ln4755">        static no_key extract(</a>
<a name="ln4756">          Arg1 const&amp;, Arg2 const&amp;, Arg3 const&amp;, Args const&amp;...)</a>
<a name="ln4757">        {</a>
<a name="ln4758">          return no_key();</a>
<a name="ln4759">        }</a>
<a name="ln4760">#endif</a>
<a name="ln4761"> </a>
<a name="ln4762">#if !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES)</a>
<a name="ln4763"> </a>
<a name="ln4764">#define BOOST_UNORDERED_KEY_FROM_TUPLE(namespace_)                             \</a>
<a name="ln4765">  template &lt;typename T2&gt;                                                       \</a>
<a name="ln4766">  static no_key extract(boost::unordered::piecewise_construct_t,               \</a>
<a name="ln4767">    namespace_ tuple&lt;&gt; const&amp;, T2 const&amp;)                                      \</a>
<a name="ln4768">  {                                                                            \</a>
<a name="ln4769">    return no_key();                                                           \</a>
<a name="ln4770">  }                                                                            \</a>
<a name="ln4771">                                                                               \</a>
<a name="ln4772">  template &lt;typename T, typename T2&gt;                                           \</a>
<a name="ln4773">  static typename is_key&lt;key_type, T&gt;::type extract(                           \</a>
<a name="ln4774">    boost::unordered::piecewise_construct_t, namespace_ tuple&lt;T&gt; const&amp; k,     \</a>
<a name="ln4775">    T2 const&amp;)                                                                 \</a>
<a name="ln4776">  {                                                                            \</a>
<a name="ln4777">    return typename is_key&lt;key_type, T&gt;::type(namespace_ get&lt;0&gt;(k));           \</a>
<a name="ln4778">  }</a>
<a name="ln4779"> </a>
<a name="ln4780">#else</a>
<a name="ln4781"> </a>
<a name="ln4782">#define BOOST_UNORDERED_KEY_FROM_TUPLE(namespace_)                             \</a>
<a name="ln4783">  static no_key extract(                                                       \</a>
<a name="ln4784">    boost::unordered::piecewise_construct_t, namespace_ tuple&lt;&gt; const&amp;)        \</a>
<a name="ln4785">  {                                                                            \</a>
<a name="ln4786">    return no_key();                                                           \</a>
<a name="ln4787">  }                                                                            \</a>
<a name="ln4788">                                                                               \</a>
<a name="ln4789">  template &lt;typename T&gt;                                                        \</a>
<a name="ln4790">  static typename is_key&lt;key_type, T&gt;::type extract(                           \</a>
<a name="ln4791">    boost::unordered::piecewise_construct_t, namespace_ tuple&lt;T&gt; const&amp; k)     \</a>
<a name="ln4792">  {                                                                            \</a>
<a name="ln4793">    return typename is_key&lt;key_type, T&gt;::type(namespace_ get&lt;0&gt;(k));           \</a>
<a name="ln4794">  }</a>
<a name="ln4795"> </a>
<a name="ln4796">#endif</a>
<a name="ln4797"> </a>
<a name="ln4798">        BOOST_UNORDERED_KEY_FROM_TUPLE(boost::)</a>
<a name="ln4799"> </a>
<a name="ln4800">#if BOOST_UNORDERED_TUPLE_ARGS</a>
<a name="ln4801">        BOOST_UNORDERED_KEY_FROM_TUPLE(std::)</a>
<a name="ln4802">#endif</a>
<a name="ln4803"> </a>
<a name="ln4804">#undef BOOST_UNORDERED_KEY_FROM_TUPLE</a>
<a name="ln4805">      };</a>
<a name="ln4806"> </a>
<a name="ln4807">      ////////////////////////////////////////////////////////////////////////</a>
<a name="ln4808">      // Unique nodes</a>
<a name="ln4809"> </a>
<a name="ln4810">      template &lt;typename A, typename T&gt;</a>
<a name="ln4811">      struct node : boost::unordered::detail::value_base&lt;T&gt;</a>
<a name="ln4812">      {</a>
<a name="ln4813">        typedef</a>
<a name="ln4814">          typename ::boost::unordered::detail::rebind_wrap&lt;A, node&lt;A, T&gt; &gt;::type</a>
<a name="ln4815">            allocator;</a>
<a name="ln4816">        typedef typename ::boost::unordered::detail::allocator_traits&lt;</a>
<a name="ln4817">          allocator&gt;::pointer node_pointer;</a>
<a name="ln4818">        typedef node_pointer link_pointer;</a>
<a name="ln4819">        typedef typename ::boost::unordered::detail::rebind_wrap&lt;A,</a>
<a name="ln4820">          bucket&lt;node_pointer&gt; &gt;::type bucket_allocator;</a>
<a name="ln4821">        typedef typename ::boost::unordered::detail::allocator_traits&lt;</a>
<a name="ln4822">          bucket_allocator&gt;::pointer bucket_pointer;</a>
<a name="ln4823"> </a>
<a name="ln4824">        link_pointer next_;</a>
<a name="ln4825">        std::size_t bucket_info_;</a>
<a name="ln4826"> </a>
<a name="ln4827">        node() : next_(), bucket_info_(0) {}</a>
<a name="ln4828"> </a>
<a name="ln4829">        std::size_t get_bucket() const</a>
<a name="ln4830">        {</a>
<a name="ln4831">          return bucket_info_ &amp; ((std::size_t)-1 &gt;&gt; 1);</a>
<a name="ln4832">        }</a>
<a name="ln4833"> </a>
<a name="ln4834">        std::size_t is_first_in_group() const</a>
<a name="ln4835">        {</a>
<a name="ln4836">          return !(bucket_info_ &amp; ~((std::size_t)-1 &gt;&gt; 1));</a>
<a name="ln4837">        }</a>
<a name="ln4838"> </a>
<a name="ln4839">        void set_first_in_group()</a>
<a name="ln4840">        {</a>
<a name="ln4841">          bucket_info_ = bucket_info_ &amp; ((std::size_t)-1 &gt;&gt; 1);</a>
<a name="ln4842">        }</a>
<a name="ln4843"> </a>
<a name="ln4844">        void reset_first_in_group()</a>
<a name="ln4845">        {</a>
<a name="ln4846">          bucket_info_ = bucket_info_ | ~((std::size_t)-1 &gt;&gt; 1);</a>
<a name="ln4847">        }</a>
<a name="ln4848"> </a>
<a name="ln4849">      private:</a>
<a name="ln4850">        node&amp; operator=(node const&amp;);</a>
<a name="ln4851">      };</a>
<a name="ln4852"> </a>
<a name="ln4853">      template &lt;typename T&gt;</a>
<a name="ln4854">      struct ptr_node : boost::unordered::detail::ptr_bucket</a>
<a name="ln4855">      {</a>
<a name="ln4856">        typedef T value_type;</a>
<a name="ln4857">        typedef boost::unordered::detail::ptr_bucket bucket_base;</a>
<a name="ln4858">        typedef ptr_node&lt;T&gt;* node_pointer;</a>
<a name="ln4859">        typedef ptr_bucket* link_pointer;</a>
<a name="ln4860">        typedef ptr_bucket* bucket_pointer;</a>
<a name="ln4861"> </a>
<a name="ln4862">        std::size_t bucket_info_;</a>
<a name="ln4863">        boost::unordered::detail::value_base&lt;T&gt; value_base_;</a>
<a name="ln4864"> </a>
<a name="ln4865">        ptr_node() : bucket_base(), bucket_info_(0) {}</a>
<a name="ln4866"> </a>
<a name="ln4867">        void* address() { return value_base_.address(); }</a>
<a name="ln4868">        value_type&amp; value() { return value_base_.value(); }</a>
<a name="ln4869">        value_type* value_ptr() { return value_base_.value_ptr(); }</a>
<a name="ln4870"> </a>
<a name="ln4871">        std::size_t get_bucket() const</a>
<a name="ln4872">        {</a>
<a name="ln4873">          return bucket_info_ &amp; ((std::size_t)-1 &gt;&gt; 1);</a>
<a name="ln4874">        }</a>
<a name="ln4875"> </a>
<a name="ln4876">        std::size_t is_first_in_group() const</a>
<a name="ln4877">        {</a>
<a name="ln4878">          return !(bucket_info_ &amp; ~((std::size_t)-1 &gt;&gt; 1));</a>
<a name="ln4879">        }</a>
<a name="ln4880"> </a>
<a name="ln4881">        void set_first_in_group()</a>
<a name="ln4882">        {</a>
<a name="ln4883">          bucket_info_ = bucket_info_ &amp; ((std::size_t)-1 &gt;&gt; 1);</a>
<a name="ln4884">        }</a>
<a name="ln4885"> </a>
<a name="ln4886">        void reset_first_in_group()</a>
<a name="ln4887">        {</a>
<a name="ln4888">          bucket_info_ = bucket_info_ | ~((std::size_t)-1 &gt;&gt; 1);</a>
<a name="ln4889">        }</a>
<a name="ln4890"> </a>
<a name="ln4891">      private:</a>
<a name="ln4892">        ptr_node&amp; operator=(ptr_node const&amp;);</a>
<a name="ln4893">      };</a>
<a name="ln4894"> </a>
<a name="ln4895">      // If the allocator uses raw pointers use ptr_node</a>
<a name="ln4896">      // Otherwise use node.</a>
<a name="ln4897"> </a>
<a name="ln4898">      template &lt;typename A, typename T, typename NodePtr, typename BucketPtr&gt;</a>
<a name="ln4899">      struct pick_node2</a>
<a name="ln4900">      {</a>
<a name="ln4901">        typedef boost::unordered::detail::node&lt;A, T&gt; node;</a>
<a name="ln4902"> </a>
<a name="ln4903">        typedef typename boost::unordered::detail::allocator_traits&lt;</a>
<a name="ln4904">          typename boost::unordered::detail::rebind_wrap&lt;A,</a>
<a name="ln4905">            node&gt;::type&gt;::pointer node_pointer;</a>
<a name="ln4906"> </a>
<a name="ln4907">        typedef boost::unordered::detail::bucket&lt;node_pointer&gt; bucket;</a>
<a name="ln4908">        typedef node_pointer link_pointer;</a>
<a name="ln4909">      };</a>
<a name="ln4910"> </a>
<a name="ln4911">      template &lt;typename A, typename T&gt;</a>
<a name="ln4912">      struct pick_node2&lt;A, T, boost::unordered::detail::ptr_node&lt;T&gt;*,</a>
<a name="ln4913">        boost::unordered::detail::ptr_bucket*&gt;</a>
<a name="ln4914">      {</a>
<a name="ln4915">        typedef boost::unordered::detail::ptr_node&lt;T&gt; node;</a>
<a name="ln4916">        typedef boost::unordered::detail::ptr_bucket bucket;</a>
<a name="ln4917">        typedef bucket* link_pointer;</a>
<a name="ln4918">      };</a>
<a name="ln4919"> </a>
<a name="ln4920">      template &lt;typename A, typename T&gt; struct pick_node</a>
<a name="ln4921">      {</a>
<a name="ln4922">        typedef typename boost::remove_const&lt;T&gt;::type nonconst;</a>
<a name="ln4923"> </a>
<a name="ln4924">        typedef boost::unordered::detail::allocator_traits&lt;</a>
<a name="ln4925">          typename boost::unordered::detail::rebind_wrap&lt;A,</a>
<a name="ln4926">            boost::unordered::detail::ptr_node&lt;nonconst&gt; &gt;::type&gt;</a>
<a name="ln4927">          tentative_node_traits;</a>
<a name="ln4928"> </a>
<a name="ln4929">        typedef boost::unordered::detail::allocator_traits&lt;</a>
<a name="ln4930">          typename boost::unordered::detail::rebind_wrap&lt;A,</a>
<a name="ln4931">            boost::unordered::detail::ptr_bucket&gt;::type&gt;</a>
<a name="ln4932">          tentative_bucket_traits;</a>
<a name="ln4933"> </a>
<a name="ln4934">        typedef pick_node2&lt;A, nonconst, typename tentative_node_traits::pointer,</a>
<a name="ln4935">          typename tentative_bucket_traits::pointer&gt;</a>
<a name="ln4936">          pick;</a>
<a name="ln4937"> </a>
<a name="ln4938">        typedef typename pick::node node;</a>
<a name="ln4939">        typedef typename pick::bucket bucket;</a>
<a name="ln4940">        typedef typename pick::link_pointer link_pointer;</a>
<a name="ln4941">      };</a>
<a name="ln4942">    }</a>
<a name="ln4943">  }</a>
<a name="ln4944">}</a>
<a name="ln4945"> </a>
<a name="ln4946">#undef BOOST_UNORDERED_EMPLACE_TEMPLATE</a>
<a name="ln4947">#undef BOOST_UNORDERED_EMPLACE_ARGS</a>
<a name="ln4948">#undef BOOST_UNORDERED_EMPLACE_FORWARD</a>
<a name="ln4949">#undef BOOST_UNORDERED_CALL_CONSTRUCT1</a>
<a name="ln4950">#undef BOOST_UNORDERED_CALL_DESTROY</a>
<a name="ln4951"> </a>
<a name="ln4952">#endif</a>

</code></pre>
<div class="balloon" rel="2242"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: bucket_, bucket_count_.</p></div>
<div class="balloon" rel="2299"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: bucket_, bucket_count_.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
