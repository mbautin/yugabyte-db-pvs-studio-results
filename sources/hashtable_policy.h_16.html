
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>hashtable_policy.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Internal policy header for unordered_set and unordered_map -*- C++ -*-</a>
<a name="ln2"> </a>
<a name="ln3">// Copyright (C) 2010-2018 Free Software Foundation, Inc.</a>
<a name="ln4">//</a>
<a name="ln5">// This file is part of the GNU ISO C++ Library.  This library is free</a>
<a name="ln6">// software; you can redistribute it and/or modify it under the</a>
<a name="ln7">// terms of the GNU General Public License as published by the</a>
<a name="ln8">// Free Software Foundation; either version 3, or (at your option)</a>
<a name="ln9">// any later version.</a>
<a name="ln10"> </a>
<a name="ln11">// This library is distributed in the hope that it will be useful,</a>
<a name="ln12">// but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">// GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">// Under Section 7 of GPL version 3, you are granted additional</a>
<a name="ln17">// permissions described in the GCC Runtime Library Exception, version</a>
<a name="ln18">// 3.1, as published by the Free Software Foundation.</a>
<a name="ln19"> </a>
<a name="ln20">// You should have received a copy of the GNU General Public License and</a>
<a name="ln21">// a copy of the GCC Runtime Library Exception along with this program;</a>
<a name="ln22">// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see</a>
<a name="ln23">// &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln24"> </a>
<a name="ln25">/** @file bits/hashtable_policy.h</a>
<a name="ln26"> *  This is an internal header file, included by other library headers.</a>
<a name="ln27"> *  Do not attempt to use it directly.</a>
<a name="ln28"> *  @headername{unordered_map,unordered_set}</a>
<a name="ln29"> */</a>
<a name="ln30"> </a>
<a name="ln31">#ifndef _HASHTABLE_POLICY_H</a>
<a name="ln32">#define _HASHTABLE_POLICY_H 1</a>
<a name="ln33"> </a>
<a name="ln34">#include &lt;tuple&gt;		// for std::tuple, std::forward_as_tuple</a>
<a name="ln35">#include &lt;cstdint&gt;		// for std::uint_fast64_t</a>
<a name="ln36">#include &lt;bits/stl_algobase.h&gt;	// for std::min.</a>
<a name="ln37"> </a>
<a name="ln38">namespace std _GLIBCXX_VISIBILITY(default)</a>
<a name="ln39">{</a>
<a name="ln40">_GLIBCXX_BEGIN_NAMESPACE_VERSION</a>
<a name="ln41"> </a>
<a name="ln42">  template&lt;typename _Key, typename _Value, typename _Alloc,</a>
<a name="ln43">	   typename _ExtractKey, typename _Equal,</a>
<a name="ln44">	   typename _H1, typename _H2, typename _Hash,</a>
<a name="ln45">	   typename _RehashPolicy, typename _Traits&gt;</a>
<a name="ln46">    class _Hashtable;</a>
<a name="ln47"> </a>
<a name="ln48">namespace __detail</a>
<a name="ln49">{</a>
<a name="ln50">  /**</a>
<a name="ln51">   *  @defgroup hashtable-detail Base and Implementation Classes</a>
<a name="ln52">   *  @ingroup unordered_associative_containers</a>
<a name="ln53">   *  @{</a>
<a name="ln54">   */</a>
<a name="ln55">  template&lt;typename _Key, typename _Value,</a>
<a name="ln56">	   typename _ExtractKey, typename _Equal,</a>
<a name="ln57">	   typename _H1, typename _H2, typename _Hash, typename _Traits&gt;</a>
<a name="ln58">    struct _Hashtable_base;</a>
<a name="ln59"> </a>
<a name="ln60">  // Helper function: return distance(first, last) for forward</a>
<a name="ln61">  // iterators, or 0/1 for input iterators.</a>
<a name="ln62">  template&lt;class _Iterator&gt;</a>
<a name="ln63">    inline typename std::iterator_traits&lt;_Iterator&gt;::difference_type</a>
<a name="ln64">    __distance_fw(_Iterator __first, _Iterator __last,</a>
<a name="ln65">		  std::input_iterator_tag)</a>
<a name="ln66">    { return __first != __last ? 1 : 0; }</a>
<a name="ln67"> </a>
<a name="ln68">  template&lt;class _Iterator&gt;</a>
<a name="ln69">    inline typename std::iterator_traits&lt;_Iterator&gt;::difference_type</a>
<a name="ln70">    __distance_fw(_Iterator __first, _Iterator __last,</a>
<a name="ln71">		  std::forward_iterator_tag)</a>
<a name="ln72">    { return std::distance(__first, __last); }</a>
<a name="ln73"> </a>
<a name="ln74">  template&lt;class _Iterator&gt;</a>
<a name="ln75">    inline typename std::iterator_traits&lt;_Iterator&gt;::difference_type</a>
<a name="ln76">    __distance_fw(_Iterator __first, _Iterator __last)</a>
<a name="ln77">    { return __distance_fw(__first, __last,</a>
<a name="ln78">			   std::__iterator_category(__first)); }</a>
<a name="ln79"> </a>
<a name="ln80">  struct _Identity</a>
<a name="ln81">  {</a>
<a name="ln82">    template&lt;typename _Tp&gt;</a>
<a name="ln83">      _Tp&amp;&amp;</a>
<a name="ln84">      operator()(_Tp&amp;&amp; __x) const</a>
<a name="ln85">      { return std::forward&lt;_Tp&gt;(__x); }</a>
<a name="ln86">  };</a>
<a name="ln87"> </a>
<a name="ln88">  struct _Select1st</a>
<a name="ln89">  {</a>
<a name="ln90">    template&lt;typename _Tp&gt;</a>
<a name="ln91">      auto</a>
<a name="ln92">      operator()(_Tp&amp;&amp; __x) const</a>
<a name="ln93">      -&gt; decltype(std::get&lt;0&gt;(std::forward&lt;_Tp&gt;(__x)))</a>
<a name="ln94">      { return std::get&lt;0&gt;(std::forward&lt;_Tp&gt;(__x)); }</a>
<a name="ln95">  };</a>
<a name="ln96"> </a>
<a name="ln97">  template&lt;typename _NodeAlloc&gt;</a>
<a name="ln98">    struct _Hashtable_alloc;</a>
<a name="ln99"> </a>
<a name="ln100">  // Functor recycling a pool of nodes and using allocation once the pool is</a>
<a name="ln101">  // empty.</a>
<a name="ln102">  template&lt;typename _NodeAlloc&gt;</a>
<a name="ln103">    struct _ReuseOrAllocNode</a>
<a name="ln104">    {</a>
<a name="ln105">    private:</a>
<a name="ln106">      using __node_alloc_type = _NodeAlloc;</a>
<a name="ln107">      using __hashtable_alloc = _Hashtable_alloc&lt;__node_alloc_type&gt;;</a>
<a name="ln108">      using __node_alloc_traits =</a>
<a name="ln109">	typename __hashtable_alloc::__node_alloc_traits;</a>
<a name="ln110">      using __node_type = typename __hashtable_alloc::__node_type;</a>
<a name="ln111"> </a>
<a name="ln112">    public:</a>
<a name="ln113">      _ReuseOrAllocNode(__node_type* __nodes, __hashtable_alloc&amp; __h)</a>
<a name="ln114">	: _M_nodes(__nodes), _M_h(__h) { }</a>
<a name="ln115">      _ReuseOrAllocNode(const _ReuseOrAllocNode&amp;) = delete;</a>
<a name="ln116"> </a>
<a name="ln117">      ~_ReuseOrAllocNode()</a>
<a name="ln118">      { _M_h._M_deallocate_nodes(_M_nodes); }</a>
<a name="ln119"> </a>
<a name="ln120">      template&lt;typename _Arg&gt;</a>
<a name="ln121">	__node_type*</a>
<a name="ln122">	operator()(_Arg&amp;&amp; __arg) const</a>
<a name="ln123">	{</a>
<a name="ln124">	  if (_M_nodes)</a>
<a name="ln125">	    {</a>
<a name="ln126">	      __node_type* __node = _M_nodes;</a>
<a name="ln127">	      _M_nodes = _M_nodes-&gt;_M_next();</a>
<a name="ln128">	      __node-&gt;_M_nxt = nullptr;</a>
<a name="ln129">	      auto&amp; __a = _M_h._M_node_allocator();</a>
<a name="ln130">	      __node_alloc_traits::destroy(__a, __node-&gt;_M_valptr());</a>
<a name="ln131">	      __try</a>
<a name="ln132">		{</a>
<a name="ln133">		  __node_alloc_traits::construct(__a, __node-&gt;_M_valptr(),</a>
<a name="ln134">						 std::forward&lt;_Arg&gt;(__arg));</a>
<a name="ln135">		}</a>
<a name="ln136">	      __catch(...)</a>
<a name="ln137">		{</a>
<a name="ln138">		  __node-&gt;~__node_type();</a>
<a name="ln139">		  __node_alloc_traits::deallocate(__a, __node, 1);</a>
<a name="ln140">		  __throw_exception_again;</a>
<a name="ln141">		}</a>
<a name="ln142">	      return __node;</a>
<a name="ln143">	    }</a>
<a name="ln144">	  return _M_h._M_allocate_node(std::forward&lt;_Arg&gt;(__arg));</a>
<a name="ln145">	}</a>
<a name="ln146"> </a>
<a name="ln147">    private:</a>
<a name="ln148">      mutable __node_type* _M_nodes;</a>
<a name="ln149">      __hashtable_alloc&amp; _M_h;</a>
<a name="ln150">    };</a>
<a name="ln151"> </a>
<a name="ln152">  // Functor similar to the previous one but without any pool of nodes to</a>
<a name="ln153">  // recycle.</a>
<a name="ln154">  template&lt;typename _NodeAlloc&gt;</a>
<a name="ln155">    struct _AllocNode</a>
<a name="ln156">    {</a>
<a name="ln157">    private:</a>
<a name="ln158">      using __hashtable_alloc = _Hashtable_alloc&lt;_NodeAlloc&gt;;</a>
<a name="ln159">      using __node_type = typename __hashtable_alloc::__node_type;</a>
<a name="ln160"> </a>
<a name="ln161">    public:</a>
<a name="ln162">      _AllocNode(__hashtable_alloc&amp; __h)</a>
<a name="ln163">	: _M_h(__h) { }</a>
<a name="ln164"> </a>
<a name="ln165">      template&lt;typename _Arg&gt;</a>
<a name="ln166">	__node_type*</a>
<a name="ln167">	operator()(_Arg&amp;&amp; __arg) const</a>
<a name="ln168">	{ return _M_h._M_allocate_node(std::forward&lt;_Arg&gt;(__arg)); }</a>
<a name="ln169"> </a>
<a name="ln170">    private:</a>
<a name="ln171">      __hashtable_alloc&amp; _M_h;</a>
<a name="ln172">    };</a>
<a name="ln173"> </a>
<a name="ln174">  // Auxiliary types used for all instantiations of _Hashtable nodes</a>
<a name="ln175">  // and iterators.</a>
<a name="ln176"> </a>
<a name="ln177">  /**</a>
<a name="ln178">   *  struct _Hashtable_traits</a>
<a name="ln179">   *</a>
<a name="ln180">   *  Important traits for hash tables.</a>
<a name="ln181">   *</a>
<a name="ln182">   *  @tparam _Cache_hash_code  Boolean value. True if the value of</a>
<a name="ln183">   *  the hash function is stored along with the value. This is a</a>
<a name="ln184">   *  time-space tradeoff.  Storing it may improve lookup speed by</a>
<a name="ln185">   *  reducing the number of times we need to call the _Equal</a>
<a name="ln186">   *  function.</a>
<a name="ln187">   *</a>
<a name="ln188">   *  @tparam _Constant_iterators  Boolean value. True if iterator and</a>
<a name="ln189">   *  const_iterator are both constant iterator types. This is true</a>
<a name="ln190">   *  for unordered_set and unordered_multiset, false for</a>
<a name="ln191">   *  unordered_map and unordered_multimap.</a>
<a name="ln192">   *</a>
<a name="ln193">   *  @tparam _Unique_keys  Boolean value. True if the return value</a>
<a name="ln194">   *  of _Hashtable::count(k) is always at most one, false if it may</a>
<a name="ln195">   *  be an arbitrary number. This is true for unordered_set and</a>
<a name="ln196">   *  unordered_map, false for unordered_multiset and</a>
<a name="ln197">   *  unordered_multimap.</a>
<a name="ln198">   */</a>
<a name="ln199">  template&lt;bool _Cache_hash_code, bool _Constant_iterators, bool _Unique_keys&gt;</a>
<a name="ln200">    struct _Hashtable_traits</a>
<a name="ln201">    {</a>
<a name="ln202">      using __hash_cached = __bool_constant&lt;_Cache_hash_code&gt;;</a>
<a name="ln203">      using __constant_iterators = __bool_constant&lt;_Constant_iterators&gt;;</a>
<a name="ln204">      using __unique_keys = __bool_constant&lt;_Unique_keys&gt;;</a>
<a name="ln205">    };</a>
<a name="ln206"> </a>
<a name="ln207">  /**</a>
<a name="ln208">   *  struct _Hash_node_base</a>
<a name="ln209">   *</a>
<a name="ln210">   *  Nodes, used to wrap elements stored in the hash table.  A policy</a>
<a name="ln211">   *  template parameter of class template _Hashtable controls whether</a>
<a name="ln212">   *  nodes also store a hash code. In some cases (e.g. strings) this</a>
<a name="ln213">   *  may be a performance win.</a>
<a name="ln214">   */</a>
<a name="ln215">  struct _Hash_node_base</a>
<a name="ln216">  {</a>
<a name="ln217">    _Hash_node_base* _M_nxt;</a>
<a name="ln218"> </a>
<a name="ln219">    _Hash_node_base() noexcept : _M_nxt() { }</a>
<a name="ln220"> </a>
<a name="ln221">    _Hash_node_base(_Hash_node_base* __next) noexcept : _M_nxt(__next) { }</a>
<a name="ln222">  };</a>
<a name="ln223"> </a>
<a name="ln224">  /**</a>
<a name="ln225">   *  struct _Hash_node_value_base</a>
<a name="ln226">   *</a>
<a name="ln227">   *  Node type with the value to store.</a>
<a name="ln228">   */</a>
<a name="ln229">  template&lt;typename _Value&gt;</a>
<a name="ln230">    struct _Hash_node_value_base : _Hash_node_base</a>
<a name="ln231">    {</a>
<a name="ln232">      typedef _Value value_type;</a>
<a name="ln233"> </a>
<a name="ln234">      __gnu_cxx::__aligned_buffer&lt;_Value&gt; _M_storage;</a>
<a name="ln235"> </a>
<a name="ln236">      _Value*</a>
<a name="ln237">      _M_valptr() noexcept</a>
<a name="ln238">      { return _M_storage._M_ptr(); }</a>
<a name="ln239"> </a>
<a name="ln240">      const _Value*</a>
<a name="ln241">      _M_valptr() const noexcept</a>
<a name="ln242">      { return _M_storage._M_ptr(); }</a>
<a name="ln243"> </a>
<a name="ln244">      _Value&amp;</a>
<a name="ln245">      _M_v() noexcept</a>
<a name="ln246">      { return *_M_valptr(); }</a>
<a name="ln247"> </a>
<a name="ln248">      const _Value&amp;</a>
<a name="ln249">      _M_v() const noexcept</a>
<a name="ln250">      { return *_M_valptr(); }</a>
<a name="ln251">    };</a>
<a name="ln252"> </a>
<a name="ln253">  /**</a>
<a name="ln254">   *  Primary template struct _Hash_node.</a>
<a name="ln255">   */</a>
<a name="ln256">  template&lt;typename _Value, bool _Cache_hash_code&gt;</a>
<a name="ln257">    struct _Hash_node;</a>
<a name="ln258"> </a>
<a name="ln259">  /**</a>
<a name="ln260">   *  Specialization for nodes with caches, struct _Hash_node.</a>
<a name="ln261">   *</a>
<a name="ln262">   *  Base class is __detail::_Hash_node_value_base.</a>
<a name="ln263">   */</a>
<a name="ln264">  template&lt;typename _Value&gt;</a>
<a name="ln265">    struct _Hash_node&lt;_Value, true&gt; : _Hash_node_value_base&lt;_Value&gt;</a>
<a name="ln266">    {</a>
<a name="ln267">      std::size_t  _M_hash_code;</a>
<a name="ln268"> </a>
<a name="ln269">      _Hash_node*</a>
<a name="ln270">      _M_next() const noexcept</a>
<a name="ln271">      { return static_cast&lt;_Hash_node*&gt;(this-&gt;_M_nxt); }</a>
<a name="ln272">    };</a>
<a name="ln273"> </a>
<a name="ln274">  /**</a>
<a name="ln275">   *  Specialization for nodes without caches, struct _Hash_node.</a>
<a name="ln276">   *</a>
<a name="ln277">   *  Base class is __detail::_Hash_node_value_base.</a>
<a name="ln278">   */</a>
<a name="ln279">  template&lt;typename _Value&gt;</a>
<a name="ln280">    struct _Hash_node&lt;_Value, false&gt; : _Hash_node_value_base&lt;_Value&gt;</a>
<a name="ln281">    {</a>
<a name="ln282">      _Hash_node*</a>
<a name="ln283">      _M_next() const noexcept</a>
<a name="ln284">      { return static_cast&lt;_Hash_node*&gt;(this-&gt;_M_nxt); }</a>
<a name="ln285">    };</a>
<a name="ln286"> </a>
<a name="ln287">  /// Base class for node iterators.</a>
<a name="ln288">  template&lt;typename _Value, bool _Cache_hash_code&gt;</a>
<a name="ln289">    struct _Node_iterator_base</a>
<a name="ln290">    {</a>
<a name="ln291">      using __node_type = _Hash_node&lt;_Value, _Cache_hash_code&gt;;</a>
<a name="ln292"> </a>
<a name="ln293">      __node_type*  _M_cur;</a>
<a name="ln294"> </a>
<a name="ln295">      _Node_iterator_base(__node_type* __p) noexcept</a>
<a name="ln296">      : _M_cur(__p) { }</a>
<a name="ln297"> </a>
<a name="ln298">      void</a>
<a name="ln299">      _M_incr() noexcept</a>
<a name="ln300">      { _M_cur = _M_cur-&gt;_M_next(); }</a>
<a name="ln301">    };</a>
<a name="ln302"> </a>
<a name="ln303">  template&lt;typename _Value, bool _Cache_hash_code&gt;</a>
<a name="ln304">    inline bool</a>
<a name="ln305">    operator==(const _Node_iterator_base&lt;_Value, _Cache_hash_code&gt;&amp; __x,</a>
<a name="ln306">	       const _Node_iterator_base&lt;_Value, _Cache_hash_code &gt;&amp; __y)</a>
<a name="ln307">    noexcept</a>
<a name="ln308">    { return __x._M_cur == __y._M_cur; }</a>
<a name="ln309"> </a>
<a name="ln310">  template&lt;typename _Value, bool _Cache_hash_code&gt;</a>
<a name="ln311">    inline bool</a>
<a name="ln312">    operator!=(const _Node_iterator_base&lt;_Value, _Cache_hash_code&gt;&amp; __x,</a>
<a name="ln313">	       const _Node_iterator_base&lt;_Value, _Cache_hash_code&gt;&amp; __y)</a>
<a name="ln314">    noexcept</a>
<a name="ln315">    { return __x._M_cur != __y._M_cur; }</a>
<a name="ln316"> </a>
<a name="ln317">  /// Node iterators, used to iterate through all the hashtable.</a>
<a name="ln318">  template&lt;typename _Value, bool __constant_iterators, bool __cache&gt;</a>
<a name="ln319">    struct _Node_iterator</a>
<a name="ln320">    : public _Node_iterator_base&lt;_Value, __cache&gt;</a>
<a name="ln321">    {</a>
<a name="ln322">    private:</a>
<a name="ln323">      using __base_type = _Node_iterator_base&lt;_Value, __cache&gt;;</a>
<a name="ln324">      using __node_type = typename __base_type::__node_type;</a>
<a name="ln325"> </a>
<a name="ln326">    public:</a>
<a name="ln327">      typedef _Value					value_type;</a>
<a name="ln328">      typedef std::ptrdiff_t				difference_type;</a>
<a name="ln329">      typedef std::forward_iterator_tag			iterator_category;</a>
<a name="ln330"> </a>
<a name="ln331">      using pointer = typename std::conditional&lt;__constant_iterators,</a>
<a name="ln332">						const _Value*, _Value*&gt;::type;</a>
<a name="ln333"> </a>
<a name="ln334">      using reference = typename std::conditional&lt;__constant_iterators,</a>
<a name="ln335">						  const _Value&amp;, _Value&amp;&gt;::type;</a>
<a name="ln336"> </a>
<a name="ln337">      _Node_iterator() noexcept</a>
<a name="ln338">      : __base_type(0) { }</a>
<a name="ln339"> </a>
<a name="ln340">      explicit</a>
<a name="ln341">      _Node_iterator(__node_type* __p) noexcept</a>
<a name="ln342">      : __base_type(__p) { }</a>
<a name="ln343"> </a>
<a name="ln344">      reference</a>
<a name="ln345">      operator*() const noexcept</a>
<a name="ln346">      { return this-&gt;_M_cur-&gt;_M_v(); }</a>
<a name="ln347"> </a>
<a name="ln348">      pointer</a>
<a name="ln349">      operator-&gt;() const noexcept</a>
<a name="ln350">      { return this-&gt;_M_cur-&gt;_M_valptr(); }</a>
<a name="ln351"> </a>
<a name="ln352">      _Node_iterator&amp;</a>
<a name="ln353">      operator++() noexcept</a>
<a name="ln354">      {</a>
<a name="ln355">	this-&gt;_M_incr();</a>
<a name="ln356">	return *this;</a>
<a name="ln357">      }</a>
<a name="ln358"> </a>
<a name="ln359">      _Node_iterator</a>
<a name="ln360">      operator++(int) noexcept</a>
<a name="ln361">      {</a>
<a name="ln362">	_Node_iterator __tmp(*this);</a>
<a name="ln363">	this-&gt;_M_incr();</a>
<a name="ln364">	return __tmp;</a>
<a name="ln365">      }</a>
<a name="ln366">    };</a>
<a name="ln367"> </a>
<a name="ln368">  /// Node const_iterators, used to iterate through all the hashtable.</a>
<a name="ln369">  template&lt;typename _Value, bool __constant_iterators, bool __cache&gt;</a>
<a name="ln370">    struct _Node_const_iterator</a>
<a name="ln371">    : public _Node_iterator_base&lt;_Value, __cache&gt;</a>
<a name="ln372">    {</a>
<a name="ln373">    private:</a>
<a name="ln374">      using __base_type = _Node_iterator_base&lt;_Value, __cache&gt;;</a>
<a name="ln375">      using __node_type = typename __base_type::__node_type;</a>
<a name="ln376"> </a>
<a name="ln377">    public:</a>
<a name="ln378">      typedef _Value					value_type;</a>
<a name="ln379">      typedef std::ptrdiff_t				difference_type;</a>
<a name="ln380">      typedef std::forward_iterator_tag			iterator_category;</a>
<a name="ln381"> </a>
<a name="ln382">      typedef const _Value*				pointer;</a>
<a name="ln383">      typedef const _Value&amp;				reference;</a>
<a name="ln384"> </a>
<a name="ln385">      _Node_const_iterator() noexcept</a>
<a name="ln386">      : __base_type(0) { }</a>
<a name="ln387"> </a>
<a name="ln388">      explicit</a>
<a name="ln389">      _Node_const_iterator(__node_type* __p) noexcept</a>
<a name="ln390">      : __base_type(__p) { }</a>
<a name="ln391"> </a>
<a name="ln392">      _Node_const_iterator(const _Node_iterator&lt;_Value, __constant_iterators,</a>
<a name="ln393">			   __cache&gt;&amp; __x) noexcept</a>
<a name="ln394">      : __base_type(__x._M_cur) { }</a>
<a name="ln395"> </a>
<a name="ln396">      reference</a>
<a name="ln397">      operator*() const noexcept</a>
<a name="ln398">      { return this-&gt;_M_cur-&gt;_M_v(); }</a>
<a name="ln399"> </a>
<a name="ln400">      pointer</a>
<a name="ln401">      operator-&gt;() const noexcept</a>
<a name="ln402">      { return this-&gt;_M_cur-&gt;_M_valptr(); }</a>
<a name="ln403"> </a>
<a name="ln404">      _Node_const_iterator&amp;</a>
<a name="ln405">      operator++() noexcept</a>
<a name="ln406">      {</a>
<a name="ln407">	this-&gt;_M_incr();</a>
<a name="ln408">	return *this;</a>
<a name="ln409">      }</a>
<a name="ln410"> </a>
<a name="ln411">      _Node_const_iterator</a>
<a name="ln412">      operator++(int) noexcept</a>
<a name="ln413">      {</a>
<a name="ln414">	_Node_const_iterator __tmp(*this);</a>
<a name="ln415">	this-&gt;_M_incr();</a>
<a name="ln416">	return __tmp;</a>
<a name="ln417">      }</a>
<a name="ln418">    };</a>
<a name="ln419"> </a>
<a name="ln420">  // Many of class template _Hashtable's template parameters are policy</a>
<a name="ln421">  // classes.  These are defaults for the policies.</a>
<a name="ln422"> </a>
<a name="ln423">  /// Default range hashing function: use division to fold a large number</a>
<a name="ln424">  /// into the range [0, N).</a>
<a name="ln425">  struct _Mod_range_hashing</a>
<a name="ln426">  {</a>
<a name="ln427">    typedef std::size_t first_argument_type;</a>
<a name="ln428">    typedef std::size_t second_argument_type;</a>
<a name="ln429">    typedef std::size_t result_type;</a>
<a name="ln430"> </a>
<a name="ln431">    result_type</a>
<a name="ln432">    operator()(first_argument_type __num,</a>
<a name="ln433">	       second_argument_type __den) const noexcept</a>
<a name="ln434">    { return __num % __den; }</a>
<a name="ln435">  };</a>
<a name="ln436"> </a>
<a name="ln437">  /// Default ranged hash function H.  In principle it should be a</a>
<a name="ln438">  /// function object composed from objects of type H1 and H2 such that</a>
<a name="ln439">  /// h(k, N) = h2(h1(k), N), but that would mean making extra copies of</a>
<a name="ln440">  /// h1 and h2.  So instead we'll just use a tag to tell class template</a>
<a name="ln441">  /// hashtable to do that composition.</a>
<a name="ln442">  struct _Default_ranged_hash { };</a>
<a name="ln443"> </a>
<a name="ln444">  /// Default value for rehash policy.  Bucket size is (usually) the</a>
<a name="ln445">  /// smallest prime that keeps the load factor small enough.</a>
<a name="ln446">  struct _Prime_rehash_policy</a>
<a name="ln447">  {</a>
<a name="ln448">    using __has_load_factor = std::true_type;</a>
<a name="ln449"> </a>
<a name="ln450">    _Prime_rehash_policy(float __z = 1.0) noexcept</a>
<a name="ln451">    : _M_max_load_factor(__z), _M_next_resize(0) { }</a>
<a name="ln452"> </a>
<a name="ln453">    float</a>
<a name="ln454">    max_load_factor() const noexcept</a>
<a name="ln455">    { return _M_max_load_factor; }</a>
<a name="ln456"> </a>
<a name="ln457">    // Return a bucket size no smaller than n.</a>
<a name="ln458">    std::size_t</a>
<a name="ln459">    _M_next_bkt(std::size_t __n) const;</a>
<a name="ln460"> </a>
<a name="ln461">    // Return a bucket count appropriate for n elements</a>
<a name="ln462">    std::size_t</a>
<a name="ln463">    _M_bkt_for_elements(std::size_t __n) const</a>
<a name="ln464">    { return __builtin_ceil(__n / (long double)_M_max_load_factor); }</a>
<a name="ln465"> </a>
<a name="ln466">    // __n_bkt is current bucket count, __n_elt is current element count,</a>
<a name="ln467">    // and __n_ins is number of elements to be inserted.  Do we need to</a>
<a name="ln468">    // increase bucket count?  If so, return make_pair(true, n), where n</a>
<a name="ln469">    // is the new bucket count.  If not, return make_pair(false, 0).</a>
<a name="ln470">    std::pair&lt;bool, std::size_t&gt;</a>
<a name="ln471">    _M_need_rehash(std::size_t __n_bkt, std::size_t __n_elt,</a>
<a name="ln472">		   std::size_t __n_ins) const;</a>
<a name="ln473"> </a>
<a name="ln474">    typedef std::size_t _State;</a>
<a name="ln475"> </a>
<a name="ln476">    _State</a>
<a name="ln477">    _M_state() const</a>
<a name="ln478">    { return _M_next_resize; }</a>
<a name="ln479"> </a>
<a name="ln480">    void</a>
<a name="ln481">    _M_reset() noexcept</a>
<a name="ln482">    { _M_next_resize = 0; }</a>
<a name="ln483"> </a>
<a name="ln484">    void</a>
<a name="ln485">    _M_reset(_State __state)</a>
<a name="ln486">    { _M_next_resize = __state; }</a>
<a name="ln487"> </a>
<a name="ln488">    static const std::size_t _S_growth_factor = 2;</a>
<a name="ln489"> </a>
<a name="ln490">    float		_M_max_load_factor;</a>
<a name="ln491">    mutable std::size_t	_M_next_resize;</a>
<a name="ln492">  };</a>
<a name="ln493"> </a>
<a name="ln494">  /// Range hashing function assuming that second arg is a power of 2.</a>
<a name="ln495">  struct _Mask_range_hashing</a>
<a name="ln496">  {</a>
<a name="ln497">    typedef std::size_t first_argument_type;</a>
<a name="ln498">    typedef std::size_t second_argument_type;</a>
<a name="ln499">    typedef std::size_t result_type;</a>
<a name="ln500"> </a>
<a name="ln501">    result_type</a>
<a name="ln502">    operator()(first_argument_type __num,</a>
<a name="ln503">	       second_argument_type __den) const noexcept</a>
<a name="ln504">    { return __num &amp; (__den - 1); }</a>
<a name="ln505">  };</a>
<a name="ln506"> </a>
<a name="ln507">  /// Compute closest power of 2.</a>
<a name="ln508">  _GLIBCXX14_CONSTEXPR</a>
<a name="ln509">  inline std::size_t</a>
<a name="ln510">  __clp2(std::size_t __n) noexcept</a>
<a name="ln511">  {</a>
<a name="ln512">#if __SIZEOF_SIZE_T__ &gt;= 8</a>
<a name="ln513">    std::uint_fast64_t __x = __n;</a>
<a name="ln514">#else</a>
<a name="ln515">    std::uint_fast32_t __x = __n;</a>
<a name="ln516">#endif</a>
<a name="ln517">    // Algorithm from Hacker's Delight, Figure 3-3.</a>
<a name="ln518">    __x = __x - 1;</a>
<a name="ln519">    __x = __x | (__x &gt;&gt; 1);</a>
<a name="ln520">    __x = __x | (__x &gt;&gt; 2);</a>
<a name="ln521">    __x = __x | (__x &gt;&gt; 4);</a>
<a name="ln522">    __x = __x | (__x &gt;&gt; 8);</a>
<a name="ln523">    __x = __x | (__x &gt;&gt;16);</a>
<a name="ln524">#if __SIZEOF_SIZE_T__ &gt;= 8</a>
<a name="ln525">    __x = __x | (__x &gt;&gt;32);</a>
<a name="ln526">#endif</a>
<a name="ln527">    return __x + 1;</a>
<a name="ln528">  }</a>
<a name="ln529"> </a>
<a name="ln530">  /// Rehash policy providing power of 2 bucket numbers. Avoids modulo</a>
<a name="ln531">  /// operations.</a>
<a name="ln532">  struct _Power2_rehash_policy</a>
<a name="ln533">  {</a>
<a name="ln534">    using __has_load_factor = std::true_type;</a>
<a name="ln535"> </a>
<a name="ln536">    _Power2_rehash_policy(float __z = 1.0) noexcept</a>
<a name="ln537">    : _M_max_load_factor(__z), _M_next_resize(0) { }</a>
<a name="ln538"> </a>
<a name="ln539">    float</a>
<a name="ln540">    max_load_factor() const noexcept</a>
<a name="ln541">    { return _M_max_load_factor; }</a>
<a name="ln542"> </a>
<a name="ln543">    // Return a bucket size no smaller than n (as long as n is not above the</a>
<a name="ln544">    // highest power of 2).</a>
<a name="ln545">    std::size_t</a>
<a name="ln546">    _M_next_bkt(std::size_t __n) noexcept</a>
<a name="ln547">    {</a>
<a name="ln548">      const auto __max_width = std::min&lt;size_t&gt;(sizeof(size_t), 8);</a>
<a name="ln549">      const auto __max_bkt = size_t(1) &lt;&lt; (__max_width * __CHAR_BIT__ - 1);</a>
<a name="ln550">      std::size_t __res = __clp2(__n);</a>
<a name="ln551"> </a>
<a name="ln552">      if (__res == __n)</a>
<a name="ln553">	__res &lt;&lt;= 1;</a>
<a name="ln554"> </a>
<a name="ln555">      if (__res == 0)</a>
<a name="ln556">	__res = __max_bkt;</a>
<a name="ln557"> </a>
<a name="ln558">      if (__res == __max_bkt)</a>
<a name="ln559">	// Set next resize to the max value so that we never try to rehash again</a>
<a name="ln560">	// as we already reach the biggest possible bucket number.</a>
<a name="ln561">	// Note that it might result in max_load_factor not being respected.</a>
<a name="ln562">	_M_next_resize = std::size_t(-1);</a>
<a name="ln563">      else</a>
<a name="ln564">	_M_next_resize</a>
<a name="ln565">	  = __builtin_ceil(__res * (long double)_M_max_load_factor);</a>
<a name="ln566"> </a>
<a name="ln567">      return __res;</a>
<a name="ln568">    }</a>
<a name="ln569"> </a>
<a name="ln570">    // Return a bucket count appropriate for n elements</a>
<a name="ln571">    std::size_t</a>
<a name="ln572">    _M_bkt_for_elements(std::size_t __n) const noexcept</a>
<a name="ln573">    { return __builtin_ceil(__n / (long double)_M_max_load_factor); }</a>
<a name="ln574"> </a>
<a name="ln575">    // __n_bkt is current bucket count, __n_elt is current element count,</a>
<a name="ln576">    // and __n_ins is number of elements to be inserted.  Do we need to</a>
<a name="ln577">    // increase bucket count?  If so, return make_pair(true, n), where n</a>
<a name="ln578">    // is the new bucket count.  If not, return make_pair(false, 0).</a>
<a name="ln579">    std::pair&lt;bool, std::size_t&gt;</a>
<a name="ln580">    _M_need_rehash(std::size_t __n_bkt, std::size_t __n_elt,</a>
<a name="ln581">		   std::size_t __n_ins) noexcept</a>
<a name="ln582">    {</a>
<a name="ln583">      if (__n_elt + __n_ins &gt;= _M_next_resize)</a>
<a name="ln584">	{</a>
<a name="ln585">	  long double __min_bkts = (__n_elt + __n_ins)</a>
<a name="ln586">					/ (long double)_M_max_load_factor;</a>
<a name="ln587">	  if (__min_bkts &gt;= __n_bkt)</a>
<a name="ln588">	    return std::make_pair(true,</a>
<a name="ln589">	      _M_next_bkt(std::max&lt;std::size_t&gt;(__builtin_floor(__min_bkts) + 1,</a>
<a name="ln590">						__n_bkt * _S_growth_factor)));</a>
<a name="ln591"> </a>
<a name="ln592">	  _M_next_resize</a>
<a name="ln593">	    = __builtin_floor(__n_bkt * (long double)_M_max_load_factor);</a>
<a name="ln594">	  return std::make_pair(false, 0);</a>
<a name="ln595">	}</a>
<a name="ln596">      else</a>
<a name="ln597">	return std::make_pair(false, 0);</a>
<a name="ln598">    }</a>
<a name="ln599"> </a>
<a name="ln600">    typedef std::size_t _State;</a>
<a name="ln601"> </a>
<a name="ln602">    _State</a>
<a name="ln603">    _M_state() const noexcept</a>
<a name="ln604">    { return _M_next_resize; }</a>
<a name="ln605"> </a>
<a name="ln606">    void</a>
<a name="ln607">    _M_reset() noexcept</a>
<a name="ln608">    { _M_next_resize = 0; }</a>
<a name="ln609"> </a>
<a name="ln610">    void</a>
<a name="ln611">    _M_reset(_State __state) noexcept</a>
<a name="ln612">    { _M_next_resize = __state; }</a>
<a name="ln613"> </a>
<a name="ln614">    static const std::size_t _S_growth_factor = 2;</a>
<a name="ln615"> </a>
<a name="ln616">    float	_M_max_load_factor;</a>
<a name="ln617">    std::size_t	_M_next_resize;</a>
<a name="ln618">  };</a>
<a name="ln619"> </a>
<a name="ln620">  // Base classes for std::_Hashtable.  We define these base classes</a>
<a name="ln621">  // because in some cases we want to do different things depending on</a>
<a name="ln622">  // the value of a policy class.  In some cases the policy class</a>
<a name="ln623">  // affects which member functions and nested typedefs are defined;</a>
<a name="ln624">  // we handle that by specializing base class templates.  Several of</a>
<a name="ln625">  // the base class templates need to access other members of class</a>
<a name="ln626">  // template _Hashtable, so we use a variant of the &quot;Curiously</a>
<a name="ln627">  // Recurring Template Pattern&quot; (CRTP) technique.</a>
<a name="ln628"> </a>
<a name="ln629">  /**</a>
<a name="ln630">   *  Primary class template _Map_base.</a>
<a name="ln631">   *</a>
<a name="ln632">   *  If the hashtable has a value type of the form pair&lt;T1, T2&gt; and a</a>
<a name="ln633">   *  key extraction policy (_ExtractKey) that returns the first part</a>
<a name="ln634">   *  of the pair, the hashtable gets a mapped_type typedef.  If it</a>
<a name="ln635">   *  satisfies those criteria and also has unique keys, then it also</a>
<a name="ln636">   *  gets an operator[].</a>
<a name="ln637">   */</a>
<a name="ln638">  template&lt;typename _Key, typename _Value, typename _Alloc,</a>
<a name="ln639">	   typename _ExtractKey, typename _Equal,</a>
<a name="ln640">	   typename _H1, typename _H2, typename _Hash,</a>
<a name="ln641">	   typename _RehashPolicy, typename _Traits,</a>
<a name="ln642">	   bool _Unique_keys = _Traits::__unique_keys::value&gt;</a>
<a name="ln643">    struct _Map_base { };</a>
<a name="ln644"> </a>
<a name="ln645">  /// Partial specialization, __unique_keys set to false.</a>
<a name="ln646">  template&lt;typename _Key, typename _Pair, typename _Alloc, typename _Equal,</a>
<a name="ln647">	   typename _H1, typename _H2, typename _Hash,</a>
<a name="ln648">	   typename _RehashPolicy, typename _Traits&gt;</a>
<a name="ln649">    struct _Map_base&lt;_Key, _Pair, _Alloc, _Select1st, _Equal,</a>
<a name="ln650">		     _H1, _H2, _Hash, _RehashPolicy, _Traits, false&gt;</a>
<a name="ln651">    {</a>
<a name="ln652">      using mapped_type = typename std::tuple_element&lt;1, _Pair&gt;::type;</a>
<a name="ln653">    };</a>
<a name="ln654"> </a>
<a name="ln655">  /// Partial specialization, __unique_keys set to true.</a>
<a name="ln656">  template&lt;typename _Key, typename _Pair, typename _Alloc, typename _Equal,</a>
<a name="ln657">	   typename _H1, typename _H2, typename _Hash,</a>
<a name="ln658">	   typename _RehashPolicy, typename _Traits&gt;</a>
<a name="ln659">    struct _Map_base&lt;_Key, _Pair, _Alloc, _Select1st, _Equal,</a>
<a name="ln660">		     _H1, _H2, _Hash, _RehashPolicy, _Traits, true&gt;</a>
<a name="ln661">    {</a>
<a name="ln662">    private:</a>
<a name="ln663">      using __hashtable_base = __detail::_Hashtable_base&lt;_Key, _Pair,</a>
<a name="ln664">							 _Select1st,</a>
<a name="ln665">							_Equal, _H1, _H2, _Hash,</a>
<a name="ln666">							  _Traits&gt;;</a>
<a name="ln667"> </a>
<a name="ln668">      using __hashtable = _Hashtable&lt;_Key, _Pair, _Alloc,</a>
<a name="ln669">				     _Select1st, _Equal,</a>
<a name="ln670">				     _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;;</a>
<a name="ln671"> </a>
<a name="ln672">      using __hash_code = typename __hashtable_base::__hash_code;</a>
<a name="ln673">      using __node_type = typename __hashtable_base::__node_type;</a>
<a name="ln674"> </a>
<a name="ln675">    public:</a>
<a name="ln676">      using key_type = typename __hashtable_base::key_type;</a>
<a name="ln677">      using iterator = typename __hashtable_base::iterator;</a>
<a name="ln678">      using mapped_type = typename std::tuple_element&lt;1, _Pair&gt;::type;</a>
<a name="ln679"> </a>
<a name="ln680">      mapped_type&amp;</a>
<a name="ln681">      operator[](const key_type&amp; __k);</a>
<a name="ln682"> </a>
<a name="ln683">      mapped_type&amp;</a>
<a name="ln684">      operator[](key_type&amp;&amp; __k);</a>
<a name="ln685"> </a>
<a name="ln686">      // _GLIBCXX_RESOLVE_LIB_DEFECTS</a>
<a name="ln687">      // DR 761. unordered_map needs an at() member function.</a>
<a name="ln688">      mapped_type&amp;</a>
<a name="ln689">      at(const key_type&amp; __k);</a>
<a name="ln690"> </a>
<a name="ln691">      const mapped_type&amp;</a>
<a name="ln692">      at(const key_type&amp; __k) const;</a>
<a name="ln693">    };</a>
<a name="ln694"> </a>
<a name="ln695">  template&lt;typename _Key, typename _Pair, typename _Alloc, typename _Equal,</a>
<a name="ln696">	   typename _H1, typename _H2, typename _Hash,</a>
<a name="ln697">	   typename _RehashPolicy, typename _Traits&gt;</a>
<a name="ln698">    auto</a>
<a name="ln699">    _Map_base&lt;_Key, _Pair, _Alloc, _Select1st, _Equal,</a>
<a name="ln700">	      _H1, _H2, _Hash, _RehashPolicy, _Traits, true&gt;::</a>
<a name="ln701">    operator[](const key_type&amp; __k)</a>
<a name="ln702">    -&gt; mapped_type&amp;</a>
<a name="ln703">    {</a>
<a name="ln704">      __hashtable* __h = static_cast&lt;__hashtable*&gt;(this);</a>
<a name="ln705">      __hash_code __code = __h-&gt;_M_hash_code(__k);</a>
<a name="ln706">      std::size_t __n = __h-&gt;_M_bucket_index(__k, __code);</a>
<a name="ln707">      __node_type* __p = __h-&gt;_M_find_node(__n, __k, __code);</a>
<a name="ln708"> </a>
<a name="ln709">      if (!__p)</a>
<a name="ln710">	{</a>
<a name="ln711">	  __p = __h-&gt;_M_allocate_node(std::piecewise_construct,</a>
<a name="ln712">				      std::tuple&lt;const key_type&amp;&gt;(__k),</a>
<a name="ln713">				      std::tuple&lt;&gt;());</a>
<a name="ln714">	  return __h-&gt;_M_insert_unique_node(__n, __code, __p)-&gt;second;</a>
<a name="ln715">	}</a>
<a name="ln716"> </a>
<a name="ln717">      return __p-&gt;_M_v().second;</a>
<a name="ln718">    }</a>
<a name="ln719"> </a>
<a name="ln720">  template&lt;typename _Key, typename _Pair, typename _Alloc, typename _Equal,</a>
<a name="ln721">	   typename _H1, typename _H2, typename _Hash,</a>
<a name="ln722">	   typename _RehashPolicy, typename _Traits&gt;</a>
<a name="ln723">    auto</a>
<a name="ln724">    _Map_base&lt;_Key, _Pair, _Alloc, _Select1st, _Equal,</a>
<a name="ln725">	      _H1, _H2, _Hash, _RehashPolicy, _Traits, true&gt;::</a>
<a name="ln726">    operator[](key_type&amp;&amp; __k)</a>
<a name="ln727">    -&gt; mapped_type&amp;</a>
<a name="ln728">    {</a>
<a name="ln729">      __hashtable* __h = static_cast&lt;__hashtable*&gt;(this);</a>
<a name="ln730">      __hash_code __code = __h-&gt;_M_hash_code(__k);</a>
<a name="ln731">      std::size_t __n = __h-&gt;_M_bucket_index(__k, __code);</a>
<a name="ln732">      __node_type* __p = __h-&gt;_M_find_node(__n, __k, __code);</a>
<a name="ln733"> </a>
<a name="ln734">      if (!__p)</a>
<a name="ln735">	{</a>
<a name="ln736">	  __p = __h-&gt;_M_allocate_node(std::piecewise_construct,</a>
<a name="ln737">				      std::forward_as_tuple(std::move(__k)),</a>
<a name="ln738">				      std::tuple&lt;&gt;());</a>
<a name="ln739">	  return __h-&gt;_M_insert_unique_node(__n, __code, __p)-&gt;second;</a>
<a name="ln740">	}</a>
<a name="ln741"> </a>
<a name="ln742">      return __p-&gt;_M_v().second;</a>
<a name="ln743">    }</a>
<a name="ln744"> </a>
<a name="ln745">  template&lt;typename _Key, typename _Pair, typename _Alloc, typename _Equal,</a>
<a name="ln746">	   typename _H1, typename _H2, typename _Hash,</a>
<a name="ln747">	   typename _RehashPolicy, typename _Traits&gt;</a>
<a name="ln748">    auto</a>
<a name="ln749">    _Map_base&lt;_Key, _Pair, _Alloc, _Select1st, _Equal,</a>
<a name="ln750">	      _H1, _H2, _Hash, _RehashPolicy, _Traits, true&gt;::</a>
<a name="ln751">    at(const key_type&amp; __k)</a>
<a name="ln752">    -&gt; mapped_type&amp;</a>
<a name="ln753">    {</a>
<a name="ln754">      __hashtable* __h = static_cast&lt;__hashtable*&gt;(this);</a>
<a name="ln755">      __hash_code __code = __h-&gt;_M_hash_code(__k);</a>
<a name="ln756">      std::size_t __n = __h-&gt;_M_bucket_index(__k, __code);</a>
<a name="ln757">      __node_type* __p = __h-&gt;_M_find_node(__n, __k, __code);</a>
<a name="ln758"> </a>
<a name="ln759">      if (!__p)</a>
<a name="ln760">	__throw_out_of_range(__N(&quot;_Map_base::at&quot;));</a>
<a name="ln761">      return __p-&gt;_M_v().second;</a>
<a name="ln762">    }</a>
<a name="ln763"> </a>
<a name="ln764">  template&lt;typename _Key, typename _Pair, typename _Alloc, typename _Equal,</a>
<a name="ln765">	   typename _H1, typename _H2, typename _Hash,</a>
<a name="ln766">	   typename _RehashPolicy, typename _Traits&gt;</a>
<a name="ln767">    auto</a>
<a name="ln768">    _Map_base&lt;_Key, _Pair, _Alloc, _Select1st, _Equal,</a>
<a name="ln769">	      _H1, _H2, _Hash, _RehashPolicy, _Traits, true&gt;::</a>
<a name="ln770">    at(const key_type&amp; __k) const</a>
<a name="ln771">    -&gt; const mapped_type&amp;</a>
<a name="ln772">    {</a>
<a name="ln773">      const __hashtable* __h = static_cast&lt;const __hashtable*&gt;(this);</a>
<a name="ln774">      __hash_code __code = __h-&gt;_M_hash_code(__k);</a>
<a name="ln775">      std::size_t __n = __h-&gt;_M_bucket_index(__k, __code);</a>
<a name="ln776">      __node_type* __p = __h-&gt;_M_find_node(__n, __k, __code);</a>
<a name="ln777"> </a>
<a name="ln778">      if (!__p)</a>
<a name="ln779">	__throw_out_of_range(__N(&quot;_Map_base::at&quot;));</a>
<a name="ln780">      return __p-&gt;_M_v().second;</a>
<a name="ln781">    }</a>
<a name="ln782"> </a>
<a name="ln783">  /**</a>
<a name="ln784">   *  Primary class template _Insert_base.</a>
<a name="ln785">   *</a>
<a name="ln786">   *  Defines @c insert member functions appropriate to all _Hashtables.</a>
<a name="ln787">   */</a>
<a name="ln788">  template&lt;typename _Key, typename _Value, typename _Alloc,</a>
<a name="ln789">	   typename _ExtractKey, typename _Equal,</a>
<a name="ln790">	   typename _H1, typename _H2, typename _Hash,</a>
<a name="ln791">	   typename _RehashPolicy, typename _Traits&gt;</a>
<a name="ln792">    struct _Insert_base</a>
<a name="ln793">    {</a>
<a name="ln794">    protected:</a>
<a name="ln795">      using __hashtable = _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey,</a>
<a name="ln796">				     _Equal, _H1, _H2, _Hash,</a>
<a name="ln797">				     _RehashPolicy, _Traits&gt;;</a>
<a name="ln798"> </a>
<a name="ln799">      using __hashtable_base = _Hashtable_base&lt;_Key, _Value, _ExtractKey,</a>
<a name="ln800">					       _Equal, _H1, _H2, _Hash,</a>
<a name="ln801">					       _Traits&gt;;</a>
<a name="ln802"> </a>
<a name="ln803">      using value_type = typename __hashtable_base::value_type;</a>
<a name="ln804">      using iterator = typename __hashtable_base::iterator;</a>
<a name="ln805">      using const_iterator =  typename __hashtable_base::const_iterator;</a>
<a name="ln806">      using size_type = typename __hashtable_base::size_type;</a>
<a name="ln807"> </a>
<a name="ln808">      using __unique_keys = typename __hashtable_base::__unique_keys;</a>
<a name="ln809">      using __ireturn_type = typename __hashtable_base::__ireturn_type;</a>
<a name="ln810">      using __node_type = _Hash_node&lt;_Value, _Traits::__hash_cached::value&gt;;</a>
<a name="ln811">      using __node_alloc_type = __alloc_rebind&lt;_Alloc, __node_type&gt;;</a>
<a name="ln812">      using __node_gen_type = _AllocNode&lt;__node_alloc_type&gt;;</a>
<a name="ln813"> </a>
<a name="ln814">      __hashtable&amp;</a>
<a name="ln815">      _M_conjure_hashtable()</a>
<a name="ln816">      { return *(static_cast&lt;__hashtable*&gt;(this)); }</a>
<a name="ln817"> </a>
<a name="ln818">      template&lt;typename _InputIterator, typename _NodeGetter&gt;</a>
<a name="ln819">	void</a>
<a name="ln820">	_M_insert_range(_InputIterator __first, _InputIterator __last,</a>
<a name="ln821">			const _NodeGetter&amp;, true_type);</a>
<a name="ln822"> </a>
<a name="ln823">      template&lt;typename _InputIterator, typename _NodeGetter&gt;</a>
<a name="ln824">	void</a>
<a name="ln825">	_M_insert_range(_InputIterator __first, _InputIterator __last,</a>
<a name="ln826">			const _NodeGetter&amp;, false_type);</a>
<a name="ln827"> </a>
<a name="ln828">    public:</a>
<a name="ln829">      __ireturn_type</a>
<a name="ln830">      insert(const value_type&amp; __v)</a>
<a name="ln831">      {</a>
<a name="ln832">	__hashtable&amp; __h = _M_conjure_hashtable();</a>
<a name="ln833">	__node_gen_type __node_gen(__h);</a>
<a name="ln834">	return __h._M_insert(__v, __node_gen, __unique_keys());</a>
<a name="ln835">      }</a>
<a name="ln836"> </a>
<a name="ln837">      iterator</a>
<a name="ln838">      insert(const_iterator __hint, const value_type&amp; __v)</a>
<a name="ln839">      {</a>
<a name="ln840">	__hashtable&amp; __h = _M_conjure_hashtable();</a>
<a name="ln841">	__node_gen_type __node_gen(__h);	</a>
<a name="ln842">	return __h._M_insert(__hint, __v, __node_gen, __unique_keys());</a>
<a name="ln843">      }</a>
<a name="ln844"> </a>
<a name="ln845">      void</a>
<a name="ln846">      insert(initializer_list&lt;value_type&gt; __l)</a>
<a name="ln847">      { this-&gt;insert(__l.begin(), __l.end()); }</a>
<a name="ln848"> </a>
<a name="ln849">      template&lt;typename _InputIterator&gt;</a>
<a name="ln850">	void</a>
<a name="ln851">	insert(_InputIterator __first, _InputIterator __last)</a>
<a name="ln852">	{</a>
<a name="ln853">	  __hashtable&amp; __h = _M_conjure_hashtable();</a>
<a name="ln854">	  __node_gen_type __node_gen(__h);</a>
<a name="ln855">	  return _M_insert_range(__first, __last, __node_gen, __unique_keys());</a>
<a name="ln856">	}</a>
<a name="ln857">    };</a>
<a name="ln858"> </a>
<a name="ln859">  template&lt;typename _Key, typename _Value, typename _Alloc,</a>
<a name="ln860">	   typename _ExtractKey, typename _Equal,</a>
<a name="ln861">	   typename _H1, typename _H2, typename _Hash,</a>
<a name="ln862">	   typename _RehashPolicy, typename _Traits&gt;</a>
<a name="ln863">    template&lt;typename _InputIterator, typename _NodeGetter&gt;</a>
<a name="ln864">      void</a>
<a name="ln865">      _Insert_base&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,</a>
<a name="ln866">		    _RehashPolicy, _Traits&gt;::</a>
<a name="ln867">      _M_insert_range(_InputIterator __first, _InputIterator __last,</a>
<a name="ln868">		      const _NodeGetter&amp; __node_gen, true_type)</a>
<a name="ln869">      {</a>
<a name="ln870">	size_type __n_elt = __detail::__distance_fw(__first, __last);</a>
<a name="ln871">	if (__n_elt == 0)</a>
<a name="ln872">	  return;</a>
<a name="ln873"> </a>
<a name="ln874">	__hashtable&amp; __h = _M_conjure_hashtable();</a>
<a name="ln875">	for (; __first != __last; ++__first)</a>
<a name="ln876">	  {</a>
<a name="ln877">	    if (__h._M_insert(*__first, __node_gen, __unique_keys(),</a>
<a name="ln878">			      __n_elt).second)</a>
<a name="ln879">	      __n_elt = 1;</a>
<a name="ln880">	    else if (__n_elt != 1)</a>
<a name="ln881">	      --__n_elt;</a>
<a name="ln882">	  }</a>
<a name="ln883">      }</a>
<a name="ln884"> </a>
<a name="ln885">  template&lt;typename _Key, typename _Value, typename _Alloc,</a>
<a name="ln886">	   typename _ExtractKey, typename _Equal,</a>
<a name="ln887">	   typename _H1, typename _H2, typename _Hash,</a>
<a name="ln888">	   typename _RehashPolicy, typename _Traits&gt;</a>
<a name="ln889">    template&lt;typename _InputIterator, typename _NodeGetter&gt;</a>
<a name="ln890">      void</a>
<a name="ln891">      _Insert_base&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,</a>
<a name="ln892">		    _RehashPolicy, _Traits&gt;::</a>
<a name="ln893">      _M_insert_range(_InputIterator __first, _InputIterator __last,</a>
<a name="ln894">		      const _NodeGetter&amp; __node_gen, false_type)</a>
<a name="ln895">      {</a>
<a name="ln896">	using __rehash_type = typename __hashtable::__rehash_type;</a>
<a name="ln897">	using __rehash_state = typename __hashtable::__rehash_state;</a>
<a name="ln898">	using pair_type = std::pair&lt;bool, std::size_t&gt;;</a>
<a name="ln899"> </a>
<a name="ln900">	size_type __n_elt = __detail::__distance_fw(__first, __last);</a>
<a name="ln901">	if (__n_elt == 0)</a>
<a name="ln902">	  return;</a>
<a name="ln903"> </a>
<a name="ln904">	__hashtable&amp; __h = _M_conjure_hashtable();</a>
<a name="ln905">	__rehash_type&amp; __rehash = __h._M_rehash_policy;</a>
<a name="ln906">	const __rehash_state&amp; __saved_state = __rehash._M_state();</a>
<a name="ln907">	pair_type __do_rehash = __rehash._M_need_rehash(__h._M_bucket_count,</a>
<a name="ln908">							__h._M_element_count,</a>
<a name="ln909">							__n_elt);</a>
<a name="ln910"> </a>
<a name="ln911">	if (__do_rehash.first)</a>
<a name="ln912">	  __h._M_rehash(__do_rehash.second, __saved_state);</a>
<a name="ln913"> </a>
<a name="ln914">	for (; __first != __last; ++__first)</a>
<a name="ln915">	  __h._M_insert(*__first, __node_gen, __unique_keys());</a>
<a name="ln916">      }</a>
<a name="ln917"> </a>
<a name="ln918">  /**</a>
<a name="ln919">   *  Primary class template _Insert.</a>
<a name="ln920">   *</a>
<a name="ln921">   *  Defines @c insert member functions that depend on _Hashtable policies,</a>
<a name="ln922">   *  via partial specializations.</a>
<a name="ln923">   */</a>
<a name="ln924">  template&lt;typename _Key, typename _Value, typename _Alloc,</a>
<a name="ln925">	   typename _ExtractKey, typename _Equal,</a>
<a name="ln926">	   typename _H1, typename _H2, typename _Hash,</a>
<a name="ln927">	   typename _RehashPolicy, typename _Traits,</a>
<a name="ln928">	   bool _Constant_iterators = _Traits::__constant_iterators::value&gt;</a>
<a name="ln929">    struct _Insert;</a>
<a name="ln930"> </a>
<a name="ln931">  /// Specialization.</a>
<a name="ln932">  template&lt;typename _Key, typename _Value, typename _Alloc,</a>
<a name="ln933">	   typename _ExtractKey, typename _Equal,</a>
<a name="ln934">	   typename _H1, typename _H2, typename _Hash,</a>
<a name="ln935">	   typename _RehashPolicy, typename _Traits&gt;</a>
<a name="ln936">    struct _Insert&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,</a>
<a name="ln937">		   _RehashPolicy, _Traits, true&gt;</a>
<a name="ln938">    : public _Insert_base&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal,</a>
<a name="ln939">			   _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;</a>
<a name="ln940">    {</a>
<a name="ln941">      using __base_type = _Insert_base&lt;_Key, _Value, _Alloc, _ExtractKey,</a>
<a name="ln942">					_Equal, _H1, _H2, _Hash,</a>
<a name="ln943">					_RehashPolicy, _Traits&gt;;</a>
<a name="ln944"> </a>
<a name="ln945">      using __hashtable_base = _Hashtable_base&lt;_Key, _Value, _ExtractKey,</a>
<a name="ln946">					       _Equal, _H1, _H2, _Hash,</a>
<a name="ln947">					       _Traits&gt;;</a>
<a name="ln948"> </a>
<a name="ln949">      using value_type = typename __base_type::value_type;</a>
<a name="ln950">      using iterator = typename __base_type::iterator;</a>
<a name="ln951">      using const_iterator =  typename __base_type::const_iterator;</a>
<a name="ln952"> </a>
<a name="ln953">      using __unique_keys = typename __base_type::__unique_keys;</a>
<a name="ln954">      using __ireturn_type = typename __hashtable_base::__ireturn_type;</a>
<a name="ln955">      using __hashtable = typename __base_type::__hashtable;</a>
<a name="ln956">      using __node_gen_type = typename __base_type::__node_gen_type;</a>
<a name="ln957"> </a>
<a name="ln958">      using __base_type::insert;</a>
<a name="ln959"> </a>
<a name="ln960">      __ireturn_type</a>
<a name="ln961">      insert(value_type&amp;&amp; __v)</a>
<a name="ln962">      {</a>
<a name="ln963">	__hashtable&amp; __h = this-&gt;_M_conjure_hashtable();</a>
<a name="ln964">	__node_gen_type __node_gen(__h);</a>
<a name="ln965">	return __h._M_insert(std::move(__v), __node_gen, __unique_keys());</a>
<a name="ln966">      }</a>
<a name="ln967"> </a>
<a name="ln968">      iterator</a>
<a name="ln969">      insert(const_iterator __hint, value_type&amp;&amp; __v)</a>
<a name="ln970">      {</a>
<a name="ln971">	__hashtable&amp; __h = this-&gt;_M_conjure_hashtable();</a>
<a name="ln972">	__node_gen_type __node_gen(__h);</a>
<a name="ln973">	return __h._M_insert(__hint, std::move(__v), __node_gen,</a>
<a name="ln974">			     __unique_keys());</a>
<a name="ln975">      }</a>
<a name="ln976">    };</a>
<a name="ln977"> </a>
<a name="ln978">  /// Specialization.</a>
<a name="ln979">  template&lt;typename _Key, typename _Value, typename _Alloc,</a>
<a name="ln980">	   typename _ExtractKey, typename _Equal,</a>
<a name="ln981">	   typename _H1, typename _H2, typename _Hash,</a>
<a name="ln982">	   typename _RehashPolicy, typename _Traits&gt;</a>
<a name="ln983">    struct _Insert&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,</a>
<a name="ln984">		   _RehashPolicy, _Traits, false&gt;</a>
<a name="ln985">    : public _Insert_base&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal,</a>
<a name="ln986">			   _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;</a>
<a name="ln987">    {</a>
<a name="ln988">      using __base_type = _Insert_base&lt;_Key, _Value, _Alloc, _ExtractKey,</a>
<a name="ln989">				       _Equal, _H1, _H2, _Hash,</a>
<a name="ln990">				       _RehashPolicy, _Traits&gt;;</a>
<a name="ln991">      using value_type = typename __base_type::value_type;</a>
<a name="ln992">      using iterator = typename __base_type::iterator;</a>
<a name="ln993">      using const_iterator =  typename __base_type::const_iterator;</a>
<a name="ln994"> </a>
<a name="ln995">      using __unique_keys = typename __base_type::__unique_keys;</a>
<a name="ln996">      using __hashtable = typename __base_type::__hashtable;</a>
<a name="ln997">      using __ireturn_type = typename __base_type::__ireturn_type;</a>
<a name="ln998"> </a>
<a name="ln999">      using __base_type::insert;</a>
<a name="ln1000"> </a>
<a name="ln1001">      template&lt;typename _Pair&gt;</a>
<a name="ln1002">	using __is_cons = std::is_constructible&lt;value_type, _Pair&amp;&amp;&gt;;</a>
<a name="ln1003"> </a>
<a name="ln1004">      template&lt;typename _Pair&gt;</a>
<a name="ln1005">	using _IFcons = std::enable_if&lt;__is_cons&lt;_Pair&gt;::value&gt;;</a>
<a name="ln1006"> </a>
<a name="ln1007">      template&lt;typename _Pair&gt;</a>
<a name="ln1008">	using _IFconsp = typename _IFcons&lt;_Pair&gt;::type;</a>
<a name="ln1009"> </a>
<a name="ln1010">      template&lt;typename _Pair, typename = _IFconsp&lt;_Pair&gt;&gt;</a>
<a name="ln1011">	__ireturn_type</a>
<a name="ln1012">	insert(_Pair&amp;&amp; __v)</a>
<a name="ln1013">	{</a>
<a name="ln1014">	  __hashtable&amp; __h = this-&gt;_M_conjure_hashtable();</a>
<a name="ln1015">	  return __h._M_emplace(__unique_keys(), std::forward&lt;_Pair&gt;(__v));</a>
<a name="ln1016">	}</a>
<a name="ln1017"> </a>
<a name="ln1018">      template&lt;typename _Pair, typename = _IFconsp&lt;_Pair&gt;&gt;</a>
<a name="ln1019">	iterator</a>
<a name="ln1020">	insert(const_iterator __hint, _Pair&amp;&amp; __v)</a>
<a name="ln1021">	{</a>
<a name="ln1022">	  __hashtable&amp; __h = this-&gt;_M_conjure_hashtable();</a>
<a name="ln1023">	  return __h._M_emplace(__hint, __unique_keys(),</a>
<a name="ln1024">				std::forward&lt;_Pair&gt;(__v));</a>
<a name="ln1025">	}</a>
<a name="ln1026">   };</a>
<a name="ln1027"> </a>
<a name="ln1028">  template&lt;typename _Policy&gt;</a>
<a name="ln1029">    using __has_load_factor = typename _Policy::__has_load_factor;</a>
<a name="ln1030"> </a>
<a name="ln1031">  /**</a>
<a name="ln1032">   *  Primary class template  _Rehash_base.</a>
<a name="ln1033">   *</a>
<a name="ln1034">   *  Give hashtable the max_load_factor functions and reserve iff the</a>
<a name="ln1035">   *  rehash policy supports it.</a>
<a name="ln1036">  */</a>
<a name="ln1037">  template&lt;typename _Key, typename _Value, typename _Alloc,</a>
<a name="ln1038">	   typename _ExtractKey, typename _Equal,</a>
<a name="ln1039">	   typename _H1, typename _H2, typename _Hash,</a>
<a name="ln1040">	   typename _RehashPolicy, typename _Traits,</a>
<a name="ln1041">	   typename =</a>
<a name="ln1042">	     __detected_or_t&lt;std::false_type, __has_load_factor, _RehashPolicy&gt;&gt;</a>
<a name="ln1043">    struct _Rehash_base;</a>
<a name="ln1044"> </a>
<a name="ln1045">  /// Specialization when rehash policy doesn't provide load factor management.</a>
<a name="ln1046">  template&lt;typename _Key, typename _Value, typename _Alloc,</a>
<a name="ln1047">	   typename _ExtractKey, typename _Equal,</a>
<a name="ln1048">	   typename _H1, typename _H2, typename _Hash,</a>
<a name="ln1049">	   typename _RehashPolicy, typename _Traits&gt;</a>
<a name="ln1050">    struct _Rehash_base&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal,</a>
<a name="ln1051">		      _H1, _H2, _Hash, _RehashPolicy, _Traits,</a>
<a name="ln1052">		      std::false_type&gt;</a>
<a name="ln1053">    {</a>
<a name="ln1054">    };</a>
<a name="ln1055"> </a>
<a name="ln1056">  /// Specialization when rehash policy provide load factor management.</a>
<a name="ln1057">  template&lt;typename _Key, typename _Value, typename _Alloc,</a>
<a name="ln1058">	   typename _ExtractKey, typename _Equal,</a>
<a name="ln1059">	   typename _H1, typename _H2, typename _Hash,</a>
<a name="ln1060">	   typename _RehashPolicy, typename _Traits&gt;</a>
<a name="ln1061">    struct _Rehash_base&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal,</a>
<a name="ln1062">			_H1, _H2, _Hash, _RehashPolicy, _Traits,</a>
<a name="ln1063">			std::true_type&gt;</a>
<a name="ln1064">    {</a>
<a name="ln1065">      using __hashtable = _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey,</a>
<a name="ln1066">				     _Equal, _H1, _H2, _Hash,</a>
<a name="ln1067">				     _RehashPolicy, _Traits&gt;;</a>
<a name="ln1068"> </a>
<a name="ln1069">      float</a>
<a name="ln1070">      max_load_factor() const noexcept</a>
<a name="ln1071">      {</a>
<a name="ln1072">	const __hashtable* __this = static_cast&lt;const __hashtable*&gt;(this);</a>
<a name="ln1073">	return __this-&gt;__rehash_policy().max_load_factor();</a>
<a name="ln1074">      }</a>
<a name="ln1075"> </a>
<a name="ln1076">      void</a>
<a name="ln1077">      max_load_factor(float __z)</a>
<a name="ln1078">      {</a>
<a name="ln1079">	__hashtable* __this = static_cast&lt;__hashtable*&gt;(this);</a>
<a name="ln1080">	__this-&gt;__rehash_policy(_RehashPolicy(__z));</a>
<a name="ln1081">      }</a>
<a name="ln1082"> </a>
<a name="ln1083">      void</a>
<a name="ln1084">      reserve(std::size_t __n)</a>
<a name="ln1085">      {</a>
<a name="ln1086">	__hashtable* __this = static_cast&lt;__hashtable*&gt;(this);</a>
<a name="ln1087">	__this-&gt;rehash(__builtin_ceil(__n / max_load_factor()));</a>
<a name="ln1088">      }</a>
<a name="ln1089">    };</a>
<a name="ln1090"> </a>
<a name="ln1091">  /**</a>
<a name="ln1092">   *  Primary class template _Hashtable_ebo_helper.</a>
<a name="ln1093">   *</a>
<a name="ln1094">   *  Helper class using EBO when it is not forbidden (the type is not</a>
<a name="ln1095">   *  final) and when it is worth it (the type is empty.)</a>
<a name="ln1096">   */</a>
<a name="ln1097">  template&lt;int _Nm, typename _Tp,</a>
<a name="ln1098">	   bool __use_ebo = !__is_final(_Tp) &amp;&amp; __is_empty(_Tp)&gt;</a>
<a name="ln1099">    struct _Hashtable_ebo_helper;</a>
<a name="ln1100"> </a>
<a name="ln1101">  /// Specialization using EBO.</a>
<a name="ln1102">  template&lt;int _Nm, typename _Tp&gt;</a>
<a name="ln1103">    struct _Hashtable_ebo_helper&lt;_Nm, _Tp, true&gt;</a>
<a name="ln1104">    : private _Tp</a>
<a name="ln1105">    {</a>
<a name="ln1106">      _Hashtable_ebo_helper() = default;</a>
<a name="ln1107"> </a>
<a name="ln1108">      template&lt;typename _OtherTp&gt;</a>
<a name="ln1109">	_Hashtable_ebo_helper(_OtherTp&amp;&amp; __tp)</a>
<a name="ln1110">	  : _Tp(std::forward&lt;_OtherTp&gt;(__tp))</a>
<a name="ln1111">	{ }</a>
<a name="ln1112"> </a>
<a name="ln1113">      static const _Tp&amp;</a>
<a name="ln1114">      _S_cget(const _Hashtable_ebo_helper&amp; __eboh)</a>
<a name="ln1115">      { return static_cast&lt;const _Tp&amp;&gt;(__eboh); }</a>
<a name="ln1116"> </a>
<a name="ln1117">      static _Tp&amp;</a>
<a name="ln1118">      _S_get(_Hashtable_ebo_helper&amp; __eboh)</a>
<a name="ln1119">      { return static_cast&lt;_Tp&amp;&gt;(__eboh); }</a>
<a name="ln1120">    };</a>
<a name="ln1121"> </a>
<a name="ln1122">  /// Specialization not using EBO.</a>
<a name="ln1123">  template&lt;int _Nm, typename _Tp&gt;</a>
<a name="ln1124">    struct _Hashtable_ebo_helper&lt;_Nm, _Tp, false&gt;</a>
<a name="ln1125">    {</a>
<a name="ln1126">      _Hashtable_ebo_helper() = default;</a>
<a name="ln1127"> </a>
<a name="ln1128">      template&lt;typename _OtherTp&gt;</a>
<a name="ln1129">	_Hashtable_ebo_helper(_OtherTp&amp;&amp; __tp)</a>
<a name="ln1130">	  : _M_tp(std::forward&lt;_OtherTp&gt;(__tp))</a>
<a name="ln1131">	{ }</a>
<a name="ln1132"> </a>
<a name="ln1133">      static const _Tp&amp;</a>
<a name="ln1134">      _S_cget(const _Hashtable_ebo_helper&amp; __eboh)</a>
<a name="ln1135">      { return __eboh._M_tp; }</a>
<a name="ln1136"> </a>
<a name="ln1137">      static _Tp&amp;</a>
<a name="ln1138">      _S_get(_Hashtable_ebo_helper&amp; __eboh)</a>
<a name="ln1139">      { return __eboh._M_tp; }</a>
<a name="ln1140"> </a>
<a name="ln1141">    private:</a>
<a name="ln1142">      _Tp _M_tp;</a>
<a name="ln1143">    };</a>
<a name="ln1144"> </a>
<a name="ln1145">  /**</a>
<a name="ln1146">   *  Primary class template _Local_iterator_base.</a>
<a name="ln1147">   *</a>
<a name="ln1148">   *  Base class for local iterators, used to iterate within a bucket</a>
<a name="ln1149">   *  but not between buckets.</a>
<a name="ln1150">   */</a>
<a name="ln1151">  template&lt;typename _Key, typename _Value, typename _ExtractKey,</a>
<a name="ln1152">	   typename _H1, typename _H2, typename _Hash,</a>
<a name="ln1153">	   bool __cache_hash_code&gt;</a>
<a name="ln1154">    struct _Local_iterator_base;</a>
<a name="ln1155"> </a>
<a name="ln1156">  /**</a>
<a name="ln1157">   *  Primary class template _Hash_code_base.</a>
<a name="ln1158">   *</a>
<a name="ln1159">   *  Encapsulates two policy issues that aren't quite orthogonal.</a>
<a name="ln1160">   *   (1) the difference between using a ranged hash function and using</a>
<a name="ln1161">   *       the combination of a hash function and a range-hashing function.</a>
<a name="ln1162">   *       In the former case we don't have such things as hash codes, so</a>
<a name="ln1163">   *       we have a dummy type as placeholder.</a>
<a name="ln1164">   *   (2) Whether or not we cache hash codes.  Caching hash codes is</a>
<a name="ln1165">   *       meaningless if we have a ranged hash function.</a>
<a name="ln1166">   *</a>
<a name="ln1167">   *  We also put the key extraction objects here, for convenience.</a>
<a name="ln1168">   *  Each specialization derives from one or more of the template</a>
<a name="ln1169">   *  parameters to benefit from Ebo. This is important as this type</a>
<a name="ln1170">   *  is inherited in some cases by the _Local_iterator_base type used</a>
<a name="ln1171">   *  to implement local_iterator and const_local_iterator. As with</a>
<a name="ln1172">   *  any iterator type we prefer to make it as small as possible.</a>
<a name="ln1173">   *</a>
<a name="ln1174">   *  Primary template is unused except as a hook for specializations.</a>
<a name="ln1175">   */</a>
<a name="ln1176">  template&lt;typename _Key, typename _Value, typename _ExtractKey,</a>
<a name="ln1177">	   typename _H1, typename _H2, typename _Hash,</a>
<a name="ln1178">	   bool __cache_hash_code&gt;</a>
<a name="ln1179">    struct _Hash_code_base;</a>
<a name="ln1180"> </a>
<a name="ln1181">  /// Specialization: ranged hash function, no caching hash codes.  H1</a>
<a name="ln1182">  /// and H2 are provided but ignored.  We define a dummy hash code type.</a>
<a name="ln1183">  template&lt;typename _Key, typename _Value, typename _ExtractKey,</a>
<a name="ln1184">	   typename _H1, typename _H2, typename _Hash&gt;</a>
<a name="ln1185">    struct _Hash_code_base&lt;_Key, _Value, _ExtractKey, _H1, _H2, _Hash, false&gt;</a>
<a name="ln1186">    : private _Hashtable_ebo_helper&lt;0, _ExtractKey&gt;,</a>
<a name="ln1187">      private _Hashtable_ebo_helper&lt;1, _Hash&gt;</a>
<a name="ln1188">    {</a>
<a name="ln1189">    private:</a>
<a name="ln1190">      using __ebo_extract_key = _Hashtable_ebo_helper&lt;0, _ExtractKey&gt;;</a>
<a name="ln1191">      using __ebo_hash = _Hashtable_ebo_helper&lt;1, _Hash&gt;;</a>
<a name="ln1192"> </a>
<a name="ln1193">    protected:</a>
<a name="ln1194">      typedef void* 					__hash_code;</a>
<a name="ln1195">      typedef _Hash_node&lt;_Value, false&gt;			__node_type;</a>
<a name="ln1196"> </a>
<a name="ln1197">      // We need the default constructor for the local iterators and _Hashtable</a>
<a name="ln1198">      // default constructor.</a>
<a name="ln1199">      _Hash_code_base() = default;</a>
<a name="ln1200"> </a>
<a name="ln1201">      _Hash_code_base(const _ExtractKey&amp; __ex, const _H1&amp;, const _H2&amp;,</a>
<a name="ln1202">		      const _Hash&amp; __h)</a>
<a name="ln1203">      : __ebo_extract_key(__ex), __ebo_hash(__h) { }</a>
<a name="ln1204"> </a>
<a name="ln1205">      __hash_code</a>
<a name="ln1206">      _M_hash_code(const _Key&amp; __key) const</a>
<a name="ln1207">      { return 0; }</a>
<a name="ln1208"> </a>
<a name="ln1209">      std::size_t</a>
<a name="ln1210">      _M_bucket_index(const _Key&amp; __k, __hash_code, std::size_t __n) const</a>
<a name="ln1211">      { return _M_ranged_hash()(__k, __n); }</a>
<a name="ln1212"> </a>
<a name="ln1213">      std::size_t</a>
<a name="ln1214">      _M_bucket_index(const __node_type* __p, std::size_t __n) const</a>
<a name="ln1215">	noexcept( noexcept(declval&lt;const _Hash&amp;&gt;()(declval&lt;const _Key&amp;&gt;(),</a>
<a name="ln1216">						   (std::size_t)0)) )</a>
<a name="ln1217">      { return _M_ranged_hash()(_M_extract()(__p-&gt;_M_v()), __n); }</a>
<a name="ln1218"> </a>
<a name="ln1219">      void</a>
<a name="ln1220">      _M_store_code(__node_type*, __hash_code) const</a>
<a name="ln1221">      { }</a>
<a name="ln1222"> </a>
<a name="ln1223">      void</a>
<a name="ln1224">      _M_copy_code(__node_type*, const __node_type*) const</a>
<a name="ln1225">      { }</a>
<a name="ln1226"> </a>
<a name="ln1227">      void</a>
<a name="ln1228">      _M_swap(_Hash_code_base&amp; __x)</a>
<a name="ln1229">      {</a>
<a name="ln1230">	std::swap(_M_extract(), __x._M_extract());</a>
<a name="ln1231">	std::swap(_M_ranged_hash(), __x._M_ranged_hash());</a>
<a name="ln1232">      }</a>
<a name="ln1233"> </a>
<a name="ln1234">      const _ExtractKey&amp;</a>
<a name="ln1235">      _M_extract() const { return __ebo_extract_key::_S_cget(*this); }</a>
<a name="ln1236"> </a>
<a name="ln1237">      _ExtractKey&amp;</a>
<a name="ln1238">      _M_extract() { return __ebo_extract_key::_S_get(*this); }</a>
<a name="ln1239"> </a>
<a name="ln1240">      const _Hash&amp;</a>
<a name="ln1241">      _M_ranged_hash() const { return __ebo_hash::_S_cget(*this); }</a>
<a name="ln1242"> </a>
<a name="ln1243">      _Hash&amp;</a>
<a name="ln1244">      _M_ranged_hash() { return __ebo_hash::_S_get(*this); }</a>
<a name="ln1245">    };</a>
<a name="ln1246"> </a>
<a name="ln1247">  // No specialization for ranged hash function while caching hash codes.</a>
<a name="ln1248">  // That combination is meaningless, and trying to do it is an error.</a>
<a name="ln1249"> </a>
<a name="ln1250">  /// Specialization: ranged hash function, cache hash codes.  This</a>
<a name="ln1251">  /// combination is meaningless, so we provide only a declaration</a>
<a name="ln1252">  /// and no definition.</a>
<a name="ln1253">  template&lt;typename _Key, typename _Value, typename _ExtractKey,</a>
<a name="ln1254">	   typename _H1, typename _H2, typename _Hash&gt;</a>
<a name="ln1255">    struct _Hash_code_base&lt;_Key, _Value, _ExtractKey, _H1, _H2, _Hash, true&gt;;</a>
<a name="ln1256"> </a>
<a name="ln1257">  /// Specialization: hash function and range-hashing function, no</a>
<a name="ln1258">  /// caching of hash codes.</a>
<a name="ln1259">  /// Provides typedef and accessor required by C++ 11.</a>
<a name="ln1260">  template&lt;typename _Key, typename _Value, typename _ExtractKey,</a>
<a name="ln1261">	   typename _H1, typename _H2&gt;</a>
<a name="ln1262">    struct _Hash_code_base&lt;_Key, _Value, _ExtractKey, _H1, _H2,</a>
<a name="ln1263">			   _Default_ranged_hash, false&gt;</a>
<a name="ln1264">    : private _Hashtable_ebo_helper&lt;0, _ExtractKey&gt;,</a>
<a name="ln1265">      private _Hashtable_ebo_helper&lt;1, _H1&gt;,</a>
<a name="ln1266">      private _Hashtable_ebo_helper&lt;2, _H2&gt;</a>
<a name="ln1267">    {</a>
<a name="ln1268">    private:</a>
<a name="ln1269">      using __ebo_extract_key = _Hashtable_ebo_helper&lt;0, _ExtractKey&gt;;</a>
<a name="ln1270">      using __ebo_h1 = _Hashtable_ebo_helper&lt;1, _H1&gt;;</a>
<a name="ln1271">      using __ebo_h2 = _Hashtable_ebo_helper&lt;2, _H2&gt;;</a>
<a name="ln1272"> </a>
<a name="ln1273">      // Gives the local iterator implementation access to _M_bucket_index().</a>
<a name="ln1274">      friend struct _Local_iterator_base&lt;_Key, _Value, _ExtractKey, _H1, _H2,</a>
<a name="ln1275">					 _Default_ranged_hash, false&gt;;</a>
<a name="ln1276"> </a>
<a name="ln1277">    public:</a>
<a name="ln1278">      typedef _H1 					hasher;</a>
<a name="ln1279"> </a>
<a name="ln1280">      hasher</a>
<a name="ln1281">      hash_function() const</a>
<a name="ln1282">      { return _M_h1(); }</a>
<a name="ln1283"> </a>
<a name="ln1284">    protected:</a>
<a name="ln1285">      typedef std::size_t 				__hash_code;</a>
<a name="ln1286">      typedef _Hash_node&lt;_Value, false&gt;			__node_type;</a>
<a name="ln1287"> </a>
<a name="ln1288">      // We need the default constructor for the local iterators and _Hashtable</a>
<a name="ln1289">      // default constructor.</a>
<a name="ln1290">      _Hash_code_base() = default;</a>
<a name="ln1291"> </a>
<a name="ln1292">      _Hash_code_base(const _ExtractKey&amp; __ex,</a>
<a name="ln1293">		      const _H1&amp; __h1, const _H2&amp; __h2,</a>
<a name="ln1294">		      const _Default_ranged_hash&amp;)</a>
<a name="ln1295">      : __ebo_extract_key(__ex), __ebo_h1(__h1), __ebo_h2(__h2) { }</a>
<a name="ln1296"> </a>
<a name="ln1297">      __hash_code</a>
<a name="ln1298">      _M_hash_code(const _Key&amp; __k) const</a>
<a name="ln1299">      { return _M_h1()(__k); }</a>
<a name="ln1300"> </a>
<a name="ln1301">      std::size_t</a>
<a name="ln1302">      _M_bucket_index(const _Key&amp;, __hash_code __c, std::size_t __n) const</a>
<a name="ln1303">      { return _M_h2()(__c, __n); }</a>
<a name="ln1304"> </a>
<a name="ln1305">      std::size_t</a>
<a name="ln1306">      _M_bucket_index(const __node_type* __p, std::size_t __n) const</a>
<a name="ln1307">	noexcept( noexcept(declval&lt;const _H1&amp;&gt;()(declval&lt;const _Key&amp;&gt;()))</a>
<a name="ln1308">		  &amp;&amp; noexcept(declval&lt;const _H2&amp;&gt;()((__hash_code)0,</a>
<a name="ln1309">						    (std::size_t)0)) )</a>
<a name="ln1310">      { return _M_h2()(_M_h1()(_M_extract()(__p-&gt;_M_v())), __n); }</a>
<a name="ln1311"> </a>
<a name="ln1312">      void</a>
<a name="ln1313">      _M_store_code(__node_type*, __hash_code) const</a>
<a name="ln1314">      { }</a>
<a name="ln1315"> </a>
<a name="ln1316">      void</a>
<a name="ln1317">      _M_copy_code(__node_type*, const __node_type*) const</a>
<a name="ln1318">      { }</a>
<a name="ln1319"> </a>
<a name="ln1320">      void</a>
<a name="ln1321">      _M_swap(_Hash_code_base&amp; __x)</a>
<a name="ln1322">      {</a>
<a name="ln1323">	std::swap(_M_extract(), __x._M_extract());</a>
<a name="ln1324">	std::swap(_M_h1(), __x._M_h1());</a>
<a name="ln1325">	std::swap(_M_h2(), __x._M_h2());</a>
<a name="ln1326">      }</a>
<a name="ln1327"> </a>
<a name="ln1328">      const _ExtractKey&amp;</a>
<a name="ln1329">      _M_extract() const { return __ebo_extract_key::_S_cget(*this); }</a>
<a name="ln1330"> </a>
<a name="ln1331">      _ExtractKey&amp;</a>
<a name="ln1332">      _M_extract() { return __ebo_extract_key::_S_get(*this); }</a>
<a name="ln1333"> </a>
<a name="ln1334">      const _H1&amp;</a>
<a name="ln1335">      _M_h1() const { return __ebo_h1::_S_cget(*this); }</a>
<a name="ln1336"> </a>
<a name="ln1337">      _H1&amp;</a>
<a name="ln1338">      _M_h1() { return __ebo_h1::_S_get(*this); }</a>
<a name="ln1339"> </a>
<a name="ln1340">      const _H2&amp;</a>
<a name="ln1341">      _M_h2() const { return __ebo_h2::_S_cget(*this); }</a>
<a name="ln1342"> </a>
<a name="ln1343">      _H2&amp;</a>
<a name="ln1344">      _M_h2() { return __ebo_h2::_S_get(*this); }</a>
<a name="ln1345">    };</a>
<a name="ln1346"> </a>
<a name="ln1347">  /// Specialization: hash function and range-hashing function,</a>
<a name="ln1348">  /// caching hash codes.  H is provided but ignored.  Provides</a>
<a name="ln1349">  /// typedef and accessor required by C++ 11.</a>
<a name="ln1350">  template&lt;typename _Key, typename _Value, typename _ExtractKey,</a>
<a name="ln1351">	   typename _H1, typename _H2&gt;</a>
<a name="ln1352">    struct _Hash_code_base&lt;_Key, _Value, _ExtractKey, _H1, _H2,</a>
<a name="ln1353">			   _Default_ranged_hash, true&gt;</a>
<a name="ln1354">    : private _Hashtable_ebo_helper&lt;0, _ExtractKey&gt;,</a>
<a name="ln1355">      private _Hashtable_ebo_helper&lt;1, _H1&gt;,</a>
<a name="ln1356">      private _Hashtable_ebo_helper&lt;2, _H2&gt;</a>
<a name="ln1357">    {</a>
<a name="ln1358">    private:</a>
<a name="ln1359">      // Gives the local iterator implementation access to _M_h2().</a>
<a name="ln1360">      friend struct _Local_iterator_base&lt;_Key, _Value, _ExtractKey, _H1, _H2,</a>
<a name="ln1361">					 _Default_ranged_hash, true&gt;;</a>
<a name="ln1362"> </a>
<a name="ln1363">      using __ebo_extract_key = _Hashtable_ebo_helper&lt;0, _ExtractKey&gt;;</a>
<a name="ln1364">      using __ebo_h1 = _Hashtable_ebo_helper&lt;1, _H1&gt;;</a>
<a name="ln1365">      using __ebo_h2 = _Hashtable_ebo_helper&lt;2, _H2&gt;;</a>
<a name="ln1366"> </a>
<a name="ln1367">    public:</a>
<a name="ln1368">      typedef _H1 					hasher;</a>
<a name="ln1369"> </a>
<a name="ln1370">      hasher</a>
<a name="ln1371">      hash_function() const</a>
<a name="ln1372">      { return _M_h1(); }</a>
<a name="ln1373"> </a>
<a name="ln1374">    protected:</a>
<a name="ln1375">      typedef std::size_t 				__hash_code;</a>
<a name="ln1376">      typedef _Hash_node&lt;_Value, true&gt;			__node_type;</a>
<a name="ln1377"> </a>
<a name="ln1378">      // We need the default constructor for _Hashtable default constructor.</a>
<a name="ln1379">      _Hash_code_base() = default;</a>
<a name="ln1380">      _Hash_code_base(const _ExtractKey&amp; __ex,</a>
<a name="ln1381">		      const _H1&amp; __h1, const _H2&amp; __h2,</a>
<a name="ln1382">		      const _Default_ranged_hash&amp;)</a>
<a name="ln1383">      : __ebo_extract_key(__ex), __ebo_h1(__h1), __ebo_h2(__h2) { }</a>
<a name="ln1384"> </a>
<a name="ln1385">      __hash_code</a>
<a name="ln1386">      _M_hash_code(const _Key&amp; __k) const</a>
<a name="ln1387">      { return _M_h1()(__k); }</a>
<a name="ln1388"> </a>
<a name="ln1389">      std::size_t</a>
<a name="ln1390">      _M_bucket_index(const _Key&amp;, __hash_code __c,</a>
<a name="ln1391">		      std::size_t __n) const</a>
<a name="ln1392">      { return _M_h2()(__c, __n); }</a>
<a name="ln1393"> </a>
<a name="ln1394">      std::size_t</a>
<a name="ln1395">      _M_bucket_index(const __node_type* __p, std::size_t __n) const</a>
<a name="ln1396">	noexcept( noexcept(declval&lt;const _H2&amp;&gt;()((__hash_code)0,</a>
<a name="ln1397">						 (std::size_t)0)) )</a>
<a name="ln1398">      { return _M_h2()(__p-&gt;_M_hash_code, __n); }</a>
<a name="ln1399"> </a>
<a name="ln1400">      void</a>
<a name="ln1401">      _M_store_code(__node_type* __n, __hash_code __c) const</a>
<a name="ln1402">      { __n-&gt;_M_hash_code = __c; }</a>
<a name="ln1403"> </a>
<a name="ln1404">      void</a>
<a name="ln1405">      _M_copy_code(__node_type* __to, const __node_type* __from) const</a>
<a name="ln1406">      { __to-&gt;_M_hash_code = __from-&gt;_M_hash_code; }</a>
<a name="ln1407"> </a>
<a name="ln1408">      void</a>
<a name="ln1409">      _M_swap(_Hash_code_base&amp; __x)</a>
<a name="ln1410">      {</a>
<a name="ln1411">	std::swap(_M_extract(), __x._M_extract());</a>
<a name="ln1412">	std::swap(_M_h1(), __x._M_h1());</a>
<a name="ln1413">	std::swap(_M_h2(), __x._M_h2());</a>
<a name="ln1414">      }</a>
<a name="ln1415"> </a>
<a name="ln1416">      const _ExtractKey&amp;</a>
<a name="ln1417">      _M_extract() const { return __ebo_extract_key::_S_cget(*this); }</a>
<a name="ln1418"> </a>
<a name="ln1419">      _ExtractKey&amp;</a>
<a name="ln1420">      _M_extract() { return __ebo_extract_key::_S_get(*this); }</a>
<a name="ln1421"> </a>
<a name="ln1422">      const _H1&amp;</a>
<a name="ln1423">      _M_h1() const { return __ebo_h1::_S_cget(*this); }</a>
<a name="ln1424"> </a>
<a name="ln1425">      _H1&amp;</a>
<a name="ln1426">      _M_h1() { return __ebo_h1::_S_get(*this); }</a>
<a name="ln1427"> </a>
<a name="ln1428">      const _H2&amp;</a>
<a name="ln1429">      _M_h2() const { return __ebo_h2::_S_cget(*this); }</a>
<a name="ln1430"> </a>
<a name="ln1431">      _H2&amp;</a>
<a name="ln1432">      _M_h2() { return __ebo_h2::_S_get(*this); }</a>
<a name="ln1433">    };</a>
<a name="ln1434"> </a>
<a name="ln1435">  /**</a>
<a name="ln1436">   *  Primary class template _Equal_helper.</a>
<a name="ln1437">   *</a>
<a name="ln1438">   */</a>
<a name="ln1439">  template &lt;typename _Key, typename _Value, typename _ExtractKey,</a>
<a name="ln1440">	    typename _Equal, typename _HashCodeType,</a>
<a name="ln1441">	    bool __cache_hash_code&gt;</a>
<a name="ln1442">  struct _Equal_helper;</a>
<a name="ln1443"> </a>
<a name="ln1444">  /// Specialization.</a>
<a name="ln1445">  template&lt;typename _Key, typename _Value, typename _ExtractKey,</a>
<a name="ln1446">	   typename _Equal, typename _HashCodeType&gt;</a>
<a name="ln1447">  struct _Equal_helper&lt;_Key, _Value, _ExtractKey, _Equal, _HashCodeType, true&gt;</a>
<a name="ln1448">  {</a>
<a name="ln1449">    static bool</a>
<a name="ln1450">    _S_equals(const _Equal&amp; __eq, const _ExtractKey&amp; __extract,</a>
<a name="ln1451">	      const _Key&amp; __k, _HashCodeType __c, _Hash_node&lt;_Value, true&gt;* __n)</a>
<a name="ln1452">    { return __c == __n-&gt;_M_hash_code &amp;&amp; __eq(__k, __extract(__n-&gt;_M_v())); }</a>
<a name="ln1453">  };</a>
<a name="ln1454"> </a>
<a name="ln1455">  /// Specialization.</a>
<a name="ln1456">  template&lt;typename _Key, typename _Value, typename _ExtractKey,</a>
<a name="ln1457">	   typename _Equal, typename _HashCodeType&gt;</a>
<a name="ln1458">  struct _Equal_helper&lt;_Key, _Value, _ExtractKey, _Equal, _HashCodeType, false&gt;</a>
<a name="ln1459">  {</a>
<a name="ln1460">    static bool</a>
<a name="ln1461">    _S_equals(const _Equal&amp; __eq, const _ExtractKey&amp; __extract,</a>
<a name="ln1462">	      const _Key&amp; __k, _HashCodeType, _Hash_node&lt;_Value, false&gt;* __n)</a>
<a name="ln1463">    { return __eq(__k, __extract(__n-&gt;_M_v())); }</a>
<a name="ln1464">  };</a>
<a name="ln1465"> </a>
<a name="ln1466"> </a>
<a name="ln1467">  /// Partial specialization used when nodes contain a cached hash code.</a>
<a name="ln1468">  template&lt;typename _Key, typename _Value, typename _ExtractKey,</a>
<a name="ln1469">	   typename _H1, typename _H2, typename _Hash&gt;</a>
<a name="ln1470">    struct _Local_iterator_base&lt;_Key, _Value, _ExtractKey,</a>
<a name="ln1471">				_H1, _H2, _Hash, true&gt;</a>
<a name="ln1472">    : private _Hashtable_ebo_helper&lt;0, _H2&gt;</a>
<a name="ln1473">    {</a>
<a name="ln1474">    protected:</a>
<a name="ln1475">      using __base_type = _Hashtable_ebo_helper&lt;0, _H2&gt;;</a>
<a name="ln1476">      using __hash_code_base = _Hash_code_base&lt;_Key, _Value, _ExtractKey,</a>
<a name="ln1477">					       _H1, _H2, _Hash, true&gt;;</a>
<a name="ln1478"> </a>
<a name="ln1479">      _Local_iterator_base() = default;</a>
<a name="ln1480">      _Local_iterator_base(const __hash_code_base&amp; __base,</a>
<a name="ln1481">			   _Hash_node&lt;_Value, true&gt;* __p,</a>
<a name="ln1482">			   std::size_t __bkt, std::size_t __bkt_count)</a>
<a name="ln1483">      : __base_type(__base._M_h2()),</a>
<a name="ln1484">	_M_cur(__p), _M_bucket(__bkt), _M_bucket_count(__bkt_count) { }</a>
<a name="ln1485"> </a>
<a name="ln1486">      void</a>
<a name="ln1487">      _M_incr()</a>
<a name="ln1488">      {</a>
<a name="ln1489">	_M_cur = _M_cur-&gt;_M_next();</a>
<a name="ln1490">	if (_M_cur)</a>
<a name="ln1491">	  {</a>
<a name="ln1492">	    std::size_t __bkt</a>
<a name="ln1493">	      = __base_type::_S_get(*this)(_M_cur-&gt;_M_hash_code,</a>
<a name="ln1494">					   _M_bucket_count);</a>
<a name="ln1495">	    if (__bkt != _M_bucket)</a>
<a name="ln1496">	      _M_cur = nullptr;</a>
<a name="ln1497">	  }</a>
<a name="ln1498">      }</a>
<a name="ln1499"> </a>
<a name="ln1500">      _Hash_node&lt;_Value, true&gt;*  _M_cur;</a>
<a name="ln1501">      std::size_t _M_bucket;</a>
<a name="ln1502">      std::size_t _M_bucket_count;</a>
<a name="ln1503"> </a>
<a name="ln1504">    public:</a>
<a name="ln1505">      const void*</a>
<a name="ln1506">      _M_curr() const { return _M_cur; }  // for equality ops</a>
<a name="ln1507"> </a>
<a name="ln1508">      std::size_t</a>
<a name="ln1509">      _M_get_bucket() const { return _M_bucket; }  // for debug mode</a>
<a name="ln1510">    };</a>
<a name="ln1511"> </a>
<a name="ln1512">  // Uninitialized storage for a _Hash_code_base.</a>
<a name="ln1513">  // This type is DefaultConstructible and Assignable even if the</a>
<a name="ln1514">  // _Hash_code_base type isn't, so that _Local_iterator_base&lt;..., false&gt;</a>
<a name="ln1515">  // can be DefaultConstructible and Assignable.</a>
<a name="ln1516">  template&lt;typename _Tp, bool _IsEmpty = std::is_empty&lt;_Tp&gt;::value&gt;</a>
<a name="ln1517">    struct _Hash_code_storage</a>
<a name="ln1518">    {</a>
<a name="ln1519">      __gnu_cxx::__aligned_buffer&lt;_Tp&gt; _M_storage;</a>
<a name="ln1520"> </a>
<a name="ln1521">      _Tp*</a>
<a name="ln1522">      _M_h() { return _M_storage._M_ptr(); }</a>
<a name="ln1523"> </a>
<a name="ln1524">      const _Tp*</a>
<a name="ln1525">      _M_h() const { return _M_storage._M_ptr(); }</a>
<a name="ln1526">    };</a>
<a name="ln1527"> </a>
<a name="ln1528">  // Empty partial specialization for empty _Hash_code_base types.</a>
<a name="ln1529">  template&lt;typename _Tp&gt;</a>
<a name="ln1530">    struct _Hash_code_storage&lt;_Tp, true&gt;</a>
<a name="ln1531">    {</a>
<a name="ln1532">      static_assert( std::is_empty&lt;_Tp&gt;::value, &quot;Type must be empty&quot; );</a>
<a name="ln1533"> </a>
<a name="ln1534">      // As _Tp is an empty type there will be no bytes written/read through</a>
<a name="ln1535">      // the cast pointer, so no strict-aliasing violation.</a>
<a name="ln1536">      _Tp*</a>
<a name="ln1537">      _M_h() { return reinterpret_cast&lt;_Tp*&gt;(this); }</a>
<a name="ln1538"> </a>
<a name="ln1539">      const _Tp*</a>
<a name="ln1540">      _M_h() const { return reinterpret_cast&lt;const _Tp*&gt;(this); }</a>
<a name="ln1541">    };</a>
<a name="ln1542"> </a>
<a name="ln1543">  template&lt;typename _Key, typename _Value, typename _ExtractKey,</a>
<a name="ln1544">	   typename _H1, typename _H2, typename _Hash&gt;</a>
<a name="ln1545">    using __hash_code_for_local_iter</a>
<a name="ln1546">      = _Hash_code_storage&lt;_Hash_code_base&lt;_Key, _Value, _ExtractKey,</a>
<a name="ln1547">					   _H1, _H2, _Hash, false&gt;&gt;;</a>
<a name="ln1548"> </a>
<a name="ln1549">  // Partial specialization used when hash codes are not cached</a>
<a name="ln1550">  template&lt;typename _Key, typename _Value, typename _ExtractKey,</a>
<a name="ln1551">	   typename _H1, typename _H2, typename _Hash&gt;</a>
<a name="ln1552">    struct _Local_iterator_base&lt;_Key, _Value, _ExtractKey,</a>
<a name="ln1553">				_H1, _H2, _Hash, false&gt;</a>
<a name="ln1554">    : __hash_code_for_local_iter&lt;_Key, _Value, _ExtractKey, _H1, _H2, _Hash&gt;</a>
<a name="ln1555">    {</a>
<a name="ln1556">    protected:</a>
<a name="ln1557">      using __hash_code_base = _Hash_code_base&lt;_Key, _Value, _ExtractKey,</a>
<a name="ln1558">					       _H1, _H2, _Hash, false&gt;;</a>
<a name="ln1559"> </a>
<a name="ln1560">      _Local_iterator_base() : _M_bucket_count(-1) { }</a>
<a name="ln1561"> </a>
<a name="ln1562">      _Local_iterator_base(const __hash_code_base&amp; __base,</a>
<a name="ln1563">			   _Hash_node&lt;_Value, false&gt;* __p,</a>
<a name="ln1564">			   std::size_t __bkt, std::size_t __bkt_count)</a>
<a name="ln1565">      : _M_cur(__p), _M_bucket(__bkt), _M_bucket_count(__bkt_count)</a>
<a name="ln1566">      { _M_init(__base); }</a>
<a name="ln1567"> </a>
<a name="ln1568">      ~_Local_iterator_base()</a>
<a name="ln1569">      {</a>
<a name="ln1570">	if (_M_bucket_count != -1)</a>
<a name="ln1571">	  _M_destroy();</a>
<a name="ln1572">      }</a>
<a name="ln1573"> </a>
<a name="ln1574">      _Local_iterator_base(const _Local_iterator_base&amp; __iter)</a>
<a name="ln1575">      : _M_cur(__iter._M_cur), _M_bucket(__iter._M_bucket),</a>
<a name="ln1576">        _M_bucket_count(__iter._M_bucket_count)</a>
<a name="ln1577">      {</a>
<a name="ln1578">	if (_M_bucket_count != -1)</a>
<a name="ln1579">	  _M_init(*__iter._M_h());</a>
<a name="ln1580">      }</a>
<a name="ln1581"> </a>
<a name="ln1582">      _Local_iterator_base&amp;</a>
<a name="ln1583">      operator=(const _Local_iterator_base&amp; __iter)</a>
<a name="ln1584">      {</a>
<a name="ln1585">	if (_M_bucket_count != -1)</a>
<a name="ln1586">	  _M_destroy();</a>
<a name="ln1587">	_M_cur = __iter._M_cur;</a>
<a name="ln1588">	_M_bucket = __iter._M_bucket;</a>
<a name="ln1589">	_M_bucket_count = __iter._M_bucket_count;</a>
<a name="ln1590">	if (_M_bucket_count != -1)</a>
<a name="ln1591">	  _M_init(*__iter._M_h());</a>
<a name="ln1592">	return *this;</a>
<a name="ln1593">      }</a>
<a name="ln1594"> </a>
<a name="ln1595">      void</a>
<a name="ln1596">      _M_incr()</a>
<a name="ln1597">      {</a>
<a name="ln1598">	_M_cur = _M_cur-&gt;_M_next();</a>
<a name="ln1599">	if (_M_cur)</a>
<a name="ln1600">	  {</a>
<a name="ln1601">	    std::size_t __bkt = this-&gt;_M_h()-&gt;_M_bucket_index(_M_cur,</a>
<a name="ln1602">							      _M_bucket_count);</a>
<a name="ln1603">	    if (__bkt != _M_bucket)</a>
<a name="ln1604">	      _M_cur = nullptr;</a>
<a name="ln1605">	  }</a>
<a name="ln1606">      }</a>
<a name="ln1607"> </a>
<a name="ln1608">      _Hash_node&lt;_Value, false&gt;*  _M_cur;</a>
<a name="ln1609">      std::size_t _M_bucket;</a>
<a name="ln1610">      std::size_t _M_bucket_count;</a>
<a name="ln1611"> </a>
<a name="ln1612">      void</a>
<a name="ln1613">      _M_init(const __hash_code_base&amp; __base)</a>
<a name="ln1614">      { ::new(this-&gt;_M_h()) __hash_code_base(__base); }</a>
<a name="ln1615"> </a>
<a name="ln1616">      void</a>
<a name="ln1617">      _M_destroy() { this-&gt;_M_h()-&gt;~__hash_code_base(); }</a>
<a name="ln1618"> </a>
<a name="ln1619">    public:</a>
<a name="ln1620">      const void*</a>
<a name="ln1621">      _M_curr() const { return _M_cur; }  // for equality ops and debug mode</a>
<a name="ln1622"> </a>
<a name="ln1623">      std::size_t</a>
<a name="ln1624">      _M_get_bucket() const { return _M_bucket; }  // for debug mode</a>
<a name="ln1625">    };</a>
<a name="ln1626"> </a>
<a name="ln1627">  template&lt;typename _Key, typename _Value, typename _ExtractKey,</a>
<a name="ln1628">	   typename _H1, typename _H2, typename _Hash, bool __cache&gt;</a>
<a name="ln1629">    inline bool</a>
<a name="ln1630">    operator==(const _Local_iterator_base&lt;_Key, _Value, _ExtractKey,</a>
<a name="ln1631">					  _H1, _H2, _Hash, __cache&gt;&amp; __x,</a>
<a name="ln1632">	       const _Local_iterator_base&lt;_Key, _Value, _ExtractKey,</a>
<a name="ln1633">					  _H1, _H2, _Hash, __cache&gt;&amp; __y)</a>
<a name="ln1634">    { return __x._M_curr() == __y._M_curr(); }</a>
<a name="ln1635"> </a>
<a name="ln1636">  template&lt;typename _Key, typename _Value, typename _ExtractKey,</a>
<a name="ln1637">	   typename _H1, typename _H2, typename _Hash, bool __cache&gt;</a>
<a name="ln1638">    inline bool</a>
<a name="ln1639">    operator!=(const _Local_iterator_base&lt;_Key, _Value, _ExtractKey,</a>
<a name="ln1640">					  _H1, _H2, _Hash, __cache&gt;&amp; __x,</a>
<a name="ln1641">	       const _Local_iterator_base&lt;_Key, _Value, _ExtractKey,</a>
<a name="ln1642">					  _H1, _H2, _Hash, __cache&gt;&amp; __y)</a>
<a name="ln1643">    { return __x._M_curr() != __y._M_curr(); }</a>
<a name="ln1644"> </a>
<a name="ln1645">  /// local iterators</a>
<a name="ln1646">  template&lt;typename _Key, typename _Value, typename _ExtractKey,</a>
<a name="ln1647">	   typename _H1, typename _H2, typename _Hash,</a>
<a name="ln1648">	   bool __constant_iterators, bool __cache&gt;</a>
<a name="ln1649">    struct _Local_iterator</a>
<a name="ln1650">    : public _Local_iterator_base&lt;_Key, _Value, _ExtractKey,</a>
<a name="ln1651">				  _H1, _H2, _Hash, __cache&gt;</a>
<a name="ln1652">    {</a>
<a name="ln1653">    private:</a>
<a name="ln1654">      using __base_type = _Local_iterator_base&lt;_Key, _Value, _ExtractKey,</a>
<a name="ln1655">					       _H1, _H2, _Hash, __cache&gt;;</a>
<a name="ln1656">      using __hash_code_base = typename __base_type::__hash_code_base;</a>
<a name="ln1657">    public:</a>
<a name="ln1658">      typedef _Value					value_type;</a>
<a name="ln1659">      typedef typename std::conditional&lt;__constant_iterators,</a>
<a name="ln1660">					const _Value*, _Value*&gt;::type</a>
<a name="ln1661">						       pointer;</a>
<a name="ln1662">      typedef typename std::conditional&lt;__constant_iterators,</a>
<a name="ln1663">					const _Value&amp;, _Value&amp;&gt;::type</a>
<a name="ln1664">						       reference;</a>
<a name="ln1665">      typedef std::ptrdiff_t				difference_type;</a>
<a name="ln1666">      typedef std::forward_iterator_tag			iterator_category;</a>
<a name="ln1667"> </a>
<a name="ln1668">      _Local_iterator() = default;</a>
<a name="ln1669"> </a>
<a name="ln1670">      _Local_iterator(const __hash_code_base&amp; __base,</a>
<a name="ln1671">		      _Hash_node&lt;_Value, __cache&gt;* __p,</a>
<a name="ln1672">		      std::size_t __bkt, std::size_t __bkt_count)</a>
<a name="ln1673">	: __base_type(__base, __p, __bkt, __bkt_count)</a>
<a name="ln1674">      { }</a>
<a name="ln1675"> </a>
<a name="ln1676">      reference</a>
<a name="ln1677">      operator*() const</a>
<a name="ln1678">      { return this-&gt;_M_cur-&gt;_M_v(); }</a>
<a name="ln1679"> </a>
<a name="ln1680">      pointer</a>
<a name="ln1681">      operator-&gt;() const</a>
<a name="ln1682">      { return this-&gt;_M_cur-&gt;_M_valptr(); }</a>
<a name="ln1683"> </a>
<a name="ln1684">      _Local_iterator&amp;</a>
<a name="ln1685">      operator++()</a>
<a name="ln1686">      {</a>
<a name="ln1687">	this-&gt;_M_incr();</a>
<a name="ln1688">	return *this;</a>
<a name="ln1689">      }</a>
<a name="ln1690"> </a>
<a name="ln1691">      _Local_iterator</a>
<a name="ln1692">      operator++(int)</a>
<a name="ln1693">      {</a>
<a name="ln1694">	_Local_iterator __tmp(*this);</a>
<a name="ln1695">	this-&gt;_M_incr();</a>
<a name="ln1696">	return __tmp;</a>
<a name="ln1697">      }</a>
<a name="ln1698">    };</a>
<a name="ln1699"> </a>
<a name="ln1700">  /// local const_iterators</a>
<a name="ln1701">  template&lt;typename _Key, typename _Value, typename _ExtractKey,</a>
<a name="ln1702">	   typename _H1, typename _H2, typename _Hash,</a>
<a name="ln1703">	   bool __constant_iterators, bool __cache&gt;</a>
<a name="ln1704">    struct _Local_const_iterator</a>
<a name="ln1705">    : public _Local_iterator_base&lt;_Key, _Value, _ExtractKey,</a>
<a name="ln1706">				  _H1, _H2, _Hash, __cache&gt;</a>
<a name="ln1707">    {</a>
<a name="ln1708">    private:</a>
<a name="ln1709">      using __base_type = _Local_iterator_base&lt;_Key, _Value, _ExtractKey,</a>
<a name="ln1710">					       _H1, _H2, _Hash, __cache&gt;;</a>
<a name="ln1711">      using __hash_code_base = typename __base_type::__hash_code_base;</a>
<a name="ln1712"> </a>
<a name="ln1713">    public:</a>
<a name="ln1714">      typedef _Value					value_type;</a>
<a name="ln1715">      typedef const _Value*				pointer;</a>
<a name="ln1716">      typedef const _Value&amp;				reference;</a>
<a name="ln1717">      typedef std::ptrdiff_t				difference_type;</a>
<a name="ln1718">      typedef std::forward_iterator_tag			iterator_category;</a>
<a name="ln1719"> </a>
<a name="ln1720">      _Local_const_iterator() = default;</a>
<a name="ln1721"> </a>
<a name="ln1722">      _Local_const_iterator(const __hash_code_base&amp; __base,</a>
<a name="ln1723">			    _Hash_node&lt;_Value, __cache&gt;* __p,</a>
<a name="ln1724">			    std::size_t __bkt, std::size_t __bkt_count)</a>
<a name="ln1725">	: __base_type(__base, __p, __bkt, __bkt_count)</a>
<a name="ln1726">      { }</a>
<a name="ln1727"> </a>
<a name="ln1728">      _Local_const_iterator(const _Local_iterator&lt;_Key, _Value, _ExtractKey,</a>
<a name="ln1729">						  _H1, _H2, _Hash,</a>
<a name="ln1730">						  __constant_iterators,</a>
<a name="ln1731">						  __cache&gt;&amp; __x)</a>
<a name="ln1732">	: __base_type(__x)</a>
<a name="ln1733">      { }</a>
<a name="ln1734"> </a>
<a name="ln1735">      reference</a>
<a name="ln1736">      operator*() const</a>
<a name="ln1737">      { return this-&gt;_M_cur-&gt;_M_v(); }</a>
<a name="ln1738"> </a>
<a name="ln1739">      pointer</a>
<a name="ln1740">      operator-&gt;() const</a>
<a name="ln1741">      { return this-&gt;_M_cur-&gt;_M_valptr(); }</a>
<a name="ln1742"> </a>
<a name="ln1743">      _Local_const_iterator&amp;</a>
<a name="ln1744">      operator++()</a>
<a name="ln1745">      {</a>
<a name="ln1746">	this-&gt;_M_incr();</a>
<a name="ln1747">	return *this;</a>
<a name="ln1748">      }</a>
<a name="ln1749"> </a>
<a name="ln1750">      _Local_const_iterator</a>
<a name="ln1751">      operator++(int)</a>
<a name="ln1752">      {</a>
<a name="ln1753">	_Local_const_iterator __tmp(*this);</a>
<a name="ln1754">	this-&gt;_M_incr();</a>
<a name="ln1755">	return __tmp;</a>
<a name="ln1756">      }</a>
<a name="ln1757">    };</a>
<a name="ln1758"> </a>
<a name="ln1759">  /**</a>
<a name="ln1760">   *  Primary class template _Hashtable_base.</a>
<a name="ln1761">   *</a>
<a name="ln1762">   *  Helper class adding management of _Equal functor to</a>
<a name="ln1763">   *  _Hash_code_base type.</a>
<a name="ln1764">   *</a>
<a name="ln1765">   *  Base class templates are:</a>
<a name="ln1766">   *    - __detail::_Hash_code_base</a>
<a name="ln1767">   *    - __detail::_Hashtable_ebo_helper</a>
<a name="ln1768">   */</a>
<a name="ln1769">  template&lt;typename _Key, typename _Value,</a>
<a name="ln1770">	   typename _ExtractKey, typename _Equal,</a>
<a name="ln1771">	   typename _H1, typename _H2, typename _Hash, typename _Traits&gt;</a>
<a name="ln1772">  struct _Hashtable_base</a>
<a name="ln1773">  : public _Hash_code_base&lt;_Key, _Value, _ExtractKey, _H1, _H2, _Hash,</a>
<a name="ln1774">			   _Traits::__hash_cached::value&gt;,</a>
<a name="ln1775">    private _Hashtable_ebo_helper&lt;0, _Equal&gt;</a>
<a name="ln1776">  {</a>
<a name="ln1777">  public:</a>
<a name="ln1778">    typedef _Key					key_type;</a>
<a name="ln1779">    typedef _Value					value_type;</a>
<a name="ln1780">    typedef _Equal					key_equal;</a>
<a name="ln1781">    typedef std::size_t					size_type;</a>
<a name="ln1782">    typedef std::ptrdiff_t				difference_type;</a>
<a name="ln1783"> </a>
<a name="ln1784">    using __traits_type = _Traits;</a>
<a name="ln1785">    using __hash_cached = typename __traits_type::__hash_cached;</a>
<a name="ln1786">    using __constant_iterators = typename __traits_type::__constant_iterators;</a>
<a name="ln1787">    using __unique_keys = typename __traits_type::__unique_keys;</a>
<a name="ln1788"> </a>
<a name="ln1789">    using __hash_code_base = _Hash_code_base&lt;_Key, _Value, _ExtractKey,</a>
<a name="ln1790">					     _H1, _H2, _Hash,</a>
<a name="ln1791">					     __hash_cached::value&gt;;</a>
<a name="ln1792"> </a>
<a name="ln1793">    using __hash_code = typename __hash_code_base::__hash_code;</a>
<a name="ln1794">    using __node_type = typename __hash_code_base::__node_type;</a>
<a name="ln1795"> </a>
<a name="ln1796">    using iterator = __detail::_Node_iterator&lt;value_type,</a>
<a name="ln1797">					      __constant_iterators::value,</a>
<a name="ln1798">					      __hash_cached::value&gt;;</a>
<a name="ln1799"> </a>
<a name="ln1800">    using const_iterator = __detail::_Node_const_iterator&lt;value_type,</a>
<a name="ln1801">						   __constant_iterators::value,</a>
<a name="ln1802">						   __hash_cached::value&gt;;</a>
<a name="ln1803"> </a>
<a name="ln1804">    using local_iterator = __detail::_Local_iterator&lt;key_type, value_type,</a>
<a name="ln1805">						  _ExtractKey, _H1, _H2, _Hash,</a>
<a name="ln1806">						  __constant_iterators::value,</a>
<a name="ln1807">						     __hash_cached::value&gt;;</a>
<a name="ln1808"> </a>
<a name="ln1809">    using const_local_iterator = __detail::_Local_const_iterator&lt;key_type,</a>
<a name="ln1810">								 value_type,</a>
<a name="ln1811">					_ExtractKey, _H1, _H2, _Hash,</a>
<a name="ln1812">					__constant_iterators::value,</a>
<a name="ln1813">					__hash_cached::value&gt;;</a>
<a name="ln1814"> </a>
<a name="ln1815">    using __ireturn_type = typename std::conditional&lt;__unique_keys::value,</a>
<a name="ln1816">						     std::pair&lt;iterator, bool&gt;,</a>
<a name="ln1817">						     iterator&gt;::type;</a>
<a name="ln1818">  private:</a>
<a name="ln1819">    using _EqualEBO = _Hashtable_ebo_helper&lt;0, _Equal&gt;;</a>
<a name="ln1820">    using _EqualHelper =  _Equal_helper&lt;_Key, _Value, _ExtractKey, _Equal,</a>
<a name="ln1821">					__hash_code, __hash_cached::value&gt;;</a>
<a name="ln1822"> </a>
<a name="ln1823">  protected:</a>
<a name="ln1824">    _Hashtable_base() = default;</a>
<a name="ln1825">    _Hashtable_base(const _ExtractKey&amp; __ex, const _H1&amp; __h1, const _H2&amp; __h2,</a>
<a name="ln1826">		    const _Hash&amp; __hash, const _Equal&amp; __eq)</a>
<a name="ln1827">    : __hash_code_base(__ex, __h1, __h2, __hash), _EqualEBO(__eq)</a>
<a name="ln1828">    { }</a>
<a name="ln1829"> </a>
<a name="ln1830">    bool</a>
<a name="ln1831">    _M_equals(const _Key&amp; __k, __hash_code __c, __node_type* __n) const</a>
<a name="ln1832">    {</a>
<a name="ln1833">      return _EqualHelper::_S_equals(_M_eq(), this-&gt;_M_extract(),</a>
<a name="ln1834">				     __k, __c, __n);</a>
<a name="ln1835">    }</a>
<a name="ln1836"> </a>
<a name="ln1837">    void</a>
<a name="ln1838">    _M_swap(_Hashtable_base&amp; __x)</a>
<a name="ln1839">    {</a>
<a name="ln1840">      __hash_code_base::_M_swap(__x);</a>
<a name="ln1841">      std::swap(_M_eq(), __x._M_eq());</a>
<a name="ln1842">    }</a>
<a name="ln1843"> </a>
<a name="ln1844">    const _Equal&amp;</a>
<a name="ln1845">    _M_eq() const { return _EqualEBO::_S_cget(*this); }</a>
<a name="ln1846"> </a>
<a name="ln1847">    _Equal&amp;</a>
<a name="ln1848">    _M_eq() { return _EqualEBO::_S_get(*this); }</a>
<a name="ln1849">  };</a>
<a name="ln1850"> </a>
<a name="ln1851">  /**</a>
<a name="ln1852">   *  struct _Equality_base.</a>
<a name="ln1853">   *</a>
<a name="ln1854">   *  Common types and functions for class _Equality.</a>
<a name="ln1855">   */</a>
<a name="ln1856">  struct _Equality_base</a>
<a name="ln1857">  {</a>
<a name="ln1858">  protected:</a>
<a name="ln1859">    template&lt;typename _Uiterator&gt;</a>
<a name="ln1860">      static bool</a>
<a name="ln1861">      _S_is_permutation(_Uiterator, _Uiterator, _Uiterator);</a>
<a name="ln1862">  };</a>
<a name="ln1863"> </a>
<a name="ln1864">  // See std::is_permutation in N3068.</a>
<a name="ln1865">  template&lt;typename _Uiterator&gt;</a>
<a name="ln1866">    bool</a>
<a name="ln1867">    _Equality_base::</a>
<a name="ln1868">    _S_is_permutation(_Uiterator __first1, _Uiterator __last1,</a>
<a name="ln1869">		      _Uiterator __first2)</a>
<a name="ln1870">    {</a>
<a name="ln1871">      for (; __first1 != __last1; ++__first1, ++__first2)</a>
<a name="ln1872">	if (!(*__first1 == *__first2))</a>
<a name="ln1873">	  break;</a>
<a name="ln1874"> </a>
<a name="ln1875">      if (__first1 == __last1)</a>
<a name="ln1876">	return true;</a>
<a name="ln1877"> </a>
<a name="ln1878">      _Uiterator __last2 = __first2;</a>
<a name="ln1879">      std::advance(__last2, std::distance(__first1, __last1));</a>
<a name="ln1880"> </a>
<a name="ln1881">      for (_Uiterator __it1 = __first1; __it1 != __last1; ++__it1)</a>
<a name="ln1882">	{</a>
<a name="ln1883">	  _Uiterator __tmp =  __first1;</a>
<a name="ln1884">	  while (__tmp != __it1 &amp;&amp; !bool(*__tmp == *__it1))</a>
<a name="ln1885">	    ++__tmp;</a>
<a name="ln1886"> </a>
<a name="ln1887">	  // We've seen this one before.</a>
<a name="ln1888">	  if (__tmp != __it1)</a>
<a name="ln1889">	    continue;</a>
<a name="ln1890"> </a>
<a name="ln1891">	  std::ptrdiff_t __n2 = 0;</a>
<a name="ln1892">	  for (__tmp = __first2; __tmp != __last2; ++__tmp)</a>
<a name="ln1893">	    if (*__tmp == *__it1)</a>
<a name="ln1894">	      ++__n2;</a>
<a name="ln1895"> </a>
<a name="ln1896">	  if (!__n2)</a>
<a name="ln1897">	    return false;</a>
<a name="ln1898"> </a>
<a name="ln1899">	  std::ptrdiff_t __n1 = 0;</a>
<a name="ln1900">	  for (__tmp = __it1; __tmp != __last1; ++__tmp)</a>
<a name="ln1901">	    if (*__tmp == *__it1)</a>
<a name="ln1902">	      ++__n1;</a>
<a name="ln1903"> </a>
<a name="ln1904">	  if (__n1 != __n2)</a>
<a name="ln1905">	    return false;</a>
<a name="ln1906">	}</a>
<a name="ln1907">      return true;</a>
<a name="ln1908">    }</a>
<a name="ln1909"> </a>
<a name="ln1910">  /**</a>
<a name="ln1911">   *  Primary class template  _Equality.</a>
<a name="ln1912">   *</a>
<a name="ln1913">   *  This is for implementing equality comparison for unordered</a>
<a name="ln1914">   *  containers, per N3068, by John Lakos and Pablo Halpern.</a>
<a name="ln1915">   *  Algorithmically, we follow closely the reference implementations</a>
<a name="ln1916">   *  therein.</a>
<a name="ln1917">   */</a>
<a name="ln1918">  template&lt;typename _Key, typename _Value, typename _Alloc,</a>
<a name="ln1919">	   typename _ExtractKey, typename _Equal,</a>
<a name="ln1920">	   typename _H1, typename _H2, typename _Hash,</a>
<a name="ln1921">	   typename _RehashPolicy, typename _Traits,</a>
<a name="ln1922">	   bool _Unique_keys = _Traits::__unique_keys::value&gt;</a>
<a name="ln1923">    struct _Equality;</a>
<a name="ln1924"> </a>
<a name="ln1925">  /// Specialization.</a>
<a name="ln1926">  template&lt;typename _Key, typename _Value, typename _Alloc,</a>
<a name="ln1927">	   typename _ExtractKey, typename _Equal,</a>
<a name="ln1928">	   typename _H1, typename _H2, typename _Hash,</a>
<a name="ln1929">	   typename _RehashPolicy, typename _Traits&gt;</a>
<a name="ln1930">    struct _Equality&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal,</a>
<a name="ln1931">		     _H1, _H2, _Hash, _RehashPolicy, _Traits, true&gt;</a>
<a name="ln1932">    {</a>
<a name="ln1933">      using __hashtable = _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal,</a>
<a name="ln1934">				     _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;;</a>
<a name="ln1935"> </a>
<a name="ln1936">      bool</a>
<a name="ln1937">      _M_equal(const __hashtable&amp;) const;</a>
<a name="ln1938">    };</a>
<a name="ln1939"> </a>
<a name="ln1940">  template&lt;typename _Key, typename _Value, typename _Alloc,</a>
<a name="ln1941">	   typename _ExtractKey, typename _Equal,</a>
<a name="ln1942">	   typename _H1, typename _H2, typename _Hash,</a>
<a name="ln1943">	   typename _RehashPolicy, typename _Traits&gt;</a>
<a name="ln1944">    bool</a>
<a name="ln1945">    _Equality&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal,</a>
<a name="ln1946">	      _H1, _H2, _Hash, _RehashPolicy, _Traits, true&gt;::</a>
<a name="ln1947">    _M_equal(const __hashtable&amp; __other) const</a>
<a name="ln1948">    {</a>
<a name="ln1949">      const __hashtable* __this = static_cast&lt;const __hashtable*&gt;(this);</a>
<a name="ln1950"> </a>
<a name="ln1951">      if (__this-&gt;size() != __other.size())</a>
<a name="ln1952">	return false;</a>
<a name="ln1953"> </a>
<a name="ln1954">      for (auto __itx = __this-&gt;begin(); __itx != __this-&gt;end(); ++__itx)</a>
<a name="ln1955">	{</a>
<a name="ln1956">	  const auto __ity = __other.find(_ExtractKey()(*__itx));</a>
<a name="ln1957">	  if (__ity == __other.end() || !bool(*__ity == *__itx))</a>
<a name="ln1958">	    return false;</a>
<a name="ln1959">	}</a>
<a name="ln1960">      return true;</a>
<a name="ln1961">    }</a>
<a name="ln1962"> </a>
<a name="ln1963">  /// Specialization.</a>
<a name="ln1964">  template&lt;typename _Key, typename _Value, typename _Alloc,</a>
<a name="ln1965">	   typename _ExtractKey, typename _Equal,</a>
<a name="ln1966">	   typename _H1, typename _H2, typename _Hash,</a>
<a name="ln1967">	   typename _RehashPolicy, typename _Traits&gt;</a>
<a name="ln1968">    struct _Equality&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal,</a>
<a name="ln1969">		     _H1, _H2, _Hash, _RehashPolicy, _Traits, false&gt;</a>
<a name="ln1970">    : public _Equality_base</a>
<a name="ln1971">    {</a>
<a name="ln1972">      using __hashtable = _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal,</a>
<a name="ln1973">				     _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;;</a>
<a name="ln1974"> </a>
<a name="ln1975">      bool</a>
<a name="ln1976">      _M_equal(const __hashtable&amp;) const;</a>
<a name="ln1977">    };</a>
<a name="ln1978"> </a>
<a name="ln1979">  template&lt;typename _Key, typename _Value, typename _Alloc,</a>
<a name="ln1980">	   typename _ExtractKey, typename _Equal,</a>
<a name="ln1981">	   typename _H1, typename _H2, typename _Hash,</a>
<a name="ln1982">	   typename _RehashPolicy, typename _Traits&gt;</a>
<a name="ln1983">    bool</a>
<a name="ln1984">    _Equality&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal,</a>
<a name="ln1985">	      _H1, _H2, _Hash, _RehashPolicy, _Traits, false&gt;::</a>
<a name="ln1986">    _M_equal(const __hashtable&amp; __other) const</a>
<a name="ln1987">    {</a>
<a name="ln1988">      const __hashtable* __this = static_cast&lt;const __hashtable*&gt;(this);</a>
<a name="ln1989"> </a>
<a name="ln1990">      if (__this-&gt;size() != __other.size())</a>
<a name="ln1991">	return false;</a>
<a name="ln1992"> </a>
<a name="ln1993">      for (auto __itx = __this-&gt;begin(); __itx != __this-&gt;end();)</a>
<a name="ln1994">	{</a>
<a name="ln1995">	  const auto __xrange = __this-&gt;equal_range(_ExtractKey()(*__itx));</a>
<a name="ln1996">	  const auto __yrange = __other.equal_range(_ExtractKey()(*__itx));</a>
<a name="ln1997"> </a>
<a name="ln1998">	  if (std::distance(__xrange.first, __xrange.second)</a>
<a name="ln1999">	      != std::distance(__yrange.first, __yrange.second))</a>
<a name="ln2000">	    return false;</a>
<a name="ln2001"> </a>
<a name="ln2002">	  if (!_S_is_permutation(__xrange.first, __xrange.second,</a>
<a name="ln2003">				 __yrange.first))</a>
<a name="ln2004">	    return false;</a>
<a name="ln2005"> </a>
<a name="ln2006">	  __itx = __xrange.second;</a>
<a name="ln2007">	}</a>
<a name="ln2008">      return true;</a>
<a name="ln2009">    }</a>
<a name="ln2010"> </a>
<a name="ln2011">  /**</a>
<a name="ln2012">   * This type deals with all allocation and keeps an allocator instance through</a>
<a name="ln2013">   * inheritance to benefit from EBO when possible.</a>
<a name="ln2014">   */</a>
<a name="ln2015">  template&lt;typename _NodeAlloc&gt;</a>
<a name="ln2016">    struct _Hashtable_alloc : private _Hashtable_ebo_helper&lt;0, _NodeAlloc&gt;</a>
<a name="ln2017">    {</a>
<a name="ln2018">    private:</a>
<a name="ln2019">      using __ebo_node_alloc = _Hashtable_ebo_helper&lt;0, _NodeAlloc&gt;;</a>
<a name="ln2020">    public:</a>
<a name="ln2021">      using __node_type = typename _NodeAlloc::value_type;</a>
<a name="ln2022">      using __node_alloc_type = _NodeAlloc;</a>
<a name="ln2023">      // Use __gnu_cxx to benefit from _S_always_equal and al.</a>
<a name="ln2024">      using __node_alloc_traits = __gnu_cxx::__alloc_traits&lt;__node_alloc_type&gt;;</a>
<a name="ln2025"> </a>
<a name="ln2026">      using __value_alloc_traits = typename __node_alloc_traits::template</a>
<a name="ln2027">	rebind_traits&lt;typename __node_type::value_type&gt;;</a>
<a name="ln2028"> </a>
<a name="ln2029">      using __node_base = __detail::_Hash_node_base;</a>
<a name="ln2030">      using __bucket_type = __node_base*;      </a>
<a name="ln2031">      using __bucket_alloc_type =</a>
<a name="ln2032">	__alloc_rebind&lt;__node_alloc_type, __bucket_type&gt;;</a>
<a name="ln2033">      using __bucket_alloc_traits = std::allocator_traits&lt;__bucket_alloc_type&gt;;</a>
<a name="ln2034"> </a>
<a name="ln2035">      _Hashtable_alloc() = default;</a>
<a name="ln2036">      _Hashtable_alloc(const _Hashtable_alloc&amp;) = default;</a>
<a name="ln2037">      _Hashtable_alloc(_Hashtable_alloc&amp;&amp;) = default;</a>
<a name="ln2038"> </a>
<a name="ln2039">      template&lt;typename _Alloc&gt;</a>
<a name="ln2040">	_Hashtable_alloc(_Alloc&amp;&amp; __a)</a>
<a name="ln2041">	  : __ebo_node_alloc(std::forward&lt;_Alloc&gt;(__a))</a>
<a name="ln2042">	{ }</a>
<a name="ln2043"> </a>
<a name="ln2044">      __node_alloc_type&amp;</a>
<a name="ln2045">      _M_node_allocator()</a>
<a name="ln2046">      { return __ebo_node_alloc::_S_get(*this); }</a>
<a name="ln2047"> </a>
<a name="ln2048">      const __node_alloc_type&amp;</a>
<a name="ln2049">      _M_node_allocator() const</a>
<a name="ln2050">      { return __ebo_node_alloc::_S_cget(*this); }</a>
<a name="ln2051"> </a>
<a name="ln2052">      template&lt;typename... _Args&gt;</a>
<a name="ln2053">	__node_type*</a>
<a name="ln2054">	_M_allocate_node(_Args&amp;&amp;... __args);</a>
<a name="ln2055"> </a>
<a name="ln2056">      void</a>
<a name="ln2057">      _M_deallocate_node(__node_type* __n);</a>
<a name="ln2058"> </a>
<a name="ln2059">      // Deallocate the linked list of nodes pointed to by __n</a>
<a name="ln2060">      void</a>
<a name="ln2061">      _M_deallocate_nodes(__node_type* __n);</a>
<a name="ln2062"> </a>
<a name="ln2063">      __bucket_type*</a>
<a name="ln2064">      _M_allocate_buckets(std::size_t __n);</a>
<a name="ln2065"> </a>
<a name="ln2066">      void</a>
<a name="ln2067">      _M_deallocate_buckets(__bucket_type*, std::size_t __n);</a>
<a name="ln2068">    };</a>
<a name="ln2069"> </a>
<a name="ln2070">  // Definitions of class template _Hashtable_alloc's out-of-line member</a>
<a name="ln2071">  // functions.</a>
<a name="ln2072">  template&lt;typename _NodeAlloc&gt;</a>
<a name="ln2073">    template&lt;typename... _Args&gt;</a>
<a name="ln2074">      typename _Hashtable_alloc&lt;_NodeAlloc&gt;::__node_type*</a>
<a name="ln2075">      _Hashtable_alloc&lt;_NodeAlloc&gt;::_M_allocate_node(_Args&amp;&amp;... __args)</a>
<a name="ln2076">      {</a>
<a name="ln2077">	auto __nptr = __node_alloc_traits::allocate(_M_node_allocator(), 1);</a>
<a name="ln2078">	__node_type* __n = std::__to_address(__nptr);</a>
<a name="ln2079">	__try</a>
<a name="ln2080">	  {</a>
<a name="ln2081">	    ::new ((void*)__n) __node_type;</a>
<a name="ln2082">	    __node_alloc_traits::construct(_M_node_allocator(),</a>
<a name="ln2083">					   __n-&gt;_M_valptr(),</a>
<a name="ln2084">					   std::forward&lt;_Args&gt;(__args)...);</a>
<a name="ln2085">	    return __n;</a>
<a name="ln2086">	  }</a>
<a name="ln2087">	__catch(...)</a>
<a name="ln2088">	  {</a>
<a name="ln2089">	    __node_alloc_traits::deallocate(_M_node_allocator(), __nptr, 1);</a>
<a name="ln2090">	    __throw_exception_again;</a>
<a name="ln2091">	  }</a>
<a name="ln2092">      }</a>
<a name="ln2093"> </a>
<a name="ln2094">  template&lt;typename _NodeAlloc&gt;</a>
<a name="ln2095">    void</a>
<a name="ln2096">    _Hashtable_alloc&lt;_NodeAlloc&gt;::_M_deallocate_node(__node_type* __n)</a>
<a name="ln2097">    {</a>
<a name="ln2098">      typedef typename __node_alloc_traits::pointer _Ptr;</a>
<a name="ln2099">      auto __ptr = std::pointer_traits&lt;_Ptr&gt;::pointer_to(*__n);</a>
<a name="ln2100">      __node_alloc_traits::destroy(_M_node_allocator(), __n-&gt;_M_valptr());</a>
<a name="ln2101">      __n-&gt;~__node_type();</a>
<a name="ln2102">      __node_alloc_traits::deallocate(_M_node_allocator(), __ptr, 1);</a>
<a name="ln2103">    }</a>
<a name="ln2104"> </a>
<a name="ln2105">  template&lt;typename _NodeAlloc&gt;</a>
<a name="ln2106">    void</a>
<a name="ln2107">    _Hashtable_alloc&lt;_NodeAlloc&gt;::_M_deallocate_nodes(__node_type* __n)</a>
<a name="ln2108">    {</a>
<a name="ln2109">      while (__n)</a>
<a name="ln2110">	{</a>
<a name="ln2111">	  __node_type* __tmp = __n;</a>
<a name="ln2112">	  __n = __n-&gt;_M_next();</a>
<a name="ln2113">	  _M_deallocate_node(__tmp);</a>
<a name="ln2114">	}</a>
<a name="ln2115">    }</a>
<a name="ln2116"> </a>
<a name="ln2117">  template&lt;typename _NodeAlloc&gt;</a>
<a name="ln2118">    typename _Hashtable_alloc&lt;_NodeAlloc&gt;::__bucket_type*</a>
<a name="ln2119">    _Hashtable_alloc&lt;_NodeAlloc&gt;::_M_allocate_buckets(std::size_t __n)</a>
<a name="ln2120">    {</a>
<a name="ln2121">      __bucket_alloc_type __alloc(_M_node_allocator());</a>
<a name="ln2122"> </a>
<a name="ln2123">      auto __ptr = __bucket_alloc_traits::allocate(__alloc, __n);</a>
<a name="ln2124">      __bucket_type* __p = std::__to_address(__ptr);</a>
<a name="ln2125">      __builtin_memset(__p, 0, __n * sizeof(__bucket_type));</a>
<a name="ln2126">      return __p;</a>
<a name="ln2127">    }</a>
<a name="ln2128"> </a>
<a name="ln2129">  template&lt;typename _NodeAlloc&gt;</a>
<a name="ln2130">    void</a>
<a name="ln2131">    _Hashtable_alloc&lt;_NodeAlloc&gt;::_M_deallocate_buckets(__bucket_type* __bkts,</a>
<a name="ln2132">							std::size_t __n)</a>
<a name="ln2133">    {</a>
<a name="ln2134">      typedef typename __bucket_alloc_traits::pointer _Ptr;</a>
<a name="ln2135">      auto __ptr = std::pointer_traits&lt;_Ptr&gt;::pointer_to(*__bkts);</a>
<a name="ln2136">      __bucket_alloc_type __alloc(_M_node_allocator());</a>
<a name="ln2137">      __bucket_alloc_traits::deallocate(__alloc, __ptr, __n);</a>
<a name="ln2138">    }</a>
<a name="ln2139"> </a>
<a name="ln2140"> //@} hashtable-detail</a>
<a name="ln2141">} // namespace __detail</a>
<a name="ln2142">_GLIBCXX_END_NAMESPACE_VERSION</a>
<a name="ln2143">} // namespace std</a>
<a name="ln2144"> </a>
<a name="ln2145">#endif // _HASHTABLE_POLICY_H</a>

</code></pre>
<div class="balloon" rel="1560"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: _M_bucket.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
