
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>master_service.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Licensed to the Apache Software Foundation (ASF) under one</a>
<a name="ln2">// or more contributor license agreements.  See the NOTICE file</a>
<a name="ln3">// distributed with this work for additional information</a>
<a name="ln4">// regarding copyright ownership.  The ASF licenses this file</a>
<a name="ln5">// to you under the Apache License, Version 2.0 (the</a>
<a name="ln6">// &quot;License&quot;); you may not use this file except in compliance</a>
<a name="ln7">// with the License.  You may obtain a copy of the License at</a>
<a name="ln8">//</a>
<a name="ln9">//   http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln10">//</a>
<a name="ln11">// Unless required by applicable law or agreed to in writing,</a>
<a name="ln12">// software distributed under the License is distributed on an</a>
<a name="ln13">// &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</a>
<a name="ln14">// KIND, either express or implied.  See the License for the</a>
<a name="ln15">// specific language governing permissions and limitations</a>
<a name="ln16">// under the License.</a>
<a name="ln17">//</a>
<a name="ln18">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln19">//</a>
<a name="ln20">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln21">//</a>
<a name="ln22">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln23">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln24">//</a>
<a name="ln25">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln26">//</a>
<a name="ln27">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln28">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln29">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln30">// under the License.</a>
<a name="ln31">//</a>
<a name="ln32"> </a>
<a name="ln33">#include &quot;yb/master/master_service.h&quot;</a>
<a name="ln34"> </a>
<a name="ln35">#include &lt;memory&gt;</a>
<a name="ln36">#include &lt;string&gt;</a>
<a name="ln37">#include &lt;vector&gt;</a>
<a name="ln38"> </a>
<a name="ln39">#include &lt;gflags/gflags.h&gt;</a>
<a name="ln40"> </a>
<a name="ln41">#include &quot;yb/common/wire_protocol.h&quot;</a>
<a name="ln42">#include &quot;yb/master/catalog_manager-internal.h&quot;</a>
<a name="ln43">#include &quot;yb/master/flush_manager.h&quot;</a>
<a name="ln44">#include &quot;yb/master/master_service_base-internal.h&quot;</a>
<a name="ln45">#include &quot;yb/master/master.h&quot;</a>
<a name="ln46">#include &quot;yb/master/ts_descriptor.h&quot;</a>
<a name="ln47">#include &quot;yb/master/ts_manager.h&quot;</a>
<a name="ln48">#include &quot;yb/master/encryption_manager.h&quot;</a>
<a name="ln49">#include &quot;yb/server/webserver.h&quot;</a>
<a name="ln50">#include &quot;yb/util/debug/long_operation_tracker.h&quot;</a>
<a name="ln51">#include &quot;yb/util/flag_tags.h&quot;</a>
<a name="ln52">#include &quot;yb/util/random_util.h&quot;</a>
<a name="ln53">#include &quot;yb/util/shared_lock.h&quot;</a>
<a name="ln54"> </a>
<a name="ln55">DEFINE_int64(tablet_split_size_threshold_bytes, 0,</a>
<a name="ln56">             &quot;Threshold on tablet size after which tablet should be split. Automated splitting is &quot;</a>
<a name="ln57">             &quot;disabled if this value is set to 0&quot;);</a>
<a name="ln58"> </a>
<a name="ln59">DEFINE_int32(master_inject_latency_on_tablet_lookups_ms, 0,</a>
<a name="ln60">             &quot;Number of milliseconds that the master will sleep before responding to &quot;</a>
<a name="ln61">             &quot;requests for tablet locations.&quot;);</a>
<a name="ln62">TAG_FLAG(master_inject_latency_on_tablet_lookups_ms, unsafe);</a>
<a name="ln63">TAG_FLAG(master_inject_latency_on_tablet_lookups_ms, hidden);</a>
<a name="ln64"> </a>
<a name="ln65">DEFINE_test_flag(bool, master_fail_transactional_tablet_lookups, false,</a>
<a name="ln66">                 &quot;Whether to fail all lookup requests to transactional table.&quot;);</a>
<a name="ln67"> </a>
<a name="ln68">DEFINE_double(master_slow_get_registration_probability, 0,</a>
<a name="ln69">              &quot;Probability of injecting delay in GetMasterRegistration.&quot;);</a>
<a name="ln70"> </a>
<a name="ln71">using namespace std::literals;</a>
<a name="ln72"> </a>
<a name="ln73">namespace yb {</a>
<a name="ln74">namespace master {</a>
<a name="ln75"> </a>
<a name="ln76">using std::string;</a>
<a name="ln77">using std::vector;</a>
<a name="ln78">using std::shared_ptr;</a>
<a name="ln79">using std::ostringstream;</a>
<a name="ln80">using consensus::RaftPeerPB;</a>
<a name="ln81">using rpc::RpcContext;</a>
<a name="ln82"> </a>
<a name="ln83">static void SetupErrorAndRespond(MasterErrorPB* error,</a>
<a name="ln84">                                 const Status&amp; s,</a>
<a name="ln85">                                 MasterErrorPB::Code code,</a>
<a name="ln86">                                 RpcContext* rpc) {</a>
<a name="ln87">  StatusToPB(s, error-&gt;mutable_status());</a>
<a name="ln88">  error-&gt;set_code(code);</a>
<a name="ln89">  rpc-&gt;RespondSuccess();</a>
<a name="ln90">}</a>
<a name="ln91"> </a>
<a name="ln92">MasterServiceImpl::MasterServiceImpl(Master* server)</a>
<a name="ln93">  : MasterServiceIf(server-&gt;metric_entity()),</a>
<a name="ln94">    MasterServiceBase(server) {</a>
<a name="ln95">}</a>
<a name="ln96"> </a>
<a name="ln97">void MasterServiceImpl::TSHeartbeat(const TSHeartbeatRequestPB* req,</a>
<a name="ln98">                                    TSHeartbeatResponsePB* resp,</a>
<a name="ln99">                                    RpcContext rpc) {</a>
<a name="ln100">  LongOperationTracker long_operation_tracker(&quot;TSHeartbeat&quot;, 1s);</a>
<a name="ln101"> </a>
<a name="ln102">  // If CatalogManager is not initialized don't even know whether or not we will</a>
<a name="ln103">  // be a leader (so we can't tell whether or not we can accept tablet reports).</a>
<a name="ln104">  CatalogManager::ScopedLeaderSharedLock l(server_-&gt;catalog_manager());</a>
<a name="ln105"> </a>
<a name="ln106">  consensus::ConsensusStatePB cpb;</a>
<a name="ln107">  Status s = server_-&gt;catalog_manager()-&gt;GetCurrentConfig(&amp;cpb);</a>
<a name="ln108">  if (!s.ok()) {</a>
<a name="ln109">    // For now, we skip setting the config on errors (hopefully next heartbeat will work).</a>
<a name="ln110">    // We could enhance to fail rpc, if there are too many error, on a case by case error basis.</a>
<a name="ln111">    LOG(WARNING) &lt;&lt; &quot;Could not set master raft config : &quot; &lt;&lt; s.ToString();</a>
<a name="ln112">  } else if (cpb.has_config()) {</a>
<a name="ln113">    if (cpb.config().opid_index() &gt; req-&gt;config_index()) {</a>
<a name="ln114">      *resp-&gt;mutable_master_config() = std::move(cpb.config());</a>
<a name="ln115">      LOG(INFO) &lt;&lt; &quot;Set config at index &quot; &lt;&lt; resp-&gt;master_config().opid_index() &lt;&lt; &quot; for ts uuid &quot;</a>
<a name="ln116">                &lt;&lt; req-&gt;common().ts_instance().permanent_uuid();</a>
<a name="ln117">    }</a>
<a name="ln118">  } // Do nothing if config not ready.</a>
<a name="ln119"> </a>
<a name="ln120">  if (!l.CheckIsInitializedAndIsLeaderOrRespond(resp, &amp;rpc)) {</a>
<a name="ln121">    resp-&gt;set_leader_master(false);</a>
<a name="ln122">    return;</a>
<a name="ln123">  }</a>
<a name="ln124"> </a>
<a name="ln125">  resp-&gt;mutable_master_instance()-&gt;CopyFrom(server_-&gt;instance_pb());</a>
<a name="ln126">  resp-&gt;set_leader_master(true);</a>
<a name="ln127"> </a>
<a name="ln128">  // If the TS is registering, register in the TS manager.</a>
<a name="ln129">  if (req-&gt;has_registration()) {</a>
<a name="ln130">    Status s = server_-&gt;ts_manager()-&gt;RegisterTS(req-&gt;common().ts_instance(),</a>
<a name="ln131">                                                 req-&gt;registration(),</a>
<a name="ln132">                                                 server_-&gt;MakeCloudInfoPB(),</a>
<a name="ln133">                                                 &amp;server_-&gt;proxy_cache());</a>
<a name="ln134">    if (!s.ok()) {</a>
<a name="ln135">      LOG(WARNING) &lt;&lt; &quot;Unable to register tablet server (&quot; &lt;&lt; rpc.requestor_string() &lt;&lt; &quot;): &quot;</a>
<a name="ln136">                   &lt;&lt; s.ToString();</a>
<a name="ln137">      // TODO: add service-specific errors.</a>
<a name="ln138">      rpc.RespondFailure(s);</a>
<a name="ln139">      return;</a>
<a name="ln140">    }</a>
<a name="ln141">    SysClusterConfigEntryPB cluster_config;</a>
<a name="ln142">    s = server_-&gt;catalog_manager()-&gt;GetClusterConfig(&amp;cluster_config);</a>
<a name="ln143">    if (!s.ok()) {</a>
<a name="ln144">      LOG(WARNING) &lt;&lt; &quot;Unable to get cluster configuration: &quot; &lt;&lt; s.ToString();</a>
<a name="ln145">      rpc.RespondFailure(s);</a>
<a name="ln146">    }</a>
<a name="ln147">    resp-&gt;set_cluster_uuid(cluster_config.cluster_uuid());</a>
<a name="ln148">  }</a>
<a name="ln149"> </a>
<a name="ln150">  s = server_-&gt;catalog_manager()-&gt;FillHeartbeatResponse(req, resp);</a>
<a name="ln151">  if (!s.ok()) {</a>
<a name="ln152">    LOG(WARNING) &lt;&lt; &quot;Unable to fill heartbeat response: &quot; &lt;&lt; s.ToString();</a>
<a name="ln153">    rpc.RespondFailure(s);</a>
<a name="ln154">  }</a>
<a name="ln155"> </a>
<a name="ln156">  // TODO: KUDU-86 if something fails after this point the TS will not be able</a>
<a name="ln157">  //       to register again.</a>
<a name="ln158"> </a>
<a name="ln159">  // Look up the TS -- if it just registered above, it will be found here.</a>
<a name="ln160">  // This allows the TS to register and tablet-report in the same RPC.</a>
<a name="ln161">  TSDescriptorPtr ts_desc;</a>
<a name="ln162">  s = server_-&gt;ts_manager()-&gt;LookupTS(req-&gt;common().ts_instance(), &amp;ts_desc);</a>
<a name="ln163">  if (s.IsNotFound()) {</a>
<a name="ln164">    LOG(INFO) &lt;&lt; &quot;Got heartbeat from unknown tablet server { &quot;</a>
<a name="ln165">              &lt;&lt; req-&gt;common().ts_instance().ShortDebugString()</a>
<a name="ln166">              &lt;&lt; &quot; } as &quot; &lt;&lt; rpc.requestor_string()</a>
<a name="ln167">              &lt;&lt; &quot;; Asking this server to re-register.&quot;;</a>
<a name="ln168">    resp-&gt;set_needs_reregister(true);</a>
<a name="ln169">    resp-&gt;set_needs_full_tablet_report(true);</a>
<a name="ln170">    rpc.RespondSuccess();</a>
<a name="ln171">    return;</a>
<a name="ln172">  } else if (!s.ok()) {</a>
<a name="ln173">    LOG(WARNING) &lt;&lt; &quot;Unable to look up tablet server for heartbeat request &quot;</a>
<a name="ln174">                 &lt;&lt; req-&gt;DebugString() &lt;&lt; &quot; from &quot; &lt;&lt; rpc.requestor_string()</a>
<a name="ln175">                 &lt;&lt; &quot;\nStatus: &quot; &lt;&lt; s.ToString();</a>
<a name="ln176">    rpc.RespondFailure(s.CloneAndPrepend(&quot;Unable to lookup TS&quot;));</a>
<a name="ln177">    return;</a>
<a name="ln178">  }</a>
<a name="ln179"> </a>
<a name="ln180">  ts_desc-&gt;UpdateHeartbeatTime();</a>
<a name="ln181">  ts_desc-&gt;set_num_live_replicas(req-&gt;num_live_tablets());</a>
<a name="ln182">  ts_desc-&gt;set_leader_count(req-&gt;leader_count());</a>
<a name="ln183"> </a>
<a name="ln184">  // Set the TServer metrics in TS Descriptor.</a>
<a name="ln185">  if (req-&gt;has_metrics()) {</a>
<a name="ln186">    ts_desc-&gt;UpdateMetrics(req-&gt;metrics());</a>
<a name="ln187">  }</a>
<a name="ln188"> </a>
<a name="ln189">  if (req-&gt;has_tablet_report()) {</a>
<a name="ln190">    s = server_-&gt;catalog_manager()-&gt;ProcessTabletReport(</a>
<a name="ln191">      ts_desc.get(), req-&gt;tablet_report(), resp-&gt;mutable_tablet_report(), &amp;rpc);</a>
<a name="ln192">    if (!s.ok()) {</a>
<a name="ln193">      rpc.RespondFailure(s.CloneAndPrepend(&quot;Failed to process tablet report&quot;));</a>
<a name="ln194">      return;</a>
<a name="ln195">    }</a>
<a name="ln196">  }</a>
<a name="ln197"> </a>
<a name="ln198">  if (!req-&gt;has_tablet_report() || req-&gt;tablet_report().is_incremental()) {</a>
<a name="ln199">    // TODO(tsplit): for now we only do splitting in case there is no full tablet report to</a>
<a name="ln200">    // minimize probability of TSHeartbeat RPC timeout and retry.</a>
<a name="ln201">    // This will be improved to handle split retries appropriately and then we won't need that</a>
<a name="ln202">    // check.</a>
<a name="ln203">    for (const auto&amp; tablet : req-&gt;tablets_for_split()) {</a>
<a name="ln204">      LOG(INFO) &lt;&lt; &quot;Got tablet to split: &quot; &lt;&lt; AsString(tablet);</a>
<a name="ln205">      const auto split_status = server_-&gt;catalog_manager()-&gt;SplitTablet(</a>
<a name="ln206">          tablet.tablet_id(), tablet.split_encoded_key(), tablet.split_partition_key());</a>
<a name="ln207">      if (!split_status.ok()) {</a>
<a name="ln208">        LOG(WARNING) &lt;&lt; split_status;</a>
<a name="ln209">      }</a>
<a name="ln210">    }</a>
<a name="ln211">  }</a>
<a name="ln212"> </a>
<a name="ln213">  if (!ts_desc-&gt;has_tablet_report()) {</a>
<a name="ln214">    resp-&gt;set_needs_full_tablet_report(true);</a>
<a name="ln215">  }</a>
<a name="ln216"> </a>
<a name="ln217">  // Retrieve all the nodes known by the master.</a>
<a name="ln218">  std::vector&lt;std::shared_ptr&lt;TSDescriptor&gt;&gt; descs;</a>
<a name="ln219">  server_-&gt;ts_manager()-&gt;GetAllLiveDescriptors(&amp;descs);</a>
<a name="ln220">  for (const auto&amp; desc : descs) {</a>
<a name="ln221">    *resp-&gt;add_tservers() = *desc-&gt;GetTSInformationPB();</a>
<a name="ln222">  }</a>
<a name="ln223"> </a>
<a name="ln224">  // Retrieve the ysql catalog schema version.</a>
<a name="ln225">  uint64_t version = server_-&gt;catalog_manager()-&gt;GetYsqlCatalogVersion();</a>
<a name="ln226">  resp-&gt;set_ysql_catalog_version(version);</a>
<a name="ln227"> </a>
<a name="ln228">  if (FLAGS_tablet_split_size_threshold_bytes &gt; 0) {</a>
<a name="ln229">    resp-&gt;set_tablet_split_size_threshold_bytes(FLAGS_tablet_split_size_threshold_bytes);</a>
<a name="ln230">  }</a>
<a name="ln231"> </a>
<a name="ln232">  rpc.RespondSuccess();</a>
<a name="ln233">}</a>
<a name="ln234"> </a>
<a name="ln235">void MasterServiceImpl::GetTabletLocations(const GetTabletLocationsRequestPB* req,</a>
<a name="ln236">                                           GetTabletLocationsResponsePB* resp,</a>
<a name="ln237">                                           RpcContext rpc) {</a>
<a name="ln238">  CatalogManager::ScopedLeaderSharedLock l(server_-&gt;catalog_manager());</a>
<a name="ln239">  if (!l.CheckIsInitializedAndIsLeaderOrRespond(resp, &amp;rpc)) {</a>
<a name="ln240">    return;</a>
<a name="ln241">  }</a>
<a name="ln242"> </a>
<a name="ln243">  if (PREDICT_FALSE(FLAGS_master_inject_latency_on_tablet_lookups_ms &gt; 0)) {</a>
<a name="ln244">    SleepFor(MonoDelta::FromMilliseconds(FLAGS_master_inject_latency_on_tablet_lookups_ms));</a>
<a name="ln245">  }</a>
<a name="ln246">  if (PREDICT_FALSE(FLAGS_TEST_master_fail_transactional_tablet_lookups)) {</a>
<a name="ln247">    std::vector&lt;scoped_refptr&lt;TableInfo&gt;&gt; tables;</a>
<a name="ln248">    server_-&gt;catalog_manager()-&gt;GetAllTables(&amp;tables);</a>
<a name="ln249">    const auto&amp; tablet_id = req-&gt;tablet_ids(0);</a>
<a name="ln250">    for (const auto&amp; table : tables) {</a>
<a name="ln251">      TabletInfos tablets;</a>
<a name="ln252">      table-&gt;GetAllTablets(&amp;tablets);</a>
<a name="ln253">      for (const auto&amp; tablet : tablets) {</a>
<a name="ln254">        if (tablet-&gt;tablet_id() == tablet_id) {</a>
<a name="ln255">          TableType table_type;</a>
<a name="ln256">          {</a>
<a name="ln257">            auto lock = table-&gt;LockForRead();</a>
<a name="ln258">            table_type = table-&gt;metadata().state().table_type();</a>
<a name="ln259">          }</a>
<a name="ln260">          if (table_type == TableType::TRANSACTION_STATUS_TABLE_TYPE) {</a>
<a name="ln261">            rpc.RespondFailure(STATUS(InvalidCommand, &quot;TEST: Artificial failure&quot;));</a>
<a name="ln262">            return;</a>
<a name="ln263">          }</a>
<a name="ln264">          break;</a>
<a name="ln265">        }</a>
<a name="ln266">      }</a>
<a name="ln267">    }</a>
<a name="ln268">  }</a>
<a name="ln269"> </a>
<a name="ln270">  for (const TabletId&amp; tablet_id : req-&gt;tablet_ids()) {</a>
<a name="ln271">    // TODO: once we have catalog data. ACL checks would also go here, probably.</a>
<a name="ln272">    TabletLocationsPB* locs_pb = resp-&gt;add_tablet_locations();</a>
<a name="ln273">    Status s = server_-&gt;catalog_manager()-&gt;GetTabletLocations(tablet_id, locs_pb);</a>
<a name="ln274">    if (!s.ok()) {</a>
<a name="ln275">      resp-&gt;mutable_tablet_locations()-&gt;RemoveLast();</a>
<a name="ln276"> </a>
<a name="ln277">      GetTabletLocationsResponsePB::Error* err = resp-&gt;add_errors();</a>
<a name="ln278">      err-&gt;set_tablet_id(tablet_id);</a>
<a name="ln279">      StatusToPB(s, err-&gt;mutable_status());</a>
<a name="ln280">    }</a>
<a name="ln281">  }</a>
<a name="ln282"> </a>
<a name="ln283">  rpc.RespondSuccess();</a>
<a name="ln284">}</a>
<a name="ln285"> </a>
<a name="ln286">void MasterServiceImpl::CreateTable(const CreateTableRequestPB* req,</a>
<a name="ln287">                                    CreateTableResponsePB* resp,</a>
<a name="ln288">                                    RpcContext rpc) {</a>
<a name="ln289">  HandleIn(req, resp, &amp;rpc, &amp;CatalogManager::CreateTable);</a>
<a name="ln290">}</a>
<a name="ln291"> </a>
<a name="ln292">void MasterServiceImpl::IsCreateTableDone(const IsCreateTableDoneRequestPB* req,</a>
<a name="ln293">                                          IsCreateTableDoneResponsePB* resp,</a>
<a name="ln294">                                          RpcContext rpc) {</a>
<a name="ln295">  HandleIn(req, resp, &amp;rpc, &amp;CatalogManager::IsCreateTableDone);</a>
<a name="ln296">}</a>
<a name="ln297"> </a>
<a name="ln298">void MasterServiceImpl::TruncateTable(const TruncateTableRequestPB* req,</a>
<a name="ln299">                                      TruncateTableResponsePB* resp,</a>
<a name="ln300">                                      RpcContext rpc) {</a>
<a name="ln301">  HandleIn(req, resp, &amp;rpc, &amp;CatalogManager::TruncateTable);</a>
<a name="ln302">}</a>
<a name="ln303"> </a>
<a name="ln304">void MasterServiceImpl::IsTruncateTableDone(const IsTruncateTableDoneRequestPB* req,</a>
<a name="ln305">                                            IsTruncateTableDoneResponsePB* resp,</a>
<a name="ln306">                                            RpcContext rpc) {</a>
<a name="ln307">  HandleIn(req, resp, &amp;rpc, &amp;CatalogManager::IsTruncateTableDone);</a>
<a name="ln308">}</a>
<a name="ln309"> </a>
<a name="ln310">void MasterServiceImpl::DeleteTable(const DeleteTableRequestPB* req,</a>
<a name="ln311">                                    DeleteTableResponsePB* resp,</a>
<a name="ln312">                                    RpcContext rpc) {</a>
<a name="ln313">  HandleIn(req, resp, &amp;rpc, &amp;CatalogManager::DeleteTable);</a>
<a name="ln314">}</a>
<a name="ln315"> </a>
<a name="ln316">void MasterServiceImpl::IsDeleteTableDone(const IsDeleteTableDoneRequestPB* req,</a>
<a name="ln317">                                          IsDeleteTableDoneResponsePB* resp,</a>
<a name="ln318">                                          RpcContext rpc) {</a>
<a name="ln319">  HandleIn(req, resp, &amp;rpc, &amp;CatalogManager::IsDeleteTableDone);</a>
<a name="ln320">}</a>
<a name="ln321"> </a>
<a name="ln322">void MasterServiceImpl::AlterTable(const AlterTableRequestPB* req,</a>
<a name="ln323">                                   AlterTableResponsePB* resp,</a>
<a name="ln324">                                   RpcContext rpc) {</a>
<a name="ln325">  HandleIn(req, resp, &amp;rpc, &amp;CatalogManager::AlterTable);</a>
<a name="ln326">}</a>
<a name="ln327"> </a>
<a name="ln328">void MasterServiceImpl::IsAlterTableDone(const IsAlterTableDoneRequestPB* req,</a>
<a name="ln329">                                         IsAlterTableDoneResponsePB* resp,</a>
<a name="ln330">                                         RpcContext rpc) {</a>
<a name="ln331">  HandleIn(req, resp, &amp;rpc, &amp;CatalogManager::IsAlterTableDone);</a>
<a name="ln332">}</a>
<a name="ln333"> </a>
<a name="ln334">void MasterServiceImpl::ListTables(const ListTablesRequestPB* req,</a>
<a name="ln335">                                   ListTablesResponsePB* resp,</a>
<a name="ln336">                                   RpcContext rpc) {</a>
<a name="ln337">  HandleIn(req, resp, &amp;rpc, &amp;CatalogManager::ListTables);</a>
<a name="ln338">}</a>
<a name="ln339"> </a>
<a name="ln340">void MasterServiceImpl::GetTableLocations(const GetTableLocationsRequestPB* req,</a>
<a name="ln341">                                          GetTableLocationsResponsePB* resp,</a>
<a name="ln342">                                          RpcContext rpc) {</a>
<a name="ln343">  HandleOnLeader(req, resp, &amp;rpc, [&amp;]() -&gt; Status {</a>
<a name="ln344">    if (PREDICT_FALSE(FLAGS_master_inject_latency_on_tablet_lookups_ms &gt; 0)) {</a>
<a name="ln345">      SleepFor(MonoDelta::FromMilliseconds(FLAGS_master_inject_latency_on_tablet_lookups_ms));</a>
<a name="ln346">    }</a>
<a name="ln347">    return server_-&gt;catalog_manager()-&gt;GetTableLocations(req, resp); });</a>
<a name="ln348">}</a>
<a name="ln349"> </a>
<a name="ln350">void MasterServiceImpl::GetTableSchema(const GetTableSchemaRequestPB* req,</a>
<a name="ln351">                                       GetTableSchemaResponsePB* resp,</a>
<a name="ln352">                                       RpcContext rpc) {</a>
<a name="ln353">  HandleIn(req, resp, &amp;rpc, &amp;CatalogManager::GetTableSchema);</a>
<a name="ln354">}</a>
<a name="ln355"> </a>
<a name="ln356">void MasterServiceImpl::CreateNamespace(const CreateNamespaceRequestPB* req,</a>
<a name="ln357">                                        CreateNamespaceResponsePB* resp,</a>
<a name="ln358">                                        RpcContext rpc) {</a>
<a name="ln359">  HandleIn(req, resp, &amp;rpc, &amp;CatalogManager::CreateNamespace);</a>
<a name="ln360">}</a>
<a name="ln361"> </a>
<a name="ln362">void MasterServiceImpl::IsCreateNamespaceDone(const IsCreateNamespaceDoneRequestPB* req,</a>
<a name="ln363">                                              IsCreateNamespaceDoneResponsePB* resp,</a>
<a name="ln364">                                              rpc::RpcContext rpc) {</a>
<a name="ln365">  HandleIn(req, resp, &amp;rpc, &amp;CatalogManager::IsCreateNamespaceDone);</a>
<a name="ln366">}</a>
<a name="ln367"> </a>
<a name="ln368">void MasterServiceImpl::DeleteNamespace(const DeleteNamespaceRequestPB* req,</a>
<a name="ln369">                                        DeleteNamespaceResponsePB* resp,</a>
<a name="ln370">                                        RpcContext rpc) {</a>
<a name="ln371">  HandleIn(req, resp, &amp;rpc, &amp;CatalogManager::DeleteNamespace);</a>
<a name="ln372">}</a>
<a name="ln373"> </a>
<a name="ln374">void MasterServiceImpl::IsDeleteNamespaceDone(const IsDeleteNamespaceDoneRequestPB* req,</a>
<a name="ln375">                                              IsDeleteNamespaceDoneResponsePB* resp,</a>
<a name="ln376">                                              RpcContext rpc) {</a>
<a name="ln377">  HandleIn(req, resp, &amp;rpc, &amp;CatalogManager::IsDeleteNamespaceDone);</a>
<a name="ln378">}</a>
<a name="ln379"> </a>
<a name="ln380">void MasterServiceImpl::AlterNamespace(const AlterNamespaceRequestPB* req,</a>
<a name="ln381">                                       AlterNamespaceResponsePB* resp,</a>
<a name="ln382">                                       RpcContext rpc) {</a>
<a name="ln383">  HandleIn(req, resp, &amp;rpc, &amp;CatalogManager::AlterNamespace);</a>
<a name="ln384">}</a>
<a name="ln385"> </a>
<a name="ln386">void MasterServiceImpl::ListNamespaces(const ListNamespacesRequestPB* req,</a>
<a name="ln387">                                       ListNamespacesResponsePB* resp,</a>
<a name="ln388">                                       RpcContext rpc) {</a>
<a name="ln389">  HandleIn(req, resp, &amp;rpc, &amp;CatalogManager::ListNamespaces);</a>
<a name="ln390">}</a>
<a name="ln391"> </a>
<a name="ln392">void MasterServiceImpl::GetNamespaceInfo(const GetNamespaceInfoRequestPB* req,</a>
<a name="ln393">                                         GetNamespaceInfoResponsePB* resp,</a>
<a name="ln394">                                         RpcContext rpc) {</a>
<a name="ln395">  HandleIn(req, resp, &amp;rpc, &amp;CatalogManager::GetNamespaceInfo);</a>
<a name="ln396">}</a>
<a name="ln397"> </a>
<a name="ln398">void MasterServiceImpl::ReservePgsqlOids(const ReservePgsqlOidsRequestPB* req,</a>
<a name="ln399">                                         ReservePgsqlOidsResponsePB* resp,</a>
<a name="ln400">                                         rpc::RpcContext rpc) {</a>
<a name="ln401">  HandleIn(req, resp, &amp;rpc, &amp;CatalogManager::ReservePgsqlOids);</a>
<a name="ln402">}</a>
<a name="ln403"> </a>
<a name="ln404">void MasterServiceImpl::GetYsqlCatalogConfig(const GetYsqlCatalogConfigRequestPB* req,</a>
<a name="ln405">                                             GetYsqlCatalogConfigResponsePB* resp,</a>
<a name="ln406">                                             rpc::RpcContext rpc) {</a>
<a name="ln407">  HandleIn(req, resp, &amp;rpc, &amp;CatalogManager::GetYsqlCatalogConfig);</a>
<a name="ln408">}</a>
<a name="ln409"> </a>
<a name="ln410">// ------------------------------------------------------------------------------------------------</a>
<a name="ln411">// Tablegroup</a>
<a name="ln412">// ------------------------------------------------------------------------------------------------</a>
<a name="ln413"> </a>
<a name="ln414">void MasterServiceImpl::CreateTablegroup(const CreateTablegroupRequestPB* req,</a>
<a name="ln415">                                         CreateTablegroupResponsePB* resp,</a>
<a name="ln416">                                         rpc::RpcContext rpc) {</a>
<a name="ln417">  HandleIn(req, resp, &amp;rpc, &amp;CatalogManager::CreateTablegroup);</a>
<a name="ln418">}</a>
<a name="ln419"> </a>
<a name="ln420">void MasterServiceImpl::DeleteTablegroup(const DeleteTablegroupRequestPB* req,</a>
<a name="ln421">                                         DeleteTablegroupResponsePB* resp,</a>
<a name="ln422">                                         rpc::RpcContext rpc) {</a>
<a name="ln423">  HandleIn(req, resp, &amp;rpc, &amp;CatalogManager::DeleteTablegroup);</a>
<a name="ln424">}</a>
<a name="ln425"> </a>
<a name="ln426">void MasterServiceImpl::ListTablegroups(const ListTablegroupsRequestPB* req,</a>
<a name="ln427">                                        ListTablegroupsResponsePB* resp,</a>
<a name="ln428">                                        rpc::RpcContext rpc) {</a>
<a name="ln429">  HandleIn(req, resp, &amp;rpc, &amp;CatalogManager::ListTablegroups);</a>
<a name="ln430">}</a>
<a name="ln431"> </a>
<a name="ln432">// ------------------------------------------------------------------------------------------------</a>
<a name="ln433">// Permissions</a>
<a name="ln434">// ------------------------------------------------------------------------------------------------</a>
<a name="ln435"> </a>
<a name="ln436">void MasterServiceImpl::CreateRole(const CreateRoleRequestPB* req,</a>
<a name="ln437">                                   CreateRoleResponsePB* resp,</a>
<a name="ln438">                                   rpc::RpcContext rpc) {</a>
<a name="ln439">  HandleIn(req, resp, &amp;rpc, &amp;PermissionsManager::CreateRole);</a>
<a name="ln440">}</a>
<a name="ln441"> </a>
<a name="ln442">void MasterServiceImpl::AlterRole(const AlterRoleRequestPB* req,</a>
<a name="ln443">                                  AlterRoleResponsePB* resp,</a>
<a name="ln444">                                  rpc::RpcContext rpc) {</a>
<a name="ln445">  HandleIn(req, resp, &amp;rpc, &amp;PermissionsManager::AlterRole);</a>
<a name="ln446">}</a>
<a name="ln447"> </a>
<a name="ln448">void MasterServiceImpl::DeleteRole(const DeleteRoleRequestPB* req,</a>
<a name="ln449">                                   DeleteRoleResponsePB* resp,</a>
<a name="ln450">                                   rpc::RpcContext rpc) {</a>
<a name="ln451">  HandleIn(req, resp, &amp;rpc, &amp;PermissionsManager::DeleteRole);</a>
<a name="ln452">}</a>
<a name="ln453"> </a>
<a name="ln454">void MasterServiceImpl::GrantRevokeRole(const GrantRevokeRoleRequestPB* req,</a>
<a name="ln455">                                        GrantRevokeRoleResponsePB* resp,</a>
<a name="ln456">                                        rpc::RpcContext rpc) {</a>
<a name="ln457">  HandleIn(req, resp, &amp;rpc, &amp;PermissionsManager::GrantRevokeRole);</a>
<a name="ln458">}</a>
<a name="ln459"> </a>
<a name="ln460">void MasterServiceImpl::GrantRevokePermission(const GrantRevokePermissionRequestPB* req,</a>
<a name="ln461">                                              GrantRevokePermissionResponsePB* resp,</a>
<a name="ln462">                                              rpc::RpcContext rpc) {</a>
<a name="ln463">  HandleIn(req, resp, &amp;rpc, &amp;PermissionsManager::GrantRevokePermission);</a>
<a name="ln464">}</a>
<a name="ln465"> </a>
<a name="ln466">void MasterServiceImpl::GetPermissions(const GetPermissionsRequestPB* req,</a>
<a name="ln467">                                       GetPermissionsResponsePB* resp,</a>
<a name="ln468">                                       rpc::RpcContext rpc) {</a>
<a name="ln469">  HandleIn(req, resp, &amp;rpc, &amp;PermissionsManager::GetPermissions);</a>
<a name="ln470">}</a>
<a name="ln471"> </a>
<a name="ln472">// ------------------------------------------------------------------------------------------------</a>
<a name="ln473">// Redis</a>
<a name="ln474">// ------------------------------------------------------------------------------------------------</a>
<a name="ln475"> </a>
<a name="ln476">void MasterServiceImpl::RedisConfigSet(</a>
<a name="ln477">    const RedisConfigSetRequestPB* req, RedisConfigSetResponsePB* resp, rpc::RpcContext rpc) {</a>
<a name="ln478">  HandleIn(req, resp, &amp;rpc, &amp;CatalogManager::RedisConfigSet);</a>
<a name="ln479">}</a>
<a name="ln480"> </a>
<a name="ln481">void MasterServiceImpl::RedisConfigGet(</a>
<a name="ln482">    const RedisConfigGetRequestPB* req, RedisConfigGetResponsePB* resp, rpc::RpcContext rpc) {</a>
<a name="ln483">  HandleIn(req, resp, &amp;rpc, &amp;CatalogManager::RedisConfigGet);</a>
<a name="ln484">}</a>
<a name="ln485"> </a>
<a name="ln486">// ------------------------------------------------------------------------------------------------</a>
<a name="ln487">// YCQL user-defined types</a>
<a name="ln488">// ------------------------------------------------------------------------------------------------</a>
<a name="ln489"> </a>
<a name="ln490">void MasterServiceImpl::CreateUDType(const CreateUDTypeRequestPB* req,</a>
<a name="ln491">                                     CreateUDTypeResponsePB* resp,</a>
<a name="ln492">                                     rpc::RpcContext rpc) {</a>
<a name="ln493">  HandleIn(req, resp, &amp;rpc, &amp;CatalogManager::CreateUDType);</a>
<a name="ln494">}</a>
<a name="ln495"> </a>
<a name="ln496">void MasterServiceImpl::DeleteUDType(const DeleteUDTypeRequestPB* req,</a>
<a name="ln497">                                     DeleteUDTypeResponsePB* resp,</a>
<a name="ln498">                                     rpc::RpcContext rpc) {</a>
<a name="ln499">  HandleIn(req, resp, &amp;rpc, &amp;CatalogManager::DeleteUDType);</a>
<a name="ln500">}</a>
<a name="ln501"> </a>
<a name="ln502">void MasterServiceImpl::ListUDTypes(const ListUDTypesRequestPB* req,</a>
<a name="ln503">                                    ListUDTypesResponsePB* resp,</a>
<a name="ln504">                                    rpc::RpcContext rpc) {</a>
<a name="ln505">  HandleIn(req, resp, &amp;rpc, &amp;CatalogManager::ListUDTypes);</a>
<a name="ln506">}</a>
<a name="ln507"> </a>
<a name="ln508">void MasterServiceImpl::GetUDTypeInfo(const GetUDTypeInfoRequestPB* req,</a>
<a name="ln509">                                      GetUDTypeInfoResponsePB* resp,</a>
<a name="ln510">                                      rpc::RpcContext rpc) {</a>
<a name="ln511">  HandleIn(req, resp, &amp;rpc, &amp;CatalogManager::GetUDTypeInfo);</a>
<a name="ln512">}</a>
<a name="ln513"> </a>
<a name="ln514">// ------------------------------------------------------------------------------------------------</a>
<a name="ln515">// CDC Stream</a>
<a name="ln516">// ------------------------------------------------------------------------------------------------</a>
<a name="ln517"> </a>
<a name="ln518">void MasterServiceImpl::CreateCDCStream(const CreateCDCStreamRequestPB* req,</a>
<a name="ln519">                                        CreateCDCStreamResponsePB* resp,</a>
<a name="ln520">                                        rpc::RpcContext rpc) {</a>
<a name="ln521">  HandleIn(req, resp, &amp;rpc, &amp;enterprise::CatalogManager::CreateCDCStream);</a>
<a name="ln522">}</a>
<a name="ln523"> </a>
<a name="ln524">void MasterServiceImpl::DeleteCDCStream(const DeleteCDCStreamRequestPB* req,</a>
<a name="ln525">                                        DeleteCDCStreamResponsePB* resp,</a>
<a name="ln526">                                        rpc::RpcContext rpc) {</a>
<a name="ln527">  HandleIn(req, resp, &amp;rpc, &amp;enterprise::CatalogManager::DeleteCDCStream);</a>
<a name="ln528">}</a>
<a name="ln529"> </a>
<a name="ln530">void MasterServiceImpl::ListCDCStreams(const ListCDCStreamsRequestPB* req,</a>
<a name="ln531">                                       ListCDCStreamsResponsePB* resp,</a>
<a name="ln532">                                       rpc::RpcContext rpc) {</a>
<a name="ln533">  HandleIn(req, resp, &amp;rpc, &amp;enterprise::CatalogManager::ListCDCStreams);</a>
<a name="ln534">}</a>
<a name="ln535"> </a>
<a name="ln536">void MasterServiceImpl::GetCDCStream(const GetCDCStreamRequestPB* req,</a>
<a name="ln537">                                     GetCDCStreamResponsePB* resp,</a>
<a name="ln538">                                     rpc::RpcContext rpc) {</a>
<a name="ln539">  HandleIn(req, resp, &amp;rpc, &amp;enterprise::CatalogManager::GetCDCStream);</a>
<a name="ln540">}</a>
<a name="ln541"> </a>
<a name="ln542">// ------------------------------------------------------------------------------------------------</a>
<a name="ln543">// Miscellaneous</a>
<a name="ln544">// ------------------------------------------------------------------------------------------------</a>
<a name="ln545"> </a>
<a name="ln546">void MasterServiceImpl::ListTabletServers(const ListTabletServersRequestPB* req,</a>
<a name="ln547">                                          ListTabletServersResponsePB* resp,</a>
<a name="ln548">                                          RpcContext rpc) {</a>
<a name="ln549">  CatalogManager::ScopedLeaderSharedLock l(server_-&gt;catalog_manager());</a>
<a name="ln550">  if (!l.CheckIsInitializedAndIsLeaderOrRespond(resp, &amp;rpc)) {</a>
<a name="ln551">    return;</a>
<a name="ln552">  }</a>
<a name="ln553"> </a>
<a name="ln554">  std::vector&lt;std::shared_ptr&lt;TSDescriptor&gt; &gt; descs;</a>
<a name="ln555">  if (!req-&gt;primary_only()) {</a>
<a name="ln556">    server_-&gt;ts_manager()-&gt;GetAllDescriptors(&amp;descs);</a>
<a name="ln557">  } else {</a>
<a name="ln558">    server_-&gt;ts_manager()-&gt;GetAllLiveDescriptorsInCluster(</a>
<a name="ln559">        &amp;descs,</a>
<a name="ln560">        server_-&gt;catalog_manager()-&gt;placement_uuid());</a>
<a name="ln561">  }</a>
<a name="ln562"> </a>
<a name="ln563">  for (const std::shared_ptr&lt;TSDescriptor&gt;&amp; desc : descs) {</a>
<a name="ln564">    ListTabletServersResponsePB::Entry* entry = resp-&gt;add_servers();</a>
<a name="ln565">    auto ts_info = *desc-&gt;GetTSInformationPB();</a>
<a name="ln566">    *entry-&gt;mutable_instance_id() = std::move(*ts_info.mutable_tserver_instance());</a>
<a name="ln567">    *entry-&gt;mutable_registration() = std::move(*ts_info.mutable_registration());</a>
<a name="ln568">    entry-&gt;set_millis_since_heartbeat(desc-&gt;TimeSinceHeartbeat().ToMilliseconds());</a>
<a name="ln569">    entry-&gt;set_alive(TSManager::IsTSLive(desc));</a>
<a name="ln570">    desc-&gt;GetMetrics(entry-&gt;mutable_metrics());</a>
<a name="ln571">  }</a>
<a name="ln572">  rpc.RespondSuccess();</a>
<a name="ln573">}</a>
<a name="ln574"> </a>
<a name="ln575">void MasterServiceImpl::ListMasters(</a>
<a name="ln576">    const ListMastersRequestPB* req,</a>
<a name="ln577">    ListMastersResponsePB* resp,</a>
<a name="ln578">    RpcContext rpc) {</a>
<a name="ln579">  std::vector&lt;ServerEntryPB&gt; masters;</a>
<a name="ln580">  Status s = server_-&gt;ListMasters(&amp;masters);</a>
<a name="ln581">  if (s.ok()) {</a>
<a name="ln582">    for (const ServerEntryPB&amp; master : masters) {</a>
<a name="ln583">      resp-&gt;add_masters()-&gt;CopyFrom(master);</a>
<a name="ln584">    }</a>
<a name="ln585">    rpc.RespondSuccess();</a>
<a name="ln586">  } else {</a>
<a name="ln587">    SetupErrorAndRespond(resp-&gt;mutable_error(), s, MasterErrorPB_Code_UNKNOWN_ERROR, &amp;rpc);</a>
<a name="ln588">  }</a>
<a name="ln589">}</a>
<a name="ln590"> </a>
<a name="ln591">void MasterServiceImpl::ListMasterRaftPeers(</a>
<a name="ln592">    const ListMasterRaftPeersRequestPB* req,</a>
<a name="ln593">    ListMasterRaftPeersResponsePB* resp,</a>
<a name="ln594">    RpcContext rpc) {</a>
<a name="ln595">  std::vector&lt;RaftPeerPB&gt; masters;</a>
<a name="ln596">  Status s = server_-&gt;ListRaftConfigMasters(&amp;masters);</a>
<a name="ln597">  if (s.ok()) {</a>
<a name="ln598">    for (const RaftPeerPB&amp; master : masters) {</a>
<a name="ln599">      resp-&gt;add_masters()-&gt;CopyFrom(master);</a>
<a name="ln600">    }</a>
<a name="ln601">    rpc.RespondSuccess();</a>
<a name="ln602">  } else {</a>
<a name="ln603">    SetupErrorAndRespond(resp-&gt;mutable_error(), s, MasterErrorPB_Code_UNKNOWN_ERROR, &amp;rpc);</a>
<a name="ln604">  }</a>
<a name="ln605">}</a>
<a name="ln606"> </a>
<a name="ln607">void MasterServiceImpl::GetMasterRegistration(const GetMasterRegistrationRequestPB* req,</a>
<a name="ln608">                                              GetMasterRegistrationResponsePB* resp,</a>
<a name="ln609">                                              RpcContext rpc) {</a>
<a name="ln610">  // instance_id must always be set in order for status pages to be useful.</a>
<a name="ln611">  if (RandomActWithProbability(FLAGS_master_slow_get_registration_probability)) {</a>
<a name="ln612">    std::this_thread::sleep_for(20s);</a>
<a name="ln613">  }</a>
<a name="ln614">  resp-&gt;mutable_instance_id()-&gt;CopyFrom(server_-&gt;instance_pb());</a>
<a name="ln615">  CatalogManager::ScopedLeaderSharedLock l(server_-&gt;catalog_manager());</a>
<a name="ln616">  if (!l.CheckIsInitializedOrRespond(resp, &amp;rpc)) {</a>
<a name="ln617">    return;</a>
<a name="ln618">  }</a>
<a name="ln619">  Status s = server_-&gt;GetMasterRegistration(resp-&gt;mutable_registration());</a>
<a name="ln620">  CheckRespErrorOrSetUnknown(s, resp);</a>
<a name="ln621">  auto role = server_-&gt;catalog_manager()-&gt;Role();</a>
<a name="ln622">  if (role == RaftPeerPB::LEADER) {</a>
<a name="ln623">    if (!l.leader_status().ok()) {</a>
<a name="ln624">      YB_LOG_EVERY_N_SECS(INFO, 1)</a>
<a name="ln625">          &lt;&lt; &quot;Patching role from leader to follower because of: &quot; &lt;&lt; l.leader_status()</a>
<a name="ln626">          &lt;&lt; THROTTLE_MSG;</a>
<a name="ln627">      role = RaftPeerPB::FOLLOWER;</a>
<a name="ln628">    }</a>
<a name="ln629">  }</a>
<a name="ln630">  resp-&gt;set_role(role);</a>
<a name="ln631">  rpc.RespondSuccess();</a>
<a name="ln632">}</a>
<a name="ln633"> </a>
<a name="ln634">void MasterServiceImpl::DumpState(</a>
<a name="ln635">    const DumpMasterStateRequestPB* req,</a>
<a name="ln636">    DumpMasterStateResponsePB* resp,</a>
<a name="ln637">    RpcContext rpc) {</a>
<a name="ln638">  CatalogManager::ScopedLeaderSharedLock l(server_-&gt;catalog_manager());</a>
<a name="ln639">  if (!l.CheckIsInitializedOrRespond(resp, &amp;rpc)) {</a>
<a name="ln640">    return;</a>
<a name="ln641">  }</a>
<a name="ln642"> </a>
<a name="ln643">  const string role = (req-&gt;has_peers_also() &amp;&amp; req-&gt;peers_also() ? &quot;Leader&quot; : &quot;Follower&quot;);</a>
<a name="ln644">  const string title = role + &quot; Master &quot; + server_-&gt;instance_pb().permanent_uuid();</a>
<a name="ln645"> </a>
<a name="ln646">  if (req-&gt;return_dump_as_string()) {</a>
<a name="ln647">    ostringstream ss;</a>
<a name="ln648">    server_-&gt;catalog_manager()-&gt;DumpState(&amp;ss, req-&gt;on_disk());</a>
<a name="ln649">    resp-&gt;set_dump(title + &quot;:\n&quot; + ss.str());</a>
<a name="ln650">  } else {</a>
<a name="ln651">    LOG(INFO) &lt;&lt; title;</a>
<a name="ln652">    server_-&gt;catalog_manager()-&gt;DumpState(&amp;LOG(INFO), req-&gt;on_disk());</a>
<a name="ln653">  }</a>
<a name="ln654"> </a>
<a name="ln655">  if (req-&gt;has_peers_also() &amp;&amp; req-&gt;peers_also()) {</a>
<a name="ln656">    std::vector&lt;RaftPeerPB&gt; masters_raft;</a>
<a name="ln657">    Status s = server_-&gt;ListRaftConfigMasters(&amp;masters_raft);</a>
<a name="ln658">    CheckRespErrorOrSetUnknown(s, resp);</a>
<a name="ln659"> </a>
<a name="ln660">    if (!s.ok())</a>
<a name="ln661">      return;</a>
<a name="ln662"> </a>
<a name="ln663">    LOG(INFO) &lt;&lt; &quot;Sending dump command to &quot; &lt;&lt; masters_raft.size()-1 &lt;&lt; &quot; peers.&quot;;</a>
<a name="ln664"> </a>
<a name="ln665">    // Remove our entry before broadcasting to all peers.</a>
<a name="ln666">    std::vector&lt;RaftPeerPB&gt;::iterator it;</a>
<a name="ln667">    bool found = false;</a>
<a name="ln668">    for (it = masters_raft.begin(); it != masters_raft.end(); it++) {</a>
<a name="ln669">      RaftPeerPB peerPB = *it;</a>
<a name="ln670">      if (server_-&gt;instance_pb().permanent_uuid() == peerPB.permanent_uuid()) {</a>
<a name="ln671">        found = true;</a>
<a name="ln672">        break;</a>
<a name="ln673">      }</a>
<a name="ln674">    }</a>
<a name="ln675"> </a>
<a name="ln676">    if (!found) {</a>
<a name="ln677">      CHECK(found) &lt;&lt; &quot;Did not find leader in Raft config&quot;;</a>
<a name="ln678">    }</a>
<a name="ln679"> </a>
<a name="ln680">    masters_raft.erase(it);</a>
<a name="ln681"> </a>
<a name="ln682">    s = server_-&gt;catalog_manager()-&gt;PeerStateDump(masters_raft, req, resp);</a>
<a name="ln683">    CheckRespErrorOrSetUnknown(s, resp);</a>
<a name="ln684">  }</a>
<a name="ln685"> </a>
<a name="ln686">  rpc.RespondSuccess();</a>
<a name="ln687">}</a>
<a name="ln688"> </a>
<a name="ln689">void MasterServiceImpl::RemovedMasterUpdate(const RemovedMasterUpdateRequestPB* req,</a>
<a name="ln690">                                            RemovedMasterUpdateResponsePB* resp,</a>
<a name="ln691">                                            RpcContext rpc) {</a>
<a name="ln692">  CatalogManager::ScopedLeaderSharedLock l(server_-&gt;catalog_manager());</a>
<a name="ln693">  if (!l.CheckIsInitializedOrRespond(resp, &amp;rpc)) {</a>
<a name="ln694">    return;</a>
<a name="ln695">  }</a>
<a name="ln696"> </a>
<a name="ln697">  Status s = server_-&gt;GoIntoShellMode();</a>
<a name="ln698">  CheckRespErrorOrSetUnknown(s, resp);</a>
<a name="ln699">  rpc.RespondSuccess();</a>
<a name="ln700">}</a>
<a name="ln701"> </a>
<a name="ln702">void MasterServiceImpl::ChangeLoadBalancerState(</a>
<a name="ln703">    const ChangeLoadBalancerStateRequestPB* req, ChangeLoadBalancerStateResponsePB* resp,</a>
<a name="ln704">    RpcContext rpc) {</a>
<a name="ln705">  // This should work on both followers and leaders, in order to cover leader failover!</a>
<a name="ln706">  if (req-&gt;has_is_enabled()) {</a>
<a name="ln707">    LOG(INFO) &lt;&lt; &quot;Changing balancer state to &quot; &lt;&lt; req-&gt;is_enabled();</a>
<a name="ln708">    server_-&gt;catalog_manager()-&gt;SetLoadBalancerEnabled(req-&gt;is_enabled());</a>
<a name="ln709">  }</a>
<a name="ln710"> </a>
<a name="ln711">  rpc.RespondSuccess();</a>
<a name="ln712">}</a>
<a name="ln713"> </a>
<a name="ln714">void MasterServiceImpl::GetLoadBalancerState(</a>
<a name="ln715">    const GetLoadBalancerStateRequestPB* req, GetLoadBalancerStateResponsePB* resp,</a>
<a name="ln716">    RpcContext rpc) {</a>
<a name="ln717">  resp-&gt;set_is_enabled(server_-&gt;catalog_manager()-&gt;IsLoadBalancerEnabled());</a>
<a name="ln718">  rpc.RespondSuccess();</a>
<a name="ln719">}</a>
<a name="ln720"> </a>
<a name="ln721">void MasterServiceImpl::SetPreferredZones(</a>
<a name="ln722">    const SetPreferredZonesRequestPB* req, SetPreferredZonesResponsePB* resp,</a>
<a name="ln723">    RpcContext rpc) {</a>
<a name="ln724">  HandleIn(req, resp, &amp;rpc, &amp;CatalogManager::SetPreferredZones);</a>
<a name="ln725">}</a>
<a name="ln726"> </a>
<a name="ln727">void MasterServiceImpl::GetMasterClusterConfig(</a>
<a name="ln728">    const GetMasterClusterConfigRequestPB* req, GetMasterClusterConfigResponsePB* resp,</a>
<a name="ln729">    RpcContext rpc) {</a>
<a name="ln730">  // Explicit instantiation here because the handler method has a few overloadings.</a>
<a name="ln731">  HandleIn&lt;CatalogManager&gt;(req, resp, &amp;rpc, &amp;CatalogManager::GetClusterConfig);</a>
<a name="ln732">}</a>
<a name="ln733"> </a>
<a name="ln734">void MasterServiceImpl::ChangeMasterClusterConfig(</a>
<a name="ln735">    const ChangeMasterClusterConfigRequestPB* req, ChangeMasterClusterConfigResponsePB* resp,</a>
<a name="ln736">    RpcContext rpc) {</a>
<a name="ln737">  HandleIn(req, resp, &amp;rpc, &amp;CatalogManager::SetClusterConfig);</a>
<a name="ln738">}</a>
<a name="ln739"> </a>
<a name="ln740">void MasterServiceImpl::GetLoadMoveCompletion(</a>
<a name="ln741">    const GetLoadMovePercentRequestPB* req, GetLoadMovePercentResponsePB* resp,</a>
<a name="ln742">    RpcContext rpc) {</a>
<a name="ln743">  HandleIn(req, resp, &amp;rpc, &amp;CatalogManager::GetLoadMoveCompletionPercent);</a>
<a name="ln744">}</a>
<a name="ln745"> </a>
<a name="ln746">void MasterServiceImpl::GetLeaderBlacklistCompletion(</a>
<a name="ln747">    const GetLeaderBlacklistPercentRequestPB* req, GetLoadMovePercentResponsePB* resp,</a>
<a name="ln748">    RpcContext rpc) {</a>
<a name="ln749">  HandleIn(req, resp, &amp;rpc, &amp;CatalogManager::GetLeaderBlacklistCompletionPercent);</a>
<a name="ln750">}</a>
<a name="ln751"> </a>
<a name="ln752">void MasterServiceImpl::IsMasterLeaderServiceReady(</a>
<a name="ln753">    const IsMasterLeaderReadyRequestPB* req, IsMasterLeaderReadyResponsePB* resp,</a>
<a name="ln754">    RpcContext rpc) {</a>
<a name="ln755">  CatalogManager::ScopedLeaderSharedLock l(server_-&gt;catalog_manager());</a>
<a name="ln756">  if (!l.CheckIsInitializedAndIsLeaderOrRespond(resp, &amp;rpc)) {</a>
<a name="ln757">    return;</a>
<a name="ln758">  }</a>
<a name="ln759"> </a>
<a name="ln760">  rpc.RespondSuccess();</a>
<a name="ln761">}</a>
<a name="ln762"> </a>
<a name="ln763">void MasterServiceImpl::IsLoadBalanced(</a>
<a name="ln764">    const IsLoadBalancedRequestPB* req, IsLoadBalancedResponsePB* resp,</a>
<a name="ln765">    RpcContext rpc) {</a>
<a name="ln766">  HandleIn(req, resp, &amp;rpc, &amp;CatalogManager::IsLoadBalanced);</a>
<a name="ln767">}</a>
<a name="ln768"> </a>
<a name="ln769">void MasterServiceImpl::IsLoadBalancerIdle(</a>
<a name="ln770">    const IsLoadBalancerIdleRequestPB* req, IsLoadBalancerIdleResponsePB* resp,</a>
<a name="ln771">    RpcContext rpc) {</a>
<a name="ln772">  HandleIn(req, resp, &amp;rpc, &amp;CatalogManager::IsLoadBalancerIdle);</a>
<a name="ln773">}</a>
<a name="ln774"> </a>
<a name="ln775">void MasterServiceImpl::AreLeadersOnPreferredOnly(</a>
<a name="ln776">    const AreLeadersOnPreferredOnlyRequestPB* req, AreLeadersOnPreferredOnlyResponsePB* resp,</a>
<a name="ln777">    RpcContext rpc) {</a>
<a name="ln778">  HandleIn(req, resp, &amp;rpc, &amp;CatalogManager::AreLeadersOnPreferredOnly);</a>
<a name="ln779">}</a>
<a name="ln780"> </a>
<a name="ln781">void MasterServiceImpl::FlushTables(const FlushTablesRequestPB* req,</a>
<a name="ln782">                                    FlushTablesResponsePB* resp,</a>
<a name="ln783">                                    RpcContext rpc) {</a>
<a name="ln784">  HandleIn(req, resp, &amp;rpc, &amp;FlushManager::FlushTables);</a>
<a name="ln785">}</a>
<a name="ln786"> </a>
<a name="ln787">void MasterServiceImpl::IsFlushTablesDone(const IsFlushTablesDoneRequestPB* req,</a>
<a name="ln788">                                          IsFlushTablesDoneResponsePB* resp,</a>
<a name="ln789">                                          RpcContext rpc) {</a>
<a name="ln790">  HandleIn(req, resp, &amp;rpc, &amp;FlushManager::IsFlushTablesDone);</a>
<a name="ln791">}</a>
<a name="ln792"> </a>
<a name="ln793">void MasterServiceImpl::IsInitDbDone(const IsInitDbDoneRequestPB* req,</a>
<a name="ln794">                                     IsInitDbDoneResponsePB* resp,</a>
<a name="ln795">                                     RpcContext rpc) {</a>
<a name="ln796">  HandleIn(req, resp, &amp;rpc, &amp;CatalogManager::IsInitDbDone, HoldCatalogLock::kFalse);</a>
<a name="ln797">}</a>
<a name="ln798"> </a>
<a name="ln799">void MasterServiceImpl::ChangeEncryptionInfo(const ChangeEncryptionInfoRequestPB* req,</a>
<a name="ln800">                                             ChangeEncryptionInfoResponsePB* resp,</a>
<a name="ln801">                                             rpc::RpcContext rpc) {</a>
<a name="ln802">  HandleIn(req, resp, &amp;rpc, &amp;enterprise::CatalogManager::ChangeEncryptionInfo);</a>
<a name="ln803">}</a>
<a name="ln804"> </a>
<a name="ln805">void MasterServiceImpl::IsEncryptionEnabled(const IsEncryptionEnabledRequestPB* req,</a>
<a name="ln806">                                            IsEncryptionEnabledResponsePB* resp,</a>
<a name="ln807">                                            rpc::RpcContext rpc) {</a>
<a name="ln808">  HandleIn(req, resp, &amp;rpc, &amp;enterprise::CatalogManager::IsEncryptionEnabled);</a>
<a name="ln809">}</a>
<a name="ln810"> </a>
<a name="ln811">void MasterServiceImpl::GetUniverseKeyRegistry(const GetUniverseKeyRegistryRequestPB* req,</a>
<a name="ln812">                                               GetUniverseKeyRegistryResponsePB* resp,</a>
<a name="ln813">                                               rpc::RpcContext rpc) {</a>
<a name="ln814">  HandleOnAllMasters(req, resp, &amp;rpc, &amp;EncryptionManager::GetUniverseKeyRegistry);</a>
<a name="ln815">}</a>
<a name="ln816"> </a>
<a name="ln817">void MasterServiceImpl::AddUniverseKeys(const AddUniverseKeysRequestPB* req,</a>
<a name="ln818">                                        AddUniverseKeysResponsePB* resp,</a>
<a name="ln819">                                        rpc::RpcContext rpc) {</a>
<a name="ln820">  HandleOnAllMasters(req, resp, &amp;rpc, &amp;EncryptionManager::AddUniverseKeys);</a>
<a name="ln821">}</a>
<a name="ln822"> </a>
<a name="ln823">void MasterServiceImpl::HasUniverseKeyInMemory(const HasUniverseKeyInMemoryRequestPB* req,</a>
<a name="ln824">                                               HasUniverseKeyInMemoryResponsePB* resp,</a>
<a name="ln825">                                               rpc::RpcContext rpc) {</a>
<a name="ln826">  HandleOnAllMasters(req, resp, &amp;rpc, &amp;EncryptionManager::HasUniverseKeyInMemory);</a>
<a name="ln827">}</a>
<a name="ln828"> </a>
<a name="ln829">void MasterServiceImpl::SetupUniverseReplication(const SetupUniverseReplicationRequestPB* req,</a>
<a name="ln830">                                                 SetupUniverseReplicationResponsePB* resp,</a>
<a name="ln831">                                                 rpc::RpcContext rpc) {</a>
<a name="ln832">  HandleIn(req, resp, &amp;rpc, &amp;enterprise::CatalogManager::SetupUniverseReplication);</a>
<a name="ln833">}</a>
<a name="ln834"> </a>
<a name="ln835">void MasterServiceImpl::DeleteUniverseReplication(const DeleteUniverseReplicationRequestPB* req,</a>
<a name="ln836">                                                  DeleteUniverseReplicationResponsePB* resp,</a>
<a name="ln837">                                                  rpc::RpcContext rpc) {</a>
<a name="ln838">  HandleIn(req, resp, &amp;rpc, &amp;enterprise::CatalogManager::DeleteUniverseReplication);</a>
<a name="ln839">}</a>
<a name="ln840"> </a>
<a name="ln841">void MasterServiceImpl::AlterUniverseReplication(const AlterUniverseReplicationRequestPB* req,</a>
<a name="ln842">                                                  AlterUniverseReplicationResponsePB* resp,</a>
<a name="ln843">                                                  rpc::RpcContext rpc) {</a>
<a name="ln844">  HandleIn(req, resp, &amp;rpc, &amp;enterprise::CatalogManager::AlterUniverseReplication);</a>
<a name="ln845">}</a>
<a name="ln846"> </a>
<a name="ln847">void MasterServiceImpl::SetUniverseReplicationEnabled(</a>
<a name="ln848">                          const SetUniverseReplicationEnabledRequestPB* req,</a>
<a name="ln849">                          SetUniverseReplicationEnabledResponsePB* resp,</a>
<a name="ln850">                          rpc::RpcContext rpc) {</a>
<a name="ln851">  HandleIn(req, resp, &amp;rpc, &amp;enterprise::CatalogManager::SetUniverseReplicationEnabled);</a>
<a name="ln852">}</a>
<a name="ln853"> </a>
<a name="ln854">void MasterServiceImpl::GetUniverseReplication(const GetUniverseReplicationRequestPB* req,</a>
<a name="ln855">                                               GetUniverseReplicationResponsePB* resp,</a>
<a name="ln856">                                               rpc::RpcContext rpc) {</a>
<a name="ln857">  HandleIn(req, resp, &amp;rpc, &amp;enterprise::CatalogManager::GetUniverseReplication);</a>
<a name="ln858">}</a>
<a name="ln859"> </a>
<a name="ln860">void MasterServiceImpl::SplitTablet(</a>
<a name="ln861">    const SplitTabletRequestPB* req, SplitTabletResponsePB* resp, rpc::RpcContext rpc) {</a>
<a name="ln862">  HandleIn(req, resp, &amp;rpc, &amp;CatalogManager::SplitTablet);</a>
<a name="ln863">}</a>
<a name="ln864"> </a>
<a name="ln865">} // namespace master</a>
<a name="ln866">} // namespace yb</a>

</code></pre>
<div class="balloon" rel="677"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
