
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>map-util.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Copyright 2005 Google Inc.</a>
<a name="ln2">//</a>
<a name="ln3">// #status: RECOMMENDED</a>
<a name="ln4">// #category: maps</a>
<a name="ln5">// #summary: Utility functions for use with map-like containers.</a>
<a name="ln6">//</a>
<a name="ln7">// This file provides utility functions for use with STL map-like data</a>
<a name="ln8">// structures, such as std::map and hash_map. Some functions will also work with</a>
<a name="ln9">// sets, such as ContainsKey().</a>
<a name="ln10">//</a>
<a name="ln11">// The main functions in this file fall into the following categories:</a>
<a name="ln12">//</a>
<a name="ln13">// - Find*()</a>
<a name="ln14">// - Contains*()</a>
<a name="ln15">// - Insert*()</a>
<a name="ln16">// - Lookup*()</a>
<a name="ln17">//</a>
<a name="ln18">// These functions often have &quot;...OrDie&quot; or &quot;...OrDieNoPrint&quot; variants. These</a>
<a name="ln19">// variants will crash the process with a CHECK() failure on error, including</a>
<a name="ln20">// the offending key/data in the log message. The NoPrint variants will not</a>
<a name="ln21">// include the key/data in the log output under the assumption that it's not a</a>
<a name="ln22">// printable type.</a>
<a name="ln23">//</a>
<a name="ln24">// Most functions are fairly self explanatory from their names, with the</a>
<a name="ln25">// exception of Find*() vs Lookup*(). The Find functions typically use the map's</a>
<a name="ln26">// .find() member function to locate and return the map's value type. The</a>
<a name="ln27">// Lookup*() functions typically use the map's .insert() (yes, insert) member</a>
<a name="ln28">// function to insert the given value if necessary and returns (usually a</a>
<a name="ln29">// reference to) the map's value type for the found item.</a>
<a name="ln30">//</a>
<a name="ln31">// See the per-function comments for specifics.</a>
<a name="ln32">//</a>
<a name="ln33">// There are also a handful of functions for doing other miscellaneous things.</a>
<a name="ln34">//</a>
<a name="ln35">// A note on terminology:</a>
<a name="ln36">//</a>
<a name="ln37">// Map-like containers are collections of pairs. Like all STL containers they</a>
<a name="ln38">// contain a few standard typedefs identifying the types of data they contain.</a>
<a name="ln39">// Given the following map declaration:</a>
<a name="ln40">//</a>
<a name="ln41">//   map&lt;string, int&gt; my_map;</a>
<a name="ln42">//</a>
<a name="ln43">// the notable typedefs would be as follows:</a>
<a name="ln44">//</a>
<a name="ln45">//   - key_type    -- string</a>
<a name="ln46">//   - value_type  -- pair&lt;const string, int&gt;</a>
<a name="ln47">//   - mapped_type -- int</a>
<a name="ln48">//</a>
<a name="ln49">// Note that the map above contains two types of &quot;values&quot;: the key-value pairs</a>
<a name="ln50">// themselves (value_type) and the values within the key-value pairs</a>
<a name="ln51">// (mapped_type). A value_type consists of a key_type and a mapped_type.</a>
<a name="ln52">//</a>
<a name="ln53">// The documentation below is written for programmers thinking in terms of keys</a>
<a name="ln54">// and the (mapped_type) values associated with a given key.  For example, the</a>
<a name="ln55">// statement</a>
<a name="ln56">//</a>
<a name="ln57">//   my_map[&quot;foo&quot;] = 3;</a>
<a name="ln58">//</a>
<a name="ln59">// has a key of &quot;foo&quot; (type: string) with a value of 3 (type: int).</a>
<a name="ln60">//</a>
<a name="ln61"> </a>
<a name="ln62">//</a>
<a name="ln63">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln64">//</a>
<a name="ln65">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln66">//</a>
<a name="ln67">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln68">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln69">//</a>
<a name="ln70">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln71">//</a>
<a name="ln72">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln73">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln74">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln75">// under the License.</a>
<a name="ln76">//</a>
<a name="ln77">#ifndef YB_GUTIL_MAP_UTIL_H</a>
<a name="ln78">#define YB_GUTIL_MAP_UTIL_H</a>
<a name="ln79"> </a>
<a name="ln80">#include &lt;stddef.h&gt;</a>
<a name="ln81">#include &lt;string&gt;</a>
<a name="ln82">#include &lt;utility&gt;</a>
<a name="ln83">#include &lt;tuple&gt;</a>
<a name="ln84">#include &lt;vector&gt;</a>
<a name="ln85"> </a>
<a name="ln86">using std::make_pair;</a>
<a name="ln87">using std::pair;</a>
<a name="ln88">using std::string;</a>
<a name="ln89">using std::vector;</a>
<a name="ln90"> </a>
<a name="ln91">#include &lt;glog/logging.h&gt;</a>
<a name="ln92"> </a>
<a name="ln93">#include &quot;yb/gutil/logging-inl.h&quot;</a>
<a name="ln94"> </a>
<a name="ln95">//</a>
<a name="ln96">// Find*()</a>
<a name="ln97">//</a>
<a name="ln98"> </a>
<a name="ln99">// Returns a const reference to the value associated with the given key if it</a>
<a name="ln100">// exists. Crashes otherwise.</a>
<a name="ln101">//</a>
<a name="ln102">// This is intended as a replacement for operator[] as an rvalue (for reading)</a>
<a name="ln103">// when the key is guaranteed to exist.</a>
<a name="ln104">//</a>
<a name="ln105">// operator[] for lookup is discouraged for several reasons:</a>
<a name="ln106">//  * It has a side-effect of inserting missing keys</a>
<a name="ln107">//  * It is not thread-safe (even when it is not inserting, it can still</a>
<a name="ln108">//      choose to resize the underlying storage)</a>
<a name="ln109">//  * It invalidates iterators (when it chooses to resize)</a>
<a name="ln110">//  * It default constructs a value object even if it doesn't need to</a>
<a name="ln111">//</a>
<a name="ln112">// This version assumes the key is printable, and includes it in the fatal log</a>
<a name="ln113">// message.</a>
<a name="ln114">template &lt;class Collection&gt;</a>
<a name="ln115">const typename Collection::value_type::second_type&amp;</a>
<a name="ln116">FindOrDie(const Collection&amp; collection,</a>
<a name="ln117">          const typename Collection::value_type::first_type&amp; key) {</a>
<a name="ln118">  auto it = collection.find(key);</a>
<a name="ln119">  CHECK(it != collection.end()) &lt;&lt; &quot;Map key not found: &quot; &lt;&lt; key;</a>
<a name="ln120">  return it-&gt;second;</a>
<a name="ln121">}</a>
<a name="ln122"> </a>
<a name="ln123">// Same as above, but returns a non-const reference.</a>
<a name="ln124">template &lt;class Collection&gt;</a>
<a name="ln125">typename Collection::value_type::second_type&amp;</a>
<a name="ln126">FindOrDie(Collection&amp; collection,  // NOLINT</a>
<a name="ln127">          const typename Collection::value_type::first_type&amp; key) {</a>
<a name="ln128">  auto it = collection.find(key);</a>
<a name="ln129">  CHECK(it != collection.end()) &lt;&lt; &quot;Map key not found: &quot; &lt;&lt; key;</a>
<a name="ln130">  return it-&gt;second;</a>
<a name="ln131">}</a>
<a name="ln132"> </a>
<a name="ln133">// Same as FindOrDie above, but doesn't log the key on failure.</a>
<a name="ln134">template &lt;class Collection&gt;</a>
<a name="ln135">const typename Collection::value_type::second_type&amp;</a>
<a name="ln136">FindOrDieNoPrint(const Collection&amp; collection,</a>
<a name="ln137">                 const typename Collection::value_type::first_type&amp; key) {</a>
<a name="ln138">  typename Collection::const_iterator it = collection.find(key);</a>
<a name="ln139">  CHECK(it != collection.end()) &lt;&lt; &quot;Map key not found&quot;;</a>
<a name="ln140">  return it-&gt;second;</a>
<a name="ln141">}</a>
<a name="ln142"> </a>
<a name="ln143">// Same as above, but returns a non-const reference.</a>
<a name="ln144">template &lt;class Collection&gt;</a>
<a name="ln145">typename Collection::value_type::second_type&amp;</a>
<a name="ln146">FindOrDieNoPrint(Collection&amp; collection,  // NOLINT</a>
<a name="ln147">                 const typename Collection::value_type::first_type&amp; key) {</a>
<a name="ln148">  typename Collection::iterator it = collection.find(key);</a>
<a name="ln149">  CHECK(it != collection.end()) &lt;&lt; &quot;Map key not found&quot;;</a>
<a name="ln150">  return it-&gt;second;</a>
<a name="ln151">}</a>
<a name="ln152"> </a>
<a name="ln153">// Returns a const reference to the value associated with the given key if it</a>
<a name="ln154">// exists, otherwise a const reference to the provided default value is</a>
<a name="ln155">// returned.</a>
<a name="ln156">//</a>
<a name="ln157">// WARNING: If a temporary object is passed as the default &quot;value,&quot; this</a>
<a name="ln158">// function will return a reference to that temporary object, which will be</a>
<a name="ln159">// destroyed by the end of the statement. Specifically, if you have a map with</a>
<a name="ln160">// string values, and you pass a char* as the default &quot;value,&quot; either use the</a>
<a name="ln161">// returned value immediately or store it in a string (not string&amp;). Details:</a>
<a name="ln162">template &lt;class Collection&gt;</a>
<a name="ln163">const typename Collection::value_type::second_type&amp;</a>
<a name="ln164">FindWithDefault(const Collection&amp; collection,</a>
<a name="ln165">                const typename Collection::value_type::first_type&amp; key,</a>
<a name="ln166">                const typename Collection::value_type::second_type&amp; value) {</a>
<a name="ln167">  auto it = collection.find(key);</a>
<a name="ln168">  if (it == collection.end()) {</a>
<a name="ln169">    return value;</a>
<a name="ln170">  }</a>
<a name="ln171">  return it-&gt;second;</a>
<a name="ln172">}</a>
<a name="ln173"> </a>
<a name="ln174">// Returns a pointer to the const value associated with the given key if it</a>
<a name="ln175">// exists, or NULL otherwise.</a>
<a name="ln176">template &lt;class Collection&gt;</a>
<a name="ln177">const typename Collection::value_type::second_type*</a>
<a name="ln178">FindOrNull(const Collection&amp; collection,</a>
<a name="ln179">           const typename Collection::value_type::first_type&amp; key) {</a>
<a name="ln180">  auto it = collection.find(key);</a>
<a name="ln181">  if (it == collection.end()) {</a>
<a name="ln182">    return 0;</a>
<a name="ln183">  }</a>
<a name="ln184">  return &amp;it-&gt;second;</a>
<a name="ln185">}</a>
<a name="ln186"> </a>
<a name="ln187">// Same as above but returns a pointer to the non-const value.</a>
<a name="ln188">template &lt;class Collection&gt;</a>
<a name="ln189">typename Collection::value_type::second_type*</a>
<a name="ln190">FindOrNull(Collection&amp; collection,  // NOLINT</a>
<a name="ln191">           const typename Collection::value_type::first_type&amp; key) {</a>
<a name="ln192">  auto it = collection.find(key);</a>
<a name="ln193">  if (it == collection.end()) {</a>
<a name="ln194">    return 0;</a>
<a name="ln195">  }</a>
<a name="ln196">  return &amp;it-&gt;second;</a>
<a name="ln197">}</a>
<a name="ln198"> </a>
<a name="ln199">// Returns a pointer to the const value associated with the greatest key</a>
<a name="ln200">// that's less than or equal to the given key, or NULL if no such key exists.</a>
<a name="ln201">template &lt;class Collection&gt;</a>
<a name="ln202">const typename Collection::value_type::second_type*</a>
<a name="ln203">FindFloorOrNull(const Collection&amp; collection,</a>
<a name="ln204">                const typename Collection::value_type::first_type&amp; key) {</a>
<a name="ln205">  auto it = collection.upper_bound(key);</a>
<a name="ln206">  if (it == collection.begin()) {</a>
<a name="ln207">    return 0;</a>
<a name="ln208">  }</a>
<a name="ln209">  return &amp;(--it)-&gt;second;</a>
<a name="ln210">}</a>
<a name="ln211"> </a>
<a name="ln212">// Same as above but returns a pointer to the non-const value.</a>
<a name="ln213">template &lt;class Collection&gt;</a>
<a name="ln214">typename Collection::value_type::second_type*</a>
<a name="ln215">FindFloorOrNull(Collection&amp; collection,  // NOLINT</a>
<a name="ln216">                const typename Collection::value_type::first_type&amp; key) {</a>
<a name="ln217">  auto it = collection.upper_bound(key);</a>
<a name="ln218">  if (it == collection.begin()) {</a>
<a name="ln219">    return 0;</a>
<a name="ln220">  }</a>
<a name="ln221">  return &amp;(--it)-&gt;second;</a>
<a name="ln222">}</a>
<a name="ln223"> </a>
<a name="ln224">// Returns the pointer value associated with the given key. If none is found,</a>
<a name="ln225">// NULL is returned. The function is designed to be used with a map of keys to</a>
<a name="ln226">// pointers.</a>
<a name="ln227">//</a>
<a name="ln228">// This function does not distinguish between a missing key and a key mapped</a>
<a name="ln229">// to a NULL value.</a>
<a name="ln230">template &lt;class Collection&gt;</a>
<a name="ln231">typename Collection::value_type::second_type</a>
<a name="ln232">FindPtrOrNull(const Collection&amp; collection,</a>
<a name="ln233">              const typename Collection::value_type::first_type&amp; key) {</a>
<a name="ln234">  auto it = collection.find(key);</a>
<a name="ln235">  if (it == collection.end()) {</a>
<a name="ln236">    return typename Collection::value_type::second_type(0);</a>
<a name="ln237">  }</a>
<a name="ln238">  return it-&gt;second;</a>
<a name="ln239">}</a>
<a name="ln240"> </a>
<a name="ln241">// Same as above, except takes non-const reference to collection.</a>
<a name="ln242">//</a>
<a name="ln243">// This function is needed for containers that propagate constness to the</a>
<a name="ln244">// pointee, such as boost::ptr_map.</a>
<a name="ln245">template &lt;class Collection&gt;</a>
<a name="ln246">typename Collection::value_type::second_type</a>
<a name="ln247">FindPtrOrNull(Collection&amp; collection,  // NOLINT</a>
<a name="ln248">              const typename Collection::value_type::first_type&amp; key) {</a>
<a name="ln249">  auto it = collection.find(key);</a>
<a name="ln250">  if (it == collection.end()) {</a>
<a name="ln251">    return typename Collection::value_type::second_type(0);</a>
<a name="ln252">  }</a>
<a name="ln253">  return it-&gt;second;</a>
<a name="ln254">}</a>
<a name="ln255"> </a>
<a name="ln256">// Finds the value associated with the given key and copies it to *value (if not</a>
<a name="ln257">// NULL). Returns false if the key was not found, true otherwise.</a>
<a name="ln258">template &lt;class Collection, class Key, class Value&gt;</a>
<a name="ln259">bool FindCopy(const Collection&amp; collection,</a>
<a name="ln260">              const Key&amp; key,</a>
<a name="ln261">              Value* const value) {</a>
<a name="ln262">  auto it = collection.find(key);</a>
<a name="ln263">  if (it == collection.end()) {</a>
<a name="ln264">    return false;</a>
<a name="ln265">  }</a>
<a name="ln266">  if (value) {</a>
<a name="ln267">    *value = it-&gt;second;</a>
<a name="ln268">  }</a>
<a name="ln269">  return true;</a>
<a name="ln270">}</a>
<a name="ln271"> </a>
<a name="ln272">//</a>
<a name="ln273">// Contains*()</a>
<a name="ln274">//</a>
<a name="ln275"> </a>
<a name="ln276">// Returns true iff the given collection contains the given key.</a>
<a name="ln277">template &lt;class Collection, class Key&gt;</a>
<a name="ln278">bool ContainsKey(const Collection&amp; collection, const Key&amp; key) {</a>
<a name="ln279">  auto it = collection.find(key);</a>
<a name="ln280">  return it != collection.end();</a>
<a name="ln281">}</a>
<a name="ln282"> </a>
<a name="ln283">// Returns true iff the given collection contains the given key-value pair.</a>
<a name="ln284">template &lt;class Collection, class Key, class Value&gt;</a>
<a name="ln285">bool ContainsKeyValuePair(const Collection&amp; collection,</a>
<a name="ln286">                          const Key&amp; key,</a>
<a name="ln287">                          const Value&amp; value) {</a>
<a name="ln288">  typedef typename Collection::const_iterator const_iterator;</a>
<a name="ln289">  pair&lt;const_iterator, const_iterator&gt; range = collection.equal_range(key);</a>
<a name="ln290">  for (const_iterator it = range.first; it != range.second; ++it) {</a>
<a name="ln291">    if (it-&gt;second == value) {</a>
<a name="ln292">      return true;</a>
<a name="ln293">    }</a>
<a name="ln294">  }</a>
<a name="ln295">  return false;</a>
<a name="ln296">}</a>
<a name="ln297"> </a>
<a name="ln298">//</a>
<a name="ln299">// Insert*()</a>
<a name="ln300">//</a>
<a name="ln301"> </a>
<a name="ln302">// Inserts the given key-value pair into the collection. Returns true if the</a>
<a name="ln303">// given key didn't previously exist. If the given key already existed in the</a>
<a name="ln304">// map, its value is changed to the given &quot;value&quot; and false is returned.</a>
<a name="ln305">template &lt;class Collection&gt;</a>
<a name="ln306">bool InsertOrUpdate(Collection* const collection,</a>
<a name="ln307">                    const typename Collection::value_type&amp; vt) {</a>
<a name="ln308">  pair&lt;typename Collection::iterator, bool&gt; ret = collection-&gt;insert(vt);</a>
<a name="ln309">  if (!ret.second) {</a>
<a name="ln310">    // update</a>
<a name="ln311">    ret.first-&gt;second = vt.second;</a>
<a name="ln312">    return false;</a>
<a name="ln313">  }</a>
<a name="ln314">  return true;</a>
<a name="ln315">}</a>
<a name="ln316"> </a>
<a name="ln317">// Same as above, except that the key and value are passed separately.</a>
<a name="ln318">template &lt;class Collection&gt;</a>
<a name="ln319">bool InsertOrUpdate(Collection* const collection,</a>
<a name="ln320">                    const typename Collection::value_type::first_type&amp; key,</a>
<a name="ln321">                    const typename Collection::value_type::second_type&amp; value) {</a>
<a name="ln322">  return InsertOrUpdate(</a>
<a name="ln323">      collection, typename Collection::value_type(key, value));</a>
<a name="ln324">}</a>
<a name="ln325"> </a>
<a name="ln326">// Inserts/updates all the key-value pairs from the range defined by the</a>
<a name="ln327">// iterators &quot;first&quot; and &quot;last&quot; into the given collection.</a>
<a name="ln328">template &lt;class Collection, class InputIterator&gt;</a>
<a name="ln329">void InsertOrUpdateMany(Collection* const collection,</a>
<a name="ln330">                        InputIterator first, InputIterator last) {</a>
<a name="ln331">  for (; first != last; ++first) {</a>
<a name="ln332">    InsertOrUpdate(collection, *first);</a>
<a name="ln333">  }</a>
<a name="ln334">}</a>
<a name="ln335"> </a>
<a name="ln336">// Change the value associated with a particular key in a map or hash_map</a>
<a name="ln337">// of the form map&lt;Key, Value*&gt; which owns the objects pointed to by the</a>
<a name="ln338">// value pointers.  If there was an existing value for the key, it is deleted.</a>
<a name="ln339">// True indicates an insert took place, false indicates an update + delete.</a>
<a name="ln340">template &lt;class Collection&gt;</a>
<a name="ln341">bool InsertAndDeleteExisting(</a>
<a name="ln342">    Collection* const collection,</a>
<a name="ln343">    const typename Collection::value_type::first_type&amp; key,</a>
<a name="ln344">    const typename Collection::value_type::second_type&amp; value) {</a>
<a name="ln345">  pair&lt;typename Collection::iterator, bool&gt; ret =</a>
<a name="ln346">      collection-&gt;insert(typename Collection::value_type(key, value));</a>
<a name="ln347">  if (!ret.second) {</a>
<a name="ln348">    delete ret.first-&gt;second;</a>
<a name="ln349">    ret.first-&gt;second = value;</a>
<a name="ln350">    return false;</a>
<a name="ln351">  }</a>
<a name="ln352">  return true;</a>
<a name="ln353">}</a>
<a name="ln354"> </a>
<a name="ln355">// Inserts the given key and value into the given collection iff the given key</a>
<a name="ln356">// did NOT already exist in the collection. If the key previously existed in the</a>
<a name="ln357">// collection, the value is not changed. Returns true if the key-value pair was</a>
<a name="ln358">// inserted; returns false if the key was already present.</a>
<a name="ln359">template &lt;class Collection&gt;</a>
<a name="ln360">bool InsertIfNotPresent(Collection* const collection,</a>
<a name="ln361">                        const typename Collection::value_type&amp; vt) {</a>
<a name="ln362">  return collection-&gt;insert(vt).second;</a>
<a name="ln363">}</a>
<a name="ln364"> </a>
<a name="ln365">// Same as above except the key and value are passed separately.</a>
<a name="ln366">template &lt;class Collection&gt;</a>
<a name="ln367">bool InsertIfNotPresent(</a>
<a name="ln368">    Collection* const collection,</a>
<a name="ln369">    const typename Collection::value_type::first_type&amp; key,</a>
<a name="ln370">    const typename Collection::value_type::second_type&amp; value) {</a>
<a name="ln371">  return InsertIfNotPresent(</a>
<a name="ln372">      collection, typename Collection::value_type(key, value));</a>
<a name="ln373">}</a>
<a name="ln374"> </a>
<a name="ln375">// Same as above except dies if the key already exists in the collection.</a>
<a name="ln376">template &lt;class Collection&gt;</a>
<a name="ln377">void InsertOrDie(Collection* const collection,</a>
<a name="ln378">                 const typename Collection::value_type&amp; value) {</a>
<a name="ln379">  CHECK(InsertIfNotPresent(collection, value)) &lt;&lt; &quot;duplicate value: &quot; &lt;&lt; value;</a>
<a name="ln380">}</a>
<a name="ln381"> </a>
<a name="ln382">// Same as above except doesn't log the value on error.</a>
<a name="ln383">template &lt;class Collection&gt;</a>
<a name="ln384">void InsertOrDieNoPrint(Collection* const collection,</a>
<a name="ln385">                        const typename Collection::value_type&amp; value) {</a>
<a name="ln386">  CHECK(InsertIfNotPresent(collection, value)) &lt;&lt; &quot;duplicate value.&quot;;</a>
<a name="ln387">}</a>
<a name="ln388"> </a>
<a name="ln389">// Inserts the key-value pair into the collection. Dies if key was already</a>
<a name="ln390">// present.</a>
<a name="ln391">template &lt;class Collection&gt;</a>
<a name="ln392">void InsertOrDie(Collection* const collection,</a>
<a name="ln393">                 const typename Collection::value_type::first_type&amp; key,</a>
<a name="ln394">                 const typename Collection::value_type::second_type&amp; data) {</a>
<a name="ln395">  CHECK(InsertIfNotPresent(collection, key, data))</a>
<a name="ln396">      &lt;&lt; &quot;duplicate key: &quot; &lt;&lt; key;</a>
<a name="ln397">}</a>
<a name="ln398"> </a>
<a name="ln399">// Same as above except deson't log the key on error.</a>
<a name="ln400">template &lt;class Collection&gt;</a>
<a name="ln401">void InsertOrDieNoPrint(</a>
<a name="ln402">    Collection* const collection,</a>
<a name="ln403">    const typename Collection::value_type::first_type&amp; key,</a>
<a name="ln404">    const typename Collection::value_type::second_type&amp; data) {</a>
<a name="ln405">  CHECK(InsertIfNotPresent(collection, key, data)) &lt;&lt; &quot;duplicate key.&quot;;</a>
<a name="ln406">}</a>
<a name="ln407"> </a>
<a name="ln408">// Inserts a new key and default-initialized value. Dies if the key was already</a>
<a name="ln409">// present. Returns a reference to the value. Example usage:</a>
<a name="ln410">//</a>
<a name="ln411">// map&lt;int, SomeProto&gt; m;</a>
<a name="ln412">// SomeProto&amp; proto = InsertKeyOrDie(&amp;m, 3);</a>
<a name="ln413">// proto.set_field(&quot;foo&quot;);</a>
<a name="ln414">template &lt;class Collection&gt;</a>
<a name="ln415">typename Collection::value_type::second_type&amp; InsertKeyOrDie(</a>
<a name="ln416">    Collection* const collection,</a>
<a name="ln417">    const typename Collection::value_type::first_type&amp; key) {</a>
<a name="ln418">  typedef typename Collection::value_type value_type;</a>
<a name="ln419">  pair&lt;typename Collection::iterator, bool&gt; res =</a>
<a name="ln420">      collection-&gt;insert(value_type(key, typename value_type::second_type()));</a>
<a name="ln421">  CHECK(res.second) &lt;&lt; &quot;duplicate key: &quot; &lt;&lt; key;</a>
<a name="ln422">  return res.first-&gt;second;</a>
<a name="ln423">}</a>
<a name="ln424"> </a>
<a name="ln425">//</a>
<a name="ln426">// Emplace*()</a>
<a name="ln427">//</a>
<a name="ln428">template &lt;class Collection, class... Args&gt;</a>
<a name="ln429">bool EmplaceIfNotPresent(Collection* const collection,</a>
<a name="ln430">                         Args&amp;&amp;... args) {</a>
<a name="ln431">  return collection-&gt;emplace(std::forward&lt;Args&gt;(args)...).second;</a>
<a name="ln432">}</a>
<a name="ln433"> </a>
<a name="ln434">template &lt;class Collection, class... Args&gt;</a>
<a name="ln435">void EmplaceOrDie(Collection* const collection,</a>
<a name="ln436">                  Args&amp;&amp;... args) {</a>
<a name="ln437">  CHECK(EmplaceIfNotPresent(collection, std::forward&lt;Args&gt;(args)...))</a>
<a name="ln438">      &lt;&lt; &quot;duplicate value&quot;;</a>
<a name="ln439">}</a>
<a name="ln440"> </a>
<a name="ln441">//</a>
<a name="ln442">// Lookup*()</a>
<a name="ln443">//</a>
<a name="ln444"> </a>
<a name="ln445">// Looks up a given key and value pair in a collection and inserts the key-value</a>
<a name="ln446">// pair if it's not already present. Returns a reference to the value associated</a>
<a name="ln447">// with the key.</a>
<a name="ln448">template &lt;class Collection&gt;</a>
<a name="ln449">typename Collection::value_type::second_type&amp;</a>
<a name="ln450">LookupOrInsert(Collection* const collection,</a>
<a name="ln451">               const typename Collection::value_type&amp; vt) {</a>
<a name="ln452">  return collection-&gt;insert(vt).first-&gt;second;</a>
<a name="ln453">}</a>
<a name="ln454"> </a>
<a name="ln455">// Same as above except the key-value are passed separately.</a>
<a name="ln456">template &lt;class Collection&gt;</a>
<a name="ln457">typename Collection::value_type::second_type&amp;</a>
<a name="ln458">LookupOrInsert(Collection* const collection,</a>
<a name="ln459">               const typename Collection::value_type::first_type&amp; key,</a>
<a name="ln460">               const typename Collection::value_type::second_type&amp; value) {</a>
<a name="ln461">  return LookupOrInsert(</a>
<a name="ln462">      collection, typename Collection::value_type(key, value));</a>
<a name="ln463">}</a>
<a name="ln464"> </a>
<a name="ln465">// Counts the number of equivalent elements in the given &quot;sequence&quot;, and stores</a>
<a name="ln466">// the results in &quot;count_map&quot; with element as the key and count as the value.</a>
<a name="ln467">//</a>
<a name="ln468">// Example:</a>
<a name="ln469">//   vector&lt;string&gt; v = {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;};</a>
<a name="ln470">//   map&lt;string, int&gt; m;</a>
<a name="ln471">//   AddTokenCounts(v, 1, &amp;m);</a>
<a name="ln472">//   assert(m[&quot;a&quot;] == 2);</a>
<a name="ln473">//   assert(m[&quot;b&quot;] == 2);</a>
<a name="ln474">//   assert(m[&quot;c&quot;] == 1);</a>
<a name="ln475">template &lt;typename Sequence, typename Collection&gt;</a>
<a name="ln476">void AddTokenCounts(</a>
<a name="ln477">    const Sequence&amp; sequence,</a>
<a name="ln478">    const typename Collection::value_type::second_type&amp; increment,</a>
<a name="ln479">    Collection* const count_map) {</a>
<a name="ln480">  for (typename Sequence::const_iterator it = sequence.begin();</a>
<a name="ln481">       it != sequence.end(); ++it) {</a>
<a name="ln482">    typename Collection::value_type::second_type&amp; value =</a>
<a name="ln483">        LookupOrInsert(count_map, *it,</a>
<a name="ln484">                       typename Collection::value_type::second_type());</a>
<a name="ln485">    value += increment;</a>
<a name="ln486">  }</a>
<a name="ln487">}</a>
<a name="ln488"> </a>
<a name="ln489">// Helpers for LookupOrInsertNew(), needed to create a new value type when the</a>
<a name="ln490">// type itself is a pointer, i.e., these extract the actual type from a pointer.</a>
<a name="ln491">template &lt;class T&gt;</a>
<a name="ln492">void MapUtilAssignNewDefaultInstance(T** location) {</a>
<a name="ln493">  *location = new T();</a>
<a name="ln494">}</a>
<a name="ln495"> </a>
<a name="ln496">template &lt;class T, class Arg&gt;</a>
<a name="ln497">void MapUtilAssignNewInstance(T** location, const Arg &amp;arg) {</a>
<a name="ln498">  *location = new T(arg);</a>
<a name="ln499">}</a>
<a name="ln500"> </a>
<a name="ln501">// Returns a reference to the value associated with key. If not found, a value</a>
<a name="ln502">// is default constructed on the heap and added to the map.</a>
<a name="ln503">//</a>
<a name="ln504">// This function is useful for containers of the form map&lt;Key, Value*&gt;, where</a>
<a name="ln505">// inserting a new key, value pair involves constructing a new heap-allocated</a>
<a name="ln506">// Value, and storing a pointer to that in the collection.</a>
<a name="ln507">template &lt;class Collection&gt;</a>
<a name="ln508">typename Collection::value_type::second_type&amp;</a>
<a name="ln509">LookupOrInsertNew(Collection* const collection,</a>
<a name="ln510">                  const typename Collection::value_type::first_type&amp; key) {</a>
<a name="ln511">  pair&lt;typename Collection::iterator, bool&gt; ret =</a>
<a name="ln512">      collection-&gt;insert(</a>
<a name="ln513">          typename Collection::value_type(key,</a>
<a name="ln514">              static_cast&lt;typename Collection::value_type::second_type&gt;(NULL)));</a>
<a name="ln515">  if (ret.second) {</a>
<a name="ln516">    // This helper is needed to 'extract' the Value type from the type of the</a>
<a name="ln517">    // container value, which is (Value*).</a>
<a name="ln518">    MapUtilAssignNewDefaultInstance(&amp;(ret.first-&gt;second));</a>
<a name="ln519">  }</a>
<a name="ln520">  return ret.first-&gt;second;</a>
<a name="ln521">}</a>
<a name="ln522"> </a>
<a name="ln523">// Same as above but constructs the value using the single-argument constructor</a>
<a name="ln524">// and the given &quot;arg&quot;.</a>
<a name="ln525">template &lt;class Collection, class Arg&gt;</a>
<a name="ln526">typename Collection::value_type::second_type&amp;</a>
<a name="ln527">LookupOrInsertNew(Collection* const collection,</a>
<a name="ln528">                  const typename Collection::value_type::first_type&amp; key,</a>
<a name="ln529">                  const Arg&amp; arg) {</a>
<a name="ln530">  pair&lt;typename Collection::iterator, bool&gt; ret =</a>
<a name="ln531">      collection-&gt;insert(</a>
<a name="ln532">          typename Collection::value_type(</a>
<a name="ln533">              key,</a>
<a name="ln534">              static_cast&lt;typename Collection::value_type::second_type&gt;(NULL)));</a>
<a name="ln535">  if (ret.second) {</a>
<a name="ln536">    // This helper is needed to 'extract' the Value type from the type of the</a>
<a name="ln537">    // container value, which is (Value*).</a>
<a name="ln538">    MapUtilAssignNewInstance(&amp;(ret.first-&gt;second), arg);</a>
<a name="ln539">  }</a>
<a name="ln540">  return ret.first-&gt;second;</a>
<a name="ln541">}</a>
<a name="ln542"> </a>
<a name="ln543">// Lookup of linked/shared pointers is used in two scenarios:</a>
<a name="ln544">//</a>
<a name="ln545">// Use LookupOrInsertSharedPtr if the container does not own the elements</a>
<a name="ln546">// for their whole lifetime. This is typically the case when a reader allows</a>
<a name="ln547">// parallel updates to the container. In this case a Mutex only needs to lock</a>
<a name="ln548">// container operations, but all element operations must be performed on the</a>
<a name="ln549">// shared pointer. Finding an element must be performed using FindPtr*() and</a>
<a name="ln550">// cannot be done with FindLinkedPtr*() even though it compiles.</a>
<a name="ln551"> </a>
<a name="ln552">// Lookup a key in a map or hash_map whose values are shared_ptrs.  If it is</a>
<a name="ln553">// missing, set collection[key].reset(new Value::element_type). Unlike</a>
<a name="ln554">// LookupOrInsertNewLinkedPtr, this function returns the shared_ptr instead of</a>
<a name="ln555">// the raw pointer. Value::element_type must be default constructable.</a>
<a name="ln556">template &lt;class Collection&gt;</a>
<a name="ln557">typename Collection::value_type::second_type&amp;</a>
<a name="ln558">LookupOrInsertNewSharedPtr(</a>
<a name="ln559">    Collection* const collection,</a>
<a name="ln560">    const typename Collection::value_type::first_type&amp; key) {</a>
<a name="ln561">  typedef typename Collection::value_type::second_type SharedPtr;</a>
<a name="ln562">  typedef typename Collection::value_type::second_type::element_type Element;</a>
<a name="ln563">  pair&lt;typename Collection::iterator, bool&gt; ret =</a>
<a name="ln564">      collection-&gt;insert(typename Collection::value_type(key, SharedPtr()));</a>
<a name="ln565">  if (ret.second) {</a>
<a name="ln566">    ret.first-&gt;second.reset(new Element());</a>
<a name="ln567">  }</a>
<a name="ln568">  return ret.first-&gt;second;</a>
<a name="ln569">}</a>
<a name="ln570"> </a>
<a name="ln571">// A variant of LookupOrInsertNewSharedPtr where the value is constructed using</a>
<a name="ln572">// a single-parameter constructor.  Note: the constructor argument is computed</a>
<a name="ln573">// even if it will not be used, so only values cheap to compute should be passed</a>
<a name="ln574">// here.  On the other hand it does not matter how expensive the construction of</a>
<a name="ln575">// the actual stored value is, as that only occurs if necessary.</a>
<a name="ln576">template &lt;class Collection, class Arg&gt;</a>
<a name="ln577">typename Collection::value_type::second_type&amp;</a>
<a name="ln578">LookupOrInsertNewSharedPtr(</a>
<a name="ln579">    Collection* const collection,</a>
<a name="ln580">    const typename Collection::value_type::first_type&amp; key,</a>
<a name="ln581">    const Arg&amp; arg) {</a>
<a name="ln582">  typedef typename Collection::value_type::second_type SharedPtr;</a>
<a name="ln583">  typedef typename Collection::value_type::second_type::element_type Element;</a>
<a name="ln584">  pair&lt;typename Collection::iterator, bool&gt; ret =</a>
<a name="ln585">      collection-&gt;insert(typename Collection::value_type(key, SharedPtr()));</a>
<a name="ln586">  if (ret.second) {</a>
<a name="ln587">    ret.first-&gt;second.reset(new Element(arg));</a>
<a name="ln588">  }</a>
<a name="ln589">  return ret.first-&gt;second;</a>
<a name="ln590">}</a>
<a name="ln591"> </a>
<a name="ln592">//</a>
<a name="ln593">// Misc Utility Functions</a>
<a name="ln594">//</a>
<a name="ln595"> </a>
<a name="ln596">// Updates the value associated with the given key. If the key was not already</a>
<a name="ln597">// present, then the key-value pair are inserted and &quot;previous&quot; is unchanged. If</a>
<a name="ln598">// the key was already present, the value is updated and &quot;*previous&quot; will</a>
<a name="ln599">// contain a copy of the old value.</a>
<a name="ln600">//</a>
<a name="ln601">// InsertOrReturnExisting has complementary behavior that returns the</a>
<a name="ln602">// address of an already existing value, rather than updating it.</a>
<a name="ln603">template &lt;class Collection&gt;</a>
<a name="ln604">bool UpdateReturnCopy(Collection* const collection,</a>
<a name="ln605">                      const typename Collection::value_type::first_type&amp; key,</a>
<a name="ln606">                      const typename Collection::value_type::second_type&amp; value,</a>
<a name="ln607">                      typename Collection::value_type::second_type* previous) {</a>
<a name="ln608">  pair&lt;typename Collection::iterator, bool&gt; ret =</a>
<a name="ln609">      collection-&gt;insert(typename Collection::value_type(key, value));</a>
<a name="ln610">  if (!ret.second) {</a>
<a name="ln611">    // update</a>
<a name="ln612">    if (previous) {</a>
<a name="ln613">      *previous = ret.first-&gt;second;</a>
<a name="ln614">    }</a>
<a name="ln615">    ret.first-&gt;second = value;</a>
<a name="ln616">    return true;</a>
<a name="ln617">  }</a>
<a name="ln618">  return false;</a>
<a name="ln619">}</a>
<a name="ln620"> </a>
<a name="ln621">// Same as above except that the key and value are passed as a pair.</a>
<a name="ln622">template &lt;class Collection&gt;</a>
<a name="ln623">bool UpdateReturnCopy(Collection* const collection,</a>
<a name="ln624">                      const typename Collection::value_type&amp; vt,</a>
<a name="ln625">                      typename Collection::value_type::second_type* previous) {</a>
<a name="ln626">  pair&lt;typename Collection::iterator, bool&gt; ret =</a>
<a name="ln627">    collection-&gt;insert(vt);</a>
<a name="ln628">  if (!ret.second) {</a>
<a name="ln629">    // update</a>
<a name="ln630">    if (previous) {</a>
<a name="ln631">      *previous = ret.first-&gt;second;</a>
<a name="ln632">    }</a>
<a name="ln633">    ret.first-&gt;second = vt.second;</a>
<a name="ln634">    return true;</a>
<a name="ln635">  }</a>
<a name="ln636">  return false;</a>
<a name="ln637">}</a>
<a name="ln638"> </a>
<a name="ln639">// Tries to insert the given key-value pair into the collection. Returns NULL if</a>
<a name="ln640">// the insert succeeds. Otherwise, returns a pointer to the existing value.</a>
<a name="ln641">//</a>
<a name="ln642">// This complements UpdateReturnCopy in that it allows to update only after</a>
<a name="ln643">// verifying the old value and still insert quickly without having to look up</a>
<a name="ln644">// twice. Unlike UpdateReturnCopy this also does not come with the issue of an</a>
<a name="ln645">// undefined previous* in case new data was inserted.</a>
<a name="ln646">template &lt;class Collection&gt;</a>
<a name="ln647">typename Collection::value_type::second_type*</a>
<a name="ln648">InsertOrReturnExisting(Collection* const collection,</a>
<a name="ln649">                       const typename Collection::value_type&amp; vt) {</a>
<a name="ln650">  pair&lt;typename Collection::iterator, bool&gt; ret = collection-&gt;insert(vt);</a>
<a name="ln651">  if (ret.second) {</a>
<a name="ln652">    return NULL;  // Inserted, no existing previous value.</a>
<a name="ln653">  } else {</a>
<a name="ln654">    return &amp;ret.first-&gt;second;  // Return address of already existing value.</a>
<a name="ln655">  }</a>
<a name="ln656">}</a>
<a name="ln657"> </a>
<a name="ln658">// Same as above, except for explicit key and data.</a>
<a name="ln659">template &lt;class Collection&gt;</a>
<a name="ln660">typename Collection::value_type::second_type*</a>
<a name="ln661">InsertOrReturnExisting(</a>
<a name="ln662">    Collection* const collection,</a>
<a name="ln663">    const typename Collection::value_type::first_type&amp; key,</a>
<a name="ln664">    const typename Collection::value_type::second_type&amp; data) {</a>
<a name="ln665">  return InsertOrReturnExisting(collection,</a>
<a name="ln666">                                typename Collection::value_type(key, data));</a>
<a name="ln667">}</a>
<a name="ln668"> </a>
<a name="ln669">// Saves the reverse mapping into reverse. Key/value pairs are inserted in the</a>
<a name="ln670">// order the iterator returns them.</a>
<a name="ln671">template &lt;class Collection, class ReverseCollection&gt;</a>
<a name="ln672">void ReverseMap(const Collection&amp; collection,</a>
<a name="ln673">                ReverseCollection* const reverse) {</a>
<a name="ln674">  CHECK(reverse != NULL);</a>
<a name="ln675">  for (typename Collection::const_iterator it = collection.begin();</a>
<a name="ln676">       it != collection.end();</a>
<a name="ln677">       ++it) {</a>
<a name="ln678">    InsertOrUpdate(reverse, it-&gt;second, it-&gt;first);</a>
<a name="ln679">  }</a>
<a name="ln680">}</a>
<a name="ln681"> </a>
<a name="ln682">// Erases the collection item identified by the given key, and returns the value</a>
<a name="ln683">// associated with that key. It is assumed that the value (i.e., the</a>
<a name="ln684">// mapped_type) is a pointer. Returns NULL if the key was not found in the</a>
<a name="ln685">// collection.</a>
<a name="ln686">//</a>
<a name="ln687">// Examples:</a>
<a name="ln688">//   map&lt;string, MyType*&gt; my_map;</a>
<a name="ln689">//</a>
<a name="ln690">// One line cleanup:</a>
<a name="ln691">//     delete EraseKeyReturnValuePtr(&amp;my_map, &quot;abc&quot;);</a>
<a name="ln692">//</a>
<a name="ln693">// Use returned value:</a>
<a name="ln694">//     gscoped_ptr&lt;MyType&gt; value_ptr(EraseKeyReturnValuePtr(&amp;my_map, &quot;abc&quot;));</a>
<a name="ln695">//     if (value_ptr.get())</a>
<a name="ln696">//       value_ptr-&gt;DoSomething();</a>
<a name="ln697">//</a>
<a name="ln698">template &lt;class Collection&gt;</a>
<a name="ln699">typename Collection::value_type::second_type EraseKeyReturnValuePtr(</a>
<a name="ln700">    Collection* const collection,</a>
<a name="ln701">    const typename Collection::value_type::first_type&amp; key) {</a>
<a name="ln702">  auto it = collection-&gt;find(key);</a>
<a name="ln703">  if (it == collection-&gt;end()) {</a>
<a name="ln704">    return NULL;</a>
<a name="ln705">  }</a>
<a name="ln706">  typename Collection::value_type::second_type v = it-&gt;second;</a>
<a name="ln707">  collection-&gt;erase(it);</a>
<a name="ln708">  return v;</a>
<a name="ln709">}</a>
<a name="ln710"> </a>
<a name="ln711">// Inserts all the keys from map_container into key_container, which must</a>
<a name="ln712">// support insert(MapContainer::key_type).</a>
<a name="ln713">//</a>
<a name="ln714">// Note: any initial contents of the key_container are not cleared.</a>
<a name="ln715">template &lt;class MapContainer, class KeyContainer&gt;</a>
<a name="ln716">void InsertKeysFromMap(const MapContainer&amp; map_container,</a>
<a name="ln717">                       KeyContainer* key_container) {</a>
<a name="ln718">  CHECK(key_container != NULL);</a>
<a name="ln719">  for (typename MapContainer::const_iterator it = map_container.begin();</a>
<a name="ln720">       it != map_container.end(); ++it) {</a>
<a name="ln721">    key_container-&gt;insert(it-&gt;first);</a>
<a name="ln722">  }</a>
<a name="ln723">}</a>
<a name="ln724"> </a>
<a name="ln725">// Appends all the keys from map_container into key_container, which must</a>
<a name="ln726">// support push_back(MapContainer::key_type).</a>
<a name="ln727">//</a>
<a name="ln728">// Note: any initial contents of the key_container are not cleared.</a>
<a name="ln729">template &lt;class MapContainer, class KeyContainer&gt;</a>
<a name="ln730">void AppendKeysFromMap(const MapContainer&amp; map_container,</a>
<a name="ln731">                       KeyContainer* key_container) {</a>
<a name="ln732">  CHECK(key_container != NULL);</a>
<a name="ln733">  for (typename MapContainer::const_iterator it = map_container.begin();</a>
<a name="ln734">       it != map_container.end(); ++it) {</a>
<a name="ln735">    key_container-&gt;push_back(it-&gt;first);</a>
<a name="ln736">  }</a>
<a name="ln737">}</a>
<a name="ln738"> </a>
<a name="ln739">// A more specialized overload of AppendKeysFromMap to optimize reallocations</a>
<a name="ln740">// for the common case in which we're appending keys to a vector and hence can</a>
<a name="ln741">// (and sometimes should) call reserve() first.</a>
<a name="ln742">//</a>
<a name="ln743">// (It would be possible to play SFINAE games to call reserve() for any</a>
<a name="ln744">// container that supports it, but this seems to get us 99% of what we need</a>
<a name="ln745">// without the complexity of a SFINAE-based solution.)</a>
<a name="ln746">template &lt;class MapContainer, class KeyType&gt;</a>
<a name="ln747">void AppendKeysFromMap(const MapContainer&amp; map_container,</a>
<a name="ln748">                       vector&lt;KeyType&gt;* key_container) {</a>
<a name="ln749">  CHECK(key_container != NULL);</a>
<a name="ln750">  // We now have the opportunity to call reserve(). Calling reserve() every</a>
<a name="ln751">  // time is a bad idea for some use cases: libstdc++'s implementation of</a>
<a name="ln752">  // vector&lt;&gt;::reserve() resizes the vector's backing store to exactly the</a>
<a name="ln753">  // given size (unless it's already at least that big). Because of this,</a>
<a name="ln754">  // the use case that involves appending a lot of small maps (total size</a>
<a name="ln755">  // N) one by one to a vector would be O(N^2). But never calling reserve()</a>
<a name="ln756">  // loses the opportunity to improve the use case of adding from a large</a>
<a name="ln757">  // map to an empty vector (this improves performance by up to 33%). A</a>
<a name="ln758">  // number of heuristics are possible; see the discussion in</a>
<a name="ln759">  // cl/34081696. Here we use the simplest one.</a>
<a name="ln760">  if (key_container-&gt;empty()) {</a>
<a name="ln761">    key_container-&gt;reserve(map_container.size());</a>
<a name="ln762">  }</a>
<a name="ln763">  for (typename MapContainer::const_iterator it = map_container.begin();</a>
<a name="ln764">       it != map_container.end(); ++it) {</a>
<a name="ln765">    key_container-&gt;push_back(it-&gt;first);</a>
<a name="ln766">  }</a>
<a name="ln767">}</a>
<a name="ln768"> </a>
<a name="ln769">// Inserts all the values from map_container into value_container, which must</a>
<a name="ln770">// support push_back(MapContainer::mapped_type).</a>
<a name="ln771">//</a>
<a name="ln772">// Note: any initial contents of the value_container are not cleared.</a>
<a name="ln773">template &lt;class MapContainer, class ValueContainer&gt;</a>
<a name="ln774">void AppendValuesFromMap(const MapContainer&amp; map_container,</a>
<a name="ln775">                         ValueContainer* value_container) {</a>
<a name="ln776">  CHECK(value_container != NULL);</a>
<a name="ln777">  for (typename MapContainer::const_iterator it = map_container.begin();</a>
<a name="ln778">       it != map_container.end(); ++it) {</a>
<a name="ln779">    value_container-&gt;push_back(it-&gt;second);</a>
<a name="ln780">  }</a>
<a name="ln781">}</a>
<a name="ln782"> </a>
<a name="ln783">// A more specialized overload of AppendValuesFromMap to optimize reallocations</a>
<a name="ln784">// for the common case in which we're appending values to a vector and hence</a>
<a name="ln785">// can (and sometimes should) call reserve() first.</a>
<a name="ln786">//</a>
<a name="ln787">// (It would be possible to play SFINAE games to call reserve() for any</a>
<a name="ln788">// container that supports it, but this seems to get us 99% of what we need</a>
<a name="ln789">// without the complexity of a SFINAE-based solution.)</a>
<a name="ln790">template &lt;class MapContainer, class ValueType&gt;</a>
<a name="ln791">void AppendValuesFromMap(const MapContainer&amp; map_container,</a>
<a name="ln792">                         vector&lt;ValueType&gt;* value_container) {</a>
<a name="ln793">  CHECK(value_container != NULL);</a>
<a name="ln794">  // See AppendKeysFromMap for why this is done.</a>
<a name="ln795">  if (value_container-&gt;empty()) {</a>
<a name="ln796">    value_container-&gt;reserve(map_container.size());</a>
<a name="ln797">  }</a>
<a name="ln798">  for (const auto&amp; entry : map_container) {</a>
<a name="ln799">    value_container-&gt;push_back(entry.second);</a>
<a name="ln800">  }</a>
<a name="ln801">}</a>
<a name="ln802"> </a>
<a name="ln803">#endif  // YB_GUTIL_MAP_UTIL_H</a>

</code></pre>
<div class="balloon" rel="119"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="129"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="139"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="149"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="379"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="386"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="395"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="405"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="421"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="437"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="674"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="718"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="732"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="749"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="760"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1004/" target="_blank">V1004</a> The 'key_container' pointer was used unsafely after it was verified against nullptr. Check lines: 749, 760.</p></div>
<div class="balloon" rel="776"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="793"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="795"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1004/" target="_blank">V1004</a> The 'value_container' pointer was used unsafely after it was verified against nullptr. Check lines: 793, 795.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
