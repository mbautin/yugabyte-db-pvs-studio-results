
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>complex</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// The template and inlines for the -*- C++ -*- complex number classes.</a>
<a name="ln2"> </a>
<a name="ln3">// Copyright (C) 1997-2018 Free Software Foundation, Inc.</a>
<a name="ln4">//</a>
<a name="ln5">// This file is part of the GNU ISO C++ Library.  This library is free</a>
<a name="ln6">// software; you can redistribute it and/or modify it under the</a>
<a name="ln7">// terms of the GNU General Public License as published by the</a>
<a name="ln8">// Free Software Foundation; either version 3, or (at your option)</a>
<a name="ln9">// any later version.</a>
<a name="ln10"> </a>
<a name="ln11">// This library is distributed in the hope that it will be useful,</a>
<a name="ln12">// but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">// GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">// Under Section 7 of GPL version 3, you are granted additional</a>
<a name="ln17">// permissions described in the GCC Runtime Library Exception, version</a>
<a name="ln18">// 3.1, as published by the Free Software Foundation.</a>
<a name="ln19"> </a>
<a name="ln20">// You should have received a copy of the GNU General Public License and</a>
<a name="ln21">// a copy of the GCC Runtime Library Exception along with this program;</a>
<a name="ln22">// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see</a>
<a name="ln23">// &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln24"> </a>
<a name="ln25">/** @file include/complex</a>
<a name="ln26"> *  This is a Standard C++ Library header.</a>
<a name="ln27"> */</a>
<a name="ln28"> </a>
<a name="ln29">//</a>
<a name="ln30">// ISO C++ 14882: 26.2  Complex Numbers</a>
<a name="ln31">// Note: this is not a conforming implementation.</a>
<a name="ln32">// Initially implemented by Ulrich Drepper &lt;drepper@cygnus.com&gt;</a>
<a name="ln33">// Improved by Gabriel Dos Reis &lt;dosreis@cmla.ens-cachan.fr&gt;</a>
<a name="ln34">//</a>
<a name="ln35"> </a>
<a name="ln36">#ifndef _GLIBCXX_COMPLEX</a>
<a name="ln37">#define _GLIBCXX_COMPLEX 1</a>
<a name="ln38"> </a>
<a name="ln39">#pragma GCC system_header</a>
<a name="ln40"> </a>
<a name="ln41">#include &lt;bits/c++config.h&gt;</a>
<a name="ln42">#include &lt;bits/cpp_type_traits.h&gt;</a>
<a name="ln43">#include &lt;ext/type_traits.h&gt;</a>
<a name="ln44">#include &lt;cmath&gt;</a>
<a name="ln45">#include &lt;sstream&gt;</a>
<a name="ln46"> </a>
<a name="ln47">// Get rid of a macro possibly defined in &lt;complex.h&gt;</a>
<a name="ln48">#undef complex</a>
<a name="ln49"> </a>
<a name="ln50">namespace std _GLIBCXX_VISIBILITY(default)</a>
<a name="ln51">{</a>
<a name="ln52">_GLIBCXX_BEGIN_NAMESPACE_VERSION</a>
<a name="ln53"> </a>
<a name="ln54">  /**</a>
<a name="ln55">   * @defgroup complex_numbers Complex Numbers</a>
<a name="ln56">   * @ingroup numerics</a>
<a name="ln57">   *</a>
<a name="ln58">   * Classes and functions for complex numbers.</a>
<a name="ln59">   * @{</a>
<a name="ln60">   */</a>
<a name="ln61"> </a>
<a name="ln62">  // Forward declarations.</a>
<a name="ln63">  template&lt;typename _Tp&gt; class complex;</a>
<a name="ln64">  template&lt;&gt; class complex&lt;float&gt;;</a>
<a name="ln65">  template&lt;&gt; class complex&lt;double&gt;;</a>
<a name="ln66">  template&lt;&gt; class complex&lt;long double&gt;;</a>
<a name="ln67"> </a>
<a name="ln68">  ///  Return magnitude of @a z.</a>
<a name="ln69">  template&lt;typename _Tp&gt; _Tp abs(const complex&lt;_Tp&gt;&amp;);</a>
<a name="ln70">  ///  Return phase angle of @a z.</a>
<a name="ln71">  template&lt;typename _Tp&gt; _Tp arg(const complex&lt;_Tp&gt;&amp;);</a>
<a name="ln72">  ///  Return @a z magnitude squared.</a>
<a name="ln73">  template&lt;typename _Tp&gt; _Tp norm(const complex&lt;_Tp&gt;&amp;);</a>
<a name="ln74"> </a>
<a name="ln75">  ///  Return complex conjugate of @a z.</a>
<a name="ln76">  template&lt;typename _Tp&gt; complex&lt;_Tp&gt; conj(const complex&lt;_Tp&gt;&amp;);</a>
<a name="ln77">  ///  Return complex with magnitude @a rho and angle @a theta.</a>
<a name="ln78">  template&lt;typename _Tp&gt; complex&lt;_Tp&gt; polar(const _Tp&amp;, const _Tp&amp; = 0);</a>
<a name="ln79"> </a>
<a name="ln80">  // Transcendentals:</a>
<a name="ln81">  /// Return complex cosine of @a z.</a>
<a name="ln82">  template&lt;typename _Tp&gt; complex&lt;_Tp&gt; cos(const complex&lt;_Tp&gt;&amp;);</a>
<a name="ln83">  /// Return complex hyperbolic cosine of @a z.</a>
<a name="ln84">  template&lt;typename _Tp&gt; complex&lt;_Tp&gt; cosh(const complex&lt;_Tp&gt;&amp;);</a>
<a name="ln85">  /// Return complex base e exponential of @a z.</a>
<a name="ln86">  template&lt;typename _Tp&gt; complex&lt;_Tp&gt; exp(const complex&lt;_Tp&gt;&amp;);</a>
<a name="ln87">  /// Return complex natural logarithm of @a z.</a>
<a name="ln88">  template&lt;typename _Tp&gt; complex&lt;_Tp&gt; log(const complex&lt;_Tp&gt;&amp;);</a>
<a name="ln89">  /// Return complex base 10 logarithm of @a z.</a>
<a name="ln90">  template&lt;typename _Tp&gt; complex&lt;_Tp&gt; log10(const complex&lt;_Tp&gt;&amp;);</a>
<a name="ln91">  /// Return @a x to the @a y'th power.</a>
<a name="ln92">  template&lt;typename _Tp&gt; complex&lt;_Tp&gt; pow(const complex&lt;_Tp&gt;&amp;, int);</a>
<a name="ln93">  /// Return @a x to the @a y'th power.</a>
<a name="ln94">  template&lt;typename _Tp&gt; complex&lt;_Tp&gt; pow(const complex&lt;_Tp&gt;&amp;, const _Tp&amp;);</a>
<a name="ln95">  /// Return @a x to the @a y'th power.</a>
<a name="ln96">  template&lt;typename _Tp&gt; complex&lt;_Tp&gt; pow(const complex&lt;_Tp&gt;&amp;,</a>
<a name="ln97">                                          const complex&lt;_Tp&gt;&amp;);</a>
<a name="ln98">  /// Return @a x to the @a y'th power.</a>
<a name="ln99">  template&lt;typename _Tp&gt; complex&lt;_Tp&gt; pow(const _Tp&amp;, const complex&lt;_Tp&gt;&amp;);</a>
<a name="ln100">  /// Return complex sine of @a z.</a>
<a name="ln101">  template&lt;typename _Tp&gt; complex&lt;_Tp&gt; sin(const complex&lt;_Tp&gt;&amp;);</a>
<a name="ln102">  /// Return complex hyperbolic sine of @a z.</a>
<a name="ln103">  template&lt;typename _Tp&gt; complex&lt;_Tp&gt; sinh(const complex&lt;_Tp&gt;&amp;);</a>
<a name="ln104">  /// Return complex square root of @a z.</a>
<a name="ln105">  template&lt;typename _Tp&gt; complex&lt;_Tp&gt; sqrt(const complex&lt;_Tp&gt;&amp;);</a>
<a name="ln106">  /// Return complex tangent of @a z.</a>
<a name="ln107">  template&lt;typename _Tp&gt; complex&lt;_Tp&gt; tan(const complex&lt;_Tp&gt;&amp;);</a>
<a name="ln108">  /// Return complex hyperbolic tangent of @a z.</a>
<a name="ln109">  template&lt;typename _Tp&gt; complex&lt;_Tp&gt; tanh(const complex&lt;_Tp&gt;&amp;);</a>
<a name="ln110"> </a>
<a name="ln111"> </a>
<a name="ln112">  // 26.2.2  Primary template class complex</a>
<a name="ln113">  /**</a>
<a name="ln114">   *  Template to represent complex numbers.</a>
<a name="ln115">   *</a>
<a name="ln116">   *  Specializations for float, double, and long double are part of the</a>
<a name="ln117">   *  library.  Results with any other type are not guaranteed.</a>
<a name="ln118">   *</a>
<a name="ln119">   *  @param  Tp  Type of real and imaginary values.</a>
<a name="ln120">  */</a>
<a name="ln121">  template&lt;typename _Tp&gt;</a>
<a name="ln122">    struct complex</a>
<a name="ln123">    {</a>
<a name="ln124">      /// Value typedef.</a>
<a name="ln125">      typedef _Tp value_type;</a>
<a name="ln126"> </a>
<a name="ln127">      ///  Default constructor.  First parameter is x, second parameter is y.</a>
<a name="ln128">      ///  Unspecified parameters default to 0.</a>
<a name="ln129">      _GLIBCXX_CONSTEXPR complex(const _Tp&amp; __r = _Tp(), const _Tp&amp; __i = _Tp())</a>
<a name="ln130">      : _M_real(__r), _M_imag(__i) { }</a>
<a name="ln131"> </a>
<a name="ln132">      // Let the compiler synthesize the copy constructor</a>
<a name="ln133">#if __cplusplus &gt;= 201103L</a>
<a name="ln134">      constexpr complex(const complex&amp;) = default;</a>
<a name="ln135">#endif</a>
<a name="ln136"> </a>
<a name="ln137">      ///  Converting constructor.</a>
<a name="ln138">      template&lt;typename _Up&gt;</a>
<a name="ln139">        _GLIBCXX_CONSTEXPR complex(const complex&lt;_Up&gt;&amp; __z)</a>
<a name="ln140">	: _M_real(__z.real()), _M_imag(__z.imag()) { }</a>
<a name="ln141"> </a>
<a name="ln142">#if __cplusplus &gt;= 201103L</a>
<a name="ln143">      // _GLIBCXX_RESOLVE_LIB_DEFECTS</a>
<a name="ln144">      // DR 387. std::complex over-encapsulated.</a>
<a name="ln145">      _GLIBCXX_ABI_TAG_CXX11</a>
<a name="ln146">      constexpr _Tp</a>
<a name="ln147">      real() const { return _M_real; }</a>
<a name="ln148"> </a>
<a name="ln149">      _GLIBCXX_ABI_TAG_CXX11</a>
<a name="ln150">      constexpr _Tp</a>
<a name="ln151">      imag() const { return _M_imag; }</a>
<a name="ln152">#else</a>
<a name="ln153">      ///  Return real part of complex number.</a>
<a name="ln154">      _Tp&amp;</a>
<a name="ln155">      real() { return _M_real; }</a>
<a name="ln156"> </a>
<a name="ln157">      ///  Return real part of complex number.</a>
<a name="ln158">      const _Tp&amp;</a>
<a name="ln159">      real() const { return _M_real; }</a>
<a name="ln160"> </a>
<a name="ln161">      ///  Return imaginary part of complex number.</a>
<a name="ln162">      _Tp&amp;</a>
<a name="ln163">      imag() { return _M_imag; }</a>
<a name="ln164"> </a>
<a name="ln165">      ///  Return imaginary part of complex number.</a>
<a name="ln166">      const _Tp&amp;</a>
<a name="ln167">      imag() const { return _M_imag; }</a>
<a name="ln168">#endif</a>
<a name="ln169"> </a>
<a name="ln170">      // _GLIBCXX_RESOLVE_LIB_DEFECTS</a>
<a name="ln171">      // DR 387. std::complex over-encapsulated.</a>
<a name="ln172">      void</a>
<a name="ln173">      real(_Tp __val) { _M_real = __val; }</a>
<a name="ln174"> </a>
<a name="ln175">      void</a>
<a name="ln176">      imag(_Tp __val) { _M_imag = __val; }</a>
<a name="ln177"> </a>
<a name="ln178">      /// Assign a scalar to this complex number.</a>
<a name="ln179">      complex&lt;_Tp&gt;&amp; operator=(const _Tp&amp;);</a>
<a name="ln180"> </a>
<a name="ln181">      /// Add a scalar to this complex number.</a>
<a name="ln182">      // 26.2.5/1</a>
<a name="ln183">      complex&lt;_Tp&gt;&amp;</a>
<a name="ln184">      operator+=(const _Tp&amp; __t)</a>
<a name="ln185">      {</a>
<a name="ln186">	_M_real += __t;</a>
<a name="ln187">	return *this;</a>
<a name="ln188">      }</a>
<a name="ln189"> </a>
<a name="ln190">      /// Subtract a scalar from this complex number.</a>
<a name="ln191">      // 26.2.5/3</a>
<a name="ln192">      complex&lt;_Tp&gt;&amp;</a>
<a name="ln193">      operator-=(const _Tp&amp; __t)</a>
<a name="ln194">      {</a>
<a name="ln195">	_M_real -= __t;</a>
<a name="ln196">	return *this;</a>
<a name="ln197">      }</a>
<a name="ln198"> </a>
<a name="ln199">      /// Multiply this complex number by a scalar.</a>
<a name="ln200">      complex&lt;_Tp&gt;&amp; operator*=(const _Tp&amp;);</a>
<a name="ln201">      /// Divide this complex number by a scalar.</a>
<a name="ln202">      complex&lt;_Tp&gt;&amp; operator/=(const _Tp&amp;);</a>
<a name="ln203"> </a>
<a name="ln204">      // Let the compiler synthesize the copy assignment operator</a>
<a name="ln205">#if __cplusplus &gt;= 201103L</a>
<a name="ln206">      complex&amp; operator=(const complex&amp;) = default;</a>
<a name="ln207">#endif</a>
<a name="ln208"> </a>
<a name="ln209">      /// Assign another complex number to this one.</a>
<a name="ln210">      template&lt;typename _Up&gt;</a>
<a name="ln211">        complex&lt;_Tp&gt;&amp; operator=(const complex&lt;_Up&gt;&amp;);</a>
<a name="ln212">      /// Add another complex number to this one.</a>
<a name="ln213">      template&lt;typename _Up&gt;</a>
<a name="ln214">        complex&lt;_Tp&gt;&amp; operator+=(const complex&lt;_Up&gt;&amp;);</a>
<a name="ln215">      /// Subtract another complex number from this one.</a>
<a name="ln216">      template&lt;typename _Up&gt;</a>
<a name="ln217">        complex&lt;_Tp&gt;&amp; operator-=(const complex&lt;_Up&gt;&amp;);</a>
<a name="ln218">      /// Multiply this complex number by another.</a>
<a name="ln219">      template&lt;typename _Up&gt;</a>
<a name="ln220">        complex&lt;_Tp&gt;&amp; operator*=(const complex&lt;_Up&gt;&amp;);</a>
<a name="ln221">      /// Divide this complex number by another.</a>
<a name="ln222">      template&lt;typename _Up&gt;</a>
<a name="ln223">        complex&lt;_Tp&gt;&amp; operator/=(const complex&lt;_Up&gt;&amp;);</a>
<a name="ln224"> </a>
<a name="ln225">      _GLIBCXX_CONSTEXPR complex __rep() const</a>
<a name="ln226">      { return *this; }</a>
<a name="ln227"> </a>
<a name="ln228">    private:</a>
<a name="ln229">      _Tp _M_real;</a>
<a name="ln230">      _Tp _M_imag;</a>
<a name="ln231">    };</a>
<a name="ln232"> </a>
<a name="ln233">  template&lt;typename _Tp&gt;</a>
<a name="ln234">    complex&lt;_Tp&gt;&amp;</a>
<a name="ln235">    complex&lt;_Tp&gt;::operator=(const _Tp&amp; __t)</a>
<a name="ln236">    {</a>
<a name="ln237">     _M_real = __t;</a>
<a name="ln238">     _M_imag = _Tp();</a>
<a name="ln239">     return *this;</a>
<a name="ln240">    }</a>
<a name="ln241"> </a>
<a name="ln242">  // 26.2.5/5</a>
<a name="ln243">  template&lt;typename _Tp&gt;</a>
<a name="ln244">    complex&lt;_Tp&gt;&amp;</a>
<a name="ln245">    complex&lt;_Tp&gt;::operator*=(const _Tp&amp; __t)</a>
<a name="ln246">    {</a>
<a name="ln247">      _M_real *= __t;</a>
<a name="ln248">      _M_imag *= __t;</a>
<a name="ln249">      return *this;</a>
<a name="ln250">    }</a>
<a name="ln251"> </a>
<a name="ln252">  // 26.2.5/7</a>
<a name="ln253">  template&lt;typename _Tp&gt;</a>
<a name="ln254">    complex&lt;_Tp&gt;&amp;</a>
<a name="ln255">    complex&lt;_Tp&gt;::operator/=(const _Tp&amp; __t)</a>
<a name="ln256">    {</a>
<a name="ln257">      _M_real /= __t;</a>
<a name="ln258">      _M_imag /= __t;</a>
<a name="ln259">      return *this;</a>
<a name="ln260">    }</a>
<a name="ln261"> </a>
<a name="ln262">  template&lt;typename _Tp&gt;</a>
<a name="ln263">    template&lt;typename _Up&gt;</a>
<a name="ln264">    complex&lt;_Tp&gt;&amp;</a>
<a name="ln265">    complex&lt;_Tp&gt;::operator=(const complex&lt;_Up&gt;&amp; __z)</a>
<a name="ln266">    {</a>
<a name="ln267">      _M_real = __z.real();</a>
<a name="ln268">      _M_imag = __z.imag();</a>
<a name="ln269">      return *this;</a>
<a name="ln270">    }</a>
<a name="ln271"> </a>
<a name="ln272">  // 26.2.5/9</a>
<a name="ln273">  template&lt;typename _Tp&gt;</a>
<a name="ln274">    template&lt;typename _Up&gt;</a>
<a name="ln275">    complex&lt;_Tp&gt;&amp;</a>
<a name="ln276">    complex&lt;_Tp&gt;::operator+=(const complex&lt;_Up&gt;&amp; __z)</a>
<a name="ln277">    {</a>
<a name="ln278">      _M_real += __z.real();</a>
<a name="ln279">      _M_imag += __z.imag();</a>
<a name="ln280">      return *this;</a>
<a name="ln281">    }</a>
<a name="ln282"> </a>
<a name="ln283">  // 26.2.5/11</a>
<a name="ln284">  template&lt;typename _Tp&gt;</a>
<a name="ln285">    template&lt;typename _Up&gt;</a>
<a name="ln286">    complex&lt;_Tp&gt;&amp;</a>
<a name="ln287">    complex&lt;_Tp&gt;::operator-=(const complex&lt;_Up&gt;&amp; __z)</a>
<a name="ln288">    {</a>
<a name="ln289">      _M_real -= __z.real();</a>
<a name="ln290">      _M_imag -= __z.imag();</a>
<a name="ln291">      return *this;</a>
<a name="ln292">    }</a>
<a name="ln293"> </a>
<a name="ln294">  // 26.2.5/13</a>
<a name="ln295">  // XXX: This is a grammar school implementation.</a>
<a name="ln296">  template&lt;typename _Tp&gt;</a>
<a name="ln297">    template&lt;typename _Up&gt;</a>
<a name="ln298">    complex&lt;_Tp&gt;&amp;</a>
<a name="ln299">    complex&lt;_Tp&gt;::operator*=(const complex&lt;_Up&gt;&amp; __z)</a>
<a name="ln300">    {</a>
<a name="ln301">      const _Tp __r = _M_real * __z.real() - _M_imag * __z.imag();</a>
<a name="ln302">      _M_imag = _M_real * __z.imag() + _M_imag * __z.real();</a>
<a name="ln303">      _M_real = __r;</a>
<a name="ln304">      return *this;</a>
<a name="ln305">    }</a>
<a name="ln306"> </a>
<a name="ln307">  // 26.2.5/15</a>
<a name="ln308">  // XXX: This is a grammar school implementation.</a>
<a name="ln309">  template&lt;typename _Tp&gt;</a>
<a name="ln310">    template&lt;typename _Up&gt;</a>
<a name="ln311">    complex&lt;_Tp&gt;&amp;</a>
<a name="ln312">    complex&lt;_Tp&gt;::operator/=(const complex&lt;_Up&gt;&amp; __z)</a>
<a name="ln313">    {</a>
<a name="ln314">      const _Tp __r =  _M_real * __z.real() + _M_imag * __z.imag();</a>
<a name="ln315">      const _Tp __n = std::norm(__z);</a>
<a name="ln316">      _M_imag = (_M_imag * __z.real() - _M_real * __z.imag()) / __n;</a>
<a name="ln317">      _M_real = __r / __n;</a>
<a name="ln318">      return *this;</a>
<a name="ln319">    }</a>
<a name="ln320"> </a>
<a name="ln321">  // Operators:</a>
<a name="ln322">  //@{</a>
<a name="ln323">  ///  Return new complex value @a x plus @a y.</a>
<a name="ln324">  template&lt;typename _Tp&gt;</a>
<a name="ln325">    inline complex&lt;_Tp&gt;</a>
<a name="ln326">    operator+(const complex&lt;_Tp&gt;&amp; __x, const complex&lt;_Tp&gt;&amp; __y)</a>
<a name="ln327">    {</a>
<a name="ln328">      complex&lt;_Tp&gt; __r = __x;</a>
<a name="ln329">      __r += __y;</a>
<a name="ln330">      return __r;</a>
<a name="ln331">    }</a>
<a name="ln332"> </a>
<a name="ln333">  template&lt;typename _Tp&gt;</a>
<a name="ln334">    inline complex&lt;_Tp&gt;</a>
<a name="ln335">    operator+(const complex&lt;_Tp&gt;&amp; __x, const _Tp&amp; __y)</a>
<a name="ln336">    {</a>
<a name="ln337">      complex&lt;_Tp&gt; __r = __x;</a>
<a name="ln338">      __r += __y;</a>
<a name="ln339">      return __r;</a>
<a name="ln340">    }</a>
<a name="ln341"> </a>
<a name="ln342">  template&lt;typename _Tp&gt;</a>
<a name="ln343">    inline complex&lt;_Tp&gt;</a>
<a name="ln344">    operator+(const _Tp&amp; __x, const complex&lt;_Tp&gt;&amp; __y)</a>
<a name="ln345">    {</a>
<a name="ln346">      complex&lt;_Tp&gt; __r = __y;</a>
<a name="ln347">      __r += __x;</a>
<a name="ln348">      return __r;</a>
<a name="ln349">    }</a>
<a name="ln350">  //@}</a>
<a name="ln351"> </a>
<a name="ln352">  //@{</a>
<a name="ln353">  ///  Return new complex value @a x minus @a y.</a>
<a name="ln354">  template&lt;typename _Tp&gt;</a>
<a name="ln355">    inline complex&lt;_Tp&gt;</a>
<a name="ln356">    operator-(const complex&lt;_Tp&gt;&amp; __x, const complex&lt;_Tp&gt;&amp; __y)</a>
<a name="ln357">    {</a>
<a name="ln358">      complex&lt;_Tp&gt; __r = __x;</a>
<a name="ln359">      __r -= __y;</a>
<a name="ln360">      return __r;</a>
<a name="ln361">    }</a>
<a name="ln362"> </a>
<a name="ln363">  template&lt;typename _Tp&gt;</a>
<a name="ln364">    inline complex&lt;_Tp&gt;</a>
<a name="ln365">    operator-(const complex&lt;_Tp&gt;&amp; __x, const _Tp&amp; __y)</a>
<a name="ln366">    {</a>
<a name="ln367">      complex&lt;_Tp&gt; __r = __x;</a>
<a name="ln368">      __r -= __y;</a>
<a name="ln369">      return __r;</a>
<a name="ln370">    }</a>
<a name="ln371"> </a>
<a name="ln372">  template&lt;typename _Tp&gt;</a>
<a name="ln373">    inline complex&lt;_Tp&gt;</a>
<a name="ln374">    operator-(const _Tp&amp; __x, const complex&lt;_Tp&gt;&amp; __y)</a>
<a name="ln375">    {</a>
<a name="ln376">      complex&lt;_Tp&gt; __r(__x, -__y.imag());</a>
<a name="ln377">      __r -= __y.real();</a>
<a name="ln378">      return __r;</a>
<a name="ln379">    }</a>
<a name="ln380">  //@}</a>
<a name="ln381"> </a>
<a name="ln382">  //@{</a>
<a name="ln383">  ///  Return new complex value @a x times @a y.</a>
<a name="ln384">  template&lt;typename _Tp&gt;</a>
<a name="ln385">    inline complex&lt;_Tp&gt;</a>
<a name="ln386">    operator*(const complex&lt;_Tp&gt;&amp; __x, const complex&lt;_Tp&gt;&amp; __y)</a>
<a name="ln387">    {</a>
<a name="ln388">      complex&lt;_Tp&gt; __r = __x;</a>
<a name="ln389">      __r *= __y;</a>
<a name="ln390">      return __r;</a>
<a name="ln391">    }</a>
<a name="ln392"> </a>
<a name="ln393">  template&lt;typename _Tp&gt;</a>
<a name="ln394">    inline complex&lt;_Tp&gt;</a>
<a name="ln395">    operator*(const complex&lt;_Tp&gt;&amp; __x, const _Tp&amp; __y)</a>
<a name="ln396">    {</a>
<a name="ln397">      complex&lt;_Tp&gt; __r = __x;</a>
<a name="ln398">      __r *= __y;</a>
<a name="ln399">      return __r;</a>
<a name="ln400">    }</a>
<a name="ln401"> </a>
<a name="ln402">  template&lt;typename _Tp&gt;</a>
<a name="ln403">    inline complex&lt;_Tp&gt;</a>
<a name="ln404">    operator*(const _Tp&amp; __x, const complex&lt;_Tp&gt;&amp; __y)</a>
<a name="ln405">    {</a>
<a name="ln406">      complex&lt;_Tp&gt; __r = __y;</a>
<a name="ln407">      __r *= __x;</a>
<a name="ln408">      return __r;</a>
<a name="ln409">    }</a>
<a name="ln410">  //@}</a>
<a name="ln411"> </a>
<a name="ln412">  //@{</a>
<a name="ln413">  ///  Return new complex value @a x divided by @a y.</a>
<a name="ln414">  template&lt;typename _Tp&gt;</a>
<a name="ln415">    inline complex&lt;_Tp&gt;</a>
<a name="ln416">    operator/(const complex&lt;_Tp&gt;&amp; __x, const complex&lt;_Tp&gt;&amp; __y)</a>
<a name="ln417">    {</a>
<a name="ln418">      complex&lt;_Tp&gt; __r = __x;</a>
<a name="ln419">      __r /= __y;</a>
<a name="ln420">      return __r;</a>
<a name="ln421">    }</a>
<a name="ln422"> </a>
<a name="ln423">  template&lt;typename _Tp&gt;</a>
<a name="ln424">    inline complex&lt;_Tp&gt;</a>
<a name="ln425">    operator/(const complex&lt;_Tp&gt;&amp; __x, const _Tp&amp; __y)</a>
<a name="ln426">    {</a>
<a name="ln427">      complex&lt;_Tp&gt; __r = __x;</a>
<a name="ln428">      __r /= __y;</a>
<a name="ln429">      return __r;</a>
<a name="ln430">    }</a>
<a name="ln431"> </a>
<a name="ln432">  template&lt;typename _Tp&gt;</a>
<a name="ln433">    inline complex&lt;_Tp&gt;</a>
<a name="ln434">    operator/(const _Tp&amp; __x, const complex&lt;_Tp&gt;&amp; __y)</a>
<a name="ln435">    {</a>
<a name="ln436">      complex&lt;_Tp&gt; __r = __x;</a>
<a name="ln437">      __r /= __y;</a>
<a name="ln438">      return __r;</a>
<a name="ln439">    }</a>
<a name="ln440">  //@}</a>
<a name="ln441"> </a>
<a name="ln442">  ///  Return @a x.</a>
<a name="ln443">  template&lt;typename _Tp&gt;</a>
<a name="ln444">    inline complex&lt;_Tp&gt;</a>
<a name="ln445">    operator+(const complex&lt;_Tp&gt;&amp; __x)</a>
<a name="ln446">    { return __x; }</a>
<a name="ln447"> </a>
<a name="ln448">  ///  Return complex negation of @a x.</a>
<a name="ln449">  template&lt;typename _Tp&gt;</a>
<a name="ln450">    inline complex&lt;_Tp&gt;</a>
<a name="ln451">    operator-(const complex&lt;_Tp&gt;&amp; __x)</a>
<a name="ln452">    {  return complex&lt;_Tp&gt;(-__x.real(), -__x.imag()); }</a>
<a name="ln453"> </a>
<a name="ln454">  //@{</a>
<a name="ln455">  ///  Return true if @a x is equal to @a y.</a>
<a name="ln456">  template&lt;typename _Tp&gt;</a>
<a name="ln457">    inline _GLIBCXX_CONSTEXPR bool</a>
<a name="ln458">    operator==(const complex&lt;_Tp&gt;&amp; __x, const complex&lt;_Tp&gt;&amp; __y)</a>
<a name="ln459">    { return __x.real() == __y.real() &amp;&amp; __x.imag() == __y.imag(); }</a>
<a name="ln460"> </a>
<a name="ln461">  template&lt;typename _Tp&gt;</a>
<a name="ln462">    inline _GLIBCXX_CONSTEXPR bool</a>
<a name="ln463">    operator==(const complex&lt;_Tp&gt;&amp; __x, const _Tp&amp; __y)</a>
<a name="ln464">    { return __x.real() == __y &amp;&amp; __x.imag() == _Tp(); }</a>
<a name="ln465"> </a>
<a name="ln466">  template&lt;typename _Tp&gt;</a>
<a name="ln467">    inline _GLIBCXX_CONSTEXPR bool</a>
<a name="ln468">    operator==(const _Tp&amp; __x, const complex&lt;_Tp&gt;&amp; __y)</a>
<a name="ln469">    { return __x == __y.real() &amp;&amp; _Tp() == __y.imag(); }</a>
<a name="ln470">  //@}</a>
<a name="ln471"> </a>
<a name="ln472">  //@{</a>
<a name="ln473">  ///  Return false if @a x is equal to @a y.</a>
<a name="ln474">  template&lt;typename _Tp&gt;</a>
<a name="ln475">    inline _GLIBCXX_CONSTEXPR bool</a>
<a name="ln476">    operator!=(const complex&lt;_Tp&gt;&amp; __x, const complex&lt;_Tp&gt;&amp; __y)</a>
<a name="ln477">    { return __x.real() != __y.real() || __x.imag() != __y.imag(); }</a>
<a name="ln478"> </a>
<a name="ln479">  template&lt;typename _Tp&gt;</a>
<a name="ln480">    inline _GLIBCXX_CONSTEXPR bool</a>
<a name="ln481">    operator!=(const complex&lt;_Tp&gt;&amp; __x, const _Tp&amp; __y)</a>
<a name="ln482">    { return __x.real() != __y || __x.imag() != _Tp(); }</a>
<a name="ln483"> </a>
<a name="ln484">  template&lt;typename _Tp&gt;</a>
<a name="ln485">    inline _GLIBCXX_CONSTEXPR bool</a>
<a name="ln486">    operator!=(const _Tp&amp; __x, const complex&lt;_Tp&gt;&amp; __y)</a>
<a name="ln487">    { return __x != __y.real() || _Tp() != __y.imag(); }</a>
<a name="ln488">  //@}</a>
<a name="ln489"> </a>
<a name="ln490">  ///  Extraction operator for complex values.</a>
<a name="ln491">  template&lt;typename _Tp, typename _CharT, class _Traits&gt;</a>
<a name="ln492">    basic_istream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln493">    operator&gt;&gt;(basic_istream&lt;_CharT, _Traits&gt;&amp; __is, complex&lt;_Tp&gt;&amp; __x)</a>
<a name="ln494">    {</a>
<a name="ln495">      bool __fail = true;</a>
<a name="ln496">      _CharT __ch;</a>
<a name="ln497">      if (__is &gt;&gt; __ch)</a>
<a name="ln498">	{</a>
<a name="ln499">	  if (_Traits::eq(__ch, __is.widen('(')))</a>
<a name="ln500">	    {</a>
<a name="ln501">	      _Tp __u;</a>
<a name="ln502">	      if (__is &gt;&gt; __u &gt;&gt; __ch)</a>
<a name="ln503">		{</a>
<a name="ln504">		  const _CharT __rparen = __is.widen(')');</a>
<a name="ln505">		  if (_Traits::eq(__ch, __rparen))</a>
<a name="ln506">		    {</a>
<a name="ln507">		      __x = __u;</a>
<a name="ln508">		      __fail = false;</a>
<a name="ln509">		    }</a>
<a name="ln510">		  else if (_Traits::eq(__ch, __is.widen(',')))</a>
<a name="ln511">		    {</a>
<a name="ln512">		      _Tp __v;</a>
<a name="ln513">		      if (__is &gt;&gt; __v &gt;&gt; __ch)</a>
<a name="ln514">			{</a>
<a name="ln515">			  if (_Traits::eq(__ch, __rparen))</a>
<a name="ln516">			    {</a>
<a name="ln517">			      __x = complex&lt;_Tp&gt;(__u, __v);</a>
<a name="ln518">			      __fail = false;</a>
<a name="ln519">			    }</a>
<a name="ln520">			  else</a>
<a name="ln521">			    __is.putback(__ch);</a>
<a name="ln522">			}</a>
<a name="ln523">		    }</a>
<a name="ln524">		  else</a>
<a name="ln525">		    __is.putback(__ch);</a>
<a name="ln526">		}</a>
<a name="ln527">	    }</a>
<a name="ln528">	  else</a>
<a name="ln529">	    {</a>
<a name="ln530">	      __is.putback(__ch);</a>
<a name="ln531">	      _Tp __u;</a>
<a name="ln532">	      if (__is &gt;&gt; __u)</a>
<a name="ln533">		{</a>
<a name="ln534">		  __x = __u;</a>
<a name="ln535">		  __fail = false;</a>
<a name="ln536">		}</a>
<a name="ln537">	    }</a>
<a name="ln538">	}</a>
<a name="ln539">      if (__fail)</a>
<a name="ln540">	__is.setstate(ios_base::failbit);</a>
<a name="ln541">      return __is;</a>
<a name="ln542">    }</a>
<a name="ln543"> </a>
<a name="ln544">  ///  Insertion operator for complex values.</a>
<a name="ln545">  template&lt;typename _Tp, typename _CharT, class _Traits&gt;</a>
<a name="ln546">    basic_ostream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln547">    operator&lt;&lt;(basic_ostream&lt;_CharT, _Traits&gt;&amp; __os, const complex&lt;_Tp&gt;&amp; __x)</a>
<a name="ln548">    {</a>
<a name="ln549">      basic_ostringstream&lt;_CharT, _Traits&gt; __s;</a>
<a name="ln550">      __s.flags(__os.flags());</a>
<a name="ln551">      __s.imbue(__os.getloc());</a>
<a name="ln552">      __s.precision(__os.precision());</a>
<a name="ln553">      __s &lt;&lt; '(' &lt;&lt; __x.real() &lt;&lt; ',' &lt;&lt; __x.imag() &lt;&lt; ')';</a>
<a name="ln554">      return __os &lt;&lt; __s.str();</a>
<a name="ln555">    }</a>
<a name="ln556"> </a>
<a name="ln557">  // Values</a>
<a name="ln558">#if __cplusplus &gt;= 201103L</a>
<a name="ln559">  template&lt;typename _Tp&gt;</a>
<a name="ln560">    constexpr _Tp</a>
<a name="ln561">    real(const complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln562">    { return __z.real(); }</a>
<a name="ln563"> </a>
<a name="ln564">  template&lt;typename _Tp&gt;</a>
<a name="ln565">    constexpr _Tp</a>
<a name="ln566">    imag(const complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln567">    { return __z.imag(); }</a>
<a name="ln568">#else</a>
<a name="ln569">  template&lt;typename _Tp&gt;</a>
<a name="ln570">    inline _Tp&amp;</a>
<a name="ln571">    real(complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln572">    { return __z.real(); }</a>
<a name="ln573"> </a>
<a name="ln574">  template&lt;typename _Tp&gt;</a>
<a name="ln575">    inline const _Tp&amp;</a>
<a name="ln576">    real(const complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln577">    { return __z.real(); }</a>
<a name="ln578"> </a>
<a name="ln579">  template&lt;typename _Tp&gt;</a>
<a name="ln580">    inline _Tp&amp;</a>
<a name="ln581">    imag(complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln582">    { return __z.imag(); }</a>
<a name="ln583"> </a>
<a name="ln584">  template&lt;typename _Tp&gt;</a>
<a name="ln585">    inline const _Tp&amp;</a>
<a name="ln586">    imag(const complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln587">    { return __z.imag(); }</a>
<a name="ln588">#endif</a>
<a name="ln589"> </a>
<a name="ln590">  // 26.2.7/3 abs(__z):  Returns the magnitude of __z.</a>
<a name="ln591">  template&lt;typename _Tp&gt;</a>
<a name="ln592">    inline _Tp</a>
<a name="ln593">    __complex_abs(const complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln594">    {</a>
<a name="ln595">      _Tp __x = __z.real();</a>
<a name="ln596">      _Tp __y = __z.imag();</a>
<a name="ln597">      const _Tp __s = std::max(abs(__x), abs(__y));</a>
<a name="ln598">      if (__s == _Tp())  // well ...</a>
<a name="ln599">        return __s;</a>
<a name="ln600">      __x /= __s;</a>
<a name="ln601">      __y /= __s;</a>
<a name="ln602">      return __s * sqrt(__x * __x + __y * __y);</a>
<a name="ln603">    }</a>
<a name="ln604"> </a>
<a name="ln605">#if _GLIBCXX_USE_C99_COMPLEX</a>
<a name="ln606">  inline float</a>
<a name="ln607">  __complex_abs(__complex__ float __z) { return __builtin_cabsf(__z); }</a>
<a name="ln608"> </a>
<a name="ln609">  inline double</a>
<a name="ln610">  __complex_abs(__complex__ double __z) { return __builtin_cabs(__z); }</a>
<a name="ln611"> </a>
<a name="ln612">  inline long double</a>
<a name="ln613">  __complex_abs(const __complex__ long double&amp; __z)</a>
<a name="ln614">  { return __builtin_cabsl(__z); }</a>
<a name="ln615"> </a>
<a name="ln616">  template&lt;typename _Tp&gt;</a>
<a name="ln617">    inline _Tp</a>
<a name="ln618">    abs(const complex&lt;_Tp&gt;&amp; __z) { return __complex_abs(__z.__rep()); }</a>
<a name="ln619">#else</a>
<a name="ln620">  template&lt;typename _Tp&gt;</a>
<a name="ln621">    inline _Tp</a>
<a name="ln622">    abs(const complex&lt;_Tp&gt;&amp; __z) { return __complex_abs(__z); }</a>
<a name="ln623">#endif</a>
<a name="ln624"> </a>
<a name="ln625"> </a>
<a name="ln626">  // 26.2.7/4: arg(__z): Returns the phase angle of __z.</a>
<a name="ln627">  template&lt;typename _Tp&gt;</a>
<a name="ln628">    inline _Tp</a>
<a name="ln629">    __complex_arg(const complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln630">    { return  atan2(__z.imag(), __z.real()); }</a>
<a name="ln631"> </a>
<a name="ln632">#if _GLIBCXX_USE_C99_COMPLEX</a>
<a name="ln633">  inline float</a>
<a name="ln634">  __complex_arg(__complex__ float __z) { return __builtin_cargf(__z); }</a>
<a name="ln635"> </a>
<a name="ln636">  inline double</a>
<a name="ln637">  __complex_arg(__complex__ double __z) { return __builtin_carg(__z); }</a>
<a name="ln638"> </a>
<a name="ln639">  inline long double</a>
<a name="ln640">  __complex_arg(const __complex__ long double&amp; __z)</a>
<a name="ln641">  { return __builtin_cargl(__z); }</a>
<a name="ln642"> </a>
<a name="ln643">  template&lt;typename _Tp&gt;</a>
<a name="ln644">    inline _Tp</a>
<a name="ln645">    arg(const complex&lt;_Tp&gt;&amp; __z) { return __complex_arg(__z.__rep()); }</a>
<a name="ln646">#else</a>
<a name="ln647">  template&lt;typename _Tp&gt;</a>
<a name="ln648">    inline _Tp</a>
<a name="ln649">    arg(const complex&lt;_Tp&gt;&amp; __z) { return __complex_arg(__z); }</a>
<a name="ln650">#endif</a>
<a name="ln651"> </a>
<a name="ln652">  // 26.2.7/5: norm(__z) returns the squared magnitude of __z.</a>
<a name="ln653">  //     As defined, norm() is -not- a norm is the common mathematical</a>
<a name="ln654">  //     sense used in numerics.  The helper class _Norm_helper&lt;&gt; tries to</a>
<a name="ln655">  //     distinguish between builtin floating point and the rest, so as</a>
<a name="ln656">  //     to deliver an answer as close as possible to the real value.</a>
<a name="ln657">  template&lt;bool&gt;</a>
<a name="ln658">    struct _Norm_helper</a>
<a name="ln659">    {</a>
<a name="ln660">      template&lt;typename _Tp&gt;</a>
<a name="ln661">        static inline _Tp _S_do_it(const complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln662">        {</a>
<a name="ln663">          const _Tp __x = __z.real();</a>
<a name="ln664">          const _Tp __y = __z.imag();</a>
<a name="ln665">          return __x * __x + __y * __y;</a>
<a name="ln666">        }</a>
<a name="ln667">    };</a>
<a name="ln668"> </a>
<a name="ln669">  template&lt;&gt;</a>
<a name="ln670">    struct _Norm_helper&lt;true&gt;</a>
<a name="ln671">    {</a>
<a name="ln672">      template&lt;typename _Tp&gt;</a>
<a name="ln673">        static inline _Tp _S_do_it(const complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln674">        {</a>
<a name="ln675">          _Tp __res = std::abs(__z);</a>
<a name="ln676">          return __res * __res;</a>
<a name="ln677">        }</a>
<a name="ln678">    };</a>
<a name="ln679"> </a>
<a name="ln680">  template&lt;typename _Tp&gt;</a>
<a name="ln681">    inline _Tp</a>
<a name="ln682">    norm(const complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln683">    {</a>
<a name="ln684">      return _Norm_helper&lt;__is_floating&lt;_Tp&gt;::__value</a>
<a name="ln685">	&amp;&amp; !_GLIBCXX_FAST_MATH&gt;::_S_do_it(__z);</a>
<a name="ln686">    }</a>
<a name="ln687"> </a>
<a name="ln688">  template&lt;typename _Tp&gt;</a>
<a name="ln689">    inline complex&lt;_Tp&gt;</a>
<a name="ln690">    polar(const _Tp&amp; __rho, const _Tp&amp; __theta)</a>
<a name="ln691">    {</a>
<a name="ln692">      __glibcxx_assert( __rho &gt;= 0 );</a>
<a name="ln693">      return complex&lt;_Tp&gt;(__rho * cos(__theta), __rho * sin(__theta));</a>
<a name="ln694">    }</a>
<a name="ln695"> </a>
<a name="ln696">  template&lt;typename _Tp&gt;</a>
<a name="ln697">    inline complex&lt;_Tp&gt;</a>
<a name="ln698">    conj(const complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln699">    { return complex&lt;_Tp&gt;(__z.real(), -__z.imag()); }</a>
<a name="ln700"> </a>
<a name="ln701">  // Transcendentals</a>
<a name="ln702"> </a>
<a name="ln703">  // 26.2.8/1 cos(__z):  Returns the cosine of __z.</a>
<a name="ln704">  template&lt;typename _Tp&gt;</a>
<a name="ln705">    inline complex&lt;_Tp&gt;</a>
<a name="ln706">    __complex_cos(const complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln707">    {</a>
<a name="ln708">      const _Tp __x = __z.real();</a>
<a name="ln709">      const _Tp __y = __z.imag();</a>
<a name="ln710">      return complex&lt;_Tp&gt;(cos(__x) * cosh(__y), -sin(__x) * sinh(__y));</a>
<a name="ln711">    }</a>
<a name="ln712"> </a>
<a name="ln713">#if _GLIBCXX_USE_C99_COMPLEX</a>
<a name="ln714">  inline __complex__ float</a>
<a name="ln715">  __complex_cos(__complex__ float __z) { return __builtin_ccosf(__z); }</a>
<a name="ln716"> </a>
<a name="ln717">  inline __complex__ double</a>
<a name="ln718">  __complex_cos(__complex__ double __z) { return __builtin_ccos(__z); }</a>
<a name="ln719"> </a>
<a name="ln720">  inline __complex__ long double</a>
<a name="ln721">  __complex_cos(const __complex__ long double&amp; __z)</a>
<a name="ln722">  { return __builtin_ccosl(__z); }</a>
<a name="ln723"> </a>
<a name="ln724">  template&lt;typename _Tp&gt;</a>
<a name="ln725">    inline complex&lt;_Tp&gt;</a>
<a name="ln726">    cos(const complex&lt;_Tp&gt;&amp; __z) { return __complex_cos(__z.__rep()); }</a>
<a name="ln727">#else</a>
<a name="ln728">  template&lt;typename _Tp&gt;</a>
<a name="ln729">    inline complex&lt;_Tp&gt;</a>
<a name="ln730">    cos(const complex&lt;_Tp&gt;&amp; __z) { return __complex_cos(__z); }</a>
<a name="ln731">#endif</a>
<a name="ln732"> </a>
<a name="ln733">  // 26.2.8/2 cosh(__z): Returns the hyperbolic cosine of __z.</a>
<a name="ln734">  template&lt;typename _Tp&gt;</a>
<a name="ln735">    inline complex&lt;_Tp&gt;</a>
<a name="ln736">    __complex_cosh(const complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln737">    {</a>
<a name="ln738">      const _Tp __x = __z.real();</a>
<a name="ln739">      const _Tp __y = __z.imag();</a>
<a name="ln740">      return complex&lt;_Tp&gt;(cosh(__x) * cos(__y), sinh(__x) * sin(__y));</a>
<a name="ln741">    }</a>
<a name="ln742"> </a>
<a name="ln743">#if _GLIBCXX_USE_C99_COMPLEX</a>
<a name="ln744">  inline __complex__ float</a>
<a name="ln745">  __complex_cosh(__complex__ float __z) { return __builtin_ccoshf(__z); }</a>
<a name="ln746"> </a>
<a name="ln747">  inline __complex__ double</a>
<a name="ln748">  __complex_cosh(__complex__ double __z) { return __builtin_ccosh(__z); }</a>
<a name="ln749"> </a>
<a name="ln750">  inline __complex__ long double</a>
<a name="ln751">  __complex_cosh(const __complex__ long double&amp; __z)</a>
<a name="ln752">  { return __builtin_ccoshl(__z); }</a>
<a name="ln753"> </a>
<a name="ln754">  template&lt;typename _Tp&gt;</a>
<a name="ln755">    inline complex&lt;_Tp&gt;</a>
<a name="ln756">    cosh(const complex&lt;_Tp&gt;&amp; __z) { return __complex_cosh(__z.__rep()); }</a>
<a name="ln757">#else</a>
<a name="ln758">  template&lt;typename _Tp&gt;</a>
<a name="ln759">    inline complex&lt;_Tp&gt;</a>
<a name="ln760">    cosh(const complex&lt;_Tp&gt;&amp; __z) { return __complex_cosh(__z); }</a>
<a name="ln761">#endif</a>
<a name="ln762"> </a>
<a name="ln763">  // 26.2.8/3 exp(__z): Returns the complex base e exponential of x</a>
<a name="ln764">  template&lt;typename _Tp&gt;</a>
<a name="ln765">    inline complex&lt;_Tp&gt;</a>
<a name="ln766">    __complex_exp(const complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln767">    { return std::polar&lt;_Tp&gt;(exp(__z.real()), __z.imag()); }</a>
<a name="ln768"> </a>
<a name="ln769">#if _GLIBCXX_USE_C99_COMPLEX</a>
<a name="ln770">  inline __complex__ float</a>
<a name="ln771">  __complex_exp(__complex__ float __z) { return __builtin_cexpf(__z); }</a>
<a name="ln772"> </a>
<a name="ln773">  inline __complex__ double</a>
<a name="ln774">  __complex_exp(__complex__ double __z) { return __builtin_cexp(__z); }</a>
<a name="ln775"> </a>
<a name="ln776">  inline __complex__ long double</a>
<a name="ln777">  __complex_exp(const __complex__ long double&amp; __z)</a>
<a name="ln778">  { return __builtin_cexpl(__z); }</a>
<a name="ln779"> </a>
<a name="ln780">  template&lt;typename _Tp&gt;</a>
<a name="ln781">    inline complex&lt;_Tp&gt;</a>
<a name="ln782">    exp(const complex&lt;_Tp&gt;&amp; __z) { return __complex_exp(__z.__rep()); }</a>
<a name="ln783">#else</a>
<a name="ln784">  template&lt;typename _Tp&gt;</a>
<a name="ln785">    inline complex&lt;_Tp&gt;</a>
<a name="ln786">    exp(const complex&lt;_Tp&gt;&amp; __z) { return __complex_exp(__z); }</a>
<a name="ln787">#endif</a>
<a name="ln788"> </a>
<a name="ln789">  // 26.2.8/5 log(__z): Returns the natural complex logarithm of __z.</a>
<a name="ln790">  //                    The branch cut is along the negative axis.</a>
<a name="ln791">  template&lt;typename _Tp&gt;</a>
<a name="ln792">    inline complex&lt;_Tp&gt;</a>
<a name="ln793">    __complex_log(const complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln794">    { return complex&lt;_Tp&gt;(log(std::abs(__z)), std::arg(__z)); }</a>
<a name="ln795"> </a>
<a name="ln796">#if _GLIBCXX_USE_C99_COMPLEX</a>
<a name="ln797">  inline __complex__ float</a>
<a name="ln798">  __complex_log(__complex__ float __z) { return __builtin_clogf(__z); }</a>
<a name="ln799"> </a>
<a name="ln800">  inline __complex__ double</a>
<a name="ln801">  __complex_log(__complex__ double __z) { return __builtin_clog(__z); }</a>
<a name="ln802"> </a>
<a name="ln803">  inline __complex__ long double</a>
<a name="ln804">  __complex_log(const __complex__ long double&amp; __z)</a>
<a name="ln805">  { return __builtin_clogl(__z); }</a>
<a name="ln806"> </a>
<a name="ln807">  template&lt;typename _Tp&gt;</a>
<a name="ln808">    inline complex&lt;_Tp&gt;</a>
<a name="ln809">    log(const complex&lt;_Tp&gt;&amp; __z) { return __complex_log(__z.__rep()); }</a>
<a name="ln810">#else</a>
<a name="ln811">  template&lt;typename _Tp&gt;</a>
<a name="ln812">    inline complex&lt;_Tp&gt;</a>
<a name="ln813">    log(const complex&lt;_Tp&gt;&amp; __z) { return __complex_log(__z); }</a>
<a name="ln814">#endif</a>
<a name="ln815"> </a>
<a name="ln816">  template&lt;typename _Tp&gt;</a>
<a name="ln817">    inline complex&lt;_Tp&gt;</a>
<a name="ln818">    log10(const complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln819">    { return std::log(__z) / log(_Tp(10.0)); }</a>
<a name="ln820"> </a>
<a name="ln821">  // 26.2.8/10 sin(__z): Returns the sine of __z.</a>
<a name="ln822">  template&lt;typename _Tp&gt;</a>
<a name="ln823">    inline complex&lt;_Tp&gt;</a>
<a name="ln824">    __complex_sin(const complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln825">    {</a>
<a name="ln826">      const _Tp __x = __z.real();</a>
<a name="ln827">      const _Tp __y = __z.imag();</a>
<a name="ln828">      return complex&lt;_Tp&gt;(sin(__x) * cosh(__y), cos(__x) * sinh(__y));</a>
<a name="ln829">    }</a>
<a name="ln830"> </a>
<a name="ln831">#if _GLIBCXX_USE_C99_COMPLEX</a>
<a name="ln832">  inline __complex__ float</a>
<a name="ln833">  __complex_sin(__complex__ float __z) { return __builtin_csinf(__z); }</a>
<a name="ln834"> </a>
<a name="ln835">  inline __complex__ double</a>
<a name="ln836">  __complex_sin(__complex__ double __z) { return __builtin_csin(__z); }</a>
<a name="ln837"> </a>
<a name="ln838">  inline __complex__ long double</a>
<a name="ln839">  __complex_sin(const __complex__ long double&amp; __z)</a>
<a name="ln840">  { return __builtin_csinl(__z); }</a>
<a name="ln841"> </a>
<a name="ln842">  template&lt;typename _Tp&gt;</a>
<a name="ln843">    inline complex&lt;_Tp&gt;</a>
<a name="ln844">    sin(const complex&lt;_Tp&gt;&amp; __z) { return __complex_sin(__z.__rep()); }</a>
<a name="ln845">#else</a>
<a name="ln846">  template&lt;typename _Tp&gt;</a>
<a name="ln847">    inline complex&lt;_Tp&gt;</a>
<a name="ln848">    sin(const complex&lt;_Tp&gt;&amp; __z) { return __complex_sin(__z); }</a>
<a name="ln849">#endif</a>
<a name="ln850"> </a>
<a name="ln851">  // 26.2.8/11 sinh(__z): Returns the hyperbolic sine of __z.</a>
<a name="ln852">  template&lt;typename _Tp&gt;</a>
<a name="ln853">    inline complex&lt;_Tp&gt;</a>
<a name="ln854">    __complex_sinh(const complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln855">    {</a>
<a name="ln856">      const _Tp __x = __z.real();</a>
<a name="ln857">      const _Tp  __y = __z.imag();</a>
<a name="ln858">      return complex&lt;_Tp&gt;(sinh(__x) * cos(__y), cosh(__x) * sin(__y));</a>
<a name="ln859">    }</a>
<a name="ln860"> </a>
<a name="ln861">#if _GLIBCXX_USE_C99_COMPLEX</a>
<a name="ln862">  inline __complex__ float</a>
<a name="ln863">  __complex_sinh(__complex__ float __z) { return __builtin_csinhf(__z); }</a>
<a name="ln864"> </a>
<a name="ln865">  inline __complex__ double</a>
<a name="ln866">  __complex_sinh(__complex__ double __z) { return __builtin_csinh(__z); }</a>
<a name="ln867"> </a>
<a name="ln868">  inline __complex__ long double</a>
<a name="ln869">  __complex_sinh(const __complex__ long double&amp; __z)</a>
<a name="ln870">  { return __builtin_csinhl(__z); }</a>
<a name="ln871"> </a>
<a name="ln872">  template&lt;typename _Tp&gt;</a>
<a name="ln873">    inline complex&lt;_Tp&gt;</a>
<a name="ln874">    sinh(const complex&lt;_Tp&gt;&amp; __z) { return __complex_sinh(__z.__rep()); }</a>
<a name="ln875">#else</a>
<a name="ln876">  template&lt;typename _Tp&gt;</a>
<a name="ln877">    inline complex&lt;_Tp&gt;</a>
<a name="ln878">    sinh(const complex&lt;_Tp&gt;&amp; __z) { return __complex_sinh(__z); }</a>
<a name="ln879">#endif</a>
<a name="ln880"> </a>
<a name="ln881">  // 26.2.8/13 sqrt(__z): Returns the complex square root of __z.</a>
<a name="ln882">  //                     The branch cut is on the negative axis.</a>
<a name="ln883">  template&lt;typename _Tp&gt;</a>
<a name="ln884">    complex&lt;_Tp&gt;</a>
<a name="ln885">    __complex_sqrt(const complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln886">    {</a>
<a name="ln887">      _Tp __x = __z.real();</a>
<a name="ln888">      _Tp __y = __z.imag();</a>
<a name="ln889"> </a>
<a name="ln890">      if (__x == _Tp())</a>
<a name="ln891">        {</a>
<a name="ln892">          _Tp __t = sqrt(abs(__y) / 2);</a>
<a name="ln893">          return complex&lt;_Tp&gt;(__t, __y &lt; _Tp() ? -__t : __t);</a>
<a name="ln894">        }</a>
<a name="ln895">      else</a>
<a name="ln896">        {</a>
<a name="ln897">          _Tp __t = sqrt(2 * (std::abs(__z) + abs(__x)));</a>
<a name="ln898">          _Tp __u = __t / 2;</a>
<a name="ln899">          return __x &gt; _Tp()</a>
<a name="ln900">            ? complex&lt;_Tp&gt;(__u, __y / __t)</a>
<a name="ln901">            : complex&lt;_Tp&gt;(abs(__y) / __t, __y &lt; _Tp() ? -__u : __u);</a>
<a name="ln902">        }</a>
<a name="ln903">    }</a>
<a name="ln904"> </a>
<a name="ln905">#if _GLIBCXX_USE_C99_COMPLEX</a>
<a name="ln906">  inline __complex__ float</a>
<a name="ln907">  __complex_sqrt(__complex__ float __z) { return __builtin_csqrtf(__z); }</a>
<a name="ln908"> </a>
<a name="ln909">  inline __complex__ double</a>
<a name="ln910">  __complex_sqrt(__complex__ double __z) { return __builtin_csqrt(__z); }</a>
<a name="ln911"> </a>
<a name="ln912">  inline __complex__ long double</a>
<a name="ln913">  __complex_sqrt(const __complex__ long double&amp; __z)</a>
<a name="ln914">  { return __builtin_csqrtl(__z); }</a>
<a name="ln915"> </a>
<a name="ln916">  template&lt;typename _Tp&gt;</a>
<a name="ln917">    inline complex&lt;_Tp&gt;</a>
<a name="ln918">    sqrt(const complex&lt;_Tp&gt;&amp; __z) { return __complex_sqrt(__z.__rep()); }</a>
<a name="ln919">#else</a>
<a name="ln920">  template&lt;typename _Tp&gt;</a>
<a name="ln921">    inline complex&lt;_Tp&gt;</a>
<a name="ln922">    sqrt(const complex&lt;_Tp&gt;&amp; __z) { return __complex_sqrt(__z); }</a>
<a name="ln923">#endif</a>
<a name="ln924"> </a>
<a name="ln925">  // 26.2.8/14 tan(__z):  Return the complex tangent of __z.</a>
<a name="ln926"> </a>
<a name="ln927">  template&lt;typename _Tp&gt;</a>
<a name="ln928">    inline complex&lt;_Tp&gt;</a>
<a name="ln929">    __complex_tan(const complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln930">    { return std::sin(__z) / std::cos(__z); }</a>
<a name="ln931"> </a>
<a name="ln932">#if _GLIBCXX_USE_C99_COMPLEX</a>
<a name="ln933">  inline __complex__ float</a>
<a name="ln934">  __complex_tan(__complex__ float __z) { return __builtin_ctanf(__z); }</a>
<a name="ln935"> </a>
<a name="ln936">  inline __complex__ double</a>
<a name="ln937">  __complex_tan(__complex__ double __z) { return __builtin_ctan(__z); }</a>
<a name="ln938"> </a>
<a name="ln939">  inline __complex__ long double</a>
<a name="ln940">  __complex_tan(const __complex__ long double&amp; __z)</a>
<a name="ln941">  { return __builtin_ctanl(__z); }</a>
<a name="ln942"> </a>
<a name="ln943">  template&lt;typename _Tp&gt;</a>
<a name="ln944">    inline complex&lt;_Tp&gt;</a>
<a name="ln945">    tan(const complex&lt;_Tp&gt;&amp; __z) { return __complex_tan(__z.__rep()); }</a>
<a name="ln946">#else</a>
<a name="ln947">  template&lt;typename _Tp&gt;</a>
<a name="ln948">    inline complex&lt;_Tp&gt;</a>
<a name="ln949">    tan(const complex&lt;_Tp&gt;&amp; __z) { return __complex_tan(__z); }</a>
<a name="ln950">#endif</a>
<a name="ln951"> </a>
<a name="ln952"> </a>
<a name="ln953">  // 26.2.8/15 tanh(__z):  Returns the hyperbolic tangent of __z.</a>
<a name="ln954"> </a>
<a name="ln955">  template&lt;typename _Tp&gt;</a>
<a name="ln956">    inline complex&lt;_Tp&gt;</a>
<a name="ln957">    __complex_tanh(const complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln958">    { return std::sinh(__z) / std::cosh(__z); }</a>
<a name="ln959"> </a>
<a name="ln960">#if _GLIBCXX_USE_C99_COMPLEX</a>
<a name="ln961">  inline __complex__ float</a>
<a name="ln962">  __complex_tanh(__complex__ float __z) { return __builtin_ctanhf(__z); }</a>
<a name="ln963"> </a>
<a name="ln964">  inline __complex__ double</a>
<a name="ln965">  __complex_tanh(__complex__ double __z) { return __builtin_ctanh(__z); }</a>
<a name="ln966"> </a>
<a name="ln967">  inline __complex__ long double</a>
<a name="ln968">  __complex_tanh(const __complex__ long double&amp; __z)</a>
<a name="ln969">  { return __builtin_ctanhl(__z); }</a>
<a name="ln970"> </a>
<a name="ln971">  template&lt;typename _Tp&gt;</a>
<a name="ln972">    inline complex&lt;_Tp&gt;</a>
<a name="ln973">    tanh(const complex&lt;_Tp&gt;&amp; __z) { return __complex_tanh(__z.__rep()); }</a>
<a name="ln974">#else</a>
<a name="ln975">  template&lt;typename _Tp&gt;</a>
<a name="ln976">    inline complex&lt;_Tp&gt;</a>
<a name="ln977">    tanh(const complex&lt;_Tp&gt;&amp; __z) { return __complex_tanh(__z); }</a>
<a name="ln978">#endif</a>
<a name="ln979"> </a>
<a name="ln980"> </a>
<a name="ln981">  // 26.2.8/9  pow(__x, __y): Returns the complex power base of __x</a>
<a name="ln982">  //                          raised to the __y-th power.  The branch</a>
<a name="ln983">  //                          cut is on the negative axis.</a>
<a name="ln984">  template&lt;typename _Tp&gt;</a>
<a name="ln985">    complex&lt;_Tp&gt;</a>
<a name="ln986">    __complex_pow_unsigned(complex&lt;_Tp&gt; __x, unsigned __n)</a>
<a name="ln987">    {</a>
<a name="ln988">      complex&lt;_Tp&gt; __y = __n % 2 ? __x : complex&lt;_Tp&gt;(1);</a>
<a name="ln989"> </a>
<a name="ln990">      while (__n &gt;&gt;= 1)</a>
<a name="ln991">        {</a>
<a name="ln992">          __x *= __x;</a>
<a name="ln993">          if (__n % 2)</a>
<a name="ln994">            __y *= __x;</a>
<a name="ln995">        }</a>
<a name="ln996"> </a>
<a name="ln997">      return __y;</a>
<a name="ln998">    }</a>
<a name="ln999"> </a>
<a name="ln1000">  // In C++11 mode we used to implement the resolution of</a>
<a name="ln1001">  // DR 844. complex pow return type is ambiguous.</a>
<a name="ln1002">  // thus the following overload was disabled in that mode.  However, doing</a>
<a name="ln1003">  // that causes all sorts of issues, see, for example:</a>
<a name="ln1004">  //   http://gcc.gnu.org/ml/libstdc++/2013-01/msg00058.html</a>
<a name="ln1005">  // and also PR57974.</a>
<a name="ln1006">  template&lt;typename _Tp&gt;</a>
<a name="ln1007">    inline complex&lt;_Tp&gt;</a>
<a name="ln1008">    pow(const complex&lt;_Tp&gt;&amp; __z, int __n)</a>
<a name="ln1009">    {</a>
<a name="ln1010">      return __n &lt; 0</a>
<a name="ln1011">	? complex&lt;_Tp&gt;(1) / std::__complex_pow_unsigned(__z, -(unsigned)__n)</a>
<a name="ln1012">        : std::__complex_pow_unsigned(__z, __n);</a>
<a name="ln1013">    }</a>
<a name="ln1014"> </a>
<a name="ln1015">  template&lt;typename _Tp&gt;</a>
<a name="ln1016">    complex&lt;_Tp&gt;</a>
<a name="ln1017">    pow(const complex&lt;_Tp&gt;&amp; __x, const _Tp&amp; __y)</a>
<a name="ln1018">    {</a>
<a name="ln1019">#if ! _GLIBCXX_USE_C99_COMPLEX</a>
<a name="ln1020">      if (__x == _Tp())</a>
<a name="ln1021">	return _Tp();</a>
<a name="ln1022">#endif</a>
<a name="ln1023">      if (__x.imag() == _Tp() &amp;&amp; __x.real() &gt; _Tp())</a>
<a name="ln1024">        return pow(__x.real(), __y);</a>
<a name="ln1025"> </a>
<a name="ln1026">      complex&lt;_Tp&gt; __t = std::log(__x);</a>
<a name="ln1027">      return std::polar&lt;_Tp&gt;(exp(__y * __t.real()), __y * __t.imag());</a>
<a name="ln1028">    }</a>
<a name="ln1029"> </a>
<a name="ln1030">  template&lt;typename _Tp&gt;</a>
<a name="ln1031">    inline complex&lt;_Tp&gt;</a>
<a name="ln1032">    __complex_pow(const complex&lt;_Tp&gt;&amp; __x, const complex&lt;_Tp&gt;&amp; __y)</a>
<a name="ln1033">    { return __x == _Tp() ? _Tp() : std::exp(__y * std::log(__x)); }</a>
<a name="ln1034"> </a>
<a name="ln1035">#if _GLIBCXX_USE_C99_COMPLEX</a>
<a name="ln1036">  inline __complex__ float</a>
<a name="ln1037">  __complex_pow(__complex__ float __x, __complex__ float __y)</a>
<a name="ln1038">  { return __builtin_cpowf(__x, __y); }</a>
<a name="ln1039"> </a>
<a name="ln1040">  inline __complex__ double</a>
<a name="ln1041">  __complex_pow(__complex__ double __x, __complex__ double __y)</a>
<a name="ln1042">  { return __builtin_cpow(__x, __y); }</a>
<a name="ln1043"> </a>
<a name="ln1044">  inline __complex__ long double</a>
<a name="ln1045">  __complex_pow(const __complex__ long double&amp; __x,</a>
<a name="ln1046">		const __complex__ long double&amp; __y)</a>
<a name="ln1047">  { return __builtin_cpowl(__x, __y); }</a>
<a name="ln1048"> </a>
<a name="ln1049">  template&lt;typename _Tp&gt;</a>
<a name="ln1050">    inline complex&lt;_Tp&gt;</a>
<a name="ln1051">    pow(const complex&lt;_Tp&gt;&amp; __x, const complex&lt;_Tp&gt;&amp; __y)</a>
<a name="ln1052">    { return __complex_pow(__x.__rep(), __y.__rep()); }</a>
<a name="ln1053">#else</a>
<a name="ln1054">  template&lt;typename _Tp&gt;</a>
<a name="ln1055">    inline complex&lt;_Tp&gt;</a>
<a name="ln1056">    pow(const complex&lt;_Tp&gt;&amp; __x, const complex&lt;_Tp&gt;&amp; __y)</a>
<a name="ln1057">    { return __complex_pow(__x, __y); }</a>
<a name="ln1058">#endif</a>
<a name="ln1059"> </a>
<a name="ln1060">  template&lt;typename _Tp&gt;</a>
<a name="ln1061">    inline complex&lt;_Tp&gt;</a>
<a name="ln1062">    pow(const _Tp&amp; __x, const complex&lt;_Tp&gt;&amp; __y)</a>
<a name="ln1063">    {</a>
<a name="ln1064">      return __x &gt; _Tp() ? std::polar&lt;_Tp&gt;(pow(__x, __y.real()),</a>
<a name="ln1065">					   __y.imag() * log(__x))</a>
<a name="ln1066">	                 : std::pow(complex&lt;_Tp&gt;(__x), __y);</a>
<a name="ln1067">    }</a>
<a name="ln1068"> </a>
<a name="ln1069">  /// 26.2.3  complex specializations</a>
<a name="ln1070">  /// complex&lt;float&gt; specialization</a>
<a name="ln1071">  template&lt;&gt;</a>
<a name="ln1072">    struct complex&lt;float&gt;</a>
<a name="ln1073">    {</a>
<a name="ln1074">      typedef float value_type;</a>
<a name="ln1075">      typedef __complex__ float _ComplexT;</a>
<a name="ln1076"> </a>
<a name="ln1077">      _GLIBCXX_CONSTEXPR complex(_ComplexT __z) : _M_value(__z) { }</a>
<a name="ln1078"> </a>
<a name="ln1079">      _GLIBCXX_CONSTEXPR complex(float __r = 0.0f, float __i = 0.0f)</a>
<a name="ln1080">#if __cplusplus &gt;= 201103L</a>
<a name="ln1081">      : _M_value{ __r, __i } { }</a>
<a name="ln1082">#else</a>
<a name="ln1083">      {</a>
<a name="ln1084">	__real__ _M_value = __r;</a>
<a name="ln1085">	__imag__ _M_value = __i;</a>
<a name="ln1086">      }</a>
<a name="ln1087">#endif</a>
<a name="ln1088"> </a>
<a name="ln1089">      explicit _GLIBCXX_CONSTEXPR complex(const complex&lt;double&gt;&amp;);</a>
<a name="ln1090">      explicit _GLIBCXX_CONSTEXPR complex(const complex&lt;long double&gt;&amp;);</a>
<a name="ln1091"> </a>
<a name="ln1092">#if __cplusplus &gt;= 201103L</a>
<a name="ln1093">      // _GLIBCXX_RESOLVE_LIB_DEFECTS</a>
<a name="ln1094">      // DR 387. std::complex over-encapsulated.</a>
<a name="ln1095">      __attribute ((__abi_tag__ (&quot;cxx11&quot;)))</a>
<a name="ln1096">      constexpr float</a>
<a name="ln1097">      real() const { return __real__ _M_value; }</a>
<a name="ln1098"> </a>
<a name="ln1099">      __attribute ((__abi_tag__ (&quot;cxx11&quot;)))</a>
<a name="ln1100">      constexpr float</a>
<a name="ln1101">      imag() const { return __imag__ _M_value; }</a>
<a name="ln1102">#else</a>
<a name="ln1103">      float&amp;</a>
<a name="ln1104">      real() { return __real__ _M_value; }</a>
<a name="ln1105"> </a>
<a name="ln1106">      const float&amp;</a>
<a name="ln1107">      real() const { return __real__ _M_value; }</a>
<a name="ln1108"> </a>
<a name="ln1109">      float&amp;</a>
<a name="ln1110">      imag() { return __imag__ _M_value; }</a>
<a name="ln1111"> </a>
<a name="ln1112">      const float&amp;</a>
<a name="ln1113">      imag() const { return __imag__ _M_value; }</a>
<a name="ln1114">#endif</a>
<a name="ln1115"> </a>
<a name="ln1116">      // _GLIBCXX_RESOLVE_LIB_DEFECTS</a>
<a name="ln1117">      // DR 387. std::complex over-encapsulated.</a>
<a name="ln1118">      void</a>
<a name="ln1119">      real(float __val) { __real__ _M_value = __val; }</a>
<a name="ln1120"> </a>
<a name="ln1121">      void</a>
<a name="ln1122">      imag(float __val) { __imag__ _M_value = __val; }</a>
<a name="ln1123"> </a>
<a name="ln1124">      complex&amp;</a>
<a name="ln1125">      operator=(float __f)</a>
<a name="ln1126">      {</a>
<a name="ln1127">	_M_value = __f;</a>
<a name="ln1128">	return *this;</a>
<a name="ln1129">      }</a>
<a name="ln1130"> </a>
<a name="ln1131">      complex&amp;</a>
<a name="ln1132">      operator+=(float __f)</a>
<a name="ln1133">      {</a>
<a name="ln1134">	_M_value += __f;</a>
<a name="ln1135">	return *this;</a>
<a name="ln1136">      }</a>
<a name="ln1137"> </a>
<a name="ln1138">      complex&amp;</a>
<a name="ln1139">      operator-=(float __f)</a>
<a name="ln1140">      {</a>
<a name="ln1141">	_M_value -= __f;</a>
<a name="ln1142">	return *this;</a>
<a name="ln1143">      }</a>
<a name="ln1144"> </a>
<a name="ln1145">      complex&amp;</a>
<a name="ln1146">      operator*=(float __f)</a>
<a name="ln1147">      {</a>
<a name="ln1148">	_M_value *= __f;</a>
<a name="ln1149">	return *this;</a>
<a name="ln1150">      }</a>
<a name="ln1151"> </a>
<a name="ln1152">      complex&amp;</a>
<a name="ln1153">      operator/=(float __f)</a>
<a name="ln1154">      {</a>
<a name="ln1155">	_M_value /= __f;</a>
<a name="ln1156">	return *this;</a>
<a name="ln1157">      }</a>
<a name="ln1158"> </a>
<a name="ln1159">      // Let the compiler synthesize the copy and assignment</a>
<a name="ln1160">      // operator.  It always does a pretty good job.</a>
<a name="ln1161">      // complex&amp; operator=(const complex&amp;);</a>
<a name="ln1162"> </a>
<a name="ln1163">      template&lt;typename _Tp&gt;</a>
<a name="ln1164">        complex&amp;</a>
<a name="ln1165">        operator=(const complex&lt;_Tp&gt;&amp;  __z)</a>
<a name="ln1166">	{</a>
<a name="ln1167">	  __real__ _M_value = __z.real();</a>
<a name="ln1168">	  __imag__ _M_value = __z.imag();</a>
<a name="ln1169">	  return *this;</a>
<a name="ln1170">	}</a>
<a name="ln1171"> </a>
<a name="ln1172">      template&lt;typename _Tp&gt;</a>
<a name="ln1173">        complex&amp;</a>
<a name="ln1174">        operator+=(const complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln1175">	{</a>
<a name="ln1176">	  __real__ _M_value += __z.real();</a>
<a name="ln1177">	  __imag__ _M_value += __z.imag();</a>
<a name="ln1178">	  return *this;</a>
<a name="ln1179">	}</a>
<a name="ln1180"> </a>
<a name="ln1181">      template&lt;class _Tp&gt;</a>
<a name="ln1182">        complex&amp;</a>
<a name="ln1183">        operator-=(const complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln1184">	{</a>
<a name="ln1185">	  __real__ _M_value -= __z.real();</a>
<a name="ln1186">	  __imag__ _M_value -= __z.imag();</a>
<a name="ln1187">	  return *this;</a>
<a name="ln1188">	}</a>
<a name="ln1189"> </a>
<a name="ln1190">      template&lt;class _Tp&gt;</a>
<a name="ln1191">        complex&amp;</a>
<a name="ln1192">        operator*=(const complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln1193">	{</a>
<a name="ln1194">	  _ComplexT __t;</a>
<a name="ln1195">	  __real__ __t = __z.real();</a>
<a name="ln1196">	  __imag__ __t = __z.imag();</a>
<a name="ln1197">	  _M_value *= __t;</a>
<a name="ln1198">	  return *this;</a>
<a name="ln1199">	}</a>
<a name="ln1200"> </a>
<a name="ln1201">      template&lt;class _Tp&gt;</a>
<a name="ln1202">        complex&amp;</a>
<a name="ln1203">        operator/=(const complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln1204">	{</a>
<a name="ln1205">	  _ComplexT __t;</a>
<a name="ln1206">	  __real__ __t = __z.real();</a>
<a name="ln1207">	  __imag__ __t = __z.imag();</a>
<a name="ln1208">	  _M_value /= __t;</a>
<a name="ln1209">	  return *this;</a>
<a name="ln1210">	}</a>
<a name="ln1211"> </a>
<a name="ln1212">      _GLIBCXX_CONSTEXPR _ComplexT __rep() const { return _M_value; }</a>
<a name="ln1213"> </a>
<a name="ln1214">    private:</a>
<a name="ln1215">      _ComplexT _M_value;</a>
<a name="ln1216">    };</a>
<a name="ln1217"> </a>
<a name="ln1218">  /// 26.2.3  complex specializations</a>
<a name="ln1219">  /// complex&lt;double&gt; specialization</a>
<a name="ln1220">  template&lt;&gt;</a>
<a name="ln1221">    struct complex&lt;double&gt;</a>
<a name="ln1222">    {</a>
<a name="ln1223">      typedef double value_type;</a>
<a name="ln1224">      typedef __complex__ double _ComplexT;</a>
<a name="ln1225"> </a>
<a name="ln1226">      _GLIBCXX_CONSTEXPR complex(_ComplexT __z) : _M_value(__z) { }</a>
<a name="ln1227"> </a>
<a name="ln1228">      _GLIBCXX_CONSTEXPR complex(double __r = 0.0, double __i = 0.0)</a>
<a name="ln1229">#if __cplusplus &gt;= 201103L</a>
<a name="ln1230">      : _M_value{ __r, __i } { }</a>
<a name="ln1231">#else</a>
<a name="ln1232">      {</a>
<a name="ln1233">	__real__ _M_value = __r;</a>
<a name="ln1234">	__imag__ _M_value = __i;</a>
<a name="ln1235">      }</a>
<a name="ln1236">#endif</a>
<a name="ln1237"> </a>
<a name="ln1238">      _GLIBCXX_CONSTEXPR complex(const complex&lt;float&gt;&amp; __z)</a>
<a name="ln1239">      : _M_value(__z.__rep()) { }</a>
<a name="ln1240"> </a>
<a name="ln1241">      explicit _GLIBCXX_CONSTEXPR complex(const complex&lt;long double&gt;&amp;);</a>
<a name="ln1242"> </a>
<a name="ln1243">#if __cplusplus &gt;= 201103L</a>
<a name="ln1244">      // _GLIBCXX_RESOLVE_LIB_DEFECTS</a>
<a name="ln1245">      // DR 387. std::complex over-encapsulated.</a>
<a name="ln1246">      __attribute ((__abi_tag__ (&quot;cxx11&quot;)))</a>
<a name="ln1247">      constexpr double</a>
<a name="ln1248">      real() const { return __real__ _M_value; }</a>
<a name="ln1249"> </a>
<a name="ln1250">      __attribute ((__abi_tag__ (&quot;cxx11&quot;)))</a>
<a name="ln1251">      constexpr double</a>
<a name="ln1252">      imag() const { return __imag__ _M_value; }</a>
<a name="ln1253">#else</a>
<a name="ln1254">      double&amp;</a>
<a name="ln1255">      real() { return __real__ _M_value; }</a>
<a name="ln1256"> </a>
<a name="ln1257">      const double&amp;</a>
<a name="ln1258">      real() const { return __real__ _M_value; }</a>
<a name="ln1259"> </a>
<a name="ln1260">      double&amp;</a>
<a name="ln1261">      imag() { return __imag__ _M_value; }</a>
<a name="ln1262"> </a>
<a name="ln1263">      const double&amp;</a>
<a name="ln1264">      imag() const { return __imag__ _M_value; }</a>
<a name="ln1265">#endif</a>
<a name="ln1266"> </a>
<a name="ln1267">      // _GLIBCXX_RESOLVE_LIB_DEFECTS</a>
<a name="ln1268">      // DR 387. std::complex over-encapsulated.</a>
<a name="ln1269">      void</a>
<a name="ln1270">      real(double __val) { __real__ _M_value = __val; }</a>
<a name="ln1271"> </a>
<a name="ln1272">      void</a>
<a name="ln1273">      imag(double __val) { __imag__ _M_value = __val; }</a>
<a name="ln1274"> </a>
<a name="ln1275">      complex&amp;</a>
<a name="ln1276">      operator=(double __d)</a>
<a name="ln1277">      {</a>
<a name="ln1278">	_M_value = __d;</a>
<a name="ln1279">	return *this;</a>
<a name="ln1280">      }</a>
<a name="ln1281"> </a>
<a name="ln1282">      complex&amp;</a>
<a name="ln1283">      operator+=(double __d)</a>
<a name="ln1284">      {</a>
<a name="ln1285">	_M_value += __d;</a>
<a name="ln1286">	return *this;</a>
<a name="ln1287">      }</a>
<a name="ln1288"> </a>
<a name="ln1289">      complex&amp;</a>
<a name="ln1290">      operator-=(double __d)</a>
<a name="ln1291">      {</a>
<a name="ln1292">	_M_value -= __d;</a>
<a name="ln1293">	return *this;</a>
<a name="ln1294">      }</a>
<a name="ln1295"> </a>
<a name="ln1296">      complex&amp;</a>
<a name="ln1297">      operator*=(double __d)</a>
<a name="ln1298">      {</a>
<a name="ln1299">	_M_value *= __d;</a>
<a name="ln1300">	return *this;</a>
<a name="ln1301">      }</a>
<a name="ln1302"> </a>
<a name="ln1303">      complex&amp;</a>
<a name="ln1304">      operator/=(double __d)</a>
<a name="ln1305">      {</a>
<a name="ln1306">	_M_value /= __d;</a>
<a name="ln1307">	return *this;</a>
<a name="ln1308">      }</a>
<a name="ln1309"> </a>
<a name="ln1310">      // The compiler will synthesize this, efficiently.</a>
<a name="ln1311">      // complex&amp; operator=(const complex&amp;);</a>
<a name="ln1312"> </a>
<a name="ln1313">      template&lt;typename _Tp&gt;</a>
<a name="ln1314">        complex&amp;</a>
<a name="ln1315">        operator=(const complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln1316">	{</a>
<a name="ln1317">	  __real__ _M_value = __z.real();</a>
<a name="ln1318">	  __imag__ _M_value = __z.imag();</a>
<a name="ln1319">	  return *this;</a>
<a name="ln1320">	}</a>
<a name="ln1321"> </a>
<a name="ln1322">      template&lt;typename _Tp&gt;</a>
<a name="ln1323">        complex&amp;</a>
<a name="ln1324">        operator+=(const complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln1325">	{</a>
<a name="ln1326">	  __real__ _M_value += __z.real();</a>
<a name="ln1327">	  __imag__ _M_value += __z.imag();</a>
<a name="ln1328">	  return *this;</a>
<a name="ln1329">	}</a>
<a name="ln1330"> </a>
<a name="ln1331">      template&lt;typename _Tp&gt;</a>
<a name="ln1332">        complex&amp;</a>
<a name="ln1333">        operator-=(const complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln1334">	{</a>
<a name="ln1335">	  __real__ _M_value -= __z.real();</a>
<a name="ln1336">	  __imag__ _M_value -= __z.imag();</a>
<a name="ln1337">	  return *this;</a>
<a name="ln1338">	}</a>
<a name="ln1339"> </a>
<a name="ln1340">      template&lt;typename _Tp&gt;</a>
<a name="ln1341">        complex&amp;</a>
<a name="ln1342">        operator*=(const complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln1343">	{</a>
<a name="ln1344">	  _ComplexT __t;</a>
<a name="ln1345">	  __real__ __t = __z.real();</a>
<a name="ln1346">	  __imag__ __t = __z.imag();</a>
<a name="ln1347">	  _M_value *= __t;</a>
<a name="ln1348">	  return *this;</a>
<a name="ln1349">	}</a>
<a name="ln1350"> </a>
<a name="ln1351">      template&lt;typename _Tp&gt;</a>
<a name="ln1352">        complex&amp;</a>
<a name="ln1353">        operator/=(const complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln1354">	{</a>
<a name="ln1355">	  _ComplexT __t;</a>
<a name="ln1356">	  __real__ __t = __z.real();</a>
<a name="ln1357">	  __imag__ __t = __z.imag();</a>
<a name="ln1358">	  _M_value /= __t;</a>
<a name="ln1359">	  return *this;</a>
<a name="ln1360">	}</a>
<a name="ln1361"> </a>
<a name="ln1362">      _GLIBCXX_CONSTEXPR _ComplexT __rep() const { return _M_value; }</a>
<a name="ln1363"> </a>
<a name="ln1364">    private:</a>
<a name="ln1365">      _ComplexT _M_value;</a>
<a name="ln1366">    };</a>
<a name="ln1367"> </a>
<a name="ln1368">  /// 26.2.3  complex specializations</a>
<a name="ln1369">  /// complex&lt;long double&gt; specialization</a>
<a name="ln1370">  template&lt;&gt;</a>
<a name="ln1371">    struct complex&lt;long double&gt;</a>
<a name="ln1372">    {</a>
<a name="ln1373">      typedef long double value_type;</a>
<a name="ln1374">      typedef __complex__ long double _ComplexT;</a>
<a name="ln1375"> </a>
<a name="ln1376">      _GLIBCXX_CONSTEXPR complex(_ComplexT __z) : _M_value(__z) { }</a>
<a name="ln1377"> </a>
<a name="ln1378">      _GLIBCXX_CONSTEXPR complex(long double __r = 0.0L,</a>
<a name="ln1379">				 long double __i = 0.0L)</a>
<a name="ln1380">#if __cplusplus &gt;= 201103L</a>
<a name="ln1381">      : _M_value{ __r, __i } { }</a>
<a name="ln1382">#else</a>
<a name="ln1383">      {</a>
<a name="ln1384">	__real__ _M_value = __r;</a>
<a name="ln1385">	__imag__ _M_value = __i;</a>
<a name="ln1386">      }</a>
<a name="ln1387">#endif</a>
<a name="ln1388"> </a>
<a name="ln1389">      _GLIBCXX_CONSTEXPR complex(const complex&lt;float&gt;&amp; __z)</a>
<a name="ln1390">      : _M_value(__z.__rep()) { }</a>
<a name="ln1391"> </a>
<a name="ln1392">      _GLIBCXX_CONSTEXPR complex(const complex&lt;double&gt;&amp; __z)</a>
<a name="ln1393">      : _M_value(__z.__rep()) { }</a>
<a name="ln1394"> </a>
<a name="ln1395">#if __cplusplus &gt;= 201103L</a>
<a name="ln1396">      // _GLIBCXX_RESOLVE_LIB_DEFECTS</a>
<a name="ln1397">      // DR 387. std::complex over-encapsulated.</a>
<a name="ln1398">      __attribute ((__abi_tag__ (&quot;cxx11&quot;)))</a>
<a name="ln1399">      constexpr long double</a>
<a name="ln1400">      real() const { return __real__ _M_value; }</a>
<a name="ln1401"> </a>
<a name="ln1402">      __attribute ((__abi_tag__ (&quot;cxx11&quot;)))</a>
<a name="ln1403">      constexpr long double</a>
<a name="ln1404">      imag() const { return __imag__ _M_value; }</a>
<a name="ln1405">#else</a>
<a name="ln1406">      long double&amp;</a>
<a name="ln1407">      real() { return __real__ _M_value; }</a>
<a name="ln1408"> </a>
<a name="ln1409">      const long double&amp;</a>
<a name="ln1410">      real() const { return __real__ _M_value; }</a>
<a name="ln1411"> </a>
<a name="ln1412">      long double&amp;</a>
<a name="ln1413">      imag() { return __imag__ _M_value; }</a>
<a name="ln1414"> </a>
<a name="ln1415">      const long double&amp;</a>
<a name="ln1416">      imag() const { return __imag__ _M_value; }</a>
<a name="ln1417">#endif</a>
<a name="ln1418"> </a>
<a name="ln1419">      // _GLIBCXX_RESOLVE_LIB_DEFECTS</a>
<a name="ln1420">      // DR 387. std::complex over-encapsulated.</a>
<a name="ln1421">      void</a>
<a name="ln1422">      real(long double __val) { __real__ _M_value = __val; }</a>
<a name="ln1423"> </a>
<a name="ln1424">      void</a>
<a name="ln1425">      imag(long double __val) { __imag__ _M_value = __val; }</a>
<a name="ln1426"> </a>
<a name="ln1427">      complex&amp;</a>
<a name="ln1428">      operator=(long double __r)</a>
<a name="ln1429">      {</a>
<a name="ln1430">	_M_value = __r;</a>
<a name="ln1431">	return *this;</a>
<a name="ln1432">      }</a>
<a name="ln1433"> </a>
<a name="ln1434">      complex&amp;</a>
<a name="ln1435">      operator+=(long double __r)</a>
<a name="ln1436">      {</a>
<a name="ln1437">	_M_value += __r;</a>
<a name="ln1438">	return *this;</a>
<a name="ln1439">      }</a>
<a name="ln1440"> </a>
<a name="ln1441">      complex&amp;</a>
<a name="ln1442">      operator-=(long double __r)</a>
<a name="ln1443">      {</a>
<a name="ln1444">	_M_value -= __r;</a>
<a name="ln1445">	return *this;</a>
<a name="ln1446">      }</a>
<a name="ln1447"> </a>
<a name="ln1448">      complex&amp;</a>
<a name="ln1449">      operator*=(long double __r)</a>
<a name="ln1450">      {</a>
<a name="ln1451">	_M_value *= __r;</a>
<a name="ln1452">	return *this;</a>
<a name="ln1453">      }</a>
<a name="ln1454"> </a>
<a name="ln1455">      complex&amp;</a>
<a name="ln1456">      operator/=(long double __r)</a>
<a name="ln1457">      {</a>
<a name="ln1458">	_M_value /= __r;</a>
<a name="ln1459">	return *this;</a>
<a name="ln1460">      }</a>
<a name="ln1461"> </a>
<a name="ln1462">      // The compiler knows how to do this efficiently</a>
<a name="ln1463">      // complex&amp; operator=(const complex&amp;);</a>
<a name="ln1464"> </a>
<a name="ln1465">      template&lt;typename _Tp&gt;</a>
<a name="ln1466">        complex&amp;</a>
<a name="ln1467">        operator=(const complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln1468">	{</a>
<a name="ln1469">	  __real__ _M_value = __z.real();</a>
<a name="ln1470">	  __imag__ _M_value = __z.imag();</a>
<a name="ln1471">	  return *this;</a>
<a name="ln1472">	}</a>
<a name="ln1473"> </a>
<a name="ln1474">      template&lt;typename _Tp&gt;</a>
<a name="ln1475">        complex&amp;</a>
<a name="ln1476">	operator+=(const complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln1477">	{</a>
<a name="ln1478">	  __real__ _M_value += __z.real();</a>
<a name="ln1479">	  __imag__ _M_value += __z.imag();</a>
<a name="ln1480">	  return *this;</a>
<a name="ln1481">	}</a>
<a name="ln1482"> </a>
<a name="ln1483">      template&lt;typename _Tp&gt;</a>
<a name="ln1484">        complex&amp;</a>
<a name="ln1485">	operator-=(const complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln1486">	{</a>
<a name="ln1487">	  __real__ _M_value -= __z.real();</a>
<a name="ln1488">	  __imag__ _M_value -= __z.imag();</a>
<a name="ln1489">	  return *this;</a>
<a name="ln1490">	}</a>
<a name="ln1491"> </a>
<a name="ln1492">      template&lt;typename _Tp&gt;</a>
<a name="ln1493">        complex&amp;</a>
<a name="ln1494">	operator*=(const complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln1495">	{</a>
<a name="ln1496">	  _ComplexT __t;</a>
<a name="ln1497">	  __real__ __t = __z.real();</a>
<a name="ln1498">	  __imag__ __t = __z.imag();</a>
<a name="ln1499">	  _M_value *= __t;</a>
<a name="ln1500">	  return *this;</a>
<a name="ln1501">	}</a>
<a name="ln1502"> </a>
<a name="ln1503">      template&lt;typename _Tp&gt;</a>
<a name="ln1504">        complex&amp;</a>
<a name="ln1505">	operator/=(const complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln1506">	{</a>
<a name="ln1507">	  _ComplexT __t;</a>
<a name="ln1508">	  __real__ __t = __z.real();</a>
<a name="ln1509">	  __imag__ __t = __z.imag();</a>
<a name="ln1510">	  _M_value /= __t;</a>
<a name="ln1511">	  return *this;</a>
<a name="ln1512">	}</a>
<a name="ln1513"> </a>
<a name="ln1514">      _GLIBCXX_CONSTEXPR _ComplexT __rep() const { return _M_value; }</a>
<a name="ln1515"> </a>
<a name="ln1516">    private:</a>
<a name="ln1517">      _ComplexT _M_value;</a>
<a name="ln1518">    };</a>
<a name="ln1519"> </a>
<a name="ln1520">  // These bits have to be at the end of this file, so that the</a>
<a name="ln1521">  // specializations have all been defined.</a>
<a name="ln1522">  inline _GLIBCXX_CONSTEXPR</a>
<a name="ln1523">  complex&lt;float&gt;::complex(const complex&lt;double&gt;&amp; __z)</a>
<a name="ln1524">  : _M_value(__z.__rep()) { }</a>
<a name="ln1525"> </a>
<a name="ln1526">  inline _GLIBCXX_CONSTEXPR</a>
<a name="ln1527">  complex&lt;float&gt;::complex(const complex&lt;long double&gt;&amp; __z)</a>
<a name="ln1528">  : _M_value(__z.__rep()) { }</a>
<a name="ln1529"> </a>
<a name="ln1530">  inline _GLIBCXX_CONSTEXPR</a>
<a name="ln1531">  complex&lt;double&gt;::complex(const complex&lt;long double&gt;&amp; __z)</a>
<a name="ln1532">  : _M_value(__z.__rep()) { }</a>
<a name="ln1533"> </a>
<a name="ln1534">  // Inhibit implicit instantiations for required instantiations,</a>
<a name="ln1535">  // which are defined via explicit instantiations elsewhere.</a>
<a name="ln1536">  // NB:  This syntax is a GNU extension.</a>
<a name="ln1537">#if _GLIBCXX_EXTERN_TEMPLATE</a>
<a name="ln1538">  extern template istream&amp; operator&gt;&gt;(istream&amp;, complex&lt;float&gt;&amp;);</a>
<a name="ln1539">  extern template ostream&amp; operator&lt;&lt;(ostream&amp;, const complex&lt;float&gt;&amp;);</a>
<a name="ln1540">  extern template istream&amp; operator&gt;&gt;(istream&amp;, complex&lt;double&gt;&amp;);</a>
<a name="ln1541">  extern template ostream&amp; operator&lt;&lt;(ostream&amp;, const complex&lt;double&gt;&amp;);</a>
<a name="ln1542">  extern template istream&amp; operator&gt;&gt;(istream&amp;, complex&lt;long double&gt;&amp;);</a>
<a name="ln1543">  extern template ostream&amp; operator&lt;&lt;(ostream&amp;, const complex&lt;long double&gt;&amp;);</a>
<a name="ln1544"> </a>
<a name="ln1545">#ifdef _GLIBCXX_USE_WCHAR_T</a>
<a name="ln1546">  extern template wistream&amp; operator&gt;&gt;(wistream&amp;, complex&lt;float&gt;&amp;);</a>
<a name="ln1547">  extern template wostream&amp; operator&lt;&lt;(wostream&amp;, const complex&lt;float&gt;&amp;);</a>
<a name="ln1548">  extern template wistream&amp; operator&gt;&gt;(wistream&amp;, complex&lt;double&gt;&amp;);</a>
<a name="ln1549">  extern template wostream&amp; operator&lt;&lt;(wostream&amp;, const complex&lt;double&gt;&amp;);</a>
<a name="ln1550">  extern template wistream&amp; operator&gt;&gt;(wistream&amp;, complex&lt;long double&gt;&amp;);</a>
<a name="ln1551">  extern template wostream&amp; operator&lt;&lt;(wostream&amp;, const complex&lt;long double&gt;&amp;);</a>
<a name="ln1552">#endif</a>
<a name="ln1553">#endif</a>
<a name="ln1554"> </a>
<a name="ln1555">  // @} group complex_numbers</a>
<a name="ln1556"> </a>
<a name="ln1557">_GLIBCXX_END_NAMESPACE_VERSION</a>
<a name="ln1558">} // namespace</a>
<a name="ln1559"> </a>
<a name="ln1560">namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)</a>
<a name="ln1561">{</a>
<a name="ln1562">_GLIBCXX_BEGIN_NAMESPACE_VERSION</a>
<a name="ln1563"> </a>
<a name="ln1564">  // See ext/type_traits.h for the primary template.</a>
<a name="ln1565">  template&lt;typename _Tp, typename _Up&gt;</a>
<a name="ln1566">    struct __promote_2&lt;std::complex&lt;_Tp&gt;, _Up&gt;</a>
<a name="ln1567">    {</a>
<a name="ln1568">    public:</a>
<a name="ln1569">      typedef std::complex&lt;typename __promote_2&lt;_Tp, _Up&gt;::__type&gt; __type;</a>
<a name="ln1570">    };</a>
<a name="ln1571"> </a>
<a name="ln1572">  template&lt;typename _Tp, typename _Up&gt;</a>
<a name="ln1573">    struct __promote_2&lt;_Tp, std::complex&lt;_Up&gt; &gt;</a>
<a name="ln1574">    {</a>
<a name="ln1575">    public:</a>
<a name="ln1576">      typedef std::complex&lt;typename __promote_2&lt;_Tp, _Up&gt;::__type&gt; __type;</a>
<a name="ln1577">    };</a>
<a name="ln1578"> </a>
<a name="ln1579">  template&lt;typename _Tp, typename _Up&gt;</a>
<a name="ln1580">    struct __promote_2&lt;std::complex&lt;_Tp&gt;, std::complex&lt;_Up&gt; &gt;</a>
<a name="ln1581">    {</a>
<a name="ln1582">    public:</a>
<a name="ln1583">      typedef std::complex&lt;typename __promote_2&lt;_Tp, _Up&gt;::__type&gt; __type;</a>
<a name="ln1584">    };</a>
<a name="ln1585"> </a>
<a name="ln1586">_GLIBCXX_END_NAMESPACE_VERSION</a>
<a name="ln1587">} // namespace</a>
<a name="ln1588"> </a>
<a name="ln1589">#if __cplusplus &gt;= 201103L</a>
<a name="ln1590"> </a>
<a name="ln1591">namespace std _GLIBCXX_VISIBILITY(default)</a>
<a name="ln1592">{</a>
<a name="ln1593">_GLIBCXX_BEGIN_NAMESPACE_VERSION</a>
<a name="ln1594"> </a>
<a name="ln1595">  // Forward declarations.</a>
<a name="ln1596">  template&lt;typename _Tp&gt; std::complex&lt;_Tp&gt; acos(const std::complex&lt;_Tp&gt;&amp;);</a>
<a name="ln1597">  template&lt;typename _Tp&gt; std::complex&lt;_Tp&gt; asin(const std::complex&lt;_Tp&gt;&amp;);</a>
<a name="ln1598">  template&lt;typename _Tp&gt; std::complex&lt;_Tp&gt; atan(const std::complex&lt;_Tp&gt;&amp;);</a>
<a name="ln1599"> </a>
<a name="ln1600">  template&lt;typename _Tp&gt; std::complex&lt;_Tp&gt; acosh(const std::complex&lt;_Tp&gt;&amp;);</a>
<a name="ln1601">  template&lt;typename _Tp&gt; std::complex&lt;_Tp&gt; asinh(const std::complex&lt;_Tp&gt;&amp;);</a>
<a name="ln1602">  template&lt;typename _Tp&gt; std::complex&lt;_Tp&gt; atanh(const std::complex&lt;_Tp&gt;&amp;);</a>
<a name="ln1603">  // DR 595.</a>
<a name="ln1604">  template&lt;typename _Tp&gt; _Tp               fabs(const std::complex&lt;_Tp&gt;&amp;);</a>
<a name="ln1605"> </a>
<a name="ln1606">  template&lt;typename _Tp&gt;</a>
<a name="ln1607">    inline std::complex&lt;_Tp&gt;</a>
<a name="ln1608">    __complex_acos(const std::complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln1609">    {</a>
<a name="ln1610">      const std::complex&lt;_Tp&gt; __t = std::asin(__z);</a>
<a name="ln1611">      const _Tp __pi_2 = 1.5707963267948966192313216916397514L;</a>
<a name="ln1612">      return std::complex&lt;_Tp&gt;(__pi_2 - __t.real(), -__t.imag());</a>
<a name="ln1613">    }</a>
<a name="ln1614"> </a>
<a name="ln1615">#if _GLIBCXX_USE_C99_COMPLEX_TR1</a>
<a name="ln1616">  inline __complex__ float</a>
<a name="ln1617">  __complex_acos(__complex__ float __z)</a>
<a name="ln1618">  { return __builtin_cacosf(__z); }</a>
<a name="ln1619"> </a>
<a name="ln1620">  inline __complex__ double</a>
<a name="ln1621">  __complex_acos(__complex__ double __z)</a>
<a name="ln1622">  { return __builtin_cacos(__z); }</a>
<a name="ln1623"> </a>
<a name="ln1624">  inline __complex__ long double</a>
<a name="ln1625">  __complex_acos(const __complex__ long double&amp; __z)</a>
<a name="ln1626">  { return __builtin_cacosl(__z); }</a>
<a name="ln1627"> </a>
<a name="ln1628">  template&lt;typename _Tp&gt;</a>
<a name="ln1629">    inline std::complex&lt;_Tp&gt;</a>
<a name="ln1630">    acos(const std::complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln1631">    { return __complex_acos(__z.__rep()); }</a>
<a name="ln1632">#else</a>
<a name="ln1633">  /// acos(__z) [8.1.2].</a>
<a name="ln1634">  //  Effects:  Behaves the same as C99 function cacos, defined</a>
<a name="ln1635">  //            in subclause 7.3.5.1.</a>
<a name="ln1636">  template&lt;typename _Tp&gt;</a>
<a name="ln1637">    inline std::complex&lt;_Tp&gt;</a>
<a name="ln1638">    acos(const std::complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln1639">    { return __complex_acos(__z); }</a>
<a name="ln1640">#endif</a>
<a name="ln1641"> </a>
<a name="ln1642">  template&lt;typename _Tp&gt;</a>
<a name="ln1643">    inline std::complex&lt;_Tp&gt;</a>
<a name="ln1644">    __complex_asin(const std::complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln1645">    {</a>
<a name="ln1646">      std::complex&lt;_Tp&gt; __t(-__z.imag(), __z.real());</a>
<a name="ln1647">      __t = std::asinh(__t);</a>
<a name="ln1648">      return std::complex&lt;_Tp&gt;(__t.imag(), -__t.real());</a>
<a name="ln1649">    }</a>
<a name="ln1650"> </a>
<a name="ln1651">#if _GLIBCXX_USE_C99_COMPLEX_TR1</a>
<a name="ln1652">  inline __complex__ float</a>
<a name="ln1653">  __complex_asin(__complex__ float __z)</a>
<a name="ln1654">  { return __builtin_casinf(__z); }</a>
<a name="ln1655"> </a>
<a name="ln1656">  inline __complex__ double</a>
<a name="ln1657">  __complex_asin(__complex__ double __z)</a>
<a name="ln1658">  { return __builtin_casin(__z); }</a>
<a name="ln1659"> </a>
<a name="ln1660">  inline __complex__ long double</a>
<a name="ln1661">  __complex_asin(const __complex__ long double&amp; __z)</a>
<a name="ln1662">  { return __builtin_casinl(__z); }</a>
<a name="ln1663"> </a>
<a name="ln1664">  template&lt;typename _Tp&gt;</a>
<a name="ln1665">    inline std::complex&lt;_Tp&gt;</a>
<a name="ln1666">    asin(const std::complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln1667">    { return __complex_asin(__z.__rep()); }</a>
<a name="ln1668">#else</a>
<a name="ln1669">  /// asin(__z) [8.1.3].</a>
<a name="ln1670">  //  Effects:  Behaves the same as C99 function casin, defined</a>
<a name="ln1671">  //            in subclause 7.3.5.2.</a>
<a name="ln1672">  template&lt;typename _Tp&gt;</a>
<a name="ln1673">    inline std::complex&lt;_Tp&gt;</a>
<a name="ln1674">    asin(const std::complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln1675">    { return __complex_asin(__z); }</a>
<a name="ln1676">#endif</a>
<a name="ln1677"> </a>
<a name="ln1678">  template&lt;typename _Tp&gt;</a>
<a name="ln1679">    std::complex&lt;_Tp&gt;</a>
<a name="ln1680">    __complex_atan(const std::complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln1681">    {</a>
<a name="ln1682">      const _Tp __r2 = __z.real() * __z.real();</a>
<a name="ln1683">      const _Tp __x = _Tp(1.0) - __r2 - __z.imag() * __z.imag();</a>
<a name="ln1684"> </a>
<a name="ln1685">      _Tp __num = __z.imag() + _Tp(1.0);</a>
<a name="ln1686">      _Tp __den = __z.imag() - _Tp(1.0);</a>
<a name="ln1687"> </a>
<a name="ln1688">      __num = __r2 + __num * __num;</a>
<a name="ln1689">      __den = __r2 + __den * __den;</a>
<a name="ln1690"> </a>
<a name="ln1691">      return std::complex&lt;_Tp&gt;(_Tp(0.5) * atan2(_Tp(2.0) * __z.real(), __x),</a>
<a name="ln1692">			       _Tp(0.25) * log(__num / __den));</a>
<a name="ln1693">    }</a>
<a name="ln1694"> </a>
<a name="ln1695">#if _GLIBCXX_USE_C99_COMPLEX_TR1</a>
<a name="ln1696">  inline __complex__ float</a>
<a name="ln1697">  __complex_atan(__complex__ float __z)</a>
<a name="ln1698">  { return __builtin_catanf(__z); }</a>
<a name="ln1699"> </a>
<a name="ln1700">  inline __complex__ double</a>
<a name="ln1701">  __complex_atan(__complex__ double __z)</a>
<a name="ln1702">  { return __builtin_catan(__z); }</a>
<a name="ln1703"> </a>
<a name="ln1704">  inline __complex__ long double</a>
<a name="ln1705">  __complex_atan(const __complex__ long double&amp; __z)</a>
<a name="ln1706">  { return __builtin_catanl(__z); }</a>
<a name="ln1707"> </a>
<a name="ln1708">  template&lt;typename _Tp&gt;</a>
<a name="ln1709">    inline std::complex&lt;_Tp&gt;</a>
<a name="ln1710">    atan(const std::complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln1711">    { return __complex_atan(__z.__rep()); }</a>
<a name="ln1712">#else</a>
<a name="ln1713">  /// atan(__z) [8.1.4].</a>
<a name="ln1714">  //  Effects:  Behaves the same as C99 function catan, defined</a>
<a name="ln1715">  //            in subclause 7.3.5.3.</a>
<a name="ln1716">  template&lt;typename _Tp&gt;</a>
<a name="ln1717">    inline std::complex&lt;_Tp&gt;</a>
<a name="ln1718">    atan(const std::complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln1719">    { return __complex_atan(__z); }</a>
<a name="ln1720">#endif</a>
<a name="ln1721"> </a>
<a name="ln1722">  template&lt;typename _Tp&gt;</a>
<a name="ln1723">    std::complex&lt;_Tp&gt;</a>
<a name="ln1724">    __complex_acosh(const std::complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln1725">    {</a>
<a name="ln1726">      // Kahan's formula.</a>
<a name="ln1727">      return _Tp(2.0) * std::log(std::sqrt(_Tp(0.5) * (__z + _Tp(1.0)))</a>
<a name="ln1728">				 + std::sqrt(_Tp(0.5) * (__z - _Tp(1.0))));</a>
<a name="ln1729">    }</a>
<a name="ln1730"> </a>
<a name="ln1731">#if _GLIBCXX_USE_C99_COMPLEX_TR1</a>
<a name="ln1732">  inline __complex__ float</a>
<a name="ln1733">  __complex_acosh(__complex__ float __z)</a>
<a name="ln1734">  { return __builtin_cacoshf(__z); }</a>
<a name="ln1735"> </a>
<a name="ln1736">  inline __complex__ double</a>
<a name="ln1737">  __complex_acosh(__complex__ double __z)</a>
<a name="ln1738">  { return __builtin_cacosh(__z); }</a>
<a name="ln1739"> </a>
<a name="ln1740">  inline __complex__ long double</a>
<a name="ln1741">  __complex_acosh(const __complex__ long double&amp; __z)</a>
<a name="ln1742">  { return __builtin_cacoshl(__z); }</a>
<a name="ln1743"> </a>
<a name="ln1744">  template&lt;typename _Tp&gt;</a>
<a name="ln1745">    inline std::complex&lt;_Tp&gt;</a>
<a name="ln1746">    acosh(const std::complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln1747">    { return __complex_acosh(__z.__rep()); }</a>
<a name="ln1748">#else</a>
<a name="ln1749">  /// acosh(__z) [8.1.5].</a>
<a name="ln1750">  //  Effects:  Behaves the same as C99 function cacosh, defined</a>
<a name="ln1751">  //            in subclause 7.3.6.1.</a>
<a name="ln1752">  template&lt;typename _Tp&gt;</a>
<a name="ln1753">    inline std::complex&lt;_Tp&gt;</a>
<a name="ln1754">    acosh(const std::complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln1755">    { return __complex_acosh(__z); }</a>
<a name="ln1756">#endif</a>
<a name="ln1757"> </a>
<a name="ln1758">  template&lt;typename _Tp&gt;</a>
<a name="ln1759">    std::complex&lt;_Tp&gt;</a>
<a name="ln1760">    __complex_asinh(const std::complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln1761">    {</a>
<a name="ln1762">      std::complex&lt;_Tp&gt; __t((__z.real() - __z.imag())</a>
<a name="ln1763">			    * (__z.real() + __z.imag()) + _Tp(1.0),</a>
<a name="ln1764">			    _Tp(2.0) * __z.real() * __z.imag());</a>
<a name="ln1765">      __t = std::sqrt(__t);</a>
<a name="ln1766"> </a>
<a name="ln1767">      return std::log(__t + __z);</a>
<a name="ln1768">    }</a>
<a name="ln1769"> </a>
<a name="ln1770">#if _GLIBCXX_USE_C99_COMPLEX_TR1</a>
<a name="ln1771">  inline __complex__ float</a>
<a name="ln1772">  __complex_asinh(__complex__ float __z)</a>
<a name="ln1773">  { return __builtin_casinhf(__z); }</a>
<a name="ln1774"> </a>
<a name="ln1775">  inline __complex__ double</a>
<a name="ln1776">  __complex_asinh(__complex__ double __z)</a>
<a name="ln1777">  { return __builtin_casinh(__z); }</a>
<a name="ln1778"> </a>
<a name="ln1779">  inline __complex__ long double</a>
<a name="ln1780">  __complex_asinh(const __complex__ long double&amp; __z)</a>
<a name="ln1781">  { return __builtin_casinhl(__z); }</a>
<a name="ln1782"> </a>
<a name="ln1783">  template&lt;typename _Tp&gt;</a>
<a name="ln1784">    inline std::complex&lt;_Tp&gt;</a>
<a name="ln1785">    asinh(const std::complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln1786">    { return __complex_asinh(__z.__rep()); }</a>
<a name="ln1787">#else</a>
<a name="ln1788">  /// asinh(__z) [8.1.6].</a>
<a name="ln1789">  //  Effects:  Behaves the same as C99 function casin, defined</a>
<a name="ln1790">  //            in subclause 7.3.6.2.</a>
<a name="ln1791">  template&lt;typename _Tp&gt;</a>
<a name="ln1792">    inline std::complex&lt;_Tp&gt;</a>
<a name="ln1793">    asinh(const std::complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln1794">    { return __complex_asinh(__z); }</a>
<a name="ln1795">#endif</a>
<a name="ln1796"> </a>
<a name="ln1797">  template&lt;typename _Tp&gt;</a>
<a name="ln1798">    std::complex&lt;_Tp&gt;</a>
<a name="ln1799">    __complex_atanh(const std::complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln1800">    {</a>
<a name="ln1801">      const _Tp __i2 = __z.imag() * __z.imag();</a>
<a name="ln1802">      const _Tp __x = _Tp(1.0) - __i2 - __z.real() * __z.real();</a>
<a name="ln1803"> </a>
<a name="ln1804">      _Tp __num = _Tp(1.0) + __z.real();</a>
<a name="ln1805">      _Tp __den = _Tp(1.0) - __z.real();</a>
<a name="ln1806"> </a>
<a name="ln1807">      __num = __i2 + __num * __num;</a>
<a name="ln1808">      __den = __i2 + __den * __den;</a>
<a name="ln1809"> </a>
<a name="ln1810">      return std::complex&lt;_Tp&gt;(_Tp(0.25) * (log(__num) - log(__den)),</a>
<a name="ln1811">			       _Tp(0.5) * atan2(_Tp(2.0) * __z.imag(), __x));</a>
<a name="ln1812">    }</a>
<a name="ln1813"> </a>
<a name="ln1814">#if _GLIBCXX_USE_C99_COMPLEX_TR1</a>
<a name="ln1815">  inline __complex__ float</a>
<a name="ln1816">  __complex_atanh(__complex__ float __z)</a>
<a name="ln1817">  { return __builtin_catanhf(__z); }</a>
<a name="ln1818"> </a>
<a name="ln1819">  inline __complex__ double</a>
<a name="ln1820">  __complex_atanh(__complex__ double __z)</a>
<a name="ln1821">  { return __builtin_catanh(__z); }</a>
<a name="ln1822"> </a>
<a name="ln1823">  inline __complex__ long double</a>
<a name="ln1824">  __complex_atanh(const __complex__ long double&amp; __z)</a>
<a name="ln1825">  { return __builtin_catanhl(__z); }</a>
<a name="ln1826"> </a>
<a name="ln1827">  template&lt;typename _Tp&gt;</a>
<a name="ln1828">    inline std::complex&lt;_Tp&gt;</a>
<a name="ln1829">    atanh(const std::complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln1830">    { return __complex_atanh(__z.__rep()); }</a>
<a name="ln1831">#else</a>
<a name="ln1832">  /// atanh(__z) [8.1.7].</a>
<a name="ln1833">  //  Effects:  Behaves the same as C99 function catanh, defined</a>
<a name="ln1834">  //            in subclause 7.3.6.3.</a>
<a name="ln1835">  template&lt;typename _Tp&gt;</a>
<a name="ln1836">    inline std::complex&lt;_Tp&gt;</a>
<a name="ln1837">    atanh(const std::complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln1838">    { return __complex_atanh(__z); }</a>
<a name="ln1839">#endif</a>
<a name="ln1840"> </a>
<a name="ln1841">  template&lt;typename _Tp&gt;</a>
<a name="ln1842">    inline _Tp</a>
<a name="ln1843">    /// fabs(__z) [8.1.8].</a>
<a name="ln1844">    //  Effects:  Behaves the same as C99 function cabs, defined</a>
<a name="ln1845">    //            in subclause 7.3.8.1.</a>
<a name="ln1846">    fabs(const std::complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln1847">    { return std::abs(__z); }</a>
<a name="ln1848"> </a>
<a name="ln1849">  /// Additional overloads [8.1.9].</a>
<a name="ln1850">  template&lt;typename _Tp&gt;</a>
<a name="ln1851">    inline typename __gnu_cxx::__promote&lt;_Tp&gt;::__type</a>
<a name="ln1852">    arg(_Tp __x)</a>
<a name="ln1853">    {</a>
<a name="ln1854">      typedef typename __gnu_cxx::__promote&lt;_Tp&gt;::__type __type;</a>
<a name="ln1855">#if (_GLIBCXX11_USE_C99_MATH &amp;&amp; !_GLIBCXX_USE_C99_FP_MACROS_DYNAMIC)</a>
<a name="ln1856">      return std::signbit(__x) ? __type(3.1415926535897932384626433832795029L)</a>
<a name="ln1857">	                       : __type();</a>
<a name="ln1858">#else</a>
<a name="ln1859">      return std::arg(std::complex&lt;__type&gt;(__x));</a>
<a name="ln1860">#endif</a>
<a name="ln1861">    }</a>
<a name="ln1862"> </a>
<a name="ln1863">  template&lt;typename _Tp&gt;</a>
<a name="ln1864">    _GLIBCXX_CONSTEXPR inline typename __gnu_cxx::__promote&lt;_Tp&gt;::__type</a>
<a name="ln1865">    imag(_Tp)</a>
<a name="ln1866">    { return _Tp(); }</a>
<a name="ln1867"> </a>
<a name="ln1868">  template&lt;typename _Tp&gt;</a>
<a name="ln1869">    inline typename __gnu_cxx::__promote&lt;_Tp&gt;::__type</a>
<a name="ln1870">    norm(_Tp __x)</a>
<a name="ln1871">    {</a>
<a name="ln1872">      typedef typename __gnu_cxx::__promote&lt;_Tp&gt;::__type __type;</a>
<a name="ln1873">      return __type(__x) * __type(__x);</a>
<a name="ln1874">    }</a>
<a name="ln1875"> </a>
<a name="ln1876">  template&lt;typename _Tp&gt;</a>
<a name="ln1877">    _GLIBCXX_CONSTEXPR inline typename __gnu_cxx::__promote&lt;_Tp&gt;::__type</a>
<a name="ln1878">    real(_Tp __x)</a>
<a name="ln1879">    { return __x; }</a>
<a name="ln1880"> </a>
<a name="ln1881">  template&lt;typename _Tp, typename _Up&gt;</a>
<a name="ln1882">    inline std::complex&lt;typename __gnu_cxx::__promote_2&lt;_Tp, _Up&gt;::__type&gt;</a>
<a name="ln1883">    pow(const std::complex&lt;_Tp&gt;&amp; __x, const _Up&amp; __y)</a>
<a name="ln1884">    {</a>
<a name="ln1885">      typedef typename __gnu_cxx::__promote_2&lt;_Tp, _Up&gt;::__type __type;</a>
<a name="ln1886">      return std::pow(std::complex&lt;__type&gt;(__x), __type(__y));</a>
<a name="ln1887">    }</a>
<a name="ln1888"> </a>
<a name="ln1889">  template&lt;typename _Tp, typename _Up&gt;</a>
<a name="ln1890">    inline std::complex&lt;typename __gnu_cxx::__promote_2&lt;_Tp, _Up&gt;::__type&gt;</a>
<a name="ln1891">    pow(const _Tp&amp; __x, const std::complex&lt;_Up&gt;&amp; __y)</a>
<a name="ln1892">    {</a>
<a name="ln1893">      typedef typename __gnu_cxx::__promote_2&lt;_Tp, _Up&gt;::__type __type;</a>
<a name="ln1894">      return std::pow(__type(__x), std::complex&lt;__type&gt;(__y));</a>
<a name="ln1895">    }</a>
<a name="ln1896"> </a>
<a name="ln1897">  template&lt;typename _Tp, typename _Up&gt;</a>
<a name="ln1898">    inline std::complex&lt;typename __gnu_cxx::__promote_2&lt;_Tp, _Up&gt;::__type&gt;</a>
<a name="ln1899">    pow(const std::complex&lt;_Tp&gt;&amp; __x, const std::complex&lt;_Up&gt;&amp; __y)</a>
<a name="ln1900">    {</a>
<a name="ln1901">      typedef typename __gnu_cxx::__promote_2&lt;_Tp, _Up&gt;::__type __type;</a>
<a name="ln1902">      return std::pow(std::complex&lt;__type&gt;(__x),</a>
<a name="ln1903">		      std::complex&lt;__type&gt;(__y));</a>
<a name="ln1904">    }</a>
<a name="ln1905"> </a>
<a name="ln1906">  // Forward declarations.</a>
<a name="ln1907">  // DR 781.</a>
<a name="ln1908">  template&lt;typename _Tp&gt; std::complex&lt;_Tp&gt; proj(const std::complex&lt;_Tp&gt;&amp;);</a>
<a name="ln1909"> </a>
<a name="ln1910">  template&lt;typename _Tp&gt;</a>
<a name="ln1911">    std::complex&lt;_Tp&gt;</a>
<a name="ln1912">    __complex_proj(const std::complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln1913">    {</a>
<a name="ln1914">      const _Tp __den = (__z.real() * __z.real()</a>
<a name="ln1915">			 + __z.imag() * __z.imag() + _Tp(1.0));</a>
<a name="ln1916"> </a>
<a name="ln1917">      return std::complex&lt;_Tp&gt;((_Tp(2.0) * __z.real()) / __den,</a>
<a name="ln1918">			       (_Tp(2.0) * __z.imag()) / __den);</a>
<a name="ln1919">    }</a>
<a name="ln1920"> </a>
<a name="ln1921">#if _GLIBCXX_USE_C99_COMPLEX</a>
<a name="ln1922">  inline __complex__ float</a>
<a name="ln1923">  __complex_proj(__complex__ float __z)</a>
<a name="ln1924">  { return __builtin_cprojf(__z); }</a>
<a name="ln1925"> </a>
<a name="ln1926">  inline __complex__ double</a>
<a name="ln1927">  __complex_proj(__complex__ double __z)</a>
<a name="ln1928">  { return __builtin_cproj(__z); }</a>
<a name="ln1929"> </a>
<a name="ln1930">  inline __complex__ long double</a>
<a name="ln1931">  __complex_proj(const __complex__ long double&amp; __z)</a>
<a name="ln1932">  { return __builtin_cprojl(__z); }</a>
<a name="ln1933"> </a>
<a name="ln1934">  template&lt;typename _Tp&gt;</a>
<a name="ln1935">    inline std::complex&lt;_Tp&gt;</a>
<a name="ln1936">    proj(const std::complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln1937">    { return __complex_proj(__z.__rep()); }</a>
<a name="ln1938">#else</a>
<a name="ln1939">  template&lt;typename _Tp&gt;</a>
<a name="ln1940">    inline std::complex&lt;_Tp&gt;</a>
<a name="ln1941">    proj(const std::complex&lt;_Tp&gt;&amp; __z)</a>
<a name="ln1942">    { return __complex_proj(__z); }</a>
<a name="ln1943">#endif</a>
<a name="ln1944"> </a>
<a name="ln1945">  template&lt;typename _Tp&gt;</a>
<a name="ln1946">    inline std::complex&lt;typename __gnu_cxx::__promote&lt;_Tp&gt;::__type&gt;</a>
<a name="ln1947">    proj(_Tp __x)</a>
<a name="ln1948">    {</a>
<a name="ln1949">      typedef typename __gnu_cxx::__promote&lt;_Tp&gt;::__type __type;</a>
<a name="ln1950">      return std::proj(std::complex&lt;__type&gt;(__x));</a>
<a name="ln1951">    }</a>
<a name="ln1952"> </a>
<a name="ln1953">  template&lt;typename _Tp&gt;</a>
<a name="ln1954">    inline std::complex&lt;typename __gnu_cxx::__promote&lt;_Tp&gt;::__type&gt;</a>
<a name="ln1955">    conj(_Tp __x)</a>
<a name="ln1956">    {</a>
<a name="ln1957">      typedef typename __gnu_cxx::__promote&lt;_Tp&gt;::__type __type;</a>
<a name="ln1958">      return std::complex&lt;__type&gt;(__x, -__type());</a>
<a name="ln1959">    }</a>
<a name="ln1960"> </a>
<a name="ln1961">#if __cplusplus &gt; 201103L</a>
<a name="ln1962"> </a>
<a name="ln1963">inline namespace literals {</a>
<a name="ln1964">inline namespace complex_literals {</a>
<a name="ln1965">#pragma GCC diagnostic push</a>
<a name="ln1966">#pragma GCC diagnostic ignored &quot;-Wliteral-suffix&quot;</a>
<a name="ln1967">#define __cpp_lib_complex_udls 201309</a>
<a name="ln1968"> </a>
<a name="ln1969">  constexpr std::complex&lt;float&gt;</a>
<a name="ln1970">  operator&quot;&quot;if(long double __num)</a>
<a name="ln1971">  { return std::complex&lt;float&gt;{0.0F, static_cast&lt;float&gt;(__num)}; }</a>
<a name="ln1972"> </a>
<a name="ln1973">  constexpr std::complex&lt;float&gt;</a>
<a name="ln1974">  operator&quot;&quot;if(unsigned long long __num)</a>
<a name="ln1975">  { return std::complex&lt;float&gt;{0.0F, static_cast&lt;float&gt;(__num)}; }</a>
<a name="ln1976"> </a>
<a name="ln1977">  constexpr std::complex&lt;double&gt;</a>
<a name="ln1978">  operator&quot;&quot;i(long double __num)</a>
<a name="ln1979">  { return std::complex&lt;double&gt;{0.0, static_cast&lt;double&gt;(__num)}; }</a>
<a name="ln1980"> </a>
<a name="ln1981">  constexpr std::complex&lt;double&gt;</a>
<a name="ln1982">  operator&quot;&quot;i(unsigned long long __num)</a>
<a name="ln1983">  { return std::complex&lt;double&gt;{0.0, static_cast&lt;double&gt;(__num)}; }</a>
<a name="ln1984"> </a>
<a name="ln1985">  constexpr std::complex&lt;long double&gt;</a>
<a name="ln1986">  operator&quot;&quot;il(long double __num)</a>
<a name="ln1987">  { return std::complex&lt;long double&gt;{0.0L, __num}; }</a>
<a name="ln1988"> </a>
<a name="ln1989">  constexpr std::complex&lt;long double&gt;</a>
<a name="ln1990">  operator&quot;&quot;il(unsigned long long __num)</a>
<a name="ln1991">  { return std::complex&lt;long double&gt;{0.0L, static_cast&lt;long double&gt;(__num)}; }</a>
<a name="ln1992"> </a>
<a name="ln1993">#pragma GCC diagnostic pop</a>
<a name="ln1994">} // inline namespace complex_literals</a>
<a name="ln1995">} // inline namespace literals</a>
<a name="ln1996"> </a>
<a name="ln1997">#endif // C++14</a>
<a name="ln1998"> </a>
<a name="ln1999">_GLIBCXX_END_NAMESPACE_VERSION</a>
<a name="ln2000">} // namespace</a>
<a name="ln2001"> </a>
<a name="ln2002">#endif  // C++11</a>
<a name="ln2003"> </a>
<a name="ln2004">#endif  /* _GLIBCXX_COMPLEX */</a>

</code></pre>
<div class="balloon" rel="1168"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v519/" target="_blank">V519</a> The '_M_value' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 1167, 1168.</p></div>
<div class="balloon" rel="1196"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v519/" target="_blank">V519</a> The '__t' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 1195, 1196.</p></div>
<div class="balloon" rel="1207"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v519/" target="_blank">V519</a> The '__t' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 1206, 1207.</p></div>
<div class="balloon" rel="1318"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v519/" target="_blank">V519</a> The '_M_value' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 1317, 1318.</p></div>
<div class="balloon" rel="1346"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v519/" target="_blank">V519</a> The '__t' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 1345, 1346.</p></div>
<div class="balloon" rel="1357"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v519/" target="_blank">V519</a> The '__t' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 1356, 1357.</p></div>
<div class="balloon" rel="1470"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v519/" target="_blank">V519</a> The '_M_value' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 1469, 1470.</p></div>
<div class="balloon" rel="1498"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v519/" target="_blank">V519</a> The '__t' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 1497, 1498.</p></div>
<div class="balloon" rel="1509"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v519/" target="_blank">V519</a> The '__t' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 1508, 1509.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
