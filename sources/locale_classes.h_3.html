
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>locale_classes.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Locale support -*- C++ -*-</a>
<a name="ln2"> </a>
<a name="ln3">// Copyright (C) 1997-2018 Free Software Foundation, Inc.</a>
<a name="ln4">//</a>
<a name="ln5">// This file is part of the GNU ISO C++ Library.  This library is free</a>
<a name="ln6">// software; you can redistribute it and/or modify it under the</a>
<a name="ln7">// terms of the GNU General Public License as published by the</a>
<a name="ln8">// Free Software Foundation; either version 3, or (at your option)</a>
<a name="ln9">// any later version.</a>
<a name="ln10"> </a>
<a name="ln11">// This library is distributed in the hope that it will be useful,</a>
<a name="ln12">// but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">// GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">// Under Section 7 of GPL version 3, you are granted additional</a>
<a name="ln17">// permissions described in the GCC Runtime Library Exception, version</a>
<a name="ln18">// 3.1, as published by the Free Software Foundation.</a>
<a name="ln19"> </a>
<a name="ln20">// You should have received a copy of the GNU General Public License and</a>
<a name="ln21">// a copy of the GCC Runtime Library Exception along with this program;</a>
<a name="ln22">// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see</a>
<a name="ln23">// &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln24"> </a>
<a name="ln25">/** @file bits/locale_classes.h</a>
<a name="ln26"> *  This is an internal header file, included by other library headers.</a>
<a name="ln27"> *  Do not attempt to use it directly. @headername{locale}</a>
<a name="ln28"> */</a>
<a name="ln29"> </a>
<a name="ln30">//</a>
<a name="ln31">// ISO C++ 14882: 22.1  Locales</a>
<a name="ln32">//</a>
<a name="ln33"> </a>
<a name="ln34">#ifndef _LOCALE_CLASSES_H</a>
<a name="ln35">#define _LOCALE_CLASSES_H 1</a>
<a name="ln36"> </a>
<a name="ln37">#pragma GCC system_header</a>
<a name="ln38"> </a>
<a name="ln39">#include &lt;bits/localefwd.h&gt;</a>
<a name="ln40">#include &lt;string&gt;</a>
<a name="ln41">#include &lt;ext/atomicity.h&gt;</a>
<a name="ln42"> </a>
<a name="ln43">namespace std _GLIBCXX_VISIBILITY(default)</a>
<a name="ln44">{</a>
<a name="ln45">_GLIBCXX_BEGIN_NAMESPACE_VERSION</a>
<a name="ln46"> </a>
<a name="ln47">  // 22.1.1 Class locale</a>
<a name="ln48">  /**</a>
<a name="ln49">   *  @brief  Container class for localization functionality.</a>
<a name="ln50">   *  @ingroup locales</a>
<a name="ln51">   *</a>
<a name="ln52">   *  The locale class is first a class wrapper for C library locales.  It is</a>
<a name="ln53">   *  also an extensible container for user-defined localization.  A locale is</a>
<a name="ln54">   *  a collection of facets that implement various localization features such</a>
<a name="ln55">   *  as money, time, and number printing.</a>
<a name="ln56">   *</a>
<a name="ln57">   *  Constructing C++ locales does not change the C library locale.</a>
<a name="ln58">   *</a>
<a name="ln59">   *  This library supports efficient construction and copying of locales</a>
<a name="ln60">   *  through a reference counting implementation of the locale class.</a>
<a name="ln61">  */</a>
<a name="ln62">  class locale</a>
<a name="ln63">  {</a>
<a name="ln64">  public:</a>
<a name="ln65">    // Types:</a>
<a name="ln66">    /// Definition of locale::category.</a>
<a name="ln67">    typedef int	category;</a>
<a name="ln68"> </a>
<a name="ln69">    // Forward decls and friends:</a>
<a name="ln70">    class facet;</a>
<a name="ln71">    class id;</a>
<a name="ln72">    class _Impl;</a>
<a name="ln73"> </a>
<a name="ln74">    friend class facet;</a>
<a name="ln75">    friend class _Impl;</a>
<a name="ln76"> </a>
<a name="ln77">    template&lt;typename _Facet&gt;</a>
<a name="ln78">      friend bool</a>
<a name="ln79">      has_facet(const locale&amp;) throw();</a>
<a name="ln80"> </a>
<a name="ln81">    template&lt;typename _Facet&gt;</a>
<a name="ln82">      friend const _Facet&amp;</a>
<a name="ln83">      use_facet(const locale&amp;);</a>
<a name="ln84"> </a>
<a name="ln85">    template&lt;typename _Cache&gt;</a>
<a name="ln86">      friend struct __use_cache;</a>
<a name="ln87"> </a>
<a name="ln88">    //@{</a>
<a name="ln89">    /**</a>
<a name="ln90">     *  @brief  Category values.</a>
<a name="ln91">     *</a>
<a name="ln92">     *  The standard category values are none, ctype, numeric, collate, time,</a>
<a name="ln93">     *  monetary, and messages.  They form a bitmask that supports union and</a>
<a name="ln94">     *  intersection.  The category all is the union of these values.</a>
<a name="ln95">     *</a>
<a name="ln96">     *  NB: Order must match _S_facet_categories definition in locale.cc</a>
<a name="ln97">    */</a>
<a name="ln98">    static const category none		= 0;</a>
<a name="ln99">    static const category ctype		= 1L &lt;&lt; 0;</a>
<a name="ln100">    static const category numeric	= 1L &lt;&lt; 1;</a>
<a name="ln101">    static const category collate	= 1L &lt;&lt; 2;</a>
<a name="ln102">    static const category time		= 1L &lt;&lt; 3;</a>
<a name="ln103">    static const category monetary	= 1L &lt;&lt; 4;</a>
<a name="ln104">    static const category messages	= 1L &lt;&lt; 5;</a>
<a name="ln105">    static const category all		= (ctype | numeric | collate |</a>
<a name="ln106">					   time  | monetary | messages);</a>
<a name="ln107">    //@}</a>
<a name="ln108"> </a>
<a name="ln109">    // Construct/copy/destroy:</a>
<a name="ln110"> </a>
<a name="ln111">    /**</a>
<a name="ln112">     *  @brief  Default constructor.</a>
<a name="ln113">     *</a>
<a name="ln114">     *  Constructs a copy of the global locale.  If no locale has been</a>
<a name="ln115">     *  explicitly set, this is the C locale.</a>
<a name="ln116">    */</a>
<a name="ln117">    locale() throw();</a>
<a name="ln118"> </a>
<a name="ln119">    /**</a>
<a name="ln120">     *  @brief  Copy constructor.</a>
<a name="ln121">     *</a>
<a name="ln122">     *  Constructs a copy of @a other.</a>
<a name="ln123">     *</a>
<a name="ln124">     *  @param  __other  The locale to copy.</a>
<a name="ln125">    */</a>
<a name="ln126">    locale(const locale&amp; __other) throw();</a>
<a name="ln127"> </a>
<a name="ln128">    /**</a>
<a name="ln129">     *  @brief  Named locale constructor.</a>
<a name="ln130">     *</a>
<a name="ln131">     *  Constructs a copy of the named C library locale.</a>
<a name="ln132">     *</a>
<a name="ln133">     *  @param  __s  Name of the locale to construct.</a>
<a name="ln134">     *  @throw  std::runtime_error if __s is null or an undefined locale.</a>
<a name="ln135">    */</a>
<a name="ln136">    explicit</a>
<a name="ln137">    locale(const char* __s);</a>
<a name="ln138"> </a>
<a name="ln139">    /**</a>
<a name="ln140">     *  @brief  Construct locale with facets from another locale.</a>
<a name="ln141">     *</a>
<a name="ln142">     *  Constructs a copy of the locale @a base.  The facets specified by @a</a>
<a name="ln143">     *  cat are replaced with those from the locale named by @a s.  If base is</a>
<a name="ln144">     *  named, this locale instance will also be named.</a>
<a name="ln145">     *</a>
<a name="ln146">     *  @param  __base  The locale to copy.</a>
<a name="ln147">     *  @param  __s  Name of the locale to use facets from.</a>
<a name="ln148">     *  @param  __cat  Set of categories defining the facets to use from __s.</a>
<a name="ln149">     *  @throw  std::runtime_error if __s is null or an undefined locale.</a>
<a name="ln150">    */</a>
<a name="ln151">    locale(const locale&amp; __base, const char* __s, category __cat);</a>
<a name="ln152"> </a>
<a name="ln153">#if __cplusplus &gt;= 201103L</a>
<a name="ln154">    /**</a>
<a name="ln155">     *  @brief  Named locale constructor.</a>
<a name="ln156">     *</a>
<a name="ln157">     *  Constructs a copy of the named C library locale.</a>
<a name="ln158">     *</a>
<a name="ln159">     *  @param  __s  Name of the locale to construct.</a>
<a name="ln160">     *  @throw  std::runtime_error if __s is an undefined locale.</a>
<a name="ln161">    */</a>
<a name="ln162">    explicit</a>
<a name="ln163">    locale(const std::string&amp; __s) : locale(__s.c_str()) { }</a>
<a name="ln164"> </a>
<a name="ln165">    /**</a>
<a name="ln166">     *  @brief  Construct locale with facets from another locale.</a>
<a name="ln167">     *</a>
<a name="ln168">     *  Constructs a copy of the locale @a base.  The facets specified by @a</a>
<a name="ln169">     *  cat are replaced with those from the locale named by @a s.  If base is</a>
<a name="ln170">     *  named, this locale instance will also be named.</a>
<a name="ln171">     *</a>
<a name="ln172">     *  @param  __base  The locale to copy.</a>
<a name="ln173">     *  @param  __s  Name of the locale to use facets from.</a>
<a name="ln174">     *  @param  __cat  Set of categories defining the facets to use from __s.</a>
<a name="ln175">     *  @throw  std::runtime_error if __s is an undefined locale.</a>
<a name="ln176">    */</a>
<a name="ln177">    locale(const locale&amp; __base, const std::string&amp; __s, category __cat)</a>
<a name="ln178">    : locale(__base, __s.c_str(), __cat) { }</a>
<a name="ln179">#endif</a>
<a name="ln180"> </a>
<a name="ln181">    /**</a>
<a name="ln182">     *  @brief  Construct locale with facets from another locale.</a>
<a name="ln183">     *</a>
<a name="ln184">     *  Constructs a copy of the locale @a base.  The facets specified by @a</a>
<a name="ln185">     *  cat are replaced with those from the locale @a add.  If @a base and @a</a>
<a name="ln186">     *  add are named, this locale instance will also be named.</a>
<a name="ln187">     *</a>
<a name="ln188">     *  @param  __base  The locale to copy.</a>
<a name="ln189">     *  @param  __add  The locale to use facets from.</a>
<a name="ln190">     *  @param  __cat  Set of categories defining the facets to use from add.</a>
<a name="ln191">    */</a>
<a name="ln192">    locale(const locale&amp; __base, const locale&amp; __add, category __cat);</a>
<a name="ln193"> </a>
<a name="ln194">    /**</a>
<a name="ln195">     *  @brief  Construct locale with another facet.</a>
<a name="ln196">     *</a>
<a name="ln197">     *  Constructs a copy of the locale @a __other.  The facet @a __f</a>
<a name="ln198">     *  is added to @a __other, replacing an existing facet of type</a>
<a name="ln199">     *  Facet if there is one.  If @a __f is null, this locale is a</a>
<a name="ln200">     *  copy of @a __other.</a>
<a name="ln201">     *</a>
<a name="ln202">     *  @param  __other  The locale to copy.</a>
<a name="ln203">     *  @param  __f  The facet to add in.</a>
<a name="ln204">    */</a>
<a name="ln205">    template&lt;typename _Facet&gt;</a>
<a name="ln206">      locale(const locale&amp; __other, _Facet* __f);</a>
<a name="ln207"> </a>
<a name="ln208">    /// Locale destructor.</a>
<a name="ln209">    ~locale() throw();</a>
<a name="ln210"> </a>
<a name="ln211">    /**</a>
<a name="ln212">     *  @brief  Assignment operator.</a>
<a name="ln213">     *</a>
<a name="ln214">     *  Set this locale to be a copy of @a other.</a>
<a name="ln215">     *</a>
<a name="ln216">     *  @param  __other  The locale to copy.</a>
<a name="ln217">     *  @return  A reference to this locale.</a>
<a name="ln218">    */</a>
<a name="ln219">    const locale&amp;</a>
<a name="ln220">    operator=(const locale&amp; __other) throw();</a>
<a name="ln221"> </a>
<a name="ln222">    /**</a>
<a name="ln223">     *  @brief  Construct locale with another facet.</a>
<a name="ln224">     *</a>
<a name="ln225">     *  Constructs and returns a new copy of this locale.  Adds or replaces an</a>
<a name="ln226">     *  existing facet of type Facet from the locale @a other into the new</a>
<a name="ln227">     *  locale.</a>
<a name="ln228">     *</a>
<a name="ln229">     *  @tparam  _Facet  The facet type to copy from other</a>
<a name="ln230">     *  @param  __other  The locale to copy from.</a>
<a name="ln231">     *  @return  Newly constructed locale.</a>
<a name="ln232">     *  @throw  std::runtime_error if __other has no facet of type _Facet.</a>
<a name="ln233">    */</a>
<a name="ln234">    template&lt;typename _Facet&gt;</a>
<a name="ln235">      locale</a>
<a name="ln236">      combine(const locale&amp; __other) const;</a>
<a name="ln237"> </a>
<a name="ln238">    // Locale operations:</a>
<a name="ln239">    /**</a>
<a name="ln240">     *  @brief  Return locale name.</a>
<a name="ln241">     *  @return  Locale name or &quot;*&quot; if unnamed.</a>
<a name="ln242">    */</a>
<a name="ln243">    _GLIBCXX_DEFAULT_ABI_TAG</a>
<a name="ln244">    string</a>
<a name="ln245">    name() const;</a>
<a name="ln246"> </a>
<a name="ln247">    /**</a>
<a name="ln248">     *  @brief  Locale equality.</a>
<a name="ln249">     *</a>
<a name="ln250">     *  @param  __other  The locale to compare against.</a>
<a name="ln251">     *  @return  True if other and this refer to the same locale instance, are</a>
<a name="ln252">     *		 copies, or have the same name.  False otherwise.</a>
<a name="ln253">    */</a>
<a name="ln254">    bool</a>
<a name="ln255">    operator==(const locale&amp; __other) const throw();</a>
<a name="ln256"> </a>
<a name="ln257">    /**</a>
<a name="ln258">     *  @brief  Locale inequality.</a>
<a name="ln259">     *</a>
<a name="ln260">     *  @param  __other  The locale to compare against.</a>
<a name="ln261">     *  @return  ! (*this == __other)</a>
<a name="ln262">    */</a>
<a name="ln263">    bool</a>
<a name="ln264">    operator!=(const locale&amp; __other) const throw()</a>
<a name="ln265">    { return !(this-&gt;operator==(__other)); }</a>
<a name="ln266"> </a>
<a name="ln267">    /**</a>
<a name="ln268">     *  @brief  Compare two strings according to collate.</a>
<a name="ln269">     *</a>
<a name="ln270">     *  Template operator to compare two strings using the compare function of</a>
<a name="ln271">     *  the collate facet in this locale.  One use is to provide the locale to</a>
<a name="ln272">     *  the sort function.  For example, a vector v of strings could be sorted</a>
<a name="ln273">     *  according to locale loc by doing:</a>
<a name="ln274">     *  @code</a>
<a name="ln275">     *  std::sort(v.begin(), v.end(), loc);</a>
<a name="ln276">     *  @endcode</a>
<a name="ln277">     *</a>
<a name="ln278">     *  @param  __s1  First string to compare.</a>
<a name="ln279">     *  @param  __s2  Second string to compare.</a>
<a name="ln280">     *  @return  True if collate&lt;_Char&gt; facet compares __s1 &lt; __s2, else false.</a>
<a name="ln281">    */</a>
<a name="ln282">    template&lt;typename _Char, typename _Traits, typename _Alloc&gt;</a>
<a name="ln283">      bool</a>
<a name="ln284">      operator()(const basic_string&lt;_Char, _Traits, _Alloc&gt;&amp; __s1,</a>
<a name="ln285">		 const basic_string&lt;_Char, _Traits, _Alloc&gt;&amp; __s2) const;</a>
<a name="ln286"> </a>
<a name="ln287">    // Global locale objects:</a>
<a name="ln288">    /**</a>
<a name="ln289">     *  @brief  Set global locale</a>
<a name="ln290">     *</a>
<a name="ln291">     *  This function sets the global locale to the argument and returns a</a>
<a name="ln292">     *  copy of the previous global locale.  If the argument has a name, it</a>
<a name="ln293">     *  will also call std::setlocale(LC_ALL, loc.name()).</a>
<a name="ln294">     *</a>
<a name="ln295">     *  @param  __loc  The new locale to make global.</a>
<a name="ln296">     *  @return  Copy of the old global locale.</a>
<a name="ln297">    */</a>
<a name="ln298">    static locale</a>
<a name="ln299">    global(const locale&amp; __loc);</a>
<a name="ln300"> </a>
<a name="ln301">    /**</a>
<a name="ln302">     *  @brief  Return reference to the C locale.</a>
<a name="ln303">    */</a>
<a name="ln304">    static const locale&amp;</a>
<a name="ln305">    classic();</a>
<a name="ln306"> </a>
<a name="ln307">  private:</a>
<a name="ln308">    // The (shared) implementation</a>
<a name="ln309">    _Impl*		_M_impl;</a>
<a name="ln310"> </a>
<a name="ln311">    // The &quot;C&quot; reference locale</a>
<a name="ln312">    static _Impl*       _S_classic;</a>
<a name="ln313"> </a>
<a name="ln314">    // Current global locale</a>
<a name="ln315">    static _Impl*	_S_global;</a>
<a name="ln316"> </a>
<a name="ln317">    // Names of underlying locale categories.</a>
<a name="ln318">    // NB: locale::global() has to know how to modify all the</a>
<a name="ln319">    // underlying categories, not just the ones required by the C++</a>
<a name="ln320">    // standard.</a>
<a name="ln321">    static const char* const* const _S_categories;</a>
<a name="ln322"> </a>
<a name="ln323">    // Number of standard categories. For C++, these categories are</a>
<a name="ln324">    // collate, ctype, monetary, numeric, time, and messages. These</a>
<a name="ln325">    // directly correspond to ISO C99 macros LC_COLLATE, LC_CTYPE,</a>
<a name="ln326">    // LC_MONETARY, LC_NUMERIC, and LC_TIME. In addition, POSIX (IEEE</a>
<a name="ln327">    // 1003.1-2001) specifies LC_MESSAGES.</a>
<a name="ln328">    // In addition to the standard categories, the underlying</a>
<a name="ln329">    // operating system is allowed to define extra LC_*</a>
<a name="ln330">    // macros. For GNU systems, the following are also valid:</a>
<a name="ln331">    // LC_PAPER, LC_NAME, LC_ADDRESS, LC_TELEPHONE, LC_MEASUREMENT,</a>
<a name="ln332">    // and LC_IDENTIFICATION.</a>
<a name="ln333">    enum { _S_categories_size = 6 + _GLIBCXX_NUM_CATEGORIES };</a>
<a name="ln334"> </a>
<a name="ln335">#ifdef __GTHREADS</a>
<a name="ln336">    static __gthread_once_t _S_once;</a>
<a name="ln337">#endif</a>
<a name="ln338"> </a>
<a name="ln339">    explicit</a>
<a name="ln340">    locale(_Impl*) throw();</a>
<a name="ln341"> </a>
<a name="ln342">    static void</a>
<a name="ln343">    _S_initialize();</a>
<a name="ln344"> </a>
<a name="ln345">    static void</a>
<a name="ln346">    _S_initialize_once() throw();</a>
<a name="ln347"> </a>
<a name="ln348">    static category</a>
<a name="ln349">    _S_normalize_category(category);</a>
<a name="ln350"> </a>
<a name="ln351">    void</a>
<a name="ln352">    _M_coalesce(const locale&amp; __base, const locale&amp; __add, category __cat);</a>
<a name="ln353"> </a>
<a name="ln354">#if _GLIBCXX_USE_CXX11_ABI</a>
<a name="ln355">    static const id* const _S_twinned_facets[];</a>
<a name="ln356">#endif</a>
<a name="ln357">  };</a>
<a name="ln358"> </a>
<a name="ln359"> </a>
<a name="ln360">  // 22.1.1.1.2  Class locale::facet</a>
<a name="ln361">  /**</a>
<a name="ln362">   *  @brief  Localization functionality base class.</a>
<a name="ln363">   *  @ingroup locales</a>
<a name="ln364">   *</a>
<a name="ln365">   *  The facet class is the base class for a localization feature, such as</a>
<a name="ln366">   *  money, time, and number printing.  It provides common support for facets</a>
<a name="ln367">   *  and reference management.</a>
<a name="ln368">   *</a>
<a name="ln369">   *  Facets may not be copied or assigned.</a>
<a name="ln370">  */</a>
<a name="ln371">  class locale::facet</a>
<a name="ln372">  {</a>
<a name="ln373">  private:</a>
<a name="ln374">    friend class locale;</a>
<a name="ln375">    friend class locale::_Impl;</a>
<a name="ln376"> </a>
<a name="ln377">    mutable _Atomic_word		_M_refcount;</a>
<a name="ln378"> </a>
<a name="ln379">    // Contains data from the underlying &quot;C&quot; library for the classic locale.</a>
<a name="ln380">    static __c_locale                   _S_c_locale;</a>
<a name="ln381"> </a>
<a name="ln382">    // String literal for the name of the classic locale.</a>
<a name="ln383">    static const char			_S_c_name[2];</a>
<a name="ln384"> </a>
<a name="ln385">#ifdef __GTHREADS</a>
<a name="ln386">    static __gthread_once_t		_S_once;</a>
<a name="ln387">#endif</a>
<a name="ln388"> </a>
<a name="ln389">    static void</a>
<a name="ln390">    _S_initialize_once();</a>
<a name="ln391"> </a>
<a name="ln392">  protected:</a>
<a name="ln393">    /**</a>
<a name="ln394">     *  @brief  Facet constructor.</a>
<a name="ln395">     *</a>
<a name="ln396">     *  This is the constructor provided by the standard.  If refs is 0, the</a>
<a name="ln397">     *  facet is destroyed when the last referencing locale is destroyed.</a>
<a name="ln398">     *  Otherwise the facet will never be destroyed.</a>
<a name="ln399">     *</a>
<a name="ln400">     *  @param __refs  The initial value for reference count.</a>
<a name="ln401">    */</a>
<a name="ln402">    explicit</a>
<a name="ln403">    facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)</a>
<a name="ln404">    { }</a>
<a name="ln405"> </a>
<a name="ln406">    /// Facet destructor.</a>
<a name="ln407">    virtual</a>
<a name="ln408">    ~facet();</a>
<a name="ln409"> </a>
<a name="ln410">    static void</a>
<a name="ln411">    _S_create_c_locale(__c_locale&amp; __cloc, const char* __s,</a>
<a name="ln412">		       __c_locale __old = 0);</a>
<a name="ln413"> </a>
<a name="ln414">    static __c_locale</a>
<a name="ln415">    _S_clone_c_locale(__c_locale&amp; __cloc) throw();</a>
<a name="ln416"> </a>
<a name="ln417">    static void</a>
<a name="ln418">    _S_destroy_c_locale(__c_locale&amp; __cloc);</a>
<a name="ln419"> </a>
<a name="ln420">    static __c_locale</a>
<a name="ln421">    _S_lc_ctype_c_locale(__c_locale __cloc, const char* __s);</a>
<a name="ln422"> </a>
<a name="ln423">    // Returns data from the underlying &quot;C&quot; library data for the</a>
<a name="ln424">    // classic locale.</a>
<a name="ln425">    static __c_locale</a>
<a name="ln426">    _S_get_c_locale();</a>
<a name="ln427"> </a>
<a name="ln428">    _GLIBCXX_CONST static const char*</a>
<a name="ln429">    _S_get_c_name() throw();</a>
<a name="ln430"> </a>
<a name="ln431">#if __cplusplus &lt; 201103L</a>
<a name="ln432">  private:</a>
<a name="ln433">    facet(const facet&amp;);  // Not defined.</a>
<a name="ln434"> </a>
<a name="ln435">    facet&amp;</a>
<a name="ln436">    operator=(const facet&amp;);  // Not defined.</a>
<a name="ln437">#else</a>
<a name="ln438">    facet(const facet&amp;) = delete;</a>
<a name="ln439"> </a>
<a name="ln440">    facet&amp;</a>
<a name="ln441">    operator=(const facet&amp;) = delete;</a>
<a name="ln442">#endif</a>
<a name="ln443"> </a>
<a name="ln444">  private:</a>
<a name="ln445">    void</a>
<a name="ln446">    _M_add_reference() const throw()</a>
<a name="ln447">    { __gnu_cxx::__atomic_add_dispatch(&amp;_M_refcount, 1); }</a>
<a name="ln448"> </a>
<a name="ln449">    void</a>
<a name="ln450">    _M_remove_reference() const throw()</a>
<a name="ln451">    {</a>
<a name="ln452">      // Be race-detector-friendly.  For more info see bits/c++config.</a>
<a name="ln453">      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_refcount);</a>
<a name="ln454">      if (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_refcount, -1) == 1)</a>
<a name="ln455">	{</a>
<a name="ln456">          _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_refcount);</a>
<a name="ln457">	  __try</a>
<a name="ln458">	    { delete this; }</a>
<a name="ln459">	  __catch(...)</a>
<a name="ln460">	    { }</a>
<a name="ln461">	}</a>
<a name="ln462">    }</a>
<a name="ln463"> </a>
<a name="ln464">    const facet* _M_sso_shim(const id*) const;</a>
<a name="ln465">    const facet* _M_cow_shim(const id*) const;</a>
<a name="ln466"> </a>
<a name="ln467">  protected:</a>
<a name="ln468">    class __shim; // For internal use only.</a>
<a name="ln469">  };</a>
<a name="ln470"> </a>
<a name="ln471"> </a>
<a name="ln472">  // 22.1.1.1.3 Class locale::id</a>
<a name="ln473">  /**</a>
<a name="ln474">   *  @brief  Facet ID class.</a>
<a name="ln475">   *  @ingroup locales</a>
<a name="ln476">   *</a>
<a name="ln477">   *  The ID class provides facets with an index used to identify them.</a>
<a name="ln478">   *  Every facet class must define a public static member locale::id, or be</a>
<a name="ln479">   *  derived from a facet that provides this member, otherwise the facet</a>
<a name="ln480">   *  cannot be used in a locale.  The locale::id ensures that each class</a>
<a name="ln481">   *  type gets a unique identifier.</a>
<a name="ln482">  */</a>
<a name="ln483">  class locale::id</a>
<a name="ln484">  {</a>
<a name="ln485">  private:</a>
<a name="ln486">    friend class locale;</a>
<a name="ln487">    friend class locale::_Impl;</a>
<a name="ln488"> </a>
<a name="ln489">    template&lt;typename _Facet&gt;</a>
<a name="ln490">      friend const _Facet&amp;</a>
<a name="ln491">      use_facet(const locale&amp;);</a>
<a name="ln492"> </a>
<a name="ln493">    template&lt;typename _Facet&gt;</a>
<a name="ln494">      friend bool</a>
<a name="ln495">      has_facet(const locale&amp;) throw();</a>
<a name="ln496"> </a>
<a name="ln497">    // NB: There is no accessor for _M_index because it may be used</a>
<a name="ln498">    // before the constructor is run; the effect of calling a member</a>
<a name="ln499">    // function (even an inline) would be undefined.</a>
<a name="ln500">    mutable size_t		_M_index;</a>
<a name="ln501"> </a>
<a name="ln502">    // Last id number assigned.</a>
<a name="ln503">    static _Atomic_word		_S_refcount;</a>
<a name="ln504"> </a>
<a name="ln505">    void</a>
<a name="ln506">    operator=(const id&amp;);  // Not defined.</a>
<a name="ln507"> </a>
<a name="ln508">    id(const id&amp;);  // Not defined.</a>
<a name="ln509"> </a>
<a name="ln510">  public:</a>
<a name="ln511">    // NB: This class is always a static data member, and thus can be</a>
<a name="ln512">    // counted on to be zero-initialized.</a>
<a name="ln513">    /// Constructor.</a>
<a name="ln514">    id() { }</a>
<a name="ln515"> </a>
<a name="ln516">    size_t</a>
<a name="ln517">    _M_id() const throw();</a>
<a name="ln518">  };</a>
<a name="ln519"> </a>
<a name="ln520"> </a>
<a name="ln521">  // Implementation object for locale.</a>
<a name="ln522">  class locale::_Impl</a>
<a name="ln523">  {</a>
<a name="ln524">  public:</a>
<a name="ln525">    // Friends.</a>
<a name="ln526">    friend class locale;</a>
<a name="ln527">    friend class locale::facet;</a>
<a name="ln528"> </a>
<a name="ln529">    template&lt;typename _Facet&gt;</a>
<a name="ln530">      friend bool</a>
<a name="ln531">      has_facet(const locale&amp;) throw();</a>
<a name="ln532"> </a>
<a name="ln533">    template&lt;typename _Facet&gt;</a>
<a name="ln534">      friend const _Facet&amp;</a>
<a name="ln535">      use_facet(const locale&amp;);</a>
<a name="ln536"> </a>
<a name="ln537">    template&lt;typename _Cache&gt;</a>
<a name="ln538">      friend struct __use_cache;</a>
<a name="ln539"> </a>
<a name="ln540">  private:</a>
<a name="ln541">    // Data Members.</a>
<a name="ln542">    _Atomic_word			_M_refcount;</a>
<a name="ln543">    const facet**			_M_facets;</a>
<a name="ln544">    size_t				_M_facets_size;</a>
<a name="ln545">    const facet**			_M_caches;</a>
<a name="ln546">    char**				_M_names;</a>
<a name="ln547">    static const locale::id* const	_S_id_ctype[];</a>
<a name="ln548">    static const locale::id* const	_S_id_numeric[];</a>
<a name="ln549">    static const locale::id* const	_S_id_collate[];</a>
<a name="ln550">    static const locale::id* const	_S_id_time[];</a>
<a name="ln551">    static const locale::id* const	_S_id_monetary[];</a>
<a name="ln552">    static const locale::id* const	_S_id_messages[];</a>
<a name="ln553">    static const locale::id* const* const _S_facet_categories[];</a>
<a name="ln554"> </a>
<a name="ln555">    void</a>
<a name="ln556">    _M_add_reference() throw()</a>
<a name="ln557">    { __gnu_cxx::__atomic_add_dispatch(&amp;_M_refcount, 1); }</a>
<a name="ln558"> </a>
<a name="ln559">    void</a>
<a name="ln560">    _M_remove_reference() throw()</a>
<a name="ln561">    {</a>
<a name="ln562">      // Be race-detector-friendly.  For more info see bits/c++config.</a>
<a name="ln563">      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_refcount);</a>
<a name="ln564">      if (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_refcount, -1) == 1)</a>
<a name="ln565">	{</a>
<a name="ln566">          _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_refcount);</a>
<a name="ln567">	  __try</a>
<a name="ln568">	    { delete this; }</a>
<a name="ln569">	  __catch(...)</a>
<a name="ln570">	    { }</a>
<a name="ln571">	}</a>
<a name="ln572">    }</a>
<a name="ln573"> </a>
<a name="ln574">    _Impl(const _Impl&amp;, size_t);</a>
<a name="ln575">    _Impl(const char*, size_t);</a>
<a name="ln576">    _Impl(size_t) throw();</a>
<a name="ln577"> </a>
<a name="ln578">   ~_Impl() throw();</a>
<a name="ln579"> </a>
<a name="ln580">    _Impl(const _Impl&amp;);  // Not defined.</a>
<a name="ln581"> </a>
<a name="ln582">    void</a>
<a name="ln583">    operator=(const _Impl&amp;);  // Not defined.</a>
<a name="ln584"> </a>
<a name="ln585">    bool</a>
<a name="ln586">    _M_check_same_name()</a>
<a name="ln587">    {</a>
<a name="ln588">      bool __ret = true;</a>
<a name="ln589">      if (_M_names[1])</a>
<a name="ln590">	// We must actually compare all the _M_names: can be all equal!</a>
<a name="ln591">	for (size_t __i = 0; __ret &amp;&amp; __i &lt; _S_categories_size - 1; ++__i)</a>
<a name="ln592">	  __ret = __builtin_strcmp(_M_names[__i], _M_names[__i + 1]) == 0;</a>
<a name="ln593">      return __ret;</a>
<a name="ln594">    }</a>
<a name="ln595"> </a>
<a name="ln596">    void</a>
<a name="ln597">    _M_replace_categories(const _Impl*, category);</a>
<a name="ln598"> </a>
<a name="ln599">    void</a>
<a name="ln600">    _M_replace_category(const _Impl*, const locale::id* const*);</a>
<a name="ln601"> </a>
<a name="ln602">    void</a>
<a name="ln603">    _M_replace_facet(const _Impl*, const locale::id*);</a>
<a name="ln604"> </a>
<a name="ln605">    void</a>
<a name="ln606">    _M_install_facet(const locale::id*, const facet*);</a>
<a name="ln607"> </a>
<a name="ln608">    template&lt;typename _Facet&gt;</a>
<a name="ln609">      void</a>
<a name="ln610">      _M_init_facet(_Facet* __facet)</a>
<a name="ln611">      { _M_install_facet(&amp;_Facet::id, __facet); }</a>
<a name="ln612"> </a>
<a name="ln613">    template&lt;typename _Facet&gt;</a>
<a name="ln614">      void</a>
<a name="ln615">      _M_init_facet_unchecked(_Facet* __facet)</a>
<a name="ln616">      {</a>
<a name="ln617">	__facet-&gt;_M_add_reference();</a>
<a name="ln618">	_M_facets[_Facet::id._M_id()] = __facet;</a>
<a name="ln619">      }</a>
<a name="ln620"> </a>
<a name="ln621">    void</a>
<a name="ln622">    _M_install_cache(const facet*, size_t);</a>
<a name="ln623"> </a>
<a name="ln624">    void _M_init_extra(facet**);</a>
<a name="ln625">    void _M_init_extra(void*, void*, const char*, const char*);</a>
<a name="ln626">  };</a>
<a name="ln627"> </a>
<a name="ln628"> </a>
<a name="ln629">  /**</a>
<a name="ln630">   *  @brief  Facet for localized string comparison.</a>
<a name="ln631">   *</a>
<a name="ln632">   *  This facet encapsulates the code to compare strings in a localized</a>
<a name="ln633">   *  manner.</a>
<a name="ln634">   *</a>
<a name="ln635">   *  The collate template uses protected virtual functions to provide</a>
<a name="ln636">   *  the actual results.  The public accessors forward the call to</a>
<a name="ln637">   *  the virtual functions.  These virtual functions are hooks for</a>
<a name="ln638">   *  developers to implement the behavior they require from the</a>
<a name="ln639">   *  collate facet.</a>
<a name="ln640">  */</a>
<a name="ln641">  template&lt;typename _CharT&gt;</a>
<a name="ln642">    class _GLIBCXX_NAMESPACE_CXX11 collate : public locale::facet</a>
<a name="ln643">    {</a>
<a name="ln644">    public:</a>
<a name="ln645">      // Types:</a>
<a name="ln646">      //@{</a>
<a name="ln647">      /// Public typedefs</a>
<a name="ln648">      typedef _CharT			char_type;</a>
<a name="ln649">      typedef basic_string&lt;_CharT&gt;	string_type;</a>
<a name="ln650">      //@}</a>
<a name="ln651"> </a>
<a name="ln652">    protected:</a>
<a name="ln653">      // Underlying &quot;C&quot; library locale information saved from</a>
<a name="ln654">      // initialization, needed by collate_byname as well.</a>
<a name="ln655">      __c_locale			_M_c_locale_collate;</a>
<a name="ln656"> </a>
<a name="ln657">    public:</a>
<a name="ln658">      /// Numpunct facet id.</a>
<a name="ln659">      static locale::id			id;</a>
<a name="ln660"> </a>
<a name="ln661">      /**</a>
<a name="ln662">       *  @brief  Constructor performs initialization.</a>
<a name="ln663">       *</a>
<a name="ln664">       *  This is the constructor provided by the standard.</a>
<a name="ln665">       *</a>
<a name="ln666">       *  @param __refs  Passed to the base facet class.</a>
<a name="ln667">      */</a>
<a name="ln668">      explicit</a>
<a name="ln669">      collate(size_t __refs = 0)</a>
<a name="ln670">      : facet(__refs), _M_c_locale_collate(_S_get_c_locale())</a>
<a name="ln671">      { }</a>
<a name="ln672"> </a>
<a name="ln673">      /**</a>
<a name="ln674">       *  @brief  Internal constructor. Not for general use.</a>
<a name="ln675">       *</a>
<a name="ln676">       *  This is a constructor for use by the library itself to set up new</a>
<a name="ln677">       *  locales.</a>
<a name="ln678">       *</a>
<a name="ln679">       *  @param __cloc  The C locale.</a>
<a name="ln680">       *  @param __refs  Passed to the base facet class.</a>
<a name="ln681">      */</a>
<a name="ln682">      explicit</a>
<a name="ln683">      collate(__c_locale __cloc, size_t __refs = 0)</a>
<a name="ln684">      : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))</a>
<a name="ln685">      { }</a>
<a name="ln686"> </a>
<a name="ln687">      /**</a>
<a name="ln688">       *  @brief  Compare two strings.</a>
<a name="ln689">       *</a>
<a name="ln690">       *  This function compares two strings and returns the result by calling</a>
<a name="ln691">       *  collate::do_compare().</a>
<a name="ln692">       *</a>
<a name="ln693">       *  @param __lo1  Start of string 1.</a>
<a name="ln694">       *  @param __hi1  End of string 1.</a>
<a name="ln695">       *  @param __lo2  Start of string 2.</a>
<a name="ln696">       *  @param __hi2  End of string 2.</a>
<a name="ln697">       *  @return  1 if string1 &gt; string2, -1 if string1 &lt; string2, else 0.</a>
<a name="ln698">      */</a>
<a name="ln699">      int</a>
<a name="ln700">      compare(const _CharT* __lo1, const _CharT* __hi1,</a>
<a name="ln701">	      const _CharT* __lo2, const _CharT* __hi2) const</a>
<a name="ln702">      { return this-&gt;do_compare(__lo1, __hi1, __lo2, __hi2); }</a>
<a name="ln703"> </a>
<a name="ln704">      /**</a>
<a name="ln705">       *  @brief  Transform string to comparable form.</a>
<a name="ln706">       *</a>
<a name="ln707">       *  This function is a wrapper for strxfrm functionality.  It takes the</a>
<a name="ln708">       *  input string and returns a modified string that can be directly</a>
<a name="ln709">       *  compared to other transformed strings.  In the C locale, this</a>
<a name="ln710">       *  function just returns a copy of the input string.  In some other</a>
<a name="ln711">       *  locales, it may replace two chars with one, change a char for</a>
<a name="ln712">       *  another, etc.  It does so by returning collate::do_transform().</a>
<a name="ln713">       *</a>
<a name="ln714">       *  @param __lo  Start of string.</a>
<a name="ln715">       *  @param __hi  End of string.</a>
<a name="ln716">       *  @return  Transformed string_type.</a>
<a name="ln717">      */</a>
<a name="ln718">      string_type</a>
<a name="ln719">      transform(const _CharT* __lo, const _CharT* __hi) const</a>
<a name="ln720">      { return this-&gt;do_transform(__lo, __hi); }</a>
<a name="ln721"> </a>
<a name="ln722">      /**</a>
<a name="ln723">       *  @brief  Return hash of a string.</a>
<a name="ln724">       *</a>
<a name="ln725">       *  This function computes and returns a hash on the input string.  It</a>
<a name="ln726">       *  does so by returning collate::do_hash().</a>
<a name="ln727">       *</a>
<a name="ln728">       *  @param __lo  Start of string.</a>
<a name="ln729">       *  @param __hi  End of string.</a>
<a name="ln730">       *  @return  Hash value.</a>
<a name="ln731">      */</a>
<a name="ln732">      long</a>
<a name="ln733">      hash(const _CharT* __lo, const _CharT* __hi) const</a>
<a name="ln734">      { return this-&gt;do_hash(__lo, __hi); }</a>
<a name="ln735"> </a>
<a name="ln736">      // Used to abstract out _CharT bits in virtual member functions, below.</a>
<a name="ln737">      int</a>
<a name="ln738">      _M_compare(const _CharT*, const _CharT*) const throw();</a>
<a name="ln739"> </a>
<a name="ln740">      size_t</a>
<a name="ln741">      _M_transform(_CharT*, const _CharT*, size_t) const throw();</a>
<a name="ln742"> </a>
<a name="ln743">  protected:</a>
<a name="ln744">      /// Destructor.</a>
<a name="ln745">      virtual</a>
<a name="ln746">      ~collate()</a>
<a name="ln747">      { _S_destroy_c_locale(_M_c_locale_collate); }</a>
<a name="ln748"> </a>
<a name="ln749">      /**</a>
<a name="ln750">       *  @brief  Compare two strings.</a>
<a name="ln751">       *</a>
<a name="ln752">       *  This function is a hook for derived classes to change the value</a>
<a name="ln753">       *  returned.  @see compare().</a>
<a name="ln754">       *</a>
<a name="ln755">       *  @param __lo1  Start of string 1.</a>
<a name="ln756">       *  @param __hi1  End of string 1.</a>
<a name="ln757">       *  @param __lo2  Start of string 2.</a>
<a name="ln758">       *  @param __hi2  End of string 2.</a>
<a name="ln759">       *  @return  1 if string1 &gt; string2, -1 if string1 &lt; string2, else 0.</a>
<a name="ln760">      */</a>
<a name="ln761">      virtual int</a>
<a name="ln762">      do_compare(const _CharT* __lo1, const _CharT* __hi1,</a>
<a name="ln763">		 const _CharT* __lo2, const _CharT* __hi2) const;</a>
<a name="ln764"> </a>
<a name="ln765">      /**</a>
<a name="ln766">       *  @brief  Transform string to comparable form.</a>
<a name="ln767">       *</a>
<a name="ln768">       *  This function is a hook for derived classes to change the value</a>
<a name="ln769">       *  returned.</a>
<a name="ln770">       *</a>
<a name="ln771">       *  @param __lo  Start.</a>
<a name="ln772">       *  @param __hi  End.</a>
<a name="ln773">       *  @return  transformed string.</a>
<a name="ln774">      */</a>
<a name="ln775">      virtual string_type</a>
<a name="ln776">      do_transform(const _CharT* __lo, const _CharT* __hi) const;</a>
<a name="ln777"> </a>
<a name="ln778">      /**</a>
<a name="ln779">       *  @brief  Return hash of a string.</a>
<a name="ln780">       *</a>
<a name="ln781">       *  This function computes and returns a hash on the input string.  This</a>
<a name="ln782">       *  function is a hook for derived classes to change the value returned.</a>
<a name="ln783">       *</a>
<a name="ln784">       *  @param __lo  Start of string.</a>
<a name="ln785">       *  @param __hi  End of string.</a>
<a name="ln786">       *  @return  Hash value.</a>
<a name="ln787">      */</a>
<a name="ln788">      virtual long</a>
<a name="ln789">      do_hash(const _CharT* __lo, const _CharT* __hi) const;</a>
<a name="ln790">    };</a>
<a name="ln791"> </a>
<a name="ln792">  template&lt;typename _CharT&gt;</a>
<a name="ln793">    locale::id collate&lt;_CharT&gt;::id;</a>
<a name="ln794"> </a>
<a name="ln795">  // Specializations.</a>
<a name="ln796">  template&lt;&gt;</a>
<a name="ln797">    int</a>
<a name="ln798">    collate&lt;char&gt;::_M_compare(const char*, const char*) const throw();</a>
<a name="ln799"> </a>
<a name="ln800">  template&lt;&gt;</a>
<a name="ln801">    size_t</a>
<a name="ln802">    collate&lt;char&gt;::_M_transform(char*, const char*, size_t) const throw();</a>
<a name="ln803"> </a>
<a name="ln804">#ifdef _GLIBCXX_USE_WCHAR_T</a>
<a name="ln805">  template&lt;&gt;</a>
<a name="ln806">    int</a>
<a name="ln807">    collate&lt;wchar_t&gt;::_M_compare(const wchar_t*, const wchar_t*) const throw();</a>
<a name="ln808"> </a>
<a name="ln809">  template&lt;&gt;</a>
<a name="ln810">    size_t</a>
<a name="ln811">    collate&lt;wchar_t&gt;::_M_transform(wchar_t*, const wchar_t*, size_t) const throw();</a>
<a name="ln812">#endif</a>
<a name="ln813"> </a>
<a name="ln814">  /// class collate_byname [22.2.4.2].</a>
<a name="ln815">  template&lt;typename _CharT&gt;</a>
<a name="ln816">    class _GLIBCXX_NAMESPACE_CXX11 collate_byname : public collate&lt;_CharT&gt;</a>
<a name="ln817">    {</a>
<a name="ln818">    public:</a>
<a name="ln819">      //@{</a>
<a name="ln820">      /// Public typedefs</a>
<a name="ln821">      typedef _CharT               char_type;</a>
<a name="ln822">      typedef basic_string&lt;_CharT&gt; string_type;</a>
<a name="ln823">      //@}</a>
<a name="ln824"> </a>
<a name="ln825">      explicit</a>
<a name="ln826">      collate_byname(const char* __s, size_t __refs = 0)</a>
<a name="ln827">      : collate&lt;_CharT&gt;(__refs)</a>
<a name="ln828">      {</a>
<a name="ln829">	if (__builtin_strcmp(__s, &quot;C&quot;) != 0</a>
<a name="ln830">	    &amp;&amp; __builtin_strcmp(__s, &quot;POSIX&quot;) != 0)</a>
<a name="ln831">	  {</a>
<a name="ln832">	    this-&gt;_S_destroy_c_locale(this-&gt;_M_c_locale_collate);</a>
<a name="ln833">	    this-&gt;_S_create_c_locale(this-&gt;_M_c_locale_collate, __s);</a>
<a name="ln834">	  }</a>
<a name="ln835">      }</a>
<a name="ln836"> </a>
<a name="ln837">#if __cplusplus &gt;= 201103L</a>
<a name="ln838">      explicit</a>
<a name="ln839">      collate_byname(const string&amp; __s, size_t __refs = 0)</a>
<a name="ln840">      : collate_byname(__s.c_str(), __refs) { }</a>
<a name="ln841">#endif</a>
<a name="ln842"> </a>
<a name="ln843">    protected:</a>
<a name="ln844">      virtual</a>
<a name="ln845">      ~collate_byname() { }</a>
<a name="ln846">    };</a>
<a name="ln847"> </a>
<a name="ln848">_GLIBCXX_END_NAMESPACE_VERSION</a>
<a name="ln849">} // namespace</a>
<a name="ln850"> </a>
<a name="ln851"># include &lt;bits/locale_classes.tcc&gt;</a>
<a name="ln852"> </a>
<a name="ln853">#endif</a>

</code></pre>
<div class="balloon" rel="522"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v690/" target="_blank">V690</a> The copy assignment operator is declared as private in the 'locale::_Impl' class, but the default copy constructor will still be generated by compiler. It is dangerous to use such a class.</p></div>
<div class="balloon" rel="514"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: _M_index.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
