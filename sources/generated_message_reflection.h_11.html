
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>generated_message_reflection.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Protocol Buffers - Google's data interchange format</a>
<a name="ln2">// Copyright 2008 Google Inc.  All rights reserved.</a>
<a name="ln3">// https://developers.google.com/protocol-buffers/</a>
<a name="ln4">//</a>
<a name="ln5">// Redistribution and use in source and binary forms, with or without</a>
<a name="ln6">// modification, are permitted provided that the following conditions are</a>
<a name="ln7">// met:</a>
<a name="ln8">//</a>
<a name="ln9">//     * Redistributions of source code must retain the above copyright</a>
<a name="ln10">// notice, this list of conditions and the following disclaimer.</a>
<a name="ln11">//     * Redistributions in binary form must reproduce the above</a>
<a name="ln12">// copyright notice, this list of conditions and the following disclaimer</a>
<a name="ln13">// in the documentation and/or other materials provided with the</a>
<a name="ln14">// distribution.</a>
<a name="ln15">//     * Neither the name of Google Inc. nor the names of its</a>
<a name="ln16">// contributors may be used to endorse or promote products derived from</a>
<a name="ln17">// this software without specific prior written permission.</a>
<a name="ln18">//</a>
<a name="ln19">// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</a>
<a name="ln20">// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</a>
<a name="ln21">// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</a>
<a name="ln22">// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</a>
<a name="ln23">// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</a>
<a name="ln24">// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</a>
<a name="ln25">// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</a>
<a name="ln26">// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</a>
<a name="ln27">// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</a>
<a name="ln28">// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</a>
<a name="ln29">// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</a>
<a name="ln30"> </a>
<a name="ln31">// Author: kenton@google.com (Kenton Varda)</a>
<a name="ln32">//  Based on original Protocol Buffers design by</a>
<a name="ln33">//  Sanjay Ghemawat, Jeff Dean, and others.</a>
<a name="ln34">//</a>
<a name="ln35">// This header is logically internal, but is made public because it is used</a>
<a name="ln36">// from protocol-compiler-generated code, which may reside in other components.</a>
<a name="ln37"> </a>
<a name="ln38">#ifndef GOOGLE_PROTOBUF_GENERATED_MESSAGE_REFLECTION_H__</a>
<a name="ln39">#define GOOGLE_PROTOBUF_GENERATED_MESSAGE_REFLECTION_H__</a>
<a name="ln40"> </a>
<a name="ln41">#include &lt;string&gt;</a>
<a name="ln42">#include &lt;vector&gt;</a>
<a name="ln43">#include &lt;google/protobuf/stubs/casts.h&gt;</a>
<a name="ln44">#include &lt;google/protobuf/stubs/common.h&gt;</a>
<a name="ln45">// TODO(jasonh): Remove this once the compiler change to directly include this</a>
<a name="ln46">// is released to components.</a>
<a name="ln47">#include &lt;google/protobuf/generated_enum_reflection.h&gt;</a>
<a name="ln48">#include &lt;google/protobuf/message.h&gt;</a>
<a name="ln49">#include &lt;google/protobuf/metadata.h&gt;</a>
<a name="ln50">#include &lt;google/protobuf/unknown_field_set.h&gt;</a>
<a name="ln51"> </a>
<a name="ln52"> </a>
<a name="ln53">namespace google {</a>
<a name="ln54">namespace upb {</a>
<a name="ln55">namespace google_opensource {</a>
<a name="ln56">class GMR_Handlers;</a>
<a name="ln57">}  // namespace google_opensource</a>
<a name="ln58">}  // namespace upb</a>
<a name="ln59"> </a>
<a name="ln60">namespace protobuf {</a>
<a name="ln61">class DescriptorPool;</a>
<a name="ln62">class MapKey;</a>
<a name="ln63">class MapValueRef;</a>
<a name="ln64">}  // namespace protobuf</a>
<a name="ln65"> </a>
<a name="ln66"> </a>
<a name="ln67">namespace protobuf {</a>
<a name="ln68">namespace flat {</a>
<a name="ln69">class MetadataBuilder;</a>
<a name="ln70">}  // namespace flat</a>
<a name="ln71">}  // namespace protobuf</a>
<a name="ln72"> </a>
<a name="ln73"> </a>
<a name="ln74">namespace protobuf {</a>
<a name="ln75">namespace internal {</a>
<a name="ln76">class DefaultEmptyOneof;</a>
<a name="ln77"> </a>
<a name="ln78">// Defined in this file.</a>
<a name="ln79">class GeneratedMessageReflection;</a>
<a name="ln80"> </a>
<a name="ln81">// Defined in other files.</a>
<a name="ln82">class ExtensionSet;             // extension_set.h</a>
<a name="ln83">class WeakFieldMap;             // weak_field_map.h</a>
<a name="ln84"> </a>
<a name="ln85">// This struct describes the internal layout of the message, hence this is</a>
<a name="ln86">// used to act on the message reflectively.</a>
<a name="ln87">//   default_instance:  The default instance of the message.  This is only</a>
<a name="ln88">//                  used to obtain pointers to default instances of embedded</a>
<a name="ln89">//                  messages, which GetMessage() will return if the particular</a>
<a name="ln90">//                  sub-message has not been initialized yet.  (Thus, all</a>
<a name="ln91">//                  embedded message fields *must* have non-NULL pointers</a>
<a name="ln92">//                  in the default instance.)</a>
<a name="ln93">//   offsets:       An array of ints giving the byte offsets.</a>
<a name="ln94">//                  For each oneof or weak field, the offset is relative to the</a>
<a name="ln95">//                  default_instance. These can be computed at compile time</a>
<a name="ln96">//                  using the</a>
<a name="ln97">//                  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET()</a>
<a name="ln98">//                  macro. For each none oneof field, the offset is related to</a>
<a name="ln99">//                  the start of the message object.  These can be computed at</a>
<a name="ln100">//                  compile time using the</a>
<a name="ln101">//                  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET() macro.</a>
<a name="ln102">//                  Besides offsets for all fields, this array also contains</a>
<a name="ln103">//                  offsets for oneof unions. The offset of the i-th oneof union</a>
<a name="ln104">//                  is offsets[descriptor-&gt;field_count() + i].</a>
<a name="ln105">//   has_bit_indices:  Mapping from field indexes to their index in the has</a>
<a name="ln106">//                  bit array.</a>
<a name="ln107">//   has_bits_offset:  Offset in the message of an array of uint32s of size</a>
<a name="ln108">//                  descriptor-&gt;field_count()/32, rounded up.  This is a</a>
<a name="ln109">//                  bitfield where each bit indicates whether or not the</a>
<a name="ln110">//                  corresponding field of the message has been initialized.</a>
<a name="ln111">//                  The bit for field index i is obtained by the expression:</a>
<a name="ln112">//                    has_bits[i / 32] &amp; (1 &lt;&lt; (i % 32))</a>
<a name="ln113">//   unknown_fields_offset:  Offset in the message of the UnknownFieldSet for</a>
<a name="ln114">//                  the message.</a>
<a name="ln115">//   extensions_offset:  Offset in the message of the ExtensionSet for the</a>
<a name="ln116">//                  message, or -1 if the message type has no extension</a>
<a name="ln117">//                  ranges.</a>
<a name="ln118">//   oneof_case_offset:  Offset in the message of an array of uint32s of</a>
<a name="ln119">//                  size descriptor-&gt;oneof_decl_count().  Each uint32</a>
<a name="ln120">//                  indicates what field is set for each oneof.</a>
<a name="ln121">//   object_size:   The size of a message object of this type, as measured</a>
<a name="ln122">//                  by sizeof().</a>
<a name="ln123">//   arena_offset:  If a message doesn't have a unknown_field_set that stores</a>
<a name="ln124">//                  the arena, it must have a direct pointer to the arena.</a>
<a name="ln125">//   weak_field_map_offset: If the message proto has weak fields, this is the</a>
<a name="ln126">//                  offset of _weak_field_map_ in the generated proto. Otherwise</a>
<a name="ln127">//                  -1.</a>
<a name="ln128">struct ReflectionSchema {</a>
<a name="ln129"> public:</a>
<a name="ln130">  // Size of a google::protobuf::Message object of this type.</a>
<a name="ln131">  uint32 GetObjectSize() const { return static_cast&lt;uint32&gt;(object_size_); }</a>
<a name="ln132"> </a>
<a name="ln133">  // Offset of a non-oneof field.  Getting a field offset is slightly more</a>
<a name="ln134">  // efficient when we know statically that it is not a oneof field.</a>
<a name="ln135">  uint32 GetFieldOffsetNonOneof(const FieldDescriptor* field) const {</a>
<a name="ln136">    GOOGLE_DCHECK(!field-&gt;containing_oneof());</a>
<a name="ln137">    return offsets_[field-&gt;index()];</a>
<a name="ln138">  }</a>
<a name="ln139"> </a>
<a name="ln140">  // Offset of any field.</a>
<a name="ln141">  uint32 GetFieldOffset(const FieldDescriptor* field) const {</a>
<a name="ln142">    if (field-&gt;containing_oneof()) {</a>
<a name="ln143">      size_t offset =</a>
<a name="ln144">          static_cast&lt;size_t&gt;(field-&gt;containing_type()-&gt;field_count() +</a>
<a name="ln145">          field-&gt;containing_oneof()-&gt;index());</a>
<a name="ln146">      return offsets_[offset];</a>
<a name="ln147">    } else {</a>
<a name="ln148">      return GetFieldOffsetNonOneof(field);</a>
<a name="ln149">    }</a>
<a name="ln150">  }</a>
<a name="ln151"> </a>
<a name="ln152">  uint32 GetOneofCaseOffset(const OneofDescriptor* oneof_descriptor) const {</a>
<a name="ln153">    return static_cast&lt;uint32&gt;(oneof_case_offset_) +</a>
<a name="ln154">           static_cast&lt;uint32&gt;(</a>
<a name="ln155">               static_cast&lt;size_t&gt;(oneof_descriptor-&gt;index()) * sizeof(uint32));</a>
<a name="ln156">  }</a>
<a name="ln157"> </a>
<a name="ln158">  bool HasHasbits() const { return has_bits_offset_ != -1; }</a>
<a name="ln159"> </a>
<a name="ln160">  // Bit index within the bit array of hasbits.  Bit order is low-to-high.</a>
<a name="ln161">  uint32 HasBitIndex(const FieldDescriptor* field) const {</a>
<a name="ln162">    GOOGLE_DCHECK(HasHasbits());</a>
<a name="ln163">    return has_bit_indices_[field-&gt;index()];</a>
<a name="ln164">  }</a>
<a name="ln165"> </a>
<a name="ln166">  // Byte offset of the hasbits array.</a>
<a name="ln167">  uint32 HasBitsOffset() const {</a>
<a name="ln168">    GOOGLE_DCHECK(HasHasbits());</a>
<a name="ln169">    return static_cast&lt;uint32&gt;(has_bits_offset_);</a>
<a name="ln170">  }</a>
<a name="ln171"> </a>
<a name="ln172">  // The offset of the InternalMetadataWithArena member.</a>
<a name="ln173">  // For Lite this will actually be an InternalMetadataWithArenaLite.</a>
<a name="ln174">  // The schema doesn't contain enough information to distinguish between</a>
<a name="ln175">  // these two cases.</a>
<a name="ln176">  uint32 GetMetadataOffset() const {</a>
<a name="ln177">    return static_cast&lt;uint32&gt;(metadata_offset_);</a>
<a name="ln178">  }</a>
<a name="ln179"> </a>
<a name="ln180">  // Whether this message has an ExtensionSet.</a>
<a name="ln181">  bool HasExtensionSet() const { return extensions_offset_ != -1; }</a>
<a name="ln182"> </a>
<a name="ln183">  // The offset of the ExtensionSet in this message.</a>
<a name="ln184">  uint32 GetExtensionSetOffset() const {</a>
<a name="ln185">    GOOGLE_DCHECK(HasExtensionSet());</a>
<a name="ln186">    return static_cast&lt;uint32&gt;(extensions_offset_);</a>
<a name="ln187">  }</a>
<a name="ln188"> </a>
<a name="ln189">  // The off set of WeakFieldMap when the message contains weak fields.</a>
<a name="ln190">  // The default is 0 for now.</a>
<a name="ln191">  int GetWeakFieldMapOffset() const { return weak_field_map_offset_; }</a>
<a name="ln192"> </a>
<a name="ln193">  bool IsDefaultInstance(const Message&amp; message) const {</a>
<a name="ln194">    return &amp;message == default_instance_;</a>
<a name="ln195">  }</a>
<a name="ln196"> </a>
<a name="ln197">  // Returns a pointer to the default value for this field.  The size and type</a>
<a name="ln198">  // of the underlying data depends on the field's type.</a>
<a name="ln199">  const void *GetFieldDefault(const FieldDescriptor* field) const {</a>
<a name="ln200">    return reinterpret_cast&lt;const uint8*&gt;(default_instance_) +</a>
<a name="ln201">                     offsets_[field-&gt;index()];</a>
<a name="ln202">  }</a>
<a name="ln203"> </a>
<a name="ln204"> </a>
<a name="ln205">  bool HasWeakFields() const { return weak_field_map_offset_ &gt; 0; }</a>
<a name="ln206"> </a>
<a name="ln207">  // These members are intended to be private, but we cannot actually make them</a>
<a name="ln208">  // private because this prevents us from using aggregate initialization of</a>
<a name="ln209">  // them, ie.</a>
<a name="ln210">  //</a>
<a name="ln211">  //   ReflectionSchema schema = {a, b, c, d, e, ...};</a>
<a name="ln212"> // private:</a>
<a name="ln213">  const Message* default_instance_;</a>
<a name="ln214">  const uint32* offsets_;</a>
<a name="ln215">  const uint32* has_bit_indices_;</a>
<a name="ln216">  int has_bits_offset_;</a>
<a name="ln217">  int metadata_offset_;</a>
<a name="ln218">  int extensions_offset_;</a>
<a name="ln219">  int oneof_case_offset_;</a>
<a name="ln220">  int object_size_;</a>
<a name="ln221">  int weak_field_map_offset_;</a>
<a name="ln222">};</a>
<a name="ln223"> </a>
<a name="ln224">// Structs that the code generator emits directly to describe a message.</a>
<a name="ln225">// These should never used directly except to build a ReflectionSchema</a>
<a name="ln226">// object.</a>
<a name="ln227">//</a>
<a name="ln228">// EXPERIMENTAL: these are changing rapidly, and may completely disappear</a>
<a name="ln229">// or merge with ReflectionSchema.</a>
<a name="ln230">struct MigrationSchema {</a>
<a name="ln231">  int32 offsets_index;</a>
<a name="ln232">  int32 has_bit_indices_index;</a>
<a name="ln233">  int object_size;</a>
<a name="ln234">};</a>
<a name="ln235"> </a>
<a name="ln236">// THIS CLASS IS NOT INTENDED FOR DIRECT USE.  It is intended for use</a>
<a name="ln237">// by generated code.  This class is just a big hack that reduces code</a>
<a name="ln238">// size.</a>
<a name="ln239">//</a>
<a name="ln240">// A GeneratedMessageReflection is an implementation of Reflection</a>
<a name="ln241">// which expects all fields to be backed by simple variables located in</a>
<a name="ln242">// memory.  The locations are given using a base pointer and a set of</a>
<a name="ln243">// offsets.</a>
<a name="ln244">//</a>
<a name="ln245">// It is required that the user represents fields of each type in a standard</a>
<a name="ln246">// way, so that GeneratedMessageReflection can cast the void* pointer to</a>
<a name="ln247">// the appropriate type.  For primitive fields and string fields, each field</a>
<a name="ln248">// should be represented using the obvious C++ primitive type.  Enums and</a>
<a name="ln249">// Messages are different:</a>
<a name="ln250">//  - Singular Message fields are stored as a pointer to a Message.  These</a>
<a name="ln251">//    should start out NULL, except for in the default instance where they</a>
<a name="ln252">//    should start out pointing to other default instances.</a>
<a name="ln253">//  - Enum fields are stored as an int.  This int must always contain</a>
<a name="ln254">//    a valid value, such that EnumDescriptor::FindValueByNumber() would</a>
<a name="ln255">//    not return NULL.</a>
<a name="ln256">//  - Repeated fields are stored as RepeatedFields or RepeatedPtrFields</a>
<a name="ln257">//    of whatever type the individual field would be.  Strings and</a>
<a name="ln258">//    Messages use RepeatedPtrFields while everything else uses</a>
<a name="ln259">//    RepeatedFields.</a>
<a name="ln260">class LIBPROTOBUF_EXPORT GeneratedMessageReflection PROTOBUF_FINAL : public Reflection {</a>
<a name="ln261"> public:</a>
<a name="ln262">  // Constructs a GeneratedMessageReflection.</a>
<a name="ln263">  // Parameters:</a>
<a name="ln264">  //   descriptor:    The descriptor for the message type being implemented.</a>
<a name="ln265">  //   schema:        The description of the internal guts of the message.</a>
<a name="ln266">  //   pool:          DescriptorPool to search for extension definitions.  Only</a>
<a name="ln267">  //                  used by FindKnownExtensionByName() and</a>
<a name="ln268">  //                  FindKnownExtensionByNumber().</a>
<a name="ln269">  //   factory:       MessageFactory to use to construct extension messages.</a>
<a name="ln270">  GeneratedMessageReflection(const Descriptor* descriptor,</a>
<a name="ln271">                             const ReflectionSchema&amp; schema,</a>
<a name="ln272">                             const DescriptorPool* pool,</a>
<a name="ln273">                             MessageFactory* factory);</a>
<a name="ln274"> </a>
<a name="ln275">  ~GeneratedMessageReflection();</a>
<a name="ln276"> </a>
<a name="ln277">  // implements Reflection -------------------------------------------</a>
<a name="ln278"> </a>
<a name="ln279">  const UnknownFieldSet&amp; GetUnknownFields(const Message&amp; message) const;</a>
<a name="ln280">  UnknownFieldSet* MutableUnknownFields(Message* message) const;</a>
<a name="ln281"> </a>
<a name="ln282">  size_t SpaceUsedLong(const Message&amp; message) const;</a>
<a name="ln283"> </a>
<a name="ln284">  bool HasField(const Message&amp; message, const FieldDescriptor* field) const;</a>
<a name="ln285">  int FieldSize(const Message&amp; message, const FieldDescriptor* field) const;</a>
<a name="ln286">  void ClearField(Message* message, const FieldDescriptor* field) const;</a>
<a name="ln287">  bool HasOneof(const Message&amp; message,</a>
<a name="ln288">                const OneofDescriptor* oneof_descriptor) const;</a>
<a name="ln289">  void ClearOneof(Message* message, const OneofDescriptor* field) const;</a>
<a name="ln290">  void RemoveLast(Message* message, const FieldDescriptor* field) const;</a>
<a name="ln291">  Message* ReleaseLast(Message* message, const FieldDescriptor* field) const;</a>
<a name="ln292">  void Swap(Message* message1, Message* message2) const;</a>
<a name="ln293">  void SwapFields(Message* message1, Message* message2,</a>
<a name="ln294">                  const std::vector&lt;const FieldDescriptor*&gt;&amp; fields) const;</a>
<a name="ln295">  void SwapElements(Message* message, const FieldDescriptor* field,</a>
<a name="ln296">                    int index1, int index2) const;</a>
<a name="ln297">  void ListFields(const Message&amp; message,</a>
<a name="ln298">                  std::vector&lt;const FieldDescriptor*&gt;* output) const;</a>
<a name="ln299"> </a>
<a name="ln300">  int32  GetInt32 (const Message&amp; message,</a>
<a name="ln301">                   const FieldDescriptor* field) const;</a>
<a name="ln302">  int64  GetInt64 (const Message&amp; message,</a>
<a name="ln303">                   const FieldDescriptor* field) const;</a>
<a name="ln304">  uint32 GetUInt32(const Message&amp; message,</a>
<a name="ln305">                   const FieldDescriptor* field) const;</a>
<a name="ln306">  uint64 GetUInt64(const Message&amp; message,</a>
<a name="ln307">                   const FieldDescriptor* field) const;</a>
<a name="ln308">  float  GetFloat (const Message&amp; message,</a>
<a name="ln309">                   const FieldDescriptor* field) const;</a>
<a name="ln310">  double GetDouble(const Message&amp; message,</a>
<a name="ln311">                   const FieldDescriptor* field) const;</a>
<a name="ln312">  bool   GetBool  (const Message&amp; message,</a>
<a name="ln313">                   const FieldDescriptor* field) const;</a>
<a name="ln314">  string GetString(const Message&amp; message,</a>
<a name="ln315">                   const FieldDescriptor* field) const;</a>
<a name="ln316">  const string&amp; GetStringReference(const Message&amp; message,</a>
<a name="ln317">                                   const FieldDescriptor* field,</a>
<a name="ln318">                                   string* scratch) const;</a>
<a name="ln319">  const EnumValueDescriptor* GetEnum(const Message&amp; message,</a>
<a name="ln320">                                     const FieldDescriptor* field) const;</a>
<a name="ln321">  int GetEnumValue(const Message&amp; message,</a>
<a name="ln322">                   const FieldDescriptor* field) const;</a>
<a name="ln323">  const Message&amp; GetMessage(const Message&amp; message,</a>
<a name="ln324">                            const FieldDescriptor* field,</a>
<a name="ln325">                            MessageFactory* factory = NULL) const;</a>
<a name="ln326"> </a>
<a name="ln327">  const FieldDescriptor* GetOneofFieldDescriptor(</a>
<a name="ln328">      const Message&amp; message,</a>
<a name="ln329">      const OneofDescriptor* oneof_descriptor) const;</a>
<a name="ln330"> </a>
<a name="ln331"> private:</a>
<a name="ln332">  bool ContainsMapKey(const Message&amp; message,</a>
<a name="ln333">                      const FieldDescriptor* field,</a>
<a name="ln334">                      const MapKey&amp; key) const;</a>
<a name="ln335">  bool InsertOrLookupMapValue(Message* message,</a>
<a name="ln336">                              const FieldDescriptor* field,</a>
<a name="ln337">                              const MapKey&amp; key,</a>
<a name="ln338">                              MapValueRef* val) const;</a>
<a name="ln339">  bool DeleteMapValue(Message* message,</a>
<a name="ln340">                      const FieldDescriptor* field,</a>
<a name="ln341">                      const MapKey&amp; key) const;</a>
<a name="ln342">  MapIterator MapBegin(</a>
<a name="ln343">      Message* message,</a>
<a name="ln344">      const FieldDescriptor* field) const;</a>
<a name="ln345">  MapIterator MapEnd(</a>
<a name="ln346">      Message* message,</a>
<a name="ln347">      const FieldDescriptor* field) const;</a>
<a name="ln348">  int MapSize(const Message&amp; message, const FieldDescriptor* field) const;</a>
<a name="ln349"> </a>
<a name="ln350"> public:</a>
<a name="ln351">  void SetInt32 (Message* message,</a>
<a name="ln352">                 const FieldDescriptor* field, int32  value) const;</a>
<a name="ln353">  void SetInt64 (Message* message,</a>
<a name="ln354">                 const FieldDescriptor* field, int64  value) const;</a>
<a name="ln355">  void SetUInt32(Message* message,</a>
<a name="ln356">                 const FieldDescriptor* field, uint32 value) const;</a>
<a name="ln357">  void SetUInt64(Message* message,</a>
<a name="ln358">                 const FieldDescriptor* field, uint64 value) const;</a>
<a name="ln359">  void SetFloat (Message* message,</a>
<a name="ln360">                 const FieldDescriptor* field, float  value) const;</a>
<a name="ln361">  void SetDouble(Message* message,</a>
<a name="ln362">                 const FieldDescriptor* field, double value) const;</a>
<a name="ln363">  void SetBool  (Message* message,</a>
<a name="ln364">                 const FieldDescriptor* field, bool   value) const;</a>
<a name="ln365">  void SetString(Message* message,</a>
<a name="ln366">                 const FieldDescriptor* field,</a>
<a name="ln367">                 const string&amp; value) const;</a>
<a name="ln368">  void SetEnum  (Message* message, const FieldDescriptor* field,</a>
<a name="ln369">                 const EnumValueDescriptor* value) const;</a>
<a name="ln370">  void SetEnumValue(Message* message, const FieldDescriptor* field,</a>
<a name="ln371">                    int value) const;</a>
<a name="ln372">  Message* MutableMessage(Message* message, const FieldDescriptor* field,</a>
<a name="ln373">                          MessageFactory* factory = NULL) const;</a>
<a name="ln374">  void SetAllocatedMessage(Message* message,</a>
<a name="ln375">                           Message* sub_message,</a>
<a name="ln376">                           const FieldDescriptor* field) const;</a>
<a name="ln377">  Message* ReleaseMessage(Message* message, const FieldDescriptor* field,</a>
<a name="ln378">                          MessageFactory* factory = NULL) const;</a>
<a name="ln379"> </a>
<a name="ln380">  int32  GetRepeatedInt32 (const Message&amp; message,</a>
<a name="ln381">                           const FieldDescriptor* field, int index) const;</a>
<a name="ln382">  int64  GetRepeatedInt64 (const Message&amp; message,</a>
<a name="ln383">                           const FieldDescriptor* field, int index) const;</a>
<a name="ln384">  uint32 GetRepeatedUInt32(const Message&amp; message,</a>
<a name="ln385">                           const FieldDescriptor* field, int index) const;</a>
<a name="ln386">  uint64 GetRepeatedUInt64(const Message&amp; message,</a>
<a name="ln387">                           const FieldDescriptor* field, int index) const;</a>
<a name="ln388">  float  GetRepeatedFloat (const Message&amp; message,</a>
<a name="ln389">                           const FieldDescriptor* field, int index) const;</a>
<a name="ln390">  double GetRepeatedDouble(const Message&amp; message,</a>
<a name="ln391">                           const FieldDescriptor* field, int index) const;</a>
<a name="ln392">  bool   GetRepeatedBool  (const Message&amp; message,</a>
<a name="ln393">                           const FieldDescriptor* field, int index) const;</a>
<a name="ln394">  string GetRepeatedString(const Message&amp; message,</a>
<a name="ln395">                           const FieldDescriptor* field, int index) const;</a>
<a name="ln396">  const string&amp; GetRepeatedStringReference(const Message&amp; message,</a>
<a name="ln397">                                           const FieldDescriptor* field,</a>
<a name="ln398">                                           int index, string* scratch) const;</a>
<a name="ln399">  const EnumValueDescriptor* GetRepeatedEnum(const Message&amp; message,</a>
<a name="ln400">                                             const FieldDescriptor* field,</a>
<a name="ln401">                                             int index) const;</a>
<a name="ln402">  int GetRepeatedEnumValue(const Message&amp; message,</a>
<a name="ln403">                           const FieldDescriptor* field,</a>
<a name="ln404">                           int index) const;</a>
<a name="ln405">  const Message&amp; GetRepeatedMessage(const Message&amp; message,</a>
<a name="ln406">                                    const FieldDescriptor* field,</a>
<a name="ln407">                                    int index) const;</a>
<a name="ln408"> </a>
<a name="ln409">  // Set the value of a field.</a>
<a name="ln410">  void SetRepeatedInt32 (Message* message,</a>
<a name="ln411">                         const FieldDescriptor* field, int index, int32  value) const;</a>
<a name="ln412">  void SetRepeatedInt64 (Message* message,</a>
<a name="ln413">                         const FieldDescriptor* field, int index, int64  value) const;</a>
<a name="ln414">  void SetRepeatedUInt32(Message* message,</a>
<a name="ln415">                         const FieldDescriptor* field, int index, uint32 value) const;</a>
<a name="ln416">  void SetRepeatedUInt64(Message* message,</a>
<a name="ln417">                         const FieldDescriptor* field, int index, uint64 value) const;</a>
<a name="ln418">  void SetRepeatedFloat (Message* message,</a>
<a name="ln419">                         const FieldDescriptor* field, int index, float  value) const;</a>
<a name="ln420">  void SetRepeatedDouble(Message* message,</a>
<a name="ln421">                         const FieldDescriptor* field, int index, double value) const;</a>
<a name="ln422">  void SetRepeatedBool  (Message* message,</a>
<a name="ln423">                         const FieldDescriptor* field, int index, bool   value) const;</a>
<a name="ln424">  void SetRepeatedString(Message* message,</a>
<a name="ln425">                         const FieldDescriptor* field, int index,</a>
<a name="ln426">                         const string&amp; value) const;</a>
<a name="ln427">  void SetRepeatedEnum(Message* message, const FieldDescriptor* field,</a>
<a name="ln428">                       int index, const EnumValueDescriptor* value) const;</a>
<a name="ln429">  void SetRepeatedEnumValue(Message* message, const FieldDescriptor* field,</a>
<a name="ln430">                            int index, int value) const;</a>
<a name="ln431">  // Get a mutable pointer to a field with a message type.</a>
<a name="ln432">  Message* MutableRepeatedMessage(Message* message,</a>
<a name="ln433">                                  const FieldDescriptor* field,</a>
<a name="ln434">                                  int index) const;</a>
<a name="ln435"> </a>
<a name="ln436">  void AddInt32 (Message* message,</a>
<a name="ln437">                 const FieldDescriptor* field, int32  value) const;</a>
<a name="ln438">  void AddInt64 (Message* message,</a>
<a name="ln439">                 const FieldDescriptor* field, int64  value) const;</a>
<a name="ln440">  void AddUInt32(Message* message,</a>
<a name="ln441">                 const FieldDescriptor* field, uint32 value) const;</a>
<a name="ln442">  void AddUInt64(Message* message,</a>
<a name="ln443">                 const FieldDescriptor* field, uint64 value) const;</a>
<a name="ln444">  void AddFloat (Message* message,</a>
<a name="ln445">                 const FieldDescriptor* field, float  value) const;</a>
<a name="ln446">  void AddDouble(Message* message,</a>
<a name="ln447">                 const FieldDescriptor* field, double value) const;</a>
<a name="ln448">  void AddBool  (Message* message,</a>
<a name="ln449">                 const FieldDescriptor* field, bool   value) const;</a>
<a name="ln450">  void AddString(Message* message,</a>
<a name="ln451">                 const FieldDescriptor* field, const string&amp; value) const;</a>
<a name="ln452">  void AddEnum(Message* message,</a>
<a name="ln453">               const FieldDescriptor* field,</a>
<a name="ln454">               const EnumValueDescriptor* value) const;</a>
<a name="ln455">  void AddEnumValue(Message* message,</a>
<a name="ln456">                    const FieldDescriptor* field,</a>
<a name="ln457">                    int value) const;</a>
<a name="ln458">  Message* AddMessage(Message* message, const FieldDescriptor* field,</a>
<a name="ln459">                      MessageFactory* factory = NULL) const;</a>
<a name="ln460">  void AddAllocatedMessage(</a>
<a name="ln461">      Message* message, const FieldDescriptor* field,</a>
<a name="ln462">      Message* new_entry) const;</a>
<a name="ln463"> </a>
<a name="ln464">  const FieldDescriptor* FindKnownExtensionByName(const string&amp; name) const;</a>
<a name="ln465">  const FieldDescriptor* FindKnownExtensionByNumber(int number) const;</a>
<a name="ln466"> </a>
<a name="ln467">  bool SupportsUnknownEnumValues() const;</a>
<a name="ln468"> </a>
<a name="ln469">  // This value for arena_offset_ indicates that there is no arena pointer in</a>
<a name="ln470">  // this message (e.g., old generated code).</a>
<a name="ln471">  static const int kNoArenaPointer = -1;</a>
<a name="ln472"> </a>
<a name="ln473">  // This value for unknown_field_offset_ indicates that there is no</a>
<a name="ln474">  // UnknownFieldSet in this message, and that instead, we are using the</a>
<a name="ln475">  // Zero-Overhead Arena Pointer trick. When this is the case, arena_offset_</a>
<a name="ln476">  // actually indexes to an InternalMetadataWithArena instance, which can return</a>
<a name="ln477">  // either an arena pointer or an UnknownFieldSet or both. It is never the case</a>
<a name="ln478">  // that unknown_field_offset_ == kUnknownFieldSetInMetadata &amp;&amp; arena_offset_</a>
<a name="ln479">  // == kNoArenaPointer.</a>
<a name="ln480">  static const int kUnknownFieldSetInMetadata = -1;</a>
<a name="ln481"> </a>
<a name="ln482"> protected:</a>
<a name="ln483">  void* MutableRawRepeatedField(</a>
<a name="ln484">      Message* message, const FieldDescriptor* field, FieldDescriptor::CppType,</a>
<a name="ln485">      int ctype, const Descriptor* desc) const;</a>
<a name="ln486"> </a>
<a name="ln487">  const void* GetRawRepeatedField(</a>
<a name="ln488">      const Message&amp; message, const FieldDescriptor* field,</a>
<a name="ln489">      FieldDescriptor::CppType, int ctype,</a>
<a name="ln490">      const Descriptor* desc) const;</a>
<a name="ln491"> </a>
<a name="ln492">  virtual MessageFactory* GetMessageFactory() const;</a>
<a name="ln493"> </a>
<a name="ln494">  virtual void* RepeatedFieldData(</a>
<a name="ln495">      Message* message, const FieldDescriptor* field,</a>
<a name="ln496">      FieldDescriptor::CppType cpp_type,</a>
<a name="ln497">      const Descriptor* message_type) const;</a>
<a name="ln498"> </a>
<a name="ln499"> private:</a>
<a name="ln500">  friend class google::protobuf::flat::MetadataBuilder;</a>
<a name="ln501">  friend class upb::google_opensource::GMR_Handlers;</a>
<a name="ln502"> </a>
<a name="ln503">  const Descriptor* const descriptor_;</a>
<a name="ln504">  const ReflectionSchema schema_;</a>
<a name="ln505">  const DescriptorPool* const descriptor_pool_;</a>
<a name="ln506">  MessageFactory* const message_factory_;</a>
<a name="ln507"> </a>
<a name="ln508">  // Last non weak field index. This is an optimization when most weak fields</a>
<a name="ln509">  // are at the end of the containing message. If a message proto doesn't</a>
<a name="ln510">  // contain weak fields, then this field equals descriptor_-&gt;field_count().</a>
<a name="ln511">  int last_non_weak_field_index_;</a>
<a name="ln512"> </a>
<a name="ln513">  template &lt;class T&gt;</a>
<a name="ln514">  const T&amp; GetRawNonOneof(const Message&amp; message,</a>
<a name="ln515">                          const FieldDescriptor* field) const;</a>
<a name="ln516">  template &lt;class T&gt;</a>
<a name="ln517">  T* MutableRawNonOneof(Message* message, const FieldDescriptor* field) const;</a>
<a name="ln518"> </a>
<a name="ln519">  template &lt;typename Type&gt;</a>
<a name="ln520">  const Type&amp; GetRaw(const Message&amp; message,</a>
<a name="ln521">                            const FieldDescriptor* field) const;</a>
<a name="ln522">  template &lt;typename Type&gt;</a>
<a name="ln523">  inline Type* MutableRaw(Message* message,</a>
<a name="ln524">                          const FieldDescriptor* field) const;</a>
<a name="ln525">  template &lt;typename Type&gt;</a>
<a name="ln526">  inline const Type&amp; DefaultRaw(const FieldDescriptor* field) const;</a>
<a name="ln527"> </a>
<a name="ln528">  inline const uint32* GetHasBits(const Message&amp; message) const;</a>
<a name="ln529">  inline uint32* MutableHasBits(Message* message) const;</a>
<a name="ln530">  inline uint32 GetOneofCase(</a>
<a name="ln531">      const Message&amp; message,</a>
<a name="ln532">      const OneofDescriptor* oneof_descriptor) const;</a>
<a name="ln533">  inline uint32* MutableOneofCase(</a>
<a name="ln534">      Message* message,</a>
<a name="ln535">      const OneofDescriptor* oneof_descriptor) const;</a>
<a name="ln536">  inline const ExtensionSet&amp; GetExtensionSet(const Message&amp; message) const;</a>
<a name="ln537">  inline ExtensionSet* MutableExtensionSet(Message* message) const;</a>
<a name="ln538">  inline Arena* GetArena(Message* message) const;</a>
<a name="ln539"> </a>
<a name="ln540">  inline const InternalMetadataWithArena&amp; GetInternalMetadataWithArena(</a>
<a name="ln541">      const Message&amp; message) const;</a>
<a name="ln542"> </a>
<a name="ln543">  inline InternalMetadataWithArena*</a>
<a name="ln544">      MutableInternalMetadataWithArena(Message* message) const;</a>
<a name="ln545"> </a>
<a name="ln546">  inline bool HasBit(const Message&amp; message,</a>
<a name="ln547">                     const FieldDescriptor* field) const;</a>
<a name="ln548">  inline void SetBit(Message* message,</a>
<a name="ln549">                     const FieldDescriptor* field) const;</a>
<a name="ln550">  inline void ClearBit(Message* message,</a>
<a name="ln551">                       const FieldDescriptor* field) const;</a>
<a name="ln552">  inline void SwapBit(Message* message1,</a>
<a name="ln553">                      Message* message2,</a>
<a name="ln554">                      const FieldDescriptor* field) const;</a>
<a name="ln555"> </a>
<a name="ln556">  // This function only swaps the field. Should swap corresponding has_bit</a>
<a name="ln557">  // before or after using this function.</a>
<a name="ln558">  void SwapField(Message* message1,</a>
<a name="ln559">                 Message* message2,</a>
<a name="ln560">                 const FieldDescriptor* field) const;</a>
<a name="ln561"> </a>
<a name="ln562">  void SwapOneofField(Message* message1,</a>
<a name="ln563">                      Message* message2,</a>
<a name="ln564">                      const OneofDescriptor* oneof_descriptor) const;</a>
<a name="ln565"> </a>
<a name="ln566">  inline bool HasOneofField(const Message&amp; message,</a>
<a name="ln567">                            const FieldDescriptor* field) const;</a>
<a name="ln568">  inline void SetOneofCase(Message* message,</a>
<a name="ln569">                           const FieldDescriptor* field) const;</a>
<a name="ln570">  inline void ClearOneofField(Message* message,</a>
<a name="ln571">                              const FieldDescriptor* field) const;</a>
<a name="ln572"> </a>
<a name="ln573">  template &lt;typename Type&gt;</a>
<a name="ln574">  inline const Type&amp; GetField(const Message&amp; message,</a>
<a name="ln575">                              const FieldDescriptor* field) const;</a>
<a name="ln576">  template &lt;typename Type&gt;</a>
<a name="ln577">  inline void SetField(Message* message,</a>
<a name="ln578">                       const FieldDescriptor* field, const Type&amp; value) const;</a>
<a name="ln579">  template &lt;typename Type&gt;</a>
<a name="ln580">  inline Type* MutableField(Message* message,</a>
<a name="ln581">                            const FieldDescriptor* field) const;</a>
<a name="ln582">  template &lt;typename Type&gt;</a>
<a name="ln583">  inline const Type&amp; GetRepeatedField(const Message&amp; message,</a>
<a name="ln584">                                      const FieldDescriptor* field,</a>
<a name="ln585">                                      int index) const;</a>
<a name="ln586">  template &lt;typename Type&gt;</a>
<a name="ln587">  inline const Type&amp; GetRepeatedPtrField(const Message&amp; message,</a>
<a name="ln588">                                         const FieldDescriptor* field,</a>
<a name="ln589">                                         int index) const;</a>
<a name="ln590">  template &lt;typename Type&gt;</a>
<a name="ln591">  inline void SetRepeatedField(Message* message,</a>
<a name="ln592">                               const FieldDescriptor* field, int index,</a>
<a name="ln593">                               Type value) const;</a>
<a name="ln594">  template &lt;typename Type&gt;</a>
<a name="ln595">  inline Type* MutableRepeatedField(Message* message,</a>
<a name="ln596">                                    const FieldDescriptor* field,</a>
<a name="ln597">                                    int index) const;</a>
<a name="ln598">  template &lt;typename Type&gt;</a>
<a name="ln599">  inline void AddField(Message* message,</a>
<a name="ln600">                       const FieldDescriptor* field, const Type&amp; value) const;</a>
<a name="ln601">  template &lt;typename Type&gt;</a>
<a name="ln602">  inline Type* AddField(Message* message,</a>
<a name="ln603">                        const FieldDescriptor* field) const;</a>
<a name="ln604"> </a>
<a name="ln605">  int GetExtensionNumberOrDie(const Descriptor* type) const;</a>
<a name="ln606"> </a>
<a name="ln607">  // Internal versions of EnumValue API perform no checking. Called after checks</a>
<a name="ln608">  // by public methods.</a>
<a name="ln609">  void SetEnumValueInternal(Message* message,</a>
<a name="ln610">                            const FieldDescriptor* field,</a>
<a name="ln611">                            int value) const;</a>
<a name="ln612">  void SetRepeatedEnumValueInternal(Message* message,</a>
<a name="ln613">                                    const FieldDescriptor* field,</a>
<a name="ln614">                                    int index,</a>
<a name="ln615">                                    int value) const;</a>
<a name="ln616">  void AddEnumValueInternal(Message* message,</a>
<a name="ln617">                            const FieldDescriptor* field,</a>
<a name="ln618">                            int value) const;</a>
<a name="ln619"> </a>
<a name="ln620"> </a>
<a name="ln621">  Message* UnsafeArenaReleaseMessage(Message* message,</a>
<a name="ln622">                                     const FieldDescriptor* field,</a>
<a name="ln623">                                     MessageFactory* factory = NULL) const;</a>
<a name="ln624"> </a>
<a name="ln625">  void UnsafeArenaSetAllocatedMessage(Message* message,</a>
<a name="ln626">                                      Message* sub_message,</a>
<a name="ln627">                                      const FieldDescriptor* field) const;</a>
<a name="ln628"> </a>
<a name="ln629">  internal::MapFieldBase* MapData(</a>
<a name="ln630">      Message* message, const FieldDescriptor* field) const;</a>
<a name="ln631"> </a>
<a name="ln632">  friend inline  // inline so nobody can call this function.</a>
<a name="ln633">      void</a>
<a name="ln634">      RegisterAllTypesInternal(const Metadata* file_level_metadata, int size);</a>
<a name="ln635">  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(GeneratedMessageReflection);</a>
<a name="ln636">};</a>
<a name="ln637"> </a>
<a name="ln638">// There are some places in proto2 where dynamic_cast would be useful as an</a>
<a name="ln639">// optimization.  For example, take Message::MergeFrom(const Message&amp; other).</a>
<a name="ln640">// For a given generated message FooMessage, we generate these two methods:</a>
<a name="ln641">//   void MergeFrom(const FooMessage&amp; other);</a>
<a name="ln642">//   void MergeFrom(const Message&amp; other);</a>
<a name="ln643">// The former method can be implemented directly in terms of FooMessage's</a>
<a name="ln644">// inline accessors, but the latter method must work with the reflection</a>
<a name="ln645">// interface.  However, if the parameter to the latter method is actually of</a>
<a name="ln646">// type FooMessage, then we'd like to be able to just call the other method</a>
<a name="ln647">// as an optimization.  So, we use dynamic_cast to check this.</a>
<a name="ln648">//</a>
<a name="ln649">// That said, dynamic_cast requires RTTI, which many people like to disable</a>
<a name="ln650">// for performance and code size reasons.  When RTTI is not available, we</a>
<a name="ln651">// still need to produce correct results.  So, in this case we have to fall</a>
<a name="ln652">// back to using reflection, which is what we would have done anyway if the</a>
<a name="ln653">// objects were not of the exact same class.</a>
<a name="ln654">//</a>
<a name="ln655">// dynamic_cast_if_available() implements this logic.  If RTTI is</a>
<a name="ln656">// enabled, it does a dynamic_cast.  If RTTI is disabled, it just returns</a>
<a name="ln657">// NULL.</a>
<a name="ln658">//</a>
<a name="ln659">// If you need to compile without RTTI, simply #define GOOGLE_PROTOBUF_NO_RTTI.</a>
<a name="ln660">// On MSVC, this should be detected automatically.</a>
<a name="ln661">template&lt;typename To, typename From&gt;</a>
<a name="ln662">inline To dynamic_cast_if_available(From from) {</a>
<a name="ln663">#if defined(GOOGLE_PROTOBUF_NO_RTTI) || (defined(_MSC_VER)&amp;&amp;!defined(_CPPRTTI))</a>
<a name="ln664">  // Avoid the compiler warning about unused variables.</a>
<a name="ln665">  (void)from;</a>
<a name="ln666">  return NULL;</a>
<a name="ln667">#else</a>
<a name="ln668">  return dynamic_cast&lt;To&gt;(from);</a>
<a name="ln669">#endif</a>
<a name="ln670">}</a>
<a name="ln671"> </a>
<a name="ln672">// Tries to downcast this message to a generated message type.</a>
<a name="ln673">// Returns NULL if this class is not an instance of T.</a>
<a name="ln674">//</a>
<a name="ln675">// This is like dynamic_cast_if_available, except it works even when</a>
<a name="ln676">// dynamic_cast is not available by using Reflection.  However it only works</a>
<a name="ln677">// with Message objects.</a>
<a name="ln678">//</a>
<a name="ln679">// TODO(haberman): can we remove dynamic_cast_if_available in favor of this?</a>
<a name="ln680">template &lt;typename T&gt;</a>
<a name="ln681">T* DynamicCastToGenerated(const Message* from) {</a>
<a name="ln682">  // Compile-time assert that T is a generated type that has a</a>
<a name="ln683">  // default_instance() accessor, but avoid actually calling it.</a>
<a name="ln684">  const T&amp;(*get_default_instance)() = &amp;T::default_instance;</a>
<a name="ln685">  (void)get_default_instance;</a>
<a name="ln686"> </a>
<a name="ln687">  // Compile-time assert that T is a subclass of google::protobuf::Message.</a>
<a name="ln688">  const Message* unused = static_cast&lt;T*&gt;(NULL);</a>
<a name="ln689">  (void)unused;</a>
<a name="ln690"> </a>
<a name="ln691">#if defined(GOOGLE_PROTOBUF_NO_RTTI) || \</a>
<a name="ln692">  (defined(_MSC_VER) &amp;&amp; !defined(_CPPRTTI))</a>
<a name="ln693">  bool ok = &amp;T::default_instance() ==</a>
<a name="ln694">            from-&gt;GetReflection()-&gt;GetMessageFactory()-&gt;GetPrototype(</a>
<a name="ln695">                from-&gt;GetDescriptor());</a>
<a name="ln696">  return ok ? down_cast&lt;T*&gt;(from) : NULL;</a>
<a name="ln697">#else</a>
<a name="ln698">  return dynamic_cast&lt;T*&gt;(from);</a>
<a name="ln699">#endif</a>
<a name="ln700">}</a>
<a name="ln701"> </a>
<a name="ln702">template &lt;typename T&gt;</a>
<a name="ln703">T* DynamicCastToGenerated(Message* from) {</a>
<a name="ln704">  const Message* message_const = from;</a>
<a name="ln705">  return const_cast&lt;T*&gt;(DynamicCastToGenerated&lt;const T&gt;(message_const));</a>
<a name="ln706">}</a>
<a name="ln707"> </a>
<a name="ln708">LIBPROTOBUF_EXPORT void AssignDescriptors(</a>
<a name="ln709">    const string&amp; filename, const MigrationSchema* schemas,</a>
<a name="ln710">    const Message* const* default_instances_, const uint32* offsets,</a>
<a name="ln711">    MessageFactory* factory,</a>
<a name="ln712">    // update the following descriptor arrays.</a>
<a name="ln713">    Metadata* file_level_metadata,</a>
<a name="ln714">    const EnumDescriptor** file_level_enum_descriptors,</a>
<a name="ln715">    const ServiceDescriptor** file_level_service_descriptors);</a>
<a name="ln716"> </a>
<a name="ln717">LIBPROTOBUF_EXPORT void RegisterAllTypes(const Metadata* file_level_metadata, int size);</a>
<a name="ln718"> </a>
<a name="ln719">// These cannot be in lite so we put them in the reflection.</a>
<a name="ln720">LIBPROTOBUF_EXPORT void UnknownFieldSetSerializer(const uint8* base, uint32 offset, uint32 tag,</a>
<a name="ln721">                               uint32 has_offset,</a>
<a name="ln722">                               ::google::protobuf::io::CodedOutputStream* output);</a>
<a name="ln723"> </a>
<a name="ln724">}  // namespace internal</a>
<a name="ln725">}  // namespace protobuf</a>
<a name="ln726"> </a>
<a name="ln727">}  // namespace google</a>
<a name="ln728">#endif  // GOOGLE_PROTOBUF_GENERATED_MESSAGE_REFLECTION_H__</a>

</code></pre>
<div class="balloon" rel="144"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1028/" target="_blank">V1028</a> Possible overflow. Consider casting operands, not the result.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
