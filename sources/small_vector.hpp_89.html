
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>small_vector.hpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//////////////////////////////////////////////////////////////////////////////</a>
<a name="ln2">//</a>
<a name="ln3">// (C) Copyright Ion Gaztanaga 2015-2015. Distributed under the Boost</a>
<a name="ln4">// Software License, Version 1.0. (See accompanying file</a>
<a name="ln5">// LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)</a>
<a name="ln6">//</a>
<a name="ln7">// See http://www.boost.org/libs/container for documentation.</a>
<a name="ln8">//</a>
<a name="ln9">//////////////////////////////////////////////////////////////////////////////</a>
<a name="ln10"> </a>
<a name="ln11">#ifndef BOOST_CONTAINER_CONTAINER_SMALL_VECTOR_HPP</a>
<a name="ln12">#define BOOST_CONTAINER_CONTAINER_SMALL_VECTOR_HPP</a>
<a name="ln13"> </a>
<a name="ln14">#ifndef BOOST_CONFIG_HPP</a>
<a name="ln15">#  include &lt;boost/config.hpp&gt;</a>
<a name="ln16">#endif</a>
<a name="ln17"> </a>
<a name="ln18">#if defined(BOOST_HAS_PRAGMA_ONCE)</a>
<a name="ln19">#  pragma once</a>
<a name="ln20">#endif</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;boost/container/detail/config_begin.hpp&gt;</a>
<a name="ln23">#include &lt;boost/container/detail/workaround.hpp&gt;</a>
<a name="ln24"> </a>
<a name="ln25">// container</a>
<a name="ln26">#include &lt;boost/container/container_fwd.hpp&gt;</a>
<a name="ln27">#include &lt;boost/container/vector.hpp&gt;</a>
<a name="ln28">#include &lt;boost/container/allocator_traits.hpp&gt;</a>
<a name="ln29">#include &lt;boost/container/new_allocator.hpp&gt; //new_allocator</a>
<a name="ln30">// container/detail</a>
<a name="ln31">#include &lt;boost/container/detail/type_traits.hpp&gt;</a>
<a name="ln32">#include &lt;boost/container/detail/version_type.hpp&gt;</a>
<a name="ln33"> </a>
<a name="ln34">//move</a>
<a name="ln35">#include &lt;boost/move/adl_move_swap.hpp&gt;</a>
<a name="ln36">#include &lt;boost/move/iterator.hpp&gt;</a>
<a name="ln37"> </a>
<a name="ln38">//move/detail</a>
<a name="ln39">#if defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES)</a>
<a name="ln40">#include &lt;boost/move/detail/fwd_macros.hpp&gt;</a>
<a name="ln41">#endif</a>
<a name="ln42"> </a>
<a name="ln43">//std</a>
<a name="ln44">#if !defined(BOOST_NO_CXX11_HDR_INITIALIZER_LIST)</a>
<a name="ln45">#include &lt;initializer_list&gt;   //for std::initializer_list</a>
<a name="ln46">#endif</a>
<a name="ln47"> </a>
<a name="ln48">namespace boost {</a>
<a name="ln49">namespace container {</a>
<a name="ln50"> </a>
<a name="ln51">#ifndef BOOST_CONTAINER_DOXYGEN_INVOKED</a>
<a name="ln52"> </a>
<a name="ln53">template &lt;class T, class Allocator = new_allocator&lt;T&gt; &gt;</a>
<a name="ln54">class small_vector_base;</a>
<a name="ln55"> </a>
<a name="ln56">#endif</a>
<a name="ln57"> </a>
<a name="ln58">//! A non-standard allocator used to implement `small_vector`.</a>
<a name="ln59">//! Users should never use it directly. It is described here</a>
<a name="ln60">//! for documentation purposes.</a>
<a name="ln61">//! </a>
<a name="ln62">//! This allocator inherits from a standard-conforming allocator</a>
<a name="ln63">//! and forwards member functions to the standard allocator except</a>
<a name="ln64">//! when internal storage is being used as memory source.</a>
<a name="ln65">//!</a>
<a name="ln66">//! This allocator is a &quot;partially_propagable&quot; allocator and</a>
<a name="ln67">//! defines `is_partially_propagable` as true_type.</a>
<a name="ln68">//! </a>
<a name="ln69">//! A partially propagable allocator means that not all storage</a>
<a name="ln70">//! allocatod by an instance of `small_vector_allocator` can be</a>
<a name="ln71">//! deallocated by another instance of this type, even if both</a>
<a name="ln72">//! instances compare equal or an instance is propagated to another</a>
<a name="ln73">//! one using the copy/move constructor or assignment. The storage that</a>
<a name="ln74">//! can never be propagated is identified by `storage_is_unpropagable(p)`.</a>
<a name="ln75">//!</a>
<a name="ln76">//! `boost::container::vector` supports partially propagable allocators</a>
<a name="ln77">//! fallbacking to deep copy/swap/move operations when internal storage</a>
<a name="ln78">//! is being used to store vector elements.</a>
<a name="ln79">//!</a>
<a name="ln80">//! `small_vector_allocator` assumes that will be instantiated as</a>
<a name="ln81">//! `boost::container::vector&lt; T, small_vector_allocator&lt;Allocator&gt; &gt;`</a>
<a name="ln82">//! and internal storage can be obtained downcasting that vector</a>
<a name="ln83">//! to `small_vector_base&lt;T&gt;`.</a>
<a name="ln84">template&lt;class Allocator&gt;</a>
<a name="ln85">class small_vector_allocator</a>
<a name="ln86">   : public Allocator</a>
<a name="ln87">{</a>
<a name="ln88">   typedef unsigned int allocation_type;</a>
<a name="ln89">   #ifndef BOOST_CONTAINER_DOXYGEN_INVOKED</a>
<a name="ln90">   private:</a>
<a name="ln91"> </a>
<a name="ln92">   BOOST_COPYABLE_AND_MOVABLE(small_vector_allocator)</a>
<a name="ln93"> </a>
<a name="ln94">   BOOST_CONTAINER_FORCEINLINE const Allocator &amp;as_base() const</a>
<a name="ln95">   {  return static_cast&lt;const Allocator&amp;&gt;(*this);  }</a>
<a name="ln96"> </a>
<a name="ln97">   BOOST_CONTAINER_FORCEINLINE Allocator &amp;as_base() </a>
<a name="ln98">   {  return static_cast&lt;Allocator&amp;&gt;(*this);  }</a>
<a name="ln99"> </a>
<a name="ln100">   #endif   //#ifndef BOOST_CONTAINER_DOXYGEN_INVOKED</a>
<a name="ln101"> </a>
<a name="ln102">   public:</a>
<a name="ln103">   #ifndef BOOST_CONTAINER_DOXYGEN_INVOKED</a>
<a name="ln104">   typedef allocator_traits&lt;Allocator&gt; allocator_traits_type;</a>
<a name="ln105">   #endif   //#ifndef BOOST_CONTAINER_DOXYGEN_INVOKED</a>
<a name="ln106"> </a>
<a name="ln107">   typedef typename allocator_traits&lt;Allocator&gt;::value_type          value_type;</a>
<a name="ln108">   typedef typename allocator_traits&lt;Allocator&gt;::pointer             pointer;</a>
<a name="ln109">   typedef typename allocator_traits&lt;Allocator&gt;::const_pointer       const_pointer;</a>
<a name="ln110">   typedef typename allocator_traits&lt;Allocator&gt;::reference           reference;</a>
<a name="ln111">   typedef typename allocator_traits&lt;Allocator&gt;::const_reference     const_reference;</a>
<a name="ln112">   typedef typename allocator_traits&lt;Allocator&gt;::size_type           size_type;</a>
<a name="ln113">   typedef typename allocator_traits&lt;Allocator&gt;::difference_type     difference_type;</a>
<a name="ln114">   typedef typename allocator_traits&lt;Allocator&gt;::void_pointer        void_pointer;</a>
<a name="ln115">   typedef typename allocator_traits&lt;Allocator&gt;::const_void_pointer  const_void_pointer;</a>
<a name="ln116"> </a>
<a name="ln117">   typedef typename allocator_traits&lt;Allocator&gt;::propagate_on_container_copy_assignment   propagate_on_container_copy_assignment;</a>
<a name="ln118">   typedef typename allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment   propagate_on_container_move_assignment;</a>
<a name="ln119">   typedef typename allocator_traits&lt;Allocator&gt;::propagate_on_container_swap              propagate_on_container_swap;</a>
<a name="ln120">   //! An integral constant with member `value == false`</a>
<a name="ln121">   typedef BOOST_CONTAINER_IMPDEF(dtl::bool_&lt;false&gt;)                         is_always_equal;</a>
<a name="ln122">   //! An integral constant with member `value == true`</a>
<a name="ln123">   typedef BOOST_CONTAINER_IMPDEF(dtl::bool_&lt;true&gt;)                          is_partially_propagable;</a>
<a name="ln124"> </a>
<a name="ln125">   BOOST_CONTAINER_DOCIGN(typedef dtl::version_type&lt;small_vector_allocator BOOST_CONTAINER_I 1&gt;  version;)</a>
<a name="ln126"> </a>
<a name="ln127">   //!Obtains an small_vector_allocator that allocates</a>
<a name="ln128">   //!objects of type T2</a>
<a name="ln129">   template&lt;class T2&gt;</a>
<a name="ln130">   struct rebind</a>
<a name="ln131">   {</a>
<a name="ln132">      typedef typename allocator_traits&lt;Allocator&gt;::template rebind_alloc&lt;T2&gt;::type other;</a>
<a name="ln133">   };</a>
<a name="ln134"> </a>
<a name="ln135">   #if !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) || defined(BOOST_CONTAINER_DOXYGEN_INVOKED)</a>
<a name="ln136">      //!Constructor from arbitrary arguments</a>
<a name="ln137">      template&lt;class ...Args&gt;</a>
<a name="ln138">      BOOST_CONTAINER_FORCEINLINE explicit small_vector_allocator(BOOST_FWD_REF(Args) ...args)</a>
<a name="ln139">         : Allocator(::boost::forward&lt;Args&gt;(args)...)</a>
<a name="ln140">      {}</a>
<a name="ln141">   #else</a>
<a name="ln142">      #define BOOST_CONTAINER_SMALL_VECTOR_ALLOCATOR_CTOR_CODE(N) \</a>
<a name="ln143">      BOOST_MOVE_TMPL_LT##N BOOST_MOVE_CLASS##N BOOST_MOVE_GT##N \</a>
<a name="ln144">      BOOST_CONTAINER_FORCEINLINE explicit small_vector_allocator(BOOST_MOVE_UREF##N)\</a>
<a name="ln145">         : Allocator(BOOST_MOVE_FWD##N)\</a>
<a name="ln146">      {}\</a>
<a name="ln147">      //</a>
<a name="ln148">      BOOST_MOVE_ITERATE_0TO9(BOOST_CONTAINER_SMALL_VECTOR_ALLOCATOR_CTOR_CODE)</a>
<a name="ln149">      #undef BOOST_CONTAINER_SMALL_VECTOR_ALLOCATOR_CTOR_CODE</a>
<a name="ln150">   #endif</a>
<a name="ln151"> </a>
<a name="ln152">   //!Constructor from other small_vector_allocator.</a>
<a name="ln153">   //!Never throws</a>
<a name="ln154">   BOOST_CONTAINER_FORCEINLINE small_vector_allocator</a>
<a name="ln155">      (const small_vector_allocator &amp;other) BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln156">      : Allocator(other.as_base())</a>
<a name="ln157">   {}</a>
<a name="ln158"> </a>
<a name="ln159">   //!Move constructor from small_vector_allocator.</a>
<a name="ln160">   //!Never throws</a>
<a name="ln161">   BOOST_CONTAINER_FORCEINLINE small_vector_allocator</a>
<a name="ln162">      (BOOST_RV_REF(small_vector_allocator) other) BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln163">      : Allocator(::boost::move(other.as_base()))</a>
<a name="ln164">   {}</a>
<a name="ln165"> </a>
<a name="ln166">   //!Constructor from related small_vector_allocator.</a>
<a name="ln167">   //!Never throws</a>
<a name="ln168">   template&lt;class OtherAllocator&gt;</a>
<a name="ln169">   BOOST_CONTAINER_FORCEINLINE small_vector_allocator</a>
<a name="ln170">      (const small_vector_allocator&lt;OtherAllocator&gt; &amp;other) BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln171">      : Allocator(other.as_base())</a>
<a name="ln172">   {}</a>
<a name="ln173"> </a>
<a name="ln174">   //!Move constructor from related small_vector_allocator.</a>
<a name="ln175">   //!Never throws</a>
<a name="ln176">   template&lt;class OtherAllocator&gt;</a>
<a name="ln177">   BOOST_CONTAINER_FORCEINLINE small_vector_allocator</a>
<a name="ln178">      (BOOST_RV_REF(small_vector_allocator&lt;OtherAllocator&gt;) other) BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln179">      : Allocator(::boost::move(other.as_base()))</a>
<a name="ln180">   {}</a>
<a name="ln181"> </a>
<a name="ln182">   //!Assignment from other small_vector_allocator.</a>
<a name="ln183">   //!Never throws</a>
<a name="ln184">   BOOST_CONTAINER_FORCEINLINE small_vector_allocator &amp;</a>
<a name="ln185">      operator=(BOOST_COPY_ASSIGN_REF(small_vector_allocator) other) BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln186">   {  return static_cast&lt;small_vector_allocator&amp;&gt;(this-&gt;Allocator::operator=(other.as_base()));  }</a>
<a name="ln187"> </a>
<a name="ln188">   //!Move constructor from other small_vector_allocator.</a>
<a name="ln189">   //!Never throws</a>
<a name="ln190">   BOOST_CONTAINER_FORCEINLINE small_vector_allocator &amp;</a>
<a name="ln191">      operator=(BOOST_RV_REF(small_vector_allocator) other) BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln192">   {  return static_cast&lt;small_vector_allocator&amp;&gt;(this-&gt;Allocator::operator=(::boost::move(other.as_base())));  }</a>
<a name="ln193"> </a>
<a name="ln194">   //!Assignment from related small_vector_allocator.</a>
<a name="ln195">   //!Never throws</a>
<a name="ln196">   template&lt;class OtherAllocator&gt;</a>
<a name="ln197">   BOOST_CONTAINER_FORCEINLINE small_vector_allocator &amp;</a>
<a name="ln198">      operator=(BOOST_COPY_ASSIGN_REF(small_vector_allocator&lt;OtherAllocator&gt;) other) BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln199">   {  return static_cast&lt;small_vector_allocator&amp;&gt;(this-&gt;Allocator::operator=(other.as_base()));  }</a>
<a name="ln200"> </a>
<a name="ln201">   //!Move assignment from related small_vector_allocator.</a>
<a name="ln202">   //!Never throws</a>
<a name="ln203">   template&lt;class OtherAllocator&gt;</a>
<a name="ln204">   BOOST_CONTAINER_FORCEINLINE small_vector_allocator &amp;</a>
<a name="ln205">      operator=(BOOST_RV_REF(small_vector_allocator&lt;OtherAllocator&gt;) other) BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln206">   {  return static_cast&lt;small_vector_allocator&amp;&gt;(this-&gt;Allocator::operator=(::boost::move(other.as_base())));  }</a>
<a name="ln207"> </a>
<a name="ln208">   //!Allocates storage from the standard-conforming allocator</a>
<a name="ln209">   BOOST_CONTAINER_FORCEINLINE pointer allocate(size_type count, const_void_pointer hint = const_void_pointer())</a>
<a name="ln210">   {  return allocator_traits_type::allocate(this-&gt;as_base(), count, hint);  }</a>
<a name="ln211"> </a>
<a name="ln212">   //!Deallocates previously allocated memory.</a>
<a name="ln213">   //!Never throws</a>
<a name="ln214">   void deallocate(pointer ptr, size_type n) BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln215">   {</a>
<a name="ln216">      if(!this-&gt;is_internal_storage(ptr))</a>
<a name="ln217">         allocator_traits_type::deallocate(this-&gt;as_base(), ptr, n);</a>
<a name="ln218">   }</a>
<a name="ln219"> </a>
<a name="ln220">   //!Returns the maximum number of elements that could be allocated.</a>
<a name="ln221">   //!Never throws</a>
<a name="ln222">   BOOST_CONTAINER_FORCEINLINE size_type max_size() const BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln223">   {  return allocator_traits_type::max_size(this-&gt;as_base());   }</a>
<a name="ln224"> </a>
<a name="ln225">   small_vector_allocator select_on_container_copy_construction() const</a>
<a name="ln226">   {  return small_vector_allocator(allocator_traits_type::select_on_container_copy_construction(this-&gt;as_base())); }</a>
<a name="ln227"> </a>
<a name="ln228">   bool storage_is_unpropagable(pointer p) const</a>
<a name="ln229">   {  return this-&gt;is_internal_storage(p) || allocator_traits_type::storage_is_unpropagable(this-&gt;as_base(), p);  }</a>
<a name="ln230"> </a>
<a name="ln231">   //!Swaps two allocators, does nothing</a>
<a name="ln232">   //!because this small_vector_allocator is stateless</a>
<a name="ln233">   BOOST_CONTAINER_FORCEINLINE friend void swap(small_vector_allocator &amp;l, small_vector_allocator &amp;r) BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln234">   {  boost::adl_move_swap(l.as_base(), r.as_base());  }</a>
<a name="ln235"> </a>
<a name="ln236">   //!An small_vector_allocator always compares to true, as memory allocated with one</a>
<a name="ln237">   //!instance can be deallocated by another instance (except for unpropagable storage)</a>
<a name="ln238">   BOOST_CONTAINER_FORCEINLINE friend bool operator==(const small_vector_allocator &amp;l, const small_vector_allocator &amp;r) BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln239">   {  return allocator_traits_type::equal(l.as_base(), r.as_base());  }</a>
<a name="ln240"> </a>
<a name="ln241">   //!An small_vector_allocator always compares to false, as memory allocated with one</a>
<a name="ln242">   //!instance can be deallocated by another instance</a>
<a name="ln243">   BOOST_CONTAINER_FORCEINLINE friend bool operator!=(const small_vector_allocator &amp;l, const small_vector_allocator &amp;r) BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln244">   {  return !(l == r);   }</a>
<a name="ln245"> </a>
<a name="ln246">   #ifndef BOOST_CONTAINER_DOXYGEN_INVOKED</a>
<a name="ln247">   /*</a>
<a name="ln248">   //!An advanced function that offers in-place expansion shrink to fit and new allocation</a>
<a name="ln249">   //!capabilities. Memory allocated with this function can only be deallocated with deallocate()</a>
<a name="ln250">   //!or deallocate_many().</a>
<a name="ln251">   //!This function is available only with Version == 2</a>
<a name="ln252">   pointer allocation_command(allocation_type command,</a>
<a name="ln253">                         size_type limit_size,</a>
<a name="ln254">                         size_type &amp;prefer_in_recvd_out_size,</a>
<a name="ln255">                         pointer &amp;reuse)</a>
<a name="ln256">   {  return allocator_traits_type::allocation_command(command, limit_size, prefer_in_recvd_out_size, reuse);  }</a>
<a name="ln257"> </a>
<a name="ln258">   //!Returns maximum the number of objects the previously allocated memory</a>
<a name="ln259">   //!pointed by p can hold.</a>
<a name="ln260">   //!Memory must not have been allocated with</a>
<a name="ln261">   //!allocate_one or allocate_individual.</a>
<a name="ln262">   //!This function is available only with Version == 2</a>
<a name="ln263">   size_type size(pointer p) const BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln264">   {  return allocator_traits_type::size(p);  }</a>
<a name="ln265">   */</a>
<a name="ln266">   private:</a>
<a name="ln267">   /*</a>
<a name="ln268">   //!Allocates just one object. Memory allocated with this function</a>
<a name="ln269">   //!must be deallocated only with deallocate_one().</a>
<a name="ln270">   //!Throws bad_alloc if there is no enough memory</a>
<a name="ln271">   //!This function is available only with Version == 2</a>
<a name="ln272">   using Allocator::allocate_one;</a>
<a name="ln273">   using Allocator::allocate_individual;</a>
<a name="ln274">   using Allocator::deallocate_one;</a>
<a name="ln275">   using Allocator::deallocate_individual;</a>
<a name="ln276">   using Allocator::allocate_many;</a>
<a name="ln277">   using Allocator::deallocate_many;*/</a>
<a name="ln278"> </a>
<a name="ln279">   BOOST_CONTAINER_FORCEINLINE bool is_internal_storage(const_pointer p) const</a>
<a name="ln280">   {  return this-&gt;internal_storage() == p;  }</a>
<a name="ln281"> </a>
<a name="ln282">   BOOST_CONTAINER_FORCEINLINE</a>
<a name="ln283">   const_pointer internal_storage() const</a>
<a name="ln284">   {</a>
<a name="ln285">      typedef typename Allocator::value_type                                              value_type;</a>
<a name="ln286">      typedef typename allocator_traits_type::size_type                                   size_type;</a>
<a name="ln287">      typedef vector_alloc_holder&lt; small_vector_allocator&lt;Allocator&gt;, size_type &gt;         vector_alloc_holder_t;</a>
<a name="ln288">      typedef vector&lt;value_type, small_vector_allocator&lt;Allocator&gt; &gt;                      vector_base;</a>
<a name="ln289">      typedef small_vector_base&lt;value_type, Allocator&gt;                                    derived_type;</a>
<a name="ln290">      //</a>
<a name="ln291">      const vector_alloc_holder_t &amp;v_holder = static_cast&lt;const vector_alloc_holder_t &amp;&gt;(*this);</a>
<a name="ln292">      const vector_base &amp;v_base = reinterpret_cast&lt;const vector_base &amp;&gt;(v_holder);</a>
<a name="ln293">      const derived_type &amp;d_base = static_cast&lt;const derived_type &amp;&gt;(v_base);</a>
<a name="ln294">      return d_base.internal_storage();</a>
<a name="ln295">   }</a>
<a name="ln296"> </a>
<a name="ln297">   BOOST_CONTAINER_FORCEINLINE</a>
<a name="ln298">   pointer internal_storage()</a>
<a name="ln299">   {</a>
<a name="ln300">      typedef typename Allocator::value_type                                              value_type;</a>
<a name="ln301">      typedef typename allocator_traits_type::size_type                                   size_type;</a>
<a name="ln302">      typedef vector_alloc_holder&lt; small_vector_allocator&lt;Allocator&gt;, size_type &gt;         vector_alloc_holder_t;</a>
<a name="ln303">      typedef vector&lt;value_type, small_vector_allocator&lt;Allocator&gt; &gt;                      vector_base;</a>
<a name="ln304">      typedef small_vector_base&lt;value_type, Allocator&gt;                                    derived_type;</a>
<a name="ln305">      //</a>
<a name="ln306">      vector_alloc_holder_t &amp;v_holder = static_cast&lt;vector_alloc_holder_t &amp;&gt;(*this);</a>
<a name="ln307">      vector_base &amp;v_base = reinterpret_cast&lt;vector_base &amp;&gt;(v_holder);</a>
<a name="ln308">      derived_type &amp;d_base = static_cast&lt;derived_type &amp;&gt;(v_base);</a>
<a name="ln309">      return d_base.internal_storage();</a>
<a name="ln310">   }</a>
<a name="ln311">   #endif   //#ifndef BOOST_CONTAINER_DOXYGEN_INVOKED</a>
<a name="ln312">};</a>
<a name="ln313"> </a>
<a name="ln314">//! This class consists of common code from all small_vector&lt;T, N&gt; types that don't depend on the</a>
<a name="ln315">//! &quot;N&quot; template parameter. This class is non-copyable and non-destructible, so this class typically</a>
<a name="ln316">//! used as reference argument to functions that read or write small vectors. Since `small_vector&lt;T, N&gt;`</a>
<a name="ln317">//! derives from `small_vector_base&lt;T&gt;`, the conversion to `small_vector_base` is implicit</a>
<a name="ln318">//! &lt;pre&gt;</a>
<a name="ln319">//!</a>
<a name="ln320">//! //Clients can pass any small_vector&lt;Foo, N&gt;.</a>
<a name="ln321">//! void read_any_small_vector_of_foo(const small_vector_base&lt;Foo&gt; &amp;in_parameter);</a>
<a name="ln322">//!</a>
<a name="ln323">//! void modify_any_small_vector_of_foo(small_vector_base&lt;Foo&gt; &amp;in_out_parameter);</a>
<a name="ln324">//!</a>
<a name="ln325">//! void some_function()</a>
<a name="ln326">//! {</a>
<a name="ln327">//! </a>
<a name="ln328">//!    small_vector&lt;Foo, 8&gt; myvector;</a>
<a name="ln329">//!</a>
<a name="ln330">//!    read_any_small_vector_of_foo(myvector);   // Reads myvector</a>
<a name="ln331">//!</a>
<a name="ln332">//!    modify_any_small_vector_of_foo(myvector); // Modifies myvector</a>
<a name="ln333">//! </a>
<a name="ln334">//! }</a>
<a name="ln335">//! &lt;/pre&gt;</a>
<a name="ln336">//!</a>
<a name="ln337">//! All `boost::container:vector` member functions are inherited. See `vector` documentation for details.</a>
<a name="ln338">//!</a>
<a name="ln339">template &lt;class T, class SecondaryAllocator&gt;</a>
<a name="ln340">class small_vector_base</a>
<a name="ln341">   : public vector&lt;T, small_vector_allocator&lt;SecondaryAllocator&gt; &gt;</a>
<a name="ln342">{</a>
<a name="ln343">   #ifndef BOOST_CONTAINER_DOXYGEN_INVOKED</a>
<a name="ln344">   public:</a>
<a name="ln345">   //Make it public as it will be inherited by small_vector and container</a>
<a name="ln346">   //must have this public member</a>
<a name="ln347">   typedef typename allocator_traits&lt;SecondaryAllocator&gt;::pointer       pointer;</a>
<a name="ln348">   typedef typename allocator_traits&lt;SecondaryAllocator&gt;::const_pointer const_pointer;</a>
<a name="ln349">   typedef typename allocator_traits&lt;SecondaryAllocator&gt;::void_pointer  void_pointer;</a>
<a name="ln350">   typedef typename allocator_traits&lt;SecondaryAllocator&gt;::const_void_pointer  const_void_pointer;</a>
<a name="ln351"> </a>
<a name="ln352">   private: </a>
<a name="ln353">   BOOST_COPYABLE_AND_MOVABLE(small_vector_base)</a>
<a name="ln354"> </a>
<a name="ln355">   friend class small_vector_allocator&lt;SecondaryAllocator&gt;;</a>
<a name="ln356"> </a>
<a name="ln357">   BOOST_CONTAINER_FORCEINLINE</a>
<a name="ln358">   const_pointer internal_storage() const BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln359">   {</a>
<a name="ln360">      typedef typename boost::intrusive::pointer_traits&lt;const_pointer&gt;::template</a>
<a name="ln361">         rebind_pointer&lt;const unsigned char&gt;::type const_char_pointer;</a>
<a name="ln362">      const_void_pointer void_p = boost::intrusive::pointer_traits&lt;const_char_pointer&gt;::</a>
<a name="ln363">         pointer_to(*m_storage_start.data);</a>
<a name="ln364">      return boost::intrusive::pointer_traits&lt;const_pointer&gt;::static_cast_from(void_p);</a>
<a name="ln365">   }</a>
<a name="ln366"> </a>
<a name="ln367">   BOOST_CONTAINER_FORCEINLINE</a>
<a name="ln368">   pointer internal_storage() BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln369">   {</a>
<a name="ln370">      typedef typename boost::intrusive::pointer_traits&lt;pointer&gt;::template</a>
<a name="ln371">         rebind_pointer&lt;unsigned char&gt;::type char_pointer;</a>
<a name="ln372">      void_pointer void_p = boost::intrusive::pointer_traits&lt;char_pointer&gt;::</a>
<a name="ln373">         pointer_to(*m_storage_start.data);</a>
<a name="ln374">      return boost::intrusive::pointer_traits&lt;pointer&gt;::static_cast_from(void_p);</a>
<a name="ln375">   }</a>
<a name="ln376"> </a>
<a name="ln377">   typedef vector&lt;T, small_vector_allocator&lt;SecondaryAllocator&gt; &gt; base_type;</a>
<a name="ln378">         base_type &amp;as_base()       { return static_cast&lt;base_type&amp;&gt;(*this); }</a>
<a name="ln379">   const base_type &amp;as_base() const { return static_cast&lt;const base_type&amp;&gt;(*this); }</a>
<a name="ln380"> </a>
<a name="ln381">   public:</a>
<a name="ln382">   typedef typename dtl::aligned_storage</a>
<a name="ln383">      &lt;sizeof(T), dtl::alignment_of&lt;T&gt;::value&gt;::type storage_type;</a>
<a name="ln384">   typedef small_vector_allocator&lt;SecondaryAllocator&gt;             allocator_type;</a>
<a name="ln385"> </a>
<a name="ln386">   protected:</a>
<a name="ln387"> </a>
<a name="ln388">   BOOST_CONTAINER_FORCEINLINE explicit small_vector_base(initial_capacity_t, std::size_t initial_capacity)</a>
<a name="ln389">      : base_type(initial_capacity_t(), this-&gt;internal_storage(), initial_capacity)</a>
<a name="ln390">   {}</a>
<a name="ln391"> </a>
<a name="ln392">   template&lt;class AllocFwd&gt;</a>
<a name="ln393">   BOOST_CONTAINER_FORCEINLINE explicit small_vector_base(initial_capacity_t, std::size_t capacity, BOOST_FWD_REF(AllocFwd) a)</a>
<a name="ln394">      : base_type(initial_capacity_t(), this-&gt;internal_storage(), capacity, ::boost::forward&lt;AllocFwd&gt;(a))</a>
<a name="ln395">   {}</a>
<a name="ln396"> </a>
<a name="ln397">   //~small_vector_base(){}</a>
<a name="ln398"> </a>
<a name="ln399">   private:</a>
<a name="ln400">   //The only member</a>
<a name="ln401">   storage_type m_storage_start;</a>
<a name="ln402"> </a>
<a name="ln403">   #endif   //#ifndef BOOST_CONTAINER_DOXYGEN_INVOKED</a>
<a name="ln404"> </a>
<a name="ln405">   public:</a>
<a name="ln406">   BOOST_CONTAINER_FORCEINLINE small_vector_base&amp; operator=(BOOST_COPY_ASSIGN_REF(small_vector_base) other)</a>
<a name="ln407">   {  return static_cast&lt;small_vector_base&amp;&gt;(this-&gt;base_type::operator=(static_cast&lt;base_type const&amp;&gt;(other)));  }</a>
<a name="ln408"> </a>
<a name="ln409">   BOOST_CONTAINER_FORCEINLINE small_vector_base&amp; operator=(BOOST_RV_REF(small_vector_base) other)</a>
<a name="ln410">   {  return static_cast&lt;small_vector_base&amp;&gt;(this-&gt;base_type::operator=(BOOST_MOVE_BASE(base_type, other))); }</a>
<a name="ln411"> </a>
<a name="ln412">   BOOST_CONTAINER_FORCEINLINE void swap(small_vector_base &amp;other)</a>
<a name="ln413">   {  return this-&gt;base_type::swap(other);  }</a>
<a name="ln414"> </a>
<a name="ln415">   #ifndef BOOST_CONTAINER_DOXYGEN_INVOKED</a>
<a name="ln416">   protected:</a>
<a name="ln417">   void move_construct_impl(base_type &amp;x, const allocator_type &amp;a)</a>
<a name="ln418">   {</a>
<a name="ln419">      if(base_type::is_propagable_from(x.get_stored_allocator(), x.data(), a, true)){</a>
<a name="ln420">         this-&gt;steal_resources(x);</a>
<a name="ln421">      }</a>
<a name="ln422">      else{</a>
<a name="ln423">         this-&gt;assign( boost::make_move_iterator(boost::movelib::iterator_to_raw_pointer(x.begin()))</a>
<a name="ln424">                     , boost::make_move_iterator(boost::movelib::iterator_to_raw_pointer(x.end  ()))</a>
<a name="ln425">                     );</a>
<a name="ln426">      }</a>
<a name="ln427">   }</a>
<a name="ln428">   #endif   //#ifndef BOOST_CONTAINER_DOXYGEN_INVOKED</a>
<a name="ln429">};</a>
<a name="ln430"> </a>
<a name="ln431">#ifndef BOOST_CONTAINER_DOXYGEN_INVOKED</a>
<a name="ln432"> </a>
<a name="ln433">/////////////////////////////////////////////////////</a>
<a name="ln434">//</a>
<a name="ln435">//          small_vector_storage_calculator</a>
<a name="ln436">//</a>
<a name="ln437">/////////////////////////////////////////////////////</a>
<a name="ln438">template&lt;std::size_t Needed, std::size_t Hdr, std::size_t SSize, bool NeedsZero = (0u == Needed || Needed &lt;= Hdr)&gt;</a>
<a name="ln439">struct small_vector_storage_calculator_helper</a>
<a name="ln440">{</a>
<a name="ln441">   static const std::size_t value = (Needed - Hdr - 1u)/SSize + 1u;</a>
<a name="ln442">};</a>
<a name="ln443"> </a>
<a name="ln444">template&lt;std::size_t Needed, std::size_t Hdr, std::size_t SSize&gt;</a>
<a name="ln445">struct small_vector_storage_calculator_helper&lt;Needed, Hdr, SSize, true&gt;</a>
<a name="ln446">{</a>
<a name="ln447">   static const std::size_t value = 0u;</a>
<a name="ln448">};</a>
<a name="ln449"> </a>
<a name="ln450">template&lt;class Storage, class Allocator, class T, std::size_t N&gt;</a>
<a name="ln451">struct small_vector_storage_calculator</a>
<a name="ln452">{</a>
<a name="ln453">   typedef small_vector_base&lt;T, Allocator&gt; svh_type;</a>
<a name="ln454">   typedef vector&lt;T, small_vector_allocator&lt;Allocator&gt; &gt; svhb_type;</a>
<a name="ln455">   static const std::size_t s_align = dtl::alignment_of&lt;Storage&gt;::value;</a>
<a name="ln456">   static const std::size_t s_size = sizeof(Storage);</a>
<a name="ln457">   static const std::size_t svh_sizeof = sizeof(svh_type);</a>
<a name="ln458">   static const std::size_t svhb_sizeof = sizeof(svhb_type);</a>
<a name="ln459">   static const std::size_t s_start = ((svhb_sizeof-1)/s_align+1)*s_align;</a>
<a name="ln460">   static const std::size_t header_bytes = svh_sizeof-s_start;</a>
<a name="ln461">   static const std::size_t needed_bytes = sizeof(T)*N;</a>
<a name="ln462">   static const std::size_t needed_extra_storages =</a>
<a name="ln463">      small_vector_storage_calculator_helper&lt;needed_bytes, header_bytes, s_size&gt;::value;</a>
<a name="ln464">};</a>
<a name="ln465"> </a>
<a name="ln466">/////////////////////////////////////////////////////</a>
<a name="ln467">//</a>
<a name="ln468">//          small_vector_storage_definer</a>
<a name="ln469">//</a>
<a name="ln470">/////////////////////////////////////////////////////</a>
<a name="ln471">template&lt;class Storage, std::size_t N&gt;</a>
<a name="ln472">struct small_vector_storage</a>
<a name="ln473">{</a>
<a name="ln474">   Storage m_rest_of_storage[N];</a>
<a name="ln475">};</a>
<a name="ln476"> </a>
<a name="ln477">template&lt;class Storage&gt;</a>
<a name="ln478">struct small_vector_storage&lt;Storage, 0&gt;</a>
<a name="ln479">{};</a>
<a name="ln480"> </a>
<a name="ln481">template&lt;class Allocator, std::size_t N&gt;</a>
<a name="ln482">struct small_vector_storage_definer</a>
<a name="ln483">{</a>
<a name="ln484">   typedef typename Allocator::value_type                                  value_type;</a>
<a name="ln485">   typedef typename small_vector_base&lt;value_type, Allocator&gt;::storage_type storage_type;</a>
<a name="ln486">   static const std::size_t needed_extra_storages =</a>
<a name="ln487">      small_vector_storage_calculator&lt;storage_type, Allocator, value_type, N&gt;::needed_extra_storages;</a>
<a name="ln488">   typedef small_vector_storage&lt;storage_type, needed_extra_storages&gt; type;</a>
<a name="ln489">};</a>
<a name="ln490"> </a>
<a name="ln491">#endif   //#ifndef BOOST_CONTAINER_DOXYGEN_INVOKED</a>
<a name="ln492"> </a>
<a name="ln493">//! small_vector is a vector-like container optimized for the case when it contains few elements.</a>
<a name="ln494">//! It contains some preallocated elements in-place, which can avoid the use of dynamic storage allocation</a>
<a name="ln495">//! when the actual number of elements is below that preallocated threshold.</a>
<a name="ln496">//!</a>
<a name="ln497">//! `small_vector&lt;T, N, Allocator&gt;` is convertible to `small_vector_base&lt;T, Allocator&gt;` that is independent</a>
<a name="ln498">//! from the preallocated element capacity, so client code does not need to be templated on that N argument.</a>
<a name="ln499">//!</a>
<a name="ln500">//! All `boost::container::vector` member functions are inherited. See `vector` documentation for details.</a>
<a name="ln501">//!</a>
<a name="ln502">//! \tparam T The type of object that is stored in the small_vector</a>
<a name="ln503">//! \tparam N The number of preallocated elements stored inside small_vector. It shall be less than Allocator::max_size();</a>
<a name="ln504">//! \tparam Allocator The allocator used for memory management when the number of elements exceeds N.</a>
<a name="ln505">template &lt;class T, std::size_t N, class Allocator BOOST_CONTAINER_DOCONLY(= new_allocator&lt;T&gt;) &gt;</a>
<a name="ln506">class small_vector : public small_vector_base&lt;T, Allocator&gt;</a>
<a name="ln507">   #ifndef BOOST_CONTAINER_DOXYGEN_INVOKED</a>
<a name="ln508">   , private small_vector_storage_definer&lt;Allocator, N&gt;::type</a>
<a name="ln509">   #endif</a>
<a name="ln510">{</a>
<a name="ln511">   #ifndef BOOST_CONTAINER_DOXYGEN_INVOKED</a>
<a name="ln512">   typedef small_vector_base&lt;T, Allocator&gt; base_type;</a>
<a name="ln513">   typedef typename small_vector_storage_definer&lt;Allocator, N&gt;::type remaining_storage_holder;</a>
<a name="ln514"> </a>
<a name="ln515">   BOOST_COPYABLE_AND_MOVABLE(small_vector)</a>
<a name="ln516"> </a>
<a name="ln517">   typedef allocator_traits&lt;typename base_type::allocator_type&gt; allocator_traits_type;</a>
<a name="ln518"> </a>
<a name="ln519">   public:</a>
<a name="ln520">   typedef small_vector_storage_calculator&lt; typename small_vector_base&lt;T, Allocator&gt;</a>
<a name="ln521">      ::storage_type, Allocator, T, N&gt; storage_test;</a>
<a name="ln522"> </a>
<a name="ln523">   static const std::size_t needed_extra_storages =  storage_test::needed_extra_storages;</a>
<a name="ln524">   static const std::size_t needed_bytes =  storage_test::needed_bytes;</a>
<a name="ln525">   static const std::size_t header_bytes =  storage_test::header_bytes;</a>
<a name="ln526">   static const std::size_t s_start =  storage_test::s_start;</a>
<a name="ln527"> </a>
<a name="ln528">   typedef typename base_type::allocator_type   allocator_type;</a>
<a name="ln529">   typedef typename base_type::size_type        size_type;</a>
<a name="ln530">   typedef typename base_type::value_type       value_type;</a>
<a name="ln531"> </a>
<a name="ln532">   BOOST_CONTAINER_FORCEINLINE static std::size_t internal_capacity()</a>
<a name="ln533">   {  return (sizeof(small_vector) - storage_test::s_start)/sizeof(T);  }</a>
<a name="ln534"> </a>
<a name="ln535">   #endif   //#ifndef BOOST_CONTAINER_DOXYGEN_INVOKED</a>
<a name="ln536"> </a>
<a name="ln537">   //! @brief The capacity/max size of the container</a>
<a name="ln538">   static const size_type static_capacity = N;</a>
<a name="ln539"> </a>
<a name="ln540">   public:</a>
<a name="ln541">   BOOST_CONTAINER_FORCEINLINE small_vector()</a>
<a name="ln542">      BOOST_NOEXCEPT_IF(dtl::is_nothrow_default_constructible&lt;Allocator&gt;::value)</a>
<a name="ln543">      : base_type(initial_capacity_t(), internal_capacity())</a>
<a name="ln544">   {}</a>
<a name="ln545"> </a>
<a name="ln546">   BOOST_CONTAINER_FORCEINLINE explicit small_vector(const allocator_type &amp;a)</a>
<a name="ln547">      : base_type(initial_capacity_t(), internal_capacity(), a)</a>
<a name="ln548">   {}</a>
<a name="ln549"> </a>
<a name="ln550">   BOOST_CONTAINER_FORCEINLINE explicit small_vector(size_type n)</a>
<a name="ln551">      : base_type(initial_capacity_t(), internal_capacity())</a>
<a name="ln552">   {  this-&gt;resize(n); }</a>
<a name="ln553"> </a>
<a name="ln554">   BOOST_CONTAINER_FORCEINLINE small_vector(size_type n, const allocator_type &amp;a)</a>
<a name="ln555">      : base_type(initial_capacity_t(), internal_capacity(), a)</a>
<a name="ln556">   {  this-&gt;resize(n); }</a>
<a name="ln557"> </a>
<a name="ln558">   BOOST_CONTAINER_FORCEINLINE small_vector(size_type n, default_init_t)</a>
<a name="ln559">      : base_type(initial_capacity_t(), internal_capacity())</a>
<a name="ln560">   {  this-&gt;resize(n, default_init_t()); }</a>
<a name="ln561"> </a>
<a name="ln562">   BOOST_CONTAINER_FORCEINLINE small_vector(size_type n, default_init_t, const allocator_type &amp;a)</a>
<a name="ln563">      : base_type(initial_capacity_t(), internal_capacity(), a)</a>
<a name="ln564">   {  this-&gt;resize(n, default_init_t()); }</a>
<a name="ln565"> </a>
<a name="ln566">   BOOST_CONTAINER_FORCEINLINE small_vector(size_type n, const value_type &amp;v)</a>
<a name="ln567">      : base_type(initial_capacity_t(), internal_capacity())</a>
<a name="ln568">   {  this-&gt;resize(n, v); }</a>
<a name="ln569"> </a>
<a name="ln570">   BOOST_CONTAINER_FORCEINLINE small_vector(size_type n, const value_type &amp;v, const allocator_type &amp;a)</a>
<a name="ln571">      : base_type(initial_capacity_t(), internal_capacity(), a)</a>
<a name="ln572">   {  this-&gt;resize(n, v); }</a>
<a name="ln573"> </a>
<a name="ln574">   template &lt;class InIt&gt;</a>
<a name="ln575">   BOOST_CONTAINER_FORCEINLINE small_vector(InIt first, InIt last</a>
<a name="ln576">      BOOST_CONTAINER_DOCIGN(BOOST_MOVE_I typename dtl::disable_if_c</a>
<a name="ln577">         &lt; dtl::is_convertible&lt;InIt BOOST_MOVE_I size_type&gt;::value</a>
<a name="ln578">         BOOST_MOVE_I dtl::nat &gt;::type * = 0)</a>
<a name="ln579">      )</a>
<a name="ln580">      : base_type(initial_capacity_t(), internal_capacity())</a>
<a name="ln581">   {  this-&gt;assign(first, last); }</a>
<a name="ln582"> </a>
<a name="ln583">   template &lt;class InIt&gt;</a>
<a name="ln584">   BOOST_CONTAINER_FORCEINLINE small_vector(InIt first, InIt last, const allocator_type&amp; a</a>
<a name="ln585">      BOOST_CONTAINER_DOCIGN(BOOST_MOVE_I typename dtl::disable_if_c</a>
<a name="ln586">         &lt; dtl::is_convertible&lt;InIt BOOST_MOVE_I size_type&gt;::value</a>
<a name="ln587">         BOOST_MOVE_I dtl::nat &gt;::type * = 0)</a>
<a name="ln588">      )</a>
<a name="ln589">      : base_type(initial_capacity_t(), internal_capacity(), a)</a>
<a name="ln590">   {  this-&gt;assign(first, last); }</a>
<a name="ln591"> </a>
<a name="ln592">   BOOST_CONTAINER_FORCEINLINE small_vector(const small_vector &amp;other)</a>
<a name="ln593">      : base_type( initial_capacity_t(), internal_capacity()</a>
<a name="ln594">                 , allocator_traits_type::select_on_container_copy_construction(other.get_stored_allocator()))</a>
<a name="ln595">   {  this-&gt;assign(other.cbegin(), other.cend());  }</a>
<a name="ln596"> </a>
<a name="ln597">   BOOST_CONTAINER_FORCEINLINE small_vector(const small_vector &amp;other, const allocator_type &amp;a)</a>
<a name="ln598">      : base_type(initial_capacity_t(), internal_capacity(), a)</a>
<a name="ln599">   {  this-&gt;assign(other.cbegin(), other.cend());  }</a>
<a name="ln600"> </a>
<a name="ln601">   BOOST_CONTAINER_FORCEINLINE explicit small_vector(const base_type &amp;other)</a>
<a name="ln602">      : base_type( initial_capacity_t(), internal_capacity()</a>
<a name="ln603">                 , allocator_traits_type::select_on_container_copy_construction(other.get_stored_allocator()))</a>
<a name="ln604">   {  this-&gt;assign(other.cbegin(), other.cend());  }</a>
<a name="ln605"> </a>
<a name="ln606">   BOOST_CONTAINER_FORCEINLINE explicit small_vector(BOOST_RV_REF(base_type) other)</a>
<a name="ln607">      : base_type(initial_capacity_t(), internal_capacity(), ::boost::move(other.get_stored_allocator()))</a>
<a name="ln608">   {  this-&gt;move_construct_impl(other, other.get_stored_allocator());   }</a>
<a name="ln609"> </a>
<a name="ln610">   BOOST_CONTAINER_FORCEINLINE small_vector(BOOST_RV_REF(small_vector) other)</a>
<a name="ln611">      BOOST_NOEXCEPT_IF(boost::container::dtl::is_nothrow_move_assignable&lt;value_type&gt;::value)</a>
<a name="ln612">      : base_type(initial_capacity_t(), internal_capacity(), ::boost::move(other.get_stored_allocator()))</a>
<a name="ln613">   {  this-&gt;move_construct_impl(other, other.get_stored_allocator());   }</a>
<a name="ln614"> </a>
<a name="ln615">   BOOST_CONTAINER_FORCEINLINE small_vector(BOOST_RV_REF(small_vector) other, const allocator_type &amp;a)</a>
<a name="ln616">      : base_type(initial_capacity_t(), internal_capacity(), a)</a>
<a name="ln617">   {  this-&gt;move_construct_impl(other, a);   }</a>
<a name="ln618"> </a>
<a name="ln619">   #if !defined(BOOST_NO_CXX11_HDR_INITIALIZER_LIST)</a>
<a name="ln620">   BOOST_CONTAINER_FORCEINLINE small_vector(std::initializer_list&lt;value_type&gt; il, const allocator_type&amp; a = allocator_type())</a>
<a name="ln621">      : base_type(initial_capacity_t(), internal_capacity(), a)</a>
<a name="ln622">   {</a>
<a name="ln623">      this-&gt;assign(il.begin(), il.end());</a>
<a name="ln624">   }</a>
<a name="ln625">   #endif</a>
<a name="ln626"> </a>
<a name="ln627">   BOOST_CONTAINER_FORCEINLINE small_vector&amp; operator=(BOOST_COPY_ASSIGN_REF(small_vector) other)</a>
<a name="ln628">   {  return static_cast&lt;small_vector&amp;&gt;(this-&gt;base_type::operator=(static_cast&lt;base_type const&amp;&gt;(other)));  }</a>
<a name="ln629"> </a>
<a name="ln630">   BOOST_CONTAINER_FORCEINLINE small_vector&amp; operator=(BOOST_RV_REF(small_vector) other)</a>
<a name="ln631">      BOOST_NOEXCEPT_IF(boost::container::dtl::is_nothrow_move_assignable&lt;value_type&gt;::value</a>
<a name="ln632">         &amp;&amp; (allocator_traits_type::propagate_on_container_move_assignment::value</a>
<a name="ln633">             || allocator_traits_type::is_always_equal::value))</a>
<a name="ln634">   {  return static_cast&lt;small_vector&amp;&gt;(this-&gt;base_type::operator=(BOOST_MOVE_BASE(base_type, other))); }</a>
<a name="ln635"> </a>
<a name="ln636">   BOOST_CONTAINER_FORCEINLINE small_vector&amp; operator=(const base_type &amp;other)</a>
<a name="ln637">   {  return static_cast&lt;small_vector&amp;&gt;(this-&gt;base_type::operator=(other));  }</a>
<a name="ln638"> </a>
<a name="ln639">   BOOST_CONTAINER_FORCEINLINE small_vector&amp; operator=(BOOST_RV_REF(base_type) other)</a>
<a name="ln640">   {  return static_cast&lt;small_vector&amp;&gt;(this-&gt;base_type::operator=(boost::move(other))); }</a>
<a name="ln641"> </a>
<a name="ln642">   BOOST_CONTAINER_FORCEINLINE void swap(small_vector &amp;other)</a>
<a name="ln643">   {  return this-&gt;base_type::swap(other);  }</a>
<a name="ln644">};</a>
<a name="ln645"> </a>
<a name="ln646">}}</a>
<a name="ln647"> </a>
<a name="ln648">#ifndef BOOST_CONTAINER_DOXYGEN_INVOKED</a>
<a name="ln649">/*</a>
<a name="ln650">namespace boost {</a>
<a name="ln651"> </a>
<a name="ln652">//!has_trivial_destructor_after_move&lt;&gt; == true_type</a>
<a name="ln653">//!specialization for optimizations</a>
<a name="ln654">template &lt;class T, class Allocator&gt;</a>
<a name="ln655">struct has_trivial_destructor_after_move&lt;boost::container::vector&lt;T, Allocator&gt; &gt;</a>
<a name="ln656">{</a>
<a name="ln657">   typedef typename ::boost::container::allocator_traits&lt;Allocator&gt;::pointer pointer;</a>
<a name="ln658">   static const bool value = ::boost::has_trivial_destructor_after_move&lt;Allocator&gt;::value &amp;&amp;</a>
<a name="ln659">                             ::boost::has_trivial_destructor_after_move&lt;pointer&gt;::value;</a>
<a name="ln660">};</a>
<a name="ln661"> </a>
<a name="ln662">}</a>
<a name="ln663">*/</a>
<a name="ln664">#endif   //#ifndef BOOST_CONTAINER_DOXYGEN_INVOKED</a>
<a name="ln665"> </a>
<a name="ln666">#include &lt;boost/container/detail/config_end.hpp&gt;</a>
<a name="ln667"> </a>
<a name="ln668">#endif //   #ifndef  BOOST_CONTAINER_CONTAINER_SMALL_VECTOR_HPP</a>

</code></pre>
<div class="balloon" rel="388"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: m_storage_start.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
