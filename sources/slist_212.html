
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>slist</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Singly-linked list implementation -*- C++ -*-</a>
<a name="ln2"> </a>
<a name="ln3">// Copyright (C) 2001-2018 Free Software Foundation, Inc.</a>
<a name="ln4">//</a>
<a name="ln5">// This file is part of the GNU ISO C++ Library.  This library is free</a>
<a name="ln6">// software; you can redistribute it and/or modify it under the</a>
<a name="ln7">// terms of the GNU General Public License as published by the</a>
<a name="ln8">// Free Software Foundation; either version 3, or (at your option)</a>
<a name="ln9">// any later version.</a>
<a name="ln10"> </a>
<a name="ln11">// This library is distributed in the hope that it will be useful,</a>
<a name="ln12">// but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">// GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">// Under Section 7 of GPL version 3, you are granted additional</a>
<a name="ln17">// permissions described in the GCC Runtime Library Exception, version</a>
<a name="ln18">// 3.1, as published by the Free Software Foundation.</a>
<a name="ln19"> </a>
<a name="ln20">// You should have received a copy of the GNU General Public License and</a>
<a name="ln21">// a copy of the GCC Runtime Library Exception along with this program;</a>
<a name="ln22">// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see</a>
<a name="ln23">// &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln24"> </a>
<a name="ln25">/*</a>
<a name="ln26"> * Copyright (c) 1997</a>
<a name="ln27"> * Silicon Graphics Computer Systems, Inc.</a>
<a name="ln28"> *</a>
<a name="ln29"> * Permission to use, copy, modify, distribute and sell this software</a>
<a name="ln30"> * and its documentation for any purpose is hereby granted without fee,</a>
<a name="ln31"> * provided that the above copyright notice appear in all copies and</a>
<a name="ln32"> * that both that copyright notice and this permission notice appear</a>
<a name="ln33"> * in supporting documentation.  Silicon Graphics makes no</a>
<a name="ln34"> * representations about the suitability of this software for any</a>
<a name="ln35"> * purpose.  It is provided &quot;as is&quot; without express or implied warranty.</a>
<a name="ln36"> *</a>
<a name="ln37"> */</a>
<a name="ln38"> </a>
<a name="ln39">/** @file ext/slist</a>
<a name="ln40"> *  This file is a GNU extension to the Standard C++ Library (possibly</a>
<a name="ln41"> *  containing extensions from the HP/SGI STL subset). </a>
<a name="ln42"> */</a>
<a name="ln43"> </a>
<a name="ln44">#ifndef _SLIST</a>
<a name="ln45">#define _SLIST 1</a>
<a name="ln46"> </a>
<a name="ln47">#include &lt;algorithm&gt;</a>
<a name="ln48">#include &lt;bits/allocator.h&gt;</a>
<a name="ln49">#include &lt;bits/stl_construct.h&gt;</a>
<a name="ln50">#include &lt;bits/stl_uninitialized.h&gt;</a>
<a name="ln51">#include &lt;bits/concept_check.h&gt;</a>
<a name="ln52"> </a>
<a name="ln53">namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)</a>
<a name="ln54">{</a>
<a name="ln55">_GLIBCXX_BEGIN_NAMESPACE_VERSION</a>
<a name="ln56"> </a>
<a name="ln57">  using std::size_t;</a>
<a name="ln58">  using std::ptrdiff_t;</a>
<a name="ln59">  using std::_Construct;</a>
<a name="ln60">  using std::_Destroy;</a>
<a name="ln61">  using std::allocator;</a>
<a name="ln62">  using std::__true_type;</a>
<a name="ln63">  using std::__false_type;</a>
<a name="ln64"> </a>
<a name="ln65">  struct _Slist_node_base</a>
<a name="ln66">  {</a>
<a name="ln67">    _Slist_node_base* _M_next;</a>
<a name="ln68">  };</a>
<a name="ln69">  </a>
<a name="ln70">  inline _Slist_node_base*</a>
<a name="ln71">  __slist_make_link(_Slist_node_base* __prev_node,</a>
<a name="ln72">		    _Slist_node_base* __new_node)</a>
<a name="ln73">  {</a>
<a name="ln74">    __new_node-&gt;_M_next = __prev_node-&gt;_M_next;</a>
<a name="ln75">    __prev_node-&gt;_M_next = __new_node;</a>
<a name="ln76">    return __new_node;</a>
<a name="ln77">  }</a>
<a name="ln78"> </a>
<a name="ln79">  inline _Slist_node_base*</a>
<a name="ln80">  __slist_previous(_Slist_node_base* __head,</a>
<a name="ln81">		   const _Slist_node_base* __node)</a>
<a name="ln82">  {</a>
<a name="ln83">    while (__head &amp;&amp; __head-&gt;_M_next != __node)</a>
<a name="ln84">      __head = __head-&gt;_M_next;</a>
<a name="ln85">    return __head;</a>
<a name="ln86">  }</a>
<a name="ln87"> </a>
<a name="ln88">  inline const _Slist_node_base*</a>
<a name="ln89">  __slist_previous(const _Slist_node_base* __head,</a>
<a name="ln90">		   const _Slist_node_base* __node)</a>
<a name="ln91">  {</a>
<a name="ln92">    while (__head &amp;&amp; __head-&gt;_M_next != __node)</a>
<a name="ln93">      __head = __head-&gt;_M_next;</a>
<a name="ln94">    return __head;</a>
<a name="ln95">  }</a>
<a name="ln96"> </a>
<a name="ln97">  inline void</a>
<a name="ln98">  __slist_splice_after(_Slist_node_base* __pos,</a>
<a name="ln99">		       _Slist_node_base* __before_first,</a>
<a name="ln100">		       _Slist_node_base* __before_last)</a>
<a name="ln101">  {</a>
<a name="ln102">    if (__pos != __before_first &amp;&amp; __pos != __before_last)</a>
<a name="ln103">      {</a>
<a name="ln104">	_Slist_node_base* __first = __before_first-&gt;_M_next;</a>
<a name="ln105">	_Slist_node_base* __after = __pos-&gt;_M_next;</a>
<a name="ln106">	__before_first-&gt;_M_next = __before_last-&gt;_M_next;</a>
<a name="ln107">	__pos-&gt;_M_next = __first;</a>
<a name="ln108">	__before_last-&gt;_M_next = __after;</a>
<a name="ln109">      }</a>
<a name="ln110">  }</a>
<a name="ln111"> </a>
<a name="ln112">  inline void</a>
<a name="ln113">  __slist_splice_after(_Slist_node_base* __pos, _Slist_node_base* __head)</a>
<a name="ln114">  {</a>
<a name="ln115">    _Slist_node_base* __before_last = __slist_previous(__head, 0);</a>
<a name="ln116">    if (__before_last != __head)</a>
<a name="ln117">      {</a>
<a name="ln118">	_Slist_node_base* __after = __pos-&gt;_M_next;</a>
<a name="ln119">	__pos-&gt;_M_next = __head-&gt;_M_next;</a>
<a name="ln120">	__head-&gt;_M_next = 0;</a>
<a name="ln121">	__before_last-&gt;_M_next = __after;</a>
<a name="ln122">      }</a>
<a name="ln123">  }</a>
<a name="ln124"> </a>
<a name="ln125">  inline _Slist_node_base*</a>
<a name="ln126">  __slist_reverse(_Slist_node_base* __node)</a>
<a name="ln127">  {</a>
<a name="ln128">    _Slist_node_base* __result = __node;</a>
<a name="ln129">    __node = __node-&gt;_M_next;</a>
<a name="ln130">    __result-&gt;_M_next = 0;</a>
<a name="ln131">    while(__node)</a>
<a name="ln132">      {</a>
<a name="ln133">	_Slist_node_base* __next = __node-&gt;_M_next;</a>
<a name="ln134">	__node-&gt;_M_next = __result;</a>
<a name="ln135">	__result = __node;</a>
<a name="ln136">	__node = __next;</a>
<a name="ln137">      }</a>
<a name="ln138">    return __result;</a>
<a name="ln139">  }</a>
<a name="ln140"> </a>
<a name="ln141">  inline size_t</a>
<a name="ln142">  __slist_size(_Slist_node_base* __node)</a>
<a name="ln143">  {</a>
<a name="ln144">    size_t __result = 0;</a>
<a name="ln145">    for (; __node != 0; __node = __node-&gt;_M_next)</a>
<a name="ln146">      ++__result;</a>
<a name="ln147">    return __result;</a>
<a name="ln148">  }</a>
<a name="ln149"> </a>
<a name="ln150">  template &lt;class _Tp&gt;</a>
<a name="ln151">    struct _Slist_node : public _Slist_node_base</a>
<a name="ln152">    {</a>
<a name="ln153">      _Tp _M_data;</a>
<a name="ln154">    };</a>
<a name="ln155"> </a>
<a name="ln156">  struct _Slist_iterator_base</a>
<a name="ln157">  {</a>
<a name="ln158">    typedef size_t                    size_type;</a>
<a name="ln159">    typedef ptrdiff_t                 difference_type;</a>
<a name="ln160">    typedef std::forward_iterator_tag iterator_category;</a>
<a name="ln161"> </a>
<a name="ln162">    _Slist_node_base* _M_node;</a>
<a name="ln163">    </a>
<a name="ln164">    _Slist_iterator_base(_Slist_node_base* __x)</a>
<a name="ln165">    : _M_node(__x) {}</a>
<a name="ln166"> </a>
<a name="ln167">    void</a>
<a name="ln168">    _M_incr()</a>
<a name="ln169">    { _M_node = _M_node-&gt;_M_next; }</a>
<a name="ln170"> </a>
<a name="ln171">    bool</a>
<a name="ln172">    operator==(const _Slist_iterator_base&amp; __x) const</a>
<a name="ln173">    { return _M_node == __x._M_node; }</a>
<a name="ln174"> </a>
<a name="ln175">    bool</a>
<a name="ln176">    operator!=(const _Slist_iterator_base&amp; __x) const</a>
<a name="ln177">    { return _M_node != __x._M_node; }</a>
<a name="ln178">  };</a>
<a name="ln179"> </a>
<a name="ln180">  template &lt;class _Tp, class _Ref, class _Ptr&gt;</a>
<a name="ln181">    struct _Slist_iterator : public _Slist_iterator_base</a>
<a name="ln182">    {</a>
<a name="ln183">      typedef _Slist_iterator&lt;_Tp, _Tp&amp;, _Tp*&gt;             iterator;</a>
<a name="ln184">      typedef _Slist_iterator&lt;_Tp, const _Tp&amp;, const _Tp*&gt; const_iterator;</a>
<a name="ln185">      typedef _Slist_iterator&lt;_Tp, _Ref, _Ptr&gt;             _Self;</a>
<a name="ln186"> </a>
<a name="ln187">      typedef _Tp              value_type;</a>
<a name="ln188">      typedef _Ptr             pointer;</a>
<a name="ln189">      typedef _Ref             reference;</a>
<a name="ln190">      typedef _Slist_node&lt;_Tp&gt; _Node;</a>
<a name="ln191"> </a>
<a name="ln192">      explicit</a>
<a name="ln193">      _Slist_iterator(_Node* __x)</a>
<a name="ln194">      : _Slist_iterator_base(__x) {}</a>
<a name="ln195"> </a>
<a name="ln196">      _Slist_iterator()</a>
<a name="ln197">      : _Slist_iterator_base(0) {}</a>
<a name="ln198"> </a>
<a name="ln199">      _Slist_iterator(const iterator&amp; __x)</a>
<a name="ln200">      : _Slist_iterator_base(__x._M_node) {}</a>
<a name="ln201"> </a>
<a name="ln202">      reference</a>
<a name="ln203">      operator*() const</a>
<a name="ln204">      { return ((_Node*) _M_node)-&gt;_M_data; }</a>
<a name="ln205"> </a>
<a name="ln206">      pointer</a>
<a name="ln207">      operator-&gt;() const</a>
<a name="ln208">      { return &amp;(operator*()); }</a>
<a name="ln209"> </a>
<a name="ln210">      _Self&amp;</a>
<a name="ln211">      operator++()</a>
<a name="ln212">      {</a>
<a name="ln213">	_M_incr();</a>
<a name="ln214">	return *this;</a>
<a name="ln215">      }</a>
<a name="ln216"> </a>
<a name="ln217">      _Self</a>
<a name="ln218">      operator++(int)</a>
<a name="ln219">      {</a>
<a name="ln220">	_Self __tmp = *this;</a>
<a name="ln221">	_M_incr();</a>
<a name="ln222">	return __tmp;</a>
<a name="ln223">      }</a>
<a name="ln224">    };</a>
<a name="ln225"> </a>
<a name="ln226">  template &lt;class _Tp, class _Alloc&gt;</a>
<a name="ln227">    struct _Slist_base</a>
<a name="ln228">    : public _Alloc::template rebind&lt;_Slist_node&lt;_Tp&gt; &gt;::other</a>
<a name="ln229">    {</a>
<a name="ln230">      typedef typename _Alloc::template rebind&lt;_Slist_node&lt;_Tp&gt; &gt;::other</a>
<a name="ln231">        _Node_alloc;</a>
<a name="ln232">      typedef _Alloc allocator_type;</a>
<a name="ln233"> </a>
<a name="ln234">      allocator_type</a>
<a name="ln235">      get_allocator() const</a>
<a name="ln236">      { return *static_cast&lt;const _Node_alloc*&gt;(this); }</a>
<a name="ln237"> </a>
<a name="ln238">      _Slist_base(const allocator_type&amp; __a)</a>
<a name="ln239">      : _Node_alloc(__a)</a>
<a name="ln240">      { this-&gt;_M_head._M_next = 0; }</a>
<a name="ln241"> </a>
<a name="ln242">      ~_Slist_base()</a>
<a name="ln243">      { _M_erase_after(&amp;this-&gt;_M_head, 0); }</a>
<a name="ln244"> </a>
<a name="ln245">    protected:</a>
<a name="ln246">      _Slist_node_base _M_head;</a>
<a name="ln247"> </a>
<a name="ln248">      _Slist_node&lt;_Tp&gt;*</a>
<a name="ln249">      _M_get_node()</a>
<a name="ln250">      { return _Node_alloc::allocate(1); }</a>
<a name="ln251">  </a>
<a name="ln252">      void</a>
<a name="ln253">      _M_put_node(_Slist_node&lt;_Tp&gt;* __p)</a>
<a name="ln254">      { _Node_alloc::deallocate(__p, 1); }</a>
<a name="ln255"> </a>
<a name="ln256">    protected:</a>
<a name="ln257">      _Slist_node_base* _M_erase_after(_Slist_node_base* __pos)</a>
<a name="ln258">      {</a>
<a name="ln259">	_Slist_node&lt;_Tp&gt;* __next = (_Slist_node&lt;_Tp&gt;*) (__pos-&gt;_M_next);</a>
<a name="ln260">	_Slist_node_base* __next_next = __next-&gt;_M_next;</a>
<a name="ln261">	__pos-&gt;_M_next = __next_next;</a>
<a name="ln262">	get_allocator().destroy(&amp;__next-&gt;_M_data);</a>
<a name="ln263">	_M_put_node(__next);</a>
<a name="ln264">	return __next_next;</a>
<a name="ln265">      }</a>
<a name="ln266">      _Slist_node_base* _M_erase_after(_Slist_node_base*, _Slist_node_base*);</a>
<a name="ln267">    };</a>
<a name="ln268"> </a>
<a name="ln269">  template &lt;class _Tp, class _Alloc&gt;</a>
<a name="ln270">    _Slist_node_base*</a>
<a name="ln271">    _Slist_base&lt;_Tp,_Alloc&gt;::_M_erase_after(_Slist_node_base* __before_first,</a>
<a name="ln272">					    _Slist_node_base* __last_node)</a>
<a name="ln273">    {</a>
<a name="ln274">      _Slist_node&lt;_Tp&gt;* __cur = (_Slist_node&lt;_Tp&gt;*) (__before_first-&gt;_M_next);</a>
<a name="ln275">      while (__cur != __last_node)</a>
<a name="ln276">	{</a>
<a name="ln277">	  _Slist_node&lt;_Tp&gt;* __tmp = __cur;</a>
<a name="ln278">	  __cur = (_Slist_node&lt;_Tp&gt;*) __cur-&gt;_M_next;</a>
<a name="ln279">	  get_allocator().destroy(&amp;__tmp-&gt;_M_data);</a>
<a name="ln280">	  _M_put_node(__tmp);</a>
<a name="ln281">	}</a>
<a name="ln282">      __before_first-&gt;_M_next = __last_node;</a>
<a name="ln283">      return __last_node;</a>
<a name="ln284">    }</a>
<a name="ln285"> </a>
<a name="ln286">  /**</a>
<a name="ln287">   *  This is an SGI extension.</a>
<a name="ln288">   *  @ingroup SGIextensions</a>
<a name="ln289">   *  @doctodo</a>
<a name="ln290">   */</a>
<a name="ln291">  template &lt;class _Tp, class _Alloc = allocator&lt;_Tp&gt; &gt;</a>
<a name="ln292">    class slist : private _Slist_base&lt;_Tp,_Alloc&gt;</a>
<a name="ln293">    {</a>
<a name="ln294">      // concept requirements</a>
<a name="ln295">      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)</a>
<a name="ln296">	</a>
<a name="ln297">    private:</a>
<a name="ln298">      typedef _Slist_base&lt;_Tp,_Alloc&gt; _Base;</a>
<a name="ln299"> </a>
<a name="ln300">    public:</a>
<a name="ln301">      typedef _Tp               value_type;</a>
<a name="ln302">      typedef value_type*       pointer;</a>
<a name="ln303">      typedef const value_type* const_pointer;</a>
<a name="ln304">      typedef value_type&amp;       reference;</a>
<a name="ln305">      typedef const value_type&amp; const_reference;</a>
<a name="ln306">      typedef size_t            size_type;</a>
<a name="ln307">      typedef ptrdiff_t         difference_type;</a>
<a name="ln308">      </a>
<a name="ln309">      typedef _Slist_iterator&lt;_Tp, _Tp&amp;, _Tp*&gt;             iterator;</a>
<a name="ln310">      typedef _Slist_iterator&lt;_Tp, const _Tp&amp;, const _Tp*&gt; const_iterator;</a>
<a name="ln311">      </a>
<a name="ln312">      typedef typename _Base::allocator_type allocator_type;</a>
<a name="ln313"> </a>
<a name="ln314">      allocator_type</a>
<a name="ln315">      get_allocator() const</a>
<a name="ln316">      { return _Base::get_allocator(); }</a>
<a name="ln317"> </a>
<a name="ln318">    private:</a>
<a name="ln319">      typedef _Slist_node&lt;_Tp&gt;      _Node;</a>
<a name="ln320">      typedef _Slist_node_base      _Node_base;</a>
<a name="ln321">      typedef _Slist_iterator_base  _Iterator_base;</a>
<a name="ln322">      </a>
<a name="ln323">      _Node*</a>
<a name="ln324">      _M_create_node(const value_type&amp; __x)</a>
<a name="ln325">      {</a>
<a name="ln326">	_Node* __node = this-&gt;_M_get_node();</a>
<a name="ln327">	__try</a>
<a name="ln328">	  {</a>
<a name="ln329">	    get_allocator().construct(&amp;__node-&gt;_M_data, __x);</a>
<a name="ln330">	    __node-&gt;_M_next = 0;</a>
<a name="ln331">	  }</a>
<a name="ln332">	__catch(...)</a>
<a name="ln333">	  {</a>
<a name="ln334">	    this-&gt;_M_put_node(__node);</a>
<a name="ln335">	    __throw_exception_again;</a>
<a name="ln336">	  }</a>
<a name="ln337">	return __node;</a>
<a name="ln338">      }</a>
<a name="ln339"> </a>
<a name="ln340">      _Node*</a>
<a name="ln341">      _M_create_node()</a>
<a name="ln342">      {</a>
<a name="ln343">	_Node* __node = this-&gt;_M_get_node();</a>
<a name="ln344">	__try</a>
<a name="ln345">	  {</a>
<a name="ln346">	    get_allocator().construct(&amp;__node-&gt;_M_data, value_type());</a>
<a name="ln347">	    __node-&gt;_M_next = 0;</a>
<a name="ln348">	  }</a>
<a name="ln349">	__catch(...)</a>
<a name="ln350">	  {</a>
<a name="ln351">	    this-&gt;_M_put_node(__node);</a>
<a name="ln352">	    __throw_exception_again;</a>
<a name="ln353">	  }</a>
<a name="ln354">	return __node;</a>
<a name="ln355">      }</a>
<a name="ln356"> </a>
<a name="ln357">    public:</a>
<a name="ln358">      explicit</a>
<a name="ln359">      slist(const allocator_type&amp; __a = allocator_type())</a>
<a name="ln360">      : _Base(__a) {}</a>
<a name="ln361"> </a>
<a name="ln362">      slist(size_type __n, const value_type&amp; __x,</a>
<a name="ln363">	    const allocator_type&amp; __a =  allocator_type())</a>
<a name="ln364">      : _Base(__a)</a>
<a name="ln365">      { _M_insert_after_fill(&amp;this-&gt;_M_head, __n, __x); }</a>
<a name="ln366"> </a>
<a name="ln367">      explicit</a>
<a name="ln368">      slist(size_type __n)</a>
<a name="ln369">      : _Base(allocator_type())</a>
<a name="ln370">      { _M_insert_after_fill(&amp;this-&gt;_M_head, __n, value_type()); }</a>
<a name="ln371"> </a>
<a name="ln372">      // We don't need any dispatching tricks here, because</a>
<a name="ln373">      // _M_insert_after_range already does them.</a>
<a name="ln374">      template &lt;class _InputIterator&gt;</a>
<a name="ln375">        slist(_InputIterator __first, _InputIterator __last,</a>
<a name="ln376">	      const allocator_type&amp; __a =  allocator_type())</a>
<a name="ln377">	: _Base(__a)</a>
<a name="ln378">        { _M_insert_after_range(&amp;this-&gt;_M_head, __first, __last); }</a>
<a name="ln379"> </a>
<a name="ln380">      slist(const slist&amp; __x)</a>
<a name="ln381">      : _Base(__x.get_allocator())</a>
<a name="ln382">      { _M_insert_after_range(&amp;this-&gt;_M_head, __x.begin(), __x.end()); }</a>
<a name="ln383"> </a>
<a name="ln384">      slist&amp;</a>
<a name="ln385">      operator= (const slist&amp; __x);</a>
<a name="ln386"> </a>
<a name="ln387">      ~slist() {}</a>
<a name="ln388"> </a>
<a name="ln389">    public:</a>
<a name="ln390">      // assign(), a generalized assignment member function.  Two</a>
<a name="ln391">      // versions: one that takes a count, and one that takes a range.</a>
<a name="ln392">      // The range version is a member template, so we dispatch on whether</a>
<a name="ln393">      // or not the type is an integer.</a>
<a name="ln394">      </a>
<a name="ln395">      void</a>
<a name="ln396">      assign(size_type __n, const _Tp&amp; __val)</a>
<a name="ln397">      { _M_fill_assign(__n, __val); }</a>
<a name="ln398"> </a>
<a name="ln399">      void</a>
<a name="ln400">      _M_fill_assign(size_type __n, const _Tp&amp; __val);</a>
<a name="ln401"> </a>
<a name="ln402">      template &lt;class _InputIterator&gt;</a>
<a name="ln403">        void</a>
<a name="ln404">        assign(_InputIterator __first, _InputIterator __last)</a>
<a name="ln405">        {</a>
<a name="ln406">	  typedef typename std::__is_integer&lt;_InputIterator&gt;::__type _Integral;</a>
<a name="ln407">	  _M_assign_dispatch(__first, __last, _Integral());</a>
<a name="ln408">	}</a>
<a name="ln409"> </a>
<a name="ln410">      template &lt;class _Integer&gt;</a>
<a name="ln411">      void</a>
<a name="ln412">      _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)</a>
<a name="ln413">      { _M_fill_assign((size_type) __n, (_Tp) __val); }</a>
<a name="ln414"> </a>
<a name="ln415">      template &lt;class _InputIterator&gt;</a>
<a name="ln416">      void</a>
<a name="ln417">      _M_assign_dispatch(_InputIterator __first, _InputIterator __last,</a>
<a name="ln418">			 __false_type);</a>
<a name="ln419"> </a>
<a name="ln420">    public:</a>
<a name="ln421"> </a>
<a name="ln422">      iterator</a>
<a name="ln423">      begin()</a>
<a name="ln424">      { return iterator((_Node*)this-&gt;_M_head._M_next); }</a>
<a name="ln425"> </a>
<a name="ln426">      const_iterator</a>
<a name="ln427">      begin() const</a>
<a name="ln428">      { return const_iterator((_Node*)this-&gt;_M_head._M_next);}</a>
<a name="ln429"> </a>
<a name="ln430">      iterator</a>
<a name="ln431">      end()</a>
<a name="ln432">      { return iterator(0); }</a>
<a name="ln433"> </a>
<a name="ln434">      const_iterator</a>
<a name="ln435">      end() const</a>
<a name="ln436">      { return const_iterator(0); }</a>
<a name="ln437"> </a>
<a name="ln438">      // Experimental new feature: before_begin() returns a</a>
<a name="ln439">      // non-dereferenceable iterator that, when incremented, yields</a>
<a name="ln440">      // begin().  This iterator may be used as the argument to</a>
<a name="ln441">      // insert_after, erase_after, etc.  Note that even for an empty</a>
<a name="ln442">      // slist, before_begin() is not the same iterator as end().  It</a>
<a name="ln443">      // is always necessary to increment before_begin() at least once to</a>
<a name="ln444">      // obtain end().</a>
<a name="ln445">      iterator</a>
<a name="ln446">      before_begin()</a>
<a name="ln447">      { return iterator((_Node*) &amp;this-&gt;_M_head); }</a>
<a name="ln448"> </a>
<a name="ln449">      const_iterator</a>
<a name="ln450">      before_begin() const</a>
<a name="ln451">      { return const_iterator((_Node*) &amp;this-&gt;_M_head); }</a>
<a name="ln452"> </a>
<a name="ln453">      size_type</a>
<a name="ln454">      size() const</a>
<a name="ln455">      { return __slist_size(this-&gt;_M_head._M_next); }</a>
<a name="ln456"> </a>
<a name="ln457">      size_type</a>
<a name="ln458">      max_size() const</a>
<a name="ln459">      { return size_type(-1); }</a>
<a name="ln460"> </a>
<a name="ln461">      bool</a>
<a name="ln462">      empty() const</a>
<a name="ln463">      { return this-&gt;_M_head._M_next == 0; }</a>
<a name="ln464"> </a>
<a name="ln465">      void</a>
<a name="ln466">      swap(slist&amp; __x)</a>
<a name="ln467">      { std::swap(this-&gt;_M_head._M_next, __x._M_head._M_next); }</a>
<a name="ln468"> </a>
<a name="ln469">    public:</a>
<a name="ln470"> </a>
<a name="ln471">      reference</a>
<a name="ln472">      front()</a>
<a name="ln473">      { return ((_Node*) this-&gt;_M_head._M_next)-&gt;_M_data; }</a>
<a name="ln474"> </a>
<a name="ln475">      const_reference</a>
<a name="ln476">      front() const</a>
<a name="ln477">      { return ((_Node*) this-&gt;_M_head._M_next)-&gt;_M_data; }</a>
<a name="ln478"> </a>
<a name="ln479">      void</a>
<a name="ln480">      push_front(const value_type&amp; __x)</a>
<a name="ln481">      { __slist_make_link(&amp;this-&gt;_M_head, _M_create_node(__x)); }</a>
<a name="ln482"> </a>
<a name="ln483">      void</a>
<a name="ln484">      push_front()</a>
<a name="ln485">      { __slist_make_link(&amp;this-&gt;_M_head, _M_create_node()); }</a>
<a name="ln486"> </a>
<a name="ln487">      void</a>
<a name="ln488">      pop_front()</a>
<a name="ln489">      {</a>
<a name="ln490">	_Node* __node = (_Node*) this-&gt;_M_head._M_next;</a>
<a name="ln491">	this-&gt;_M_head._M_next = __node-&gt;_M_next;</a>
<a name="ln492">	get_allocator().destroy(&amp;__node-&gt;_M_data);</a>
<a name="ln493">	this-&gt;_M_put_node(__node);</a>
<a name="ln494">      }</a>
<a name="ln495"> </a>
<a name="ln496">      iterator</a>
<a name="ln497">      previous(const_iterator __pos)</a>
<a name="ln498">      { return iterator((_Node*) __slist_previous(&amp;this-&gt;_M_head,</a>
<a name="ln499">						  __pos._M_node)); }</a>
<a name="ln500"> </a>
<a name="ln501">      const_iterator</a>
<a name="ln502">      previous(const_iterator __pos) const</a>
<a name="ln503">      { return const_iterator((_Node*) __slist_previous(&amp;this-&gt;_M_head,</a>
<a name="ln504">							__pos._M_node)); }</a>
<a name="ln505"> </a>
<a name="ln506">    private:</a>
<a name="ln507">      _Node*</a>
<a name="ln508">      _M_insert_after(_Node_base* __pos, const value_type&amp; __x)</a>
<a name="ln509">      { return (_Node*) (__slist_make_link(__pos, _M_create_node(__x))); }</a>
<a name="ln510"> </a>
<a name="ln511">      _Node*</a>
<a name="ln512">      _M_insert_after(_Node_base* __pos)</a>
<a name="ln513">      { return (_Node*) (__slist_make_link(__pos, _M_create_node())); }</a>
<a name="ln514"> </a>
<a name="ln515">      void</a>
<a name="ln516">      _M_insert_after_fill(_Node_base* __pos,</a>
<a name="ln517">			   size_type __n, const value_type&amp; __x)</a>
<a name="ln518">      {</a>
<a name="ln519">	for (size_type __i = 0; __i &lt; __n; ++__i)</a>
<a name="ln520">	  __pos = __slist_make_link(__pos, _M_create_node(__x));</a>
<a name="ln521">      }</a>
<a name="ln522"> </a>
<a name="ln523">      // Check whether it's an integral type.  If so, it's not an iterator.</a>
<a name="ln524">      template &lt;class _InIterator&gt;</a>
<a name="ln525">        void</a>
<a name="ln526">        _M_insert_after_range(_Node_base* __pos,</a>
<a name="ln527">			      _InIterator __first, _InIterator __last)</a>
<a name="ln528">        {</a>
<a name="ln529">	  typedef typename std::__is_integer&lt;_InIterator&gt;::__type _Integral;</a>
<a name="ln530">	  _M_insert_after_range(__pos, __first, __last, _Integral());</a>
<a name="ln531">	}</a>
<a name="ln532"> </a>
<a name="ln533">      template &lt;class _Integer&gt;</a>
<a name="ln534">        void</a>
<a name="ln535">        _M_insert_after_range(_Node_base* __pos, _Integer __n, _Integer __x,</a>
<a name="ln536">			      __true_type)</a>
<a name="ln537">        { _M_insert_after_fill(__pos, __n, __x); }</a>
<a name="ln538"> </a>
<a name="ln539">      template &lt;class _InIterator&gt;</a>
<a name="ln540">        void</a>
<a name="ln541">        _M_insert_after_range(_Node_base* __pos,</a>
<a name="ln542">			      _InIterator __first, _InIterator __last,</a>
<a name="ln543">			      __false_type)</a>
<a name="ln544">        {</a>
<a name="ln545">	  while (__first != __last)</a>
<a name="ln546">	    {</a>
<a name="ln547">	      __pos = __slist_make_link(__pos, _M_create_node(*__first));</a>
<a name="ln548">	      ++__first;</a>
<a name="ln549">	    }</a>
<a name="ln550">	}</a>
<a name="ln551"> </a>
<a name="ln552">    public:</a>
<a name="ln553">      iterator</a>
<a name="ln554">      insert_after(iterator __pos, const value_type&amp; __x)</a>
<a name="ln555">      { return iterator(_M_insert_after(__pos._M_node, __x)); }</a>
<a name="ln556"> </a>
<a name="ln557">      iterator</a>
<a name="ln558">      insert_after(iterator __pos)</a>
<a name="ln559">      { return insert_after(__pos, value_type()); }</a>
<a name="ln560"> </a>
<a name="ln561">      void</a>
<a name="ln562">      insert_after(iterator __pos, size_type __n, const value_type&amp; __x)</a>
<a name="ln563">      { _M_insert_after_fill(__pos._M_node, __n, __x); }</a>
<a name="ln564"> </a>
<a name="ln565">      // We don't need any dispatching tricks here, because</a>
<a name="ln566">      // _M_insert_after_range already does them.</a>
<a name="ln567">      template &lt;class _InIterator&gt;</a>
<a name="ln568">        void</a>
<a name="ln569">        insert_after(iterator __pos, _InIterator __first, _InIterator __last)</a>
<a name="ln570">        { _M_insert_after_range(__pos._M_node, __first, __last); }</a>
<a name="ln571"> </a>
<a name="ln572">      iterator</a>
<a name="ln573">      insert(iterator __pos, const value_type&amp; __x)</a>
<a name="ln574">      { return iterator(_M_insert_after(__slist_previous(&amp;this-&gt;_M_head,</a>
<a name="ln575">							 __pos._M_node),</a>
<a name="ln576">					__x)); }</a>
<a name="ln577"> </a>
<a name="ln578">      iterator</a>
<a name="ln579">      insert(iterator __pos)</a>
<a name="ln580">      { return iterator(_M_insert_after(__slist_previous(&amp;this-&gt;_M_head,</a>
<a name="ln581">							 __pos._M_node),</a>
<a name="ln582">					value_type())); }</a>
<a name="ln583"> </a>
<a name="ln584">      void</a>
<a name="ln585">      insert(iterator __pos, size_type __n, const value_type&amp; __x)</a>
<a name="ln586">      { _M_insert_after_fill(__slist_previous(&amp;this-&gt;_M_head, __pos._M_node),</a>
<a name="ln587">			     __n, __x); }</a>
<a name="ln588"> </a>
<a name="ln589">      // We don't need any dispatching tricks here, because</a>
<a name="ln590">      // _M_insert_after_range already does them.</a>
<a name="ln591">      template &lt;class _InIterator&gt;</a>
<a name="ln592">        void</a>
<a name="ln593">        insert(iterator __pos, _InIterator __first, _InIterator __last)</a>
<a name="ln594">        { _M_insert_after_range(__slist_previous(&amp;this-&gt;_M_head, __pos._M_node),</a>
<a name="ln595">				__first, __last); }</a>
<a name="ln596"> </a>
<a name="ln597">    public:</a>
<a name="ln598">      iterator</a>
<a name="ln599">      erase_after(iterator __pos)</a>
<a name="ln600">      { return iterator((_Node*) this-&gt;_M_erase_after(__pos._M_node)); }</a>
<a name="ln601"> </a>
<a name="ln602">      iterator</a>
<a name="ln603">      erase_after(iterator __before_first, iterator __last)</a>
<a name="ln604">      { </a>
<a name="ln605">	return iterator((_Node*) this-&gt;_M_erase_after(__before_first._M_node,</a>
<a name="ln606">						      __last._M_node));</a>
<a name="ln607">      }</a>
<a name="ln608"> </a>
<a name="ln609">      iterator</a>
<a name="ln610">      erase(iterator __pos)</a>
<a name="ln611">      { </a>
<a name="ln612">	return iterator((_Node*) this-&gt;_M_erase_after</a>
<a name="ln613">			(__slist_previous(&amp;this-&gt;_M_head, __pos._M_node)));</a>
<a name="ln614">      }</a>
<a name="ln615"> </a>
<a name="ln616">      iterator</a>
<a name="ln617">      erase(iterator __first, iterator __last)</a>
<a name="ln618">      { </a>
<a name="ln619">	return iterator((_Node*) this-&gt;_M_erase_after</a>
<a name="ln620">			(__slist_previous(&amp;this-&gt;_M_head, __first._M_node),</a>
<a name="ln621">			 __last._M_node));</a>
<a name="ln622">      }</a>
<a name="ln623">      </a>
<a name="ln624">      void</a>
<a name="ln625">      resize(size_type new_size, const _Tp&amp; __x);</a>
<a name="ln626"> </a>
<a name="ln627">      void</a>
<a name="ln628">      resize(size_type new_size)</a>
<a name="ln629">      { resize(new_size, _Tp()); }</a>
<a name="ln630"> </a>
<a name="ln631">      void</a>
<a name="ln632">      clear()</a>
<a name="ln633">      { this-&gt;_M_erase_after(&amp;this-&gt;_M_head, 0); }</a>
<a name="ln634"> </a>
<a name="ln635">    public:</a>
<a name="ln636">      // Moves the range [__before_first + 1, __before_last + 1) to *this,</a>
<a name="ln637">      //  inserting it immediately after __pos.  This is constant time.</a>
<a name="ln638">      void</a>
<a name="ln639">      splice_after(iterator __pos,</a>
<a name="ln640">		   iterator __before_first, iterator __before_last)</a>
<a name="ln641">      {</a>
<a name="ln642">	if (__before_first != __before_last)</a>
<a name="ln643">	  __slist_splice_after(__pos._M_node, __before_first._M_node,</a>
<a name="ln644">			       __before_last._M_node);</a>
<a name="ln645">      }</a>
<a name="ln646"> </a>
<a name="ln647">      // Moves the element that follows __prev to *this, inserting it</a>
<a name="ln648">      // immediately after __pos.  This is constant time.</a>
<a name="ln649">      void</a>
<a name="ln650">      splice_after(iterator __pos, iterator __prev)</a>
<a name="ln651">      { __slist_splice_after(__pos._M_node,</a>
<a name="ln652">			     __prev._M_node, __prev._M_node-&gt;_M_next); }</a>
<a name="ln653"> </a>
<a name="ln654">      // Removes all of the elements from the list __x to *this, inserting</a>
<a name="ln655">      // them immediately after __pos.  __x must not be *this.  Complexity:</a>
<a name="ln656">      // linear in __x.size().</a>
<a name="ln657">      void</a>
<a name="ln658">      splice_after(iterator __pos, slist&amp; __x)</a>
<a name="ln659">      { __slist_splice_after(__pos._M_node, &amp;__x._M_head); }</a>
<a name="ln660"> </a>
<a name="ln661">      // Linear in distance(begin(), __pos), and linear in __x.size().</a>
<a name="ln662">      void</a>
<a name="ln663">      splice(iterator __pos, slist&amp; __x)</a>
<a name="ln664">      {</a>
<a name="ln665">	if (__x._M_head._M_next)</a>
<a name="ln666">	  __slist_splice_after(__slist_previous(&amp;this-&gt;_M_head, __pos._M_node),</a>
<a name="ln667">			       &amp;__x._M_head,</a>
<a name="ln668">			       __slist_previous(&amp;__x._M_head, 0)); }</a>
<a name="ln669"> </a>
<a name="ln670">      // Linear in distance(begin(), __pos), and in distance(__x.begin(), __i).</a>
<a name="ln671">      void</a>
<a name="ln672">      splice(iterator __pos, slist&amp; __x, iterator __i)</a>
<a name="ln673">      { __slist_splice_after(__slist_previous(&amp;this-&gt;_M_head, __pos._M_node),</a>
<a name="ln674">			     __slist_previous(&amp;__x._M_head, __i._M_node),</a>
<a name="ln675">			     __i._M_node); }</a>
<a name="ln676"> </a>
<a name="ln677">      // Linear in distance(begin(), __pos), in distance(__x.begin(), __first),</a>
<a name="ln678">      // and in distance(__first, __last).</a>
<a name="ln679">      void</a>
<a name="ln680">      splice(iterator __pos, slist&amp; __x, iterator __first, iterator __last)</a>
<a name="ln681">      {</a>
<a name="ln682">	if (__first != __last)</a>
<a name="ln683">	  __slist_splice_after(__slist_previous(&amp;this-&gt;_M_head, __pos._M_node),</a>
<a name="ln684">			       __slist_previous(&amp;__x._M_head, __first._M_node),</a>
<a name="ln685">			       __slist_previous(__first._M_node,</a>
<a name="ln686">						__last._M_node));</a>
<a name="ln687">      }</a>
<a name="ln688"> </a>
<a name="ln689">    public:</a>
<a name="ln690">      void</a>
<a name="ln691">      reverse()</a>
<a name="ln692">      {</a>
<a name="ln693">	if (this-&gt;_M_head._M_next)</a>
<a name="ln694">	  this-&gt;_M_head._M_next = __slist_reverse(this-&gt;_M_head._M_next);</a>
<a name="ln695">      }</a>
<a name="ln696"> </a>
<a name="ln697">      void</a>
<a name="ln698">      remove(const _Tp&amp; __val);</a>
<a name="ln699"> </a>
<a name="ln700">      void</a>
<a name="ln701">      unique();</a>
<a name="ln702">      </a>
<a name="ln703">      void</a>
<a name="ln704">      merge(slist&amp; __x);</a>
<a name="ln705">      </a>
<a name="ln706">      void</a>
<a name="ln707">      sort();</a>
<a name="ln708"> </a>
<a name="ln709">      template &lt;class _Predicate&gt;</a>
<a name="ln710">        void</a>
<a name="ln711">        remove_if(_Predicate __pred);</a>
<a name="ln712"> </a>
<a name="ln713">      template &lt;class _BinaryPredicate&gt;</a>
<a name="ln714">        void</a>
<a name="ln715">        unique(_BinaryPredicate __pred);</a>
<a name="ln716"> </a>
<a name="ln717">      template &lt;class _StrictWeakOrdering&gt;</a>
<a name="ln718">        void</a>
<a name="ln719">        merge(slist&amp;, _StrictWeakOrdering);</a>
<a name="ln720"> </a>
<a name="ln721">      template &lt;class _StrictWeakOrdering&gt;</a>
<a name="ln722">        void</a>
<a name="ln723">        sort(_StrictWeakOrdering __comp);</a>
<a name="ln724">    };</a>
<a name="ln725"> </a>
<a name="ln726">  template &lt;class _Tp, class _Alloc&gt;</a>
<a name="ln727">    slist&lt;_Tp, _Alloc&gt;&amp;</a>
<a name="ln728">    slist&lt;_Tp, _Alloc&gt;::operator=(const slist&lt;_Tp, _Alloc&gt;&amp; __x)</a>
<a name="ln729">    {</a>
<a name="ln730">      if (&amp;__x != this)</a>
<a name="ln731">	{</a>
<a name="ln732">	  _Node_base* __p1 = &amp;this-&gt;_M_head;</a>
<a name="ln733">	  _Node* __n1 = (_Node*) this-&gt;_M_head._M_next;</a>
<a name="ln734">	  const _Node* __n2 = (const _Node*) __x._M_head._M_next;</a>
<a name="ln735">	  while (__n1 &amp;&amp; __n2)</a>
<a name="ln736">	    {</a>
<a name="ln737">	      __n1-&gt;_M_data = __n2-&gt;_M_data;</a>
<a name="ln738">	      __p1 = __n1;</a>
<a name="ln739">	      __n1 = (_Node*) __n1-&gt;_M_next;</a>
<a name="ln740">	      __n2 = (const _Node*) __n2-&gt;_M_next;</a>
<a name="ln741">	    }</a>
<a name="ln742">	  if (__n2 == 0)</a>
<a name="ln743">	    this-&gt;_M_erase_after(__p1, 0);</a>
<a name="ln744">	  else</a>
<a name="ln745">	    _M_insert_after_range(__p1, const_iterator((_Node*)__n2),</a>
<a name="ln746">                                  const_iterator(0));</a>
<a name="ln747">	}</a>
<a name="ln748">      return *this;</a>
<a name="ln749">    }</a>
<a name="ln750"> </a>
<a name="ln751">  template &lt;class _Tp, class _Alloc&gt;</a>
<a name="ln752">    void</a>
<a name="ln753">    slist&lt;_Tp, _Alloc&gt;::_M_fill_assign(size_type __n, const _Tp&amp; __val)</a>
<a name="ln754">    {</a>
<a name="ln755">      _Node_base* __prev = &amp;this-&gt;_M_head;</a>
<a name="ln756">      _Node* __node = (_Node*) this-&gt;_M_head._M_next;</a>
<a name="ln757">      for (; __node != 0 &amp;&amp; __n &gt; 0; --__n)</a>
<a name="ln758">	{</a>
<a name="ln759">	  __node-&gt;_M_data = __val;</a>
<a name="ln760">	  __prev = __node;</a>
<a name="ln761">	  __node = (_Node*) __node-&gt;_M_next;</a>
<a name="ln762">	}</a>
<a name="ln763">      if (__n &gt; 0)</a>
<a name="ln764">	_M_insert_after_fill(__prev, __n, __val);</a>
<a name="ln765">      else</a>
<a name="ln766">	this-&gt;_M_erase_after(__prev, 0);</a>
<a name="ln767">    }</a>
<a name="ln768">  </a>
<a name="ln769">  template &lt;class _Tp, class _Alloc&gt;</a>
<a name="ln770">    template &lt;class _InputIterator&gt;</a>
<a name="ln771">      void</a>
<a name="ln772">      slist&lt;_Tp, _Alloc&gt;::_M_assign_dispatch(_InputIterator __first,</a>
<a name="ln773">					     _InputIterator __last,</a>
<a name="ln774">					     __false_type)</a>
<a name="ln775">      {</a>
<a name="ln776">	_Node_base* __prev = &amp;this-&gt;_M_head;</a>
<a name="ln777">	_Node* __node = (_Node*) this-&gt;_M_head._M_next;</a>
<a name="ln778">	while (__node != 0 &amp;&amp; __first != __last)</a>
<a name="ln779">	  {</a>
<a name="ln780">	    __node-&gt;_M_data = *__first;</a>
<a name="ln781">	    __prev = __node;</a>
<a name="ln782">	    __node = (_Node*) __node-&gt;_M_next;</a>
<a name="ln783">	    ++__first;</a>
<a name="ln784">	  }</a>
<a name="ln785">	if (__first != __last)</a>
<a name="ln786">	  _M_insert_after_range(__prev, __first, __last);</a>
<a name="ln787">	else</a>
<a name="ln788">	  this-&gt;_M_erase_after(__prev, 0);</a>
<a name="ln789">      }</a>
<a name="ln790">  </a>
<a name="ln791">  template &lt;class _Tp, class _Alloc&gt;</a>
<a name="ln792">    inline bool</a>
<a name="ln793">    operator==(const slist&lt;_Tp, _Alloc&gt;&amp; _SL1, const slist&lt;_Tp, _Alloc&gt;&amp; _SL2)</a>
<a name="ln794">    {</a>
<a name="ln795">      typedef typename slist&lt;_Tp,_Alloc&gt;::const_iterator const_iterator;</a>
<a name="ln796">      const_iterator __end1 = _SL1.end();</a>
<a name="ln797">      const_iterator __end2 = _SL2.end();</a>
<a name="ln798">      </a>
<a name="ln799">      const_iterator __i1 = _SL1.begin();</a>
<a name="ln800">      const_iterator __i2 = _SL2.begin();</a>
<a name="ln801">      while (__i1 != __end1 &amp;&amp; __i2 != __end2 &amp;&amp; *__i1 == *__i2)</a>
<a name="ln802">	{</a>
<a name="ln803">	  ++__i1;</a>
<a name="ln804">	  ++__i2;</a>
<a name="ln805">	}</a>
<a name="ln806">      return __i1 == __end1 &amp;&amp; __i2 == __end2;</a>
<a name="ln807">    }</a>
<a name="ln808"> </a>
<a name="ln809"> </a>
<a name="ln810">  template &lt;class _Tp, class _Alloc&gt;</a>
<a name="ln811">    inline bool</a>
<a name="ln812">    operator&lt;(const slist&lt;_Tp, _Alloc&gt;&amp; _SL1, const slist&lt;_Tp, _Alloc&gt;&amp; _SL2)</a>
<a name="ln813">    { return std::lexicographical_compare(_SL1.begin(), _SL1.end(),</a>
<a name="ln814">					  _SL2.begin(), _SL2.end()); }</a>
<a name="ln815"> </a>
<a name="ln816">  template &lt;class _Tp, class _Alloc&gt;</a>
<a name="ln817">    inline bool</a>
<a name="ln818">    operator!=(const slist&lt;_Tp, _Alloc&gt;&amp; _SL1, const slist&lt;_Tp, _Alloc&gt;&amp; _SL2)</a>
<a name="ln819">    { return !(_SL1 == _SL2); }</a>
<a name="ln820"> </a>
<a name="ln821">  template &lt;class _Tp, class _Alloc&gt;</a>
<a name="ln822">    inline bool</a>
<a name="ln823">    operator&gt;(const slist&lt;_Tp, _Alloc&gt;&amp; _SL1, const slist&lt;_Tp, _Alloc&gt;&amp; _SL2)</a>
<a name="ln824">    { return _SL2 &lt; _SL1; }</a>
<a name="ln825"> </a>
<a name="ln826">  template &lt;class _Tp, class _Alloc&gt;</a>
<a name="ln827">    inline bool</a>
<a name="ln828">    operator&lt;=(const slist&lt;_Tp, _Alloc&gt;&amp; _SL1, const slist&lt;_Tp, _Alloc&gt;&amp; _SL2)</a>
<a name="ln829">    { return !(_SL2 &lt; _SL1); }</a>
<a name="ln830"> </a>
<a name="ln831">  template &lt;class _Tp, class _Alloc&gt;</a>
<a name="ln832">    inline bool</a>
<a name="ln833">    operator&gt;=(const slist&lt;_Tp, _Alloc&gt;&amp; _SL1, const slist&lt;_Tp, _Alloc&gt;&amp; _SL2)</a>
<a name="ln834">    { return !(_SL1 &lt; _SL2); }</a>
<a name="ln835"> </a>
<a name="ln836">  template &lt;class _Tp, class _Alloc&gt;</a>
<a name="ln837">    inline void</a>
<a name="ln838">    swap(slist&lt;_Tp, _Alloc&gt;&amp; __x, slist&lt;_Tp, _Alloc&gt;&amp; __y)</a>
<a name="ln839">    { __x.swap(__y); }</a>
<a name="ln840"> </a>
<a name="ln841">  template &lt;class _Tp, class _Alloc&gt;</a>
<a name="ln842">    void</a>
<a name="ln843">    slist&lt;_Tp, _Alloc&gt;::resize(size_type __len, const _Tp&amp; __x)</a>
<a name="ln844">    {</a>
<a name="ln845">      _Node_base* __cur = &amp;this-&gt;_M_head;</a>
<a name="ln846">      while (__cur-&gt;_M_next != 0 &amp;&amp; __len &gt; 0)</a>
<a name="ln847">	{</a>
<a name="ln848">	  --__len;</a>
<a name="ln849">	  __cur = __cur-&gt;_M_next;</a>
<a name="ln850">	}</a>
<a name="ln851">      if (__cur-&gt;_M_next)</a>
<a name="ln852">	this-&gt;_M_erase_after(__cur, 0);</a>
<a name="ln853">      else</a>
<a name="ln854">	_M_insert_after_fill(__cur, __len, __x);</a>
<a name="ln855">    }</a>
<a name="ln856"> </a>
<a name="ln857">  template &lt;class _Tp, class _Alloc&gt;</a>
<a name="ln858">    void</a>
<a name="ln859">    slist&lt;_Tp, _Alloc&gt;::remove(const _Tp&amp; __val)</a>
<a name="ln860">    { </a>
<a name="ln861">      _Node_base* __cur = &amp;this-&gt;_M_head;</a>
<a name="ln862">      while (__cur &amp;&amp; __cur-&gt;_M_next)</a>
<a name="ln863">	{</a>
<a name="ln864">	  if (((_Node*) __cur-&gt;_M_next)-&gt;_M_data == __val)</a>
<a name="ln865">	    this-&gt;_M_erase_after(__cur);</a>
<a name="ln866">	  else</a>
<a name="ln867">	    __cur = __cur-&gt;_M_next;</a>
<a name="ln868">	}</a>
<a name="ln869">    }</a>
<a name="ln870"> </a>
<a name="ln871">  template &lt;class _Tp, class _Alloc&gt;</a>
<a name="ln872">    void</a>
<a name="ln873">    slist&lt;_Tp, _Alloc&gt;::unique()</a>
<a name="ln874">    {</a>
<a name="ln875">      _Node_base* __cur = this-&gt;_M_head._M_next;</a>
<a name="ln876">      if (__cur)</a>
<a name="ln877">	{</a>
<a name="ln878">	  while (__cur-&gt;_M_next)</a>
<a name="ln879">	    {</a>
<a name="ln880">	      if (((_Node*)__cur)-&gt;_M_data</a>
<a name="ln881">		  == ((_Node*)(__cur-&gt;_M_next))-&gt;_M_data)</a>
<a name="ln882">		this-&gt;_M_erase_after(__cur);</a>
<a name="ln883">	      else</a>
<a name="ln884">		__cur = __cur-&gt;_M_next;</a>
<a name="ln885">	    }</a>
<a name="ln886">	}</a>
<a name="ln887">    }</a>
<a name="ln888"> </a>
<a name="ln889">  template &lt;class _Tp, class _Alloc&gt;</a>
<a name="ln890">    void</a>
<a name="ln891">    slist&lt;_Tp, _Alloc&gt;::merge(slist&lt;_Tp, _Alloc&gt;&amp; __x)</a>
<a name="ln892">    {</a>
<a name="ln893">      _Node_base* __n1 = &amp;this-&gt;_M_head;</a>
<a name="ln894">      while (__n1-&gt;_M_next &amp;&amp; __x._M_head._M_next)</a>
<a name="ln895">	{</a>
<a name="ln896">	  if (((_Node*) __x._M_head._M_next)-&gt;_M_data</a>
<a name="ln897">	      &lt; ((_Node*) __n1-&gt;_M_next)-&gt;_M_data)</a>
<a name="ln898">	    __slist_splice_after(__n1, &amp;__x._M_head, __x._M_head._M_next);</a>
<a name="ln899">	  __n1 = __n1-&gt;_M_next;</a>
<a name="ln900">	}</a>
<a name="ln901">      if (__x._M_head._M_next)</a>
<a name="ln902">	{</a>
<a name="ln903">	  __n1-&gt;_M_next = __x._M_head._M_next;</a>
<a name="ln904">	  __x._M_head._M_next = 0;</a>
<a name="ln905">	}</a>
<a name="ln906">    }</a>
<a name="ln907"> </a>
<a name="ln908">  template &lt;class _Tp, class _Alloc&gt;</a>
<a name="ln909">    void</a>
<a name="ln910">    slist&lt;_Tp, _Alloc&gt;::sort()</a>
<a name="ln911">    {</a>
<a name="ln912">      if (this-&gt;_M_head._M_next &amp;&amp; this-&gt;_M_head._M_next-&gt;_M_next)</a>
<a name="ln913">	{</a>
<a name="ln914">	  slist __carry;</a>
<a name="ln915">	  slist __counter[64];</a>
<a name="ln916">	  int __fill = 0;</a>
<a name="ln917">	  while (!empty())</a>
<a name="ln918">	    {</a>
<a name="ln919">	      __slist_splice_after(&amp;__carry._M_head,</a>
<a name="ln920">				   &amp;this-&gt;_M_head, this-&gt;_M_head._M_next);</a>
<a name="ln921">	      int __i = 0;</a>
<a name="ln922">	      while (__i &lt; __fill &amp;&amp; !__counter[__i].empty())</a>
<a name="ln923">		{</a>
<a name="ln924">		  __counter[__i].merge(__carry);</a>
<a name="ln925">		  __carry.swap(__counter[__i]);</a>
<a name="ln926">		  ++__i;</a>
<a name="ln927">		}</a>
<a name="ln928">	      __carry.swap(__counter[__i]);</a>
<a name="ln929">	      if (__i == __fill)</a>
<a name="ln930">		++__fill;</a>
<a name="ln931">	    }</a>
<a name="ln932">	  </a>
<a name="ln933">	  for (int __i = 1; __i &lt; __fill; ++__i)</a>
<a name="ln934">	    __counter[__i].merge(__counter[__i-1]);</a>
<a name="ln935">	  this-&gt;swap(__counter[__fill-1]);</a>
<a name="ln936">	}</a>
<a name="ln937">    }</a>
<a name="ln938"> </a>
<a name="ln939">  template &lt;class _Tp, class _Alloc&gt;</a>
<a name="ln940">    template &lt;class _Predicate&gt;</a>
<a name="ln941">      void slist&lt;_Tp, _Alloc&gt;::remove_if(_Predicate __pred)</a>
<a name="ln942">      {</a>
<a name="ln943">	_Node_base* __cur = &amp;this-&gt;_M_head;</a>
<a name="ln944">	while (__cur-&gt;_M_next)</a>
<a name="ln945">	  {</a>
<a name="ln946">	    if (__pred(((_Node*) __cur-&gt;_M_next)-&gt;_M_data))</a>
<a name="ln947">	      this-&gt;_M_erase_after(__cur);</a>
<a name="ln948">	    else</a>
<a name="ln949">	      __cur = __cur-&gt;_M_next;</a>
<a name="ln950">	  }</a>
<a name="ln951">      }</a>
<a name="ln952"> </a>
<a name="ln953">  template &lt;class _Tp, class _Alloc&gt;</a>
<a name="ln954">    template &lt;class _BinaryPredicate&gt;</a>
<a name="ln955">      void</a>
<a name="ln956">      slist&lt;_Tp, _Alloc&gt;::unique(_BinaryPredicate __pred)</a>
<a name="ln957">      {</a>
<a name="ln958">	_Node* __cur = (_Node*) this-&gt;_M_head._M_next;</a>
<a name="ln959">	if (__cur)</a>
<a name="ln960">	  {</a>
<a name="ln961">	    while (__cur-&gt;_M_next)</a>
<a name="ln962">	      {</a>
<a name="ln963">		if (__pred(((_Node*)__cur)-&gt;_M_data,</a>
<a name="ln964">			   ((_Node*)(__cur-&gt;_M_next))-&gt;_M_data))</a>
<a name="ln965">		  this-&gt;_M_erase_after(__cur);</a>
<a name="ln966">		else</a>
<a name="ln967">		  __cur = (_Node*) __cur-&gt;_M_next;</a>
<a name="ln968">	      }</a>
<a name="ln969">	  }</a>
<a name="ln970">      }</a>
<a name="ln971"> </a>
<a name="ln972">  template &lt;class _Tp, class _Alloc&gt;</a>
<a name="ln973">    template &lt;class _StrictWeakOrdering&gt;</a>
<a name="ln974">      void</a>
<a name="ln975">      slist&lt;_Tp, _Alloc&gt;::merge(slist&lt;_Tp, _Alloc&gt;&amp; __x,</a>
<a name="ln976">			       _StrictWeakOrdering __comp)</a>
<a name="ln977">      {</a>
<a name="ln978">	_Node_base* __n1 = &amp;this-&gt;_M_head;</a>
<a name="ln979">	while (__n1-&gt;_M_next &amp;&amp; __x._M_head._M_next)</a>
<a name="ln980">	  {</a>
<a name="ln981">	    if (__comp(((_Node*) __x._M_head._M_next)-&gt;_M_data,</a>
<a name="ln982">		       ((_Node*) __n1-&gt;_M_next)-&gt;_M_data))</a>
<a name="ln983">	      __slist_splice_after(__n1, &amp;__x._M_head, __x._M_head._M_next);</a>
<a name="ln984">	    __n1 = __n1-&gt;_M_next;</a>
<a name="ln985">	  }</a>
<a name="ln986">	if (__x._M_head._M_next)</a>
<a name="ln987">	  {</a>
<a name="ln988">	    __n1-&gt;_M_next = __x._M_head._M_next;</a>
<a name="ln989">	    __x._M_head._M_next = 0;</a>
<a name="ln990">	  }</a>
<a name="ln991">      }</a>
<a name="ln992"> </a>
<a name="ln993">  template &lt;class _Tp, class _Alloc&gt;</a>
<a name="ln994">    template &lt;class _StrictWeakOrdering&gt;</a>
<a name="ln995">      void</a>
<a name="ln996">      slist&lt;_Tp, _Alloc&gt;::sort(_StrictWeakOrdering __comp)</a>
<a name="ln997">      {</a>
<a name="ln998">	if (this-&gt;_M_head._M_next &amp;&amp; this-&gt;_M_head._M_next-&gt;_M_next)</a>
<a name="ln999">	  {</a>
<a name="ln1000">	    slist __carry;</a>
<a name="ln1001">	    slist __counter[64];</a>
<a name="ln1002">	    int __fill = 0;</a>
<a name="ln1003">	    while (!empty())</a>
<a name="ln1004">	      {</a>
<a name="ln1005">		__slist_splice_after(&amp;__carry._M_head,</a>
<a name="ln1006">				     &amp;this-&gt;_M_head, this-&gt;_M_head._M_next);</a>
<a name="ln1007">		int __i = 0;</a>
<a name="ln1008">		while (__i &lt; __fill &amp;&amp; !__counter[__i].empty())</a>
<a name="ln1009">		  {</a>
<a name="ln1010">		    __counter[__i].merge(__carry, __comp);</a>
<a name="ln1011">		    __carry.swap(__counter[__i]);</a>
<a name="ln1012">		    ++__i;</a>
<a name="ln1013">		  }</a>
<a name="ln1014">		__carry.swap(__counter[__i]);</a>
<a name="ln1015">		if (__i == __fill)</a>
<a name="ln1016">		  ++__fill;</a>
<a name="ln1017">	      }</a>
<a name="ln1018"> </a>
<a name="ln1019">	    for (int __i = 1; __i &lt; __fill; ++__i)</a>
<a name="ln1020">	      __counter[__i].merge(__counter[__i-1], __comp);</a>
<a name="ln1021">	    this-&gt;swap(__counter[__fill-1]);</a>
<a name="ln1022">	  }</a>
<a name="ln1023">      }</a>
<a name="ln1024"> </a>
<a name="ln1025">_GLIBCXX_END_NAMESPACE_VERSION</a>
<a name="ln1026">} // namespace</a>
<a name="ln1027"> </a>
<a name="ln1028">namespace std _GLIBCXX_VISIBILITY(default)</a>
<a name="ln1029">{</a>
<a name="ln1030">_GLIBCXX_BEGIN_NAMESPACE_VERSION</a>
<a name="ln1031"> </a>
<a name="ln1032">  // Specialization of insert_iterator so that insertions will be constant</a>
<a name="ln1033">  // time rather than linear time.</a>
<a name="ln1034">  template &lt;class _Tp, class _Alloc&gt;</a>
<a name="ln1035">    class insert_iterator&lt;__gnu_cxx::slist&lt;_Tp, _Alloc&gt; &gt;</a>
<a name="ln1036">    {</a>
<a name="ln1037">    protected:</a>
<a name="ln1038">      typedef __gnu_cxx::slist&lt;_Tp, _Alloc&gt; _Container;</a>
<a name="ln1039">      _Container* container;</a>
<a name="ln1040">      typename _Container::iterator iter;</a>
<a name="ln1041"> </a>
<a name="ln1042">    public:</a>
<a name="ln1043">      typedef _Container          container_type;</a>
<a name="ln1044">      typedef output_iterator_tag iterator_category;</a>
<a name="ln1045">      typedef void                value_type;</a>
<a name="ln1046">      typedef void                difference_type;</a>
<a name="ln1047">      typedef void                pointer;</a>
<a name="ln1048">      typedef void                reference;</a>
<a name="ln1049"> </a>
<a name="ln1050">      insert_iterator(_Container&amp; __x, typename _Container::iterator __i)</a>
<a name="ln1051">      : container(&amp;__x)</a>
<a name="ln1052">      {</a>
<a name="ln1053">	if (__i == __x.begin())</a>
<a name="ln1054">	  iter = __x.before_begin();</a>
<a name="ln1055">	else</a>
<a name="ln1056">	  iter = __x.previous(__i);</a>
<a name="ln1057">      }</a>
<a name="ln1058"> </a>
<a name="ln1059">      insert_iterator&lt;_Container&gt;&amp;</a>
<a name="ln1060">      operator=(const typename _Container::value_type&amp; __value)</a>
<a name="ln1061">      {</a>
<a name="ln1062">	iter = container-&gt;insert_after(iter, __value);</a>
<a name="ln1063">	return *this;</a>
<a name="ln1064">      }</a>
<a name="ln1065"> </a>
<a name="ln1066">      insert_iterator&lt;_Container&gt;&amp;</a>
<a name="ln1067">      operator*()</a>
<a name="ln1068">      { return *this; }</a>
<a name="ln1069"> </a>
<a name="ln1070">      insert_iterator&lt;_Container&gt;&amp;</a>
<a name="ln1071">      operator++()</a>
<a name="ln1072">      { return *this; }</a>
<a name="ln1073"> </a>
<a name="ln1074">      insert_iterator&lt;_Container&gt;&amp;</a>
<a name="ln1075">      operator++(int)</a>
<a name="ln1076">      { return *this; }</a>
<a name="ln1077">    };</a>
<a name="ln1078"> </a>
<a name="ln1079">_GLIBCXX_END_NAMESPACE_VERSION</a>
<a name="ln1080">} // namespace</a>
<a name="ln1081"> </a>
<a name="ln1082">#endif</a>

</code></pre>
<div class="balloon" rel="447"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v717/" target="_blank">V717</a> It is suspicious to cast object of base class '_Slist_node_base' to derived class '_Slist_node'.</p></div>
<div class="balloon" rel="451"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v717/" target="_blank">V717</a> It is suspicious to cast object of base class '_Slist_node_base' to derived class '_Slist_node'.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
