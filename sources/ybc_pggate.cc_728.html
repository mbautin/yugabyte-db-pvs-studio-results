
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ybc_pggate.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Copyright (c) YugaByte, Inc.</a>
<a name="ln2">//</a>
<a name="ln3">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln4">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln5">//</a>
<a name="ln6">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln7">//</a>
<a name="ln8">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln9">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln10">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln11">// under the License.</a>
<a name="ln12"> </a>
<a name="ln13">#include &lt;algorithm&gt;</a>
<a name="ln14">#include &lt;string&gt;</a>
<a name="ln15"> </a>
<a name="ln16">#include &lt;cds/init.h&gt; // NOLINT</a>
<a name="ln17"> </a>
<a name="ln18">#include &quot;yb/common/common_flags.h&quot;</a>
<a name="ln19">#include &quot;yb/common/ybc-internal.h&quot;</a>
<a name="ln20">#include &quot;yb/util/atomic.h&quot;</a>
<a name="ln21"> </a>
<a name="ln22">#include &quot;yb/yql/pggate/ybc_pggate.h&quot;</a>
<a name="ln23">#include &quot;yb/yql/pggate/pggate.h&quot;</a>
<a name="ln24">#include &quot;yb/yql/pggate/pggate_thread_local_vars.h&quot;</a>
<a name="ln25">#include &quot;yb/yql/pggate/pg_txn_manager.h&quot;</a>
<a name="ln26">#include &quot;yb/yql/pggate/pggate_flags.h&quot;</a>
<a name="ln27"> </a>
<a name="ln28">DECLARE_bool(client_suppress_created_logs);</a>
<a name="ln29"> </a>
<a name="ln30">DEFINE_int32(pggate_num_connections_to_server, 1,</a>
<a name="ln31">             &quot;Number of underlying connections to each server from a PostgreSQL backend process. &quot;</a>
<a name="ln32">             &quot;This overrides the value of --num_connections_to_server.&quot;);</a>
<a name="ln33"> </a>
<a name="ln34">DECLARE_int32(num_connections_to_server);</a>
<a name="ln35"> </a>
<a name="ln36">DECLARE_int32(delay_alter_sequence_sec);</a>
<a name="ln37"> </a>
<a name="ln38">DECLARE_int32(client_read_write_timeout_ms);</a>
<a name="ln39"> </a>
<a name="ln40">namespace yb {</a>
<a name="ln41">namespace pggate {</a>
<a name="ln42"> </a>
<a name="ln43">//--------------------------------------------------------------------------------------------------</a>
<a name="ln44">// C++ Implementation.</a>
<a name="ln45">// All C++ objects and structures in this module are listed in the following namespace.</a>
<a name="ln46">//--------------------------------------------------------------------------------------------------</a>
<a name="ln47">namespace {</a>
<a name="ln48"> </a>
<a name="ln49">// Using a raw pointer here to fully control object initialization and destruction.</a>
<a name="ln50">pggate::PgApiImpl* pgapi;</a>
<a name="ln51">std::atomic&lt;bool&gt; pgapi_shutdown_done;</a>
<a name="ln52"> </a>
<a name="ln53">template&lt;class T&gt;</a>
<a name="ln54">YBCStatus ExtractValueFromResult(const Result&lt;T&gt;&amp; result, T* value) {</a>
<a name="ln55">  if (result.ok()) {</a>
<a name="ln56">    *value = *result;</a>
<a name="ln57">    return YBCStatusOK();</a>
<a name="ln58">  }</a>
<a name="ln59">  return ToYBCStatus(result.status());</a>
<a name="ln60">}</a>
<a name="ln61"> </a>
<a name="ln62">} // anonymous namespace</a>
<a name="ln63"> </a>
<a name="ln64">//--------------------------------------------------------------------------------------------------</a>
<a name="ln65">// C API.</a>
<a name="ln66">//--------------------------------------------------------------------------------------------------</a>
<a name="ln67">extern &quot;C&quot; {</a>
<a name="ln68"> </a>
<a name="ln69">void YBCInitPgGate(const YBCPgTypeEntity *YBCDataTypeTable, int count, PgCallbacks pg_callbacks) {</a>
<a name="ln70">  InitThreading();</a>
<a name="ln71"> </a>
<a name="ln72">  CHECK(pgapi == nullptr) &lt;&lt; &quot;: &quot; &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; &quot; can only be called once&quot;;</a>
<a name="ln73"> </a>
<a name="ln74">  YBCInitFlags();</a>
<a name="ln75"> </a>
<a name="ln76">  pgapi_shutdown_done.exchange(false);</a>
<a name="ln77">  pgapi = new pggate::PgApiImpl(YBCDataTypeTable, count, pg_callbacks);</a>
<a name="ln78">  VLOG(1) &lt;&lt; &quot;PgGate open&quot;;</a>
<a name="ln79">}</a>
<a name="ln80"> </a>
<a name="ln81">void YBCDestroyPgGate() {</a>
<a name="ln82">  if (pgapi_shutdown_done.exchange(true)) {</a>
<a name="ln83">    LOG(DFATAL) &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; &quot; should only be called once&quot;;</a>
<a name="ln84">  } else {</a>
<a name="ln85">    pggate::PgApiImpl* local_pgapi = pgapi;</a>
<a name="ln86">    pgapi = nullptr; // YBCPgIsYugaByteEnabled() must return false from now on.</a>
<a name="ln87">    delete local_pgapi;</a>
<a name="ln88">    VLOG(1) &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; &quot; finished&quot;;</a>
<a name="ln89">  }</a>
<a name="ln90">}</a>
<a name="ln91"> </a>
<a name="ln92">YBCStatus YBCPgCreateEnv(YBCPgEnv *pg_env) {</a>
<a name="ln93">  return ToYBCStatus(pgapi-&gt;CreateEnv(pg_env));</a>
<a name="ln94">}</a>
<a name="ln95"> </a>
<a name="ln96">YBCStatus YBCPgDestroyEnv(YBCPgEnv pg_env) {</a>
<a name="ln97">  return ToYBCStatus(pgapi-&gt;DestroyEnv(pg_env));</a>
<a name="ln98">}</a>
<a name="ln99"> </a>
<a name="ln100">YBCStatus YBCPgInitSession(const YBCPgEnv pg_env,</a>
<a name="ln101">                           const char *database_name) {</a>
<a name="ln102">  const string db_name(database_name ? database_name : &quot;&quot;);</a>
<a name="ln103">  return ToYBCStatus(pgapi-&gt;InitSession(pg_env, db_name));</a>
<a name="ln104">}</a>
<a name="ln105"> </a>
<a name="ln106">YBCPgMemctx YBCPgCreateMemctx() {</a>
<a name="ln107">  return pgapi-&gt;CreateMemctx();</a>
<a name="ln108">}</a>
<a name="ln109"> </a>
<a name="ln110">YBCStatus YBCPgDestroyMemctx(YBCPgMemctx memctx) {</a>
<a name="ln111">  return ToYBCStatus(pgapi-&gt;DestroyMemctx(memctx));</a>
<a name="ln112">}</a>
<a name="ln113"> </a>
<a name="ln114">YBCStatus YBCPgResetMemctx(YBCPgMemctx memctx) {</a>
<a name="ln115">  return ToYBCStatus(pgapi-&gt;ResetMemctx(memctx));</a>
<a name="ln116">}</a>
<a name="ln117"> </a>
<a name="ln118">YBCStatus YBCPgInvalidateCache() {</a>
<a name="ln119">  return ToYBCStatus(pgapi-&gt;InvalidateCache());</a>
<a name="ln120">}</a>
<a name="ln121"> </a>
<a name="ln122">const YBCPgTypeEntity *YBCPgFindTypeEntity(int type_oid) {</a>
<a name="ln123">  return pgapi-&gt;FindTypeEntity(type_oid);</a>
<a name="ln124">}</a>
<a name="ln125"> </a>
<a name="ln126">YBCPgDataType YBCPgGetType(const YBCPgTypeEntity *type_entity) {</a>
<a name="ln127">  if (type_entity) {</a>
<a name="ln128">    return type_entity-&gt;yb_type;</a>
<a name="ln129">  }</a>
<a name="ln130">  return YB_YQL_DATA_TYPE_UNKNOWN_DATA;</a>
<a name="ln131">}</a>
<a name="ln132"> </a>
<a name="ln133">bool YBCPgAllowForPrimaryKey(const YBCPgTypeEntity *type_entity) {</a>
<a name="ln134">  if (type_entity) {</a>
<a name="ln135">    return type_entity-&gt;allow_for_primary_key;</a>
<a name="ln136">  }</a>
<a name="ln137">  return false;</a>
<a name="ln138">}</a>
<a name="ln139"> </a>
<a name="ln140">//--------------------------------------------------------------------------------------------------</a>
<a name="ln141">// DDL Statements.</a>
<a name="ln142">//--------------------------------------------------------------------------------------------------</a>
<a name="ln143">// Database Operations -----------------------------------------------------------------------------</a>
<a name="ln144"> </a>
<a name="ln145">YBCStatus YBCPgConnectDatabase(const char *database_name) {</a>
<a name="ln146">  return ToYBCStatus(pgapi-&gt;ConnectDatabase(database_name));</a>
<a name="ln147">}</a>
<a name="ln148"> </a>
<a name="ln149">YBCStatus YBCPgIsDatabaseColocated(const YBCPgOid database_oid, bool *colocated) {</a>
<a name="ln150">  return ToYBCStatus(pgapi-&gt;IsDatabaseColocated(database_oid, colocated));</a>
<a name="ln151">}</a>
<a name="ln152"> </a>
<a name="ln153">YBCStatus YBCPgNewCreateDatabase(const char *database_name,</a>
<a name="ln154">                                 const YBCPgOid database_oid,</a>
<a name="ln155">                                 const YBCPgOid source_database_oid,</a>
<a name="ln156">                                 const YBCPgOid next_oid,</a>
<a name="ln157">                                 const bool colocated,</a>
<a name="ln158">                                 YBCPgStatement *handle) {</a>
<a name="ln159">  return ToYBCStatus(pgapi-&gt;NewCreateDatabase(</a>
<a name="ln160">      database_name, database_oid, source_database_oid, next_oid, colocated, handle));</a>
<a name="ln161">}</a>
<a name="ln162"> </a>
<a name="ln163">YBCStatus YBCPgExecCreateDatabase(YBCPgStatement handle) {</a>
<a name="ln164">  return ToYBCStatus(pgapi-&gt;ExecCreateDatabase(handle));</a>
<a name="ln165">}</a>
<a name="ln166"> </a>
<a name="ln167">YBCStatus YBCPgNewDropDatabase(const char *database_name,</a>
<a name="ln168">                               const YBCPgOid database_oid,</a>
<a name="ln169">                               YBCPgStatement *handle) {</a>
<a name="ln170">  return ToYBCStatus(pgapi-&gt;NewDropDatabase(database_name, database_oid, handle));</a>
<a name="ln171">}</a>
<a name="ln172"> </a>
<a name="ln173">YBCStatus YBCPgExecDropDatabase(YBCPgStatement handle) {</a>
<a name="ln174">  return ToYBCStatus(pgapi-&gt;ExecDropDatabase(handle));</a>
<a name="ln175">}</a>
<a name="ln176"> </a>
<a name="ln177">YBCStatus YBCPgNewAlterDatabase(const char *database_name,</a>
<a name="ln178">                               const YBCPgOid database_oid,</a>
<a name="ln179">                               YBCPgStatement *handle) {</a>
<a name="ln180">  return ToYBCStatus(pgapi-&gt;NewAlterDatabase(database_name, database_oid, handle));</a>
<a name="ln181">}</a>
<a name="ln182"> </a>
<a name="ln183">YBCStatus YBCPgAlterDatabaseRenameDatabase(YBCPgStatement handle, const char *newname) {</a>
<a name="ln184">  return ToYBCStatus(pgapi-&gt;AlterDatabaseRenameDatabase(handle, newname));</a>
<a name="ln185">}</a>
<a name="ln186"> </a>
<a name="ln187">YBCStatus YBCPgExecAlterDatabase(YBCPgStatement handle) {</a>
<a name="ln188">  return ToYBCStatus(pgapi-&gt;ExecAlterDatabase(handle));</a>
<a name="ln189">}</a>
<a name="ln190"> </a>
<a name="ln191">YBCStatus YBCPgReserveOids(const YBCPgOid database_oid,</a>
<a name="ln192">                           const YBCPgOid next_oid,</a>
<a name="ln193">                           const uint32_t count,</a>
<a name="ln194">                           YBCPgOid *begin_oid,</a>
<a name="ln195">                           YBCPgOid *end_oid) {</a>
<a name="ln196">  return ToYBCStatus(pgapi-&gt;ReserveOids(database_oid, next_oid, count,</a>
<a name="ln197">                                        begin_oid, end_oid));</a>
<a name="ln198">}</a>
<a name="ln199"> </a>
<a name="ln200">YBCStatus YBCPgGetCatalogMasterVersion(uint64_t *version) {</a>
<a name="ln201">  return ToYBCStatus(pgapi-&gt;GetCatalogMasterVersion(version));</a>
<a name="ln202">}</a>
<a name="ln203"> </a>
<a name="ln204">void YBCPgInvalidateTableCache(</a>
<a name="ln205">    const YBCPgOid database_oid,</a>
<a name="ln206">    const YBCPgOid table_oid) {</a>
<a name="ln207">  const PgObjectId table_id(database_oid, table_oid);</a>
<a name="ln208">  pgapi-&gt;InvalidateTableCache(table_id);</a>
<a name="ln209">}</a>
<a name="ln210"> </a>
<a name="ln211">YBCStatus YBCPgInvalidateTableCacheByTableId(const char *table_id) {</a>
<a name="ln212">  if (table_id == NULL) {</a>
<a name="ln213">    return ToYBCStatus(STATUS(InvalidArgument, &quot;table_id is null&quot;));</a>
<a name="ln214">  }</a>
<a name="ln215">  std::string table_id_str = table_id;</a>
<a name="ln216">  const PgObjectId pg_object_id(table_id_str);</a>
<a name="ln217">  pgapi-&gt;InvalidateTableCache(pg_object_id);</a>
<a name="ln218">  return YBCStatusOK();</a>
<a name="ln219">}</a>
<a name="ln220"> </a>
<a name="ln221">// Tablegroup Operations ---------------------------------------------------------------------------</a>
<a name="ln222"> </a>
<a name="ln223">YBCStatus YBCPgNewCreateTablegroup(const char *database_name,</a>
<a name="ln224">                                   YBCPgOid database_oid,</a>
<a name="ln225">                                   YBCPgOid tablegroup_oid,</a>
<a name="ln226">                                   YBCPgStatement *handle) {</a>
<a name="ln227">  return ToYBCStatus(pgapi-&gt;NewCreateTablegroup(database_name,</a>
<a name="ln228">                                                database_oid,</a>
<a name="ln229">                                                tablegroup_oid,</a>
<a name="ln230">                                                handle));</a>
<a name="ln231">}</a>
<a name="ln232"> </a>
<a name="ln233">YBCStatus YBCPgExecCreateTablegroup(YBCPgStatement handle) {</a>
<a name="ln234">  return ToYBCStatus(pgapi-&gt;ExecCreateTablegroup(handle));</a>
<a name="ln235">}</a>
<a name="ln236"> </a>
<a name="ln237">YBCStatus YBCPgNewDropTablegroup(YBCPgOid database_oid,</a>
<a name="ln238">                                 YBCPgOid tablegroup_oid,</a>
<a name="ln239">                                 YBCPgStatement *handle) {</a>
<a name="ln240">  return ToYBCStatus(pgapi-&gt;NewDropTablegroup(database_oid,</a>
<a name="ln241">                                              tablegroup_oid,</a>
<a name="ln242">                                              handle));</a>
<a name="ln243">}</a>
<a name="ln244">YBCStatus YBCPgExecDropTablegroup(YBCPgStatement handle) {</a>
<a name="ln245">  return ToYBCStatus(pgapi-&gt;ExecDropTablegroup(handle));</a>
<a name="ln246">}</a>
<a name="ln247"> </a>
<a name="ln248">// Statement Operations ----------------------------------------------------------------------------</a>
<a name="ln249"> </a>
<a name="ln250">YBCStatus YBCPgClearBinds(YBCPgStatement handle) {</a>
<a name="ln251">  return ToYBCStatus(pgapi-&gt;ClearBinds(handle));</a>
<a name="ln252">}</a>
<a name="ln253"> </a>
<a name="ln254">// Sequence Operations -----------------------------------------------------------------------------</a>
<a name="ln255"> </a>
<a name="ln256">YBCStatus YBCInsertSequenceTuple(int64_t db_oid,</a>
<a name="ln257">                                 int64_t seq_oid,</a>
<a name="ln258">                                 uint64_t ysql_catalog_version,</a>
<a name="ln259">                                 int64_t last_val,</a>
<a name="ln260">                                 bool is_called) {</a>
<a name="ln261">  return ToYBCStatus(pgapi-&gt;InsertSequenceTuple(</a>
<a name="ln262">      db_oid, seq_oid, ysql_catalog_version, last_val, is_called));</a>
<a name="ln263">}</a>
<a name="ln264"> </a>
<a name="ln265">YBCStatus YBCUpdateSequenceTupleConditionally(int64_t db_oid,</a>
<a name="ln266">                                              int64_t seq_oid,</a>
<a name="ln267">                                              uint64_t ysql_catalog_version,</a>
<a name="ln268">                                              int64_t last_val,</a>
<a name="ln269">                                              bool is_called,</a>
<a name="ln270">                                              int64_t expected_last_val,</a>
<a name="ln271">                                              bool expected_is_called,</a>
<a name="ln272">                                              bool *skipped) {</a>
<a name="ln273">  return ToYBCStatus(</a>
<a name="ln274">      pgapi-&gt;UpdateSequenceTupleConditionally(db_oid, seq_oid, ysql_catalog_version,</a>
<a name="ln275">          last_val, is_called, expected_last_val, expected_is_called, skipped));</a>
<a name="ln276">}</a>
<a name="ln277"> </a>
<a name="ln278">YBCStatus YBCUpdateSequenceTuple(int64_t db_oid,</a>
<a name="ln279">                                 int64_t seq_oid,</a>
<a name="ln280">                                 uint64_t ysql_catalog_version,</a>
<a name="ln281">                                 int64_t last_val,</a>
<a name="ln282">                                 bool is_called,</a>
<a name="ln283">                                 bool* skipped) {</a>
<a name="ln284">  return ToYBCStatus(pgapi-&gt;UpdateSequenceTuple(</a>
<a name="ln285">      db_oid, seq_oid, ysql_catalog_version, last_val, is_called, skipped));</a>
<a name="ln286">}</a>
<a name="ln287"> </a>
<a name="ln288">YBCStatus YBCReadSequenceTuple(int64_t db_oid,</a>
<a name="ln289">                               int64_t seq_oid,</a>
<a name="ln290">                               uint64_t ysql_catalog_version,</a>
<a name="ln291">                               int64_t *last_val,</a>
<a name="ln292">                               bool *is_called) {</a>
<a name="ln293">  return ToYBCStatus(pgapi-&gt;ReadSequenceTuple(</a>
<a name="ln294">      db_oid, seq_oid, ysql_catalog_version, last_val, is_called));</a>
<a name="ln295">}</a>
<a name="ln296"> </a>
<a name="ln297">YBCStatus YBCDeleteSequenceTuple(int64_t db_oid, int64_t seq_oid) {</a>
<a name="ln298">  return ToYBCStatus(pgapi-&gt;DeleteSequenceTuple(db_oid, seq_oid));</a>
<a name="ln299">}</a>
<a name="ln300"> </a>
<a name="ln301">// Table Operations -------------------------------------------------------------------------------</a>
<a name="ln302"> </a>
<a name="ln303">YBCStatus YBCPgNewCreateTable(const char *database_name,</a>
<a name="ln304">                              const char *schema_name,</a>
<a name="ln305">                              const char *table_name,</a>
<a name="ln306">                              const YBCPgOid database_oid,</a>
<a name="ln307">                              const YBCPgOid table_oid,</a>
<a name="ln308">                              bool is_shared_table,</a>
<a name="ln309">                              bool if_not_exist,</a>
<a name="ln310">                              bool add_primary_key,</a>
<a name="ln311">                              const bool colocated,</a>
<a name="ln312">                              const YBCPgOid tablegroup_oid,</a>
<a name="ln313">                              YBCPgStatement *handle) {</a>
<a name="ln314">  const PgObjectId table_id(database_oid, table_oid);</a>
<a name="ln315">  const PgObjectId tablegroup_id(database_oid, tablegroup_oid);</a>
<a name="ln316">  return ToYBCStatus(pgapi-&gt;NewCreateTable(</a>
<a name="ln317">      database_name, schema_name, table_name, table_id, is_shared_table,</a>
<a name="ln318">      if_not_exist, add_primary_key, colocated, tablegroup_id, handle));</a>
<a name="ln319">}</a>
<a name="ln320"> </a>
<a name="ln321">YBCStatus YBCPgCreateTableAddColumn(YBCPgStatement handle, const char *attr_name, int attr_num,</a>
<a name="ln322">                                    const YBCPgTypeEntity *attr_type, bool is_hash, bool is_range,</a>
<a name="ln323">                                    bool is_desc, bool is_nulls_first) {</a>
<a name="ln324">  return ToYBCStatus(pgapi-&gt;CreateTableAddColumn(handle, attr_name, attr_num, attr_type,</a>
<a name="ln325">                                                 is_hash, is_range, is_desc, is_nulls_first));</a>
<a name="ln326">}</a>
<a name="ln327"> </a>
<a name="ln328">YBCStatus YBCPgCreateTableSetNumTablets(YBCPgStatement handle, int32_t num_tablets) {</a>
<a name="ln329">  return ToYBCStatus(pgapi-&gt;CreateTableSetNumTablets(handle, num_tablets));</a>
<a name="ln330">}</a>
<a name="ln331"> </a>
<a name="ln332">YBCStatus YBCPgCreateTableAddSplitRow(YBCPgStatement handle, int num_cols,</a>
<a name="ln333">    YBCPgTypeEntity **types, uint64_t *data) {</a>
<a name="ln334">  return ToYBCStatus(pgapi-&gt;CreateTableAddSplitRow(handle, num_cols, types, data));</a>
<a name="ln335">}</a>
<a name="ln336"> </a>
<a name="ln337">YBCStatus YBCPgExecCreateTable(YBCPgStatement handle) {</a>
<a name="ln338">  return ToYBCStatus(pgapi-&gt;ExecCreateTable(handle));</a>
<a name="ln339">}</a>
<a name="ln340"> </a>
<a name="ln341">YBCStatus YBCPgNewAlterTable(const YBCPgOid database_oid,</a>
<a name="ln342">                             const YBCPgOid table_oid,</a>
<a name="ln343">                             YBCPgStatement *handle) {</a>
<a name="ln344">  const PgObjectId table_id(database_oid, table_oid);</a>
<a name="ln345">  return ToYBCStatus(pgapi-&gt;NewAlterTable(table_id, handle));</a>
<a name="ln346">}</a>
<a name="ln347"> </a>
<a name="ln348">YBCStatus YBCPgAlterTableAddColumn(YBCPgStatement handle, const char *name, int order,</a>
<a name="ln349">                                   const YBCPgTypeEntity *attr_type, bool is_not_null) {</a>
<a name="ln350">  return ToYBCStatus(pgapi-&gt;AlterTableAddColumn(handle, name, order, attr_type, is_not_null));</a>
<a name="ln351">}</a>
<a name="ln352"> </a>
<a name="ln353">YBCStatus YBCPgAlterTableRenameColumn(YBCPgStatement handle, const char *oldname,</a>
<a name="ln354">                                      const char *newname) {</a>
<a name="ln355">  return ToYBCStatus(pgapi-&gt;AlterTableRenameColumn(handle, oldname, newname));</a>
<a name="ln356">}</a>
<a name="ln357"> </a>
<a name="ln358">YBCStatus YBCPgAlterTableDropColumn(YBCPgStatement handle, const char *name) {</a>
<a name="ln359">  return ToYBCStatus(pgapi-&gt;AlterTableDropColumn(handle, name));</a>
<a name="ln360">}</a>
<a name="ln361"> </a>
<a name="ln362">YBCStatus YBCPgAlterTableRenameTable(YBCPgStatement handle, const char *db_name,</a>
<a name="ln363">                                     const char *newname) {</a>
<a name="ln364">  return ToYBCStatus(pgapi-&gt;AlterTableRenameTable(handle, db_name, newname));</a>
<a name="ln365">}</a>
<a name="ln366"> </a>
<a name="ln367">YBCStatus YBCPgExecAlterTable(YBCPgStatement handle) {</a>
<a name="ln368">  return ToYBCStatus(pgapi-&gt;ExecAlterTable(handle));</a>
<a name="ln369">}</a>
<a name="ln370"> </a>
<a name="ln371">YBCStatus YBCPgNewDropTable(const YBCPgOid database_oid,</a>
<a name="ln372">                            const YBCPgOid table_oid,</a>
<a name="ln373">                            bool if_exist,</a>
<a name="ln374">                            YBCPgStatement *handle) {</a>
<a name="ln375">  const PgObjectId table_id(database_oid, table_oid);</a>
<a name="ln376">  return ToYBCStatus(pgapi-&gt;NewDropTable(table_id, if_exist, handle));</a>
<a name="ln377">}</a>
<a name="ln378"> </a>
<a name="ln379">YBCStatus YBCPgExecDropTable(YBCPgStatement handle) {</a>
<a name="ln380">  return ToYBCStatus(pgapi-&gt;ExecDropTable(handle));</a>
<a name="ln381">}</a>
<a name="ln382"> </a>
<a name="ln383">YBCStatus YBCPgGetTableDesc(const YBCPgOid database_oid,</a>
<a name="ln384">                            const YBCPgOid table_oid,</a>
<a name="ln385">                            YBCPgTableDesc *handle) {</a>
<a name="ln386">  const PgObjectId table_id(database_oid, table_oid);</a>
<a name="ln387">  return ToYBCStatus(pgapi-&gt;GetTableDesc(table_id, handle));</a>
<a name="ln388">}</a>
<a name="ln389"> </a>
<a name="ln390">YBCStatus YBCPgGetColumnInfo(YBCPgTableDesc table_desc,</a>
<a name="ln391">                             int16_t attr_number,</a>
<a name="ln392">                             bool *is_primary,</a>
<a name="ln393">                             bool *is_hash) {</a>
<a name="ln394">  return ToYBCStatus(pgapi-&gt;GetColumnInfo(table_desc, attr_number, is_primary, is_hash));</a>
<a name="ln395">}</a>
<a name="ln396"> </a>
<a name="ln397">YBCStatus YBCPgSetCatalogCacheVersion(YBCPgStatement handle,</a>
<a name="ln398">                                      uint64_t catalog_cache_version) {</a>
<a name="ln399">  return ToYBCStatus(pgapi-&gt;SetCatalogCacheVersion(handle, catalog_cache_version));</a>
<a name="ln400">}</a>
<a name="ln401"> </a>
<a name="ln402">YBCStatus YBCPgDmlModifiesRow(YBCPgStatement handle, bool *modifies_row) {</a>
<a name="ln403">  return ToYBCStatus(pgapi-&gt;DmlModifiesRow(handle, modifies_row));</a>
<a name="ln404">}</a>
<a name="ln405"> </a>
<a name="ln406">YBCStatus YBCPgSetIsSysCatalogVersionChange(YBCPgStatement handle) {</a>
<a name="ln407">  return ToYBCStatus(pgapi-&gt;SetIsSysCatalogVersionChange(handle));</a>
<a name="ln408">}</a>
<a name="ln409"> </a>
<a name="ln410">YBCStatus YBCPgNewTruncateTable(const YBCPgOid database_oid,</a>
<a name="ln411">                                const YBCPgOid table_oid,</a>
<a name="ln412">                                YBCPgStatement *handle) {</a>
<a name="ln413">  const PgObjectId table_id(database_oid, table_oid);</a>
<a name="ln414">  return ToYBCStatus(pgapi-&gt;NewTruncateTable(table_id, handle));</a>
<a name="ln415">}</a>
<a name="ln416"> </a>
<a name="ln417">YBCStatus YBCPgExecTruncateTable(YBCPgStatement handle) {</a>
<a name="ln418">  return ToYBCStatus(pgapi-&gt;ExecTruncateTable(handle));</a>
<a name="ln419">}</a>
<a name="ln420"> </a>
<a name="ln421">YBCStatus YBCPgIsTableColocated(const YBCPgOid database_oid,</a>
<a name="ln422">                                const YBCPgOid table_oid,</a>
<a name="ln423">                                bool *colocated) {</a>
<a name="ln424">  const PgObjectId table_id(database_oid, table_oid);</a>
<a name="ln425">  PgTableDesc::ScopedRefPtr table_desc;</a>
<a name="ln426">  YBCStatus status = ExtractValueFromResult(pgapi-&gt;LoadTable(table_id), &amp;table_desc);</a>
<a name="ln427">  if (status) {</a>
<a name="ln428">    return status;</a>
<a name="ln429">  } else {</a>
<a name="ln430">    *colocated = table_desc-&gt;IsColocated();</a>
<a name="ln431">    return YBCStatusOK();</a>
<a name="ln432">  }</a>
<a name="ln433">}</a>
<a name="ln434"> </a>
<a name="ln435">YBCStatus YBCPgGetTableProperties(YBCPgTableDesc table_desc,</a>
<a name="ln436">                                  YBCPgTableProperties *properties) {</a>
<a name="ln437">  CHECK_NOTNULL(properties)-&gt;num_tablets = table_desc-&gt;GetPartitionCount();</a>
<a name="ln438">  properties-&gt;num_hash_key_columns = table_desc-&gt;num_hash_key_columns();</a>
<a name="ln439">  properties-&gt;is_colocated = table_desc-&gt;IsColocated();</a>
<a name="ln440">  return YBCStatusOK();</a>
<a name="ln441">}</a>
<a name="ln442"> </a>
<a name="ln443">YBCStatus YBCPgTableExists(const YBCPgOid database_oid,</a>
<a name="ln444">                           const YBCPgOid table_oid,</a>
<a name="ln445">                           bool *exists) {</a>
<a name="ln446">  const PgObjectId table_id(database_oid, table_oid);</a>
<a name="ln447">  const auto result = pgapi-&gt;LoadTable(table_id);</a>
<a name="ln448"> </a>
<a name="ln449">  if (result.ok()) {</a>
<a name="ln450">    *exists = true;</a>
<a name="ln451">    return YBCStatusOK();</a>
<a name="ln452">  } else if (result.status().IsNotFound()) {</a>
<a name="ln453">    *exists = false;</a>
<a name="ln454">    return YBCStatusOK();</a>
<a name="ln455">  } else {</a>
<a name="ln456">    return ToYBCStatus(result.status());</a>
<a name="ln457">  }</a>
<a name="ln458">}</a>
<a name="ln459"> </a>
<a name="ln460">// Index Operations -------------------------------------------------------------------------------</a>
<a name="ln461"> </a>
<a name="ln462">YBCStatus YBCPgNewCreateIndex(const char *database_name,</a>
<a name="ln463">                              const char *schema_name,</a>
<a name="ln464">                              const char *index_name,</a>
<a name="ln465">                              const YBCPgOid database_oid,</a>
<a name="ln466">                              const YBCPgOid index_oid,</a>
<a name="ln467">                              const YBCPgOid table_oid,</a>
<a name="ln468">                              bool is_shared_index,</a>
<a name="ln469">                              bool is_unique_index,</a>
<a name="ln470">                              const bool skip_index_backfill,</a>
<a name="ln471">                              bool if_not_exist,</a>
<a name="ln472">                              const YBCPgOid tablegroup_oid,</a>
<a name="ln473">                              YBCPgStatement *handle) {</a>
<a name="ln474">  const PgObjectId index_id(database_oid, index_oid);</a>
<a name="ln475">  const PgObjectId table_id(database_oid, table_oid);</a>
<a name="ln476">  const PgObjectId tablegroup_id(database_oid, tablegroup_oid);</a>
<a name="ln477">  return ToYBCStatus(pgapi-&gt;NewCreateIndex(database_name, schema_name, index_name, index_id,</a>
<a name="ln478">                                           table_id, is_shared_index, is_unique_index,</a>
<a name="ln479">                                           skip_index_backfill, if_not_exist, tablegroup_id,</a>
<a name="ln480">                                           handle));</a>
<a name="ln481">}</a>
<a name="ln482"> </a>
<a name="ln483">YBCStatus YBCPgCreateIndexAddColumn(YBCPgStatement handle, const char *attr_name, int attr_num,</a>
<a name="ln484">                                    const YBCPgTypeEntity *attr_type, bool is_hash, bool is_range,</a>
<a name="ln485">                                    bool is_desc, bool is_nulls_first) {</a>
<a name="ln486">  return ToYBCStatus(pgapi-&gt;CreateIndexAddColumn(handle, attr_name, attr_num, attr_type,</a>
<a name="ln487">                                                 is_hash, is_range, is_desc, is_nulls_first));</a>
<a name="ln488">}</a>
<a name="ln489"> </a>
<a name="ln490">YBCStatus YBCPgCreateIndexSetNumTablets(YBCPgStatement handle, int32_t num_tablets) {</a>
<a name="ln491">  return ToYBCStatus(pgapi-&gt;CreateIndexSetNumTablets(handle, num_tablets));</a>
<a name="ln492">}</a>
<a name="ln493"> </a>
<a name="ln494">YBCStatus YBCPgCreateIndexAddSplitRow(YBCPgStatement handle, int num_cols,</a>
<a name="ln495">                                      YBCPgTypeEntity **types, uint64_t *data) {</a>
<a name="ln496">  return ToYBCStatus(pgapi-&gt;CreateIndexAddSplitRow(handle, num_cols, types, data));</a>
<a name="ln497">}</a>
<a name="ln498"> </a>
<a name="ln499">YBCStatus YBCPgExecCreateIndex(YBCPgStatement handle) {</a>
<a name="ln500">  return ToYBCStatus(pgapi-&gt;ExecCreateIndex(handle));</a>
<a name="ln501">}</a>
<a name="ln502"> </a>
<a name="ln503">YBCStatus YBCPgNewDropIndex(const YBCPgOid database_oid,</a>
<a name="ln504">                            const YBCPgOid index_oid,</a>
<a name="ln505">                            bool if_exist,</a>
<a name="ln506">                            YBCPgStatement *handle) {</a>
<a name="ln507">  const PgObjectId index_id(database_oid, index_oid);</a>
<a name="ln508">  return ToYBCStatus(pgapi-&gt;NewDropIndex(index_id, if_exist, handle));</a>
<a name="ln509">}</a>
<a name="ln510"> </a>
<a name="ln511">YBCStatus YBCPgExecDropIndex(YBCPgStatement handle) {</a>
<a name="ln512">  return ToYBCStatus(pgapi-&gt;ExecDropIndex(handle));</a>
<a name="ln513">}</a>
<a name="ln514"> </a>
<a name="ln515">YBCStatus YBCPgWaitUntilIndexPermissionsAtLeast(</a>
<a name="ln516">    const YBCPgOid database_oid,</a>
<a name="ln517">    const YBCPgOid table_oid,</a>
<a name="ln518">    const YBCPgOid index_oid,</a>
<a name="ln519">    const uint32_t target_index_permissions,</a>
<a name="ln520">    uint32_t *actual_index_permissions) {</a>
<a name="ln521">  const PgObjectId table_id(database_oid, table_oid);</a>
<a name="ln522">  const PgObjectId index_id(database_oid, index_oid);</a>
<a name="ln523">  IndexPermissions returned_index_permissions = IndexPermissions::INDEX_PERM_DELETE_ONLY;</a>
<a name="ln524">  YBCStatus s = ExtractValueFromResult(pgapi-&gt;WaitUntilIndexPermissionsAtLeast(</a>
<a name="ln525">        table_id,</a>
<a name="ln526">        index_id,</a>
<a name="ln527">        static_cast&lt;IndexPermissions&gt;(target_index_permissions)),</a>
<a name="ln528">      &amp;returned_index_permissions);</a>
<a name="ln529">  if (s) {</a>
<a name="ln530">    // Bad status.</a>
<a name="ln531">    return s;</a>
<a name="ln532">  }</a>
<a name="ln533">  *actual_index_permissions = static_cast&lt;uint32_t&gt;(returned_index_permissions);</a>
<a name="ln534">  return YBCStatusOK();</a>
<a name="ln535">}</a>
<a name="ln536"> </a>
<a name="ln537">YBCStatus YBCPgAsyncUpdateIndexPermissions(</a>
<a name="ln538">    const YBCPgOid database_oid,</a>
<a name="ln539">    const YBCPgOid indexed_table_oid) {</a>
<a name="ln540">  const PgObjectId indexed_table_id(database_oid, indexed_table_oid);</a>
<a name="ln541">  return ToYBCStatus(pgapi-&gt;AsyncUpdateIndexPermissions(indexed_table_id));</a>
<a name="ln542">}</a>
<a name="ln543"> </a>
<a name="ln544">//--------------------------------------------------------------------------------------------------</a>
<a name="ln545">// DML Statements.</a>
<a name="ln546">//--------------------------------------------------------------------------------------------------</a>
<a name="ln547"> </a>
<a name="ln548">YBCStatus YBCPgDmlAppendTarget(YBCPgStatement handle, YBCPgExpr target) {</a>
<a name="ln549">  return ToYBCStatus(pgapi-&gt;DmlAppendTarget(handle, target));</a>
<a name="ln550">}</a>
<a name="ln551"> </a>
<a name="ln552">YBCStatus YBCPgDmlBindColumn(YBCPgStatement handle, int attr_num, YBCPgExpr attr_value) {</a>
<a name="ln553">  return ToYBCStatus(pgapi-&gt;DmlBindColumn(handle, attr_num, attr_value));</a>
<a name="ln554">}</a>
<a name="ln555"> </a>
<a name="ln556">YBCStatus YBCPgDmlBindColumnCondEq(YBCPgStatement handle, int attr_num, YBCPgExpr attr_value) {</a>
<a name="ln557">  return ToYBCStatus(pgapi-&gt;DmlBindColumnCondEq(handle, attr_num, attr_value));</a>
<a name="ln558">}</a>
<a name="ln559"> </a>
<a name="ln560">YBCStatus YBCPgDmlBindColumnCondBetween(YBCPgStatement handle, int attr_num, YBCPgExpr attr_value,</a>
<a name="ln561">    YBCPgExpr attr_value_end) {</a>
<a name="ln562">  return ToYBCStatus(pgapi-&gt;DmlBindColumnCondBetween(handle, attr_num, attr_value, attr_value_end));</a>
<a name="ln563">}</a>
<a name="ln564"> </a>
<a name="ln565">YBCStatus YBCPgDmlBindColumnCondIn(YBCPgStatement handle, int attr_num, int n_attr_values,</a>
<a name="ln566">    YBCPgExpr *attr_values) {</a>
<a name="ln567">  return ToYBCStatus(pgapi-&gt;DmlBindColumnCondIn(handle, attr_num, n_attr_values, attr_values));</a>
<a name="ln568">}</a>
<a name="ln569"> </a>
<a name="ln570">YBCStatus YBCPgDmlBindTable(YBCPgStatement handle) {</a>
<a name="ln571">  return ToYBCStatus(pgapi-&gt;DmlBindTable(handle));</a>
<a name="ln572">}</a>
<a name="ln573"> </a>
<a name="ln574">YBCStatus YBCPgDmlAssignColumn(YBCPgStatement handle,</a>
<a name="ln575">                               int attr_num,</a>
<a name="ln576">                               YBCPgExpr attr_value) {</a>
<a name="ln577">  return ToYBCStatus(pgapi-&gt;DmlAssignColumn(handle, attr_num, attr_value));</a>
<a name="ln578">}</a>
<a name="ln579"> </a>
<a name="ln580">YBCStatus YBCPgDmlFetch(YBCPgStatement handle, int32_t natts, uint64_t *values, bool *isnulls,</a>
<a name="ln581">                        YBCPgSysColumns *syscols, bool *has_data) {</a>
<a name="ln582">  return ToYBCStatus(pgapi-&gt;DmlFetch(handle, natts, values, isnulls, syscols, has_data));</a>
<a name="ln583">}</a>
<a name="ln584"> </a>
<a name="ln585">void YBCPgStartOperationsBuffering() {</a>
<a name="ln586">  pgapi-&gt;StartOperationsBuffering();</a>
<a name="ln587">}</a>
<a name="ln588"> </a>
<a name="ln589">YBCStatus YBCPgStopOperationsBuffering() {</a>
<a name="ln590">  return ToYBCStatus(pgapi-&gt;StopOperationsBuffering());</a>
<a name="ln591">}</a>
<a name="ln592"> </a>
<a name="ln593">YBCStatus YBCPgResetOperationsBuffering() {</a>
<a name="ln594">  return ToYBCStatus(pgapi-&gt;ResetOperationsBuffering());</a>
<a name="ln595">}</a>
<a name="ln596"> </a>
<a name="ln597">YBCStatus YBCPgFlushBufferedOperations() {</a>
<a name="ln598">  return ToYBCStatus(pgapi-&gt;FlushBufferedOperations());</a>
<a name="ln599">}</a>
<a name="ln600"> </a>
<a name="ln601">void YBCPgDropBufferedOperations() {</a>
<a name="ln602">  pgapi-&gt;DropBufferedOperations();</a>
<a name="ln603">}</a>
<a name="ln604"> </a>
<a name="ln605">YBCStatus YBCPgDmlExecWriteOp(YBCPgStatement handle, int32_t *rows_affected_count) {</a>
<a name="ln606">  return ToYBCStatus(pgapi-&gt;DmlExecWriteOp(handle, rows_affected_count));</a>
<a name="ln607">}</a>
<a name="ln608"> </a>
<a name="ln609">YBCStatus YBCPgDmlBuildYBTupleId(YBCPgStatement handle, const YBCPgAttrValueDescriptor *attrs,</a>
<a name="ln610">                                 int32_t nattrs, uint64_t *ybctid) {</a>
<a name="ln611">  return ToYBCStatus(pgapi-&gt;DmlBuildYBTupleId(handle, attrs, nattrs, ybctid));</a>
<a name="ln612">}</a>
<a name="ln613"> </a>
<a name="ln614">// INSERT Operations -------------------------------------------------------------------------------</a>
<a name="ln615">YBCStatus YBCPgNewInsert(const YBCPgOid database_oid,</a>
<a name="ln616">                         const YBCPgOid table_oid,</a>
<a name="ln617">                         const bool is_single_row_txn,</a>
<a name="ln618">                         YBCPgStatement *handle) {</a>
<a name="ln619">  const PgObjectId table_id(database_oid, table_oid);</a>
<a name="ln620">  return ToYBCStatus(pgapi-&gt;NewInsert(table_id, is_single_row_txn, handle));</a>
<a name="ln621">}</a>
<a name="ln622"> </a>
<a name="ln623">YBCStatus YBCPgExecInsert(YBCPgStatement handle) {</a>
<a name="ln624">  return ToYBCStatus(pgapi-&gt;ExecInsert(handle));</a>
<a name="ln625">}</a>
<a name="ln626"> </a>
<a name="ln627">YBCStatus YBCPgInsertStmtSetUpsertMode(YBCPgStatement handle) {</a>
<a name="ln628">  return ToYBCStatus(pgapi-&gt;InsertStmtSetUpsertMode(handle));</a>
<a name="ln629">}</a>
<a name="ln630"> </a>
<a name="ln631">YBCStatus YBCPgInsertStmtSetWriteTime(YBCPgStatement handle, const uint64_t write_time) {</a>
<a name="ln632">  HybridTime write_hybrid_time;</a>
<a name="ln633">  YBCStatus status = ToYBCStatus(write_hybrid_time.FromUint64(write_time));</a>
<a name="ln634">  if (status) {</a>
<a name="ln635">    return status;</a>
<a name="ln636">  } else {</a>
<a name="ln637">    return ToYBCStatus(pgapi-&gt;InsertStmtSetWriteTime(handle, write_hybrid_time));</a>
<a name="ln638">  }</a>
<a name="ln639">}</a>
<a name="ln640"> </a>
<a name="ln641">// UPDATE Operations -------------------------------------------------------------------------------</a>
<a name="ln642">YBCStatus YBCPgNewUpdate(const YBCPgOid database_oid,</a>
<a name="ln643">                         const YBCPgOid table_oid,</a>
<a name="ln644">                         bool is_single_row_txn,</a>
<a name="ln645">                         YBCPgStatement *handle) {</a>
<a name="ln646">  const PgObjectId table_id(database_oid, table_oid);</a>
<a name="ln647">  return ToYBCStatus(pgapi-&gt;NewUpdate(table_id, is_single_row_txn, handle));</a>
<a name="ln648">}</a>
<a name="ln649"> </a>
<a name="ln650">YBCStatus YBCPgExecUpdate(YBCPgStatement handle) {</a>
<a name="ln651">  return ToYBCStatus(pgapi-&gt;ExecUpdate(handle));</a>
<a name="ln652">}</a>
<a name="ln653"> </a>
<a name="ln654">// DELETE Operations -------------------------------------------------------------------------------</a>
<a name="ln655">YBCStatus YBCPgNewDelete(const YBCPgOid database_oid,</a>
<a name="ln656">                         const YBCPgOid table_oid,</a>
<a name="ln657">                         bool is_single_row_txn,</a>
<a name="ln658">                         YBCPgStatement *handle) {</a>
<a name="ln659">  const PgObjectId table_id(database_oid, table_oid);</a>
<a name="ln660">  return ToYBCStatus(pgapi-&gt;NewDelete(table_id, is_single_row_txn, handle));</a>
<a name="ln661">}</a>
<a name="ln662"> </a>
<a name="ln663">YBCStatus YBCPgExecDelete(YBCPgStatement handle) {</a>
<a name="ln664">  return ToYBCStatus(pgapi-&gt;ExecDelete(handle));</a>
<a name="ln665">}</a>
<a name="ln666"> </a>
<a name="ln667">// Colocated TRUNCATE Operations -------------------------------------------------------------------</a>
<a name="ln668">YBCStatus YBCPgNewTruncateColocated(const YBCPgOid database_oid,</a>
<a name="ln669">                                    const YBCPgOid table_oid,</a>
<a name="ln670">                                    bool is_single_row_txn,</a>
<a name="ln671">                                    YBCPgStatement *handle) {</a>
<a name="ln672">  const PgObjectId table_id(database_oid, table_oid);</a>
<a name="ln673">  return ToYBCStatus(pgapi-&gt;NewTruncateColocated(table_id, is_single_row_txn, handle));</a>
<a name="ln674">}</a>
<a name="ln675"> </a>
<a name="ln676">YBCStatus YBCPgExecTruncateColocated(YBCPgStatement handle) {</a>
<a name="ln677">  return ToYBCStatus(pgapi-&gt;ExecTruncateColocated(handle));</a>
<a name="ln678">}</a>
<a name="ln679"> </a>
<a name="ln680">// SELECT Operations -------------------------------------------------------------------------------</a>
<a name="ln681">YBCStatus YBCPgNewSelect(const YBCPgOid database_oid,</a>
<a name="ln682">                         const YBCPgOid table_oid,</a>
<a name="ln683">                         const YBCPgPrepareParameters *prepare_params,</a>
<a name="ln684">                         YBCPgStatement *handle) {</a>
<a name="ln685">  const PgObjectId table_id(database_oid, table_oid);</a>
<a name="ln686">  const PgObjectId index_id(database_oid,</a>
<a name="ln687">                            prepare_params ? prepare_params-&gt;index_oid : kInvalidOid);</a>
<a name="ln688">  return ToYBCStatus(pgapi-&gt;NewSelect(table_id, index_id, prepare_params, handle));</a>
<a name="ln689">}</a>
<a name="ln690"> </a>
<a name="ln691">YBCStatus YBCPgSetForwardScan(YBCPgStatement handle, bool is_forward_scan) {</a>
<a name="ln692">  return ToYBCStatus(pgapi-&gt;SetForwardScan(handle, is_forward_scan));</a>
<a name="ln693">}</a>
<a name="ln694"> </a>
<a name="ln695">YBCStatus YBCPgExecSelect(YBCPgStatement handle, const YBCPgExecParameters *exec_params) {</a>
<a name="ln696">  return ToYBCStatus(pgapi-&gt;ExecSelect(handle, exec_params));</a>
<a name="ln697">}</a>
<a name="ln698"> </a>
<a name="ln699">//--------------------------------------------------------------------------------------------------</a>
<a name="ln700">// Expression Operations</a>
<a name="ln701">//--------------------------------------------------------------------------------------------------</a>
<a name="ln702"> </a>
<a name="ln703">YBCStatus YBCPgNewColumnRef(YBCPgStatement stmt, int attr_num, const YBCPgTypeEntity *type_entity,</a>
<a name="ln704">                            const YBCPgTypeAttrs *type_attrs, YBCPgExpr *expr_handle) {</a>
<a name="ln705">  return ToYBCStatus(pgapi-&gt;NewColumnRef(stmt, attr_num, type_entity, type_attrs, expr_handle));</a>
<a name="ln706">}</a>
<a name="ln707"> </a>
<a name="ln708">YBCStatus YBCPgNewConstant(YBCPgStatement stmt, const YBCPgTypeEntity *type_entity,</a>
<a name="ln709">                           uint64_t datum, bool is_null, YBCPgExpr *expr_handle) {</a>
<a name="ln710">  return ToYBCStatus(pgapi-&gt;NewConstant(stmt, type_entity, datum, is_null, expr_handle));</a>
<a name="ln711">}</a>
<a name="ln712"> </a>
<a name="ln713">YBCStatus YBCPgNewConstantOp(YBCPgStatement stmt, const YBCPgTypeEntity *type_entity,</a>
<a name="ln714">                           uint64_t datum, bool is_null, YBCPgExpr *expr_handle, bool is_gt) {</a>
<a name="ln715">  return ToYBCStatus(pgapi-&gt;NewConstantOp(stmt, type_entity, datum, is_null, expr_handle, is_gt));</a>
<a name="ln716">}</a>
<a name="ln717"> </a>
<a name="ln718">// Overwriting the expression's result with any desired values.</a>
<a name="ln719">YBCStatus YBCPgUpdateConstInt2(YBCPgExpr expr, int16_t value, bool is_null) {</a>
<a name="ln720">  return ToYBCStatus(pgapi-&gt;UpdateConstant(expr, value, is_null));</a>
<a name="ln721">}</a>
<a name="ln722"> </a>
<a name="ln723">YBCStatus YBCPgUpdateConstInt4(YBCPgExpr expr, int32_t value, bool is_null) {</a>
<a name="ln724">  return ToYBCStatus(pgapi-&gt;UpdateConstant(expr, value, is_null));</a>
<a name="ln725">}</a>
<a name="ln726"> </a>
<a name="ln727">YBCStatus YBCPgUpdateConstInt8(YBCPgExpr expr, int64_t value, bool is_null) {</a>
<a name="ln728">  return ToYBCStatus(pgapi-&gt;UpdateConstant(expr, value, is_null));</a>
<a name="ln729">}</a>
<a name="ln730"> </a>
<a name="ln731">YBCStatus YBCPgUpdateConstFloat4(YBCPgExpr expr, float value, bool is_null) {</a>
<a name="ln732">  return ToYBCStatus(pgapi-&gt;UpdateConstant(expr, value, is_null));</a>
<a name="ln733">}</a>
<a name="ln734"> </a>
<a name="ln735">YBCStatus YBCPgUpdateConstFloat8(YBCPgExpr expr, double value, bool is_null) {</a>
<a name="ln736">  return ToYBCStatus(pgapi-&gt;UpdateConstant(expr, value, is_null));</a>
<a name="ln737">}</a>
<a name="ln738"> </a>
<a name="ln739">YBCStatus YBCPgUpdateConstText(YBCPgExpr expr, const char *value, bool is_null) {</a>
<a name="ln740">  return ToYBCStatus(pgapi-&gt;UpdateConstant(expr, value, is_null));</a>
<a name="ln741">}</a>
<a name="ln742"> </a>
<a name="ln743">YBCStatus YBCPgUpdateConstChar(YBCPgExpr expr, const char *value,  int64_t bytes, bool is_null) {</a>
<a name="ln744">  return ToYBCStatus(pgapi-&gt;UpdateConstant(expr, value, bytes, is_null));</a>
<a name="ln745">}</a>
<a name="ln746"> </a>
<a name="ln747">YBCStatus YBCPgNewOperator(YBCPgStatement stmt, const char *opname,</a>
<a name="ln748">                           const YBCPgTypeEntity *type_entity,</a>
<a name="ln749">                           YBCPgExpr *op_handle) {</a>
<a name="ln750">  return ToYBCStatus(pgapi-&gt;NewOperator(stmt, opname, type_entity, op_handle));</a>
<a name="ln751">}</a>
<a name="ln752"> </a>
<a name="ln753">YBCStatus YBCPgOperatorAppendArg(YBCPgExpr op_handle, YBCPgExpr arg) {</a>
<a name="ln754">  return ToYBCStatus(pgapi-&gt;OperatorAppendArg(op_handle, arg));</a>
<a name="ln755">}</a>
<a name="ln756"> </a>
<a name="ln757">//------------------------------------------------------------------------------------------------</a>
<a name="ln758">// Transaction operation.</a>
<a name="ln759">//------------------------------------------------------------------------------------------------</a>
<a name="ln760"> </a>
<a name="ln761">YBCStatus YBCPgBeginTransaction() {</a>
<a name="ln762">  return ToYBCStatus(pgapi-&gt;BeginTransaction());</a>
<a name="ln763">}</a>
<a name="ln764"> </a>
<a name="ln765">YBCStatus YBCPgRestartTransaction() {</a>
<a name="ln766">  return ToYBCStatus(pgapi-&gt;RestartTransaction());</a>
<a name="ln767">}</a>
<a name="ln768"> </a>
<a name="ln769">YBCStatus YBCPgCommitTransaction() {</a>
<a name="ln770">  return ToYBCStatus(pgapi-&gt;CommitTransaction());</a>
<a name="ln771">}</a>
<a name="ln772"> </a>
<a name="ln773">YBCStatus YBCPgAbortTransaction() {</a>
<a name="ln774">  return ToYBCStatus(pgapi-&gt;AbortTransaction());</a>
<a name="ln775">}</a>
<a name="ln776"> </a>
<a name="ln777">YBCStatus YBCPgSetTransactionIsolationLevel(int isolation) {</a>
<a name="ln778">  return ToYBCStatus(pgapi-&gt;SetTransactionIsolationLevel(isolation));</a>
<a name="ln779">}</a>
<a name="ln780"> </a>
<a name="ln781">YBCStatus YBCPgSetTransactionReadOnly(bool read_only) {</a>
<a name="ln782">  return ToYBCStatus(pgapi-&gt;SetTransactionReadOnly(read_only));</a>
<a name="ln783">}</a>
<a name="ln784"> </a>
<a name="ln785">YBCStatus YBCPgSetTransactionDeferrable(bool deferrable) {</a>
<a name="ln786">  return ToYBCStatus(pgapi-&gt;SetTransactionDeferrable(deferrable));</a>
<a name="ln787">}</a>
<a name="ln788"> </a>
<a name="ln789">YBCStatus YBCPgEnterSeparateDdlTxnMode() {</a>
<a name="ln790">  return ToYBCStatus(pgapi-&gt;EnterSeparateDdlTxnMode());</a>
<a name="ln791">}</a>
<a name="ln792"> </a>
<a name="ln793">YBCStatus YBCPgExitSeparateDdlTxnMode(bool success) {</a>
<a name="ln794">  return ToYBCStatus(pgapi-&gt;ExitSeparateDdlTxnMode(success));</a>
<a name="ln795">}</a>
<a name="ln796"> </a>
<a name="ln797">// Referential Integrity Caching</a>
<a name="ln798">bool YBCForeignKeyReferenceExists(YBCPgOid table_id, const char* ybctid, int64_t ybctid_size) {</a>
<a name="ln799">  return pgapi-&gt;ForeignKeyReferenceExists(table_id, std::string(ybctid, ybctid_size));</a>
<a name="ln800">}</a>
<a name="ln801"> </a>
<a name="ln802">YBCStatus YBCCacheForeignKeyReference(YBCPgOid table_id, const char* ybctid, int64_t ybctid_size) {</a>
<a name="ln803">  return ToYBCStatus(pgapi-&gt;CacheForeignKeyReference(table_id, std::string(ybctid, ybctid_size)));</a>
<a name="ln804">}</a>
<a name="ln805"> </a>
<a name="ln806">YBCStatus YBCPgDeleteFromForeignKeyReferenceCache(YBCPgOid table_id, uint64_t ybctid) {</a>
<a name="ln807">  char *value;</a>
<a name="ln808">  int64_t bytes;</a>
<a name="ln809"> </a>
<a name="ln810">  const YBCPgTypeEntity *type_entity = pgapi-&gt;FindTypeEntity(kPgByteArrayOid);</a>
<a name="ln811">  type_entity-&gt;datum_to_yb(ybctid, &amp;value, &amp;bytes);</a>
<a name="ln812">  return ToYBCStatus(pgapi-&gt;DeleteForeignKeyReference(table_id, std::string(value, bytes)));</a>
<a name="ln813">}</a>
<a name="ln814"> </a>
<a name="ln815">void ClearForeignKeyReferenceCache() {</a>
<a name="ln816">  pgapi-&gt;ClearForeignKeyReferenceCache();</a>
<a name="ln817">}</a>
<a name="ln818"> </a>
<a name="ln819">bool YBCIsInitDbModeEnvVarSet() {</a>
<a name="ln820">  static bool cached_value = false;</a>
<a name="ln821">  static bool cached = false;</a>
<a name="ln822"> </a>
<a name="ln823">  if (!cached) {</a>
<a name="ln824">    const char* initdb_mode_env_var_value = getenv(&quot;YB_PG_INITDB_MODE&quot;);</a>
<a name="ln825">    cached_value = initdb_mode_env_var_value &amp;&amp; strcmp(initdb_mode_env_var_value, &quot;1&quot;) == 0;</a>
<a name="ln826">    cached = true;</a>
<a name="ln827">  }</a>
<a name="ln828"> </a>
<a name="ln829">  return cached_value;</a>
<a name="ln830">}</a>
<a name="ln831"> </a>
<a name="ln832">void YBCInitFlags() {</a>
<a name="ln833">  if (YBCIsInitDbModeEnvVarSet()) {</a>
<a name="ln834">    // Suppress log spew during initdb.</a>
<a name="ln835">    FLAGS_client_suppress_created_logs = true;</a>
<a name="ln836">  }</a>
<a name="ln837"> </a>
<a name="ln838">  SetAtomicFlag(GetAtomicFlag(&amp;FLAGS_pggate_num_connections_to_server),</a>
<a name="ln839">                &amp;FLAGS_num_connections_to_server);</a>
<a name="ln840"> </a>
<a name="ln841">  // TODO(neil) Init a gflag for &quot;YB_PG_TRANSACTIONS_ENABLED&quot; here also.</a>
<a name="ln842">  // Mikhail agreed that this flag should just be initialized once at the beginning here.</a>
<a name="ln843">  // Currently, it is initialized for every CREATE statement.</a>
<a name="ln844">}</a>
<a name="ln845"> </a>
<a name="ln846">YBCStatus YBCPgIsInitDbDone(bool* initdb_done) {</a>
<a name="ln847">  return ExtractValueFromResult(pgapi-&gt;IsInitDbDone(), initdb_done);</a>
<a name="ln848">}</a>
<a name="ln849"> </a>
<a name="ln850">const bool YBCGetDisableTransparentCacheRefreshRetry() {</a>
<a name="ln851">  return pgapi-&gt;GetDisableTransparentCacheRefreshRetry();</a>
<a name="ln852">}</a>
<a name="ln853"> </a>
<a name="ln854">YBCStatus YBCGetSharedCatalogVersion(uint64_t* catalog_version) {</a>
<a name="ln855">  return ExtractValueFromResult(pgapi-&gt;GetSharedCatalogVersion(), catalog_version);</a>
<a name="ln856">}</a>
<a name="ln857"> </a>
<a name="ln858">int32_t YBCGetMaxReadRestartAttempts() {</a>
<a name="ln859">  return FLAGS_ysql_max_read_restart_attempts;</a>
<a name="ln860">}</a>
<a name="ln861"> </a>
<a name="ln862">int32_t YBCGetOutputBufferSize() {</a>
<a name="ln863">  return FLAGS_ysql_output_buffer_size;</a>
<a name="ln864">}</a>
<a name="ln865"> </a>
<a name="ln866">bool YBCGetDisableIndexBackfill() {</a>
<a name="ln867">  return FLAGS_ysql_disable_index_backfill;</a>
<a name="ln868">}</a>
<a name="ln869"> </a>
<a name="ln870">bool YBCPgIsYugaByteEnabled() {</a>
<a name="ln871">  return pgapi;</a>
<a name="ln872">}</a>
<a name="ln873"> </a>
<a name="ln874">void YBCSetTimeout(int timeout_ms, void* extra) {</a>
<a name="ln875">  // We set the rpc timeouts as a min{STATEMENT_TIMEOUT, FLAGS_client_read_write_timeout_ms}.</a>
<a name="ln876">  if (timeout_ms &lt;= 0) {</a>
<a name="ln877">    // The timeout is not valid. Use the default GFLAG value.</a>
<a name="ln878">    return;</a>
<a name="ln879">  }</a>
<a name="ln880">  timeout_ms = std::min(timeout_ms, FLAGS_client_read_write_timeout_ms);</a>
<a name="ln881"> </a>
<a name="ln882">  // The statement timeout is lesser than FLAGS_client_read_write_timeout_ms, hence the rpcs would</a>
<a name="ln883">  // need to use a shorter timeout.</a>
<a name="ln884">  pgapi-&gt;SetTimeout(timeout_ms);</a>
<a name="ln885">}</a>
<a name="ln886"> </a>
<a name="ln887">//------------------------------------------------------------------------------------------------</a>
<a name="ln888">// Thread-local variables.</a>
<a name="ln889">//------------------------------------------------------------------------------------------------</a>
<a name="ln890"> </a>
<a name="ln891">void* YBCPgGetThreadLocalCurrentMemoryContext() {</a>
<a name="ln892">  return PgGetThreadLocalCurrentMemoryContext();</a>
<a name="ln893">}</a>
<a name="ln894"> </a>
<a name="ln895">void* YBCPgSetThreadLocalCurrentMemoryContext(void *memctx) {</a>
<a name="ln896">  return PgSetThreadLocalCurrentMemoryContext(memctx);</a>
<a name="ln897">}</a>
<a name="ln898"> </a>
<a name="ln899">void YBCPgResetCurrentMemCtxThreadLocalVars() {</a>
<a name="ln900">  PgResetCurrentMemCtxThreadLocalVars();</a>
<a name="ln901">}</a>
<a name="ln902"> </a>
<a name="ln903">void* YBCPgGetThreadLocalStrTokPtr() {</a>
<a name="ln904">  return PgGetThreadLocalStrTokPtr();</a>
<a name="ln905">}</a>
<a name="ln906"> </a>
<a name="ln907">void YBCPgSetThreadLocalStrTokPtr(char *new_pg_strtok_ptr) {</a>
<a name="ln908">  PgSetThreadLocalStrTokPtr(new_pg_strtok_ptr);</a>
<a name="ln909">}</a>
<a name="ln910"> </a>
<a name="ln911">void* YBCPgSetThreadLocalJumpBuffer(void* new_buffer) {</a>
<a name="ln912">  return PgSetThreadLocalJumpBuffer(new_buffer);</a>
<a name="ln913">}</a>
<a name="ln914"> </a>
<a name="ln915">void* YBCPgGetThreadLocalJumpBuffer() {</a>
<a name="ln916">  return PgGetThreadLocalJumpBuffer();</a>
<a name="ln917">}</a>
<a name="ln918"> </a>
<a name="ln919">void YBCPgSetThreadLocalErrMsg(const void* new_msg) {</a>
<a name="ln920">  PgSetThreadLocalErrMsg(new_msg);</a>
<a name="ln921">}</a>
<a name="ln922"> </a>
<a name="ln923">const void* YBCPgGetThreadLocalErrMsg() {</a>
<a name="ln924">  return PgGetThreadLocalErrMsg();</a>
<a name="ln925">}</a>
<a name="ln926"> </a>
<a name="ln927">} // extern &quot;C&quot;</a>
<a name="ln928"> </a>
<a name="ln929">} // namespace pggate</a>
<a name="ln930">} // namespace yb</a>

</code></pre>
<div class="balloon" rel="72"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="78"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="88"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
