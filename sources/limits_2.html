
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>limits</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// The template and inlines for the numeric_limits classes. -*- C++ -*-</a>
<a name="ln2"> </a>
<a name="ln3">// Copyright (C) 1999-2018 Free Software Foundation, Inc.</a>
<a name="ln4">//</a>
<a name="ln5">// This file is part of the GNU ISO C++ Library.  This library is free</a>
<a name="ln6">// software; you can redistribute it and/or modify it under the</a>
<a name="ln7">// terms of the GNU General Public License as published by the</a>
<a name="ln8">// Free Software Foundation; either version 3, or (at your option)</a>
<a name="ln9">// any later version.</a>
<a name="ln10"> </a>
<a name="ln11">// This library is distributed in the hope that it will be useful,</a>
<a name="ln12">// but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">// GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">// Under Section 7 of GPL version 3, you are granted additional</a>
<a name="ln17">// permissions described in the GCC Runtime Library Exception, version</a>
<a name="ln18">// 3.1, as published by the Free Software Foundation.</a>
<a name="ln19"> </a>
<a name="ln20">// You should have received a copy of the GNU General Public License and</a>
<a name="ln21">// a copy of the GCC Runtime Library Exception along with this program;</a>
<a name="ln22">// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see</a>
<a name="ln23">// &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln24"> </a>
<a name="ln25">/** @file include/limits</a>
<a name="ln26"> *  This is a Standard C++ Library header.</a>
<a name="ln27"> */</a>
<a name="ln28"> </a>
<a name="ln29">// Note: this is not a conforming implementation.</a>
<a name="ln30">// Written by Gabriel Dos Reis &lt;gdr@codesourcery.com&gt;</a>
<a name="ln31"> </a>
<a name="ln32">//</a>
<a name="ln33">// ISO 14882:1998</a>
<a name="ln34">// 18.2.1</a>
<a name="ln35">//</a>
<a name="ln36"> </a>
<a name="ln37">#ifndef _GLIBCXX_NUMERIC_LIMITS</a>
<a name="ln38">#define _GLIBCXX_NUMERIC_LIMITS 1</a>
<a name="ln39"> </a>
<a name="ln40">#pragma GCC system_header</a>
<a name="ln41"> </a>
<a name="ln42">#include &lt;bits/c++config.h&gt;</a>
<a name="ln43"> </a>
<a name="ln44">//</a>
<a name="ln45">// The numeric_limits&lt;&gt; traits document implementation-defined aspects</a>
<a name="ln46">// of fundamental arithmetic data types (integers and floating points).</a>
<a name="ln47">// From Standard C++ point of view, there are 14 such types:</a>
<a name="ln48">//   * integers</a>
<a name="ln49">//         bool							(1)</a>
<a name="ln50">//         char, signed char, unsigned char, wchar_t            (4)</a>
<a name="ln51">//         short, unsigned short				(2)</a>
<a name="ln52">//         int, unsigned					(2)</a>
<a name="ln53">//         long, unsigned long					(2)</a>
<a name="ln54">//</a>
<a name="ln55">//   * floating points</a>
<a name="ln56">//         float						(1)</a>
<a name="ln57">//         double						(1)</a>
<a name="ln58">//         long double						(1)</a>
<a name="ln59">//</a>
<a name="ln60">// GNU C++ understands (where supported by the host C-library)</a>
<a name="ln61">//   * integer</a>
<a name="ln62">//         long long, unsigned long long			(2)</a>
<a name="ln63">//</a>
<a name="ln64">// which brings us to 16 fundamental arithmetic data types in GNU C++.</a>
<a name="ln65">//</a>
<a name="ln66">//</a>
<a name="ln67">// Since a numeric_limits&lt;&gt; is a bit tricky to get right, we rely on</a>
<a name="ln68">// an interface composed of macros which should be defined in config/os</a>
<a name="ln69">// or config/cpu when they differ from the generic (read arbitrary)</a>
<a name="ln70">// definitions given here.</a>
<a name="ln71">//</a>
<a name="ln72"> </a>
<a name="ln73">// These values can be overridden in the target configuration file.</a>
<a name="ln74">// The default values are appropriate for many 32-bit targets.</a>
<a name="ln75"> </a>
<a name="ln76">// GCC only intrinsically supports modulo integral types.  The only remaining</a>
<a name="ln77">// integral exceptional values is division by zero.  Only targets that do not</a>
<a name="ln78">// signal division by zero in some &quot;hard to ignore&quot; way should use false.</a>
<a name="ln79">#ifndef __glibcxx_integral_traps</a>
<a name="ln80"># define __glibcxx_integral_traps true</a>
<a name="ln81">#endif</a>
<a name="ln82"> </a>
<a name="ln83">// float</a>
<a name="ln84">//</a>
<a name="ln85"> </a>
<a name="ln86">// Default values.  Should be overridden in configuration files if necessary.</a>
<a name="ln87"> </a>
<a name="ln88">#ifndef __glibcxx_float_has_denorm_loss</a>
<a name="ln89">#  define __glibcxx_float_has_denorm_loss false</a>
<a name="ln90">#endif</a>
<a name="ln91">#ifndef __glibcxx_float_traps</a>
<a name="ln92">#  define __glibcxx_float_traps false</a>
<a name="ln93">#endif</a>
<a name="ln94">#ifndef __glibcxx_float_tinyness_before</a>
<a name="ln95">#  define __glibcxx_float_tinyness_before false</a>
<a name="ln96">#endif</a>
<a name="ln97"> </a>
<a name="ln98">// double</a>
<a name="ln99"> </a>
<a name="ln100">// Default values.  Should be overridden in configuration files if necessary.</a>
<a name="ln101"> </a>
<a name="ln102">#ifndef __glibcxx_double_has_denorm_loss</a>
<a name="ln103">#  define __glibcxx_double_has_denorm_loss false</a>
<a name="ln104">#endif</a>
<a name="ln105">#ifndef __glibcxx_double_traps</a>
<a name="ln106">#  define __glibcxx_double_traps false</a>
<a name="ln107">#endif</a>
<a name="ln108">#ifndef __glibcxx_double_tinyness_before</a>
<a name="ln109">#  define __glibcxx_double_tinyness_before false</a>
<a name="ln110">#endif</a>
<a name="ln111"> </a>
<a name="ln112">// long double</a>
<a name="ln113"> </a>
<a name="ln114">// Default values.  Should be overridden in configuration files if necessary.</a>
<a name="ln115"> </a>
<a name="ln116">#ifndef __glibcxx_long_double_has_denorm_loss</a>
<a name="ln117">#  define __glibcxx_long_double_has_denorm_loss false</a>
<a name="ln118">#endif</a>
<a name="ln119">#ifndef __glibcxx_long_double_traps</a>
<a name="ln120">#  define __glibcxx_long_double_traps false</a>
<a name="ln121">#endif</a>
<a name="ln122">#ifndef __glibcxx_long_double_tinyness_before</a>
<a name="ln123">#  define __glibcxx_long_double_tinyness_before false</a>
<a name="ln124">#endif</a>
<a name="ln125"> </a>
<a name="ln126">// You should not need to define any macros below this point.</a>
<a name="ln127"> </a>
<a name="ln128">#define __glibcxx_signed_b(T,B)	((T)(-1) &lt; 0)</a>
<a name="ln129"> </a>
<a name="ln130">#define __glibcxx_min_b(T,B)					\</a>
<a name="ln131">  (__glibcxx_signed_b (T,B) ? -__glibcxx_max_b (T,B) - 1 : (T)0)</a>
<a name="ln132"> </a>
<a name="ln133">#define __glibcxx_max_b(T,B)						\</a>
<a name="ln134">  (__glibcxx_signed_b (T,B) ?						\</a>
<a name="ln135">   (((((T)1 &lt;&lt; (__glibcxx_digits_b (T,B) - 1)) - 1) &lt;&lt; 1) + 1) : ~(T)0)</a>
<a name="ln136"> </a>
<a name="ln137">#define __glibcxx_digits_b(T,B)				\</a>
<a name="ln138">  (B - __glibcxx_signed_b (T,B))</a>
<a name="ln139"> </a>
<a name="ln140">// The fraction 643/2136 approximates log10(2) to 7 significant digits.</a>
<a name="ln141">#define __glibcxx_digits10_b(T,B)		\</a>
<a name="ln142">  (__glibcxx_digits_b (T,B) * 643L / 2136)</a>
<a name="ln143"> </a>
<a name="ln144">#define __glibcxx_signed(T) \</a>
<a name="ln145">  __glibcxx_signed_b (T, sizeof(T) * __CHAR_BIT__)</a>
<a name="ln146">#define __glibcxx_min(T) \</a>
<a name="ln147">  __glibcxx_min_b (T, sizeof(T) * __CHAR_BIT__)</a>
<a name="ln148">#define __glibcxx_max(T) \</a>
<a name="ln149">  __glibcxx_max_b (T, sizeof(T) * __CHAR_BIT__)</a>
<a name="ln150">#define __glibcxx_digits(T) \</a>
<a name="ln151">  __glibcxx_digits_b (T, sizeof(T) * __CHAR_BIT__)</a>
<a name="ln152">#define __glibcxx_digits10(T) \</a>
<a name="ln153">  __glibcxx_digits10_b (T, sizeof(T) * __CHAR_BIT__)</a>
<a name="ln154"> </a>
<a name="ln155">#define __glibcxx_max_digits10(T) \</a>
<a name="ln156">  (2 + (T) * 643L / 2136)</a>
<a name="ln157"> </a>
<a name="ln158">namespace std _GLIBCXX_VISIBILITY(default)</a>
<a name="ln159">{</a>
<a name="ln160">_GLIBCXX_BEGIN_NAMESPACE_VERSION</a>
<a name="ln161"> </a>
<a name="ln162">  /**</a>
<a name="ln163">   *  @brief Describes the rounding style for floating-point types.</a>
<a name="ln164">   *</a>
<a name="ln165">   *  This is used in the std::numeric_limits class.</a>
<a name="ln166">  */</a>
<a name="ln167">  enum float_round_style</a>
<a name="ln168">  {</a>
<a name="ln169">    round_indeterminate       = -1,    /// Intermediate.</a>
<a name="ln170">    round_toward_zero         = 0,     /// To zero.</a>
<a name="ln171">    round_to_nearest          = 1,     /// To the nearest representable value.</a>
<a name="ln172">    round_toward_infinity     = 2,     /// To infinity.</a>
<a name="ln173">    round_toward_neg_infinity = 3      /// To negative infinity.</a>
<a name="ln174">  };</a>
<a name="ln175"> </a>
<a name="ln176">  /**</a>
<a name="ln177">   *  @brief Describes the denormalization for floating-point types.</a>
<a name="ln178">   *</a>
<a name="ln179">   *  These values represent the presence or absence of a variable number</a>
<a name="ln180">   *  of exponent bits.  This type is used in the std::numeric_limits class.</a>
<a name="ln181">  */</a>
<a name="ln182">  enum float_denorm_style</a>
<a name="ln183">  {</a>
<a name="ln184">    /// Indeterminate at compile time whether denormalized values are allowed.</a>
<a name="ln185">    denorm_indeterminate = -1,</a>
<a name="ln186">    /// The type does not allow denormalized values.</a>
<a name="ln187">    denorm_absent        = 0,</a>
<a name="ln188">    /// The type allows denormalized values.</a>
<a name="ln189">    denorm_present       = 1</a>
<a name="ln190">  };</a>
<a name="ln191"> </a>
<a name="ln192">  /**</a>
<a name="ln193">   *  @brief Part of std::numeric_limits.</a>
<a name="ln194">   *</a>
<a name="ln195">   *  The @c static @c const members are usable as integral constant</a>
<a name="ln196">   *  expressions.</a>
<a name="ln197">   *</a>
<a name="ln198">   *  @note This is a separate class for purposes of efficiency; you</a>
<a name="ln199">   *        should only access these members as part of an instantiation</a>
<a name="ln200">   *        of the std::numeric_limits class.</a>
<a name="ln201">  */</a>
<a name="ln202">  struct __numeric_limits_base</a>
<a name="ln203">  {</a>
<a name="ln204">    /** This will be true for all fundamental types (which have</a>
<a name="ln205">	specializations), and false for everything else.  */</a>
<a name="ln206">    static _GLIBCXX_USE_CONSTEXPR bool is_specialized = false;</a>
<a name="ln207"> </a>
<a name="ln208">    /** The number of @c radix digits that be represented without change:  for</a>
<a name="ln209">	integer types, the number of non-sign bits in the mantissa; for</a>
<a name="ln210">	floating types, the number of @c radix digits in the mantissa.  */</a>
<a name="ln211">    static _GLIBCXX_USE_CONSTEXPR int digits = 0;</a>
<a name="ln212"> </a>
<a name="ln213">    /** The number of base 10 digits that can be represented without change. */</a>
<a name="ln214">    static _GLIBCXX_USE_CONSTEXPR int digits10 = 0;</a>
<a name="ln215"> </a>
<a name="ln216">#if __cplusplus &gt;= 201103L</a>
<a name="ln217">    /** The number of base 10 digits required to ensure that values which</a>
<a name="ln218">	differ are always differentiated.  */</a>
<a name="ln219">    static constexpr int max_digits10 = 0;</a>
<a name="ln220">#endif</a>
<a name="ln221"> </a>
<a name="ln222">    /** True if the type is signed.  */</a>
<a name="ln223">    static _GLIBCXX_USE_CONSTEXPR bool is_signed = false;</a>
<a name="ln224"> </a>
<a name="ln225">    /** True if the type is integer.  */</a>
<a name="ln226">    static _GLIBCXX_USE_CONSTEXPR bool is_integer = false;</a>
<a name="ln227"> </a>
<a name="ln228">    /** True if the type uses an exact representation. All integer types are</a>
<a name="ln229">	exact, but not all exact types are integer.  For example, rational and</a>
<a name="ln230">	fixed-exponent representations are exact but not integer. */</a>
<a name="ln231">    static _GLIBCXX_USE_CONSTEXPR bool is_exact = false;</a>
<a name="ln232"> </a>
<a name="ln233">    /** For integer types, specifies the base of the representation.  For</a>
<a name="ln234">	floating types, specifies the base of the exponent representation.  */</a>
<a name="ln235">    static _GLIBCXX_USE_CONSTEXPR int radix = 0;</a>
<a name="ln236"> </a>
<a name="ln237">    /** The minimum negative integer such that @c radix raised to the power of</a>
<a name="ln238">	(one less than that integer) is a normalized floating point number.  */</a>
<a name="ln239">    static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;</a>
<a name="ln240"> </a>
<a name="ln241">    /** The minimum negative integer such that 10 raised to that power is in</a>
<a name="ln242">	the range of normalized floating point numbers.  */</a>
<a name="ln243">    static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;</a>
<a name="ln244"> </a>
<a name="ln245">    /** The maximum positive integer such that @c radix raised to the power of</a>
<a name="ln246">	(one less than that integer) is a representable finite floating point</a>
<a name="ln247">	number.  */</a>
<a name="ln248">    static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;</a>
<a name="ln249"> </a>
<a name="ln250">    /** The maximum positive integer such that 10 raised to that power is in</a>
<a name="ln251">	the range of representable finite floating point numbers.  */</a>
<a name="ln252">    static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;</a>
<a name="ln253"> </a>
<a name="ln254">    /** True if the type has a representation for positive infinity.  */</a>
<a name="ln255">    static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;</a>
<a name="ln256"> </a>
<a name="ln257">    /** True if the type has a representation for a quiet (non-signaling)</a>
<a name="ln258">	Not a Number.  */</a>
<a name="ln259">    static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;</a>
<a name="ln260"> </a>
<a name="ln261">    /** True if the type has a representation for a signaling</a>
<a name="ln262">	Not a Number.  */</a>
<a name="ln263">    static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;</a>
<a name="ln264"> </a>
<a name="ln265">    /** See std::float_denorm_style for more information.  */</a>
<a name="ln266">    static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm = denorm_absent;</a>
<a name="ln267"> </a>
<a name="ln268">    /** True if loss of accuracy is detected as a denormalization loss,</a>
<a name="ln269">	rather than as an inexact result. */</a>
<a name="ln270">    static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;</a>
<a name="ln271"> </a>
<a name="ln272">    /** True if-and-only-if the type adheres to the IEC 559 standard, also</a>
<a name="ln273">	known as IEEE 754.  (Only makes sense for floating point types.)  */</a>
<a name="ln274">    static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;</a>
<a name="ln275"> </a>
<a name="ln276">    /** True if the set of values representable by the type is</a>
<a name="ln277">	finite.  All built-in types are bounded, this member would be</a>
<a name="ln278">	false for arbitrary precision types. */</a>
<a name="ln279">    static _GLIBCXX_USE_CONSTEXPR bool is_bounded = false;</a>
<a name="ln280"> </a>
<a name="ln281">    /** True if the type is @e modulo. A type is modulo if, for any</a>
<a name="ln282">	operation involving +, -, or * on values of that type whose</a>
<a name="ln283">	result would fall outside the range [min(),max()], the value</a>
<a name="ln284">	returned differs from the true value by an integer multiple of</a>
<a name="ln285">	max() - min() + 1. On most machines, this is false for floating</a>
<a name="ln286">	types, true for unsigned integers, and true for signed integers.</a>
<a name="ln287">	See PR22200 about signed integers.  */</a>
<a name="ln288">    static _GLIBCXX_USE_CONSTEXPR bool is_modulo = false;</a>
<a name="ln289"> </a>
<a name="ln290">    /** True if trapping is implemented for this type.  */</a>
<a name="ln291">    static _GLIBCXX_USE_CONSTEXPR bool traps = false;</a>
<a name="ln292"> </a>
<a name="ln293">    /** True if tininess is detected before rounding.  (see IEC 559)  */</a>
<a name="ln294">    static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;</a>
<a name="ln295"> </a>
<a name="ln296">    /** See std::float_round_style for more information.  This is only</a>
<a name="ln297">	meaningful for floating types; integer types will all be</a>
<a name="ln298">	round_toward_zero.  */</a>
<a name="ln299">    static _GLIBCXX_USE_CONSTEXPR float_round_style round_style =</a>
<a name="ln300">						    round_toward_zero;</a>
<a name="ln301">  };</a>
<a name="ln302"> </a>
<a name="ln303">  /**</a>
<a name="ln304">   *  @brief Properties of fundamental types.</a>
<a name="ln305">   *</a>
<a name="ln306">   *  This class allows a program to obtain information about the</a>
<a name="ln307">   *  representation of a fundamental type on a given platform.  For</a>
<a name="ln308">   *  non-fundamental types, the functions will return 0 and the data</a>
<a name="ln309">   *  members will all be @c false.</a>
<a name="ln310">  */</a>
<a name="ln311">  template&lt;typename _Tp&gt;</a>
<a name="ln312">    struct numeric_limits : public __numeric_limits_base</a>
<a name="ln313">    {</a>
<a name="ln314">      /** The minimum finite value, or for floating types with</a>
<a name="ln315">	  denormalization, the minimum positive normalized value.  */</a>
<a name="ln316">      static _GLIBCXX_CONSTEXPR _Tp</a>
<a name="ln317">      min() _GLIBCXX_USE_NOEXCEPT { return _Tp(); }</a>
<a name="ln318"> </a>
<a name="ln319">      /** The maximum finite value.  */</a>
<a name="ln320">      static _GLIBCXX_CONSTEXPR _Tp</a>
<a name="ln321">      max() _GLIBCXX_USE_NOEXCEPT { return _Tp(); }</a>
<a name="ln322"> </a>
<a name="ln323">#if __cplusplus &gt;= 201103L</a>
<a name="ln324">      /** A finite value x such that there is no other finite value y</a>
<a name="ln325">       *  where y &lt; x.  */</a>
<a name="ln326">      static constexpr _Tp</a>
<a name="ln327">      lowest() noexcept { return _Tp(); }</a>
<a name="ln328">#endif</a>
<a name="ln329"> </a>
<a name="ln330">      /** The @e machine @e epsilon:  the difference between 1 and the least</a>
<a name="ln331">	  value greater than 1 that is representable.  */</a>
<a name="ln332">      static _GLIBCXX_CONSTEXPR _Tp</a>
<a name="ln333">      epsilon() _GLIBCXX_USE_NOEXCEPT { return _Tp(); }</a>
<a name="ln334"> </a>
<a name="ln335">      /** The maximum rounding error measurement (see LIA-1).  */</a>
<a name="ln336">      static _GLIBCXX_CONSTEXPR _Tp</a>
<a name="ln337">      round_error() _GLIBCXX_USE_NOEXCEPT { return _Tp(); }</a>
<a name="ln338"> </a>
<a name="ln339">      /** The representation of positive infinity, if @c has_infinity.  */</a>
<a name="ln340">      static _GLIBCXX_CONSTEXPR _Tp</a>
<a name="ln341">      infinity() _GLIBCXX_USE_NOEXCEPT { return _Tp(); }</a>
<a name="ln342"> </a>
<a name="ln343">      /** The representation of a quiet Not a Number,</a>
<a name="ln344">	  if @c has_quiet_NaN. */</a>
<a name="ln345">      static _GLIBCXX_CONSTEXPR _Tp</a>
<a name="ln346">      quiet_NaN() _GLIBCXX_USE_NOEXCEPT { return _Tp(); }</a>
<a name="ln347"> </a>
<a name="ln348">      /** The representation of a signaling Not a Number, if</a>
<a name="ln349">	  @c has_signaling_NaN. */</a>
<a name="ln350">      static _GLIBCXX_CONSTEXPR _Tp</a>
<a name="ln351">      signaling_NaN() _GLIBCXX_USE_NOEXCEPT { return _Tp(); }</a>
<a name="ln352"> </a>
<a name="ln353">      /** The minimum positive denormalized value.  For types where</a>
<a name="ln354">	  @c has_denorm is false, this is the minimum positive normalized</a>
<a name="ln355">	  value.  */</a>
<a name="ln356">      static _GLIBCXX_CONSTEXPR _Tp</a>
<a name="ln357">      denorm_min() _GLIBCXX_USE_NOEXCEPT { return _Tp(); }</a>
<a name="ln358">    };</a>
<a name="ln359"> </a>
<a name="ln360">  // _GLIBCXX_RESOLVE_LIB_DEFECTS</a>
<a name="ln361">  // 559. numeric_limits&lt;const T&gt;</a>
<a name="ln362"> </a>
<a name="ln363">  template&lt;typename _Tp&gt;</a>
<a name="ln364">    struct numeric_limits&lt;const _Tp&gt;</a>
<a name="ln365">    : public numeric_limits&lt;_Tp&gt; { };</a>
<a name="ln366"> </a>
<a name="ln367">  template&lt;typename _Tp&gt;</a>
<a name="ln368">    struct numeric_limits&lt;volatile _Tp&gt;</a>
<a name="ln369">    : public numeric_limits&lt;_Tp&gt; { };</a>
<a name="ln370"> </a>
<a name="ln371">  template&lt;typename _Tp&gt;</a>
<a name="ln372">    struct numeric_limits&lt;const volatile _Tp&gt;</a>
<a name="ln373">    : public numeric_limits&lt;_Tp&gt; { };</a>
<a name="ln374"> </a>
<a name="ln375">  // Now there follow 16 explicit specializations.  Yes, 16.  Make sure</a>
<a name="ln376">  // you get the count right. (18 in C++11 mode, with char16_t and char32_t.)</a>
<a name="ln377"> </a>
<a name="ln378">  // _GLIBCXX_RESOLVE_LIB_DEFECTS</a>
<a name="ln379">  // 184. numeric_limits&lt;bool&gt; wording problems</a>
<a name="ln380"> </a>
<a name="ln381">  /// numeric_limits&lt;bool&gt; specialization.</a>
<a name="ln382">  template&lt;&gt;</a>
<a name="ln383">    struct numeric_limits&lt;bool&gt;</a>
<a name="ln384">    {</a>
<a name="ln385">      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;</a>
<a name="ln386"> </a>
<a name="ln387">      static _GLIBCXX_CONSTEXPR bool</a>
<a name="ln388">      min() _GLIBCXX_USE_NOEXCEPT { return false; }</a>
<a name="ln389"> </a>
<a name="ln390">      static _GLIBCXX_CONSTEXPR bool</a>
<a name="ln391">      max() _GLIBCXX_USE_NOEXCEPT { return true; }</a>
<a name="ln392"> </a>
<a name="ln393">#if __cplusplus &gt;= 201103L</a>
<a name="ln394">      static constexpr bool</a>
<a name="ln395">      lowest() noexcept { return min(); }</a>
<a name="ln396">#endif</a>
<a name="ln397">      static _GLIBCXX_USE_CONSTEXPR int digits = 1;</a>
<a name="ln398">      static _GLIBCXX_USE_CONSTEXPR int digits10 = 0;</a>
<a name="ln399">#if __cplusplus &gt;= 201103L</a>
<a name="ln400">      static constexpr int max_digits10 = 0;</a>
<a name="ln401">#endif</a>
<a name="ln402">      static _GLIBCXX_USE_CONSTEXPR bool is_signed = false;</a>
<a name="ln403">      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;</a>
<a name="ln404">      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;</a>
<a name="ln405">      static _GLIBCXX_USE_CONSTEXPR int radix = 2;</a>
<a name="ln406"> </a>
<a name="ln407">      static _GLIBCXX_CONSTEXPR bool</a>
<a name="ln408">      epsilon() _GLIBCXX_USE_NOEXCEPT { return false; }</a>
<a name="ln409"> </a>
<a name="ln410">      static _GLIBCXX_CONSTEXPR bool</a>
<a name="ln411">      round_error() _GLIBCXX_USE_NOEXCEPT { return false; }</a>
<a name="ln412"> </a>
<a name="ln413">      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;</a>
<a name="ln414">      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;</a>
<a name="ln415">      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;</a>
<a name="ln416">      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;</a>
<a name="ln417"> </a>
<a name="ln418">      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;</a>
<a name="ln419">      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;</a>
<a name="ln420">      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;</a>
<a name="ln421">      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm</a>
<a name="ln422">       = denorm_absent;</a>
<a name="ln423">      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;</a>
<a name="ln424"> </a>
<a name="ln425">      static _GLIBCXX_CONSTEXPR bool</a>
<a name="ln426">      infinity() _GLIBCXX_USE_NOEXCEPT { return false; }</a>
<a name="ln427"> </a>
<a name="ln428">      static _GLIBCXX_CONSTEXPR bool</a>
<a name="ln429">      quiet_NaN() _GLIBCXX_USE_NOEXCEPT { return false; }</a>
<a name="ln430"> </a>
<a name="ln431">      static _GLIBCXX_CONSTEXPR bool</a>
<a name="ln432">      signaling_NaN() _GLIBCXX_USE_NOEXCEPT { return false; }</a>
<a name="ln433"> </a>
<a name="ln434">      static _GLIBCXX_CONSTEXPR bool</a>
<a name="ln435">      denorm_min() _GLIBCXX_USE_NOEXCEPT { return false; }</a>
<a name="ln436"> </a>
<a name="ln437">      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;</a>
<a name="ln438">      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;</a>
<a name="ln439">      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = false;</a>
<a name="ln440"> </a>
<a name="ln441">      // It is not clear what it means for a boolean type to trap.</a>
<a name="ln442">      // This is a DR on the LWG issue list.  Here, I use integer</a>
<a name="ln443">      // promotion semantics.</a>
<a name="ln444">      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;</a>
<a name="ln445">      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;</a>
<a name="ln446">      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style</a>
<a name="ln447">       = round_toward_zero;</a>
<a name="ln448">    };</a>
<a name="ln449"> </a>
<a name="ln450">  /// numeric_limits&lt;char&gt; specialization.</a>
<a name="ln451">  template&lt;&gt;</a>
<a name="ln452">    struct numeric_limits&lt;char&gt;</a>
<a name="ln453">    {</a>
<a name="ln454">      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;</a>
<a name="ln455"> </a>
<a name="ln456">      static _GLIBCXX_CONSTEXPR char</a>
<a name="ln457">      min() _GLIBCXX_USE_NOEXCEPT { return __glibcxx_min(char); }</a>
<a name="ln458"> </a>
<a name="ln459">      static _GLIBCXX_CONSTEXPR char</a>
<a name="ln460">      max() _GLIBCXX_USE_NOEXCEPT { return __glibcxx_max(char); }</a>
<a name="ln461"> </a>
<a name="ln462">#if __cplusplus &gt;= 201103L</a>
<a name="ln463">      static constexpr char</a>
<a name="ln464">      lowest() noexcept { return min(); }</a>
<a name="ln465">#endif</a>
<a name="ln466"> </a>
<a name="ln467">      static _GLIBCXX_USE_CONSTEXPR int digits = __glibcxx_digits (char);</a>
<a name="ln468">      static _GLIBCXX_USE_CONSTEXPR int digits10 = __glibcxx_digits10 (char);</a>
<a name="ln469">#if __cplusplus &gt;= 201103L</a>
<a name="ln470">      static constexpr int max_digits10 = 0;</a>
<a name="ln471">#endif</a>
<a name="ln472">      static _GLIBCXX_USE_CONSTEXPR bool is_signed = __glibcxx_signed (char);</a>
<a name="ln473">      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;</a>
<a name="ln474">      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;</a>
<a name="ln475">      static _GLIBCXX_USE_CONSTEXPR int radix = 2;</a>
<a name="ln476"> </a>
<a name="ln477">      static _GLIBCXX_CONSTEXPR char</a>
<a name="ln478">      epsilon() _GLIBCXX_USE_NOEXCEPT { return 0; }</a>
<a name="ln479"> </a>
<a name="ln480">      static _GLIBCXX_CONSTEXPR char</a>
<a name="ln481">      round_error() _GLIBCXX_USE_NOEXCEPT { return 0; }</a>
<a name="ln482"> </a>
<a name="ln483">      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;</a>
<a name="ln484">      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;</a>
<a name="ln485">      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;</a>
<a name="ln486">      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;</a>
<a name="ln487"> </a>
<a name="ln488">      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;</a>
<a name="ln489">      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;</a>
<a name="ln490">      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;</a>
<a name="ln491">      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm</a>
<a name="ln492">       = denorm_absent;</a>
<a name="ln493">      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;</a>
<a name="ln494"> </a>
<a name="ln495">      static _GLIBCXX_CONSTEXPR</a>
<a name="ln496">      char infinity() _GLIBCXX_USE_NOEXCEPT { return char(); }</a>
<a name="ln497"> </a>
<a name="ln498">      static _GLIBCXX_CONSTEXPR char</a>
<a name="ln499">      quiet_NaN() _GLIBCXX_USE_NOEXCEPT { return char(); }</a>
<a name="ln500"> </a>
<a name="ln501">      static _GLIBCXX_CONSTEXPR char</a>
<a name="ln502">      signaling_NaN() _GLIBCXX_USE_NOEXCEPT { return char(); }</a>
<a name="ln503"> </a>
<a name="ln504">      static _GLIBCXX_CONSTEXPR char</a>
<a name="ln505">      denorm_min() _GLIBCXX_USE_NOEXCEPT { return static_cast&lt;char&gt;(0); }</a>
<a name="ln506"> </a>
<a name="ln507">      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;</a>
<a name="ln508">      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;</a>
<a name="ln509">      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = !is_signed;</a>
<a name="ln510"> </a>
<a name="ln511">      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;</a>
<a name="ln512">      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;</a>
<a name="ln513">      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style</a>
<a name="ln514">       = round_toward_zero;</a>
<a name="ln515">    };</a>
<a name="ln516"> </a>
<a name="ln517">  /// numeric_limits&lt;signed char&gt; specialization.</a>
<a name="ln518">  template&lt;&gt;</a>
<a name="ln519">    struct numeric_limits&lt;signed char&gt;</a>
<a name="ln520">    {</a>
<a name="ln521">      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;</a>
<a name="ln522"> </a>
<a name="ln523">      static _GLIBCXX_CONSTEXPR signed char</a>
<a name="ln524">      min() _GLIBCXX_USE_NOEXCEPT { return -__SCHAR_MAX__ - 1; }</a>
<a name="ln525"> </a>
<a name="ln526">      static _GLIBCXX_CONSTEXPR signed char</a>
<a name="ln527">      max() _GLIBCXX_USE_NOEXCEPT { return __SCHAR_MAX__; }</a>
<a name="ln528"> </a>
<a name="ln529">#if __cplusplus &gt;= 201103L</a>
<a name="ln530">      static constexpr signed char</a>
<a name="ln531">      lowest() noexcept { return min(); }</a>
<a name="ln532">#endif</a>
<a name="ln533"> </a>
<a name="ln534">      static _GLIBCXX_USE_CONSTEXPR int digits = __glibcxx_digits (signed char);</a>
<a name="ln535">      static _GLIBCXX_USE_CONSTEXPR int digits10</a>
<a name="ln536">       = __glibcxx_digits10 (signed char);</a>
<a name="ln537">#if __cplusplus &gt;= 201103L</a>
<a name="ln538">      static constexpr int max_digits10 = 0;</a>
<a name="ln539">#endif</a>
<a name="ln540">      static _GLIBCXX_USE_CONSTEXPR bool is_signed = true;</a>
<a name="ln541">      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;</a>
<a name="ln542">      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;</a>
<a name="ln543">      static _GLIBCXX_USE_CONSTEXPR int radix = 2;</a>
<a name="ln544"> </a>
<a name="ln545">      static _GLIBCXX_CONSTEXPR signed char</a>
<a name="ln546">      epsilon() _GLIBCXX_USE_NOEXCEPT { return 0; }</a>
<a name="ln547"> </a>
<a name="ln548">      static _GLIBCXX_CONSTEXPR signed char</a>
<a name="ln549">      round_error() _GLIBCXX_USE_NOEXCEPT { return 0; }</a>
<a name="ln550"> </a>
<a name="ln551">      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;</a>
<a name="ln552">      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;</a>
<a name="ln553">      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;</a>
<a name="ln554">      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;</a>
<a name="ln555"> </a>
<a name="ln556">      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;</a>
<a name="ln557">      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;</a>
<a name="ln558">      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;</a>
<a name="ln559">      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm</a>
<a name="ln560">       = denorm_absent;</a>
<a name="ln561">      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;</a>
<a name="ln562"> </a>
<a name="ln563">      static _GLIBCXX_CONSTEXPR signed char</a>
<a name="ln564">      infinity() _GLIBCXX_USE_NOEXCEPT { return static_cast&lt;signed char&gt;(0); }</a>
<a name="ln565"> </a>
<a name="ln566">      static _GLIBCXX_CONSTEXPR signed char</a>
<a name="ln567">      quiet_NaN() _GLIBCXX_USE_NOEXCEPT { return static_cast&lt;signed char&gt;(0); }</a>
<a name="ln568"> </a>
<a name="ln569">      static _GLIBCXX_CONSTEXPR signed char</a>
<a name="ln570">      signaling_NaN() _GLIBCXX_USE_NOEXCEPT</a>
<a name="ln571">      { return static_cast&lt;signed char&gt;(0); }</a>
<a name="ln572"> </a>
<a name="ln573">      static _GLIBCXX_CONSTEXPR signed char</a>
<a name="ln574">      denorm_min() _GLIBCXX_USE_NOEXCEPT</a>
<a name="ln575">      { return static_cast&lt;signed char&gt;(0); }</a>
<a name="ln576"> </a>
<a name="ln577">      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;</a>
<a name="ln578">      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;</a>
<a name="ln579">      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = false;</a>
<a name="ln580"> </a>
<a name="ln581">      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;</a>
<a name="ln582">      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;</a>
<a name="ln583">      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style</a>
<a name="ln584">       = round_toward_zero;</a>
<a name="ln585">    };</a>
<a name="ln586"> </a>
<a name="ln587">  /// numeric_limits&lt;unsigned char&gt; specialization.</a>
<a name="ln588">  template&lt;&gt;</a>
<a name="ln589">    struct numeric_limits&lt;unsigned char&gt;</a>
<a name="ln590">    {</a>
<a name="ln591">      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;</a>
<a name="ln592"> </a>
<a name="ln593">      static _GLIBCXX_CONSTEXPR unsigned char</a>
<a name="ln594">      min() _GLIBCXX_USE_NOEXCEPT { return 0; }</a>
<a name="ln595"> </a>
<a name="ln596">      static _GLIBCXX_CONSTEXPR unsigned char</a>
<a name="ln597">      max() _GLIBCXX_USE_NOEXCEPT { return __SCHAR_MAX__ * 2U + 1; }</a>
<a name="ln598"> </a>
<a name="ln599">#if __cplusplus &gt;= 201103L</a>
<a name="ln600">      static constexpr unsigned char</a>
<a name="ln601">      lowest() noexcept { return min(); }</a>
<a name="ln602">#endif</a>
<a name="ln603"> </a>
<a name="ln604">      static _GLIBCXX_USE_CONSTEXPR int digits</a>
<a name="ln605">       = __glibcxx_digits (unsigned char);</a>
<a name="ln606">      static _GLIBCXX_USE_CONSTEXPR int digits10</a>
<a name="ln607">       = __glibcxx_digits10 (unsigned char);</a>
<a name="ln608">#if __cplusplus &gt;= 201103L</a>
<a name="ln609">      static constexpr int max_digits10 = 0;</a>
<a name="ln610">#endif</a>
<a name="ln611">      static _GLIBCXX_USE_CONSTEXPR bool is_signed = false;</a>
<a name="ln612">      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;</a>
<a name="ln613">      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;</a>
<a name="ln614">      static _GLIBCXX_USE_CONSTEXPR int radix = 2;</a>
<a name="ln615"> </a>
<a name="ln616">      static _GLIBCXX_CONSTEXPR unsigned char</a>
<a name="ln617">      epsilon() _GLIBCXX_USE_NOEXCEPT { return 0; }</a>
<a name="ln618"> </a>
<a name="ln619">      static _GLIBCXX_CONSTEXPR unsigned char</a>
<a name="ln620">      round_error() _GLIBCXX_USE_NOEXCEPT { return 0; }</a>
<a name="ln621"> </a>
<a name="ln622">      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;</a>
<a name="ln623">      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;</a>
<a name="ln624">      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;</a>
<a name="ln625">      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;</a>
<a name="ln626"> </a>
<a name="ln627">      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;</a>
<a name="ln628">      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;</a>
<a name="ln629">      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;</a>
<a name="ln630">      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm</a>
<a name="ln631">       = denorm_absent;</a>
<a name="ln632">      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;</a>
<a name="ln633"> </a>
<a name="ln634">      static _GLIBCXX_CONSTEXPR unsigned char</a>
<a name="ln635">      infinity() _GLIBCXX_USE_NOEXCEPT</a>
<a name="ln636">      { return static_cast&lt;unsigned char&gt;(0); }</a>
<a name="ln637"> </a>
<a name="ln638">      static _GLIBCXX_CONSTEXPR unsigned char</a>
<a name="ln639">      quiet_NaN() _GLIBCXX_USE_NOEXCEPT</a>
<a name="ln640">      { return static_cast&lt;unsigned char&gt;(0); }</a>
<a name="ln641"> </a>
<a name="ln642">      static _GLIBCXX_CONSTEXPR unsigned char</a>
<a name="ln643">      signaling_NaN() _GLIBCXX_USE_NOEXCEPT</a>
<a name="ln644">      { return static_cast&lt;unsigned char&gt;(0); }</a>
<a name="ln645"> </a>
<a name="ln646">      static _GLIBCXX_CONSTEXPR unsigned char</a>
<a name="ln647">      denorm_min() _GLIBCXX_USE_NOEXCEPT</a>
<a name="ln648">      { return static_cast&lt;unsigned char&gt;(0); }</a>
<a name="ln649"> </a>
<a name="ln650">      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;</a>
<a name="ln651">      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;</a>
<a name="ln652">      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = true;</a>
<a name="ln653"> </a>
<a name="ln654">      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;</a>
<a name="ln655">      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;</a>
<a name="ln656">      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style</a>
<a name="ln657">       = round_toward_zero;</a>
<a name="ln658">    };</a>
<a name="ln659"> </a>
<a name="ln660">  /// numeric_limits&lt;wchar_t&gt; specialization.</a>
<a name="ln661">  template&lt;&gt;</a>
<a name="ln662">    struct numeric_limits&lt;wchar_t&gt;</a>
<a name="ln663">    {</a>
<a name="ln664">      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;</a>
<a name="ln665"> </a>
<a name="ln666">      static _GLIBCXX_CONSTEXPR wchar_t</a>
<a name="ln667">      min() _GLIBCXX_USE_NOEXCEPT { return __glibcxx_min (wchar_t); }</a>
<a name="ln668"> </a>
<a name="ln669">      static _GLIBCXX_CONSTEXPR wchar_t</a>
<a name="ln670">      max() _GLIBCXX_USE_NOEXCEPT { return __glibcxx_max (wchar_t); }</a>
<a name="ln671"> </a>
<a name="ln672">#if __cplusplus &gt;= 201103L</a>
<a name="ln673">      static constexpr wchar_t</a>
<a name="ln674">      lowest() noexcept { return min(); }</a>
<a name="ln675">#endif</a>
<a name="ln676"> </a>
<a name="ln677">      static _GLIBCXX_USE_CONSTEXPR int digits = __glibcxx_digits (wchar_t);</a>
<a name="ln678">      static _GLIBCXX_USE_CONSTEXPR int digits10</a>
<a name="ln679">       = __glibcxx_digits10 (wchar_t);</a>
<a name="ln680">#if __cplusplus &gt;= 201103L</a>
<a name="ln681">      static constexpr int max_digits10 = 0;</a>
<a name="ln682">#endif</a>
<a name="ln683">      static _GLIBCXX_USE_CONSTEXPR bool is_signed = __glibcxx_signed (wchar_t);</a>
<a name="ln684">      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;</a>
<a name="ln685">      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;</a>
<a name="ln686">      static _GLIBCXX_USE_CONSTEXPR int radix = 2;</a>
<a name="ln687"> </a>
<a name="ln688">      static _GLIBCXX_CONSTEXPR wchar_t</a>
<a name="ln689">      epsilon() _GLIBCXX_USE_NOEXCEPT { return 0; }</a>
<a name="ln690"> </a>
<a name="ln691">      static _GLIBCXX_CONSTEXPR wchar_t</a>
<a name="ln692">      round_error() _GLIBCXX_USE_NOEXCEPT { return 0; }</a>
<a name="ln693"> </a>
<a name="ln694">      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;</a>
<a name="ln695">      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;</a>
<a name="ln696">      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;</a>
<a name="ln697">      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;</a>
<a name="ln698"> </a>
<a name="ln699">      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;</a>
<a name="ln700">      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;</a>
<a name="ln701">      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;</a>
<a name="ln702">      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm</a>
<a name="ln703">       = denorm_absent;</a>
<a name="ln704">      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;</a>
<a name="ln705"> </a>
<a name="ln706">      static _GLIBCXX_CONSTEXPR wchar_t</a>
<a name="ln707">      infinity() _GLIBCXX_USE_NOEXCEPT { return wchar_t(); }</a>
<a name="ln708"> </a>
<a name="ln709">      static _GLIBCXX_CONSTEXPR wchar_t</a>
<a name="ln710">      quiet_NaN() _GLIBCXX_USE_NOEXCEPT { return wchar_t(); }</a>
<a name="ln711"> </a>
<a name="ln712">      static _GLIBCXX_CONSTEXPR wchar_t</a>
<a name="ln713">      signaling_NaN() _GLIBCXX_USE_NOEXCEPT { return wchar_t(); }</a>
<a name="ln714"> </a>
<a name="ln715">      static _GLIBCXX_CONSTEXPR wchar_t</a>
<a name="ln716">      denorm_min() _GLIBCXX_USE_NOEXCEPT { return wchar_t(); }</a>
<a name="ln717"> </a>
<a name="ln718">      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;</a>
<a name="ln719">      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;</a>
<a name="ln720">      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = !is_signed;</a>
<a name="ln721"> </a>
<a name="ln722">      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;</a>
<a name="ln723">      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;</a>
<a name="ln724">      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style</a>
<a name="ln725">       = round_toward_zero;</a>
<a name="ln726">    };</a>
<a name="ln727"> </a>
<a name="ln728">#if __cplusplus &gt;= 201103L</a>
<a name="ln729">  /// numeric_limits&lt;char16_t&gt; specialization.</a>
<a name="ln730">  template&lt;&gt;</a>
<a name="ln731">    struct numeric_limits&lt;char16_t&gt;</a>
<a name="ln732">    {</a>
<a name="ln733">      static constexpr bool is_specialized = true;</a>
<a name="ln734"> </a>
<a name="ln735">      static constexpr char16_t</a>
<a name="ln736">      min() noexcept { return __glibcxx_min (char16_t); }</a>
<a name="ln737"> </a>
<a name="ln738">      static constexpr char16_t</a>
<a name="ln739">      max() noexcept { return __glibcxx_max (char16_t); }</a>
<a name="ln740"> </a>
<a name="ln741">      static constexpr char16_t</a>
<a name="ln742">      lowest() noexcept { return min(); }</a>
<a name="ln743"> </a>
<a name="ln744">      static constexpr int digits = __glibcxx_digits (char16_t);</a>
<a name="ln745">      static constexpr int digits10 = __glibcxx_digits10 (char16_t);</a>
<a name="ln746">      static constexpr int max_digits10 = 0;</a>
<a name="ln747">      static constexpr bool is_signed = __glibcxx_signed (char16_t);</a>
<a name="ln748">      static constexpr bool is_integer = true;</a>
<a name="ln749">      static constexpr bool is_exact = true;</a>
<a name="ln750">      static constexpr int radix = 2;</a>
<a name="ln751"> </a>
<a name="ln752">      static constexpr char16_t</a>
<a name="ln753">      epsilon() noexcept { return 0; }</a>
<a name="ln754"> </a>
<a name="ln755">      static constexpr char16_t</a>
<a name="ln756">      round_error() noexcept { return 0; }</a>
<a name="ln757"> </a>
<a name="ln758">      static constexpr int min_exponent = 0;</a>
<a name="ln759">      static constexpr int min_exponent10 = 0;</a>
<a name="ln760">      static constexpr int max_exponent = 0;</a>
<a name="ln761">      static constexpr int max_exponent10 = 0;</a>
<a name="ln762"> </a>
<a name="ln763">      static constexpr bool has_infinity = false;</a>
<a name="ln764">      static constexpr bool has_quiet_NaN = false;</a>
<a name="ln765">      static constexpr bool has_signaling_NaN = false;</a>
<a name="ln766">      static constexpr float_denorm_style has_denorm = denorm_absent;</a>
<a name="ln767">      static constexpr bool has_denorm_loss = false;</a>
<a name="ln768"> </a>
<a name="ln769">      static constexpr char16_t</a>
<a name="ln770">      infinity() noexcept { return char16_t(); }</a>
<a name="ln771"> </a>
<a name="ln772">      static constexpr char16_t</a>
<a name="ln773">      quiet_NaN() noexcept { return char16_t(); }</a>
<a name="ln774"> </a>
<a name="ln775">      static constexpr char16_t</a>
<a name="ln776">      signaling_NaN() noexcept { return char16_t(); }</a>
<a name="ln777"> </a>
<a name="ln778">      static constexpr char16_t</a>
<a name="ln779">      denorm_min() noexcept { return char16_t(); }</a>
<a name="ln780"> </a>
<a name="ln781">      static constexpr bool is_iec559 = false;</a>
<a name="ln782">      static constexpr bool is_bounded = true;</a>
<a name="ln783">      static constexpr bool is_modulo = !is_signed;</a>
<a name="ln784"> </a>
<a name="ln785">      static constexpr bool traps = __glibcxx_integral_traps;</a>
<a name="ln786">      static constexpr bool tinyness_before = false;</a>
<a name="ln787">      static constexpr float_round_style round_style = round_toward_zero;</a>
<a name="ln788">    };</a>
<a name="ln789"> </a>
<a name="ln790">  /// numeric_limits&lt;char32_t&gt; specialization.</a>
<a name="ln791">  template&lt;&gt;</a>
<a name="ln792">    struct numeric_limits&lt;char32_t&gt;</a>
<a name="ln793">    {</a>
<a name="ln794">      static constexpr bool is_specialized = true;</a>
<a name="ln795"> </a>
<a name="ln796">      static constexpr char32_t</a>
<a name="ln797">      min() noexcept { return __glibcxx_min (char32_t); }</a>
<a name="ln798"> </a>
<a name="ln799">      static constexpr char32_t</a>
<a name="ln800">      max() noexcept { return __glibcxx_max (char32_t); }</a>
<a name="ln801"> </a>
<a name="ln802">      static constexpr char32_t</a>
<a name="ln803">      lowest() noexcept { return min(); }</a>
<a name="ln804"> </a>
<a name="ln805">      static constexpr int digits = __glibcxx_digits (char32_t);</a>
<a name="ln806">      static constexpr int digits10 = __glibcxx_digits10 (char32_t);</a>
<a name="ln807">      static constexpr int max_digits10 = 0;</a>
<a name="ln808">      static constexpr bool is_signed = __glibcxx_signed (char32_t);</a>
<a name="ln809">      static constexpr bool is_integer = true;</a>
<a name="ln810">      static constexpr bool is_exact = true;</a>
<a name="ln811">      static constexpr int radix = 2;</a>
<a name="ln812"> </a>
<a name="ln813">      static constexpr char32_t</a>
<a name="ln814">      epsilon() noexcept { return 0; }</a>
<a name="ln815"> </a>
<a name="ln816">      static constexpr char32_t</a>
<a name="ln817">      round_error() noexcept { return 0; }</a>
<a name="ln818"> </a>
<a name="ln819">      static constexpr int min_exponent = 0;</a>
<a name="ln820">      static constexpr int min_exponent10 = 0;</a>
<a name="ln821">      static constexpr int max_exponent = 0;</a>
<a name="ln822">      static constexpr int max_exponent10 = 0;</a>
<a name="ln823"> </a>
<a name="ln824">      static constexpr bool has_infinity = false;</a>
<a name="ln825">      static constexpr bool has_quiet_NaN = false;</a>
<a name="ln826">      static constexpr bool has_signaling_NaN = false;</a>
<a name="ln827">      static constexpr float_denorm_style has_denorm = denorm_absent;</a>
<a name="ln828">      static constexpr bool has_denorm_loss = false;</a>
<a name="ln829"> </a>
<a name="ln830">      static constexpr char32_t</a>
<a name="ln831">      infinity() noexcept { return char32_t(); }</a>
<a name="ln832"> </a>
<a name="ln833">      static constexpr char32_t</a>
<a name="ln834">      quiet_NaN() noexcept { return char32_t(); }</a>
<a name="ln835"> </a>
<a name="ln836">      static constexpr char32_t</a>
<a name="ln837">      signaling_NaN() noexcept { return char32_t(); }</a>
<a name="ln838"> </a>
<a name="ln839">      static constexpr char32_t</a>
<a name="ln840">      denorm_min() noexcept { return char32_t(); }</a>
<a name="ln841"> </a>
<a name="ln842">      static constexpr bool is_iec559 = false;</a>
<a name="ln843">      static constexpr bool is_bounded = true;</a>
<a name="ln844">      static constexpr bool is_modulo = !is_signed;</a>
<a name="ln845"> </a>
<a name="ln846">      static constexpr bool traps = __glibcxx_integral_traps;</a>
<a name="ln847">      static constexpr bool tinyness_before = false;</a>
<a name="ln848">      static constexpr float_round_style round_style = round_toward_zero;</a>
<a name="ln849">    };</a>
<a name="ln850">#endif</a>
<a name="ln851"> </a>
<a name="ln852">  /// numeric_limits&lt;short&gt; specialization.</a>
<a name="ln853">  template&lt;&gt;</a>
<a name="ln854">    struct numeric_limits&lt;short&gt;</a>
<a name="ln855">    {</a>
<a name="ln856">      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;</a>
<a name="ln857"> </a>
<a name="ln858">      static _GLIBCXX_CONSTEXPR short</a>
<a name="ln859">      min() _GLIBCXX_USE_NOEXCEPT { return -__SHRT_MAX__ - 1; }</a>
<a name="ln860"> </a>
<a name="ln861">      static _GLIBCXX_CONSTEXPR short</a>
<a name="ln862">      max() _GLIBCXX_USE_NOEXCEPT { return __SHRT_MAX__; }</a>
<a name="ln863"> </a>
<a name="ln864">#if __cplusplus &gt;= 201103L</a>
<a name="ln865">      static constexpr short</a>
<a name="ln866">      lowest() noexcept { return min(); }</a>
<a name="ln867">#endif</a>
<a name="ln868"> </a>
<a name="ln869">      static _GLIBCXX_USE_CONSTEXPR int digits = __glibcxx_digits (short);</a>
<a name="ln870">      static _GLIBCXX_USE_CONSTEXPR int digits10 = __glibcxx_digits10 (short);</a>
<a name="ln871">#if __cplusplus &gt;= 201103L</a>
<a name="ln872">      static constexpr int max_digits10 = 0;</a>
<a name="ln873">#endif</a>
<a name="ln874">      static _GLIBCXX_USE_CONSTEXPR bool is_signed = true;</a>
<a name="ln875">      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;</a>
<a name="ln876">      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;</a>
<a name="ln877">      static _GLIBCXX_USE_CONSTEXPR int radix = 2;</a>
<a name="ln878"> </a>
<a name="ln879">      static _GLIBCXX_CONSTEXPR short</a>
<a name="ln880">      epsilon() _GLIBCXX_USE_NOEXCEPT { return 0; }</a>
<a name="ln881"> </a>
<a name="ln882">      static _GLIBCXX_CONSTEXPR short</a>
<a name="ln883">      round_error() _GLIBCXX_USE_NOEXCEPT { return 0; }</a>
<a name="ln884"> </a>
<a name="ln885">      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;</a>
<a name="ln886">      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;</a>
<a name="ln887">      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;</a>
<a name="ln888">      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;</a>
<a name="ln889"> </a>
<a name="ln890">      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;</a>
<a name="ln891">      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;</a>
<a name="ln892">      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;</a>
<a name="ln893">      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm</a>
<a name="ln894">       = denorm_absent;</a>
<a name="ln895">      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;</a>
<a name="ln896"> </a>
<a name="ln897">      static _GLIBCXX_CONSTEXPR short</a>
<a name="ln898">      infinity() _GLIBCXX_USE_NOEXCEPT { return short(); }</a>
<a name="ln899"> </a>
<a name="ln900">      static _GLIBCXX_CONSTEXPR short</a>
<a name="ln901">      quiet_NaN() _GLIBCXX_USE_NOEXCEPT { return short(); }</a>
<a name="ln902"> </a>
<a name="ln903">      static _GLIBCXX_CONSTEXPR short</a>
<a name="ln904">      signaling_NaN() _GLIBCXX_USE_NOEXCEPT { return short(); }</a>
<a name="ln905"> </a>
<a name="ln906">      static _GLIBCXX_CONSTEXPR short</a>
<a name="ln907">      denorm_min() _GLIBCXX_USE_NOEXCEPT { return short(); }</a>
<a name="ln908"> </a>
<a name="ln909">      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;</a>
<a name="ln910">      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;</a>
<a name="ln911">      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = false;</a>
<a name="ln912"> </a>
<a name="ln913">      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;</a>
<a name="ln914">      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;</a>
<a name="ln915">      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style</a>
<a name="ln916">       = round_toward_zero;</a>
<a name="ln917">    };</a>
<a name="ln918"> </a>
<a name="ln919">  /// numeric_limits&lt;unsigned short&gt; specialization.</a>
<a name="ln920">  template&lt;&gt;</a>
<a name="ln921">    struct numeric_limits&lt;unsigned short&gt;</a>
<a name="ln922">    {</a>
<a name="ln923">      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;</a>
<a name="ln924"> </a>
<a name="ln925">      static _GLIBCXX_CONSTEXPR unsigned short</a>
<a name="ln926">      min() _GLIBCXX_USE_NOEXCEPT { return 0; }</a>
<a name="ln927"> </a>
<a name="ln928">      static _GLIBCXX_CONSTEXPR unsigned short</a>
<a name="ln929">      max() _GLIBCXX_USE_NOEXCEPT { return __SHRT_MAX__ * 2U + 1; }</a>
<a name="ln930"> </a>
<a name="ln931">#if __cplusplus &gt;= 201103L</a>
<a name="ln932">      static constexpr unsigned short</a>
<a name="ln933">      lowest() noexcept { return min(); }</a>
<a name="ln934">#endif</a>
<a name="ln935"> </a>
<a name="ln936">      static _GLIBCXX_USE_CONSTEXPR int digits</a>
<a name="ln937">       = __glibcxx_digits (unsigned short);</a>
<a name="ln938">      static _GLIBCXX_USE_CONSTEXPR int digits10</a>
<a name="ln939">       = __glibcxx_digits10 (unsigned short);</a>
<a name="ln940">#if __cplusplus &gt;= 201103L</a>
<a name="ln941">      static constexpr int max_digits10 = 0;</a>
<a name="ln942">#endif</a>
<a name="ln943">      static _GLIBCXX_USE_CONSTEXPR bool is_signed = false;</a>
<a name="ln944">      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;</a>
<a name="ln945">      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;</a>
<a name="ln946">      static _GLIBCXX_USE_CONSTEXPR int radix = 2;</a>
<a name="ln947"> </a>
<a name="ln948">      static _GLIBCXX_CONSTEXPR unsigned short</a>
<a name="ln949">      epsilon() _GLIBCXX_USE_NOEXCEPT { return 0; }</a>
<a name="ln950"> </a>
<a name="ln951">      static _GLIBCXX_CONSTEXPR unsigned short</a>
<a name="ln952">      round_error() _GLIBCXX_USE_NOEXCEPT { return 0; }</a>
<a name="ln953"> </a>
<a name="ln954">      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;</a>
<a name="ln955">      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;</a>
<a name="ln956">      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;</a>
<a name="ln957">      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;</a>
<a name="ln958"> </a>
<a name="ln959">      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;</a>
<a name="ln960">      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;</a>
<a name="ln961">      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;</a>
<a name="ln962">      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm</a>
<a name="ln963">       = denorm_absent;</a>
<a name="ln964">      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;</a>
<a name="ln965"> </a>
<a name="ln966">      static _GLIBCXX_CONSTEXPR unsigned short</a>
<a name="ln967">      infinity() _GLIBCXX_USE_NOEXCEPT</a>
<a name="ln968">      { return static_cast&lt;unsigned short&gt;(0); }</a>
<a name="ln969"> </a>
<a name="ln970">      static _GLIBCXX_CONSTEXPR unsigned short</a>
<a name="ln971">      quiet_NaN() _GLIBCXX_USE_NOEXCEPT</a>
<a name="ln972">      { return static_cast&lt;unsigned short&gt;(0); }</a>
<a name="ln973"> </a>
<a name="ln974">      static _GLIBCXX_CONSTEXPR unsigned short</a>
<a name="ln975">      signaling_NaN() _GLIBCXX_USE_NOEXCEPT</a>
<a name="ln976">      { return static_cast&lt;unsigned short&gt;(0); }</a>
<a name="ln977"> </a>
<a name="ln978">      static _GLIBCXX_CONSTEXPR unsigned short</a>
<a name="ln979">      denorm_min() _GLIBCXX_USE_NOEXCEPT</a>
<a name="ln980">      { return static_cast&lt;unsigned short&gt;(0); }</a>
<a name="ln981"> </a>
<a name="ln982">      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;</a>
<a name="ln983">      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;</a>
<a name="ln984">      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = true;</a>
<a name="ln985"> </a>
<a name="ln986">      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;</a>
<a name="ln987">      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;</a>
<a name="ln988">      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style</a>
<a name="ln989">       = round_toward_zero;</a>
<a name="ln990">    };</a>
<a name="ln991"> </a>
<a name="ln992">  /// numeric_limits&lt;int&gt; specialization.</a>
<a name="ln993">  template&lt;&gt;</a>
<a name="ln994">    struct numeric_limits&lt;int&gt;</a>
<a name="ln995">    {</a>
<a name="ln996">      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;</a>
<a name="ln997"> </a>
<a name="ln998">      static _GLIBCXX_CONSTEXPR int</a>
<a name="ln999">      min() _GLIBCXX_USE_NOEXCEPT { return -__INT_MAX__ - 1; }</a>
<a name="ln1000"> </a>
<a name="ln1001">      static _GLIBCXX_CONSTEXPR int</a>
<a name="ln1002">      max() _GLIBCXX_USE_NOEXCEPT { return __INT_MAX__; }</a>
<a name="ln1003"> </a>
<a name="ln1004">#if __cplusplus &gt;= 201103L</a>
<a name="ln1005">      static constexpr int</a>
<a name="ln1006">      lowest() noexcept { return min(); }</a>
<a name="ln1007">#endif</a>
<a name="ln1008"> </a>
<a name="ln1009">      static _GLIBCXX_USE_CONSTEXPR int digits = __glibcxx_digits (int);</a>
<a name="ln1010">      static _GLIBCXX_USE_CONSTEXPR int digits10 = __glibcxx_digits10 (int);</a>
<a name="ln1011">#if __cplusplus &gt;= 201103L</a>
<a name="ln1012">      static constexpr int max_digits10 = 0;</a>
<a name="ln1013">#endif</a>
<a name="ln1014">      static _GLIBCXX_USE_CONSTEXPR bool is_signed = true;</a>
<a name="ln1015">      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;</a>
<a name="ln1016">      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;</a>
<a name="ln1017">      static _GLIBCXX_USE_CONSTEXPR int radix = 2;</a>
<a name="ln1018"> </a>
<a name="ln1019">      static _GLIBCXX_CONSTEXPR int</a>
<a name="ln1020">      epsilon() _GLIBCXX_USE_NOEXCEPT { return 0; }</a>
<a name="ln1021"> </a>
<a name="ln1022">      static _GLIBCXX_CONSTEXPR int</a>
<a name="ln1023">      round_error() _GLIBCXX_USE_NOEXCEPT { return 0; }</a>
<a name="ln1024"> </a>
<a name="ln1025">      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;</a>
<a name="ln1026">      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;</a>
<a name="ln1027">      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;</a>
<a name="ln1028">      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;</a>
<a name="ln1029"> </a>
<a name="ln1030">      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;</a>
<a name="ln1031">      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;</a>
<a name="ln1032">      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;</a>
<a name="ln1033">      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm</a>
<a name="ln1034">       = denorm_absent;</a>
<a name="ln1035">      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;</a>
<a name="ln1036"> </a>
<a name="ln1037">      static _GLIBCXX_CONSTEXPR int</a>
<a name="ln1038">      infinity() _GLIBCXX_USE_NOEXCEPT { return static_cast&lt;int&gt;(0); }</a>
<a name="ln1039"> </a>
<a name="ln1040">      static _GLIBCXX_CONSTEXPR int</a>
<a name="ln1041">      quiet_NaN() _GLIBCXX_USE_NOEXCEPT { return static_cast&lt;int&gt;(0); }</a>
<a name="ln1042"> </a>
<a name="ln1043">      static _GLIBCXX_CONSTEXPR int</a>
<a name="ln1044">      signaling_NaN() _GLIBCXX_USE_NOEXCEPT { return static_cast&lt;int&gt;(0); }</a>
<a name="ln1045"> </a>
<a name="ln1046">      static _GLIBCXX_CONSTEXPR int</a>
<a name="ln1047">      denorm_min() _GLIBCXX_USE_NOEXCEPT { return static_cast&lt;int&gt;(0); }</a>
<a name="ln1048"> </a>
<a name="ln1049">      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;</a>
<a name="ln1050">      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;</a>
<a name="ln1051">      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = false;</a>
<a name="ln1052"> </a>
<a name="ln1053">      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;</a>
<a name="ln1054">      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;</a>
<a name="ln1055">      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style</a>
<a name="ln1056">       = round_toward_zero;</a>
<a name="ln1057">    };</a>
<a name="ln1058"> </a>
<a name="ln1059">  /// numeric_limits&lt;unsigned int&gt; specialization.</a>
<a name="ln1060">  template&lt;&gt;</a>
<a name="ln1061">    struct numeric_limits&lt;unsigned int&gt;</a>
<a name="ln1062">    {</a>
<a name="ln1063">      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;</a>
<a name="ln1064"> </a>
<a name="ln1065">      static _GLIBCXX_CONSTEXPR unsigned int</a>
<a name="ln1066">      min() _GLIBCXX_USE_NOEXCEPT { return 0; }</a>
<a name="ln1067"> </a>
<a name="ln1068">      static _GLIBCXX_CONSTEXPR unsigned int</a>
<a name="ln1069">      max() _GLIBCXX_USE_NOEXCEPT { return __INT_MAX__ * 2U + 1; }</a>
<a name="ln1070"> </a>
<a name="ln1071">#if __cplusplus &gt;= 201103L</a>
<a name="ln1072">      static constexpr unsigned int</a>
<a name="ln1073">      lowest() noexcept { return min(); }</a>
<a name="ln1074">#endif</a>
<a name="ln1075"> </a>
<a name="ln1076">      static _GLIBCXX_USE_CONSTEXPR int digits</a>
<a name="ln1077">       = __glibcxx_digits (unsigned int);</a>
<a name="ln1078">      static _GLIBCXX_USE_CONSTEXPR int digits10</a>
<a name="ln1079">       = __glibcxx_digits10 (unsigned int);</a>
<a name="ln1080">#if __cplusplus &gt;= 201103L</a>
<a name="ln1081">      static constexpr int max_digits10 = 0;</a>
<a name="ln1082">#endif</a>
<a name="ln1083">      static _GLIBCXX_USE_CONSTEXPR bool is_signed = false;</a>
<a name="ln1084">      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;</a>
<a name="ln1085">      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;</a>
<a name="ln1086">      static _GLIBCXX_USE_CONSTEXPR int radix = 2;</a>
<a name="ln1087"> </a>
<a name="ln1088">      static _GLIBCXX_CONSTEXPR unsigned int</a>
<a name="ln1089">      epsilon() _GLIBCXX_USE_NOEXCEPT { return 0; }</a>
<a name="ln1090"> </a>
<a name="ln1091">      static _GLIBCXX_CONSTEXPR unsigned int</a>
<a name="ln1092">      round_error() _GLIBCXX_USE_NOEXCEPT { return 0; }</a>
<a name="ln1093"> </a>
<a name="ln1094">      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;</a>
<a name="ln1095">      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;</a>
<a name="ln1096">      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;</a>
<a name="ln1097">      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;</a>
<a name="ln1098"> </a>
<a name="ln1099">      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;</a>
<a name="ln1100">      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;</a>
<a name="ln1101">      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;</a>
<a name="ln1102">      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm</a>
<a name="ln1103">       = denorm_absent;</a>
<a name="ln1104">      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;</a>
<a name="ln1105"> </a>
<a name="ln1106">      static _GLIBCXX_CONSTEXPR unsigned int</a>
<a name="ln1107">      infinity() _GLIBCXX_USE_NOEXCEPT { return static_cast&lt;unsigned int&gt;(0); }</a>
<a name="ln1108"> </a>
<a name="ln1109">      static _GLIBCXX_CONSTEXPR unsigned int</a>
<a name="ln1110">      quiet_NaN() _GLIBCXX_USE_NOEXCEPT</a>
<a name="ln1111">      { return static_cast&lt;unsigned int&gt;(0); }</a>
<a name="ln1112"> </a>
<a name="ln1113">      static _GLIBCXX_CONSTEXPR unsigned int</a>
<a name="ln1114">      signaling_NaN() _GLIBCXX_USE_NOEXCEPT</a>
<a name="ln1115">      { return static_cast&lt;unsigned int&gt;(0); }</a>
<a name="ln1116"> </a>
<a name="ln1117">      static _GLIBCXX_CONSTEXPR unsigned int</a>
<a name="ln1118">      denorm_min() _GLIBCXX_USE_NOEXCEPT</a>
<a name="ln1119">      { return static_cast&lt;unsigned int&gt;(0); }</a>
<a name="ln1120"> </a>
<a name="ln1121">      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;</a>
<a name="ln1122">      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;</a>
<a name="ln1123">      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = true;</a>
<a name="ln1124"> </a>
<a name="ln1125">      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;</a>
<a name="ln1126">      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;</a>
<a name="ln1127">      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style</a>
<a name="ln1128">       = round_toward_zero;</a>
<a name="ln1129">    };</a>
<a name="ln1130"> </a>
<a name="ln1131">  /// numeric_limits&lt;long&gt; specialization.</a>
<a name="ln1132">  template&lt;&gt;</a>
<a name="ln1133">    struct numeric_limits&lt;long&gt;</a>
<a name="ln1134">    {</a>
<a name="ln1135">      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;</a>
<a name="ln1136"> </a>
<a name="ln1137">      static _GLIBCXX_CONSTEXPR long</a>
<a name="ln1138">      min() _GLIBCXX_USE_NOEXCEPT { return -__LONG_MAX__ - 1; }</a>
<a name="ln1139"> </a>
<a name="ln1140">      static _GLIBCXX_CONSTEXPR long</a>
<a name="ln1141">      max() _GLIBCXX_USE_NOEXCEPT { return __LONG_MAX__; }</a>
<a name="ln1142"> </a>
<a name="ln1143">#if __cplusplus &gt;= 201103L</a>
<a name="ln1144">      static constexpr long</a>
<a name="ln1145">      lowest() noexcept { return min(); }</a>
<a name="ln1146">#endif</a>
<a name="ln1147"> </a>
<a name="ln1148">      static _GLIBCXX_USE_CONSTEXPR int digits = __glibcxx_digits (long);</a>
<a name="ln1149">      static _GLIBCXX_USE_CONSTEXPR int digits10 = __glibcxx_digits10 (long);</a>
<a name="ln1150">#if __cplusplus &gt;= 201103L</a>
<a name="ln1151">      static constexpr int max_digits10 = 0;</a>
<a name="ln1152">#endif</a>
<a name="ln1153">      static _GLIBCXX_USE_CONSTEXPR bool is_signed = true;</a>
<a name="ln1154">      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;</a>
<a name="ln1155">      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;</a>
<a name="ln1156">      static _GLIBCXX_USE_CONSTEXPR int radix = 2;</a>
<a name="ln1157"> </a>
<a name="ln1158">      static _GLIBCXX_CONSTEXPR long</a>
<a name="ln1159">      epsilon() _GLIBCXX_USE_NOEXCEPT { return 0; }</a>
<a name="ln1160"> </a>
<a name="ln1161">      static _GLIBCXX_CONSTEXPR long</a>
<a name="ln1162">      round_error() _GLIBCXX_USE_NOEXCEPT { return 0; }</a>
<a name="ln1163"> </a>
<a name="ln1164">      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;</a>
<a name="ln1165">      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;</a>
<a name="ln1166">      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;</a>
<a name="ln1167">      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;</a>
<a name="ln1168"> </a>
<a name="ln1169">      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;</a>
<a name="ln1170">      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;</a>
<a name="ln1171">      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;</a>
<a name="ln1172">      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm</a>
<a name="ln1173">       = denorm_absent;</a>
<a name="ln1174">      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;</a>
<a name="ln1175"> </a>
<a name="ln1176">      static _GLIBCXX_CONSTEXPR long</a>
<a name="ln1177">      infinity() _GLIBCXX_USE_NOEXCEPT { return static_cast&lt;long&gt;(0); }</a>
<a name="ln1178"> </a>
<a name="ln1179">      static _GLIBCXX_CONSTEXPR long</a>
<a name="ln1180">      quiet_NaN() _GLIBCXX_USE_NOEXCEPT { return static_cast&lt;long&gt;(0); }</a>
<a name="ln1181"> </a>
<a name="ln1182">      static _GLIBCXX_CONSTEXPR long</a>
<a name="ln1183">      signaling_NaN() _GLIBCXX_USE_NOEXCEPT { return static_cast&lt;long&gt;(0); }</a>
<a name="ln1184"> </a>
<a name="ln1185">      static _GLIBCXX_CONSTEXPR long</a>
<a name="ln1186">      denorm_min() _GLIBCXX_USE_NOEXCEPT { return static_cast&lt;long&gt;(0); }</a>
<a name="ln1187"> </a>
<a name="ln1188">      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;</a>
<a name="ln1189">      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;</a>
<a name="ln1190">      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = false;</a>
<a name="ln1191"> </a>
<a name="ln1192">      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;</a>
<a name="ln1193">      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;</a>
<a name="ln1194">      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style</a>
<a name="ln1195">       = round_toward_zero;</a>
<a name="ln1196">    };</a>
<a name="ln1197"> </a>
<a name="ln1198">  /// numeric_limits&lt;unsigned long&gt; specialization.</a>
<a name="ln1199">  template&lt;&gt;</a>
<a name="ln1200">    struct numeric_limits&lt;unsigned long&gt;</a>
<a name="ln1201">    {</a>
<a name="ln1202">      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;</a>
<a name="ln1203"> </a>
<a name="ln1204">      static _GLIBCXX_CONSTEXPR unsigned long</a>
<a name="ln1205">      min() _GLIBCXX_USE_NOEXCEPT { return 0; }</a>
<a name="ln1206"> </a>
<a name="ln1207">      static _GLIBCXX_CONSTEXPR unsigned long</a>
<a name="ln1208">      max() _GLIBCXX_USE_NOEXCEPT { return __LONG_MAX__ * 2UL + 1; }</a>
<a name="ln1209"> </a>
<a name="ln1210">#if __cplusplus &gt;= 201103L</a>
<a name="ln1211">      static constexpr unsigned long</a>
<a name="ln1212">      lowest() noexcept { return min(); }</a>
<a name="ln1213">#endif</a>
<a name="ln1214"> </a>
<a name="ln1215">      static _GLIBCXX_USE_CONSTEXPR int digits</a>
<a name="ln1216">       = __glibcxx_digits (unsigned long);</a>
<a name="ln1217">      static _GLIBCXX_USE_CONSTEXPR int digits10</a>
<a name="ln1218">       = __glibcxx_digits10 (unsigned long);</a>
<a name="ln1219">#if __cplusplus &gt;= 201103L</a>
<a name="ln1220">      static constexpr int max_digits10 = 0;</a>
<a name="ln1221">#endif</a>
<a name="ln1222">      static _GLIBCXX_USE_CONSTEXPR bool is_signed = false;</a>
<a name="ln1223">      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;</a>
<a name="ln1224">      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;</a>
<a name="ln1225">      static _GLIBCXX_USE_CONSTEXPR int radix = 2;</a>
<a name="ln1226"> </a>
<a name="ln1227">      static _GLIBCXX_CONSTEXPR unsigned long</a>
<a name="ln1228">      epsilon() _GLIBCXX_USE_NOEXCEPT { return 0; }</a>
<a name="ln1229"> </a>
<a name="ln1230">      static _GLIBCXX_CONSTEXPR unsigned long</a>
<a name="ln1231">      round_error() _GLIBCXX_USE_NOEXCEPT { return 0; }</a>
<a name="ln1232"> </a>
<a name="ln1233">      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;</a>
<a name="ln1234">      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;</a>
<a name="ln1235">      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;</a>
<a name="ln1236">      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;</a>
<a name="ln1237"> </a>
<a name="ln1238">      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;</a>
<a name="ln1239">      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;</a>
<a name="ln1240">      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;</a>
<a name="ln1241">      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm</a>
<a name="ln1242">       = denorm_absent;</a>
<a name="ln1243">      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;</a>
<a name="ln1244"> </a>
<a name="ln1245">      static _GLIBCXX_CONSTEXPR unsigned long</a>
<a name="ln1246">      infinity() _GLIBCXX_USE_NOEXCEPT</a>
<a name="ln1247">      { return static_cast&lt;unsigned long&gt;(0); }</a>
<a name="ln1248"> </a>
<a name="ln1249">      static _GLIBCXX_CONSTEXPR unsigned long</a>
<a name="ln1250">      quiet_NaN() _GLIBCXX_USE_NOEXCEPT</a>
<a name="ln1251">      { return static_cast&lt;unsigned long&gt;(0); }</a>
<a name="ln1252"> </a>
<a name="ln1253">      static _GLIBCXX_CONSTEXPR unsigned long</a>
<a name="ln1254">      signaling_NaN() _GLIBCXX_USE_NOEXCEPT</a>
<a name="ln1255">      { return static_cast&lt;unsigned long&gt;(0); }</a>
<a name="ln1256"> </a>
<a name="ln1257">      static _GLIBCXX_CONSTEXPR unsigned long</a>
<a name="ln1258">      denorm_min() _GLIBCXX_USE_NOEXCEPT</a>
<a name="ln1259">      { return static_cast&lt;unsigned long&gt;(0); }</a>
<a name="ln1260"> </a>
<a name="ln1261">      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;</a>
<a name="ln1262">      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;</a>
<a name="ln1263">      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = true;</a>
<a name="ln1264"> </a>
<a name="ln1265">      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;</a>
<a name="ln1266">      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;</a>
<a name="ln1267">      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style</a>
<a name="ln1268">       = round_toward_zero;</a>
<a name="ln1269">    };</a>
<a name="ln1270"> </a>
<a name="ln1271">  /// numeric_limits&lt;long long&gt; specialization.</a>
<a name="ln1272">  template&lt;&gt;</a>
<a name="ln1273">    struct numeric_limits&lt;long long&gt;</a>
<a name="ln1274">    {</a>
<a name="ln1275">      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;</a>
<a name="ln1276"> </a>
<a name="ln1277">      static _GLIBCXX_CONSTEXPR long long</a>
<a name="ln1278">      min() _GLIBCXX_USE_NOEXCEPT { return -__LONG_LONG_MAX__ - 1; }</a>
<a name="ln1279"> </a>
<a name="ln1280">      static _GLIBCXX_CONSTEXPR long long</a>
<a name="ln1281">      max() _GLIBCXX_USE_NOEXCEPT { return __LONG_LONG_MAX__; }</a>
<a name="ln1282"> </a>
<a name="ln1283">#if __cplusplus &gt;= 201103L</a>
<a name="ln1284">      static constexpr long long</a>
<a name="ln1285">      lowest() noexcept { return min(); }</a>
<a name="ln1286">#endif</a>
<a name="ln1287"> </a>
<a name="ln1288">      static _GLIBCXX_USE_CONSTEXPR int digits</a>
<a name="ln1289">       = __glibcxx_digits (long long);</a>
<a name="ln1290">      static _GLIBCXX_USE_CONSTEXPR int digits10</a>
<a name="ln1291">       = __glibcxx_digits10 (long long);</a>
<a name="ln1292">#if __cplusplus &gt;= 201103L</a>
<a name="ln1293">      static constexpr int max_digits10 = 0;</a>
<a name="ln1294">#endif</a>
<a name="ln1295">      static _GLIBCXX_USE_CONSTEXPR bool is_signed = true;</a>
<a name="ln1296">      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;</a>
<a name="ln1297">      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;</a>
<a name="ln1298">      static _GLIBCXX_USE_CONSTEXPR int radix = 2;</a>
<a name="ln1299"> </a>
<a name="ln1300">      static _GLIBCXX_CONSTEXPR long long</a>
<a name="ln1301">      epsilon() _GLIBCXX_USE_NOEXCEPT { return 0; }</a>
<a name="ln1302"> </a>
<a name="ln1303">      static _GLIBCXX_CONSTEXPR long long</a>
<a name="ln1304">      round_error() _GLIBCXX_USE_NOEXCEPT { return 0; }</a>
<a name="ln1305"> </a>
<a name="ln1306">      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;</a>
<a name="ln1307">      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;</a>
<a name="ln1308">      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;</a>
<a name="ln1309">      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;</a>
<a name="ln1310"> </a>
<a name="ln1311">      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;</a>
<a name="ln1312">      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;</a>
<a name="ln1313">      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;</a>
<a name="ln1314">      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm</a>
<a name="ln1315">       = denorm_absent;</a>
<a name="ln1316">      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;</a>
<a name="ln1317"> </a>
<a name="ln1318">      static _GLIBCXX_CONSTEXPR long long</a>
<a name="ln1319">      infinity() _GLIBCXX_USE_NOEXCEPT { return static_cast&lt;long long&gt;(0); }</a>
<a name="ln1320"> </a>
<a name="ln1321">      static _GLIBCXX_CONSTEXPR long long</a>
<a name="ln1322">      quiet_NaN() _GLIBCXX_USE_NOEXCEPT { return static_cast&lt;long long&gt;(0); }</a>
<a name="ln1323"> </a>
<a name="ln1324">      static _GLIBCXX_CONSTEXPR long long</a>
<a name="ln1325">      signaling_NaN() _GLIBCXX_USE_NOEXCEPT</a>
<a name="ln1326">      { return static_cast&lt;long long&gt;(0); }</a>
<a name="ln1327"> </a>
<a name="ln1328">      static _GLIBCXX_CONSTEXPR long long</a>
<a name="ln1329">      denorm_min() _GLIBCXX_USE_NOEXCEPT { return static_cast&lt;long long&gt;(0); }</a>
<a name="ln1330"> </a>
<a name="ln1331">      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;</a>
<a name="ln1332">      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;</a>
<a name="ln1333">      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = false;</a>
<a name="ln1334"> </a>
<a name="ln1335">      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;</a>
<a name="ln1336">      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;</a>
<a name="ln1337">      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style</a>
<a name="ln1338">       = round_toward_zero;</a>
<a name="ln1339">    };</a>
<a name="ln1340"> </a>
<a name="ln1341">  /// numeric_limits&lt;unsigned long long&gt; specialization.</a>
<a name="ln1342">  template&lt;&gt;</a>
<a name="ln1343">    struct numeric_limits&lt;unsigned long long&gt;</a>
<a name="ln1344">    {</a>
<a name="ln1345">      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;</a>
<a name="ln1346"> </a>
<a name="ln1347">      static _GLIBCXX_CONSTEXPR unsigned long long</a>
<a name="ln1348">      min() _GLIBCXX_USE_NOEXCEPT { return 0; }</a>
<a name="ln1349"> </a>
<a name="ln1350">      static _GLIBCXX_CONSTEXPR unsigned long long</a>
<a name="ln1351">      max() _GLIBCXX_USE_NOEXCEPT { return __LONG_LONG_MAX__ * 2ULL + 1; }</a>
<a name="ln1352"> </a>
<a name="ln1353">#if __cplusplus &gt;= 201103L</a>
<a name="ln1354">      static constexpr unsigned long long</a>
<a name="ln1355">      lowest() noexcept { return min(); }</a>
<a name="ln1356">#endif</a>
<a name="ln1357"> </a>
<a name="ln1358">      static _GLIBCXX_USE_CONSTEXPR int digits</a>
<a name="ln1359">       = __glibcxx_digits (unsigned long long);</a>
<a name="ln1360">      static _GLIBCXX_USE_CONSTEXPR int digits10</a>
<a name="ln1361">       = __glibcxx_digits10 (unsigned long long);</a>
<a name="ln1362">#if __cplusplus &gt;= 201103L</a>
<a name="ln1363">      static constexpr int max_digits10 = 0;</a>
<a name="ln1364">#endif</a>
<a name="ln1365">      static _GLIBCXX_USE_CONSTEXPR bool is_signed = false;</a>
<a name="ln1366">      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;</a>
<a name="ln1367">      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;</a>
<a name="ln1368">      static _GLIBCXX_USE_CONSTEXPR int radix = 2;</a>
<a name="ln1369"> </a>
<a name="ln1370">      static _GLIBCXX_CONSTEXPR unsigned long long</a>
<a name="ln1371">      epsilon() _GLIBCXX_USE_NOEXCEPT { return 0; }</a>
<a name="ln1372"> </a>
<a name="ln1373">      static _GLIBCXX_CONSTEXPR unsigned long long</a>
<a name="ln1374">      round_error() _GLIBCXX_USE_NOEXCEPT { return 0; }</a>
<a name="ln1375"> </a>
<a name="ln1376">      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;</a>
<a name="ln1377">      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;</a>
<a name="ln1378">      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;</a>
<a name="ln1379">      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;</a>
<a name="ln1380"> </a>
<a name="ln1381">      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;</a>
<a name="ln1382">      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;</a>
<a name="ln1383">      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;</a>
<a name="ln1384">      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm</a>
<a name="ln1385">       = denorm_absent;</a>
<a name="ln1386">      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;</a>
<a name="ln1387"> </a>
<a name="ln1388">      static _GLIBCXX_CONSTEXPR unsigned long long</a>
<a name="ln1389">      infinity() _GLIBCXX_USE_NOEXCEPT</a>
<a name="ln1390">      { return static_cast&lt;unsigned long long&gt;(0); }</a>
<a name="ln1391"> </a>
<a name="ln1392">      static _GLIBCXX_CONSTEXPR unsigned long long</a>
<a name="ln1393">      quiet_NaN() _GLIBCXX_USE_NOEXCEPT</a>
<a name="ln1394">      { return static_cast&lt;unsigned long long&gt;(0); }</a>
<a name="ln1395"> </a>
<a name="ln1396">      static _GLIBCXX_CONSTEXPR unsigned long long</a>
<a name="ln1397">      signaling_NaN() _GLIBCXX_USE_NOEXCEPT</a>
<a name="ln1398">      { return static_cast&lt;unsigned long long&gt;(0); }</a>
<a name="ln1399"> </a>
<a name="ln1400">      static _GLIBCXX_CONSTEXPR unsigned long long</a>
<a name="ln1401">      denorm_min() _GLIBCXX_USE_NOEXCEPT</a>
<a name="ln1402">      { return static_cast&lt;unsigned long long&gt;(0); }</a>
<a name="ln1403"> </a>
<a name="ln1404">      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;</a>
<a name="ln1405">      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;</a>
<a name="ln1406">      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = true;</a>
<a name="ln1407"> </a>
<a name="ln1408">      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;</a>
<a name="ln1409">      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;</a>
<a name="ln1410">      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style</a>
<a name="ln1411">       = round_toward_zero;</a>
<a name="ln1412">    };</a>
<a name="ln1413"> </a>
<a name="ln1414">#if !defined(__STRICT_ANSI__)</a>
<a name="ln1415"> </a>
<a name="ln1416">#define __INT_N(TYPE, BITSIZE, EXT, UEXT)			\</a>
<a name="ln1417">  template&lt;&gt; 									\</a>
<a name="ln1418">    struct numeric_limits&lt;TYPE&gt; 						\</a>
<a name="ln1419">    { 										\</a>
<a name="ln1420">      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true; 		\</a>
<a name="ln1421"> 										\</a>
<a name="ln1422">      static _GLIBCXX_CONSTEXPR TYPE 						\</a>
<a name="ln1423">	min() _GLIBCXX_USE_NOEXCEPT { return __glibcxx_min_b (TYPE, BITSIZE); } \</a>
<a name="ln1424"> 										\</a>
<a name="ln1425">      static _GLIBCXX_CONSTEXPR TYPE 						\</a>
<a name="ln1426">      max() _GLIBCXX_USE_NOEXCEPT { return __glibcxx_max_b (TYPE, BITSIZE); } 	\</a>
<a name="ln1427"> 										\</a>
<a name="ln1428">      static _GLIBCXX_USE_CONSTEXPR int digits 					\</a>
<a name="ln1429">       = BITSIZE - 1; 								\</a>
<a name="ln1430">      static _GLIBCXX_USE_CONSTEXPR int digits10 				\</a>
<a name="ln1431">       = (BITSIZE - 1) * 643L / 2136; 						\</a>
<a name="ln1432">      										\</a>
<a name="ln1433">      static _GLIBCXX_USE_CONSTEXPR bool is_signed = true; 			\</a>
<a name="ln1434">      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true; 			\</a>
<a name="ln1435">      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true; 			\</a>
<a name="ln1436">      static _GLIBCXX_USE_CONSTEXPR int radix = 2; 				\</a>
<a name="ln1437"> 										\</a>
<a name="ln1438">      static _GLIBCXX_CONSTEXPR TYPE 						\</a>
<a name="ln1439">      epsilon() _GLIBCXX_USE_NOEXCEPT { return 0; } 				\</a>
<a name="ln1440"> 										\</a>
<a name="ln1441">      static _GLIBCXX_CONSTEXPR TYPE 						\</a>
<a name="ln1442">      round_error() _GLIBCXX_USE_NOEXCEPT { return 0; } 			\</a>
<a name="ln1443"> 										\</a>
<a name="ln1444">      EXT									\</a>
<a name="ln1445"> 										\</a>
<a name="ln1446">      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0; 			\</a>
<a name="ln1447">      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0; 			\</a>
<a name="ln1448">      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0; 			\</a>
<a name="ln1449">      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0; 			\</a>
<a name="ln1450"> 										\</a>
<a name="ln1451">      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false; 			\</a>
<a name="ln1452">      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false; 		\</a>
<a name="ln1453">      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false; 		\</a>
<a name="ln1454">      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm 		\</a>
<a name="ln1455">       = denorm_absent; 							\</a>
<a name="ln1456">      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false; 		\</a>
<a name="ln1457"> 										\</a>
<a name="ln1458">      static _GLIBCXX_CONSTEXPR TYPE 						\</a>
<a name="ln1459">      infinity() _GLIBCXX_USE_NOEXCEPT 						\</a>
<a name="ln1460">      { return static_cast&lt;TYPE&gt;(0); } 						\</a>
<a name="ln1461"> 										\</a>
<a name="ln1462">      static _GLIBCXX_CONSTEXPR TYPE 						\</a>
<a name="ln1463">      quiet_NaN() _GLIBCXX_USE_NOEXCEPT 					\</a>
<a name="ln1464">      { return static_cast&lt;TYPE&gt;(0); } 						\</a>
<a name="ln1465">       										\</a>
<a name="ln1466">      static _GLIBCXX_CONSTEXPR TYPE 						\</a>
<a name="ln1467">      signaling_NaN() _GLIBCXX_USE_NOEXCEPT 					\</a>
<a name="ln1468">      { return static_cast&lt;TYPE&gt;(0); } 						\</a>
<a name="ln1469">       										\</a>
<a name="ln1470">      static _GLIBCXX_CONSTEXPR TYPE 						\</a>
<a name="ln1471">      denorm_min() _GLIBCXX_USE_NOEXCEPT 					\</a>
<a name="ln1472">      { return static_cast&lt;TYPE&gt;(0); } 						\</a>
<a name="ln1473"> 										\</a>
<a name="ln1474">      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false; 			\</a>
<a name="ln1475">      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true; 			\</a>
<a name="ln1476">      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = false; 			\</a>
<a name="ln1477"> 										\</a>
<a name="ln1478">      static _GLIBCXX_USE_CONSTEXPR bool traps 					\</a>
<a name="ln1479">       = __glibcxx_integral_traps; 						\</a>
<a name="ln1480">      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false; 		\</a>
<a name="ln1481">      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style 		\</a>
<a name="ln1482">       = round_toward_zero; 							\</a>
<a name="ln1483">    }; 										\</a>
<a name="ln1484"> 										\</a>
<a name="ln1485">  template&lt;&gt; 									\</a>
<a name="ln1486">    struct numeric_limits&lt;unsigned TYPE&gt; 					\</a>
<a name="ln1487">    { 										\</a>
<a name="ln1488">      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true; 		\</a>
<a name="ln1489"> 										\</a>
<a name="ln1490">      static _GLIBCXX_CONSTEXPR unsigned TYPE 					\</a>
<a name="ln1491">      min() _GLIBCXX_USE_NOEXCEPT { return 0; } 				\</a>
<a name="ln1492"> 										\</a>
<a name="ln1493">      static _GLIBCXX_CONSTEXPR unsigned TYPE 					\</a>
<a name="ln1494">      max() _GLIBCXX_USE_NOEXCEPT						\</a>
<a name="ln1495">      { return  __glibcxx_max_b (unsigned TYPE, BITSIZE); }			\</a>
<a name="ln1496"> 										\</a>
<a name="ln1497">      UEXT									\</a>
<a name="ln1498"> 										\</a>
<a name="ln1499">      static _GLIBCXX_USE_CONSTEXPR int digits 					\</a>
<a name="ln1500">       = BITSIZE; 								\</a>
<a name="ln1501">      static _GLIBCXX_USE_CONSTEXPR int digits10 				\</a>
<a name="ln1502">       = BITSIZE * 643L / 2136; 						\</a>
<a name="ln1503">      static _GLIBCXX_USE_CONSTEXPR bool is_signed = false; 			\</a>
<a name="ln1504">      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true; 			\</a>
<a name="ln1505">      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true; 			\</a>
<a name="ln1506">      static _GLIBCXX_USE_CONSTEXPR int radix = 2; 				\</a>
<a name="ln1507"> 										\</a>
<a name="ln1508">      static _GLIBCXX_CONSTEXPR unsigned TYPE 					\</a>
<a name="ln1509">      epsilon() _GLIBCXX_USE_NOEXCEPT { return 0; } 				\</a>
<a name="ln1510"> 										\</a>
<a name="ln1511">      static _GLIBCXX_CONSTEXPR unsigned TYPE 					\</a>
<a name="ln1512">      round_error() _GLIBCXX_USE_NOEXCEPT { return 0; } 			\</a>
<a name="ln1513"> 										\</a>
<a name="ln1514">      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0; 			\</a>
<a name="ln1515">      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0; 			\</a>
<a name="ln1516">      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0; 			\</a>
<a name="ln1517">      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0; 			\</a>
<a name="ln1518"> 										\</a>
<a name="ln1519">      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false; 			\</a>
<a name="ln1520">      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false; 		\</a>
<a name="ln1521">      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false; 		\</a>
<a name="ln1522">      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm 		\</a>
<a name="ln1523">       = denorm_absent; 							\</a>
<a name="ln1524">      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false; 		\</a>
<a name="ln1525"> 										\</a>
<a name="ln1526">      static _GLIBCXX_CONSTEXPR unsigned TYPE 					\</a>
<a name="ln1527">      infinity() _GLIBCXX_USE_NOEXCEPT 						\</a>
<a name="ln1528">      { return static_cast&lt;unsigned TYPE&gt;(0); } 				\</a>
<a name="ln1529"> 										\</a>
<a name="ln1530">      static _GLIBCXX_CONSTEXPR unsigned TYPE 					\</a>
<a name="ln1531">      quiet_NaN() _GLIBCXX_USE_NOEXCEPT 					\</a>
<a name="ln1532">      { return static_cast&lt;unsigned TYPE&gt;(0); } 				\</a>
<a name="ln1533"> 										\</a>
<a name="ln1534">      static _GLIBCXX_CONSTEXPR unsigned TYPE 					\</a>
<a name="ln1535">      signaling_NaN() _GLIBCXX_USE_NOEXCEPT 					\</a>
<a name="ln1536">      { return static_cast&lt;unsigned TYPE&gt;(0); } 				\</a>
<a name="ln1537"> 										\</a>
<a name="ln1538">      static _GLIBCXX_CONSTEXPR unsigned TYPE 					\</a>
<a name="ln1539">      denorm_min() _GLIBCXX_USE_NOEXCEPT 					\</a>
<a name="ln1540">      { return static_cast&lt;unsigned TYPE&gt;(0); } 				\</a>
<a name="ln1541"> 										\</a>
<a name="ln1542">      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false; 			\</a>
<a name="ln1543">      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true; 			\</a>
<a name="ln1544">      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = true; 			\</a>
<a name="ln1545"> 										\</a>
<a name="ln1546">      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps; 	\</a>
<a name="ln1547">      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false; 		\</a>
<a name="ln1548">      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style 		\</a>
<a name="ln1549">       = round_toward_zero; 							\</a>
<a name="ln1550">    };</a>
<a name="ln1551"> </a>
<a name="ln1552">#if __cplusplus &gt;= 201103L</a>
<a name="ln1553"> </a>
<a name="ln1554">#define __INT_N_201103(TYPE)							\</a>
<a name="ln1555">      static constexpr TYPE 							\</a>
<a name="ln1556">      lowest() noexcept { return min(); }					\</a>
<a name="ln1557">      static constexpr int max_digits10 = 0;</a>
<a name="ln1558"> </a>
<a name="ln1559">#define __INT_N_U201103(TYPE)							\</a>
<a name="ln1560">      static constexpr unsigned TYPE 						\</a>
<a name="ln1561">      lowest() noexcept { return min(); }					\</a>
<a name="ln1562">      static constexpr int max_digits10 = 0;</a>
<a name="ln1563"> </a>
<a name="ln1564">#else</a>
<a name="ln1565">#define __INT_N_201103(TYPE)</a>
<a name="ln1566">#define __INT_N_U201103(TYPE)</a>
<a name="ln1567">#endif</a>
<a name="ln1568"> </a>
<a name="ln1569">#ifdef __GLIBCXX_TYPE_INT_N_0</a>
<a name="ln1570">  __INT_N(__GLIBCXX_TYPE_INT_N_0, __GLIBCXX_BITSIZE_INT_N_0,</a>
<a name="ln1571">	  __INT_N_201103 (__GLIBCXX_TYPE_INT_N_0), __INT_N_U201103 (__GLIBCXX_TYPE_INT_N_0))</a>
<a name="ln1572">#endif</a>
<a name="ln1573">#ifdef __GLIBCXX_TYPE_INT_N_1</a>
<a name="ln1574">  __INT_N (__GLIBCXX_TYPE_INT_N_1, __GLIBCXX_BITSIZE_INT_N_1,</a>
<a name="ln1575">	  __INT_N_201103 (__GLIBCXX_TYPE_INT_N_1), __INT_N_U201103 (__GLIBCXX_TYPE_INT_N_1))</a>
<a name="ln1576">#endif</a>
<a name="ln1577">#ifdef __GLIBCXX_TYPE_INT_N_2</a>
<a name="ln1578">  __INT_N (__GLIBCXX_TYPE_INT_N_2, __GLIBCXX_BITSIZE_INT_N_2,</a>
<a name="ln1579">	  __INT_N_201103 (__GLIBCXX_TYPE_INT_N_2), __INT_N_U201103 (__GLIBCXX_TYPE_INT_N_2))</a>
<a name="ln1580">#endif</a>
<a name="ln1581">#ifdef __GLIBCXX_TYPE_INT_N_3</a>
<a name="ln1582">  __INT_N (__GLIBCXX_TYPE_INT_N_3, __GLIBCXX_BITSIZE_INT_N_3,</a>
<a name="ln1583">	  __INT_N_201103 (__GLIBCXX_TYPE_INT_N_3), __INT_N_U201103 (__GLIBCXX_TYPE_INT_N_3))</a>
<a name="ln1584">#endif</a>
<a name="ln1585"> </a>
<a name="ln1586">#undef __INT_N</a>
<a name="ln1587">#undef __INT_N_201103</a>
<a name="ln1588">#undef __INT_N_U201103</a>
<a name="ln1589"> </a>
<a name="ln1590">#endif</a>
<a name="ln1591"> </a>
<a name="ln1592">  /// numeric_limits&lt;float&gt; specialization.</a>
<a name="ln1593">  template&lt;&gt;</a>
<a name="ln1594">    struct numeric_limits&lt;float&gt;</a>
<a name="ln1595">    {</a>
<a name="ln1596">      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;</a>
<a name="ln1597"> </a>
<a name="ln1598">      static _GLIBCXX_CONSTEXPR float</a>
<a name="ln1599">      min() _GLIBCXX_USE_NOEXCEPT { return __FLT_MIN__; }</a>
<a name="ln1600"> </a>
<a name="ln1601">      static _GLIBCXX_CONSTEXPR float</a>
<a name="ln1602">      max() _GLIBCXX_USE_NOEXCEPT { return __FLT_MAX__; }</a>
<a name="ln1603"> </a>
<a name="ln1604">#if __cplusplus &gt;= 201103L</a>
<a name="ln1605">      static constexpr float</a>
<a name="ln1606">      lowest() noexcept { return -__FLT_MAX__; }</a>
<a name="ln1607">#endif</a>
<a name="ln1608"> </a>
<a name="ln1609">      static _GLIBCXX_USE_CONSTEXPR int digits = __FLT_MANT_DIG__;</a>
<a name="ln1610">      static _GLIBCXX_USE_CONSTEXPR int digits10 = __FLT_DIG__;</a>
<a name="ln1611">#if __cplusplus &gt;= 201103L</a>
<a name="ln1612">      static constexpr int max_digits10</a>
<a name="ln1613">	 = __glibcxx_max_digits10 (__FLT_MANT_DIG__);</a>
<a name="ln1614">#endif</a>
<a name="ln1615">      static _GLIBCXX_USE_CONSTEXPR bool is_signed = true;</a>
<a name="ln1616">      static _GLIBCXX_USE_CONSTEXPR bool is_integer = false;</a>
<a name="ln1617">      static _GLIBCXX_USE_CONSTEXPR bool is_exact = false;</a>
<a name="ln1618">      static _GLIBCXX_USE_CONSTEXPR int radix = __FLT_RADIX__;</a>
<a name="ln1619"> </a>
<a name="ln1620">      static _GLIBCXX_CONSTEXPR float</a>
<a name="ln1621">      epsilon() _GLIBCXX_USE_NOEXCEPT { return __FLT_EPSILON__; }</a>
<a name="ln1622"> </a>
<a name="ln1623">      static _GLIBCXX_CONSTEXPR float</a>
<a name="ln1624">      round_error() _GLIBCXX_USE_NOEXCEPT { return 0.5F; }</a>
<a name="ln1625"> </a>
<a name="ln1626">      static _GLIBCXX_USE_CONSTEXPR int min_exponent = __FLT_MIN_EXP__;</a>
<a name="ln1627">      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = __FLT_MIN_10_EXP__;</a>
<a name="ln1628">      static _GLIBCXX_USE_CONSTEXPR int max_exponent = __FLT_MAX_EXP__;</a>
<a name="ln1629">      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = __FLT_MAX_10_EXP__;</a>
<a name="ln1630"> </a>
<a name="ln1631">      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = __FLT_HAS_INFINITY__;</a>
<a name="ln1632">      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = __FLT_HAS_QUIET_NAN__;</a>
<a name="ln1633">      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = has_quiet_NaN;</a>
<a name="ln1634">      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm</a>
<a name="ln1635">	= bool(__FLT_HAS_DENORM__) ? denorm_present : denorm_absent;</a>
<a name="ln1636">      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss</a>
<a name="ln1637">       = __glibcxx_float_has_denorm_loss;</a>
<a name="ln1638"> </a>
<a name="ln1639">      static _GLIBCXX_CONSTEXPR float</a>
<a name="ln1640">      infinity() _GLIBCXX_USE_NOEXCEPT { return __builtin_huge_valf(); }</a>
<a name="ln1641"> </a>
<a name="ln1642">      static _GLIBCXX_CONSTEXPR float</a>
<a name="ln1643">      quiet_NaN() _GLIBCXX_USE_NOEXCEPT { return __builtin_nanf(&quot;&quot;); }</a>
<a name="ln1644"> </a>
<a name="ln1645">      static _GLIBCXX_CONSTEXPR float</a>
<a name="ln1646">      signaling_NaN() _GLIBCXX_USE_NOEXCEPT { return __builtin_nansf(&quot;&quot;); }</a>
<a name="ln1647"> </a>
<a name="ln1648">      static _GLIBCXX_CONSTEXPR float</a>
<a name="ln1649">      denorm_min() _GLIBCXX_USE_NOEXCEPT { return __FLT_DENORM_MIN__; }</a>
<a name="ln1650"> </a>
<a name="ln1651">      static _GLIBCXX_USE_CONSTEXPR bool is_iec559</a>
<a name="ln1652">	= has_infinity &amp;&amp; has_quiet_NaN &amp;&amp; has_denorm == denorm_present;</a>
<a name="ln1653">      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;</a>
<a name="ln1654">      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = false;</a>
<a name="ln1655"> </a>
<a name="ln1656">      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_float_traps;</a>
<a name="ln1657">      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before</a>
<a name="ln1658">       = __glibcxx_float_tinyness_before;</a>
<a name="ln1659">      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style</a>
<a name="ln1660">       = round_to_nearest;</a>
<a name="ln1661">    };</a>
<a name="ln1662"> </a>
<a name="ln1663">#undef __glibcxx_float_has_denorm_loss</a>
<a name="ln1664">#undef __glibcxx_float_traps</a>
<a name="ln1665">#undef __glibcxx_float_tinyness_before</a>
<a name="ln1666"> </a>
<a name="ln1667">  /// numeric_limits&lt;double&gt; specialization.</a>
<a name="ln1668">  template&lt;&gt;</a>
<a name="ln1669">    struct numeric_limits&lt;double&gt;</a>
<a name="ln1670">    {</a>
<a name="ln1671">      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;</a>
<a name="ln1672"> </a>
<a name="ln1673">      static _GLIBCXX_CONSTEXPR double</a>
<a name="ln1674">      min() _GLIBCXX_USE_NOEXCEPT { return __DBL_MIN__; }</a>
<a name="ln1675"> </a>
<a name="ln1676">      static _GLIBCXX_CONSTEXPR double</a>
<a name="ln1677">      max() _GLIBCXX_USE_NOEXCEPT { return __DBL_MAX__; }</a>
<a name="ln1678"> </a>
<a name="ln1679">#if __cplusplus &gt;= 201103L</a>
<a name="ln1680">      static constexpr double</a>
<a name="ln1681">      lowest() noexcept { return -__DBL_MAX__; }</a>
<a name="ln1682">#endif</a>
<a name="ln1683"> </a>
<a name="ln1684">      static _GLIBCXX_USE_CONSTEXPR int digits = __DBL_MANT_DIG__;</a>
<a name="ln1685">      static _GLIBCXX_USE_CONSTEXPR int digits10 = __DBL_DIG__;</a>
<a name="ln1686">#if __cplusplus &gt;= 201103L</a>
<a name="ln1687">      static constexpr int max_digits10</a>
<a name="ln1688">	 = __glibcxx_max_digits10 (__DBL_MANT_DIG__);</a>
<a name="ln1689">#endif</a>
<a name="ln1690">      static _GLIBCXX_USE_CONSTEXPR bool is_signed = true;</a>
<a name="ln1691">      static _GLIBCXX_USE_CONSTEXPR bool is_integer = false;</a>
<a name="ln1692">      static _GLIBCXX_USE_CONSTEXPR bool is_exact = false;</a>
<a name="ln1693">      static _GLIBCXX_USE_CONSTEXPR int radix = __FLT_RADIX__;</a>
<a name="ln1694"> </a>
<a name="ln1695">      static _GLIBCXX_CONSTEXPR double</a>
<a name="ln1696">      epsilon() _GLIBCXX_USE_NOEXCEPT { return __DBL_EPSILON__; }</a>
<a name="ln1697"> </a>
<a name="ln1698">      static _GLIBCXX_CONSTEXPR double</a>
<a name="ln1699">      round_error() _GLIBCXX_USE_NOEXCEPT { return 0.5; }</a>
<a name="ln1700"> </a>
<a name="ln1701">      static _GLIBCXX_USE_CONSTEXPR int min_exponent = __DBL_MIN_EXP__;</a>
<a name="ln1702">      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = __DBL_MIN_10_EXP__;</a>
<a name="ln1703">      static _GLIBCXX_USE_CONSTEXPR int max_exponent = __DBL_MAX_EXP__;</a>
<a name="ln1704">      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = __DBL_MAX_10_EXP__;</a>
<a name="ln1705"> </a>
<a name="ln1706">      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = __DBL_HAS_INFINITY__;</a>
<a name="ln1707">      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = __DBL_HAS_QUIET_NAN__;</a>
<a name="ln1708">      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = has_quiet_NaN;</a>
<a name="ln1709">      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm</a>
<a name="ln1710">	= bool(__DBL_HAS_DENORM__) ? denorm_present : denorm_absent;</a>
<a name="ln1711">      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss</a>
<a name="ln1712">        = __glibcxx_double_has_denorm_loss;</a>
<a name="ln1713"> </a>
<a name="ln1714">      static _GLIBCXX_CONSTEXPR double</a>
<a name="ln1715">      infinity() _GLIBCXX_USE_NOEXCEPT { return __builtin_huge_val(); }</a>
<a name="ln1716"> </a>
<a name="ln1717">      static _GLIBCXX_CONSTEXPR double</a>
<a name="ln1718">      quiet_NaN() _GLIBCXX_USE_NOEXCEPT { return __builtin_nan(&quot;&quot;); }</a>
<a name="ln1719"> </a>
<a name="ln1720">      static _GLIBCXX_CONSTEXPR double</a>
<a name="ln1721">      signaling_NaN() _GLIBCXX_USE_NOEXCEPT { return __builtin_nans(&quot;&quot;); }</a>
<a name="ln1722"> </a>
<a name="ln1723">      static _GLIBCXX_CONSTEXPR double</a>
<a name="ln1724">      denorm_min() _GLIBCXX_USE_NOEXCEPT { return __DBL_DENORM_MIN__; }</a>
<a name="ln1725"> </a>
<a name="ln1726">      static _GLIBCXX_USE_CONSTEXPR bool is_iec559</a>
<a name="ln1727">	= has_infinity &amp;&amp; has_quiet_NaN &amp;&amp; has_denorm == denorm_present;</a>
<a name="ln1728">      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;</a>
<a name="ln1729">      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = false;</a>
<a name="ln1730"> </a>
<a name="ln1731">      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_double_traps;</a>
<a name="ln1732">      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before</a>
<a name="ln1733">       = __glibcxx_double_tinyness_before;</a>
<a name="ln1734">      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style</a>
<a name="ln1735">       = round_to_nearest;</a>
<a name="ln1736">    };</a>
<a name="ln1737"> </a>
<a name="ln1738">#undef __glibcxx_double_has_denorm_loss</a>
<a name="ln1739">#undef __glibcxx_double_traps</a>
<a name="ln1740">#undef __glibcxx_double_tinyness_before</a>
<a name="ln1741"> </a>
<a name="ln1742">  /// numeric_limits&lt;long double&gt; specialization.</a>
<a name="ln1743">  template&lt;&gt;</a>
<a name="ln1744">    struct numeric_limits&lt;long double&gt;</a>
<a name="ln1745">    {</a>
<a name="ln1746">      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;</a>
<a name="ln1747"> </a>
<a name="ln1748">      static _GLIBCXX_CONSTEXPR long double</a>
<a name="ln1749">      min() _GLIBCXX_USE_NOEXCEPT { return __LDBL_MIN__; }</a>
<a name="ln1750"> </a>
<a name="ln1751">      static _GLIBCXX_CONSTEXPR long double</a>
<a name="ln1752">      max() _GLIBCXX_USE_NOEXCEPT { return __LDBL_MAX__; }</a>
<a name="ln1753"> </a>
<a name="ln1754">#if __cplusplus &gt;= 201103L</a>
<a name="ln1755">      static constexpr long double</a>
<a name="ln1756">      lowest() noexcept { return -__LDBL_MAX__; }</a>
<a name="ln1757">#endif</a>
<a name="ln1758"> </a>
<a name="ln1759">      static _GLIBCXX_USE_CONSTEXPR int digits = __LDBL_MANT_DIG__;</a>
<a name="ln1760">      static _GLIBCXX_USE_CONSTEXPR int digits10 = __LDBL_DIG__;</a>
<a name="ln1761">#if __cplusplus &gt;= 201103L</a>
<a name="ln1762">      static _GLIBCXX_USE_CONSTEXPR int max_digits10</a>
<a name="ln1763">	 = __glibcxx_max_digits10 (__LDBL_MANT_DIG__);</a>
<a name="ln1764">#endif</a>
<a name="ln1765">      static _GLIBCXX_USE_CONSTEXPR bool is_signed = true;</a>
<a name="ln1766">      static _GLIBCXX_USE_CONSTEXPR bool is_integer = false;</a>
<a name="ln1767">      static _GLIBCXX_USE_CONSTEXPR bool is_exact = false;</a>
<a name="ln1768">      static _GLIBCXX_USE_CONSTEXPR int radix = __FLT_RADIX__;</a>
<a name="ln1769"> </a>
<a name="ln1770">      static _GLIBCXX_CONSTEXPR long double</a>
<a name="ln1771">      epsilon() _GLIBCXX_USE_NOEXCEPT { return __LDBL_EPSILON__; }</a>
<a name="ln1772"> </a>
<a name="ln1773">      static _GLIBCXX_CONSTEXPR long double</a>
<a name="ln1774">      round_error() _GLIBCXX_USE_NOEXCEPT { return 0.5L; }</a>
<a name="ln1775"> </a>
<a name="ln1776">      static _GLIBCXX_USE_CONSTEXPR int min_exponent = __LDBL_MIN_EXP__;</a>
<a name="ln1777">      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = __LDBL_MIN_10_EXP__;</a>
<a name="ln1778">      static _GLIBCXX_USE_CONSTEXPR int max_exponent = __LDBL_MAX_EXP__;</a>
<a name="ln1779">      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = __LDBL_MAX_10_EXP__;</a>
<a name="ln1780"> </a>
<a name="ln1781">      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = __LDBL_HAS_INFINITY__;</a>
<a name="ln1782">      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = __LDBL_HAS_QUIET_NAN__;</a>
<a name="ln1783">      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = has_quiet_NaN;</a>
<a name="ln1784">      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm</a>
<a name="ln1785">	= bool(__LDBL_HAS_DENORM__) ? denorm_present : denorm_absent;</a>
<a name="ln1786">      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss</a>
<a name="ln1787">	= __glibcxx_long_double_has_denorm_loss;</a>
<a name="ln1788"> </a>
<a name="ln1789">      static _GLIBCXX_CONSTEXPR long double</a>
<a name="ln1790">      infinity() _GLIBCXX_USE_NOEXCEPT { return __builtin_huge_vall(); }</a>
<a name="ln1791"> </a>
<a name="ln1792">      static _GLIBCXX_CONSTEXPR long double</a>
<a name="ln1793">      quiet_NaN() _GLIBCXX_USE_NOEXCEPT { return __builtin_nanl(&quot;&quot;); }</a>
<a name="ln1794"> </a>
<a name="ln1795">      static _GLIBCXX_CONSTEXPR long double</a>
<a name="ln1796">      signaling_NaN() _GLIBCXX_USE_NOEXCEPT { return __builtin_nansl(&quot;&quot;); }</a>
<a name="ln1797"> </a>
<a name="ln1798">      static _GLIBCXX_CONSTEXPR long double</a>
<a name="ln1799">      denorm_min() _GLIBCXX_USE_NOEXCEPT { return __LDBL_DENORM_MIN__; }</a>
<a name="ln1800"> </a>
<a name="ln1801">      static _GLIBCXX_USE_CONSTEXPR bool is_iec559</a>
<a name="ln1802">	= has_infinity &amp;&amp; has_quiet_NaN &amp;&amp; has_denorm == denorm_present;</a>
<a name="ln1803">      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;</a>
<a name="ln1804">      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = false;</a>
<a name="ln1805"> </a>
<a name="ln1806">      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_long_double_traps;</a>
<a name="ln1807">      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before =</a>
<a name="ln1808">					 __glibcxx_long_double_tinyness_before;</a>
<a name="ln1809">      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style =</a>
<a name="ln1810">						      round_to_nearest;</a>
<a name="ln1811">    };</a>
<a name="ln1812"> </a>
<a name="ln1813">#undef __glibcxx_long_double_has_denorm_loss</a>
<a name="ln1814">#undef __glibcxx_long_double_traps</a>
<a name="ln1815">#undef __glibcxx_long_double_tinyness_before</a>
<a name="ln1816"> </a>
<a name="ln1817">_GLIBCXX_END_NAMESPACE_VERSION</a>
<a name="ln1818">} // namespace</a>
<a name="ln1819"> </a>
<a name="ln1820">#undef __glibcxx_signed</a>
<a name="ln1821">#undef __glibcxx_min</a>
<a name="ln1822">#undef __glibcxx_max</a>
<a name="ln1823">#undef __glibcxx_digits</a>
<a name="ln1824">#undef __glibcxx_digits10</a>
<a name="ln1825">#undef __glibcxx_max_digits10</a>
<a name="ln1826"> </a>
<a name="ln1827">#endif // _GLIBCXX_NUMERIC_LIMITS</a>

</code></pre>
<div class="balloon" rel="1652"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: has_denorm == denorm_present.</p></div>
<div class="balloon" rel="1727"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: has_denorm == denorm_present.</p></div>
<div class="balloon" rel="1802"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: has_denorm == denorm_present.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
