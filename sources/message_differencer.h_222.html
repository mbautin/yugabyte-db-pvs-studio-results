
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>message_differencer.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Protocol Buffers - Google's data interchange format</a>
<a name="ln2">// Copyright 2008 Google Inc.  All rights reserved.</a>
<a name="ln3">// https://developers.google.com/protocol-buffers/</a>
<a name="ln4">//</a>
<a name="ln5">// Redistribution and use in source and binary forms, with or without</a>
<a name="ln6">// modification, are permitted provided that the following conditions are</a>
<a name="ln7">// met:</a>
<a name="ln8">//</a>
<a name="ln9">//     * Redistributions of source code must retain the above copyright</a>
<a name="ln10">// notice, this list of conditions and the following disclaimer.</a>
<a name="ln11">//     * Redistributions in binary form must reproduce the above</a>
<a name="ln12">// copyright notice, this list of conditions and the following disclaimer</a>
<a name="ln13">// in the documentation and/or other materials provided with the</a>
<a name="ln14">// distribution.</a>
<a name="ln15">//     * Neither the name of Google Inc. nor the names of its</a>
<a name="ln16">// contributors may be used to endorse or promote products derived from</a>
<a name="ln17">// this software without specific prior written permission.</a>
<a name="ln18">//</a>
<a name="ln19">// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</a>
<a name="ln20">// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</a>
<a name="ln21">// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</a>
<a name="ln22">// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</a>
<a name="ln23">// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</a>
<a name="ln24">// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</a>
<a name="ln25">// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</a>
<a name="ln26">// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</a>
<a name="ln27">// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</a>
<a name="ln28">// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</a>
<a name="ln29">// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</a>
<a name="ln30"> </a>
<a name="ln31">// Author: jschorr@google.com (Joseph Schorr)</a>
<a name="ln32">//  Based on original Protocol Buffers design by</a>
<a name="ln33">//  Sanjay Ghemawat, Jeff Dean, and others.</a>
<a name="ln34">//</a>
<a name="ln35">// This file defines static methods and classes for comparing Protocol</a>
<a name="ln36">// Messages.</a>
<a name="ln37">//</a>
<a name="ln38">// Aug. 2008: Added Unknown Fields Comparison for messages.</a>
<a name="ln39">// Aug. 2009: Added different options to compare repeated fields.</a>
<a name="ln40">// Apr. 2010: Moved field comparison to FieldComparator.</a>
<a name="ln41"> </a>
<a name="ln42">#ifndef GOOGLE_PROTOBUF_UTIL_MESSAGE_DIFFERENCER_H__</a>
<a name="ln43">#define GOOGLE_PROTOBUF_UTIL_MESSAGE_DIFFERENCER_H__</a>
<a name="ln44"> </a>
<a name="ln45">#include &lt;map&gt;</a>
<a name="ln46">#include &lt;set&gt;</a>
<a name="ln47">#include &lt;string&gt;</a>
<a name="ln48">#include &lt;vector&gt;</a>
<a name="ln49">#include &lt;google/protobuf/descriptor.h&gt;  // FieldDescriptor</a>
<a name="ln50">#include &lt;google/protobuf/message.h&gt;  // Message</a>
<a name="ln51">#include &lt;google/protobuf/unknown_field_set.h&gt;</a>
<a name="ln52">#include &lt;google/protobuf/util/field_comparator.h&gt;</a>
<a name="ln53"> </a>
<a name="ln54">namespace google {</a>
<a name="ln55">namespace protobuf {</a>
<a name="ln56"> </a>
<a name="ln57">class DynamicMessageFactory;</a>
<a name="ln58">class FieldDescriptor;</a>
<a name="ln59"> </a>
<a name="ln60">namespace io {</a>
<a name="ln61">class ZeroCopyOutputStream;</a>
<a name="ln62">class Printer;</a>
<a name="ln63">}</a>
<a name="ln64"> </a>
<a name="ln65">namespace util {</a>
<a name="ln66"> </a>
<a name="ln67">class FieldContext;  // declared below MessageDifferencer</a>
<a name="ln68"> </a>
<a name="ln69">// A basic differencer that can be used to determine</a>
<a name="ln70">// the differences between two specified Protocol Messages. If any differences</a>
<a name="ln71">// are found, the Compare method will return false, and any differencer reporter</a>
<a name="ln72">// specified via ReportDifferencesTo will have its reporting methods called (see</a>
<a name="ln73">// below for implementation of the report). Based off of the original</a>
<a name="ln74">// ProtocolDifferencer implementation in //net/proto/protocol-differencer.h</a>
<a name="ln75">// (Thanks Todd!).</a>
<a name="ln76">//</a>
<a name="ln77">// MessageDifferencer REQUIRES that compared messages be the same type, defined</a>
<a name="ln78">// as messages that share the same descriptor.  If not, the behavior of this</a>
<a name="ln79">// class is undefined.</a>
<a name="ln80">//</a>
<a name="ln81">// People disagree on what MessageDifferencer should do when asked to compare</a>
<a name="ln82">// messages with different descriptors.  Some people think it should always</a>
<a name="ln83">// return false.  Others expect it to try to look for similar fields and</a>
<a name="ln84">// compare them anyway -- especially if the descriptors happen to be identical.</a>
<a name="ln85">// If we chose either of these behaviors, some set of people would find it</a>
<a name="ln86">// surprising, and could end up writing code expecting the other behavior</a>
<a name="ln87">// without realizing their error.  Therefore, we forbid that usage.</a>
<a name="ln88">//</a>
<a name="ln89">// This class is implemented based on the proto2 reflection. The performance</a>
<a name="ln90">// should be good enough for normal usages. However, for places where the</a>
<a name="ln91">// performance is extremely sensitive, there are several alternatives:</a>
<a name="ln92">// - Comparing serialized string</a>
<a name="ln93">// Downside: false negatives (there are messages that are the same but their</a>
<a name="ln94">// serialized strings are different).</a>
<a name="ln95">// - Equals code generator by compiler plugin (net/proto2/contrib/equals_plugin)</a>
<a name="ln96">// Downside: more generated code; maintenance overhead for the additional rule</a>
<a name="ln97">// (must be in sync with the original proto_library).</a>
<a name="ln98">//</a>
<a name="ln99">// Note on handling of google.protobuf.Any: MessageDifferencer automatically</a>
<a name="ln100">// unpacks Any::value into a Message and compares its individual fields.</a>
<a name="ln101">// Messages encoded in a repeated Any cannot be compared using TreatAsMap.</a>
<a name="ln102">//</a>
<a name="ln103">//</a>
<a name="ln104">// Note on thread-safety: MessageDifferencer is *not* thread-safe. You need to</a>
<a name="ln105">// guard it with a lock to use the same MessageDifferencer instance from</a>
<a name="ln106">// multiple threads. Note that it's fine to call static comparison methods</a>
<a name="ln107">// (like MessageDifferencer::Equals) concurrently.</a>
<a name="ln108">class LIBPROTOBUF_EXPORT MessageDifferencer {</a>
<a name="ln109"> public:</a>
<a name="ln110">  // Determines whether the supplied messages are equal. Equality is defined as</a>
<a name="ln111">  // all fields within the two messages being set to the same value. Primitive</a>
<a name="ln112">  // fields and strings are compared by value while embedded messages/groups</a>
<a name="ln113">  // are compared as if via a recursive call. Use IgnoreField() and Compare()</a>
<a name="ln114">  // if some fields should be ignored in the comparison.</a>
<a name="ln115">  //</a>
<a name="ln116">  // This method REQUIRES that the two messages have the same</a>
<a name="ln117">  // Descriptor (message1.GetDescriptor() == message2.GetDescriptor()).</a>
<a name="ln118">  static bool Equals(const Message&amp; message1, const Message&amp; message2);</a>
<a name="ln119"> </a>
<a name="ln120">  // Determines whether the supplied messages are equivalent. Equivalency is</a>
<a name="ln121">  // defined as all fields within the two messages having the same value. This</a>
<a name="ln122">  // differs from the Equals method above in that fields with default values</a>
<a name="ln123">  // are considered set to said value automatically. For details on how default</a>
<a name="ln124">  // values are defined for each field type, see http://shortn/_x2Gv6XFrWt.</a>
<a name="ln125">  // Also, Equivalent() ignores unknown fields. Use IgnoreField() and Compare()</a>
<a name="ln126">  // if some fields should be ignored in the comparison.</a>
<a name="ln127">  //</a>
<a name="ln128">  // This method REQUIRES that the two messages have the same</a>
<a name="ln129">  // Descriptor (message1.GetDescriptor() == message2.GetDescriptor()).</a>
<a name="ln130">  static bool Equivalent(const Message&amp; message1, const Message&amp; message2);</a>
<a name="ln131"> </a>
<a name="ln132">  // Determines whether the supplied messages are approximately equal.</a>
<a name="ln133">  // Approximate equality is defined as all fields within the two messages</a>
<a name="ln134">  // being approximately equal.  Primitive (non-float) fields and strings are</a>
<a name="ln135">  // compared by value, floats are compared using MathUtil::AlmostEquals() and</a>
<a name="ln136">  // embedded messages/groups are compared as if via a recursive call. Use</a>
<a name="ln137">  // IgnoreField() and Compare() if some fields should be ignored in the</a>
<a name="ln138">  // comparison.</a>
<a name="ln139">  //</a>
<a name="ln140">  // This method REQUIRES that the two messages have the same</a>
<a name="ln141">  // Descriptor (message1.GetDescriptor() == message2.GetDescriptor()).</a>
<a name="ln142">  static bool ApproximatelyEquals(const Message&amp; message1,</a>
<a name="ln143">                                  const Message&amp; message2);</a>
<a name="ln144"> </a>
<a name="ln145">  // Determines whether the supplied messages are approximately equivalent.</a>
<a name="ln146">  // Approximate equivalency is defined as all fields within the two messages</a>
<a name="ln147">  // being approximately equivalent. As in</a>
<a name="ln148">  // MessageDifferencer::ApproximatelyEquals, primitive (non-float) fields and</a>
<a name="ln149">  // strings are compared by value, floats are compared using</a>
<a name="ln150">  // MathUtil::AlmostEquals() and embedded messages/groups are compared as if</a>
<a name="ln151">  // via a recursive call. However, fields with default values are considered</a>
<a name="ln152">  // set to said value, as per MessageDiffencer::Equivalent. Use IgnoreField()</a>
<a name="ln153">  // and Compare() if some fields should be ignored in the comparison.</a>
<a name="ln154">  //</a>
<a name="ln155">  // This method REQUIRES that the two messages have the same</a>
<a name="ln156">  // Descriptor (message1.GetDescriptor() == message2.GetDescriptor()).</a>
<a name="ln157">  static bool ApproximatelyEquivalent(const Message&amp; message1,</a>
<a name="ln158">                                      const Message&amp; message2);</a>
<a name="ln159"> </a>
<a name="ln160">  // Identifies an individual field in a message instance.  Used for field_path,</a>
<a name="ln161">  // below.</a>
<a name="ln162">  struct SpecificField {</a>
<a name="ln163">    // For known fields, &quot;field&quot; is filled in and &quot;unknown_field_number&quot; is -1.</a>
<a name="ln164">    // For unknown fields, &quot;field&quot; is NULL, &quot;unknown_field_number&quot; is the field</a>
<a name="ln165">    // number, and &quot;unknown_field_type&quot; is its type.</a>
<a name="ln166">    const FieldDescriptor* field;</a>
<a name="ln167">    int unknown_field_number;</a>
<a name="ln168">    UnknownField::Type unknown_field_type;</a>
<a name="ln169"> </a>
<a name="ln170">    // If this a repeated field, &quot;index&quot; is the index within it.  For unknown</a>
<a name="ln171">    // fields, this is the index of the field among all unknown fields of the</a>
<a name="ln172">    // same field number and type.</a>
<a name="ln173">    int index;</a>
<a name="ln174"> </a>
<a name="ln175">    // If &quot;field&quot; is a repeated field which is being treated as a map or</a>
<a name="ln176">    // a set (see TreatAsMap() and TreatAsSet(), below), new_index indicates</a>
<a name="ln177">    // the index the position to which the element has moved.  This only</a>
<a name="ln178">    // applies to ReportMoved() and (in the case of TreatAsMap())</a>
<a name="ln179">    // ReportModified().  In all other cases, &quot;new_index&quot; will have the same</a>
<a name="ln180">    // value as &quot;index&quot;.</a>
<a name="ln181">    int new_index;</a>
<a name="ln182"> </a>
<a name="ln183">    // For unknown fields, these are the pointers to the UnknownFieldSet</a>
<a name="ln184">    // containing the unknown fields. In certain cases (e.g. proto1's</a>
<a name="ln185">    // MessageSet, or nested groups of unknown fields), these may differ from</a>
<a name="ln186">    // the messages' internal UnknownFieldSets.</a>
<a name="ln187">    const UnknownFieldSet* unknown_field_set1;</a>
<a name="ln188">    const UnknownFieldSet* unknown_field_set2;</a>
<a name="ln189"> </a>
<a name="ln190">    // For unknown fields, these are the index of the field within the</a>
<a name="ln191">    // UnknownFieldSets. One or the other will be -1 when</a>
<a name="ln192">    // reporting an addition or deletion.</a>
<a name="ln193">    int unknown_field_index1;</a>
<a name="ln194">    int unknown_field_index2;</a>
<a name="ln195"> </a>
<a name="ln196">    SpecificField()</a>
<a name="ln197">        : field(NULL),</a>
<a name="ln198">          unknown_field_number(-1),</a>
<a name="ln199">          index(-1),</a>
<a name="ln200">          new_index(-1),</a>
<a name="ln201">          unknown_field_set1(NULL),</a>
<a name="ln202">          unknown_field_set2(NULL),</a>
<a name="ln203">          unknown_field_index1(-1),</a>
<a name="ln204">          unknown_field_index2(-1) {}</a>
<a name="ln205">  };</a>
<a name="ln206"> </a>
<a name="ln207">  // Abstract base class from which all MessageDifferencer</a>
<a name="ln208">  // reporters derive. The five Report* methods below will be called when</a>
<a name="ln209">  // a field has been added, deleted, modified, moved, or matched. The third</a>
<a name="ln210">  // argument is a vector of FieldDescriptor pointers which describes the chain</a>
<a name="ln211">  // of fields that was taken to find the current field. For example, for a</a>
<a name="ln212">  // field found in an embedded message, the vector will contain two</a>
<a name="ln213">  // FieldDescriptors. The first will be the field of the embedded message</a>
<a name="ln214">  // itself and the second will be the actual field in the embedded message</a>
<a name="ln215">  // that was added/deleted/modified.</a>
<a name="ln216">  class LIBPROTOBUF_EXPORT Reporter {</a>
<a name="ln217">   public:</a>
<a name="ln218">    Reporter();</a>
<a name="ln219">    virtual ~Reporter();</a>
<a name="ln220"> </a>
<a name="ln221">    // Reports that a field has been added into Message2.</a>
<a name="ln222">    virtual void ReportAdded(</a>
<a name="ln223">        const Message&amp; message1, const Message&amp; message2,</a>
<a name="ln224">        const std::vector&lt;SpecificField&gt;&amp; field_path) = 0;</a>
<a name="ln225"> </a>
<a name="ln226">    // Reports that a field has been deleted from Message1.</a>
<a name="ln227">    virtual void ReportDeleted(</a>
<a name="ln228">        const Message&amp; message1,</a>
<a name="ln229">        const Message&amp; message2,</a>
<a name="ln230">        const std::vector&lt;SpecificField&gt;&amp; field_path) = 0;</a>
<a name="ln231"> </a>
<a name="ln232">    // Reports that the value of a field has been modified.</a>
<a name="ln233">    virtual void ReportModified(</a>
<a name="ln234">        const Message&amp; message1,</a>
<a name="ln235">        const Message&amp; message2,</a>
<a name="ln236">        const std::vector&lt;SpecificField&gt;&amp; field_path) = 0;</a>
<a name="ln237"> </a>
<a name="ln238">    // Reports that a repeated field has been moved to another location.  This</a>
<a name="ln239">    // only applies when using TreatAsSet or TreatAsMap()  -- see below. Also</a>
<a name="ln240">    // note that for any given field, ReportModified and ReportMoved are</a>
<a name="ln241">    // mutually exclusive. If a field has been both moved and modified, then</a>
<a name="ln242">    // only ReportModified will be called.</a>
<a name="ln243">    virtual void ReportMoved(</a>
<a name="ln244">        const Message&amp; /* message1 */,</a>
<a name="ln245">        const Message&amp; /* message2 */,</a>
<a name="ln246">        const std::vector&lt;SpecificField&gt;&amp; /* field_path */) { }</a>
<a name="ln247"> </a>
<a name="ln248">    // Reports that two fields match. Useful for doing side-by-side diffs.</a>
<a name="ln249">    // This function is mutually exclusive with ReportModified and ReportMoved.</a>
<a name="ln250">    // Note that you must call set_report_matches(true) before calling Compare</a>
<a name="ln251">    // to make use of this function.</a>
<a name="ln252">    virtual void ReportMatched(</a>
<a name="ln253">        const Message&amp; /* message1 */,</a>
<a name="ln254">        const Message&amp; /* message2 */,</a>
<a name="ln255">        const std::vector&lt;SpecificField&gt;&amp; /* field_path */) { }</a>
<a name="ln256"> </a>
<a name="ln257">    // Reports that two fields would have been compared, but the</a>
<a name="ln258">    // comparison has been skipped because the field was marked as</a>
<a name="ln259">    // 'ignored' using IgnoreField().  This function is mutually</a>
<a name="ln260">    // exclusive with all the other Report() functions.</a>
<a name="ln261">    //</a>
<a name="ln262">    // The contract of ReportIgnored is slightly different than the</a>
<a name="ln263">    // other Report() functions, in that |field_path.back().index| is</a>
<a name="ln264">    // always equal to -1, even if the last field is repeated. This is</a>
<a name="ln265">    // because while the other Report() functions indicate where in a</a>
<a name="ln266">    // repeated field the action (Addition, Deletion, etc...)</a>
<a name="ln267">    // happened, when a repeated field is 'ignored', the differencer</a>
<a name="ln268">    // simply calls ReportIgnored on the repeated field as a whole and</a>
<a name="ln269">    // moves on without looking at its individual elements.</a>
<a name="ln270">    //</a>
<a name="ln271">    // Furthermore, ReportIgnored() does not indicate whether the</a>
<a name="ln272">    // fields were in fact equal or not, as Compare() does not inspect</a>
<a name="ln273">    // these fields at all. It is up to the Reporter to decide whether</a>
<a name="ln274">    // the fields are equal or not (perhaps with a second call to</a>
<a name="ln275">    // Compare()), if it cares.</a>
<a name="ln276">    virtual void ReportIgnored(</a>
<a name="ln277">        const Message&amp; /* message1 */,</a>
<a name="ln278">        const Message&amp; /* message2 */,</a>
<a name="ln279">        const std::vector&lt;SpecificField&gt;&amp; /* field_path */) { }</a>
<a name="ln280"> </a>
<a name="ln281">    // Report that an unknown field is ignored. (see comment above).</a>
<a name="ln282">    // Note this is a different function since the last SpecificField in field</a>
<a name="ln283">    // path has a null field.  This could break existing Reporter.</a>
<a name="ln284">    virtual void ReportUnknownFieldIgnored(</a>
<a name="ln285">        const Message&amp; /* message1 */, const Message&amp; /* message2 */,</a>
<a name="ln286">        const std::vector&lt;SpecificField&gt;&amp; /* field_path */) {}</a>
<a name="ln287"> </a>
<a name="ln288">   private:</a>
<a name="ln289">    GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(Reporter);</a>
<a name="ln290">  };</a>
<a name="ln291"> </a>
<a name="ln292">  // MapKeyComparator is used to determine if two elements have the same key</a>
<a name="ln293">  // when comparing elements of a repeated field as a map.</a>
<a name="ln294">  class LIBPROTOBUF_EXPORT MapKeyComparator {</a>
<a name="ln295">   public:</a>
<a name="ln296">    MapKeyComparator();</a>
<a name="ln297">    virtual ~MapKeyComparator();</a>
<a name="ln298"> </a>
<a name="ln299">    virtual bool IsMatch(</a>
<a name="ln300">        const Message&amp; /* message1 */,</a>
<a name="ln301">        const Message&amp; /* message2 */,</a>
<a name="ln302">        const std::vector&lt;SpecificField&gt;&amp; /* parent_fields */) const {</a>
<a name="ln303">      GOOGLE_CHECK(false) &lt;&lt; &quot;IsMatch() is not implemented.&quot;;</a>
<a name="ln304">      return false;</a>
<a name="ln305">    }</a>
<a name="ln306"> </a>
<a name="ln307">   private:</a>
<a name="ln308">    GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(MapKeyComparator);</a>
<a name="ln309">  };</a>
<a name="ln310"> </a>
<a name="ln311">  // Abstract base class from which all IgnoreCriteria derive.</a>
<a name="ln312">  // By adding IgnoreCriteria more complex ignore logic can be implemented.</a>
<a name="ln313">  // IgnoreCriteria are registed with AddIgnoreCriteria. For each compared</a>
<a name="ln314">  // field IsIgnored is called on each added IgnoreCriteria until one returns</a>
<a name="ln315">  // true or all return false.</a>
<a name="ln316">  // IsIgnored is called for fields where at least one side has a value.</a>
<a name="ln317">  class LIBPROTOBUF_EXPORT IgnoreCriteria {</a>
<a name="ln318">   public:</a>
<a name="ln319">    IgnoreCriteria();</a>
<a name="ln320">    virtual ~IgnoreCriteria();</a>
<a name="ln321"> </a>
<a name="ln322">    // Returns true if the field should be ignored.</a>
<a name="ln323">    virtual bool IsIgnored(</a>
<a name="ln324">        const Message&amp; /* message1 */,</a>
<a name="ln325">        const Message&amp; /* message2 */,</a>
<a name="ln326">        const FieldDescriptor* /* field */,</a>
<a name="ln327">        const std::vector&lt;SpecificField&gt;&amp; /* parent_fields */) = 0;</a>
<a name="ln328"> </a>
<a name="ln329">    // Returns true if the unknown field should be ignored.</a>
<a name="ln330">    // Note: This will be called for unknown fields as well in which case</a>
<a name="ln331">    //       field.field will be null.</a>
<a name="ln332">    virtual bool IsUnknownFieldIgnored(</a>
<a name="ln333">        const Message&amp; /* message1 */, const Message&amp; /* message2 */,</a>
<a name="ln334">        const SpecificField&amp; /* field */,</a>
<a name="ln335">        const std::vector&lt;SpecificField&gt;&amp; /* parent_fields */) {</a>
<a name="ln336">      return false;</a>
<a name="ln337">    }</a>
<a name="ln338">  };</a>
<a name="ln339"> </a>
<a name="ln340">  // To add a Reporter, construct default here, then use ReportDifferencesTo or</a>
<a name="ln341">  // ReportDifferencesToString.</a>
<a name="ln342">  explicit MessageDifferencer();</a>
<a name="ln343"> </a>
<a name="ln344">  ~MessageDifferencer();</a>
<a name="ln345"> </a>
<a name="ln346">  enum MessageFieldComparison {</a>
<a name="ln347">    EQUAL,       // Fields must be present in both messages</a>
<a name="ln348">                 // for the messages to be considered the same.</a>
<a name="ln349">    EQUIVALENT,  // Fields with default values are considered set</a>
<a name="ln350">                 // for comparison purposes even if not explicitly</a>
<a name="ln351">                 // set in the messages themselves.  Unknown fields</a>
<a name="ln352">                 // are ignored.</a>
<a name="ln353">  };</a>
<a name="ln354"> </a>
<a name="ln355">  enum Scope {</a>
<a name="ln356">    FULL,    // All fields of both messages are considered in the comparison.</a>
<a name="ln357">    PARTIAL  // Only fields present in the first message are considered; fields</a>
<a name="ln358">             // set only in the second message will be skipped during</a>
<a name="ln359">             // comparison.</a>
<a name="ln360">  };</a>
<a name="ln361"> </a>
<a name="ln362">  // DEPRECATED. Use FieldComparator::FloatComparison instead.</a>
<a name="ln363">  enum FloatComparison {</a>
<a name="ln364">    EXACT,       // Floats and doubles are compared exactly.</a>
<a name="ln365">    APPROXIMATE  // Floats and doubles are compared using the</a>
<a name="ln366">                 // MathUtil::AlmostEquals method.</a>
<a name="ln367">  };</a>
<a name="ln368"> </a>
<a name="ln369">  enum RepeatedFieldComparison {</a>
<a name="ln370">    AS_LIST,     // Repeated fields are compared in order.  Differing values at</a>
<a name="ln371">                 // the same index are reported using ReportModified().  If the</a>
<a name="ln372">                 // repeated fields have different numbers of elements, the</a>
<a name="ln373">                 // unpaired elements are reported using ReportAdded() or</a>
<a name="ln374">                 // ReportDeleted().</a>
<a name="ln375">    AS_SET,      // Treat all the repeated fields as sets by default.</a>
<a name="ln376">                 // See TreatAsSet(), as below.</a>
<a name="ln377">  };</a>
<a name="ln378"> </a>
<a name="ln379">  // The elements of the given repeated field will be treated as a set for</a>
<a name="ln380">  // diffing purposes, so different orderings of the same elements will be</a>
<a name="ln381">  // considered equal.  Elements which are present on both sides of the</a>
<a name="ln382">  // comparison but which have changed position will be reported with</a>
<a name="ln383">  // ReportMoved().  Elements which only exist on one side or the other are</a>
<a name="ln384">  // reported with ReportAdded() and ReportDeleted() regardless of their</a>
<a name="ln385">  // positions.  ReportModified() is never used for this repeated field.  If</a>
<a name="ln386">  // the only differences between the compared messages is that some fields</a>
<a name="ln387">  // have been moved, then the comparison returns true.</a>
<a name="ln388">  //</a>
<a name="ln389">  // If the scope of comparison is set to PARTIAL, then in addition to what's</a>
<a name="ln390">  // above, extra values added to repeated fields of the second message will</a>
<a name="ln391">  // not cause the comparison to fail.</a>
<a name="ln392">  //</a>
<a name="ln393">  // Note that set comparison is currently O(k * n^2) (where n is the total</a>
<a name="ln394">  // number of elements, and k is the average size of each element). In theory</a>
<a name="ln395">  // it could be made O(n * k) with a more complex hashing implementation. Feel</a>
<a name="ln396">  // free to contribute one if the current implementation is too slow for you.</a>
<a name="ln397">  // If partial matching is also enabled, the time complexity will be O(k * n^2</a>
<a name="ln398">  // + n^3) in which n^3 is the time complexity of the maximum matching</a>
<a name="ln399">  // algorithm.</a>
<a name="ln400">  //</a>
<a name="ln401">  // REQUIRES:  field-&gt;is_repeated() and field not registered with TreatAsList</a>
<a name="ln402">  void TreatAsSet(const FieldDescriptor* field);</a>
<a name="ln403"> </a>
<a name="ln404">  // The elements of the given repeated field will be treated as a list for</a>
<a name="ln405">  // diffing purposes, so different orderings of the same elements will NOT be</a>
<a name="ln406">  // considered equal.</a>
<a name="ln407">  //</a>
<a name="ln408">  // REQUIRED: field-&gt;is_repeated() and field not registered with TreatAsSet</a>
<a name="ln409">  void TreatAsList(const FieldDescriptor* field);</a>
<a name="ln410"> </a>
<a name="ln411">  // The elements of the given repeated field will be treated as a map for</a>
<a name="ln412">  // diffing purposes, with |key| being the map key.  Thus, elements with the</a>
<a name="ln413">  // same key will be compared even if they do not appear at the same index.</a>
<a name="ln414">  // Differences are reported similarly to TreatAsSet(), except that</a>
<a name="ln415">  // ReportModified() is used to report elements with the same key but</a>
<a name="ln416">  // different values.  Note that if an element is both moved and modified,</a>
<a name="ln417">  // only ReportModified() will be called.  As with TreatAsSet, if the only</a>
<a name="ln418">  // differences between the compared messages is that some fields have been</a>
<a name="ln419">  // moved, then the comparison returns true. See TreatAsSet for notes on</a>
<a name="ln420">  // performance.</a>
<a name="ln421">  //</a>
<a name="ln422">  // REQUIRES:  field-&gt;is_repeated()</a>
<a name="ln423">  // REQUIRES:  field-&gt;cpp_type() == FieldDescriptor::CPPTYPE_MESSAGE</a>
<a name="ln424">  // REQUIRES:  key-&gt;containing_type() == field-&gt;message_type()</a>
<a name="ln425">  void TreatAsMap(const FieldDescriptor* field, const FieldDescriptor* key);</a>
<a name="ln426">  // Same as TreatAsMap except that this method will use multiple fields as</a>
<a name="ln427">  // the key in comparison. All specified fields in 'key_fields' should be</a>
<a name="ln428">  // present in the compared elements. Two elements will be treated as having</a>
<a name="ln429">  // the same key iff they have the same value for every specified field. There</a>
<a name="ln430">  // are two steps in the comparison process. The first one is key matching.</a>
<a name="ln431">  // Every element from one message will be compared to every element from</a>
<a name="ln432">  // the other message. Only fields in 'key_fields' are compared in this step</a>
<a name="ln433">  // to decide if two elements have the same key. The second step is value</a>
<a name="ln434">  // comparison. Those pairs of elements with the same key (with equal value</a>
<a name="ln435">  // for every field in 'key_fields') will be compared in this step.</a>
<a name="ln436">  // Time complexity of the first step is O(s * m * n ^ 2) where s is the</a>
<a name="ln437">  // average size of the fields specified in 'key_fields', m is the number of</a>
<a name="ln438">  // fields in 'key_fields' and n is the number of elements. If partial</a>
<a name="ln439">  // matching is enabled, an extra O(n^3) will be incured by the maximum</a>
<a name="ln440">  // matching algorithm. The second step is O(k * n) where k is the average</a>
<a name="ln441">  // size of each element.</a>
<a name="ln442">  void TreatAsMapWithMultipleFieldsAsKey(</a>
<a name="ln443">      const FieldDescriptor* field,</a>
<a name="ln444">      const std::vector&lt;const FieldDescriptor*&gt;&amp; key_fields);</a>
<a name="ln445">  // Same as TreatAsMapWithMultipleFieldsAsKey, except that each of the field</a>
<a name="ln446">  // do not necessarily need to be a direct subfield. Each element in</a>
<a name="ln447">  // key_field_paths indicate a path from the message being compared, listing</a>
<a name="ln448">  // successive subfield to reach the key field.</a>
<a name="ln449">  //</a>
<a name="ln450">  // REQUIRES:</a>
<a name="ln451">  //   for key_field_path in key_field_paths:</a>
<a name="ln452">  //     key_field_path[0]-&gt;containing_type() == field-&gt;message_type()</a>
<a name="ln453">  //     for i in [0, key_field_path.size() - 1):</a>
<a name="ln454">  //       key_field_path[i+1]-&gt;containing_type() ==</a>
<a name="ln455">  //           key_field_path[i]-&gt;message_type()</a>
<a name="ln456">  //       key_field_path[i]-&gt;cpp_type() == FieldDescriptor::CPPTYPE_MESSAGE</a>
<a name="ln457">  //       !key_field_path[i]-&gt;is_repeated()</a>
<a name="ln458">  void TreatAsMapWithMultipleFieldPathsAsKey(</a>
<a name="ln459">      const FieldDescriptor* field,</a>
<a name="ln460">      const std::vector&lt;std::vector&lt;const FieldDescriptor*&gt; &gt;&amp; key_field_paths);</a>
<a name="ln461"> </a>
<a name="ln462">  // Uses a custom MapKeyComparator to determine if two elements have the same</a>
<a name="ln463">  // key when comparing a repeated field as a map.</a>
<a name="ln464">  // The caller is responsible to delete the key_comparator.</a>
<a name="ln465">  // This method varies from TreatAsMapWithMultipleFieldsAsKey only in the</a>
<a name="ln466">  // first key matching step. Rather than comparing some specified fields, it</a>
<a name="ln467">  // will invoke the IsMatch method of the given 'key_comparator' to decide if</a>
<a name="ln468">  // two elements have the same key.</a>
<a name="ln469">  void TreatAsMapUsingKeyComparator(</a>
<a name="ln470">      const FieldDescriptor* field,</a>
<a name="ln471">      const MapKeyComparator* key_comparator);</a>
<a name="ln472"> </a>
<a name="ln473">  // Add a custom ignore criteria that is evaluated in addition to the</a>
<a name="ln474">  // ignored fields added with IgnoreField.</a>
<a name="ln475">  // Takes ownership of ignore_criteria.</a>
<a name="ln476">  void AddIgnoreCriteria(IgnoreCriteria* ignore_criteria);</a>
<a name="ln477"> </a>
<a name="ln478">  // Indicates that any field with the given descriptor should be</a>
<a name="ln479">  // ignored for the purposes of comparing two messages. This applies</a>
<a name="ln480">  // to fields nested in the message structure as well as top level</a>
<a name="ln481">  // ones. When the MessageDifferencer encounters an ignored field,</a>
<a name="ln482">  // ReportIgnored is called on the reporter, if one is specified.</a>
<a name="ln483">  //</a>
<a name="ln484">  // The only place where the field's 'ignored' status is not applied is when</a>
<a name="ln485">  // it is being used as a key in a field passed to TreatAsMap or is one of</a>
<a name="ln486">  // the fields passed to TreatAsMapWithMultipleFieldsAsKey.</a>
<a name="ln487">  // In this case it is compared in key matching but after that it's ignored</a>
<a name="ln488">  // in value comparison.</a>
<a name="ln489">  void IgnoreField(const FieldDescriptor* field);</a>
<a name="ln490"> </a>
<a name="ln491">  // Sets the field comparator used to determine differences between protocol</a>
<a name="ln492">  // buffer fields. By default it's set to a DefaultFieldComparator instance.</a>
<a name="ln493">  // MessageDifferencer doesn't take ownership over the passed object.</a>
<a name="ln494">  // Note that this method must be called before Compare for the comparator to</a>
<a name="ln495">  // be used.</a>
<a name="ln496">  void set_field_comparator(FieldComparator* comparator);</a>
<a name="ln497"> </a>
<a name="ln498">  // DEPRECATED. Pass a DefaultFieldComparator instance instead.</a>
<a name="ln499">  // Sets the fraction and margin for the float comparison of a given field.</a>
<a name="ln500">  // Uses MathUtil::WithinFractionOrMargin to compare the values.</a>
<a name="ln501">  // NOTE: this method does nothing if differencer's field comparator has been</a>
<a name="ln502">  //       set to a custom object.</a>
<a name="ln503">  //</a>
<a name="ln504">  // REQUIRES: field-&gt;cpp_type == FieldDescriptor::CPPTYPE_DOUBLE or</a>
<a name="ln505">  //           field-&gt;cpp_type == FieldDescriptor::CPPTYPE_FLOAT</a>
<a name="ln506">  // REQUIRES: float_comparison_ == APPROXIMATE</a>
<a name="ln507">  void SetFractionAndMargin(const FieldDescriptor* field, double fraction,</a>
<a name="ln508">                            double margin);</a>
<a name="ln509"> </a>
<a name="ln510">  // Sets the type of comparison (as defined in the MessageFieldComparison</a>
<a name="ln511">  // enumeration above) that is used by this differencer when determining how</a>
<a name="ln512">  // to compare fields in messages.</a>
<a name="ln513">  void set_message_field_comparison(MessageFieldComparison comparison);</a>
<a name="ln514"> </a>
<a name="ln515">  // Tells the differencer whether or not to report matches. This method must</a>
<a name="ln516">  // be called before Compare. The default for a new differencer is false.</a>
<a name="ln517">  void set_report_matches(bool report_matches) {</a>
<a name="ln518">    report_matches_ = report_matches;</a>
<a name="ln519">  }</a>
<a name="ln520"> </a>
<a name="ln521">  // Tells the differencer whether or not to report moves (in a set or map</a>
<a name="ln522">  // repeated field). This method must be called before Compare. The default for</a>
<a name="ln523">  // a new differencer is true.</a>
<a name="ln524">  void set_report_moves(bool report_moves) {</a>
<a name="ln525">    report_moves_ = report_moves;</a>
<a name="ln526">  }</a>
<a name="ln527"> </a>
<a name="ln528">  // Sets the scope of the comparison (as defined in the Scope enumeration</a>
<a name="ln529">  // above) that is used by this differencer when determining which fields to</a>
<a name="ln530">  // compare between the messages.</a>
<a name="ln531">  void set_scope(Scope scope);</a>
<a name="ln532"> </a>
<a name="ln533">  // Returns the current scope used by this differencer.</a>
<a name="ln534">  Scope scope();</a>
<a name="ln535"> </a>
<a name="ln536">  // DEPRECATED. Pass a DefaultFieldComparator instance instead.</a>
<a name="ln537">  // Sets the type of comparison (as defined in the FloatComparison enumeration</a>
<a name="ln538">  // above) that is used by this differencer when comparing float (and double)</a>
<a name="ln539">  // fields in messages.</a>
<a name="ln540">  // NOTE: this method does nothing if differencer's field comparator has been</a>
<a name="ln541">  //       set to a custom object.</a>
<a name="ln542">  void set_float_comparison(FloatComparison comparison);</a>
<a name="ln543"> </a>
<a name="ln544">  // Sets the type of comparison for repeated field (as defined in the</a>
<a name="ln545">  // RepeatedFieldComparison enumeration above) that is used by this</a>
<a name="ln546">  // differencer when compare repeated fields in messages.</a>
<a name="ln547">  void set_repeated_field_comparison(RepeatedFieldComparison comparison);</a>
<a name="ln548"> </a>
<a name="ln549">  // Compares the two specified messages, returning true if they are the same,</a>
<a name="ln550">  // false otherwise. If this method returns false, any changes between the</a>
<a name="ln551">  // two messages will be reported if a Reporter was specified via</a>
<a name="ln552">  // ReportDifferencesTo (see also ReportDifferencesToString).</a>
<a name="ln553">  //</a>
<a name="ln554">  // This method REQUIRES that the two messages have the same</a>
<a name="ln555">  // Descriptor (message1.GetDescriptor() == message2.GetDescriptor()).</a>
<a name="ln556">  bool Compare(const Message&amp; message1, const Message&amp; message2);</a>
<a name="ln557"> </a>
<a name="ln558">  // Same as above, except comparing only the list of fields specified by the</a>
<a name="ln559">  // two vectors of FieldDescriptors.</a>
<a name="ln560">  bool CompareWithFields(</a>
<a name="ln561">      const Message&amp; message1, const Message&amp; message2,</a>
<a name="ln562">      const std::vector&lt;const FieldDescriptor*&gt;&amp; message1_fields,</a>
<a name="ln563">      const std::vector&lt;const FieldDescriptor*&gt;&amp; message2_fields);</a>
<a name="ln564"> </a>
<a name="ln565">  // Automatically creates a reporter that will output the differences</a>
<a name="ln566">  // found (if any) to the specified output string pointer. Note that this</a>
<a name="ln567">  // method must be called before Compare.</a>
<a name="ln568">  void ReportDifferencesToString(string* output);</a>
<a name="ln569"> </a>
<a name="ln570">  // Tells the MessageDifferencer to report differences via the specified</a>
<a name="ln571">  // reporter. Note that this method must be called before Compare for</a>
<a name="ln572">  // the reporter to be used. It is the responsibility of the caller to delete</a>
<a name="ln573">  // this object.</a>
<a name="ln574">  // If the provided pointer equals NULL, the MessageDifferencer stops reporting</a>
<a name="ln575">  // differences to any previously set reporters or output strings.</a>
<a name="ln576">  void ReportDifferencesTo(Reporter* reporter);</a>
<a name="ln577"> </a>
<a name="ln578">  // An implementation of the MessageDifferencer Reporter that outputs</a>
<a name="ln579">  // any differences found in human-readable form to the supplied</a>
<a name="ln580">  // ZeroCopyOutputStream or Printer. If a printer is used, the delimiter</a>
<a name="ln581">  // *must* be '$'.</a>
<a name="ln582">  //</a>
<a name="ln583">  // WARNING: this reporter does not necessarily flush its output until it is</a>
<a name="ln584">  // destroyed. As a result, it is not safe to assume the output is valid or</a>
<a name="ln585">  // complete until after you destroy the reporter. For example, if you use a</a>
<a name="ln586">  // StreamReporter to write to a StringOutputStream, the target string may</a>
<a name="ln587">  // contain uninitialized data until the reporter is destroyed.</a>
<a name="ln588">  class LIBPROTOBUF_EXPORT StreamReporter : public Reporter {</a>
<a name="ln589">   public:</a>
<a name="ln590">    explicit StreamReporter(io::ZeroCopyOutputStream* output);</a>
<a name="ln591">    explicit StreamReporter(io::Printer* printer);  // delimiter '$'</a>
<a name="ln592">    virtual ~StreamReporter();</a>
<a name="ln593"> </a>
<a name="ln594">    // When set to true, the stream reporter will also output aggregates nodes</a>
<a name="ln595">    // (i.e. messages and groups) whose subfields have been modified. When</a>
<a name="ln596">    // false, will only report the individual subfields. Defaults to false.</a>
<a name="ln597">    void set_report_modified_aggregates(bool report) {</a>
<a name="ln598">      report_modified_aggregates_ = report;</a>
<a name="ln599">    }</a>
<a name="ln600"> </a>
<a name="ln601">    // The following are implementations of the methods described above.</a>
<a name="ln602">    virtual void ReportAdded(const Message&amp; message1, const Message&amp; message2,</a>
<a name="ln603">                             const std::vector&lt;SpecificField&gt;&amp; field_path);</a>
<a name="ln604"> </a>
<a name="ln605">    virtual void ReportDeleted(const Message&amp; message1,</a>
<a name="ln606">                               const Message&amp; message2,</a>
<a name="ln607">                               const std::vector&lt;SpecificField&gt;&amp; field_path);</a>
<a name="ln608"> </a>
<a name="ln609">    virtual void ReportModified(const Message&amp; message1,</a>
<a name="ln610">                                const Message&amp; message2,</a>
<a name="ln611">                                const std::vector&lt;SpecificField&gt;&amp; field_path);</a>
<a name="ln612"> </a>
<a name="ln613">    virtual void ReportMoved(const Message&amp; message1,</a>
<a name="ln614">                             const Message&amp; message2,</a>
<a name="ln615">                             const std::vector&lt;SpecificField&gt;&amp; field_path);</a>
<a name="ln616"> </a>
<a name="ln617">    virtual void ReportMatched(const Message&amp; message1,</a>
<a name="ln618">                               const Message&amp; message2,</a>
<a name="ln619">                               const std::vector&lt;SpecificField&gt;&amp; field_path);</a>
<a name="ln620"> </a>
<a name="ln621">    virtual void ReportIgnored(const Message&amp; message1,</a>
<a name="ln622">                               const Message&amp; message2,</a>
<a name="ln623">                               const std::vector&lt;SpecificField&gt;&amp; field_path);</a>
<a name="ln624"> </a>
<a name="ln625">    virtual void ReportUnknownFieldIgnored(</a>
<a name="ln626">        const Message&amp; message1, const Message&amp; message2,</a>
<a name="ln627">        const std::vector&lt;SpecificField&gt;&amp; field_path);</a>
<a name="ln628"> </a>
<a name="ln629">   protected:</a>
<a name="ln630">    // Prints the specified path of fields to the buffer.  message is used to</a>
<a name="ln631">    // print map keys.</a>
<a name="ln632">    virtual void PrintPath(const std::vector&lt;SpecificField&gt;&amp; field_path,</a>
<a name="ln633">                           bool left_side, const Message&amp; message);</a>
<a name="ln634"> </a>
<a name="ln635">    // Prints the specified path of fields to the buffer.</a>
<a name="ln636">    virtual void PrintPath(const std::vector&lt;SpecificField&gt;&amp; field_path,</a>
<a name="ln637">                           bool left_side);</a>
<a name="ln638"> </a>
<a name="ln639">    // Prints the value of fields to the buffer.  left_side is true if the</a>
<a name="ln640">    // given message is from the left side of the comparison, false if it</a>
<a name="ln641">    // was the right.  This is relevant only to decide whether to follow</a>
<a name="ln642">    // unknown_field_index1 or unknown_field_index2 when an unknown field</a>
<a name="ln643">    // is encountered in field_path.</a>
<a name="ln644">    virtual void PrintValue(const Message&amp; message,</a>
<a name="ln645">                            const std::vector&lt;SpecificField&gt;&amp; field_path,</a>
<a name="ln646">                            bool left_side);</a>
<a name="ln647"> </a>
<a name="ln648">    // Prints the specified path of unknown fields to the buffer.</a>
<a name="ln649">    virtual void PrintUnknownFieldValue(const UnknownField* unknown_field);</a>
<a name="ln650"> </a>
<a name="ln651">    // Just print a string</a>
<a name="ln652">    void Print(const string&amp; str);</a>
<a name="ln653"> </a>
<a name="ln654">   private:</a>
<a name="ln655">    io::Printer* printer_;</a>
<a name="ln656">    bool delete_printer_;</a>
<a name="ln657">    bool report_modified_aggregates_;</a>
<a name="ln658"> </a>
<a name="ln659">    GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(StreamReporter);</a>
<a name="ln660">  };</a>
<a name="ln661"> </a>
<a name="ln662"> private:</a>
<a name="ln663">  // A MapKeyComparator to be used in TreatAsMapUsingKeyComparator.</a>
<a name="ln664">  // Implementation of this class needs to do field value comparison which</a>
<a name="ln665">  // relies on some private methods of MessageDifferencer. That's why this</a>
<a name="ln666">  // class is declared as a nested class of MessageDifferencer.</a>
<a name="ln667">  class MultipleFieldsMapKeyComparator;</a>
<a name="ln668"> </a>
<a name="ln669">  // A MapKeyComparator for use with map_entries.</a>
<a name="ln670">  class LIBPROTOBUF_EXPORT MapEntryKeyComparator : public MapKeyComparator {</a>
<a name="ln671">   public:</a>
<a name="ln672">    explicit MapEntryKeyComparator(MessageDifferencer* message_differencer);</a>
<a name="ln673">    virtual bool IsMatch(const Message&amp; message1, const Message&amp; message2,</a>
<a name="ln674">                         const std::vector&lt;SpecificField&gt;&amp; parent_fields) const;</a>
<a name="ln675"> </a>
<a name="ln676">   private:</a>
<a name="ln677">    MessageDifferencer* message_differencer_;</a>
<a name="ln678">  };</a>
<a name="ln679"> </a>
<a name="ln680">  // Returns true if field1's number() is less than field2's.</a>
<a name="ln681">  static bool FieldBefore(const FieldDescriptor* field1,</a>
<a name="ln682">                          const FieldDescriptor* field2);</a>
<a name="ln683"> </a>
<a name="ln684">  // Combine the two lists of fields into the combined_fields output vector.</a>
<a name="ln685">  // All fields present in both lists will always be included in the combined</a>
<a name="ln686">  // list.  Fields only present in one of the lists will only appear in the</a>
<a name="ln687">  // combined list if the corresponding fields_scope option is set to FULL.</a>
<a name="ln688">  void CombineFields(const std::vector&lt;const FieldDescriptor*&gt;&amp; fields1,</a>
<a name="ln689">                     Scope fields1_scope,</a>
<a name="ln690">                     const std::vector&lt;const FieldDescriptor*&gt;&amp; fields2,</a>
<a name="ln691">                     Scope fields2_scope,</a>
<a name="ln692">                     std::vector&lt;const FieldDescriptor*&gt;* combined_fields);</a>
<a name="ln693"> </a>
<a name="ln694">  // Internal version of the Compare method which performs the actual</a>
<a name="ln695">  // comparison. The parent_fields vector is a vector containing field</a>
<a name="ln696">  // descriptors of all fields accessed to get to this comparison operation</a>
<a name="ln697">  // (i.e. if the current message is an embedded message, the parent_fields</a>
<a name="ln698">  // vector will contain the field that has this embedded message).</a>
<a name="ln699">  bool Compare(const Message&amp; message1, const Message&amp; message2,</a>
<a name="ln700">               std::vector&lt;SpecificField&gt;* parent_fields);</a>
<a name="ln701"> </a>
<a name="ln702">  // Compares all the unknown fields in two messages.</a>
<a name="ln703">  bool CompareUnknownFields(const Message&amp; message1, const Message&amp; message2,</a>
<a name="ln704">                            const google::protobuf::UnknownFieldSet&amp;,</a>
<a name="ln705">                            const google::protobuf::UnknownFieldSet&amp;,</a>
<a name="ln706">                            std::vector&lt;SpecificField&gt;* parent_fields);</a>
<a name="ln707"> </a>
<a name="ln708">  // Compares the specified messages for the requested field lists. The field</a>
<a name="ln709">  // lists are modified depending on comparison settings, and then passed to</a>
<a name="ln710">  // CompareWithFieldsInternal.</a>
<a name="ln711">  bool CompareRequestedFieldsUsingSettings(</a>
<a name="ln712">      const Message&amp; message1, const Message&amp; message2,</a>
<a name="ln713">      const std::vector&lt;const FieldDescriptor*&gt;&amp; message1_fields,</a>
<a name="ln714">      const std::vector&lt;const FieldDescriptor*&gt;&amp; message2_fields,</a>
<a name="ln715">      std::vector&lt;SpecificField&gt;* parent_fields);</a>
<a name="ln716"> </a>
<a name="ln717">  // Compares the specified messages with the specified field lists.</a>
<a name="ln718">  bool CompareWithFieldsInternal(</a>
<a name="ln719">      const Message&amp; message1, const Message&amp; message2,</a>
<a name="ln720">      const std::vector&lt;const FieldDescriptor*&gt;&amp; message1_fields,</a>
<a name="ln721">      const std::vector&lt;const FieldDescriptor*&gt;&amp; message2_fields,</a>
<a name="ln722">      std::vector&lt;SpecificField&gt;* parent_fields);</a>
<a name="ln723"> </a>
<a name="ln724">  // Compares the repeated fields, and report the error.</a>
<a name="ln725">  bool CompareRepeatedField(const Message&amp; message1, const Message&amp; message2,</a>
<a name="ln726">                            const FieldDescriptor* field,</a>
<a name="ln727">                            std::vector&lt;SpecificField&gt;* parent_fields);</a>
<a name="ln728"> </a>
<a name="ln729">  // Shorthand for CompareFieldValueUsingParentFields with NULL parent_fields.</a>
<a name="ln730">  bool CompareFieldValue(const Message&amp; message1,</a>
<a name="ln731">                         const Message&amp; message2,</a>
<a name="ln732">                         const FieldDescriptor* field,</a>
<a name="ln733">                         int index1,</a>
<a name="ln734">                         int index2);</a>
<a name="ln735"> </a>
<a name="ln736">  // Compares the specified field on the two messages, returning</a>
<a name="ln737">  // true if they are the same, false otherwise. For repeated fields,</a>
<a name="ln738">  // this method only compares the value in the specified index. This method</a>
<a name="ln739">  // uses Compare functions to recurse into submessages.</a>
<a name="ln740">  // The parent_fields vector is used in calls to a Reporter instance calls.</a>
<a name="ln741">  // It can be NULL, in which case the MessageDifferencer will create new</a>
<a name="ln742">  // list of parent messages if it needs to recursively compare the given field.</a>
<a name="ln743">  // To avoid confusing users you should not set it to NULL unless you modified</a>
<a name="ln744">  // Reporter to handle the change of parent_fields correctly.</a>
<a name="ln745">  bool CompareFieldValueUsingParentFields(</a>
<a name="ln746">      const Message&amp; message1,</a>
<a name="ln747">      const Message&amp; message2,</a>
<a name="ln748">      const FieldDescriptor* field,</a>
<a name="ln749">      int index1,</a>
<a name="ln750">      int index2,</a>
<a name="ln751">      std::vector&lt;SpecificField&gt;* parent_fields);</a>
<a name="ln752"> </a>
<a name="ln753">  // Compares the specified field on the two messages, returning comparison</a>
<a name="ln754">  // result, as returned by appropriate FieldComparator.</a>
<a name="ln755">  FieldComparator::ComparisonResult GetFieldComparisonResult(</a>
<a name="ln756">      const Message&amp; message1, const Message&amp; message2,</a>
<a name="ln757">      const FieldDescriptor* field, int index1, int index2,</a>
<a name="ln758">      const FieldContext* field_context);</a>
<a name="ln759"> </a>
<a name="ln760">  // Check if the two elements in the repeated field are match to each other.</a>
<a name="ln761">  // if the key_comprator is NULL, this function returns true when the two</a>
<a name="ln762">  // elements are equal.</a>
<a name="ln763">  bool IsMatch(const FieldDescriptor* repeated_field,</a>
<a name="ln764">               const MapKeyComparator* key_comparator,</a>
<a name="ln765">               const Message* message1, const Message* message2,</a>
<a name="ln766">               const std::vector&lt;SpecificField&gt;&amp; parent_fields,</a>
<a name="ln767">               int index1, int index2);</a>
<a name="ln768"> </a>
<a name="ln769">  // Returns true when this repeated field has been configured to be treated</a>
<a name="ln770">  // as a set.</a>
<a name="ln771">  bool IsTreatedAsSet(const FieldDescriptor* field);</a>
<a name="ln772"> </a>
<a name="ln773">  // Returns true when this repeated field is to be compared as a subset, ie.</a>
<a name="ln774">  // has been configured to be treated as a set or map and scope is set to</a>
<a name="ln775">  // PARTIAL.</a>
<a name="ln776">  bool IsTreatedAsSubset(const FieldDescriptor* field);</a>
<a name="ln777"> </a>
<a name="ln778">  // Returns true if this field is to be ignored when this</a>
<a name="ln779">  // MessageDifferencer compares messages.</a>
<a name="ln780">  bool IsIgnored(</a>
<a name="ln781">      const Message&amp; message1,</a>
<a name="ln782">      const Message&amp; message2,</a>
<a name="ln783">      const FieldDescriptor* field,</a>
<a name="ln784">      const std::vector&lt;SpecificField&gt;&amp; parent_fields);</a>
<a name="ln785"> </a>
<a name="ln786">  // Returns true if this unknown field is to be ignored when this</a>
<a name="ln787">  // MessageDifferencer compares messages.</a>
<a name="ln788">  bool IsUnknownFieldIgnored(const Message&amp; message1, const Message&amp; message2,</a>
<a name="ln789">                             const SpecificField&amp; field,</a>
<a name="ln790">                             const std::vector&lt;SpecificField&gt;&amp; parent_fields);</a>
<a name="ln791"> </a>
<a name="ln792">  // Returns MapKeyComparator* when this field has been configured to be treated</a>
<a name="ln793">  // as a map or its is_map() return true.  If not, returns NULL.</a>
<a name="ln794">  const MapKeyComparator* GetMapKeyComparator(</a>
<a name="ln795">      const FieldDescriptor* field) const;</a>
<a name="ln796"> </a>
<a name="ln797">  // Attempts to match indices of a repeated field, so that the contained values</a>
<a name="ln798">  // match. Clears output vectors and sets their values to indices of paired</a>
<a name="ln799">  // messages, ie. if message1[0] matches message2[1], then match_list1[0] == 1</a>
<a name="ln800">  // and match_list2[1] == 0. The unmatched indices are indicated by -1.</a>
<a name="ln801">  // This method returns false if the match failed. However, it doesn't mean</a>
<a name="ln802">  // that the comparison succeeds when this method returns true (you need to</a>
<a name="ln803">  // double-check in this case).</a>
<a name="ln804">  bool MatchRepeatedFieldIndices(</a>
<a name="ln805">      const Message&amp; message1,</a>
<a name="ln806">      const Message&amp; message2,</a>
<a name="ln807">      const FieldDescriptor* repeated_field,</a>
<a name="ln808">      const std::vector&lt;SpecificField&gt;&amp; parent_fields,</a>
<a name="ln809">      std::vector&lt;int&gt;* match_list1,</a>
<a name="ln810">      std::vector&lt;int&gt;* match_list2);</a>
<a name="ln811"> </a>
<a name="ln812">  // If &quot;any&quot; is of type google.protobuf.Any, extract its payload using</a>
<a name="ln813">  // DynamicMessageFactory and store in &quot;data&quot;.</a>
<a name="ln814">  bool UnpackAny(const Message&amp; any, google::protobuf::scoped_ptr&lt;Message&gt;* data);</a>
<a name="ln815"> </a>
<a name="ln816">  // Checks if index is equal to new_index in all the specific fields.</a>
<a name="ln817">  static bool CheckPathChanged(const std::vector&lt;SpecificField&gt;&amp; parent_fields);</a>
<a name="ln818"> </a>
<a name="ln819">  // Defines a map between field descriptors and their MapKeyComparators.</a>
<a name="ln820">  // Used for repeated fields when they are configured as TreatAsMap.</a>
<a name="ln821">  typedef std::map&lt;const FieldDescriptor*,</a>
<a name="ln822">              const MapKeyComparator*&gt; FieldKeyComparatorMap;</a>
<a name="ln823"> </a>
<a name="ln824">  // Defines a set to store field descriptors.  Used for repeated fields when</a>
<a name="ln825">  // they are configured as TreatAsSet.</a>
<a name="ln826">  typedef std::set&lt;const FieldDescriptor*&gt; FieldSet;</a>
<a name="ln827"> </a>
<a name="ln828">  Reporter* reporter_;</a>
<a name="ln829">  DefaultFieldComparator default_field_comparator_;</a>
<a name="ln830">  FieldComparator* field_comparator_;</a>
<a name="ln831">  MessageFieldComparison message_field_comparison_;</a>
<a name="ln832">  Scope scope_;</a>
<a name="ln833">  RepeatedFieldComparison repeated_field_comparison_;</a>
<a name="ln834"> </a>
<a name="ln835">  FieldSet set_fields_;</a>
<a name="ln836">  FieldSet list_fields_;</a>
<a name="ln837">  // Keeps track of MapKeyComparators that are created within</a>
<a name="ln838">  // MessageDifferencer. These MapKeyComparators should be deleted</a>
<a name="ln839">  // before MessageDifferencer is destroyed.</a>
<a name="ln840">  // When TreatAsMap or TreatAsMapWithMultipleFieldsAsKey is called, we don't</a>
<a name="ln841">  // store the supplied FieldDescriptors directly. Instead, a new</a>
<a name="ln842">  // MapKeyComparator is created for comparison purpose.</a>
<a name="ln843">  std::vector&lt;MapKeyComparator*&gt; owned_key_comparators_;</a>
<a name="ln844">  FieldKeyComparatorMap map_field_key_comparator_;</a>
<a name="ln845">  MapEntryKeyComparator map_entry_key_comparator_;</a>
<a name="ln846">  std::vector&lt;IgnoreCriteria*&gt; ignore_criteria_;</a>
<a name="ln847"> </a>
<a name="ln848">  FieldSet ignored_fields_;</a>
<a name="ln849"> </a>
<a name="ln850">  bool report_matches_;</a>
<a name="ln851">  bool report_moves_;</a>
<a name="ln852"> </a>
<a name="ln853">  string* output_string_;</a>
<a name="ln854"> </a>
<a name="ln855">  google::protobuf::scoped_ptr&lt;DynamicMessageFactory&gt; dynamic_message_factory_;</a>
<a name="ln856">  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(MessageDifferencer);</a>
<a name="ln857">};</a>
<a name="ln858"> </a>
<a name="ln859">// This class provides extra information to the FieldComparator::Compare</a>
<a name="ln860">// function.</a>
<a name="ln861">class LIBPROTOBUF_EXPORT FieldContext {</a>
<a name="ln862"> public:</a>
<a name="ln863">  explicit FieldContext(</a>
<a name="ln864">      std::vector&lt;MessageDifferencer::SpecificField&gt;* parent_fields)</a>
<a name="ln865">      : parent_fields_(parent_fields) {}</a>
<a name="ln866"> </a>
<a name="ln867">  std::vector&lt;MessageDifferencer::SpecificField&gt;* parent_fields() const {</a>
<a name="ln868">    return parent_fields_;</a>
<a name="ln869">  }</a>
<a name="ln870"> </a>
<a name="ln871"> private:</a>
<a name="ln872">  std::vector&lt;MessageDifferencer::SpecificField&gt;* parent_fields_;</a>
<a name="ln873">};</a>
<a name="ln874"> </a>
<a name="ln875">}</a>
<a name="ln876">}</a>
<a name="ln877"> </a>
<a name="ln878">}  // namespace google</a>
<a name="ln879">#endif  // GOOGLE_PROTOBUF_UTIL_MESSAGE_DIFFERENCER_H__</a>

</code></pre>
<div class="balloon" rel="196"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: unknown_field_type.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
