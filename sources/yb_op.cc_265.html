
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>yb_op.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Licensed to the Apache Software Foundation (ASF) under one</a>
<a name="ln2">// or more contributor license agreements.  See the NOTICE file</a>
<a name="ln3">// distributed with this work for additional information</a>
<a name="ln4">// regarding copyright ownership.  The ASF licenses this file</a>
<a name="ln5">// to you under the Apache License, Version 2.0 (the</a>
<a name="ln6">// &quot;License&quot;); you may not use this file except in compliance</a>
<a name="ln7">// with the License.  You may obtain a copy of the License at</a>
<a name="ln8">//</a>
<a name="ln9">//   http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln10">//</a>
<a name="ln11">// Unless required by applicable law or agreed to in writing,</a>
<a name="ln12">// software distributed under the License is distributed on an</a>
<a name="ln13">// &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</a>
<a name="ln14">// KIND, either express or implied.  See the License for the</a>
<a name="ln15">// specific language governing permissions and limitations</a>
<a name="ln16">// under the License.</a>
<a name="ln17">//</a>
<a name="ln18">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln19">//</a>
<a name="ln20">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln21">//</a>
<a name="ln22">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln23">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln24">//</a>
<a name="ln25">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln26">//</a>
<a name="ln27">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln28">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln29">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln30">// under the License.</a>
<a name="ln31">//</a>
<a name="ln32"> </a>
<a name="ln33">#include &quot;yb/client/yb_op.h&quot;</a>
<a name="ln34"> </a>
<a name="ln35">#include &quot;yb/client/client.h&quot;</a>
<a name="ln36">#include &quot;yb/client/client-internal.h&quot;</a>
<a name="ln37">#include &quot;yb/client/meta_cache.h&quot;</a>
<a name="ln38">#include &quot;yb/client/table.h&quot;</a>
<a name="ln39"> </a>
<a name="ln40">#include &quot;yb/common/row.h&quot;</a>
<a name="ln41">#include &quot;yb/common/row_mark.h&quot;</a>
<a name="ln42">#include &quot;yb/common/wire_protocol.pb.h&quot;</a>
<a name="ln43">#include &quot;yb/common/wire_protocol.h&quot;</a>
<a name="ln44">#include &quot;yb/common/redis_protocol.pb.h&quot;</a>
<a name="ln45">#include &quot;yb/common/ql_protocol.pb.h&quot;</a>
<a name="ln46">#include &quot;yb/common/ql_rowblock.h&quot;</a>
<a name="ln47">#include &quot;yb/common/ql_scanspec.h&quot;</a>
<a name="ln48">#include &quot;yb/common/ql_type.h&quot;</a>
<a name="ln49">#include &quot;yb/common/ql_value.h&quot;</a>
<a name="ln50"> </a>
<a name="ln51">#include &quot;yb/docdb/doc_key.h&quot;</a>
<a name="ln52">#include &quot;yb/docdb/doc_scanspec_util.h&quot;</a>
<a name="ln53">#include &quot;yb/docdb/primitive_value.h&quot;</a>
<a name="ln54"> </a>
<a name="ln55">#include &quot;yb/tserver/tserver.pb.h&quot;</a>
<a name="ln56">#include &quot;yb/tserver/tserver_service.proxy.h&quot;</a>
<a name="ln57"> </a>
<a name="ln58">#include &quot;yb/yql/cql/ql/util/errcodes.h&quot;</a>
<a name="ln59">#include &quot;yb/yql/redis/redisserver/redis_constants.h&quot;</a>
<a name="ln60"> </a>
<a name="ln61">#include &quot;yb/util/flag_tags.h&quot;</a>
<a name="ln62"> </a>
<a name="ln63">using namespace std::literals;</a>
<a name="ln64"> </a>
<a name="ln65">DEFINE_bool(redis_allow_reads_from_followers, false,</a>
<a name="ln66">            &quot;If true, the read will be served from the closest replica in the same AZ, which can &quot;</a>
<a name="ln67">            &quot;be a follower.&quot;);</a>
<a name="ln68">TAG_FLAG(redis_allow_reads_from_followers, evolving);</a>
<a name="ln69">TAG_FLAG(redis_allow_reads_from_followers, runtime);</a>
<a name="ln70"> </a>
<a name="ln71">namespace yb {</a>
<a name="ln72">namespace client {</a>
<a name="ln73"> </a>
<a name="ln74">using std::shared_ptr;</a>
<a name="ln75">using std::unique_ptr;</a>
<a name="ln76">using common::QLScanRange;</a>
<a name="ln77"> </a>
<a name="ln78">//--------------------------------------------------------------------------------------------------</a>
<a name="ln79">// YBOperation</a>
<a name="ln80">//--------------------------------------------------------------------------------------------------</a>
<a name="ln81"> </a>
<a name="ln82">YBOperation::YBOperation(const shared_ptr&lt;YBTable&gt;&amp; table)</a>
<a name="ln83">  : table_(table) {</a>
<a name="ln84">}</a>
<a name="ln85"> </a>
<a name="ln86">YBOperation::~YBOperation() {}</a>
<a name="ln87"> </a>
<a name="ln88">void YBOperation::SetTablet(const scoped_refptr&lt;internal::RemoteTablet&gt;&amp; tablet) {</a>
<a name="ln89">  tablet_ = tablet;</a>
<a name="ln90">}</a>
<a name="ln91"> </a>
<a name="ln92">void YBOperation::ResetTable(std::shared_ptr&lt;YBTable&gt; new_table) {</a>
<a name="ln93">  table_.reset();</a>
<a name="ln94">  table_ = new_table;</a>
<a name="ln95">  // tablet_ can no longer be valid.</a>
<a name="ln96">  tablet_.reset();</a>
<a name="ln97">}</a>
<a name="ln98"> </a>
<a name="ln99">bool YBOperation::IsTransactional() const {</a>
<a name="ln100">  return table_-&gt;schema().table_properties().is_transactional();</a>
<a name="ln101">}</a>
<a name="ln102"> </a>
<a name="ln103">bool YBOperation::IsYsqlCatalogOp() const {</a>
<a name="ln104">  return table_-&gt;schema().table_properties().is_ysql_catalog_table();</a>
<a name="ln105">}</a>
<a name="ln106"> </a>
<a name="ln107">void YBOperation::MarkTablePartitionsAsStale() {</a>
<a name="ln108">  table_-&gt;MarkPartitionsAsStale();</a>
<a name="ln109">}</a>
<a name="ln110"> </a>
<a name="ln111">Result&lt;bool&gt; YBOperation::MaybeRefreshTablePartitions() {</a>
<a name="ln112">  return table_-&gt;MaybeRefreshPartitions();</a>
<a name="ln113">}</a>
<a name="ln114"> </a>
<a name="ln115">//--------------------------------------------------------------------------------------------------</a>
<a name="ln116">// YBRedisOp</a>
<a name="ln117">//--------------------------------------------------------------------------------------------------</a>
<a name="ln118"> </a>
<a name="ln119">YBRedisOp::YBRedisOp(const shared_ptr&lt;YBTable&gt;&amp; table)</a>
<a name="ln120">    : YBOperation(table) {</a>
<a name="ln121">}</a>
<a name="ln122"> </a>
<a name="ln123">RedisResponsePB* YBRedisOp::mutable_response() {</a>
<a name="ln124">  if (!redis_response_) {</a>
<a name="ln125">    redis_response_.reset(new RedisResponsePB());</a>
<a name="ln126">  }</a>
<a name="ln127">  return redis_response_.get();</a>
<a name="ln128">}</a>
<a name="ln129"> </a>
<a name="ln130">const RedisResponsePB&amp; YBRedisOp::response() const {</a>
<a name="ln131">  return *DCHECK_NOTNULL(redis_response_.get());</a>
<a name="ln132">}</a>
<a name="ln133"> </a>
<a name="ln134">OpGroup YBRedisReadOp::group() {</a>
<a name="ln135">  return FLAGS_redis_allow_reads_from_followers ? OpGroup::kConsistentPrefixRead</a>
<a name="ln136">                                                : OpGroup::kLeaderRead;</a>
<a name="ln137">}</a>
<a name="ln138"> </a>
<a name="ln139">// YBRedisWriteOp -----------------------------------------------------------------</a>
<a name="ln140"> </a>
<a name="ln141">YBRedisWriteOp::YBRedisWriteOp(const shared_ptr&lt;YBTable&gt;&amp; table)</a>
<a name="ln142">    : YBRedisOp(table), redis_write_request_(new RedisWriteRequestPB()) {</a>
<a name="ln143">}</a>
<a name="ln144"> </a>
<a name="ln145">size_t YBRedisWriteOp::space_used_by_request() const {</a>
<a name="ln146">  return redis_write_request_-&gt;ByteSizeLong();</a>
<a name="ln147">}</a>
<a name="ln148"> </a>
<a name="ln149">std::string YBRedisWriteOp::ToString() const {</a>
<a name="ln150">  return &quot;REDIS_WRITE &quot; + redis_write_request_-&gt;key_value().key();</a>
<a name="ln151">}</a>
<a name="ln152"> </a>
<a name="ln153">void YBRedisWriteOp::SetHashCode(uint16_t hash_code) {</a>
<a name="ln154">  hash_code_ = hash_code;</a>
<a name="ln155">  redis_write_request_-&gt;mutable_key_value()-&gt;set_hash_code(hash_code);</a>
<a name="ln156">}</a>
<a name="ln157"> </a>
<a name="ln158">const std::string&amp; YBRedisWriteOp::GetKey() const {</a>
<a name="ln159">  return redis_write_request_-&gt;key_value().key();</a>
<a name="ln160">}</a>
<a name="ln161"> </a>
<a name="ln162">Status YBRedisWriteOp::GetPartitionKey(std::string *partition_key) const {</a>
<a name="ln163">  const Slice&amp; slice(redis_write_request_-&gt;key_value().key());</a>
<a name="ln164">  return table_-&gt;partition_schema().EncodeRedisKey(slice, partition_key);</a>
<a name="ln165">}</a>
<a name="ln166"> </a>
<a name="ln167">// YBRedisReadOp -----------------------------------------------------------------</a>
<a name="ln168"> </a>
<a name="ln169">YBRedisReadOp::YBRedisReadOp(const shared_ptr&lt;YBTable&gt;&amp; table)</a>
<a name="ln170">    : YBRedisOp(table), redis_read_request_(new RedisReadRequestPB()) {</a>
<a name="ln171">}</a>
<a name="ln172"> </a>
<a name="ln173">size_t YBRedisReadOp::space_used_by_request() const {</a>
<a name="ln174">  return redis_read_request_-&gt;SpaceUsedLong();</a>
<a name="ln175">}</a>
<a name="ln176"> </a>
<a name="ln177">std::string YBRedisReadOp::ToString() const {</a>
<a name="ln178">  return &quot;REDIS_READ &quot; + redis_read_request_-&gt;key_value().key();</a>
<a name="ln179">}</a>
<a name="ln180"> </a>
<a name="ln181">void YBRedisReadOp::SetHashCode(uint16_t hash_code) {</a>
<a name="ln182">  hash_code_ = hash_code;</a>
<a name="ln183">  redis_read_request_-&gt;mutable_key_value()-&gt;set_hash_code(hash_code);</a>
<a name="ln184">}</a>
<a name="ln185"> </a>
<a name="ln186">const std::string&amp; YBRedisReadOp::GetKey() const {</a>
<a name="ln187">  return redis_read_request_-&gt;key_value().key();</a>
<a name="ln188">}</a>
<a name="ln189"> </a>
<a name="ln190">Status YBRedisReadOp::GetPartitionKey(std::string *partition_key) const {</a>
<a name="ln191">  if (!redis_read_request_-&gt;key_value().has_key()) {</a>
<a name="ln192">    *partition_key =</a>
<a name="ln193">        PartitionSchema::EncodeMultiColumnHashValue(redis_read_request_-&gt;key_value().hash_code());</a>
<a name="ln194">    return Status::OK();</a>
<a name="ln195">  }</a>
<a name="ln196">  const Slice&amp; slice(redis_read_request_-&gt;key_value().key());</a>
<a name="ln197">  return table_-&gt;partition_schema().EncodeRedisKey(slice, partition_key);</a>
<a name="ln198">}</a>
<a name="ln199"> </a>
<a name="ln200">//--------------------------------------------------------------------------------------------------</a>
<a name="ln201">// YBCql Operators</a>
<a name="ln202">// - These ops should be prefixed with YBCql instead of YBql.</a>
<a name="ln203">// - The prefixes &quot;ql&quot; or &quot;QL&quot; are used for common entities of all languages and not just CQL.</a>
<a name="ln204">// - The name will be clean up later.</a>
<a name="ln205">//--------------------------------------------------------------------------------------------------</a>
<a name="ln206"> </a>
<a name="ln207">YBqlOp::YBqlOp(const shared_ptr&lt;YBTable&gt;&amp; table)</a>
<a name="ln208">      : YBOperation(table) , ql_response_(new QLResponsePB()) {</a>
<a name="ln209">}</a>
<a name="ln210"> </a>
<a name="ln211">YBqlOp::~YBqlOp() {</a>
<a name="ln212">}</a>
<a name="ln213"> </a>
<a name="ln214">// YBqlWriteOp -----------------------------------------------------------------</a>
<a name="ln215"> </a>
<a name="ln216">YBqlWriteOp::YBqlWriteOp(const shared_ptr&lt;YBTable&gt;&amp; table)</a>
<a name="ln217">    : YBqlOp(table), ql_write_request_(new QLWriteRequestPB()) {</a>
<a name="ln218">}</a>
<a name="ln219"> </a>
<a name="ln220">YBqlWriteOp::~YBqlWriteOp() {}</a>
<a name="ln221"> </a>
<a name="ln222">static std::unique_ptr&lt;YBqlWriteOp&gt; NewYBqlWriteOp(const shared_ptr&lt;YBTable&gt;&amp; table,</a>
<a name="ln223">                                                   QLWriteRequestPB::QLStmtType stmt_type) {</a>
<a name="ln224">  auto op = std::unique_ptr&lt;YBqlWriteOp&gt;(new YBqlWriteOp(table));</a>
<a name="ln225">  QLWriteRequestPB* req = op-&gt;mutable_request();</a>
<a name="ln226">  req-&gt;set_type(stmt_type);</a>
<a name="ln227">  req-&gt;set_client(YQL_CLIENT_CQL);</a>
<a name="ln228">  // TODO: Request ID should be filled with CQL stream ID. Query ID should be replaced too.</a>
<a name="ln229">  req-&gt;set_request_id(reinterpret_cast&lt;uint64_t&gt;(op.get()));</a>
<a name="ln230">  req-&gt;set_query_id(op-&gt;GetQueryId());</a>
<a name="ln231"> </a>
<a name="ln232">  req-&gt;set_schema_version(table-&gt;schema().version());</a>
<a name="ln233"> </a>
<a name="ln234">  return op;</a>
<a name="ln235">}</a>
<a name="ln236"> </a>
<a name="ln237">std::unique_ptr&lt;YBqlWriteOp&gt; YBqlWriteOp::NewInsert(const std::shared_ptr&lt;YBTable&gt;&amp; table) {</a>
<a name="ln238">  return NewYBqlWriteOp(table, QLWriteRequestPB::QL_STMT_INSERT);</a>
<a name="ln239">}</a>
<a name="ln240"> </a>
<a name="ln241">std::unique_ptr&lt;YBqlWriteOp&gt; YBqlWriteOp::NewUpdate(const std::shared_ptr&lt;YBTable&gt;&amp; table) {</a>
<a name="ln242">  return NewYBqlWriteOp(table, QLWriteRequestPB::QL_STMT_UPDATE);</a>
<a name="ln243">}</a>
<a name="ln244"> </a>
<a name="ln245">std::unique_ptr&lt;YBqlWriteOp&gt; YBqlWriteOp::NewDelete(const std::shared_ptr&lt;YBTable&gt;&amp; table) {</a>
<a name="ln246">  return NewYBqlWriteOp(table, QLWriteRequestPB::QL_STMT_DELETE);</a>
<a name="ln247">}</a>
<a name="ln248"> </a>
<a name="ln249">std::string YBqlWriteOp::ToString() const {</a>
<a name="ln250">  return &quot;QL_WRITE &quot; + ql_write_request_-&gt;ShortDebugString();</a>
<a name="ln251">}</a>
<a name="ln252"> </a>
<a name="ln253">Status YBqlWriteOp::GetPartitionKey(string* partition_key) const {</a>
<a name="ln254">  return table_-&gt;partition_schema().EncodeKey(ql_write_request_-&gt;hashed_column_values(),</a>
<a name="ln255">                                              partition_key);</a>
<a name="ln256">}</a>
<a name="ln257"> </a>
<a name="ln258">void YBqlWriteOp::SetHashCode(const uint16_t hash_code) {</a>
<a name="ln259">  ql_write_request_-&gt;set_hash_code(hash_code);</a>
<a name="ln260">}</a>
<a name="ln261"> </a>
<a name="ln262">uint16_t YBqlWriteOp::GetHashCode() const {</a>
<a name="ln263">  return ql_write_request_-&gt;hash_code();</a>
<a name="ln264">}</a>
<a name="ln265"> </a>
<a name="ln266">bool YBqlWriteOp::ReadsStaticRow() const {</a>
<a name="ln267">  // A QL write op reads the static row if it reads a static column, or it writes to the static row</a>
<a name="ln268">  // and has a user-defined timestamp (which DocDB requires a read-modify-write by the timestamp).</a>
<a name="ln269">  return !ql_write_request_-&gt;column_refs().static_ids().empty() ||</a>
<a name="ln270">         (writes_static_row_ &amp;&amp; ql_write_request_-&gt;has_user_timestamp_usec());</a>
<a name="ln271">}</a>
<a name="ln272"> </a>
<a name="ln273">bool YBqlWriteOp::ReadsPrimaryRow() const {</a>
<a name="ln274">  // A QL write op reads the primary row reads a non-static column, it writes to the primary row</a>
<a name="ln275">  // and has a user-defined timestamp (which DocDB requires a read-modify-write by the timestamp),</a>
<a name="ln276">  // or if there is an IF clause.</a>
<a name="ln277">  return !ql_write_request_-&gt;column_refs().ids().empty() ||</a>
<a name="ln278">         (writes_primary_row_ &amp;&amp; ql_write_request_-&gt;has_user_timestamp_usec()) ||</a>
<a name="ln279">         ql_write_request_-&gt;has_if_expr();</a>
<a name="ln280">}</a>
<a name="ln281"> </a>
<a name="ln282">bool YBqlWriteOp::WritesStaticRow() const {</a>
<a name="ln283">  return writes_static_row_;</a>
<a name="ln284">}</a>
<a name="ln285"> </a>
<a name="ln286">bool YBqlWriteOp::WritesPrimaryRow() const {</a>
<a name="ln287">  return writes_primary_row_;</a>
<a name="ln288">}</a>
<a name="ln289"> </a>
<a name="ln290">// YBqlWriteOp::HashHash/Equal ---------------------------------------------------------------</a>
<a name="ln291">size_t YBqlWriteOp::HashKeyComparator::operator() (const YBqlWriteOpPtr&amp; op) const {</a>
<a name="ln292">  size_t hash = 0;</a>
<a name="ln293"> </a>
<a name="ln294">  // Hash the table id.</a>
<a name="ln295">  boost::hash_combine(hash, op-&gt;table()-&gt;id());</a>
<a name="ln296"> </a>
<a name="ln297">  // Hash the hash key.</a>
<a name="ln298">  string key;</a>
<a name="ln299">  for (const auto&amp; value : op-&gt;request().hashed_column_values()) {</a>
<a name="ln300">    AppendToKey(value.value(), &amp;key);</a>
<a name="ln301">  }</a>
<a name="ln302">  boost::hash_combine(hash, key);</a>
<a name="ln303"> </a>
<a name="ln304">  return hash;</a>
<a name="ln305">}</a>
<a name="ln306"> </a>
<a name="ln307">bool YBqlWriteOp::HashKeyComparator::operator() (const YBqlWriteOpPtr&amp; op1,</a>
<a name="ln308">                                                 const YBqlWriteOpPtr&amp; op2) const {</a>
<a name="ln309">  // Check if two write ops overlap that they apply to the same hash key in the same table.</a>
<a name="ln310">  if (op1-&gt;table() != op2-&gt;table() &amp;&amp; op1-&gt;table()-&gt;id() != op2-&gt;table()-&gt;id()) {</a>
<a name="ln311">    return false;</a>
<a name="ln312">  }</a>
<a name="ln313">  const QLWriteRequestPB&amp; req1 = op1-&gt;request();</a>
<a name="ln314">  const QLWriteRequestPB&amp; req2 = op2-&gt;request();</a>
<a name="ln315">  if (req1.hashed_column_values_size() != req2.hashed_column_values_size()) {</a>
<a name="ln316">    return false;</a>
<a name="ln317">  }</a>
<a name="ln318">  for (int i = 0; i &lt; req1.hashed_column_values().size(); i++) {</a>
<a name="ln319">    DCHECK(req1.hashed_column_values()[i].has_value());</a>
<a name="ln320">    DCHECK(req2.hashed_column_values()[i].has_value());</a>
<a name="ln321">    if (req1.hashed_column_values()[i].value() != req2.hashed_column_values()[i].value())</a>
<a name="ln322">      return false;</a>
<a name="ln323">  }</a>
<a name="ln324">  return true;</a>
<a name="ln325">}</a>
<a name="ln326"> </a>
<a name="ln327">// YBqlWriteOp::PrimaryHash/Equal ---------------------------------------------------------------</a>
<a name="ln328">size_t YBqlWriteOp::PrimaryKeyComparator::operator() (const YBqlWriteOpPtr&amp; op) const {</a>
<a name="ln329">  size_t hash = YBqlWriteOp::HashKeyComparator::operator()(op);</a>
<a name="ln330"> </a>
<a name="ln331">  // Hash the range key also.</a>
<a name="ln332">  string key;</a>
<a name="ln333">  for (const auto&amp; value : op-&gt;request().range_column_values()) {</a>
<a name="ln334">    AppendToKey(value.value(), &amp;key);</a>
<a name="ln335">  }</a>
<a name="ln336">  boost::hash_combine(hash, key);</a>
<a name="ln337"> </a>
<a name="ln338">  return hash;</a>
<a name="ln339">}</a>
<a name="ln340"> </a>
<a name="ln341">bool YBqlWriteOp::PrimaryKeyComparator::operator() (const YBqlWriteOpPtr&amp; op1,</a>
<a name="ln342">                                                    const YBqlWriteOpPtr&amp; op2) const {</a>
<a name="ln343">  if (!YBqlWriteOp::HashKeyComparator::operator()(op1, op2)) {</a>
<a name="ln344">    return false;</a>
<a name="ln345">  }</a>
<a name="ln346"> </a>
<a name="ln347">  // Check if two write ops overlap that they apply to the range key also.</a>
<a name="ln348">  const QLWriteRequestPB&amp; req1 = op1-&gt;request();</a>
<a name="ln349">  const QLWriteRequestPB&amp; req2 = op2-&gt;request();</a>
<a name="ln350">  if (req1.range_column_values_size() != req2.range_column_values_size()) {</a>
<a name="ln351">    return false;</a>
<a name="ln352">  }</a>
<a name="ln353">  for (int i = 0; i &lt; req1.range_column_values().size(); i++) {</a>
<a name="ln354">    DCHECK(req1.range_column_values()[i].has_value());</a>
<a name="ln355">    DCHECK(req2.range_column_values()[i].has_value());</a>
<a name="ln356">    if (req1.range_column_values()[i].value() != req2.range_column_values()[i].value())</a>
<a name="ln357">      return false;</a>
<a name="ln358">  }</a>
<a name="ln359">  return true;</a>
<a name="ln360">}</a>
<a name="ln361"> </a>
<a name="ln362">// YBqlReadOp -----------------------------------------------------------------</a>
<a name="ln363"> </a>
<a name="ln364">YBqlReadOp::YBqlReadOp(const shared_ptr&lt;YBTable&gt;&amp; table)</a>
<a name="ln365">    : YBqlOp(table),</a>
<a name="ln366">      ql_read_request_(new QLReadRequestPB()),</a>
<a name="ln367">      yb_consistency_level_(YBConsistencyLevel::STRONG) {</a>
<a name="ln368">}</a>
<a name="ln369"> </a>
<a name="ln370">YBqlReadOp::~YBqlReadOp() {}</a>
<a name="ln371"> </a>
<a name="ln372">OpGroup YBqlReadOp::group() {</a>
<a name="ln373">  return yb_consistency_level_ == YBConsistencyLevel::CONSISTENT_PREFIX</a>
<a name="ln374">      ? OpGroup::kConsistentPrefixRead : OpGroup::kLeaderRead;</a>
<a name="ln375">}</a>
<a name="ln376"> </a>
<a name="ln377">std::unique_ptr&lt;YBqlReadOp&gt; YBqlReadOp::NewSelect(const shared_ptr&lt;YBTable&gt;&amp; table) {</a>
<a name="ln378">  std::unique_ptr&lt;YBqlReadOp&gt; op(new YBqlReadOp(table));</a>
<a name="ln379">  QLReadRequestPB *req = op-&gt;mutable_request();</a>
<a name="ln380">  req-&gt;set_client(YQL_CLIENT_CQL);</a>
<a name="ln381">  // TODO: Request ID should be filled with CQL stream ID. Query ID should be replaced too.</a>
<a name="ln382">  req-&gt;set_request_id(reinterpret_cast&lt;uint64_t&gt;(op.get()));</a>
<a name="ln383">  req-&gt;set_query_id(op-&gt;GetQueryId());</a>
<a name="ln384"> </a>
<a name="ln385">  req-&gt;set_schema_version(table-&gt;schema().version());</a>
<a name="ln386"> </a>
<a name="ln387">  return op;</a>
<a name="ln388">}</a>
<a name="ln389"> </a>
<a name="ln390">std::string YBqlReadOp::ToString() const {</a>
<a name="ln391">  return &quot;QL_READ &quot; + ql_read_request_-&gt;DebugString();</a>
<a name="ln392">}</a>
<a name="ln393"> </a>
<a name="ln394">void YBqlReadOp::SetHashCode(const uint16_t hash_code) {</a>
<a name="ln395">  ql_read_request_-&gt;set_hash_code(hash_code);</a>
<a name="ln396">}</a>
<a name="ln397"> </a>
<a name="ln398">Status YBqlReadOp::GetPartitionKey(string* partition_key) const {</a>
<a name="ln399">  if (!ql_read_request_-&gt;hashed_column_values().empty()) {</a>
<a name="ln400">    // If hashed columns are set, use them to compute the exact key and set the bounds</a>
<a name="ln401">    RETURN_NOT_OK(table_-&gt;partition_schema().EncodeKey(ql_read_request_-&gt;hashed_column_values(),</a>
<a name="ln402">        partition_key));</a>
<a name="ln403"> </a>
<a name="ln404">    // TODO: If user specified token range doesn't contain the hash columns specified then the query</a>
<a name="ln405">    // will have no effect. We need to implement an exit path rather than requesting the tablets.</a>
<a name="ln406">    // For now, we set point query some value that is not equal to the hash to the hash columns</a>
<a name="ln407">    // Which will return no result.</a>
<a name="ln408"> </a>
<a name="ln409">    // Make sure given key is not smaller than lower bound (if any)</a>
<a name="ln410">    if (ql_read_request_-&gt;has_hash_code()) {</a>
<a name="ln411">      uint16 hash_code = static_cast&lt;uint16&gt;(ql_read_request_-&gt;hash_code());</a>
<a name="ln412">      auto lower_bound = PartitionSchema::EncodeMultiColumnHashValue(hash_code);</a>
<a name="ln413">      if (*partition_key &lt; lower_bound) *partition_key = std::move(lower_bound);</a>
<a name="ln414">    }</a>
<a name="ln415"> </a>
<a name="ln416">    // Make sure given key is not bigger than upper bound (if any)</a>
<a name="ln417">    if (ql_read_request_-&gt;has_max_hash_code()) {</a>
<a name="ln418">      uint16 hash_code = static_cast&lt;uint16&gt;(ql_read_request_-&gt;max_hash_code());</a>
<a name="ln419">      auto upper_bound = PartitionSchema::EncodeMultiColumnHashValue(hash_code);</a>
<a name="ln420">      if (*partition_key &gt; upper_bound) *partition_key = std::move(upper_bound);</a>
<a name="ln421">    }</a>
<a name="ln422"> </a>
<a name="ln423">    // Set both bounds to equal partition key now, because this is a point get</a>
<a name="ln424">    ql_read_request_-&gt;set_hash_code(</a>
<a name="ln425">          PartitionSchema::DecodeMultiColumnHashValue(*partition_key));</a>
<a name="ln426">    ql_read_request_-&gt;set_max_hash_code(</a>
<a name="ln427">          PartitionSchema::DecodeMultiColumnHashValue(*partition_key));</a>
<a name="ln428">  } else {</a>
<a name="ln429">    // Otherwise, set the partition key to the hash_code (lower bound of the token range).</a>
<a name="ln430">    if (ql_read_request_-&gt;has_hash_code()) {</a>
<a name="ln431">      uint16 hash_code = static_cast&lt;uint16&gt;(ql_read_request_-&gt;hash_code());</a>
<a name="ln432">      *partition_key = PartitionSchema::EncodeMultiColumnHashValue(hash_code);</a>
<a name="ln433">    } else {</a>
<a name="ln434">      // Default to empty key, this will start a scan from the beginning.</a>
<a name="ln435">      partition_key-&gt;clear();</a>
<a name="ln436">    }</a>
<a name="ln437">  }</a>
<a name="ln438"> </a>
<a name="ln439">  // If this is a continued query use the partition key from the paging state</a>
<a name="ln440">  // If paging state is there, set hash_code = paging state. This is only supported for forward</a>
<a name="ln441">  // scans.</a>
<a name="ln442">  if (ql_read_request_-&gt;has_paging_state() &amp;&amp;</a>
<a name="ln443">      ql_read_request_-&gt;paging_state().has_next_partition_key() &amp;&amp;</a>
<a name="ln444">      !ql_read_request_-&gt;paging_state().next_partition_key().empty()) {</a>
<a name="ln445">    *partition_key = ql_read_request_-&gt;paging_state().next_partition_key();</a>
<a name="ln446"> </a>
<a name="ln447">    // Check that the partition key we got from the paging state is within bounds.</a>
<a name="ln448">    uint16 paging_state_hash_code = PartitionSchema::DecodeMultiColumnHashValue(*partition_key);</a>
<a name="ln449">    if ((ql_read_request_-&gt;has_hash_code() &amp;&amp;</a>
<a name="ln450">            paging_state_hash_code &lt; ql_read_request_-&gt;hash_code()) ||</a>
<a name="ln451">        (ql_read_request_-&gt;has_max_hash_code() &amp;&amp;</a>
<a name="ln452">            paging_state_hash_code &gt; ql_read_request_-&gt;max_hash_code())) {</a>
<a name="ln453">    return STATUS_SUBSTITUTE(InternalError,</a>
<a name="ln454">                             &quot;Out of bounds partition key found in paging state:&quot;</a>
<a name="ln455">                             &quot;Query's partition bounds: [%d, %d], paging state partition: %d&quot;,</a>
<a name="ln456">                             ql_read_request_-&gt;hash_code(),</a>
<a name="ln457">                             ql_read_request_-&gt;max_hash_code() ,</a>
<a name="ln458">                             paging_state_hash_code);</a>
<a name="ln459">    }</a>
<a name="ln460"> </a>
<a name="ln461">    ql_read_request_-&gt;set_hash_code(paging_state_hash_code);</a>
<a name="ln462">  }</a>
<a name="ln463"> </a>
<a name="ln464">  return Status::OK();</a>
<a name="ln465">}</a>
<a name="ln466"> </a>
<a name="ln467">std::vector&lt;ColumnSchema&gt; MakeColumnSchemasFromColDesc(</a>
<a name="ln468">  const google::protobuf::RepeatedPtrField&lt;QLRSColDescPB&gt;&amp; rscol_descs) {</a>
<a name="ln469">  std::vector&lt;ColumnSchema&gt; column_schemas;</a>
<a name="ln470">  column_schemas.reserve(rscol_descs.size());</a>
<a name="ln471">  for (const auto&amp; rscol_desc : rscol_descs) {</a>
<a name="ln472">    column_schemas.emplace_back(rscol_desc.name(), QLType::FromQLTypePB(rscol_desc.ql_type()));</a>
<a name="ln473">  }</a>
<a name="ln474">  return column_schemas;</a>
<a name="ln475">}</a>
<a name="ln476"> </a>
<a name="ln477">std::vector&lt;ColumnSchema&gt; YBqlReadOp::MakeColumnSchemasFromRequest() const {</a>
<a name="ln478">  // Tests don't have access to the QL internal statement object, so they have to use rsrow</a>
<a name="ln479">  // descriptor from the read request.</a>
<a name="ln480">  return MakeColumnSchemasFromColDesc(request().rsrow_desc().rscol_descs());</a>
<a name="ln481">}</a>
<a name="ln482"> </a>
<a name="ln483">Result&lt;QLRowBlock&gt; YBqlReadOp::MakeRowBlock() const {</a>
<a name="ln484">  Schema schema(MakeColumnSchemasFromRequest(), 0);</a>
<a name="ln485">  QLRowBlock result(schema);</a>
<a name="ln486">  Slice data(rows_data_);</a>
<a name="ln487">  if (!data.empty()) {</a>
<a name="ln488">    RETURN_NOT_OK(result.Deserialize(request().client(), &amp;data));</a>
<a name="ln489">  }</a>
<a name="ln490">  return result;</a>
<a name="ln491">}</a>
<a name="ln492"> </a>
<a name="ln493">//--------------------------------------------------------------------------------------------------</a>
<a name="ln494">// YBPgsql Operators</a>
<a name="ln495">//--------------------------------------------------------------------------------------------------</a>
<a name="ln496"> </a>
<a name="ln497">YBPgsqlOp::YBPgsqlOp(const shared_ptr&lt;YBTable&gt;&amp; table)</a>
<a name="ln498">      : YBOperation(table) , response_(new PgsqlResponsePB()) {</a>
<a name="ln499">}</a>
<a name="ln500"> </a>
<a name="ln501">YBPgsqlOp::~YBPgsqlOp() {</a>
<a name="ln502">}</a>
<a name="ln503"> </a>
<a name="ln504">namespace {</a>
<a name="ln505"> </a>
<a name="ln506">Status GetRangeComponents(</a>
<a name="ln507">    const Schema&amp; schema, const google::protobuf::RepeatedPtrField&lt;PgsqlExpressionPB&gt;&amp; range_cols,</a>
<a name="ln508">    std::vector&lt;docdb::PrimitiveValue&gt;* range_components) {</a>
<a name="ln509">  int i = 0;</a>
<a name="ln510">  int num_range_key_columns = schema.num_range_key_columns();</a>
<a name="ln511">  for (const auto&amp; col_id : schema.column_ids()) {</a>
<a name="ln512">    if (!schema.is_range_column(col_id)) {</a>
<a name="ln513">      continue;</a>
<a name="ln514">    }</a>
<a name="ln515"> </a>
<a name="ln516">    const ColumnSchema&amp; column_schema = VERIFY_RESULT(schema.column_by_id(col_id));</a>
<a name="ln517">    if (i &gt;= range_cols.size() || range_cols[i].value().value_case() == QLValuePB::VALUE_NOT_SET) {</a>
<a name="ln518">      range_components-&gt;emplace_back(docdb::ValueType::kLowest);</a>
<a name="ln519">    } else {</a>
<a name="ln520">      range_components-&gt;push_back(docdb::PrimitiveValue::FromQLValuePB(</a>
<a name="ln521">          range_cols[i].value(), column_schema.sorting_type()));</a>
<a name="ln522">    }</a>
<a name="ln523"> </a>
<a name="ln524">    i++;</a>
<a name="ln525">    if (i == num_range_key_columns) {</a>
<a name="ln526">      break;</a>
<a name="ln527">    }</a>
<a name="ln528">  }</a>
<a name="ln529">  return Status::OK();</a>
<a name="ln530">}</a>
<a name="ln531"> </a>
<a name="ln532">CHECKED_STATUS GetRangePartitionKey(</a>
<a name="ln533">    const Schema&amp; schema, const google::protobuf::RepeatedPtrField&lt;PgsqlExpressionPB&gt;&amp; range_cols,</a>
<a name="ln534">    std::string* key) {</a>
<a name="ln535">  vector&lt;docdb::PrimitiveValue&gt; range_components;</a>
<a name="ln536">  DSCHECK(!schema.num_hash_key_columns(), IllegalState,</a>
<a name="ln537">      &quot;Cannot get range partition key for hash partitioned table&quot;);</a>
<a name="ln538"> </a>
<a name="ln539">  RETURN_NOT_OK(GetRangeComponents(schema, range_cols, &amp;range_components));</a>
<a name="ln540">  *key = docdb::DocKey(std::move(range_components)).Encode().ToStringBuffer();</a>
<a name="ln541">  return Status::OK();</a>
<a name="ln542">}</a>
<a name="ln543"> </a>
<a name="ln544">CHECKED_STATUS GetRangePartitionBounds(const YBPgsqlReadOp&amp; op,</a>
<a name="ln545">                                       vector&lt;docdb::PrimitiveValue&gt;* lower_bound,</a>
<a name="ln546">                                       vector&lt;docdb::PrimitiveValue&gt;* upper_bound) {</a>
<a name="ln547">  const auto&amp; schema = op.table()-&gt;InternalSchema();</a>
<a name="ln548">  SCHECK(!schema.num_hash_key_columns(), IllegalState,</a>
<a name="ln549">         &quot;Cannot set range partition key for hash partitioned table&quot;);</a>
<a name="ln550">  const auto&amp; request = op.request();</a>
<a name="ln551">  const auto&amp; range_cols = request.range_column_values();</a>
<a name="ln552">  const auto&amp; condition_expr = request.condition_expr();</a>
<a name="ln553">  if (range_cols.size() &gt; 0) {</a>
<a name="ln554">    RETURN_NOT_OK(GetRangeComponents(schema, range_cols, lower_bound));</a>
<a name="ln555">    *upper_bound = *lower_bound;</a>
<a name="ln556">    upper_bound-&gt;emplace_back(docdb::ValueType::kHighest);</a>
<a name="ln557">  } else if (condition_expr.has_condition()) {</a>
<a name="ln558">    QLScanRange scan_range(schema, condition_expr.condition());</a>
<a name="ln559">    *lower_bound = docdb::GetRangeKeyScanSpec(schema, &amp;scan_range, true /* lower bound */);</a>
<a name="ln560">    *upper_bound = docdb::GetRangeKeyScanSpec(schema, &amp;scan_range, false /* upper bound */);</a>
<a name="ln561">  }</a>
<a name="ln562">  return Status::OK();</a>
<a name="ln563">}</a>
<a name="ln564"> </a>
<a name="ln565">CHECKED_STATUS SetRangePartitionBounds(const YBPgsqlReadOp&amp; op,</a>
<a name="ln566">                                       std::string* key,</a>
<a name="ln567">                                       std::string* key_upper_bound) {</a>
<a name="ln568">  vector&lt;docdb::PrimitiveValue&gt; range_components, range_components_end;</a>
<a name="ln569">  RETURN_NOT_OK(GetRangePartitionBounds(op, &amp;range_components, &amp;range_components_end));</a>
<a name="ln570">  if (range_components.empty() &amp;&amp; range_components_end.empty()) {</a>
<a name="ln571">    if (op.request().is_forward_scan()) {</a>
<a name="ln572">      key-&gt;clear();</a>
<a name="ln573">    } else {</a>
<a name="ln574">      // In case of backward scan process must be start from the last partition.</a>
<a name="ln575">      *key = op.table()-&gt;GetPartitions().back();</a>
<a name="ln576">    }</a>
<a name="ln577">    key_upper_bound-&gt;clear();</a>
<a name="ln578">    return Status::OK();</a>
<a name="ln579">  }</a>
<a name="ln580">  auto upper_bound_key = docdb::DocKey(std::move(range_components_end)).Encode().ToStringBuffer();</a>
<a name="ln581">  if (op.request().is_forward_scan()) {</a>
<a name="ln582">    *key = docdb::DocKey(std::move(range_components)).Encode().ToStringBuffer();</a>
<a name="ln583">    *key_upper_bound = std::move(upper_bound_key);</a>
<a name="ln584">  } else {</a>
<a name="ln585">    // Backward scan should go from upper bound to lower. But because DocDB can check upper bound</a>
<a name="ln586">    // only it is not set here. Lower bound will be checked on client side in the</a>
<a name="ln587">    // ReviewResponsePagingState function.</a>
<a name="ln588">    *key = std::move(upper_bound_key);</a>
<a name="ln589">    key_upper_bound-&gt;clear();</a>
<a name="ln590">  }</a>
<a name="ln591">  return Status::OK();</a>
<a name="ln592">}</a>
<a name="ln593"> </a>
<a name="ln594">} // namespace</a>
<a name="ln595"> </a>
<a name="ln596">//--------------------------------------------------------------------------------------------------</a>
<a name="ln597">// YBPgsqlWriteOp</a>
<a name="ln598"> </a>
<a name="ln599">YBPgsqlWriteOp::YBPgsqlWriteOp(const shared_ptr&lt;YBTable&gt;&amp; table)</a>
<a name="ln600">    : YBPgsqlOp(table), write_request_(new PgsqlWriteRequestPB()) {</a>
<a name="ln601">}</a>
<a name="ln602"> </a>
<a name="ln603">YBPgsqlWriteOp::~YBPgsqlWriteOp() {}</a>
<a name="ln604"> </a>
<a name="ln605">std::unique_ptr&lt;YBPgsqlWriteOp&gt; YBPgsqlWriteOp::DeepCopy() {</a>
<a name="ln606">  auto op = std::make_unique&lt;YBPgsqlWriteOp&gt;(table_);</a>
<a name="ln607">  op-&gt;mutable_request()-&gt;CopyFrom(request());</a>
<a name="ln608">  op-&gt;set_is_single_row_txn(is_single_row_txn_);</a>
<a name="ln609">  op-&gt;SetTablet(tablet());</a>
<a name="ln610">  return op;</a>
<a name="ln611">}</a>
<a name="ln612"> </a>
<a name="ln613">static std::unique_ptr&lt;YBPgsqlWriteOp&gt; NewYBPgsqlWriteOp(</a>
<a name="ln614">    const shared_ptr&lt;YBTable&gt;&amp; table,</a>
<a name="ln615">    PgsqlWriteRequestPB::PgsqlStmtType stmt_type) {</a>
<a name="ln616">  auto op = std::make_unique&lt;YBPgsqlWriteOp&gt;(table);</a>
<a name="ln617">  PgsqlWriteRequestPB *req = op-&gt;mutable_request();</a>
<a name="ln618">  req-&gt;set_stmt_type(stmt_type);</a>
<a name="ln619">  req-&gt;set_client(YQL_CLIENT_PGSQL);</a>
<a name="ln620">  req-&gt;set_table_id(table-&gt;id());</a>
<a name="ln621">  req-&gt;set_schema_version(table-&gt;schema().version());</a>
<a name="ln622">  req-&gt;set_stmt_id(op-&gt;GetQueryId());</a>
<a name="ln623"> </a>
<a name="ln624">  return op;</a>
<a name="ln625">}</a>
<a name="ln626"> </a>
<a name="ln627">std::unique_ptr&lt;YBPgsqlWriteOp&gt; YBPgsqlWriteOp::NewInsert(const std::shared_ptr&lt;YBTable&gt;&amp; table) {</a>
<a name="ln628">  return NewYBPgsqlWriteOp(table, PgsqlWriteRequestPB::PGSQL_INSERT);</a>
<a name="ln629">}</a>
<a name="ln630"> </a>
<a name="ln631">std::unique_ptr&lt;YBPgsqlWriteOp&gt; YBPgsqlWriteOp::NewUpdate(const std::shared_ptr&lt;YBTable&gt;&amp; table) {</a>
<a name="ln632">  return NewYBPgsqlWriteOp(table, PgsqlWriteRequestPB::PGSQL_UPDATE);</a>
<a name="ln633">}</a>
<a name="ln634"> </a>
<a name="ln635">std::unique_ptr&lt;YBPgsqlWriteOp&gt; YBPgsqlWriteOp::NewDelete(const std::shared_ptr&lt;YBTable&gt;&amp; table) {</a>
<a name="ln636">  return NewYBPgsqlWriteOp(table, PgsqlWriteRequestPB::PGSQL_DELETE);</a>
<a name="ln637">}</a>
<a name="ln638"> </a>
<a name="ln639">std::unique_ptr&lt;YBPgsqlWriteOp&gt; YBPgsqlWriteOp::NewTruncateColocated(</a>
<a name="ln640">    const std::shared_ptr&lt;YBTable&gt;&amp; table) {</a>
<a name="ln641">  return NewYBPgsqlWriteOp(table, PgsqlWriteRequestPB::PGSQL_TRUNCATE_COLOCATED);</a>
<a name="ln642">}</a>
<a name="ln643"> </a>
<a name="ln644">std::string YBPgsqlWriteOp::ToString() const {</a>
<a name="ln645">  return &quot;PGSQL_WRITE &quot; + write_request_-&gt;ShortDebugString() +</a>
<a name="ln646">         &quot;, response: &quot; + response().ShortDebugString();</a>
<a name="ln647">}</a>
<a name="ln648"> </a>
<a name="ln649">Status YBPgsqlWriteOp::GetPartitionKey(string* partition_key) const {</a>
<a name="ln650">  const auto&amp; ybctid = write_request_-&gt;ybctid_column_value().value();</a>
<a name="ln651">  if (table_-&gt;schema().num_hash_key_columns() &gt; 0) {</a>
<a name="ln652">    if (!IsNull(ybctid)) {</a>
<a name="ln653">      const uint16 hash_code = VERIFY_RESULT(docdb::DocKey::DecodeHash(ybctid.binary_value()));</a>
<a name="ln654">      write_request_-&gt;set_hash_code(hash_code);</a>
<a name="ln655">      *partition_key = PartitionSchema::EncodeMultiColumnHashValue(hash_code);</a>
<a name="ln656">      return Status::OK();</a>
<a name="ln657">    }</a>
<a name="ln658"> </a>
<a name="ln659">    // Computing the partition_key.</a>
<a name="ln660">    return table_-&gt;partition_schema().EncodeKey(write_request_-&gt;partition_column_values(),</a>
<a name="ln661">                                                partition_key);</a>
<a name="ln662">  } else {</a>
<a name="ln663">    // Range partitioned table</a>
<a name="ln664">    if (!IsNull(ybctid)) {</a>
<a name="ln665">      *partition_key = ybctid.binary_value();</a>
<a name="ln666">      return Status::OK();</a>
<a name="ln667">    }</a>
<a name="ln668"> </a>
<a name="ln669">    // Computing the range key.</a>
<a name="ln670">    return GetRangePartitionKey(table_-&gt;InternalSchema(),</a>
<a name="ln671">        write_request_-&gt;range_column_values(), partition_key);</a>
<a name="ln672">  }</a>
<a name="ln673">}</a>
<a name="ln674"> </a>
<a name="ln675">void YBPgsqlWriteOp::SetHashCode(const uint16_t hash_code) {</a>
<a name="ln676">  write_request_-&gt;set_hash_code(hash_code);</a>
<a name="ln677">}</a>
<a name="ln678"> </a>
<a name="ln679">bool YBPgsqlWriteOp::IsTransactional() const {</a>
<a name="ln680">  return !is_single_row_txn_ &amp;&amp; table_-&gt;schema().table_properties().is_transactional();</a>
<a name="ln681">}</a>
<a name="ln682"> </a>
<a name="ln683">//--------------------------------------------------------------------------------------------------</a>
<a name="ln684">// YBPgsqlReadOp</a>
<a name="ln685"> </a>
<a name="ln686">YBPgsqlReadOp::YBPgsqlReadOp(const shared_ptr&lt;YBTable&gt;&amp; table)</a>
<a name="ln687">    : YBPgsqlOp(table),</a>
<a name="ln688">      read_request_(new PgsqlReadRequestPB()),</a>
<a name="ln689">      yb_consistency_level_(YBConsistencyLevel::STRONG) {</a>
<a name="ln690">}</a>
<a name="ln691"> </a>
<a name="ln692">std::unique_ptr&lt;YBPgsqlReadOp&gt; YBPgsqlReadOp::NewSelect(const shared_ptr&lt;YBTable&gt;&amp; table) {</a>
<a name="ln693">  std::unique_ptr&lt;YBPgsqlReadOp&gt; op(new YBPgsqlReadOp(table));</a>
<a name="ln694">  PgsqlReadRequestPB *req = op-&gt;mutable_request();</a>
<a name="ln695">  req-&gt;set_client(YQL_CLIENT_PGSQL);</a>
<a name="ln696">  req-&gt;set_table_id(table-&gt;id());</a>
<a name="ln697">  req-&gt;set_schema_version(table-&gt;schema().version());</a>
<a name="ln698">  req-&gt;set_stmt_id(op-&gt;GetQueryId());</a>
<a name="ln699"> </a>
<a name="ln700">  return op;</a>
<a name="ln701">}</a>
<a name="ln702"> </a>
<a name="ln703">std::unique_ptr&lt;YBPgsqlReadOp&gt; YBPgsqlReadOp::DeepCopy() {</a>
<a name="ln704">  auto op = NewSelect(table_);</a>
<a name="ln705">  op-&gt;set_yb_consistency_level(yb_consistency_level());</a>
<a name="ln706">  op-&gt;SetReadTime(read_time());</a>
<a name="ln707">  op-&gt;SetTablet(tablet());</a>
<a name="ln708">  op-&gt;mutable_request()-&gt;CopyFrom(request());</a>
<a name="ln709">  return op;</a>
<a name="ln710">}</a>
<a name="ln711"> </a>
<a name="ln712">std::string YBPgsqlReadOp::ToString() const {</a>
<a name="ln713">  return &quot;PGSQL_READ &quot; + read_request_-&gt;DebugString();</a>
<a name="ln714">}</a>
<a name="ln715"> </a>
<a name="ln716">void YBPgsqlReadOp::SetHashCode(const uint16_t hash_code) {</a>
<a name="ln717">  read_request_-&gt;set_hash_code(hash_code);</a>
<a name="ln718">}</a>
<a name="ln719"> </a>
<a name="ln720">Status YBPgsqlReadOp::GetPartitionKey(string* partition_key) const {</a>
<a name="ln721">  const Schema schema = table_-&gt;InternalSchema();</a>
<a name="ln722">  if (!read_request_-&gt;partition_column_values().empty()) {</a>
<a name="ln723">    // If hashed columns are set, use them to compute the exact key and set the bounds</a>
<a name="ln724">    RETURN_NOT_OK(table_-&gt;partition_schema().EncodeKey(read_request_-&gt;partition_column_values(),</a>
<a name="ln725">        partition_key));</a>
<a name="ln726"> </a>
<a name="ln727">    // TODO(neil) We borrow &quot;EncodeMultiColumnHashValue&quot; for now. For postgresql, this encoding</a>
<a name="ln728">    // is up to us to choose whatever that make sense.</a>
<a name="ln729">    //</a>
<a name="ln730">    // Make sure given key is not smaller than lower bound (if any)</a>
<a name="ln731">    if (read_request_-&gt;has_hash_code()) {</a>
<a name="ln732">      uint16 hash_code = static_cast&lt;uint16&gt;(read_request_-&gt;hash_code());</a>
<a name="ln733">      auto lower_bound = PartitionSchema::EncodeMultiColumnHashValue(hash_code);</a>
<a name="ln734">      if (*partition_key &lt; lower_bound) *partition_key = std::move(lower_bound);</a>
<a name="ln735">    }</a>
<a name="ln736"> </a>
<a name="ln737">    // Make sure given key is not bigger than upper bound (if any)</a>
<a name="ln738">    if (read_request_-&gt;has_max_hash_code()) {</a>
<a name="ln739">      uint16 hash_code = static_cast&lt;uint16&gt;(read_request_-&gt;max_hash_code());</a>
<a name="ln740">      auto upper_bound = PartitionSchema::EncodeMultiColumnHashValue(hash_code);</a>
<a name="ln741">      if (*partition_key &gt; upper_bound) *partition_key = std::move(upper_bound);</a>
<a name="ln742">    }</a>
<a name="ln743"> </a>
<a name="ln744">    if (!partition_key-&gt;empty()) {</a>
<a name="ln745">      // Set both bounds to equal partition key now, because this is a point get</a>
<a name="ln746">      uint16 hash_code = PartitionSchema::DecodeMultiColumnHashValue(*partition_key);</a>
<a name="ln747">      read_request_-&gt;set_hash_code(hash_code);</a>
<a name="ln748">      read_request_-&gt;set_max_hash_code(hash_code);</a>
<a name="ln749">    } // else we are using no-hash scheme (e.g. for postgres syscatalog tables) -- nothing to do.</a>
<a name="ln750">  } else {</a>
<a name="ln751">    if (schema.num_hash_key_columns() &gt; 0) {</a>
<a name="ln752">      // Set the partition key to the hash_code (lower bound of the token range).</a>
<a name="ln753">      const auto &amp;ybctid = read_request_-&gt;ybctid_column_value().value();</a>
<a name="ln754">      if (!IsNull(ybctid)) {</a>
<a name="ln755">        const uint16 hash_code = VERIFY_RESULT(docdb::DocKey::DecodeHash(ybctid.binary_value()));</a>
<a name="ln756">        read_request_-&gt;set_hash_code(hash_code);</a>
<a name="ln757">        *partition_key = PartitionSchema::EncodeMultiColumnHashValue(hash_code);</a>
<a name="ln758">      } else {</a>
<a name="ln759">        // Default to empty key, this will start a scan from the beginning.</a>
<a name="ln760">        partition_key-&gt;clear();</a>
<a name="ln761">      }</a>
<a name="ln762">    } else {</a>
<a name="ln763">      // Set the range partition key.</a>
<a name="ln764">      const auto &amp;ybctid = read_request_-&gt;ybctid_column_value().value();</a>
<a name="ln765">      if (!IsNull(ybctid)) {</a>
<a name="ln766">        *partition_key = ybctid.binary_value();</a>
<a name="ln767">      } else {</a>
<a name="ln768">        RETURN_NOT_OK(SetRangePartitionBounds(</a>
<a name="ln769">            *this, partition_key, read_request_-&gt;mutable_max_partition_key()));</a>
<a name="ln770">      }</a>
<a name="ln771">    }</a>
<a name="ln772">  }</a>
<a name="ln773"> </a>
<a name="ln774">  // If this is a continued query use the partition key from the paging state</a>
<a name="ln775">  // If paging state is there, set hash_code = paging state. This is only supported for forward</a>
<a name="ln776">  // scans.</a>
<a name="ln777">  if (read_request_-&gt;has_paging_state() &amp;&amp; read_request_-&gt;paging_state().has_next_partition_key()) {</a>
<a name="ln778">    *partition_key = read_request_-&gt;paging_state().next_partition_key();</a>
<a name="ln779">    // Check that the partition key we got from the paging state is within bounds.</a>
<a name="ln780">    if (schema.num_hash_key_columns() &gt; 0 &amp;&amp; !partition_key-&gt;empty()) {</a>
<a name="ln781">      uint16 paging_state_hash_code = PartitionSchema::DecodeMultiColumnHashValue(*partition_key);</a>
<a name="ln782">      if ((read_request_-&gt;has_hash_code() &amp;&amp;</a>
<a name="ln783">          paging_state_hash_code &lt; read_request_-&gt;hash_code()) ||</a>
<a name="ln784">          (read_request_-&gt;has_max_hash_code() &amp;&amp;</a>
<a name="ln785">              paging_state_hash_code &gt; read_request_-&gt;max_hash_code())) {</a>
<a name="ln786">        return STATUS_SUBSTITUTE(InternalError,</a>
<a name="ln787">                                 &quot;Out of bounds partition key found in paging state:&quot;</a>
<a name="ln788">                                 &quot;Query's partition bounds: [%d, %d], paging state partition: %d&quot;,</a>
<a name="ln789">                                 read_request_-&gt;hash_code(),</a>
<a name="ln790">                                 read_request_-&gt;max_hash_code(),</a>
<a name="ln791">                                 paging_state_hash_code);</a>
<a name="ln792">      }</a>
<a name="ln793"> </a>
<a name="ln794">      read_request_-&gt;set_hash_code(paging_state_hash_code);</a>
<a name="ln795">    }</a>
<a name="ln796">  }</a>
<a name="ln797"> </a>
<a name="ln798">  return Status::OK();</a>
<a name="ln799">}</a>
<a name="ln800"> </a>
<a name="ln801">std::vector&lt;ColumnSchema&gt; YBPgsqlReadOp::MakeColumnSchemasFromColDesc(</a>
<a name="ln802">  const google::protobuf::RepeatedPtrField&lt;PgsqlRSColDescPB&gt;&amp; rscol_descs) {</a>
<a name="ln803">  std::vector&lt;ColumnSchema&gt; column_schemas;</a>
<a name="ln804">  column_schemas.reserve(rscol_descs.size());</a>
<a name="ln805">  for (const auto&amp; rscol_desc : rscol_descs) {</a>
<a name="ln806">    column_schemas.emplace_back(rscol_desc.name(), QLType::FromQLTypePB(rscol_desc.ql_type()));</a>
<a name="ln807">  }</a>
<a name="ln808">  return column_schemas;</a>
<a name="ln809">}</a>
<a name="ln810"> </a>
<a name="ln811">std::vector&lt;ColumnSchema&gt; YBPgsqlReadOp::MakeColumnSchemasFromRequest() const {</a>
<a name="ln812">  // Tests don't have access to the QL internal statement object, so they have to use rsrow</a>
<a name="ln813">  // descriptor from the read request.</a>
<a name="ln814">  return MakeColumnSchemasFromColDesc(request().rsrow_desc().rscol_descs());</a>
<a name="ln815">}</a>
<a name="ln816"> </a>
<a name="ln817">Result&lt;QLRowBlock&gt; YBPgsqlReadOp::MakeRowBlock() const {</a>
<a name="ln818">  Schema schema(MakeColumnSchemasFromRequest(), 0);</a>
<a name="ln819">  QLRowBlock result(schema);</a>
<a name="ln820">  Slice data(rows_data_);</a>
<a name="ln821">  if (!data.empty()) {</a>
<a name="ln822">    RETURN_NOT_OK(result.Deserialize(request().client(), &amp;data));</a>
<a name="ln823">  }</a>
<a name="ln824">  return result;</a>
<a name="ln825">}</a>
<a name="ln826"> </a>
<a name="ln827">////////////////////////////////////////////////////////////</a>
<a name="ln828">// YBNoOp</a>
<a name="ln829">////////////////////////////////////////////////////////////</a>
<a name="ln830"> </a>
<a name="ln831">YBNoOp::YBNoOp(YBTable* table)</a>
<a name="ln832">  : table_(table) {</a>
<a name="ln833">}</a>
<a name="ln834"> </a>
<a name="ln835">Status YBNoOp::Execute(const YBPartialRow&amp; key) {</a>
<a name="ln836">  string encoded_key;</a>
<a name="ln837">  RETURN_NOT_OK(table_-&gt;partition_schema().EncodeKey(key, &amp;encoded_key));</a>
<a name="ln838">  CoarseTimePoint deadline = CoarseMonoClock::Now() + 5s;</a>
<a name="ln839"> </a>
<a name="ln840">  tserver::NoOpRequestPB noop_req;</a>
<a name="ln841">  tserver::NoOpResponsePB noop_resp;</a>
<a name="ln842"> </a>
<a name="ln843">  for (int attempt = 1; attempt &lt; 11; attempt++) {</a>
<a name="ln844">    Synchronizer sync;</a>
<a name="ln845">    auto remote_ = VERIFY_RESULT(table_-&gt;client()-&gt;data_-&gt;meta_cache_-&gt;LookupTabletByKeyFuture(</a>
<a name="ln846">        table_, encoded_key, deadline).get());</a>
<a name="ln847"> </a>
<a name="ln848">    internal::RemoteTabletServer *ts = nullptr;</a>
<a name="ln849">    std::vector&lt;internal::RemoteTabletServer*&gt; candidates;</a>
<a name="ln850">    std::set&lt;string&gt; blacklist;  // TODO: empty set for now.</a>
<a name="ln851">    Status lookup_status = table_-&gt;client()-&gt;data_-&gt;GetTabletServer(</a>
<a name="ln852">       table_-&gt;client(),</a>
<a name="ln853">       remote_,</a>
<a name="ln854">       YBClient::ReplicaSelection::LEADER_ONLY,</a>
<a name="ln855">       blacklist,</a>
<a name="ln856">       &amp;candidates,</a>
<a name="ln857">       &amp;ts);</a>
<a name="ln858"> </a>
<a name="ln859">    // If we get ServiceUnavailable, this indicates that the tablet doesn't</a>
<a name="ln860">    // currently have any known leader. We should sleep and retry, since</a>
<a name="ln861">    // it's likely that the tablet is undergoing a leader election and will</a>
<a name="ln862">    // soon have one.</a>
<a name="ln863">    if (lookup_status.IsServiceUnavailable() &amp;&amp; CoarseMonoClock::Now() &lt; deadline) {</a>
<a name="ln864">      const int sleep_ms = attempt * 100;</a>
<a name="ln865">      VLOG(1) &lt;&lt; &quot;Tablet &quot; &lt;&lt; remote_-&gt;tablet_id() &lt;&lt; &quot; current unavailable: &quot;</a>
<a name="ln866">              &lt;&lt; lookup_status.ToString() &lt;&lt; &quot;. Sleeping for &quot; &lt;&lt; sleep_ms &lt;&lt; &quot;ms &quot;</a>
<a name="ln867">              &lt;&lt; &quot;and retrying...&quot;;</a>
<a name="ln868">      SleepFor(MonoDelta::FromMilliseconds(sleep_ms));</a>
<a name="ln869">      continue;</a>
<a name="ln870">    }</a>
<a name="ln871">    RETURN_NOT_OK(lookup_status);</a>
<a name="ln872"> </a>
<a name="ln873">    auto now = CoarseMonoClock::Now();</a>
<a name="ln874">    if (deadline &lt; now) {</a>
<a name="ln875">      return STATUS(TimedOut, &quot;Op timed out, deadline expired&quot;);</a>
<a name="ln876">    }</a>
<a name="ln877"> </a>
<a name="ln878">    // Recalculate the deadlines.</a>
<a name="ln879">    // If we have other replicas beyond this one to try, then we'll use the default RPC timeout.</a>
<a name="ln880">    // That gives us time to try other replicas later. Otherwise, use the full remaining deadline</a>
<a name="ln881">    // for the user's call.</a>
<a name="ln882">    CoarseTimePoint rpc_deadline;</a>
<a name="ln883">    if (static_cast&lt;int&gt;(candidates.size()) - blacklist.size() &gt; 1) {</a>
<a name="ln884">      rpc_deadline = now + table_-&gt;client()-&gt;default_rpc_timeout();</a>
<a name="ln885">      rpc_deadline = std::min(deadline, rpc_deadline);</a>
<a name="ln886">    } else {</a>
<a name="ln887">      rpc_deadline = deadline;</a>
<a name="ln888">    }</a>
<a name="ln889"> </a>
<a name="ln890">    rpc::RpcController controller;</a>
<a name="ln891">    controller.set_deadline(rpc_deadline);</a>
<a name="ln892"> </a>
<a name="ln893">    CHECK(ts-&gt;proxy());</a>
<a name="ln894">    const Status rpc_status = ts-&gt;proxy()-&gt;NoOp(noop_req, &amp;noop_resp, &amp;controller);</a>
<a name="ln895">    if (rpc_status.ok() &amp;&amp; !noop_resp.has_error()) {</a>
<a name="ln896">      break;</a>
<a name="ln897">    }</a>
<a name="ln898"> </a>
<a name="ln899">    LOG(INFO) &lt;&lt; rpc_status.CodeAsString();</a>
<a name="ln900">    if (noop_resp.has_error()) {</a>
<a name="ln901">      Status s = StatusFromPB(noop_resp.error().status());</a>
<a name="ln902">      LOG(INFO) &lt;&lt; rpc_status.CodeAsString();</a>
<a name="ln903">    }</a>
<a name="ln904">    /*</a>
<a name="ln905">     * TODO: For now, we just try a few attempts and exit. Ideally, we should check for</a>
<a name="ln906">     * errors that are retriable, and retry if so.</a>
<a name="ln907">     * RETURN_NOT_OK(CanBeRetried(true, rpc_status, server_status, rpc_deadline, deadline,</a>
<a name="ln908">     *                         candidates, blacklist));</a>
<a name="ln909">     */</a>
<a name="ln910">  }</a>
<a name="ln911"> </a>
<a name="ln912">  return Status::OK();</a>
<a name="ln913">}</a>
<a name="ln914"> </a>
<a name="ln915">bool YBPgsqlReadOp::should_add_intents(IsolationLevel isolation_level) {</a>
<a name="ln916">  return isolation_level == IsolationLevel::SERIALIZABLE_ISOLATION ||</a>
<a name="ln917">         IsValidRowMarkType(GetRowMarkTypeFromPB(*read_request_));</a>
<a name="ln918">}</a>
<a name="ln919"> </a>
<a name="ln920">CHECKED_STATUS ReviewResponsePagingState(YBPgsqlReadOp* op) {</a>
<a name="ln921">  auto&amp; response = *op-&gt;mutable_response();</a>
<a name="ln922">  const auto&amp; schema = op-&gt;table()-&gt;InternalSchema();</a>
<a name="ln923">  if (schema.num_hash_key_columns() &gt; 0 ||</a>
<a name="ln924">      op-&gt;request().is_forward_scan() ||</a>
<a name="ln925">      !response.has_paging_state() ||</a>
<a name="ln926">      !response.paging_state().has_next_partition_key() ||</a>
<a name="ln927">      response.paging_state().has_next_row_key()) {</a>
<a name="ln928">    return Status::OK();</a>
<a name="ln929">  }</a>
<a name="ln930">  // Backward scan of range key only table. next_row_key is not specified in paging state.</a>
<a name="ln931">  // In this case next_partition_key must be corrected as now it points to the partition start key</a>
<a name="ln932">  // of already scanned tablet. Partition start key of the preceding tablet must be used instead.</a>
<a name="ln933">  // Also lower bound is checked here because DocDB can check upper bound only.</a>
<a name="ln934">  const auto&amp; current_next_partition_key = response.paging_state().next_partition_key();</a>
<a name="ln935">  vector&lt;docdb::PrimitiveValue&gt; lower_bound, upper_bound;</a>
<a name="ln936">  RETURN_NOT_OK(GetRangePartitionBounds(*op, &amp;lower_bound, &amp;upper_bound));</a>
<a name="ln937">  if (!lower_bound.empty()) {</a>
<a name="ln938">    docdb::DocKey current_key(schema);</a>
<a name="ln939">    VERIFY_RESULT(current_key.DecodeFrom(</a>
<a name="ln940">        current_next_partition_key, docdb::DocKeyPart::kWholeDocKey, docdb::AllowSpecial::kTrue));</a>
<a name="ln941">    if (current_key.CompareTo(docdb::DocKey(std::move(lower_bound))) &lt; 0) {</a>
<a name="ln942">      response.clear_paging_state();</a>
<a name="ln943">      return Status::OK();</a>
<a name="ln944">    }</a>
<a name="ln945">  }</a>
<a name="ln946">  const auto&amp; partitions = op-&gt;table()-&gt;GetPartitions();</a>
<a name="ln947">  const auto idx = FindPartitionStartIndex(partitions, current_next_partition_key);</a>
<a name="ln948">  SCHECK_GT(</a>
<a name="ln949">      idx, 0,</a>
<a name="ln950">      IllegalState, &quot;Paging state for backward scan cannot point to first partition&quot;);</a>
<a name="ln951">  SCHECK_EQ(</a>
<a name="ln952">      partitions[idx], current_next_partition_key,</a>
<a name="ln953">      IllegalState, &quot;Paging state for backward scan must point to partition start key&quot;);</a>
<a name="ln954">  const auto&amp; next_partition_key = partitions[idx - 1];</a>
<a name="ln955">  response.mutable_paging_state()-&gt;set_next_partition_key(next_partition_key);</a>
<a name="ln956">  return Status::OK();</a>
<a name="ln957">}</a>
<a name="ln958"> </a>
<a name="ln959">}  // namespace client</a>
<a name="ln960">}  // namespace yb</a>

</code></pre>
<div class="balloon" rel="319"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="320"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="354"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="355"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="865"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="893"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
