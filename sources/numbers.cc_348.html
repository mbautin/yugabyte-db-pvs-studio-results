
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>numbers.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Copyright 2010 Google Inc. All Rights Reserved.</a>
<a name="ln2">// Refactored from contributions of various authors in strings/strutil.cc</a>
<a name="ln3">//</a>
<a name="ln4">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln5">//</a>
<a name="ln6">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln7">//</a>
<a name="ln8">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln9">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln10">//</a>
<a name="ln11">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln12">//</a>
<a name="ln13">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln14">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln15">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln16">// under the License.</a>
<a name="ln17">//</a>
<a name="ln18">// This file contains string processing functions related to</a>
<a name="ln19">// numeric values.</a>
<a name="ln20"> </a>
<a name="ln21">#include &quot;yb/gutil/strings/numbers.h&quot;</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;assert.h&gt;</a>
<a name="ln24">#include &lt;ctype.h&gt;</a>
<a name="ln25">#include &lt;errno.h&gt;</a>
<a name="ln26">#include &lt;float.h&gt;          // for DBL_DIG and FLT_DIG</a>
<a name="ln27">#include &lt;math.h&gt;           // for HUGE_VAL</a>
<a name="ln28">#include &lt;stdio.h&gt;</a>
<a name="ln29">#include &lt;stdlib.h&gt;</a>
<a name="ln30">#include &lt;string.h&gt;</a>
<a name="ln31">#include &lt;iomanip&gt;</a>
<a name="ln32">#include &lt;limits&gt;</a>
<a name="ln33">using std::numeric_limits;</a>
<a name="ln34">#include &lt;string&gt;</a>
<a name="ln35">#include &lt;sstream&gt;</a>
<a name="ln36">using std::string;</a>
<a name="ln37"> </a>
<a name="ln38">#include &quot;yb/gutil/int128.h&quot;</a>
<a name="ln39">#include &quot;yb/gutil/integral_types.h&quot;</a>
<a name="ln40">#include &lt;glog/logging.h&gt;</a>
<a name="ln41">#include &quot;yb/gutil/logging-inl.h&quot;</a>
<a name="ln42">#include &quot;yb/gutil/gscoped_ptr.h&quot;</a>
<a name="ln43">#include &quot;yb/gutil/stringprintf.h&quot;</a>
<a name="ln44">#include &quot;yb/gutil/strtoint.h&quot;</a>
<a name="ln45">#include &quot;yb/gutil/strings/ascii_ctype.h&quot;</a>
<a name="ln46"> </a>
<a name="ln47">// Reads a &lt;double&gt; in *text, which may not be whitespace-initiated.</a>
<a name="ln48">// *len is the length, or -1 if text is '\0'-terminated, which is more</a>
<a name="ln49">// efficient.  Sets *text to the end of the double, and val to the</a>
<a name="ln50">// converted value, and the length of the double is subtracted from</a>
<a name="ln51">// *len. &lt;double&gt; may also be a '?', in which case val will be</a>
<a name="ln52">// unchanged. Returns true upon success.  If initial_minus is</a>
<a name="ln53">// non-NULL, then *initial_minus will indicate whether the first</a>
<a name="ln54">// symbol seen was a '-', which will be ignored. Similarly, if</a>
<a name="ln55">// final_period is non-NULL, then *final_period will indicate whether</a>
<a name="ln56">// the last symbol seen was a '.', which will be ignored. This is</a>
<a name="ln57">// useful in case that an initial '-' or final '.' would have another</a>
<a name="ln58">// meaning (as a separator, e.g.).</a>
<a name="ln59">static inline bool EatADouble(const char** text, int* len, bool allow_question,</a>
<a name="ln60">                              double* val, bool* initial_minus,</a>
<a name="ln61">                              bool* final_period) {</a>
<a name="ln62">  const char* pos = *text;</a>
<a name="ln63">  int rem = *len;  // remaining length, or -1 if null-terminated</a>
<a name="ln64"> </a>
<a name="ln65">  if (pos == nullptr || rem == 0)</a>
<a name="ln66">    return false;</a>
<a name="ln67"> </a>
<a name="ln68">  if (allow_question &amp;&amp; (*pos == '?')) {</a>
<a name="ln69">    *text = pos + 1;</a>
<a name="ln70">    if (rem != -1)</a>
<a name="ln71">      *len = rem - 1;</a>
<a name="ln72">    return true;</a>
<a name="ln73">  }</a>
<a name="ln74"> </a>
<a name="ln75">  if (initial_minus) {</a>
<a name="ln76">    if ((*initial_minus = (*pos == '-'))) {  // Yes, we want assignment.</a>
<a name="ln77">      if (rem == 1)</a>
<a name="ln78">        return false;</a>
<a name="ln79">      ++pos;</a>
<a name="ln80">      if (rem != -1)</a>
<a name="ln81">        --rem;</a>
<a name="ln82">    }</a>
<a name="ln83">  }</a>
<a name="ln84"> </a>
<a name="ln85">  // a double has to begin one of these (we don't allow 'inf' or whitespace)</a>
<a name="ln86">  // this also serves as an optimization.</a>
<a name="ln87">  if (!strchr(&quot;-+.0123456789&quot;, *pos))</a>
<a name="ln88">    return false;</a>
<a name="ln89"> </a>
<a name="ln90">  // strtod is evil in that the second param is a non-const char**</a>
<a name="ln91">  char* end_nonconst;</a>
<a name="ln92">  double retval;</a>
<a name="ln93">  if (rem == -1) {</a>
<a name="ln94">    retval = strtod(pos, &amp;end_nonconst);</a>
<a name="ln95">  } else {</a>
<a name="ln96">    // not '\0'-terminated &amp; no obvious terminator found. must copy.</a>
<a name="ln97">    gscoped_array&lt;char&gt; buf(new char[rem + 1]);</a>
<a name="ln98">    memcpy(buf.get(), pos, rem);</a>
<a name="ln99">    buf[rem] = '\0';</a>
<a name="ln100">    retval = strtod(buf.get(), &amp;end_nonconst);</a>
<a name="ln101">    end_nonconst = const_cast&lt;char*&gt;(pos) + (end_nonconst - buf.get());</a>
<a name="ln102">  }</a>
<a name="ln103"> </a>
<a name="ln104">  if (pos == end_nonconst)</a>
<a name="ln105">    return false;</a>
<a name="ln106"> </a>
<a name="ln107">  if (final_period) {</a>
<a name="ln108">    *final_period = (end_nonconst[-1] == '.');</a>
<a name="ln109">    if (*final_period) {</a>
<a name="ln110">      --end_nonconst;</a>
<a name="ln111">    }</a>
<a name="ln112">  }</a>
<a name="ln113"> </a>
<a name="ln114">  *text = end_nonconst;</a>
<a name="ln115">  *val = retval;</a>
<a name="ln116">  if (rem != -1)</a>
<a name="ln117">    *len = rem - (end_nonconst - pos);</a>
<a name="ln118">  return true;</a>
<a name="ln119">}</a>
<a name="ln120"> </a>
<a name="ln121">// If update, consume one of acceptable_chars from string *text of</a>
<a name="ln122">// length len and return that char, or '\0' otherwise. If len is -1,</a>
<a name="ln123">// *text is null-terminated. If update is false, don't alter *text and</a>
<a name="ln124">// *len. If null_ok, then update must be false, and, if text has no</a>
<a name="ln125">// more chars, then return '\1' (arbitrary nonzero).</a>
<a name="ln126">static inline char EatAChar(const char** text, int* len,</a>
<a name="ln127">                            const char* acceptable_chars,</a>
<a name="ln128">                            bool update, bool null_ok) {</a>
<a name="ln129">  assert(!(update &amp;&amp; null_ok));</a>
<a name="ln130">  if ((*len == 0) || (**text == '\0'))</a>
<a name="ln131">    return (null_ok ? '\1' : '\0');  // if null_ok, we're in predicate mode.</a>
<a name="ln132"> </a>
<a name="ln133">  if (strchr(acceptable_chars, **text)) {</a>
<a name="ln134">    char result = **text;</a>
<a name="ln135">    if (update) {</a>
<a name="ln136">      ++(*text);</a>
<a name="ln137">      if (*len != -1)</a>
<a name="ln138">        --(*len);</a>
<a name="ln139">    }</a>
<a name="ln140">    return result;</a>
<a name="ln141">  }</a>
<a name="ln142"> </a>
<a name="ln143">  return '\0';  // no match; no update</a>
<a name="ln144">}</a>
<a name="ln145"> </a>
<a name="ln146">// Parse an expression in 'text' of the form: &lt;comparator&gt;&lt;double&gt; or</a>
<a name="ln147">// &lt;double&gt;&lt;sep&gt;&lt;double&gt; See full comments in header file.</a>
<a name="ln148">bool ParseDoubleRange(const char* text, int len, const char** end,</a>
<a name="ln149">                      double* from, double* to, bool* is_currency,</a>
<a name="ln150">                      const DoubleRangeOptions&amp; opts) {</a>
<a name="ln151">  const double from_default = opts.dont_modify_unbounded ? *from : -HUGE_VAL;</a>
<a name="ln152"> </a>
<a name="ln153">  if (!opts.dont_modify_unbounded) {</a>
<a name="ln154">    *from = -HUGE_VAL;</a>
<a name="ln155">    *to = HUGE_VAL;</a>
<a name="ln156">  }</a>
<a name="ln157">  if (opts.allow_currency &amp;&amp; (is_currency != nullptr))</a>
<a name="ln158">    *is_currency = false;</a>
<a name="ln159"> </a>
<a name="ln160">  assert(len &gt;= -1);</a>
<a name="ln161">  assert(opts.separators &amp;&amp; (*opts.separators != '\0'));</a>
<a name="ln162">  // these aren't valid separators</a>
<a name="ln163">  assert(strlen(opts.separators) ==</a>
<a name="ln164">         strcspn(opts.separators, &quot;+0123456789eE$&quot;));</a>
<a name="ln165">  assert(opts.num_required_bounds &lt;= 2);</a>
<a name="ln166"> </a>
<a name="ln167">  // Handle easier cases of comparators (&lt;, &gt;) first</a>
<a name="ln168">  if (opts.allow_comparators) {</a>
<a name="ln169">    char comparator = EatAChar(&amp;text, &amp;len, &quot;&lt;&gt;&quot;, true, false);</a>
<a name="ln170">    if (comparator) {</a>
<a name="ln171">      double* dest = (comparator == '&gt;') ? from : to;</a>
<a name="ln172">      EatAChar(&amp;text, &amp;len, &quot;=&quot;, true, false);</a>
<a name="ln173">      if (opts.allow_currency &amp;&amp; EatAChar(&amp;text, &amp;len, &quot;$&quot;, true, false))</a>
<a name="ln174">        if (is_currency != nullptr)</a>
<a name="ln175">          *is_currency = true;</a>
<a name="ln176">      if (!EatADouble(&amp;text, &amp;len, opts.allow_unbounded_markers, dest, nullptr,</a>
<a name="ln177">                      nullptr))</a>
<a name="ln178">        return false;</a>
<a name="ln179">      *end = text;</a>
<a name="ln180">      return EatAChar(&amp;text, &amp;len, opts.acceptable_terminators, false,</a>
<a name="ln181">                      opts.null_terminator_ok);</a>
<a name="ln182">    }</a>
<a name="ln183">  }</a>
<a name="ln184"> </a>
<a name="ln185">  bool seen_dollar = (opts.allow_currency &amp;&amp;</a>
<a name="ln186">                      EatAChar(&amp;text, &amp;len, &quot;$&quot;, true, false));</a>
<a name="ln187"> </a>
<a name="ln188">  // If we see a '-', two things could be happening: -&lt;to&gt; or</a>
<a name="ln189">  // &lt;from&gt;... where &lt;from&gt; is negative. Treat initial minus sign as a</a>
<a name="ln190">  // separator if '-' is a valid separator.</a>
<a name="ln191">  // Similarly, we prepare for the possibility of seeing a '.' at the</a>
<a name="ln192">  // end of the number, in case '.' (which really means '..') is a</a>
<a name="ln193">  // separator.</a>
<a name="ln194">  bool initial_minus_sign = false;</a>
<a name="ln195">  bool final_period = false;</a>
<a name="ln196">  bool* check_initial_minus = (strchr(opts.separators, '-') &amp;&amp; !seen_dollar</a>
<a name="ln197">                               &amp;&amp; (opts.num_required_bounds &lt; 2)) ?</a>
<a name="ln198">                              (&amp;initial_minus_sign) : nullptr;</a>
<a name="ln199">  bool* check_final_period = strchr(opts.separators, '.') ? (&amp;final_period)</a>
<a name="ln200">                             : nullptr;</a>
<a name="ln201">  bool double_seen = EatADouble(&amp;text, &amp;len, opts.allow_unbounded_markers,</a>
<a name="ln202">                                from, check_initial_minus, check_final_period);</a>
<a name="ln203"> </a>
<a name="ln204">  // if 2 bounds required, must see a double (or '?' if allowed)</a>
<a name="ln205">  if ((opts.num_required_bounds == 2) &amp;&amp; !double_seen) return false;</a>
<a name="ln206"> </a>
<a name="ln207">  if (seen_dollar &amp;&amp; !double_seen) {</a>
<a name="ln208">      --text;</a>
<a name="ln209">      if (len != -1)</a>
<a name="ln210">        ++len;</a>
<a name="ln211">      seen_dollar = false;</a>
<a name="ln212">  }</a>
<a name="ln213">  // If we're here, we've read the first double and now expect a</a>
<a name="ln214">  // separator and another &lt;double&gt;.</a>
<a name="ln215">  char separator = EatAChar(&amp;text, &amp;len, opts.separators, true, false);</a>
<a name="ln216">  if (separator == '.') {</a>
<a name="ln217">    // seen one '.' as separator; must check for another; perhaps set seplen=2</a>
<a name="ln218">    if (EatAChar(&amp;text, &amp;len, &quot;.&quot;, true, false)) {</a>
<a name="ln219">      if (final_period) {</a>
<a name="ln220">        // We may have three periods in a row. The first is part of the</a>
<a name="ln221">        // first number, the others are a separator. Policy: 234...567</a>
<a name="ln222">        // is &quot;234.&quot; to &quot;567&quot;, not &quot;234&quot; to &quot;.567&quot;.</a>
<a name="ln223">        EatAChar(&amp;text, &amp;len, &quot;.&quot;, true, false);</a>
<a name="ln224">      }</a>
<a name="ln225">    } else if (!EatAChar(&amp;text, &amp;len, opts.separators, true, false)) {</a>
<a name="ln226">      // just one '.' and no other separator; uneat the first '.' we saw</a>
<a name="ln227">      --text;</a>
<a name="ln228">      if (len != -1)</a>
<a name="ln229">        ++len;</a>
<a name="ln230">      separator = '\0';</a>
<a name="ln231">    }</a>
<a name="ln232">  }</a>
<a name="ln233">  // By now, we've consumed whatever separator there may have been,</a>
<a name="ln234">  // and separator is true iff there was one.</a>
<a name="ln235">  if (!separator) {</a>
<a name="ln236">    if (final_period)  // final period now considered part of first double</a>
<a name="ln237">      EatAChar(&amp;text, &amp;len, &quot;.&quot;, true, false);</a>
<a name="ln238">    if (initial_minus_sign &amp;&amp; double_seen) {</a>
<a name="ln239">      *to = *from;</a>
<a name="ln240">      *from = from_default;</a>
<a name="ln241">    } else if (opts.require_separator ||</a>
<a name="ln242">               (opts.num_required_bounds &gt; 0 &amp;&amp; !double_seen) ||</a>
<a name="ln243">               (opts.num_required_bounds &gt; 1) ) {</a>
<a name="ln244">      return false;</a>
<a name="ln245">    }</a>
<a name="ln246">  } else {</a>
<a name="ln247">    if (initial_minus_sign &amp;&amp; double_seen)</a>
<a name="ln248">      *from = -(*from);</a>
<a name="ln249">    // read second &lt;double&gt;</a>
<a name="ln250">    bool second_dollar_seen = (seen_dollar</a>
<a name="ln251">                               || (opts.allow_currency &amp;&amp; !double_seen))</a>
<a name="ln252">                              &amp;&amp; EatAChar(&amp;text, &amp;len, &quot;$&quot;, true, false);</a>
<a name="ln253">    bool second_double_seen = EatADouble(</a>
<a name="ln254">      &amp;text, &amp;len, opts.allow_unbounded_markers, to, nullptr, nullptr);</a>
<a name="ln255">    if (opts.num_required_bounds &gt; double_seen + second_double_seen)</a>
<a name="ln256">      return false;</a>
<a name="ln257">    if (second_dollar_seen &amp;&amp; !second_double_seen) {</a>
<a name="ln258">      --text;</a>
<a name="ln259">      if (len != -1)</a>
<a name="ln260">        ++len;</a>
<a name="ln261">      second_dollar_seen = false;</a>
<a name="ln262">    }</a>
<a name="ln263">    seen_dollar = seen_dollar || second_dollar_seen;</a>
<a name="ln264">  }</a>
<a name="ln265"> </a>
<a name="ln266">  if (seen_dollar &amp;&amp; (is_currency != nullptr))</a>
<a name="ln267">    *is_currency = true;</a>
<a name="ln268">  // We're done. But we have to check that the next char is a proper</a>
<a name="ln269">  // terminator.</a>
<a name="ln270">  *end = text;</a>
<a name="ln271">  char terminator = EatAChar(&amp;text, &amp;len, opts.acceptable_terminators, false,</a>
<a name="ln272">                             opts.null_terminator_ok);</a>
<a name="ln273">  if (terminator == '.')</a>
<a name="ln274">    --(*end);</a>
<a name="ln275">  return terminator;</a>
<a name="ln276">}</a>
<a name="ln277"> </a>
<a name="ln278">// ----------------------------------------------------------------------</a>
<a name="ln279">// ConsumeStrayLeadingZeroes</a>
<a name="ln280">//    Eliminates all leading zeroes (unless the string itself is composed</a>
<a name="ln281">//    of nothing but zeroes, in which case one is kept: 0...0 becomes 0).</a>
<a name="ln282">// --------------------------------------------------------------------</a>
<a name="ln283"> </a>
<a name="ln284">void ConsumeStrayLeadingZeroes(string *const str) {</a>
<a name="ln285">  const string::size_type len(str-&gt;size());</a>
<a name="ln286">  if (len &gt; 1 &amp;&amp; (*str)[0] == '0') {</a>
<a name="ln287">    const char</a>
<a name="ln288">      *const begin(str-&gt;c_str()),</a>
<a name="ln289">      *const end(begin + len),</a>
<a name="ln290">      *ptr(begin + 1);</a>
<a name="ln291">    while (ptr != end &amp;&amp; *ptr == '0') {</a>
<a name="ln292">      ++ptr;</a>
<a name="ln293">    }</a>
<a name="ln294">    string::size_type remove(ptr - begin);</a>
<a name="ln295">    DCHECK_GT(ptr, begin);</a>
<a name="ln296">    if (remove == len) {</a>
<a name="ln297">      --remove;  // if they are all zero, leave one...</a>
<a name="ln298">    }</a>
<a name="ln299">    str-&gt;erase(0, remove);</a>
<a name="ln300">  }</a>
<a name="ln301">}</a>
<a name="ln302"> </a>
<a name="ln303">// ----------------------------------------------------------------------</a>
<a name="ln304">// ParseLeadingInt32Value()</a>
<a name="ln305">// ParseLeadingUInt32Value()</a>
<a name="ln306">//    A simple parser for [u]int32 values. Returns the parsed value</a>
<a name="ln307">//    if a valid value is found; else returns deflt</a>
<a name="ln308">//    This cannot handle decimal numbers with leading 0s.</a>
<a name="ln309">// --------------------------------------------------------------------</a>
<a name="ln310"> </a>
<a name="ln311">int32 ParseLeadingInt32Value(const char *str, int32 deflt) {</a>
<a name="ln312">  char *error = nullptr;</a>
<a name="ln313">  auto value = strtol(str, &amp;error, 0);</a>
<a name="ln314">  // Limit long values to int32 min/max.  Needed for lp64; no-op on 32 bits.</a>
<a name="ln315">  if (value &gt; numeric_limits&lt;int32&gt;::max()) {</a>
<a name="ln316">    value = numeric_limits&lt;int32&gt;::max();</a>
<a name="ln317">  } else if (value &lt; numeric_limits&lt;int32&gt;::min()) {</a>
<a name="ln318">    value = numeric_limits&lt;int32&gt;::min();</a>
<a name="ln319">  }</a>
<a name="ln320">  return (error == str) ? deflt : value;</a>
<a name="ln321">}</a>
<a name="ln322"> </a>
<a name="ln323">uint32 ParseLeadingUInt32Value(const char *str, uint32 deflt) {</a>
<a name="ln324">  if (numeric_limits&lt;size_t&gt;::max() == numeric_limits&lt;uint32&gt;::max()) {</a>
<a name="ln325">    // When long is 32 bits, we can use strtoul.</a>
<a name="ln326">    char *error = nullptr;</a>
<a name="ln327">    const uint32 value = strtoul(str, &amp;error, 0);</a>
<a name="ln328">    return (error == str) ? deflt : value;</a>
<a name="ln329">  } else {</a>
<a name="ln330">    // When long is 64 bits, we must use strto64 and handle limits</a>
<a name="ln331">    // by hand.  The reason we cannot use a 64-bit strtoul is that</a>
<a name="ln332">    // it would be impossible to differentiate &quot;-2&quot; (that should wrap</a>
<a name="ln333">    // around to the value UINT_MAX-1) from a string with ULONG_MAX-1</a>
<a name="ln334">    // (that should be pegged to UINT_MAX due to overflow).</a>
<a name="ln335">    char *error = nullptr;</a>
<a name="ln336">    int64 value = strto64(str, &amp;error, 0);</a>
<a name="ln337">    if (value &gt; numeric_limits&lt;uint32&gt;::max() ||</a>
<a name="ln338">        value &lt; -static_cast&lt;int64&gt;(numeric_limits&lt;uint32&gt;::max())) {</a>
<a name="ln339">      value = numeric_limits&lt;uint32&gt;::max();</a>
<a name="ln340">    }</a>
<a name="ln341">    // Within these limits, truncation to 32 bits handles negatives correctly.</a>
<a name="ln342">    return (error == str) ? deflt : value;</a>
<a name="ln343">  }</a>
<a name="ln344">}</a>
<a name="ln345"> </a>
<a name="ln346">// ----------------------------------------------------------------------</a>
<a name="ln347">// ParseLeadingDec32Value</a>
<a name="ln348">// ParseLeadingUDec32Value</a>
<a name="ln349">//    A simple parser for [u]int32 values. Returns the parsed value</a>
<a name="ln350">//    if a valid value is found; else returns deflt</a>
<a name="ln351">//    The string passed in is treated as *10 based*.</a>
<a name="ln352">//    This can handle strings with leading 0s.</a>
<a name="ln353">// --------------------------------------------------------------------</a>
<a name="ln354"> </a>
<a name="ln355">int32 ParseLeadingDec32Value(const char *str, int32 deflt) {</a>
<a name="ln356">  char *error = nullptr;</a>
<a name="ln357">  auto value = strtol(str, &amp;error, 10);</a>
<a name="ln358">  // Limit long values to int32 min/max.  Needed for lp64; no-op on 32 bits.</a>
<a name="ln359">  if (value &gt; numeric_limits&lt;int32&gt;::max()) {</a>
<a name="ln360">    value = numeric_limits&lt;int32&gt;::max();</a>
<a name="ln361">  } else if (value &lt; numeric_limits&lt;int32&gt;::min()) {</a>
<a name="ln362">    value = numeric_limits&lt;int32&gt;::min();</a>
<a name="ln363">  }</a>
<a name="ln364">  return (error == str) ? deflt : value;</a>
<a name="ln365">}</a>
<a name="ln366"> </a>
<a name="ln367">uint32 ParseLeadingUDec32Value(const char *str, uint32 deflt) {</a>
<a name="ln368">  if (numeric_limits&lt;size_t&gt;::max() == numeric_limits&lt;uint32&gt;::max()) {</a>
<a name="ln369">    // When long is 32 bits, we can use strtoul.</a>
<a name="ln370">    char *error = nullptr;</a>
<a name="ln371">    const uint32 value = strtoul(str, &amp;error, 10);</a>
<a name="ln372">    return (error == str) ? deflt : value;</a>
<a name="ln373">  } else {</a>
<a name="ln374">    // When long is 64 bits, we must use strto64 and handle limits</a>
<a name="ln375">    // by hand.  The reason we cannot use a 64-bit strtoul is that</a>
<a name="ln376">    // it would be impossible to differentiate &quot;-2&quot; (that should wrap</a>
<a name="ln377">    // around to the value UINT_MAX-1) from a string with ULONG_MAX-1</a>
<a name="ln378">    // (that should be pegged to UINT_MAX due to overflow).</a>
<a name="ln379">    char *error = nullptr;</a>
<a name="ln380">    int64 value = strto64(str, &amp;error, 10);</a>
<a name="ln381">    if (value &gt; numeric_limits&lt;uint32&gt;::max() ||</a>
<a name="ln382">        value &lt; -static_cast&lt;int64&gt;(numeric_limits&lt;uint32&gt;::max())) {</a>
<a name="ln383">      value = numeric_limits&lt;uint32&gt;::max();</a>
<a name="ln384">    }</a>
<a name="ln385">    // Within these limits, truncation to 32 bits handles negatives correctly.</a>
<a name="ln386">    return (error == str) ? deflt : value;</a>
<a name="ln387">  }</a>
<a name="ln388">}</a>
<a name="ln389"> </a>
<a name="ln390">// ----------------------------------------------------------------------</a>
<a name="ln391">// ParseLeadingUInt64Value</a>
<a name="ln392">// ParseLeadingInt64Value</a>
<a name="ln393">// ParseLeadingHex64Value</a>
<a name="ln394">//    A simple parser for 64-bit values. Returns the parsed value if a</a>
<a name="ln395">//    valid integer is found; else returns deflt</a>
<a name="ln396">//    UInt64 and Int64 cannot handle decimal numbers with leading 0s.</a>
<a name="ln397">// --------------------------------------------------------------------</a>
<a name="ln398">uint64 ParseLeadingUInt64Value(const char *str, uint64 deflt) {</a>
<a name="ln399">  char *error = nullptr;</a>
<a name="ln400">  const uint64 value = strtou64(str, &amp;error, 0);</a>
<a name="ln401">  return (error == str) ? deflt : value;</a>
<a name="ln402">}</a>
<a name="ln403"> </a>
<a name="ln404">int64 ParseLeadingInt64Value(const char *str, int64 deflt) {</a>
<a name="ln405">  char *error = nullptr;</a>
<a name="ln406">  const int64 value = strto64(str, &amp;error, 0);</a>
<a name="ln407">  return (error == str) ? deflt : value;</a>
<a name="ln408">}</a>
<a name="ln409"> </a>
<a name="ln410">uint64 ParseLeadingHex64Value(const char *str, uint64 deflt) {</a>
<a name="ln411">  char *error = nullptr;</a>
<a name="ln412">  const uint64 value = strtou64(str, &amp;error, 16);</a>
<a name="ln413">  return (error == str) ? deflt : value;</a>
<a name="ln414">}</a>
<a name="ln415"> </a>
<a name="ln416">// ----------------------------------------------------------------------</a>
<a name="ln417">// ParseLeadingDec64Value</a>
<a name="ln418">// ParseLeadingUDec64Value</a>
<a name="ln419">//    A simple parser for [u]int64 values. Returns the parsed value</a>
<a name="ln420">//    if a valid value is found; else returns deflt</a>
<a name="ln421">//    The string passed in is treated as *10 based*.</a>
<a name="ln422">//    This can handle strings with leading 0s.</a>
<a name="ln423">// --------------------------------------------------------------------</a>
<a name="ln424"> </a>
<a name="ln425">int64 ParseLeadingDec64Value(const char *str, int64 deflt) {</a>
<a name="ln426">  char *error = nullptr;</a>
<a name="ln427">  const int64 value = strto64(str, &amp;error, 10);</a>
<a name="ln428">  return (error == str) ? deflt : value;</a>
<a name="ln429">}</a>
<a name="ln430"> </a>
<a name="ln431">uint64 ParseLeadingUDec64Value(const char *str, uint64 deflt) {</a>
<a name="ln432">  char *error = nullptr;</a>
<a name="ln433">  const uint64 value = strtou64(str, &amp;error, 10);</a>
<a name="ln434">  return (error == str) ? deflt : value;</a>
<a name="ln435">}</a>
<a name="ln436"> </a>
<a name="ln437">// ----------------------------------------------------------------------</a>
<a name="ln438">// ParseLeadingDoubleValue()</a>
<a name="ln439">//    A simple parser for double values. Returns the parsed value</a>
<a name="ln440">//    if a valid value is found; else returns deflt</a>
<a name="ln441">// --------------------------------------------------------------------</a>
<a name="ln442"> </a>
<a name="ln443">double ParseLeadingDoubleValue(const char *str, double deflt) {</a>
<a name="ln444">  char *error = nullptr;</a>
<a name="ln445">  errno = 0;</a>
<a name="ln446">  const double value = strtod(str, &amp;error);</a>
<a name="ln447">  if (errno != 0 ||  // overflow/underflow happened</a>
<a name="ln448">      error == str) {  // no valid parse</a>
<a name="ln449">    return deflt;</a>
<a name="ln450">  } else {</a>
<a name="ln451">    return value;</a>
<a name="ln452">  }</a>
<a name="ln453">}</a>
<a name="ln454"> </a>
<a name="ln455">// ----------------------------------------------------------------------</a>
<a name="ln456">// ParseLeadingBoolValue()</a>
<a name="ln457">//    A recognizer of boolean string values. Returns the parsed value</a>
<a name="ln458">//    if a valid value is found; else returns deflt.  This skips leading</a>
<a name="ln459">//    whitespace, is case insensitive, and recognizes these forms:</a>
<a name="ln460">//    0/1, false/true, no/yes, n/y</a>
<a name="ln461">// --------------------------------------------------------------------</a>
<a name="ln462">bool ParseLeadingBoolValue(const char *str, bool deflt) {</a>
<a name="ln463">  static const int kMaxLen = 5;</a>
<a name="ln464">  char value[kMaxLen + 1];</a>
<a name="ln465">  // Skip whitespace</a>
<a name="ln466">  while (ascii_isspace(*str)) {</a>
<a name="ln467">    ++str;</a>
<a name="ln468">  }</a>
<a name="ln469">  int len = 0;</a>
<a name="ln470">  for (; len &lt;= kMaxLen &amp;&amp; ascii_isalnum(*str); ++str)</a>
<a name="ln471">    value[len++] = ascii_tolower(*str);</a>
<a name="ln472">  if (len == 0 || len &gt; kMaxLen)</a>
<a name="ln473">    return deflt;</a>
<a name="ln474">  value[len] = '\0';</a>
<a name="ln475">  switch (len) {</a>
<a name="ln476">    case 1:</a>
<a name="ln477">      if (value[0] == '0' || value[0] == 'n')</a>
<a name="ln478">        return false;</a>
<a name="ln479">      if (value[0] == '1' || value[0] == 'y')</a>
<a name="ln480">        return true;</a>
<a name="ln481">      break;</a>
<a name="ln482">    case 2:</a>
<a name="ln483">      if (!strcmp(value, &quot;no&quot;))</a>
<a name="ln484">        return false;</a>
<a name="ln485">      break;</a>
<a name="ln486">    case 3:</a>
<a name="ln487">      if (!strcmp(value, &quot;yes&quot;))</a>
<a name="ln488">        return true;</a>
<a name="ln489">      break;</a>
<a name="ln490">    case 4:</a>
<a name="ln491">      if (!strcmp(value, &quot;true&quot;))</a>
<a name="ln492">        return true;</a>
<a name="ln493">      break;</a>
<a name="ln494">    case 5:</a>
<a name="ln495">      if (!strcmp(value, &quot;false&quot;))</a>
<a name="ln496">        return false;</a>
<a name="ln497">      break;</a>
<a name="ln498">  }</a>
<a name="ln499">  return deflt;</a>
<a name="ln500">}</a>
<a name="ln501"> </a>
<a name="ln502"> </a>
<a name="ln503">// ----------------------------------------------------------------------</a>
<a name="ln504">// FpToString()</a>
<a name="ln505">// FloatToString()</a>
<a name="ln506">// IntToString()</a>
<a name="ln507">//    Convert various types to their string representation, possibly padded</a>
<a name="ln508">//    with spaces, using snprintf format specifiers.</a>
<a name="ln509">// ----------------------------------------------------------------------</a>
<a name="ln510"> </a>
<a name="ln511">string FpToString(Fprint fp) {</a>
<a name="ln512">  char buf[17];</a>
<a name="ln513">  snprintf(buf, sizeof(buf), &quot;%016&quot; PRIx64, fp);</a>
<a name="ln514">  return string(buf);</a>
<a name="ln515">}</a>
<a name="ln516"> </a>
<a name="ln517">// Default arguments</a>
<a name="ln518">string Uint128ToHexString(uint128 ui128) {</a>
<a name="ln519">  char buf[33];</a>
<a name="ln520">  snprintf(buf, sizeof(buf), &quot;%016&quot; PRIx64,</a>
<a name="ln521">           Uint128High64(ui128));</a>
<a name="ln522">  snprintf(buf + 16, sizeof(buf) - 16, &quot;%016&quot; PRIx64,</a>
<a name="ln523">           Uint128Low64(ui128));</a>
<a name="ln524">  return string(buf);</a>
<a name="ln525">}</a>
<a name="ln526"> </a>
<a name="ln527">namespace {</a>
<a name="ln528"> </a>
<a name="ln529">// Represents integer values of digits.</a>
<a name="ln530">// Uses 36 to indicate an invalid character since we support</a>
<a name="ln531">// bases up to 36.</a>
<a name="ln532">static const int8 kAsciiToInt[256] = {</a>
<a name="ln533">  36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,  // 16 36s.</a>
<a name="ln534">  36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,</a>
<a name="ln535">  36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,</a>
<a name="ln536">  0, 1, 2, 3, 4, 5, 6, 7, 8, 9,</a>
<a name="ln537">  36, 36, 36, 36, 36, 36, 36,</a>
<a name="ln538">  10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,</a>
<a name="ln539">  26, 27, 28, 29, 30, 31, 32, 33, 34, 35,</a>
<a name="ln540">  36, 36, 36, 36, 36, 36,</a>
<a name="ln541">  10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,</a>
<a name="ln542">  26, 27, 28, 29, 30, 31, 32, 33, 34, 35,</a>
<a name="ln543">  36, 36, 36, 36, 36,</a>
<a name="ln544">  36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,</a>
<a name="ln545">  36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,</a>
<a name="ln546">  36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,</a>
<a name="ln547">  36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,</a>
<a name="ln548">  36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,</a>
<a name="ln549">  36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,</a>
<a name="ln550">  36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,</a>
<a name="ln551">  36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36 };</a>
<a name="ln552"> </a>
<a name="ln553">// Input format based on POSIX.1-2008 strtol</a>
<a name="ln554">// http://pubs.opengroup.org/onlinepubs/9699919799/functions/strtol.html</a>
<a name="ln555">template&lt;typename IntType&gt;</a>
<a name="ln556">bool safe_int_internal(const char* start, const char* end, int base,</a>
<a name="ln557">                       IntType* value_p) {</a>
<a name="ln558">  // Consume whitespace.</a>
<a name="ln559">  while (start &lt; end &amp;&amp; ascii_isspace(start[0])) {</a>
<a name="ln560">    ++start;</a>
<a name="ln561">  }</a>
<a name="ln562">  while (start &lt; end &amp;&amp; ascii_isspace(end[-1])) {</a>
<a name="ln563">    --end;</a>
<a name="ln564">  }</a>
<a name="ln565">  if (start &gt;= end) {</a>
<a name="ln566">    return false;</a>
<a name="ln567">  }</a>
<a name="ln568"> </a>
<a name="ln569">  // Consume sign.</a>
<a name="ln570">  const bool negative = (start[0] == '-');</a>
<a name="ln571">  if (negative || start[0] == '+') {</a>
<a name="ln572">    ++start;</a>
<a name="ln573">    if (start &gt;= end) {</a>
<a name="ln574">      return false;</a>
<a name="ln575">    }</a>
<a name="ln576">  }</a>
<a name="ln577"> </a>
<a name="ln578">  // Consume base-dependent prefix.</a>
<a name="ln579">  //  base 0: &quot;0x&quot; -&gt; base 16, &quot;0&quot; -&gt; base 8, default -&gt; base 10</a>
<a name="ln580">  //  base 16: &quot;0x&quot; -&gt; base 16</a>
<a name="ln581">  // Also validate the base.</a>
<a name="ln582">  if (base == 0) {</a>
<a name="ln583">    if (end - start &gt;= 2 &amp;&amp; start[0] == '0' &amp;&amp;</a>
<a name="ln584">        (start[1] == 'x' || start[1] == 'X')) {</a>
<a name="ln585">      base = 16;</a>
<a name="ln586">      start += 2;</a>
<a name="ln587">    } else if (end - start &gt;= 1 &amp;&amp; start[0] == '0') {</a>
<a name="ln588">      base = 8;</a>
<a name="ln589">      start += 1;</a>
<a name="ln590">    } else {</a>
<a name="ln591">      base = 10;</a>
<a name="ln592">    }</a>
<a name="ln593">  } else if (base == 16) {</a>
<a name="ln594">    if (end - start &gt;= 2 &amp;&amp; start[0] == '0' &amp;&amp;</a>
<a name="ln595">        (start[1] == 'x' || start[1] == 'X')) {</a>
<a name="ln596">      start += 2;</a>
<a name="ln597">    }</a>
<a name="ln598">  } else if (base &gt;= 2 &amp;&amp; base &lt;= 36) {</a>
<a name="ln599">    // okay</a>
<a name="ln600">  } else {</a>
<a name="ln601">    return false;</a>
<a name="ln602">  }</a>
<a name="ln603"> </a>
<a name="ln604">  // Consume digits.</a>
<a name="ln605">  //</a>
<a name="ln606">  // The classic loop:</a>
<a name="ln607">  //</a>
<a name="ln608">  //   for each digit</a>
<a name="ln609">  //     value = value * base + digit</a>
<a name="ln610">  //   value *= sign</a>
<a name="ln611">  //</a>
<a name="ln612">  // The classic loop needs overflow checking.  It also fails on the most</a>
<a name="ln613">  // negative integer, -2147483648 in 32-bit two's complement representation.</a>
<a name="ln614">  //</a>
<a name="ln615">  // My improved loop:</a>
<a name="ln616">  //</a>
<a name="ln617">  //  if (!negative)</a>
<a name="ln618">  //    for each digit</a>
<a name="ln619">  //      value = value * base</a>
<a name="ln620">  //      value = value + digit</a>
<a name="ln621">  //  else</a>
<a name="ln622">  //    for each digit</a>
<a name="ln623">  //      value = value * base</a>
<a name="ln624">  //      value = value - digit</a>
<a name="ln625">  //</a>
<a name="ln626">  // Overflow checking becomes simple.</a>
<a name="ln627">  //</a>
<a name="ln628">  // I present the positive code first for easier reading.</a>
<a name="ln629">  IntType value = 0;</a>
<a name="ln630">  if (!negative) {</a>
<a name="ln631">    const IntType vmax = std::numeric_limits&lt;IntType&gt;::max();</a>
<a name="ln632">    assert(vmax &gt; 0);</a>
<a name="ln633">    assert(vmax &gt;= base);</a>
<a name="ln634">    const IntType vmax_over_base = vmax / base;</a>
<a name="ln635">    // loop over digits</a>
<a name="ln636">    // loop body is interleaved for perf, not readability</a>
<a name="ln637">    for (; start &lt; end; ++start) {</a>
<a name="ln638">      unsigned char c = static_cast&lt;unsigned char&gt;(start[0]);</a>
<a name="ln639">      int digit = kAsciiToInt[c];</a>
<a name="ln640">      if (value &gt; vmax_over_base) return false;</a>
<a name="ln641">      value *= base;</a>
<a name="ln642">      if (digit &gt;= base) return false;</a>
<a name="ln643">      if (value &gt; vmax - digit) return false;</a>
<a name="ln644">      value += digit;</a>
<a name="ln645">    }</a>
<a name="ln646">  } else {</a>
<a name="ln647">    const IntType vmin = std::numeric_limits&lt;IntType&gt;::min();</a>
<a name="ln648">    assert(vmin &lt; 0);</a>
<a name="ln649">    assert(vmin &lt;= 0 - base);</a>
<a name="ln650">    IntType vmin_over_base = vmin / base;</a>
<a name="ln651">    // 2003 c++ standard [expr.mul]</a>
<a name="ln652">    // &quot;... the sign of the remainder is implementation-defined.&quot;</a>
<a name="ln653">    // Although (vmin/base)*base + vmin%base is always vmin.</a>
<a name="ln654">    // 2011 c++ standard tightens the spec but we cannot rely on it.</a>
<a name="ln655">    if (vmin % base &gt; 0) {</a>
<a name="ln656">      vmin_over_base += 1;</a>
<a name="ln657">    }</a>
<a name="ln658">    // loop over digits</a>
<a name="ln659">    // loop body is interleaved for perf, not readability</a>
<a name="ln660">    for (; start &lt; end; ++start) {</a>
<a name="ln661">      unsigned char c = static_cast&lt;unsigned char&gt;(start[0]);</a>
<a name="ln662">      int digit = kAsciiToInt[c];</a>
<a name="ln663">      if (value &lt; vmin_over_base) return false;</a>
<a name="ln664">      value *= base;</a>
<a name="ln665">      if (digit &gt;= base) return false;</a>
<a name="ln666">      if (value &lt; vmin + digit) return false;</a>
<a name="ln667">      value -= digit;</a>
<a name="ln668">    }</a>
<a name="ln669">  }</a>
<a name="ln670"> </a>
<a name="ln671">  // Store output.</a>
<a name="ln672">  *value_p = value;</a>
<a name="ln673">  return true;</a>
<a name="ln674">}</a>
<a name="ln675"> </a>
<a name="ln676">}  // anonymous namespace</a>
<a name="ln677"> </a>
<a name="ln678">bool safe_strto32_base(const char* startptr, const int buffer_size,</a>
<a name="ln679">                       int32* v, int base) {</a>
<a name="ln680">  return safe_int_internal&lt;int32&gt;(startptr, startptr + buffer_size, base, v);</a>
<a name="ln681">}</a>
<a name="ln682"> </a>
<a name="ln683">bool safe_strto64_base(const char* startptr, const int buffer_size,</a>
<a name="ln684">                       int64* v, int base) {</a>
<a name="ln685">  return safe_int_internal&lt;int64&gt;(startptr, startptr + buffer_size, base, v);</a>
<a name="ln686">}</a>
<a name="ln687"> </a>
<a name="ln688">bool safe_strto32(const char* startptr, const int buffer_size, int32* value) {</a>
<a name="ln689">  return safe_int_internal&lt;int32&gt;(startptr, startptr + buffer_size, 10, value);</a>
<a name="ln690">}</a>
<a name="ln691"> </a>
<a name="ln692">bool safe_strto64(const char* startptr, const int buffer_size, int64* value) {</a>
<a name="ln693">  return safe_int_internal&lt;int64&gt;(startptr, startptr + buffer_size, 10, value);</a>
<a name="ln694">}</a>
<a name="ln695"> </a>
<a name="ln696">bool safe_strto32_base(const char* str, int32* value, int base) {</a>
<a name="ln697">  char* endptr;</a>
<a name="ln698">  errno = 0;  // errno only gets set on errors</a>
<a name="ln699">  *value = strto32(str, &amp;endptr, base);</a>
<a name="ln700">  if (endptr != str) {</a>
<a name="ln701">    while (ascii_isspace(*endptr)) ++endptr;</a>
<a name="ln702">  }</a>
<a name="ln703">  return *str != '\0' &amp;&amp; *endptr == '\0' &amp;&amp; errno == 0;</a>
<a name="ln704">}</a>
<a name="ln705"> </a>
<a name="ln706">bool safe_strto64_base(const char* str, int64* value, int base) {</a>
<a name="ln707">  char* endptr;</a>
<a name="ln708">  errno = 0;  // errno only gets set on errors</a>
<a name="ln709">  *value = strto64(str, &amp;endptr, base);</a>
<a name="ln710">  if (endptr != str) {</a>
<a name="ln711">    while (ascii_isspace(*endptr)) ++endptr;</a>
<a name="ln712">  }</a>
<a name="ln713">  return *str != '\0' &amp;&amp; *endptr == '\0' &amp;&amp; errno == 0;</a>
<a name="ln714">}</a>
<a name="ln715"> </a>
<a name="ln716">bool safe_strtou32_base(const char* str, uint32* value, int base) {</a>
<a name="ln717">  // strtoul does not give any errors on negative numbers, so we have to</a>
<a name="ln718">  // search the string for '-' manually.</a>
<a name="ln719">  while (ascii_isspace(*str)) ++str;</a>
<a name="ln720">  if (*str == '-') return false;</a>
<a name="ln721"> </a>
<a name="ln722">  char* endptr;</a>
<a name="ln723">  errno = 0;  // errno only gets set on errors</a>
<a name="ln724">  *value = strtou32(str, &amp;endptr, base);</a>
<a name="ln725">  if (endptr != str) {</a>
<a name="ln726">    while (ascii_isspace(*endptr)) ++endptr;</a>
<a name="ln727">  }</a>
<a name="ln728">  return *str != '\0' &amp;&amp; *endptr == '\0' &amp;&amp; errno == 0;</a>
<a name="ln729">}</a>
<a name="ln730"> </a>
<a name="ln731">bool safe_strtou64_base(const char* str, uint64* value, int base) {</a>
<a name="ln732">  // strtou64 does not give any errors on negative numbers, so we have to</a>
<a name="ln733">  // search the string for '-' manually.</a>
<a name="ln734">  while (ascii_isspace(*str)) ++str;</a>
<a name="ln735">  if (*str == '-') return false;</a>
<a name="ln736"> </a>
<a name="ln737">  char* endptr;</a>
<a name="ln738">  errno = 0;  // errno only gets set on errors</a>
<a name="ln739">  *value = strtou64(str, &amp;endptr, base);</a>
<a name="ln740">  if (endptr != str) {</a>
<a name="ln741">    while (ascii_isspace(*endptr)) ++endptr;</a>
<a name="ln742">  }</a>
<a name="ln743">  return *str != '\0' &amp;&amp; *endptr == '\0' &amp;&amp; errno == 0;</a>
<a name="ln744">}</a>
<a name="ln745"> </a>
<a name="ln746">// ----------------------------------------------------------------------</a>
<a name="ln747">// u64tostr_base36()</a>
<a name="ln748">//    Converts unsigned number to string representation in base-36.</a>
<a name="ln749">// --------------------------------------------------------------------</a>
<a name="ln750">size_t u64tostr_base36(uint64 number, size_t buf_size, char* buffer) {</a>
<a name="ln751">  CHECK_GT(buf_size, 0);</a>
<a name="ln752">  CHECK(buffer);</a>
<a name="ln753">  static const char kAlphabet[] = &quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;;</a>
<a name="ln754"> </a>
<a name="ln755">  buffer[buf_size - 1] = '\0';</a>
<a name="ln756">  size_t result_size = 1;</a>
<a name="ln757"> </a>
<a name="ln758">  do {</a>
<a name="ln759">    if (buf_size == result_size) {  // Ran out of space.</a>
<a name="ln760">      return 0;</a>
<a name="ln761">    }</a>
<a name="ln762">    int remainder = number % 36;</a>
<a name="ln763">    number /= 36;</a>
<a name="ln764">    buffer[buf_size - result_size - 1] = kAlphabet[remainder];</a>
<a name="ln765">    result_size++;</a>
<a name="ln766">  } while (number);</a>
<a name="ln767"> </a>
<a name="ln768">  memmove(buffer, buffer + buf_size - result_size, result_size);</a>
<a name="ln769"> </a>
<a name="ln770">  return result_size - 1;</a>
<a name="ln771">}</a>
<a name="ln772"> </a>
<a name="ln773">// Generate functions that wrap safe_strtoXXX_base.</a>
<a name="ln774">#define GEN_SAFE_STRTO(name, type)                           \</a>
<a name="ln775">bool name##_base(const string&amp; str, type* value, int base) { \</a>
<a name="ln776">  return name##_base(str.c_str(), value, base);              \</a>
<a name="ln777">}                                                            \</a>
<a name="ln778">bool name(const char* str, type* value) {                    \</a>
<a name="ln779">  return name##_base(str, value, 10);                        \</a>
<a name="ln780">}                                                            \</a>
<a name="ln781">bool name(const string&amp; str, type* value) {                  \</a>
<a name="ln782">  return name##_base(str.c_str(), value, 10);                \</a>
<a name="ln783">}</a>
<a name="ln784">GEN_SAFE_STRTO(safe_strto32, int32);</a>
<a name="ln785">GEN_SAFE_STRTO(safe_strtou32, uint32);</a>
<a name="ln786">GEN_SAFE_STRTO(safe_strto64, int64);</a>
<a name="ln787">GEN_SAFE_STRTO(safe_strtou64, uint64);</a>
<a name="ln788">#undef GEN_SAFE_STRTO</a>
<a name="ln789"> </a>
<a name="ln790">bool safe_strtof(const char* str, float* value) {</a>
<a name="ln791">  char* endptr;</a>
<a name="ln792">#ifdef _MSC_VER  // has no strtof()</a>
<a name="ln793">  *value = strtod(str, &amp;endptr);</a>
<a name="ln794">#else</a>
<a name="ln795">  *value = strtof(str, &amp;endptr);</a>
<a name="ln796">#endif</a>
<a name="ln797">  if (endptr != str) {</a>
<a name="ln798">    while (ascii_isspace(*endptr)) ++endptr;</a>
<a name="ln799">  }</a>
<a name="ln800">  // Ignore range errors from strtod/strtof.</a>
<a name="ln801">  // The values it returns on underflow and</a>
<a name="ln802">  // overflow are the right fallback in a</a>
<a name="ln803">  // robust setting.</a>
<a name="ln804">  return *str != '\0' &amp;&amp; *endptr == '\0';</a>
<a name="ln805">}</a>
<a name="ln806"> </a>
<a name="ln807">bool safe_strtod(const char* str, double* value) {</a>
<a name="ln808">  char* endptr;</a>
<a name="ln809">  *value = strtod(str, &amp;endptr);</a>
<a name="ln810">  if (endptr != str) {</a>
<a name="ln811">    while (ascii_isspace(*endptr)) ++endptr;</a>
<a name="ln812">  }</a>
<a name="ln813">  // Ignore range errors from strtod.  The values it</a>
<a name="ln814">  // returns on underflow and overflow are the right</a>
<a name="ln815">  // fallback in a robust setting.</a>
<a name="ln816">  return *str != '\0' &amp;&amp; *endptr == '\0';</a>
<a name="ln817">}</a>
<a name="ln818"> </a>
<a name="ln819">bool safe_strtof(const string&amp; str, float* value) {</a>
<a name="ln820">  return safe_strtof(str.c_str(), value);</a>
<a name="ln821">}</a>
<a name="ln822"> </a>
<a name="ln823">bool safe_strtod(const string&amp; str, double* value) {</a>
<a name="ln824">  return safe_strtod(str.c_str(), value);</a>
<a name="ln825">}</a>
<a name="ln826"> </a>
<a name="ln827">uint64 atoi_kmgt(const char* s) {</a>
<a name="ln828">  char* endptr;</a>
<a name="ln829">  uint64 n = strtou64(s, &amp;endptr, 10);</a>
<a name="ln830">  uint64 scale = 1;</a>
<a name="ln831">  char c = *endptr;</a>
<a name="ln832">  if (c != '\0') {</a>
<a name="ln833">    c = ascii_toupper(c);</a>
<a name="ln834">    switch (c) {</a>
<a name="ln835">      case 'K':</a>
<a name="ln836">        scale = GG_ULONGLONG(1) &lt;&lt; 10;</a>
<a name="ln837">        break;</a>
<a name="ln838">      case 'M':</a>
<a name="ln839">        scale = GG_ULONGLONG(1) &lt;&lt; 20;</a>
<a name="ln840">        break;</a>
<a name="ln841">      case 'G':</a>
<a name="ln842">        scale = GG_ULONGLONG(1) &lt;&lt; 30;</a>
<a name="ln843">        break;</a>
<a name="ln844">      case 'T':</a>
<a name="ln845">        scale = GG_ULONGLONG(1) &lt;&lt; 40;</a>
<a name="ln846">        break;</a>
<a name="ln847">      default:</a>
<a name="ln848">        LOG(FATAL) &lt;&lt; &quot;Invalid mnemonic: `&quot; &lt;&lt; c &lt;&lt; &quot;';&quot;</a>
<a name="ln849">                   &lt;&lt; &quot; should be one of `K', `M', `G', and `T'.&quot;;</a>
<a name="ln850">    }</a>
<a name="ln851">  }</a>
<a name="ln852">  return n * scale;</a>
<a name="ln853">}</a>
<a name="ln854"> </a>
<a name="ln855">// ----------------------------------------------------------------------</a>
<a name="ln856">// FastIntToBuffer()</a>
<a name="ln857">// FastInt64ToBuffer()</a>
<a name="ln858">// FastHexToBuffer()</a>
<a name="ln859">// FastHex64ToBuffer()</a>
<a name="ln860">// FastHex32ToBuffer()</a>
<a name="ln861">// FastTimeToBuffer()</a>
<a name="ln862">//    These are intended for speed.  FastHexToBuffer() assumes the</a>
<a name="ln863">//    integer is non-negative.  FastHexToBuffer() puts output in</a>
<a name="ln864">//    hex rather than decimal.  FastTimeToBuffer() puts the output</a>
<a name="ln865">//    into RFC822 format.  If time is 0, uses the current time.</a>
<a name="ln866">//</a>
<a name="ln867">//    FastHex64ToBuffer() puts a 64-bit unsigned value in hex-format,</a>
<a name="ln868">//    padded to exactly 16 bytes (plus one byte for '\0')</a>
<a name="ln869">//</a>
<a name="ln870">//    FastHex32ToBuffer() puts a 32-bit unsigned value in hex-format,</a>
<a name="ln871">//    padded to exactly 8 bytes (plus one byte for '\0')</a>
<a name="ln872">//</a>
<a name="ln873">//       All functions take the output buffer as an arg.  FastInt()</a>
<a name="ln874">//    uses at most 22 bytes, FastTime() uses exactly 30 bytes.</a>
<a name="ln875">//    They all return a pointer to the beginning of the output,</a>
<a name="ln876">//    which may not be the beginning of the input buffer.  (Though</a>
<a name="ln877">//    for FastTimeToBuffer(), we guarantee that it is.)</a>
<a name="ln878">// ----------------------------------------------------------------------</a>
<a name="ln879"> </a>
<a name="ln880">char *FastInt64ToBuffer(int64 i, char* buffer) {</a>
<a name="ln881">  FastInt64ToBufferLeft(i, buffer);</a>
<a name="ln882">  return buffer;</a>
<a name="ln883">}</a>
<a name="ln884"> </a>
<a name="ln885">char *FastInt32ToBuffer(int32 i, char* buffer) {</a>
<a name="ln886">  FastInt32ToBufferLeft(i, buffer);</a>
<a name="ln887">  return buffer;</a>
<a name="ln888">}</a>
<a name="ln889"> </a>
<a name="ln890">char *FastHexToBuffer(int i, char* buffer) {</a>
<a name="ln891">  CHECK_GE(i, 0) &lt;&lt; &quot;FastHexToBuffer() wants non-negative integers, not &quot; &lt;&lt; i;</a>
<a name="ln892"> </a>
<a name="ln893">  static const char *hexdigits = &quot;0123456789abcdef&quot;;</a>
<a name="ln894">  char *p = buffer + 21;</a>
<a name="ln895">  *p-- = '\0';</a>
<a name="ln896">  do {</a>
<a name="ln897">    *p-- = hexdigits[i &amp; 15];   // mod by 16</a>
<a name="ln898">    i &gt;&gt;= 4;                    // divide by 16</a>
<a name="ln899">  } while (i &gt; 0);</a>
<a name="ln900">  return p + 1;</a>
<a name="ln901">}</a>
<a name="ln902"> </a>
<a name="ln903">char *InternalFastHexToBuffer(uint64 value, char* buffer, int num_byte) {</a>
<a name="ln904">  static const char *hexdigits = &quot;0123456789abcdef&quot;;</a>
<a name="ln905">  buffer[num_byte] = '\0';</a>
<a name="ln906">  for (int i = num_byte - 1; i &gt;= 0; i--) {</a>
<a name="ln907">    buffer[i] = hexdigits[value &amp; 0xf];</a>
<a name="ln908">    value &gt;&gt;= 4;</a>
<a name="ln909">  }</a>
<a name="ln910">  return buffer;</a>
<a name="ln911">}</a>
<a name="ln912"> </a>
<a name="ln913">char *FastHex64ToBuffer(uint64 value, char* buffer) {</a>
<a name="ln914">  return InternalFastHexToBuffer(value, buffer, 16);</a>
<a name="ln915">}</a>
<a name="ln916"> </a>
<a name="ln917">char *FastHex32ToBuffer(uint32 value, char* buffer) {</a>
<a name="ln918">  return InternalFastHexToBuffer(value, buffer, 8);</a>
<a name="ln919">}</a>
<a name="ln920"> </a>
<a name="ln921">// TODO(user): revisit the two_ASCII_digits optimization.</a>
<a name="ln922">//</a>
<a name="ln923">// Several converters use this table to reduce</a>
<a name="ln924">// division and modulo operations.</a>
<a name="ln925">extern const char two_ASCII_digits[100][2];  // from strutil.cc</a>
<a name="ln926"> </a>
<a name="ln927">// ----------------------------------------------------------------------</a>
<a name="ln928">// FastInt32ToBufferLeft()</a>
<a name="ln929">// FastUInt32ToBufferLeft()</a>
<a name="ln930">// FastInt64ToBufferLeft()</a>
<a name="ln931">// FastUInt64ToBufferLeft()</a>
<a name="ln932">//</a>
<a name="ln933">// Like the Fast*ToBuffer() functions above, these are intended for speed.</a>
<a name="ln934">// Unlike the Fast*ToBuffer() functions, however, these functions write</a>
<a name="ln935">// their output to the beginning of the buffer (hence the name, as the</a>
<a name="ln936">// output is left-aligned).  The caller is responsible for ensuring that</a>
<a name="ln937">// the buffer has enough space to hold the output.</a>
<a name="ln938">//</a>
<a name="ln939">// Returns a pointer to the end of the string (i.e. the null character</a>
<a name="ln940">// terminating the string).</a>
<a name="ln941">// ----------------------------------------------------------------------</a>
<a name="ln942"> </a>
<a name="ln943">char* FastUInt32ToBufferLeft(uint32 u, char* buffer) {</a>
<a name="ln944">  uint digits;</a>
<a name="ln945">  const char *ASCII_digits = nullptr;</a>
<a name="ln946">  // The idea of this implementation is to trim the number of divides to as few</a>
<a name="ln947">  // as possible by using multiplication and subtraction rather than mod (%),</a>
<a name="ln948">  // and by outputting two digits at a time rather than one.</a>
<a name="ln949">  // The huge-number case is first, in the hopes that the compiler will output</a>
<a name="ln950">  // that case in one branch-free block of code, and only output conditional</a>
<a name="ln951">  // branches into it from below.</a>
<a name="ln952">  if (u &gt;= 1000000000) {  // &gt;= 1,000,000,000</a>
<a name="ln953">    digits = u / 100000000;  // 100,000,000</a>
<a name="ln954">    ASCII_digits = two_ASCII_digits[digits];</a>
<a name="ln955">    buffer[0] = ASCII_digits[0];</a>
<a name="ln956">    buffer[1] = ASCII_digits[1];</a>
<a name="ln957">    buffer += 2;</a>
<a name="ln958"> sublt100_000_000:</a>
<a name="ln959">    u -= digits * 100000000;  // 100,000,000</a>
<a name="ln960"> lt100_000_000:</a>
<a name="ln961">    digits = u / 1000000;  // 1,000,000</a>
<a name="ln962">    ASCII_digits = two_ASCII_digits[digits];</a>
<a name="ln963">    buffer[0] = ASCII_digits[0];</a>
<a name="ln964">    buffer[1] = ASCII_digits[1];</a>
<a name="ln965">    buffer += 2;</a>
<a name="ln966"> sublt1_000_000:</a>
<a name="ln967">    u -= digits * 1000000;  // 1,000,000</a>
<a name="ln968"> lt1_000_000:</a>
<a name="ln969">    digits = u / 10000;  // 10,000</a>
<a name="ln970">    ASCII_digits = two_ASCII_digits[digits];</a>
<a name="ln971">    buffer[0] = ASCII_digits[0];</a>
<a name="ln972">    buffer[1] = ASCII_digits[1];</a>
<a name="ln973">    buffer += 2;</a>
<a name="ln974"> sublt10_000:</a>
<a name="ln975">    u -= digits * 10000;  // 10,000</a>
<a name="ln976"> lt10_000:</a>
<a name="ln977">    digits = u / 100;</a>
<a name="ln978">    ASCII_digits = two_ASCII_digits[digits];</a>
<a name="ln979">    buffer[0] = ASCII_digits[0];</a>
<a name="ln980">    buffer[1] = ASCII_digits[1];</a>
<a name="ln981">    buffer += 2;</a>
<a name="ln982"> sublt100:</a>
<a name="ln983">    u -= digits * 100;</a>
<a name="ln984"> lt100:</a>
<a name="ln985">    digits = u;</a>
<a name="ln986">    ASCII_digits = two_ASCII_digits[digits];</a>
<a name="ln987">    buffer[0] = ASCII_digits[0];</a>
<a name="ln988">    buffer[1] = ASCII_digits[1];</a>
<a name="ln989">    buffer += 2;</a>
<a name="ln990"> done:</a>
<a name="ln991">    *buffer = 0;</a>
<a name="ln992">    return buffer;</a>
<a name="ln993">  }</a>
<a name="ln994"> </a>
<a name="ln995">  if (u &lt; 100) {</a>
<a name="ln996">    digits = u;</a>
<a name="ln997">    if (u &gt;= 10) goto lt100;</a>
<a name="ln998">    *buffer++ = '0' + digits;</a>
<a name="ln999">    goto done;</a>
<a name="ln1000">  }</a>
<a name="ln1001">  if (u  &lt;  10000) {   // 10,000</a>
<a name="ln1002">    if (u &gt;= 1000) goto lt10_000;</a>
<a name="ln1003">    digits = u / 100;</a>
<a name="ln1004">    *buffer++ = '0' + digits;</a>
<a name="ln1005">    goto sublt100;</a>
<a name="ln1006">  }</a>
<a name="ln1007">  if (u  &lt;  1000000) {   // 1,000,000</a>
<a name="ln1008">    if (u &gt;= 100000) goto lt1_000_000;</a>
<a name="ln1009">    digits = u / 10000;  //    10,000</a>
<a name="ln1010">    *buffer++ = '0' + digits;</a>
<a name="ln1011">    goto sublt10_000;</a>
<a name="ln1012">  }</a>
<a name="ln1013">  if (u  &lt;  100000000) {   // 100,000,000</a>
<a name="ln1014">    if (u &gt;= 10000000) goto lt100_000_000;</a>
<a name="ln1015">    digits = u / 1000000;  //   1,000,000</a>
<a name="ln1016">    *buffer++ = '0' + digits;</a>
<a name="ln1017">    goto sublt1_000_000;</a>
<a name="ln1018">  }</a>
<a name="ln1019">  // we already know that u &lt; 1,000,000,000</a>
<a name="ln1020">  digits = u / 100000000;   // 100,000,000</a>
<a name="ln1021">  *buffer++ = '0' + digits;</a>
<a name="ln1022">  goto sublt100_000_000;</a>
<a name="ln1023">}</a>
<a name="ln1024"> </a>
<a name="ln1025">char* FastInt32ToBufferLeft(int32 i, char* buffer) {</a>
<a name="ln1026">  uint32 u = i;</a>
<a name="ln1027">  if (i &lt; 0) {</a>
<a name="ln1028">    *buffer++ = '-';</a>
<a name="ln1029">    // We need to do the negation in modular (i.e., &quot;unsigned&quot;)</a>
<a name="ln1030">    // arithmetic; MSVC++ apprently warns for plain &quot;-u&quot;, so</a>
<a name="ln1031">    // we write the equivalent expression &quot;0 - u&quot; instead.</a>
<a name="ln1032">    u = 0 - u;</a>
<a name="ln1033">  }</a>
<a name="ln1034">  return FastUInt32ToBufferLeft(u, buffer);</a>
<a name="ln1035">}</a>
<a name="ln1036"> </a>
<a name="ln1037">char* FastUInt64ToBufferLeft(uint64 u64, char* buffer) {</a>
<a name="ln1038">  uint digits;</a>
<a name="ln1039">  const char *ASCII_digits = nullptr;</a>
<a name="ln1040"> </a>
<a name="ln1041">  uint32 u = static_cast&lt;uint32&gt;(u64);</a>
<a name="ln1042">  if (u == u64) return FastUInt32ToBufferLeft(u, buffer);</a>
<a name="ln1043"> </a>
<a name="ln1044">  uint64 top_11_digits = u64 / 1000000000;</a>
<a name="ln1045">  buffer = FastUInt64ToBufferLeft(top_11_digits, buffer);</a>
<a name="ln1046">  u = u64 - (top_11_digits * 1000000000);</a>
<a name="ln1047"> </a>
<a name="ln1048">  digits = u / 10000000;  // 10,000,000</a>
<a name="ln1049">  DCHECK_LT(digits, 100);</a>
<a name="ln1050">  ASCII_digits = two_ASCII_digits[digits];</a>
<a name="ln1051">  buffer[0] = ASCII_digits[0];</a>
<a name="ln1052">  buffer[1] = ASCII_digits[1];</a>
<a name="ln1053">  buffer += 2;</a>
<a name="ln1054">  u -= digits * 10000000;  // 10,000,000</a>
<a name="ln1055">  digits = u / 100000;  // 100,000</a>
<a name="ln1056">  ASCII_digits = two_ASCII_digits[digits];</a>
<a name="ln1057">  buffer[0] = ASCII_digits[0];</a>
<a name="ln1058">  buffer[1] = ASCII_digits[1];</a>
<a name="ln1059">  buffer += 2;</a>
<a name="ln1060">  u -= digits * 100000;  // 100,000</a>
<a name="ln1061">  digits = u / 1000;  // 1,000</a>
<a name="ln1062">  ASCII_digits = two_ASCII_digits[digits];</a>
<a name="ln1063">  buffer[0] = ASCII_digits[0];</a>
<a name="ln1064">  buffer[1] = ASCII_digits[1];</a>
<a name="ln1065">  buffer += 2;</a>
<a name="ln1066">  u -= digits * 1000;  // 1,000</a>
<a name="ln1067">  digits = u / 10;</a>
<a name="ln1068">  ASCII_digits = two_ASCII_digits[digits];</a>
<a name="ln1069">  buffer[0] = ASCII_digits[0];</a>
<a name="ln1070">  buffer[1] = ASCII_digits[1];</a>
<a name="ln1071">  buffer += 2;</a>
<a name="ln1072">  u -= digits * 10;</a>
<a name="ln1073">  digits = u;</a>
<a name="ln1074">  *buffer++ = '0' + digits;</a>
<a name="ln1075">  *buffer = 0;</a>
<a name="ln1076">  return buffer;</a>
<a name="ln1077">}</a>
<a name="ln1078"> </a>
<a name="ln1079">char* FastInt64ToBufferLeft(int64 i, char* buffer) {</a>
<a name="ln1080">  uint64 u = i;</a>
<a name="ln1081">  if (i &lt; 0) {</a>
<a name="ln1082">    *buffer++ = '-';</a>
<a name="ln1083">    u = 0 - u;</a>
<a name="ln1084">  }</a>
<a name="ln1085">  return FastUInt64ToBufferLeft(u, buffer);</a>
<a name="ln1086">}</a>
<a name="ln1087"> </a>
<a name="ln1088">int HexDigitsPrefix(const char* buf, int num_digits) {</a>
<a name="ln1089">  for (int i = 0; i &lt; num_digits; i++)</a>
<a name="ln1090">    if (!ascii_isxdigit(buf[i]))</a>
<a name="ln1091">      return 0;  // This also detects end of string as '\0' is not xdigit.</a>
<a name="ln1092">  return 1;</a>
<a name="ln1093">}</a>
<a name="ln1094"> </a>
<a name="ln1095">// ----------------------------------------------------------------------</a>
<a name="ln1096">// AutoDigitStrCmp</a>
<a name="ln1097">// AutoDigitLessThan</a>
<a name="ln1098">// StrictAutoDigitLessThan</a>
<a name="ln1099">// autodigit_less</a>
<a name="ln1100">// autodigit_greater</a>
<a name="ln1101">// strict_autodigit_less</a>
<a name="ln1102">// strict_autodigit_greater</a>
<a name="ln1103">//    These are like less&lt;string&gt; and greater&lt;string&gt;, except when a</a>
<a name="ln1104">//    run of digits is encountered at corresponding points in the two</a>
<a name="ln1105">//    arguments.  Such digit strings are compared numerically instead</a>
<a name="ln1106">//    of lexicographically.  Therefore if you sort by</a>
<a name="ln1107">//    &quot;autodigit_less&quot;, some machine names might get sorted as:</a>
<a name="ln1108">//        exaf1</a>
<a name="ln1109">//        exaf2</a>
<a name="ln1110">//        exaf10</a>
<a name="ln1111">//    When using &quot;strict&quot; comparison (AutoDigitStrCmp with the strict flag</a>
<a name="ln1112">//    set to true, or the strict version of the other functions),</a>
<a name="ln1113">//    strings that represent equal numbers will not be considered equal if</a>
<a name="ln1114">//    the string representations are not identical.  That is, &quot;01&quot; &lt; &quot;1&quot; in</a>
<a name="ln1115">//    strict mode, but &quot;01&quot; == &quot;1&quot; otherwise.</a>
<a name="ln1116">// ----------------------------------------------------------------------</a>
<a name="ln1117"> </a>
<a name="ln1118">int AutoDigitStrCmp(const char* a, size_t alen,</a>
<a name="ln1119">                    const char* b, size_t blen,</a>
<a name="ln1120">                    bool strict) {</a>
<a name="ln1121">  size_t aindex = 0;</a>
<a name="ln1122">  size_t bindex = 0;</a>
<a name="ln1123">  while ((aindex &lt; alen) &amp;&amp; (bindex &lt; blen)) {</a>
<a name="ln1124">    if (isdigit(a[aindex]) &amp;&amp; isdigit(b[bindex])) {</a>
<a name="ln1125">      // Compare runs of digits.  Instead of extracting numbers, we</a>
<a name="ln1126">      // just skip leading zeroes, and then get the run-lengths.  This</a>
<a name="ln1127">      // allows us to handle arbitrary precision numbers.  We remember</a>
<a name="ln1128">      // how many zeroes we found so that we can differentiate between</a>
<a name="ln1129">      // &quot;1&quot; and &quot;01&quot; in strict mode.</a>
<a name="ln1130"> </a>
<a name="ln1131">      // Skip leading zeroes, but remember how many we found</a>
<a name="ln1132">      size_t azeroes = aindex;</a>
<a name="ln1133">      size_t bzeroes = bindex;</a>
<a name="ln1134">      while ((aindex &lt; alen) &amp;&amp; (a[aindex] == '0')) aindex++;</a>
<a name="ln1135">      while ((bindex &lt; blen) &amp;&amp; (b[bindex] == '0')) bindex++;</a>
<a name="ln1136">      azeroes = aindex - azeroes;</a>
<a name="ln1137">      bzeroes = bindex - bzeroes;</a>
<a name="ln1138"> </a>
<a name="ln1139">      // Count digit lengths</a>
<a name="ln1140">      size_t astart = aindex;</a>
<a name="ln1141">      size_t bstart = bindex;</a>
<a name="ln1142">      while ((aindex &lt; alen) &amp;&amp; isdigit(a[aindex])) aindex++;</a>
<a name="ln1143">      while ((bindex &lt; blen) &amp;&amp; isdigit(b[bindex])) bindex++;</a>
<a name="ln1144">      if (aindex - astart &lt; bindex - bstart) {</a>
<a name="ln1145">        // a has shorter run of digits: so smaller</a>
<a name="ln1146">        return -1;</a>
<a name="ln1147">      } else if (aindex - astart &gt; bindex - bstart) {</a>
<a name="ln1148">        // a has longer run of digits: so larger</a>
<a name="ln1149">        return 1;</a>
<a name="ln1150">      } else {</a>
<a name="ln1151">        // Same lengths, so compare digit by digit</a>
<a name="ln1152">        for (int i = 0; i &lt; aindex-astart; i++) {</a>
<a name="ln1153">          if (a[astart+i] &lt; b[bstart+i]) {</a>
<a name="ln1154">            return -1;</a>
<a name="ln1155">          } else if (a[astart+i] &gt; b[bstart+i]) {</a>
<a name="ln1156">            return 1;</a>
<a name="ln1157">          }</a>
<a name="ln1158">        }</a>
<a name="ln1159">        // Equal: did one have more leading zeroes?</a>
<a name="ln1160">        if (strict &amp;&amp; azeroes != bzeroes) {</a>
<a name="ln1161">          if (azeroes &gt; bzeroes) {</a>
<a name="ln1162">            // a has more leading zeroes: a &lt; b</a>
<a name="ln1163">            return -1;</a>
<a name="ln1164">          } else {</a>
<a name="ln1165">            // b has more leading zeroes: a &gt; b</a>
<a name="ln1166">            return 1;</a>
<a name="ln1167">          }</a>
<a name="ln1168">        }</a>
<a name="ln1169">        // Equal: so continue scanning</a>
<a name="ln1170">      }</a>
<a name="ln1171">    } else if (a[aindex] &lt; b[bindex]) {</a>
<a name="ln1172">      return -1;</a>
<a name="ln1173">    } else if (a[aindex] &gt; b[bindex]) {</a>
<a name="ln1174">      return 1;</a>
<a name="ln1175">    } else {</a>
<a name="ln1176">      aindex++;</a>
<a name="ln1177">      bindex++;</a>
<a name="ln1178">    }</a>
<a name="ln1179">  }</a>
<a name="ln1180"> </a>
<a name="ln1181">  if (aindex &lt; alen) {</a>
<a name="ln1182">    // b is prefix of a</a>
<a name="ln1183">    return 1;</a>
<a name="ln1184">  } else if (bindex &lt; blen) {</a>
<a name="ln1185">    // a is prefix of b</a>
<a name="ln1186">    return -1;</a>
<a name="ln1187">  } else {</a>
<a name="ln1188">    // a is equal to b</a>
<a name="ln1189">    return 0;</a>
<a name="ln1190">  }</a>
<a name="ln1191">}</a>
<a name="ln1192"> </a>
<a name="ln1193">bool AutoDigitLessThan(const char* a, size_t alen, const char* b, size_t blen) {</a>
<a name="ln1194">  return AutoDigitStrCmp(a, alen, b, blen, false) &lt; 0;</a>
<a name="ln1195">}</a>
<a name="ln1196"> </a>
<a name="ln1197">bool StrictAutoDigitLessThan(const char* a, size_t alen,</a>
<a name="ln1198">                             const char* b, size_t blen) {</a>
<a name="ln1199">  return AutoDigitStrCmp(a, alen, b, blen, true) &lt; 0;</a>
<a name="ln1200">}</a>
<a name="ln1201"> </a>
<a name="ln1202">// ----------------------------------------------------------------------</a>
<a name="ln1203">// SimpleDtoa()</a>
<a name="ln1204">// SimpleFtoa()</a>
<a name="ln1205">// DoubleToBuffer()</a>
<a name="ln1206">// FloatToBuffer()</a>
<a name="ln1207">//    We want to print the value without losing precision, but we also do</a>
<a name="ln1208">//    not want to print more digits than necessary.  This turns out to be</a>
<a name="ln1209">//    trickier than it sounds.  Numbers like 0.2 cannot be represented</a>
<a name="ln1210">//    exactly in binary.  If we print 0.2 with a very large precision,</a>
<a name="ln1211">//    e.g. &quot;%.50g&quot;, we get &quot;0.2000000000000000111022302462515654042363167&quot;.</a>
<a name="ln1212">//    On the other hand, if we set the precision too low, we lose</a>
<a name="ln1213">//    significant digits when printing numbers that actually need them.</a>
<a name="ln1214">//    It turns out there is no precision value that does the right thing</a>
<a name="ln1215">//    for all numbers.</a>
<a name="ln1216">//</a>
<a name="ln1217">//    Our strategy is to first try printing with a precision that is never</a>
<a name="ln1218">//    over-precise, then parse the result with strtod() to see if it</a>
<a name="ln1219">//    matches.  If not, we print again with a precision that will always</a>
<a name="ln1220">//    give a precise result, but may use more digits than necessary.</a>
<a name="ln1221">//</a>
<a name="ln1222">//    An arguably better strategy would be to use the algorithm described</a>
<a name="ln1223">//    in &quot;How to Print Floating-Point Numbers Accurately&quot; by Steele &amp;</a>
<a name="ln1224">//    White, e.g. as implemented by David M. Gay's dtoa().  It turns out,</a>
<a name="ln1225">//    however, that the following implementation is about as fast as</a>
<a name="ln1226">//    DMG's code.  Furthermore, DMG's code locks mutexes, which means it</a>
<a name="ln1227">//    will not scale well on multi-core machines.  DMG's code is slightly</a>
<a name="ln1228">//    more accurate (in that it will never use more digits than</a>
<a name="ln1229">//    necessary), but this is probably irrelevant for most users.</a>
<a name="ln1230">//</a>
<a name="ln1231">//    Rob Pike and Ken Thompson also have an implementation of dtoa() in</a>
<a name="ln1232">//    third_party/fmt/fltfmt.cc.  Their implementation is similar to this</a>
<a name="ln1233">//    one in that it makes guesses and then uses strtod() to check them.</a>
<a name="ln1234">//    Their implementation is faster because they use their own code to</a>
<a name="ln1235">//    generate the digits in the first place rather than use snprintf(),</a>
<a name="ln1236">//    thus avoiding format string parsing overhead.  However, this makes</a>
<a name="ln1237">//    it considerably more complicated than the following implementation,</a>
<a name="ln1238">//    and it is embedded in a larger library.  If speed turns out to be</a>
<a name="ln1239">//    an issue, we could re-implement this in terms of their</a>
<a name="ln1240">//    implementation.</a>
<a name="ln1241">// ----------------------------------------------------------------------</a>
<a name="ln1242"> </a>
<a name="ln1243">string SimpleDtoa(double value) {</a>
<a name="ln1244">  char buffer[kDoubleToBufferSize];</a>
<a name="ln1245">  return DoubleToBuffer(value, buffer);</a>
<a name="ln1246">}</a>
<a name="ln1247"> </a>
<a name="ln1248">string SimpleFtoa(float value) {</a>
<a name="ln1249">  char buffer[kFloatToBufferSize];</a>
<a name="ln1250">  return FloatToBuffer(value, buffer);</a>
<a name="ln1251">}</a>
<a name="ln1252"> </a>
<a name="ln1253">char* DoubleToBuffer(double value, char* buffer) {</a>
<a name="ln1254">  // DBL_DIG is 15 for IEEE-754 doubles, which are used on almost all</a>
<a name="ln1255">  // platforms these days.  Just in case some system exists where DBL_DIG</a>
<a name="ln1256">  // is significantly larger -- and risks overflowing our buffer -- we have</a>
<a name="ln1257">  // this assert.</a>
<a name="ln1258">  COMPILE_ASSERT(DBL_DIG &lt; 20, DBL_DIG_is_too_big);</a>
<a name="ln1259"> </a>
<a name="ln1260">  int snprintf_result =</a>
<a name="ln1261">    snprintf(buffer, kDoubleToBufferSize, &quot;%.*g&quot;, DBL_DIG, value);</a>
<a name="ln1262"> </a>
<a name="ln1263">  // The snprintf should never overflow because the buffer is significantly</a>
<a name="ln1264">  // larger than the precision we asked for.</a>
<a name="ln1265">  DCHECK(snprintf_result &gt; 0 &amp;&amp; snprintf_result &lt; kDoubleToBufferSize);</a>
<a name="ln1266"> </a>
<a name="ln1267">  if (strtod(buffer, nullptr) != value) {</a>
<a name="ln1268">    snprintf_result =</a>
<a name="ln1269">      snprintf(buffer, kDoubleToBufferSize, &quot;%.*g&quot;, DBL_DIG+2, value);</a>
<a name="ln1270"> </a>
<a name="ln1271">    // Should never overflow; see above.</a>
<a name="ln1272">    DCHECK(snprintf_result &gt; 0 &amp;&amp; snprintf_result &lt; kDoubleToBufferSize);</a>
<a name="ln1273">  }</a>
<a name="ln1274">  return buffer;</a>
<a name="ln1275">}</a>
<a name="ln1276"> </a>
<a name="ln1277">char* FloatToBuffer(float value, char* buffer) {</a>
<a name="ln1278">  // FLT_DIG is 6 for IEEE-754 floats, which are used on almost all</a>
<a name="ln1279">  // platforms these days.  Just in case some system exists where FLT_DIG</a>
<a name="ln1280">  // is significantly larger -- and risks overflowing our buffer -- we have</a>
<a name="ln1281">  // this assert.</a>
<a name="ln1282">  COMPILE_ASSERT(FLT_DIG &lt; 10, FLT_DIG_is_too_big);</a>
<a name="ln1283"> </a>
<a name="ln1284">  int snprintf_result =</a>
<a name="ln1285">    snprintf(buffer, kFloatToBufferSize, &quot;%.*g&quot;, FLT_DIG, value);</a>
<a name="ln1286"> </a>
<a name="ln1287">  // The snprintf should never overflow because the buffer is significantly</a>
<a name="ln1288">  // larger than the precision we asked for.</a>
<a name="ln1289">  DCHECK(snprintf_result &gt; 0 &amp;&amp; snprintf_result &lt; kFloatToBufferSize);</a>
<a name="ln1290"> </a>
<a name="ln1291">  float parsed_value;</a>
<a name="ln1292">  if (!safe_strtof(buffer, &amp;parsed_value) || parsed_value != value) {</a>
<a name="ln1293">    snprintf_result =</a>
<a name="ln1294">      snprintf(buffer, kFloatToBufferSize, &quot;%.*g&quot;, FLT_DIG+2, value);</a>
<a name="ln1295"> </a>
<a name="ln1296">    // Should never overflow; see above.</a>
<a name="ln1297">    DCHECK(snprintf_result &gt; 0 &amp;&amp; snprintf_result &lt; kFloatToBufferSize);</a>
<a name="ln1298">  }</a>
<a name="ln1299">  return buffer;</a>
<a name="ln1300">}</a>
<a name="ln1301"> </a>
<a name="ln1302">// ----------------------------------------------------------------------</a>
<a name="ln1303">// SimpleItoaWithCommas()</a>
<a name="ln1304">//    Description: converts an integer to a string.</a>
<a name="ln1305">//    Puts commas every 3 spaces.</a>
<a name="ln1306">//    Faster than printf(&quot;%d&quot;)?</a>
<a name="ln1307">//</a>
<a name="ln1308">//    Return value: string</a>
<a name="ln1309">// ----------------------------------------------------------------------</a>
<a name="ln1310">string SimpleItoaWithCommas(int32 i) {</a>
<a name="ln1311">  // 10 digits, 3 commas, and sign are good for 32-bit or smaller ints.</a>
<a name="ln1312">  // Longest is -2,147,483,648.</a>
<a name="ln1313">  char local[14];</a>
<a name="ln1314">  char *p = local + sizeof(local);</a>
<a name="ln1315">  // Need to use uint32 instead of int32 to correctly handle</a>
<a name="ln1316">  // -2,147,483,648.</a>
<a name="ln1317">  uint32 n = i;</a>
<a name="ln1318">  if (i &lt; 0)</a>
<a name="ln1319">    n = 0 - n;  // negate the unsigned value to avoid overflow</a>
<a name="ln1320">  *--p = '0' + n % 10;          // this case deals with the number &quot;0&quot;</a>
<a name="ln1321">  n /= 10;</a>
<a name="ln1322">  while (n) {</a>
<a name="ln1323">    *--p = '0' + n % 10;</a>
<a name="ln1324">    n /= 10;</a>
<a name="ln1325">    if (n == 0) break;</a>
<a name="ln1326"> </a>
<a name="ln1327">    *--p = '0' + n % 10;</a>
<a name="ln1328">    n /= 10;</a>
<a name="ln1329">    if (n == 0) break;</a>
<a name="ln1330"> </a>
<a name="ln1331">    *--p = ',';</a>
<a name="ln1332">    *--p = '0' + n % 10;</a>
<a name="ln1333">    n /= 10;</a>
<a name="ln1334">    // For this unrolling, we check if n == 0 in the main while loop</a>
<a name="ln1335">  }</a>
<a name="ln1336">  if (i &lt; 0)</a>
<a name="ln1337">    *--p = '-';</a>
<a name="ln1338">  return string(p, local + sizeof(local));</a>
<a name="ln1339">}</a>
<a name="ln1340"> </a>
<a name="ln1341">// We need this overload because otherwise SimpleItoaWithCommas(5U) wouldn't</a>
<a name="ln1342">// compile.</a>
<a name="ln1343">string SimpleItoaWithCommas(uint32 i) {</a>
<a name="ln1344">  // 10 digits and 3 commas are good for 32-bit or smaller ints.</a>
<a name="ln1345">  // Longest is 4,294,967,295.</a>
<a name="ln1346">  char local[13];</a>
<a name="ln1347">  char *p = local + sizeof(local);</a>
<a name="ln1348">  *--p = '0' + i % 10;          // this case deals with the number &quot;0&quot;</a>
<a name="ln1349">  i /= 10;</a>
<a name="ln1350">  while (i) {</a>
<a name="ln1351">    *--p = '0' + i % 10;</a>
<a name="ln1352">    i /= 10;</a>
<a name="ln1353">    if (i == 0) break;</a>
<a name="ln1354"> </a>
<a name="ln1355">    *--p = '0' + i % 10;</a>
<a name="ln1356">    i /= 10;</a>
<a name="ln1357">    if (i == 0) break;</a>
<a name="ln1358"> </a>
<a name="ln1359">    *--p = ',';</a>
<a name="ln1360">    *--p = '0' + i % 10;</a>
<a name="ln1361">    i /= 10;</a>
<a name="ln1362">    // For this unrolling, we check if i == 0 in the main while loop</a>
<a name="ln1363">  }</a>
<a name="ln1364">  return string(p, local + sizeof(local));</a>
<a name="ln1365">}</a>
<a name="ln1366"> </a>
<a name="ln1367">string SimpleItoaWithCommas(int64 i) {</a>
<a name="ln1368">  // 19 digits, 6 commas, and sign are good for 64-bit or smaller ints.</a>
<a name="ln1369">  char local[26];</a>
<a name="ln1370">  char *p = local + sizeof(local);</a>
<a name="ln1371">  // Need to use uint64 instead of int64 to correctly handle</a>
<a name="ln1372">  // -9,223,372,036,854,775,808.</a>
<a name="ln1373">  uint64 n = i;</a>
<a name="ln1374">  if (i &lt; 0)</a>
<a name="ln1375">    n = 0 - n;</a>
<a name="ln1376">  *--p = '0' + n % 10;          // this case deals with the number &quot;0&quot;</a>
<a name="ln1377">  n /= 10;</a>
<a name="ln1378">  while (n) {</a>
<a name="ln1379">    *--p = '0' + n % 10;</a>
<a name="ln1380">    n /= 10;</a>
<a name="ln1381">    if (n == 0) break;</a>
<a name="ln1382"> </a>
<a name="ln1383">    *--p = '0' + n % 10;</a>
<a name="ln1384">    n /= 10;</a>
<a name="ln1385">    if (n == 0) break;</a>
<a name="ln1386"> </a>
<a name="ln1387">    *--p = ',';</a>
<a name="ln1388">    *--p = '0' + n % 10;</a>
<a name="ln1389">    n /= 10;</a>
<a name="ln1390">    // For this unrolling, we check if n == 0 in the main while loop</a>
<a name="ln1391">  }</a>
<a name="ln1392">  if (i &lt; 0)</a>
<a name="ln1393">    *--p = '-';</a>
<a name="ln1394">  return string(p, local + sizeof(local));</a>
<a name="ln1395">}</a>
<a name="ln1396"> </a>
<a name="ln1397">// We need this overload because otherwise SimpleItoaWithCommas(5ULL) wouldn't</a>
<a name="ln1398">// compile.</a>
<a name="ln1399">string SimpleItoaWithCommas(uint64 i) {</a>
<a name="ln1400">  // 20 digits and 6 commas are good for 64-bit or smaller ints.</a>
<a name="ln1401">  // Longest is 18,446,744,073,709,551,615.</a>
<a name="ln1402">  char local[26];</a>
<a name="ln1403">  char *p = local + sizeof(local);</a>
<a name="ln1404">  *--p = '0' + i % 10;          // this case deals with the number &quot;0&quot;</a>
<a name="ln1405">  i /= 10;</a>
<a name="ln1406">  while (i) {</a>
<a name="ln1407">    *--p = '0' + i % 10;</a>
<a name="ln1408">    i /= 10;</a>
<a name="ln1409">    if (i == 0) break;</a>
<a name="ln1410"> </a>
<a name="ln1411">    *--p = '0' + i % 10;</a>
<a name="ln1412">    i /= 10;</a>
<a name="ln1413">    if (i == 0) break;</a>
<a name="ln1414"> </a>
<a name="ln1415">    *--p = ',';</a>
<a name="ln1416">    *--p = '0' + i % 10;</a>
<a name="ln1417">    i /= 10;</a>
<a name="ln1418">    // For this unrolling, we check if i == 0 in the main while loop</a>
<a name="ln1419">  }</a>
<a name="ln1420">  return string(p, local + sizeof(local));</a>
<a name="ln1421">}</a>
<a name="ln1422"> </a>
<a name="ln1423">// ----------------------------------------------------------------------</a>
<a name="ln1424">// ItoaKMGT()</a>
<a name="ln1425">//    Description: converts an integer to a string</a>
<a name="ln1426">//    Truncates values to a readable unit: K, G, M or T</a>
<a name="ln1427">//    Opposite of atoi_kmgt()</a>
<a name="ln1428">//    e.g. 100 -&gt; &quot;100&quot; 1500 -&gt; &quot;1500&quot;  4000 -&gt; &quot;3K&quot;   57185920 -&gt; &quot;45M&quot;</a>
<a name="ln1429">//</a>
<a name="ln1430">//    Return value: string</a>
<a name="ln1431">// ----------------------------------------------------------------------</a>
<a name="ln1432">string ItoaKMGT(int64 i) {</a>
<a name="ln1433">  const char *sign = &quot;&quot;, *suffix = &quot;&quot;;</a>
<a name="ln1434">  if (i &lt; 0) {</a>
<a name="ln1435">    // We lose some accuracy if the caller passes LONG_LONG_MIN, but</a>
<a name="ln1436">    // that's OK as this function is only for human readability</a>
<a name="ln1437">    if (i == numeric_limits&lt;int64&gt;::min()) i++;</a>
<a name="ln1438">    sign = &quot;-&quot;;</a>
<a name="ln1439">    i = -i;</a>
<a name="ln1440">  }</a>
<a name="ln1441"> </a>
<a name="ln1442">  int64 val;</a>
<a name="ln1443"> </a>
<a name="ln1444">  if ((val = (i &gt;&gt; 40)) &gt; 1) {</a>
<a name="ln1445">    suffix = &quot;T&quot;;</a>
<a name="ln1446">  } else if ((val = (i &gt;&gt; 30)) &gt; 1) {</a>
<a name="ln1447">    suffix = &quot;G&quot;;</a>
<a name="ln1448">  } else if ((val = (i &gt;&gt; 20)) &gt; 1) {</a>
<a name="ln1449">    suffix = &quot;M&quot;;</a>
<a name="ln1450">  } else if ((val = (i &gt;&gt; 10)) &gt; 1) {</a>
<a name="ln1451">    suffix = &quot;K&quot;;</a>
<a name="ln1452">  } else {</a>
<a name="ln1453">    val = i;</a>
<a name="ln1454">  }</a>
<a name="ln1455"> </a>
<a name="ln1456">  return StringPrintf(&quot;%s%&quot; PRId64 &quot;%s&quot;, sign, val, suffix);</a>
<a name="ln1457">}</a>
<a name="ln1458"> </a>
<a name="ln1459">// DEPRECATED(wadetregaskis).</a>
<a name="ln1460">// These are non-inline because some BUILD files turn on -Wformat-non-literal.</a>
<a name="ln1461"> </a>
<a name="ln1462">string FloatToString(float f, const char* format) {</a>
<a name="ln1463">  return StringPrintf(format, f);</a>
<a name="ln1464">}</a>
<a name="ln1465"> </a>
<a name="ln1466">string IntToString(int i, const char* format) {</a>
<a name="ln1467">  return StringPrintf(format, i);</a>
<a name="ln1468">}</a>
<a name="ln1469"> </a>
<a name="ln1470">string Int64ToString(int64 i64, const char* format) {</a>
<a name="ln1471">  return StringPrintf(format, i64);</a>
<a name="ln1472">}</a>
<a name="ln1473"> </a>
<a name="ln1474">string UInt64ToString(uint64 ui64, const char* format) {</a>
<a name="ln1475">  return StringPrintf(format, ui64);</a>
<a name="ln1476">}</a>
<a name="ln1477"> </a>
<a name="ln1478">namespace {</a>
<a name="ln1479">  constexpr int64_t kBytesPerGB = 1000000000;</a>
<a name="ln1480">  constexpr int64_t kBytesPerMB = 1000000;</a>
<a name="ln1481">  constexpr int64_t kBytesPerKB = 1000;</a>
<a name="ln1482">}</a>
<a name="ln1483"> </a>
<a name="ln1484">string HumanizeBytes(uint64_t bytes, int precision) {</a>
<a name="ln1485">  std::ostringstream op_stream;</a>
<a name="ln1486">  op_stream &lt;&lt; std::fixed &lt;&lt; std::setprecision(precision);</a>
<a name="ln1487">  if (bytes &gt;= kBytesPerGB) {</a>
<a name="ln1488">    op_stream &lt;&lt; static_cast&lt;double&gt; (bytes)/kBytesPerGB &lt;&lt; &quot; GB&quot;;</a>
<a name="ln1489">  } else if (bytes &gt;= kBytesPerMB) {</a>
<a name="ln1490">    op_stream &lt;&lt; static_cast&lt;double&gt; (bytes)/kBytesPerMB &lt;&lt; &quot; MB&quot;;</a>
<a name="ln1491">  } else if (bytes &gt;= kBytesPerKB) {</a>
<a name="ln1492">    op_stream &lt;&lt; static_cast&lt;double&gt; (bytes)/kBytesPerKB &lt;&lt; &quot; KB&quot;;</a>
<a name="ln1493">  } else {</a>
<a name="ln1494">    op_stream &lt;&lt; bytes &lt;&lt; &quot; B&quot;;</a>
<a name="ln1495">  }</a>
<a name="ln1496">  return op_stream.str();</a>
<a name="ln1497">}</a>

</code></pre>
<div class="balloon" rel="752"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="755"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1004/" target="_blank">V1004</a> The 'buffer' pointer was used unsafely after it was verified against nullptr. Check lines: 752, 755.</p></div>
<div class="balloon" rel="1265"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1272"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1289"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1297"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
