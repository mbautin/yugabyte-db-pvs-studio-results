
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>catalog_entity_info.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Licensed to the Apache Software Foundation (ASF) under one</a>
<a name="ln2">// or more contributor license agreements.  See the NOTICE file</a>
<a name="ln3">// distributed with this work for additional information</a>
<a name="ln4">// regarding copyright ownership.  The ASF licenses this file</a>
<a name="ln5">// to you under the Apache License, Version 2.0 (the</a>
<a name="ln6">// &quot;License&quot;); you may not use this file except in compliance</a>
<a name="ln7">// with the License.  You may obtain a copy of the License at</a>
<a name="ln8">//</a>
<a name="ln9">//   http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln10">//</a>
<a name="ln11">// Unless required by applicable law or agreed to in writing,</a>
<a name="ln12">// software distributed under the License is distributed on an</a>
<a name="ln13">// &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</a>
<a name="ln14">// KIND, either express or implied.  See the License for the</a>
<a name="ln15">// specific language governing permissions and limitations</a>
<a name="ln16">// under the License.</a>
<a name="ln17">//</a>
<a name="ln18">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln19">//</a>
<a name="ln20">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln21">//</a>
<a name="ln22">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln23">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln24">//</a>
<a name="ln25">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln26">//</a>
<a name="ln27">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln28">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln29">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln30">// under the License.</a>
<a name="ln31">//</a>
<a name="ln32"> </a>
<a name="ln33">#ifndef YB_MASTER_CATALOG_ENTITY_INFO_H</a>
<a name="ln34">#define YB_MASTER_CATALOG_ENTITY_INFO_H</a>
<a name="ln35"> </a>
<a name="ln36">#include &lt;shared_mutex&gt;</a>
<a name="ln37"> </a>
<a name="ln38">#include &lt;mutex&gt;</a>
<a name="ln39"> </a>
<a name="ln40">#include &quot;yb/master/ts_descriptor.h&quot;</a>
<a name="ln41">#include &quot;yb/master/master.pb.h&quot;</a>
<a name="ln42">#include &quot;yb/master/tasks_tracker.h&quot;</a>
<a name="ln43">#include &quot;yb/util/cow_object.h&quot;</a>
<a name="ln44">#include &quot;yb/common/entity_ids.h&quot;</a>
<a name="ln45">#include &quot;yb/util/monotime.h&quot;</a>
<a name="ln46">#include &quot;yb/server/monitored_task.h&quot;</a>
<a name="ln47">#include &quot;yb/common/schema.h&quot;</a>
<a name="ln48">#include &quot;yb/common/index.h&quot;</a>
<a name="ln49"> </a>
<a name="ln50">namespace yb {</a>
<a name="ln51">namespace master {</a>
<a name="ln52"> </a>
<a name="ln53">// Information on a current replica of a tablet.</a>
<a name="ln54">// This is copyable so that no locking is needed.</a>
<a name="ln55">struct TabletReplica {</a>
<a name="ln56">  TSDescriptor* ts_desc;</a>
<a name="ln57">  tablet::RaftGroupStatePB state;</a>
<a name="ln58">  consensus::RaftPeerPB::Role role;</a>
<a name="ln59">  consensus::RaftPeerPB::MemberType member_type;</a>
<a name="ln60">  MonoTime time_updated;</a>
<a name="ln61"> </a>
<a name="ln62">  TabletReplica() : time_updated(MonoTime::Now()) {}</a>
<a name="ln63"> </a>
<a name="ln64">  void UpdateFrom(const TabletReplica&amp; source);</a>
<a name="ln65"> </a>
<a name="ln66">  bool IsStale() const;</a>
<a name="ln67"> </a>
<a name="ln68">  bool IsStarting() const;</a>
<a name="ln69"> </a>
<a name="ln70">  std::string ToString() const;</a>
<a name="ln71">};</a>
<a name="ln72"> </a>
<a name="ln73">// This class is a base wrapper around the protos that get serialized in the data column of the</a>
<a name="ln74">// sys_catalog. Subclasses of this will provide convenience getter/setter methods around the</a>
<a name="ln75">// protos and instances of these will be wrapped around CowObjects and locks for access and</a>
<a name="ln76">// modifications.</a>
<a name="ln77">template &lt;class DataEntryPB, SysRowEntry::Type entry_type&gt;</a>
<a name="ln78">struct Persistent {</a>
<a name="ln79">  // Type declaration to be used in templated read/write methods. We are using typename</a>
<a name="ln80">  // Class::data_type in templated methods for figuring out the type we need.</a>
<a name="ln81">  typedef DataEntryPB data_type;</a>
<a name="ln82"> </a>
<a name="ln83">  // Subclasses of this need to provide a valid value of the entry type through</a>
<a name="ln84">  // the template class argument.</a>
<a name="ln85">  static SysRowEntry::Type type() { return entry_type; }</a>
<a name="ln86"> </a>
<a name="ln87">  // The proto that is persisted in the sys_catalog.</a>
<a name="ln88">  DataEntryPB pb;</a>
<a name="ln89">};</a>
<a name="ln90"> </a>
<a name="ln91">// This class is used to manage locking of the persistent metadata returned from the</a>
<a name="ln92">// MetadataCowWrapper objects.</a>
<a name="ln93">template &lt;class MetadataClass&gt;</a>
<a name="ln94">class MetadataLock : public CowLock&lt;typename MetadataClass::cow_state&gt; {</a>
<a name="ln95"> public:</a>
<a name="ln96">  typedef CowLock&lt;typename MetadataClass::cow_state&gt; super;</a>
<a name="ln97">  MetadataLock(MetadataClass* info, typename super::LockMode mode)</a>
<a name="ln98">      : super(DCHECK_NOTNULL(info)-&gt;mutable_metadata(), mode) {}</a>
<a name="ln99">  MetadataLock(const MetadataClass* info, typename super::LockMode mode)</a>
<a name="ln100">      : super(&amp;(DCHECK_NOTNULL(info))-&gt;metadata(), mode) {}</a>
<a name="ln101">};</a>
<a name="ln102"> </a>
<a name="ln103">// This class is a base wrapper around accessors for the persistent proto data, through CowObject.</a>
<a name="ln104">// The locks are taken on subclasses of this class, around the object returned from metadata().</a>
<a name="ln105">template &lt;class PersistentDataEntryPB&gt;</a>
<a name="ln106">class MetadataCowWrapper {</a>
<a name="ln107"> public:</a>
<a name="ln108">  // Type declaration for use in the Lock classes.</a>
<a name="ln109">  typedef PersistentDataEntryPB cow_state;</a>
<a name="ln110">  typedef MetadataLock&lt;MetadataCowWrapper&lt;PersistentDataEntryPB&gt;&gt; lock_type;</a>
<a name="ln111"> </a>
<a name="ln112">  // This method should return the id to be written into the sys_catalog id column.</a>
<a name="ln113">  virtual const std::string&amp; id() const = 0;</a>
<a name="ln114"> </a>
<a name="ln115">  // Pretty printing.</a>
<a name="ln116">  virtual std::string ToString() const {</a>
<a name="ln117">    return strings::Substitute(</a>
<a name="ln118">        &quot;Object type = $0 (id = $1)&quot;, PersistentDataEntryPB::type(), id());</a>
<a name="ln119">  }</a>
<a name="ln120"> </a>
<a name="ln121">  // Access the persistent metadata. Typically you should use</a>
<a name="ln122">  // MetadataLock to gain access to this data.</a>
<a name="ln123">  const CowObject&lt;PersistentDataEntryPB&gt;&amp; metadata() const { return metadata_; }</a>
<a name="ln124">  CowObject&lt;PersistentDataEntryPB&gt;* mutable_metadata() { return &amp;metadata_; }</a>
<a name="ln125"> </a>
<a name="ln126">  std::unique_ptr&lt;lock_type&gt; LockForRead() const {</a>
<a name="ln127">    return std::unique_ptr&lt;lock_type&gt;(new lock_type(this, lock_type::READ));</a>
<a name="ln128">  }</a>
<a name="ln129"> </a>
<a name="ln130">  std::unique_ptr&lt;lock_type&gt; LockForWrite() {</a>
<a name="ln131">    return std::unique_ptr&lt;lock_type&gt;(new lock_type(this, lock_type::WRITE));</a>
<a name="ln132">  }</a>
<a name="ln133"> </a>
<a name="ln134"> protected:</a>
<a name="ln135">  virtual ~MetadataCowWrapper() = default;</a>
<a name="ln136">  CowObject&lt;PersistentDataEntryPB&gt; metadata_;</a>
<a name="ln137">};</a>
<a name="ln138"> </a>
<a name="ln139">// The data related to a tablet which is persisted on disk.</a>
<a name="ln140">// This portion of TabletInfo is managed via CowObject.</a>
<a name="ln141">// It wraps the underlying protobuf to add useful accessors.</a>
<a name="ln142">struct PersistentTabletInfo : public Persistent&lt;SysTabletsEntryPB, SysRowEntry::TABLET&gt; {</a>
<a name="ln143">  bool is_running() const {</a>
<a name="ln144">    return pb.state() == SysTabletsEntryPB::RUNNING;</a>
<a name="ln145">  }</a>
<a name="ln146"> </a>
<a name="ln147">  bool is_deleted() const {</a>
<a name="ln148">    return pb.state() == SysTabletsEntryPB::REPLACED ||</a>
<a name="ln149">           pb.state() == SysTabletsEntryPB::DELETED;</a>
<a name="ln150">  }</a>
<a name="ln151"> </a>
<a name="ln152">  bool is_colocated() const {</a>
<a name="ln153">    return pb.colocated();</a>
<a name="ln154">  }</a>
<a name="ln155"> </a>
<a name="ln156">  // Helper to set the state of the tablet with a custom message.</a>
<a name="ln157">  // Requires that the caller has prepared this object for write.</a>
<a name="ln158">  // The change will only be visible after Commit().</a>
<a name="ln159">  void set_state(SysTabletsEntryPB::State state, const std::string&amp; msg);</a>
<a name="ln160">};</a>
<a name="ln161"> </a>
<a name="ln162">class TableInfo;</a>
<a name="ln163"> </a>
<a name="ln164">typedef std::unordered_map&lt;TabletServerId, MonoTime&gt; LeaderStepDownFailureTimes;</a>
<a name="ln165"> </a>
<a name="ln166">// The information about a single tablet which exists in the cluster,</a>
<a name="ln167">// including its state and locations.</a>
<a name="ln168">//</a>
<a name="ln169">// This object uses copy-on-write for the portions of data which are persisted</a>
<a name="ln170">// on disk. This allows the mutated data to be staged and written to disk</a>
<a name="ln171">// while readers continue to access the previous version. These portions</a>
<a name="ln172">// of data are in PersistentTabletInfo above, and typically accessed using</a>
<a name="ln173">// MetadataLock. For example:</a>
<a name="ln174">//</a>
<a name="ln175">//   TabletInfo* tablet = ...;</a>
<a name="ln176">//   MetadataLock l = tablet-&gt;LockForRead();</a>
<a name="ln177">//   if (l.data().is_running()) { ... }</a>
<a name="ln178">//</a>
<a name="ln179">// The non-persistent information about the tablet is protected by an internal</a>
<a name="ln180">// spin-lock.</a>
<a name="ln181">//</a>
<a name="ln182">// The object is owned/managed by the CatalogManager, and exposed for testing.</a>
<a name="ln183">class TabletInfo : public RefCountedThreadSafe&lt;TabletInfo&gt;,</a>
<a name="ln184">                   public MetadataCowWrapper&lt;PersistentTabletInfo&gt; {</a>
<a name="ln185"> public:</a>
<a name="ln186">  typedef std::unordered_map&lt;std::string, TabletReplica&gt; ReplicaMap;</a>
<a name="ln187"> </a>
<a name="ln188">  TabletInfo(const scoped_refptr&lt;TableInfo&gt;&amp; table, TabletId tablet_id);</a>
<a name="ln189">  virtual const TabletId&amp; id() const override { return tablet_id_; }</a>
<a name="ln190"> </a>
<a name="ln191">  const TabletId&amp; tablet_id() const { return tablet_id_; }</a>
<a name="ln192">  const scoped_refptr&lt;TableInfo&gt;&amp; table() const { return table_; }</a>
<a name="ln193"> </a>
<a name="ln194">  // Accessors for the latest known tablet replica locations.</a>
<a name="ln195">  // These locations include only the members of the latest-reported Raft</a>
<a name="ln196">  // configuration whose tablet servers have ever heartbeated to this Master.</a>
<a name="ln197">  void SetReplicaLocations(ReplicaMap replica_locations);</a>
<a name="ln198">  void GetReplicaLocations(ReplicaMap* replica_locations) const;</a>
<a name="ln199">  Result&lt;TSDescriptor*&gt; GetLeader() const;</a>
<a name="ln200"> </a>
<a name="ln201">  // Replaces a replica in replica_locations_ map if it exists. Otherwise, it adds it to the map.</a>
<a name="ln202">  void UpdateReplicaLocations(const TabletReplica&amp; replica);</a>
<a name="ln203"> </a>
<a name="ln204">  // Accessors for the last time the replica locations were updated.</a>
<a name="ln205">  void set_last_update_time(const MonoTime&amp; ts);</a>
<a name="ln206">  MonoTime last_update_time() const;</a>
<a name="ln207"> </a>
<a name="ln208">  // Accessors for the last reported schema version.</a>
<a name="ln209">  bool set_reported_schema_version(const TableId&amp; table_id, uint32_t version);</a>
<a name="ln210">  uint32_t reported_schema_version(const TableId&amp; table_id);</a>
<a name="ln211"> </a>
<a name="ln212">  bool colocated() const;</a>
<a name="ln213"> </a>
<a name="ln214">  // No synchronization needed.</a>
<a name="ln215">  std::string ToString() const override;</a>
<a name="ln216"> </a>
<a name="ln217">  // This is called when a leader stepdown request fails. Optionally, takes an amount of time since</a>
<a name="ln218">  // the stepdown failure, in case it happened in the past (e.g. we talked to a tablet server and</a>
<a name="ln219">  // it told us that it previously tried to step down in favor of this server and that server lost</a>
<a name="ln220">  // the election).</a>
<a name="ln221">  void RegisterLeaderStepDownFailure(const TabletServerId&amp; intended_leader,</a>
<a name="ln222">                                     MonoDelta time_since_stepdown_failure);</a>
<a name="ln223"> </a>
<a name="ln224">  // Retrieves a map of recent leader step-down failures. At the same time, forgets about step-down</a>
<a name="ln225">  // failures that happened before a certain point in time.</a>
<a name="ln226">  void GetLeaderStepDownFailureTimes(MonoTime forget_failures_before,</a>
<a name="ln227">                                     LeaderStepDownFailureTimes* dest);</a>
<a name="ln228"> </a>
<a name="ln229">  CHECKED_STATUS CheckRunning() const;</a>
<a name="ln230"> </a>
<a name="ln231"> private:</a>
<a name="ln232">  friend class RefCountedThreadSafe&lt;TabletInfo&gt;;</a>
<a name="ln233"> </a>
<a name="ln234">  class LeaderChangeReporter;</a>
<a name="ln235">  friend class LeaderChangeReporter;</a>
<a name="ln236"> </a>
<a name="ln237">  ~TabletInfo();</a>
<a name="ln238">  TSDescriptor* GetLeaderUnlocked() const;</a>
<a name="ln239"> </a>
<a name="ln240">  const TabletId tablet_id_;</a>
<a name="ln241">  const scoped_refptr&lt;TableInfo&gt; table_;</a>
<a name="ln242"> </a>
<a name="ln243">  // Lock protecting the below mutable fields.</a>
<a name="ln244">  // This doesn't protect metadata_ (the on-disk portion).</a>
<a name="ln245">  mutable simple_spinlock lock_;</a>
<a name="ln246"> </a>
<a name="ln247">  // The last time the replica locations were updated.</a>
<a name="ln248">  // Also set when the Master first attempts to create the tablet.</a>
<a name="ln249">  MonoTime last_update_time_;</a>
<a name="ln250"> </a>
<a name="ln251">  // The locations in the latest Raft config where this tablet has been</a>
<a name="ln252">  // reported. The map is keyed by tablet server UUID.</a>
<a name="ln253">  ReplicaMap replica_locations_;</a>
<a name="ln254"> </a>
<a name="ln255">  // Reported schema version (in-memory only).</a>
<a name="ln256">  std::unordered_map&lt;TableId, uint32_t&gt; reported_schema_version_ = {};</a>
<a name="ln257"> </a>
<a name="ln258">  LeaderStepDownFailureTimes leader_stepdown_failure_times_;</a>
<a name="ln259"> </a>
<a name="ln260">  DISALLOW_COPY_AND_ASSIGN(TabletInfo);</a>
<a name="ln261">};</a>
<a name="ln262"> </a>
<a name="ln263">// The data related to a table which is persisted on disk.</a>
<a name="ln264">// This portion of TableInfo is managed via CowObject.</a>
<a name="ln265">// It wraps the underlying protobuf to add useful accessors.</a>
<a name="ln266">struct PersistentTableInfo : public Persistent&lt;SysTablesEntryPB, SysRowEntry::TABLE&gt; {</a>
<a name="ln267">  bool started_deleting() const {</a>
<a name="ln268">    return pb.state() == SysTablesEntryPB::DELETING ||</a>
<a name="ln269">           pb.state() == SysTablesEntryPB::DELETED;</a>
<a name="ln270">  }</a>
<a name="ln271"> </a>
<a name="ln272">  bool is_deleted() const {</a>
<a name="ln273">    return pb.state() == SysTablesEntryPB::DELETED;</a>
<a name="ln274">  }</a>
<a name="ln275"> </a>
<a name="ln276">  bool is_deleting() const {</a>
<a name="ln277">    return pb.state() == SysTablesEntryPB::DELETING;</a>
<a name="ln278">  }</a>
<a name="ln279"> </a>
<a name="ln280">  bool is_running() const {</a>
<a name="ln281">    return pb.state() == SysTablesEntryPB::RUNNING ||</a>
<a name="ln282">           pb.state() == SysTablesEntryPB::ALTERING;</a>
<a name="ln283">  }</a>
<a name="ln284"> </a>
<a name="ln285">  // Return the table's name.</a>
<a name="ln286">  const TableName&amp; name() const {</a>
<a name="ln287">    return pb.name();</a>
<a name="ln288">  }</a>
<a name="ln289"> </a>
<a name="ln290">  // Return the table's type.</a>
<a name="ln291">  const TableType table_type() const {</a>
<a name="ln292">    return pb.table_type();</a>
<a name="ln293">  }</a>
<a name="ln294"> </a>
<a name="ln295">  // Return the table's namespace id.</a>
<a name="ln296">  const NamespaceId&amp; namespace_id() const { return pb.namespace_id(); }</a>
<a name="ln297">  // Return the table's namespace name.</a>
<a name="ln298">  const NamespaceName&amp; namespace_name() const { return pb.namespace_name(); }</a>
<a name="ln299"> </a>
<a name="ln300">  const SchemaPB&amp; schema() const {</a>
<a name="ln301">    return pb.schema();</a>
<a name="ln302">  }</a>
<a name="ln303"> </a>
<a name="ln304">  SchemaPB* mutable_schema() {</a>
<a name="ln305">    return pb.mutable_schema();</a>
<a name="ln306">  }</a>
<a name="ln307"> </a>
<a name="ln308">  // Helper to set the state of the tablet with a custom message.</a>
<a name="ln309">  void set_state(SysTablesEntryPB::State state, const std::string&amp; msg);</a>
<a name="ln310">};</a>
<a name="ln311"> </a>
<a name="ln312">// The information about a table, including its state and tablets.</a>
<a name="ln313">//</a>
<a name="ln314">// This object uses copy-on-write techniques similarly to TabletInfo.</a>
<a name="ln315">// Please see the TabletInfo class doc above for more information.</a>
<a name="ln316">//</a>
<a name="ln317">// The non-persistent information about the table is protected by an internal</a>
<a name="ln318">// spin-lock.</a>
<a name="ln319">class TableInfo : public RefCountedThreadSafe&lt;TableInfo&gt;,</a>
<a name="ln320">                  public MetadataCowWrapper&lt;PersistentTableInfo&gt; {</a>
<a name="ln321"> public:</a>
<a name="ln322">  explicit TableInfo(TableId table_id, scoped_refptr&lt;TasksTracker&gt; tasks_tracker = nullptr);</a>
<a name="ln323"> </a>
<a name="ln324">  const TableName name() const;</a>
<a name="ln325"> </a>
<a name="ln326">  bool is_running() const;</a>
<a name="ln327"> </a>
<a name="ln328">  std::string ToString() const override;</a>
<a name="ln329">  std::string ToStringWithState() const;</a>
<a name="ln330"> </a>
<a name="ln331">  const NamespaceId namespace_id() const;</a>
<a name="ln332">  const NamespaceName namespace_name() const;</a>
<a name="ln333"> </a>
<a name="ln334">  const CHECKED_STATUS GetSchema(Schema* schema) const;</a>
<a name="ln335"> </a>
<a name="ln336">  bool colocated() const;</a>
<a name="ln337"> </a>
<a name="ln338">  // Return the table's ID. Does not require synchronization.</a>
<a name="ln339">  virtual const std::string&amp; id() const override { return table_id_; }</a>
<a name="ln340"> </a>
<a name="ln341">  // Return the indexed table id if the table is an index table. Otherwise, return an empty string.</a>
<a name="ln342">  const std::string indexed_table_id() const;</a>
<a name="ln343"> </a>
<a name="ln344">  bool is_index() const {</a>
<a name="ln345">    return !indexed_table_id().empty();</a>
<a name="ln346">  }</a>
<a name="ln347"> </a>
<a name="ln348">  // For index table</a>
<a name="ln349">  bool is_local_index() const;</a>
<a name="ln350">  bool is_unique_index() const;</a>
<a name="ln351"> </a>
<a name="ln352">  // Return the table type of the table.</a>
<a name="ln353">  TableType GetTableType() const;</a>
<a name="ln354"> </a>
<a name="ln355">  // Checks if the table is the internal redis table.</a>
<a name="ln356">  bool IsRedisTable() const {</a>
<a name="ln357">    return GetTableType() == REDIS_TABLE_TYPE;</a>
<a name="ln358">  }</a>
<a name="ln359"> </a>
<a name="ln360">  // Add a tablet to this table.</a>
<a name="ln361">  void AddTablet(TabletInfo *tablet);</a>
<a name="ln362"> </a>
<a name="ln363">  // Add multiple tablets to this table.</a>
<a name="ln364">  void AddTablets(const std::vector&lt;TabletInfo*&gt;&amp; tablets);</a>
<a name="ln365"> </a>
<a name="ln366">  // Return true if tablet with 'partition_key_start' has been</a>
<a name="ln367">  // removed from 'tablet_map_' below.</a>
<a name="ln368">  bool RemoveTablet(const std::string&amp; partition_key_start);</a>
<a name="ln369"> </a>
<a name="ln370">  // This only returns tablets which are in RUNNING state.</a>
<a name="ln371">  void GetTabletsInRange(const GetTableLocationsRequestPB* req, TabletInfos *ret) const;</a>
<a name="ln372"> </a>
<a name="ln373">  // Get all tablets of the table.</a>
<a name="ln374">  void GetAllTablets(TabletInfos *ret) const;</a>
<a name="ln375"> </a>
<a name="ln376">  // Get the tablet of the table.  The table must be colocated.</a>
<a name="ln377">  TabletInfoPtr GetColocatedTablet() const;</a>
<a name="ln378"> </a>
<a name="ln379">  // Get info of the specified index.</a>
<a name="ln380">  IndexInfo GetIndexInfo(const TableId&amp; index_id) const;</a>
<a name="ln381"> </a>
<a name="ln382">  // Returns true if all tablets of the table are deleted.</a>
<a name="ln383">  bool AreAllTabletsDeleted() const;</a>
<a name="ln384"> </a>
<a name="ln385">  // Returns true if the table creation is in-progress.</a>
<a name="ln386">  bool IsCreateInProgress() const;</a>
<a name="ln387"> </a>
<a name="ln388">  // Returns true if the table is backfilling an index.</a>
<a name="ln389">  bool IsBackfilling() const {</a>
<a name="ln390">    std::shared_lock&lt;decltype(lock_)&gt; l(lock_);</a>
<a name="ln391">    return is_backfilling_;</a>
<a name="ln392">  }</a>
<a name="ln393"> </a>
<a name="ln394">  void SetIsBackfilling(bool flag) {</a>
<a name="ln395">    std::lock_guard&lt;decltype(lock_)&gt; l(lock_);</a>
<a name="ln396">    is_backfilling_ = flag;</a>
<a name="ln397">  }</a>
<a name="ln398"> </a>
<a name="ln399">  // Returns true if an &quot;Alter&quot; operation is in-progress.</a>
<a name="ln400">  bool IsAlterInProgress(uint32_t version) const;</a>
<a name="ln401"> </a>
<a name="ln402">  // Set the Status related to errors on CreateTable.</a>
<a name="ln403">  void SetCreateTableErrorStatus(const Status&amp; status);</a>
<a name="ln404"> </a>
<a name="ln405">  // Get the Status of the last error from the current CreateTable.</a>
<a name="ln406">  CHECKED_STATUS GetCreateTableErrorStatus() const;</a>
<a name="ln407"> </a>
<a name="ln408">  std::size_t NumLBTasks() const;</a>
<a name="ln409">  std::size_t NumTasks() const;</a>
<a name="ln410">  bool HasTasks() const;</a>
<a name="ln411">  bool HasTasks(MonitoredTask::Type type) const;</a>
<a name="ln412">  void AddTask(std::shared_ptr&lt;MonitoredTask&gt; task);</a>
<a name="ln413">  void RemoveTask(const std::shared_ptr&lt;MonitoredTask&gt;&amp; task);</a>
<a name="ln414">  void AbortTasks();</a>
<a name="ln415">  void AbortTasksAndClose();</a>
<a name="ln416">  void WaitTasksCompletion();</a>
<a name="ln417"> </a>
<a name="ln418">  // Allow for showing outstanding tasks in the master UI.</a>
<a name="ln419">  std::unordered_set&lt;std::shared_ptr&lt;MonitoredTask&gt;&gt; GetTasks();</a>
<a name="ln420"> </a>
<a name="ln421"> private:</a>
<a name="ln422">  friend class RefCountedThreadSafe&lt;TableInfo&gt;;</a>
<a name="ln423">  ~TableInfo();</a>
<a name="ln424"> </a>
<a name="ln425">  void AddTabletUnlocked(TabletInfo* tablet);</a>
<a name="ln426">  void AbortTasksAndCloseIfRequested(bool close);</a>
<a name="ln427"> </a>
<a name="ln428">  const TableId table_id_;</a>
<a name="ln429"> </a>
<a name="ln430">  scoped_refptr&lt;TasksTracker&gt; tasks_tracker_;</a>
<a name="ln431"> </a>
<a name="ln432">  // Sorted index of tablet start partition-keys to TabletInfo.</a>
<a name="ln433">  // The TabletInfo objects are owned by the CatalogManager.</a>
<a name="ln434">  typedef std::map&lt;std::string, TabletInfo *&gt; TabletInfoMap;</a>
<a name="ln435">  TabletInfoMap tablet_map_;</a>
<a name="ln436"> </a>
<a name="ln437">  // Protects tablet_map_ and pending_tasks_.</a>
<a name="ln438">  mutable rw_spinlock lock_;</a>
<a name="ln439"> </a>
<a name="ln440">  // If closing, requests to AddTask will be promptly aborted.</a>
<a name="ln441">  bool closing_ = false;</a>
<a name="ln442"> </a>
<a name="ln443">  // In memory state set during backfill to prevent multiple backfill jobs.</a>
<a name="ln444">  bool is_backfilling_ = false;</a>
<a name="ln445"> </a>
<a name="ln446">  // List of pending tasks (e.g. create/alter tablet requests).</a>
<a name="ln447">  std::unordered_set&lt;std::shared_ptr&lt;MonitoredTask&gt;&gt; pending_tasks_;</a>
<a name="ln448"> </a>
<a name="ln449">  // The last error Status of the currently running CreateTable. Will be OK, if freshly constructed</a>
<a name="ln450">  // object, or if the CreateTable was successful.</a>
<a name="ln451">  Status create_table_error_;</a>
<a name="ln452"> </a>
<a name="ln453">  DISALLOW_COPY_AND_ASSIGN(TableInfo);</a>
<a name="ln454">};</a>
<a name="ln455"> </a>
<a name="ln456">class DeletedTableInfo;</a>
<a name="ln457">typedef std::pair&lt;TabletServerId, TabletId&gt; TabletKey;</a>
<a name="ln458">typedef std::unordered_map&lt;</a>
<a name="ln459">    TabletKey, scoped_refptr&lt;DeletedTableInfo&gt;, boost::hash&lt;TabletKey&gt;&gt; DeletedTabletMap;</a>
<a name="ln460"> </a>
<a name="ln461">class DeletedTableInfo : public RefCountedThreadSafe&lt;DeletedTableInfo&gt; {</a>
<a name="ln462"> public:</a>
<a name="ln463">  explicit DeletedTableInfo(const TableInfo* table);</a>
<a name="ln464"> </a>
<a name="ln465">  const TableId&amp; id() const { return table_id_; }</a>
<a name="ln466"> </a>
<a name="ln467">  std::size_t NumTablets() const;</a>
<a name="ln468">  bool HasTablets() const;</a>
<a name="ln469"> </a>
<a name="ln470">  void DeleteTablet(const TabletKey&amp; key);</a>
<a name="ln471"> </a>
<a name="ln472">  void AddTabletsToMap(DeletedTabletMap* tablet_map);</a>
<a name="ln473"> </a>
<a name="ln474"> private:</a>
<a name="ln475">  const TableId table_id_;</a>
<a name="ln476"> </a>
<a name="ln477">  // Protects tablet_set_.</a>
<a name="ln478">  mutable simple_spinlock lock_;</a>
<a name="ln479"> </a>
<a name="ln480">  typedef std::unordered_set&lt;TabletKey, boost::hash&lt;TabletKey&gt;&gt; TabletSet;</a>
<a name="ln481">  TabletSet tablet_set_;</a>
<a name="ln482">};</a>
<a name="ln483"> </a>
<a name="ln484">// The data related to a namespace which is persisted on disk.</a>
<a name="ln485">// This portion of NamespaceInfo is managed via CowObject.</a>
<a name="ln486">// It wraps the underlying protobuf to add useful accessors.</a>
<a name="ln487">struct PersistentNamespaceInfo : public Persistent&lt;SysNamespaceEntryPB, SysRowEntry::NAMESPACE&gt; {</a>
<a name="ln488">  // Get the namespace name.</a>
<a name="ln489">  const NamespaceName&amp; name() const {</a>
<a name="ln490">    return pb.name();</a>
<a name="ln491">  }</a>
<a name="ln492"> </a>
<a name="ln493">  YQLDatabase database_type() const {</a>
<a name="ln494">    return pb.database_type();</a>
<a name="ln495">  }</a>
<a name="ln496"> </a>
<a name="ln497">  bool colocated() const {</a>
<a name="ln498">    return pb.colocated();</a>
<a name="ln499">  }</a>
<a name="ln500">};</a>
<a name="ln501"> </a>
<a name="ln502">// The information about a namespace.</a>
<a name="ln503">//</a>
<a name="ln504">// This object uses copy-on-write techniques similarly to TabletInfo.</a>
<a name="ln505">// Please see the TabletInfo class doc above for more information.</a>
<a name="ln506">class NamespaceInfo : public RefCountedThreadSafe&lt;NamespaceInfo&gt;,</a>
<a name="ln507">                      public MetadataCowWrapper&lt;PersistentNamespaceInfo&gt; {</a>
<a name="ln508"> public:</a>
<a name="ln509">  explicit NamespaceInfo(NamespaceId ns_id);</a>
<a name="ln510"> </a>
<a name="ln511">  virtual const NamespaceId&amp; id() const override { return namespace_id_; }</a>
<a name="ln512"> </a>
<a name="ln513">  const NamespaceName&amp; name() const;</a>
<a name="ln514"> </a>
<a name="ln515">  YQLDatabase database_type() const;</a>
<a name="ln516"> </a>
<a name="ln517">  bool colocated() const;</a>
<a name="ln518"> </a>
<a name="ln519">  ::yb::master::SysNamespaceEntryPB_State state() const;</a>
<a name="ln520"> </a>
<a name="ln521">  std::string ToString() const override;</a>
<a name="ln522"> </a>
<a name="ln523"> private:</a>
<a name="ln524">  friend class RefCountedThreadSafe&lt;NamespaceInfo&gt;;</a>
<a name="ln525">  ~NamespaceInfo() = default;</a>
<a name="ln526"> </a>
<a name="ln527">  // The ID field is used in the sys_catalog table.</a>
<a name="ln528">  const NamespaceId namespace_id_;</a>
<a name="ln529"> </a>
<a name="ln530">  DISALLOW_COPY_AND_ASSIGN(NamespaceInfo);</a>
<a name="ln531">};</a>
<a name="ln532"> </a>
<a name="ln533">// The information about a tablegroup.</a>
<a name="ln534">class TablegroupInfo : public RefCountedThreadSafe&lt;TablegroupInfo&gt;{</a>
<a name="ln535"> public:</a>
<a name="ln536">  explicit TablegroupInfo(TablegroupId tablegroup_id,</a>
<a name="ln537">                          NamespaceId namespace_id);</a>
<a name="ln538"> </a>
<a name="ln539">  const std::string&amp; id() const { return tablegroup_id_; }</a>
<a name="ln540">  const std::string&amp; namespace_id() const { return namespace_id_; }</a>
<a name="ln541"> </a>
<a name="ln542">  // Operations to track table_set_ information (what tables belong to the tablegroup)</a>
<a name="ln543">  void AddChildTable(const TableId&amp; table_id);</a>
<a name="ln544">  void DeleteChildTable(const TableId&amp; table_id);</a>
<a name="ln545">  bool HasChildTables() const;</a>
<a name="ln546">  std::size_t NumChildTables() const;</a>
<a name="ln547"> </a>
<a name="ln548"> private:</a>
<a name="ln549">  friend class RefCountedThreadSafe&lt;TablegroupInfo&gt;;</a>
<a name="ln550">  ~TablegroupInfo() = default;</a>
<a name="ln551"> </a>
<a name="ln552">  // The tablegroup ID is used in the catalog manager maps to look up the proper</a>
<a name="ln553">  // tablet to add user tables to.</a>
<a name="ln554">  const TablegroupId tablegroup_id_;</a>
<a name="ln555">  const NamespaceId namespace_id_;</a>
<a name="ln556"> </a>
<a name="ln557">  // Protects table_set_.</a>
<a name="ln558">  mutable simple_spinlock lock_;</a>
<a name="ln559">  std::unordered_set&lt;TableId&gt; table_set_;</a>
<a name="ln560"> </a>
<a name="ln561">  DISALLOW_COPY_AND_ASSIGN(TablegroupInfo);</a>
<a name="ln562">};</a>
<a name="ln563"> </a>
<a name="ln564">// The data related to a User-Defined Type which is persisted on disk.</a>
<a name="ln565">// This portion of UDTypeInfo is managed via CowObject.</a>
<a name="ln566">// It wraps the underlying protobuf to add useful accessors.</a>
<a name="ln567">struct PersistentUDTypeInfo : public Persistent&lt;SysUDTypeEntryPB, SysRowEntry::UDTYPE&gt; {</a>
<a name="ln568">  // Return the type's name.</a>
<a name="ln569">  const UDTypeName&amp; name() const {</a>
<a name="ln570">    return pb.name();</a>
<a name="ln571">  }</a>
<a name="ln572"> </a>
<a name="ln573">  // Return the table's namespace id.</a>
<a name="ln574">  const NamespaceId&amp; namespace_id() const {</a>
<a name="ln575">    return pb.namespace_id();</a>
<a name="ln576">  }</a>
<a name="ln577"> </a>
<a name="ln578">  int field_names_size() const {</a>
<a name="ln579">    return pb.field_names_size();</a>
<a name="ln580">  }</a>
<a name="ln581"> </a>
<a name="ln582">  const string&amp; field_names(int index) const {</a>
<a name="ln583">    return pb.field_names(index);</a>
<a name="ln584">  }</a>
<a name="ln585"> </a>
<a name="ln586">  int field_types_size() const {</a>
<a name="ln587">    return pb.field_types_size();</a>
<a name="ln588">  }</a>
<a name="ln589"> </a>
<a name="ln590">  const QLTypePB&amp; field_types(int index) const {</a>
<a name="ln591">    return pb.field_types(index);</a>
<a name="ln592">  }</a>
<a name="ln593">};</a>
<a name="ln594"> </a>
<a name="ln595">class UDTypeInfo : public RefCountedThreadSafe&lt;UDTypeInfo&gt;,</a>
<a name="ln596">                   public MetadataCowWrapper&lt;PersistentUDTypeInfo&gt; {</a>
<a name="ln597"> public:</a>
<a name="ln598">  explicit UDTypeInfo(UDTypeId udtype_id);</a>
<a name="ln599"> </a>
<a name="ln600">  // Return the user defined type's ID. Does not require synchronization.</a>
<a name="ln601">  virtual const std::string&amp; id() const override { return udtype_id_; }</a>
<a name="ln602"> </a>
<a name="ln603">  const UDTypeName&amp; name() const;</a>
<a name="ln604"> </a>
<a name="ln605">  const NamespaceId&amp; namespace_id() const;</a>
<a name="ln606"> </a>
<a name="ln607">  int field_names_size() const;</a>
<a name="ln608"> </a>
<a name="ln609">  const string&amp; field_names(int index) const;</a>
<a name="ln610"> </a>
<a name="ln611">  int field_types_size() const;</a>
<a name="ln612"> </a>
<a name="ln613">  const QLTypePB&amp; field_types(int index) const;</a>
<a name="ln614"> </a>
<a name="ln615">  std::string ToString() const override;</a>
<a name="ln616"> </a>
<a name="ln617"> private:</a>
<a name="ln618">  friend class RefCountedThreadSafe&lt;UDTypeInfo&gt;;</a>
<a name="ln619">  ~UDTypeInfo() = default;</a>
<a name="ln620"> </a>
<a name="ln621">  // The ID field is used in the sys_catalog table.</a>
<a name="ln622">  const UDTypeId udtype_id_;</a>
<a name="ln623"> </a>
<a name="ln624">  DISALLOW_COPY_AND_ASSIGN(UDTypeInfo);</a>
<a name="ln625">};</a>
<a name="ln626"> </a>
<a name="ln627">// This wraps around the proto containing cluster level config information. It will be used for</a>
<a name="ln628">// CowObject managed access.</a>
<a name="ln629">struct PersistentClusterConfigInfo : public Persistent&lt;SysClusterConfigEntryPB,</a>
<a name="ln630">                                                       SysRowEntry::CLUSTER_CONFIG&gt; {</a>
<a name="ln631">};</a>
<a name="ln632"> </a>
<a name="ln633">// This is the in memory representation of the cluster config information serialized proto data,</a>
<a name="ln634">// using metadata() for CowObject access.</a>
<a name="ln635">class ClusterConfigInfo : public RefCountedThreadSafe&lt;ClusterConfigInfo&gt;,</a>
<a name="ln636">                          public MetadataCowWrapper&lt;PersistentClusterConfigInfo&gt; {</a>
<a name="ln637"> public:</a>
<a name="ln638">  ClusterConfigInfo() {}</a>
<a name="ln639"> </a>
<a name="ln640">  virtual const std::string&amp; id() const override { return fake_id_; }</a>
<a name="ln641"> </a>
<a name="ln642"> private:</a>
<a name="ln643">  friend class RefCountedThreadSafe&lt;ClusterConfigInfo&gt;;</a>
<a name="ln644">  ~ClusterConfigInfo() = default;</a>
<a name="ln645"> </a>
<a name="ln646">  // We do not use the ID field in the sys_catalog table.</a>
<a name="ln647">  const std::string fake_id_;</a>
<a name="ln648"> </a>
<a name="ln649">  DISALLOW_COPY_AND_ASSIGN(ClusterConfigInfo);</a>
<a name="ln650">};</a>
<a name="ln651"> </a>
<a name="ln652">struct PersistentRedisConfigInfo</a>
<a name="ln653">    : public Persistent&lt;SysRedisConfigEntryPB, SysRowEntry::REDIS_CONFIG&gt; {};</a>
<a name="ln654"> </a>
<a name="ln655">class RedisConfigInfo : public RefCountedThreadSafe&lt;RedisConfigInfo&gt;,</a>
<a name="ln656">                        public MetadataCowWrapper&lt;PersistentRedisConfigInfo&gt; {</a>
<a name="ln657"> public:</a>
<a name="ln658">  explicit RedisConfigInfo(const std::string key) : config_key_(key) {}</a>
<a name="ln659"> </a>
<a name="ln660">  virtual const std::string&amp; id() const override { return config_key_; }</a>
<a name="ln661"> </a>
<a name="ln662"> private:</a>
<a name="ln663">  friend class RefCountedThreadSafe&lt;RedisConfigInfo&gt;;</a>
<a name="ln664">  ~RedisConfigInfo() = default;</a>
<a name="ln665"> </a>
<a name="ln666">  const std::string config_key_;</a>
<a name="ln667"> </a>
<a name="ln668">  DISALLOW_COPY_AND_ASSIGN(RedisConfigInfo);</a>
<a name="ln669">};</a>
<a name="ln670"> </a>
<a name="ln671">struct PersistentRoleInfo : public Persistent&lt;SysRoleEntryPB, SysRowEntry::ROLE&gt; {};</a>
<a name="ln672"> </a>
<a name="ln673">class RoleInfo : public RefCountedThreadSafe&lt;RoleInfo&gt;,</a>
<a name="ln674">                 public MetadataCowWrapper&lt;PersistentRoleInfo&gt; {</a>
<a name="ln675"> public:</a>
<a name="ln676">  explicit RoleInfo(const std::string&amp; role) : role_(role) {}</a>
<a name="ln677">  const std::string&amp; id() const override { return role_; }</a>
<a name="ln678"> </a>
<a name="ln679"> private:</a>
<a name="ln680">  friend class RefCountedThreadSafe&lt;RoleInfo&gt;;</a>
<a name="ln681">  ~RoleInfo() = default;</a>
<a name="ln682"> </a>
<a name="ln683">  const std::string role_;</a>
<a name="ln684"> </a>
<a name="ln685">  DISALLOW_COPY_AND_ASSIGN(RoleInfo);</a>
<a name="ln686">};</a>
<a name="ln687"> </a>
<a name="ln688">struct PersistentSysConfigInfo</a>
<a name="ln689">    : public Persistent&lt;SysConfigEntryPB, SysRowEntry::SYS_CONFIG&gt; {};</a>
<a name="ln690"> </a>
<a name="ln691">class SysConfigInfo : public RefCountedThreadSafe&lt;SysConfigInfo&gt;,</a>
<a name="ln692">                      public MetadataCowWrapper&lt;PersistentSysConfigInfo&gt; {</a>
<a name="ln693"> public:</a>
<a name="ln694">  explicit SysConfigInfo(const std::string&amp; config_type) : config_type_(config_type) {}</a>
<a name="ln695">  const std::string&amp; id() const override { return config_type_; /* config type is the entry id */ }</a>
<a name="ln696"> </a>
<a name="ln697"> private:</a>
<a name="ln698">  friend class RefCountedThreadSafe&lt;SysConfigInfo&gt;;</a>
<a name="ln699">  ~SysConfigInfo() = default;</a>
<a name="ln700"> </a>
<a name="ln701">  const std::string config_type_;</a>
<a name="ln702"> </a>
<a name="ln703">  DISALLOW_COPY_AND_ASSIGN(SysConfigInfo);</a>
<a name="ln704">};</a>
<a name="ln705"> </a>
<a name="ln706">// Convenience typedefs.</a>
<a name="ln707">// Table(t)InfoMap ordered for deterministic locking.</a>
<a name="ln708">typedef std::map&lt;TabletId, scoped_refptr&lt;TabletInfo&gt;&gt; TabletInfoMap;</a>
<a name="ln709">typedef std::map&lt;TableId, scoped_refptr&lt;TableInfo&gt;&gt; TableInfoMap;</a>
<a name="ln710">typedef std::pair&lt;NamespaceId, TableName&gt; TableNameKey;</a>
<a name="ln711">typedef std::unordered_map&lt;</a>
<a name="ln712">    TableNameKey, scoped_refptr&lt;TableInfo&gt;, boost::hash&lt;TableNameKey&gt;&gt; TableInfoByNameMap;</a>
<a name="ln713"> </a>
<a name="ln714">typedef std::unordered_map&lt;UDTypeId, scoped_refptr&lt;UDTypeInfo&gt;&gt; UDTypeInfoMap;</a>
<a name="ln715">typedef std::pair&lt;NamespaceId, UDTypeName&gt; UDTypeNameKey;</a>
<a name="ln716">typedef std::unordered_map&lt;</a>
<a name="ln717">    UDTypeNameKey, scoped_refptr&lt;UDTypeInfo&gt;, boost::hash&lt;UDTypeNameKey&gt;&gt; UDTypeInfoByNameMap;</a>
<a name="ln718"> </a>
<a name="ln719">template &lt;class Info&gt;</a>
<a name="ln720">void FillInfoEntry(const Info&amp; info, SysRowEntry* entry) {</a>
<a name="ln721">  entry-&gt;set_id(info.id());</a>
<a name="ln722">  entry-&gt;set_type(info.metadata().state().type());</a>
<a name="ln723">  entry-&gt;set_data(info.metadata().state().pb.SerializeAsString());</a>
<a name="ln724">}</a>
<a name="ln725"> </a>
<a name="ln726">}  // namespace master</a>
<a name="ln727">}  // namespace yb</a>
<a name="ln728"> </a>
<a name="ln729">#endif  // YB_MASTER_CATALOG_ENTITY_INFO_H</a>

</code></pre>
<div class="balloon" rel="62"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: ts_desc, state, role, member_type.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
