
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>net_util.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Licensed to the Apache Software Foundation (ASF) under one</a>
<a name="ln2">// or more contributor license agreements.  See the NOTICE file</a>
<a name="ln3">// distributed with this work for additional information</a>
<a name="ln4">// regarding copyright ownership.  The ASF licenses this file</a>
<a name="ln5">// to you under the Apache License, Version 2.0 (the</a>
<a name="ln6">// &quot;License&quot;); you may not use this file except in compliance</a>
<a name="ln7">// with the License.  You may obtain a copy of the License at</a>
<a name="ln8">//</a>
<a name="ln9">//   http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln10">//</a>
<a name="ln11">// Unless required by applicable law or agreed to in writing,</a>
<a name="ln12">// software distributed under the License is distributed on an</a>
<a name="ln13">// &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</a>
<a name="ln14">// KIND, either express or implied.  See the License for the</a>
<a name="ln15">// specific language governing permissions and limitations</a>
<a name="ln16">// under the License.</a>
<a name="ln17">//</a>
<a name="ln18">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln19">//</a>
<a name="ln20">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln21">//</a>
<a name="ln22">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln23">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln24">//</a>
<a name="ln25">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln26">//</a>
<a name="ln27">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln28">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln29">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln30">// under the License.</a>
<a name="ln31">//</a>
<a name="ln32"> </a>
<a name="ln33">#include &quot;yb/util/net/net_util.h&quot;</a>
<a name="ln34"> </a>
<a name="ln35">#include &lt;arpa/inet.h&gt;</a>
<a name="ln36">#include &lt;ifaddrs.h&gt;</a>
<a name="ln37">#include &lt;netdb.h&gt;</a>
<a name="ln38">#include &lt;sys/types.h&gt;</a>
<a name="ln39">#include &lt;sys/socket.h&gt;</a>
<a name="ln40"> </a>
<a name="ln41">#include &lt;algorithm&gt;</a>
<a name="ln42">#include &lt;iostream&gt;</a>
<a name="ln43">#include &lt;unordered_set&gt;</a>
<a name="ln44">#include &lt;utility&gt;</a>
<a name="ln45">#include &lt;vector&gt;</a>
<a name="ln46"> </a>
<a name="ln47">#include &lt;boost/algorithm/string.hpp&gt;</a>
<a name="ln48">#include &lt;boost/optional/optional.hpp&gt;</a>
<a name="ln49"> </a>
<a name="ln50">#include &quot;yb/gutil/gscoped_ptr.h&quot;</a>
<a name="ln51">#include &quot;yb/gutil/map-util.h&quot;</a>
<a name="ln52">#include &quot;yb/gutil/strings/join.h&quot;</a>
<a name="ln53">#include &quot;yb/gutil/strings/numbers.h&quot;</a>
<a name="ln54">#include &quot;yb/gutil/strings/split.h&quot;</a>
<a name="ln55">#include &quot;yb/gutil/strings/strip.h&quot;</a>
<a name="ln56">#include &quot;yb/gutil/strings/substitute.h&quot;</a>
<a name="ln57">#include &quot;yb/gutil/strings/util.h&quot;</a>
<a name="ln58"> </a>
<a name="ln59">#include &quot;yb/util/debug/trace_event.h&quot;</a>
<a name="ln60">#include &quot;yb/util/errno.h&quot;</a>
<a name="ln61">#include &quot;yb/util/faststring.h&quot;</a>
<a name="ln62">#include &quot;yb/util/env.h&quot;</a>
<a name="ln63">#include &quot;yb/util/env_util.h&quot;</a>
<a name="ln64">#include &quot;yb/util/memory/memory.h&quot;</a>
<a name="ln65">#include &quot;yb/util/net/inetaddress.h&quot;</a>
<a name="ln66">#include &quot;yb/util/net/sockaddr.h&quot;</a>
<a name="ln67">#include &quot;yb/util/net/socket.h&quot;</a>
<a name="ln68">#include &quot;yb/util/random.h&quot;</a>
<a name="ln69">#include &quot;yb/util/scope_exit.h&quot;</a>
<a name="ln70">#include &quot;yb/util/stopwatch.h&quot;</a>
<a name="ln71">#include &quot;yb/util/subprocess.h&quot;</a>
<a name="ln72"> </a>
<a name="ln73">// Mac OS 10.9 does not appear to define HOST_NAME_MAX in unistd.h</a>
<a name="ln74">#ifndef HOST_NAME_MAX</a>
<a name="ln75">#define HOST_NAME_MAX 64</a>
<a name="ln76">#endif</a>
<a name="ln77"> </a>
<a name="ln78">using std::unordered_set;</a>
<a name="ln79">using std::vector;</a>
<a name="ln80">using strings::Substitute;</a>
<a name="ln81"> </a>
<a name="ln82">DEFINE_string(</a>
<a name="ln83">    net_address_filter,</a>
<a name="ln84">    &quot;ipv4_external,ipv4_all&quot;,</a>
<a name="ln85">    &quot;Order in which to select ip addresses returned by the resolver&quot;</a>
<a name="ln86">    &quot;Can be set to something like \&quot;ipv4_all,ipv6_all\&quot; to prefer IPv4 over &quot;</a>
<a name="ln87">    &quot;IPv6 addresses.&quot;</a>
<a name="ln88">    &quot;Can be set to something like \&quot;ipv4_external,ipv4_all,ipv6_all\&quot; to &quot;</a>
<a name="ln89">    &quot;prefer external IPv4 &quot;</a>
<a name="ln90">    &quot;addresses first. Other options include ipv6_external,ipv6_non_link_local&quot;);</a>
<a name="ln91"> </a>
<a name="ln92">namespace yb {</a>
<a name="ln93"> </a>
<a name="ln94">namespace {</a>
<a name="ln95">struct AddrinfoDeleter {</a>
<a name="ln96">  void operator()(struct addrinfo* info) {</a>
<a name="ln97">    freeaddrinfo(info);</a>
<a name="ln98">  }</a>
<a name="ln99">};</a>
<a name="ln100">}</a>
<a name="ln101"> </a>
<a name="ln102">HostPort::HostPort()</a>
<a name="ln103">    : port_(0) {</a>
<a name="ln104">}</a>
<a name="ln105"> </a>
<a name="ln106">HostPort::HostPort(std::string host, uint16_t port)</a>
<a name="ln107">    : host_(std::move(host)), port_(port) {}</a>
<a name="ln108"> </a>
<a name="ln109">HostPort::HostPort(const Endpoint&amp; endpoint)</a>
<a name="ln110">    : host_(endpoint.address().to_string()), port_(endpoint.port()) {</a>
<a name="ln111">}</a>
<a name="ln112"> </a>
<a name="ln113">Status HostPort::RemoveAndGetHostPortList(</a>
<a name="ln114">    const Endpoint&amp; remove,</a>
<a name="ln115">    const std::vector&lt;std::string&gt;&amp; multiple_server_addresses,</a>
<a name="ln116">    uint16_t default_port,</a>
<a name="ln117">    std::vector&lt;HostPort&gt; *res) {</a>
<a name="ln118">  bool found = false;</a>
<a name="ln119">  // Note that this outer loop is over a vector of comma-separated strings.</a>
<a name="ln120">  for (const string&amp; master_server_addr : multiple_server_addresses) {</a>
<a name="ln121">    std::vector&lt;std::string&gt; addr_strings =</a>
<a name="ln122">        strings::Split(master_server_addr, &quot;,&quot;, strings::SkipEmpty());</a>
<a name="ln123">    for (const auto&amp; single_addr : addr_strings) {</a>
<a name="ln124">      HostPort host_port;</a>
<a name="ln125">      RETURN_NOT_OK(host_port.ParseString(single_addr, default_port));</a>
<a name="ln126">      if (host_port.equals(remove)) {</a>
<a name="ln127">        found = true;</a>
<a name="ln128">        continue;</a>
<a name="ln129">      } else {</a>
<a name="ln130">        res-&gt;push_back(host_port);</a>
<a name="ln131">      }</a>
<a name="ln132">    }</a>
<a name="ln133">  }</a>
<a name="ln134"> </a>
<a name="ln135">  if (!found) {</a>
<a name="ln136">    std::ostringstream out;</a>
<a name="ln137">    out.str(&quot;Current list of master addresses: &quot;);</a>
<a name="ln138">    for (const string&amp; master_server_addr : multiple_server_addresses) {</a>
<a name="ln139">      out.str(master_server_addr);</a>
<a name="ln140">      out.str(&quot; &quot;);</a>
<a name="ln141">    }</a>
<a name="ln142">    LOG(ERROR) &lt;&lt; out.str();</a>
<a name="ln143"> </a>
<a name="ln144">    return STATUS_SUBSTITUTE(NotFound,</a>
<a name="ln145">                             &quot;Cannot find $0 in addresses: $1&quot;,</a>
<a name="ln146">                             yb::ToString(remove),</a>
<a name="ln147">                             out.str());</a>
<a name="ln148">  }</a>
<a name="ln149"> </a>
<a name="ln150">  return Status::OK();</a>
<a name="ln151">}</a>
<a name="ln152"> </a>
<a name="ln153">// Accepts entries like: [::1], 127.0.0.1, [::1]:7100, 0.0.0.0:7100,</a>
<a name="ln154">// f.q.d.n:7100</a>
<a name="ln155">Status HostPort::ParseString(const string &amp;str_in, uint16_t default_port) {</a>
<a name="ln156">  uint32_t port;</a>
<a name="ln157">  string host;</a>
<a name="ln158"> </a>
<a name="ln159">  string str(str_in);</a>
<a name="ln160">  StripWhiteSpace(&amp;str);</a>
<a name="ln161">  size_t pos = str.rfind(':');</a>
<a name="ln162">  if (str[0] == '[' &amp;&amp; str[str.length() - 1] == ']' &amp;&amp; str.length() &gt; 2) {</a>
<a name="ln163">    // The whole thing is an IPv6 address.</a>
<a name="ln164">    host = str.substr(1, str.length() - 2);</a>
<a name="ln165">    port = default_port;</a>
<a name="ln166">  } else if (pos == string::npos) {</a>
<a name="ln167">    // No port was specified, the whole thing must be a host.</a>
<a name="ln168">    host = str;</a>
<a name="ln169">    port = default_port;</a>
<a name="ln170">  } else if (pos &gt; 1 &amp;&amp; pos + 1 &lt; str.length() &amp;&amp;</a>
<a name="ln171">             SimpleAtoi(str.substr(pos + 1), &amp;port)) {</a>
<a name="ln172"> </a>
<a name="ln173">    if (port &gt; numeric_limits&lt;uint16_t&gt;::max()) {</a>
<a name="ln174">      return STATUS(InvalidArgument, &quot;Invalid port&quot;, str);</a>
<a name="ln175">    }</a>
<a name="ln176"> </a>
<a name="ln177">    // Got a host:port</a>
<a name="ln178">    host = str.substr(0, pos);</a>
<a name="ln179">    if (host[0] == '[' &amp;&amp; host[host.length() - 1] == ']' &amp;&amp; host.length() &gt; 2) {</a>
<a name="ln180">      // Remove brackets if we have an IPv6 address</a>
<a name="ln181">      host = host.substr(1, host.length() - 2);</a>
<a name="ln182">    }</a>
<a name="ln183">  } else {</a>
<a name="ln184">    return STATUS(InvalidArgument,</a>
<a name="ln185">                  Format(</a>
<a name="ln186">                      &quot;Invalid port: expected port after ':' &quot;</a>
<a name="ln187">                      &quot;at position $0 in $1&quot;,</a>
<a name="ln188">                      pos, str));</a>
<a name="ln189">  }</a>
<a name="ln190"> </a>
<a name="ln191">  host_ = host;</a>
<a name="ln192">  port_ = port;</a>
<a name="ln193">  return Status::OK();</a>
<a name="ln194">}</a>
<a name="ln195"> </a>
<a name="ln196">namespace {</a>
<a name="ln197">const string getaddrinfo_rc_to_string(int rc) {</a>
<a name="ln198">  const char* s = nullptr;</a>
<a name="ln199">  switch (rc) {</a>
<a name="ln200">    case EAI_ADDRFAMILY: s = &quot;EAI_ADDRFAMILY&quot;; break;</a>
<a name="ln201">    case EAI_AGAIN: s = &quot;EAI_AGAIN&quot;; break;</a>
<a name="ln202">    case EAI_BADFLAGS: s = &quot;EAI_BADFLAGS&quot;; break;</a>
<a name="ln203">    case EAI_FAIL: s = &quot;EAI_FAIL&quot;; break;</a>
<a name="ln204">    case EAI_FAMILY: s = &quot;EAI_FAMILY&quot;; break;</a>
<a name="ln205">    case EAI_MEMORY: s = &quot;EAI_MEMORY&quot;; break;</a>
<a name="ln206">    case EAI_NODATA: s = &quot;EAI_NODATA&quot;; break;</a>
<a name="ln207">    case EAI_NONAME: s = &quot;EAI_NONAME&quot;; break;</a>
<a name="ln208">    case EAI_SERVICE: s = &quot;EAI_SERVICE&quot;; break;</a>
<a name="ln209">    case EAI_SOCKTYPE: s = &quot;EAI_SOCKTYPE&quot;; break;</a>
<a name="ln210">    case EAI_SYSTEM: s = &quot;EAI_SYSTEM&quot;; break;</a>
<a name="ln211">    default: s = &quot;UNKNOWN&quot;;</a>
<a name="ln212">  }</a>
<a name="ln213">  return Substitute(&quot;$0 ($1)&quot;, rc, s);</a>
<a name="ln214">}</a>
<a name="ln215"> </a>
<a name="ln216">Result&lt;std::unique_ptr&lt;addrinfo, AddrinfoDeleter&gt;&gt; HostToInetAddrInfo(const std::string&amp; host) {</a>
<a name="ln217">  struct addrinfo hints;</a>
<a name="ln218">  memset(&amp;hints, 0, sizeof(hints));</a>
<a name="ln219">  hints.ai_family = AF_UNSPEC;</a>
<a name="ln220">  hints.ai_socktype = SOCK_STREAM;</a>
<a name="ln221">  struct addrinfo* res = nullptr;</a>
<a name="ln222">  int rc = 0;</a>
<a name="ln223">  LOG_SLOW_EXECUTION(WARNING, 200,</a>
<a name="ln224">                     Substitute(&quot;resolving address for $0&quot;, host)) {</a>
<a name="ln225">    rc = getaddrinfo(host.c_str(), nullptr, &amp;hints, &amp;res);</a>
<a name="ln226">  }</a>
<a name="ln227">  if (rc != 0) {</a>
<a name="ln228">    return STATUS_FORMAT(NetworkError, &quot;Unable to resolve address $0, getaddrinfo returned $1: $2&quot;,</a>
<a name="ln229">                         host.c_str(), getaddrinfo_rc_to_string(rc).c_str(), gai_strerror(rc));</a>
<a name="ln230">  } else {</a>
<a name="ln231">    return std::unique_ptr&lt;addrinfo, AddrinfoDeleter&gt;(res);</a>
<a name="ln232">  }</a>
<a name="ln233">}</a>
<a name="ln234"> </a>
<a name="ln235">template &lt;typename F&gt;</a>
<a name="ln236">CHECKED_STATUS ResolveInetAddresses(const std::string&amp; host, F func) {</a>
<a name="ln237">  boost::optional&lt;IpAddress&gt; fast_resolve = TryFastResolve(host);</a>
<a name="ln238">  if (fast_resolve) {</a>
<a name="ln239">    func(*fast_resolve);</a>
<a name="ln240">    VLOG(4) &lt;&lt; &quot;Fast resolved &quot; &lt;&lt; host &lt;&lt; &quot; to &quot; &lt;&lt; fast_resolve-&gt;to_string();</a>
<a name="ln241">    return Status::OK();</a>
<a name="ln242">  }</a>
<a name="ln243"> </a>
<a name="ln244">  auto addrinfo_holder = VERIFY_RESULT(HostToInetAddrInfo(host));</a>
<a name="ln245">  struct addrinfo* addrinfo = addrinfo_holder.get();</a>
<a name="ln246">  for (; addrinfo != nullptr; addrinfo = addrinfo-&gt;ai_next) {</a>
<a name="ln247">    if (addrinfo-&gt;ai_family == AF_INET) {</a>
<a name="ln248">      auto* addr = reinterpret_cast&lt;struct sockaddr_in*&gt;(addrinfo-&gt;ai_addr);</a>
<a name="ln249">      Endpoint endpoint;</a>
<a name="ln250">      memcpy(endpoint.data(), addr, sizeof(*addr));</a>
<a name="ln251">      func(endpoint.address());</a>
<a name="ln252">    } else if (addrinfo-&gt;ai_family == AF_INET6) {</a>
<a name="ln253">      auto* addr = reinterpret_cast&lt;struct sockaddr_in6*&gt;(addrinfo-&gt;ai_addr);</a>
<a name="ln254">      Endpoint endpoint;</a>
<a name="ln255">      memcpy(endpoint.data(), addr, sizeof(*addr));</a>
<a name="ln256">      func(endpoint.address());</a>
<a name="ln257">    } else {</a>
<a name="ln258">      return STATUS_FORMAT(NetworkError, &quot;Unexpected address family: $0&quot;, addrinfo-&gt;ai_family);</a>
<a name="ln259">    }</a>
<a name="ln260">  }</a>
<a name="ln261">  return Status::OK();</a>
<a name="ln262">}</a>
<a name="ln263"> </a>
<a name="ln264">}  // namespace</a>
<a name="ln265"> </a>
<a name="ln266">Status HostPort::ResolveAddresses(std::vector&lt;Endpoint&gt;* addresses) const {</a>
<a name="ln267">  TRACE_EVENT1(&quot;net&quot;, &quot;HostPort::ResolveAddresses&quot;,</a>
<a name="ln268">               &quot;host&quot;, host_);</a>
<a name="ln269">  if (!addresses) {</a>
<a name="ln270">    return Status::OK();</a>
<a name="ln271">  }</a>
<a name="ln272">  vector&lt;IpAddress&gt; ip_addresses;</a>
<a name="ln273">  RETURN_NOT_OK(ResolveInetAddresses(</a>
<a name="ln274">      host_, [this, &amp;ip_addresses](const IpAddress &amp;ip_address) {</a>
<a name="ln275">        ip_addresses.push_back(ip_address);</a>
<a name="ln276">        VLOG(3) &lt;&lt; &quot;Resolved address &quot; &lt;&lt; ip_address.to_string() &lt;&lt; &quot; for host &quot;</a>
<a name="ln277">                &lt;&lt; host_;</a>
<a name="ln278">      }));</a>
<a name="ln279"> </a>
<a name="ln280">  FilterAddresses(FLAGS_net_address_filter, &amp;ip_addresses);</a>
<a name="ln281"> </a>
<a name="ln282">  VLOG(2) &lt;&lt; &quot;Returned &quot; &lt;&lt; ip_addresses.size() &lt;&lt; &quot; addresses for host &quot;</a>
<a name="ln283">          &lt;&lt; host_;</a>
<a name="ln284">  for (const auto &amp;ip_addr : ip_addresses) {</a>
<a name="ln285">    VLOG(2) &lt;&lt; &quot;Returned address &quot; &lt;&lt; ip_addr.to_string() &lt;&lt; &quot; for host &quot;</a>
<a name="ln286">            &lt;&lt; host_;</a>
<a name="ln287">    addresses-&gt;push_back(Endpoint(ip_addr, port_));</a>
<a name="ln288">  }</a>
<a name="ln289">  return Status::OK();</a>
<a name="ln290">}</a>
<a name="ln291"> </a>
<a name="ln292">Status HostPort::ParseStrings(const string&amp; comma_sep_addrs,</a>
<a name="ln293">                              uint16_t default_port,</a>
<a name="ln294">                              std::vector&lt;HostPort&gt;* res,</a>
<a name="ln295">                              const char* separator) {</a>
<a name="ln296">  std::vector&lt;string&gt; addr_strings = strings::Split(</a>
<a name="ln297">      comma_sep_addrs, separator, strings::SkipEmpty());</a>
<a name="ln298">  std::vector&lt;HostPort&gt; host_ports;</a>
<a name="ln299">  for (string&amp; addr_string : addr_strings) {</a>
<a name="ln300">    StripWhiteSpace(&amp;addr_string);</a>
<a name="ln301">    HostPort host_port;</a>
<a name="ln302">    RETURN_NOT_OK(host_port.ParseString(addr_string, default_port));</a>
<a name="ln303">    host_ports.push_back(host_port);</a>
<a name="ln304">  }</a>
<a name="ln305">  *res = host_ports;</a>
<a name="ln306">  return Status::OK();</a>
<a name="ln307">}</a>
<a name="ln308"> </a>
<a name="ln309">string HostPort::ToString() const { return HostPortToString(host_, port_); }</a>
<a name="ln310"> </a>
<a name="ln311">string HostPort::ToCommaSeparatedString(const std::vector&lt;HostPort&gt;&amp; hostports) {</a>
<a name="ln312">  vector&lt;string&gt; hostport_strs;</a>
<a name="ln313">  for (const HostPort&amp; hostport : hostports) {</a>
<a name="ln314">    hostport_strs.push_back(hostport.ToString());</a>
<a name="ln315">  }</a>
<a name="ln316">  return JoinStrings(hostport_strs, &quot;,&quot;);</a>
<a name="ln317">}</a>
<a name="ln318"> </a>
<a name="ln319">bool IsPrivilegedPort(uint16_t port) { return port &lt; 1024 &amp;&amp; port != 0; }</a>
<a name="ln320"> </a>
<a name="ln321">Status ParseAddressList(const std::string&amp; addr_list,</a>
<a name="ln322">                        uint16_t default_port,</a>
<a name="ln323">                        std::vector&lt;Endpoint&gt;* addresses) {</a>
<a name="ln324">  std::vector&lt;HostPort&gt; host_ports;</a>
<a name="ln325">  RETURN_NOT_OK(HostPort::ParseStrings(addr_list, default_port, &amp;host_ports));</a>
<a name="ln326">  std::unordered_set&lt;Endpoint, EndpointHash&gt; uniqued;</a>
<a name="ln327"> </a>
<a name="ln328">  for (const HostPort&amp; host_port : host_ports) {</a>
<a name="ln329">    std::vector&lt;Endpoint&gt; this_addresses;</a>
<a name="ln330">    RETURN_NOT_OK(host_port.ResolveAddresses(&amp;this_addresses));</a>
<a name="ln331"> </a>
<a name="ln332">    // Only add the unique ones -- the user may have specified</a>
<a name="ln333">    // some IP addresses in multiple ways</a>
<a name="ln334">    for (const auto&amp; addr : this_addresses) {</a>
<a name="ln335">      if (InsertIfNotPresent(&amp;uniqued, addr)) {</a>
<a name="ln336">        addresses-&gt;push_back(addr);</a>
<a name="ln337">      } else {</a>
<a name="ln338">        LOG(INFO) &lt;&lt; &quot;Address &quot; &lt;&lt; addr &lt;&lt; &quot; for &quot; &lt;&lt; host_port.ToString()</a>
<a name="ln339">                  &lt;&lt; &quot; duplicates an earlier resolved entry.&quot;;</a>
<a name="ln340">      }</a>
<a name="ln341">    }</a>
<a name="ln342">  }</a>
<a name="ln343">  return Status::OK();</a>
<a name="ln344">}</a>
<a name="ln345"> </a>
<a name="ln346">Status GetHostname(string* hostname) {</a>
<a name="ln347">  TRACE_EVENT0(&quot;net&quot;, &quot;GetHostname&quot;);</a>
<a name="ln348">  char name[HOST_NAME_MAX];</a>
<a name="ln349">  int ret = gethostname(name, HOST_NAME_MAX);</a>
<a name="ln350">  if (ret != 0) {</a>
<a name="ln351">    return STATUS(NetworkError, &quot;Unable to determine local hostname&quot;, Errno(errno));</a>
<a name="ln352">  }</a>
<a name="ln353">  *hostname = name;</a>
<a name="ln354">  return Status::OK();</a>
<a name="ln355">}</a>
<a name="ln356"> </a>
<a name="ln357">Result&lt;string&gt; GetHostname() {</a>
<a name="ln358">  std::string result;</a>
<a name="ln359">  RETURN_NOT_OK(GetHostname(&amp;result));</a>
<a name="ln360">  return result;</a>
<a name="ln361">}</a>
<a name="ln362"> </a>
<a name="ln363">Status GetLocalAddresses(const string &amp;filter_spec,</a>
<a name="ln364">                         std::vector&lt;IpAddress&gt; *result) {</a>
<a name="ln365">  RETURN_NOT_OK(GetLocalAddresses(result, AddressFilter::ANY));</a>
<a name="ln366">  FilterAddresses(filter_spec, result);</a>
<a name="ln367">  return Status::OK();</a>
<a name="ln368">}</a>
<a name="ln369"> </a>
<a name="ln370">Status GetLocalAddresses(std::vector&lt;IpAddress&gt;* result, AddressFilter filter) {</a>
<a name="ln371">  ifaddrs* addresses;</a>
<a name="ln372">  if (getifaddrs(&amp;addresses)) {</a>
<a name="ln373">    return STATUS(NetworkError, &quot;Failed to list network interfaces&quot;, Errno(errno));</a>
<a name="ln374">  }</a>
<a name="ln375"> </a>
<a name="ln376">  auto se = ScopeExit([addresses] {</a>
<a name="ln377">    freeifaddrs(addresses);</a>
<a name="ln378">  });</a>
<a name="ln379"> </a>
<a name="ln380">  for (auto address = addresses; address; address = address-&gt;ifa_next) {</a>
<a name="ln381">    if (address-&gt;ifa_addr != nullptr) {</a>
<a name="ln382">      Endpoint temp;</a>
<a name="ln383">      auto family = address-&gt;ifa_addr-&gt;sa_family;</a>
<a name="ln384">      size_t size;</a>
<a name="ln385">      if (family == AF_INET) {</a>
<a name="ln386">        size = sizeof(sockaddr_in);</a>
<a name="ln387">      } else if (family == AF_INET6) {</a>
<a name="ln388">        size = sizeof(sockaddr_in6);</a>
<a name="ln389">      } else {</a>
<a name="ln390">        continue;</a>
<a name="ln391">      }</a>
<a name="ln392">      memcpy(temp.data(), address-&gt;ifa_addr, size);</a>
<a name="ln393">      switch (filter) {</a>
<a name="ln394">        case AddressFilter::ANY:</a>
<a name="ln395">          result-&gt;push_back(temp.address());</a>
<a name="ln396">          break;</a>
<a name="ln397">        case AddressFilter::EXTERNAL:</a>
<a name="ln398">          if (!temp.address().is_unspecified() &amp;&amp; !temp.address().is_loopback()) {</a>
<a name="ln399">            result-&gt;push_back(temp.address());</a>
<a name="ln400">          }</a>
<a name="ln401">          break;</a>
<a name="ln402">      }</a>
<a name="ln403">    }</a>
<a name="ln404">  }</a>
<a name="ln405">  return Status::OK();</a>
<a name="ln406">}</a>
<a name="ln407"> </a>
<a name="ln408">Status GetFQDN(string* hostname) {</a>
<a name="ln409">  TRACE_EVENT0(&quot;net&quot;, &quot;GetFQDN&quot;);</a>
<a name="ln410">  // Start with the non-qualified hostname</a>
<a name="ln411">  RETURN_NOT_OK(GetHostname(hostname));</a>
<a name="ln412"> </a>
<a name="ln413">  struct addrinfo hints;</a>
<a name="ln414">  memset(&amp;hints, 0, sizeof(hints));</a>
<a name="ln415">  hints.ai_socktype = SOCK_DGRAM;</a>
<a name="ln416">  hints.ai_flags = AI_CANONNAME;</a>
<a name="ln417"> </a>
<a name="ln418">  struct addrinfo* result;</a>
<a name="ln419">  LOG_SLOW_EXECUTION(WARNING, 200,</a>
<a name="ln420">                     Substitute(&quot;looking up canonical hostname for localhost $0&quot;, *hostname)) {</a>
<a name="ln421">    TRACE_EVENT0(&quot;net&quot;, &quot;getaddrinfo&quot;);</a>
<a name="ln422">    const int rc = getaddrinfo(hostname-&gt;c_str(), nullptr, &amp;hints, &amp;result);</a>
<a name="ln423">    if (rc != 0) {</a>
<a name="ln424">      return STATUS(NetworkError,</a>
<a name="ln425">                    Substitute(&quot;Unable to lookup FQDN ($0), getaddrinfo returned $1&quot;,</a>
<a name="ln426">                               *hostname, getaddrinfo_rc_to_string(rc)),</a>
<a name="ln427">                    Errno(errno));</a>
<a name="ln428">    }</a>
<a name="ln429">  }</a>
<a name="ln430"> </a>
<a name="ln431">  *hostname = result-&gt;ai_canonname;</a>
<a name="ln432">  freeaddrinfo(result);</a>
<a name="ln433">  return Status::OK();</a>
<a name="ln434">}</a>
<a name="ln435"> </a>
<a name="ln436">Status EndpointFromHostPort(const HostPort&amp; host_port, Endpoint* endpoint) {</a>
<a name="ln437">  vector&lt;Endpoint&gt; addrs;</a>
<a name="ln438">  RETURN_NOT_OK(host_port.ResolveAddresses(&amp;addrs));</a>
<a name="ln439">  if (addrs.empty()) {</a>
<a name="ln440">    return STATUS(NetworkError, &quot;Unable to resolve address&quot;, host_port.ToString());</a>
<a name="ln441">  }</a>
<a name="ln442">  *endpoint = addrs[0];</a>
<a name="ln443">  if (addrs.size() &gt; 1) {</a>
<a name="ln444">    VLOG(1) &lt;&lt; &quot;Hostname &quot; &lt;&lt; host_port.host() &lt;&lt; &quot; resolved to more than one address. &quot;</a>
<a name="ln445">            &lt;&lt; &quot;Using address: &quot; &lt;&lt; *endpoint;</a>
<a name="ln446">  }</a>
<a name="ln447">  return Status::OK();</a>
<a name="ln448">}</a>
<a name="ln449"> </a>
<a name="ln450">Status HostPortFromEndpointReplaceWildcard(const Endpoint&amp; addr, HostPort* hp) {</a>
<a name="ln451">  string host;</a>
<a name="ln452">  if (addr.address().is_unspecified()) {</a>
<a name="ln453">    auto status = GetFQDN(&amp;host);</a>
<a name="ln454">    if (!status.ok()) {</a>
<a name="ln455">      std::vector&lt;IpAddress&gt; locals;</a>
<a name="ln456">      if (GetLocalAddresses(&amp;locals, AddressFilter::EXTERNAL).ok() &amp;&amp; !locals.empty()) {</a>
<a name="ln457">        hp-&gt;set_host(locals.front().to_string());</a>
<a name="ln458">        hp-&gt;set_port(addr.port());</a>
<a name="ln459">        return Status::OK();</a>
<a name="ln460">      }</a>
<a name="ln461">      return status;</a>
<a name="ln462">    }</a>
<a name="ln463">  } else {</a>
<a name="ln464">    host = addr.address().to_string();</a>
<a name="ln465">  }</a>
<a name="ln466">  hp-&gt;set_host(host);</a>
<a name="ln467">  hp-&gt;set_port(addr.port());</a>
<a name="ln468">  return Status::OK();</a>
<a name="ln469">}</a>
<a name="ln470"> </a>
<a name="ln471">void TryRunLsof(const Endpoint&amp; addr, vector&lt;string&gt;* log) {</a>
<a name="ln472">#if defined(__APPLE__)</a>
<a name="ln473">  string cmd = strings::Substitute(</a>
<a name="ln474">      &quot;lsof -n -i 'TCP:$0' -sTCP:LISTEN ; &quot;</a>
<a name="ln475">      &quot;for pid in $$(lsof -F p -n -i 'TCP:$0' -sTCP:LISTEN | cut -f 2 -dp) ; do&quot;</a>
<a name="ln476">      &quot;  pstree $$pid || ps h -p $$pid;&quot;</a>
<a name="ln477">      &quot;done&quot;,</a>
<a name="ln478">      addr.port());</a>
<a name="ln479">#else</a>
<a name="ln480">  // Little inline bash script prints the full ancestry of any pid listening</a>
<a name="ln481">  // on the same port as 'addr'. We could use 'pstree -s', but that option</a>
<a name="ln482">  // doesn't exist on el6.</a>
<a name="ln483">  //</a>
<a name="ln484">  // Note the sed command to check for the process name wrapped in ().</a>
<a name="ln485">  // Example prefix of /proc/$pid/stat output, with a process with spaces in the name:</a>
<a name="ln486">  // 3917 (tmux: server) S 1</a>
<a name="ln487">  string cmd = strings::Substitute(</a>
<a name="ln488">      &quot;export PATH=$$PATH:/usr/sbin ; &quot;</a>
<a name="ln489">      &quot;lsof -n -i 'TCP:$0' -sTCP:LISTEN ; &quot;</a>
<a name="ln490">      &quot;for pid in $$(lsof -F p -n -i 'TCP:$0' -sTCP:LISTEN | cut -f 2 -dp) ; do&quot;</a>
<a name="ln491">      &quot;  while [ $$pid -gt 1 ] ; do&quot;</a>
<a name="ln492">      &quot;    ps h -fp $$pid ;&quot;</a>
<a name="ln493">      &quot;    pid=$$(sed 's/.* (.*) [^ ] \\([0-9]*\\).*/\\1/g' /proc/$$pid/stat);&quot;</a>
<a name="ln494">      &quot;  done ; &quot;</a>
<a name="ln495">      &quot;done&quot;,</a>
<a name="ln496">      addr.port());</a>
<a name="ln497">#endif // defined(__APPLE__)</a>
<a name="ln498"> </a>
<a name="ln499">  LOG_STRING(WARNING, log) &lt;&lt; &quot;Failed to bind to &quot; &lt;&lt; addr &lt;&lt; &quot;. &quot;</a>
<a name="ln500">                           &lt;&lt; &quot;Trying to use lsof to find any processes listening &quot;</a>
<a name="ln501">                           &lt;&lt; &quot;on the same port:&quot;;</a>
<a name="ln502">  LOG_STRING(INFO, log) &lt;&lt; &quot;$ &quot; &lt;&lt; cmd;</a>
<a name="ln503">  vector&lt;string&gt; argv = { &quot;bash&quot;, &quot;-c&quot;, cmd };</a>
<a name="ln504">  string results;</a>
<a name="ln505">  Status s = Subprocess::Call(argv, &amp;results);</a>
<a name="ln506">  if (PREDICT_FALSE(!s.ok())) {</a>
<a name="ln507">    LOG_STRING(WARNING, log) &lt;&lt; s.ToString();</a>
<a name="ln508">  }</a>
<a name="ln509">  LOG_STRING(WARNING, log) &lt;&lt; results;</a>
<a name="ln510">}</a>
<a name="ln511"> </a>
<a name="ln512">uint16_t GetFreePort(std::unique_ptr&lt;FileLock&gt;* file_lock) {</a>
<a name="ln513">  // To avoid a race condition where the free port returned to the caller gets used by another</a>
<a name="ln514">  // process before this caller can use it, we will lock the port using a file level lock.</a>
<a name="ln515">  // First create the directory, if it doesn't already exist, where these lock files will live.</a>
<a name="ln516">  Env* env = Env::Default();</a>
<a name="ln517">  bool created = false;</a>
<a name="ln518">  const string lock_file_dir = &quot;/tmp/yb-port-locks&quot;;</a>
<a name="ln519">  Status status = env_util::CreateDirIfMissing(env, lock_file_dir, &amp;created);</a>
<a name="ln520">  if (!status.ok()) {</a>
<a name="ln521">    LOG(FATAL) &lt;&lt; &quot;Could not create &quot; &lt;&lt; lock_file_dir &lt;&lt; &quot; directory: &quot;</a>
<a name="ln522">               &lt;&lt; status.ToString();</a>
<a name="ln523">  }</a>
<a name="ln524"> </a>
<a name="ln525">  // Now, find a unused port in the [kMinPort..kMaxPort] range.</a>
<a name="ln526">  constexpr uint16_t kMinPort = 15000;</a>
<a name="ln527">  constexpr uint16_t kMaxPort = 30000;</a>
<a name="ln528">  static yb::Random rand(GetCurrentTimeMicros());</a>
<a name="ln529">  Status s;</a>
<a name="ln530">  for (int i = 0; i &lt; 1000; ++i) {</a>
<a name="ln531">    const uint16_t random_port = kMinPort + rand.Next() % (kMaxPort - kMinPort + 1);</a>
<a name="ln532">    VLOG(1) &lt;&lt; &quot;Trying to bind to port &quot; &lt;&lt; random_port;</a>
<a name="ln533"> </a>
<a name="ln534">    Endpoint sock_addr(boost::asio::ip::address_v4::loopback(), random_port);</a>
<a name="ln535">    Socket sock;</a>
<a name="ln536">    s = sock.Init(0);</a>
<a name="ln537">    if (!s.ok()) {</a>
<a name="ln538">      VLOG(1) &lt;&lt; &quot;Failed to call Init() on socket ith address &quot; &lt;&lt; sock_addr;</a>
<a name="ln539">      continue;</a>
<a name="ln540">    }</a>
<a name="ln541"> </a>
<a name="ln542">    s = sock.Bind(sock_addr, /* explain_addr_in_use */ false);</a>
<a name="ln543">    if (s.ok()) {</a>
<a name="ln544">      // We found an unused port.</a>
<a name="ln545"> </a>
<a name="ln546">      // Now, lock this &quot;port&quot; for use by the current process before 'sock' goes out of scope.</a>
<a name="ln547">      // This will ensure that no other process can get this port while this process is still</a>
<a name="ln548">      // running. LockFile() returns immediately if we can't get the lock. That's the behavior</a>
<a name="ln549">      // we want. In that case, we'll just try another port.</a>
<a name="ln550">      const string lock_file = lock_file_dir + &quot;/&quot; + std::to_string(random_port) + &quot;.lck&quot;;</a>
<a name="ln551">      FileLock *lock = nullptr;</a>
<a name="ln552">      s = env-&gt;LockFile(lock_file, &amp;lock, false /* recursive_lock_ok */);</a>
<a name="ln553">      if (s.ok()) {</a>
<a name="ln554">        CHECK(lock) &lt;&lt; &quot;Lock should not be NULL&quot;;</a>
<a name="ln555">        file_lock-&gt;reset(lock);</a>
<a name="ln556">        LOG(INFO) &lt;&lt; &quot;Selected random free RPC port &quot; &lt;&lt; random_port;</a>
<a name="ln557">        return random_port;</a>
<a name="ln558">      } else {</a>
<a name="ln559">        VLOG(1) &lt;&lt; &quot;Could not lock file &quot; &lt;&lt; lock_file &lt;&lt; &quot;: &quot; &lt;&lt; s.ToString();</a>
<a name="ln560">      }</a>
<a name="ln561">    } else {</a>
<a name="ln562">      VLOG(1) &lt;&lt; &quot;Failed to bind to port &quot; &lt;&lt; random_port &lt;&lt; &quot;: &quot; &lt;&lt; s.ToString();</a>
<a name="ln563">    }</a>
<a name="ln564">  }</a>
<a name="ln565"> </a>
<a name="ln566">  LOG(FATAL) &lt;&lt; &quot;Could not find a free random port between &quot; &lt;&lt;  kMinPort &lt;&lt; &quot; and &quot;</a>
<a name="ln567">             &lt;&lt; kMaxPort &lt;&lt; &quot; inclusively&quot; &lt;&lt; &quot;: &quot; &lt;&lt; s.ToString();</a>
<a name="ln568">  return 0;  // never reached</a>
<a name="ln569">}</a>
<a name="ln570"> </a>
<a name="ln571">bool HostPort::equals(const Endpoint&amp; endpoint) const {</a>
<a name="ln572">  return endpoint.address().to_string() == host() &amp;&amp; endpoint.port() == port();</a>
<a name="ln573">}</a>
<a name="ln574"> </a>
<a name="ln575">HostPort HostPort::FromBoundEndpoint(const Endpoint&amp; endpoint) {</a>
<a name="ln576">  if (endpoint.address().is_unspecified()) {</a>
<a name="ln577">    return HostPort(endpoint.address().is_v4() ? &quot;127.0.0.1&quot; : &quot;::1&quot;, endpoint.port());</a>
<a name="ln578">  } else {</a>
<a name="ln579">    return HostPort(endpoint);</a>
<a name="ln580">  }</a>
<a name="ln581">}</a>
<a name="ln582"> </a>
<a name="ln583">std::string HostPortToString(const std::string&amp; host, int port) {</a>
<a name="ln584">  DCHECK_GE(port, 0);</a>
<a name="ln585">  DCHECK_LE(port, 65535);</a>
<a name="ln586">  if (host.find(':') != string::npos) {</a>
<a name="ln587">    return Format(&quot;[$0]:$1&quot;, host, port);</a>
<a name="ln588">  } else {</a>
<a name="ln589">    return Format(&quot;$0:$1&quot;, host, port);</a>
<a name="ln590">  }</a>
<a name="ln591">}</a>
<a name="ln592"> </a>
<a name="ln593">Status HostToAddresses(</a>
<a name="ln594">    const std::string&amp; host,</a>
<a name="ln595">    boost::container::small_vector_base&lt;IpAddress&gt;* addresses) {</a>
<a name="ln596">  return ResolveInetAddresses(host, [&amp;addresses](const IpAddress&amp; address) {</a>
<a name="ln597">    addresses-&gt;push_back(address);</a>
<a name="ln598">  });</a>
<a name="ln599">}</a>
<a name="ln600"> </a>
<a name="ln601">Result&lt;IpAddress&gt; HostToAddress(const std::string&amp; host) {</a>
<a name="ln602">  boost::container::small_vector&lt;IpAddress, 1&gt; addrs;</a>
<a name="ln603">  RETURN_NOT_OK(HostToAddresses(host, &amp;addrs));</a>
<a name="ln604">  if (addrs.empty()) {</a>
<a name="ln605">    return STATUS(NetworkError, &quot;Unable to resolve address&quot;, host);</a>
<a name="ln606">  }</a>
<a name="ln607">  auto addr = addrs.front();</a>
<a name="ln608">  if (addrs.size() &gt; 1) {</a>
<a name="ln609">    VLOG(1) &lt;&lt; &quot;Hostname &quot; &lt;&lt; host &lt;&lt; &quot; resolved to more than one address. &quot;</a>
<a name="ln610">            &lt;&lt; &quot;Using address: &quot; &lt;&lt; addr;</a>
<a name="ln611">  }</a>
<a name="ln612">  return addr;</a>
<a name="ln613">}</a>
<a name="ln614"> </a>
<a name="ln615">bool IsWildcardAddress(const std::string&amp; host_str) {</a>
<a name="ln616">  boost::system::error_code ec;</a>
<a name="ln617">  auto addr = IpAddress::from_string(host_str, ec);</a>
<a name="ln618">  return !ec &amp;&amp; addr.is_unspecified();</a>
<a name="ln619">}</a>
<a name="ln620"> </a>
<a name="ln621">Result&lt;IpAddress&gt; ParseIpAddress(const std::string&amp; host) {</a>
<a name="ln622">  boost::system::error_code ec;</a>
<a name="ln623">  auto addr = IpAddress::from_string(host, ec);</a>
<a name="ln624">  if (ec) {</a>
<a name="ln625">    return STATUS_FORMAT(InvalidArgument, &quot;Failed to parse $0: $1&quot;, host, ec.message());</a>
<a name="ln626">  }</a>
<a name="ln627"> </a>
<a name="ln628">  VLOG(4) &lt;&lt; &quot;Resolving ip address to itself for input: &quot; &lt;&lt; host;</a>
<a name="ln629">  return addr;</a>
<a name="ln630">}</a>
<a name="ln631"> </a>
<a name="ln632">boost::optional&lt;IpAddress&gt; TryFastResolve(const std::string&amp; host) {</a>
<a name="ln633">  auto result = ParseIpAddress(host);</a>
<a name="ln634">  if (result.ok()) {</a>
<a name="ln635">    return *result;</a>
<a name="ln636">  }</a>
<a name="ln637"> </a>
<a name="ln638">  // For testing purpose we resolve A.B.C.D.ip.yugabyte to A.B.C.D.</a>
<a name="ln639">  static const std::string kYbIpSuffix = &quot;.ip.yugabyte&quot;;</a>
<a name="ln640">  if (boost::ends_with(host, kYbIpSuffix)) {</a>
<a name="ln641">    boost::system::error_code ec;</a>
<a name="ln642">    auto address = IpAddress::from_string(</a>
<a name="ln643">        host.substr(0, host.length() - kYbIpSuffix.length()), ec);</a>
<a name="ln644">    if (!ec) {</a>
<a name="ln645">      return address;</a>
<a name="ln646">    }</a>
<a name="ln647">  }</a>
<a name="ln648"> </a>
<a name="ln649">  return boost::none;</a>
<a name="ln650">}</a>
<a name="ln651"> </a>
<a name="ln652">} // namespace yb</a>

</code></pre>
<div class="balloon" rel="240"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="255"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v512/" target="_blank">V512</a> A call of the 'memcpy' function will lead to overflow of the buffer 'endpoint.data()'.</p></div>
<div class="balloon" rel="273"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="282"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="285"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="444"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="532"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="538"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="554"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="559"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="562"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="609"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="628"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
