
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>read_until.hpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//</a>
<a name="ln2">// impl/read_until.hpp</a>
<a name="ln3">// ~~~~~~~~~~~~~~~~~~~</a>
<a name="ln4">//</a>
<a name="ln5">// Copyright (c) 2003-2018 Christopher M. Kohlhoff (chris at kohlhoff dot com)</a>
<a name="ln6">//</a>
<a name="ln7">// Distributed under the Boost Software License, Version 1.0. (See accompanying</a>
<a name="ln8">// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)</a>
<a name="ln9">//</a>
<a name="ln10"> </a>
<a name="ln11">#ifndef BOOST_ASIO_IMPL_READ_UNTIL_HPP</a>
<a name="ln12">#define BOOST_ASIO_IMPL_READ_UNTIL_HPP</a>
<a name="ln13"> </a>
<a name="ln14">#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1200)</a>
<a name="ln15"># pragma once</a>
<a name="ln16">#endif // defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1200)</a>
<a name="ln17"> </a>
<a name="ln18">#include &lt;algorithm&gt;</a>
<a name="ln19">#include &lt;string&gt;</a>
<a name="ln20">#include &lt;vector&gt;</a>
<a name="ln21">#include &lt;utility&gt;</a>
<a name="ln22">#include &lt;boost/asio/associated_allocator.hpp&gt;</a>
<a name="ln23">#include &lt;boost/asio/associated_executor.hpp&gt;</a>
<a name="ln24">#include &lt;boost/asio/buffer.hpp&gt;</a>
<a name="ln25">#include &lt;boost/asio/buffers_iterator.hpp&gt;</a>
<a name="ln26">#include &lt;boost/asio/detail/bind_handler.hpp&gt;</a>
<a name="ln27">#include &lt;boost/asio/detail/handler_alloc_helpers.hpp&gt;</a>
<a name="ln28">#include &lt;boost/asio/detail/handler_cont_helpers.hpp&gt;</a>
<a name="ln29">#include &lt;boost/asio/detail/handler_invoke_helpers.hpp&gt;</a>
<a name="ln30">#include &lt;boost/asio/detail/handler_type_requirements.hpp&gt;</a>
<a name="ln31">#include &lt;boost/asio/detail/limits.hpp&gt;</a>
<a name="ln32">#include &lt;boost/asio/detail/throw_error.hpp&gt;</a>
<a name="ln33"> </a>
<a name="ln34">#include &lt;boost/asio/detail/push_options.hpp&gt;</a>
<a name="ln35"> </a>
<a name="ln36">namespace boost {</a>
<a name="ln37">namespace asio {</a>
<a name="ln38"> </a>
<a name="ln39">template &lt;typename SyncReadStream, typename DynamicBuffer&gt;</a>
<a name="ln40">inline std::size_t read_until(SyncReadStream&amp; s,</a>
<a name="ln41">    BOOST_ASIO_MOVE_ARG(DynamicBuffer) buffers, char delim)</a>
<a name="ln42">{</a>
<a name="ln43">  boost::system::error_code ec;</a>
<a name="ln44">  std::size_t bytes_transferred = read_until(s,</a>
<a name="ln45">      BOOST_ASIO_MOVE_CAST(DynamicBuffer)(buffers), delim, ec);</a>
<a name="ln46">  boost::asio::detail::throw_error(ec, &quot;read_until&quot;);</a>
<a name="ln47">  return bytes_transferred;</a>
<a name="ln48">}</a>
<a name="ln49"> </a>
<a name="ln50">template &lt;typename SyncReadStream, typename DynamicBuffer&gt;</a>
<a name="ln51">std::size_t read_until(SyncReadStream&amp; s,</a>
<a name="ln52">    BOOST_ASIO_MOVE_ARG(DynamicBuffer) buffers,</a>
<a name="ln53">    char delim, boost::system::error_code&amp; ec)</a>
<a name="ln54">{</a>
<a name="ln55">  typename decay&lt;DynamicBuffer&gt;::type b(</a>
<a name="ln56">      BOOST_ASIO_MOVE_CAST(DynamicBuffer)(buffers));</a>
<a name="ln57"> </a>
<a name="ln58">  std::size_t search_position = 0;</a>
<a name="ln59">  for (;;)</a>
<a name="ln60">  {</a>
<a name="ln61">    // Determine the range of the data to be searched.</a>
<a name="ln62">    typedef typename DynamicBuffer::const_buffers_type buffers_type;</a>
<a name="ln63">    typedef buffers_iterator&lt;buffers_type&gt; iterator;</a>
<a name="ln64">    buffers_type data_buffers = b.data();</a>
<a name="ln65">    iterator begin = iterator::begin(data_buffers);</a>
<a name="ln66">    iterator start_pos = begin + search_position;</a>
<a name="ln67">    iterator end = iterator::end(data_buffers);</a>
<a name="ln68"> </a>
<a name="ln69">    // Look for a match.</a>
<a name="ln70">    iterator iter = std::find(start_pos, end, delim);</a>
<a name="ln71">    if (iter != end)</a>
<a name="ln72">    {</a>
<a name="ln73">      // Found a match. We're done.</a>
<a name="ln74">      ec = boost::system::error_code();</a>
<a name="ln75">      return iter - begin + 1;</a>
<a name="ln76">    }</a>
<a name="ln77">    else</a>
<a name="ln78">    {</a>
<a name="ln79">      // No match. Next search can start with the new data.</a>
<a name="ln80">      search_position = end - begin;</a>
<a name="ln81">    }</a>
<a name="ln82"> </a>
<a name="ln83">    // Check if buffer is full.</a>
<a name="ln84">    if (b.size() == b.max_size())</a>
<a name="ln85">    {</a>
<a name="ln86">      ec = error::not_found;</a>
<a name="ln87">      return 0;</a>
<a name="ln88">    }</a>
<a name="ln89"> </a>
<a name="ln90">    // Need more data.</a>
<a name="ln91">    std::size_t bytes_to_read = std::min&lt;std::size_t&gt;(</a>
<a name="ln92">          std::max&lt;std::size_t&gt;(512, b.capacity() - b.size()),</a>
<a name="ln93">          std::min&lt;std::size_t&gt;(65536, b.max_size() - b.size()));</a>
<a name="ln94">    b.commit(s.read_some(b.prepare(bytes_to_read), ec));</a>
<a name="ln95">    if (ec)</a>
<a name="ln96">      return 0;</a>
<a name="ln97">  }</a>
<a name="ln98">}</a>
<a name="ln99"> </a>
<a name="ln100">template &lt;typename SyncReadStream, typename DynamicBuffer&gt;</a>
<a name="ln101">inline std::size_t read_until(SyncReadStream&amp; s,</a>
<a name="ln102">    BOOST_ASIO_MOVE_ARG(DynamicBuffer) buffers,</a>
<a name="ln103">    BOOST_ASIO_STRING_VIEW_PARAM delim)</a>
<a name="ln104">{</a>
<a name="ln105">  boost::system::error_code ec;</a>
<a name="ln106">  std::size_t bytes_transferred = read_until(s,</a>
<a name="ln107">      BOOST_ASIO_MOVE_CAST(DynamicBuffer)(buffers), delim, ec);</a>
<a name="ln108">  boost::asio::detail::throw_error(ec, &quot;read_until&quot;);</a>
<a name="ln109">  return bytes_transferred;</a>
<a name="ln110">}</a>
<a name="ln111"> </a>
<a name="ln112">namespace detail</a>
<a name="ln113">{</a>
<a name="ln114">  // Algorithm that finds a subsequence of equal values in a sequence. Returns</a>
<a name="ln115">  // (iterator,true) if a full match was found, in which case the iterator</a>
<a name="ln116">  // points to the beginning of the match. Returns (iterator,false) if a</a>
<a name="ln117">  // partial match was found at the end of the first sequence, in which case</a>
<a name="ln118">  // the iterator points to the beginning of the partial match. Returns</a>
<a name="ln119">  // (last1,false) if no full or partial match was found.</a>
<a name="ln120">  template &lt;typename Iterator1, typename Iterator2&gt;</a>
<a name="ln121">  std::pair&lt;Iterator1, bool&gt; partial_search(</a>
<a name="ln122">      Iterator1 first1, Iterator1 last1, Iterator2 first2, Iterator2 last2)</a>
<a name="ln123">  {</a>
<a name="ln124">    for (Iterator1 iter1 = first1; iter1 != last1; ++iter1)</a>
<a name="ln125">    {</a>
<a name="ln126">      Iterator1 test_iter1 = iter1;</a>
<a name="ln127">      Iterator2 test_iter2 = first2;</a>
<a name="ln128">      for (;; ++test_iter1, ++test_iter2)</a>
<a name="ln129">      {</a>
<a name="ln130">        if (test_iter2 == last2)</a>
<a name="ln131">          return std::make_pair(iter1, true);</a>
<a name="ln132">        if (test_iter1 == last1)</a>
<a name="ln133">        {</a>
<a name="ln134">          if (test_iter2 != first2)</a>
<a name="ln135">            return std::make_pair(iter1, false);</a>
<a name="ln136">          else</a>
<a name="ln137">            break;</a>
<a name="ln138">        }</a>
<a name="ln139">        if (*test_iter1 != *test_iter2)</a>
<a name="ln140">          break;</a>
<a name="ln141">      }</a>
<a name="ln142">    }</a>
<a name="ln143">    return std::make_pair(last1, false);</a>
<a name="ln144">  }</a>
<a name="ln145">} // namespace detail</a>
<a name="ln146"> </a>
<a name="ln147">template &lt;typename SyncReadStream, typename DynamicBuffer&gt;</a>
<a name="ln148">std::size_t read_until(SyncReadStream&amp; s,</a>
<a name="ln149">    BOOST_ASIO_MOVE_ARG(DynamicBuffer) buffers,</a>
<a name="ln150">    BOOST_ASIO_STRING_VIEW_PARAM delim, boost::system::error_code&amp; ec)</a>
<a name="ln151">{</a>
<a name="ln152">  typename decay&lt;DynamicBuffer&gt;::type b(</a>
<a name="ln153">      BOOST_ASIO_MOVE_CAST(DynamicBuffer)(buffers));</a>
<a name="ln154"> </a>
<a name="ln155">  std::size_t search_position = 0;</a>
<a name="ln156">  for (;;)</a>
<a name="ln157">  {</a>
<a name="ln158">    // Determine the range of the data to be searched.</a>
<a name="ln159">    typedef typename DynamicBuffer::const_buffers_type buffers_type;</a>
<a name="ln160">    typedef buffers_iterator&lt;buffers_type&gt; iterator;</a>
<a name="ln161">    buffers_type data_buffers = b.data();</a>
<a name="ln162">    iterator begin = iterator::begin(data_buffers);</a>
<a name="ln163">    iterator start_pos = begin + search_position;</a>
<a name="ln164">    iterator end = iterator::end(data_buffers);</a>
<a name="ln165"> </a>
<a name="ln166">    // Look for a match.</a>
<a name="ln167">    std::pair&lt;iterator, bool&gt; result = detail::partial_search(</a>
<a name="ln168">        start_pos, end, delim.begin(), delim.end());</a>
<a name="ln169">    if (result.first != end)</a>
<a name="ln170">    {</a>
<a name="ln171">      if (result.second)</a>
<a name="ln172">      {</a>
<a name="ln173">        // Full match. We're done.</a>
<a name="ln174">        ec = boost::system::error_code();</a>
<a name="ln175">        return result.first - begin + delim.length();</a>
<a name="ln176">      }</a>
<a name="ln177">      else</a>
<a name="ln178">      {</a>
<a name="ln179">        // Partial match. Next search needs to start from beginning of match.</a>
<a name="ln180">        search_position = result.first - begin;</a>
<a name="ln181">      }</a>
<a name="ln182">    }</a>
<a name="ln183">    else</a>
<a name="ln184">    {</a>
<a name="ln185">      // No match. Next search can start with the new data.</a>
<a name="ln186">      search_position = end - begin;</a>
<a name="ln187">    }</a>
<a name="ln188"> </a>
<a name="ln189">    // Check if buffer is full.</a>
<a name="ln190">    if (b.size() == b.max_size())</a>
<a name="ln191">    {</a>
<a name="ln192">      ec = error::not_found;</a>
<a name="ln193">      return 0;</a>
<a name="ln194">    }</a>
<a name="ln195"> </a>
<a name="ln196">    // Need more data.</a>
<a name="ln197">    std::size_t bytes_to_read = std::min&lt;std::size_t&gt;(</a>
<a name="ln198">          std::max&lt;std::size_t&gt;(512, b.capacity() - b.size()),</a>
<a name="ln199">          std::min&lt;std::size_t&gt;(65536, b.max_size() - b.size()));</a>
<a name="ln200">    b.commit(s.read_some(b.prepare(bytes_to_read), ec));</a>
<a name="ln201">    if (ec)</a>
<a name="ln202">      return 0;</a>
<a name="ln203">  }</a>
<a name="ln204">}</a>
<a name="ln205"> </a>
<a name="ln206">#if !defined(BOOST_ASIO_NO_EXTENSIONS)</a>
<a name="ln207">#if defined(BOOST_ASIO_HAS_BOOST_REGEX)</a>
<a name="ln208"> </a>
<a name="ln209">template &lt;typename SyncReadStream, typename DynamicBuffer&gt;</a>
<a name="ln210">inline std::size_t read_until(SyncReadStream&amp; s,</a>
<a name="ln211">    BOOST_ASIO_MOVE_ARG(DynamicBuffer) buffers,</a>
<a name="ln212">    const boost::regex&amp; expr)</a>
<a name="ln213">{</a>
<a name="ln214">  boost::system::error_code ec;</a>
<a name="ln215">  std::size_t bytes_transferred = read_until(s,</a>
<a name="ln216">      BOOST_ASIO_MOVE_CAST(DynamicBuffer)(buffers), expr, ec);</a>
<a name="ln217">  boost::asio::detail::throw_error(ec, &quot;read_until&quot;);</a>
<a name="ln218">  return bytes_transferred;</a>
<a name="ln219">}</a>
<a name="ln220"> </a>
<a name="ln221">template &lt;typename SyncReadStream, typename DynamicBuffer&gt;</a>
<a name="ln222">std::size_t read_until(SyncReadStream&amp; s,</a>
<a name="ln223">    BOOST_ASIO_MOVE_ARG(DynamicBuffer) buffers,</a>
<a name="ln224">    const boost::regex&amp; expr, boost::system::error_code&amp; ec)</a>
<a name="ln225">{</a>
<a name="ln226">  typename decay&lt;DynamicBuffer&gt;::type b(</a>
<a name="ln227">      BOOST_ASIO_MOVE_CAST(DynamicBuffer)(buffers));</a>
<a name="ln228"> </a>
<a name="ln229">  std::size_t search_position = 0;</a>
<a name="ln230">  for (;;)</a>
<a name="ln231">  {</a>
<a name="ln232">    // Determine the range of the data to be searched.</a>
<a name="ln233">    typedef typename DynamicBuffer::const_buffers_type buffers_type;</a>
<a name="ln234">    typedef buffers_iterator&lt;buffers_type&gt; iterator;</a>
<a name="ln235">    buffers_type data_buffers = b.data();</a>
<a name="ln236">    iterator begin = iterator::begin(data_buffers);</a>
<a name="ln237">    iterator start_pos = begin + search_position;</a>
<a name="ln238">    iterator end = iterator::end(data_buffers);</a>
<a name="ln239"> </a>
<a name="ln240">    // Look for a match.</a>
<a name="ln241">    boost::match_results&lt;iterator,</a>
<a name="ln242">      typename std::vector&lt;boost::sub_match&lt;iterator&gt; &gt;::allocator_type&gt;</a>
<a name="ln243">        match_results;</a>
<a name="ln244">    if (regex_search(start_pos, end, match_results, expr,</a>
<a name="ln245">          boost::match_default | boost::match_partial))</a>
<a name="ln246">    {</a>
<a name="ln247">      if (match_results[0].matched)</a>
<a name="ln248">      {</a>
<a name="ln249">        // Full match. We're done.</a>
<a name="ln250">        ec = boost::system::error_code();</a>
<a name="ln251">        return match_results[0].second - begin;</a>
<a name="ln252">      }</a>
<a name="ln253">      else</a>
<a name="ln254">      {</a>
<a name="ln255">        // Partial match. Next search needs to start from beginning of match.</a>
<a name="ln256">        search_position = match_results[0].first - begin;</a>
<a name="ln257">      }</a>
<a name="ln258">    }</a>
<a name="ln259">    else</a>
<a name="ln260">    {</a>
<a name="ln261">      // No match. Next search can start with the new data.</a>
<a name="ln262">      search_position = end - begin;</a>
<a name="ln263">    }</a>
<a name="ln264"> </a>
<a name="ln265">    // Check if buffer is full.</a>
<a name="ln266">    if (b.size() == b.max_size())</a>
<a name="ln267">    {</a>
<a name="ln268">      ec = error::not_found;</a>
<a name="ln269">      return 0;</a>
<a name="ln270">    }</a>
<a name="ln271"> </a>
<a name="ln272">    // Need more data.</a>
<a name="ln273">    std::size_t bytes_to_read = std::min&lt;std::size_t&gt;(</a>
<a name="ln274">          std::max&lt;std::size_t&gt;(512, b.capacity() - b.size()),</a>
<a name="ln275">          std::min&lt;std::size_t&gt;(65536, b.max_size() - b.size()));</a>
<a name="ln276">    b.commit(s.read_some(b.prepare(bytes_to_read), ec));</a>
<a name="ln277">    if (ec)</a>
<a name="ln278">      return 0;</a>
<a name="ln279">  }</a>
<a name="ln280">}</a>
<a name="ln281"> </a>
<a name="ln282">#endif // defined(BOOST_ASIO_HAS_BOOST_REGEX)</a>
<a name="ln283"> </a>
<a name="ln284">template &lt;typename SyncReadStream,</a>
<a name="ln285">    typename DynamicBuffer, typename MatchCondition&gt;</a>
<a name="ln286">inline std::size_t read_until(SyncReadStream&amp; s,</a>
<a name="ln287">    BOOST_ASIO_MOVE_ARG(DynamicBuffer) buffers,</a>
<a name="ln288">    MatchCondition match_condition,</a>
<a name="ln289">    typename enable_if&lt;is_match_condition&lt;MatchCondition&gt;::value&gt;::type*)</a>
<a name="ln290">{</a>
<a name="ln291">  boost::system::error_code ec;</a>
<a name="ln292">  std::size_t bytes_transferred = read_until(s,</a>
<a name="ln293">      BOOST_ASIO_MOVE_CAST(DynamicBuffer)(buffers),</a>
<a name="ln294">      match_condition, ec);</a>
<a name="ln295">  boost::asio::detail::throw_error(ec, &quot;read_until&quot;);</a>
<a name="ln296">  return bytes_transferred;</a>
<a name="ln297">}</a>
<a name="ln298"> </a>
<a name="ln299">template &lt;typename SyncReadStream,</a>
<a name="ln300">    typename DynamicBuffer, typename MatchCondition&gt;</a>
<a name="ln301">std::size_t read_until(SyncReadStream&amp; s,</a>
<a name="ln302">    BOOST_ASIO_MOVE_ARG(DynamicBuffer) buffers,</a>
<a name="ln303">    MatchCondition match_condition, boost::system::error_code&amp; ec,</a>
<a name="ln304">    typename enable_if&lt;is_match_condition&lt;MatchCondition&gt;::value&gt;::type*)</a>
<a name="ln305">{</a>
<a name="ln306">  typename decay&lt;DynamicBuffer&gt;::type b(</a>
<a name="ln307">      BOOST_ASIO_MOVE_CAST(DynamicBuffer)(buffers));</a>
<a name="ln308"> </a>
<a name="ln309">  std::size_t search_position = 0;</a>
<a name="ln310">  for (;;)</a>
<a name="ln311">  {</a>
<a name="ln312">    // Determine the range of the data to be searched.</a>
<a name="ln313">    typedef typename DynamicBuffer::const_buffers_type buffers_type;</a>
<a name="ln314">    typedef buffers_iterator&lt;buffers_type&gt; iterator;</a>
<a name="ln315">    buffers_type data_buffers = b.data();</a>
<a name="ln316">    iterator begin = iterator::begin(data_buffers);</a>
<a name="ln317">    iterator start_pos = begin + search_position;</a>
<a name="ln318">    iterator end = iterator::end(data_buffers);</a>
<a name="ln319"> </a>
<a name="ln320">    // Look for a match.</a>
<a name="ln321">    std::pair&lt;iterator, bool&gt; result = match_condition(start_pos, end);</a>
<a name="ln322">    if (result.second)</a>
<a name="ln323">    {</a>
<a name="ln324">      // Full match. We're done.</a>
<a name="ln325">      ec = boost::system::error_code();</a>
<a name="ln326">      return result.first - begin;</a>
<a name="ln327">    }</a>
<a name="ln328">    else if (result.first != end)</a>
<a name="ln329">    {</a>
<a name="ln330">      // Partial match. Next search needs to start from beginning of match.</a>
<a name="ln331">      search_position = result.first - begin;</a>
<a name="ln332">    }</a>
<a name="ln333">    else</a>
<a name="ln334">    {</a>
<a name="ln335">      // No match. Next search can start with the new data.</a>
<a name="ln336">      search_position = end - begin;</a>
<a name="ln337">    }</a>
<a name="ln338"> </a>
<a name="ln339">    // Check if buffer is full.</a>
<a name="ln340">    if (b.size() == b.max_size())</a>
<a name="ln341">    {</a>
<a name="ln342">      ec = error::not_found;</a>
<a name="ln343">      return 0;</a>
<a name="ln344">    }</a>
<a name="ln345"> </a>
<a name="ln346">    // Need more data.</a>
<a name="ln347">    std::size_t bytes_to_read = std::min&lt;std::size_t&gt;(</a>
<a name="ln348">          std::max&lt;std::size_t&gt;(512, b.capacity() - b.size()),</a>
<a name="ln349">          std::min&lt;std::size_t&gt;(65536, b.max_size() - b.size()));</a>
<a name="ln350">    b.commit(s.read_some(b.prepare(bytes_to_read), ec));</a>
<a name="ln351">    if (ec)</a>
<a name="ln352">      return 0;</a>
<a name="ln353">  }</a>
<a name="ln354">}</a>
<a name="ln355"> </a>
<a name="ln356">#if !defined(BOOST_ASIO_NO_IOSTREAM)</a>
<a name="ln357"> </a>
<a name="ln358">template &lt;typename SyncReadStream, typename Allocator&gt;</a>
<a name="ln359">inline std::size_t read_until(SyncReadStream&amp; s,</a>
<a name="ln360">    boost::asio::basic_streambuf&lt;Allocator&gt;&amp; b, char delim)</a>
<a name="ln361">{</a>
<a name="ln362">  return read_until(s, basic_streambuf_ref&lt;Allocator&gt;(b), delim);</a>
<a name="ln363">}</a>
<a name="ln364"> </a>
<a name="ln365">template &lt;typename SyncReadStream, typename Allocator&gt;</a>
<a name="ln366">inline std::size_t read_until(SyncReadStream&amp; s,</a>
<a name="ln367">    boost::asio::basic_streambuf&lt;Allocator&gt;&amp; b, char delim,</a>
<a name="ln368">    boost::system::error_code&amp; ec)</a>
<a name="ln369">{</a>
<a name="ln370">  return read_until(s, basic_streambuf_ref&lt;Allocator&gt;(b), delim, ec);</a>
<a name="ln371">}</a>
<a name="ln372"> </a>
<a name="ln373">template &lt;typename SyncReadStream, typename Allocator&gt;</a>
<a name="ln374">inline std::size_t read_until(SyncReadStream&amp; s,</a>
<a name="ln375">    boost::asio::basic_streambuf&lt;Allocator&gt;&amp; b,</a>
<a name="ln376">    BOOST_ASIO_STRING_VIEW_PARAM delim)</a>
<a name="ln377">{</a>
<a name="ln378">  return read_until(s, basic_streambuf_ref&lt;Allocator&gt;(b), delim);</a>
<a name="ln379">}</a>
<a name="ln380"> </a>
<a name="ln381">template &lt;typename SyncReadStream, typename Allocator&gt;</a>
<a name="ln382">inline std::size_t read_until(SyncReadStream&amp; s,</a>
<a name="ln383">    boost::asio::basic_streambuf&lt;Allocator&gt;&amp; b,</a>
<a name="ln384">    BOOST_ASIO_STRING_VIEW_PARAM delim, boost::system::error_code&amp; ec)</a>
<a name="ln385">{</a>
<a name="ln386">  return read_until(s, basic_streambuf_ref&lt;Allocator&gt;(b), delim, ec);</a>
<a name="ln387">}</a>
<a name="ln388"> </a>
<a name="ln389">#if defined(BOOST_ASIO_HAS_BOOST_REGEX)</a>
<a name="ln390"> </a>
<a name="ln391">template &lt;typename SyncReadStream, typename Allocator&gt;</a>
<a name="ln392">inline std::size_t read_until(SyncReadStream&amp; s,</a>
<a name="ln393">    boost::asio::basic_streambuf&lt;Allocator&gt;&amp; b, const boost::regex&amp; expr)</a>
<a name="ln394">{</a>
<a name="ln395">  return read_until(s, basic_streambuf_ref&lt;Allocator&gt;(b), expr);</a>
<a name="ln396">}</a>
<a name="ln397"> </a>
<a name="ln398">template &lt;typename SyncReadStream, typename Allocator&gt;</a>
<a name="ln399">inline std::size_t read_until(SyncReadStream&amp; s,</a>
<a name="ln400">    boost::asio::basic_streambuf&lt;Allocator&gt;&amp; b, const boost::regex&amp; expr,</a>
<a name="ln401">    boost::system::error_code&amp; ec)</a>
<a name="ln402">{</a>
<a name="ln403">  return read_until(s, basic_streambuf_ref&lt;Allocator&gt;(b), expr, ec);</a>
<a name="ln404">}</a>
<a name="ln405"> </a>
<a name="ln406">#endif // defined(BOOST_ASIO_HAS_BOOST_REGEX)</a>
<a name="ln407"> </a>
<a name="ln408">template &lt;typename SyncReadStream, typename Allocator, typename MatchCondition&gt;</a>
<a name="ln409">inline std::size_t read_until(SyncReadStream&amp; s,</a>
<a name="ln410">    boost::asio::basic_streambuf&lt;Allocator&gt;&amp; b, MatchCondition match_condition,</a>
<a name="ln411">    typename enable_if&lt;is_match_condition&lt;MatchCondition&gt;::value&gt;::type*)</a>
<a name="ln412">{</a>
<a name="ln413">  return read_until(s, basic_streambuf_ref&lt;Allocator&gt;(b), match_condition);</a>
<a name="ln414">}</a>
<a name="ln415"> </a>
<a name="ln416">template &lt;typename SyncReadStream, typename Allocator, typename MatchCondition&gt;</a>
<a name="ln417">inline std::size_t read_until(SyncReadStream&amp; s,</a>
<a name="ln418">    boost::asio::basic_streambuf&lt;Allocator&gt;&amp; b,</a>
<a name="ln419">    MatchCondition match_condition, boost::system::error_code&amp; ec,</a>
<a name="ln420">    typename enable_if&lt;is_match_condition&lt;MatchCondition&gt;::value&gt;::type*)</a>
<a name="ln421">{</a>
<a name="ln422">  return read_until(s, basic_streambuf_ref&lt;Allocator&gt;(b), match_condition, ec);</a>
<a name="ln423">}</a>
<a name="ln424"> </a>
<a name="ln425">#endif // !defined(BOOST_ASIO_NO_IOSTREAM)</a>
<a name="ln426">#endif // !defined(BOOST_ASIO_NO_EXTENSIONS)</a>
<a name="ln427"> </a>
<a name="ln428">namespace detail</a>
<a name="ln429">{</a>
<a name="ln430">  template &lt;typename AsyncReadStream,</a>
<a name="ln431">      typename DynamicBuffer, typename ReadHandler&gt;</a>
<a name="ln432">  class read_until_delim_op</a>
<a name="ln433">  {</a>
<a name="ln434">  public:</a>
<a name="ln435">    template &lt;typename BufferSequence&gt;</a>
<a name="ln436">    read_until_delim_op(AsyncReadStream&amp; stream,</a>
<a name="ln437">        BOOST_ASIO_MOVE_ARG(BufferSequence) buffers,</a>
<a name="ln438">        char delim, ReadHandler&amp; handler)</a>
<a name="ln439">      : stream_(stream),</a>
<a name="ln440">        buffers_(BOOST_ASIO_MOVE_CAST(BufferSequence)(buffers)),</a>
<a name="ln441">        delim_(delim),</a>
<a name="ln442">        start_(0),</a>
<a name="ln443">        search_position_(0),</a>
<a name="ln444">        handler_(BOOST_ASIO_MOVE_CAST(ReadHandler)(handler))</a>
<a name="ln445">    {</a>
<a name="ln446">    }</a>
<a name="ln447"> </a>
<a name="ln448">#if defined(BOOST_ASIO_HAS_MOVE)</a>
<a name="ln449">    read_until_delim_op(const read_until_delim_op&amp; other)</a>
<a name="ln450">      : stream_(other.stream_),</a>
<a name="ln451">        buffers_(other.buffers_),</a>
<a name="ln452">        delim_(other.delim_),</a>
<a name="ln453">        start_(other.start_),</a>
<a name="ln454">        search_position_(other.search_position_),</a>
<a name="ln455">        handler_(other.handler_)</a>
<a name="ln456">    {</a>
<a name="ln457">    }</a>
<a name="ln458"> </a>
<a name="ln459">    read_until_delim_op(read_until_delim_op&amp;&amp; other)</a>
<a name="ln460">      : stream_(other.stream_),</a>
<a name="ln461">        buffers_(BOOST_ASIO_MOVE_CAST(DynamicBuffer)(other.buffers_)),</a>
<a name="ln462">        delim_(other.delim_),</a>
<a name="ln463">        start_(other.start_),</a>
<a name="ln464">        search_position_(other.search_position_),</a>
<a name="ln465">        handler_(BOOST_ASIO_MOVE_CAST(ReadHandler)(other.handler_))</a>
<a name="ln466">    {</a>
<a name="ln467">    }</a>
<a name="ln468">#endif // defined(BOOST_ASIO_HAS_MOVE)</a>
<a name="ln469"> </a>
<a name="ln470">    void operator()(const boost::system::error_code&amp; ec,</a>
<a name="ln471">        std::size_t bytes_transferred, int start = 0)</a>
<a name="ln472">    {</a>
<a name="ln473">      const std::size_t not_found = (std::numeric_limits&lt;std::size_t&gt;::max)();</a>
<a name="ln474">      std::size_t bytes_to_read;</a>
<a name="ln475">      switch (start_ = start)</a>
<a name="ln476">      {</a>
<a name="ln477">      case 1:</a>
<a name="ln478">        for (;;)</a>
<a name="ln479">        {</a>
<a name="ln480">          {</a>
<a name="ln481">            // Determine the range of the data to be searched.</a>
<a name="ln482">            typedef typename DynamicBuffer::const_buffers_type</a>
<a name="ln483">              buffers_type;</a>
<a name="ln484">            typedef buffers_iterator&lt;buffers_type&gt; iterator;</a>
<a name="ln485">            buffers_type data_buffers = buffers_.data();</a>
<a name="ln486">            iterator begin = iterator::begin(data_buffers);</a>
<a name="ln487">            iterator start_pos = begin + search_position_;</a>
<a name="ln488">            iterator end = iterator::end(data_buffers);</a>
<a name="ln489"> </a>
<a name="ln490">            // Look for a match.</a>
<a name="ln491">            iterator iter = std::find(start_pos, end, delim_);</a>
<a name="ln492">            if (iter != end)</a>
<a name="ln493">            {</a>
<a name="ln494">              // Found a match. We're done.</a>
<a name="ln495">              search_position_ = iter - begin + 1;</a>
<a name="ln496">              bytes_to_read = 0;</a>
<a name="ln497">            }</a>
<a name="ln498"> </a>
<a name="ln499">            // No match yet. Check if buffer is full.</a>
<a name="ln500">            else if (buffers_.size() == buffers_.max_size())</a>
<a name="ln501">            {</a>
<a name="ln502">              search_position_ = not_found;</a>
<a name="ln503">              bytes_to_read = 0;</a>
<a name="ln504">            }</a>
<a name="ln505"> </a>
<a name="ln506">            // Need to read some more data.</a>
<a name="ln507">            else</a>
<a name="ln508">            {</a>
<a name="ln509">              // Next search can start with the new data.</a>
<a name="ln510">              search_position_ = end - begin;</a>
<a name="ln511">              bytes_to_read = std::min&lt;std::size_t&gt;(</a>
<a name="ln512">                    std::max&lt;std::size_t&gt;(512,</a>
<a name="ln513">                      buffers_.capacity() - buffers_.size()),</a>
<a name="ln514">                    std::min&lt;std::size_t&gt;(65536,</a>
<a name="ln515">                      buffers_.max_size() - buffers_.size()));</a>
<a name="ln516">            }</a>
<a name="ln517">          }</a>
<a name="ln518"> </a>
<a name="ln519">          // Check if we're done.</a>
<a name="ln520">          if (!start &amp;&amp; bytes_to_read == 0)</a>
<a name="ln521">            break;</a>
<a name="ln522"> </a>
<a name="ln523">          // Start a new asynchronous read operation to obtain more data.</a>
<a name="ln524">          stream_.async_read_some(buffers_.prepare(bytes_to_read),</a>
<a name="ln525">              BOOST_ASIO_MOVE_CAST(read_until_delim_op)(*this));</a>
<a name="ln526">          return; default:</a>
<a name="ln527">          buffers_.commit(bytes_transferred);</a>
<a name="ln528">          if (ec || bytes_transferred == 0)</a>
<a name="ln529">            break;</a>
<a name="ln530">        }</a>
<a name="ln531"> </a>
<a name="ln532">        const boost::system::error_code result_ec =</a>
<a name="ln533">          (search_position_ == not_found)</a>
<a name="ln534">          ? error::not_found : ec;</a>
<a name="ln535"> </a>
<a name="ln536">        const std::size_t result_n =</a>
<a name="ln537">          (ec || search_position_ == not_found)</a>
<a name="ln538">          ? 0 : search_position_;</a>
<a name="ln539"> </a>
<a name="ln540">        handler_(result_ec, result_n);</a>
<a name="ln541">      }</a>
<a name="ln542">    }</a>
<a name="ln543"> </a>
<a name="ln544">  //private:</a>
<a name="ln545">    AsyncReadStream&amp; stream_;</a>
<a name="ln546">    DynamicBuffer buffers_;</a>
<a name="ln547">    char delim_;</a>
<a name="ln548">    int start_;</a>
<a name="ln549">    std::size_t search_position_;</a>
<a name="ln550">    ReadHandler handler_;</a>
<a name="ln551">  };</a>
<a name="ln552"> </a>
<a name="ln553">  template &lt;typename AsyncReadStream,</a>
<a name="ln554">      typename DynamicBuffer, typename ReadHandler&gt;</a>
<a name="ln555">  inline void* asio_handler_allocate(std::size_t size,</a>
<a name="ln556">      read_until_delim_op&lt;AsyncReadStream,</a>
<a name="ln557">        DynamicBuffer, ReadHandler&gt;* this_handler)</a>
<a name="ln558">  {</a>
<a name="ln559">    return boost_asio_handler_alloc_helpers::allocate(</a>
<a name="ln560">        size, this_handler-&gt;handler_);</a>
<a name="ln561">  }</a>
<a name="ln562"> </a>
<a name="ln563">  template &lt;typename AsyncReadStream,</a>
<a name="ln564">      typename DynamicBuffer, typename ReadHandler&gt;</a>
<a name="ln565">  inline void asio_handler_deallocate(void* pointer, std::size_t size,</a>
<a name="ln566">      read_until_delim_op&lt;AsyncReadStream,</a>
<a name="ln567">        DynamicBuffer, ReadHandler&gt;* this_handler)</a>
<a name="ln568">  {</a>
<a name="ln569">    boost_asio_handler_alloc_helpers::deallocate(</a>
<a name="ln570">        pointer, size, this_handler-&gt;handler_);</a>
<a name="ln571">  }</a>
<a name="ln572"> </a>
<a name="ln573">  template &lt;typename AsyncReadStream,</a>
<a name="ln574">      typename DynamicBuffer, typename ReadHandler&gt;</a>
<a name="ln575">  inline bool asio_handler_is_continuation(</a>
<a name="ln576">      read_until_delim_op&lt;AsyncReadStream,</a>
<a name="ln577">        DynamicBuffer, ReadHandler&gt;* this_handler)</a>
<a name="ln578">  {</a>
<a name="ln579">    return this_handler-&gt;start_ == 0 ? true</a>
<a name="ln580">      : boost_asio_handler_cont_helpers::is_continuation(</a>
<a name="ln581">          this_handler-&gt;handler_);</a>
<a name="ln582">  }</a>
<a name="ln583"> </a>
<a name="ln584">  template &lt;typename Function, typename AsyncReadStream,</a>
<a name="ln585">      typename DynamicBuffer, typename ReadHandler&gt;</a>
<a name="ln586">  inline void asio_handler_invoke(Function&amp; function,</a>
<a name="ln587">      read_until_delim_op&lt;AsyncReadStream,</a>
<a name="ln588">        DynamicBuffer, ReadHandler&gt;* this_handler)</a>
<a name="ln589">  {</a>
<a name="ln590">    boost_asio_handler_invoke_helpers::invoke(</a>
<a name="ln591">        function, this_handler-&gt;handler_);</a>
<a name="ln592">  }</a>
<a name="ln593"> </a>
<a name="ln594">  template &lt;typename Function, typename AsyncReadStream,</a>
<a name="ln595">      typename DynamicBuffer, typename ReadHandler&gt;</a>
<a name="ln596">  inline void asio_handler_invoke(const Function&amp; function,</a>
<a name="ln597">      read_until_delim_op&lt;AsyncReadStream,</a>
<a name="ln598">        DynamicBuffer, ReadHandler&gt;* this_handler)</a>
<a name="ln599">  {</a>
<a name="ln600">    boost_asio_handler_invoke_helpers::invoke(</a>
<a name="ln601">        function, this_handler-&gt;handler_);</a>
<a name="ln602">  }</a>
<a name="ln603">} // namespace detail</a>
<a name="ln604"> </a>
<a name="ln605">#if !defined(GENERATING_DOCUMENTATION)</a>
<a name="ln606"> </a>
<a name="ln607">template &lt;typename AsyncReadStream, typename DynamicBuffer,</a>
<a name="ln608">    typename ReadHandler, typename Allocator&gt;</a>
<a name="ln609">struct associated_allocator&lt;</a>
<a name="ln610">    detail::read_until_delim_op&lt;AsyncReadStream,</a>
<a name="ln611">      DynamicBuffer, ReadHandler&gt;,</a>
<a name="ln612">    Allocator&gt;</a>
<a name="ln613">{</a>
<a name="ln614">  typedef typename associated_allocator&lt;ReadHandler, Allocator&gt;::type type;</a>
<a name="ln615"> </a>
<a name="ln616">  static type get(</a>
<a name="ln617">      const detail::read_until_delim_op&lt;AsyncReadStream,</a>
<a name="ln618">        DynamicBuffer, ReadHandler&gt;&amp; h,</a>
<a name="ln619">      const Allocator&amp; a = Allocator()) BOOST_ASIO_NOEXCEPT</a>
<a name="ln620">  {</a>
<a name="ln621">    return associated_allocator&lt;ReadHandler, Allocator&gt;::get(h.handler_, a);</a>
<a name="ln622">  }</a>
<a name="ln623">};</a>
<a name="ln624"> </a>
<a name="ln625">template &lt;typename AsyncReadStream, typename DynamicBuffer,</a>
<a name="ln626">    typename ReadHandler, typename Executor&gt;</a>
<a name="ln627">struct associated_executor&lt;</a>
<a name="ln628">    detail::read_until_delim_op&lt;AsyncReadStream,</a>
<a name="ln629">      DynamicBuffer, ReadHandler&gt;,</a>
<a name="ln630">    Executor&gt;</a>
<a name="ln631">{</a>
<a name="ln632">  typedef typename associated_executor&lt;ReadHandler, Executor&gt;::type type;</a>
<a name="ln633"> </a>
<a name="ln634">  static type get(</a>
<a name="ln635">      const detail::read_until_delim_op&lt;AsyncReadStream,</a>
<a name="ln636">        DynamicBuffer, ReadHandler&gt;&amp; h,</a>
<a name="ln637">      const Executor&amp; ex = Executor()) BOOST_ASIO_NOEXCEPT</a>
<a name="ln638">  {</a>
<a name="ln639">    return associated_executor&lt;ReadHandler, Executor&gt;::get(h.handler_, ex);</a>
<a name="ln640">  }</a>
<a name="ln641">};</a>
<a name="ln642"> </a>
<a name="ln643">#endif // !defined(GENERATING_DOCUMENTATION)</a>
<a name="ln644"> </a>
<a name="ln645">template &lt;typename AsyncReadStream,</a>
<a name="ln646">    typename DynamicBuffer, typename ReadHandler&gt;</a>
<a name="ln647">BOOST_ASIO_INITFN_RESULT_TYPE(ReadHandler,</a>
<a name="ln648">    void (boost::system::error_code, std::size_t))</a>
<a name="ln649">async_read_until(AsyncReadStream&amp; s,</a>
<a name="ln650">    BOOST_ASIO_MOVE_ARG(DynamicBuffer) buffers,</a>
<a name="ln651">    char delim, BOOST_ASIO_MOVE_ARG(ReadHandler) handler)</a>
<a name="ln652">{</a>
<a name="ln653">  // If you get an error on the following line it means that your handler does</a>
<a name="ln654">  // not meet the documented type requirements for a ReadHandler.</a>
<a name="ln655">  BOOST_ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;</a>
<a name="ln656"> </a>
<a name="ln657">  async_completion&lt;ReadHandler,</a>
<a name="ln658">    void (boost::system::error_code, std::size_t)&gt; init(handler);</a>
<a name="ln659"> </a>
<a name="ln660">  detail::read_until_delim_op&lt;AsyncReadStream,</a>
<a name="ln661">    typename decay&lt;DynamicBuffer&gt;::type,</a>
<a name="ln662">      BOOST_ASIO_HANDLER_TYPE(ReadHandler,</a>
<a name="ln663">        void (boost::system::error_code, std::size_t))&gt;(</a>
<a name="ln664">          s, BOOST_ASIO_MOVE_CAST(DynamicBuffer)(buffers),</a>
<a name="ln665">            delim, init.completion_handler)(boost::system::error_code(), 0, 1);</a>
<a name="ln666"> </a>
<a name="ln667">  return init.result.get();</a>
<a name="ln668">}</a>
<a name="ln669"> </a>
<a name="ln670">namespace detail</a>
<a name="ln671">{</a>
<a name="ln672">  template &lt;typename AsyncReadStream,</a>
<a name="ln673">      typename DynamicBuffer, typename ReadHandler&gt;</a>
<a name="ln674">  class read_until_delim_string_op</a>
<a name="ln675">  {</a>
<a name="ln676">  public:</a>
<a name="ln677">    template &lt;typename BufferSequence&gt;</a>
<a name="ln678">    read_until_delim_string_op(AsyncReadStream&amp; stream,</a>
<a name="ln679">        BOOST_ASIO_MOVE_ARG(BufferSequence) buffers,</a>
<a name="ln680">        const std::string&amp; delim, ReadHandler&amp; handler)</a>
<a name="ln681">      : stream_(stream),</a>
<a name="ln682">        buffers_(BOOST_ASIO_MOVE_CAST(BufferSequence)(buffers)),</a>
<a name="ln683">        delim_(delim),</a>
<a name="ln684">        start_(0),</a>
<a name="ln685">        search_position_(0),</a>
<a name="ln686">        handler_(BOOST_ASIO_MOVE_CAST(ReadHandler)(handler))</a>
<a name="ln687">    {</a>
<a name="ln688">    }</a>
<a name="ln689"> </a>
<a name="ln690">#if defined(BOOST_ASIO_HAS_MOVE)</a>
<a name="ln691">    read_until_delim_string_op(const read_until_delim_string_op&amp; other)</a>
<a name="ln692">      : stream_(other.stream_),</a>
<a name="ln693">        buffers_(other.buffers_),</a>
<a name="ln694">        delim_(other.delim_),</a>
<a name="ln695">        start_(other.start_),</a>
<a name="ln696">        search_position_(other.search_position_),</a>
<a name="ln697">        handler_(other.handler_)</a>
<a name="ln698">    {</a>
<a name="ln699">    }</a>
<a name="ln700"> </a>
<a name="ln701">    read_until_delim_string_op(read_until_delim_string_op&amp;&amp; other)</a>
<a name="ln702">      : stream_(other.stream_),</a>
<a name="ln703">        buffers_(BOOST_ASIO_MOVE_CAST(DynamicBuffer)(other.buffers_)),</a>
<a name="ln704">        delim_(BOOST_ASIO_MOVE_CAST(std::string)(other.delim_)),</a>
<a name="ln705">        start_(other.start_),</a>
<a name="ln706">        search_position_(other.search_position_),</a>
<a name="ln707">        handler_(BOOST_ASIO_MOVE_CAST(ReadHandler)(other.handler_))</a>
<a name="ln708">    {</a>
<a name="ln709">    }</a>
<a name="ln710">#endif // defined(BOOST_ASIO_HAS_MOVE)</a>
<a name="ln711"> </a>
<a name="ln712">    void operator()(const boost::system::error_code&amp; ec,</a>
<a name="ln713">        std::size_t bytes_transferred, int start = 0)</a>
<a name="ln714">    {</a>
<a name="ln715">      const std::size_t not_found = (std::numeric_limits&lt;std::size_t&gt;::max)();</a>
<a name="ln716">      std::size_t bytes_to_read;</a>
<a name="ln717">      switch (start_ = start)</a>
<a name="ln718">      {</a>
<a name="ln719">      case 1:</a>
<a name="ln720">        for (;;)</a>
<a name="ln721">        {</a>
<a name="ln722">          {</a>
<a name="ln723">            // Determine the range of the data to be searched.</a>
<a name="ln724">            typedef typename DynamicBuffer::const_buffers_type</a>
<a name="ln725">              buffers_type;</a>
<a name="ln726">            typedef buffers_iterator&lt;buffers_type&gt; iterator;</a>
<a name="ln727">            buffers_type data_buffers = buffers_.data();</a>
<a name="ln728">            iterator begin = iterator::begin(data_buffers);</a>
<a name="ln729">            iterator start_pos = begin + search_position_;</a>
<a name="ln730">            iterator end = iterator::end(data_buffers);</a>
<a name="ln731"> </a>
<a name="ln732">            // Look for a match.</a>
<a name="ln733">            std::pair&lt;iterator, bool&gt; result = detail::partial_search(</a>
<a name="ln734">                start_pos, end, delim_.begin(), delim_.end());</a>
<a name="ln735">            if (result.first != end &amp;&amp; result.second)</a>
<a name="ln736">            {</a>
<a name="ln737">              // Full match. We're done.</a>
<a name="ln738">              search_position_ = result.first - begin + delim_.length();</a>
<a name="ln739">              bytes_to_read = 0;</a>
<a name="ln740">            }</a>
<a name="ln741"> </a>
<a name="ln742">            // No match yet. Check if buffer is full.</a>
<a name="ln743">            else if (buffers_.size() == buffers_.max_size())</a>
<a name="ln744">            {</a>
<a name="ln745">              search_position_ = not_found;</a>
<a name="ln746">              bytes_to_read = 0;</a>
<a name="ln747">            }</a>
<a name="ln748"> </a>
<a name="ln749">            // Need to read some more data.</a>
<a name="ln750">            else</a>
<a name="ln751">            {</a>
<a name="ln752">              if (result.first != end)</a>
<a name="ln753">              {</a>
<a name="ln754">                // Partial match. Next search needs to start from beginning of</a>
<a name="ln755">                // match.</a>
<a name="ln756">                search_position_ = result.first - begin;</a>
<a name="ln757">              }</a>
<a name="ln758">              else</a>
<a name="ln759">              {</a>
<a name="ln760">                // Next search can start with the new data.</a>
<a name="ln761">                search_position_ = end - begin;</a>
<a name="ln762">              }</a>
<a name="ln763"> </a>
<a name="ln764">              bytes_to_read = std::min&lt;std::size_t&gt;(</a>
<a name="ln765">                    std::max&lt;std::size_t&gt;(512,</a>
<a name="ln766">                      buffers_.capacity() - buffers_.size()),</a>
<a name="ln767">                    std::min&lt;std::size_t&gt;(65536,</a>
<a name="ln768">                      buffers_.max_size() - buffers_.size()));</a>
<a name="ln769">            }</a>
<a name="ln770">          }</a>
<a name="ln771"> </a>
<a name="ln772">          // Check if we're done.</a>
<a name="ln773">          if (!start &amp;&amp; bytes_to_read == 0)</a>
<a name="ln774">            break;</a>
<a name="ln775"> </a>
<a name="ln776">          // Start a new asynchronous read operation to obtain more data.</a>
<a name="ln777">          stream_.async_read_some(buffers_.prepare(bytes_to_read),</a>
<a name="ln778">              BOOST_ASIO_MOVE_CAST(read_until_delim_string_op)(*this));</a>
<a name="ln779">          return; default:</a>
<a name="ln780">          buffers_.commit(bytes_transferred);</a>
<a name="ln781">          if (ec || bytes_transferred == 0)</a>
<a name="ln782">            break;</a>
<a name="ln783">        }</a>
<a name="ln784"> </a>
<a name="ln785">        const boost::system::error_code result_ec =</a>
<a name="ln786">          (search_position_ == not_found)</a>
<a name="ln787">          ? error::not_found : ec;</a>
<a name="ln788"> </a>
<a name="ln789">        const std::size_t result_n =</a>
<a name="ln790">          (ec || search_position_ == not_found)</a>
<a name="ln791">          ? 0 : search_position_;</a>
<a name="ln792"> </a>
<a name="ln793">        handler_(result_ec, result_n);</a>
<a name="ln794">      }</a>
<a name="ln795">    }</a>
<a name="ln796"> </a>
<a name="ln797">  //private:</a>
<a name="ln798">    AsyncReadStream&amp; stream_;</a>
<a name="ln799">    DynamicBuffer buffers_;</a>
<a name="ln800">    std::string delim_;</a>
<a name="ln801">    int start_;</a>
<a name="ln802">    std::size_t search_position_;</a>
<a name="ln803">    ReadHandler handler_;</a>
<a name="ln804">  };</a>
<a name="ln805"> </a>
<a name="ln806">  template &lt;typename AsyncReadStream,</a>
<a name="ln807">      typename DynamicBuffer, typename ReadHandler&gt;</a>
<a name="ln808">  inline void* asio_handler_allocate(std::size_t size,</a>
<a name="ln809">      read_until_delim_string_op&lt;AsyncReadStream,</a>
<a name="ln810">        DynamicBuffer, ReadHandler&gt;* this_handler)</a>
<a name="ln811">  {</a>
<a name="ln812">    return boost_asio_handler_alloc_helpers::allocate(</a>
<a name="ln813">        size, this_handler-&gt;handler_);</a>
<a name="ln814">  }</a>
<a name="ln815"> </a>
<a name="ln816">  template &lt;typename AsyncReadStream,</a>
<a name="ln817">      typename DynamicBuffer, typename ReadHandler&gt;</a>
<a name="ln818">  inline void asio_handler_deallocate(void* pointer, std::size_t size,</a>
<a name="ln819">      read_until_delim_string_op&lt;AsyncReadStream,</a>
<a name="ln820">        DynamicBuffer, ReadHandler&gt;* this_handler)</a>
<a name="ln821">  {</a>
<a name="ln822">    boost_asio_handler_alloc_helpers::deallocate(</a>
<a name="ln823">        pointer, size, this_handler-&gt;handler_);</a>
<a name="ln824">  }</a>
<a name="ln825"> </a>
<a name="ln826">  template &lt;typename AsyncReadStream,</a>
<a name="ln827">      typename DynamicBuffer, typename ReadHandler&gt;</a>
<a name="ln828">  inline bool asio_handler_is_continuation(</a>
<a name="ln829">      read_until_delim_string_op&lt;AsyncReadStream,</a>
<a name="ln830">        DynamicBuffer, ReadHandler&gt;* this_handler)</a>
<a name="ln831">  {</a>
<a name="ln832">    return this_handler-&gt;start_ == 0 ? true</a>
<a name="ln833">      : boost_asio_handler_cont_helpers::is_continuation(</a>
<a name="ln834">          this_handler-&gt;handler_);</a>
<a name="ln835">  }</a>
<a name="ln836"> </a>
<a name="ln837">  template &lt;typename Function, typename AsyncReadStream,</a>
<a name="ln838">      typename DynamicBuffer, typename ReadHandler&gt;</a>
<a name="ln839">  inline void asio_handler_invoke(Function&amp; function,</a>
<a name="ln840">      read_until_delim_string_op&lt;AsyncReadStream,</a>
<a name="ln841">        DynamicBuffer, ReadHandler&gt;* this_handler)</a>
<a name="ln842">  {</a>
<a name="ln843">    boost_asio_handler_invoke_helpers::invoke(</a>
<a name="ln844">        function, this_handler-&gt;handler_);</a>
<a name="ln845">  }</a>
<a name="ln846"> </a>
<a name="ln847">  template &lt;typename Function, typename AsyncReadStream,</a>
<a name="ln848">      typename DynamicBuffer, typename ReadHandler&gt;</a>
<a name="ln849">  inline void asio_handler_invoke(const Function&amp; function,</a>
<a name="ln850">      read_until_delim_string_op&lt;AsyncReadStream,</a>
<a name="ln851">        DynamicBuffer, ReadHandler&gt;* this_handler)</a>
<a name="ln852">  {</a>
<a name="ln853">    boost_asio_handler_invoke_helpers::invoke(</a>
<a name="ln854">        function, this_handler-&gt;handler_);</a>
<a name="ln855">  }</a>
<a name="ln856">} // namespace detail</a>
<a name="ln857"> </a>
<a name="ln858">#if !defined(GENERATING_DOCUMENTATION)</a>
<a name="ln859"> </a>
<a name="ln860">template &lt;typename AsyncReadStream, typename DynamicBuffer,</a>
<a name="ln861">    typename ReadHandler, typename Allocator&gt;</a>
<a name="ln862">struct associated_allocator&lt;</a>
<a name="ln863">    detail::read_until_delim_string_op&lt;AsyncReadStream,</a>
<a name="ln864">      DynamicBuffer, ReadHandler&gt;,</a>
<a name="ln865">    Allocator&gt;</a>
<a name="ln866">{</a>
<a name="ln867">  typedef typename associated_allocator&lt;ReadHandler, Allocator&gt;::type type;</a>
<a name="ln868"> </a>
<a name="ln869">  static type get(</a>
<a name="ln870">      const detail::read_until_delim_string_op&lt;AsyncReadStream,</a>
<a name="ln871">        DynamicBuffer, ReadHandler&gt;&amp; h,</a>
<a name="ln872">      const Allocator&amp; a = Allocator()) BOOST_ASIO_NOEXCEPT</a>
<a name="ln873">  {</a>
<a name="ln874">    return associated_allocator&lt;ReadHandler, Allocator&gt;::get(h.handler_, a);</a>
<a name="ln875">  }</a>
<a name="ln876">};</a>
<a name="ln877"> </a>
<a name="ln878">template &lt;typename AsyncReadStream, typename DynamicBuffer,</a>
<a name="ln879">    typename ReadHandler, typename Executor&gt;</a>
<a name="ln880">struct associated_executor&lt;</a>
<a name="ln881">    detail::read_until_delim_string_op&lt;AsyncReadStream,</a>
<a name="ln882">      DynamicBuffer, ReadHandler&gt;,</a>
<a name="ln883">    Executor&gt;</a>
<a name="ln884">{</a>
<a name="ln885">  typedef typename associated_executor&lt;ReadHandler, Executor&gt;::type type;</a>
<a name="ln886"> </a>
<a name="ln887">  static type get(</a>
<a name="ln888">      const detail::read_until_delim_string_op&lt;AsyncReadStream,</a>
<a name="ln889">        DynamicBuffer, ReadHandler&gt;&amp; h,</a>
<a name="ln890">      const Executor&amp; ex = Executor()) BOOST_ASIO_NOEXCEPT</a>
<a name="ln891">  {</a>
<a name="ln892">    return associated_executor&lt;ReadHandler, Executor&gt;::get(h.handler_, ex);</a>
<a name="ln893">  }</a>
<a name="ln894">};</a>
<a name="ln895"> </a>
<a name="ln896">#endif // !defined(GENERATING_DOCUMENTATION)</a>
<a name="ln897"> </a>
<a name="ln898">template &lt;typename AsyncReadStream,</a>
<a name="ln899">    typename DynamicBuffer, typename ReadHandler&gt;</a>
<a name="ln900">BOOST_ASIO_INITFN_RESULT_TYPE(ReadHandler,</a>
<a name="ln901">    void (boost::system::error_code, std::size_t))</a>
<a name="ln902">async_read_until(AsyncReadStream&amp; s,</a>
<a name="ln903">    BOOST_ASIO_MOVE_ARG(DynamicBuffer) buffers,</a>
<a name="ln904">    BOOST_ASIO_STRING_VIEW_PARAM delim,</a>
<a name="ln905">    BOOST_ASIO_MOVE_ARG(ReadHandler) handler)</a>
<a name="ln906">{</a>
<a name="ln907">  // If you get an error on the following line it means that your handler does</a>
<a name="ln908">  // not meet the documented type requirements for a ReadHandler.</a>
<a name="ln909">  BOOST_ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;</a>
<a name="ln910"> </a>
<a name="ln911">  async_completion&lt;ReadHandler,</a>
<a name="ln912">    void (boost::system::error_code, std::size_t)&gt; init(handler);</a>
<a name="ln913"> </a>
<a name="ln914">  detail::read_until_delim_string_op&lt;AsyncReadStream,</a>
<a name="ln915">    typename decay&lt;DynamicBuffer&gt;::type,</a>
<a name="ln916">      BOOST_ASIO_HANDLER_TYPE(ReadHandler,</a>
<a name="ln917">        void (boost::system::error_code, std::size_t))&gt;(</a>
<a name="ln918">          s, BOOST_ASIO_MOVE_CAST(DynamicBuffer)(buffers),</a>
<a name="ln919">            static_cast&lt;std::string&gt;(delim),</a>
<a name="ln920">              init.completion_handler)(boost::system::error_code(), 0, 1);</a>
<a name="ln921"> </a>
<a name="ln922">  return init.result.get();</a>
<a name="ln923">}</a>
<a name="ln924"> </a>
<a name="ln925">#if !defined(BOOST_ASIO_NO_EXTENSIONS)</a>
<a name="ln926">#if defined(BOOST_ASIO_HAS_BOOST_REGEX)</a>
<a name="ln927"> </a>
<a name="ln928">namespace detail</a>
<a name="ln929">{</a>
<a name="ln930">  template &lt;typename AsyncReadStream, typename DynamicBuffer,</a>
<a name="ln931">      typename RegEx, typename ReadHandler&gt;</a>
<a name="ln932">  class read_until_expr_op</a>
<a name="ln933">  {</a>
<a name="ln934">  public:</a>
<a name="ln935">    template &lt;typename BufferSequence&gt;</a>
<a name="ln936">    read_until_expr_op(AsyncReadStream&amp; stream,</a>
<a name="ln937">        BOOST_ASIO_MOVE_ARG(BufferSequence) buffers,</a>
<a name="ln938">        const boost::regex&amp; expr, ReadHandler&amp; handler)</a>
<a name="ln939">      : stream_(stream),</a>
<a name="ln940">        buffers_(BOOST_ASIO_MOVE_CAST(BufferSequence)(buffers)),</a>
<a name="ln941">        expr_(expr),</a>
<a name="ln942">        start_(0),</a>
<a name="ln943">        search_position_(0),</a>
<a name="ln944">        handler_(BOOST_ASIO_MOVE_CAST(ReadHandler)(handler))</a>
<a name="ln945">    {</a>
<a name="ln946">    }</a>
<a name="ln947"> </a>
<a name="ln948">#if defined(BOOST_ASIO_HAS_MOVE)</a>
<a name="ln949">    read_until_expr_op(const read_until_expr_op&amp; other)</a>
<a name="ln950">      : stream_(other.stream_),</a>
<a name="ln951">        buffers_(other.buffers_),</a>
<a name="ln952">        expr_(other.expr_),</a>
<a name="ln953">        start_(other.start_),</a>
<a name="ln954">        search_position_(other.search_position_),</a>
<a name="ln955">        handler_(other.handler_)</a>
<a name="ln956">    {</a>
<a name="ln957">    }</a>
<a name="ln958"> </a>
<a name="ln959">    read_until_expr_op(read_until_expr_op&amp;&amp; other)</a>
<a name="ln960">      : stream_(other.stream_),</a>
<a name="ln961">        buffers_(BOOST_ASIO_MOVE_CAST(DynamicBuffer)(other.buffers_)),</a>
<a name="ln962">        expr_(other.expr_),</a>
<a name="ln963">        start_(other.start_),</a>
<a name="ln964">        search_position_(other.search_position_),</a>
<a name="ln965">        handler_(BOOST_ASIO_MOVE_CAST(ReadHandler)(other.handler_))</a>
<a name="ln966">    {</a>
<a name="ln967">    }</a>
<a name="ln968">#endif // defined(BOOST_ASIO_HAS_MOVE)</a>
<a name="ln969"> </a>
<a name="ln970">    void operator()(const boost::system::error_code&amp; ec,</a>
<a name="ln971">        std::size_t bytes_transferred, int start = 0)</a>
<a name="ln972">    {</a>
<a name="ln973">      const std::size_t not_found = (std::numeric_limits&lt;std::size_t&gt;::max)();</a>
<a name="ln974">      std::size_t bytes_to_read;</a>
<a name="ln975">      switch (start_ = start)</a>
<a name="ln976">      {</a>
<a name="ln977">      case 1:</a>
<a name="ln978">        for (;;)</a>
<a name="ln979">        {</a>
<a name="ln980">          {</a>
<a name="ln981">            // Determine the range of the data to be searched.</a>
<a name="ln982">            typedef typename DynamicBuffer::const_buffers_type</a>
<a name="ln983">              buffers_type;</a>
<a name="ln984">            typedef buffers_iterator&lt;buffers_type&gt; iterator;</a>
<a name="ln985">            buffers_type data_buffers = buffers_.data();</a>
<a name="ln986">            iterator begin = iterator::begin(data_buffers);</a>
<a name="ln987">            iterator start_pos = begin + search_position_;</a>
<a name="ln988">            iterator end = iterator::end(data_buffers);</a>
<a name="ln989"> </a>
<a name="ln990">            // Look for a match.</a>
<a name="ln991">            boost::match_results&lt;iterator,</a>
<a name="ln992">              typename std::vector&lt;boost::sub_match&lt;iterator&gt; &gt;::allocator_type&gt;</a>
<a name="ln993">                match_results;</a>
<a name="ln994">            bool match = regex_search(start_pos, end, match_results, expr_,</a>
<a name="ln995">                boost::match_default | boost::match_partial);</a>
<a name="ln996">            if (match &amp;&amp; match_results[0].matched)</a>
<a name="ln997">            {</a>
<a name="ln998">              // Full match. We're done.</a>
<a name="ln999">              search_position_ = match_results[0].second - begin;</a>
<a name="ln1000">              bytes_to_read = 0;</a>
<a name="ln1001">            }</a>
<a name="ln1002"> </a>
<a name="ln1003">            // No match yet. Check if buffer is full.</a>
<a name="ln1004">            else if (buffers_.size() == buffers_.max_size())</a>
<a name="ln1005">            {</a>
<a name="ln1006">              search_position_ = not_found;</a>
<a name="ln1007">              bytes_to_read = 0;</a>
<a name="ln1008">            }</a>
<a name="ln1009"> </a>
<a name="ln1010">            // Need to read some more data.</a>
<a name="ln1011">            else</a>
<a name="ln1012">            {</a>
<a name="ln1013">              if (match)</a>
<a name="ln1014">              {</a>
<a name="ln1015">                // Partial match. Next search needs to start from beginning of</a>
<a name="ln1016">                // match.</a>
<a name="ln1017">                search_position_ = match_results[0].first - begin;</a>
<a name="ln1018">              }</a>
<a name="ln1019">              else</a>
<a name="ln1020">              {</a>
<a name="ln1021">                // Next search can start with the new data.</a>
<a name="ln1022">                search_position_ = end - begin;</a>
<a name="ln1023">              }</a>
<a name="ln1024"> </a>
<a name="ln1025">              bytes_to_read = std::min&lt;std::size_t&gt;(</a>
<a name="ln1026">                    std::max&lt;std::size_t&gt;(512,</a>
<a name="ln1027">                      buffers_.capacity() - buffers_.size()),</a>
<a name="ln1028">                    std::min&lt;std::size_t&gt;(65536,</a>
<a name="ln1029">                      buffers_.max_size() - buffers_.size()));</a>
<a name="ln1030">            }</a>
<a name="ln1031">          }</a>
<a name="ln1032"> </a>
<a name="ln1033">          // Check if we're done.</a>
<a name="ln1034">          if (!start &amp;&amp; bytes_to_read == 0)</a>
<a name="ln1035">            break;</a>
<a name="ln1036"> </a>
<a name="ln1037">          // Start a new asynchronous read operation to obtain more data.</a>
<a name="ln1038">          stream_.async_read_some(buffers_.prepare(bytes_to_read),</a>
<a name="ln1039">              BOOST_ASIO_MOVE_CAST(read_until_expr_op)(*this));</a>
<a name="ln1040">          return; default:</a>
<a name="ln1041">          buffers_.commit(bytes_transferred);</a>
<a name="ln1042">          if (ec || bytes_transferred == 0)</a>
<a name="ln1043">            break;</a>
<a name="ln1044">        }</a>
<a name="ln1045"> </a>
<a name="ln1046">        const boost::system::error_code result_ec =</a>
<a name="ln1047">          (search_position_ == not_found)</a>
<a name="ln1048">          ? error::not_found : ec;</a>
<a name="ln1049"> </a>
<a name="ln1050">        const std::size_t result_n =</a>
<a name="ln1051">          (ec || search_position_ == not_found)</a>
<a name="ln1052">          ? 0 : search_position_;</a>
<a name="ln1053"> </a>
<a name="ln1054">        handler_(result_ec, result_n);</a>
<a name="ln1055">      }</a>
<a name="ln1056">    }</a>
<a name="ln1057"> </a>
<a name="ln1058">  //private:</a>
<a name="ln1059">    AsyncReadStream&amp; stream_;</a>
<a name="ln1060">    DynamicBuffer buffers_;</a>
<a name="ln1061">    RegEx expr_;</a>
<a name="ln1062">    int start_;</a>
<a name="ln1063">    std::size_t search_position_;</a>
<a name="ln1064">    ReadHandler handler_;</a>
<a name="ln1065">  };</a>
<a name="ln1066"> </a>
<a name="ln1067">  template &lt;typename AsyncReadStream, typename DynamicBuffer,</a>
<a name="ln1068">      typename RegEx, typename ReadHandler&gt;</a>
<a name="ln1069">  inline void* asio_handler_allocate(std::size_t size,</a>
<a name="ln1070">      read_until_expr_op&lt;AsyncReadStream,</a>
<a name="ln1071">        DynamicBuffer, RegEx, ReadHandler&gt;* this_handler)</a>
<a name="ln1072">  {</a>
<a name="ln1073">    return boost_asio_handler_alloc_helpers::allocate(</a>
<a name="ln1074">        size, this_handler-&gt;handler_);</a>
<a name="ln1075">  }</a>
<a name="ln1076"> </a>
<a name="ln1077">  template &lt;typename AsyncReadStream, typename DynamicBuffer,</a>
<a name="ln1078">      typename RegEx, typename ReadHandler&gt;</a>
<a name="ln1079">  inline void asio_handler_deallocate(void* pointer, std::size_t size,</a>
<a name="ln1080">      read_until_expr_op&lt;AsyncReadStream,</a>
<a name="ln1081">        DynamicBuffer, RegEx, ReadHandler&gt;* this_handler)</a>
<a name="ln1082">  {</a>
<a name="ln1083">    boost_asio_handler_alloc_helpers::deallocate(</a>
<a name="ln1084">        pointer, size, this_handler-&gt;handler_);</a>
<a name="ln1085">  }</a>
<a name="ln1086"> </a>
<a name="ln1087">  template &lt;typename AsyncReadStream, typename DynamicBuffer,</a>
<a name="ln1088">      typename RegEx, typename ReadHandler&gt;</a>
<a name="ln1089">  inline bool asio_handler_is_continuation(</a>
<a name="ln1090">      read_until_expr_op&lt;AsyncReadStream,</a>
<a name="ln1091">        DynamicBuffer, RegEx, ReadHandler&gt;* this_handler)</a>
<a name="ln1092">  {</a>
<a name="ln1093">    return this_handler-&gt;start_ == 0 ? true</a>
<a name="ln1094">      : boost_asio_handler_cont_helpers::is_continuation(</a>
<a name="ln1095">          this_handler-&gt;handler_);</a>
<a name="ln1096">  }</a>
<a name="ln1097"> </a>
<a name="ln1098">  template &lt;typename Function, typename AsyncReadStream,</a>
<a name="ln1099">      typename DynamicBuffer, typename RegEx, typename ReadHandler&gt;</a>
<a name="ln1100">  inline void asio_handler_invoke(Function&amp; function,</a>
<a name="ln1101">      read_until_expr_op&lt;AsyncReadStream,</a>
<a name="ln1102">        DynamicBuffer, RegEx, ReadHandler&gt;* this_handler)</a>
<a name="ln1103">  {</a>
<a name="ln1104">    boost_asio_handler_invoke_helpers::invoke(</a>
<a name="ln1105">        function, this_handler-&gt;handler_);</a>
<a name="ln1106">  }</a>
<a name="ln1107"> </a>
<a name="ln1108">  template &lt;typename Function, typename AsyncReadStream,</a>
<a name="ln1109">      typename DynamicBuffer, typename RegEx, typename ReadHandler&gt;</a>
<a name="ln1110">  inline void asio_handler_invoke(const Function&amp; function,</a>
<a name="ln1111">      read_until_expr_op&lt;AsyncReadStream,</a>
<a name="ln1112">        DynamicBuffer, RegEx, ReadHandler&gt;* this_handler)</a>
<a name="ln1113">  {</a>
<a name="ln1114">    boost_asio_handler_invoke_helpers::invoke(</a>
<a name="ln1115">        function, this_handler-&gt;handler_);</a>
<a name="ln1116">  }</a>
<a name="ln1117">} // namespace detail</a>
<a name="ln1118"> </a>
<a name="ln1119">#if !defined(GENERATING_DOCUMENTATION)</a>
<a name="ln1120"> </a>
<a name="ln1121">template &lt;typename AsyncReadStream, typename DynamicBuffer,</a>
<a name="ln1122">    typename RegEx, typename ReadHandler, typename Allocator&gt;</a>
<a name="ln1123">struct associated_allocator&lt;</a>
<a name="ln1124">    detail::read_until_expr_op&lt;AsyncReadStream,</a>
<a name="ln1125">      DynamicBuffer, RegEx, ReadHandler&gt;,</a>
<a name="ln1126">    Allocator&gt;</a>
<a name="ln1127">{</a>
<a name="ln1128">  typedef typename associated_allocator&lt;ReadHandler, Allocator&gt;::type type;</a>
<a name="ln1129"> </a>
<a name="ln1130">  static type get(</a>
<a name="ln1131">      const detail::read_until_expr_op&lt;AsyncReadStream,</a>
<a name="ln1132">        DynamicBuffer, RegEx, ReadHandler&gt;&amp; h,</a>
<a name="ln1133">      const Allocator&amp; a = Allocator()) BOOST_ASIO_NOEXCEPT</a>
<a name="ln1134">  {</a>
<a name="ln1135">    return associated_allocator&lt;ReadHandler, Allocator&gt;::get(h.handler_, a);</a>
<a name="ln1136">  }</a>
<a name="ln1137">};</a>
<a name="ln1138"> </a>
<a name="ln1139">template &lt;typename AsyncReadStream, typename DynamicBuffer,</a>
<a name="ln1140">    typename RegEx, typename ReadHandler, typename Executor&gt;</a>
<a name="ln1141">struct associated_executor&lt;</a>
<a name="ln1142">    detail::read_until_expr_op&lt;AsyncReadStream,</a>
<a name="ln1143">      DynamicBuffer, RegEx, ReadHandler&gt;,</a>
<a name="ln1144">    Executor&gt;</a>
<a name="ln1145">{</a>
<a name="ln1146">  typedef typename associated_executor&lt;ReadHandler, Executor&gt;::type type;</a>
<a name="ln1147"> </a>
<a name="ln1148">  static type get(</a>
<a name="ln1149">      const detail::read_until_expr_op&lt;AsyncReadStream,</a>
<a name="ln1150">        DynamicBuffer, RegEx, ReadHandler&gt;&amp; h,</a>
<a name="ln1151">      const Executor&amp; ex = Executor()) BOOST_ASIO_NOEXCEPT</a>
<a name="ln1152">  {</a>
<a name="ln1153">    return associated_executor&lt;ReadHandler, Executor&gt;::get(h.handler_, ex);</a>
<a name="ln1154">  }</a>
<a name="ln1155">};</a>
<a name="ln1156"> </a>
<a name="ln1157">#endif // !defined(GENERATING_DOCUMENTATION)</a>
<a name="ln1158"> </a>
<a name="ln1159">template &lt;typename AsyncReadStream,</a>
<a name="ln1160">    typename DynamicBuffer, typename ReadHandler&gt;</a>
<a name="ln1161">BOOST_ASIO_INITFN_RESULT_TYPE(ReadHandler,</a>
<a name="ln1162">    void (boost::system::error_code, std::size_t))</a>
<a name="ln1163">async_read_until(AsyncReadStream&amp; s,</a>
<a name="ln1164">    BOOST_ASIO_MOVE_ARG(DynamicBuffer) buffers,</a>
<a name="ln1165">    const boost::regex&amp; expr,</a>
<a name="ln1166">    BOOST_ASIO_MOVE_ARG(ReadHandler) handler)</a>
<a name="ln1167">{</a>
<a name="ln1168">  // If you get an error on the following line it means that your handler does</a>
<a name="ln1169">  // not meet the documented type requirements for a ReadHandler.</a>
<a name="ln1170">  BOOST_ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;</a>
<a name="ln1171"> </a>
<a name="ln1172">  async_completion&lt;ReadHandler,</a>
<a name="ln1173">    void (boost::system::error_code, std::size_t)&gt; init(handler);</a>
<a name="ln1174"> </a>
<a name="ln1175">  detail::read_until_expr_op&lt;AsyncReadStream,</a>
<a name="ln1176">    typename decay&lt;DynamicBuffer&gt;::type,</a>
<a name="ln1177">      boost::regex, BOOST_ASIO_HANDLER_TYPE(ReadHandler,</a>
<a name="ln1178">        void (boost::system::error_code, std::size_t))&gt;(</a>
<a name="ln1179">          s, BOOST_ASIO_MOVE_CAST(DynamicBuffer)(buffers),</a>
<a name="ln1180">            expr, init.completion_handler)(boost::system::error_code(), 0, 1);</a>
<a name="ln1181"> </a>
<a name="ln1182">  return init.result.get();</a>
<a name="ln1183">}</a>
<a name="ln1184"> </a>
<a name="ln1185">#endif // defined(BOOST_ASIO_HAS_BOOST_REGEX)</a>
<a name="ln1186"> </a>
<a name="ln1187">namespace detail</a>
<a name="ln1188">{</a>
<a name="ln1189">  template &lt;typename AsyncReadStream, typename DynamicBuffer,</a>
<a name="ln1190">      typename MatchCondition, typename ReadHandler&gt;</a>
<a name="ln1191">  class read_until_match_op</a>
<a name="ln1192">  {</a>
<a name="ln1193">  public:</a>
<a name="ln1194">    template &lt;typename BufferSequence&gt;</a>
<a name="ln1195">    read_until_match_op(AsyncReadStream&amp; stream,</a>
<a name="ln1196">        BOOST_ASIO_MOVE_ARG(BufferSequence) buffers,</a>
<a name="ln1197">        MatchCondition match_condition, ReadHandler&amp; handler)</a>
<a name="ln1198">      : stream_(stream),</a>
<a name="ln1199">        buffers_(BOOST_ASIO_MOVE_CAST(BufferSequence)(buffers)),</a>
<a name="ln1200">        match_condition_(match_condition),</a>
<a name="ln1201">        start_(0),</a>
<a name="ln1202">        search_position_(0),</a>
<a name="ln1203">        handler_(BOOST_ASIO_MOVE_CAST(ReadHandler)(handler))</a>
<a name="ln1204">    {</a>
<a name="ln1205">    }</a>
<a name="ln1206"> </a>
<a name="ln1207">#if defined(BOOST_ASIO_HAS_MOVE)</a>
<a name="ln1208">    read_until_match_op(const read_until_match_op&amp; other)</a>
<a name="ln1209">      : stream_(other.stream_),</a>
<a name="ln1210">        buffers_(other.buffers_),</a>
<a name="ln1211">        match_condition_(other.match_condition_),</a>
<a name="ln1212">        start_(other.start_),</a>
<a name="ln1213">        search_position_(other.search_position_),</a>
<a name="ln1214">        handler_(other.handler_)</a>
<a name="ln1215">    {</a>
<a name="ln1216">    }</a>
<a name="ln1217"> </a>
<a name="ln1218">    read_until_match_op(read_until_match_op&amp;&amp; other)</a>
<a name="ln1219">      : stream_(other.stream_),</a>
<a name="ln1220">        buffers_(BOOST_ASIO_MOVE_CAST(DynamicBuffer)(other.buffers_)),</a>
<a name="ln1221">        match_condition_(other.match_condition_),</a>
<a name="ln1222">        start_(other.start_),</a>
<a name="ln1223">        search_position_(other.search_position_),</a>
<a name="ln1224">        handler_(BOOST_ASIO_MOVE_CAST(ReadHandler)(other.handler_))</a>
<a name="ln1225">    {</a>
<a name="ln1226">    }</a>
<a name="ln1227">#endif // defined(BOOST_ASIO_HAS_MOVE)</a>
<a name="ln1228"> </a>
<a name="ln1229">    void operator()(const boost::system::error_code&amp; ec,</a>
<a name="ln1230">        std::size_t bytes_transferred, int start = 0)</a>
<a name="ln1231">    {</a>
<a name="ln1232">      const std::size_t not_found = (std::numeric_limits&lt;std::size_t&gt;::max)();</a>
<a name="ln1233">      std::size_t bytes_to_read;</a>
<a name="ln1234">      switch (start_ = start)</a>
<a name="ln1235">      {</a>
<a name="ln1236">      case 1:</a>
<a name="ln1237">        for (;;)</a>
<a name="ln1238">        {</a>
<a name="ln1239">          {</a>
<a name="ln1240">            // Determine the range of the data to be searched.</a>
<a name="ln1241">            typedef typename DynamicBuffer::const_buffers_type</a>
<a name="ln1242">              buffers_type;</a>
<a name="ln1243">            typedef buffers_iterator&lt;buffers_type&gt; iterator;</a>
<a name="ln1244">            buffers_type data_buffers = buffers_.data();</a>
<a name="ln1245">            iterator begin = iterator::begin(data_buffers);</a>
<a name="ln1246">            iterator start_pos = begin + search_position_;</a>
<a name="ln1247">            iterator end = iterator::end(data_buffers);</a>
<a name="ln1248"> </a>
<a name="ln1249">            // Look for a match.</a>
<a name="ln1250">            std::pair&lt;iterator, bool&gt; result = match_condition_(start_pos, end);</a>
<a name="ln1251">            if (result.second)</a>
<a name="ln1252">            {</a>
<a name="ln1253">              // Full match. We're done.</a>
<a name="ln1254">              search_position_ = result.first - begin;</a>
<a name="ln1255">              bytes_to_read = 0;</a>
<a name="ln1256">            }</a>
<a name="ln1257"> </a>
<a name="ln1258">            // No match yet. Check if buffer is full.</a>
<a name="ln1259">            else if (buffers_.size() == buffers_.max_size())</a>
<a name="ln1260">            {</a>
<a name="ln1261">              search_position_ = not_found;</a>
<a name="ln1262">              bytes_to_read = 0;</a>
<a name="ln1263">            }</a>
<a name="ln1264"> </a>
<a name="ln1265">            // Need to read some more data.</a>
<a name="ln1266">            else</a>
<a name="ln1267">            {</a>
<a name="ln1268">              if (result.first != end)</a>
<a name="ln1269">              {</a>
<a name="ln1270">                // Partial match. Next search needs to start from beginning of</a>
<a name="ln1271">                // match.</a>
<a name="ln1272">                search_position_ = result.first - begin;</a>
<a name="ln1273">              }</a>
<a name="ln1274">              else</a>
<a name="ln1275">              {</a>
<a name="ln1276">                // Next search can start with the new data.</a>
<a name="ln1277">                search_position_ = end - begin;</a>
<a name="ln1278">              }</a>
<a name="ln1279"> </a>
<a name="ln1280">              bytes_to_read = std::min&lt;std::size_t&gt;(</a>
<a name="ln1281">                    std::max&lt;std::size_t&gt;(512,</a>
<a name="ln1282">                      buffers_.capacity() - buffers_.size()),</a>
<a name="ln1283">                    std::min&lt;std::size_t&gt;(65536,</a>
<a name="ln1284">                      buffers_.max_size() - buffers_.size()));</a>
<a name="ln1285">            }</a>
<a name="ln1286">          }</a>
<a name="ln1287"> </a>
<a name="ln1288">          // Check if we're done.</a>
<a name="ln1289">          if (!start &amp;&amp; bytes_to_read == 0)</a>
<a name="ln1290">            break;</a>
<a name="ln1291"> </a>
<a name="ln1292">          // Start a new asynchronous read operation to obtain more data.</a>
<a name="ln1293">          stream_.async_read_some(buffers_.prepare(bytes_to_read),</a>
<a name="ln1294">              BOOST_ASIO_MOVE_CAST(read_until_match_op)(*this));</a>
<a name="ln1295">          return; default:</a>
<a name="ln1296">          buffers_.commit(bytes_transferred);</a>
<a name="ln1297">          if (ec || bytes_transferred == 0)</a>
<a name="ln1298">            break;</a>
<a name="ln1299">        }</a>
<a name="ln1300"> </a>
<a name="ln1301">        const boost::system::error_code result_ec =</a>
<a name="ln1302">          (search_position_ == not_found)</a>
<a name="ln1303">          ? error::not_found : ec;</a>
<a name="ln1304"> </a>
<a name="ln1305">        const std::size_t result_n =</a>
<a name="ln1306">          (ec || search_position_ == not_found)</a>
<a name="ln1307">          ? 0 : search_position_;</a>
<a name="ln1308"> </a>
<a name="ln1309">        handler_(result_ec, result_n);</a>
<a name="ln1310">      }</a>
<a name="ln1311">    }</a>
<a name="ln1312"> </a>
<a name="ln1313">  //private:</a>
<a name="ln1314">    AsyncReadStream&amp; stream_;</a>
<a name="ln1315">    DynamicBuffer buffers_;</a>
<a name="ln1316">    MatchCondition match_condition_;</a>
<a name="ln1317">    int start_;</a>
<a name="ln1318">    std::size_t search_position_;</a>
<a name="ln1319">    ReadHandler handler_;</a>
<a name="ln1320">  };</a>
<a name="ln1321"> </a>
<a name="ln1322">  template &lt;typename AsyncReadStream, typename DynamicBuffer,</a>
<a name="ln1323">      typename MatchCondition, typename ReadHandler&gt;</a>
<a name="ln1324">  inline void* asio_handler_allocate(std::size_t size,</a>
<a name="ln1325">      read_until_match_op&lt;AsyncReadStream, DynamicBuffer,</a>
<a name="ln1326">        MatchCondition, ReadHandler&gt;* this_handler)</a>
<a name="ln1327">  {</a>
<a name="ln1328">    return boost_asio_handler_alloc_helpers::allocate(</a>
<a name="ln1329">        size, this_handler-&gt;handler_);</a>
<a name="ln1330">  }</a>
<a name="ln1331"> </a>
<a name="ln1332">  template &lt;typename AsyncReadStream, typename DynamicBuffer,</a>
<a name="ln1333">      typename MatchCondition, typename ReadHandler&gt;</a>
<a name="ln1334">  inline void asio_handler_deallocate(void* pointer, std::size_t size,</a>
<a name="ln1335">      read_until_match_op&lt;AsyncReadStream, DynamicBuffer,</a>
<a name="ln1336">        MatchCondition, ReadHandler&gt;* this_handler)</a>
<a name="ln1337">  {</a>
<a name="ln1338">    boost_asio_handler_alloc_helpers::deallocate(</a>
<a name="ln1339">        pointer, size, this_handler-&gt;handler_);</a>
<a name="ln1340">  }</a>
<a name="ln1341"> </a>
<a name="ln1342">  template &lt;typename AsyncReadStream, typename DynamicBuffer,</a>
<a name="ln1343">      typename MatchCondition, typename ReadHandler&gt;</a>
<a name="ln1344">  inline bool asio_handler_is_continuation(</a>
<a name="ln1345">      read_until_match_op&lt;AsyncReadStream, DynamicBuffer,</a>
<a name="ln1346">        MatchCondition, ReadHandler&gt;* this_handler)</a>
<a name="ln1347">  {</a>
<a name="ln1348">    return this_handler-&gt;start_ == 0 ? true</a>
<a name="ln1349">      : boost_asio_handler_cont_helpers::is_continuation(</a>
<a name="ln1350">          this_handler-&gt;handler_);</a>
<a name="ln1351">  }</a>
<a name="ln1352"> </a>
<a name="ln1353">  template &lt;typename Function, typename AsyncReadStream,</a>
<a name="ln1354">      typename DynamicBuffer, typename MatchCondition,</a>
<a name="ln1355">      typename ReadHandler&gt;</a>
<a name="ln1356">  inline void asio_handler_invoke(Function&amp; function,</a>
<a name="ln1357">      read_until_match_op&lt;AsyncReadStream, DynamicBuffer,</a>
<a name="ln1358">        MatchCondition, ReadHandler&gt;* this_handler)</a>
<a name="ln1359">  {</a>
<a name="ln1360">    boost_asio_handler_invoke_helpers::invoke(</a>
<a name="ln1361">        function, this_handler-&gt;handler_);</a>
<a name="ln1362">  }</a>
<a name="ln1363"> </a>
<a name="ln1364">  template &lt;typename Function, typename AsyncReadStream,</a>
<a name="ln1365">      typename DynamicBuffer, typename MatchCondition,</a>
<a name="ln1366">      typename ReadHandler&gt;</a>
<a name="ln1367">  inline void asio_handler_invoke(const Function&amp; function,</a>
<a name="ln1368">      read_until_match_op&lt;AsyncReadStream, DynamicBuffer,</a>
<a name="ln1369">      MatchCondition, ReadHandler&gt;* this_handler)</a>
<a name="ln1370">  {</a>
<a name="ln1371">    boost_asio_handler_invoke_helpers::invoke(</a>
<a name="ln1372">        function, this_handler-&gt;handler_);</a>
<a name="ln1373">  }</a>
<a name="ln1374">} // namespace detail</a>
<a name="ln1375"> </a>
<a name="ln1376">#if !defined(GENERATING_DOCUMENTATION)</a>
<a name="ln1377"> </a>
<a name="ln1378">template &lt;typename AsyncReadStream, typename DynamicBuffer,</a>
<a name="ln1379">    typename MatchCondition, typename ReadHandler, typename Allocator&gt;</a>
<a name="ln1380">struct associated_allocator&lt;</a>
<a name="ln1381">    detail::read_until_match_op&lt;AsyncReadStream,</a>
<a name="ln1382">      DynamicBuffer, MatchCondition, ReadHandler&gt;,</a>
<a name="ln1383">    Allocator&gt;</a>
<a name="ln1384">{</a>
<a name="ln1385">  typedef typename associated_allocator&lt;ReadHandler, Allocator&gt;::type type;</a>
<a name="ln1386"> </a>
<a name="ln1387">  static type get(</a>
<a name="ln1388">      const detail::read_until_match_op&lt;AsyncReadStream,</a>
<a name="ln1389">        DynamicBuffer, MatchCondition, ReadHandler&gt;&amp; h,</a>
<a name="ln1390">      const Allocator&amp; a = Allocator()) BOOST_ASIO_NOEXCEPT</a>
<a name="ln1391">  {</a>
<a name="ln1392">    return associated_allocator&lt;ReadHandler, Allocator&gt;::get(h.handler_, a);</a>
<a name="ln1393">  }</a>
<a name="ln1394">};</a>
<a name="ln1395"> </a>
<a name="ln1396">template &lt;typename AsyncReadStream, typename DynamicBuffer,</a>
<a name="ln1397">    typename MatchCondition, typename ReadHandler, typename Executor&gt;</a>
<a name="ln1398">struct associated_executor&lt;</a>
<a name="ln1399">    detail::read_until_match_op&lt;AsyncReadStream,</a>
<a name="ln1400">      DynamicBuffer, MatchCondition, ReadHandler&gt;,</a>
<a name="ln1401">    Executor&gt;</a>
<a name="ln1402">{</a>
<a name="ln1403">  typedef typename associated_executor&lt;ReadHandler, Executor&gt;::type type;</a>
<a name="ln1404"> </a>
<a name="ln1405">  static type get(</a>
<a name="ln1406">      const detail::read_until_match_op&lt;AsyncReadStream,</a>
<a name="ln1407">        DynamicBuffer, MatchCondition, ReadHandler&gt;&amp; h,</a>
<a name="ln1408">      const Executor&amp; ex = Executor()) BOOST_ASIO_NOEXCEPT</a>
<a name="ln1409">  {</a>
<a name="ln1410">    return associated_executor&lt;ReadHandler, Executor&gt;::get(h.handler_, ex);</a>
<a name="ln1411">  }</a>
<a name="ln1412">};</a>
<a name="ln1413"> </a>
<a name="ln1414">#endif // !defined(GENERATING_DOCUMENTATION)</a>
<a name="ln1415"> </a>
<a name="ln1416">template &lt;typename AsyncReadStream, typename DynamicBuffer,</a>
<a name="ln1417">    typename MatchCondition, typename ReadHandler&gt;</a>
<a name="ln1418">BOOST_ASIO_INITFN_RESULT_TYPE(ReadHandler,</a>
<a name="ln1419">    void (boost::system::error_code, std::size_t))</a>
<a name="ln1420">async_read_until(AsyncReadStream&amp; s,</a>
<a name="ln1421">    BOOST_ASIO_MOVE_ARG(DynamicBuffer) buffers,</a>
<a name="ln1422">    MatchCondition match_condition, BOOST_ASIO_MOVE_ARG(ReadHandler) handler,</a>
<a name="ln1423">    typename enable_if&lt;is_match_condition&lt;MatchCondition&gt;::value&gt;::type*)</a>
<a name="ln1424">{</a>
<a name="ln1425">  // If you get an error on the following line it means that your handler does</a>
<a name="ln1426">  // not meet the documented type requirements for a ReadHandler.</a>
<a name="ln1427">  BOOST_ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;</a>
<a name="ln1428"> </a>
<a name="ln1429">  async_completion&lt;ReadHandler,</a>
<a name="ln1430">    void (boost::system::error_code, std::size_t)&gt; init(handler);</a>
<a name="ln1431"> </a>
<a name="ln1432">  detail::read_until_match_op&lt;AsyncReadStream,</a>
<a name="ln1433">    typename decay&lt;DynamicBuffer&gt;::type,</a>
<a name="ln1434">      MatchCondition, BOOST_ASIO_HANDLER_TYPE(ReadHandler,</a>
<a name="ln1435">        void (boost::system::error_code, std::size_t))&gt;(</a>
<a name="ln1436">          s, BOOST_ASIO_MOVE_CAST(DynamicBuffer)(buffers),</a>
<a name="ln1437">            match_condition, init.completion_handler)(</a>
<a name="ln1438">              boost::system::error_code(), 0, 1);</a>
<a name="ln1439"> </a>
<a name="ln1440">  return init.result.get();</a>
<a name="ln1441">}</a>
<a name="ln1442"> </a>
<a name="ln1443">#if !defined(BOOST_ASIO_NO_IOSTREAM)</a>
<a name="ln1444"> </a>
<a name="ln1445">template &lt;typename AsyncReadStream, typename Allocator, typename ReadHandler&gt;</a>
<a name="ln1446">inline BOOST_ASIO_INITFN_RESULT_TYPE(ReadHandler,</a>
<a name="ln1447">    void (boost::system::error_code, std::size_t))</a>
<a name="ln1448">async_read_until(AsyncReadStream&amp; s,</a>
<a name="ln1449">    boost::asio::basic_streambuf&lt;Allocator&gt;&amp; b,</a>
<a name="ln1450">    char delim, BOOST_ASIO_MOVE_ARG(ReadHandler) handler)</a>
<a name="ln1451">{</a>
<a name="ln1452">  return async_read_until(s, basic_streambuf_ref&lt;Allocator&gt;(b),</a>
<a name="ln1453">      delim, BOOST_ASIO_MOVE_CAST(ReadHandler)(handler));</a>
<a name="ln1454">}</a>
<a name="ln1455"> </a>
<a name="ln1456">template &lt;typename AsyncReadStream, typename Allocator, typename ReadHandler&gt;</a>
<a name="ln1457">inline BOOST_ASIO_INITFN_RESULT_TYPE(ReadHandler,</a>
<a name="ln1458">    void (boost::system::error_code, std::size_t))</a>
<a name="ln1459">async_read_until(AsyncReadStream&amp; s,</a>
<a name="ln1460">    boost::asio::basic_streambuf&lt;Allocator&gt;&amp; b,</a>
<a name="ln1461">    BOOST_ASIO_STRING_VIEW_PARAM delim,</a>
<a name="ln1462">    BOOST_ASIO_MOVE_ARG(ReadHandler) handler)</a>
<a name="ln1463">{</a>
<a name="ln1464">  return async_read_until(s, basic_streambuf_ref&lt;Allocator&gt;(b),</a>
<a name="ln1465">      delim, BOOST_ASIO_MOVE_CAST(ReadHandler)(handler));</a>
<a name="ln1466">}</a>
<a name="ln1467"> </a>
<a name="ln1468">#if defined(BOOST_ASIO_HAS_BOOST_REGEX)</a>
<a name="ln1469"> </a>
<a name="ln1470">template &lt;typename AsyncReadStream, typename Allocator, typename ReadHandler&gt;</a>
<a name="ln1471">inline BOOST_ASIO_INITFN_RESULT_TYPE(ReadHandler,</a>
<a name="ln1472">    void (boost::system::error_code, std::size_t))</a>
<a name="ln1473">async_read_until(AsyncReadStream&amp; s,</a>
<a name="ln1474">    boost::asio::basic_streambuf&lt;Allocator&gt;&amp; b, const boost::regex&amp; expr,</a>
<a name="ln1475">    BOOST_ASIO_MOVE_ARG(ReadHandler) handler)</a>
<a name="ln1476">{</a>
<a name="ln1477">  return async_read_until(s, basic_streambuf_ref&lt;Allocator&gt;(b),</a>
<a name="ln1478">      expr, BOOST_ASIO_MOVE_CAST(ReadHandler)(handler));</a>
<a name="ln1479">}</a>
<a name="ln1480"> </a>
<a name="ln1481">#endif // defined(BOOST_ASIO_HAS_BOOST_REGEX)</a>
<a name="ln1482"> </a>
<a name="ln1483">template &lt;typename AsyncReadStream, typename Allocator,</a>
<a name="ln1484">    typename MatchCondition, typename ReadHandler&gt;</a>
<a name="ln1485">inline BOOST_ASIO_INITFN_RESULT_TYPE(ReadHandler,</a>
<a name="ln1486">    void (boost::system::error_code, std::size_t))</a>
<a name="ln1487">async_read_until(AsyncReadStream&amp; s,</a>
<a name="ln1488">    boost::asio::basic_streambuf&lt;Allocator&gt;&amp; b,</a>
<a name="ln1489">    MatchCondition match_condition, BOOST_ASIO_MOVE_ARG(ReadHandler) handler,</a>
<a name="ln1490">    typename enable_if&lt;is_match_condition&lt;MatchCondition&gt;::value&gt;::type*)</a>
<a name="ln1491">{</a>
<a name="ln1492">  return async_read_until(s, basic_streambuf_ref&lt;Allocator&gt;(b),</a>
<a name="ln1493">      match_condition, BOOST_ASIO_MOVE_CAST(ReadHandler)(handler));</a>
<a name="ln1494">}</a>
<a name="ln1495"> </a>
<a name="ln1496">#endif // !defined(BOOST_ASIO_NO_IOSTREAM)</a>
<a name="ln1497">#endif // !defined(BOOST_ASIO_NO_EXTENSIONS)</a>
<a name="ln1498"> </a>
<a name="ln1499">} // namespace asio</a>
<a name="ln1500">} // namespace boost</a>
<a name="ln1501"> </a>
<a name="ln1502">#include &lt;boost/asio/detail/pop_options.hpp&gt;</a>
<a name="ln1503"> </a>
<a name="ln1504">#endif // BOOST_ASIO_IMPL_READ_UNTIL_HPP</a>

</code></pre>
<div class="balloon" rel="520"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: !start.</p></div>
<div class="balloon" rel="773"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: !start.</p></div>
<div class="balloon" rel="1034"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: !start.</p></div>
<div class="balloon" rel="1289"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: !start.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
