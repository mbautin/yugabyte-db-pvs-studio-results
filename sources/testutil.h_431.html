
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>testutil.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//  Copyright (c) 2011-present, Facebook, Inc.  All rights reserved.</a>
<a name="ln2">//  This source code is licensed under the BSD-style license found in the</a>
<a name="ln3">//  LICENSE file in the root directory of this source tree. An additional grant</a>
<a name="ln4">//  of patent rights can be found in the PATENTS file in the same directory.</a>
<a name="ln5">//</a>
<a name="ln6">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln7">//</a>
<a name="ln8">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln9">//</a>
<a name="ln10">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln11">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln12">//</a>
<a name="ln13">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln14">//</a>
<a name="ln15">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln16">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln17">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln18">// under the License.</a>
<a name="ln19">//</a>
<a name="ln20">// Copyright (c) 2011 The LevelDB Authors. All rights reserved.</a>
<a name="ln21">// Use of this source code is governed by a BSD-style license that can be</a>
<a name="ln22">// found in the LICENSE file. See the AUTHORS file for names of contributors.</a>
<a name="ln23"> </a>
<a name="ln24">#ifndef YB_ROCKSDB_UTIL_TESTUTIL_H</a>
<a name="ln25">#define YB_ROCKSDB_UTIL_TESTUTIL_H</a>
<a name="ln26"> </a>
<a name="ln27">#pragma once</a>
<a name="ln28">#include &lt;algorithm&gt;</a>
<a name="ln29">#include &lt;deque&gt;</a>
<a name="ln30">#include &lt;string&gt;</a>
<a name="ln31">#include &lt;vector&gt;</a>
<a name="ln32"> </a>
<a name="ln33">#include &quot;yb/rocksdb/compaction_filter.h&quot;</a>
<a name="ln34">#include &quot;yb/rocksdb/env.h&quot;</a>
<a name="ln35">#include &quot;yb/rocksdb/iterator.h&quot;</a>
<a name="ln36">#include &quot;yb/rocksdb/merge_operator.h&quot;</a>
<a name="ln37">#include &quot;yb/rocksdb/options.h&quot;</a>
<a name="ln38">#include &quot;yb/rocksdb/db/version_edit.pb.h&quot;</a>
<a name="ln39">#include &quot;yb/rocksdb/table.h&quot;</a>
<a name="ln40">#include &quot;yb/rocksdb/table/block_based_table_factory.h&quot;</a>
<a name="ln41">#include &quot;yb/rocksdb/table/internal_iterator.h&quot;</a>
<a name="ln42">#include &quot;yb/rocksdb/table/plain_table_factory.h&quot;</a>
<a name="ln43">#include &quot;yb/rocksdb/util/mutexlock.h&quot;</a>
<a name="ln44">#include &quot;yb/rocksdb/util/random.h&quot;</a>
<a name="ln45"> </a>
<a name="ln46">#include &quot;yb/util/slice.h&quot;</a>
<a name="ln47"> </a>
<a name="ln48">namespace rocksdb {</a>
<a name="ln49">class SequentialFileReader;</a>
<a name="ln50"> </a>
<a name="ln51">namespace test {</a>
<a name="ln52"> </a>
<a name="ln53">extern std::string RandomHumanReadableString(Random* rnd, int len);</a>
<a name="ln54"> </a>
<a name="ln55">// Return a random key with the specified length that may contain interesting</a>
<a name="ln56">// characters (e.g. \x00, \xff, etc.).</a>
<a name="ln57">enum RandomKeyType : char { RANDOM, LARGEST, SMALLEST, MIDDLE };</a>
<a name="ln58">extern std::string RandomKey(Random* rnd, int len,</a>
<a name="ln59">                             RandomKeyType type = RandomKeyType::RANDOM);</a>
<a name="ln60"> </a>
<a name="ln61">// A wrapper that allows injection of errors.</a>
<a name="ln62">class ErrorEnv : public EnvWrapper {</a>
<a name="ln63"> public:</a>
<a name="ln64">  bool writable_file_error_;</a>
<a name="ln65">  int num_writable_file_errors_;</a>
<a name="ln66"> </a>
<a name="ln67">  ErrorEnv() : EnvWrapper(Env::Default()),</a>
<a name="ln68">               writable_file_error_(false),</a>
<a name="ln69">               num_writable_file_errors_(0) { }</a>
<a name="ln70"> </a>
<a name="ln71">  virtual Status NewWritableFile(const std::string&amp; fname,</a>
<a name="ln72">                                 unique_ptr&lt;WritableFile&gt;* result,</a>
<a name="ln73">                                 const EnvOptions&amp; soptions) override {</a>
<a name="ln74">    result-&gt;reset();</a>
<a name="ln75">    if (writable_file_error_) {</a>
<a name="ln76">      ++num_writable_file_errors_;</a>
<a name="ln77">      return STATUS(IOError, fname, &quot;fake error&quot;);</a>
<a name="ln78">    }</a>
<a name="ln79">    return target()-&gt;NewWritableFile(fname, result, soptions);</a>
<a name="ln80">  }</a>
<a name="ln81">};</a>
<a name="ln82"> </a>
<a name="ln83">// An internal comparator that just forward comparing results from the</a>
<a name="ln84">// user comparator in it. Can be used to test entities that have no dependency</a>
<a name="ln85">// on internal key structure but consumes InternalKeyComparator, like</a>
<a name="ln86">// BlockBasedTable.</a>
<a name="ln87">class PlainInternalKeyComparator : public InternalKeyComparator {</a>
<a name="ln88"> public:</a>
<a name="ln89">  explicit PlainInternalKeyComparator(const Comparator* c)</a>
<a name="ln90">      : InternalKeyComparator(c) {}</a>
<a name="ln91"> </a>
<a name="ln92">  virtual ~PlainInternalKeyComparator() {}</a>
<a name="ln93"> </a>
<a name="ln94">  virtual int Compare(const Slice&amp; a, const Slice&amp; b) const override {</a>
<a name="ln95">    return user_comparator()-&gt;Compare(a, b);</a>
<a name="ln96">  }</a>
<a name="ln97">  virtual void FindShortestSeparator(std::string* start,</a>
<a name="ln98">                                     const Slice&amp; limit) const override {</a>
<a name="ln99">    user_comparator()-&gt;FindShortestSeparator(start, limit);</a>
<a name="ln100">  }</a>
<a name="ln101">  virtual void FindShortSuccessor(std::string* key) const override {</a>
<a name="ln102">    user_comparator()-&gt;FindShortSuccessor(key);</a>
<a name="ln103">  }</a>
<a name="ln104">};</a>
<a name="ln105"> </a>
<a name="ln106">// A test comparator which compare two strings in this way:</a>
<a name="ln107">// (1) first compare prefix of 8 bytes in alphabet order,</a>
<a name="ln108">// (2) if two strings share the same prefix, sort the other part of the string</a>
<a name="ln109">//     in the reverse alphabet order.</a>
<a name="ln110">// This helps simulate the case of compounded key of [entity][timestamp] and</a>
<a name="ln111">// latest timestamp first.</a>
<a name="ln112">class SimpleSuffixReverseComparator : public Comparator {</a>
<a name="ln113"> public:</a>
<a name="ln114">  SimpleSuffixReverseComparator() {}</a>
<a name="ln115"> </a>
<a name="ln116">  virtual const char* Name() const override {</a>
<a name="ln117">    return &quot;SimpleSuffixReverseComparator&quot;;</a>
<a name="ln118">  }</a>
<a name="ln119"> </a>
<a name="ln120">  virtual int Compare(const Slice&amp; a, const Slice&amp; b) const override {</a>
<a name="ln121">    Slice prefix_a = Slice(a.data(), 8);</a>
<a name="ln122">    Slice prefix_b = Slice(b.data(), 8);</a>
<a name="ln123">    int prefix_comp = prefix_a.compare(prefix_b);</a>
<a name="ln124">    if (prefix_comp != 0) {</a>
<a name="ln125">      return prefix_comp;</a>
<a name="ln126">    } else {</a>
<a name="ln127">      Slice suffix_a = Slice(a.data() + 8, a.size() - 8);</a>
<a name="ln128">      Slice suffix_b = Slice(b.data() + 8, b.size() - 8);</a>
<a name="ln129">      return -(suffix_a.compare(suffix_b));</a>
<a name="ln130">    }</a>
<a name="ln131">  }</a>
<a name="ln132">  virtual void FindShortestSeparator(std::string* start,</a>
<a name="ln133">                                     const Slice&amp; limit) const override {}</a>
<a name="ln134"> </a>
<a name="ln135">  virtual void FindShortSuccessor(std::string* key) const override {}</a>
<a name="ln136">};</a>
<a name="ln137"> </a>
<a name="ln138">// Iterator over a vector of keys/values</a>
<a name="ln139">class VectorIterator : public InternalIterator {</a>
<a name="ln140"> public:</a>
<a name="ln141">  explicit VectorIterator(const std::vector&lt;std::string&gt;&amp; keys)</a>
<a name="ln142">      : keys_(keys), current_(keys.size()) {</a>
<a name="ln143">    std::sort(keys_.begin(), keys_.end());</a>
<a name="ln144">    values_.resize(keys.size());</a>
<a name="ln145">  }</a>
<a name="ln146"> </a>
<a name="ln147">  VectorIterator(const std::vector&lt;std::string&gt;&amp; keys,</a>
<a name="ln148">      const std::vector&lt;std::string&gt;&amp; values)</a>
<a name="ln149">    : keys_(keys), values_(values), current_(keys.size()) {</a>
<a name="ln150">    assert(keys_.size() == values_.size());</a>
<a name="ln151">  }</a>
<a name="ln152"> </a>
<a name="ln153">  virtual bool Valid() const override { return current_ &lt; keys_.size(); }</a>
<a name="ln154"> </a>
<a name="ln155">  virtual void SeekToFirst() override { current_ = 0; }</a>
<a name="ln156">  virtual void SeekToLast() override { current_ = keys_.size() - 1; }</a>
<a name="ln157"> </a>
<a name="ln158">  virtual void Seek(const Slice&amp; target) override {</a>
<a name="ln159">    current_ = std::lower_bound(keys_.begin(), keys_.end(), target.ToBuffer()) -</a>
<a name="ln160">               keys_.begin();</a>
<a name="ln161">  }</a>
<a name="ln162"> </a>
<a name="ln163">  virtual void Next() override { current_++; }</a>
<a name="ln164">  virtual void Prev() override { current_--; }</a>
<a name="ln165"> </a>
<a name="ln166">  virtual Slice key() const override { return Slice(keys_[current_]); }</a>
<a name="ln167">  virtual Slice value() const override { return Slice(values_[current_]); }</a>
<a name="ln168"> </a>
<a name="ln169">  virtual Status status() const override { return Status::OK(); }</a>
<a name="ln170"> </a>
<a name="ln171"> private:</a>
<a name="ln172">  std::vector&lt;std::string&gt; keys_;</a>
<a name="ln173">  std::vector&lt;std::string&gt; values_;</a>
<a name="ln174">  size_t current_;</a>
<a name="ln175">};</a>
<a name="ln176">extern WritableFileWriter* GetWritableFileWriter(WritableFile* wf);</a>
<a name="ln177"> </a>
<a name="ln178">extern RandomAccessFileReader* GetRandomAccessFileReader(RandomAccessFile* raf);</a>
<a name="ln179"> </a>
<a name="ln180">extern SequentialFileReader* GetSequentialFileReader(SequentialFile* se);</a>
<a name="ln181"> </a>
<a name="ln182">class StringSink: public WritableFile {</a>
<a name="ln183"> public:</a>
<a name="ln184">  std::string contents_;</a>
<a name="ln185"> </a>
<a name="ln186">  explicit StringSink(Slice* reader_contents = nullptr) :</a>
<a name="ln187">      WritableFile(),</a>
<a name="ln188">      contents_(&quot;&quot;),</a>
<a name="ln189">      reader_contents_(reader_contents),</a>
<a name="ln190">      last_flush_(0) {</a>
<a name="ln191">    if (reader_contents_ != nullptr) {</a>
<a name="ln192">      *reader_contents_ = Slice(contents_.data(), 0UL);</a>
<a name="ln193">    }</a>
<a name="ln194">  }</a>
<a name="ln195"> </a>
<a name="ln196">  const std::string&amp; contents() const { return contents_; }</a>
<a name="ln197"> </a>
<a name="ln198">  virtual Status Truncate(uint64_t size) override {</a>
<a name="ln199">    contents_.resize(static_cast&lt;size_t&gt;(size));</a>
<a name="ln200">    return Status::OK();</a>
<a name="ln201">  }</a>
<a name="ln202">  virtual Status Close() override { return Status::OK(); }</a>
<a name="ln203">  virtual Status Flush() override {</a>
<a name="ln204">    if (reader_contents_ != nullptr) {</a>
<a name="ln205">      assert(reader_contents_-&gt;size() &lt;= last_flush_);</a>
<a name="ln206">      size_t offset = last_flush_ - reader_contents_-&gt;size();</a>
<a name="ln207">      *reader_contents_ = Slice(</a>
<a name="ln208">          contents_.data() + offset,</a>
<a name="ln209">          contents_.size() - offset);</a>
<a name="ln210">      last_flush_ = contents_.size();</a>
<a name="ln211">    }</a>
<a name="ln212"> </a>
<a name="ln213">    return Status::OK();</a>
<a name="ln214">  }</a>
<a name="ln215">  virtual Status Sync() override { return Status::OK(); }</a>
<a name="ln216">  virtual Status Append(const Slice&amp; slice) override {</a>
<a name="ln217">    contents_.append(slice.cdata(), slice.size());</a>
<a name="ln218">    return Status::OK();</a>
<a name="ln219">  }</a>
<a name="ln220">  void Drop(size_t bytes) {</a>
<a name="ln221">    if (reader_contents_ != nullptr) {</a>
<a name="ln222">      contents_.resize(contents_.size() - bytes);</a>
<a name="ln223">      *reader_contents_ = Slice(</a>
<a name="ln224">          reader_contents_-&gt;data(), reader_contents_-&gt;size() - bytes);</a>
<a name="ln225">      last_flush_ = contents_.size();</a>
<a name="ln226">    }</a>
<a name="ln227">  }</a>
<a name="ln228"> </a>
<a name="ln229"> private:</a>
<a name="ln230">  Slice* reader_contents_;</a>
<a name="ln231">  size_t last_flush_;</a>
<a name="ln232">};</a>
<a name="ln233"> </a>
<a name="ln234">class StringSource: public RandomAccessFile {</a>
<a name="ln235"> public:</a>
<a name="ln236">  explicit StringSource(const Slice&amp; contents, uint64_t uniq_id = 0,</a>
<a name="ln237">                        bool mmap = false)</a>
<a name="ln238">      : contents_(contents.cdata(), contents.size()),</a>
<a name="ln239">        uniq_id_(uniq_id),</a>
<a name="ln240">        mmap_(mmap),</a>
<a name="ln241">        total_reads_(0) {}</a>
<a name="ln242"> </a>
<a name="ln243">  virtual ~StringSource() {}</a>
<a name="ln244"> </a>
<a name="ln245">  yb::Result&lt;uint64_t&gt; Size() const override { return contents_.size(); }</a>
<a name="ln246"> </a>
<a name="ln247">  CHECKED_STATUS Read(uint64_t offset, size_t n, Slice* result, uint8_t* scratch) const override {</a>
<a name="ln248">    total_reads_++;</a>
<a name="ln249">    if (offset &gt; contents_.size()) {</a>
<a name="ln250">      return STATUS(InvalidArgument, &quot;invalid Read offset&quot;);</a>
<a name="ln251">    }</a>
<a name="ln252">    if (offset + n &gt; contents_.size()) {</a>
<a name="ln253">      n = contents_.size() - static_cast&lt;size_t&gt;(offset);</a>
<a name="ln254">    }</a>
<a name="ln255">    if (!mmap_) {</a>
<a name="ln256">      memcpy(scratch, &amp;contents_[static_cast&lt;size_t&gt;(offset)], n);</a>
<a name="ln257">      *result = Slice(scratch, n);</a>
<a name="ln258">    } else {</a>
<a name="ln259">      *result = Slice(&amp;contents_[static_cast&lt;size_t&gt;(offset)], n);</a>
<a name="ln260">    }</a>
<a name="ln261">    return Status::OK();</a>
<a name="ln262">  }</a>
<a name="ln263"> </a>
<a name="ln264">  virtual size_t GetUniqueId(char* id) const override {</a>
<a name="ln265">    char* rid = id;</a>
<a name="ln266">    rid = EncodeVarint64(rid, uniq_id_);</a>
<a name="ln267">    rid = EncodeVarint64(rid, 0);</a>
<a name="ln268">    return static_cast&lt;size_t&gt;(rid-id);</a>
<a name="ln269">  }</a>
<a name="ln270"> </a>
<a name="ln271">  yb::Result&lt;uint64_t&gt; INode() const override { return STATUS(NotSupported, &quot;Not supported&quot;); }</a>
<a name="ln272"> </a>
<a name="ln273">  const std::string&amp; filename() const override { return filename_; }</a>
<a name="ln274"> </a>
<a name="ln275">  size_t memory_footprint() const override { LOG(FATAL) &lt;&lt; &quot;Not supported&quot;; }</a>
<a name="ln276"> </a>
<a name="ln277">  int total_reads() const { return total_reads_; }</a>
<a name="ln278"> </a>
<a name="ln279">  void set_total_reads(int tr) { total_reads_ = tr; }</a>
<a name="ln280"> </a>
<a name="ln281"> private:</a>
<a name="ln282">  std::string filename_ = &quot;StringSource&quot;;</a>
<a name="ln283">  std::string contents_;</a>
<a name="ln284">  uint64_t uniq_id_;</a>
<a name="ln285">  bool mmap_;</a>
<a name="ln286">  mutable int total_reads_;</a>
<a name="ln287">};</a>
<a name="ln288"> </a>
<a name="ln289">class NullLogger : public Logger {</a>
<a name="ln290"> public:</a>
<a name="ln291">  using Logger::Logv;</a>
<a name="ln292">  virtual void Logv(const char* format, va_list ap) override {}</a>
<a name="ln293">  virtual size_t GetLogFileSize() const override { return 0; }</a>
<a name="ln294">};</a>
<a name="ln295"> </a>
<a name="ln296">// Corrupts key by changing the type</a>
<a name="ln297">extern void CorruptKeyType(InternalKey* ikey);</a>
<a name="ln298"> </a>
<a name="ln299">extern std::string KeyStr(const std::string&amp; user_key,</a>
<a name="ln300">                          const SequenceNumber&amp; seq, const ValueType&amp; t,</a>
<a name="ln301">                          bool corrupt = false);</a>
<a name="ln302"> </a>
<a name="ln303">class SleepingBackgroundTask {</a>
<a name="ln304"> public:</a>
<a name="ln305">  SleepingBackgroundTask()</a>
<a name="ln306">      : bg_cv_(&amp;mutex_),</a>
<a name="ln307">        should_sleep_(true),</a>
<a name="ln308">        done_with_sleep_(false),</a>
<a name="ln309">        sleeping_(false) {}</a>
<a name="ln310"> </a>
<a name="ln311">  bool IsSleeping() {</a>
<a name="ln312">    MutexLock l(&amp;mutex_);</a>
<a name="ln313">    return sleeping_;</a>
<a name="ln314">  }</a>
<a name="ln315">  void DoSleep() {</a>
<a name="ln316">    MutexLock l(&amp;mutex_);</a>
<a name="ln317">    sleeping_ = true;</a>
<a name="ln318">    bg_cv_.SignalAll();</a>
<a name="ln319">    while (should_sleep_) {</a>
<a name="ln320">      bg_cv_.Wait();</a>
<a name="ln321">    }</a>
<a name="ln322">    sleeping_ = false;</a>
<a name="ln323">    done_with_sleep_ = true;</a>
<a name="ln324">    bg_cv_.SignalAll();</a>
<a name="ln325">  }</a>
<a name="ln326">  void WaitUntilSleeping() {</a>
<a name="ln327">    MutexLock l(&amp;mutex_);</a>
<a name="ln328">    while (!sleeping_ || !should_sleep_) {</a>
<a name="ln329">      bg_cv_.Wait();</a>
<a name="ln330">    }</a>
<a name="ln331">  }</a>
<a name="ln332">  void WakeUp() {</a>
<a name="ln333">    MutexLock l(&amp;mutex_);</a>
<a name="ln334">    should_sleep_ = false;</a>
<a name="ln335">    bg_cv_.SignalAll();</a>
<a name="ln336">  }</a>
<a name="ln337">  void WaitUntilDone() {</a>
<a name="ln338">    MutexLock l(&amp;mutex_);</a>
<a name="ln339">    while (!done_with_sleep_) {</a>
<a name="ln340">      bg_cv_.Wait();</a>
<a name="ln341">    }</a>
<a name="ln342">  }</a>
<a name="ln343">  bool WokenUp() {</a>
<a name="ln344">    MutexLock l(&amp;mutex_);</a>
<a name="ln345">    return should_sleep_ == false;</a>
<a name="ln346">  }</a>
<a name="ln347"> </a>
<a name="ln348">  void Reset() {</a>
<a name="ln349">    MutexLock l(&amp;mutex_);</a>
<a name="ln350">    should_sleep_ = true;</a>
<a name="ln351">    done_with_sleep_ = false;</a>
<a name="ln352">  }</a>
<a name="ln353"> </a>
<a name="ln354">  static void DoSleepTask(void* arg) {</a>
<a name="ln355">    reinterpret_cast&lt;SleepingBackgroundTask*&gt;(arg)-&gt;DoSleep();</a>
<a name="ln356">  }</a>
<a name="ln357"> </a>
<a name="ln358"> private:</a>
<a name="ln359">  port::Mutex mutex_;</a>
<a name="ln360">  port::CondVar bg_cv_;  // Signalled when background work finishes</a>
<a name="ln361">  bool should_sleep_;</a>
<a name="ln362">  bool done_with_sleep_;</a>
<a name="ln363">  bool sleeping_;</a>
<a name="ln364">};</a>
<a name="ln365"> </a>
<a name="ln366">// Filters merge operands and values that are equal to `num`.</a>
<a name="ln367">class FilterNumber : public CompactionFilter {</a>
<a name="ln368"> public:</a>
<a name="ln369">  explicit FilterNumber(uint64_t num) : num_(num) {}</a>
<a name="ln370"> </a>
<a name="ln371">  std::string last_merge_operand_key() { return last_merge_operand_key_; }</a>
<a name="ln372"> </a>
<a name="ln373">  FilterDecision Filter(int level, const rocksdb::Slice&amp; key, const rocksdb::Slice&amp; value,</a>
<a name="ln374">              std::string* new_value, bool* value_changed) override {</a>
<a name="ln375">    if (value.size() == sizeof(uint64_t)) {</a>
<a name="ln376">      return num_ == DecodeFixed64(value.data()) ? FilterDecision::kDiscard : FilterDecision::kKeep;</a>
<a name="ln377">    }</a>
<a name="ln378">    return FilterDecision::kDiscard;</a>
<a name="ln379">  }</a>
<a name="ln380"> </a>
<a name="ln381">  bool FilterMergeOperand(int level, const rocksdb::Slice&amp; key,</a>
<a name="ln382">                          const rocksdb::Slice&amp; value) const override {</a>
<a name="ln383">    last_merge_operand_key_ = key.ToString();</a>
<a name="ln384">    if (value.size() == sizeof(uint64_t)) {</a>
<a name="ln385">      return num_ == DecodeFixed64(value.data());</a>
<a name="ln386">    }</a>
<a name="ln387">    return true;</a>
<a name="ln388">  }</a>
<a name="ln389"> </a>
<a name="ln390">  const char* Name() const override { return &quot;FilterBadMergeOperand&quot;; }</a>
<a name="ln391"> </a>
<a name="ln392"> private:</a>
<a name="ln393">  mutable std::string last_merge_operand_key_;</a>
<a name="ln394">  uint64_t num_;</a>
<a name="ln395">};</a>
<a name="ln396"> </a>
<a name="ln397">inline std::string EncodeInt(uint64_t x) {</a>
<a name="ln398">  std::string result;</a>
<a name="ln399">  PutFixed64(&amp;result, x);</a>
<a name="ln400">  return result;</a>
<a name="ln401">}</a>
<a name="ln402"> </a>
<a name="ln403">class StringEnv : public EnvWrapper {</a>
<a name="ln404"> public:</a>
<a name="ln405">  class SeqStringSource : public SequentialFile {</a>
<a name="ln406">   public:</a>
<a name="ln407">    explicit SeqStringSource(const std::string&amp; data)</a>
<a name="ln408">        : data_(data), offset_(0) {}</a>
<a name="ln409"> </a>
<a name="ln410">    ~SeqStringSource() {}</a>
<a name="ln411"> </a>
<a name="ln412">    Status Read(size_t n, Slice* result, uint8_t* scratch) override {</a>
<a name="ln413">      std::string output;</a>
<a name="ln414">      if (offset_ &lt; data_.size()) {</a>
<a name="ln415">        n = std::min(data_.size() - offset_, n);</a>
<a name="ln416">        memcpy(scratch, data_.data() + offset_, n);</a>
<a name="ln417">        offset_ += n;</a>
<a name="ln418">        *result = Slice(scratch, n);</a>
<a name="ln419">      } else {</a>
<a name="ln420">        return STATUS(InvalidArgument,</a>
<a name="ln421">            &quot;Attemp to read when it already reached eof.&quot;);</a>
<a name="ln422">      }</a>
<a name="ln423">      return Status::OK();</a>
<a name="ln424">    }</a>
<a name="ln425"> </a>
<a name="ln426">    Status Skip(uint64_t n) override {</a>
<a name="ln427">      if (offset_ &gt;= data_.size()) {</a>
<a name="ln428">        return STATUS(InvalidArgument,</a>
<a name="ln429">            &quot;Attemp to read when it already reached eof.&quot;);</a>
<a name="ln430">      }</a>
<a name="ln431">      // TODO(yhchiang): Currently doesn't handle the overflow case.</a>
<a name="ln432">      offset_ += n;</a>
<a name="ln433">      return Status::OK();</a>
<a name="ln434">    }</a>
<a name="ln435"> </a>
<a name="ln436">    const std::string&amp; filename() const override {</a>
<a name="ln437">      static const std::string kFilename = &quot;SeqStringSource&quot;;</a>
<a name="ln438">      return kFilename;</a>
<a name="ln439">    }</a>
<a name="ln440"> </a>
<a name="ln441">   private:</a>
<a name="ln442">    std::string data_;</a>
<a name="ln443">    size_t offset_;</a>
<a name="ln444">  };</a>
<a name="ln445"> </a>
<a name="ln446">  class StringSink : public WritableFile {</a>
<a name="ln447">   public:</a>
<a name="ln448">    explicit StringSink(std::string* contents)</a>
<a name="ln449">        : WritableFile(), contents_(contents) {}</a>
<a name="ln450">    virtual Status Truncate(uint64_t size) override {</a>
<a name="ln451">      contents_-&gt;resize(size);</a>
<a name="ln452">      return Status::OK();</a>
<a name="ln453">    }</a>
<a name="ln454">    virtual Status Close() override { return Status::OK(); }</a>
<a name="ln455">    virtual Status Flush() override { return Status::OK(); }</a>
<a name="ln456">    virtual Status Sync() override { return Status::OK(); }</a>
<a name="ln457">    virtual Status Append(const Slice&amp; slice) override {</a>
<a name="ln458">      contents_-&gt;append(slice.cdata(), slice.size());</a>
<a name="ln459">      return Status::OK();</a>
<a name="ln460">    }</a>
<a name="ln461"> </a>
<a name="ln462">   private:</a>
<a name="ln463">    std::string* contents_;</a>
<a name="ln464">  };</a>
<a name="ln465"> </a>
<a name="ln466">  explicit StringEnv(Env* t) : EnvWrapper(t) {}</a>
<a name="ln467">  virtual ~StringEnv() {}</a>
<a name="ln468"> </a>
<a name="ln469">  const std::string&amp; GetContent(const std::string&amp; f) { return files_[f]; }</a>
<a name="ln470"> </a>
<a name="ln471">  const Status WriteToNewFile(const std::string&amp; file_name,</a>
<a name="ln472">                              const std::string&amp; content) {</a>
<a name="ln473">    unique_ptr&lt;WritableFile&gt; r;</a>
<a name="ln474">    auto s = NewWritableFile(file_name, &amp;r, EnvOptions());</a>
<a name="ln475">    if (!s.ok()) {</a>
<a name="ln476">      return s;</a>
<a name="ln477">    }</a>
<a name="ln478">    RETURN_NOT_OK(r-&gt;Append(content));</a>
<a name="ln479">    RETURN_NOT_OK(r-&gt;Flush());</a>
<a name="ln480">    RETURN_NOT_OK(r-&gt;Close());</a>
<a name="ln481">    assert(files_[file_name] == content);</a>
<a name="ln482">    return Status::OK();</a>
<a name="ln483">  }</a>
<a name="ln484"> </a>
<a name="ln485">  // The following text is boilerplate that forwards all methods to target()</a>
<a name="ln486">  Status NewSequentialFile(const std::string&amp; f, unique_ptr&lt;SequentialFile&gt;* r,</a>
<a name="ln487">                           const EnvOptions&amp; options) override {</a>
<a name="ln488">    auto iter = files_.find(f);</a>
<a name="ln489">    if (iter == files_.end()) {</a>
<a name="ln490">      return STATUS(NotFound, &quot;The specified file does not exist&quot;, f);</a>
<a name="ln491">    }</a>
<a name="ln492">    r-&gt;reset(new SeqStringSource(iter-&gt;second));</a>
<a name="ln493">    return Status::OK();</a>
<a name="ln494">  }</a>
<a name="ln495">  Status NewRandomAccessFile(const std::string&amp; f,</a>
<a name="ln496">                             unique_ptr&lt;RandomAccessFile&gt;* r,</a>
<a name="ln497">                             const EnvOptions&amp; options) override {</a>
<a name="ln498">    return STATUS(NotSupported, &quot;&quot;);</a>
<a name="ln499">  }</a>
<a name="ln500">  Status NewWritableFile(const std::string&amp; f, unique_ptr&lt;WritableFile&gt;* r,</a>
<a name="ln501">                         const EnvOptions&amp; options) override {</a>
<a name="ln502">    auto iter = files_.find(f);</a>
<a name="ln503">    if (iter != files_.end()) {</a>
<a name="ln504">      return STATUS(IOError, &quot;The specified file already exists&quot;, f);</a>
<a name="ln505">    }</a>
<a name="ln506">    r-&gt;reset(new StringSink(&amp;files_[f]));</a>
<a name="ln507">    return Status::OK();</a>
<a name="ln508">  }</a>
<a name="ln509">  virtual Status NewDirectory(const std::string&amp; name,</a>
<a name="ln510">                              unique_ptr&lt;Directory&gt;* result) override {</a>
<a name="ln511">    return STATUS(NotSupported, &quot;&quot;);</a>
<a name="ln512">  }</a>
<a name="ln513">  Status FileExists(const std::string&amp; f) override {</a>
<a name="ln514">    if (files_.find(f) == files_.end()) {</a>
<a name="ln515">      return STATUS(NotFound, &quot;&quot;);</a>
<a name="ln516">    }</a>
<a name="ln517">    return Status::OK();</a>
<a name="ln518">  }</a>
<a name="ln519">  Status GetChildren(const std::string&amp; dir,</a>
<a name="ln520">                     std::vector&lt;std::string&gt;* r) override {</a>
<a name="ln521">    return STATUS(NotSupported, &quot;&quot;);</a>
<a name="ln522">  }</a>
<a name="ln523">  Status DeleteFile(const std::string&amp; f) override {</a>
<a name="ln524">    files_.erase(f);</a>
<a name="ln525">    return Status::OK();</a>
<a name="ln526">  }</a>
<a name="ln527">  Status CreateDir(const std::string&amp; d) override {</a>
<a name="ln528">    return STATUS(NotSupported, &quot;&quot;);</a>
<a name="ln529">  }</a>
<a name="ln530">  Status CreateDirIfMissing(const std::string&amp; d) override {</a>
<a name="ln531">    return STATUS(NotSupported, &quot;&quot;);</a>
<a name="ln532">  }</a>
<a name="ln533">  Status DeleteDir(const std::string&amp; d) override {</a>
<a name="ln534">    return STATUS(NotSupported, &quot;&quot;);</a>
<a name="ln535">  }</a>
<a name="ln536">  Status GetFileSize(const std::string&amp; f, uint64_t* s) override {</a>
<a name="ln537">    auto iter = files_.find(f);</a>
<a name="ln538">    if (iter == files_.end()) {</a>
<a name="ln539">      return STATUS(NotFound, &quot;The specified file does not exist:&quot;, f);</a>
<a name="ln540">    }</a>
<a name="ln541">    *s = iter-&gt;second.size();</a>
<a name="ln542">    return Status::OK();</a>
<a name="ln543">  }</a>
<a name="ln544"> </a>
<a name="ln545">  Status GetFileModificationTime(const std::string&amp; fname,</a>
<a name="ln546">                                 uint64_t* file_mtime) override {</a>
<a name="ln547">    return STATUS(NotSupported, &quot;&quot;);</a>
<a name="ln548">  }</a>
<a name="ln549"> </a>
<a name="ln550">  Status RenameFile(const std::string&amp; s, const std::string&amp; t) override {</a>
<a name="ln551">    return STATUS(NotSupported, &quot;&quot;);</a>
<a name="ln552">  }</a>
<a name="ln553"> </a>
<a name="ln554">  Status LinkFile(const std::string&amp; s, const std::string&amp; t) override {</a>
<a name="ln555">    return STATUS(NotSupported, &quot;&quot;);</a>
<a name="ln556">  }</a>
<a name="ln557"> </a>
<a name="ln558">  Status LockFile(const std::string&amp; f, FileLock** l) override {</a>
<a name="ln559">    return STATUS(NotSupported, &quot;&quot;);</a>
<a name="ln560">  }</a>
<a name="ln561"> </a>
<a name="ln562">  Status UnlockFile(FileLock* l) override { return STATUS(NotSupported, &quot;&quot;); }</a>
<a name="ln563"> </a>
<a name="ln564"> protected:</a>
<a name="ln565">  std::unordered_map&lt;std::string, std::string&gt; files_;</a>
<a name="ln566">};</a>
<a name="ln567"> </a>
<a name="ln568">// Randomly initialize the given DBOptions</a>
<a name="ln569">void RandomInitDBOptions(DBOptions* db_opt, Random* rnd);</a>
<a name="ln570"> </a>
<a name="ln571">// Randomly initialize the given ColumnFamilyOptions</a>
<a name="ln572">// Note that the caller is responsible for releasing non-null</a>
<a name="ln573">// cf_opt-&gt;compaction_filter.</a>
<a name="ln574">void RandomInitCFOptions(ColumnFamilyOptions* cf_opt, Random* rnd);</a>
<a name="ln575"> </a>
<a name="ln576">// A dummy merge operator which can change its name</a>
<a name="ln577">class ChanglingMergeOperator : public MergeOperator {</a>
<a name="ln578"> public:</a>
<a name="ln579">  explicit ChanglingMergeOperator(const std::string&amp; name)</a>
<a name="ln580">      : name_(name + &quot;MergeOperator&quot;) {}</a>
<a name="ln581">  ~ChanglingMergeOperator() {}</a>
<a name="ln582"> </a>
<a name="ln583">  void SetName(const std::string&amp; name) { name_ = name; }</a>
<a name="ln584"> </a>
<a name="ln585">  virtual bool FullMerge(const Slice&amp; key, const Slice* existing_value,</a>
<a name="ln586">                         const std::deque&lt;std::string&gt;&amp; operand_list,</a>
<a name="ln587">                         std::string* new_value,</a>
<a name="ln588">                         Logger* logger) const override {</a>
<a name="ln589">    return false;</a>
<a name="ln590">  }</a>
<a name="ln591">  virtual bool PartialMergeMulti(const Slice&amp; key,</a>
<a name="ln592">                                 const std::deque&lt;Slice&gt;&amp; operand_list,</a>
<a name="ln593">                                 std::string* new_value,</a>
<a name="ln594">                                 Logger* logger) const override {</a>
<a name="ln595">    return false;</a>
<a name="ln596">  }</a>
<a name="ln597">  virtual const char* Name() const override { return name_.c_str(); }</a>
<a name="ln598"> </a>
<a name="ln599"> protected:</a>
<a name="ln600">  std::string name_;</a>
<a name="ln601">};</a>
<a name="ln602"> </a>
<a name="ln603">// Returns a dummy merge operator with random name.</a>
<a name="ln604">MergeOperator* RandomMergeOperator(Random* rnd);</a>
<a name="ln605"> </a>
<a name="ln606">// A dummy compaction filter which can change its name</a>
<a name="ln607">class ChanglingCompactionFilter : public CompactionFilter {</a>
<a name="ln608"> public:</a>
<a name="ln609">  explicit ChanglingCompactionFilter(const std::string&amp; name)</a>
<a name="ln610">      : name_(name + &quot;CompactionFilter&quot;) {}</a>
<a name="ln611">  ~ChanglingCompactionFilter() {}</a>
<a name="ln612"> </a>
<a name="ln613">  void SetName(const std::string&amp; name) { name_ = name; }</a>
<a name="ln614"> </a>
<a name="ln615">  FilterDecision Filter(</a>
<a name="ln616">      int level, const Slice&amp; key, const Slice&amp; existing_value, std::string* new_value,</a>
<a name="ln617">      bool* value_changed) override {</a>
<a name="ln618">    return FilterDecision::kKeep;</a>
<a name="ln619">  }</a>
<a name="ln620"> </a>
<a name="ln621">  const char* Name() const override { return name_.c_str(); }</a>
<a name="ln622"> </a>
<a name="ln623"> private:</a>
<a name="ln624">  std::string name_;</a>
<a name="ln625">};</a>
<a name="ln626"> </a>
<a name="ln627">// Returns a dummy compaction filter with a random name.</a>
<a name="ln628">CompactionFilter* RandomCompactionFilter(Random* rnd);</a>
<a name="ln629"> </a>
<a name="ln630">// A dummy compaction filter factory which can change its name</a>
<a name="ln631">class ChanglingCompactionFilterFactory : public CompactionFilterFactory {</a>
<a name="ln632"> public:</a>
<a name="ln633">  explicit ChanglingCompactionFilterFactory(const std::string&amp; name)</a>
<a name="ln634">      : name_(name + &quot;CompactionFilterFactory&quot;) {}</a>
<a name="ln635">  ~ChanglingCompactionFilterFactory() {}</a>
<a name="ln636"> </a>
<a name="ln637">  void SetName(const std::string&amp; name) { name_ = name; }</a>
<a name="ln638"> </a>
<a name="ln639">  std::unique_ptr&lt;CompactionFilter&gt; CreateCompactionFilter(</a>
<a name="ln640">      const CompactionFilter::Context&amp; context) override {</a>
<a name="ln641">    return std::unique_ptr&lt;CompactionFilter&gt;();</a>
<a name="ln642">  }</a>
<a name="ln643"> </a>
<a name="ln644">  // Returns a name that identifies this compaction filter factory.</a>
<a name="ln645">  const char* Name() const override { return name_.c_str(); }</a>
<a name="ln646"> </a>
<a name="ln647"> protected:</a>
<a name="ln648">  std::string name_;</a>
<a name="ln649">};</a>
<a name="ln650"> </a>
<a name="ln651">CompressionType RandomCompressionType(Random* rnd);</a>
<a name="ln652"> </a>
<a name="ln653">void RandomCompressionTypeVector(const size_t count,</a>
<a name="ln654">                                 std::vector&lt;CompressionType&gt;* types,</a>
<a name="ln655">                                 Random* rnd);</a>
<a name="ln656"> </a>
<a name="ln657">CompactionFilterFactory* RandomCompactionFilterFactory(Random* rnd);</a>
<a name="ln658"> </a>
<a name="ln659">const SliceTransform* RandomSliceTransform(Random* rnd, int pre_defined = -1);</a>
<a name="ln660"> </a>
<a name="ln661">TableFactory* RandomTableFactory(Random* rnd, int pre_defined = -1);</a>
<a name="ln662"> </a>
<a name="ln663">std::string RandomName(Random* rnd, const size_t len);</a>
<a name="ln664"> </a>
<a name="ln665">std::shared_ptr&lt;BoundaryValuesExtractor&gt; MakeBoundaryValuesExtractor();</a>
<a name="ln666">UserBoundaryValuePtr MakeIntBoundaryValue(int64_t value);</a>
<a name="ln667">UserBoundaryValuePtr MakeStringBoundaryValue(std::string value);</a>
<a name="ln668">int64_t GetBoundaryInt(const UserBoundaryValues&amp; values);</a>
<a name="ln669">std::string GetBoundaryString(const UserBoundaryValues&amp; values);</a>
<a name="ln670"> </a>
<a name="ln671">struct BoundaryTestValues {</a>
<a name="ln672">  void Feed(Slice key);</a>
<a name="ln673">  void Check(const FileBoundaryValues&lt;InternalKey&gt;&amp; smallest,</a>
<a name="ln674">             const FileBoundaryValues&lt;InternalKey&gt;&amp; largest);</a>
<a name="ln675"> </a>
<a name="ln676">  int64_t min_int = std::numeric_limits&lt;int64_t&gt;::max();</a>
<a name="ln677">  int64_t max_int = std::numeric_limits&lt;int64_t&gt;::min();</a>
<a name="ln678">  std::string min_string;</a>
<a name="ln679">  std::string max_string;</a>
<a name="ln680">};</a>
<a name="ln681"> </a>
<a name="ln682">// A test implementation of UserFrontier, wrapper over simple int64_t value.</a>
<a name="ln683">class TestUserFrontier : public UserFrontier {</a>
<a name="ln684"> public:</a>
<a name="ln685">  TestUserFrontier() : value_(0) {}</a>
<a name="ln686">  explicit TestUserFrontier(uint64_t value) : value_(value) {}</a>
<a name="ln687"> </a>
<a name="ln688">  std::unique_ptr&lt;UserFrontier&gt; Clone() const override {</a>
<a name="ln689">    return std::make_unique&lt;TestUserFrontier&gt;(*this);</a>
<a name="ln690">  }</a>
<a name="ln691"> </a>
<a name="ln692">  void SetValue(uint64_t value) {</a>
<a name="ln693">    value_ = value;</a>
<a name="ln694">  }</a>
<a name="ln695"> </a>
<a name="ln696">  uint64_t Value() const {</a>
<a name="ln697">    return value_;</a>
<a name="ln698">  }</a>
<a name="ln699"> </a>
<a name="ln700">  std::string ToString() const override {</a>
<a name="ln701">    return yb::Format(&quot;{ value: $0 }&quot;, value_);</a>
<a name="ln702">  }</a>
<a name="ln703"> </a>
<a name="ln704">  void ToPB(google::protobuf::Any* pb) const override {</a>
<a name="ln705">    UserBoundaryValuePB value;</a>
<a name="ln706">    value.set_tag(static_cast&lt;uint32_t&gt;(value_));</a>
<a name="ln707">    pb-&gt;PackFrom(value);</a>
<a name="ln708">  }</a>
<a name="ln709"> </a>
<a name="ln710">  bool Equals(const UserFrontier&amp; rhs) const override {</a>
<a name="ln711">    return value_ == down_cast&lt;const TestUserFrontier&amp;&gt;(rhs).value_;</a>
<a name="ln712">  }</a>
<a name="ln713"> </a>
<a name="ln714">  void Update(const UserFrontier&amp; rhs, UpdateUserValueType type) override {</a>
<a name="ln715">    auto rhs_value = down_cast&lt;const TestUserFrontier&amp;&gt;(rhs).value_;</a>
<a name="ln716">    switch (type) {</a>
<a name="ln717">      case UpdateUserValueType::kLargest:</a>
<a name="ln718">        value_ = std::max(value_, rhs_value);</a>
<a name="ln719">        return;</a>
<a name="ln720">      case UpdateUserValueType::kSmallest:</a>
<a name="ln721">        value_ = std::min(value_, rhs_value);</a>
<a name="ln722">        return;</a>
<a name="ln723">    }</a>
<a name="ln724">    FATAL_INVALID_ENUM_VALUE(UpdateUserValueType, type);</a>
<a name="ln725">  }</a>
<a name="ln726"> </a>
<a name="ln727">  bool IsUpdateValid(const UserFrontier&amp; rhs, UpdateUserValueType type) const override {</a>
<a name="ln728">    auto rhs_value = down_cast&lt;const TestUserFrontier&amp;&gt;(rhs).value_;</a>
<a name="ln729">    switch (type) {</a>
<a name="ln730">      case UpdateUserValueType::kLargest:</a>
<a name="ln731">        return rhs_value &gt;= value_;</a>
<a name="ln732">      case UpdateUserValueType::kSmallest:</a>
<a name="ln733">        return rhs_value &lt;= value_;</a>
<a name="ln734">    }</a>
<a name="ln735">    FATAL_INVALID_ENUM_VALUE(UpdateUserValueType, type);</a>
<a name="ln736">  }</a>
<a name="ln737"> </a>
<a name="ln738">  void FromOpIdPBDeprecated(const yb::OpIdPB&amp; op_id) override {}</a>
<a name="ln739"> </a>
<a name="ln740">  void FromPB(const google::protobuf::Any&amp; pb) override {</a>
<a name="ln741">    UserBoundaryValuePB value;</a>
<a name="ln742">    pb.UnpackTo(&amp;value);</a>
<a name="ln743">    value_ = value.tag();</a>
<a name="ln744">  }</a>
<a name="ln745"> </a>
<a name="ln746">  Slice Filter() const override {</a>
<a name="ln747">    return Slice();</a>
<a name="ln748">  }</a>
<a name="ln749"> </a>
<a name="ln750"> private:</a>
<a name="ln751">  uint64_t value_ = 0;</a>
<a name="ln752">};</a>
<a name="ln753"> </a>
<a name="ln754">class TestUserFrontiers : public rocksdb::UserFrontiersBase&lt;TestUserFrontier&gt; {</a>
<a name="ln755"> public:</a>
<a name="ln756">  TestUserFrontiers(uint64_t min, uint64_t max) {</a>
<a name="ln757">    Smallest().SetValue(min);</a>
<a name="ln758">    Largest().SetValue(max);</a>
<a name="ln759">  }</a>
<a name="ln760"> </a>
<a name="ln761">  std::unique_ptr&lt;UserFrontiers&gt; Clone() const {</a>
<a name="ln762">    return std::make_unique&lt;TestUserFrontiers&gt;(*this);</a>
<a name="ln763">  }</a>
<a name="ln764">};</a>
<a name="ln765"> </a>
<a name="ln766">// A class which remembers the name of each flushed file.</a>
<a name="ln767">class FlushedFileCollector : public EventListener {</a>
<a name="ln768"> public:</a>
<a name="ln769">  virtual void OnFlushCompleted(DB* db, const FlushJobInfo&amp; info) override {</a>
<a name="ln770">    std::lock_guard&lt;std::mutex&gt; lock(mutex_);</a>
<a name="ln771">    flushed_file_infos_.push_back(info);</a>
<a name="ln772">  }</a>
<a name="ln773"> </a>
<a name="ln774">  std::vector&lt;std::string&gt; GetFlushedFiles() {</a>
<a name="ln775">    std::vector&lt;std::string&gt; flushed_files;</a>
<a name="ln776">    std::lock_guard&lt;std::mutex&gt; lock(mutex_);</a>
<a name="ln777">    for (const auto&amp; info : flushed_file_infos_) {</a>
<a name="ln778">      flushed_files.push_back(info.file_path);</a>
<a name="ln779">    }</a>
<a name="ln780">    return flushed_files;</a>
<a name="ln781">  }</a>
<a name="ln782"> </a>
<a name="ln783">  std::vector&lt;std::string&gt; GetAndClearFlushedFiles() {</a>
<a name="ln784">    std::vector&lt;std::string&gt; flushed_files;</a>
<a name="ln785">    std::lock_guard&lt;std::mutex&gt; lock(mutex_);</a>
<a name="ln786">    for (const auto&amp; info : flushed_file_infos_) {</a>
<a name="ln787">      flushed_files.push_back(info.file_path);</a>
<a name="ln788">    }</a>
<a name="ln789">    flushed_file_infos_.clear();</a>
<a name="ln790">    return flushed_files;</a>
<a name="ln791">  }</a>
<a name="ln792"> </a>
<a name="ln793">  std::vector&lt;FlushJobInfo&gt; GetFlushedFileInfos() {</a>
<a name="ln794">    std::lock_guard&lt;std::mutex&gt; lock(mutex_);</a>
<a name="ln795">    return flushed_file_infos_;</a>
<a name="ln796">  }</a>
<a name="ln797"> </a>
<a name="ln798">  void Clear() {</a>
<a name="ln799">    std::lock_guard&lt;std::mutex&gt; lock(mutex_);</a>
<a name="ln800">    flushed_file_infos_.clear();</a>
<a name="ln801">  }</a>
<a name="ln802"> </a>
<a name="ln803"> private:</a>
<a name="ln804">  std::vector&lt;FlushJobInfo&gt; flushed_file_infos_;</a>
<a name="ln805">  std::mutex mutex_;</a>
<a name="ln806">};</a>
<a name="ln807"> </a>
<a name="ln808">}  // namespace test</a>
<a name="ln809">}  // namespace rocksdb</a>
<a name="ln810"> </a>
<a name="ln811">#endif // YB_ROCKSDB_UTIL_TESTUTIL_H</a>

</code></pre>
<div class="balloon" rel="757"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1053/" target="_blank">V1053</a> Calling the 'Smallest' virtual function in the constructor may lead to unexpected result at runtime.</p></div>
<div class="balloon" rel="758"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1053/" target="_blank">V1053</a> Calling the 'Largest' virtual function in the constructor may lead to unexpected result at runtime.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
