
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>partial_row.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Licensed to the Apache Software Foundation (ASF) under one</a>
<a name="ln2">// or more contributor license agreements.  See the NOTICE file</a>
<a name="ln3">// distributed with this work for additional information</a>
<a name="ln4">// regarding copyright ownership.  The ASF licenses this file</a>
<a name="ln5">// to you under the Apache License, Version 2.0 (the</a>
<a name="ln6">// &quot;License&quot;); you may not use this file except in compliance</a>
<a name="ln7">// with the License.  You may obtain a copy of the License at</a>
<a name="ln8">//</a>
<a name="ln9">//   http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln10">//</a>
<a name="ln11">// Unless required by applicable law or agreed to in writing,</a>
<a name="ln12">// software distributed under the License is distributed on an</a>
<a name="ln13">// &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</a>
<a name="ln14">// KIND, either express or implied.  See the License for the</a>
<a name="ln15">// specific language governing permissions and limitations</a>
<a name="ln16">// under the License.</a>
<a name="ln17">//</a>
<a name="ln18">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln19">//</a>
<a name="ln20">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln21">//</a>
<a name="ln22">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln23">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln24">//</a>
<a name="ln25">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln26">//</a>
<a name="ln27">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln28">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln29">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln30">// under the License.</a>
<a name="ln31">//</a>
<a name="ln32"> </a>
<a name="ln33">#include &quot;yb/common/partial_row.h&quot;</a>
<a name="ln34"> </a>
<a name="ln35">#include &lt;algorithm&gt;</a>
<a name="ln36">#include &lt;cstring&gt;</a>
<a name="ln37">#include &lt;string&gt;</a>
<a name="ln38"> </a>
<a name="ln39">#include &quot;yb/common/common.pb.h&quot;</a>
<a name="ln40">#include &quot;yb/common/row.h&quot;</a>
<a name="ln41">#include &quot;yb/common/schema.h&quot;</a>
<a name="ln42">#include &quot;yb/common/wire_protocol.pb.h&quot;</a>
<a name="ln43">#include &quot;yb/gutil/strings/substitute.h&quot;</a>
<a name="ln44">#include &quot;yb/util/bitmap.h&quot;</a>
<a name="ln45">#include &quot;yb/util/status.h&quot;</a>
<a name="ln46">#include &quot;yb/util/decimal.h&quot;</a>
<a name="ln47"> </a>
<a name="ln48">using strings::Substitute;</a>
<a name="ln49"> </a>
<a name="ln50">namespace yb {</a>
<a name="ln51"> </a>
<a name="ln52">namespace {</a>
<a name="ln53">inline Status FindColumn(const Schema&amp; schema, const Slice&amp; col_name, int* idx) {</a>
<a name="ln54">  GStringPiece sp(reinterpret_cast&lt;const char*&gt;(col_name.data()), col_name.size());</a>
<a name="ln55">  *idx = schema.find_column(sp);</a>
<a name="ln56">  if (PREDICT_FALSE(*idx == -1)) {</a>
<a name="ln57">    return STATUS(NotFound, &quot;No such column&quot;, col_name);</a>
<a name="ln58">  }</a>
<a name="ln59">  return Status::OK();</a>
<a name="ln60">}</a>
<a name="ln61">} // anonymous namespace</a>
<a name="ln62"> </a>
<a name="ln63">YBPartialRow::YBPartialRow(const Schema* schema)</a>
<a name="ln64">  : schema_(schema) {</a>
<a name="ln65">  DCHECK(schema_-&gt;initialized());</a>
<a name="ln66">  size_t column_bitmap_size = BitmapSize(schema_-&gt;num_columns());</a>
<a name="ln67">  size_t row_size = ContiguousRowHelper::row_size(*schema);</a>
<a name="ln68"> </a>
<a name="ln69">  auto dst = new uint8_t[2 * column_bitmap_size + row_size];</a>
<a name="ln70">  isset_bitmap_ = dst;</a>
<a name="ln71">  owned_strings_bitmap_ = isset_bitmap_ + column_bitmap_size;</a>
<a name="ln72"> </a>
<a name="ln73">  memset(isset_bitmap_, 0, 2 * column_bitmap_size);</a>
<a name="ln74"> </a>
<a name="ln75">  row_data_ = owned_strings_bitmap_ + column_bitmap_size;</a>
<a name="ln76">#ifndef NDEBUG</a>
<a name="ln77">  OverwriteWithPattern(reinterpret_cast&lt;char*&gt;(row_data_),</a>
<a name="ln78">                       row_size, &quot;NEWNEWNEWNEWNEW&quot;);</a>
<a name="ln79">#endif</a>
<a name="ln80">  ContiguousRowHelper::InitNullsBitmap(</a>
<a name="ln81">    *schema_, row_data_, ContiguousRowHelper::null_bitmap_size(*schema_));</a>
<a name="ln82">}</a>
<a name="ln83"> </a>
<a name="ln84">YBPartialRow::~YBPartialRow() {</a>
<a name="ln85">  DeallocateOwnedStrings();</a>
<a name="ln86">  // Both the row data and bitmap came from the same allocation.</a>
<a name="ln87">  // The bitmap is at the start of it.</a>
<a name="ln88">  delete [] isset_bitmap_;</a>
<a name="ln89">}</a>
<a name="ln90"> </a>
<a name="ln91">YBPartialRow::YBPartialRow(const YBPartialRow&amp; other)</a>
<a name="ln92">    : schema_(other.schema_) {</a>
<a name="ln93">  size_t column_bitmap_size = BitmapSize(schema_-&gt;num_columns());</a>
<a name="ln94">  size_t row_size = ContiguousRowHelper::row_size(*schema_);</a>
<a name="ln95"> </a>
<a name="ln96">  size_t len = 2 * column_bitmap_size + row_size;</a>
<a name="ln97">  isset_bitmap_ = new uint8_t[len];</a>
<a name="ln98">  owned_strings_bitmap_ = isset_bitmap_ + column_bitmap_size;</a>
<a name="ln99">  row_data_ = owned_strings_bitmap_ + column_bitmap_size;</a>
<a name="ln100"> </a>
<a name="ln101">  // Copy all bitmaps and row data.</a>
<a name="ln102">  memcpy(isset_bitmap_, other.isset_bitmap_, len);</a>
<a name="ln103"> </a>
<a name="ln104">  // Copy owned strings.</a>
<a name="ln105">  for (int col_idx = 0; col_idx &lt; schema_-&gt;num_columns(); col_idx++) {</a>
<a name="ln106">    if (BitmapTest(owned_strings_bitmap_, col_idx)) {</a>
<a name="ln107">      ContiguousRow row(schema_, row_data_);</a>
<a name="ln108">      Slice* slice = reinterpret_cast&lt;Slice*&gt;(row.mutable_cell_ptr(col_idx));</a>
<a name="ln109">      auto data = new uint8_t[slice-&gt;size()];</a>
<a name="ln110">      slice-&gt;relocate(data);</a>
<a name="ln111">    }</a>
<a name="ln112">  }</a>
<a name="ln113">}</a>
<a name="ln114"> </a>
<a name="ln115">YBPartialRow&amp; YBPartialRow::operator=(YBPartialRow other) {</a>
<a name="ln116">  std::swap(schema_, other.schema_);</a>
<a name="ln117">  std::swap(isset_bitmap_, other.isset_bitmap_);</a>
<a name="ln118">  std::swap(owned_strings_bitmap_, other.owned_strings_bitmap_);</a>
<a name="ln119">  std::swap(row_data_, other.row_data_);</a>
<a name="ln120">  return *this;</a>
<a name="ln121">}</a>
<a name="ln122"> </a>
<a name="ln123">template&lt;typename T&gt;</a>
<a name="ln124">Status YBPartialRow::Set(const Slice&amp; col_name,</a>
<a name="ln125">                         const typename T::cpp_type&amp; val,</a>
<a name="ln126">                         bool owned) {</a>
<a name="ln127">  int col_idx;</a>
<a name="ln128">  RETURN_NOT_OK(FindColumn(*schema_, col_name, &amp;col_idx));</a>
<a name="ln129">  return Set&lt;T&gt;(col_idx, val, owned);</a>
<a name="ln130">}</a>
<a name="ln131"> </a>
<a name="ln132">template&lt;typename T&gt;</a>
<a name="ln133">Status YBPartialRow::Set(int col_idx,</a>
<a name="ln134">                         const typename T::cpp_type&amp; val,</a>
<a name="ln135">                         bool owned) {</a>
<a name="ln136">  const ColumnSchema&amp; col = schema_-&gt;column(col_idx);</a>
<a name="ln137">  if (PREDICT_FALSE(col.type_info()-&gt;type() != T::type)) {</a>
<a name="ln138">    // TODO: at some point we could allow type coercion here.</a>
<a name="ln139">    return STATUS(InvalidArgument,</a>
<a name="ln140">      Substitute(&quot;invalid type $0 provided for column '$1' (expected $2)&quot;,</a>
<a name="ln141">                 T::name(),</a>
<a name="ln142">                 col.name(), col.type_info()-&gt;name()));</a>
<a name="ln143">  }</a>
<a name="ln144"> </a>
<a name="ln145">  ContiguousRow row(schema_, row_data_);</a>
<a name="ln146"> </a>
<a name="ln147">  // If we're replacing an existing STRING/BINARY/INET value, deallocate the old value.</a>
<a name="ln148">  if (T::physical_type == BINARY) DeallocateStringIfSet(col_idx, col);</a>
<a name="ln149"> </a>
<a name="ln150">  // Mark the column as set.</a>
<a name="ln151">  BitmapSet(isset_bitmap_, col_idx);</a>
<a name="ln152"> </a>
<a name="ln153">  if (col.is_nullable()) {</a>
<a name="ln154">    row.set_null(col_idx, false);</a>
<a name="ln155">  }</a>
<a name="ln156"> </a>
<a name="ln157">  ContiguousRowCell&lt;ContiguousRow&gt; dst(&amp;row, col_idx);</a>
<a name="ln158">  memcpy(dst.mutable_ptr(), &amp;val, sizeof(val));</a>
<a name="ln159">  if (owned) {</a>
<a name="ln160">    BitmapSet(owned_strings_bitmap_, col_idx);</a>
<a name="ln161">  }</a>
<a name="ln162">  return Status::OK();</a>
<a name="ln163">}</a>
<a name="ln164"> </a>
<a name="ln165">Status YBPartialRow::Set(int32_t column_idx, const uint8_t* val) {</a>
<a name="ln166">  const ColumnSchema&amp; column_schema = schema()-&gt;column(column_idx);</a>
<a name="ln167"> </a>
<a name="ln168">  switch (column_schema.type_info()-&gt;type()) {</a>
<a name="ln169">    case BOOL: {</a>
<a name="ln170">      RETURN_NOT_OK(SetBool(column_idx, *reinterpret_cast&lt;const bool*&gt;(val)));</a>
<a name="ln171">      break;</a>
<a name="ln172">    };</a>
<a name="ln173">    case INT8: {</a>
<a name="ln174">      RETURN_NOT_OK(SetInt8(column_idx, *reinterpret_cast&lt;const int8_t*&gt;(val)));</a>
<a name="ln175">      break;</a>
<a name="ln176">    };</a>
<a name="ln177">    case INT16: {</a>
<a name="ln178">      RETURN_NOT_OK(SetInt16(column_idx, *reinterpret_cast&lt;const int16_t*&gt;(val)));</a>
<a name="ln179">      break;</a>
<a name="ln180">    };</a>
<a name="ln181">    case INT32: {</a>
<a name="ln182">      RETURN_NOT_OK(SetInt32(column_idx, *reinterpret_cast&lt;const int32_t*&gt;(val)));</a>
<a name="ln183">      break;</a>
<a name="ln184">    };</a>
<a name="ln185">    case INT64: {</a>
<a name="ln186">      RETURN_NOT_OK(SetInt64(column_idx, *reinterpret_cast&lt;const int64_t*&gt;(val)));</a>
<a name="ln187">      break;</a>
<a name="ln188">    };</a>
<a name="ln189">    case FLOAT: {</a>
<a name="ln190">      RETURN_NOT_OK(SetFloat(column_idx, *reinterpret_cast&lt;const float*&gt;(val)));</a>
<a name="ln191">      break;</a>
<a name="ln192">    };</a>
<a name="ln193">    case DOUBLE: {</a>
<a name="ln194">      RETURN_NOT_OK(SetDouble(column_idx, *reinterpret_cast&lt;const double*&gt;(val)));</a>
<a name="ln195">      break;</a>
<a name="ln196">    };</a>
<a name="ln197">    case STRING: {</a>
<a name="ln198">      RETURN_NOT_OK(SetStringCopy(column_idx, *reinterpret_cast&lt;const Slice*&gt;(val)));</a>
<a name="ln199">      break;</a>
<a name="ln200">    };</a>
<a name="ln201">    case BINARY: {</a>
<a name="ln202">      RETURN_NOT_OK(SetBinaryCopy(column_idx, *reinterpret_cast&lt;const Slice*&gt;(val)));</a>
<a name="ln203">      break;</a>
<a name="ln204">    };</a>
<a name="ln205">    case TIMESTAMP: {</a>
<a name="ln206">      RETURN_NOT_OK(SetTimestamp(column_idx, *reinterpret_cast&lt;const int64_t*&gt;(val)));</a>
<a name="ln207">      break;</a>
<a name="ln208">    };</a>
<a name="ln209">    case INET: {</a>
<a name="ln210">      RETURN_NOT_OK(SetInet(column_idx, *reinterpret_cast&lt;const Slice*&gt;(val)));</a>
<a name="ln211">      break;</a>
<a name="ln212">    };</a>
<a name="ln213">    case JSONB: {</a>
<a name="ln214">      RETURN_NOT_OK(SetJsonb(column_idx, *reinterpret_cast&lt;const Slice*&gt;(val)));</a>
<a name="ln215">      break;</a>
<a name="ln216">    };</a>
<a name="ln217">    case UUID: {</a>
<a name="ln218">      RETURN_NOT_OK(SetUuidCopy(column_idx, *reinterpret_cast&lt;const Slice*&gt;(val)));</a>
<a name="ln219">      break;</a>
<a name="ln220">    };</a>
<a name="ln221">    case TIMEUUID: {</a>
<a name="ln222">      RETURN_NOT_OK(SetTimeUuidCopy(column_idx, *reinterpret_cast&lt;const Slice*&gt;(val)));</a>
<a name="ln223">      break;</a>
<a name="ln224">    }</a>
<a name="ln225">    case FROZEN: {</a>
<a name="ln226">      RETURN_NOT_OK(SetFrozenCopy(column_idx, *reinterpret_cast&lt;const Slice*&gt;(val)));</a>
<a name="ln227">      break;</a>
<a name="ln228">    };</a>
<a name="ln229">    case DECIMAL: FALLTHROUGH_INTENDED;</a>
<a name="ln230">    default: {</a>
<a name="ln231">      return STATUS(InvalidArgument, &quot;Unknown column type in schema&quot;,</a>
<a name="ln232">                                     column_schema.ToString());</a>
<a name="ln233">    };</a>
<a name="ln234">  }</a>
<a name="ln235">  return Status::OK();</a>
<a name="ln236">}</a>
<a name="ln237"> </a>
<a name="ln238">void YBPartialRow::DeallocateStringIfSet(int col_idx, const ColumnSchema&amp; col) {</a>
<a name="ln239">  if (BitmapTest(owned_strings_bitmap_, col_idx)) {</a>
<a name="ln240">    ContiguousRow row(schema_, row_data_);</a>
<a name="ln241">    const Slice* dst;</a>
<a name="ln242">    if (col.type_info()-&gt;type() == BINARY) {</a>
<a name="ln243">      dst = schema_-&gt;ExtractColumnFromRow&lt;BINARY&gt;(row, col_idx);</a>
<a name="ln244">    } else if (col.type_info()-&gt;type() == INET) {</a>
<a name="ln245">      dst = schema_-&gt;ExtractColumnFromRow&lt;INET&gt;(row, col_idx);</a>
<a name="ln246">    } else if (col.type_info()-&gt;type() == JSONB) {</a>
<a name="ln247">      dst = schema_-&gt;ExtractColumnFromRow&lt;JSONB&gt;(row, col_idx);</a>
<a name="ln248">    } else if (col.type_info()-&gt;type() == UUID) {</a>
<a name="ln249">      dst = schema_-&gt;ExtractColumnFromRow&lt;UUID&gt;(row, col_idx);</a>
<a name="ln250">    } else if (col.type_info()-&gt;type() == TIMEUUID) {</a>
<a name="ln251">      dst = schema_-&gt;ExtractColumnFromRow&lt;TIMEUUID&gt;(row, col_idx);</a>
<a name="ln252">    } else if (col.type_info()-&gt;type() == FROZEN) {</a>
<a name="ln253">      dst = schema_-&gt;ExtractColumnFromRow&lt;FROZEN&gt;(row, col_idx);</a>
<a name="ln254">    } else {</a>
<a name="ln255">      CHECK(col.type_info()-&gt;type() == STRING);</a>
<a name="ln256">      dst = schema_-&gt;ExtractColumnFromRow&lt;STRING&gt;(row, col_idx);</a>
<a name="ln257">    }</a>
<a name="ln258">    delete [] dst-&gt;data();</a>
<a name="ln259">    BitmapClear(owned_strings_bitmap_, col_idx);</a>
<a name="ln260">  }</a>
<a name="ln261">}</a>
<a name="ln262"> </a>
<a name="ln263">void YBPartialRow::DeallocateOwnedStrings() {</a>
<a name="ln264">  for (int i = 0; i &lt; schema_-&gt;num_columns(); i++) {</a>
<a name="ln265">    DeallocateStringIfSet(i, schema_-&gt;column(i));</a>
<a name="ln266">  }</a>
<a name="ln267">}</a>
<a name="ln268"> </a>
<a name="ln269">//------------------------------------------------------------</a>
<a name="ln270">// Setters</a>
<a name="ln271">//------------------------------------------------------------</a>
<a name="ln272"> </a>
<a name="ln273">Status YBPartialRow::SetBool(const Slice&amp; col_name, bool val) {</a>
<a name="ln274">  return Set&lt;TypeTraits&lt;BOOL&gt; &gt;(col_name, val);</a>
<a name="ln275">}</a>
<a name="ln276">Status YBPartialRow::SetInt8(const Slice&amp; col_name, int8_t val) {</a>
<a name="ln277">  return Set&lt;TypeTraits&lt;INT8&gt; &gt;(col_name, val);</a>
<a name="ln278">}</a>
<a name="ln279">Status YBPartialRow::SetInt16(const Slice&amp; col_name, int16_t val) {</a>
<a name="ln280">  return Set&lt;TypeTraits&lt;INT16&gt; &gt;(col_name, val);</a>
<a name="ln281">}</a>
<a name="ln282">Status YBPartialRow::SetInt32(const Slice&amp; col_name, int32_t val) {</a>
<a name="ln283">  return Set&lt;TypeTraits&lt;INT32&gt; &gt;(col_name, val);</a>
<a name="ln284">}</a>
<a name="ln285">Status YBPartialRow::SetInt64(const Slice&amp; col_name, int64_t val) {</a>
<a name="ln286">  return Set&lt;TypeTraits&lt;INT64&gt; &gt;(col_name, val);</a>
<a name="ln287">}</a>
<a name="ln288">Status YBPartialRow::SetTimestamp(const Slice&amp; col_name, int64_t val) {</a>
<a name="ln289">  return Set&lt;TypeTraits&lt;TIMESTAMP&gt; &gt;(col_name, val);</a>
<a name="ln290">}</a>
<a name="ln291">Status YBPartialRow::SetFloat(const Slice&amp; col_name, float val) {</a>
<a name="ln292">  return Set&lt;TypeTraits&lt;FLOAT&gt; &gt;(col_name, val);</a>
<a name="ln293">}</a>
<a name="ln294">Status YBPartialRow::SetDouble(const Slice&amp; col_name, double val) {</a>
<a name="ln295">  return Set&lt;TypeTraits&lt;DOUBLE&gt; &gt;(col_name, val);</a>
<a name="ln296">}</a>
<a name="ln297">Status YBPartialRow::SetString(const Slice&amp; col_name, const Slice&amp; val) {</a>
<a name="ln298">  return Set&lt;TypeTraits&lt;STRING&gt; &gt;(col_name, val, false);</a>
<a name="ln299">}</a>
<a name="ln300">Status YBPartialRow::SetBinary(const Slice&amp; col_name, const Slice&amp; val) {</a>
<a name="ln301">  return Set&lt;TypeTraits&lt;BINARY&gt; &gt;(col_name, val, false);</a>
<a name="ln302">}</a>
<a name="ln303">Status YBPartialRow::SetFrozen(const Slice&amp; col_name, const Slice&amp; val) {</a>
<a name="ln304">  return Set&lt;TypeTraits&lt;FROZEN&gt; &gt;(col_name, val, false);</a>
<a name="ln305">}</a>
<a name="ln306">Status YBPartialRow::SetInet(const Slice&amp; col_name, const Slice&amp; val) {</a>
<a name="ln307">  return SetSliceCopy&lt;TypeTraits&lt;INET&gt; &gt;(col_name, val);</a>
<a name="ln308">}</a>
<a name="ln309">Status YBPartialRow::SetUuid(const Slice&amp; col_name, const Slice&amp; val) {</a>
<a name="ln310">  return Set&lt;TypeTraits&lt;UUID&gt; &gt;(col_name, val, false);</a>
<a name="ln311">}</a>
<a name="ln312">Status YBPartialRow::SetTimeUuid(const Slice&amp; col_name, const Slice&amp; val) {</a>
<a name="ln313">  return Set&lt;TypeTraits&lt;TIMEUUID&gt; &gt;(col_name, val, false);</a>
<a name="ln314">}</a>
<a name="ln315">Status YBPartialRow::SetDecimal(const Slice&amp; col_name, const Slice&amp; val) {</a>
<a name="ln316">  return Set&lt;TypeTraits&lt;DECIMAL&gt; &gt;(col_name, val, false);</a>
<a name="ln317">}</a>
<a name="ln318">Status YBPartialRow::SetBool(int col_idx, bool val) {</a>
<a name="ln319">  return Set&lt;TypeTraits&lt;BOOL&gt; &gt;(col_idx, val);</a>
<a name="ln320">}</a>
<a name="ln321">Status YBPartialRow::SetInt8(int col_idx, int8_t val) {</a>
<a name="ln322">  return Set&lt;TypeTraits&lt;INT8&gt; &gt;(col_idx, val);</a>
<a name="ln323">}</a>
<a name="ln324">Status YBPartialRow::SetInt16(int col_idx, int16_t val) {</a>
<a name="ln325">  return Set&lt;TypeTraits&lt;INT16&gt; &gt;(col_idx, val);</a>
<a name="ln326">}</a>
<a name="ln327">Status YBPartialRow::SetInt32(int col_idx, int32_t val) {</a>
<a name="ln328">  return Set&lt;TypeTraits&lt;INT32&gt; &gt;(col_idx, val);</a>
<a name="ln329">}</a>
<a name="ln330">Status YBPartialRow::SetInt64(int col_idx, int64_t val) {</a>
<a name="ln331">  return Set&lt;TypeTraits&lt;INT64&gt; &gt;(col_idx, val);</a>
<a name="ln332">}</a>
<a name="ln333">Status YBPartialRow::SetTimestamp(int col_idx, int64_t val) {</a>
<a name="ln334">  return Set&lt;TypeTraits&lt;TIMESTAMP&gt; &gt;(col_idx, val);</a>
<a name="ln335">}</a>
<a name="ln336">Status YBPartialRow::SetString(int col_idx, const Slice&amp; val) {</a>
<a name="ln337">  return Set&lt;TypeTraits&lt;STRING&gt; &gt;(col_idx, val, false);</a>
<a name="ln338">}</a>
<a name="ln339">Status YBPartialRow::SetBinary(int col_idx, const Slice&amp; val) {</a>
<a name="ln340">  return Set&lt;TypeTraits&lt;BINARY&gt; &gt;(col_idx, val, false);</a>
<a name="ln341">}</a>
<a name="ln342">Status YBPartialRow::SetFrozen(int col_idx, const Slice&amp; val) {</a>
<a name="ln343">  return Set&lt;TypeTraits&lt;FROZEN&gt; &gt;(col_idx, val, false);</a>
<a name="ln344">}</a>
<a name="ln345">Status YBPartialRow::SetInet(int col_idx, const Slice&amp; val) {</a>
<a name="ln346">  return SetSliceCopy&lt;TypeTraits&lt;INET&gt; &gt;(col_idx, val);</a>
<a name="ln347">}</a>
<a name="ln348">Status YBPartialRow::SetJsonb(int col_idx, const Slice&amp; val) {</a>
<a name="ln349">  return SetSliceCopy&lt;TypeTraits&lt;JSONB&gt; &gt;(col_idx, val);</a>
<a name="ln350">}</a>
<a name="ln351">Status YBPartialRow::SetUuid(int col_idx, const Slice&amp; val) {</a>
<a name="ln352">  return Set&lt;TypeTraits&lt;UUID&gt; &gt;(col_idx, val, false);</a>
<a name="ln353">}</a>
<a name="ln354">Status YBPartialRow::SetTimeUuid(int col_idx, const Slice&amp; val) {</a>
<a name="ln355">  return Set&lt;TypeTraits&lt;TIMEUUID&gt; &gt;(col_idx, val, false);</a>
<a name="ln356">}</a>
<a name="ln357">Status YBPartialRow::SetDecimal(int col_idx, const Slice&amp; val) {</a>
<a name="ln358">  return Set&lt;TypeTraits&lt;DECIMAL&gt; &gt;(col_idx, val, false);</a>
<a name="ln359">}</a>
<a name="ln360">Status YBPartialRow::SetFloat(int col_idx, float val) {</a>
<a name="ln361">  return Set&lt;TypeTraits&lt;FLOAT&gt; &gt;(col_idx, util::CanonicalizeFloat(val));</a>
<a name="ln362">}</a>
<a name="ln363">Status YBPartialRow::SetDouble(int col_idx, double val) {</a>
<a name="ln364">  return Set&lt;TypeTraits&lt;DOUBLE&gt; &gt;(col_idx, util::CanonicalizeDouble(val));</a>
<a name="ln365">}</a>
<a name="ln366"> </a>
<a name="ln367">Status YBPartialRow::SetBinaryCopy(const Slice&amp; col_name, const Slice&amp; val) {</a>
<a name="ln368">  return SetSliceCopy&lt;TypeTraits&lt;BINARY&gt; &gt;(col_name, val);</a>
<a name="ln369">}</a>
<a name="ln370">Status YBPartialRow::SetBinaryCopy(int col_idx, const Slice&amp; val) {</a>
<a name="ln371">  return SetSliceCopy&lt;TypeTraits&lt;BINARY&gt; &gt;(col_idx, val);</a>
<a name="ln372">}</a>
<a name="ln373">Status YBPartialRow::SetStringCopy(const Slice&amp; col_name, const Slice&amp; val) {</a>
<a name="ln374">  return SetSliceCopy&lt;TypeTraits&lt;STRING&gt; &gt;(col_name, val);</a>
<a name="ln375">}</a>
<a name="ln376">Status YBPartialRow::SetStringCopy(int col_idx, const Slice&amp; val) {</a>
<a name="ln377">  return SetSliceCopy&lt;TypeTraits&lt;STRING&gt; &gt;(col_idx, val);</a>
<a name="ln378">}</a>
<a name="ln379">Status YBPartialRow::SetUuidCopy(const Slice&amp; col_name, const Slice&amp; val) {</a>
<a name="ln380">  return SetSliceCopy&lt;TypeTraits&lt;UUID&gt; &gt;(col_name, val);</a>
<a name="ln381">}</a>
<a name="ln382">Status YBPartialRow::SetUuidCopy(int col_idx, const Slice&amp; val) {</a>
<a name="ln383">  return SetSliceCopy&lt;TypeTraits&lt;UUID&gt; &gt;(col_idx, val);</a>
<a name="ln384">}</a>
<a name="ln385">Status YBPartialRow::SetTimeUuidCopy(const Slice&amp; col_name, const Slice&amp; val) {</a>
<a name="ln386">  return SetSliceCopy&lt;TypeTraits&lt;TIMEUUID&gt; &gt;(col_name, val);</a>
<a name="ln387">}</a>
<a name="ln388">Status YBPartialRow::SetTimeUuidCopy(int col_idx, const Slice&amp; val) {</a>
<a name="ln389">  return SetSliceCopy&lt;TypeTraits&lt;TIMEUUID&gt; &gt;(col_idx, val);</a>
<a name="ln390">}</a>
<a name="ln391">Status YBPartialRow::SetFrozenCopy(const Slice&amp; col_name, const Slice&amp; val) {</a>
<a name="ln392">  return SetSliceCopy&lt;TypeTraits&lt;FROZEN&gt; &gt;(col_name, val);</a>
<a name="ln393">}</a>
<a name="ln394">Status YBPartialRow::SetFrozenCopy(int col_idx, const Slice&amp; val) {</a>
<a name="ln395">  return SetSliceCopy&lt;TypeTraits&lt;FROZEN&gt; &gt;(col_idx, val);</a>
<a name="ln396">}</a>
<a name="ln397"> </a>
<a name="ln398">template&lt;typename T&gt;</a>
<a name="ln399">Status YBPartialRow::SetSliceCopy(const Slice&amp; col_name, const Slice&amp; val) {</a>
<a name="ln400">  auto relocated = new uint8_t[val.size()];</a>
<a name="ln401">  memcpy(relocated, val.data(), val.size());</a>
<a name="ln402">  Slice relocated_val(relocated, val.size());</a>
<a name="ln403">  Status s = Set&lt;T&gt;(col_name, relocated_val, true);</a>
<a name="ln404">  if (!s.ok()) {</a>
<a name="ln405">    delete [] relocated;</a>
<a name="ln406">  }</a>
<a name="ln407">  return s;</a>
<a name="ln408">}</a>
<a name="ln409"> </a>
<a name="ln410">template&lt;typename T&gt;</a>
<a name="ln411">Status YBPartialRow::SetSliceCopy(int col_idx, const Slice&amp; val) {</a>
<a name="ln412">  auto relocated = new uint8_t[val.size()];</a>
<a name="ln413">  memcpy(relocated, val.data(), val.size());</a>
<a name="ln414">  Slice relocated_val(relocated, val.size());</a>
<a name="ln415">  Status s = Set&lt;T&gt;(col_idx, relocated_val, true);</a>
<a name="ln416">  if (!s.ok()) {</a>
<a name="ln417">    delete [] relocated;</a>
<a name="ln418">  }</a>
<a name="ln419">  return s;</a>
<a name="ln420">}</a>
<a name="ln421"> </a>
<a name="ln422">Status YBPartialRow::SetNull(const Slice&amp; col_name) {</a>
<a name="ln423">  int col_idx;</a>
<a name="ln424">  RETURN_NOT_OK(FindColumn(*schema_, col_name, &amp;col_idx));</a>
<a name="ln425">  return SetNull(col_idx);</a>
<a name="ln426">}</a>
<a name="ln427"> </a>
<a name="ln428">Status YBPartialRow::SetNull(int col_idx) {</a>
<a name="ln429">  const ColumnSchema&amp; col = schema_-&gt;column(col_idx);</a>
<a name="ln430">  if (PREDICT_FALSE(!col.is_nullable())) {</a>
<a name="ln431">    return STATUS(InvalidArgument, &quot;column not nullable&quot;, col.ToString());</a>
<a name="ln432">  }</a>
<a name="ln433"> </a>
<a name="ln434">  if (col.type_info()-&gt;physical_type() == BINARY) DeallocateStringIfSet(col_idx, col);</a>
<a name="ln435"> </a>
<a name="ln436">  ContiguousRow row(schema_, row_data_);</a>
<a name="ln437">  row.set_null(col_idx, true);</a>
<a name="ln438"> </a>
<a name="ln439">  // Mark the column as set.</a>
<a name="ln440">  BitmapSet(isset_bitmap_, col_idx);</a>
<a name="ln441">  return Status::OK();</a>
<a name="ln442">}</a>
<a name="ln443"> </a>
<a name="ln444">Status YBPartialRow::Unset(const Slice&amp; col_name) {</a>
<a name="ln445">  int col_idx;</a>
<a name="ln446">  RETURN_NOT_OK(FindColumn(*schema_, col_name, &amp;col_idx));</a>
<a name="ln447">  return Unset(col_idx);</a>
<a name="ln448">}</a>
<a name="ln449"> </a>
<a name="ln450">Status YBPartialRow::Unset(int col_idx) {</a>
<a name="ln451">  const ColumnSchema&amp; col = schema_-&gt;column(col_idx);</a>
<a name="ln452">  if (col.type_info()-&gt;physical_type() == BINARY) DeallocateStringIfSet(col_idx, col);</a>
<a name="ln453">  BitmapClear(isset_bitmap_, col_idx);</a>
<a name="ln454">  return Status::OK();</a>
<a name="ln455">}</a>
<a name="ln456"> </a>
<a name="ln457">//------------------------------------------------------------</a>
<a name="ln458">// Template instantiations: We instantiate all possible templates to avoid linker issues.</a>
<a name="ln459">// see: https://isocpp.org/wiki/faq/templates#separate-template-fn-defn-from-decl</a>
<a name="ln460">// TODO We can probably remove this when we move to c++11 and can use &quot;extern template&quot;</a>
<a name="ln461">//------------------------------------------------------------</a>
<a name="ln462"> </a>
<a name="ln463">template</a>
<a name="ln464">Status YBPartialRow::SetSliceCopy&lt;TypeTraits&lt;STRING&gt; &gt;(int col_idx, const Slice&amp; val);</a>
<a name="ln465"> </a>
<a name="ln466">template</a>
<a name="ln467">Status YBPartialRow::SetSliceCopy&lt;TypeTraits&lt;BINARY&gt; &gt;(int col_idx, const Slice&amp; val);</a>
<a name="ln468"> </a>
<a name="ln469">template</a>
<a name="ln470">Status YBPartialRow::SetSliceCopy&lt;TypeTraits&lt;INET&gt; &gt;(int col_idx, const Slice&amp; val);</a>
<a name="ln471"> </a>
<a name="ln472">template</a>
<a name="ln473">Status YBPartialRow::SetSliceCopy&lt;TypeTraits&lt;JSONB&gt; &gt;(int col_idx, const Slice&amp; val);</a>
<a name="ln474"> </a>
<a name="ln475">template</a>
<a name="ln476">Status YBPartialRow::SetSliceCopy&lt;TypeTraits&lt;UUID&gt; &gt;(int col_idx, const Slice&amp; val);</a>
<a name="ln477"> </a>
<a name="ln478">template</a>
<a name="ln479">Status YBPartialRow::SetSliceCopy&lt;TypeTraits&lt;TIMEUUID&gt; &gt;(int col_idx, const Slice&amp; val);</a>
<a name="ln480"> </a>
<a name="ln481">template</a>
<a name="ln482">Status YBPartialRow::SetSliceCopy&lt;TypeTraits&lt;STRING&gt; &gt;(const Slice&amp; col_name, const Slice&amp; val);</a>
<a name="ln483"> </a>
<a name="ln484">template</a>
<a name="ln485">Status YBPartialRow::SetSliceCopy&lt;TypeTraits&lt;BINARY&gt; &gt;(const Slice&amp; col_name, const Slice&amp; val);</a>
<a name="ln486"> </a>
<a name="ln487">template</a>
<a name="ln488">Status YBPartialRow::SetSliceCopy&lt;TypeTraits&lt;INET&gt; &gt;(const Slice&amp; col_name, const Slice&amp; val);</a>
<a name="ln489"> </a>
<a name="ln490">template</a>
<a name="ln491">Status YBPartialRow::SetSliceCopy&lt;TypeTraits&lt;JSONB&gt; &gt;(const Slice&amp; col_name, const Slice&amp; val);</a>
<a name="ln492"> </a>
<a name="ln493">template</a>
<a name="ln494">Status YBPartialRow::SetSliceCopy&lt;TypeTraits&lt;UUID&gt; &gt;(const Slice&amp; col_name, const Slice&amp; val);</a>
<a name="ln495"> </a>
<a name="ln496">template</a>
<a name="ln497">Status YBPartialRow::SetSliceCopy&lt;TypeTraits&lt;TIMEUUID&gt; &gt;(const Slice&amp; col_name, const Slice&amp; val);</a>
<a name="ln498"> </a>
<a name="ln499">template</a>
<a name="ln500">Status YBPartialRow::Set&lt;TypeTraits&lt;INT8&gt; &gt;(int col_idx,</a>
<a name="ln501">                                              const TypeTraits&lt;INT8&gt;::cpp_type&amp; val,</a>
<a name="ln502">                                              bool owned);</a>
<a name="ln503"> </a>
<a name="ln504">template</a>
<a name="ln505">Status YBPartialRow::Set&lt;TypeTraits&lt;INT16&gt; &gt;(int col_idx,</a>
<a name="ln506">                                               const TypeTraits&lt;INT16&gt;::cpp_type&amp; val,</a>
<a name="ln507">                                               bool owned);</a>
<a name="ln508"> </a>
<a name="ln509">template</a>
<a name="ln510">Status YBPartialRow::Set&lt;TypeTraits&lt;INT32&gt; &gt;(int col_idx,</a>
<a name="ln511">                                               const TypeTraits&lt;INT32&gt;::cpp_type&amp; val,</a>
<a name="ln512">                                               bool owned);</a>
<a name="ln513"> </a>
<a name="ln514">template</a>
<a name="ln515">Status YBPartialRow::Set&lt;TypeTraits&lt;INT64&gt; &gt;(int col_idx,</a>
<a name="ln516">                                               const TypeTraits&lt;INT64&gt;::cpp_type&amp; val,</a>
<a name="ln517">                                               bool owned);</a>
<a name="ln518"> </a>
<a name="ln519">template</a>
<a name="ln520">Status YBPartialRow::Set&lt;TypeTraits&lt;TIMESTAMP&gt; &gt;(</a>
<a name="ln521">    int col_idx,</a>
<a name="ln522">    const TypeTraits&lt;TIMESTAMP&gt;::cpp_type&amp; val,</a>
<a name="ln523">    bool owned);</a>
<a name="ln524"> </a>
<a name="ln525">template</a>
<a name="ln526">Status YBPartialRow::Set&lt;TypeTraits&lt;STRING&gt; &gt;(int col_idx,</a>
<a name="ln527">                                                const TypeTraits&lt;STRING&gt;::cpp_type&amp; val,</a>
<a name="ln528">                                                bool owned);</a>
<a name="ln529"> </a>
<a name="ln530">template</a>
<a name="ln531">Status YBPartialRow::Set&lt;TypeTraits&lt;BINARY&gt; &gt;(int col_idx,</a>
<a name="ln532">                                                const TypeTraits&lt;BINARY&gt;::cpp_type&amp; val,</a>
<a name="ln533">                                                bool owned);</a>
<a name="ln534"> </a>
<a name="ln535">template</a>
<a name="ln536">Status YBPartialRow::Set&lt;TypeTraits&lt;FLOAT&gt; &gt;(int col_idx,</a>
<a name="ln537">                                               const TypeTraits&lt;FLOAT&gt;::cpp_type&amp; val,</a>
<a name="ln538">                                               bool owned);</a>
<a name="ln539"> </a>
<a name="ln540">template</a>
<a name="ln541">Status YBPartialRow::Set&lt;TypeTraits&lt;DOUBLE&gt; &gt;(int col_idx,</a>
<a name="ln542">                                                const TypeTraits&lt;DOUBLE&gt;::cpp_type&amp; val,</a>
<a name="ln543">                                                bool owned);</a>
<a name="ln544"> </a>
<a name="ln545">template</a>
<a name="ln546">Status YBPartialRow::Set&lt;TypeTraits&lt;BOOL&gt; &gt;(int col_idx,</a>
<a name="ln547">                                              const TypeTraits&lt;BOOL&gt;::cpp_type&amp; val,</a>
<a name="ln548">                                              bool owned);</a>
<a name="ln549"> </a>
<a name="ln550">template</a>
<a name="ln551">Status YBPartialRow::Set&lt;TypeTraits&lt;INT8&gt; &gt;(const Slice&amp; col_name,</a>
<a name="ln552">                                              const TypeTraits&lt;INT8&gt;::cpp_type&amp; val,</a>
<a name="ln553">                                              bool owned);</a>
<a name="ln554"> </a>
<a name="ln555">template</a>
<a name="ln556">Status YBPartialRow::Set&lt;TypeTraits&lt;INT16&gt; &gt;(const Slice&amp; col_name,</a>
<a name="ln557">                                               const TypeTraits&lt;INT16&gt;::cpp_type&amp; val,</a>
<a name="ln558">                                               bool owned);</a>
<a name="ln559"> </a>
<a name="ln560">template</a>
<a name="ln561">Status YBPartialRow::Set&lt;TypeTraits&lt;INT32&gt; &gt;(const Slice&amp; col_name,</a>
<a name="ln562">                                               const TypeTraits&lt;INT32&gt;::cpp_type&amp; val,</a>
<a name="ln563">                                               bool owned);</a>
<a name="ln564"> </a>
<a name="ln565">template</a>
<a name="ln566">Status YBPartialRow::Set&lt;TypeTraits&lt;INT64&gt; &gt;(const Slice&amp; col_name,</a>
<a name="ln567">                                               const TypeTraits&lt;INT64&gt;::cpp_type&amp; val,</a>
<a name="ln568">                                               bool owned);</a>
<a name="ln569"> </a>
<a name="ln570">template</a>
<a name="ln571">Status YBPartialRow::Set&lt;TypeTraits&lt;TIMESTAMP&gt; &gt;(</a>
<a name="ln572">    const Slice&amp; col_name,</a>
<a name="ln573">    const TypeTraits&lt;TIMESTAMP&gt;::cpp_type&amp; val,</a>
<a name="ln574">    bool owned);</a>
<a name="ln575"> </a>
<a name="ln576">template</a>
<a name="ln577">Status YBPartialRow::Set&lt;TypeTraits&lt;FLOAT&gt; &gt;(const Slice&amp; col_name,</a>
<a name="ln578">                                               const TypeTraits&lt;FLOAT&gt;::cpp_type&amp; val,</a>
<a name="ln579">                                               bool owned);</a>
<a name="ln580"> </a>
<a name="ln581">template</a>
<a name="ln582">Status YBPartialRow::Set&lt;TypeTraits&lt;DOUBLE&gt; &gt;(const Slice&amp; col_name,</a>
<a name="ln583">                                                const TypeTraits&lt;DOUBLE&gt;::cpp_type&amp; val,</a>
<a name="ln584">                                                bool owned);</a>
<a name="ln585"> </a>
<a name="ln586">template</a>
<a name="ln587">Status YBPartialRow::Set&lt;TypeTraits&lt;BOOL&gt; &gt;(const Slice&amp; col_name,</a>
<a name="ln588">                                              const TypeTraits&lt;BOOL&gt;::cpp_type&amp; val,</a>
<a name="ln589">                                              bool owned);</a>
<a name="ln590"> </a>
<a name="ln591">template</a>
<a name="ln592">Status YBPartialRow::Set&lt;TypeTraits&lt;STRING&gt; &gt;(const Slice&amp; col_name,</a>
<a name="ln593">                                                const TypeTraits&lt;STRING&gt;::cpp_type&amp; val,</a>
<a name="ln594">                                                bool owned);</a>
<a name="ln595"> </a>
<a name="ln596">template</a>
<a name="ln597">Status YBPartialRow::Set&lt;TypeTraits&lt;BINARY&gt; &gt;(const Slice&amp; col_name,</a>
<a name="ln598">                                                const TypeTraits&lt;BINARY&gt;::cpp_type&amp; val,</a>
<a name="ln599">                                                bool owned);</a>
<a name="ln600"> </a>
<a name="ln601">//------------------------------------------------------------</a>
<a name="ln602">// Getters</a>
<a name="ln603">//------------------------------------------------------------</a>
<a name="ln604">bool YBPartialRow::IsColumnSet(int col_idx) const {</a>
<a name="ln605">  DCHECK_GE(col_idx, 0);</a>
<a name="ln606">  DCHECK_LT(col_idx, schema_-&gt;num_columns());</a>
<a name="ln607">  return BitmapTest(isset_bitmap_, col_idx);</a>
<a name="ln608">}</a>
<a name="ln609"> </a>
<a name="ln610">bool YBPartialRow::IsColumnSet(const Slice&amp; col_name) const {</a>
<a name="ln611">  int col_idx;</a>
<a name="ln612">  CHECK_OK(FindColumn(*schema_, col_name, &amp;col_idx));</a>
<a name="ln613">  return IsColumnSet(col_idx);</a>
<a name="ln614">}</a>
<a name="ln615"> </a>
<a name="ln616">bool YBPartialRow::IsNull(int col_idx) const {</a>
<a name="ln617">  const ColumnSchema&amp; col = schema_-&gt;column(col_idx);</a>
<a name="ln618">  if (!col.is_nullable()) {</a>
<a name="ln619">    return false;</a>
<a name="ln620">  }</a>
<a name="ln621"> </a>
<a name="ln622">  if (!IsColumnSet(col_idx)) return false;</a>
<a name="ln623"> </a>
<a name="ln624">  ContiguousRow row(schema_, row_data_);</a>
<a name="ln625">  return row.is_null(col_idx);</a>
<a name="ln626">}</a>
<a name="ln627"> </a>
<a name="ln628">bool YBPartialRow::IsNull(const Slice&amp; col_name) const {</a>
<a name="ln629">  int col_idx;</a>
<a name="ln630">  CHECK_OK(FindColumn(*schema_, col_name, &amp;col_idx));</a>
<a name="ln631">  return IsNull(col_idx);</a>
<a name="ln632">}</a>
<a name="ln633"> </a>
<a name="ln634">Status YBPartialRow::GetBool(const Slice&amp; col_name, bool* val) const {</a>
<a name="ln635">  return Get&lt;TypeTraits&lt;BOOL&gt; &gt;(col_name, val);</a>
<a name="ln636">}</a>
<a name="ln637">Status YBPartialRow::GetInt8(const Slice&amp; col_name, int8_t* val) const {</a>
<a name="ln638">  return Get&lt;TypeTraits&lt;INT8&gt; &gt;(col_name, val);</a>
<a name="ln639">}</a>
<a name="ln640">Status YBPartialRow::GetInt16(const Slice&amp; col_name, int16_t* val) const {</a>
<a name="ln641">  return Get&lt;TypeTraits&lt;INT16&gt; &gt;(col_name, val);</a>
<a name="ln642">}</a>
<a name="ln643">Status YBPartialRow::GetInt32(const Slice&amp; col_name, int32_t* val) const {</a>
<a name="ln644">  return Get&lt;TypeTraits&lt;INT32&gt; &gt;(col_name, val);</a>
<a name="ln645">}</a>
<a name="ln646">Status YBPartialRow::GetInt64(const Slice&amp; col_name, int64_t* val) const {</a>
<a name="ln647">  return Get&lt;TypeTraits&lt;INT64&gt; &gt;(col_name, val);</a>
<a name="ln648">}</a>
<a name="ln649">Status YBPartialRow::GetTimestamp(const Slice&amp; col_name, int64_t* micros_since_utc_epoch) const {</a>
<a name="ln650">  return Get&lt;TypeTraits&lt;TIMESTAMP&gt; &gt;(col_name, micros_since_utc_epoch);</a>
<a name="ln651">}</a>
<a name="ln652">Status YBPartialRow::GetFloat(const Slice&amp; col_name, float* val) const {</a>
<a name="ln653">  return Get&lt;TypeTraits&lt;FLOAT&gt; &gt;(col_name, val);</a>
<a name="ln654">}</a>
<a name="ln655">Status YBPartialRow::GetDouble(const Slice&amp; col_name, double* val) const {</a>
<a name="ln656">  return Get&lt;TypeTraits&lt;DOUBLE&gt; &gt;(col_name, val);</a>
<a name="ln657">}</a>
<a name="ln658">Status YBPartialRow::GetString(const Slice&amp; col_name, Slice* val) const {</a>
<a name="ln659">  return Get&lt;TypeTraits&lt;STRING&gt; &gt;(col_name, val);</a>
<a name="ln660">}</a>
<a name="ln661">Status YBPartialRow::GetBinary(const Slice&amp; col_name, Slice* val) const {</a>
<a name="ln662">  return Get&lt;TypeTraits&lt;BINARY&gt; &gt;(col_name, val);</a>
<a name="ln663">}</a>
<a name="ln664">Status YBPartialRow::GetInet(const Slice&amp; col_name, Slice* val) const {</a>
<a name="ln665">  return Get&lt;TypeTraits&lt;INET&gt; &gt;(col_name, val);</a>
<a name="ln666">}</a>
<a name="ln667">Status YBPartialRow::GetJsonb(const Slice&amp; col_name, Slice* val) const {</a>
<a name="ln668">  return Get&lt;TypeTraits&lt;JSONB&gt; &gt;(col_name, val);</a>
<a name="ln669">}</a>
<a name="ln670">Status YBPartialRow::GetUuid(const Slice&amp; col_name, Slice* val) const {</a>
<a name="ln671">  return Get&lt;TypeTraits&lt;UUID&gt; &gt;(col_name, val);</a>
<a name="ln672">}</a>
<a name="ln673">Status YBPartialRow::GetTimeUuid(const Slice&amp; col_name, Slice* val) const {</a>
<a name="ln674">  return Get&lt;TypeTraits&lt;TIMEUUID&gt; &gt;(col_name, val);</a>
<a name="ln675">}</a>
<a name="ln676">Status YBPartialRow::GetBool(int col_idx, bool* val) const {</a>
<a name="ln677">  return Get&lt;TypeTraits&lt;BOOL&gt; &gt;(col_idx, val);</a>
<a name="ln678">}</a>
<a name="ln679">Status YBPartialRow::GetInt8(int col_idx, int8_t* val) const {</a>
<a name="ln680">  return Get&lt;TypeTraits&lt;INT8&gt; &gt;(col_idx, val);</a>
<a name="ln681">}</a>
<a name="ln682">Status YBPartialRow::GetInt16(int col_idx, int16_t* val) const {</a>
<a name="ln683">  return Get&lt;TypeTraits&lt;INT16&gt; &gt;(col_idx, val);</a>
<a name="ln684">}</a>
<a name="ln685">Status YBPartialRow::GetInt32(int col_idx, int32_t* val) const {</a>
<a name="ln686">  return Get&lt;TypeTraits&lt;INT32&gt; &gt;(col_idx, val);</a>
<a name="ln687">}</a>
<a name="ln688">Status YBPartialRow::GetInt64(int col_idx, int64_t* val) const {</a>
<a name="ln689">  return Get&lt;TypeTraits&lt;INT64&gt; &gt;(col_idx, val);</a>
<a name="ln690">}</a>
<a name="ln691">Status YBPartialRow::GetTimestamp(int col_idx, int64_t* micros_since_utc_epoch) const {</a>
<a name="ln692">  return Get&lt;TypeTraits&lt;TIMESTAMP&gt; &gt;(col_idx, micros_since_utc_epoch);</a>
<a name="ln693">}</a>
<a name="ln694">Status YBPartialRow::GetFloat(int col_idx, float* val) const {</a>
<a name="ln695">  return Get&lt;TypeTraits&lt;FLOAT&gt; &gt;(col_idx, val);</a>
<a name="ln696">}</a>
<a name="ln697">Status YBPartialRow::GetDouble(int col_idx, double* val) const {</a>
<a name="ln698">  return Get&lt;TypeTraits&lt;DOUBLE&gt; &gt;(col_idx, val);</a>
<a name="ln699">}</a>
<a name="ln700">Status YBPartialRow::GetString(int col_idx, Slice* val) const {</a>
<a name="ln701">  return Get&lt;TypeTraits&lt;STRING&gt; &gt;(col_idx, val);</a>
<a name="ln702">}</a>
<a name="ln703">Status YBPartialRow::GetBinary(int col_idx, Slice* val) const {</a>
<a name="ln704">  return Get&lt;TypeTraits&lt;BINARY&gt; &gt;(col_idx, val);</a>
<a name="ln705">}</a>
<a name="ln706">Status YBPartialRow::GetInet(int col_idx, Slice* val) const {</a>
<a name="ln707">  return Get&lt;TypeTraits&lt;INET&gt; &gt;(col_idx, val);</a>
<a name="ln708">}</a>
<a name="ln709">Status YBPartialRow::GetJsonb(int col_idx, Slice* val) const {</a>
<a name="ln710">  return Get&lt;TypeTraits&lt;JSONB&gt; &gt;(col_idx, val);</a>
<a name="ln711">}</a>
<a name="ln712">Status YBPartialRow::GetUuid(int col_idx, Slice* val) const {</a>
<a name="ln713">  return Get&lt;TypeTraits&lt;UUID&gt; &gt;(col_idx, val);</a>
<a name="ln714">}</a>
<a name="ln715">Status YBPartialRow::GetTimeUuid(int col_idx, Slice* val) const {</a>
<a name="ln716">  return Get&lt;TypeTraits&lt;TIMEUUID&gt; &gt;(col_idx, val);</a>
<a name="ln717">}</a>
<a name="ln718"> </a>
<a name="ln719">template&lt;typename T&gt;</a>
<a name="ln720">Status YBPartialRow::Get(const Slice&amp; col_name,</a>
<a name="ln721">                           typename T::cpp_type* val) const {</a>
<a name="ln722">  int col_idx;</a>
<a name="ln723">  RETURN_NOT_OK(FindColumn(*schema_, col_name, &amp;col_idx));</a>
<a name="ln724">  return Get&lt;T&gt;(col_idx, val);</a>
<a name="ln725">}</a>
<a name="ln726"> </a>
<a name="ln727">template&lt;typename T&gt;</a>
<a name="ln728">Status YBPartialRow::Get(int col_idx, typename T::cpp_type* val) const {</a>
<a name="ln729">  const ColumnSchema&amp; col = schema_-&gt;column(col_idx);</a>
<a name="ln730">  if (PREDICT_FALSE(col.type_info()-&gt;type() != T::type)) {</a>
<a name="ln731">    // TODO: at some point we could allow type coercion here.</a>
<a name="ln732">    return STATUS(InvalidArgument,</a>
<a name="ln733">      Substitute(&quot;invalid type $0 provided for column '$1' (expected $2)&quot;,</a>
<a name="ln734">                 T::name(),</a>
<a name="ln735">                 col.name(), col.type_info()-&gt;name()));</a>
<a name="ln736">  }</a>
<a name="ln737"> </a>
<a name="ln738">  if (PREDICT_FALSE(!IsColumnSet(col_idx))) {</a>
<a name="ln739">    return STATUS(NotFound, &quot;column not set&quot;);</a>
<a name="ln740">  }</a>
<a name="ln741">  if (col.is_nullable() &amp;&amp; IsNull(col_idx)) {</a>
<a name="ln742">    return STATUS(NotFound, &quot;column is NULL&quot;);</a>
<a name="ln743">  }</a>
<a name="ln744"> </a>
<a name="ln745">  ContiguousRow row(schema_, row_data_);</a>
<a name="ln746">  memcpy(val, row.cell_ptr(col_idx), sizeof(*val));</a>
<a name="ln747">  return Status::OK();</a>
<a name="ln748">}</a>
<a name="ln749"> </a>
<a name="ln750">//------------------------------------------------------------</a>
<a name="ln751">// Key-encoding related functions</a>
<a name="ln752">//------------------------------------------------------------</a>
<a name="ln753">Status YBPartialRow::EncodeRowKey(string* encoded_key) const {</a>
<a name="ln754">  // Currently, a row key must be fully specified.</a>
<a name="ln755">  // TODO: allow specifying a prefix of the key, and automatically</a>
<a name="ln756">  // fill the rest with minimum values.</a>
<a name="ln757">  for (int i = 0; i &lt; schema_-&gt;num_key_columns(); i++) {</a>
<a name="ln758">    if (PREDICT_FALSE(!IsColumnSet(i))) {</a>
<a name="ln759">      return STATUS(InvalidArgument, &quot;All key columns must be set&quot;,</a>
<a name="ln760">                                     schema_-&gt;column(i).name());</a>
<a name="ln761">    }</a>
<a name="ln762">  }</a>
<a name="ln763"> </a>
<a name="ln764">  encoded_key-&gt;clear();</a>
<a name="ln765">  ContiguousRow row(schema_, row_data_);</a>
<a name="ln766"> </a>
<a name="ln767">  for (int i = 0; i &lt; schema_-&gt;num_key_columns(); i++) {</a>
<a name="ln768">    bool is_last = i == schema_-&gt;num_key_columns() - 1;</a>
<a name="ln769">    const TypeInfo* ti = schema_-&gt;column(i).type_info();</a>
<a name="ln770">    GetKeyEncoder&lt;string&gt;(ti).Encode(row.cell_ptr(i), is_last, encoded_key);</a>
<a name="ln771">  }</a>
<a name="ln772"> </a>
<a name="ln773">  return Status::OK();</a>
<a name="ln774">}</a>
<a name="ln775"> </a>
<a name="ln776">string YBPartialRow::ToEncodedRowKeyOrDie() const {</a>
<a name="ln777">  string ret;</a>
<a name="ln778">  CHECK_OK(EncodeRowKey(&amp;ret));</a>
<a name="ln779">  return ret;</a>
<a name="ln780">}</a>
<a name="ln781"> </a>
<a name="ln782">//------------------------------------------------------------</a>
<a name="ln783">// Utility code</a>
<a name="ln784">//------------------------------------------------------------</a>
<a name="ln785"> </a>
<a name="ln786">bool YBPartialRow::IsHashKeySet() const {</a>
<a name="ln787">  return schema_-&gt;num_hash_key_columns() &gt; 0 &amp;&amp;</a>
<a name="ln788">         BitMapIsAllSet(isset_bitmap_, 0, schema_-&gt;num_hash_key_columns());</a>
<a name="ln789">}</a>
<a name="ln790"> </a>
<a name="ln791">bool YBPartialRow::IsKeySet() const {</a>
<a name="ln792">  return schema_-&gt;num_key_columns() &gt; 0 &amp;&amp;</a>
<a name="ln793">         BitMapIsAllSet(isset_bitmap_, 0, schema_-&gt;num_key_columns());</a>
<a name="ln794">}</a>
<a name="ln795"> </a>
<a name="ln796">bool YBPartialRow::IsHashOrPrimaryKeySet() const {</a>
<a name="ln797">  return IsHashKeySet() || IsKeySet();</a>
<a name="ln798">}</a>
<a name="ln799"> </a>
<a name="ln800">bool YBPartialRow::AllColumnsSet() const {</a>
<a name="ln801">  return schema_-&gt;num_columns() &gt; 0 &amp;&amp;</a>
<a name="ln802">         BitMapIsAllSet(isset_bitmap_, 0, schema_-&gt;num_columns());</a>
<a name="ln803">}</a>
<a name="ln804"> </a>
<a name="ln805">std::string YBPartialRow::ToString() const {</a>
<a name="ln806">  ContiguousRow row(schema_, row_data_);</a>
<a name="ln807">  std::string ret;</a>
<a name="ln808">  bool first = true;</a>
<a name="ln809">  for (int i = 0; i &lt; schema_-&gt;num_columns(); i++) {</a>
<a name="ln810">    if (IsColumnSet(i)) {</a>
<a name="ln811">      if (!first) {</a>
<a name="ln812">        ret.append(&quot;, &quot;);</a>
<a name="ln813">      }</a>
<a name="ln814">      schema_-&gt;column(i).DebugCellAppend(row.cell(i), &amp;ret);</a>
<a name="ln815">      first = false;</a>
<a name="ln816">    }</a>
<a name="ln817">  }</a>
<a name="ln818">  return ret;</a>
<a name="ln819">}</a>
<a name="ln820"> </a>
<a name="ln821">//------------------------------------------------------------</a>
<a name="ln822">// Serialization/deserialization</a>
<a name="ln823">//------------------------------------------------------------</a>
<a name="ln824"> </a>
<a name="ln825">} // namespace yb</a>

</code></pre>
<div class="balloon" rel="65"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="255"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="612"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="630"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="778"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
