
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>trace_event_impl.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Copyright (c) 2012 The Chromium Authors. All rights reserved.</a>
<a name="ln2">// Use of this source code is governed by a BSD-style license that can be</a>
<a name="ln3">// found in the LICENSE file.</a>
<a name="ln4">//</a>
<a name="ln5">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln6">//</a>
<a name="ln7">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln8">//</a>
<a name="ln9">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln10">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln11">//</a>
<a name="ln12">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln13">//</a>
<a name="ln14">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln15">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln16">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln17">// under the License.</a>
<a name="ln18">//</a>
<a name="ln19"> </a>
<a name="ln20">#ifndef YB_UTIL_DEBUG_TRACE_EVENT_IMPL_H_</a>
<a name="ln21">#define YB_UTIL_DEBUG_TRACE_EVENT_IMPL_H_</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;stack&gt;</a>
<a name="ln24">#include &lt;string&gt;</a>
<a name="ln25">#include &lt;unordered_map&gt;</a>
<a name="ln26">#include &lt;unordered_set&gt;</a>
<a name="ln27">#include &lt;vector&gt;</a>
<a name="ln28"> </a>
<a name="ln29">#include &lt;gtest/gtest_prod.h&gt;</a>
<a name="ln30"> </a>
<a name="ln31">#include &quot;yb/gutil/atomicops.h&quot;</a>
<a name="ln32">#include &quot;yb/gutil/callback.h&quot;</a>
<a name="ln33">#include &quot;yb/gutil/walltime.h&quot;</a>
<a name="ln34">#include &quot;yb/gutil/ref_counted.h&quot;</a>
<a name="ln35">#include &quot;yb/gutil/ref_counted_memory.h&quot;</a>
<a name="ln36">#include &quot;yb/util/atomic.h&quot;</a>
<a name="ln37">#include &quot;yb/util/condition_variable.h&quot;</a>
<a name="ln38">#include &quot;yb/util/locks.h&quot;</a>
<a name="ln39">#include &quot;yb/util/thread.h&quot;</a>
<a name="ln40">#include &quot;yb/util/threadlocal.h&quot;</a>
<a name="ln41"> </a>
<a name="ln42">// Older style trace macros with explicit id and extra data</a>
<a name="ln43">// Only these macros result in publishing data to ETW as currently implemented.</a>
<a name="ln44">#define TRACE_EVENT_BEGIN_ETW(name, id, extra) \</a>
<a name="ln45">    base::debug::TraceLog::AddTraceEventEtw( \</a>
<a name="ln46">        TRACE_EVENT_PHASE_BEGIN, \</a>
<a name="ln47">        name, reinterpret_cast&lt;const void*&gt;(id), extra)</a>
<a name="ln48"> </a>
<a name="ln49">#define TRACE_EVENT_END_ETW(name, id, extra) \</a>
<a name="ln50">    base::debug::TraceLog::AddTraceEventEtw( \</a>
<a name="ln51">        TRACE_EVENT_PHASE_END, \</a>
<a name="ln52">        name, reinterpret_cast&lt;const void*&gt;(id), extra)</a>
<a name="ln53"> </a>
<a name="ln54">#define TRACE_EVENT_INSTANT_ETW(name, id, extra) \</a>
<a name="ln55">    base::debug::TraceLog::AddTraceEventEtw( \</a>
<a name="ln56">        TRACE_EVENT_PHASE_INSTANT, \</a>
<a name="ln57">        name, reinterpret_cast&lt;const void*&gt;(id), extra)</a>
<a name="ln58"> </a>
<a name="ln59">template &lt;typename Type&gt;</a>
<a name="ln60">class Singleton;</a>
<a name="ln61"> </a>
<a name="ln62">#if defined(COMPILER_GCC)</a>
<a name="ln63">namespace BASE_HASH_NAMESPACE {</a>
<a name="ln64">template &lt;&gt;</a>
<a name="ln65">struct hash&lt;yb::Thread*&gt; {</a>
<a name="ln66">  std::size_t operator()(yb::Thread* value) const {</a>
<a name="ln67">    return reinterpret_cast&lt;std::size_t&gt;(value);</a>
<a name="ln68">  }</a>
<a name="ln69">};</a>
<a name="ln70">}  // BASE_HASH_NAMESPACE</a>
<a name="ln71">#endif</a>
<a name="ln72"> </a>
<a name="ln73">namespace yb {</a>
<a name="ln74">namespace debug {</a>
<a name="ln75"> </a>
<a name="ln76">// For any argument of type TRACE_VALUE_TYPE_CONVERTABLE the provided</a>
<a name="ln77">// class must implement this interface.</a>
<a name="ln78">class ConvertableToTraceFormat : public yb::RefCountedThreadSafe&lt;ConvertableToTraceFormat&gt; {</a>
<a name="ln79"> public:</a>
<a name="ln80">  // Append the class info to the provided |out| string. The appended</a>
<a name="ln81">  // data must be a valid JSON object. Strings must be properly quoted, and</a>
<a name="ln82">  // escaped. There is no processing applied to the content after it is</a>
<a name="ln83">  // appended.</a>
<a name="ln84">  virtual void AppendAsTraceFormat(std::string* out) const = 0;</a>
<a name="ln85"> </a>
<a name="ln86"> protected:</a>
<a name="ln87">  virtual ~ConvertableToTraceFormat() {}</a>
<a name="ln88"> </a>
<a name="ln89"> private:</a>
<a name="ln90">  friend class yb::RefCountedThreadSafe&lt;ConvertableToTraceFormat&gt;;</a>
<a name="ln91">};</a>
<a name="ln92"> </a>
<a name="ln93">struct TraceEventHandle {</a>
<a name="ln94">  uint32 chunk_seq = 0;</a>
<a name="ln95">  uint16 chunk_index = 0;</a>
<a name="ln96">  uint16 event_index = 0;</a>
<a name="ln97">};</a>
<a name="ln98"> </a>
<a name="ln99">const int kTraceMaxNumArgs = 2;</a>
<a name="ln100"> </a>
<a name="ln101">class BASE_EXPORT TraceEvent {</a>
<a name="ln102"> public:</a>
<a name="ln103">  union TraceValue {</a>
<a name="ln104">    bool as_bool;</a>
<a name="ln105">    uint64_t as_uint;</a>
<a name="ln106">    long long as_int;  // NOLINT(runtime/int)</a>
<a name="ln107">    double as_double;</a>
<a name="ln108">    const void* as_pointer;</a>
<a name="ln109">    const char* as_string;</a>
<a name="ln110">  };</a>
<a name="ln111"> </a>
<a name="ln112">  TraceEvent();</a>
<a name="ln113">  ~TraceEvent();</a>
<a name="ln114"> </a>
<a name="ln115">  // We don't need to copy TraceEvent except when TraceEventBuffer is cloned.</a>
<a name="ln116">  // Use explicit copy method to avoid accidentally misuse of copy.</a>
<a name="ln117">  void CopyFrom(const TraceEvent&amp; other);</a>
<a name="ln118"> </a>
<a name="ln119">  void Initialize(</a>
<a name="ln120">      int thread_id,</a>
<a name="ln121">      MicrosecondsInt64 timestamp,</a>
<a name="ln122">      MicrosecondsInt64 thread_timestamp,</a>
<a name="ln123">      char phase,</a>
<a name="ln124">      const unsigned char* category_group_enabled,</a>
<a name="ln125">      const char* name,</a>
<a name="ln126">      uint64_t id,</a>
<a name="ln127">      int num_args,</a>
<a name="ln128">      const char** arg_names,</a>
<a name="ln129">      const unsigned char* arg_types,</a>
<a name="ln130">      const uint64_t* arg_values,</a>
<a name="ln131">      const scoped_refptr&lt;ConvertableToTraceFormat&gt;* convertable_values,</a>
<a name="ln132">      unsigned char flags);</a>
<a name="ln133"> </a>
<a name="ln134">  void Reset();</a>
<a name="ln135"> </a>
<a name="ln136">  void UpdateDuration(const MicrosecondsInt64&amp; now, const MicrosecondsInt64&amp; thread_now);</a>
<a name="ln137"> </a>
<a name="ln138">  // Serialize event data to JSON</a>
<a name="ln139">  void AppendAsJSON(std::string* out) const;</a>
<a name="ln140">  void AppendPrettyPrinted(std::ostringstream* out) const;</a>
<a name="ln141"> </a>
<a name="ln142">  static void AppendValueAsJSON(unsigned char type,</a>
<a name="ln143">                                TraceValue value,</a>
<a name="ln144">                                std::string* out);</a>
<a name="ln145"> </a>
<a name="ln146">  MicrosecondsInt64 timestamp() const { return timestamp_; }</a>
<a name="ln147">  MicrosecondsInt64 thread_timestamp() const { return thread_timestamp_; }</a>
<a name="ln148">  char phase() const { return phase_; }</a>
<a name="ln149">  int thread_id() const { return thread_id_; }</a>
<a name="ln150">  MicrosecondsInt64 duration() const { return duration_; }</a>
<a name="ln151">  MicrosecondsInt64 thread_duration() const { return thread_duration_; }</a>
<a name="ln152">  uint64_t id() const { return id_; }</a>
<a name="ln153">  unsigned char flags() const { return flags_; }</a>
<a name="ln154"> </a>
<a name="ln155">  // Exposed for unittesting:</a>
<a name="ln156"> </a>
<a name="ln157">  const yb::RefCountedString* parameter_copy_storage() const {</a>
<a name="ln158">    return parameter_copy_storage_.get();</a>
<a name="ln159">  }</a>
<a name="ln160"> </a>
<a name="ln161">  const unsigned char* category_group_enabled() const {</a>
<a name="ln162">    return category_group_enabled_;</a>
<a name="ln163">  }</a>
<a name="ln164"> </a>
<a name="ln165">  const char* name() const { return name_; }</a>
<a name="ln166"> </a>
<a name="ln167">#if defined(OS_ANDROID)</a>
<a name="ln168">  void SendToATrace();</a>
<a name="ln169">#endif</a>
<a name="ln170"> </a>
<a name="ln171"> private:</a>
<a name="ln172">  // Note: these are ordered by size (largest first) for optimal packing.</a>
<a name="ln173">  MicrosecondsInt64 timestamp_;</a>
<a name="ln174">  MicrosecondsInt64 thread_timestamp_;</a>
<a name="ln175">  MicrosecondsInt64 duration_;</a>
<a name="ln176">  MicrosecondsInt64 thread_duration_;</a>
<a name="ln177">  // id_ can be used to store phase-specific data.</a>
<a name="ln178">  uint64_t id_;</a>
<a name="ln179">  TraceValue arg_values_[kTraceMaxNumArgs];</a>
<a name="ln180">  const char* arg_names_[kTraceMaxNumArgs];</a>
<a name="ln181">  scoped_refptr&lt;ConvertableToTraceFormat&gt; convertable_values_[kTraceMaxNumArgs];</a>
<a name="ln182">  const unsigned char* category_group_enabled_;</a>
<a name="ln183">  const char* name_;</a>
<a name="ln184">  scoped_refptr&lt;yb::RefCountedString&gt; parameter_copy_storage_;</a>
<a name="ln185">  int thread_id_;</a>
<a name="ln186">  char phase_;</a>
<a name="ln187">  unsigned char flags_;</a>
<a name="ln188">  unsigned char arg_types_[kTraceMaxNumArgs];</a>
<a name="ln189"> </a>
<a name="ln190">  DISALLOW_COPY_AND_ASSIGN(TraceEvent);</a>
<a name="ln191">};</a>
<a name="ln192"> </a>
<a name="ln193">// TraceBufferChunk is the basic unit of TraceBuffer.</a>
<a name="ln194">class BASE_EXPORT TraceBufferChunk {</a>
<a name="ln195"> public:</a>
<a name="ln196">  explicit TraceBufferChunk(uint32 seq)</a>
<a name="ln197">      : next_free_(0),</a>
<a name="ln198">        seq_(seq) {</a>
<a name="ln199">  }</a>
<a name="ln200"> </a>
<a name="ln201">  void Reset(uint32 new_seq);</a>
<a name="ln202">  TraceEvent* AddTraceEvent(size_t* event_index);</a>
<a name="ln203">  bool IsFull() const { return next_free_ == kTraceBufferChunkSize; }</a>
<a name="ln204"> </a>
<a name="ln205">  uint32 seq() const { return seq_; }</a>
<a name="ln206">  size_t capacity() const { return kTraceBufferChunkSize; }</a>
<a name="ln207">  size_t size() const { return next_free_; }</a>
<a name="ln208"> </a>
<a name="ln209">  TraceEvent* GetEventAt(size_t index) {</a>
<a name="ln210">    DCHECK(index &lt; size());</a>
<a name="ln211">    return &amp;chunk_[index];</a>
<a name="ln212">  }</a>
<a name="ln213">  const TraceEvent* GetEventAt(size_t index) const {</a>
<a name="ln214">    DCHECK(index &lt; size());</a>
<a name="ln215">    return &amp;chunk_[index];</a>
<a name="ln216">  }</a>
<a name="ln217"> </a>
<a name="ln218">  gscoped_ptr&lt;TraceBufferChunk&gt; Clone() const;</a>
<a name="ln219"> </a>
<a name="ln220">  static const size_t kTraceBufferChunkSize = 64;</a>
<a name="ln221"> </a>
<a name="ln222"> private:</a>
<a name="ln223">  size_t next_free_;</a>
<a name="ln224">  TraceEvent chunk_[kTraceBufferChunkSize];</a>
<a name="ln225">  uint32 seq_;</a>
<a name="ln226">};</a>
<a name="ln227"> </a>
<a name="ln228">// TraceBuffer holds the events as they are collected.</a>
<a name="ln229">class BASE_EXPORT TraceBuffer {</a>
<a name="ln230"> public:</a>
<a name="ln231">  virtual ~TraceBuffer() {}</a>
<a name="ln232"> </a>
<a name="ln233">  virtual gscoped_ptr&lt;TraceBufferChunk&gt; GetChunk(size_t *index) = 0;</a>
<a name="ln234">  virtual void ReturnChunk(size_t index,</a>
<a name="ln235">                           gscoped_ptr&lt;TraceBufferChunk&gt; chunk) = 0;</a>
<a name="ln236"> </a>
<a name="ln237">  virtual bool IsFull() const = 0;</a>
<a name="ln238">  virtual size_t Size() const = 0;</a>
<a name="ln239">  virtual size_t Capacity() const = 0;</a>
<a name="ln240">  virtual TraceEvent* GetEventByHandle(TraceEventHandle handle) = 0;</a>
<a name="ln241"> </a>
<a name="ln242">  // For iteration. Each TraceBuffer can only be iterated once.</a>
<a name="ln243">  virtual const TraceBufferChunk* NextChunk() = 0;</a>
<a name="ln244"> </a>
<a name="ln245">  virtual gscoped_ptr&lt;TraceBuffer&gt; CloneForIteration() const = 0;</a>
<a name="ln246">};</a>
<a name="ln247"> </a>
<a name="ln248">// TraceResultBuffer collects and converts trace fragments returned by TraceLog</a>
<a name="ln249">// to JSON output.</a>
<a name="ln250">class TraceResultBuffer {</a>
<a name="ln251"> public:</a>
<a name="ln252">  static std::string FlushTraceLogToString();</a>
<a name="ln253">  static std::string FlushTraceLogToStringButLeaveBufferIntact();</a>
<a name="ln254"> </a>
<a name="ln255"> private:</a>
<a name="ln256">  TraceResultBuffer();</a>
<a name="ln257">  ~TraceResultBuffer();</a>
<a name="ln258"> </a>
<a name="ln259">  static std::string DoFlush(bool leave_intact);</a>
<a name="ln260"> </a>
<a name="ln261">  // Callback for TraceLog::Flush</a>
<a name="ln262">  void Collect(const scoped_refptr&lt;RefCountedString&gt;&amp; s,</a>
<a name="ln263">               bool has_more_events);</a>
<a name="ln264"> </a>
<a name="ln265">  bool first_;</a>
<a name="ln266">  std::string json_;</a>
<a name="ln267">};</a>
<a name="ln268"> </a>
<a name="ln269">class BASE_EXPORT CategoryFilter {</a>
<a name="ln270"> public:</a>
<a name="ln271">  typedef std::vector&lt;std::string&gt; StringList;</a>
<a name="ln272"> </a>
<a name="ln273">  // The default category filter, used when none is provided.</a>
<a name="ln274">  // Allows all categories through, except if they end in the suffix 'Debug' or</a>
<a name="ln275">  // 'Test'.</a>
<a name="ln276">  static const char* kDefaultCategoryFilterString;</a>
<a name="ln277"> </a>
<a name="ln278">  // |filter_string| is a comma-delimited list of category wildcards.</a>
<a name="ln279">  // A category can have an optional '-' prefix to make it an excluded category.</a>
<a name="ln280">  // All the same rules apply above, so for example, having both included and</a>
<a name="ln281">  // excluded categories in the same list would not be supported.</a>
<a name="ln282">  //</a>
<a name="ln283">  // Example: CategoryFilter&quot;test_MyTest*&quot;);</a>
<a name="ln284">  // Example: CategoryFilter(&quot;test_MyTest*,test_OtherStuff&quot;);</a>
<a name="ln285">  // Example: CategoryFilter(&quot;-excluded_category1,-excluded_category2&quot;);</a>
<a name="ln286">  // Example: CategoryFilter(&quot;-*,webkit&quot;); would disable everything but webkit.</a>
<a name="ln287">  // Example: CategoryFilter(&quot;-webkit&quot;); would enable everything but webkit.</a>
<a name="ln288">  //</a>
<a name="ln289">  // Category filters can also be used to configure synthetic delays.</a>
<a name="ln290">  //</a>
<a name="ln291">  // Example: CategoryFilter(&quot;DELAY(gpu.PresentingFrame;16)&quot;); would make swap</a>
<a name="ln292">  //          buffers always take at least 16 ms.</a>
<a name="ln293">  // Example: CategoryFilter(&quot;DELAY(gpu.PresentingFrame;16;oneshot)&quot;); would</a>
<a name="ln294">  //          make swap buffers take at least 16 ms the first time it is</a>
<a name="ln295">  //          called.</a>
<a name="ln296">  // Example: CategoryFilter(&quot;DELAY(gpu.PresentingFrame;16;alternating)&quot;);</a>
<a name="ln297">  //          would make swap buffers take at least 16 ms every other time it</a>
<a name="ln298">  //          is called.</a>
<a name="ln299">  explicit CategoryFilter(const std::string&amp; filter_string);</a>
<a name="ln300"> </a>
<a name="ln301">  CategoryFilter(const CategoryFilter&amp; cf);</a>
<a name="ln302"> </a>
<a name="ln303">  ~CategoryFilter();</a>
<a name="ln304"> </a>
<a name="ln305">  CategoryFilter&amp; operator=(const CategoryFilter&amp; rhs);</a>
<a name="ln306"> </a>
<a name="ln307">  // Writes the string representation of the CategoryFilter. This is a comma</a>
<a name="ln308">  // separated string, similar in nature to the one used to determine</a>
<a name="ln309">  // enabled/disabled category patterns, except here there is an arbitrary</a>
<a name="ln310">  // order, included categories go first, then excluded categories. Excluded</a>
<a name="ln311">  // categories are distinguished from included categories by the prefix '-'.</a>
<a name="ln312">  std::string ToString() const;</a>
<a name="ln313"> </a>
<a name="ln314">  // Determines whether category group would be enabled or</a>
<a name="ln315">  // disabled by this category filter.</a>
<a name="ln316">  bool IsCategoryGroupEnabled(const char* category_group) const;</a>
<a name="ln317"> </a>
<a name="ln318">  // Return a list of the synthetic delays specified in this category filter.</a>
<a name="ln319">  const StringList&amp; GetSyntheticDelayValues() const;</a>
<a name="ln320"> </a>
<a name="ln321">  // Merges nested_filter with the current CategoryFilter</a>
<a name="ln322">  void Merge(const CategoryFilter&amp; nested_filter);</a>
<a name="ln323"> </a>
<a name="ln324">  // Clears both included/excluded pattern lists. This would be equivalent to</a>
<a name="ln325">  // creating a CategoryFilter with an empty string, through the constructor.</a>
<a name="ln326">  // i.e: CategoryFilter(&quot;&quot;).</a>
<a name="ln327">  //</a>
<a name="ln328">  // When using an empty filter, all categories are considered included as we</a>
<a name="ln329">  // are not excluding anything.</a>
<a name="ln330">  void Clear();</a>
<a name="ln331"> </a>
<a name="ln332"> private:</a>
<a name="ln333">  FRIEND_TEST(TraceEventTestFixture, CategoryFilter);</a>
<a name="ln334"> </a>
<a name="ln335">  static bool IsEmptyOrContainsLeadingOrTrailingWhitespace(</a>
<a name="ln336">      const std::string&amp; str);</a>
<a name="ln337"> </a>
<a name="ln338">  void Initialize(const std::string&amp; filter_string);</a>
<a name="ln339">  void WriteString(const StringList&amp; values,</a>
<a name="ln340">                   std::string* out,</a>
<a name="ln341">                   bool included) const;</a>
<a name="ln342">  void WriteString(const StringList&amp; delays, std::string* out) const;</a>
<a name="ln343">  bool HasIncludedPatterns() const;</a>
<a name="ln344"> </a>
<a name="ln345">  bool DoesCategoryGroupContainCategory(const char* category_group,</a>
<a name="ln346">                                        const char* category) const;</a>
<a name="ln347"> </a>
<a name="ln348">  StringList included_;</a>
<a name="ln349">  StringList disabled_;</a>
<a name="ln350">  StringList excluded_;</a>
<a name="ln351">  StringList delays_;</a>
<a name="ln352">};</a>
<a name="ln353"> </a>
<a name="ln354">class TraceSamplingThread;</a>
<a name="ln355"> </a>
<a name="ln356">class BASE_EXPORT TraceLog {</a>
<a name="ln357"> public:</a>
<a name="ln358">  enum Mode {</a>
<a name="ln359">    DISABLED = 0,</a>
<a name="ln360">    RECORDING_MODE,</a>
<a name="ln361">    MONITORING_MODE,</a>
<a name="ln362">  };</a>
<a name="ln363"> </a>
<a name="ln364">  // Options determines how the trace buffer stores data.</a>
<a name="ln365">  enum Options {</a>
<a name="ln366">    // Record until the trace buffer is full.</a>
<a name="ln367">    RECORD_UNTIL_FULL = 1 &lt;&lt; 0,</a>
<a name="ln368"> </a>
<a name="ln369">    // Record until the user ends the trace. The trace buffer is a fixed size</a>
<a name="ln370">    // and we use it as a ring buffer during recording.</a>
<a name="ln371">    RECORD_CONTINUOUSLY = 1 &lt;&lt; 1,</a>
<a name="ln372"> </a>
<a name="ln373">    // Enable the sampling profiler in the recording mode.</a>
<a name="ln374">    ENABLE_SAMPLING = 1 &lt;&lt; 2,</a>
<a name="ln375"> </a>
<a name="ln376">    // Echo to console. Events are discarded.</a>
<a name="ln377">    ECHO_TO_CONSOLE = 1 &lt;&lt; 3,</a>
<a name="ln378">  };</a>
<a name="ln379"> </a>
<a name="ln380">  // The pointer returned from GetCategoryGroupEnabledInternal() points to a</a>
<a name="ln381">  // value with zero or more of the following bits. Used in this class only.</a>
<a name="ln382">  // The TRACE_EVENT macros should only use the value as a bool.</a>
<a name="ln383">  // These values must be in sync with macro values in TraceEvent.h in Blink.</a>
<a name="ln384">  enum CategoryGroupEnabledFlags {</a>
<a name="ln385">    // Category group enabled for the recording mode.</a>
<a name="ln386">    ENABLED_FOR_RECORDING = 1 &lt;&lt; 0,</a>
<a name="ln387">    // Category group enabled for the monitoring mode.</a>
<a name="ln388">    ENABLED_FOR_MONITORING = 1 &lt;&lt; 1,</a>
<a name="ln389">    // Category group enabled by SetEventCallbackEnabled().</a>
<a name="ln390">    ENABLED_FOR_EVENT_CALLBACK = 1 &lt;&lt; 2,</a>
<a name="ln391">  };</a>
<a name="ln392"> </a>
<a name="ln393">  static TraceLog* GetInstance();</a>
<a name="ln394"> </a>
<a name="ln395">  // Get set of known category groups. This can change as new code paths are</a>
<a name="ln396">  // reached. The known category groups are inserted into |category_groups|.</a>
<a name="ln397">  void GetKnownCategoryGroups(std::vector&lt;std::string&gt;* category_groups);</a>
<a name="ln398"> </a>
<a name="ln399">  // Retrieves a copy (for thread-safety) of the current CategoryFilter.</a>
<a name="ln400">  CategoryFilter GetCurrentCategoryFilter();</a>
<a name="ln401"> </a>
<a name="ln402">  Options trace_options() const {</a>
<a name="ln403">    return static_cast&lt;Options&gt;(base::subtle::NoBarrier_Load(&amp;trace_options_));</a>
<a name="ln404">  }</a>
<a name="ln405"> </a>
<a name="ln406">  // Enables normal tracing (recording trace events in the trace buffer).</a>
<a name="ln407">  // See CategoryFilter comments for details on how to control what categories</a>
<a name="ln408">  // will be traced. If tracing has already been enabled, |category_filter| will</a>
<a name="ln409">  // be merged into the current category filter.</a>
<a name="ln410">  void SetEnabled(const CategoryFilter&amp; category_filter,</a>
<a name="ln411">                  Mode mode, Options options);</a>
<a name="ln412"> </a>
<a name="ln413">  // Disables normal tracing for all categories.</a>
<a name="ln414">  void SetDisabled();</a>
<a name="ln415"> </a>
<a name="ln416">  bool IsEnabled() { return mode_ != DISABLED; }</a>
<a name="ln417"> </a>
<a name="ln418">  // The number of times we have begun recording traces. If tracing is off,</a>
<a name="ln419">  // returns -1. If tracing is on, then it returns the number of times we have</a>
<a name="ln420">  // recorded a trace. By watching for this number to increment, you can</a>
<a name="ln421">  // passively discover when a new trace has begun. This is then used to</a>
<a name="ln422">  // implement the TRACE_EVENT_IS_NEW_TRACE() primitive.</a>
<a name="ln423">  int GetNumTracesRecorded();</a>
<a name="ln424"> </a>
<a name="ln425">#if defined(OS_ANDROID)</a>
<a name="ln426">  void StartATrace();</a>
<a name="ln427">  void StopATrace();</a>
<a name="ln428">  void AddClockSyncMetadataEvent();</a>
<a name="ln429">#endif</a>
<a name="ln430"> </a>
<a name="ln431">  // Enabled state listeners give a callback when tracing is enabled or</a>
<a name="ln432">  // disabled. This can be used to tie into other library's tracing systems</a>
<a name="ln433">  // on-demand.</a>
<a name="ln434">  class EnabledStateObserver {</a>
<a name="ln435">   public:</a>
<a name="ln436">    virtual ~EnabledStateObserver();</a>
<a name="ln437"> </a>
<a name="ln438">    // Called just after the tracing system becomes enabled, outside of the</a>
<a name="ln439">    // |lock_|. TraceLog::IsEnabled() is true at this point.</a>
<a name="ln440">    virtual void OnTraceLogEnabled() = 0;</a>
<a name="ln441"> </a>
<a name="ln442">    // Called just after the tracing system disables, outside of the |lock_|.</a>
<a name="ln443">    // TraceLog::IsEnabled() is false at this point.</a>
<a name="ln444">    virtual void OnTraceLogDisabled() = 0;</a>
<a name="ln445">  };</a>
<a name="ln446">  void AddEnabledStateObserver(EnabledStateObserver* listener);</a>
<a name="ln447">  void RemoveEnabledStateObserver(EnabledStateObserver* listener);</a>
<a name="ln448">  bool HasEnabledStateObserver(EnabledStateObserver* listener) const;</a>
<a name="ln449"> </a>
<a name="ln450">  float GetBufferPercentFull() const;</a>
<a name="ln451">  bool BufferIsFull() const;</a>
<a name="ln452"> </a>
<a name="ln453">  // Not using yb::Callback because of its limited by 7 parameters.</a>
<a name="ln454">  // Also, using primitive type allows directly passing callback from WebCore.</a>
<a name="ln455">  // WARNING: It is possible for the previously set callback to be called</a>
<a name="ln456">  // after a call to SetEventCallbackEnabled() that replaces or a call to</a>
<a name="ln457">  // SetEventCallbackDisabled() that disables the callback.</a>
<a name="ln458">  // This callback may be invoked on any thread.</a>
<a name="ln459">  // For TRACE_EVENT_PHASE_COMPLETE events, the client will still receive pairs</a>
<a name="ln460">  // of TRACE_EVENT_PHASE_BEGIN and TRACE_EVENT_PHASE_END events to keep the</a>
<a name="ln461">  // interface simple.</a>
<a name="ln462">  typedef void (*EventCallback)(MicrosecondsInt64 timestamp,</a>
<a name="ln463">                                char phase,</a>
<a name="ln464">                                const unsigned char* category_group_enabled,</a>
<a name="ln465">                                const char* name,</a>
<a name="ln466">                                uint64_t id,</a>
<a name="ln467">                                int num_args,</a>
<a name="ln468">                                const char* const arg_names[],</a>
<a name="ln469">                                const unsigned char arg_types[],</a>
<a name="ln470">                                const uint64_t arg_values[],</a>
<a name="ln471">                                unsigned char flags);</a>
<a name="ln472"> </a>
<a name="ln473">  // Enable tracing for EventCallback.</a>
<a name="ln474">  void SetEventCallbackEnabled(const CategoryFilter&amp; category_filter,</a>
<a name="ln475">                               EventCallback cb);</a>
<a name="ln476">  void SetEventCallbackDisabled();</a>
<a name="ln477"> </a>
<a name="ln478">  // Flush all collected events to the given output callback. The callback will</a>
<a name="ln479">  // be called one or more times synchronously from</a>
<a name="ln480">  // the current thread with IPC-bite-size chunks. The string format is</a>
<a name="ln481">  // undefined. Use TraceResultBuffer to convert one or more trace strings to</a>
<a name="ln482">  // JSON. The callback can be null if the caller doesn't want any data.</a>
<a name="ln483">  // Due to the implementation of thread-local buffers, flush can't be</a>
<a name="ln484">  // done when tracing is enabled. If called when tracing is enabled, the</a>
<a name="ln485">  // callback will be called directly with (empty_string, false) to indicate</a>
<a name="ln486">  // the end of this unsuccessful flush.</a>
<a name="ln487">  typedef yb::Callback&lt;void(const scoped_refptr&lt;yb::RefCountedString&gt;&amp;,</a>
<a name="ln488">                              bool has_more_events)&gt; OutputCallback;</a>
<a name="ln489">  void Flush(const OutputCallback&amp; cb);</a>
<a name="ln490">  void FlushButLeaveBufferIntact(const OutputCallback&amp; flush_output_callback);</a>
<a name="ln491"> </a>
<a name="ln492">  // Called by TRACE_EVENT* macros, don't call this directly.</a>
<a name="ln493">  // The name parameter is a category group for example:</a>
<a name="ln494">  // TRACE_EVENT0(&quot;renderer,webkit&quot;, &quot;WebViewImpl::HandleInputEvent&quot;)</a>
<a name="ln495">  static const unsigned char* GetCategoryGroupEnabled(const char* name);</a>
<a name="ln496">  static const char* GetCategoryGroupName(</a>
<a name="ln497">      const unsigned char* category_group_enabled);</a>
<a name="ln498"> </a>
<a name="ln499">  // Called by TRACE_EVENT* macros, don't call this directly.</a>
<a name="ln500">  // If |copy| is set, |name|, |arg_name1| and |arg_name2| will be deep copied</a>
<a name="ln501">  // into the event; see &quot;Memory scoping note&quot; and TRACE_EVENT_COPY_XXX above.</a>
<a name="ln502">  TraceEventHandle AddTraceEvent(</a>
<a name="ln503">      char phase,</a>
<a name="ln504">      const unsigned char* category_group_enabled,</a>
<a name="ln505">      const char* name,</a>
<a name="ln506">      uint64_t id,</a>
<a name="ln507">      int num_args,</a>
<a name="ln508">      const char** arg_names,</a>
<a name="ln509">      const unsigned char* arg_types,</a>
<a name="ln510">      const uint64_t* arg_values,</a>
<a name="ln511">      const scoped_refptr&lt;ConvertableToTraceFormat&gt;* convertable_values,</a>
<a name="ln512">      unsigned char flags);</a>
<a name="ln513">  TraceEventHandle AddTraceEventWithThreadIdAndTimestamp(</a>
<a name="ln514">      char phase,</a>
<a name="ln515">      const unsigned char* category_group_enabled,</a>
<a name="ln516">      const char* name,</a>
<a name="ln517">      uint64_t id,</a>
<a name="ln518">      int thread_id,</a>
<a name="ln519">      const MicrosecondsInt64&amp; timestamp,</a>
<a name="ln520">      int num_args,</a>
<a name="ln521">      const char** arg_names,</a>
<a name="ln522">      const unsigned char* arg_types,</a>
<a name="ln523">      const uint64_t* arg_values,</a>
<a name="ln524">      const scoped_refptr&lt;ConvertableToTraceFormat&gt;* convertable_values,</a>
<a name="ln525">      unsigned char flags);</a>
<a name="ln526">  static void AddTraceEventEtw(char phase,</a>
<a name="ln527">                               const char* category_group,</a>
<a name="ln528">                               const void* id,</a>
<a name="ln529">                               const char* extra);</a>
<a name="ln530">  static void AddTraceEventEtw(char phase,</a>
<a name="ln531">                               const char* category_group,</a>
<a name="ln532">                               const void* id,</a>
<a name="ln533">                               const std::string&amp; extra);</a>
<a name="ln534"> </a>
<a name="ln535">  void UpdateTraceEventDuration(const unsigned char* category_group_enabled,</a>
<a name="ln536">                                const char* name,</a>
<a name="ln537">                                TraceEventHandle handle);</a>
<a name="ln538"> </a>
<a name="ln539">  // For every matching event, the callback will be called.</a>
<a name="ln540">  typedef yb::Callback&lt;void()&gt; WatchEventCallback;</a>
<a name="ln541">  void SetWatchEvent(const std::string&amp; category_name,</a>
<a name="ln542">                     const std::string&amp; event_name,</a>
<a name="ln543">                     const WatchEventCallback&amp; callback);</a>
<a name="ln544">  // Cancel the watch event. If tracing is enabled, this may race with the</a>
<a name="ln545">  // watch event notification firing.</a>
<a name="ln546">  void CancelWatchEvent();</a>
<a name="ln547"> </a>
<a name="ln548">  int process_id() const { return process_id_; }</a>
<a name="ln549"> </a>
<a name="ln550">  // Allow tests to inspect TraceEvents.</a>
<a name="ln551">  size_t GetEventsSize() const { return logged_events_-&gt;Size(); }</a>
<a name="ln552">  TraceEvent* GetEventByHandle(TraceEventHandle handle);</a>
<a name="ln553"> </a>
<a name="ln554">  void SetProcessID(int process_id);</a>
<a name="ln555"> </a>
<a name="ln556">  // Process sort indices, if set, override the order of a process will appear</a>
<a name="ln557">  // relative to other processes in the trace viewer. Processes are sorted first</a>
<a name="ln558">  // on their sort index, ascending, then by their name, and then tid.</a>
<a name="ln559">  void SetProcessSortIndex(int sort_index);</a>
<a name="ln560"> </a>
<a name="ln561">  // Sets the name of the process.</a>
<a name="ln562">  void SetProcessName(const std::string&amp; process_name);</a>
<a name="ln563"> </a>
<a name="ln564">  // Processes can have labels in addition to their names. Use labels, for</a>
<a name="ln565">  // instance, to list out the web page titles that a process is handling.</a>
<a name="ln566">  void UpdateProcessLabel(int label_id, const std::string&amp; current_label);</a>
<a name="ln567">  void RemoveProcessLabel(int label_id);</a>
<a name="ln568"> </a>
<a name="ln569">  // Thread sort indices, if set, override the order of a thread will appear</a>
<a name="ln570">  // within its process in the trace viewer. Threads are sorted first on their</a>
<a name="ln571">  // sort index, ascending, then by their name, and then tid.</a>
<a name="ln572">  void SetThreadSortIndex(int64_t tid , int sort_index);</a>
<a name="ln573"> </a>
<a name="ln574">  // Allow setting an offset between the current MicrosecondsInt64 time and the time</a>
<a name="ln575">  // that should be reported.</a>
<a name="ln576">  void SetTimeOffset(MicrosecondsInt64 offset);</a>
<a name="ln577"> </a>
<a name="ln578">  size_t GetObserverCountForTest() const;</a>
<a name="ln579"> </a>
<a name="ln580"> </a>
<a name="ln581"> private:</a>
<a name="ln582">  FRIEND_TEST(TraceEventTestFixture,</a>
<a name="ln583">                           TraceBufferRingBufferGetReturnChunk);</a>
<a name="ln584">  FRIEND_TEST(TraceEventTestFixture,</a>
<a name="ln585">                           TraceBufferRingBufferHalfIteration);</a>
<a name="ln586">  FRIEND_TEST(TraceEventTestFixture,</a>
<a name="ln587">                           TraceBufferRingBufferFullIteration);</a>
<a name="ln588"> </a>
<a name="ln589">  // This allows constructor and destructor to be private and usable only</a>
<a name="ln590">  // by the Singleton class.</a>
<a name="ln591">  friend class Singleton&lt;TraceLog&gt;;</a>
<a name="ln592"> </a>
<a name="ln593">  // Enable/disable each category group based on the current mode_,</a>
<a name="ln594">  // category_filter_, event_callback_ and event_callback_category_filter_.</a>
<a name="ln595">  // Enable the category group in the enabled mode if category_filter_ matches</a>
<a name="ln596">  // the category group, or event_callback_ is not null and</a>
<a name="ln597">  // event_callback_category_filter_ matches the category group.</a>
<a name="ln598">  void UpdateCategoryGroupEnabledFlags();</a>
<a name="ln599">  void UpdateCategoryGroupEnabledFlag(int category_index);</a>
<a name="ln600"> </a>
<a name="ln601">  // Configure synthetic delays based on the values set in the current</a>
<a name="ln602">  // category filter.</a>
<a name="ln603">  void UpdateSyntheticDelaysFromCategoryFilter();</a>
<a name="ln604"> </a>
<a name="ln605">  struct PerThreadInfo;</a>
<a name="ln606">  class OptionalAutoLock;</a>
<a name="ln607">  class ThreadLocalEventBuffer;</a>
<a name="ln608"> </a>
<a name="ln609">  TraceLog();</a>
<a name="ln610">  ~TraceLog();</a>
<a name="ln611">  const unsigned char* GetCategoryGroupEnabledInternal(const char* name);</a>
<a name="ln612">  void AddMetadataEventsWhileLocked();</a>
<a name="ln613"> </a>
<a name="ln614">  TraceBuffer* trace_buffer() const { return logged_events_.get(); }</a>
<a name="ln615">  TraceBuffer* CreateTraceBuffer();</a>
<a name="ln616"> </a>
<a name="ln617">  std::string EventToConsoleMessage(unsigned char phase,</a>
<a name="ln618">                                    const MicrosecondsInt64&amp; timestamp,</a>
<a name="ln619">                                    TraceEvent* trace_event);</a>
<a name="ln620"> </a>
<a name="ln621">  TraceEvent* AddEventToThreadSharedChunkWhileLocked(TraceEventHandle* handle,</a>
<a name="ln622">                                                     bool check_buffer_is_full);</a>
<a name="ln623">  void CheckIfBufferIsFullWhileLocked();</a>
<a name="ln624">  void SetDisabledWhileLocked();</a>
<a name="ln625"> </a>
<a name="ln626">  TraceEvent* GetEventByHandleInternal(TraceEventHandle handle,</a>
<a name="ln627">                                       OptionalAutoLock* lock);</a>
<a name="ln628"> </a>
<a name="ln629">  void ConvertTraceEventsToTraceFormat(gscoped_ptr&lt;TraceBuffer&gt; logged_events,</a>
<a name="ln630">                                       const OutputCallback&amp; flush_output_callback);</a>
<a name="ln631">  void FinishFlush(int generation,</a>
<a name="ln632">                   const OutputCallback&amp; flush_output_callback);</a>
<a name="ln633"> </a>
<a name="ln634">  // Called when a thread which has registered trace events is about to exit.</a>
<a name="ln635">  void ThreadExiting();</a>
<a name="ln636"> </a>
<a name="ln637">  int generation() const {</a>
<a name="ln638">    return static_cast&lt;int&gt;(base::subtle::NoBarrier_Load(&amp;generation_));</a>
<a name="ln639">  }</a>
<a name="ln640">  bool CheckGeneration(int generation) const {</a>
<a name="ln641">    return generation == this-&gt;generation();</a>
<a name="ln642">  }</a>
<a name="ln643">  void UseNextTraceBuffer();</a>
<a name="ln644"> </a>
<a name="ln645">  MicrosecondsInt64 OffsetNow() const {</a>
<a name="ln646">    return OffsetTimestamp(GetMonoTimeMicros());</a>
<a name="ln647">  }</a>
<a name="ln648">  MicrosecondsInt64 OffsetTimestamp(const MicrosecondsInt64&amp; timestamp) const {</a>
<a name="ln649">    return timestamp - time_offset_;</a>
<a name="ln650">  }</a>
<a name="ln651"> </a>
<a name="ln652">  // Create a new PerThreadInfo object for the current thread,</a>
<a name="ln653">  // and register it in the active_threads_ list.</a>
<a name="ln654">  PerThreadInfo* SetupThreadLocalBuffer();</a>
<a name="ln655"> </a>
<a name="ln656">  // This lock protects TraceLog member accesses (except for members protected</a>
<a name="ln657">  // by thread_info_lock_) from arbitrary threads.</a>
<a name="ln658">  mutable base::SpinLock lock_;</a>
<a name="ln659">  // This lock protects accesses to thread_names_, thread_event_start_times_</a>
<a name="ln660">  // and thread_colors_.</a>
<a name="ln661">  base::SpinLock thread_info_lock_;</a>
<a name="ln662">  int locked_line_;</a>
<a name="ln663">  Mode mode_;</a>
<a name="ln664">  int num_traces_recorded_;</a>
<a name="ln665">  gscoped_ptr&lt;TraceBuffer&gt; logged_events_;</a>
<a name="ln666">  AtomicWord /* EventCallback */ event_callback_;</a>
<a name="ln667">  bool dispatching_to_observer_list_;</a>
<a name="ln668">  std::vector&lt;EnabledStateObserver*&gt; enabled_state_observer_list_;</a>
<a name="ln669"> </a>
<a name="ln670">  std::string process_name_;</a>
<a name="ln671">  std::unordered_map&lt;int, std::string&gt; process_labels_;</a>
<a name="ln672">  int process_sort_index_;</a>
<a name="ln673">  std::unordered_map&lt;int, int&gt; thread_sort_indices_;</a>
<a name="ln674">  std::unordered_map&lt;int, std::string&gt; thread_names_;</a>
<a name="ln675"> </a>
<a name="ln676">  // The following two maps are used only when ECHO_TO_CONSOLE.</a>
<a name="ln677">  std::unordered_map&lt;int, std::stack&lt;MicrosecondsInt64&gt; &gt; thread_event_start_times_;</a>
<a name="ln678">  std::unordered_map&lt;std::string, int&gt; thread_colors_;</a>
<a name="ln679"> </a>
<a name="ln680">  // XORed with TraceID to make it unlikely to collide with other processes.</a>
<a name="ln681">  uint64_t process_id_hash_;</a>
<a name="ln682"> </a>
<a name="ln683">  int process_id_;</a>
<a name="ln684"> </a>
<a name="ln685">  MicrosecondsInt64 time_offset_;</a>
<a name="ln686"> </a>
<a name="ln687">  // Allow tests to wake up when certain events occur.</a>
<a name="ln688">  WatchEventCallback watch_event_callback_;</a>
<a name="ln689">  AtomicWord /* const unsigned char* */ watch_category_;</a>
<a name="ln690">  std::string watch_event_name_;</a>
<a name="ln691"> </a>
<a name="ln692">  AtomicWord /* Options */ trace_options_;</a>
<a name="ln693"> </a>
<a name="ln694">  // Sampling thread handles.</a>
<a name="ln695">  gscoped_ptr&lt;TraceSamplingThread&gt; sampling_thread_;</a>
<a name="ln696">  scoped_refptr&lt;yb::Thread&gt; sampling_thread_handle_;</a>
<a name="ln697"> </a>
<a name="ln698">  CategoryFilter category_filter_;</a>
<a name="ln699">  CategoryFilter event_callback_category_filter_;</a>
<a name="ln700"> </a>
<a name="ln701">  struct PerThreadInfo {</a>
<a name="ln702">    ThreadLocalEventBuffer* event_buffer_;</a>
<a name="ln703">    base::subtle::Atomic32 is_in_trace_event_;</a>
<a name="ln704"> </a>
<a name="ln705">    // Atomically take the event_buffer_ member, setting it to NULL.</a>
<a name="ln706">    // Returns the old value of the member.</a>
<a name="ln707">    ThreadLocalEventBuffer* AtomicTakeBuffer();</a>
<a name="ln708">  };</a>
<a name="ln709">  static __thread PerThreadInfo* thread_local_info_;</a>
<a name="ln710"> </a>
<a name="ln711">  Mutex active_threads_lock_;</a>
<a name="ln712">  // Map of PID -&gt; PerThreadInfo</a>
<a name="ln713">  // Protected by active_threads_lock_.</a>
<a name="ln714">  typedef std::unordered_map&lt;int64_t, PerThreadInfo*&gt; ActiveThreadMap;</a>
<a name="ln715">  ActiveThreadMap active_threads_;</a>
<a name="ln716"> </a>
<a name="ln717">  // For events which can't be added into the thread local buffer, e.g. events</a>
<a name="ln718">  // from threads without a message loop.</a>
<a name="ln719">  gscoped_ptr&lt;TraceBufferChunk&gt; thread_shared_chunk_;</a>
<a name="ln720">  size_t thread_shared_chunk_index_;</a>
<a name="ln721"> </a>
<a name="ln722">  // The generation is incremented whenever tracing is enabled, and incremented</a>
<a name="ln723">  // again when the buffers are flushed. This ensures that trace events logged</a>
<a name="ln724">  // for a previous tracing session do not get accidentally flushed in the</a>
<a name="ln725">  // next tracing session.</a>
<a name="ln726">  AtomicWord generation_;</a>
<a name="ln727"> </a>
<a name="ln728">  DISALLOW_COPY_AND_ASSIGN(TraceLog);</a>
<a name="ln729">};</a>
<a name="ln730"> </a>
<a name="ln731">}  // namespace debug</a>
<a name="ln732">}  // namespace yb</a>
<a name="ln733"> </a>
<a name="ln734">#endif // YB_UTIL_DEBUG_TRACE_EVENT_IMPL_H_</a>

</code></pre>
<div class="balloon" rel="210"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="214"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
