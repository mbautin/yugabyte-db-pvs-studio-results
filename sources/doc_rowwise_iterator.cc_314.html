
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>doc_rowwise_iterator.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Copyright (c) YugaByte, Inc.</a>
<a name="ln2">//</a>
<a name="ln3">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln4">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln5">//</a>
<a name="ln6">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln7">//</a>
<a name="ln8">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln9">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln10">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln11">// under the License.</a>
<a name="ln12">//</a>
<a name="ln13"> </a>
<a name="ln14">#include &quot;yb/docdb/doc_rowwise_iterator.h&quot;</a>
<a name="ln15"> </a>
<a name="ln16">#include &quot;yb/common/partition.h&quot;</a>
<a name="ln17">#include &quot;yb/common/transaction.h&quot;</a>
<a name="ln18">#include &quot;yb/common/ql_expr.h&quot;</a>
<a name="ln19">#include &quot;yb/common/ql_scanspec.h&quot;</a>
<a name="ln20">#include &quot;yb/common/ql_value.h&quot;</a>
<a name="ln21"> </a>
<a name="ln22">#include &quot;yb/docdb/doc_key.h&quot;</a>
<a name="ln23">#include &quot;yb/docdb/doc_ql_scanspec.h&quot;</a>
<a name="ln24">#include &quot;yb/docdb/doc_reader.h&quot;</a>
<a name="ln25">#include &quot;yb/docdb/doc_scanspec_util.h&quot;</a>
<a name="ln26">#include &quot;yb/docdb/doc_ttl_util.h&quot;</a>
<a name="ln27">#include &quot;yb/docdb/docdb-internal.h&quot;</a>
<a name="ln28">#include &quot;yb/docdb/docdb_rocksdb_util.h&quot;</a>
<a name="ln29">#include &quot;yb/docdb/intent_aware_iterator.h&quot;</a>
<a name="ln30">#include &quot;yb/docdb/subdocument.h&quot;</a>
<a name="ln31">#include &quot;yb/gutil/strings/substitute.h&quot;</a>
<a name="ln32">#include &quot;yb/rocksdb/db/compaction.h&quot;</a>
<a name="ln33">#include &quot;yb/rocksutil/yb_rocksdb.h&quot;</a>
<a name="ln34"> </a>
<a name="ln35">#include &quot;yb/yql/pggate/util/pg_doc_data.h&quot;</a>
<a name="ln36"> </a>
<a name="ln37">using std::string;</a>
<a name="ln38"> </a>
<a name="ln39">namespace yb {</a>
<a name="ln40">namespace docdb {</a>
<a name="ln41"> </a>
<a name="ln42">class ScanChoices {</a>
<a name="ln43"> public:</a>
<a name="ln44">  explicit ScanChoices(bool is_forward_scan) : is_forward_scan_(is_forward_scan) {}</a>
<a name="ln45">  virtual ~ScanChoices() {}</a>
<a name="ln46"> </a>
<a name="ln47">  bool CurrentIteratorPositionMatchesCurrentTarget(const Slice&amp; curr) {</a>
<a name="ln48">    VLOG(3) &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; &quot; checking if acceptable ? &quot;</a>
<a name="ln49">            &lt;&lt; (curr == current_scan_target_ ? &quot;YEP&quot; : &quot;NOPE&quot;)</a>
<a name="ln50">            &lt;&lt; &quot;: &quot; &lt;&lt; DocKey::DebugSliceToString(curr)</a>
<a name="ln51">            &lt;&lt; &quot; vs &quot; &lt;&lt; DocKey::DebugSliceToString(current_scan_target_.AsSlice());</a>
<a name="ln52">    return curr == current_scan_target_;</a>
<a name="ln53">  }</a>
<a name="ln54"> </a>
<a name="ln55">  // Returns false if there are still target keys we need to scan, and true if we are done.</a>
<a name="ln56">  virtual bool FinishedWithScanChoices() const { return finished_; }</a>
<a name="ln57"> </a>
<a name="ln58">  // Go to the next scan target if any.</a>
<a name="ln59">  virtual CHECKED_STATUS DoneWithCurrentTarget() = 0;</a>
<a name="ln60"> </a>
<a name="ln61">  // Go (directly) to the new target (or the one after if new_target does not</a>
<a name="ln62">  // exist in the desired list/range). If the new_target is larger than all scan target options it</a>
<a name="ln63">  // means we are done.</a>
<a name="ln64">  virtual CHECKED_STATUS SkipTargetsUpTo(const Slice&amp; new_target) = 0;</a>
<a name="ln65"> </a>
<a name="ln66">  // If the given doc_key isn't already at the desired target, seek appropriately to go to the</a>
<a name="ln67">  // current target.</a>
<a name="ln68">  virtual CHECKED_STATUS SeekToCurrentTarget(IntentAwareIterator* db_iter) = 0;</a>
<a name="ln69"> </a>
<a name="ln70"> protected:</a>
<a name="ln71">  const bool is_forward_scan_;</a>
<a name="ln72">  KeyBytes current_scan_target_;</a>
<a name="ln73">  bool finished_ = false;</a>
<a name="ln74">};</a>
<a name="ln75"> </a>
<a name="ln76">class DiscreteScanChoices : public ScanChoices {</a>
<a name="ln77"> public:</a>
<a name="ln78">  DiscreteScanChoices(const DocQLScanSpec&amp; doc_spec, const KeyBytes&amp; lower_doc_key,</a>
<a name="ln79">                      const KeyBytes&amp; upper_doc_key)</a>
<a name="ln80">      : ScanChoices(doc_spec.is_forward_scan()) {</a>
<a name="ln81">    range_cols_scan_options_ = doc_spec.range_options();</a>
<a name="ln82">    current_scan_target_idxs_.resize(range_cols_scan_options_-&gt;size());</a>
<a name="ln83">    for (int i = 0; i &lt; range_cols_scan_options_-&gt;size(); i++) {</a>
<a name="ln84">      current_scan_target_idxs_[i] = range_cols_scan_options_-&gt;at(i).begin();</a>
<a name="ln85">    }</a>
<a name="ln86"> </a>
<a name="ln87">    // Initialize target doc key.</a>
<a name="ln88">    if (is_forward_scan_) {</a>
<a name="ln89">      current_scan_target_ = lower_doc_key;</a>
<a name="ln90">      if (CHECK_RESULT(ClearRangeComponents(&amp;current_scan_target_))) {</a>
<a name="ln91">        CHECK_OK(SkipTargetsUpTo(lower_doc_key));</a>
<a name="ln92">      }</a>
<a name="ln93">    } else {</a>
<a name="ln94">      current_scan_target_ = upper_doc_key;</a>
<a name="ln95">      if (CHECK_RESULT(ClearRangeComponents(&amp;current_scan_target_))) {</a>
<a name="ln96">        CHECK_OK(SkipTargetsUpTo(upper_doc_key));</a>
<a name="ln97">      }</a>
<a name="ln98">    }</a>
<a name="ln99">  }</a>
<a name="ln100"> </a>
<a name="ln101">  DiscreteScanChoices(const DocPgsqlScanSpec&amp; doc_spec, const KeyBytes&amp; lower_doc_key,</a>
<a name="ln102">                      const KeyBytes&amp; upper_doc_key)</a>
<a name="ln103">      : ScanChoices(doc_spec.is_forward_scan()) {</a>
<a name="ln104">    range_cols_scan_options_ = doc_spec.range_options();</a>
<a name="ln105">    current_scan_target_idxs_.resize(range_cols_scan_options_-&gt;size());</a>
<a name="ln106">    for (int i = 0; i &lt; range_cols_scan_options_-&gt;size(); i++) {</a>
<a name="ln107">      current_scan_target_idxs_[i] = range_cols_scan_options_-&gt;at(i).begin();</a>
<a name="ln108">    }</a>
<a name="ln109"> </a>
<a name="ln110">    // Initialize target doc key.</a>
<a name="ln111">    if (is_forward_scan_) {</a>
<a name="ln112">      current_scan_target_ = lower_doc_key;</a>
<a name="ln113">      if (CHECK_RESULT(ClearRangeComponents(&amp;current_scan_target_))) {</a>
<a name="ln114">        CHECK_OK(SkipTargetsUpTo(lower_doc_key));</a>
<a name="ln115">      }</a>
<a name="ln116">    } else {</a>
<a name="ln117">      current_scan_target_ = upper_doc_key;</a>
<a name="ln118">      if (CHECK_RESULT(ClearRangeComponents(&amp;current_scan_target_))) {</a>
<a name="ln119">        CHECK_OK(SkipTargetsUpTo(upper_doc_key));</a>
<a name="ln120">      }</a>
<a name="ln121">    }</a>
<a name="ln122">  }</a>
<a name="ln123"> </a>
<a name="ln124">  CHECKED_STATUS DoneWithCurrentTarget() override;</a>
<a name="ln125">  CHECKED_STATUS SkipTargetsUpTo(const Slice&amp; new_target) override;</a>
<a name="ln126">  CHECKED_STATUS SeekToCurrentTarget(IntentAwareIterator* db_iter) override;</a>
<a name="ln127"> </a>
<a name="ln128"> protected:</a>
<a name="ln129">  // Utility function for (multi)key scans. Updates the target scan key by incrementing the option</a>
<a name="ln130">  // index for one column. Will handle overflow by setting current column index to 0 and</a>
<a name="ln131">  // incrementing the previous column instead. If it overflows at first column it means we are done,</a>
<a name="ln132">  // so it clears the scan target idxs array.</a>
<a name="ln133">  CHECKED_STATUS IncrementScanTargetAtColumn(size_t start_col);</a>
<a name="ln134"> </a>
<a name="ln135">  // Utility function for (multi)key scans to initialize the range portion of the current scan</a>
<a name="ln136">  // target, scan target with the first option.</a>
<a name="ln137">  // Only needed for scans that include the static row, otherwise Init will take care of this.</a>
<a name="ln138">  Result&lt;bool&gt; InitScanTargetRangeGroupIfNeeded();</a>
<a name="ln139"> </a>
<a name="ln140"> private:</a>
<a name="ln141">  // For (multi)key scans (e.g. selects with 'IN' condition on the range columns) we hold the</a>
<a name="ln142">  // options for each range column as we iteratively seek to each target key.</a>
<a name="ln143">  // e.g. for a query &quot;h = 1 and r1 in (2,3) and r2 in (4,5) and r3 = 6&quot;:</a>
<a name="ln144">  //  range_cols_scan_options_   [[2, 3], [4, 5], [6]] -- value options for each column.</a>
<a name="ln145">  //  current_scan_target_idxs_  goes from [0, 0, 0] up to [1, 1, 0] -- except when including the</a>
<a name="ln146">  //                             static row when it starts from [0, 0, -1] instead.</a>
<a name="ln147">  //  current_scan_target_       goes from [1][2,4,6] up to [1][3,5,6] -- is the doc key containing,</a>
<a name="ln148">  //                             for each range column, the value (option) referenced by the</a>
<a name="ln149">  //                             corresponding index (updated along with current_scan_target_idxs_).</a>
<a name="ln150">  std::shared_ptr&lt;std::vector&lt;std::vector&lt;PrimitiveValue&gt;&gt;&gt; range_cols_scan_options_;</a>
<a name="ln151">  mutable std::vector&lt;std::vector&lt;PrimitiveValue&gt;::const_iterator&gt; current_scan_target_idxs_;</a>
<a name="ln152">};</a>
<a name="ln153"> </a>
<a name="ln154">Status DiscreteScanChoices::IncrementScanTargetAtColumn(size_t start_col) {</a>
<a name="ln155">  DCHECK_LE(start_col, current_scan_target_idxs_.size());</a>
<a name="ln156"> </a>
<a name="ln157">  // Increment start col, move backwards in case of overflow.</a>
<a name="ln158">  int col_idx = start_col;</a>
<a name="ln159">  for (; col_idx &gt;= 0; col_idx--) {</a>
<a name="ln160">    const auto&amp; choices = range_cols_scan_options_-&gt;at(col_idx);</a>
<a name="ln161">    auto&amp; it = current_scan_target_idxs_[col_idx];</a>
<a name="ln162"> </a>
<a name="ln163">    if (++it != choices.end()) {</a>
<a name="ln164">      break;</a>
<a name="ln165">    }</a>
<a name="ln166">    it = choices.begin();</a>
<a name="ln167">  }</a>
<a name="ln168"> </a>
<a name="ln169">  if (col_idx &lt; 0) {</a>
<a name="ln170">    // If we got here we finished all the options and are done.</a>
<a name="ln171">    finished_ = true;</a>
<a name="ln172">    return Status::OK();</a>
<a name="ln173">  }</a>
<a name="ln174"> </a>
<a name="ln175">  DocKeyDecoder decoder(current_scan_target_);</a>
<a name="ln176">  RETURN_NOT_OK(decoder.DecodeToRangeGroup());</a>
<a name="ln177">  for (int i = 0; i != col_idx; ++i) {</a>
<a name="ln178">    RETURN_NOT_OK(decoder.DecodePrimitiveValue());</a>
<a name="ln179">  }</a>
<a name="ln180"> </a>
<a name="ln181">  current_scan_target_.Truncate(</a>
<a name="ln182">      decoder.left_input().cdata() - current_scan_target_.AsSlice().cdata());</a>
<a name="ln183"> </a>
<a name="ln184">  for (size_t i = col_idx; i &lt;= start_col; ++i) {</a>
<a name="ln185">    current_scan_target_idxs_[i]-&gt;AppendToKey(&amp;current_scan_target_);</a>
<a name="ln186">  }</a>
<a name="ln187"> </a>
<a name="ln188">  return Status::OK();</a>
<a name="ln189">}</a>
<a name="ln190"> </a>
<a name="ln191">Result&lt;bool&gt; DiscreteScanChoices::InitScanTargetRangeGroupIfNeeded() {</a>
<a name="ln192">  DocKeyDecoder decoder(current_scan_target_.AsSlice());</a>
<a name="ln193">  RETURN_NOT_OK(decoder.DecodeToRangeGroup());</a>
<a name="ln194"> </a>
<a name="ln195">  // Initialize the range key values if needed (i.e. we scanned the static row until now).</a>
<a name="ln196">  if (!VERIFY_RESULT(decoder.HasPrimitiveValue())) {</a>
<a name="ln197">    current_scan_target_.mutable_data()-&gt;pop_back();</a>
<a name="ln198">    for (size_t col_idx = 0; col_idx &lt; range_cols_scan_options_-&gt;size(); col_idx++) {</a>
<a name="ln199">      current_scan_target_idxs_[col_idx]-&gt;AppendToKey(&amp;current_scan_target_);</a>
<a name="ln200">    }</a>
<a name="ln201">    current_scan_target_.AppendValueType(ValueType::kGroupEnd);</a>
<a name="ln202">    return true;</a>
<a name="ln203">  }</a>
<a name="ln204">  return false;</a>
<a name="ln205">}</a>
<a name="ln206"> </a>
<a name="ln207">Status DiscreteScanChoices::DoneWithCurrentTarget() {</a>
<a name="ln208">  VLOG(2) &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; &quot; moving on to next target&quot;;</a>
<a name="ln209">  DCHECK(!FinishedWithScanChoices());</a>
<a name="ln210"> </a>
<a name="ln211">  // Initialize the first target/option if not done already, otherwise go to the next one.</a>
<a name="ln212">  if (!VERIFY_RESULT(InitScanTargetRangeGroupIfNeeded())) {</a>
<a name="ln213">    RETURN_NOT_OK(IncrementScanTargetAtColumn(range_cols_scan_options_-&gt;size() - 1));</a>
<a name="ln214">    current_scan_target_.AppendValueType(ValueType::kGroupEnd);</a>
<a name="ln215">  }</a>
<a name="ln216">  return Status::OK();</a>
<a name="ln217">}</a>
<a name="ln218"> </a>
<a name="ln219">Status DiscreteScanChoices::SkipTargetsUpTo(const Slice&amp; new_target) {</a>
<a name="ln220">  VLOG(2) &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; &quot; Updating current target to be &gt;= &quot; &lt;&lt; new_target;</a>
<a name="ln221">  DCHECK(!FinishedWithScanChoices());</a>
<a name="ln222">  RETURN_NOT_OK(InitScanTargetRangeGroupIfNeeded());</a>
<a name="ln223">  DocKeyDecoder decoder(new_target);</a>
<a name="ln224">  RETURN_NOT_OK(decoder.DecodeToRangeGroup());</a>
<a name="ln225">  current_scan_target_.Reset(Slice(new_target.data(), decoder.left_input().data()));</a>
<a name="ln226"> </a>
<a name="ln227">  size_t col_idx = 0;</a>
<a name="ln228">  PrimitiveValue target_value;</a>
<a name="ln229">  while (col_idx &lt; range_cols_scan_options_-&gt;size()) {</a>
<a name="ln230">    RETURN_NOT_OK(decoder.DecodePrimitiveValue(&amp;target_value));</a>
<a name="ln231">    const auto&amp; choices = (*range_cols_scan_options_)[col_idx];</a>
<a name="ln232">    auto&amp; it = current_scan_target_idxs_[col_idx];</a>
<a name="ln233"> </a>
<a name="ln234">    // Fast-path in case the existing value for this column already matches the new target.</a>
<a name="ln235">    if (target_value == *it) {</a>
<a name="ln236">      col_idx++;</a>
<a name="ln237">      target_value.AppendToKey(&amp;current_scan_target_);</a>
<a name="ln238">      continue;</a>
<a name="ln239">    }</a>
<a name="ln240"> </a>
<a name="ln241">    // Search for the option that matches new target value (for the current column).</a>
<a name="ln242">    if (is_forward_scan_) {</a>
<a name="ln243">      it = std::lower_bound(choices.begin(), choices.end(), target_value);</a>
<a name="ln244">    } else {</a>
<a name="ln245">      it = std::lower_bound(choices.begin(), choices.end(), target_value, std::greater&lt;&gt;());</a>
<a name="ln246">    }</a>
<a name="ln247"> </a>
<a name="ln248">    // If we overflowed, the new target value for this column is larger than all our options, so</a>
<a name="ln249">    // we go back and increment the previous column instead.</a>
<a name="ln250">    if (it == choices.end()) {</a>
<a name="ln251">      RETURN_NOT_OK(IncrementScanTargetAtColumn(col_idx - 1));</a>
<a name="ln252">      break;</a>
<a name="ln253">    }</a>
<a name="ln254"> </a>
<a name="ln255">    // Else, update the current target value for this column.</a>
<a name="ln256">    it-&gt;AppendToKey(&amp;current_scan_target_);</a>
<a name="ln257"> </a>
<a name="ln258">    // If we did not find an exact match we are already beyond the new target so we can stop.</a>
<a name="ln259">    if (target_value != *it) {</a>
<a name="ln260">      col_idx++;</a>
<a name="ln261">      break;</a>
<a name="ln262">    }</a>
<a name="ln263"> </a>
<a name="ln264">    col_idx++;</a>
<a name="ln265">  }</a>
<a name="ln266"> </a>
<a name="ln267">  // If there are any columns left (i.e. we stopped early), it means we did not find an exact</a>
<a name="ln268">  // match and we reached beyond the new target key. So we need to include all options for the</a>
<a name="ln269">  // leftover columns (i.e. set all following indexes to 0).</a>
<a name="ln270">  for (size_t i = col_idx; i &lt; current_scan_target_idxs_.size(); i++) {</a>
<a name="ln271">    current_scan_target_idxs_[i] = (*range_cols_scan_options_)[i].begin();</a>
<a name="ln272">    current_scan_target_idxs_[i]-&gt;AppendToKey(&amp;current_scan_target_);</a>
<a name="ln273">  }</a>
<a name="ln274"> </a>
<a name="ln275">  current_scan_target_.AppendValueType(ValueType::kGroupEnd);</a>
<a name="ln276"> </a>
<a name="ln277">  return Status::OK();</a>
<a name="ln278">}</a>
<a name="ln279"> </a>
<a name="ln280">Status DiscreteScanChoices::SeekToCurrentTarget(IntentAwareIterator* db_iter) {</a>
<a name="ln281">  VLOG(2) &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; &quot; Advancing iterator towards target&quot;;</a>
<a name="ln282">  // Seek to the current target doc key if needed.</a>
<a name="ln283">  if (!FinishedWithScanChoices()) {</a>
<a name="ln284">    if (is_forward_scan_) {</a>
<a name="ln285">      VLOG(2) &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; &quot; Seeking to &quot; &lt;&lt; current_scan_target_;</a>
<a name="ln286">      db_iter-&gt;Seek(current_scan_target_);</a>
<a name="ln287">    } else {</a>
<a name="ln288">      auto tmp = current_scan_target_;</a>
<a name="ln289">      tmp.AppendValueType(ValueType::kHighest);</a>
<a name="ln290">      VLOG(2) &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; &quot; Going to PrevDocKey &quot; &lt;&lt; tmp;</a>
<a name="ln291">      db_iter-&gt;PrevDocKey(tmp);</a>
<a name="ln292">    }</a>
<a name="ln293">  }</a>
<a name="ln294">  return Status::OK();</a>
<a name="ln295">}</a>
<a name="ln296"> </a>
<a name="ln297">class RangeBasedScanChoices : public ScanChoices {</a>
<a name="ln298"> public:</a>
<a name="ln299">  RangeBasedScanChoices(const Schema&amp; schema, const DocQLScanSpec&amp; doc_spec)</a>
<a name="ln300">      : ScanChoices(doc_spec.is_forward_scan()) {</a>
<a name="ln301">    DCHECK(doc_spec.range_bounds());</a>
<a name="ln302">    lower_.reserve(schema.num_range_key_columns());</a>
<a name="ln303">    upper_.reserve(schema.num_range_key_columns());</a>
<a name="ln304">    int idx = 0;</a>
<a name="ln305">    for (idx = schema.num_hash_key_columns(); idx &lt; schema.num_key_columns(); idx++) {</a>
<a name="ln306">      const ColumnId col_idx = schema.column_id(idx);</a>
<a name="ln307">      const auto col_sort_type = schema.column(idx).sorting_type();</a>
<a name="ln308">      const common::QLScanRange::QLRange range = doc_spec.range_bounds()-&gt;RangeFor(col_idx);</a>
<a name="ln309">      const auto lower = GetQLRangeBoundAsPVal(range, col_sort_type, true /* lower_bound */);</a>
<a name="ln310">      const auto upper = GetQLRangeBoundAsPVal(range, col_sort_type, false /* upper_bound */);</a>
<a name="ln311">      lower_.emplace_back(lower);</a>
<a name="ln312">      upper_.emplace_back(upper);</a>
<a name="ln313">    }</a>
<a name="ln314">  }</a>
<a name="ln315"> </a>
<a name="ln316">  RangeBasedScanChoices(const Schema&amp; schema, const DocPgsqlScanSpec&amp; doc_spec)</a>
<a name="ln317">      : ScanChoices(doc_spec.is_forward_scan()) {</a>
<a name="ln318">    DCHECK(doc_spec.range_bounds());</a>
<a name="ln319">    lower_.reserve(schema.num_range_key_columns());</a>
<a name="ln320">    upper_.reserve(schema.num_range_key_columns());</a>
<a name="ln321">    int idx = 0;</a>
<a name="ln322">    for (idx = schema.num_hash_key_columns(); idx &lt; schema.num_key_columns(); idx++) {</a>
<a name="ln323">      const ColumnId col_idx = schema.column_id(idx);</a>
<a name="ln324">      const auto col_sort_type = schema.column(idx).sorting_type();</a>
<a name="ln325">      const common::QLScanRange::QLRange range = doc_spec.range_bounds()-&gt;RangeFor(col_idx);</a>
<a name="ln326">      const auto lower = GetQLRangeBoundAsPVal(range, col_sort_type, true /* lower_bound */);</a>
<a name="ln327">      const auto upper = GetQLRangeBoundAsPVal(range, col_sort_type, false /* upper_bound */);</a>
<a name="ln328">      lower_.emplace_back(lower);</a>
<a name="ln329">      upper_.emplace_back(upper);</a>
<a name="ln330">    }</a>
<a name="ln331">  }</a>
<a name="ln332"> </a>
<a name="ln333">  CHECKED_STATUS SkipTargetsUpTo(const Slice&amp; new_target) override;</a>
<a name="ln334">  CHECKED_STATUS DoneWithCurrentTarget() override;</a>
<a name="ln335">  CHECKED_STATUS SeekToCurrentTarget(IntentAwareIterator* db_iter) override;</a>
<a name="ln336"> </a>
<a name="ln337"> private:</a>
<a name="ln338">  std::vector&lt;PrimitiveValue&gt; lower_, upper_;</a>
<a name="ln339">  KeyBytes prev_scan_target_;</a>
<a name="ln340">};</a>
<a name="ln341"> </a>
<a name="ln342">Status RangeBasedScanChoices::SkipTargetsUpTo(const Slice&amp; new_target) {</a>
<a name="ln343">  VLOG(2) &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; &quot; Updating current target to be &gt;= &quot;</a>
<a name="ln344">          &lt;&lt; DocKey::DebugSliceToString(new_target);</a>
<a name="ln345">  DCHECK(!FinishedWithScanChoices());</a>
<a name="ln346"> </a>
<a name="ln347">  /*</a>
<a name="ln348">   Let's say we have a row key with (A B) as the hash part and C, D as the range part:</a>
<a name="ln349">   ((A B) C D) E F</a>
<a name="ln350"> </a>
<a name="ln351">   Let's say we have a range constraint :</a>
<a name="ln352">    l_c &lt; C &lt; u_c</a>
<a name="ln353">     4        6</a>
<a name="ln354"> </a>
<a name="ln355">    a b  0 d  -&gt; a  b l_c  l_d</a>
<a name="ln356"> </a>
<a name="ln357">    a b  5 d  -&gt; a  b  5    d</a>
<a name="ln358">                  [ Will subsequently week out of document on reading the subdoc]</a>
<a name="ln359"> </a>
<a name="ln360">    a b  7 d  -&gt; a &lt;b&gt; MAX</a>
<a name="ln361">                [ This will seek to &lt;b_next&gt; and on the next invocation update:</a>
<a name="ln362">                   a &lt;b_next&gt; ? ? -&gt; a &lt;b_next&gt; l_c l_d ]</a>
<a name="ln363">  */</a>
<a name="ln364">  DocKeyDecoder decoder(new_target);</a>
<a name="ln365">  RETURN_NOT_OK(decoder.DecodeToRangeGroup());</a>
<a name="ln366">  current_scan_target_.Reset(Slice(new_target.data(), decoder.left_input().data()));</a>
<a name="ln367"> </a>
<a name="ln368">  int col_idx = 0;</a>
<a name="ln369">  PrimitiveValue target_value;</a>
<a name="ln370">  bool last_was_infinity = false;</a>
<a name="ln371">  for (col_idx = 0; VERIFY_RESULT(decoder.HasPrimitiveValue()); col_idx++) {</a>
<a name="ln372">    RETURN_NOT_OK(decoder.DecodePrimitiveValue(&amp;target_value));</a>
<a name="ln373">    VLOG(3) &lt;&lt; &quot;col_idx &quot; &lt;&lt; col_idx &lt;&lt; &quot; is &quot; &lt;&lt; target_value &lt;&lt; &quot; in [&quot;</a>
<a name="ln374">            &lt;&lt; yb::ToString(lower_[col_idx]) &lt;&lt; &quot; , &quot; &lt;&lt; yb::ToString(upper_[col_idx]) &lt;&lt; &quot; ] ?&quot;;</a>
<a name="ln375"> </a>
<a name="ln376">    const auto&amp; lower = lower_[col_idx];</a>
<a name="ln377">    if (target_value &lt; lower) {</a>
<a name="ln378">      const auto tgt = (is_forward_scan_ ? lower : PrimitiveValue(ValueType::kLowest));</a>
<a name="ln379">      tgt.AppendToKey(&amp;current_scan_target_);</a>
<a name="ln380">      last_was_infinity = tgt.IsInfinity();</a>
<a name="ln381">      VLOG(3) &lt;&lt; &quot; Updating idx &quot; &lt;&lt; col_idx &lt;&lt; &quot; from &quot; &lt;&lt; target_value &lt;&lt; &quot; to &quot; &lt;&lt; tgt;</a>
<a name="ln382">      break;</a>
<a name="ln383">    }</a>
<a name="ln384">    const auto&amp; upper = upper_[col_idx];</a>
<a name="ln385">    if (target_value &gt; upper) {</a>
<a name="ln386">      const auto tgt = (!is_forward_scan_ ? upper : PrimitiveValue(ValueType::kHighest));</a>
<a name="ln387">      VLOG(3) &lt;&lt; &quot; Updating idx &quot; &lt;&lt; col_idx &lt;&lt; &quot; from &quot; &lt;&lt; target_value &lt;&lt; &quot; to &quot; &lt;&lt; tgt;</a>
<a name="ln388">      tgt.AppendToKey(&amp;current_scan_target_);</a>
<a name="ln389">      last_was_infinity = tgt.IsInfinity();</a>
<a name="ln390">      break;</a>
<a name="ln391">    }</a>
<a name="ln392">    target_value.AppendToKey(&amp;current_scan_target_);</a>
<a name="ln393">    last_was_infinity = target_value.IsInfinity();</a>
<a name="ln394">  }</a>
<a name="ln395"> </a>
<a name="ln396">  // Reset the remaining range columns to kHighest/lower for forward scans</a>
<a name="ln397">  // or kLowest/upper for backward scans.</a>
<a name="ln398">  while (++col_idx &lt; lower_.size()) {</a>
<a name="ln399">    if (last_was_infinity) {</a>
<a name="ln400">      // No point having more components after +/- Inf.</a>
<a name="ln401">      break;</a>
<a name="ln402">    }</a>
<a name="ln403">    if (is_forward_scan_) {</a>
<a name="ln404">      VLOG(3) &lt;&lt; &quot; Updating col_idx &quot; &lt;&lt; col_idx &lt;&lt; &quot; to &quot; &lt;&lt; lower_[col_idx];</a>
<a name="ln405">      lower_[col_idx].AppendToKey(&amp;current_scan_target_);</a>
<a name="ln406">      last_was_infinity = lower_[col_idx].IsInfinity();</a>
<a name="ln407">    } else {</a>
<a name="ln408">      VLOG(3) &lt;&lt; &quot; Updating col_idx &quot; &lt;&lt; col_idx &lt;&lt; &quot; to &quot; &lt;&lt; upper_[col_idx];</a>
<a name="ln409">      upper_[col_idx].AppendToKey(&amp;current_scan_target_);</a>
<a name="ln410">      last_was_infinity = upper_[col_idx].IsInfinity();</a>
<a name="ln411">    }</a>
<a name="ln412">  }</a>
<a name="ln413">  VLOG(2) &lt;&lt; &quot;After &quot; &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; &quot; current_scan_target_ is &quot;</a>
<a name="ln414">          &lt;&lt; DocKey::DebugSliceToString(current_scan_target_);</a>
<a name="ln415">  current_scan_target_.AppendValueType(ValueType::kGroupEnd);</a>
<a name="ln416"> </a>
<a name="ln417">  return Status::OK();</a>
<a name="ln418">}</a>
<a name="ln419"> </a>
<a name="ln420">Status RangeBasedScanChoices::DoneWithCurrentTarget() {</a>
<a name="ln421">  prev_scan_target_ = current_scan_target_;</a>
<a name="ln422">  current_scan_target_.Clear();</a>
<a name="ln423">  return Status::OK();</a>
<a name="ln424">}</a>
<a name="ln425"> </a>
<a name="ln426">Status RangeBasedScanChoices::SeekToCurrentTarget(IntentAwareIterator* db_iter) {</a>
<a name="ln427">  VLOG(2) &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; &quot; Advancing iterator towards target&quot;;</a>
<a name="ln428"> </a>
<a name="ln429">  if (!FinishedWithScanChoices()) {</a>
<a name="ln430">    if (!current_scan_target_.empty()) {</a>
<a name="ln431">      VLOG(3) &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; &quot; current_scan_target_ is non-empty. &quot;</a>
<a name="ln432">              &lt;&lt; current_scan_target_;</a>
<a name="ln433">      if (is_forward_scan_) {</a>
<a name="ln434">        VLOG(3) &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; &quot; Seeking to &quot; &lt;&lt; current_scan_target_;</a>
<a name="ln435">        db_iter-&gt;Seek(current_scan_target_);</a>
<a name="ln436">      } else {</a>
<a name="ln437">        auto tmp = current_scan_target_;</a>
<a name="ln438">        PrimitiveValue(ValueType::kHighest).AppendToKey(&amp;tmp);</a>
<a name="ln439">        VLOG(3) &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; &quot; Going to PrevDocKey &quot; &lt;&lt; tmp;  // Never seen.</a>
<a name="ln440">        db_iter-&gt;PrevDocKey(tmp);</a>
<a name="ln441">      }</a>
<a name="ln442">    } else {</a>
<a name="ln443">      if (!is_forward_scan_ &amp;&amp; !prev_scan_target_.empty()) {</a>
<a name="ln444">        db_iter-&gt;PrevDocKey(prev_scan_target_);</a>
<a name="ln445">      }</a>
<a name="ln446">    }</a>
<a name="ln447">  }</a>
<a name="ln448"> </a>
<a name="ln449">  return Status::OK();</a>
<a name="ln450">}</a>
<a name="ln451"> </a>
<a name="ln452">DocRowwiseIterator::DocRowwiseIterator(</a>
<a name="ln453">    const Schema &amp;projection,</a>
<a name="ln454">    const Schema &amp;schema,</a>
<a name="ln455">    const TransactionOperationContextOpt&amp; txn_op_context,</a>
<a name="ln456">    const DocDB&amp; doc_db,</a>
<a name="ln457">    CoarseTimePoint deadline,</a>
<a name="ln458">    const ReadHybridTime&amp; read_time,</a>
<a name="ln459">    RWOperationCounter* pending_op_counter)</a>
<a name="ln460">    : projection_(projection),</a>
<a name="ln461">      schema_(schema),</a>
<a name="ln462">      txn_op_context_(txn_op_context),</a>
<a name="ln463">      deadline_(deadline),</a>
<a name="ln464">      read_time_(read_time),</a>
<a name="ln465">      doc_db_(doc_db),</a>
<a name="ln466">      has_bound_key_(false),</a>
<a name="ln467">      pending_op_(pending_op_counter),</a>
<a name="ln468">      done_(false) {</a>
<a name="ln469">  projection_subkeys_.reserve(projection.num_columns() + 1);</a>
<a name="ln470">  projection_subkeys_.push_back(PrimitiveValue::SystemColumnId(SystemColumnIds::kLivenessColumn));</a>
<a name="ln471">  for (size_t i = projection_.num_key_columns(); i &lt; projection.num_columns(); i++) {</a>
<a name="ln472">    projection_subkeys_.emplace_back(projection.column_id(i));</a>
<a name="ln473">  }</a>
<a name="ln474">  std::sort(projection_subkeys_.begin(), projection_subkeys_.end());</a>
<a name="ln475">  deadline_info_.emplace(deadline);</a>
<a name="ln476">}</a>
<a name="ln477"> </a>
<a name="ln478">DocRowwiseIterator::~DocRowwiseIterator() {</a>
<a name="ln479">}</a>
<a name="ln480"> </a>
<a name="ln481">Status DocRowwiseIterator::Init() {</a>
<a name="ln482">  db_iter_ = CreateIntentAwareIterator(</a>
<a name="ln483">      doc_db_,</a>
<a name="ln484">      BloomFilterMode::DONT_USE_BLOOM_FILTER,</a>
<a name="ln485">      boost::none /* user_key_for_filter */,</a>
<a name="ln486">      rocksdb::kDefaultQueryId,</a>
<a name="ln487">      txn_op_context_,</a>
<a name="ln488">      deadline_,</a>
<a name="ln489">      read_time_);</a>
<a name="ln490"> </a>
<a name="ln491">  DocKeyEncoder(&amp;iter_key_).Schema(schema_);</a>
<a name="ln492">  row_key_ = iter_key_;</a>
<a name="ln493">  row_hash_key_ = row_key_;</a>
<a name="ln494">  VLOG(3) &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; &quot; Seeking to &quot; &lt;&lt; row_key_;</a>
<a name="ln495">  db_iter_-&gt;Seek(row_key_);</a>
<a name="ln496">  row_ready_ = false;</a>
<a name="ln497">  has_bound_key_ = false;</a>
<a name="ln498"> </a>
<a name="ln499">  return Status::OK();</a>
<a name="ln500">}</a>
<a name="ln501"> </a>
<a name="ln502">Result&lt;bool&gt; DocRowwiseIterator::InitScanChoices(</a>
<a name="ln503">    const DocQLScanSpec&amp; doc_spec, const KeyBytes&amp; lower_doc_key, const KeyBytes&amp; upper_doc_key) {</a>
<a name="ln504">  if (doc_spec.range_options()) {</a>
<a name="ln505">    scan_choices_.reset(new DiscreteScanChoices(doc_spec, lower_doc_key, upper_doc_key));</a>
<a name="ln506">    // Let's not seek to the lower doc key or upper doc key. We know exactly what we want.</a>
<a name="ln507">    RETURN_NOT_OK(AdvanceIteratorToNextDesiredRow());</a>
<a name="ln508">    return true;</a>
<a name="ln509">  }</a>
<a name="ln510"> </a>
<a name="ln511">  if (doc_spec.range_bounds()) {</a>
<a name="ln512">    scan_choices_.reset(new RangeBasedScanChoices(schema_, doc_spec));</a>
<a name="ln513">  }</a>
<a name="ln514"> </a>
<a name="ln515">  return false;</a>
<a name="ln516">}</a>
<a name="ln517"> </a>
<a name="ln518">Result&lt;bool&gt; DocRowwiseIterator::InitScanChoices(</a>
<a name="ln519">    const DocPgsqlScanSpec&amp; doc_spec, const KeyBytes&amp; lower_doc_key,</a>
<a name="ln520">    const KeyBytes&amp; upper_doc_key) {</a>
<a name="ln521">  if (doc_spec.range_options()) {</a>
<a name="ln522">    scan_choices_.reset(new DiscreteScanChoices(doc_spec, lower_doc_key, upper_doc_key));</a>
<a name="ln523">    // Let's not seek to the lower doc key or upper doc key. We know exactly what we want.</a>
<a name="ln524">    RETURN_NOT_OK(AdvanceIteratorToNextDesiredRow());</a>
<a name="ln525">    return true;</a>
<a name="ln526">  }</a>
<a name="ln527"> </a>
<a name="ln528">  if (doc_spec.range_bounds()) {</a>
<a name="ln529">    scan_choices_.reset(new RangeBasedScanChoices(schema_, doc_spec));</a>
<a name="ln530">  }</a>
<a name="ln531"> </a>
<a name="ln532">  return false;</a>
<a name="ln533">}</a>
<a name="ln534"> </a>
<a name="ln535">template &lt;class T&gt;</a>
<a name="ln536">Status DocRowwiseIterator::DoInit(const T&amp; doc_spec) {</a>
<a name="ln537">  is_forward_scan_ = doc_spec.is_forward_scan();</a>
<a name="ln538"> </a>
<a name="ln539">  VLOG(4) &lt;&lt; &quot;Initializing iterator direction: &quot; &lt;&lt; (is_forward_scan_ ? &quot;FORWARD&quot; : &quot;BACKWARD&quot;);</a>
<a name="ln540"> </a>
<a name="ln541">  auto lower_doc_key = VERIFY_RESULT(doc_spec.LowerBound());</a>
<a name="ln542">  auto upper_doc_key = VERIFY_RESULT(doc_spec.UpperBound());</a>
<a name="ln543">  VLOG(4) &lt;&lt; &quot;DocKey Bounds &quot; &lt;&lt; DocKey::DebugSliceToString(lower_doc_key.AsSlice())</a>
<a name="ln544">          &lt;&lt; &quot;, &quot; &lt;&lt; DocKey::DebugSliceToString(upper_doc_key.AsSlice());</a>
<a name="ln545"> </a>
<a name="ln546">  // TODO(bogdan): decide if this is a good enough heuristic for using blooms for scans.</a>
<a name="ln547">  const bool is_fixed_point_get =</a>
<a name="ln548">      !lower_doc_key.empty() &amp;&amp;</a>
<a name="ln549">      VERIFY_RESULT(HashedOrFirstRangeComponentsEqual(lower_doc_key, upper_doc_key));</a>
<a name="ln550">  const auto mode = is_fixed_point_get ? BloomFilterMode::USE_BLOOM_FILTER</a>
<a name="ln551">                                       : BloomFilterMode::DONT_USE_BLOOM_FILTER;</a>
<a name="ln552"> </a>
<a name="ln553">  db_iter_ = CreateIntentAwareIterator(</a>
<a name="ln554">      doc_db_, mode, lower_doc_key.AsSlice(), doc_spec.QueryId(), txn_op_context_,</a>
<a name="ln555">      deadline_, read_time_, doc_spec.CreateFileFilter());</a>
<a name="ln556"> </a>
<a name="ln557">  row_ready_ = false;</a>
<a name="ln558"> </a>
<a name="ln559">  if (is_forward_scan_) {</a>
<a name="ln560">    has_bound_key_ = !upper_doc_key.empty();</a>
<a name="ln561">    if (has_bound_key_) {</a>
<a name="ln562">      bound_key_ = std::move(upper_doc_key);</a>
<a name="ln563">      db_iter_-&gt;SetUpperbound(bound_key_);</a>
<a name="ln564">    }</a>
<a name="ln565">  } else {</a>
<a name="ln566">    has_bound_key_ = !lower_doc_key.empty();</a>
<a name="ln567">    if (has_bound_key_) {</a>
<a name="ln568">      bound_key_ = std::move(lower_doc_key);</a>
<a name="ln569">    }</a>
<a name="ln570">  }</a>
<a name="ln571"> </a>
<a name="ln572">  if (!VERIFY_RESULT(InitScanChoices(doc_spec, lower_doc_key, upper_doc_key))) {</a>
<a name="ln573">    if (is_forward_scan_) {</a>
<a name="ln574">      VLOG(3) &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; &quot; Seeking to &quot; &lt;&lt; DocKey::DebugSliceToString(lower_doc_key);</a>
<a name="ln575">      db_iter_-&gt;Seek(lower_doc_key);</a>
<a name="ln576">    } else {</a>
<a name="ln577">      // TODO consider adding an operator bool to DocKey to use instead of empty() here.</a>
<a name="ln578">      if (!upper_doc_key.empty()) {</a>
<a name="ln579">        db_iter_-&gt;PrevDocKey(upper_doc_key);</a>
<a name="ln580">      } else {</a>
<a name="ln581">        db_iter_-&gt;SeekToLastDocKey();</a>
<a name="ln582">      }</a>
<a name="ln583">    }</a>
<a name="ln584">  }</a>
<a name="ln585"> </a>
<a name="ln586">  return Status::OK();</a>
<a name="ln587">}</a>
<a name="ln588"> </a>
<a name="ln589">Status DocRowwiseIterator::Init(const common::QLScanSpec&amp; spec) {</a>
<a name="ln590">  return DoInit(dynamic_cast&lt;const DocQLScanSpec&amp;&gt;(spec));</a>
<a name="ln591">}</a>
<a name="ln592"> </a>
<a name="ln593">Status DocRowwiseIterator::Init(const common::PgsqlScanSpec&amp; spec) {</a>
<a name="ln594">  return DoInit(dynamic_cast&lt;const DocPgsqlScanSpec&amp;&gt;(spec));</a>
<a name="ln595">}</a>
<a name="ln596"> </a>
<a name="ln597">Status DocRowwiseIterator::AdvanceIteratorToNextDesiredRow() const {</a>
<a name="ln598">  if (scan_choices_) {</a>
<a name="ln599">    if (!IsNextStaticColumn()</a>
<a name="ln600">        &amp;&amp; !scan_choices_-&gt;CurrentIteratorPositionMatchesCurrentTarget(row_key_)) {</a>
<a name="ln601">      return scan_choices_-&gt;SeekToCurrentTarget(db_iter_.get());</a>
<a name="ln602">    }</a>
<a name="ln603">  } else {</a>
<a name="ln604">    if (!is_forward_scan_) {</a>
<a name="ln605">      VLOG(4) &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; &quot; setting as PrevDocKey&quot;;</a>
<a name="ln606">      db_iter_-&gt;PrevDocKey(row_key_);</a>
<a name="ln607">    }</a>
<a name="ln608">  }</a>
<a name="ln609"> </a>
<a name="ln610">  return Status::OK();</a>
<a name="ln611">}</a>
<a name="ln612"> </a>
<a name="ln613">Result&lt;bool&gt; DocRowwiseIterator::HasNext() const {</a>
<a name="ln614">  VLOG(4) &lt;&lt; __PRETTY_FUNCTION__;</a>
<a name="ln615"> </a>
<a name="ln616">  // Repeated HasNext calls (without Skip/NextRow in between) should be idempotent:</a>
<a name="ln617">  // 1. If a previous call failed we returned the same status.</a>
<a name="ln618">  // 2. If a row is already available (row_ready_), return true directly.</a>
<a name="ln619">  // 3. If we finished all target rows for the scan (done_), return false directly.</a>
<a name="ln620">  RETURN_NOT_OK(has_next_status_);</a>
<a name="ln621">  if (row_ready_) {</a>
<a name="ln622">    // If row is ready, then HasNext returns true.</a>
<a name="ln623">    return true;</a>
<a name="ln624">  }</a>
<a name="ln625">  if (done_) {</a>
<a name="ln626">    return false;</a>
<a name="ln627">  }</a>
<a name="ln628"> </a>
<a name="ln629">  bool doc_found = false;</a>
<a name="ln630">  while (!doc_found) {</a>
<a name="ln631">    if (!db_iter_-&gt;valid() || (scan_choices_ &amp;&amp; scan_choices_-&gt;FinishedWithScanChoices())) {</a>
<a name="ln632">      done_ = true;</a>
<a name="ln633">      return false;</a>
<a name="ln634">    }</a>
<a name="ln635"> </a>
<a name="ln636">    const auto key_data = db_iter_-&gt;FetchKey();</a>
<a name="ln637">    if (!key_data.ok()) {</a>
<a name="ln638">      has_next_status_ = key_data.status();</a>
<a name="ln639">      return has_next_status_;</a>
<a name="ln640">    }</a>
<a name="ln641"> </a>
<a name="ln642">    VLOG(4) &lt;&lt; &quot;*fetched_key is &quot; &lt;&lt; SubDocKey::DebugSliceToString(key_data-&gt;key);</a>
<a name="ln643"> </a>
<a name="ln644">    // The iterator is positioned by the previous GetSubDocument call (which places the iterator</a>
<a name="ln645">    // outside the previous doc_key). Ensure the iterator is pushed forward/backward indeed. We</a>
<a name="ln646">    // check it here instead of after GetSubDocument() below because we want to avoid the extra</a>
<a name="ln647">    // expensive FetchKey() call just to fetch and validate the key.</a>
<a name="ln648">    if (!iter_key_.data().empty() &amp;&amp;</a>
<a name="ln649">        (is_forward_scan_ ? iter_key_.CompareTo(key_data-&gt;key) &gt;= 0</a>
<a name="ln650">                          : iter_key_.CompareTo(key_data-&gt;key) &lt;= 0)) {</a>
<a name="ln651">      has_next_status_ = STATUS_SUBSTITUTE(Corruption, &quot;Infinite loop detected at $0&quot;,</a>
<a name="ln652">                                           FormatSliceAsStr(key_data-&gt;key));</a>
<a name="ln653">      return has_next_status_;</a>
<a name="ln654">    }</a>
<a name="ln655">    iter_key_.Reset(key_data-&gt;key);</a>
<a name="ln656">    VLOG(4) &lt;&lt; &quot; Current iter_key_ is &quot; &lt;&lt; iter_key_;</a>
<a name="ln657"> </a>
<a name="ln658">    const auto dockey_sizes = DocKey::EncodedHashPartAndDocKeySizes(iter_key_);</a>
<a name="ln659">    if (!dockey_sizes.ok()) {</a>
<a name="ln660">      has_next_status_ = dockey_sizes.status();</a>
<a name="ln661">      return has_next_status_;</a>
<a name="ln662">    }</a>
<a name="ln663">    row_hash_key_ = iter_key_.AsSlice().Prefix(dockey_sizes-&gt;first);</a>
<a name="ln664">    row_key_ = iter_key_.AsSlice().Prefix(dockey_sizes-&gt;second);</a>
<a name="ln665"> </a>
<a name="ln666">    if (!DocKeyBelongsTo(row_key_, schema_) ||</a>
<a name="ln667">        (has_bound_key_ &amp;&amp; is_forward_scan_ == (row_key_.compare(bound_key_) &gt;= 0))) {</a>
<a name="ln668">      done_ = true;</a>
<a name="ln669">      return false;</a>
<a name="ln670">    }</a>
<a name="ln671"> </a>
<a name="ln672">    // Prepare the DocKey to get the SubDocument. Trim the DocKey to contain just the primary key.</a>
<a name="ln673">    Slice sub_doc_key = row_key_;</a>
<a name="ln674">    VLOG(4) &lt;&lt; &quot; sub_doc_key part of iter_key_ is &quot; &lt;&lt; DocKey::DebugSliceToString(sub_doc_key);</a>
<a name="ln675"> </a>
<a name="ln676">    bool is_static_column = IsNextStaticColumn();</a>
<a name="ln677">    if (scan_choices_ &amp;&amp; !is_static_column) {</a>
<a name="ln678">      if (!scan_choices_-&gt;CurrentIteratorPositionMatchesCurrentTarget(row_key_)) {</a>
<a name="ln679">        // We must have seeked past the target key we are looking for (no result) so we can safely</a>
<a name="ln680">        // skip all scan targets between the current target and row key (excluding row_key_ itself).</a>
<a name="ln681">        // Update the target key and iterator and call HasNext again to try the next target.</a>
<a name="ln682">        RETURN_NOT_OK(scan_choices_-&gt;SkipTargetsUpTo(row_key_));</a>
<a name="ln683"> </a>
<a name="ln684">        // We updated scan target above, if it goes past the row_key_ we will seek again, and</a>
<a name="ln685">        // process the found key in the next loop.</a>
<a name="ln686">        if (!scan_choices_-&gt;CurrentIteratorPositionMatchesCurrentTarget(row_key_)) {</a>
<a name="ln687">          RETURN_NOT_OK(scan_choices_-&gt;SeekToCurrentTarget(db_iter_.get()));</a>
<a name="ln688">          continue;</a>
<a name="ln689">        }</a>
<a name="ln690">      }</a>
<a name="ln691">      // We found a match for the target key or a static column, so we move on to getting the</a>
<a name="ln692">      // SubDocument.</a>
<a name="ln693">    }</a>
<a name="ln694"> </a>
<a name="ln695">    GetSubDocumentData data = {</a>
<a name="ln696">      sub_doc_key,</a>
<a name="ln697">      &amp;row_,</a>
<a name="ln698">      &amp;doc_found,</a>
<a name="ln699">      TableTTL(schema_),</a>
<a name="ln700">      &amp;table_tombstone_time_,</a>
<a name="ln701">    };</a>
<a name="ln702">    data.deadline_info = deadline_info_.get_ptr();</a>
<a name="ln703">    has_next_status_ = GetSubDocument(db_iter_.get(), data, &amp;projection_subkeys_);</a>
<a name="ln704">    RETURN_NOT_OK(has_next_status_);</a>
<a name="ln705">    // After this, the iter should be positioned right after the subdocument.</a>
<a name="ln706"> </a>
<a name="ln707">    if (!doc_found) {</a>
<a name="ln708">      SubDocument full_row;</a>
<a name="ln709">      // If doc is not found, decide if some non-projection column exists.</a>
<a name="ln710">      // Currently we read the whole doc here,</a>
<a name="ln711">      // may be optimized by exiting on the first column in future.</a>
<a name="ln712">      db_iter_-&gt;Seek(row_key_);  // Position it for GetSubDocument.</a>
<a name="ln713">      data.result = &amp;full_row;</a>
<a name="ln714">      has_next_status_ = GetSubDocument(db_iter_.get(), data);</a>
<a name="ln715">      RETURN_NOT_OK(has_next_status_);</a>
<a name="ln716">    }</a>
<a name="ln717">    if (scan_choices_ &amp;&amp; !is_static_column) {</a>
<a name="ln718">      has_next_status_ = scan_choices_-&gt;DoneWithCurrentTarget();</a>
<a name="ln719">      RETURN_NOT_OK(has_next_status_);</a>
<a name="ln720">    }</a>
<a name="ln721">    has_next_status_ = AdvanceIteratorToNextDesiredRow();</a>
<a name="ln722">    RETURN_NOT_OK(has_next_status_);</a>
<a name="ln723">  }</a>
<a name="ln724">  row_ready_ = true;</a>
<a name="ln725">  return true;</a>
<a name="ln726">}</a>
<a name="ln727"> </a>
<a name="ln728">string DocRowwiseIterator::ToString() const {</a>
<a name="ln729">  return &quot;DocRowwiseIterator&quot;;</a>
<a name="ln730">}</a>
<a name="ln731"> </a>
<a name="ln732">namespace {</a>
<a name="ln733"> </a>
<a name="ln734">// Set primary key column values (hashed or range columns) in a QL row value map.</a>
<a name="ln735">CHECKED_STATUS SetQLPrimaryKeyColumnValues(const Schema&amp; schema,</a>
<a name="ln736">                                           const size_t begin_index,</a>
<a name="ln737">                                           const size_t column_count,</a>
<a name="ln738">                                           const char* column_type,</a>
<a name="ln739">                                           DocKeyDecoder* decoder,</a>
<a name="ln740">                                           QLTableRow* table_row) {</a>
<a name="ln741">  if (begin_index + column_count &gt; schema.num_columns()) {</a>
<a name="ln742">    return STATUS_SUBSTITUTE(</a>
<a name="ln743">        Corruption,</a>
<a name="ln744">        &quot;$0 primary key columns between positions $1 and $2 go beyond table columns $3&quot;,</a>
<a name="ln745">        column_type, begin_index, begin_index + column_count - 1, schema.num_columns());</a>
<a name="ln746">  }</a>
<a name="ln747">  PrimitiveValue primitive_value;</a>
<a name="ln748">  for (size_t i = 0, j = begin_index; i &lt; column_count; i++, j++) {</a>
<a name="ln749">    const auto ql_type = schema.column(j).type();</a>
<a name="ln750">    QLTableColumn&amp; column = table_row-&gt;AllocColumn(schema.column_id(j));</a>
<a name="ln751">    RETURN_NOT_OK(decoder-&gt;DecodePrimitiveValue(&amp;primitive_value));</a>
<a name="ln752">    PrimitiveValue::ToQLValuePB(primitive_value, ql_type, &amp;column.value);</a>
<a name="ln753">  }</a>
<a name="ln754">  return decoder-&gt;ConsumeGroupEnd();</a>
<a name="ln755">}</a>
<a name="ln756"> </a>
<a name="ln757">} // namespace</a>
<a name="ln758"> </a>
<a name="ln759">void DocRowwiseIterator::SkipRow() {</a>
<a name="ln760">  row_ready_ = false;</a>
<a name="ln761">}</a>
<a name="ln762"> </a>
<a name="ln763">HybridTime DocRowwiseIterator::RestartReadHt() {</a>
<a name="ln764">  auto max_seen_ht = db_iter_-&gt;max_seen_ht();</a>
<a name="ln765">  if (max_seen_ht.is_valid() &amp;&amp; max_seen_ht &gt; db_iter_-&gt;read_time().read) {</a>
<a name="ln766">    VLOG(4) &lt;&lt; &quot;Restart read: &quot; &lt;&lt; max_seen_ht &lt;&lt; &quot;, original: &quot; &lt;&lt; db_iter_-&gt;read_time();</a>
<a name="ln767">    return max_seen_ht;</a>
<a name="ln768">  }</a>
<a name="ln769">  return HybridTime::kInvalid;</a>
<a name="ln770">}</a>
<a name="ln771"> </a>
<a name="ln772">bool DocRowwiseIterator::IsNextStaticColumn() const {</a>
<a name="ln773">  return schema_.has_statics() &amp;&amp; row_hash_key_.end() + 1 == row_key_.end();</a>
<a name="ln774">}</a>
<a name="ln775"> </a>
<a name="ln776">Status DocRowwiseIterator::DoNextRow(const Schema&amp; projection, QLTableRow* table_row) {</a>
<a name="ln777">  VLOG(4) &lt;&lt; __PRETTY_FUNCTION__;</a>
<a name="ln778"> </a>
<a name="ln779">  if (PREDICT_FALSE(done_)) {</a>
<a name="ln780">    return STATUS(NotFound, &quot;end of iter&quot;);</a>
<a name="ln781">  }</a>
<a name="ln782"> </a>
<a name="ln783">  // Ensure row is ready to be read. HasNext() must be called before reading the first row, or</a>
<a name="ln784">  // again after the previous row has been read or skipped.</a>
<a name="ln785">  if (!row_ready_) {</a>
<a name="ln786">    return STATUS(InternalError, &quot;next row has not be prepared for reading&quot;);</a>
<a name="ln787">  }</a>
<a name="ln788"> </a>
<a name="ln789">  DocKeyDecoder decoder(row_key_);</a>
<a name="ln790">  RETURN_NOT_OK(decoder.DecodeCotableId());</a>
<a name="ln791">  RETURN_NOT_OK(decoder.DecodePgtableId());</a>
<a name="ln792">  bool has_hash_components = VERIFY_RESULT(decoder.DecodeHashCode());</a>
<a name="ln793"> </a>
<a name="ln794">  // Populate the key column values from the doc key. The key column values in doc key were</a>
<a name="ln795">  // written in the same order as in the table schema (see DocKeyFromQLKey). If the range columns</a>
<a name="ln796">  // are present, read them also.</a>
<a name="ln797">  if (has_hash_components) {</a>
<a name="ln798">    RETURN_NOT_OK(SetQLPrimaryKeyColumnValues(</a>
<a name="ln799">        schema_, 0, schema_.num_hash_key_columns(),</a>
<a name="ln800">        &quot;hash&quot;, &amp;decoder, table_row));</a>
<a name="ln801">  }</a>
<a name="ln802">  if (!decoder.GroupEnded()) {</a>
<a name="ln803">    RETURN_NOT_OK(SetQLPrimaryKeyColumnValues(</a>
<a name="ln804">        schema_, schema_.num_hash_key_columns(), schema_.num_range_key_columns(),</a>
<a name="ln805">        &quot;range&quot;, &amp;decoder, table_row));</a>
<a name="ln806">  }</a>
<a name="ln807"> </a>
<a name="ln808">  for (size_t i = projection.num_key_columns(); i &lt; projection.num_columns(); i++) {</a>
<a name="ln809">    const auto&amp; column_id = projection.column_id(i);</a>
<a name="ln810">    const auto ql_type = projection.column(i).type();</a>
<a name="ln811">    const SubDocument* column_value = row_.GetChild(PrimitiveValue(column_id));</a>
<a name="ln812">    if (column_value != nullptr) {</a>
<a name="ln813">      QLTableColumn&amp; column = table_row-&gt;AllocColumn(column_id);</a>
<a name="ln814">      SubDocument::ToQLValuePB(*column_value, ql_type, &amp;column.value);</a>
<a name="ln815">      column.ttl_seconds = column_value-&gt;GetTtl();</a>
<a name="ln816">      if (column_value-&gt;IsWriteTimeSet()) {</a>
<a name="ln817">        column.write_time = column_value-&gt;GetWriteTime();</a>
<a name="ln818">      }</a>
<a name="ln819">    }</a>
<a name="ln820">  }</a>
<a name="ln821"> </a>
<a name="ln822">  row_ready_ = false;</a>
<a name="ln823">  return Status::OK();</a>
<a name="ln824">}</a>
<a name="ln825"> </a>
<a name="ln826">bool DocRowwiseIterator::LivenessColumnExists() const {</a>
<a name="ln827">  const SubDocument* subdoc = row_.GetChild(</a>
<a name="ln828">      PrimitiveValue::SystemColumnId(SystemColumnIds::kLivenessColumn));</a>
<a name="ln829">  return subdoc != nullptr &amp;&amp; subdoc-&gt;value_type() != ValueType::kInvalid;</a>
<a name="ln830">}</a>
<a name="ln831"> </a>
<a name="ln832">CHECKED_STATUS DocRowwiseIterator::GetNextReadSubDocKey(SubDocKey* sub_doc_key) const {</a>
<a name="ln833">  if (db_iter_ == nullptr) {</a>
<a name="ln834">    return STATUS(Corruption, &quot;Iterator not initialized.&quot;);</a>
<a name="ln835">  }</a>
<a name="ln836"> </a>
<a name="ln837">  // There are no more rows to fetch, so no next SubDocKey to read.</a>
<a name="ln838">  if (!VERIFY_RESULT(HasNext())) {</a>
<a name="ln839">    DVLOG(3) &lt;&lt; &quot;No Next SubDocKey&quot;;</a>
<a name="ln840">    return Status::OK();</a>
<a name="ln841">  }</a>
<a name="ln842"> </a>
<a name="ln843">  DocKey doc_key;</a>
<a name="ln844">  RETURN_NOT_OK(doc_key.FullyDecodeFrom(row_key_));</a>
<a name="ln845">  *sub_doc_key = SubDocKey(doc_key, read_time_.read);</a>
<a name="ln846">  DVLOG(3) &lt;&lt; &quot;Next SubDocKey: &quot; &lt;&lt; sub_doc_key-&gt;ToString();</a>
<a name="ln847">  return Status::OK();</a>
<a name="ln848">}</a>
<a name="ln849"> </a>
<a name="ln850">Result&lt;Slice&gt; DocRowwiseIterator::GetTupleId() const {</a>
<a name="ln851">  // Return tuple id without cotable id / pgtable id if any.</a>
<a name="ln852">  Slice tuple_id = row_key_;</a>
<a name="ln853">  if (tuple_id.starts_with(ValueTypeAsChar::kTableId)) {</a>
<a name="ln854">    tuple_id.remove_prefix(1 + kUuidSize);</a>
<a name="ln855">  } else if (tuple_id.starts_with(ValueTypeAsChar::kPgTableOid)) {</a>
<a name="ln856">    tuple_id.remove_prefix(1 + sizeof(PgTableOid));</a>
<a name="ln857">  }</a>
<a name="ln858">  return tuple_id;</a>
<a name="ln859">}</a>
<a name="ln860"> </a>
<a name="ln861">Result&lt;bool&gt; DocRowwiseIterator::SeekTuple(const Slice&amp; tuple_id) {</a>
<a name="ln862">  // If cotable id / pgtable id is present in the table schema, then</a>
<a name="ln863">  // we need to prepend it in the tuple key to seek.</a>
<a name="ln864">  if (schema_.has_cotable_id() || schema_.has_pgtable_id()) {</a>
<a name="ln865">    uint32_t size = schema_.has_pgtable_id() ? sizeof(PgTableOid) : kUuidSize;</a>
<a name="ln866">    if (!tuple_key_) {</a>
<a name="ln867">      tuple_key_.emplace();</a>
<a name="ln868">      tuple_key_-&gt;Reserve(1 + size + tuple_id.size());</a>
<a name="ln869"> </a>
<a name="ln870">      if (schema_.has_cotable_id()) {</a>
<a name="ln871">        std::string bytes;</a>
<a name="ln872">        schema_.cotable_id().EncodeToComparable(&amp;bytes);</a>
<a name="ln873">        tuple_key_-&gt;AppendValueType(ValueType::kTableId);</a>
<a name="ln874">        tuple_key_-&gt;AppendRawBytes(bytes);</a>
<a name="ln875">      } else {</a>
<a name="ln876">        tuple_key_-&gt;AppendValueType(ValueType::kPgTableOid);</a>
<a name="ln877">        tuple_key_-&gt;AppendUInt32(schema_.pgtable_id());</a>
<a name="ln878">      }</a>
<a name="ln879">    } else {</a>
<a name="ln880">      tuple_key_-&gt;Truncate(1 + size);</a>
<a name="ln881">    }</a>
<a name="ln882">    tuple_key_-&gt;AppendRawBytes(tuple_id);</a>
<a name="ln883">    db_iter_-&gt;Seek(*tuple_key_);</a>
<a name="ln884">  } else {</a>
<a name="ln885">    db_iter_-&gt;Seek(tuple_id);</a>
<a name="ln886">  }</a>
<a name="ln887"> </a>
<a name="ln888">  iter_key_.Clear();</a>
<a name="ln889">  row_ready_ = false;</a>
<a name="ln890"> </a>
<a name="ln891">  return VERIFY_RESULT(HasNext()) &amp;&amp; VERIFY_RESULT(GetTupleId()) == tuple_id;</a>
<a name="ln892">}</a>
<a name="ln893"> </a>
<a name="ln894">}  // namespace docdb</a>
<a name="ln895">}  // namespace yb</a>

</code></pre>
<div class="balloon" rel="48"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="90"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="91"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="95"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="96"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="113"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="114"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="118"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="119"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="208"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="209"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="220"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="221"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="281"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="285"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="290"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="301"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="318"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="343"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="345"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="373"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="381"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="387"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="404"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="408"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="413"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="427"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="431"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="434"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="439"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="494"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="539"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="543"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="574"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="605"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="614"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="642"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="656"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="674"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="713"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v506/" target="_blank">V506</a> Pointer to local variable 'full_row' is stored outside the scope of this variable. Such a pointer will become invalid.</p></div>
<div class="balloon" rel="766"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="777"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="839"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="846"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
