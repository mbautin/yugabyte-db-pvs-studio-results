
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>cluster_itest_util.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Licensed to the Apache Software Foundation (ASF) under one</a>
<a name="ln2">// or more contributor license agreements.  See the NOTICE file</a>
<a name="ln3">// distributed with this work for additional information</a>
<a name="ln4">// regarding copyright ownership.  The ASF licenses this file</a>
<a name="ln5">// to you under the Apache License, Version 2.0 (the</a>
<a name="ln6">// &quot;License&quot;); you may not use this file except in compliance</a>
<a name="ln7">// with the License.  You may obtain a copy of the License at</a>
<a name="ln8">//</a>
<a name="ln9">//   http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln10">//</a>
<a name="ln11">// Unless required by applicable law or agreed to in writing,</a>
<a name="ln12">// software distributed under the License is distributed on an</a>
<a name="ln13">// &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</a>
<a name="ln14">// KIND, either express or implied.  See the License for the</a>
<a name="ln15">// specific language governing permissions and limitations</a>
<a name="ln16">// under the License.</a>
<a name="ln17">//</a>
<a name="ln18">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln19">//</a>
<a name="ln20">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln21">//</a>
<a name="ln22">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln23">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln24">//</a>
<a name="ln25">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln26">//</a>
<a name="ln27">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln28">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln29">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln30">// under the License.</a>
<a name="ln31">//</a>
<a name="ln32">#include &quot;yb/integration-tests/cluster_itest_util.h&quot;</a>
<a name="ln33"> </a>
<a name="ln34">#include &lt;algorithm&gt;</a>
<a name="ln35">#include &lt;limits&gt;</a>
<a name="ln36"> </a>
<a name="ln37">#include &lt;boost/optional.hpp&gt;</a>
<a name="ln38"> </a>
<a name="ln39">#include &lt;glog/stl_logging.h&gt;</a>
<a name="ln40"> </a>
<a name="ln41">#include &lt;gtest/gtest.h&gt;</a>
<a name="ln42"> </a>
<a name="ln43">#include &quot;yb/client/client.h&quot;</a>
<a name="ln44"> </a>
<a name="ln45">#include &quot;yb/common/wire_protocol.h&quot;</a>
<a name="ln46">#include &quot;yb/common/wire_protocol.pb.h&quot;</a>
<a name="ln47">#include &quot;yb/common/wire_protocol-test-util.h&quot;</a>
<a name="ln48"> </a>
<a name="ln49">#include &quot;yb/consensus/consensus_meta.h&quot;</a>
<a name="ln50">#include &quot;yb/consensus/consensus.proxy.h&quot;</a>
<a name="ln51">#include &quot;yb/consensus/opid_util.h&quot;</a>
<a name="ln52">#include &quot;yb/consensus/quorum_util.h&quot;</a>
<a name="ln53"> </a>
<a name="ln54">#include &quot;yb/gutil/map-util.h&quot;</a>
<a name="ln55">#include &quot;yb/gutil/strings/join.h&quot;</a>
<a name="ln56">#include &quot;yb/gutil/strings/substitute.h&quot;</a>
<a name="ln57"> </a>
<a name="ln58">#include &quot;yb/master/master.proxy.h&quot;</a>
<a name="ln59"> </a>
<a name="ln60">#include &quot;yb/rpc/rpc_controller.h&quot;</a>
<a name="ln61"> </a>
<a name="ln62">#include &quot;yb/server/server_base.proxy.h&quot;</a>
<a name="ln63">#include &quot;yb/tserver/tablet_server_test_util.h&quot;</a>
<a name="ln64">#include &quot;yb/tserver/tserver_admin.proxy.h&quot;</a>
<a name="ln65">#include &quot;yb/tserver/tserver_service.pb.h&quot;</a>
<a name="ln66">#include &quot;yb/tserver/tserver_service.proxy.h&quot;</a>
<a name="ln67"> </a>
<a name="ln68">#include &quot;yb/util/net/net_util.h&quot;</a>
<a name="ln69"> </a>
<a name="ln70">namespace yb {</a>
<a name="ln71">namespace itest {</a>
<a name="ln72"> </a>
<a name="ln73">using client::YBClient;</a>
<a name="ln74">using client::YBSchema;</a>
<a name="ln75">using client::YBSchemaBuilder;</a>
<a name="ln76">using client::YBTable;</a>
<a name="ln77">using client::YBTableName;</a>
<a name="ln78">using consensus::CONSENSUS_CONFIG_ACTIVE;</a>
<a name="ln79">using consensus::CONSENSUS_CONFIG_COMMITTED;</a>
<a name="ln80">using consensus::ChangeConfigRequestPB;</a>
<a name="ln81">using consensus::ChangeConfigResponsePB;</a>
<a name="ln82">using consensus::ConsensusConfigType;</a>
<a name="ln83">using consensus::ConsensusStatePB;</a>
<a name="ln84">using consensus::CountVoters;</a>
<a name="ln85">using consensus::GetConsensusStateRequestPB;</a>
<a name="ln86">using consensus::GetConsensusStateResponsePB;</a>
<a name="ln87">using consensus::GetLastOpIdRequestPB;</a>
<a name="ln88">using consensus::GetLastOpIdResponsePB;</a>
<a name="ln89">using consensus::LeaderStepDownRequestPB;</a>
<a name="ln90">using consensus::LeaderStepDownResponsePB;</a>
<a name="ln91">using consensus::RaftPeerPB;</a>
<a name="ln92">using consensus::RunLeaderElectionResponsePB;</a>
<a name="ln93">using consensus::RunLeaderElectionRequestPB;</a>
<a name="ln94">using consensus::kInvalidOpIdIndex;</a>
<a name="ln95">using consensus::LeaderLeaseCheckMode;</a>
<a name="ln96">using consensus::LeaderLeaseStatus;</a>
<a name="ln97">using master::ListTabletServersResponsePB;</a>
<a name="ln98">using master::MasterServiceProxy;</a>
<a name="ln99">using master::TabletLocationsPB;</a>
<a name="ln100">using rpc::Messenger;</a>
<a name="ln101">using rpc::RpcController;</a>
<a name="ln102">using std::min;</a>
<a name="ln103">using std::shared_ptr;</a>
<a name="ln104">using std::string;</a>
<a name="ln105">using std::unordered_map;</a>
<a name="ln106">using std::vector;</a>
<a name="ln107">using strings::Substitute;</a>
<a name="ln108">using tserver::CreateTsClientProxies;</a>
<a name="ln109">using tserver::ListTabletsResponsePB;</a>
<a name="ln110">using tserver::DeleteTabletRequestPB;</a>
<a name="ln111">using tserver::DeleteTabletResponsePB;</a>
<a name="ln112">using tserver::TabletServerAdminServiceProxy;</a>
<a name="ln113">using tserver::TabletServerErrorPB;</a>
<a name="ln114">using tserver::TabletServerServiceProxy;</a>
<a name="ln115">using tserver::WriteRequestPB;</a>
<a name="ln116">using tserver::WriteResponsePB;</a>
<a name="ln117"> </a>
<a name="ln118">const string&amp; TServerDetails::uuid() const {</a>
<a name="ln119">  return instance_id.permanent_uuid();</a>
<a name="ln120">}</a>
<a name="ln121"> </a>
<a name="ln122">std::string TServerDetails::ToString() const {</a>
<a name="ln123">  return Format(&quot;TabletServer: $0, Rpc address: $1&quot;, instance_id.permanent_uuid(),</a>
<a name="ln124">                DesiredHostPort(registration.common(), CloudInfoPB()));</a>
<a name="ln125">}</a>
<a name="ln126"> </a>
<a name="ln127">client::YBSchema SimpleIntKeyYBSchema() {</a>
<a name="ln128">  YBSchema s;</a>
<a name="ln129">  YBSchemaBuilder b;</a>
<a name="ln130">  b.AddColumn(&quot;key&quot;)-&gt;Type(INT32)-&gt;NotNull()-&gt;PrimaryKey();</a>
<a name="ln131">  CHECK_OK(b.Build(&amp;s));</a>
<a name="ln132">  return s;</a>
<a name="ln133">}</a>
<a name="ln134"> </a>
<a name="ln135">Status GetLastOpIdForEachReplica(const string&amp; tablet_id,</a>
<a name="ln136">                                 const vector&lt;TServerDetails*&gt;&amp; replicas,</a>
<a name="ln137">                                 consensus::OpIdType opid_type,</a>
<a name="ln138">                                 const MonoDelta&amp; timeout,</a>
<a name="ln139">                                 vector&lt;OpIdPB&gt;* op_ids) {</a>
<a name="ln140">  GetLastOpIdRequestPB opid_req;</a>
<a name="ln141">  GetLastOpIdResponsePB opid_resp;</a>
<a name="ln142">  opid_req.set_tablet_id(tablet_id);</a>
<a name="ln143">  RpcController controller;</a>
<a name="ln144"> </a>
<a name="ln145">  op_ids-&gt;clear();</a>
<a name="ln146">  for (TServerDetails* ts : replicas) {</a>
<a name="ln147">    controller.Reset();</a>
<a name="ln148">    controller.set_timeout(timeout);</a>
<a name="ln149">    opid_resp.Clear();</a>
<a name="ln150">    opid_req.set_dest_uuid(ts-&gt;uuid());</a>
<a name="ln151">    opid_req.set_tablet_id(tablet_id);</a>
<a name="ln152">    opid_req.set_opid_type(opid_type);</a>
<a name="ln153">    RETURN_NOT_OK_PREPEND(</a>
<a name="ln154">      ts-&gt;consensus_proxy-&gt;GetLastOpId(opid_req, &amp;opid_resp, &amp;controller),</a>
<a name="ln155">      Substitute(&quot;Failed to fetch last op id from $0&quot;,</a>
<a name="ln156">                 ts-&gt;instance_id.ShortDebugString()));</a>
<a name="ln157">    if (!opid_resp.has_opid()) {</a>
<a name="ln158">      LOG(WARNING) &lt;&lt; &quot;Received uninitialized op id from &quot; &lt;&lt; ts-&gt;instance_id.ShortDebugString();</a>
<a name="ln159">    }</a>
<a name="ln160">    op_ids-&gt;push_back(opid_resp.opid());</a>
<a name="ln161">  }</a>
<a name="ln162"> </a>
<a name="ln163">  return Status::OK();</a>
<a name="ln164">}</a>
<a name="ln165"> </a>
<a name="ln166">Status GetLastOpIdForReplica(const std::string&amp; tablet_id,</a>
<a name="ln167">                             TServerDetails* replica,</a>
<a name="ln168">                             consensus::OpIdType opid_type,</a>
<a name="ln169">                             const MonoDelta&amp; timeout,</a>
<a name="ln170">                             OpIdPB* op_id) {</a>
<a name="ln171">  vector&lt;TServerDetails*&gt; replicas;</a>
<a name="ln172">  replicas.push_back(replica);</a>
<a name="ln173">  vector&lt;OpIdPB&gt; op_ids;</a>
<a name="ln174">  RETURN_NOT_OK(GetLastOpIdForEachReplica(tablet_id, replicas, opid_type, timeout, &amp;op_ids));</a>
<a name="ln175">  CHECK_EQ(1, op_ids.size());</a>
<a name="ln176">  *op_id = op_ids[0];</a>
<a name="ln177">  return Status::OK();</a>
<a name="ln178">}</a>
<a name="ln179"> </a>
<a name="ln180">vector&lt;TServerDetails*&gt; TServerDetailsVector(const TabletServerMap&amp; tablet_servers) {</a>
<a name="ln181">  vector&lt;TServerDetails*&gt; result;</a>
<a name="ln182">  result.reserve(tablet_servers.size());</a>
<a name="ln183">  for (auto&amp; pair : tablet_servers) {</a>
<a name="ln184">    result.push_back(pair.second.get());</a>
<a name="ln185">  }</a>
<a name="ln186">  return result;</a>
<a name="ln187">}</a>
<a name="ln188"> </a>
<a name="ln189">vector&lt;TServerDetails*&gt; TServerDetailsVector(const TabletServerMapUnowned&amp; tablet_servers) {</a>
<a name="ln190">  vector&lt;TServerDetails*&gt; result;</a>
<a name="ln191">  result.reserve(tablet_servers.size());</a>
<a name="ln192">  for (auto&amp; pair : tablet_servers) {</a>
<a name="ln193">    result.push_back(pair.second);</a>
<a name="ln194">  }</a>
<a name="ln195">  return result;</a>
<a name="ln196">}</a>
<a name="ln197"> </a>
<a name="ln198">TabletServerMapUnowned CreateTabletServerMapUnowned(const TabletServerMap&amp; tablet_servers) {</a>
<a name="ln199">  TabletServerMapUnowned result;</a>
<a name="ln200">  for (auto&amp; pair : tablet_servers) {</a>
<a name="ln201">    result.emplace(pair.first, pair.second.get());</a>
<a name="ln202">  }</a>
<a name="ln203">  return result;</a>
<a name="ln204">}</a>
<a name="ln205"> </a>
<a name="ln206">Status WaitForServersToAgree(const MonoDelta&amp; timeout,</a>
<a name="ln207">                             const TabletServerMap&amp; tablet_servers,</a>
<a name="ln208">                             const string&amp; tablet_id,</a>
<a name="ln209">                             int64_t minimum_index,</a>
<a name="ln210">                             int64_t* actual_index,</a>
<a name="ln211">                             MustBeCommitted must_be_committed) {</a>
<a name="ln212">  return WaitForServersToAgree(timeout,</a>
<a name="ln213">                               TServerDetailsVector(tablet_servers),</a>
<a name="ln214">                               tablet_id,</a>
<a name="ln215">                               minimum_index,</a>
<a name="ln216">                               actual_index,</a>
<a name="ln217">                               must_be_committed);</a>
<a name="ln218">}</a>
<a name="ln219"> </a>
<a name="ln220">Status WaitForServersToAgree(const MonoDelta&amp; timeout,</a>
<a name="ln221">                             const TabletServerMapUnowned&amp; tablet_servers,</a>
<a name="ln222">                             const TabletId&amp; tablet_id,</a>
<a name="ln223">                             int64_t minimum_index,</a>
<a name="ln224">                             int64_t* actual_index,</a>
<a name="ln225">                             MustBeCommitted must_be_committed) {</a>
<a name="ln226">  return WaitForServersToAgree(</a>
<a name="ln227">      timeout, TServerDetailsVector(tablet_servers), tablet_id, minimum_index, actual_index,</a>
<a name="ln228">      must_be_committed);</a>
<a name="ln229">}</a>
<a name="ln230"> </a>
<a name="ln231">Status WaitForServersToAgree(const MonoDelta&amp; timeout,</a>
<a name="ln232">                             const vector&lt;TServerDetails*&gt;&amp; servers,</a>
<a name="ln233">                             const string&amp; tablet_id,</a>
<a name="ln234">                             int64_t minimum_index,</a>
<a name="ln235">                             int64_t* actual_index,</a>
<a name="ln236">                             MustBeCommitted must_be_committed) {</a>
<a name="ln237">  auto deadline = CoarseMonoClock::Now() + timeout;</a>
<a name="ln238">  if (actual_index != nullptr) {</a>
<a name="ln239">    *actual_index = 0;</a>
<a name="ln240">  }</a>
<a name="ln241"> </a>
<a name="ln242">  vector&lt;OpIdType&gt; opid_types{consensus::OpIdType::RECEIVED_OPID};</a>
<a name="ln243">  if (must_be_committed) {</a>
<a name="ln244">    // In this mode we require that last received and committed op ids from all servers converge</a>
<a name="ln245">    // on the same value.</a>
<a name="ln246">    opid_types.push_back(consensus::OpIdType::COMMITTED_OPID);</a>
<a name="ln247">  }</a>
<a name="ln248"> </a>
<a name="ln249">  Status last_non_ok_status;</a>
<a name="ln250">  vector&lt;OpIdPB&gt; received_ids;</a>
<a name="ln251">  vector&lt;OpIdPB&gt; committed_ids;</a>
<a name="ln252"> </a>
<a name="ln253">  for (int attempt = 1; CoarseMonoClock::Now() &lt; deadline; attempt++) {</a>
<a name="ln254">    vector&lt;OpIdPB&gt; ids;</a>
<a name="ln255"> </a>
<a name="ln256">    Status s;</a>
<a name="ln257">    for (auto opid_type : opid_types) {</a>
<a name="ln258">      vector&lt;OpIdPB&gt; ids_of_this_type;</a>
<a name="ln259">      s = GetLastOpIdForEachReplica(tablet_id, servers, opid_type, timeout, &amp;ids_of_this_type);</a>
<a name="ln260">      if (opid_type == consensus::OpIdType::RECEIVED_OPID) {</a>
<a name="ln261">        received_ids = ids_of_this_type;</a>
<a name="ln262">      } else {</a>
<a name="ln263">        committed_ids = ids_of_this_type;</a>
<a name="ln264">      }</a>
<a name="ln265">      if (s.ok()) {</a>
<a name="ln266">        std::copy(ids_of_this_type.begin(), ids_of_this_type.end(), std::back_inserter(ids));</a>
<a name="ln267">      } else {</a>
<a name="ln268">        break;</a>
<a name="ln269">      }</a>
<a name="ln270">    }</a>
<a name="ln271"> </a>
<a name="ln272">    if (s.ok()) {</a>
<a name="ln273">      int64_t cur_index = kInvalidOpIdIndex;</a>
<a name="ln274">      bool any_behind = false;</a>
<a name="ln275">      bool any_disagree = false;</a>
<a name="ln276">      for (const OpIdPB&amp; id : ids) {</a>
<a name="ln277">        if (cur_index == kInvalidOpIdIndex) {</a>
<a name="ln278">          cur_index = id.index();</a>
<a name="ln279">        }</a>
<a name="ln280">        if (id.index() != cur_index) {</a>
<a name="ln281">          any_disagree = true;</a>
<a name="ln282">          break;</a>
<a name="ln283">        }</a>
<a name="ln284">        if (id.index() &lt; minimum_index) {</a>
<a name="ln285">          any_behind = true;</a>
<a name="ln286">          break;</a>
<a name="ln287">        }</a>
<a name="ln288">      }</a>
<a name="ln289">      if (!any_behind &amp;&amp; !any_disagree) {</a>
<a name="ln290">        LOG(INFO) &lt;&lt; &quot;All servers converged on OpIds: &quot; &lt;&lt; ids;</a>
<a name="ln291">        if (actual_index != nullptr) {</a>
<a name="ln292">          *actual_index = cur_index;</a>
<a name="ln293">        }</a>
<a name="ln294">        return Status::OK();</a>
<a name="ln295">      }</a>
<a name="ln296">    } else {</a>
<a name="ln297">      LOG(WARNING) &lt;&lt; &quot;Got error getting last opid for each replica: &quot; &lt;&lt; s.ToString();</a>
<a name="ln298">      last_non_ok_status = s;</a>
<a name="ln299">    }</a>
<a name="ln300"> </a>
<a name="ln301">    LOG(INFO) &lt;&lt; &quot;Not converged past &quot; &lt;&lt; minimum_index &lt;&lt; &quot; yet: &quot; &lt;&lt; ids;</a>
<a name="ln302">    SleepFor(MonoDelta::FromMilliseconds(min(attempt * 100, 1000)));</a>
<a name="ln303">  }</a>
<a name="ln304">  return STATUS_FORMAT(</a>
<a name="ln305">      TimedOut,</a>
<a name="ln306">      &quot;All replicas of tablet $0 could not converge on an index of at least $1 after $2. &quot;</a>
<a name="ln307">      &quot;must_be_committed=$3. Latest received ids: $3, committed ids: $4&quot;,</a>
<a name="ln308">      tablet_id, minimum_index, timeout, must_be_committed, received_ids, committed_ids);</a>
<a name="ln309">}</a>
<a name="ln310"> </a>
<a name="ln311">// Wait until all specified replicas have logged the given index.</a>
<a name="ln312">Status WaitUntilAllReplicasHaveOp(const int64_t log_index,</a>
<a name="ln313">                                  const string&amp; tablet_id,</a>
<a name="ln314">                                  const vector&lt;TServerDetails*&gt;&amp; replicas,</a>
<a name="ln315">                                  const MonoDelta&amp; timeout,</a>
<a name="ln316">                                  int64_t* actual_minimum_index) {</a>
<a name="ln317">  MonoTime start = MonoTime::Now();</a>
<a name="ln318">  MonoDelta passed = MonoDelta::FromMilliseconds(0);</a>
<a name="ln319">  while (true) {</a>
<a name="ln320">    vector&lt;OpIdPB&gt; op_ids;</a>
<a name="ln321">    Status s = GetLastOpIdForEachReplica(tablet_id, replicas, consensus::RECEIVED_OPID, timeout,</a>
<a name="ln322">                                         &amp;op_ids);</a>
<a name="ln323">    if (s.ok()) {</a>
<a name="ln324">      if (actual_minimum_index != nullptr) {</a>
<a name="ln325">        *actual_minimum_index = std::numeric_limits&lt;int64_t&gt;::max();</a>
<a name="ln326">      }</a>
<a name="ln327"> </a>
<a name="ln328">      bool any_behind = false;</a>
<a name="ln329">      for (const OpIdPB&amp; op_id : op_ids) {</a>
<a name="ln330">        if (actual_minimum_index != nullptr) {</a>
<a name="ln331">          *actual_minimum_index = std::min(*actual_minimum_index, op_id.index());</a>
<a name="ln332">        }</a>
<a name="ln333"> </a>
<a name="ln334">        if (op_id.index() &lt; log_index) {</a>
<a name="ln335">          any_behind = true;</a>
<a name="ln336">          break;</a>
<a name="ln337">        }</a>
<a name="ln338">      }</a>
<a name="ln339">      if (!any_behind) return Status::OK();</a>
<a name="ln340">    } else {</a>
<a name="ln341">      LOG(WARNING) &lt;&lt; &quot;Got error getting last opid for each replica: &quot; &lt;&lt; s.ToString();</a>
<a name="ln342">    }</a>
<a name="ln343">    passed = MonoTime::Now().GetDeltaSince(start);</a>
<a name="ln344">    if (passed.MoreThan(timeout)) {</a>
<a name="ln345">      break;</a>
<a name="ln346">    }</a>
<a name="ln347">    SleepFor(MonoDelta::FromMilliseconds(50));</a>
<a name="ln348">  }</a>
<a name="ln349">  string replicas_str;</a>
<a name="ln350">  for (const TServerDetails* replica : replicas) {</a>
<a name="ln351">    if (!replicas_str.empty()) replicas_str += &quot;, &quot;;</a>
<a name="ln352">    replicas_str += &quot;{ &quot; + replica-&gt;ToString() + &quot; }&quot;;</a>
<a name="ln353">  }</a>
<a name="ln354">  return STATUS(TimedOut, Substitute(&quot;Index $0 not available on all replicas after $1. &quot;</a>
<a name="ln355">                                              &quot;Replicas: [ $2 ]&quot;,</a>
<a name="ln356">                                              log_index, passed.ToString()));</a>
<a name="ln357">}</a>
<a name="ln358"> </a>
<a name="ln359">Status WaitUntilNumberOfAliveTServersEqual(int n_tservers,</a>
<a name="ln360">                                           MasterServiceProxy* master_proxy,</a>
<a name="ln361">                                           const MonoDelta&amp; timeout) {</a>
<a name="ln362"> </a>
<a name="ln363">  master::ListTabletServersRequestPB req;</a>
<a name="ln364">  master::ListTabletServersResponsePB resp;</a>
<a name="ln365">  rpc::RpcController controller;</a>
<a name="ln366">  controller.set_timeout(timeout);</a>
<a name="ln367"> </a>
<a name="ln368">  // The field primary_only means only tservers that are alive (tservers that have sent at least on</a>
<a name="ln369">  // heartbeat in the last FLAG_tserver_unresponsive_timeout_ms milliseconds.)</a>
<a name="ln370">  req.set_primary_only(true);</a>
<a name="ln371"> </a>
<a name="ln372">  MonoTime start = MonoTime::Now();</a>
<a name="ln373">  MonoDelta passed = MonoDelta::FromMilliseconds(0);</a>
<a name="ln374">  while (true) {</a>
<a name="ln375">    Status s = master_proxy-&gt;ListTabletServers(req, &amp;resp, &amp;controller);</a>
<a name="ln376"> </a>
<a name="ln377">    if (s.ok() &amp;&amp;</a>
<a name="ln378">        controller.status().ok() &amp;&amp;</a>
<a name="ln379">        !resp.has_error()) {</a>
<a name="ln380">      if (resp.servers_size() == n_tservers) {</a>
<a name="ln381">        passed = MonoTime::Now().GetDeltaSince(start);</a>
<a name="ln382">        return Status::OK();</a>
<a name="ln383">      }</a>
<a name="ln384">    } else {</a>
<a name="ln385">      string error;</a>
<a name="ln386">      if (!s.ok()) {</a>
<a name="ln387">        error = s.ToString();</a>
<a name="ln388">      } else if (!controller.status().ok()) {</a>
<a name="ln389">        error = controller.status().ToString();</a>
<a name="ln390">      } else {</a>
<a name="ln391">        error = resp.error().ShortDebugString();</a>
<a name="ln392">      }</a>
<a name="ln393">      LOG(WARNING) &lt;&lt; &quot;Got error getting list of tablet servers: &quot; &lt;&lt; error;</a>
<a name="ln394">    }</a>
<a name="ln395">    passed = MonoTime::Now().GetDeltaSince(start);</a>
<a name="ln396">    if (passed.MoreThan(timeout)) {</a>
<a name="ln397">      break;</a>
<a name="ln398">    }</a>
<a name="ln399">    SleepFor(MonoDelta::FromMilliseconds(50));</a>
<a name="ln400">    controller.Reset();</a>
<a name="ln401">  }</a>
<a name="ln402">  return STATUS(TimedOut, Substitute(&quot;Number of alive tservers not equal to $0 after $1 ms. &quot;,</a>
<a name="ln403">                                     n_tservers, timeout.ToMilliseconds()));</a>
<a name="ln404">}</a>
<a name="ln405"> </a>
<a name="ln406">Status CreateTabletServerMap(MasterServiceProxy* master_proxy,</a>
<a name="ln407">                             rpc::ProxyCache* proxy_cache,</a>
<a name="ln408">                             TabletServerMap* ts_map) {</a>
<a name="ln409">  master::ListTabletServersRequestPB req;</a>
<a name="ln410">  master::ListTabletServersResponsePB resp;</a>
<a name="ln411">  rpc::RpcController controller;</a>
<a name="ln412"> </a>
<a name="ln413">  RETURN_NOT_OK(master_proxy-&gt;ListTabletServers(req, &amp;resp, &amp;controller));</a>
<a name="ln414">  RETURN_NOT_OK(controller.status());</a>
<a name="ln415">  if (resp.has_error()) {</a>
<a name="ln416">    return STATUS(RemoteError, &quot;Response had an error&quot;, resp.error().ShortDebugString());</a>
<a name="ln417">  }</a>
<a name="ln418"> </a>
<a name="ln419">  ts_map-&gt;clear();</a>
<a name="ln420">  for (const ListTabletServersResponsePB::Entry&amp; entry : resp.servers()) {</a>
<a name="ln421">    HostPort host_port = HostPortFromPB(DesiredHostPort(</a>
<a name="ln422">        entry.registration().common(), CloudInfoPB()));</a>
<a name="ln423"> </a>
<a name="ln424">    std::unique_ptr&lt;TServerDetails&gt; peer(new TServerDetails());</a>
<a name="ln425">    peer-&gt;instance_id.CopyFrom(entry.instance_id());</a>
<a name="ln426">    peer-&gt;registration.CopyFrom(entry.registration());</a>
<a name="ln427"> </a>
<a name="ln428">    CreateTsClientProxies(host_port,</a>
<a name="ln429">                          proxy_cache,</a>
<a name="ln430">                          &amp;peer-&gt;tserver_proxy,</a>
<a name="ln431">                          &amp;peer-&gt;tserver_admin_proxy,</a>
<a name="ln432">                          &amp;peer-&gt;consensus_proxy,</a>
<a name="ln433">                          &amp;peer-&gt;generic_proxy);</a>
<a name="ln434"> </a>
<a name="ln435">    const auto&amp; key = peer-&gt;instance_id.permanent_uuid();</a>
<a name="ln436">    CHECK(ts_map-&gt;emplace(key, std::move(peer)).second) &lt;&lt; &quot;duplicate key: &quot; &lt;&lt; key;</a>
<a name="ln437">  }</a>
<a name="ln438">  return Status::OK();</a>
<a name="ln439">}</a>
<a name="ln440"> </a>
<a name="ln441">Status GetConsensusState(const TServerDetails* replica,</a>
<a name="ln442">                         const string&amp; tablet_id,</a>
<a name="ln443">                         consensus::ConsensusConfigType type,</a>
<a name="ln444">                         const MonoDelta&amp; timeout,</a>
<a name="ln445">                         ConsensusStatePB* consensus_state,</a>
<a name="ln446">                         LeaderLeaseStatus* leader_lease_status) {</a>
<a name="ln447">  DCHECK_ONLY_NOTNULL(replica);</a>
<a name="ln448"> </a>
<a name="ln449">  GetConsensusStateRequestPB req;</a>
<a name="ln450">  GetConsensusStateResponsePB resp;</a>
<a name="ln451">  RpcController controller;</a>
<a name="ln452">  controller.set_timeout(timeout);</a>
<a name="ln453">  req.set_dest_uuid(replica-&gt;uuid());</a>
<a name="ln454">  req.set_tablet_id(tablet_id);</a>
<a name="ln455">  req.set_type(type);</a>
<a name="ln456"> </a>
<a name="ln457">  RETURN_NOT_OK(replica-&gt;consensus_proxy-&gt;GetConsensusState(req, &amp;resp, &amp;controller));</a>
<a name="ln458">  if (resp.has_error()) {</a>
<a name="ln459">    return StatusFromPB(resp.error().status());</a>
<a name="ln460">  }</a>
<a name="ln461">  *consensus_state = resp.cstate();</a>
<a name="ln462">  if (leader_lease_status) {</a>
<a name="ln463">    *leader_lease_status = resp.has_leader_lease_status() ?</a>
<a name="ln464">        resp.leader_lease_status() :</a>
<a name="ln465">        LeaderLeaseStatus::NO_MAJORITY_REPLICATED_LEASE;  // Could be anything but HAS_LEASE.</a>
<a name="ln466">  }</a>
<a name="ln467">  return Status::OK();</a>
<a name="ln468">}</a>
<a name="ln469"> </a>
<a name="ln470">Status WaitUntilCommittedConfigNumVotersIs(int config_size,</a>
<a name="ln471">                                           const TServerDetails* replica,</a>
<a name="ln472">                                           const std::string&amp; tablet_id,</a>
<a name="ln473">                                           const MonoDelta&amp; timeout) {</a>
<a name="ln474">  return WaitUntilCommittedConfigMemberTypeIs(config_size, replica, tablet_id, timeout,</a>
<a name="ln475">                                              RaftPeerPB::VOTER);</a>
<a name="ln476">}</a>
<a name="ln477"> </a>
<a name="ln478">Status WaitUntilCommittedConfigMemberTypeIs(int config_size,</a>
<a name="ln479">                                           const TServerDetails* replica,</a>
<a name="ln480">                                           const std::string&amp; tablet_id,</a>
<a name="ln481">                                           const MonoDelta&amp; timeout,</a>
<a name="ln482">                                           RaftPeerPB::MemberType member_type) {</a>
<a name="ln483">  DCHECK_ONLY_NOTNULL(replica);</a>
<a name="ln484"> </a>
<a name="ln485">  MonoTime start = MonoTime::Now();</a>
<a name="ln486">  MonoTime deadline = start + timeout;</a>
<a name="ln487"> </a>
<a name="ln488">  int backoff_exp = 0;</a>
<a name="ln489">  const int kMaxBackoffExp = 7;</a>
<a name="ln490">  Status s;</a>
<a name="ln491">  ConsensusStatePB cstate;</a>
<a name="ln492">  while (true) {</a>
<a name="ln493">    MonoDelta remaining_timeout = deadline.GetDeltaSince(MonoTime::Now());</a>
<a name="ln494">    s = GetConsensusState(replica, tablet_id, CONSENSUS_CONFIG_COMMITTED,</a>
<a name="ln495">                          remaining_timeout, &amp;cstate);</a>
<a name="ln496">    if (s.ok()) {</a>
<a name="ln497">      if (CountMemberType(cstate.config(), member_type) == config_size) {</a>
<a name="ln498">        return Status::OK();</a>
<a name="ln499">      }</a>
<a name="ln500">    }</a>
<a name="ln501"> </a>
<a name="ln502">    if (MonoTime::Now().GetDeltaSince(start).MoreThan(timeout)) {</a>
<a name="ln503">      break;</a>
<a name="ln504">    }</a>
<a name="ln505">    SleepFor(MonoDelta::FromMilliseconds(1 &lt;&lt; backoff_exp));</a>
<a name="ln506">    backoff_exp = min(backoff_exp + 1, kMaxBackoffExp);</a>
<a name="ln507">  }</a>
<a name="ln508">  return STATUS(TimedOut, Substitute(&quot;Number of replicas of type $0 does not equal $1 after &quot;</a>
<a name="ln509">                                     &quot;waiting for $2. Last consensus state: $3. Last status: $4&quot;,</a>
<a name="ln510">                                     RaftPeerPB::MemberType_Name(member_type), config_size,</a>
<a name="ln511">                                     timeout.ToString(), cstate.ShortDebugString(), s.ToString()));</a>
<a name="ln512">}</a>
<a name="ln513"> </a>
<a name="ln514">template&lt;class Context&gt;</a>
<a name="ln515">Status WaitUntilCommittedOpIdIndex(TServerDetails* replica,</a>
<a name="ln516">                                   const string&amp; tablet_id,</a>
<a name="ln517">                                   const MonoDelta&amp; timeout,</a>
<a name="ln518">                                   CommittedEntryType type,</a>
<a name="ln519">                                   Context context) {</a>
<a name="ln520">  MonoTime start = MonoTime::Now();</a>
<a name="ln521">  MonoTime deadline = start;</a>
<a name="ln522">  deadline.AddDelta(timeout);</a>
<a name="ln523"> </a>
<a name="ln524">  bool config = type == CommittedEntryType::CONFIG;</a>
<a name="ln525">  Status s;</a>
<a name="ln526">  OpIdPB op_id;</a>
<a name="ln527">  ConsensusStatePB cstate;</a>
<a name="ln528">  while (true) {</a>
<a name="ln529">    MonoDelta remaining_timeout = deadline.GetDeltaSince(MonoTime::Now());</a>
<a name="ln530"> </a>
<a name="ln531">    int64_t op_index = -1;</a>
<a name="ln532">    if (config) {</a>
<a name="ln533">      s = GetConsensusState(replica, tablet_id, CONSENSUS_CONFIG_COMMITTED,</a>
<a name="ln534">          remaining_timeout, &amp;cstate);</a>
<a name="ln535">      if (s.ok()) {</a>
<a name="ln536">        op_index = cstate.config().opid_index();</a>
<a name="ln537">      }</a>
<a name="ln538">    } else {</a>
<a name="ln539">      s = GetLastOpIdForReplica(tablet_id, replica, consensus::COMMITTED_OPID, remaining_timeout,</a>
<a name="ln540">          &amp;op_id);</a>
<a name="ln541">      if (s.ok()) {</a>
<a name="ln542">        op_index = op_id.index();</a>
<a name="ln543">      }</a>
<a name="ln544">    }</a>
<a name="ln545"> </a>
<a name="ln546">    if (s.ok() &amp;&amp; context.Check(op_index)) {</a>
<a name="ln547">      if (config) {</a>
<a name="ln548">        LOG(INFO) &lt;&lt; &quot;Committed config state is: &quot; &lt;&lt; cstate.ShortDebugString() &lt;&lt; &quot; for replica: &quot;</a>
<a name="ln549">                  &lt;&lt; replica-&gt;instance_id.permanent_uuid();</a>
<a name="ln550">      } else {</a>
<a name="ln551">        LOG(INFO) &lt;&lt; &quot;Committed op_id index is: &quot; &lt;&lt; op_id &lt;&lt; &quot; for replica: &quot;</a>
<a name="ln552">                  &lt;&lt; replica-&gt;instance_id.permanent_uuid();</a>
<a name="ln553">      }</a>
<a name="ln554">      return Status::OK();</a>
<a name="ln555">    }</a>
<a name="ln556">    auto passed = MonoTime::Now().GetDeltaSince(start);</a>
<a name="ln557">    if (passed.MoreThan(timeout)) {</a>
<a name="ln558">      auto name = config ? &quot;config&quot; : &quot;consensus&quot;;</a>
<a name="ln559">      auto last_value = config ? cstate.ShortDebugString() : consensus::OpIdToString(op_id);</a>
<a name="ln560">      return STATUS(TimedOut,</a>
<a name="ln561">                    Substitute(&quot;Committed $0 opid_index does not equal $1 &quot;</a>
<a name="ln562">                               &quot;after waiting for $2. Last value: $3, Last status: $4&quot;,</a>
<a name="ln563">                               name,</a>
<a name="ln564">                               context.Desired(),</a>
<a name="ln565">                               passed.ToString(),</a>
<a name="ln566">                               last_value,</a>
<a name="ln567">                               s.ToString()));</a>
<a name="ln568">    }</a>
<a name="ln569">    if (!config) {</a>
<a name="ln570">      LOG(INFO) &lt;&lt; &quot;Committed index is at: &quot; &lt;&lt; op_id.index() &lt;&lt; &quot; and not yet at &quot;</a>
<a name="ln571">                &lt;&lt; context.Desired();</a>
<a name="ln572">    }</a>
<a name="ln573">    SleepFor(MonoDelta::FromMilliseconds(100));</a>
<a name="ln574">  }</a>
<a name="ln575">}</a>
<a name="ln576"> </a>
<a name="ln577">class WaitUntilCommittedOpIdIndexContext {</a>
<a name="ln578"> public:</a>
<a name="ln579">  explicit WaitUntilCommittedOpIdIndexContext(std::string desired)</a>
<a name="ln580">      : desired_(std::move(desired)) {</a>
<a name="ln581">  }</a>
<a name="ln582"> </a>
<a name="ln583">  const string&amp; Desired() const {</a>
<a name="ln584">    return desired_;</a>
<a name="ln585">  }</a>
<a name="ln586"> private:</a>
<a name="ln587">  string desired_;</a>
<a name="ln588">};</a>
<a name="ln589"> </a>
<a name="ln590">class WaitUntilCommittedOpIdIndexIsContext : public WaitUntilCommittedOpIdIndexContext {</a>
<a name="ln591"> public:</a>
<a name="ln592">  explicit WaitUntilCommittedOpIdIndexIsContext(int64_t value)</a>
<a name="ln593">      : WaitUntilCommittedOpIdIndexContext(Substitute(&quot;equal $0&quot;, value)),</a>
<a name="ln594">        value_(value) {</a>
<a name="ln595">  }</a>
<a name="ln596"> </a>
<a name="ln597">  bool Check(int64_t current) {</a>
<a name="ln598">    return value_ == current;</a>
<a name="ln599">  }</a>
<a name="ln600"> private:</a>
<a name="ln601">  int64_t value_;</a>
<a name="ln602">};</a>
<a name="ln603"> </a>
<a name="ln604">Status WaitUntilCommittedOpIdIndexIs(int64_t opid_index,</a>
<a name="ln605">                                     TServerDetails* replica,</a>
<a name="ln606">                                     const string&amp; tablet_id,</a>
<a name="ln607">                                     const MonoDelta&amp; timeout,</a>
<a name="ln608">                                     CommittedEntryType type) {</a>
<a name="ln609">  return WaitUntilCommittedOpIdIndex(</a>
<a name="ln610">      replica,</a>
<a name="ln611">      tablet_id,</a>
<a name="ln612">      timeout,</a>
<a name="ln613">      type,</a>
<a name="ln614">      WaitUntilCommittedOpIdIndexIsContext(opid_index));</a>
<a name="ln615">}</a>
<a name="ln616"> </a>
<a name="ln617">class WaitUntilCommittedOpIdIndexIsGreaterThanContext : public WaitUntilCommittedOpIdIndexContext {</a>
<a name="ln618"> public:</a>
<a name="ln619">  explicit WaitUntilCommittedOpIdIndexIsGreaterThanContext(int64_t* value)</a>
<a name="ln620">      : WaitUntilCommittedOpIdIndexContext(Substitute(&quot;greater than $0&quot;, *value)),</a>
<a name="ln621">        original_value_(*value), value_(value) {</a>
<a name="ln622"> </a>
<a name="ln623">  }</a>
<a name="ln624"> </a>
<a name="ln625">  bool Check(int64_t current) {</a>
<a name="ln626">    if (current &gt; *value_) {</a>
<a name="ln627">      CHECK_EQ(*value_, original_value_);</a>
<a name="ln628">      *value_ = current;</a>
<a name="ln629">      return true;</a>
<a name="ln630">    }</a>
<a name="ln631">    return false;</a>
<a name="ln632">  }</a>
<a name="ln633"> private:</a>
<a name="ln634">  int64_t original_value_;</a>
<a name="ln635">  int64_t* const value_;</a>
<a name="ln636">};</a>
<a name="ln637"> </a>
<a name="ln638">Status WaitUntilCommittedOpIdIndexIsGreaterThan(int64_t* index,</a>
<a name="ln639">                                                TServerDetails* replica,</a>
<a name="ln640">                                                const TabletId&amp; tablet_id,</a>
<a name="ln641">                                                const MonoDelta&amp; timeout,</a>
<a name="ln642">                                                CommittedEntryType type) {</a>
<a name="ln643">  return WaitUntilCommittedOpIdIndex(</a>
<a name="ln644">      replica,</a>
<a name="ln645">      tablet_id,</a>
<a name="ln646">      timeout,</a>
<a name="ln647">      type,</a>
<a name="ln648">      WaitUntilCommittedOpIdIndexIsGreaterThanContext(index));</a>
<a name="ln649">}</a>
<a name="ln650"> </a>
<a name="ln651">Status WaitUntilCommittedOpIdIndexIsAtLeast(int64_t* index,</a>
<a name="ln652">                                            TServerDetails* replica,</a>
<a name="ln653">                                            const TabletId&amp; tablet_id,</a>
<a name="ln654">                                            const MonoDelta&amp; timeout,</a>
<a name="ln655">                                            CommittedEntryType type) {</a>
<a name="ln656">  int64_t tmp_index = *index - 1;</a>
<a name="ln657">  Status s = WaitUntilCommittedOpIdIndexIsGreaterThan(</a>
<a name="ln658">      &amp;tmp_index,</a>
<a name="ln659">      replica,</a>
<a name="ln660">      tablet_id,</a>
<a name="ln661">      timeout,</a>
<a name="ln662">      type);</a>
<a name="ln663">  *index = tmp_index;</a>
<a name="ln664">  return s;</a>
<a name="ln665">}</a>
<a name="ln666"> </a>
<a name="ln667">Status GetReplicaStatusAndCheckIfLeader(const TServerDetails* replica,</a>
<a name="ln668">                                        const string&amp; tablet_id,</a>
<a name="ln669">                                        const MonoDelta&amp; timeout,</a>
<a name="ln670">                                        LeaderLeaseCheckMode lease_check_mode) {</a>
<a name="ln671">  ConsensusStatePB cstate;</a>
<a name="ln672">  LeaderLeaseStatus leader_lease_status;</a>
<a name="ln673">  Status s = GetConsensusState(replica, tablet_id, CONSENSUS_CONFIG_ACTIVE,</a>
<a name="ln674">                               timeout, &amp;cstate, &amp;leader_lease_status);</a>
<a name="ln675">  if (PREDICT_FALSE(!s.ok())) {</a>
<a name="ln676">    VLOG(1) &lt;&lt; &quot;Error getting consensus state from replica: &quot;</a>
<a name="ln677">            &lt;&lt; replica-&gt;instance_id.permanent_uuid();</a>
<a name="ln678">    return STATUS(NotFound, &quot;Error connecting to replica&quot;, s.ToString());</a>
<a name="ln679">  }</a>
<a name="ln680">  const string&amp; replica_uuid = replica-&gt;instance_id.permanent_uuid();</a>
<a name="ln681">  if (cstate.has_leader_uuid() &amp;&amp; cstate.leader_uuid() == replica_uuid &amp;&amp;</a>
<a name="ln682">      (lease_check_mode == LeaderLeaseCheckMode::DONT_NEED_LEASE ||</a>
<a name="ln683">       leader_lease_status == consensus::LeaderLeaseStatus::HAS_LEASE)) {</a>
<a name="ln684">    return Status::OK();</a>
<a name="ln685">  }</a>
<a name="ln686">  VLOG(1) &lt;&lt; &quot;Replica not leader of config: &quot; &lt;&lt; replica-&gt;instance_id.permanent_uuid();</a>
<a name="ln687">  return STATUS_FORMAT(IllegalState,</a>
<a name="ln688">      &quot;Replica found but not leader; lease check mode: $0&quot;, lease_check_mode);</a>
<a name="ln689">}</a>
<a name="ln690"> </a>
<a name="ln691">Status WaitUntilLeader(const TServerDetails* replica,</a>
<a name="ln692">                       const string&amp; tablet_id,</a>
<a name="ln693">                       const MonoDelta&amp; timeout,</a>
<a name="ln694">                       const LeaderLeaseCheckMode lease_check_mode) {</a>
<a name="ln695">  MonoTime start = MonoTime::Now();</a>
<a name="ln696">  MonoTime deadline = start;</a>
<a name="ln697">  deadline.AddDelta(timeout);</a>
<a name="ln698"> </a>
<a name="ln699">  int backoff_exp = 0;</a>
<a name="ln700">  const int kMaxBackoffExp = 7;</a>
<a name="ln701">  Status s;</a>
<a name="ln702">  while (true) {</a>
<a name="ln703">    MonoDelta remaining_timeout = deadline.GetDeltaSince(MonoTime::Now());</a>
<a name="ln704">    s = GetReplicaStatusAndCheckIfLeader(replica, tablet_id, remaining_timeout,</a>
<a name="ln705">                                         lease_check_mode);</a>
<a name="ln706">    if (s.ok()) {</a>
<a name="ln707">      return Status::OK();</a>
<a name="ln708">    }</a>
<a name="ln709"> </a>
<a name="ln710">    if (MonoTime::Now().GetDeltaSince(start).MoreThan(timeout)) {</a>
<a name="ln711">      break;</a>
<a name="ln712">    }</a>
<a name="ln713">    SleepFor(MonoDelta::FromMilliseconds(1 &lt;&lt; backoff_exp));</a>
<a name="ln714">    backoff_exp = min(backoff_exp + 1, kMaxBackoffExp);</a>
<a name="ln715">  }</a>
<a name="ln716">  return STATUS(TimedOut, Substitute(&quot;Replica $0 is not leader after waiting for $1: $2&quot;,</a>
<a name="ln717">                                     replica-&gt;ToString(), timeout.ToString(), s.ToString()));</a>
<a name="ln718">}</a>
<a name="ln719"> </a>
<a name="ln720">Status FindTabletLeader(const TabletServerMap&amp; tablet_servers,</a>
<a name="ln721">                        const string&amp; tablet_id,</a>
<a name="ln722">                        const MonoDelta&amp; timeout,</a>
<a name="ln723">                        TServerDetails** leader) {</a>
<a name="ln724">  return FindTabletLeader(TServerDetailsVector(tablet_servers), tablet_id, timeout, leader);</a>
<a name="ln725">}</a>
<a name="ln726"> </a>
<a name="ln727">Status FindTabletLeader(const TabletServerMapUnowned&amp; tablet_servers,</a>
<a name="ln728">                        const string&amp; tablet_id,</a>
<a name="ln729">                        const MonoDelta&amp; timeout,</a>
<a name="ln730">                        TServerDetails** leader) {</a>
<a name="ln731">  return FindTabletLeader(TServerDetailsVector(tablet_servers), tablet_id, timeout, leader);</a>
<a name="ln732">}</a>
<a name="ln733"> </a>
<a name="ln734">Status FindTabletLeader(const vector&lt;TServerDetails*&gt;&amp; tservers,</a>
<a name="ln735">                        const string&amp; tablet_id,</a>
<a name="ln736">                        const MonoDelta&amp; timeout,</a>
<a name="ln737">                        TServerDetails** leader) {</a>
<a name="ln738">  MonoTime start = MonoTime::Now();</a>
<a name="ln739">  MonoTime deadline = start;</a>
<a name="ln740">  deadline.AddDelta(timeout);</a>
<a name="ln741">  Status s;</a>
<a name="ln742">  int i = 0;</a>
<a name="ln743">  while (true) {</a>
<a name="ln744">    MonoDelta remaining_timeout = deadline.GetDeltaSince(MonoTime::Now());</a>
<a name="ln745">    s = GetReplicaStatusAndCheckIfLeader(tservers[i], tablet_id, remaining_timeout);</a>
<a name="ln746">    if (s.ok()) {</a>
<a name="ln747">      *leader = tservers[i];</a>
<a name="ln748">      return Status::OK();</a>
<a name="ln749">    }</a>
<a name="ln750"> </a>
<a name="ln751">    if (deadline.ComesBefore(MonoTime::Now())) break;</a>
<a name="ln752">    i = (i + 1) % tservers.size();</a>
<a name="ln753">    if (i == 0) {</a>
<a name="ln754">      SleepFor(MonoDelta::FromMilliseconds(10));</a>
<a name="ln755">    }</a>
<a name="ln756">  }</a>
<a name="ln757">  return STATUS(TimedOut, Substitute(&quot;Unable to find leader of tablet $0 after $1. &quot;</a>
<a name="ln758">                                     &quot;Status message: $2&quot;, tablet_id,</a>
<a name="ln759">                                     MonoTime::Now().GetDeltaSince(start).ToString(),</a>
<a name="ln760">                                     s.ToString()));</a>
<a name="ln761">}</a>
<a name="ln762"> </a>
<a name="ln763">Status StartElection(const TServerDetails* replica,</a>
<a name="ln764">                     const string&amp; tablet_id,</a>
<a name="ln765">                     const MonoDelta&amp; timeout,</a>
<a name="ln766">                     consensus::TEST_SuppressVoteRequest suppress_vote_request) {</a>
<a name="ln767">  RunLeaderElectionRequestPB req;</a>
<a name="ln768">  req.set_dest_uuid(replica-&gt;uuid());</a>
<a name="ln769">  req.set_tablet_id(tablet_id);</a>
<a name="ln770">  req.set_suppress_vote_request(suppress_vote_request);</a>
<a name="ln771">  RunLeaderElectionResponsePB resp;</a>
<a name="ln772">  RpcController rpc;</a>
<a name="ln773">  rpc.set_timeout(timeout);</a>
<a name="ln774">  RETURN_NOT_OK(replica-&gt;consensus_proxy-&gt;RunLeaderElection(req, &amp;resp, &amp;rpc));</a>
<a name="ln775">  if (resp.has_error()) {</a>
<a name="ln776">    return StatusFromPB(resp.error().status())</a>
<a name="ln777">      .CloneAndPrepend(Substitute(&quot;Code $0&quot;, TabletServerErrorPB::Code_Name(resp.error().code())));</a>
<a name="ln778">  }</a>
<a name="ln779">  return Status::OK();</a>
<a name="ln780">}</a>
<a name="ln781"> </a>
<a name="ln782">Status RequestVote(const TServerDetails* replica,</a>
<a name="ln783">                   const std::string&amp; tablet_id,</a>
<a name="ln784">                   const std::string&amp; candidate_uuid,</a>
<a name="ln785">                   int64_t candidate_term,</a>
<a name="ln786">                   const OpIdPB&amp; last_logged_opid,</a>
<a name="ln787">                   boost::optional&lt;bool&gt; ignore_live_leader,</a>
<a name="ln788">                   boost::optional&lt;bool&gt; is_pre_election,</a>
<a name="ln789">                   const MonoDelta&amp; timeout) {</a>
<a name="ln790">  DSCHECK(last_logged_opid.IsInitialized(), Uninitialized, &quot;Last logged op id is uninitialized&quot;);</a>
<a name="ln791">  consensus::VoteRequestPB req;</a>
<a name="ln792">  req.set_dest_uuid(replica-&gt;uuid());</a>
<a name="ln793">  req.set_tablet_id(tablet_id);</a>
<a name="ln794">  req.set_candidate_uuid(candidate_uuid);</a>
<a name="ln795">  req.set_candidate_term(candidate_term);</a>
<a name="ln796">  *req.mutable_candidate_status()-&gt;mutable_last_received() = last_logged_opid;</a>
<a name="ln797">  if (ignore_live_leader) req.set_ignore_live_leader(*ignore_live_leader);</a>
<a name="ln798">  if (is_pre_election) req.set_preelection(*is_pre_election);</a>
<a name="ln799">  consensus::VoteResponsePB resp;</a>
<a name="ln800">  RpcController rpc;</a>
<a name="ln801">  rpc.set_timeout(timeout);</a>
<a name="ln802">  RETURN_NOT_OK(replica-&gt;consensus_proxy-&gt;RequestConsensusVote(req, &amp;resp, &amp;rpc));</a>
<a name="ln803">  if (resp.has_vote_granted() &amp;&amp; resp.vote_granted())</a>
<a name="ln804">    return Status::OK();</a>
<a name="ln805">  if (resp.has_error())</a>
<a name="ln806">    return StatusFromPB(resp.error().status());</a>
<a name="ln807">  if (resp.has_consensus_error())</a>
<a name="ln808">    return StatusFromPB(resp.consensus_error().status());</a>
<a name="ln809">  return STATUS(IllegalState, &quot;Unknown error (vote not granted)&quot;);</a>
<a name="ln810">}</a>
<a name="ln811"> </a>
<a name="ln812">Status LeaderStepDown(</a>
<a name="ln813">    const TServerDetails* replica,</a>
<a name="ln814">    const string&amp; tablet_id,</a>
<a name="ln815">    const TServerDetails* new_leader,</a>
<a name="ln816">    const MonoDelta&amp; timeout,</a>
<a name="ln817">    const bool disable_graceful_transition,</a>
<a name="ln818">    TabletServerErrorPB* error) {</a>
<a name="ln819">  LeaderStepDownRequestPB req;</a>
<a name="ln820">  req.set_dest_uuid(replica-&gt;uuid());</a>
<a name="ln821">  req.set_tablet_id(tablet_id);</a>
<a name="ln822">  if (disable_graceful_transition) {</a>
<a name="ln823">    req.set_disable_graceful_transition(disable_graceful_transition);</a>
<a name="ln824">  }</a>
<a name="ln825">  if (new_leader) {</a>
<a name="ln826">    req.set_new_leader_uuid(new_leader-&gt;uuid());</a>
<a name="ln827">  }</a>
<a name="ln828">  LeaderStepDownResponsePB resp;</a>
<a name="ln829">  RpcController rpc;</a>
<a name="ln830">  rpc.set_timeout(timeout);</a>
<a name="ln831">  RETURN_NOT_OK(replica-&gt;consensus_proxy-&gt;LeaderStepDown(req, &amp;resp, &amp;rpc));</a>
<a name="ln832">  if (resp.has_error()) {</a>
<a name="ln833">    if (error != nullptr) {</a>
<a name="ln834">      *error = resp.error();</a>
<a name="ln835">    }</a>
<a name="ln836">    return StatusFromPB(resp.error().status())</a>
<a name="ln837">      .CloneAndPrepend(Substitute(&quot;Code $0&quot;, TabletServerErrorPB::Code_Name(resp.error().code())));</a>
<a name="ln838">  }</a>
<a name="ln839">  return Status::OK();</a>
<a name="ln840">}</a>
<a name="ln841"> </a>
<a name="ln842">Status WriteSimpleTestRow(const TServerDetails* replica,</a>
<a name="ln843">                          const std::string&amp; tablet_id,</a>
<a name="ln844">                          int32_t key,</a>
<a name="ln845">                          int32_t int_val,</a>
<a name="ln846">                          const string&amp; string_val,</a>
<a name="ln847">                          const MonoDelta&amp; timeout) {</a>
<a name="ln848">  WriteRequestPB req;</a>
<a name="ln849">  WriteResponsePB resp;</a>
<a name="ln850">  RpcController rpc;</a>
<a name="ln851">  rpc.set_timeout(timeout);</a>
<a name="ln852"> </a>
<a name="ln853">  req.set_tablet_id(tablet_id);</a>
<a name="ln854"> </a>
<a name="ln855">  AddTestRowInsert(key, int_val, string_val, &amp;req);</a>
<a name="ln856"> </a>
<a name="ln857">  RETURN_NOT_OK(replica-&gt;tserver_proxy-&gt;Write(req, &amp;resp, &amp;rpc));</a>
<a name="ln858">  if (resp.has_error()) {</a>
<a name="ln859">    return StatusFromPB(resp.error().status());</a>
<a name="ln860">  }</a>
<a name="ln861">  return Status::OK();</a>
<a name="ln862">}</a>
<a name="ln863"> </a>
<a name="ln864">namespace {</a>
<a name="ln865">  Status SendAddRemoveServerRequest(const TServerDetails* leader,</a>
<a name="ln866">                                    const ChangeConfigRequestPB&amp; req,</a>
<a name="ln867">                                    ChangeConfigResponsePB* resp,</a>
<a name="ln868">                                    RpcController* rpc,</a>
<a name="ln869">                                    const MonoDelta&amp; timeout,</a>
<a name="ln870">                                    TabletServerErrorPB::Code* error_code,</a>
<a name="ln871">                                    bool retry) {</a>
<a name="ln872">    Status status = Status::OK();</a>
<a name="ln873">    MonoTime start = MonoTime::Now();</a>
<a name="ln874">    do {</a>
<a name="ln875">      RETURN_NOT_OK(leader-&gt;consensus_proxy-&gt;ChangeConfig(req, resp, rpc));</a>
<a name="ln876">      if (!resp-&gt;has_error()) {</a>
<a name="ln877">        break;</a>
<a name="ln878">      }</a>
<a name="ln879">      if (error_code) *error_code = resp-&gt;error().code();</a>
<a name="ln880">      status = StatusFromPB(resp-&gt;error().status());</a>
<a name="ln881">      if (!retry) {</a>
<a name="ln882">        break;</a>
<a name="ln883">      }</a>
<a name="ln884">      if (resp-&gt;error().code() != TabletServerErrorPB::LEADER_NOT_READY_CHANGE_CONFIG) {</a>
<a name="ln885">        break;</a>
<a name="ln886">      }</a>
<a name="ln887">      rpc-&gt;Reset();</a>
<a name="ln888">    } while (MonoTime::Now().GetDeltaSince(start).LessThan(timeout));</a>
<a name="ln889">    return status;</a>
<a name="ln890">  }</a>
<a name="ln891">} // namespace</a>
<a name="ln892"> </a>
<a name="ln893">Status AddServer(const TServerDetails* leader,</a>
<a name="ln894">                 const std::string&amp; tablet_id,</a>
<a name="ln895">                 const TServerDetails* replica_to_add,</a>
<a name="ln896">                 consensus::RaftPeerPB::MemberType member_type,</a>
<a name="ln897">                 const boost::optional&lt;int64_t&gt;&amp; cas_config_opid_index,</a>
<a name="ln898">                 const MonoDelta&amp; timeout,</a>
<a name="ln899">                 TabletServerErrorPB::Code* error_code,</a>
<a name="ln900">                 bool retry) {</a>
<a name="ln901">  ChangeConfigRequestPB req;</a>
<a name="ln902">  ChangeConfigResponsePB resp;</a>
<a name="ln903">  RpcController rpc;</a>
<a name="ln904">  rpc.set_timeout(timeout);</a>
<a name="ln905"> </a>
<a name="ln906">  req.set_dest_uuid(leader-&gt;uuid());</a>
<a name="ln907">  req.set_tablet_id(tablet_id);</a>
<a name="ln908">  req.set_type(consensus::ADD_SERVER);</a>
<a name="ln909">  RaftPeerPB* peer = req.mutable_server();</a>
<a name="ln910">  peer-&gt;set_permanent_uuid(replica_to_add-&gt;uuid());</a>
<a name="ln911">  peer-&gt;set_member_type(member_type);</a>
<a name="ln912">  CopyRegistration(replica_to_add-&gt;registration.common(), peer);</a>
<a name="ln913">  if (cas_config_opid_index) {</a>
<a name="ln914">    req.set_cas_config_opid_index(*cas_config_opid_index);</a>
<a name="ln915">  }</a>
<a name="ln916"> </a>
<a name="ln917">  return SendAddRemoveServerRequest(leader, req, &amp;resp, &amp;rpc, timeout, error_code, retry);</a>
<a name="ln918">}</a>
<a name="ln919"> </a>
<a name="ln920">Status RemoveServer(const TServerDetails* leader,</a>
<a name="ln921">                    const std::string&amp; tablet_id,</a>
<a name="ln922">                    const TServerDetails* replica_to_remove,</a>
<a name="ln923">                    const boost::optional&lt;int64_t&gt;&amp; cas_config_opid_index,</a>
<a name="ln924">                    const MonoDelta&amp; timeout,</a>
<a name="ln925">                    TabletServerErrorPB::Code* error_code,</a>
<a name="ln926">                    bool retry) {</a>
<a name="ln927">  ChangeConfigRequestPB req;</a>
<a name="ln928">  ChangeConfigResponsePB resp;</a>
<a name="ln929">  RpcController rpc;</a>
<a name="ln930">  rpc.set_timeout(timeout);</a>
<a name="ln931"> </a>
<a name="ln932">  req.set_dest_uuid(leader-&gt;uuid());</a>
<a name="ln933">  req.set_tablet_id(tablet_id);</a>
<a name="ln934">  req.set_type(consensus::REMOVE_SERVER);</a>
<a name="ln935">  if (cas_config_opid_index) {</a>
<a name="ln936">    req.set_cas_config_opid_index(*cas_config_opid_index);</a>
<a name="ln937">  }</a>
<a name="ln938">  RaftPeerPB* peer = req.mutable_server();</a>
<a name="ln939">  peer-&gt;set_permanent_uuid(replica_to_remove-&gt;uuid());</a>
<a name="ln940"> </a>
<a name="ln941">  return SendAddRemoveServerRequest(leader, req, &amp;resp, &amp;rpc, timeout, error_code, retry);</a>
<a name="ln942">}</a>
<a name="ln943"> </a>
<a name="ln944">Status ListTablets(const TServerDetails* ts,</a>
<a name="ln945">                   const MonoDelta&amp; timeout,</a>
<a name="ln946">                   vector&lt;ListTabletsResponsePB::StatusAndSchemaPB&gt;* tablets) {</a>
<a name="ln947">  tserver::ListTabletsRequestPB req;</a>
<a name="ln948">  tserver::ListTabletsResponsePB resp;</a>
<a name="ln949">  RpcController rpc;</a>
<a name="ln950">  rpc.set_timeout(timeout);</a>
<a name="ln951"> </a>
<a name="ln952">  RETURN_NOT_OK(ts-&gt;tserver_proxy-&gt;ListTablets(req, &amp;resp, &amp;rpc));</a>
<a name="ln953">  if (resp.has_error()) {</a>
<a name="ln954">    return StatusFromPB(resp.error().status());</a>
<a name="ln955">  }</a>
<a name="ln956"> </a>
<a name="ln957">  tablets-&gt;assign(resp.status_and_schema().begin(), resp.status_and_schema().end());</a>
<a name="ln958">  return Status::OK();</a>
<a name="ln959">}</a>
<a name="ln960"> </a>
<a name="ln961">Status ListRunningTabletIds(const TServerDetails* ts,</a>
<a name="ln962">                            const MonoDelta&amp; timeout,</a>
<a name="ln963">                            vector&lt;string&gt;* tablet_ids) {</a>
<a name="ln964">  vector&lt;ListTabletsResponsePB::StatusAndSchemaPB&gt; tablets;</a>
<a name="ln965">  RETURN_NOT_OK(ListTablets(ts, timeout, &amp;tablets));</a>
<a name="ln966">  tablet_ids-&gt;clear();</a>
<a name="ln967">  for (const ListTabletsResponsePB::StatusAndSchemaPB&amp; t : tablets) {</a>
<a name="ln968">    if (t.tablet_status().state() == tablet::RUNNING) {</a>
<a name="ln969">      tablet_ids-&gt;push_back(t.tablet_status().tablet_id());</a>
<a name="ln970">    }</a>
<a name="ln971">  }</a>
<a name="ln972">  return Status::OK();</a>
<a name="ln973">}</a>
<a name="ln974"> </a>
<a name="ln975">Status GetTabletLocations(const shared_ptr&lt;MasterServiceProxy&gt;&amp; master_proxy,</a>
<a name="ln976">                          const string&amp; tablet_id,</a>
<a name="ln977">                          const MonoDelta&amp; timeout,</a>
<a name="ln978">                          master::TabletLocationsPB* tablet_locations) {</a>
<a name="ln979">  master::GetTabletLocationsResponsePB resp;</a>
<a name="ln980">  master::GetTabletLocationsRequestPB req;</a>
<a name="ln981">  *req.add_tablet_ids() = tablet_id;</a>
<a name="ln982">  rpc::RpcController rpc;</a>
<a name="ln983">  rpc.set_timeout(timeout);</a>
<a name="ln984">  RETURN_NOT_OK(master_proxy-&gt;GetTabletLocations(req, &amp;resp, &amp;rpc));</a>
<a name="ln985">  if (resp.has_error()) {</a>
<a name="ln986">    return StatusFromPB(resp.error().status());</a>
<a name="ln987">  }</a>
<a name="ln988">  if (resp.errors_size() &gt; 0) {</a>
<a name="ln989">    CHECK_EQ(1, resp.errors_size()) &lt;&lt; resp.ShortDebugString();</a>
<a name="ln990">    return StatusFromPB(resp.errors(0).status());</a>
<a name="ln991">  }</a>
<a name="ln992">  CHECK_EQ(1, resp.tablet_locations_size()) &lt;&lt; resp.ShortDebugString();</a>
<a name="ln993">  *tablet_locations = resp.tablet_locations(0);</a>
<a name="ln994">  return Status::OK();</a>
<a name="ln995">}</a>
<a name="ln996"> </a>
<a name="ln997">Status GetTableLocations(const shared_ptr&lt;MasterServiceProxy&gt;&amp; master_proxy,</a>
<a name="ln998">                         const YBTableName&amp; table_name,</a>
<a name="ln999">                         const MonoDelta&amp; timeout,</a>
<a name="ln1000">                         master::GetTableLocationsResponsePB* table_locations) {</a>
<a name="ln1001">  master::GetTableLocationsRequestPB req;</a>
<a name="ln1002">  table_name.SetIntoTableIdentifierPB(req.mutable_table());</a>
<a name="ln1003">  req.set_max_returned_locations(1000);</a>
<a name="ln1004">  rpc::RpcController rpc;</a>
<a name="ln1005">  rpc.set_timeout(timeout);</a>
<a name="ln1006">  RETURN_NOT_OK(master_proxy-&gt;GetTableLocations(req, table_locations, &amp;rpc));</a>
<a name="ln1007">  if (table_locations-&gt;has_error()) {</a>
<a name="ln1008">    return StatusFromPB(table_locations-&gt;error().status());</a>
<a name="ln1009">  }</a>
<a name="ln1010">  return Status::OK();</a>
<a name="ln1011">}</a>
<a name="ln1012"> </a>
<a name="ln1013">Status WaitForNumVotersInConfigOnMaster(const shared_ptr&lt;MasterServiceProxy&gt;&amp; master_proxy,</a>
<a name="ln1014">                                        const std::string&amp; tablet_id,</a>
<a name="ln1015">                                        int num_voters,</a>
<a name="ln1016">                                        const MonoDelta&amp; timeout) {</a>
<a name="ln1017">  Status s;</a>
<a name="ln1018">  MonoTime deadline = MonoTime::Now();</a>
<a name="ln1019">  deadline.AddDelta(timeout);</a>
<a name="ln1020">  int num_voters_found = 0;</a>
<a name="ln1021">  while (true) {</a>
<a name="ln1022">    TabletLocationsPB tablet_locations;</a>
<a name="ln1023">    MonoDelta time_remaining = deadline.GetDeltaSince(MonoTime::Now());</a>
<a name="ln1024">    s = GetTabletLocations(master_proxy, tablet_id, time_remaining, &amp;tablet_locations);</a>
<a name="ln1025">    if (s.ok()) {</a>
<a name="ln1026">      num_voters_found = 0;</a>
<a name="ln1027">      for (const TabletLocationsPB::ReplicaPB&amp; r : tablet_locations.replicas()) {</a>
<a name="ln1028">        if (r.role() == RaftPeerPB::LEADER || r.role() == RaftPeerPB::FOLLOWER) num_voters_found++;</a>
<a name="ln1029">      }</a>
<a name="ln1030">      if (num_voters_found == num_voters) break;</a>
<a name="ln1031">    }</a>
<a name="ln1032">    if (deadline.ComesBefore(MonoTime::Now())) break;</a>
<a name="ln1033">    SleepFor(MonoDelta::FromMilliseconds(10));</a>
<a name="ln1034">  }</a>
<a name="ln1035">  RETURN_NOT_OK(s);</a>
<a name="ln1036">  if (num_voters_found != num_voters) {</a>
<a name="ln1037">    return STATUS(IllegalState,</a>
<a name="ln1038">        Substitute(&quot;Did not find exactly $0 voters, found $1 voters&quot;,</a>
<a name="ln1039">                   num_voters, num_voters_found));</a>
<a name="ln1040">  }</a>
<a name="ln1041">  return Status::OK();</a>
<a name="ln1042">}</a>
<a name="ln1043"> </a>
<a name="ln1044">Status WaitForNumTabletsOnTS(TServerDetails* ts,</a>
<a name="ln1045">                             int count,</a>
<a name="ln1046">                             const MonoDelta&amp; timeout,</a>
<a name="ln1047">                             vector&lt;ListTabletsResponsePB::StatusAndSchemaPB&gt;* tablets) {</a>
<a name="ln1048">  Status s;</a>
<a name="ln1049">  MonoTime deadline = MonoTime::Now();</a>
<a name="ln1050">  deadline.AddDelta(timeout);</a>
<a name="ln1051">  while (true) {</a>
<a name="ln1052">    s = ListTablets(ts, MonoDelta::FromSeconds(10), tablets);</a>
<a name="ln1053">    if (s.ok() &amp;&amp; tablets-&gt;size() == count) break;</a>
<a name="ln1054">    if (deadline.ComesBefore(MonoTime::Now())) break;</a>
<a name="ln1055">    SleepFor(MonoDelta::FromMilliseconds(10));</a>
<a name="ln1056">  }</a>
<a name="ln1057">  RETURN_NOT_OK(s);</a>
<a name="ln1058">  if (tablets-&gt;size() != count) {</a>
<a name="ln1059">    return STATUS(IllegalState,</a>
<a name="ln1060">        Substitute(&quot;Did not find exactly $0 tablets, found $1 tablets&quot;,</a>
<a name="ln1061">                   count, tablets-&gt;size()));</a>
<a name="ln1062">  }</a>
<a name="ln1063">  return Status::OK();</a>
<a name="ln1064">}</a>
<a name="ln1065"> </a>
<a name="ln1066">Status WaitUntilTabletInState(TServerDetails* ts,</a>
<a name="ln1067">                              const std::string&amp; tablet_id,</a>
<a name="ln1068">                              tablet::RaftGroupStatePB state,</a>
<a name="ln1069">                              const MonoDelta&amp; timeout,</a>
<a name="ln1070">                              const MonoDelta&amp; list_tablets_timeout) {</a>
<a name="ln1071">  MonoTime start = MonoTime::Now();</a>
<a name="ln1072">  MonoTime deadline = start;</a>
<a name="ln1073">  deadline.AddDelta(timeout);</a>
<a name="ln1074">  vector&lt;ListTabletsResponsePB::StatusAndSchemaPB&gt; tablets;</a>
<a name="ln1075">  Status s;</a>
<a name="ln1076">  tablet::RaftGroupStatePB last_state = tablet::UNKNOWN;</a>
<a name="ln1077">  while (true) {</a>
<a name="ln1078">    s = ListTablets(ts, list_tablets_timeout, &amp;tablets);</a>
<a name="ln1079">    if (s.ok()) {</a>
<a name="ln1080">      bool seen = false;</a>
<a name="ln1081">      for (const ListTabletsResponsePB::StatusAndSchemaPB&amp; t : tablets) {</a>
<a name="ln1082">        if (t.tablet_status().tablet_id() == tablet_id) {</a>
<a name="ln1083">          seen = true;</a>
<a name="ln1084">          last_state = t.tablet_status().state();</a>
<a name="ln1085">          if (last_state == state) {</a>
<a name="ln1086">            return Status::OK();</a>
<a name="ln1087">          }</a>
<a name="ln1088">        }</a>
<a name="ln1089">      }</a>
<a name="ln1090">      if (!seen) {</a>
<a name="ln1091">        s = STATUS(NotFound, &quot;Tablet &quot; + tablet_id + &quot; not found&quot;);</a>
<a name="ln1092">      }</a>
<a name="ln1093">    }</a>
<a name="ln1094">    if (deadline.ComesBefore(MonoTime::Now())) {</a>
<a name="ln1095">      break;</a>
<a name="ln1096">    }</a>
<a name="ln1097">    SleepFor(MonoDelta::FromMilliseconds(10));</a>
<a name="ln1098">  }</a>
<a name="ln1099">  return STATUS(TimedOut, Substitute(&quot;T $0 P $1: Tablet not in $2 state after $3: &quot;</a>
<a name="ln1100">                                     &quot;Tablet state: $4, Status message: $5&quot;,</a>
<a name="ln1101">                                     tablet_id, ts-&gt;uuid(),</a>
<a name="ln1102">                                     tablet::RaftGroupStatePB_Name(state),</a>
<a name="ln1103">                                     MonoTime::Now().GetDeltaSince(start).ToString(),</a>
<a name="ln1104">                                     tablet::RaftGroupStatePB_Name(last_state), s.ToString()));</a>
<a name="ln1105">}</a>
<a name="ln1106"> </a>
<a name="ln1107">// Wait until the specified tablet is in RUNNING state.</a>
<a name="ln1108">Status WaitUntilTabletRunning(TServerDetails* ts,</a>
<a name="ln1109">                              const std::string&amp; tablet_id,</a>
<a name="ln1110">                              const MonoDelta&amp; timeout) {</a>
<a name="ln1111">  return WaitUntilTabletInState(ts, tablet_id, tablet::RUNNING, timeout);</a>
<a name="ln1112">}</a>
<a name="ln1113"> </a>
<a name="ln1114">Status DeleteTablet(const TServerDetails* ts,</a>
<a name="ln1115">                    const std::string&amp; tablet_id,</a>
<a name="ln1116">                    const tablet::TabletDataState delete_type,</a>
<a name="ln1117">                    const boost::optional&lt;int64_t&gt;&amp; cas_config_opid_index_less_or_equal,</a>
<a name="ln1118">                    const MonoDelta&amp; timeout,</a>
<a name="ln1119">                    tserver::TabletServerErrorPB::Code* error_code) {</a>
<a name="ln1120">  DeleteTabletRequestPB req;</a>
<a name="ln1121">  DeleteTabletResponsePB resp;</a>
<a name="ln1122">  RpcController rpc;</a>
<a name="ln1123">  rpc.set_timeout(timeout);</a>
<a name="ln1124"> </a>
<a name="ln1125">  req.set_dest_uuid(ts-&gt;uuid());</a>
<a name="ln1126">  req.set_tablet_id(tablet_id);</a>
<a name="ln1127">  req.set_delete_type(delete_type);</a>
<a name="ln1128">  if (cas_config_opid_index_less_or_equal) {</a>
<a name="ln1129">    req.set_cas_config_opid_index_less_or_equal(*cas_config_opid_index_less_or_equal);</a>
<a name="ln1130">  }</a>
<a name="ln1131"> </a>
<a name="ln1132">  RETURN_NOT_OK(ts-&gt;tserver_admin_proxy-&gt;DeleteTablet(req, &amp;resp, &amp;rpc));</a>
<a name="ln1133">  if (resp.has_error()) {</a>
<a name="ln1134">    if (error_code) {</a>
<a name="ln1135">      *error_code = resp.error().code();</a>
<a name="ln1136">    }</a>
<a name="ln1137">    return StatusFromPB(resp.error().status());</a>
<a name="ln1138">  }</a>
<a name="ln1139">  return Status::OK();</a>
<a name="ln1140">}</a>
<a name="ln1141"> </a>
<a name="ln1142">Status StartRemoteBootstrap(const TServerDetails* ts,</a>
<a name="ln1143">                            const string&amp; tablet_id,</a>
<a name="ln1144">                            const string&amp; bootstrap_source_uuid,</a>
<a name="ln1145">                            const HostPort&amp; bootstrap_source_addr,</a>
<a name="ln1146">                            int64_t caller_term,</a>
<a name="ln1147">                            const MonoDelta&amp; timeout) {</a>
<a name="ln1148">  consensus::StartRemoteBootstrapRequestPB req;</a>
<a name="ln1149">  consensus::StartRemoteBootstrapResponsePB resp;</a>
<a name="ln1150">  RpcController rpc;</a>
<a name="ln1151">  rpc.set_timeout(timeout);</a>
<a name="ln1152"> </a>
<a name="ln1153">  req.set_dest_uuid(ts-&gt;uuid());</a>
<a name="ln1154">  req.set_tablet_id(tablet_id);</a>
<a name="ln1155">  req.set_bootstrap_peer_uuid(bootstrap_source_uuid);</a>
<a name="ln1156">  HostPortToPB(bootstrap_source_addr, req.mutable_source_private_addr()-&gt;Add());</a>
<a name="ln1157">  req.set_caller_term(caller_term);</a>
<a name="ln1158"> </a>
<a name="ln1159">  RETURN_NOT_OK(ts-&gt;consensus_proxy-&gt;StartRemoteBootstrap(req, &amp;resp, &amp;rpc));</a>
<a name="ln1160">  if (resp.has_error()) {</a>
<a name="ln1161">    return StatusFromPB(resp.error().status());</a>
<a name="ln1162">  }</a>
<a name="ln1163">  return Status::OK();</a>
<a name="ln1164">}</a>
<a name="ln1165"> </a>
<a name="ln1166">Status GetLastOpIdForMasterReplica(const shared_ptr&lt;ConsensusServiceProxy&gt;&amp; consensus_proxy,</a>
<a name="ln1167">                                   const string&amp; tablet_id,</a>
<a name="ln1168">                                   const string&amp; dest_uuid,</a>
<a name="ln1169">                                   const consensus::OpIdType opid_type,</a>
<a name="ln1170">                                   const MonoDelta&amp; timeout,</a>
<a name="ln1171">                                   OpIdPB* opid) {</a>
<a name="ln1172">  GetLastOpIdRequestPB opid_req;</a>
<a name="ln1173">  GetLastOpIdResponsePB opid_resp;</a>
<a name="ln1174">  RpcController controller;</a>
<a name="ln1175">  controller.Reset();</a>
<a name="ln1176">  controller.set_timeout(timeout);</a>
<a name="ln1177"> </a>
<a name="ln1178">  opid_req.set_dest_uuid(dest_uuid);</a>
<a name="ln1179">  opid_req.set_tablet_id(tablet_id);</a>
<a name="ln1180">  opid_req.set_opid_type(opid_type);</a>
<a name="ln1181"> </a>
<a name="ln1182">  Status s = consensus_proxy-&gt;GetLastOpId(opid_req, &amp;opid_resp, &amp;controller);</a>
<a name="ln1183">  if (!s.ok()) {</a>
<a name="ln1184">    return STATUS(InvalidArgument, Substitute(</a>
<a name="ln1185">        &quot;Failed to fetch opid type $0 from master uuid $1 with error : $2&quot;,</a>
<a name="ln1186">        opid_type, dest_uuid, s.ToString()));</a>
<a name="ln1187">  }</a>
<a name="ln1188">  if (opid_resp.has_error()) {</a>
<a name="ln1189">    return StatusFromPB(opid_resp.error().status());</a>
<a name="ln1190">  }</a>
<a name="ln1191"> </a>
<a name="ln1192">  *opid = opid_resp.opid();</a>
<a name="ln1193"> </a>
<a name="ln1194">  return Status::OK();</a>
<a name="ln1195">}</a>
<a name="ln1196"> </a>
<a name="ln1197">} // namespace itest</a>
<a name="ln1198">} // namespace yb</a>

</code></pre>
<div class="balloon" rel="131"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="436"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="676"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="686"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
