
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>gtest-param-util.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Copyright 2008 Google Inc.</a>
<a name="ln2">// All Rights Reserved.</a>
<a name="ln3">//</a>
<a name="ln4">// Redistribution and use in source and binary forms, with or without</a>
<a name="ln5">// modification, are permitted provided that the following conditions are</a>
<a name="ln6">// met:</a>
<a name="ln7">//</a>
<a name="ln8">//     * Redistributions of source code must retain the above copyright</a>
<a name="ln9">// notice, this list of conditions and the following disclaimer.</a>
<a name="ln10">//     * Redistributions in binary form must reproduce the above</a>
<a name="ln11">// copyright notice, this list of conditions and the following disclaimer</a>
<a name="ln12">// in the documentation and/or other materials provided with the</a>
<a name="ln13">// distribution.</a>
<a name="ln14">//     * Neither the name of Google Inc. nor the names of its</a>
<a name="ln15">// contributors may be used to endorse or promote products derived from</a>
<a name="ln16">// this software without specific prior written permission.</a>
<a name="ln17">//</a>
<a name="ln18">// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</a>
<a name="ln19">// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</a>
<a name="ln20">// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</a>
<a name="ln21">// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</a>
<a name="ln22">// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</a>
<a name="ln23">// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</a>
<a name="ln24">// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</a>
<a name="ln25">// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</a>
<a name="ln26">// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</a>
<a name="ln27">// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</a>
<a name="ln28">// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</a>
<a name="ln29">//</a>
<a name="ln30">// Author: vladl@google.com (Vlad Losev)</a>
<a name="ln31"> </a>
<a name="ln32">// Type and function utilities for implementing parameterized tests.</a>
<a name="ln33"> </a>
<a name="ln34">#ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PARAM_UTIL_H_</a>
<a name="ln35">#define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PARAM_UTIL_H_</a>
<a name="ln36"> </a>
<a name="ln37">#include &lt;ctype.h&gt;</a>
<a name="ln38"> </a>
<a name="ln39">#include &lt;iterator&gt;</a>
<a name="ln40">#include &lt;set&gt;</a>
<a name="ln41">#include &lt;utility&gt;</a>
<a name="ln42">#include &lt;vector&gt;</a>
<a name="ln43"> </a>
<a name="ln44">// scripts/fuse_gtest.py depends on gtest's own header being #included</a>
<a name="ln45">// *unconditionally*.  Therefore these #includes cannot be moved</a>
<a name="ln46">// inside #if GTEST_HAS_PARAM_TEST.</a>
<a name="ln47">#include &quot;gtest/internal/gtest-internal.h&quot;</a>
<a name="ln48">#include &quot;gtest/internal/gtest-linked_ptr.h&quot;</a>
<a name="ln49">#include &quot;gtest/internal/gtest-port.h&quot;</a>
<a name="ln50">#include &quot;gtest/gtest-printers.h&quot;</a>
<a name="ln51"> </a>
<a name="ln52">#if GTEST_HAS_PARAM_TEST</a>
<a name="ln53"> </a>
<a name="ln54">namespace testing {</a>
<a name="ln55"> </a>
<a name="ln56">// Input to a parameterized test name generator, describing a test parameter.</a>
<a name="ln57">// Consists of the parameter value and the integer parameter index.</a>
<a name="ln58">template &lt;class ParamType&gt;</a>
<a name="ln59">struct TestParamInfo {</a>
<a name="ln60">  TestParamInfo(const ParamType&amp; a_param, size_t an_index) :</a>
<a name="ln61">    param(a_param),</a>
<a name="ln62">    index(an_index) {}</a>
<a name="ln63">  ParamType param;</a>
<a name="ln64">  size_t index;</a>
<a name="ln65">};</a>
<a name="ln66"> </a>
<a name="ln67">// A builtin parameterized test name generator which returns the result of</a>
<a name="ln68">// testing::PrintToString.</a>
<a name="ln69">struct PrintToStringParamName {</a>
<a name="ln70">  template &lt;class ParamType&gt;</a>
<a name="ln71">  std::string operator()(const TestParamInfo&lt;ParamType&gt;&amp; info) const {</a>
<a name="ln72">    return PrintToString(info.param);</a>
<a name="ln73">  }</a>
<a name="ln74">};</a>
<a name="ln75"> </a>
<a name="ln76">namespace internal {</a>
<a name="ln77"> </a>
<a name="ln78">// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.</a>
<a name="ln79">//</a>
<a name="ln80">// Outputs a message explaining invalid registration of different</a>
<a name="ln81">// fixture class for the same test case. This may happen when</a>
<a name="ln82">// TEST_P macro is used to define two tests with the same name</a>
<a name="ln83">// but in different namespaces.</a>
<a name="ln84">GTEST_API_ void ReportInvalidTestCaseType(const char* test_case_name,</a>
<a name="ln85">                                          CodeLocation code_location);</a>
<a name="ln86"> </a>
<a name="ln87">template &lt;typename&gt; class ParamGeneratorInterface;</a>
<a name="ln88">template &lt;typename&gt; class ParamGenerator;</a>
<a name="ln89"> </a>
<a name="ln90">// Interface for iterating over elements provided by an implementation</a>
<a name="ln91">// of ParamGeneratorInterface&lt;T&gt;.</a>
<a name="ln92">template &lt;typename T&gt;</a>
<a name="ln93">class ParamIteratorInterface {</a>
<a name="ln94"> public:</a>
<a name="ln95">  virtual ~ParamIteratorInterface() {}</a>
<a name="ln96">  // A pointer to the base generator instance.</a>
<a name="ln97">  // Used only for the purposes of iterator comparison</a>
<a name="ln98">  // to make sure that two iterators belong to the same generator.</a>
<a name="ln99">  virtual const ParamGeneratorInterface&lt;T&gt;* BaseGenerator() const = 0;</a>
<a name="ln100">  // Advances iterator to point to the next element</a>
<a name="ln101">  // provided by the generator. The caller is responsible</a>
<a name="ln102">  // for not calling Advance() on an iterator equal to</a>
<a name="ln103">  // BaseGenerator()-&gt;End().</a>
<a name="ln104">  virtual void Advance() = 0;</a>
<a name="ln105">  // Clones the iterator object. Used for implementing copy semantics</a>
<a name="ln106">  // of ParamIterator&lt;T&gt;.</a>
<a name="ln107">  virtual ParamIteratorInterface* Clone() const = 0;</a>
<a name="ln108">  // Dereferences the current iterator and provides (read-only) access</a>
<a name="ln109">  // to the pointed value. It is the caller's responsibility not to call</a>
<a name="ln110">  // Current() on an iterator equal to BaseGenerator()-&gt;End().</a>
<a name="ln111">  // Used for implementing ParamGenerator&lt;T&gt;::operator*().</a>
<a name="ln112">  virtual const T* Current() const = 0;</a>
<a name="ln113">  // Determines whether the given iterator and other point to the same</a>
<a name="ln114">  // element in the sequence generated by the generator.</a>
<a name="ln115">  // Used for implementing ParamGenerator&lt;T&gt;::operator==().</a>
<a name="ln116">  virtual bool Equals(const ParamIteratorInterface&amp; other) const = 0;</a>
<a name="ln117">};</a>
<a name="ln118"> </a>
<a name="ln119">// Class iterating over elements provided by an implementation of</a>
<a name="ln120">// ParamGeneratorInterface&lt;T&gt;. It wraps ParamIteratorInterface&lt;T&gt;</a>
<a name="ln121">// and implements the const forward iterator concept.</a>
<a name="ln122">template &lt;typename T&gt;</a>
<a name="ln123">class ParamIterator {</a>
<a name="ln124"> public:</a>
<a name="ln125">  typedef T value_type;</a>
<a name="ln126">  typedef const T&amp; reference;</a>
<a name="ln127">  typedef ptrdiff_t difference_type;</a>
<a name="ln128"> </a>
<a name="ln129">  // ParamIterator assumes ownership of the impl_ pointer.</a>
<a name="ln130">  ParamIterator(const ParamIterator&amp; other) : impl_(other.impl_-&gt;Clone()) {}</a>
<a name="ln131">  ParamIterator&amp; operator=(const ParamIterator&amp; other) {</a>
<a name="ln132">    if (this != &amp;other)</a>
<a name="ln133">      impl_.reset(other.impl_-&gt;Clone());</a>
<a name="ln134">    return *this;</a>
<a name="ln135">  }</a>
<a name="ln136"> </a>
<a name="ln137">  const T&amp; operator*() const { return *impl_-&gt;Current(); }</a>
<a name="ln138">  const T* operator-&gt;() const { return impl_-&gt;Current(); }</a>
<a name="ln139">  // Prefix version of operator++.</a>
<a name="ln140">  ParamIterator&amp; operator++() {</a>
<a name="ln141">    impl_-&gt;Advance();</a>
<a name="ln142">    return *this;</a>
<a name="ln143">  }</a>
<a name="ln144">  // Postfix version of operator++.</a>
<a name="ln145">  ParamIterator operator++(int /*unused*/) {</a>
<a name="ln146">    ParamIteratorInterface&lt;T&gt;* clone = impl_-&gt;Clone();</a>
<a name="ln147">    impl_-&gt;Advance();</a>
<a name="ln148">    return ParamIterator(clone);</a>
<a name="ln149">  }</a>
<a name="ln150">  bool operator==(const ParamIterator&amp; other) const {</a>
<a name="ln151">    return impl_.get() == other.impl_.get() || impl_-&gt;Equals(*other.impl_);</a>
<a name="ln152">  }</a>
<a name="ln153">  bool operator!=(const ParamIterator&amp; other) const {</a>
<a name="ln154">    return !(*this == other);</a>
<a name="ln155">  }</a>
<a name="ln156"> </a>
<a name="ln157"> private:</a>
<a name="ln158">  friend class ParamGenerator&lt;T&gt;;</a>
<a name="ln159">  explicit ParamIterator(ParamIteratorInterface&lt;T&gt;* impl) : impl_(impl) {}</a>
<a name="ln160">  scoped_ptr&lt;ParamIteratorInterface&lt;T&gt; &gt; impl_;</a>
<a name="ln161">};</a>
<a name="ln162"> </a>
<a name="ln163">// ParamGeneratorInterface&lt;T&gt; is the binary interface to access generators</a>
<a name="ln164">// defined in other translation units.</a>
<a name="ln165">template &lt;typename T&gt;</a>
<a name="ln166">class ParamGeneratorInterface {</a>
<a name="ln167"> public:</a>
<a name="ln168">  typedef T ParamType;</a>
<a name="ln169"> </a>
<a name="ln170">  virtual ~ParamGeneratorInterface() {}</a>
<a name="ln171"> </a>
<a name="ln172">  // Generator interface definition</a>
<a name="ln173">  virtual ParamIteratorInterface&lt;T&gt;* Begin() const = 0;</a>
<a name="ln174">  virtual ParamIteratorInterface&lt;T&gt;* End() const = 0;</a>
<a name="ln175">};</a>
<a name="ln176"> </a>
<a name="ln177">// Wraps ParamGeneratorInterface&lt;T&gt; and provides general generator syntax</a>
<a name="ln178">// compatible with the STL Container concept.</a>
<a name="ln179">// This class implements copy initialization semantics and the contained</a>
<a name="ln180">// ParamGeneratorInterface&lt;T&gt; instance is shared among all copies</a>
<a name="ln181">// of the original object. This is possible because that instance is immutable.</a>
<a name="ln182">template&lt;typename T&gt;</a>
<a name="ln183">class ParamGenerator {</a>
<a name="ln184"> public:</a>
<a name="ln185">  typedef ParamIterator&lt;T&gt; iterator;</a>
<a name="ln186"> </a>
<a name="ln187">  explicit ParamGenerator(ParamGeneratorInterface&lt;T&gt;* impl) : impl_(impl) {}</a>
<a name="ln188">  ParamGenerator(const ParamGenerator&amp; other) : impl_(other.impl_) {}</a>
<a name="ln189"> </a>
<a name="ln190">  ParamGenerator&amp; operator=(const ParamGenerator&amp; other) {</a>
<a name="ln191">    impl_ = other.impl_;</a>
<a name="ln192">    return *this;</a>
<a name="ln193">  }</a>
<a name="ln194"> </a>
<a name="ln195">  iterator begin() const { return iterator(impl_-&gt;Begin()); }</a>
<a name="ln196">  iterator end() const { return iterator(impl_-&gt;End()); }</a>
<a name="ln197"> </a>
<a name="ln198"> private:</a>
<a name="ln199">  linked_ptr&lt;const ParamGeneratorInterface&lt;T&gt; &gt; impl_;</a>
<a name="ln200">};</a>
<a name="ln201"> </a>
<a name="ln202">// Generates values from a range of two comparable values. Can be used to</a>
<a name="ln203">// generate sequences of user-defined types that implement operator+() and</a>
<a name="ln204">// operator&lt;().</a>
<a name="ln205">// This class is used in the Range() function.</a>
<a name="ln206">template &lt;typename T, typename IncrementT&gt;</a>
<a name="ln207">class RangeGenerator : public ParamGeneratorInterface&lt;T&gt; {</a>
<a name="ln208"> public:</a>
<a name="ln209">  RangeGenerator(T begin, T end, IncrementT step)</a>
<a name="ln210">      : begin_(begin), end_(end),</a>
<a name="ln211">        step_(step), end_index_(CalculateEndIndex(begin, end, step)) {}</a>
<a name="ln212">  virtual ~RangeGenerator() {}</a>
<a name="ln213"> </a>
<a name="ln214">  virtual ParamIteratorInterface&lt;T&gt;* Begin() const {</a>
<a name="ln215">    return new Iterator(this, begin_, 0, step_);</a>
<a name="ln216">  }</a>
<a name="ln217">  virtual ParamIteratorInterface&lt;T&gt;* End() const {</a>
<a name="ln218">    return new Iterator(this, end_, end_index_, step_);</a>
<a name="ln219">  }</a>
<a name="ln220"> </a>
<a name="ln221"> private:</a>
<a name="ln222">  class Iterator : public ParamIteratorInterface&lt;T&gt; {</a>
<a name="ln223">   public:</a>
<a name="ln224">    Iterator(const ParamGeneratorInterface&lt;T&gt;* base, T value, int index,</a>
<a name="ln225">             IncrementT step)</a>
<a name="ln226">        : base_(base), value_(value), index_(index), step_(step) {}</a>
<a name="ln227">    virtual ~Iterator() {}</a>
<a name="ln228"> </a>
<a name="ln229">    virtual const ParamGeneratorInterface&lt;T&gt;* BaseGenerator() const {</a>
<a name="ln230">      return base_;</a>
<a name="ln231">    }</a>
<a name="ln232">    virtual void Advance() {</a>
<a name="ln233">      value_ = static_cast&lt;T&gt;(value_ + step_);</a>
<a name="ln234">      index_++;</a>
<a name="ln235">    }</a>
<a name="ln236">    virtual ParamIteratorInterface&lt;T&gt;* Clone() const {</a>
<a name="ln237">      return new Iterator(*this);</a>
<a name="ln238">    }</a>
<a name="ln239">    virtual const T* Current() const { return &amp;value_; }</a>
<a name="ln240">    virtual bool Equals(const ParamIteratorInterface&lt;T&gt;&amp; other) const {</a>
<a name="ln241">      // Having the same base generator guarantees that the other</a>
<a name="ln242">      // iterator is of the same type and we can downcast.</a>
<a name="ln243">      GTEST_CHECK_(BaseGenerator() == other.BaseGenerator())</a>
<a name="ln244">          &lt;&lt; &quot;The program attempted to compare iterators &quot;</a>
<a name="ln245">          &lt;&lt; &quot;from different generators.&quot; &lt;&lt; std::endl;</a>
<a name="ln246">      const int other_index =</a>
<a name="ln247">          CheckedDowncastToActualType&lt;const Iterator&gt;(&amp;other)-&gt;index_;</a>
<a name="ln248">      return index_ == other_index;</a>
<a name="ln249">    }</a>
<a name="ln250"> </a>
<a name="ln251">   private:</a>
<a name="ln252">    Iterator(const Iterator&amp; other)</a>
<a name="ln253">        : ParamIteratorInterface&lt;T&gt;(),</a>
<a name="ln254">          base_(other.base_), value_(other.value_), index_(other.index_),</a>
<a name="ln255">          step_(other.step_) {}</a>
<a name="ln256"> </a>
<a name="ln257">    // No implementation - assignment is unsupported.</a>
<a name="ln258">    void operator=(const Iterator&amp; other);</a>
<a name="ln259"> </a>
<a name="ln260">    const ParamGeneratorInterface&lt;T&gt;* const base_;</a>
<a name="ln261">    T value_;</a>
<a name="ln262">    int index_;</a>
<a name="ln263">    const IncrementT step_;</a>
<a name="ln264">  };  // class RangeGenerator::Iterator</a>
<a name="ln265"> </a>
<a name="ln266">  static int CalculateEndIndex(const T&amp; begin,</a>
<a name="ln267">                               const T&amp; end,</a>
<a name="ln268">                               const IncrementT&amp; step) {</a>
<a name="ln269">    int end_index = 0;</a>
<a name="ln270">    for (T i = begin; i &lt; end; i = static_cast&lt;T&gt;(i + step))</a>
<a name="ln271">      end_index++;</a>
<a name="ln272">    return end_index;</a>
<a name="ln273">  }</a>
<a name="ln274"> </a>
<a name="ln275">  // No implementation - assignment is unsupported.</a>
<a name="ln276">  void operator=(const RangeGenerator&amp; other);</a>
<a name="ln277"> </a>
<a name="ln278">  const T begin_;</a>
<a name="ln279">  const T end_;</a>
<a name="ln280">  const IncrementT step_;</a>
<a name="ln281">  // The index for the end() iterator. All the elements in the generated</a>
<a name="ln282">  // sequence are indexed (0-based) to aid iterator comparison.</a>
<a name="ln283">  const int end_index_;</a>
<a name="ln284">};  // class RangeGenerator</a>
<a name="ln285"> </a>
<a name="ln286"> </a>
<a name="ln287">// Generates values from a pair of STL-style iterators. Used in the</a>
<a name="ln288">// ValuesIn() function. The elements are copied from the source range</a>
<a name="ln289">// since the source can be located on the stack, and the generator</a>
<a name="ln290">// is likely to persist beyond that stack frame.</a>
<a name="ln291">template &lt;typename T&gt;</a>
<a name="ln292">class ValuesInIteratorRangeGenerator : public ParamGeneratorInterface&lt;T&gt; {</a>
<a name="ln293"> public:</a>
<a name="ln294">  template &lt;typename ForwardIterator&gt;</a>
<a name="ln295">  ValuesInIteratorRangeGenerator(ForwardIterator begin, ForwardIterator end)</a>
<a name="ln296">      : container_(begin, end) {}</a>
<a name="ln297">  virtual ~ValuesInIteratorRangeGenerator() {}</a>
<a name="ln298"> </a>
<a name="ln299">  virtual ParamIteratorInterface&lt;T&gt;* Begin() const {</a>
<a name="ln300">    return new Iterator(this, container_.begin());</a>
<a name="ln301">  }</a>
<a name="ln302">  virtual ParamIteratorInterface&lt;T&gt;* End() const {</a>
<a name="ln303">    return new Iterator(this, container_.end());</a>
<a name="ln304">  }</a>
<a name="ln305"> </a>
<a name="ln306"> private:</a>
<a name="ln307">  typedef typename ::std::vector&lt;T&gt; ContainerType;</a>
<a name="ln308"> </a>
<a name="ln309">  class Iterator : public ParamIteratorInterface&lt;T&gt; {</a>
<a name="ln310">   public:</a>
<a name="ln311">    Iterator(const ParamGeneratorInterface&lt;T&gt;* base,</a>
<a name="ln312">             typename ContainerType::const_iterator iterator)</a>
<a name="ln313">        : base_(base), iterator_(iterator) {}</a>
<a name="ln314">    virtual ~Iterator() {}</a>
<a name="ln315"> </a>
<a name="ln316">    virtual const ParamGeneratorInterface&lt;T&gt;* BaseGenerator() const {</a>
<a name="ln317">      return base_;</a>
<a name="ln318">    }</a>
<a name="ln319">    virtual void Advance() {</a>
<a name="ln320">      ++iterator_;</a>
<a name="ln321">      value_.reset();</a>
<a name="ln322">    }</a>
<a name="ln323">    virtual ParamIteratorInterface&lt;T&gt;* Clone() const {</a>
<a name="ln324">      return new Iterator(*this);</a>
<a name="ln325">    }</a>
<a name="ln326">    // We need to use cached value referenced by iterator_ because *iterator_</a>
<a name="ln327">    // can return a temporary object (and of type other then T), so just</a>
<a name="ln328">    // having &quot;return &amp;*iterator_;&quot; doesn't work.</a>
<a name="ln329">    // value_ is updated here and not in Advance() because Advance()</a>
<a name="ln330">    // can advance iterator_ beyond the end of the range, and we cannot</a>
<a name="ln331">    // detect that fact. The client code, on the other hand, is</a>
<a name="ln332">    // responsible for not calling Current() on an out-of-range iterator.</a>
<a name="ln333">    virtual const T* Current() const {</a>
<a name="ln334">      if (value_.get() == NULL)</a>
<a name="ln335">        value_.reset(new T(*iterator_));</a>
<a name="ln336">      return value_.get();</a>
<a name="ln337">    }</a>
<a name="ln338">    virtual bool Equals(const ParamIteratorInterface&lt;T&gt;&amp; other) const {</a>
<a name="ln339">      // Having the same base generator guarantees that the other</a>
<a name="ln340">      // iterator is of the same type and we can downcast.</a>
<a name="ln341">      GTEST_CHECK_(BaseGenerator() == other.BaseGenerator())</a>
<a name="ln342">          &lt;&lt; &quot;The program attempted to compare iterators &quot;</a>
<a name="ln343">          &lt;&lt; &quot;from different generators.&quot; &lt;&lt; std::endl;</a>
<a name="ln344">      return iterator_ ==</a>
<a name="ln345">          CheckedDowncastToActualType&lt;const Iterator&gt;(&amp;other)-&gt;iterator_;</a>
<a name="ln346">    }</a>
<a name="ln347"> </a>
<a name="ln348">   private:</a>
<a name="ln349">    Iterator(const Iterator&amp; other)</a>
<a name="ln350">          // The explicit constructor call suppresses a false warning</a>
<a name="ln351">          // emitted by gcc when supplied with the -Wextra option.</a>
<a name="ln352">        : ParamIteratorInterface&lt;T&gt;(),</a>
<a name="ln353">          base_(other.base_),</a>
<a name="ln354">          iterator_(other.iterator_) {}</a>
<a name="ln355"> </a>
<a name="ln356">    const ParamGeneratorInterface&lt;T&gt;* const base_;</a>
<a name="ln357">    typename ContainerType::const_iterator iterator_;</a>
<a name="ln358">    // A cached value of *iterator_. We keep it here to allow access by</a>
<a name="ln359">    // pointer in the wrapping iterator's operator-&gt;().</a>
<a name="ln360">    // value_ needs to be mutable to be accessed in Current().</a>
<a name="ln361">    // Use of scoped_ptr helps manage cached value's lifetime,</a>
<a name="ln362">    // which is bound by the lifespan of the iterator itself.</a>
<a name="ln363">    mutable scoped_ptr&lt;const T&gt; value_;</a>
<a name="ln364">  };  // class ValuesInIteratorRangeGenerator::Iterator</a>
<a name="ln365"> </a>
<a name="ln366">  // No implementation - assignment is unsupported.</a>
<a name="ln367">  void operator=(const ValuesInIteratorRangeGenerator&amp; other);</a>
<a name="ln368"> </a>
<a name="ln369">  const ContainerType container_;</a>
<a name="ln370">};  // class ValuesInIteratorRangeGenerator</a>
<a name="ln371"> </a>
<a name="ln372">// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.</a>
<a name="ln373">//</a>
<a name="ln374">// Default parameterized test name generator, returns a string containing the</a>
<a name="ln375">// integer test parameter index.</a>
<a name="ln376">template &lt;class ParamType&gt;</a>
<a name="ln377">std::string DefaultParamName(const TestParamInfo&lt;ParamType&gt;&amp; info) {</a>
<a name="ln378">  Message name_stream;</a>
<a name="ln379">  name_stream &lt;&lt; info.index;</a>
<a name="ln380">  return name_stream.GetString();</a>
<a name="ln381">}</a>
<a name="ln382"> </a>
<a name="ln383">// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.</a>
<a name="ln384">//</a>
<a name="ln385">// Parameterized test name overload helpers, which help the</a>
<a name="ln386">// INSTANTIATE_TEST_CASE_P macro choose between the default parameterized</a>
<a name="ln387">// test name generator and user param name generator.</a>
<a name="ln388">template &lt;class ParamType, class ParamNameGenFunctor&gt;</a>
<a name="ln389">ParamNameGenFunctor GetParamNameGen(ParamNameGenFunctor func) {</a>
<a name="ln390">  return func;</a>
<a name="ln391">}</a>
<a name="ln392"> </a>
<a name="ln393">template &lt;class ParamType&gt;</a>
<a name="ln394">struct ParamNameGenFunc {</a>
<a name="ln395">  typedef std::string Type(const TestParamInfo&lt;ParamType&gt;&amp;);</a>
<a name="ln396">};</a>
<a name="ln397"> </a>
<a name="ln398">template &lt;class ParamType&gt;</a>
<a name="ln399">typename ParamNameGenFunc&lt;ParamType&gt;::Type *GetParamNameGen() {</a>
<a name="ln400">  return DefaultParamName;</a>
<a name="ln401">}</a>
<a name="ln402"> </a>
<a name="ln403">// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.</a>
<a name="ln404">//</a>
<a name="ln405">// Stores a parameter value and later creates tests parameterized with that</a>
<a name="ln406">// value.</a>
<a name="ln407">template &lt;class TestClass&gt;</a>
<a name="ln408">class ParameterizedTestFactory : public TestFactoryBase {</a>
<a name="ln409"> public:</a>
<a name="ln410">  typedef typename TestClass::ParamType ParamType;</a>
<a name="ln411">  explicit ParameterizedTestFactory(ParamType parameter) :</a>
<a name="ln412">      parameter_(parameter) {}</a>
<a name="ln413">  virtual Test* CreateTest() {</a>
<a name="ln414">    TestClass::SetParam(&amp;parameter_);</a>
<a name="ln415">    return new TestClass();</a>
<a name="ln416">  }</a>
<a name="ln417"> </a>
<a name="ln418"> private:</a>
<a name="ln419">  const ParamType parameter_;</a>
<a name="ln420"> </a>
<a name="ln421">  GTEST_DISALLOW_COPY_AND_ASSIGN_(ParameterizedTestFactory);</a>
<a name="ln422">};</a>
<a name="ln423"> </a>
<a name="ln424">// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.</a>
<a name="ln425">//</a>
<a name="ln426">// TestMetaFactoryBase is a base class for meta-factories that create</a>
<a name="ln427">// test factories for passing into MakeAndRegisterTestInfo function.</a>
<a name="ln428">template &lt;class ParamType&gt;</a>
<a name="ln429">class TestMetaFactoryBase {</a>
<a name="ln430"> public:</a>
<a name="ln431">  virtual ~TestMetaFactoryBase() {}</a>
<a name="ln432"> </a>
<a name="ln433">  virtual TestFactoryBase* CreateTestFactory(ParamType parameter) = 0;</a>
<a name="ln434">};</a>
<a name="ln435"> </a>
<a name="ln436">// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.</a>
<a name="ln437">//</a>
<a name="ln438">// TestMetaFactory creates test factories for passing into</a>
<a name="ln439">// MakeAndRegisterTestInfo function. Since MakeAndRegisterTestInfo receives</a>
<a name="ln440">// ownership of test factory pointer, same factory object cannot be passed</a>
<a name="ln441">// into that method twice. But ParameterizedTestCaseInfo is going to call</a>
<a name="ln442">// it for each Test/Parameter value combination. Thus it needs meta factory</a>
<a name="ln443">// creator class.</a>
<a name="ln444">template &lt;class TestCase&gt;</a>
<a name="ln445">class TestMetaFactory</a>
<a name="ln446">    : public TestMetaFactoryBase&lt;typename TestCase::ParamType&gt; {</a>
<a name="ln447"> public:</a>
<a name="ln448">  typedef typename TestCase::ParamType ParamType;</a>
<a name="ln449"> </a>
<a name="ln450">  TestMetaFactory() {}</a>
<a name="ln451"> </a>
<a name="ln452">  virtual TestFactoryBase* CreateTestFactory(ParamType parameter) {</a>
<a name="ln453">    return new ParameterizedTestFactory&lt;TestCase&gt;(parameter);</a>
<a name="ln454">  }</a>
<a name="ln455"> </a>
<a name="ln456"> private:</a>
<a name="ln457">  GTEST_DISALLOW_COPY_AND_ASSIGN_(TestMetaFactory);</a>
<a name="ln458">};</a>
<a name="ln459"> </a>
<a name="ln460">// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.</a>
<a name="ln461">//</a>
<a name="ln462">// ParameterizedTestCaseInfoBase is a generic interface</a>
<a name="ln463">// to ParameterizedTestCaseInfo classes. ParameterizedTestCaseInfoBase</a>
<a name="ln464">// accumulates test information provided by TEST_P macro invocations</a>
<a name="ln465">// and generators provided by INSTANTIATE_TEST_CASE_P macro invocations</a>
<a name="ln466">// and uses that information to register all resulting test instances</a>
<a name="ln467">// in RegisterTests method. The ParameterizeTestCaseRegistry class holds</a>
<a name="ln468">// a collection of pointers to the ParameterizedTestCaseInfo objects</a>
<a name="ln469">// and calls RegisterTests() on each of them when asked.</a>
<a name="ln470">class ParameterizedTestCaseInfoBase {</a>
<a name="ln471"> public:</a>
<a name="ln472">  virtual ~ParameterizedTestCaseInfoBase() {}</a>
<a name="ln473"> </a>
<a name="ln474">  // Base part of test case name for display purposes.</a>
<a name="ln475">  virtual const string&amp; GetTestCaseName() const = 0;</a>
<a name="ln476">  // Test case id to verify identity.</a>
<a name="ln477">  virtual TypeId GetTestCaseTypeId() const = 0;</a>
<a name="ln478">  // UnitTest class invokes this method to register tests in this</a>
<a name="ln479">  // test case right before running them in RUN_ALL_TESTS macro.</a>
<a name="ln480">  // This method should not be called more then once on any single</a>
<a name="ln481">  // instance of a ParameterizedTestCaseInfoBase derived class.</a>
<a name="ln482">  virtual void RegisterTests() = 0;</a>
<a name="ln483"> </a>
<a name="ln484"> protected:</a>
<a name="ln485">  ParameterizedTestCaseInfoBase() {}</a>
<a name="ln486"> </a>
<a name="ln487"> private:</a>
<a name="ln488">  GTEST_DISALLOW_COPY_AND_ASSIGN_(ParameterizedTestCaseInfoBase);</a>
<a name="ln489">};</a>
<a name="ln490"> </a>
<a name="ln491">// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.</a>
<a name="ln492">//</a>
<a name="ln493">// ParameterizedTestCaseInfo accumulates tests obtained from TEST_P</a>
<a name="ln494">// macro invocations for a particular test case and generators</a>
<a name="ln495">// obtained from INSTANTIATE_TEST_CASE_P macro invocations for that</a>
<a name="ln496">// test case. It registers tests with all values generated by all</a>
<a name="ln497">// generators when asked.</a>
<a name="ln498">template &lt;class TestCase&gt;</a>
<a name="ln499">class ParameterizedTestCaseInfo : public ParameterizedTestCaseInfoBase {</a>
<a name="ln500"> public:</a>
<a name="ln501">  // ParamType and GeneratorCreationFunc are private types but are required</a>
<a name="ln502">  // for declarations of public methods AddTestPattern() and</a>
<a name="ln503">  // AddTestCaseInstantiation().</a>
<a name="ln504">  typedef typename TestCase::ParamType ParamType;</a>
<a name="ln505">  // A function that returns an instance of appropriate generator type.</a>
<a name="ln506">  typedef ParamGenerator&lt;ParamType&gt;(GeneratorCreationFunc)();</a>
<a name="ln507">  typedef typename ParamNameGenFunc&lt;ParamType&gt;::Type ParamNameGeneratorFunc;</a>
<a name="ln508"> </a>
<a name="ln509">  explicit ParameterizedTestCaseInfo(</a>
<a name="ln510">      const char* name, CodeLocation code_location)</a>
<a name="ln511">      : test_case_name_(name), code_location_(code_location) {}</a>
<a name="ln512"> </a>
<a name="ln513">  // Test case base name for display purposes.</a>
<a name="ln514">  virtual const string&amp; GetTestCaseName() const { return test_case_name_; }</a>
<a name="ln515">  // Test case id to verify identity.</a>
<a name="ln516">  virtual TypeId GetTestCaseTypeId() const { return GetTypeId&lt;TestCase&gt;(); }</a>
<a name="ln517">  // TEST_P macro uses AddTestPattern() to record information</a>
<a name="ln518">  // about a single test in a LocalTestInfo structure.</a>
<a name="ln519">  // test_case_name is the base name of the test case (without invocation</a>
<a name="ln520">  // prefix). test_base_name is the name of an individual test without</a>
<a name="ln521">  // parameter index. For the test SequenceA/FooTest.DoBar/1 FooTest is</a>
<a name="ln522">  // test case base name and DoBar is test base name.</a>
<a name="ln523">  void AddTestPattern(const char* test_case_name,</a>
<a name="ln524">                      const char* test_base_name,</a>
<a name="ln525">                      TestMetaFactoryBase&lt;ParamType&gt;* meta_factory) {</a>
<a name="ln526">    tests_.push_back(linked_ptr&lt;TestInfo&gt;(new TestInfo(test_case_name,</a>
<a name="ln527">                                                       test_base_name,</a>
<a name="ln528">                                                       meta_factory)));</a>
<a name="ln529">  }</a>
<a name="ln530">  // INSTANTIATE_TEST_CASE_P macro uses AddGenerator() to record information</a>
<a name="ln531">  // about a generator.</a>
<a name="ln532">  int AddTestCaseInstantiation(const string&amp; instantiation_name,</a>
<a name="ln533">                               GeneratorCreationFunc* func,</a>
<a name="ln534">                               ParamNameGeneratorFunc* name_func,</a>
<a name="ln535">                               const char* file,</a>
<a name="ln536">                               int line) {</a>
<a name="ln537">    instantiations_.push_back(</a>
<a name="ln538">        InstantiationInfo(instantiation_name, func, name_func, file, line));</a>
<a name="ln539">    return 0;  // Return value used only to run this method in namespace scope.</a>
<a name="ln540">  }</a>
<a name="ln541">  // UnitTest class invokes this method to register tests in this test case</a>
<a name="ln542">  // test cases right before running tests in RUN_ALL_TESTS macro.</a>
<a name="ln543">  // This method should not be called more then once on any single</a>
<a name="ln544">  // instance of a ParameterizedTestCaseInfoBase derived class.</a>
<a name="ln545">  // UnitTest has a guard to prevent from calling this method more then once.</a>
<a name="ln546">  virtual void RegisterTests() {</a>
<a name="ln547">    for (typename TestInfoContainer::iterator test_it = tests_.begin();</a>
<a name="ln548">         test_it != tests_.end(); ++test_it) {</a>
<a name="ln549">      linked_ptr&lt;TestInfo&gt; test_info = *test_it;</a>
<a name="ln550">      for (typename InstantiationContainer::iterator gen_it =</a>
<a name="ln551">               instantiations_.begin(); gen_it != instantiations_.end();</a>
<a name="ln552">               ++gen_it) {</a>
<a name="ln553">        const string&amp; instantiation_name = gen_it-&gt;name;</a>
<a name="ln554">        ParamGenerator&lt;ParamType&gt; generator((*gen_it-&gt;generator)());</a>
<a name="ln555">        ParamNameGeneratorFunc* name_func = gen_it-&gt;name_func;</a>
<a name="ln556">        const char* file = gen_it-&gt;file;</a>
<a name="ln557">        int line = gen_it-&gt;line;</a>
<a name="ln558"> </a>
<a name="ln559">        string test_case_name;</a>
<a name="ln560">        if ( !instantiation_name.empty() )</a>
<a name="ln561">          test_case_name = instantiation_name + &quot;/&quot;;</a>
<a name="ln562">        test_case_name += test_info-&gt;test_case_base_name;</a>
<a name="ln563"> </a>
<a name="ln564">        size_t i = 0;</a>
<a name="ln565">        std::set&lt;std::string&gt; test_param_names;</a>
<a name="ln566">        for (typename ParamGenerator&lt;ParamType&gt;::iterator param_it =</a>
<a name="ln567">                 generator.begin();</a>
<a name="ln568">             param_it != generator.end(); ++param_it, ++i) {</a>
<a name="ln569">          Message test_name_stream;</a>
<a name="ln570"> </a>
<a name="ln571">          std::string param_name = name_func(</a>
<a name="ln572">              TestParamInfo&lt;ParamType&gt;(*param_it, i));</a>
<a name="ln573"> </a>
<a name="ln574">          GTEST_CHECK_(IsValidParamName(param_name))</a>
<a name="ln575">              &lt;&lt; &quot;Parameterized test name '&quot; &lt;&lt; param_name</a>
<a name="ln576">              &lt;&lt; &quot;' is invalid, in &quot; &lt;&lt; file</a>
<a name="ln577">              &lt;&lt; &quot; line &quot; &lt;&lt; line &lt;&lt; std::endl;</a>
<a name="ln578"> </a>
<a name="ln579">          GTEST_CHECK_(test_param_names.count(param_name) == 0)</a>
<a name="ln580">              &lt;&lt; &quot;Duplicate parameterized test name '&quot; &lt;&lt; param_name</a>
<a name="ln581">              &lt;&lt; &quot;', in &quot; &lt;&lt; file &lt;&lt; &quot; line &quot; &lt;&lt; line &lt;&lt; std::endl;</a>
<a name="ln582"> </a>
<a name="ln583">          test_param_names.insert(param_name);</a>
<a name="ln584"> </a>
<a name="ln585">          test_name_stream &lt;&lt; test_info-&gt;test_base_name &lt;&lt; &quot;/&quot; &lt;&lt; param_name;</a>
<a name="ln586">          MakeAndRegisterTestInfo(</a>
<a name="ln587">              test_case_name.c_str(),</a>
<a name="ln588">              test_name_stream.GetString().c_str(),</a>
<a name="ln589">              NULL,  // No type parameter.</a>
<a name="ln590">              PrintToString(*param_it).c_str(),</a>
<a name="ln591">              code_location_,</a>
<a name="ln592">              GetTestCaseTypeId(),</a>
<a name="ln593">              TestCase::SetUpTestCase,</a>
<a name="ln594">              TestCase::TearDownTestCase,</a>
<a name="ln595">              test_info-&gt;test_meta_factory-&gt;CreateTestFactory(*param_it));</a>
<a name="ln596">        }  // for param_it</a>
<a name="ln597">      }  // for gen_it</a>
<a name="ln598">    }  // for test_it</a>
<a name="ln599">  }  // RegisterTests</a>
<a name="ln600"> </a>
<a name="ln601"> private:</a>
<a name="ln602">  // LocalTestInfo structure keeps information about a single test registered</a>
<a name="ln603">  // with TEST_P macro.</a>
<a name="ln604">  struct TestInfo {</a>
<a name="ln605">    TestInfo(const char* a_test_case_base_name,</a>
<a name="ln606">             const char* a_test_base_name,</a>
<a name="ln607">             TestMetaFactoryBase&lt;ParamType&gt;* a_test_meta_factory) :</a>
<a name="ln608">        test_case_base_name(a_test_case_base_name),</a>
<a name="ln609">        test_base_name(a_test_base_name),</a>
<a name="ln610">        test_meta_factory(a_test_meta_factory) {}</a>
<a name="ln611"> </a>
<a name="ln612">    const string test_case_base_name;</a>
<a name="ln613">    const string test_base_name;</a>
<a name="ln614">    const scoped_ptr&lt;TestMetaFactoryBase&lt;ParamType&gt; &gt; test_meta_factory;</a>
<a name="ln615">  };</a>
<a name="ln616">  typedef ::std::vector&lt;linked_ptr&lt;TestInfo&gt; &gt; TestInfoContainer;</a>
<a name="ln617">  // Records data received from INSTANTIATE_TEST_CASE_P macros:</a>
<a name="ln618">  //  &lt;Instantiation name, Sequence generator creation function,</a>
<a name="ln619">  //     Name generator function, Source file, Source line&gt;</a>
<a name="ln620">  struct InstantiationInfo {</a>
<a name="ln621">      InstantiationInfo(const std::string &amp;name_in,</a>
<a name="ln622">                        GeneratorCreationFunc* generator_in,</a>
<a name="ln623">                        ParamNameGeneratorFunc* name_func_in,</a>
<a name="ln624">                        const char* file_in,</a>
<a name="ln625">                        int line_in)</a>
<a name="ln626">          : name(name_in),</a>
<a name="ln627">            generator(generator_in),</a>
<a name="ln628">            name_func(name_func_in),</a>
<a name="ln629">            file(file_in),</a>
<a name="ln630">            line(line_in) {}</a>
<a name="ln631"> </a>
<a name="ln632">      std::string name;</a>
<a name="ln633">      GeneratorCreationFunc* generator;</a>
<a name="ln634">      ParamNameGeneratorFunc* name_func;</a>
<a name="ln635">      const char* file;</a>
<a name="ln636">      int line;</a>
<a name="ln637">  };</a>
<a name="ln638">  typedef ::std::vector&lt;InstantiationInfo&gt; InstantiationContainer;</a>
<a name="ln639"> </a>
<a name="ln640">  static bool IsValidParamName(const std::string&amp; name) {</a>
<a name="ln641">    // Check for empty string</a>
<a name="ln642">    if (name.empty())</a>
<a name="ln643">      return false;</a>
<a name="ln644"> </a>
<a name="ln645">    // Check for invalid characters</a>
<a name="ln646">    for (std::string::size_type index = 0; index &lt; name.size(); ++index) {</a>
<a name="ln647">      if (!isalnum(name[index]) &amp;&amp; name[index] != '_')</a>
<a name="ln648">        return false;</a>
<a name="ln649">    }</a>
<a name="ln650"> </a>
<a name="ln651">    return true;</a>
<a name="ln652">  }</a>
<a name="ln653"> </a>
<a name="ln654">  const string test_case_name_;</a>
<a name="ln655">  CodeLocation code_location_;</a>
<a name="ln656">  TestInfoContainer tests_;</a>
<a name="ln657">  InstantiationContainer instantiations_;</a>
<a name="ln658"> </a>
<a name="ln659">  GTEST_DISALLOW_COPY_AND_ASSIGN_(ParameterizedTestCaseInfo);</a>
<a name="ln660">};  // class ParameterizedTestCaseInfo</a>
<a name="ln661"> </a>
<a name="ln662">// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.</a>
<a name="ln663">//</a>
<a name="ln664">// ParameterizedTestCaseRegistry contains a map of ParameterizedTestCaseInfoBase</a>
<a name="ln665">// classes accessed by test case names. TEST_P and INSTANTIATE_TEST_CASE_P</a>
<a name="ln666">// macros use it to locate their corresponding ParameterizedTestCaseInfo</a>
<a name="ln667">// descriptors.</a>
<a name="ln668">class ParameterizedTestCaseRegistry {</a>
<a name="ln669"> public:</a>
<a name="ln670">  ParameterizedTestCaseRegistry() {}</a>
<a name="ln671">  ~ParameterizedTestCaseRegistry() {</a>
<a name="ln672">    for (TestCaseInfoContainer::iterator it = test_case_infos_.begin();</a>
<a name="ln673">         it != test_case_infos_.end(); ++it) {</a>
<a name="ln674">      delete *it;</a>
<a name="ln675">    }</a>
<a name="ln676">  }</a>
<a name="ln677"> </a>
<a name="ln678">  // Looks up or creates and returns a structure containing information about</a>
<a name="ln679">  // tests and instantiations of a particular test case.</a>
<a name="ln680">  template &lt;class TestCase&gt;</a>
<a name="ln681">  ParameterizedTestCaseInfo&lt;TestCase&gt;* GetTestCasePatternHolder(</a>
<a name="ln682">      const char* test_case_name,</a>
<a name="ln683">      CodeLocation code_location) {</a>
<a name="ln684">    ParameterizedTestCaseInfo&lt;TestCase&gt;* typed_test_info = NULL;</a>
<a name="ln685">    for (TestCaseInfoContainer::iterator it = test_case_infos_.begin();</a>
<a name="ln686">         it != test_case_infos_.end(); ++it) {</a>
<a name="ln687">      if ((*it)-&gt;GetTestCaseName() == test_case_name) {</a>
<a name="ln688">        if ((*it)-&gt;GetTestCaseTypeId() != GetTypeId&lt;TestCase&gt;()) {</a>
<a name="ln689">          // Complain about incorrect usage of Google Test facilities</a>
<a name="ln690">          // and terminate the program since we cannot guaranty correct</a>
<a name="ln691">          // test case setup and tear-down in this case.</a>
<a name="ln692">          ReportInvalidTestCaseType(test_case_name, code_location);</a>
<a name="ln693">          posix::Abort();</a>
<a name="ln694">        } else {</a>
<a name="ln695">          // At this point we are sure that the object we found is of the same</a>
<a name="ln696">          // type we are looking for, so we downcast it to that type</a>
<a name="ln697">          // without further checks.</a>
<a name="ln698">          typed_test_info = CheckedDowncastToActualType&lt;</a>
<a name="ln699">              ParameterizedTestCaseInfo&lt;TestCase&gt; &gt;(*it);</a>
<a name="ln700">        }</a>
<a name="ln701">        break;</a>
<a name="ln702">      }</a>
<a name="ln703">    }</a>
<a name="ln704">    if (typed_test_info == NULL) {</a>
<a name="ln705">      typed_test_info = new ParameterizedTestCaseInfo&lt;TestCase&gt;(</a>
<a name="ln706">          test_case_name, code_location);</a>
<a name="ln707">      test_case_infos_.push_back(typed_test_info);</a>
<a name="ln708">    }</a>
<a name="ln709">    return typed_test_info;</a>
<a name="ln710">  }</a>
<a name="ln711">  void RegisterTests() {</a>
<a name="ln712">    for (TestCaseInfoContainer::iterator it = test_case_infos_.begin();</a>
<a name="ln713">         it != test_case_infos_.end(); ++it) {</a>
<a name="ln714">      (*it)-&gt;RegisterTests();</a>
<a name="ln715">    }</a>
<a name="ln716">  }</a>
<a name="ln717"> </a>
<a name="ln718"> private:</a>
<a name="ln719">  typedef ::std::vector&lt;ParameterizedTestCaseInfoBase*&gt; TestCaseInfoContainer;</a>
<a name="ln720"> </a>
<a name="ln721">  TestCaseInfoContainer test_case_infos_;</a>
<a name="ln722"> </a>
<a name="ln723">  GTEST_DISALLOW_COPY_AND_ASSIGN_(ParameterizedTestCaseRegistry);</a>
<a name="ln724">};</a>
<a name="ln725"> </a>
<a name="ln726">}  // namespace internal</a>
<a name="ln727">}  // namespace testing</a>
<a name="ln728"> </a>
<a name="ln729">#endif  //  GTEST_HAS_PARAM_TEST</a>
<a name="ln730"> </a>
<a name="ln731">#endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PARAM_UTIL_H_</a>

</code></pre>
<div class="balloon" rel="309"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v690/" target="_blank">V690</a> The copy constructor is declared as private in the 'Iterator' class, but the default copy assignment operator will still be generated by compiler. It is dangerous to use such a class.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
