
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ql_type.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//--------------------------------------------------------------------------------------------------</a>
<a name="ln2">// Copyright (c) YugaByte, Inc.</a>
<a name="ln3">//</a>
<a name="ln4">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln5">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln6">//</a>
<a name="ln7">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln8">//</a>
<a name="ln9">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln10">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln11">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln12">// under the License.</a>
<a name="ln13">//</a>
<a name="ln14">//</a>
<a name="ln15">// This module is to define a few supporting functions for QLTYPE.</a>
<a name="ln16">//--------------------------------------------------------------------------------------------------</a>
<a name="ln17"> </a>
<a name="ln18">#ifndef YB_COMMON_QL_TYPE_H_</a>
<a name="ln19">#define YB_COMMON_QL_TYPE_H_</a>
<a name="ln20"> </a>
<a name="ln21">#include &lt;glog/logging.h&gt;</a>
<a name="ln22"> </a>
<a name="ln23">#include &quot;yb/common/common_fwd.h&quot;</a>
<a name="ln24">#include &quot;yb/common/key_encoder.h&quot;</a>
<a name="ln25">#include &quot;yb/common/common.pb.h&quot;</a>
<a name="ln26">#include &quot;yb/util/result.h&quot;</a>
<a name="ln27">#include &quot;yb/util/status.h&quot;</a>
<a name="ln28"> </a>
<a name="ln29">namespace yb {</a>
<a name="ln30"> </a>
<a name="ln31">// Class for storing the additional fields of user-defined types (compared to primitive QL Types)</a>
<a name="ln32">// Used internally in QLType and only set for user-defined types.</a>
<a name="ln33">class UDTypeInfo {</a>
<a name="ln34"> public:</a>
<a name="ln35"> </a>
<a name="ln36">  UDTypeInfo(std::string keyspace_name, std::string name)</a>
<a name="ln37">      : keyspace_name_(keyspace_name), name_(name) {</a>
<a name="ln38">  }</a>
<a name="ln39"> </a>
<a name="ln40">  const std::string&amp; keyspace_name() const {</a>
<a name="ln41">    return keyspace_name_;</a>
<a name="ln42">  }</a>
<a name="ln43"> </a>
<a name="ln44">  const std::string&amp; name() const {</a>
<a name="ln45">    return name_;</a>
<a name="ln46">  }</a>
<a name="ln47"> </a>
<a name="ln48">  const std::string&amp; id() const {</a>
<a name="ln49">    return id_;</a>
<a name="ln50">  }</a>
<a name="ln51"> </a>
<a name="ln52">  const std::vector&lt;string&gt;&amp; field_names() const {</a>
<a name="ln53">    return field_names_;</a>
<a name="ln54">  }</a>
<a name="ln55"> </a>
<a name="ln56">  const std::string&amp; field_name(int index) const {</a>
<a name="ln57">    return field_names_[index];</a>
<a name="ln58">  }</a>
<a name="ln59"> </a>
<a name="ln60">  void set_udt_fields(const std::string&amp; type_id,</a>
<a name="ln61">                      const std::vector&lt;std::string&gt;&amp; field_names) {</a>
<a name="ln62">    id_ = type_id;</a>
<a name="ln63">    field_names_ = field_names;</a>
<a name="ln64">  }</a>
<a name="ln65"> </a>
<a name="ln66"> private:</a>
<a name="ln67">  std::string keyspace_name_;</a>
<a name="ln68">  std::string name_;</a>
<a name="ln69">  std::string id_;</a>
<a name="ln70">  std::vector&lt;std::string&gt; field_names_ = {};</a>
<a name="ln71">};</a>
<a name="ln72"> </a>
<a name="ln73">class QLType {</a>
<a name="ln74"> public:</a>
<a name="ln75">  typedef std::shared_ptr&lt;QLType&gt; SharedPtr;</a>
<a name="ln76"> </a>
<a name="ln77">  //------------------------------------------------------------------------------------------------</a>
<a name="ln78">  // The Create() functions are to construct QLType objects.</a>
<a name="ln79">  template&lt;DataType data_type&gt;</a>
<a name="ln80">  static const std::shared_ptr&lt;QLType&gt;&amp; CreatePrimitiveType() {</a>
<a name="ln81">    static std::shared_ptr&lt;QLType&gt; ql_type = std::make_shared&lt;QLType&gt;(data_type);</a>
<a name="ln82">    return ql_type;</a>
<a name="ln83">  }</a>
<a name="ln84"> </a>
<a name="ln85">  template&lt;DataType data_type&gt;</a>
<a name="ln86">  static std::shared_ptr&lt;QLType&gt; CreateCollectionType(</a>
<a name="ln87">      const vector&lt;std::shared_ptr&lt;QLType&gt;&gt;&amp; params) {</a>
<a name="ln88">    return std::make_shared&lt;QLType&gt;(data_type, params);</a>
<a name="ln89">  }</a>
<a name="ln90"> </a>
<a name="ln91">  // Create all builtin types including collection.</a>
<a name="ln92">  static std::shared_ptr&lt;QLType&gt; Create(DataType data_type,</a>
<a name="ln93">                                        const vector&lt;std::shared_ptr&lt;QLType&gt;&gt;&amp; params);</a>
<a name="ln94"> </a>
<a name="ln95">  // Create primitive types, all builtin types except collection.</a>
<a name="ln96">  static std::shared_ptr&lt;QLType&gt; Create(DataType data_type);</a>
<a name="ln97"> </a>
<a name="ln98">  // Check type methods.</a>
<a name="ln99">  static bool IsValidPrimaryType(DataType type);</a>
<a name="ln100"> </a>
<a name="ln101">  // Create map datatype.</a>
<a name="ln102">  static std::shared_ptr&lt;QLType&gt; CreateTypeMap(std::shared_ptr&lt;QLType&gt; key_type,</a>
<a name="ln103">                                               std::shared_ptr&lt;QLType&gt; value_type);</a>
<a name="ln104">  static std::shared_ptr&lt;QLType&gt; CreateTypeMap(DataType key_type, DataType value_type);</a>
<a name="ln105">  static std::shared_ptr&lt;QLType&gt; CreateTypeMap() {</a>
<a name="ln106">    // Create default map type: MAP &lt;UNKNOWN -&gt; UNKNOWN&gt;.</a>
<a name="ln107">    static const std::shared_ptr&lt;QLType&gt; default_map =</a>
<a name="ln108">        CreateTypeMap(QLType::Create(DataType::UNKNOWN_DATA),</a>
<a name="ln109">                      QLType::Create(DataType::UNKNOWN_DATA));</a>
<a name="ln110">    return default_map;</a>
<a name="ln111">  }</a>
<a name="ln112"> </a>
<a name="ln113">  // Create list datatype.</a>
<a name="ln114">  static std::shared_ptr&lt;QLType&gt; CreateTypeList(std::shared_ptr&lt;QLType&gt; value_type);</a>
<a name="ln115">  static std::shared_ptr&lt;QLType&gt; CreateTypeList(DataType val_type);</a>
<a name="ln116">  static std::shared_ptr&lt;QLType&gt; CreateTypeList() {</a>
<a name="ln117">    // Create default list type: LIST &lt;UNKNOWN&gt;.</a>
<a name="ln118">    static const std::shared_ptr&lt;QLType&gt; default_list = CreateTypeList(DataType::UNKNOWN_DATA);</a>
<a name="ln119">    return default_list;</a>
<a name="ln120">  }</a>
<a name="ln121"> </a>
<a name="ln122">  // Create set datatype.</a>
<a name="ln123">  static std::shared_ptr&lt;QLType&gt; CreateTypeSet(std::shared_ptr&lt;QLType&gt; value_type);</a>
<a name="ln124">  static std::shared_ptr&lt;QLType&gt; CreateTypeSet(DataType value_type);</a>
<a name="ln125">  static std::shared_ptr&lt;QLType&gt; CreateTypeSet() {</a>
<a name="ln126">    // Create default set type: SET &lt;UNKNOWN&gt;.</a>
<a name="ln127">    static const std::shared_ptr&lt;QLType&gt; default_set = CreateTypeSet(DataType::UNKNOWN_DATA);</a>
<a name="ln128">    return default_set;</a>
<a name="ln129">  }</a>
<a name="ln130"> </a>
<a name="ln131">  // Create frozen datatype</a>
<a name="ln132">  static std::shared_ptr&lt;QLType&gt; CreateTypeFrozen(std::shared_ptr&lt;QLType&gt; value_type);</a>
<a name="ln133">  static std::shared_ptr&lt;QLType&gt; CreateTypeFrozen() {</a>
<a name="ln134">  // Create default frozen type: FROZEN &lt;UNKNOWN&gt;.</a>
<a name="ln135">    static const std::shared_ptr&lt;QLType&gt; default_frozen =</a>
<a name="ln136">        CreateTypeFrozen(QLType::Create(DataType::UNKNOWN_DATA));</a>
<a name="ln137">    return default_frozen;</a>
<a name="ln138">  }</a>
<a name="ln139"> </a>
<a name="ln140">  //------------------------------------------------------------------------------------------------</a>
<a name="ln141">  // Constructors.</a>
<a name="ln142"> </a>
<a name="ln143">  // Constructor for elementary types</a>
<a name="ln144">  explicit QLType(DataType ql_typeid) : id_(ql_typeid), params_(0) {</a>
<a name="ln145">  }</a>
<a name="ln146"> </a>
<a name="ln147">  // Constructor for collection types</a>
<a name="ln148">  QLType(DataType ql_typeid, const vector&lt;std::shared_ptr&lt;QLType&gt;&gt;&amp; params)</a>
<a name="ln149">      : id_(ql_typeid), params_(params) {</a>
<a name="ln150">  }</a>
<a name="ln151"> </a>
<a name="ln152">  // Constructor for user-defined types</a>
<a name="ln153">  QLType(const std::string&amp; keyspace_name, const std::string&amp; type_name)</a>
<a name="ln154">      : id_(USER_DEFINED_TYPE), params_(0) {</a>
<a name="ln155">    udtype_info_ = std::make_shared&lt;UDTypeInfo&gt;(keyspace_name, type_name);</a>
<a name="ln156">  }</a>
<a name="ln157"> </a>
<a name="ln158">  virtual ~QLType() {</a>
<a name="ln159">  }</a>
<a name="ln160"> </a>
<a name="ln161">  //------------------------------------------------------------------------------------------------</a>
<a name="ln162">  // Protobuf support.</a>
<a name="ln163"> </a>
<a name="ln164">  void ToQLTypePB(QLTypePB *pb_type) const;</a>
<a name="ln165">  static std::shared_ptr&lt;QLType&gt; FromQLTypePB(const QLTypePB&amp; pb_type);</a>
<a name="ln166"> </a>
<a name="ln167">  //------------------------------------------------------------------------------------------------</a>
<a name="ln168">  // Access functions.</a>
<a name="ln169"> </a>
<a name="ln170">  const DataType main() const {</a>
<a name="ln171">    return id_;</a>
<a name="ln172">  }</a>
<a name="ln173"> </a>
<a name="ln174">  const vector&lt;std::shared_ptr&lt;QLType&gt;&gt;&amp; params() const {</a>
<a name="ln175">    return params_;</a>
<a name="ln176">  }</a>
<a name="ln177"> </a>
<a name="ln178">  std::shared_ptr&lt;QLType&gt; keys_type() const {</a>
<a name="ln179">    switch (id_) {</a>
<a name="ln180">      case MAP:</a>
<a name="ln181">        return params_[0];</a>
<a name="ln182">      case LIST:</a>
<a name="ln183">        return QLType::Create(INT32);</a>
<a name="ln184">      case SET:</a>
<a name="ln185">        // set has no keys, only values</a>
<a name="ln186">        return nullptr;</a>
<a name="ln187">      case TUPLE:</a>
<a name="ln188">        // https://github.com/YugaByte/yugabyte-db/issues/936</a>
<a name="ln189">        LOG(FATAL) &lt;&lt; &quot;Tuple type not implemented yet&quot;;</a>
<a name="ln190"> </a>
<a name="ln191">      default:</a>
<a name="ln192">        // elementary types have no keys or values</a>
<a name="ln193">        return nullptr;</a>
<a name="ln194">    }</a>
<a name="ln195">  }</a>
<a name="ln196"> </a>
<a name="ln197">  std::shared_ptr&lt;QLType&gt; values_type() const {</a>
<a name="ln198">    switch (id_) {</a>
<a name="ln199">      case MAP:</a>
<a name="ln200">        return params_[1];</a>
<a name="ln201">      case LIST:</a>
<a name="ln202">        return params_[0];</a>
<a name="ln203">      case SET:</a>
<a name="ln204">        return params_[0];</a>
<a name="ln205">      case TUPLE:</a>
<a name="ln206">        LOG(FATAL) &lt;&lt; &quot;Tuple type not implemented yet&quot;;</a>
<a name="ln207"> </a>
<a name="ln208">      default:</a>
<a name="ln209">        // other types have no keys or values</a>
<a name="ln210">        return nullptr;</a>
<a name="ln211">    }</a>
<a name="ln212">  }</a>
<a name="ln213"> </a>
<a name="ln214">  const QLType::SharedPtr&amp; param_type(int member_index = 0) const {</a>
<a name="ln215">    DCHECK_LT(member_index, params_.size());</a>
<a name="ln216">    return params_[member_index];</a>
<a name="ln217">  }</a>
<a name="ln218"> </a>
<a name="ln219">  const TypeInfo* type_info() const {</a>
<a name="ln220">    return GetTypeInfo(id_);</a>
<a name="ln221">  }</a>
<a name="ln222"> </a>
<a name="ln223">  //------------------------------------------------------------------------------------------------</a>
<a name="ln224">  // Methods for User-Defined types.</a>
<a name="ln225"> </a>
<a name="ln226">  const std::shared_ptr&lt;UDTypeInfo&gt;&amp; udtype_info() const {</a>
<a name="ln227">    return udtype_info_;</a>
<a name="ln228">  }</a>
<a name="ln229"> </a>
<a name="ln230">  const std::vector&lt;string&gt;&amp; udtype_field_names() const {</a>
<a name="ln231">    return udtype_info_-&gt;field_names();</a>
<a name="ln232">  }</a>
<a name="ln233"> </a>
<a name="ln234">  const std::string&amp; udtype_field_name(int index) const {</a>
<a name="ln235">    return udtype_info_-&gt;field_name(index);</a>
<a name="ln236">  }</a>
<a name="ln237"> </a>
<a name="ln238">  const std::string&amp; udtype_keyspace_name() const {</a>
<a name="ln239">    return udtype_info_-&gt;keyspace_name();</a>
<a name="ln240">  }</a>
<a name="ln241"> </a>
<a name="ln242">  const std::string&amp; udtype_name() const {</a>
<a name="ln243">    return udtype_info_-&gt;name();</a>
<a name="ln244">  }</a>
<a name="ln245"> </a>
<a name="ln246">  const std::string&amp; udtype_id() const {</a>
<a name="ln247">    return udtype_info_-&gt;id();</a>
<a name="ln248">  }</a>
<a name="ln249"> </a>
<a name="ln250">  void SetUDTypeFields(const std::string &amp;type_id,</a>
<a name="ln251">                       const std::vector&lt;std::string&gt; &amp;field_names,</a>
<a name="ln252">                       const std::vector&lt;std::shared_ptr&lt;QLType&gt;&gt; &amp;field_types) {</a>
<a name="ln253">    udtype_info_-&gt;set_udt_fields(type_id, field_names);</a>
<a name="ln254">    params_ = field_types;</a>
<a name="ln255">  }</a>
<a name="ln256"> </a>
<a name="ln257">  // returns position of &quot;field_name&quot; in udtype_field_names() vector if found, otherwise -1</a>
<a name="ln258">  const int GetUDTypeFieldIdxByName(const std::string &amp;field_name) const {</a>
<a name="ln259">    const std::vector&lt;string&gt;&amp; field_names = udtype_field_names();</a>
<a name="ln260">    int i = 0;</a>
<a name="ln261">    while (i != field_names.size()) {</a>
<a name="ln262">      if (field_names[i] == field_name) return i;</a>
<a name="ln263">      i++;</a>
<a name="ln264">    }</a>
<a name="ln265">    return -1;</a>
<a name="ln266">  }</a>
<a name="ln267"> </a>
<a name="ln268">  // Get the type ids of all UDTs (transitively) referenced by this UDT.</a>
<a name="ln269">  std::vector&lt;std::string&gt; GetUserDefinedTypeIds() const {</a>
<a name="ln270">    std::vector&lt;std::string&gt; udt_ids;</a>
<a name="ln271">    GetUserDefinedTypeIds(&amp;udt_ids);</a>
<a name="ln272">    return udt_ids;</a>
<a name="ln273">  }</a>
<a name="ln274"> </a>
<a name="ln275">  void GetUserDefinedTypeIds(std::vector&lt;std::string&gt;* udt_ids) const {</a>
<a name="ln276">    if (IsUserDefined()) {</a>
<a name="ln277">      udt_ids-&gt;push_back(udtype_info_-&gt;id());</a>
<a name="ln278">    }</a>
<a name="ln279">    for (auto&amp; param : params_) {</a>
<a name="ln280">      param-&gt;GetUserDefinedTypeIds(udt_ids);</a>
<a name="ln281">    }</a>
<a name="ln282">  }</a>
<a name="ln283"> </a>
<a name="ln284">  // Get the type ids of all UDTs referenced by this UDT.</a>
<a name="ln285">  static void GetUserDefinedTypeIds(const QLTypePB&amp; type_pb,</a>
<a name="ln286">                                    const bool transitive,</a>
<a name="ln287">                                    std::vector&lt;std::string&gt;* udt_ids) {</a>
<a name="ln288">    if (type_pb.main() == USER_DEFINED_TYPE) {</a>
<a name="ln289">      udt_ids-&gt;push_back(type_pb.udtype_info().id());</a>
<a name="ln290">      if (!transitive) {</a>
<a name="ln291">        return; // Do not check params of the UDT if only looking for direct dependencies.</a>
<a name="ln292">      }</a>
<a name="ln293">    }</a>
<a name="ln294"> </a>
<a name="ln295">    for (const auto&amp; param : type_pb.params()) {</a>
<a name="ln296">      GetUserDefinedTypeIds(param, transitive, udt_ids);</a>
<a name="ln297">    }</a>
<a name="ln298">  }</a>
<a name="ln299"> </a>
<a name="ln300">  // Returns the type of given field, or nullptr if that field is not found in this UDT.R</a>
<a name="ln301">  Result&lt;QLType::SharedPtr&gt; GetUDTFieldTypeByName(const std::string&amp; field_name) const {</a>
<a name="ln302">    SCHECK(IsUserDefined(), InternalError, &quot;Can only be called on UDT&quot;);</a>
<a name="ln303">    const int idx = GetUDTypeFieldIdxByName(field_name);</a>
<a name="ln304">    if (idx == -1) {</a>
<a name="ln305">      return nullptr;</a>
<a name="ln306">    }</a>
<a name="ln307">    return param_type(idx);</a>
<a name="ln308">  }</a>
<a name="ln309"> </a>
<a name="ln310">  //------------------------------------------------------------------------------------------------</a>
<a name="ln311">  // Predicates.</a>
<a name="ln312"> </a>
<a name="ln313">  bool IsCollection() const {</a>
<a name="ln314">    return id_ == MAP || id_ == SET || id_ == LIST || id_ == TUPLE;</a>
<a name="ln315">  }</a>
<a name="ln316"> </a>
<a name="ln317">  bool IsUserDefined() const {</a>
<a name="ln318">    return id_ == USER_DEFINED_TYPE;</a>
<a name="ln319">  }</a>
<a name="ln320"> </a>
<a name="ln321">  bool IsFrozen() const {</a>
<a name="ln322">    return id_ == FROZEN;</a>
<a name="ln323">  }</a>
<a name="ln324"> </a>
<a name="ln325">  bool IsParametric() const {</a>
<a name="ln326">    return IsCollection() || IsUserDefined() || IsFrozen();</a>
<a name="ln327">  }</a>
<a name="ln328"> </a>
<a name="ln329">  bool IsElementary() const {</a>
<a name="ln330">    return !IsParametric();</a>
<a name="ln331">  }</a>
<a name="ln332"> </a>
<a name="ln333">  // Collections and UDT values are stored as complex objects internally, unlike Elementary and</a>
<a name="ln334">  // Frozen types which are stored as single values.</a>
<a name="ln335">  bool HasComplexValues() const {</a>
<a name="ln336">    return IsCollection() || IsUserDefined();</a>
<a name="ln337">  }</a>
<a name="ln338"> </a>
<a name="ln339">  bool IsUnknown() const {</a>
<a name="ln340">    return IsUnknown(id_);</a>
<a name="ln341">  }</a>
<a name="ln342"> </a>
<a name="ln343">  bool IsAnyType() const {</a>
<a name="ln344">    return IsNull(id_);</a>
<a name="ln345">  }</a>
<a name="ln346"> </a>
<a name="ln347">  bool IsInteger() const {</a>
<a name="ln348">    return IsInteger(id_);</a>
<a name="ln349">  }</a>
<a name="ln350"> </a>
<a name="ln351">  bool IsJson() const {</a>
<a name="ln352">    return IsJson(id_);</a>
<a name="ln353">  }</a>
<a name="ln354"> </a>
<a name="ln355">  bool IsNumeric() const {</a>
<a name="ln356">    return IsNumeric(id_);</a>
<a name="ln357">  }</a>
<a name="ln358"> </a>
<a name="ln359">  bool IsValid() const {</a>
<a name="ln360">    if (IsElementary()) {</a>
<a name="ln361">      return params_.empty();</a>
<a name="ln362">    } else {</a>
<a name="ln363">      // checking number of params</a>
<a name="ln364">      if (id_ == MAP &amp;&amp; params_.size() != 2) {</a>
<a name="ln365">        return false; // expect two type parameters for maps</a>
<a name="ln366">      } else if ((id_ == SET || id_ == LIST) &amp;&amp; params_.size() != 1) {</a>
<a name="ln367">        return false; // expect one type parameter for set and list</a>
<a name="ln368">      } else if (id_ == TUPLE &amp;&amp; params_.size() == 0) {</a>
<a name="ln369">        return false; // expect at least one type parameters for tuples</a>
<a name="ln370">      } else if (id_ == FROZEN &amp;&amp; params_.size() != 1) {</a>
<a name="ln371">        return false; // expect one type parameter for frozen</a>
<a name="ln372">      }</a>
<a name="ln373">      // recursively checking params</a>
<a name="ln374">      for (const auto &amp;param : params_) {</a>
<a name="ln375">        if (!param-&gt;IsValid()) return false;</a>
<a name="ln376">      }</a>
<a name="ln377">      return true;</a>
<a name="ln378">    }</a>
<a name="ln379">  }</a>
<a name="ln380"> </a>
<a name="ln381">  bool Contains(DataType id) const {</a>
<a name="ln382">    for (const std::shared_ptr&lt;QLType&gt;&amp; param : params_) {</a>
<a name="ln383">      if (param-&gt;Contains(id)) {</a>
<a name="ln384">        return true;</a>
<a name="ln385">      }</a>
<a name="ln386">    }</a>
<a name="ln387">    return id_ == id;</a>
<a name="ln388">  }</a>
<a name="ln389"> </a>
<a name="ln390">  bool operator ==(const QLType&amp; other) const {</a>
<a name="ln391">    if (IsUserDefined()) {</a>
<a name="ln392">      return other.IsUserDefined() &amp;&amp; udtype_id() == other.udtype_id();</a>
<a name="ln393">    }</a>
<a name="ln394">    if (id_ == other.id_ &amp;&amp; params_.size() == other.params_.size()) {</a>
<a name="ln395">      for (int i = 0; i &lt; params_.size(); i++) {</a>
<a name="ln396">        if (*params_[i] == *other.params_[i]) {</a>
<a name="ln397">          continue;</a>
<a name="ln398">        }</a>
<a name="ln399">        return false;</a>
<a name="ln400">      }</a>
<a name="ln401">      return true;</a>
<a name="ln402">    }</a>
<a name="ln403"> </a>
<a name="ln404">    return false;</a>
<a name="ln405">  }</a>
<a name="ln406"> </a>
<a name="ln407">  bool operator !=(const QLType&amp; other) const {</a>
<a name="ln408">    return !(*this == other);</a>
<a name="ln409">  }</a>
<a name="ln410"> </a>
<a name="ln411">  //------------------------------------------------------------------------------------------------</a>
<a name="ln412">  // Logging supports.</a>
<a name="ln413">  const std::string ToString() const;</a>
<a name="ln414">  void ToString(std::stringstream&amp; os) const;</a>
<a name="ln415">  static const std::string ToCQLString(const DataType&amp; datatype);</a>
<a name="ln416"> </a>
<a name="ln417">  //------------------------------------------------------------------------------------------------</a>
<a name="ln418">  // static methods</a>
<a name="ln419">  static const int kMaxTypeIndex = DataType::JSONB + 1;</a>
<a name="ln420"> </a>
<a name="ln421">  // When a new type is added in the enum &quot;DataType&quot;, kMaxTypeIndex should be updated for this</a>
<a name="ln422">  // module to work properly. The DCHECKs in this struct would failed if kMaxTypeIndex is wrong.</a>
<a name="ln423">  static bool IsValid(DataType type) {</a>
<a name="ln424">    return (type &gt;= 0 &amp;&amp; type &lt; kMaxTypeIndex);</a>
<a name="ln425">  }</a>
<a name="ln426"> </a>
<a name="ln427">  static bool IsInteger(DataType t) {</a>
<a name="ln428">    return (t &gt;= INT8 &amp;&amp; t &lt;= INT64) || t == VARINT;</a>
<a name="ln429">  }</a>
<a name="ln430"> </a>
<a name="ln431">  static bool IsJson(DataType t) {</a>
<a name="ln432">    return t == JSONB;</a>
<a name="ln433">  }</a>
<a name="ln434"> </a>
<a name="ln435">  static bool IsNumeric(DataType t) {</a>
<a name="ln436">    return IsInteger(t) || t == FLOAT || t == DOUBLE || t == DECIMAL;</a>
<a name="ln437">  }</a>
<a name="ln438"> </a>
<a name="ln439">  // NULL_VALUE_TYPE represents type of a null value.</a>
<a name="ln440">  static bool IsNull(DataType t) {</a>
<a name="ln441">    return t == NULL_VALUE_TYPE;</a>
<a name="ln442">  }</a>
<a name="ln443"> </a>
<a name="ln444">  // Type is not yet set (VOID).</a>
<a name="ln445">  static bool IsUnknown(DataType t) {</a>
<a name="ln446">    return t == DataType::UNKNOWN_DATA;</a>
<a name="ln447">  }</a>
<a name="ln448"> </a>
<a name="ln449">  // There are a few compatibility modes between different datatypes. We use these modes when it is</a>
<a name="ln450">  // necessary to convert a value from one type to another.</a>
<a name="ln451">  // * kIdentical: The same type (INT8 === INT8).</a>
<a name="ln452">  // * kSimilar: These types share the same logical representation even though they might be</a>
<a name="ln453">  //   represented or implemented differently.</a>
<a name="ln454">  //   - INT8, INT16, INT32, INT64, and VARINT are similar.</a>
<a name="ln455">  //   - DOUBLE and FLOAT are similar.</a>
<a name="ln456">  // * kImplicit: Values can be converted automatically between two different datatypes.</a>
<a name="ln457">  //   - All integer types are convertible to DOUBLE and FLOAT.</a>
<a name="ln458">  // * kExplicit: An explicit CAST must be used to trigger the conversion from one type to another.</a>
<a name="ln459">  //   - DOUBLE and FLOAT are not automatically convertible to integer types.</a>
<a name="ln460">  //   - Once we support &quot;cast&quot; operator, DOUBLE &amp; FLOAT can be explicitly casted to int types.</a>
<a name="ln461">  // * kNotAllowed: No conversion is allowed between two different datatypes.</a>
<a name="ln462">  enum class ConversionMode : int {</a>
<a name="ln463">    kIdentical = 0,</a>
<a name="ln464">    kSimilar = 1,</a>
<a name="ln465">    kImplicit = 2,</a>
<a name="ln466">    kFurtherCheck = 3,</a>
<a name="ln467">    kExplicit = 4,</a>
<a name="ln468">    kNotAllowed = 5,</a>
<a name="ln469">  };</a>
<a name="ln470"> </a>
<a name="ln471">  static ConversionMode GetConversionMode(DataType left, DataType right) {</a>
<a name="ln472">    DCHECK(IsValid(left) &amp;&amp; IsValid(right)) &lt;&lt; left &lt;&lt; &quot;, &quot; &lt;&lt; right;</a>
<a name="ln473"> </a>
<a name="ln474">    static const ConversionMode kID = ConversionMode::kIdentical;</a>
<a name="ln475">    static const ConversionMode kSI = ConversionMode::kSimilar;</a>
<a name="ln476">    static const ConversionMode kIM = ConversionMode::kImplicit;</a>
<a name="ln477">    static const ConversionMode kFC = ConversionMode::kFurtherCheck;</a>
<a name="ln478">    static const ConversionMode kEX = ConversionMode::kExplicit;</a>
<a name="ln479">    static const ConversionMode kNA = ConversionMode::kNotAllowed;</a>
<a name="ln480">    static const ConversionMode kConversionMode[kMaxTypeIndex][kMaxTypeIndex] = {</a>
<a name="ln481">        // LHS :=  RHS (source)</a>
<a name="ln482">        //         nul | i8  | i16 | i32 | i64 | str | bln | flt | dbl | bin | tst | dec | vit | ine | lst | map | set | uid | tui | tup | arg | udt | frz | dat | tim | jso</a>
<a name="ln483">        /* nul */{ kID,  kIM,  kIM,  kIM,  kIM,  kIM,  kIM,  kIM,  kIM,  kIM,  kIM,  kIM,  kIM,  kIM,  kIM,  kIM,  kIM,  kIM,  kIM,  kIM,  kIM,  kIM,  kIM,  kIM,  kIM,  kIM },</a>
<a name="ln484">        /* i8 */ { kIM,  kID,  kSI,  kSI,  kSI,  kNA,  kNA,  kEX,  kEX,  kNA,  kNA,  kEX,  kSI,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA },</a>
<a name="ln485">        /* i16 */{ kIM,  kSI,  kID,  kSI,  kSI,  kNA,  kNA,  kEX,  kEX,  kNA,  kNA,  kEX,  kSI,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA },</a>
<a name="ln486">        /* i32 */{ kIM,  kSI,  kSI,  kID,  kSI,  kNA,  kNA,  kEX,  kEX,  kNA,  kNA,  kEX,  kSI,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA },</a>
<a name="ln487">        /* i64 */{ kIM,  kSI,  kSI,  kSI,  kID,  kNA,  kNA,  kEX,  kEX,  kNA,  kEX,  kEX,  kSI,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kEX,  kEX,  kNA },</a>
<a name="ln488">        /* str */{ kIM,  kEX,  kEX,  kEX,  kEX,  kID,  kEX,  kEX,  kEX,  kEX,  kEX,  kEX,  kNA,  kEX,  kNA,  kNA,  kNA,  kEX,  kEX,  kNA,  kNA,  kNA,  kNA,  kEX,  kEX,  kEX },</a>
<a name="ln489">        /* bln */{ kIM,  kNA,  kNA,  kNA,  kNA,  kNA,  kID,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA },</a>
<a name="ln490">        /* flt */{ kIM,  kIM,  kIM,  kIM,  kIM,  kNA,  kNA,  kID,  kSI,  kNA,  kNA,  kSI,  kIM,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA },</a>
<a name="ln491">        /* dbl */{ kIM,  kIM,  kIM,  kIM,  kIM,  kNA,  kNA,  kSI,  kID,  kNA,  kNA,  kSI,  kIM,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA },</a>
<a name="ln492">        /* bin */{ kIM,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kID,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA },</a>
<a name="ln493">        /* tst */{ kIM,  kNA,  kNA,  kNA,  kIM,  kIM,  kNA,  kNA,  kNA,  kNA,  kID,  kNA,  kIM,  kNA,  kNA,  kNA,  kNA,  kNA,  kEX,  kNA,  kNA,  kNA,  kNA,  kIM,  kIM,  kNA },</a>
<a name="ln494">        /* dec */{ kIM,  kIM,  kIM,  kIM,  kIM,  kEX,  kNA,  kSI,  kSI,  kNA,  kEX,  kID,  kIM,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA },</a>
<a name="ln495">        /* vit */{ kIM,  kSI,  kSI,  kSI,  kSI,  kNA,  kNA,  kEX,  kEX,  kNA,  kEX,  kEX,  kID,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kEX,  kEX,  kNA },</a>
<a name="ln496">        /* ine */{ kIM,  kNA,  kNA,  kNA,  kNA,  kIM,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kID,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA },</a>
<a name="ln497">        /* lst */{ kIM,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kFC,  kNA,  kNA,  kNA,  kNA,  kFC,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA },</a>
<a name="ln498">        /* map */{ kIM,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kFC,  kFC,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA },</a>
<a name="ln499">        /* set */{ kIM,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kFC,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA },</a>
<a name="ln500">        /* uid */{ kIM,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kID,  kIM,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA },</a>
<a name="ln501">        /* tui */{ kIM,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kIM,  kID,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA },</a>
<a name="ln502">        /* tup */{ kIM,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kFC,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA },</a>
<a name="ln503">        /* arg */{ kIM,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kID,  kNA,  kNA,  kNA,  kNA,  kNA },</a>
<a name="ln504">        /* udt */{ kIM,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kFC,  kNA,  kNA,  kNA,  kNA,  kNA,  kFC,  kNA,  kNA,  kNA,  kNA },</a>
<a name="ln505">        /* frz */{ kIM,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kFC,  kFC,  kFC,  kNA,  kNA,  kFC,  kNA,  kFC,  kFC,  kNA,  kNA,  kNA },</a>
<a name="ln506">        /* dat */{ kIM,  kNA,  kNA,  kNA,  kIM,  kIM,  kNA,  kNA,  kNA,  kNA,  kIM,  kNA,  kIM,  kNA,  kNA,  kNA,  kNA,  kNA,  kEX,  kNA,  kNA,  kNA,  kNA,  kID,  kNA,  kNA },</a>
<a name="ln507">        /* tim */{ kIM,  kNA,  kNA,  kNA,  kIM,  kIM,  kNA,  kNA,  kNA,  kNA,  kIM,  kNA,  kIM,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kID,  kNA },</a>
<a name="ln508">        /* jso */{ kNA,  kNA,  kNA,  kNA,  kNA,  kIM,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kNA,  kID },</a>
<a name="ln509">    };</a>
<a name="ln510">    return kConversionMode[left][right];</a>
<a name="ln511">  }</a>
<a name="ln512"> </a>
<a name="ln513">  static bool IsIdentical(DataType left, DataType right) {</a>
<a name="ln514">    return GetConversionMode(left, right) == ConversionMode::kIdentical;</a>
<a name="ln515">  }</a>
<a name="ln516"> </a>
<a name="ln517">  static bool IsSimilar(DataType left, DataType right) {</a>
<a name="ln518">    return GetConversionMode(left, right) &lt;= ConversionMode::kSimilar;</a>
<a name="ln519">  }</a>
<a name="ln520"> </a>
<a name="ln521">  static bool IsImplicitlyConvertible(DataType left, DataType right) {</a>
<a name="ln522">    return GetConversionMode(left, right) &lt;= ConversionMode::kImplicit;</a>
<a name="ln523">  }</a>
<a name="ln524"> </a>
<a name="ln525">  static bool IsPotentiallyConvertible(DataType left, DataType right) {</a>
<a name="ln526">    return GetConversionMode(left, right) &lt;= ConversionMode::kFurtherCheck;</a>
<a name="ln527">  }</a>
<a name="ln528"> </a>
<a name="ln529">  static bool IsExplicitlyConvertible(DataType left, DataType right) {</a>
<a name="ln530">    return GetConversionMode(left, right) &lt;= ConversionMode::kExplicit;</a>
<a name="ln531">  }</a>
<a name="ln532"> </a>
<a name="ln533">  static bool IsImplicitlyConvertible(const std::shared_ptr&lt;QLType&gt;&amp; lhs_type,</a>
<a name="ln534">                                      const std::shared_ptr&lt;QLType&gt;&amp; rhs_type) {</a>
<a name="ln535">    switch (QLType::GetConversionMode(lhs_type-&gt;main(), rhs_type-&gt;main())) {</a>
<a name="ln536">      case QLType::ConversionMode::kIdentical: FALLTHROUGH_INTENDED;</a>
<a name="ln537">      case QLType::ConversionMode::kSimilar: FALLTHROUGH_INTENDED;</a>
<a name="ln538">      case QLType::ConversionMode::kImplicit:</a>
<a name="ln539">        return true;</a>
<a name="ln540"> </a>
<a name="ln541">      case QLType::ConversionMode::kFurtherCheck:</a>
<a name="ln542">        // checking params convertibility</a>
<a name="ln543">        if (lhs_type-&gt;params().size() != rhs_type-&gt;params().size()) {</a>
<a name="ln544">          return false;</a>
<a name="ln545">        }</a>
<a name="ln546">        for (int i = 0; i &lt; lhs_type-&gt;params().size(); i++) {</a>
<a name="ln547">          if (!IsImplicitlyConvertible(lhs_type-&gt;params().at(i), rhs_type-&gt;params().at(i))) {</a>
<a name="ln548">            return false;</a>
<a name="ln549">          }</a>
<a name="ln550">        }</a>
<a name="ln551">        return true;</a>
<a name="ln552"> </a>
<a name="ln553">      case QLType::ConversionMode::kExplicit: FALLTHROUGH_INTENDED;</a>
<a name="ln554">      case QLType::ConversionMode::kNotAllowed:</a>
<a name="ln555">        return false;</a>
<a name="ln556">    }</a>
<a name="ln557"> </a>
<a name="ln558">    LOG(FATAL) &lt;&lt; &quot;Unsupported conversion mode in switch statement&quot;;</a>
<a name="ln559">    return false;</a>
<a name="ln560">  }</a>
<a name="ln561"> </a>
<a name="ln562">  static bool IsComparable(DataType left, DataType right) {</a>
<a name="ln563">    DCHECK(IsValid(left) &amp;&amp; IsValid(right)) &lt;&lt; left &lt;&lt; &quot;, &quot; &lt;&lt; right;</a>
<a name="ln564"> </a>
<a name="ln565">    static const bool kYS = true;</a>
<a name="ln566">    static const bool kNO = false;</a>
<a name="ln567">    static const bool kCompareMode[kMaxTypeIndex][kMaxTypeIndex] = {</a>
<a name="ln568">        // LHS ==  RHS (source)</a>
<a name="ln569">        //         nul | i8  | i16 | i32 | i64 | str | bln | flt | dbl | bin | tst | dec | vit | ine | lst | map | set | uid | tui | tup | arg | udt | frz | dat | tim | jso</a>
<a name="ln570">        /* nul */{ kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO },</a>
<a name="ln571">        /* i8  */{ kNO,  kYS,  kYS,  kYS,  kYS,  kNO,  kNO,  kYS,  kYS,  kNO,  kNO,  kNO,  kYS,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO },</a>
<a name="ln572">        /* i16 */{ kNO,  kYS,  kYS,  kYS,  kYS,  kNO,  kNO,  kYS,  kYS,  kNO,  kNO,  kNO,  kYS,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO },</a>
<a name="ln573">        /* i32 */{ kNO,  kYS,  kYS,  kYS,  kYS,  kNO,  kNO,  kYS,  kYS,  kNO,  kNO,  kNO,  kYS,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO },</a>
<a name="ln574">        /* i64 */{ kNO,  kYS,  kYS,  kYS,  kYS,  kNO,  kNO,  kYS,  kYS,  kNO,  kNO,  kNO,  kYS,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO },</a>
<a name="ln575">        /* str */{ kNO,  kNO,  kNO,  kNO,  kNO,  kYS,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO },</a>
<a name="ln576">        /* bln */{ kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kYS,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO },</a>
<a name="ln577">        /* flt */{ kNO,  kYS,  kYS,  kYS,  kYS,  kNO,  kNO,  kYS,  kYS,  kNO,  kNO,  kYS,  kYS,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO },</a>
<a name="ln578">        /* dbl */{ kNO,  kYS,  kYS,  kYS,  kYS,  kNO,  kNO,  kYS,  kYS,  kNO,  kNO,  kYS,  kYS,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO },</a>
<a name="ln579">        /* bin */{ kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kYS,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO },</a>
<a name="ln580">        /* tst */{ kNO,  kNO,  kNO,  kNO,  kYS,  kYS,  kNO,  kNO,  kNO,  kNO,  kYS,  kNO,  kYS,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kYS,  kYS,  kNO },</a>
<a name="ln581">        /* dec */{ kNO,  kYS,  kYS,  kYS,  kYS,  kNO,  kNO,  kYS,  kYS,  kNO,  kNO,  kYS,  kYS,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO },</a>
<a name="ln582">        /* vit */{ kNO,  kYS,  kYS,  kYS,  kYS,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kYS,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO },</a>
<a name="ln583">        /* ine */{ kNO,  kNO,  kNO,  kNO,  kNO,  kYS,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kYS,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO },</a>
<a name="ln584">        /* lst */{ kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO },</a>
<a name="ln585">        /* map */{ kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO },</a>
<a name="ln586">        /* set */{ kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO },</a>
<a name="ln587">        /* uid */{ kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kYS,  kYS,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO },</a>
<a name="ln588">        /* tui */{ kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kYS,  kYS,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO },</a>
<a name="ln589">        /* tup */{ kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO },</a>
<a name="ln590">        /* arg */{ kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO },</a>
<a name="ln591">        /* udt */{ kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO },</a>
<a name="ln592">        /* frz */{ kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kYS,  kNO,  kNO,  kNO },</a>
<a name="ln593">        /* dat */{ kNO,  kNO,  kNO,  kNO,  kYS,  kYS,  kNO,  kNO,  kNO,  kNO,  kYS,  kNO,  kYS,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kYS,  kYS,  kNO },</a>
<a name="ln594">        /* tim */{ kNO,  kNO,  kNO,  kNO,  kYS,  kYS,  kNO,  kNO,  kNO,  kNO,  kYS,  kNO,  kYS,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kYS,  kYS,  kNO },</a>
<a name="ln595">        /* jso */{ kNO,  kNO,  kNO,  kNO,  kNO,  kYS,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kNO,  kYS },</a>
<a name="ln596">    };</a>
<a name="ln597">    return kCompareMode[left][right];</a>
<a name="ln598">  }</a>
<a name="ln599"> </a>
<a name="ln600"> private:</a>
<a name="ln601">  //------------------------------------------------------------------------------------------------</a>
<a name="ln602">  // Data members.</a>
<a name="ln603">  DataType id_;</a>
<a name="ln604">  std::vector&lt;std::shared_ptr&lt;QLType&gt;&gt; params_;</a>
<a name="ln605"> </a>
<a name="ln606">  // Members for User-Defined Types</a>
<a name="ln607">  std::shared_ptr&lt;UDTypeInfo&gt; udtype_info_ = nullptr; // default</a>
<a name="ln608">};</a>
<a name="ln609"> </a>
<a name="ln610"> </a>
<a name="ln611">}; // namespace yb</a>
<a name="ln612"> </a>
<a name="ln613">#endif  // YB_COMMON_QL_TYPE_H_</a>

</code></pre>
<div class="balloon" rel="424"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1016/" target="_blank">V1016</a> Expression 'type >= 0' is always true.</p></div>
<div class="balloon" rel="472"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="563"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
