
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>dhp.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Copyright (c) 2006-2018 Maxim Khizhinsky</a>
<a name="ln2">//</a>
<a name="ln3">// Distributed under the Boost Software License, Version 1.0. (See accompanying</a>
<a name="ln4">// file LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)</a>
<a name="ln5"> </a>
<a name="ln6">#ifndef CDSLIB_GC_DHP_SMR_H</a>
<a name="ln7">#define CDSLIB_GC_DHP_SMR_H</a>
<a name="ln8"> </a>
<a name="ln9">#include &lt;exception&gt;</a>
<a name="ln10">#include &lt;cds/gc/details/hp_common.h&gt;</a>
<a name="ln11">#include &lt;cds/threading/model.h&gt;</a>
<a name="ln12">#include &lt;cds/intrusive/free_list_selector.h&gt;</a>
<a name="ln13">#include &lt;cds/details/throw_exception.h&gt;</a>
<a name="ln14">#include &lt;cds/details/marked_ptr.h&gt;</a>
<a name="ln15">#include &lt;cds/user_setup/cache_line.h&gt;</a>
<a name="ln16"> </a>
<a name="ln17">namespace cds { namespace gc {</a>
<a name="ln18"> </a>
<a name="ln19">    /// Dynamic (adaptive) Hazard Pointer implementation details</a>
<a name="ln20">    namespace dhp {</a>
<a name="ln21">        using namespace cds::gc::hp::common;</a>
<a name="ln22"> </a>
<a name="ln23">        /// Exception &quot;Dynamic Hazard Pointer SMR is not initialized&quot;</a>
<a name="ln24">        class not_initialized: public std::runtime_error</a>
<a name="ln25">        {</a>
<a name="ln26">        public:</a>
<a name="ln27">            //@cond</a>
<a name="ln28">            not_initialized()</a>
<a name="ln29">                : std::runtime_error( &quot;Global DHP SMR object is not initialized&quot; )</a>
<a name="ln30">            {}</a>
<a name="ln31">            //@endcond</a>
<a name="ln32">        };</a>
<a name="ln33"> </a>
<a name="ln34">        //@cond</a>
<a name="ln35">        struct guard_block: public cds::intrusive::FreeListImpl::node</a>
<a name="ln36">        {</a>
<a name="ln37">            guard_block*  next_block_ = nullptr;  // next block in the thread list</a>
<a name="ln38"> </a>
<a name="ln39">            guard* first()</a>
<a name="ln40">            {</a>
<a name="ln41">                return reinterpret_cast&lt;guard*&gt;( this + 1 );</a>
<a name="ln42">            }</a>
<a name="ln43">        };</a>
<a name="ln44">        //@endcond</a>
<a name="ln45"> </a>
<a name="ln46">        //@cond</a>
<a name="ln47">        /// \p guard_block allocator (global object)</a>
<a name="ln48">        class hp_allocator</a>
<a name="ln49">        {</a>
<a name="ln50">            friend class smr;</a>
<a name="ln51">        public:</a>
<a name="ln52">            static hp_allocator&amp; instance();</a>
<a name="ln53"> </a>
<a name="ln54">            CDS_EXPORT_API guard_block* alloc();</a>
<a name="ln55">            void free( guard_block* block )</a>
<a name="ln56">            {</a>
<a name="ln57">                free_list_.put( block );</a>
<a name="ln58">            }</a>
<a name="ln59"> </a>
<a name="ln60">        private:</a>
<a name="ln61">            hp_allocator()</a>
<a name="ln62">#ifdef CDS_ENABLE_HPSTAT</a>
<a name="ln63">                : block_allocated_(0)</a>
<a name="ln64">#endif</a>
<a name="ln65">            {}</a>
<a name="ln66">            CDS_EXPORT_API ~hp_allocator();</a>
<a name="ln67"> </a>
<a name="ln68">        private:</a>
<a name="ln69">            cds::intrusive::FreeListImpl    free_list_; ///&lt; list of free \p guard_block</a>
<a name="ln70">#ifdef CDS_ENABLE_HPSTAT</a>
<a name="ln71">        public:</a>
<a name="ln72">            atomics::atomic&lt;size_t&gt;         block_allocated_;   ///&lt; count of allocated blocks</a>
<a name="ln73">#endif</a>
<a name="ln74">        };</a>
<a name="ln75">        //@endcond</a>
<a name="ln76"> </a>
<a name="ln77">        //@cond</a>
<a name="ln78">        /// Per-thread hazard pointer storage</a>
<a name="ln79">        class thread_hp_storage</a>
<a name="ln80">        {</a>
<a name="ln81">            friend class smr;</a>
<a name="ln82">        public:</a>
<a name="ln83">            thread_hp_storage( guard* arr, size_t nSize ) noexcept</a>
<a name="ln84">                : free_head_( arr )</a>
<a name="ln85">                , array_( arr )</a>
<a name="ln86">                , initial_capacity_( nSize )</a>
<a name="ln87">#       ifdef CDS_ENABLE_HPSTAT</a>
<a name="ln88">                , alloc_guard_count_( 0 )</a>
<a name="ln89">                , free_guard_count_( 0 )</a>
<a name="ln90">                , extend_call_count_( 0 )</a>
<a name="ln91">#       endif</a>
<a name="ln92">            {</a>
<a name="ln93">                // Initialize guards</a>
<a name="ln94">                new( arr ) guard[nSize];</a>
<a name="ln95">                extended_list_.store( nullptr, atomics::memory_order_release );</a>
<a name="ln96">            }</a>
<a name="ln97"> </a>
<a name="ln98">            thread_hp_storage() = delete;</a>
<a name="ln99">            thread_hp_storage( thread_hp_storage const&amp; ) = delete;</a>
<a name="ln100">            thread_hp_storage( thread_hp_storage&amp;&amp; ) = delete;</a>
<a name="ln101"> </a>
<a name="ln102">            ~thread_hp_storage()</a>
<a name="ln103">            {</a>
<a name="ln104">                clear();</a>
<a name="ln105">            }</a>
<a name="ln106"> </a>
<a name="ln107">            guard* alloc()</a>
<a name="ln108">            {</a>
<a name="ln109">                if ( cds_unlikely( free_head_ == nullptr )) {</a>
<a name="ln110">                    extend();</a>
<a name="ln111">                    assert( free_head_ != nullptr );</a>
<a name="ln112">                }</a>
<a name="ln113"> </a>
<a name="ln114">                guard* g = free_head_;</a>
<a name="ln115">                free_head_ = g-&gt;next_;</a>
<a name="ln116">                CDS_HPSTAT( ++alloc_guard_count_ );</a>
<a name="ln117">                return g;</a>
<a name="ln118">            }</a>
<a name="ln119"> </a>
<a name="ln120">            void free( guard* g ) noexcept</a>
<a name="ln121">            {</a>
<a name="ln122">                if ( g ) {</a>
<a name="ln123">                    g-&gt;clear();</a>
<a name="ln124">                    g-&gt;next_ = free_head_;</a>
<a name="ln125">                    free_head_ = g;</a>
<a name="ln126">                    CDS_HPSTAT( ++free_guard_count_ );</a>
<a name="ln127">                }</a>
<a name="ln128">            }</a>
<a name="ln129"> </a>
<a name="ln130">            template&lt; size_t Capacity&gt;</a>
<a name="ln131">            size_t alloc( guard_array&lt;Capacity&gt;&amp; arr )</a>
<a name="ln132">            {</a>
<a name="ln133">                for ( size_t i = 0; i &lt; Capacity; ++i ) {</a>
<a name="ln134">                    if ( cds_unlikely( free_head_ == nullptr ))</a>
<a name="ln135">                        extend();</a>
<a name="ln136">                    arr.reset( i, free_head_ );</a>
<a name="ln137">                    free_head_ = free_head_-&gt;next_;</a>
<a name="ln138">                }</a>
<a name="ln139">                CDS_HPSTAT( alloc_guard_count_ += Capacity );</a>
<a name="ln140">                return Capacity;</a>
<a name="ln141">            }</a>
<a name="ln142"> </a>
<a name="ln143">            template &lt;size_t Capacity&gt;</a>
<a name="ln144">            void free( guard_array&lt;Capacity&gt;&amp; arr ) noexcept</a>
<a name="ln145">            {</a>
<a name="ln146">                guard* gList = free_head_;</a>
<a name="ln147">                for ( size_t i = 0; i &lt; Capacity; ++i ) {</a>
<a name="ln148">                    guard* g = arr[i];</a>
<a name="ln149">                    if ( g ) {</a>
<a name="ln150">                        g-&gt;clear();</a>
<a name="ln151">                        g-&gt;next_ = gList;</a>
<a name="ln152">                        gList = g;</a>
<a name="ln153">                        CDS_HPSTAT( ++free_guard_count_ );</a>
<a name="ln154">                    }</a>
<a name="ln155">                }</a>
<a name="ln156">                free_head_ = gList;</a>
<a name="ln157">            }</a>
<a name="ln158"> </a>
<a name="ln159">            void clear()</a>
<a name="ln160">            {</a>
<a name="ln161">                // clear array_</a>
<a name="ln162">                for ( guard* cur = array_, *last = array_ + initial_capacity_; cur &lt; last; ++cur )</a>
<a name="ln163">                    cur-&gt;clear();</a>
<a name="ln164"> </a>
<a name="ln165">                // free all extended blocks</a>
<a name="ln166">                hp_allocator&amp; a = hp_allocator::instance();</a>
<a name="ln167">                for ( guard_block* p = extended_list_.load( atomics::memory_order_relaxed ); p; ) {</a>
<a name="ln168">                    guard_block* next = p-&gt;next_block_;</a>
<a name="ln169">                    a.free( p );</a>
<a name="ln170">                    p = next;</a>
<a name="ln171">                }</a>
<a name="ln172"> </a>
<a name="ln173">                extended_list_.store( nullptr, atomics::memory_order_release );</a>
<a name="ln174">            }</a>
<a name="ln175"> </a>
<a name="ln176">            void init()</a>
<a name="ln177">            {</a>
<a name="ln178">                assert( extended_list_.load(atomics::memory_order_relaxed) == nullptr );</a>
<a name="ln179"> </a>
<a name="ln180">                guard* p = array_;</a>
<a name="ln181">                for ( guard* pEnd = p + initial_capacity_ - 1; p != pEnd; ++p )</a>
<a name="ln182">                    p-&gt;next_ = p + 1;</a>
<a name="ln183">                p-&gt;next_ = nullptr;</a>
<a name="ln184">                free_head_ = array_;</a>
<a name="ln185">            }</a>
<a name="ln186"> </a>
<a name="ln187">        private:</a>
<a name="ln188">            void extend()</a>
<a name="ln189">            {</a>
<a name="ln190">                assert( free_head_ == nullptr );</a>
<a name="ln191"> </a>
<a name="ln192">                guard_block* block = hp_allocator::instance().alloc();</a>
<a name="ln193">                block-&gt;next_block_ = extended_list_.load( atomics::memory_order_relaxed );</a>
<a name="ln194">                extended_list_.store( block, atomics::memory_order_release );</a>
<a name="ln195">                free_head_ = block-&gt;first();</a>
<a name="ln196">                CDS_HPSTAT( ++extend_call_count_ );</a>
<a name="ln197">            }</a>
<a name="ln198"> </a>
<a name="ln199">        private:</a>
<a name="ln200">            guard*          free_head_;        ///&lt; Head of free guard list</a>
<a name="ln201">            atomics::atomic&lt;guard_block*&gt; extended_list_;    ///&lt; Head of extended guard blocks allocated for the thread</a>
<a name="ln202">            guard* const    array_;            ///&lt; initial HP array</a>
<a name="ln203">            size_t const    initial_capacity_; ///&lt; Capacity of \p array_</a>
<a name="ln204">#       ifdef CDS_ENABLE_HPSTAT</a>
<a name="ln205">        public:</a>
<a name="ln206">            size_t          alloc_guard_count_;</a>
<a name="ln207">            size_t          free_guard_count_;</a>
<a name="ln208">            size_t          extend_call_count_;</a>
<a name="ln209">#       endif</a>
<a name="ln210">        };</a>
<a name="ln211">        //@endcond</a>
<a name="ln212"> </a>
<a name="ln213">        //@cond</a>
<a name="ln214">        struct retired_block: public cds::intrusive::FreeListImpl::node</a>
<a name="ln215">        {</a>
<a name="ln216">            retired_block*  next_;  ///&lt; Next block in thread-private retired array</a>
<a name="ln217"> </a>
<a name="ln218">            static size_t const c_capacity = 256;</a>
<a name="ln219"> </a>
<a name="ln220">            retired_block()</a>
<a name="ln221">                : next_( nullptr )</a>
<a name="ln222">            {}</a>
<a name="ln223"> </a>
<a name="ln224">            retired_ptr* first() const</a>
<a name="ln225">            {</a>
<a name="ln226">                return reinterpret_cast&lt;retired_ptr*&gt;( const_cast&lt;retired_block*&gt;( this ) + 1 );</a>
<a name="ln227">            }</a>
<a name="ln228"> </a>
<a name="ln229">            retired_ptr* last() const</a>
<a name="ln230">            {</a>
<a name="ln231">                return first() + c_capacity;</a>
<a name="ln232">            }</a>
<a name="ln233">        };</a>
<a name="ln234">        //@endcond</a>
<a name="ln235"> </a>
<a name="ln236">        //@cond</a>
<a name="ln237">        class retired_allocator</a>
<a name="ln238">        {</a>
<a name="ln239">            friend class smr;</a>
<a name="ln240">        public:</a>
<a name="ln241">            static retired_allocator&amp; instance();</a>
<a name="ln242"> </a>
<a name="ln243">            CDS_EXPORT_API retired_block* alloc();</a>
<a name="ln244">            void free( retired_block* block )</a>
<a name="ln245">            {</a>
<a name="ln246">                block-&gt;next_ = nullptr;</a>
<a name="ln247">                free_list_.put( block );</a>
<a name="ln248">            }</a>
<a name="ln249"> </a>
<a name="ln250">        private:</a>
<a name="ln251">            retired_allocator()</a>
<a name="ln252">#ifdef CDS_ENABLE_HPSTAT</a>
<a name="ln253">                : block_allocated_(0)</a>
<a name="ln254">#endif</a>
<a name="ln255">            {}</a>
<a name="ln256">            CDS_EXPORT_API ~retired_allocator();</a>
<a name="ln257"> </a>
<a name="ln258">        private:</a>
<a name="ln259">            cds::intrusive::FreeListImpl    free_list_; ///&lt; list of free \p guard_block</a>
<a name="ln260">#ifdef CDS_ENABLE_HPSTAT</a>
<a name="ln261">        public:</a>
<a name="ln262">            atomics::atomic&lt;size_t&gt; block_allocated_; ///&lt; Count of allocated blocks</a>
<a name="ln263">#endif</a>
<a name="ln264">        };</a>
<a name="ln265">        //@endcond</a>
<a name="ln266"> </a>
<a name="ln267">        //@cond</a>
<a name="ln268">        /// Per-thread retired array</a>
<a name="ln269">        class retired_array</a>
<a name="ln270">        {</a>
<a name="ln271">            friend class smr;</a>
<a name="ln272">        public:</a>
<a name="ln273">            retired_array() noexcept</a>
<a name="ln274">                : current_block_( nullptr )</a>
<a name="ln275">                , current_cell_( nullptr )</a>
<a name="ln276">                , list_head_( nullptr )</a>
<a name="ln277">                , list_tail_( nullptr )</a>
<a name="ln278">                , block_count_(0)</a>
<a name="ln279">#       ifdef CDS_ENABLE_HPSTAT</a>
<a name="ln280">                , retire_call_count_( 0 )</a>
<a name="ln281">                , extend_call_count_( 0 )</a>
<a name="ln282">#       endif</a>
<a name="ln283">            {}</a>
<a name="ln284"> </a>
<a name="ln285">            retired_array( retired_array const&amp; ) = delete;</a>
<a name="ln286">            retired_array( retired_array&amp;&amp; ) = delete;</a>
<a name="ln287"> </a>
<a name="ln288">            ~retired_array()</a>
<a name="ln289">            {</a>
<a name="ln290">                assert( empty());</a>
<a name="ln291">                fini();</a>
<a name="ln292">            }</a>
<a name="ln293"> </a>
<a name="ln294">            bool push( retired_ptr const&amp; p ) noexcept</a>
<a name="ln295">            {</a>
<a name="ln296">                assert( current_block_ != nullptr );</a>
<a name="ln297">                assert( current_block_-&gt;first() &lt;= current_cell_ );</a>
<a name="ln298">                assert( current_cell_ &lt; current_block_-&gt;last());</a>
<a name="ln299">                //assert( &amp;p != current_cell_ );</a>
<a name="ln300"> </a>
<a name="ln301">                *current_cell_ = p;</a>
<a name="ln302">                CDS_HPSTAT( ++retire_call_count_ );</a>
<a name="ln303"> </a>
<a name="ln304">                if ( ++current_cell_ == current_block_-&gt;last()) {</a>
<a name="ln305">                    // goto next block if exists</a>
<a name="ln306">                    if ( current_block_-&gt;next_ ) {</a>
<a name="ln307">                        current_block_ = current_block_-&gt;next_;</a>
<a name="ln308">                        current_cell_ = current_block_-&gt;first();</a>
<a name="ln309">                        return true;</a>
<a name="ln310">                    }</a>
<a name="ln311"> </a>
<a name="ln312">                    // no free block</a>
<a name="ln313">                    // smr::scan() extend retired_array if needed</a>
<a name="ln314">                    return false;</a>
<a name="ln315">                }</a>
<a name="ln316"> </a>
<a name="ln317">                return true;</a>
<a name="ln318">            }</a>
<a name="ln319"> </a>
<a name="ln320">            bool repush( retired_ptr* p ) noexcept</a>
<a name="ln321">            {</a>
<a name="ln322">                bool ret = push( *p );</a>
<a name="ln323">                CDS_HPSTAT( --retire_call_count_ );</a>
<a name="ln324">                assert( ret );</a>
<a name="ln325">                return ret;</a>
<a name="ln326">            }</a>
<a name="ln327"> </a>
<a name="ln328">        private: // called by smr</a>
<a name="ln329">            void init()</a>
<a name="ln330">            {</a>
<a name="ln331">                if ( list_head_ == nullptr ) {</a>
<a name="ln332">                    retired_block* block = retired_allocator::instance().alloc();</a>
<a name="ln333">                    assert( block-&gt;next_ == nullptr );</a>
<a name="ln334"> </a>
<a name="ln335">                    current_block_ =</a>
<a name="ln336">                        list_head_ =</a>
<a name="ln337">                        list_tail_ = block;</a>
<a name="ln338">                    current_cell_ = block-&gt;first();</a>
<a name="ln339"> </a>
<a name="ln340">                    block_count_ = 1;</a>
<a name="ln341">                }</a>
<a name="ln342">            }</a>
<a name="ln343"> </a>
<a name="ln344">            void fini()</a>
<a name="ln345">            {</a>
<a name="ln346">                retired_allocator&amp; alloc = retired_allocator::instance();</a>
<a name="ln347">                for ( retired_block* p = list_head_; p; ) {</a>
<a name="ln348">                    retired_block* next = p-&gt;next_;</a>
<a name="ln349">                    alloc.free( p );</a>
<a name="ln350">                    p = next;</a>
<a name="ln351">                }</a>
<a name="ln352"> </a>
<a name="ln353">                current_block_ =</a>
<a name="ln354">                    list_head_ =</a>
<a name="ln355">                    list_tail_ = nullptr;</a>
<a name="ln356">                current_cell_ = nullptr;</a>
<a name="ln357"> </a>
<a name="ln358">                block_count_ = 0;</a>
<a name="ln359">            }</a>
<a name="ln360"> </a>
<a name="ln361">            void extend()</a>
<a name="ln362">            {</a>
<a name="ln363">                assert( list_head_ != nullptr );</a>
<a name="ln364">                assert( current_block_ == list_tail_ );</a>
<a name="ln365">                assert( current_cell_ == current_block_-&gt;last());</a>
<a name="ln366"> </a>
<a name="ln367">                retired_block* block = retired_allocator::instance().alloc();</a>
<a name="ln368">                assert( block-&gt;next_ == nullptr );</a>
<a name="ln369"> </a>
<a name="ln370">                current_block_ = list_tail_ = list_tail_-&gt;next_ = block;</a>
<a name="ln371">                current_cell_ = block-&gt;first();</a>
<a name="ln372">                ++block_count_;</a>
<a name="ln373">                CDS_HPSTAT( ++extend_call_count_ );</a>
<a name="ln374">            }</a>
<a name="ln375"> </a>
<a name="ln376">            bool empty() const</a>
<a name="ln377">            {</a>
<a name="ln378">                return current_block_ == nullptr</a>
<a name="ln379">                    || ( current_block_ == list_head_ &amp;&amp; current_cell_ == current_block_-&gt;first());</a>
<a name="ln380">            }</a>
<a name="ln381"> </a>
<a name="ln382">        private:</a>
<a name="ln383">            retired_block*          current_block_;</a>
<a name="ln384">            retired_ptr*            current_cell_;  // in current_block_</a>
<a name="ln385"> </a>
<a name="ln386">            retired_block*          list_head_;</a>
<a name="ln387">            retired_block*          list_tail_;</a>
<a name="ln388">            size_t                  block_count_;</a>
<a name="ln389">#       ifdef CDS_ENABLE_HPSTAT</a>
<a name="ln390">        public:</a>
<a name="ln391">            size_t  retire_call_count_;</a>
<a name="ln392">            size_t  extend_call_count_;</a>
<a name="ln393">#       endif</a>
<a name="ln394">        };</a>
<a name="ln395">        //@endcond</a>
<a name="ln396"> </a>
<a name="ln397">        /// Internal statistics</a>
<a name="ln398">        struct stat {</a>
<a name="ln399">            size_t  guard_allocated;    ///&lt; Count of allocated HP guards</a>
<a name="ln400">            size_t  guard_freed;        ///&lt; Count of freed HP guards</a>
<a name="ln401">            size_t  retired_count;      ///&lt; Count of retired pointers</a>
<a name="ln402">            size_t  free_count;         ///&lt; Count of free pointers</a>
<a name="ln403">            size_t  scan_count;         ///&lt; Count of \p scan() call</a>
<a name="ln404">            size_t  help_scan_count;    ///&lt; Count of \p help_scan() call</a>
<a name="ln405"> </a>
<a name="ln406">            size_t  thread_rec_count;   ///&lt; Count of thread records</a>
<a name="ln407"> </a>
<a name="ln408">            size_t  hp_block_count;         ///&lt; Count of extended HP blocks allocated</a>
<a name="ln409">            size_t  retired_block_count;    ///&lt; Count of retired blocks allocated</a>
<a name="ln410">            size_t  hp_extend_count;        ///&lt; Count of hp array \p extend() call</a>
<a name="ln411">            size_t  retired_extend_count;   ///&lt; Count of retired array \p extend() call</a>
<a name="ln412"> </a>
<a name="ln413">                                        /// Default ctor</a>
<a name="ln414">            stat()</a>
<a name="ln415">            {</a>
<a name="ln416">                clear();</a>
<a name="ln417">            }</a>
<a name="ln418"> </a>
<a name="ln419">            /// Clears all counters</a>
<a name="ln420">            void clear()</a>
<a name="ln421">            {</a>
<a name="ln422">                guard_allocated =</a>
<a name="ln423">                    guard_freed =</a>
<a name="ln424">                    retired_count =</a>
<a name="ln425">                    free_count =</a>
<a name="ln426">                    scan_count =</a>
<a name="ln427">                    help_scan_count =</a>
<a name="ln428">                    thread_rec_count =</a>
<a name="ln429">                    hp_block_count =</a>
<a name="ln430">                    retired_block_count =</a>
<a name="ln431">                    hp_extend_count =</a>
<a name="ln432">                    retired_extend_count = 0;</a>
<a name="ln433">            }</a>
<a name="ln434">        };</a>
<a name="ln435"> </a>
<a name="ln436">        //@cond</a>
<a name="ln437">        /// Per-thread data</a>
<a name="ln438">        struct thread_data {</a>
<a name="ln439">            thread_hp_storage   hazards_;   ///&lt; Hazard pointers private to the thread</a>
<a name="ln440">            retired_array       retired_;   ///&lt; Retired data private to the thread</a>
<a name="ln441"> </a>
<a name="ln442">            char pad1_[cds::c_nCacheLineSize];</a>
<a name="ln443">            atomics::atomic&lt;unsigned int&gt; sync_; ///&lt; dummy var to introduce synchronizes-with relationship between threads</a>
<a name="ln444">            char pad2_[cds::c_nCacheLineSize];</a>
<a name="ln445"> </a>
<a name="ln446">#       ifdef CDS_ENABLE_HPSTAT</a>
<a name="ln447">            size_t              free_call_count_;</a>
<a name="ln448">            size_t              scan_call_count_;</a>
<a name="ln449">            size_t              help_scan_call_count_;</a>
<a name="ln450">#       endif</a>
<a name="ln451"> </a>
<a name="ln452">            // CppCheck warn: pad1_ and pad2_ is uninitialized in ctor</a>
<a name="ln453">            // cppcheck-suppress uninitMemberVar</a>
<a name="ln454">            thread_data( guard* guards, size_t guard_count )</a>
<a name="ln455">                : hazards_( guards, guard_count )</a>
<a name="ln456">                , sync_( 0 )</a>
<a name="ln457">#       ifdef CDS_ENABLE_HPSTAT</a>
<a name="ln458">                , free_call_count_(0)</a>
<a name="ln459">                , scan_call_count_(0)</a>
<a name="ln460">                , help_scan_call_count_(0)</a>
<a name="ln461">#       endif</a>
<a name="ln462">            {}</a>
<a name="ln463"> </a>
<a name="ln464">            thread_data() = delete;</a>
<a name="ln465">            thread_data( thread_data const&amp; ) = delete;</a>
<a name="ln466">            thread_data( thread_data&amp;&amp; ) = delete;</a>
<a name="ln467"> </a>
<a name="ln468">            void sync()</a>
<a name="ln469">            {</a>
<a name="ln470">                sync_.fetch_add( 1, atomics::memory_order_acq_rel );</a>
<a name="ln471">            }</a>
<a name="ln472">        };</a>
<a name="ln473">        //@endcond</a>
<a name="ln474"> </a>
<a name="ln475">        //@cond</a>
<a name="ln476">        // Dynamic (adaptive) Hazard Pointer SMR (Safe Memory Reclamation)</a>
<a name="ln477">        class smr</a>
<a name="ln478">        {</a>
<a name="ln479">            struct thread_record;</a>
<a name="ln480"> </a>
<a name="ln481">        public:</a>
<a name="ln482">            /// Returns the instance of Hazard Pointer \ref smr</a>
<a name="ln483">            static smr&amp; instance()</a>
<a name="ln484">            {</a>
<a name="ln485">#       ifdef CDS_DISABLE_SMR_EXCEPTION</a>
<a name="ln486">                assert( instance_ != nullptr );</a>
<a name="ln487">#       else</a>
<a name="ln488">                if ( !instance_ )</a>
<a name="ln489">                    CDS_THROW_EXCEPTION( not_initialized());</a>
<a name="ln490">#       endif</a>
<a name="ln491">                return *instance_;</a>
<a name="ln492">            }</a>
<a name="ln493"> </a>
<a name="ln494">            /// Creates Dynamic Hazard Pointer SMR singleton</a>
<a name="ln495">            /**</a>
<a name="ln496">                Dynamic Hazard Pointer SMR is a singleton. If DHP instance is not initialized then the function creates the instance.</a>
<a name="ln497">                Otherwise it does nothing.</a>
<a name="ln498"> </a>
<a name="ln499">                The Michael's HP reclamation schema depends of three parameters:</a>
<a name="ln500">                - \p nHazardPtrCount - HP pointer count per thread. Usually it is small number (2-4) depending from</a>
<a name="ln501">                the data structure algorithms. By default, if \p nHazardPtrCount = 0,</a>
<a name="ln502">                the function uses maximum of HP count for CDS library</a>
<a name="ln503">                - \p nMaxThreadCount - max count of thread with using HP GC in your application. Default is 100.</a>
<a name="ln504">                - \p nMaxRetiredPtrCount - capacity of array of retired pointers for each thread. Must be greater than</a>
<a name="ln505">                &lt;tt&gt; nHazardPtrCount * nMaxThreadCount &lt;/tt&gt;</a>
<a name="ln506">                Default is &lt;tt&gt;2 * nHazardPtrCount * nMaxThreadCount&lt;/tt&gt;</a>
<a name="ln507">            */</a>
<a name="ln508">            static CDS_EXPORT_API void construct(</a>
<a name="ln509">                size_t nInitialHazardPtrCount = 16  ///&lt; Initial number of hazard pointer per thread</a>
<a name="ln510">            );</a>
<a name="ln511"> </a>
<a name="ln512">            // for back-copatibility</a>
<a name="ln513">            static void Construct(</a>
<a name="ln514">                size_t nInitialHazardPtrCount = 16  ///&lt; Initial number of hazard pointer per thread</a>
<a name="ln515">            )</a>
<a name="ln516">            {</a>
<a name="ln517">                construct( nInitialHazardPtrCount );</a>
<a name="ln518">            }</a>
<a name="ln519"> </a>
<a name="ln520">            /// Destroys global instance of \ref smr</a>
<a name="ln521">            /**</a>
<a name="ln522">                The parameter \p bDetachAll should be used carefully: if its value is \p true,</a>
<a name="ln523">                then the object destroyed automatically detaches all attached threads. This feature</a>
<a name="ln524">                can be useful when you have no control over the thread termination, for example,</a>
<a name="ln525">                when \p libcds is injected into existing external thread.</a>
<a name="ln526">            */</a>
<a name="ln527">            static CDS_EXPORT_API void destruct(</a>
<a name="ln528">                bool bDetachAll = false     ///&lt; Detach all threads</a>
<a name="ln529">            );</a>
<a name="ln530"> </a>
<a name="ln531">            // for back-compatibility</a>
<a name="ln532">            static void Destruct(</a>
<a name="ln533">                bool bDetachAll = false     ///&lt; Detach all threads</a>
<a name="ln534">            )</a>
<a name="ln535">            {</a>
<a name="ln536">                destruct( bDetachAll );</a>
<a name="ln537">            }</a>
<a name="ln538"> </a>
<a name="ln539">            /// Checks if global SMR object is constructed and may be used</a>
<a name="ln540">            static bool isUsed() noexcept</a>
<a name="ln541">            {</a>
<a name="ln542">                return instance_ != nullptr;</a>
<a name="ln543">            }</a>
<a name="ln544"> </a>
<a name="ln545">            /// Set memory management functions</a>
<a name="ln546">            /**</a>
<a name="ln547">                @note This function may be called &lt;b&gt;BEFORE&lt;/b&gt; creating an instance</a>
<a name="ln548">                of Dynamic Hazard Pointer SMR</a>
<a name="ln549"> </a>
<a name="ln550">                SMR object allocates some memory for thread-specific data and for</a>
<a name="ln551">                creating SMR object.</a>
<a name="ln552">                By default, a standard \p new and \p delete operators are used for this.</a>
<a name="ln553">            */</a>
<a name="ln554">            static CDS_EXPORT_API void set_memory_allocator(</a>
<a name="ln555">                void* ( *alloc_func )( size_t size ),</a>
<a name="ln556">                void( *free_func )( void * p )</a>
<a name="ln557">            );</a>
<a name="ln558"> </a>
<a name="ln559">            /// Returns thread-local data for the current thread</a>
<a name="ln560">            static CDS_EXPORT_API thread_data* tls();</a>
<a name="ln561"> </a>
<a name="ln562">            static CDS_EXPORT_API void attach_thread();</a>
<a name="ln563">            static CDS_EXPORT_API void detach_thread();</a>
<a name="ln564"> </a>
<a name="ln565">            /// Get internal statistics</a>
<a name="ln566">            CDS_EXPORT_API void statistics( stat&amp; st );</a>
<a name="ln567"> </a>
<a name="ln568">        public: // for internal use only</a>
<a name="ln569">            /// The main garbage collecting function</a>
<a name="ln570">            CDS_EXPORT_API void scan( thread_data* pRec );</a>
<a name="ln571"> </a>
<a name="ln572">            /// Helper scan routine</a>
<a name="ln573">            /**</a>
<a name="ln574">                The function guarantees that every node that is eligible for reuse is eventually freed, barring</a>
<a name="ln575">                thread failures. To do so, after executing \p scan(), a thread executes a \p %help_scan(),</a>
<a name="ln576">                where it checks every HP record. If an HP record is inactive, the thread moves all &quot;lost&quot; reclaimed pointers</a>
<a name="ln577">                to thread's list of reclaimed pointers.</a>
<a name="ln578"> </a>
<a name="ln579">                The function is called internally by \p scan().</a>
<a name="ln580">            */</a>
<a name="ln581">            CDS_EXPORT_API void help_scan( thread_data* pThis );</a>
<a name="ln582"> </a>
<a name="ln583">            hp_allocator&amp; get_hp_allocator()</a>
<a name="ln584">            {</a>
<a name="ln585">                return hp_allocator_;</a>
<a name="ln586">            }</a>
<a name="ln587"> </a>
<a name="ln588">            retired_allocator&amp; get_retired_allocator()</a>
<a name="ln589">            {</a>
<a name="ln590">                return retired_allocator_;</a>
<a name="ln591">            }</a>
<a name="ln592"> </a>
<a name="ln593">        private:</a>
<a name="ln594">            CDS_EXPORT_API explicit smr(</a>
<a name="ln595">                size_t nInitialHazardPtrCount</a>
<a name="ln596">            );</a>
<a name="ln597"> </a>
<a name="ln598">            CDS_EXPORT_API ~smr();</a>
<a name="ln599"> </a>
<a name="ln600">            CDS_EXPORT_API void detach_all_thread();</a>
<a name="ln601"> </a>
<a name="ln602">        private:</a>
<a name="ln603">            CDS_EXPORT_API thread_record* create_thread_data();</a>
<a name="ln604">            static CDS_EXPORT_API void destroy_thread_data( thread_record* pRec );</a>
<a name="ln605"> </a>
<a name="ln606">            /// Allocates Hazard Pointer SMR thread private data</a>
<a name="ln607">            CDS_EXPORT_API thread_record* alloc_thread_data();</a>
<a name="ln608"> </a>
<a name="ln609">            /// Free HP SMR thread-private data</a>
<a name="ln610">            CDS_EXPORT_API void free_thread_data( thread_record* pRec, bool callHelpScan );</a>
<a name="ln611"> </a>
<a name="ln612">        private:</a>
<a name="ln613">            static CDS_EXPORT_API smr* instance_;</a>
<a name="ln614"> </a>
<a name="ln615">            atomics::atomic&lt; thread_record*&gt;    thread_list_;   ///&lt; Head of thread list</a>
<a name="ln616">            size_t const        initial_hazard_count_;  ///&lt; initial number of hazard pointers per thread</a>
<a name="ln617">            hp_allocator        hp_allocator_;</a>
<a name="ln618">            retired_allocator   retired_allocator_;</a>
<a name="ln619"> </a>
<a name="ln620">            // temporaries</a>
<a name="ln621">            std::atomic&lt;size_t&gt; last_plist_size_;   ///&lt; HP array size in last scan() call</a>
<a name="ln622">        };</a>
<a name="ln623">        //@endcond</a>
<a name="ln624"> </a>
<a name="ln625">        //@cond</a>
<a name="ln626">        // for backward compatibility</a>
<a name="ln627">        typedef smr GarbageCollector;</a>
<a name="ln628"> </a>
<a name="ln629"> </a>
<a name="ln630">        // inlines</a>
<a name="ln631">        inline hp_allocator&amp; hp_allocator::instance()</a>
<a name="ln632">        {</a>
<a name="ln633">            return smr::instance().get_hp_allocator();</a>
<a name="ln634">        }</a>
<a name="ln635"> </a>
<a name="ln636">        inline retired_allocator&amp; retired_allocator::instance()</a>
<a name="ln637">        {</a>
<a name="ln638">            return smr::instance().get_retired_allocator();</a>
<a name="ln639">        }</a>
<a name="ln640">        //@endcond</a>
<a name="ln641"> </a>
<a name="ln642">    } // namespace dhp</a>
<a name="ln643"> </a>
<a name="ln644"> </a>
<a name="ln645">    /// Dynamic (adaptie) Hazard Pointer SMR</a>
<a name="ln646">    /**  @ingroup cds_garbage_collector</a>
<a name="ln647"> </a>
<a name="ln648">        Implementation of Dynamic (adaptive) Hazard Pointer SMR</a>
<a name="ln649"> </a>
<a name="ln650">        Sources:</a>
<a name="ln651">            - [2002] Maged M.Michael &quot;Safe memory reclamation for dynamic lock-freeobjects using atomic reads and writes&quot;</a>
<a name="ln652">            - [2003] Maged M.Michael &quot;Hazard Pointers: Safe memory reclamation for lock-free objects&quot;</a>
<a name="ln653">            - [2004] Andrei Alexandrescy, Maged Michael &quot;Lock-free Data Structures with Hazard Pointers&quot;</a>
<a name="ln654"> </a>
<a name="ln655">        %DHP is an adaptive variant of classic \p cds::gc::HP, see @ref cds_garbage_collectors_comparison &quot;Compare HP implementation&quot;</a>
<a name="ln656"> </a>
<a name="ln657">        @note Internally, %DHP depends on free-list implementation. There are</a>
<a name="ln658">        DCAS-based free-list \p cds::intrusive::TaggedFreeList and more complicated CAS-based free-list</a>
<a name="ln659">        \p cds::intrusive::FreeList. For x86 architecture and GCC/clang, libcds selects appropriate free-list</a>
<a name="ln660">        based on \p -mcx16 compiler flag. You may manually disable DCAS support specifying</a>
<a name="ln661">        \p -DCDS_DISABLE_128BIT_ATOMIC for 64bit build or \p -DCDS_DISABLE_64BIT_ATOMIC for 32bit build</a>
<a name="ln662">        in compiler command line. All your projects and libcds MUST be compiled with the same flags -</a>
<a name="ln663">        either with DCAS support or without it.</a>
<a name="ln664">        For MS VC++ compiler DCAS is not supported.</a>
<a name="ln665"> </a>
<a name="ln666">        See \ref cds_how_to_use &quot;How to use&quot; section for details how to apply SMR.</a>
<a name="ln667">    */</a>
<a name="ln668">    class DHP</a>
<a name="ln669">    {</a>
<a name="ln670">    public:</a>
<a name="ln671">        /// Native guarded pointer type</a>
<a name="ln672">        typedef void* guarded_pointer;</a>
<a name="ln673"> </a>
<a name="ln674">        /// Atomic reference</a>
<a name="ln675">        template &lt;typename T&gt; using atomic_ref = atomics::atomic&lt;T *&gt;;</a>
<a name="ln676"> </a>
<a name="ln677">        /// Atomic type</a>
<a name="ln678">        /**</a>
<a name="ln679">            @headerfile cds/gc/dhp.h</a>
<a name="ln680">        */</a>
<a name="ln681">        template &lt;typename T&gt; using atomic_type = atomics::atomic&lt;T&gt;;</a>
<a name="ln682"> </a>
<a name="ln683">        /// Atomic marked pointer</a>
<a name="ln684">        template &lt;typename MarkedPtr&gt; using atomic_marked_ptr = atomics::atomic&lt;MarkedPtr&gt;;</a>
<a name="ln685"> </a>
<a name="ln686">        /// Internal statistics</a>
<a name="ln687">        typedef dhp::stat stat;</a>
<a name="ln688"> </a>
<a name="ln689">        /// Dynamic Hazard Pointer guard</a>
<a name="ln690">        /**</a>
<a name="ln691">            A guard is a hazard pointer.</a>
<a name="ln692">            Additionally, the \p %Guard class manages allocation and deallocation of the hazard pointer</a>
<a name="ln693"> </a>
<a name="ln694">            \p %Guard object is movable but not copyable.</a>
<a name="ln695"> </a>
<a name="ln696">            The guard object can be in two states:</a>
<a name="ln697">            - unlinked - the guard is not linked with any internal hazard pointer.</a>
<a name="ln698">              In this state no operation except \p link() and move assignment is supported.</a>
<a name="ln699">            - linked (default) - the guard allocates an internal hazard pointer and fully operable.</a>
<a name="ln700"> </a>
<a name="ln701">            Due to performance reason the implementation does not check state of the guard in runtime.</a>
<a name="ln702"> </a>
<a name="ln703">            @warning Move assignment can transfer the guard in unlinked state, use with care.</a>
<a name="ln704">        */</a>
<a name="ln705">        class Guard</a>
<a name="ln706">        {</a>
<a name="ln707">        public:</a>
<a name="ln708">            /// Default ctor allocates a guard (hazard pointer) from thread-private storage</a>
<a name="ln709">            Guard() noexcept</a>
<a name="ln710">                : guard_( dhp::smr::tls()-&gt;hazards_.alloc())</a>
<a name="ln711">            {}</a>
<a name="ln712"> </a>
<a name="ln713">            /// Initilalizes an unlinked guard i.e. the guard contains no hazard pointer. Used for move semantics support</a>
<a name="ln714">            explicit Guard( std::nullptr_t ) noexcept</a>
<a name="ln715">                : guard_( nullptr )</a>
<a name="ln716">            {}</a>
<a name="ln717"> </a>
<a name="ln718">            /// Move ctor - \p src guard becomes unlinked (transfer internal guard ownership)</a>
<a name="ln719">            Guard( Guard&amp;&amp; src ) noexcept</a>
<a name="ln720">                : guard_( src.guard_ )</a>
<a name="ln721">            {</a>
<a name="ln722">                src.guard_ = nullptr;</a>
<a name="ln723">            }</a>
<a name="ln724"> </a>
<a name="ln725">            /// Move assignment: the internal guards are swapped between \p src and \p this</a>
<a name="ln726">            /**</a>
<a name="ln727">                @warning \p src will become in unlinked state if \p this was unlinked on entry.</a>
<a name="ln728">            */</a>
<a name="ln729">            Guard&amp; operator=( Guard&amp;&amp; src ) noexcept</a>
<a name="ln730">            {</a>
<a name="ln731">                std::swap( guard_, src.guard_ );</a>
<a name="ln732">                return *this;</a>
<a name="ln733">            }</a>
<a name="ln734"> </a>
<a name="ln735">            /// Copy ctor is prohibited - the guard is not copyable</a>
<a name="ln736">            Guard( Guard const&amp; ) = delete;</a>
<a name="ln737"> </a>
<a name="ln738">            /// Copy assignment is prohibited</a>
<a name="ln739">            Guard&amp; operator=( Guard const&amp; ) = delete;</a>
<a name="ln740"> </a>
<a name="ln741">            /// Frees the internal hazard pointer if the guard is in linked state</a>
<a name="ln742">            ~Guard()</a>
<a name="ln743">            {</a>
<a name="ln744">                unlink();</a>
<a name="ln745">            }</a>
<a name="ln746"> </a>
<a name="ln747">            /// Checks if the guard object linked with any internal hazard pointer</a>
<a name="ln748">            bool is_linked() const</a>
<a name="ln749">            {</a>
<a name="ln750">                return guard_ != nullptr;</a>
<a name="ln751">            }</a>
<a name="ln752"> </a>
<a name="ln753">            /// Links the guard with internal hazard pointer if the guard is in unlinked state</a>
<a name="ln754">            void link()</a>
<a name="ln755">            {</a>
<a name="ln756">                if ( !guard_ )</a>
<a name="ln757">                    guard_ = dhp::smr::tls()-&gt;hazards_.alloc();</a>
<a name="ln758">            }</a>
<a name="ln759"> </a>
<a name="ln760">            /// Unlinks the guard from internal hazard pointer; the guard becomes in unlinked state</a>
<a name="ln761">            void unlink()</a>
<a name="ln762">            {</a>
<a name="ln763">                if ( guard_ ) {</a>
<a name="ln764">                    dhp::smr::tls()-&gt;hazards_.free( guard_ );</a>
<a name="ln765">                    guard_ = nullptr;</a>
<a name="ln766">                }</a>
<a name="ln767">            }</a>
<a name="ln768"> </a>
<a name="ln769">            /// Protects a pointer of type &lt;tt&gt; atomic&lt;T*&gt; &lt;/tt&gt;</a>
<a name="ln770">            /**</a>
<a name="ln771">                Return the value of \p toGuard</a>
<a name="ln772"> </a>
<a name="ln773">                The function tries to load \p toGuard and to store it</a>
<a name="ln774">                to the HP slot repeatedly until the guard's value equals \p toGuard</a>
<a name="ln775">            */</a>
<a name="ln776">            template &lt;typename T&gt;</a>
<a name="ln777">            T protect( atomics::atomic&lt;T&gt; const&amp; toGuard )</a>
<a name="ln778">            {</a>
<a name="ln779">                return protect(toGuard, [](T p) { return p; });</a>
<a name="ln780">            }</a>
<a name="ln781"> </a>
<a name="ln782">            /// Protects a converted pointer of type &lt;tt&gt; atomic&lt;T*&gt; &lt;/tt&gt;</a>
<a name="ln783">            /**</a>
<a name="ln784">                Return the value of \p toGuard</a>
<a name="ln785"> </a>
<a name="ln786">                The function tries to load \p toGuard and to store result of \p f functor</a>
<a name="ln787">                to the HP slot repeatedly until the guard's value equals \p toGuard.</a>
<a name="ln788"> </a>
<a name="ln789">                The function is useful for intrusive containers when \p toGuard is a node pointer</a>
<a name="ln790">                that should be converted to a pointer to the value type before guarding.</a>
<a name="ln791">                The parameter \p f of type Func is a functor that makes this conversion:</a>
<a name="ln792">                \code</a>
<a name="ln793">                    struct functor {</a>
<a name="ln794">                        value_type * operator()( T * p );</a>
<a name="ln795">                    };</a>
<a name="ln796">                \endcode</a>
<a name="ln797">                Really, the result of &lt;tt&gt; f( toGuard.load()) &lt;/tt&gt; is assigned to the hazard pointer.</a>
<a name="ln798">            */</a>
<a name="ln799">            template &lt;typename T, class Func&gt;</a>
<a name="ln800">            T protect( atomics::atomic&lt;T&gt; const&amp; toGuard, Func f )</a>
<a name="ln801">            {</a>
<a name="ln802">                assert( guard_ != nullptr );</a>
<a name="ln803"> </a>
<a name="ln804">                T pCur = toGuard.load(atomics::memory_order_relaxed);</a>
<a name="ln805">                T pRet;</a>
<a name="ln806">                do {</a>
<a name="ln807">                    pRet = pCur;</a>
<a name="ln808">                    assign( f( pCur ));</a>
<a name="ln809">                    pCur = toGuard.load(atomics::memory_order_acquire);</a>
<a name="ln810">                } while ( pRet != pCur );</a>
<a name="ln811">                return pCur;</a>
<a name="ln812">            }</a>
<a name="ln813"> </a>
<a name="ln814">            /// Store \p p to the guard</a>
<a name="ln815">            /**</a>
<a name="ln816">                The function is just an assignment, no loop is performed.</a>
<a name="ln817">                Can be used for a pointer that cannot be changed concurrently</a>
<a name="ln818">                or for already guarded pointer.</a>
<a name="ln819">            */</a>
<a name="ln820">            template &lt;typename T&gt;</a>
<a name="ln821">            T* assign( T* p )</a>
<a name="ln822">            {</a>
<a name="ln823">                assert( guard_ != nullptr );</a>
<a name="ln824"> </a>
<a name="ln825">                guard_-&gt;set( p );</a>
<a name="ln826">                dhp::smr::tls()-&gt;sync();</a>
<a name="ln827">                return p;</a>
<a name="ln828">            }</a>
<a name="ln829"> </a>
<a name="ln830">            //@cond</a>
<a name="ln831">            std::nullptr_t assign( std::nullptr_t )</a>
<a name="ln832">            {</a>
<a name="ln833">                assert( guard_ != nullptr );</a>
<a name="ln834"> </a>
<a name="ln835">                clear();</a>
<a name="ln836">                return nullptr;</a>
<a name="ln837">            }</a>
<a name="ln838">            //@endcond</a>
<a name="ln839"> </a>
<a name="ln840">            /// Store marked pointer \p p to the guard</a>
<a name="ln841">            /**</a>
<a name="ln842">                The function is just an assignment of &lt;tt&gt;p.ptr()&lt;/tt&gt;, no loop is performed.</a>
<a name="ln843">                Can be used for a marked pointer that cannot be changed concurrently</a>
<a name="ln844">                or for already guarded pointer.</a>
<a name="ln845">            */</a>
<a name="ln846">            template &lt;typename T, int BITMASK&gt;</a>
<a name="ln847">            T* assign( cds::details::marked_ptr&lt;T, BITMASK&gt; p )</a>
<a name="ln848">            {</a>
<a name="ln849">                return assign( p.ptr());</a>
<a name="ln850">            }</a>
<a name="ln851"> </a>
<a name="ln852">            /// Copy from \p src guard to \p this guard</a>
<a name="ln853">            void copy( Guard const&amp; src )</a>
<a name="ln854">            {</a>
<a name="ln855">                assign( src.get_native());</a>
<a name="ln856">            }</a>
<a name="ln857"> </a>
<a name="ln858">            /// Clears value of the guard</a>
<a name="ln859">            void clear()</a>
<a name="ln860">            {</a>
<a name="ln861">                assert( guard_ != nullptr );</a>
<a name="ln862"> </a>
<a name="ln863">                guard_-&gt;clear();</a>
<a name="ln864">            }</a>
<a name="ln865"> </a>
<a name="ln866">            /// Gets the value currently protected (relaxed read)</a>
<a name="ln867">            template &lt;typename T&gt;</a>
<a name="ln868">            T * get() const</a>
<a name="ln869">            {</a>
<a name="ln870">                assert( guard_ != nullptr );</a>
<a name="ln871">                return guard_-&gt;get_as&lt;T&gt;();</a>
<a name="ln872">            }</a>
<a name="ln873"> </a>
<a name="ln874">            /// Gets native guarded pointer stored</a>
<a name="ln875">            void* get_native() const</a>
<a name="ln876">            {</a>
<a name="ln877">                assert( guard_ != nullptr );</a>
<a name="ln878">                return guard_-&gt;get();</a>
<a name="ln879">            }</a>
<a name="ln880"> </a>
<a name="ln881">            //@cond</a>
<a name="ln882">            dhp::guard* release()</a>
<a name="ln883">            {</a>
<a name="ln884">                dhp::guard* g = guard_;</a>
<a name="ln885">                guard_ = nullptr;</a>
<a name="ln886">                return g;</a>
<a name="ln887">            }</a>
<a name="ln888"> </a>
<a name="ln889">            dhp::guard*&amp; guard_ref()</a>
<a name="ln890">            {</a>
<a name="ln891">                return guard_;</a>
<a name="ln892">            }</a>
<a name="ln893">            //@endcond</a>
<a name="ln894"> </a>
<a name="ln895">        private:</a>
<a name="ln896">            //@cond</a>
<a name="ln897">            dhp::guard* guard_;</a>
<a name="ln898">            //@endcond</a>
<a name="ln899">        };</a>
<a name="ln900"> </a>
<a name="ln901">        /// Array of Dynamic Hazard Pointer guards</a>
<a name="ln902">        /**</a>
<a name="ln903">            The class is intended for allocating an array of hazard pointer guards.</a>
<a name="ln904">            Template parameter \p Count defines the size of the array.</a>
<a name="ln905"> </a>
<a name="ln906">            A \p %GuardArray object is not copy- and move-constructible</a>
<a name="ln907">            and not copy- and move-assignable.</a>
<a name="ln908">        */</a>
<a name="ln909">        template &lt;size_t Count&gt;</a>
<a name="ln910">        class GuardArray</a>
<a name="ln911">        {</a>
<a name="ln912">        public:</a>
<a name="ln913">            /// Rebind array for other size \p OtherCount</a>
<a name="ln914">            template &lt;size_t OtherCount&gt;</a>
<a name="ln915">            struct rebind {</a>
<a name="ln916">                typedef GuardArray&lt;OtherCount&gt;  other   ;   ///&lt; rebinding result</a>
<a name="ln917">            };</a>
<a name="ln918"> </a>
<a name="ln919">            /// Array capacity</a>
<a name="ln920">            static constexpr const size_t c_nCapacity = Count;</a>
<a name="ln921"> </a>
<a name="ln922">        public:</a>
<a name="ln923">            /// Default ctor allocates \p Count hazard pointers</a>
<a name="ln924">            GuardArray()</a>
<a name="ln925">            {</a>
<a name="ln926">                dhp::smr::tls()-&gt;hazards_.alloc( guards_ );</a>
<a name="ln927">            }</a>
<a name="ln928"> </a>
<a name="ln929">            /// Move ctor is prohibited</a>
<a name="ln930">            GuardArray( GuardArray&amp;&amp; ) = delete;</a>
<a name="ln931"> </a>
<a name="ln932">            /// Move assignment is prohibited</a>
<a name="ln933">            GuardArray&amp; operator=( GuardArray&amp;&amp; ) = delete;</a>
<a name="ln934"> </a>
<a name="ln935">            /// Copy ctor is prohibited</a>
<a name="ln936">            GuardArray( GuardArray const&amp; ) = delete;</a>
<a name="ln937"> </a>
<a name="ln938">            /// Copy assignment is prohibited</a>
<a name="ln939">            GuardArray&amp; operator=( GuardArray const&amp; ) = delete;</a>
<a name="ln940"> </a>
<a name="ln941">            /// Frees allocated hazard pointers</a>
<a name="ln942">            ~GuardArray()</a>
<a name="ln943">            {</a>
<a name="ln944">                dhp::smr::tls()-&gt;hazards_.free( guards_ );</a>
<a name="ln945">            }</a>
<a name="ln946"> </a>
<a name="ln947">            /// Protects a pointer of type \p atomic&lt;T*&gt;</a>
<a name="ln948">            /**</a>
<a name="ln949">                Return the value of \p toGuard</a>
<a name="ln950"> </a>
<a name="ln951">                The function tries to load \p toGuard and to store it</a>
<a name="ln952">                to the slot \p nIndex repeatedly until the guard's value equals \p toGuard</a>
<a name="ln953">            */</a>
<a name="ln954">            template &lt;typename T&gt;</a>
<a name="ln955">            T protect( size_t nIndex, atomics::atomic&lt;T&gt; const&amp; toGuard )</a>
<a name="ln956">            {</a>
<a name="ln957">                return protect(nIndex, toGuard, [](T p) { return p; });</a>
<a name="ln958">            }</a>
<a name="ln959"> </a>
<a name="ln960">            /// Protects a pointer of type \p atomic&lt;T*&gt;</a>
<a name="ln961">            /**</a>
<a name="ln962">                Return the value of \p toGuard</a>
<a name="ln963"> </a>
<a name="ln964">                The function tries to load \p toGuard and to store it</a>
<a name="ln965">                to the slot \p nIndex repeatedly until the guard's value equals \p toGuard</a>
<a name="ln966"> </a>
<a name="ln967">                The function is useful for intrusive containers when \p toGuard is a node pointer</a>
<a name="ln968">                that should be converted to a pointer to the value type before guarding.</a>
<a name="ln969">                The parameter \p f of type Func is a functor to make that conversion:</a>
<a name="ln970">                \code</a>
<a name="ln971">                    struct functor {</a>
<a name="ln972">                        value_type * operator()( T * p );</a>
<a name="ln973">                    };</a>
<a name="ln974">                \endcode</a>
<a name="ln975">                Actually, the result of &lt;tt&gt; f( toGuard.load()) &lt;/tt&gt; is assigned to the hazard pointer.</a>
<a name="ln976">            */</a>
<a name="ln977">            template &lt;typename T, class Func&gt;</a>
<a name="ln978">            T protect( size_t nIndex, atomics::atomic&lt;T&gt; const&amp; toGuard, Func f )</a>
<a name="ln979">            {</a>
<a name="ln980">                assert( nIndex &lt; capacity());</a>
<a name="ln981"> </a>
<a name="ln982">                T pRet;</a>
<a name="ln983">                do {</a>
<a name="ln984">                    assign( nIndex, f( pRet = toGuard.load(atomics::memory_order_relaxed)));</a>
<a name="ln985">                } while ( pRet != toGuard.load(atomics::memory_order_acquire));</a>
<a name="ln986"> </a>
<a name="ln987">                return pRet;</a>
<a name="ln988">            }</a>
<a name="ln989"> </a>
<a name="ln990">            /// Store \p p to the slot \p nIndex</a>
<a name="ln991">            /**</a>
<a name="ln992">                The function is just an assignment, no loop is performed.</a>
<a name="ln993">            */</a>
<a name="ln994">            template &lt;typename T&gt;</a>
<a name="ln995">            T * assign( size_t nIndex, T * p )</a>
<a name="ln996">            {</a>
<a name="ln997">                assert( nIndex &lt; capacity());</a>
<a name="ln998"> </a>
<a name="ln999">                guards_.set( nIndex, p );</a>
<a name="ln1000">                dhp::smr::tls()-&gt;sync();</a>
<a name="ln1001">                return p;</a>
<a name="ln1002">            }</a>
<a name="ln1003"> </a>
<a name="ln1004">            /// Store marked pointer \p p to the guard</a>
<a name="ln1005">            /**</a>
<a name="ln1006">                The function is just an assignment of &lt;tt&gt;p.ptr()&lt;/tt&gt;, no loop is performed.</a>
<a name="ln1007">                Can be used for a marked pointer that cannot be changed concurrently</a>
<a name="ln1008">                or for already guarded pointer.</a>
<a name="ln1009">            */</a>
<a name="ln1010">            template &lt;typename T, int Bitmask&gt;</a>
<a name="ln1011">            T * assign( size_t nIndex, cds::details::marked_ptr&lt;T, Bitmask&gt; p )</a>
<a name="ln1012">            {</a>
<a name="ln1013">                return assign( nIndex, p.ptr());</a>
<a name="ln1014">            }</a>
<a name="ln1015"> </a>
<a name="ln1016">            /// Copy guarded value from \p src guard to slot at index \p nIndex</a>
<a name="ln1017">            void copy( size_t nIndex, Guard const&amp; src )</a>
<a name="ln1018">            {</a>
<a name="ln1019">                assign( nIndex, src.get_native());</a>
<a name="ln1020">            }</a>
<a name="ln1021"> </a>
<a name="ln1022">            /// Copy guarded value from slot \p nSrcIndex to slot at index \p nDestIndex</a>
<a name="ln1023">            void copy( size_t nDestIndex, size_t nSrcIndex )</a>
<a name="ln1024">            {</a>
<a name="ln1025">                assign( nDestIndex, get_native( nSrcIndex ));</a>
<a name="ln1026">            }</a>
<a name="ln1027"> </a>
<a name="ln1028">            /// Clear value of the slot \p nIndex</a>
<a name="ln1029">            void clear( size_t nIndex )</a>
<a name="ln1030">            {</a>
<a name="ln1031">                guards_.clear( nIndex );</a>
<a name="ln1032">            }</a>
<a name="ln1033"> </a>
<a name="ln1034">            /// Get current value of slot \p nIndex</a>
<a name="ln1035">            template &lt;typename T&gt;</a>
<a name="ln1036">            T * get( size_t nIndex ) const</a>
<a name="ln1037">            {</a>
<a name="ln1038">                assert( nIndex &lt; capacity());</a>
<a name="ln1039">                return guards_[nIndex]-&gt;template get_as&lt;T&gt;();</a>
<a name="ln1040">            }</a>
<a name="ln1041"> </a>
<a name="ln1042">            /// Get native guarded pointer stored</a>
<a name="ln1043">            guarded_pointer get_native( size_t nIndex ) const</a>
<a name="ln1044">            {</a>
<a name="ln1045">                assert( nIndex &lt; capacity());</a>
<a name="ln1046">                return guards_[nIndex]-&gt;get();</a>
<a name="ln1047">            }</a>
<a name="ln1048"> </a>
<a name="ln1049">            //@cond</a>
<a name="ln1050">            dhp::guard* release( size_t nIndex ) noexcept</a>
<a name="ln1051">            {</a>
<a name="ln1052">                return guards_.release( nIndex );</a>
<a name="ln1053">            }</a>
<a name="ln1054">            //@endcond</a>
<a name="ln1055"> </a>
<a name="ln1056">            /// Capacity of the guard array</a>
<a name="ln1057">            static constexpr size_t capacity()</a>
<a name="ln1058">            {</a>
<a name="ln1059">                return Count;</a>
<a name="ln1060">            }</a>
<a name="ln1061"> </a>
<a name="ln1062">        private:</a>
<a name="ln1063">            //@cond</a>
<a name="ln1064">            dhp::guard_array&lt;c_nCapacity&gt; guards_;</a>
<a name="ln1065">            //@endcond</a>
<a name="ln1066">        };</a>
<a name="ln1067"> </a>
<a name="ln1068">        /// Guarded pointer</a>
<a name="ln1069">        /**</a>
<a name="ln1070">            A guarded pointer is a pair of a pointer and GC's guard.</a>
<a name="ln1071">            Usually, it is used for returning a pointer to the item from an lock-free container.</a>
<a name="ln1072">            The guard prevents the pointer to be early disposed (freed) by GC.</a>
<a name="ln1073">            After destructing \p %guarded_ptr object the pointer can be disposed (freed) automatically at any time.</a>
<a name="ln1074"> </a>
<a name="ln1075">            Template arguments:</a>
<a name="ln1076">            - \p GuardedType - a type which the guard stores</a>
<a name="ln1077">            - \p ValueType - a value type</a>
<a name="ln1078">            - \p Cast - a functor for converting &lt;tt&gt;GuardedType*&lt;/tt&gt; to &lt;tt&gt;ValueType*&lt;/tt&gt;. Default is \p void (no casting).</a>
<a name="ln1079"> </a>
<a name="ln1080">            For intrusive containers, \p GuardedType is the same as \p ValueType and no casting is needed.</a>
<a name="ln1081">            In such case the \p %guarded_ptr is:</a>
<a name="ln1082">            @code</a>
<a name="ln1083">            typedef cds::gc::DHP::guarded_ptr&lt; foo &gt; intrusive_guarded_ptr;</a>
<a name="ln1084">            @endcode</a>
<a name="ln1085"> </a>
<a name="ln1086">            For standard (non-intrusive) containers \p GuardedType is not the same as \p ValueType and casting is needed.</a>
<a name="ln1087">            For example:</a>
<a name="ln1088">            @code</a>
<a name="ln1089">            struct foo {</a>
<a name="ln1090">                int const   key;</a>
<a name="ln1091">                std::string value;</a>
<a name="ln1092">            };</a>
<a name="ln1093"> </a>
<a name="ln1094">            struct value_accessor {</a>
<a name="ln1095">                std::string* operator()( foo* pFoo ) const</a>
<a name="ln1096">                {</a>
<a name="ln1097">                    return &amp;(pFoo-&gt;value);</a>
<a name="ln1098">                }</a>
<a name="ln1099">            };</a>
<a name="ln1100"> </a>
<a name="ln1101">            // Guarded ptr</a>
<a name="ln1102">            typedef cds::gc::DHP::guarded_ptr&lt; Foo, std::string, value_accessor &gt; nonintrusive_guarded_ptr;</a>
<a name="ln1103">            @endcode</a>
<a name="ln1104"> </a>
<a name="ln1105">            You don't need use this class directly.</a>
<a name="ln1106">            All set/map container classes from \p libcds declare the typedef for \p %guarded_ptr with appropriate casting functor.</a>
<a name="ln1107">        */</a>
<a name="ln1108">        template &lt;typename GuardedType, typename ValueType=GuardedType, typename Cast=void &gt;</a>
<a name="ln1109">        class guarded_ptr</a>
<a name="ln1110">        {</a>
<a name="ln1111">            //@cond</a>
<a name="ln1112">            struct trivial_cast {</a>
<a name="ln1113">                ValueType * operator()( GuardedType * p ) const</a>
<a name="ln1114">                {</a>
<a name="ln1115">                    return p;</a>
<a name="ln1116">                }</a>
<a name="ln1117">            };</a>
<a name="ln1118"> </a>
<a name="ln1119">            template &lt;typename GT, typename VT, typename C&gt; friend class guarded_ptr;</a>
<a name="ln1120">            //@endcond</a>
<a name="ln1121"> </a>
<a name="ln1122">        public:</a>
<a name="ln1123">            typedef GuardedType guarded_type; ///&lt; Guarded type</a>
<a name="ln1124">            typedef ValueType   value_type;   ///&lt; Value type</a>
<a name="ln1125"> </a>
<a name="ln1126">            /// Functor for casting \p guarded_type to \p value_type</a>
<a name="ln1127">            typedef typename std::conditional&lt; std::is_same&lt;Cast, void&gt;::value, trivial_cast, Cast &gt;::type value_cast;</a>
<a name="ln1128"> </a>
<a name="ln1129">        public:</a>
<a name="ln1130">            /// Creates empty guarded pointer</a>
<a name="ln1131">            guarded_ptr() noexcept</a>
<a name="ln1132">                : guard_( nullptr )</a>
<a name="ln1133">            {}</a>
<a name="ln1134"> </a>
<a name="ln1135">            //@cond</a>
<a name="ln1136">            explicit guarded_ptr( dhp::guard* g ) noexcept</a>
<a name="ln1137">                : guard_( g )</a>
<a name="ln1138">            {}</a>
<a name="ln1139"> </a>
<a name="ln1140">            /// Initializes guarded pointer with \p p</a>
<a name="ln1141">            explicit guarded_ptr( guarded_type * p ) noexcept</a>
<a name="ln1142">                : guard_( nullptr )</a>
<a name="ln1143">            {</a>
<a name="ln1144">                reset( p );</a>
<a name="ln1145">            }</a>
<a name="ln1146">            explicit guarded_ptr( std::nullptr_t ) noexcept</a>
<a name="ln1147">                : guard_( nullptr )</a>
<a name="ln1148">            {}</a>
<a name="ln1149">            //@endcond</a>
<a name="ln1150"> </a>
<a name="ln1151">            /// Move ctor</a>
<a name="ln1152">            guarded_ptr( guarded_ptr&amp;&amp; gp ) noexcept</a>
<a name="ln1153">                : guard_( gp.guard_ )</a>
<a name="ln1154">            {</a>
<a name="ln1155">                gp.guard_ = nullptr;</a>
<a name="ln1156">            }</a>
<a name="ln1157"> </a>
<a name="ln1158">            /// Move ctor</a>
<a name="ln1159">            template &lt;typename GT, typename VT, typename C&gt;</a>
<a name="ln1160">            guarded_ptr( guarded_ptr&lt;GT, VT, C&gt;&amp;&amp; gp ) noexcept</a>
<a name="ln1161">                : guard_( gp.guard_ )</a>
<a name="ln1162">            {</a>
<a name="ln1163">                gp.guard_ = nullptr;</a>
<a name="ln1164">            }</a>
<a name="ln1165"> </a>
<a name="ln1166">            /// Ctor from \p Guard</a>
<a name="ln1167">            explicit guarded_ptr( Guard&amp;&amp; g ) noexcept</a>
<a name="ln1168">                : guard_( g.release())</a>
<a name="ln1169">            {}</a>
<a name="ln1170"> </a>
<a name="ln1171">            /// The guarded pointer is not copy-constructible</a>
<a name="ln1172">            guarded_ptr( guarded_ptr const&amp; gp ) = delete;</a>
<a name="ln1173"> </a>
<a name="ln1174">            /// Clears the guarded pointer</a>
<a name="ln1175">            /**</a>
<a name="ln1176">                \ref release is called if guarded pointer is not \ref empty</a>
<a name="ln1177">            */</a>
<a name="ln1178">            ~guarded_ptr() noexcept</a>
<a name="ln1179">            {</a>
<a name="ln1180">                release();</a>
<a name="ln1181">            }</a>
<a name="ln1182"> </a>
<a name="ln1183">            /// Move-assignment operator</a>
<a name="ln1184">            guarded_ptr&amp; operator=( guarded_ptr&amp;&amp; gp ) noexcept</a>
<a name="ln1185">            {</a>
<a name="ln1186">                std::swap( guard_, gp.guard_ );</a>
<a name="ln1187">                return *this;</a>
<a name="ln1188">            }</a>
<a name="ln1189"> </a>
<a name="ln1190">            /// Move-assignment from \p Guard</a>
<a name="ln1191">            guarded_ptr&amp; operator=( Guard&amp;&amp; g ) noexcept</a>
<a name="ln1192">            {</a>
<a name="ln1193">                std::swap( guard_, g.guard_ref());</a>
<a name="ln1194">                return *this;</a>
<a name="ln1195">            }</a>
<a name="ln1196"> </a>
<a name="ln1197">            /// The guarded pointer is not copy-assignable</a>
<a name="ln1198">            guarded_ptr&amp; operator=(guarded_ptr const&amp; gp) = delete;</a>
<a name="ln1199"> </a>
<a name="ln1200">            /// Returns a pointer to guarded value</a>
<a name="ln1201">            value_type * operator -&gt;() const noexcept</a>
<a name="ln1202">            {</a>
<a name="ln1203">                assert( !empty());</a>
<a name="ln1204">                return value_cast()( guard_-&gt;get_as&lt;guarded_type&gt;());</a>
<a name="ln1205">            }</a>
<a name="ln1206"> </a>
<a name="ln1207">            /// Returns a reference to guarded value</a>
<a name="ln1208">            value_type&amp; operator *() noexcept</a>
<a name="ln1209">            {</a>
<a name="ln1210">                assert( !empty());</a>
<a name="ln1211">                return *value_cast()( guard_-&gt;get_as&lt;guarded_type&gt;());</a>
<a name="ln1212">            }</a>
<a name="ln1213"> </a>
<a name="ln1214">            /// Returns const reference to guarded value</a>
<a name="ln1215">            value_type const&amp; operator *() const noexcept</a>
<a name="ln1216">            {</a>
<a name="ln1217">                assert( !empty());</a>
<a name="ln1218">                return *value_cast()(reinterpret_cast&lt;guarded_type *&gt;(guard_-&gt;get()));</a>
<a name="ln1219">            }</a>
<a name="ln1220"> </a>
<a name="ln1221">            /// Checks if the guarded pointer is \p nullptr</a>
<a name="ln1222">            bool empty() const noexcept</a>
<a name="ln1223">            {</a>
<a name="ln1224">                return guard_ == nullptr || guard_-&gt;get( atomics::memory_order_relaxed ) == nullptr;</a>
<a name="ln1225">            }</a>
<a name="ln1226"> </a>
<a name="ln1227">            /// \p bool operator returns &lt;tt&gt;!empty()&lt;/tt&gt;</a>
<a name="ln1228">            explicit operator bool() const noexcept</a>
<a name="ln1229">            {</a>
<a name="ln1230">                return !empty();</a>
<a name="ln1231">            }</a>
<a name="ln1232"> </a>
<a name="ln1233">            /// Clears guarded pointer</a>
<a name="ln1234">            /**</a>
<a name="ln1235">                If the guarded pointer has been released, the pointer can be disposed (freed) at any time.</a>
<a name="ln1236">                Dereferncing the guarded pointer after \p release() is dangerous.</a>
<a name="ln1237">            */</a>
<a name="ln1238">            void release() noexcept</a>
<a name="ln1239">            {</a>
<a name="ln1240">                free_guard();</a>
<a name="ln1241">            }</a>
<a name="ln1242"> </a>
<a name="ln1243">            //@cond</a>
<a name="ln1244">            // For internal use only!!!</a>
<a name="ln1245">            void reset(guarded_type * p) noexcept</a>
<a name="ln1246">            {</a>
<a name="ln1247">                alloc_guard();</a>
<a name="ln1248">                assert( guard_ );</a>
<a name="ln1249">                guard_-&gt;set( p );</a>
<a name="ln1250">            }</a>
<a name="ln1251"> </a>
<a name="ln1252">            //@endcond</a>
<a name="ln1253"> </a>
<a name="ln1254">        private:</a>
<a name="ln1255">            //@cond</a>
<a name="ln1256">            void alloc_guard()</a>
<a name="ln1257">            {</a>
<a name="ln1258">                if ( !guard_ )</a>
<a name="ln1259">                    guard_ = dhp::smr::tls()-&gt;hazards_.alloc();</a>
<a name="ln1260">            }</a>
<a name="ln1261"> </a>
<a name="ln1262">            void free_guard()</a>
<a name="ln1263">            {</a>
<a name="ln1264">                if ( guard_ ) {</a>
<a name="ln1265">                    dhp::smr::tls()-&gt;hazards_.free( guard_ );</a>
<a name="ln1266">                    guard_ = nullptr;</a>
<a name="ln1267">                }</a>
<a name="ln1268">            }</a>
<a name="ln1269">            //@endcond</a>
<a name="ln1270"> </a>
<a name="ln1271">        private:</a>
<a name="ln1272">            //@cond</a>
<a name="ln1273">            dhp::guard* guard_;</a>
<a name="ln1274">            //@endcond</a>
<a name="ln1275">        };</a>
<a name="ln1276"> </a>
<a name="ln1277">    public:</a>
<a name="ln1278">        /// Initializes %DHP memory manager singleton</a>
<a name="ln1279">        /**</a>
<a name="ln1280">            Constructor creates and initializes %DHP global object.</a>
<a name="ln1281">            %DHP object should be created before using CDS data structure based on \p %cds::gc::DHP. Usually,</a>
<a name="ln1282">            it is created in the beginning of \p main() function.</a>
<a name="ln1283">            After creating of global object you may use CDS data structures based on \p %cds::gc::DHP.</a>
<a name="ln1284"> </a>
<a name="ln1285">            \p nInitialThreadGuardCount - initial count of guard allocated for each thread.</a>
<a name="ln1286">                When a thread is initialized the GC allocates local guard pool for the thread from a common guard pool.</a>
<a name="ln1287">                By perforce the local thread's guard pool is grown automatically from common pool.</a>
<a name="ln1288">                When the thread terminated its guard pool is backed to common GC's pool.</a>
<a name="ln1289">        */</a>
<a name="ln1290">        explicit DHP(</a>
<a name="ln1291">            size_t nInitialHazardPtrCount = 16  ///&lt; Initial number of hazard pointer per thread</a>
<a name="ln1292">        )</a>
<a name="ln1293">        {</a>
<a name="ln1294">            dhp::smr::construct( nInitialHazardPtrCount );</a>
<a name="ln1295">        }</a>
<a name="ln1296"> </a>
<a name="ln1297">        /// Destroys %DHP memory manager</a>
<a name="ln1298">        /**</a>
<a name="ln1299">            The destructor destroys %DHP global object. After calling of this function you may \b NOT</a>
<a name="ln1300">            use CDS data structures based on \p %cds::gc::DHP.</a>
<a name="ln1301">            Usually, %DHP object is destroyed at the end of your \p main().</a>
<a name="ln1302">        */</a>
<a name="ln1303">        ~DHP()</a>
<a name="ln1304">        {</a>
<a name="ln1305">            dhp::GarbageCollector::destruct( true );</a>
<a name="ln1306">        }</a>
<a name="ln1307"> </a>
<a name="ln1308">        /// Checks if count of hazard pointer is no less than \p nCountNeeded</a>
<a name="ln1309">        /**</a>
<a name="ln1310">            The function always returns \p true since the guard count is unlimited for</a>
<a name="ln1311">            \p %gc::DHP garbage collector.</a>
<a name="ln1312">        */</a>
<a name="ln1313">        static constexpr bool check_available_guards(</a>
<a name="ln1314">#ifdef CDS_DOXYGEN_INVOKED</a>
<a name="ln1315">            size_t nCountNeeded,</a>
<a name="ln1316">#else</a>
<a name="ln1317">            size_t</a>
<a name="ln1318">#endif</a>
<a name="ln1319">        )</a>
<a name="ln1320">        {</a>
<a name="ln1321">            return true;</a>
<a name="ln1322">        }</a>
<a name="ln1323"> </a>
<a name="ln1324">        /// Set memory management functions</a>
<a name="ln1325">        /**</a>
<a name="ln1326">            @note This function may be called &lt;b&gt;BEFORE&lt;/b&gt; creating an instance</a>
<a name="ln1327">            of Dynamic Hazard Pointer SMR</a>
<a name="ln1328"> </a>
<a name="ln1329">            SMR object allocates some memory for thread-specific data and for creating SMR object.</a>
<a name="ln1330">            By default, a standard \p new and \p delete operators are used for this.</a>
<a name="ln1331">        */</a>
<a name="ln1332">        static void set_memory_allocator(</a>
<a name="ln1333">            void* ( *alloc_func )( size_t size ),   ///&lt; \p malloc() function</a>
<a name="ln1334">            void( *free_func )( void * p )          ///&lt; \p free() function</a>
<a name="ln1335">        )</a>
<a name="ln1336">        {</a>
<a name="ln1337">            dhp::smr::set_memory_allocator( alloc_func, free_func );</a>
<a name="ln1338">        }</a>
<a name="ln1339"> </a>
<a name="ln1340">        /// Retire pointer \p p with function \p pFunc</a>
<a name="ln1341">        /**</a>
<a name="ln1342">            The function places pointer \p p to array of pointers ready for removing.</a>
<a name="ln1343">            (so called retired pointer array). The pointer can be safely removed when no hazard pointer points to it.</a>
<a name="ln1344">            \p func is a disposer: when \p p can be safely removed, \p func is called.</a>
<a name="ln1345">        */</a>
<a name="ln1346">        template &lt;typename T&gt;</a>
<a name="ln1347">        static void retire( T * p, void (* func)(void *))</a>
<a name="ln1348">        {</a>
<a name="ln1349">            dhp::thread_data* rec = dhp::smr::tls();</a>
<a name="ln1350">            if ( !rec-&gt;retired_.push( dhp::retired_ptr( p, func )))</a>
<a name="ln1351">                dhp::smr::instance().scan( rec );</a>
<a name="ln1352">        }</a>
<a name="ln1353"> </a>
<a name="ln1354">        /// Retire pointer \p p with functor of type \p Disposer</a>
<a name="ln1355">        /**</a>
<a name="ln1356">            The function places pointer \p p to array of pointers ready for removing.</a>
<a name="ln1357">            (so called retired pointer array). The pointer can be safely removed when no hazard pointer points to it.</a>
<a name="ln1358"> </a>
<a name="ln1359">            Deleting the pointer is an invocation of some object of type \p Disposer; the interface of \p Disposer is:</a>
<a name="ln1360">            \code</a>
<a name="ln1361">            template &lt;typename T&gt;</a>
<a name="ln1362">            struct disposer {</a>
<a name="ln1363">                void operator()( T * p )    ;   // disposing operator</a>
<a name="ln1364">            };</a>
<a name="ln1365">            \endcode</a>
<a name="ln1366">            Since the functor call can happen at any time after \p retire() call, additional restrictions are imposed to \p Disposer type:</a>
<a name="ln1367">            - it should be stateless functor</a>
<a name="ln1368">            - it should be default-constructible</a>
<a name="ln1369">            - the result of functor call with argument \p p should not depend on where the functor will be called.</a>
<a name="ln1370"> </a>
<a name="ln1371">            \par Examples:</a>
<a name="ln1372">            Operator \p delete functor:</a>
<a name="ln1373">            \code</a>
<a name="ln1374">            template &lt;typename T&gt;</a>
<a name="ln1375">            struct disposer {</a>
<a name="ln1376">                void operator ()( T * p ) {</a>
<a name="ln1377">                    delete p;</a>
<a name="ln1378">                }</a>
<a name="ln1379">            };</a>
<a name="ln1380"> </a>
<a name="ln1381">            // How to call HP::retire method</a>
<a name="ln1382">            int * p = new int;</a>
<a name="ln1383"> </a>
<a name="ln1384">            // ... use p in lock-free manner</a>
<a name="ln1385"> </a>
<a name="ln1386">            cds::gc::DHP::retire&lt;disposer&gt;( p ) ;   // place p to retired pointer array of DHP SMR</a>
<a name="ln1387">            \endcode</a>
<a name="ln1388"> </a>
<a name="ln1389">            Functor based on \p std::allocator :</a>
<a name="ln1390">            \code</a>
<a name="ln1391">            template &lt;typename Alloc = std::allocator&lt;int&gt; &gt;</a>
<a name="ln1392">            struct disposer {</a>
<a name="ln1393">                template &lt;typename T&gt;</a>
<a name="ln1394">                void operator()( T * p ) {</a>
<a name="ln1395">                    typedef typename Alloc::templare rebind&lt;T&gt;::other alloc_t;</a>
<a name="ln1396">                    alloc_t a;</a>
<a name="ln1397">                    a.destroy( p );</a>
<a name="ln1398">                    a.deallocate( p, 1 );</a>
<a name="ln1399">                }</a>
<a name="ln1400">            };</a>
<a name="ln1401">            \endcode</a>
<a name="ln1402">        */</a>
<a name="ln1403">        template &lt;class Disposer, typename T&gt;</a>
<a name="ln1404">        static void retire( T* p )</a>
<a name="ln1405">        {</a>
<a name="ln1406">            if ( !dhp::smr::tls()-&gt;retired_.push( dhp::retired_ptr( p, +[]( void* p ) { Disposer()( static_cast&lt;T*&gt;( p )); })))</a>
<a name="ln1407">                scan();</a>
<a name="ln1408">        }</a>
<a name="ln1409"> </a>
<a name="ln1410">        /// Checks if Dynamic Hazard Pointer GC is constructed and may be used</a>
<a name="ln1411">        static bool isUsed()</a>
<a name="ln1412">        {</a>
<a name="ln1413">            return dhp::smr::isUsed();</a>
<a name="ln1414">        }</a>
<a name="ln1415"> </a>
<a name="ln1416">        /// Forced GC cycle call for current thread</a>
<a name="ln1417">        /**</a>
<a name="ln1418">            Usually, this function should not be called directly.</a>
<a name="ln1419">        */</a>
<a name="ln1420">        static void scan()</a>
<a name="ln1421">        {</a>
<a name="ln1422">            dhp::smr::instance().scan( dhp::smr::tls());</a>
<a name="ln1423">        }</a>
<a name="ln1424"> </a>
<a name="ln1425">        /// Synonym for \p scan()</a>
<a name="ln1426">        static void force_dispose()</a>
<a name="ln1427">        {</a>
<a name="ln1428">            scan();</a>
<a name="ln1429">        }</a>
<a name="ln1430"> </a>
<a name="ln1431">        /// Returns internal statistics</a>
<a name="ln1432">        /**</a>
<a name="ln1433">            The function clears \p st before gathering statistics.</a>
<a name="ln1434"> </a>
<a name="ln1435">            @note Internal statistics is available only if you compile</a>
<a name="ln1436">            \p libcds and your program with \p -DCDS_ENABLE_HPSTAT.</a>
<a name="ln1437">        */</a>
<a name="ln1438">        static void statistics( stat&amp; st )</a>
<a name="ln1439">        {</a>
<a name="ln1440">            dhp::smr::instance().statistics( st );</a>
<a name="ln1441">        }</a>
<a name="ln1442"> </a>
<a name="ln1443">        /// Returns post-mortem statistics</a>
<a name="ln1444">        /**</a>
<a name="ln1445">            Post-mortem statistics is gathered in the \p %DHP object destructor</a>
<a name="ln1446">            and can be accessible after destructing the global \p %DHP object.</a>
<a name="ln1447"> </a>
<a name="ln1448">            @note Internal statistics is available only if you compile</a>
<a name="ln1449">            \p libcds and your program with \p -DCDS_ENABLE_HPSTAT.</a>
<a name="ln1450"> </a>
<a name="ln1451">            Usage:</a>
<a name="ln1452">            \code</a>
<a name="ln1453">            int main()</a>
<a name="ln1454">            {</a>
<a name="ln1455">                cds::Initialize();</a>
<a name="ln1456">                {</a>
<a name="ln1457">                    // Initialize DHP SMR</a>
<a name="ln1458">                    cds::gc::DHP dhp;</a>
<a name="ln1459"> </a>
<a name="ln1460">                    // deal with DHP-based data structured</a>
<a name="ln1461">                    // ...</a>
<a name="ln1462">                }</a>
<a name="ln1463"> </a>
<a name="ln1464">                // DHP object destroyed</a>
<a name="ln1465">                // Get total post-mortem statistics</a>
<a name="ln1466">                cds::gc::DHP::stat const&amp; st = cds::gc::DHP::postmortem_statistics();</a>
<a name="ln1467"> </a>
<a name="ln1468">                printf( &quot;DHP statistics:\n&quot;</a>
<a name="ln1469">                    &quot;  thread count           = %llu\n&quot;</a>
<a name="ln1470">                    &quot;  guard allocated        = %llu\n&quot;</a>
<a name="ln1471">                    &quot;  guard freed            = %llu\n&quot;</a>
<a name="ln1472">                    &quot;  retired data count     = %llu\n&quot;</a>
<a name="ln1473">                    &quot;  free data count        = %llu\n&quot;</a>
<a name="ln1474">                    &quot;  scan() call count      = %llu\n&quot;</a>
<a name="ln1475">                    &quot;  help_scan() call count = %llu\n&quot;,</a>
<a name="ln1476">                    st.thread_rec_count,</a>
<a name="ln1477">                    st.guard_allocated, st.guard_freed,</a>
<a name="ln1478">                    st.retired_count, st.free_count,</a>
<a name="ln1479">                    st.scan_count, st.help_scan_count</a>
<a name="ln1480">                );</a>
<a name="ln1481"> </a>
<a name="ln1482">                cds::Terminate();</a>
<a name="ln1483">            }</a>
<a name="ln1484">            \endcode</a>
<a name="ln1485">        */</a>
<a name="ln1486">        CDS_EXPORT_API static stat const&amp; postmortem_statistics();</a>
<a name="ln1487">    };</a>
<a name="ln1488"> </a>
<a name="ln1489">}} // namespace cds::gc</a>
<a name="ln1490"> </a>
<a name="ln1491">#endif // #ifndef CDSLIB_GC_DHP_SMR_H</a>
<a name="ln1492"> </a>
<a name="ln1493"> </a>

</code></pre>
<div class="balloon" rel="454"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: pad1_, pad2_.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
