
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>db_bench_tool.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//  Copyright (c) 2011-present, Facebook, Inc.  All rights reserved.</a>
<a name="ln2">//  This source code is licensed under the BSD-style license found in the</a>
<a name="ln3">//  LICENSE file in the root directory of this source tree. An additional grant</a>
<a name="ln4">//  of patent rights can be found in the PATENTS file in the same directory.</a>
<a name="ln5">//</a>
<a name="ln6">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln7">//</a>
<a name="ln8">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln9">//</a>
<a name="ln10">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln11">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln12">//</a>
<a name="ln13">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln14">//</a>
<a name="ln15">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln16">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln17">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln18">// under the License.</a>
<a name="ln19">//</a>
<a name="ln20">// Copyright (c) 2011 The LevelDB Authors. All rights reserved.</a>
<a name="ln21">// Use of this source code is governed by a BSD-style license that can be</a>
<a name="ln22">// found in the LICENSE file. See the AUTHORS file for names of contributors.</a>
<a name="ln23"> </a>
<a name="ln24">#ifndef __STDC_FORMAT_MACROS</a>
<a name="ln25">#define __STDC_FORMAT_MACROS</a>
<a name="ln26">#endif</a>
<a name="ln27"> </a>
<a name="ln28">#ifdef GFLAGS</a>
<a name="ln29">#ifdef NUMA</a>
<a name="ln30">#include &lt;numa.h&gt;</a>
<a name="ln31">#include &lt;numaif.h&gt;</a>
<a name="ln32">#endif</a>
<a name="ln33"> </a>
<a name="ln34">#ifndef OS_WIN</a>
<a name="ln35">#include &lt;unistd.h&gt;</a>
<a name="ln36">#endif</a>
<a name="ln37">#include &lt;fcntl.h&gt;</a>
<a name="ln38">#include &lt;inttypes.h&gt;</a>
<a name="ln39">#include &lt;sys/types.h&gt;</a>
<a name="ln40">#include &lt;stdio.h&gt;</a>
<a name="ln41">#include &lt;stdlib.h&gt;</a>
<a name="ln42"> </a>
<a name="ln43">#include &lt;atomic&gt;</a>
<a name="ln44">#include &lt;condition_variable&gt;</a>
<a name="ln45">#include &lt;cstddef&gt;</a>
<a name="ln46">#include &lt;mutex&gt;</a>
<a name="ln47">#include &lt;thread&gt;</a>
<a name="ln48">#include &lt;unordered_map&gt;</a>
<a name="ln49"> </a>
<a name="ln50">#include &lt;gflags/gflags.h&gt;</a>
<a name="ln51"> </a>
<a name="ln52">#include &quot;yb/rocksdb/db/db_impl.h&quot;</a>
<a name="ln53">#include &quot;yb/rocksdb/db/version_set.h&quot;</a>
<a name="ln54">#include &quot;yb/rocksdb/options.h&quot;</a>
<a name="ln55">#include &quot;yb/rocksdb/cache.h&quot;</a>
<a name="ln56">#include &quot;yb/rocksdb/db.h&quot;</a>
<a name="ln57">#include &quot;yb/rocksdb/env.h&quot;</a>
<a name="ln58">#include &quot;yb/rocksdb/memtablerep.h&quot;</a>
<a name="ln59">#include &quot;yb/rocksdb/write_batch.h&quot;</a>
<a name="ln60">#include &quot;yb/util/slice.h&quot;</a>
<a name="ln61">#include &quot;yb/rocksdb/filter_policy.h&quot;</a>
<a name="ln62">#include &quot;yb/rocksdb/rate_limiter.h&quot;</a>
<a name="ln63">#include &quot;yb/rocksdb/slice_transform.h&quot;</a>
<a name="ln64">#include &quot;yb/rocksdb/perf_context.h&quot;</a>
<a name="ln65">#include &quot;yb/rocksdb/utilities/flashcache.h&quot;</a>
<a name="ln66">#include &quot;yb/rocksdb/utilities/transaction.h&quot;</a>
<a name="ln67">#include &quot;yb/rocksdb/utilities/transaction_db.h&quot;</a>
<a name="ln68">#include &quot;yb/rocksdb/utilities/optimistic_transaction_db.h&quot;</a>
<a name="ln69">#include &quot;yb/rocksdb/port/port.h&quot;</a>
<a name="ln70">#include &quot;yb/rocksdb/port/stack_trace.h&quot;</a>
<a name="ln71">#include &quot;yb/rocksdb/util/crc32c.h&quot;</a>
<a name="ln72">#include &quot;yb/rocksdb/util/compression.h&quot;</a>
<a name="ln73">#include &quot;yb/rocksdb/util/histogram.h&quot;</a>
<a name="ln74">#include &quot;yb/rocksdb/util/mutexlock.h&quot;</a>
<a name="ln75">#include &quot;yb/rocksdb/util/random.h&quot;</a>
<a name="ln76">#include &quot;yb/util/string_util.h&quot;</a>
<a name="ln77">#include &quot;yb/rocksdb/util/statistics.h&quot;</a>
<a name="ln78">#include &quot;yb/rocksdb/util/testutil.h&quot;</a>
<a name="ln79">#include &quot;yb/rocksdb/util/xxhash.h&quot;</a>
<a name="ln80">#include &quot;yb/rocksdb/hdfs/env_hdfs.h&quot;</a>
<a name="ln81">#include &quot;yb/rocksdb/utilities/merge_operators.h&quot;</a>
<a name="ln82"> </a>
<a name="ln83">#ifdef OS_WIN</a>
<a name="ln84">#include &lt;io.h&gt;  // open/close</a>
<a name="ln85">#endif</a>
<a name="ln86"> </a>
<a name="ln87">namespace {</a>
<a name="ln88">using GFLAGS::ParseCommandLineFlags;</a>
<a name="ln89">using GFLAGS::RegisterFlagValidator;</a>
<a name="ln90">using GFLAGS::SetUsageMessage;</a>
<a name="ln91"> </a>
<a name="ln92">DEFINE_string(benchmarks,</a>
<a name="ln93">              &quot;fillseq,&quot;</a>
<a name="ln94">              &quot;fillsync,&quot;</a>
<a name="ln95">              &quot;fillrandom,&quot;</a>
<a name="ln96">              &quot;overwrite,&quot;</a>
<a name="ln97">              &quot;readrandom,&quot;</a>
<a name="ln98">              &quot;newiterator,&quot;</a>
<a name="ln99">              &quot;newiteratorwhilewriting,&quot;</a>
<a name="ln100">              &quot;seekrandom,&quot;</a>
<a name="ln101">              &quot;seekrandomwhilewriting,&quot;</a>
<a name="ln102">              &quot;seekrandomwhilemerging,&quot;</a>
<a name="ln103">              &quot;readseq,&quot;</a>
<a name="ln104">              &quot;readreverse,&quot;</a>
<a name="ln105">              &quot;compact,&quot;</a>
<a name="ln106">              &quot;readrandom,&quot;</a>
<a name="ln107">              &quot;multireadrandom,&quot;</a>
<a name="ln108">              &quot;readseq,&quot;</a>
<a name="ln109">              &quot;readtocache,&quot;</a>
<a name="ln110">              &quot;readreverse,&quot;</a>
<a name="ln111">              &quot;readwhilewriting,&quot;</a>
<a name="ln112">              &quot;readwhilemerging,&quot;</a>
<a name="ln113">              &quot;readrandomwriterandom,&quot;</a>
<a name="ln114">              &quot;updaterandom,&quot;</a>
<a name="ln115">              &quot;randomwithverify,&quot;</a>
<a name="ln116">              &quot;fill100K,&quot;</a>
<a name="ln117">              &quot;crc32c,&quot;</a>
<a name="ln118">              &quot;xxhash,&quot;</a>
<a name="ln119">              &quot;compress,&quot;</a>
<a name="ln120">              &quot;uncompress,&quot;</a>
<a name="ln121">              &quot;acquireload,&quot;</a>
<a name="ln122">              &quot;fillseekseq,&quot;</a>
<a name="ln123">              &quot;randomtransaction,&quot;</a>
<a name="ln124">              &quot;randomreplacekeys&quot;,</a>
<a name="ln125"> </a>
<a name="ln126">              &quot;Comma-separated list of operations to run in the specified&quot;</a>
<a name="ln127">              &quot; order. Available benchmarks:\n&quot;</a>
<a name="ln128">              &quot;\tfillseq       -- write N values in sequential key&quot;</a>
<a name="ln129">              &quot; order in async mode\n&quot;</a>
<a name="ln130">              &quot;\tfillrandom    -- write N values in random key order in async&quot;</a>
<a name="ln131">              &quot; mode\n&quot;</a>
<a name="ln132">              &quot;\toverwrite     -- overwrite N values in random key order in&quot;</a>
<a name="ln133">              &quot; async mode\n&quot;</a>
<a name="ln134">              &quot;\tfillsync      -- write N/100 values in random key order in &quot;</a>
<a name="ln135">              &quot;sync mode\n&quot;</a>
<a name="ln136">              &quot;\tfill100K      -- write N/1000 100K values in random order in&quot;</a>
<a name="ln137">              &quot; async mode\n&quot;</a>
<a name="ln138">              &quot;\tdeleteseq     -- delete N keys in sequential order\n&quot;</a>
<a name="ln139">              &quot;\tdeleterandom  -- delete N keys in random order\n&quot;</a>
<a name="ln140">              &quot;\treadseq       -- read N times sequentially\n&quot;</a>
<a name="ln141">              &quot;\treadtocache   -- 1 thread reading database sequentially\n&quot;</a>
<a name="ln142">              &quot;\treadreverse   -- read N times in reverse order\n&quot;</a>
<a name="ln143">              &quot;\treadrandom    -- read N times in random order\n&quot;</a>
<a name="ln144">              &quot;\treadmissing   -- read N missing keys in random order\n&quot;</a>
<a name="ln145">              &quot;\treadwhilewriting      -- 1 writer, N threads doing random &quot;</a>
<a name="ln146">              &quot;reads\n&quot;</a>
<a name="ln147">              &quot;\treadwhilemerging      -- 1 merger, N threads doing random &quot;</a>
<a name="ln148">              &quot;reads\n&quot;</a>
<a name="ln149">              &quot;\treadrandomwriterandom -- N threads doing random-read, &quot;</a>
<a name="ln150">              &quot;random-write\n&quot;</a>
<a name="ln151">              &quot;\tprefixscanrandom      -- prefix scan N times in random order\n&quot;</a>
<a name="ln152">              &quot;\tupdaterandom  -- N threads doing read-modify-write for random &quot;</a>
<a name="ln153">              &quot;keys\n&quot;</a>
<a name="ln154">              &quot;\tappendrandom  -- N threads doing read-modify-write with &quot;</a>
<a name="ln155">              &quot;growing values\n&quot;</a>
<a name="ln156">              &quot;\tmergerandom   -- same as updaterandom/appendrandom using merge&quot;</a>
<a name="ln157">              &quot; operator. &quot;</a>
<a name="ln158">              &quot;Must be used with merge_operator\n&quot;</a>
<a name="ln159">              &quot;\treadrandommergerandom -- perform N random read-or-merge &quot;</a>
<a name="ln160">              &quot;operations. Must be used with merge_operator\n&quot;</a>
<a name="ln161">              &quot;\tnewiterator   -- repeated iterator creation\n&quot;</a>
<a name="ln162">              &quot;\tseekrandom    -- N random seeks, call Next seek_nexts times &quot;</a>
<a name="ln163">              &quot;per seek\n&quot;</a>
<a name="ln164">              &quot;\tseekrandomwhilewriting -- seekrandom and 1 thread doing &quot;</a>
<a name="ln165">              &quot;overwrite\n&quot;</a>
<a name="ln166">              &quot;\tseekrandomwhilemerging -- seekrandom and 1 thread doing &quot;</a>
<a name="ln167">              &quot;merge\n&quot;</a>
<a name="ln168">              &quot;\tcrc32c        -- repeated crc32c of 4K of data\n&quot;</a>
<a name="ln169">              &quot;\txxhash        -- repeated xxHash of 4K of data\n&quot;</a>
<a name="ln170">              &quot;\tacquireload   -- load N*1000 times\n&quot;</a>
<a name="ln171">              &quot;\tfillseekseq   -- write N values in sequential key, then read &quot;</a>
<a name="ln172">              &quot;them by seeking to each key\n&quot;</a>
<a name="ln173">              &quot;\trandomtransaction     -- execute N random transactions and &quot;</a>
<a name="ln174">              &quot;verify correctness\n&quot;</a>
<a name="ln175">              &quot;\trandomreplacekeys     -- randomly replaces N keys by deleting &quot;</a>
<a name="ln176">              &quot;the old version and putting the new version\n\n&quot;</a>
<a name="ln177">              &quot;Meta operations:\n&quot;</a>
<a name="ln178">              &quot;\tcompact     -- Compact the entire DB\n&quot;</a>
<a name="ln179">              &quot;\tstats       -- Print DB stats\n&quot;</a>
<a name="ln180">              &quot;\tlevelstats  -- Print the number of files and bytes per level\n&quot;</a>
<a name="ln181">              &quot;\tsstables    -- Print sstable info\n&quot;</a>
<a name="ln182">              &quot;\theapprofile -- Dump a heap profile (if supported by this&quot;</a>
<a name="ln183">              &quot; port)\n&quot;);</a>
<a name="ln184"> </a>
<a name="ln185">DEFINE_int64(num, 1000000, &quot;Number of key/values to place in database&quot;);</a>
<a name="ln186"> </a>
<a name="ln187">DEFINE_int64(numdistinct, 1000,</a>
<a name="ln188">             &quot;Number of distinct keys to use. Used in RandomWithVerify to &quot;</a>
<a name="ln189">             &quot;read/write on fewer keys so that gets are more likely to find the&quot;</a>
<a name="ln190">             &quot; key and puts are more likely to update the same key&quot;);</a>
<a name="ln191"> </a>
<a name="ln192">DEFINE_int64(merge_keys, -1,</a>
<a name="ln193">             &quot;Number of distinct keys to use for MergeRandom and &quot;</a>
<a name="ln194">             &quot;ReadRandomMergeRandom. &quot;</a>
<a name="ln195">             &quot;If negative, there will be FLAGS_num keys.&quot;);</a>
<a name="ln196">DEFINE_int32(num_column_families, 1, &quot;Number of Column Families to use.&quot;);</a>
<a name="ln197"> </a>
<a name="ln198">DEFINE_int32(</a>
<a name="ln199">    num_hot_column_families, 0,</a>
<a name="ln200">    &quot;Number of Hot Column Families. If more than 0, only write to this &quot;</a>
<a name="ln201">    &quot;number of column families. After finishing all the writes to them, &quot;</a>
<a name="ln202">    &quot;create new set of column families and insert to them. Only used &quot;</a>
<a name="ln203">    &quot;when num_column_families &gt; 1.&quot;);</a>
<a name="ln204"> </a>
<a name="ln205">DEFINE_int64(reads, -1, &quot;Number of read operations to do.  &quot;</a>
<a name="ln206">             &quot;If negative, do FLAGS_num reads.&quot;);</a>
<a name="ln207"> </a>
<a name="ln208">DEFINE_int32(bloom_locality, 0, &quot;Control bloom filter probes locality&quot;);</a>
<a name="ln209"> </a>
<a name="ln210">DEFINE_int64(seed, 0, &quot;Seed base for random number generators. &quot;</a>
<a name="ln211">             &quot;When 0 it is deterministic.&quot;);</a>
<a name="ln212"> </a>
<a name="ln213">DEFINE_int32(threads, 1, &quot;Number of concurrent threads to run.&quot;);</a>
<a name="ln214"> </a>
<a name="ln215">DEFINE_int32(duration, 0, &quot;Time in seconds for the random-ops tests to run.&quot;</a>
<a name="ln216">             &quot; When 0 then num &amp; reads determine the test duration&quot;);</a>
<a name="ln217"> </a>
<a name="ln218">DEFINE_int32(value_size, 100, &quot;Size of each value&quot;);</a>
<a name="ln219"> </a>
<a name="ln220">DEFINE_int32(seek_nexts, 0,</a>
<a name="ln221">             &quot;How many times to call Next() after Seek() in &quot;</a>
<a name="ln222">             &quot;fillseekseq, seekrandom, seekrandomwhilewriting and &quot;</a>
<a name="ln223">             &quot;seekrandomwhilemerging&quot;);</a>
<a name="ln224"> </a>
<a name="ln225">DEFINE_bool(reverse_iterator, false,</a>
<a name="ln226">            &quot;When true use Prev rather than Next for iterators that do &quot;</a>
<a name="ln227">            &quot;Seek and then Next&quot;);</a>
<a name="ln228"> </a>
<a name="ln229">DEFINE_bool(use_uint64_comparator, false, &quot;use Uint64 user comparator&quot;);</a>
<a name="ln230"> </a>
<a name="ln231">DEFINE_int64(batch_size, 1, &quot;Batch size&quot;);</a>
<a name="ln232"> </a>
<a name="ln233">static bool ValidateKeySize(const char* flagname, int32_t value) {</a>
<a name="ln234">  return true;</a>
<a name="ln235">}</a>
<a name="ln236"> </a>
<a name="ln237">static bool ValidateUint32Range(const char* flagname, uint64_t value) {</a>
<a name="ln238">  if (value &gt; std::numeric_limits&lt;uint32_t&gt;::max()) {</a>
<a name="ln239">    fprintf(stderr, &quot;Invalid value for --%s: %&quot; PRIu64 &quot;, overflow\n&quot;, flagname, value);</a>
<a name="ln240">    return false;</a>
<a name="ln241">  }</a>
<a name="ln242">  return true;</a>
<a name="ln243">}</a>
<a name="ln244"> </a>
<a name="ln245">DEFINE_int32(key_size, 16, &quot;size of each key&quot;);</a>
<a name="ln246"> </a>
<a name="ln247">DEFINE_int32(num_multi_db, 0,</a>
<a name="ln248">             &quot;Number of DBs used in the benchmark. 0 means single DB.&quot;);</a>
<a name="ln249"> </a>
<a name="ln250">DEFINE_double(compression_ratio, 0.5, &quot;Arrange to generate values that shrink&quot;</a>
<a name="ln251">              &quot; to this fraction of their original size after compression&quot;);</a>
<a name="ln252"> </a>
<a name="ln253">DEFINE_double(read_random_exp_range, 0.0,</a>
<a name="ln254">              &quot;Read random's key will be generated using distribution of &quot;</a>
<a name="ln255">              &quot;num * exp(-r) where r is uniform number from 0 to this value. &quot;</a>
<a name="ln256">              &quot;The larger the number is, the more skewed the reads are. &quot;</a>
<a name="ln257">              &quot;Only used in readrandom and multireadrandom benchmarks.&quot;);</a>
<a name="ln258"> </a>
<a name="ln259">DEFINE_bool(histogram, false, &quot;Print histogram of operation timings&quot;);</a>
<a name="ln260"> </a>
<a name="ln261">DEFINE_bool(enable_numa, false,</a>
<a name="ln262">            &quot;Make operations aware of NUMA architecture and bind memory &quot;</a>
<a name="ln263">            &quot;and cpus corresponding to nodes together. In NUMA, memory &quot;</a>
<a name="ln264">            &quot;in same node as CPUs are closer when compared to memory in &quot;</a>
<a name="ln265">            &quot;other nodes. Reads can be faster when the process is bound to &quot;</a>
<a name="ln266">            &quot;CPU and memory of same node. Use \&quot;$numactl --hardware\&quot; command &quot;</a>
<a name="ln267">            &quot;to see NUMA memory architecture.&quot;);</a>
<a name="ln268"> </a>
<a name="ln269">DEFINE_int64(db_write_buffer_size, rocksdb::Options().db_write_buffer_size,</a>
<a name="ln270">             &quot;Number of bytes to buffer in all memtables before compacting&quot;);</a>
<a name="ln271"> </a>
<a name="ln272">DEFINE_int64(write_buffer_size, rocksdb::Options().write_buffer_size,</a>
<a name="ln273">             &quot;Number of bytes to buffer in memtable before compacting&quot;);</a>
<a name="ln274"> </a>
<a name="ln275">DEFINE_int32(max_write_buffer_number,</a>
<a name="ln276">             rocksdb::Options().max_write_buffer_number,</a>
<a name="ln277">             &quot;The number of in-memory memtables. Each memtable is of size&quot;</a>
<a name="ln278">             &quot;write_buffer_size.&quot;);</a>
<a name="ln279"> </a>
<a name="ln280">DEFINE_int32(min_write_buffer_number_to_merge,</a>
<a name="ln281">             rocksdb::Options().min_write_buffer_number_to_merge,</a>
<a name="ln282">             &quot;The minimum number of write buffers that will be merged together&quot;</a>
<a name="ln283">             &quot;before writing to storage. This is cheap because it is an&quot;</a>
<a name="ln284">             &quot;in-memory merge. If this feature is not enabled, then all these&quot;</a>
<a name="ln285">             &quot;write buffers are flushed to L0 as separate files and this &quot;</a>
<a name="ln286">             &quot;increases read amplification because a get request has to check&quot;</a>
<a name="ln287">             &quot; in all of these files. Also, an in-memory merge may result in&quot;</a>
<a name="ln288">             &quot; writing less data to storage if there are duplicate records &quot;</a>
<a name="ln289">             &quot; in each of these individual write buffers.&quot;);</a>
<a name="ln290"> </a>
<a name="ln291">DEFINE_int32(max_write_buffer_number_to_maintain,</a>
<a name="ln292">             rocksdb::Options().max_write_buffer_number_to_maintain,</a>
<a name="ln293">             &quot;The total maximum number of write buffers to maintain in memory &quot;</a>
<a name="ln294">             &quot;including copies of buffers that have already been flushed. &quot;</a>
<a name="ln295">             &quot;Unlike max_write_buffer_number, this parameter does not affect &quot;</a>
<a name="ln296">             &quot;flushing. This controls the minimum amount of write history &quot;</a>
<a name="ln297">             &quot;that will be available in memory for conflict checking when &quot;</a>
<a name="ln298">             &quot;Transactions are used. If this value is too low, some &quot;</a>
<a name="ln299">             &quot;transactions may fail at commit time due to not being able to &quot;</a>
<a name="ln300">             &quot;determine whether there were any write conflicts. Setting this &quot;</a>
<a name="ln301">             &quot;value to 0 will cause write buffers to be freed immediately &quot;</a>
<a name="ln302">             &quot;after they are flushed.  If this value is set to -1, &quot;</a>
<a name="ln303">             &quot;'max_write_buffer_number' will be used.&quot;);</a>
<a name="ln304"> </a>
<a name="ln305">DEFINE_int32(max_background_compactions,</a>
<a name="ln306">             rocksdb::Options().max_background_compactions,</a>
<a name="ln307">             &quot;The maximum number of concurrent background compactions&quot;</a>
<a name="ln308">             &quot; that can occur in parallel.&quot;);</a>
<a name="ln309"> </a>
<a name="ln310">DEFINE_uint64(subcompactions, 1,</a>
<a name="ln311">              &quot;Maximum number of subcompactions to divide L0-L1 compactions &quot;</a>
<a name="ln312">              &quot;into.&quot;);</a>
<a name="ln313">static const bool FLAGS_subcompactions_dummy</a>
<a name="ln314">    __attribute__((unused)) = RegisterFlagValidator(&amp;FLAGS_subcompactions,</a>
<a name="ln315">                                                    &amp;ValidateUint32Range);</a>
<a name="ln316"> </a>
<a name="ln317">DEFINE_int32(max_background_flushes,</a>
<a name="ln318">             rocksdb::Options().max_background_flushes,</a>
<a name="ln319">             &quot;The maximum number of concurrent background flushes&quot;</a>
<a name="ln320">             &quot; that can occur in parallel.&quot;);</a>
<a name="ln321"> </a>
<a name="ln322">static rocksdb::CompactionStyle FLAGS_compaction_style_e;</a>
<a name="ln323">DEFINE_int32(compaction_style, (int32_t) rocksdb::Options().compaction_style,</a>
<a name="ln324">             &quot;style of compaction: level-based vs universal&quot;);</a>
<a name="ln325"> </a>
<a name="ln326">static rocksdb::CompactionPri FLAGS_compaction_pri_e;</a>
<a name="ln327">DEFINE_int32(compaction_pri, (int32_t)rocksdb::Options().compaction_pri,</a>
<a name="ln328">             &quot;priority of files to compaction: by size or by data age&quot;);</a>
<a name="ln329"> </a>
<a name="ln330">DEFINE_int32(universal_size_ratio, 0,</a>
<a name="ln331">             &quot;Percentage flexibility while comparing file size&quot;</a>
<a name="ln332">             &quot; (for universal compaction only).&quot;);</a>
<a name="ln333"> </a>
<a name="ln334">DEFINE_int32(universal_min_merge_width, 0, &quot;The minimum number of files in a&quot;</a>
<a name="ln335">             &quot; single compaction run (for universal compaction only).&quot;);</a>
<a name="ln336"> </a>
<a name="ln337">DEFINE_int32(universal_max_merge_width, 0, &quot;The max number of files to compact&quot;</a>
<a name="ln338">             &quot; in universal style compaction&quot;);</a>
<a name="ln339"> </a>
<a name="ln340">DEFINE_int32(universal_max_size_amplification_percent, 0,</a>
<a name="ln341">             &quot;The max size amplification for universal style compaction&quot;);</a>
<a name="ln342"> </a>
<a name="ln343">DEFINE_int32(universal_compression_size_percent, -1,</a>
<a name="ln344">             &quot;The percentage of the database to compress for universal &quot;</a>
<a name="ln345">             &quot;compaction. -1 means compress everything.&quot;);</a>
<a name="ln346"> </a>
<a name="ln347">DEFINE_bool(universal_allow_trivial_move, false,</a>
<a name="ln348">            &quot;Allow trivial move in universal compaction.&quot;);</a>
<a name="ln349"> </a>
<a name="ln350">DEFINE_int64(cache_size, -1, &quot;Number of bytes to use as a cache of uncompressed&quot;</a>
<a name="ln351">             &quot;data. Negative means use default settings.&quot;);</a>
<a name="ln352"> </a>
<a name="ln353">DEFINE_bool(cache_index_and_filter_blocks, false,</a>
<a name="ln354">            &quot;Cache index/filter blocks in block cache.&quot;);</a>
<a name="ln355"> </a>
<a name="ln356">DEFINE_int32(block_size,</a>
<a name="ln357">             static_cast&lt;int32_t&gt;(rocksdb::BlockBasedTableOptions().block_size),</a>
<a name="ln358">             &quot;Number of bytes in a block.&quot;);</a>
<a name="ln359"> </a>
<a name="ln360">DEFINE_int32(block_restart_interval,</a>
<a name="ln361">             rocksdb::BlockBasedTableOptions().block_restart_interval,</a>
<a name="ln362">             &quot;Number of keys between restart points &quot;</a>
<a name="ln363">             &quot;for delta encoding of keys.&quot;);</a>
<a name="ln364"> </a>
<a name="ln365">DEFINE_int64(compressed_cache_size, -1,</a>
<a name="ln366">             &quot;Number of bytes to use as a cache of compressed data.&quot;);</a>
<a name="ln367"> </a>
<a name="ln368">DEFINE_int64(row_cache_size, 0,</a>
<a name="ln369">             &quot;Number of bytes to use as a cache of individual rows&quot;</a>
<a name="ln370">             &quot; (0 = disabled).&quot;);</a>
<a name="ln371"> </a>
<a name="ln372">DEFINE_int32(open_files, rocksdb::Options().max_open_files,</a>
<a name="ln373">             &quot;Maximum number of files to keep open at the same time&quot;</a>
<a name="ln374">             &quot; (use default if == 0)&quot;);</a>
<a name="ln375"> </a>
<a name="ln376">DEFINE_int32(file_opening_threads, rocksdb::Options().max_file_opening_threads,</a>
<a name="ln377">             &quot;If open_files is set to -1, this option set the number of &quot;</a>
<a name="ln378">             &quot;threads that will be used to open files during DB::Open()&quot;);</a>
<a name="ln379"> </a>
<a name="ln380">DEFINE_int32(new_table_reader_for_compaction_inputs, true,</a>
<a name="ln381">             &quot;If true, uses a separate file handle for compaction inputs&quot;);</a>
<a name="ln382"> </a>
<a name="ln383">DEFINE_int32(compaction_readahead_size, 0, &quot;Compaction readahead size&quot;);</a>
<a name="ln384"> </a>
<a name="ln385">DEFINE_int32(random_access_max_buffer_size, 1024 * 1024,</a>
<a name="ln386">             &quot;Maximum windows randomaccess buffer size&quot;);</a>
<a name="ln387"> </a>
<a name="ln388">DEFINE_int32(writable_file_max_buffer_size, 1024 * 1024,</a>
<a name="ln389">             &quot;Maximum write buffer for Writable File&quot;);</a>
<a name="ln390"> </a>
<a name="ln391">DEFINE_int32(skip_table_builder_flush, false, &quot;Skip flushing block in &quot;</a>
<a name="ln392">             &quot;table builder &quot;);</a>
<a name="ln393"> </a>
<a name="ln394">DEFINE_int32(bloom_bits, -1, &quot;Bloom filter bits per key. Negative means&quot;</a>
<a name="ln395">             &quot; use default settings.&quot;);</a>
<a name="ln396">DEFINE_int32(memtable_bloom_bits, 0, &quot;Bloom filter bits per key for memtable. &quot;</a>
<a name="ln397">             &quot;Negative means no bloom filter.&quot;);</a>
<a name="ln398"> </a>
<a name="ln399">DEFINE_bool(use_existing_db, false, &quot;If true, do not destroy the existing&quot;</a>
<a name="ln400">            &quot; database.  If you set this flag and also specify a benchmark that&quot;</a>
<a name="ln401">            &quot; wants a fresh database, that benchmark will fail.&quot;);</a>
<a name="ln402"> </a>
<a name="ln403">DEFINE_bool(show_table_properties, false,</a>
<a name="ln404">            &quot;If true, then per-level table&quot;</a>
<a name="ln405">            &quot; properties will be printed on every stats-interval when&quot;</a>
<a name="ln406">            &quot; stats_interval is set and stats_per_interval is on.&quot;);</a>
<a name="ln407"> </a>
<a name="ln408">DEFINE_string(db, &quot;&quot;, &quot;Use the db with the following name.&quot;);</a>
<a name="ln409"> </a>
<a name="ln410">static bool ValidateCacheNumshardbits(const char* flagname, int32_t value) {</a>
<a name="ln411">  if (value &gt;= 20) {</a>
<a name="ln412">    fprintf(stderr, &quot;Invalid value for --%s: %d, must be &lt; 20\n&quot;,</a>
<a name="ln413">            flagname, value);</a>
<a name="ln414">    return false;</a>
<a name="ln415">  }</a>
<a name="ln416">  return true;</a>
<a name="ln417">}</a>
<a name="ln418">DEFINE_int32(cache_numshardbits, -1, &quot;Number of shards for the block cache&quot;</a>
<a name="ln419">             &quot; is 2 ** cache_numshardbits. Negative means use default settings.&quot;</a>
<a name="ln420">             &quot; This is applied only if FLAGS_cache_size is non-negative.&quot;);</a>
<a name="ln421"> </a>
<a name="ln422">DEFINE_bool(verify_checksum, false, &quot;Verify checksum for every block read&quot;</a>
<a name="ln423">            &quot; from storage&quot;);</a>
<a name="ln424"> </a>
<a name="ln425">DEFINE_bool(statistics, false, &quot;Database statistics&quot;);</a>
<a name="ln426">static class std::shared_ptr&lt;rocksdb::Statistics&gt; dbstats;</a>
<a name="ln427"> </a>
<a name="ln428">DEFINE_int64(writes, -1, &quot;Number of write operations to do. If negative, do&quot;</a>
<a name="ln429">             &quot; --num reads.&quot;);</a>
<a name="ln430"> </a>
<a name="ln431">DEFINE_bool(sync, false, &quot;Sync all writes to disk&quot;);</a>
<a name="ln432"> </a>
<a name="ln433">DEFINE_bool(disable_data_sync, false, &quot;If true, do not wait until data is&quot;</a>
<a name="ln434">            &quot; synced to disk.&quot;);</a>
<a name="ln435"> </a>
<a name="ln436">DEFINE_bool(use_fsync, false, &quot;If true, issue fsync instead of fdatasync&quot;);</a>
<a name="ln437"> </a>
<a name="ln438">DEFINE_bool(disable_wal, false, &quot;If true, do not write WAL for write.&quot;);</a>
<a name="ln439"> </a>
<a name="ln440">DEFINE_string(wal_dir, &quot;&quot;, &quot;If not empty, use the given dir for WAL&quot;);</a>
<a name="ln441"> </a>
<a name="ln442">DEFINE_int32(num_levels, 7, &quot;The total number of levels&quot;);</a>
<a name="ln443"> </a>
<a name="ln444">DEFINE_int64(target_file_size_base, 2 * 1048576, &quot;Target file size at level-1&quot;);</a>
<a name="ln445"> </a>
<a name="ln446">DEFINE_int32(target_file_size_multiplier, 1,</a>
<a name="ln447">             &quot;A multiplier to compute target level-N file size (N &gt;= 2)&quot;);</a>
<a name="ln448"> </a>
<a name="ln449">DEFINE_uint64(max_bytes_for_level_base,  10 * 1048576, &quot;Max bytes for level-1&quot;);</a>
<a name="ln450"> </a>
<a name="ln451">DEFINE_bool(level_compaction_dynamic_level_bytes, false,</a>
<a name="ln452">            &quot;Whether level size base is dynamic&quot;);</a>
<a name="ln453"> </a>
<a name="ln454">DEFINE_int32(max_bytes_for_level_multiplier, 10,</a>
<a name="ln455">             &quot;A multiplier to compute max bytes for level-N (N &gt;= 2)&quot;);</a>
<a name="ln456"> </a>
<a name="ln457">static std::vector&lt;int&gt; FLAGS_max_bytes_for_level_multiplier_additional_v;</a>
<a name="ln458">DEFINE_string(max_bytes_for_level_multiplier_additional, &quot;&quot;,</a>
<a name="ln459">              &quot;A vector that specifies additional fanout per level&quot;);</a>
<a name="ln460"> </a>
<a name="ln461">DEFINE_int32(level0_stop_writes_trigger,</a>
<a name="ln462">             rocksdb::Options().level0_stop_writes_trigger,</a>
<a name="ln463">             &quot;Number of files in level-0&quot;</a>
<a name="ln464">             &quot; that will trigger put stop.&quot;);</a>
<a name="ln465"> </a>
<a name="ln466">DEFINE_int32(level0_slowdown_writes_trigger,</a>
<a name="ln467">             rocksdb::Options().level0_slowdown_writes_trigger,</a>
<a name="ln468">             &quot;Number of files in level-0&quot;</a>
<a name="ln469">             &quot; that will slow down writes.&quot;);</a>
<a name="ln470"> </a>
<a name="ln471">DEFINE_int32(level0_file_num_compaction_trigger,</a>
<a name="ln472">             rocksdb::Options().level0_file_num_compaction_trigger,</a>
<a name="ln473">             &quot;Number of files in level-0&quot;</a>
<a name="ln474">             &quot; when compactions start&quot;);</a>
<a name="ln475"> </a>
<a name="ln476">static bool ValidateInt32Percent(const char* flagname, int32_t value) {</a>
<a name="ln477">  if (value &lt;= 0 || value &gt;= 100) {</a>
<a name="ln478">    fprintf(stderr, &quot;Invalid value for --%s: %d, 0&lt; pct &lt;100 \n&quot;,</a>
<a name="ln479">            flagname, value);</a>
<a name="ln480">    return false;</a>
<a name="ln481">  }</a>
<a name="ln482">  return true;</a>
<a name="ln483">}</a>
<a name="ln484"> </a>
<a name="ln485">DEFINE_int32(readwritepercent, 90, &quot;Ratio of reads to reads/writes (expressed&quot;</a>
<a name="ln486">             &quot; as percentage) for the ReadRandomWriteRandom workload. The &quot;</a>
<a name="ln487">             &quot;default value 90 means 90% operations out of all reads and writes&quot;</a>
<a name="ln488">             &quot; operations are reads. In other words, 9 gets for every 1 put.&quot;);</a>
<a name="ln489"> </a>
<a name="ln490">DEFINE_int32(mergereadpercent, 70, &quot;Ratio of merges to merges&amp;reads (expressed&quot;</a>
<a name="ln491">             &quot; as percentage) for the ReadRandomMergeRandom workload. The&quot;</a>
<a name="ln492">             &quot; default value 70 means 70% out of all read and merge operations&quot;</a>
<a name="ln493">             &quot; are merges. In other words, 7 merges for every 3 gets.&quot;);</a>
<a name="ln494"> </a>
<a name="ln495">DEFINE_int32(deletepercent, 2, &quot;Percentage of deletes out of reads/writes/&quot;</a>
<a name="ln496">             &quot;deletes (used in RandomWithVerify only). RandomWithVerify &quot;</a>
<a name="ln497">             &quot;calculates writepercent as (100 - FLAGS_readwritepercent - &quot;</a>
<a name="ln498">             &quot;deletepercent), so deletepercent must be smaller than (100 - &quot;</a>
<a name="ln499">             &quot;FLAGS_readwritepercent)&quot;);</a>
<a name="ln500"> </a>
<a name="ln501">DEFINE_uint64(delete_obsolete_files_period_micros, 0,</a>
<a name="ln502">              &quot;Ignored. Left here for backward compatibility&quot;);</a>
<a name="ln503"> </a>
<a name="ln504">#ifndef ROCKSDB_LITE</a>
<a name="ln505">DEFINE_bool(optimistic_transaction_db, false,</a>
<a name="ln506">            &quot;Open a OptimisticTransactionDB instance. &quot;</a>
<a name="ln507">            &quot;Required for randomtransaction benchmark.&quot;);</a>
<a name="ln508"> </a>
<a name="ln509">DEFINE_bool(transaction_db, false,</a>
<a name="ln510">            &quot;Open a TransactionDB instance. &quot;</a>
<a name="ln511">            &quot;Required for randomtransaction benchmark.&quot;);</a>
<a name="ln512"> </a>
<a name="ln513">DEFINE_uint64(transaction_sets, 2,</a>
<a name="ln514">              &quot;Number of keys each transaction will &quot;</a>
<a name="ln515">              &quot;modify (use in RandomTransaction only).  Max: 9999&quot;);</a>
<a name="ln516"> </a>
<a name="ln517">DEFINE_bool(transaction_set_snapshot, false,</a>
<a name="ln518">            &quot;Setting to true will have each transaction call SetSnapshot()&quot;</a>
<a name="ln519">            &quot; upon creation.&quot;);</a>
<a name="ln520"> </a>
<a name="ln521">DEFINE_int32(transaction_sleep, 0,</a>
<a name="ln522">             &quot;Max microseconds to sleep in between &quot;</a>
<a name="ln523">             &quot;reading and writing a value (used in RandomTransaction only). &quot;);</a>
<a name="ln524"> </a>
<a name="ln525">DEFINE_uint64(transaction_lock_timeout, 100,</a>
<a name="ln526">              &quot;If using a transaction_db, specifies the lock wait timeout in&quot;</a>
<a name="ln527">              &quot; milliseconds before failing a transaction waiting on a lock&quot;);</a>
<a name="ln528">#endif  // ROCKSDB_LITE</a>
<a name="ln529"> </a>
<a name="ln530">DEFINE_bool(compaction_measure_io_stats, false,</a>
<a name="ln531">            &quot;Measure times spents on I/Os while in compactions. &quot;);</a>
<a name="ln532"> </a>
<a name="ln533">enum rocksdb::CompressionType StringToCompressionType(const char* ctype) {</a>
<a name="ln534">  assert(ctype);</a>
<a name="ln535"> </a>
<a name="ln536">  if (!strcasecmp(ctype, &quot;none&quot;))</a>
<a name="ln537">    return rocksdb::kNoCompression;</a>
<a name="ln538">  else if (!strcasecmp(ctype, &quot;snappy&quot;))</a>
<a name="ln539">    return rocksdb::kSnappyCompression;</a>
<a name="ln540">  else if (!strcasecmp(ctype, &quot;zlib&quot;))</a>
<a name="ln541">    return rocksdb::kZlibCompression;</a>
<a name="ln542">  else if (!strcasecmp(ctype, &quot;bzip2&quot;))</a>
<a name="ln543">    return rocksdb::kBZip2Compression;</a>
<a name="ln544">  else if (!strcasecmp(ctype, &quot;lz4&quot;))</a>
<a name="ln545">    return rocksdb::kLZ4Compression;</a>
<a name="ln546">  else if (!strcasecmp(ctype, &quot;lz4hc&quot;))</a>
<a name="ln547">    return rocksdb::kLZ4HCCompression;</a>
<a name="ln548">  else if (!strcasecmp(ctype, &quot;zstd&quot;))</a>
<a name="ln549">    return rocksdb::kZSTDNotFinalCompression;</a>
<a name="ln550"> </a>
<a name="ln551">  fprintf(stdout, &quot;Cannot parse compression type '%s'\n&quot;, ctype);</a>
<a name="ln552">  return rocksdb::kSnappyCompression;  // default value</a>
<a name="ln553">}</a>
<a name="ln554"> </a>
<a name="ln555">std::string ColumnFamilyName(size_t i) {</a>
<a name="ln556">  if (i == 0) {</a>
<a name="ln557">    return rocksdb::kDefaultColumnFamilyName;</a>
<a name="ln558">  } else {</a>
<a name="ln559">    char name[100];</a>
<a name="ln560">    snprintf(name, sizeof(name), &quot;column_family_name_%06zu&quot;, i);</a>
<a name="ln561">    return std::string(name);</a>
<a name="ln562">  }</a>
<a name="ln563">}</a>
<a name="ln564"> </a>
<a name="ln565">DEFINE_string(compression_type, &quot;snappy&quot;,</a>
<a name="ln566">              &quot;Algorithm to use to compress the database&quot;);</a>
<a name="ln567">static enum rocksdb::CompressionType FLAGS_compression_type_e =</a>
<a name="ln568">    rocksdb::kSnappyCompression;</a>
<a name="ln569"> </a>
<a name="ln570">DEFINE_int32(compression_level, -1,</a>
<a name="ln571">             &quot;Compression level. For zlib this should be -1 for the &quot;</a>
<a name="ln572">             &quot;default level, or between 0 and 9.&quot;);</a>
<a name="ln573"> </a>
<a name="ln574">static bool ValidateCompressionLevel(const char* flagname, int32_t value) {</a>
<a name="ln575">  if (value &lt; -1 || value &gt; 9) {</a>
<a name="ln576">    fprintf(stderr, &quot;Invalid value for --%s: %d, must be between -1 and 9\n&quot;,</a>
<a name="ln577">            flagname, value);</a>
<a name="ln578">    return false;</a>
<a name="ln579">  }</a>
<a name="ln580">  return true;</a>
<a name="ln581">}</a>
<a name="ln582"> </a>
<a name="ln583">static const bool FLAGS_compression_level_dummy __attribute__((unused)) =</a>
<a name="ln584">    RegisterFlagValidator(&amp;FLAGS_compression_level, &amp;ValidateCompressionLevel);</a>
<a name="ln585"> </a>
<a name="ln586">DEFINE_int32(min_level_to_compress, -1, &quot;If non-negative, compression starts&quot;</a>
<a name="ln587">             &quot; from this level. Levels with number &lt; min_level_to_compress are&quot;</a>
<a name="ln588">             &quot; not compressed. Otherwise, apply compression_type to &quot;</a>
<a name="ln589">             &quot;all levels.&quot;);</a>
<a name="ln590"> </a>
<a name="ln591">static bool ValidateTableCacheNumshardbits(const char* flagname,</a>
<a name="ln592">                                           int32_t value) {</a>
<a name="ln593">  if (0 &gt;= value || value &gt; 20) {</a>
<a name="ln594">    fprintf(stderr, &quot;Invalid value for --%s: %d, must be  0 &lt; val &lt;= 20\n&quot;,</a>
<a name="ln595">            flagname, value);</a>
<a name="ln596">    return false;</a>
<a name="ln597">  }</a>
<a name="ln598">  return true;</a>
<a name="ln599">}</a>
<a name="ln600">DEFINE_int32(table_cache_numshardbits, 4, &quot;&quot;);</a>
<a name="ln601"> </a>
<a name="ln602">DEFINE_string(hdfs, &quot;&quot;, &quot;Name of hdfs environment&quot;);</a>
<a name="ln603">// posix or hdfs environment</a>
<a name="ln604">static rocksdb::Env* FLAGS_env = rocksdb::Env::Default();</a>
<a name="ln605"> </a>
<a name="ln606">DEFINE_int64(stats_interval, 0, &quot;Stats are reported every N operations when &quot;</a>
<a name="ln607">             &quot;this is greater than zero. When 0 the interval grows over time.&quot;);</a>
<a name="ln608"> </a>
<a name="ln609">DEFINE_int64(stats_interval_seconds, 0, &quot;Report stats every N seconds. This &quot;</a>
<a name="ln610">             &quot;overrides stats_interval when both are &gt; 0.&quot;);</a>
<a name="ln611"> </a>
<a name="ln612">DEFINE_int32(stats_per_interval, 0, &quot;Reports additional stats per interval when&quot;</a>
<a name="ln613">             &quot; this is greater than 0.&quot;);</a>
<a name="ln614"> </a>
<a name="ln615">DEFINE_int64(report_interval_seconds, 0,</a>
<a name="ln616">             &quot;If greater than zero, it will write simple stats in CVS format &quot;</a>
<a name="ln617">             &quot;to --report_file every N seconds&quot;);</a>
<a name="ln618"> </a>
<a name="ln619">DEFINE_string(report_file, &quot;report.csv&quot;,</a>
<a name="ln620">              &quot;Filename where some simple stats are reported to (if &quot;</a>
<a name="ln621">              &quot;--report_interval_seconds is bigger than 0)&quot;);</a>
<a name="ln622"> </a>
<a name="ln623">DEFINE_int32(thread_status_per_interval, 0,</a>
<a name="ln624">             &quot;Takes and report a snapshot of the current status of each thread&quot;</a>
<a name="ln625">             &quot; when this is greater than 0.&quot;);</a>
<a name="ln626"> </a>
<a name="ln627">DEFINE_int32(perf_level, 0, &quot;Level of perf collection&quot;);</a>
<a name="ln628"> </a>
<a name="ln629">static bool ValidateRateLimit(const char* flagname, double value) {</a>
<a name="ln630">  const double EPSILON = 1e-10;</a>
<a name="ln631">  if ( value &lt; -EPSILON ) {</a>
<a name="ln632">    fprintf(stderr, &quot;Invalid value for --%s: %12.6f, must be &gt;= 0.0\n&quot;,</a>
<a name="ln633">            flagname, value);</a>
<a name="ln634">    return false;</a>
<a name="ln635">  }</a>
<a name="ln636">  return true;</a>
<a name="ln637">}</a>
<a name="ln638">DEFINE_double(soft_rate_limit, 0.0, &quot;DEPRECATED&quot;);</a>
<a name="ln639"> </a>
<a name="ln640">DEFINE_double(hard_rate_limit, 0.0, &quot;DEPRECATED&quot;);</a>
<a name="ln641"> </a>
<a name="ln642">DEFINE_uint64(soft_pending_compaction_bytes_limit, 64ull * 1024 * 1024 * 1024,</a>
<a name="ln643">              &quot;Slowdown writes if pending compaction bytes exceed this number&quot;);</a>
<a name="ln644"> </a>
<a name="ln645">DEFINE_uint64(hard_pending_compaction_bytes_limit, 128ull * 1024 * 1024 * 1024,</a>
<a name="ln646">              &quot;Stop writes if pending compaction bytes exceed this number&quot;);</a>
<a name="ln647"> </a>
<a name="ln648">DEFINE_uint64(delayed_write_rate, 8388608u,</a>
<a name="ln649">              &quot;Limited bytes allowed to DB when soft_rate_limit or &quot;</a>
<a name="ln650">              &quot;level0_slowdown_writes_trigger triggers&quot;);</a>
<a name="ln651"> </a>
<a name="ln652">DEFINE_bool(allow_concurrent_memtable_write, false,</a>
<a name="ln653">            &quot;Allow multi-writers to update mem tables in parallel.&quot;);</a>
<a name="ln654"> </a>
<a name="ln655">DEFINE_bool(enable_write_thread_adaptive_yield, false,</a>
<a name="ln656">            &quot;Use a yielding spin loop for brief writer thread waits.&quot;);</a>
<a name="ln657"> </a>
<a name="ln658">DEFINE_uint64(</a>
<a name="ln659">    write_thread_max_yield_usec, 100,</a>
<a name="ln660">    &quot;Maximum microseconds for enable_write_thread_adaptive_yield operation.&quot;);</a>
<a name="ln661"> </a>
<a name="ln662">DEFINE_uint64(write_thread_slow_yield_usec, 3,</a>
<a name="ln663">              &quot;The threshold at which a slow yield is considered a signal that &quot;</a>
<a name="ln664">              &quot;other processes or threads want the core.&quot;);</a>
<a name="ln665"> </a>
<a name="ln666">DEFINE_int32(rate_limit_delay_max_milliseconds, 1000,</a>
<a name="ln667">             &quot;When hard_rate_limit is set then this is the max time a put will&quot;</a>
<a name="ln668">             &quot; be stalled.&quot;);</a>
<a name="ln669"> </a>
<a name="ln670">DEFINE_uint64(rate_limiter_bytes_per_sec, 0, &quot;Set options.rate_limiter value.&quot;);</a>
<a name="ln671"> </a>
<a name="ln672">DEFINE_uint64(</a>
<a name="ln673">    benchmark_write_rate_limit, 0,</a>
<a name="ln674">    &quot;If non-zero, db_bench will rate-limit the writes going into RocksDB. This &quot;</a>
<a name="ln675">    &quot;is the global rate in bytes/second.&quot;);</a>
<a name="ln676"> </a>
<a name="ln677">DEFINE_int32(max_grandparent_overlap_factor, 10, &quot;Control maximum bytes of &quot;</a>
<a name="ln678">             &quot;overlaps in grandparent (i.e., level+2) before we stop building a&quot;</a>
<a name="ln679">             &quot; single file in a level-&gt;level+1 compaction.&quot;);</a>
<a name="ln680"> </a>
<a name="ln681">#ifndef ROCKSDB_LITE</a>
<a name="ln682">DEFINE_bool(readonly, false, &quot;Run read only benchmarks.&quot;);</a>
<a name="ln683">#endif  // ROCKSDB_LITE</a>
<a name="ln684"> </a>
<a name="ln685">DEFINE_bool(disable_auto_compactions, false, &quot;Do not auto trigger compactions&quot;);</a>
<a name="ln686"> </a>
<a name="ln687">DEFINE_int32(source_compaction_factor, 1, &quot;Cap the size of data in level-K for&quot;</a>
<a name="ln688">             &quot; a compaction run that compacts Level-K with Level-(K+1) (for&quot;</a>
<a name="ln689">             &quot; K &gt;= 1)&quot;);</a>
<a name="ln690"> </a>
<a name="ln691">DEFINE_uint64(wal_ttl_seconds, 0, &quot;Set the TTL for the WAL Files in seconds.&quot;);</a>
<a name="ln692">DEFINE_uint64(wal_size_limit_MB, 0, &quot;Set the size limit for the WAL Files&quot;</a>
<a name="ln693">              &quot; in MB.&quot;);</a>
<a name="ln694">DEFINE_uint64(max_total_wal_size, 0, &quot;Set total max WAL size&quot;);</a>
<a name="ln695"> </a>
<a name="ln696">DEFINE_bool(bufferedio, rocksdb::EnvOptions().use_os_buffer,</a>
<a name="ln697">            &quot;Allow buffered io using OS buffers&quot;);</a>
<a name="ln698"> </a>
<a name="ln699">DEFINE_bool(mmap_read, rocksdb::EnvOptions().use_mmap_reads,</a>
<a name="ln700">            &quot;Allow reads to occur via mmap-ing files&quot;);</a>
<a name="ln701"> </a>
<a name="ln702">DEFINE_bool(mmap_write, rocksdb::EnvOptions().use_mmap_writes,</a>
<a name="ln703">            &quot;Allow writes to occur via mmap-ing files&quot;);</a>
<a name="ln704"> </a>
<a name="ln705">DEFINE_bool(advise_random_on_open, rocksdb::Options().advise_random_on_open,</a>
<a name="ln706">            &quot;Advise random access on table file open&quot;);</a>
<a name="ln707"> </a>
<a name="ln708">DEFINE_string(compaction_fadvice, &quot;NORMAL&quot;,</a>
<a name="ln709">              &quot;Access pattern advice when a file is compacted&quot;);</a>
<a name="ln710">static auto FLAGS_compaction_fadvice_e =</a>
<a name="ln711">  rocksdb::Options().access_hint_on_compaction_start;</a>
<a name="ln712"> </a>
<a name="ln713">DEFINE_bool(disable_flashcache_for_background_threads, false,</a>
<a name="ln714">            &quot;Disable flashcache for background threads&quot;);</a>
<a name="ln715"> </a>
<a name="ln716">DEFINE_string(flashcache_dev, &quot;&quot;, &quot;Path to flashcache device&quot;);</a>
<a name="ln717"> </a>
<a name="ln718">DEFINE_bool(use_tailing_iterator, false,</a>
<a name="ln719">            &quot;Use tailing iterator to access a series of keys instead of get&quot;);</a>
<a name="ln720"> </a>
<a name="ln721">DEFINE_bool(use_adaptive_mutex, rocksdb::Options().use_adaptive_mutex,</a>
<a name="ln722">            &quot;Use adaptive mutex&quot;);</a>
<a name="ln723"> </a>
<a name="ln724">DEFINE_uint64(bytes_per_sync,  rocksdb::Options().bytes_per_sync,</a>
<a name="ln725">              &quot;Allows OS to incrementally sync SST files to disk while they are&quot;</a>
<a name="ln726">              &quot; being written, in the background. Issue one request for every&quot;</a>
<a name="ln727">              &quot; bytes_per_sync written. 0 turns it off.&quot;);</a>
<a name="ln728"> </a>
<a name="ln729">DEFINE_uint64(wal_bytes_per_sync,  rocksdb::Options().wal_bytes_per_sync,</a>
<a name="ln730">              &quot;Allows OS to incrementally sync WAL files to disk while they are&quot;</a>
<a name="ln731">              &quot; being written, in the background. Issue one request for every&quot;</a>
<a name="ln732">              &quot; wal_bytes_per_sync written. 0 turns it off.&quot;);</a>
<a name="ln733"> </a>
<a name="ln734">DEFINE_bool(filter_deletes, false, &quot; On true, deletes use bloom-filter and drop&quot;</a>
<a name="ln735">            &quot; the delete if key not present&quot;);</a>
<a name="ln736"> </a>
<a name="ln737">DEFINE_bool(use_single_deletes, true,</a>
<a name="ln738">            &quot;Use single deletes (used in RandomReplaceKeys only).&quot;);</a>
<a name="ln739"> </a>
<a name="ln740">DEFINE_double(stddev, 2000.0,</a>
<a name="ln741">              &quot;Standard deviation of normal distribution used for picking keys&quot;</a>
<a name="ln742">              &quot; (used in RandomReplaceKeys only).&quot;);</a>
<a name="ln743"> </a>
<a name="ln744">DEFINE_int32(max_successive_merges, 0, &quot;Maximum number of successive merge&quot;</a>
<a name="ln745">             &quot; operations on a key in the memtable&quot;);</a>
<a name="ln746"> </a>
<a name="ln747">static bool ValidatePrefixSize(const char* flagname, int32_t value) {</a>
<a name="ln748">  if (value &lt; 0 || value &gt;= 2000000000) {</a>
<a name="ln749">    fprintf(stderr, &quot;Invalid value for --%s: %d. 0&lt;= PrefixSize &lt;=2000000000\n&quot;,</a>
<a name="ln750">            flagname, value);</a>
<a name="ln751">    return false;</a>
<a name="ln752">  }</a>
<a name="ln753">  return true;</a>
<a name="ln754">}</a>
<a name="ln755">DEFINE_int32(prefix_size, 0, &quot;control the prefix size for HashSkipList and &quot;</a>
<a name="ln756">             &quot;plain table&quot;);</a>
<a name="ln757">DEFINE_int64(keys_per_prefix, 0, &quot;control average number of keys generated &quot;</a>
<a name="ln758">             &quot;per prefix, 0 means no special handling of the prefix, &quot;</a>
<a name="ln759">             &quot;i.e. use the prefix comes with the generated random number.&quot;);</a>
<a name="ln760">DEFINE_bool(enable_io_prio, false, &quot;Lower the background flush/compaction &quot;</a>
<a name="ln761">            &quot;threads' IO priority&quot;);</a>
<a name="ln762"> </a>
<a name="ln763">enum RepFactory {</a>
<a name="ln764">  kSkipList,</a>
<a name="ln765">  kPrefixHash,</a>
<a name="ln766">  kVectorRep,</a>
<a name="ln767">  kHashLinkedList</a>
<a name="ln768">};</a>
<a name="ln769"> </a>
<a name="ln770">enum RepFactory StringToRepFactory(const char* ctype) {</a>
<a name="ln771">  assert(ctype);</a>
<a name="ln772"> </a>
<a name="ln773">  if (!strcasecmp(ctype, &quot;skip_list&quot;))</a>
<a name="ln774">    return kSkipList;</a>
<a name="ln775"> </a>
<a name="ln776">  if (!strcasecmp(ctype, &quot;prefix_hash&quot;))</a>
<a name="ln777">    return kPrefixHash;</a>
<a name="ln778"> </a>
<a name="ln779">  if (!strcasecmp(ctype, &quot;vector&quot;))</a>
<a name="ln780">    return kVectorRep;</a>
<a name="ln781"> </a>
<a name="ln782">  if (!strcasecmp(ctype, &quot;hash_linkedlist&quot;))</a>
<a name="ln783">    return kHashLinkedList;</a>
<a name="ln784"> </a>
<a name="ln785">  fprintf(stdout, &quot;Cannot parse memreptable %s\n&quot;, ctype);</a>
<a name="ln786">  return kSkipList;</a>
<a name="ln787">}</a>
<a name="ln788"> </a>
<a name="ln789">static enum RepFactory FLAGS_rep_factory;</a>
<a name="ln790">DEFINE_string(memtablerep, &quot;skip_list&quot;, &quot;&quot;);</a>
<a name="ln791">DEFINE_int64(hash_bucket_count, 1024 * 1024, &quot;hash bucket count&quot;);</a>
<a name="ln792">DEFINE_bool(use_plain_table, false, &quot;if use plain table &quot;</a>
<a name="ln793">            &quot;instead of block-based table format&quot;);</a>
<a name="ln794">DEFINE_bool(use_binary_search, false, &quot;if use kBinarySearch &quot;</a>
<a name="ln795">            &quot;instead of kMultiLevelBinarySearch. &quot;</a>
<a name="ln796">            &quot;This is valid if only we use BlockTable&quot;);</a>
<a name="ln797">DEFINE_bool(use_hash_search, false, &quot;if use kHashSearch &quot;</a>
<a name="ln798">            &quot;instead of kMultiLevelBinarySearch. &quot;</a>
<a name="ln799">            &quot;This is valid if only we use BlockTable&quot;);</a>
<a name="ln800">DEFINE_bool(use_block_based_filter, false, &quot;if use kBlockBasedFilter &quot;</a>
<a name="ln801">            &quot;instead of kFullFilter for filter block. &quot;</a>
<a name="ln802">            &quot;This is valid if only we use BlockTable&quot;);</a>
<a name="ln803">DEFINE_string(merge_operator, &quot;&quot;, &quot;The merge operator to use with the database.&quot;</a>
<a name="ln804">              &quot;If a new merge operator is specified, be sure to use fresh&quot;</a>
<a name="ln805">              &quot; database The possible merge operators are defined in&quot;</a>
<a name="ln806">              &quot; utilities/merge_operators.h&quot;);</a>
<a name="ln807">DEFINE_int32(skip_list_lookahead, 0, &quot;Used with skip_list memtablerep; try &quot;</a>
<a name="ln808">             &quot;linear search first for this many steps from the previous &quot;</a>
<a name="ln809">             &quot;position&quot;);</a>
<a name="ln810">DEFINE_bool(report_file_operations, false, &quot;if report number of file &quot;</a>
<a name="ln811">            &quot;operations&quot;);</a>
<a name="ln812"> </a>
<a name="ln813">static const bool FLAGS_soft_rate_limit_dummy __attribute__((unused)) =</a>
<a name="ln814">    RegisterFlagValidator(&amp;FLAGS_soft_rate_limit, &amp;ValidateRateLimit);</a>
<a name="ln815"> </a>
<a name="ln816">static const bool FLAGS_hard_rate_limit_dummy __attribute__((unused)) =</a>
<a name="ln817">    RegisterFlagValidator(&amp;FLAGS_hard_rate_limit, &amp;ValidateRateLimit);</a>
<a name="ln818"> </a>
<a name="ln819">static const bool FLAGS_prefix_size_dummy __attribute__((unused)) =</a>
<a name="ln820">    RegisterFlagValidator(&amp;FLAGS_prefix_size, &amp;ValidatePrefixSize);</a>
<a name="ln821"> </a>
<a name="ln822">static const bool FLAGS_key_size_dummy __attribute__((unused)) =</a>
<a name="ln823">    RegisterFlagValidator(&amp;FLAGS_key_size, &amp;ValidateKeySize);</a>
<a name="ln824"> </a>
<a name="ln825">static const bool FLAGS_cache_numshardbits_dummy __attribute__((unused)) =</a>
<a name="ln826">    RegisterFlagValidator(&amp;FLAGS_cache_numshardbits,</a>
<a name="ln827">                          &amp;ValidateCacheNumshardbits);</a>
<a name="ln828"> </a>
<a name="ln829">static const bool FLAGS_readwritepercent_dummy __attribute__((unused)) =</a>
<a name="ln830">    RegisterFlagValidator(&amp;FLAGS_readwritepercent, &amp;ValidateInt32Percent);</a>
<a name="ln831"> </a>
<a name="ln832">DEFINE_int32(disable_seek_compaction, false,</a>
<a name="ln833">             &quot;Not used, left here for backwards compatibility&quot;);</a>
<a name="ln834"> </a>
<a name="ln835">static const bool FLAGS_deletepercent_dummy __attribute__((unused)) =</a>
<a name="ln836">    RegisterFlagValidator(&amp;FLAGS_deletepercent, &amp;ValidateInt32Percent);</a>
<a name="ln837">static const bool FLAGS_table_cache_numshardbits_dummy __attribute__((unused)) =</a>
<a name="ln838">    RegisterFlagValidator(&amp;FLAGS_table_cache_numshardbits,</a>
<a name="ln839">                          &amp;ValidateTableCacheNumshardbits);</a>
<a name="ln840">}  // namespace</a>
<a name="ln841"> </a>
<a name="ln842">namespace rocksdb {</a>
<a name="ln843"> </a>
<a name="ln844">namespace {</a>
<a name="ln845">struct ReportFileOpCounters {</a>
<a name="ln846">  std::atomic&lt;int&gt; open_counter_;</a>
<a name="ln847">  std::atomic&lt;int&gt; read_counter_;</a>
<a name="ln848">  std::atomic&lt;int&gt; append_counter_;</a>
<a name="ln849">  std::atomic&lt;uint64_t&gt; bytes_read_;</a>
<a name="ln850">  std::atomic&lt;uint64_t&gt; bytes_written_;</a>
<a name="ln851">};</a>
<a name="ln852"> </a>
<a name="ln853">// A special Env to records and report file operations in db_bench</a>
<a name="ln854">class ReportFileOpEnv : public EnvWrapper {</a>
<a name="ln855"> public:</a>
<a name="ln856">  explicit ReportFileOpEnv(Env* base) : EnvWrapper(base) { reset(); }</a>
<a name="ln857"> </a>
<a name="ln858">  void reset() {</a>
<a name="ln859">    counters_.open_counter_ = 0;</a>
<a name="ln860">    counters_.read_counter_ = 0;</a>
<a name="ln861">    counters_.append_counter_ = 0;</a>
<a name="ln862">    counters_.bytes_read_ = 0;</a>
<a name="ln863">    counters_.bytes_written_ = 0;</a>
<a name="ln864">  }</a>
<a name="ln865"> </a>
<a name="ln866">  Status NewSequentialFile(const std::string&amp; f, unique_ptr&lt;SequentialFile&gt;* r,</a>
<a name="ln867">                           const EnvOptions&amp; soptions) override {</a>
<a name="ln868">    class CountingFile : public SequentialFile {</a>
<a name="ln869">     private:</a>
<a name="ln870">      unique_ptr&lt;SequentialFile&gt; target_;</a>
<a name="ln871">      ReportFileOpCounters* counters_;</a>
<a name="ln872"> </a>
<a name="ln873">     public:</a>
<a name="ln874">      CountingFile(unique_ptr&lt;SequentialFile&gt;&amp;&amp; target,</a>
<a name="ln875">                   ReportFileOpCounters* counters)</a>
<a name="ln876">          : target_(std::move(target)), counters_(counters) {}</a>
<a name="ln877"> </a>
<a name="ln878">      Status Read(size_t n, Slice* result, uint8_t* scratch) override {</a>
<a name="ln879">        counters_-&gt;read_counter_.fetch_add(1, std::memory_order_relaxed);</a>
<a name="ln880">        Status rv = target_-&gt;Read(n, result, scratch);</a>
<a name="ln881">        counters_-&gt;bytes_read_.fetch_add(result-&gt;size(),</a>
<a name="ln882">                                         std::memory_order_relaxed);</a>
<a name="ln883">        return rv;</a>
<a name="ln884">      }</a>
<a name="ln885"> </a>
<a name="ln886">      Status Skip(uint64_t n) override { return target_-&gt;Skip(n); }</a>
<a name="ln887"> </a>
<a name="ln888">      const std::string&amp; filename() const override { return target_-&gt;filename(); }</a>
<a name="ln889">    };</a>
<a name="ln890"> </a>
<a name="ln891">    Status s = target()-&gt;NewSequentialFile(f, r, soptions);</a>
<a name="ln892">    if (s.ok()) {</a>
<a name="ln893">      counters()-&gt;open_counter_.fetch_add(1, std::memory_order_relaxed);</a>
<a name="ln894">      r-&gt;reset(new CountingFile(std::move(*r), counters()));</a>
<a name="ln895">    }</a>
<a name="ln896">    return s;</a>
<a name="ln897">  }</a>
<a name="ln898"> </a>
<a name="ln899">  Status NewRandomAccessFile(const std::string&amp; f,</a>
<a name="ln900">                             unique_ptr&lt;RandomAccessFile&gt;* r,</a>
<a name="ln901">                             const EnvOptions&amp; soptions) override {</a>
<a name="ln902">    class CountingFile : public yb::RandomAccessFileWrapper {</a>
<a name="ln903">     public:</a>
<a name="ln904">      CountingFile(std::unique_ptr&lt;RandomAccessFile&gt;&amp;&amp; target,</a>
<a name="ln905">                   ReportFileOpCounters* counters)</a>
<a name="ln906">          : RandomAccessFileWrapper(std::move(target)), counters_(counters) {}</a>
<a name="ln907"> </a>
<a name="ln908">      Status Read(uint64_t offset, size_t n, Slice* result, uint8_t* scratch) const override {</a>
<a name="ln909">        counters_-&gt;read_counter_.fetch_add(1, std::memory_order_relaxed);</a>
<a name="ln910">        Status rv = RandomAccessFileWrapper::Read(offset, n, result, scratch);</a>
<a name="ln911">        counters_-&gt;bytes_read_.fetch_add(result-&gt;size(), std::memory_order_relaxed);</a>
<a name="ln912">        return rv;</a>
<a name="ln913">      }</a>
<a name="ln914"> </a>
<a name="ln915">     private:</a>
<a name="ln916">      ReportFileOpCounters* counters_;</a>
<a name="ln917">    };</a>
<a name="ln918"> </a>
<a name="ln919">    Status s = target()-&gt;NewRandomAccessFile(f, r, soptions);</a>
<a name="ln920">    if (s.ok()) {</a>
<a name="ln921">      counters()-&gt;open_counter_.fetch_add(1, std::memory_order_relaxed);</a>
<a name="ln922">      r-&gt;reset(new CountingFile(std::move(*r), counters()));</a>
<a name="ln923">    }</a>
<a name="ln924">    return s;</a>
<a name="ln925">  }</a>
<a name="ln926"> </a>
<a name="ln927">  Status NewWritableFile(const std::string&amp; f, unique_ptr&lt;WritableFile&gt;* r,</a>
<a name="ln928">                         const EnvOptions&amp; soptions) override {</a>
<a name="ln929">    class CountingFile : public WritableFile {</a>
<a name="ln930">     private:</a>
<a name="ln931">      unique_ptr&lt;WritableFile&gt; target_;</a>
<a name="ln932">      ReportFileOpCounters* counters_;</a>
<a name="ln933"> </a>
<a name="ln934">     public:</a>
<a name="ln935">      CountingFile(unique_ptr&lt;WritableFile&gt;&amp;&amp; target,</a>
<a name="ln936">                   ReportFileOpCounters* counters)</a>
<a name="ln937">          : target_(std::move(target)), counters_(counters) {}</a>
<a name="ln938"> </a>
<a name="ln939">      Status Append(const Slice&amp; data) override {</a>
<a name="ln940">        counters_-&gt;append_counter_.fetch_add(1, std::memory_order_relaxed);</a>
<a name="ln941">        Status rv = target_-&gt;Append(data);</a>
<a name="ln942">        counters_-&gt;bytes_written_.fetch_add(data.size(),</a>
<a name="ln943">                                            std::memory_order_relaxed);</a>
<a name="ln944">        return rv;</a>
<a name="ln945">      }</a>
<a name="ln946"> </a>
<a name="ln947">      Status Truncate(uint64_t size) override { return target_-&gt;Truncate(size); }</a>
<a name="ln948">      Status Close() override { return target_-&gt;Close(); }</a>
<a name="ln949">      Status Flush() override { return target_-&gt;Flush(); }</a>
<a name="ln950">      Status Sync() override { return target_-&gt;Sync(); }</a>
<a name="ln951">    };</a>
<a name="ln952"> </a>
<a name="ln953">    Status s = target()-&gt;NewWritableFile(f, r, soptions);</a>
<a name="ln954">    if (s.ok()) {</a>
<a name="ln955">      counters()-&gt;open_counter_.fetch_add(1, std::memory_order_relaxed);</a>
<a name="ln956">      r-&gt;reset(new CountingFile(std::move(*r), counters()));</a>
<a name="ln957">    }</a>
<a name="ln958">    return s;</a>
<a name="ln959">  }</a>
<a name="ln960"> </a>
<a name="ln961">  // getter</a>
<a name="ln962">  ReportFileOpCounters* counters() { return &amp;counters_; }</a>
<a name="ln963"> </a>
<a name="ln964"> private:</a>
<a name="ln965">  ReportFileOpCounters counters_;</a>
<a name="ln966">};</a>
<a name="ln967"> </a>
<a name="ln968">}  // namespace</a>
<a name="ln969"> </a>
<a name="ln970">// Helper for quickly generating random data.</a>
<a name="ln971">class RandomGenerator {</a>
<a name="ln972"> private:</a>
<a name="ln973">  std::string data_;</a>
<a name="ln974">  unsigned int pos_;</a>
<a name="ln975"> </a>
<a name="ln976"> public:</a>
<a name="ln977">  RandomGenerator() {</a>
<a name="ln978">    // We use a limited amount of data over and over again and ensure</a>
<a name="ln979">    // that it is larger than the compression window (32KB), and also</a>
<a name="ln980">    // large enough to serve all typical value sizes we want to write.</a>
<a name="ln981">    Random rnd(301);</a>
<a name="ln982">    std::string piece;</a>
<a name="ln983">    while (data_.size() &lt; (unsigned)std::max(1048576, FLAGS_value_size)) {</a>
<a name="ln984">      // Add a short fragment that is as compressible as specified</a>
<a name="ln985">      // by FLAGS_compression_ratio.</a>
<a name="ln986">      CompressibleString(&amp;rnd, FLAGS_compression_ratio, 100, &amp;piece);</a>
<a name="ln987">      data_.append(piece);</a>
<a name="ln988">    }</a>
<a name="ln989">    pos_ = 0;</a>
<a name="ln990">  }</a>
<a name="ln991"> </a>
<a name="ln992">  Slice Generate(unsigned int len) {</a>
<a name="ln993">    assert(len &lt;= data_.size());</a>
<a name="ln994">    if (pos_ + len &gt; data_.size()) {</a>
<a name="ln995">      pos_ = 0;</a>
<a name="ln996">    }</a>
<a name="ln997">    pos_ += len;</a>
<a name="ln998">    return Slice(data_.data() + pos_ - len, len);</a>
<a name="ln999">  }</a>
<a name="ln1000">};</a>
<a name="ln1001"> </a>
<a name="ln1002">static void AppendWithSpace(std::string* str, Slice msg) {</a>
<a name="ln1003">  if (msg.empty()) return;</a>
<a name="ln1004">  if (!str-&gt;empty()) {</a>
<a name="ln1005">    str-&gt;push_back(' ');</a>
<a name="ln1006">  }</a>
<a name="ln1007">  str-&gt;append(msg.cdata(), msg.size());</a>
<a name="ln1008">}</a>
<a name="ln1009"> </a>
<a name="ln1010">struct DBWithColumnFamilies {</a>
<a name="ln1011">  std::vector&lt;ColumnFamilyHandle*&gt; cfh;</a>
<a name="ln1012">  DB* db;</a>
<a name="ln1013">#ifndef ROCKSDB_LITE</a>
<a name="ln1014">  OptimisticTransactionDB* opt_txn_db;</a>
<a name="ln1015">#endif  // ROCKSDB_LITE</a>
<a name="ln1016">  std::atomic&lt;size_t&gt; num_created;  // Need to be updated after all the</a>
<a name="ln1017">                                    // new entries in cfh are set.</a>
<a name="ln1018">  size_t num_hot;  // Number of column families to be queried at each moment.</a>
<a name="ln1019">                   // After each CreateNewCf(), another num_hot number of new</a>
<a name="ln1020">                   // Column families will be created and used to be queried.</a>
<a name="ln1021">  port::Mutex create_cf_mutex;  // Only one thread can execute CreateNewCf()</a>
<a name="ln1022"> </a>
<a name="ln1023">  DBWithColumnFamilies()</a>
<a name="ln1024">      : db(nullptr)</a>
<a name="ln1025">#ifndef ROCKSDB_LITE</a>
<a name="ln1026">        , opt_txn_db(nullptr)</a>
<a name="ln1027">#endif  // ROCKSDB_LITE</a>
<a name="ln1028">  {</a>
<a name="ln1029">    cfh.clear();</a>
<a name="ln1030">    num_created = 0;</a>
<a name="ln1031">    num_hot = 0;</a>
<a name="ln1032">  }</a>
<a name="ln1033"> </a>
<a name="ln1034">  DBWithColumnFamilies(const DBWithColumnFamilies&amp; other)</a>
<a name="ln1035">      : cfh(other.cfh),</a>
<a name="ln1036">        db(other.db),</a>
<a name="ln1037">#ifndef ROCKSDB_LITE</a>
<a name="ln1038">        opt_txn_db(other.opt_txn_db),</a>
<a name="ln1039">#endif  // ROCKSDB_LITE</a>
<a name="ln1040">        num_created(other.num_created.load()),</a>
<a name="ln1041">        num_hot(other.num_hot) {}</a>
<a name="ln1042"> </a>
<a name="ln1043">  void DeleteDBs() {</a>
<a name="ln1044">    std::for_each(cfh.begin(), cfh.end(),</a>
<a name="ln1045">                  [](ColumnFamilyHandle* cfhi) { delete cfhi; });</a>
<a name="ln1046">    cfh.clear();</a>
<a name="ln1047">#ifndef ROCKSDB_LITE</a>
<a name="ln1048">    if (opt_txn_db) {</a>
<a name="ln1049">      delete opt_txn_db;</a>
<a name="ln1050">      opt_txn_db = nullptr;</a>
<a name="ln1051">    } else {</a>
<a name="ln1052">      delete db;</a>
<a name="ln1053">      db = nullptr;</a>
<a name="ln1054">    }</a>
<a name="ln1055">#else</a>
<a name="ln1056">    delete db;</a>
<a name="ln1057">    db = nullptr;</a>
<a name="ln1058">#endif  // ROCKSDB_LITE</a>
<a name="ln1059">  }</a>
<a name="ln1060"> </a>
<a name="ln1061">  ColumnFamilyHandle* GetCfh(int64_t rand_num) {</a>
<a name="ln1062">    assert(num_hot &gt; 0);</a>
<a name="ln1063">    return cfh[num_created.load(std::memory_order_acquire) - num_hot +</a>
<a name="ln1064">               rand_num % num_hot];</a>
<a name="ln1065">  }</a>
<a name="ln1066"> </a>
<a name="ln1067">  // stage: assume CF from 0 to stage * num_hot has be created. Need to create</a>
<a name="ln1068">  //        stage * num_hot + 1 to stage * (num_hot + 1).</a>
<a name="ln1069">  void CreateNewCf(ColumnFamilyOptions options, int64_t stage) {</a>
<a name="ln1070">    MutexLock l(&amp;create_cf_mutex);</a>
<a name="ln1071">    if ((stage + 1) * num_hot &lt;= num_created) {</a>
<a name="ln1072">      // Already created.</a>
<a name="ln1073">      return;</a>
<a name="ln1074">    }</a>
<a name="ln1075">    auto new_num_created = num_created + num_hot;</a>
<a name="ln1076">    assert(new_num_created &lt;= cfh.size());</a>
<a name="ln1077">    for (size_t i = num_created; i &lt; new_num_created; i++) {</a>
<a name="ln1078">      Status s =</a>
<a name="ln1079">          db-&gt;CreateColumnFamily(options, ColumnFamilyName(i), &amp;(cfh[i]));</a>
<a name="ln1080">      if (!s.ok()) {</a>
<a name="ln1081">        fprintf(stderr, &quot;create column family error: %s\n&quot;,</a>
<a name="ln1082">                s.ToString().c_str());</a>
<a name="ln1083">        abort();</a>
<a name="ln1084">      }</a>
<a name="ln1085">    }</a>
<a name="ln1086">    num_created.store(new_num_created, std::memory_order_release);</a>
<a name="ln1087">  }</a>
<a name="ln1088">};</a>
<a name="ln1089"> </a>
<a name="ln1090">// a class that reports stats to CSV file</a>
<a name="ln1091">class ReporterAgent {</a>
<a name="ln1092"> public:</a>
<a name="ln1093">  ReporterAgent(Env* env, const std::string&amp; fname,</a>
<a name="ln1094">                uint64_t report_interval_secs)</a>
<a name="ln1095">      : env_(env),</a>
<a name="ln1096">        total_ops_done_(0),</a>
<a name="ln1097">        last_report_(0),</a>
<a name="ln1098">        report_interval_secs_(report_interval_secs),</a>
<a name="ln1099">        stop_(false) {</a>
<a name="ln1100">    auto s = env_-&gt;NewWritableFile(fname, &amp;report_file_, EnvOptions());</a>
<a name="ln1101">    if (s.ok()) {</a>
<a name="ln1102">      s = report_file_-&gt;Append(Header() + &quot;\n&quot;);</a>
<a name="ln1103">    }</a>
<a name="ln1104">    if (s.ok()) {</a>
<a name="ln1105">      s = report_file_-&gt;Flush();</a>
<a name="ln1106">    }</a>
<a name="ln1107">    if (!s.ok()) {</a>
<a name="ln1108">      fprintf(stderr, &quot;Can't open %s: %s\n&quot;, fname.c_str(),</a>
<a name="ln1109">              s.ToString().c_str());</a>
<a name="ln1110">      abort();</a>
<a name="ln1111">    }</a>
<a name="ln1112"> </a>
<a name="ln1113">    reporting_thread_ = std::thread([&amp;]() { SleepAndReport(); });</a>
<a name="ln1114">  }</a>
<a name="ln1115"> </a>
<a name="ln1116">  ~ReporterAgent() {</a>
<a name="ln1117">    {</a>
<a name="ln1118">      std::unique_lock&lt;std::mutex&gt; lk(mutex_);</a>
<a name="ln1119">      stop_ = true;</a>
<a name="ln1120">      stop_cv_.notify_all();</a>
<a name="ln1121">    }</a>
<a name="ln1122">    reporting_thread_.join();</a>
<a name="ln1123">  }</a>
<a name="ln1124"> </a>
<a name="ln1125">  // thread safe</a>
<a name="ln1126">  void ReportFinishedOps(int64_t num_ops) {</a>
<a name="ln1127">    total_ops_done_.fetch_add(num_ops);</a>
<a name="ln1128">  }</a>
<a name="ln1129"> </a>
<a name="ln1130"> private:</a>
<a name="ln1131">  std::string Header() const { return &quot;secs_elapsed,interval_qps&quot;; }</a>
<a name="ln1132">  void SleepAndReport() {</a>
<a name="ln1133">    uint64_t kMicrosInSecond = 1000 * 1000;</a>
<a name="ln1134">    auto time_started = env_-&gt;NowMicros();</a>
<a name="ln1135">    while (true) {</a>
<a name="ln1136">      {</a>
<a name="ln1137">        std::unique_lock&lt;std::mutex&gt; lk(mutex_);</a>
<a name="ln1138">        if (stop_ ||</a>
<a name="ln1139">            stop_cv_.wait_for(lk, std::chrono::seconds(report_interval_secs_),</a>
<a name="ln1140">                              [&amp;]() { return stop_; })) {</a>
<a name="ln1141">          // stopping</a>
<a name="ln1142">          break;</a>
<a name="ln1143">        }</a>
<a name="ln1144">        // else -&gt; timeout, which means time for a report!</a>
<a name="ln1145">      }</a>
<a name="ln1146">      auto total_ops_done_snapshot = total_ops_done_.load();</a>
<a name="ln1147">      // round the seconds elapsed</a>
<a name="ln1148">      auto secs_elapsed =</a>
<a name="ln1149">          (env_-&gt;NowMicros() - time_started + kMicrosInSecond / 2) /</a>
<a name="ln1150">          kMicrosInSecond;</a>
<a name="ln1151">      std::string report = ToString(secs_elapsed) + &quot;,&quot; +</a>
<a name="ln1152">                           ToString(total_ops_done_snapshot - last_report_) +</a>
<a name="ln1153">                           &quot;\n&quot;;</a>
<a name="ln1154">      auto s = report_file_-&gt;Append(report);</a>
<a name="ln1155">      if (s.ok()) {</a>
<a name="ln1156">        s = report_file_-&gt;Flush();</a>
<a name="ln1157">      }</a>
<a name="ln1158">      if (!s.ok()) {</a>
<a name="ln1159">        fprintf(stderr,</a>
<a name="ln1160">                &quot;Can't write to report file (%s), stopping the reporting\n&quot;,</a>
<a name="ln1161">                s.ToString().c_str());</a>
<a name="ln1162">        break;</a>
<a name="ln1163">      }</a>
<a name="ln1164">      last_report_ = total_ops_done_snapshot;</a>
<a name="ln1165">    }</a>
<a name="ln1166">  }</a>
<a name="ln1167"> </a>
<a name="ln1168">  Env* env_;</a>
<a name="ln1169">  std::unique_ptr&lt;WritableFile&gt; report_file_;</a>
<a name="ln1170">  std::atomic&lt;int64_t&gt; total_ops_done_;</a>
<a name="ln1171">  int64_t last_report_;</a>
<a name="ln1172">  const uint64_t report_interval_secs_;</a>
<a name="ln1173">  std::thread reporting_thread_;</a>
<a name="ln1174">  std::mutex mutex_;</a>
<a name="ln1175">  // will notify on stop</a>
<a name="ln1176">  std::condition_variable stop_cv_;</a>
<a name="ln1177">  bool stop_;</a>
<a name="ln1178">};</a>
<a name="ln1179"> </a>
<a name="ln1180">enum OperationType : unsigned char {</a>
<a name="ln1181">  kRead = 0,</a>
<a name="ln1182">  kWrite,</a>
<a name="ln1183">  kDelete,</a>
<a name="ln1184">  kSeek,</a>
<a name="ln1185">  kMerge,</a>
<a name="ln1186">  kUpdate,</a>
<a name="ln1187">  kCompress,</a>
<a name="ln1188">  kUncompress,</a>
<a name="ln1189">  kCrc,</a>
<a name="ln1190">  kHash,</a>
<a name="ln1191">  kOthers</a>
<a name="ln1192">};</a>
<a name="ln1193"> </a>
<a name="ln1194">static std::unordered_map&lt;OperationType, std::string, std::hash&lt;unsigned char&gt;&gt;</a>
<a name="ln1195">                          OperationTypeString = {</a>
<a name="ln1196">  {kRead, &quot;read&quot;},</a>
<a name="ln1197">  {kWrite, &quot;write&quot;},</a>
<a name="ln1198">  {kDelete, &quot;delete&quot;},</a>
<a name="ln1199">  {kSeek, &quot;seek&quot;},</a>
<a name="ln1200">  {kMerge, &quot;merge&quot;},</a>
<a name="ln1201">  {kUpdate, &quot;update&quot;},</a>
<a name="ln1202">  {kCompress, &quot;compress&quot;},</a>
<a name="ln1203">  {kCompress, &quot;uncompress&quot;},</a>
<a name="ln1204">  {kCrc, &quot;crc&quot;},</a>
<a name="ln1205">  {kHash, &quot;hash&quot;},</a>
<a name="ln1206">  {kOthers, &quot;op&quot;}</a>
<a name="ln1207">};</a>
<a name="ln1208"> </a>
<a name="ln1209">class Stats {</a>
<a name="ln1210"> private:</a>
<a name="ln1211">  int id_;</a>
<a name="ln1212">  uint64_t start_;</a>
<a name="ln1213">  uint64_t finish_;</a>
<a name="ln1214">  double seconds_;</a>
<a name="ln1215">  uint64_t done_;</a>
<a name="ln1216">  uint64_t last_report_done_;</a>
<a name="ln1217">  uint64_t next_report_;</a>
<a name="ln1218">  uint64_t bytes_;</a>
<a name="ln1219">  uint64_t last_op_finish_;</a>
<a name="ln1220">  uint64_t last_report_finish_;</a>
<a name="ln1221">  std::unordered_map&lt;OperationType, HistogramImpl,</a>
<a name="ln1222">                     std::hash&lt;unsigned char&gt;&gt; hist_;</a>
<a name="ln1223">  std::string message_;</a>
<a name="ln1224">  bool exclude_from_merge_;</a>
<a name="ln1225">  ReporterAgent* reporter_agent_;  // does not own</a>
<a name="ln1226"> </a>
<a name="ln1227"> public:</a>
<a name="ln1228">  Stats() { Start(-1); }</a>
<a name="ln1229"> </a>
<a name="ln1230">  void SetReporterAgent(ReporterAgent* reporter_agent) {</a>
<a name="ln1231">    reporter_agent_ = reporter_agent;</a>
<a name="ln1232">  }</a>
<a name="ln1233"> </a>
<a name="ln1234">  void Start(int id) {</a>
<a name="ln1235">    id_ = id;</a>
<a name="ln1236">    start_ = FLAGS_env-&gt;NowMicros();</a>
<a name="ln1237">    next_report_ = FLAGS_stats_interval ? FLAGS_stats_interval : 100;</a>
<a name="ln1238">    last_op_finish_ = start_;</a>
<a name="ln1239">    hist_.clear();</a>
<a name="ln1240">    done_ = 0;</a>
<a name="ln1241">    last_report_done_ = 0;</a>
<a name="ln1242">    bytes_ = 0;</a>
<a name="ln1243">    seconds_ = 0;</a>
<a name="ln1244">    finish_ = start_;</a>
<a name="ln1245">    last_report_finish_ = start_;</a>
<a name="ln1246">    message_.clear();</a>
<a name="ln1247">    // When set, stats from this thread won't be merged with others.</a>
<a name="ln1248">    exclude_from_merge_ = false;</a>
<a name="ln1249">  }</a>
<a name="ln1250"> </a>
<a name="ln1251">  void Merge(const Stats&amp; other) {</a>
<a name="ln1252">    if (other.exclude_from_merge_)</a>
<a name="ln1253">      return;</a>
<a name="ln1254"> </a>
<a name="ln1255">    for (auto it = other.hist_.begin(); it != other.hist_.end(); ++it) {</a>
<a name="ln1256">      auto this_it = hist_.find(it-&gt;first);</a>
<a name="ln1257">      if (this_it != hist_.end()) {</a>
<a name="ln1258">        this_it-&gt;second.Merge(other.hist_.at(it-&gt;first));</a>
<a name="ln1259">      } else {</a>
<a name="ln1260">        hist_.insert({ it-&gt;first, it-&gt;second });</a>
<a name="ln1261">      }</a>
<a name="ln1262">    }</a>
<a name="ln1263"> </a>
<a name="ln1264">    done_ += other.done_;</a>
<a name="ln1265">    bytes_ += other.bytes_;</a>
<a name="ln1266">    seconds_ += other.seconds_;</a>
<a name="ln1267">    if (other.start_ &lt; start_) start_ = other.start_;</a>
<a name="ln1268">    if (other.finish_ &gt; finish_) finish_ = other.finish_;</a>
<a name="ln1269"> </a>
<a name="ln1270">    // Just keep the messages from one thread</a>
<a name="ln1271">    if (message_.empty()) message_ = other.message_;</a>
<a name="ln1272">  }</a>
<a name="ln1273"> </a>
<a name="ln1274">  void Stop() {</a>
<a name="ln1275">    finish_ = FLAGS_env-&gt;NowMicros();</a>
<a name="ln1276">    seconds_ = (finish_ - start_) * 1e-6;</a>
<a name="ln1277">  }</a>
<a name="ln1278"> </a>
<a name="ln1279">  void AddMessage(Slice msg) {</a>
<a name="ln1280">    AppendWithSpace(&amp;message_, msg);</a>
<a name="ln1281">  }</a>
<a name="ln1282"> </a>
<a name="ln1283">  void SetId(int id) { id_ = id; }</a>
<a name="ln1284">  void SetExcludeFromMerge() { exclude_from_merge_ = true; }</a>
<a name="ln1285"> </a>
<a name="ln1286">  void PrintThreadStatus() {</a>
<a name="ln1287">    std::vector&lt;ThreadStatus&gt; thread_list;</a>
<a name="ln1288">    CHECK_OK(FLAGS_env-&gt;GetThreadList(&amp;thread_list));</a>
<a name="ln1289"> </a>
<a name="ln1290">    fprintf(stderr, &quot;\n%18s %10s %12s %20s %13s %45s %12s %s\n&quot;,</a>
<a name="ln1291">        &quot;ThreadID&quot;, &quot;ThreadType&quot;, &quot;cfName&quot;, &quot;Operation&quot;,</a>
<a name="ln1292">        &quot;ElapsedTime&quot;, &quot;Stage&quot;, &quot;State&quot;, &quot;OperationProperties&quot;);</a>
<a name="ln1293"> </a>
<a name="ln1294">    int64_t current_time = 0;</a>
<a name="ln1295">    CHECK_OK(Env::Default()-&gt;GetCurrentTime(&amp;current_time));</a>
<a name="ln1296">    for (auto ts : thread_list) {</a>
<a name="ln1297">      fprintf(stderr, &quot;%18&quot; PRIu64 &quot; %10s %12s %20s %13s %45s %12s&quot;,</a>
<a name="ln1298">          ts.thread_id,</a>
<a name="ln1299">          ThreadStatus::GetThreadTypeName(ts.thread_type).c_str(),</a>
<a name="ln1300">          ts.cf_name.c_str(),</a>
<a name="ln1301">          ThreadStatus::GetOperationName(ts.operation_type).c_str(),</a>
<a name="ln1302">          ThreadStatus::MicrosToString(ts.op_elapsed_micros).c_str(),</a>
<a name="ln1303">          ThreadStatus::GetOperationStageName(ts.operation_stage).c_str(),</a>
<a name="ln1304">          ThreadStatus::GetStateName(ts.state_type).c_str());</a>
<a name="ln1305"> </a>
<a name="ln1306">      auto op_properties = ThreadStatus::InterpretOperationProperties(</a>
<a name="ln1307">          ts.operation_type, ts.op_properties);</a>
<a name="ln1308">      for (const auto&amp; op_prop : op_properties) {</a>
<a name="ln1309">        fprintf(stderr, &quot; %s %&quot; PRIu64&quot; |&quot;,</a>
<a name="ln1310">            op_prop.first.c_str(), op_prop.second);</a>
<a name="ln1311">      }</a>
<a name="ln1312">      fprintf(stderr, &quot;\n&quot;);</a>
<a name="ln1313">    }</a>
<a name="ln1314">  }</a>
<a name="ln1315"> </a>
<a name="ln1316">  void ResetLastOpTime() {</a>
<a name="ln1317">    // Set to now to avoid latency from calls to SleepForMicroseconds</a>
<a name="ln1318">    last_op_finish_ = FLAGS_env-&gt;NowMicros();</a>
<a name="ln1319">  }</a>
<a name="ln1320"> </a>
<a name="ln1321">  void FinishedOps(DBWithColumnFamilies* db_with_cfh, DB* db, int64_t num_ops,</a>
<a name="ln1322">                   enum OperationType op_type = kOthers) {</a>
<a name="ln1323">    if (reporter_agent_) {</a>
<a name="ln1324">      reporter_agent_-&gt;ReportFinishedOps(num_ops);</a>
<a name="ln1325">    }</a>
<a name="ln1326">    if (FLAGS_histogram) {</a>
<a name="ln1327">      uint64_t now = FLAGS_env-&gt;NowMicros();</a>
<a name="ln1328">      uint64_t micros = now - last_op_finish_;</a>
<a name="ln1329"> </a>
<a name="ln1330">      if (hist_.find(op_type) == hist_.end()) {</a>
<a name="ln1331">        HistogramImpl hist_temp;</a>
<a name="ln1332">        hist_.insert({op_type, hist_temp});</a>
<a name="ln1333">      }</a>
<a name="ln1334">      hist_[op_type].Add(micros);</a>
<a name="ln1335"> </a>
<a name="ln1336">      if (micros &gt; 20000 &amp;&amp; !FLAGS_stats_interval) {</a>
<a name="ln1337">        fprintf(stderr, &quot;long op: %&quot; PRIu64 &quot; micros%30s\r&quot;, micros, &quot;&quot;);</a>
<a name="ln1338">        fflush(stderr);</a>
<a name="ln1339">      }</a>
<a name="ln1340">      last_op_finish_ = now;</a>
<a name="ln1341">    }</a>
<a name="ln1342"> </a>
<a name="ln1343">    done_ += num_ops;</a>
<a name="ln1344">    if (done_ &gt;= next_report_) {</a>
<a name="ln1345">      if (!FLAGS_stats_interval) {</a>
<a name="ln1346">        if      (next_report_ &lt; 1000)   next_report_ += 100;</a>
<a name="ln1347">        else if (next_report_ &lt; 5000)   next_report_ += 500;</a>
<a name="ln1348">        else if (next_report_ &lt; 10000)  next_report_ += 1000;</a>
<a name="ln1349">        else if (next_report_ &lt; 50000)  next_report_ += 5000;</a>
<a name="ln1350">        else if (next_report_ &lt; 100000) next_report_ += 10000;</a>
<a name="ln1351">        else if (next_report_ &lt; 500000) next_report_ += 50000;</a>
<a name="ln1352">        else                            next_report_ += 100000;</a>
<a name="ln1353">        fprintf(stderr, &quot;... finished %&quot; PRIu64 &quot; ops%30s\r&quot;, done_, &quot;&quot;);</a>
<a name="ln1354">      } else {</a>
<a name="ln1355">        uint64_t now = FLAGS_env-&gt;NowMicros();</a>
<a name="ln1356">        int64_t usecs_since_last = now - last_report_finish_;</a>
<a name="ln1357"> </a>
<a name="ln1358">        // Determine whether to print status where interval is either</a>
<a name="ln1359">        // each N operations or each N seconds.</a>
<a name="ln1360"> </a>
<a name="ln1361">        if (FLAGS_stats_interval_seconds &amp;&amp;</a>
<a name="ln1362">            usecs_since_last &lt; (FLAGS_stats_interval_seconds * 1000000)) {</a>
<a name="ln1363">          // Don't check again for this many operations</a>
<a name="ln1364">          next_report_ += FLAGS_stats_interval;</a>
<a name="ln1365"> </a>
<a name="ln1366">        } else {</a>
<a name="ln1367"> </a>
<a name="ln1368">          fprintf(stderr,</a>
<a name="ln1369">                  &quot;%s ... thread %d: (%&quot; PRIu64 &quot;,%&quot; PRIu64 &quot;) ops and &quot;</a>
<a name="ln1370">                  &quot;(%.1f,%.1f) ops/second in (%.6f,%.6f) seconds\n&quot;,</a>
<a name="ln1371">                  FLAGS_env-&gt;TimeToString(now/1000000).c_str(),</a>
<a name="ln1372">                  id_,</a>
<a name="ln1373">                  done_ - last_report_done_, done_,</a>
<a name="ln1374">                  (done_ - last_report_done_) /</a>
<a name="ln1375">                  (usecs_since_last / 1000000.0),</a>
<a name="ln1376">                  done_ / ((now - start_) / 1000000.0),</a>
<a name="ln1377">                  (now - last_report_finish_) / 1000000.0,</a>
<a name="ln1378">                  (now - start_) / 1000000.0);</a>
<a name="ln1379"> </a>
<a name="ln1380">          if (FLAGS_stats_per_interval) {</a>
<a name="ln1381">            std::string stats;</a>
<a name="ln1382"> </a>
<a name="ln1383">            if (db_with_cfh &amp;&amp; db_with_cfh-&gt;num_created.load()) {</a>
<a name="ln1384">              for (size_t i = 0; i &lt; db_with_cfh-&gt;num_created.load(); ++i) {</a>
<a name="ln1385">                if (db-&gt;GetProperty(db_with_cfh-&gt;cfh[i], &quot;rocksdb.cfstats&quot;,</a>
<a name="ln1386">                                    &amp;stats))</a>
<a name="ln1387">                  fprintf(stderr, &quot;%s\n&quot;, stats.c_str());</a>
<a name="ln1388">                if (FLAGS_show_table_properties) {</a>
<a name="ln1389">                  for (int level = 0; level &lt; FLAGS_num_levels; ++level) {</a>
<a name="ln1390">                    if (db-&gt;GetProperty(</a>
<a name="ln1391">                            db_with_cfh-&gt;cfh[i],</a>
<a name="ln1392">                            &quot;rocksdb.aggregated-table-properties-at-level&quot; +</a>
<a name="ln1393">                                ToString(level),</a>
<a name="ln1394">                            &amp;stats)) {</a>
<a name="ln1395">                      if (stats.find(&quot;# entries=0&quot;) == std::string::npos) {</a>
<a name="ln1396">                        fprintf(stderr, &quot;Level[%d]: %s\n&quot;, level,</a>
<a name="ln1397">                                stats.c_str());</a>
<a name="ln1398">                      }</a>
<a name="ln1399">                    }</a>
<a name="ln1400">                  }</a>
<a name="ln1401">                }</a>
<a name="ln1402">              }</a>
<a name="ln1403">            } else if (db) {</a>
<a name="ln1404">              if (db-&gt;GetProperty(&quot;rocksdb.stats&quot;, &amp;stats)) {</a>
<a name="ln1405">                fprintf(stderr, &quot;%s\n&quot;, stats.c_str());</a>
<a name="ln1406">              }</a>
<a name="ln1407">              if (FLAGS_show_table_properties) {</a>
<a name="ln1408">                for (int level = 0; level &lt; FLAGS_num_levels; ++level) {</a>
<a name="ln1409">                  if (db-&gt;GetProperty(</a>
<a name="ln1410">                          &quot;rocksdb.aggregated-table-properties-at-level&quot; +</a>
<a name="ln1411">                              ToString(level),</a>
<a name="ln1412">                          &amp;stats)) {</a>
<a name="ln1413">                    if (stats.find(&quot;# entries=0&quot;) == std::string::npos) {</a>
<a name="ln1414">                      fprintf(stderr, &quot;Level[%d]: %s\n&quot;, level, stats.c_str());</a>
<a name="ln1415">                    }</a>
<a name="ln1416">                  }</a>
<a name="ln1417">                }</a>
<a name="ln1418">              }</a>
<a name="ln1419">            }</a>
<a name="ln1420">          }</a>
<a name="ln1421"> </a>
<a name="ln1422">          next_report_ += FLAGS_stats_interval;</a>
<a name="ln1423">          last_report_finish_ = now;</a>
<a name="ln1424">          last_report_done_ = done_;</a>
<a name="ln1425">        }</a>
<a name="ln1426">      }</a>
<a name="ln1427">      if (id_ == 0 &amp;&amp; FLAGS_thread_status_per_interval) {</a>
<a name="ln1428">        PrintThreadStatus();</a>
<a name="ln1429">      }</a>
<a name="ln1430">      fflush(stderr);</a>
<a name="ln1431">    }</a>
<a name="ln1432">  }</a>
<a name="ln1433"> </a>
<a name="ln1434">  void AddBytes(int64_t n) {</a>
<a name="ln1435">    bytes_ += n;</a>
<a name="ln1436">  }</a>
<a name="ln1437"> </a>
<a name="ln1438">  void Report(const Slice&amp; name) {</a>
<a name="ln1439">    // Pretend at least one op was done in case we are running a benchmark</a>
<a name="ln1440">    // that does not call FinishedOps().</a>
<a name="ln1441">    if (done_ &lt; 1) done_ = 1;</a>
<a name="ln1442"> </a>
<a name="ln1443">    std::string extra;</a>
<a name="ln1444">    if (bytes_ &gt; 0) {</a>
<a name="ln1445">      // Rate is computed on actual elapsed time, not the sum of per-thread</a>
<a name="ln1446">      // elapsed times.</a>
<a name="ln1447">      double elapsed = (finish_ - start_) * 1e-6;</a>
<a name="ln1448">      char rate[100];</a>
<a name="ln1449">      snprintf(rate, sizeof(rate), &quot;%6.1f MB/s&quot;,</a>
<a name="ln1450">               (bytes_ / 1048576.0) / elapsed);</a>
<a name="ln1451">      extra = rate;</a>
<a name="ln1452">    }</a>
<a name="ln1453">    AppendWithSpace(&amp;extra, message_);</a>
<a name="ln1454">    double elapsed = (finish_ - start_) * 1e-6;</a>
<a name="ln1455">    double throughput = static_cast&lt;double&gt;(done_)/elapsed;</a>
<a name="ln1456"> </a>
<a name="ln1457">    fprintf(stdout, &quot;%-12s : %11.3f micros/op %&quot; PRId64 &quot; ops/sec;%s%s\n&quot;,</a>
<a name="ln1458">            name.ToString().c_str(),</a>
<a name="ln1459">            elapsed * 1e6 / done_,</a>
<a name="ln1460">            static_cast&lt;int64_t&gt;(throughput),</a>
<a name="ln1461">            (extra.empty() ? &quot;&quot; : &quot; &quot;),</a>
<a name="ln1462">            extra.c_str());</a>
<a name="ln1463">    if (FLAGS_histogram) {</a>
<a name="ln1464">      for (auto it = hist_.begin(); it != hist_.end(); ++it) {</a>
<a name="ln1465">        fprintf(stdout, &quot;Microseconds per %s:\n%s\n&quot;,</a>
<a name="ln1466">                OperationTypeString[it-&gt;first].c_str(),</a>
<a name="ln1467">                it-&gt;second.ToString().c_str());</a>
<a name="ln1468">      }</a>
<a name="ln1469">    }</a>
<a name="ln1470">    if (FLAGS_report_file_operations) {</a>
<a name="ln1471">      ReportFileOpEnv* env = static_cast&lt;ReportFileOpEnv*&gt;(FLAGS_env);</a>
<a name="ln1472">      ReportFileOpCounters* counters = env-&gt;counters();</a>
<a name="ln1473">      fprintf(stdout, &quot;Num files opened: %d\n&quot;,</a>
<a name="ln1474">              counters-&gt;open_counter_.load(std::memory_order_relaxed));</a>
<a name="ln1475">      fprintf(stdout, &quot;Num Read(): %d\n&quot;,</a>
<a name="ln1476">              counters-&gt;read_counter_.load(std::memory_order_relaxed));</a>
<a name="ln1477">      fprintf(stdout, &quot;Num Append(): %d\n&quot;,</a>
<a name="ln1478">              counters-&gt;append_counter_.load(std::memory_order_relaxed));</a>
<a name="ln1479">      fprintf(stdout, &quot;Num bytes read: %&quot; PRIu64 &quot;\n&quot;,</a>
<a name="ln1480">              counters-&gt;bytes_read_.load(std::memory_order_relaxed));</a>
<a name="ln1481">      fprintf(stdout, &quot;Num bytes written: %&quot; PRIu64 &quot;\n&quot;,</a>
<a name="ln1482">              counters-&gt;bytes_written_.load(std::memory_order_relaxed));</a>
<a name="ln1483">      env-&gt;reset();</a>
<a name="ln1484">    }</a>
<a name="ln1485">    fflush(stdout);</a>
<a name="ln1486">  }</a>
<a name="ln1487">};</a>
<a name="ln1488"> </a>
<a name="ln1489">// State shared by all concurrent executions of the same benchmark.</a>
<a name="ln1490">struct SharedState {</a>
<a name="ln1491">  port::Mutex mu;</a>
<a name="ln1492">  port::CondVar cv;</a>
<a name="ln1493">  int total;</a>
<a name="ln1494">  int perf_level;</a>
<a name="ln1495">  std::shared_ptr&lt;RateLimiter&gt; write_rate_limiter;</a>
<a name="ln1496"> </a>
<a name="ln1497">  // Each thread goes through the following states:</a>
<a name="ln1498">  //    (1) initializing</a>
<a name="ln1499">  //    (2) waiting for others to be initialized</a>
<a name="ln1500">  //    (3) running</a>
<a name="ln1501">  //    (4) done</a>
<a name="ln1502"> </a>
<a name="ln1503">  int num_initialized;</a>
<a name="ln1504">  int num_done;</a>
<a name="ln1505">  bool start;</a>
<a name="ln1506"> </a>
<a name="ln1507">  SharedState() : cv(&amp;mu), perf_level(FLAGS_perf_level) { }</a>
<a name="ln1508">};</a>
<a name="ln1509"> </a>
<a name="ln1510">// Per-thread state for concurrent executions of the same benchmark.</a>
<a name="ln1511">struct ThreadState {</a>
<a name="ln1512">  int tid;             // 0..n-1 when running in n threads</a>
<a name="ln1513">  Random64 rand;         // Has different seeds for different threads</a>
<a name="ln1514">  Stats stats;</a>
<a name="ln1515">  SharedState* shared;</a>
<a name="ln1516"> </a>
<a name="ln1517">  explicit ThreadState(int index)</a>
<a name="ln1518">      : tid(index),</a>
<a name="ln1519">        rand((FLAGS_seed ? FLAGS_seed : 1000) + index) {</a>
<a name="ln1520">  }</a>
<a name="ln1521">};</a>
<a name="ln1522"> </a>
<a name="ln1523">class Duration {</a>
<a name="ln1524"> public:</a>
<a name="ln1525">  Duration(uint64_t max_seconds, int64_t max_ops, int64_t ops_per_stage = 0) {</a>
<a name="ln1526">    max_seconds_ = max_seconds;</a>
<a name="ln1527">    max_ops_ = max_ops;</a>
<a name="ln1528">    ops_per_stage_ = (ops_per_stage &gt; 0) ? ops_per_stage : max_ops;</a>
<a name="ln1529">    ops_ = 0;</a>
<a name="ln1530">    start_at_ = FLAGS_env-&gt;NowMicros();</a>
<a name="ln1531">  }</a>
<a name="ln1532"> </a>
<a name="ln1533">  int64_t GetStage() { return std::min(ops_, max_ops_ - 1) / ops_per_stage_; }</a>
<a name="ln1534"> </a>
<a name="ln1535">  bool Done(int64_t increment) {</a>
<a name="ln1536">    if (increment &lt;= 0) increment = 1;    // avoid Done(0) and infinite loops</a>
<a name="ln1537">    ops_ += increment;</a>
<a name="ln1538"> </a>
<a name="ln1539">    if (max_seconds_) {</a>
<a name="ln1540">      // Recheck every appx 1000 ops (exact iff increment is factor of 1000)</a>
<a name="ln1541">      if ((ops_/1000) != ((ops_-increment)/1000)) {</a>
<a name="ln1542">        uint64_t now = FLAGS_env-&gt;NowMicros();</a>
<a name="ln1543">        return ((now - start_at_) / 1000000) &gt;= max_seconds_;</a>
<a name="ln1544">      } else {</a>
<a name="ln1545">        return false;</a>
<a name="ln1546">      }</a>
<a name="ln1547">    } else {</a>
<a name="ln1548">      return ops_ &gt; max_ops_;</a>
<a name="ln1549">    }</a>
<a name="ln1550">  }</a>
<a name="ln1551"> </a>
<a name="ln1552"> private:</a>
<a name="ln1553">  uint64_t max_seconds_;</a>
<a name="ln1554">  int64_t max_ops_;</a>
<a name="ln1555">  int64_t ops_per_stage_;</a>
<a name="ln1556">  int64_t ops_;</a>
<a name="ln1557">  uint64_t start_at_;</a>
<a name="ln1558">};</a>
<a name="ln1559"> </a>
<a name="ln1560">class Benchmark {</a>
<a name="ln1561"> private:</a>
<a name="ln1562">  std::shared_ptr&lt;Cache&gt; cache_;</a>
<a name="ln1563">  std::shared_ptr&lt;Cache&gt; compressed_cache_;</a>
<a name="ln1564">  std::shared_ptr&lt;const FilterPolicy&gt; filter_policy_;</a>
<a name="ln1565">  const SliceTransform* prefix_extractor_;</a>
<a name="ln1566">  DBWithColumnFamilies db_;</a>
<a name="ln1567">  std::vector&lt;DBWithColumnFamilies&gt; multi_dbs_;</a>
<a name="ln1568">  int64_t num_;</a>
<a name="ln1569">  int value_size_;</a>
<a name="ln1570">  int key_size_;</a>
<a name="ln1571">  int prefix_size_;</a>
<a name="ln1572">  int64_t keys_per_prefix_;</a>
<a name="ln1573">  int64_t entries_per_batch_;</a>
<a name="ln1574">  WriteOptions write_options_;</a>
<a name="ln1575">  Options open_options_;  // keep options around to properly destroy db later</a>
<a name="ln1576">  int64_t reads_;</a>
<a name="ln1577">  double read_random_exp_range_;</a>
<a name="ln1578">  int64_t writes_;</a>
<a name="ln1579">  int64_t readwrites_;</a>
<a name="ln1580">  int64_t merge_keys_;</a>
<a name="ln1581">  bool report_file_operations_;</a>
<a name="ln1582">  int cachedev_fd_;</a>
<a name="ln1583"> </a>
<a name="ln1584">  bool SanityCheck() {</a>
<a name="ln1585">    if (FLAGS_compression_ratio &gt; 1) {</a>
<a name="ln1586">      fprintf(stderr, &quot;compression_ratio should be between 0 and 1\n&quot;);</a>
<a name="ln1587">      return false;</a>
<a name="ln1588">    }</a>
<a name="ln1589">    return true;</a>
<a name="ln1590">  }</a>
<a name="ln1591"> </a>
<a name="ln1592">  inline bool CompressSlice(const Slice&amp; input, std::string* compressed) {</a>
<a name="ln1593">    bool ok = true;</a>
<a name="ln1594">    switch (FLAGS_compression_type_e) {</a>
<a name="ln1595">      case rocksdb::kSnappyCompression:</a>
<a name="ln1596">        ok = Snappy_Compress(Options().compression_opts, input.cdata(),</a>
<a name="ln1597">                             input.size(), compressed);</a>
<a name="ln1598">        break;</a>
<a name="ln1599">      case rocksdb::kZlibCompression:</a>
<a name="ln1600">        ok = Zlib_Compress(Options().compression_opts, 2, input.cdata(),</a>
<a name="ln1601">                           input.size(), compressed);</a>
<a name="ln1602">        break;</a>
<a name="ln1603">      case rocksdb::kBZip2Compression:</a>
<a name="ln1604">        ok = BZip2_Compress(Options().compression_opts, 2, input.cdata(),</a>
<a name="ln1605">                            input.size(), compressed);</a>
<a name="ln1606">        break;</a>
<a name="ln1607">      case rocksdb::kLZ4Compression:</a>
<a name="ln1608">        ok = LZ4_Compress(Options().compression_opts, 2, input.cdata(),</a>
<a name="ln1609">                          input.size(), compressed);</a>
<a name="ln1610">        break;</a>
<a name="ln1611">      case rocksdb::kLZ4HCCompression:</a>
<a name="ln1612">        ok = LZ4HC_Compress(Options().compression_opts, 2, input.cdata(),</a>
<a name="ln1613">                            input.size(), compressed);</a>
<a name="ln1614">        break;</a>
<a name="ln1615">      case rocksdb::kZSTDNotFinalCompression:</a>
<a name="ln1616">        ok = ZSTD_Compress(Options().compression_opts, input.cdata(),</a>
<a name="ln1617">                           input.size(), compressed);</a>
<a name="ln1618">        break;</a>
<a name="ln1619">      default:</a>
<a name="ln1620">        ok = false;</a>
<a name="ln1621">    }</a>
<a name="ln1622">    return ok;</a>
<a name="ln1623">  }</a>
<a name="ln1624"> </a>
<a name="ln1625">  void PrintHeader() {</a>
<a name="ln1626">    PrintEnvironment();</a>
<a name="ln1627">    fprintf(stdout, &quot;Keys:       %d bytes each\n&quot;, FLAGS_key_size);</a>
<a name="ln1628">    fprintf(stdout, &quot;Values:     %d bytes each (%d bytes after compression)\n&quot;,</a>
<a name="ln1629">            FLAGS_value_size,</a>
<a name="ln1630">            static_cast&lt;int&gt;(FLAGS_value_size * FLAGS_compression_ratio + 0.5));</a>
<a name="ln1631">    fprintf(stdout, &quot;Entries:    %&quot; PRIu64 &quot;\n&quot;, num_);</a>
<a name="ln1632">    fprintf(stdout, &quot;Prefix:    %d bytes\n&quot;, FLAGS_prefix_size);</a>
<a name="ln1633">    fprintf(stdout, &quot;Keys per prefix:    %&quot; PRIu64 &quot;\n&quot;, keys_per_prefix_);</a>
<a name="ln1634">    fprintf(stdout, &quot;RawSize:    %.1f MB (estimated)\n&quot;,</a>
<a name="ln1635">            ((static_cast&lt;int64_t&gt;(FLAGS_key_size + FLAGS_value_size) * num_)</a>
<a name="ln1636">             / 1048576.0));</a>
<a name="ln1637">    fprintf(stdout, &quot;FileSize:   %.1f MB (estimated)\n&quot;,</a>
<a name="ln1638">            (((FLAGS_key_size + FLAGS_value_size * FLAGS_compression_ratio)</a>
<a name="ln1639">              * num_)</a>
<a name="ln1640">             / 1048576.0));</a>
<a name="ln1641">    fprintf(stdout, &quot;Write rate: %&quot; PRIu64 &quot; bytes/second\n&quot;,</a>
<a name="ln1642">            FLAGS_benchmark_write_rate_limit);</a>
<a name="ln1643">    if (FLAGS_enable_numa) {</a>
<a name="ln1644">      fprintf(stderr, &quot;Running in NUMA enabled mode.\n&quot;);</a>
<a name="ln1645">#ifndef NUMA</a>
<a name="ln1646">      fprintf(stderr, &quot;NUMA is not defined in the system.\n&quot;);</a>
<a name="ln1647">      exit(1);</a>
<a name="ln1648">#else</a>
<a name="ln1649">      if (numa_available() == -1) {</a>
<a name="ln1650">        fprintf(stderr, &quot;NUMA is not supported by the system.\n&quot;);</a>
<a name="ln1651">        exit(1);</a>
<a name="ln1652">      }</a>
<a name="ln1653">#endif</a>
<a name="ln1654">    }</a>
<a name="ln1655"> </a>
<a name="ln1656">    auto compression = CompressionTypeToString(FLAGS_compression_type_e);</a>
<a name="ln1657">    fprintf(stdout, &quot;Compression: %s\n&quot;, compression.c_str());</a>
<a name="ln1658"> </a>
<a name="ln1659">    switch (FLAGS_rep_factory) {</a>
<a name="ln1660">      case kPrefixHash:</a>
<a name="ln1661">        fprintf(stdout, &quot;Memtablerep: prefix_hash\n&quot;);</a>
<a name="ln1662">        break;</a>
<a name="ln1663">      case kSkipList:</a>
<a name="ln1664">        fprintf(stdout, &quot;Memtablerep: skip_list\n&quot;);</a>
<a name="ln1665">        break;</a>
<a name="ln1666">      case kVectorRep:</a>
<a name="ln1667">        fprintf(stdout, &quot;Memtablerep: vector\n&quot;);</a>
<a name="ln1668">        break;</a>
<a name="ln1669">      case kHashLinkedList:</a>
<a name="ln1670">        fprintf(stdout, &quot;Memtablerep: hash_linkedlist\n&quot;);</a>
<a name="ln1671">        break;</a>
<a name="ln1672">    }</a>
<a name="ln1673">    fprintf(stdout, &quot;Perf Level: %d\n&quot;, FLAGS_perf_level);</a>
<a name="ln1674"> </a>
<a name="ln1675">    PrintWarnings(compression.c_str());</a>
<a name="ln1676">    fprintf(stdout, &quot;------------------------------------------------\n&quot;);</a>
<a name="ln1677">  }</a>
<a name="ln1678"> </a>
<a name="ln1679">  void PrintWarnings(const char* compression) {</a>
<a name="ln1680">#if defined(__GNUC__) &amp;&amp; !defined(__OPTIMIZE__)</a>
<a name="ln1681">    fprintf(stdout,</a>
<a name="ln1682">            &quot;WARNING: Optimization is disabled: benchmarks unnecessarily slow\n&quot;</a>
<a name="ln1683">            );</a>
<a name="ln1684">#endif</a>
<a name="ln1685">#ifndef NDEBUG</a>
<a name="ln1686">    fprintf(stdout,</a>
<a name="ln1687">            &quot;WARNING: Assertions are enabled; benchmarks unnecessarily slow\n&quot;);</a>
<a name="ln1688">#endif</a>
<a name="ln1689">    if (FLAGS_compression_type_e != rocksdb::kNoCompression) {</a>
<a name="ln1690">      // The test string should not be too small.</a>
<a name="ln1691">      const int len = FLAGS_block_size;</a>
<a name="ln1692">      std::string input_str(len, 'y');</a>
<a name="ln1693">      std::string compressed;</a>
<a name="ln1694">      bool result = CompressSlice(Slice(input_str), &amp;compressed);</a>
<a name="ln1695"> </a>
<a name="ln1696">      if (!result) {</a>
<a name="ln1697">        fprintf(stdout, &quot;WARNING: %s compression is not enabled\n&quot;,</a>
<a name="ln1698">                compression);</a>
<a name="ln1699">      } else if (compressed.size() &gt;= input_str.size()) {</a>
<a name="ln1700">        fprintf(stdout, &quot;WARNING: %s compression is not effective\n&quot;,</a>
<a name="ln1701">                compression);</a>
<a name="ln1702">      }</a>
<a name="ln1703">    }</a>
<a name="ln1704">  }</a>
<a name="ln1705"> </a>
<a name="ln1706">// Current the following isn't equivalent to __linux__.</a>
<a name="ln1707">#if defined(__linux)</a>
<a name="ln1708">  static Slice TrimSpace(Slice s) {</a>
<a name="ln1709">    unsigned int start = 0;</a>
<a name="ln1710">    while (start &lt; s.size() &amp;&amp; isspace(s[start])) {</a>
<a name="ln1711">      start++;</a>
<a name="ln1712">    }</a>
<a name="ln1713">    unsigned int limit = static_cast&lt;unsigned int&gt;(s.size());</a>
<a name="ln1714">    while (limit &gt; start &amp;&amp; isspace(s[limit-1])) {</a>
<a name="ln1715">      limit--;</a>
<a name="ln1716">    }</a>
<a name="ln1717">    return Slice(s.data() + start, limit - start);</a>
<a name="ln1718">  }</a>
<a name="ln1719">#endif</a>
<a name="ln1720"> </a>
<a name="ln1721">  void PrintEnvironment() {</a>
<a name="ln1722">#if defined(__linux)</a>
<a name="ln1723">    time_t now = time(nullptr);</a>
<a name="ln1724">    char buf[52];</a>
<a name="ln1725">    // Lint complains about ctime() usage, so replace it with ctime_r(). The</a>
<a name="ln1726">    // requirement is to provide a buffer which is at least 26 bytes.</a>
<a name="ln1727">    fprintf(stderr, &quot;Date:       %s&quot;,</a>
<a name="ln1728">            ctime_r(&amp;now, buf));  // ctime_r() adds newline</a>
<a name="ln1729"> </a>
<a name="ln1730">    FILE* cpuinfo = fopen(&quot;/proc/cpuinfo&quot;, &quot;r&quot;);</a>
<a name="ln1731">    if (cpuinfo != nullptr) {</a>
<a name="ln1732">      char line[1000];</a>
<a name="ln1733">      int num_cpus = 0;</a>
<a name="ln1734">      std::string cpu_type;</a>
<a name="ln1735">      std::string cache_size;</a>
<a name="ln1736">      while (fgets(line, sizeof(line), cpuinfo) != nullptr) {</a>
<a name="ln1737">        const char* sep = strchr(line, ':');</a>
<a name="ln1738">        if (sep == nullptr) {</a>
<a name="ln1739">          continue;</a>
<a name="ln1740">        }</a>
<a name="ln1741">        Slice key = TrimSpace(Slice(line, sep - 1 - line));</a>
<a name="ln1742">        Slice val = TrimSpace(Slice(sep + 1));</a>
<a name="ln1743">        if (key == &quot;model name&quot;) {</a>
<a name="ln1744">          ++num_cpus;</a>
<a name="ln1745">          cpu_type = val.ToString();</a>
<a name="ln1746">        } else if (key == &quot;cache size&quot;) {</a>
<a name="ln1747">          cache_size = val.ToString();</a>
<a name="ln1748">        }</a>
<a name="ln1749">      }</a>
<a name="ln1750">      fclose(cpuinfo);</a>
<a name="ln1751">      fprintf(stderr, &quot;CPU:        %d * %s\n&quot;, num_cpus, cpu_type.c_str());</a>
<a name="ln1752">      fprintf(stderr, &quot;CPUCache:   %s\n&quot;, cache_size.c_str());</a>
<a name="ln1753">    }</a>
<a name="ln1754">#endif</a>
<a name="ln1755">  }</a>
<a name="ln1756"> </a>
<a name="ln1757"> public:</a>
<a name="ln1758">  Benchmark()</a>
<a name="ln1759">      : cache_(</a>
<a name="ln1760">            FLAGS_cache_size &gt;= 0</a>
<a name="ln1761">                ? (FLAGS_cache_numshardbits &gt;= 1</a>
<a name="ln1762">                       ? NewLRUCache(FLAGS_cache_size, FLAGS_cache_numshardbits)</a>
<a name="ln1763">                       : NewLRUCache(FLAGS_cache_size))</a>
<a name="ln1764">                : nullptr),</a>
<a name="ln1765">        compressed_cache_(FLAGS_compressed_cache_size &gt;= 0</a>
<a name="ln1766">                              ? (FLAGS_cache_numshardbits &gt;= 1</a>
<a name="ln1767">                                     ? NewLRUCache(FLAGS_compressed_cache_size,</a>
<a name="ln1768">                                                   FLAGS_cache_numshardbits)</a>
<a name="ln1769">                                     : NewLRUCache(FLAGS_compressed_cache_size))</a>
<a name="ln1770">                              : nullptr),</a>
<a name="ln1771">        filter_policy_(FLAGS_bloom_bits &gt;= 0</a>
<a name="ln1772">                           ? NewBloomFilterPolicy(FLAGS_bloom_bits,</a>
<a name="ln1773">                                                  FLAGS_use_block_based_filter)</a>
<a name="ln1774">                           : nullptr),</a>
<a name="ln1775">        prefix_extractor_(NewFixedPrefixTransform(FLAGS_prefix_size)),</a>
<a name="ln1776">        num_(FLAGS_num),</a>
<a name="ln1777">        value_size_(FLAGS_value_size),</a>
<a name="ln1778">        key_size_(FLAGS_key_size),</a>
<a name="ln1779">        prefix_size_(FLAGS_prefix_size),</a>
<a name="ln1780">        keys_per_prefix_(FLAGS_keys_per_prefix),</a>
<a name="ln1781">        entries_per_batch_(1),</a>
<a name="ln1782">        reads_(FLAGS_reads &lt; 0 ? FLAGS_num : FLAGS_reads),</a>
<a name="ln1783">        read_random_exp_range_(0.0),</a>
<a name="ln1784">        writes_(FLAGS_writes &lt; 0 ? FLAGS_num : FLAGS_writes),</a>
<a name="ln1785">        readwrites_(</a>
<a name="ln1786">            (FLAGS_writes &lt; 0 &amp;&amp; FLAGS_reads &lt; 0)</a>
<a name="ln1787">                ? FLAGS_num</a>
<a name="ln1788">                : ((FLAGS_writes &gt; FLAGS_reads) ? FLAGS_writes : FLAGS_reads)),</a>
<a name="ln1789">        merge_keys_(FLAGS_merge_keys &lt; 0 ? FLAGS_num : FLAGS_merge_keys),</a>
<a name="ln1790">        report_file_operations_(FLAGS_report_file_operations),</a>
<a name="ln1791">        cachedev_fd_(-1) {</a>
<a name="ln1792">    if (report_file_operations_) {</a>
<a name="ln1793">      if (!FLAGS_hdfs.empty()) {</a>
<a name="ln1794">        fprintf(stderr,</a>
<a name="ln1795">                &quot;--hdfs and --report_file_operations cannot be enabled &quot;</a>
<a name="ln1796">                &quot;at the same time&quot;);</a>
<a name="ln1797">        exit(1);</a>
<a name="ln1798">      }</a>
<a name="ln1799">      FLAGS_env = new ReportFileOpEnv(rocksdb::Env::Default());</a>
<a name="ln1800">    }</a>
<a name="ln1801"> </a>
<a name="ln1802">    if (FLAGS_prefix_size &gt; FLAGS_key_size) {</a>
<a name="ln1803">      fprintf(stderr, &quot;prefix size is larger than key size&quot;);</a>
<a name="ln1804">      exit(1);</a>
<a name="ln1805">    }</a>
<a name="ln1806"> </a>
<a name="ln1807">    std::vector&lt;std::string&gt; files;</a>
<a name="ln1808">    FLAGS_env-&gt;GetChildrenWarnNotOk(FLAGS_db, &amp;files);</a>
<a name="ln1809">    for (size_t i = 0; i &lt; files.size(); i++) {</a>
<a name="ln1810">      if (Slice(files[i]).starts_with(&quot;heap-&quot;)) {</a>
<a name="ln1811">        CHECK_OK(FLAGS_env-&gt;DeleteFile(FLAGS_db + &quot;/&quot; + files[i]));</a>
<a name="ln1812">      }</a>
<a name="ln1813">    }</a>
<a name="ln1814">    if (!FLAGS_use_existing_db) {</a>
<a name="ln1815">      Options options;</a>
<a name="ln1816">      if (!FLAGS_wal_dir.empty()) {</a>
<a name="ln1817">        options.wal_dir = FLAGS_wal_dir;</a>
<a name="ln1818">      }</a>
<a name="ln1819">      CHECK_OK(DestroyDB(FLAGS_db, options));</a>
<a name="ln1820">    }</a>
<a name="ln1821">  }</a>
<a name="ln1822"> </a>
<a name="ln1823">  ~Benchmark() {</a>
<a name="ln1824">    db_.DeleteDBs();</a>
<a name="ln1825">    delete prefix_extractor_;</a>
<a name="ln1826">    if (cache_.get() != nullptr) {</a>
<a name="ln1827">      // this will leak, but we're shutting down so nobody cares</a>
<a name="ln1828">      cache_-&gt;DisownData();</a>
<a name="ln1829">    }</a>
<a name="ln1830">    if (FLAGS_disable_flashcache_for_background_threads &amp;&amp; cachedev_fd_ != -1) {</a>
<a name="ln1831">      // Dtor for this env should run before cachedev_fd_ is closed</a>
<a name="ln1832">      flashcache_aware_env_ = nullptr;</a>
<a name="ln1833">      close(cachedev_fd_);</a>
<a name="ln1834">    }</a>
<a name="ln1835">  }</a>
<a name="ln1836"> </a>
<a name="ln1837">  Slice AllocateKey(std::unique_ptr&lt;const char[]&gt;* key_guard) {</a>
<a name="ln1838">    char* data = new char[key_size_];</a>
<a name="ln1839">    const char* const_data = data;</a>
<a name="ln1840">    key_guard-&gt;reset(const_data);</a>
<a name="ln1841">    return Slice(key_guard-&gt;get(), key_size_);</a>
<a name="ln1842">  }</a>
<a name="ln1843"> </a>
<a name="ln1844">  // Generate key according to the given specification and random number.</a>
<a name="ln1845">  // The resulting key will have the following format (if keys_per_prefix_</a>
<a name="ln1846">  // is positive), extra trailing bytes are either cut off or paddd with '0'.</a>
<a name="ln1847">  // The prefix value is derived from key value.</a>
<a name="ln1848">  //   ----------------------------</a>
<a name="ln1849">  //   | prefix 00000 | key 00000 |</a>
<a name="ln1850">  //   ----------------------------</a>
<a name="ln1851">  // If keys_per_prefix_ is 0, the key is simply a binary representation of</a>
<a name="ln1852">  // random number followed by trailing '0's</a>
<a name="ln1853">  //   ----------------------------</a>
<a name="ln1854">  //   |        key 00000         |</a>
<a name="ln1855">  //   ----------------------------</a>
<a name="ln1856">  void GenerateKeyFromInt(uint64_t v, int64_t num_keys, Slice* key) {</a>
<a name="ln1857">    char* start = const_cast&lt;char*&gt;(key-&gt;cdata());</a>
<a name="ln1858">    char* pos = start;</a>
<a name="ln1859">    if (keys_per_prefix_ &gt; 0) {</a>
<a name="ln1860">      int64_t num_prefix = num_keys / keys_per_prefix_;</a>
<a name="ln1861">      int64_t prefix = v % num_prefix;</a>
<a name="ln1862">      int bytes_to_fill = std::min(prefix_size_, 8);</a>
<a name="ln1863">      if (port::kLittleEndian) {</a>
<a name="ln1864">        for (int i = 0; i &lt; bytes_to_fill; ++i) {</a>
<a name="ln1865">          pos[i] = (prefix &gt;&gt; ((bytes_to_fill - i - 1) &lt;&lt; 3)) &amp; 0xFF;</a>
<a name="ln1866">        }</a>
<a name="ln1867">      } else {</a>
<a name="ln1868">        memcpy(pos, static_cast&lt;void*&gt;(&amp;prefix), bytes_to_fill);</a>
<a name="ln1869">      }</a>
<a name="ln1870">      if (prefix_size_ &gt; 8) {</a>
<a name="ln1871">        // fill the rest with 0s</a>
<a name="ln1872">        memset(pos + 8, '0', prefix_size_ - 8);</a>
<a name="ln1873">      }</a>
<a name="ln1874">      pos += prefix_size_;</a>
<a name="ln1875">    }</a>
<a name="ln1876"> </a>
<a name="ln1877">    int bytes_to_fill = std::min(key_size_ - static_cast&lt;int&gt;(pos - start), 8);</a>
<a name="ln1878">    if (port::kLittleEndian) {</a>
<a name="ln1879">      for (int i = 0; i &lt; bytes_to_fill; ++i) {</a>
<a name="ln1880">        pos[i] = (v &gt;&gt; ((bytes_to_fill - i - 1) &lt;&lt; 3)) &amp; 0xFF;</a>
<a name="ln1881">      }</a>
<a name="ln1882">    } else {</a>
<a name="ln1883">      memcpy(pos, static_cast&lt;void*&gt;(&amp;v), bytes_to_fill);</a>
<a name="ln1884">    }</a>
<a name="ln1885">    pos += bytes_to_fill;</a>
<a name="ln1886">    if (key_size_ &gt; pos - start) {</a>
<a name="ln1887">      memset(pos, '0', key_size_ - (pos - start));</a>
<a name="ln1888">    }</a>
<a name="ln1889">  }</a>
<a name="ln1890"> </a>
<a name="ln1891">  std::string GetDbNameForMultiple(std::string base_name, size_t id) {</a>
<a name="ln1892">    return base_name + ToString(id);</a>
<a name="ln1893">  }</a>
<a name="ln1894"> </a>
<a name="ln1895">  void Run() {</a>
<a name="ln1896">    if (!SanityCheck()) {</a>
<a name="ln1897">      exit(1);</a>
<a name="ln1898">    }</a>
<a name="ln1899">    PrintHeader();</a>
<a name="ln1900">    Open(&amp;open_options_);</a>
<a name="ln1901">    std::stringstream benchmark_stream(FLAGS_benchmarks);</a>
<a name="ln1902">    std::string name;</a>
<a name="ln1903">    while (std::getline(benchmark_stream, name, ',')) {</a>
<a name="ln1904">      // Sanitize parameters</a>
<a name="ln1905">      num_ = FLAGS_num;</a>
<a name="ln1906">      reads_ = (FLAGS_reads &lt; 0 ? FLAGS_num : FLAGS_reads);</a>
<a name="ln1907">      writes_ = (FLAGS_writes &lt; 0 ? FLAGS_num : FLAGS_writes);</a>
<a name="ln1908">      value_size_ = FLAGS_value_size;</a>
<a name="ln1909">      key_size_ = FLAGS_key_size;</a>
<a name="ln1910">      entries_per_batch_ = FLAGS_batch_size;</a>
<a name="ln1911">      write_options_ = WriteOptions();</a>
<a name="ln1912">      read_random_exp_range_ = FLAGS_read_random_exp_range;</a>
<a name="ln1913">      if (FLAGS_sync) {</a>
<a name="ln1914">        write_options_.sync = true;</a>
<a name="ln1915">      }</a>
<a name="ln1916">      write_options_.disableWAL = FLAGS_disable_wal;</a>
<a name="ln1917"> </a>
<a name="ln1918">      void (Benchmark::*method)(ThreadState*) = nullptr;</a>
<a name="ln1919">      void (Benchmark::*post_process_method)() = nullptr;</a>
<a name="ln1920"> </a>
<a name="ln1921">      bool fresh_db = false;</a>
<a name="ln1922">      int num_threads = FLAGS_threads;</a>
<a name="ln1923"> </a>
<a name="ln1924">      if (name == &quot;fillseq&quot;) {</a>
<a name="ln1925">        fresh_db = true;</a>
<a name="ln1926">        method = &amp;Benchmark::WriteSeq;</a>
<a name="ln1927">      } else if (name == &quot;fillbatch&quot;) {</a>
<a name="ln1928">        fresh_db = true;</a>
<a name="ln1929">        entries_per_batch_ = 1000;</a>
<a name="ln1930">        method = &amp;Benchmark::WriteSeq;</a>
<a name="ln1931">      } else if (name == &quot;fillrandom&quot;) {</a>
<a name="ln1932">        fresh_db = true;</a>
<a name="ln1933">        method = &amp;Benchmark::WriteRandom;</a>
<a name="ln1934">      } else if (name == &quot;filluniquerandom&quot;) {</a>
<a name="ln1935">        fresh_db = true;</a>
<a name="ln1936">        if (num_threads &gt; 1) {</a>
<a name="ln1937">          fprintf(stderr,</a>
<a name="ln1938">                  &quot;filluniquerandom multithreaded not supported&quot;</a>
<a name="ln1939">                  &quot;, use 1 thread&quot;);</a>
<a name="ln1940">          num_threads = 1;</a>
<a name="ln1941">        }</a>
<a name="ln1942">        method = &amp;Benchmark::WriteUniqueRandom;</a>
<a name="ln1943">      } else if (name == &quot;overwrite&quot;) {</a>
<a name="ln1944">        method = &amp;Benchmark::WriteRandom;</a>
<a name="ln1945">      } else if (name == &quot;fillsync&quot;) {</a>
<a name="ln1946">        fresh_db = true;</a>
<a name="ln1947">        num_ /= 1000;</a>
<a name="ln1948">        write_options_.sync = true;</a>
<a name="ln1949">        method = &amp;Benchmark::WriteRandom;</a>
<a name="ln1950">      } else if (name == &quot;fill100K&quot;) {</a>
<a name="ln1951">        fresh_db = true;</a>
<a name="ln1952">        num_ /= 1000;</a>
<a name="ln1953">        value_size_ = 100 * 1000;</a>
<a name="ln1954">        method = &amp;Benchmark::WriteRandom;</a>
<a name="ln1955">      } else if (name == &quot;readseq&quot;) {</a>
<a name="ln1956">        method = &amp;Benchmark::ReadSequential;</a>
<a name="ln1957">      } else if (name == &quot;readtocache&quot;) {</a>
<a name="ln1958">        method = &amp;Benchmark::ReadSequential;</a>
<a name="ln1959">        num_threads = 1;</a>
<a name="ln1960">        reads_ = num_;</a>
<a name="ln1961">      } else if (name == &quot;readreverse&quot;) {</a>
<a name="ln1962">        method = &amp;Benchmark::ReadReverse;</a>
<a name="ln1963">      } else if (name == &quot;readrandom&quot;) {</a>
<a name="ln1964">        method = &amp;Benchmark::ReadRandom;</a>
<a name="ln1965">      } else if (name == &quot;readrandomfast&quot;) {</a>
<a name="ln1966">        method = &amp;Benchmark::ReadRandomFast;</a>
<a name="ln1967">      } else if (name == &quot;multireadrandom&quot;) {</a>
<a name="ln1968">        fprintf(stderr, &quot;entries_per_batch = %&quot; PRIi64 &quot;\n&quot;,</a>
<a name="ln1969">                entries_per_batch_);</a>
<a name="ln1970">        method = &amp;Benchmark::MultiReadRandom;</a>
<a name="ln1971">      } else if (name == &quot;readmissing&quot;) {</a>
<a name="ln1972">        ++key_size_;</a>
<a name="ln1973">        method = &amp;Benchmark::ReadRandom;</a>
<a name="ln1974">      } else if (name == &quot;newiterator&quot;) {</a>
<a name="ln1975">        method = &amp;Benchmark::IteratorCreation;</a>
<a name="ln1976">      } else if (name == &quot;newiteratorwhilewriting&quot;) {</a>
<a name="ln1977">        num_threads++;  // Add extra thread for writing</a>
<a name="ln1978">        method = &amp;Benchmark::IteratorCreationWhileWriting;</a>
<a name="ln1979">      } else if (name == &quot;seekrandom&quot;) {</a>
<a name="ln1980">        method = &amp;Benchmark::SeekRandom;</a>
<a name="ln1981">      } else if (name == &quot;seekrandomwhilewriting&quot;) {</a>
<a name="ln1982">        num_threads++;  // Add extra thread for writing</a>
<a name="ln1983">        method = &amp;Benchmark::SeekRandomWhileWriting;</a>
<a name="ln1984">      } else if (name == &quot;seekrandomwhilemerging&quot;) {</a>
<a name="ln1985">        num_threads++;  // Add extra thread for merging</a>
<a name="ln1986">        method = &amp;Benchmark::SeekRandomWhileMerging;</a>
<a name="ln1987">      } else if (name == &quot;readrandomsmall&quot;) {</a>
<a name="ln1988">        reads_ /= 1000;</a>
<a name="ln1989">        method = &amp;Benchmark::ReadRandom;</a>
<a name="ln1990">      } else if (name == &quot;deleteseq&quot;) {</a>
<a name="ln1991">        method = &amp;Benchmark::DeleteSeq;</a>
<a name="ln1992">      } else if (name == &quot;deleterandom&quot;) {</a>
<a name="ln1993">        method = &amp;Benchmark::DeleteRandom;</a>
<a name="ln1994">      } else if (name == &quot;readwhilewriting&quot;) {</a>
<a name="ln1995">        num_threads++;  // Add extra thread for writing</a>
<a name="ln1996">        method = &amp;Benchmark::ReadWhileWriting;</a>
<a name="ln1997">      } else if (name == &quot;readwhilemerging&quot;) {</a>
<a name="ln1998">        num_threads++;  // Add extra thread for writing</a>
<a name="ln1999">        method = &amp;Benchmark::ReadWhileMerging;</a>
<a name="ln2000">      } else if (name == &quot;readrandomwriterandom&quot;) {</a>
<a name="ln2001">        method = &amp;Benchmark::ReadRandomWriteRandom;</a>
<a name="ln2002">      } else if (name == &quot;readrandommergerandom&quot;) {</a>
<a name="ln2003">        if (FLAGS_merge_operator.empty()) {</a>
<a name="ln2004">          fprintf(stdout, &quot;%-12s : skipped (--merge_operator is unknown)\n&quot;,</a>
<a name="ln2005">                  name.c_str());</a>
<a name="ln2006">          exit(1);</a>
<a name="ln2007">        }</a>
<a name="ln2008">        method = &amp;Benchmark::ReadRandomMergeRandom;</a>
<a name="ln2009">      } else if (name == &quot;updaterandom&quot;) {</a>
<a name="ln2010">        method = &amp;Benchmark::UpdateRandom;</a>
<a name="ln2011">      } else if (name == &quot;appendrandom&quot;) {</a>
<a name="ln2012">        method = &amp;Benchmark::AppendRandom;</a>
<a name="ln2013">      } else if (name == &quot;mergerandom&quot;) {</a>
<a name="ln2014">        if (FLAGS_merge_operator.empty()) {</a>
<a name="ln2015">          fprintf(stdout, &quot;%-12s : skipped (--merge_operator is unknown)\n&quot;,</a>
<a name="ln2016">                  name.c_str());</a>
<a name="ln2017">          exit(1);</a>
<a name="ln2018">        }</a>
<a name="ln2019">        method = &amp;Benchmark::MergeRandom;</a>
<a name="ln2020">      } else if (name == &quot;randomwithverify&quot;) {</a>
<a name="ln2021">        method = &amp;Benchmark::RandomWithVerify;</a>
<a name="ln2022">      } else if (name == &quot;fillseekseq&quot;) {</a>
<a name="ln2023">        method = &amp;Benchmark::WriteSeqSeekSeq;</a>
<a name="ln2024">      } else if (name == &quot;compact&quot;) {</a>
<a name="ln2025">        method = &amp;Benchmark::Compact;</a>
<a name="ln2026">      } else if (name == &quot;crc32c&quot;) {</a>
<a name="ln2027">        method = &amp;Benchmark::Crc32c;</a>
<a name="ln2028">      } else if (name == &quot;xxhash&quot;) {</a>
<a name="ln2029">        method = &amp;Benchmark::xxHash;</a>
<a name="ln2030">      } else if (name == &quot;acquireload&quot;) {</a>
<a name="ln2031">        method = &amp;Benchmark::AcquireLoad;</a>
<a name="ln2032">      } else if (name == &quot;compress&quot;) {</a>
<a name="ln2033">        method = &amp;Benchmark::Compress;</a>
<a name="ln2034">      } else if (name == &quot;uncompress&quot;) {</a>
<a name="ln2035">        method = &amp;Benchmark::Uncompress;</a>
<a name="ln2036">#ifndef ROCKSDB_LITE</a>
<a name="ln2037">      } else if (name == &quot;randomtransaction&quot;) {</a>
<a name="ln2038">        method = &amp;Benchmark::RandomTransaction;</a>
<a name="ln2039">        post_process_method = &amp;Benchmark::RandomTransactionVerify;</a>
<a name="ln2040">#endif  // ROCKSDB_LITE</a>
<a name="ln2041">      } else if (name == &quot;randomreplacekeys&quot;) {</a>
<a name="ln2042">        fresh_db = true;</a>
<a name="ln2043">        method = &amp;Benchmark::RandomReplaceKeys;</a>
<a name="ln2044">      } else if (name == &quot;stats&quot;) {</a>
<a name="ln2045">        PrintStats(&quot;rocksdb.stats&quot;);</a>
<a name="ln2046">      } else if (name == &quot;levelstats&quot;) {</a>
<a name="ln2047">        PrintStats(&quot;rocksdb.levelstats&quot;);</a>
<a name="ln2048">      } else if (name == &quot;sstables&quot;) {</a>
<a name="ln2049">        PrintStats(&quot;rocksdb.sstables&quot;);</a>
<a name="ln2050">      } else if (!name.empty()) {  // No error message for empty name</a>
<a name="ln2051">        fprintf(stderr, &quot;unknown benchmark '%s'\n&quot;, name.c_str());</a>
<a name="ln2052">        exit(1);</a>
<a name="ln2053">      }</a>
<a name="ln2054"> </a>
<a name="ln2055">      if (fresh_db) {</a>
<a name="ln2056">        if (FLAGS_use_existing_db) {</a>
<a name="ln2057">          fprintf(stdout, &quot;%-12s : skipped (--use_existing_db is true)\n&quot;,</a>
<a name="ln2058">                  name.c_str());</a>
<a name="ln2059">          method = nullptr;</a>
<a name="ln2060">        } else {</a>
<a name="ln2061">          if (db_.db != nullptr) {</a>
<a name="ln2062">            db_.DeleteDBs();</a>
<a name="ln2063">            CHECK_OK(DestroyDB(FLAGS_db, open_options_));</a>
<a name="ln2064">          }</a>
<a name="ln2065">          for (size_t i = 0; i &lt; multi_dbs_.size(); i++) {</a>
<a name="ln2066">            delete multi_dbs_[i].db;</a>
<a name="ln2067">            CHECK_OK(DestroyDB(GetDbNameForMultiple(FLAGS_db, i), open_options_));</a>
<a name="ln2068">          }</a>
<a name="ln2069">          multi_dbs_.clear();</a>
<a name="ln2070">        }</a>
<a name="ln2071">        Open(&amp;open_options_);  // use open_options for the last accessed</a>
<a name="ln2072">      }</a>
<a name="ln2073"> </a>
<a name="ln2074">      if (method != nullptr) {</a>
<a name="ln2075">        fprintf(stdout, &quot;DB path: [%s]\n&quot;, FLAGS_db.c_str());</a>
<a name="ln2076">        RunBenchmark(num_threads, name, method);</a>
<a name="ln2077">      }</a>
<a name="ln2078">      if (post_process_method != nullptr) {</a>
<a name="ln2079">        (this-&gt;*post_process_method)();</a>
<a name="ln2080">      }</a>
<a name="ln2081">    }</a>
<a name="ln2082">    if (FLAGS_statistics) {</a>
<a name="ln2083">     fprintf(stdout, &quot;STATISTICS:\n%s\n&quot;, dbstats-&gt;ToString().c_str());</a>
<a name="ln2084">    }</a>
<a name="ln2085">  }</a>
<a name="ln2086"> </a>
<a name="ln2087"> private:</a>
<a name="ln2088">  std::unique_ptr&lt;Env&gt; flashcache_aware_env_;</a>
<a name="ln2089"> </a>
<a name="ln2090">  struct ThreadArg {</a>
<a name="ln2091">    Benchmark* bm;</a>
<a name="ln2092">    SharedState* shared;</a>
<a name="ln2093">    ThreadState* thread;</a>
<a name="ln2094">    void (Benchmark::*method)(ThreadState*);</a>
<a name="ln2095">  };</a>
<a name="ln2096"> </a>
<a name="ln2097">  static void ThreadBody(void* v) {</a>
<a name="ln2098">    ThreadArg* arg = reinterpret_cast&lt;ThreadArg*&gt;(v);</a>
<a name="ln2099">    SharedState* shared = arg-&gt;shared;</a>
<a name="ln2100">    ThreadState* thread = arg-&gt;thread;</a>
<a name="ln2101">    {</a>
<a name="ln2102">      MutexLock l(&amp;shared-&gt;mu);</a>
<a name="ln2103">      shared-&gt;num_initialized++;</a>
<a name="ln2104">      if (shared-&gt;num_initialized &gt;= shared-&gt;total) {</a>
<a name="ln2105">        shared-&gt;cv.SignalAll();</a>
<a name="ln2106">      }</a>
<a name="ln2107">      while (!shared-&gt;start) {</a>
<a name="ln2108">        shared-&gt;cv.Wait();</a>
<a name="ln2109">      }</a>
<a name="ln2110">    }</a>
<a name="ln2111"> </a>
<a name="ln2112">    SetPerfLevel(static_cast&lt;PerfLevel&gt; (shared-&gt;perf_level));</a>
<a name="ln2113">    thread-&gt;stats.Start(thread-&gt;tid);</a>
<a name="ln2114">    (arg-&gt;bm-&gt;*(arg-&gt;method))(thread);</a>
<a name="ln2115">    thread-&gt;stats.Stop();</a>
<a name="ln2116"> </a>
<a name="ln2117">    {</a>
<a name="ln2118">      MutexLock l(&amp;shared-&gt;mu);</a>
<a name="ln2119">      shared-&gt;num_done++;</a>
<a name="ln2120">      if (shared-&gt;num_done &gt;= shared-&gt;total) {</a>
<a name="ln2121">        shared-&gt;cv.SignalAll();</a>
<a name="ln2122">      }</a>
<a name="ln2123">    }</a>
<a name="ln2124">  }</a>
<a name="ln2125"> </a>
<a name="ln2126">  void RunBenchmark(int n, Slice name,</a>
<a name="ln2127">                    void (Benchmark::*method)(ThreadState*)) {</a>
<a name="ln2128">    SharedState shared;</a>
<a name="ln2129">    shared.total = n;</a>
<a name="ln2130">    shared.num_initialized = 0;</a>
<a name="ln2131">    shared.num_done = 0;</a>
<a name="ln2132">    shared.start = false;</a>
<a name="ln2133">    if (FLAGS_benchmark_write_rate_limit &gt; 0) {</a>
<a name="ln2134">      shared.write_rate_limiter.reset(</a>
<a name="ln2135">          NewGenericRateLimiter(FLAGS_benchmark_write_rate_limit));</a>
<a name="ln2136">    }</a>
<a name="ln2137"> </a>
<a name="ln2138">    std::unique_ptr&lt;ReporterAgent&gt; reporter_agent;</a>
<a name="ln2139">    if (FLAGS_report_interval_seconds &gt; 0) {</a>
<a name="ln2140">      reporter_agent.reset(new ReporterAgent(FLAGS_env, FLAGS_report_file,</a>
<a name="ln2141">                                             FLAGS_report_interval_seconds));</a>
<a name="ln2142">    }</a>
<a name="ln2143"> </a>
<a name="ln2144">    ThreadArg* arg = new ThreadArg[n];</a>
<a name="ln2145"> </a>
<a name="ln2146">    for (int i = 0; i &lt; n; i++) {</a>
<a name="ln2147">#ifdef NUMA</a>
<a name="ln2148">      if (FLAGS_enable_numa) {</a>
<a name="ln2149">        // Performs a local allocation of memory to threads in numa node.</a>
<a name="ln2150">        int n_nodes = numa_num_task_nodes();  // Number of nodes in NUMA.</a>
<a name="ln2151">        numa_exit_on_error = 1;</a>
<a name="ln2152">        uint64_t numa_node = i % n_nodes;</a>
<a name="ln2153">        bitmask* nodes = numa_allocate_nodemask();</a>
<a name="ln2154">        numa_bitmask_clearall(nodes);</a>
<a name="ln2155">        numa_bitmask_setbit(nodes, numa_node);</a>
<a name="ln2156">        // numa_bind() call binds the process to the node and these</a>
<a name="ln2157">        // properties are passed on to the thread that is created in</a>
<a name="ln2158">        // StartThread method called later in the loop.</a>
<a name="ln2159">        numa_bind(nodes);</a>
<a name="ln2160">        numa_set_strict(1);</a>
<a name="ln2161">        numa_free_nodemask(nodes);</a>
<a name="ln2162">      }</a>
<a name="ln2163">#endif</a>
<a name="ln2164">      arg[i].bm = this;</a>
<a name="ln2165">      arg[i].method = method;</a>
<a name="ln2166">      arg[i].shared = &amp;shared;</a>
<a name="ln2167">      arg[i].thread = new ThreadState(i);</a>
<a name="ln2168">      arg[i].thread-&gt;stats.SetReporterAgent(reporter_agent.get());</a>
<a name="ln2169">      arg[i].thread-&gt;shared = &amp;shared;</a>
<a name="ln2170">      FLAGS_env-&gt;StartThread(ThreadBody, &amp;arg[i]);</a>
<a name="ln2171">    }</a>
<a name="ln2172"> </a>
<a name="ln2173">    shared.mu.Lock();</a>
<a name="ln2174">    while (shared.num_initialized &lt; n) {</a>
<a name="ln2175">      shared.cv.Wait();</a>
<a name="ln2176">    }</a>
<a name="ln2177"> </a>
<a name="ln2178">    shared.start = true;</a>
<a name="ln2179">    shared.cv.SignalAll();</a>
<a name="ln2180">    while (shared.num_done &lt; n) {</a>
<a name="ln2181">      shared.cv.Wait();</a>
<a name="ln2182">    }</a>
<a name="ln2183">    shared.mu.Unlock();</a>
<a name="ln2184"> </a>
<a name="ln2185">    // Stats for some threads can be excluded.</a>
<a name="ln2186">    Stats merge_stats;</a>
<a name="ln2187">    for (int i = 0; i &lt; n; i++) {</a>
<a name="ln2188">      merge_stats.Merge(arg[i].thread-&gt;stats);</a>
<a name="ln2189">    }</a>
<a name="ln2190">    merge_stats.Report(name);</a>
<a name="ln2191"> </a>
<a name="ln2192">    for (int i = 0; i &lt; n; i++) {</a>
<a name="ln2193">      delete arg[i].thread;</a>
<a name="ln2194">    }</a>
<a name="ln2195">    delete[] arg;</a>
<a name="ln2196">  }</a>
<a name="ln2197"> </a>
<a name="ln2198">  void Crc32c(ThreadState* thread) {</a>
<a name="ln2199">    // Checksum about 500MB of data total</a>
<a name="ln2200">    const int size = 4096;</a>
<a name="ln2201">    const char* label = &quot;(4K per op)&quot;;</a>
<a name="ln2202">    std::string data(size, 'x');</a>
<a name="ln2203">    int64_t bytes = 0;</a>
<a name="ln2204">    uint32_t crc = 0;</a>
<a name="ln2205">    while (bytes &lt; 500 * 1048576) {</a>
<a name="ln2206">      crc = crc32c::Value(data.data(), size);</a>
<a name="ln2207">      thread-&gt;stats.FinishedOps(nullptr, nullptr, 1, kCrc);</a>
<a name="ln2208">      bytes += size;</a>
<a name="ln2209">    }</a>
<a name="ln2210">    // Print so result is not dead</a>
<a name="ln2211">    fprintf(stderr, &quot;... crc=0x%x\r&quot;, static_cast&lt;unsigned int&gt;(crc));</a>
<a name="ln2212"> </a>
<a name="ln2213">    thread-&gt;stats.AddBytes(bytes);</a>
<a name="ln2214">    thread-&gt;stats.AddMessage(label);</a>
<a name="ln2215">  }</a>
<a name="ln2216"> </a>
<a name="ln2217">  void xxHash(ThreadState* thread) {</a>
<a name="ln2218">    // Checksum about 500MB of data total</a>
<a name="ln2219">    const int size = 4096;</a>
<a name="ln2220">    const char* label = &quot;(4K per op)&quot;;</a>
<a name="ln2221">    std::string data(size, 'x');</a>
<a name="ln2222">    int64_t bytes = 0;</a>
<a name="ln2223">    unsigned int xxh32 = 0;</a>
<a name="ln2224">    while (bytes &lt; 500 * 1048576) {</a>
<a name="ln2225">      xxh32 = XXH32(data.data(), size, 0);</a>
<a name="ln2226">      thread-&gt;stats.FinishedOps(nullptr, nullptr, 1, kHash);</a>
<a name="ln2227">      bytes += size;</a>
<a name="ln2228">    }</a>
<a name="ln2229">    // Print so result is not dead</a>
<a name="ln2230">    fprintf(stderr, &quot;... xxh32=0x%x\r&quot;, static_cast&lt;unsigned int&gt;(xxh32));</a>
<a name="ln2231"> </a>
<a name="ln2232">    thread-&gt;stats.AddBytes(bytes);</a>
<a name="ln2233">    thread-&gt;stats.AddMessage(label);</a>
<a name="ln2234">  }</a>
<a name="ln2235"> </a>
<a name="ln2236">  void AcquireLoad(ThreadState* thread) {</a>
<a name="ln2237">    int dummy;</a>
<a name="ln2238">    std::atomic&lt;void*&gt; ap(&amp;dummy);</a>
<a name="ln2239">    int count = 0;</a>
<a name="ln2240">    void *ptr = nullptr;</a>
<a name="ln2241">    thread-&gt;stats.AddMessage(&quot;(each op is 1000 loads)&quot;);</a>
<a name="ln2242">    while (count &lt; 100000) {</a>
<a name="ln2243">      for (int i = 0; i &lt; 1000; i++) {</a>
<a name="ln2244">        ptr = ap.load(std::memory_order_acquire);</a>
<a name="ln2245">      }</a>
<a name="ln2246">      count++;</a>
<a name="ln2247">      thread-&gt;stats.FinishedOps(nullptr, nullptr, 1, kOthers);</a>
<a name="ln2248">    }</a>
<a name="ln2249">    if (ptr == nullptr) exit(1);  // Disable unused variable warning.</a>
<a name="ln2250">  }</a>
<a name="ln2251"> </a>
<a name="ln2252">  void Compress(ThreadState *thread) {</a>
<a name="ln2253">    RandomGenerator gen;</a>
<a name="ln2254">    Slice input = gen.Generate(FLAGS_block_size);</a>
<a name="ln2255">    int64_t bytes = 0;</a>
<a name="ln2256">    int64_t produced = 0;</a>
<a name="ln2257">    bool ok = true;</a>
<a name="ln2258">    std::string compressed;</a>
<a name="ln2259"> </a>
<a name="ln2260">    // Compress 1G</a>
<a name="ln2261">    while (ok &amp;&amp; bytes &lt; int64_t(1) &lt;&lt; 30) {</a>
<a name="ln2262">      compressed.clear();</a>
<a name="ln2263">      ok = CompressSlice(input, &amp;compressed);</a>
<a name="ln2264">      produced += compressed.size();</a>
<a name="ln2265">      bytes += input.size();</a>
<a name="ln2266">      thread-&gt;stats.FinishedOps(nullptr, nullptr, 1, kCompress);</a>
<a name="ln2267">    }</a>
<a name="ln2268"> </a>
<a name="ln2269">    if (!ok) {</a>
<a name="ln2270">      thread-&gt;stats.AddMessage(&quot;(compression failure)&quot;);</a>
<a name="ln2271">    } else {</a>
<a name="ln2272">      char buf[100];</a>
<a name="ln2273">      snprintf(buf, sizeof(buf), &quot;(output: %.1f%%)&quot;,</a>
<a name="ln2274">               (produced * 100.0) / bytes);</a>
<a name="ln2275">      thread-&gt;stats.AddMessage(buf);</a>
<a name="ln2276">      thread-&gt;stats.AddBytes(bytes);</a>
<a name="ln2277">    }</a>
<a name="ln2278">  }</a>
<a name="ln2279"> </a>
<a name="ln2280">  void Uncompress(ThreadState *thread) {</a>
<a name="ln2281">    RandomGenerator gen;</a>
<a name="ln2282">    Slice input = gen.Generate(FLAGS_block_size);</a>
<a name="ln2283">    std::string compressed;</a>
<a name="ln2284"> </a>
<a name="ln2285">    bool ok = CompressSlice(input, &amp;compressed);</a>
<a name="ln2286">    int64_t bytes = 0;</a>
<a name="ln2287">    int decompress_size;</a>
<a name="ln2288">    while (ok &amp;&amp; bytes &lt; 1024 * 1048576) {</a>
<a name="ln2289">      char *uncompressed = nullptr;</a>
<a name="ln2290">      switch (FLAGS_compression_type_e) {</a>
<a name="ln2291">        case rocksdb::kSnappyCompression: {</a>
<a name="ln2292">          // get size and allocate here to make comparison fair</a>
<a name="ln2293">          size_t ulength = 0;</a>
<a name="ln2294">          if (!Snappy_GetUncompressedLength(compressed.data(),</a>
<a name="ln2295">                                            compressed.size(), &amp;ulength)) {</a>
<a name="ln2296">            ok = false;</a>
<a name="ln2297">            break;</a>
<a name="ln2298">          }</a>
<a name="ln2299">          uncompressed = new char[ulength];</a>
<a name="ln2300">          ok = Snappy_Uncompress(compressed.data(), compressed.size(),</a>
<a name="ln2301">                                 uncompressed);</a>
<a name="ln2302">          break;</a>
<a name="ln2303">        }</a>
<a name="ln2304">      case rocksdb::kZlibCompression:</a>
<a name="ln2305">        uncompressed = Zlib_Uncompress(compressed.data(), compressed.size(),</a>
<a name="ln2306">                                       &amp;decompress_size, 2);</a>
<a name="ln2307">        ok = uncompressed != nullptr;</a>
<a name="ln2308">        break;</a>
<a name="ln2309">      case rocksdb::kBZip2Compression:</a>
<a name="ln2310">        uncompressed = BZip2_Uncompress(compressed.data(), compressed.size(),</a>
<a name="ln2311">                                        &amp;decompress_size, 2);</a>
<a name="ln2312">        ok = uncompressed != nullptr;</a>
<a name="ln2313">        break;</a>
<a name="ln2314">      case rocksdb::kLZ4Compression:</a>
<a name="ln2315">        uncompressed = LZ4_Uncompress(compressed.data(), compressed.size(),</a>
<a name="ln2316">                                      &amp;decompress_size, 2);</a>
<a name="ln2317">        ok = uncompressed != nullptr;</a>
<a name="ln2318">        break;</a>
<a name="ln2319">      case rocksdb::kLZ4HCCompression:</a>
<a name="ln2320">        uncompressed = LZ4_Uncompress(compressed.data(), compressed.size(),</a>
<a name="ln2321">                                      &amp;decompress_size, 2);</a>
<a name="ln2322">        ok = uncompressed != nullptr;</a>
<a name="ln2323">        break;</a>
<a name="ln2324">      case rocksdb::kZSTDNotFinalCompression:</a>
<a name="ln2325">        uncompressed = ZSTD_Uncompress(compressed.data(), compressed.size(),</a>
<a name="ln2326">                                       &amp;decompress_size);</a>
<a name="ln2327">        ok = uncompressed != nullptr;</a>
<a name="ln2328">        break;</a>
<a name="ln2329">      default:</a>
<a name="ln2330">        ok = false;</a>
<a name="ln2331">      }</a>
<a name="ln2332">      delete[] uncompressed;</a>
<a name="ln2333">      bytes += input.size();</a>
<a name="ln2334">      thread-&gt;stats.FinishedOps(nullptr, nullptr, 1, kUncompress);</a>
<a name="ln2335">    }</a>
<a name="ln2336"> </a>
<a name="ln2337">    if (!ok) {</a>
<a name="ln2338">      thread-&gt;stats.AddMessage(&quot;(compression failure)&quot;);</a>
<a name="ln2339">    } else {</a>
<a name="ln2340">      thread-&gt;stats.AddBytes(bytes);</a>
<a name="ln2341">    }</a>
<a name="ln2342">  }</a>
<a name="ln2343"> </a>
<a name="ln2344">  void Open(Options* opts) {</a>
<a name="ln2345">    Options&amp; options = *opts;</a>
<a name="ln2346"> </a>
<a name="ln2347">    assert(db_.db == nullptr);</a>
<a name="ln2348"> </a>
<a name="ln2349">    options.create_if_missing = !FLAGS_use_existing_db;</a>
<a name="ln2350">    options.create_missing_column_families = FLAGS_num_column_families &gt; 1;</a>
<a name="ln2351">    options.db_write_buffer_size = FLAGS_db_write_buffer_size;</a>
<a name="ln2352">    options.write_buffer_size = FLAGS_write_buffer_size;</a>
<a name="ln2353">    options.max_write_buffer_number = FLAGS_max_write_buffer_number;</a>
<a name="ln2354">    options.min_write_buffer_number_to_merge =</a>
<a name="ln2355">      FLAGS_min_write_buffer_number_to_merge;</a>
<a name="ln2356">    options.max_write_buffer_number_to_maintain =</a>
<a name="ln2357">        FLAGS_max_write_buffer_number_to_maintain;</a>
<a name="ln2358">    options.max_background_compactions = FLAGS_max_background_compactions;</a>
<a name="ln2359">    options.max_subcompactions = static_cast&lt;uint32_t&gt;(FLAGS_subcompactions);</a>
<a name="ln2360">    options.max_background_flushes = FLAGS_max_background_flushes;</a>
<a name="ln2361">    options.compaction_style = FLAGS_compaction_style_e;</a>
<a name="ln2362">    options.compaction_pri = FLAGS_compaction_pri_e;</a>
<a name="ln2363">    if (FLAGS_prefix_size != 0) {</a>
<a name="ln2364">      options.prefix_extractor.reset(</a>
<a name="ln2365">          NewFixedPrefixTransform(FLAGS_prefix_size));</a>
<a name="ln2366">    }</a>
<a name="ln2367">    if (FLAGS_use_uint64_comparator) {</a>
<a name="ln2368">      options.comparator = Uint64Comparator();</a>
<a name="ln2369">      if (FLAGS_key_size != 8) {</a>
<a name="ln2370">        fprintf(stderr, &quot;Using Uint64 comparator but key size is not 8.\n&quot;);</a>
<a name="ln2371">        exit(1);</a>
<a name="ln2372">      }</a>
<a name="ln2373">    }</a>
<a name="ln2374">    options.memtable_prefix_bloom_bits = FLAGS_memtable_bloom_bits;</a>
<a name="ln2375">    options.bloom_locality = FLAGS_bloom_locality;</a>
<a name="ln2376">    options.max_open_files = FLAGS_open_files;</a>
<a name="ln2377">    options.max_file_opening_threads = FLAGS_file_opening_threads;</a>
<a name="ln2378">    options.new_table_reader_for_compaction_inputs =</a>
<a name="ln2379">        FLAGS_new_table_reader_for_compaction_inputs;</a>
<a name="ln2380">    options.compaction_readahead_size = FLAGS_compaction_readahead_size;</a>
<a name="ln2381">    options.random_access_max_buffer_size = FLAGS_random_access_max_buffer_size;</a>
<a name="ln2382">    options.writable_file_max_buffer_size = FLAGS_writable_file_max_buffer_size;</a>
<a name="ln2383">    options.statistics = dbstats;</a>
<a name="ln2384">    if (FLAGS_enable_io_prio) {</a>
<a name="ln2385">      FLAGS_env-&gt;LowerThreadPoolIOPriority(Env::LOW);</a>
<a name="ln2386">      FLAGS_env-&gt;LowerThreadPoolIOPriority(Env::HIGH);</a>
<a name="ln2387">    }</a>
<a name="ln2388">    if (FLAGS_disable_flashcache_for_background_threads &amp;&amp;</a>
<a name="ln2389">        cachedev_fd_ == -1) {</a>
<a name="ln2390">      // Avoid creating the env twice when an use_existing_db is true</a>
<a name="ln2391">      cachedev_fd_ = open(FLAGS_flashcache_dev.c_str(), O_RDONLY);</a>
<a name="ln2392">      if (cachedev_fd_ &lt; 0) {</a>
<a name="ln2393">        fprintf(stderr, &quot;Open flash device failed\n&quot;);</a>
<a name="ln2394">        exit(1);</a>
<a name="ln2395">      }</a>
<a name="ln2396">      flashcache_aware_env_ = NewFlashcacheAwareEnv(FLAGS_env, cachedev_fd_);</a>
<a name="ln2397">      if (flashcache_aware_env_.get() == nullptr) {</a>
<a name="ln2398">        fprintf(stderr, &quot;Failed to open flashcache device at %s\n&quot;,</a>
<a name="ln2399">                FLAGS_flashcache_dev.c_str());</a>
<a name="ln2400">        std::abort();</a>
<a name="ln2401">      }</a>
<a name="ln2402">      options.env = flashcache_aware_env_.get();</a>
<a name="ln2403">    } else {</a>
<a name="ln2404">      options.env = FLAGS_env;</a>
<a name="ln2405">    }</a>
<a name="ln2406">    options.disableDataSync = FLAGS_disable_data_sync;</a>
<a name="ln2407">    options.use_fsync = FLAGS_use_fsync;</a>
<a name="ln2408">    options.wal_dir = FLAGS_wal_dir;</a>
<a name="ln2409">    options.num_levels = FLAGS_num_levels;</a>
<a name="ln2410">    options.target_file_size_base = FLAGS_target_file_size_base;</a>
<a name="ln2411">    options.target_file_size_multiplier = FLAGS_target_file_size_multiplier;</a>
<a name="ln2412">    options.max_bytes_for_level_base = FLAGS_max_bytes_for_level_base;</a>
<a name="ln2413">    options.level_compaction_dynamic_level_bytes =</a>
<a name="ln2414">        FLAGS_level_compaction_dynamic_level_bytes;</a>
<a name="ln2415">    options.max_bytes_for_level_multiplier =</a>
<a name="ln2416">        FLAGS_max_bytes_for_level_multiplier;</a>
<a name="ln2417">    options.filter_deletes = FLAGS_filter_deletes;</a>
<a name="ln2418">    if (FLAGS_row_cache_size) {</a>
<a name="ln2419">      if (FLAGS_cache_numshardbits &gt;= 1) {</a>
<a name="ln2420">        options.row_cache =</a>
<a name="ln2421">            NewLRUCache(FLAGS_row_cache_size, FLAGS_cache_numshardbits);</a>
<a name="ln2422">      } else {</a>
<a name="ln2423">        options.row_cache = NewLRUCache(FLAGS_row_cache_size);</a>
<a name="ln2424">      }</a>
<a name="ln2425">    }</a>
<a name="ln2426">    if ((FLAGS_prefix_size == 0) &amp;&amp; (FLAGS_rep_factory == kPrefixHash ||</a>
<a name="ln2427">                                     FLAGS_rep_factory == kHashLinkedList)) {</a>
<a name="ln2428">      fprintf(stderr, &quot;prefix_size should be non-zero if PrefixHash or &quot;</a>
<a name="ln2429">                      &quot;HashLinkedList memtablerep is used\n&quot;);</a>
<a name="ln2430">      exit(1);</a>
<a name="ln2431">    }</a>
<a name="ln2432">    switch (FLAGS_rep_factory) {</a>
<a name="ln2433">      case kSkipList:</a>
<a name="ln2434">        options.memtable_factory.reset(new SkipListFactory(</a>
<a name="ln2435">            FLAGS_skip_list_lookahead));</a>
<a name="ln2436">        break;</a>
<a name="ln2437">#ifndef ROCKSDB_LITE</a>
<a name="ln2438">      case kPrefixHash:</a>
<a name="ln2439">        options.memtable_factory.reset(</a>
<a name="ln2440">            NewHashSkipListRepFactory(FLAGS_hash_bucket_count));</a>
<a name="ln2441">        break;</a>
<a name="ln2442">      case kHashLinkedList:</a>
<a name="ln2443">        options.memtable_factory.reset(NewHashLinkListRepFactory(</a>
<a name="ln2444">            FLAGS_hash_bucket_count));</a>
<a name="ln2445">        break;</a>
<a name="ln2446">      case kVectorRep:</a>
<a name="ln2447">        options.memtable_factory.reset(</a>
<a name="ln2448">          new VectorRepFactory</a>
<a name="ln2449">        );</a>
<a name="ln2450">        break;</a>
<a name="ln2451">#else</a>
<a name="ln2452">      default:</a>
<a name="ln2453">        fprintf(stderr, &quot;Only skip list is supported in lite mode\n&quot;);</a>
<a name="ln2454">        exit(1);</a>
<a name="ln2455">#endif  // ROCKSDB_LITE</a>
<a name="ln2456">    }</a>
<a name="ln2457">    if (FLAGS_use_plain_table) {</a>
<a name="ln2458">#ifndef ROCKSDB_LITE</a>
<a name="ln2459">      if (FLAGS_rep_factory != kPrefixHash &amp;&amp;</a>
<a name="ln2460">          FLAGS_rep_factory != kHashLinkedList) {</a>
<a name="ln2461">        fprintf(stderr, &quot;Waring: plain table is used with skipList\n&quot;);</a>
<a name="ln2462">      }</a>
<a name="ln2463">      if (!FLAGS_mmap_read &amp;&amp; !FLAGS_mmap_write) {</a>
<a name="ln2464">        fprintf(stderr, &quot;plain table format requires mmap to operate\n&quot;);</a>
<a name="ln2465">        exit(1);</a>
<a name="ln2466">      }</a>
<a name="ln2467"> </a>
<a name="ln2468">      int bloom_bits_per_key = FLAGS_bloom_bits;</a>
<a name="ln2469">      if (bloom_bits_per_key &lt; 0) {</a>
<a name="ln2470">        bloom_bits_per_key = 0;</a>
<a name="ln2471">      }</a>
<a name="ln2472"> </a>
<a name="ln2473">      PlainTableOptions plain_table_options;</a>
<a name="ln2474">      plain_table_options.user_key_len = FLAGS_key_size;</a>
<a name="ln2475">      plain_table_options.bloom_bits_per_key = bloom_bits_per_key;</a>
<a name="ln2476">      plain_table_options.hash_table_ratio = 0.75;</a>
<a name="ln2477">      options.table_factory = std::shared_ptr&lt;TableFactory&gt;(</a>
<a name="ln2478">          NewPlainTableFactory(plain_table_options));</a>
<a name="ln2479">#else</a>
<a name="ln2480">      fprintf(stderr, &quot;Plain table is not supported in lite mode\n&quot;);</a>
<a name="ln2481">      exit(1);</a>
<a name="ln2482">#endif  // ROCKSDB_LITE</a>
<a name="ln2483">    } else {</a>
<a name="ln2484">      BlockBasedTableOptions block_based_options;</a>
<a name="ln2485">      if (FLAGS_use_hash_search) {</a>
<a name="ln2486">        if (FLAGS_prefix_size == 0) {</a>
<a name="ln2487">          fprintf(stderr,</a>
<a name="ln2488">              &quot;prefix_size not assigned when enable use_hash_search \n&quot;);</a>
<a name="ln2489">          exit(1);</a>
<a name="ln2490">        }</a>
<a name="ln2491">        block_based_options.index_type = IndexType::kHashSearch;</a>
<a name="ln2492">      } else if (FLAGS_use_binary_search) {</a>
<a name="ln2493">        block_based_options.index_type = IndexType::kBinarySearch;</a>
<a name="ln2494">      } else {</a>
<a name="ln2495">        block_based_options.index_type = IndexType::kMultiLevelBinarySearch;</a>
<a name="ln2496">      }</a>
<a name="ln2497">      if (cache_ == nullptr) {</a>
<a name="ln2498">        block_based_options.no_block_cache = true;</a>
<a name="ln2499">      }</a>
<a name="ln2500">      block_based_options.cache_index_and_filter_blocks =</a>
<a name="ln2501">          FLAGS_cache_index_and_filter_blocks;</a>
<a name="ln2502">      block_based_options.block_cache = cache_;</a>
<a name="ln2503">      block_based_options.block_cache_compressed = compressed_cache_;</a>
<a name="ln2504">      block_based_options.block_size = FLAGS_block_size;</a>
<a name="ln2505">      block_based_options.block_restart_interval = FLAGS_block_restart_interval;</a>
<a name="ln2506">      block_based_options.filter_policy = filter_policy_;</a>
<a name="ln2507">      block_based_options.skip_table_builder_flush =</a>
<a name="ln2508">          FLAGS_skip_table_builder_flush;</a>
<a name="ln2509">      block_based_options.format_version = 2;</a>
<a name="ln2510">      options.table_factory.reset(</a>
<a name="ln2511">          NewBlockBasedTableFactory(block_based_options));</a>
<a name="ln2512">    }</a>
<a name="ln2513">    if (FLAGS_max_bytes_for_level_multiplier_additional_v.size() &gt; 0) {</a>
<a name="ln2514">      if (FLAGS_max_bytes_for_level_multiplier_additional_v.size() !=</a>
<a name="ln2515">          (unsigned int)FLAGS_num_levels) {</a>
<a name="ln2516">        fprintf(stderr, &quot;Insufficient number of fanouts specified %zu\n&quot;,</a>
<a name="ln2517">                FLAGS_max_bytes_for_level_multiplier_additional_v.size());</a>
<a name="ln2518">        exit(1);</a>
<a name="ln2519">      }</a>
<a name="ln2520">      options.max_bytes_for_level_multiplier_additional =</a>
<a name="ln2521">        FLAGS_max_bytes_for_level_multiplier_additional_v;</a>
<a name="ln2522">    }</a>
<a name="ln2523">    options.level0_stop_writes_trigger = FLAGS_level0_stop_writes_trigger;</a>
<a name="ln2524">    options.level0_file_num_compaction_trigger =</a>
<a name="ln2525">        FLAGS_level0_file_num_compaction_trigger;</a>
<a name="ln2526">    options.level0_slowdown_writes_trigger =</a>
<a name="ln2527">      FLAGS_level0_slowdown_writes_trigger;</a>
<a name="ln2528">    options.compression = FLAGS_compression_type_e;</a>
<a name="ln2529">    options.compression_opts.level = FLAGS_compression_level;</a>
<a name="ln2530">    options.WAL_ttl_seconds = FLAGS_wal_ttl_seconds;</a>
<a name="ln2531">    options.WAL_size_limit_MB = FLAGS_wal_size_limit_MB;</a>
<a name="ln2532">    options.max_total_wal_size = FLAGS_max_total_wal_size;</a>
<a name="ln2533"> </a>
<a name="ln2534">    if (FLAGS_min_level_to_compress &gt;= 0) {</a>
<a name="ln2535">      assert(FLAGS_min_level_to_compress &lt;= FLAGS_num_levels);</a>
<a name="ln2536">      options.compression_per_level.resize(FLAGS_num_levels);</a>
<a name="ln2537">      for (int i = 0; i &lt; FLAGS_min_level_to_compress; i++) {</a>
<a name="ln2538">        options.compression_per_level[i] = kNoCompression;</a>
<a name="ln2539">      }</a>
<a name="ln2540">      for (int i = FLAGS_min_level_to_compress;</a>
<a name="ln2541">           i &lt; FLAGS_num_levels; i++) {</a>
<a name="ln2542">        options.compression_per_level[i] = FLAGS_compression_type_e;</a>
<a name="ln2543">      }</a>
<a name="ln2544">    }</a>
<a name="ln2545">    options.soft_rate_limit = FLAGS_soft_rate_limit;</a>
<a name="ln2546">    options.hard_rate_limit = FLAGS_hard_rate_limit;</a>
<a name="ln2547">    options.soft_pending_compaction_bytes_limit =</a>
<a name="ln2548">        FLAGS_soft_pending_compaction_bytes_limit;</a>
<a name="ln2549">    options.hard_pending_compaction_bytes_limit =</a>
<a name="ln2550">        FLAGS_hard_pending_compaction_bytes_limit;</a>
<a name="ln2551">    options.delayed_write_rate = FLAGS_delayed_write_rate;</a>
<a name="ln2552">    options.allow_concurrent_memtable_write =</a>
<a name="ln2553">        FLAGS_allow_concurrent_memtable_write;</a>
<a name="ln2554">    options.enable_write_thread_adaptive_yield =</a>
<a name="ln2555">        FLAGS_enable_write_thread_adaptive_yield;</a>
<a name="ln2556">    options.write_thread_max_yield_usec = FLAGS_write_thread_max_yield_usec;</a>
<a name="ln2557">    options.write_thread_slow_yield_usec = FLAGS_write_thread_slow_yield_usec;</a>
<a name="ln2558">    options.rate_limit_delay_max_milliseconds =</a>
<a name="ln2559">      FLAGS_rate_limit_delay_max_milliseconds;</a>
<a name="ln2560">    options.table_cache_numshardbits = FLAGS_table_cache_numshardbits;</a>
<a name="ln2561">    options.max_grandparent_overlap_factor =</a>
<a name="ln2562">      FLAGS_max_grandparent_overlap_factor;</a>
<a name="ln2563">    options.disable_auto_compactions = FLAGS_disable_auto_compactions;</a>
<a name="ln2564">    options.source_compaction_factor = FLAGS_source_compaction_factor;</a>
<a name="ln2565"> </a>
<a name="ln2566">    // fill storage options</a>
<a name="ln2567">    options.allow_os_buffer = FLAGS_bufferedio;</a>
<a name="ln2568">    options.allow_mmap_reads = FLAGS_mmap_read;</a>
<a name="ln2569">    options.allow_mmap_writes = FLAGS_mmap_write;</a>
<a name="ln2570">    options.advise_random_on_open = FLAGS_advise_random_on_open;</a>
<a name="ln2571">    options.access_hint_on_compaction_start = FLAGS_compaction_fadvice_e;</a>
<a name="ln2572">    options.use_adaptive_mutex = FLAGS_use_adaptive_mutex;</a>
<a name="ln2573">    options.bytes_per_sync = FLAGS_bytes_per_sync;</a>
<a name="ln2574">    options.wal_bytes_per_sync = FLAGS_wal_bytes_per_sync;</a>
<a name="ln2575"> </a>
<a name="ln2576">    // merge operator options</a>
<a name="ln2577">    options.merge_operator = MergeOperators::CreateFromStringId(</a>
<a name="ln2578">        FLAGS_merge_operator);</a>
<a name="ln2579">    if (options.merge_operator == nullptr &amp;&amp; !FLAGS_merge_operator.empty()) {</a>
<a name="ln2580">      fprintf(stderr, &quot;invalid merge operator: %s\n&quot;,</a>
<a name="ln2581">              FLAGS_merge_operator.c_str());</a>
<a name="ln2582">      exit(1);</a>
<a name="ln2583">    }</a>
<a name="ln2584">    options.max_successive_merges = FLAGS_max_successive_merges;</a>
<a name="ln2585">    options.compaction_measure_io_stats = FLAGS_compaction_measure_io_stats;</a>
<a name="ln2586"> </a>
<a name="ln2587">    // set universal style compaction configurations, if applicable</a>
<a name="ln2588">    if (FLAGS_universal_size_ratio != 0) {</a>
<a name="ln2589">      options.compaction_options_universal.size_ratio =</a>
<a name="ln2590">        FLAGS_universal_size_ratio;</a>
<a name="ln2591">    }</a>
<a name="ln2592">    if (FLAGS_universal_min_merge_width != 0) {</a>
<a name="ln2593">      options.compaction_options_universal.min_merge_width =</a>
<a name="ln2594">        FLAGS_universal_min_merge_width;</a>
<a name="ln2595">    }</a>
<a name="ln2596">    if (FLAGS_universal_max_merge_width != 0) {</a>
<a name="ln2597">      options.compaction_options_universal.max_merge_width =</a>
<a name="ln2598">        FLAGS_universal_max_merge_width;</a>
<a name="ln2599">    }</a>
<a name="ln2600">    if (FLAGS_universal_max_size_amplification_percent != 0) {</a>
<a name="ln2601">      options.compaction_options_universal.max_size_amplification_percent =</a>
<a name="ln2602">        FLAGS_universal_max_size_amplification_percent;</a>
<a name="ln2603">    }</a>
<a name="ln2604">    if (FLAGS_universal_compression_size_percent != -1) {</a>
<a name="ln2605">      options.compaction_options_universal.compression_size_percent =</a>
<a name="ln2606">        FLAGS_universal_compression_size_percent;</a>
<a name="ln2607">    }</a>
<a name="ln2608">    options.compaction_options_universal.allow_trivial_move =</a>
<a name="ln2609">        FLAGS_universal_allow_trivial_move;</a>
<a name="ln2610">    if (FLAGS_thread_status_per_interval &gt; 0) {</a>
<a name="ln2611">      options.enable_thread_tracking = true;</a>
<a name="ln2612">    }</a>
<a name="ln2613">    if (FLAGS_rate_limiter_bytes_per_sec &gt; 0) {</a>
<a name="ln2614">      options.rate_limiter.reset(</a>
<a name="ln2615">          NewGenericRateLimiter(FLAGS_rate_limiter_bytes_per_sec));</a>
<a name="ln2616">    }</a>
<a name="ln2617"> </a>
<a name="ln2618">#ifndef ROCKSDB_LITE</a>
<a name="ln2619">    if (FLAGS_readonly &amp;&amp; FLAGS_transaction_db) {</a>
<a name="ln2620">      fprintf(stderr, &quot;Cannot use readonly flag with transaction_db\n&quot;);</a>
<a name="ln2621">      exit(1);</a>
<a name="ln2622">    }</a>
<a name="ln2623">#endif  // ROCKSDB_LITE</a>
<a name="ln2624"> </a>
<a name="ln2625">    if (FLAGS_num_multi_db &lt;= 1) {</a>
<a name="ln2626">      OpenDb(options, FLAGS_db, &amp;db_);</a>
<a name="ln2627">    } else {</a>
<a name="ln2628">      multi_dbs_.clear();</a>
<a name="ln2629">      multi_dbs_.resize(FLAGS_num_multi_db);</a>
<a name="ln2630">      for (int i = 0; i &lt; FLAGS_num_multi_db; i++) {</a>
<a name="ln2631">        OpenDb(options, GetDbNameForMultiple(FLAGS_db, i), &amp;multi_dbs_[i]);</a>
<a name="ln2632">      }</a>
<a name="ln2633">    }</a>
<a name="ln2634">    if (FLAGS_min_level_to_compress &gt;= 0) {</a>
<a name="ln2635">      options.compression_per_level.clear();</a>
<a name="ln2636">    }</a>
<a name="ln2637">  }</a>
<a name="ln2638"> </a>
<a name="ln2639">  void OpenDb(const Options&amp; options, const std::string&amp; db_name,</a>
<a name="ln2640">      DBWithColumnFamilies* db) {</a>
<a name="ln2641">    Status s;</a>
<a name="ln2642">    // Open with column families if necessary.</a>
<a name="ln2643">    if (FLAGS_num_column_families &gt; 1) {</a>
<a name="ln2644">      size_t num_hot = FLAGS_num_column_families;</a>
<a name="ln2645">      if (FLAGS_num_hot_column_families &gt; 0 &amp;&amp;</a>
<a name="ln2646">          FLAGS_num_hot_column_families &lt; FLAGS_num_column_families) {</a>
<a name="ln2647">        num_hot = FLAGS_num_hot_column_families;</a>
<a name="ln2648">      } else {</a>
<a name="ln2649">        FLAGS_num_hot_column_families = FLAGS_num_column_families;</a>
<a name="ln2650">      }</a>
<a name="ln2651">      std::vector&lt;ColumnFamilyDescriptor&gt; column_families;</a>
<a name="ln2652">      for (size_t i = 0; i &lt; num_hot; i++) {</a>
<a name="ln2653">        column_families.push_back(ColumnFamilyDescriptor(</a>
<a name="ln2654">              ColumnFamilyName(i), ColumnFamilyOptions(options)));</a>
<a name="ln2655">      }</a>
<a name="ln2656">#ifndef ROCKSDB_LITE</a>
<a name="ln2657">      if (FLAGS_readonly) {</a>
<a name="ln2658">        s = DB::OpenForReadOnly(options, db_name, column_families,</a>
<a name="ln2659">            &amp;db-&gt;cfh, &amp;db-&gt;db);</a>
<a name="ln2660">      } else if (FLAGS_optimistic_transaction_db) {</a>
<a name="ln2661">        s = OptimisticTransactionDB::Open(options, db_name, column_families,</a>
<a name="ln2662">                                          &amp;db-&gt;cfh, &amp;db-&gt;opt_txn_db);</a>
<a name="ln2663">        if (s.ok()) {</a>
<a name="ln2664">          db-&gt;db = db-&gt;opt_txn_db-&gt;GetBaseDB();</a>
<a name="ln2665">        }</a>
<a name="ln2666">      } else if (FLAGS_transaction_db) {</a>
<a name="ln2667">        TransactionDB* ptr;</a>
<a name="ln2668">        TransactionDBOptions txn_db_options;</a>
<a name="ln2669">        s = TransactionDB::Open(options, txn_db_options, db_name,</a>
<a name="ln2670">                                column_families, &amp;db-&gt;cfh, &amp;ptr);</a>
<a name="ln2671">        if (s.ok()) {</a>
<a name="ln2672">          db-&gt;db = ptr;</a>
<a name="ln2673">        }</a>
<a name="ln2674">      } else {</a>
<a name="ln2675">        s = DB::Open(options, db_name, column_families, &amp;db-&gt;cfh, &amp;db-&gt;db);</a>
<a name="ln2676">      }</a>
<a name="ln2677">#else</a>
<a name="ln2678">      s = DB::Open(options, db_name, column_families, &amp;db-&gt;cfh, &amp;db-&gt;db);</a>
<a name="ln2679">#endif  // ROCKSDB_LITE</a>
<a name="ln2680">      db-&gt;cfh.resize(FLAGS_num_column_families);</a>
<a name="ln2681">      db-&gt;num_created = num_hot;</a>
<a name="ln2682">      db-&gt;num_hot = num_hot;</a>
<a name="ln2683">#ifndef ROCKSDB_LITE</a>
<a name="ln2684">    } else if (FLAGS_readonly) {</a>
<a name="ln2685">      s = DB::OpenForReadOnly(options, db_name, &amp;db-&gt;db);</a>
<a name="ln2686">    } else if (FLAGS_optimistic_transaction_db) {</a>
<a name="ln2687">      s = OptimisticTransactionDB::Open(options, db_name, &amp;db-&gt;opt_txn_db);</a>
<a name="ln2688">      if (s.ok()) {</a>
<a name="ln2689">        db-&gt;db = db-&gt;opt_txn_db-&gt;GetBaseDB();</a>
<a name="ln2690">      }</a>
<a name="ln2691">    } else if (FLAGS_transaction_db) {</a>
<a name="ln2692">      TransactionDB* ptr;</a>
<a name="ln2693">      TransactionDBOptions txn_db_options;</a>
<a name="ln2694">      s = TransactionDB::Open(options, txn_db_options, db_name, &amp;ptr);</a>
<a name="ln2695">      if (s.ok()) {</a>
<a name="ln2696">        db-&gt;db = ptr;</a>
<a name="ln2697">      }</a>
<a name="ln2698">#endif  // ROCKSDB_LITE</a>
<a name="ln2699">    } else {</a>
<a name="ln2700">      s = DB::Open(options, db_name, &amp;db-&gt;db);</a>
<a name="ln2701">    }</a>
<a name="ln2702">    if (!s.ok()) {</a>
<a name="ln2703">      fprintf(stderr, &quot;open error: %s\n&quot;, s.ToString().c_str());</a>
<a name="ln2704">      exit(1);</a>
<a name="ln2705">    }</a>
<a name="ln2706">  }</a>
<a name="ln2707"> </a>
<a name="ln2708">  enum WriteMode {</a>
<a name="ln2709">    RANDOM, SEQUENTIAL, UNIQUE_RANDOM</a>
<a name="ln2710">  };</a>
<a name="ln2711"> </a>
<a name="ln2712">  void WriteSeq(ThreadState* thread) {</a>
<a name="ln2713">    DoWrite(thread, SEQUENTIAL);</a>
<a name="ln2714">  }</a>
<a name="ln2715"> </a>
<a name="ln2716">  void WriteRandom(ThreadState* thread) {</a>
<a name="ln2717">    DoWrite(thread, RANDOM);</a>
<a name="ln2718">  }</a>
<a name="ln2719"> </a>
<a name="ln2720">  void WriteUniqueRandom(ThreadState* thread) {</a>
<a name="ln2721">    DoWrite(thread, UNIQUE_RANDOM);</a>
<a name="ln2722">  }</a>
<a name="ln2723"> </a>
<a name="ln2724">  class KeyGenerator {</a>
<a name="ln2725">   public:</a>
<a name="ln2726">    KeyGenerator(Random64* rand, WriteMode mode,</a>
<a name="ln2727">        uint64_t num, uint64_t num_per_set = 64 * 1024)</a>
<a name="ln2728">      : rand_(rand),</a>
<a name="ln2729">        mode_(mode),</a>
<a name="ln2730">        num_(num),</a>
<a name="ln2731">        next_(0) {</a>
<a name="ln2732">      if (mode_ == UNIQUE_RANDOM) {</a>
<a name="ln2733">        // NOTE: if memory consumption of this approach becomes a concern,</a>
<a name="ln2734">        // we can either break it into pieces and only random shuffle a section</a>
<a name="ln2735">        // each time. Alternatively, use a bit map implementation</a>
<a name="ln2736">        // (https://reviews.facebook.net/differential/diff/54627/)</a>
<a name="ln2737">        values_.resize(num_);</a>
<a name="ln2738">        for (uint64_t i = 0; i &lt; num_; ++i) {</a>
<a name="ln2739">          values_[i] = i;</a>
<a name="ln2740">        }</a>
<a name="ln2741">        std::shuffle(</a>
<a name="ln2742">            values_.begin(), values_.end(),</a>
<a name="ln2743">            std::default_random_engine(static_cast&lt;unsigned int&gt;(FLAGS_seed)));</a>
<a name="ln2744">      }</a>
<a name="ln2745">    }</a>
<a name="ln2746"> </a>
<a name="ln2747">    uint64_t Next() {</a>
<a name="ln2748">      switch (mode_) {</a>
<a name="ln2749">        case SEQUENTIAL:</a>
<a name="ln2750">          return next_++;</a>
<a name="ln2751">        case RANDOM:</a>
<a name="ln2752">          return rand_-&gt;Next() % num_;</a>
<a name="ln2753">        case UNIQUE_RANDOM:</a>
<a name="ln2754">          return values_[next_++];</a>
<a name="ln2755">      }</a>
<a name="ln2756">      assert(false);</a>
<a name="ln2757">      return std::numeric_limits&lt;uint64_t&gt;::max();</a>
<a name="ln2758">    }</a>
<a name="ln2759"> </a>
<a name="ln2760">   private:</a>
<a name="ln2761">    Random64* rand_;</a>
<a name="ln2762">    WriteMode mode_;</a>
<a name="ln2763">    const uint64_t num_;</a>
<a name="ln2764">    uint64_t next_;</a>
<a name="ln2765">    std::vector&lt;uint64_t&gt; values_;</a>
<a name="ln2766">  };</a>
<a name="ln2767"> </a>
<a name="ln2768">  DB* SelectDB(ThreadState* thread) {</a>
<a name="ln2769">    return SelectDBWithCfh(thread)-&gt;db;</a>
<a name="ln2770">  }</a>
<a name="ln2771"> </a>
<a name="ln2772">  DBWithColumnFamilies* SelectDBWithCfh(ThreadState* thread) {</a>
<a name="ln2773">    return SelectDBWithCfh(thread-&gt;rand.Next());</a>
<a name="ln2774">  }</a>
<a name="ln2775"> </a>
<a name="ln2776">  DBWithColumnFamilies* SelectDBWithCfh(uint64_t rand_int) {</a>
<a name="ln2777">    if (db_.db != nullptr) {</a>
<a name="ln2778">      return &amp;db_;</a>
<a name="ln2779">    } else  {</a>
<a name="ln2780">      return &amp;multi_dbs_[rand_int % multi_dbs_.size()];</a>
<a name="ln2781">    }</a>
<a name="ln2782">  }</a>
<a name="ln2783"> </a>
<a name="ln2784">  void DoWrite(ThreadState* thread, WriteMode write_mode) {</a>
<a name="ln2785">    const int test_duration = write_mode == RANDOM ? FLAGS_duration : 0;</a>
<a name="ln2786">    const int64_t num_ops = writes_ == 0 ? num_ : writes_;</a>
<a name="ln2787"> </a>
<a name="ln2788">    size_t num_key_gens = 1;</a>
<a name="ln2789">    if (db_.db == nullptr) {</a>
<a name="ln2790">      num_key_gens = multi_dbs_.size();</a>
<a name="ln2791">    }</a>
<a name="ln2792">    std::vector&lt;std::unique_ptr&lt;KeyGenerator&gt;&gt; key_gens(num_key_gens);</a>
<a name="ln2793">    int64_t max_ops = num_ops * num_key_gens;</a>
<a name="ln2794">    int64_t ops_per_stage = max_ops;</a>
<a name="ln2795">    if (FLAGS_num_column_families &gt; 1 &amp;&amp; FLAGS_num_hot_column_families &gt; 0) {</a>
<a name="ln2796">      ops_per_stage = (max_ops - 1) / (FLAGS_num_column_families /</a>
<a name="ln2797">                                       FLAGS_num_hot_column_families) +</a>
<a name="ln2798">                      1;</a>
<a name="ln2799">    }</a>
<a name="ln2800"> </a>
<a name="ln2801">    Duration duration(test_duration, max_ops, ops_per_stage);</a>
<a name="ln2802">    for (size_t i = 0; i &lt; num_key_gens; i++) {</a>
<a name="ln2803">      key_gens[i].reset(new KeyGenerator(&amp;(thread-&gt;rand), write_mode, num_,</a>
<a name="ln2804">                                         ops_per_stage));</a>
<a name="ln2805">    }</a>
<a name="ln2806"> </a>
<a name="ln2807">    if (num_ != FLAGS_num) {</a>
<a name="ln2808">      char msg[100];</a>
<a name="ln2809">      snprintf(msg, sizeof(msg), &quot;(%&quot; PRIu64 &quot; ops)&quot;, num_);</a>
<a name="ln2810">      thread-&gt;stats.AddMessage(msg);</a>
<a name="ln2811">    }</a>
<a name="ln2812"> </a>
<a name="ln2813">    RandomGenerator gen;</a>
<a name="ln2814">    WriteBatch batch;</a>
<a name="ln2815">    Status s;</a>
<a name="ln2816">    int64_t bytes = 0;</a>
<a name="ln2817"> </a>
<a name="ln2818">    std::unique_ptr&lt;const char[]&gt; key_guard;</a>
<a name="ln2819">    Slice key = AllocateKey(&amp;key_guard);</a>
<a name="ln2820">    int64_t stage = 0;</a>
<a name="ln2821">    while (!duration.Done(entries_per_batch_)) {</a>
<a name="ln2822">      if (duration.GetStage() != stage) {</a>
<a name="ln2823">        stage = duration.GetStage();</a>
<a name="ln2824">        if (db_.db != nullptr) {</a>
<a name="ln2825">          db_.CreateNewCf(open_options_, stage);</a>
<a name="ln2826">        } else {</a>
<a name="ln2827">          for (auto&amp; db : multi_dbs_) {</a>
<a name="ln2828">            db.CreateNewCf(open_options_, stage);</a>
<a name="ln2829">          }</a>
<a name="ln2830">        }</a>
<a name="ln2831">      }</a>
<a name="ln2832"> </a>
<a name="ln2833">      size_t id = thread-&gt;rand.Next() % num_key_gens;</a>
<a name="ln2834">      DBWithColumnFamilies* db_with_cfh = SelectDBWithCfh(id);</a>
<a name="ln2835">      batch.Clear();</a>
<a name="ln2836"> </a>
<a name="ln2837">      if (thread-&gt;shared-&gt;write_rate_limiter.get() != nullptr) {</a>
<a name="ln2838">        thread-&gt;shared-&gt;write_rate_limiter-&gt;Request(</a>
<a name="ln2839">            entries_per_batch_ * (value_size_ + key_size_),</a>
<a name="ln2840">            Env::IO_HIGH);</a>
<a name="ln2841">        // Set time at which last op finished to Now() to hide latency and</a>
<a name="ln2842">        // sleep from rate limiter. Also, do the check once per batch, not</a>
<a name="ln2843">        // once per write.</a>
<a name="ln2844">        thread-&gt;stats.ResetLastOpTime();</a>
<a name="ln2845">      }</a>
<a name="ln2846"> </a>
<a name="ln2847">      for (int64_t j = 0; j &lt; entries_per_batch_; j++) {</a>
<a name="ln2848">        int64_t rand_num = key_gens[id]-&gt;Next();</a>
<a name="ln2849">        GenerateKeyFromInt(rand_num, FLAGS_num, &amp;key);</a>
<a name="ln2850">        if (FLAGS_num_column_families &lt;= 1) {</a>
<a name="ln2851">          batch.Put(key, gen.Generate(value_size_));</a>
<a name="ln2852">        } else {</a>
<a name="ln2853">          // We use same rand_num as seed for key and column family so that we</a>
<a name="ln2854">          // can deterministically find the cfh corresponding to a particular</a>
<a name="ln2855">          // key while reading the key.</a>
<a name="ln2856">          batch.Put(db_with_cfh-&gt;GetCfh(rand_num), key,</a>
<a name="ln2857">                    gen.Generate(value_size_));</a>
<a name="ln2858">        }</a>
<a name="ln2859">        bytes += value_size_ + key_size_;</a>
<a name="ln2860">      }</a>
<a name="ln2861">      s = db_with_cfh-&gt;db-&gt;Write(write_options_, &amp;batch);</a>
<a name="ln2862">      thread-&gt;stats.FinishedOps(db_with_cfh, db_with_cfh-&gt;db,</a>
<a name="ln2863">                                entries_per_batch_, kWrite);</a>
<a name="ln2864">      if (!s.ok()) {</a>
<a name="ln2865">        fprintf(stderr, &quot;put error: %s\n&quot;, s.ToString().c_str());</a>
<a name="ln2866">        exit(1);</a>
<a name="ln2867">      }</a>
<a name="ln2868">    }</a>
<a name="ln2869">    thread-&gt;stats.AddBytes(bytes);</a>
<a name="ln2870">  }</a>
<a name="ln2871"> </a>
<a name="ln2872">  void ReadSequential(ThreadState* thread) {</a>
<a name="ln2873">    if (db_.db != nullptr) {</a>
<a name="ln2874">      ReadSequential(thread, db_.db);</a>
<a name="ln2875">    } else {</a>
<a name="ln2876">      for (const auto&amp; db_with_cfh : multi_dbs_) {</a>
<a name="ln2877">        ReadSequential(thread, db_with_cfh.db);</a>
<a name="ln2878">      }</a>
<a name="ln2879">    }</a>
<a name="ln2880">  }</a>
<a name="ln2881"> </a>
<a name="ln2882">  void ReadSequential(ThreadState* thread, DB* db) {</a>
<a name="ln2883">    ReadOptions options(FLAGS_verify_checksum, true);</a>
<a name="ln2884">    options.tailing = FLAGS_use_tailing_iterator;</a>
<a name="ln2885"> </a>
<a name="ln2886">    Iterator* iter = db-&gt;NewIterator(options);</a>
<a name="ln2887">    int64_t i = 0;</a>
<a name="ln2888">    int64_t bytes = 0;</a>
<a name="ln2889">    for (iter-&gt;SeekToFirst(); i &lt; reads_ &amp;&amp; iter-&gt;Valid(); iter-&gt;Next()) {</a>
<a name="ln2890">      bytes += iter-&gt;key().size() + iter-&gt;value().size();</a>
<a name="ln2891">      thread-&gt;stats.FinishedOps(nullptr, db, 1, kRead);</a>
<a name="ln2892">      ++i;</a>
<a name="ln2893">    }</a>
<a name="ln2894">    delete iter;</a>
<a name="ln2895">    thread-&gt;stats.AddBytes(bytes);</a>
<a name="ln2896">  }</a>
<a name="ln2897"> </a>
<a name="ln2898">  void ReadReverse(ThreadState* thread) {</a>
<a name="ln2899">    if (db_.db != nullptr) {</a>
<a name="ln2900">      ReadReverse(thread, db_.db);</a>
<a name="ln2901">    } else {</a>
<a name="ln2902">      for (const auto&amp; db_with_cfh : multi_dbs_) {</a>
<a name="ln2903">        ReadReverse(thread, db_with_cfh.db);</a>
<a name="ln2904">      }</a>
<a name="ln2905">    }</a>
<a name="ln2906">  }</a>
<a name="ln2907"> </a>
<a name="ln2908">  void ReadReverse(ThreadState* thread, DB* db) {</a>
<a name="ln2909">    Iterator* iter = db-&gt;NewIterator(ReadOptions(FLAGS_verify_checksum, true));</a>
<a name="ln2910">    int64_t i = 0;</a>
<a name="ln2911">    int64_t bytes = 0;</a>
<a name="ln2912">    for (iter-&gt;SeekToLast(); i &lt; reads_ &amp;&amp; iter-&gt;Valid(); iter-&gt;Prev()) {</a>
<a name="ln2913">      bytes += iter-&gt;key().size() + iter-&gt;value().size();</a>
<a name="ln2914">      thread-&gt;stats.FinishedOps(nullptr, db, 1, kRead);</a>
<a name="ln2915">      ++i;</a>
<a name="ln2916">    }</a>
<a name="ln2917">    delete iter;</a>
<a name="ln2918">    thread-&gt;stats.AddBytes(bytes);</a>
<a name="ln2919">  }</a>
<a name="ln2920"> </a>
<a name="ln2921">  void ReadRandomFast(ThreadState* thread) {</a>
<a name="ln2922">    int64_t read = 0;</a>
<a name="ln2923">    int64_t found = 0;</a>
<a name="ln2924">    int64_t nonexist = 0;</a>
<a name="ln2925">    ReadOptions options(FLAGS_verify_checksum, true);</a>
<a name="ln2926">    std::unique_ptr&lt;const char[]&gt; key_guard;</a>
<a name="ln2927">    Slice key = AllocateKey(&amp;key_guard);</a>
<a name="ln2928">    std::string value;</a>
<a name="ln2929">    DB* db = SelectDBWithCfh(thread)-&gt;db;</a>
<a name="ln2930"> </a>
<a name="ln2931">    int64_t pot = 1;</a>
<a name="ln2932">    while (pot &lt; FLAGS_num) {</a>
<a name="ln2933">      pot &lt;&lt;= 1;</a>
<a name="ln2934">    }</a>
<a name="ln2935"> </a>
<a name="ln2936">    Duration duration(FLAGS_duration, reads_);</a>
<a name="ln2937">    do {</a>
<a name="ln2938">      for (int i = 0; i &lt; 100; ++i) {</a>
<a name="ln2939">        int64_t key_rand = thread-&gt;rand.Next() &amp; (pot - 1);</a>
<a name="ln2940">        GenerateKeyFromInt(key_rand, FLAGS_num, &amp;key);</a>
<a name="ln2941">        ++read;</a>
<a name="ln2942">        auto status = db-&gt;Get(options, key, &amp;value);</a>
<a name="ln2943">        if (status.ok()) {</a>
<a name="ln2944">          ++found;</a>
<a name="ln2945">        } else if (!status.IsNotFound()) {</a>
<a name="ln2946">          fprintf(stderr, &quot;Get returned an error: %s\n&quot;,</a>
<a name="ln2947">                  status.ToString().c_str());</a>
<a name="ln2948">          abort();</a>
<a name="ln2949">        }</a>
<a name="ln2950">        if (key_rand &gt;= FLAGS_num) {</a>
<a name="ln2951">          ++nonexist;</a>
<a name="ln2952">        }</a>
<a name="ln2953">      }</a>
<a name="ln2954">      thread-&gt;stats.FinishedOps(nullptr, db, 100, kRead);</a>
<a name="ln2955">    } while (!duration.Done(100));</a>
<a name="ln2956"> </a>
<a name="ln2957">    char msg[100];</a>
<a name="ln2958">    snprintf(msg, sizeof(msg), &quot;(%&quot; PRIu64 &quot; of %&quot; PRIu64 &quot; found, &quot;</a>
<a name="ln2959">             &quot;issued %&quot; PRIu64 &quot; non-exist keys)\n&quot;,</a>
<a name="ln2960">             found, read, nonexist);</a>
<a name="ln2961"> </a>
<a name="ln2962">    thread-&gt;stats.AddMessage(msg);</a>
<a name="ln2963"> </a>
<a name="ln2964">    if (FLAGS_perf_level &gt; 0) {</a>
<a name="ln2965">      thread-&gt;stats.AddMessage(perf_context.ToString());</a>
<a name="ln2966">    }</a>
<a name="ln2967">  }</a>
<a name="ln2968"> </a>
<a name="ln2969">  int64_t GetRandomKey(Random64* rand) {</a>
<a name="ln2970">    uint64_t rand_int = rand-&gt;Next();</a>
<a name="ln2971">    int64_t key_rand;</a>
<a name="ln2972">    if (read_random_exp_range_ == 0) {</a>
<a name="ln2973">      key_rand = rand_int % FLAGS_num;</a>
<a name="ln2974">    } else {</a>
<a name="ln2975">      const uint64_t kBigInt = static_cast&lt;uint64_t&gt;(1U) &lt;&lt; 62;</a>
<a name="ln2976">      long double order = -static_cast&lt;long double&gt;(rand_int % kBigInt) /</a>
<a name="ln2977">                          static_cast&lt;long double&gt;(kBigInt) *</a>
<a name="ln2978">                          read_random_exp_range_;</a>
<a name="ln2979">      long double exp_ran = std::exp(order);</a>
<a name="ln2980">      uint64_t rand_num =</a>
<a name="ln2981">          static_cast&lt;int64_t&gt;(exp_ran * static_cast&lt;long double&gt;(FLAGS_num));</a>
<a name="ln2982">      // Map to a different number to avoid locality.</a>
<a name="ln2983">      const uint64_t kBigPrime = 0x5bd1e995;</a>
<a name="ln2984">      // Overflow is like %(2^64). Will have little impact of results.</a>
<a name="ln2985">      key_rand = static_cast&lt;int64_t&gt;((rand_num * kBigPrime) % FLAGS_num);</a>
<a name="ln2986">    }</a>
<a name="ln2987">    return key_rand;</a>
<a name="ln2988">  }</a>
<a name="ln2989"> </a>
<a name="ln2990">  void ReadRandom(ThreadState* thread) {</a>
<a name="ln2991">    int64_t read = 0;</a>
<a name="ln2992">    int64_t found = 0;</a>
<a name="ln2993">    int64_t bytes = 0;</a>
<a name="ln2994">    ReadOptions options(FLAGS_verify_checksum, true);</a>
<a name="ln2995">    std::unique_ptr&lt;const char[]&gt; key_guard;</a>
<a name="ln2996">    Slice key = AllocateKey(&amp;key_guard);</a>
<a name="ln2997">    std::string value;</a>
<a name="ln2998"> </a>
<a name="ln2999">    Duration duration(FLAGS_duration, reads_);</a>
<a name="ln3000">    while (!duration.Done(1)) {</a>
<a name="ln3001">      DBWithColumnFamilies* db_with_cfh = SelectDBWithCfh(thread);</a>
<a name="ln3002">      // We use same key_rand as seed for key and column family so that we can</a>
<a name="ln3003">      // deterministically find the cfh corresponding to a particular key, as it</a>
<a name="ln3004">      // is done in DoWrite method.</a>
<a name="ln3005">      int64_t key_rand = GetRandomKey(&amp;thread-&gt;rand);</a>
<a name="ln3006">      GenerateKeyFromInt(key_rand, FLAGS_num, &amp;key);</a>
<a name="ln3007">      read++;</a>
<a name="ln3008">      Status s;</a>
<a name="ln3009">      if (FLAGS_num_column_families &gt; 1) {</a>
<a name="ln3010">        s = db_with_cfh-&gt;db-&gt;Get(options, db_with_cfh-&gt;GetCfh(key_rand), key,</a>
<a name="ln3011">                                 &amp;value);</a>
<a name="ln3012">      } else {</a>
<a name="ln3013">        s = db_with_cfh-&gt;db-&gt;Get(options, key, &amp;value);</a>
<a name="ln3014">      }</a>
<a name="ln3015">      if (s.ok()) {</a>
<a name="ln3016">        found++;</a>
<a name="ln3017">        bytes += key.size() + value.size();</a>
<a name="ln3018">      } else if (!s.IsNotFound()) {</a>
<a name="ln3019">        fprintf(stderr, &quot;Get returned an error: %s\n&quot;, s.ToString().c_str());</a>
<a name="ln3020">        abort();</a>
<a name="ln3021">      }</a>
<a name="ln3022">      thread-&gt;stats.FinishedOps(db_with_cfh, db_with_cfh-&gt;db, 1, kRead);</a>
<a name="ln3023">    }</a>
<a name="ln3024"> </a>
<a name="ln3025">    char msg[100];</a>
<a name="ln3026">    snprintf(msg, sizeof(msg), &quot;(%&quot; PRIu64 &quot; of %&quot; PRIu64 &quot; found)\n&quot;,</a>
<a name="ln3027">             found, read);</a>
<a name="ln3028"> </a>
<a name="ln3029">    thread-&gt;stats.AddBytes(bytes);</a>
<a name="ln3030">    thread-&gt;stats.AddMessage(msg);</a>
<a name="ln3031"> </a>
<a name="ln3032">    if (FLAGS_perf_level &gt; 0) {</a>
<a name="ln3033">      thread-&gt;stats.AddMessage(perf_context.ToString());</a>
<a name="ln3034">    }</a>
<a name="ln3035">  }</a>
<a name="ln3036"> </a>
<a name="ln3037">  // Calls MultiGet over a list of keys from a random distribution.</a>
<a name="ln3038">  // Returns the total number of keys found.</a>
<a name="ln3039">  void MultiReadRandom(ThreadState* thread) {</a>
<a name="ln3040">    int64_t read = 0;</a>
<a name="ln3041">    int64_t found = 0;</a>
<a name="ln3042">    ReadOptions options(FLAGS_verify_checksum, true);</a>
<a name="ln3043">    std::vector&lt;Slice&gt; keys;</a>
<a name="ln3044">    std::vector&lt;std::unique_ptr&lt;const char[]&gt; &gt; key_guards;</a>
<a name="ln3045">    std::vector&lt;std::string&gt; values(entries_per_batch_);</a>
<a name="ln3046">    while (static_cast&lt;int64_t&gt;(keys.size()) &lt; entries_per_batch_) {</a>
<a name="ln3047">      key_guards.push_back(std::unique_ptr&lt;const char[]&gt;());</a>
<a name="ln3048">      keys.push_back(AllocateKey(&amp;key_guards.back()));</a>
<a name="ln3049">    }</a>
<a name="ln3050"> </a>
<a name="ln3051">    Duration duration(FLAGS_duration, reads_);</a>
<a name="ln3052">    while (!duration.Done(1)) {</a>
<a name="ln3053">      DB* db = SelectDB(thread);</a>
<a name="ln3054">      for (int64_t i = 0; i &lt; entries_per_batch_; ++i) {</a>
<a name="ln3055">        GenerateKeyFromInt(GetRandomKey(&amp;thread-&gt;rand), FLAGS_num, &amp;keys[i]);</a>
<a name="ln3056">      }</a>
<a name="ln3057">      std::vector&lt;Status&gt; statuses = db-&gt;MultiGet(options, keys, &amp;values);</a>
<a name="ln3058">      assert(static_cast&lt;int64_t&gt;(statuses.size()) == entries_per_batch_);</a>
<a name="ln3059"> </a>
<a name="ln3060">      read += entries_per_batch_;</a>
<a name="ln3061">      for (int64_t i = 0; i &lt; entries_per_batch_; ++i) {</a>
<a name="ln3062">        if (statuses[i].ok()) {</a>
<a name="ln3063">          ++found;</a>
<a name="ln3064">        } else if (!statuses[i].IsNotFound()) {</a>
<a name="ln3065">          fprintf(stderr, &quot;MultiGet returned an error: %s\n&quot;,</a>
<a name="ln3066">                  statuses[i].ToString().c_str());</a>
<a name="ln3067">          abort();</a>
<a name="ln3068">        }</a>
<a name="ln3069">      }</a>
<a name="ln3070">      thread-&gt;stats.FinishedOps(nullptr, db, entries_per_batch_, kRead);</a>
<a name="ln3071">    }</a>
<a name="ln3072"> </a>
<a name="ln3073">    char msg[100];</a>
<a name="ln3074">    snprintf(msg, sizeof(msg), &quot;(%&quot; PRIu64 &quot; of %&quot; PRIu64 &quot; found)&quot;,</a>
<a name="ln3075">             found, read);</a>
<a name="ln3076">    thread-&gt;stats.AddMessage(msg);</a>
<a name="ln3077">  }</a>
<a name="ln3078"> </a>
<a name="ln3079">  void IteratorCreation(ThreadState* thread) {</a>
<a name="ln3080">    Duration duration(FLAGS_duration, reads_);</a>
<a name="ln3081">    ReadOptions options(FLAGS_verify_checksum, true);</a>
<a name="ln3082">    while (!duration.Done(1)) {</a>
<a name="ln3083">      DB* db = SelectDB(thread);</a>
<a name="ln3084">      Iterator* iter = db-&gt;NewIterator(options);</a>
<a name="ln3085">      delete iter;</a>
<a name="ln3086">      thread-&gt;stats.FinishedOps(nullptr, db, 1, kOthers);</a>
<a name="ln3087">    }</a>
<a name="ln3088">  }</a>
<a name="ln3089"> </a>
<a name="ln3090">  void IteratorCreationWhileWriting(ThreadState* thread) {</a>
<a name="ln3091">    if (thread-&gt;tid &gt; 0) {</a>
<a name="ln3092">      IteratorCreation(thread);</a>
<a name="ln3093">    } else {</a>
<a name="ln3094">      BGWriter(thread, kWrite);</a>
<a name="ln3095">    }</a>
<a name="ln3096">  }</a>
<a name="ln3097"> </a>
<a name="ln3098">  void SeekRandom(ThreadState* thread) {</a>
<a name="ln3099">    int64_t read = 0;</a>
<a name="ln3100">    int64_t found = 0;</a>
<a name="ln3101">    int64_t bytes = 0;</a>
<a name="ln3102">    ReadOptions options(FLAGS_verify_checksum, true);</a>
<a name="ln3103">    options.tailing = FLAGS_use_tailing_iterator;</a>
<a name="ln3104"> </a>
<a name="ln3105">    Iterator* single_iter = nullptr;</a>
<a name="ln3106">    std::vector&lt;Iterator*&gt; multi_iters;</a>
<a name="ln3107">    if (db_.db != nullptr) {</a>
<a name="ln3108">      single_iter = db_.db-&gt;NewIterator(options);</a>
<a name="ln3109">    } else {</a>
<a name="ln3110">      for (const auto&amp; db_with_cfh : multi_dbs_) {</a>
<a name="ln3111">        multi_iters.push_back(db_with_cfh.db-&gt;NewIterator(options));</a>
<a name="ln3112">      }</a>
<a name="ln3113">    }</a>
<a name="ln3114"> </a>
<a name="ln3115">    std::unique_ptr&lt;const char[]&gt; key_guard;</a>
<a name="ln3116">    Slice key = AllocateKey(&amp;key_guard);</a>
<a name="ln3117"> </a>
<a name="ln3118">    Duration duration(FLAGS_duration, reads_);</a>
<a name="ln3119">    char value_buffer[256];</a>
<a name="ln3120">    while (!duration.Done(1)) {</a>
<a name="ln3121">      if (!FLAGS_use_tailing_iterator) {</a>
<a name="ln3122">        if (db_.db != nullptr) {</a>
<a name="ln3123">          delete single_iter;</a>
<a name="ln3124">          single_iter = db_.db-&gt;NewIterator(options);</a>
<a name="ln3125">        } else {</a>
<a name="ln3126">          for (auto iter : multi_iters) {</a>
<a name="ln3127">            delete iter;</a>
<a name="ln3128">          }</a>
<a name="ln3129">          multi_iters.clear();</a>
<a name="ln3130">          for (const auto&amp; db_with_cfh : multi_dbs_) {</a>
<a name="ln3131">            multi_iters.push_back(db_with_cfh.db-&gt;NewIterator(options));</a>
<a name="ln3132">          }</a>
<a name="ln3133">        }</a>
<a name="ln3134">      }</a>
<a name="ln3135">      // Pick a Iterator to use</a>
<a name="ln3136">      Iterator* iter_to_use = single_iter;</a>
<a name="ln3137">      if (single_iter == nullptr) {</a>
<a name="ln3138">        iter_to_use = multi_iters[thread-&gt;rand.Next() % multi_iters.size()];</a>
<a name="ln3139">      }</a>
<a name="ln3140"> </a>
<a name="ln3141">      GenerateKeyFromInt(thread-&gt;rand.Next() % FLAGS_num, FLAGS_num, &amp;key);</a>
<a name="ln3142">      iter_to_use-&gt;Seek(key);</a>
<a name="ln3143">      read++;</a>
<a name="ln3144">      if (iter_to_use-&gt;Valid() &amp;&amp; iter_to_use-&gt;key().compare(key) == 0) {</a>
<a name="ln3145">        found++;</a>
<a name="ln3146">      }</a>
<a name="ln3147"> </a>
<a name="ln3148">      for (int j = 0; j &lt; FLAGS_seek_nexts &amp;&amp; iter_to_use-&gt;Valid(); ++j) {</a>
<a name="ln3149">        // Copy out iterator's value to make sure we read them.</a>
<a name="ln3150">        Slice value = iter_to_use-&gt;value();</a>
<a name="ln3151">        memcpy(value_buffer, value.data(),</a>
<a name="ln3152">               std::min(value.size(), sizeof(value_buffer)));</a>
<a name="ln3153">        bytes += iter_to_use-&gt;key().size() + iter_to_use-&gt;value().size();</a>
<a name="ln3154"> </a>
<a name="ln3155">        if (!FLAGS_reverse_iterator) {</a>
<a name="ln3156">          iter_to_use-&gt;Next();</a>
<a name="ln3157">        } else {</a>
<a name="ln3158">          iter_to_use-&gt;Prev();</a>
<a name="ln3159">        }</a>
<a name="ln3160">        assert(iter_to_use-&gt;status().ok());</a>
<a name="ln3161">      }</a>
<a name="ln3162"> </a>
<a name="ln3163">      thread-&gt;stats.FinishedOps(&amp;db_, db_.db, 1, kSeek);</a>
<a name="ln3164">    }</a>
<a name="ln3165">    delete single_iter;</a>
<a name="ln3166">    for (auto iter : multi_iters) {</a>
<a name="ln3167">      delete iter;</a>
<a name="ln3168">    }</a>
<a name="ln3169"> </a>
<a name="ln3170">    char msg[100];</a>
<a name="ln3171">    snprintf(msg, sizeof(msg), &quot;(%&quot; PRIu64 &quot; of %&quot; PRIu64 &quot; found)\n&quot;,</a>
<a name="ln3172">             found, read);</a>
<a name="ln3173">    thread-&gt;stats.AddBytes(bytes);</a>
<a name="ln3174">    thread-&gt;stats.AddMessage(msg);</a>
<a name="ln3175">    if (FLAGS_perf_level &gt; 0) {</a>
<a name="ln3176">      thread-&gt;stats.AddMessage(perf_context.ToString());</a>
<a name="ln3177">    }</a>
<a name="ln3178">  }</a>
<a name="ln3179"> </a>
<a name="ln3180">  void SeekRandomWhileWriting(ThreadState* thread) {</a>
<a name="ln3181">    if (thread-&gt;tid &gt; 0) {</a>
<a name="ln3182">      SeekRandom(thread);</a>
<a name="ln3183">    } else {</a>
<a name="ln3184">      BGWriter(thread, kWrite);</a>
<a name="ln3185">    }</a>
<a name="ln3186">  }</a>
<a name="ln3187"> </a>
<a name="ln3188">  void SeekRandomWhileMerging(ThreadState* thread) {</a>
<a name="ln3189">    if (thread-&gt;tid &gt; 0) {</a>
<a name="ln3190">      SeekRandom(thread);</a>
<a name="ln3191">    } else {</a>
<a name="ln3192">      BGWriter(thread, kMerge);</a>
<a name="ln3193">    }</a>
<a name="ln3194">  }</a>
<a name="ln3195"> </a>
<a name="ln3196">  void DoDelete(ThreadState* thread, bool seq) {</a>
<a name="ln3197">    WriteBatch batch;</a>
<a name="ln3198">    Duration duration(seq ? 0 : FLAGS_duration, num_);</a>
<a name="ln3199">    int64_t i = 0;</a>
<a name="ln3200">    std::unique_ptr&lt;const char[]&gt; key_guard;</a>
<a name="ln3201">    Slice key = AllocateKey(&amp;key_guard);</a>
<a name="ln3202"> </a>
<a name="ln3203">    while (!duration.Done(entries_per_batch_)) {</a>
<a name="ln3204">      DB* db = SelectDB(thread);</a>
<a name="ln3205">      batch.Clear();</a>
<a name="ln3206">      for (int64_t j = 0; j &lt; entries_per_batch_; ++j) {</a>
<a name="ln3207">        const int64_t k = seq ? i + j : (thread-&gt;rand.Next() % FLAGS_num);</a>
<a name="ln3208">        GenerateKeyFromInt(k, FLAGS_num, &amp;key);</a>
<a name="ln3209">        batch.Delete(key);</a>
<a name="ln3210">      }</a>
<a name="ln3211">      auto s = db-&gt;Write(write_options_, &amp;batch);</a>
<a name="ln3212">      thread-&gt;stats.FinishedOps(nullptr, db, entries_per_batch_, kDelete);</a>
<a name="ln3213">      if (!s.ok()) {</a>
<a name="ln3214">        fprintf(stderr, &quot;del error: %s\n&quot;, s.ToString().c_str());</a>
<a name="ln3215">        exit(1);</a>
<a name="ln3216">      }</a>
<a name="ln3217">      i += entries_per_batch_;</a>
<a name="ln3218">    }</a>
<a name="ln3219">  }</a>
<a name="ln3220"> </a>
<a name="ln3221">  void DeleteSeq(ThreadState* thread) {</a>
<a name="ln3222">    DoDelete(thread, true);</a>
<a name="ln3223">  }</a>
<a name="ln3224"> </a>
<a name="ln3225">  void DeleteRandom(ThreadState* thread) {</a>
<a name="ln3226">    DoDelete(thread, false);</a>
<a name="ln3227">  }</a>
<a name="ln3228"> </a>
<a name="ln3229">  void ReadWhileWriting(ThreadState* thread) {</a>
<a name="ln3230">    if (thread-&gt;tid &gt; 0) {</a>
<a name="ln3231">      ReadRandom(thread);</a>
<a name="ln3232">    } else {</a>
<a name="ln3233">      BGWriter(thread, kWrite);</a>
<a name="ln3234">    }</a>
<a name="ln3235">  }</a>
<a name="ln3236"> </a>
<a name="ln3237">  void ReadWhileMerging(ThreadState* thread) {</a>
<a name="ln3238">    if (thread-&gt;tid &gt; 0) {</a>
<a name="ln3239">      ReadRandom(thread);</a>
<a name="ln3240">    } else {</a>
<a name="ln3241">      BGWriter(thread, kMerge);</a>
<a name="ln3242">    }</a>
<a name="ln3243">  }</a>
<a name="ln3244"> </a>
<a name="ln3245">  void BGWriter(ThreadState* thread, enum OperationType write_merge) {</a>
<a name="ln3246">    // Special thread that keeps writing until other threads are done.</a>
<a name="ln3247">    RandomGenerator gen;</a>
<a name="ln3248">    int64_t bytes = 0;</a>
<a name="ln3249"> </a>
<a name="ln3250">    std::unique_ptr&lt;RateLimiter&gt; write_rate_limiter;</a>
<a name="ln3251">    if (FLAGS_benchmark_write_rate_limit &gt; 0) {</a>
<a name="ln3252">      write_rate_limiter.reset(</a>
<a name="ln3253">          NewGenericRateLimiter(FLAGS_benchmark_write_rate_limit));</a>
<a name="ln3254">    }</a>
<a name="ln3255"> </a>
<a name="ln3256">    // Don't merge stats from this thread with the readers.</a>
<a name="ln3257">    thread-&gt;stats.SetExcludeFromMerge();</a>
<a name="ln3258"> </a>
<a name="ln3259">    std::unique_ptr&lt;const char[]&gt; key_guard;</a>
<a name="ln3260">    Slice key = AllocateKey(&amp;key_guard);</a>
<a name="ln3261"> </a>
<a name="ln3262">    while (true) {</a>
<a name="ln3263">      DB* db = SelectDB(thread);</a>
<a name="ln3264">      {</a>
<a name="ln3265">        MutexLock l(&amp;thread-&gt;shared-&gt;mu);</a>
<a name="ln3266">        if (thread-&gt;shared-&gt;num_done + 1 &gt;= thread-&gt;shared-&gt;num_initialized) {</a>
<a name="ln3267">          // Other threads have finished</a>
<a name="ln3268">          break;</a>
<a name="ln3269">        }</a>
<a name="ln3270">      }</a>
<a name="ln3271"> </a>
<a name="ln3272">      GenerateKeyFromInt(thread-&gt;rand.Next() % FLAGS_num, FLAGS_num, &amp;key);</a>
<a name="ln3273">      Status s;</a>
<a name="ln3274"> </a>
<a name="ln3275">      if (write_merge == kWrite) {</a>
<a name="ln3276">          s = db-&gt;Put(write_options_, key, gen.Generate(value_size_));</a>
<a name="ln3277">      } else {</a>
<a name="ln3278">          s = db-&gt;Merge(write_options_, key, gen.Generate(value_size_));</a>
<a name="ln3279">      }</a>
<a name="ln3280"> </a>
<a name="ln3281">      if (!s.ok()) {</a>
<a name="ln3282">        fprintf(stderr, &quot;put or merge error: %s\n&quot;, s.ToString().c_str());</a>
<a name="ln3283">        exit(1);</a>
<a name="ln3284">      }</a>
<a name="ln3285">      bytes += key.size() + value_size_;</a>
<a name="ln3286">      thread-&gt;stats.FinishedOps(&amp;db_, db_.db, 1, kWrite);</a>
<a name="ln3287"> </a>
<a name="ln3288">      if (FLAGS_benchmark_write_rate_limit &gt; 0) {</a>
<a name="ln3289">        write_rate_limiter-&gt;Request(</a>
<a name="ln3290">            entries_per_batch_ * (value_size_ + key_size_),</a>
<a name="ln3291">            Env::IO_HIGH);</a>
<a name="ln3292">      }</a>
<a name="ln3293">    }</a>
<a name="ln3294">    thread-&gt;stats.AddBytes(bytes);</a>
<a name="ln3295">  }</a>
<a name="ln3296"> </a>
<a name="ln3297">  // Given a key K and value V, this puts (K+&quot;0&quot;, V), (K+&quot;1&quot;, V), (K+&quot;2&quot;, V)</a>
<a name="ln3298">  // in DB atomically i.e in a single batch. Also refer GetMany.</a>
<a name="ln3299">  Status PutMany(DB* db, const WriteOptions&amp; writeoptions, const Slice&amp; key,</a>
<a name="ln3300">                 const Slice&amp; value) {</a>
<a name="ln3301">    std::string suffixes[3] = {&quot;2&quot;, &quot;1&quot;, &quot;0&quot;};</a>
<a name="ln3302">    std::string keys[3];</a>
<a name="ln3303"> </a>
<a name="ln3304">    WriteBatch batch;</a>
<a name="ln3305">    Status s;</a>
<a name="ln3306">    for (int i = 0; i &lt; 3; i++) {</a>
<a name="ln3307">      keys[i] = key.ToString() + suffixes[i];</a>
<a name="ln3308">      batch.Put(keys[i], value);</a>
<a name="ln3309">    }</a>
<a name="ln3310"> </a>
<a name="ln3311">    s = db-&gt;Write(writeoptions, &amp;batch);</a>
<a name="ln3312">    return s;</a>
<a name="ln3313">  }</a>
<a name="ln3314"> </a>
<a name="ln3315"> </a>
<a name="ln3316">  // Given a key K, this deletes (K+&quot;0&quot;, V), (K+&quot;1&quot;, V), (K+&quot;2&quot;, V)</a>
<a name="ln3317">  // in DB atomically i.e in a single batch. Also refer GetMany.</a>
<a name="ln3318">  Status DeleteMany(DB* db, const WriteOptions&amp; writeoptions,</a>
<a name="ln3319">                    const Slice&amp; key) {</a>
<a name="ln3320">    std::string suffixes[3] = {&quot;1&quot;, &quot;2&quot;, &quot;0&quot;};</a>
<a name="ln3321">    std::string keys[3];</a>
<a name="ln3322"> </a>
<a name="ln3323">    WriteBatch batch;</a>
<a name="ln3324">    Status s;</a>
<a name="ln3325">    for (int i = 0; i &lt; 3; i++) {</a>
<a name="ln3326">      keys[i] = key.ToString() + suffixes[i];</a>
<a name="ln3327">      batch.Delete(keys[i]);</a>
<a name="ln3328">    }</a>
<a name="ln3329"> </a>
<a name="ln3330">    s = db-&gt;Write(writeoptions, &amp;batch);</a>
<a name="ln3331">    return s;</a>
<a name="ln3332">  }</a>
<a name="ln3333"> </a>
<a name="ln3334">  // Given a key K and value V, this gets values for K+&quot;0&quot;, K+&quot;1&quot; and K+&quot;2&quot;</a>
<a name="ln3335">  // in the same snapshot, and verifies that all the values are identical.</a>
<a name="ln3336">  // ASSUMES that PutMany was used to put (K, V) into the DB.</a>
<a name="ln3337">  Status GetMany(DB* db, const ReadOptions&amp; readoptions, const Slice&amp; key,</a>
<a name="ln3338">                 std::string* value) {</a>
<a name="ln3339">    std::string suffixes[3] = {&quot;0&quot;, &quot;1&quot;, &quot;2&quot;};</a>
<a name="ln3340">    std::string keys[3];</a>
<a name="ln3341">    Slice key_slices[3];</a>
<a name="ln3342">    std::string values[3];</a>
<a name="ln3343">    ReadOptions readoptionscopy = readoptions;</a>
<a name="ln3344">    readoptionscopy.snapshot = db-&gt;GetSnapshot();</a>
<a name="ln3345">    Status s;</a>
<a name="ln3346">    for (int i = 0; i &lt; 3; i++) {</a>
<a name="ln3347">      keys[i] = key.ToString() + suffixes[i];</a>
<a name="ln3348">      key_slices[i] = keys[i];</a>
<a name="ln3349">      s = db-&gt;Get(readoptionscopy, key_slices[i], value);</a>
<a name="ln3350">      if (!s.ok() &amp;&amp; !s.IsNotFound()) {</a>
<a name="ln3351">        fprintf(stderr, &quot;get error: %s\n&quot;, s.ToString().c_str());</a>
<a name="ln3352">        values[i] = &quot;&quot;;</a>
<a name="ln3353">        // we continue after error rather than exiting so that we can</a>
<a name="ln3354">        // find more errors if any</a>
<a name="ln3355">      } else if (s.IsNotFound()) {</a>
<a name="ln3356">        values[i] = &quot;&quot;;</a>
<a name="ln3357">      } else {</a>
<a name="ln3358">        values[i] = *value;</a>
<a name="ln3359">      }</a>
<a name="ln3360">    }</a>
<a name="ln3361">    db-&gt;ReleaseSnapshot(readoptionscopy.snapshot);</a>
<a name="ln3362"> </a>
<a name="ln3363">    if ((values[0] != values[1]) || (values[1] != values[2])) {</a>
<a name="ln3364">      fprintf(stderr, &quot;inconsistent values for key %s: %s, %s, %s\n&quot;,</a>
<a name="ln3365">              key.ToString().c_str(), values[0].c_str(), values[1].c_str(),</a>
<a name="ln3366">              values[2].c_str());</a>
<a name="ln3367">      // we continue after error rather than exiting so that we can</a>
<a name="ln3368">      // find more errors if any</a>
<a name="ln3369">    }</a>
<a name="ln3370"> </a>
<a name="ln3371">    return s;</a>
<a name="ln3372">  }</a>
<a name="ln3373"> </a>
<a name="ln3374">  // Differs from readrandomwriterandom in the following ways:</a>
<a name="ln3375">  // (a) Uses GetMany/PutMany to read/write key values. Refer to those funcs.</a>
<a name="ln3376">  // (b) Does deletes as well (per FLAGS_deletepercent)</a>
<a name="ln3377">  // (c) In order to achieve high % of 'found' during lookups, and to do</a>
<a name="ln3378">  //     multiple writes (including puts and deletes) it uses upto</a>
<a name="ln3379">  //     FLAGS_numdistinct distinct keys instead of FLAGS_num distinct keys.</a>
<a name="ln3380">  // (d) Does not have a MultiGet option.</a>
<a name="ln3381">  void RandomWithVerify(ThreadState* thread) {</a>
<a name="ln3382">    ReadOptions options(FLAGS_verify_checksum, true);</a>
<a name="ln3383">    RandomGenerator gen;</a>
<a name="ln3384">    std::string value;</a>
<a name="ln3385">    int64_t found = 0;</a>
<a name="ln3386">    int get_weight = 0;</a>
<a name="ln3387">    int put_weight = 0;</a>
<a name="ln3388">    int delete_weight = 0;</a>
<a name="ln3389">    int64_t gets_done = 0;</a>
<a name="ln3390">    int64_t puts_done = 0;</a>
<a name="ln3391">    int64_t deletes_done = 0;</a>
<a name="ln3392"> </a>
<a name="ln3393">    std::unique_ptr&lt;const char[]&gt; key_guard;</a>
<a name="ln3394">    Slice key = AllocateKey(&amp;key_guard);</a>
<a name="ln3395"> </a>
<a name="ln3396">    // the number of iterations is the larger of read_ or write_</a>
<a name="ln3397">    for (int64_t i = 0; i &lt; readwrites_; i++) {</a>
<a name="ln3398">      DB* db = SelectDB(thread);</a>
<a name="ln3399">      if (get_weight == 0 &amp;&amp; put_weight == 0 &amp;&amp; delete_weight == 0) {</a>
<a name="ln3400">        // one batch completed, reinitialize for next batch</a>
<a name="ln3401">        get_weight = FLAGS_readwritepercent;</a>
<a name="ln3402">        delete_weight = FLAGS_deletepercent;</a>
<a name="ln3403">        put_weight = 100 - get_weight - delete_weight;</a>
<a name="ln3404">      }</a>
<a name="ln3405">      GenerateKeyFromInt(thread-&gt;rand.Next() % FLAGS_numdistinct,</a>
<a name="ln3406">          FLAGS_numdistinct, &amp;key);</a>
<a name="ln3407">      if (get_weight &gt; 0) {</a>
<a name="ln3408">        // do all the gets first</a>
<a name="ln3409">        Status s = GetMany(db, options, key, &amp;value);</a>
<a name="ln3410">        if (!s.ok() &amp;&amp; !s.IsNotFound()) {</a>
<a name="ln3411">          fprintf(stderr, &quot;getmany error: %s\n&quot;, s.ToString().c_str());</a>
<a name="ln3412">          // we continue after error rather than exiting so that we can</a>
<a name="ln3413">          // find more errors if any</a>
<a name="ln3414">        } else if (!s.IsNotFound()) {</a>
<a name="ln3415">          found++;</a>
<a name="ln3416">        }</a>
<a name="ln3417">        get_weight--;</a>
<a name="ln3418">        gets_done++;</a>
<a name="ln3419">        thread-&gt;stats.FinishedOps(&amp;db_, db_.db, 1, kRead);</a>
<a name="ln3420">      } else if (put_weight &gt; 0) {</a>
<a name="ln3421">        // then do all the corresponding number of puts</a>
<a name="ln3422">        // for all the gets we have done earlier</a>
<a name="ln3423">        Status s = PutMany(db, write_options_, key, gen.Generate(value_size_));</a>
<a name="ln3424">        if (!s.ok()) {</a>
<a name="ln3425">          fprintf(stderr, &quot;putmany error: %s\n&quot;, s.ToString().c_str());</a>
<a name="ln3426">          exit(1);</a>
<a name="ln3427">        }</a>
<a name="ln3428">        put_weight--;</a>
<a name="ln3429">        puts_done++;</a>
<a name="ln3430">        thread-&gt;stats.FinishedOps(&amp;db_, db_.db, 1, kWrite);</a>
<a name="ln3431">      } else if (delete_weight &gt; 0) {</a>
<a name="ln3432">        Status s = DeleteMany(db, write_options_, key);</a>
<a name="ln3433">        if (!s.ok()) {</a>
<a name="ln3434">          fprintf(stderr, &quot;deletemany error: %s\n&quot;, s.ToString().c_str());</a>
<a name="ln3435">          exit(1);</a>
<a name="ln3436">        }</a>
<a name="ln3437">        delete_weight--;</a>
<a name="ln3438">        deletes_done++;</a>
<a name="ln3439">        thread-&gt;stats.FinishedOps(&amp;db_, db_.db, 1, kDelete);</a>
<a name="ln3440">      }</a>
<a name="ln3441">    }</a>
<a name="ln3442">    char msg[128];</a>
<a name="ln3443">    snprintf(msg, sizeof(msg),</a>
<a name="ln3444">             &quot;( get:%&quot; PRIu64 &quot; put:%&quot; PRIu64 &quot; del:%&quot; PRIu64 &quot; total:%&quot; \</a>
<a name="ln3445">             PRIu64 &quot; found:%&quot; PRIu64 &quot;)&quot;,</a>
<a name="ln3446">             gets_done, puts_done, deletes_done, readwrites_, found);</a>
<a name="ln3447">    thread-&gt;stats.AddMessage(msg);</a>
<a name="ln3448">  }</a>
<a name="ln3449"> </a>
<a name="ln3450">  // This is different from ReadWhileWriting because it does not use</a>
<a name="ln3451">  // an extra thread.</a>
<a name="ln3452">  void ReadRandomWriteRandom(ThreadState* thread) {</a>
<a name="ln3453">    ReadOptions options(FLAGS_verify_checksum, true);</a>
<a name="ln3454">    RandomGenerator gen;</a>
<a name="ln3455">    std::string value;</a>
<a name="ln3456">    int64_t found = 0;</a>
<a name="ln3457">    int get_weight = 0;</a>
<a name="ln3458">    int put_weight = 0;</a>
<a name="ln3459">    int64_t reads_done = 0;</a>
<a name="ln3460">    int64_t writes_done = 0;</a>
<a name="ln3461">    Duration duration(FLAGS_duration, readwrites_);</a>
<a name="ln3462"> </a>
<a name="ln3463">    std::unique_ptr&lt;const char[]&gt; key_guard;</a>
<a name="ln3464">    Slice key = AllocateKey(&amp;key_guard);</a>
<a name="ln3465"> </a>
<a name="ln3466">    // the number of iterations is the larger of read_ or write_</a>
<a name="ln3467">    while (!duration.Done(1)) {</a>
<a name="ln3468">      DB* db = SelectDB(thread);</a>
<a name="ln3469">      GenerateKeyFromInt(thread-&gt;rand.Next() % FLAGS_num, FLAGS_num, &amp;key);</a>
<a name="ln3470">      if (get_weight == 0 &amp;&amp; put_weight == 0) {</a>
<a name="ln3471">        // one batch completed, reinitialize for next batch</a>
<a name="ln3472">        get_weight = FLAGS_readwritepercent;</a>
<a name="ln3473">        put_weight = 100 - get_weight;</a>
<a name="ln3474">      }</a>
<a name="ln3475">      if (get_weight &gt; 0) {</a>
<a name="ln3476">        // do all the gets first</a>
<a name="ln3477">        Status s = db-&gt;Get(options, key, &amp;value);</a>
<a name="ln3478">        if (!s.ok() &amp;&amp; !s.IsNotFound()) {</a>
<a name="ln3479">          fprintf(stderr, &quot;get error: %s\n&quot;, s.ToString().c_str());</a>
<a name="ln3480">          // we continue after error rather than exiting so that we can</a>
<a name="ln3481">          // find more errors if any</a>
<a name="ln3482">        } else if (!s.IsNotFound()) {</a>
<a name="ln3483">          found++;</a>
<a name="ln3484">        }</a>
<a name="ln3485">        get_weight--;</a>
<a name="ln3486">        reads_done++;</a>
<a name="ln3487">        thread-&gt;stats.FinishedOps(nullptr, db, 1, kRead);</a>
<a name="ln3488">      } else  if (put_weight &gt; 0) {</a>
<a name="ln3489">        // then do all the corresponding number of puts</a>
<a name="ln3490">        // for all the gets we have done earlier</a>
<a name="ln3491">        Status s = db-&gt;Put(write_options_, key, gen.Generate(value_size_));</a>
<a name="ln3492">        if (!s.ok()) {</a>
<a name="ln3493">          fprintf(stderr, &quot;put error: %s\n&quot;, s.ToString().c_str());</a>
<a name="ln3494">          exit(1);</a>
<a name="ln3495">        }</a>
<a name="ln3496">        put_weight--;</a>
<a name="ln3497">        writes_done++;</a>
<a name="ln3498">        thread-&gt;stats.FinishedOps(nullptr, db, 1, kWrite);</a>
<a name="ln3499">      }</a>
<a name="ln3500">    }</a>
<a name="ln3501">    char msg[100];</a>
<a name="ln3502">    snprintf(msg, sizeof(msg), &quot;( reads:%&quot; PRIu64 &quot; writes:%&quot; PRIu64 \</a>
<a name="ln3503">             &quot; total:%&quot; PRIu64 &quot; found:%&quot; PRIu64 &quot;)&quot;,</a>
<a name="ln3504">             reads_done, writes_done, readwrites_, found);</a>
<a name="ln3505">    thread-&gt;stats.AddMessage(msg);</a>
<a name="ln3506">  }</a>
<a name="ln3507"> </a>
<a name="ln3508">  //</a>
<a name="ln3509">  // Read-modify-write for random keys</a>
<a name="ln3510">  void UpdateRandom(ThreadState* thread) {</a>
<a name="ln3511">    ReadOptions options(FLAGS_verify_checksum, true);</a>
<a name="ln3512">    RandomGenerator gen;</a>
<a name="ln3513">    std::string value;</a>
<a name="ln3514">    int64_t found = 0;</a>
<a name="ln3515">    int64_t bytes = 0;</a>
<a name="ln3516">    Duration duration(FLAGS_duration, readwrites_);</a>
<a name="ln3517"> </a>
<a name="ln3518">    std::unique_ptr&lt;const char[]&gt; key_guard;</a>
<a name="ln3519">    Slice key = AllocateKey(&amp;key_guard);</a>
<a name="ln3520">    // the number of iterations is the larger of read_ or write_</a>
<a name="ln3521">    while (!duration.Done(1)) {</a>
<a name="ln3522">      DB* db = SelectDB(thread);</a>
<a name="ln3523">      GenerateKeyFromInt(thread-&gt;rand.Next() % FLAGS_num, FLAGS_num, &amp;key);</a>
<a name="ln3524"> </a>
<a name="ln3525">      auto status = db-&gt;Get(options, key, &amp;value);</a>
<a name="ln3526">      if (status.ok()) {</a>
<a name="ln3527">        ++found;</a>
<a name="ln3528">        bytes += key.size() + value.size();</a>
<a name="ln3529">      } else if (!status.IsNotFound()) {</a>
<a name="ln3530">        fprintf(stderr, &quot;Get returned an error: %s\n&quot;,</a>
<a name="ln3531">                status.ToString().c_str());</a>
<a name="ln3532">        abort();</a>
<a name="ln3533">      }</a>
<a name="ln3534"> </a>
<a name="ln3535">      Status s = db-&gt;Put(write_options_, key, gen.Generate(value_size_));</a>
<a name="ln3536">      if (!s.ok()) {</a>
<a name="ln3537">        fprintf(stderr, &quot;put error: %s\n&quot;, s.ToString().c_str());</a>
<a name="ln3538">        exit(1);</a>
<a name="ln3539">      }</a>
<a name="ln3540">      bytes += key.size() + value_size_;</a>
<a name="ln3541">      thread-&gt;stats.FinishedOps(nullptr, db, 1, kUpdate);</a>
<a name="ln3542">    }</a>
<a name="ln3543">    char msg[100];</a>
<a name="ln3544">    snprintf(msg, sizeof(msg),</a>
<a name="ln3545">             &quot;( updates:%&quot; PRIu64 &quot; found:%&quot; PRIu64 &quot;)&quot;, readwrites_, found);</a>
<a name="ln3546">    thread-&gt;stats.AddBytes(bytes);</a>
<a name="ln3547">    thread-&gt;stats.AddMessage(msg);</a>
<a name="ln3548">  }</a>
<a name="ln3549"> </a>
<a name="ln3550">  // Read-modify-write for random keys.</a>
<a name="ln3551">  // Each operation causes the key grow by value_size (simulating an append).</a>
<a name="ln3552">  // Generally used for benchmarking against merges of similar type</a>
<a name="ln3553">  void AppendRandom(ThreadState* thread) {</a>
<a name="ln3554">    ReadOptions options(FLAGS_verify_checksum, true);</a>
<a name="ln3555">    RandomGenerator gen;</a>
<a name="ln3556">    std::string value;</a>
<a name="ln3557">    int64_t found = 0;</a>
<a name="ln3558">    int64_t bytes = 0;</a>
<a name="ln3559"> </a>
<a name="ln3560">    std::unique_ptr&lt;const char[]&gt; key_guard;</a>
<a name="ln3561">    Slice key = AllocateKey(&amp;key_guard);</a>
<a name="ln3562">    // The number of iterations is the larger of read_ or write_</a>
<a name="ln3563">    Duration duration(FLAGS_duration, readwrites_);</a>
<a name="ln3564">    while (!duration.Done(1)) {</a>
<a name="ln3565">      DB* db = SelectDB(thread);</a>
<a name="ln3566">      GenerateKeyFromInt(thread-&gt;rand.Next() % FLAGS_num, FLAGS_num, &amp;key);</a>
<a name="ln3567"> </a>
<a name="ln3568">      auto status = db-&gt;Get(options, key, &amp;value);</a>
<a name="ln3569">      if (status.ok()) {</a>
<a name="ln3570">        ++found;</a>
<a name="ln3571">        bytes += key.size() + value.size();</a>
<a name="ln3572">      } else if (!status.IsNotFound()) {</a>
<a name="ln3573">        fprintf(stderr, &quot;Get returned an error: %s\n&quot;,</a>
<a name="ln3574">                status.ToString().c_str());</a>
<a name="ln3575">        abort();</a>
<a name="ln3576">      } else {</a>
<a name="ln3577">        // If not existing, then just assume an empty string of data</a>
<a name="ln3578">        value.clear();</a>
<a name="ln3579">      }</a>
<a name="ln3580"> </a>
<a name="ln3581">      // Update the value (by appending data)</a>
<a name="ln3582">      Slice operand = gen.Generate(value_size_);</a>
<a name="ln3583">      if (value.size() &gt; 0) {</a>
<a name="ln3584">        // Use a delimiter to match the semantics for StringAppendOperator</a>
<a name="ln3585">        value.append(1, ',');</a>
<a name="ln3586">      }</a>
<a name="ln3587">      value.append(operand.cdata(), operand.size());</a>
<a name="ln3588"> </a>
<a name="ln3589">      // Write back to the database</a>
<a name="ln3590">      Status s = db-&gt;Put(write_options_, key, value);</a>
<a name="ln3591">      if (!s.ok()) {</a>
<a name="ln3592">        fprintf(stderr, &quot;put error: %s\n&quot;, s.ToString().c_str());</a>
<a name="ln3593">        exit(1);</a>
<a name="ln3594">      }</a>
<a name="ln3595">      bytes += key.size() + value.size();</a>
<a name="ln3596">      thread-&gt;stats.FinishedOps(nullptr, db, 1, kUpdate);</a>
<a name="ln3597">    }</a>
<a name="ln3598"> </a>
<a name="ln3599">    char msg[100];</a>
<a name="ln3600">    snprintf(msg, sizeof(msg), &quot;( updates:%&quot; PRIu64 &quot; found:%&quot; PRIu64 &quot;)&quot;,</a>
<a name="ln3601">            readwrites_, found);</a>
<a name="ln3602">    thread-&gt;stats.AddBytes(bytes);</a>
<a name="ln3603">    thread-&gt;stats.AddMessage(msg);</a>
<a name="ln3604">  }</a>
<a name="ln3605"> </a>
<a name="ln3606">  // Read-modify-write for random keys (using MergeOperator)</a>
<a name="ln3607">  // The merge operator to use should be defined by FLAGS_merge_operator</a>
<a name="ln3608">  // Adjust FLAGS_value_size so that the keys are reasonable for this operator</a>
<a name="ln3609">  // Assumes that the merge operator is non-null (i.e.: is well-defined)</a>
<a name="ln3610">  //</a>
<a name="ln3611">  // For example, use FLAGS_merge_operator=&quot;uint64add&quot; and FLAGS_value_size=8</a>
<a name="ln3612">  // to simulate random additions over 64-bit integers using merge.</a>
<a name="ln3613">  //</a>
<a name="ln3614">  // The number of merges on the same key can be controlled by adjusting</a>
<a name="ln3615">  // FLAGS_merge_keys.</a>
<a name="ln3616">  void MergeRandom(ThreadState* thread) {</a>
<a name="ln3617">    RandomGenerator gen;</a>
<a name="ln3618">    int64_t bytes = 0;</a>
<a name="ln3619">    std::unique_ptr&lt;const char[]&gt; key_guard;</a>
<a name="ln3620">    Slice key = AllocateKey(&amp;key_guard);</a>
<a name="ln3621">    // The number of iterations is the larger of read_ or write_</a>
<a name="ln3622">    Duration duration(FLAGS_duration, readwrites_);</a>
<a name="ln3623">    while (!duration.Done(1)) {</a>
<a name="ln3624">      DB* db = SelectDB(thread);</a>
<a name="ln3625">      GenerateKeyFromInt(thread-&gt;rand.Next() % merge_keys_, merge_keys_, &amp;key);</a>
<a name="ln3626"> </a>
<a name="ln3627">      Status s = db-&gt;Merge(write_options_, key, gen.Generate(value_size_));</a>
<a name="ln3628"> </a>
<a name="ln3629">      if (!s.ok()) {</a>
<a name="ln3630">        fprintf(stderr, &quot;merge error: %s\n&quot;, s.ToString().c_str());</a>
<a name="ln3631">        exit(1);</a>
<a name="ln3632">      }</a>
<a name="ln3633">      bytes += key.size() + value_size_;</a>
<a name="ln3634">      thread-&gt;stats.FinishedOps(nullptr, db, 1, kMerge);</a>
<a name="ln3635">    }</a>
<a name="ln3636"> </a>
<a name="ln3637">    // Print some statistics</a>
<a name="ln3638">    char msg[100];</a>
<a name="ln3639">    snprintf(msg, sizeof(msg), &quot;( updates:%&quot; PRIu64 &quot;)&quot;, readwrites_);</a>
<a name="ln3640">    thread-&gt;stats.AddBytes(bytes);</a>
<a name="ln3641">    thread-&gt;stats.AddMessage(msg);</a>
<a name="ln3642">  }</a>
<a name="ln3643"> </a>
<a name="ln3644">  // Read and merge random keys. The amount of reads and merges are controlled</a>
<a name="ln3645">  // by adjusting FLAGS_num and FLAGS_mergereadpercent. The number of distinct</a>
<a name="ln3646">  // keys (and thus also the number of reads and merges on the same key) can be</a>
<a name="ln3647">  // adjusted with FLAGS_merge_keys.</a>
<a name="ln3648">  //</a>
<a name="ln3649">  // As with MergeRandom, the merge operator to use should be defined by</a>
<a name="ln3650">  // FLAGS_merge_operator.</a>
<a name="ln3651">  void ReadRandomMergeRandom(ThreadState* thread) {</a>
<a name="ln3652">    ReadOptions options(FLAGS_verify_checksum, true);</a>
<a name="ln3653">    RandomGenerator gen;</a>
<a name="ln3654">    std::string value;</a>
<a name="ln3655">    int64_t num_hits = 0;</a>
<a name="ln3656">    int64_t num_gets = 0;</a>
<a name="ln3657">    int64_t num_merges = 0;</a>
<a name="ln3658">    size_t max_length = 0;</a>
<a name="ln3659"> </a>
<a name="ln3660">    std::unique_ptr&lt;const char[]&gt; key_guard;</a>
<a name="ln3661">    Slice key = AllocateKey(&amp;key_guard);</a>
<a name="ln3662">    // the number of iterations is the larger of read_ or write_</a>
<a name="ln3663">    Duration duration(FLAGS_duration, readwrites_);</a>
<a name="ln3664">    while (!duration.Done(1)) {</a>
<a name="ln3665">      DB* db = SelectDB(thread);</a>
<a name="ln3666">      GenerateKeyFromInt(thread-&gt;rand.Next() % merge_keys_, merge_keys_, &amp;key);</a>
<a name="ln3667"> </a>
<a name="ln3668">      bool do_merge = static_cast&lt;int&gt;(thread-&gt;rand.Next() % 100) &lt; FLAGS_mergereadpercent;</a>
<a name="ln3669"> </a>
<a name="ln3670">      if (do_merge) {</a>
<a name="ln3671">        Status s = db-&gt;Merge(write_options_, key, gen.Generate(value_size_));</a>
<a name="ln3672">        if (!s.ok()) {</a>
<a name="ln3673">          fprintf(stderr, &quot;merge error: %s\n&quot;, s.ToString().c_str());</a>
<a name="ln3674">          exit(1);</a>
<a name="ln3675">        }</a>
<a name="ln3676">        num_merges++;</a>
<a name="ln3677">        thread-&gt;stats.FinishedOps(nullptr, db, 1, kMerge);</a>
<a name="ln3678">      } else {</a>
<a name="ln3679">        Status s = db-&gt;Get(options, key, &amp;value);</a>
<a name="ln3680">        if (value.length() &gt; max_length)</a>
<a name="ln3681">          max_length = value.length();</a>
<a name="ln3682"> </a>
<a name="ln3683">        if (!s.ok() &amp;&amp; !s.IsNotFound()) {</a>
<a name="ln3684">          fprintf(stderr, &quot;get error: %s\n&quot;, s.ToString().c_str());</a>
<a name="ln3685">          // we continue after error rather than exiting so that we can</a>
<a name="ln3686">          // find more errors if any</a>
<a name="ln3687">        } else if (!s.IsNotFound()) {</a>
<a name="ln3688">          num_hits++;</a>
<a name="ln3689">        }</a>
<a name="ln3690">        num_gets++;</a>
<a name="ln3691">        thread-&gt;stats.FinishedOps(nullptr, db, 1, kRead);</a>
<a name="ln3692">      }</a>
<a name="ln3693">    }</a>
<a name="ln3694"> </a>
<a name="ln3695">    char msg[100];</a>
<a name="ln3696">    snprintf(msg, sizeof(msg),</a>
<a name="ln3697">             &quot;(reads:%&quot; PRIu64 &quot; merges:%&quot; PRIu64 &quot; total:%&quot; PRIu64</a>
<a name="ln3698">             &quot; hits:%&quot; PRIu64 &quot; maxlength:%&quot; ROCKSDB_PRIszt &quot;)&quot;,</a>
<a name="ln3699">             num_gets, num_merges, readwrites_, num_hits, max_length);</a>
<a name="ln3700">    thread-&gt;stats.AddMessage(msg);</a>
<a name="ln3701">  }</a>
<a name="ln3702"> </a>
<a name="ln3703">  void WriteSeqSeekSeq(ThreadState* thread) {</a>
<a name="ln3704">    writes_ = FLAGS_num;</a>
<a name="ln3705">    DoWrite(thread, SEQUENTIAL);</a>
<a name="ln3706">    // exclude writes from the ops/sec calculation</a>
<a name="ln3707">    thread-&gt;stats.Start(thread-&gt;tid);</a>
<a name="ln3708"> </a>
<a name="ln3709">    DB* db = SelectDB(thread);</a>
<a name="ln3710">    std::unique_ptr&lt;Iterator&gt; iter(</a>
<a name="ln3711">      db-&gt;NewIterator(ReadOptions(FLAGS_verify_checksum, true)));</a>
<a name="ln3712"> </a>
<a name="ln3713">    std::unique_ptr&lt;const char[]&gt; key_guard;</a>
<a name="ln3714">    Slice key = AllocateKey(&amp;key_guard);</a>
<a name="ln3715">    for (int64_t i = 0; i &lt; FLAGS_num; ++i) {</a>
<a name="ln3716">      GenerateKeyFromInt(i, FLAGS_num, &amp;key);</a>
<a name="ln3717">      iter-&gt;Seek(key);</a>
<a name="ln3718">      assert(iter-&gt;Valid() &amp;&amp; iter-&gt;key() == key);</a>
<a name="ln3719">      thread-&gt;stats.FinishedOps(nullptr, db, 1, kSeek);</a>
<a name="ln3720"> </a>
<a name="ln3721">      for (int j = 0; j &lt; FLAGS_seek_nexts &amp;&amp; i + 1 &lt; FLAGS_num; ++j) {</a>
<a name="ln3722">        if (!FLAGS_reverse_iterator) {</a>
<a name="ln3723">          iter-&gt;Next();</a>
<a name="ln3724">        } else {</a>
<a name="ln3725">          iter-&gt;Prev();</a>
<a name="ln3726">        }</a>
<a name="ln3727">        GenerateKeyFromInt(++i, FLAGS_num, &amp;key);</a>
<a name="ln3728">        assert(iter-&gt;Valid() &amp;&amp; iter-&gt;key() == key);</a>
<a name="ln3729">        thread-&gt;stats.FinishedOps(nullptr, db, 1, kSeek);</a>
<a name="ln3730">      }</a>
<a name="ln3731"> </a>
<a name="ln3732">      iter-&gt;Seek(key);</a>
<a name="ln3733">      assert(iter-&gt;Valid() &amp;&amp; iter-&gt;key() == key);</a>
<a name="ln3734">      thread-&gt;stats.FinishedOps(nullptr, db, 1, kSeek);</a>
<a name="ln3735">    }</a>
<a name="ln3736">  }</a>
<a name="ln3737"> </a>
<a name="ln3738">#ifndef ROCKSDB_LITE</a>
<a name="ln3739">  // This benchmark stress tests Transactions.  For a given --duration (or</a>
<a name="ln3740">  // total number of --writes, a Transaction will perform a read-modify-write</a>
<a name="ln3741">  // to increment the value of a key in each of N(--transaction-sets) sets of</a>
<a name="ln3742">  // keys (where each set has --num keys).  If --threads is set, this will be</a>
<a name="ln3743">  // done in parallel.</a>
<a name="ln3744">  //</a>
<a name="ln3745">  // To test transactions, use --transaction_db=true.  Not setting this</a>
<a name="ln3746">  // parameter</a>
<a name="ln3747">  // will run the same benchmark without transactions.</a>
<a name="ln3748">  //</a>
<a name="ln3749">  // RandomTransactionVerify() will then validate the correctness of the results</a>
<a name="ln3750">  // by checking if the sum of all keys in each set is the same.</a>
<a name="ln3751">  void RandomTransaction(ThreadState* thread) {</a>
<a name="ln3752">    ReadOptions options(FLAGS_verify_checksum, true);</a>
<a name="ln3753">    Duration duration(FLAGS_duration, readwrites_);</a>
<a name="ln3754">    ReadOptions read_options(FLAGS_verify_checksum, true);</a>
<a name="ln3755">    std::string value;</a>
<a name="ln3756">    DB* db = db_.db;</a>
<a name="ln3757">    uint64_t transactions_done = 0;</a>
<a name="ln3758">    uint64_t transactions_aborted = 0;</a>
<a name="ln3759">    Status s;</a>
<a name="ln3760">    uint64_t num_prefix_ranges = FLAGS_transaction_sets;</a>
<a name="ln3761"> </a>
<a name="ln3762">    if (num_prefix_ranges == 0 || num_prefix_ranges &gt; 9999) {</a>
<a name="ln3763">      fprintf(stderr, &quot;invalid value for transaction_sets\n&quot;);</a>
<a name="ln3764">      abort();</a>
<a name="ln3765">    }</a>
<a name="ln3766"> </a>
<a name="ln3767">    if (FLAGS_num_multi_db &gt; 1) {</a>
<a name="ln3768">      fprintf(stderr,</a>
<a name="ln3769">              &quot;Cannot run RandomTransaction benchmark with &quot;</a>
<a name="ln3770">              &quot;FLAGS_multi_db &gt; 1.&quot;);</a>
<a name="ln3771">      abort();</a>
<a name="ln3772">    }</a>
<a name="ln3773"> </a>
<a name="ln3774">    while (!duration.Done(1)) {</a>
<a name="ln3775">      Transaction* txn = nullptr;</a>
<a name="ln3776">      WriteBatch* batch = nullptr;</a>
<a name="ln3777"> </a>
<a name="ln3778">      if (FLAGS_optimistic_transaction_db) {</a>
<a name="ln3779">        txn = db_.opt_txn_db-&gt;BeginTransaction(write_options_);</a>
<a name="ln3780">        assert(txn);</a>
<a name="ln3781">      } else if (FLAGS_transaction_db) {</a>
<a name="ln3782">        TransactionDB* txn_db = reinterpret_cast&lt;TransactionDB*&gt;(db_.db);</a>
<a name="ln3783"> </a>
<a name="ln3784">        TransactionOptions txn_options;</a>
<a name="ln3785">        txn_options.lock_timeout = FLAGS_transaction_lock_timeout;</a>
<a name="ln3786"> </a>
<a name="ln3787">        txn = txn_db-&gt;BeginTransaction(write_options_, txn_options);</a>
<a name="ln3788">        assert(txn);</a>
<a name="ln3789">      } else {</a>
<a name="ln3790">        batch = new WriteBatch();</a>
<a name="ln3791">      }</a>
<a name="ln3792"> </a>
<a name="ln3793">      if (txn &amp;&amp; FLAGS_transaction_set_snapshot) {</a>
<a name="ln3794">        txn-&gt;SetSnapshot();</a>
<a name="ln3795">      }</a>
<a name="ln3796"> </a>
<a name="ln3797">      // pick a random number to use to increment a key in each set</a>
<a name="ln3798">      uint64_t incr = (thread-&gt;rand.Next() % 100) + 1;</a>
<a name="ln3799"> </a>
<a name="ln3800">      bool failed = false;</a>
<a name="ln3801">      // For each set, pick a key at random and increment it</a>
<a name="ln3802">      for (uint8_t i = 0; i &lt; num_prefix_ranges; i++) {</a>
<a name="ln3803">        uint64_t int_value;</a>
<a name="ln3804">        char prefix_buf[5];</a>
<a name="ln3805"> </a>
<a name="ln3806">        // key format:  [SET#][random#]</a>
<a name="ln3807">        std::string rand_key = ToString(thread-&gt;rand.Next() % FLAGS_num);</a>
<a name="ln3808">        Slice base_key(rand_key);</a>
<a name="ln3809"> </a>
<a name="ln3810">        // Pad prefix appropriately so we can iterate over each set</a>
<a name="ln3811">        snprintf(prefix_buf, sizeof(prefix_buf), &quot;%04d&quot;, i + 1);</a>
<a name="ln3812">        std::string full_key = std::string(prefix_buf) + base_key.ToString();</a>
<a name="ln3813">        Slice key(full_key);</a>
<a name="ln3814"> </a>
<a name="ln3815">        if (txn) {</a>
<a name="ln3816">          s = txn-&gt;GetForUpdate(read_options, key, &amp;value);</a>
<a name="ln3817">        } else {</a>
<a name="ln3818">          s = db-&gt;Get(read_options, key, &amp;value);</a>
<a name="ln3819">        }</a>
<a name="ln3820"> </a>
<a name="ln3821">        if (s.ok()) {</a>
<a name="ln3822">          int_value = std::stoull(value);</a>
<a name="ln3823"> </a>
<a name="ln3824">          if (int_value == 0 || int_value == ULONG_MAX) {</a>
<a name="ln3825">            fprintf(stderr, &quot;Get returned unexpected value: %s\n&quot;,</a>
<a name="ln3826">                    value.c_str());</a>
<a name="ln3827">            abort();</a>
<a name="ln3828">          }</a>
<a name="ln3829">        } else if (s.IsNotFound()) {</a>
<a name="ln3830">          int_value = 0;</a>
<a name="ln3831">        } else if (!(s.IsBusy() || s.IsTimedOut() || s.IsTryAgain())) {</a>
<a name="ln3832">          fprintf(stderr, &quot;Get returned an unexpected error: %s\n&quot;,</a>
<a name="ln3833">                  s.ToString().c_str());</a>
<a name="ln3834">          abort();</a>
<a name="ln3835">        } else {</a>
<a name="ln3836">          failed = true;</a>
<a name="ln3837">          break;</a>
<a name="ln3838">        }</a>
<a name="ln3839"> </a>
<a name="ln3840">        if (FLAGS_transaction_sleep &gt; 0) {</a>
<a name="ln3841">          FLAGS_env-&gt;SleepForMicroseconds(thread-&gt;rand.Next() %</a>
<a name="ln3842">                                          FLAGS_transaction_sleep);</a>
<a name="ln3843">        }</a>
<a name="ln3844"> </a>
<a name="ln3845">        std::string sum = ToString(int_value + incr);</a>
<a name="ln3846">        if (txn) {</a>
<a name="ln3847">          s = txn-&gt;Put(key, sum);</a>
<a name="ln3848">          if (!s.ok()) {</a>
<a name="ln3849">            // Since we did a GetForUpdate, Put should not fail.</a>
<a name="ln3850">            fprintf(stderr, &quot;Put returned an unexpected error: %s\n&quot;,</a>
<a name="ln3851">                    s.ToString().c_str());</a>
<a name="ln3852">            abort();</a>
<a name="ln3853">          }</a>
<a name="ln3854">        } else {</a>
<a name="ln3855">          batch-&gt;Put(key, sum);</a>
<a name="ln3856">        }</a>
<a name="ln3857">      }</a>
<a name="ln3858"> </a>
<a name="ln3859">      if (txn) {</a>
<a name="ln3860">        if (failed) {</a>
<a name="ln3861">          transactions_aborted++;</a>
<a name="ln3862">          txn-&gt;Rollback();</a>
<a name="ln3863">          s = Status::OK();</a>
<a name="ln3864">        } else {</a>
<a name="ln3865">          s = txn-&gt;Commit();</a>
<a name="ln3866">        }</a>
<a name="ln3867">      } else {</a>
<a name="ln3868">        s = db-&gt;Write(write_options_, batch);</a>
<a name="ln3869">      }</a>
<a name="ln3870"> </a>
<a name="ln3871">      if (!s.ok()) {</a>
<a name="ln3872">        failed = true;</a>
<a name="ln3873"> </a>
<a name="ln3874">        // Ideally, we'd want to run this stress test with enough concurrency</a>
<a name="ln3875">        // on a small enough set of keys that we get some failed transactions</a>
<a name="ln3876">        // due to conflicts.</a>
<a name="ln3877">        if (FLAGS_optimistic_transaction_db &amp;&amp;</a>
<a name="ln3878">            (s.IsBusy() || s.IsTimedOut() || s.IsTryAgain())) {</a>
<a name="ln3879">          transactions_aborted++;</a>
<a name="ln3880">        } else if (FLAGS_transaction_db &amp;&amp; s.IsExpired()) {</a>
<a name="ln3881">          transactions_aborted++;</a>
<a name="ln3882">        } else {</a>
<a name="ln3883">          fprintf(stderr, &quot;Unexpected write error: %s\n&quot;, s.ToString().c_str());</a>
<a name="ln3884">          abort();</a>
<a name="ln3885">        }</a>
<a name="ln3886">      }</a>
<a name="ln3887"> </a>
<a name="ln3888">      delete txn;</a>
<a name="ln3889">      delete batch;</a>
<a name="ln3890"> </a>
<a name="ln3891">      if (!failed) {</a>
<a name="ln3892">        thread-&gt;stats.FinishedOps(nullptr, db, 1, kOthers);</a>
<a name="ln3893">      }</a>
<a name="ln3894"> </a>
<a name="ln3895">      transactions_done++;</a>
<a name="ln3896">    }</a>
<a name="ln3897"> </a>
<a name="ln3898">    char msg[100];</a>
<a name="ln3899">    if (FLAGS_optimistic_transaction_db || FLAGS_transaction_db) {</a>
<a name="ln3900">      snprintf(msg, sizeof(msg),</a>
<a name="ln3901">               &quot;( transactions:%&quot; PRIu64 &quot; aborts:%&quot; PRIu64 &quot;)&quot;,</a>
<a name="ln3902">               transactions_done, transactions_aborted);</a>
<a name="ln3903">    } else {</a>
<a name="ln3904">      snprintf(msg, sizeof(msg), &quot;( batches:%&quot; PRIu64 &quot; )&quot;, transactions_done);</a>
<a name="ln3905">    }</a>
<a name="ln3906">    thread-&gt;stats.AddMessage(msg);</a>
<a name="ln3907"> </a>
<a name="ln3908">    if (FLAGS_perf_level &gt; 0) {</a>
<a name="ln3909">      thread-&gt;stats.AddMessage(perf_context.ToString());</a>
<a name="ln3910">    }</a>
<a name="ln3911">  }</a>
<a name="ln3912"> </a>
<a name="ln3913">  // Verifies consistency of data after RandomTransaction() has been run.</a>
<a name="ln3914">  // Since each iteration of RandomTransaction() incremented a key in each set</a>
<a name="ln3915">  // by the same value, the sum of the keys in each set should be the same.</a>
<a name="ln3916">  void RandomTransactionVerify() {</a>
<a name="ln3917">    if (!FLAGS_transaction_db &amp;&amp; !FLAGS_optimistic_transaction_db) {</a>
<a name="ln3918">      // transactions not used, nothing to verify.</a>
<a name="ln3919">      return;</a>
<a name="ln3920">    }</a>
<a name="ln3921"> </a>
<a name="ln3922">    uint64_t prev_total = 0;</a>
<a name="ln3923"> </a>
<a name="ln3924">    // For each set of keys with the same prefix, sum all the values</a>
<a name="ln3925">    for (uint32_t i = 0; i &lt; FLAGS_transaction_sets; i++) {</a>
<a name="ln3926">      char prefix_buf[5];</a>
<a name="ln3927">      snprintf(prefix_buf, sizeof(prefix_buf), &quot;%04u&quot;, i + 1);</a>
<a name="ln3928">      uint64_t total = 0;</a>
<a name="ln3929"> </a>
<a name="ln3930">      Iterator* iter = db_.db-&gt;NewIterator(ReadOptions());</a>
<a name="ln3931"> </a>
<a name="ln3932">      for (iter-&gt;Seek(Slice(prefix_buf, 4)); iter-&gt;Valid(); iter-&gt;Next()) {</a>
<a name="ln3933">        Slice key = iter-&gt;key();</a>
<a name="ln3934"> </a>
<a name="ln3935">        // stop when we reach a different prefix</a>
<a name="ln3936">        if (key.ToString().compare(0, 4, prefix_buf) != 0) {</a>
<a name="ln3937">          break;</a>
<a name="ln3938">        }</a>
<a name="ln3939"> </a>
<a name="ln3940">        Slice value = iter-&gt;value();</a>
<a name="ln3941">        uint64_t int_value = std::stoull(value.ToString());</a>
<a name="ln3942">        if (int_value == 0 || int_value == ULONG_MAX) {</a>
<a name="ln3943">          fprintf(stderr, &quot;Iter returned unexpected value: %s\n&quot;,</a>
<a name="ln3944">                  value.ToString().c_str());</a>
<a name="ln3945">          abort();</a>
<a name="ln3946">        }</a>
<a name="ln3947"> </a>
<a name="ln3948">        total += int_value;</a>
<a name="ln3949">      }</a>
<a name="ln3950">      delete iter;</a>
<a name="ln3951"> </a>
<a name="ln3952">      if (i &gt; 0) {</a>
<a name="ln3953">        if (total != prev_total) {</a>
<a name="ln3954">          fprintf(stderr,</a>
<a name="ln3955">                  &quot;RandomTransactionVerify found inconsistent totals. &quot;</a>
<a name="ln3956">                  &quot;Set[%&quot; PRIu32 &quot;]: %&quot; PRIu64 &quot;, Set[%&quot; PRIu32 &quot;]: %&quot; PRIu64</a>
<a name="ln3957">                  &quot; \n&quot;,</a>
<a name="ln3958">                  i - 1, prev_total, i, total);</a>
<a name="ln3959">          abort();</a>
<a name="ln3960">        }</a>
<a name="ln3961">      }</a>
<a name="ln3962">      prev_total = total;</a>
<a name="ln3963">    }</a>
<a name="ln3964"> </a>
<a name="ln3965">    fprintf(stdout, &quot;RandomTransactionVerify Success!\n&quot;);</a>
<a name="ln3966">  }</a>
<a name="ln3967">#endif  // ROCKSDB_LITE</a>
<a name="ln3968"> </a>
<a name="ln3969">  // Writes and deletes random keys without overwriting keys.</a>
<a name="ln3970">  //</a>
<a name="ln3971">  // This benchmark is intended to partially replicate the behavior of MyRocks</a>
<a name="ln3972">  // secondary indices: All data is stored in keys and updates happen by</a>
<a name="ln3973">  // deleting the old version of the key and inserting the new version.</a>
<a name="ln3974">  void RandomReplaceKeys(ThreadState* thread) {</a>
<a name="ln3975">    std::unique_ptr&lt;const char[]&gt; key_guard;</a>
<a name="ln3976">    Slice key = AllocateKey(&amp;key_guard);</a>
<a name="ln3977">    std::vector&lt;uint32_t&gt; counters(FLAGS_numdistinct, 0);</a>
<a name="ln3978">    size_t max_counter = 50;</a>
<a name="ln3979">    RandomGenerator gen;</a>
<a name="ln3980"> </a>
<a name="ln3981">    Status s;</a>
<a name="ln3982">    DB* db = SelectDB(thread);</a>
<a name="ln3983">    for (int64_t i = 0; i &lt; FLAGS_numdistinct; i++) {</a>
<a name="ln3984">      GenerateKeyFromInt(i * max_counter, FLAGS_num, &amp;key);</a>
<a name="ln3985">      s = db-&gt;Put(write_options_, key, gen.Generate(value_size_));</a>
<a name="ln3986">      if (!s.ok()) {</a>
<a name="ln3987">        fprintf(stderr, &quot;Operation failed: %s\n&quot;, s.ToString().c_str());</a>
<a name="ln3988">        exit(1);</a>
<a name="ln3989">      }</a>
<a name="ln3990">    }</a>
<a name="ln3991"> </a>
<a name="ln3992">    db-&gt;GetSnapshot();</a>
<a name="ln3993"> </a>
<a name="ln3994">    std::default_random_engine generator;</a>
<a name="ln3995">    std::normal_distribution&lt;double&gt; distribution(FLAGS_numdistinct / 2.0,</a>
<a name="ln3996">                                                  FLAGS_stddev);</a>
<a name="ln3997">    Duration duration(FLAGS_duration, FLAGS_num);</a>
<a name="ln3998">    while (!duration.Done(1)) {</a>
<a name="ln3999">      int64_t rnd_id = static_cast&lt;int64_t&gt;(distribution(generator));</a>
<a name="ln4000">      int64_t key_id = std::max(std::min(FLAGS_numdistinct - 1, rnd_id),</a>
<a name="ln4001">                                static_cast&lt;int64_t&gt;(0));</a>
<a name="ln4002">      GenerateKeyFromInt(key_id * max_counter + counters[key_id], FLAGS_num,</a>
<a name="ln4003">                         &amp;key);</a>
<a name="ln4004">      s = FLAGS_use_single_deletes ? db-&gt;SingleDelete(write_options_, key)</a>
<a name="ln4005">                                   : db-&gt;Delete(write_options_, key);</a>
<a name="ln4006">      if (s.ok()) {</a>
<a name="ln4007">        counters[key_id] = (counters[key_id] + 1) % max_counter;</a>
<a name="ln4008">        GenerateKeyFromInt(key_id * max_counter + counters[key_id], FLAGS_num,</a>
<a name="ln4009">                           &amp;key);</a>
<a name="ln4010">        s = db-&gt;Put(write_options_, key, Slice());</a>
<a name="ln4011">      }</a>
<a name="ln4012"> </a>
<a name="ln4013">      if (!s.ok()) {</a>
<a name="ln4014">        fprintf(stderr, &quot;Operation failed: %s\n&quot;, s.ToString().c_str());</a>
<a name="ln4015">        exit(1);</a>
<a name="ln4016">      }</a>
<a name="ln4017"> </a>
<a name="ln4018">      thread-&gt;stats.FinishedOps(nullptr, db, 1, kOthers);</a>
<a name="ln4019">    }</a>
<a name="ln4020"> </a>
<a name="ln4021">    char msg[200];</a>
<a name="ln4022">    snprintf(msg, sizeof(msg),</a>
<a name="ln4023">             &quot;use single deletes: %d, &quot;</a>
<a name="ln4024">             &quot;standard deviation: %lf\n&quot;,</a>
<a name="ln4025">             FLAGS_use_single_deletes, FLAGS_stddev);</a>
<a name="ln4026">    thread-&gt;stats.AddMessage(msg);</a>
<a name="ln4027">  }</a>
<a name="ln4028"> </a>
<a name="ln4029">  void Compact(ThreadState* thread) {</a>
<a name="ln4030">    DB* db = SelectDB(thread);</a>
<a name="ln4031">    CHECK_OK(db-&gt;CompactRange(CompactRangeOptions(), nullptr, nullptr));</a>
<a name="ln4032">  }</a>
<a name="ln4033"> </a>
<a name="ln4034">  void PrintStats(const char* key) {</a>
<a name="ln4035">    if (db_.db != nullptr) {</a>
<a name="ln4036">      PrintStats(db_.db, key, false);</a>
<a name="ln4037">    }</a>
<a name="ln4038">    for (const auto&amp; db_with_cfh : multi_dbs_) {</a>
<a name="ln4039">      PrintStats(db_with_cfh.db, key, true);</a>
<a name="ln4040">    }</a>
<a name="ln4041">  }</a>
<a name="ln4042"> </a>
<a name="ln4043">  void PrintStats(DB* db, const char* key, bool print_header = false) {</a>
<a name="ln4044">    if (print_header) {</a>
<a name="ln4045">      fprintf(stdout, &quot;\n==== DB: %s ===\n&quot;, db-&gt;GetName().c_str());</a>
<a name="ln4046">    }</a>
<a name="ln4047">    std::string stats;</a>
<a name="ln4048">    if (!db-&gt;GetProperty(key, &amp;stats)) {</a>
<a name="ln4049">      stats = &quot;(failed)&quot;;</a>
<a name="ln4050">    }</a>
<a name="ln4051">    fprintf(stdout, &quot;\n%s\n&quot;, stats.c_str());</a>
<a name="ln4052">  }</a>
<a name="ln4053">};</a>
<a name="ln4054"> </a>
<a name="ln4055">int db_bench_tool(int argc, char** argv) {</a>
<a name="ln4056">  rocksdb::port::InstallStackTraceHandler();</a>
<a name="ln4057">  SetUsageMessage(std::string(&quot;\nUSAGE:\n&quot;) + std::string(argv[0]) +</a>
<a name="ln4058">                  &quot; [OPTIONS]...&quot;);</a>
<a name="ln4059">  ParseCommandLineFlags(&amp;argc, &amp;argv, true);</a>
<a name="ln4060"> </a>
<a name="ln4061">  FLAGS_compaction_style_e = (rocksdb::CompactionStyle) FLAGS_compaction_style;</a>
<a name="ln4062">  if (FLAGS_statistics) {</a>
<a name="ln4063">    dbstats = rocksdb::CreateDBStatistics();</a>
<a name="ln4064">  }</a>
<a name="ln4065">  FLAGS_compaction_pri_e = (rocksdb::CompactionPri)FLAGS_compaction_pri;</a>
<a name="ln4066"> </a>
<a name="ln4067">  std::vector&lt;std::string&gt; fanout = rocksdb::StringSplit(</a>
<a name="ln4068">      FLAGS_max_bytes_for_level_multiplier_additional, ',');</a>
<a name="ln4069">  for (size_t j = 0; j &lt; fanout.size(); j++) {</a>
<a name="ln4070">    FLAGS_max_bytes_for_level_multiplier_additional_v.push_back(</a>
<a name="ln4071">#ifndef CYGWIN</a>
<a name="ln4072">        std::stoi(fanout[j]));</a>
<a name="ln4073">#else</a>
<a name="ln4074">        stoi(fanout[j]));</a>
<a name="ln4075">#endif</a>
<a name="ln4076">  }</a>
<a name="ln4077"> </a>
<a name="ln4078">  FLAGS_compression_type_e =</a>
<a name="ln4079">    StringToCompressionType(FLAGS_compression_type.c_str());</a>
<a name="ln4080"> </a>
<a name="ln4081">  if (!FLAGS_hdfs.empty()) {</a>
<a name="ln4082">    FLAGS_env  = new rocksdb::HdfsEnv(FLAGS_hdfs);</a>
<a name="ln4083">  }</a>
<a name="ln4084"> </a>
<a name="ln4085">  if (!strcasecmp(FLAGS_compaction_fadvice.c_str(), &quot;NONE&quot;)) {</a>
<a name="ln4086">    FLAGS_compaction_fadvice_e = rocksdb::Options::NONE;</a>
<a name="ln4087">  } else if (!strcasecmp(FLAGS_compaction_fadvice.c_str(), &quot;NORMAL&quot;)) {</a>
<a name="ln4088">    FLAGS_compaction_fadvice_e = rocksdb::Options::NORMAL;</a>
<a name="ln4089">  } else if (!strcasecmp(FLAGS_compaction_fadvice.c_str(), &quot;SEQUENTIAL&quot;)) {</a>
<a name="ln4090">    FLAGS_compaction_fadvice_e = rocksdb::Options::SEQUENTIAL;</a>
<a name="ln4091">  } else if (!strcasecmp(FLAGS_compaction_fadvice.c_str(), &quot;WILLNEED&quot;)) {</a>
<a name="ln4092">    FLAGS_compaction_fadvice_e = rocksdb::Options::WILLNEED;</a>
<a name="ln4093">  } else {</a>
<a name="ln4094">    fprintf(stdout, &quot;Unknown compaction fadvice:%s\n&quot;,</a>
<a name="ln4095">            FLAGS_compaction_fadvice.c_str());</a>
<a name="ln4096">  }</a>
<a name="ln4097"> </a>
<a name="ln4098">  FLAGS_rep_factory = StringToRepFactory(FLAGS_memtablerep.c_str());</a>
<a name="ln4099"> </a>
<a name="ln4100">  // The number of background threads should be at least as much the</a>
<a name="ln4101">  // max number of concurrent compactions.</a>
<a name="ln4102">  FLAGS_env-&gt;SetBackgroundThreads(FLAGS_max_background_compactions);</a>
<a name="ln4103">  FLAGS_env-&gt;SetBackgroundThreads(FLAGS_max_background_flushes,</a>
<a name="ln4104">                                  rocksdb::Env::Priority::HIGH);</a>
<a name="ln4105"> </a>
<a name="ln4106">  // Choose a location for the test database if none given with --db=&lt;path&gt;</a>
<a name="ln4107">  if (FLAGS_db.empty()) {</a>
<a name="ln4108">    std::string default_db_path;</a>
<a name="ln4109">    CHECK_OK(rocksdb::Env::Default()-&gt;GetTestDirectory(&amp;default_db_path));</a>
<a name="ln4110">    default_db_path += &quot;/dbbench&quot;;</a>
<a name="ln4111">    FLAGS_db = default_db_path;</a>
<a name="ln4112">  }</a>
<a name="ln4113"> </a>
<a name="ln4114">  if (FLAGS_stats_interval_seconds &gt; 0) {</a>
<a name="ln4115">    // When both are set then FLAGS_stats_interval determines the frequency</a>
<a name="ln4116">    // at which the timer is checked for FLAGS_stats_interval_seconds</a>
<a name="ln4117">    FLAGS_stats_interval = 1000;</a>
<a name="ln4118">  }</a>
<a name="ln4119"> </a>
<a name="ln4120">  rocksdb::Benchmark benchmark;</a>
<a name="ln4121">  benchmark.Run();</a>
<a name="ln4122">  return 0;</a>
<a name="ln4123">}</a>
<a name="ln4124">}  // namespace rocksdb</a>
<a name="ln4125">#endif</a>

</code></pre>
<div class="balloon" rel="1010"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v690/" target="_blank">V690</a> The 'DBWithColumnFamilies' class implements a copy constructor, but lacks the copy assignment operator. It is dangerous to use such a class.</p></div>
<div class="balloon" rel="1203"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v766/" target="_blank">V766</a> An item with the same key 'kCompress' has already been added.</p></div>
<div class="balloon" rel="1288"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1295"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1635"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1028/" target="_blank">V1028</a> Possible overflow. Consider casting operands, not the result.</p></div>
<div class="balloon" rel="1811"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1819"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="2063"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="2067"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="2312"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'uncompressed != nullptr' is always false.</p></div>
<div class="balloon" rel="2317"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'uncompressed != nullptr' is always false.</p></div>
<div class="balloon" rel="2322"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'uncompressed != nullptr' is always false.</p></div>
<div class="balloon" rel="2327"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'uncompressed != nullptr' is always false.</p></div>
<div class="balloon" rel="2315"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 2315, 2320</p></div>
<div class="balloon" rel="2495"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'block_based_options.index_type' variable was assigned the same value.</p></div>
<div class="balloon" rel="2509"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'block_based_options.format_version' variable was assigned the same value.</p></div>
<div class="balloon" rel="4031"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="4109"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1228"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> It is possible that not all members of a class are initialized inside the constructor. Consider inspecting: reporter_agent_.</p></div>
<div class="balloon" rel="1517"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: shared.</p></div>
<div class="balloon" rel="1507"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: total, num_initialized, num_done, start.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
