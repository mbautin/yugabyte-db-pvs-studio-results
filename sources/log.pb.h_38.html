
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>log.pb.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Generated by the protocol buffer compiler.  DO NOT EDIT!</a>
<a name="ln2">// source: yb/consensus/log.proto</a>
<a name="ln3"> </a>
<a name="ln4">#ifndef PROTOBUF_yb_2fconsensus_2flog_2eproto__INCLUDED</a>
<a name="ln5">#define PROTOBUF_yb_2fconsensus_2flog_2eproto__INCLUDED</a>
<a name="ln6"> </a>
<a name="ln7">#include &lt;string&gt;</a>
<a name="ln8"> </a>
<a name="ln9">#include &lt;google/protobuf/stubs/common.h&gt;</a>
<a name="ln10"> </a>
<a name="ln11">#if GOOGLE_PROTOBUF_VERSION &lt; 3005000</a>
<a name="ln12">#error This file was generated by a newer version of protoc which is</a>
<a name="ln13">#error incompatible with your Protocol Buffer headers.  Please update</a>
<a name="ln14">#error your headers.</a>
<a name="ln15">#endif</a>
<a name="ln16">#if 3005001 &lt; GOOGLE_PROTOBUF_MIN_PROTOC_VERSION</a>
<a name="ln17">#error This file was generated by an older version of protoc which is</a>
<a name="ln18">#error incompatible with your Protocol Buffer headers.  Please</a>
<a name="ln19">#error regenerate this file with a newer version of protoc.</a>
<a name="ln20">#endif</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;google/protobuf/io/coded_stream.h&gt;</a>
<a name="ln23">#include &lt;google/protobuf/arena.h&gt;</a>
<a name="ln24">#include &lt;google/protobuf/arenastring.h&gt;</a>
<a name="ln25">#include &lt;google/protobuf/generated_message_table_driven.h&gt;</a>
<a name="ln26">#include &lt;google/protobuf/generated_message_util.h&gt;</a>
<a name="ln27">#include &lt;google/protobuf/metadata.h&gt;</a>
<a name="ln28">#include &lt;google/protobuf/message.h&gt;</a>
<a name="ln29">#include &lt;google/protobuf/repeated_field.h&gt;  // IWYU pragma: export</a>
<a name="ln30">#include &lt;google/protobuf/extension_set.h&gt;  // IWYU pragma: export</a>
<a name="ln31">#include &lt;google/protobuf/generated_enum_reflection.h&gt;</a>
<a name="ln32">#include &lt;google/protobuf/unknown_field_set.h&gt;</a>
<a name="ln33">#include &quot;yb/common/common.pb.h&quot;</a>
<a name="ln34">#include &quot;yb/consensus/consensus.pb.h&quot;</a>
<a name="ln35">#include &quot;yb/consensus/metadata.pb.h&quot;</a>
<a name="ln36">#include &quot;yb/util/opid.pb.h&quot;</a>
<a name="ln37">// @@protoc_insertion_point(includes)</a>
<a name="ln38"> </a>
<a name="ln39">namespace protobuf_yb_2fconsensus_2flog_2eproto {</a>
<a name="ln40">// Internal implementation detail -- do not use these members.</a>
<a name="ln41">struct TableStruct {</a>
<a name="ln42">  static const ::google::protobuf::internal::ParseTableField entries[];</a>
<a name="ln43">  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];</a>
<a name="ln44">  static const ::google::protobuf::internal::ParseTable schema[4];</a>
<a name="ln45">  static const ::google::protobuf::internal::FieldMetadata field_metadata[];</a>
<a name="ln46">  static const ::google::protobuf::internal::SerializationTable serialization_table[];</a>
<a name="ln47">  static const ::google::protobuf::uint32 offsets[];</a>
<a name="ln48">};</a>
<a name="ln49">void AddDescriptors();</a>
<a name="ln50">void InitDefaultsLogEntryPBImpl();</a>
<a name="ln51">void InitDefaultsLogEntryPB();</a>
<a name="ln52">void InitDefaultsLogEntryBatchPBImpl();</a>
<a name="ln53">void InitDefaultsLogEntryBatchPB();</a>
<a name="ln54">void InitDefaultsLogSegmentHeaderPBImpl();</a>
<a name="ln55">void InitDefaultsLogSegmentHeaderPB();</a>
<a name="ln56">void InitDefaultsLogSegmentFooterPBImpl();</a>
<a name="ln57">void InitDefaultsLogSegmentFooterPB();</a>
<a name="ln58">inline void InitDefaults() {</a>
<a name="ln59">  InitDefaultsLogEntryPB();</a>
<a name="ln60">  InitDefaultsLogEntryBatchPB();</a>
<a name="ln61">  InitDefaultsLogSegmentHeaderPB();</a>
<a name="ln62">  InitDefaultsLogSegmentFooterPB();</a>
<a name="ln63">}</a>
<a name="ln64">}  // namespace protobuf_yb_2fconsensus_2flog_2eproto</a>
<a name="ln65">namespace yb {</a>
<a name="ln66">namespace log {</a>
<a name="ln67">class LogEntryBatchPB;</a>
<a name="ln68">class LogEntryBatchPBDefaultTypeInternal;</a>
<a name="ln69">extern LogEntryBatchPBDefaultTypeInternal _LogEntryBatchPB_default_instance_;</a>
<a name="ln70">class LogEntryPB;</a>
<a name="ln71">class LogEntryPBDefaultTypeInternal;</a>
<a name="ln72">extern LogEntryPBDefaultTypeInternal _LogEntryPB_default_instance_;</a>
<a name="ln73">class LogSegmentFooterPB;</a>
<a name="ln74">class LogSegmentFooterPBDefaultTypeInternal;</a>
<a name="ln75">extern LogSegmentFooterPBDefaultTypeInternal _LogSegmentFooterPB_default_instance_;</a>
<a name="ln76">class LogSegmentHeaderPB;</a>
<a name="ln77">class LogSegmentHeaderPBDefaultTypeInternal;</a>
<a name="ln78">extern LogSegmentHeaderPBDefaultTypeInternal _LogSegmentHeaderPB_default_instance_;</a>
<a name="ln79">}  // namespace log</a>
<a name="ln80">}  // namespace yb</a>
<a name="ln81">namespace yb {</a>
<a name="ln82">namespace log {</a>
<a name="ln83"> </a>
<a name="ln84">enum LogEntryTypePB {</a>
<a name="ln85">  UNKNOWN = 0,</a>
<a name="ln86">  REPLICATE = 1,</a>
<a name="ln87">  FLUSH_MARKER = 999</a>
<a name="ln88">};</a>
<a name="ln89">bool LogEntryTypePB_IsValid(int value);</a>
<a name="ln90">const LogEntryTypePB LogEntryTypePB_MIN = UNKNOWN;</a>
<a name="ln91">const LogEntryTypePB LogEntryTypePB_MAX = FLUSH_MARKER;</a>
<a name="ln92">const int LogEntryTypePB_ARRAYSIZE = LogEntryTypePB_MAX + 1;</a>
<a name="ln93"> </a>
<a name="ln94">const ::google::protobuf::EnumDescriptor* LogEntryTypePB_descriptor();</a>
<a name="ln95">inline const ::std::string&amp; LogEntryTypePB_Name(LogEntryTypePB value) {</a>
<a name="ln96">  return ::google::protobuf::internal::NameOfEnum(</a>
<a name="ln97">    LogEntryTypePB_descriptor(), value);</a>
<a name="ln98">}</a>
<a name="ln99">inline bool LogEntryTypePB_Parse(</a>
<a name="ln100">    const ::std::string&amp; name, LogEntryTypePB* value) {</a>
<a name="ln101">  return ::google::protobuf::internal::ParseNamedEnum&lt;LogEntryTypePB&gt;(</a>
<a name="ln102">    LogEntryTypePB_descriptor(), name, value);</a>
<a name="ln103">}</a>
<a name="ln104">// ===================================================================</a>
<a name="ln105"> </a>
<a name="ln106">class LogEntryPB : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:yb.log.LogEntryPB) */ {</a>
<a name="ln107"> public:</a>
<a name="ln108">  LogEntryPB();</a>
<a name="ln109">  virtual ~LogEntryPB();</a>
<a name="ln110"> </a>
<a name="ln111">  LogEntryPB(const LogEntryPB&amp; from);</a>
<a name="ln112"> </a>
<a name="ln113">  inline LogEntryPB&amp; operator=(const LogEntryPB&amp; from) {</a>
<a name="ln114">    CopyFrom(from);</a>
<a name="ln115">    return *this;</a>
<a name="ln116">  }</a>
<a name="ln117">  #if LANG_CXX11</a>
<a name="ln118">  LogEntryPB(LogEntryPB&amp;&amp; from) noexcept</a>
<a name="ln119">    : LogEntryPB() {</a>
<a name="ln120">    *this = ::std::move(from);</a>
<a name="ln121">  }</a>
<a name="ln122"> </a>
<a name="ln123">  inline LogEntryPB&amp; operator=(LogEntryPB&amp;&amp; from) noexcept {</a>
<a name="ln124">    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {</a>
<a name="ln125">      if (this != &amp;from) InternalSwap(&amp;from);</a>
<a name="ln126">    } else {</a>
<a name="ln127">      CopyFrom(from);</a>
<a name="ln128">    }</a>
<a name="ln129">    return *this;</a>
<a name="ln130">  }</a>
<a name="ln131">  #endif</a>
<a name="ln132">  inline const ::google::protobuf::UnknownFieldSet&amp; unknown_fields() const {</a>
<a name="ln133">    return _internal_metadata_.unknown_fields();</a>
<a name="ln134">  }</a>
<a name="ln135">  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {</a>
<a name="ln136">    return _internal_metadata_.mutable_unknown_fields();</a>
<a name="ln137">  }</a>
<a name="ln138"> </a>
<a name="ln139">  static const ::google::protobuf::Descriptor* descriptor();</a>
<a name="ln140">  static const LogEntryPB&amp; default_instance();</a>
<a name="ln141"> </a>
<a name="ln142">  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY</a>
<a name="ln143">  static inline const LogEntryPB* internal_default_instance() {</a>
<a name="ln144">    return reinterpret_cast&lt;const LogEntryPB*&gt;(</a>
<a name="ln145">               &amp;_LogEntryPB_default_instance_);</a>
<a name="ln146">  }</a>
<a name="ln147">  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =</a>
<a name="ln148">    0;</a>
<a name="ln149"> </a>
<a name="ln150">  void Swap(LogEntryPB* other);</a>
<a name="ln151">  friend void swap(LogEntryPB&amp; a, LogEntryPB&amp; b) {</a>
<a name="ln152">    a.Swap(&amp;b);</a>
<a name="ln153">  }</a>
<a name="ln154"> </a>
<a name="ln155">  // implements Message ----------------------------------------------</a>
<a name="ln156"> </a>
<a name="ln157">  inline LogEntryPB* New() const PROTOBUF_FINAL { return New(NULL); }</a>
<a name="ln158"> </a>
<a name="ln159">  LogEntryPB* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;</a>
<a name="ln160">  void CopyFrom(const ::google::protobuf::Message&amp; from) PROTOBUF_FINAL;</a>
<a name="ln161">  void MergeFrom(const ::google::protobuf::Message&amp; from) PROTOBUF_FINAL;</a>
<a name="ln162">  void CopyFrom(const LogEntryPB&amp; from);</a>
<a name="ln163">  void MergeFrom(const LogEntryPB&amp; from);</a>
<a name="ln164">  void Clear() PROTOBUF_FINAL;</a>
<a name="ln165">  bool IsInitialized() const PROTOBUF_FINAL;</a>
<a name="ln166"> </a>
<a name="ln167">  size_t ByteSizeLong() const PROTOBUF_FINAL;</a>
<a name="ln168">  bool MergePartialFromCodedStream(</a>
<a name="ln169">      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;</a>
<a name="ln170">  void SerializeWithCachedSizes(</a>
<a name="ln171">      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;</a>
<a name="ln172">  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(</a>
<a name="ln173">      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;</a>
<a name="ln174">  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }</a>
<a name="ln175">  private:</a>
<a name="ln176">  void SharedCtor();</a>
<a name="ln177">  void SharedDtor();</a>
<a name="ln178">  void SetCachedSize(int size) const PROTOBUF_FINAL;</a>
<a name="ln179">  void InternalSwap(LogEntryPB* other);</a>
<a name="ln180">  private:</a>
<a name="ln181">  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {</a>
<a name="ln182">    return NULL;</a>
<a name="ln183">  }</a>
<a name="ln184">  inline void* MaybeArenaPtr() const {</a>
<a name="ln185">    return NULL;</a>
<a name="ln186">  }</a>
<a name="ln187">  public:</a>
<a name="ln188"> </a>
<a name="ln189">  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;</a>
<a name="ln190"> </a>
<a name="ln191">  // nested types ----------------------------------------------------</a>
<a name="ln192"> </a>
<a name="ln193">  // accessors -------------------------------------------------------</a>
<a name="ln194"> </a>
<a name="ln195">  // optional .yb.consensus.ReplicateMsg replicate = 2;</a>
<a name="ln196">  bool has_replicate() const;</a>
<a name="ln197">  void clear_replicate();</a>
<a name="ln198">  static const int kReplicateFieldNumber = 2;</a>
<a name="ln199">  const ::yb::consensus::ReplicateMsg&amp; replicate() const;</a>
<a name="ln200">  ::yb::consensus::ReplicateMsg* release_replicate();</a>
<a name="ln201">  ::yb::consensus::ReplicateMsg* mutable_replicate();</a>
<a name="ln202">  void set_allocated_replicate(::yb::consensus::ReplicateMsg* replicate);</a>
<a name="ln203"> </a>
<a name="ln204">  // required .yb.log.LogEntryTypePB type = 1;</a>
<a name="ln205">  bool has_type() const;</a>
<a name="ln206">  void clear_type();</a>
<a name="ln207">  static const int kTypeFieldNumber = 1;</a>
<a name="ln208">  ::yb::log::LogEntryTypePB type() const;</a>
<a name="ln209">  void set_type(::yb::log::LogEntryTypePB value);</a>
<a name="ln210"> </a>
<a name="ln211">  // @@protoc_insertion_point(class_scope:yb.log.LogEntryPB)</a>
<a name="ln212"> private:</a>
<a name="ln213">  void set_has_type();</a>
<a name="ln214">  void clear_has_type();</a>
<a name="ln215">  void set_has_replicate();</a>
<a name="ln216">  void clear_has_replicate();</a>
<a name="ln217"> </a>
<a name="ln218">  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;</a>
<a name="ln219">  ::google::protobuf::internal::HasBits&lt;1&gt; _has_bits_;</a>
<a name="ln220">  mutable int _cached_size_;</a>
<a name="ln221">  ::yb::consensus::ReplicateMsg* replicate_;</a>
<a name="ln222">  int type_;</a>
<a name="ln223">  friend struct ::protobuf_yb_2fconsensus_2flog_2eproto::TableStruct;</a>
<a name="ln224">  friend void ::protobuf_yb_2fconsensus_2flog_2eproto::InitDefaultsLogEntryPBImpl();</a>
<a name="ln225">};</a>
<a name="ln226">// -------------------------------------------------------------------</a>
<a name="ln227"> </a>
<a name="ln228">class LogEntryBatchPB : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:yb.log.LogEntryBatchPB) */ {</a>
<a name="ln229"> public:</a>
<a name="ln230">  LogEntryBatchPB();</a>
<a name="ln231">  virtual ~LogEntryBatchPB();</a>
<a name="ln232"> </a>
<a name="ln233">  LogEntryBatchPB(const LogEntryBatchPB&amp; from);</a>
<a name="ln234"> </a>
<a name="ln235">  inline LogEntryBatchPB&amp; operator=(const LogEntryBatchPB&amp; from) {</a>
<a name="ln236">    CopyFrom(from);</a>
<a name="ln237">    return *this;</a>
<a name="ln238">  }</a>
<a name="ln239">  #if LANG_CXX11</a>
<a name="ln240">  LogEntryBatchPB(LogEntryBatchPB&amp;&amp; from) noexcept</a>
<a name="ln241">    : LogEntryBatchPB() {</a>
<a name="ln242">    *this = ::std::move(from);</a>
<a name="ln243">  }</a>
<a name="ln244"> </a>
<a name="ln245">  inline LogEntryBatchPB&amp; operator=(LogEntryBatchPB&amp;&amp; from) noexcept {</a>
<a name="ln246">    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {</a>
<a name="ln247">      if (this != &amp;from) InternalSwap(&amp;from);</a>
<a name="ln248">    } else {</a>
<a name="ln249">      CopyFrom(from);</a>
<a name="ln250">    }</a>
<a name="ln251">    return *this;</a>
<a name="ln252">  }</a>
<a name="ln253">  #endif</a>
<a name="ln254">  inline const ::google::protobuf::UnknownFieldSet&amp; unknown_fields() const {</a>
<a name="ln255">    return _internal_metadata_.unknown_fields();</a>
<a name="ln256">  }</a>
<a name="ln257">  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {</a>
<a name="ln258">    return _internal_metadata_.mutable_unknown_fields();</a>
<a name="ln259">  }</a>
<a name="ln260"> </a>
<a name="ln261">  static const ::google::protobuf::Descriptor* descriptor();</a>
<a name="ln262">  static const LogEntryBatchPB&amp; default_instance();</a>
<a name="ln263"> </a>
<a name="ln264">  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY</a>
<a name="ln265">  static inline const LogEntryBatchPB* internal_default_instance() {</a>
<a name="ln266">    return reinterpret_cast&lt;const LogEntryBatchPB*&gt;(</a>
<a name="ln267">               &amp;_LogEntryBatchPB_default_instance_);</a>
<a name="ln268">  }</a>
<a name="ln269">  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =</a>
<a name="ln270">    1;</a>
<a name="ln271"> </a>
<a name="ln272">  void Swap(LogEntryBatchPB* other);</a>
<a name="ln273">  friend void swap(LogEntryBatchPB&amp; a, LogEntryBatchPB&amp; b) {</a>
<a name="ln274">    a.Swap(&amp;b);</a>
<a name="ln275">  }</a>
<a name="ln276"> </a>
<a name="ln277">  // implements Message ----------------------------------------------</a>
<a name="ln278"> </a>
<a name="ln279">  inline LogEntryBatchPB* New() const PROTOBUF_FINAL { return New(NULL); }</a>
<a name="ln280"> </a>
<a name="ln281">  LogEntryBatchPB* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;</a>
<a name="ln282">  void CopyFrom(const ::google::protobuf::Message&amp; from) PROTOBUF_FINAL;</a>
<a name="ln283">  void MergeFrom(const ::google::protobuf::Message&amp; from) PROTOBUF_FINAL;</a>
<a name="ln284">  void CopyFrom(const LogEntryBatchPB&amp; from);</a>
<a name="ln285">  void MergeFrom(const LogEntryBatchPB&amp; from);</a>
<a name="ln286">  void Clear() PROTOBUF_FINAL;</a>
<a name="ln287">  bool IsInitialized() const PROTOBUF_FINAL;</a>
<a name="ln288"> </a>
<a name="ln289">  size_t ByteSizeLong() const PROTOBUF_FINAL;</a>
<a name="ln290">  bool MergePartialFromCodedStream(</a>
<a name="ln291">      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;</a>
<a name="ln292">  void SerializeWithCachedSizes(</a>
<a name="ln293">      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;</a>
<a name="ln294">  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(</a>
<a name="ln295">      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;</a>
<a name="ln296">  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }</a>
<a name="ln297">  private:</a>
<a name="ln298">  void SharedCtor();</a>
<a name="ln299">  void SharedDtor();</a>
<a name="ln300">  void SetCachedSize(int size) const PROTOBUF_FINAL;</a>
<a name="ln301">  void InternalSwap(LogEntryBatchPB* other);</a>
<a name="ln302">  private:</a>
<a name="ln303">  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {</a>
<a name="ln304">    return NULL;</a>
<a name="ln305">  }</a>
<a name="ln306">  inline void* MaybeArenaPtr() const {</a>
<a name="ln307">    return NULL;</a>
<a name="ln308">  }</a>
<a name="ln309">  public:</a>
<a name="ln310"> </a>
<a name="ln311">  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;</a>
<a name="ln312"> </a>
<a name="ln313">  // nested types ----------------------------------------------------</a>
<a name="ln314"> </a>
<a name="ln315">  // accessors -------------------------------------------------------</a>
<a name="ln316"> </a>
<a name="ln317">  // repeated .yb.log.LogEntryPB entry = 1;</a>
<a name="ln318">  int entry_size() const;</a>
<a name="ln319">  void clear_entry();</a>
<a name="ln320">  static const int kEntryFieldNumber = 1;</a>
<a name="ln321">  const ::yb::log::LogEntryPB&amp; entry(int index) const;</a>
<a name="ln322">  ::yb::log::LogEntryPB* mutable_entry(int index);</a>
<a name="ln323">  ::yb::log::LogEntryPB* add_entry();</a>
<a name="ln324">  ::google::protobuf::RepeatedPtrField&lt; ::yb::log::LogEntryPB &gt;*</a>
<a name="ln325">      mutable_entry();</a>
<a name="ln326">  const ::google::protobuf::RepeatedPtrField&lt; ::yb::log::LogEntryPB &gt;&amp;</a>
<a name="ln327">      entry() const;</a>
<a name="ln328"> </a>
<a name="ln329">  // optional .yb.OpIdPB committed_op_id = 2;</a>
<a name="ln330">  bool has_committed_op_id() const;</a>
<a name="ln331">  void clear_committed_op_id();</a>
<a name="ln332">  static const int kCommittedOpIdFieldNumber = 2;</a>
<a name="ln333">  const ::yb::OpIdPB&amp; committed_op_id() const;</a>
<a name="ln334">  ::yb::OpIdPB* release_committed_op_id();</a>
<a name="ln335">  ::yb::OpIdPB* mutable_committed_op_id();</a>
<a name="ln336">  void set_allocated_committed_op_id(::yb::OpIdPB* committed_op_id);</a>
<a name="ln337"> </a>
<a name="ln338">  // optional uint64 mono_time = 3;</a>
<a name="ln339">  bool has_mono_time() const;</a>
<a name="ln340">  void clear_mono_time();</a>
<a name="ln341">  static const int kMonoTimeFieldNumber = 3;</a>
<a name="ln342">  ::google::protobuf::uint64 mono_time() const;</a>
<a name="ln343">  void set_mono_time(::google::protobuf::uint64 value);</a>
<a name="ln344"> </a>
<a name="ln345">  // @@protoc_insertion_point(class_scope:yb.log.LogEntryBatchPB)</a>
<a name="ln346"> private:</a>
<a name="ln347">  void set_has_committed_op_id();</a>
<a name="ln348">  void clear_has_committed_op_id();</a>
<a name="ln349">  void set_has_mono_time();</a>
<a name="ln350">  void clear_has_mono_time();</a>
<a name="ln351"> </a>
<a name="ln352">  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;</a>
<a name="ln353">  ::google::protobuf::internal::HasBits&lt;1&gt; _has_bits_;</a>
<a name="ln354">  mutable int _cached_size_;</a>
<a name="ln355">  ::google::protobuf::RepeatedPtrField&lt; ::yb::log::LogEntryPB &gt; entry_;</a>
<a name="ln356">  ::yb::OpIdPB* committed_op_id_;</a>
<a name="ln357">  ::google::protobuf::uint64 mono_time_;</a>
<a name="ln358">  friend struct ::protobuf_yb_2fconsensus_2flog_2eproto::TableStruct;</a>
<a name="ln359">  friend void ::protobuf_yb_2fconsensus_2flog_2eproto::InitDefaultsLogEntryBatchPBImpl();</a>
<a name="ln360">};</a>
<a name="ln361">// -------------------------------------------------------------------</a>
<a name="ln362"> </a>
<a name="ln363">class LogSegmentHeaderPB : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:yb.log.LogSegmentHeaderPB) */ {</a>
<a name="ln364"> public:</a>
<a name="ln365">  LogSegmentHeaderPB();</a>
<a name="ln366">  virtual ~LogSegmentHeaderPB();</a>
<a name="ln367"> </a>
<a name="ln368">  LogSegmentHeaderPB(const LogSegmentHeaderPB&amp; from);</a>
<a name="ln369"> </a>
<a name="ln370">  inline LogSegmentHeaderPB&amp; operator=(const LogSegmentHeaderPB&amp; from) {</a>
<a name="ln371">    CopyFrom(from);</a>
<a name="ln372">    return *this;</a>
<a name="ln373">  }</a>
<a name="ln374">  #if LANG_CXX11</a>
<a name="ln375">  LogSegmentHeaderPB(LogSegmentHeaderPB&amp;&amp; from) noexcept</a>
<a name="ln376">    : LogSegmentHeaderPB() {</a>
<a name="ln377">    *this = ::std::move(from);</a>
<a name="ln378">  }</a>
<a name="ln379"> </a>
<a name="ln380">  inline LogSegmentHeaderPB&amp; operator=(LogSegmentHeaderPB&amp;&amp; from) noexcept {</a>
<a name="ln381">    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {</a>
<a name="ln382">      if (this != &amp;from) InternalSwap(&amp;from);</a>
<a name="ln383">    } else {</a>
<a name="ln384">      CopyFrom(from);</a>
<a name="ln385">    }</a>
<a name="ln386">    return *this;</a>
<a name="ln387">  }</a>
<a name="ln388">  #endif</a>
<a name="ln389">  inline const ::google::protobuf::UnknownFieldSet&amp; unknown_fields() const {</a>
<a name="ln390">    return _internal_metadata_.unknown_fields();</a>
<a name="ln391">  }</a>
<a name="ln392">  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {</a>
<a name="ln393">    return _internal_metadata_.mutable_unknown_fields();</a>
<a name="ln394">  }</a>
<a name="ln395"> </a>
<a name="ln396">  static const ::google::protobuf::Descriptor* descriptor();</a>
<a name="ln397">  static const LogSegmentHeaderPB&amp; default_instance();</a>
<a name="ln398"> </a>
<a name="ln399">  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY</a>
<a name="ln400">  static inline const LogSegmentHeaderPB* internal_default_instance() {</a>
<a name="ln401">    return reinterpret_cast&lt;const LogSegmentHeaderPB*&gt;(</a>
<a name="ln402">               &amp;_LogSegmentHeaderPB_default_instance_);</a>
<a name="ln403">  }</a>
<a name="ln404">  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =</a>
<a name="ln405">    2;</a>
<a name="ln406"> </a>
<a name="ln407">  void Swap(LogSegmentHeaderPB* other);</a>
<a name="ln408">  friend void swap(LogSegmentHeaderPB&amp; a, LogSegmentHeaderPB&amp; b) {</a>
<a name="ln409">    a.Swap(&amp;b);</a>
<a name="ln410">  }</a>
<a name="ln411"> </a>
<a name="ln412">  // implements Message ----------------------------------------------</a>
<a name="ln413"> </a>
<a name="ln414">  inline LogSegmentHeaderPB* New() const PROTOBUF_FINAL { return New(NULL); }</a>
<a name="ln415"> </a>
<a name="ln416">  LogSegmentHeaderPB* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;</a>
<a name="ln417">  void CopyFrom(const ::google::protobuf::Message&amp; from) PROTOBUF_FINAL;</a>
<a name="ln418">  void MergeFrom(const ::google::protobuf::Message&amp; from) PROTOBUF_FINAL;</a>
<a name="ln419">  void CopyFrom(const LogSegmentHeaderPB&amp; from);</a>
<a name="ln420">  void MergeFrom(const LogSegmentHeaderPB&amp; from);</a>
<a name="ln421">  void Clear() PROTOBUF_FINAL;</a>
<a name="ln422">  bool IsInitialized() const PROTOBUF_FINAL;</a>
<a name="ln423"> </a>
<a name="ln424">  size_t ByteSizeLong() const PROTOBUF_FINAL;</a>
<a name="ln425">  bool MergePartialFromCodedStream(</a>
<a name="ln426">      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;</a>
<a name="ln427">  void SerializeWithCachedSizes(</a>
<a name="ln428">      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;</a>
<a name="ln429">  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(</a>
<a name="ln430">      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;</a>
<a name="ln431">  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }</a>
<a name="ln432">  private:</a>
<a name="ln433">  void SharedCtor();</a>
<a name="ln434">  void SharedDtor();</a>
<a name="ln435">  void SetCachedSize(int size) const PROTOBUF_FINAL;</a>
<a name="ln436">  void InternalSwap(LogSegmentHeaderPB* other);</a>
<a name="ln437">  private:</a>
<a name="ln438">  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {</a>
<a name="ln439">    return NULL;</a>
<a name="ln440">  }</a>
<a name="ln441">  inline void* MaybeArenaPtr() const {</a>
<a name="ln442">    return NULL;</a>
<a name="ln443">  }</a>
<a name="ln444">  public:</a>
<a name="ln445"> </a>
<a name="ln446">  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;</a>
<a name="ln447"> </a>
<a name="ln448">  // nested types ----------------------------------------------------</a>
<a name="ln449"> </a>
<a name="ln450">  // accessors -------------------------------------------------------</a>
<a name="ln451"> </a>
<a name="ln452">  // required bytes tablet_id = 5;</a>
<a name="ln453">  bool has_tablet_id() const;</a>
<a name="ln454">  void clear_tablet_id();</a>
<a name="ln455">  static const int kTabletIdFieldNumber = 5;</a>
<a name="ln456">  const ::std::string&amp; tablet_id() const;</a>
<a name="ln457">  void set_tablet_id(const ::std::string&amp; value);</a>
<a name="ln458">  #if LANG_CXX11</a>
<a name="ln459">  void set_tablet_id(::std::string&amp;&amp; value);</a>
<a name="ln460">  #endif</a>
<a name="ln461">  void set_tablet_id(const char* value);</a>
<a name="ln462">  void set_tablet_id(const void* value, size_t size);</a>
<a name="ln463">  ::std::string* mutable_tablet_id();</a>
<a name="ln464">  ::std::string* release_tablet_id();</a>
<a name="ln465">  void set_allocated_tablet_id(::std::string* tablet_id);</a>
<a name="ln466"> </a>
<a name="ln467">  // required .yb.SchemaPB schema = 7;</a>
<a name="ln468">  bool has_schema() const;</a>
<a name="ln469">  void clear_schema();</a>
<a name="ln470">  static const int kSchemaFieldNumber = 7;</a>
<a name="ln471">  const ::yb::SchemaPB&amp; schema() const;</a>
<a name="ln472">  ::yb::SchemaPB* release_schema();</a>
<a name="ln473">  ::yb::SchemaPB* mutable_schema();</a>
<a name="ln474">  void set_allocated_schema(::yb::SchemaPB* schema);</a>
<a name="ln475"> </a>
<a name="ln476">  // required uint32 major_version = 1;</a>
<a name="ln477">  bool has_major_version() const;</a>
<a name="ln478">  void clear_major_version();</a>
<a name="ln479">  static const int kMajorVersionFieldNumber = 1;</a>
<a name="ln480">  ::google::protobuf::uint32 major_version() const;</a>
<a name="ln481">  void set_major_version(::google::protobuf::uint32 value);</a>
<a name="ln482"> </a>
<a name="ln483">  // required uint32 minor_version = 2;</a>
<a name="ln484">  bool has_minor_version() const;</a>
<a name="ln485">  void clear_minor_version();</a>
<a name="ln486">  static const int kMinorVersionFieldNumber = 2;</a>
<a name="ln487">  ::google::protobuf::uint32 minor_version() const;</a>
<a name="ln488">  void set_minor_version(::google::protobuf::uint32 value);</a>
<a name="ln489"> </a>
<a name="ln490">  // required uint64 sequence_number = 6;</a>
<a name="ln491">  bool has_sequence_number() const;</a>
<a name="ln492">  void clear_sequence_number();</a>
<a name="ln493">  static const int kSequenceNumberFieldNumber = 6;</a>
<a name="ln494">  ::google::protobuf::uint64 sequence_number() const;</a>
<a name="ln495">  void set_sequence_number(::google::protobuf::uint64 value);</a>
<a name="ln496"> </a>
<a name="ln497">  // optional uint32 schema_version = 8;</a>
<a name="ln498">  bool has_schema_version() const;</a>
<a name="ln499">  void clear_schema_version();</a>
<a name="ln500">  static const int kSchemaVersionFieldNumber = 8;</a>
<a name="ln501">  ::google::protobuf::uint32 schema_version() const;</a>
<a name="ln502">  void set_schema_version(::google::protobuf::uint32 value);</a>
<a name="ln503"> </a>
<a name="ln504">  // @@protoc_insertion_point(class_scope:yb.log.LogSegmentHeaderPB)</a>
<a name="ln505"> private:</a>
<a name="ln506">  void set_has_major_version();</a>
<a name="ln507">  void clear_has_major_version();</a>
<a name="ln508">  void set_has_minor_version();</a>
<a name="ln509">  void clear_has_minor_version();</a>
<a name="ln510">  void set_has_tablet_id();</a>
<a name="ln511">  void clear_has_tablet_id();</a>
<a name="ln512">  void set_has_sequence_number();</a>
<a name="ln513">  void clear_has_sequence_number();</a>
<a name="ln514">  void set_has_schema();</a>
<a name="ln515">  void clear_has_schema();</a>
<a name="ln516">  void set_has_schema_version();</a>
<a name="ln517">  void clear_has_schema_version();</a>
<a name="ln518"> </a>
<a name="ln519">  // helper for ByteSizeLong()</a>
<a name="ln520">  size_t RequiredFieldsByteSizeFallback() const;</a>
<a name="ln521"> </a>
<a name="ln522">  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;</a>
<a name="ln523">  ::google::protobuf::internal::HasBits&lt;1&gt; _has_bits_;</a>
<a name="ln524">  mutable int _cached_size_;</a>
<a name="ln525">  ::google::protobuf::internal::ArenaStringPtr tablet_id_;</a>
<a name="ln526">  ::yb::SchemaPB* schema_;</a>
<a name="ln527">  ::google::protobuf::uint32 major_version_;</a>
<a name="ln528">  ::google::protobuf::uint32 minor_version_;</a>
<a name="ln529">  ::google::protobuf::uint64 sequence_number_;</a>
<a name="ln530">  ::google::protobuf::uint32 schema_version_;</a>
<a name="ln531">  friend struct ::protobuf_yb_2fconsensus_2flog_2eproto::TableStruct;</a>
<a name="ln532">  friend void ::protobuf_yb_2fconsensus_2flog_2eproto::InitDefaultsLogSegmentHeaderPBImpl();</a>
<a name="ln533">};</a>
<a name="ln534">// -------------------------------------------------------------------</a>
<a name="ln535"> </a>
<a name="ln536">class LogSegmentFooterPB : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:yb.log.LogSegmentFooterPB) */ {</a>
<a name="ln537"> public:</a>
<a name="ln538">  LogSegmentFooterPB();</a>
<a name="ln539">  virtual ~LogSegmentFooterPB();</a>
<a name="ln540"> </a>
<a name="ln541">  LogSegmentFooterPB(const LogSegmentFooterPB&amp; from);</a>
<a name="ln542"> </a>
<a name="ln543">  inline LogSegmentFooterPB&amp; operator=(const LogSegmentFooterPB&amp; from) {</a>
<a name="ln544">    CopyFrom(from);</a>
<a name="ln545">    return *this;</a>
<a name="ln546">  }</a>
<a name="ln547">  #if LANG_CXX11</a>
<a name="ln548">  LogSegmentFooterPB(LogSegmentFooterPB&amp;&amp; from) noexcept</a>
<a name="ln549">    : LogSegmentFooterPB() {</a>
<a name="ln550">    *this = ::std::move(from);</a>
<a name="ln551">  }</a>
<a name="ln552"> </a>
<a name="ln553">  inline LogSegmentFooterPB&amp; operator=(LogSegmentFooterPB&amp;&amp; from) noexcept {</a>
<a name="ln554">    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {</a>
<a name="ln555">      if (this != &amp;from) InternalSwap(&amp;from);</a>
<a name="ln556">    } else {</a>
<a name="ln557">      CopyFrom(from);</a>
<a name="ln558">    }</a>
<a name="ln559">    return *this;</a>
<a name="ln560">  }</a>
<a name="ln561">  #endif</a>
<a name="ln562">  inline const ::google::protobuf::UnknownFieldSet&amp; unknown_fields() const {</a>
<a name="ln563">    return _internal_metadata_.unknown_fields();</a>
<a name="ln564">  }</a>
<a name="ln565">  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {</a>
<a name="ln566">    return _internal_metadata_.mutable_unknown_fields();</a>
<a name="ln567">  }</a>
<a name="ln568"> </a>
<a name="ln569">  static const ::google::protobuf::Descriptor* descriptor();</a>
<a name="ln570">  static const LogSegmentFooterPB&amp; default_instance();</a>
<a name="ln571"> </a>
<a name="ln572">  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY</a>
<a name="ln573">  static inline const LogSegmentFooterPB* internal_default_instance() {</a>
<a name="ln574">    return reinterpret_cast&lt;const LogSegmentFooterPB*&gt;(</a>
<a name="ln575">               &amp;_LogSegmentFooterPB_default_instance_);</a>
<a name="ln576">  }</a>
<a name="ln577">  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =</a>
<a name="ln578">    3;</a>
<a name="ln579"> </a>
<a name="ln580">  void Swap(LogSegmentFooterPB* other);</a>
<a name="ln581">  friend void swap(LogSegmentFooterPB&amp; a, LogSegmentFooterPB&amp; b) {</a>
<a name="ln582">    a.Swap(&amp;b);</a>
<a name="ln583">  }</a>
<a name="ln584"> </a>
<a name="ln585">  // implements Message ----------------------------------------------</a>
<a name="ln586"> </a>
<a name="ln587">  inline LogSegmentFooterPB* New() const PROTOBUF_FINAL { return New(NULL); }</a>
<a name="ln588"> </a>
<a name="ln589">  LogSegmentFooterPB* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;</a>
<a name="ln590">  void CopyFrom(const ::google::protobuf::Message&amp; from) PROTOBUF_FINAL;</a>
<a name="ln591">  void MergeFrom(const ::google::protobuf::Message&amp; from) PROTOBUF_FINAL;</a>
<a name="ln592">  void CopyFrom(const LogSegmentFooterPB&amp; from);</a>
<a name="ln593">  void MergeFrom(const LogSegmentFooterPB&amp; from);</a>
<a name="ln594">  void Clear() PROTOBUF_FINAL;</a>
<a name="ln595">  bool IsInitialized() const PROTOBUF_FINAL;</a>
<a name="ln596"> </a>
<a name="ln597">  size_t ByteSizeLong() const PROTOBUF_FINAL;</a>
<a name="ln598">  bool MergePartialFromCodedStream(</a>
<a name="ln599">      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;</a>
<a name="ln600">  void SerializeWithCachedSizes(</a>
<a name="ln601">      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;</a>
<a name="ln602">  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(</a>
<a name="ln603">      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;</a>
<a name="ln604">  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }</a>
<a name="ln605">  private:</a>
<a name="ln606">  void SharedCtor();</a>
<a name="ln607">  void SharedDtor();</a>
<a name="ln608">  void SetCachedSize(int size) const PROTOBUF_FINAL;</a>
<a name="ln609">  void InternalSwap(LogSegmentFooterPB* other);</a>
<a name="ln610">  private:</a>
<a name="ln611">  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {</a>
<a name="ln612">    return NULL;</a>
<a name="ln613">  }</a>
<a name="ln614">  inline void* MaybeArenaPtr() const {</a>
<a name="ln615">    return NULL;</a>
<a name="ln616">  }</a>
<a name="ln617">  public:</a>
<a name="ln618"> </a>
<a name="ln619">  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;</a>
<a name="ln620"> </a>
<a name="ln621">  // nested types ----------------------------------------------------</a>
<a name="ln622"> </a>
<a name="ln623">  // accessors -------------------------------------------------------</a>
<a name="ln624"> </a>
<a name="ln625">  // required int64 num_entries = 1;</a>
<a name="ln626">  bool has_num_entries() const;</a>
<a name="ln627">  void clear_num_entries();</a>
<a name="ln628">  static const int kNumEntriesFieldNumber = 1;</a>
<a name="ln629">  ::google::protobuf::int64 num_entries() const;</a>
<a name="ln630">  void set_num_entries(::google::protobuf::int64 value);</a>
<a name="ln631"> </a>
<a name="ln632">  // optional int64 close_timestamp_micros = 4;</a>
<a name="ln633">  bool has_close_timestamp_micros() const;</a>
<a name="ln634">  void clear_close_timestamp_micros();</a>
<a name="ln635">  static const int kCloseTimestampMicrosFieldNumber = 4;</a>
<a name="ln636">  ::google::protobuf::int64 close_timestamp_micros() const;</a>
<a name="ln637">  void set_close_timestamp_micros(::google::protobuf::int64 value);</a>
<a name="ln638"> </a>
<a name="ln639">  // optional int64 min_replicate_index = 2 [default = -1];</a>
<a name="ln640">  bool has_min_replicate_index() const;</a>
<a name="ln641">  void clear_min_replicate_index();</a>
<a name="ln642">  static const int kMinReplicateIndexFieldNumber = 2;</a>
<a name="ln643">  ::google::protobuf::int64 min_replicate_index() const;</a>
<a name="ln644">  void set_min_replicate_index(::google::protobuf::int64 value);</a>
<a name="ln645"> </a>
<a name="ln646">  // optional int64 max_replicate_index = 3 [default = -1];</a>
<a name="ln647">  bool has_max_replicate_index() const;</a>
<a name="ln648">  void clear_max_replicate_index();</a>
<a name="ln649">  static const int kMaxReplicateIndexFieldNumber = 3;</a>
<a name="ln650">  ::google::protobuf::int64 max_replicate_index() const;</a>
<a name="ln651">  void set_max_replicate_index(::google::protobuf::int64 value);</a>
<a name="ln652"> </a>
<a name="ln653">  // @@protoc_insertion_point(class_scope:yb.log.LogSegmentFooterPB)</a>
<a name="ln654"> private:</a>
<a name="ln655">  void set_has_num_entries();</a>
<a name="ln656">  void clear_has_num_entries();</a>
<a name="ln657">  void set_has_min_replicate_index();</a>
<a name="ln658">  void clear_has_min_replicate_index();</a>
<a name="ln659">  void set_has_max_replicate_index();</a>
<a name="ln660">  void clear_has_max_replicate_index();</a>
<a name="ln661">  void set_has_close_timestamp_micros();</a>
<a name="ln662">  void clear_has_close_timestamp_micros();</a>
<a name="ln663"> </a>
<a name="ln664">  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;</a>
<a name="ln665">  ::google::protobuf::internal::HasBits&lt;1&gt; _has_bits_;</a>
<a name="ln666">  mutable int _cached_size_;</a>
<a name="ln667">  ::google::protobuf::int64 num_entries_;</a>
<a name="ln668">  ::google::protobuf::int64 close_timestamp_micros_;</a>
<a name="ln669">  ::google::protobuf::int64 min_replicate_index_;</a>
<a name="ln670">  ::google::protobuf::int64 max_replicate_index_;</a>
<a name="ln671">  friend struct ::protobuf_yb_2fconsensus_2flog_2eproto::TableStruct;</a>
<a name="ln672">  friend void ::protobuf_yb_2fconsensus_2flog_2eproto::InitDefaultsLogSegmentFooterPBImpl();</a>
<a name="ln673">};</a>
<a name="ln674">// ===================================================================</a>
<a name="ln675"> </a>
<a name="ln676"> </a>
<a name="ln677">// ===================================================================</a>
<a name="ln678"> </a>
<a name="ln679">#ifdef __GNUC__</a>
<a name="ln680">  #pragma GCC diagnostic push</a>
<a name="ln681">  #pragma GCC diagnostic ignored &quot;-Wstrict-aliasing&quot;</a>
<a name="ln682">#endif  // __GNUC__</a>
<a name="ln683">// LogEntryPB</a>
<a name="ln684"> </a>
<a name="ln685">// required .yb.log.LogEntryTypePB type = 1;</a>
<a name="ln686">inline bool LogEntryPB::has_type() const {</a>
<a name="ln687">  return (_has_bits_[0] &amp; 0x00000002u) != 0;</a>
<a name="ln688">}</a>
<a name="ln689">inline void LogEntryPB::set_has_type() {</a>
<a name="ln690">  _has_bits_[0] |= 0x00000002u;</a>
<a name="ln691">}</a>
<a name="ln692">inline void LogEntryPB::clear_has_type() {</a>
<a name="ln693">  _has_bits_[0] &amp;= ~0x00000002u;</a>
<a name="ln694">}</a>
<a name="ln695">inline void LogEntryPB::clear_type() {</a>
<a name="ln696">  type_ = 0;</a>
<a name="ln697">  clear_has_type();</a>
<a name="ln698">}</a>
<a name="ln699">inline ::yb::log::LogEntryTypePB LogEntryPB::type() const {</a>
<a name="ln700">  // @@protoc_insertion_point(field_get:yb.log.LogEntryPB.type)</a>
<a name="ln701">  return static_cast&lt; ::yb::log::LogEntryTypePB &gt;(type_);</a>
<a name="ln702">}</a>
<a name="ln703">inline void LogEntryPB::set_type(::yb::log::LogEntryTypePB value) {</a>
<a name="ln704">  assert(::yb::log::LogEntryTypePB_IsValid(value));</a>
<a name="ln705">  set_has_type();</a>
<a name="ln706">  type_ = value;</a>
<a name="ln707">  // @@protoc_insertion_point(field_set:yb.log.LogEntryPB.type)</a>
<a name="ln708">}</a>
<a name="ln709"> </a>
<a name="ln710">// optional .yb.consensus.ReplicateMsg replicate = 2;</a>
<a name="ln711">inline bool LogEntryPB::has_replicate() const {</a>
<a name="ln712">  return (_has_bits_[0] &amp; 0x00000001u) != 0;</a>
<a name="ln713">}</a>
<a name="ln714">inline void LogEntryPB::set_has_replicate() {</a>
<a name="ln715">  _has_bits_[0] |= 0x00000001u;</a>
<a name="ln716">}</a>
<a name="ln717">inline void LogEntryPB::clear_has_replicate() {</a>
<a name="ln718">  _has_bits_[0] &amp;= ~0x00000001u;</a>
<a name="ln719">}</a>
<a name="ln720">inline const ::yb::consensus::ReplicateMsg&amp; LogEntryPB::replicate() const {</a>
<a name="ln721">  const ::yb::consensus::ReplicateMsg* p = replicate_;</a>
<a name="ln722">  // @@protoc_insertion_point(field_get:yb.log.LogEntryPB.replicate)</a>
<a name="ln723">  return p != NULL ? *p : *reinterpret_cast&lt;const ::yb::consensus::ReplicateMsg*&gt;(</a>
<a name="ln724">      &amp;::yb::consensus::_ReplicateMsg_default_instance_);</a>
<a name="ln725">}</a>
<a name="ln726">inline ::yb::consensus::ReplicateMsg* LogEntryPB::release_replicate() {</a>
<a name="ln727">  // @@protoc_insertion_point(field_release:yb.log.LogEntryPB.replicate)</a>
<a name="ln728">  clear_has_replicate();</a>
<a name="ln729">  ::yb::consensus::ReplicateMsg* temp = replicate_;</a>
<a name="ln730">  replicate_ = NULL;</a>
<a name="ln731">  return temp;</a>
<a name="ln732">}</a>
<a name="ln733">inline ::yb::consensus::ReplicateMsg* LogEntryPB::mutable_replicate() {</a>
<a name="ln734">  set_has_replicate();</a>
<a name="ln735">  if (replicate_ == NULL) {</a>
<a name="ln736">    replicate_ = new ::yb::consensus::ReplicateMsg;</a>
<a name="ln737">  }</a>
<a name="ln738">  // @@protoc_insertion_point(field_mutable:yb.log.LogEntryPB.replicate)</a>
<a name="ln739">  return replicate_;</a>
<a name="ln740">}</a>
<a name="ln741">inline void LogEntryPB::set_allocated_replicate(::yb::consensus::ReplicateMsg* replicate) {</a>
<a name="ln742">  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();</a>
<a name="ln743">  if (message_arena == NULL) {</a>
<a name="ln744">    delete reinterpret_cast&lt; ::google::protobuf::MessageLite*&gt;(replicate_);</a>
<a name="ln745">  }</a>
<a name="ln746">  if (replicate) {</a>
<a name="ln747">    ::google::protobuf::Arena* submessage_arena = NULL;</a>
<a name="ln748">    if (message_arena != submessage_arena) {</a>
<a name="ln749">      replicate = ::google::protobuf::internal::GetOwnedMessage(</a>
<a name="ln750">          message_arena, replicate, submessage_arena);</a>
<a name="ln751">    }</a>
<a name="ln752">    set_has_replicate();</a>
<a name="ln753">  } else {</a>
<a name="ln754">    clear_has_replicate();</a>
<a name="ln755">  }</a>
<a name="ln756">  replicate_ = replicate;</a>
<a name="ln757">  // @@protoc_insertion_point(field_set_allocated:yb.log.LogEntryPB.replicate)</a>
<a name="ln758">}</a>
<a name="ln759"> </a>
<a name="ln760">// -------------------------------------------------------------------</a>
<a name="ln761"> </a>
<a name="ln762">// LogEntryBatchPB</a>
<a name="ln763"> </a>
<a name="ln764">// repeated .yb.log.LogEntryPB entry = 1;</a>
<a name="ln765">inline int LogEntryBatchPB::entry_size() const {</a>
<a name="ln766">  return entry_.size();</a>
<a name="ln767">}</a>
<a name="ln768">inline void LogEntryBatchPB::clear_entry() {</a>
<a name="ln769">  entry_.Clear();</a>
<a name="ln770">}</a>
<a name="ln771">inline const ::yb::log::LogEntryPB&amp; LogEntryBatchPB::entry(int index) const {</a>
<a name="ln772">  // @@protoc_insertion_point(field_get:yb.log.LogEntryBatchPB.entry)</a>
<a name="ln773">  return entry_.Get(index);</a>
<a name="ln774">}</a>
<a name="ln775">inline ::yb::log::LogEntryPB* LogEntryBatchPB::mutable_entry(int index) {</a>
<a name="ln776">  // @@protoc_insertion_point(field_mutable:yb.log.LogEntryBatchPB.entry)</a>
<a name="ln777">  return entry_.Mutable(index);</a>
<a name="ln778">}</a>
<a name="ln779">inline ::yb::log::LogEntryPB* LogEntryBatchPB::add_entry() {</a>
<a name="ln780">  // @@protoc_insertion_point(field_add:yb.log.LogEntryBatchPB.entry)</a>
<a name="ln781">  return entry_.Add();</a>
<a name="ln782">}</a>
<a name="ln783">inline ::google::protobuf::RepeatedPtrField&lt; ::yb::log::LogEntryPB &gt;*</a>
<a name="ln784">LogEntryBatchPB::mutable_entry() {</a>
<a name="ln785">  // @@protoc_insertion_point(field_mutable_list:yb.log.LogEntryBatchPB.entry)</a>
<a name="ln786">  return &amp;entry_;</a>
<a name="ln787">}</a>
<a name="ln788">inline const ::google::protobuf::RepeatedPtrField&lt; ::yb::log::LogEntryPB &gt;&amp;</a>
<a name="ln789">LogEntryBatchPB::entry() const {</a>
<a name="ln790">  // @@protoc_insertion_point(field_list:yb.log.LogEntryBatchPB.entry)</a>
<a name="ln791">  return entry_;</a>
<a name="ln792">}</a>
<a name="ln793"> </a>
<a name="ln794">// optional .yb.OpIdPB committed_op_id = 2;</a>
<a name="ln795">inline bool LogEntryBatchPB::has_committed_op_id() const {</a>
<a name="ln796">  return (_has_bits_[0] &amp; 0x00000001u) != 0;</a>
<a name="ln797">}</a>
<a name="ln798">inline void LogEntryBatchPB::set_has_committed_op_id() {</a>
<a name="ln799">  _has_bits_[0] |= 0x00000001u;</a>
<a name="ln800">}</a>
<a name="ln801">inline void LogEntryBatchPB::clear_has_committed_op_id() {</a>
<a name="ln802">  _has_bits_[0] &amp;= ~0x00000001u;</a>
<a name="ln803">}</a>
<a name="ln804">inline const ::yb::OpIdPB&amp; LogEntryBatchPB::committed_op_id() const {</a>
<a name="ln805">  const ::yb::OpIdPB* p = committed_op_id_;</a>
<a name="ln806">  // @@protoc_insertion_point(field_get:yb.log.LogEntryBatchPB.committed_op_id)</a>
<a name="ln807">  return p != NULL ? *p : *reinterpret_cast&lt;const ::yb::OpIdPB*&gt;(</a>
<a name="ln808">      &amp;::yb::_OpIdPB_default_instance_);</a>
<a name="ln809">}</a>
<a name="ln810">inline ::yb::OpIdPB* LogEntryBatchPB::release_committed_op_id() {</a>
<a name="ln811">  // @@protoc_insertion_point(field_release:yb.log.LogEntryBatchPB.committed_op_id)</a>
<a name="ln812">  clear_has_committed_op_id();</a>
<a name="ln813">  ::yb::OpIdPB* temp = committed_op_id_;</a>
<a name="ln814">  committed_op_id_ = NULL;</a>
<a name="ln815">  return temp;</a>
<a name="ln816">}</a>
<a name="ln817">inline ::yb::OpIdPB* LogEntryBatchPB::mutable_committed_op_id() {</a>
<a name="ln818">  set_has_committed_op_id();</a>
<a name="ln819">  if (committed_op_id_ == NULL) {</a>
<a name="ln820">    committed_op_id_ = new ::yb::OpIdPB;</a>
<a name="ln821">  }</a>
<a name="ln822">  // @@protoc_insertion_point(field_mutable:yb.log.LogEntryBatchPB.committed_op_id)</a>
<a name="ln823">  return committed_op_id_;</a>
<a name="ln824">}</a>
<a name="ln825">inline void LogEntryBatchPB::set_allocated_committed_op_id(::yb::OpIdPB* committed_op_id) {</a>
<a name="ln826">  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();</a>
<a name="ln827">  if (message_arena == NULL) {</a>
<a name="ln828">    delete reinterpret_cast&lt; ::google::protobuf::MessageLite*&gt;(committed_op_id_);</a>
<a name="ln829">  }</a>
<a name="ln830">  if (committed_op_id) {</a>
<a name="ln831">    ::google::protobuf::Arena* submessage_arena = NULL;</a>
<a name="ln832">    if (message_arena != submessage_arena) {</a>
<a name="ln833">      committed_op_id = ::google::protobuf::internal::GetOwnedMessage(</a>
<a name="ln834">          message_arena, committed_op_id, submessage_arena);</a>
<a name="ln835">    }</a>
<a name="ln836">    set_has_committed_op_id();</a>
<a name="ln837">  } else {</a>
<a name="ln838">    clear_has_committed_op_id();</a>
<a name="ln839">  }</a>
<a name="ln840">  committed_op_id_ = committed_op_id;</a>
<a name="ln841">  // @@protoc_insertion_point(field_set_allocated:yb.log.LogEntryBatchPB.committed_op_id)</a>
<a name="ln842">}</a>
<a name="ln843"> </a>
<a name="ln844">// optional uint64 mono_time = 3;</a>
<a name="ln845">inline bool LogEntryBatchPB::has_mono_time() const {</a>
<a name="ln846">  return (_has_bits_[0] &amp; 0x00000002u) != 0;</a>
<a name="ln847">}</a>
<a name="ln848">inline void LogEntryBatchPB::set_has_mono_time() {</a>
<a name="ln849">  _has_bits_[0] |= 0x00000002u;</a>
<a name="ln850">}</a>
<a name="ln851">inline void LogEntryBatchPB::clear_has_mono_time() {</a>
<a name="ln852">  _has_bits_[0] &amp;= ~0x00000002u;</a>
<a name="ln853">}</a>
<a name="ln854">inline void LogEntryBatchPB::clear_mono_time() {</a>
<a name="ln855">  mono_time_ = GOOGLE_ULONGLONG(0);</a>
<a name="ln856">  clear_has_mono_time();</a>
<a name="ln857">}</a>
<a name="ln858">inline ::google::protobuf::uint64 LogEntryBatchPB::mono_time() const {</a>
<a name="ln859">  // @@protoc_insertion_point(field_get:yb.log.LogEntryBatchPB.mono_time)</a>
<a name="ln860">  return mono_time_;</a>
<a name="ln861">}</a>
<a name="ln862">inline void LogEntryBatchPB::set_mono_time(::google::protobuf::uint64 value) {</a>
<a name="ln863">  set_has_mono_time();</a>
<a name="ln864">  mono_time_ = value;</a>
<a name="ln865">  // @@protoc_insertion_point(field_set:yb.log.LogEntryBatchPB.mono_time)</a>
<a name="ln866">}</a>
<a name="ln867"> </a>
<a name="ln868">// -------------------------------------------------------------------</a>
<a name="ln869"> </a>
<a name="ln870">// LogSegmentHeaderPB</a>
<a name="ln871"> </a>
<a name="ln872">// required uint32 major_version = 1;</a>
<a name="ln873">inline bool LogSegmentHeaderPB::has_major_version() const {</a>
<a name="ln874">  return (_has_bits_[0] &amp; 0x00000004u) != 0;</a>
<a name="ln875">}</a>
<a name="ln876">inline void LogSegmentHeaderPB::set_has_major_version() {</a>
<a name="ln877">  _has_bits_[0] |= 0x00000004u;</a>
<a name="ln878">}</a>
<a name="ln879">inline void LogSegmentHeaderPB::clear_has_major_version() {</a>
<a name="ln880">  _has_bits_[0] &amp;= ~0x00000004u;</a>
<a name="ln881">}</a>
<a name="ln882">inline void LogSegmentHeaderPB::clear_major_version() {</a>
<a name="ln883">  major_version_ = 0u;</a>
<a name="ln884">  clear_has_major_version();</a>
<a name="ln885">}</a>
<a name="ln886">inline ::google::protobuf::uint32 LogSegmentHeaderPB::major_version() const {</a>
<a name="ln887">  // @@protoc_insertion_point(field_get:yb.log.LogSegmentHeaderPB.major_version)</a>
<a name="ln888">  return major_version_;</a>
<a name="ln889">}</a>
<a name="ln890">inline void LogSegmentHeaderPB::set_major_version(::google::protobuf::uint32 value) {</a>
<a name="ln891">  set_has_major_version();</a>
<a name="ln892">  major_version_ = value;</a>
<a name="ln893">  // @@protoc_insertion_point(field_set:yb.log.LogSegmentHeaderPB.major_version)</a>
<a name="ln894">}</a>
<a name="ln895"> </a>
<a name="ln896">// required uint32 minor_version = 2;</a>
<a name="ln897">inline bool LogSegmentHeaderPB::has_minor_version() const {</a>
<a name="ln898">  return (_has_bits_[0] &amp; 0x00000008u) != 0;</a>
<a name="ln899">}</a>
<a name="ln900">inline void LogSegmentHeaderPB::set_has_minor_version() {</a>
<a name="ln901">  _has_bits_[0] |= 0x00000008u;</a>
<a name="ln902">}</a>
<a name="ln903">inline void LogSegmentHeaderPB::clear_has_minor_version() {</a>
<a name="ln904">  _has_bits_[0] &amp;= ~0x00000008u;</a>
<a name="ln905">}</a>
<a name="ln906">inline void LogSegmentHeaderPB::clear_minor_version() {</a>
<a name="ln907">  minor_version_ = 0u;</a>
<a name="ln908">  clear_has_minor_version();</a>
<a name="ln909">}</a>
<a name="ln910">inline ::google::protobuf::uint32 LogSegmentHeaderPB::minor_version() const {</a>
<a name="ln911">  // @@protoc_insertion_point(field_get:yb.log.LogSegmentHeaderPB.minor_version)</a>
<a name="ln912">  return minor_version_;</a>
<a name="ln913">}</a>
<a name="ln914">inline void LogSegmentHeaderPB::set_minor_version(::google::protobuf::uint32 value) {</a>
<a name="ln915">  set_has_minor_version();</a>
<a name="ln916">  minor_version_ = value;</a>
<a name="ln917">  // @@protoc_insertion_point(field_set:yb.log.LogSegmentHeaderPB.minor_version)</a>
<a name="ln918">}</a>
<a name="ln919"> </a>
<a name="ln920">// required bytes tablet_id = 5;</a>
<a name="ln921">inline bool LogSegmentHeaderPB::has_tablet_id() const {</a>
<a name="ln922">  return (_has_bits_[0] &amp; 0x00000001u) != 0;</a>
<a name="ln923">}</a>
<a name="ln924">inline void LogSegmentHeaderPB::set_has_tablet_id() {</a>
<a name="ln925">  _has_bits_[0] |= 0x00000001u;</a>
<a name="ln926">}</a>
<a name="ln927">inline void LogSegmentHeaderPB::clear_has_tablet_id() {</a>
<a name="ln928">  _has_bits_[0] &amp;= ~0x00000001u;</a>
<a name="ln929">}</a>
<a name="ln930">inline void LogSegmentHeaderPB::clear_tablet_id() {</a>
<a name="ln931">  tablet_id_.ClearToEmptyNoArena(&amp;::google::protobuf::internal::GetEmptyStringAlreadyInited());</a>
<a name="ln932">  clear_has_tablet_id();</a>
<a name="ln933">}</a>
<a name="ln934">inline const ::std::string&amp; LogSegmentHeaderPB::tablet_id() const {</a>
<a name="ln935">  // @@protoc_insertion_point(field_get:yb.log.LogSegmentHeaderPB.tablet_id)</a>
<a name="ln936">  return tablet_id_.GetNoArena();</a>
<a name="ln937">}</a>
<a name="ln938">inline void LogSegmentHeaderPB::set_tablet_id(const ::std::string&amp; value) {</a>
<a name="ln939">  set_has_tablet_id();</a>
<a name="ln940">  tablet_id_.SetNoArena(&amp;::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);</a>
<a name="ln941">  // @@protoc_insertion_point(field_set:yb.log.LogSegmentHeaderPB.tablet_id)</a>
<a name="ln942">}</a>
<a name="ln943">#if LANG_CXX11</a>
<a name="ln944">inline void LogSegmentHeaderPB::set_tablet_id(::std::string&amp;&amp; value) {</a>
<a name="ln945">  set_has_tablet_id();</a>
<a name="ln946">  tablet_id_.SetNoArena(</a>
<a name="ln947">    &amp;::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));</a>
<a name="ln948">  // @@protoc_insertion_point(field_set_rvalue:yb.log.LogSegmentHeaderPB.tablet_id)</a>
<a name="ln949">}</a>
<a name="ln950">#endif</a>
<a name="ln951">inline void LogSegmentHeaderPB::set_tablet_id(const char* value) {</a>
<a name="ln952">  GOOGLE_DCHECK(value != NULL);</a>
<a name="ln953">  set_has_tablet_id();</a>
<a name="ln954">  tablet_id_.SetNoArena(&amp;::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));</a>
<a name="ln955">  // @@protoc_insertion_point(field_set_char:yb.log.LogSegmentHeaderPB.tablet_id)</a>
<a name="ln956">}</a>
<a name="ln957">inline void LogSegmentHeaderPB::set_tablet_id(const void* value, size_t size) {</a>
<a name="ln958">  set_has_tablet_id();</a>
<a name="ln959">  tablet_id_.SetNoArena(&amp;::google::protobuf::internal::GetEmptyStringAlreadyInited(),</a>
<a name="ln960">      ::std::string(reinterpret_cast&lt;const char*&gt;(value), size));</a>
<a name="ln961">  // @@protoc_insertion_point(field_set_pointer:yb.log.LogSegmentHeaderPB.tablet_id)</a>
<a name="ln962">}</a>
<a name="ln963">inline ::std::string* LogSegmentHeaderPB::mutable_tablet_id() {</a>
<a name="ln964">  set_has_tablet_id();</a>
<a name="ln965">  // @@protoc_insertion_point(field_mutable:yb.log.LogSegmentHeaderPB.tablet_id)</a>
<a name="ln966">  return tablet_id_.MutableNoArena(&amp;::google::protobuf::internal::GetEmptyStringAlreadyInited());</a>
<a name="ln967">}</a>
<a name="ln968">inline ::std::string* LogSegmentHeaderPB::release_tablet_id() {</a>
<a name="ln969">  // @@protoc_insertion_point(field_release:yb.log.LogSegmentHeaderPB.tablet_id)</a>
<a name="ln970">  clear_has_tablet_id();</a>
<a name="ln971">  return tablet_id_.ReleaseNoArena(&amp;::google::protobuf::internal::GetEmptyStringAlreadyInited());</a>
<a name="ln972">}</a>
<a name="ln973">inline void LogSegmentHeaderPB::set_allocated_tablet_id(::std::string* tablet_id) {</a>
<a name="ln974">  if (tablet_id != NULL) {</a>
<a name="ln975">    set_has_tablet_id();</a>
<a name="ln976">  } else {</a>
<a name="ln977">    clear_has_tablet_id();</a>
<a name="ln978">  }</a>
<a name="ln979">  tablet_id_.SetAllocatedNoArena(&amp;::google::protobuf::internal::GetEmptyStringAlreadyInited(), tablet_id);</a>
<a name="ln980">  // @@protoc_insertion_point(field_set_allocated:yb.log.LogSegmentHeaderPB.tablet_id)</a>
<a name="ln981">}</a>
<a name="ln982"> </a>
<a name="ln983">// required uint64 sequence_number = 6;</a>
<a name="ln984">inline bool LogSegmentHeaderPB::has_sequence_number() const {</a>
<a name="ln985">  return (_has_bits_[0] &amp; 0x00000010u) != 0;</a>
<a name="ln986">}</a>
<a name="ln987">inline void LogSegmentHeaderPB::set_has_sequence_number() {</a>
<a name="ln988">  _has_bits_[0] |= 0x00000010u;</a>
<a name="ln989">}</a>
<a name="ln990">inline void LogSegmentHeaderPB::clear_has_sequence_number() {</a>
<a name="ln991">  _has_bits_[0] &amp;= ~0x00000010u;</a>
<a name="ln992">}</a>
<a name="ln993">inline void LogSegmentHeaderPB::clear_sequence_number() {</a>
<a name="ln994">  sequence_number_ = GOOGLE_ULONGLONG(0);</a>
<a name="ln995">  clear_has_sequence_number();</a>
<a name="ln996">}</a>
<a name="ln997">inline ::google::protobuf::uint64 LogSegmentHeaderPB::sequence_number() const {</a>
<a name="ln998">  // @@protoc_insertion_point(field_get:yb.log.LogSegmentHeaderPB.sequence_number)</a>
<a name="ln999">  return sequence_number_;</a>
<a name="ln1000">}</a>
<a name="ln1001">inline void LogSegmentHeaderPB::set_sequence_number(::google::protobuf::uint64 value) {</a>
<a name="ln1002">  set_has_sequence_number();</a>
<a name="ln1003">  sequence_number_ = value;</a>
<a name="ln1004">  // @@protoc_insertion_point(field_set:yb.log.LogSegmentHeaderPB.sequence_number)</a>
<a name="ln1005">}</a>
<a name="ln1006"> </a>
<a name="ln1007">// required .yb.SchemaPB schema = 7;</a>
<a name="ln1008">inline bool LogSegmentHeaderPB::has_schema() const {</a>
<a name="ln1009">  return (_has_bits_[0] &amp; 0x00000002u) != 0;</a>
<a name="ln1010">}</a>
<a name="ln1011">inline void LogSegmentHeaderPB::set_has_schema() {</a>
<a name="ln1012">  _has_bits_[0] |= 0x00000002u;</a>
<a name="ln1013">}</a>
<a name="ln1014">inline void LogSegmentHeaderPB::clear_has_schema() {</a>
<a name="ln1015">  _has_bits_[0] &amp;= ~0x00000002u;</a>
<a name="ln1016">}</a>
<a name="ln1017">inline const ::yb::SchemaPB&amp; LogSegmentHeaderPB::schema() const {</a>
<a name="ln1018">  const ::yb::SchemaPB* p = schema_;</a>
<a name="ln1019">  // @@protoc_insertion_point(field_get:yb.log.LogSegmentHeaderPB.schema)</a>
<a name="ln1020">  return p != NULL ? *p : *reinterpret_cast&lt;const ::yb::SchemaPB*&gt;(</a>
<a name="ln1021">      &amp;::yb::_SchemaPB_default_instance_);</a>
<a name="ln1022">}</a>
<a name="ln1023">inline ::yb::SchemaPB* LogSegmentHeaderPB::release_schema() {</a>
<a name="ln1024">  // @@protoc_insertion_point(field_release:yb.log.LogSegmentHeaderPB.schema)</a>
<a name="ln1025">  clear_has_schema();</a>
<a name="ln1026">  ::yb::SchemaPB* temp = schema_;</a>
<a name="ln1027">  schema_ = NULL;</a>
<a name="ln1028">  return temp;</a>
<a name="ln1029">}</a>
<a name="ln1030">inline ::yb::SchemaPB* LogSegmentHeaderPB::mutable_schema() {</a>
<a name="ln1031">  set_has_schema();</a>
<a name="ln1032">  if (schema_ == NULL) {</a>
<a name="ln1033">    schema_ = new ::yb::SchemaPB;</a>
<a name="ln1034">  }</a>
<a name="ln1035">  // @@protoc_insertion_point(field_mutable:yb.log.LogSegmentHeaderPB.schema)</a>
<a name="ln1036">  return schema_;</a>
<a name="ln1037">}</a>
<a name="ln1038">inline void LogSegmentHeaderPB::set_allocated_schema(::yb::SchemaPB* schema) {</a>
<a name="ln1039">  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();</a>
<a name="ln1040">  if (message_arena == NULL) {</a>
<a name="ln1041">    delete reinterpret_cast&lt; ::google::protobuf::MessageLite*&gt;(schema_);</a>
<a name="ln1042">  }</a>
<a name="ln1043">  if (schema) {</a>
<a name="ln1044">    ::google::protobuf::Arena* submessage_arena = NULL;</a>
<a name="ln1045">    if (message_arena != submessage_arena) {</a>
<a name="ln1046">      schema = ::google::protobuf::internal::GetOwnedMessage(</a>
<a name="ln1047">          message_arena, schema, submessage_arena);</a>
<a name="ln1048">    }</a>
<a name="ln1049">    set_has_schema();</a>
<a name="ln1050">  } else {</a>
<a name="ln1051">    clear_has_schema();</a>
<a name="ln1052">  }</a>
<a name="ln1053">  schema_ = schema;</a>
<a name="ln1054">  // @@protoc_insertion_point(field_set_allocated:yb.log.LogSegmentHeaderPB.schema)</a>
<a name="ln1055">}</a>
<a name="ln1056"> </a>
<a name="ln1057">// optional uint32 schema_version = 8;</a>
<a name="ln1058">inline bool LogSegmentHeaderPB::has_schema_version() const {</a>
<a name="ln1059">  return (_has_bits_[0] &amp; 0x00000020u) != 0;</a>
<a name="ln1060">}</a>
<a name="ln1061">inline void LogSegmentHeaderPB::set_has_schema_version() {</a>
<a name="ln1062">  _has_bits_[0] |= 0x00000020u;</a>
<a name="ln1063">}</a>
<a name="ln1064">inline void LogSegmentHeaderPB::clear_has_schema_version() {</a>
<a name="ln1065">  _has_bits_[0] &amp;= ~0x00000020u;</a>
<a name="ln1066">}</a>
<a name="ln1067">inline void LogSegmentHeaderPB::clear_schema_version() {</a>
<a name="ln1068">  schema_version_ = 0u;</a>
<a name="ln1069">  clear_has_schema_version();</a>
<a name="ln1070">}</a>
<a name="ln1071">inline ::google::protobuf::uint32 LogSegmentHeaderPB::schema_version() const {</a>
<a name="ln1072">  // @@protoc_insertion_point(field_get:yb.log.LogSegmentHeaderPB.schema_version)</a>
<a name="ln1073">  return schema_version_;</a>
<a name="ln1074">}</a>
<a name="ln1075">inline void LogSegmentHeaderPB::set_schema_version(::google::protobuf::uint32 value) {</a>
<a name="ln1076">  set_has_schema_version();</a>
<a name="ln1077">  schema_version_ = value;</a>
<a name="ln1078">  // @@protoc_insertion_point(field_set:yb.log.LogSegmentHeaderPB.schema_version)</a>
<a name="ln1079">}</a>
<a name="ln1080"> </a>
<a name="ln1081">// -------------------------------------------------------------------</a>
<a name="ln1082"> </a>
<a name="ln1083">// LogSegmentFooterPB</a>
<a name="ln1084"> </a>
<a name="ln1085">// required int64 num_entries = 1;</a>
<a name="ln1086">inline bool LogSegmentFooterPB::has_num_entries() const {</a>
<a name="ln1087">  return (_has_bits_[0] &amp; 0x00000001u) != 0;</a>
<a name="ln1088">}</a>
<a name="ln1089">inline void LogSegmentFooterPB::set_has_num_entries() {</a>
<a name="ln1090">  _has_bits_[0] |= 0x00000001u;</a>
<a name="ln1091">}</a>
<a name="ln1092">inline void LogSegmentFooterPB::clear_has_num_entries() {</a>
<a name="ln1093">  _has_bits_[0] &amp;= ~0x00000001u;</a>
<a name="ln1094">}</a>
<a name="ln1095">inline void LogSegmentFooterPB::clear_num_entries() {</a>
<a name="ln1096">  num_entries_ = GOOGLE_LONGLONG(0);</a>
<a name="ln1097">  clear_has_num_entries();</a>
<a name="ln1098">}</a>
<a name="ln1099">inline ::google::protobuf::int64 LogSegmentFooterPB::num_entries() const {</a>
<a name="ln1100">  // @@protoc_insertion_point(field_get:yb.log.LogSegmentFooterPB.num_entries)</a>
<a name="ln1101">  return num_entries_;</a>
<a name="ln1102">}</a>
<a name="ln1103">inline void LogSegmentFooterPB::set_num_entries(::google::protobuf::int64 value) {</a>
<a name="ln1104">  set_has_num_entries();</a>
<a name="ln1105">  num_entries_ = value;</a>
<a name="ln1106">  // @@protoc_insertion_point(field_set:yb.log.LogSegmentFooterPB.num_entries)</a>
<a name="ln1107">}</a>
<a name="ln1108"> </a>
<a name="ln1109">// optional int64 min_replicate_index = 2 [default = -1];</a>
<a name="ln1110">inline bool LogSegmentFooterPB::has_min_replicate_index() const {</a>
<a name="ln1111">  return (_has_bits_[0] &amp; 0x00000004u) != 0;</a>
<a name="ln1112">}</a>
<a name="ln1113">inline void LogSegmentFooterPB::set_has_min_replicate_index() {</a>
<a name="ln1114">  _has_bits_[0] |= 0x00000004u;</a>
<a name="ln1115">}</a>
<a name="ln1116">inline void LogSegmentFooterPB::clear_has_min_replicate_index() {</a>
<a name="ln1117">  _has_bits_[0] &amp;= ~0x00000004u;</a>
<a name="ln1118">}</a>
<a name="ln1119">inline void LogSegmentFooterPB::clear_min_replicate_index() {</a>
<a name="ln1120">  min_replicate_index_ = GOOGLE_LONGLONG(-1);</a>
<a name="ln1121">  clear_has_min_replicate_index();</a>
<a name="ln1122">}</a>
<a name="ln1123">inline ::google::protobuf::int64 LogSegmentFooterPB::min_replicate_index() const {</a>
<a name="ln1124">  // @@protoc_insertion_point(field_get:yb.log.LogSegmentFooterPB.min_replicate_index)</a>
<a name="ln1125">  return min_replicate_index_;</a>
<a name="ln1126">}</a>
<a name="ln1127">inline void LogSegmentFooterPB::set_min_replicate_index(::google::protobuf::int64 value) {</a>
<a name="ln1128">  set_has_min_replicate_index();</a>
<a name="ln1129">  min_replicate_index_ = value;</a>
<a name="ln1130">  // @@protoc_insertion_point(field_set:yb.log.LogSegmentFooterPB.min_replicate_index)</a>
<a name="ln1131">}</a>
<a name="ln1132"> </a>
<a name="ln1133">// optional int64 max_replicate_index = 3 [default = -1];</a>
<a name="ln1134">inline bool LogSegmentFooterPB::has_max_replicate_index() const {</a>
<a name="ln1135">  return (_has_bits_[0] &amp; 0x00000008u) != 0;</a>
<a name="ln1136">}</a>
<a name="ln1137">inline void LogSegmentFooterPB::set_has_max_replicate_index() {</a>
<a name="ln1138">  _has_bits_[0] |= 0x00000008u;</a>
<a name="ln1139">}</a>
<a name="ln1140">inline void LogSegmentFooterPB::clear_has_max_replicate_index() {</a>
<a name="ln1141">  _has_bits_[0] &amp;= ~0x00000008u;</a>
<a name="ln1142">}</a>
<a name="ln1143">inline void LogSegmentFooterPB::clear_max_replicate_index() {</a>
<a name="ln1144">  max_replicate_index_ = GOOGLE_LONGLONG(-1);</a>
<a name="ln1145">  clear_has_max_replicate_index();</a>
<a name="ln1146">}</a>
<a name="ln1147">inline ::google::protobuf::int64 LogSegmentFooterPB::max_replicate_index() const {</a>
<a name="ln1148">  // @@protoc_insertion_point(field_get:yb.log.LogSegmentFooterPB.max_replicate_index)</a>
<a name="ln1149">  return max_replicate_index_;</a>
<a name="ln1150">}</a>
<a name="ln1151">inline void LogSegmentFooterPB::set_max_replicate_index(::google::protobuf::int64 value) {</a>
<a name="ln1152">  set_has_max_replicate_index();</a>
<a name="ln1153">  max_replicate_index_ = value;</a>
<a name="ln1154">  // @@protoc_insertion_point(field_set:yb.log.LogSegmentFooterPB.max_replicate_index)</a>
<a name="ln1155">}</a>
<a name="ln1156"> </a>
<a name="ln1157">// optional int64 close_timestamp_micros = 4;</a>
<a name="ln1158">inline bool LogSegmentFooterPB::has_close_timestamp_micros() const {</a>
<a name="ln1159">  return (_has_bits_[0] &amp; 0x00000002u) != 0;</a>
<a name="ln1160">}</a>
<a name="ln1161">inline void LogSegmentFooterPB::set_has_close_timestamp_micros() {</a>
<a name="ln1162">  _has_bits_[0] |= 0x00000002u;</a>
<a name="ln1163">}</a>
<a name="ln1164">inline void LogSegmentFooterPB::clear_has_close_timestamp_micros() {</a>
<a name="ln1165">  _has_bits_[0] &amp;= ~0x00000002u;</a>
<a name="ln1166">}</a>
<a name="ln1167">inline void LogSegmentFooterPB::clear_close_timestamp_micros() {</a>
<a name="ln1168">  close_timestamp_micros_ = GOOGLE_LONGLONG(0);</a>
<a name="ln1169">  clear_has_close_timestamp_micros();</a>
<a name="ln1170">}</a>
<a name="ln1171">inline ::google::protobuf::int64 LogSegmentFooterPB::close_timestamp_micros() const {</a>
<a name="ln1172">  // @@protoc_insertion_point(field_get:yb.log.LogSegmentFooterPB.close_timestamp_micros)</a>
<a name="ln1173">  return close_timestamp_micros_;</a>
<a name="ln1174">}</a>
<a name="ln1175">inline void LogSegmentFooterPB::set_close_timestamp_micros(::google::protobuf::int64 value) {</a>
<a name="ln1176">  set_has_close_timestamp_micros();</a>
<a name="ln1177">  close_timestamp_micros_ = value;</a>
<a name="ln1178">  // @@protoc_insertion_point(field_set:yb.log.LogSegmentFooterPB.close_timestamp_micros)</a>
<a name="ln1179">}</a>
<a name="ln1180"> </a>
<a name="ln1181">#ifdef __GNUC__</a>
<a name="ln1182">  #pragma GCC diagnostic pop</a>
<a name="ln1183">#endif  // __GNUC__</a>
<a name="ln1184">// -------------------------------------------------------------------</a>
<a name="ln1185"> </a>
<a name="ln1186">// -------------------------------------------------------------------</a>
<a name="ln1187"> </a>
<a name="ln1188">// -------------------------------------------------------------------</a>
<a name="ln1189"> </a>
<a name="ln1190"> </a>
<a name="ln1191">// @@protoc_insertion_point(namespace_scope)</a>
<a name="ln1192"> </a>
<a name="ln1193">}  // namespace log</a>
<a name="ln1194">}  // namespace yb</a>
<a name="ln1195"> </a>
<a name="ln1196">namespace google {</a>
<a name="ln1197">namespace protobuf {</a>
<a name="ln1198"> </a>
<a name="ln1199">template &lt;&gt; struct is_proto_enum&lt; ::yb::log::LogEntryTypePB&gt; : ::google::protobuf::internal::true_type {};</a>
<a name="ln1200">template &lt;&gt;</a>
<a name="ln1201">inline const EnumDescriptor* GetEnumDescriptor&lt; ::yb::log::LogEntryTypePB&gt;() {</a>
<a name="ln1202">  return ::yb::log::LogEntryTypePB_descriptor();</a>
<a name="ln1203">}</a>
<a name="ln1204"> </a>
<a name="ln1205">}  // namespace protobuf</a>
<a name="ln1206">}  // namespace google</a>
<a name="ln1207"> </a>
<a name="ln1208">// @@protoc_insertion_point(global_scope)</a>
<a name="ln1209"> </a>
<a name="ln1210">#endif  // PROTOBUF_yb_2fconsensus_2flog_2eproto__INCLUDED</a>

</code></pre>
<div class="balloon" rel="743"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'message_arena == __null' is always true.</p></div>
<div class="balloon" rel="748"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'message_arena != submessage_arena' is always false.</p></div>
<div class="balloon" rel="827"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'message_arena == __null' is always true.</p></div>
<div class="balloon" rel="832"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'message_arena != submessage_arena' is always false.</p></div>
<div class="balloon" rel="1040"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'message_arena == __null' is always true.</p></div>
<div class="balloon" rel="1045"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'message_arena != submessage_arena' is always false.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
