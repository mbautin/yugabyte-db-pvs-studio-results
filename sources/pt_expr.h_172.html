
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>pt_expr.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//--------------------------------------------------------------------------------------------------</a>
<a name="ln2">// Copyright (c) YugaByte, Inc.</a>
<a name="ln3">//</a>
<a name="ln4">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln5">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln6">//</a>
<a name="ln7">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln8">//</a>
<a name="ln9">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln10">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln11">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln12">// under the License.</a>
<a name="ln13">//</a>
<a name="ln14">//</a>
<a name="ln15">// Tree node definitions for expression.</a>
<a name="ln16">//--------------------------------------------------------------------------------------------------</a>
<a name="ln17"> </a>
<a name="ln18">#ifndef YB_YQL_CQL_QL_PTREE_PT_EXPR_H_</a>
<a name="ln19">#define YB_YQL_CQL_QL_PTREE_PT_EXPR_H_</a>
<a name="ln20"> </a>
<a name="ln21">#include &lt;boost/optional.hpp&gt;</a>
<a name="ln22"> </a>
<a name="ln23">#include &quot;yb/yql/cql/ql/ptree/column_desc.h&quot;</a>
<a name="ln24">#include &quot;yb/yql/cql/ql/ptree/tree_node.h&quot;</a>
<a name="ln25">#include &quot;yb/yql/cql/ql/ptree/pt_type.h&quot;</a>
<a name="ln26">#include &quot;yb/yql/cql/ql/ptree/pt_name.h&quot;</a>
<a name="ln27">#include &quot;yb/yql/cql/ql/ptree/sem_state.h&quot;</a>
<a name="ln28"> </a>
<a name="ln29">#include &quot;yb/util/bfql/tserver_opcodes.h&quot;</a>
<a name="ln30">#include &quot;yb/util/decimal.h&quot;</a>
<a name="ln31"> </a>
<a name="ln32">namespace yb {</a>
<a name="ln33">namespace ql {</a>
<a name="ln34"> </a>
<a name="ln35">// Because statements own expressions and their headers include expression headers, we forward</a>
<a name="ln36">// declare statement classes here.</a>
<a name="ln37">class PTSelectStmt;</a>
<a name="ln38">class PTDmlStmt;</a>
<a name="ln39"> </a>
<a name="ln40">//--------------------------------------------------------------------------------------------------</a>
<a name="ln41">// The order of the following enum values are not important.</a>
<a name="ln42">enum class ExprOperator : int {</a>
<a name="ln43">  kNoOp = 0,</a>
<a name="ln44"> </a>
<a name="ln45">  // Reference to constants, columns, and variables.</a>
<a name="ln46">  kConst = 1,</a>
<a name="ln47">  kAlias = 2,</a>
<a name="ln48">  kRef = 3,</a>
<a name="ln49">  kSubColRef = 4,</a>
<a name="ln50">  kBindVar = 5,</a>
<a name="ln51">  kBcall = 6,</a>
<a name="ln52"> </a>
<a name="ln53">  // Operators that take one operand.</a>
<a name="ln54">  kUMinus = 7,</a>
<a name="ln55"> </a>
<a name="ln56">  // Logical operators with one operand.</a>
<a name="ln57">  kLogic1 = 8,</a>
<a name="ln58"> </a>
<a name="ln59">  // Logical operators with two operands.</a>
<a name="ln60">  kLogic2 = 9,</a>
<a name="ln61"> </a>
<a name="ln62">  // Relation operators that take no operand.</a>
<a name="ln63">  kRelation0 = 10,</a>
<a name="ln64"> </a>
<a name="ln65">  // Relation operators that take one operand.</a>
<a name="ln66">  kRelation1 = 11,</a>
<a name="ln67"> </a>
<a name="ln68">  // Relation operators that take two operands.</a>
<a name="ln69">  kRelation2 = 12,</a>
<a name="ln70"> </a>
<a name="ln71">  // Relation operators that take three operands.</a>
<a name="ln72">  kRelation3 = 13,</a>
<a name="ln73"> </a>
<a name="ln74">  // Relation operators that take unspecified number of operands.</a>
<a name="ln75">  kCollection = 14,</a>
<a name="ln76"> </a>
<a name="ln77">  // Reference to a column with json operators.</a>
<a name="ln78">  kJsonOperatorRef = 15,</a>
<a name="ln79">};</a>
<a name="ln80"> </a>
<a name="ln81">enum class JsonOperator {</a>
<a name="ln82">  JSON_OBJECT,</a>
<a name="ln83">  JSON_TEXT</a>
<a name="ln84">};</a>
<a name="ln85"> </a>
<a name="ln86">//--------------------------------------------------------------------------------------------------</a>
<a name="ln87">// Base class for all expressions.</a>
<a name="ln88">class PTExpr : public TreeNode {</a>
<a name="ln89"> public:</a>
<a name="ln90">  //------------------------------------------------------------------------------------------------</a>
<a name="ln91">  // Public types.</a>
<a name="ln92">  typedef MCSharedPtr&lt;PTExpr&gt; SharedPtr;</a>
<a name="ln93">  typedef MCSharedPtr&lt;const PTExpr&gt; SharedPtrConst;</a>
<a name="ln94"> </a>
<a name="ln95">  //------------------------------------------------------------------------------------------------</a>
<a name="ln96">  // Constructor and destructor.</a>
<a name="ln97">  explicit PTExpr(</a>
<a name="ln98">      MemoryContext *memctx,</a>
<a name="ln99">      YBLocation::SharedPtr loc,</a>
<a name="ln100">      ExprOperator op = ExprOperator::kNoOp,</a>
<a name="ln101">      yb::QLOperator ql_op = yb::QLOperator::QL_OP_NOOP,</a>
<a name="ln102">      InternalType internal_type = InternalType::VALUE_NOT_SET,</a>
<a name="ln103">      DataType ql_type_id = DataType::UNKNOWN_DATA)</a>
<a name="ln104">      : PTExpr(memctx, loc, op, ql_op, internal_type, QLType::Create(ql_type_id)) {}</a>
<a name="ln105">  explicit PTExpr(</a>
<a name="ln106">      MemoryContext *memctx,</a>
<a name="ln107">      YBLocation::SharedPtr loc,</a>
<a name="ln108">      ExprOperator op,</a>
<a name="ln109">      yb::QLOperator ql_op,</a>
<a name="ln110">      InternalType internal_type,</a>
<a name="ln111">      const QLType::SharedPtr&amp; ql_type)</a>
<a name="ln112">      : TreeNode(memctx, loc),</a>
<a name="ln113">        op_(op),</a>
<a name="ln114">        ql_op_(ql_op),</a>
<a name="ln115">        internal_type_(internal_type),</a>
<a name="ln116">        ql_type_(ql_type),</a>
<a name="ln117">        expected_internal_type_(InternalType::VALUE_NOT_SET),</a>
<a name="ln118">        index_name_(MCMakeShared&lt;MCString&gt;(memctx)) {}</a>
<a name="ln119">  virtual ~PTExpr() {}</a>
<a name="ln120"> </a>
<a name="ln121">  // Expression return type in DocDB format.</a>
<a name="ln122">  virtual InternalType internal_type() const {</a>
<a name="ln123">    return internal_type_;</a>
<a name="ln124">  }</a>
<a name="ln125"> </a>
<a name="ln126">  bool has_valid_internal_type() {</a>
<a name="ln127">    // internal_type_ is not set in case of PTNull.</a>
<a name="ln128">    return ql_type_-&gt;main() == DataType::NULL_VALUE_TYPE ||</a>
<a name="ln129">           internal_type_ != InternalType::VALUE_NOT_SET;</a>
<a name="ln130">  }</a>
<a name="ln131"> </a>
<a name="ln132">  virtual InternalType expected_internal_type() const {</a>
<a name="ln133">    return expected_internal_type_;</a>
<a name="ln134">  }</a>
<a name="ln135"> </a>
<a name="ln136">  // Expression return type in QL format.</a>
<a name="ln137">  virtual const std::shared_ptr&lt;QLType&gt;&amp; ql_type() const {</a>
<a name="ln138">    return ql_type_;</a>
<a name="ln139">  }</a>
<a name="ln140"> </a>
<a name="ln141">  // This is only useful during pre-exec phase.</a>
<a name="ln142">  // Normally you'd want to use CheckExpectedTypeCompatibility instead.</a>
<a name="ln143">  virtual void set_expected_internal_type(InternalType expected_internal_type) {</a>
<a name="ln144">    expected_internal_type_ = expected_internal_type;</a>
<a name="ln145">  }</a>
<a name="ln146"> </a>
<a name="ln147">  // Expression return result set column type in QL format.</a>
<a name="ln148">  virtual void rscol_type_PB(QLTypePB *pb_type ) const {</a>
<a name="ln149">    ql_type_-&gt;ToQLTypePB(pb_type);</a>
<a name="ln150">  }</a>
<a name="ln151"> </a>
<a name="ln152">  virtual void set_ql_type(const std::shared_ptr&lt;QLType&gt;&amp; ql_type) {</a>
<a name="ln153">    ql_type_ = ql_type;</a>
<a name="ln154">  }</a>
<a name="ln155"> </a>
<a name="ln156">  virtual void set_ql_type(DataType type_id) {</a>
<a name="ln157">    ql_type_ = QLType::Create(type_id);</a>
<a name="ln158">  }</a>
<a name="ln159"> </a>
<a name="ln160">  // TODO(neil or mihnea) Remove or replace all ql_type_id API &amp; comments with QLType.</a>
<a name="ln161">  virtual DataType ql_type_id() const {</a>
<a name="ln162">    return ql_type_-&gt;main();</a>
<a name="ln163">  }</a>
<a name="ln164"> </a>
<a name="ln165">  virtual void set_ql_type_id(DataType type_id) {</a>
<a name="ln166">    ql_type_ = QLType::Create(type_id);</a>
<a name="ln167">  }</a>
<a name="ln168"> </a>
<a name="ln169">  bool has_valid_ql_type_id() {</a>
<a name="ln170">    return ql_type_-&gt;main() != DataType::UNKNOWN_DATA;</a>
<a name="ln171">  }</a>
<a name="ln172"> </a>
<a name="ln173">  // Seeks index-columns that referenced by this expression and output mangled colum names.</a>
<a name="ln174">  // NOTE:</a>
<a name="ln175">  // - index-column can be either a column or an expression of the column.</a>
<a name="ln176">  // - Currently, name of a column in an INDEX must be one of the following.</a>
<a name="ln177">  //   * Mangled name of a column of scalar type (not a collection type such as map, jsonb).</a>
<a name="ln178">  //   * Mangled name of a &quot;jsonb-&gt;&gt;field&quot; expresion.</a>
<a name="ln179">  virtual void CollectReferencedIndexColnames(MCSet&lt;string&gt; *col_names) const {</a>
<a name="ln180">    if (op1()) {</a>
<a name="ln181">      op1()-&gt;CollectReferencedIndexColnames(col_names);</a>
<a name="ln182">    }</a>
<a name="ln183">    if (op2()) {</a>
<a name="ln184">      op2()-&gt;CollectReferencedIndexColnames(col_names);</a>
<a name="ln185">    }</a>
<a name="ln186">    if (op3()) {</a>
<a name="ln187">      op3()-&gt;CollectReferencedIndexColnames(col_names);</a>
<a name="ln188">    }</a>
<a name="ln189">  }</a>
<a name="ln190"> </a>
<a name="ln191">  // Return name of expression.</a>
<a name="ln192">  // - Option kUserOriginalName</a>
<a name="ln193">  //     When report data to user, we use the original name that users enterred. In SELECT,</a>
<a name="ln194">  //     each selected expression is assigned a name, and this method is to form the name of an</a>
<a name="ln195">  //     expression using un-mangled column names. For example, when selected expr is a column of a</a>
<a name="ln196">  //     table, QLName() would be the name of that column.</a>
<a name="ln197">  //</a>
<a name="ln198">  // - Option kMangledName</a>
<a name="ln199">  //     When INDEX is created, YugaByte generates column name by mangling the original name from</a>
<a name="ln200">  //     users for the index expression columns.</a>
<a name="ln201">  //</a>
<a name="ln202">  // - Option kMetadataName</a>
<a name="ln203">  //     When loading column descriptor from Catalog::Table and Catalog::IndexTable, we might want</a>
<a name="ln204">  //     to read the name that is kept in the Catalog. Unmangled name for regular column, and</a>
<a name="ln205">  //     mangled name for index-expression column.</a>
<a name="ln206">  virtual string QLName(QLNameOption option = QLNameOption::kUserOriginalName) const {</a>
<a name="ln207">    LOG(INFO) &lt;&lt; &quot;Missing QLName for expression(&quot;</a>
<a name="ln208">              &lt;&lt; static_cast&lt;int&gt;(expr_op())</a>
<a name="ln209">              &lt;&lt; &quot;) that is being selected&quot;;</a>
<a name="ln210">    return &quot;expr&quot;;</a>
<a name="ln211">  }</a>
<a name="ln212"> </a>
<a name="ln213">  virtual string MangledName() const {</a>
<a name="ln214">    return QLName(QLNameOption::kMangledName);</a>
<a name="ln215">  }</a>
<a name="ln216"> </a>
<a name="ln217">  virtual string MetadataName() const {</a>
<a name="ln218">    // If this expression was used to define an index column, use its descriptor name.</a>
<a name="ln219">    return index_desc_ ? index_desc_-&gt;MetadataName() : QLName(QLNameOption::kMetadataName);</a>
<a name="ln220">  }</a>
<a name="ln221"> </a>
<a name="ln222">  // Node type.</a>
<a name="ln223">  virtual TreeNodeOpcode opcode() const override {</a>
<a name="ln224">    return TreeNodeOpcode::kPTExpr;</a>
<a name="ln225">  }</a>
<a name="ln226"> </a>
<a name="ln227">  // Returns the expression operator.</a>
<a name="ln228">  virtual ExprOperator expr_op() const {</a>
<a name="ln229">    return op_;</a>
<a name="ln230">  }</a>
<a name="ln231"> </a>
<a name="ln232">  yb::QLOperator ql_op() const {</a>
<a name="ln233">    return ql_op_;</a>
<a name="ln234">  }</a>
<a name="ln235"> </a>
<a name="ln236">  // Predicate for null.</a>
<a name="ln237">  virtual bool is_null() const {</a>
<a name="ln238">    return ql_type_-&gt;main() == DataType::NULL_VALUE_TYPE;</a>
<a name="ln239">  }</a>
<a name="ln240"> </a>
<a name="ln241">  // Returns the operands of an expression.</a>
<a name="ln242">  virtual PTExpr::SharedPtr op1() const {</a>
<a name="ln243">    return nullptr;</a>
<a name="ln244">  }</a>
<a name="ln245"> </a>
<a name="ln246">  virtual PTExpr::SharedPtr op2() const {</a>
<a name="ln247">    return nullptr;</a>
<a name="ln248">  }</a>
<a name="ln249"> </a>
<a name="ln250">  virtual PTExpr::SharedPtr op3() const {</a>
<a name="ln251">    return nullptr;</a>
<a name="ln252">  }</a>
<a name="ln253"> </a>
<a name="ln254">  // Predicate for constant tree node.</a>
<a name="ln255">  bool is_constant() const {</a>
<a name="ln256">    return ((expr_op() == ExprOperator::kConst) ||</a>
<a name="ln257">            (expr_op() == ExprOperator::kUMinus &amp;&amp; op1()-&gt;expr_op() == ExprOperator::kConst));</a>
<a name="ln258">  }</a>
<a name="ln259"> </a>
<a name="ln260">  // Predicate for values.</a>
<a name="ln261">  bool has_no_column_ref() const {</a>
<a name="ln262">    return is_constant() ||</a>
<a name="ln263">           expr_op() == ExprOperator::kBindVar ||</a>
<a name="ln264">           expr_op() == ExprOperator::kCollection;</a>
<a name="ln265">  }</a>
<a name="ln266"> </a>
<a name="ln267">  virtual bool IsDummyStar() const {</a>
<a name="ln268">    return false;</a>
<a name="ln269">  }</a>
<a name="ln270"> </a>
<a name="ln271">  // Predicate for calls to aggregate functions.</a>
<a name="ln272">  virtual bool IsAggregateCall() const {</a>
<a name="ln273">    return false;</a>
<a name="ln274">  }</a>
<a name="ln275">  virtual yb::bfql::TSOpcode aggregate_opcode() const {</a>
<a name="ln276">    return yb::bfql::TSOpcode::kNoOp;</a>
<a name="ln277">  }</a>
<a name="ln278"> </a>
<a name="ln279">  // Predicate for expressions that have no column reference.</a>
<a name="ln280">  // - When an expression does not have ColumnRef, it can be evaluated without reading table data.</a>
<a name="ln281">  // - By default, returns true to indicate so that optimization doesn't take place unless we</a>
<a name="ln282">  //   know for sure ColumnRef is used.</a>
<a name="ln283">  //</a>
<a name="ln284">  // Examples:</a>
<a name="ln285">  // - Constant has no column reference.</a>
<a name="ln286">  // - PTRef always has column-ref.</a>
<a name="ln287">  // - All other epxressions are dependent on whether or not its argument list contains a column.</a>
<a name="ln288">  //   NOW() and COUNT(*) have no reference. The '*' argument is translated to PTStar (DummyStar)</a>
<a name="ln289">  //   because we don't need to read any extra information from DocDB to process the statement for</a>
<a name="ln290">  //   this expression.</a>
<a name="ln291">  virtual bool HaveColumnRef() const {</a>
<a name="ln292">    return true;</a>
<a name="ln293">  }</a>
<a name="ln294"> </a>
<a name="ln295">  static PTExpr::SharedPtr CreateConst(MemoryContext *memctx,</a>
<a name="ln296">                                       YBLocation::SharedPtr loc,</a>
<a name="ln297">                                       PTBaseType::SharedPtr data_type);</a>
<a name="ln298"> </a>
<a name="ln299">  // Predicate for updating counter.  Only '+' and '-' expression support counter update.</a>
<a name="ln300">  virtual CHECKED_STATUS CheckCounterUpdateSupport(SemContext *sem_context) const;</a>
<a name="ln301"> </a>
<a name="ln302">  // All expressions must define this Analyze() function, which does the following steps.</a>
<a name="ln303">  // - Call Analyze() on child treenodes to run semantic analysis on the child nodes. The child</a>
<a name="ln304">  //   nodes will then call their own child nodes and so forth. In short, we traverse the expression</a>
<a name="ln305">  //   parse tree to run semantic analysis on them.</a>
<a name="ln306">  // - Run semantic analysis on this node.</a>
<a name="ln307">  // - The main job of semantics analysis is to run type resolution to find the correct values for</a>
<a name="ln308">  //   ql_type and internal_type_ for expressions.</a>
<a name="ln309">  virtual CHECKED_STATUS Analyze(SemContext *sem_context) override = 0;</a>
<a name="ln310"> </a>
<a name="ln311">  // Check if this expression represents a column in an INDEX table.</a>
<a name="ln312">  bool CheckIndexColumn(SemContext *sem_context);</a>
<a name="ln313"> </a>
<a name="ln314">  // Check if an operator is allowed in the current context before analyzing it.</a>
<a name="ln315">  virtual CHECKED_STATUS CheckOperator(SemContext *sem_context);</a>
<a name="ln316"> </a>
<a name="ln317">  // The following functions are called to setup the states before analyzing an operand.</a>
<a name="ln318">  virtual CHECKED_STATUS SetupSemStateForOp1(SemState *sem_state);</a>
<a name="ln319">  virtual CHECKED_STATUS SetupSemStateForOp2(SemState *sem_state);</a>
<a name="ln320">  virtual CHECKED_STATUS SetupSemStateForOp3(SemState *sem_state);</a>
<a name="ln321"> </a>
<a name="ln322">  // These functions are called by analyze to run type resolution on this expression.</a>
<a name="ln323">  virtual CHECKED_STATUS AnalyzeOperator(SemContext *sem_context);</a>
<a name="ln324">  virtual CHECKED_STATUS AnalyzeOperator(SemContext *sem_context,</a>
<a name="ln325">                                         PTExpr::SharedPtr op1);</a>
<a name="ln326">  virtual CHECKED_STATUS AnalyzeOperator(SemContext *sem_context,</a>
<a name="ln327">                                         PTExpr::SharedPtr op1,</a>
<a name="ln328">                                         PTExpr::SharedPtr op2);</a>
<a name="ln329">  virtual CHECKED_STATUS AnalyzeOperator(SemContext *sem_context,</a>
<a name="ln330">                                         PTExpr::SharedPtr op1,</a>
<a name="ln331">                                         PTExpr::SharedPtr op2,</a>
<a name="ln332">                                         PTExpr::SharedPtr op3);</a>
<a name="ln333"> </a>
<a name="ln334">  // Analyze LHS expression.</a>
<a name="ln335">  virtual CHECKED_STATUS CheckLhsExpr(SemContext *sem_context);</a>
<a name="ln336"> </a>
<a name="ln337">  // Analyze RHS expression.</a>
<a name="ln338">  virtual CHECKED_STATUS CheckRhsExpr(SemContext *sem_context);</a>
<a name="ln339"> </a>
<a name="ln340">  // Check if left and right values are compatible.</a>
<a name="ln341">  virtual CHECKED_STATUS CheckInequalityOperands(SemContext *sem_context,</a>
<a name="ln342">                                                 PTExpr::SharedPtr lhs,</a>
<a name="ln343">                                                 PTExpr::SharedPtr rhs);</a>
<a name="ln344">  // Check if left and right values are compatible.</a>
<a name="ln345">  virtual CHECKED_STATUS CheckEqualityOperands(SemContext *sem_context,</a>
<a name="ln346">                                               PTExpr::SharedPtr lhs,</a>
<a name="ln347">                                               PTExpr::SharedPtr rhs);</a>
<a name="ln348"> </a>
<a name="ln349">  // Compare this node datatype with the expected type from the parent treenode.</a>
<a name="ln350">  virtual CHECKED_STATUS CheckExpectedTypeCompatibility(SemContext *sem_context);</a>
<a name="ln351"> </a>
<a name="ln352">  // Access function for descriptor.</a>
<a name="ln353">  const ColumnDesc *index_desc() const {</a>
<a name="ln354">    return index_desc_;</a>
<a name="ln355">  }</a>
<a name="ln356"> </a>
<a name="ln357">  const MCSharedPtr&lt;MCString&gt;&amp; index_name() const {</a>
<a name="ln358">    return index_name_;</a>
<a name="ln359">  }</a>
<a name="ln360"> </a>
<a name="ln361"> protected:</a>
<a name="ln362">  // Get the column descriptor for this expression. IndexTable can have expression as its column.</a>
<a name="ln363">  const ColumnDesc *GetColumnDesc(const SemContext *sem_context);</a>
<a name="ln364"> </a>
<a name="ln365">  // Get the descriptor for a column name.</a>
<a name="ln366">  const ColumnDesc *GetColumnDesc(const SemContext *sem_context, const MCString&amp; col_name) const;</a>
<a name="ln367"> </a>
<a name="ln368">  // Get the descriptor for a column or expr name from either a DML STMT or a TABLE.</a>
<a name="ln369">  const ColumnDesc *GetColumnDesc(const SemContext *sem_context,</a>
<a name="ln370">                                  const MCString&amp; col_name,</a>
<a name="ln371">                                  PTDmlStmt *stmt) const;</a>
<a name="ln372"> </a>
<a name="ln373">  ExprOperator op_;</a>
<a name="ln374">  yb::QLOperator ql_op_;</a>
<a name="ln375">  InternalType internal_type_;</a>
<a name="ln376">  QLType::SharedPtr ql_type_;</a>
<a name="ln377">  InternalType expected_internal_type_;</a>
<a name="ln378"> </a>
<a name="ln379">  // Fields that should be resolved by semantic analysis.</a>
<a name="ln380">  // An expression might be a reference to a column in an INDEX.</a>
<a name="ln381">  const ColumnDesc *index_desc_ = nullptr;</a>
<a name="ln382">  MCSharedPtr&lt;MCString&gt; index_name_;</a>
<a name="ln383">};</a>
<a name="ln384"> </a>
<a name="ln385">using PTExprListNode = TreeListNode&lt;PTExpr&gt;;</a>
<a name="ln386"> </a>
<a name="ln387">//--------------------------------------------------------------------------------------------------</a>
<a name="ln388">// Tree Nodes for Collections -- treated as expressions with flexible arity</a>
<a name="ln389">//--------------------------------------------------------------------------------------------------</a>
<a name="ln390"> </a>
<a name="ln391">class PTCollectionExpr : public PTExpr {</a>
<a name="ln392"> public:</a>
<a name="ln393">  //------------------------------------------------------------------------------------------------</a>
<a name="ln394">  // Public types.</a>
<a name="ln395">  typedef MCSharedPtr&lt;PTCollectionExpr&gt; SharedPtr;</a>
<a name="ln396">  typedef MCSharedPtr&lt;const PTCollectionExpr&gt; SharedPtrConst;</a>
<a name="ln397"> </a>
<a name="ln398">  //------------------------------------------------------------------------------------------------</a>
<a name="ln399">  // Constructor and destructor.</a>
<a name="ln400">  PTCollectionExpr(MemoryContext* memctx,</a>
<a name="ln401">                   YBLocation::SharedPtr loc,</a>
<a name="ln402">                   const QLType::SharedPtr&amp; ql_type)</a>
<a name="ln403">      : PTExpr(memctx, loc, ExprOperator::kCollection, yb::QLOperator::QL_OP_NOOP,</a>
<a name="ln404">               client::YBColumnSchema::ToInternalDataType(ql_type), ql_type),</a>
<a name="ln405">        keys_(memctx), values_(memctx), udtype_field_values_(memctx) {}</a>
<a name="ln406">  PTCollectionExpr(MemoryContext* memctx, YBLocation::SharedPtr loc, DataType literal_type)</a>
<a name="ln407">      : PTCollectionExpr(memctx, loc, QLType::Create(literal_type)) {}</a>
<a name="ln408">  virtual ~PTCollectionExpr() { }</a>
<a name="ln409"> </a>
<a name="ln410">  void AddKeyValuePair(PTExpr::SharedPtr key, PTExpr::SharedPtr value) {</a>
<a name="ln411">    keys_.emplace_back(key);</a>
<a name="ln412">    values_.emplace_back(value);</a>
<a name="ln413">  }</a>
<a name="ln414"> </a>
<a name="ln415">  void AddElement(PTExpr::SharedPtr value) {</a>
<a name="ln416">    values_.emplace_back(value);</a>
<a name="ln417">  }</a>
<a name="ln418"> </a>
<a name="ln419">  // Fill in udtype_field_values collection, copying values in accordance to UDT field order</a>
<a name="ln420">  CHECKED_STATUS InitializeUDTValues(const QLType::SharedPtr&amp; expected_type,</a>
<a name="ln421">                                     ProcessContextBase* process_context);</a>
<a name="ln422"> </a>
<a name="ln423">  int size() const {</a>
<a name="ln424">    return static_cast&lt;int&gt;(values_.size());</a>
<a name="ln425">  }</a>
<a name="ln426"> </a>
<a name="ln427">  const MCList&lt;PTExpr::SharedPtr&gt;&amp; keys() const {</a>
<a name="ln428">    return keys_;</a>
<a name="ln429">  }</a>
<a name="ln430"> </a>
<a name="ln431">  const MCList&lt;PTExpr::SharedPtr&gt;&amp; values() const {</a>
<a name="ln432">    return values_;</a>
<a name="ln433">  }</a>
<a name="ln434"> </a>
<a name="ln435">  const MCVector&lt;PTExpr::SharedPtr&gt;&amp; udtype_field_values() const {</a>
<a name="ln436">    return udtype_field_values_;</a>
<a name="ln437">  }</a>
<a name="ln438"> </a>
<a name="ln439">  virtual CHECKED_STATUS Analyze(SemContext *sem_context) override;</a>
<a name="ln440"> </a>
<a name="ln441">  // Support for shared_ptr.</a>
<a name="ln442">  template&lt;typename... TypeArgs&gt;</a>
<a name="ln443">  inline static PTCollectionExpr::SharedPtr MakeShared(MemoryContext *memctx, TypeArgs&amp;&amp;... args) {</a>
<a name="ln444">    return MCMakeShared&lt;PTCollectionExpr&gt;(memctx, std::forward&lt;TypeArgs&gt;(args)...);</a>
<a name="ln445">  }</a>
<a name="ln446"> </a>
<a name="ln447"> private:</a>
<a name="ln448">  MCList&lt;PTExpr::SharedPtr&gt; keys_;</a>
<a name="ln449">  MCList&lt;PTExpr::SharedPtr&gt; values_;</a>
<a name="ln450"> </a>
<a name="ln451">  // This field will be decorated during analysis if this collection represents a user-defined type</a>
<a name="ln452">  // It contains the field values in the order specified by the type (or nullptr for missing values)</a>
<a name="ln453">  MCVector&lt;PTExpr::SharedPtr&gt; udtype_field_values_;</a>
<a name="ln454">};</a>
<a name="ln455"> </a>
<a name="ln456">//--------------------------------------------------------------------------------------------------</a>
<a name="ln457">// Template for expression with no operand (0 input).</a>
<a name="ln458">template&lt;InternalType itype, DataType ytype, class expr_class = PTExpr&gt;</a>
<a name="ln459">class PTExpr0 : public expr_class {</a>
<a name="ln460"> public:</a>
<a name="ln461">  //------------------------------------------------------------------------------------------------</a>
<a name="ln462">  // Public types.</a>
<a name="ln463">  typedef MCSharedPtr&lt;PTExpr0&gt; SharedPtr;</a>
<a name="ln464">  typedef MCSharedPtr&lt;const PTExpr0&gt; SharedPtrConst;</a>
<a name="ln465"> </a>
<a name="ln466">  //------------------------------------------------------------------------------------------------</a>
<a name="ln467">  // Constructor and destructor.</a>
<a name="ln468">  PTExpr0(MemoryContext *memctx,</a>
<a name="ln469">          YBLocation::SharedPtr loc,</a>
<a name="ln470">          ExprOperator op,</a>
<a name="ln471">          yb::QLOperator ql_op)</a>
<a name="ln472">      : expr_class(memctx, loc, op, ql_op, itype, ytype) {</a>
<a name="ln473">  }</a>
<a name="ln474">  virtual ~PTExpr0() {</a>
<a name="ln475">  }</a>
<a name="ln476"> </a>
<a name="ln477">  // Shared pointer support.</a>
<a name="ln478">  template&lt;typename... TypeArgs&gt;</a>
<a name="ln479">  inline static PTExpr0::SharedPtr MakeShared(MemoryContext *memctx, TypeArgs&amp;&amp;... args) {</a>
<a name="ln480">    return MCMakeShared&lt;PTExpr0&gt;(memctx, std::forward&lt;TypeArgs&gt;(args)...);</a>
<a name="ln481">  }</a>
<a name="ln482"> </a>
<a name="ln483">  virtual CHECKED_STATUS Analyze(SemContext *sem_context) override {</a>
<a name="ln484">    // Before traversing the expression, check if this whole expression is actually a column.</a>
<a name="ln485">    if (this-&gt;CheckIndexColumn(sem_context)) {</a>
<a name="ln486">      return Status::OK();</a>
<a name="ln487">    }</a>
<a name="ln488"> </a>
<a name="ln489">    RETURN_NOT_OK(this-&gt;CheckOperator(sem_context));</a>
<a name="ln490"> </a>
<a name="ln491">    // Analyze this node operator and setup its ql_type and internal_type_.</a>
<a name="ln492">    RETURN_NOT_OK(this-&gt;AnalyzeOperator(sem_context));</a>
<a name="ln493"> </a>
<a name="ln494">    // Make sure that this expression has valid data type.</a>
<a name="ln495">    return this-&gt;CheckExpectedTypeCompatibility(sem_context);</a>
<a name="ln496">  }</a>
<a name="ln497">};</a>
<a name="ln498"> </a>
<a name="ln499">//--------------------------------------------------------------------------------------------------</a>
<a name="ln500">// Template for expression with one operand (1 input).</a>
<a name="ln501">template&lt;InternalType itype, DataType ytype, class expr_class = PTExpr&gt;</a>
<a name="ln502">class PTExpr1 : public expr_class {</a>
<a name="ln503"> public:</a>
<a name="ln504">  //------------------------------------------------------------------------------------------------</a>
<a name="ln505">  // Public types.</a>
<a name="ln506">  typedef MCSharedPtr&lt;PTExpr1&gt; SharedPtr;</a>
<a name="ln507">  typedef MCSharedPtr&lt;const PTExpr1&gt; SharedPtrConst;</a>
<a name="ln508"> </a>
<a name="ln509">  //------------------------------------------------------------------------------------------------</a>
<a name="ln510">  // Constructor and destructor.</a>
<a name="ln511">  PTExpr1(MemoryContext *memctx,</a>
<a name="ln512">          YBLocation::SharedPtr loc,</a>
<a name="ln513">          ExprOperator op,</a>
<a name="ln514">          yb::QLOperator ql_op,</a>
<a name="ln515">          PTExpr::SharedPtr op1)</a>
<a name="ln516">      : expr_class(memctx, loc, op, ql_op, itype, ytype),</a>
<a name="ln517">        op1_(op1) {</a>
<a name="ln518">  }</a>
<a name="ln519">  virtual ~PTExpr1() {</a>
<a name="ln520">  }</a>
<a name="ln521"> </a>
<a name="ln522">  // Shared pointer support.</a>
<a name="ln523">  template&lt;typename... TypeArgs&gt;</a>
<a name="ln524">  inline static PTExpr1::SharedPtr MakeShared(MemoryContext *memctx, TypeArgs&amp;&amp;... args) {</a>
<a name="ln525">    return MCMakeShared&lt;PTExpr1&gt;(memctx, std::forward&lt;TypeArgs&gt;(args)...);</a>
<a name="ln526">  }</a>
<a name="ln527"> </a>
<a name="ln528">  PTExpr::SharedPtr op1() const override {</a>
<a name="ln529">    return op1_;</a>
<a name="ln530">  }</a>
<a name="ln531"> </a>
<a name="ln532">  virtual CHECKED_STATUS Analyze(SemContext *sem_context) override {</a>
<a name="ln533">    // Before traversing the expression, check if this whole expression is actually a column.</a>
<a name="ln534">    if (this-&gt;CheckIndexColumn(sem_context)) {</a>
<a name="ln535">      return Status::OK();</a>
<a name="ln536">    }</a>
<a name="ln537"> </a>
<a name="ln538">    RETURN_NOT_OK(this-&gt;CheckOperator(sem_context));</a>
<a name="ln539"> </a>
<a name="ln540">    // Run semantic analysis on child nodes.</a>
<a name="ln541">    SemState sem_state(sem_context);</a>
<a name="ln542">    RETURN_NOT_OK(this-&gt;SetupSemStateForOp1(&amp;sem_state));</a>
<a name="ln543">    RETURN_NOT_OK(op1_-&gt;Analyze(sem_context));</a>
<a name="ln544">    sem_state.ResetContextState();</a>
<a name="ln545"> </a>
<a name="ln546">    // Analyze this node operator and setup its ql_type and internal_type_.</a>
<a name="ln547">    RETURN_NOT_OK(this-&gt;AnalyzeOperator(sem_context, op1_));</a>
<a name="ln548"> </a>
<a name="ln549">    // Make sure that it has valid data type.</a>
<a name="ln550">    return this-&gt;CheckExpectedTypeCompatibility(sem_context);</a>
<a name="ln551">  }</a>
<a name="ln552"> </a>
<a name="ln553"> protected:</a>
<a name="ln554">  //------------------------------------------------------------------------------------------------</a>
<a name="ln555">  // Operand.</a>
<a name="ln556">  PTExpr::SharedPtr op1_;</a>
<a name="ln557">};</a>
<a name="ln558"> </a>
<a name="ln559">//--------------------------------------------------------------------------------------------------</a>
<a name="ln560">// Template for expression with two operands (2 inputs).</a>
<a name="ln561">template&lt;InternalType itype, DataType ytype, class expr_class = PTExpr&gt;</a>
<a name="ln562">class PTExpr2 : public expr_class {</a>
<a name="ln563"> public:</a>
<a name="ln564">  //------------------------------------------------------------------------------------------------</a>
<a name="ln565">  // Public types.</a>
<a name="ln566">  typedef MCSharedPtr&lt;PTExpr2&gt; SharedPtr;</a>
<a name="ln567">  typedef MCSharedPtr&lt;const PTExpr2&gt; SharedPtrConst;</a>
<a name="ln568"> </a>
<a name="ln569">  //------------------------------------------------------------------------------------------------</a>
<a name="ln570">  // Constructor and destructor.</a>
<a name="ln571">  PTExpr2(MemoryContext *memctx,</a>
<a name="ln572">          YBLocation::SharedPtr loc,</a>
<a name="ln573">          ExprOperator op,</a>
<a name="ln574">          yb::QLOperator ql_op,</a>
<a name="ln575">          const PTExpr::SharedPtr&amp; op1,</a>
<a name="ln576">          const PTExpr::SharedPtr&amp; op2)</a>
<a name="ln577">      : expr_class(memctx, loc, op, ql_op, itype, ytype),</a>
<a name="ln578">        op1_(op1),</a>
<a name="ln579">        op2_(op2) {</a>
<a name="ln580">  }</a>
<a name="ln581">  virtual ~PTExpr2() {</a>
<a name="ln582">  }</a>
<a name="ln583"> </a>
<a name="ln584">  // Shared pointer support.</a>
<a name="ln585">  template&lt;typename... TypeArgs&gt;</a>
<a name="ln586">  inline static PTExpr2::SharedPtr MakeShared(MemoryContext *memctx, TypeArgs&amp;&amp;... args) {</a>
<a name="ln587">    return MCMakeShared&lt;PTExpr2&gt;(memctx, std::forward&lt;TypeArgs&gt;(args)...);</a>
<a name="ln588">  }</a>
<a name="ln589"> </a>
<a name="ln590">  PTExpr::SharedPtr op1() const override {</a>
<a name="ln591">    return op1_;</a>
<a name="ln592">  }</a>
<a name="ln593"> </a>
<a name="ln594">  PTExpr::SharedPtr op2() const override {</a>
<a name="ln595">    return op2_;</a>
<a name="ln596">  }</a>
<a name="ln597"> </a>
<a name="ln598">  virtual CHECKED_STATUS Analyze(SemContext *sem_context) override {</a>
<a name="ln599">    // Before traversing the expression, check if this whole expression is actually a column.</a>
<a name="ln600">    if (this-&gt;CheckIndexColumn(sem_context)) {</a>
<a name="ln601">      return Status::OK();</a>
<a name="ln602">    }</a>
<a name="ln603"> </a>
<a name="ln604">    RETURN_NOT_OK(this-&gt;CheckOperator(sem_context));</a>
<a name="ln605"> </a>
<a name="ln606">    // Run semantic analysis on child nodes.</a>
<a name="ln607">    SemState sem_state(sem_context);</a>
<a name="ln608">    RETURN_NOT_OK(this-&gt;SetupSemStateForOp1(&amp;sem_state));</a>
<a name="ln609">    RETURN_NOT_OK(op1_-&gt;Analyze(sem_context));</a>
<a name="ln610"> </a>
<a name="ln611">    RETURN_NOT_OK(this-&gt;SetupSemStateForOp2(&amp;sem_state));</a>
<a name="ln612">    RETURN_NOT_OK(op2_-&gt;Analyze(sem_context));</a>
<a name="ln613">    sem_state.ResetContextState();</a>
<a name="ln614"> </a>
<a name="ln615">    // Analyze this node operator and setup its ql_type and internal_type_.</a>
<a name="ln616">    RETURN_NOT_OK(this-&gt;AnalyzeOperator(sem_context, op1_, op2_));</a>
<a name="ln617"> </a>
<a name="ln618">    // Make sure that it has valid data type.</a>
<a name="ln619">    return this-&gt;CheckExpectedTypeCompatibility(sem_context);</a>
<a name="ln620">  }</a>
<a name="ln621"> </a>
<a name="ln622"> protected:</a>
<a name="ln623">  //------------------------------------------------------------------------------------------------</a>
<a name="ln624">  // Operand 1 and 2.</a>
<a name="ln625">  PTExpr::SharedPtr op1_;</a>
<a name="ln626">  PTExpr::SharedPtr op2_;</a>
<a name="ln627">};</a>
<a name="ln628"> </a>
<a name="ln629">//--------------------------------------------------------------------------------------------------</a>
<a name="ln630">// Template for expression with two operands (3 inputs).</a>
<a name="ln631">template&lt;InternalType itype, DataType ytype, class expr_class = PTExpr&gt;</a>
<a name="ln632">class PTExpr3 : public expr_class {</a>
<a name="ln633"> public:</a>
<a name="ln634">  //------------------------------------------------------------------------------------------------</a>
<a name="ln635">  // Public types.</a>
<a name="ln636">  typedef MCSharedPtr&lt;PTExpr3&gt; SharedPtr;</a>
<a name="ln637">  typedef MCSharedPtr&lt;const PTExpr3&gt; SharedPtrConst;</a>
<a name="ln638"> </a>
<a name="ln639">  //------------------------------------------------------------------------------------------------</a>
<a name="ln640">  // Constructor and destructor.</a>
<a name="ln641">  PTExpr3(MemoryContext *memctx,</a>
<a name="ln642">          YBLocation::SharedPtr loc,</a>
<a name="ln643">          ExprOperator op,</a>
<a name="ln644">          yb::QLOperator ql_op,</a>
<a name="ln645">          const PTExpr::SharedPtr&amp; op1,</a>
<a name="ln646">          const PTExpr::SharedPtr&amp; op2,</a>
<a name="ln647">          const PTExpr::SharedPtr&amp; op3)</a>
<a name="ln648">      : expr_class(memctx, loc, op, ql_op, itype, ytype),</a>
<a name="ln649">        op1_(op1),</a>
<a name="ln650">        op2_(op2),</a>
<a name="ln651">        op3_(op3) {</a>
<a name="ln652">  }</a>
<a name="ln653">  virtual ~PTExpr3() {</a>
<a name="ln654">  }</a>
<a name="ln655"> </a>
<a name="ln656">  // Shared pointer support.</a>
<a name="ln657">  template&lt;typename... TypeArgs&gt;</a>
<a name="ln658">  inline static PTExpr3::SharedPtr MakeShared(MemoryContext *memctx, TypeArgs&amp;&amp;... args) {</a>
<a name="ln659">    return MCMakeShared&lt;PTExpr3&gt;(memctx, std::forward&lt;TypeArgs&gt;(args)...);</a>
<a name="ln660">  }</a>
<a name="ln661"> </a>
<a name="ln662">  PTExpr::SharedPtr op1() const override {</a>
<a name="ln663">    return op1_;</a>
<a name="ln664">  }</a>
<a name="ln665"> </a>
<a name="ln666">  PTExpr::SharedPtr op2() const override {</a>
<a name="ln667">    return op2_;</a>
<a name="ln668">  }</a>
<a name="ln669"> </a>
<a name="ln670">  PTExpr::SharedPtr op3() const override {</a>
<a name="ln671">    return op3_;</a>
<a name="ln672">  }</a>
<a name="ln673"> </a>
<a name="ln674">  virtual CHECKED_STATUS Analyze(SemContext *sem_context) override {</a>
<a name="ln675">    // Before traversing the expression, check if this whole expression is actually a column.</a>
<a name="ln676">    if (this-&gt;CheckIndexColumn(sem_context)) {</a>
<a name="ln677">      return Status::OK();</a>
<a name="ln678">    }</a>
<a name="ln679"> </a>
<a name="ln680">    RETURN_NOT_OK(this-&gt;CheckOperator(sem_context));</a>
<a name="ln681"> </a>
<a name="ln682">    // Run semantic analysis on child nodes.</a>
<a name="ln683">    SemState sem_state(sem_context);</a>
<a name="ln684">    RETURN_NOT_OK(this-&gt;SetupSemStateForOp1(&amp;sem_state));</a>
<a name="ln685">    RETURN_NOT_OK(op1_-&gt;Analyze(sem_context));</a>
<a name="ln686"> </a>
<a name="ln687">    RETURN_NOT_OK(this-&gt;SetupSemStateForOp2(&amp;sem_state));</a>
<a name="ln688">    RETURN_NOT_OK(op2_-&gt;Analyze(sem_context));</a>
<a name="ln689"> </a>
<a name="ln690">    RETURN_NOT_OK(this-&gt;SetupSemStateForOp3(&amp;sem_state));</a>
<a name="ln691">    RETURN_NOT_OK(op3_-&gt;Analyze(sem_context));</a>
<a name="ln692">    sem_state.ResetContextState();</a>
<a name="ln693"> </a>
<a name="ln694">    // Analyze this node operator and setup its ql_type and internal_type_.</a>
<a name="ln695">    RETURN_NOT_OK(this-&gt;AnalyzeOperator(sem_context, op1_, op2_, op3_));</a>
<a name="ln696"> </a>
<a name="ln697">    // Make sure that it has valid data type.</a>
<a name="ln698">    return this-&gt;CheckExpectedTypeCompatibility(sem_context);</a>
<a name="ln699">  }</a>
<a name="ln700"> </a>
<a name="ln701"> protected:</a>
<a name="ln702">  //------------------------------------------------------------------------------------------------</a>
<a name="ln703">  // Operand 1 and 2.</a>
<a name="ln704">  PTExpr::SharedPtr op1_;</a>
<a name="ln705">  PTExpr::SharedPtr op2_;</a>
<a name="ln706">  PTExpr::SharedPtr op3_;</a>
<a name="ln707">};</a>
<a name="ln708"> </a>
<a name="ln709">//--------------------------------------------------------------------------------------------------</a>
<a name="ln710">// Tree node for constants</a>
<a name="ln711">//--------------------------------------------------------------------------------------------------</a>
<a name="ln712">// Template for constant expressions.</a>
<a name="ln713">template&lt;typename ReturnType&gt;</a>
<a name="ln714">class PTLiteral {</a>
<a name="ln715"> public:</a>
<a name="ln716">  explicit PTLiteral(ReturnType value) : value_(value) { }</a>
<a name="ln717"> </a>
<a name="ln718">  virtual ~PTLiteral() { }</a>
<a name="ln719"> </a>
<a name="ln720">  virtual ReturnType Eval() const { return value_; }</a>
<a name="ln721"> </a>
<a name="ln722">  virtual ReturnType value() const { return value_; }</a>
<a name="ln723"> </a>
<a name="ln724">  virtual string ToQLName(int64_t value) const {</a>
<a name="ln725">    return std::to_string(value);</a>
<a name="ln726">  }</a>
<a name="ln727"> </a>
<a name="ln728">  virtual string ToQLName(int32_t value) const {</a>
<a name="ln729">    return std::to_string(value);</a>
<a name="ln730">  }</a>
<a name="ln731"> </a>
<a name="ln732">  virtual string ToQLName(int16_t value) const {</a>
<a name="ln733">    return std::to_string(value);</a>
<a name="ln734">  }</a>
<a name="ln735"> </a>
<a name="ln736">  virtual string ToQLName(uint32_t value) const {</a>
<a name="ln737">    return std::to_string(value);</a>
<a name="ln738">  }</a>
<a name="ln739"> </a>
<a name="ln740">  virtual string ToQLName(long double value) const {</a>
<a name="ln741">    return std::to_string(value);</a>
<a name="ln742">  }</a>
<a name="ln743"> </a>
<a name="ln744">  virtual string ToQLName(float value) const {</a>
<a name="ln745">    return std::to_string(value);</a>
<a name="ln746">  }</a>
<a name="ln747"> </a>
<a name="ln748">  virtual string ToQLName(const string&amp; value) const {</a>
<a name="ln749">    return value;</a>
<a name="ln750">  }</a>
<a name="ln751"> </a>
<a name="ln752">  virtual string ToQLName(bool value) const {</a>
<a name="ln753">    return std::to_string(value);</a>
<a name="ln754">  }</a>
<a name="ln755"> </a>
<a name="ln756">  virtual string ToQLName(void *ptr) const {</a>
<a name="ln757">    return &quot;NULL&quot;;</a>
<a name="ln758">  }</a>
<a name="ln759"> </a>
<a name="ln760">  virtual string ToQLName(const MCSharedPtr&lt;MCString&gt;&amp; value) const {</a>
<a name="ln761">    return value-&gt;c_str();</a>
<a name="ln762">  }</a>
<a name="ln763"> </a>
<a name="ln764"> protected:</a>
<a name="ln765">  ReturnType value_;</a>
<a name="ln766">};</a>
<a name="ln767"> </a>
<a name="ln768">template&lt;InternalType itype, DataType ytype,</a>
<a name="ln769">         typename ReturnType, typename LiteralType = PTLiteral&lt;ReturnType&gt;&gt;</a>
<a name="ln770">class PTExprConst : public PTExpr0&lt;itype, ytype&gt;,</a>
<a name="ln771">                    public LiteralType {</a>
<a name="ln772"> public:</a>
<a name="ln773">  //------------------------------------------------------------------------------------------------</a>
<a name="ln774">  // Public types.</a>
<a name="ln775">  typedef MCSharedPtr&lt;PTExprConst&gt; SharedPtr;</a>
<a name="ln776">  typedef MCSharedPtr&lt;const PTExprConst&gt; SharedPtrConst;</a>
<a name="ln777"> </a>
<a name="ln778">  //------------------------------------------------------------------------------------------------</a>
<a name="ln779">  // Constructor and destructor.</a>
<a name="ln780">  PTExprConst(MemoryContext *memctx,</a>
<a name="ln781">              YBLocation::SharedPtr loc,</a>
<a name="ln782">              ReturnType value)</a>
<a name="ln783">      : PTExpr0&lt;itype, ytype&gt;(memctx, loc, ExprOperator::kConst, yb::QLOperator::QL_OP_NOOP),</a>
<a name="ln784">        LiteralType(value) {</a>
<a name="ln785">  }</a>
<a name="ln786">  virtual ~PTExprConst() {</a>
<a name="ln787">  }</a>
<a name="ln788"> </a>
<a name="ln789">  // Shared pointer support.</a>
<a name="ln790">  template&lt;typename... TypeArgs&gt;</a>
<a name="ln791">  inline static PTExprConst::SharedPtr MakeShared(MemoryContext *memctx, TypeArgs&amp;&amp;... args) {</a>
<a name="ln792">    return MCMakeShared&lt;PTExprConst&gt;(memctx, std::forward&lt;TypeArgs&gt;(args)...);</a>
<a name="ln793">  }</a>
<a name="ln794"> </a>
<a name="ln795">  using PTExpr0&lt;itype, ytype&gt;::AnalyzeOperator;</a>
<a name="ln796">  virtual CHECKED_STATUS AnalyzeOperator(SemContext *sem_context) override {</a>
<a name="ln797">    // Nothing to do: constant expressions should be initialized with valid data type already</a>
<a name="ln798">    return Status::OK();</a>
<a name="ln799">  };</a>
<a name="ln800"> </a>
<a name="ln801">  virtual string QLName(QLNameOption option = QLNameOption::kUserOriginalName)</a>
<a name="ln802">      const override {</a>
<a name="ln803">    return LiteralType::ToQLName(LiteralType::value());</a>
<a name="ln804">  }</a>
<a name="ln805"> </a>
<a name="ln806">  virtual bool HaveColumnRef() const override {</a>
<a name="ln807">    return false;</a>
<a name="ln808">  }</a>
<a name="ln809">};</a>
<a name="ln810"> </a>
<a name="ln811">// NULL constant.</a>
<a name="ln812">using PTConstArg = PTExprConst&lt;InternalType::VALUE_NOT_SET,</a>
<a name="ln813">                               DataType::UNKNOWN_DATA,</a>
<a name="ln814">                               void*&gt;;</a>
<a name="ln815"> </a>
<a name="ln816">using PTNull = PTExprConst&lt;InternalType::VALUE_NOT_SET,</a>
<a name="ln817">                           DataType::NULL_VALUE_TYPE,</a>
<a name="ln818">                           void*&gt;;</a>
<a name="ln819"> </a>
<a name="ln820">// This class is used only for the dummy (meaningless) '*' such as in COUNT(*).</a>
<a name="ln821">class PTStar : public PTNull {</a>
<a name="ln822"> public:</a>
<a name="ln823">  // Public types.</a>
<a name="ln824">  typedef MCSharedPtr&lt;PTStar&gt; SharedPtr;</a>
<a name="ln825">  typedef MCSharedPtr&lt;const PTStar&gt; SharedPtrConst;</a>
<a name="ln826"> </a>
<a name="ln827">  // Constructor and destructor.</a>
<a name="ln828">  PTStar(MemoryContext *memctx, YBLocation::SharedPtr loc)</a>
<a name="ln829">      : PTNull(memctx, loc, nullptr) {</a>
<a name="ln830">  }</a>
<a name="ln831"> </a>
<a name="ln832">  // Shared pointer support.</a>
<a name="ln833">  template&lt;typename... TypeArgs&gt;</a>
<a name="ln834">  inline static PTStar::SharedPtr MakeShared(MemoryContext *memctx, TypeArgs&amp;&amp;... args) {</a>
<a name="ln835">    return MCMakeShared&lt;PTStar&gt;(memctx, std::forward&lt;TypeArgs&gt;(args)...);</a>
<a name="ln836">  }</a>
<a name="ln837"> </a>
<a name="ln838">  virtual string QLName(QLNameOption option = QLNameOption::kUserOriginalName) const override {</a>
<a name="ln839">    return &quot;&quot;;</a>
<a name="ln840">  }</a>
<a name="ln841"> </a>
<a name="ln842">  virtual bool IsDummyStar() const override {</a>
<a name="ln843">    return true;</a>
<a name="ln844">  }</a>
<a name="ln845"> </a>
<a name="ln846">  virtual bool HaveColumnRef() const override {</a>
<a name="ln847">    return false;</a>
<a name="ln848">  }</a>
<a name="ln849">};</a>
<a name="ln850"> </a>
<a name="ln851">// String base classes for constant expression.</a>
<a name="ln852">class PTLiteralString : public PTLiteral&lt;MCSharedPtr&lt;MCString&gt;&gt; {</a>
<a name="ln853"> public:</a>
<a name="ln854">  explicit PTLiteralString(MCSharedPtr&lt;MCString&gt; value);</a>
<a name="ln855">  virtual ~PTLiteralString();</a>
<a name="ln856"> </a>
<a name="ln857">  CHECKED_STATUS ToInt64(int64_t *value, bool negate) const;</a>
<a name="ln858">  CHECKED_STATUS ToDouble(long double *value, bool negate) const;</a>
<a name="ln859">  CHECKED_STATUS ToDecimal(util::Decimal *value, bool negate) const;</a>
<a name="ln860">  CHECKED_STATUS ToDecimal(std::string *value, bool negate) const;</a>
<a name="ln861">  CHECKED_STATUS ToVarInt(std::string *value, bool negate) const;</a>
<a name="ln862"> </a>
<a name="ln863">  std::string ToString() const;</a>
<a name="ln864"> </a>
<a name="ln865">  CHECKED_STATUS ToString(std::string *value) const;</a>
<a name="ln866">  CHECKED_STATUS ToTimestamp(int64_t *value) const;</a>
<a name="ln867">  CHECKED_STATUS ToDate(uint32_t *value) const;</a>
<a name="ln868">  CHECKED_STATUS ToTime(int64_t *value) const;</a>
<a name="ln869"> </a>
<a name="ln870">  CHECKED_STATUS ToInetaddress(InetAddress *value) const;</a>
<a name="ln871">};</a>
<a name="ln872">using PTConstText = PTExprConst&lt;InternalType::kStringValue,</a>
<a name="ln873">                                DataType::STRING,</a>
<a name="ln874">                                MCSharedPtr&lt;MCString&gt;,</a>
<a name="ln875">                                PTLiteralString&gt;;</a>
<a name="ln876">using PTConstVarInt = PTExprConst&lt;InternalType::kVarintValue,</a>
<a name="ln877">                                  DataType::VARINT,</a>
<a name="ln878">                                  MCSharedPtr&lt;MCString&gt;,</a>
<a name="ln879">                                  PTLiteralString&gt;;</a>
<a name="ln880">using PTConstDecimal = PTExprConst&lt;InternalType::kDecimalValue,</a>
<a name="ln881">                                   DataType::DECIMAL,</a>
<a name="ln882">                                   MCSharedPtr&lt;MCString&gt;,</a>
<a name="ln883">                                   PTLiteralString&gt;;</a>
<a name="ln884">using PTConstUuid = PTExprConst&lt;InternalType::kUuidValue,</a>
<a name="ln885">                                DataType::UUID,</a>
<a name="ln886">                                MCSharedPtr&lt;MCString&gt;,</a>
<a name="ln887">                                PTLiteralString&gt;;</a>
<a name="ln888">using PTConstBinary = PTExprConst&lt;InternalType::kBinaryValue,</a>
<a name="ln889">                                  DataType::BINARY,</a>
<a name="ln890">                                  MCSharedPtr&lt;MCString&gt;,</a>
<a name="ln891">                                  PTLiteralString&gt;;</a>
<a name="ln892"> </a>
<a name="ln893">// Boolean constant.</a>
<a name="ln894">using PTConstBool = PTExprConst&lt;InternalType::kBoolValue,</a>
<a name="ln895">                                DataType::BOOL,</a>
<a name="ln896">                                bool&gt;;</a>
<a name="ln897"> </a>
<a name="ln898">// Obsolete numeric constant classes.</a>
<a name="ln899">using PTConstInt = PTExprConst&lt;InternalType::kInt64Value,</a>
<a name="ln900">                               DataType::INT64,</a>
<a name="ln901">                               int64_t&gt;;</a>
<a name="ln902"> </a>
<a name="ln903">using PTConstInt32 = PTExprConst&lt;InternalType::kInt32Value,</a>
<a name="ln904">                                 DataType::INT32,</a>
<a name="ln905">                                 int32_t&gt;;</a>
<a name="ln906"> </a>
<a name="ln907">using PTConstInt16 = PTExprConst&lt;InternalType::kInt16Value,</a>
<a name="ln908">                                 DataType::INT16,</a>
<a name="ln909">                                 int16_t&gt;;</a>
<a name="ln910"> </a>
<a name="ln911">using PTConstDouble = PTExprConst&lt;InternalType::kDoubleValue,</a>
<a name="ln912">                                  DataType::DOUBLE,</a>
<a name="ln913">                                  long double&gt;;</a>
<a name="ln914"> </a>
<a name="ln915">using PTConstFloat = PTExprConst&lt;InternalType::kFloatValue,</a>
<a name="ln916">                                 DataType::FLOAT,</a>
<a name="ln917">                                 float&gt;;</a>
<a name="ln918"> </a>
<a name="ln919">using PTConstTimestamp = PTExprConst&lt;InternalType::kTimestampValue,</a>
<a name="ln920">                                     DataType::TIMESTAMP,</a>
<a name="ln921">                                     int64_t&gt;;</a>
<a name="ln922"> </a>
<a name="ln923">using PTConstDate = PTExprConst&lt;InternalType::kDateValue,</a>
<a name="ln924">                                DataType::DATE,</a>
<a name="ln925">                                uint32_t&gt;;</a>
<a name="ln926"> </a>
<a name="ln927">// Class representing a json operator.</a>
<a name="ln928">class PTJsonOperator : public PTExpr {</a>
<a name="ln929"> public:</a>
<a name="ln930">  //------------------------------------------------------------------------------------------------</a>
<a name="ln931">  // Public types.</a>
<a name="ln932">  typedef MCSharedPtr&lt;PTJsonOperator&gt; SharedPtr;</a>
<a name="ln933">  typedef MCSharedPtr&lt;const PTJsonOperator&gt; SharedPtrConst;</a>
<a name="ln934"> </a>
<a name="ln935">  //------------------------------------------------------------------------------------------------</a>
<a name="ln936">  // Constructors and destructor.</a>
<a name="ln937">  PTJsonOperator(MemoryContext *memctx,</a>
<a name="ln938">                 YBLocation::SharedPtr loc,</a>
<a name="ln939">                 const JsonOperator&amp; json_operator,</a>
<a name="ln940">                 const PTExpr::SharedPtr&amp; arg);</a>
<a name="ln941"> </a>
<a name="ln942">  virtual ~PTJsonOperator();</a>
<a name="ln943"> </a>
<a name="ln944">  template&lt;typename... TypeArgs&gt;</a>
<a name="ln945">  inline static PTJsonOperator::SharedPtr MakeShared(MemoryContext *memctx,</a>
<a name="ln946">                                                     TypeArgs&amp;&amp;... args) {</a>
<a name="ln947">    return MCMakeShared&lt;PTJsonOperator&gt;(memctx, std::forward&lt;TypeArgs&gt;(args)...);</a>
<a name="ln948">  }</a>
<a name="ln949"> </a>
<a name="ln950">  // Node semantics analysis.</a>
<a name="ln951">  virtual CHECKED_STATUS Analyze(SemContext *sem_context) override;</a>
<a name="ln952"> </a>
<a name="ln953">  const PTExpr::SharedPtr&amp; arg() const {</a>
<a name="ln954">    return arg_;</a>
<a name="ln955">  }</a>
<a name="ln956"> </a>
<a name="ln957">  JsonOperator json_operator() const {</a>
<a name="ln958">    return json_operator_;</a>
<a name="ln959">  }</a>
<a name="ln960"> </a>
<a name="ln961">  // Selected name.</a>
<a name="ln962">  virtual string QLName(QLNameOption option = QLNameOption::kUserOriginalName) const override {</a>
<a name="ln963">    string jquote = &quot;'&quot;;</a>
<a name="ln964">    string op_name = json_operator_ == JsonOperator::JSON_OBJECT ? &quot;-&gt;&quot; : &quot;-&gt;&gt;&quot;;</a>
<a name="ln965">    string jattr = arg_-&gt;QLName(option);</a>
<a name="ln966">    if (option == QLNameOption::kMangledName) {</a>
<a name="ln967">      jattr = YcqlName::MangleJsonAttrName(jattr);</a>
<a name="ln968">    }</a>
<a name="ln969"> </a>
<a name="ln970">    return op_name + jquote + jattr + jquote;</a>
<a name="ln971">  }</a>
<a name="ln972"> </a>
<a name="ln973"> protected:</a>
<a name="ln974">  JsonOperator json_operator_;</a>
<a name="ln975">  PTExpr::SharedPtr arg_;</a>
<a name="ln976">};</a>
<a name="ln977"> </a>
<a name="ln978"> </a>
<a name="ln979"> </a>
<a name="ln980">//--------------------------------------------------------------------------------------------------</a>
<a name="ln981">// Tree node for logical expressions (AND, OR, NOT, ...).</a>
<a name="ln982">//--------------------------------------------------------------------------------------------------</a>
<a name="ln983">class PTLogicExpr : public PTExpr {</a>
<a name="ln984"> public:</a>
<a name="ln985">  explicit PTLogicExpr(</a>
<a name="ln986">      MemoryContext *memctx,</a>
<a name="ln987">      YBLocation::SharedPtr loc,</a>
<a name="ln988">      ExprOperator op = ExprOperator::kNoOp,</a>
<a name="ln989">      yb::QLOperator ql_op = yb::QLOperator::QL_OP_NOOP,</a>
<a name="ln990">      InternalType internal_type = InternalType::VALUE_NOT_SET,</a>
<a name="ln991">      DataType ql_type_id = DataType::BOOL)</a>
<a name="ln992">      : PTExpr(memctx, loc, op, ql_op, internal_type, ql_type_id) {</a>
<a name="ln993">  }</a>
<a name="ln994"> </a>
<a name="ln995">  // Setup states before analyzing operand.</a>
<a name="ln996">  virtual CHECKED_STATUS SetupSemStateForOp1(SemState *sem_state) override;</a>
<a name="ln997">  virtual CHECKED_STATUS SetupSemStateForOp2(SemState *sem_state) override;</a>
<a name="ln998"> </a>
<a name="ln999">  // Analyze this operator.</a>
<a name="ln1000">  using PTExpr::AnalyzeOperator;</a>
<a name="ln1001">  virtual CHECKED_STATUS AnalyzeOperator(SemContext *sem_context,</a>
<a name="ln1002">                                         PTExpr::SharedPtr op1) override;</a>
<a name="ln1003">  virtual CHECKED_STATUS AnalyzeOperator(SemContext *sem_context,</a>
<a name="ln1004">                                         PTExpr::SharedPtr op1,</a>
<a name="ln1005">                                         PTExpr::SharedPtr op2) override;</a>
<a name="ln1006">};</a>
<a name="ln1007">using PTLogic1 = PTExpr1&lt;InternalType::kBoolValue, DataType::BOOL, PTLogicExpr&gt;;</a>
<a name="ln1008">using PTLogic2 = PTExpr2&lt;InternalType::kBoolValue, DataType::BOOL, PTLogicExpr&gt;;</a>
<a name="ln1009"> </a>
<a name="ln1010">//--------------------------------------------------------------------------------------------------</a>
<a name="ln1011">// Tree node for relational expressions (=, !=, &gt;, ...).</a>
<a name="ln1012">//--------------------------------------------------------------------------------------------------</a>
<a name="ln1013">class PTRelationExpr : public PTExpr {</a>
<a name="ln1014"> public:</a>
<a name="ln1015">  explicit PTRelationExpr(</a>
<a name="ln1016">      MemoryContext *memctx,</a>
<a name="ln1017">      YBLocation::SharedPtr loc,</a>
<a name="ln1018">      ExprOperator op = ExprOperator::kNoOp,</a>
<a name="ln1019">      yb::QLOperator ql_op = yb::QLOperator::QL_OP_NOOP,</a>
<a name="ln1020">      InternalType internal_type = InternalType::VALUE_NOT_SET,</a>
<a name="ln1021">      DataType ql_type_id = DataType::BOOL)</a>
<a name="ln1022">      : PTExpr(memctx, loc, op, ql_op, internal_type, ql_type_id) {</a>
<a name="ln1023">  }</a>
<a name="ln1024"> </a>
<a name="ln1025">  // Setup states before analyzing operands.</a>
<a name="ln1026">  virtual CHECKED_STATUS SetupSemStateForOp1(SemState *sem_state) override;</a>
<a name="ln1027">  virtual CHECKED_STATUS SetupSemStateForOp2(SemState *sem_state) override;</a>
<a name="ln1028">  virtual CHECKED_STATUS SetupSemStateForOp3(SemState *sem_state) override;</a>
<a name="ln1029"> </a>
<a name="ln1030">  // Analyze this operator after all operands were analyzed.</a>
<a name="ln1031">  virtual CHECKED_STATUS AnalyzeOperator(SemContext *sem_context) override;</a>
<a name="ln1032">  virtual CHECKED_STATUS AnalyzeOperator(SemContext *sem_context,</a>
<a name="ln1033">                                         PTExpr::SharedPtr op1) override;</a>
<a name="ln1034">  virtual CHECKED_STATUS AnalyzeOperator(SemContext *sem_context,</a>
<a name="ln1035">                                         PTExpr::SharedPtr op1,</a>
<a name="ln1036">                                         PTExpr::SharedPtr op2) override;</a>
<a name="ln1037">  virtual CHECKED_STATUS AnalyzeOperator(SemContext *sem_context,</a>
<a name="ln1038">                                         PTExpr::SharedPtr op1,</a>
<a name="ln1039">                                         PTExpr::SharedPtr op2,</a>
<a name="ln1040">                                         PTExpr::SharedPtr op3) override;</a>
<a name="ln1041">  virtual string QLName(QLNameOption option = QLNameOption::kUserOriginalName) const override;</a>
<a name="ln1042">};</a>
<a name="ln1043">using PTRelation0 = PTExpr0&lt;InternalType::kBoolValue, DataType::BOOL, PTRelationExpr&gt;;</a>
<a name="ln1044">using PTRelation1 = PTExpr1&lt;InternalType::kBoolValue, DataType::BOOL, PTRelationExpr&gt;;</a>
<a name="ln1045">using PTRelation2 = PTExpr2&lt;InternalType::kBoolValue, DataType::BOOL, PTRelationExpr&gt;;</a>
<a name="ln1046">using PTRelation3 = PTExpr3&lt;InternalType::kBoolValue, DataType::BOOL, PTRelationExpr&gt;;</a>
<a name="ln1047"> </a>
<a name="ln1048">//--------------------------------------------------------------------------------------------------</a>
<a name="ln1049">// Tree node for operators.</a>
<a name="ln1050">// - Currently, we only have unary '-'.</a>
<a name="ln1051">// - Generally, we only need PTOperator for performance purposes. All operations can be supported</a>
<a name="ln1052">//   by adding it to builtin library, but that method is less efficient and PTOperator.</a>
<a name="ln1053">//--------------------------------------------------------------------------------------------------</a>
<a name="ln1054">class PTOperatorExpr : public PTExpr {</a>
<a name="ln1055"> public:</a>
<a name="ln1056">  explicit PTOperatorExpr(</a>
<a name="ln1057">      MemoryContext *memctx,</a>
<a name="ln1058">      YBLocation::SharedPtr loc,</a>
<a name="ln1059">      ExprOperator op = ExprOperator::kNoOp,</a>
<a name="ln1060">      yb::QLOperator ql_op = yb::QLOperator::QL_OP_NOOP,</a>
<a name="ln1061">      InternalType internal_type = InternalType::VALUE_NOT_SET,</a>
<a name="ln1062">      DataType ql_type_id = DataType::UNKNOWN_DATA)</a>
<a name="ln1063">      : PTExpr(memctx, loc, op, ql_op, internal_type, ql_type_id) {</a>
<a name="ln1064">  }</a>
<a name="ln1065"> </a>
<a name="ln1066">  // Setup states before analyzing operands.</a>
<a name="ln1067">  virtual CHECKED_STATUS SetupSemStateForOp1(SemState *sem_state) override;</a>
<a name="ln1068"> </a>
<a name="ln1069">  // Analyze this operator after all operands were analyzed.</a>
<a name="ln1070">  using PTExpr::AnalyzeOperator;</a>
<a name="ln1071">  virtual CHECKED_STATUS AnalyzeOperator(SemContext *sem_context, PTExpr::SharedPtr op1) override;</a>
<a name="ln1072">};</a>
<a name="ln1073"> </a>
<a name="ln1074">using PTOperator0 = PTExpr0&lt;InternalType::VALUE_NOT_SET, DataType::UNKNOWN_DATA, PTOperatorExpr&gt;;</a>
<a name="ln1075">using PTOperator1 = PTExpr1&lt;InternalType::VALUE_NOT_SET, DataType::UNKNOWN_DATA, PTOperatorExpr&gt;;</a>
<a name="ln1076">using PTOperator2 = PTExpr2&lt;InternalType::VALUE_NOT_SET, DataType::UNKNOWN_DATA, PTOperatorExpr&gt;;</a>
<a name="ln1077">using PTOperator3 = PTExpr3&lt;InternalType::VALUE_NOT_SET, DataType::UNKNOWN_DATA, PTOperatorExpr&gt;;</a>
<a name="ln1078"> </a>
<a name="ln1079">//--------------------------------------------------------------------------------------------------</a>
<a name="ln1080">// Column Reference. The datatype of this expression would need to be resolved by the analyzer.</a>
<a name="ln1081">class PTRef : public PTOperator0 {</a>
<a name="ln1082"> public:</a>
<a name="ln1083">  //------------------------------------------------------------------------------------------------</a>
<a name="ln1084">  // Public types.</a>
<a name="ln1085">  typedef MCSharedPtr&lt;PTRef&gt; SharedPtr;</a>
<a name="ln1086">  typedef MCSharedPtr&lt;const PTRef&gt; SharedPtrConst;</a>
<a name="ln1087"> </a>
<a name="ln1088">  //------------------------------------------------------------------------------------------------</a>
<a name="ln1089">  // Constructor and destructor.</a>
<a name="ln1090">  PTRef(MemoryContext *memctx,</a>
<a name="ln1091">        YBLocation::SharedPtr loc,</a>
<a name="ln1092">        const PTQualifiedName::SharedPtr&amp; name);</a>
<a name="ln1093">  virtual ~PTRef();</a>
<a name="ln1094"> </a>
<a name="ln1095">  // Support for shared_ptr.</a>
<a name="ln1096">  template&lt;typename... TypeArgs&gt;</a>
<a name="ln1097">  inline static PTRef::SharedPtr MakeShared(MemoryContext *memctx, TypeArgs&amp;&amp;... args) {</a>
<a name="ln1098">    return MCMakeShared&lt;PTRef&gt;(memctx, std::forward&lt;TypeArgs&gt;(args)...);</a>
<a name="ln1099">  }</a>
<a name="ln1100"> </a>
<a name="ln1101">  // Node semantics analysis.</a>
<a name="ln1102">  void PrintSemanticAnalysisResult(SemContext *sem_context);</a>
<a name="ln1103"> </a>
<a name="ln1104">  using PTOperatorExpr::AnalyzeOperator;</a>
<a name="ln1105">  virtual CHECKED_STATUS AnalyzeOperator(SemContext *sem_context) override;</a>
<a name="ln1106"> </a>
<a name="ln1107">  // Add the name of column that is being referenced to output parameter.</a>
<a name="ln1108">  void CollectReferencedIndexColnames(MCSet&lt;string&gt; *col_names) const override {</a>
<a name="ln1109">    col_names-&gt;insert(QLName(QLNameOption::kMangledName));</a>
<a name="ln1110">  }</a>
<a name="ln1111"> </a>
<a name="ln1112">  // Selected name.</a>
<a name="ln1113">  virtual string QLName(QLNameOption option = QLNameOption::kUserOriginalName) const override {</a>
<a name="ln1114">    if (option == QLNameOption::kMetadataName) {</a>
<a name="ln1115">      // Should only be called after the descriptor is loaded from the catalog by Analyze().</a>
<a name="ln1116">      CHECK(desc_) &lt;&lt; &quot;Metadata is not yet loaded to this node&quot;;</a>
<a name="ln1117">      return desc_-&gt;MetadataName();</a>
<a name="ln1118">    }</a>
<a name="ln1119"> </a>
<a name="ln1120">    if (option == QLNameOption::kMangledName) {</a>
<a name="ln1121">      return YcqlName::MangleColumnName(name_-&gt;QLName());</a>
<a name="ln1122">    }</a>
<a name="ln1123"> </a>
<a name="ln1124">    return name_-&gt;QLName();</a>
<a name="ln1125">  }</a>
<a name="ln1126"> </a>
<a name="ln1127">  // Access function for name.</a>
<a name="ln1128">  const PTQualifiedName::SharedPtr&amp; name() const {</a>
<a name="ln1129">    return name_;</a>
<a name="ln1130">  }</a>
<a name="ln1131"> </a>
<a name="ln1132">  // Construct bind variable name from the name of this column.</a>
<a name="ln1133">  const MCSharedPtr&lt;MCString&gt;&amp; bindvar_name() const {</a>
<a name="ln1134">    return name_-&gt;bindvar_name();</a>
<a name="ln1135">  }</a>
<a name="ln1136"> </a>
<a name="ln1137">  // Access function for descriptor.</a>
<a name="ln1138">  const ColumnDesc *desc() const {</a>
<a name="ln1139">    return desc_;</a>
<a name="ln1140">  }</a>
<a name="ln1141"> </a>
<a name="ln1142">  // Node type.</a>
<a name="ln1143">  virtual TreeNodeOpcode opcode() const override {</a>
<a name="ln1144">    return TreeNodeOpcode::kPTRef;</a>
<a name="ln1145">  }</a>
<a name="ln1146"> </a>
<a name="ln1147">  // Analyze LHS expression.</a>
<a name="ln1148">  virtual CHECKED_STATUS CheckLhsExpr(SemContext *sem_context) override;</a>
<a name="ln1149"> </a>
<a name="ln1150"> private:</a>
<a name="ln1151">  PTQualifiedName::SharedPtr name_;</a>
<a name="ln1152"> </a>
<a name="ln1153">  // Fields that should be resolved by semantic analysis.</a>
<a name="ln1154">  const ColumnDesc *desc_;</a>
<a name="ln1155">};</a>
<a name="ln1156"> </a>
<a name="ln1157">// A json column with json operators applied to the column.</a>
<a name="ln1158">class PTJsonColumnWithOperators : public PTOperator0 {</a>
<a name="ln1159"> public:</a>
<a name="ln1160">  //------------------------------------------------------------------------------------------------</a>
<a name="ln1161">  // Public types.</a>
<a name="ln1162">  typedef MCSharedPtr&lt;PTJsonColumnWithOperators&gt; SharedPtr;</a>
<a name="ln1163">  typedef MCSharedPtr&lt;const PTJsonColumnWithOperators&gt; SharedPtrConst;</a>
<a name="ln1164"> </a>
<a name="ln1165">  //------------------------------------------------------------------------------------------------</a>
<a name="ln1166">  // Constructor and destructor.</a>
<a name="ln1167">  PTJsonColumnWithOperators(MemoryContext *memctx,</a>
<a name="ln1168">                            YBLocation::SharedPtr loc,</a>
<a name="ln1169">                            const PTQualifiedName::SharedPtr&amp; name,</a>
<a name="ln1170">                            const PTExprListNode::SharedPtr&amp; operators);</a>
<a name="ln1171">  virtual ~PTJsonColumnWithOperators();</a>
<a name="ln1172"> </a>
<a name="ln1173">  // Support for shared_ptr.</a>
<a name="ln1174">  template&lt;typename... TypeArgs&gt;</a>
<a name="ln1175">  inline static PTJsonColumnWithOperators::SharedPtr MakeShared(MemoryContext *memctx,</a>
<a name="ln1176">                                                          TypeArgs&amp;&amp;... args) {</a>
<a name="ln1177">    return MCMakeShared&lt;PTJsonColumnWithOperators&gt;(memctx, std::forward&lt;TypeArgs&gt;(args)...);</a>
<a name="ln1178">  }</a>
<a name="ln1179"> </a>
<a name="ln1180">  using PTOperatorExpr::AnalyzeOperator;</a>
<a name="ln1181">  virtual CHECKED_STATUS AnalyzeOperator(SemContext *sem_context) override;</a>
<a name="ln1182"> </a>
<a name="ln1183">  // Access function for name.</a>
<a name="ln1184">  const PTQualifiedName::SharedPtr&amp; name() const {</a>
<a name="ln1185">    return name_;</a>
<a name="ln1186">  }</a>
<a name="ln1187"> </a>
<a name="ln1188">  // Add the name of this JSONB expression to output parameter.</a>
<a name="ln1189">  void CollectReferencedIndexColnames(MCSet&lt;string&gt; *col_names) const override {</a>
<a name="ln1190">    col_names-&gt;insert(QLName(QLNameOption::kMangledName));</a>
<a name="ln1191">  }</a>
<a name="ln1192"> </a>
<a name="ln1193">  // Selected name.</a>
<a name="ln1194">  virtual string QLName(QLNameOption option = QLNameOption::kUserOriginalName) const override {</a>
<a name="ln1195">    string qlname;</a>
<a name="ln1196">    if (option == QLNameOption::kMetadataName) {</a>
<a name="ln1197">      DCHECK(desc_) &lt;&lt; &quot;Metadata is not yet loaded to this node&quot;;</a>
<a name="ln1198">      qlname = desc_-&gt;MetadataName();</a>
<a name="ln1199">    } else if (option == QLNameOption::kMangledName) {</a>
<a name="ln1200">      qlname = YcqlName::MangleColumnName(name_-&gt;QLName());</a>
<a name="ln1201">    } else {</a>
<a name="ln1202">      qlname = name_-&gt;QLName();</a>
<a name="ln1203">    }</a>
<a name="ln1204"> </a>
<a name="ln1205">    for (PTExpr::SharedPtr expr : operators_-&gt;node_list()) {</a>
<a name="ln1206">      qlname += expr-&gt;QLName(option);</a>
<a name="ln1207">    }</a>
<a name="ln1208">    return qlname;</a>
<a name="ln1209">  }</a>
<a name="ln1210"> </a>
<a name="ln1211">  const PTExprListNode::SharedPtr&amp; operators() const {</a>
<a name="ln1212">    return operators_;</a>
<a name="ln1213">  }</a>
<a name="ln1214"> </a>
<a name="ln1215">  // Access function for descriptor.</a>
<a name="ln1216">  const ColumnDesc *desc() const {</a>
<a name="ln1217">    return desc_;</a>
<a name="ln1218">  }</a>
<a name="ln1219"> </a>
<a name="ln1220">  // Node type.</a>
<a name="ln1221">  virtual TreeNodeOpcode opcode() const override {</a>
<a name="ln1222">    return TreeNodeOpcode::kPTJsonOp;</a>
<a name="ln1223">  }</a>
<a name="ln1224"> </a>
<a name="ln1225">  // Analyze LHS expression.</a>
<a name="ln1226">  virtual CHECKED_STATUS CheckLhsExpr(SemContext *sem_context) override;</a>
<a name="ln1227"> </a>
<a name="ln1228"> private:</a>
<a name="ln1229">  PTQualifiedName::SharedPtr name_;</a>
<a name="ln1230">  PTExprListNode::SharedPtr operators_;</a>
<a name="ln1231"> </a>
<a name="ln1232">  // Fields that should be resolved by semantic analysis.</a>
<a name="ln1233">  const ColumnDesc *desc_ = nullptr;</a>
<a name="ln1234">};</a>
<a name="ln1235"> </a>
<a name="ln1236">// SubColumn Reference. The datatype of this expression would need to be resolved by the analyzer.</a>
<a name="ln1237">class PTSubscriptedColumn : public PTOperator0 {</a>
<a name="ln1238"> public:</a>
<a name="ln1239">  //------------------------------------------------------------------------------------------------</a>
<a name="ln1240">  // Public types.</a>
<a name="ln1241">  typedef MCSharedPtr&lt;PTSubscriptedColumn&gt; SharedPtr;</a>
<a name="ln1242">  typedef MCSharedPtr&lt;const PTSubscriptedColumn&gt; SharedPtrConst;</a>
<a name="ln1243"> </a>
<a name="ln1244">  //------------------------------------------------------------------------------------------------</a>
<a name="ln1245">  // Constructor and destructor.</a>
<a name="ln1246">  PTSubscriptedColumn(MemoryContext *memctx,</a>
<a name="ln1247">        YBLocation::SharedPtr loc,</a>
<a name="ln1248">        const PTQualifiedName::SharedPtr&amp; name,</a>
<a name="ln1249">        const PTExprListNode::SharedPtr&amp; args);</a>
<a name="ln1250">  virtual ~PTSubscriptedColumn();</a>
<a name="ln1251"> </a>
<a name="ln1252">  // Support for shared_ptr.</a>
<a name="ln1253">  template&lt;typename... TypeArgs&gt;</a>
<a name="ln1254">  inline static PTSubscriptedColumn::SharedPtr MakeShared(MemoryContext *memctx,</a>
<a name="ln1255">                                                          TypeArgs&amp;&amp;... args) {</a>
<a name="ln1256">    return MCMakeShared&lt;PTSubscriptedColumn&gt;(memctx, std::forward&lt;TypeArgs&gt;(args)...);</a>
<a name="ln1257">  }</a>
<a name="ln1258"> </a>
<a name="ln1259">  // Node semantics analysis.</a>
<a name="ln1260">  void PrintSemanticAnalysisResult(SemContext *sem_context);</a>
<a name="ln1261"> </a>
<a name="ln1262">  using PTOperatorExpr::AnalyzeOperator;</a>
<a name="ln1263">  virtual CHECKED_STATUS AnalyzeOperator(SemContext *sem_context) override;</a>
<a name="ln1264"> </a>
<a name="ln1265">  // Access function for name.</a>
<a name="ln1266">  const PTQualifiedName::SharedPtr&amp; name() const {</a>
<a name="ln1267">    return name_;</a>
<a name="ln1268">  }</a>
<a name="ln1269"> </a>
<a name="ln1270">  // Access function for name.</a>
<a name="ln1271">  const PTExprListNode::SharedPtr&amp; args() const {</a>
<a name="ln1272">    return args_;</a>
<a name="ln1273">  }</a>
<a name="ln1274"> </a>
<a name="ln1275">  // Construct bind variable name from the name of this column.</a>
<a name="ln1276">  const MCSharedPtr&lt;MCString&gt;&amp; bindvar_name() const {</a>
<a name="ln1277">    return name_-&gt;bindvar_name();</a>
<a name="ln1278">  }</a>
<a name="ln1279"> </a>
<a name="ln1280">  // Access function for descriptor.</a>
<a name="ln1281">  const ColumnDesc *desc() const {</a>
<a name="ln1282">    return desc_;</a>
<a name="ln1283">  }</a>
<a name="ln1284"> </a>
<a name="ln1285">  // Node type.</a>
<a name="ln1286">  virtual TreeNodeOpcode opcode() const override {</a>
<a name="ln1287">    return TreeNodeOpcode::kPTSubscript;</a>
<a name="ln1288">  }</a>
<a name="ln1289"> </a>
<a name="ln1290">  // Analyze LHS expression.</a>
<a name="ln1291">  virtual CHECKED_STATUS CheckLhsExpr(SemContext *sem_context) override;</a>
<a name="ln1292"> </a>
<a name="ln1293"> private:</a>
<a name="ln1294">  PTQualifiedName::SharedPtr name_;</a>
<a name="ln1295">  PTExprListNode::SharedPtr args_;</a>
<a name="ln1296"> </a>
<a name="ln1297">  // Fields that should be resolved by semantic analysis.</a>
<a name="ln1298">  const ColumnDesc *desc_;</a>
<a name="ln1299">};</a>
<a name="ln1300"> </a>
<a name="ln1301">//--------------------------------------------------------------------------------------------------</a>
<a name="ln1302">// Reference to all columns of all selected tables.</a>
<a name="ln1303">class PTAllColumns : public PTOperator0 {</a>
<a name="ln1304"> public:</a>
<a name="ln1305">  //------------------------------------------------------------------------------------------------</a>
<a name="ln1306">  // Public types.</a>
<a name="ln1307">  typedef MCSharedPtr&lt;PTAllColumns&gt; SharedPtr;</a>
<a name="ln1308">  typedef MCSharedPtr&lt;const PTAllColumns&gt; SharedPtrConst;</a>
<a name="ln1309"> </a>
<a name="ln1310">  //------------------------------------------------------------------------------------------------</a>
<a name="ln1311">  // Constructor and destructor.</a>
<a name="ln1312">  PTAllColumns(MemoryContext *memctx, YBLocation::SharedPtr loc);</a>
<a name="ln1313">  virtual ~PTAllColumns();</a>
<a name="ln1314"> </a>
<a name="ln1315">  // Support for shared_ptr.</a>
<a name="ln1316">  template&lt;typename... TypeArgs&gt;</a>
<a name="ln1317">  inline static PTAllColumns::SharedPtr MakeShared(MemoryContext *memctx, TypeArgs&amp;&amp;... args) {</a>
<a name="ln1318">    return MCMakeShared&lt;PTAllColumns&gt;(memctx, std::forward&lt;TypeArgs&gt;(args)...);</a>
<a name="ln1319">  }</a>
<a name="ln1320"> </a>
<a name="ln1321">  using PTOperatorExpr::AnalyzeOperator;</a>
<a name="ln1322">  virtual CHECKED_STATUS AnalyzeOperator(SemContext *sem_context) override;</a>
<a name="ln1323"> </a>
<a name="ln1324">  // Node type.</a>
<a name="ln1325">  virtual TreeNodeOpcode opcode() const override {</a>
<a name="ln1326">    return TreeNodeOpcode::kPTAllColumns;</a>
<a name="ln1327">  }</a>
<a name="ln1328"> </a>
<a name="ln1329">  virtual string QLName(QLNameOption option = QLNameOption::kUserOriginalName) const override {</a>
<a name="ln1330">    // We should not get here as '*' should have been converted into a list of column name before</a>
<a name="ln1331">    // the selected tuple is constructed and described.</a>
<a name="ln1332">    VLOG(3) &lt;&lt; &quot;Calling QLName for '*' is not expected&quot;;</a>
<a name="ln1333">    return &quot;*&quot;;</a>
<a name="ln1334">  }</a>
<a name="ln1335"> </a>
<a name="ln1336">  const MCVector&lt;ColumnDesc&gt;&amp; columns() const {</a>
<a name="ln1337">    return columns_;</a>
<a name="ln1338">  }</a>
<a name="ln1339"> </a>
<a name="ln1340"> private:</a>
<a name="ln1341">  // Fields that should be resolved by semantic analysis.</a>
<a name="ln1342">  MCVector&lt;ColumnDesc&gt; columns_;</a>
<a name="ln1343">};</a>
<a name="ln1344"> </a>
<a name="ln1345">//--------------------------------------------------------------------------------------------------</a>
<a name="ln1346">// Expression alias - Name of an expression including reference to column.</a>
<a name="ln1347">class PTExprAlias : public PTOperator1 {</a>
<a name="ln1348"> public:</a>
<a name="ln1349">  //------------------------------------------------------------------------------------------------</a>
<a name="ln1350">  // Public types.</a>
<a name="ln1351">  typedef MCSharedPtr&lt;PTExprAlias&gt; SharedPtr;</a>
<a name="ln1352">  typedef MCSharedPtr&lt;const PTExprAlias&gt; SharedPtrConst;</a>
<a name="ln1353"> </a>
<a name="ln1354">  //------------------------------------------------------------------------------------------------</a>
<a name="ln1355">  // Constructor and destructor.</a>
<a name="ln1356">  PTExprAlias(MemoryContext *memctx,</a>
<a name="ln1357">              YBLocation::SharedPtr loc,</a>
<a name="ln1358">              const PTExpr::SharedPtr&amp; expr,</a>
<a name="ln1359">              const MCSharedPtr&lt;MCString&gt;&amp; alias);</a>
<a name="ln1360">  virtual ~PTExprAlias();</a>
<a name="ln1361"> </a>
<a name="ln1362">  // Support for shared_ptr.</a>
<a name="ln1363">  template&lt;typename... TypeArgs&gt;</a>
<a name="ln1364">  inline static PTExprAlias::SharedPtr MakeShared(MemoryContext *memctx, TypeArgs&amp;&amp;... args) {</a>
<a name="ln1365">    return MCMakeShared&lt;PTExprAlias&gt;(memctx, std::forward&lt;TypeArgs&gt;(args)...);</a>
<a name="ln1366">  }</a>
<a name="ln1367"> </a>
<a name="ln1368">  virtual CHECKED_STATUS SetupSemStateForOp1(SemState *sem_state) override;</a>
<a name="ln1369"> </a>
<a name="ln1370">  using PTOperatorExpr::AnalyzeOperator;</a>
<a name="ln1371">  virtual CHECKED_STATUS AnalyzeOperator(SemContext *sem_context, PTExpr::SharedPtr op1) override;</a>
<a name="ln1372"> </a>
<a name="ln1373">  virtual string QLName(QLNameOption option = QLNameOption::kUserOriginalName) const override {</a>
<a name="ln1374">    return alias_-&gt;c_str();</a>
<a name="ln1375">  }</a>
<a name="ln1376"> </a>
<a name="ln1377">  // Alias result set column type in QL format.</a>
<a name="ln1378">  virtual void rscol_type_PB(QLTypePB *pb_type) const override {</a>
<a name="ln1379">    return op1_-&gt;rscol_type_PB(pb_type);</a>
<a name="ln1380">  }</a>
<a name="ln1381"> </a>
<a name="ln1382">  // Predicate for calls to aggregate functions.</a>
<a name="ln1383">  virtual bool IsAggregateCall() const override {</a>
<a name="ln1384">    return (op1_ != nullptr &amp;&amp; op1_-&gt;IsAggregateCall());</a>
<a name="ln1385">  }</a>
<a name="ln1386">  virtual yb::bfql::TSOpcode aggregate_opcode() const override {</a>
<a name="ln1387">    DCHECK(op1_ != nullptr) &lt;&lt; &quot;Reading aggregate opcode from a NULL operator&quot;;</a>
<a name="ln1388">    return op1_-&gt;aggregate_opcode();</a>
<a name="ln1389">  }</a>
<a name="ln1390"> </a>
<a name="ln1391"> private:</a>
<a name="ln1392">  MCSharedPtr&lt;MCString&gt; alias_;</a>
<a name="ln1393">};</a>
<a name="ln1394"> </a>
<a name="ln1395">//--------------------------------------------------------------------------------------------------</a>
<a name="ln1396">// Bind variable. The datatype of this expression would need to be resolved by the analyzer.</a>
<a name="ln1397">class PTBindVar : public PTExpr {</a>
<a name="ln1398"> public:</a>
<a name="ln1399">  //------------------------------------------------------------------------------------------------</a>
<a name="ln1400">  // Public types.</a>
<a name="ln1401">  typedef MCSharedPtr&lt;PTBindVar&gt; SharedPtr;</a>
<a name="ln1402">  typedef MCSharedPtr&lt;const PTBindVar&gt; SharedPtrConst;</a>
<a name="ln1403"> </a>
<a name="ln1404">  // Compare 2 bind variable positions in a statement.</a>
<a name="ln1405">  struct SetCmp {</a>
<a name="ln1406">    bool operator() (const PTBindVar* v1, const PTBindVar* v2) const {</a>
<a name="ln1407">      const YBLocation&amp; l1 = v1-&gt;loc();</a>
<a name="ln1408">      const YBLocation&amp; l2 = v2-&gt;loc();</a>
<a name="ln1409">      return (l1.BeginLine() &lt; l2.BeginLine() ||</a>
<a name="ln1410">              (l1.BeginLine() == l2.BeginLine() &amp;&amp; l1.BeginColumn() &lt; l2.BeginColumn()));</a>
<a name="ln1411">    }</a>
<a name="ln1412">  };</a>
<a name="ln1413"> </a>
<a name="ln1414">  // Compare 2 bind variables for their hash column ids.</a>
<a name="ln1415">  struct HashColCmp {</a>
<a name="ln1416">    bool operator() (const PTBindVar* v1, const PTBindVar* v2) const {</a>
<a name="ln1417">      DCHECK(v1-&gt;hash_col() != nullptr) &lt;&lt; &quot;bindvar pos &quot; &lt;&lt; v1-&gt;pos() &lt;&lt; &quot; is not a hash column&quot;;</a>
<a name="ln1418">      DCHECK(v2-&gt;hash_col() != nullptr) &lt;&lt; &quot;bindvar pos &quot; &lt;&lt; v2-&gt;pos() &lt;&lt; &quot; is not a hash column&quot;;</a>
<a name="ln1419">      return v1-&gt;hash_col()-&gt;id() &lt; v2-&gt;hash_col()-&gt;id();</a>
<a name="ln1420">    }</a>
<a name="ln1421">  };</a>
<a name="ln1422"> </a>
<a name="ln1423">  //------------------------------------------------------------------------------------------------</a>
<a name="ln1424">  // Constructor and destructor.</a>
<a name="ln1425">  PTBindVar(MemoryContext *memctx,</a>
<a name="ln1426">            YBLocation::SharedPtr loc,</a>
<a name="ln1427">            const MCSharedPtr&lt;MCString&gt;&amp; name = nullptr);</a>
<a name="ln1428">  PTBindVar(MemoryContext *memctx,</a>
<a name="ln1429">            YBLocation::SharedPtr loc,</a>
<a name="ln1430">            PTConstVarInt::SharedPtr user_pos);</a>
<a name="ln1431">  virtual ~PTBindVar();</a>
<a name="ln1432"> </a>
<a name="ln1433">  // Support for shared_ptr.</a>
<a name="ln1434">  template&lt;typename... TypeArgs&gt;</a>
<a name="ln1435">  inline static PTBindVar::SharedPtr MakeShared(MemoryContext *memctx, TypeArgs&amp;&amp;... args) {</a>
<a name="ln1436">    return MCMakeShared&lt;PTBindVar&gt;(memctx, std::forward&lt;TypeArgs&gt;(args)...);</a>
<a name="ln1437">  }</a>
<a name="ln1438"> </a>
<a name="ln1439">  // Node semantics analysis.</a>
<a name="ln1440">  virtual CHECKED_STATUS Analyze(SemContext *sem_context) override;</a>
<a name="ln1441">  void PrintSemanticAnalysisResult(SemContext *sem_context);</a>
<a name="ln1442"> </a>
<a name="ln1443">  // Access functions for position.</a>
<a name="ln1444">  int64_t pos() const {</a>
<a name="ln1445">    return *pos_;</a>
<a name="ln1446">  }</a>
<a name="ln1447">  void set_pos(const int64_t pos) {</a>
<a name="ln1448">    pos_ = pos;</a>
<a name="ln1449">  }</a>
<a name="ln1450">  bool is_unset_pos() const {</a>
<a name="ln1451">    return !pos_;</a>
<a name="ln1452">  }</a>
<a name="ln1453"> </a>
<a name="ln1454">  // Access functions for name.</a>
<a name="ln1455">  const MCSharedPtr&lt;MCString&gt;&amp; name() const {</a>
<a name="ln1456">    return name_;</a>
<a name="ln1457">  }</a>
<a name="ln1458"> </a>
<a name="ln1459">  // Access function for hash column if available.</a>
<a name="ln1460">  const ColumnDesc *hash_col() const {</a>
<a name="ln1461">    return hash_col_;</a>
<a name="ln1462">  }</a>
<a name="ln1463"> </a>
<a name="ln1464">  // Node type.</a>
<a name="ln1465">  virtual TreeNodeOpcode opcode() const override {</a>
<a name="ln1466">    return TreeNodeOpcode::kPTBindVar;</a>
<a name="ln1467">  }</a>
<a name="ln1468"> </a>
<a name="ln1469">  virtual string QLName(QLNameOption option = QLNameOption::kUserOriginalName) const override {</a>
<a name="ln1470">    string qlname = (user_pos_) ? user_pos_-&gt;ToString() : name()-&gt;c_str();</a>
<a name="ln1471">    return &quot;:&quot; +  qlname;</a>
<a name="ln1472">  }</a>
<a name="ln1473"> </a>
<a name="ln1474">  // Access to op_.</a>
<a name="ln1475">  virtual ExprOperator expr_op() const override {</a>
<a name="ln1476">    return ExprOperator::kBindVar;</a>
<a name="ln1477">  }</a>
<a name="ln1478"> </a>
<a name="ln1479">  // The name Cassandra uses for the virtual column when binding LIMIT clause</a>
<a name="ln1480">  static const string&amp; limit_bindvar_name() {</a>
<a name="ln1481">    static string limit_bindvar_name = &quot;[limit]&quot;;</a>
<a name="ln1482">    return limit_bindvar_name;</a>
<a name="ln1483">  }</a>
<a name="ln1484"> </a>
<a name="ln1485">  // The name Cassandra uses for the virtual column when binding OFFSET clause</a>
<a name="ln1486">  static const string&amp; offset_bindvar_name() {</a>
<a name="ln1487">    static string offset_bindvar_name = &quot;[offset]&quot;;</a>
<a name="ln1488">    return offset_bindvar_name;</a>
<a name="ln1489">  }</a>
<a name="ln1490"> </a>
<a name="ln1491">  // The name Cassandra uses for the virtual column when binding USING TTL clause</a>
<a name="ln1492">  static const string&amp; ttl_bindvar_name() {</a>
<a name="ln1493">    static string ttl_bindvar_name = &quot;[ttl]&quot;;</a>
<a name="ln1494">    return ttl_bindvar_name;</a>
<a name="ln1495">  }</a>
<a name="ln1496"> </a>
<a name="ln1497">  // The name Cassandra uses for the virtual column when binding USING TIMESTAMP clause</a>
<a name="ln1498">  static const string&amp; timestamp_bindvar_name() {</a>
<a name="ln1499">    static string timestamp_bindvar_name = &quot;[timestamp]&quot;;</a>
<a name="ln1500">    return timestamp_bindvar_name;</a>
<a name="ln1501">  }</a>
<a name="ln1502"> </a>
<a name="ln1503">  // The name Cassandra uses for the virtual column when binding the partition key (i.e. with token)</a>
<a name="ln1504">  static const string&amp; token_bindvar_name() {</a>
<a name="ln1505">    static string token_bindvar_name = &quot;partition key token&quot;;</a>
<a name="ln1506">    return token_bindvar_name;</a>
<a name="ln1507">  }</a>
<a name="ln1508"> </a>
<a name="ln1509">  // Name used for binding the 'partition_hash()' builtin function.</a>
<a name="ln1510">  static const string&amp; partition_hash_bindvar_name() {</a>
<a name="ln1511">    static string partition_hash_bindvar_name = &quot;[partition_hash]&quot;;</a>
<a name="ln1512">    return partition_hash_bindvar_name;</a>
<a name="ln1513">  }</a>
<a name="ln1514"> </a>
<a name="ln1515">  // The name Cassandra uses for binding the args of a builtin system call e.g. &quot;token(?, ?)&quot;</a>
<a name="ln1516">  static const string bcall_arg_bindvar_name(const string&amp; bcall_name, size_t arg_position) {</a>
<a name="ln1517">    return strings::Substitute(&quot;arg$0(system.$1)&quot;, arg_position, bcall_name);</a>
<a name="ln1518">  }</a>
<a name="ln1519"> </a>
<a name="ln1520">  // The name Cassandra uses for binding the collection elements.</a>
<a name="ln1521">  static const string coll_bindvar_name(const string&amp; col_name) {</a>
<a name="ln1522">    return strings::Substitute(&quot;value($0)&quot;, col_name);</a>
<a name="ln1523">  }</a>
<a name="ln1524"> </a>
<a name="ln1525">  // The name for binding the JSON attributes.</a>
<a name="ln1526">  static const string json_bindvar_name(const string&amp; col_name) {</a>
<a name="ln1527">    return strings::Substitute(&quot;json_attr($0)&quot;, col_name);</a>
<a name="ln1528">  }</a>
<a name="ln1529"> </a>
<a name="ln1530">  // Use the binding name by default (if no other cases applicable).</a>
<a name="ln1531">  static const string&amp; default_bindvar_name() {</a>
<a name="ln1532">    static string default_bindvar_name = &quot;expr&quot;;</a>
<a name="ln1533">    return default_bindvar_name;</a>
<a name="ln1534">  }</a>
<a name="ln1535"> </a>
<a name="ln1536"> private:</a>
<a name="ln1537">  // 0-based position.</a>
<a name="ln1538">  PTConstVarInt::SharedPtr user_pos_; // pos used for parsing.</a>
<a name="ln1539">  boost::optional&lt;int64_t&gt; pos_; // pos after parsing is done.</a>
<a name="ln1540">  // Variable name.</a>
<a name="ln1541">  MCSharedPtr&lt;MCString&gt; name_;</a>
<a name="ln1542">  // Hash column descriptor.</a>
<a name="ln1543">  const ColumnDesc *hash_col_ = nullptr;</a>
<a name="ln1544">};</a>
<a name="ln1545"> </a>
<a name="ln1546">}  // namespace ql</a>
<a name="ln1547">}  // namespace yb</a>
<a name="ln1548"> </a>
<a name="ln1549">#endif  // YB_YQL_CQL_QL_PTREE_PT_EXPR_H_</a>

</code></pre>
<div class="balloon" rel="1116"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1197"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1332"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1387"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1417"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1418"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
