
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>regex.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// class template regex -*- C++ -*-</a>
<a name="ln2"> </a>
<a name="ln3">// Copyright (C) 2010-2018 Free Software Foundation, Inc.</a>
<a name="ln4">//</a>
<a name="ln5">// This file is part of the GNU ISO C++ Library.  This library is free</a>
<a name="ln6">// software; you can redistribute it and/or modify it under the</a>
<a name="ln7">// terms of the GNU General Public License as published by the</a>
<a name="ln8">// Free Software Foundation; either version 3, or (at your option)</a>
<a name="ln9">// any later version.</a>
<a name="ln10"> </a>
<a name="ln11">// This library is distributed in the hope that it will be useful,</a>
<a name="ln12">// but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">// GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">// Under Section 7 of GPL version 3, you are granted additional</a>
<a name="ln17">// permissions described in the GCC Runtime Library Exception, version</a>
<a name="ln18">// 3.1, as published by the Free Software Foundation.</a>
<a name="ln19"> </a>
<a name="ln20">// You should have received a copy of the GNU General Public License and</a>
<a name="ln21">// a copy of the GCC Runtime Library Exception along with this program;</a>
<a name="ln22">// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see</a>
<a name="ln23">// &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln24"> </a>
<a name="ln25">/**</a>
<a name="ln26"> *  @file bits/regex.h</a>
<a name="ln27"> *  This is an internal header file, included by other library headers.</a>
<a name="ln28"> *  Do not attempt to use it directly. @headername{regex}</a>
<a name="ln29"> */</a>
<a name="ln30"> </a>
<a name="ln31">namespace std _GLIBCXX_VISIBILITY(default)</a>
<a name="ln32">{</a>
<a name="ln33">_GLIBCXX_BEGIN_NAMESPACE_VERSION</a>
<a name="ln34">_GLIBCXX_BEGIN_NAMESPACE_CXX11</a>
<a name="ln35">  template&lt;typename, typename&gt;</a>
<a name="ln36">    class basic_regex;</a>
<a name="ln37"> </a>
<a name="ln38">  template&lt;typename, typename&gt;</a>
<a name="ln39">    class match_results;</a>
<a name="ln40"> </a>
<a name="ln41">_GLIBCXX_END_NAMESPACE_CXX11</a>
<a name="ln42"> </a>
<a name="ln43">namespace __detail</a>
<a name="ln44">{</a>
<a name="ln45">  enum class _RegexExecutorPolicy : int</a>
<a name="ln46">    { _S_auto, _S_alternate };</a>
<a name="ln47"> </a>
<a name="ln48">  template&lt;typename _BiIter, typename _Alloc,</a>
<a name="ln49">	   typename _CharT, typename _TraitsT,</a>
<a name="ln50">	   _RegexExecutorPolicy __policy,</a>
<a name="ln51">	   bool __match_mode&gt;</a>
<a name="ln52">    bool</a>
<a name="ln53">    __regex_algo_impl(_BiIter			      __s,</a>
<a name="ln54">		      _BiIter			      __e,</a>
<a name="ln55">		      match_results&lt;_BiIter, _Alloc&gt;&amp;      __m,</a>
<a name="ln56">		      const basic_regex&lt;_CharT, _TraitsT&gt;&amp; __re,</a>
<a name="ln57">		      regex_constants::match_flag_type     __flags);</a>
<a name="ln58"> </a>
<a name="ln59">  template&lt;typename, typename, typename, bool&gt;</a>
<a name="ln60">    class _Executor;</a>
<a name="ln61">}</a>
<a name="ln62"> </a>
<a name="ln63">_GLIBCXX_BEGIN_NAMESPACE_CXX11</a>
<a name="ln64"> </a>
<a name="ln65">  /**</a>
<a name="ln66">   * @addtogroup regex</a>
<a name="ln67">   * @{</a>
<a name="ln68">   */</a>
<a name="ln69"> </a>
<a name="ln70">  /**</a>
<a name="ln71">   * @brief Describes aspects of a regular expression.</a>
<a name="ln72">   *</a>
<a name="ln73">   * A regular expression traits class that satisfies the requirements of</a>
<a name="ln74">   * section [28.7].</a>
<a name="ln75">   *</a>
<a name="ln76">   * The class %regex is parameterized around a set of related types and</a>
<a name="ln77">   * functions used to complete the definition of its semantics.  This class</a>
<a name="ln78">   * satisfies the requirements of such a traits class.</a>
<a name="ln79">   */</a>
<a name="ln80">  template&lt;typename _Ch_type&gt;</a>
<a name="ln81">    struct regex_traits</a>
<a name="ln82">    {</a>
<a name="ln83">    public:</a>
<a name="ln84">      typedef _Ch_type				char_type;</a>
<a name="ln85">      typedef std::basic_string&lt;char_type&gt;	string_type;</a>
<a name="ln86">      typedef std::locale			locale_type;</a>
<a name="ln87">    private:</a>
<a name="ln88">      struct _RegexMask</a>
<a name="ln89">	{</a>
<a name="ln90">	  typedef std::ctype_base::mask _BaseType;</a>
<a name="ln91">	  _BaseType _M_base;</a>
<a name="ln92">	  unsigned char _M_extended;</a>
<a name="ln93">	  static constexpr unsigned char _S_under = 1 &lt;&lt; 0;</a>
<a name="ln94">	  static constexpr unsigned char _S_valid_mask = 0x1;</a>
<a name="ln95"> </a>
<a name="ln96">	  constexpr _RegexMask(_BaseType __base = 0,</a>
<a name="ln97">			       unsigned char __extended = 0)</a>
<a name="ln98">	  : _M_base(__base), _M_extended(__extended)</a>
<a name="ln99">	  { }</a>
<a name="ln100"> </a>
<a name="ln101">	  constexpr _RegexMask</a>
<a name="ln102">	  operator&amp;(_RegexMask __other) const</a>
<a name="ln103">	  {</a>
<a name="ln104">	    return _RegexMask(_M_base &amp; __other._M_base,</a>
<a name="ln105">			      _M_extended &amp; __other._M_extended);</a>
<a name="ln106">	  }</a>
<a name="ln107"> </a>
<a name="ln108">	  constexpr _RegexMask</a>
<a name="ln109">	  operator|(_RegexMask __other) const</a>
<a name="ln110">	  {</a>
<a name="ln111">	    return _RegexMask(_M_base | __other._M_base,</a>
<a name="ln112">			      _M_extended | __other._M_extended);</a>
<a name="ln113">	  }</a>
<a name="ln114"> </a>
<a name="ln115">	  constexpr _RegexMask</a>
<a name="ln116">	  operator^(_RegexMask __other) const</a>
<a name="ln117">	  {</a>
<a name="ln118">	    return _RegexMask(_M_base ^ __other._M_base,</a>
<a name="ln119">			      _M_extended ^ __other._M_extended);</a>
<a name="ln120">	  }</a>
<a name="ln121"> </a>
<a name="ln122">	  constexpr _RegexMask</a>
<a name="ln123">	  operator~() const</a>
<a name="ln124">	  { return _RegexMask(~_M_base, ~_M_extended); }</a>
<a name="ln125"> </a>
<a name="ln126">	  _RegexMask&amp;</a>
<a name="ln127">	  operator&amp;=(_RegexMask __other)</a>
<a name="ln128">	  { return *this = (*this) &amp; __other; }</a>
<a name="ln129"> </a>
<a name="ln130">	  _RegexMask&amp;</a>
<a name="ln131">	  operator|=(_RegexMask __other)</a>
<a name="ln132">	  { return *this = (*this) | __other; }</a>
<a name="ln133"> </a>
<a name="ln134">	  _RegexMask&amp;</a>
<a name="ln135">	  operator^=(_RegexMask __other)</a>
<a name="ln136">	  { return *this = (*this) ^ __other; }</a>
<a name="ln137"> </a>
<a name="ln138">	  constexpr bool</a>
<a name="ln139">	  operator==(_RegexMask __other) const</a>
<a name="ln140">	  {</a>
<a name="ln141">	    return (_M_extended &amp; _S_valid_mask)</a>
<a name="ln142">		   == (__other._M_extended &amp; _S_valid_mask)</a>
<a name="ln143">		     &amp;&amp; _M_base == __other._M_base;</a>
<a name="ln144">	  }</a>
<a name="ln145"> </a>
<a name="ln146">	  constexpr bool</a>
<a name="ln147">	  operator!=(_RegexMask __other) const</a>
<a name="ln148">	  { return !((*this) == __other); }</a>
<a name="ln149"> </a>
<a name="ln150">	};</a>
<a name="ln151">    public:</a>
<a name="ln152">      typedef _RegexMask char_class_type;</a>
<a name="ln153"> </a>
<a name="ln154">    public:</a>
<a name="ln155">      /**</a>
<a name="ln156">       * @brief Constructs a default traits object.</a>
<a name="ln157">       */</a>
<a name="ln158">      regex_traits() { }</a>
<a name="ln159"> </a>
<a name="ln160">      /**</a>
<a name="ln161">       * @brief Gives the length of a C-style string starting at @p __p.</a>
<a name="ln162">       *</a>
<a name="ln163">       * @param __p a pointer to the start of a character sequence.</a>
<a name="ln164">       *</a>
<a name="ln165">       * @returns the number of characters between @p *__p and the first</a>
<a name="ln166">       * default-initialized value of type @p char_type.  In other words, uses</a>
<a name="ln167">       * the C-string algorithm for determining the length of a sequence of</a>
<a name="ln168">       * characters.</a>
<a name="ln169">       */</a>
<a name="ln170">      static std::size_t</a>
<a name="ln171">      length(const char_type* __p)</a>
<a name="ln172">      { return string_type::traits_type::length(__p); }</a>
<a name="ln173"> </a>
<a name="ln174">      /**</a>
<a name="ln175">       * @brief Performs the identity translation.</a>
<a name="ln176">       *</a>
<a name="ln177">       * @param __c A character to the locale-specific character set.</a>
<a name="ln178">       *</a>
<a name="ln179">       * @returns __c.</a>
<a name="ln180">       */</a>
<a name="ln181">      char_type</a>
<a name="ln182">      translate(char_type __c) const</a>
<a name="ln183">      { return __c; }</a>
<a name="ln184"> </a>
<a name="ln185">      /**</a>
<a name="ln186">       * @brief Translates a character into a case-insensitive equivalent.</a>
<a name="ln187">       *</a>
<a name="ln188">       * @param __c A character to the locale-specific character set.</a>
<a name="ln189">       *</a>
<a name="ln190">       * @returns the locale-specific lower-case equivalent of __c.</a>
<a name="ln191">       * @throws std::bad_cast if the imbued locale does not support the ctype</a>
<a name="ln192">       *         facet.</a>
<a name="ln193">       */</a>
<a name="ln194">      char_type</a>
<a name="ln195">      translate_nocase(char_type __c) const</a>
<a name="ln196">      {</a>
<a name="ln197">	typedef std::ctype&lt;char_type&gt; __ctype_type;</a>
<a name="ln198">	const __ctype_type&amp; __fctyp(use_facet&lt;__ctype_type&gt;(_M_locale));</a>
<a name="ln199">	return __fctyp.tolower(__c);</a>
<a name="ln200">      }</a>
<a name="ln201"> </a>
<a name="ln202">      /**</a>
<a name="ln203">       * @brief Gets a sort key for a character sequence.</a>
<a name="ln204">       *</a>
<a name="ln205">       * @param __first beginning of the character sequence.</a>
<a name="ln206">       * @param __last  one-past-the-end of the character sequence.</a>
<a name="ln207">       *</a>
<a name="ln208">       * Returns a sort key for the character sequence designated by the</a>
<a name="ln209">       * iterator range [F1, F2) such that if the character sequence [G1, G2)</a>
<a name="ln210">       * sorts before the character sequence [H1, H2) then</a>
<a name="ln211">       * v.transform(G1, G2) &lt; v.transform(H1, H2).</a>
<a name="ln212">       *</a>
<a name="ln213">       * What this really does is provide a more efficient way to compare a</a>
<a name="ln214">       * string to multiple other strings in locales with fancy collation</a>
<a name="ln215">       * rules and equivalence classes.</a>
<a name="ln216">       *</a>
<a name="ln217">       * @returns a locale-specific sort key equivalent to the input range.</a>
<a name="ln218">       *</a>
<a name="ln219">       * @throws std::bad_cast if the current locale does not have a collate</a>
<a name="ln220">       *         facet.</a>
<a name="ln221">       */</a>
<a name="ln222">      template&lt;typename _Fwd_iter&gt;</a>
<a name="ln223">	string_type</a>
<a name="ln224">	transform(_Fwd_iter __first, _Fwd_iter __last) const</a>
<a name="ln225">	{</a>
<a name="ln226">	  typedef std::collate&lt;char_type&gt; __collate_type;</a>
<a name="ln227">	  const __collate_type&amp; __fclt(use_facet&lt;__collate_type&gt;(_M_locale));</a>
<a name="ln228">	  string_type __s(__first, __last);</a>
<a name="ln229">	  return __fclt.transform(__s.data(), __s.data() + __s.size());</a>
<a name="ln230">	}</a>
<a name="ln231"> </a>
<a name="ln232">      /**</a>
<a name="ln233">       * @brief Gets a sort key for a character sequence, independent of case.</a>
<a name="ln234">       *</a>
<a name="ln235">       * @param __first beginning of the character sequence.</a>
<a name="ln236">       * @param __last  one-past-the-end of the character sequence.</a>
<a name="ln237">       *</a>
<a name="ln238">       * Effects: if typeid(use_facet&lt;collate&lt;_Ch_type&gt; &gt;) ==</a>
<a name="ln239">       * typeid(collate_byname&lt;_Ch_type&gt;) and the form of the sort key</a>
<a name="ln240">       * returned by collate_byname&lt;_Ch_type&gt;::transform(__first, __last)</a>
<a name="ln241">       * is known and can be converted into a primary sort key</a>
<a name="ln242">       * then returns that key, otherwise returns an empty string.</a>
<a name="ln243">       *</a>
<a name="ln244">       * @todo Implement this function correctly.</a>
<a name="ln245">       */</a>
<a name="ln246">      template&lt;typename _Fwd_iter&gt;</a>
<a name="ln247">	string_type</a>
<a name="ln248">	transform_primary(_Fwd_iter __first, _Fwd_iter __last) const</a>
<a name="ln249">	{</a>
<a name="ln250">	  // TODO : this is not entirely correct.</a>
<a name="ln251">	  // This function requires extra support from the platform.</a>
<a name="ln252">	  //</a>
<a name="ln253">	  // Read http://gcc.gnu.org/ml/libstdc++/2013-09/msg00117.html and</a>
<a name="ln254">	  // http://www.open-std.org/Jtc1/sc22/wg21/docs/papers/2003/n1429.htm</a>
<a name="ln255">	  // for details.</a>
<a name="ln256">	  typedef std::ctype&lt;char_type&gt; __ctype_type;</a>
<a name="ln257">	  const __ctype_type&amp; __fctyp(use_facet&lt;__ctype_type&gt;(_M_locale));</a>
<a name="ln258">	  std::vector&lt;char_type&gt; __s(__first, __last);</a>
<a name="ln259">	  __fctyp.tolower(__s.data(), __s.data() + __s.size());</a>
<a name="ln260">	  return this-&gt;transform(__s.data(), __s.data() + __s.size());</a>
<a name="ln261">	}</a>
<a name="ln262"> </a>
<a name="ln263">      /**</a>
<a name="ln264">       * @brief Gets a collation element by name.</a>
<a name="ln265">       *</a>
<a name="ln266">       * @param __first beginning of the collation element name.</a>
<a name="ln267">       * @param __last  one-past-the-end of the collation element name.</a>
<a name="ln268">       *</a>
<a name="ln269">       * @returns a sequence of one or more characters that represents the</a>
<a name="ln270">       * collating element consisting of the character sequence designated by</a>
<a name="ln271">       * the iterator range [__first, __last). Returns an empty string if the</a>
<a name="ln272">       * character sequence is not a valid collating element.</a>
<a name="ln273">       */</a>
<a name="ln274">      template&lt;typename _Fwd_iter&gt;</a>
<a name="ln275">	string_type</a>
<a name="ln276">	lookup_collatename(_Fwd_iter __first, _Fwd_iter __last) const;</a>
<a name="ln277"> </a>
<a name="ln278">      /**</a>
<a name="ln279">       * @brief Maps one or more characters to a named character</a>
<a name="ln280">       *        classification.</a>
<a name="ln281">       *</a>
<a name="ln282">       * @param __first beginning of the character sequence.</a>
<a name="ln283">       * @param __last  one-past-the-end of the character sequence.</a>
<a name="ln284">       * @param __icase ignores the case of the classification name.</a>
<a name="ln285">       *</a>
<a name="ln286">       * @returns an unspecified value that represents the character</a>
<a name="ln287">       * classification named by the character sequence designated by</a>
<a name="ln288">       * the iterator range [__first, __last). If @p icase is true,</a>
<a name="ln289">       * the returned mask identifies the classification regardless of</a>
<a name="ln290">       * the case of the characters to be matched (for example,</a>
<a name="ln291">       * [[:lower:]] is the same as [[:alpha:]]), otherwise a</a>
<a name="ln292">       * case-dependent classification is returned.  The value</a>
<a name="ln293">       * returned shall be independent of the case of the characters</a>
<a name="ln294">       * in the character sequence. If the name is not recognized then</a>
<a name="ln295">       * returns a value that compares equal to 0.</a>
<a name="ln296">       *</a>
<a name="ln297">       * At least the following names (or their wide-character equivalent) are</a>
<a name="ln298">       * supported.</a>
<a name="ln299">       * - d</a>
<a name="ln300">       * - w</a>
<a name="ln301">       * - s</a>
<a name="ln302">       * - alnum</a>
<a name="ln303">       * - alpha</a>
<a name="ln304">       * - blank</a>
<a name="ln305">       * - cntrl</a>
<a name="ln306">       * - digit</a>
<a name="ln307">       * - graph</a>
<a name="ln308">       * - lower</a>
<a name="ln309">       * - print</a>
<a name="ln310">       * - punct</a>
<a name="ln311">       * - space</a>
<a name="ln312">       * - upper</a>
<a name="ln313">       * - xdigit</a>
<a name="ln314">       */</a>
<a name="ln315">      template&lt;typename _Fwd_iter&gt;</a>
<a name="ln316">	char_class_type</a>
<a name="ln317">	lookup_classname(_Fwd_iter __first, _Fwd_iter __last,</a>
<a name="ln318">			 bool __icase = false) const;</a>
<a name="ln319"> </a>
<a name="ln320">      /**</a>
<a name="ln321">       * @brief Determines if @p c is a member of an identified class.</a>
<a name="ln322">       *</a>
<a name="ln323">       * @param __c a character.</a>
<a name="ln324">       * @param __f a class type (as returned from lookup_classname).</a>
<a name="ln325">       *</a>
<a name="ln326">       * @returns true if the character @p __c is a member of the classification</a>
<a name="ln327">       * represented by @p __f, false otherwise.</a>
<a name="ln328">       *</a>
<a name="ln329">       * @throws std::bad_cast if the current locale does not have a ctype</a>
<a name="ln330">       *         facet.</a>
<a name="ln331">       */</a>
<a name="ln332">      bool</a>
<a name="ln333">      isctype(_Ch_type __c, char_class_type __f) const;</a>
<a name="ln334"> </a>
<a name="ln335">      /**</a>
<a name="ln336">       * @brief Converts a digit to an int.</a>
<a name="ln337">       *</a>
<a name="ln338">       * @param __ch    a character representing a digit.</a>
<a name="ln339">       * @param __radix the radix if the numeric conversion (limited to 8, 10,</a>
<a name="ln340">       *              or 16).</a>
<a name="ln341">       *</a>
<a name="ln342">       * @returns the value represented by the digit __ch in base radix if the</a>
<a name="ln343">       * character __ch is a valid digit in base radix; otherwise returns -1.</a>
<a name="ln344">       */</a>
<a name="ln345">      int</a>
<a name="ln346">      value(_Ch_type __ch, int __radix) const;</a>
<a name="ln347"> </a>
<a name="ln348">      /**</a>
<a name="ln349">       * @brief Imbues the regex_traits object with a copy of a new locale.</a>
<a name="ln350">       *</a>
<a name="ln351">       * @param __loc A locale.</a>
<a name="ln352">       *</a>
<a name="ln353">       * @returns a copy of the previous locale in use by the regex_traits</a>
<a name="ln354">       *          object.</a>
<a name="ln355">       *</a>
<a name="ln356">       * @note Calling imbue with a different locale than the one currently in</a>
<a name="ln357">       *       use invalidates all cached data held by *this.</a>
<a name="ln358">       */</a>
<a name="ln359">      locale_type</a>
<a name="ln360">      imbue(locale_type __loc)</a>
<a name="ln361">      {</a>
<a name="ln362">	std::swap(_M_locale, __loc);</a>
<a name="ln363">	return __loc;</a>
<a name="ln364">      }</a>
<a name="ln365"> </a>
<a name="ln366">      /**</a>
<a name="ln367">       * @brief Gets a copy of the current locale in use by the regex_traits</a>
<a name="ln368">       * object.</a>
<a name="ln369">       */</a>
<a name="ln370">      locale_type</a>
<a name="ln371">      getloc() const</a>
<a name="ln372">      { return _M_locale; }</a>
<a name="ln373"> </a>
<a name="ln374">    protected:</a>
<a name="ln375">      locale_type _M_locale;</a>
<a name="ln376">    };</a>
<a name="ln377"> </a>
<a name="ln378">  // [7.8] Class basic_regex</a>
<a name="ln379">  /**</a>
<a name="ln380">   * Objects of specializations of this class represent regular expressions</a>
<a name="ln381">   * constructed from sequences of character type @p _Ch_type.</a>
<a name="ln382">   *</a>
<a name="ln383">   * Storage for the regular expression is allocated and deallocated as</a>
<a name="ln384">   * necessary by the member functions of this class.</a>
<a name="ln385">   */</a>
<a name="ln386">  template&lt;typename _Ch_type, typename _Rx_traits = regex_traits&lt;_Ch_type&gt;&gt;</a>
<a name="ln387">    class basic_regex</a>
<a name="ln388">    {</a>
<a name="ln389">    public:</a>
<a name="ln390">      static_assert(is_same&lt;_Ch_type, typename _Rx_traits::char_type&gt;::value,</a>
<a name="ln391">		    &quot;regex traits class must have the same char_type&quot;);</a>
<a name="ln392"> </a>
<a name="ln393">      // types:</a>
<a name="ln394">      typedef _Ch_type				  value_type;</a>
<a name="ln395">      typedef _Rx_traits			  traits_type;</a>
<a name="ln396">      typedef typename traits_type::string_type   string_type;</a>
<a name="ln397">      typedef regex_constants::syntax_option_type flag_type;</a>
<a name="ln398">      typedef typename traits_type::locale_type   locale_type;</a>
<a name="ln399"> </a>
<a name="ln400">      /**</a>
<a name="ln401">       * @name Constants</a>
<a name="ln402">       * std [28.8.1](1)</a>
<a name="ln403">       */</a>
<a name="ln404">      //@{</a>
<a name="ln405">      static constexpr flag_type icase = regex_constants::icase;</a>
<a name="ln406">      static constexpr flag_type nosubs = regex_constants::nosubs;</a>
<a name="ln407">      static constexpr flag_type optimize = regex_constants::optimize;</a>
<a name="ln408">      static constexpr flag_type collate = regex_constants::collate;</a>
<a name="ln409">      static constexpr flag_type ECMAScript = regex_constants::ECMAScript;</a>
<a name="ln410">      static constexpr flag_type basic = regex_constants::basic;</a>
<a name="ln411">      static constexpr flag_type extended = regex_constants::extended;</a>
<a name="ln412">      static constexpr flag_type awk = regex_constants::awk;</a>
<a name="ln413">      static constexpr flag_type grep = regex_constants::grep;</a>
<a name="ln414">      static constexpr flag_type egrep = regex_constants::egrep;</a>
<a name="ln415">      //@}</a>
<a name="ln416"> </a>
<a name="ln417">      // [7.8.2] construct/copy/destroy</a>
<a name="ln418">      /**</a>
<a name="ln419">       * Constructs a basic regular expression that does not match any</a>
<a name="ln420">       * character sequence.</a>
<a name="ln421">       */</a>
<a name="ln422">      basic_regex()</a>
<a name="ln423">      : _M_flags(ECMAScript), _M_loc(), _M_automaton(nullptr)</a>
<a name="ln424">      { }</a>
<a name="ln425"> </a>
<a name="ln426">      /**</a>
<a name="ln427">       * @brief Constructs a basic regular expression from the</a>
<a name="ln428">       * sequence [__p, __p + char_traits&lt;_Ch_type&gt;::length(__p))</a>
<a name="ln429">       * interpreted according to the flags in @p __f.</a>
<a name="ln430">       *</a>
<a name="ln431">       * @param __p A pointer to the start of a C-style null-terminated string</a>
<a name="ln432">       *          containing a regular expression.</a>
<a name="ln433">       * @param __f Flags indicating the syntax rules and options.</a>
<a name="ln434">       *</a>
<a name="ln435">       * @throws regex_error if @p __p is not a valid regular expression.</a>
<a name="ln436">       */</a>
<a name="ln437">      explicit</a>
<a name="ln438">      basic_regex(const _Ch_type* __p, flag_type __f = ECMAScript)</a>
<a name="ln439">      : basic_regex(__p, __p + char_traits&lt;_Ch_type&gt;::length(__p), __f)</a>
<a name="ln440">      { }</a>
<a name="ln441"> </a>
<a name="ln442">      /**</a>
<a name="ln443">       * @brief Constructs a basic regular expression from the sequence</a>
<a name="ln444">       * [p, p + len) interpreted according to the flags in @p f.</a>
<a name="ln445">       *</a>
<a name="ln446">       * @param __p   A pointer to the start of a string containing a regular</a>
<a name="ln447">       *              expression.</a>
<a name="ln448">       * @param __len The length of the string containing the regular</a>
<a name="ln449">       *              expression.</a>
<a name="ln450">       * @param __f   Flags indicating the syntax rules and options.</a>
<a name="ln451">       *</a>
<a name="ln452">       * @throws regex_error if @p __p is not a valid regular expression.</a>
<a name="ln453">       */</a>
<a name="ln454">      basic_regex(const _Ch_type* __p, std::size_t __len,</a>
<a name="ln455">		  flag_type __f = ECMAScript)</a>
<a name="ln456">      : basic_regex(__p, __p + __len, __f)</a>
<a name="ln457">      { }</a>
<a name="ln458"> </a>
<a name="ln459">      /**</a>
<a name="ln460">       * @brief Copy-constructs a basic regular expression.</a>
<a name="ln461">       *</a>
<a name="ln462">       * @param __rhs A @p regex object.</a>
<a name="ln463">       */</a>
<a name="ln464">      basic_regex(const basic_regex&amp; __rhs) = default;</a>
<a name="ln465"> </a>
<a name="ln466">      /**</a>
<a name="ln467">       * @brief Move-constructs a basic regular expression.</a>
<a name="ln468">       *</a>
<a name="ln469">       * @param __rhs A @p regex object.</a>
<a name="ln470">       */</a>
<a name="ln471">      basic_regex(basic_regex&amp;&amp; __rhs) noexcept = default;</a>
<a name="ln472"> </a>
<a name="ln473">      /**</a>
<a name="ln474">       * @brief Constructs a basic regular expression from the string</a>
<a name="ln475">       * @p s interpreted according to the flags in @p f.</a>
<a name="ln476">       *</a>
<a name="ln477">       * @param __s A string containing a regular expression.</a>
<a name="ln478">       * @param __f Flags indicating the syntax rules and options.</a>
<a name="ln479">       *</a>
<a name="ln480">       * @throws regex_error if @p __s is not a valid regular expression.</a>
<a name="ln481">       */</a>
<a name="ln482">      template&lt;typename _Ch_traits, typename _Ch_alloc&gt;</a>
<a name="ln483">	explicit</a>
<a name="ln484">	basic_regex(const std::basic_string&lt;_Ch_type, _Ch_traits,</a>
<a name="ln485">					    _Ch_alloc&gt;&amp; __s,</a>
<a name="ln486">		    flag_type __f = ECMAScript)</a>
<a name="ln487">	: basic_regex(__s.data(), __s.data() + __s.size(), __f)</a>
<a name="ln488">	{ }</a>
<a name="ln489"> </a>
<a name="ln490">      /**</a>
<a name="ln491">       * @brief Constructs a basic regular expression from the range</a>
<a name="ln492">       * [first, last) interpreted according to the flags in @p f.</a>
<a name="ln493">       *</a>
<a name="ln494">       * @param __first The start of a range containing a valid regular</a>
<a name="ln495">       *                expression.</a>
<a name="ln496">       * @param __last  The end of a range containing a valid regular</a>
<a name="ln497">       *                expression.</a>
<a name="ln498">       * @param __f     The format flags of the regular expression.</a>
<a name="ln499">       *</a>
<a name="ln500">       * @throws regex_error if @p [__first, __last) is not a valid regular</a>
<a name="ln501">       *         expression.</a>
<a name="ln502">       */</a>
<a name="ln503">      template&lt;typename _FwdIter&gt;</a>
<a name="ln504">	basic_regex(_FwdIter __first, _FwdIter __last,</a>
<a name="ln505">		    flag_type __f = ECMAScript)</a>
<a name="ln506">	: basic_regex(std::move(__first), std::move(__last), locale_type(), __f)</a>
<a name="ln507">	{ }</a>
<a name="ln508"> </a>
<a name="ln509">      /**</a>
<a name="ln510">       * @brief Constructs a basic regular expression from an initializer list.</a>
<a name="ln511">       *</a>
<a name="ln512">       * @param __l  The initializer list.</a>
<a name="ln513">       * @param __f  The format flags of the regular expression.</a>
<a name="ln514">       *</a>
<a name="ln515">       * @throws regex_error if @p __l is not a valid regular expression.</a>
<a name="ln516">       */</a>
<a name="ln517">      basic_regex(initializer_list&lt;_Ch_type&gt; __l, flag_type __f = ECMAScript)</a>
<a name="ln518">      : basic_regex(__l.begin(), __l.end(), __f)</a>
<a name="ln519">      { }</a>
<a name="ln520"> </a>
<a name="ln521">      /**</a>
<a name="ln522">       * @brief Destroys a basic regular expression.</a>
<a name="ln523">       */</a>
<a name="ln524">      ~basic_regex()</a>
<a name="ln525">      { }</a>
<a name="ln526"> </a>
<a name="ln527">      /**</a>
<a name="ln528">       * @brief Assigns one regular expression to another.</a>
<a name="ln529">       */</a>
<a name="ln530">      basic_regex&amp;</a>
<a name="ln531">      operator=(const basic_regex&amp; __rhs)</a>
<a name="ln532">      { return this-&gt;assign(__rhs); }</a>
<a name="ln533"> </a>
<a name="ln534">      /**</a>
<a name="ln535">       * @brief Move-assigns one regular expression to another.</a>
<a name="ln536">       */</a>
<a name="ln537">      basic_regex&amp;</a>
<a name="ln538">      operator=(basic_regex&amp;&amp; __rhs) noexcept</a>
<a name="ln539">      { return this-&gt;assign(std::move(__rhs)); }</a>
<a name="ln540"> </a>
<a name="ln541">      /**</a>
<a name="ln542">       * @brief Replaces a regular expression with a new one constructed from</a>
<a name="ln543">       * a C-style null-terminated string.</a>
<a name="ln544">       *</a>
<a name="ln545">       * @param __p A pointer to the start of a null-terminated C-style string</a>
<a name="ln546">       *        containing a regular expression.</a>
<a name="ln547">       */</a>
<a name="ln548">      basic_regex&amp;</a>
<a name="ln549">      operator=(const _Ch_type* __p)</a>
<a name="ln550">      { return this-&gt;assign(__p); }</a>
<a name="ln551"> </a>
<a name="ln552">      /**</a>
<a name="ln553">       * @brief Replaces a regular expression with a new one constructed from</a>
<a name="ln554">       * an initializer list.</a>
<a name="ln555">       *</a>
<a name="ln556">       * @param __l  The initializer list.</a>
<a name="ln557">       *</a>
<a name="ln558">       * @throws regex_error if @p __l is not a valid regular expression.</a>
<a name="ln559">       */</a>
<a name="ln560">      basic_regex&amp;</a>
<a name="ln561">      operator=(initializer_list&lt;_Ch_type&gt; __l)</a>
<a name="ln562">      { return this-&gt;assign(__l.begin(), __l.end()); }</a>
<a name="ln563"> </a>
<a name="ln564">      /**</a>
<a name="ln565">       * @brief Replaces a regular expression with a new one constructed from</a>
<a name="ln566">       * a string.</a>
<a name="ln567">       *</a>
<a name="ln568">       * @param __s A pointer to a string containing a regular expression.</a>
<a name="ln569">       */</a>
<a name="ln570">      template&lt;typename _Ch_traits, typename _Alloc&gt;</a>
<a name="ln571">	basic_regex&amp;</a>
<a name="ln572">	operator=(const basic_string&lt;_Ch_type, _Ch_traits, _Alloc&gt;&amp; __s)</a>
<a name="ln573">	{ return this-&gt;assign(__s); }</a>
<a name="ln574"> </a>
<a name="ln575">      // [7.8.3] assign</a>
<a name="ln576">      /**</a>
<a name="ln577">       * @brief the real assignment operator.</a>
<a name="ln578">       *</a>
<a name="ln579">       * @param __rhs Another regular expression object.</a>
<a name="ln580">       */</a>
<a name="ln581">      basic_regex&amp;</a>
<a name="ln582">      assign(const basic_regex&amp; __rhs)</a>
<a name="ln583">      {</a>
<a name="ln584">	basic_regex __tmp(__rhs);</a>
<a name="ln585">	this-&gt;swap(__tmp);</a>
<a name="ln586">	return *this;</a>
<a name="ln587">      }</a>
<a name="ln588"> </a>
<a name="ln589">      /**</a>
<a name="ln590">       * @brief The move-assignment operator.</a>
<a name="ln591">       *</a>
<a name="ln592">       * @param __rhs Another regular expression object.</a>
<a name="ln593">       */</a>
<a name="ln594">      basic_regex&amp;</a>
<a name="ln595">      assign(basic_regex&amp;&amp; __rhs) noexcept</a>
<a name="ln596">      {</a>
<a name="ln597">	basic_regex __tmp(std::move(__rhs));</a>
<a name="ln598">	this-&gt;swap(__tmp);</a>
<a name="ln599">	return *this;</a>
<a name="ln600">      }</a>
<a name="ln601"> </a>
<a name="ln602">      /**</a>
<a name="ln603">       * @brief Assigns a new regular expression to a regex object from a</a>
<a name="ln604">       * C-style null-terminated string containing a regular expression</a>
<a name="ln605">       * pattern.</a>
<a name="ln606">       *</a>
<a name="ln607">       * @param __p     A pointer to a C-style null-terminated string containing</a>
<a name="ln608">       *              a regular expression pattern.</a>
<a name="ln609">       * @param __flags Syntax option flags.</a>
<a name="ln610">       *</a>
<a name="ln611">       * @throws regex_error if __p does not contain a valid regular</a>
<a name="ln612">       * expression pattern interpreted according to @p __flags.  If</a>
<a name="ln613">       * regex_error is thrown, *this remains unchanged.</a>
<a name="ln614">       */</a>
<a name="ln615">      basic_regex&amp;</a>
<a name="ln616">      assign(const _Ch_type* __p, flag_type __flags = ECMAScript)</a>
<a name="ln617">      { return this-&gt;assign(string_type(__p), __flags); }</a>
<a name="ln618"> </a>
<a name="ln619">      /**</a>
<a name="ln620">       * @brief Assigns a new regular expression to a regex object from a</a>
<a name="ln621">       * C-style string containing a regular expression pattern.</a>
<a name="ln622">       *</a>
<a name="ln623">       * @param __p     A pointer to a C-style string containing a</a>
<a name="ln624">       *                regular expression pattern.</a>
<a name="ln625">       * @param __len   The length of the regular expression pattern string.</a>
<a name="ln626">       * @param __flags Syntax option flags.</a>
<a name="ln627">       *</a>
<a name="ln628">       * @throws regex_error if p does not contain a valid regular</a>
<a name="ln629">       * expression pattern interpreted according to @p __flags.  If</a>
<a name="ln630">       * regex_error is thrown, *this remains unchanged.</a>
<a name="ln631">       */</a>
<a name="ln632">      basic_regex&amp;</a>
<a name="ln633">      assign(const _Ch_type* __p, std::size_t __len, flag_type __flags)</a>
<a name="ln634">      { return this-&gt;assign(string_type(__p, __len), __flags); }</a>
<a name="ln635"> </a>
<a name="ln636">      /**</a>
<a name="ln637">       * @brief Assigns a new regular expression to a regex object from a</a>
<a name="ln638">       * string containing a regular expression pattern.</a>
<a name="ln639">       *</a>
<a name="ln640">       * @param __s     A string containing a regular expression pattern.</a>
<a name="ln641">       * @param __flags Syntax option flags.</a>
<a name="ln642">       *</a>
<a name="ln643">       * @throws regex_error if __s does not contain a valid regular</a>
<a name="ln644">       * expression pattern interpreted according to @p __flags.  If</a>
<a name="ln645">       * regex_error is thrown, *this remains unchanged.</a>
<a name="ln646">       */</a>
<a name="ln647">      template&lt;typename _Ch_traits, typename _Alloc&gt;</a>
<a name="ln648">	basic_regex&amp;</a>
<a name="ln649">	assign(const basic_string&lt;_Ch_type, _Ch_traits, _Alloc&gt;&amp; __s,</a>
<a name="ln650">	       flag_type __flags = ECMAScript)</a>
<a name="ln651">	{</a>
<a name="ln652">	  return this-&gt;assign(basic_regex(__s.data(), __s.data() + __s.size(),</a>
<a name="ln653">					  _M_loc, __flags));</a>
<a name="ln654">	}</a>
<a name="ln655"> </a>
<a name="ln656">      /**</a>
<a name="ln657">       * @brief Assigns a new regular expression to a regex object.</a>
<a name="ln658">       *</a>
<a name="ln659">       * @param __first The start of a range containing a valid regular</a>
<a name="ln660">       *                expression.</a>
<a name="ln661">       * @param __last  The end of a range containing a valid regular</a>
<a name="ln662">       *                expression.</a>
<a name="ln663">       * @param __flags Syntax option flags.</a>
<a name="ln664">       *</a>
<a name="ln665">       * @throws regex_error if p does not contain a valid regular</a>
<a name="ln666">       * expression pattern interpreted according to @p __flags.  If</a>
<a name="ln667">       * regex_error is thrown, the object remains unchanged.</a>
<a name="ln668">       */</a>
<a name="ln669">      template&lt;typename _InputIterator&gt;</a>
<a name="ln670">	basic_regex&amp;</a>
<a name="ln671">	assign(_InputIterator __first, _InputIterator __last,</a>
<a name="ln672">	       flag_type __flags = ECMAScript)</a>
<a name="ln673">	{ return this-&gt;assign(string_type(__first, __last), __flags); }</a>
<a name="ln674"> </a>
<a name="ln675">      /**</a>
<a name="ln676">       * @brief Assigns a new regular expression to a regex object.</a>
<a name="ln677">       *</a>
<a name="ln678">       * @param __l     An initializer list representing a regular expression.</a>
<a name="ln679">       * @param __flags Syntax option flags.</a>
<a name="ln680">       *</a>
<a name="ln681">       * @throws regex_error if @p __l does not contain a valid</a>
<a name="ln682">       * regular expression pattern interpreted according to @p</a>
<a name="ln683">       * __flags.  If regex_error is thrown, the object remains</a>
<a name="ln684">       * unchanged.</a>
<a name="ln685">       */</a>
<a name="ln686">      basic_regex&amp;</a>
<a name="ln687">      assign(initializer_list&lt;_Ch_type&gt; __l, flag_type __flags = ECMAScript)</a>
<a name="ln688">      { return this-&gt;assign(__l.begin(), __l.end(), __flags); }</a>
<a name="ln689"> </a>
<a name="ln690">      // [7.8.4] const operations</a>
<a name="ln691">      /**</a>
<a name="ln692">       * @brief Gets the number of marked subexpressions within the regular</a>
<a name="ln693">       * expression.</a>
<a name="ln694">       */</a>
<a name="ln695">      unsigned int</a>
<a name="ln696">      mark_count() const</a>
<a name="ln697">      {</a>
<a name="ln698">	if (_M_automaton)</a>
<a name="ln699">	  return _M_automaton-&gt;_M_sub_count() - 1;</a>
<a name="ln700">	return 0;</a>
<a name="ln701">      }</a>
<a name="ln702"> </a>
<a name="ln703">      /**</a>
<a name="ln704">       * @brief Gets the flags used to construct the regular expression</a>
<a name="ln705">       * or in the last call to assign().</a>
<a name="ln706">       */</a>
<a name="ln707">      flag_type</a>
<a name="ln708">      flags() const</a>
<a name="ln709">      { return _M_flags; }</a>
<a name="ln710"> </a>
<a name="ln711">      // [7.8.5] locale</a>
<a name="ln712">      /**</a>
<a name="ln713">       * @brief Imbues the regular expression object with the given locale.</a>
<a name="ln714">       *</a>
<a name="ln715">       * @param __loc A locale.</a>
<a name="ln716">       */</a>
<a name="ln717">      locale_type</a>
<a name="ln718">      imbue(locale_type __loc)</a>
<a name="ln719">      {</a>
<a name="ln720">	std::swap(__loc, _M_loc);</a>
<a name="ln721">	_M_automaton.reset();</a>
<a name="ln722">	return __loc;</a>
<a name="ln723">      }</a>
<a name="ln724"> </a>
<a name="ln725">      /**</a>
<a name="ln726">       * @brief Gets the locale currently imbued in the regular expression</a>
<a name="ln727">       *        object.</a>
<a name="ln728">       */</a>
<a name="ln729">      locale_type</a>
<a name="ln730">      getloc() const</a>
<a name="ln731">      { return _M_loc; }</a>
<a name="ln732"> </a>
<a name="ln733">      // [7.8.6] swap</a>
<a name="ln734">      /**</a>
<a name="ln735">       * @brief Swaps the contents of two regular expression objects.</a>
<a name="ln736">       *</a>
<a name="ln737">       * @param __rhs Another regular expression object.</a>
<a name="ln738">       */</a>
<a name="ln739">      void</a>
<a name="ln740">      swap(basic_regex&amp; __rhs)</a>
<a name="ln741">      {</a>
<a name="ln742">	std::swap(_M_flags, __rhs._M_flags);</a>
<a name="ln743">	std::swap(_M_loc, __rhs._M_loc);</a>
<a name="ln744">	std::swap(_M_automaton, __rhs._M_automaton);</a>
<a name="ln745">      }</a>
<a name="ln746"> </a>
<a name="ln747">#ifdef _GLIBCXX_DEBUG</a>
<a name="ln748">      void</a>
<a name="ln749">      _M_dot(std::ostream&amp; __ostr)</a>
<a name="ln750">      { _M_automaton-&gt;_M_dot(__ostr); }</a>
<a name="ln751">#endif</a>
<a name="ln752"> </a>
<a name="ln753">    private:</a>
<a name="ln754">      typedef std::shared_ptr&lt;const __detail::_NFA&lt;_Rx_traits&gt;&gt; _AutomatonPtr;</a>
<a name="ln755"> </a>
<a name="ln756">      template&lt;typename _FwdIter&gt;</a>
<a name="ln757">	basic_regex(_FwdIter __first, _FwdIter __last, locale_type __loc,</a>
<a name="ln758">		    flag_type __f)</a>
<a name="ln759">	: _M_flags(__f), _M_loc(std::move(__loc)),</a>
<a name="ln760">	_M_automaton(__detail::__compile_nfa&lt;_Rx_traits&gt;(</a>
<a name="ln761">	  std::move(__first), std::move(__last), _M_loc, _M_flags))</a>
<a name="ln762">	{ }</a>
<a name="ln763"> </a>
<a name="ln764">      template&lt;typename _Bp, typename _Ap, typename _Cp, typename _Rp,</a>
<a name="ln765">	__detail::_RegexExecutorPolicy, bool&gt;</a>
<a name="ln766">	friend bool</a>
<a name="ln767">	__detail::__regex_algo_impl(_Bp, _Bp, match_results&lt;_Bp, _Ap&gt;&amp;,</a>
<a name="ln768">				    const basic_regex&lt;_Cp, _Rp&gt;&amp;,</a>
<a name="ln769">				    regex_constants::match_flag_type);</a>
<a name="ln770"> </a>
<a name="ln771">      template&lt;typename, typename, typename, bool&gt;</a>
<a name="ln772">	friend class __detail::_Executor;</a>
<a name="ln773"> </a>
<a name="ln774">      flag_type		_M_flags;</a>
<a name="ln775">      locale_type	_M_loc;</a>
<a name="ln776">      _AutomatonPtr	_M_automaton;</a>
<a name="ln777">    };</a>
<a name="ln778"> </a>
<a name="ln779">#if __cplusplus &lt; 201703L</a>
<a name="ln780">  template&lt;typename _Ch, typename _Tr&gt;</a>
<a name="ln781">    constexpr regex_constants::syntax_option_type</a>
<a name="ln782">    basic_regex&lt;_Ch, _Tr&gt;::icase;</a>
<a name="ln783"> </a>
<a name="ln784">  template&lt;typename _Ch, typename _Tr&gt;</a>
<a name="ln785">    constexpr regex_constants::syntax_option_type</a>
<a name="ln786">    basic_regex&lt;_Ch, _Tr&gt;::nosubs;</a>
<a name="ln787"> </a>
<a name="ln788">  template&lt;typename _Ch, typename _Tr&gt;</a>
<a name="ln789">    constexpr regex_constants::syntax_option_type</a>
<a name="ln790">    basic_regex&lt;_Ch, _Tr&gt;::optimize;</a>
<a name="ln791"> </a>
<a name="ln792">  template&lt;typename _Ch, typename _Tr&gt;</a>
<a name="ln793">    constexpr regex_constants::syntax_option_type</a>
<a name="ln794">    basic_regex&lt;_Ch, _Tr&gt;::collate;</a>
<a name="ln795"> </a>
<a name="ln796">  template&lt;typename _Ch, typename _Tr&gt;</a>
<a name="ln797">    constexpr regex_constants::syntax_option_type</a>
<a name="ln798">    basic_regex&lt;_Ch, _Tr&gt;::ECMAScript;</a>
<a name="ln799"> </a>
<a name="ln800">  template&lt;typename _Ch, typename _Tr&gt;</a>
<a name="ln801">    constexpr regex_constants::syntax_option_type</a>
<a name="ln802">    basic_regex&lt;_Ch, _Tr&gt;::basic;</a>
<a name="ln803"> </a>
<a name="ln804">  template&lt;typename _Ch, typename _Tr&gt;</a>
<a name="ln805">    constexpr regex_constants::syntax_option_type</a>
<a name="ln806">    basic_regex&lt;_Ch, _Tr&gt;::extended;</a>
<a name="ln807"> </a>
<a name="ln808">  template&lt;typename _Ch, typename _Tr&gt;</a>
<a name="ln809">    constexpr regex_constants::syntax_option_type</a>
<a name="ln810">    basic_regex&lt;_Ch, _Tr&gt;::awk;</a>
<a name="ln811"> </a>
<a name="ln812">  template&lt;typename _Ch, typename _Tr&gt;</a>
<a name="ln813">    constexpr regex_constants::syntax_option_type</a>
<a name="ln814">    basic_regex&lt;_Ch, _Tr&gt;::grep;</a>
<a name="ln815"> </a>
<a name="ln816">  template&lt;typename _Ch, typename _Tr&gt;</a>
<a name="ln817">    constexpr regex_constants::syntax_option_type</a>
<a name="ln818">    basic_regex&lt;_Ch, _Tr&gt;::egrep;</a>
<a name="ln819">#endif // ! C++17</a>
<a name="ln820"> </a>
<a name="ln821">#if __cpp_deduction_guides &gt;= 201606</a>
<a name="ln822">  template&lt;typename _ForwardIterator&gt;</a>
<a name="ln823">    basic_regex(_ForwardIterator, _ForwardIterator,</a>
<a name="ln824">		regex_constants::syntax_option_type = {})</a>
<a name="ln825">      -&gt; basic_regex&lt;typename iterator_traits&lt;_ForwardIterator&gt;::value_type&gt;;</a>
<a name="ln826">#endif</a>
<a name="ln827"> </a>
<a name="ln828">  /** @brief Standard regular expressions. */</a>
<a name="ln829">  typedef basic_regex&lt;char&gt;    regex;</a>
<a name="ln830"> </a>
<a name="ln831">#ifdef _GLIBCXX_USE_WCHAR_T</a>
<a name="ln832">  /** @brief Standard wide-character regular expressions. */</a>
<a name="ln833">  typedef basic_regex&lt;wchar_t&gt; wregex;</a>
<a name="ln834">#endif</a>
<a name="ln835"> </a>
<a name="ln836"> </a>
<a name="ln837">  // [7.8.6] basic_regex swap</a>
<a name="ln838">  /**</a>
<a name="ln839">   * @brief Swaps the contents of two regular expression objects.</a>
<a name="ln840">   * @param __lhs First regular expression.</a>
<a name="ln841">   * @param __rhs Second regular expression.</a>
<a name="ln842">   */</a>
<a name="ln843">  template&lt;typename _Ch_type, typename _Rx_traits&gt;</a>
<a name="ln844">    inline void</a>
<a name="ln845">    swap(basic_regex&lt;_Ch_type, _Rx_traits&gt;&amp; __lhs,</a>
<a name="ln846">	 basic_regex&lt;_Ch_type, _Rx_traits&gt;&amp; __rhs)</a>
<a name="ln847">    { __lhs.swap(__rhs); }</a>
<a name="ln848"> </a>
<a name="ln849"> </a>
<a name="ln850">  // [7.9] Class template sub_match</a>
<a name="ln851">  /**</a>
<a name="ln852">   * A sequence of characters matched by a particular marked sub-expression.</a>
<a name="ln853">   *</a>
<a name="ln854">   * An object of this class is essentially a pair of iterators marking a</a>
<a name="ln855">   * matched subexpression within a regular expression pattern match. Such</a>
<a name="ln856">   * objects can be converted to and compared with std::basic_string objects</a>
<a name="ln857">   * of a similar base character type as the pattern matched by the regular</a>
<a name="ln858">   * expression.</a>
<a name="ln859">   *</a>
<a name="ln860">   * The iterators that make up the pair are the usual half-open interval</a>
<a name="ln861">   * referencing the actual original pattern matched.</a>
<a name="ln862">   */</a>
<a name="ln863">  template&lt;typename _BiIter&gt;</a>
<a name="ln864">    class sub_match : public std::pair&lt;_BiIter, _BiIter&gt;</a>
<a name="ln865">    {</a>
<a name="ln866">      typedef iterator_traits&lt;_BiIter&gt;			__iter_traits;</a>
<a name="ln867">	</a>
<a name="ln868">    public:</a>
<a name="ln869">      typedef typename __iter_traits::value_type      	value_type;</a>
<a name="ln870">      typedef typename __iter_traits::difference_type 	difference_type;</a>
<a name="ln871">      typedef _BiIter				   iterator;</a>
<a name="ln872">      typedef std::basic_string&lt;value_type&gt;	     string_type;</a>
<a name="ln873"> </a>
<a name="ln874">      bool matched;</a>
<a name="ln875"> </a>
<a name="ln876">      constexpr sub_match() : matched() { }</a>
<a name="ln877"> </a>
<a name="ln878">      /**</a>
<a name="ln879">       * Gets the length of the matching sequence.</a>
<a name="ln880">       */</a>
<a name="ln881">      difference_type</a>
<a name="ln882">      length() const</a>
<a name="ln883">      { return this-&gt;matched ? std::distance(this-&gt;first, this-&gt;second) : 0; }</a>
<a name="ln884"> </a>
<a name="ln885">      /**</a>
<a name="ln886">       * @brief Gets the matching sequence as a string.</a>
<a name="ln887">       *</a>
<a name="ln888">       * @returns the matching sequence as a string.</a>
<a name="ln889">       *</a>
<a name="ln890">       * This is the implicit conversion operator.  It is identical to the</a>
<a name="ln891">       * str() member function except that it will want to pop up in</a>
<a name="ln892">       * unexpected places and cause a great deal of confusion and cursing</a>
<a name="ln893">       * from the unwary.</a>
<a name="ln894">       */</a>
<a name="ln895">      operator string_type() const</a>
<a name="ln896">      {</a>
<a name="ln897">	return this-&gt;matched</a>
<a name="ln898">	  ? string_type(this-&gt;first, this-&gt;second)</a>
<a name="ln899">	  : string_type();</a>
<a name="ln900">      }</a>
<a name="ln901"> </a>
<a name="ln902">      /**</a>
<a name="ln903">       * @brief Gets the matching sequence as a string.</a>
<a name="ln904">       *</a>
<a name="ln905">       * @returns the matching sequence as a string.</a>
<a name="ln906">       */</a>
<a name="ln907">      string_type</a>
<a name="ln908">      str() const</a>
<a name="ln909">      {</a>
<a name="ln910">	return this-&gt;matched</a>
<a name="ln911">	  ? string_type(this-&gt;first, this-&gt;second)</a>
<a name="ln912">	  : string_type();</a>
<a name="ln913">      }</a>
<a name="ln914"> </a>
<a name="ln915">      /**</a>
<a name="ln916">       * @brief Compares this and another matched sequence.</a>
<a name="ln917">       *</a>
<a name="ln918">       * @param __s Another matched sequence to compare to this one.</a>
<a name="ln919">       *</a>
<a name="ln920">       * @retval &lt;0 this matched sequence will collate before @p __s.</a>
<a name="ln921">       * @retval =0 this matched sequence is equivalent to @p __s.</a>
<a name="ln922">       * @retval &lt;0 this matched sequence will collate after @p __s.</a>
<a name="ln923">       */</a>
<a name="ln924">      int</a>
<a name="ln925">      compare(const sub_match&amp; __s) const</a>
<a name="ln926">      { return this-&gt;str().compare(__s.str()); }</a>
<a name="ln927"> </a>
<a name="ln928">      /**</a>
<a name="ln929">       * @brief Compares this sub_match to a string.</a>
<a name="ln930">       *</a>
<a name="ln931">       * @param __s A string to compare to this sub_match.</a>
<a name="ln932">       *</a>
<a name="ln933">       * @retval &lt;0 this matched sequence will collate before @p __s.</a>
<a name="ln934">       * @retval =0 this matched sequence is equivalent to @p __s.</a>
<a name="ln935">       * @retval &lt;0 this matched sequence will collate after @p __s.</a>
<a name="ln936">       */</a>
<a name="ln937">      int</a>
<a name="ln938">      compare(const string_type&amp; __s) const</a>
<a name="ln939">      { return this-&gt;str().compare(__s); }</a>
<a name="ln940"> </a>
<a name="ln941">      /**</a>
<a name="ln942">       * @brief Compares this sub_match to a C-style string.</a>
<a name="ln943">       *</a>
<a name="ln944">       * @param __s A C-style string to compare to this sub_match.</a>
<a name="ln945">       *</a>
<a name="ln946">       * @retval &lt;0 this matched sequence will collate before @p __s.</a>
<a name="ln947">       * @retval =0 this matched sequence is equivalent to @p __s.</a>
<a name="ln948">       * @retval &lt;0 this matched sequence will collate after @p __s.</a>
<a name="ln949">       */</a>
<a name="ln950">      int</a>
<a name="ln951">      compare(const value_type* __s) const</a>
<a name="ln952">      { return this-&gt;str().compare(__s); }</a>
<a name="ln953">    };</a>
<a name="ln954"> </a>
<a name="ln955"> </a>
<a name="ln956">  /** @brief Standard regex submatch over a C-style null-terminated string. */</a>
<a name="ln957">  typedef sub_match&lt;const char*&gt;	     csub_match;</a>
<a name="ln958"> </a>
<a name="ln959">  /** @brief Standard regex submatch over a standard string. */</a>
<a name="ln960">  typedef sub_match&lt;string::const_iterator&gt;  ssub_match;</a>
<a name="ln961"> </a>
<a name="ln962">#ifdef _GLIBCXX_USE_WCHAR_T</a>
<a name="ln963">  /** @brief Regex submatch over a C-style null-terminated wide string. */</a>
<a name="ln964">  typedef sub_match&lt;const wchar_t*&gt;	  wcsub_match;</a>
<a name="ln965"> </a>
<a name="ln966">  /** @brief Regex submatch over a standard wide string. */</a>
<a name="ln967">  typedef sub_match&lt;wstring::const_iterator&gt; wssub_match;</a>
<a name="ln968">#endif</a>
<a name="ln969"> </a>
<a name="ln970">  // [7.9.2] sub_match non-member operators</a>
<a name="ln971"> </a>
<a name="ln972">  /**</a>
<a name="ln973">   * @brief Tests the equivalence of two regular expression submatches.</a>
<a name="ln974">   * @param __lhs First regular expression submatch.</a>
<a name="ln975">   * @param __rhs Second regular expression submatch.</a>
<a name="ln976">   * @returns true if @a __lhs  is equivalent to @a __rhs, false otherwise.</a>
<a name="ln977">   */</a>
<a name="ln978">  template&lt;typename _BiIter&gt;</a>
<a name="ln979">    inline bool</a>
<a name="ln980">    operator==(const sub_match&lt;_BiIter&gt;&amp; __lhs, const sub_match&lt;_BiIter&gt;&amp; __rhs)</a>
<a name="ln981">    { return __lhs.compare(__rhs) == 0; }</a>
<a name="ln982"> </a>
<a name="ln983">  /**</a>
<a name="ln984">   * @brief Tests the inequivalence of two regular expression submatches.</a>
<a name="ln985">   * @param __lhs First regular expression submatch.</a>
<a name="ln986">   * @param __rhs Second regular expression submatch.</a>
<a name="ln987">   * @returns true if @a __lhs  is not equivalent to @a __rhs, false otherwise.</a>
<a name="ln988">   */</a>
<a name="ln989">  template&lt;typename _BiIter&gt;</a>
<a name="ln990">    inline bool</a>
<a name="ln991">    operator!=(const sub_match&lt;_BiIter&gt;&amp; __lhs, const sub_match&lt;_BiIter&gt;&amp; __rhs)</a>
<a name="ln992">    { return __lhs.compare(__rhs) != 0; }</a>
<a name="ln993"> </a>
<a name="ln994">  /**</a>
<a name="ln995">   * @brief Tests the ordering of two regular expression submatches.</a>
<a name="ln996">   * @param __lhs First regular expression submatch.</a>
<a name="ln997">   * @param __rhs Second regular expression submatch.</a>
<a name="ln998">   * @returns true if @a __lhs precedes @a __rhs, false otherwise.</a>
<a name="ln999">   */</a>
<a name="ln1000">  template&lt;typename _BiIter&gt;</a>
<a name="ln1001">    inline bool</a>
<a name="ln1002">    operator&lt;(const sub_match&lt;_BiIter&gt;&amp; __lhs, const sub_match&lt;_BiIter&gt;&amp; __rhs)</a>
<a name="ln1003">    { return __lhs.compare(__rhs) &lt; 0; }</a>
<a name="ln1004"> </a>
<a name="ln1005">  /**</a>
<a name="ln1006">   * @brief Tests the ordering of two regular expression submatches.</a>
<a name="ln1007">   * @param __lhs First regular expression submatch.</a>
<a name="ln1008">   * @param __rhs Second regular expression submatch.</a>
<a name="ln1009">   * @returns true if @a __lhs does not succeed @a __rhs, false otherwise.</a>
<a name="ln1010">   */</a>
<a name="ln1011">  template&lt;typename _BiIter&gt;</a>
<a name="ln1012">    inline bool</a>
<a name="ln1013">    operator&lt;=(const sub_match&lt;_BiIter&gt;&amp; __lhs, const sub_match&lt;_BiIter&gt;&amp; __rhs)</a>
<a name="ln1014">    { return __lhs.compare(__rhs) &lt;= 0; }</a>
<a name="ln1015"> </a>
<a name="ln1016">  /**</a>
<a name="ln1017">   * @brief Tests the ordering of two regular expression submatches.</a>
<a name="ln1018">   * @param __lhs First regular expression submatch.</a>
<a name="ln1019">   * @param __rhs Second regular expression submatch.</a>
<a name="ln1020">   * @returns true if @a __lhs does not precede @a __rhs, false otherwise.</a>
<a name="ln1021">   */</a>
<a name="ln1022">  template&lt;typename _BiIter&gt;</a>
<a name="ln1023">    inline bool</a>
<a name="ln1024">    operator&gt;=(const sub_match&lt;_BiIter&gt;&amp; __lhs, const sub_match&lt;_BiIter&gt;&amp; __rhs)</a>
<a name="ln1025">    { return __lhs.compare(__rhs) &gt;= 0; }</a>
<a name="ln1026"> </a>
<a name="ln1027">  /**</a>
<a name="ln1028">   * @brief Tests the ordering of two regular expression submatches.</a>
<a name="ln1029">   * @param __lhs First regular expression submatch.</a>
<a name="ln1030">   * @param __rhs Second regular expression submatch.</a>
<a name="ln1031">   * @returns true if @a __lhs succeeds @a __rhs, false otherwise.</a>
<a name="ln1032">   */</a>
<a name="ln1033">  template&lt;typename _BiIter&gt;</a>
<a name="ln1034">    inline bool</a>
<a name="ln1035">    operator&gt;(const sub_match&lt;_BiIter&gt;&amp; __lhs, const sub_match&lt;_BiIter&gt;&amp; __rhs)</a>
<a name="ln1036">    { return __lhs.compare(__rhs) &gt; 0; }</a>
<a name="ln1037"> </a>
<a name="ln1038">  // Alias for sub_match'd string.</a>
<a name="ln1039">  template&lt;typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc&gt;</a>
<a name="ln1040">    using __sub_match_string = basic_string&lt;</a>
<a name="ln1041">			      typename iterator_traits&lt;_Bi_iter&gt;::value_type,</a>
<a name="ln1042">			      _Ch_traits, _Ch_alloc&gt;;</a>
<a name="ln1043"> </a>
<a name="ln1044">  /**</a>
<a name="ln1045">   * @brief Tests the equivalence of a string and a regular expression</a>
<a name="ln1046">   *        submatch.</a>
<a name="ln1047">   * @param __lhs A string.</a>
<a name="ln1048">   * @param __rhs A regular expression submatch.</a>
<a name="ln1049">   * @returns true if @a __lhs  is equivalent to @a __rhs, false otherwise.</a>
<a name="ln1050">   */</a>
<a name="ln1051">  template&lt;typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc&gt;</a>
<a name="ln1052">    inline bool</a>
<a name="ln1053">    operator==(const __sub_match_string&lt;_Bi_iter, _Ch_traits, _Ch_alloc&gt;&amp; __lhs,</a>
<a name="ln1054">	       const sub_match&lt;_Bi_iter&gt;&amp; __rhs)</a>
<a name="ln1055">    {</a>
<a name="ln1056">      typedef typename sub_match&lt;_Bi_iter&gt;::string_type string_type;</a>
<a name="ln1057">      return __rhs.compare(string_type(__lhs.data(), __lhs.size())) == 0;</a>
<a name="ln1058">    }</a>
<a name="ln1059"> </a>
<a name="ln1060">  /**</a>
<a name="ln1061">   * @brief Tests the inequivalence of a string and a regular expression</a>
<a name="ln1062">   *        submatch.</a>
<a name="ln1063">   * @param __lhs A string.</a>
<a name="ln1064">   * @param __rhs A regular expression submatch.</a>
<a name="ln1065">   * @returns true if @a __lhs  is not equivalent to @a __rhs, false otherwise.</a>
<a name="ln1066">   */</a>
<a name="ln1067">  template&lt;typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc&gt;</a>
<a name="ln1068">    inline bool</a>
<a name="ln1069">    operator!=(const __sub_match_string&lt;_Bi_iter, _Ch_traits, _Ch_alloc&gt;&amp; __lhs,</a>
<a name="ln1070">	       const sub_match&lt;_Bi_iter&gt;&amp; __rhs)</a>
<a name="ln1071">    { return !(__lhs == __rhs); }</a>
<a name="ln1072"> </a>
<a name="ln1073">  /**</a>
<a name="ln1074">   * @brief Tests the ordering of a string and a regular expression submatch.</a>
<a name="ln1075">   * @param __lhs A string.</a>
<a name="ln1076">   * @param __rhs A regular expression submatch.</a>
<a name="ln1077">   * @returns true if @a __lhs precedes @a __rhs, false otherwise.</a>
<a name="ln1078">   */</a>
<a name="ln1079">  template&lt;typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc&gt;</a>
<a name="ln1080">    inline bool</a>
<a name="ln1081">    operator&lt;(const __sub_match_string&lt;_Bi_iter, _Ch_traits, _Ch_alloc&gt;&amp; __lhs,</a>
<a name="ln1082">	      const sub_match&lt;_Bi_iter&gt;&amp; __rhs)</a>
<a name="ln1083">    {</a>
<a name="ln1084">      typedef typename sub_match&lt;_Bi_iter&gt;::string_type string_type;</a>
<a name="ln1085">      return __rhs.compare(string_type(__lhs.data(), __lhs.size())) &gt; 0;</a>
<a name="ln1086">    }</a>
<a name="ln1087"> </a>
<a name="ln1088">  /**</a>
<a name="ln1089">   * @brief Tests the ordering of a string and a regular expression submatch.</a>
<a name="ln1090">   * @param __lhs A string.</a>
<a name="ln1091">   * @param __rhs A regular expression submatch.</a>
<a name="ln1092">   * @returns true if @a __lhs succeeds @a __rhs, false otherwise.</a>
<a name="ln1093">   */</a>
<a name="ln1094">  template&lt;typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc&gt;</a>
<a name="ln1095">    inline bool</a>
<a name="ln1096">    operator&gt;(const __sub_match_string&lt;_Bi_iter, _Ch_traits, _Ch_alloc&gt;&amp; __lhs,</a>
<a name="ln1097">	      const sub_match&lt;_Bi_iter&gt;&amp; __rhs)</a>
<a name="ln1098">    { return __rhs &lt; __lhs; }</a>
<a name="ln1099"> </a>
<a name="ln1100">  /**</a>
<a name="ln1101">   * @brief Tests the ordering of a string and a regular expression submatch.</a>
<a name="ln1102">   * @param __lhs A string.</a>
<a name="ln1103">   * @param __rhs A regular expression submatch.</a>
<a name="ln1104">   * @returns true if @a __lhs does not precede @a __rhs, false otherwise.</a>
<a name="ln1105">   */</a>
<a name="ln1106">  template&lt;typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc&gt;</a>
<a name="ln1107">    inline bool</a>
<a name="ln1108">    operator&gt;=(const __sub_match_string&lt;_Bi_iter, _Ch_traits, _Ch_alloc&gt;&amp; __lhs,</a>
<a name="ln1109">	       const sub_match&lt;_Bi_iter&gt;&amp; __rhs)</a>
<a name="ln1110">    { return !(__lhs &lt; __rhs); }</a>
<a name="ln1111"> </a>
<a name="ln1112">  /**</a>
<a name="ln1113">   * @brief Tests the ordering of a string and a regular expression submatch.</a>
<a name="ln1114">   * @param __lhs A string.</a>
<a name="ln1115">   * @param __rhs A regular expression submatch.</a>
<a name="ln1116">   * @returns true if @a __lhs does not succeed @a __rhs, false otherwise.</a>
<a name="ln1117">   */</a>
<a name="ln1118">  template&lt;typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc&gt;</a>
<a name="ln1119">    inline bool</a>
<a name="ln1120">    operator&lt;=(const __sub_match_string&lt;_Bi_iter, _Ch_traits, _Ch_alloc&gt;&amp; __lhs,</a>
<a name="ln1121">	       const sub_match&lt;_Bi_iter&gt;&amp; __rhs)</a>
<a name="ln1122">    { return !(__rhs &lt; __lhs); }</a>
<a name="ln1123"> </a>
<a name="ln1124">  /**</a>
<a name="ln1125">   * @brief Tests the equivalence of a regular expression submatch and a</a>
<a name="ln1126">   *        string.</a>
<a name="ln1127">   * @param __lhs A regular expression submatch.</a>
<a name="ln1128">   * @param __rhs A string.</a>
<a name="ln1129">   * @returns true if @a __lhs is equivalent to @a __rhs, false otherwise.</a>
<a name="ln1130">   */</a>
<a name="ln1131">  template&lt;typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc&gt;</a>
<a name="ln1132">    inline bool</a>
<a name="ln1133">    operator==(const sub_match&lt;_Bi_iter&gt;&amp; __lhs,</a>
<a name="ln1134">	       const __sub_match_string&lt;_Bi_iter, _Ch_traits, _Ch_alloc&gt;&amp; __rhs)</a>
<a name="ln1135">    {</a>
<a name="ln1136">      typedef typename sub_match&lt;_Bi_iter&gt;::string_type string_type;</a>
<a name="ln1137">      return __lhs.compare(string_type(__rhs.data(), __rhs.size())) == 0;</a>
<a name="ln1138">    }</a>
<a name="ln1139"> </a>
<a name="ln1140">  /**</a>
<a name="ln1141">   * @brief Tests the inequivalence of a regular expression submatch and a</a>
<a name="ln1142">   *        string.</a>
<a name="ln1143">   * @param __lhs A regular expression submatch.</a>
<a name="ln1144">   * @param __rhs A string.</a>
<a name="ln1145">   * @returns true if @a __lhs is not equivalent to @a __rhs, false otherwise.</a>
<a name="ln1146">   */</a>
<a name="ln1147">  template&lt;typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc&gt;</a>
<a name="ln1148">    inline bool</a>
<a name="ln1149">    operator!=(const sub_match&lt;_Bi_iter&gt;&amp; __lhs,</a>
<a name="ln1150">	       const __sub_match_string&lt;_Bi_iter, _Ch_traits, _Ch_alloc&gt;&amp; __rhs)</a>
<a name="ln1151">    { return !(__lhs == __rhs); }</a>
<a name="ln1152"> </a>
<a name="ln1153">  /**</a>
<a name="ln1154">   * @brief Tests the ordering of a regular expression submatch and a string.</a>
<a name="ln1155">   * @param __lhs A regular expression submatch.</a>
<a name="ln1156">   * @param __rhs A string.</a>
<a name="ln1157">   * @returns true if @a __lhs precedes @a __rhs, false otherwise.</a>
<a name="ln1158">   */</a>
<a name="ln1159">  template&lt;typename _Bi_iter, class _Ch_traits, class _Ch_alloc&gt;</a>
<a name="ln1160">    inline bool</a>
<a name="ln1161">    operator&lt;(const sub_match&lt;_Bi_iter&gt;&amp; __lhs,</a>
<a name="ln1162">	      const __sub_match_string&lt;_Bi_iter, _Ch_traits, _Ch_alloc&gt;&amp; __rhs)</a>
<a name="ln1163">    {</a>
<a name="ln1164">      typedef typename sub_match&lt;_Bi_iter&gt;::string_type string_type;</a>
<a name="ln1165">      return __lhs.compare(string_type(__rhs.data(), __rhs.size())) &lt; 0;</a>
<a name="ln1166">    }</a>
<a name="ln1167"> </a>
<a name="ln1168">  /**</a>
<a name="ln1169">   * @brief Tests the ordering of a regular expression submatch and a string.</a>
<a name="ln1170">   * @param __lhs A regular expression submatch.</a>
<a name="ln1171">   * @param __rhs A string.</a>
<a name="ln1172">   * @returns true if @a __lhs succeeds @a __rhs, false otherwise.</a>
<a name="ln1173">   */</a>
<a name="ln1174">  template&lt;typename _Bi_iter, class _Ch_traits, class _Ch_alloc&gt;</a>
<a name="ln1175">    inline bool</a>
<a name="ln1176">    operator&gt;(const sub_match&lt;_Bi_iter&gt;&amp; __lhs,</a>
<a name="ln1177">	      const __sub_match_string&lt;_Bi_iter, _Ch_traits, _Ch_alloc&gt;&amp; __rhs)</a>
<a name="ln1178">    { return __rhs &lt; __lhs; }</a>
<a name="ln1179"> </a>
<a name="ln1180">  /**</a>
<a name="ln1181">   * @brief Tests the ordering of a regular expression submatch and a string.</a>
<a name="ln1182">   * @param __lhs A regular expression submatch.</a>
<a name="ln1183">   * @param __rhs A string.</a>
<a name="ln1184">   * @returns true if @a __lhs does not precede @a __rhs, false otherwise.</a>
<a name="ln1185">   */</a>
<a name="ln1186">  template&lt;typename _Bi_iter, class _Ch_traits, class _Ch_alloc&gt;</a>
<a name="ln1187">    inline bool</a>
<a name="ln1188">    operator&gt;=(const sub_match&lt;_Bi_iter&gt;&amp; __lhs,</a>
<a name="ln1189">	       const __sub_match_string&lt;_Bi_iter, _Ch_traits, _Ch_alloc&gt;&amp; __rhs)</a>
<a name="ln1190">    { return !(__lhs &lt; __rhs); }</a>
<a name="ln1191"> </a>
<a name="ln1192">  /**</a>
<a name="ln1193">   * @brief Tests the ordering of a regular expression submatch and a string.</a>
<a name="ln1194">   * @param __lhs A regular expression submatch.</a>
<a name="ln1195">   * @param __rhs A string.</a>
<a name="ln1196">   * @returns true if @a __lhs does not succeed @a __rhs, false otherwise.</a>
<a name="ln1197">   */</a>
<a name="ln1198">  template&lt;typename _Bi_iter, class _Ch_traits, class _Ch_alloc&gt;</a>
<a name="ln1199">    inline bool</a>
<a name="ln1200">    operator&lt;=(const sub_match&lt;_Bi_iter&gt;&amp; __lhs,</a>
<a name="ln1201">	       const __sub_match_string&lt;_Bi_iter, _Ch_traits, _Ch_alloc&gt;&amp; __rhs)</a>
<a name="ln1202">    { return !(__rhs &lt; __lhs); }</a>
<a name="ln1203"> </a>
<a name="ln1204">  /**</a>
<a name="ln1205">   * @brief Tests the equivalence of a C string and a regular expression</a>
<a name="ln1206">   *        submatch.</a>
<a name="ln1207">   * @param __lhs A C string.</a>
<a name="ln1208">   * @param __rhs A regular expression submatch.</a>
<a name="ln1209">   * @returns true if @a __lhs  is equivalent to @a __rhs, false otherwise.</a>
<a name="ln1210">   */</a>
<a name="ln1211">  template&lt;typename _Bi_iter&gt;</a>
<a name="ln1212">    inline bool</a>
<a name="ln1213">    operator==(typename iterator_traits&lt;_Bi_iter&gt;::value_type const* __lhs,</a>
<a name="ln1214">	       const sub_match&lt;_Bi_iter&gt;&amp; __rhs)</a>
<a name="ln1215">    { return __rhs.compare(__lhs) == 0; }</a>
<a name="ln1216"> </a>
<a name="ln1217">  /**</a>
<a name="ln1218">   * @brief Tests the inequivalence of an iterator value and a regular</a>
<a name="ln1219">   *        expression submatch.</a>
<a name="ln1220">   * @param __lhs A regular expression submatch.</a>
<a name="ln1221">   * @param __rhs A string.</a>
<a name="ln1222">   * @returns true if @a __lhs is not equivalent to @a __rhs, false otherwise.</a>
<a name="ln1223">   */</a>
<a name="ln1224">  template&lt;typename _Bi_iter&gt;</a>
<a name="ln1225">    inline bool</a>
<a name="ln1226">    operator!=(typename iterator_traits&lt;_Bi_iter&gt;::value_type const* __lhs,</a>
<a name="ln1227">	       const sub_match&lt;_Bi_iter&gt;&amp; __rhs)</a>
<a name="ln1228">    { return !(__lhs == __rhs); }</a>
<a name="ln1229"> </a>
<a name="ln1230">  /**</a>
<a name="ln1231">   * @brief Tests the ordering of a string and a regular expression submatch.</a>
<a name="ln1232">   * @param __lhs A string.</a>
<a name="ln1233">   * @param __rhs A regular expression submatch.</a>
<a name="ln1234">   * @returns true if @a __lhs precedes @a __rhs, false otherwise.</a>
<a name="ln1235">   */</a>
<a name="ln1236">  template&lt;typename _Bi_iter&gt;</a>
<a name="ln1237">    inline bool</a>
<a name="ln1238">    operator&lt;(typename iterator_traits&lt;_Bi_iter&gt;::value_type const* __lhs,</a>
<a name="ln1239">	      const sub_match&lt;_Bi_iter&gt;&amp; __rhs)</a>
<a name="ln1240">    { return __rhs.compare(__lhs) &gt; 0; }</a>
<a name="ln1241"> </a>
<a name="ln1242">  /**</a>
<a name="ln1243">   * @brief Tests the ordering of a string and a regular expression submatch.</a>
<a name="ln1244">   * @param __lhs A string.</a>
<a name="ln1245">   * @param __rhs A regular expression submatch.</a>
<a name="ln1246">   * @returns true if @a __lhs succeeds @a __rhs, false otherwise.</a>
<a name="ln1247">   */</a>
<a name="ln1248">  template&lt;typename _Bi_iter&gt;</a>
<a name="ln1249">    inline bool</a>
<a name="ln1250">    operator&gt;(typename iterator_traits&lt;_Bi_iter&gt;::value_type const* __lhs,</a>
<a name="ln1251">	      const sub_match&lt;_Bi_iter&gt;&amp; __rhs)</a>
<a name="ln1252">    { return __rhs &lt; __lhs; }</a>
<a name="ln1253"> </a>
<a name="ln1254">  /**</a>
<a name="ln1255">   * @brief Tests the ordering of a string and a regular expression submatch.</a>
<a name="ln1256">   * @param __lhs A string.</a>
<a name="ln1257">   * @param __rhs A regular expression submatch.</a>
<a name="ln1258">   * @returns true if @a __lhs does not precede @a __rhs, false otherwise.</a>
<a name="ln1259">   */</a>
<a name="ln1260">  template&lt;typename _Bi_iter&gt;</a>
<a name="ln1261">    inline bool</a>
<a name="ln1262">    operator&gt;=(typename iterator_traits&lt;_Bi_iter&gt;::value_type const* __lhs,</a>
<a name="ln1263">	       const sub_match&lt;_Bi_iter&gt;&amp; __rhs)</a>
<a name="ln1264">    { return !(__lhs &lt; __rhs); }</a>
<a name="ln1265"> </a>
<a name="ln1266">  /**</a>
<a name="ln1267">   * @brief Tests the ordering of a string and a regular expression submatch.</a>
<a name="ln1268">   * @param __lhs A string.</a>
<a name="ln1269">   * @param __rhs A regular expression submatch.</a>
<a name="ln1270">   * @returns true if @a __lhs does not succeed @a __rhs, false otherwise.</a>
<a name="ln1271">   */</a>
<a name="ln1272">  template&lt;typename _Bi_iter&gt;</a>
<a name="ln1273">    inline bool</a>
<a name="ln1274">    operator&lt;=(typename iterator_traits&lt;_Bi_iter&gt;::value_type const* __lhs,</a>
<a name="ln1275">	       const sub_match&lt;_Bi_iter&gt;&amp; __rhs)</a>
<a name="ln1276">    { return !(__rhs &lt; __lhs); }</a>
<a name="ln1277"> </a>
<a name="ln1278">  /**</a>
<a name="ln1279">   * @brief Tests the equivalence of a regular expression submatch and a</a>
<a name="ln1280">   *        string.</a>
<a name="ln1281">   * @param __lhs A regular expression submatch.</a>
<a name="ln1282">   * @param __rhs A pointer to a string?</a>
<a name="ln1283">   * @returns true if @a __lhs  is equivalent to @a __rhs, false otherwise.</a>
<a name="ln1284">   */</a>
<a name="ln1285">  template&lt;typename _Bi_iter&gt;</a>
<a name="ln1286">    inline bool</a>
<a name="ln1287">    operator==(const sub_match&lt;_Bi_iter&gt;&amp; __lhs,</a>
<a name="ln1288">	       typename iterator_traits&lt;_Bi_iter&gt;::value_type const* __rhs)</a>
<a name="ln1289">    { return __lhs.compare(__rhs) == 0; }</a>
<a name="ln1290"> </a>
<a name="ln1291">  /**</a>
<a name="ln1292">   * @brief Tests the inequivalence of a regular expression submatch and a</a>
<a name="ln1293">   *        string.</a>
<a name="ln1294">   * @param __lhs A regular expression submatch.</a>
<a name="ln1295">   * @param __rhs A pointer to a string.</a>
<a name="ln1296">   * @returns true if @a __lhs is not equivalent to @a __rhs, false otherwise.</a>
<a name="ln1297">   */</a>
<a name="ln1298">  template&lt;typename _Bi_iter&gt;</a>
<a name="ln1299">    inline bool</a>
<a name="ln1300">    operator!=(const sub_match&lt;_Bi_iter&gt;&amp; __lhs,</a>
<a name="ln1301">	       typename iterator_traits&lt;_Bi_iter&gt;::value_type const* __rhs)</a>
<a name="ln1302">    { return !(__lhs == __rhs); }</a>
<a name="ln1303"> </a>
<a name="ln1304">  /**</a>
<a name="ln1305">   * @brief Tests the ordering of a regular expression submatch and a string.</a>
<a name="ln1306">   * @param __lhs A regular expression submatch.</a>
<a name="ln1307">   * @param __rhs A string.</a>
<a name="ln1308">   * @returns true if @a __lhs precedes @a __rhs, false otherwise.</a>
<a name="ln1309">   */</a>
<a name="ln1310">  template&lt;typename _Bi_iter&gt;</a>
<a name="ln1311">    inline bool</a>
<a name="ln1312">    operator&lt;(const sub_match&lt;_Bi_iter&gt;&amp; __lhs,</a>
<a name="ln1313">	      typename iterator_traits&lt;_Bi_iter&gt;::value_type const* __rhs)</a>
<a name="ln1314">    { return __lhs.compare(__rhs) &lt; 0; }</a>
<a name="ln1315"> </a>
<a name="ln1316">  /**</a>
<a name="ln1317">   * @brief Tests the ordering of a regular expression submatch and a string.</a>
<a name="ln1318">   * @param __lhs A regular expression submatch.</a>
<a name="ln1319">   * @param __rhs A string.</a>
<a name="ln1320">   * @returns true if @a __lhs succeeds @a __rhs, false otherwise.</a>
<a name="ln1321">   */</a>
<a name="ln1322">  template&lt;typename _Bi_iter&gt;</a>
<a name="ln1323">    inline bool</a>
<a name="ln1324">    operator&gt;(const sub_match&lt;_Bi_iter&gt;&amp; __lhs,</a>
<a name="ln1325">	      typename iterator_traits&lt;_Bi_iter&gt;::value_type const* __rhs)</a>
<a name="ln1326">    { return __rhs &lt; __lhs; }</a>
<a name="ln1327"> </a>
<a name="ln1328">  /**</a>
<a name="ln1329">   * @brief Tests the ordering of a regular expression submatch and a string.</a>
<a name="ln1330">   * @param __lhs A regular expression submatch.</a>
<a name="ln1331">   * @param __rhs A string.</a>
<a name="ln1332">   * @returns true if @a __lhs does not precede @a __rhs, false otherwise.</a>
<a name="ln1333">   */</a>
<a name="ln1334">  template&lt;typename _Bi_iter&gt;</a>
<a name="ln1335">    inline bool</a>
<a name="ln1336">    operator&gt;=(const sub_match&lt;_Bi_iter&gt;&amp; __lhs,</a>
<a name="ln1337">	       typename iterator_traits&lt;_Bi_iter&gt;::value_type const* __rhs)</a>
<a name="ln1338">    { return !(__lhs &lt; __rhs); }</a>
<a name="ln1339"> </a>
<a name="ln1340">  /**</a>
<a name="ln1341">   * @brief Tests the ordering of a regular expression submatch and a string.</a>
<a name="ln1342">   * @param __lhs A regular expression submatch.</a>
<a name="ln1343">   * @param __rhs A string.</a>
<a name="ln1344">   * @returns true if @a __lhs does not succeed @a __rhs, false otherwise.</a>
<a name="ln1345">   */</a>
<a name="ln1346">  template&lt;typename _Bi_iter&gt;</a>
<a name="ln1347">    inline bool</a>
<a name="ln1348">    operator&lt;=(const sub_match&lt;_Bi_iter&gt;&amp; __lhs,</a>
<a name="ln1349">	       typename iterator_traits&lt;_Bi_iter&gt;::value_type const* __rhs)</a>
<a name="ln1350">    { return !(__rhs &lt; __lhs); }</a>
<a name="ln1351"> </a>
<a name="ln1352">  /**</a>
<a name="ln1353">   * @brief Tests the equivalence of a string and a regular expression</a>
<a name="ln1354">   *        submatch.</a>
<a name="ln1355">   * @param __lhs A string.</a>
<a name="ln1356">   * @param __rhs A regular expression submatch.</a>
<a name="ln1357">   * @returns true if @a __lhs is equivalent to @a __rhs, false otherwise.</a>
<a name="ln1358">   */</a>
<a name="ln1359">  template&lt;typename _Bi_iter&gt;</a>
<a name="ln1360">    inline bool</a>
<a name="ln1361">    operator==(typename iterator_traits&lt;_Bi_iter&gt;::value_type const&amp; __lhs,</a>
<a name="ln1362">	       const sub_match&lt;_Bi_iter&gt;&amp; __rhs)</a>
<a name="ln1363">    {</a>
<a name="ln1364">      typedef typename sub_match&lt;_Bi_iter&gt;::string_type string_type;</a>
<a name="ln1365">      return __rhs.compare(string_type(1, __lhs)) == 0;</a>
<a name="ln1366">    }</a>
<a name="ln1367"> </a>
<a name="ln1368">  /**</a>
<a name="ln1369">   * @brief Tests the inequivalence of a string and a regular expression</a>
<a name="ln1370">   *        submatch.</a>
<a name="ln1371">   * @param __lhs A string.</a>
<a name="ln1372">   * @param __rhs A regular expression submatch.</a>
<a name="ln1373">   * @returns true if @a __lhs is not equivalent to @a __rhs, false otherwise.</a>
<a name="ln1374">   */</a>
<a name="ln1375">  template&lt;typename _Bi_iter&gt;</a>
<a name="ln1376">    inline bool</a>
<a name="ln1377">    operator!=(typename iterator_traits&lt;_Bi_iter&gt;::value_type const&amp; __lhs,</a>
<a name="ln1378">	       const sub_match&lt;_Bi_iter&gt;&amp; __rhs)</a>
<a name="ln1379">    { return !(__lhs == __rhs); }</a>
<a name="ln1380"> </a>
<a name="ln1381">  /**</a>
<a name="ln1382">   * @brief Tests the ordering of a string and a regular expression submatch.</a>
<a name="ln1383">   * @param __lhs A string.</a>
<a name="ln1384">   * @param __rhs A regular expression submatch.</a>
<a name="ln1385">   * @returns true if @a __lhs precedes @a __rhs, false otherwise.</a>
<a name="ln1386">   */</a>
<a name="ln1387">  template&lt;typename _Bi_iter&gt;</a>
<a name="ln1388">    inline bool</a>
<a name="ln1389">    operator&lt;(typename iterator_traits&lt;_Bi_iter&gt;::value_type const&amp; __lhs,</a>
<a name="ln1390">	      const sub_match&lt;_Bi_iter&gt;&amp; __rhs)</a>
<a name="ln1391">    {</a>
<a name="ln1392">      typedef typename sub_match&lt;_Bi_iter&gt;::string_type string_type;</a>
<a name="ln1393">      return __rhs.compare(string_type(1, __lhs)) &gt; 0;</a>
<a name="ln1394">    }</a>
<a name="ln1395"> </a>
<a name="ln1396">  /**</a>
<a name="ln1397">   * @brief Tests the ordering of a string and a regular expression submatch.</a>
<a name="ln1398">   * @param __lhs A string.</a>
<a name="ln1399">   * @param __rhs A regular expression submatch.</a>
<a name="ln1400">   * @returns true if @a __lhs succeeds @a __rhs, false otherwise.</a>
<a name="ln1401">   */</a>
<a name="ln1402">  template&lt;typename _Bi_iter&gt;</a>
<a name="ln1403">    inline bool</a>
<a name="ln1404">    operator&gt;(typename iterator_traits&lt;_Bi_iter&gt;::value_type const&amp; __lhs,</a>
<a name="ln1405">	      const sub_match&lt;_Bi_iter&gt;&amp; __rhs)</a>
<a name="ln1406">    { return __rhs &lt; __lhs; }</a>
<a name="ln1407"> </a>
<a name="ln1408">  /**</a>
<a name="ln1409">   * @brief Tests the ordering of a string and a regular expression submatch.</a>
<a name="ln1410">   * @param __lhs A string.</a>
<a name="ln1411">   * @param __rhs A regular expression submatch.</a>
<a name="ln1412">   * @returns true if @a __lhs does not precede @a __rhs, false otherwise.</a>
<a name="ln1413">   */</a>
<a name="ln1414">  template&lt;typename _Bi_iter&gt;</a>
<a name="ln1415">    inline bool</a>
<a name="ln1416">    operator&gt;=(typename iterator_traits&lt;_Bi_iter&gt;::value_type const&amp; __lhs,</a>
<a name="ln1417">	       const sub_match&lt;_Bi_iter&gt;&amp; __rhs)</a>
<a name="ln1418">    { return !(__lhs &lt; __rhs); }</a>
<a name="ln1419"> </a>
<a name="ln1420">  /**</a>
<a name="ln1421">   * @brief Tests the ordering of a string and a regular expression submatch.</a>
<a name="ln1422">   * @param __lhs A string.</a>
<a name="ln1423">   * @param __rhs A regular expression submatch.</a>
<a name="ln1424">   * @returns true if @a __lhs does not succeed @a __rhs, false otherwise.</a>
<a name="ln1425">   */</a>
<a name="ln1426">  template&lt;typename _Bi_iter&gt;</a>
<a name="ln1427">    inline bool</a>
<a name="ln1428">    operator&lt;=(typename iterator_traits&lt;_Bi_iter&gt;::value_type const&amp; __lhs,</a>
<a name="ln1429">	       const sub_match&lt;_Bi_iter&gt;&amp; __rhs)</a>
<a name="ln1430">    { return !(__rhs &lt; __lhs); }</a>
<a name="ln1431"> </a>
<a name="ln1432">  /**</a>
<a name="ln1433">   * @brief Tests the equivalence of a regular expression submatch and a</a>
<a name="ln1434">   *        string.</a>
<a name="ln1435">   * @param __lhs A regular expression submatch.</a>
<a name="ln1436">   * @param __rhs A const string reference.</a>
<a name="ln1437">   * @returns true if @a __lhs  is equivalent to @a __rhs, false otherwise.</a>
<a name="ln1438">   */</a>
<a name="ln1439">  template&lt;typename _Bi_iter&gt;</a>
<a name="ln1440">    inline bool</a>
<a name="ln1441">    operator==(const sub_match&lt;_Bi_iter&gt;&amp; __lhs,</a>
<a name="ln1442">	       typename iterator_traits&lt;_Bi_iter&gt;::value_type const&amp; __rhs)</a>
<a name="ln1443">    {</a>
<a name="ln1444">      typedef typename sub_match&lt;_Bi_iter&gt;::string_type string_type;</a>
<a name="ln1445">      return __lhs.compare(string_type(1, __rhs)) == 0;</a>
<a name="ln1446">    }</a>
<a name="ln1447"> </a>
<a name="ln1448">  /**</a>
<a name="ln1449">   * @brief Tests the inequivalence of a regular expression submatch and a</a>
<a name="ln1450">   *        string.</a>
<a name="ln1451">   * @param __lhs A regular expression submatch.</a>
<a name="ln1452">   * @param __rhs A const string reference.</a>
<a name="ln1453">   * @returns true if @a __lhs is not equivalent to @a __rhs, false otherwise.</a>
<a name="ln1454">   */</a>
<a name="ln1455">  template&lt;typename _Bi_iter&gt;</a>
<a name="ln1456">    inline bool</a>
<a name="ln1457">    operator!=(const sub_match&lt;_Bi_iter&gt;&amp; __lhs,</a>
<a name="ln1458">	       typename iterator_traits&lt;_Bi_iter&gt;::value_type const&amp; __rhs)</a>
<a name="ln1459">    { return !(__lhs == __rhs); }</a>
<a name="ln1460"> </a>
<a name="ln1461">  /**</a>
<a name="ln1462">   * @brief Tests the ordering of a regular expression submatch and a string.</a>
<a name="ln1463">   * @param __lhs A regular expression submatch.</a>
<a name="ln1464">   * @param __rhs A const string reference.</a>
<a name="ln1465">   * @returns true if @a __lhs precedes @a __rhs, false otherwise.</a>
<a name="ln1466">   */</a>
<a name="ln1467">  template&lt;typename _Bi_iter&gt;</a>
<a name="ln1468">    inline bool</a>
<a name="ln1469">    operator&lt;(const sub_match&lt;_Bi_iter&gt;&amp; __lhs,</a>
<a name="ln1470">	      typename iterator_traits&lt;_Bi_iter&gt;::value_type const&amp; __rhs)</a>
<a name="ln1471">    {</a>
<a name="ln1472">      typedef typename sub_match&lt;_Bi_iter&gt;::string_type string_type;</a>
<a name="ln1473">      return __lhs.compare(string_type(1, __rhs)) &lt; 0;</a>
<a name="ln1474">    }</a>
<a name="ln1475"> </a>
<a name="ln1476">  /**</a>
<a name="ln1477">   * @brief Tests the ordering of a regular expression submatch and a string.</a>
<a name="ln1478">   * @param __lhs A regular expression submatch.</a>
<a name="ln1479">   * @param __rhs A const string reference.</a>
<a name="ln1480">   * @returns true if @a __lhs succeeds @a __rhs, false otherwise.</a>
<a name="ln1481">   */</a>
<a name="ln1482">  template&lt;typename _Bi_iter&gt;</a>
<a name="ln1483">    inline bool</a>
<a name="ln1484">    operator&gt;(const sub_match&lt;_Bi_iter&gt;&amp; __lhs,</a>
<a name="ln1485">	      typename iterator_traits&lt;_Bi_iter&gt;::value_type const&amp; __rhs)</a>
<a name="ln1486">    { return __rhs &lt; __lhs; }</a>
<a name="ln1487"> </a>
<a name="ln1488">  /**</a>
<a name="ln1489">   * @brief Tests the ordering of a regular expression submatch and a string.</a>
<a name="ln1490">   * @param __lhs A regular expression submatch.</a>
<a name="ln1491">   * @param __rhs A const string reference.</a>
<a name="ln1492">   * @returns true if @a __lhs does not precede @a __rhs, false otherwise.</a>
<a name="ln1493">   */</a>
<a name="ln1494">  template&lt;typename _Bi_iter&gt;</a>
<a name="ln1495">    inline bool</a>
<a name="ln1496">    operator&gt;=(const sub_match&lt;_Bi_iter&gt;&amp; __lhs,</a>
<a name="ln1497">	       typename iterator_traits&lt;_Bi_iter&gt;::value_type const&amp; __rhs)</a>
<a name="ln1498">    { return !(__lhs &lt; __rhs); }</a>
<a name="ln1499"> </a>
<a name="ln1500">  /**</a>
<a name="ln1501">   * @brief Tests the ordering of a regular expression submatch and a string.</a>
<a name="ln1502">   * @param __lhs A regular expression submatch.</a>
<a name="ln1503">   * @param __rhs A const string reference.</a>
<a name="ln1504">   * @returns true if @a __lhs does not succeed @a __rhs, false otherwise.</a>
<a name="ln1505">   */</a>
<a name="ln1506">  template&lt;typename _Bi_iter&gt;</a>
<a name="ln1507">    inline bool</a>
<a name="ln1508">    operator&lt;=(const sub_match&lt;_Bi_iter&gt;&amp; __lhs,</a>
<a name="ln1509">	       typename iterator_traits&lt;_Bi_iter&gt;::value_type const&amp; __rhs)</a>
<a name="ln1510">    { return !(__rhs &lt; __lhs); }</a>
<a name="ln1511"> </a>
<a name="ln1512">  /**</a>
<a name="ln1513">   * @brief Inserts a matched string into an output stream.</a>
<a name="ln1514">   *</a>
<a name="ln1515">   * @param __os The output stream.</a>
<a name="ln1516">   * @param __m  A submatch string.</a>
<a name="ln1517">   *</a>
<a name="ln1518">   * @returns the output stream with the submatch string inserted.</a>
<a name="ln1519">   */</a>
<a name="ln1520">  template&lt;typename _Ch_type, typename _Ch_traits, typename _Bi_iter&gt;</a>
<a name="ln1521">    inline</a>
<a name="ln1522">    basic_ostream&lt;_Ch_type, _Ch_traits&gt;&amp;</a>
<a name="ln1523">    operator&lt;&lt;(basic_ostream&lt;_Ch_type, _Ch_traits&gt;&amp; __os,</a>
<a name="ln1524">	       const sub_match&lt;_Bi_iter&gt;&amp; __m)</a>
<a name="ln1525">    { return __os &lt;&lt; __m.str(); }</a>
<a name="ln1526"> </a>
<a name="ln1527">  // [7.10] Class template match_results</a>
<a name="ln1528"> </a>
<a name="ln1529">  /**</a>
<a name="ln1530">   * @brief The results of a match or search operation.</a>
<a name="ln1531">   *</a>
<a name="ln1532">   * A collection of character sequences representing the result of a regular</a>
<a name="ln1533">   * expression match.  Storage for the collection is allocated and freed as</a>
<a name="ln1534">   * necessary by the member functions of class template match_results.</a>
<a name="ln1535">   *</a>
<a name="ln1536">   * This class satisfies the Sequence requirements, with the exception that</a>
<a name="ln1537">   * only the operations defined for a const-qualified Sequence are supported.</a>
<a name="ln1538">   *</a>
<a name="ln1539">   * The sub_match object stored at index 0 represents sub-expression 0, i.e.</a>
<a name="ln1540">   * the whole match. In this case the %sub_match member matched is always true.</a>
<a name="ln1541">   * The sub_match object stored at index n denotes what matched the marked</a>
<a name="ln1542">   * sub-expression n within the matched expression. If the sub-expression n</a>
<a name="ln1543">   * participated in a regular expression match then the %sub_match member</a>
<a name="ln1544">   * matched evaluates to true, and members first and second denote the range</a>
<a name="ln1545">   * of characters [first, second) which formed that match. Otherwise matched</a>
<a name="ln1546">   * is false, and members first and second point to the end of the sequence</a>
<a name="ln1547">   * that was searched.</a>
<a name="ln1548">   *</a>
<a name="ln1549">   * @nosubgrouping</a>
<a name="ln1550">   */</a>
<a name="ln1551">  template&lt;typename _Bi_iter,</a>
<a name="ln1552">	   typename _Alloc = allocator&lt;sub_match&lt;_Bi_iter&gt; &gt; &gt;</a>
<a name="ln1553">    class match_results</a>
<a name="ln1554">    : private std::vector&lt;sub_match&lt;_Bi_iter&gt;, _Alloc&gt;</a>
<a name="ln1555">    {</a>
<a name="ln1556">    private:</a>
<a name="ln1557">      /*</a>
<a name="ln1558">       * The vector base is empty if this does not represent a match (!ready());</a>
<a name="ln1559">       * Otherwise if it's a match failure, it contains 3 elements:</a>
<a name="ln1560">       * [0] unmatched</a>
<a name="ln1561">       * [1] prefix</a>
<a name="ln1562">       * [2] suffix</a>
<a name="ln1563">       * Otherwise it contains n+4 elements where n is the number of marked</a>
<a name="ln1564">       * sub-expressions:</a>
<a name="ln1565">       * [0] entire match</a>
<a name="ln1566">       * [1] 1st marked subexpression</a>
<a name="ln1567">       * ...</a>
<a name="ln1568">       * [n] nth marked subexpression</a>
<a name="ln1569">       * [n+1] unmatched</a>
<a name="ln1570">       * [n+2] prefix</a>
<a name="ln1571">       * [n+3] suffix</a>
<a name="ln1572">       */</a>
<a name="ln1573">      typedef std::vector&lt;sub_match&lt;_Bi_iter&gt;, _Alloc&gt;     _Base_type;</a>
<a name="ln1574">      typedef std::iterator_traits&lt;_Bi_iter&gt;   	   	   __iter_traits;</a>
<a name="ln1575">      typedef regex_constants::match_flag_type		   match_flag_type;</a>
<a name="ln1576"> </a>
<a name="ln1577">    public:</a>
<a name="ln1578">      /**</a>
<a name="ln1579">       * @name 10.? Public Types</a>
<a name="ln1580">       */</a>
<a name="ln1581">      //@{</a>
<a name="ln1582">      typedef sub_match&lt;_Bi_iter&gt;			   value_type;</a>
<a name="ln1583">      typedef const value_type&amp;				   const_reference;</a>
<a name="ln1584">      typedef value_type&amp;				   reference;</a>
<a name="ln1585">      typedef typename _Base_type::const_iterator	   const_iterator;</a>
<a name="ln1586">      typedef const_iterator				   iterator;</a>
<a name="ln1587">      typedef typename __iter_traits::difference_type	   difference_type;</a>
<a name="ln1588">      typedef typename allocator_traits&lt;_Alloc&gt;::size_type size_type;</a>
<a name="ln1589">      typedef _Alloc					   allocator_type;</a>
<a name="ln1590">      typedef typename __iter_traits::value_type 	   char_type;</a>
<a name="ln1591">      typedef std::basic_string&lt;char_type&gt;		   string_type;</a>
<a name="ln1592">      //@}</a>
<a name="ln1593"> </a>
<a name="ln1594">    public:</a>
<a name="ln1595">      /**</a>
<a name="ln1596">       * @name 28.10.1 Construction, Copying, and Destruction</a>
<a name="ln1597">       */</a>
<a name="ln1598">      //@{</a>
<a name="ln1599"> </a>
<a name="ln1600">      /**</a>
<a name="ln1601">       * @brief Constructs a default %match_results container.</a>
<a name="ln1602">       * @post size() returns 0 and str() returns an empty string.</a>
<a name="ln1603">       */</a>
<a name="ln1604">      explicit</a>
<a name="ln1605">      match_results(const _Alloc&amp; __a = _Alloc())</a>
<a name="ln1606">      : _Base_type(__a)</a>
<a name="ln1607">      { }</a>
<a name="ln1608"> </a>
<a name="ln1609">      /**</a>
<a name="ln1610">       * @brief Copy constructs a %match_results.</a>
<a name="ln1611">       */</a>
<a name="ln1612">      match_results(const match_results&amp; __rhs) = default;</a>
<a name="ln1613"> </a>
<a name="ln1614">      /**</a>
<a name="ln1615">       * @brief Move constructs a %match_results.</a>
<a name="ln1616">       */</a>
<a name="ln1617">      match_results(match_results&amp;&amp; __rhs) noexcept = default;</a>
<a name="ln1618"> </a>
<a name="ln1619">      /**</a>
<a name="ln1620">       * @brief Assigns rhs to *this.</a>
<a name="ln1621">       */</a>
<a name="ln1622">      match_results&amp;</a>
<a name="ln1623">      operator=(const match_results&amp; __rhs) = default;</a>
<a name="ln1624"> </a>
<a name="ln1625">      /**</a>
<a name="ln1626">       * @brief Move-assigns rhs to *this.</a>
<a name="ln1627">       */</a>
<a name="ln1628">      match_results&amp;</a>
<a name="ln1629">      operator=(match_results&amp;&amp; __rhs) = default;</a>
<a name="ln1630"> </a>
<a name="ln1631">      /**</a>
<a name="ln1632">       * @brief Destroys a %match_results object.</a>
<a name="ln1633">       */</a>
<a name="ln1634">      ~match_results()</a>
<a name="ln1635">      { }</a>
<a name="ln1636"> </a>
<a name="ln1637">      //@}</a>
<a name="ln1638"> </a>
<a name="ln1639">      // 28.10.2, state:</a>
<a name="ln1640">      /**</a>
<a name="ln1641">       * @brief Indicates if the %match_results is ready.</a>
<a name="ln1642">       * @retval true   The object has a fully-established result state.</a>
<a name="ln1643">       * @retval false  The object is not ready.</a>
<a name="ln1644">       */</a>
<a name="ln1645">      bool ready() const { return !_Base_type::empty(); }</a>
<a name="ln1646"> </a>
<a name="ln1647">      /**</a>
<a name="ln1648">       * @name 28.10.2 Size</a>
<a name="ln1649">       */</a>
<a name="ln1650">      //@{</a>
<a name="ln1651"> </a>
<a name="ln1652">      /**</a>
<a name="ln1653">       * @brief Gets the number of matches and submatches.</a>
<a name="ln1654">       *</a>
<a name="ln1655">       * The number of matches for a given regular expression will be either 0</a>
<a name="ln1656">       * if there was no match or mark_count() + 1 if a match was successful.</a>
<a name="ln1657">       * Some matches may be empty.</a>
<a name="ln1658">       *</a>
<a name="ln1659">       * @returns the number of matches found.</a>
<a name="ln1660">       */</a>
<a name="ln1661">      size_type</a>
<a name="ln1662">      size() const</a>
<a name="ln1663">      { return _Base_type::empty() ? 0 : _Base_type::size() - 3; }</a>
<a name="ln1664"> </a>
<a name="ln1665">      size_type</a>
<a name="ln1666">      max_size() const</a>
<a name="ln1667">      { return _Base_type::max_size(); }</a>
<a name="ln1668"> </a>
<a name="ln1669">      /**</a>
<a name="ln1670">       * @brief Indicates if the %match_results contains no results.</a>
<a name="ln1671">       * @retval true The %match_results object is empty.</a>
<a name="ln1672">       * @retval false The %match_results object is not empty.</a>
<a name="ln1673">       */</a>
<a name="ln1674">      bool</a>
<a name="ln1675">      empty() const</a>
<a name="ln1676">      { return size() == 0; }</a>
<a name="ln1677"> </a>
<a name="ln1678">      //@}</a>
<a name="ln1679"> </a>
<a name="ln1680">      /**</a>
<a name="ln1681">       * @name 10.3 Element Access</a>
<a name="ln1682">       */</a>
<a name="ln1683">      //@{</a>
<a name="ln1684"> </a>
<a name="ln1685">      /**</a>
<a name="ln1686">       * @brief Gets the length of the indicated submatch.</a>
<a name="ln1687">       * @param __sub indicates the submatch.</a>
<a name="ln1688">       * @pre   ready() == true</a>
<a name="ln1689">       *</a>
<a name="ln1690">       * This function returns the length of the indicated submatch, or the</a>
<a name="ln1691">       * length of the entire match if @p __sub is zero (the default).</a>
<a name="ln1692">       */</a>
<a name="ln1693">      difference_type</a>
<a name="ln1694">      length(size_type __sub = 0) const</a>
<a name="ln1695">      { return (*this)[__sub].length(); }</a>
<a name="ln1696"> </a>
<a name="ln1697">      /**</a>
<a name="ln1698">       * @brief Gets the offset of the beginning of the indicated submatch.</a>
<a name="ln1699">       * @param __sub indicates the submatch.</a>
<a name="ln1700">       * @pre   ready() == true</a>
<a name="ln1701">       *</a>
<a name="ln1702">       * This function returns the offset from the beginning of the target</a>
<a name="ln1703">       * sequence to the beginning of the submatch, unless the value of @p __sub</a>
<a name="ln1704">       * is zero (the default), in which case this function returns the offset</a>
<a name="ln1705">       * from the beginning of the target sequence to the beginning of the</a>
<a name="ln1706">       * match.</a>
<a name="ln1707">       */</a>
<a name="ln1708">      difference_type</a>
<a name="ln1709">      position(size_type __sub = 0) const</a>
<a name="ln1710">      { return std::distance(_M_begin, (*this)[__sub].first); }</a>
<a name="ln1711"> </a>
<a name="ln1712">      /**</a>
<a name="ln1713">       * @brief Gets the match or submatch converted to a string type.</a>
<a name="ln1714">       * @param __sub indicates the submatch.</a>
<a name="ln1715">       * @pre   ready() == true</a>
<a name="ln1716">       *</a>
<a name="ln1717">       * This function gets the submatch (or match, if @p __sub is</a>
<a name="ln1718">       * zero) extracted from the target range and converted to the</a>
<a name="ln1719">       * associated string type.</a>
<a name="ln1720">       */</a>
<a name="ln1721">      string_type</a>
<a name="ln1722">      str(size_type __sub = 0) const</a>
<a name="ln1723">      { return string_type((*this)[__sub]); }</a>
<a name="ln1724"> </a>
<a name="ln1725">      /**</a>
<a name="ln1726">       * @brief Gets a %sub_match reference for the match or submatch.</a>
<a name="ln1727">       * @param __sub indicates the submatch.</a>
<a name="ln1728">       * @pre   ready() == true</a>
<a name="ln1729">       *</a>
<a name="ln1730">       * This function gets a reference to the indicated submatch, or</a>
<a name="ln1731">       * the entire match if @p __sub is zero.</a>
<a name="ln1732">       *</a>
<a name="ln1733">       * If @p __sub &gt;= size() then this function returns a %sub_match with a</a>
<a name="ln1734">       * special value indicating no submatch.</a>
<a name="ln1735">       */</a>
<a name="ln1736">      const_reference</a>
<a name="ln1737">      operator[](size_type __sub) const</a>
<a name="ln1738">      {</a>
<a name="ln1739">	__glibcxx_assert( ready() );</a>
<a name="ln1740">	return __sub &lt; size()</a>
<a name="ln1741">	       ? _Base_type::operator[](__sub)</a>
<a name="ln1742">	       : _M_unmatched_sub();</a>
<a name="ln1743">      }</a>
<a name="ln1744"> </a>
<a name="ln1745">      /**</a>
<a name="ln1746">       * @brief Gets a %sub_match representing the match prefix.</a>
<a name="ln1747">       * @pre   ready() == true</a>
<a name="ln1748">       *</a>
<a name="ln1749">       * This function gets a reference to a %sub_match object representing the</a>
<a name="ln1750">       * part of the target range between the start of the target range and the</a>
<a name="ln1751">       * start of the match.</a>
<a name="ln1752">       */</a>
<a name="ln1753">      const_reference</a>
<a name="ln1754">      prefix() const</a>
<a name="ln1755">      {</a>
<a name="ln1756">	__glibcxx_assert( ready() );</a>
<a name="ln1757">	return !empty() ? _M_prefix() : _M_unmatched_sub();</a>
<a name="ln1758">      }</a>
<a name="ln1759"> </a>
<a name="ln1760">      /**</a>
<a name="ln1761">       * @brief Gets a %sub_match representing the match suffix.</a>
<a name="ln1762">       * @pre   ready() == true</a>
<a name="ln1763">       *</a>
<a name="ln1764">       * This function gets a reference to a %sub_match object representing the</a>
<a name="ln1765">       * part of the target range between the end of the match and the end of</a>
<a name="ln1766">       * the target range.</a>
<a name="ln1767">       */</a>
<a name="ln1768">      const_reference</a>
<a name="ln1769">      suffix() const</a>
<a name="ln1770">      {</a>
<a name="ln1771">	__glibcxx_assert( ready() );</a>
<a name="ln1772">	return !empty() ? _M_suffix() : _M_unmatched_sub();</a>
<a name="ln1773">      }</a>
<a name="ln1774"> </a>
<a name="ln1775">      /**</a>
<a name="ln1776">       * @brief Gets an iterator to the start of the %sub_match collection.</a>
<a name="ln1777">       */</a>
<a name="ln1778">      const_iterator</a>
<a name="ln1779">      begin() const</a>
<a name="ln1780">      { return _Base_type::begin(); }</a>
<a name="ln1781"> </a>
<a name="ln1782">      /**</a>
<a name="ln1783">       * @brief Gets an iterator to the start of the %sub_match collection.</a>
<a name="ln1784">       */</a>
<a name="ln1785">      const_iterator</a>
<a name="ln1786">      cbegin() const</a>
<a name="ln1787">      { return this-&gt;begin(); }</a>
<a name="ln1788"> </a>
<a name="ln1789">      /**</a>
<a name="ln1790">       * @brief Gets an iterator to one-past-the-end of the collection.</a>
<a name="ln1791">       */</a>
<a name="ln1792">      const_iterator</a>
<a name="ln1793">      end() const</a>
<a name="ln1794">      { return _Base_type::end() - (empty() ? 0 : 3); }</a>
<a name="ln1795"> </a>
<a name="ln1796">      /**</a>
<a name="ln1797">       * @brief Gets an iterator to one-past-the-end of the collection.</a>
<a name="ln1798">       */</a>
<a name="ln1799">      const_iterator</a>
<a name="ln1800">      cend() const</a>
<a name="ln1801">      { return this-&gt;end(); }</a>
<a name="ln1802"> </a>
<a name="ln1803">      //@}</a>
<a name="ln1804"> </a>
<a name="ln1805">      /**</a>
<a name="ln1806">       * @name 10.4 Formatting</a>
<a name="ln1807">       *</a>
<a name="ln1808">       * These functions perform formatted substitution of the matched</a>
<a name="ln1809">       * character sequences into their target.  The format specifiers and</a>
<a name="ln1810">       * escape sequences accepted by these functions are determined by</a>
<a name="ln1811">       * their @p flags parameter as documented above.</a>
<a name="ln1812">       */</a>
<a name="ln1813">       //@{</a>
<a name="ln1814"> </a>
<a name="ln1815">      /**</a>
<a name="ln1816">       * @pre   ready() == true</a>
<a name="ln1817">       */</a>
<a name="ln1818">      template&lt;typename _Out_iter&gt;</a>
<a name="ln1819">	_Out_iter</a>
<a name="ln1820">	format(_Out_iter __out, const char_type* __fmt_first,</a>
<a name="ln1821">	       const char_type* __fmt_last,</a>
<a name="ln1822">	       match_flag_type __flags = regex_constants::format_default) const;</a>
<a name="ln1823"> </a>
<a name="ln1824">      /**</a>
<a name="ln1825">       * @pre   ready() == true</a>
<a name="ln1826">       */</a>
<a name="ln1827">      template&lt;typename _Out_iter, typename _St, typename _Sa&gt;</a>
<a name="ln1828">	_Out_iter</a>
<a name="ln1829">	format(_Out_iter __out, const basic_string&lt;char_type, _St, _Sa&gt;&amp; __fmt,</a>
<a name="ln1830">	       match_flag_type __flags = regex_constants::format_default) const</a>
<a name="ln1831">	{</a>
<a name="ln1832">	  return format(__out, __fmt.data(), __fmt.data() + __fmt.size(),</a>
<a name="ln1833">			__flags);</a>
<a name="ln1834">	}</a>
<a name="ln1835"> </a>
<a name="ln1836">      /**</a>
<a name="ln1837">       * @pre   ready() == true</a>
<a name="ln1838">       */</a>
<a name="ln1839">      template&lt;typename _St, typename _Sa&gt;</a>
<a name="ln1840">	basic_string&lt;char_type, _St, _Sa&gt;</a>
<a name="ln1841">	format(const basic_string&lt;char_type, _St, _Sa&gt;&amp; __fmt,</a>
<a name="ln1842">	       match_flag_type __flags = regex_constants::format_default) const</a>
<a name="ln1843">	{</a>
<a name="ln1844">	  basic_string&lt;char_type, _St, _Sa&gt; __result;</a>
<a name="ln1845">	  format(std::back_inserter(__result), __fmt, __flags);</a>
<a name="ln1846">	  return __result;</a>
<a name="ln1847">	}</a>
<a name="ln1848"> </a>
<a name="ln1849">      /**</a>
<a name="ln1850">       * @pre   ready() == true</a>
<a name="ln1851">       */</a>
<a name="ln1852">      string_type</a>
<a name="ln1853">      format(const char_type* __fmt,</a>
<a name="ln1854">	     match_flag_type __flags = regex_constants::format_default) const</a>
<a name="ln1855">      {</a>
<a name="ln1856">	string_type __result;</a>
<a name="ln1857">	format(std::back_inserter(__result),</a>
<a name="ln1858">	       __fmt,</a>
<a name="ln1859">	       __fmt + char_traits&lt;char_type&gt;::length(__fmt),</a>
<a name="ln1860">	       __flags);</a>
<a name="ln1861">	return __result;</a>
<a name="ln1862">      }</a>
<a name="ln1863"> </a>
<a name="ln1864">      //@}</a>
<a name="ln1865"> </a>
<a name="ln1866">      /**</a>
<a name="ln1867">       * @name 10.5 Allocator</a>
<a name="ln1868">       */</a>
<a name="ln1869">      //@{</a>
<a name="ln1870"> </a>
<a name="ln1871">      /**</a>
<a name="ln1872">       * @brief Gets a copy of the allocator.</a>
<a name="ln1873">       */</a>
<a name="ln1874">      allocator_type</a>
<a name="ln1875">      get_allocator() const</a>
<a name="ln1876">      { return _Base_type::get_allocator(); }</a>
<a name="ln1877"> </a>
<a name="ln1878">      //@}</a>
<a name="ln1879"> </a>
<a name="ln1880">      /**</a>
<a name="ln1881">       * @name 10.6 Swap</a>
<a name="ln1882">       */</a>
<a name="ln1883">       //@{</a>
<a name="ln1884"> </a>
<a name="ln1885">      /**</a>
<a name="ln1886">       * @brief Swaps the contents of two match_results.</a>
<a name="ln1887">       */</a>
<a name="ln1888">      void</a>
<a name="ln1889">      swap(match_results&amp; __that)</a>
<a name="ln1890">      {</a>
<a name="ln1891">	using std::swap;</a>
<a name="ln1892">	_Base_type::swap(__that);</a>
<a name="ln1893">	swap(_M_begin, __that._M_begin);</a>
<a name="ln1894">      }</a>
<a name="ln1895">      //@}</a>
<a name="ln1896"> </a>
<a name="ln1897">    private:</a>
<a name="ln1898">      template&lt;typename, typename, typename, bool&gt;</a>
<a name="ln1899">	friend class __detail::_Executor;</a>
<a name="ln1900"> </a>
<a name="ln1901">      template&lt;typename, typename, typename&gt;</a>
<a name="ln1902">	friend class regex_iterator;</a>
<a name="ln1903"> </a>
<a name="ln1904">      template&lt;typename _Bp, typename _Ap, typename _Cp, typename _Rp,</a>
<a name="ln1905">	__detail::_RegexExecutorPolicy, bool&gt;</a>
<a name="ln1906">	friend bool</a>
<a name="ln1907">	__detail::__regex_algo_impl(_Bp, _Bp, match_results&lt;_Bp, _Ap&gt;&amp;,</a>
<a name="ln1908">				    const basic_regex&lt;_Cp, _Rp&gt;&amp;,</a>
<a name="ln1909">				    regex_constants::match_flag_type);</a>
<a name="ln1910"> </a>
<a name="ln1911">      void</a>
<a name="ln1912">      _M_resize(unsigned int __size)</a>
<a name="ln1913">      { _Base_type::resize(__size + 3); }</a>
<a name="ln1914"> </a>
<a name="ln1915">      const_reference</a>
<a name="ln1916">      _M_unmatched_sub() const</a>
<a name="ln1917">      { return _Base_type::operator[](_Base_type::size() - 3); }</a>
<a name="ln1918"> </a>
<a name="ln1919">      sub_match&lt;_Bi_iter&gt;&amp;</a>
<a name="ln1920">      _M_unmatched_sub()</a>
<a name="ln1921">      { return _Base_type::operator[](_Base_type::size() - 3); }</a>
<a name="ln1922"> </a>
<a name="ln1923">      const_reference</a>
<a name="ln1924">      _M_prefix() const</a>
<a name="ln1925">      { return _Base_type::operator[](_Base_type::size() - 2); }</a>
<a name="ln1926"> </a>
<a name="ln1927">      sub_match&lt;_Bi_iter&gt;&amp;</a>
<a name="ln1928">      _M_prefix()</a>
<a name="ln1929">      { return _Base_type::operator[](_Base_type::size() - 2); }</a>
<a name="ln1930"> </a>
<a name="ln1931">      const_reference</a>
<a name="ln1932">      _M_suffix() const</a>
<a name="ln1933">      { return _Base_type::operator[](_Base_type::size() - 1); }</a>
<a name="ln1934"> </a>
<a name="ln1935">      sub_match&lt;_Bi_iter&gt;&amp;</a>
<a name="ln1936">      _M_suffix()</a>
<a name="ln1937">      { return _Base_type::operator[](_Base_type::size() - 1); }</a>
<a name="ln1938"> </a>
<a name="ln1939">      _Bi_iter _M_begin;</a>
<a name="ln1940">    };</a>
<a name="ln1941"> </a>
<a name="ln1942">  typedef match_results&lt;const char*&gt;		 cmatch;</a>
<a name="ln1943">  typedef match_results&lt;string::const_iterator&gt;	 smatch;</a>
<a name="ln1944">#ifdef _GLIBCXX_USE_WCHAR_T</a>
<a name="ln1945">  typedef match_results&lt;const wchar_t*&gt;		 wcmatch;</a>
<a name="ln1946">  typedef match_results&lt;wstring::const_iterator&gt; wsmatch;</a>
<a name="ln1947">#endif</a>
<a name="ln1948"> </a>
<a name="ln1949">  // match_results comparisons</a>
<a name="ln1950">  /**</a>
<a name="ln1951">   * @brief Compares two match_results for equality.</a>
<a name="ln1952">   * @returns true if the two objects refer to the same match,</a>
<a name="ln1953">   * false otherwise.</a>
<a name="ln1954">   */</a>
<a name="ln1955">  template&lt;typename _Bi_iter, typename _Alloc&gt;</a>
<a name="ln1956">    inline bool</a>
<a name="ln1957">    operator==(const match_results&lt;_Bi_iter, _Alloc&gt;&amp; __m1,</a>
<a name="ln1958">	       const match_results&lt;_Bi_iter, _Alloc&gt;&amp; __m2)</a>
<a name="ln1959">    {</a>
<a name="ln1960">      if (__m1.ready() != __m2.ready())</a>
<a name="ln1961">	return false;</a>
<a name="ln1962">      if (!__m1.ready())  // both are not ready</a>
<a name="ln1963">	return true;</a>
<a name="ln1964">      if (__m1.empty() != __m2.empty())</a>
<a name="ln1965">	return false;</a>
<a name="ln1966">      if (__m1.empty())   // both are empty</a>
<a name="ln1967">	return true;</a>
<a name="ln1968">      return __m1.prefix() == __m2.prefix()</a>
<a name="ln1969">	&amp;&amp; __m1.size() == __m2.size()</a>
<a name="ln1970">	&amp;&amp; std::equal(__m1.begin(), __m1.end(), __m2.begin())</a>
<a name="ln1971">	&amp;&amp; __m1.suffix() == __m2.suffix();</a>
<a name="ln1972">    }</a>
<a name="ln1973"> </a>
<a name="ln1974">  /**</a>
<a name="ln1975">   * @brief Compares two match_results for inequality.</a>
<a name="ln1976">   * @returns true if the two objects do not refer to the same match,</a>
<a name="ln1977">   * false otherwise.</a>
<a name="ln1978">   */</a>
<a name="ln1979">  template&lt;typename _Bi_iter, class _Alloc&gt;</a>
<a name="ln1980">    inline bool</a>
<a name="ln1981">    operator!=(const match_results&lt;_Bi_iter, _Alloc&gt;&amp; __m1,</a>
<a name="ln1982">	       const match_results&lt;_Bi_iter, _Alloc&gt;&amp; __m2)</a>
<a name="ln1983">    { return !(__m1 == __m2); }</a>
<a name="ln1984"> </a>
<a name="ln1985">  // [7.10.6] match_results swap</a>
<a name="ln1986">  /**</a>
<a name="ln1987">   * @brief Swaps two match results.</a>
<a name="ln1988">   * @param __lhs A match result.</a>
<a name="ln1989">   * @param __rhs A match result.</a>
<a name="ln1990">   *</a>
<a name="ln1991">   * The contents of the two match_results objects are swapped.</a>
<a name="ln1992">   */</a>
<a name="ln1993">  template&lt;typename _Bi_iter, typename _Alloc&gt;</a>
<a name="ln1994">    inline void</a>
<a name="ln1995">    swap(match_results&lt;_Bi_iter, _Alloc&gt;&amp; __lhs,</a>
<a name="ln1996">	 match_results&lt;_Bi_iter, _Alloc&gt;&amp; __rhs)</a>
<a name="ln1997">    { __lhs.swap(__rhs); }</a>
<a name="ln1998"> </a>
<a name="ln1999">_GLIBCXX_END_NAMESPACE_CXX11</a>
<a name="ln2000"> </a>
<a name="ln2001">  // [7.11.2] Function template regex_match</a>
<a name="ln2002">  /**</a>
<a name="ln2003">   * @name Matching, Searching, and Replacing</a>
<a name="ln2004">   */</a>
<a name="ln2005">  //@{</a>
<a name="ln2006"> </a>
<a name="ln2007">  /**</a>
<a name="ln2008">   * @brief Determines if there is a match between the regular expression @p e</a>
<a name="ln2009">   * and all of the character sequence [first, last).</a>
<a name="ln2010">   *</a>
<a name="ln2011">   * @param __s     Start of the character sequence to match.</a>
<a name="ln2012">   * @param __e     One-past-the-end of the character sequence to match.</a>
<a name="ln2013">   * @param __m     The match results.</a>
<a name="ln2014">   * @param __re    The regular expression.</a>
<a name="ln2015">   * @param __flags Controls how the regular expression is matched.</a>
<a name="ln2016">   *</a>
<a name="ln2017">   * @retval true  A match exists.</a>
<a name="ln2018">   * @retval false Otherwise.</a>
<a name="ln2019">   *</a>
<a name="ln2020">   * @throws an exception of type regex_error.</a>
<a name="ln2021">   */</a>
<a name="ln2022">  template&lt;typename _Bi_iter, typename _Alloc,</a>
<a name="ln2023">	   typename _Ch_type, typename _Rx_traits&gt;</a>
<a name="ln2024">    inline bool</a>
<a name="ln2025">    regex_match(_Bi_iter				 __s,</a>
<a name="ln2026">		_Bi_iter				 __e,</a>
<a name="ln2027">		match_results&lt;_Bi_iter, _Alloc&gt;&amp;	 __m,</a>
<a name="ln2028">		const basic_regex&lt;_Ch_type, _Rx_traits&gt;&amp; __re,</a>
<a name="ln2029">		regex_constants::match_flag_type	 __flags</a>
<a name="ln2030">			       = regex_constants::match_default)</a>
<a name="ln2031">    {</a>
<a name="ln2032">      return __detail::__regex_algo_impl&lt;_Bi_iter, _Alloc, _Ch_type, _Rx_traits,</a>
<a name="ln2033">	__detail::_RegexExecutorPolicy::_S_auto, true&gt;</a>
<a name="ln2034">	  (__s, __e, __m, __re, __flags);</a>
<a name="ln2035">    }</a>
<a name="ln2036"> </a>
<a name="ln2037">  /**</a>
<a name="ln2038">   * @brief Indicates if there is a match between the regular expression @p e</a>
<a name="ln2039">   * and all of the character sequence [first, last).</a>
<a name="ln2040">   *</a>
<a name="ln2041">   * @param __first Beginning of the character sequence to match.</a>
<a name="ln2042">   * @param __last  One-past-the-end of the character sequence to match.</a>
<a name="ln2043">   * @param __re    The regular expression.</a>
<a name="ln2044">   * @param __flags Controls how the regular expression is matched.</a>
<a name="ln2045">   *</a>
<a name="ln2046">   * @retval true  A match exists.</a>
<a name="ln2047">   * @retval false Otherwise.</a>
<a name="ln2048">   *</a>
<a name="ln2049">   * @throws an exception of type regex_error.</a>
<a name="ln2050">   */</a>
<a name="ln2051">  template&lt;typename _Bi_iter, typename _Ch_type, typename _Rx_traits&gt;</a>
<a name="ln2052">    inline bool</a>
<a name="ln2053">    regex_match(_Bi_iter __first, _Bi_iter __last,</a>
<a name="ln2054">		const basic_regex&lt;_Ch_type, _Rx_traits&gt;&amp; __re,</a>
<a name="ln2055">		regex_constants::match_flag_type __flags</a>
<a name="ln2056">		= regex_constants::match_default)</a>
<a name="ln2057">    {</a>
<a name="ln2058">      match_results&lt;_Bi_iter&gt; __what;</a>
<a name="ln2059">      return regex_match(__first, __last, __what, __re, __flags);</a>
<a name="ln2060">    }</a>
<a name="ln2061"> </a>
<a name="ln2062">  /**</a>
<a name="ln2063">   * @brief Determines if there is a match between the regular expression @p e</a>
<a name="ln2064">   * and a C-style null-terminated string.</a>
<a name="ln2065">   *</a>
<a name="ln2066">   * @param __s  The C-style null-terminated string to match.</a>
<a name="ln2067">   * @param __m  The match results.</a>
<a name="ln2068">   * @param __re The regular expression.</a>
<a name="ln2069">   * @param __f  Controls how the regular expression is matched.</a>
<a name="ln2070">   *</a>
<a name="ln2071">   * @retval true  A match exists.</a>
<a name="ln2072">   * @retval false Otherwise.</a>
<a name="ln2073">   *</a>
<a name="ln2074">   * @throws an exception of type regex_error.</a>
<a name="ln2075">   */</a>
<a name="ln2076">  template&lt;typename _Ch_type, typename _Alloc, typename _Rx_traits&gt;</a>
<a name="ln2077">    inline bool</a>
<a name="ln2078">    regex_match(const _Ch_type* __s,</a>
<a name="ln2079">		match_results&lt;const _Ch_type*, _Alloc&gt;&amp; __m,</a>
<a name="ln2080">		const basic_regex&lt;_Ch_type, _Rx_traits&gt;&amp; __re,</a>
<a name="ln2081">		regex_constants::match_flag_type __f</a>
<a name="ln2082">		= regex_constants::match_default)</a>
<a name="ln2083">    { return regex_match(__s, __s + _Rx_traits::length(__s), __m, __re, __f); }</a>
<a name="ln2084"> </a>
<a name="ln2085">  /**</a>
<a name="ln2086">   * @brief Determines if there is a match between the regular expression @p e</a>
<a name="ln2087">   * and a string.</a>
<a name="ln2088">   *</a>
<a name="ln2089">   * @param __s     The string to match.</a>
<a name="ln2090">   * @param __m     The match results.</a>
<a name="ln2091">   * @param __re    The regular expression.</a>
<a name="ln2092">   * @param __flags Controls how the regular expression is matched.</a>
<a name="ln2093">   *</a>
<a name="ln2094">   * @retval true  A match exists.</a>
<a name="ln2095">   * @retval false Otherwise.</a>
<a name="ln2096">   *</a>
<a name="ln2097">   * @throws an exception of type regex_error.</a>
<a name="ln2098">   */</a>
<a name="ln2099">  template&lt;typename _Ch_traits, typename _Ch_alloc,</a>
<a name="ln2100">	   typename _Alloc, typename _Ch_type, typename _Rx_traits&gt;</a>
<a name="ln2101">    inline bool</a>
<a name="ln2102">    regex_match(const basic_string&lt;_Ch_type, _Ch_traits, _Ch_alloc&gt;&amp; __s,</a>
<a name="ln2103">		match_results&lt;typename basic_string&lt;_Ch_type,</a>
<a name="ln2104">		_Ch_traits, _Ch_alloc&gt;::const_iterator, _Alloc&gt;&amp; __m,</a>
<a name="ln2105">		const basic_regex&lt;_Ch_type, _Rx_traits&gt;&amp; __re,</a>
<a name="ln2106">		regex_constants::match_flag_type __flags</a>
<a name="ln2107">		= regex_constants::match_default)</a>
<a name="ln2108">    { return regex_match(__s.begin(), __s.end(), __m, __re, __flags); }</a>
<a name="ln2109"> </a>
<a name="ln2110">  // _GLIBCXX_RESOLVE_LIB_DEFECTS</a>
<a name="ln2111">  // 2329. regex_match() with match_results should forbid temporary strings</a>
<a name="ln2112">  /// Prevent unsafe attempts to get match_results from a temporary string.</a>
<a name="ln2113">  template&lt;typename _Ch_traits, typename _Ch_alloc,</a>
<a name="ln2114">	   typename _Alloc, typename _Ch_type, typename _Rx_traits&gt;</a>
<a name="ln2115">    bool</a>
<a name="ln2116">    regex_match(const basic_string&lt;_Ch_type, _Ch_traits, _Ch_alloc&gt;&amp;&amp;,</a>
<a name="ln2117">		match_results&lt;typename basic_string&lt;_Ch_type,</a>
<a name="ln2118">		_Ch_traits, _Ch_alloc&gt;::const_iterator, _Alloc&gt;&amp;,</a>
<a name="ln2119">		const basic_regex&lt;_Ch_type, _Rx_traits&gt;&amp;,</a>
<a name="ln2120">		regex_constants::match_flag_type</a>
<a name="ln2121">		= regex_constants::match_default) = delete;</a>
<a name="ln2122"> </a>
<a name="ln2123">  /**</a>
<a name="ln2124">   * @brief Indicates if there is a match between the regular expression @p e</a>
<a name="ln2125">   * and a C-style null-terminated string.</a>
<a name="ln2126">   *</a>
<a name="ln2127">   * @param __s  The C-style null-terminated string to match.</a>
<a name="ln2128">   * @param __re The regular expression.</a>
<a name="ln2129">   * @param __f  Controls how the regular expression is matched.</a>
<a name="ln2130">   *</a>
<a name="ln2131">   * @retval true  A match exists.</a>
<a name="ln2132">   * @retval false Otherwise.</a>
<a name="ln2133">   *</a>
<a name="ln2134">   * @throws an exception of type regex_error.</a>
<a name="ln2135">   */</a>
<a name="ln2136">  template&lt;typename _Ch_type, class _Rx_traits&gt;</a>
<a name="ln2137">    inline bool</a>
<a name="ln2138">    regex_match(const _Ch_type* __s,</a>
<a name="ln2139">		const basic_regex&lt;_Ch_type, _Rx_traits&gt;&amp; __re,</a>
<a name="ln2140">		regex_constants::match_flag_type __f</a>
<a name="ln2141">		= regex_constants::match_default)</a>
<a name="ln2142">    { return regex_match(__s, __s + _Rx_traits::length(__s), __re, __f); }</a>
<a name="ln2143"> </a>
<a name="ln2144">  /**</a>
<a name="ln2145">   * @brief Indicates if there is a match between the regular expression @p e</a>
<a name="ln2146">   * and a string.</a>
<a name="ln2147">   *</a>
<a name="ln2148">   * @param __s     [IN] The string to match.</a>
<a name="ln2149">   * @param __re    [IN] The regular expression.</a>
<a name="ln2150">   * @param __flags [IN] Controls how the regular expression is matched.</a>
<a name="ln2151">   *</a>
<a name="ln2152">   * @retval true  A match exists.</a>
<a name="ln2153">   * @retval false Otherwise.</a>
<a name="ln2154">   *</a>
<a name="ln2155">   * @throws an exception of type regex_error.</a>
<a name="ln2156">   */</a>
<a name="ln2157">  template&lt;typename _Ch_traits, typename _Str_allocator,</a>
<a name="ln2158">	   typename _Ch_type, typename _Rx_traits&gt;</a>
<a name="ln2159">    inline bool</a>
<a name="ln2160">    regex_match(const basic_string&lt;_Ch_type, _Ch_traits, _Str_allocator&gt;&amp; __s,</a>
<a name="ln2161">		const basic_regex&lt;_Ch_type, _Rx_traits&gt;&amp; __re,</a>
<a name="ln2162">		regex_constants::match_flag_type __flags</a>
<a name="ln2163">		= regex_constants::match_default)</a>
<a name="ln2164">    { return regex_match(__s.begin(), __s.end(), __re, __flags); }</a>
<a name="ln2165"> </a>
<a name="ln2166">  // [7.11.3] Function template regex_search</a>
<a name="ln2167">  /**</a>
<a name="ln2168">   * Searches for a regular expression within a range.</a>
<a name="ln2169">   * @param __s     [IN]  The start of the string to search.</a>
<a name="ln2170">   * @param __e     [IN]  One-past-the-end of the string to search.</a>
<a name="ln2171">   * @param __m     [OUT] The match results.</a>
<a name="ln2172">   * @param __re    [IN]  The regular expression to search for.</a>
<a name="ln2173">   * @param __flags [IN]  Search policy flags.</a>
<a name="ln2174">   * @retval true  A match was found within the string.</a>
<a name="ln2175">   * @retval false No match was found within the string, the content of %m is</a>
<a name="ln2176">   *               undefined.</a>
<a name="ln2177">   *</a>
<a name="ln2178">   * @throws an exception of type regex_error.</a>
<a name="ln2179">   */</a>
<a name="ln2180">  template&lt;typename _Bi_iter, typename _Alloc,</a>
<a name="ln2181">	   typename _Ch_type, typename _Rx_traits&gt;</a>
<a name="ln2182">    inline bool</a>
<a name="ln2183">    regex_search(_Bi_iter __s, _Bi_iter __e,</a>
<a name="ln2184">		 match_results&lt;_Bi_iter, _Alloc&gt;&amp; __m,</a>
<a name="ln2185">		 const basic_regex&lt;_Ch_type, _Rx_traits&gt;&amp; __re,</a>
<a name="ln2186">		 regex_constants::match_flag_type __flags</a>
<a name="ln2187">		 = regex_constants::match_default)</a>
<a name="ln2188">    {</a>
<a name="ln2189">      return __detail::__regex_algo_impl&lt;_Bi_iter, _Alloc, _Ch_type, _Rx_traits,</a>
<a name="ln2190">	__detail::_RegexExecutorPolicy::_S_auto, false&gt;</a>
<a name="ln2191">	  (__s, __e, __m, __re, __flags);</a>
<a name="ln2192">    }</a>
<a name="ln2193"> </a>
<a name="ln2194">  /**</a>
<a name="ln2195">   * Searches for a regular expression within a range.</a>
<a name="ln2196">   * @param __first [IN]  The start of the string to search.</a>
<a name="ln2197">   * @param __last  [IN]  One-past-the-end of the string to search.</a>
<a name="ln2198">   * @param __re    [IN]  The regular expression to search for.</a>
<a name="ln2199">   * @param __flags [IN]  Search policy flags.</a>
<a name="ln2200">   * @retval true  A match was found within the string.</a>
<a name="ln2201">   * @retval false No match was found within the string.</a>
<a name="ln2202">   *</a>
<a name="ln2203">   * @throws an exception of type regex_error.</a>
<a name="ln2204">   */</a>
<a name="ln2205">  template&lt;typename _Bi_iter, typename _Ch_type, typename _Rx_traits&gt;</a>
<a name="ln2206">    inline bool</a>
<a name="ln2207">    regex_search(_Bi_iter __first, _Bi_iter __last,</a>
<a name="ln2208">		 const basic_regex&lt;_Ch_type, _Rx_traits&gt;&amp; __re,</a>
<a name="ln2209">		 regex_constants::match_flag_type __flags</a>
<a name="ln2210">		 = regex_constants::match_default)</a>
<a name="ln2211">    {</a>
<a name="ln2212">      match_results&lt;_Bi_iter&gt; __what;</a>
<a name="ln2213">      return regex_search(__first, __last, __what, __re, __flags);</a>
<a name="ln2214">    }</a>
<a name="ln2215"> </a>
<a name="ln2216">  /**</a>
<a name="ln2217">   * @brief Searches for a regular expression within a C-string.</a>
<a name="ln2218">   * @param __s [IN]  A C-string to search for the regex.</a>
<a name="ln2219">   * @param __m [OUT] The set of regex matches.</a>
<a name="ln2220">   * @param __e [IN]  The regex to search for in @p s.</a>
<a name="ln2221">   * @param __f [IN]  The search flags.</a>
<a name="ln2222">   * @retval true  A match was found within the string.</a>
<a name="ln2223">   * @retval false No match was found within the string, the content of %m is</a>
<a name="ln2224">   *               undefined.</a>
<a name="ln2225">   *</a>
<a name="ln2226">   * @throws an exception of type regex_error.</a>
<a name="ln2227">   */</a>
<a name="ln2228">  template&lt;typename _Ch_type, class _Alloc, class _Rx_traits&gt;</a>
<a name="ln2229">    inline bool</a>
<a name="ln2230">    regex_search(const _Ch_type* __s,</a>
<a name="ln2231">		 match_results&lt;const _Ch_type*, _Alloc&gt;&amp; __m,</a>
<a name="ln2232">		 const basic_regex&lt;_Ch_type, _Rx_traits&gt;&amp; __e,</a>
<a name="ln2233">		 regex_constants::match_flag_type __f</a>
<a name="ln2234">		 = regex_constants::match_default)</a>
<a name="ln2235">    { return regex_search(__s, __s + _Rx_traits::length(__s), __m, __e, __f); }</a>
<a name="ln2236"> </a>
<a name="ln2237">  /**</a>
<a name="ln2238">   * @brief Searches for a regular expression within a C-string.</a>
<a name="ln2239">   * @param __s [IN]  The C-string to search.</a>
<a name="ln2240">   * @param __e [IN]  The regular expression to search for.</a>
<a name="ln2241">   * @param __f [IN]  Search policy flags.</a>
<a name="ln2242">   * @retval true  A match was found within the string.</a>
<a name="ln2243">   * @retval false No match was found within the string.</a>
<a name="ln2244">   *</a>
<a name="ln2245">   * @throws an exception of type regex_error.</a>
<a name="ln2246">   */</a>
<a name="ln2247">  template&lt;typename _Ch_type, typename _Rx_traits&gt;</a>
<a name="ln2248">    inline bool</a>
<a name="ln2249">    regex_search(const _Ch_type* __s,</a>
<a name="ln2250">		 const basic_regex&lt;_Ch_type, _Rx_traits&gt;&amp; __e,</a>
<a name="ln2251">		 regex_constants::match_flag_type __f</a>
<a name="ln2252">		 = regex_constants::match_default)</a>
<a name="ln2253">    { return regex_search(__s, __s + _Rx_traits::length(__s), __e, __f); }</a>
<a name="ln2254"> </a>
<a name="ln2255">  /**</a>
<a name="ln2256">   * @brief Searches for a regular expression within a string.</a>
<a name="ln2257">   * @param __s     [IN]  The string to search.</a>
<a name="ln2258">   * @param __e     [IN]  The regular expression to search for.</a>
<a name="ln2259">   * @param __flags [IN]  Search policy flags.</a>
<a name="ln2260">   * @retval true  A match was found within the string.</a>
<a name="ln2261">   * @retval false No match was found within the string.</a>
<a name="ln2262">   *</a>
<a name="ln2263">   * @throws an exception of type regex_error.</a>
<a name="ln2264">   */</a>
<a name="ln2265">  template&lt;typename _Ch_traits, typename _String_allocator,</a>
<a name="ln2266">	   typename _Ch_type, typename _Rx_traits&gt;</a>
<a name="ln2267">    inline bool</a>
<a name="ln2268">    regex_search(const basic_string&lt;_Ch_type, _Ch_traits,</a>
<a name="ln2269">		 _String_allocator&gt;&amp; __s,</a>
<a name="ln2270">		 const basic_regex&lt;_Ch_type, _Rx_traits&gt;&amp; __e,</a>
<a name="ln2271">		 regex_constants::match_flag_type __flags</a>
<a name="ln2272">		 = regex_constants::match_default)</a>
<a name="ln2273">    { return regex_search(__s.begin(), __s.end(), __e, __flags); }</a>
<a name="ln2274"> </a>
<a name="ln2275">  /**</a>
<a name="ln2276">   * @brief Searches for a regular expression within a string.</a>
<a name="ln2277">   * @param __s [IN]  A C++ string to search for the regex.</a>
<a name="ln2278">   * @param __m [OUT] The set of regex matches.</a>
<a name="ln2279">   * @param __e [IN]  The regex to search for in @p s.</a>
<a name="ln2280">   * @param __f [IN]  The search flags.</a>
<a name="ln2281">   * @retval true  A match was found within the string.</a>
<a name="ln2282">   * @retval false No match was found within the string, the content of %m is</a>
<a name="ln2283">   *               undefined.</a>
<a name="ln2284">   *</a>
<a name="ln2285">   * @throws an exception of type regex_error.</a>
<a name="ln2286">   */</a>
<a name="ln2287">  template&lt;typename _Ch_traits, typename _Ch_alloc,</a>
<a name="ln2288">	   typename _Alloc, typename _Ch_type,</a>
<a name="ln2289">	   typename _Rx_traits&gt;</a>
<a name="ln2290">    inline bool</a>
<a name="ln2291">    regex_search(const basic_string&lt;_Ch_type, _Ch_traits, _Ch_alloc&gt;&amp; __s,</a>
<a name="ln2292">		 match_results&lt;typename basic_string&lt;_Ch_type,</a>
<a name="ln2293">		 _Ch_traits, _Ch_alloc&gt;::const_iterator, _Alloc&gt;&amp; __m,</a>
<a name="ln2294">		 const basic_regex&lt;_Ch_type, _Rx_traits&gt;&amp; __e,</a>
<a name="ln2295">		 regex_constants::match_flag_type __f</a>
<a name="ln2296">		 = regex_constants::match_default)</a>
<a name="ln2297">    { return regex_search(__s.begin(), __s.end(), __m, __e, __f); }</a>
<a name="ln2298"> </a>
<a name="ln2299">  // _GLIBCXX_RESOLVE_LIB_DEFECTS</a>
<a name="ln2300">  // 2329. regex_search() with match_results should forbid temporary strings</a>
<a name="ln2301">  /// Prevent unsafe attempts to get match_results from a temporary string.</a>
<a name="ln2302">  template&lt;typename _Ch_traits, typename _Ch_alloc,</a>
<a name="ln2303">	   typename _Alloc, typename _Ch_type,</a>
<a name="ln2304">	   typename _Rx_traits&gt;</a>
<a name="ln2305">    bool</a>
<a name="ln2306">    regex_search(const basic_string&lt;_Ch_type, _Ch_traits, _Ch_alloc&gt;&amp;&amp;,</a>
<a name="ln2307">		 match_results&lt;typename basic_string&lt;_Ch_type,</a>
<a name="ln2308">		 _Ch_traits, _Ch_alloc&gt;::const_iterator, _Alloc&gt;&amp;,</a>
<a name="ln2309">		 const basic_regex&lt;_Ch_type, _Rx_traits&gt;&amp;,</a>
<a name="ln2310">		 regex_constants::match_flag_type</a>
<a name="ln2311">		 = regex_constants::match_default) = delete;</a>
<a name="ln2312"> </a>
<a name="ln2313">  // std [28.11.4] Function template regex_replace</a>
<a name="ln2314">  /**</a>
<a name="ln2315">   * @brief Search for a regular expression within a range for multiple times,</a>
<a name="ln2316">   and replace the matched parts through filling a format string.</a>
<a name="ln2317">   * @param __out   [OUT] The output iterator.</a>
<a name="ln2318">   * @param __first [IN]  The start of the string to search.</a>
<a name="ln2319">   * @param __last  [IN]  One-past-the-end of the string to search.</a>
<a name="ln2320">   * @param __e     [IN]  The regular expression to search for.</a>
<a name="ln2321">   * @param __fmt   [IN]  The format string.</a>
<a name="ln2322">   * @param __flags [IN]  Search and replace policy flags.</a>
<a name="ln2323">   *</a>
<a name="ln2324">   * @returns __out</a>
<a name="ln2325">   * @throws an exception of type regex_error.</a>
<a name="ln2326">   */</a>
<a name="ln2327">  template&lt;typename _Out_iter, typename _Bi_iter,</a>
<a name="ln2328">	   typename _Rx_traits, typename _Ch_type,</a>
<a name="ln2329">	   typename _St, typename _Sa&gt;</a>
<a name="ln2330">    inline _Out_iter</a>
<a name="ln2331">    regex_replace(_Out_iter __out, _Bi_iter __first, _Bi_iter __last,</a>
<a name="ln2332">		  const basic_regex&lt;_Ch_type, _Rx_traits&gt;&amp; __e,</a>
<a name="ln2333">		  const basic_string&lt;_Ch_type, _St, _Sa&gt;&amp; __fmt,</a>
<a name="ln2334">		  regex_constants::match_flag_type __flags</a>
<a name="ln2335">		  = regex_constants::match_default)</a>
<a name="ln2336">    {</a>
<a name="ln2337">      return regex_replace(__out, __first, __last, __e, __fmt.c_str(), __flags);</a>
<a name="ln2338">    }</a>
<a name="ln2339"> </a>
<a name="ln2340">  /**</a>
<a name="ln2341">   * @brief Search for a regular expression within a range for multiple times,</a>
<a name="ln2342">   and replace the matched parts through filling a format C-string.</a>
<a name="ln2343">   * @param __out   [OUT] The output iterator.</a>
<a name="ln2344">   * @param __first [IN]  The start of the string to search.</a>
<a name="ln2345">   * @param __last  [IN]  One-past-the-end of the string to search.</a>
<a name="ln2346">   * @param __e     [IN]  The regular expression to search for.</a>
<a name="ln2347">   * @param __fmt   [IN]  The format C-string.</a>
<a name="ln2348">   * @param __flags [IN]  Search and replace policy flags.</a>
<a name="ln2349">   *</a>
<a name="ln2350">   * @returns __out</a>
<a name="ln2351">   * @throws an exception of type regex_error.</a>
<a name="ln2352">   */</a>
<a name="ln2353">  template&lt;typename _Out_iter, typename _Bi_iter,</a>
<a name="ln2354">	   typename _Rx_traits, typename _Ch_type&gt;</a>
<a name="ln2355">    _Out_iter</a>
<a name="ln2356">    regex_replace(_Out_iter __out, _Bi_iter __first, _Bi_iter __last,</a>
<a name="ln2357">		  const basic_regex&lt;_Ch_type, _Rx_traits&gt;&amp; __e,</a>
<a name="ln2358">		  const _Ch_type* __fmt,</a>
<a name="ln2359">		  regex_constants::match_flag_type __flags</a>
<a name="ln2360">		  = regex_constants::match_default);</a>
<a name="ln2361"> </a>
<a name="ln2362">  /**</a>
<a name="ln2363">   * @brief Search for a regular expression within a string for multiple times,</a>
<a name="ln2364">   and replace the matched parts through filling a format string.</a>
<a name="ln2365">   * @param __s     [IN] The string to search and replace.</a>
<a name="ln2366">   * @param __e     [IN] The regular expression to search for.</a>
<a name="ln2367">   * @param __fmt   [IN] The format string.</a>
<a name="ln2368">   * @param __flags [IN] Search and replace policy flags.</a>
<a name="ln2369">   *</a>
<a name="ln2370">   * @returns The string after replacing.</a>
<a name="ln2371">   * @throws an exception of type regex_error.</a>
<a name="ln2372">   */</a>
<a name="ln2373">  template&lt;typename _Rx_traits, typename _Ch_type,</a>
<a name="ln2374">	   typename _St, typename _Sa, typename _Fst, typename _Fsa&gt;</a>
<a name="ln2375">    inline basic_string&lt;_Ch_type, _St, _Sa&gt;</a>
<a name="ln2376">    regex_replace(const basic_string&lt;_Ch_type, _St, _Sa&gt;&amp; __s,</a>
<a name="ln2377">		  const basic_regex&lt;_Ch_type, _Rx_traits&gt;&amp; __e,</a>
<a name="ln2378">		  const basic_string&lt;_Ch_type, _Fst, _Fsa&gt;&amp; __fmt,</a>
<a name="ln2379">		  regex_constants::match_flag_type __flags</a>
<a name="ln2380">		  = regex_constants::match_default)</a>
<a name="ln2381">    {</a>
<a name="ln2382">      basic_string&lt;_Ch_type, _St, _Sa&gt; __result;</a>
<a name="ln2383">      regex_replace(std::back_inserter(__result),</a>
<a name="ln2384">		    __s.begin(), __s.end(), __e, __fmt, __flags);</a>
<a name="ln2385">      return __result;</a>
<a name="ln2386">    }</a>
<a name="ln2387"> </a>
<a name="ln2388">  /**</a>
<a name="ln2389">   * @brief Search for a regular expression within a string for multiple times,</a>
<a name="ln2390">   and replace the matched parts through filling a format C-string.</a>
<a name="ln2391">   * @param __s     [IN] The string to search and replace.</a>
<a name="ln2392">   * @param __e     [IN] The regular expression to search for.</a>
<a name="ln2393">   * @param __fmt   [IN] The format C-string.</a>
<a name="ln2394">   * @param __flags [IN] Search and replace policy flags.</a>
<a name="ln2395">   *</a>
<a name="ln2396">   * @returns The string after replacing.</a>
<a name="ln2397">   * @throws an exception of type regex_error.</a>
<a name="ln2398">   */</a>
<a name="ln2399">  template&lt;typename _Rx_traits, typename _Ch_type,</a>
<a name="ln2400">	   typename _St, typename _Sa&gt;</a>
<a name="ln2401">    inline basic_string&lt;_Ch_type, _St, _Sa&gt;</a>
<a name="ln2402">    regex_replace(const basic_string&lt;_Ch_type, _St, _Sa&gt;&amp; __s,</a>
<a name="ln2403">		  const basic_regex&lt;_Ch_type, _Rx_traits&gt;&amp; __e,</a>
<a name="ln2404">		  const _Ch_type* __fmt,</a>
<a name="ln2405">		  regex_constants::match_flag_type __flags</a>
<a name="ln2406">		  = regex_constants::match_default)</a>
<a name="ln2407">    {</a>
<a name="ln2408">      basic_string&lt;_Ch_type, _St, _Sa&gt; __result;</a>
<a name="ln2409">      regex_replace(std::back_inserter(__result),</a>
<a name="ln2410">		    __s.begin(), __s.end(), __e, __fmt, __flags);</a>
<a name="ln2411">      return __result;</a>
<a name="ln2412">    }</a>
<a name="ln2413"> </a>
<a name="ln2414">  /**</a>
<a name="ln2415">   * @brief Search for a regular expression within a C-string for multiple</a>
<a name="ln2416">   times, and replace the matched parts through filling a format string.</a>
<a name="ln2417">   * @param __s     [IN] The C-string to search and replace.</a>
<a name="ln2418">   * @param __e     [IN] The regular expression to search for.</a>
<a name="ln2419">   * @param __fmt   [IN] The format string.</a>
<a name="ln2420">   * @param __flags [IN] Search and replace policy flags.</a>
<a name="ln2421">   *</a>
<a name="ln2422">   * @returns The string after replacing.</a>
<a name="ln2423">   * @throws an exception of type regex_error.</a>
<a name="ln2424">   */</a>
<a name="ln2425">  template&lt;typename _Rx_traits, typename _Ch_type,</a>
<a name="ln2426">	   typename _St, typename _Sa&gt;</a>
<a name="ln2427">    inline basic_string&lt;_Ch_type&gt;</a>
<a name="ln2428">    regex_replace(const _Ch_type* __s,</a>
<a name="ln2429">		  const basic_regex&lt;_Ch_type, _Rx_traits&gt;&amp; __e,</a>
<a name="ln2430">		  const basic_string&lt;_Ch_type, _St, _Sa&gt;&amp; __fmt,</a>
<a name="ln2431">		  regex_constants::match_flag_type __flags</a>
<a name="ln2432">		  = regex_constants::match_default)</a>
<a name="ln2433">    {</a>
<a name="ln2434">      basic_string&lt;_Ch_type&gt; __result;</a>
<a name="ln2435">      regex_replace(std::back_inserter(__result), __s,</a>
<a name="ln2436">		    __s + char_traits&lt;_Ch_type&gt;::length(__s),</a>
<a name="ln2437">		    __e, __fmt, __flags);</a>
<a name="ln2438">      return __result;</a>
<a name="ln2439">    }</a>
<a name="ln2440"> </a>
<a name="ln2441">  /**</a>
<a name="ln2442">   * @brief Search for a regular expression within a C-string for multiple</a>
<a name="ln2443">   times, and replace the matched parts through filling a format C-string.</a>
<a name="ln2444">   * @param __s     [IN] The C-string to search and replace.</a>
<a name="ln2445">   * @param __e     [IN] The regular expression to search for.</a>
<a name="ln2446">   * @param __fmt   [IN] The format C-string.</a>
<a name="ln2447">   * @param __flags [IN] Search and replace policy flags.</a>
<a name="ln2448">   *</a>
<a name="ln2449">   * @returns The string after replacing.</a>
<a name="ln2450">   * @throws an exception of type regex_error.</a>
<a name="ln2451">   */</a>
<a name="ln2452">  template&lt;typename _Rx_traits, typename _Ch_type&gt;</a>
<a name="ln2453">    inline basic_string&lt;_Ch_type&gt;</a>
<a name="ln2454">    regex_replace(const _Ch_type* __s,</a>
<a name="ln2455">		  const basic_regex&lt;_Ch_type, _Rx_traits&gt;&amp; __e,</a>
<a name="ln2456">		  const _Ch_type* __fmt,</a>
<a name="ln2457">		  regex_constants::match_flag_type __flags</a>
<a name="ln2458">		  = regex_constants::match_default)</a>
<a name="ln2459">    {</a>
<a name="ln2460">      basic_string&lt;_Ch_type&gt; __result;</a>
<a name="ln2461">      regex_replace(std::back_inserter(__result), __s,</a>
<a name="ln2462">		    __s + char_traits&lt;_Ch_type&gt;::length(__s),</a>
<a name="ln2463">		    __e, __fmt, __flags);</a>
<a name="ln2464">      return __result;</a>
<a name="ln2465">    }</a>
<a name="ln2466"> </a>
<a name="ln2467">  //@}</a>
<a name="ln2468"> </a>
<a name="ln2469">_GLIBCXX_BEGIN_NAMESPACE_CXX11</a>
<a name="ln2470"> </a>
<a name="ln2471">  // std [28.12] Class template regex_iterator</a>
<a name="ln2472">  /**</a>
<a name="ln2473">   * An iterator adaptor that will provide repeated calls of regex_search over</a>
<a name="ln2474">   * a range until no more matches remain.</a>
<a name="ln2475">   */</a>
<a name="ln2476">  template&lt;typename _Bi_iter,</a>
<a name="ln2477">	   typename _Ch_type = typename iterator_traits&lt;_Bi_iter&gt;::value_type,</a>
<a name="ln2478">	   typename _Rx_traits = regex_traits&lt;_Ch_type&gt; &gt;</a>
<a name="ln2479">    class regex_iterator</a>
<a name="ln2480">    {</a>
<a name="ln2481">    public:</a>
<a name="ln2482">      typedef basic_regex&lt;_Ch_type, _Rx_traits&gt;  regex_type;</a>
<a name="ln2483">      typedef match_results&lt;_Bi_iter&gt;	    value_type;</a>
<a name="ln2484">      typedef std::ptrdiff_t		     difference_type;</a>
<a name="ln2485">      typedef const value_type*		  pointer;</a>
<a name="ln2486">      typedef const value_type&amp;		  reference;</a>
<a name="ln2487">      typedef std::forward_iterator_tag	  iterator_category;</a>
<a name="ln2488"> </a>
<a name="ln2489">      /**</a>
<a name="ln2490">       * @brief Provides a singular iterator, useful for indicating</a>
<a name="ln2491">       * one-past-the-end of a range.</a>
<a name="ln2492">       */</a>
<a name="ln2493">      regex_iterator()</a>
<a name="ln2494">      : _M_pregex()</a>
<a name="ln2495">      { }</a>
<a name="ln2496"> </a>
<a name="ln2497">      /**</a>
<a name="ln2498">       * Constructs a %regex_iterator...</a>
<a name="ln2499">       * @param __a  [IN] The start of a text range to search.</a>
<a name="ln2500">       * @param __b  [IN] One-past-the-end of the text range to search.</a>
<a name="ln2501">       * @param __re [IN] The regular expression to match.</a>
<a name="ln2502">       * @param __m  [IN] Policy flags for match rules.</a>
<a name="ln2503">       */</a>
<a name="ln2504">      regex_iterator(_Bi_iter __a, _Bi_iter __b, const regex_type&amp; __re,</a>
<a name="ln2505">		     regex_constants::match_flag_type __m</a>
<a name="ln2506">		     = regex_constants::match_default)</a>
<a name="ln2507">      : _M_begin(__a), _M_end(__b), _M_pregex(&amp;__re), _M_flags(__m), _M_match()</a>
<a name="ln2508">      {</a>
<a name="ln2509">	if (!regex_search(_M_begin, _M_end, _M_match, *_M_pregex, _M_flags))</a>
<a name="ln2510">	  *this = regex_iterator();</a>
<a name="ln2511">      }</a>
<a name="ln2512"> </a>
<a name="ln2513">      // _GLIBCXX_RESOLVE_LIB_DEFECTS</a>
<a name="ln2514">      // 2332. regex_iterator should forbid temporary regexes</a>
<a name="ln2515">      regex_iterator(_Bi_iter, _Bi_iter, const regex_type&amp;&amp;,</a>
<a name="ln2516">		     regex_constants::match_flag_type</a>
<a name="ln2517">		     = regex_constants::match_default) = delete;</a>
<a name="ln2518">      /**</a>
<a name="ln2519">       * Copy constructs a %regex_iterator.</a>
<a name="ln2520">       */</a>
<a name="ln2521">      regex_iterator(const regex_iterator&amp; __rhs) = default;</a>
<a name="ln2522"> </a>
<a name="ln2523">      /**</a>
<a name="ln2524">       * @brief Assigns one %regex_iterator to another.</a>
<a name="ln2525">       */</a>
<a name="ln2526">      regex_iterator&amp;</a>
<a name="ln2527">      operator=(const regex_iterator&amp; __rhs) = default;</a>
<a name="ln2528"> </a>
<a name="ln2529">      /**</a>
<a name="ln2530">       * @brief Tests the equivalence of two regex iterators.</a>
<a name="ln2531">       */</a>
<a name="ln2532">      bool</a>
<a name="ln2533">      operator==(const regex_iterator&amp; __rhs) const;</a>
<a name="ln2534"> </a>
<a name="ln2535">      /**</a>
<a name="ln2536">       * @brief Tests the inequivalence of two regex iterators.</a>
<a name="ln2537">       */</a>
<a name="ln2538">      bool</a>
<a name="ln2539">      operator!=(const regex_iterator&amp; __rhs) const</a>
<a name="ln2540">      { return !(*this == __rhs); }</a>
<a name="ln2541"> </a>
<a name="ln2542">      /**</a>
<a name="ln2543">       * @brief Dereferences a %regex_iterator.</a>
<a name="ln2544">       */</a>
<a name="ln2545">      const value_type&amp;</a>
<a name="ln2546">      operator*() const</a>
<a name="ln2547">      { return _M_match; }</a>
<a name="ln2548"> </a>
<a name="ln2549">      /**</a>
<a name="ln2550">       * @brief Selects a %regex_iterator member.</a>
<a name="ln2551">       */</a>
<a name="ln2552">      const value_type*</a>
<a name="ln2553">      operator-&gt;() const</a>
<a name="ln2554">      { return &amp;_M_match; }</a>
<a name="ln2555"> </a>
<a name="ln2556">      /**</a>
<a name="ln2557">       * @brief Increments a %regex_iterator.</a>
<a name="ln2558">       */</a>
<a name="ln2559">      regex_iterator&amp;</a>
<a name="ln2560">      operator++();</a>
<a name="ln2561"> </a>
<a name="ln2562">      /**</a>
<a name="ln2563">       * @brief Postincrements a %regex_iterator.</a>
<a name="ln2564">       */</a>
<a name="ln2565">      regex_iterator</a>
<a name="ln2566">      operator++(int)</a>
<a name="ln2567">      {</a>
<a name="ln2568">	auto __tmp = *this;</a>
<a name="ln2569">	++(*this);</a>
<a name="ln2570">	return __tmp;</a>
<a name="ln2571">      }</a>
<a name="ln2572"> </a>
<a name="ln2573">    private:</a>
<a name="ln2574">      _Bi_iter				_M_begin;</a>
<a name="ln2575">      _Bi_iter				_M_end;</a>
<a name="ln2576">      const regex_type*			_M_pregex;</a>
<a name="ln2577">      regex_constants::match_flag_type	_M_flags;</a>
<a name="ln2578">      match_results&lt;_Bi_iter&gt;		_M_match;</a>
<a name="ln2579">    };</a>
<a name="ln2580"> </a>
<a name="ln2581">  typedef regex_iterator&lt;const char*&gt;			cregex_iterator;</a>
<a name="ln2582">  typedef regex_iterator&lt;string::const_iterator&gt;	sregex_iterator;</a>
<a name="ln2583">#ifdef _GLIBCXX_USE_WCHAR_T</a>
<a name="ln2584">  typedef regex_iterator&lt;const wchar_t*&gt;		wcregex_iterator;</a>
<a name="ln2585">  typedef regex_iterator&lt;wstring::const_iterator&gt;	wsregex_iterator;</a>
<a name="ln2586">#endif</a>
<a name="ln2587"> </a>
<a name="ln2588">  // [7.12.2] Class template regex_token_iterator</a>
<a name="ln2589">  /**</a>
<a name="ln2590">   * Iterates over submatches in a range (or @a splits a text string).</a>
<a name="ln2591">   *</a>
<a name="ln2592">   * The purpose of this iterator is to enumerate all, or all specified,</a>
<a name="ln2593">   * matches of a regular expression within a text range.  The dereferenced</a>
<a name="ln2594">   * value of an iterator of this class is a std::sub_match object.</a>
<a name="ln2595">   */</a>
<a name="ln2596">  template&lt;typename _Bi_iter,</a>
<a name="ln2597">	   typename _Ch_type = typename iterator_traits&lt;_Bi_iter&gt;::value_type,</a>
<a name="ln2598">	   typename _Rx_traits = regex_traits&lt;_Ch_type&gt; &gt;</a>
<a name="ln2599">    class regex_token_iterator</a>
<a name="ln2600">    {</a>
<a name="ln2601">    public:</a>
<a name="ln2602">      typedef basic_regex&lt;_Ch_type, _Rx_traits&gt;	regex_type;</a>
<a name="ln2603">      typedef sub_match&lt;_Bi_iter&gt;		value_type;</a>
<a name="ln2604">      typedef std::ptrdiff_t			difference_type;</a>
<a name="ln2605">      typedef const value_type*			pointer;</a>
<a name="ln2606">      typedef const value_type&amp;			reference;</a>
<a name="ln2607">      typedef std::forward_iterator_tag		iterator_category;</a>
<a name="ln2608"> </a>
<a name="ln2609">    public:</a>
<a name="ln2610">      /**</a>
<a name="ln2611">       * @brief Default constructs a %regex_token_iterator.</a>
<a name="ln2612">       *</a>
<a name="ln2613">       * A default-constructed %regex_token_iterator is a singular iterator</a>
<a name="ln2614">       * that will compare equal to the one-past-the-end value for any</a>
<a name="ln2615">       * iterator of the same type.</a>
<a name="ln2616">       */</a>
<a name="ln2617">      regex_token_iterator()</a>
<a name="ln2618">      : _M_position(), _M_subs(), _M_suffix(), _M_n(0), _M_result(nullptr),</a>
<a name="ln2619">      _M_has_m1(false)</a>
<a name="ln2620">      { }</a>
<a name="ln2621"> </a>
<a name="ln2622">      /**</a>
<a name="ln2623">       * Constructs a %regex_token_iterator...</a>
<a name="ln2624">       * @param __a          [IN] The start of the text to search.</a>
<a name="ln2625">       * @param __b          [IN] One-past-the-end of the text to search.</a>
<a name="ln2626">       * @param __re         [IN] The regular expression to search for.</a>
<a name="ln2627">       * @param __submatch   [IN] Which submatch to return.  There are some</a>
<a name="ln2628">       *                        special values for this parameter:</a>
<a name="ln2629">       *                        - -1 each enumerated subexpression does NOT</a>
<a name="ln2630">       *                          match the regular expression (aka field</a>
<a name="ln2631">       *                          splitting)</a>
<a name="ln2632">       *                        - 0 the entire string matching the</a>
<a name="ln2633">       *                          subexpression is returned for each match</a>
<a name="ln2634">       *                          within the text.</a>
<a name="ln2635">       *                        - &gt;0 enumerates only the indicated</a>
<a name="ln2636">       *                          subexpression from a match within the text.</a>
<a name="ln2637">       * @param __m          [IN] Policy flags for match rules.</a>
<a name="ln2638">       */</a>
<a name="ln2639">      regex_token_iterator(_Bi_iter __a, _Bi_iter __b, const regex_type&amp; __re,</a>
<a name="ln2640">			   int __submatch = 0,</a>
<a name="ln2641">			   regex_constants::match_flag_type __m</a>
<a name="ln2642">			   = regex_constants::match_default)</a>
<a name="ln2643">      : _M_position(__a, __b, __re, __m), _M_subs(1, __submatch), _M_n(0)</a>
<a name="ln2644">      { _M_init(__a, __b); }</a>
<a name="ln2645"> </a>
<a name="ln2646">      /**</a>
<a name="ln2647">       * Constructs a %regex_token_iterator...</a>
<a name="ln2648">       * @param __a          [IN] The start of the text to search.</a>
<a name="ln2649">       * @param __b          [IN] One-past-the-end of the text to search.</a>
<a name="ln2650">       * @param __re         [IN] The regular expression to search for.</a>
<a name="ln2651">       * @param __submatches [IN] A list of subexpressions to return for each</a>
<a name="ln2652">       *                          regular expression match within the text.</a>
<a name="ln2653">       * @param __m          [IN] Policy flags for match rules.</a>
<a name="ln2654">       */</a>
<a name="ln2655">      regex_token_iterator(_Bi_iter __a, _Bi_iter __b,</a>
<a name="ln2656">			   const regex_type&amp; __re,</a>
<a name="ln2657">			   const std::vector&lt;int&gt;&amp; __submatches,</a>
<a name="ln2658">			   regex_constants::match_flag_type __m</a>
<a name="ln2659">			     = regex_constants::match_default)</a>
<a name="ln2660">      : _M_position(__a, __b, __re, __m), _M_subs(__submatches), _M_n(0)</a>
<a name="ln2661">      { _M_init(__a, __b); }</a>
<a name="ln2662"> </a>
<a name="ln2663">      /**</a>
<a name="ln2664">       * Constructs a %regex_token_iterator...</a>
<a name="ln2665">       * @param __a          [IN] The start of the text to search.</a>
<a name="ln2666">       * @param __b          [IN] One-past-the-end of the text to search.</a>
<a name="ln2667">       * @param __re         [IN] The regular expression to search for.</a>
<a name="ln2668">       * @param __submatches [IN] A list of subexpressions to return for each</a>
<a name="ln2669">       *                          regular expression match within the text.</a>
<a name="ln2670">       * @param __m          [IN] Policy flags for match rules.</a>
<a name="ln2671">       */</a>
<a name="ln2672">      regex_token_iterator(_Bi_iter __a, _Bi_iter __b,</a>
<a name="ln2673">			   const regex_type&amp; __re,</a>
<a name="ln2674">			   initializer_list&lt;int&gt; __submatches,</a>
<a name="ln2675">			   regex_constants::match_flag_type __m</a>
<a name="ln2676">			     = regex_constants::match_default)</a>
<a name="ln2677">      : _M_position(__a, __b, __re, __m), _M_subs(__submatches), _M_n(0)</a>
<a name="ln2678">      { _M_init(__a, __b); }</a>
<a name="ln2679"> </a>
<a name="ln2680">      /**</a>
<a name="ln2681">       * Constructs a %regex_token_iterator...</a>
<a name="ln2682">       * @param __a          [IN] The start of the text to search.</a>
<a name="ln2683">       * @param __b          [IN] One-past-the-end of the text to search.</a>
<a name="ln2684">       * @param __re         [IN] The regular expression to search for.</a>
<a name="ln2685">       * @param __submatches [IN] A list of subexpressions to return for each</a>
<a name="ln2686">       *                          regular expression match within the text.</a>
<a name="ln2687">       * @param __m          [IN] Policy flags for match rules.</a>
<a name="ln2688">       */</a>
<a name="ln2689">      template&lt;std::size_t _Nm&gt;</a>
<a name="ln2690">	regex_token_iterator(_Bi_iter __a, _Bi_iter __b,</a>
<a name="ln2691">			     const regex_type&amp; __re,</a>
<a name="ln2692">			     const int (&amp;__submatches)[_Nm],</a>
<a name="ln2693">			     regex_constants::match_flag_type __m</a>
<a name="ln2694">			     = regex_constants::match_default)</a>
<a name="ln2695">      : _M_position(__a, __b, __re, __m),</a>
<a name="ln2696">      _M_subs(__submatches, __submatches + _Nm), _M_n(0)</a>
<a name="ln2697">      { _M_init(__a, __b); }</a>
<a name="ln2698"> </a>
<a name="ln2699">      // _GLIBCXX_RESOLVE_LIB_DEFECTS</a>
<a name="ln2700">      // 2332. regex_token_iterator should forbid temporary regexes</a>
<a name="ln2701">      regex_token_iterator(_Bi_iter, _Bi_iter, const regex_type&amp;&amp;, int = 0,</a>
<a name="ln2702">			   regex_constants::match_flag_type =</a>
<a name="ln2703">			   regex_constants::match_default) = delete;</a>
<a name="ln2704">      regex_token_iterator(_Bi_iter, _Bi_iter, const regex_type&amp;&amp;,</a>
<a name="ln2705">			   const std::vector&lt;int&gt;&amp;,</a>
<a name="ln2706">			   regex_constants::match_flag_type =</a>
<a name="ln2707">			   regex_constants::match_default) = delete;</a>
<a name="ln2708">      regex_token_iterator(_Bi_iter, _Bi_iter, const regex_type&amp;&amp;,</a>
<a name="ln2709">			   initializer_list&lt;int&gt;,</a>
<a name="ln2710">			   regex_constants::match_flag_type =</a>
<a name="ln2711">			   regex_constants::match_default) = delete;</a>
<a name="ln2712">      template &lt;std::size_t _Nm&gt;</a>
<a name="ln2713">	regex_token_iterator(_Bi_iter, _Bi_iter, const regex_type&amp;&amp;,</a>
<a name="ln2714">			     const int (&amp;)[_Nm],</a>
<a name="ln2715">			     regex_constants::match_flag_type =</a>
<a name="ln2716">			     regex_constants::match_default) = delete;</a>
<a name="ln2717"> </a>
<a name="ln2718">      /**</a>
<a name="ln2719">       * @brief Copy constructs a %regex_token_iterator.</a>
<a name="ln2720">       * @param __rhs [IN] A %regex_token_iterator to copy.</a>
<a name="ln2721">       */</a>
<a name="ln2722">      regex_token_iterator(const regex_token_iterator&amp; __rhs)</a>
<a name="ln2723">      : _M_position(__rhs._M_position), _M_subs(__rhs._M_subs),</a>
<a name="ln2724">      _M_suffix(__rhs._M_suffix), _M_n(__rhs._M_n), _M_has_m1(__rhs._M_has_m1)</a>
<a name="ln2725">      { _M_normalize_result(); }</a>
<a name="ln2726"> </a>
<a name="ln2727">      /**</a>
<a name="ln2728">       * @brief Assigns a %regex_token_iterator to another.</a>
<a name="ln2729">       * @param __rhs [IN] A %regex_token_iterator to copy.</a>
<a name="ln2730">       */</a>
<a name="ln2731">      regex_token_iterator&amp;</a>
<a name="ln2732">      operator=(const regex_token_iterator&amp; __rhs);</a>
<a name="ln2733"> </a>
<a name="ln2734">      /**</a>
<a name="ln2735">       * @brief Compares a %regex_token_iterator to another for equality.</a>
<a name="ln2736">       */</a>
<a name="ln2737">      bool</a>
<a name="ln2738">      operator==(const regex_token_iterator&amp; __rhs) const;</a>
<a name="ln2739"> </a>
<a name="ln2740">      /**</a>
<a name="ln2741">       * @brief Compares a %regex_token_iterator to another for inequality.</a>
<a name="ln2742">       */</a>
<a name="ln2743">      bool</a>
<a name="ln2744">      operator!=(const regex_token_iterator&amp; __rhs) const</a>
<a name="ln2745">      { return !(*this == __rhs); }</a>
<a name="ln2746"> </a>
<a name="ln2747">      /**</a>
<a name="ln2748">       * @brief Dereferences a %regex_token_iterator.</a>
<a name="ln2749">       */</a>
<a name="ln2750">      const value_type&amp;</a>
<a name="ln2751">      operator*() const</a>
<a name="ln2752">      { return *_M_result; }</a>
<a name="ln2753"> </a>
<a name="ln2754">      /**</a>
<a name="ln2755">       * @brief Selects a %regex_token_iterator member.</a>
<a name="ln2756">       */</a>
<a name="ln2757">      const value_type*</a>
<a name="ln2758">      operator-&gt;() const</a>
<a name="ln2759">      { return _M_result; }</a>
<a name="ln2760"> </a>
<a name="ln2761">      /**</a>
<a name="ln2762">       * @brief Increments a %regex_token_iterator.</a>
<a name="ln2763">       */</a>
<a name="ln2764">      regex_token_iterator&amp;</a>
<a name="ln2765">      operator++();</a>
<a name="ln2766"> </a>
<a name="ln2767">      /**</a>
<a name="ln2768">       * @brief Postincrements a %regex_token_iterator.</a>
<a name="ln2769">       */</a>
<a name="ln2770">      regex_token_iterator</a>
<a name="ln2771">      operator++(int)</a>
<a name="ln2772">      {</a>
<a name="ln2773">	auto __tmp = *this;</a>
<a name="ln2774">	++(*this);</a>
<a name="ln2775">	return __tmp;</a>
<a name="ln2776">      }</a>
<a name="ln2777"> </a>
<a name="ln2778">    private:</a>
<a name="ln2779">      typedef regex_iterator&lt;_Bi_iter, _Ch_type, _Rx_traits&gt; _Position;</a>
<a name="ln2780"> </a>
<a name="ln2781">      void</a>
<a name="ln2782">      _M_init(_Bi_iter __a, _Bi_iter __b);</a>
<a name="ln2783"> </a>
<a name="ln2784">      const value_type&amp;</a>
<a name="ln2785">      _M_current_match() const</a>
<a name="ln2786">      {</a>
<a name="ln2787">	if (_M_subs[_M_n] == -1)</a>
<a name="ln2788">	  return (*_M_position).prefix();</a>
<a name="ln2789">	else</a>
<a name="ln2790">	  return (*_M_position)[_M_subs[_M_n]];</a>
<a name="ln2791">      }</a>
<a name="ln2792"> </a>
<a name="ln2793">      constexpr bool</a>
<a name="ln2794">      _M_end_of_seq() const</a>
<a name="ln2795">      { return _M_result == nullptr; }</a>
<a name="ln2796"> </a>
<a name="ln2797">      // [28.12.2.2.4]</a>
<a name="ln2798">      void</a>
<a name="ln2799">      _M_normalize_result()</a>
<a name="ln2800">      {</a>
<a name="ln2801">	if (_M_position != _Position())</a>
<a name="ln2802">	  _M_result = &amp;_M_current_match();</a>
<a name="ln2803">	else if (_M_has_m1)</a>
<a name="ln2804">	  _M_result = &amp;_M_suffix;</a>
<a name="ln2805">	else</a>
<a name="ln2806">	  _M_result = nullptr;</a>
<a name="ln2807">      }</a>
<a name="ln2808"> </a>
<a name="ln2809">      _Position		_M_position;</a>
<a name="ln2810">      std::vector&lt;int&gt;	_M_subs;</a>
<a name="ln2811">      value_type	_M_suffix;</a>
<a name="ln2812">      std::size_t	_M_n;</a>
<a name="ln2813">      const value_type*	_M_result;</a>
<a name="ln2814"> </a>
<a name="ln2815">      // Show whether _M_subs contains -1</a>
<a name="ln2816">      bool		_M_has_m1;</a>
<a name="ln2817">    };</a>
<a name="ln2818"> </a>
<a name="ln2819">  /** @brief Token iterator for C-style NULL-terminated strings. */</a>
<a name="ln2820">  typedef regex_token_iterator&lt;const char*&gt;		cregex_token_iterator;</a>
<a name="ln2821"> </a>
<a name="ln2822">  /** @brief Token iterator for standard strings. */</a>
<a name="ln2823">  typedef regex_token_iterator&lt;string::const_iterator&gt;	sregex_token_iterator;</a>
<a name="ln2824"> </a>
<a name="ln2825">#ifdef _GLIBCXX_USE_WCHAR_T</a>
<a name="ln2826">  /** @brief Token iterator for C-style NULL-terminated wide strings. */</a>
<a name="ln2827">  typedef regex_token_iterator&lt;const wchar_t*&gt;		wcregex_token_iterator;</a>
<a name="ln2828"> </a>
<a name="ln2829">  /** @brief Token iterator for standard wide-character strings. */</a>
<a name="ln2830">  typedef regex_token_iterator&lt;wstring::const_iterator&gt; wsregex_token_iterator;</a>
<a name="ln2831">#endif</a>
<a name="ln2832"> </a>
<a name="ln2833">  //@} // group regex</a>
<a name="ln2834"> </a>
<a name="ln2835">_GLIBCXX_END_NAMESPACE_CXX11</a>
<a name="ln2836">_GLIBCXX_END_NAMESPACE_VERSION</a>
<a name="ln2837">} // namespace</a>
<a name="ln2838"> </a>
<a name="ln2839">#include &lt;bits/regex.tcc&gt;</a>

</code></pre>
<div class="balloon" rel="259"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v530/" target="_blank">V530</a> The return value of function 'tolower' is required to be utilized.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
