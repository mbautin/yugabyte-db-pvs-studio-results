
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>signal_set.hpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//</a>
<a name="ln2">// signal_set.hpp</a>
<a name="ln3">// ~~~~~~~~~~~~~~</a>
<a name="ln4">//</a>
<a name="ln5">// Copyright (c) 2003-2018 Christopher M. Kohlhoff (chris at kohlhoff dot com)</a>
<a name="ln6">//</a>
<a name="ln7">// Distributed under the Boost Software License, Version 1.0. (See accompanying</a>
<a name="ln8">// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)</a>
<a name="ln9">//</a>
<a name="ln10"> </a>
<a name="ln11">#ifndef BOOST_ASIO_SIGNAL_SET_HPP</a>
<a name="ln12">#define BOOST_ASIO_SIGNAL_SET_HPP</a>
<a name="ln13"> </a>
<a name="ln14">#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1200)</a>
<a name="ln15"># pragma once</a>
<a name="ln16">#endif // defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1200)</a>
<a name="ln17"> </a>
<a name="ln18">#include &lt;boost/asio/detail/config.hpp&gt;</a>
<a name="ln19"> </a>
<a name="ln20">#include &lt;boost/asio/async_result.hpp&gt;</a>
<a name="ln21">#include &lt;boost/asio/basic_io_object.hpp&gt;</a>
<a name="ln22">#include &lt;boost/asio/detail/handler_type_requirements.hpp&gt;</a>
<a name="ln23">#include &lt;boost/asio/detail/throw_error.hpp&gt;</a>
<a name="ln24">#include &lt;boost/asio/error.hpp&gt;</a>
<a name="ln25">#include &lt;boost/asio/io_context.hpp&gt;</a>
<a name="ln26"> </a>
<a name="ln27">#if defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln28"># include &lt;boost/asio/basic_signal_set.hpp&gt;</a>
<a name="ln29">#else // defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln30"># include &lt;boost/asio/detail/signal_set_service.hpp&gt;</a>
<a name="ln31">#endif // defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln32"> </a>
<a name="ln33">namespace boost {</a>
<a name="ln34">namespace asio {</a>
<a name="ln35"> </a>
<a name="ln36">#if defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln37">// Typedef for the typical usage of a signal set.</a>
<a name="ln38">typedef basic_signal_set&lt;&gt; signal_set;</a>
<a name="ln39">#else // defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln40">/// Provides signal functionality.</a>
<a name="ln41">/**</a>
<a name="ln42"> * The signal_set class provides the ability to perform an asynchronous wait</a>
<a name="ln43"> * for one or more signals to occur.</a>
<a name="ln44"> *</a>
<a name="ln45"> * @par Thread Safety</a>
<a name="ln46"> * @e Distinct @e objects: Safe.@n</a>
<a name="ln47"> * @e Shared @e objects: Unsafe.</a>
<a name="ln48"> *</a>
<a name="ln49"> * @par Example</a>
<a name="ln50"> * Performing an asynchronous wait:</a>
<a name="ln51"> * @code</a>
<a name="ln52"> * void handler(</a>
<a name="ln53"> *     const boost::system::error_code&amp; error,</a>
<a name="ln54"> *     int signal_number)</a>
<a name="ln55"> * {</a>
<a name="ln56"> *   if (!error)</a>
<a name="ln57"> *   {</a>
<a name="ln58"> *     // A signal occurred.</a>
<a name="ln59"> *   }</a>
<a name="ln60"> * }</a>
<a name="ln61"> *</a>
<a name="ln62"> * ...</a>
<a name="ln63"> *</a>
<a name="ln64"> * // Construct a signal set registered for process termination.</a>
<a name="ln65"> * boost::asio::signal_set signals(io_context, SIGINT, SIGTERM);</a>
<a name="ln66"> *</a>
<a name="ln67"> * // Start an asynchronous wait for one of the signals to occur.</a>
<a name="ln68"> * signals.async_wait(handler);</a>
<a name="ln69"> * @endcode</a>
<a name="ln70"> *</a>
<a name="ln71"> * @par Queueing of signal notifications</a>
<a name="ln72"> *</a>
<a name="ln73"> * If a signal is registered with a signal_set, and the signal occurs when</a>
<a name="ln74"> * there are no waiting handlers, then the signal notification is queued. The</a>
<a name="ln75"> * next async_wait operation on that signal_set will dequeue the notification.</a>
<a name="ln76"> * If multiple notifications are queued, subsequent async_wait operations</a>
<a name="ln77"> * dequeue them one at a time. Signal notifications are dequeued in order of</a>
<a name="ln78"> * ascending signal number.</a>
<a name="ln79"> *</a>
<a name="ln80"> * If a signal number is removed from a signal_set (using the @c remove or @c</a>
<a name="ln81"> * erase member functions) then any queued notifications for that signal are</a>
<a name="ln82"> * discarded.</a>
<a name="ln83"> *</a>
<a name="ln84"> * @par Multiple registration of signals</a>
<a name="ln85"> *</a>
<a name="ln86"> * The same signal number may be registered with different signal_set objects.</a>
<a name="ln87"> * When the signal occurs, one handler is called for each signal_set object.</a>
<a name="ln88"> *</a>
<a name="ln89"> * Note that multiple registration only works for signals that are registered</a>
<a name="ln90"> * using Asio. The application must not also register a signal handler using</a>
<a name="ln91"> * functions such as @c signal() or @c sigaction().</a>
<a name="ln92"> *</a>
<a name="ln93"> * @par Signal masking on POSIX platforms</a>
<a name="ln94"> *</a>
<a name="ln95"> * POSIX allows signals to be blocked using functions such as @c sigprocmask()</a>
<a name="ln96"> * and @c pthread_sigmask(). For signals to be delivered, programs must ensure</a>
<a name="ln97"> * that any signals registered using signal_set objects are unblocked in at</a>
<a name="ln98"> * least one thread.</a>
<a name="ln99"> */</a>
<a name="ln100">class signal_set</a>
<a name="ln101">  : BOOST_ASIO_SVC_ACCESS basic_io_object&lt;detail::signal_set_service&gt;</a>
<a name="ln102">{</a>
<a name="ln103">public:</a>
<a name="ln104">  /// The type of the executor associated with the object.</a>
<a name="ln105">  typedef io_context::executor_type executor_type;</a>
<a name="ln106"> </a>
<a name="ln107">  /// Construct a signal set without adding any signals.</a>
<a name="ln108">  /**</a>
<a name="ln109">   * This constructor creates a signal set without registering for any signals.</a>
<a name="ln110">   *</a>
<a name="ln111">   * @param io_context The io_context object that the signal set will use to</a>
<a name="ln112">   * dispatch handlers for any asynchronous operations performed on the set.</a>
<a name="ln113">   */</a>
<a name="ln114">  explicit signal_set(boost::asio::io_context&amp; io_context)</a>
<a name="ln115">    : basic_io_object&lt;detail::signal_set_service&gt;(io_context)</a>
<a name="ln116">  {</a>
<a name="ln117">  }</a>
<a name="ln118"> </a>
<a name="ln119">  /// Construct a signal set and add one signal.</a>
<a name="ln120">  /**</a>
<a name="ln121">   * This constructor creates a signal set and registers for one signal.</a>
<a name="ln122">   *</a>
<a name="ln123">   * @param io_context The io_context object that the signal set will use to</a>
<a name="ln124">   * dispatch handlers for any asynchronous operations performed on the set.</a>
<a name="ln125">   *</a>
<a name="ln126">   * @param signal_number_1 The signal number to be added.</a>
<a name="ln127">   *</a>
<a name="ln128">   * @note This constructor is equivalent to performing:</a>
<a name="ln129">   * @code boost::asio::signal_set signals(io_context);</a>
<a name="ln130">   * signals.add(signal_number_1); @endcode</a>
<a name="ln131">   */</a>
<a name="ln132">  signal_set(boost::asio::io_context&amp; io_context, int signal_number_1)</a>
<a name="ln133">    : basic_io_object&lt;detail::signal_set_service&gt;(io_context)</a>
<a name="ln134">  {</a>
<a name="ln135">    boost::system::error_code ec;</a>
<a name="ln136">    this-&gt;get_service().add(this-&gt;get_implementation(), signal_number_1, ec);</a>
<a name="ln137">    boost::asio::detail::throw_error(ec, &quot;add&quot;);</a>
<a name="ln138">  }</a>
<a name="ln139"> </a>
<a name="ln140">  /// Construct a signal set and add two signals.</a>
<a name="ln141">  /**</a>
<a name="ln142">   * This constructor creates a signal set and registers for two signals.</a>
<a name="ln143">   *</a>
<a name="ln144">   * @param io_context The io_context object that the signal set will use to</a>
<a name="ln145">   * dispatch handlers for any asynchronous operations performed on the set.</a>
<a name="ln146">   *</a>
<a name="ln147">   * @param signal_number_1 The first signal number to be added.</a>
<a name="ln148">   *</a>
<a name="ln149">   * @param signal_number_2 The second signal number to be added.</a>
<a name="ln150">   *</a>
<a name="ln151">   * @note This constructor is equivalent to performing:</a>
<a name="ln152">   * @code boost::asio::signal_set signals(io_context);</a>
<a name="ln153">   * signals.add(signal_number_1);</a>
<a name="ln154">   * signals.add(signal_number_2); @endcode</a>
<a name="ln155">   */</a>
<a name="ln156">  signal_set(boost::asio::io_context&amp; io_context, int signal_number_1,</a>
<a name="ln157">      int signal_number_2)</a>
<a name="ln158">    : basic_io_object&lt;detail::signal_set_service&gt;(io_context)</a>
<a name="ln159">  {</a>
<a name="ln160">    boost::system::error_code ec;</a>
<a name="ln161">    this-&gt;get_service().add(this-&gt;get_implementation(), signal_number_1, ec);</a>
<a name="ln162">    boost::asio::detail::throw_error(ec, &quot;add&quot;);</a>
<a name="ln163">    this-&gt;get_service().add(this-&gt;get_implementation(), signal_number_2, ec);</a>
<a name="ln164">    boost::asio::detail::throw_error(ec, &quot;add&quot;);</a>
<a name="ln165">  }</a>
<a name="ln166"> </a>
<a name="ln167">  /// Construct a signal set and add three signals.</a>
<a name="ln168">  /**</a>
<a name="ln169">   * This constructor creates a signal set and registers for three signals.</a>
<a name="ln170">   *</a>
<a name="ln171">   * @param io_context The io_context object that the signal set will use to</a>
<a name="ln172">   * dispatch handlers for any asynchronous operations performed on the set.</a>
<a name="ln173">   *</a>
<a name="ln174">   * @param signal_number_1 The first signal number to be added.</a>
<a name="ln175">   *</a>
<a name="ln176">   * @param signal_number_2 The second signal number to be added.</a>
<a name="ln177">   *</a>
<a name="ln178">   * @param signal_number_3 The third signal number to be added.</a>
<a name="ln179">   *</a>
<a name="ln180">   * @note This constructor is equivalent to performing:</a>
<a name="ln181">   * @code boost::asio::signal_set signals(io_context);</a>
<a name="ln182">   * signals.add(signal_number_1);</a>
<a name="ln183">   * signals.add(signal_number_2);</a>
<a name="ln184">   * signals.add(signal_number_3); @endcode</a>
<a name="ln185">   */</a>
<a name="ln186">  signal_set(boost::asio::io_context&amp; io_context, int signal_number_1,</a>
<a name="ln187">      int signal_number_2, int signal_number_3)</a>
<a name="ln188">    : basic_io_object&lt;detail::signal_set_service&gt;(io_context)</a>
<a name="ln189">  {</a>
<a name="ln190">    boost::system::error_code ec;</a>
<a name="ln191">    this-&gt;get_service().add(this-&gt;get_implementation(), signal_number_1, ec);</a>
<a name="ln192">    boost::asio::detail::throw_error(ec, &quot;add&quot;);</a>
<a name="ln193">    this-&gt;get_service().add(this-&gt;get_implementation(), signal_number_2, ec);</a>
<a name="ln194">    boost::asio::detail::throw_error(ec, &quot;add&quot;);</a>
<a name="ln195">    this-&gt;get_service().add(this-&gt;get_implementation(), signal_number_3, ec);</a>
<a name="ln196">    boost::asio::detail::throw_error(ec, &quot;add&quot;);</a>
<a name="ln197">  }</a>
<a name="ln198"> </a>
<a name="ln199">  /// Destroys the signal set.</a>
<a name="ln200">  /**</a>
<a name="ln201">   * This function destroys the signal set, cancelling any outstanding</a>
<a name="ln202">   * asynchronous wait operations associated with the signal set as if by</a>
<a name="ln203">   * calling @c cancel.</a>
<a name="ln204">   */</a>
<a name="ln205">  ~signal_set()</a>
<a name="ln206">  {</a>
<a name="ln207">  }</a>
<a name="ln208"> </a>
<a name="ln209">#if !defined(BOOST_ASIO_NO_DEPRECATED)</a>
<a name="ln210">  /// (Deprecated: Use get_executor().) Get the io_context associated with the</a>
<a name="ln211">  /// object.</a>
<a name="ln212">  /**</a>
<a name="ln213">   * This function may be used to obtain the io_context object that the I/O</a>
<a name="ln214">   * object uses to dispatch handlers for asynchronous operations.</a>
<a name="ln215">   *</a>
<a name="ln216">   * @return A reference to the io_context object that the I/O object will use</a>
<a name="ln217">   * to dispatch handlers. Ownership is not transferred to the caller.</a>
<a name="ln218">   */</a>
<a name="ln219">  boost::asio::io_context&amp; get_io_context()</a>
<a name="ln220">  {</a>
<a name="ln221">    return basic_io_object&lt;detail::signal_set_service&gt;::get_io_context();</a>
<a name="ln222">  }</a>
<a name="ln223"> </a>
<a name="ln224">  /// (Deprecated: Use get_executor().) Get the io_context associated with the</a>
<a name="ln225">  /// object.</a>
<a name="ln226">  /**</a>
<a name="ln227">   * This function may be used to obtain the io_context object that the I/O</a>
<a name="ln228">   * object uses to dispatch handlers for asynchronous operations.</a>
<a name="ln229">   *</a>
<a name="ln230">   * @return A reference to the io_context object that the I/O object will use</a>
<a name="ln231">   * to dispatch handlers. Ownership is not transferred to the caller.</a>
<a name="ln232">   */</a>
<a name="ln233">  boost::asio::io_context&amp; get_io_service()</a>
<a name="ln234">  {</a>
<a name="ln235">    return basic_io_object&lt;detail::signal_set_service&gt;::get_io_service();</a>
<a name="ln236">  }</a>
<a name="ln237">#endif // !defined(BOOST_ASIO_NO_DEPRECATED)</a>
<a name="ln238"> </a>
<a name="ln239">  /// Get the executor associated with the object.</a>
<a name="ln240">  executor_type get_executor() BOOST_ASIO_NOEXCEPT</a>
<a name="ln241">  {</a>
<a name="ln242">    return basic_io_object&lt;detail::signal_set_service&gt;::get_executor();</a>
<a name="ln243">  }</a>
<a name="ln244"> </a>
<a name="ln245">  /// Add a signal to a signal_set.</a>
<a name="ln246">  /**</a>
<a name="ln247">   * This function adds the specified signal to the set. It has no effect if the</a>
<a name="ln248">   * signal is already in the set.</a>
<a name="ln249">   *</a>
<a name="ln250">   * @param signal_number The signal to be added to the set.</a>
<a name="ln251">   *</a>
<a name="ln252">   * @throws boost::system::system_error Thrown on failure.</a>
<a name="ln253">   */</a>
<a name="ln254">  void add(int signal_number)</a>
<a name="ln255">  {</a>
<a name="ln256">    boost::system::error_code ec;</a>
<a name="ln257">    this-&gt;get_service().add(this-&gt;get_implementation(), signal_number, ec);</a>
<a name="ln258">    boost::asio::detail::throw_error(ec, &quot;add&quot;);</a>
<a name="ln259">  }</a>
<a name="ln260"> </a>
<a name="ln261">  /// Add a signal to a signal_set.</a>
<a name="ln262">  /**</a>
<a name="ln263">   * This function adds the specified signal to the set. It has no effect if the</a>
<a name="ln264">   * signal is already in the set.</a>
<a name="ln265">   *</a>
<a name="ln266">   * @param signal_number The signal to be added to the set.</a>
<a name="ln267">   *</a>
<a name="ln268">   * @param ec Set to indicate what error occurred, if any.</a>
<a name="ln269">   */</a>
<a name="ln270">  BOOST_ASIO_SYNC_OP_VOID add(int signal_number,</a>
<a name="ln271">      boost::system::error_code&amp; ec)</a>
<a name="ln272">  {</a>
<a name="ln273">    this-&gt;get_service().add(this-&gt;get_implementation(), signal_number, ec);</a>
<a name="ln274">    BOOST_ASIO_SYNC_OP_VOID_RETURN(ec);</a>
<a name="ln275">  }</a>
<a name="ln276"> </a>
<a name="ln277">  /// Remove a signal from a signal_set.</a>
<a name="ln278">  /**</a>
<a name="ln279">   * This function removes the specified signal from the set. It has no effect</a>
<a name="ln280">   * if the signal is not in the set.</a>
<a name="ln281">   *</a>
<a name="ln282">   * @param signal_number The signal to be removed from the set.</a>
<a name="ln283">   *</a>
<a name="ln284">   * @throws boost::system::system_error Thrown on failure.</a>
<a name="ln285">   *</a>
<a name="ln286">   * @note Removes any notifications that have been queued for the specified</a>
<a name="ln287">   * signal number.</a>
<a name="ln288">   */</a>
<a name="ln289">  void remove(int signal_number)</a>
<a name="ln290">  {</a>
<a name="ln291">    boost::system::error_code ec;</a>
<a name="ln292">    this-&gt;get_service().remove(this-&gt;get_implementation(), signal_number, ec);</a>
<a name="ln293">    boost::asio::detail::throw_error(ec, &quot;remove&quot;);</a>
<a name="ln294">  }</a>
<a name="ln295"> </a>
<a name="ln296">  /// Remove a signal from a signal_set.</a>
<a name="ln297">  /**</a>
<a name="ln298">   * This function removes the specified signal from the set. It has no effect</a>
<a name="ln299">   * if the signal is not in the set.</a>
<a name="ln300">   *</a>
<a name="ln301">   * @param signal_number The signal to be removed from the set.</a>
<a name="ln302">   *</a>
<a name="ln303">   * @param ec Set to indicate what error occurred, if any.</a>
<a name="ln304">   *</a>
<a name="ln305">   * @note Removes any notifications that have been queued for the specified</a>
<a name="ln306">   * signal number.</a>
<a name="ln307">   */</a>
<a name="ln308">  BOOST_ASIO_SYNC_OP_VOID remove(int signal_number,</a>
<a name="ln309">      boost::system::error_code&amp; ec)</a>
<a name="ln310">  {</a>
<a name="ln311">    this-&gt;get_service().remove(this-&gt;get_implementation(), signal_number, ec);</a>
<a name="ln312">    BOOST_ASIO_SYNC_OP_VOID_RETURN(ec);</a>
<a name="ln313">  }</a>
<a name="ln314"> </a>
<a name="ln315">  /// Remove all signals from a signal_set.</a>
<a name="ln316">  /**</a>
<a name="ln317">   * This function removes all signals from the set. It has no effect if the set</a>
<a name="ln318">   * is already empty.</a>
<a name="ln319">   *</a>
<a name="ln320">   * @throws boost::system::system_error Thrown on failure.</a>
<a name="ln321">   *</a>
<a name="ln322">   * @note Removes all queued notifications.</a>
<a name="ln323">   */</a>
<a name="ln324">  void clear()</a>
<a name="ln325">  {</a>
<a name="ln326">    boost::system::error_code ec;</a>
<a name="ln327">    this-&gt;get_service().clear(this-&gt;get_implementation(), ec);</a>
<a name="ln328">    boost::asio::detail::throw_error(ec, &quot;clear&quot;);</a>
<a name="ln329">  }</a>
<a name="ln330"> </a>
<a name="ln331">  /// Remove all signals from a signal_set.</a>
<a name="ln332">  /**</a>
<a name="ln333">   * This function removes all signals from the set. It has no effect if the set</a>
<a name="ln334">   * is already empty.</a>
<a name="ln335">   *</a>
<a name="ln336">   * @param ec Set to indicate what error occurred, if any.</a>
<a name="ln337">   *</a>
<a name="ln338">   * @note Removes all queued notifications.</a>
<a name="ln339">   */</a>
<a name="ln340">  BOOST_ASIO_SYNC_OP_VOID clear(boost::system::error_code&amp; ec)</a>
<a name="ln341">  {</a>
<a name="ln342">    this-&gt;get_service().clear(this-&gt;get_implementation(), ec);</a>
<a name="ln343">    BOOST_ASIO_SYNC_OP_VOID_RETURN(ec);</a>
<a name="ln344">  }</a>
<a name="ln345"> </a>
<a name="ln346">  /// Cancel all operations associated with the signal set.</a>
<a name="ln347">  /**</a>
<a name="ln348">   * This function forces the completion of any pending asynchronous wait</a>
<a name="ln349">   * operations against the signal set. The handler for each cancelled</a>
<a name="ln350">   * operation will be invoked with the boost::asio::error::operation_aborted</a>
<a name="ln351">   * error code.</a>
<a name="ln352">   *</a>
<a name="ln353">   * Cancellation does not alter the set of registered signals.</a>
<a name="ln354">   *</a>
<a name="ln355">   * @throws boost::system::system_error Thrown on failure.</a>
<a name="ln356">   *</a>
<a name="ln357">   * @note If a registered signal occurred before cancel() is called, then the</a>
<a name="ln358">   * handlers for asynchronous wait operations will:</a>
<a name="ln359">   *</a>
<a name="ln360">   * @li have already been invoked; or</a>
<a name="ln361">   *</a>
<a name="ln362">   * @li have been queued for invocation in the near future.</a>
<a name="ln363">   *</a>
<a name="ln364">   * These handlers can no longer be cancelled, and therefore are passed an</a>
<a name="ln365">   * error code that indicates the successful completion of the wait operation.</a>
<a name="ln366">   */</a>
<a name="ln367">  void cancel()</a>
<a name="ln368">  {</a>
<a name="ln369">    boost::system::error_code ec;</a>
<a name="ln370">    this-&gt;get_service().cancel(this-&gt;get_implementation(), ec);</a>
<a name="ln371">    boost::asio::detail::throw_error(ec, &quot;cancel&quot;);</a>
<a name="ln372">  }</a>
<a name="ln373"> </a>
<a name="ln374">  /// Cancel all operations associated with the signal set.</a>
<a name="ln375">  /**</a>
<a name="ln376">   * This function forces the completion of any pending asynchronous wait</a>
<a name="ln377">   * operations against the signal set. The handler for each cancelled</a>
<a name="ln378">   * operation will be invoked with the boost::asio::error::operation_aborted</a>
<a name="ln379">   * error code.</a>
<a name="ln380">   *</a>
<a name="ln381">   * Cancellation does not alter the set of registered signals.</a>
<a name="ln382">   *</a>
<a name="ln383">   * @param ec Set to indicate what error occurred, if any.</a>
<a name="ln384">   *</a>
<a name="ln385">   * @note If a registered signal occurred before cancel() is called, then the</a>
<a name="ln386">   * handlers for asynchronous wait operations will:</a>
<a name="ln387">   *</a>
<a name="ln388">   * @li have already been invoked; or</a>
<a name="ln389">   *</a>
<a name="ln390">   * @li have been queued for invocation in the near future.</a>
<a name="ln391">   *</a>
<a name="ln392">   * These handlers can no longer be cancelled, and therefore are passed an</a>
<a name="ln393">   * error code that indicates the successful completion of the wait operation.</a>
<a name="ln394">   */</a>
<a name="ln395">  BOOST_ASIO_SYNC_OP_VOID cancel(boost::system::error_code&amp; ec)</a>
<a name="ln396">  {</a>
<a name="ln397">    this-&gt;get_service().cancel(this-&gt;get_implementation(), ec);</a>
<a name="ln398">    BOOST_ASIO_SYNC_OP_VOID_RETURN(ec);</a>
<a name="ln399">  }</a>
<a name="ln400"> </a>
<a name="ln401">  /// Start an asynchronous operation to wait for a signal to be delivered.</a>
<a name="ln402">  /**</a>
<a name="ln403">   * This function may be used to initiate an asynchronous wait against the</a>
<a name="ln404">   * signal set. It always returns immediately.</a>
<a name="ln405">   *</a>
<a name="ln406">   * For each call to async_wait(), the supplied handler will be called exactly</a>
<a name="ln407">   * once. The handler will be called when:</a>
<a name="ln408">   *</a>
<a name="ln409">   * @li One of the registered signals in the signal set occurs; or</a>
<a name="ln410">   *</a>
<a name="ln411">   * @li The signal set was cancelled, in which case the handler is passed the</a>
<a name="ln412">   * error code boost::asio::error::operation_aborted.</a>
<a name="ln413">   *</a>
<a name="ln414">   * @param handler The handler to be called when the signal occurs. Copies</a>
<a name="ln415">   * will be made of the handler as required. The function signature of the</a>
<a name="ln416">   * handler must be:</a>
<a name="ln417">   * @code void handler(</a>
<a name="ln418">   *   const boost::system::error_code&amp; error, // Result of operation.</a>
<a name="ln419">   *   int signal_number // Indicates which signal occurred.</a>
<a name="ln420">   * ); @endcode</a>
<a name="ln421">   * Regardless of whether the asynchronous operation completes immediately or</a>
<a name="ln422">   * not, the handler will not be invoked from within this function. Invocation</a>
<a name="ln423">   * of the handler will be performed in a manner equivalent to using</a>
<a name="ln424">   * boost::asio::io_context::post().</a>
<a name="ln425">   */</a>
<a name="ln426">  template &lt;typename SignalHandler&gt;</a>
<a name="ln427">  BOOST_ASIO_INITFN_RESULT_TYPE(SignalHandler,</a>
<a name="ln428">      void (boost::system::error_code, int))</a>
<a name="ln429">  async_wait(BOOST_ASIO_MOVE_ARG(SignalHandler) handler)</a>
<a name="ln430">  {</a>
<a name="ln431">    // If you get an error on the following line it means that your handler does</a>
<a name="ln432">    // not meet the documented type requirements for a SignalHandler.</a>
<a name="ln433">    BOOST_ASIO_SIGNAL_HANDLER_CHECK(SignalHandler, handler) type_check;</a>
<a name="ln434"> </a>
<a name="ln435">    async_completion&lt;SignalHandler,</a>
<a name="ln436">      void (boost::system::error_code, int)&gt; init(handler);</a>
<a name="ln437"> </a>
<a name="ln438">    this-&gt;get_service().async_wait(this-&gt;get_implementation(),</a>
<a name="ln439">        init.completion_handler);</a>
<a name="ln440"> </a>
<a name="ln441">    return init.result.get();</a>
<a name="ln442">  }</a>
<a name="ln443">};</a>
<a name="ln444">#endif // defined(BOOST_ASIO_ENABLE_OLD_SERVICES)</a>
<a name="ln445"> </a>
<a name="ln446">} // namespace asio</a>
<a name="ln447">} // namespace boost</a>
<a name="ln448"> </a>
<a name="ln449">#endif // BOOST_ASIO_SIGNAL_SET_HPP</a>

</code></pre>
<div class="balloon" rel="163"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v779/" target="_blank">V779</a> Unreachable code detected. It is possible that an error is present.</p></div>
<div class="balloon" rel="193"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v779/" target="_blank">V779</a> Unreachable code detected. It is possible that an error is present.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
