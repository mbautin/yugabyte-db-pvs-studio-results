
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>pt_expr.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//--------------------------------------------------------------------------------------------------</a>
<a name="ln2">// Copyright (c) YugaByte, Inc.</a>
<a name="ln3">//</a>
<a name="ln4">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln5">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln6">//</a>
<a name="ln7">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln8">//</a>
<a name="ln9">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln10">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln11">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln12">// under the License.</a>
<a name="ln13">//</a>
<a name="ln14">//</a>
<a name="ln15">// Treenode definitions for expressions.</a>
<a name="ln16">//--------------------------------------------------------------------------------------------------</a>
<a name="ln17"> </a>
<a name="ln18">#include &quot;yb/client/table.h&quot;</a>
<a name="ln19"> </a>
<a name="ln20">#include &quot;yb/yql/cql/ql/ptree/pt_expr.h&quot;</a>
<a name="ln21">#include &quot;yb/yql/cql/ql/ptree/pt_bcall.h&quot;</a>
<a name="ln22">#include &quot;yb/yql/cql/ql/ptree/sem_context.h&quot;</a>
<a name="ln23">#include &quot;yb/util/decimal.h&quot;</a>
<a name="ln24">#include &quot;yb/util/net/inetaddress.h&quot;</a>
<a name="ln25">#include &quot;yb/util/net/net_util.h&quot;</a>
<a name="ln26">#include &quot;yb/util/stol_utils.h&quot;</a>
<a name="ln27">#include &quot;yb/util/date_time.h&quot;</a>
<a name="ln28"> </a>
<a name="ln29">namespace yb {</a>
<a name="ln30">namespace ql {</a>
<a name="ln31"> </a>
<a name="ln32">using client::YBColumnSchema;</a>
<a name="ln33">using std::shared_ptr;</a>
<a name="ln34"> </a>
<a name="ln35">//--------------------------------------------------------------------------------------------------</a>
<a name="ln36"> </a>
<a name="ln37">bool PTExpr::CheckIndexColumn(SemContext *sem_context) {</a>
<a name="ln38">  if (!sem_context-&gt;selecting_from_index()) {</a>
<a name="ln39">    return false;</a>
<a name="ln40">  }</a>
<a name="ln41"> </a>
<a name="ln42">  // Currently, only PTJsonColumnWithOperators node is allowed to be an IndexColumn. However, define</a>
<a name="ln43">  // this analysis in PTExpr class so that it's easier to extend the support INDEX by expression.</a>
<a name="ln44">  if (op_ != ExprOperator::kJsonOperatorRef) {</a>
<a name="ln45">    return false;</a>
<a name="ln46">  }</a>
<a name="ln47"> </a>
<a name="ln48">  // Check if this expression is used for indexing.</a>
<a name="ln49">  index_desc_ = GetColumnDesc(sem_context);</a>
<a name="ln50">  if (index_desc_ != nullptr) {</a>
<a name="ln51">    // Type resolution: This expr should have the same datatype as the column.</a>
<a name="ln52">    index_name_-&gt;assign(QLName().c_str());</a>
<a name="ln53">    internal_type_ = index_desc_-&gt;internal_type();</a>
<a name="ln54">    ql_type_ = index_desc_-&gt;ql_type();</a>
<a name="ln55">    return true;</a>
<a name="ln56">  }</a>
<a name="ln57"> </a>
<a name="ln58">  return false;</a>
<a name="ln59">}</a>
<a name="ln60"> </a>
<a name="ln61">CHECKED_STATUS PTExpr::CheckOperator(SemContext *sem_context) {</a>
<a name="ln62">  // Where clause only allow AND, EQ, LT, LE, GT, and GE operators.</a>
<a name="ln63">  if (sem_context-&gt;where_state() != nullptr) {</a>
<a name="ln64">    switch (ql_op_) {</a>
<a name="ln65">      case QL_OP_AND:</a>
<a name="ln66">      case QL_OP_EQUAL:</a>
<a name="ln67">      case QL_OP_LESS_THAN:</a>
<a name="ln68">      case QL_OP_LESS_THAN_EQUAL:</a>
<a name="ln69">      case QL_OP_GREATER_THAN:</a>
<a name="ln70">      case QL_OP_GREATER_THAN_EQUAL:</a>
<a name="ln71">      case QL_OP_IN:</a>
<a name="ln72">      case QL_OP_NOT_IN:</a>
<a name="ln73">      case QL_OP_NOOP:</a>
<a name="ln74">        break;</a>
<a name="ln75">      default:</a>
<a name="ln76">        return sem_context-&gt;Error(this, &quot;This operator is not allowed in where clause&quot;,</a>
<a name="ln77">                                  ErrorCode::CQL_STATEMENT_INVALID);</a>
<a name="ln78">    }</a>
<a name="ln79">  }</a>
<a name="ln80">  return Status::OK();</a>
<a name="ln81">}</a>
<a name="ln82"> </a>
<a name="ln83">CHECKED_STATUS PTExpr::AnalyzeOperator(SemContext *sem_context) {</a>
<a name="ln84">  return Status::OK();</a>
<a name="ln85">}</a>
<a name="ln86"> </a>
<a name="ln87">CHECKED_STATUS PTExpr::AnalyzeOperator(SemContext *sem_context,</a>
<a name="ln88">                                       PTExpr::SharedPtr op1) {</a>
<a name="ln89">  return Status::OK();</a>
<a name="ln90">}</a>
<a name="ln91"> </a>
<a name="ln92">CHECKED_STATUS PTExpr::AnalyzeOperator(SemContext *sem_context,</a>
<a name="ln93">                                       PTExpr::SharedPtr op1,</a>
<a name="ln94">                                       PTExpr::SharedPtr op2) {</a>
<a name="ln95">  return Status::OK();</a>
<a name="ln96">}</a>
<a name="ln97"> </a>
<a name="ln98">CHECKED_STATUS PTExpr::AnalyzeOperator(SemContext *sem_context,</a>
<a name="ln99">                                       PTExpr::SharedPtr op1,</a>
<a name="ln100">                                       PTExpr::SharedPtr op2,</a>
<a name="ln101">                                       PTExpr::SharedPtr op3) {</a>
<a name="ln102">  return Status::OK();</a>
<a name="ln103">}</a>
<a name="ln104"> </a>
<a name="ln105">CHECKED_STATUS PTExpr::SetupSemStateForOp1(SemState *sem_state) {</a>
<a name="ln106">  return Status::OK();</a>
<a name="ln107">}</a>
<a name="ln108"> </a>
<a name="ln109">CHECKED_STATUS PTExpr::SetupSemStateForOp2(SemState *sem_state) {</a>
<a name="ln110">  // Passing down where clause state variables.</a>
<a name="ln111">  return Status::OK();</a>
<a name="ln112">}</a>
<a name="ln113"> </a>
<a name="ln114">CHECKED_STATUS PTExpr::SetupSemStateForOp3(SemState *sem_state) {</a>
<a name="ln115">  return Status::OK();</a>
<a name="ln116">}</a>
<a name="ln117"> </a>
<a name="ln118">CHECKED_STATUS PTExpr::CheckExpectedTypeCompatibility(SemContext *sem_context) {</a>
<a name="ln119">  CHECK(has_valid_internal_type() &amp;&amp; has_valid_ql_type_id());</a>
<a name="ln120"> </a>
<a name="ln121">  // Check if RHS support counter update.</a>
<a name="ln122">  if (sem_context-&gt;processing_set_clause() &amp;&amp;</a>
<a name="ln123">      sem_context-&gt;lhs_col() != nullptr &amp;&amp;</a>
<a name="ln124">      sem_context-&gt;lhs_col()-&gt;is_counter()) {</a>
<a name="ln125">    RETURN_NOT_OK(this-&gt;CheckCounterUpdateSupport(sem_context));</a>
<a name="ln126">  }</a>
<a name="ln127"> </a>
<a name="ln128">  // Check if RHS is convertible to LHS.</a>
<a name="ln129">  if (!sem_context-&gt;expr_expected_ql_type()-&gt;IsUnknown()) {</a>
<a name="ln130">    if (!sem_context-&gt;IsConvertible(sem_context-&gt;expr_expected_ql_type(), ql_type_)) {</a>
<a name="ln131">      return sem_context-&gt;Error(this, ErrorCode::DATATYPE_MISMATCH);</a>
<a name="ln132">    }</a>
<a name="ln133">  }</a>
<a name="ln134"> </a>
<a name="ln135">  // Resolve internal type.</a>
<a name="ln136">  const InternalType expected_itype = sem_context-&gt;expr_expected_internal_type();</a>
<a name="ln137">  if (expected_itype == InternalType::VALUE_NOT_SET) {</a>
<a name="ln138">    expected_internal_type_ = internal_type_;</a>
<a name="ln139">  } else {</a>
<a name="ln140">    expected_internal_type_ = expected_itype;</a>
<a name="ln141">  }</a>
<a name="ln142">  return Status::OK();</a>
<a name="ln143">}</a>
<a name="ln144"> </a>
<a name="ln145">//--------------------------------------------------------------------------------------------------</a>
<a name="ln146">CHECKED_STATUS PTExpr::CheckInequalityOperands(SemContext *sem_context,</a>
<a name="ln147">                                               PTExpr::SharedPtr lhs,</a>
<a name="ln148">                                               PTExpr::SharedPtr rhs) {</a>
<a name="ln149">  if (!sem_context-&gt;IsComparable(lhs-&gt;ql_type_id(), rhs-&gt;ql_type_id())) {</a>
<a name="ln150">    return sem_context-&gt;Error(this, &quot;Cannot compare values of these datatypes&quot;,</a>
<a name="ln151">                              ErrorCode::INCOMPARABLE_DATATYPES);</a>
<a name="ln152">  }</a>
<a name="ln153">  return Status::OK();</a>
<a name="ln154">}</a>
<a name="ln155"> </a>
<a name="ln156">CHECKED_STATUS PTExpr::CheckEqualityOperands(SemContext *sem_context,</a>
<a name="ln157">                                             PTExpr::SharedPtr lhs,</a>
<a name="ln158">                                             PTExpr::SharedPtr rhs) {</a>
<a name="ln159">  if (QLType::IsNull(lhs-&gt;ql_type_id()) || QLType::IsNull(rhs-&gt;ql_type_id())) {</a>
<a name="ln160">    return Status::OK();</a>
<a name="ln161">  } else {</a>
<a name="ln162">    return CheckInequalityOperands(sem_context, lhs, rhs);</a>
<a name="ln163">  }</a>
<a name="ln164">}</a>
<a name="ln165"> </a>
<a name="ln166"> </a>
<a name="ln167">CHECKED_STATUS PTExpr::CheckLhsExpr(SemContext *sem_context) {</a>
<a name="ln168">  if (op_ != ExprOperator::kRef &amp;&amp; op_ != ExprOperator::kBcall) {</a>
<a name="ln169">    return sem_context-&gt;Error(this,</a>
<a name="ln170">                              &quot;Only column refs and builtin calls are allowed for left hand value&quot;,</a>
<a name="ln171">                              ErrorCode::CQL_STATEMENT_INVALID);</a>
<a name="ln172">  }</a>
<a name="ln173">  return Status::OK();</a>
<a name="ln174">}</a>
<a name="ln175"> </a>
<a name="ln176">CHECKED_STATUS PTExpr::CheckRhsExpr(SemContext *sem_context) {</a>
<a name="ln177">  // Check for limitation in QL (Not all expressions are acceptable).</a>
<a name="ln178">  switch (op_) {</a>
<a name="ln179">    case ExprOperator::kRef:</a>
<a name="ln180">      // Only accept column references where they are explicitly allowed.</a>
<a name="ln181">      if (sem_context-&gt;sem_state() == nullptr ||</a>
<a name="ln182">          !sem_context-&gt;allowing_column_refs()) {</a>
<a name="ln183">        return sem_context-&gt;Error(this,</a>
<a name="ln184">                                  &quot;Column references are not allowed in this context&quot;,</a>
<a name="ln185">                                  ErrorCode::CQL_STATEMENT_INVALID);</a>
<a name="ln186">      }</a>
<a name="ln187">      FALLTHROUGH_INTENDED;</a>
<a name="ln188">    case ExprOperator::kConst: FALLTHROUGH_INTENDED;</a>
<a name="ln189">    case ExprOperator::kCollection: FALLTHROUGH_INTENDED;</a>
<a name="ln190">    case ExprOperator::kUMinus: FALLTHROUGH_INTENDED;</a>
<a name="ln191">    case ExprOperator::kBindVar: FALLTHROUGH_INTENDED;</a>
<a name="ln192">    case ExprOperator::kJsonOperatorRef: FALLTHROUGH_INTENDED;</a>
<a name="ln193">    case ExprOperator::kBcall:</a>
<a name="ln194">      break;</a>
<a name="ln195">    default:</a>
<a name="ln196">      return sem_context-&gt;Error(this, &quot;Operator not allowed as right hand value&quot;,</a>
<a name="ln197">                                ErrorCode::CQL_STATEMENT_INVALID);</a>
<a name="ln198">  }</a>
<a name="ln199"> </a>
<a name="ln200">  return Status::OK();</a>
<a name="ln201">}</a>
<a name="ln202"> </a>
<a name="ln203">CHECKED_STATUS PTExpr::CheckCounterUpdateSupport(SemContext *sem_context) const {</a>
<a name="ln204">  return sem_context-&gt;Error(this, ErrorCode::INVALID_COUNTING_EXPR);</a>
<a name="ln205">}</a>
<a name="ln206"> </a>
<a name="ln207">PTExpr::SharedPtr PTExpr::CreateConst(MemoryContext *memctx,</a>
<a name="ln208">                                      YBLocation::SharedPtr loc,</a>
<a name="ln209">                                      PTBaseType::SharedPtr data_type) {</a>
<a name="ln210">  switch(data_type-&gt;ql_type()-&gt;main()) {</a>
<a name="ln211">    case DataType::DOUBLE:</a>
<a name="ln212">      return PTConstDouble::MakeShared(memctx, loc, 0);</a>
<a name="ln213">    case DataType::FLOAT:</a>
<a name="ln214">      return PTConstFloat::MakeShared(memctx, loc, 0);</a>
<a name="ln215">    case DataType::INT16:</a>
<a name="ln216">      return PTConstInt16::MakeShared(memctx, loc, 0);</a>
<a name="ln217">    case DataType::INT32:</a>
<a name="ln218">      return PTConstInt32::MakeShared(memctx, loc, 0);</a>
<a name="ln219">    case DataType::INT64:</a>
<a name="ln220">      return PTConstInt::MakeShared(memctx, loc, 0);</a>
<a name="ln221">    case DataType::STRING:</a>
<a name="ln222">      return PTConstText::MakeShared(memctx, loc, MCMakeShared&lt;MCString&gt;(memctx, &quot;&quot;));</a>
<a name="ln223">    case DataType::TIMESTAMP:</a>
<a name="ln224">      return PTConstTimestamp::MakeShared(memctx, loc, 0);</a>
<a name="ln225">    case DataType::DATE:</a>
<a name="ln226">      return PTConstDate::MakeShared(memctx, loc, 0);</a>
<a name="ln227">    case DataType::DECIMAL:</a>
<a name="ln228">      return PTConstDecimal::MakeShared(memctx, loc, MCMakeShared&lt;MCString&gt;(memctx));</a>
<a name="ln229">    default:</a>
<a name="ln230">      LOG(WARNING) &lt;&lt; &quot;Unexpected QL type: &quot; &lt;&lt; data_type-&gt;ql_type()-&gt;ToString();</a>
<a name="ln231">      return nullptr;</a>
<a name="ln232">  }</a>
<a name="ln233">}</a>
<a name="ln234"> </a>
<a name="ln235">//--------------------------------------------------------------------------------------------------</a>
<a name="ln236"> </a>
<a name="ln237">PTLiteralString::PTLiteralString(MCSharedPtr&lt;MCString&gt; value)</a>
<a name="ln238">    : PTLiteral&lt;MCSharedPtr&lt;MCString&gt;&gt;(value) {</a>
<a name="ln239">}</a>
<a name="ln240"> </a>
<a name="ln241">PTLiteralString::~PTLiteralString() {</a>
<a name="ln242">}</a>
<a name="ln243"> </a>
<a name="ln244">CHECKED_STATUS PTLiteralString::ToInt64(int64_t *value, bool negate) const {</a>
<a name="ln245">  auto temp = negate ? CheckedStoll(string(&quot;-&quot;) + value_-&gt;c_str())</a>
<a name="ln246">              : CheckedStoll(*value_);</a>
<a name="ln247">  RETURN_NOT_OK(temp);</a>
<a name="ln248">  *value = *temp;</a>
<a name="ln249">  return Status::OK();</a>
<a name="ln250">}</a>
<a name="ln251"> </a>
<a name="ln252">CHECKED_STATUS PTLiteralString::ToDouble(long double *value, bool negate) const {</a>
<a name="ln253">  auto temp = CheckedStold(*value_);</a>
<a name="ln254">  RETURN_NOT_OK(temp);</a>
<a name="ln255">  *value = negate ? -*temp : *temp;</a>
<a name="ln256">  return Status::OK();</a>
<a name="ln257">}</a>
<a name="ln258"> </a>
<a name="ln259">CHECKED_STATUS PTLiteralString::ToDecimal(util::Decimal *value, bool negate) const {</a>
<a name="ln260">  if (negate) {</a>
<a name="ln261">    return value-&gt;FromString(string(&quot;-&quot;) + value_-&gt;c_str());</a>
<a name="ln262">  } else {</a>
<a name="ln263">    return value-&gt;FromString(value_-&gt;c_str());</a>
<a name="ln264">  }</a>
<a name="ln265">}</a>
<a name="ln266"> </a>
<a name="ln267">CHECKED_STATUS PTLiteralString::ToDecimal(string *value, bool negate) const {</a>
<a name="ln268">  util::Decimal d;</a>
<a name="ln269">  if (negate) {</a>
<a name="ln270">    RETURN_NOT_OK(d.FromString(string(&quot;-&quot;) + value_-&gt;c_str()));</a>
<a name="ln271">  } else {</a>
<a name="ln272">    RETURN_NOT_OK(d.FromString(value_-&gt;c_str()));</a>
<a name="ln273">  }</a>
<a name="ln274">  *value = d.EncodeToComparable();</a>
<a name="ln275">  return Status::OK();</a>
<a name="ln276">}</a>
<a name="ln277"> </a>
<a name="ln278">CHECKED_STATUS PTLiteralString::ToVarInt(string *value, bool negate) const {</a>
<a name="ln279">  util::VarInt v;</a>
<a name="ln280">  if (negate) {</a>
<a name="ln281">    RETURN_NOT_OK(v.FromString(string(&quot;-&quot;) + value_-&gt;c_str()));</a>
<a name="ln282">  } else {</a>
<a name="ln283">    RETURN_NOT_OK(v.FromString(value_-&gt;c_str()));</a>
<a name="ln284">  }</a>
<a name="ln285">  *value = v.EncodeToComparable();</a>
<a name="ln286">  return Status::OK();</a>
<a name="ln287">}</a>
<a name="ln288"> </a>
<a name="ln289">std::string PTLiteralString::ToString() const {</a>
<a name="ln290">  return string(value_-&gt;c_str());</a>
<a name="ln291">}</a>
<a name="ln292"> </a>
<a name="ln293">CHECKED_STATUS PTLiteralString::ToString(string *value) const {</a>
<a name="ln294">  *value = value_-&gt;c_str();</a>
<a name="ln295">  return Status::OK();</a>
<a name="ln296">}</a>
<a name="ln297"> </a>
<a name="ln298">CHECKED_STATUS PTLiteralString::ToTimestamp(int64_t *value) const {</a>
<a name="ln299">  *value = VERIFY_RESULT(DateTime::TimestampFromString(value_-&gt;c_str())).ToInt64();</a>
<a name="ln300">  return Status::OK();</a>
<a name="ln301">}</a>
<a name="ln302"> </a>
<a name="ln303">CHECKED_STATUS PTLiteralString::ToDate(uint32_t *value) const {</a>
<a name="ln304">  *value = VERIFY_RESULT(DateTime::DateFromString(value_-&gt;c_str()));</a>
<a name="ln305">  return Status::OK();</a>
<a name="ln306">}</a>
<a name="ln307"> </a>
<a name="ln308">CHECKED_STATUS PTLiteralString::ToTime(int64_t *value) const {</a>
<a name="ln309">  *value = VERIFY_RESULT(DateTime::TimeFromString(value_-&gt;c_str()));</a>
<a name="ln310">  return Status::OK();</a>
<a name="ln311">}</a>
<a name="ln312"> </a>
<a name="ln313">CHECKED_STATUS PTLiteralString::ToInetaddress(InetAddress *value) const {</a>
<a name="ln314">  *value = InetAddress(VERIFY_RESULT(HostToAddress(value_-&gt;c_str())));</a>
<a name="ln315">  return Status::OK();</a>
<a name="ln316">}</a>
<a name="ln317"> </a>
<a name="ln318">//--------------------------------------------------------------------------------------------------</a>
<a name="ln319">// Collections.</a>
<a name="ln320"> </a>
<a name="ln321">CHECKED_STATUS PTCollectionExpr::InitializeUDTValues(const QLType::SharedPtr&amp; expected_type,</a>
<a name="ln322">                                                     ProcessContextBase* process_context) {</a>
<a name="ln323">  SCHECK(expected_type-&gt;IsUserDefined(), Corruption, &quot;Expected type should be UDT&quot;);</a>
<a name="ln324">  SCHECK_EQ(keys_.size(), values_.size(), Corruption,</a>
<a name="ln325">            &quot;Expected keys and values to be of the same size&quot;);</a>
<a name="ln326"> </a>
<a name="ln327">  udtype_field_values_.resize(expected_type-&gt;udtype_field_names().size());</a>
<a name="ln328">  // Each literal key/value pair must correspond to a field name/type pair from the UDT</a>
<a name="ln329">  auto values_it = values_.begin();</a>
<a name="ln330">  for (const auto&amp; key : keys_) {</a>
<a name="ln331">    // All keys must be field refs</a>
<a name="ln332"> </a>
<a name="ln333">    // TODO (mihnea) Consider unifying handling of field references (for user-defined types) and</a>
<a name="ln334">    // column references (for tables) to simplify this path.</a>
<a name="ln335">    if (key-&gt;opcode() != TreeNodeOpcode::kPTRef) {</a>
<a name="ln336">      return process_context-&gt;Error(this,</a>
<a name="ln337">                                    &quot;Field names for user-defined types must be field reference&quot;,</a>
<a name="ln338">                                    ErrorCode::INVALID_ARGUMENTS);</a>
<a name="ln339">    }</a>
<a name="ln340">    PTRef* field_ref = down_cast&lt;PTRef*&gt;(key.get());</a>
<a name="ln341">    if (!field_ref-&gt;name()-&gt;IsSimpleName()) {</a>
<a name="ln342">      return process_context-&gt;Error(this,</a>
<a name="ln343">                                    &quot;Qualified names not allowed for fields of user-defined types&quot;,</a>
<a name="ln344">                                    ErrorCode::INVALID_ARGUMENTS);</a>
<a name="ln345">    }</a>
<a name="ln346">    string field_name(field_ref-&gt;name()-&gt;last_name().c_str());</a>
<a name="ln347"> </a>
<a name="ln348">    // All keys must be existing field names from the UDT</a>
<a name="ln349">    int field_idx = expected_type-&gt;GetUDTypeFieldIdxByName(field_name);</a>
<a name="ln350">    if (field_idx &lt; 0) {</a>
<a name="ln351">      return process_context-&gt;Error(this, &quot;Invalid field name found for user-defined type instance&quot;,</a>
<a name="ln352">                                    ErrorCode::INVALID_ARGUMENTS);</a>
<a name="ln353">    }</a>
<a name="ln354"> </a>
<a name="ln355">    // Setting the corresponding field value</a>
<a name="ln356">    udtype_field_values_[field_idx] = *values_it;</a>
<a name="ln357">    values_it++;</a>
<a name="ln358">  }</a>
<a name="ln359">  return Status::OK();</a>
<a name="ln360">}</a>
<a name="ln361"> </a>
<a name="ln362">CHECKED_STATUS PTCollectionExpr::Analyze(SemContext *sem_context) {</a>
<a name="ln363">  // Before traversing the expression, check if this whole expression is actually a column.</a>
<a name="ln364">  if (CheckIndexColumn(sem_context)) {</a>
<a name="ln365">    return Status::OK();</a>
<a name="ln366">  }</a>
<a name="ln367"> </a>
<a name="ln368">  RETURN_NOT_OK(CheckOperator(sem_context));</a>
<a name="ln369">  const shared_ptr&lt;QLType&gt;&amp; expected_type = sem_context-&gt;expr_expected_ql_type();</a>
<a name="ln370"> </a>
<a name="ln371">  // If no expected type is given, use type inferred during parsing</a>
<a name="ln372">  if (expected_type-&gt;main() == DataType::UNKNOWN_DATA) {</a>
<a name="ln373">    return CheckExpectedTypeCompatibility(sem_context);</a>
<a name="ln374">  }</a>
<a name="ln375"> </a>
<a name="ln376">  // Ensuring expected type is compatible with parsing/literal type.</a>
<a name="ln377">  auto conversion_mode = QLType::GetConversionMode(expected_type-&gt;main(), ql_type_-&gt;main());</a>
<a name="ln378">  if (conversion_mode &gt; QLType::ConversionMode::kFurtherCheck) {</a>
<a name="ln379">    return sem_context-&gt;Error(this, ErrorCode::DATATYPE_MISMATCH);</a>
<a name="ln380">  }</a>
<a name="ln381"> </a>
<a name="ln382">  const MCSharedPtr&lt;MCString&gt;&amp; bindvar_name = sem_context-&gt;bindvar_name();</a>
<a name="ln383"> </a>
<a name="ln384">  // Checking type parameters.</a>
<a name="ln385">  switch (expected_type-&gt;main()) {</a>
<a name="ln386">    case MAP: {</a>
<a name="ln387">      if (ql_type_-&gt;main() == SET &amp;&amp; values_.size() &gt; 0) {</a>
<a name="ln388">        return sem_context-&gt;Error(this, ErrorCode::DATATYPE_MISMATCH);</a>
<a name="ln389">      }</a>
<a name="ln390">      SemState sem_state(sem_context);</a>
<a name="ln391"> </a>
<a name="ln392">      const shared_ptr&lt;QLType&gt;&amp; key_type = expected_type-&gt;param_type(0);</a>
<a name="ln393">      sem_state.SetExprState(key_type, YBColumnSchema::ToInternalDataType(key_type), bindvar_name);</a>
<a name="ln394">      for (auto&amp; key : keys_) {</a>
<a name="ln395">        RETURN_NOT_OK(key-&gt;Analyze(sem_context));</a>
<a name="ln396">      }</a>
<a name="ln397"> </a>
<a name="ln398">      const shared_ptr&lt;QLType&gt;&amp; val_type = expected_type-&gt;param_type(1);</a>
<a name="ln399">      sem_state.SetExprState(val_type, YBColumnSchema::ToInternalDataType(val_type), bindvar_name);</a>
<a name="ln400">      for (auto&amp; value : values_) {</a>
<a name="ln401">        RETURN_NOT_OK(value-&gt;Analyze(sem_context));</a>
<a name="ln402">      }</a>
<a name="ln403"> </a>
<a name="ln404">      sem_state.ResetContextState();</a>
<a name="ln405">      break;</a>
<a name="ln406">    }</a>
<a name="ln407">    case SET: {</a>
<a name="ln408">      SemState sem_state(sem_context);</a>
<a name="ln409">      const shared_ptr&lt;QLType&gt;&amp; val_type = expected_type-&gt;param_type(0);</a>
<a name="ln410">      sem_state.SetExprState(val_type, YBColumnSchema::ToInternalDataType(val_type), bindvar_name);</a>
<a name="ln411">      for (auto&amp; elem : values_) {</a>
<a name="ln412">        RETURN_NOT_OK(elem-&gt;Analyze(sem_context));</a>
<a name="ln413">      }</a>
<a name="ln414">      sem_state.ResetContextState();</a>
<a name="ln415">      break;</a>
<a name="ln416">    }</a>
<a name="ln417"> </a>
<a name="ln418">    case LIST: {</a>
<a name="ln419">      SemState sem_state(sem_context);</a>
<a name="ln420">      const shared_ptr&lt;QLType&gt;&amp; val_type = expected_type-&gt;param_type(0);</a>
<a name="ln421">      sem_state.SetExprState(val_type, YBColumnSchema::ToInternalDataType(val_type), bindvar_name);</a>
<a name="ln422">      for (auto&amp; elem : values_) {</a>
<a name="ln423">        RETURN_NOT_OK(elem-&gt;Analyze(sem_context));</a>
<a name="ln424">      }</a>
<a name="ln425">      sem_state.ResetContextState();</a>
<a name="ln426">      break;</a>
<a name="ln427">    }</a>
<a name="ln428"> </a>
<a name="ln429">    case USER_DEFINED_TYPE: {</a>
<a name="ln430">      SemState sem_state(sem_context);</a>
<a name="ln431">      RETURN_NOT_OK(InitializeUDTValues(expected_type, sem_context));</a>
<a name="ln432">      for (int i = 0; i &lt; udtype_field_values_.size(); i++) {</a>
<a name="ln433">        if (!udtype_field_values_[i]) {</a>
<a name="ln434">          // Skip missing values</a>
<a name="ln435">          continue;</a>
<a name="ln436">        }</a>
<a name="ln437">        // Each value should have the corresponding type from the UDT</a>
<a name="ln438">        const auto&amp; param_type = expected_type-&gt;param_type(i);</a>
<a name="ln439">        sem_state.SetExprState(param_type,</a>
<a name="ln440">                               YBColumnSchema::ToInternalDataType(param_type),</a>
<a name="ln441">                               bindvar_name);</a>
<a name="ln442">        RETURN_NOT_OK(udtype_field_values_[i]-&gt;Analyze(sem_context));</a>
<a name="ln443">      }</a>
<a name="ln444">      sem_state.ResetContextState();</a>
<a name="ln445">      break;</a>
<a name="ln446">    }</a>
<a name="ln447"> </a>
<a name="ln448">    case FROZEN: {</a>
<a name="ln449">      if (ql_type_-&gt;main() == FROZEN) {</a>
<a name="ln450">        // Already analyzed (e.g. for indexes), just check if type matches.</a>
<a name="ln451">        if (*ql_type_ != *expected_type) {</a>
<a name="ln452">          return sem_context-&gt;Error(this, ErrorCode::DATATYPE_MISMATCH);</a>
<a name="ln453">        }</a>
<a name="ln454">      } else {</a>
<a name="ln455">        SemState sem_state(sem_context);</a>
<a name="ln456">        sem_state.SetExprState(expected_type-&gt;param_type(0),</a>
<a name="ln457">                              YBColumnSchema::ToInternalDataType(expected_type-&gt;param_type(0)),</a>
<a name="ln458">                              bindvar_name);</a>
<a name="ln459">        RETURN_NOT_OK(Analyze(sem_context));</a>
<a name="ln460">        sem_state.ResetContextState();</a>
<a name="ln461">      }</a>
<a name="ln462">      break;</a>
<a name="ln463">    }</a>
<a name="ln464"> </a>
<a name="ln465">    case TUPLE:</a>
<a name="ln466">      return sem_context-&gt;Error(this, &quot;Tuple type not supported yet&quot;,</a>
<a name="ln467">                                ErrorCode::FEATURE_NOT_SUPPORTED);</a>
<a name="ln468"> </a>
<a name="ln469">    default:</a>
<a name="ln470">      return sem_context-&gt;Error(this, ErrorCode::DATATYPE_MISMATCH);</a>
<a name="ln471">  }</a>
<a name="ln472"> </a>
<a name="ln473">  // Assign correct datatype.</a>
<a name="ln474">  ql_type_ = expected_type;</a>
<a name="ln475">  internal_type_ = sem_context-&gt;expr_expected_internal_type();</a>
<a name="ln476"> </a>
<a name="ln477">  return Status::OK();</a>
<a name="ln478">}</a>
<a name="ln479"> </a>
<a name="ln480">//--------------------------------------------------------------------------------------------------</a>
<a name="ln481">// Logic expressions consist of the following operators.</a>
<a name="ln482">//   ExprOperator::kNot</a>
<a name="ln483">//   ExprOperator::kAND</a>
<a name="ln484">//   ExprOperator::kOR</a>
<a name="ln485">//   ExprOperator::kIsTrue</a>
<a name="ln486">//   ExprOperator::kIsFalse</a>
<a name="ln487"> </a>
<a name="ln488">CHECKED_STATUS PTLogicExpr::SetupSemStateForOp1(SemState *sem_state) {</a>
<a name="ln489">  // Expect &quot;bool&quot; datatype for logic expression.</a>
<a name="ln490">  sem_state-&gt;SetExprState(QLType::Create(BOOL), InternalType::kBoolValue);</a>
<a name="ln491"> </a>
<a name="ln492">  // Pass down the state variables for IF clause &quot;if_state&quot;.</a>
<a name="ln493">  sem_state-&gt;CopyPreviousIfState();</a>
<a name="ln494"> </a>
<a name="ln495">  // If this is OP_AND, we need to pass down the state variables for where clause &quot;where_state&quot;.</a>
<a name="ln496">  if (ql_op_ == QL_OP_AND) {</a>
<a name="ln497">    sem_state-&gt;CopyPreviousWhereState();</a>
<a name="ln498">  }</a>
<a name="ln499">  return Status::OK();</a>
<a name="ln500">}</a>
<a name="ln501"> </a>
<a name="ln502">CHECKED_STATUS PTLogicExpr::SetupSemStateForOp2(SemState *sem_state) {</a>
<a name="ln503">  // Expect &quot;bool&quot; datatype for logic expression.</a>
<a name="ln504">  sem_state-&gt;SetExprState(QLType::Create(BOOL), InternalType::kBoolValue);</a>
<a name="ln505"> </a>
<a name="ln506">  // Pass down the state variables for IF clause &quot;if_state&quot;.</a>
<a name="ln507">  sem_state-&gt;CopyPreviousIfState();</a>
<a name="ln508"> </a>
<a name="ln509">  // If this is OP_AND, we need to pass down the state variables for where clause &quot;where_state&quot;.</a>
<a name="ln510">  if (ql_op_ == QL_OP_AND) {</a>
<a name="ln511">    sem_state-&gt;CopyPreviousWhereState();</a>
<a name="ln512">  }</a>
<a name="ln513">  return Status::OK();</a>
<a name="ln514">}</a>
<a name="ln515"> </a>
<a name="ln516">CHECKED_STATUS PTLogicExpr::AnalyzeOperator(SemContext *sem_context,</a>
<a name="ln517">                                            PTExpr::SharedPtr op1) {</a>
<a name="ln518">  switch (ql_op_) {</a>
<a name="ln519">    case QL_OP_NOT:</a>
<a name="ln520">      if (op1-&gt;ql_type_id() != BOOL) {</a>
<a name="ln521">        return sem_context-&gt;Error(this, &quot;Only boolean value is allowed in this context&quot;,</a>
<a name="ln522">                                  ErrorCode::INVALID_DATATYPE);</a>
<a name="ln523">      }</a>
<a name="ln524">      internal_type_ = yb::InternalType::kBoolValue;</a>
<a name="ln525">      break;</a>
<a name="ln526"> </a>
<a name="ln527">    case QL_OP_IS_TRUE: FALLTHROUGH_INTENDED;</a>
<a name="ln528">    case QL_OP_IS_FALSE:</a>
<a name="ln529">      return sem_context-&gt;Error(this, &quot;Operator not supported yet&quot;,</a>
<a name="ln530">                                ErrorCode::CQL_STATEMENT_INVALID);</a>
<a name="ln531">    default:</a>
<a name="ln532">      LOG(FATAL) &lt;&lt; &quot;Invalid operator&quot;;</a>
<a name="ln533">  }</a>
<a name="ln534">  return Status::OK();</a>
<a name="ln535">}</a>
<a name="ln536"> </a>
<a name="ln537">CHECKED_STATUS PTLogicExpr::AnalyzeOperator(SemContext *sem_context,</a>
<a name="ln538">                                            PTExpr::SharedPtr op1,</a>
<a name="ln539">                                            PTExpr::SharedPtr op2) {</a>
<a name="ln540">  // Verify the operators.</a>
<a name="ln541">  DCHECK(ql_op_ == QL_OP_AND || ql_op_ == QL_OP_OR);</a>
<a name="ln542"> </a>
<a name="ln543">  // &quot;op1&quot; and &quot;op2&quot; must have been analyzed before getting here</a>
<a name="ln544">  if (op1-&gt;ql_type_id() != BOOL) {</a>
<a name="ln545">    return sem_context-&gt;Error(op1, &quot;Only boolean value is allowed in this context&quot;,</a>
<a name="ln546">                              ErrorCode::INVALID_DATATYPE);</a>
<a name="ln547">  }</a>
<a name="ln548">  if (op2-&gt;ql_type_id() != BOOL) {</a>
<a name="ln549">    return sem_context-&gt;Error(op2, &quot;Only boolean value is allowed in this context&quot;,</a>
<a name="ln550">                              ErrorCode::INVALID_DATATYPE);</a>
<a name="ln551">  }</a>
<a name="ln552"> </a>
<a name="ln553">  internal_type_ = yb::InternalType::kBoolValue;</a>
<a name="ln554">  return Status::OK();</a>
<a name="ln555">}</a>
<a name="ln556"> </a>
<a name="ln557">//--------------------------------------------------------------------------------------------------</a>
<a name="ln558">// Relations expressions: ==, !=, &gt;, &gt;=, between, ...</a>
<a name="ln559"> </a>
<a name="ln560">CHECKED_STATUS PTRelationExpr::SetupSemStateForOp1(SemState *sem_state) {</a>
<a name="ln561">  // Pass down the state variables for IF clause &quot;if_state&quot;.</a>
<a name="ln562">  sem_state-&gt;CopyPreviousIfState();</a>
<a name="ln563"> </a>
<a name="ln564">  // passing down where state</a>
<a name="ln565">  sem_state-&gt;CopyPreviousWhereState();</a>
<a name="ln566">  sem_state-&gt;set_allowing_column_refs(true);</a>
<a name="ln567">  // No expectation for operand 1. All types are accepted.</a>
<a name="ln568">  return Status::OK();</a>
<a name="ln569">}</a>
<a name="ln570"> </a>
<a name="ln571">CHECKED_STATUS PTRelationExpr::SetupSemStateForOp2(SemState *sem_state) {</a>
<a name="ln572">  // The state of operand2 is dependent on operand1.</a>
<a name="ln573">  PTExpr::SharedPtr operand1 = op1();</a>
<a name="ln574">  DCHECK_NOTNULL(operand1.get());</a>
<a name="ln575">  sem_state-&gt;set_allowing_column_refs(false);</a>
<a name="ln576"> </a>
<a name="ln577">  switch (ql_op_) {</a>
<a name="ln578">    case QL_OP_EQUAL: FALLTHROUGH_INTENDED;</a>
<a name="ln579">    case QL_OP_LESS_THAN: FALLTHROUGH_INTENDED;</a>
<a name="ln580">    case QL_OP_LESS_THAN_EQUAL: FALLTHROUGH_INTENDED;</a>
<a name="ln581">    case QL_OP_GREATER_THAN: FALLTHROUGH_INTENDED;</a>
<a name="ln582">    case QL_OP_GREATER_THAN_EQUAL: FALLTHROUGH_INTENDED;</a>
<a name="ln583">    case QL_OP_NOT_EQUAL: FALLTHROUGH_INTENDED;</a>
<a name="ln584">    case QL_OP_EXISTS: FALLTHROUGH_INTENDED;</a>
<a name="ln585">    case QL_OP_NOT_EXISTS: FALLTHROUGH_INTENDED;</a>
<a name="ln586">    case QL_OP_BETWEEN: FALLTHROUGH_INTENDED;</a>
<a name="ln587">    case QL_OP_NOT_BETWEEN: {</a>
<a name="ln588">      // TODO(neil) Indexing processing should be redesigned such that when processing a statement</a>
<a name="ln589">      // against an INDEX table, most of these semantic processing shouldn't be done again as they</a>
<a name="ln590">      // were already done once again the actual table.</a>
<a name="ln591"> </a>
<a name="ln592">      // Setup for expression column.</a>
<a name="ln593">      if (operand1-&gt;index_desc() != nullptr) {</a>
<a name="ln594">        // Operand1 is a index column.</a>
<a name="ln595">        sem_state-&gt;SetExprState(operand1-&gt;ql_type(),</a>
<a name="ln596">                                operand1-&gt;internal_type(),</a>
<a name="ln597">                                operand1-&gt;index_name(),</a>
<a name="ln598">                                operand1-&gt;index_desc());</a>
<a name="ln599">        break;</a>
<a name="ln600">      }</a>
<a name="ln601"> </a>
<a name="ln602">      // Setup for table column.</a>
<a name="ln603">      if (operand1-&gt;expr_op() == ExprOperator::kRef) {</a>
<a name="ln604">        const PTRef *ref = static_cast&lt;const PTRef *&gt;(operand1.get());</a>
<a name="ln605">        sem_state-&gt;SetExprState(ref-&gt;ql_type(),</a>
<a name="ln606">                                ref-&gt;internal_type(),</a>
<a name="ln607">                                ref-&gt;bindvar_name(),</a>
<a name="ln608">                                ref-&gt;desc());</a>
<a name="ln609">        break;</a>
<a name="ln610">      }</a>
<a name="ln611"> </a>
<a name="ln612">      // Setup for other expression.</a>
<a name="ln613">      sem_state-&gt;SetExprState(operand1-&gt;ql_type(), operand1-&gt;internal_type());</a>
<a name="ln614">      switch (operand1-&gt;expr_op()) {</a>
<a name="ln615">        case ExprOperator::kBcall: {</a>
<a name="ln616">          PTBcall *bcall = static_cast&lt;PTBcall *&gt;(operand1.get());</a>
<a name="ln617">          DCHECK_NOTNULL(bcall-&gt;name().get());</a>
<a name="ln618">          if (strcmp(bcall-&gt;name()-&gt;c_str(), &quot;token&quot;) == 0) {</a>
<a name="ln619">            sem_state-&gt;set_bindvar_name(PTBindVar::token_bindvar_name());</a>
<a name="ln620">          }</a>
<a name="ln621">          if (strcmp(bcall-&gt;name()-&gt;c_str(), &quot;partition_hash&quot;) == 0) {</a>
<a name="ln622">            sem_state-&gt;set_bindvar_name(PTBindVar::partition_hash_bindvar_name());</a>
<a name="ln623">          }</a>
<a name="ln624">          break;</a>
<a name="ln625">        }</a>
<a name="ln626"> </a>
<a name="ln627">        case ExprOperator::kSubColRef: {</a>
<a name="ln628">          const PTSubscriptedColumn *ref = static_cast&lt;const PTSubscriptedColumn *&gt;(operand1.get());</a>
<a name="ln629">          if (ref-&gt;desc()) {</a>
<a name="ln630">            sem_state-&gt;set_bindvar_name(PTBindVar::coll_bindvar_name(ref-&gt;desc()-&gt;name()));</a>
<a name="ln631">          } else if (!sem_state-&gt;is_uncovered_index_select()) {</a>
<a name="ln632">            return STATUS(</a>
<a name="ln633">                QLError, &quot;Column doesn't exist&quot;, Slice(), QLError(ErrorCode::UNDEFINED_COLUMN));</a>
<a name="ln634">          } // else - this column is uncovered by the Index, skip checks and return OK.</a>
<a name="ln635">          break;</a>
<a name="ln636">        }</a>
<a name="ln637"> </a>
<a name="ln638">        case ExprOperator::kJsonOperatorRef: {</a>
<a name="ln639">          const PTJsonColumnWithOperators *ref =</a>
<a name="ln640">              static_cast&lt;const PTJsonColumnWithOperators*&gt;(operand1.get());</a>
<a name="ln641">          if (ref-&gt;desc()) {</a>
<a name="ln642">            sem_state-&gt;set_bindvar_name(PTBindVar::json_bindvar_name(ref-&gt;desc()-&gt;name()));</a>
<a name="ln643">          } else if (!sem_state-&gt;is_uncovered_index_select()) {</a>
<a name="ln644">            return STATUS(</a>
<a name="ln645">                QLError, &quot;Column doesn't exist&quot;, Slice(), QLError(ErrorCode::UNDEFINED_COLUMN));</a>
<a name="ln646">          } // else - this column is uncovered by the Index, skip checks and return OK.</a>
<a name="ln647">          break;</a>
<a name="ln648">        }</a>
<a name="ln649"> </a>
<a name="ln650">        default: {} // Use default bindvar name below.</a>
<a name="ln651">      }</a>
<a name="ln652"> </a>
<a name="ln653">      break;</a>
<a name="ln654">    }</a>
<a name="ln655"> </a>
<a name="ln656">    case QL_OP_IN: FALLTHROUGH_INTENDED;</a>
<a name="ln657">    case QL_OP_NOT_IN: {</a>
<a name="ln658">      auto ql_type = QLType::CreateTypeList(operand1-&gt;ql_type());</a>
<a name="ln659"> </a>
<a name="ln660">      if (operand1-&gt;index_desc() != nullptr) {</a>
<a name="ln661">        // Operand1 is a index column.</a>
<a name="ln662">        sem_state-&gt;SetExprState(operand1-&gt;ql_type(),</a>
<a name="ln663">                                operand1-&gt;internal_type(),</a>
<a name="ln664">                                operand1-&gt;index_name(),</a>
<a name="ln665">                                operand1-&gt;index_desc());</a>
<a name="ln666">      } else if (operand1-&gt;expr_op() == ExprOperator::kRef) {</a>
<a name="ln667">        const PTRef *ref = static_cast&lt;const PTRef *&gt;(operand1.get());</a>
<a name="ln668">        sem_state-&gt;SetExprState(ql_type,</a>
<a name="ln669">                                ref-&gt;internal_type(),</a>
<a name="ln670">                                ref-&gt;bindvar_name(),</a>
<a name="ln671">                                ref-&gt;desc());</a>
<a name="ln672">      } else {</a>
<a name="ln673">        sem_state-&gt;SetExprState(ql_type, operand1-&gt;internal_type());</a>
<a name="ln674">      }</a>
<a name="ln675">      break;</a>
<a name="ln676">    }</a>
<a name="ln677"> </a>
<a name="ln678">    default:</a>
<a name="ln679">      LOG(FATAL) &lt;&lt; &quot;Invalid operator&quot; &lt;&lt; int(ql_op_);</a>
<a name="ln680">  }</a>
<a name="ln681"> </a>
<a name="ln682">  if (!sem_state-&gt;bindvar_name()) {</a>
<a name="ln683">    sem_state-&gt;set_bindvar_name(PTBindVar::default_bindvar_name());</a>
<a name="ln684">  }</a>
<a name="ln685"> </a>
<a name="ln686">  return Status::OK();</a>
<a name="ln687">}</a>
<a name="ln688"> </a>
<a name="ln689">CHECKED_STATUS PTRelationExpr::SetupSemStateForOp3(SemState *sem_state) {</a>
<a name="ln690">  // The states of operand3 is dependent on operand1 in the same way as op2.</a>
<a name="ln691">  return SetupSemStateForOp2(sem_state);</a>
<a name="ln692">}</a>
<a name="ln693"> </a>
<a name="ln694">CHECKED_STATUS PTRelationExpr::AnalyzeOperator(SemContext *sem_context) {</a>
<a name="ln695">  switch (ql_op_) {</a>
<a name="ln696">    case QL_OP_EXISTS: FALLTHROUGH_INTENDED;</a>
<a name="ln697">    case QL_OP_NOT_EXISTS:</a>
<a name="ln698">      return Status::OK();</a>
<a name="ln699">    default:</a>
<a name="ln700">      LOG(FATAL) &lt;&lt; &quot;Invalid operator&quot;;</a>
<a name="ln701">  }</a>
<a name="ln702">  return Status::OK();</a>
<a name="ln703">}</a>
<a name="ln704"> </a>
<a name="ln705">CHECKED_STATUS PTRelationExpr::AnalyzeOperator(SemContext *sem_context,</a>
<a name="ln706">                                               PTExpr::SharedPtr op1) {</a>
<a name="ln707">  // &quot;op1&quot; must have been analyzed before getting here</a>
<a name="ln708">  switch (ql_op_) {</a>
<a name="ln709">    case QL_OP_IS_NULL: FALLTHROUGH_INTENDED;</a>
<a name="ln710">    case QL_OP_IS_NOT_NULL:</a>
<a name="ln711">      return sem_context-&gt;Error(this, &quot;Operator not supported yet&quot;,</a>
<a name="ln712">                                ErrorCode::CQL_STATEMENT_INVALID);</a>
<a name="ln713">    default:</a>
<a name="ln714">      LOG(FATAL) &lt;&lt; &quot;Invalid operator&quot; &lt;&lt; int(ql_op_);</a>
<a name="ln715">  }</a>
<a name="ln716"> </a>
<a name="ln717">  return Status::OK();</a>
<a name="ln718">}</a>
<a name="ln719"> </a>
<a name="ln720">CHECKED_STATUS PTRelationExpr::AnalyzeOperator(SemContext *sem_context,</a>
<a name="ln721">                                               PTExpr::SharedPtr op1,</a>
<a name="ln722">                                               PTExpr::SharedPtr op2) {</a>
<a name="ln723">  // &quot;op1&quot; and &quot;op2&quot; must have been analyzed before getting here</a>
<a name="ln724">  switch (ql_op_) {</a>
<a name="ln725">    case QL_OP_EQUAL:</a>
<a name="ln726">      RETURN_NOT_OK(op1-&gt;CheckLhsExpr(sem_context));</a>
<a name="ln727">      RETURN_NOT_OK(op2-&gt;CheckRhsExpr(sem_context));</a>
<a name="ln728">      RETURN_NOT_OK(CheckEqualityOperands(sem_context, op1, op2));</a>
<a name="ln729">      internal_type_ = yb::InternalType::kBoolValue;</a>
<a name="ln730">      break;</a>
<a name="ln731">    case QL_OP_LESS_THAN: FALLTHROUGH_INTENDED;</a>
<a name="ln732">    case QL_OP_GREATER_THAN: FALLTHROUGH_INTENDED;</a>
<a name="ln733">    case QL_OP_LESS_THAN_EQUAL: FALLTHROUGH_INTENDED;</a>
<a name="ln734">    case QL_OP_GREATER_THAN_EQUAL: FALLTHROUGH_INTENDED;</a>
<a name="ln735">    case QL_OP_NOT_EQUAL:</a>
<a name="ln736">      RETURN_NOT_OK(op1-&gt;CheckLhsExpr(sem_context));</a>
<a name="ln737">      RETURN_NOT_OK(op2-&gt;CheckRhsExpr(sem_context));</a>
<a name="ln738">      RETURN_NOT_OK(CheckInequalityOperands(sem_context, op1, op2));</a>
<a name="ln739">      internal_type_ = yb::InternalType::kBoolValue;</a>
<a name="ln740">      break;</a>
<a name="ln741"> </a>
<a name="ln742">    case QL_OP_IN:</a>
<a name="ln743">    case QL_OP_NOT_IN:</a>
<a name="ln744">      RETURN_NOT_OK(op1-&gt;CheckLhsExpr(sem_context));</a>
<a name="ln745">      RETURN_NOT_OK(op2-&gt;CheckRhsExpr(sem_context));</a>
<a name="ln746">      break;</a>
<a name="ln747"> </a>
<a name="ln748">    default:</a>
<a name="ln749">      return sem_context-&gt;Error(this, &quot;Operator not supported yet&quot;,</a>
<a name="ln750">                                ErrorCode::CQL_STATEMENT_INVALID);</a>
<a name="ln751">  }</a>
<a name="ln752"> </a>
<a name="ln753">  // Add filtering expressions in IF clause for indexing operations.</a>
<a name="ln754">  IfExprState *if_state = sem_context-&gt;if_state();</a>
<a name="ln755">  if (if_state != nullptr) {</a>
<a name="ln756">    if (op1-&gt;index_desc()) {</a>
<a name="ln757">      if_state-&gt;AddFilteringExpr(sem_context, this);</a>
<a name="ln758">    } else if (op1-&gt;expr_op() == ExprOperator::kRef) {</a>
<a name="ln759">      if_state-&gt;AddFilteringExpr(sem_context, this);</a>
<a name="ln760">    } else if (op1-&gt;expr_op() == ExprOperator::kSubColRef) {</a>
<a name="ln761">      if_state-&gt;AddFilteringExpr(sem_context, this);</a>
<a name="ln762">    } else if (op1-&gt;expr_op() == ExprOperator::kJsonOperatorRef) {</a>
<a name="ln763">      if_state-&gt;AddFilteringExpr(sem_context, this);</a>
<a name="ln764">    }</a>
<a name="ln765">  }</a>
<a name="ln766"> </a>
<a name="ln767">  WhereExprState *where_state = sem_context-&gt;where_state();</a>
<a name="ln768">  if (where_state != nullptr) {</a>
<a name="ln769">    // CheckLhsExpr already checks that this is either kRef or kBcall</a>
<a name="ln770">    DCHECK(op1-&gt;index_desc() != nullptr ||</a>
<a name="ln771">           op1-&gt;expr_op() == ExprOperator::kRef ||</a>
<a name="ln772">           op1-&gt;expr_op() == ExprOperator::kSubColRef ||</a>
<a name="ln773">           op1-&gt;expr_op() == ExprOperator::kJsonOperatorRef ||</a>
<a name="ln774">           op1-&gt;expr_op() == ExprOperator::kBcall);</a>
<a name="ln775">    if (op1-&gt;index_desc()) {</a>
<a name="ln776">      return where_state-&gt;AnalyzeColumnOp(sem_context, this, op1-&gt;index_desc(), op2);</a>
<a name="ln777">    } else if (op1-&gt;expr_op() == ExprOperator::kRef) {</a>
<a name="ln778">      const PTRef *ref = static_cast&lt;const PTRef *&gt;(op1.get());</a>
<a name="ln779">      return where_state-&gt;AnalyzeColumnOp(sem_context, this, ref-&gt;desc(), op2);</a>
<a name="ln780">    } else if (op1-&gt;expr_op() == ExprOperator::kSubColRef) {</a>
<a name="ln781">      const PTSubscriptedColumn *ref = static_cast&lt;const PTSubscriptedColumn *&gt;(op1.get());</a>
<a name="ln782">      return where_state-&gt;AnalyzeColumnOp(sem_context, this, ref-&gt;desc(), op2, ref-&gt;args());</a>
<a name="ln783">    } else if (op1-&gt;expr_op() == ExprOperator::kJsonOperatorRef) {</a>
<a name="ln784">      const PTJsonColumnWithOperators *ref =</a>
<a name="ln785">          static_cast&lt;const PTJsonColumnWithOperators*&gt;(op1.get());</a>
<a name="ln786"> </a>
<a name="ln787">      return where_state-&gt;AnalyzeColumnOp(sem_context, this, ref-&gt;desc(), op2, ref-&gt;operators());</a>
<a name="ln788">    } else if (op1-&gt;expr_op() == ExprOperator::kBcall) {</a>
<a name="ln789">      const PTBcall *bcall = static_cast&lt;const PTBcall *&gt;(op1.get());</a>
<a name="ln790">      if (strcmp(bcall-&gt;name()-&gt;c_str(), &quot;token&quot;) == 0 ||</a>
<a name="ln791">          strcmp(bcall-&gt;name()-&gt;c_str(), &quot;partition_hash&quot;) == 0) {</a>
<a name="ln792">        const PTToken *token = static_cast&lt;const PTToken *&gt;(bcall);</a>
<a name="ln793">        if (token-&gt;is_partition_key_ref()) {</a>
<a name="ln794">          return where_state-&gt;AnalyzePartitionKeyOp(sem_context, this, op2);</a>
<a name="ln795">        } else {</a>
<a name="ln796">          return sem_context-&gt;Error(this,</a>
<a name="ln797">                                    &quot;token/partition_hash calls need to reference partition key&quot;,</a>
<a name="ln798">                                    ErrorCode::FEATURE_NOT_SUPPORTED);</a>
<a name="ln799">        }</a>
<a name="ln800">      } else if (strcmp(bcall-&gt;name()-&gt;c_str(), &quot;ttl&quot;) == 0 ||</a>
<a name="ln801">                 strcmp(bcall-&gt;name()-&gt;c_str(), &quot;writetime&quot;) == 0 ||</a>
<a name="ln802">                 strcmp(bcall-&gt;name()-&gt;c_str(), &quot;cql_cast&quot;) == 0) {</a>
<a name="ln803">        PTBcall::SharedPtr bcall_shared = std::make_shared&lt;PTBcall&gt;(*bcall);</a>
<a name="ln804">        return where_state-&gt;AnalyzeColumnFunction(sem_context, this, op2, bcall_shared);</a>
<a name="ln805">      } else {</a>
<a name="ln806">        return sem_context-&gt;Error(loc(), &quot;Builtin call not allowed in where clause&quot;,</a>
<a name="ln807">                                  ErrorCode::CQL_STATEMENT_INVALID);</a>
<a name="ln808">      }</a>
<a name="ln809">    }</a>
<a name="ln810">  }</a>
<a name="ln811"> </a>
<a name="ln812">  return Status::OK();</a>
<a name="ln813">}</a>
<a name="ln814"> </a>
<a name="ln815">CHECKED_STATUS PTRelationExpr::AnalyzeOperator(SemContext *sem_context,</a>
<a name="ln816">                                               PTExpr::SharedPtr op1,</a>
<a name="ln817">                                               PTExpr::SharedPtr op2,</a>
<a name="ln818">                                               PTExpr::SharedPtr op3) {</a>
<a name="ln819">  // &quot;op1&quot;, &quot;op2&quot;, and &quot;op3&quot; must have been analyzed before getting here</a>
<a name="ln820">  switch (ql_op_) {</a>
<a name="ln821">    case QL_OP_BETWEEN: FALLTHROUGH_INTENDED;</a>
<a name="ln822">    case QL_OP_NOT_BETWEEN:</a>
<a name="ln823">      RETURN_NOT_OK(op1-&gt;CheckLhsExpr(sem_context));</a>
<a name="ln824">      RETURN_NOT_OK(op2-&gt;CheckRhsExpr(sem_context));</a>
<a name="ln825">      RETURN_NOT_OK(op3-&gt;CheckRhsExpr(sem_context));</a>
<a name="ln826">      RETURN_NOT_OK(CheckInequalityOperands(sem_context, op1, op2));</a>
<a name="ln827">      RETURN_NOT_OK(CheckInequalityOperands(sem_context, op1, op3));</a>
<a name="ln828">      internal_type_ = yb::InternalType::kBoolValue;</a>
<a name="ln829">      break;</a>
<a name="ln830"> </a>
<a name="ln831">    default:</a>
<a name="ln832">      LOG(FATAL) &lt;&lt; &quot;Invalid operator &quot; &lt;&lt; QLOperator_Name(ql_op_);</a>
<a name="ln833">  }</a>
<a name="ln834"> </a>
<a name="ln835">  return Status::OK();</a>
<a name="ln836">}</a>
<a name="ln837"> </a>
<a name="ln838">string PTRelationExpr::QLName(QLNameOption option) const {</a>
<a name="ln839">  switch (ql_op_) {</a>
<a name="ln840">    case QL_OP_NOOP:</a>
<a name="ln841">      return &quot;NO OP&quot;;</a>
<a name="ln842"> </a>
<a name="ln843">    // Logic operators that take one operand.</a>
<a name="ln844">    case QL_OP_NOT:</a>
<a name="ln845">      return string(&quot;NOT &quot;) + op1()-&gt;QLName(option);</a>
<a name="ln846">    case QL_OP_IS_TRUE:</a>
<a name="ln847">      return op1()-&gt;QLName(option) + &quot;IS TRUE&quot;;</a>
<a name="ln848">    case QL_OP_IS_FALSE:</a>
<a name="ln849">      return op1()-&gt;QLName(option) + &quot;IS FALSE&quot;;</a>
<a name="ln850"> </a>
<a name="ln851">      // Logic operators that take two or more operands.</a>
<a name="ln852">    case QL_OP_AND:</a>
<a name="ln853">      return op1()-&gt;QLName(option) + &quot; AND &quot; + op2()-&gt;QLName(option);</a>
<a name="ln854">    case QL_OP_OR:</a>
<a name="ln855">      return op1()-&gt;QLName(option) + &quot; OR &quot; + op2()-&gt;QLName(option);</a>
<a name="ln856"> </a>
<a name="ln857">      // Relation operators that take one operand.</a>
<a name="ln858">    case QL_OP_IS_NULL:</a>
<a name="ln859">      return op1()-&gt;QLName(option) + &quot; IS NULL&quot;;</a>
<a name="ln860">    case QL_OP_IS_NOT_NULL:</a>
<a name="ln861">      return op1()-&gt;QLName(option) + &quot; IS NOT NULL&quot;;</a>
<a name="ln862"> </a>
<a name="ln863">      // Relation operators that take two operands.</a>
<a name="ln864">    case QL_OP_EQUAL:</a>
<a name="ln865">      return op1()-&gt;QLName(option) + &quot; == &quot; + op2()-&gt;QLName(option);</a>
<a name="ln866">    case QL_OP_LESS_THAN:</a>
<a name="ln867">      return op1()-&gt;QLName(option) + &quot; &lt; &quot; + op2()-&gt;QLName(option);</a>
<a name="ln868">    case QL_OP_LESS_THAN_EQUAL:</a>
<a name="ln869">      return op1()-&gt;QLName(option) + &quot; &lt;= &quot; + op2()-&gt;QLName(option);</a>
<a name="ln870">    case QL_OP_GREATER_THAN:</a>
<a name="ln871">      return op1()-&gt;QLName(option) + &quot; &gt; &quot; + op2()-&gt;QLName(option);</a>
<a name="ln872">    case QL_OP_GREATER_THAN_EQUAL:</a>
<a name="ln873">      return op1()-&gt;QLName(option) + &quot; &gt;= &quot; + op2()-&gt;QLName(option);</a>
<a name="ln874">    case QL_OP_NOT_EQUAL:</a>
<a name="ln875">      return op1()-&gt;QLName(option) + &quot; != &quot; + op2()-&gt;QLName(option);</a>
<a name="ln876"> </a>
<a name="ln877">    case QL_OP_LIKE:</a>
<a name="ln878">      return op1()-&gt;QLName(option) + &quot; LIKE &quot; + op2()-&gt;QLName(option);</a>
<a name="ln879">    case QL_OP_NOT_LIKE:</a>
<a name="ln880">      return op1()-&gt;QLName(option) + &quot; NOT LIKE &quot; +</a>
<a name="ln881">          op2()-&gt;QLName(option);</a>
<a name="ln882">    case QL_OP_IN:</a>
<a name="ln883">      return op1()-&gt;QLName(option) + &quot; IN &quot; + op2()-&gt;QLName(option);</a>
<a name="ln884">    case QL_OP_NOT_IN:</a>
<a name="ln885">      return op1()-&gt;QLName(option) + &quot; NOT IN &quot; + op2()-&gt;QLName(option);</a>
<a name="ln886"> </a>
<a name="ln887">    // Relation operators that take three operands.</a>
<a name="ln888">    case QL_OP_BETWEEN:</a>
<a name="ln889">      return op1()-&gt;QLName(option) + &quot; BETWEEN &quot; +</a>
<a name="ln890">          op2()-&gt;QLName(option) + &quot; AND &quot; +</a>
<a name="ln891">          op3()-&gt;QLName(option);</a>
<a name="ln892">    case QL_OP_NOT_BETWEEN:</a>
<a name="ln893">      return op1()-&gt;QLName(option) + &quot; NOT BETWEEN &quot; +</a>
<a name="ln894">          op2()-&gt;QLName(option) + &quot; AND &quot; +</a>
<a name="ln895">          op3()-&gt;QLName(option);</a>
<a name="ln896"> </a>
<a name="ln897">    // Operators that take no operand. For use in &quot;if&quot; clause only currently.</a>
<a name="ln898">    case QL_OP_EXISTS:</a>
<a name="ln899">      return &quot;EXISTS&quot;;</a>
<a name="ln900">    case QL_OP_NOT_EXISTS:</a>
<a name="ln901">      return &quot;NOT EXISTS&quot;;</a>
<a name="ln902">  }</a>
<a name="ln903"> </a>
<a name="ln904">  return &quot;expr&quot;;</a>
<a name="ln905">}</a>
<a name="ln906"> </a>
<a name="ln907">const ColumnDesc *PTExpr::GetColumnDesc(const SemContext *sem_context) {</a>
<a name="ln908">  MCString expr_name(MangledName().c_str(), sem_context-&gt;PTempMem());</a>
<a name="ln909">  return GetColumnDesc(sem_context, expr_name, sem_context-&gt;current_dml_stmt());</a>
<a name="ln910">}</a>
<a name="ln911"> </a>
<a name="ln912">const ColumnDesc *PTExpr::GetColumnDesc(const SemContext *sem_context,</a>
<a name="ln913">                                        const MCString&amp; col_name) const {</a>
<a name="ln914">  if (sem_context-&gt;selecting_from_index()) {</a>
<a name="ln915">    // Mangle column name when selecting from IndexTable.</a>
<a name="ln916">    MCString mangled_name(YcqlName::MangleColumnName(col_name.c_str()).c_str(),</a>
<a name="ln917">                          sem_context-&gt;PTempMem());</a>
<a name="ln918">    return GetColumnDesc(sem_context, mangled_name, sem_context-&gt;current_dml_stmt());</a>
<a name="ln919">  }</a>
<a name="ln920"> </a>
<a name="ln921">  return GetColumnDesc(sem_context, col_name, sem_context-&gt;current_dml_stmt());</a>
<a name="ln922">}</a>
<a name="ln923"> </a>
<a name="ln924">const ColumnDesc *PTExpr::GetColumnDesc(const SemContext *sem_context,</a>
<a name="ln925">                                        const MCString&amp; desc_name,</a>
<a name="ln926">                                        PTDmlStmt *stmt) const {</a>
<a name="ln927">  if (stmt) {</a>
<a name="ln928">    // Get column from DML statement when compiling a DML statement.</a>
<a name="ln929">    return stmt-&gt;GetColumnDesc(sem_context, desc_name);</a>
<a name="ln930">  }</a>
<a name="ln931">  // Get column from symbol table in context.</a>
<a name="ln932">  return sem_context-&gt;GetColumnDesc(desc_name);</a>
<a name="ln933">}</a>
<a name="ln934"> </a>
<a name="ln935">//--------------------------------------------------------------------------------------------------</a>
<a name="ln936"> </a>
<a name="ln937">CHECKED_STATUS PTOperatorExpr::SetupSemStateForOp1(SemState *sem_state) {</a>
<a name="ln938">  switch (op_) {</a>
<a name="ln939">    case ExprOperator::kUMinus:</a>
<a name="ln940">    case ExprOperator::kAlias:</a>
<a name="ln941">      sem_state-&gt;CopyPreviousStates();</a>
<a name="ln942">      break;</a>
<a name="ln943"> </a>
<a name="ln944">    default:</a>
<a name="ln945">      LOG(FATAL) &lt;&lt; &quot;Invalid operator &quot; &lt;&lt; int(op_);</a>
<a name="ln946">  }</a>
<a name="ln947"> </a>
<a name="ln948">  return Status::OK();</a>
<a name="ln949">}</a>
<a name="ln950"> </a>
<a name="ln951">CHECKED_STATUS PTOperatorExpr::AnalyzeOperator(SemContext *sem_context,</a>
<a name="ln952">                                               PTExpr::SharedPtr op1) {</a>
<a name="ln953">  switch (op_) {</a>
<a name="ln954">    case ExprOperator::kUMinus:</a>
<a name="ln955">      // &quot;op1&quot; must have been analyzed before we get here.</a>
<a name="ln956">      // Check to make sure that it is allowed in this context.</a>
<a name="ln957">      if (op1-&gt;expr_op() != ExprOperator::kConst) {</a>
<a name="ln958">        return sem_context-&gt;Error(this, &quot;Only numeric constant is allowed in this context&quot;,</a>
<a name="ln959">                                  ErrorCode::FEATURE_NOT_SUPPORTED);</a>
<a name="ln960">      }</a>
<a name="ln961">      if (!QLType::IsNumeric(op1-&gt;ql_type_id())) {</a>
<a name="ln962">        return sem_context-&gt;Error(this, &quot;Only numeric data type is allowed in this context&quot;,</a>
<a name="ln963">                                  ErrorCode::INVALID_DATATYPE);</a>
<a name="ln964">      }</a>
<a name="ln965"> </a>
<a name="ln966">      // Type resolution: (-x) should have the same datatype as (x).</a>
<a name="ln967">      ql_type_ = op1-&gt;ql_type();</a>
<a name="ln968">      internal_type_ = op1-&gt;internal_type();</a>
<a name="ln969">      break;</a>
<a name="ln970"> </a>
<a name="ln971">    default:</a>
<a name="ln972">      LOG(FATAL) &lt;&lt; &quot;Invalid operator&quot; &lt;&lt; int(op_);</a>
<a name="ln973">  }</a>
<a name="ln974"> </a>
<a name="ln975">  return Status::OK();</a>
<a name="ln976">}</a>
<a name="ln977"> </a>
<a name="ln978">//--------------------------------------------------------------------------------------------------</a>
<a name="ln979"> </a>
<a name="ln980">PTRef::PTRef(MemoryContext *memctx,</a>
<a name="ln981">             YBLocation::SharedPtr loc,</a>
<a name="ln982">             const PTQualifiedName::SharedPtr&amp; name)</a>
<a name="ln983">    : PTOperator0(memctx, loc, ExprOperator::kRef, yb::QLOperator::QL_OP_NOOP),</a>
<a name="ln984">      name_(name),</a>
<a name="ln985">      desc_(nullptr) {</a>
<a name="ln986">}</a>
<a name="ln987"> </a>
<a name="ln988">PTRef::~PTRef() {</a>
<a name="ln989">}</a>
<a name="ln990"> </a>
<a name="ln991">CHECKED_STATUS PTRef::AnalyzeOperator(SemContext *sem_context) {</a>
<a name="ln992">  DCHECK(name_ != nullptr) &lt;&lt; &quot;Reference column is not specified&quot;;</a>
<a name="ln993"> </a>
<a name="ln994">  // Look for a column descriptor from symbol table.</a>
<a name="ln995">  RETURN_NOT_OK(name_-&gt;Analyze(sem_context));</a>
<a name="ln996">  if (!name_-&gt;IsSimpleName()) {</a>
<a name="ln997">    return sem_context-&gt;Error(this, &quot;Qualified name not allowed for column reference&quot;,</a>
<a name="ln998">                              ErrorCode::SQL_STATEMENT_INVALID);</a>
<a name="ln999">  }</a>
<a name="ln1000">  desc_ = GetColumnDesc(sem_context, name_-&gt;last_name());</a>
<a name="ln1001">  if (desc_ == nullptr) {</a>
<a name="ln1002">    // If this is a nested select from an uncovered index, ignore column that is uncovered.</a>
<a name="ln1003">    LOG(INFO) &lt;&lt; &quot;Column &quot; &lt;&lt; name_-&gt;last_name() &lt;&lt; &quot; not found&quot;;</a>
<a name="ln1004">    return sem_context-&gt;IsUncoveredIndexSelect()</a>
<a name="ln1005">        ? Status::OK()</a>
<a name="ln1006">        : sem_context-&gt;Error(this, &quot;Column doesn't exist&quot;, ErrorCode::UNDEFINED_COLUMN);</a>
<a name="ln1007">  }</a>
<a name="ln1008"> </a>
<a name="ln1009">  // Type resolution: Ref(x) should have the same datatype as (x).</a>
<a name="ln1010">  internal_type_ = desc_-&gt;internal_type();</a>
<a name="ln1011">  ql_type_ = desc_-&gt;ql_type();</a>
<a name="ln1012">  return Status::OK();</a>
<a name="ln1013">}</a>
<a name="ln1014"> </a>
<a name="ln1015">CHECKED_STATUS PTRef::CheckLhsExpr(SemContext *sem_context) {</a>
<a name="ln1016">  // When CQL IF clause is being processed. In that case, disallow reference to primary key columns</a>
<a name="ln1017">  // and counters. No error checking is needed when processing SELECT against INDEX table because</a>
<a name="ln1018">  // we already check it against the UserTable.</a>
<a name="ln1019">  if (sem_context-&gt;processing_if_clause() &amp;&amp; !sem_context-&gt;selecting_from_index()) {</a>
<a name="ln1020">    if (desc_-&gt;is_primary()) {</a>
<a name="ln1021">      return sem_context-&gt;Error(this, &quot;Primary key column reference is not allowed in if clause&quot;,</a>
<a name="ln1022">                                ErrorCode::CQL_STATEMENT_INVALID);</a>
<a name="ln1023">    } else if (desc_-&gt;is_counter()) {</a>
<a name="ln1024">      return sem_context-&gt;Error(this, &quot;Counter column reference is not allowed in if clause&quot;,</a>
<a name="ln1025">                                ErrorCode::CQL_STATEMENT_INVALID);</a>
<a name="ln1026">    }</a>
<a name="ln1027">  }</a>
<a name="ln1028"> </a>
<a name="ln1029">  // Only hash/static columns are supported in the where clause of SELECT DISTINCT.</a>
<a name="ln1030">  if (sem_context-&gt;where_state() != nullptr) {</a>
<a name="ln1031">    const PTDmlStmt *dml = sem_context-&gt;current_dml_stmt();</a>
<a name="ln1032">    if (dml != nullptr &amp;&amp; dml-&gt;opcode() == TreeNodeOpcode::kPTSelectStmt &amp;&amp;</a>
<a name="ln1033">        down_cast&lt;const PTSelectStmt*&gt;(dml)-&gt;distinct() &amp;&amp;</a>
<a name="ln1034">        !desc_-&gt;is_hash() &amp;&amp; !desc_-&gt;is_static()) {</a>
<a name="ln1035">      return sem_context-&gt;Error(this,</a>
<a name="ln1036">                                &quot;Non-partition/static column reference is not supported in the &quot;</a>
<a name="ln1037">                                &quot;where clause of a SELECT DISTINCT statement&quot;,</a>
<a name="ln1038">                                ErrorCode::CQL_STATEMENT_INVALID);</a>
<a name="ln1039">    }</a>
<a name="ln1040">  }</a>
<a name="ln1041"> </a>
<a name="ln1042">  return Status::OK();</a>
<a name="ln1043">}</a>
<a name="ln1044"> </a>
<a name="ln1045">void PTRef::PrintSemanticAnalysisResult(SemContext *sem_context) {</a>
<a name="ln1046">  VLOG(3) &lt;&lt; &quot;SEMANTIC ANALYSIS RESULT (&quot; &lt;&lt; *loc_ &lt;&lt; &quot;):\n&quot; &lt;&lt; &quot;Not yet avail&quot;;</a>
<a name="ln1047">}</a>
<a name="ln1048"> </a>
<a name="ln1049">PTJsonOperator::PTJsonOperator(MemoryContext *memctx,</a>
<a name="ln1050">                               YBLocation::SharedPtr loc,</a>
<a name="ln1051">                               const JsonOperator&amp; json_operator,</a>
<a name="ln1052">                               const PTExpr::SharedPtr&amp; arg)</a>
<a name="ln1053">    : PTExpr(memctx, loc, ExprOperator::kJsonOperatorRef, yb::QLOperator::QL_OP_NOOP,</a>
<a name="ln1054">             InternalType::kJsonbValue, DataType::JSONB),</a>
<a name="ln1055">      json_operator_(json_operator),</a>
<a name="ln1056">      arg_(arg) {</a>
<a name="ln1057">}</a>
<a name="ln1058"> </a>
<a name="ln1059">PTJsonOperator::~PTJsonOperator() {</a>
<a name="ln1060">}</a>
<a name="ln1061"> </a>
<a name="ln1062">Status PTJsonOperator::Analyze(SemContext *sem_context) {</a>
<a name="ln1063">  return arg_-&gt;Analyze(sem_context);</a>
<a name="ln1064">}</a>
<a name="ln1065"> </a>
<a name="ln1066">//--------------------------------------------------------------------------------------------------</a>
<a name="ln1067"> </a>
<a name="ln1068">PTJsonColumnWithOperators::PTJsonColumnWithOperators(MemoryContext *memctx,</a>
<a name="ln1069">                                                     YBLocation::SharedPtr loc,</a>
<a name="ln1070">                                                     const PTQualifiedName::SharedPtr&amp; name,</a>
<a name="ln1071">                                                     const PTExprListNode::SharedPtr&amp; operators)</a>
<a name="ln1072">    : PTOperator0(memctx, loc, ExprOperator::kJsonOperatorRef, yb::QLOperator::QL_OP_NOOP),</a>
<a name="ln1073">      name_(name),</a>
<a name="ln1074">      operators_(operators) {</a>
<a name="ln1075">}</a>
<a name="ln1076"> </a>
<a name="ln1077">PTJsonColumnWithOperators::~PTJsonColumnWithOperators() {</a>
<a name="ln1078">}</a>
<a name="ln1079"> </a>
<a name="ln1080">CHECKED_STATUS PTJsonColumnWithOperators::AnalyzeOperator(SemContext *sem_context) {</a>
<a name="ln1081">  // Look for a column descriptor from symbol table.</a>
<a name="ln1082">  RETURN_NOT_OK(name_-&gt;Analyze(sem_context));</a>
<a name="ln1083">  desc_ = GetColumnDesc(sem_context, name_-&gt;last_name());</a>
<a name="ln1084">  if (desc_ == nullptr) {</a>
<a name="ln1085">    // If this is a nested select from an uncovered index, ignore column that is uncovered.</a>
<a name="ln1086">    return sem_context-&gt;IsUncoveredIndexSelect()</a>
<a name="ln1087">        ? Status::OK()</a>
<a name="ln1088">        : sem_context-&gt;Error(this, &quot;Column doesn't exist&quot;, ErrorCode::UNDEFINED_COLUMN);</a>
<a name="ln1089">  }</a>
<a name="ln1090"> </a>
<a name="ln1091">  SemState sem_state(sem_context);</a>
<a name="ln1092"> </a>
<a name="ln1093">  if (!desc_-&gt;ql_type()-&gt;IsJson()) {</a>
<a name="ln1094">    return sem_context-&gt;Error(this, &quot;Column provided is not json data type&quot;,</a>
<a name="ln1095">                              ErrorCode::CQL_STATEMENT_INVALID);</a>
<a name="ln1096">  }</a>
<a name="ln1097"> </a>
<a name="ln1098">  if (operators_-&gt;size() == 0) {</a>
<a name="ln1099">    return sem_context-&gt;Error(this, &quot;No operators provided.&quot;,</a>
<a name="ln1100">                              ErrorCode::CQL_STATEMENT_INVALID);</a>
<a name="ln1101">  }</a>
<a name="ln1102"> </a>
<a name="ln1103">  // Analyze each operator.</a>
<a name="ln1104">  RETURN_NOT_OK(operators_-&gt;Analyze(sem_context));</a>
<a name="ln1105"> </a>
<a name="ln1106">  // Check the last operator to determine type.</a>
<a name="ln1107">  auto json_operator = std::dynamic_pointer_cast&lt;PTJsonOperator&gt;(</a>
<a name="ln1108">      operators_-&gt;element(operators_-&gt;size() - 1))-&gt;json_operator();</a>
<a name="ln1109"> </a>
<a name="ln1110">  if (json_operator == JsonOperator::JSON_OBJECT) {</a>
<a name="ln1111">    ql_type_ = QLType::Create(DataType::JSONB);</a>
<a name="ln1112">    internal_type_ = InternalType::kJsonbValue;</a>
<a name="ln1113">  } else if (json_operator == JsonOperator::JSON_TEXT) {</a>
<a name="ln1114">    ql_type_ = QLType::Create(DataType::STRING);</a>
<a name="ln1115">    internal_type_ = InternalType::kStringValue;</a>
<a name="ln1116">  } else {</a>
<a name="ln1117">    return sem_context-&gt;Error(this, &quot;Invalid operator.&quot;,</a>
<a name="ln1118">                              ErrorCode::CQL_STATEMENT_INVALID);</a>
<a name="ln1119">  }</a>
<a name="ln1120"> </a>
<a name="ln1121">  return Status::OK();</a>
<a name="ln1122">}</a>
<a name="ln1123"> </a>
<a name="ln1124">CHECKED_STATUS PTJsonColumnWithOperators::CheckLhsExpr(SemContext *sem_context) {</a>
<a name="ln1125">  return Status::OK();</a>
<a name="ln1126">}</a>
<a name="ln1127"> </a>
<a name="ln1128">//--------------------------------------------------------------------------------------------------</a>
<a name="ln1129"> </a>
<a name="ln1130">PTSubscriptedColumn::PTSubscriptedColumn(MemoryContext *memctx,</a>
<a name="ln1131">                                         YBLocation::SharedPtr loc,</a>
<a name="ln1132">                                         const PTQualifiedName::SharedPtr&amp; name,</a>
<a name="ln1133">                                         const PTExprListNode::SharedPtr&amp; args)</a>
<a name="ln1134">    : PTOperator0(memctx, loc, ExprOperator::kSubColRef, yb::QLOperator::QL_OP_NOOP),</a>
<a name="ln1135">      name_(name),</a>
<a name="ln1136">      args_(args),</a>
<a name="ln1137">      desc_(nullptr) {</a>
<a name="ln1138">}</a>
<a name="ln1139"> </a>
<a name="ln1140">PTSubscriptedColumn::~PTSubscriptedColumn() {</a>
<a name="ln1141">}</a>
<a name="ln1142"> </a>
<a name="ln1143">CHECKED_STATUS PTSubscriptedColumn::AnalyzeOperator(SemContext *sem_context) {</a>
<a name="ln1144"> </a>
<a name="ln1145">  // Check if this refers to the whole table (SELECT *).</a>
<a name="ln1146">  if (name_ == nullptr) {</a>
<a name="ln1147">    return sem_context-&gt;Error(this, &quot;Cannot do type resolution for wildcard reference (SELECT *)&quot;,</a>
<a name="ln1148">                              ErrorCode::SQL_STATEMENT_INVALID);</a>
<a name="ln1149">  }</a>
<a name="ln1150"> </a>
<a name="ln1151">  // Look for a column descriptor from symbol table.</a>
<a name="ln1152">  RETURN_NOT_OK(name_-&gt;Analyze(sem_context));</a>
<a name="ln1153">  desc_ = GetColumnDesc(sem_context, name_-&gt;last_name());</a>
<a name="ln1154">  if (desc_ == nullptr) {</a>
<a name="ln1155">    // If this is a nested select from an uncovered index, ignore column that is uncovered.</a>
<a name="ln1156">    return sem_context-&gt;IsUncoveredIndexSelect()</a>
<a name="ln1157">        ? Status::OK()</a>
<a name="ln1158">        : sem_context-&gt;Error(this, &quot;Column doesn't exist&quot;, ErrorCode::UNDEFINED_COLUMN);</a>
<a name="ln1159">  }</a>
<a name="ln1160"> </a>
<a name="ln1161">  SemState sem_state(sem_context);</a>
<a name="ln1162"> </a>
<a name="ln1163">  auto curr_ytype = desc_-&gt;ql_type();</a>
<a name="ln1164">  auto curr_itype = desc_-&gt;internal_type();</a>
<a name="ln1165"> </a>
<a name="ln1166">  if (args_ != nullptr) {</a>
<a name="ln1167">    for (const auto &amp;arg : args_-&gt;node_list()) {</a>
<a name="ln1168">      if (curr_ytype-&gt;keys_type() == nullptr) {</a>
<a name="ln1169">        return sem_context-&gt;Error(this, &quot;Columns with elementary types cannot take arguments&quot;,</a>
<a name="ln1170">                                  ErrorCode::CQL_STATEMENT_INVALID);</a>
<a name="ln1171">      }</a>
<a name="ln1172"> </a>
<a name="ln1173">      sem_state.SetExprState(curr_ytype-&gt;keys_type(),</a>
<a name="ln1174">                             client::YBColumnSchema::ToInternalDataType(curr_ytype-&gt;keys_type()));</a>
<a name="ln1175">      RETURN_NOT_OK(arg-&gt;Analyze(sem_context));</a>
<a name="ln1176"> </a>
<a name="ln1177">      curr_ytype = curr_ytype-&gt;values_type();</a>
<a name="ln1178">      curr_itype = client::YBColumnSchema::ToInternalDataType(curr_ytype);</a>
<a name="ln1179">    }</a>
<a name="ln1180">  }</a>
<a name="ln1181"> </a>
<a name="ln1182">  // Type resolution: Ref(x) should have the same datatype as (x).</a>
<a name="ln1183">  ql_type_ = curr_ytype;</a>
<a name="ln1184">  internal_type_ = curr_itype;</a>
<a name="ln1185"> </a>
<a name="ln1186">  return Status::OK();</a>
<a name="ln1187">}</a>
<a name="ln1188"> </a>
<a name="ln1189">CHECKED_STATUS PTSubscriptedColumn::CheckLhsExpr(SemContext *sem_context) {</a>
<a name="ln1190">  // If where_state is null, we are processing the IF clause. In that case, disallow reference to</a>
<a name="ln1191">  // primary key columns.</a>
<a name="ln1192">  if (sem_context-&gt;where_state() == nullptr &amp;&amp; desc_-&gt;is_primary()) {</a>
<a name="ln1193">    return sem_context-&gt;Error(this, &quot;Primary key column reference is not allowed in if expression&quot;,</a>
<a name="ln1194">                              ErrorCode::CQL_STATEMENT_INVALID);</a>
<a name="ln1195">  }</a>
<a name="ln1196">  return Status::OK();</a>
<a name="ln1197">}</a>
<a name="ln1198"> </a>
<a name="ln1199">void PTSubscriptedColumn::PrintSemanticAnalysisResult(SemContext *sem_context) {</a>
<a name="ln1200">  VLOG(3) &lt;&lt; &quot;SEMANTIC ANALYSIS RESULT (&quot; &lt;&lt; *loc_ &lt;&lt; &quot;):\n&quot; &lt;&lt; &quot;Not yet avail&quot;;</a>
<a name="ln1201">}</a>
<a name="ln1202"> </a>
<a name="ln1203">//--------------------------------------------------------------------------------------------------</a>
<a name="ln1204"> </a>
<a name="ln1205">PTAllColumns::PTAllColumns(MemoryContext *memctx, YBLocation::SharedPtr loc)</a>
<a name="ln1206">    : PTOperator0(memctx, loc, ExprOperator::kRef, yb::QLOperator::QL_OP_NOOP),</a>
<a name="ln1207">      columns_(memctx) {</a>
<a name="ln1208">}</a>
<a name="ln1209"> </a>
<a name="ln1210">PTAllColumns::~PTAllColumns() {</a>
<a name="ln1211">}</a>
<a name="ln1212"> </a>
<a name="ln1213">CHECKED_STATUS PTAllColumns::AnalyzeOperator(SemContext *sem_context) {</a>
<a name="ln1214">  // Make sure '*' is used only in 'SELECT *' statement.</a>
<a name="ln1215">  const PTDmlStmt *stmt = sem_context-&gt;current_dml_stmt();</a>
<a name="ln1216">  if (stmt == nullptr ||</a>
<a name="ln1217">      stmt-&gt;opcode() != TreeNodeOpcode::kPTSelectStmt ||</a>
<a name="ln1218">      static_cast&lt;const PTSelectStmt*&gt;(stmt)-&gt;selected_exprs().size() &gt; 1) {</a>
<a name="ln1219">    return sem_context-&gt;Error(loc(), &quot;Cannot use '*' expression in this context&quot;,</a>
<a name="ln1220">                              ErrorCode::CQL_STATEMENT_INVALID);</a>
<a name="ln1221">  }</a>
<a name="ln1222"> </a>
<a name="ln1223">  const auto* select_stmt = static_cast&lt;const PTSelectStmt*&gt;(stmt);</a>
<a name="ln1224">  columns_.clear();</a>
<a name="ln1225">  columns_.reserve(select_stmt-&gt;column_map().size());</a>
<a name="ln1226">  for (const auto&amp; pair : select_stmt-&gt;column_map()) {</a>
<a name="ln1227">    columns_.emplace_back(pair.second);</a>
<a name="ln1228">  }</a>
<a name="ln1229"> </a>
<a name="ln1230">  // For 'select * ... ' using index only, sort them in the same order as the table columns so that</a>
<a name="ln1231">  // the selected columns are returned in the proper order.</a>
<a name="ln1232">  if (select_stmt-&gt;table()-&gt;IsIndex()) {</a>
<a name="ln1233">    MCUnorderedMap&lt;int, int&gt; map(sem_context-&gt;PTempMem()); // Map of column_id -&gt; indexed_column_id</a>
<a name="ln1234">    for (const auto&amp; column : select_stmt-&gt;table()-&gt;index_info().columns()) {</a>
<a name="ln1235">      map.emplace(column.column_id, column.indexed_column_id);</a>
<a name="ln1236">    }</a>
<a name="ln1237">    std::sort(columns_.begin(), columns_.end(),</a>
<a name="ln1238">              [&amp;map](const ColumnDesc&amp; a, const ColumnDesc&amp; b) {</a>
<a name="ln1239">                return map[a.id()] &lt; map[b.id()];</a>
<a name="ln1240">              });</a>
<a name="ln1241">  } else {</a>
<a name="ln1242">    std::sort(columns_.begin(), columns_.end(),</a>
<a name="ln1243">              [](const ColumnDesc&amp; a, const ColumnDesc&amp; b) {</a>
<a name="ln1244">                return a.id() &lt; b.id();</a>
<a name="ln1245">              });</a>
<a name="ln1246">  }</a>
<a name="ln1247"> </a>
<a name="ln1248">  // Note to server that all column are referenced by this statement.</a>
<a name="ln1249">  sem_context-&gt;current_dml_stmt()-&gt;AddRefForAllColumns();</a>
<a name="ln1250"> </a>
<a name="ln1251">  // TODO(Mihnea) See if TUPLE datatype can be used here.</a>
<a name="ln1252">  // '*' should be of TUPLE type, but we use the following workaround for now.</a>
<a name="ln1253">  ql_type_ = QLType::Create(DataType::NULL_VALUE_TYPE);</a>
<a name="ln1254">  internal_type_ = InternalType::kListValue;</a>
<a name="ln1255">  return Status::OK();</a>
<a name="ln1256">}</a>
<a name="ln1257"> </a>
<a name="ln1258">//--------------------------------------------------------------------------------------------------</a>
<a name="ln1259"> </a>
<a name="ln1260">PTExprAlias::PTExprAlias(MemoryContext *memctx,</a>
<a name="ln1261">                         YBLocation::SharedPtr loc,</a>
<a name="ln1262">                         const PTExpr::SharedPtr&amp; expr,</a>
<a name="ln1263">                         const MCSharedPtr&lt;MCString&gt;&amp; alias)</a>
<a name="ln1264">    : PTOperator1(memctx, loc, ExprOperator::kAlias, yb::QLOperator::QL_OP_NOOP, expr),</a>
<a name="ln1265">      alias_(alias) {</a>
<a name="ln1266">}</a>
<a name="ln1267"> </a>
<a name="ln1268">PTExprAlias::~PTExprAlias() {</a>
<a name="ln1269">}</a>
<a name="ln1270"> </a>
<a name="ln1271">CHECKED_STATUS PTExprAlias::SetupSemStateForOp1(SemState *sem_state) {</a>
<a name="ln1272">  sem_state-&gt;set_allowing_aggregate(sem_state-&gt;previous_state()-&gt;allowing_aggregate());</a>
<a name="ln1273">  return Status::OK();</a>
<a name="ln1274">}</a>
<a name="ln1275"> </a>
<a name="ln1276">CHECKED_STATUS PTExprAlias::AnalyzeOperator(SemContext *sem_context, PTExpr::SharedPtr op1) {</a>
<a name="ln1277">  // Type resolution: Alias of (x) should have the same datatype as (x).</a>
<a name="ln1278">  ql_type_ = op1-&gt;ql_type();</a>
<a name="ln1279">  internal_type_ = op1-&gt;internal_type();</a>
<a name="ln1280">  return Status::OK();</a>
<a name="ln1281">}</a>
<a name="ln1282"> </a>
<a name="ln1283">//--------------------------------------------------------------------------------------------------</a>
<a name="ln1284"> </a>
<a name="ln1285">PTBindVar::PTBindVar(MemoryContext *memctx,</a>
<a name="ln1286">                     YBLocation::SharedPtr loc,</a>
<a name="ln1287">                     const MCSharedPtr&lt;MCString&gt;&amp; name)</a>
<a name="ln1288">    : PTExpr(memctx, loc, ExprOperator::kBindVar),</a>
<a name="ln1289">      name_(name) {</a>
<a name="ln1290">}</a>
<a name="ln1291"> </a>
<a name="ln1292">PTBindVar::PTBindVar(MemoryContext *memctx,</a>
<a name="ln1293">                     YBLocation::SharedPtr loc,</a>
<a name="ln1294">                     PTConstVarInt::SharedPtr user_pos)</a>
<a name="ln1295">    : PTExpr(memctx, loc, ExprOperator::kBindVar),</a>
<a name="ln1296">      user_pos_(user_pos) {</a>
<a name="ln1297">}</a>
<a name="ln1298"> </a>
<a name="ln1299">PTBindVar::~PTBindVar() {</a>
<a name="ln1300">}</a>
<a name="ln1301"> </a>
<a name="ln1302">CHECKED_STATUS PTBindVar::Analyze(SemContext *sem_context) {</a>
<a name="ln1303">  // Before traversing the expression, check if this whole expression is actually a column.</a>
<a name="ln1304">  if (CheckIndexColumn(sem_context)) {</a>
<a name="ln1305">    return Status::OK();</a>
<a name="ln1306">  }</a>
<a name="ln1307"> </a>
<a name="ln1308">  RETURN_NOT_OK(CheckOperator(sem_context));</a>
<a name="ln1309"> </a>
<a name="ln1310">  if (name_ == nullptr) {</a>
<a name="ln1311">    name_ = sem_context-&gt;bindvar_name();</a>
<a name="ln1312">  }</a>
<a name="ln1313"> </a>
<a name="ln1314">  if (user_pos_ != nullptr) {</a>
<a name="ln1315">    int64_t pos = 0;</a>
<a name="ln1316">    if (!user_pos_-&gt;ToInt64(&amp;pos, false).ok()) {</a>
<a name="ln1317">      return sem_context-&gt;Error(this, &quot;Bind position is invalid!&quot;,</a>
<a name="ln1318">                                ErrorCode::INVALID_ARGUMENTS);</a>
<a name="ln1319">    }</a>
<a name="ln1320"> </a>
<a name="ln1321">    if (pos &lt;= 0) {</a>
<a name="ln1322">      return sem_context-&gt;Error(this, &quot;Bind variable position should be positive!&quot;,</a>
<a name="ln1323">                                ErrorCode::INVALID_ARGUMENTS);</a>
<a name="ln1324">    }</a>
<a name="ln1325">    // Convert from 1 based to 0 based.</a>
<a name="ln1326">    set_pos(pos - 1);</a>
<a name="ln1327">  }</a>
<a name="ln1328"> </a>
<a name="ln1329">  if (sem_context-&gt;expr_expected_ql_type()-&gt;main() == DataType::UNKNOWN_DATA) {</a>
<a name="ln1330">    // By default bind variables are compatible with any type.</a>
<a name="ln1331">    ql_type_ = QLType::Create(NULL_VALUE_TYPE);</a>
<a name="ln1332">  } else {</a>
<a name="ln1333">    ql_type_ = sem_context-&gt;expr_expected_ql_type();</a>
<a name="ln1334">  }</a>
<a name="ln1335"> </a>
<a name="ln1336">  internal_type_ = sem_context-&gt;expr_expected_internal_type();</a>
<a name="ln1337">  expected_internal_type_ = internal_type_;</a>
<a name="ln1338">  hash_col_ = sem_context-&gt;hash_col();</a>
<a name="ln1339">  if (hash_col_ != nullptr) {</a>
<a name="ln1340">    DCHECK(sem_context-&gt;current_dml_stmt() != nullptr);</a>
<a name="ln1341">    sem_context-&gt;current_dml_stmt()-&gt;AddHashColumnBindVar(this);</a>
<a name="ln1342">  }</a>
<a name="ln1343"> </a>
<a name="ln1344">  return Status::OK();</a>
<a name="ln1345">}</a>
<a name="ln1346"> </a>
<a name="ln1347">void PTBindVar::PrintSemanticAnalysisResult(SemContext *sem_context) {</a>
<a name="ln1348">  VLOG(3) &lt;&lt; &quot;SEMANTIC ANALYSIS RESULT (&quot; &lt;&lt; *loc_ &lt;&lt; &quot;):\n&quot; &lt;&lt; &quot;Not yet avail&quot;;</a>
<a name="ln1349">}</a>
<a name="ln1350"> </a>
<a name="ln1351">}  // namespace ql</a>
<a name="ln1352">}  // namespace yb</a>

</code></pre>
<div class="balloon" rel="119"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="408"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 408, 419</p></div>
<div class="balloon" rel="541"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="770"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="992"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1046"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1200"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1340"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1348"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="502"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v524/" target="_blank">V524</a> It is odd that the body of 'SetupSemStateForOp2' function is fully equivalent to the body of 'SetupSemStateForOp1' function.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
