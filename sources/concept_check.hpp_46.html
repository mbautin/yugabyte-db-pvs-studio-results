
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>concept_check.hpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//</a>
<a name="ln2">// (C) Copyright Jeremy Siek 2000.</a>
<a name="ln3">// Copyright 2002 The Trustees of Indiana University.</a>
<a name="ln4">//</a>
<a name="ln5">// Distributed under the Boost Software License, Version 1.0. (See</a>
<a name="ln6">// accompanying file LICENSE_1_0.txt or copy at</a>
<a name="ln7">// http://www.boost.org/LICENSE_1_0.txt)</a>
<a name="ln8">//</a>
<a name="ln9">// Revision History:</a>
<a name="ln10">//   05 May   2001: Workarounds for HP aCC from Thomas Matelich. (Jeremy Siek)</a>
<a name="ln11">//   02 April 2001: Removed limits header altogether. (Jeremy Siek)</a>
<a name="ln12">//   01 April 2001: Modified to use new &lt;boost/limits.hpp&gt; header. (JMaddock)</a>
<a name="ln13">//</a>
<a name="ln14"> </a>
<a name="ln15">// See http://www.boost.org/libs/concept_check for documentation.</a>
<a name="ln16"> </a>
<a name="ln17">#ifndef BOOST_CONCEPT_CHECKS_HPP</a>
<a name="ln18"># define BOOST_CONCEPT_CHECKS_HPP</a>
<a name="ln19"> </a>
<a name="ln20"># include &lt;boost/concept/assert.hpp&gt;</a>
<a name="ln21"> </a>
<a name="ln22"># include &lt;iterator&gt;</a>
<a name="ln23"># include &lt;boost/type_traits/conversion_traits.hpp&gt;</a>
<a name="ln24"># include &lt;utility&gt;</a>
<a name="ln25"># include &lt;boost/type_traits/is_same.hpp&gt;</a>
<a name="ln26"># include &lt;boost/type_traits/is_void.hpp&gt;</a>
<a name="ln27"># include &lt;boost/static_assert.hpp&gt;</a>
<a name="ln28"># include &lt;boost/type_traits/integral_constant.hpp&gt;</a>
<a name="ln29"># include &lt;boost/config/workaround.hpp&gt;</a>
<a name="ln30"> </a>
<a name="ln31"># include &lt;boost/concept/usage.hpp&gt;</a>
<a name="ln32"># include &lt;boost/concept/detail/concept_def.hpp&gt;</a>
<a name="ln33"> </a>
<a name="ln34">#if (defined _MSC_VER)</a>
<a name="ln35"># pragma warning( push )</a>
<a name="ln36"># pragma warning( disable : 4510 ) // default constructor could not be generated</a>
<a name="ln37"># pragma warning( disable : 4610 ) // object 'class' can never be instantiated - user-defined constructor required</a>
<a name="ln38">#endif</a>
<a name="ln39"> </a>
<a name="ln40">namespace boost</a>
<a name="ln41">{</a>
<a name="ln42"> </a>
<a name="ln43">  //</a>
<a name="ln44">  // Backward compatibility</a>
<a name="ln45">  //</a>
<a name="ln46"> </a>
<a name="ln47">  template &lt;class Model&gt;</a>
<a name="ln48">  inline void function_requires(Model* = 0)</a>
<a name="ln49">  {</a>
<a name="ln50">      BOOST_CONCEPT_ASSERT((Model));</a>
<a name="ln51">  }</a>
<a name="ln52">  template &lt;class T&gt; inline void ignore_unused_variable_warning(T const&amp;) {}</a>
<a name="ln53"> </a>
<a name="ln54">#  define BOOST_CLASS_REQUIRE(type_var, ns, concept)    \</a>
<a name="ln55">    BOOST_CONCEPT_ASSERT((ns::concept&lt;type_var&gt;))</a>
<a name="ln56"> </a>
<a name="ln57">#  define BOOST_CLASS_REQUIRE2(type_var1, type_var2, ns, concept)   \</a>
<a name="ln58">    BOOST_CONCEPT_ASSERT((ns::concept&lt;type_var1,type_var2&gt;))</a>
<a name="ln59"> </a>
<a name="ln60">#  define BOOST_CLASS_REQUIRE3(tv1, tv2, tv3, ns, concept)  \</a>
<a name="ln61">    BOOST_CONCEPT_ASSERT((ns::concept&lt;tv1,tv2,tv3&gt;))</a>
<a name="ln62"> </a>
<a name="ln63">#  define BOOST_CLASS_REQUIRE4(tv1, tv2, tv3, tv4, ns, concept) \</a>
<a name="ln64">    BOOST_CONCEPT_ASSERT((ns::concept&lt;tv1,tv2,tv3,tv4&gt;))</a>
<a name="ln65"> </a>
<a name="ln66"> </a>
<a name="ln67">  //</a>
<a name="ln68">  // Begin concept definitions</a>
<a name="ln69">  //</a>
<a name="ln70">  BOOST_concept(Integer, (T))</a>
<a name="ln71">  {</a>
<a name="ln72">      BOOST_CONCEPT_USAGE(Integer)</a>
<a name="ln73">        {</a>
<a name="ln74">            x.error_type_must_be_an_integer_type();</a>
<a name="ln75">        }</a>
<a name="ln76">   private:</a>
<a name="ln77">      T x;</a>
<a name="ln78">  };</a>
<a name="ln79"> </a>
<a name="ln80">  template &lt;&gt; struct Integer&lt;char&gt; {};</a>
<a name="ln81">  template &lt;&gt; struct Integer&lt;signed char&gt; {};</a>
<a name="ln82">  template &lt;&gt; struct Integer&lt;unsigned char&gt; {};</a>
<a name="ln83">  template &lt;&gt; struct Integer&lt;short&gt; {};</a>
<a name="ln84">  template &lt;&gt; struct Integer&lt;unsigned short&gt; {};</a>
<a name="ln85">  template &lt;&gt; struct Integer&lt;int&gt; {};</a>
<a name="ln86">  template &lt;&gt; struct Integer&lt;unsigned int&gt; {};</a>
<a name="ln87">  template &lt;&gt; struct Integer&lt;long&gt; {};</a>
<a name="ln88">  template &lt;&gt; struct Integer&lt;unsigned long&gt; {};</a>
<a name="ln89"># if defined(BOOST_HAS_LONG_LONG)</a>
<a name="ln90">  template &lt;&gt; struct Integer&lt; ::boost::long_long_type&gt; {};</a>
<a name="ln91">  template &lt;&gt; struct Integer&lt; ::boost::ulong_long_type&gt; {};</a>
<a name="ln92"># elif defined(BOOST_HAS_MS_INT64)</a>
<a name="ln93">  template &lt;&gt; struct Integer&lt;__int64&gt; {};</a>
<a name="ln94">  template &lt;&gt; struct Integer&lt;unsigned __int64&gt; {};</a>
<a name="ln95"># endif</a>
<a name="ln96"> </a>
<a name="ln97">  BOOST_concept(SignedInteger,(T)) {</a>
<a name="ln98">    BOOST_CONCEPT_USAGE(SignedInteger) {</a>
<a name="ln99">      x.error_type_must_be_a_signed_integer_type();</a>
<a name="ln100">    }</a>
<a name="ln101">   private:</a>
<a name="ln102">    T x;</a>
<a name="ln103">  };</a>
<a name="ln104">  template &lt;&gt; struct SignedInteger&lt;signed char&gt; { };</a>
<a name="ln105">  template &lt;&gt; struct SignedInteger&lt;short&gt; {};</a>
<a name="ln106">  template &lt;&gt; struct SignedInteger&lt;int&gt; {};</a>
<a name="ln107">  template &lt;&gt; struct SignedInteger&lt;long&gt; {};</a>
<a name="ln108"># if defined(BOOST_HAS_LONG_LONG)</a>
<a name="ln109">  template &lt;&gt; struct SignedInteger&lt; ::boost::long_long_type&gt; {};</a>
<a name="ln110"># elif defined(BOOST_HAS_MS_INT64)</a>
<a name="ln111">  template &lt;&gt; struct SignedInteger&lt;__int64&gt; {};</a>
<a name="ln112"># endif</a>
<a name="ln113"> </a>
<a name="ln114">  BOOST_concept(UnsignedInteger,(T)) {</a>
<a name="ln115">    BOOST_CONCEPT_USAGE(UnsignedInteger) {</a>
<a name="ln116">      x.error_type_must_be_an_unsigned_integer_type();</a>
<a name="ln117">    }</a>
<a name="ln118">   private:</a>
<a name="ln119">    T x;</a>
<a name="ln120">  };</a>
<a name="ln121"> </a>
<a name="ln122">  template &lt;&gt; struct UnsignedInteger&lt;unsigned char&gt; {};</a>
<a name="ln123">  template &lt;&gt; struct UnsignedInteger&lt;unsigned short&gt; {};</a>
<a name="ln124">  template &lt;&gt; struct UnsignedInteger&lt;unsigned int&gt; {};</a>
<a name="ln125">  template &lt;&gt; struct UnsignedInteger&lt;unsigned long&gt; {};</a>
<a name="ln126"># if defined(BOOST_HAS_LONG_LONG)</a>
<a name="ln127">  template &lt;&gt; struct UnsignedInteger&lt; ::boost::ulong_long_type&gt; {};</a>
<a name="ln128"># elif defined(BOOST_HAS_MS_INT64)</a>
<a name="ln129">  template &lt;&gt; struct UnsignedInteger&lt;unsigned __int64&gt; {};</a>
<a name="ln130"># endif</a>
<a name="ln131"> </a>
<a name="ln132">  //===========================================================================</a>
<a name="ln133">  // Basic Concepts</a>
<a name="ln134"> </a>
<a name="ln135">  BOOST_concept(DefaultConstructible,(TT))</a>
<a name="ln136">  {</a>
<a name="ln137">    BOOST_CONCEPT_USAGE(DefaultConstructible) {</a>
<a name="ln138">      TT a;               // require default constructor</a>
<a name="ln139">      ignore_unused_variable_warning(a);</a>
<a name="ln140">    }</a>
<a name="ln141">  };</a>
<a name="ln142"> </a>
<a name="ln143">  BOOST_concept(Assignable,(TT))</a>
<a name="ln144">  {</a>
<a name="ln145">    BOOST_CONCEPT_USAGE(Assignable) {</a>
<a name="ln146">#if !defined(_ITERATOR_) // back_insert_iterator broken for VC++ STL</a>
<a name="ln147">      a = b;             // require assignment operator</a>
<a name="ln148">#endif</a>
<a name="ln149">      const_constraints(b);</a>
<a name="ln150">    }</a>
<a name="ln151">   private:</a>
<a name="ln152">    void const_constraints(const TT&amp; x) {</a>
<a name="ln153">#if !defined(_ITERATOR_) // back_insert_iterator broken for VC++ STL</a>
<a name="ln154">      a = x;              // const required for argument to assignment</a>
<a name="ln155">#else</a>
<a name="ln156">      ignore_unused_variable_warning(x);</a>
<a name="ln157">#endif</a>
<a name="ln158">    }</a>
<a name="ln159">   private:</a>
<a name="ln160">    TT a;</a>
<a name="ln161">    TT b;</a>
<a name="ln162">  };</a>
<a name="ln163"> </a>
<a name="ln164"> </a>
<a name="ln165">  BOOST_concept(CopyConstructible,(TT))</a>
<a name="ln166">  {</a>
<a name="ln167">    BOOST_CONCEPT_USAGE(CopyConstructible) {</a>
<a name="ln168">      TT a(b);            // require copy constructor</a>
<a name="ln169">      TT* ptr = &amp;a;       // require address of operator</a>
<a name="ln170">      const_constraints(a);</a>
<a name="ln171">      ignore_unused_variable_warning(ptr);</a>
<a name="ln172">    }</a>
<a name="ln173">   private:</a>
<a name="ln174">    void const_constraints(const TT&amp; a) {</a>
<a name="ln175">      TT c(a);            // require const copy constructor</a>
<a name="ln176">      const TT* ptr = &amp;a; // require const address of operator</a>
<a name="ln177">      ignore_unused_variable_warning(c);</a>
<a name="ln178">      ignore_unused_variable_warning(ptr);</a>
<a name="ln179">    }</a>
<a name="ln180">    TT b;</a>
<a name="ln181">  };</a>
<a name="ln182"> </a>
<a name="ln183">  // The SGI STL version of Assignable requires copy constructor and operator=</a>
<a name="ln184">  BOOST_concept(SGIAssignable,(TT))</a>
<a name="ln185">  {</a>
<a name="ln186">    BOOST_CONCEPT_USAGE(SGIAssignable) {</a>
<a name="ln187">      TT c(a);</a>
<a name="ln188">#if !defined(_ITERATOR_) // back_insert_iterator broken for VC++ STL</a>
<a name="ln189">      a = b;              // require assignment operator</a>
<a name="ln190">#endif</a>
<a name="ln191">      const_constraints(b);</a>
<a name="ln192">      ignore_unused_variable_warning(c);</a>
<a name="ln193">    }</a>
<a name="ln194">   private:</a>
<a name="ln195">    void const_constraints(const TT&amp; x) {</a>
<a name="ln196">      TT c(x);</a>
<a name="ln197">#if !defined(_ITERATOR_) // back_insert_iterator broken for VC++ STL</a>
<a name="ln198">      a = x;              // const required for argument to assignment</a>
<a name="ln199">#endif</a>
<a name="ln200">      ignore_unused_variable_warning(c);</a>
<a name="ln201">    }</a>
<a name="ln202">    TT a;</a>
<a name="ln203">    TT b;</a>
<a name="ln204">  };</a>
<a name="ln205"> </a>
<a name="ln206">  BOOST_concept(Convertible,(X)(Y))</a>
<a name="ln207">  {</a>
<a name="ln208">    BOOST_CONCEPT_USAGE(Convertible) {</a>
<a name="ln209">      Y y = x;</a>
<a name="ln210">      ignore_unused_variable_warning(y);</a>
<a name="ln211">    }</a>
<a name="ln212">   private:</a>
<a name="ln213">    X x;</a>
<a name="ln214">  };</a>
<a name="ln215"> </a>
<a name="ln216">  // The C++ standard requirements for many concepts talk about return</a>
<a name="ln217">  // types that must be &quot;convertible to bool&quot;.  The problem with this</a>
<a name="ln218">  // requirement is that it leaves the door open for evil proxies that</a>
<a name="ln219">  // define things like operator|| with strange return types.  Two</a>
<a name="ln220">  // possible solutions are:</a>
<a name="ln221">  // 1) require the return type to be exactly bool</a>
<a name="ln222">  // 2) stay with convertible to bool, and also</a>
<a name="ln223">  //    specify stuff about all the logical operators.</a>
<a name="ln224">  // For now we just test for convertible to bool.</a>
<a name="ln225">  template &lt;class TT&gt;</a>
<a name="ln226">  void require_boolean_expr(const TT&amp; t) {</a>
<a name="ln227">    bool x = t;</a>
<a name="ln228">    ignore_unused_variable_warning(x);</a>
<a name="ln229">  }</a>
<a name="ln230"> </a>
<a name="ln231">  BOOST_concept(EqualityComparable,(TT))</a>
<a name="ln232">  {</a>
<a name="ln233">    BOOST_CONCEPT_USAGE(EqualityComparable) {</a>
<a name="ln234">      require_boolean_expr(a == b);</a>
<a name="ln235">      require_boolean_expr(a != b);</a>
<a name="ln236">    }</a>
<a name="ln237">   private:</a>
<a name="ln238">    TT a, b;</a>
<a name="ln239">  };</a>
<a name="ln240"> </a>
<a name="ln241">  BOOST_concept(LessThanComparable,(TT))</a>
<a name="ln242">  {</a>
<a name="ln243">    BOOST_CONCEPT_USAGE(LessThanComparable) {</a>
<a name="ln244">      require_boolean_expr(a &lt; b);</a>
<a name="ln245">    }</a>
<a name="ln246">   private:</a>
<a name="ln247">    TT a, b;</a>
<a name="ln248">  };</a>
<a name="ln249"> </a>
<a name="ln250">  // This is equivalent to SGI STL's LessThanComparable.</a>
<a name="ln251">  BOOST_concept(Comparable,(TT))</a>
<a name="ln252">  {</a>
<a name="ln253">    BOOST_CONCEPT_USAGE(Comparable) {</a>
<a name="ln254">      require_boolean_expr(a &lt; b);</a>
<a name="ln255">      require_boolean_expr(a &gt; b);</a>
<a name="ln256">      require_boolean_expr(a &lt;= b);</a>
<a name="ln257">      require_boolean_expr(a &gt;= b);</a>
<a name="ln258">    }</a>
<a name="ln259">   private:</a>
<a name="ln260">    TT a, b;</a>
<a name="ln261">  };</a>
<a name="ln262"> </a>
<a name="ln263">#define BOOST_DEFINE_BINARY_PREDICATE_OP_CONSTRAINT(OP,NAME)    \</a>
<a name="ln264">  BOOST_concept(NAME, (First)(Second))                          \</a>
<a name="ln265">  {                                                             \</a>
<a name="ln266">      BOOST_CONCEPT_USAGE(NAME) { (void)constraints_(); }                         \</a>
<a name="ln267">     private:                                                   \</a>
<a name="ln268">        bool constraints_() { return a OP b; }                  \</a>
<a name="ln269">        First a;                                                \</a>
<a name="ln270">        Second b;                                               \</a>
<a name="ln271">  }</a>
<a name="ln272"> </a>
<a name="ln273">#define BOOST_DEFINE_BINARY_OPERATOR_CONSTRAINT(OP,NAME)    \</a>
<a name="ln274">  BOOST_concept(NAME, (Ret)(First)(Second))                 \</a>
<a name="ln275">  {                                                         \</a>
<a name="ln276">      BOOST_CONCEPT_USAGE(NAME) { (void)constraints_(); }                     \</a>
<a name="ln277">  private:                                                  \</a>
<a name="ln278">      Ret constraints_() { return a OP b; }                 \</a>
<a name="ln279">      First a;                                              \</a>
<a name="ln280">      Second b;                                             \</a>
<a name="ln281">  }</a>
<a name="ln282"> </a>
<a name="ln283">  BOOST_DEFINE_BINARY_PREDICATE_OP_CONSTRAINT(==, EqualOp);</a>
<a name="ln284">  BOOST_DEFINE_BINARY_PREDICATE_OP_CONSTRAINT(!=, NotEqualOp);</a>
<a name="ln285">  BOOST_DEFINE_BINARY_PREDICATE_OP_CONSTRAINT(&lt;, LessThanOp);</a>
<a name="ln286">  BOOST_DEFINE_BINARY_PREDICATE_OP_CONSTRAINT(&lt;=, LessEqualOp);</a>
<a name="ln287">  BOOST_DEFINE_BINARY_PREDICATE_OP_CONSTRAINT(&gt;, GreaterThanOp);</a>
<a name="ln288">  BOOST_DEFINE_BINARY_PREDICATE_OP_CONSTRAINT(&gt;=, GreaterEqualOp);</a>
<a name="ln289"> </a>
<a name="ln290">  BOOST_DEFINE_BINARY_OPERATOR_CONSTRAINT(+, PlusOp);</a>
<a name="ln291">  BOOST_DEFINE_BINARY_OPERATOR_CONSTRAINT(*, TimesOp);</a>
<a name="ln292">  BOOST_DEFINE_BINARY_OPERATOR_CONSTRAINT(/, DivideOp);</a>
<a name="ln293">  BOOST_DEFINE_BINARY_OPERATOR_CONSTRAINT(-, SubtractOp);</a>
<a name="ln294">  BOOST_DEFINE_BINARY_OPERATOR_CONSTRAINT(%, ModOp);</a>
<a name="ln295"> </a>
<a name="ln296">  //===========================================================================</a>
<a name="ln297">  // Function Object Concepts</a>
<a name="ln298"> </a>
<a name="ln299">  BOOST_concept(Generator,(Func)(Return))</a>
<a name="ln300">  {</a>
<a name="ln301">      BOOST_CONCEPT_USAGE(Generator) { test(is_void&lt;Return&gt;()); }</a>
<a name="ln302"> </a>
<a name="ln303">   private:</a>
<a name="ln304">      void test(boost::false_type)</a>
<a name="ln305">      {</a>
<a name="ln306">          // Do we really want a reference here?</a>
<a name="ln307">          const Return&amp; r = f();</a>
<a name="ln308">          ignore_unused_variable_warning(r);</a>
<a name="ln309">      }</a>
<a name="ln310"> </a>
<a name="ln311">      void test(boost::true_type)</a>
<a name="ln312">      {</a>
<a name="ln313">          f();</a>
<a name="ln314">      }</a>
<a name="ln315"> </a>
<a name="ln316">      Func f;</a>
<a name="ln317">  };</a>
<a name="ln318"> </a>
<a name="ln319">  BOOST_concept(UnaryFunction,(Func)(Return)(Arg))</a>
<a name="ln320">  {</a>
<a name="ln321">      BOOST_CONCEPT_USAGE(UnaryFunction) { test(is_void&lt;Return&gt;()); }</a>
<a name="ln322"> </a>
<a name="ln323">   private:</a>
<a name="ln324">      void test(boost::false_type)</a>
<a name="ln325">      {</a>
<a name="ln326">          f(arg);               // &quot;priming the pump&quot; this way keeps msvc6 happy (ICE)</a>
<a name="ln327">          Return r = f(arg);</a>
<a name="ln328">          ignore_unused_variable_warning(r);</a>
<a name="ln329">      }</a>
<a name="ln330"> </a>
<a name="ln331">      void test(boost::true_type)</a>
<a name="ln332">      {</a>
<a name="ln333">          f(arg);</a>
<a name="ln334">      }</a>
<a name="ln335"> </a>
<a name="ln336">#if (BOOST_WORKAROUND(__GNUC__, BOOST_TESTED_AT(4) \</a>
<a name="ln337">                      &amp;&amp; BOOST_WORKAROUND(__GNUC__, &gt; 3)))</a>
<a name="ln338">      // Declare a dummy constructor to make gcc happy.</a>
<a name="ln339">      // It seems the compiler can not generate a sensible constructor when this is instantiated with a reference type.</a>
<a name="ln340">      // (warning: non-static reference &quot;const double&amp; boost::UnaryFunction&lt;YourClassHere&gt;::arg&quot;</a>
<a name="ln341">      // in class without a constructor [-Wuninitialized])</a>
<a name="ln342">      UnaryFunction();</a>
<a name="ln343">#endif</a>
<a name="ln344"> </a>
<a name="ln345">      Func f;</a>
<a name="ln346">      Arg arg;</a>
<a name="ln347">  };</a>
<a name="ln348"> </a>
<a name="ln349">  BOOST_concept(BinaryFunction,(Func)(Return)(First)(Second))</a>
<a name="ln350">  {</a>
<a name="ln351">      BOOST_CONCEPT_USAGE(BinaryFunction) { test(is_void&lt;Return&gt;()); }</a>
<a name="ln352">   private:</a>
<a name="ln353">      void test(boost::false_type)</a>
<a name="ln354">      {</a>
<a name="ln355">          f(first,second);</a>
<a name="ln356">          Return r = f(first, second); // require operator()</a>
<a name="ln357">          (void)r;</a>
<a name="ln358">      }</a>
<a name="ln359"> </a>
<a name="ln360">      void test(boost::true_type)</a>
<a name="ln361">      {</a>
<a name="ln362">          f(first,second);</a>
<a name="ln363">      }</a>
<a name="ln364"> </a>
<a name="ln365">#if (BOOST_WORKAROUND(__GNUC__, BOOST_TESTED_AT(4) \</a>
<a name="ln366">                      &amp;&amp; BOOST_WORKAROUND(__GNUC__, &gt; 3)))</a>
<a name="ln367">      // Declare a dummy constructor to make gcc happy.</a>
<a name="ln368">      // It seems the compiler can not generate a sensible constructor when this is instantiated with a reference type.</a>
<a name="ln369">      // (warning: non-static reference &quot;const double&amp; boost::BinaryFunction&lt;YourClassHere&gt;::arg&quot;</a>
<a name="ln370">      // in class without a constructor [-Wuninitialized])</a>
<a name="ln371">      BinaryFunction();</a>
<a name="ln372">#endif</a>
<a name="ln373"> </a>
<a name="ln374">      Func f;</a>
<a name="ln375">      First first;</a>
<a name="ln376">      Second second;</a>
<a name="ln377">  };</a>
<a name="ln378"> </a>
<a name="ln379">  BOOST_concept(UnaryPredicate,(Func)(Arg))</a>
<a name="ln380">  {</a>
<a name="ln381">    BOOST_CONCEPT_USAGE(UnaryPredicate) {</a>
<a name="ln382">      require_boolean_expr(f(arg)); // require operator() returning bool</a>
<a name="ln383">    }</a>
<a name="ln384">   private:</a>
<a name="ln385">#if (BOOST_WORKAROUND(__GNUC__, BOOST_TESTED_AT(4) \</a>
<a name="ln386">                      &amp;&amp; BOOST_WORKAROUND(__GNUC__, &gt; 3)))</a>
<a name="ln387">      // Declare a dummy constructor to make gcc happy.</a>
<a name="ln388">      // It seems the compiler can not generate a sensible constructor when this is instantiated with a reference type.</a>
<a name="ln389">      // (warning: non-static reference &quot;const double&amp; boost::UnaryPredicate&lt;YourClassHere&gt;::arg&quot;</a>
<a name="ln390">      // in class without a constructor [-Wuninitialized])</a>
<a name="ln391">      UnaryPredicate();</a>
<a name="ln392">#endif</a>
<a name="ln393"> </a>
<a name="ln394">    Func f;</a>
<a name="ln395">    Arg arg;</a>
<a name="ln396">  };</a>
<a name="ln397"> </a>
<a name="ln398">  BOOST_concept(BinaryPredicate,(Func)(First)(Second))</a>
<a name="ln399">  {</a>
<a name="ln400">    BOOST_CONCEPT_USAGE(BinaryPredicate) {</a>
<a name="ln401">      require_boolean_expr(f(a, b)); // require operator() returning bool</a>
<a name="ln402">    }</a>
<a name="ln403">   private:</a>
<a name="ln404">#if (BOOST_WORKAROUND(__GNUC__, BOOST_TESTED_AT(4) \</a>
<a name="ln405">                      &amp;&amp; BOOST_WORKAROUND(__GNUC__, &gt; 3)))</a>
<a name="ln406">      // Declare a dummy constructor to make gcc happy.</a>
<a name="ln407">      // It seems the compiler can not generate a sensible constructor when this is instantiated with a reference type.</a>
<a name="ln408">      // (warning: non-static reference &quot;const double&amp; boost::BinaryPredicate&lt;YourClassHere&gt;::arg&quot;</a>
<a name="ln409">      // in class without a constructor [-Wuninitialized])</a>
<a name="ln410">      BinaryPredicate();</a>
<a name="ln411">#endif</a>
<a name="ln412">    Func f;</a>
<a name="ln413">    First a;</a>
<a name="ln414">    Second b;</a>
<a name="ln415">  };</a>
<a name="ln416"> </a>
<a name="ln417">  // use this when functor is used inside a container class like std::set</a>
<a name="ln418">  BOOST_concept(Const_BinaryPredicate,(Func)(First)(Second))</a>
<a name="ln419">    : BinaryPredicate&lt;Func, First, Second&gt;</a>
<a name="ln420">  {</a>
<a name="ln421">    BOOST_CONCEPT_USAGE(Const_BinaryPredicate) {</a>
<a name="ln422">      const_constraints(f);</a>
<a name="ln423">    }</a>
<a name="ln424">   private:</a>
<a name="ln425">    void const_constraints(const Func&amp; fun) {</a>
<a name="ln426">      // operator() must be a const member function</a>
<a name="ln427">      require_boolean_expr(fun(a, b));</a>
<a name="ln428">    }</a>
<a name="ln429">#if (BOOST_WORKAROUND(__GNUC__, BOOST_TESTED_AT(4) \</a>
<a name="ln430">                      &amp;&amp; BOOST_WORKAROUND(__GNUC__, &gt; 3)))</a>
<a name="ln431">      // Declare a dummy constructor to make gcc happy.</a>
<a name="ln432">      // It seems the compiler can not generate a sensible constructor when this is instantiated with a reference type.</a>
<a name="ln433">      // (warning: non-static reference &quot;const double&amp; boost::Const_BinaryPredicate&lt;YourClassHere&gt;::arg&quot;</a>
<a name="ln434">      // in class without a constructor [-Wuninitialized])</a>
<a name="ln435">      Const_BinaryPredicate();</a>
<a name="ln436">#endif</a>
<a name="ln437"> </a>
<a name="ln438">    Func f;</a>
<a name="ln439">    First a;</a>
<a name="ln440">    Second b;</a>
<a name="ln441">  };</a>
<a name="ln442"> </a>
<a name="ln443">  BOOST_concept(AdaptableGenerator,(Func)(Return))</a>
<a name="ln444">    : Generator&lt;Func, typename Func::result_type&gt;</a>
<a name="ln445">  {</a>
<a name="ln446">      typedef typename Func::result_type result_type;</a>
<a name="ln447"> </a>
<a name="ln448">      BOOST_CONCEPT_USAGE(AdaptableGenerator)</a>
<a name="ln449">      {</a>
<a name="ln450">          BOOST_CONCEPT_ASSERT((Convertible&lt;result_type, Return&gt;));</a>
<a name="ln451">      }</a>
<a name="ln452">  };</a>
<a name="ln453"> </a>
<a name="ln454">  BOOST_concept(AdaptableUnaryFunction,(Func)(Return)(Arg))</a>
<a name="ln455">    : UnaryFunction&lt;Func, typename Func::result_type, typename Func::argument_type&gt;</a>
<a name="ln456">  {</a>
<a name="ln457">      typedef typename Func::argument_type argument_type;</a>
<a name="ln458">      typedef typename Func::result_type result_type;</a>
<a name="ln459"> </a>
<a name="ln460">      ~AdaptableUnaryFunction()</a>
<a name="ln461">      {</a>
<a name="ln462">          BOOST_CONCEPT_ASSERT((Convertible&lt;result_type, Return&gt;));</a>
<a name="ln463">          BOOST_CONCEPT_ASSERT((Convertible&lt;Arg, argument_type&gt;));</a>
<a name="ln464">      }</a>
<a name="ln465">  };</a>
<a name="ln466"> </a>
<a name="ln467">  BOOST_concept(AdaptableBinaryFunction,(Func)(Return)(First)(Second))</a>
<a name="ln468">    : BinaryFunction&lt;</a>
<a name="ln469">          Func</a>
<a name="ln470">        , typename Func::result_type</a>
<a name="ln471">        , typename Func::first_argument_type</a>
<a name="ln472">        , typename Func::second_argument_type</a>
<a name="ln473">      &gt;</a>
<a name="ln474">  {</a>
<a name="ln475">      typedef typename Func::first_argument_type first_argument_type;</a>
<a name="ln476">      typedef typename Func::second_argument_type second_argument_type;</a>
<a name="ln477">      typedef typename Func::result_type result_type;</a>
<a name="ln478"> </a>
<a name="ln479">      ~AdaptableBinaryFunction()</a>
<a name="ln480">      {</a>
<a name="ln481">          BOOST_CONCEPT_ASSERT((Convertible&lt;result_type, Return&gt;));</a>
<a name="ln482">          BOOST_CONCEPT_ASSERT((Convertible&lt;First, first_argument_type&gt;));</a>
<a name="ln483">          BOOST_CONCEPT_ASSERT((Convertible&lt;Second, second_argument_type&gt;));</a>
<a name="ln484">      }</a>
<a name="ln485">  };</a>
<a name="ln486"> </a>
<a name="ln487">  BOOST_concept(AdaptablePredicate,(Func)(Arg))</a>
<a name="ln488">    : UnaryPredicate&lt;Func, Arg&gt;</a>
<a name="ln489">    , AdaptableUnaryFunction&lt;Func, bool, Arg&gt;</a>
<a name="ln490">  {</a>
<a name="ln491">  };</a>
<a name="ln492"> </a>
<a name="ln493">  BOOST_concept(AdaptableBinaryPredicate,(Func)(First)(Second))</a>
<a name="ln494">    : BinaryPredicate&lt;Func, First, Second&gt;</a>
<a name="ln495">    , AdaptableBinaryFunction&lt;Func, bool, First, Second&gt;</a>
<a name="ln496">  {</a>
<a name="ln497">  };</a>
<a name="ln498"> </a>
<a name="ln499">  //===========================================================================</a>
<a name="ln500">  // Iterator Concepts</a>
<a name="ln501"> </a>
<a name="ln502">  BOOST_concept(InputIterator,(TT))</a>
<a name="ln503">    : Assignable&lt;TT&gt;</a>
<a name="ln504">    , EqualityComparable&lt;TT&gt;</a>
<a name="ln505">  {</a>
<a name="ln506">      typedef typename std::iterator_traits&lt;TT&gt;::value_type value_type;</a>
<a name="ln507">      typedef typename std::iterator_traits&lt;TT&gt;::difference_type difference_type;</a>
<a name="ln508">      typedef typename std::iterator_traits&lt;TT&gt;::reference reference;</a>
<a name="ln509">      typedef typename std::iterator_traits&lt;TT&gt;::pointer pointer;</a>
<a name="ln510">      typedef typename std::iterator_traits&lt;TT&gt;::iterator_category iterator_category;</a>
<a name="ln511"> </a>
<a name="ln512">      BOOST_CONCEPT_USAGE(InputIterator)</a>
<a name="ln513">      {</a>
<a name="ln514">        BOOST_CONCEPT_ASSERT((SignedInteger&lt;difference_type&gt;));</a>
<a name="ln515">        BOOST_CONCEPT_ASSERT((Convertible&lt;iterator_category, std::input_iterator_tag&gt;));</a>
<a name="ln516"> </a>
<a name="ln517">        TT j(i);</a>
<a name="ln518">        (void)*i;           // require dereference operator</a>
<a name="ln519">        ++j;                // require preincrement operator</a>
<a name="ln520">        i++;                // require postincrement operator</a>
<a name="ln521">      }</a>
<a name="ln522">   private:</a>
<a name="ln523">    TT i;</a>
<a name="ln524">  };</a>
<a name="ln525"> </a>
<a name="ln526">  BOOST_concept(OutputIterator,(TT)(ValueT))</a>
<a name="ln527">    : Assignable&lt;TT&gt;</a>
<a name="ln528">  {</a>
<a name="ln529">    BOOST_CONCEPT_USAGE(OutputIterator) {</a>
<a name="ln530"> </a>
<a name="ln531">      ++i;                // require preincrement operator</a>
<a name="ln532">      i++;                // require postincrement operator</a>
<a name="ln533">      *i++ = t;           // require postincrement and assignment</a>
<a name="ln534">    }</a>
<a name="ln535">   private:</a>
<a name="ln536">    TT i, j;</a>
<a name="ln537">    ValueT t;</a>
<a name="ln538">  };</a>
<a name="ln539"> </a>
<a name="ln540">  BOOST_concept(ForwardIterator,(TT))</a>
<a name="ln541">    : InputIterator&lt;TT&gt;</a>
<a name="ln542">  {</a>
<a name="ln543">      BOOST_CONCEPT_USAGE(ForwardIterator)</a>
<a name="ln544">      {</a>
<a name="ln545">          BOOST_CONCEPT_ASSERT((Convertible&lt;</a>
<a name="ln546">              BOOST_DEDUCED_TYPENAME ForwardIterator::iterator_category</a>
<a name="ln547">            , std::forward_iterator_tag</a>
<a name="ln548">          &gt;));</a>
<a name="ln549"> </a>
<a name="ln550">          typename InputIterator&lt;TT&gt;::reference r = *i;</a>
<a name="ln551">          ignore_unused_variable_warning(r);</a>
<a name="ln552">      }</a>
<a name="ln553"> </a>
<a name="ln554">   private:</a>
<a name="ln555">      TT i;</a>
<a name="ln556">  };</a>
<a name="ln557"> </a>
<a name="ln558">  BOOST_concept(Mutable_ForwardIterator,(TT))</a>
<a name="ln559">    : ForwardIterator&lt;TT&gt;</a>
<a name="ln560">  {</a>
<a name="ln561">      BOOST_CONCEPT_USAGE(Mutable_ForwardIterator) {</a>
<a name="ln562">        *i++ = *j;         // require postincrement and assignment</a>
<a name="ln563">      }</a>
<a name="ln564">   private:</a>
<a name="ln565">      TT i, j;</a>
<a name="ln566">  };</a>
<a name="ln567"> </a>
<a name="ln568">  BOOST_concept(BidirectionalIterator,(TT))</a>
<a name="ln569">    : ForwardIterator&lt;TT&gt;</a>
<a name="ln570">  {</a>
<a name="ln571">      BOOST_CONCEPT_USAGE(BidirectionalIterator)</a>
<a name="ln572">      {</a>
<a name="ln573">          BOOST_CONCEPT_ASSERT((Convertible&lt;</a>
<a name="ln574">              BOOST_DEDUCED_TYPENAME BidirectionalIterator::iterator_category</a>
<a name="ln575">            , std::bidirectional_iterator_tag</a>
<a name="ln576">          &gt;));</a>
<a name="ln577"> </a>
<a name="ln578">          --i;                // require predecrement operator</a>
<a name="ln579">          i--;                // require postdecrement operator</a>
<a name="ln580">      }</a>
<a name="ln581">   private:</a>
<a name="ln582">      TT i;</a>
<a name="ln583">  };</a>
<a name="ln584"> </a>
<a name="ln585">  BOOST_concept(Mutable_BidirectionalIterator,(TT))</a>
<a name="ln586">    : BidirectionalIterator&lt;TT&gt;</a>
<a name="ln587">    , Mutable_ForwardIterator&lt;TT&gt;</a>
<a name="ln588">  {</a>
<a name="ln589">      BOOST_CONCEPT_USAGE(Mutable_BidirectionalIterator)</a>
<a name="ln590">      {</a>
<a name="ln591">          *i-- = *j;                  // require postdecrement and assignment</a>
<a name="ln592">      }</a>
<a name="ln593">   private:</a>
<a name="ln594">      TT i, j;</a>
<a name="ln595">  };</a>
<a name="ln596"> </a>
<a name="ln597">  BOOST_concept(RandomAccessIterator,(TT))</a>
<a name="ln598">    : BidirectionalIterator&lt;TT&gt;</a>
<a name="ln599">    , Comparable&lt;TT&gt;</a>
<a name="ln600">  {</a>
<a name="ln601">      BOOST_CONCEPT_USAGE(RandomAccessIterator)</a>
<a name="ln602">      {</a>
<a name="ln603">          BOOST_CONCEPT_ASSERT((Convertible&lt;</a>
<a name="ln604">              BOOST_DEDUCED_TYPENAME BidirectionalIterator&lt;TT&gt;::iterator_category</a>
<a name="ln605">            , std::random_access_iterator_tag</a>
<a name="ln606">          &gt;));</a>
<a name="ln607"> </a>
<a name="ln608">          i += n;             // require assignment addition operator</a>
<a name="ln609">          i = i + n; i = n + i; // require addition with difference type</a>
<a name="ln610">          i -= n;             // require assignment subtraction operator</a>
<a name="ln611">          i = i - n;                  // require subtraction with difference type</a>
<a name="ln612">          n = i - j;                  // require difference operator</a>
<a name="ln613">          (void)i[n];                 // require element access operator</a>
<a name="ln614">      }</a>
<a name="ln615"> </a>
<a name="ln616">   private:</a>
<a name="ln617">    TT a, b;</a>
<a name="ln618">    TT i, j;</a>
<a name="ln619">      typename std::iterator_traits&lt;TT&gt;::difference_type n;</a>
<a name="ln620">  };</a>
<a name="ln621"> </a>
<a name="ln622">  BOOST_concept(Mutable_RandomAccessIterator,(TT))</a>
<a name="ln623">    : RandomAccessIterator&lt;TT&gt;</a>
<a name="ln624">    , Mutable_BidirectionalIterator&lt;TT&gt;</a>
<a name="ln625">  {</a>
<a name="ln626">      BOOST_CONCEPT_USAGE(Mutable_RandomAccessIterator)</a>
<a name="ln627">      {</a>
<a name="ln628">          i[n] = *i;                  // require element access and assignment</a>
<a name="ln629">      }</a>
<a name="ln630">   private:</a>
<a name="ln631">    TT i;</a>
<a name="ln632">    typename std::iterator_traits&lt;TT&gt;::difference_type n;</a>
<a name="ln633">  };</a>
<a name="ln634"> </a>
<a name="ln635">  //===========================================================================</a>
<a name="ln636">  // Container s</a>
<a name="ln637"> </a>
<a name="ln638">  BOOST_concept(Container,(C))</a>
<a name="ln639">    : Assignable&lt;C&gt;</a>
<a name="ln640">  {</a>
<a name="ln641">    typedef typename C::value_type value_type;</a>
<a name="ln642">    typedef typename C::difference_type difference_type;</a>
<a name="ln643">    typedef typename C::size_type size_type;</a>
<a name="ln644">    typedef typename C::const_reference const_reference;</a>
<a name="ln645">    typedef typename C::const_pointer const_pointer;</a>
<a name="ln646">    typedef typename C::const_iterator const_iterator;</a>
<a name="ln647"> </a>
<a name="ln648">      BOOST_CONCEPT_USAGE(Container)</a>
<a name="ln649">      {</a>
<a name="ln650">          BOOST_CONCEPT_ASSERT((InputIterator&lt;const_iterator&gt;));</a>
<a name="ln651">          const_constraints(c);</a>
<a name="ln652">      }</a>
<a name="ln653"> </a>
<a name="ln654">   private:</a>
<a name="ln655">      void const_constraints(const C&amp; cc) {</a>
<a name="ln656">          i = cc.begin();</a>
<a name="ln657">          i = cc.end();</a>
<a name="ln658">          n = cc.size();</a>
<a name="ln659">          n = cc.max_size();</a>
<a name="ln660">          b = cc.empty();</a>
<a name="ln661">      }</a>
<a name="ln662">      C c;</a>
<a name="ln663">      bool b;</a>
<a name="ln664">      const_iterator i;</a>
<a name="ln665">      size_type n;</a>
<a name="ln666">  };</a>
<a name="ln667"> </a>
<a name="ln668">  BOOST_concept(Mutable_Container,(C))</a>
<a name="ln669">    : Container&lt;C&gt;</a>
<a name="ln670">  {</a>
<a name="ln671">      typedef typename C::reference reference;</a>
<a name="ln672">      typedef typename C::iterator iterator;</a>
<a name="ln673">      typedef typename C::pointer pointer;</a>
<a name="ln674"> </a>
<a name="ln675">      BOOST_CONCEPT_USAGE(Mutable_Container)</a>
<a name="ln676">      {</a>
<a name="ln677">          BOOST_CONCEPT_ASSERT((</a>
<a name="ln678">               Assignable&lt;typename Mutable_Container::value_type&gt;));</a>
<a name="ln679"> </a>
<a name="ln680">          BOOST_CONCEPT_ASSERT((InputIterator&lt;iterator&gt;));</a>
<a name="ln681"> </a>
<a name="ln682">          i = c.begin();</a>
<a name="ln683">          i = c.end();</a>
<a name="ln684">          c.swap(c2);</a>
<a name="ln685">      }</a>
<a name="ln686"> </a>
<a name="ln687">   private:</a>
<a name="ln688">      iterator i;</a>
<a name="ln689">      C c, c2;</a>
<a name="ln690">  };</a>
<a name="ln691"> </a>
<a name="ln692">  BOOST_concept(ForwardContainer,(C))</a>
<a name="ln693">    : Container&lt;C&gt;</a>
<a name="ln694">  {</a>
<a name="ln695">      BOOST_CONCEPT_USAGE(ForwardContainer)</a>
<a name="ln696">      {</a>
<a name="ln697">          BOOST_CONCEPT_ASSERT((</a>
<a name="ln698">               ForwardIterator&lt;</a>
<a name="ln699">                    typename ForwardContainer::const_iterator</a>
<a name="ln700">               &gt;));</a>
<a name="ln701">      }</a>
<a name="ln702">  };</a>
<a name="ln703"> </a>
<a name="ln704">  BOOST_concept(Mutable_ForwardContainer,(C))</a>
<a name="ln705">    : ForwardContainer&lt;C&gt;</a>
<a name="ln706">    , Mutable_Container&lt;C&gt;</a>
<a name="ln707">  {</a>
<a name="ln708">      BOOST_CONCEPT_USAGE(Mutable_ForwardContainer)</a>
<a name="ln709">      {</a>
<a name="ln710">          BOOST_CONCEPT_ASSERT((</a>
<a name="ln711">               Mutable_ForwardIterator&lt;</a>
<a name="ln712">                   typename Mutable_ForwardContainer::iterator</a>
<a name="ln713">               &gt;));</a>
<a name="ln714">      }</a>
<a name="ln715">  };</a>
<a name="ln716"> </a>
<a name="ln717">  BOOST_concept(ReversibleContainer,(C))</a>
<a name="ln718">    : ForwardContainer&lt;C&gt;</a>
<a name="ln719">  {</a>
<a name="ln720">      typedef typename</a>
<a name="ln721">        C::const_reverse_iterator</a>
<a name="ln722">      const_reverse_iterator;</a>
<a name="ln723"> </a>
<a name="ln724">      BOOST_CONCEPT_USAGE(ReversibleContainer)</a>
<a name="ln725">      {</a>
<a name="ln726">          BOOST_CONCEPT_ASSERT((</a>
<a name="ln727">              BidirectionalIterator&lt;</a>
<a name="ln728">                  typename ReversibleContainer::const_iterator&gt;));</a>
<a name="ln729"> </a>
<a name="ln730">          BOOST_CONCEPT_ASSERT((BidirectionalIterator&lt;const_reverse_iterator&gt;));</a>
<a name="ln731"> </a>
<a name="ln732">          const_constraints(c);</a>
<a name="ln733">      }</a>
<a name="ln734">   private:</a>
<a name="ln735">      void const_constraints(const C&amp; cc)</a>
<a name="ln736">      {</a>
<a name="ln737">          const_reverse_iterator _i = cc.rbegin();</a>
<a name="ln738">          _i = cc.rend();</a>
<a name="ln739">      }</a>
<a name="ln740">      C c;</a>
<a name="ln741">  };</a>
<a name="ln742"> </a>
<a name="ln743">  BOOST_concept(Mutable_ReversibleContainer,(C))</a>
<a name="ln744">    : Mutable_ForwardContainer&lt;C&gt;</a>
<a name="ln745">    , ReversibleContainer&lt;C&gt;</a>
<a name="ln746">  {</a>
<a name="ln747">      typedef typename C::reverse_iterator reverse_iterator;</a>
<a name="ln748"> </a>
<a name="ln749">      BOOST_CONCEPT_USAGE(Mutable_ReversibleContainer)</a>
<a name="ln750">      {</a>
<a name="ln751">          typedef typename Mutable_ForwardContainer&lt;C&gt;::iterator iterator;</a>
<a name="ln752">          BOOST_CONCEPT_ASSERT((Mutable_BidirectionalIterator&lt;iterator&gt;));</a>
<a name="ln753">          BOOST_CONCEPT_ASSERT((Mutable_BidirectionalIterator&lt;reverse_iterator&gt;));</a>
<a name="ln754"> </a>
<a name="ln755">          reverse_iterator i = c.rbegin();</a>
<a name="ln756">          i = c.rend();</a>
<a name="ln757">      }</a>
<a name="ln758">   private:</a>
<a name="ln759">      C c;</a>
<a name="ln760">  };</a>
<a name="ln761"> </a>
<a name="ln762">  BOOST_concept(RandomAccessContainer,(C))</a>
<a name="ln763">    : ReversibleContainer&lt;C&gt;</a>
<a name="ln764">  {</a>
<a name="ln765">      typedef typename C::size_type size_type;</a>
<a name="ln766">      typedef typename C::const_reference const_reference;</a>
<a name="ln767"> </a>
<a name="ln768">      BOOST_CONCEPT_USAGE(RandomAccessContainer)</a>
<a name="ln769">      {</a>
<a name="ln770">          BOOST_CONCEPT_ASSERT((</a>
<a name="ln771">              RandomAccessIterator&lt;</a>
<a name="ln772">                  typename RandomAccessContainer::const_iterator</a>
<a name="ln773">              &gt;));</a>
<a name="ln774"> </a>
<a name="ln775">          const_constraints(c);</a>
<a name="ln776">      }</a>
<a name="ln777">   private:</a>
<a name="ln778">      void const_constraints(const C&amp; cc)</a>
<a name="ln779">      {</a>
<a name="ln780">          const_reference r = cc[n];</a>
<a name="ln781">          ignore_unused_variable_warning(r);</a>
<a name="ln782">      }</a>
<a name="ln783"> </a>
<a name="ln784">      C c;</a>
<a name="ln785">      size_type n;</a>
<a name="ln786">  };</a>
<a name="ln787"> </a>
<a name="ln788">  BOOST_concept(Mutable_RandomAccessContainer,(C))</a>
<a name="ln789">    : Mutable_ReversibleContainer&lt;C&gt;</a>
<a name="ln790">    , RandomAccessContainer&lt;C&gt;</a>
<a name="ln791">  {</a>
<a name="ln792">   private:</a>
<a name="ln793">      typedef Mutable_RandomAccessContainer self;</a>
<a name="ln794">   public:</a>
<a name="ln795">      BOOST_CONCEPT_USAGE(Mutable_RandomAccessContainer)</a>
<a name="ln796">      {</a>
<a name="ln797">          BOOST_CONCEPT_ASSERT((Mutable_RandomAccessIterator&lt;typename self::iterator&gt;));</a>
<a name="ln798">          BOOST_CONCEPT_ASSERT((Mutable_RandomAccessIterator&lt;typename self::reverse_iterator&gt;));</a>
<a name="ln799"> </a>
<a name="ln800">          typename self::reference r = c[i];</a>
<a name="ln801">          ignore_unused_variable_warning(r);</a>
<a name="ln802">      }</a>
<a name="ln803"> </a>
<a name="ln804">   private:</a>
<a name="ln805">      typename Mutable_ReversibleContainer&lt;C&gt;::size_type i;</a>
<a name="ln806">      C c;</a>
<a name="ln807">  };</a>
<a name="ln808"> </a>
<a name="ln809">  // A Sequence is inherently mutable</a>
<a name="ln810">  BOOST_concept(Sequence,(S))</a>
<a name="ln811">    : Mutable_ForwardContainer&lt;S&gt;</a>
<a name="ln812">      // Matt Austern's book puts DefaultConstructible here, the C++</a>
<a name="ln813">      // standard places it in Container --JGS</a>
<a name="ln814">      // ... so why aren't we following the standard?  --DWA</a>
<a name="ln815">    , DefaultConstructible&lt;S&gt;</a>
<a name="ln816">  {</a>
<a name="ln817">      BOOST_CONCEPT_USAGE(Sequence)</a>
<a name="ln818">      {</a>
<a name="ln819">          S</a>
<a name="ln820">              c(n, t),</a>
<a name="ln821">              c2(first, last);</a>
<a name="ln822"> </a>
<a name="ln823">          c.insert(p, t);</a>
<a name="ln824">          c.insert(p, n, t);</a>
<a name="ln825">          c.insert(p, first, last);</a>
<a name="ln826"> </a>
<a name="ln827">          c.erase(p);</a>
<a name="ln828">          c.erase(p, q);</a>
<a name="ln829"> </a>
<a name="ln830">          typename Sequence::reference r = c.front();</a>
<a name="ln831"> </a>
<a name="ln832">          ignore_unused_variable_warning(c);</a>
<a name="ln833">          ignore_unused_variable_warning(c2);</a>
<a name="ln834">          ignore_unused_variable_warning(r);</a>
<a name="ln835">          const_constraints(c);</a>
<a name="ln836">      }</a>
<a name="ln837">   private:</a>
<a name="ln838">      void const_constraints(const S&amp; c) {</a>
<a name="ln839">          typename Sequence::const_reference r = c.front();</a>
<a name="ln840">          ignore_unused_variable_warning(r);</a>
<a name="ln841">      }</a>
<a name="ln842"> </a>
<a name="ln843">      typename S::value_type t;</a>
<a name="ln844">      typename S::size_type n;</a>
<a name="ln845">      typename S::value_type* first, *last;</a>
<a name="ln846">      typename S::iterator p, q;</a>
<a name="ln847">  };</a>
<a name="ln848"> </a>
<a name="ln849">  BOOST_concept(FrontInsertionSequence,(S))</a>
<a name="ln850">    : Sequence&lt;S&gt;</a>
<a name="ln851">  {</a>
<a name="ln852">      BOOST_CONCEPT_USAGE(FrontInsertionSequence)</a>
<a name="ln853">      {</a>
<a name="ln854">          c.push_front(t);</a>
<a name="ln855">          c.pop_front();</a>
<a name="ln856">      }</a>
<a name="ln857">   private:</a>
<a name="ln858">      S c;</a>
<a name="ln859">      typename S::value_type t;</a>
<a name="ln860">  };</a>
<a name="ln861"> </a>
<a name="ln862">  BOOST_concept(BackInsertionSequence,(S))</a>
<a name="ln863">    : Sequence&lt;S&gt;</a>
<a name="ln864">  {</a>
<a name="ln865">      BOOST_CONCEPT_USAGE(BackInsertionSequence)</a>
<a name="ln866">      {</a>
<a name="ln867">          c.push_back(t);</a>
<a name="ln868">          c.pop_back();</a>
<a name="ln869">          typename BackInsertionSequence::reference r = c.back();</a>
<a name="ln870">          ignore_unused_variable_warning(r);</a>
<a name="ln871">          const_constraints(c);</a>
<a name="ln872">      }</a>
<a name="ln873">   private:</a>
<a name="ln874">      void const_constraints(const S&amp; cc) {</a>
<a name="ln875">          typename BackInsertionSequence::const_reference</a>
<a name="ln876">              r = cc.back();</a>
<a name="ln877">          ignore_unused_variable_warning(r);</a>
<a name="ln878">      }</a>
<a name="ln879">      S c;</a>
<a name="ln880">      typename S::value_type t;</a>
<a name="ln881">  };</a>
<a name="ln882"> </a>
<a name="ln883">  BOOST_concept(AssociativeContainer,(C))</a>
<a name="ln884">    : ForwardContainer&lt;C&gt;</a>
<a name="ln885">    , DefaultConstructible&lt;C&gt;</a>
<a name="ln886">  {</a>
<a name="ln887">      typedef typename C::key_type key_type;</a>
<a name="ln888">      typedef typename C::key_compare key_compare;</a>
<a name="ln889">      typedef typename C::value_compare value_compare;</a>
<a name="ln890">      typedef typename C::iterator iterator;</a>
<a name="ln891"> </a>
<a name="ln892">      BOOST_CONCEPT_USAGE(AssociativeContainer)</a>
<a name="ln893">      {</a>
<a name="ln894">          i = c.find(k);</a>
<a name="ln895">          r = c.equal_range(k);</a>
<a name="ln896">          c.erase(k);</a>
<a name="ln897">          c.erase(i);</a>
<a name="ln898">          c.erase(r.first, r.second);</a>
<a name="ln899">          const_constraints(c);</a>
<a name="ln900">          BOOST_CONCEPT_ASSERT((BinaryPredicate&lt;key_compare,key_type,key_type&gt;));</a>
<a name="ln901"> </a>
<a name="ln902">          typedef typename AssociativeContainer::value_type value_type_;</a>
<a name="ln903">          BOOST_CONCEPT_ASSERT((BinaryPredicate&lt;value_compare,value_type_,value_type_&gt;));</a>
<a name="ln904">      }</a>
<a name="ln905"> </a>
<a name="ln906">      // Redundant with the base concept, but it helps below.</a>
<a name="ln907">      typedef typename C::const_iterator const_iterator;</a>
<a name="ln908">   private:</a>
<a name="ln909">      void const_constraints(const C&amp; cc)</a>
<a name="ln910">      {</a>
<a name="ln911">          ci = cc.find(k);</a>
<a name="ln912">          n = cc.count(k);</a>
<a name="ln913">          cr = cc.equal_range(k);</a>
<a name="ln914">      }</a>
<a name="ln915"> </a>
<a name="ln916">      C c;</a>
<a name="ln917">      iterator i;</a>
<a name="ln918">      std::pair&lt;iterator,iterator&gt; r;</a>
<a name="ln919">      const_iterator ci;</a>
<a name="ln920">      std::pair&lt;const_iterator,const_iterator&gt; cr;</a>
<a name="ln921">      typename C::key_type k;</a>
<a name="ln922">      typename C::size_type n;</a>
<a name="ln923">  };</a>
<a name="ln924"> </a>
<a name="ln925">  BOOST_concept(UniqueAssociativeContainer,(C))</a>
<a name="ln926">    : AssociativeContainer&lt;C&gt;</a>
<a name="ln927">  {</a>
<a name="ln928">      BOOST_CONCEPT_USAGE(UniqueAssociativeContainer)</a>
<a name="ln929">      {</a>
<a name="ln930">          C c(first, last);</a>
<a name="ln931"> </a>
<a name="ln932">          pos_flag = c.insert(t);</a>
<a name="ln933">          c.insert(first, last);</a>
<a name="ln934"> </a>
<a name="ln935">          ignore_unused_variable_warning(c);</a>
<a name="ln936">      }</a>
<a name="ln937">   private:</a>
<a name="ln938">      std::pair&lt;typename C::iterator, bool&gt; pos_flag;</a>
<a name="ln939">      typename C::value_type t;</a>
<a name="ln940">      typename C::value_type* first, *last;</a>
<a name="ln941">  };</a>
<a name="ln942"> </a>
<a name="ln943">  BOOST_concept(MultipleAssociativeContainer,(C))</a>
<a name="ln944">    : AssociativeContainer&lt;C&gt;</a>
<a name="ln945">  {</a>
<a name="ln946">      BOOST_CONCEPT_USAGE(MultipleAssociativeContainer)</a>
<a name="ln947">      {</a>
<a name="ln948">          C c(first, last);</a>
<a name="ln949"> </a>
<a name="ln950">          pos = c.insert(t);</a>
<a name="ln951">          c.insert(first, last);</a>
<a name="ln952"> </a>
<a name="ln953">          ignore_unused_variable_warning(c);</a>
<a name="ln954">          ignore_unused_variable_warning(pos);</a>
<a name="ln955">      }</a>
<a name="ln956">   private:</a>
<a name="ln957">      typename C::iterator pos;</a>
<a name="ln958">      typename C::value_type t;</a>
<a name="ln959">      typename C::value_type* first, *last;</a>
<a name="ln960">  };</a>
<a name="ln961"> </a>
<a name="ln962">  BOOST_concept(SimpleAssociativeContainer,(C))</a>
<a name="ln963">    : AssociativeContainer&lt;C&gt;</a>
<a name="ln964">  {</a>
<a name="ln965">      BOOST_CONCEPT_USAGE(SimpleAssociativeContainer)</a>
<a name="ln966">      {</a>
<a name="ln967">          typedef typename C::key_type key_type;</a>
<a name="ln968">          typedef typename C::value_type value_type;</a>
<a name="ln969">          BOOST_STATIC_ASSERT((boost::is_same&lt;key_type,value_type&gt;::value));</a>
<a name="ln970">      }</a>
<a name="ln971">  };</a>
<a name="ln972"> </a>
<a name="ln973">  BOOST_concept(PairAssociativeContainer,(C))</a>
<a name="ln974">    : AssociativeContainer&lt;C&gt;</a>
<a name="ln975">  {</a>
<a name="ln976">      BOOST_CONCEPT_USAGE(PairAssociativeContainer)</a>
<a name="ln977">      {</a>
<a name="ln978">          typedef typename C::key_type key_type;</a>
<a name="ln979">          typedef typename C::value_type value_type;</a>
<a name="ln980">          typedef typename C::mapped_type mapped_type;</a>
<a name="ln981">          typedef std::pair&lt;const key_type, mapped_type&gt; required_value_type;</a>
<a name="ln982">          BOOST_STATIC_ASSERT((boost::is_same&lt;value_type,required_value_type&gt;::value));</a>
<a name="ln983">      }</a>
<a name="ln984">  };</a>
<a name="ln985"> </a>
<a name="ln986">  BOOST_concept(SortedAssociativeContainer,(C))</a>
<a name="ln987">    : AssociativeContainer&lt;C&gt;</a>
<a name="ln988">    , ReversibleContainer&lt;C&gt;</a>
<a name="ln989">  {</a>
<a name="ln990">      BOOST_CONCEPT_USAGE(SortedAssociativeContainer)</a>
<a name="ln991">      {</a>
<a name="ln992">          C</a>
<a name="ln993">              c(kc),</a>
<a name="ln994">              c2(first, last),</a>
<a name="ln995">              c3(first, last, kc);</a>
<a name="ln996"> </a>
<a name="ln997">          p = c.upper_bound(k);</a>
<a name="ln998">          p = c.lower_bound(k);</a>
<a name="ln999">          r = c.equal_range(k);</a>
<a name="ln1000"> </a>
<a name="ln1001">          c.insert(p, t);</a>
<a name="ln1002"> </a>
<a name="ln1003">          ignore_unused_variable_warning(c);</a>
<a name="ln1004">          ignore_unused_variable_warning(c2);</a>
<a name="ln1005">          ignore_unused_variable_warning(c3);</a>
<a name="ln1006">          const_constraints(c);</a>
<a name="ln1007">      }</a>
<a name="ln1008"> </a>
<a name="ln1009">      void const_constraints(const C&amp; c)</a>
<a name="ln1010">      {</a>
<a name="ln1011">          kc = c.key_comp();</a>
<a name="ln1012">          vc = c.value_comp();</a>
<a name="ln1013"> </a>
<a name="ln1014">          cp = c.upper_bound(k);</a>
<a name="ln1015">          cp = c.lower_bound(k);</a>
<a name="ln1016">          cr = c.equal_range(k);</a>
<a name="ln1017">      }</a>
<a name="ln1018"> </a>
<a name="ln1019">   private:</a>
<a name="ln1020">      typename C::key_compare kc;</a>
<a name="ln1021">      typename C::value_compare vc;</a>
<a name="ln1022">      typename C::value_type t;</a>
<a name="ln1023">      typename C::key_type k;</a>
<a name="ln1024">      typedef typename C::iterator iterator;</a>
<a name="ln1025">      typedef typename C::const_iterator const_iterator;</a>
<a name="ln1026"> </a>
<a name="ln1027">      typedef SortedAssociativeContainer self;</a>
<a name="ln1028">      iterator p;</a>
<a name="ln1029">      const_iterator cp;</a>
<a name="ln1030">      std::pair&lt;typename self::iterator,typename self::iterator&gt; r;</a>
<a name="ln1031">      std::pair&lt;typename self::const_iterator,typename self::const_iterator&gt; cr;</a>
<a name="ln1032">      typename C::value_type* first, *last;</a>
<a name="ln1033">  };</a>
<a name="ln1034"> </a>
<a name="ln1035">  // HashedAssociativeContainer</a>
<a name="ln1036"> </a>
<a name="ln1037">  BOOST_concept(Collection,(C))</a>
<a name="ln1038">  {</a>
<a name="ln1039">      BOOST_CONCEPT_USAGE(Collection)</a>
<a name="ln1040">      {</a>
<a name="ln1041">        boost::function_requires&lt;boost::InputIteratorConcept&lt;iterator&gt; &gt;();</a>
<a name="ln1042">        boost::function_requires&lt;boost::InputIteratorConcept&lt;const_iterator&gt; &gt;();</a>
<a name="ln1043">        boost::function_requires&lt;boost::CopyConstructibleConcept&lt;value_type&gt; &gt;();</a>
<a name="ln1044">        const_constraints(c);</a>
<a name="ln1045">        i = c.begin();</a>
<a name="ln1046">        i = c.end();</a>
<a name="ln1047">        c.swap(c);</a>
<a name="ln1048">      }</a>
<a name="ln1049"> </a>
<a name="ln1050">      void const_constraints(const C&amp; cc) {</a>
<a name="ln1051">        ci = cc.begin();</a>
<a name="ln1052">        ci = cc.end();</a>
<a name="ln1053">        n = cc.size();</a>
<a name="ln1054">        b = cc.empty();</a>
<a name="ln1055">      }</a>
<a name="ln1056"> </a>
<a name="ln1057">    private:</a>
<a name="ln1058">      typedef typename C::value_type value_type;</a>
<a name="ln1059">      typedef typename C::iterator iterator;</a>
<a name="ln1060">      typedef typename C::const_iterator const_iterator;</a>
<a name="ln1061">      typedef typename C::reference reference;</a>
<a name="ln1062">      typedef typename C::const_reference const_reference;</a>
<a name="ln1063">      // typedef typename C::pointer pointer;</a>
<a name="ln1064">      typedef typename C::difference_type difference_type;</a>
<a name="ln1065">      typedef typename C::size_type size_type;</a>
<a name="ln1066"> </a>
<a name="ln1067">      C c;</a>
<a name="ln1068">      bool b;</a>
<a name="ln1069">      iterator i;</a>
<a name="ln1070">      const_iterator ci;</a>
<a name="ln1071">      size_type n;</a>
<a name="ln1072">  };</a>
<a name="ln1073">} // namespace boost</a>
<a name="ln1074"> </a>
<a name="ln1075">#if (defined _MSC_VER)</a>
<a name="ln1076"># pragma warning( pop )</a>
<a name="ln1077">#endif</a>
<a name="ln1078"> </a>
<a name="ln1079"># include &lt;boost/concept/detail/concept_undef.hpp&gt;</a>
<a name="ln1080"> </a>
<a name="ln1081">#endif // BOOST_CONCEPT_CHECKS_HPP</a>
<a name="ln1082"> </a>

</code></pre>
<div class="balloon" rel="738"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v519/" target="_blank">V519</a> The '_i' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 737, 738.</p></div>
<div class="balloon" rel="738"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1001/" target="_blank">V1001</a> The '_i' variable is assigned but is not used by the end of the function.</p></div>
<div class="balloon" rel="756"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v519/" target="_blank">V519</a> The 'i' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 755, 756.</p></div>
<div class="balloon" rel="756"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1001/" target="_blank">V1001</a> The 'i' variable is assigned but is not used by the end of the function.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
