
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>tablet_peer.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Licensed to the Apache Software Foundation (ASF) under one</a>
<a name="ln2">// or more contributor license agreements.  See the NOTICE file</a>
<a name="ln3">// distributed with this work for additional information</a>
<a name="ln4">// regarding copyright ownership.  The ASF licenses this file</a>
<a name="ln5">// to you under the Apache License, Version 2.0 (the</a>
<a name="ln6">// &quot;License&quot;); you may not use this file except in compliance</a>
<a name="ln7">// with the License.  You may obtain a copy of the License at</a>
<a name="ln8">//</a>
<a name="ln9">//   http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln10">//</a>
<a name="ln11">// Unless required by applicable law or agreed to in writing,</a>
<a name="ln12">// software distributed under the License is distributed on an</a>
<a name="ln13">// &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</a>
<a name="ln14">// KIND, either express or implied.  See the License for the</a>
<a name="ln15">// specific language governing permissions and limitations</a>
<a name="ln16">// under the License.</a>
<a name="ln17">//</a>
<a name="ln18">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln19">//</a>
<a name="ln20">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln21">//</a>
<a name="ln22">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln23">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln24">//</a>
<a name="ln25">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln26">//</a>
<a name="ln27">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln28">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln29">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln30">// under the License.</a>
<a name="ln31">//</a>
<a name="ln32"> </a>
<a name="ln33">#include &quot;yb/tablet/tablet_peer.h&quot;</a>
<a name="ln34"> </a>
<a name="ln35">#include &lt;algorithm&gt;</a>
<a name="ln36">#include &lt;mutex&gt;</a>
<a name="ln37">#include &lt;string&gt;</a>
<a name="ln38">#include &lt;utility&gt;</a>
<a name="ln39">#include &lt;vector&gt;</a>
<a name="ln40"> </a>
<a name="ln41">#include &lt;gflags/gflags.h&gt;</a>
<a name="ln42"> </a>
<a name="ln43">#include &quot;yb/consensus/consensus.h&quot;</a>
<a name="ln44">#include &quot;yb/consensus/consensus.pb.h&quot;</a>
<a name="ln45">#include &quot;yb/consensus/log.h&quot;</a>
<a name="ln46">#include &quot;yb/consensus/log_anchor_registry.h&quot;</a>
<a name="ln47">#include &quot;yb/consensus/log_util.h&quot;</a>
<a name="ln48">#include &quot;yb/consensus/opid_util.h&quot;</a>
<a name="ln49">#include &quot;yb/consensus/quorum_util.h&quot;</a>
<a name="ln50">#include &quot;yb/consensus/raft_consensus.h&quot;</a>
<a name="ln51">#include &quot;yb/consensus/retryable_requests.h&quot;</a>
<a name="ln52"> </a>
<a name="ln53">#include &quot;yb/docdb/consensus_frontier.h&quot;</a>
<a name="ln54">#include &quot;yb/docdb/docdb.h&quot;</a>
<a name="ln55"> </a>
<a name="ln56">#include &quot;yb/gutil/mathlimits.h&quot;</a>
<a name="ln57">#include &quot;yb/gutil/stl_util.h&quot;</a>
<a name="ln58">#include &quot;yb/gutil/strings/substitute.h&quot;</a>
<a name="ln59">#include &quot;yb/gutil/sysinfo.h&quot;</a>
<a name="ln60"> </a>
<a name="ln61">#include &quot;yb/rocksdb/db/memtable.h&quot;</a>
<a name="ln62"> </a>
<a name="ln63">#include &quot;yb/rpc/messenger.h&quot;</a>
<a name="ln64">#include &quot;yb/rpc/strand.h&quot;</a>
<a name="ln65">#include &quot;yb/rpc/thread_pool.h&quot;</a>
<a name="ln66"> </a>
<a name="ln67">#include &quot;yb/tablet/tablet.h&quot;</a>
<a name="ln68">#include &quot;yb/tablet/tablet.pb.h&quot;</a>
<a name="ln69">#include &quot;yb/tablet/tablet_bootstrap_if.h&quot;</a>
<a name="ln70">#include &quot;yb/tablet/tablet_metadata.h&quot;</a>
<a name="ln71">#include &quot;yb/tablet/tablet_metrics.h&quot;</a>
<a name="ln72">#include &quot;yb/tablet/tablet_peer_mm_ops.h&quot;</a>
<a name="ln73">#include &quot;yb/tablet/tablet_retention_policy.h&quot;</a>
<a name="ln74"> </a>
<a name="ln75">#include &quot;yb/tablet/operations/change_metadata_operation.h&quot;</a>
<a name="ln76">#include &quot;yb/tablet/operations/history_cutoff_operation.h&quot;</a>
<a name="ln77">#include &quot;yb/tablet/operations/operation_driver.h&quot;</a>
<a name="ln78">#include &quot;yb/tablet/operations/split_operation.h&quot;</a>
<a name="ln79">#include &quot;yb/tablet/operations/truncate_operation.h&quot;</a>
<a name="ln80">#include &quot;yb/tablet/operations/write_operation.h&quot;</a>
<a name="ln81">#include &quot;yb/tablet/operations/update_txn_operation.h&quot;</a>
<a name="ln82"> </a>
<a name="ln83">#include &quot;yb/util/flag_tags.h&quot;</a>
<a name="ln84">#include &quot;yb/util/logging.h&quot;</a>
<a name="ln85">#include &quot;yb/util/metrics.h&quot;</a>
<a name="ln86">#include &quot;yb/util/stopwatch.h&quot;</a>
<a name="ln87">#include &quot;yb/util/threadpool.h&quot;</a>
<a name="ln88">#include &quot;yb/util/trace.h&quot;</a>
<a name="ln89"> </a>
<a name="ln90">using namespace std::literals;</a>
<a name="ln91">using namespace std::placeholders;</a>
<a name="ln92">using std::shared_ptr;</a>
<a name="ln93">using std::string;</a>
<a name="ln94"> </a>
<a name="ln95">DEFINE_test_flag(int32, delay_init_tablet_peer_ms, 0,</a>
<a name="ln96">                 &quot;Wait before executing init tablet peer for specified amount of milliseconds.&quot;);</a>
<a name="ln97"> </a>
<a name="ln98">DEFINE_int32(cdc_min_replicated_index_considered_stale_secs, 900,</a>
<a name="ln99">    &quot;If cdc_min_replicated_index hasn't been replicated in this amount of time, we reset its&quot;</a>
<a name="ln100">    &quot;value to max int64 to avoid retaining any logs&quot;);</a>
<a name="ln101"> </a>
<a name="ln102">DEFINE_bool(propagate_safe_time, true, &quot;Propagate safe time to read from leader to followers&quot;);</a>
<a name="ln103"> </a>
<a name="ln104">namespace yb {</a>
<a name="ln105">namespace tablet {</a>
<a name="ln106"> </a>
<a name="ln107">METRIC_DEFINE_histogram(tablet, op_prepare_queue_length, &quot;Operation Prepare Queue Length&quot;,</a>
<a name="ln108">                        MetricUnit::kTasks,</a>
<a name="ln109">                        &quot;Number of operations waiting to be prepared within this tablet. &quot;</a>
<a name="ln110">                        &quot;High queue lengths indicate that the server is unable to process &quot;</a>
<a name="ln111">                        &quot;operations as fast as they are being written to the WAL.&quot;,</a>
<a name="ln112">                        10000, 2);</a>
<a name="ln113"> </a>
<a name="ln114">METRIC_DEFINE_histogram(tablet, op_prepare_queue_time, &quot;Operation Prepare Queue Time&quot;,</a>
<a name="ln115">                        MetricUnit::kMicroseconds,</a>
<a name="ln116">                        &quot;Time that operations spent waiting in the prepare queue before being &quot;</a>
<a name="ln117">                        &quot;processed. High queue times indicate that the server is unable to &quot;</a>
<a name="ln118">                        &quot;process operations as fast as they are being written to the WAL.&quot;,</a>
<a name="ln119">                        10000000, 2);</a>
<a name="ln120"> </a>
<a name="ln121">METRIC_DEFINE_histogram(tablet, op_prepare_run_time, &quot;Operation Prepare Run Time&quot;,</a>
<a name="ln122">                        MetricUnit::kMicroseconds,</a>
<a name="ln123">                        &quot;Time that operations spent being prepared in the tablet. &quot;</a>
<a name="ln124">                        &quot;High values may indicate that the server is under-provisioned or &quot;</a>
<a name="ln125">                        &quot;that operations are experiencing high contention with one another for &quot;</a>
<a name="ln126">                        &quot;locks.&quot;,</a>
<a name="ln127">                        10000000, 2);</a>
<a name="ln128"> </a>
<a name="ln129">using consensus::Consensus;</a>
<a name="ln130">using consensus::ConsensusBootstrapInfo;</a>
<a name="ln131">using consensus::ConsensusMetadata;</a>
<a name="ln132">using consensus::ConsensusOptions;</a>
<a name="ln133">using consensus::ConsensusRound;</a>
<a name="ln134">using consensus::StateChangeContext;</a>
<a name="ln135">using consensus::StateChangeReason;</a>
<a name="ln136">using consensus::RaftConfigPB;</a>
<a name="ln137">using consensus::RaftPeerPB;</a>
<a name="ln138">using consensus::RaftConsensus;</a>
<a name="ln139">using consensus::ReplicateMsg;</a>
<a name="ln140">using consensus::OpIdType;</a>
<a name="ln141">using log::Log;</a>
<a name="ln142">using log::LogAnchorRegistry;</a>
<a name="ln143">using rpc::Messenger;</a>
<a name="ln144">using strings::Substitute;</a>
<a name="ln145">using tserver::TabletServerErrorPB;</a>
<a name="ln146"> </a>
<a name="ln147">// ============================================================================</a>
<a name="ln148">//  Tablet Peer</a>
<a name="ln149">// ============================================================================</a>
<a name="ln150">TabletPeer::TabletPeer(</a>
<a name="ln151">    const RaftGroupMetadataPtr&amp; meta,</a>
<a name="ln152">    const consensus::RaftPeerPB&amp; local_peer_pb,</a>
<a name="ln153">    const scoped_refptr&lt;server::Clock&gt;&amp; clock,</a>
<a name="ln154">    const std::string&amp; permanent_uuid,</a>
<a name="ln155">    Callback&lt;void(std::shared_ptr&lt;StateChangeContext&gt; context)&gt; mark_dirty_clbk,</a>
<a name="ln156">    MetricRegistry* metric_registry,</a>
<a name="ln157">    TabletSplitter* tablet_splitter,</a>
<a name="ln158">    const std::shared_future&lt;client::YBClient*&gt;&amp; client_future)</a>
<a name="ln159">    : meta_(meta),</a>
<a name="ln160">      tablet_id_(meta-&gt;raft_group_id()),</a>
<a name="ln161">      local_peer_pb_(local_peer_pb),</a>
<a name="ln162">      state_(RaftGroupStatePB::NOT_STARTED),</a>
<a name="ln163">      operation_tracker_(consensus::MakeTabletLogPrefix(tablet_id_, permanent_uuid)),</a>
<a name="ln164">      status_listener_(new TabletStatusListener(meta)),</a>
<a name="ln165">      clock_(clock),</a>
<a name="ln166">      log_anchor_registry_(new LogAnchorRegistry()),</a>
<a name="ln167">      mark_dirty_clbk_(std::move(mark_dirty_clbk)),</a>
<a name="ln168">      permanent_uuid_(permanent_uuid),</a>
<a name="ln169">      preparing_operations_counter_(operation_tracker_.LogPrefix()),</a>
<a name="ln170">      metric_registry_(metric_registry),</a>
<a name="ln171">      tablet_splitter_(tablet_splitter),</a>
<a name="ln172">      client_future_(client_future) {}</a>
<a name="ln173"> </a>
<a name="ln174">TabletPeer::~TabletPeer() {</a>
<a name="ln175">  std::lock_guard&lt;simple_spinlock&gt; lock(lock_);</a>
<a name="ln176">  // We should either have called Shutdown(), or we should have never called</a>
<a name="ln177">  // Init().</a>
<a name="ln178">  LOG_IF_WITH_PREFIX(DFATAL, tablet_) &lt;&lt; &quot;TabletPeer not fully shut down.&quot;;</a>
<a name="ln179">}</a>
<a name="ln180"> </a>
<a name="ln181">Status TabletPeer::InitTabletPeer(</a>
<a name="ln182">    const TabletPtr&amp; tablet,</a>
<a name="ln183">    const std::shared_ptr&lt;MemTracker&gt;&amp; server_mem_tracker,</a>
<a name="ln184">    Messenger* messenger,</a>
<a name="ln185">    rpc::ProxyCache* proxy_cache,</a>
<a name="ln186">    const scoped_refptr&lt;Log&gt;&amp; log,</a>
<a name="ln187">    const scoped_refptr&lt;MetricEntity&gt;&amp; metric_entity,</a>
<a name="ln188">    ThreadPool* raft_pool,</a>
<a name="ln189">    ThreadPool* tablet_prepare_pool,</a>
<a name="ln190">    consensus::RetryableRequests* retryable_requests,</a>
<a name="ln191">    const yb::OpId&amp; split_op_id) {</a>
<a name="ln192">  DCHECK(tablet) &lt;&lt; &quot;A TabletPeer must be provided with a Tablet&quot;;</a>
<a name="ln193">  DCHECK(log) &lt;&lt; &quot;A TabletPeer must be provided with a Log&quot;;</a>
<a name="ln194"> </a>
<a name="ln195">  if (FLAGS_TEST_delay_init_tablet_peer_ms &gt; 0) {</a>
<a name="ln196">    std::this_thread::sleep_for(FLAGS_TEST_delay_init_tablet_peer_ms * 1ms);</a>
<a name="ln197">  }</a>
<a name="ln198"> </a>
<a name="ln199">  {</a>
<a name="ln200">    std::lock_guard&lt;simple_spinlock&gt; lock(lock_);</a>
<a name="ln201">    auto state = state_.load(std::memory_order_acquire);</a>
<a name="ln202">    if (state != RaftGroupStatePB::BOOTSTRAPPING) {</a>
<a name="ln203">      return STATUS_FORMAT(</a>
<a name="ln204">          IllegalState, &quot;Invalid tablet state for init: $0&quot;, RaftGroupStatePB_Name(state));</a>
<a name="ln205">    }</a>
<a name="ln206">    tablet_ = tablet;</a>
<a name="ln207">    proxy_cache_ = proxy_cache;</a>
<a name="ln208">    log_ = log;</a>
<a name="ln209">    // &quot;Publish&quot; the log pointer so it can be retrieved using the log() accessor.</a>
<a name="ln210">    log_atomic_ = log.get();</a>
<a name="ln211">    service_thread_pool_ = &amp;messenger-&gt;ThreadPool();</a>
<a name="ln212">    strand_.reset(new rpc::Strand(&amp;messenger-&gt;ThreadPool()));</a>
<a name="ln213"> </a>
<a name="ln214">    tablet-&gt;SetMemTableFlushFilterFactory([log] {</a>
<a name="ln215">      auto index = log-&gt;GetLatestEntryOpId().index;</a>
<a name="ln216">      return [index] (const rocksdb::MemTable&amp; memtable) -&gt; Result&lt;bool&gt; {</a>
<a name="ln217">        auto frontiers = memtable.Frontiers();</a>
<a name="ln218">        if (frontiers) {</a>
<a name="ln219">          const auto&amp; largest = down_cast&lt;const docdb::ConsensusFrontier&amp;&gt;(frontiers-&gt;Largest());</a>
<a name="ln220">          // We can only flush this memtable if all operations written to it have also been written</a>
<a name="ln221">          // to the log (maybe not synced, if durable_wal_write is disabled, but that's OK).</a>
<a name="ln222">          return largest.op_id().index &lt;= index;</a>
<a name="ln223">        }</a>
<a name="ln224"> </a>
<a name="ln225">        // It is correct to don't have frontiers when memtable is empty.</a>
<a name="ln226">        if (memtable.IsEmpty()) {</a>
<a name="ln227">          return true;</a>
<a name="ln228">        }</a>
<a name="ln229"> </a>
<a name="ln230">        // This is a degenerate case that should ideally never occur. An empty memtable got into the</a>
<a name="ln231">        // list of immutable memtables. We say it is OK to flush it and move on.</a>
<a name="ln232">        static const char* error_msg =</a>
<a name="ln233">            &quot;A memtable with no frontiers set found when deciding what memtables to &quot;</a>
<a name="ln234">            &quot;flush! This should not happen.&quot;;</a>
<a name="ln235">        LOG(ERROR) &lt;&lt; error_msg &lt;&lt; &quot; Stack trace:\n&quot; &lt;&lt; GetStackTrace();</a>
<a name="ln236">        return STATUS(IllegalState, error_msg);</a>
<a name="ln237">      };</a>
<a name="ln238">    });</a>
<a name="ln239"> </a>
<a name="ln240">    tablet_-&gt;SetCleanupPool(raft_pool);</a>
<a name="ln241"> </a>
<a name="ln242">    ConsensusOptions options;</a>
<a name="ln243">    options.tablet_id = meta_-&gt;raft_group_id();</a>
<a name="ln244"> </a>
<a name="ln245">    TRACE(&quot;Creating consensus instance&quot;);</a>
<a name="ln246"> </a>
<a name="ln247">    std::unique_ptr&lt;ConsensusMetadata&gt; cmeta;</a>
<a name="ln248">    RETURN_NOT_OK(ConsensusMetadata::Load(meta_-&gt;fs_manager(), tablet_id_,</a>
<a name="ln249">                                          meta_-&gt;fs_manager()-&gt;uuid(), &amp;cmeta));</a>
<a name="ln250"> </a>
<a name="ln251">    if (retryable_requests) {</a>
<a name="ln252">      retryable_requests-&gt;SetMetricEntity(tablet-&gt;GetMetricEntity());</a>
<a name="ln253">    }</a>
<a name="ln254"> </a>
<a name="ln255">    consensus_ = RaftConsensus::Create(</a>
<a name="ln256">        options,</a>
<a name="ln257">        std::move(cmeta),</a>
<a name="ln258">        local_peer_pb_,</a>
<a name="ln259">        metric_entity,</a>
<a name="ln260">        clock_,</a>
<a name="ln261">        this,</a>
<a name="ln262">        messenger,</a>
<a name="ln263">        proxy_cache_,</a>
<a name="ln264">        log_.get(),</a>
<a name="ln265">        server_mem_tracker,</a>
<a name="ln266">        tablet_-&gt;mem_tracker(),</a>
<a name="ln267">        mark_dirty_clbk_,</a>
<a name="ln268">        tablet_-&gt;table_type(),</a>
<a name="ln269">        raft_pool,</a>
<a name="ln270">        retryable_requests,</a>
<a name="ln271">        split_op_id);</a>
<a name="ln272">    has_consensus_.store(true, std::memory_order_release);</a>
<a name="ln273"> </a>
<a name="ln274">    tablet_-&gt;SetHybridTimeLeaseProvider(std::bind(&amp;TabletPeer::HybridTimeLease, this, _1, _2));</a>
<a name="ln275">    operation_tracker_.SetPostTracker(</a>
<a name="ln276">        std::bind(&amp;RaftConsensus::TrackOperationMemory, consensus_.get(), _1));</a>
<a name="ln277"> </a>
<a name="ln278">    prepare_thread_ = std::make_unique&lt;Preparer&gt;(consensus_.get(), tablet_prepare_pool);</a>
<a name="ln279"> </a>
<a name="ln280">    ChangeConfigReplicated(RaftConfig()); // Set initial flag value.</a>
<a name="ln281">  }</a>
<a name="ln282"> </a>
<a name="ln283">  RETURN_NOT_OK(prepare_thread_-&gt;Start());</a>
<a name="ln284"> </a>
<a name="ln285">  if (tablet_-&gt;metrics() != nullptr) {</a>
<a name="ln286">    TRACE(&quot;Starting instrumentation&quot;);</a>
<a name="ln287">    operation_tracker_.StartInstrumentation(tablet_-&gt;GetMetricEntity());</a>
<a name="ln288">  }</a>
<a name="ln289">  operation_tracker_.StartMemoryTracking(tablet_-&gt;mem_tracker());</a>
<a name="ln290"> </a>
<a name="ln291">  if (tablet_-&gt;transaction_coordinator()) {</a>
<a name="ln292">    tablet_-&gt;transaction_coordinator()-&gt;Start();</a>
<a name="ln293">  }</a>
<a name="ln294"> </a>
<a name="ln295">  if (tablet_-&gt;transaction_participant()) {</a>
<a name="ln296">    tablet_-&gt;transaction_participant()-&gt;Start();</a>
<a name="ln297">  }</a>
<a name="ln298"> </a>
<a name="ln299">  RETURN_NOT_OK(set_cdc_min_replicated_index(meta_-&gt;cdc_min_replicated_index()));</a>
<a name="ln300"> </a>
<a name="ln301">  TRACE(&quot;TabletPeer::Init() finished&quot;);</a>
<a name="ln302">  VLOG_WITH_PREFIX(2) &lt;&lt; &quot;Peer Initted&quot;;</a>
<a name="ln303"> </a>
<a name="ln304">  return Status::OK();</a>
<a name="ln305">}</a>
<a name="ln306"> </a>
<a name="ln307">FixedHybridTimeLease TabletPeer::HybridTimeLease(MicrosTime min_allowed, CoarseTimePoint deadline) {</a>
<a name="ln308">  auto time = clock_-&gt;Now();</a>
<a name="ln309">  MicrosTime lease_micros {</a>
<a name="ln310">      consensus_-&gt;MajorityReplicatedHtLeaseExpiration(min_allowed, deadline) };</a>
<a name="ln311">  if (!lease_micros) {</a>
<a name="ln312">    return {</a>
<a name="ln313">      .time = HybridTime::kInvalid,</a>
<a name="ln314">      .lease = HybridTime::kInvalid,</a>
<a name="ln315">    };</a>
<a name="ln316">  }</a>
<a name="ln317">  if (lease_micros &gt;= kMaxHybridTimePhysicalMicros) {</a>
<a name="ln318">    // This could happen when leader leases are disabled.</a>
<a name="ln319">    return FixedHybridTimeLease();</a>
<a name="ln320">  }</a>
<a name="ln321">  return {</a>
<a name="ln322">    .time = time,</a>
<a name="ln323">    .lease = HybridTime(lease_micros, /* logical */ 0)</a>
<a name="ln324">  };</a>
<a name="ln325">}</a>
<a name="ln326"> </a>
<a name="ln327">HybridTime TabletPeer::PreparePeerRequest() {</a>
<a name="ln328">  auto leader_term = consensus_-&gt;GetLeaderState(/* allow_stale= */ true).term;</a>
<a name="ln329">  if (leader_term &gt;= 0) {</a>
<a name="ln330">    auto last_write_ht = tablet_-&gt;mvcc_manager()-&gt;LastReplicatedHybridTime();</a>
<a name="ln331">    auto propagated_history_cutoff =</a>
<a name="ln332">        tablet_-&gt;RetentionPolicy()-&gt;HistoryCutoffToPropagate(last_write_ht);</a>
<a name="ln333"> </a>
<a name="ln334">    if (propagated_history_cutoff) {</a>
<a name="ln335">      VLOG_WITH_PREFIX(2) &lt;&lt; &quot;Propagate history cutoff: &quot; &lt;&lt; propagated_history_cutoff;</a>
<a name="ln336"> </a>
<a name="ln337">      auto state = std::make_unique&lt;HistoryCutoffOperationState&gt;(tablet_.get());</a>
<a name="ln338">      auto request = state-&gt;AllocateRequest();</a>
<a name="ln339">      request-&gt;set_history_cutoff(propagated_history_cutoff.ToUint64());</a>
<a name="ln340"> </a>
<a name="ln341">      auto operation = std::make_unique&lt;tablet::HistoryCutoffOperation&gt;(std::move(state));</a>
<a name="ln342">      Submit(std::move(operation), leader_term);</a>
<a name="ln343">    }</a>
<a name="ln344">  }</a>
<a name="ln345"> </a>
<a name="ln346">  if (!FLAGS_propagate_safe_time) {</a>
<a name="ln347">    return HybridTime::kInvalid;</a>
<a name="ln348">  }</a>
<a name="ln349"> </a>
<a name="ln350">  // Get the current majority-replicated HT leader lease without any waiting.</a>
<a name="ln351">  auto ht_lease = HybridTimeLease(/* min_allowed */ 0, /* deadline */ CoarseTimePoint::max());</a>
<a name="ln352">  if (!ht_lease.lease) {</a>
<a name="ln353">    return HybridTime::kInvalid;</a>
<a name="ln354">  }</a>
<a name="ln355">  return tablet_-&gt;mvcc_manager()-&gt;SafeTime(ht_lease);</a>
<a name="ln356">}</a>
<a name="ln357"> </a>
<a name="ln358">void TabletPeer::MajorityReplicated() {</a>
<a name="ln359">  auto ht_lease = HybridTimeLease(/* min_allowed */ 0, /* deadline */ CoarseTimePoint::max());</a>
<a name="ln360">  if (ht_lease.lease) {</a>
<a name="ln361">    tablet_-&gt;mvcc_manager()-&gt;UpdatePropagatedSafeTimeOnLeader(ht_lease);</a>
<a name="ln362">  }</a>
<a name="ln363">}</a>
<a name="ln364"> </a>
<a name="ln365">void TabletPeer::ChangeConfigReplicated(const RaftConfigPB&amp; config) {</a>
<a name="ln366">  tablet_-&gt;mvcc_manager()-&gt;SetLeaderOnlyMode(config.peers_size() == 1);</a>
<a name="ln367">}</a>
<a name="ln368"> </a>
<a name="ln369">uint64_t TabletPeer::NumSSTFiles() {</a>
<a name="ln370">  return tablet_-&gt;GetCurrentVersionNumSSTFiles();</a>
<a name="ln371">}</a>
<a name="ln372"> </a>
<a name="ln373">void TabletPeer::ListenNumSSTFilesChanged(std::function&lt;void()&gt; listener) {</a>
<a name="ln374">  tablet_-&gt;ListenNumSSTFilesChanged(std::move(listener));</a>
<a name="ln375">}</a>
<a name="ln376"> </a>
<a name="ln377">Status TabletPeer::Start(const ConsensusBootstrapInfo&amp; bootstrap_info) {</a>
<a name="ln378">  {</a>
<a name="ln379">    std::lock_guard&lt;simple_spinlock&gt; l(state_change_lock_);</a>
<a name="ln380">    TRACE(&quot;Starting consensus&quot;);</a>
<a name="ln381"> </a>
<a name="ln382">    VLOG_WITH_PREFIX(2) &lt;&lt; &quot;Peer starting&quot;;</a>
<a name="ln383"> </a>
<a name="ln384">    VLOG(2) &lt;&lt; &quot;RaftConfig before starting: &quot; &lt;&lt; consensus_-&gt;CommittedConfig().DebugString();</a>
<a name="ln385"> </a>
<a name="ln386">    // If tablet was previously considered shutdown w.r.t. metrics,</a>
<a name="ln387">    // fix that for a tablet now being reinstated.</a>
<a name="ln388">    DVLOG_WITH_PREFIX(3)</a>
<a name="ln389">      &lt;&lt; &quot;Remove from set of tablets that have been shutdown so as to allow reporting metrics&quot;;</a>
<a name="ln390">    metric_registry_-&gt;tablets_shutdown_erase(tablet_id());</a>
<a name="ln391"> </a>
<a name="ln392">    RETURN_NOT_OK(consensus_-&gt;Start(bootstrap_info));</a>
<a name="ln393">    RETURN_NOT_OK(UpdateState(RaftGroupStatePB::BOOTSTRAPPING, RaftGroupStatePB::RUNNING,</a>
<a name="ln394">                              &quot;Incorrect state to start TabletPeer, &quot;));</a>
<a name="ln395">  }</a>
<a name="ln396">  // The context tracks that the current caller does not hold the lock for consensus state.</a>
<a name="ln397">  // So mark dirty callback, e.g., consensus-&gt;ConsensusState() for master consensus callback of</a>
<a name="ln398">  // SysCatalogStateChanged, can get the lock when needed.</a>
<a name="ln399">  auto context =</a>
<a name="ln400">      std::make_shared&lt;StateChangeContext&gt;(StateChangeReason::TABLET_PEER_STARTED, false);</a>
<a name="ln401">  // Because we changed the tablet state, we need to re-report the tablet to the master.</a>
<a name="ln402">  mark_dirty_clbk_.Run(context);</a>
<a name="ln403"> </a>
<a name="ln404">  return tablet_-&gt;EnableCompactions(/* operation_pause */ nullptr);</a>
<a name="ln405">}</a>
<a name="ln406"> </a>
<a name="ln407">const consensus::RaftConfigPB TabletPeer::RaftConfig() const {</a>
<a name="ln408">  CHECK(consensus_) &lt;&lt; &quot;consensus is null&quot;;</a>
<a name="ln409">  return consensus_-&gt;CommittedConfig();</a>
<a name="ln410">}</a>
<a name="ln411"> </a>
<a name="ln412">bool TabletPeer::StartShutdown() {</a>
<a name="ln413">  LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Initiating TabletPeer shutdown&quot;;</a>
<a name="ln414"> </a>
<a name="ln415">  {</a>
<a name="ln416">    std::lock_guard&lt;decltype(lock_)&gt; lock(lock_);</a>
<a name="ln417">    if (tablet_) {</a>
<a name="ln418">      tablet_-&gt;StartShutdown();</a>
<a name="ln419">    }</a>
<a name="ln420">  }</a>
<a name="ln421"> </a>
<a name="ln422">  {</a>
<a name="ln423">    RaftGroupStatePB state = state_.load(std::memory_order_acquire);</a>
<a name="ln424">    for (;;) {</a>
<a name="ln425">      if (state == RaftGroupStatePB::QUIESCING || state == RaftGroupStatePB::SHUTDOWN) {</a>
<a name="ln426">        return false;</a>
<a name="ln427">      }</a>
<a name="ln428">      if (state_.compare_exchange_strong(</a>
<a name="ln429">          state, RaftGroupStatePB::QUIESCING, std::memory_order_acq_rel)) {</a>
<a name="ln430">        LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Started shutdown from state: &quot; &lt;&lt; RaftGroupStatePB_Name(state);</a>
<a name="ln431">        break;</a>
<a name="ln432">      }</a>
<a name="ln433">    }</a>
<a name="ln434">  }</a>
<a name="ln435"> </a>
<a name="ln436">  std::lock_guard&lt;simple_spinlock&gt; l(state_change_lock_);</a>
<a name="ln437">  // Even though Tablet::Shutdown() also unregisters its ops, we have to do it here</a>
<a name="ln438">  // to ensure that any currently running operation finishes before we proceed with</a>
<a name="ln439">  // the rest of the shutdown sequence. In particular, a maintenance operation could</a>
<a name="ln440">  // indirectly end up calling into the log, which we are about to shut down.</a>
<a name="ln441">  UnregisterMaintenanceOps();</a>
<a name="ln442"> </a>
<a name="ln443">  std::shared_ptr&lt;consensus::RaftConsensus&gt; consensus;</a>
<a name="ln444">  {</a>
<a name="ln445">    std::lock_guard&lt;decltype(lock_)&gt; lock(lock_);</a>
<a name="ln446">    consensus = consensus_;</a>
<a name="ln447">  }</a>
<a name="ln448">  if (consensus) {</a>
<a name="ln449">    consensus-&gt;Shutdown();</a>
<a name="ln450">  }</a>
<a name="ln451"> </a>
<a name="ln452">  return true;</a>
<a name="ln453">}</a>
<a name="ln454"> </a>
<a name="ln455">void TabletPeer::CompleteShutdown(IsDropTable is_drop_table) {</a>
<a name="ln456">  preparing_operations_counter_.Shutdown();</a>
<a name="ln457"> </a>
<a name="ln458">  // TODO: KUDU-183: Keep track of the pending tasks and send an &quot;abort&quot; message.</a>
<a name="ln459">  LOG_SLOW_EXECUTION(WARNING, 1000,</a>
<a name="ln460">      Substitute(&quot;TabletPeer: tablet $0: Waiting for Operations to complete&quot;, tablet_id())) {</a>
<a name="ln461">    operation_tracker_.WaitForAllToFinish();</a>
<a name="ln462">  }</a>
<a name="ln463"> </a>
<a name="ln464">  if (prepare_thread_) {</a>
<a name="ln465">    prepare_thread_-&gt;Stop();</a>
<a name="ln466">  }</a>
<a name="ln467"> </a>
<a name="ln468">  if (log_) {</a>
<a name="ln469">    WARN_NOT_OK(log_-&gt;Close(), LogPrefix() + &quot;Error closing the Log&quot;);</a>
<a name="ln470">  }</a>
<a name="ln471"> </a>
<a name="ln472">  VLOG_WITH_PREFIX(1) &lt;&lt; &quot;Shut down!&quot;;</a>
<a name="ln473"> </a>
<a name="ln474">  if (tablet_) {</a>
<a name="ln475">    tablet_-&gt;CompleteShutdown(is_drop_table);</a>
<a name="ln476">  }</a>
<a name="ln477"> </a>
<a name="ln478">  // Only mark the peer as SHUTDOWN when all other components have shut down.</a>
<a name="ln479">  {</a>
<a name="ln480">    std::lock_guard&lt;simple_spinlock&gt; lock(lock_);</a>
<a name="ln481">    // Release mem tracker resources.</a>
<a name="ln482">    has_consensus_.store(false, std::memory_order_release);</a>
<a name="ln483">    consensus_.reset();</a>
<a name="ln484">    prepare_thread_.reset();</a>
<a name="ln485">    tablet_.reset();</a>
<a name="ln486">    auto state = state_.load(std::memory_order_acquire);</a>
<a name="ln487">    LOG_IF_WITH_PREFIX(DFATAL, state != RaftGroupStatePB::QUIESCING) &lt;&lt;</a>
<a name="ln488">        &quot;Bad state when completing shutdown: &quot; &lt;&lt; RaftGroupStatePB_Name(state);</a>
<a name="ln489">    state_.store(RaftGroupStatePB::SHUTDOWN, std::memory_order_release);</a>
<a name="ln490"> </a>
<a name="ln491">    if (metric_registry_) {</a>
<a name="ln492">      DVLOG_WITH_PREFIX(3)</a>
<a name="ln493">        &lt;&lt; &quot;Add to set of tablets that have been shutdown so as to avoid reporting metrics&quot;;</a>
<a name="ln494">      metric_registry_-&gt;tablets_shutdown_insert(tablet_id());</a>
<a name="ln495">    }</a>
<a name="ln496">  }</a>
<a name="ln497">}</a>
<a name="ln498"> </a>
<a name="ln499">void TabletPeer::WaitUntilShutdown() {</a>
<a name="ln500">  const MonoDelta kSingleWait = 10ms;</a>
<a name="ln501">  const MonoDelta kReportInterval = 5s;</a>
<a name="ln502">  const MonoDelta kMaxWait = 30s;</a>
<a name="ln503"> </a>
<a name="ln504">  MonoDelta waited = MonoDelta::kZero;</a>
<a name="ln505">  MonoDelta last_reported = MonoDelta::kZero;</a>
<a name="ln506">  while (state_.load(std::memory_order_acquire) != RaftGroupStatePB::SHUTDOWN) {</a>
<a name="ln507">    if (waited &gt;= last_reported + kReportInterval) {</a>
<a name="ln508">      if (waited &gt;= kMaxWait) {</a>
<a name="ln509">        LOG_WITH_PREFIX(DFATAL)</a>
<a name="ln510">            &lt;&lt; &quot;Wait for shutdown &quot; &lt;&lt; waited &lt;&lt; &quot; exceeded kMaxWait &quot; &lt;&lt; kMaxWait;</a>
<a name="ln511">      } else {</a>
<a name="ln512">        LOG_WITH_PREFIX(WARNING) &lt;&lt; &quot;Long wait for shutdown: &quot; &lt;&lt; waited;</a>
<a name="ln513">      }</a>
<a name="ln514">      last_reported = waited;</a>
<a name="ln515">    }</a>
<a name="ln516">    SleepFor(kSingleWait);</a>
<a name="ln517">    waited += kSingleWait;</a>
<a name="ln518">  }</a>
<a name="ln519"> </a>
<a name="ln520">  if (metric_registry_) {</a>
<a name="ln521">    DVLOG_WITH_PREFIX(3)</a>
<a name="ln522">      &lt;&lt; &quot;Add to set of tablets that have been shutdown so as to avoid reporting metrics&quot;;</a>
<a name="ln523">    metric_registry_-&gt;tablets_shutdown_insert(tablet_id());</a>
<a name="ln524">  }</a>
<a name="ln525">}</a>
<a name="ln526"> </a>
<a name="ln527">void TabletPeer::Shutdown(IsDropTable is_drop_table) {</a>
<a name="ln528">  if (StartShutdown()) {</a>
<a name="ln529">    CompleteShutdown(is_drop_table);</a>
<a name="ln530">  } else {</a>
<a name="ln531">    WaitUntilShutdown();</a>
<a name="ln532">  }</a>
<a name="ln533">}</a>
<a name="ln534"> </a>
<a name="ln535">Status TabletPeer::CheckRunning() const {</a>
<a name="ln536">  if (state_.load(std::memory_order_acquire) != RaftGroupStatePB::RUNNING) {</a>
<a name="ln537">    return STATUS(IllegalState, Substitute(&quot;The tablet is not in a running state: $0&quot;,</a>
<a name="ln538">                                           RaftGroupStatePB_Name(state_)));</a>
<a name="ln539">  }</a>
<a name="ln540"> </a>
<a name="ln541">  return Status::OK();</a>
<a name="ln542">}</a>
<a name="ln543"> </a>
<a name="ln544">Status TabletPeer::CheckShutdownOrNotStarted() const {</a>
<a name="ln545">  RaftGroupStatePB value = state_.load(std::memory_order_acquire);</a>
<a name="ln546">  if (value != RaftGroupStatePB::SHUTDOWN &amp;&amp; value != RaftGroupStatePB::NOT_STARTED) {</a>
<a name="ln547">    return STATUS(IllegalState, Substitute(&quot;The tablet is not in a shutdown state: $0&quot;,</a>
<a name="ln548">                                           RaftGroupStatePB_Name(value)));</a>
<a name="ln549">  }</a>
<a name="ln550"> </a>
<a name="ln551">  return Status::OK();</a>
<a name="ln552">}</a>
<a name="ln553"> </a>
<a name="ln554">Status TabletPeer::WaitUntilConsensusRunning(const MonoDelta&amp; timeout) {</a>
<a name="ln555">  MonoTime start(MonoTime::Now());</a>
<a name="ln556"> </a>
<a name="ln557">  int backoff_exp = 0;</a>
<a name="ln558">  const int kMaxBackoffExp = 8;</a>
<a name="ln559">  while (true) {</a>
<a name="ln560">    RaftGroupStatePB cached_state = state_.load(std::memory_order_acquire);</a>
<a name="ln561">    if (cached_state == RaftGroupStatePB::QUIESCING || cached_state == RaftGroupStatePB::SHUTDOWN) {</a>
<a name="ln562">      return STATUS(IllegalState,</a>
<a name="ln563">          Substitute(&quot;The tablet is already shutting down or shutdown. State: $0&quot;,</a>
<a name="ln564">                     RaftGroupStatePB_Name(cached_state)));</a>
<a name="ln565">    }</a>
<a name="ln566">    if (cached_state == RUNNING &amp;&amp; has_consensus_.load(std::memory_order_acquire) &amp;&amp;</a>
<a name="ln567">        consensus_-&gt;IsRunning()) {</a>
<a name="ln568">      break;</a>
<a name="ln569">    }</a>
<a name="ln570">    MonoTime now(MonoTime::Now());</a>
<a name="ln571">    MonoDelta elapsed(now.GetDeltaSince(start));</a>
<a name="ln572">    if (elapsed.MoreThan(timeout)) {</a>
<a name="ln573">      return STATUS(TimedOut, Substitute(&quot;Consensus is not running after waiting for $0. State; $1&quot;,</a>
<a name="ln574">                                         elapsed.ToString(), RaftGroupStatePB_Name(cached_state)));</a>
<a name="ln575">    }</a>
<a name="ln576">    SleepFor(MonoDelta::FromMilliseconds(1 &lt;&lt; backoff_exp));</a>
<a name="ln577">    backoff_exp = std::min(backoff_exp + 1, kMaxBackoffExp);</a>
<a name="ln578">  }</a>
<a name="ln579">  return Status::OK();</a>
<a name="ln580">}</a>
<a name="ln581"> </a>
<a name="ln582">void TabletPeer::WriteAsync(</a>
<a name="ln583">    std::unique_ptr&lt;WriteOperationState&gt; state, int64_t term, CoarseTimePoint deadline) {</a>
<a name="ln584">  if (term == yb::OpId::kUnknownTerm) {</a>
<a name="ln585">    state-&gt;CompleteWithStatus(STATUS(IllegalState, &quot;Write while not leader&quot;));</a>
<a name="ln586">    return;</a>
<a name="ln587">  }</a>
<a name="ln588"> </a>
<a name="ln589">  ScopedOperation preparing_token(&amp;preparing_operations_counter_);</a>
<a name="ln590">  auto status = CheckRunning();</a>
<a name="ln591">  if (!status.ok()) {</a>
<a name="ln592">    state-&gt;CompleteWithStatus(status);</a>
<a name="ln593">    return;</a>
<a name="ln594">  }</a>
<a name="ln595"> </a>
<a name="ln596">  auto operation = std::make_unique&lt;WriteOperation&gt;(</a>
<a name="ln597">      std::move(state), term, std::move(preparing_token), deadline, this);</a>
<a name="ln598">  tablet_-&gt;AcquireLocksAndPerformDocOperations(std::move(operation));</a>
<a name="ln599">}</a>
<a name="ln600"> </a>
<a name="ln601">HybridTime TabletPeer::ReportReadRestart() {</a>
<a name="ln602">  tablet_-&gt;metrics()-&gt;restart_read_requests-&gt;Increment();</a>
<a name="ln603">  return tablet_-&gt;SafeTime(RequireLease::kTrue);</a>
<a name="ln604">}</a>
<a name="ln605"> </a>
<a name="ln606">void TabletPeer::Submit(std::unique_ptr&lt;Operation&gt; operation, int64_t term) {</a>
<a name="ln607">  auto status = CheckRunning();</a>
<a name="ln608"> </a>
<a name="ln609">  if (status.ok()) {</a>
<a name="ln610">    auto driver = NewLeaderOperationDriver(&amp;operation, term);</a>
<a name="ln611">    if (driver.ok()) {</a>
<a name="ln612">      (**driver).ExecuteAsync();</a>
<a name="ln613">    } else {</a>
<a name="ln614">      status = driver.status();</a>
<a name="ln615">    }</a>
<a name="ln616">  }</a>
<a name="ln617">  if (!status.ok()) {</a>
<a name="ln618">    operation-&gt;Aborted(status);</a>
<a name="ln619">  }</a>
<a name="ln620">}</a>
<a name="ln621"> </a>
<a name="ln622">void TabletPeer::SubmitUpdateTransaction(</a>
<a name="ln623">    std::unique_ptr&lt;UpdateTxnOperationState&gt; state, int64_t term) {</a>
<a name="ln624">  if (!state-&gt;tablet()) {</a>
<a name="ln625">    state-&gt;SetTablet(tablet());</a>
<a name="ln626">  }</a>
<a name="ln627">  auto operation = std::make_unique&lt;tablet::UpdateTxnOperation&gt;(std::move(state));</a>
<a name="ln628">  Submit(std::move(operation), term);</a>
<a name="ln629">}</a>
<a name="ln630"> </a>
<a name="ln631">HybridTime TabletPeer::SafeTimeForTransactionParticipant() {</a>
<a name="ln632">  return tablet_-&gt;mvcc_manager()-&gt;SafeTimeForFollower(</a>
<a name="ln633">      /* min_allowed= */ HybridTime::kMin, /* deadline= */ CoarseTimePoint::min());</a>
<a name="ln634">}</a>
<a name="ln635"> </a>
<a name="ln636">void TabletPeer::GetLastReplicatedData(RemoveIntentsData* data) {</a>
<a name="ln637">  consensus_-&gt;GetLastCommittedOpId().ToPB(&amp;data-&gt;op_id);</a>
<a name="ln638">  data-&gt;log_ht = tablet_-&gt;mvcc_manager()-&gt;LastReplicatedHybridTime();</a>
<a name="ln639">}</a>
<a name="ln640"> </a>
<a name="ln641">HybridTime TabletPeer::Now() {</a>
<a name="ln642">  return clock_-&gt;Now();</a>
<a name="ln643">}</a>
<a name="ln644"> </a>
<a name="ln645">void TabletPeer::UpdateClock(HybridTime hybrid_time) {</a>
<a name="ln646">  clock_-&gt;Update(hybrid_time);</a>
<a name="ln647">}</a>
<a name="ln648"> </a>
<a name="ln649">std::unique_ptr&lt;UpdateTxnOperationState&gt; TabletPeer::CreateUpdateTransactionState(</a>
<a name="ln650">    tserver::TransactionStatePB* request) {</a>
<a name="ln651">  auto result = std::make_unique&lt;UpdateTxnOperationState&gt;(tablet());</a>
<a name="ln652">  result-&gt;TakeRequest(request);</a>
<a name="ln653">  return result;</a>
<a name="ln654">}</a>
<a name="ln655"> </a>
<a name="ln656">void TabletPeer::GetTabletStatusPB(TabletStatusPB* status_pb_out) {</a>
<a name="ln657">  std::lock_guard&lt;simple_spinlock&gt; lock(lock_);</a>
<a name="ln658">  DCHECK(status_pb_out != nullptr);</a>
<a name="ln659">  DCHECK(status_listener_.get() != nullptr);</a>
<a name="ln660">  const auto disk_size_info = GetOnDiskSizeInfo();</a>
<a name="ln661">  status_pb_out-&gt;set_tablet_id(status_listener_-&gt;tablet_id());</a>
<a name="ln662">  status_pb_out-&gt;set_namespace_name(status_listener_-&gt;namespace_name());</a>
<a name="ln663">  status_pb_out-&gt;set_table_name(status_listener_-&gt;table_name());</a>
<a name="ln664">  status_pb_out-&gt;set_table_id(status_listener_-&gt;table_id());</a>
<a name="ln665">  status_pb_out-&gt;set_last_status(status_listener_-&gt;last_status());</a>
<a name="ln666">  status_listener_-&gt;partition()-&gt;ToPB(status_pb_out-&gt;mutable_partition());</a>
<a name="ln667">  status_pb_out-&gt;set_state(state_);</a>
<a name="ln668">  status_pb_out-&gt;set_tablet_data_state(meta_-&gt;tablet_data_state());</a>
<a name="ln669">  disk_size_info.ToPB(status_pb_out);</a>
<a name="ln670">}</a>
<a name="ln671"> </a>
<a name="ln672">Status TabletPeer::RunLogGC() {</a>
<a name="ln673">  if (!CheckRunning().ok()) {</a>
<a name="ln674">    return Status::OK();</a>
<a name="ln675">  }</a>
<a name="ln676">  auto s = reset_cdc_min_replicated_index_if_stale();</a>
<a name="ln677">  if (!s.ok()) {</a>
<a name="ln678">    LOG(WARNING) &lt;&lt; &quot;Unable to reset cdc min replicated index &quot; &lt;&lt; s;</a>
<a name="ln679">  }</a>
<a name="ln680">  int64_t min_log_index = VERIFY_RESULT(GetEarliestNeededLogIndex());</a>
<a name="ln681">  int32_t num_gced = 0;</a>
<a name="ln682">  return log_-&gt;GC(min_log_index, &amp;num_gced);</a>
<a name="ln683">}</a>
<a name="ln684"> </a>
<a name="ln685">const TabletDataState TabletPeer::data_state() const {</a>
<a name="ln686">  std::lock_guard&lt;simple_spinlock&gt; lock(lock_);</a>
<a name="ln687">  return meta_-&gt;tablet_data_state();</a>
<a name="ln688">}</a>
<a name="ln689"> </a>
<a name="ln690">string TabletPeer::HumanReadableState() const {</a>
<a name="ln691">  std::lock_guard&lt;simple_spinlock&gt; lock(lock_);</a>
<a name="ln692">  TabletDataState data_state = meta_-&gt;tablet_data_state();</a>
<a name="ln693">  RaftGroupStatePB state = this-&gt;state();</a>
<a name="ln694">  // If failed, any number of things could have gone wrong.</a>
<a name="ln695">  if (state == RaftGroupStatePB::FAILED) {</a>
<a name="ln696">    return Substitute(&quot;$0 ($1): $2&quot;, RaftGroupStatePB_Name(state),</a>
<a name="ln697">                      TabletDataState_Name(data_state),</a>
<a name="ln698">                      error_.get()-&gt;ToString());</a>
<a name="ln699">  // If it's remotely bootstrapping, or tombstoned, that is the important thing</a>
<a name="ln700">  // to show.</a>
<a name="ln701">  } else if (!CanServeTabletData(data_state)) {</a>
<a name="ln702">    return TabletDataState_Name(data_state);</a>
<a name="ln703">  } else if (data_state == TabletDataState::TABLET_DATA_SPLIT_COMPLETED) {</a>
<a name="ln704">    return RaftGroupStatePB_Name(state) + &quot; (split)&quot;;</a>
<a name="ln705">  }</a>
<a name="ln706">  // Otherwise, the tablet's data is in a &quot;normal&quot; state, so we just display</a>
<a name="ln707">  // the runtime state (BOOTSTRAPPING, RUNNING, etc).</a>
<a name="ln708">  return RaftGroupStatePB_Name(state);</a>
<a name="ln709">}</a>
<a name="ln710"> </a>
<a name="ln711">namespace {</a>
<a name="ln712"> </a>
<a name="ln713">consensus::OperationType MapOperationTypeToPB(OperationType operation_type) {</a>
<a name="ln714">  switch (operation_type) {</a>
<a name="ln715">    case OperationType::kWrite:</a>
<a name="ln716">      return consensus::WRITE_OP;</a>
<a name="ln717"> </a>
<a name="ln718">    case OperationType::kChangeMetadata:</a>
<a name="ln719">      return consensus::CHANGE_METADATA_OP;</a>
<a name="ln720"> </a>
<a name="ln721">    case OperationType::kUpdateTransaction:</a>
<a name="ln722">      return consensus::UPDATE_TRANSACTION_OP;</a>
<a name="ln723"> </a>
<a name="ln724">    case OperationType::kSnapshot:</a>
<a name="ln725">      return consensus::SNAPSHOT_OP;</a>
<a name="ln726"> </a>
<a name="ln727">    case OperationType::kTruncate:</a>
<a name="ln728">      return consensus::TRUNCATE_OP;</a>
<a name="ln729"> </a>
<a name="ln730">    case OperationType::kHistoryCutoff:</a>
<a name="ln731">      return consensus::HISTORY_CUTOFF_OP;</a>
<a name="ln732"> </a>
<a name="ln733">    case OperationType::kSplit:</a>
<a name="ln734">      return consensus::SPLIT_OP;</a>
<a name="ln735"> </a>
<a name="ln736">    case OperationType::kEmpty:</a>
<a name="ln737">      LOG(FATAL) &lt;&lt; &quot;OperationType::kEmpty cannot be converted to consensus::OperationType&quot;;</a>
<a name="ln738">  }</a>
<a name="ln739">  FATAL_INVALID_ENUM_VALUE(OperationType, operation_type);</a>
<a name="ln740">}</a>
<a name="ln741"> </a>
<a name="ln742">} // namespace</a>
<a name="ln743"> </a>
<a name="ln744">void TabletPeer::GetInFlightOperations(Operation::TraceType trace_type,</a>
<a name="ln745">                                       vector&lt;consensus::OperationStatusPB&gt;* out) const {</a>
<a name="ln746">  for (const auto&amp; driver : operation_tracker_.GetPendingOperations()) {</a>
<a name="ln747">    if (driver-&gt;state() == nullptr) {</a>
<a name="ln748">      continue;</a>
<a name="ln749">    }</a>
<a name="ln750">    auto op_type = driver-&gt;operation_type();</a>
<a name="ln751">    if (op_type == OperationType::kEmpty) {</a>
<a name="ln752">      // This is a special-purpose in-memory-only operation for updating propagated safe time on</a>
<a name="ln753">      // a follower.</a>
<a name="ln754">      continue;</a>
<a name="ln755">    }</a>
<a name="ln756"> </a>
<a name="ln757">    consensus::OperationStatusPB status_pb;</a>
<a name="ln758">    driver-&gt;GetOpId().ToPB(status_pb.mutable_op_id());</a>
<a name="ln759">    status_pb.set_operation_type(MapOperationTypeToPB(op_type));</a>
<a name="ln760">    status_pb.set_description(driver-&gt;ToString());</a>
<a name="ln761">    int64_t running_for_micros =</a>
<a name="ln762">        MonoTime::Now().GetDeltaSince(driver-&gt;start_time()).ToMicroseconds();</a>
<a name="ln763">    status_pb.set_running_for_micros(running_for_micros);</a>
<a name="ln764">    if (trace_type == Operation::TRACE_TXNS) {</a>
<a name="ln765">      status_pb.set_trace_buffer(driver-&gt;trace()-&gt;DumpToString(true));</a>
<a name="ln766">    }</a>
<a name="ln767">    out-&gt;push_back(status_pb);</a>
<a name="ln768">  }</a>
<a name="ln769">}</a>
<a name="ln770"> </a>
<a name="ln771">Result&lt;int64_t&gt; TabletPeer::GetEarliestNeededLogIndex(std::string* details) const {</a>
<a name="ln772">  // First, we anchor on the last OpId in the Log to establish a lower bound</a>
<a name="ln773">  // and avoid racing with the other checks. This limits the Log GC candidate</a>
<a name="ln774">  // segments before we check the anchors.</a>
<a name="ln775">  auto latest_log_entry_op_id = log_-&gt;GetLatestEntryOpId();</a>
<a name="ln776">  int64_t min_index = latest_log_entry_op_id.index;</a>
<a name="ln777">  if (details) {</a>
<a name="ln778">    *details += Format(&quot;Latest log entry op id: $0\n&quot;, latest_log_entry_op_id);</a>
<a name="ln779">  }</a>
<a name="ln780"> </a>
<a name="ln781">  // If we never have written to the log, no need to proceed.</a>
<a name="ln782">  if (min_index == 0) {</a>
<a name="ln783">    return min_index;</a>
<a name="ln784">  }</a>
<a name="ln785"> </a>
<a name="ln786">  // Next, we interrogate the anchor registry.</a>
<a name="ln787">  // Returns OK if minimum known, NotFound if no anchors are registered.</a>
<a name="ln788">  {</a>
<a name="ln789">    int64_t min_anchor_index;</a>
<a name="ln790">    Status s = log_anchor_registry_-&gt;GetEarliestRegisteredLogIndex(&amp;min_anchor_index);</a>
<a name="ln791">    if (PREDICT_FALSE(!s.ok())) {</a>
<a name="ln792">      DCHECK(s.IsNotFound()) &lt;&lt; &quot;Unexpected error calling LogAnchorRegistry: &quot; &lt;&lt; s.ToString();</a>
<a name="ln793">    } else {</a>
<a name="ln794">      min_index = std::min(min_index, min_anchor_index);</a>
<a name="ln795">      if (details) {</a>
<a name="ln796">        *details += Format(&quot;Min anchor index: $0\n&quot;, min_anchor_index);</a>
<a name="ln797">      }</a>
<a name="ln798">    }</a>
<a name="ln799">  }</a>
<a name="ln800"> </a>
<a name="ln801">  // Next, interrogate the OperationTracker.</a>
<a name="ln802">  int64_t min_pending_op_index = std::numeric_limits&lt;int64_t&gt;::max();</a>
<a name="ln803">  for (const auto&amp; driver : operation_tracker_.GetPendingOperations()) {</a>
<a name="ln804">    auto tx_op_id = driver-&gt;GetOpId();</a>
<a name="ln805">    // A operation which doesn't have an opid hasn't been submitted for replication yet and</a>
<a name="ln806">    // thus has no need to anchor the log.</a>
<a name="ln807">    if (tx_op_id != yb::OpId::Invalid()) {</a>
<a name="ln808">      min_pending_op_index = std::min(min_pending_op_index, tx_op_id.index);</a>
<a name="ln809">    }</a>
<a name="ln810">  }</a>
<a name="ln811"> </a>
<a name="ln812">  min_index = std::min(min_index, min_pending_op_index);</a>
<a name="ln813">  if (details &amp;&amp; min_pending_op_index != std::numeric_limits&lt;int64_t&gt;::max()) {</a>
<a name="ln814">    *details += Format(&quot;Min pending op id index: $0\n&quot;, min_pending_op_index);</a>
<a name="ln815">  }</a>
<a name="ln816"> </a>
<a name="ln817">  auto min_retryable_request_op_id = consensus_-&gt;MinRetryableRequestOpId();</a>
<a name="ln818">  min_index = std::min(min_index, min_retryable_request_op_id.index);</a>
<a name="ln819">  if (details) {</a>
<a name="ln820">    *details += Format(&quot;Min retryable request op id: $0\n&quot;, min_retryable_request_op_id);</a>
<a name="ln821">  }</a>
<a name="ln822"> </a>
<a name="ln823">  auto* transaction_coordinator = tablet()-&gt;transaction_coordinator();</a>
<a name="ln824">  if (transaction_coordinator) {</a>
<a name="ln825">    auto transaction_coordinator_min_op_index = transaction_coordinator-&gt;PrepareGC(details);</a>
<a name="ln826">    min_index = std::min(min_index, transaction_coordinator_min_op_index);</a>
<a name="ln827">  }</a>
<a name="ln828"> </a>
<a name="ln829">  // We keep at least one committed operation in the log so that we can always recover safe time</a>
<a name="ln830">  // during bootstrap.</a>
<a name="ln831">  // Last committed op id should be read before MaxPersistentOpId to avoid race condition</a>
<a name="ln832">  // described in MaxPersistentOpIdForDb.</a>
<a name="ln833">  //</a>
<a name="ln834">  // If we read last committed op id AFTER reading last persistent op id (INCORRECT):</a>
<a name="ln835">  // - We read max persistent op id and find there is no new data, so we ignore it.</a>
<a name="ln836">  // - New data gets written and Raft-committed, but not yet flushed to an SSTable.</a>
<a name="ln837">  // - We read the last committed op id, which is greater than what max persistent op id would have</a>
<a name="ln838">  //   returned.</a>
<a name="ln839">  // - We garbage-collect the Raft log entries corresponding to the new data.</a>
<a name="ln840">  // - Power is lost and the server reboots, losing committed data.</a>
<a name="ln841">  //</a>
<a name="ln842">  // If we read last committed op id BEFORE reading last persistent op id (CORRECT):</a>
<a name="ln843">  // - We read the last committed op id.</a>
<a name="ln844">  // - We read max persistent op id and find there is no new data, so we ignore it.</a>
<a name="ln845">  // - New data gets written and Raft-committed, but not yet flushed to an SSTable.</a>
<a name="ln846">  // - We still don't garbage-collect the logs containing the committed but unflushed data,</a>
<a name="ln847">  //   because the earlier value of the last committed op id that we read prevents us from doing so.</a>
<a name="ln848">  auto last_committed_op_id = consensus()-&gt;GetLastCommittedOpId();</a>
<a name="ln849">  min_index = std::min(min_index, last_committed_op_id.index);</a>
<a name="ln850">  if (details) {</a>
<a name="ln851">    *details += Format(&quot;Last committed op id: $0\n&quot;, last_committed_op_id);</a>
<a name="ln852">  }</a>
<a name="ln853"> </a>
<a name="ln854">  if (tablet_-&gt;table_type() != TableType::TRANSACTION_STATUS_TABLE_TYPE) {</a>
<a name="ln855">    tablet_-&gt;FlushIntentsDbIfNecessary(latest_log_entry_op_id);</a>
<a name="ln856">    auto max_persistent_op_id = VERIFY_RESULT(</a>
<a name="ln857">        tablet_-&gt;MaxPersistentOpId(true /* invalid_if_no_new_data */));</a>
<a name="ln858">    if (max_persistent_op_id.regular.valid()) {</a>
<a name="ln859">      min_index = std::min(min_index, max_persistent_op_id.regular.index);</a>
<a name="ln860">      if (details) {</a>
<a name="ln861">        *details += Format(&quot;Max persistent regular op id: $0\n&quot;, max_persistent_op_id.regular);</a>
<a name="ln862">      }</a>
<a name="ln863">    }</a>
<a name="ln864">    if (max_persistent_op_id.intents.valid()) {</a>
<a name="ln865">      min_index = std::min(min_index, max_persistent_op_id.intents.index);</a>
<a name="ln866">      if (details) {</a>
<a name="ln867">        *details += Format(&quot;Max persistent intents op id: $0\n&quot;, max_persistent_op_id.intents);</a>
<a name="ln868">      }</a>
<a name="ln869">    }</a>
<a name="ln870">  }</a>
<a name="ln871"> </a>
<a name="ln872">  {</a>
<a name="ln873">    // We should prevent Raft log GC from deleting SPLIT_OP designated for this tablet, because</a>
<a name="ln874">    // it is used during bootstrap to initialize ReplicaState::split_op_id_ which in its turn</a>
<a name="ln875">    // is used to prevent already split tablet from serving new ops.</a>
<a name="ln876">    auto split_op_id = consensus()-&gt;GetSplitOpId();</a>
<a name="ln877">    if (split_op_id) {</a>
<a name="ln878">      min_index = std::min(min_index, split_op_id.index);</a>
<a name="ln879">    }</a>
<a name="ln880">  }</a>
<a name="ln881"> </a>
<a name="ln882">  if (details) {</a>
<a name="ln883">    *details += Format(&quot;Earliest needed log index: $0\n&quot;, min_index);</a>
<a name="ln884">  }</a>
<a name="ln885"> </a>
<a name="ln886">  return min_index;</a>
<a name="ln887">}</a>
<a name="ln888"> </a>
<a name="ln889">Status TabletPeer::GetMaxIndexesToSegmentSizeMap(MaxIdxToSegmentSizeMap* idx_size_map) const {</a>
<a name="ln890">  RETURN_NOT_OK(CheckRunning());</a>
<a name="ln891">  int64_t min_op_idx = VERIFY_RESULT(GetEarliestNeededLogIndex());</a>
<a name="ln892">  log_-&gt;GetMaxIndexesToSegmentSizeMap(min_op_idx, idx_size_map);</a>
<a name="ln893">  return Status::OK();</a>
<a name="ln894">}</a>
<a name="ln895"> </a>
<a name="ln896">Status TabletPeer::GetGCableDataSize(int64_t* retention_size) const {</a>
<a name="ln897">  RETURN_NOT_OK(CheckRunning());</a>
<a name="ln898">  int64_t min_op_idx = VERIFY_RESULT(GetEarliestNeededLogIndex());</a>
<a name="ln899">  RETURN_NOT_OK(log_-&gt;GetGCableDataSize(min_op_idx, retention_size));</a>
<a name="ln900">  return Status::OK();</a>
<a name="ln901">}</a>
<a name="ln902"> </a>
<a name="ln903">log::Log* TabletPeer::log() const {</a>
<a name="ln904">  Log* log = log_atomic_.load(std::memory_order_acquire);</a>
<a name="ln905">  LOG_IF_WITH_PREFIX(FATAL, !log) &lt;&lt; &quot;log() called before the log instance is initialized.&quot;;</a>
<a name="ln906">  return log;</a>
<a name="ln907">}</a>
<a name="ln908"> </a>
<a name="ln909">yb::OpId TabletPeer::GetLatestLogEntryOpId() const {</a>
<a name="ln910">  Log* log = log_atomic_.load(std::memory_order_acquire);</a>
<a name="ln911">  if (log) {</a>
<a name="ln912">    return log-&gt;GetLatestEntryOpId();</a>
<a name="ln913">  }</a>
<a name="ln914">  return yb::OpId();</a>
<a name="ln915">}</a>
<a name="ln916"> </a>
<a name="ln917">Status TabletPeer::set_cdc_min_replicated_index_unlocked(int64_t cdc_min_replicated_index) {</a>
<a name="ln918">  LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Setting cdc min replicated index to &quot; &lt;&lt; cdc_min_replicated_index;</a>
<a name="ln919">  RETURN_NOT_OK(meta_-&gt;set_cdc_min_replicated_index(cdc_min_replicated_index));</a>
<a name="ln920">  Log* log = log_atomic_.load(std::memory_order_acquire);</a>
<a name="ln921">  if (log) {</a>
<a name="ln922">    log-&gt;set_cdc_min_replicated_index(cdc_min_replicated_index);</a>
<a name="ln923">  }</a>
<a name="ln924">  cdc_min_replicated_index_refresh_time_ = MonoTime::Now();</a>
<a name="ln925">  return Status::OK();</a>
<a name="ln926">}</a>
<a name="ln927"> </a>
<a name="ln928">Status TabletPeer::set_cdc_min_replicated_index(int64_t cdc_min_replicated_index) {</a>
<a name="ln929">  std::lock_guard&lt;decltype(cdc_min_replicated_index_lock_)&gt; l(cdc_min_replicated_index_lock_);</a>
<a name="ln930">  return set_cdc_min_replicated_index_unlocked(cdc_min_replicated_index);</a>
<a name="ln931">}</a>
<a name="ln932"> </a>
<a name="ln933">Status TabletPeer::reset_cdc_min_replicated_index_if_stale() {</a>
<a name="ln934">  std::lock_guard&lt;decltype(cdc_min_replicated_index_lock_)&gt; l(cdc_min_replicated_index_lock_);</a>
<a name="ln935">  auto seconds_since_last_refresh =</a>
<a name="ln936">      MonoTime::Now().GetDeltaSince(cdc_min_replicated_index_refresh_time_).ToSeconds();</a>
<a name="ln937">  if (seconds_since_last_refresh &gt; FLAGS_cdc_min_replicated_index_considered_stale_secs) {</a>
<a name="ln938">    LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Resetting cdc min replicated index. Seconds since last update: &quot;</a>
<a name="ln939">                          &lt;&lt; seconds_since_last_refresh;</a>
<a name="ln940">    RETURN_NOT_OK(set_cdc_min_replicated_index_unlocked(std::numeric_limits&lt;int64_t&gt;::max()));</a>
<a name="ln941">  }</a>
<a name="ln942">  return Status::OK();</a>
<a name="ln943">}</a>
<a name="ln944"> </a>
<a name="ln945">std::unique_ptr&lt;Operation&gt; TabletPeer::CreateOperation(consensus::ReplicateMsg* replicate_msg) {</a>
<a name="ln946">  switch (replicate_msg-&gt;op_type()) {</a>
<a name="ln947">    case consensus::WRITE_OP:</a>
<a name="ln948">      DCHECK(replicate_msg-&gt;has_write_request()) &lt;&lt; &quot;WRITE_OP replica&quot;</a>
<a name="ln949">          &quot; operation must receive a WriteRequestPB&quot;;</a>
<a name="ln950">      // We use separate preparing token only on leader, so here it could be empty.</a>
<a name="ln951">      return std::make_unique&lt;WriteOperation&gt;(</a>
<a name="ln952">          std::make_unique&lt;WriteOperationState&gt;(tablet()), yb::OpId::kUnknownTerm,</a>
<a name="ln953">          ScopedOperation(), CoarseTimePoint::max(), this);</a>
<a name="ln954"> </a>
<a name="ln955">    case consensus::CHANGE_METADATA_OP:</a>
<a name="ln956">      DCHECK(replicate_msg-&gt;has_change_metadata_request()) &lt;&lt; &quot;CHANGE_METADATA_OP replica&quot;</a>
<a name="ln957">          &quot; operation must receive an ChangeMetadataRequestPB&quot;;</a>
<a name="ln958">      return std::make_unique&lt;ChangeMetadataOperation&gt;(</a>
<a name="ln959">          std::make_unique&lt;ChangeMetadataOperationState&gt;(tablet(), log()));</a>
<a name="ln960"> </a>
<a name="ln961">    case consensus::UPDATE_TRANSACTION_OP:</a>
<a name="ln962">      DCHECK(replicate_msg-&gt;has_transaction_state()) &lt;&lt; &quot;UPDATE_TRANSACTION_OP replica&quot;</a>
<a name="ln963">          &quot; operation must receive an TransactionStatePB&quot;;</a>
<a name="ln964">      return std::make_unique&lt;UpdateTxnOperation&gt;(</a>
<a name="ln965">          std::make_unique&lt;UpdateTxnOperationState&gt;(tablet()));</a>
<a name="ln966"> </a>
<a name="ln967">    case consensus::TRUNCATE_OP:</a>
<a name="ln968">      DCHECK(replicate_msg-&gt;has_truncate_request()) &lt;&lt; &quot;TRUNCATE_OP replica&quot;</a>
<a name="ln969">          &quot; operation must receive an TruncateRequestPB&quot;;</a>
<a name="ln970">      return std::make_unique&lt;TruncateOperation&gt;(</a>
<a name="ln971">          std::make_unique&lt;TruncateOperationState&gt;(tablet()));</a>
<a name="ln972"> </a>
<a name="ln973">    case consensus::SNAPSHOT_OP:</a>
<a name="ln974">       DCHECK(replicate_msg-&gt;has_snapshot_request()) &lt;&lt; &quot;SNAPSHOT_OP replica&quot;</a>
<a name="ln975">          &quot; operation must receive an TabletSnapshotOpRequestPB&quot;;</a>
<a name="ln976">      return std::make_unique&lt;SnapshotOperation&gt;(</a>
<a name="ln977">          std::make_unique&lt;SnapshotOperationState&gt;(tablet()));</a>
<a name="ln978"> </a>
<a name="ln979">    case consensus::HISTORY_CUTOFF_OP:</a>
<a name="ln980">       DCHECK(replicate_msg-&gt;has_history_cutoff()) &lt;&lt; &quot;HISTORY_CUTOFF_OP replica&quot;</a>
<a name="ln981">          &quot; transaction must receive an HistoryCutoffPB&quot;;</a>
<a name="ln982">      return std::make_unique&lt;HistoryCutoffOperation&gt;(</a>
<a name="ln983">          std::make_unique&lt;HistoryCutoffOperationState&gt;(tablet()));</a>
<a name="ln984"> </a>
<a name="ln985">    case consensus::SPLIT_OP:</a>
<a name="ln986">       DCHECK(replicate_msg-&gt;has_split_request()) &lt;&lt; &quot;SPLIT_OP replica&quot;</a>
<a name="ln987">          &quot; operation must receive an SplitOpRequestPB&quot;;</a>
<a name="ln988">      return std::make_unique&lt;SplitOperation&gt;(</a>
<a name="ln989">          std::make_unique&lt;SplitOperationState&gt;(tablet(), raft_consensus(), tablet_splitter_));</a>
<a name="ln990"> </a>
<a name="ln991">    case consensus::UNKNOWN_OP: FALLTHROUGH_INTENDED;</a>
<a name="ln992">    case consensus::NO_OP: FALLTHROUGH_INTENDED;</a>
<a name="ln993">    case consensus::CHANGE_CONFIG_OP:</a>
<a name="ln994">      FATAL_INVALID_ENUM_VALUE(consensus::OperationType, replicate_msg-&gt;op_type());</a>
<a name="ln995">  }</a>
<a name="ln996">  FATAL_INVALID_ENUM_VALUE(consensus::OperationType, replicate_msg-&gt;op_type());</a>
<a name="ln997">}</a>
<a name="ln998"> </a>
<a name="ln999">Status TabletPeer::StartReplicaOperation(</a>
<a name="ln1000">    const scoped_refptr&lt;ConsensusRound&gt;&amp; round, HybridTime propagated_safe_time) {</a>
<a name="ln1001">  RaftGroupStatePB value = state();</a>
<a name="ln1002">  if (value != RaftGroupStatePB::RUNNING &amp;&amp; value != RaftGroupStatePB::BOOTSTRAPPING) {</a>
<a name="ln1003">    return STATUS(IllegalState, RaftGroupStatePB_Name(value));</a>
<a name="ln1004">  }</a>
<a name="ln1005"> </a>
<a name="ln1006">  consensus::ReplicateMsg* replicate_msg = round-&gt;replicate_msg().get();</a>
<a name="ln1007">  DCHECK(replicate_msg-&gt;has_hybrid_time());</a>
<a name="ln1008">  auto operation = CreateOperation(replicate_msg);</a>
<a name="ln1009"> </a>
<a name="ln1010">  // TODO(todd) Look at wiring the stuff below on the driver</a>
<a name="ln1011">  OperationState* state = operation-&gt;state();</a>
<a name="ln1012">  // It's imperative that we set the round here on any type of operation, as this</a>
<a name="ln1013">  // allows us to keep the reference to the request in the round instead of copying it.</a>
<a name="ln1014">  state-&gt;set_consensus_round(round);</a>
<a name="ln1015">  HybridTime ht(replicate_msg-&gt;hybrid_time());</a>
<a name="ln1016">  state-&gt;set_hybrid_time(ht);</a>
<a name="ln1017">  clock_-&gt;Update(ht);</a>
<a name="ln1018"> </a>
<a name="ln1019">  // This sets the monotonic counter to at least replicate_msg.monotonic_counter() atomically.</a>
<a name="ln1020">  tablet_-&gt;UpdateMonotonicCounter(replicate_msg-&gt;monotonic_counter());</a>
<a name="ln1021"> </a>
<a name="ln1022">  auto operation_type = operation-&gt;operation_type();</a>
<a name="ln1023">  OperationDriverPtr driver = VERIFY_RESULT(NewReplicaOperationDriver(&amp;operation));</a>
<a name="ln1024"> </a>
<a name="ln1025">  // Unretained is required to avoid a refcount cycle.</a>
<a name="ln1026">  state-&gt;consensus_round()-&gt;SetConsensusReplicatedCallback(</a>
<a name="ln1027">      std::bind(&amp;OperationDriver::ReplicationFinished, driver.get(), _1, _2, _3));</a>
<a name="ln1028"> </a>
<a name="ln1029">  if (propagated_safe_time) {</a>
<a name="ln1030">    driver-&gt;SetPropagatedSafeTime(propagated_safe_time, tablet_-&gt;mvcc_manager());</a>
<a name="ln1031">  }</a>
<a name="ln1032"> </a>
<a name="ln1033">  if (operation_type == OperationType::kWrite ||</a>
<a name="ln1034">      operation_type == OperationType::kUpdateTransaction) {</a>
<a name="ln1035">    tablet()-&gt;mvcc_manager()-&gt;AddPending(&amp;ht);</a>
<a name="ln1036">  }</a>
<a name="ln1037"> </a>
<a name="ln1038">  driver-&gt;ExecuteAsync();</a>
<a name="ln1039">  return Status::OK();</a>
<a name="ln1040">}</a>
<a name="ln1041"> </a>
<a name="ln1042">void TabletPeer::SetPropagatedSafeTime(HybridTime ht) {</a>
<a name="ln1043">  auto driver = NewReplicaOperationDriver(nullptr);</a>
<a name="ln1044">  if (!driver.ok()) {</a>
<a name="ln1045">    LOG_WITH_PREFIX(ERROR) &lt;&lt; &quot;Failed to create operation driver to set propagated hybrid time&quot;;</a>
<a name="ln1046">    return;</a>
<a name="ln1047">  }</a>
<a name="ln1048">  (**driver).SetPropagatedSafeTime(ht, tablet_-&gt;mvcc_manager());</a>
<a name="ln1049">  (**driver).ExecuteAsync();</a>
<a name="ln1050">}</a>
<a name="ln1051"> </a>
<a name="ln1052">bool TabletPeer::ShouldApplyWrite() {</a>
<a name="ln1053">  return tablet_-&gt;ShouldApplyWrite();</a>
<a name="ln1054">}</a>
<a name="ln1055"> </a>
<a name="ln1056">consensus::Consensus* TabletPeer::consensus() const {</a>
<a name="ln1057">  return raft_consensus();</a>
<a name="ln1058">}</a>
<a name="ln1059"> </a>
<a name="ln1060">consensus::RaftConsensus* TabletPeer::raft_consensus() const {</a>
<a name="ln1061">  std::lock_guard&lt;simple_spinlock&gt; lock(lock_);</a>
<a name="ln1062">  return consensus_.get();</a>
<a name="ln1063">}</a>
<a name="ln1064"> </a>
<a name="ln1065">shared_ptr&lt;consensus::Consensus&gt; TabletPeer::shared_consensus() const {</a>
<a name="ln1066">  std::lock_guard&lt;simple_spinlock&gt; lock(lock_);</a>
<a name="ln1067">  return consensus_;</a>
<a name="ln1068">}</a>
<a name="ln1069"> </a>
<a name="ln1070">Result&lt;OperationDriverPtr&gt; TabletPeer::NewLeaderOperationDriver(</a>
<a name="ln1071">    std::unique_ptr&lt;Operation&gt;* operation, int64_t term) {</a>
<a name="ln1072">  return NewOperationDriver(operation, term);</a>
<a name="ln1073">}</a>
<a name="ln1074"> </a>
<a name="ln1075">Result&lt;OperationDriverPtr&gt; TabletPeer::NewReplicaOperationDriver(</a>
<a name="ln1076">    std::unique_ptr&lt;Operation&gt;* operation) {</a>
<a name="ln1077">  return NewOperationDriver(operation, yb::OpId::kUnknownTerm);</a>
<a name="ln1078">}</a>
<a name="ln1079"> </a>
<a name="ln1080">Result&lt;OperationDriverPtr&gt; TabletPeer::NewOperationDriver(std::unique_ptr&lt;Operation&gt;* operation,</a>
<a name="ln1081">                                                          int64_t term) {</a>
<a name="ln1082">  auto operation_driver = CreateOperationDriver();</a>
<a name="ln1083">  RETURN_NOT_OK(operation_driver-&gt;Init(operation, term));</a>
<a name="ln1084">  return operation_driver;</a>
<a name="ln1085">}</a>
<a name="ln1086"> </a>
<a name="ln1087">void TabletPeer::RegisterMaintenanceOps(MaintenanceManager* maint_mgr) {</a>
<a name="ln1088">  // Taking state_change_lock_ ensures that we don't shut down concurrently with</a>
<a name="ln1089">  // this last start-up task.</a>
<a name="ln1090">  // Note that the state_change_lock_ is taken in Shutdown(),</a>
<a name="ln1091">  // prior to calling UnregisterMaintenanceOps().</a>
<a name="ln1092"> </a>
<a name="ln1093">  std::lock_guard&lt;simple_spinlock&gt; l(state_change_lock_);</a>
<a name="ln1094"> </a>
<a name="ln1095">  if (state() != RaftGroupStatePB::RUNNING) {</a>
<a name="ln1096">    LOG_WITH_PREFIX(WARNING) &lt;&lt; &quot;Not registering maintenance operations: tablet not RUNNING&quot;;</a>
<a name="ln1097">    return;</a>
<a name="ln1098">  }</a>
<a name="ln1099"> </a>
<a name="ln1100">  DCHECK(maintenance_ops_.empty());</a>
<a name="ln1101"> </a>
<a name="ln1102">  gscoped_ptr&lt;MaintenanceOp&gt; log_gc(new LogGCOp(this));</a>
<a name="ln1103">  maint_mgr-&gt;RegisterOp(log_gc.get());</a>
<a name="ln1104">  maintenance_ops_.push_back(log_gc.release());</a>
<a name="ln1105">  LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Registered log gc&quot;;</a>
<a name="ln1106">}</a>
<a name="ln1107"> </a>
<a name="ln1108">void TabletPeer::UnregisterMaintenanceOps() {</a>
<a name="ln1109">  DCHECK(state_change_lock_.is_locked());</a>
<a name="ln1110">  for (MaintenanceOp* op : maintenance_ops_) {</a>
<a name="ln1111">    op-&gt;Unregister();</a>
<a name="ln1112">  }</a>
<a name="ln1113">  STLDeleteElements(&amp;maintenance_ops_);</a>
<a name="ln1114">}</a>
<a name="ln1115"> </a>
<a name="ln1116">TabletOnDiskSizeInfo TabletPeer::GetOnDiskSizeInfo() const {</a>
<a name="ln1117">  TabletOnDiskSizeInfo info;</a>
<a name="ln1118"> </a>
<a name="ln1119">  if (consensus_) {</a>
<a name="ln1120">    info.consensus_metadata_disk_size = consensus_-&gt;OnDiskSize();</a>
<a name="ln1121">  }</a>
<a name="ln1122"> </a>
<a name="ln1123">  if (tablet_) {</a>
<a name="ln1124">    info.sst_files_disk_size = tablet_-&gt;GetCurrentVersionSstFilesSize();</a>
<a name="ln1125">    info.uncompressed_sst_files_disk_size =</a>
<a name="ln1126">        tablet_-&gt;GetCurrentVersionSstFilesUncompressedSize();</a>
<a name="ln1127">  }</a>
<a name="ln1128"> </a>
<a name="ln1129">  if (log_) {</a>
<a name="ln1130">    info.wal_files_disk_size = log_-&gt;OnDiskSize();</a>
<a name="ln1131">  }</a>
<a name="ln1132"> </a>
<a name="ln1133">  info.RecomputeTotalSize();</a>
<a name="ln1134">  return info;</a>
<a name="ln1135">}</a>
<a name="ln1136"> </a>
<a name="ln1137">int TabletPeer::GetNumLogSegments() const {</a>
<a name="ln1138">  return (log_) ? log_-&gt;num_segments() : 0;</a>
<a name="ln1139">}</a>
<a name="ln1140"> </a>
<a name="ln1141">std::string TabletPeer::LogPrefix() const {</a>
<a name="ln1142">  return Substitute(&quot;T $0 P $1 [state=$2]: &quot;,</a>
<a name="ln1143">      tablet_id_, permanent_uuid_, RaftGroupStatePB_Name(state()));</a>
<a name="ln1144">}</a>
<a name="ln1145"> </a>
<a name="ln1146">scoped_refptr&lt;OperationDriver&gt; TabletPeer::CreateOperationDriver() {</a>
<a name="ln1147">  return scoped_refptr&lt;OperationDriver&gt;(new OperationDriver(</a>
<a name="ln1148">      &amp;operation_tracker_,</a>
<a name="ln1149">      consensus_.get(),</a>
<a name="ln1150">      log_.get(),</a>
<a name="ln1151">      prepare_thread_.get(),</a>
<a name="ln1152">      &amp;operation_order_verifier_,</a>
<a name="ln1153">      tablet_-&gt;table_type()));</a>
<a name="ln1154">}</a>
<a name="ln1155"> </a>
<a name="ln1156">int64_t TabletPeer::LeaderTerm() const {</a>
<a name="ln1157">  shared_ptr&lt;consensus::Consensus&gt; consensus;</a>
<a name="ln1158">  {</a>
<a name="ln1159">    std::lock_guard&lt;simple_spinlock&gt; lock(lock_);</a>
<a name="ln1160">    consensus = consensus_;</a>
<a name="ln1161">  }</a>
<a name="ln1162">  return consensus ? consensus-&gt;LeaderTerm() : yb::OpId::kUnknownTerm;</a>
<a name="ln1163">}</a>
<a name="ln1164"> </a>
<a name="ln1165">consensus::LeaderStatus TabletPeer::LeaderStatus(bool allow_stale) const {</a>
<a name="ln1166">  shared_ptr&lt;consensus::Consensus&gt; consensus;</a>
<a name="ln1167">  {</a>
<a name="ln1168">    std::lock_guard&lt;simple_spinlock&gt; lock(lock_);</a>
<a name="ln1169">    consensus = consensus_;</a>
<a name="ln1170">  }</a>
<a name="ln1171">  return consensus ? consensus-&gt;GetLeaderStatus(allow_stale) : consensus::LeaderStatus::NOT_LEADER;</a>
<a name="ln1172">}</a>
<a name="ln1173"> </a>
<a name="ln1174">HybridTime TabletPeer::HtLeaseExpiration() const {</a>
<a name="ln1175">  HybridTime result(consensus_-&gt;MajorityReplicatedHtLeaseExpiration(0, CoarseTimePoint::max()), 0);</a>
<a name="ln1176">  return std::max(result, tablet_-&gt;mvcc_manager()-&gt;LastReplicatedHybridTime());</a>
<a name="ln1177">}</a>
<a name="ln1178"> </a>
<a name="ln1179">TableType TabletPeer::table_type() {</a>
<a name="ln1180">  // TODO: what if tablet is not set?</a>
<a name="ln1181">  return DCHECK_NOTNULL(tablet())-&gt;table_type();</a>
<a name="ln1182">}</a>
<a name="ln1183"> </a>
<a name="ln1184">void TabletPeer::SetFailed(const Status&amp; error) {</a>
<a name="ln1185">  DCHECK(error_.get(std::memory_order_acquire) == nullptr);</a>
<a name="ln1186">  error_ = MakeAtomicUniquePtr&lt;Status&gt;(error);</a>
<a name="ln1187">  auto state = state_.load(std::memory_order_acquire);</a>
<a name="ln1188">  while (state != RaftGroupStatePB::FAILED &amp;&amp; state != RaftGroupStatePB::QUIESCING &amp;&amp;</a>
<a name="ln1189">         state != RaftGroupStatePB::SHUTDOWN) {</a>
<a name="ln1190">    if (state_.compare_exchange_weak(state, RaftGroupStatePB::FAILED, std::memory_order_acq_rel)) {</a>
<a name="ln1191">      LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Changed state from &quot; &lt;&lt; RaftGroupStatePB_Name(state)</a>
<a name="ln1192">                            &lt;&lt; &quot; to FAILED&quot;;</a>
<a name="ln1193">      break;</a>
<a name="ln1194">    }</a>
<a name="ln1195">  }</a>
<a name="ln1196">}</a>
<a name="ln1197"> </a>
<a name="ln1198">Status TabletPeer::UpdateState(RaftGroupStatePB expected, RaftGroupStatePB new_state,</a>
<a name="ln1199">                               const std::string&amp; error_message) {</a>
<a name="ln1200">  RaftGroupStatePB old = expected;</a>
<a name="ln1201">  if (!state_.compare_exchange_strong(old, new_state, std::memory_order_acq_rel)) {</a>
<a name="ln1202">    return STATUS_FORMAT(</a>
<a name="ln1203">        InvalidArgument, &quot;$0 Expected state: $1, got: $2&quot;,</a>
<a name="ln1204">        error_message, RaftGroupStatePB_Name(expected), RaftGroupStatePB_Name(old));</a>
<a name="ln1205">  }</a>
<a name="ln1206"> </a>
<a name="ln1207">  LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Changed state from &quot; &lt;&lt; RaftGroupStatePB_Name(old) &lt;&lt; &quot; to &quot;</a>
<a name="ln1208">                        &lt;&lt; RaftGroupStatePB_Name(new_state);</a>
<a name="ln1209">  return Status::OK();</a>
<a name="ln1210">}</a>
<a name="ln1211"> </a>
<a name="ln1212">void TabletPeer::Enqueue(rpc::ThreadPoolTask* task) {</a>
<a name="ln1213">  rpc::ThreadPool* thread_pool = service_thread_pool_.load(std::memory_order_acquire);</a>
<a name="ln1214">  if (!thread_pool) {</a>
<a name="ln1215">    task-&gt;Done(STATUS(Aborted, &quot;Thread pool not ready&quot;));</a>
<a name="ln1216">    return;</a>
<a name="ln1217">  }</a>
<a name="ln1218"> </a>
<a name="ln1219">  thread_pool-&gt;Enqueue(task);</a>
<a name="ln1220">}</a>
<a name="ln1221"> </a>
<a name="ln1222">void TabletPeer::StrandEnqueue(rpc::StrandTask* task) {</a>
<a name="ln1223">  rpc::Strand* strand = strand_.get();</a>
<a name="ln1224">  if (!strand) {</a>
<a name="ln1225">    task-&gt;Done(STATUS(Aborted, &quot;Thread pool not ready&quot;));</a>
<a name="ln1226">    return;</a>
<a name="ln1227">  }</a>
<a name="ln1228"> </a>
<a name="ln1229">  strand-&gt;Enqueue(task);</a>
<a name="ln1230">}</a>
<a name="ln1231"> </a>
<a name="ln1232">}  // namespace tablet</a>
<a name="ln1233">}  // namespace yb</a>

</code></pre>
<div class="balloon" rel="178"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="192"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="193"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="302"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="335"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="382"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="384"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="388"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="408"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="472"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="487"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="492"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="521"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="658"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="659"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="661"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1004/" target="_blank">V1004</a> The 'status_pb_out' pointer was used unsafely after it was verified against nullptr. Check lines: 658, 661.</p></div>
<div class="balloon" rel="792"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="813"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'min_index' should be checked here.</p></div>
<div class="balloon" rel="905"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="948"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="956"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="962"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="968"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="974"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="980"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="986"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1007"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1100"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1109"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1185"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="150"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: proxy_cache_.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
