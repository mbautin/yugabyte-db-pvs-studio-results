
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>jsonb.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Copyright (c) YugaByte, Inc.</a>
<a name="ln2">//</a>
<a name="ln3">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln4">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln5">//</a>
<a name="ln6">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln7">//</a>
<a name="ln8">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln9">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln10">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln11">// under the License.</a>
<a name="ln12">//</a>
<a name="ln13"> </a>
<a name="ln14">#include &lt;rapidjson/error/en.h&gt;</a>
<a name="ln15"> </a>
<a name="ln16">#include &quot;yb/common/jsonb.h&quot;</a>
<a name="ln17">#include &quot;yb/common/json_util.h&quot;</a>
<a name="ln18">#include &quot;yb/common/ql_value.h&quot;</a>
<a name="ln19"> </a>
<a name="ln20">#include &quot;yb/util/kv_util.h&quot;</a>
<a name="ln21">#include &quot;yb/util/stol_utils.h&quot;</a>
<a name="ln22">#include &quot;yb/util/varint.h&quot;</a>
<a name="ln23"> </a>
<a name="ln24">namespace yb {</a>
<a name="ln25">namespace common {</a>
<a name="ln26"> </a>
<a name="ln27">bool Jsonb::IsScalar(const JEntry&amp; jentry) {</a>
<a name="ln28">  uint32_t jentry_type = GetJEType(jentry);</a>
<a name="ln29">  return ((jentry_type) != kJEIsArray &amp;&amp; (jentry_type) != kJEIsObject);</a>
<a name="ln30">}</a>
<a name="ln31"> </a>
<a name="ln32">size_t Jsonb::ComputeDataOffset(const size_t num_entries, const uint32_t container_type) {</a>
<a name="ln33">  const size_t num_jentries = (container_type &amp; kJBArray) ? num_entries : 2 * num_entries;</a>
<a name="ln34">  return sizeof(JsonbHeader) + num_jentries * sizeof(JEntry);</a>
<a name="ln35">}</a>
<a name="ln36"> </a>
<a name="ln37">Jsonb::Jsonb() {</a>
<a name="ln38">}</a>
<a name="ln39"> </a>
<a name="ln40">Jsonb::Jsonb(const std::string&amp; jsonb)</a>
<a name="ln41">    : serialized_jsonb_(jsonb) {</a>
<a name="ln42">}</a>
<a name="ln43"> </a>
<a name="ln44">Jsonb::Jsonb(std::string&amp;&amp; jsonb)</a>
<a name="ln45">    : serialized_jsonb_(std::move(jsonb)) {</a>
<a name="ln46">}</a>
<a name="ln47"> </a>
<a name="ln48">void Jsonb::Assign(const std::string&amp; jsonb) {</a>
<a name="ln49">  serialized_jsonb_ = jsonb;</a>
<a name="ln50">}</a>
<a name="ln51"> </a>
<a name="ln52">void Jsonb::Assign(std::string&amp;&amp; jsonb) {</a>
<a name="ln53">  serialized_jsonb_ = std::move(jsonb);</a>
<a name="ln54">}</a>
<a name="ln55"> </a>
<a name="ln56">std::string&amp;&amp; Jsonb::MoveSerializedJsonb() {</a>
<a name="ln57">  return std::move(serialized_jsonb_);</a>
<a name="ln58">}</a>
<a name="ln59"> </a>
<a name="ln60">const std::string&amp; Jsonb::SerializedJsonb() const {</a>
<a name="ln61">  return serialized_jsonb_;</a>
<a name="ln62">}</a>
<a name="ln63"> </a>
<a name="ln64">bool Jsonb::operator==(const Jsonb&amp; other) const {</a>
<a name="ln65">  return serialized_jsonb_ == other.serialized_jsonb_;</a>
<a name="ln66">}</a>
<a name="ln67"> </a>
<a name="ln68">Status Jsonb::FromString(const std::string&amp; json) {</a>
<a name="ln69">  // Parse the json document.</a>
<a name="ln70">  rapidjson::Document document;</a>
<a name="ln71">  document.Parse&lt;0&gt;(json.c_str());</a>
<a name="ln72">  if (document.HasParseError()) {</a>
<a name="ln73">    return STATUS(Corruption, &quot;JSON text is corrupt&quot;,</a>
<a name="ln74">                  rapidjson::GetParseError_En(document.GetParseError()));</a>
<a name="ln75">  }</a>
<a name="ln76">  return FromRapidJson(document);</a>
<a name="ln77">}</a>
<a name="ln78"> </a>
<a name="ln79">Status Jsonb::FromRapidJson(const rapidjson::Document&amp; document) {</a>
<a name="ln80">  return ToJsonbInternal(document, &amp;serialized_jsonb_);</a>
<a name="ln81">}</a>
<a name="ln82"> </a>
<a name="ln83">Status Jsonb::FromRapidJson(const rapidjson::Value&amp; value) {</a>
<a name="ln84">  rapidjson::Document document;</a>
<a name="ln85">  document.CopyFrom(value, document.GetAllocator());</a>
<a name="ln86">  return FromRapidJson(document);</a>
<a name="ln87">}</a>
<a name="ln88"> </a>
<a name="ln89">Status Jsonb::FromQLValuePB(const QLValuePB&amp; value_pb) {</a>
<a name="ln90">  rapidjson::Document document;</a>
<a name="ln91">  RETURN_NOT_OK(ConvertQLValuePBToRapidJson(value_pb, &amp;document));</a>
<a name="ln92">  return FromRapidJson(document);</a>
<a name="ln93">}</a>
<a name="ln94"> </a>
<a name="ln95">std::pair&lt;size_t, size_t&gt; Jsonb::ComputeOffsetsAndJsonbHeader(size_t num_entries,</a>
<a name="ln96">                                                              uint32_t container_type,</a>
<a name="ln97">                                                              std::string* jsonb) {</a>
<a name="ln98">  // Compute the size we need to allocate for the metadata.</a>
<a name="ln99">  size_t metadata_offset = jsonb-&gt;size();</a>
<a name="ln100">  const size_t jsonb_metadata_size = ComputeDataOffset(num_entries, container_type);</a>
<a name="ln101"> </a>
<a name="ln102">  // Resize the string to fit the jsonb header and the jentry for keys and values.</a>
<a name="ln103">  jsonb-&gt;resize(metadata_offset + jsonb_metadata_size);</a>
<a name="ln104"> </a>
<a name="ln105">  // Store the jsonb header at the appropriate place.</a>
<a name="ln106">  JsonbHeader jsonb_header = GetCount(num_entries) | container_type;</a>
<a name="ln107">  BigEndian::Store32(&amp;((*jsonb)[metadata_offset]), jsonb_header);</a>
<a name="ln108">  metadata_offset += sizeof(JsonbHeader);</a>
<a name="ln109"> </a>
<a name="ln110">  return make_pair(metadata_offset, jsonb_metadata_size);</a>
<a name="ln111">}</a>
<a name="ln112"> </a>
<a name="ln113">CHECKED_STATUS Jsonb::ToJsonbProcessObject(const rapidjson::Value&amp; document,</a>
<a name="ln114">                                           std::string* jsonb) {</a>
<a name="ln115">  DCHECK(document.IsObject());</a>
<a name="ln116"> </a>
<a name="ln117">  // Use a map since we need to store the keys in sorted order.</a>
<a name="ln118">  std::map&lt;string, const rapidjson::Value&amp;&gt; kv_pairs;</a>
<a name="ln119">  for (const auto&amp; member : document.GetObject()) {</a>
<a name="ln120">    kv_pairs.emplace(member.name.GetString(), member.value);</a>
<a name="ln121">  }</a>
<a name="ln122"> </a>
<a name="ln123">  size_t metadata_offset, jsonb_metadata_size;</a>
<a name="ln124">  std::tie(metadata_offset, jsonb_metadata_size) = ComputeOffsetsAndJsonbHeader(kv_pairs.size(),</a>
<a name="ln125">                                                                                kJBObject, jsonb);</a>
<a name="ln126"> </a>
<a name="ln127">  // Now append the keys and store the key offsets in the jentry.</a>
<a name="ln128">  size_t data_begin_offset = jsonb-&gt;size();</a>
<a name="ln129">  for (const auto&amp; entry : kv_pairs) {</a>
<a name="ln130">    jsonb-&gt;append(entry.first);</a>
<a name="ln131">    auto key_offset = jsonb-&gt;size() - data_begin_offset;</a>
<a name="ln132">    JEntry jentry = GetOffset(key_offset) | kJEIsString; // keys are always strings.</a>
<a name="ln133">    BigEndian::Store32(&amp;((*jsonb)[metadata_offset]), jentry);</a>
<a name="ln134">    metadata_offset += sizeof(JEntry);</a>
<a name="ln135">  }</a>
<a name="ln136"> </a>
<a name="ln137">  // Append the values to the buffer.</a>
<a name="ln138">  for (const auto&amp; entry : kv_pairs) {</a>
<a name="ln139">    const rapidjson::Value&amp; value = entry.second;</a>
<a name="ln140">    RETURN_NOT_OK(ProcessJsonValueAndMetadata(value, data_begin_offset, jsonb, &amp;metadata_offset));</a>
<a name="ln141">  }</a>
<a name="ln142"> </a>
<a name="ln143">  // The metadata slice should now be empty.</a>
<a name="ln144">  if (data_begin_offset != metadata_offset) {</a>
<a name="ln145">    return STATUS(Corruption, &quot;Couldn't process entire data for json object&quot;);</a>
<a name="ln146">  }</a>
<a name="ln147">  return Status::OK();</a>
<a name="ln148">}</a>
<a name="ln149"> </a>
<a name="ln150">CHECKED_STATUS Jsonb::ProcessJsonValueAndMetadata(const rapidjson::Value&amp; value,</a>
<a name="ln151">                                                  const size_t data_begin_offset,</a>
<a name="ln152">                                                  std::string* jsonb,</a>
<a name="ln153">                                                  size_t* metadata_offset) {</a>
<a name="ln154">  JEntry jentry = 0;</a>
<a name="ln155">  switch (value.GetType()) {</a>
<a name="ln156">    case rapidjson::Type::kNullType:</a>
<a name="ln157">      jentry |= kJEIsNull;</a>
<a name="ln158">      break;</a>
<a name="ln159">    case rapidjson::Type::kFalseType:</a>
<a name="ln160">      jentry |= kJEIsBoolFalse;</a>
<a name="ln161">      break;</a>
<a name="ln162">    case rapidjson::Type::kTrueType:</a>
<a name="ln163">      jentry |= kJEIsBoolTrue;</a>
<a name="ln164">      break;</a>
<a name="ln165">    case rapidjson::Type::kArrayType:</a>
<a name="ln166">      jentry |= kJEIsArray;</a>
<a name="ln167">      RETURN_NOT_OK(ToJsonbInternal(value, jsonb));</a>
<a name="ln168">      break;</a>
<a name="ln169">    case rapidjson::Type::kObjectType:</a>
<a name="ln170">      jentry |= kJEIsObject;</a>
<a name="ln171">      RETURN_NOT_OK(ToJsonbInternal(value, jsonb));</a>
<a name="ln172">      break;</a>
<a name="ln173">    case rapidjson::Type::kNumberType:</a>
<a name="ln174">      if (value.IsInt()) {</a>
<a name="ln175">        jentry |= kJEIsInt;</a>
<a name="ln176">        util::AppendInt32ToKey(value.GetInt(), jsonb);</a>
<a name="ln177">      } else if (value.IsUint()) {</a>
<a name="ln178">        jentry |= kJEIsUInt;</a>
<a name="ln179">        util::AppendBigEndianUInt32(value.GetUint(), jsonb);</a>
<a name="ln180">      } else if (value.IsInt64()) {</a>
<a name="ln181">        jentry |= kJEIsInt64;</a>
<a name="ln182">        util::AppendInt64ToKey(value.GetInt64(), jsonb);</a>
<a name="ln183">      } else if (value.IsUint64()) {</a>
<a name="ln184">        jentry |= kJEIsUInt64;</a>
<a name="ln185">        util::AppendBigEndianUInt64(value.GetUint64(), jsonb);</a>
<a name="ln186">      } else if (value.IsFloat()) {</a>
<a name="ln187">        jentry |= kJEIsFloat;</a>
<a name="ln188">        util::AppendFloatToKey(value.GetFloat(), jsonb);</a>
<a name="ln189">      } else if (value.IsDouble()) {</a>
<a name="ln190">        jentry |= kJEIsDouble;</a>
<a name="ln191">        util::AppendDoubleToKey(value.GetDouble(), jsonb);</a>
<a name="ln192">      } else {</a>
<a name="ln193">        return STATUS(NotSupported, &quot;Numeric type is not supported&quot;);</a>
<a name="ln194">      }</a>
<a name="ln195">      break;</a>
<a name="ln196">    case rapidjson::Type::kStringType:</a>
<a name="ln197">      jentry |= kJEIsString;</a>
<a name="ln198">      jsonb-&gt;append(value.GetString());</a>
<a name="ln199">      break;</a>
<a name="ln200">  }</a>
<a name="ln201"> </a>
<a name="ln202">  // Store the offset.</a>
<a name="ln203">  size_t offset = jsonb-&gt;size() - data_begin_offset;</a>
<a name="ln204">  jentry |= GetOffset(offset);</a>
<a name="ln205"> </a>
<a name="ln206">  // Store the JEntry.</a>
<a name="ln207">  BigEndian::Store32(&amp;((*jsonb)[*metadata_offset]), jentry);</a>
<a name="ln208">  (*metadata_offset) += sizeof(JEntry);</a>
<a name="ln209">  return Status::OK();</a>
<a name="ln210">}</a>
<a name="ln211"> </a>
<a name="ln212">CHECKED_STATUS Jsonb::ToJsonbProcessArray(const rapidjson::Value&amp; document,</a>
<a name="ln213">                                          const bool is_scalar,</a>
<a name="ln214">                                          std::string* jsonb) {</a>
<a name="ln215">  DCHECK(document.IsArray());</a>
<a name="ln216"> </a>
<a name="ln217">  const auto&amp; json_array = document.GetArray();</a>
<a name="ln218">  const size_t num_array_entries = json_array.Size();</a>
<a name="ln219"> </a>
<a name="ln220">  uint32_t container_type = kJBArray;</a>
<a name="ln221">  if (is_scalar) {</a>
<a name="ln222">    // Scalars are an array with one element and the special kJBScalar field set in the header.</a>
<a name="ln223">    DCHECK_EQ(num_array_entries, 1);</a>
<a name="ln224">    container_type |= kJBScalar;</a>
<a name="ln225">  }</a>
<a name="ln226"> </a>
<a name="ln227">  size_t metadata_offset, jsonb_metadata_size;</a>
<a name="ln228">  std::tie(metadata_offset, jsonb_metadata_size) = ComputeOffsetsAndJsonbHeader(num_array_entries,</a>
<a name="ln229">                                                                                container_type,</a>
<a name="ln230">                                                                                jsonb);</a>
<a name="ln231">  const size_t data_begin_offset = jsonb-&gt;size();</a>
<a name="ln232">  // Append the array members to the buffer.</a>
<a name="ln233">  for (const rapidjson::Value&amp; value : json_array) {</a>
<a name="ln234">    RETURN_NOT_OK(ProcessJsonValueAndMetadata(value, data_begin_offset, jsonb, &amp;metadata_offset));</a>
<a name="ln235">  }</a>
<a name="ln236"> </a>
<a name="ln237">  // The metadata slice should now be empty.</a>
<a name="ln238">  if (data_begin_offset != metadata_offset) {</a>
<a name="ln239">    return STATUS(Corruption, &quot;Couldn't process entire data for json array&quot;);</a>
<a name="ln240">  }</a>
<a name="ln241">  return Status::OK();</a>
<a name="ln242">}</a>
<a name="ln243"> </a>
<a name="ln244">CHECKED_STATUS Jsonb::ToJsonbInternal(const rapidjson::Value&amp; document, std::string* jsonb) {</a>
<a name="ln245">  if (document.IsObject()) {</a>
<a name="ln246">    return ToJsonbProcessObject(document, jsonb);</a>
<a name="ln247">  } else if (document.IsArray()) {</a>
<a name="ln248">    return ToJsonbProcessArray(document, /* is_scalar */ false, jsonb);</a>
<a name="ln249">  } else {</a>
<a name="ln250">    // Scalar values are stored as an array with one element with a special field in the header</a>
<a name="ln251">    // indicating it is a scalar.</a>
<a name="ln252">    rapidjson::Document json_array;</a>
<a name="ln253">    json_array.SetArray();</a>
<a name="ln254"> </a>
<a name="ln255">    rapidjson::Value tmpvalue;</a>
<a name="ln256">    tmpvalue.CopyFrom(document, json_array.GetAllocator());</a>
<a name="ln257">    json_array.PushBack(std::move(tmpvalue), json_array.GetAllocator());</a>
<a name="ln258">    return ToJsonbProcessArray(json_array, true, jsonb);</a>
<a name="ln259">  }</a>
<a name="ln260">}</a>
<a name="ln261"> </a>
<a name="ln262">namespace {</a>
<a name="ln263"> </a>
<a name="ln264">template &lt;typename T&gt;</a>
<a name="ln265">void AddNumericMember(rapidjson::Document* document, const Slice&amp; key, T value) {</a>
<a name="ln266">  document-&gt;AddMember(rapidjson::Value(key.cdata(), key.size(), document-&gt;GetAllocator()),</a>
<a name="ln267">                      rapidjson::Value(value),</a>
<a name="ln268">                      document-&gt;GetAllocator());</a>
<a name="ln269">}</a>
<a name="ln270"> </a>
<a name="ln271">template &lt;typename T&gt;</a>
<a name="ln272">void PushBackNumericMember(rapidjson::Document* document, T value) {</a>
<a name="ln273">  document-&gt;PushBack(rapidjson::Value(value),</a>
<a name="ln274">                     document-&gt;GetAllocator());</a>
<a name="ln275">}</a>
<a name="ln276">} // anonymous namespace</a>
<a name="ln277"> </a>
<a name="ln278">Status Jsonb::ScalarToString(const JEntry&amp; element_metadata, const Slice&amp; json_value,</a>
<a name="ln279">                             string* result) {</a>
<a name="ln280">  switch (GetJEType(element_metadata)) {</a>
<a name="ln281">    case kJEIsString: {</a>
<a name="ln282">      *result = json_value.ToBuffer();</a>
<a name="ln283">      break;</a>
<a name="ln284">    }</a>
<a name="ln285">    case kJEIsInt: {</a>
<a name="ln286">      int32_t value = util::DecodeInt32FromKey(json_value);</a>
<a name="ln287">      *result = std::to_string(value);</a>
<a name="ln288">      break;</a>
<a name="ln289">    }</a>
<a name="ln290">    case kJEIsUInt: {</a>
<a name="ln291">      uint32_t value = BigEndian::Load32(json_value.data());</a>
<a name="ln292">      *result = std::to_string(value);</a>
<a name="ln293">      break;</a>
<a name="ln294">    }</a>
<a name="ln295">    case kJEIsInt64: {</a>
<a name="ln296">      int64_t value = util::DecodeInt64FromKey(json_value);</a>
<a name="ln297">      *result = std::to_string(value);</a>
<a name="ln298">      break;</a>
<a name="ln299">    }</a>
<a name="ln300">    case kJEIsUInt64: {</a>
<a name="ln301">      uint64_t value = BigEndian::Load64(json_value.data());</a>
<a name="ln302">      *result = std::to_string(value);</a>
<a name="ln303">      break;</a>
<a name="ln304">    }</a>
<a name="ln305">    case kJEIsDouble: {</a>
<a name="ln306">      double value = util::DecodeDoubleFromKey(json_value);</a>
<a name="ln307">      *result = std::to_string(value);</a>
<a name="ln308">      break;</a>
<a name="ln309">    }</a>
<a name="ln310">    case kJEIsFloat: {</a>
<a name="ln311">      float value = util::DecodeFloatFromKey(json_value);</a>
<a name="ln312">      *result = std::to_string(value);</a>
<a name="ln313">      break;</a>
<a name="ln314">    }</a>
<a name="ln315">    case kJEIsBoolFalse: {</a>
<a name="ln316">      *result = &quot;false&quot;;</a>
<a name="ln317">      break;</a>
<a name="ln318">    }</a>
<a name="ln319">    case kJEIsBoolTrue: {</a>
<a name="ln320">      *result = &quot;true&quot;;</a>
<a name="ln321">      break;</a>
<a name="ln322">    }</a>
<a name="ln323">    case kJEIsNull: {</a>
<a name="ln324">      *result = &quot;null&quot;;</a>
<a name="ln325">      break;</a>
<a name="ln326">    }</a>
<a name="ln327">    case kJEIsObject: FALLTHROUGH_INTENDED;</a>
<a name="ln328">    case kJEIsArray:</a>
<a name="ln329">      return STATUS(InvalidArgument, &quot;Arrays and Objects not supported for this method&quot;);</a>
<a name="ln330">  }</a>
<a name="ln331">  return Status::OK();</a>
<a name="ln332">}</a>
<a name="ln333"> </a>
<a name="ln334">Status Jsonb::FromJsonbProcessObject(const Slice&amp; jsonb,</a>
<a name="ln335">                                     const JsonbHeader&amp; jsonb_header,</a>
<a name="ln336">                                     rapidjson::Document* document) {</a>
<a name="ln337">  size_t metadata_begin_offset = sizeof(JsonbHeader);</a>
<a name="ln338"> </a>
<a name="ln339">  size_t nelems = GetCount(jsonb_header);</a>
<a name="ln340">  const size_t data_begin_offset = ComputeDataOffset(nelems, kJBObject);</a>
<a name="ln341"> </a>
<a name="ln342">  // Now read the kv pairs and build the json.</a>
<a name="ln343">  document-&gt;SetObject();</a>
<a name="ln344">  for (int i = 0; i &lt; nelems; i++) {</a>
<a name="ln345">    Slice key;</a>
<a name="ln346">    RETURN_NOT_OK(GetObjectKey(i, jsonb, metadata_begin_offset, data_begin_offset, &amp;key));</a>
<a name="ln347">    Slice json_value;</a>
<a name="ln348">    JEntry value_metadata;</a>
<a name="ln349">    RETURN_NOT_OK(GetObjectValue(i, jsonb, metadata_begin_offset, data_begin_offset, nelems,</a>
<a name="ln350">                                 &amp;json_value, &amp;value_metadata));</a>
<a name="ln351">    rapidjson::Value json_key(key.cdata(), key.size(), document-&gt;GetAllocator());</a>
<a name="ln352">    switch (GetJEType(value_metadata)) {</a>
<a name="ln353">      case kJEIsString: {</a>
<a name="ln354">        document-&gt;AddMember(json_key, rapidjson::Value(json_value.cdata(), json_value.size(),</a>
<a name="ln355">                                                       document-&gt;GetAllocator()),</a>
<a name="ln356">                            document-&gt;GetAllocator());</a>
<a name="ln357">        break;</a>
<a name="ln358">      }</a>
<a name="ln359">      case kJEIsInt: {</a>
<a name="ln360">        int32_t value = util::DecodeInt32FromKey(json_value);</a>
<a name="ln361">        AddNumericMember(document, key, value);</a>
<a name="ln362">        break;</a>
<a name="ln363">      }</a>
<a name="ln364">      case kJEIsUInt: {</a>
<a name="ln365">        uint32_t value = BigEndian::Load32(json_value.data());</a>
<a name="ln366">        AddNumericMember(document, key, value);</a>
<a name="ln367">        break;</a>
<a name="ln368">      }</a>
<a name="ln369">      case kJEIsInt64: {</a>
<a name="ln370">        int64_t value = util::DecodeInt64FromKey(json_value);</a>
<a name="ln371">        AddNumericMember(document, key, value);</a>
<a name="ln372">        break;</a>
<a name="ln373">      }</a>
<a name="ln374">      case kJEIsUInt64: {</a>
<a name="ln375">        uint64_t value = BigEndian::Load64(json_value.data());</a>
<a name="ln376">        AddNumericMember(document, key, value);</a>
<a name="ln377">        break;</a>
<a name="ln378">      }</a>
<a name="ln379">      case kJEIsDouble: {</a>
<a name="ln380">        double value = util::DecodeDoubleFromKey(json_value);</a>
<a name="ln381">        AddNumericMember(document, key, value);</a>
<a name="ln382">        break;</a>
<a name="ln383">      }</a>
<a name="ln384">      case kJEIsFloat: {</a>
<a name="ln385">        float value = util::DecodeFloatFromKey(json_value);</a>
<a name="ln386">        AddNumericMember(document, key, value);</a>
<a name="ln387">        break;</a>
<a name="ln388">      }</a>
<a name="ln389">      case kJEIsBoolFalse: {</a>
<a name="ln390">        document-&gt;AddMember(json_key,</a>
<a name="ln391">                            rapidjson::Value(false),</a>
<a name="ln392">                            document-&gt;GetAllocator());</a>
<a name="ln393">        break;</a>
<a name="ln394">      }</a>
<a name="ln395">      case kJEIsBoolTrue: {</a>
<a name="ln396">        document-&gt;AddMember(json_key,</a>
<a name="ln397">                            rapidjson::Value(true),</a>
<a name="ln398">                            document-&gt;GetAllocator());</a>
<a name="ln399">        break;</a>
<a name="ln400">      }</a>
<a name="ln401">      case kJEIsNull: {</a>
<a name="ln402">        document-&gt;AddMember(json_key,</a>
<a name="ln403">                            rapidjson::Value(rapidjson::Type::kNullType),</a>
<a name="ln404">                            document-&gt;GetAllocator());</a>
<a name="ln405">        break;</a>
<a name="ln406">      }</a>
<a name="ln407">      case kJEIsObject: {</a>
<a name="ln408">        rapidjson::Document nested_container(&amp;document-&gt;GetAllocator());</a>
<a name="ln409">        nested_container.SetObject();</a>
<a name="ln410">        RETURN_NOT_OK(FromJsonbInternal(json_value, &amp;nested_container));</a>
<a name="ln411">        document-&gt;AddMember(json_key,</a>
<a name="ln412">                            std::move(nested_container),</a>
<a name="ln413">                            document-&gt;GetAllocator());</a>
<a name="ln414">        break;</a>
<a name="ln415">      }</a>
<a name="ln416">      case kJEIsArray: {</a>
<a name="ln417">        rapidjson::Document nested_container(&amp;document-&gt;GetAllocator());</a>
<a name="ln418">        nested_container.SetArray();</a>
<a name="ln419">        RETURN_NOT_OK(FromJsonbInternal(json_value, &amp;nested_container));</a>
<a name="ln420">        document-&gt;AddMember(json_key,</a>
<a name="ln421">                            std::move(nested_container),</a>
<a name="ln422">                            document-&gt;GetAllocator());</a>
<a name="ln423">        break;</a>
<a name="ln424">      }</a>
<a name="ln425">    }</a>
<a name="ln426">  }</a>
<a name="ln427">  return Status::OK();</a>
<a name="ln428">}</a>
<a name="ln429"> </a>
<a name="ln430">Status Jsonb::GetObjectValue(size_t index, const Slice&amp; jsonb, size_t metadata_begin_offset,</a>
<a name="ln431">                             size_t data_begin_offset, size_t num_kv_pairs, Slice *result,</a>
<a name="ln432">                             JEntry* value_metadata) {</a>
<a name="ln433">  // Compute the value index.</a>
<a name="ln434">  size_t key_index = metadata_begin_offset + (index * sizeof(JEntry));</a>
<a name="ln435">  size_t value_index = key_index + num_kv_pairs * sizeof(JEntry);</a>
<a name="ln436">  if (value_index &gt;= jsonb.size()) {</a>
<a name="ln437">    return STATUS(Corruption, &quot;value index in jsonb out of bounds&quot;);</a>
<a name="ln438">  }</a>
<a name="ln439"> </a>
<a name="ln440">  // Read the value metadata.</a>
<a name="ln441">  *value_metadata = BigEndian::Load32(jsonb.data() + value_index);</a>
<a name="ln442"> </a>
<a name="ln443">  // Read the value.</a>
<a name="ln444">  size_t value_end_offset = GetOffset(*value_metadata);</a>
<a name="ln445"> </a>
<a name="ln446">  // Process the value.</a>
<a name="ln447">  size_t value_offset;</a>
<a name="ln448">  size_t value_length;</a>
<a name="ln449">  std::tie(value_offset, value_length) = GetOffsetAndLength(value_index, jsonb, value_end_offset,</a>
<a name="ln450">                                                            data_begin_offset,</a>
<a name="ln451">                                                            metadata_begin_offset);</a>
<a name="ln452">  if (value_offset + value_length &gt; jsonb.size()) {</a>
<a name="ln453">    return STATUS(Corruption, &quot;json value data out of bounds in serialized jsonb&quot;);</a>
<a name="ln454">  }</a>
<a name="ln455"> </a>
<a name="ln456">  *result = Slice(jsonb.data() + value_offset, value_length);</a>
<a name="ln457">  return Status::OK();</a>
<a name="ln458">}</a>
<a name="ln459"> </a>
<a name="ln460">Status Jsonb::GetObjectKey(size_t index, const Slice&amp; jsonb, size_t metadata_begin_offset,</a>
<a name="ln461">                           size_t data_begin_offset, Slice *result) {</a>
<a name="ln462">  // Compute the key index.</a>
<a name="ln463">  size_t key_index = metadata_begin_offset + (index * sizeof(JEntry));</a>
<a name="ln464">  if (key_index &gt;= data_begin_offset) {</a>
<a name="ln465">    return STATUS(Corruption, &quot;key index in jsonb out of bounds&quot;);</a>
<a name="ln466">  }</a>
<a name="ln467"> </a>
<a name="ln468">  // Read the key metadata.</a>
<a name="ln469">  JEntry key_metadata = BigEndian::Load32(jsonb.data() + key_index);</a>
<a name="ln470"> </a>
<a name="ln471">  // Read the key.</a>
<a name="ln472">  size_t key_end_offset = GetOffset(key_metadata);</a>
<a name="ln473"> </a>
<a name="ln474">  // Process the key.</a>
<a name="ln475">  size_t key_offset;</a>
<a name="ln476">  size_t key_length;</a>
<a name="ln477">  std::tie(key_offset, key_length) = GetOffsetAndLength(key_index, jsonb, key_end_offset,</a>
<a name="ln478">                                                        data_begin_offset, metadata_begin_offset);</a>
<a name="ln479">  if (key_offset + key_length &gt; jsonb.size()) {</a>
<a name="ln480">    return STATUS(Corruption, &quot;json key data out of bounds in serialized jsonb&quot;);</a>
<a name="ln481">  }</a>
<a name="ln482"> </a>
<a name="ln483">  *result = Slice(jsonb.data() + key_offset, key_length);</a>
<a name="ln484">  return Status::OK();</a>
<a name="ln485">}</a>
<a name="ln486"> </a>
<a name="ln487">Status Jsonb::GetArrayElement(size_t index, const Slice&amp; jsonb,</a>
<a name="ln488">                              size_t metadata_begin_offset, size_t data_begin_offset,</a>
<a name="ln489">                              Slice* result, JEntry* element_metadata) {</a>
<a name="ln490">  size_t value_index = metadata_begin_offset + (index * sizeof(JEntry));</a>
<a name="ln491">  if (value_index &gt;= jsonb.size()) {</a>
<a name="ln492">    return STATUS(Corruption, &quot;value index out of bounds&quot;);</a>
<a name="ln493">  }</a>
<a name="ln494"> </a>
<a name="ln495">  // Read the metadata.</a>
<a name="ln496">  *element_metadata = BigEndian::Load32(jsonb.data() + value_index);</a>
<a name="ln497">  size_t value_end_offset = GetOffset(*element_metadata);</a>
<a name="ln498"> </a>
<a name="ln499">  // Process the value.</a>
<a name="ln500">  size_t value_offset;</a>
<a name="ln501">  size_t value_length;</a>
<a name="ln502">  std::tie(value_offset, value_length) = GetOffsetAndLength(value_index, jsonb, value_end_offset,</a>
<a name="ln503">                                                            data_begin_offset,</a>
<a name="ln504">                                                            metadata_begin_offset);</a>
<a name="ln505"> </a>
<a name="ln506">  if (value_offset + value_length &gt; jsonb.size()) {</a>
<a name="ln507">    return STATUS(Corruption, &quot;json value out of bounds of serialized jsonb&quot;);</a>
<a name="ln508">  }</a>
<a name="ln509">  *result = Slice(jsonb.data() + value_offset, value_length);</a>
<a name="ln510">  return Status::OK();</a>
<a name="ln511">}</a>
<a name="ln512"> </a>
<a name="ln513">Status Jsonb::FromJsonbProcessArray(const Slice&amp; jsonb,</a>
<a name="ln514">                                    const JsonbHeader&amp; jsonb_header,</a>
<a name="ln515">                                    rapidjson::Document* document) {</a>
<a name="ln516"> </a>
<a name="ln517">  size_t metadata_begin_offset = sizeof(JsonbHeader);</a>
<a name="ln518">  size_t nelems = GetCount(jsonb_header);</a>
<a name="ln519">  size_t data_begin_offset = ComputeDataOffset(nelems, kJBArray);</a>
<a name="ln520"> </a>
<a name="ln521">  // Now read the array members.</a>
<a name="ln522">  document-&gt;SetArray();</a>
<a name="ln523">  for (int i = 0; i &lt; nelems; i++) {</a>
<a name="ln524">    Slice result;</a>
<a name="ln525">    JEntry element_metadata;</a>
<a name="ln526">    RETURN_NOT_OK(GetArrayElement(i, jsonb, metadata_begin_offset, data_begin_offset, &amp;result,</a>
<a name="ln527">                                  &amp;element_metadata));</a>
<a name="ln528">    switch (GetJEType(element_metadata)) {</a>
<a name="ln529">      case kJEIsString: {</a>
<a name="ln530">        document-&gt;PushBack(rapidjson::Value(result.cdata(), result.size(),</a>
<a name="ln531">                                            document-&gt;GetAllocator()),</a>
<a name="ln532">                           document-&gt;GetAllocator());</a>
<a name="ln533">        break;</a>
<a name="ln534">      }</a>
<a name="ln535">      case kJEIsInt: {</a>
<a name="ln536">        int32_t value = util::DecodeInt32FromKey(result);</a>
<a name="ln537">        PushBackNumericMember(document, value);</a>
<a name="ln538">        break;</a>
<a name="ln539">      }</a>
<a name="ln540">      case kJEIsUInt: {</a>
<a name="ln541">        uint32_t value = BigEndian::Load32(result.data());</a>
<a name="ln542">        PushBackNumericMember(document, value);</a>
<a name="ln543">        break;</a>
<a name="ln544">      }</a>
<a name="ln545">      case kJEIsInt64: {</a>
<a name="ln546">        int64_t value = util::DecodeInt64FromKey(result);</a>
<a name="ln547">        PushBackNumericMember(document, value);</a>
<a name="ln548">        break;</a>
<a name="ln549">      }</a>
<a name="ln550">      case kJEIsUInt64: {</a>
<a name="ln551">        uint64_t value = BigEndian::Load64(result.data());</a>
<a name="ln552">        PushBackNumericMember(document, value);</a>
<a name="ln553">        break;</a>
<a name="ln554">      }</a>
<a name="ln555">      case kJEIsDouble: {</a>
<a name="ln556">        double value = util::DecodeDoubleFromKey(result);</a>
<a name="ln557">        PushBackNumericMember(document, value);</a>
<a name="ln558">        break;</a>
<a name="ln559">      }</a>
<a name="ln560">      case kJEIsFloat: {</a>
<a name="ln561">        float value = util::DecodeFloatFromKey(result);</a>
<a name="ln562">        PushBackNumericMember(document, value);</a>
<a name="ln563">        break;</a>
<a name="ln564">      }</a>
<a name="ln565">      case kJEIsBoolFalse: {</a>
<a name="ln566">        document-&gt;PushBack(rapidjson::Value(false), document-&gt;GetAllocator());</a>
<a name="ln567">        break;</a>
<a name="ln568">      }</a>
<a name="ln569">      case kJEIsBoolTrue: {</a>
<a name="ln570">        document-&gt;PushBack(rapidjson::Value(true), document-&gt;GetAllocator());</a>
<a name="ln571">        break;</a>
<a name="ln572">      }</a>
<a name="ln573">      case kJEIsNull: {</a>
<a name="ln574">        document-&gt;PushBack(rapidjson::Value(rapidjson::Type::kNullType), document-&gt;GetAllocator());</a>
<a name="ln575">        break;</a>
<a name="ln576">      }</a>
<a name="ln577">      case kJEIsObject: {</a>
<a name="ln578">        rapidjson::Document nested_container(&amp;document-&gt;GetAllocator());</a>
<a name="ln579">        nested_container.SetObject();</a>
<a name="ln580">        RETURN_NOT_OK(FromJsonbInternal(result, &amp;nested_container));</a>
<a name="ln581">        document-&gt;PushBack(std::move(nested_container),</a>
<a name="ln582">                           document-&gt;GetAllocator());</a>
<a name="ln583">        break;</a>
<a name="ln584">      }</a>
<a name="ln585">      case kJEIsArray: {</a>
<a name="ln586">        rapidjson::Document nested_container(&amp;document-&gt;GetAllocator());</a>
<a name="ln587">        nested_container.SetArray();</a>
<a name="ln588">        RETURN_NOT_OK(FromJsonbInternal(result, &amp;nested_container));</a>
<a name="ln589">        document-&gt;PushBack(std::move(nested_container),</a>
<a name="ln590">                           document-&gt;GetAllocator());</a>
<a name="ln591">        break;</a>
<a name="ln592">      }</a>
<a name="ln593">    }</a>
<a name="ln594">  }</a>
<a name="ln595">  return Status::OK();</a>
<a name="ln596">}</a>
<a name="ln597"> </a>
<a name="ln598">Status Jsonb::FromJsonbInternal(const Slice&amp; jsonb, rapidjson::Document* document) {</a>
<a name="ln599">  // Read the jsonb header.</a>
<a name="ln600">  JsonbHeader jsonb_header = BigEndian::Load32(jsonb.data());</a>
<a name="ln601"> </a>
<a name="ln602">  if ((jsonb_header &amp; kJBObject) == kJBObject) {</a>
<a name="ln603">    return FromJsonbProcessObject(jsonb, jsonb_header, document);</a>
<a name="ln604">  } else if ((jsonb_header &amp; kJBArray) == kJBArray) {</a>
<a name="ln605">    rapidjson::Document array_doc;</a>
<a name="ln606">    RETURN_NOT_OK(FromJsonbProcessArray(jsonb, jsonb_header, &amp;array_doc));</a>
<a name="ln607"> </a>
<a name="ln608">    if ((jsonb_header &amp; kJBScalar) &amp;&amp; array_doc.GetArray().Size() == 1) {</a>
<a name="ln609">      // This is actually a scalar, since jsonb stores scalars as arrays with one element.</a>
<a name="ln610">      // Therefore, just return the single element.</a>
<a name="ln611">      document-&gt;CopyFrom(array_doc.GetArray()[0], document-&gt;GetAllocator());</a>
<a name="ln612">    } else {</a>
<a name="ln613">      document-&gt;CopyFrom(array_doc, document-&gt;GetAllocator());</a>
<a name="ln614">    }</a>
<a name="ln615">  } else {</a>
<a name="ln616">    return STATUS(InvalidArgument, &quot;Invalid json type!&quot;);</a>
<a name="ln617">  }</a>
<a name="ln618">  return Status::OK();</a>
<a name="ln619">}</a>
<a name="ln620"> </a>
<a name="ln621">pair&lt;size_t, size_t&gt; Jsonb::GetOffsetAndLength(size_t element_metadata_offset,</a>
<a name="ln622">                                               const Slice&amp; jsonb,</a>
<a name="ln623">                                               size_t element_end_offset,</a>
<a name="ln624">                                               size_t data_begin_offset,</a>
<a name="ln625">                                               size_t metadata_begin_offset) {</a>
<a name="ln626">  if (element_metadata_offset == metadata_begin_offset) {</a>
<a name="ln627">    // This is the first element.</a>
<a name="ln628">    return std::make_pair(data_begin_offset, element_end_offset);</a>
<a name="ln629">  }</a>
<a name="ln630"> </a>
<a name="ln631">  DCHECK_GE(element_metadata_offset, sizeof(JsonbHeader));</a>
<a name="ln632">  JEntry prev_element =</a>
<a name="ln633">      BigEndian::Load32(jsonb.data() + element_metadata_offset - sizeof(JEntry));</a>
<a name="ln634">  size_t prev_element_offset = GetOffset(prev_element);</a>
<a name="ln635">  return std::make_pair(prev_element_offset + data_begin_offset,</a>
<a name="ln636">                        element_end_offset - prev_element_offset);</a>
<a name="ln637"> </a>
<a name="ln638">}</a>
<a name="ln639"> </a>
<a name="ln640">Status Jsonb::ToRapidJson(rapidjson::Document* document) const {</a>
<a name="ln641">  return FromJsonbInternal(serialized_jsonb_, document);</a>
<a name="ln642">}</a>
<a name="ln643"> </a>
<a name="ln644">Status Jsonb::ToJsonString(std::string* json) const {</a>
<a name="ln645">  return ToJsonStringInternal(serialized_jsonb_, json);</a>
<a name="ln646">}</a>
<a name="ln647"> </a>
<a name="ln648">Status Jsonb::ToJsonStringInternal(const Slice&amp; jsonb, std::string* json) {</a>
<a name="ln649">  rapidjson::Document document;</a>
<a name="ln650">  RETURN_NOT_OK(FromJsonbInternal(jsonb, &amp;document));</a>
<a name="ln651">  *DCHECK_NOTNULL(json) = WriteRapidJsonToString(document);</a>
<a name="ln652">  return Status::OK();</a>
<a name="ln653">}</a>
<a name="ln654"> </a>
<a name="ln655">Status Jsonb::ApplyJsonbOperatorToArray(const Slice&amp; jsonb, const QLJsonOperationPB&amp; json_op,</a>
<a name="ln656">                                        const JsonbHeader&amp; jsonb_header,</a>
<a name="ln657">                                        Slice* result, JEntry* element_metadata) {</a>
<a name="ln658">  if(!json_op.operand().value().has_varint_value()) {</a>
<a name="ln659">    return STATUS_SUBSTITUTE(NotFound, &quot;Couldn't apply json operator&quot;);</a>
<a name="ln660">  }</a>
<a name="ln661"> </a>
<a name="ln662">  // For arrays, the argument needs to be an integer.</a>
<a name="ln663">  size_t num_array_entries = GetCount(jsonb_header);</a>
<a name="ln664"> </a>
<a name="ln665">  // Retrieve the array index and verify.</a>
<a name="ln666">  util::VarInt varint;</a>
<a name="ln667">  RETURN_NOT_OK(varint.DecodeFromComparable(json_op.operand().value().varint_value()));</a>
<a name="ln668">  int64_t array_index = VERIFY_RESULT(varint.ToInt64());</a>
<a name="ln669"> </a>
<a name="ln670">  if (array_index &lt; 0 || array_index &gt;= num_array_entries) {</a>
<a name="ln671">    return STATUS_SUBSTITUTE(NotFound, &quot;Array index: $0 out of bounds [0, $1)&quot;,</a>
<a name="ln672">                             array_index, num_array_entries);</a>
<a name="ln673">  }</a>
<a name="ln674"> </a>
<a name="ln675">  RETURN_NOT_OK(GetArrayElement(array_index, jsonb, sizeof(jsonb_header),</a>
<a name="ln676">                                ComputeDataOffset(num_array_entries, kJBArray), result,</a>
<a name="ln677">                                element_metadata));</a>
<a name="ln678">  return Status::OK();</a>
<a name="ln679">}</a>
<a name="ln680"> </a>
<a name="ln681">Status Jsonb::ApplyJsonbOperatorToObject(const Slice&amp; jsonb, const QLJsonOperationPB&amp; json_op,</a>
<a name="ln682">                                         const JsonbHeader&amp; jsonb_header,</a>
<a name="ln683">                                         Slice* result, JEntry* element_metadata) {</a>
<a name="ln684">  if (!json_op.operand().value().has_string_value()) {</a>
<a name="ln685">    return STATUS_SUBSTITUTE(NotFound, &quot;Couldn't apply json operator&quot;);</a>
<a name="ln686">  }</a>
<a name="ln687"> </a>
<a name="ln688">  size_t num_kv_pairs = GetCount(jsonb_header);</a>
<a name="ln689">  const string&amp; search_key = json_op.operand().value().string_value();</a>
<a name="ln690"> </a>
<a name="ln691">  size_t metadata_begin_offset = sizeof(jsonb_header);</a>
<a name="ln692">  size_t data_begin_offset = ComputeDataOffset(num_kv_pairs, kJBObject);</a>
<a name="ln693"> </a>
<a name="ln694">  // Binary search to find the key.</a>
<a name="ln695">  int64_t low = 0, high = num_kv_pairs - 1;</a>
<a name="ln696">  auto search_key_slice = Slice(search_key);</a>
<a name="ln697">  while (low &lt;= high) {</a>
<a name="ln698">    size_t mid = low + (high - low)/2;</a>
<a name="ln699">    Slice mid_key;</a>
<a name="ln700">    RETURN_NOT_OK(GetObjectKey(mid, jsonb, metadata_begin_offset, data_begin_offset, &amp;mid_key));</a>
<a name="ln701"> </a>
<a name="ln702">    if (mid_key == search_key_slice) {</a>
<a name="ln703">      RETURN_NOT_OK(GetObjectValue(mid, jsonb, sizeof(jsonb_header),</a>
<a name="ln704">                                   ComputeDataOffset(num_kv_pairs, kJBObject), num_kv_pairs,</a>
<a name="ln705">                                   result, element_metadata));</a>
<a name="ln706">      return Status::OK();</a>
<a name="ln707">    } else if (mid_key.ToBuffer() &gt; search_key) {</a>
<a name="ln708">      high = mid - 1;</a>
<a name="ln709">    } else {</a>
<a name="ln710">      low = mid + 1;</a>
<a name="ln711">    }</a>
<a name="ln712">  }</a>
<a name="ln713">  return STATUS_SUBSTITUTE(NotFound, &quot;Couldn't find key $0 in json document&quot;, search_key);</a>
<a name="ln714">}</a>
<a name="ln715"> </a>
<a name="ln716">Status Jsonb::ApplyJsonbOperators(const QLJsonColumnOperationsPB&amp; json_ops, QLValue* result) const {</a>
<a name="ln717">  const int num_ops = json_ops.json_operations().size();</a>
<a name="ln718"> </a>
<a name="ln719">  Slice jsonop_result;</a>
<a name="ln720">  Slice operand(serialized_jsonb_);</a>
<a name="ln721">  JEntry element_metadata;</a>
<a name="ln722">  for (int i = 0; i &lt; num_ops; i++) {</a>
<a name="ln723">    const QLJsonOperationPB &amp;op = json_ops.json_operations().Get(i);</a>
<a name="ln724">    const Status s = ApplyJsonbOperator(operand, op, &amp;jsonop_result,</a>
<a name="ln725">                                        &amp;element_metadata);</a>
<a name="ln726">    if (s.IsNotFound()) {</a>
<a name="ln727">      // We couldn't apply the operator to the operand and hence return null as the result.</a>
<a name="ln728">      result-&gt;SetNull();</a>
<a name="ln729">      return Status::OK();</a>
<a name="ln730">    }</a>
<a name="ln731">    RETURN_NOT_OK(s);</a>
<a name="ln732"> </a>
<a name="ln733">    if (IsScalar(element_metadata) &amp;&amp; i != num_ops - 1) {</a>
<a name="ln734">      // We have to apply another operation after this, but we received a scalar intermediate</a>
<a name="ln735">      // result.</a>
<a name="ln736">      result-&gt;SetNull();</a>
<a name="ln737">      return Status::OK();</a>
<a name="ln738">    }</a>
<a name="ln739">    operand = jsonop_result;</a>
<a name="ln740">  }</a>
<a name="ln741"> </a>
<a name="ln742">  // In case of '-&gt;&gt;', we need to return a string result.</a>
<a name="ln743">  if (num_ops &gt; 0 &amp;&amp;</a>
<a name="ln744">      json_ops.json_operations().Get(num_ops - 1).json_operator() == JsonOperatorPB::JSON_TEXT) {</a>
<a name="ln745">    if (IsScalar(element_metadata)) {</a>
<a name="ln746">      RETURN_NOT_OK(ScalarToString(element_metadata, jsonop_result,</a>
<a name="ln747">                                   result-&gt;mutable_string_value()));</a>
<a name="ln748">    } else {</a>
<a name="ln749">      string str_result;</a>
<a name="ln750">      RETURN_NOT_OK(ToJsonStringInternal(jsonop_result, &amp;str_result));</a>
<a name="ln751">      result-&gt;set_string_value(std::move(str_result));</a>
<a name="ln752">    }</a>
<a name="ln753">    return Status::OK();</a>
<a name="ln754">  }</a>
<a name="ln755"> </a>
<a name="ln756">  string jsonb_result = jsonop_result.ToBuffer();</a>
<a name="ln757">  if (IsScalar(element_metadata)) {</a>
<a name="ln758">    // In case of a scalar that is received from an operation, convert it to a jsonb scalar.</a>
<a name="ln759">    RETURN_NOT_OK(CreateScalar(jsonop_result,</a>
<a name="ln760">                               element_metadata,</a>
<a name="ln761">                               &amp;jsonb_result));</a>
<a name="ln762">  }</a>
<a name="ln763">  result-&gt;set_jsonb_value(std::move(jsonb_result));</a>
<a name="ln764">  return Status::OK();</a>
<a name="ln765">}</a>
<a name="ln766"> </a>
<a name="ln767">Status Jsonb::ApplyJsonbOperator(const Slice&amp; jsonb, const QLJsonOperationPB&amp; json_op,</a>
<a name="ln768">                                 Slice* result, JEntry* element_metadata) {</a>
<a name="ln769">  // Currently, both these operators are considered the same since we only handle strings.</a>
<a name="ln770">  DCHECK(json_op.json_operator() == JsonOperatorPB::JSON_OBJECT ||</a>
<a name="ln771">         json_op.json_operator() == JsonOperatorPB::JSON_TEXT);</a>
<a name="ln772"> </a>
<a name="ln773">  // We only support strings and integers as the argument to the json operation currently.</a>
<a name="ln774">  DCHECK(json_op.operand().has_value());</a>
<a name="ln775"> </a>
<a name="ln776">  if (jsonb.size() &lt; sizeof(JsonbHeader)) {</a>
<a name="ln777">    return STATUS(InvalidArgument, &quot;Not enough data to process&quot;);</a>
<a name="ln778">  }</a>
<a name="ln779"> </a>
<a name="ln780">  JsonbHeader jsonb_header = BigEndian::Load32(jsonb.data());</a>
<a name="ln781">  if ((jsonb_header &amp; kJBScalar) &amp;&amp; (jsonb_header &amp; kJBArray)) {</a>
<a name="ln782">    // This is a scalar value and no operators can be applied to it.</a>
<a name="ln783">    return STATUS(NotFound, &quot;Cannot apply operators to scalar values&quot;);</a>
<a name="ln784">  } else if (jsonb_header &amp; kJBArray) {</a>
<a name="ln785">    return ApplyJsonbOperatorToArray(jsonb, json_op, jsonb_header, result, element_metadata);</a>
<a name="ln786">  } else if (jsonb_header &amp; kJBObject) {</a>
<a name="ln787">    return ApplyJsonbOperatorToObject(jsonb, json_op, jsonb_header, result, element_metadata);</a>
<a name="ln788">  }</a>
<a name="ln789"> </a>
<a name="ln790">  return STATUS(InvalidArgument, &quot;Invalid json operation&quot;);</a>
<a name="ln791">}</a>
<a name="ln792"> </a>
<a name="ln793">Status Jsonb::CreateScalar(const Slice&amp; scalar, const JEntry&amp; original_jentry,</a>
<a name="ln794">                           std::string* scalar_jsonb) {</a>
<a name="ln795">  // Build the header.</a>
<a name="ln796">  size_t metadata_begin_offset = sizeof(JsonbHeader);</a>
<a name="ln797">  size_t metadata_size = metadata_begin_offset + sizeof(JEntry);</a>
<a name="ln798">  size_t data_begin_offset = metadata_size;</a>
<a name="ln799"> </a>
<a name="ln800">  // Resize the result.</a>
<a name="ln801">  scalar_jsonb-&gt;resize(metadata_size);</a>
<a name="ln802">  scalar_jsonb-&gt;append(scalar.cdata(), scalar.size());</a>
<a name="ln803"> </a>
<a name="ln804">  JsonbHeader jsonb_header = (1 &amp; kJBCountMask) | kJBArray | kJBScalar;</a>
<a name="ln805">  JEntry jentry = (GetOffset(scalar_jsonb-&gt;size() - data_begin_offset)) |</a>
<a name="ln806">      GetJEType(original_jentry);</a>
<a name="ln807"> </a>
<a name="ln808">  // Store the header.</a>
<a name="ln809">  BigEndian::Store32(&amp;((*scalar_jsonb)[0]), jsonb_header);</a>
<a name="ln810">  // Store the JEntry.</a>
<a name="ln811">  BigEndian::Store32(&amp;((*scalar_jsonb)[metadata_begin_offset]), jentry);</a>
<a name="ln812">  return Status::OK();</a>
<a name="ln813">}</a>
<a name="ln814"> </a>
<a name="ln815">} // namespace common</a>
<a name="ln816">} // namespace yb</a>

</code></pre>
<div class="balloon" rel="115"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="215"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="770"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="774"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
