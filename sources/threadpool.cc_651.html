
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>threadpool.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Licensed to the Apache Software Foundation (ASF) under one</a>
<a name="ln2">// or more contributor license agreements.  See the NOTICE file</a>
<a name="ln3">// distributed with this work for additional information</a>
<a name="ln4">// regarding copyright ownership.  The ASF licenses this file</a>
<a name="ln5">// to you under the Apache License, Version 2.0 (the</a>
<a name="ln6">// &quot;License&quot;); you may not use this file except in compliance</a>
<a name="ln7">// with the License.  You may obtain a copy of the License at</a>
<a name="ln8">//</a>
<a name="ln9">//   http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln10">//</a>
<a name="ln11">// Unless required by applicable law or agreed to in writing,</a>
<a name="ln12">// software distributed under the License is distributed on an</a>
<a name="ln13">// &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</a>
<a name="ln14">// KIND, either express or implied.  See the License for the</a>
<a name="ln15">// specific language governing permissions and limitations</a>
<a name="ln16">// under the License.</a>
<a name="ln17">//</a>
<a name="ln18">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln19">//</a>
<a name="ln20">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln21">//</a>
<a name="ln22">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln23">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln24">//</a>
<a name="ln25">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln26">//</a>
<a name="ln27">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln28">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln29">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln30">// under the License.</a>
<a name="ln31">//</a>
<a name="ln32"> </a>
<a name="ln33">#include &lt;algorithm&gt;</a>
<a name="ln34">#include &lt;functional&gt;</a>
<a name="ln35">#include &lt;iostream&gt;</a>
<a name="ln36">#include &lt;limits&gt;</a>
<a name="ln37">#include &lt;memory&gt;</a>
<a name="ln38"> </a>
<a name="ln39">#include &lt;gflags/gflags.h&gt;</a>
<a name="ln40">#include &lt;glog/logging.h&gt;</a>
<a name="ln41"> </a>
<a name="ln42">#include &quot;yb/gutil/callback.h&quot;</a>
<a name="ln43">#include &quot;yb/gutil/macros.h&quot;</a>
<a name="ln44">#include &quot;yb/gutil/map-util.h&quot;</a>
<a name="ln45">#include &quot;yb/gutil/stl_util.h&quot;</a>
<a name="ln46">#include &quot;yb/gutil/strings/substitute.h&quot;</a>
<a name="ln47">#include &quot;yb/gutil/sysinfo.h&quot;</a>
<a name="ln48">#include &quot;yb/util/errno.h&quot;</a>
<a name="ln49">#include &quot;yb/util/metrics.h&quot;</a>
<a name="ln50">#include &quot;yb/util/stopwatch.h&quot;</a>
<a name="ln51">#include &quot;yb/util/thread.h&quot;</a>
<a name="ln52">#include &quot;yb/util/threadpool.h&quot;</a>
<a name="ln53">#include &quot;yb/util/trace.h&quot;</a>
<a name="ln54"> </a>
<a name="ln55">namespace yb {</a>
<a name="ln56"> </a>
<a name="ln57">using strings::Substitute;</a>
<a name="ln58">using std::unique_ptr;</a>
<a name="ln59"> </a>
<a name="ln60">////////////////////////////////////////////////////////</a>
<a name="ln61">// ThreadPoolBuilder</a>
<a name="ln62">///////////////////////////////////////////////////////</a>
<a name="ln63"> </a>
<a name="ln64">ThreadPoolBuilder::ThreadPoolBuilder(std::string name)</a>
<a name="ln65">    : name_(std::move(name)),</a>
<a name="ln66">      min_threads_(0),</a>
<a name="ln67">      max_threads_(base::NumCPUs()),</a>
<a name="ln68">      max_queue_size_(std::numeric_limits&lt;int&gt;::max()),</a>
<a name="ln69">      idle_timeout_(MonoDelta::FromMilliseconds(500)) {}</a>
<a name="ln70"> </a>
<a name="ln71">ThreadPoolBuilder&amp; ThreadPoolBuilder::set_min_threads(int min_threads) {</a>
<a name="ln72">  CHECK_GE(min_threads, 0);</a>
<a name="ln73">  min_threads_ = min_threads;</a>
<a name="ln74">  return *this;</a>
<a name="ln75">}</a>
<a name="ln76"> </a>
<a name="ln77">ThreadPoolBuilder&amp; ThreadPoolBuilder::set_max_threads(int max_threads) {</a>
<a name="ln78">  CHECK_GE(max_threads, 0);</a>
<a name="ln79">  max_threads_ = max_threads;</a>
<a name="ln80">  return *this;</a>
<a name="ln81">}</a>
<a name="ln82"> </a>
<a name="ln83">ThreadPoolBuilder&amp; ThreadPoolBuilder::unlimited_threads() {</a>
<a name="ln84">  max_threads_ = std::numeric_limits&lt;int&gt;::max();</a>
<a name="ln85">  return *this;</a>
<a name="ln86">}</a>
<a name="ln87"> </a>
<a name="ln88">ThreadPoolBuilder&amp; ThreadPoolBuilder::set_max_queue_size(int max_queue_size) {</a>
<a name="ln89">  CHECK_GE(max_queue_size, 0);</a>
<a name="ln90">  max_queue_size_ = max_queue_size;</a>
<a name="ln91">  return *this;</a>
<a name="ln92">}</a>
<a name="ln93"> </a>
<a name="ln94">ThreadPoolBuilder&amp; ThreadPoolBuilder::set_metrics(ThreadPoolMetrics metrics) {</a>
<a name="ln95">  metrics_ = std::move(metrics);</a>
<a name="ln96">  return *this;</a>
<a name="ln97">}</a>
<a name="ln98"> </a>
<a name="ln99">ThreadPoolBuilder&amp; ThreadPoolBuilder::set_idle_timeout(const MonoDelta&amp; idle_timeout) {</a>
<a name="ln100">  idle_timeout_ = idle_timeout;</a>
<a name="ln101">  return *this;</a>
<a name="ln102">}</a>
<a name="ln103"> </a>
<a name="ln104">Status ThreadPoolBuilder::Build(gscoped_ptr&lt;ThreadPool&gt;* pool) const {</a>
<a name="ln105">  pool-&gt;reset(new ThreadPool(*this));</a>
<a name="ln106">  RETURN_NOT_OK((*pool)-&gt;Init());</a>
<a name="ln107">  return Status::OK();</a>
<a name="ln108">}</a>
<a name="ln109"> </a>
<a name="ln110">Status ThreadPoolBuilder::Build(unique_ptr&lt;ThreadPool&gt;* pool) const {</a>
<a name="ln111">  pool-&gt;reset(new ThreadPool(*this));</a>
<a name="ln112">  RETURN_NOT_OK((*pool)-&gt;Init());</a>
<a name="ln113">  return Status::OK();</a>
<a name="ln114">}</a>
<a name="ln115"> </a>
<a name="ln116">////////////////////////////////////////////////////////</a>
<a name="ln117">// ThreadPoolToken</a>
<a name="ln118">////////////////////////////////////////////////////////</a>
<a name="ln119"> </a>
<a name="ln120">ThreadPoolToken::ThreadPoolToken(ThreadPool* pool,</a>
<a name="ln121">                                 ThreadPool::ExecutionMode mode,</a>
<a name="ln122">                                 ThreadPoolMetrics metrics)</a>
<a name="ln123">    : mode_(mode),</a>
<a name="ln124">      pool_(pool),</a>
<a name="ln125">      metrics_(std::move(metrics)),</a>
<a name="ln126">      state_(ThreadPoolTokenState::kIdle),</a>
<a name="ln127">      not_running_cond_(&amp;pool-&gt;lock_),</a>
<a name="ln128">      active_threads_(0) {</a>
<a name="ln129">}</a>
<a name="ln130"> </a>
<a name="ln131">ThreadPoolToken::~ThreadPoolToken() {</a>
<a name="ln132">  Shutdown();</a>
<a name="ln133">  pool_-&gt;ReleaseToken(this);</a>
<a name="ln134">}</a>
<a name="ln135"> </a>
<a name="ln136">Status ThreadPoolToken::SubmitClosure(Closure c) {</a>
<a name="ln137">  return Submit(std::make_shared&lt;FunctionRunnable&gt;((std::bind(&amp;Closure::Run, c))));</a>
<a name="ln138">}</a>
<a name="ln139"> </a>
<a name="ln140">Status ThreadPoolToken::SubmitFunc(std::function&lt;void()&gt; f) {</a>
<a name="ln141">  return Submit(std::make_shared&lt;FunctionRunnable&gt;(std::move(f)));</a>
<a name="ln142">}</a>
<a name="ln143"> </a>
<a name="ln144">Status ThreadPoolToken::Submit(std::shared_ptr&lt;Runnable&gt; r) {</a>
<a name="ln145">  return pool_-&gt;DoSubmit(std::move(r), this);</a>
<a name="ln146">}</a>
<a name="ln147"> </a>
<a name="ln148">void ThreadPoolToken::Shutdown() {</a>
<a name="ln149">  MutexLock unique_lock(pool_-&gt;lock_);</a>
<a name="ln150">  pool_-&gt;CheckNotPoolThreadUnlocked();</a>
<a name="ln151"> </a>
<a name="ln152">  // Clear the queue under the lock, but defer the releasing of the tasks</a>
<a name="ln153">  // outside the lock, in case there are concurrent threads wanting to access</a>
<a name="ln154">  // the ThreadPool. The task's destructors may acquire locks, etc, so this</a>
<a name="ln155">  // also prevents lock inversions.</a>
<a name="ln156">  deque&lt;ThreadPool::Task&gt; to_release = std::move(entries_);</a>
<a name="ln157">  pool_-&gt;total_queued_tasks_ -= to_release.size();</a>
<a name="ln158"> </a>
<a name="ln159">  switch (state()) {</a>
<a name="ln160">    case ThreadPoolTokenState::kIdle:</a>
<a name="ln161">      // There were no tasks outstanding; we can quiesce the token immediately.</a>
<a name="ln162">      Transition(ThreadPoolTokenState::kQuiesced);</a>
<a name="ln163">      break;</a>
<a name="ln164">    case ThreadPoolTokenState::kRunning:</a>
<a name="ln165">      // There were outstanding tasks. If any are still running, switch to</a>
<a name="ln166">      // kQuiescing and wait for them to finish (the worker thread executing</a>
<a name="ln167">      // the token's last task will switch the token to kQuiesced). Otherwise,</a>
<a name="ln168">      // we can quiesce the token immediately.</a>
<a name="ln169"> </a>
<a name="ln170">      // Note: this is an O(n) operation, but it's expected to be infrequent.</a>
<a name="ln171">      // Plus doing it this way (rather than switching to kQuiescing and waiting</a>
<a name="ln172">      // for a worker thread to process the queue entry) helps retain state</a>
<a name="ln173">      // transition symmetry with ThreadPool::Shutdown.</a>
<a name="ln174">      for (auto it = pool_-&gt;queue_.begin(); it != pool_-&gt;queue_.end();) {</a>
<a name="ln175">        if (*it == this) {</a>
<a name="ln176">          it = pool_-&gt;queue_.erase(it);</a>
<a name="ln177">        } else {</a>
<a name="ln178">          it++;</a>
<a name="ln179">        }</a>
<a name="ln180">      }</a>
<a name="ln181"> </a>
<a name="ln182">      if (active_threads_ == 0) {</a>
<a name="ln183">        Transition(ThreadPoolTokenState::kQuiesced);</a>
<a name="ln184">        break;</a>
<a name="ln185">      }</a>
<a name="ln186">      Transition(ThreadPoolTokenState::kQuiescing);</a>
<a name="ln187">      FALLTHROUGH_INTENDED;</a>
<a name="ln188">    case ThreadPoolTokenState::kQuiescing:</a>
<a name="ln189">      // The token is already quiescing. Just wait for a worker thread to</a>
<a name="ln190">      // switch it to kQuiesced.</a>
<a name="ln191">      while (state() != ThreadPoolTokenState::kQuiesced) {</a>
<a name="ln192">        not_running_cond_.Wait();</a>
<a name="ln193">      }</a>
<a name="ln194">      break;</a>
<a name="ln195">    default:</a>
<a name="ln196">      break;</a>
<a name="ln197">  }</a>
<a name="ln198"> </a>
<a name="ln199">  // Finally release the queued tasks, outside the lock.</a>
<a name="ln200">  unique_lock.Unlock();</a>
<a name="ln201">  for (auto&amp; t : to_release) {</a>
<a name="ln202">    if (t.trace) {</a>
<a name="ln203">      t.trace-&gt;Release();</a>
<a name="ln204">    }</a>
<a name="ln205">  }</a>
<a name="ln206">}</a>
<a name="ln207"> </a>
<a name="ln208">void ThreadPoolToken::Wait() {</a>
<a name="ln209">  MutexLock unique_lock(pool_-&gt;lock_);</a>
<a name="ln210">  pool_-&gt;CheckNotPoolThreadUnlocked();</a>
<a name="ln211">  while (IsActive()) {</a>
<a name="ln212">    not_running_cond_.Wait();</a>
<a name="ln213">  }</a>
<a name="ln214">}</a>
<a name="ln215"> </a>
<a name="ln216">bool ThreadPoolToken::WaitUntil(const MonoTime&amp; until) {</a>
<a name="ln217">  MutexLock unique_lock(pool_-&gt;lock_);</a>
<a name="ln218">  pool_-&gt;CheckNotPoolThreadUnlocked();</a>
<a name="ln219">  while (IsActive()) {</a>
<a name="ln220">    if (!not_running_cond_.WaitUntil(until)) {</a>
<a name="ln221">      return false;</a>
<a name="ln222">    }</a>
<a name="ln223">  }</a>
<a name="ln224">  return true;</a>
<a name="ln225">}</a>
<a name="ln226"> </a>
<a name="ln227">bool ThreadPoolToken::WaitFor(const MonoDelta&amp; delta) {</a>
<a name="ln228">  return WaitUntil(MonoTime::Now() + delta);</a>
<a name="ln229">}</a>
<a name="ln230"> </a>
<a name="ln231">void ThreadPoolToken::Transition(ThreadPoolTokenState new_state) {</a>
<a name="ln232">#ifndef NDEBUG</a>
<a name="ln233">  CHECK_NE(state_, new_state);</a>
<a name="ln234"> </a>
<a name="ln235">  switch (state_) {</a>
<a name="ln236">    case ThreadPoolTokenState::kIdle:</a>
<a name="ln237">      CHECK(new_state == ThreadPoolTokenState::kRunning ||</a>
<a name="ln238">            new_state == ThreadPoolTokenState::kQuiesced);</a>
<a name="ln239">      if (new_state == ThreadPoolTokenState::kRunning) {</a>
<a name="ln240">        CHECK(!entries_.empty());</a>
<a name="ln241">      } else {</a>
<a name="ln242">        CHECK(entries_.empty());</a>
<a name="ln243">        CHECK_EQ(active_threads_, 0);</a>
<a name="ln244">      }</a>
<a name="ln245">      break;</a>
<a name="ln246">    case ThreadPoolTokenState::kRunning:</a>
<a name="ln247">      CHECK(new_state == ThreadPoolTokenState::kIdle ||</a>
<a name="ln248">            new_state == ThreadPoolTokenState::kQuiescing ||</a>
<a name="ln249">            new_state == ThreadPoolTokenState::kQuiesced);</a>
<a name="ln250">      CHECK(entries_.empty());</a>
<a name="ln251">      if (new_state == ThreadPoolTokenState::kQuiescing) {</a>
<a name="ln252">        CHECK_GT(active_threads_, 0);</a>
<a name="ln253">      }</a>
<a name="ln254">      break;</a>
<a name="ln255">    case ThreadPoolTokenState::kQuiescing:</a>
<a name="ln256">      CHECK(new_state == ThreadPoolTokenState::kQuiesced);</a>
<a name="ln257">      CHECK_EQ(active_threads_, 0);</a>
<a name="ln258">      break;</a>
<a name="ln259">    case ThreadPoolTokenState::kQuiesced:</a>
<a name="ln260">      CHECK(false); // kQuiesced is a terminal state</a>
<a name="ln261">      break;</a>
<a name="ln262">    default:</a>
<a name="ln263">      LOG(FATAL) &lt;&lt; &quot;Unknown token state: &quot; &lt;&lt; state_;</a>
<a name="ln264">  }</a>
<a name="ln265">#endif</a>
<a name="ln266"> </a>
<a name="ln267">  // Take actions based on the state we're entering.</a>
<a name="ln268">  switch (new_state) {</a>
<a name="ln269">    case ThreadPoolTokenState::kIdle:</a>
<a name="ln270">    case ThreadPoolTokenState::kQuiesced:</a>
<a name="ln271">      not_running_cond_.Broadcast();</a>
<a name="ln272">      break;</a>
<a name="ln273">    default:</a>
<a name="ln274">      break;</a>
<a name="ln275">  }</a>
<a name="ln276"> </a>
<a name="ln277">  state_ = new_state;</a>
<a name="ln278">}</a>
<a name="ln279"> </a>
<a name="ln280">const char* ThreadPoolToken::StateToString(ThreadPoolTokenState s) {</a>
<a name="ln281">  switch (s) {</a>
<a name="ln282">    case ThreadPoolTokenState::kIdle: return &quot;kIdle&quot;; break;</a>
<a name="ln283">    case ThreadPoolTokenState::kRunning: return &quot;kRunning&quot;; break;</a>
<a name="ln284">    case ThreadPoolTokenState::kQuiescing: return &quot;kQuiescing&quot;; break;</a>
<a name="ln285">    case ThreadPoolTokenState::kQuiesced: return &quot;kQuiesced&quot;; break;</a>
<a name="ln286">  }</a>
<a name="ln287">  return &quot;&lt;cannot reach here&gt;&quot;;</a>
<a name="ln288">}</a>
<a name="ln289"> </a>
<a name="ln290">////////////////////////////////////////////////////////</a>
<a name="ln291">// ThreadPool</a>
<a name="ln292">////////////////////////////////////////////////////////</a>
<a name="ln293"> </a>
<a name="ln294">ThreadPool::ThreadPool(const ThreadPoolBuilder&amp; builder)</a>
<a name="ln295">  : name_(builder.name_),</a>
<a name="ln296">    min_threads_(builder.min_threads_),</a>
<a name="ln297">    max_threads_(builder.max_threads_),</a>
<a name="ln298">    max_queue_size_(builder.max_queue_size_),</a>
<a name="ln299">    idle_timeout_(builder.idle_timeout_),</a>
<a name="ln300">    pool_status_(STATUS(Uninitialized, &quot;The pool was not initialized.&quot;)),</a>
<a name="ln301">    idle_cond_(&amp;lock_),</a>
<a name="ln302">    no_threads_cond_(&amp;lock_),</a>
<a name="ln303">    not_empty_(&amp;lock_),</a>
<a name="ln304">    num_threads_(0),</a>
<a name="ln305">    active_threads_(0),</a>
<a name="ln306">    total_queued_tasks_(0),</a>
<a name="ln307">    tokenless_(NewToken(ExecutionMode::CONCURRENT)),</a>
<a name="ln308">    metrics_(builder.metrics_) {</a>
<a name="ln309">}</a>
<a name="ln310"> </a>
<a name="ln311">ThreadPool::~ThreadPool() {</a>
<a name="ln312">  // There should only be one live token: the one used in tokenless submission.</a>
<a name="ln313">  CHECK_EQ(1, tokens_.size()) &lt;&lt; Substitute(</a>
<a name="ln314">      &quot;Threadpool $0 destroyed with $1 allocated tokens&quot;,</a>
<a name="ln315">      name_, tokens_.size());</a>
<a name="ln316">  Shutdown();</a>
<a name="ln317">}</a>
<a name="ln318"> </a>
<a name="ln319">Status ThreadPool::Init() {</a>
<a name="ln320">  MutexLock unique_lock(lock_);</a>
<a name="ln321">  if (!pool_status_.IsUninitialized()) {</a>
<a name="ln322">    return STATUS(NotSupported, &quot;The thread pool is already initialized&quot;);</a>
<a name="ln323">  }</a>
<a name="ln324">  pool_status_ = Status::OK();</a>
<a name="ln325">  for (int i = 0; i &lt; min_threads_; i++) {</a>
<a name="ln326">    Status status = CreateThreadUnlocked();</a>
<a name="ln327">    if (!status.ok()) {</a>
<a name="ln328">      Shutdown();</a>
<a name="ln329">      return status;</a>
<a name="ln330">    }</a>
<a name="ln331">  }</a>
<a name="ln332">  return Status::OK();</a>
<a name="ln333">}</a>
<a name="ln334"> </a>
<a name="ln335">void ThreadPool::Shutdown() {</a>
<a name="ln336">  MutexLock unique_lock(lock_);</a>
<a name="ln337">  CheckNotPoolThreadUnlocked();</a>
<a name="ln338"> </a>
<a name="ln339">  // Note: this is the same error seen at submission if the pool is at</a>
<a name="ln340">  // capacity, so clients can't tell them apart. This isn't really a practical</a>
<a name="ln341">  // concern though because shutting down a pool typically requires clients to</a>
<a name="ln342">  // be quiesced first, so there's no danger of a client getting confused.</a>
<a name="ln343">  pool_status_ = STATUS(ServiceUnavailable, &quot;The pool has been shut down.&quot;);</a>
<a name="ln344"> </a>
<a name="ln345">  // Clear the various queues under the lock, but defer the releasing</a>
<a name="ln346">  // of the tasks outside the lock, in case there are concurrent threads</a>
<a name="ln347">  // wanting to access the ThreadPool. The task's destructors may acquire</a>
<a name="ln348">  // locks, etc, so this also prevents lock inversions.</a>
<a name="ln349">  queue_.clear();</a>
<a name="ln350">  deque&lt;deque&lt;Task&gt;&gt; to_release;</a>
<a name="ln351">  for (auto* t : tokens_) {</a>
<a name="ln352">    if (!t-&gt;entries_.empty()) {</a>
<a name="ln353">      to_release.emplace_back(std::move(t-&gt;entries_));</a>
<a name="ln354">    }</a>
<a name="ln355">    switch (t-&gt;state()) {</a>
<a name="ln356">      case ThreadPoolTokenState::kIdle:</a>
<a name="ln357">        // The token is idle; we can quiesce it immediately.</a>
<a name="ln358">        t-&gt;Transition(ThreadPoolTokenState::kQuiesced);</a>
<a name="ln359">        break;</a>
<a name="ln360">      case ThreadPoolTokenState::kRunning:</a>
<a name="ln361">        // The token has tasks associated with it. If they're merely queued</a>
<a name="ln362">        // (i.e. there are no active threads), the tasks will have been removed</a>
<a name="ln363">        // above and we can quiesce immediately. Otherwise, we need to wait for</a>
<a name="ln364">        // the threads to finish.</a>
<a name="ln365">        t-&gt;Transition(t-&gt;active_threads_ &gt; 0 ?</a>
<a name="ln366">            ThreadPoolTokenState::kQuiescing :</a>
<a name="ln367">            ThreadPoolTokenState::kQuiesced);</a>
<a name="ln368">        break;</a>
<a name="ln369">      default:</a>
<a name="ln370">        break;</a>
<a name="ln371">    }</a>
<a name="ln372">  }</a>
<a name="ln373"> </a>
<a name="ln374">  // The queues are empty. Wake any sleeping worker threads and wait for all</a>
<a name="ln375">  // of them to exit. Some worker threads will exit immediately upon waking,</a>
<a name="ln376">  // while others will exit after they finish executing an outstanding task.</a>
<a name="ln377">  total_queued_tasks_ = 0;</a>
<a name="ln378">  not_empty_.Broadcast();</a>
<a name="ln379">  while (num_threads_ &gt; 0) {</a>
<a name="ln380">    no_threads_cond_.Wait();</a>
<a name="ln381">  }</a>
<a name="ln382"> </a>
<a name="ln383">  // All the threads have exited. Check the state of each token.</a>
<a name="ln384">  for (auto* t : tokens_) {</a>
<a name="ln385">    DCHECK(t-&gt;state() == ThreadPoolTokenState::kIdle ||</a>
<a name="ln386">           t-&gt;state() == ThreadPoolTokenState::kQuiesced);</a>
<a name="ln387">  }</a>
<a name="ln388"> </a>
<a name="ln389">  // Finally release the queued tasks, outside the lock.</a>
<a name="ln390">  unique_lock.Unlock();</a>
<a name="ln391">  for (auto&amp; token : to_release) {</a>
<a name="ln392">    for (auto&amp; t : token) {</a>
<a name="ln393">      if (t.trace) {</a>
<a name="ln394">        t.trace-&gt;Release();</a>
<a name="ln395">      }</a>
<a name="ln396">    }</a>
<a name="ln397">  }</a>
<a name="ln398">}</a>
<a name="ln399"> </a>
<a name="ln400">unique_ptr&lt;ThreadPoolToken&gt; ThreadPool::NewToken(ExecutionMode mode) {</a>
<a name="ln401">  return NewTokenWithMetrics(mode, {});</a>
<a name="ln402">}</a>
<a name="ln403"> </a>
<a name="ln404">unique_ptr&lt;ThreadPoolToken&gt; ThreadPool::NewTokenWithMetrics(</a>
<a name="ln405">    ExecutionMode mode, ThreadPoolMetrics metrics) {</a>
<a name="ln406">  MutexLock guard(lock_);</a>
<a name="ln407">  unique_ptr&lt;ThreadPoolToken&gt; t(new ThreadPoolToken(this, mode, std::move(metrics)));</a>
<a name="ln408">  InsertOrDie(&amp;tokens_, t.get());</a>
<a name="ln409">  return t;</a>
<a name="ln410">}</a>
<a name="ln411"> </a>
<a name="ln412">void ThreadPool::ReleaseToken(ThreadPoolToken* t) {</a>
<a name="ln413">  MutexLock guard(lock_);</a>
<a name="ln414">  CHECK(!t-&gt;IsActive()) &lt;&lt; Substitute(&quot;Token with state $0 may not be released&quot;,</a>
<a name="ln415">                                      ThreadPoolToken::StateToString(t-&gt;state()));</a>
<a name="ln416">  CHECK_EQ(1, tokens_.erase(t));</a>
<a name="ln417">}</a>
<a name="ln418"> </a>
<a name="ln419"> </a>
<a name="ln420">Status ThreadPool::SubmitClosure(const Closure&amp; task) {</a>
<a name="ln421">  // TODO: once all uses of std::bind-based tasks are dead, implement this</a>
<a name="ln422">  // in a more straight-forward fashion.</a>
<a name="ln423">  return SubmitFunc(std::bind(&amp;Closure::Run, task));</a>
<a name="ln424">}</a>
<a name="ln425"> </a>
<a name="ln426">Status ThreadPool::SubmitFunc(const std::function&lt;void()&gt;&amp; func) {</a>
<a name="ln427">  return Submit(std::make_shared&lt;FunctionRunnable&gt;(func));</a>
<a name="ln428">}</a>
<a name="ln429"> </a>
<a name="ln430">Status ThreadPool::SubmitFunc(std::function&lt;void()&gt;&amp;&amp; func) {</a>
<a name="ln431">  return Submit(std::make_shared&lt;FunctionRunnable&gt;(std::move(func)));</a>
<a name="ln432">}</a>
<a name="ln433"> </a>
<a name="ln434">Status ThreadPool::Submit(const std::shared_ptr&lt;Runnable&gt;&amp; r) {</a>
<a name="ln435">  return DoSubmit(std::move(r), tokenless_.get());</a>
<a name="ln436">}</a>
<a name="ln437"> </a>
<a name="ln438">Status ThreadPool::DoSubmit(const std::shared_ptr&lt;Runnable&gt; task, ThreadPoolToken* token) {</a>
<a name="ln439">  DCHECK(token);</a>
<a name="ln440">  MonoTime submit_time = MonoTime::Now();</a>
<a name="ln441"> </a>
<a name="ln442">  MutexLock guard(lock_);</a>
<a name="ln443">  if (PREDICT_FALSE(!pool_status_.ok())) {</a>
<a name="ln444">    return pool_status_;</a>
<a name="ln445">  }</a>
<a name="ln446"> </a>
<a name="ln447">  if (PREDICT_FALSE(!token-&gt;MaySubmitNewTasks())) {</a>
<a name="ln448">    return STATUS(ServiceUnavailable, &quot;Thread pool token was shut down.&quot;, &quot;&quot;, Errno(ESHUTDOWN));</a>
<a name="ln449">  }</a>
<a name="ln450"> </a>
<a name="ln451">  // Size limit check.</a>
<a name="ln452">  int64_t capacity_remaining = static_cast&lt;int64_t&gt;(max_threads_) - active_threads_ +</a>
<a name="ln453">                               static_cast&lt;int64_t&gt;(max_queue_size_) - total_queued_tasks_;</a>
<a name="ln454">  if (capacity_remaining &lt; 1) {</a>
<a name="ln455">    return STATUS(ServiceUnavailable,</a>
<a name="ln456">                  Substitute(&quot;Thread pool is at capacity ($0/$1 tasks running, $2/$3 tasks queued)&quot;,</a>
<a name="ln457">                             num_threads_, max_threads_, total_queued_tasks_, max_queue_size_),</a>
<a name="ln458">                  &quot;&quot;, Errno(ESHUTDOWN));</a>
<a name="ln459">  }</a>
<a name="ln460"> </a>
<a name="ln461">  // Should we create another thread?</a>
<a name="ln462">  // We assume that each current inactive thread will grab one item from the</a>
<a name="ln463">  // queue.  If it seems like we'll need another thread, we create one.</a>
<a name="ln464">  // In theory, a currently active thread could finish immediately after this</a>
<a name="ln465">  // calculation.  This would mean we created a thread we didn't really need.</a>
<a name="ln466">  // However, this race is unavoidable, since we don't do the work under a lock.</a>
<a name="ln467">  // It's also harmless.</a>
<a name="ln468">  //</a>
<a name="ln469">  // Of course, we never create more than max_threads_ threads no matter what.</a>
<a name="ln470">  int threads_from_this_submit =</a>
<a name="ln471">      token-&gt;IsActive() &amp;&amp; token-&gt;mode() == ExecutionMode::SERIAL ? 0 : 1;</a>
<a name="ln472">  int inactive_threads = num_threads_ - active_threads_;</a>
<a name="ln473">  int additional_threads = (queue_.size() + threads_from_this_submit) - inactive_threads;</a>
<a name="ln474">  if (additional_threads &gt; 0 &amp;&amp; num_threads_ &lt; max_threads_) {</a>
<a name="ln475">    Status status = CreateThreadUnlocked();</a>
<a name="ln476">    if (!status.ok()) {</a>
<a name="ln477">      // If we failed to create a thread, but there are still some other</a>
<a name="ln478">      // worker threads, log a warning message and continue.</a>
<a name="ln479">      LOG(WARNING) &lt;&lt; &quot;Thread pool failed to create thread: &quot; &lt;&lt; status &lt;&lt; &quot;, num_threads: &quot;</a>
<a name="ln480">                   &lt;&lt; num_threads_ &lt;&lt; &quot;, max_threads: &quot; &lt;&lt; max_threads_;</a>
<a name="ln481">      if (num_threads_ == 0) {</a>
<a name="ln482">        // If we have no threads, we can't do any work.</a>
<a name="ln483">        return status;</a>
<a name="ln484">      }</a>
<a name="ln485">    }</a>
<a name="ln486">  }</a>
<a name="ln487"> </a>
<a name="ln488">  Task e;</a>
<a name="ln489">  e.runnable = task;</a>
<a name="ln490">  e.trace = Trace::CurrentTrace();</a>
<a name="ln491">  // Need to AddRef, since the thread which submitted the task may go away,</a>
<a name="ln492">  // and we don't want the trace to be destructed while waiting in the queue.</a>
<a name="ln493">  if (e.trace) {</a>
<a name="ln494">    e.trace-&gt;AddRef();</a>
<a name="ln495">  }</a>
<a name="ln496">  e.submit_time = submit_time;</a>
<a name="ln497"> </a>
<a name="ln498">  // Add the task to the token's queue.</a>
<a name="ln499">  ThreadPoolTokenState state = token-&gt;state();</a>
<a name="ln500">  DCHECK(state == ThreadPoolTokenState::kIdle ||</a>
<a name="ln501">         state == ThreadPoolTokenState::kRunning);</a>
<a name="ln502">  token-&gt;entries_.emplace_back(std::move(e));</a>
<a name="ln503">  if (state == ThreadPoolTokenState::kIdle ||</a>
<a name="ln504">      token-&gt;mode() == ExecutionMode::CONCURRENT) {</a>
<a name="ln505">    queue_.emplace_back(token);</a>
<a name="ln506">    if (state == ThreadPoolTokenState::kIdle) {</a>
<a name="ln507">      token-&gt;Transition(ThreadPoolTokenState::kRunning);</a>
<a name="ln508">    }</a>
<a name="ln509">  }</a>
<a name="ln510">  int length_at_submit = total_queued_tasks_++;</a>
<a name="ln511"> </a>
<a name="ln512">  guard.Unlock();</a>
<a name="ln513">  not_empty_.Signal();</a>
<a name="ln514"> </a>
<a name="ln515">  if (metrics_.queue_length_histogram) {</a>
<a name="ln516">    metrics_.queue_length_histogram-&gt;Increment(length_at_submit);</a>
<a name="ln517">  }</a>
<a name="ln518">  if (token-&gt;metrics_.queue_length_histogram) {</a>
<a name="ln519">    token-&gt;metrics_.queue_length_histogram-&gt;Increment(length_at_submit);</a>
<a name="ln520">  }</a>
<a name="ln521"> </a>
<a name="ln522">  return Status::OK();</a>
<a name="ln523">}</a>
<a name="ln524"> </a>
<a name="ln525">void ThreadPool::Wait() {</a>
<a name="ln526">  MutexLock unique_lock(lock_);</a>
<a name="ln527">  while ((!queue_.empty()) || (active_threads_ &gt; 0)) {</a>
<a name="ln528">    idle_cond_.Wait();</a>
<a name="ln529">  }</a>
<a name="ln530">}</a>
<a name="ln531"> </a>
<a name="ln532">bool ThreadPool::WaitUntil(const MonoTime&amp; until) {</a>
<a name="ln533">  MutexLock unique_lock(lock_);</a>
<a name="ln534">  while ((!queue_.empty()) || (active_threads_ &gt; 0)) {</a>
<a name="ln535">    if (!idle_cond_.WaitUntil(until)) {</a>
<a name="ln536">      return false;</a>
<a name="ln537">    }</a>
<a name="ln538">  }</a>
<a name="ln539">  return true;</a>
<a name="ln540">}</a>
<a name="ln541"> </a>
<a name="ln542">bool ThreadPool::WaitFor(const MonoDelta&amp; delta) {</a>
<a name="ln543">  return WaitUntil(MonoTime::Now() + delta);</a>
<a name="ln544">}</a>
<a name="ln545"> </a>
<a name="ln546">void ThreadPool::DispatchThread(bool permanent) {</a>
<a name="ln547">  MutexLock unique_lock(lock_);</a>
<a name="ln548">  while (true) {</a>
<a name="ln549">    // Note: STATUS(Aborted, ) is used to indicate normal shutdown.</a>
<a name="ln550">    if (!pool_status_.ok()) {</a>
<a name="ln551">      VLOG(2) &lt;&lt; &quot;DispatchThread exiting: &quot; &lt;&lt; pool_status_.ToString();</a>
<a name="ln552">      break;</a>
<a name="ln553">    }</a>
<a name="ln554"> </a>
<a name="ln555">    if (queue_.empty()) {</a>
<a name="ln556">      if (permanent) {</a>
<a name="ln557">        not_empty_.Wait();</a>
<a name="ln558">      } else {</a>
<a name="ln559">        if (!not_empty_.TimedWait(idle_timeout_)) {</a>
<a name="ln560">          // After much investigation, it appears that pthread condition variables have</a>
<a name="ln561">          // a weird behavior in which they can return ETIMEDOUT from timed_wait even if</a>
<a name="ln562">          // another thread did in fact signal. Apparently after a timeout there is some</a>
<a name="ln563">          // brief period during which another thread may actually grab the internal mutex</a>
<a name="ln564">          // protecting the state, signal, and release again before we get the mutex. So,</a>
<a name="ln565">          // we'll recheck the empty queue case regardless.</a>
<a name="ln566">          if (queue_.empty()) {</a>
<a name="ln567">            VLOG(3) &lt;&lt; &quot;Releasing worker thread from pool &quot; &lt;&lt; name_ &lt;&lt; &quot; after &quot;</a>
<a name="ln568">                    &lt;&lt; idle_timeout_.ToMilliseconds() &lt;&lt; &quot;ms of idle time.&quot;;</a>
<a name="ln569">            break;</a>
<a name="ln570">          }</a>
<a name="ln571">        }</a>
<a name="ln572">      }</a>
<a name="ln573">      continue;</a>
<a name="ln574">    }</a>
<a name="ln575"> </a>
<a name="ln576">    // Get the next token and task to execute.</a>
<a name="ln577">    ThreadPoolToken* token = queue_.front();</a>
<a name="ln578">    queue_.pop_front();</a>
<a name="ln579">    DCHECK_EQ(ThreadPoolTokenState::kRunning, token-&gt;state());</a>
<a name="ln580">    DCHECK(!token-&gt;entries_.empty());</a>
<a name="ln581">    Task task = std::move(token-&gt;entries_.front());</a>
<a name="ln582">    token-&gt;entries_.pop_front();</a>
<a name="ln583">    token-&gt;active_threads_++;</a>
<a name="ln584">    --total_queued_tasks_;</a>
<a name="ln585">    ++active_threads_;</a>
<a name="ln586"> </a>
<a name="ln587">    unique_lock.Unlock();</a>
<a name="ln588"> </a>
<a name="ln589">    // Release the reference which was held by the queued item.</a>
<a name="ln590">    ADOPT_TRACE(task.trace);</a>
<a name="ln591">    if (task.trace) {</a>
<a name="ln592">      task.trace-&gt;Release();</a>
<a name="ln593">    }</a>
<a name="ln594"> </a>
<a name="ln595">    // Update metrics</a>
<a name="ln596">    MonoTime now(MonoTime::Now());</a>
<a name="ln597">    int64_t queue_time_us = (now - task.submit_time).ToMicroseconds();</a>
<a name="ln598">    if (metrics_.queue_time_us_histogram) {</a>
<a name="ln599">      metrics_.queue_time_us_histogram-&gt;Increment(queue_time_us);</a>
<a name="ln600">    }</a>
<a name="ln601">    if (token-&gt;metrics_.queue_time_us_histogram) {</a>
<a name="ln602">      token-&gt;metrics_.queue_time_us_histogram-&gt;Increment(queue_time_us);</a>
<a name="ln603">    }</a>
<a name="ln604"> </a>
<a name="ln605">    // Execute the task</a>
<a name="ln606">    {</a>
<a name="ln607">      MicrosecondsInt64 start_wall_us = GetMonoTimeMicros();</a>
<a name="ln608">      task.runnable-&gt;Run();</a>
<a name="ln609">      int64_t wall_us = GetMonoTimeMicros() - start_wall_us;</a>
<a name="ln610"> </a>
<a name="ln611">      if (metrics_.run_time_us_histogram) {</a>
<a name="ln612">        metrics_.run_time_us_histogram-&gt;Increment(wall_us);</a>
<a name="ln613">      }</a>
<a name="ln614">      if (token-&gt;metrics_.run_time_us_histogram) {</a>
<a name="ln615">        token-&gt;metrics_.run_time_us_histogram-&gt;Increment(wall_us);</a>
<a name="ln616">      }</a>
<a name="ln617">    }</a>
<a name="ln618">    // Destruct the task while we do not hold the lock.</a>
<a name="ln619">    //</a>
<a name="ln620">    // The task's destructor may be expensive if it has a lot of bound</a>
<a name="ln621">    // objects, and we don't want to block submission of the threadpool.</a>
<a name="ln622">    // In the worst case, the destructor might even try to do something</a>
<a name="ln623">    // with this threadpool, and produce a deadlock.</a>
<a name="ln624">    task.runnable.reset();</a>
<a name="ln625">    unique_lock.Lock();</a>
<a name="ln626"> </a>
<a name="ln627">    // Possible states:</a>
<a name="ln628">    // 1. The token was shut down while we ran its task. Transition to kQuiesced.</a>
<a name="ln629">    // 2. The token has no more queued tasks. Transition back to kIdle.</a>
<a name="ln630">    // 3. The token has more tasks. Requeue it and transition back to RUNNABLE.</a>
<a name="ln631">    ThreadPoolTokenState state = token-&gt;state();</a>
<a name="ln632">    DCHECK(state == ThreadPoolTokenState::kRunning ||</a>
<a name="ln633">           state == ThreadPoolTokenState::kQuiescing);</a>
<a name="ln634">    if (--token-&gt;active_threads_ == 0) {</a>
<a name="ln635">      if (state == ThreadPoolTokenState::kQuiescing) {</a>
<a name="ln636">        DCHECK(token-&gt;entries_.empty());</a>
<a name="ln637">        token-&gt;Transition(ThreadPoolTokenState::kQuiesced);</a>
<a name="ln638">      } else if (token-&gt;entries_.empty()) {</a>
<a name="ln639">        token-&gt;Transition(ThreadPoolTokenState::kIdle);</a>
<a name="ln640">      } else if (token-&gt;mode() == ExecutionMode::SERIAL) {</a>
<a name="ln641">        queue_.emplace_back(token);</a>
<a name="ln642">      }</a>
<a name="ln643">    }</a>
<a name="ln644">    if (--active_threads_ == 0) {</a>
<a name="ln645">      idle_cond_.Broadcast();</a>
<a name="ln646">    }</a>
<a name="ln647">  }</a>
<a name="ln648"> </a>
<a name="ln649">  // It's important that we hold the lock between exiting the loop and dropping</a>
<a name="ln650">  // num_threads_. Otherwise it's possible someone else could come along here</a>
<a name="ln651">  // and add a new task just as the last running thread is about to exit.</a>
<a name="ln652">  CHECK(unique_lock.OwnsLock());</a>
<a name="ln653"> </a>
<a name="ln654">  CHECK_EQ(threads_.erase(Thread::current_thread()), 1);</a>
<a name="ln655">  if (--num_threads_ == 0) {</a>
<a name="ln656">    no_threads_cond_.Broadcast();</a>
<a name="ln657"> </a>
<a name="ln658">    // Sanity check: if we're the last thread exiting, the queue ought to be</a>
<a name="ln659">    // empty. Otherwise it will never get processed.</a>
<a name="ln660">    CHECK(queue_.empty());</a>
<a name="ln661">    DCHECK_EQ(0, total_queued_tasks_);</a>
<a name="ln662">  }</a>
<a name="ln663">}</a>
<a name="ln664"> </a>
<a name="ln665">Status ThreadPool::CreateThreadUnlocked() {</a>
<a name="ln666">  // The first few threads are permanent, and do not time out.</a>
<a name="ln667">  bool permanent = (num_threads_ &lt; min_threads_);</a>
<a name="ln668">  scoped_refptr&lt;Thread&gt; t;</a>
<a name="ln669">  Status s = yb::Thread::Create(&quot;thread pool&quot;, strings::Substitute(&quot;$0 [worker]&quot;, name_),</a>
<a name="ln670">                                  &amp;ThreadPool::DispatchThread, this, permanent, &amp;t);</a>
<a name="ln671">  if (s.ok()) {</a>
<a name="ln672">    InsertOrDie(&amp;threads_, t.get());</a>
<a name="ln673">    num_threads_++;</a>
<a name="ln674">  }</a>
<a name="ln675">  return s;</a>
<a name="ln676">}</a>
<a name="ln677"> </a>
<a name="ln678">void ThreadPool::CheckNotPoolThreadUnlocked() {</a>
<a name="ln679">  Thread* current = Thread::current_thread();</a>
<a name="ln680">  if (ContainsKey(threads_, current)) {</a>
<a name="ln681">    LOG(FATAL) &lt;&lt; Substitute(&quot;Thread belonging to thread pool '$0' with &quot;</a>
<a name="ln682">        &quot;name '$1' called pool function that would result in deadlock&quot;,</a>
<a name="ln683">        name_, current-&gt;name());</a>
<a name="ln684">  }</a>
<a name="ln685">}</a>
<a name="ln686"> </a>
<a name="ln687">} // namespace yb</a>

</code></pre>
<div class="balloon" rel="237"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="240"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="242"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="247"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="250"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="256"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="260"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="385"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="414"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="439"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="447"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1004/" target="_blank">V1004</a> The 'token' pointer was used unsafely after it was verified against nullptr. Check lines: 439, 447.</p></div>
<div class="balloon" rel="500"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="551"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="567"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="566"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'queue_.empty()' is always true.</p></div>
<div class="balloon" rel="580"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="632"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="636"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="652"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="660"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
