
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>backfill_index.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Copyright (c) YugaByte, Inc.</a>
<a name="ln2">//</a>
<a name="ln3">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln4">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln5">//</a>
<a name="ln6">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln7">//</a>
<a name="ln8">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln9">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln10">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln11">// under the License.</a>
<a name="ln12">//</a>
<a name="ln13">#include &quot;yb/master/backfill_index.h&quot;</a>
<a name="ln14"> </a>
<a name="ln15">#include &lt;stdlib.h&gt;</a>
<a name="ln16"> </a>
<a name="ln17">#include &lt;algorithm&gt;</a>
<a name="ln18">#include &lt;bitset&gt;</a>
<a name="ln19">#include &lt;functional&gt;</a>
<a name="ln20">#include &lt;memory&gt;</a>
<a name="ln21">#include &lt;mutex&gt;</a>
<a name="ln22">#include &lt;set&gt;</a>
<a name="ln23">#include &lt;unordered_map&gt;</a>
<a name="ln24">#include &lt;vector&gt;</a>
<a name="ln25"> </a>
<a name="ln26">#include &lt;glog/logging.h&gt;</a>
<a name="ln27">#include &lt;boost/optional.hpp&gt;</a>
<a name="ln28">#include &lt;boost/thread/shared_mutex.hpp&gt;</a>
<a name="ln29">#include &quot;yb/common/common_flags.h&quot;</a>
<a name="ln30">#include &quot;yb/common/partial_row.h&quot;</a>
<a name="ln31">#include &quot;yb/common/partition.h&quot;</a>
<a name="ln32">#include &quot;yb/common/roles_permissions.h&quot;</a>
<a name="ln33">#include &quot;yb/common/wire_protocol.h&quot;</a>
<a name="ln34">#include &quot;yb/consensus/consensus.h&quot;</a>
<a name="ln35">#include &quot;yb/consensus/consensus.proxy.h&quot;</a>
<a name="ln36">#include &quot;yb/consensus/consensus_peers.h&quot;</a>
<a name="ln37">#include &quot;yb/consensus/quorum_util.h&quot;</a>
<a name="ln38">#include &quot;yb/gutil/atomicops.h&quot;</a>
<a name="ln39">#include &quot;yb/gutil/map-util.h&quot;</a>
<a name="ln40">#include &quot;yb/gutil/mathlimits.h&quot;</a>
<a name="ln41">#include &quot;yb/gutil/stl_util.h&quot;</a>
<a name="ln42">#include &quot;yb/gutil/strings/escaping.h&quot;</a>
<a name="ln43">#include &quot;yb/gutil/strings/join.h&quot;</a>
<a name="ln44">#include &quot;yb/gutil/strings/substitute.h&quot;</a>
<a name="ln45">#include &quot;yb/gutil/sysinfo.h&quot;</a>
<a name="ln46">#include &quot;yb/gutil/walltime.h&quot;</a>
<a name="ln47">#include &quot;yb/master/async_rpc_tasks.h&quot;</a>
<a name="ln48">#include &quot;yb/master/catalog_loaders.h&quot;</a>
<a name="ln49">#include &quot;yb/master/catalog_manager_bg_tasks.h&quot;</a>
<a name="ln50">#include &quot;yb/master/catalog_manager_util.h&quot;</a>
<a name="ln51">#include &quot;yb/master/cluster_balance.h&quot;</a>
<a name="ln52">#include &quot;yb/master/master.h&quot;</a>
<a name="ln53">#include &quot;yb/master/master.pb.h&quot;</a>
<a name="ln54">#include &quot;yb/master/master.proxy.h&quot;</a>
<a name="ln55">#include &quot;yb/master/master_util.h&quot;</a>
<a name="ln56">#include &quot;yb/master/sys_catalog.h&quot;</a>
<a name="ln57">#include &quot;yb/master/system_tablet.h&quot;</a>
<a name="ln58">#include &quot;yb/master/tasks_tracker.h&quot;</a>
<a name="ln59">#include &quot;yb/master/ts_descriptor.h&quot;</a>
<a name="ln60">#include &quot;yb/master/ts_manager.h&quot;</a>
<a name="ln61">#include &quot;yb/master/yql_aggregates_vtable.h&quot;</a>
<a name="ln62">#include &quot;yb/master/yql_auth_resource_role_permissions_index.h&quot;</a>
<a name="ln63">#include &quot;yb/master/yql_auth_role_permissions_vtable.h&quot;</a>
<a name="ln64">#include &quot;yb/master/yql_auth_roles_vtable.h&quot;</a>
<a name="ln65">#include &quot;yb/master/yql_columns_vtable.h&quot;</a>
<a name="ln66">#include &quot;yb/master/yql_empty_vtable.h&quot;</a>
<a name="ln67">#include &quot;yb/master/yql_functions_vtable.h&quot;</a>
<a name="ln68">#include &quot;yb/master/yql_indexes_vtable.h&quot;</a>
<a name="ln69">#include &quot;yb/master/yql_keyspaces_vtable.h&quot;</a>
<a name="ln70">#include &quot;yb/master/yql_local_vtable.h&quot;</a>
<a name="ln71">#include &quot;yb/master/yql_partitions_vtable.h&quot;</a>
<a name="ln72">#include &quot;yb/master/yql_peers_vtable.h&quot;</a>
<a name="ln73">#include &quot;yb/master/yql_size_estimates_vtable.h&quot;</a>
<a name="ln74">#include &quot;yb/master/yql_tables_vtable.h&quot;</a>
<a name="ln75">#include &quot;yb/master/yql_triggers_vtable.h&quot;</a>
<a name="ln76">#include &quot;yb/master/yql_types_vtable.h&quot;</a>
<a name="ln77">#include &quot;yb/master/yql_views_vtable.h&quot;</a>
<a name="ln78"> </a>
<a name="ln79">#include &quot;yb/docdb/doc_rowwise_iterator.h&quot;</a>
<a name="ln80"> </a>
<a name="ln81">#include &quot;yb/rpc/messenger.h&quot;</a>
<a name="ln82">#include &quot;yb/tserver/ts_tablet_manager.h&quot;</a>
<a name="ln83"> </a>
<a name="ln84">#include &quot;yb/tablet/operations/change_metadata_operation.h&quot;</a>
<a name="ln85">#include &quot;yb/tablet/tablet.h&quot;</a>
<a name="ln86">#include &quot;yb/tablet/tablet_metadata.h&quot;</a>
<a name="ln87"> </a>
<a name="ln88">#include &quot;yb/tserver/tserver_admin.proxy.h&quot;</a>
<a name="ln89">#include &quot;yb/yql/redis/redisserver/redis_constants.h&quot;</a>
<a name="ln90"> </a>
<a name="ln91">#include &quot;yb/util/crypt.h&quot;</a>
<a name="ln92">#include &quot;yb/util/debug-util.h&quot;</a>
<a name="ln93">#include &quot;yb/util/debug/trace_event.h&quot;</a>
<a name="ln94">#include &quot;yb/util/flag_tags.h&quot;</a>
<a name="ln95">#include &quot;yb/util/logging.h&quot;</a>
<a name="ln96">#include &quot;yb/util/math_util.h&quot;</a>
<a name="ln97">#include &quot;yb/util/monotime.h&quot;</a>
<a name="ln98">#include &quot;yb/util/random_util.h&quot;</a>
<a name="ln99">#include &quot;yb/util/rw_mutex.h&quot;</a>
<a name="ln100">#include &quot;yb/util/stopwatch.h&quot;</a>
<a name="ln101">#include &quot;yb/util/thread.h&quot;</a>
<a name="ln102">#include &quot;yb/util/thread_restrictions.h&quot;</a>
<a name="ln103">#include &quot;yb/util/threadpool.h&quot;</a>
<a name="ln104">#include &quot;yb/util/trace.h&quot;</a>
<a name="ln105">#include &quot;yb/util/tsan_util.h&quot;</a>
<a name="ln106">#include &quot;yb/util/uuid.h&quot;</a>
<a name="ln107"> </a>
<a name="ln108">#include &quot;yb/client/client.h&quot;</a>
<a name="ln109">#include &quot;yb/client/meta_cache.h&quot;</a>
<a name="ln110">#include &quot;yb/client/table_creator.h&quot;</a>
<a name="ln111">#include &quot;yb/client/table_handle.h&quot;</a>
<a name="ln112">#include &quot;yb/client/yb_table_name.h&quot;</a>
<a name="ln113"> </a>
<a name="ln114">#include &quot;yb/tserver/remote_bootstrap_client.h&quot;</a>
<a name="ln115"> </a>
<a name="ln116">DEFINE_int32(index_backfill_rpc_timeout_ms, 1 * 60 * 1000, // 1 min.</a>
<a name="ln117">             &quot;Timeout used by the master when attempting to backfilll a tablet &quot;</a>
<a name="ln118">             &quot;during index creation.&quot;);</a>
<a name="ln119">TAG_FLAG(index_backfill_rpc_timeout_ms, advanced);</a>
<a name="ln120">TAG_FLAG(index_backfill_rpc_timeout_ms, runtime);</a>
<a name="ln121"> </a>
<a name="ln122">DEFINE_int32(index_backfill_rpc_max_retries, 150,</a>
<a name="ln123">             &quot;Number of times to retry backfilling a tablet chunk &quot;</a>
<a name="ln124">             &quot;during index creation.&quot;);</a>
<a name="ln125">TAG_FLAG(index_backfill_rpc_max_retries, advanced);</a>
<a name="ln126">TAG_FLAG(index_backfill_rpc_max_retries, runtime);</a>
<a name="ln127"> </a>
<a name="ln128">DEFINE_int32(index_backfill_rpc_max_delay_ms, 10 * 60 * 1000, // 10 min.</a>
<a name="ln129">             &quot;Maximum delay before retrying a backfill tablet chunk request &quot;</a>
<a name="ln130">             &quot;during index creation.&quot;);</a>
<a name="ln131">TAG_FLAG(index_backfill_rpc_max_delay_ms, advanced);</a>
<a name="ln132">TAG_FLAG(index_backfill_rpc_max_delay_ms, runtime);</a>
<a name="ln133"> </a>
<a name="ln134">DEFINE_int32(index_backfill_wait_for_alter_table_completion_ms, 100,</a>
<a name="ln135">             &quot;Delay before retrying to see if an in-progress alter table has &quot;</a>
<a name="ln136">             &quot;completed, during index backfill.&quot;);</a>
<a name="ln137">TAG_FLAG(index_backfill_wait_for_alter_table_completion_ms, advanced);</a>
<a name="ln138">TAG_FLAG(index_backfill_wait_for_alter_table_completion_ms, runtime);</a>
<a name="ln139"> </a>
<a name="ln140">DEFINE_test_flag(int32, slowdown_backfill_alter_table_rpcs_ms, 0,</a>
<a name="ln141">    &quot;Slows down the send alter table rpc's so that the master may be stopped between &quot;</a>
<a name="ln142">    &quot;different phases.&quot;);</a>
<a name="ln143"> </a>
<a name="ln144">namespace yb {</a>
<a name="ln145">namespace master {</a>
<a name="ln146"> </a>
<a name="ln147">using namespace std::literals;</a>
<a name="ln148">using strings::Substitute;</a>
<a name="ln149">using tserver::TabletServerErrorPB;</a>
<a name="ln150"> </a>
<a name="ln151">namespace {</a>
<a name="ln152"> </a>
<a name="ln153">// Peek into pg_index table to get an index (boolean) status from YSQL perspective.</a>
<a name="ln154">Result&lt;bool&gt; GetPgIndexStatus(</a>
<a name="ln155">    CatalogManager* catalog_manager,</a>
<a name="ln156">    const TableId&amp; idx_id,</a>
<a name="ln157">    const std::string&amp; status_col_name) {</a>
<a name="ln158">  const auto pg_index_id =</a>
<a name="ln159">      GetPgsqlTableId(VERIFY_RESULT(GetPgsqlDatabaseOid(idx_id)), kPgIndexTableOid);</a>
<a name="ln160"> </a>
<a name="ln161">  const tablet::Tablet* catalog_tablet =</a>
<a name="ln162">      catalog_manager-&gt;sys_catalog()-&gt;tablet_peer()-&gt;tablet();</a>
<a name="ln163">  const Schema&amp; pg_index_schema =</a>
<a name="ln164">      VERIFY_RESULT(catalog_tablet-&gt;metadata()-&gt;GetTableInfo(pg_index_id))-&gt;schema;</a>
<a name="ln165"> </a>
<a name="ln166">  Schema projection;</a>
<a name="ln167">  RETURN_NOT_OK(pg_index_schema.CreateProjectionByNames({&quot;indexrelid&quot;, status_col_name},</a>
<a name="ln168">                                                        &amp;projection,</a>
<a name="ln169">                                                        pg_index_schema.num_key_columns()));</a>
<a name="ln170"> </a>
<a name="ln171">  const auto indexrelid_col_id = VERIFY_RESULT(projection.ColumnIdByName(&quot;indexrelid&quot;)).rep();</a>
<a name="ln172">  const auto status_col_id     = VERIFY_RESULT(projection.ColumnIdByName(status_col_name)).rep();</a>
<a name="ln173"> </a>
<a name="ln174">  const auto idx_oid = VERIFY_RESULT(GetPgsqlTableOid(idx_id));</a>
<a name="ln175"> </a>
<a name="ln176">  auto iter = VERIFY_RESULT(catalog_tablet-&gt;NewRowIterator(projection.CopyWithoutColumnIds(),</a>
<a name="ln177">                                                           boost::none /* transaction_id */,</a>
<a name="ln178">                                                           {} /* read_hybrid_time */,</a>
<a name="ln179">                                                           pg_index_id));</a>
<a name="ln180"> </a>
<a name="ln181">  // Filtering by 'indexrelid' == idx_oid.</a>
<a name="ln182">  {</a>
<a name="ln183">    auto doc_iter = down_cast&lt;docdb::DocRowwiseIterator*&gt;(iter.get());</a>
<a name="ln184">    PgsqlConditionPB cond;</a>
<a name="ln185">    cond.add_operands()-&gt;set_column_id(indexrelid_col_id);</a>
<a name="ln186">    cond.set_op(QL_OP_EQUAL);</a>
<a name="ln187">    cond.add_operands()-&gt;mutable_value()-&gt;set_uint32_value(idx_oid);</a>
<a name="ln188">    docdb::DocPgsqlScanSpec spec(projection,</a>
<a name="ln189">                                 rocksdb::kDefaultQueryId,</a>
<a name="ln190">                                 {} /* hashed_components */,</a>
<a name="ln191">                                 &amp;cond,</a>
<a name="ln192">                                 boost::none /* hash_code */,</a>
<a name="ln193">                                 boost::none /* max_hash_code */,</a>
<a name="ln194">                                 nullptr /* where_expr */);</a>
<a name="ln195">    RETURN_NOT_OK(doc_iter-&gt;Init(spec));</a>
<a name="ln196">  }</a>
<a name="ln197"> </a>
<a name="ln198">  // Expecting one row at most.</a>
<a name="ln199">  QLTableRow row;</a>
<a name="ln200">  if (VERIFY_RESULT(iter-&gt;HasNext())) {</a>
<a name="ln201">    RETURN_NOT_OK(iter-&gt;NextRow(&amp;row));</a>
<a name="ln202">    return row.GetColumn(status_col_id)-&gt;bool_value();</a>
<a name="ln203">  }</a>
<a name="ln204"> </a>
<a name="ln205">  // For practical purposes, an absent index is the same as having false status column value.</a>
<a name="ln206">  return false;</a>
<a name="ln207">}</a>
<a name="ln208"> </a>
<a name="ln209">// Before advancing index permissions, we need to make sure Postgres side has advanced sufficiently</a>
<a name="ln210">// - that the state tracked in pg_index haven't fallen behind from the desired permission</a>
<a name="ln211">// for more than one step.</a>
<a name="ln212">Result&lt;bool&gt; ShouldProceedWithPgsqlIndexPermissionUpdate(</a>
<a name="ln213">    CatalogManager* catalog_manager,</a>
<a name="ln214">    const TableId&amp; idx_id,</a>
<a name="ln215">    IndexPermissions new_perm) {</a>
<a name="ln216">  // TODO(alex, jason): Add the appropriate cases for dropping index path</a>
<a name="ln217">  switch (new_perm) {</a>
<a name="ln218">    case INDEX_PERM_WRITE_AND_DELETE: {</a>
<a name="ln219">      auto live = VERIFY_RESULT(GetPgIndexStatus(catalog_manager, idx_id, &quot;indislive&quot;));</a>
<a name="ln220">      if (!live) {</a>
<a name="ln221">        VLOG(1) &lt;&lt; &quot;Index &quot; &lt;&lt; idx_id &lt;&lt; &quot; is not yet live, skipping permission update&quot;;</a>
<a name="ln222">      }</a>
<a name="ln223">      return live;</a>
<a name="ln224">    }</a>
<a name="ln225">    case INDEX_PERM_DO_BACKFILL: {</a>
<a name="ln226">      auto ready = VERIFY_RESULT(GetPgIndexStatus(catalog_manager, idx_id, &quot;indisready&quot;));</a>
<a name="ln227">      if (!ready) {</a>
<a name="ln228">        VLOG(1) &lt;&lt; &quot;Index &quot; &lt;&lt; idx_id &lt;&lt; &quot; is not yet ready, skipping permission update&quot;;</a>
<a name="ln229">      }</a>
<a name="ln230">      return ready;</a>
<a name="ln231">    }</a>
<a name="ln232">    default:</a>
<a name="ln233">      // No need to wait for anything</a>
<a name="ln234">      return true;</a>
<a name="ln235">  }</a>
<a name="ln236">}</a>
<a name="ln237"> </a>
<a name="ln238">} // namespace</a>
<a name="ln239"> </a>
<a name="ln240">void MultiStageAlterTable::CopySchemaDetailsToFullyApplied(SysTablesEntryPB* pb) {</a>
<a name="ln241">  VLOG(4) &lt;&lt; &quot;Setting fully_applied_schema_version to &quot; &lt;&lt; pb-&gt;version();</a>
<a name="ln242">  pb-&gt;mutable_fully_applied_schema()-&gt;CopyFrom(pb-&gt;schema());</a>
<a name="ln243">  pb-&gt;set_fully_applied_schema_version(pb-&gt;version());</a>
<a name="ln244">  pb-&gt;mutable_fully_applied_indexes()-&gt;CopyFrom(pb-&gt;indexes());</a>
<a name="ln245">  if (pb-&gt;has_index_info()) {</a>
<a name="ln246">    pb-&gt;mutable_fully_applied_index_info()-&gt;CopyFrom(pb-&gt;index_info());</a>
<a name="ln247">  }</a>
<a name="ln248">}</a>
<a name="ln249"> </a>
<a name="ln250">Status MultiStageAlterTable::ClearAlteringState(</a>
<a name="ln251">    CatalogManager* catalog_manager,</a>
<a name="ln252">    const scoped_refptr&lt;TableInfo&gt;&amp; table,</a>
<a name="ln253">    uint32_t expected_version) {</a>
<a name="ln254">  auto l = table-&gt;LockForWrite();</a>
<a name="ln255">  uint32_t current_version = l-&gt;data().pb.version();</a>
<a name="ln256">  if (expected_version != current_version) {</a>
<a name="ln257">    return STATUS(AlreadyPresent, &quot;Table has already moved to a different version.&quot;);</a>
<a name="ln258">  }</a>
<a name="ln259">  l-&gt;mutable_data()-&gt;pb.clear_fully_applied_schema();</a>
<a name="ln260">  l-&gt;mutable_data()-&gt;pb.clear_fully_applied_schema_version();</a>
<a name="ln261">  l-&gt;mutable_data()-&gt;pb.clear_fully_applied_indexes();</a>
<a name="ln262">  l-&gt;mutable_data()-&gt;pb.clear_fully_applied_index_info();</a>
<a name="ln263">  l-&gt;mutable_data()-&gt;set_state(</a>
<a name="ln264">      SysTablesEntryPB::RUNNING, Substitute(&quot;Current schema version=$0&quot;, current_version));</a>
<a name="ln265"> </a>
<a name="ln266">  Status s =</a>
<a name="ln267">      catalog_manager-&gt;sys_catalog_-&gt;UpdateItem(table.get(), catalog_manager-&gt;leader_ready_term());</a>
<a name="ln268">  if (!s.ok()) {</a>
<a name="ln269">    LOG(WARNING) &lt;&lt; &quot;An error occurred while updating sys-tables: &quot; &lt;&lt; s.ToString()</a>
<a name="ln270">                 &lt;&lt; &quot;. This master may not be the leader anymore.&quot;;</a>
<a name="ln271">    return s;</a>
<a name="ln272">  }</a>
<a name="ln273"> </a>
<a name="ln274">  l-&gt;Commit();</a>
<a name="ln275">  LOG(INFO) &lt;&lt; table-&gt;ToString() &lt;&lt; &quot; - Alter table completed version=&quot; &lt;&lt; current_version;</a>
<a name="ln276">  return Status::OK();</a>
<a name="ln277">}</a>
<a name="ln278"> </a>
<a name="ln279">Result&lt;bool&gt; MultiStageAlterTable::UpdateIndexPermission(</a>
<a name="ln280">    CatalogManager* catalog_manager,</a>
<a name="ln281">    const scoped_refptr&lt;TableInfo&gt;&amp; indexed_table,</a>
<a name="ln282">    const std::unordered_map&lt;TableId, IndexPermissions&gt;&amp; perm_mapping,</a>
<a name="ln283">    boost::optional&lt;uint32_t&gt; current_version) {</a>
<a name="ln284">  DVLOG(3) &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; yb::ToString(*indexed_table);</a>
<a name="ln285">  if (FLAGS_TEST_slowdown_backfill_alter_table_rpcs_ms &gt; 0) {</a>
<a name="ln286">    TRACE(&quot;Sleeping for  $0 ms&quot;, FLAGS_TEST_slowdown_backfill_alter_table_rpcs_ms);</a>
<a name="ln287">    DVLOG(3) &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; yb::ToString(*indexed_table) &lt;&lt; &quot; sleeping for &quot;</a>
<a name="ln288">             &lt;&lt; FLAGS_TEST_slowdown_backfill_alter_table_rpcs_ms</a>
<a name="ln289">             &lt;&lt; &quot;ms BEFORE updating the index permission to &quot; &lt;&lt; ToString(perm_mapping);</a>
<a name="ln290">    SleepFor(MonoDelta::FromMilliseconds(FLAGS_TEST_slowdown_backfill_alter_table_rpcs_ms));</a>
<a name="ln291">    DVLOG(3) &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; &quot;Done Sleeping&quot;;</a>
<a name="ln292">    TRACE(&quot;Done Sleeping&quot;);</a>
<a name="ln293">  }</a>
<a name="ln294"> </a>
<a name="ln295">  bool permissions_updated = false;</a>
<a name="ln296">  {</a>
<a name="ln297">    TRACE(&quot;Locking indexed table&quot;);</a>
<a name="ln298">    auto l = indexed_table-&gt;LockForWrite();</a>
<a name="ln299">    auto&amp; indexed_table_data = *l-&gt;mutable_data();</a>
<a name="ln300">    auto&amp; indexed_table_pb = indexed_table_data.pb;</a>
<a name="ln301">    if (current_version &amp;&amp; *current_version != indexed_table_pb.version()) {</a>
<a name="ln302">      LOG(INFO) &lt;&lt; &quot;The table schema version &quot;</a>
<a name="ln303">                &lt;&lt; &quot;seems to have already been updated to &quot; &lt;&lt; indexed_table_pb.version()</a>
<a name="ln304">                &lt;&lt; &quot; We wanted to do this update at &quot; &lt;&lt; *current_version;</a>
<a name="ln305">      return STATUS_SUBSTITUTE(</a>
<a name="ln306">          AlreadyPresent, &quot;Schema was already updated to $0 before we got to it (expected $1).&quot;,</a>
<a name="ln307">          indexed_table_pb.version(), *current_version);</a>
<a name="ln308">    }</a>
<a name="ln309"> </a>
<a name="ln310">    CopySchemaDetailsToFullyApplied(&amp;indexed_table_pb);</a>
<a name="ln311">    bool is_pgsql = indexed_table_pb.table_type() == TableType::PGSQL_TABLE_TYPE;</a>
<a name="ln312">    for (int i = 0; i &lt; indexed_table_pb.indexes_size(); i++) {</a>
<a name="ln313">      IndexInfoPB* idx_pb = indexed_table_pb.mutable_indexes(i);</a>
<a name="ln314">      auto&amp; idx_table_id = idx_pb-&gt;table_id();</a>
<a name="ln315">      if (perm_mapping.find(idx_table_id) != perm_mapping.end()) {</a>
<a name="ln316">        const auto new_perm = perm_mapping.at(idx_table_id);</a>
<a name="ln317">        // TODO(alex, amit): Non-OK status here should be converted to TryAgain,</a>
<a name="ln318">        //                   which should be handled on an upper level.</a>
<a name="ln319">        if (is_pgsql &amp;&amp; !VERIFY_RESULT(ShouldProceedWithPgsqlIndexPermissionUpdate(catalog_manager,</a>
<a name="ln320">                                                                                   idx_table_id,</a>
<a name="ln321">                                                                                   new_perm))) {</a>
<a name="ln322">          continue;</a>
<a name="ln323">        }</a>
<a name="ln324">        idx_pb-&gt;set_index_permissions(new_perm);</a>
<a name="ln325">        permissions_updated = true;</a>
<a name="ln326">      }</a>
<a name="ln327">    }</a>
<a name="ln328"> </a>
<a name="ln329">    if (permissions_updated) {</a>
<a name="ln330">      indexed_table_pb.set_version(indexed_table_pb.version() + 1);</a>
<a name="ln331">    } else {</a>
<a name="ln332">      VLOG(1) &lt;&lt; &quot;Index permissions update skipped, leaving schema_version at &quot;</a>
<a name="ln333">              &lt;&lt; indexed_table_pb.version();</a>
<a name="ln334">    }</a>
<a name="ln335">    indexed_table_data.set_state(SysTablesEntryPB::ALTERING,</a>
<a name="ln336">                                 Substitute(&quot;Alter table version=$0 ts=$1&quot;,</a>
<a name="ln337">                                            indexed_table_pb.version(),</a>
<a name="ln338">                                            LocalTimeAsString()));</a>
<a name="ln339"> </a>
<a name="ln340">    // Update sys-catalog with the new indexed table info.</a>
<a name="ln341">    TRACE(&quot;Updating indexed table metadata on disk&quot;);</a>
<a name="ln342">    RETURN_NOT_OK(catalog_manager-&gt;sys_catalog_-&gt;UpdateItem(</a>
<a name="ln343">        indexed_table.get(), catalog_manager-&gt;leader_ready_term()));</a>
<a name="ln344"> </a>
<a name="ln345">    // Update the in-memory state.</a>
<a name="ln346">    TRACE(&quot;Committing in-memory state&quot;);</a>
<a name="ln347">    l-&gt;Commit();</a>
<a name="ln348">  }</a>
<a name="ln349">  if (PREDICT_FALSE(FLAGS_TEST_slowdown_backfill_alter_table_rpcs_ms &gt; 0)) {</a>
<a name="ln350">    TRACE(&quot;Sleeping for $0 ms&quot;,</a>
<a name="ln351">          FLAGS_TEST_slowdown_backfill_alter_table_rpcs_ms);</a>
<a name="ln352">    DVLOG(3) &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; yb::ToString(*indexed_table) &lt;&lt; &quot; sleeping for &quot;</a>
<a name="ln353">             &lt;&lt; FLAGS_TEST_slowdown_backfill_alter_table_rpcs_ms</a>
<a name="ln354">             &lt;&lt; &quot;ms AFTER updating the index permission to &quot; &lt;&lt; ToString(perm_mapping);</a>
<a name="ln355">    SleepFor(MonoDelta::FromMilliseconds(FLAGS_TEST_slowdown_backfill_alter_table_rpcs_ms));</a>
<a name="ln356">    DVLOG(3) &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; &quot;Done Sleeping&quot;;</a>
<a name="ln357">    TRACE(&quot;Done Sleeping&quot;);</a>
<a name="ln358">  }</a>
<a name="ln359">  return permissions_updated;</a>
<a name="ln360">}</a>
<a name="ln361"> </a>
<a name="ln362">Status MultiStageAlterTable::StartBackfillingData(</a>
<a name="ln363">    CatalogManager *catalog_manager,</a>
<a name="ln364">    const scoped_refptr&lt;TableInfo&gt; &amp;indexed_table, const IndexInfoPB index_pb) {</a>
<a name="ln365">  if (indexed_table-&gt;IsBackfilling()) {</a>
<a name="ln366">    LOG(WARNING) &lt;&lt; __func__ &lt;&lt; &quot; Not starting backfill for &quot;</a>
<a name="ln367">                 &lt;&lt; indexed_table-&gt;ToString() &lt;&lt; &quot; one is already in progress &quot;;</a>
<a name="ln368">    return STATUS(AlreadyPresent, &quot;Backfill already in progress&quot;);</a>
<a name="ln369">  }</a>
<a name="ln370"> </a>
<a name="ln371">  VLOG(1) &lt;&lt; __func__ &lt;&lt; &quot; starting backfill on &quot; &lt;&lt; indexed_table-&gt;ToString()</a>
<a name="ln372">          &lt;&lt; &quot; for &quot; &lt;&lt; index_pb.table_id();</a>
<a name="ln373">  {</a>
<a name="ln374">    TRACE(&quot;Locking indexed table&quot;);</a>
<a name="ln375">    auto l = indexed_table-&gt;LockForWrite();</a>
<a name="ln376">    auto &amp;indexed_table_data = *l-&gt;mutable_data();</a>
<a name="ln377">    CopySchemaDetailsToFullyApplied(&amp;indexed_table_data.pb);</a>
<a name="ln378">    // Update sys-catalog with the new indexed table info.</a>
<a name="ln379">    TRACE(&quot;Updating indexed table metadata on disk&quot;);</a>
<a name="ln380">    RETURN_NOT_OK_PREPEND(</a>
<a name="ln381">        catalog_manager-&gt;sys_catalog_-&gt;UpdateItem(</a>
<a name="ln382">            indexed_table.get(), catalog_manager-&gt;leader_ready_term()),</a>
<a name="ln383">        &quot;Updating indexed table metadata on disk. Abandoning.&quot;);</a>
<a name="ln384"> </a>
<a name="ln385">    // Update the in-memory state.</a>
<a name="ln386">    TRACE(&quot;Committing in-memory state&quot;);</a>
<a name="ln387">    l-&gt;Commit();</a>
<a name="ln388">  }</a>
<a name="ln389">  indexed_table-&gt;SetIsBackfilling(true);</a>
<a name="ln390"> </a>
<a name="ln391">  scoped_refptr&lt;NamespaceInfo&gt; ns_info;</a>
<a name="ln392">  {</a>
<a name="ln393">    NamespaceIdentifierPB ns_identifier;</a>
<a name="ln394">    ns_identifier.set_id(indexed_table-&gt;namespace_id());</a>
<a name="ln395">    RETURN_NOT_OK_PREPEND(</a>
<a name="ln396">        catalog_manager-&gt;FindNamespace(ns_identifier, &amp;ns_info),</a>
<a name="ln397">        &quot;Getting namespace info for backfill&quot;);</a>
<a name="ln398">  }</a>
<a name="ln399">  auto backfill_table = std::make_shared&lt;BackfillTable&gt;(</a>
<a name="ln400">      catalog_manager-&gt;master_, catalog_manager-&gt;AsyncTaskPool(),</a>
<a name="ln401">      indexed_table, std::vector&lt;IndexInfoPB&gt;{index_pb}, ns_info);</a>
<a name="ln402">  backfill_table-&gt;Launch();</a>
<a name="ln403">  return Status::OK();</a>
<a name="ln404">}</a>
<a name="ln405"> </a>
<a name="ln406">// Returns true, if the said IndexPermissions is a transient state.</a>
<a name="ln407">// Returns false, if it is a state where the index can be. viz: READ_WRITE_AND_DELETE</a>
<a name="ln408">// INDEX_UNUSED is considered transcient because it needs to delete the index.</a>
<a name="ln409">bool IsTransientState(IndexPermissions perm) {</a>
<a name="ln410">  return perm != INDEX_PERM_READ_WRITE_AND_DELETE &amp;&amp; perm != INDEX_PERM_NOT_USED;</a>
<a name="ln411">}</a>
<a name="ln412"> </a>
<a name="ln413">IndexPermissions NextPermission(IndexPermissions perm) {</a>
<a name="ln414">  switch (perm) {</a>
<a name="ln415">    case INDEX_PERM_DELETE_ONLY:</a>
<a name="ln416">      return INDEX_PERM_WRITE_AND_DELETE;</a>
<a name="ln417">    case INDEX_PERM_WRITE_AND_DELETE:</a>
<a name="ln418">      return INDEX_PERM_DO_BACKFILL;</a>
<a name="ln419">    case INDEX_PERM_DO_BACKFILL:</a>
<a name="ln420">      CHECK(false) &lt;&lt; &quot;Not expected to be here.&quot;;</a>
<a name="ln421">      return INDEX_PERM_DELETE_ONLY;</a>
<a name="ln422">    case INDEX_PERM_READ_WRITE_AND_DELETE:</a>
<a name="ln423">      CHECK(false) &lt;&lt; &quot;Not expected to be here.&quot;;</a>
<a name="ln424">      return INDEX_PERM_DELETE_ONLY;</a>
<a name="ln425">    case INDEX_PERM_WRITE_AND_DELETE_WHILE_REMOVING:</a>
<a name="ln426">      return INDEX_PERM_DELETE_ONLY_WHILE_REMOVING;</a>
<a name="ln427">    case INDEX_PERM_DELETE_ONLY_WHILE_REMOVING:</a>
<a name="ln428">      return INDEX_PERM_INDEX_UNUSED;</a>
<a name="ln429">    case INDEX_PERM_INDEX_UNUSED:</a>
<a name="ln430">    case INDEX_PERM_NOT_USED:</a>
<a name="ln431">      CHECK(false) &lt;&lt; &quot;Not expected to be here.&quot;;</a>
<a name="ln432">      return INDEX_PERM_DELETE_ONLY;</a>
<a name="ln433">  }</a>
<a name="ln434">  CHECK(false) &lt;&lt; &quot;Not expected to be here.&quot;;</a>
<a name="ln435">  return INDEX_PERM_DELETE_ONLY;</a>
<a name="ln436">}</a>
<a name="ln437"> </a>
<a name="ln438">Status MultiStageAlterTable::LaunchNextTableInfoVersionIfNecessary(</a>
<a name="ln439">    CatalogManager* catalog_manager, const scoped_refptr&lt;TableInfo&gt;&amp; indexed_table,</a>
<a name="ln440">    uint32_t current_version) {</a>
<a name="ln441">  DVLOG(3) &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; yb::ToString(*indexed_table);</a>
<a name="ln442"> </a>
<a name="ln443">  std::unordered_map&lt;TableId, IndexPermissions&gt; indexes_to_update;</a>
<a name="ln444">  vector&lt;IndexInfoPB&gt; indexes_to_backfill;</a>
<a name="ln445">  vector&lt;IndexInfoPB&gt; indexes_to_delete;</a>
<a name="ln446">  {</a>
<a name="ln447">    TRACE(&quot;Locking indexed table&quot;);</a>
<a name="ln448">    VLOG(1) &lt;&lt; (&quot;Locking indexed table&quot;);</a>
<a name="ln449">    auto l = indexed_table-&gt;LockForRead();</a>
<a name="ln450">    if (current_version != l-&gt;data().pb.version()) {</a>
<a name="ln451">      LOG(WARNING) &lt;&lt; &quot;Somebody launched the next version before we got to it.&quot;;</a>
<a name="ln452">      return Status::OK();</a>
<a name="ln453">    }</a>
<a name="ln454"> </a>
<a name="ln455">    // Attempt to find an index that requires us to just launch the next state (i.e. not backfill)</a>
<a name="ln456">    for (int i = 0; i &lt; l-&gt;data().pb.indexes_size(); i++) {</a>
<a name="ln457">      const IndexInfoPB&amp; idx_pb = l-&gt;data().pb.indexes(i);</a>
<a name="ln458">      if (!idx_pb.has_index_permissions()) {</a>
<a name="ln459">        continue;</a>
<a name="ln460">      }</a>
<a name="ln461">      if (idx_pb.index_permissions() == INDEX_PERM_DO_BACKFILL) {</a>
<a name="ln462">        indexes_to_backfill.emplace_back(idx_pb);</a>
<a name="ln463">      } else if (idx_pb.index_permissions() == INDEX_PERM_INDEX_UNUSED) {</a>
<a name="ln464">        indexes_to_delete.emplace_back(idx_pb);</a>
<a name="ln465">      } else if (idx_pb.index_permissions() != INDEX_PERM_READ_WRITE_AND_DELETE) {</a>
<a name="ln466">        indexes_to_update.emplace(idx_pb.table_id(), NextPermission(idx_pb.index_permissions()));</a>
<a name="ln467">      }</a>
<a name="ln468">    }</a>
<a name="ln469">  }</a>
<a name="ln470"> </a>
<a name="ln471">  if (indexes_to_update.empty() &amp;&amp;</a>
<a name="ln472">      indexes_to_delete.empty() &amp;&amp;</a>
<a name="ln473">      indexes_to_backfill.empty()) {</a>
<a name="ln474"> </a>
<a name="ln475">    TRACE(&quot;Not necessary to launch next version&quot;);</a>
<a name="ln476">    VLOG(1) &lt;&lt; &quot;Not necessary to launch next version&quot;;</a>
<a name="ln477">    return ClearAlteringState(catalog_manager, indexed_table, current_version);</a>
<a name="ln478">  }</a>
<a name="ln479"> </a>
<a name="ln480">  if (!indexes_to_update.empty()) {</a>
<a name="ln481">    Result&lt;bool&gt; permissions_updated =</a>
<a name="ln482">        VERIFY_RESULT(UpdateIndexPermission(catalog_manager, indexed_table, indexes_to_update,</a>
<a name="ln483">                                            current_version));</a>
<a name="ln484"> </a>
<a name="ln485">    if (!permissions_updated.ok()) {</a>
<a name="ln486">      LOG(WARNING) &lt;&lt; &quot;Could not update index permissions.&quot;</a>
<a name="ln487">                   &lt;&lt; &quot; Possible that the master-leader has changed, or a race &quot;</a>
<a name="ln488">                   &lt;&lt; &quot;with another thread trying to launch next version: &quot;</a>
<a name="ln489">                   &lt;&lt; permissions_updated.ToString();</a>
<a name="ln490">    }</a>
<a name="ln491"> </a>
<a name="ln492">    if (permissions_updated.ok() &amp;&amp; *permissions_updated) {</a>
<a name="ln493">      catalog_manager-&gt;SendAlterTableRequest(indexed_table);</a>
<a name="ln494">      return Status::OK();</a>
<a name="ln495">    }</a>
<a name="ln496">  }</a>
<a name="ln497"> </a>
<a name="ln498">  IndexInfoPB index_info_to_update;</a>
<a name="ln499">  if (!indexes_to_delete.empty()) {</a>
<a name="ln500">    index_info_to_update = indexes_to_delete[0];</a>
<a name="ln501">    VLOG(3) &lt;&lt; &quot;Deleting the index and the entry in the indexed table for &quot;</a>
<a name="ln502">        &lt;&lt; yb::ToString(index_info_to_update);</a>
<a name="ln503">    DeleteTableRequestPB req;</a>
<a name="ln504">    DeleteTableResponsePB resp;</a>
<a name="ln505">    req.mutable_table()-&gt;set_table_id(index_info_to_update.table_id());</a>
<a name="ln506">    req.set_is_index_table(true);</a>
<a name="ln507">    RETURN_NOT_OK(catalog_manager-&gt;DeleteTableInternal(&amp;req, &amp;resp, nullptr));</a>
<a name="ln508">    return Status::OK();</a>
<a name="ln509">  }</a>
<a name="ln510"> </a>
<a name="ln511">  if (!indexes_to_backfill.empty()) {</a>
<a name="ln512">    // TODO(Amit): Batch backfill for different indexes.</a>
<a name="ln513">    index_info_to_update = indexes_to_backfill[0];</a>
<a name="ln514">    VLOG(3) &lt;&lt; &quot;Start backfilling for &quot; &lt;&lt; yb::ToString(index_info_to_update);</a>
<a name="ln515">    TRACE(&quot;Starting backfill process&quot;);</a>
<a name="ln516">    VLOG(1) &lt;&lt; (&quot;Starting backfill process&quot;);</a>
<a name="ln517">    WARN_NOT_OK(</a>
<a name="ln518">        StartBackfillingData(catalog_manager, indexed_table.get(), index_info_to_update),</a>
<a name="ln519">        &quot;Could not launch Backfill&quot;);</a>
<a name="ln520">    return Status::OK();</a>
<a name="ln521">  }</a>
<a name="ln522"> </a>
<a name="ln523">  return Status::OK();</a>
<a name="ln524">}</a>
<a name="ln525"> </a>
<a name="ln526">// -----------------------------------------------------------------------------------------------</a>
<a name="ln527">// BackfillTableJob</a>
<a name="ln528">// -----------------------------------------------------------------------------------------------</a>
<a name="ln529">std::string BackfillTableJob::description() const {</a>
<a name="ln530">  const std::shared_ptr&lt;BackfillTable&gt; retain_bt = backfill_table_;</a>
<a name="ln531">  auto curr_state = state();</a>
<a name="ln532">  if (!IsStateTerminal(curr_state) &amp;&amp; retain_bt) {</a>
<a name="ln533">    return retain_bt-&gt;description();</a>
<a name="ln534">  } else if (curr_state == MonitoredTaskState::kFailed) {</a>
<a name="ln535">    return Format(&quot;Backfilling $0 Failed&quot;, index_ids_);</a>
<a name="ln536">  } else if (curr_state == MonitoredTaskState::kAborted) {</a>
<a name="ln537">    return Format(&quot;Backfilling $0 Aborted&quot;, index_ids_);</a>
<a name="ln538">  } else {</a>
<a name="ln539">    DCHECK(curr_state == MonitoredTaskState::kComplete);</a>
<a name="ln540">    return Format(&quot;Backfilling $0 Done&quot;, index_ids_);</a>
<a name="ln541">  }</a>
<a name="ln542">}</a>
<a name="ln543"> </a>
<a name="ln544">MonitoredTaskState BackfillTableJob::AbortAndReturnPrevState(const Status&amp; status) {</a>
<a name="ln545">  auto old_state = state();</a>
<a name="ln546">  while (!IsStateTerminal(old_state)) {</a>
<a name="ln547">    if (state_.compare_exchange_strong(old_state,</a>
<a name="ln548">                                       MonitoredTaskState::kAborted)) {</a>
<a name="ln549">      return old_state;</a>
<a name="ln550">    }</a>
<a name="ln551">    old_state = state();</a>
<a name="ln552">  }</a>
<a name="ln553">  return old_state;</a>
<a name="ln554">}</a>
<a name="ln555"> </a>
<a name="ln556">void BackfillTableJob::SetState(MonitoredTaskState new_state) {</a>
<a name="ln557">  auto old_state = state();</a>
<a name="ln558">  if (!IsStateTerminal(old_state)) {</a>
<a name="ln559">    if (state_.compare_exchange_strong(old_state, new_state) &amp;&amp; IsStateTerminal(new_state)) {</a>
<a name="ln560">      MarkDone();</a>
<a name="ln561">    }</a>
<a name="ln562">  }</a>
<a name="ln563">}</a>
<a name="ln564">// -----------------------------------------------------------------------------------------------</a>
<a name="ln565">// BackfillTable</a>
<a name="ln566">// -----------------------------------------------------------------------------------------------</a>
<a name="ln567">BackfillTable::BackfillTable(Master *master, ThreadPool *callback_pool,</a>
<a name="ln568">                             const scoped_refptr&lt;TableInfo&gt; &amp;indexed_table,</a>
<a name="ln569">                             std::vector&lt;IndexInfoPB&gt; indexes,</a>
<a name="ln570">                             const scoped_refptr&lt;NamespaceInfo&gt; &amp;ns_info)</a>
<a name="ln571">    : master_(master), callback_pool_(callback_pool),</a>
<a name="ln572">      indexed_table_(indexed_table), indexes_to_build_(indexes), ns_info_(ns_info) {</a>
<a name="ln573">  LOG_IF(DFATAL, indexes_to_build_.size() != 1)</a>
<a name="ln574">      &lt;&lt; &quot;As of Dec 2019, we only support &quot;</a>
<a name="ln575">      &lt;&lt; &quot;building one index at a time. indexes_to_build_.size() = &quot;</a>
<a name="ln576">      &lt;&lt; indexes_to_build_.size();</a>
<a name="ln577"> </a>
<a name="ln578">  std::ostringstream out;</a>
<a name="ln579">  out &lt;&lt; &quot;{ &quot;;</a>
<a name="ln580">  bool first = true;</a>
<a name="ln581">  for (const auto &amp;index_info : indexes_to_build_) {</a>
<a name="ln582">    if (!first) {</a>
<a name="ln583">      out &lt;&lt; &quot;, &quot;;</a>
<a name="ln584">    }</a>
<a name="ln585">    out &lt;&lt; master_-&gt;catalog_manager()-&gt;GetTableInfo(index_info.table_id())-&gt;name();</a>
<a name="ln586">    first = false;</a>
<a name="ln587">  }</a>
<a name="ln588">  out &lt;&lt; &quot; }&quot;;</a>
<a name="ln589">  index_ids_ = out.str();</a>
<a name="ln590"> </a>
<a name="ln591">  auto l = indexed_table_-&gt;LockForRead();</a>
<a name="ln592">  schema_version_ = indexed_table_-&gt;metadata().state().pb.version();</a>
<a name="ln593">  leader_term_ = master_-&gt;catalog_manager()-&gt;leader_ready_term();</a>
<a name="ln594">  const auto &amp;properties =</a>
<a name="ln595">      indexed_table_-&gt;metadata().state().pb.schema().table_properties();</a>
<a name="ln596">  if (properties.has_backfilling_timestamp() &amp;&amp;</a>
<a name="ln597">      read_time_for_backfill_.FromUint64(properties.backfilling_timestamp()).ok()) {</a>
<a name="ln598">    timestamp_chosen_.store(true, std::memory_order_release);</a>
<a name="ln599">    VLOG_WITH_PREFIX(1) &lt;&lt; &quot;Will be using &quot; &lt;&lt; read_time_for_backfill_</a>
<a name="ln600">                        &lt;&lt; &quot; for backfill&quot;;</a>
<a name="ln601">  } else {</a>
<a name="ln602">    read_time_for_backfill_ = HybridTime::kInvalid;</a>
<a name="ln603">    timestamp_chosen_.store(false, std::memory_order_release);</a>
<a name="ln604">  }</a>
<a name="ln605">  done_.store(false, std::memory_order_release);</a>
<a name="ln606">}</a>
<a name="ln607"> </a>
<a name="ln608">void BackfillTable::Launch() {</a>
<a name="ln609">  backfill_job_ = std::make_shared&lt;BackfillTableJob&gt;(shared_from_this());</a>
<a name="ln610">  backfill_job_-&gt;SetState(MonitoredTaskState::kRunning);</a>
<a name="ln611">  master_-&gt;catalog_manager()-&gt;jobs_tracker_-&gt;AddTask(backfill_job_);</a>
<a name="ln612">  if (!timestamp_chosen_.load(std::memory_order_acquire)) {</a>
<a name="ln613">    LaunchComputeSafeTimeForRead();</a>
<a name="ln614">  } else {</a>
<a name="ln615">    LaunchBackfill();</a>
<a name="ln616">  }</a>
<a name="ln617">}</a>
<a name="ln618"> </a>
<a name="ln619">void BackfillTable::LaunchComputeSafeTimeForRead() {</a>
<a name="ln620">  vector&lt;scoped_refptr&lt;TabletInfo&gt;&gt; tablets;</a>
<a name="ln621">  indexed_table_-&gt;GetAllTablets(&amp;tablets);</a>
<a name="ln622"> </a>
<a name="ln623">  num_tablets_.store(tablets.size(), std::memory_order_release);</a>
<a name="ln624">  tablets_pending_.store(tablets.size(), std::memory_order_release);</a>
<a name="ln625">  auto min_cutoff = master()-&gt;clock()-&gt;Now();</a>
<a name="ln626">  for (const scoped_refptr&lt;TabletInfo&gt;&amp; tablet : tablets) {</a>
<a name="ln627">    auto get_safetime = std::make_shared&lt;GetSafeTimeForTablet&gt;(</a>
<a name="ln628">        shared_from_this(), tablet, min_cutoff);</a>
<a name="ln629">    get_safetime-&gt;Launch();</a>
<a name="ln630">  }</a>
<a name="ln631">}</a>
<a name="ln632"> </a>
<a name="ln633">std::string BackfillTable::LogPrefix() const {</a>
<a name="ln634">  return Format(&quot;Backfill Index Table(s) $0 &quot;, index_ids_);</a>
<a name="ln635">}</a>
<a name="ln636"> </a>
<a name="ln637">std::string BackfillTable::description() const {</a>
<a name="ln638">  auto num_pending = tablets_pending_.load(std::memory_order_acquire);</a>
<a name="ln639">  auto num_tablets = num_tablets_.load(std::memory_order_acquire);</a>
<a name="ln640">  return Format(</a>
<a name="ln641">      &quot;Backfill Index Table(s) $0 : $1&quot;, index_ids_,</a>
<a name="ln642">      (timestamp_chosen()</a>
<a name="ln643">           ? (done() ? Format(&quot;Backfill $0/$1 tablets done&quot;, num_pending, num_tablets)</a>
<a name="ln644">                     : Format(&quot;Backfilling $0/$1 tablets&quot;, num_pending, num_tablets))</a>
<a name="ln645">           : Format(&quot;Waiting to GetSafeTime from $0/$1 tablets&quot;, num_pending, num_tablets)));</a>
<a name="ln646">}</a>
<a name="ln647"> </a>
<a name="ln648">const std::string BackfillTable::GetNamespaceName() const {</a>
<a name="ln649">  return ns_info_-&gt;name();</a>
<a name="ln650">}</a>
<a name="ln651"> </a>
<a name="ln652">Status BackfillTable::UpdateSafeTime(const Status&amp; s, HybridTime ht) {</a>
<a name="ln653">  if (!s.ok()) {</a>
<a name="ln654">    // Move on to ABORTED permission.</a>
<a name="ln655">    LOG_WITH_PREFIX(ERROR)</a>
<a name="ln656">        &lt;&lt; &quot;Failed backfill. Could not compute safe time for &quot;</a>
<a name="ln657">        &lt;&lt; yb::ToString(indexed_table_) &lt;&lt; s;</a>
<a name="ln658">    if (!timestamp_chosen_.exchange(true)) {</a>
<a name="ln659">      RETURN_NOT_OK_PREPEND(AlterTableStateToAbort(),</a>
<a name="ln660">                            &quot;Failed to mark backfill as failed. Abandoning.&quot;);</a>
<a name="ln661">    }</a>
<a name="ln662">    return Status::OK();</a>
<a name="ln663">  }</a>
<a name="ln664"> </a>
<a name="ln665">  // Need to guard this.</a>
<a name="ln666">  HybridTime read_timestamp;</a>
<a name="ln667">  {</a>
<a name="ln668">    std::lock_guard&lt;simple_spinlock&gt; l(mutex_);</a>
<a name="ln669">    VLOG(2) &lt;&lt; &quot; Updating read_time_for_backfill_ to max{ &quot;</a>
<a name="ln670">            &lt;&lt; read_time_for_backfill_.ToString() &lt;&lt; &quot;, &quot; &lt;&lt; ht.ToString()</a>
<a name="ln671">            &lt;&lt; &quot; }.&quot;;</a>
<a name="ln672">    read_time_for_backfill_.MakeAtLeast(ht);</a>
<a name="ln673">    read_timestamp = read_time_for_backfill_;</a>
<a name="ln674">  }</a>
<a name="ln675"> </a>
<a name="ln676">  // If OK then move on to doing backfill.</a>
<a name="ln677">  if (!timestamp_chosen() &amp;&amp; --tablets_pending_ == 0) {</a>
<a name="ln678">    LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Completed fetching SafeTime for the table &quot;</a>
<a name="ln679">                          &lt;&lt; yb::ToString(indexed_table_) &lt;&lt; &quot; will be using &quot;</a>
<a name="ln680">                          &lt;&lt; read_timestamp.ToString();</a>
<a name="ln681">    {</a>
<a name="ln682">      auto l = indexed_table_-&gt;LockForWrite();</a>
<a name="ln683">      l-&gt;mutable_data()</a>
<a name="ln684">          -&gt;pb.mutable_schema()</a>
<a name="ln685">          -&gt;mutable_table_properties()</a>
<a name="ln686">          -&gt;set_backfilling_timestamp(read_timestamp.ToUint64());</a>
<a name="ln687">      RETURN_NOT_OK_PREPEND(</a>
<a name="ln688">          master_-&gt;catalog_manager()-&gt;sys_catalog_-&gt;UpdateItem(</a>
<a name="ln689">              indexed_table_.get(), leader_term()),</a>
<a name="ln690">          &quot;Failed to persist backfilling timestamp. Abandoning.&quot;);</a>
<a name="ln691">      l-&gt;Commit();</a>
<a name="ln692">    }</a>
<a name="ln693">    VLOG_WITH_PREFIX(2) &lt;&lt; &quot;Saved &quot; &lt;&lt; read_timestamp</a>
<a name="ln694">                        &lt;&lt; &quot; as backfilling_timestamp&quot;;</a>
<a name="ln695">    timestamp_chosen_.store(true, std::memory_order_release);</a>
<a name="ln696">    LaunchBackfill();</a>
<a name="ln697">  }</a>
<a name="ln698">  return Status::OK();</a>
<a name="ln699">}</a>
<a name="ln700"> </a>
<a name="ln701">void BackfillTable::LaunchBackfill() {</a>
<a name="ln702">  VLOG_WITH_PREFIX(1) &lt;&lt; &quot;launching backfill with timestamp: &quot;</a>
<a name="ln703">                      &lt;&lt; read_time_for_backfill_;</a>
<a name="ln704">  vector&lt;scoped_refptr&lt;TabletInfo&gt;&gt; tablets;</a>
<a name="ln705">  indexed_table_-&gt;GetAllTablets(&amp;tablets);</a>
<a name="ln706"> </a>
<a name="ln707">  num_tablets_.store(tablets.size(), std::memory_order_release);</a>
<a name="ln708">  tablets_pending_.store(tablets.size(), std::memory_order_release);</a>
<a name="ln709">  for (const scoped_refptr&lt;TabletInfo&gt;&amp; tablet : tablets) {</a>
<a name="ln710">    auto backfill_tablet = std::make_shared&lt;BackfillTablet&gt;(shared_from_this(), tablet);</a>
<a name="ln711">    backfill_tablet-&gt;Launch();</a>
<a name="ln712">  }</a>
<a name="ln713">}</a>
<a name="ln714"> </a>
<a name="ln715">void BackfillTable::Done(const Status&amp; s) {</a>
<a name="ln716">  if (!s.ok()) {</a>
<a name="ln717">    // Move on to ABORTED permission.</a>
<a name="ln718">    LOG_WITH_PREFIX(ERROR) &lt;&lt; &quot;Failed to backfill the index &quot; &lt;&lt; s;</a>
<a name="ln719">    if (!done_.exchange(true)) {</a>
<a name="ln720">      WARN_NOT_OK(AlterTableStateToAbort(),</a>
<a name="ln721">                  &quot;Failed to mark backfill as failed.&quot;);</a>
<a name="ln722">    } else {</a>
<a name="ln723">      LOG_WITH_PREFIX(INFO)</a>
<a name="ln724">          &lt;&lt; &quot;Somebody else already aborted the index backfill.&quot;;</a>
<a name="ln725">    }</a>
<a name="ln726">    return;</a>
<a name="ln727">  }</a>
<a name="ln728"> </a>
<a name="ln729">  // If OK then move on to READ permissions.</a>
<a name="ln730">  if (!done() &amp;&amp; --tablets_pending_ == 0) {</a>
<a name="ln731">    LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Completed backfilling the index table.&quot;;</a>
<a name="ln732">    done_.store(true, std::memory_order_release);</a>
<a name="ln733">    WARN_NOT_OK(AlterTableStateToSuccess(), &quot;Failed to complete backfill.&quot;);</a>
<a name="ln734">  }</a>
<a name="ln735">}</a>
<a name="ln736"> </a>
<a name="ln737">Status BackfillTable::AlterTableStateToSuccess() {</a>
<a name="ln738">  const TableId&amp; index_table_id = indexes()[0].table_id();</a>
<a name="ln739">  RETURN_NOT_OK_PREPEND(</a>
<a name="ln740">      MultiStageAlterTable::UpdateIndexPermission(</a>
<a name="ln741">          master_-&gt;catalog_manager(),</a>
<a name="ln742">          indexed_table_,</a>
<a name="ln743">          {{index_table_id, INDEX_PERM_READ_WRITE_AND_DELETE}},</a>
<a name="ln744">          boost::none),</a>
<a name="ln745">      &quot;Could not update permission to &quot;</a>
<a name="ln746">      &quot;INDEX_PERM_READ_WRITE_AND_DELETE. Possible that the &quot;</a>
<a name="ln747">      &quot;master-leader has changed.&quot;);</a>
<a name="ln748"> </a>
<a name="ln749">  VLOG(1) &lt;&lt; &quot;Sending alter table requests to the Indexed table&quot;;</a>
<a name="ln750">  master_-&gt;catalog_manager()-&gt;SendAlterTableRequest(indexed_table_);</a>
<a name="ln751">  VLOG(1) &lt;&lt; &quot;DONE Sending alter table requests to the Indexed table&quot;;</a>
<a name="ln752">  RETURN_NOT_OK(AllowCompactionsToGCDeleteMarkers(index_table_id));</a>
<a name="ln753"> </a>
<a name="ln754">  VLOG(1) &lt;&lt; __func__ &lt;&lt; &quot; done backfill on &quot; &lt;&lt; indexed_table_-&gt;ToString()</a>
<a name="ln755">          &lt;&lt; &quot; for &quot; &lt;&lt; index_table_id;</a>
<a name="ln756">  indexed_table_-&gt;SetIsBackfilling(false);</a>
<a name="ln757">  backfill_job_-&gt;SetState(MonitoredTaskState::kComplete);</a>
<a name="ln758">  return ClearCheckpointStateInTablets();</a>
<a name="ln759">}</a>
<a name="ln760"> </a>
<a name="ln761">Status BackfillTable::AlterTableStateToAbort() {</a>
<a name="ln762">  const TableId&amp; index_table_id = indexes()[0].table_id();</a>
<a name="ln763">  RETURN_NOT_OK_PREPEND(</a>
<a name="ln764">      MultiStageAlterTable::UpdateIndexPermission(</a>
<a name="ln765">          master_-&gt;catalog_manager(), indexed_table_,</a>
<a name="ln766">          {{index_table_id, INDEX_PERM_WRITE_AND_DELETE_WHILE_REMOVING}}, boost::none),</a>
<a name="ln767">      &quot;Could not update permission to &quot;</a>
<a name="ln768">      &quot;INDEX_PERM_WRITE_AND_DELETE_WHILE_REMOVING. Possible that the &quot;</a>
<a name="ln769">      &quot;master-leader has changed.&quot;);</a>
<a name="ln770">  master_-&gt;catalog_manager()-&gt;SendAlterTableRequest(indexed_table_);</a>
<a name="ln771">  indexed_table_-&gt;SetIsBackfilling(false);</a>
<a name="ln772">  backfill_job_-&gt;SetState(MonitoredTaskState::kFailed);</a>
<a name="ln773">  return ClearCheckpointStateInTablets();</a>
<a name="ln774">}</a>
<a name="ln775"> </a>
<a name="ln776">Status BackfillTable::ClearCheckpointStateInTablets() {</a>
<a name="ln777">  vector&lt;scoped_refptr&lt;TabletInfo&gt;&gt; tablets;</a>
<a name="ln778">  indexed_table_-&gt;GetAllTablets(&amp;tablets);</a>
<a name="ln779">  std::vector&lt;TabletInfo*&gt; tablet_ptrs;</a>
<a name="ln780">  const auto&amp; idx_id = indexes()[0].table_id();</a>
<a name="ln781">  for (scoped_refptr&lt;TabletInfo&gt;&amp; tablet : tablets) {</a>
<a name="ln782">    tablet_ptrs.push_back(tablet.get());</a>
<a name="ln783">    tablet-&gt;mutable_metadata()-&gt;StartMutation();</a>
<a name="ln784">    tablet-&gt;mutable_metadata()-&gt;mutable_dirty()-&gt;pb.mutable_backfilled_until()-&gt;erase(idx_id);</a>
<a name="ln785">  }</a>
<a name="ln786">  RETURN_NOT_OK_PREPEND(</a>
<a name="ln787">      master()-&gt;catalog_manager()-&gt;sys_catalog()-&gt;UpdateItems(tablet_ptrs,</a>
<a name="ln788">                                                              leader_term()),</a>
<a name="ln789">      &quot;Could not persist that the table is done backfilling.&quot;);</a>
<a name="ln790">  for (scoped_refptr&lt;TabletInfo&gt;&amp; tablet : tablets) {</a>
<a name="ln791">    VLOG(2) &lt;&lt; &quot;Done backfilling the table. &quot; &lt;&lt; yb::ToString(tablet)</a>
<a name="ln792">            &lt;&lt; &quot; clearing backfilled_until&quot;;</a>
<a name="ln793">    tablet-&gt;mutable_metadata()-&gt;CommitMutation();</a>
<a name="ln794">  }</a>
<a name="ln795"> </a>
<a name="ln796">  {</a>
<a name="ln797">    auto l = indexed_table_-&gt;LockForWrite();</a>
<a name="ln798">    l-&gt;mutable_data()</a>
<a name="ln799">        -&gt;pb.mutable_schema()</a>
<a name="ln800">        -&gt;mutable_table_properties()</a>
<a name="ln801">        -&gt;clear_backfilling_timestamp();</a>
<a name="ln802">    RETURN_NOT_OK_PREPEND(master_-&gt;catalog_manager()-&gt;sys_catalog_-&gt;UpdateItem(</a>
<a name="ln803">                              indexed_table_.get(), leader_term()),</a>
<a name="ln804">                          &quot;Could not clear backfilling timestamp.&quot;);</a>
<a name="ln805">    l-&gt;Commit();</a>
<a name="ln806">  }</a>
<a name="ln807">  VLOG_WITH_PREFIX(2) &lt;&lt; &quot;Cleared backfilling timestamp.&quot;;</a>
<a name="ln808">  return Status::OK();</a>
<a name="ln809">}</a>
<a name="ln810"> </a>
<a name="ln811">Status BackfillTable::AllowCompactionsToGCDeleteMarkers(</a>
<a name="ln812">    const TableId &amp;index_table_id) {</a>
<a name="ln813">  DVLOG(3) &lt;&lt; __PRETTY_FUNCTION__;</a>
<a name="ln814">  scoped_refptr&lt;TableInfo&gt; index_table_info;</a>
<a name="ln815">  TableIdentifierPB index_table_id_pb;</a>
<a name="ln816">  index_table_id_pb.set_table_id(index_table_id);</a>
<a name="ln817">  RETURN_NOT_OK_PREPEND(</a>
<a name="ln818">      master_-&gt;catalog_manager()-&gt;FindTable(index_table_id_pb,</a>
<a name="ln819">                                            &amp;index_table_info),</a>
<a name="ln820">      yb::Format(&quot;Could not find table info for the index table $0 to enable &quot;</a>
<a name="ln821">                 &quot;compactions. &quot;</a>
<a name="ln822">                 &quot;This is ok in case somebody issued a delete index.&quot;,</a>
<a name="ln823">                 yb::ToString(index_table_id)));</a>
<a name="ln824"> </a>
<a name="ln825">  // Add a sleep here to wait until the Table is fully created.</a>
<a name="ln826">  bool is_ready = false;</a>
<a name="ln827">  bool first_run = true;</a>
<a name="ln828">  do {</a>
<a name="ln829">    if (!first_run) {</a>
<a name="ln830">      YB_LOG_EVERY_N_SECS(INFO, 1) &lt;&lt; &quot;Waiting for the previous alter table to &quot;</a>
<a name="ln831">                                      &quot;complete on the index table &quot;</a>
<a name="ln832">                                   &lt;&lt; yb::ToString(index_table_id);</a>
<a name="ln833">      SleepFor(</a>
<a name="ln834">          MonoDelta::FromMilliseconds(FLAGS_index_backfill_wait_for_alter_table_completion_ms));</a>
<a name="ln835">    }</a>
<a name="ln836">    first_run = false;</a>
<a name="ln837">    {</a>
<a name="ln838">      VLOG(2) &lt;&lt; __func__ &lt;&lt; &quot;: Trying to lock index table for Read&quot;;</a>
<a name="ln839">      auto l = index_table_info-&gt;LockForRead();</a>
<a name="ln840">      is_ready = (l-&gt;data().pb.state() == SysTablesEntryPB::RUNNING);</a>
<a name="ln841">    }</a>
<a name="ln842">    VLOG(2) &lt;&lt; __func__ &lt;&lt; &quot;: Unlocked index table for Read&quot;;</a>
<a name="ln843">  } while (!is_ready);</a>
<a name="ln844">  {</a>
<a name="ln845">    TRACE(&quot;Locking index table&quot;);</a>
<a name="ln846">    VLOG(2) &lt;&lt; __func__ &lt;&lt; &quot;: Trying to lock index table for Write&quot;;</a>
<a name="ln847">    auto l = index_table_info-&gt;LockForWrite();</a>
<a name="ln848">    VLOG(2) &lt;&lt; __func__ &lt;&lt; &quot;: locked index table for Write&quot;;</a>
<a name="ln849">    l-&gt;mutable_data()-&gt;pb.mutable_schema()-&gt;mutable_table_properties()-&gt;set_is_backfilling(false);</a>
<a name="ln850"> </a>
<a name="ln851">    // Update sys-catalog with the new indexed table info.</a>
<a name="ln852">    TRACE(&quot;Updating index table metadata on disk&quot;);</a>
<a name="ln853">    RETURN_NOT_OK_PREPEND(</a>
<a name="ln854">        master_-&gt;catalog_manager()-&gt;sys_catalog_-&gt;UpdateItem(</a>
<a name="ln855">            index_table_info.get(), leader_term()),</a>
<a name="ln856">        yb::Format(</a>
<a name="ln857">            &quot;Could not update index_table_info for $0 to enable compactions.&quot;,</a>
<a name="ln858">            index_table_id));</a>
<a name="ln859"> </a>
<a name="ln860">    // Update the in-memory state.</a>
<a name="ln861">    TRACE(&quot;Committing in-memory state&quot;);</a>
<a name="ln862">    l-&gt;Commit();</a>
<a name="ln863">  }</a>
<a name="ln864">  VLOG(2) &lt;&lt; __func__ &lt;&lt; &quot;: Unlocked index table for Read&quot;;</a>
<a name="ln865">  VLOG(1) &lt;&lt; &quot;Sending backfill done requests to the Index table&quot;;</a>
<a name="ln866">  RETURN_NOT_OK(SendRpcToAllowCompactionsToGCDeleteMarkers(index_table_info));</a>
<a name="ln867">  VLOG(1) &lt;&lt; &quot;DONE Sending backfill done requests to the Index table&quot;;</a>
<a name="ln868">  return Status::OK();</a>
<a name="ln869">}</a>
<a name="ln870"> </a>
<a name="ln871">Status BackfillTable::SendRpcToAllowCompactionsToGCDeleteMarkers(</a>
<a name="ln872">    const scoped_refptr&lt;TableInfo&gt; &amp;table) {</a>
<a name="ln873">  vector&lt;scoped_refptr&lt;TabletInfo&gt;&gt; tablets;</a>
<a name="ln874">  table-&gt;GetAllTablets(&amp;tablets);</a>
<a name="ln875"> </a>
<a name="ln876">  for (const scoped_refptr&lt;TabletInfo&gt;&amp; tablet : tablets) {</a>
<a name="ln877">    RETURN_NOT_OK(SendRpcToAllowCompactionsToGCDeleteMarkers(tablet));</a>
<a name="ln878">  }</a>
<a name="ln879">  return Status::OK();</a>
<a name="ln880">}</a>
<a name="ln881"> </a>
<a name="ln882">Status BackfillTable::SendRpcToAllowCompactionsToGCDeleteMarkers(</a>
<a name="ln883">    const scoped_refptr&lt;TabletInfo&gt; &amp;tablet) {</a>
<a name="ln884">  auto call = std::make_shared&lt;AsyncBackfillDone&gt;(master_, callback_pool_, tablet);</a>
<a name="ln885">  tablet-&gt;table()-&gt;AddTask(call);</a>
<a name="ln886">  RETURN_NOT_OK_PREPEND(</a>
<a name="ln887">      master_-&gt;catalog_manager()-&gt;ScheduleTask(call), &quot;Failed to send backfill done request&quot;);</a>
<a name="ln888">  return Status::OK();</a>
<a name="ln889">}</a>
<a name="ln890"> </a>
<a name="ln891">// -----------------------------------------------------------------------------------------------</a>
<a name="ln892">// BackfillTablet</a>
<a name="ln893">// -----------------------------------------------------------------------------------------------</a>
<a name="ln894">BackfillTablet::BackfillTablet(</a>
<a name="ln895">    std::shared_ptr&lt;BackfillTable&gt; backfill_table, const scoped_refptr&lt;TabletInfo&gt;&amp; tablet)</a>
<a name="ln896">    : backfill_table_(backfill_table), tablet_(tablet) {</a>
<a name="ln897">  {</a>
<a name="ln898">    auto l = tablet_-&gt;LockForRead();</a>
<a name="ln899">    const auto&amp; pb = tablet_-&gt;metadata().state().pb;</a>
<a name="ln900">    Partition::FromPB(pb.partition(), &amp;partition_);</a>
<a name="ln901">    DCHECK_EQ(backfill_table_-&gt;indexes().size(), 1);</a>
<a name="ln902">    const auto&amp; idx_id = backfill_table_-&gt;indexes()[0].table_id();</a>
<a name="ln903">    if (pb.backfilled_until().find(idx_id) != pb.backfilled_until().end()) {</a>
<a name="ln904">      next_row_to_backfill_ = pb.backfilled_until().at(idx_id);</a>
<a name="ln905">      done_.store(next_row_to_backfill_.empty(), std::memory_order_release);</a>
<a name="ln906">    }</a>
<a name="ln907">  }</a>
<a name="ln908">  if (!next_row_to_backfill_.empty()) {</a>
<a name="ln909">    VLOG(1) &lt;&lt; tablet_-&gt;ToString() &lt;&lt; &quot; resuming backfill from &quot;</a>
<a name="ln910">            &lt;&lt; yb::ToString(next_row_to_backfill_);</a>
<a name="ln911">  } else if (done()) {</a>
<a name="ln912">    VLOG(1) &lt;&lt; tablet_-&gt;ToString() &lt;&lt; &quot; backfill already done&quot;;</a>
<a name="ln913">  } else {</a>
<a name="ln914">    VLOG(1) &lt;&lt; tablet_-&gt;ToString() &lt;&lt; &quot; begining backfill from &quot;</a>
<a name="ln915">            &lt;&lt; &quot;&lt;start-of-the-tablet&gt;&quot;;</a>
<a name="ln916">  }</a>
<a name="ln917">}</a>
<a name="ln918"> </a>
<a name="ln919">void BackfillTablet::LaunchNextChunkOrDone() {</a>
<a name="ln920">  if (done()) {</a>
<a name="ln921">    backfill_table_-&gt;Done(Status::OK());</a>
<a name="ln922">  } else {</a>
<a name="ln923">    auto chunk = std::make_shared&lt;BackfillChunk&gt;(shared_from_this(),</a>
<a name="ln924">                                                 next_row_to_backfill_);</a>
<a name="ln925">    chunk-&gt;Launch();</a>
<a name="ln926">  }</a>
<a name="ln927">}</a>
<a name="ln928"> </a>
<a name="ln929">void BackfillTablet::Done(const Status&amp; status, const string&amp; next_row_key) {</a>
<a name="ln930">  if (!status.ok()) {</a>
<a name="ln931">    LOG(INFO) &lt;&lt; &quot;Failed to backfill the tablet &quot; &lt;&lt; yb::ToString(tablet_) &lt;&lt; status;</a>
<a name="ln932">    backfill_table_-&gt;Done(status);</a>
<a name="ln933">    return;</a>
<a name="ln934">  }</a>
<a name="ln935"> </a>
<a name="ln936">  next_row_to_backfill_ = next_row_key;</a>
<a name="ln937">  VLOG(2) &lt;&lt; &quot;Done backfilling the tablet &quot; &lt;&lt; yb::ToString(tablet_)</a>
<a name="ln938">          &lt;&lt; &quot; until &quot; &lt;&lt; yb::ToString(next_row_to_backfill_);</a>
<a name="ln939">  {</a>
<a name="ln940">    tablet_-&gt;mutable_metadata()-&gt;StartMutation();</a>
<a name="ln941">    for (const auto&amp; idx_info : backfill_table_-&gt;indexes()) {</a>
<a name="ln942">      tablet_-&gt;mutable_metadata()-&gt;mutable_dirty()-&gt;pb.mutable_backfilled_until()-&gt;insert(</a>
<a name="ln943">          {idx_info.table_id(), next_row_to_backfill_});</a>
<a name="ln944">    }</a>
<a name="ln945">    WARN_NOT_OK(</a>
<a name="ln946">        backfill_table_-&gt;master()-&gt;catalog_manager()-&gt;sys_catalog()-&gt;UpdateItem(</a>
<a name="ln947">            tablet_.get(), backfill_table_-&gt;leader_term()),</a>
<a name="ln948">        &quot;Could not persist that the tablet is done backfilling.&quot;);</a>
<a name="ln949">    tablet_-&gt;mutable_metadata()-&gt;CommitMutation();</a>
<a name="ln950">  }</a>
<a name="ln951"> </a>
<a name="ln952">  // This is the last chunk.</a>
<a name="ln953">  if (next_row_to_backfill_.empty()) {</a>
<a name="ln954">    LOG(INFO) &lt;&lt; &quot;Done backfilling the tablet &quot; &lt;&lt; yb::ToString(tablet_);</a>
<a name="ln955">    done_.store(true, std::memory_order_release);</a>
<a name="ln956">  }</a>
<a name="ln957"> </a>
<a name="ln958">  LaunchNextChunkOrDone();</a>
<a name="ln959">}</a>
<a name="ln960"> </a>
<a name="ln961">// -----------------------------------------------------------------------------------------------</a>
<a name="ln962">// GetSafeTimeForTablet</a>
<a name="ln963">// -----------------------------------------------------------------------------------------------</a>
<a name="ln964"> </a>
<a name="ln965">void GetSafeTimeForTablet::Launch() {</a>
<a name="ln966">  tablet_-&gt;table()-&gt;AddTask(shared_from_this());</a>
<a name="ln967">  Status status = Run();</a>
<a name="ln968">  // Need to print this after Run() because that's where it picks the TS which description()</a>
<a name="ln969">  // needs.</a>
<a name="ln970">  if (status.ok()) {</a>
<a name="ln971">    VLOG(3) &lt;&lt; &quot;Started GetSafeTimeForTablet : &quot; &lt;&lt; this-&gt;description();</a>
<a name="ln972">  } else {</a>
<a name="ln973">    LOG(WARNING) &lt;&lt; Substitute(&quot;Failed to send GetSafeTime request for $0. &quot;,</a>
<a name="ln974">                               tablet_-&gt;ToString())</a>
<a name="ln975">                 &lt;&lt; status;</a>
<a name="ln976">  }</a>
<a name="ln977">}</a>
<a name="ln978"> </a>
<a name="ln979">bool GetSafeTimeForTablet::SendRequest(int attempt) {</a>
<a name="ln980">  VLOG(1) &lt;&lt; __PRETTY_FUNCTION__;</a>
<a name="ln981">  tserver::GetSafeTimeRequestPB req;</a>
<a name="ln982">  req.set_dest_uuid(permanent_uuid());</a>
<a name="ln983">  req.set_tablet_id(tablet_-&gt;tablet_id());</a>
<a name="ln984">  auto now = backfill_table_-&gt;master()-&gt;clock()-&gt;Now().ToUint64();</a>
<a name="ln985">  req.set_min_hybrid_time_for_backfill(min_cutoff_.ToUint64());</a>
<a name="ln986">  req.set_propagated_hybrid_time(now);</a>
<a name="ln987"> </a>
<a name="ln988">  ts_admin_proxy_-&gt;GetSafeTimeAsync(req, &amp;resp_, &amp;rpc_, BindRpcCallback());</a>
<a name="ln989">  VLOG(1) &lt;&lt; &quot;Send &quot; &lt;&lt; description() &lt;&lt; &quot; to &quot; &lt;&lt; permanent_uuid()</a>
<a name="ln990">          &lt;&lt; &quot; (attempt &quot; &lt;&lt; attempt &lt;&lt; &quot;):\n&quot;</a>
<a name="ln991">          &lt;&lt; req.DebugString();</a>
<a name="ln992">  return true;</a>
<a name="ln993">}</a>
<a name="ln994"> </a>
<a name="ln995">void GetSafeTimeForTablet::HandleResponse(int attempt) {</a>
<a name="ln996">  VLOG(1) &lt;&lt; __PRETTY_FUNCTION__;</a>
<a name="ln997">  Status status = Status::OK();</a>
<a name="ln998">  if (resp_.has_error()) {</a>
<a name="ln999">    status = StatusFromPB(resp_.error().status());</a>
<a name="ln1000"> </a>
<a name="ln1001">    // Do not retry on a fatal error</a>
<a name="ln1002">    switch (resp_.error().code()) {</a>
<a name="ln1003">      case TabletServerErrorPB::TABLET_NOT_FOUND:</a>
<a name="ln1004">      case TabletServerErrorPB::MISMATCHED_SCHEMA:</a>
<a name="ln1005">      case TabletServerErrorPB::TABLET_HAS_A_NEWER_SCHEMA:</a>
<a name="ln1006">      case TabletServerErrorPB::OPERATION_NOT_SUPPORTED:</a>
<a name="ln1007">        LOG(WARNING) &lt;&lt; &quot;TS &quot; &lt;&lt; permanent_uuid() &lt;&lt; &quot;: GetSafeTime failed for tablet &quot;</a>
<a name="ln1008">                     &lt;&lt; tablet_-&gt;ToString() &lt;&lt; &quot; no further retry: &quot; &lt;&lt; status;</a>
<a name="ln1009">        TransitionToFailedState(MonitoredTaskState::kRunning, status);</a>
<a name="ln1010">        break;</a>
<a name="ln1011">      default:</a>
<a name="ln1012">        LOG(WARNING) &lt;&lt; &quot;TS &quot; &lt;&lt; permanent_uuid() &lt;&lt; &quot;: GetSafeTime failed for tablet &quot;</a>
<a name="ln1013">                     &lt;&lt; tablet_-&gt;ToString() &lt;&lt; &quot;: &quot; &lt;&lt; status &lt;&lt; &quot; code &quot;&lt;&lt; resp_.error().code();</a>
<a name="ln1014">        break;</a>
<a name="ln1015">    }</a>
<a name="ln1016">  } else {</a>
<a name="ln1017">    TransitionToCompleteState();</a>
<a name="ln1018">    VLOG(1) &lt;&lt; &quot;TS &quot; &lt;&lt; permanent_uuid() &lt;&lt; &quot;: GetSafeTime complete on tablet &quot;</a>
<a name="ln1019">            &lt;&lt; tablet_-&gt;ToString();</a>
<a name="ln1020">  }</a>
<a name="ln1021"> </a>
<a name="ln1022">  server::UpdateClock(resp_, master_-&gt;clock());</a>
<a name="ln1023">}</a>
<a name="ln1024"> </a>
<a name="ln1025">void GetSafeTimeForTablet::UnregisterAsyncTaskCallback() {</a>
<a name="ln1026">  Status status;</a>
<a name="ln1027">  HybridTime safe_time;</a>
<a name="ln1028">  if (resp_.has_error()) {</a>
<a name="ln1029">    status = StatusFromPB(resp_.error().status());</a>
<a name="ln1030">    VLOG(3) &lt;&lt; &quot;GetSafeTime for &quot; &lt;&lt; tablet_-&gt;ToString() &lt;&lt; &quot; got an error. Returning &quot;</a>
<a name="ln1031">            &lt;&lt; safe_time;</a>
<a name="ln1032">  } else if (state() != MonitoredTaskState::kComplete) {</a>
<a name="ln1033">    status = STATUS_SUBSTITUTE(InternalError, &quot;$0 in state $1&quot;, description(),</a>
<a name="ln1034">                               ToString(state()));</a>
<a name="ln1035">  } else {</a>
<a name="ln1036">    safe_time = HybridTime(resp_.safe_time());</a>
<a name="ln1037">    if (safe_time.is_special()) {</a>
<a name="ln1038">      LOG(ERROR) &lt;&lt; &quot;GetSafeTime for &quot; &lt;&lt; tablet_-&gt;ToString() &lt;&lt; &quot; got &quot; &lt;&lt; safe_time;</a>
<a name="ln1039">    } else {</a>
<a name="ln1040">      VLOG(3) &lt;&lt; &quot;GetSafeTime for &quot; &lt;&lt; tablet_-&gt;ToString() &lt;&lt; &quot; got &quot; &lt;&lt; safe_time;</a>
<a name="ln1041">    }</a>
<a name="ln1042">  }</a>
<a name="ln1043">  WARN_NOT_OK(backfill_table_-&gt;UpdateSafeTime(status, safe_time),</a>
<a name="ln1044">    &quot;Could not UpdateSafeTime&quot;);</a>
<a name="ln1045">}</a>
<a name="ln1046"> </a>
<a name="ln1047">// -----------------------------------------------------------------------------------------------</a>
<a name="ln1048">// BackfillChunk</a>
<a name="ln1049">// -----------------------------------------------------------------------------------------------</a>
<a name="ln1050">void BackfillChunk::Launch() {</a>
<a name="ln1051">  backfill_tablet_-&gt;tablet()-&gt;table()-&gt;AddTask(shared_from_this());</a>
<a name="ln1052">  Status status = Run();</a>
<a name="ln1053">  WARN_NOT_OK(</a>
<a name="ln1054">      status, Substitute(</a>
<a name="ln1055">                  &quot;Failed to send backfill Chunk request for $0&quot;,</a>
<a name="ln1056">                  backfill_tablet_-&gt;tablet().get()-&gt;ToString()));</a>
<a name="ln1057"> </a>
<a name="ln1058">  // Need to print this after Run() because that's where it picks the TS which description()</a>
<a name="ln1059">  // needs.</a>
<a name="ln1060">  if (status.ok()) {</a>
<a name="ln1061">    LOG(INFO) &lt;&lt; &quot;Started BackfillChunk : &quot; &lt;&lt; this-&gt;description();</a>
<a name="ln1062">  }</a>
<a name="ln1063">}</a>
<a name="ln1064"> </a>
<a name="ln1065">MonoTime BackfillChunk::ComputeDeadline() {</a>
<a name="ln1066">  MonoTime timeout = MonoTime::Now();</a>
<a name="ln1067">  timeout.AddDelta(MonoDelta::FromMilliseconds(FLAGS_index_backfill_rpc_timeout_ms));</a>
<a name="ln1068">  return MonoTime::Earliest(timeout, deadline_);</a>
<a name="ln1069">}</a>
<a name="ln1070"> </a>
<a name="ln1071">int BackfillChunk::num_max_retries() {</a>
<a name="ln1072">  return FLAGS_index_backfill_rpc_max_retries;</a>
<a name="ln1073">}</a>
<a name="ln1074"> </a>
<a name="ln1075">int BackfillChunk::max_delay_ms() {</a>
<a name="ln1076">  return FLAGS_index_backfill_rpc_max_delay_ms;</a>
<a name="ln1077">}</a>
<a name="ln1078"> </a>
<a name="ln1079">bool BackfillChunk::SendRequest(int attempt) {</a>
<a name="ln1080">  VLOG(1) &lt;&lt; __PRETTY_FUNCTION__;</a>
<a name="ln1081">  tserver::BackfillIndexRequestPB req;</a>
<a name="ln1082">  req.set_dest_uuid(permanent_uuid());</a>
<a name="ln1083">  req.set_tablet_id(backfill_tablet_-&gt;tablet()-&gt;tablet_id());</a>
<a name="ln1084">  req.set_read_at_hybrid_time(backfill_tablet_-&gt;read_time_for_backfill().ToUint64());</a>
<a name="ln1085">  req.set_schema_version(backfill_tablet_-&gt;schema_version());</a>
<a name="ln1086">  req.set_start_key(start_key_);</a>
<a name="ln1087">  if (backfill_tablet_-&gt;tablet()-&gt;table()-&gt;GetTableType() == TableType::PGSQL_TABLE_TYPE) {</a>
<a name="ln1088">    req.set_namespace_name(backfill_tablet_-&gt;GetNamespaceName());</a>
<a name="ln1089">  }</a>
<a name="ln1090">  for (const IndexInfoPB&amp; idx_info : backfill_tablet_-&gt;indexes()) {</a>
<a name="ln1091">    req.add_indexes()-&gt;CopyFrom(idx_info);</a>
<a name="ln1092">  }</a>
<a name="ln1093">  req.set_propagated_hybrid_time(backfill_tablet_-&gt;master()-&gt;clock()-&gt;Now().ToUint64());</a>
<a name="ln1094"> </a>
<a name="ln1095">  ts_admin_proxy_-&gt;BackfillIndexAsync(req, &amp;resp_, &amp;rpc_, BindRpcCallback());</a>
<a name="ln1096">  VLOG(1) &lt;&lt; &quot;Send &quot; &lt;&lt; description() &lt;&lt; &quot; to &quot; &lt;&lt; permanent_uuid()</a>
<a name="ln1097">          &lt;&lt; &quot; (attempt &quot; &lt;&lt; attempt &lt;&lt; &quot;):\n&quot;</a>
<a name="ln1098">          &lt;&lt; req.DebugString();</a>
<a name="ln1099">  return true;</a>
<a name="ln1100">}</a>
<a name="ln1101"> </a>
<a name="ln1102">void BackfillChunk::HandleResponse(int attempt) {</a>
<a name="ln1103">  VLOG(1) &lt;&lt; __PRETTY_FUNCTION__;</a>
<a name="ln1104">  Status status;</a>
<a name="ln1105">  if (resp_.has_error()) {</a>
<a name="ln1106">    status = StatusFromPB(resp_.error().status());</a>
<a name="ln1107"> </a>
<a name="ln1108">    // Do not retry on a fatal error</a>
<a name="ln1109">    switch (resp_.error().code()) {</a>
<a name="ln1110">      case TabletServerErrorPB::TABLET_NOT_FOUND:</a>
<a name="ln1111">      case TabletServerErrorPB::MISMATCHED_SCHEMA:</a>
<a name="ln1112">      case TabletServerErrorPB::TABLET_HAS_A_NEWER_SCHEMA:</a>
<a name="ln1113">      case TabletServerErrorPB::OPERATION_NOT_SUPPORTED:</a>
<a name="ln1114">        LOG(WARNING) &lt;&lt; &quot;TS &quot; &lt;&lt; permanent_uuid() &lt;&lt; &quot;: backfill failed for tablet &quot;</a>
<a name="ln1115">                     &lt;&lt; backfill_tablet_-&gt;tablet()-&gt;ToString()</a>
<a name="ln1116">                     &lt;&lt; &quot; no further retry: &quot; &lt;&lt; status;</a>
<a name="ln1117">        TransitionToFailedState(MonitoredTaskState::kRunning, status);</a>
<a name="ln1118">        break;</a>
<a name="ln1119">      default:</a>
<a name="ln1120">        LOG(WARNING) &lt;&lt; &quot;TS &quot; &lt;&lt; permanent_uuid() &lt;&lt; &quot;: backfill failed for tablet &quot;</a>
<a name="ln1121">                     &lt;&lt; backfill_tablet_-&gt;tablet()-&gt;ToString() &lt;&lt; &quot;: &quot; &lt;&lt; status.ToString()</a>
<a name="ln1122">                     &lt;&lt; &quot; code &quot; &lt;&lt; resp_.error().code();</a>
<a name="ln1123">        break;</a>
<a name="ln1124">    }</a>
<a name="ln1125">  } else {</a>
<a name="ln1126">    TransitionToCompleteState();</a>
<a name="ln1127">    VLOG(1) &lt;&lt; &quot;TS &quot; &lt;&lt; permanent_uuid() &lt;&lt; &quot;: backfill complete on tablet &quot;</a>
<a name="ln1128">            &lt;&lt; backfill_tablet_-&gt;tablet()-&gt;ToString();</a>
<a name="ln1129">  }</a>
<a name="ln1130"> </a>
<a name="ln1131">  server::UpdateClock(resp_, master_-&gt;clock());</a>
<a name="ln1132">}</a>
<a name="ln1133"> </a>
<a name="ln1134">void BackfillChunk::UnregisterAsyncTaskCallback() {</a>
<a name="ln1135">  Status status;</a>
<a name="ln1136">  if (resp_.has_error()) {</a>
<a name="ln1137">    status = StatusFromPB(resp_.error().status());</a>
<a name="ln1138">  } else if (state() != MonitoredTaskState::kComplete) {</a>
<a name="ln1139">    status = STATUS_SUBSTITUTE(InternalError, &quot;$0 in state $1&quot;, description(),</a>
<a name="ln1140">                               ToString(state()));</a>
<a name="ln1141">  }</a>
<a name="ln1142">  backfill_tablet_-&gt;Done(status, resp_.backfilled_until());</a>
<a name="ln1143">}</a>
<a name="ln1144"> </a>
<a name="ln1145">}  // namespace master</a>
<a name="ln1146">}  // namespace yb</a>

</code></pre>
<div class="balloon" rel="221"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="228"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="241"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="284"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="287"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="291"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="332"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="352"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="356"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="371"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="420"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="423"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="431"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="434"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="441"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="448"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="476"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="501"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="514"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="516"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="539"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="573"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="599"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="669"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="693"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="702"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="749"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="751"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="754"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="791"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="807"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="813"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="838"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="842"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="846"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="848"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="864"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="865"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="867"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="909"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="912"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="914"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="937"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="971"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="980"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="989"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="996"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1018"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1030"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1040"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1080"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1096"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1103"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1127"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
