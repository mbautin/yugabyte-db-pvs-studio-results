
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>metrics.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Licensed to the Apache Software Foundation (ASF) under one</a>
<a name="ln2">// or more contributor license agreements.  See the NOTICE file</a>
<a name="ln3">// distributed with this work for additional information</a>
<a name="ln4">// regarding copyright ownership.  The ASF licenses this file</a>
<a name="ln5">// to you under the Apache License, Version 2.0 (the</a>
<a name="ln6">// &quot;License&quot;); you may not use this file except in compliance</a>
<a name="ln7">// with the License.  You may obtain a copy of the License at</a>
<a name="ln8">//</a>
<a name="ln9">//   http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln10">//</a>
<a name="ln11">// Unless required by applicable law or agreed to in writing,</a>
<a name="ln12">// software distributed under the License is distributed on an</a>
<a name="ln13">// &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</a>
<a name="ln14">// KIND, either express or implied.  See the License for the</a>
<a name="ln15">// specific language governing permissions and limitations</a>
<a name="ln16">// under the License.</a>
<a name="ln17">//</a>
<a name="ln18">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln19">//</a>
<a name="ln20">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln21">//</a>
<a name="ln22">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln23">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln24">//</a>
<a name="ln25">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln26">//</a>
<a name="ln27">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln28">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln29">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln30">// under the License.</a>
<a name="ln31">//</a>
<a name="ln32">#include &quot;yb/util/metrics.h&quot;</a>
<a name="ln33"> </a>
<a name="ln34">#include &lt;iostream&gt;</a>
<a name="ln35">#include &lt;map&gt;</a>
<a name="ln36">#include &lt;regex&gt;</a>
<a name="ln37">#include &lt;set&gt;</a>
<a name="ln38"> </a>
<a name="ln39">#include &lt;gflags/gflags.h&gt;</a>
<a name="ln40"> </a>
<a name="ln41">#include &quot;yb/gutil/atomicops.h&quot;</a>
<a name="ln42">#include &quot;yb/gutil/casts.h&quot;</a>
<a name="ln43">#include &quot;yb/gutil/map-util.h&quot;</a>
<a name="ln44">#include &quot;yb/gutil/singleton.h&quot;</a>
<a name="ln45">#include &quot;yb/gutil/stl_util.h&quot;</a>
<a name="ln46">#include &quot;yb/gutil/strings/substitute.h&quot;</a>
<a name="ln47">#include &quot;yb/util/flag_tags.h&quot;</a>
<a name="ln48">#include &quot;yb/util/hdr_histogram.h&quot;</a>
<a name="ln49">#include &quot;yb/util/histogram.pb.h&quot;</a>
<a name="ln50">#include &quot;yb/util/jsonwriter.h&quot;</a>
<a name="ln51">#include &quot;yb/util/locks.h&quot;</a>
<a name="ln52">#include &quot;yb/util/status.h&quot;</a>
<a name="ln53">#include &quot;yb/util/logging.h&quot;</a>
<a name="ln54"> </a>
<a name="ln55">DEFINE_int32(metrics_retirement_age_ms, 120 * 1000,</a>
<a name="ln56">             &quot;The minimum number of milliseconds a metric will be kept for after it is &quot;</a>
<a name="ln57">             &quot;no longer active. (Advanced option)&quot;);</a>
<a name="ln58">TAG_FLAG(metrics_retirement_age_ms, runtime);</a>
<a name="ln59">TAG_FLAG(metrics_retirement_age_ms, advanced);</a>
<a name="ln60"> </a>
<a name="ln61">// TODO: changed to empty string and add logic to get this from cluster_uuid in case empty.</a>
<a name="ln62">DEFINE_string(metric_node_name, &quot;DEFAULT_NODE_NAME&quot;,</a>
<a name="ln63">              &quot;Value to use as node name for metrics reporting&quot;);</a>
<a name="ln64"> </a>
<a name="ln65">DEFINE_bool(expose_metric_histogram_percentiles, true,</a>
<a name="ln66">            &quot;Should we expose the percentiles information for metrics histograms.&quot;);</a>
<a name="ln67"> </a>
<a name="ln68">// Process/server-wide metrics should go into the 'server' entity.</a>
<a name="ln69">// More complex applications will define other entities.</a>
<a name="ln70">METRIC_DEFINE_entity(server);</a>
<a name="ln71"> </a>
<a name="ln72">namespace yb {</a>
<a name="ln73"> </a>
<a name="ln74">using std::string;</a>
<a name="ln75">using std::vector;</a>
<a name="ln76">using strings::Substitute;</a>
<a name="ln77"> </a>
<a name="ln78">//</a>
<a name="ln79">// MetricUnit</a>
<a name="ln80">//</a>
<a name="ln81"> </a>
<a name="ln82">const char* MetricUnit::Name(Type unit) {</a>
<a name="ln83">  switch (unit) {</a>
<a name="ln84">    case kCacheHits:</a>
<a name="ln85">      return &quot;hits&quot;;</a>
<a name="ln86">    case kCacheQueries:</a>
<a name="ln87">      return &quot;queries&quot;;</a>
<a name="ln88">    case kBytes:</a>
<a name="ln89">      return &quot;bytes&quot;;</a>
<a name="ln90">    case kRequests:</a>
<a name="ln91">      return &quot;requests&quot;;</a>
<a name="ln92">    case kEntries:</a>
<a name="ln93">      return &quot;entries&quot;;</a>
<a name="ln94">    case kRows:</a>
<a name="ln95">      return &quot;rows&quot;;</a>
<a name="ln96">    case kCells:</a>
<a name="ln97">      return &quot;cells&quot;;</a>
<a name="ln98">    case kConnections:</a>
<a name="ln99">      return &quot;connections&quot;;</a>
<a name="ln100">    case kOperations:</a>
<a name="ln101">      return &quot;operations&quot;;</a>
<a name="ln102">    case kProbes:</a>
<a name="ln103">      return &quot;probes&quot;;</a>
<a name="ln104">    case kNanoseconds:</a>
<a name="ln105">      return &quot;nanoseconds&quot;;</a>
<a name="ln106">    case kMicroseconds:</a>
<a name="ln107">      return &quot;microseconds&quot;;</a>
<a name="ln108">    case kMilliseconds:</a>
<a name="ln109">      return &quot;milliseconds&quot;;</a>
<a name="ln110">    case kSeconds:</a>
<a name="ln111">      return &quot;seconds&quot;;</a>
<a name="ln112">    case kThreads:</a>
<a name="ln113">      return &quot;threads&quot;;</a>
<a name="ln114">    case kTransactions:</a>
<a name="ln115">      return &quot;transactions&quot;;</a>
<a name="ln116">    case kUnits:</a>
<a name="ln117">      return &quot;units&quot;;</a>
<a name="ln118">    case kMaintenanceOperations:</a>
<a name="ln119">      return &quot;operations&quot;;</a>
<a name="ln120">    case kBlocks:</a>
<a name="ln121">      return &quot;blocks&quot;;</a>
<a name="ln122">    case kLogBlockContainers:</a>
<a name="ln123">      return &quot;log block containers&quot;;</a>
<a name="ln124">    case kTasks:</a>
<a name="ln125">      return &quot;tasks&quot;;</a>
<a name="ln126">    case kMessages:</a>
<a name="ln127">      return &quot;messages&quot;;</a>
<a name="ln128">    case kContextSwitches:</a>
<a name="ln129">      return &quot;context switches&quot;;</a>
<a name="ln130">    default:</a>
<a name="ln131">      return &quot;UNKNOWN UNIT&quot;;</a>
<a name="ln132">  }</a>
<a name="ln133">}</a>
<a name="ln134"> </a>
<a name="ln135">//</a>
<a name="ln136">// MetricType</a>
<a name="ln137">//</a>
<a name="ln138"> </a>
<a name="ln139">const char* const MetricType::kGaugeType = &quot;gauge&quot;;</a>
<a name="ln140">const char* const MetricType::kCounterType = &quot;counter&quot;;</a>
<a name="ln141">const char* const MetricType::kHistogramType = &quot;histogram&quot;;</a>
<a name="ln142">const char* MetricType::Name(MetricType::Type type) {</a>
<a name="ln143">  switch (type) {</a>
<a name="ln144">    case kGauge:</a>
<a name="ln145">      return kGaugeType;</a>
<a name="ln146">    case kCounter:</a>
<a name="ln147">      return kCounterType;</a>
<a name="ln148">    case kHistogram:</a>
<a name="ln149">      return kHistogramType;</a>
<a name="ln150">    default:</a>
<a name="ln151">      return &quot;UNKNOWN TYPE&quot;;</a>
<a name="ln152">  }</a>
<a name="ln153">}</a>
<a name="ln154"> </a>
<a name="ln155">namespace {</a>
<a name="ln156"> </a>
<a name="ln157">const char* MetricLevelName(MetricLevel level) {</a>
<a name="ln158">  switch (level) {</a>
<a name="ln159">    case MetricLevel::kDebug:</a>
<a name="ln160">      return &quot;debug&quot;;</a>
<a name="ln161">    case MetricLevel::kInfo:</a>
<a name="ln162">      return &quot;info&quot;;</a>
<a name="ln163">    case MetricLevel::kWarn:</a>
<a name="ln164">      return &quot;warn&quot;;</a>
<a name="ln165">    default:</a>
<a name="ln166">      return &quot;UNKNOWN LEVEL&quot;;</a>
<a name="ln167">  }</a>
<a name="ln168">}</a>
<a name="ln169"> </a>
<a name="ln170">} // anonymous namespace</a>
<a name="ln171"> </a>
<a name="ln172">//</a>
<a name="ln173">// MetricEntityPrototype</a>
<a name="ln174">//</a>
<a name="ln175"> </a>
<a name="ln176">MetricEntityPrototype::MetricEntityPrototype(const char* name)</a>
<a name="ln177">  : name_(name) {</a>
<a name="ln178">  MetricPrototypeRegistry::get()-&gt;AddEntity(this);</a>
<a name="ln179">}</a>
<a name="ln180"> </a>
<a name="ln181">MetricEntityPrototype::~MetricEntityPrototype() {</a>
<a name="ln182">}</a>
<a name="ln183"> </a>
<a name="ln184">scoped_refptr&lt;MetricEntity&gt; MetricEntityPrototype::Instantiate(</a>
<a name="ln185">    MetricRegistry* registry,</a>
<a name="ln186">    const std::string&amp; id,</a>
<a name="ln187">    const MetricEntity::AttributeMap&amp; initial_attrs) const {</a>
<a name="ln188">  return registry-&gt;FindOrCreateEntity(this, id, initial_attrs);</a>
<a name="ln189">}</a>
<a name="ln190"> </a>
<a name="ln191"> </a>
<a name="ln192">//</a>
<a name="ln193">// MetricEntity</a>
<a name="ln194">//</a>
<a name="ln195"> </a>
<a name="ln196">MetricEntity::MetricEntity(const MetricEntityPrototype* prototype,</a>
<a name="ln197">                           std::string id, AttributeMap attributes)</a>
<a name="ln198">    : prototype_(prototype),</a>
<a name="ln199">      id_(std::move(id)),</a>
<a name="ln200">      attributes_(std::move(attributes)) {</a>
<a name="ln201">}</a>
<a name="ln202"> </a>
<a name="ln203">MetricEntity::~MetricEntity() {</a>
<a name="ln204">}</a>
<a name="ln205"> </a>
<a name="ln206">const std::regex&amp; PrometheusNameRegex() {</a>
<a name="ln207">  static const std::regex result(&quot;[a-zA-Z_:][a-zA-Z0-9_:]*&quot;);</a>
<a name="ln208">  return result;</a>
<a name="ln209">}</a>
<a name="ln210"> </a>
<a name="ln211">void MetricEntity::CheckInstantiation(const MetricPrototype* proto) const {</a>
<a name="ln212">  CHECK_STREQ(prototype_-&gt;name(), proto-&gt;entity_type())</a>
<a name="ln213">    &lt;&lt; &quot;Metric &quot; &lt;&lt; proto-&gt;name() &lt;&lt; &quot; may not be instantiated entity of type &quot;</a>
<a name="ln214">    &lt;&lt; prototype_-&gt;name() &lt;&lt; &quot; (expected: &quot; &lt;&lt; proto-&gt;entity_type() &lt;&lt; &quot;)&quot;;</a>
<a name="ln215">  DCHECK(regex_match(proto-&gt;name(), PrometheusNameRegex()))</a>
<a name="ln216">      &lt;&lt; &quot;Metric name is not compatible with Prometheus: &quot; &lt;&lt; proto-&gt;name();</a>
<a name="ln217">}</a>
<a name="ln218"> </a>
<a name="ln219">scoped_refptr&lt;Metric&gt; MetricEntity::FindOrNull(const MetricPrototype&amp; prototype) const {</a>
<a name="ln220">  std::lock_guard&lt;simple_spinlock&gt; l(lock_);</a>
<a name="ln221">  return FindPtrOrNull(metric_map_, &amp;prototype);</a>
<a name="ln222">}</a>
<a name="ln223"> </a>
<a name="ln224">namespace {</a>
<a name="ln225"> </a>
<a name="ln226">bool MatchMetricInList(const string&amp; metric_name,</a>
<a name="ln227">                       const vector&lt;string&gt;&amp; match_params) {</a>
<a name="ln228">  for (const string&amp; param : match_params) {</a>
<a name="ln229">    // Handle wildcard.</a>
<a name="ln230">    if (param == &quot;*&quot;) return true;</a>
<a name="ln231">    // The parameter is a substring match of the metric name.</a>
<a name="ln232">    if (metric_name.find(param) != std::string::npos) {</a>
<a name="ln233">      return true;</a>
<a name="ln234">    }</a>
<a name="ln235">  }</a>
<a name="ln236">  return false;</a>
<a name="ln237">}</a>
<a name="ln238"> </a>
<a name="ln239">} // anonymous namespace</a>
<a name="ln240"> </a>
<a name="ln241"> </a>
<a name="ln242">Status MetricEntity::WriteAsJson(JsonWriter* writer,</a>
<a name="ln243">                                 const vector&lt;string&gt;&amp; requested_metrics,</a>
<a name="ln244">                                 const MetricJsonOptions&amp; opts) const {</a>
<a name="ln245">  bool select_all = MatchMetricInList(id(), requested_metrics);</a>
<a name="ln246"> </a>
<a name="ln247">  // We want the keys to be in alphabetical order when printing, so we use an ordered map here.</a>
<a name="ln248">  typedef std::map&lt;const char*, scoped_refptr&lt;Metric&gt; &gt; OrderedMetricMap;</a>
<a name="ln249">  OrderedMetricMap metrics;</a>
<a name="ln250">  AttributeMap attrs;</a>
<a name="ln251">  std::vector&lt;ExternalJsonMetricsCb&gt; external_metrics_cbs;</a>
<a name="ln252">  {</a>
<a name="ln253">    // Snapshot the metrics, attributes &amp; external metrics callbacks in this metrics entity. (Note:</a>
<a name="ln254">    // this is not guaranteed to be a consistent snapshot).</a>
<a name="ln255">    std::lock_guard&lt;simple_spinlock&gt; l(lock_);</a>
<a name="ln256">    attrs = attributes_;</a>
<a name="ln257">    external_metrics_cbs = external_json_metrics_cbs_;</a>
<a name="ln258">    for (const MetricMap::value_type&amp; val : metric_map_) {</a>
<a name="ln259">      const MetricPrototype* prototype = val.first;</a>
<a name="ln260">      const scoped_refptr&lt;Metric&gt;&amp; metric = val.second;</a>
<a name="ln261"> </a>
<a name="ln262">      if (select_all || MatchMetricInList(prototype-&gt;name(), requested_metrics)) {</a>
<a name="ln263">        InsertOrDie(&amp;metrics, prototype-&gt;name(), metric);</a>
<a name="ln264">      }</a>
<a name="ln265">    }</a>
<a name="ln266">  }</a>
<a name="ln267"> </a>
<a name="ln268">  // If we had a filter, and we didn't either match this entity or any metrics inside</a>
<a name="ln269">  // it, don't print the entity at all.</a>
<a name="ln270">  if (!requested_metrics.empty() &amp;&amp; !select_all &amp;&amp; metrics.empty()) {</a>
<a name="ln271">    return Status::OK();</a>
<a name="ln272">  }</a>
<a name="ln273"> </a>
<a name="ln274">  writer-&gt;StartObject();</a>
<a name="ln275"> </a>
<a name="ln276">  writer-&gt;String(&quot;type&quot;);</a>
<a name="ln277">  writer-&gt;String(prototype_-&gt;name());</a>
<a name="ln278"> </a>
<a name="ln279">  writer-&gt;String(&quot;id&quot;);</a>
<a name="ln280">  writer-&gt;String(id_);</a>
<a name="ln281"> </a>
<a name="ln282">  writer-&gt;String(&quot;attributes&quot;);</a>
<a name="ln283">  writer-&gt;StartObject();</a>
<a name="ln284">  for (const AttributeMap::value_type&amp; val : attrs) {</a>
<a name="ln285">    writer-&gt;String(val.first);</a>
<a name="ln286">    writer-&gt;String(val.second);</a>
<a name="ln287">  }</a>
<a name="ln288">  writer-&gt;EndObject();</a>
<a name="ln289"> </a>
<a name="ln290">  writer-&gt;String(&quot;metrics&quot;);</a>
<a name="ln291">  writer-&gt;StartArray();</a>
<a name="ln292">  for (OrderedMetricMap::value_type&amp; val : metrics) {</a>
<a name="ln293">    WARN_NOT_OK(val.second-&gt;WriteAsJson(writer, opts),</a>
<a name="ln294">                strings::Substitute(&quot;Failed to write $0 as JSON&quot;, val.first));</a>
<a name="ln295"> </a>
<a name="ln296">  }</a>
<a name="ln297">  // Run the external metrics collection callback if there is one set.</a>
<a name="ln298">  for (const ExternalJsonMetricsCb&amp; cb : external_metrics_cbs) {</a>
<a name="ln299">    cb(writer, opts);</a>
<a name="ln300">  }</a>
<a name="ln301">  writer-&gt;EndArray();</a>
<a name="ln302"> </a>
<a name="ln303">  writer-&gt;EndObject();</a>
<a name="ln304"> </a>
<a name="ln305">  return Status::OK();</a>
<a name="ln306">}</a>
<a name="ln307"> </a>
<a name="ln308">CHECKED_STATUS MetricEntity::WriteForPrometheus(PrometheusWriter* writer,</a>
<a name="ln309">                                                const MetricPrometheusOptions&amp; opts) const {</a>
<a name="ln310">  // We want the keys to be in alphabetical order when printing, so we use an ordered map here.</a>
<a name="ln311">  typedef std::map&lt;const char*, scoped_refptr&lt;Metric&gt; &gt; OrderedMetricMap;</a>
<a name="ln312">  OrderedMetricMap metrics;</a>
<a name="ln313">  AttributeMap attrs;</a>
<a name="ln314">  std::vector&lt;ExternalPrometheusMetricsCb&gt; external_metrics_cbs;</a>
<a name="ln315">  {</a>
<a name="ln316">    // Snapshot the metrics, attributes &amp; external metrics callbacks in this metrics entity. (Note:</a>
<a name="ln317">    // this is not guaranteed to be a consistent snapshot).</a>
<a name="ln318">    std::lock_guard&lt;simple_spinlock&gt; l(lock_);</a>
<a name="ln319">    attrs = attributes_;</a>
<a name="ln320">    external_metrics_cbs = external_prometheus_metrics_cbs_;</a>
<a name="ln321">    for (const MetricMap::value_type&amp; val : metric_map_) {</a>
<a name="ln322">      const MetricPrototype* prototype = val.first;</a>
<a name="ln323">      const scoped_refptr&lt;Metric&gt;&amp; metric = val.second;</a>
<a name="ln324"> </a>
<a name="ln325">      InsertOrDie(&amp;metrics, prototype-&gt;name(), metric);</a>
<a name="ln326">    }</a>
<a name="ln327">  }</a>
<a name="ln328">  AttributeMap prometheus_attr;</a>
<a name="ln329">  // Per tablet metrics come with tablet_id, as well as table_id and table_name attributes.</a>
<a name="ln330">  // We ignore the tablet part to squash at the table level.</a>
<a name="ln331">  if (strcmp(prototype_-&gt;name(), &quot;tablet&quot;) == 0)  {</a>
<a name="ln332">    prometheus_attr[&quot;table_id&quot;] = attrs[&quot;table_id&quot;];</a>
<a name="ln333">    prometheus_attr[&quot;table_name&quot;] = attrs[&quot;table_name&quot;];</a>
<a name="ln334">    prometheus_attr[&quot;namespace_name&quot;] = attrs[&quot;namespace_name&quot;];</a>
<a name="ln335">  } else if (strcmp(prototype_-&gt;name(), &quot;server&quot;) == 0 ||</a>
<a name="ln336">      strcmp(prototype_-&gt;name(), &quot;cluster&quot;) == 0) {</a>
<a name="ln337">    prometheus_attr = attrs;</a>
<a name="ln338">    // This is tablet_id in the case of tablet, but otherwise names the server type, eg: yb.master</a>
<a name="ln339">    prometheus_attr[&quot;metric_id&quot;] = id_;</a>
<a name="ln340">  } else if (strcmp(prototype_-&gt;name(), &quot;cdc&quot;) == 0) {</a>
<a name="ln341">    prometheus_attr[&quot;table_id&quot;] = attrs[&quot;table_id&quot;];</a>
<a name="ln342">    prometheus_attr[&quot;table_name&quot;] = attrs[&quot;table_name&quot;];</a>
<a name="ln343">    prometheus_attr[&quot;namespace_name&quot;] = attrs[&quot;namespace_name&quot;];</a>
<a name="ln344">    prometheus_attr[&quot;stream_id&quot;] = attrs[&quot;stream_id&quot;];</a>
<a name="ln345">  } else {</a>
<a name="ln346">    return Status::OK();</a>
<a name="ln347">  }</a>
<a name="ln348">  // This is currently tablet / server / cluster / cdc.</a>
<a name="ln349">  prometheus_attr[&quot;metric_type&quot;] = prototype_-&gt;name();</a>
<a name="ln350">  prometheus_attr[&quot;exported_instance&quot;] = FLAGS_metric_node_name;</a>
<a name="ln351"> </a>
<a name="ln352">  for (OrderedMetricMap::value_type&amp; val : metrics) {</a>
<a name="ln353">    WARN_NOT_OK(val.second-&gt;WriteForPrometheus(writer, prometheus_attr, opts),</a>
<a name="ln354">                strings::Substitute(&quot;Failed to write $0 as Prometheus&quot;, val.first));</a>
<a name="ln355"> </a>
<a name="ln356">  }</a>
<a name="ln357">  // Run the external metrics collection callback if there is one set.</a>
<a name="ln358">  for (const ExternalPrometheusMetricsCb&amp; cb : external_metrics_cbs) {</a>
<a name="ln359">    cb(writer, opts);</a>
<a name="ln360">  }</a>
<a name="ln361"> </a>
<a name="ln362">  return Status::OK();</a>
<a name="ln363">}</a>
<a name="ln364"> </a>
<a name="ln365">void MetricEntity::Remove(const MetricPrototype* proto) {</a>
<a name="ln366">  std::lock_guard&lt;simple_spinlock&gt; l(lock_);</a>
<a name="ln367">  metric_map_.erase(proto);</a>
<a name="ln368">}</a>
<a name="ln369"> </a>
<a name="ln370">void MetricEntity::RetireOldMetrics() {</a>
<a name="ln371">  MonoTime now = MonoTime::Now();</a>
<a name="ln372"> </a>
<a name="ln373">  std::lock_guard&lt;simple_spinlock&gt; l(lock_);</a>
<a name="ln374">  for (auto it = metric_map_.begin(); it != metric_map_.end();) {</a>
<a name="ln375">    const scoped_refptr&lt;Metric&gt;&amp; metric = it-&gt;second;</a>
<a name="ln376"> </a>
<a name="ln377">    if (PREDICT_TRUE(!metric-&gt;HasOneRef())) {</a>
<a name="ln378">      // The metric is still in use. Note that, in the case of &quot;NeverRetire()&quot;, the metric</a>
<a name="ln379">      // will have a ref-count of 2 because it is reffed by the 'never_retire_metrics_'</a>
<a name="ln380">      // collection.</a>
<a name="ln381"> </a>
<a name="ln382">      // Ensure that it is not marked for later retirement (this could happen in the case</a>
<a name="ln383">      // that a metric is un-reffed and then re-reffed later by looking it up from the</a>
<a name="ln384">      // registry).</a>
<a name="ln385">      metric-&gt;retire_time_ = MonoTime();</a>
<a name="ln386">      ++it;</a>
<a name="ln387">      continue;</a>
<a name="ln388">    }</a>
<a name="ln389"> </a>
<a name="ln390">    if (!metric-&gt;retire_time_.Initialized()) {</a>
<a name="ln391">      VLOG(3) &lt;&lt; &quot;Metric &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; has become un-referenced. Will retire after &quot;</a>
<a name="ln392">              &lt;&lt; &quot;the retention interval&quot;;</a>
<a name="ln393">      // This is the first time we've seen this metric as retirable.</a>
<a name="ln394">      metric-&gt;retire_time_ = now;</a>
<a name="ln395">      metric-&gt;retire_time_.AddDelta(MonoDelta::FromMilliseconds(</a>
<a name="ln396">                                      FLAGS_metrics_retirement_age_ms));</a>
<a name="ln397">      ++it;</a>
<a name="ln398">      continue;</a>
<a name="ln399">    }</a>
<a name="ln400"> </a>
<a name="ln401">    // If we've already seen this metric in a previous scan, check if it's</a>
<a name="ln402">    // time to retire it yet.</a>
<a name="ln403">    if (now.ComesBefore(metric-&gt;retire_time_)) {</a>
<a name="ln404">      VLOG(3) &lt;&lt; &quot;Metric &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; is un-referenced, but still within &quot;</a>
<a name="ln405">              &lt;&lt; &quot;the retention interval&quot;;</a>
<a name="ln406">      ++it;</a>
<a name="ln407">      continue;</a>
<a name="ln408">    }</a>
<a name="ln409"> </a>
<a name="ln410"> </a>
<a name="ln411">    VLOG(2) &lt;&lt; &quot;Retiring metric &quot; &lt;&lt; it-&gt;first;</a>
<a name="ln412">    metric_map_.erase(it++);</a>
<a name="ln413">  }</a>
<a name="ln414">}</a>
<a name="ln415"> </a>
<a name="ln416">void MetricEntity::NeverRetire(const scoped_refptr&lt;Metric&gt;&amp; metric) {</a>
<a name="ln417">  std::lock_guard&lt;simple_spinlock&gt; l(lock_);</a>
<a name="ln418">  never_retire_metrics_.push_back(metric);</a>
<a name="ln419">}</a>
<a name="ln420"> </a>
<a name="ln421">void MetricEntity::SetAttributes(const AttributeMap&amp; attrs) {</a>
<a name="ln422">  std::lock_guard&lt;simple_spinlock&gt; l(lock_);</a>
<a name="ln423">  attributes_ = attrs;</a>
<a name="ln424">}</a>
<a name="ln425"> </a>
<a name="ln426">void MetricEntity::SetAttribute(const string&amp; key, const string&amp; val) {</a>
<a name="ln427">  std::lock_guard&lt;simple_spinlock&gt; l(lock_);</a>
<a name="ln428">  attributes_[key] = val;</a>
<a name="ln429">}</a>
<a name="ln430"> </a>
<a name="ln431">//</a>
<a name="ln432">// MetricRegistry</a>
<a name="ln433">//</a>
<a name="ln434"> </a>
<a name="ln435">MetricRegistry::MetricRegistry() {</a>
<a name="ln436">}</a>
<a name="ln437"> </a>
<a name="ln438">MetricRegistry::~MetricRegistry() {</a>
<a name="ln439">}</a>
<a name="ln440"> </a>
<a name="ln441">bool MetricRegistry::TabletHasBeenShutdown(const scoped_refptr&lt;MetricEntity&gt; entity) const {</a>
<a name="ln442">    if (strcmp(entity-&gt;prototype_-&gt;name(), &quot;tablet&quot;) == 0 &amp;&amp; tablets_shutdown_find(entity-&gt;id())) {</a>
<a name="ln443">      DVLOG(5) &lt;&lt; &quot;Do not report metrics for shutdown tablet &quot; &lt;&lt; entity-&gt;id();</a>
<a name="ln444">      return true;</a>
<a name="ln445">    }</a>
<a name="ln446"> </a>
<a name="ln447">    return false;</a>
<a name="ln448">}</a>
<a name="ln449"> </a>
<a name="ln450">Status MetricRegistry::WriteAsJson(JsonWriter* writer,</a>
<a name="ln451">                                   const vector&lt;string&gt;&amp; requested_metrics,</a>
<a name="ln452">                                   const MetricJsonOptions&amp; opts) const {</a>
<a name="ln453">  EntityMap entities;</a>
<a name="ln454">  {</a>
<a name="ln455">    std::lock_guard&lt;simple_spinlock&gt; l(lock_);</a>
<a name="ln456">    entities = entities_;</a>
<a name="ln457">  }</a>
<a name="ln458"> </a>
<a name="ln459">  writer-&gt;StartArray();</a>
<a name="ln460">  for (const EntityMap::value_type&amp; e : entities) {</a>
<a name="ln461">    if (TabletHasBeenShutdown(e.second)) {</a>
<a name="ln462">      continue;</a>
<a name="ln463">    }</a>
<a name="ln464"> </a>
<a name="ln465">    WARN_NOT_OK(e.second-&gt;WriteAsJson(writer, requested_metrics, opts),</a>
<a name="ln466">                Substitute(&quot;Failed to write entity $0 as JSON&quot;, e.second-&gt;id()));</a>
<a name="ln467">  }</a>
<a name="ln468">  writer-&gt;EndArray();</a>
<a name="ln469"> </a>
<a name="ln470">  // Rather than having a thread poll metrics periodically to retire old ones,</a>
<a name="ln471">  // we'll just retire them here. The only downside is that, if no one is polling</a>
<a name="ln472">  // metrics, we may end up leaving them around indefinitely; however, metrics are</a>
<a name="ln473">  // small, and one might consider it a feature: if monitoring stops polling for</a>
<a name="ln474">  // metrics, we should keep them around until the next poll.</a>
<a name="ln475">  entities.clear(); // necessary to deref metrics we just dumped before doing retirement scan.</a>
<a name="ln476">  const_cast&lt;MetricRegistry*&gt;(this)-&gt;RetireOldMetrics();</a>
<a name="ln477">  return Status::OK();</a>
<a name="ln478">}</a>
<a name="ln479"> </a>
<a name="ln480">CHECKED_STATUS MetricRegistry::WriteForPrometheus(PrometheusWriter* writer,</a>
<a name="ln481">                                                  const MetricPrometheusOptions&amp; opts) const {</a>
<a name="ln482">  EntityMap entities;</a>
<a name="ln483">  {</a>
<a name="ln484">    std::lock_guard&lt;simple_spinlock&gt; l(lock_);</a>
<a name="ln485">    entities = entities_;</a>
<a name="ln486">  }</a>
<a name="ln487"> </a>
<a name="ln488">  for (const EntityMap::value_type&amp; e : entities) {</a>
<a name="ln489">    if (TabletHasBeenShutdown(e.second)) {</a>
<a name="ln490">      continue;</a>
<a name="ln491">    }</a>
<a name="ln492"> </a>
<a name="ln493">    WARN_NOT_OK(e.second-&gt;WriteForPrometheus(writer, opts),</a>
<a name="ln494">                Substitute(&quot;Failed to write entity $0 as Prometheus&quot;, e.second-&gt;id()));</a>
<a name="ln495">  }</a>
<a name="ln496">  RETURN_NOT_OK(writer-&gt;FlushAggregatedValues());</a>
<a name="ln497"> </a>
<a name="ln498">  // Rather than having a thread poll metrics periodically to retire old ones,</a>
<a name="ln499">  // we'll just retire them here. The only downside is that, if no one is polling</a>
<a name="ln500">  // metrics, we may end up leaving them around indefinitely; however, metrics are</a>
<a name="ln501">  // small, and one might consider it a feature: if monitoring stops polling for</a>
<a name="ln502">  // metrics, we should keep them around until the next poll.</a>
<a name="ln503">  entities.clear(); // necessary to deref metrics we just dumped before doing retirement scan.</a>
<a name="ln504">  const_cast&lt;MetricRegistry*&gt;(this)-&gt;RetireOldMetrics();</a>
<a name="ln505">  return Status::OK();</a>
<a name="ln506">}</a>
<a name="ln507"> </a>
<a name="ln508">void MetricRegistry::RetireOldMetrics() {</a>
<a name="ln509">  std::lock_guard&lt;simple_spinlock&gt; l(lock_);</a>
<a name="ln510">  for (auto it = entities_.begin(); it != entities_.end();) {</a>
<a name="ln511">    it-&gt;second-&gt;RetireOldMetrics();</a>
<a name="ln512"> </a>
<a name="ln513">    if (it-&gt;second-&gt;num_metrics() == 0 &amp;&amp; it-&gt;second-&gt;HasOneRef()) {</a>
<a name="ln514">      // No metrics and no external references to this entity, so we can retire it.</a>
<a name="ln515">      // Unlike retiring the metrics themselves, we don't wait for any timeout</a>
<a name="ln516">      // to retire them -- we assume that that timed retention has been satisfied</a>
<a name="ln517">      // by holding onto the metrics inside the entity.</a>
<a name="ln518"> </a>
<a name="ln519">      // For a tablet that has been shutdown, metrics are being deleted. So do not track</a>
<a name="ln520">      // the tablet anymore.</a>
<a name="ln521">      if (strcmp(it-&gt;second-&gt;prototype_-&gt;name(), &quot;tablet&quot;) == 0) {</a>
<a name="ln522">        DVLOG(3) &lt;&lt; &quot;T &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot;: &quot;</a>
<a name="ln523">          &lt;&lt; &quot;Remove from set of tablets that have been shutdown so as to be freed&quot;;</a>
<a name="ln524">        tablets_shutdown_erase(it-&gt;first);</a>
<a name="ln525">      }</a>
<a name="ln526"> </a>
<a name="ln527">      entities_.erase(it++);</a>
<a name="ln528">    } else {</a>
<a name="ln529">      ++it;</a>
<a name="ln530">    }</a>
<a name="ln531">  }</a>
<a name="ln532">}</a>
<a name="ln533"> </a>
<a name="ln534">//</a>
<a name="ln535">// MetricPrototypeRegistry</a>
<a name="ln536">//</a>
<a name="ln537">MetricPrototypeRegistry* MetricPrototypeRegistry::get() {</a>
<a name="ln538">  return Singleton&lt;MetricPrototypeRegistry&gt;::get();</a>
<a name="ln539">}</a>
<a name="ln540"> </a>
<a name="ln541">void MetricPrototypeRegistry::AddMetric(const MetricPrototype* prototype) {</a>
<a name="ln542">  std::lock_guard&lt;simple_spinlock&gt; l(lock_);</a>
<a name="ln543">  metrics_.push_back(prototype);</a>
<a name="ln544">}</a>
<a name="ln545"> </a>
<a name="ln546">void MetricPrototypeRegistry::AddEntity(const MetricEntityPrototype* prototype) {</a>
<a name="ln547">  std::lock_guard&lt;simple_spinlock&gt; l(lock_);</a>
<a name="ln548">  entities_.push_back(prototype);</a>
<a name="ln549">}</a>
<a name="ln550"> </a>
<a name="ln551">void MetricPrototypeRegistry::WriteAsJson(JsonWriter* writer) const {</a>
<a name="ln552">  std::lock_guard&lt;simple_spinlock&gt; l(lock_);</a>
<a name="ln553">  MetricJsonOptions opts;</a>
<a name="ln554">  opts.include_schema_info = true;</a>
<a name="ln555">  writer-&gt;StartObject();</a>
<a name="ln556"> </a>
<a name="ln557">  // Dump metric prototypes.</a>
<a name="ln558">  writer-&gt;String(&quot;metrics&quot;);</a>
<a name="ln559">  writer-&gt;StartArray();</a>
<a name="ln560">  for (const MetricPrototype* p : metrics_) {</a>
<a name="ln561">    writer-&gt;StartObject();</a>
<a name="ln562">    p-&gt;WriteFields(writer, opts);</a>
<a name="ln563">    writer-&gt;String(&quot;entity_type&quot;);</a>
<a name="ln564">    writer-&gt;String(p-&gt;entity_type());</a>
<a name="ln565">    writer-&gt;EndObject();</a>
<a name="ln566">  }</a>
<a name="ln567">  writer-&gt;EndArray();</a>
<a name="ln568"> </a>
<a name="ln569">  // Dump entity prototypes.</a>
<a name="ln570">  writer-&gt;String(&quot;entities&quot;);</a>
<a name="ln571">  writer-&gt;StartArray();</a>
<a name="ln572">  for (const MetricEntityPrototype* p : entities_) {</a>
<a name="ln573">    writer-&gt;StartObject();</a>
<a name="ln574">    writer-&gt;String(&quot;name&quot;);</a>
<a name="ln575">    writer-&gt;String(p-&gt;name());</a>
<a name="ln576">    writer-&gt;EndObject();</a>
<a name="ln577">  }</a>
<a name="ln578">  writer-&gt;EndArray();</a>
<a name="ln579"> </a>
<a name="ln580">  writer-&gt;EndObject();</a>
<a name="ln581">}</a>
<a name="ln582"> </a>
<a name="ln583">CHECKED_STATUS MetricPrototypeRegistry::WriteForPrometheus(PrometheusWriter* writer) const {</a>
<a name="ln584">  // TODO: do we need this?</a>
<a name="ln585">  return Status::OK();</a>
<a name="ln586">}</a>
<a name="ln587"> </a>
<a name="ln588">void MetricPrototypeRegistry::WriteAsJsonAndExit() const {</a>
<a name="ln589">  std::stringstream s;</a>
<a name="ln590">  JsonWriter w(&amp;s, JsonWriter::PRETTY);</a>
<a name="ln591">  WriteAsJson(&amp;w);</a>
<a name="ln592">  std::cout &lt;&lt; s.str() &lt;&lt; std::endl;</a>
<a name="ln593">  exit(0);</a>
<a name="ln594">}</a>
<a name="ln595"> </a>
<a name="ln596">//</a>
<a name="ln597">// MetricPrototype</a>
<a name="ln598">//</a>
<a name="ln599">MetricPrototype::MetricPrototype(CtorArgs args) : args_(std::move(args)) {</a>
<a name="ln600">  MetricPrototypeRegistry::get()-&gt;AddMetric(this);</a>
<a name="ln601">}</a>
<a name="ln602"> </a>
<a name="ln603">void MetricPrototype::WriteFields(JsonWriter* writer,</a>
<a name="ln604">                                  const MetricJsonOptions&amp; opts) const {</a>
<a name="ln605">  writer-&gt;String(&quot;name&quot;);</a>
<a name="ln606">  writer-&gt;String(name());</a>
<a name="ln607"> </a>
<a name="ln608">  if (opts.include_schema_info) {</a>
<a name="ln609">    writer-&gt;String(&quot;label&quot;);</a>
<a name="ln610">    writer-&gt;String(label());</a>
<a name="ln611"> </a>
<a name="ln612">    writer-&gt;String(&quot;type&quot;);</a>
<a name="ln613">    writer-&gt;String(MetricType::Name(type()));</a>
<a name="ln614"> </a>
<a name="ln615">    writer-&gt;String(&quot;unit&quot;);</a>
<a name="ln616">    writer-&gt;String(MetricUnit::Name(unit()));</a>
<a name="ln617"> </a>
<a name="ln618">    writer-&gt;String(&quot;description&quot;);</a>
<a name="ln619">    writer-&gt;String(description());</a>
<a name="ln620"> </a>
<a name="ln621">    writer-&gt;String(&quot;level&quot;);</a>
<a name="ln622">    writer-&gt;String(MetricLevelName(level()));</a>
<a name="ln623">  }</a>
<a name="ln624">}</a>
<a name="ln625"> </a>
<a name="ln626">//</a>
<a name="ln627">// FunctionGaugeDetacher</a>
<a name="ln628">//</a>
<a name="ln629"> </a>
<a name="ln630">FunctionGaugeDetacher::FunctionGaugeDetacher() {</a>
<a name="ln631">}</a>
<a name="ln632"> </a>
<a name="ln633">FunctionGaugeDetacher::~FunctionGaugeDetacher() {</a>
<a name="ln634">  for (const Closure&amp; c : callbacks_) {</a>
<a name="ln635">    c.Run();</a>
<a name="ln636">  }</a>
<a name="ln637">}</a>
<a name="ln638"> </a>
<a name="ln639">scoped_refptr&lt;MetricEntity&gt; MetricRegistry::FindOrCreateEntity(</a>
<a name="ln640">    const MetricEntityPrototype* prototype,</a>
<a name="ln641">    const std::string&amp; id,</a>
<a name="ln642">    const MetricEntity::AttributeMap&amp; initial_attributes) {</a>
<a name="ln643">  std::lock_guard&lt;simple_spinlock&gt; l(lock_);</a>
<a name="ln644">  scoped_refptr&lt;MetricEntity&gt; e = FindPtrOrNull(entities_, id);</a>
<a name="ln645">  if (!e) {</a>
<a name="ln646">    e = new MetricEntity(prototype, id, initial_attributes);</a>
<a name="ln647">    InsertOrDie(&amp;entities_, id, e);</a>
<a name="ln648">  } else {</a>
<a name="ln649">    e-&gt;SetAttributes(initial_attributes);</a>
<a name="ln650">  }</a>
<a name="ln651">  return e;</a>
<a name="ln652">}</a>
<a name="ln653"> </a>
<a name="ln654">//</a>
<a name="ln655">// Metric</a>
<a name="ln656">//</a>
<a name="ln657">Metric::Metric(const MetricPrototype* prototype)</a>
<a name="ln658">  : prototype_(prototype) {</a>
<a name="ln659">}</a>
<a name="ln660"> </a>
<a name="ln661">Metric::Metric(std::unique_ptr&lt;MetricPrototype&gt; prototype)</a>
<a name="ln662">  : prototype_holder_(std::move(prototype)), prototype_(prototype_holder_.get()) {</a>
<a name="ln663">}</a>
<a name="ln664"> </a>
<a name="ln665">Metric::~Metric() {</a>
<a name="ln666">}</a>
<a name="ln667"> </a>
<a name="ln668">//</a>
<a name="ln669">// Gauge</a>
<a name="ln670">//</a>
<a name="ln671"> </a>
<a name="ln672">Status Gauge::WriteAsJson(JsonWriter* writer,</a>
<a name="ln673">                          const MetricJsonOptions&amp; opts) const {</a>
<a name="ln674">  if (prototype_-&gt;level() &lt; opts.level) {</a>
<a name="ln675">    return Status::OK();</a>
<a name="ln676">  }</a>
<a name="ln677"> </a>
<a name="ln678">  writer-&gt;StartObject();</a>
<a name="ln679"> </a>
<a name="ln680">  prototype_-&gt;WriteFields(writer, opts);</a>
<a name="ln681"> </a>
<a name="ln682">  writer-&gt;String(&quot;value&quot;);</a>
<a name="ln683">  WriteValue(writer);</a>
<a name="ln684"> </a>
<a name="ln685">  writer-&gt;EndObject();</a>
<a name="ln686">  return Status::OK();</a>
<a name="ln687">}</a>
<a name="ln688"> </a>
<a name="ln689">//</a>
<a name="ln690">// StringGauge</a>
<a name="ln691">//</a>
<a name="ln692"> </a>
<a name="ln693">StringGauge::StringGauge(const GaugePrototype&lt;string&gt;* proto,</a>
<a name="ln694">                         string initial_value)</a>
<a name="ln695">    : Gauge(proto), value_(std::move(initial_value)) {}</a>
<a name="ln696"> </a>
<a name="ln697">std::string StringGauge::value() const {</a>
<a name="ln698">  std::lock_guard&lt;simple_spinlock&gt; l(lock_);</a>
<a name="ln699">  return value_;</a>
<a name="ln700">}</a>
<a name="ln701"> </a>
<a name="ln702">void StringGauge::set_value(const std::string&amp; value) {</a>
<a name="ln703">  std::lock_guard&lt;simple_spinlock&gt; l(lock_);</a>
<a name="ln704">  value_ = value;</a>
<a name="ln705">}</a>
<a name="ln706"> </a>
<a name="ln707">void StringGauge::WriteValue(JsonWriter* writer) const {</a>
<a name="ln708">  writer-&gt;String(value());</a>
<a name="ln709">}</a>
<a name="ln710"> </a>
<a name="ln711">CHECKED_STATUS StringGauge::WriteForPrometheus(</a>
<a name="ln712">    PrometheusWriter* writer, const MetricEntity::AttributeMap&amp; attr,</a>
<a name="ln713">    const MetricPrometheusOptions&amp; opts) const {</a>
<a name="ln714">  if (prototype_-&gt;level() &lt; opts.level) {</a>
<a name="ln715">    return Status::OK();</a>
<a name="ln716">  }</a>
<a name="ln717"> </a>
<a name="ln718">  // TODO(bogdan): don't think we need this?</a>
<a name="ln719">  // return writer-&gt;WriteSingleEntry(attr, prototype_-&gt;name(), value());</a>
<a name="ln720">  return Status::OK();</a>
<a name="ln721">}</a>
<a name="ln722"> </a>
<a name="ln723">//</a>
<a name="ln724">// Counter</a>
<a name="ln725">//</a>
<a name="ln726">// This implementation is optimized by using a striped counter. See LongAdder for details.</a>
<a name="ln727"> </a>
<a name="ln728">scoped_refptr&lt;Counter&gt; CounterPrototype::Instantiate(const scoped_refptr&lt;MetricEntity&gt;&amp; entity) {</a>
<a name="ln729">  return entity-&gt;FindOrCreateCounter(this);</a>
<a name="ln730">}</a>
<a name="ln731"> </a>
<a name="ln732">Counter::Counter(const CounterPrototype* proto) : Metric(proto) {</a>
<a name="ln733">}</a>
<a name="ln734"> </a>
<a name="ln735">int64_t Counter::value() const {</a>
<a name="ln736">  return value_.Value();</a>
<a name="ln737">}</a>
<a name="ln738"> </a>
<a name="ln739">void Counter::Increment() {</a>
<a name="ln740">  IncrementBy(1);</a>
<a name="ln741">}</a>
<a name="ln742"> </a>
<a name="ln743">void Counter::IncrementBy(int64_t amount) {</a>
<a name="ln744">  value_.IncrementBy(amount);</a>
<a name="ln745">}</a>
<a name="ln746"> </a>
<a name="ln747">Status Counter::WriteAsJson(JsonWriter* writer,</a>
<a name="ln748">                            const MetricJsonOptions&amp; opts) const {</a>
<a name="ln749">  if (prototype_-&gt;level() &lt; opts.level) {</a>
<a name="ln750">    return Status::OK();</a>
<a name="ln751">  }</a>
<a name="ln752"> </a>
<a name="ln753">  writer-&gt;StartObject();</a>
<a name="ln754"> </a>
<a name="ln755">  prototype_-&gt;WriteFields(writer, opts);</a>
<a name="ln756"> </a>
<a name="ln757">  writer-&gt;String(&quot;value&quot;);</a>
<a name="ln758">  writer-&gt;Int64(value());</a>
<a name="ln759"> </a>
<a name="ln760">  writer-&gt;EndObject();</a>
<a name="ln761">  return Status::OK();</a>
<a name="ln762">}</a>
<a name="ln763"> </a>
<a name="ln764">CHECKED_STATUS Counter::WriteForPrometheus(</a>
<a name="ln765">    PrometheusWriter* writer, const MetricEntity::AttributeMap&amp; attr,</a>
<a name="ln766">    const MetricPrometheusOptions&amp; opts) const {</a>
<a name="ln767">  if (prototype_-&gt;level() &lt; opts.level) {</a>
<a name="ln768">    return Status::OK();</a>
<a name="ln769">  }</a>
<a name="ln770"> </a>
<a name="ln771">  return writer-&gt;WriteSingleEntry(attr, prototype_-&gt;name(), value());</a>
<a name="ln772">}</a>
<a name="ln773"> </a>
<a name="ln774">//</a>
<a name="ln775">// MillisLag</a>
<a name="ln776">//</a>
<a name="ln777"> </a>
<a name="ln778">scoped_refptr&lt;MillisLag&gt; MillisLagPrototype::Instantiate(</a>
<a name="ln779">    const scoped_refptr&lt;MetricEntity&gt;&amp; entity, const scoped_refptr&lt;server::Clock&gt;&amp; clock) {</a>
<a name="ln780">  return entity-&gt;FindOrCreateMillisLag(this, clock);</a>
<a name="ln781">}</a>
<a name="ln782"> </a>
<a name="ln783">MillisLag::MillisLag(const MillisLagPrototype* proto, const scoped_refptr&lt;server::Clock&gt;&amp; clock)</a>
<a name="ln784">  : Metric(proto), clock_(clock), timestamp_ms_(clock_-&gt;Now().GetPhysicalValueMillis()) {</a>
<a name="ln785">}</a>
<a name="ln786"> </a>
<a name="ln787">Status MillisLag::WriteAsJson(JsonWriter* writer, const MetricJsonOptions&amp; opts) const {</a>
<a name="ln788">  if (prototype_-&gt;level() &lt; opts.level) {</a>
<a name="ln789">    return Status::OK();</a>
<a name="ln790">  }</a>
<a name="ln791"> </a>
<a name="ln792">  writer-&gt;StartObject();</a>
<a name="ln793"> </a>
<a name="ln794">  prototype_-&gt;WriteFields(writer, opts);</a>
<a name="ln795"> </a>
<a name="ln796">  writer-&gt;String(&quot;value&quot;);</a>
<a name="ln797">  writer-&gt;Uint64(lag_ms());</a>
<a name="ln798"> </a>
<a name="ln799">  writer-&gt;EndObject();</a>
<a name="ln800">  return Status::OK();</a>
<a name="ln801">}</a>
<a name="ln802"> </a>
<a name="ln803">Status MillisLag::WriteForPrometheus(</a>
<a name="ln804">    PrometheusWriter* writer, const MetricEntity::AttributeMap&amp; attr,</a>
<a name="ln805">    const MetricPrometheusOptions&amp; opts) const {</a>
<a name="ln806">  if (prototype_-&gt;level() &lt; opts.level) {</a>
<a name="ln807">    return Status::OK();</a>
<a name="ln808">  }</a>
<a name="ln809"> </a>
<a name="ln810">  return writer-&gt;WriteSingleEntry(attr, prototype_-&gt;name(), lag_ms());</a>
<a name="ln811">}</a>
<a name="ln812"> </a>
<a name="ln813">AtomicMillisLag::AtomicMillisLag(const MillisLagPrototype* proto,</a>
<a name="ln814">                                 const scoped_refptr&lt;server::Clock&gt;&amp; clock)</a>
<a name="ln815">  : MillisLag(proto, clock), atomic_timestamp_ms_(clock_-&gt;Now().GetPhysicalValueMillis()) {</a>
<a name="ln816">}</a>
<a name="ln817"> </a>
<a name="ln818">Status AtomicMillisLag::WriteAsJson(JsonWriter* writer, const MetricJsonOptions&amp; opts) const {</a>
<a name="ln819">  if (prototype_-&gt;level() &lt; opts.level) {</a>
<a name="ln820">    return Status::OK();</a>
<a name="ln821">  }</a>
<a name="ln822"> </a>
<a name="ln823">  writer-&gt;StartObject();</a>
<a name="ln824"> </a>
<a name="ln825">  prototype_-&gt;WriteFields(writer, opts);</a>
<a name="ln826"> </a>
<a name="ln827">  writer-&gt;String(&quot;value&quot;);</a>
<a name="ln828">  writer-&gt;Uint64(this-&gt;lag_ms());</a>
<a name="ln829"> </a>
<a name="ln830">  writer-&gt;EndObject();</a>
<a name="ln831">  return Status::OK();</a>
<a name="ln832">}</a>
<a name="ln833"> </a>
<a name="ln834">/////////////////////////////////////////////////</a>
<a name="ln835">// HistogramPrototype</a>
<a name="ln836">/////////////////////////////////////////////////</a>
<a name="ln837"> </a>
<a name="ln838">HistogramPrototype::HistogramPrototype(const MetricPrototype::CtorArgs&amp; args,</a>
<a name="ln839">                                       uint64_t max_trackable_value, int num_sig_digits,</a>
<a name="ln840">                                       ExportPercentiles export_percentiles)</a>
<a name="ln841">  : MetricPrototype(args),</a>
<a name="ln842">    max_trackable_value_(max_trackable_value),</a>
<a name="ln843">    num_sig_digits_(num_sig_digits),</a>
<a name="ln844">    export_percentiles_(export_percentiles) {</a>
<a name="ln845">  // Better to crash at definition time that at instantiation time.</a>
<a name="ln846">  CHECK(HdrHistogram::IsValidHighestTrackableValue(max_trackable_value))</a>
<a name="ln847">      &lt;&lt; Substitute(&quot;Invalid max trackable value on histogram $0: $1&quot;,</a>
<a name="ln848">                    args.name_, max_trackable_value);</a>
<a name="ln849">  CHECK(HdrHistogram::IsValidNumSignificantDigits(num_sig_digits))</a>
<a name="ln850">      &lt;&lt; Substitute(&quot;Invalid number of significant digits on histogram $0: $1&quot;,</a>
<a name="ln851">                    args.name_, num_sig_digits);</a>
<a name="ln852">}</a>
<a name="ln853"> </a>
<a name="ln854">scoped_refptr&lt;Histogram&gt; HistogramPrototype::Instantiate(</a>
<a name="ln855">    const scoped_refptr&lt;MetricEntity&gt;&amp; entity) {</a>
<a name="ln856">  return entity-&gt;FindOrCreateHistogram(this);</a>
<a name="ln857">}</a>
<a name="ln858"> </a>
<a name="ln859">/////////////////////////////////////////////////</a>
<a name="ln860">// Histogram</a>
<a name="ln861">/////////////////////////////////////////////////</a>
<a name="ln862"> </a>
<a name="ln863">Histogram::Histogram(const HistogramPrototype* proto)</a>
<a name="ln864">  : Metric(proto),</a>
<a name="ln865">    histogram_(new HdrHistogram(proto-&gt;max_trackable_value(), proto-&gt;num_sig_digits())),</a>
<a name="ln866">    export_percentiles_(proto-&gt;export_percentiles()) {</a>
<a name="ln867">}</a>
<a name="ln868"> </a>
<a name="ln869">void Histogram::Increment(int64_t value) {</a>
<a name="ln870">  histogram_-&gt;Increment(value);</a>
<a name="ln871">}</a>
<a name="ln872"> </a>
<a name="ln873">void Histogram::IncrementBy(int64_t value, int64_t amount) {</a>
<a name="ln874">  histogram_-&gt;IncrementBy(value, amount);</a>
<a name="ln875">}</a>
<a name="ln876"> </a>
<a name="ln877">Status Histogram::WriteAsJson(JsonWriter* writer,</a>
<a name="ln878">                              const MetricJsonOptions&amp; opts) const {</a>
<a name="ln879">  if (prototype_-&gt;level() &lt; opts.level) {</a>
<a name="ln880">    return Status::OK();</a>
<a name="ln881">  }</a>
<a name="ln882"> </a>
<a name="ln883">  HistogramSnapshotPB snapshot;</a>
<a name="ln884">  RETURN_NOT_OK(GetAndResetHistogramSnapshotPB(&amp;snapshot, opts));</a>
<a name="ln885">  writer-&gt;Protobuf(snapshot);</a>
<a name="ln886">  return Status::OK();</a>
<a name="ln887">}</a>
<a name="ln888"> </a>
<a name="ln889">CHECKED_STATUS Histogram::WriteForPrometheus(</a>
<a name="ln890">    PrometheusWriter* writer, const MetricEntity::AttributeMap&amp; attr,</a>
<a name="ln891">    const MetricPrometheusOptions&amp; opts) const {</a>
<a name="ln892">  if (prototype_-&gt;level() &lt; opts.level) {</a>
<a name="ln893">    return Status::OK();</a>
<a name="ln894">  }</a>
<a name="ln895"> </a>
<a name="ln896">  HdrHistogram snapshot(*histogram_);</a>
<a name="ln897">  // HdrHistogram reports percentiles based on all the data points from the</a>
<a name="ln898">  // begining of time. We are interested in the percentiles based on just</a>
<a name="ln899">  // the &quot;newly-arrived&quot; data. So, we will reset the histogram's percentiles</a>
<a name="ln900">  // between each invocation.</a>
<a name="ln901">  histogram_-&gt;ResetPercentiles();</a>
<a name="ln902"> </a>
<a name="ln903">  // Representing the sum and count require suffixed names.</a>
<a name="ln904">  std::string hist_name = prototype_-&gt;name();</a>
<a name="ln905">  auto copy_of_attr = attr;</a>
<a name="ln906">  RETURN_NOT_OK(writer-&gt;WriteSingleEntry(</a>
<a name="ln907">        copy_of_attr, hist_name + &quot;_sum&quot;, snapshot.TotalSum()));</a>
<a name="ln908">  RETURN_NOT_OK(writer-&gt;WriteSingleEntry(</a>
<a name="ln909">        copy_of_attr, hist_name + &quot;_count&quot;, snapshot.TotalCount()));</a>
<a name="ln910"> </a>
<a name="ln911">  // Copy the label map to add the quatiles.</a>
<a name="ln912">  if (export_percentiles_ &amp;&amp; FLAGS_expose_metric_histogram_percentiles) {</a>
<a name="ln913">    copy_of_attr[&quot;quantile&quot;] = &quot;p50&quot;;</a>
<a name="ln914">    RETURN_NOT_OK(writer-&gt;WriteSingleEntry(copy_of_attr, hist_name,</a>
<a name="ln915">                                           snapshot.ValueAtPercentile(50)));</a>
<a name="ln916">    copy_of_attr[&quot;quantile&quot;] = &quot;p95&quot;;</a>
<a name="ln917">    RETURN_NOT_OK(writer-&gt;WriteSingleEntry(copy_of_attr, hist_name,</a>
<a name="ln918">                                           snapshot.ValueAtPercentile(95)));</a>
<a name="ln919">    copy_of_attr[&quot;quantile&quot;] = &quot;p99&quot;;</a>
<a name="ln920">    RETURN_NOT_OK(writer-&gt;WriteSingleEntry(copy_of_attr, hist_name,</a>
<a name="ln921">                                           snapshot.ValueAtPercentile(99)));</a>
<a name="ln922">    copy_of_attr[&quot;quantile&quot;] = &quot;mean&quot;;</a>
<a name="ln923">    RETURN_NOT_OK(writer-&gt;WriteSingleEntry(copy_of_attr, hist_name,</a>
<a name="ln924">                                           snapshot.MeanValue()));</a>
<a name="ln925">    copy_of_attr[&quot;quantile&quot;] = &quot;max&quot;;</a>
<a name="ln926">    RETURN_NOT_OK(writer-&gt;WriteSingleEntry(copy_of_attr, hist_name,</a>
<a name="ln927">                                           snapshot.MaxValue()));</a>
<a name="ln928">  }</a>
<a name="ln929">  return Status::OK();</a>
<a name="ln930">}</a>
<a name="ln931"> </a>
<a name="ln932">Status Histogram::GetAndResetHistogramSnapshotPB(HistogramSnapshotPB* snapshot_pb,</a>
<a name="ln933">                                                 const MetricJsonOptions&amp; opts) const {</a>
<a name="ln934">  HdrHistogram snapshot(*histogram_);</a>
<a name="ln935">  // HdrHistogram reports percentiles based on all the data points from the</a>
<a name="ln936">  // begining of time. We are interested in the percentiles based on just</a>
<a name="ln937">  // the &quot;newly-arrived&quot; data. So, we will reset the histogram's percentiles</a>
<a name="ln938">  // between each invocation.</a>
<a name="ln939">  histogram_-&gt;ResetPercentiles();</a>
<a name="ln940"> </a>
<a name="ln941">  snapshot_pb-&gt;set_name(prototype_-&gt;name());</a>
<a name="ln942">  if (opts.include_schema_info) {</a>
<a name="ln943">    snapshot_pb-&gt;set_type(MetricType::Name(prototype_-&gt;type()));</a>
<a name="ln944">    snapshot_pb-&gt;set_label(prototype_-&gt;label());</a>
<a name="ln945">    snapshot_pb-&gt;set_unit(MetricUnit::Name(prototype_-&gt;unit()));</a>
<a name="ln946">    snapshot_pb-&gt;set_description(prototype_-&gt;description());</a>
<a name="ln947">    snapshot_pb-&gt;set_level(MetricLevelName(prototype_-&gt;level()));</a>
<a name="ln948">    snapshot_pb-&gt;set_max_trackable_value(snapshot.highest_trackable_value());</a>
<a name="ln949">    snapshot_pb-&gt;set_num_significant_digits(snapshot.num_significant_digits());</a>
<a name="ln950">  }</a>
<a name="ln951">  snapshot_pb-&gt;set_total_count(snapshot.TotalCount());</a>
<a name="ln952">  snapshot_pb-&gt;set_total_sum(snapshot.TotalSum());</a>
<a name="ln953">  snapshot_pb-&gt;set_min(snapshot.MinValue());</a>
<a name="ln954">  snapshot_pb-&gt;set_mean(snapshot.MeanValue());</a>
<a name="ln955">  snapshot_pb-&gt;set_percentile_75(snapshot.ValueAtPercentile(75));</a>
<a name="ln956">  snapshot_pb-&gt;set_percentile_95(snapshot.ValueAtPercentile(95));</a>
<a name="ln957">  snapshot_pb-&gt;set_percentile_99(snapshot.ValueAtPercentile(99));</a>
<a name="ln958">  snapshot_pb-&gt;set_percentile_99_9(snapshot.ValueAtPercentile(99.9));</a>
<a name="ln959">  snapshot_pb-&gt;set_percentile_99_99(snapshot.ValueAtPercentile(99.99));</a>
<a name="ln960">  snapshot_pb-&gt;set_max(snapshot.MaxValue());</a>
<a name="ln961"> </a>
<a name="ln962">  if (opts.include_raw_histograms) {</a>
<a name="ln963">    RecordedValuesIterator iter(&amp;snapshot);</a>
<a name="ln964">    while (iter.HasNext()) {</a>
<a name="ln965">      HistogramIterationValue value;</a>
<a name="ln966">      RETURN_NOT_OK(iter.Next(&amp;value));</a>
<a name="ln967">      snapshot_pb-&gt;add_values(value.value_iterated_to);</a>
<a name="ln968">      snapshot_pb-&gt;add_counts(value.count_at_value_iterated_to);</a>
<a name="ln969">    }</a>
<a name="ln970">  }</a>
<a name="ln971">  return Status::OK();</a>
<a name="ln972">}</a>
<a name="ln973"> </a>
<a name="ln974">uint64_t Histogram::CountInBucketForValueForTests(uint64_t value) const {</a>
<a name="ln975">  return histogram_-&gt;CountInBucketForValue(value);</a>
<a name="ln976">}</a>
<a name="ln977"> </a>
<a name="ln978">uint64_t Histogram::TotalCount() const {</a>
<a name="ln979">  return histogram_-&gt;TotalCount();</a>
<a name="ln980">}</a>
<a name="ln981"> </a>
<a name="ln982">uint64_t Histogram::MinValueForTests() const {</a>
<a name="ln983">  return histogram_-&gt;MinValue();</a>
<a name="ln984">}</a>
<a name="ln985"> </a>
<a name="ln986">uint64_t Histogram::MaxValueForTests() const {</a>
<a name="ln987">  return histogram_-&gt;MaxValue();</a>
<a name="ln988">}</a>
<a name="ln989">double Histogram::MeanValueForTests() const {</a>
<a name="ln990">  return histogram_-&gt;MeanValue();</a>
<a name="ln991">}</a>
<a name="ln992"> </a>
<a name="ln993">ScopedLatencyMetric::ScopedLatencyMetric(</a>
<a name="ln994">    const scoped_refptr&lt;Histogram&gt;&amp; latency_hist, Auto automatic)</a>
<a name="ln995">    : latency_hist_(latency_hist), auto_(automatic) {</a>
<a name="ln996">  Restart();</a>
<a name="ln997">}</a>
<a name="ln998"> </a>
<a name="ln999">ScopedLatencyMetric::ScopedLatencyMetric(ScopedLatencyMetric&amp;&amp; rhs)</a>
<a name="ln1000">    : latency_hist_(std::move(rhs.latency_hist_)), time_started_(rhs.time_started_),</a>
<a name="ln1001">      auto_(rhs.auto_) {</a>
<a name="ln1002">}</a>
<a name="ln1003"> </a>
<a name="ln1004">void ScopedLatencyMetric::operator=(ScopedLatencyMetric&amp;&amp; rhs) {</a>
<a name="ln1005">  if (auto_) {</a>
<a name="ln1006">    Finish();</a>
<a name="ln1007">  }</a>
<a name="ln1008"> </a>
<a name="ln1009">  latency_hist_ = std::move(rhs.latency_hist_);</a>
<a name="ln1010">  time_started_ = rhs.time_started_;</a>
<a name="ln1011">  auto_ = rhs.auto_;</a>
<a name="ln1012">}</a>
<a name="ln1013"> </a>
<a name="ln1014">ScopedLatencyMetric::~ScopedLatencyMetric() {</a>
<a name="ln1015">  if (auto_) {</a>
<a name="ln1016">    Finish();</a>
<a name="ln1017">  }</a>
<a name="ln1018">}</a>
<a name="ln1019"> </a>
<a name="ln1020">void ScopedLatencyMetric::Restart() {</a>
<a name="ln1021">  if (latency_hist_) {</a>
<a name="ln1022">    time_started_ = MonoTime::Now();</a>
<a name="ln1023">  }</a>
<a name="ln1024">}</a>
<a name="ln1025"> </a>
<a name="ln1026">void ScopedLatencyMetric::Finish() {</a>
<a name="ln1027">  if (latency_hist_ != nullptr) {</a>
<a name="ln1028">    auto passed = (MonoTime::Now() - time_started_).ToMicroseconds();</a>
<a name="ln1029">    latency_hist_-&gt;Increment(passed);</a>
<a name="ln1030">  }</a>
<a name="ln1031">}</a>
<a name="ln1032"> </a>
<a name="ln1033">// Replace specific chars with underscore to pass PrometheusNameRegex().</a>
<a name="ln1034">void EscapeMetricNameForPrometheus(std::string *id) {</a>
<a name="ln1035">  std::replace(id-&gt;begin(), id-&gt;end(), ' ', '_');</a>
<a name="ln1036">  std::replace(id-&gt;begin(), id-&gt;end(), '.', '_');</a>
<a name="ln1037">  std::replace(id-&gt;begin(), id-&gt;end(), '-', '_');</a>
<a name="ln1038">}</a>
<a name="ln1039"> </a>
<a name="ln1040">} // namespace yb</a>

</code></pre>
<div class="balloon" rel="215"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="391"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="404"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="411"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="443"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="522"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="846"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="849"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
