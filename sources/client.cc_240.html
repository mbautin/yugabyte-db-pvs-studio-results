
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>client.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Licensed to the Apache Software Foundation (ASF) under one</a>
<a name="ln2">// or more contributor license agreements.  See the NOTICE file</a>
<a name="ln3">// distributed with this work for additional information</a>
<a name="ln4">// regarding copyright ownership.  The ASF licenses this file</a>
<a name="ln5">// to you under the Apache License, Version 2.0 (the</a>
<a name="ln6">// &quot;License&quot;); you may not use this file except in compliance</a>
<a name="ln7">// with the License.  You may obtain a copy of the License at</a>
<a name="ln8">//</a>
<a name="ln9">//   http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln10">//</a>
<a name="ln11">// Unless required by applicable law or agreed to in writing,</a>
<a name="ln12">// software distributed under the License is distributed on an</a>
<a name="ln13">// &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</a>
<a name="ln14">// KIND, either express or implied.  See the License for the</a>
<a name="ln15">// specific language governing permissions and limitations</a>
<a name="ln16">// under the License.</a>
<a name="ln17">//</a>
<a name="ln18">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln19">//</a>
<a name="ln20">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln21">//</a>
<a name="ln22">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln23">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln24">//</a>
<a name="ln25">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln26">//</a>
<a name="ln27">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln28">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln29">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln30">// under the License.</a>
<a name="ln31">//</a>
<a name="ln32"> </a>
<a name="ln33">#include &quot;yb/client/client.h&quot;</a>
<a name="ln34"> </a>
<a name="ln35">#include &lt;algorithm&gt;</a>
<a name="ln36">#include &lt;mutex&gt;</a>
<a name="ln37">#include &lt;set&gt;</a>
<a name="ln38">#include &lt;unordered_map&gt;</a>
<a name="ln39">#include &lt;vector&gt;</a>
<a name="ln40">#include &lt;iostream&gt;</a>
<a name="ln41">#include &lt;limits&gt;</a>
<a name="ln42"> </a>
<a name="ln43">#include &quot;yb/gutil/map-util.h&quot;</a>
<a name="ln44">#include &quot;yb/gutil/strings/substitute.h&quot;</a>
<a name="ln45"> </a>
<a name="ln46">#include &quot;yb/client/client_utils.h&quot;</a>
<a name="ln47">#include &quot;yb/client/meta_cache.h&quot;</a>
<a name="ln48">#include &quot;yb/client/session.h&quot;</a>
<a name="ln49">#include &quot;yb/client/table_alterer.h&quot;</a>
<a name="ln50">#include &quot;yb/client/namespace_alterer.h&quot;</a>
<a name="ln51">#include &quot;yb/client/table_creator.h&quot;</a>
<a name="ln52">#include &quot;yb/client/tablet_server.h&quot;</a>
<a name="ln53">#include &quot;yb/client/yb_table_name.h&quot;</a>
<a name="ln54"> </a>
<a name="ln55">#include &quot;yb/common/common.pb.h&quot;</a>
<a name="ln56">#include &quot;yb/common/entity_ids.h&quot;</a>
<a name="ln57">#include &quot;yb/common/common_flags.h&quot;</a>
<a name="ln58">#include &quot;yb/common/partition.h&quot;</a>
<a name="ln59">#include &quot;yb/common/roles_permissions.h&quot;</a>
<a name="ln60">#include &quot;yb/common/wire_protocol.h&quot;</a>
<a name="ln61"> </a>
<a name="ln62">#include &quot;yb/master/master.proxy.h&quot;</a>
<a name="ln63">#include &quot;yb/master/master_defaults.h&quot;</a>
<a name="ln64">#include &quot;yb/master/master_error.h&quot;</a>
<a name="ln65">#include &quot;yb/master/master_util.h&quot;</a>
<a name="ln66">#include &quot;yb/util/monotime.h&quot;</a>
<a name="ln67">#include &quot;yb/yql/redis/redisserver/redis_constants.h&quot;</a>
<a name="ln68">#include &quot;yb/yql/redis/redisserver/redis_parser.h&quot;</a>
<a name="ln69">#include &quot;yb/rpc/messenger.h&quot;</a>
<a name="ln70">#include &quot;yb/rpc/yb_rpc.h&quot;</a>
<a name="ln71">#include &quot;yb/util/flag_tags.h&quot;</a>
<a name="ln72">#include &quot;yb/util/init.h&quot;</a>
<a name="ln73">#include &quot;yb/util/logging.h&quot;</a>
<a name="ln74">#include &quot;yb/util/net/dns_resolver.h&quot;</a>
<a name="ln75">#include &quot;yb/util/oid_generator.h&quot;</a>
<a name="ln76">#include &quot;yb/util/tsan_util.h&quot;</a>
<a name="ln77">#include &quot;yb/util/crypt.h&quot;</a>
<a name="ln78"> </a>
<a name="ln79">using yb::master::AlterTableRequestPB;</a>
<a name="ln80">using yb::master::AlterTableRequestPB_Step;</a>
<a name="ln81">using yb::master::AlterTableResponsePB;</a>
<a name="ln82">using yb::master::CreateTableRequestPB;</a>
<a name="ln83">using yb::master::CreateTableResponsePB;</a>
<a name="ln84">using yb::master::DeleteTableRequestPB;</a>
<a name="ln85">using yb::master::DeleteTableResponsePB;</a>
<a name="ln86">using yb::master::CreateTablegroupRequestPB;</a>
<a name="ln87">using yb::master::CreateTablegroupResponsePB;</a>
<a name="ln88">using yb::master::DeleteTablegroupRequestPB;</a>
<a name="ln89">using yb::master::DeleteTablegroupResponsePB;</a>
<a name="ln90">using yb::master::ListTablegroupsRequestPB;</a>
<a name="ln91">using yb::master::ListTablegroupsResponsePB;</a>
<a name="ln92">using yb::master::GetNamespaceInfoRequestPB;</a>
<a name="ln93">using yb::master::GetNamespaceInfoResponsePB;</a>
<a name="ln94">using yb::master::GetTableSchemaRequestPB;</a>
<a name="ln95">using yb::master::GetTableSchemaResponsePB;</a>
<a name="ln96">using yb::master::GetTableLocationsRequestPB;</a>
<a name="ln97">using yb::master::GetTableLocationsResponsePB;</a>
<a name="ln98">using yb::master::GetTabletLocationsRequestPB;</a>
<a name="ln99">using yb::master::GetTabletLocationsResponsePB;</a>
<a name="ln100">using yb::master::IsLoadBalancedRequestPB;</a>
<a name="ln101">using yb::master::IsLoadBalancedResponsePB;</a>
<a name="ln102">using yb::master::IsLoadBalancerIdleRequestPB;</a>
<a name="ln103">using yb::master::IsLoadBalancerIdleResponsePB;</a>
<a name="ln104">using yb::master::ListMastersRequestPB;</a>
<a name="ln105">using yb::master::ListMastersResponsePB;</a>
<a name="ln106">using yb::master::ListTablesRequestPB;</a>
<a name="ln107">using yb::master::ListTablesResponsePB;</a>
<a name="ln108">using yb::master::ListTablesResponsePB_TableInfo;</a>
<a name="ln109">using yb::master::ListTabletServersRequestPB;</a>
<a name="ln110">using yb::master::ListTabletServersResponsePB;</a>
<a name="ln111">using yb::master::ListTabletServersResponsePB_Entry;</a>
<a name="ln112">using yb::master::CreateNamespaceRequestPB;</a>
<a name="ln113">using yb::master::CreateNamespaceResponsePB;</a>
<a name="ln114">using yb::master::AlterNamespaceRequestPB;</a>
<a name="ln115">using yb::master::AlterNamespaceResponsePB;</a>
<a name="ln116">using yb::master::DeleteNamespaceRequestPB;</a>
<a name="ln117">using yb::master::DeleteNamespaceResponsePB;</a>
<a name="ln118">using yb::master::ListNamespacesRequestPB;</a>
<a name="ln119">using yb::master::ListNamespacesResponsePB;</a>
<a name="ln120">using yb::master::ReservePgsqlOidsRequestPB;</a>
<a name="ln121">using yb::master::ReservePgsqlOidsResponsePB;</a>
<a name="ln122">using yb::master::GetYsqlCatalogConfigRequestPB;</a>
<a name="ln123">using yb::master::GetYsqlCatalogConfigResponsePB;</a>
<a name="ln124">using yb::master::CreateUDTypeRequestPB;</a>
<a name="ln125">using yb::master::CreateUDTypeResponsePB;</a>
<a name="ln126">using yb::master::AlterRoleRequestPB;</a>
<a name="ln127">using yb::master::AlterRoleResponsePB;</a>
<a name="ln128">using yb::master::CreateRoleRequestPB;</a>
<a name="ln129">using yb::master::CreateRoleResponsePB;</a>
<a name="ln130">using yb::master::DeleteUDTypeRequestPB;</a>
<a name="ln131">using yb::master::DeleteUDTypeResponsePB;</a>
<a name="ln132">using yb::master::DeleteRoleRequestPB;</a>
<a name="ln133">using yb::master::DeleteRoleResponsePB;</a>
<a name="ln134">using yb::master::GetPermissionsRequestPB;</a>
<a name="ln135">using yb::master::GetPermissionsResponsePB;</a>
<a name="ln136">using yb::master::GrantRevokeRoleRequestPB;</a>
<a name="ln137">using yb::master::GrantRevokeRoleResponsePB;</a>
<a name="ln138">using yb::master::ListUDTypesRequestPB;</a>
<a name="ln139">using yb::master::ListUDTypesResponsePB;</a>
<a name="ln140">using yb::master::GetUDTypeInfoRequestPB;</a>
<a name="ln141">using yb::master::GetUDTypeInfoResponsePB;</a>
<a name="ln142">using yb::master::GrantRevokePermissionResponsePB;</a>
<a name="ln143">using yb::master::GrantRevokePermissionRequestPB;</a>
<a name="ln144">using yb::master::MasterServiceProxy;</a>
<a name="ln145">using yb::master::ReplicationInfoPB;</a>
<a name="ln146">using yb::master::TabletLocationsPB;</a>
<a name="ln147">using yb::master::RedisConfigSetRequestPB;</a>
<a name="ln148">using yb::master::RedisConfigSetResponsePB;</a>
<a name="ln149">using yb::master::RedisConfigGetRequestPB;</a>
<a name="ln150">using yb::master::RedisConfigGetResponsePB;</a>
<a name="ln151">using yb::master::CreateCDCStreamRequestPB;</a>
<a name="ln152">using yb::master::CreateCDCStreamResponsePB;</a>
<a name="ln153">using yb::master::DeleteCDCStreamRequestPB;</a>
<a name="ln154">using yb::master::DeleteCDCStreamResponsePB;</a>
<a name="ln155">using yb::master::GetCDCStreamRequestPB;</a>
<a name="ln156">using yb::master::GetCDCStreamResponsePB;</a>
<a name="ln157">using yb::master::ListCDCStreamsRequestPB;</a>
<a name="ln158">using yb::master::ListCDCStreamsResponsePB;</a>
<a name="ln159">using yb::rpc::Messenger;</a>
<a name="ln160">using yb::rpc::MessengerBuilder;</a>
<a name="ln161">using yb::rpc::RpcController;</a>
<a name="ln162">using yb::tserver::NoOpRequestPB;</a>
<a name="ln163">using yb::tserver::NoOpResponsePB;</a>
<a name="ln164">using yb::util::kBcryptHashSize;</a>
<a name="ln165">using std::set;</a>
<a name="ln166">using std::string;</a>
<a name="ln167">using std::vector;</a>
<a name="ln168">using google::protobuf::RepeatedPtrField;</a>
<a name="ln169"> </a>
<a name="ln170">using namespace yb::size_literals;  // NOLINT.</a>
<a name="ln171"> </a>
<a name="ln172">DEFINE_bool(client_suppress_created_logs, false,</a>
<a name="ln173">            &quot;Suppress 'Created table ...' messages&quot;);</a>
<a name="ln174">TAG_FLAG(client_suppress_created_logs, advanced);</a>
<a name="ln175">TAG_FLAG(client_suppress_created_logs, hidden);</a>
<a name="ln176"> </a>
<a name="ln177">DEFINE_test_flag(int32, yb_num_total_tablets, 0,</a>
<a name="ln178">                 &quot;The total number of tablets per table when a table is created.&quot;);</a>
<a name="ln179"> </a>
<a name="ln180">namespace yb {</a>
<a name="ln181">namespace client {</a>
<a name="ln182"> </a>
<a name="ln183">using internal::MetaCache;</a>
<a name="ln184">using ql::ObjectType;</a>
<a name="ln185">using std::shared_ptr;</a>
<a name="ln186"> </a>
<a name="ln187">#define CALL_SYNC_LEADER_MASTER_RPC(req, resp, method) \</a>
<a name="ln188">  do { \</a>
<a name="ln189">    auto deadline = CoarseMonoClock::Now() + default_admin_operation_timeout(); \</a>
<a name="ln190">    CALL_SYNC_LEADER_MASTER_RPC_WITH_DEADLINE(req, resp, deadline, method); \</a>
<a name="ln191">  } while(0);</a>
<a name="ln192"> </a>
<a name="ln193">#define CALL_SYNC_LEADER_MASTER_RPC_WITH_DEADLINE(req, resp, deadline, method) \</a>
<a name="ln194">  do { \</a>
<a name="ln195">    Status s = data_-&gt;SyncLeaderMasterRpc&lt;BOOST_PP_CAT(method, RequestPB), \</a>
<a name="ln196">                                          BOOST_PP_CAT(method, ResponsePB)&gt;( \</a>
<a name="ln197">        deadline, \</a>
<a name="ln198">        req, \</a>
<a name="ln199">        &amp;resp, \</a>
<a name="ln200">        nullptr, \</a>
<a name="ln201">        BOOST_PP_STRINGIZE(method), \</a>
<a name="ln202">        &amp;MasterServiceProxy::method); \</a>
<a name="ln203">    RETURN_NOT_OK(s); \</a>
<a name="ln204">    if (resp.has_error()) { \</a>
<a name="ln205">      return StatusFromPB(resp.error().status()); \</a>
<a name="ln206">    } \</a>
<a name="ln207">  } while(0);</a>
<a name="ln208"> </a>
<a name="ln209">// Adapts between the internal LogSeverity and the client's YBLogSeverity.</a>
<a name="ln210">static void LoggingAdapterCB(YBLoggingCallback* user_cb,</a>
<a name="ln211">                             LogSeverity severity,</a>
<a name="ln212">                             const char* filename,</a>
<a name="ln213">                             int line_number,</a>
<a name="ln214">                             const struct ::tm* time,</a>
<a name="ln215">                             const char* message,</a>
<a name="ln216">                             size_t message_len) {</a>
<a name="ln217">  YBLogSeverity client_severity;</a>
<a name="ln218">  switch (severity) {</a>
<a name="ln219">    case yb::SEVERITY_INFO:</a>
<a name="ln220">      client_severity = SEVERITY_INFO;</a>
<a name="ln221">      break;</a>
<a name="ln222">    case yb::SEVERITY_WARNING:</a>
<a name="ln223">      client_severity = SEVERITY_WARNING;</a>
<a name="ln224">      break;</a>
<a name="ln225">    case yb::SEVERITY_ERROR:</a>
<a name="ln226">      client_severity = SEVERITY_ERROR;</a>
<a name="ln227">      break;</a>
<a name="ln228">    case yb::SEVERITY_FATAL:</a>
<a name="ln229">      client_severity = SEVERITY_FATAL;</a>
<a name="ln230">      break;</a>
<a name="ln231">    default:</a>
<a name="ln232">      LOG(FATAL) &lt;&lt; &quot;Unknown YB log severity: &quot; &lt;&lt; severity;</a>
<a name="ln233">  }</a>
<a name="ln234">  user_cb-&gt;Run(client_severity, filename, line_number, time,</a>
<a name="ln235">               message, message_len);</a>
<a name="ln236">}</a>
<a name="ln237"> </a>
<a name="ln238">void InitLogging() {</a>
<a name="ln239">  InitGoogleLoggingSafeBasic(&quot;yb_client&quot;);</a>
<a name="ln240">}</a>
<a name="ln241"> </a>
<a name="ln242">void InstallLoggingCallback(YBLoggingCallback* cb) {</a>
<a name="ln243">  RegisterLoggingCallback(Bind(&amp;LoggingAdapterCB, Unretained(cb)));</a>
<a name="ln244">}</a>
<a name="ln245"> </a>
<a name="ln246">void UninstallLoggingCallback() {</a>
<a name="ln247">  UnregisterLoggingCallback();</a>
<a name="ln248">}</a>
<a name="ln249"> </a>
<a name="ln250">void SetVerboseLogLevel(int level) {</a>
<a name="ln251">  FLAGS_v = level;</a>
<a name="ln252">}</a>
<a name="ln253"> </a>
<a name="ln254">Status SetInternalSignalNumber(int signum) {</a>
<a name="ln255">  return SetStackTraceSignal(signum);</a>
<a name="ln256">}</a>
<a name="ln257"> </a>
<a name="ln258">YBClientBuilder::YBClientBuilder()</a>
<a name="ln259">  : data_(new YBClientBuilder::Data()) {</a>
<a name="ln260">}</a>
<a name="ln261"> </a>
<a name="ln262">YBClientBuilder::~YBClientBuilder() {</a>
<a name="ln263">}</a>
<a name="ln264"> </a>
<a name="ln265">YBClientBuilder&amp; YBClientBuilder::clear_master_server_addrs() {</a>
<a name="ln266">  data_-&gt;master_server_addrs_.clear();</a>
<a name="ln267">  return *this;</a>
<a name="ln268">}</a>
<a name="ln269"> </a>
<a name="ln270">YBClientBuilder&amp; YBClientBuilder::master_server_addrs(const vector&lt;string&gt;&amp; addrs) {</a>
<a name="ln271">  for (const string&amp; addr : addrs) {</a>
<a name="ln272">    data_-&gt;master_server_addrs_.push_back(addr);</a>
<a name="ln273">  }</a>
<a name="ln274">  return *this;</a>
<a name="ln275">}</a>
<a name="ln276"> </a>
<a name="ln277">YBClientBuilder&amp; YBClientBuilder::add_master_server_addr(const string&amp; addr) {</a>
<a name="ln278">  data_-&gt;master_server_addrs_.push_back(addr);</a>
<a name="ln279">  return *this;</a>
<a name="ln280">}</a>
<a name="ln281"> </a>
<a name="ln282">YBClientBuilder&amp; YBClientBuilder::add_master_server_endpoint(const string&amp; endpoint) {</a>
<a name="ln283">  data_-&gt;master_server_endpoint_ = endpoint;</a>
<a name="ln284">  return *this;</a>
<a name="ln285">}</a>
<a name="ln286"> </a>
<a name="ln287">YBClientBuilder&amp; YBClientBuilder::skip_master_flagfile(bool should_skip) {</a>
<a name="ln288">  data_-&gt;skip_master_flagfile_ = should_skip;</a>
<a name="ln289">  return *this;</a>
<a name="ln290">}</a>
<a name="ln291"> </a>
<a name="ln292">YBClientBuilder&amp; YBClientBuilder::wait_for_leader_election_on_init(bool should_wait) {</a>
<a name="ln293">  data_-&gt;wait_for_leader_election_on_init_ = should_wait;</a>
<a name="ln294">  return *this;</a>
<a name="ln295">}</a>
<a name="ln296"> </a>
<a name="ln297">YBClientBuilder&amp; YBClientBuilder::default_admin_operation_timeout(const MonoDelta&amp; timeout) {</a>
<a name="ln298">  data_-&gt;default_admin_operation_timeout_ = timeout;</a>
<a name="ln299">  return *this;</a>
<a name="ln300">}</a>
<a name="ln301"> </a>
<a name="ln302">YBClientBuilder&amp; YBClientBuilder::default_rpc_timeout(const MonoDelta&amp; timeout) {</a>
<a name="ln303">  data_-&gt;default_rpc_timeout_ = timeout;</a>
<a name="ln304">  return *this;</a>
<a name="ln305">}</a>
<a name="ln306"> </a>
<a name="ln307">YBClientBuilder&amp; YBClientBuilder::set_num_reactors(int32_t num_reactors) {</a>
<a name="ln308">  CHECK_GT(num_reactors, 0);</a>
<a name="ln309">  data_-&gt;num_reactors_ = num_reactors;</a>
<a name="ln310">  return *this;</a>
<a name="ln311">}</a>
<a name="ln312"> </a>
<a name="ln313">YBClientBuilder&amp; YBClientBuilder::set_cloud_info_pb(const CloudInfoPB&amp; cloud_info_pb) {</a>
<a name="ln314">  data_-&gt;cloud_info_pb_ = cloud_info_pb;</a>
<a name="ln315">  return *this;</a>
<a name="ln316">}</a>
<a name="ln317"> </a>
<a name="ln318">YBClientBuilder&amp; YBClientBuilder::set_metric_entity(</a>
<a name="ln319">    const scoped_refptr&lt;MetricEntity&gt;&amp; metric_entity) {</a>
<a name="ln320">  data_-&gt;metric_entity_ = metric_entity;</a>
<a name="ln321">  return *this;</a>
<a name="ln322">}</a>
<a name="ln323"> </a>
<a name="ln324">YBClientBuilder&amp; YBClientBuilder::set_client_name(const std::string&amp; name) {</a>
<a name="ln325">  data_-&gt;client_name_ = name;</a>
<a name="ln326">  return *this;</a>
<a name="ln327">}</a>
<a name="ln328"> </a>
<a name="ln329">YBClientBuilder&amp; YBClientBuilder::set_callback_threadpool_size(size_t size) {</a>
<a name="ln330">  data_-&gt;threadpool_size_ = size;</a>
<a name="ln331">  return *this;</a>
<a name="ln332">}</a>
<a name="ln333"> </a>
<a name="ln334">YBClientBuilder&amp; YBClientBuilder::set_tserver_uuid(const TabletServerId&amp; uuid) {</a>
<a name="ln335">  data_-&gt;uuid_ = uuid;</a>
<a name="ln336">  return *this;</a>
<a name="ln337">}</a>
<a name="ln338"> </a>
<a name="ln339">YBClientBuilder&amp; YBClientBuilder::set_parent_mem_tracker(const MemTrackerPtr&amp; mem_tracker) {</a>
<a name="ln340">  data_-&gt;parent_mem_tracker_ = mem_tracker;</a>
<a name="ln341">  return *this;</a>
<a name="ln342">}</a>
<a name="ln343"> </a>
<a name="ln344">YBClientBuilder&amp; YBClientBuilder::set_master_address_flag_name(const std::string&amp; value) {</a>
<a name="ln345">  data_-&gt;master_address_flag_name_ = value;</a>
<a name="ln346">  return *this;</a>
<a name="ln347">}</a>
<a name="ln348"> </a>
<a name="ln349">YBClientBuilder&amp; YBClientBuilder::set_skip_master_leader_resolution(bool value) {</a>
<a name="ln350">  data_-&gt;skip_master_leader_resolution_ = value;</a>
<a name="ln351">  return *this;</a>
<a name="ln352">}</a>
<a name="ln353"> </a>
<a name="ln354">YBClientBuilder&amp; YBClientBuilder::AddMasterAddressSource(const MasterAddressSource&amp; source) {</a>
<a name="ln355">  data_-&gt;master_address_sources_.push_back(source);</a>
<a name="ln356">  return *this;</a>
<a name="ln357">}</a>
<a name="ln358"> </a>
<a name="ln359">Status YBClientBuilder::DoBuild(rpc::Messenger* messenger, std::unique_ptr&lt;YBClient&gt;* client) {</a>
<a name="ln360">  RETURN_NOT_OK(CheckCPUFlags());</a>
<a name="ln361"> </a>
<a name="ln362">  std::unique_ptr&lt;YBClient&gt; c(new YBClient());</a>
<a name="ln363"> </a>
<a name="ln364">  // Init messenger.</a>
<a name="ln365">  if (messenger) {</a>
<a name="ln366">    c-&gt;data_-&gt;messenger_holder_ = nullptr;</a>
<a name="ln367">    c-&gt;data_-&gt;messenger_ = messenger;</a>
<a name="ln368">  } else {</a>
<a name="ln369">    c-&gt;data_-&gt;messenger_holder_ = VERIFY_RESULT(client::CreateClientMessenger(</a>
<a name="ln370">        data_-&gt;client_name_, data_-&gt;num_reactors_,</a>
<a name="ln371">        data_-&gt;metric_entity_, data_-&gt;parent_mem_tracker_));</a>
<a name="ln372">    c-&gt;data_-&gt;messenger_ = c-&gt;data_-&gt;messenger_holder_.get();</a>
<a name="ln373">  }</a>
<a name="ln374">  c-&gt;data_-&gt;proxy_cache_ = std::make_unique&lt;rpc::ProxyCache&gt;(c-&gt;data_-&gt;messenger_);</a>
<a name="ln375">  c-&gt;data_-&gt;metric_entity_ = data_-&gt;metric_entity_;</a>
<a name="ln376"> </a>
<a name="ln377">  c-&gt;data_-&gt;master_address_flag_name_ = data_-&gt;master_address_flag_name_;</a>
<a name="ln378">  c-&gt;data_-&gt;master_server_endpoint_ = data_-&gt;master_server_endpoint_;</a>
<a name="ln379">  c-&gt;data_-&gt;master_address_sources_ = data_-&gt;master_address_sources_;</a>
<a name="ln380">  c-&gt;data_-&gt;master_server_addrs_ = data_-&gt;master_server_addrs_;</a>
<a name="ln381">  c-&gt;data_-&gt;skip_master_flagfile_ = data_-&gt;skip_master_flagfile_;</a>
<a name="ln382">  c-&gt;data_-&gt;default_admin_operation_timeout_ = data_-&gt;default_admin_operation_timeout_;</a>
<a name="ln383">  c-&gt;data_-&gt;default_rpc_timeout_ = data_-&gt;default_rpc_timeout_;</a>
<a name="ln384">  c-&gt;data_-&gt;wait_for_leader_election_on_init_ = data_-&gt;wait_for_leader_election_on_init_;</a>
<a name="ln385"> </a>
<a name="ln386">  // Let's allow for plenty of time for discovering the master the first</a>
<a name="ln387">  // time around.</a>
<a name="ln388">  auto deadline = CoarseMonoClock::Now() + c-&gt;default_admin_operation_timeout();</a>
<a name="ln389">  for (;;) {</a>
<a name="ln390">    auto status = c-&gt;data_-&gt;SetMasterServerProxy(deadline,</a>
<a name="ln391">            data_-&gt;skip_master_leader_resolution_,</a>
<a name="ln392">            data_-&gt;wait_for_leader_election_on_init_);</a>
<a name="ln393">    if (status.ok()) {</a>
<a name="ln394">      break;</a>
<a name="ln395">    }</a>
<a name="ln396">    if (!status.IsNotFound() || CoarseMonoClock::Now() &gt;= deadline) {</a>
<a name="ln397">      RETURN_NOT_OK_PREPEND(status, &quot;Could not locate the leader master&quot;)</a>
<a name="ln398">    }</a>
<a name="ln399">  }</a>
<a name="ln400"> </a>
<a name="ln401">  c-&gt;data_-&gt;meta_cache_.reset(new MetaCache(c.get()));</a>
<a name="ln402"> </a>
<a name="ln403">  // Init local host names used for locality decisions.</a>
<a name="ln404">  RETURN_NOT_OK_PREPEND(c-&gt;data_-&gt;InitLocalHostNames(),</a>
<a name="ln405">                        &quot;Could not determine local host names&quot;);</a>
<a name="ln406">  c-&gt;data_-&gt;cloud_info_pb_ = data_-&gt;cloud_info_pb_;</a>
<a name="ln407">  c-&gt;data_-&gt;uuid_ = data_-&gt;uuid_;</a>
<a name="ln408">  if (data_-&gt;threadpool_size_ &gt; 0) {</a>
<a name="ln409">    ThreadPoolBuilder tpb(data_-&gt;client_name_ + &quot;_cb&quot;);</a>
<a name="ln410">    tpb.set_max_threads(data_-&gt;threadpool_size_);</a>
<a name="ln411">    std::unique_ptr&lt;ThreadPool&gt; tp;</a>
<a name="ln412">    RETURN_NOT_OK_PREPEND(tpb.Build(&amp;tp), &quot;Could not create callback threadpool&quot;);</a>
<a name="ln413">    c-&gt;data_-&gt;cb_threadpool_ = std::move(tp);</a>
<a name="ln414">  }</a>
<a name="ln415"> </a>
<a name="ln416">  client-&gt;swap(c);</a>
<a name="ln417">  return Status::OK();</a>
<a name="ln418">}</a>
<a name="ln419"> </a>
<a name="ln420">Result&lt;std::unique_ptr&lt;YBClient&gt;&gt; YBClientBuilder::Build(rpc::Messenger* messenger) {</a>
<a name="ln421">  std::unique_ptr&lt;YBClient&gt; client;</a>
<a name="ln422">  RETURN_NOT_OK(DoBuild(messenger, &amp;client));</a>
<a name="ln423">  return client;</a>
<a name="ln424">}</a>
<a name="ln425"> </a>
<a name="ln426">Result&lt;std::unique_ptr&lt;YBClient&gt;&gt; YBClientBuilder::Build(</a>
<a name="ln427">    std::unique_ptr&lt;rpc::Messenger&gt;&amp;&amp; messenger) {</a>
<a name="ln428">  std::unique_ptr&lt;YBClient&gt; client;</a>
<a name="ln429">  RETURN_NOT_OK(DoBuild(messenger.get(), &amp;client));</a>
<a name="ln430">  client-&gt;data_-&gt;messenger_holder_ = std::move(messenger);</a>
<a name="ln431">  return client;</a>
<a name="ln432">}</a>
<a name="ln433"> </a>
<a name="ln434">YBClient::YBClient() : data_(new YBClient::Data()) {</a>
<a name="ln435">  yb::InitCommonFlags();</a>
<a name="ln436">}</a>
<a name="ln437"> </a>
<a name="ln438">YBClient::~YBClient() {</a>
<a name="ln439">  Shutdown();</a>
<a name="ln440">}</a>
<a name="ln441"> </a>
<a name="ln442">void YBClient::Shutdown() {</a>
<a name="ln443">  data_-&gt;StartShutdown();</a>
<a name="ln444">  if (data_-&gt;messenger_holder_) {</a>
<a name="ln445">    data_-&gt;messenger_holder_-&gt;Shutdown();</a>
<a name="ln446">  }</a>
<a name="ln447">  if (data_-&gt;meta_cache_) {</a>
<a name="ln448">    data_-&gt;meta_cache_-&gt;Shutdown();</a>
<a name="ln449">  }</a>
<a name="ln450">  if (data_-&gt;cb_threadpool_) {</a>
<a name="ln451">    data_-&gt;cb_threadpool_-&gt;Shutdown();</a>
<a name="ln452">  }</a>
<a name="ln453">  data_-&gt;CompleteShutdown();</a>
<a name="ln454">}</a>
<a name="ln455"> </a>
<a name="ln456">std::unique_ptr&lt;YBTableCreator&gt; YBClient::NewTableCreator() {</a>
<a name="ln457">  return std::unique_ptr&lt;YBTableCreator&gt;(new YBTableCreator(this));</a>
<a name="ln458">}</a>
<a name="ln459"> </a>
<a name="ln460">Status YBClient::IsCreateTableInProgress(const YBTableName&amp; table_name,</a>
<a name="ln461">                                         bool *create_in_progress) {</a>
<a name="ln462">  auto deadline = CoarseMonoClock::Now() + default_admin_operation_timeout();</a>
<a name="ln463">  return data_-&gt;IsCreateTableInProgress(this, table_name, &quot;&quot; /* table_id */, deadline,</a>
<a name="ln464">                                        create_in_progress);</a>
<a name="ln465">}</a>
<a name="ln466"> </a>
<a name="ln467">Status YBClient::WaitForCreateTableToFinish(const YBTableName&amp; table_name) {</a>
<a name="ln468">  const auto deadline = CoarseMonoClock::Now() + default_admin_operation_timeout();</a>
<a name="ln469">  return WaitForCreateTableToFinish(table_name, deadline);</a>
<a name="ln470">}</a>
<a name="ln471"> </a>
<a name="ln472">Status YBClient::WaitForCreateTableToFinish(</a>
<a name="ln473">    const YBTableName&amp; table_name, const CoarseTimePoint&amp; deadline) {</a>
<a name="ln474">  return data_-&gt;WaitForCreateTableToFinish(this, table_name, &quot;&quot; /* table_id */, deadline);</a>
<a name="ln475">}</a>
<a name="ln476"> </a>
<a name="ln477">Status YBClient::WaitForCreateTableToFinish(const string&amp; table_id) {</a>
<a name="ln478">  const auto deadline = CoarseMonoClock::Now() + default_admin_operation_timeout();</a>
<a name="ln479">  return WaitForCreateTableToFinish(table_id, deadline);</a>
<a name="ln480">}</a>
<a name="ln481"> </a>
<a name="ln482">Status YBClient::WaitForCreateTableToFinish(</a>
<a name="ln483">    const string&amp; table_id, const CoarseTimePoint&amp; deadline) {</a>
<a name="ln484">  const YBTableName empty_table_name;</a>
<a name="ln485">  return data_-&gt;WaitForCreateTableToFinish(this, empty_table_name, table_id, deadline);</a>
<a name="ln486">}</a>
<a name="ln487"> </a>
<a name="ln488">Status YBClient::TruncateTable(const string&amp; table_id, bool wait) {</a>
<a name="ln489">  return TruncateTables({table_id}, wait);</a>
<a name="ln490">}</a>
<a name="ln491"> </a>
<a name="ln492">Status YBClient::TruncateTables(const vector&lt;string&gt;&amp; table_ids, bool wait) {</a>
<a name="ln493">  auto deadline = CoarseMonoClock::Now() + default_admin_operation_timeout();</a>
<a name="ln494">  return data_-&gt;TruncateTables(this, table_ids, deadline, wait);</a>
<a name="ln495">}</a>
<a name="ln496"> </a>
<a name="ln497">Status YBClient::DeleteTable(const YBTableName&amp; table_name, bool wait) {</a>
<a name="ln498">  auto deadline = CoarseMonoClock::Now() + default_admin_operation_timeout();</a>
<a name="ln499">  return data_-&gt;DeleteTable(this,</a>
<a name="ln500">                            table_name,</a>
<a name="ln501">                            &quot;&quot; /* table_id */,</a>
<a name="ln502">                            false /* is_index_table */,</a>
<a name="ln503">                            deadline,</a>
<a name="ln504">                            nullptr /* indexed_table_name */,</a>
<a name="ln505">                            wait);</a>
<a name="ln506">}</a>
<a name="ln507"> </a>
<a name="ln508">Status YBClient::DeleteTable(const string&amp; table_id, bool wait) {</a>
<a name="ln509">  auto deadline = CoarseMonoClock::Now() + default_admin_operation_timeout();</a>
<a name="ln510">  return data_-&gt;DeleteTable(this,</a>
<a name="ln511">                            YBTableName(),</a>
<a name="ln512">                            table_id,</a>
<a name="ln513">                            false /* is_index_table */,</a>
<a name="ln514">                            deadline,</a>
<a name="ln515">                            nullptr /* indexed_table_name */,</a>
<a name="ln516">                            wait);</a>
<a name="ln517">}</a>
<a name="ln518"> </a>
<a name="ln519">Status YBClient::DeleteIndexTable(const YBTableName&amp; table_name,</a>
<a name="ln520">                                  YBTableName* indexed_table_name,</a>
<a name="ln521">                                  bool wait) {</a>
<a name="ln522">  auto deadline = CoarseMonoClock::Now() + default_admin_operation_timeout();</a>
<a name="ln523">  return data_-&gt;DeleteTable(this,</a>
<a name="ln524">                            table_name,</a>
<a name="ln525">                            &quot;&quot; /* table_id */,</a>
<a name="ln526">                            true /* is_index_table */,</a>
<a name="ln527">                            deadline,</a>
<a name="ln528">                            indexed_table_name,</a>
<a name="ln529">                            wait);</a>
<a name="ln530">}</a>
<a name="ln531"> </a>
<a name="ln532">Status YBClient::DeleteIndexTable(const string&amp; table_id,</a>
<a name="ln533">                                  YBTableName* indexed_table_name,</a>
<a name="ln534">                                  bool wait) {</a>
<a name="ln535">  auto deadline = CoarseMonoClock::Now() + default_admin_operation_timeout();</a>
<a name="ln536">  return data_-&gt;DeleteTable(this,</a>
<a name="ln537">                            YBTableName(),</a>
<a name="ln538">                            table_id,</a>
<a name="ln539">                            true /* is_index_table */,</a>
<a name="ln540">                            deadline,</a>
<a name="ln541">                            indexed_table_name,</a>
<a name="ln542">                            wait);</a>
<a name="ln543">}</a>
<a name="ln544"> </a>
<a name="ln545">Status YBClient::FlushTables(const std::vector&lt;TableId&gt;&amp; table_ids,</a>
<a name="ln546">                             bool add_indexes,</a>
<a name="ln547">                             int timeout_secs,</a>
<a name="ln548">                             bool is_compaction) {</a>
<a name="ln549">  auto deadline = CoarseMonoClock::Now() + MonoDelta::FromSeconds(timeout_secs);</a>
<a name="ln550">  return data_-&gt;FlushTables(this,</a>
<a name="ln551">                            table_ids,</a>
<a name="ln552">                            add_indexes,</a>
<a name="ln553">                            deadline,</a>
<a name="ln554">                            is_compaction);</a>
<a name="ln555">}</a>
<a name="ln556"> </a>
<a name="ln557">Status YBClient::FlushTables(const std::vector&lt;YBTableName&gt;&amp; table_names,</a>
<a name="ln558">                             bool add_indexes,</a>
<a name="ln559">                             int timeout_secs,</a>
<a name="ln560">                             bool is_compaction) {</a>
<a name="ln561">  auto deadline = CoarseMonoClock::Now() + MonoDelta::FromSeconds(timeout_secs);</a>
<a name="ln562">  return data_-&gt;FlushTables(this,</a>
<a name="ln563">                            table_names,</a>
<a name="ln564">                            add_indexes,</a>
<a name="ln565">                            deadline,</a>
<a name="ln566">                            is_compaction);</a>
<a name="ln567">}</a>
<a name="ln568"> </a>
<a name="ln569">std::unique_ptr&lt;YBTableAlterer&gt; YBClient::NewTableAlterer(const YBTableName&amp; name) {</a>
<a name="ln570">  return std::unique_ptr&lt;YBTableAlterer&gt;(new YBTableAlterer(this, name));</a>
<a name="ln571">}</a>
<a name="ln572"> </a>
<a name="ln573">std::unique_ptr&lt;YBTableAlterer&gt; YBClient::NewTableAlterer(const string id) {</a>
<a name="ln574">  return std::unique_ptr&lt;YBTableAlterer&gt;(new YBTableAlterer(this, id));</a>
<a name="ln575">}</a>
<a name="ln576"> </a>
<a name="ln577">Status YBClient::IsAlterTableInProgress(const YBTableName&amp; table_name,</a>
<a name="ln578">                                        const string&amp; table_id,</a>
<a name="ln579">                                        bool *alter_in_progress) {</a>
<a name="ln580">  auto deadline = CoarseMonoClock::Now() + default_admin_operation_timeout();</a>
<a name="ln581">  return data_-&gt;IsAlterTableInProgress(this, table_name, table_id, deadline, alter_in_progress);</a>
<a name="ln582">}</a>
<a name="ln583"> </a>
<a name="ln584">Result&lt;YBTableInfo&gt; YBClient::GetYBTableInfo(const YBTableName&amp; table_name) {</a>
<a name="ln585">  YBTableInfo info;</a>
<a name="ln586">  auto deadline = CoarseMonoClock::Now() + default_admin_operation_timeout();</a>
<a name="ln587">  RETURN_NOT_OK(data_-&gt;GetTableSchema(this, table_name, deadline, &amp;info));</a>
<a name="ln588">  return info;</a>
<a name="ln589">}</a>
<a name="ln590"> </a>
<a name="ln591">Status YBClient::GetTableSchema(const YBTableName&amp; table_name,</a>
<a name="ln592">                                YBSchema* schema,</a>
<a name="ln593">                                PartitionSchema* partition_schema) {</a>
<a name="ln594">  Result&lt;YBTableInfo&gt; info = GetYBTableInfo(table_name);</a>
<a name="ln595">  if (!info.ok()) {</a>
<a name="ln596">    return info.status();</a>
<a name="ln597">  }</a>
<a name="ln598">  // Verify it is not an index table.</a>
<a name="ln599">  if (info-&gt;index_info) {</a>
<a name="ln600">    return STATUS(NotFound, &quot;The table does not exist&quot;);</a>
<a name="ln601">  }</a>
<a name="ln602"> </a>
<a name="ln603">  *schema = std::move(info-&gt;schema);</a>
<a name="ln604">  *partition_schema = std::move(info-&gt;partition_schema);</a>
<a name="ln605">  return Status::OK();</a>
<a name="ln606">}</a>
<a name="ln607"> </a>
<a name="ln608">Status YBClient::GetTableSchemaById(const TableId&amp; table_id, std::shared_ptr&lt;YBTableInfo&gt; info,</a>
<a name="ln609">                                    StatusCallback callback) {</a>
<a name="ln610">  auto deadline = CoarseMonoClock::Now() + default_admin_operation_timeout();</a>
<a name="ln611">  return data_-&gt;GetTableSchemaById(this, table_id, deadline, info, callback);</a>
<a name="ln612">}</a>
<a name="ln613"> </a>
<a name="ln614">Result&lt;IndexPermissions&gt; YBClient::GetIndexPermissions(</a>
<a name="ln615">    const TableId&amp; table_id,</a>
<a name="ln616">    const TableId&amp; index_id) {</a>
<a name="ln617">  auto deadline = CoarseMonoClock::Now() + default_admin_operation_timeout();</a>
<a name="ln618">  return data_-&gt;GetIndexPermissions(</a>
<a name="ln619">      this,</a>
<a name="ln620">      table_id,</a>
<a name="ln621">      index_id,</a>
<a name="ln622">      deadline);</a>
<a name="ln623">}</a>
<a name="ln624"> </a>
<a name="ln625">Result&lt;IndexPermissions&gt; YBClient::GetIndexPermissions(</a>
<a name="ln626">    const YBTableName&amp; table_name,</a>
<a name="ln627">    const YBTableName&amp; index_name) {</a>
<a name="ln628">  YBTableInfo table_info = VERIFY_RESULT(GetYBTableInfo(table_name));</a>
<a name="ln629">  YBTableInfo index_info = VERIFY_RESULT(GetYBTableInfo(index_name));</a>
<a name="ln630">  return GetIndexPermissions(table_info.table_id, index_info.table_id);</a>
<a name="ln631">}</a>
<a name="ln632"> </a>
<a name="ln633">Result&lt;IndexPermissions&gt; YBClient::WaitUntilIndexPermissionsAtLeast(</a>
<a name="ln634">    const TableId&amp; table_id,</a>
<a name="ln635">    const TableId&amp; index_id,</a>
<a name="ln636">    const IndexPermissions&amp; target_index_permissions) {</a>
<a name="ln637">  auto deadline = CoarseMonoClock::Now() + default_admin_operation_timeout();</a>
<a name="ln638">  return data_-&gt;WaitUntilIndexPermissionsAtLeast(</a>
<a name="ln639">      this,</a>
<a name="ln640">      table_id,</a>
<a name="ln641">      index_id,</a>
<a name="ln642">      deadline,</a>
<a name="ln643">      target_index_permissions);</a>
<a name="ln644">}</a>
<a name="ln645"> </a>
<a name="ln646">Result&lt;IndexPermissions&gt; YBClient::WaitUntilIndexPermissionsAtLeast(</a>
<a name="ln647">    const YBTableName&amp; table_name,</a>
<a name="ln648">    const YBTableName&amp; index_name,</a>
<a name="ln649">    const IndexPermissions&amp; target_index_permissions) {</a>
<a name="ln650">  YBTableInfo table_info = VERIFY_RESULT(GetYBTableInfo(table_name));</a>
<a name="ln651">  YBTableInfo index_info = VERIFY_RESULT(GetYBTableInfo(index_name));</a>
<a name="ln652">  return WaitUntilIndexPermissionsAtLeast(table_info.table_id,</a>
<a name="ln653">                                          index_info.table_id,</a>
<a name="ln654">                                          target_index_permissions);</a>
<a name="ln655">}</a>
<a name="ln656"> </a>
<a name="ln657">Status YBClient::AsyncUpdateIndexPermissions(const TableId&amp; indexed_table_id) {</a>
<a name="ln658">  auto deadline = CoarseMonoClock::Now() + default_admin_operation_timeout();</a>
<a name="ln659">  AlterTableRequestPB req;</a>
<a name="ln660">  req.mutable_table()-&gt;set_table_id(indexed_table_id);</a>
<a name="ln661">  req.set_force_send_alter_request(true);</a>
<a name="ln662">  return data_-&gt;AlterTable(this, req, deadline);</a>
<a name="ln663">}</a>
<a name="ln664"> </a>
<a name="ln665">Status YBClient::CreateNamespace(const std::string&amp; namespace_name,</a>
<a name="ln666">                                 const boost::optional&lt;YQLDatabase&gt;&amp; database_type,</a>
<a name="ln667">                                 const std::string&amp; creator_role_name,</a>
<a name="ln668">                                 const std::string&amp; namespace_id,</a>
<a name="ln669">                                 const std::string&amp; source_namespace_id,</a>
<a name="ln670">                                 const boost::optional&lt;uint32_t&gt;&amp; next_pg_oid,</a>
<a name="ln671">                                 const bool colocated) {</a>
<a name="ln672">  CreateNamespaceRequestPB req;</a>
<a name="ln673">  CreateNamespaceResponsePB resp;</a>
<a name="ln674">  req.set_name(namespace_name);</a>
<a name="ln675">  if (!creator_role_name.empty()) {</a>
<a name="ln676">    req.set_creator_role_name(creator_role_name);</a>
<a name="ln677">  }</a>
<a name="ln678">  if (database_type) {</a>
<a name="ln679">    req.set_database_type(*database_type);</a>
<a name="ln680">  }</a>
<a name="ln681">  if (!namespace_id.empty()) {</a>
<a name="ln682">    req.set_namespace_id(namespace_id);</a>
<a name="ln683">  }</a>
<a name="ln684">  if (!source_namespace_id.empty()) {</a>
<a name="ln685">    req.set_source_namespace_id(source_namespace_id);</a>
<a name="ln686">  }</a>
<a name="ln687">  if (next_pg_oid) {</a>
<a name="ln688">    req.set_next_pg_oid(*next_pg_oid);</a>
<a name="ln689">  }</a>
<a name="ln690">  req.set_colocated(colocated);</a>
<a name="ln691">  auto deadline = CoarseMonoClock::Now() + default_admin_operation_timeout();</a>
<a name="ln692">  Status s = data_-&gt;SyncLeaderMasterRpc&lt;CreateNamespaceRequestPB, CreateNamespaceResponsePB&gt;(</a>
<a name="ln693">        deadline, req, &amp;resp, nullptr, &quot;CreateNamespace&quot;, &amp;MasterServiceProxy::CreateNamespace);</a>
<a name="ln694">  if (resp.has_error()) {</a>
<a name="ln695">    s = StatusFromPB(resp.error().status());</a>
<a name="ln696">  }</a>
<a name="ln697">  RETURN_NOT_OK(s);</a>
<a name="ln698">  std::string cur_id = resp.has_id() ? resp.id() : namespace_id;</a>
<a name="ln699"> </a>
<a name="ln700">  // Verify that the namespace we found is running so that, once this request returns,</a>
<a name="ln701">  // the client can send operations without receiving a &quot;namespace not found&quot; error.</a>
<a name="ln702">  RETURN_NOT_OK(data_-&gt;WaitForCreateNamespaceToFinish(this, namespace_name, database_type, cur_id,</a>
<a name="ln703">      CoarseMonoClock::Now() + default_admin_operation_timeout()));</a>
<a name="ln704"> </a>
<a name="ln705">  return Status::OK();</a>
<a name="ln706">}</a>
<a name="ln707"> </a>
<a name="ln708">Status YBClient::CreateNamespaceIfNotExists(const std::string&amp; namespace_name,</a>
<a name="ln709">                                            const boost::optional&lt;YQLDatabase&gt;&amp; database_type,</a>
<a name="ln710">                                            const std::string&amp; creator_role_name,</a>
<a name="ln711">                                            const std::string&amp; namespace_id,</a>
<a name="ln712">                                            const std::string&amp; source_namespace_id,</a>
<a name="ln713">                                            const boost::optional&lt;uint32_t&gt;&amp; next_pg_oid,</a>
<a name="ln714">                                            const bool colocated) {</a>
<a name="ln715">  Result&lt;bool&gt; namespace_exists = (!namespace_id.empty() ? NamespaceIdExists(namespace_id)</a>
<a name="ln716">                                                         : NamespaceExists(namespace_name));</a>
<a name="ln717">  if (VERIFY_RESULT(namespace_exists)) {</a>
<a name="ln718">    // Verify that the namespace we found is running so that, once this request returns,</a>
<a name="ln719">    // the client can send operations without receiving a &quot;namespace not found&quot; error.</a>
<a name="ln720">    return data_-&gt;WaitForCreateNamespaceToFinish(this, namespace_name, database_type, namespace_id,</a>
<a name="ln721">        CoarseMonoClock::Now() + default_admin_operation_timeout());</a>
<a name="ln722">  }</a>
<a name="ln723"> </a>
<a name="ln724">  Status s = CreateNamespace(namespace_name, database_type, creator_role_name, namespace_id,</a>
<a name="ln725">                             source_namespace_id, next_pg_oid, colocated);</a>
<a name="ln726">  if (s.IsAlreadyPresent() &amp;&amp; database_type &amp;&amp; *database_type == YQLDatabase::YQL_DATABASE_CQL) {</a>
<a name="ln727">    return Status::OK();</a>
<a name="ln728">  }</a>
<a name="ln729">  return s;</a>
<a name="ln730">}</a>
<a name="ln731"> </a>
<a name="ln732">Status YBClient::IsCreateNamespaceInProgress(const std::string&amp; namespace_name,</a>
<a name="ln733">                                             const boost::optional&lt;YQLDatabase&gt;&amp; database_type,</a>
<a name="ln734">                                             const std::string&amp; namespace_id,</a>
<a name="ln735">                                             bool *create_in_progress) {</a>
<a name="ln736">  auto deadline = CoarseMonoClock::Now() + default_admin_operation_timeout();</a>
<a name="ln737">  return data_-&gt;IsCreateNamespaceInProgress(this, namespace_name, database_type, namespace_id,</a>
<a name="ln738">                                            deadline, create_in_progress);</a>
<a name="ln739">}</a>
<a name="ln740"> </a>
<a name="ln741">Status YBClient::DeleteNamespace(const std::string&amp; namespace_name,</a>
<a name="ln742">                                 const boost::optional&lt;YQLDatabase&gt;&amp; database_type,</a>
<a name="ln743">                                 const std::string&amp; namespace_id) {</a>
<a name="ln744">  DeleteNamespaceRequestPB req;</a>
<a name="ln745">  DeleteNamespaceResponsePB resp;</a>
<a name="ln746">  req.mutable_namespace_()-&gt;set_name(namespace_name);</a>
<a name="ln747">  if (!namespace_id.empty()) {</a>
<a name="ln748">    req.mutable_namespace_()-&gt;set_id(namespace_id);</a>
<a name="ln749">  }</a>
<a name="ln750">  if (database_type) {</a>
<a name="ln751">    req.set_database_type(*database_type);</a>
<a name="ln752">    req.mutable_namespace_()-&gt;set_database_type(*database_type);</a>
<a name="ln753">  }</a>
<a name="ln754">  auto deadline = CoarseMonoClock::Now() + default_admin_operation_timeout();</a>
<a name="ln755">  Status s = data_-&gt;SyncLeaderMasterRpc&lt;DeleteNamespaceRequestPB, DeleteNamespaceResponsePB&gt;(</a>
<a name="ln756">      deadline, req, &amp;resp, nullptr, &quot;DeleteNamespace&quot;, &amp;MasterServiceProxy::DeleteNamespace);</a>
<a name="ln757">  if (resp.has_error()) {</a>
<a name="ln758">    s = StatusFromPB(resp.error().status());</a>
<a name="ln759">  }</a>
<a name="ln760">  RETURN_NOT_OK(s);</a>
<a name="ln761"> </a>
<a name="ln762">  // Verify that, once this request returns, the namespace has been successfully marked as deleted.</a>
<a name="ln763">  RETURN_NOT_OK(data_-&gt;WaitForDeleteNamespaceToFinish(this, namespace_name, database_type,</a>
<a name="ln764">      namespace_id, CoarseMonoClock::Now() + default_admin_operation_timeout()));</a>
<a name="ln765"> </a>
<a name="ln766">  return Status::OK();</a>
<a name="ln767">}</a>
<a name="ln768"> </a>
<a name="ln769">Status YBClient::IsDeleteNamespaceInProgress(const std::string&amp; namespace_name,</a>
<a name="ln770">                                             const boost::optional&lt;YQLDatabase&gt;&amp; database_type,</a>
<a name="ln771">                                             const std::string&amp; namespace_id,</a>
<a name="ln772">                                             bool *delete_in_progress) {</a>
<a name="ln773">  auto deadline = CoarseMonoClock::Now() + default_admin_operation_timeout();</a>
<a name="ln774">  return data_-&gt;IsDeleteNamespaceInProgress(this, namespace_name, database_type, namespace_id,</a>
<a name="ln775">                                            deadline, delete_in_progress);</a>
<a name="ln776">}</a>
<a name="ln777"> </a>
<a name="ln778">YBNamespaceAlterer* YBClient::NewNamespaceAlterer(</a>
<a name="ln779">    const string&amp; namespace_name, const std::string&amp; namespace_id) {</a>
<a name="ln780">  return new YBNamespaceAlterer(this, namespace_name, namespace_id);</a>
<a name="ln781">}</a>
<a name="ln782"> </a>
<a name="ln783">Result&lt;vector&lt;master::NamespaceIdentifierPB&gt;&gt; YBClient::ListNamespaces(</a>
<a name="ln784">    const boost::optional&lt;YQLDatabase&gt;&amp; database_type) {</a>
<a name="ln785">  ListNamespacesRequestPB req;</a>
<a name="ln786">  ListNamespacesResponsePB resp;</a>
<a name="ln787">  if (database_type) {</a>
<a name="ln788">    req.set_database_type(*database_type);</a>
<a name="ln789">  }</a>
<a name="ln790">  CALL_SYNC_LEADER_MASTER_RPC(req, resp, ListNamespaces);</a>
<a name="ln791">  auto* namespaces = resp.mutable_namespaces();</a>
<a name="ln792">  vector&lt;master::NamespaceIdentifierPB&gt; result;</a>
<a name="ln793">  result.reserve(namespaces-&gt;size());</a>
<a name="ln794">  for (auto&amp; ns : *namespaces) {</a>
<a name="ln795">    result.push_back(std::move(ns));</a>
<a name="ln796">  }</a>
<a name="ln797">  return result;</a>
<a name="ln798">}</a>
<a name="ln799"> </a>
<a name="ln800">Status YBClient::GetNamespaceInfo(const std::string&amp; namespace_id,</a>
<a name="ln801">                                  const std::string&amp; namespace_name,</a>
<a name="ln802">                                  const boost::optional&lt;YQLDatabase&gt;&amp; database_type,</a>
<a name="ln803">                                  master::GetNamespaceInfoResponsePB* ret) {</a>
<a name="ln804">  GetNamespaceInfoRequestPB req;</a>
<a name="ln805">  GetNamespaceInfoResponsePB resp;</a>
<a name="ln806"> </a>
<a name="ln807">  if (!namespace_id.empty()) {</a>
<a name="ln808">    req.mutable_namespace_()-&gt;set_id(namespace_id);</a>
<a name="ln809">  }</a>
<a name="ln810">  if (!namespace_name.empty()) {</a>
<a name="ln811">    req.mutable_namespace_()-&gt;set_name(namespace_name);</a>
<a name="ln812">  }</a>
<a name="ln813">  if (database_type) {</a>
<a name="ln814">    req.mutable_namespace_()-&gt;set_database_type(*database_type);</a>
<a name="ln815">  }</a>
<a name="ln816"> </a>
<a name="ln817">  CALL_SYNC_LEADER_MASTER_RPC(req, resp, GetNamespaceInfo);</a>
<a name="ln818">  ret-&gt;Swap(&amp;resp);</a>
<a name="ln819">  return Status::OK();</a>
<a name="ln820">}</a>
<a name="ln821"> </a>
<a name="ln822">Status YBClient::ReservePgsqlOids(const std::string&amp; namespace_id,</a>
<a name="ln823">                                  const uint32_t next_oid, const uint32_t count,</a>
<a name="ln824">                                  uint32_t* begin_oid, uint32_t* end_oid) {</a>
<a name="ln825">  ReservePgsqlOidsRequestPB req;</a>
<a name="ln826">  ReservePgsqlOidsResponsePB resp;</a>
<a name="ln827">  req.set_namespace_id(namespace_id);</a>
<a name="ln828">  req.set_next_oid(next_oid);</a>
<a name="ln829">  req.set_count(count);</a>
<a name="ln830">  CALL_SYNC_LEADER_MASTER_RPC(req, resp, ReservePgsqlOids);</a>
<a name="ln831">  *begin_oid = resp.begin_oid();</a>
<a name="ln832">  *end_oid = resp.end_oid();</a>
<a name="ln833">  return Status::OK();</a>
<a name="ln834">}</a>
<a name="ln835"> </a>
<a name="ln836">Status YBClient::GetYsqlCatalogMasterVersion(uint64_t *ysql_catalog_version) {</a>
<a name="ln837">  GetYsqlCatalogConfigRequestPB req;</a>
<a name="ln838">  GetYsqlCatalogConfigResponsePB resp;</a>
<a name="ln839">  CALL_SYNC_LEADER_MASTER_RPC(req, resp, GetYsqlCatalogConfig);</a>
<a name="ln840">  *ysql_catalog_version = resp.version();</a>
<a name="ln841">  return Status::OK();</a>
<a name="ln842">}</a>
<a name="ln843"> </a>
<a name="ln844">Status YBClient::GrantRevokePermission(GrantRevokeStatementType statement_type,</a>
<a name="ln845">                                       const PermissionType&amp; permission,</a>
<a name="ln846">                                       const ResourceType&amp; resource_type,</a>
<a name="ln847">                                       const std::string&amp; canonical_resource,</a>
<a name="ln848">                                       const char* resource_name,</a>
<a name="ln849">                                       const char* namespace_name,</a>
<a name="ln850">                                       const std::string&amp; role_name) {</a>
<a name="ln851">  // Setting up request.</a>
<a name="ln852">  GrantRevokePermissionRequestPB req;</a>
<a name="ln853">  req.set_role_name(role_name);</a>
<a name="ln854">  req.set_canonical_resource(canonical_resource);</a>
<a name="ln855">  if (resource_name != nullptr) {</a>
<a name="ln856">    req.set_resource_name(resource_name);</a>
<a name="ln857">  }</a>
<a name="ln858">  if (namespace_name != nullptr) {</a>
<a name="ln859">    req.mutable_namespace_()-&gt;set_name(namespace_name);</a>
<a name="ln860">  }</a>
<a name="ln861">  req.set_resource_type(resource_type);</a>
<a name="ln862">  req.set_permission(permission);</a>
<a name="ln863"> </a>
<a name="ln864">  req.set_revoke(statement_type == GrantRevokeStatementType::REVOKE);</a>
<a name="ln865"> </a>
<a name="ln866">  GrantRevokePermissionResponsePB resp;</a>
<a name="ln867">  CALL_SYNC_LEADER_MASTER_RPC(req, resp, GrantRevokePermission);</a>
<a name="ln868">  return Status::OK();</a>
<a name="ln869">}</a>
<a name="ln870"> </a>
<a name="ln871">Result&lt;bool&gt; YBClient::NamespaceExists(const std::string&amp; namespace_name,</a>
<a name="ln872">                                       const boost::optional&lt;YQLDatabase&gt;&amp; database_type) {</a>
<a name="ln873">  for (const auto&amp; ns : VERIFY_RESULT(ListNamespaces(database_type))) {</a>
<a name="ln874">    if (ns.name() == namespace_name) {</a>
<a name="ln875">      return true;</a>
<a name="ln876">    }</a>
<a name="ln877">  }</a>
<a name="ln878">  return false;</a>
<a name="ln879">}</a>
<a name="ln880"> </a>
<a name="ln881">Result&lt;bool&gt; YBClient::NamespaceIdExists(const std::string&amp; namespace_id,</a>
<a name="ln882">                                         const boost::optional&lt;YQLDatabase&gt;&amp; database_type) {</a>
<a name="ln883">  for (const auto&amp; ns : VERIFY_RESULT(ListNamespaces(database_type))) {</a>
<a name="ln884">    if (ns.id() == namespace_id) {</a>
<a name="ln885">      return true;</a>
<a name="ln886">    }</a>
<a name="ln887">  }</a>
<a name="ln888">  return false;</a>
<a name="ln889">}</a>
<a name="ln890"> </a>
<a name="ln891">Status YBClient::CreateTablegroup(const std::string&amp; namespace_name,</a>
<a name="ln892">                                  const std::string&amp; namespace_id,</a>
<a name="ln893">                                  const std::string&amp; tablegroup_id) {</a>
<a name="ln894">  CreateTablegroupRequestPB req;</a>
<a name="ln895">  CreateTablegroupResponsePB resp;</a>
<a name="ln896">  req.set_id(tablegroup_id);</a>
<a name="ln897">  req.set_namespace_id(namespace_id);</a>
<a name="ln898">  req.set_namespace_name(namespace_name);</a>
<a name="ln899"> </a>
<a name="ln900">  int attempts = 0;</a>
<a name="ln901">  auto deadline = CoarseMonoClock::Now() + default_admin_operation_timeout();</a>
<a name="ln902"> </a>
<a name="ln903">  Status s = data_-&gt;SyncLeaderMasterRpc&lt;CreateTablegroupRequestPB, CreateTablegroupResponsePB&gt;(</a>
<a name="ln904">      deadline, req, &amp;resp, &amp;attempts, &quot;CreateTablegroup&quot;, &amp;MasterServiceProxy::CreateTablegroup);</a>
<a name="ln905"> </a>
<a name="ln906">  // This case should not happen but need to validate contents since fields are optional in PB.</a>
<a name="ln907">  if (!resp.has_parent_table_id() || !resp.has_parent_table_name()) {</a>
<a name="ln908">    return STATUS(NotFound, &quot;Parent table information not found in CREATE TABLEGROUP response.&quot;);</a>
<a name="ln909">  }</a>
<a name="ln910"> </a>
<a name="ln911">  const YBTableName table_name(YQL_DATABASE_PGSQL, namespace_name, resp.parent_table_name());</a>
<a name="ln912"> </a>
<a name="ln913">  // Handle special cases based on resp.error().</a>
<a name="ln914">  if (resp.has_error()) {</a>
<a name="ln915">    LOG_IF(DFATAL, s.ok()) &lt;&lt; &quot;Expecting error status if response has error: &quot; &lt;&lt;</a>
<a name="ln916">        resp.error().code() &lt;&lt; &quot; Status: &quot; &lt;&lt; resp.error().status().ShortDebugString();</a>
<a name="ln917"> </a>
<a name="ln918">    if (resp.error().code() == master::MasterErrorPB::OBJECT_ALREADY_PRESENT &amp;&amp; attempts &gt; 1) {</a>
<a name="ln919">      // If the table already exists and the number of attempts is &gt;</a>
<a name="ln920">      // 1, then it means we may have succeeded in creating the</a>
<a name="ln921">      // table, but client didn't receive the successful</a>
<a name="ln922">      // response (e.g., due to failure before the successful</a>
<a name="ln923">      // response could be sent back, or due to a I/O pause or a</a>
<a name="ln924">      // network blip leading to a timeout, etc...)</a>
<a name="ln925">      YBTableInfo info;</a>
<a name="ln926"> </a>
<a name="ln927">      // A fix for https://yugabyte.atlassian.net/browse/ENG-529:</a>
<a name="ln928">      // If we've been retrying table creation, and the table is now in the process is being</a>
<a name="ln929">      // created, we can sometimes see an empty schema. Wait until the table is fully created</a>
<a name="ln930">      // before we compare the schema.</a>
<a name="ln931">      RETURN_NOT_OK_PREPEND(</a>
<a name="ln932">          data_-&gt;WaitForCreateTableToFinish(this, table_name, resp.parent_table_id(), deadline),</a>
<a name="ln933">          strings::Substitute(&quot;Failed waiting for table $0 to finish being created&quot;,</a>
<a name="ln934">                              table_name.ToString()));</a>
<a name="ln935"> </a>
<a name="ln936">      RETURN_NOT_OK_PREPEND(</a>
<a name="ln937">          data_-&gt;GetTableSchema(this, table_name, deadline, &amp;info),</a>
<a name="ln938">          strings::Substitute(&quot;Unable to check the schema of table $0&quot;, table_name.ToString()));</a>
<a name="ln939"> </a>
<a name="ln940">      YBSchemaBuilder schemaBuilder;</a>
<a name="ln941">      schemaBuilder.AddColumn(&quot;parent_column&quot;)-&gt;Type(BINARY)-&gt;PrimaryKey()-&gt;NotNull();</a>
<a name="ln942">      YBSchema ybschema;</a>
<a name="ln943">      CHECK_OK(schemaBuilder.Build(&amp;ybschema));</a>
<a name="ln944"> </a>
<a name="ln945">      if (!ybschema.Equals(info.schema)) {</a>
<a name="ln946">         string msg = Format(&quot;Table $0 already exists with a different &quot;</a>
<a name="ln947">                             &quot;schema. Requested schema was: $1, actual schema is: $2&quot;,</a>
<a name="ln948">                             table_name,</a>
<a name="ln949">                             internal::GetSchema(ybschema),</a>
<a name="ln950">                             internal::GetSchema(info.schema));</a>
<a name="ln951">        LOG(ERROR) &lt;&lt; msg;</a>
<a name="ln952">        return STATUS(AlreadyPresent, msg);</a>
<a name="ln953">      }</a>
<a name="ln954"> </a>
<a name="ln955">      return Status::OK();</a>
<a name="ln956">    }</a>
<a name="ln957"> </a>
<a name="ln958">    return StatusFromPB(resp.error().status());</a>
<a name="ln959">  }</a>
<a name="ln960"> </a>
<a name="ln961">  // Wait for create table to finish.</a>
<a name="ln962">  RETURN_NOT_OK_PREPEND(</a>
<a name="ln963">      data_-&gt;WaitForCreateTableToFinish(this, table_name, resp.parent_table_id(), deadline),</a>
<a name="ln964">      strings::Substitute(&quot;Failed waiting for parent table $0 to finish being created&quot;,</a>
<a name="ln965">                          table_name.ToString()));</a>
<a name="ln966"> </a>
<a name="ln967">  return Status::OK();</a>
<a name="ln968">}</a>
<a name="ln969"> </a>
<a name="ln970">Status YBClient::DeleteTablegroup(const std::string&amp; namespace_id,</a>
<a name="ln971">                                  const std::string&amp; tablegroup_id) {</a>
<a name="ln972">  DeleteTablegroupRequestPB req;</a>
<a name="ln973">  DeleteTablegroupResponsePB resp;</a>
<a name="ln974">  req.set_id(tablegroup_id);</a>
<a name="ln975">  req.set_namespace_id(namespace_id);</a>
<a name="ln976"> </a>
<a name="ln977">  int attempts = 0;</a>
<a name="ln978">  auto deadline = CoarseMonoClock::Now() + default_admin_operation_timeout();</a>
<a name="ln979"> </a>
<a name="ln980">  Status s = data_-&gt;SyncLeaderMasterRpc&lt;DeleteTablegroupRequestPB, DeleteTablegroupResponsePB&gt;(</a>
<a name="ln981">      deadline, req, &amp;resp, &amp;attempts, &quot;DeleteTablegroup&quot;, &amp;MasterServiceProxy::DeleteTablegroup);</a>
<a name="ln982"> </a>
<a name="ln983">  // This case should not happen but need to validate contents since fields are optional in PB.</a>
<a name="ln984">  if (!resp.has_parent_table_id()) {</a>
<a name="ln985">    return STATUS(NotFound, &quot;Parent table information not found in DELETE TABLEGROUP response.&quot;);</a>
<a name="ln986">  }</a>
<a name="ln987"> </a>
<a name="ln988">  // Handle special cases based on resp.error().</a>
<a name="ln989">  if (resp.has_error()) {</a>
<a name="ln990">    LOG_IF(DFATAL, s.ok()) &lt;&lt; &quot;Expecting error status if response has error: &quot; &lt;&lt;</a>
<a name="ln991">        resp.error().code() &lt;&lt; &quot; Status: &quot; &lt;&lt; resp.error().status().ShortDebugString();</a>
<a name="ln992"> </a>
<a name="ln993">    if (resp.error().code() == master::MasterErrorPB::OBJECT_NOT_FOUND &amp;&amp; attempts &gt; 1) {</a>
<a name="ln994">      // A prior attempt to delete the table has succeeded, but</a>
<a name="ln995">      // appeared as a failure to the client due to, e.g., an I/O or</a>
<a name="ln996">      // network issue.</a>
<a name="ln997">      LOG(INFO) &lt;&lt; &quot;Parent table for tablegroup with ID &quot; &lt;&lt; tablegroup_id &lt;&lt; &quot; already deleted.&quot;;</a>
<a name="ln998">      return Status::OK();</a>
<a name="ln999">    } else {</a>
<a name="ln1000">      return StatusFromPB(resp.error().status());</a>
<a name="ln1001">    }</a>
<a name="ln1002">  } else {</a>
<a name="ln1003">    // Check the status only if the response has no error.</a>
<a name="ln1004">    RETURN_NOT_OK(s);</a>
<a name="ln1005">  }</a>
<a name="ln1006"> </a>
<a name="ln1007">  // Spin until the table is deleted. Currently only waits till the table reaches DELETING state</a>
<a name="ln1008">  // See github issue #5290</a>
<a name="ln1009">  RETURN_NOT_OK_PREPEND(data_-&gt;WaitForDeleteTableToFinish(this,</a>
<a name="ln1010">                                                          resp.parent_table_id(),</a>
<a name="ln1011">                                                          deadline),</a>
<a name="ln1012">      strings::Substitute(&quot;Failed waiting for parent table with id $0 to finish being deleted&quot;,</a>
<a name="ln1013">                          resp.parent_table_id()));</a>
<a name="ln1014"> </a>
<a name="ln1015">  LOG(INFO) &lt;&lt; &quot;Deleted parent table for tablegroup with ID &quot; &lt;&lt; tablegroup_id;</a>
<a name="ln1016">  return Status::OK();</a>
<a name="ln1017">}</a>
<a name="ln1018"> </a>
<a name="ln1019">Result&lt;vector&lt;master::TablegroupIdentifierPB&gt;&gt;</a>
<a name="ln1020">YBClient::ListTablegroups(const std::string&amp; namespace_name) {</a>
<a name="ln1021">  GetNamespaceInfoResponsePB ret;</a>
<a name="ln1022">  Status s = GetNamespaceInfo(&quot;&quot;, namespace_name, YQL_DATABASE_PGSQL, &amp;ret);</a>
<a name="ln1023">  if (!s.ok()) {</a>
<a name="ln1024">    return s;</a>
<a name="ln1025">  }</a>
<a name="ln1026"> </a>
<a name="ln1027">  ListTablegroupsRequestPB req;</a>
<a name="ln1028">  ListTablegroupsResponsePB resp;</a>
<a name="ln1029"> </a>
<a name="ln1030">  req.set_namespace_id(ret.namespace_().id());</a>
<a name="ln1031">  CALL_SYNC_LEADER_MASTER_RPC(req, resp, ListTablegroups);</a>
<a name="ln1032">  auto* tablegroups = resp.mutable_tablegroups();</a>
<a name="ln1033">  vector&lt;master::TablegroupIdentifierPB&gt; result;</a>
<a name="ln1034">  result.reserve(tablegroups-&gt;size());</a>
<a name="ln1035">  for (auto&amp; tg : *tablegroups) {</a>
<a name="ln1036">    result.push_back(std::move(tg));</a>
<a name="ln1037">  }</a>
<a name="ln1038">  return result;</a>
<a name="ln1039">}</a>
<a name="ln1040"> </a>
<a name="ln1041">Result&lt;bool&gt; YBClient::TablegroupExists(const std::string&amp; namespace_name,</a>
<a name="ln1042">                                        const std::string&amp; tablegroup_id) {</a>
<a name="ln1043"> </a>
<a name="ln1044">  for (const auto&amp; tg : VERIFY_RESULT(ListTablegroups(namespace_name))) {</a>
<a name="ln1045">    if (tg.id().compare(tablegroup_id) == 0) {</a>
<a name="ln1046">      return true;</a>
<a name="ln1047">    }</a>
<a name="ln1048">  }</a>
<a name="ln1049">  return false;</a>
<a name="ln1050">}</a>
<a name="ln1051"> </a>
<a name="ln1052">Status YBClient::GetUDType(const std::string&amp; namespace_name,</a>
<a name="ln1053">                           const std::string&amp; type_name,</a>
<a name="ln1054">                           std::shared_ptr&lt;QLType&gt;* ql_type) {</a>
<a name="ln1055">  // Setting up request.</a>
<a name="ln1056">  GetUDTypeInfoRequestPB req;</a>
<a name="ln1057">  req.mutable_type()-&gt;mutable_namespace_()-&gt;set_name(namespace_name);</a>
<a name="ln1058">  req.mutable_type()-&gt;set_type_name(type_name);</a>
<a name="ln1059"> </a>
<a name="ln1060">  // Sending request.</a>
<a name="ln1061">  GetUDTypeInfoResponsePB resp;</a>
<a name="ln1062">  CALL_SYNC_LEADER_MASTER_RPC(req, resp, GetUDTypeInfo);</a>
<a name="ln1063"> </a>
<a name="ln1064">  // Filling in return values.</a>
<a name="ln1065">  std::vector&lt;string&gt; field_names;</a>
<a name="ln1066">  for (const auto&amp; field_name : resp.udtype().field_names()) {</a>
<a name="ln1067">    field_names.push_back(field_name);</a>
<a name="ln1068">  }</a>
<a name="ln1069"> </a>
<a name="ln1070">  std::vector&lt;shared_ptr&lt;QLType&gt;&gt; field_types;</a>
<a name="ln1071">  for (const auto&amp; field_type : resp.udtype().field_types()) {</a>
<a name="ln1072">    field_types.push_back(QLType::FromQLTypePB(field_type));</a>
<a name="ln1073">  }</a>
<a name="ln1074"> </a>
<a name="ln1075">  (*ql_type)-&gt;SetUDTypeFields(resp.udtype().id(), field_names, field_types);</a>
<a name="ln1076"> </a>
<a name="ln1077">  return Status::OK();</a>
<a name="ln1078">}</a>
<a name="ln1079"> </a>
<a name="ln1080">Status YBClient::CreateRole(const RoleName&amp; role_name,</a>
<a name="ln1081">                            const std::string&amp; salted_hash,</a>
<a name="ln1082">                            const bool login, const bool superuser,</a>
<a name="ln1083">                            const RoleName&amp; creator_role_name) {</a>
<a name="ln1084"> </a>
<a name="ln1085">  // Setting up request.</a>
<a name="ln1086">  CreateRoleRequestPB req;</a>
<a name="ln1087">  req.set_salted_hash(salted_hash);</a>
<a name="ln1088">  req.set_name(role_name);</a>
<a name="ln1089">  req.set_login(login);</a>
<a name="ln1090">  req.set_superuser(superuser);</a>
<a name="ln1091"> </a>
<a name="ln1092">  if (!creator_role_name.empty()) {</a>
<a name="ln1093">    req.set_creator_role_name(creator_role_name);</a>
<a name="ln1094">  }</a>
<a name="ln1095"> </a>
<a name="ln1096">  CreateRoleResponsePB resp;</a>
<a name="ln1097">  CALL_SYNC_LEADER_MASTER_RPC(req, resp, CreateRole);</a>
<a name="ln1098">  return Status::OK();</a>
<a name="ln1099">}</a>
<a name="ln1100"> </a>
<a name="ln1101">Status YBClient::AlterRole(const RoleName&amp; role_name,</a>
<a name="ln1102">                           const boost::optional&lt;std::string&gt;&amp; salted_hash,</a>
<a name="ln1103">                           const boost::optional&lt;bool&gt; login,</a>
<a name="ln1104">                           const boost::optional&lt;bool&gt; superuser,</a>
<a name="ln1105">                           const RoleName&amp; current_role_name) {</a>
<a name="ln1106">  // Setting up request.</a>
<a name="ln1107">  AlterRoleRequestPB req;</a>
<a name="ln1108">  req.set_name(role_name);</a>
<a name="ln1109">  if (salted_hash) {</a>
<a name="ln1110">    req.set_salted_hash(*salted_hash);</a>
<a name="ln1111">  }</a>
<a name="ln1112">  if (login) {</a>
<a name="ln1113">    req.set_login(*login);</a>
<a name="ln1114">  }</a>
<a name="ln1115">  if (superuser) {</a>
<a name="ln1116">    req.set_superuser(*superuser);</a>
<a name="ln1117">  }</a>
<a name="ln1118">  req.set_current_role(current_role_name);</a>
<a name="ln1119"> </a>
<a name="ln1120">  AlterRoleResponsePB resp;</a>
<a name="ln1121">  CALL_SYNC_LEADER_MASTER_RPC(req, resp, AlterRole);</a>
<a name="ln1122">  return Status::OK();</a>
<a name="ln1123">}</a>
<a name="ln1124"> </a>
<a name="ln1125">Status YBClient::DeleteRole(const std::string&amp; role_name,</a>
<a name="ln1126">                            const std::string&amp; current_role_name) {</a>
<a name="ln1127">  // Setting up request.</a>
<a name="ln1128">  DeleteRoleRequestPB req;</a>
<a name="ln1129">  req.set_name(role_name);</a>
<a name="ln1130">  req.set_current_role(current_role_name);</a>
<a name="ln1131"> </a>
<a name="ln1132">  DeleteRoleResponsePB resp;</a>
<a name="ln1133">  CALL_SYNC_LEADER_MASTER_RPC(req, resp, DeleteRole);</a>
<a name="ln1134">  return Status::OK();</a>
<a name="ln1135">}</a>
<a name="ln1136"> </a>
<a name="ln1137">static const string kRequirePass = &quot;requirepass&quot;;</a>
<a name="ln1138">Status YBClient::SetRedisPasswords(const std::vector&lt;string&gt;&amp; passwords) {</a>
<a name="ln1139">  // TODO: Store hash instead of the password?</a>
<a name="ln1140">  return SetRedisConfig(kRequirePass, passwords);</a>
<a name="ln1141">}</a>
<a name="ln1142"> </a>
<a name="ln1143">Status YBClient::GetRedisPasswords(vector&lt;string&gt;* passwords) {</a>
<a name="ln1144">  Status s = GetRedisConfig(kRequirePass, passwords);</a>
<a name="ln1145">  if (s.IsNotFound()) {</a>
<a name="ln1146">    // If the redis config has no kRequirePass key.</a>
<a name="ln1147">    passwords-&gt;clear();</a>
<a name="ln1148">    s = Status::OK();</a>
<a name="ln1149">  }</a>
<a name="ln1150">  return s;</a>
<a name="ln1151">}</a>
<a name="ln1152"> </a>
<a name="ln1153">Status YBClient::SetRedisConfig(const string&amp; key, const vector&lt;string&gt;&amp; values) {</a>
<a name="ln1154">  // Setting up request.</a>
<a name="ln1155">  RedisConfigSetRequestPB req;</a>
<a name="ln1156">  req.set_keyword(key);</a>
<a name="ln1157">  for (const auto&amp; value : values) {</a>
<a name="ln1158">    req.add_args(value);</a>
<a name="ln1159">  }</a>
<a name="ln1160">  RedisConfigSetResponsePB resp;</a>
<a name="ln1161">  CALL_SYNC_LEADER_MASTER_RPC(req, resp, RedisConfigSet);</a>
<a name="ln1162">  return Status::OK();</a>
<a name="ln1163">}</a>
<a name="ln1164"> </a>
<a name="ln1165">Status YBClient::GetRedisConfig(const string&amp; key, vector&lt;string&gt;* values) {</a>
<a name="ln1166">  // Setting up request.</a>
<a name="ln1167">  RedisConfigGetRequestPB req;</a>
<a name="ln1168">  RedisConfigGetResponsePB resp;</a>
<a name="ln1169">  req.set_keyword(key);</a>
<a name="ln1170">  CALL_SYNC_LEADER_MASTER_RPC(req, resp, RedisConfigGet);</a>
<a name="ln1171">  values-&gt;clear();</a>
<a name="ln1172">  for (const auto&amp; arg : resp.args())</a>
<a name="ln1173">    values-&gt;push_back(arg);</a>
<a name="ln1174">  return Status::OK();</a>
<a name="ln1175">}</a>
<a name="ln1176"> </a>
<a name="ln1177">Status YBClient::GrantRevokeRole(GrantRevokeStatementType statement_type,</a>
<a name="ln1178">                                 const std::string&amp; granted_role_name,</a>
<a name="ln1179">                                 const std::string&amp; recipient_role_name) {</a>
<a name="ln1180">  // Setting up request.</a>
<a name="ln1181">  GrantRevokeRoleRequestPB req;</a>
<a name="ln1182">  req.set_revoke(statement_type == GrantRevokeStatementType::REVOKE);</a>
<a name="ln1183">  req.set_granted_role(granted_role_name);</a>
<a name="ln1184">  req.set_recipient_role(recipient_role_name);</a>
<a name="ln1185"> </a>
<a name="ln1186">  GrantRevokeRoleResponsePB resp;</a>
<a name="ln1187">  CALL_SYNC_LEADER_MASTER_RPC(req, resp, GrantRevokeRole);</a>
<a name="ln1188">  return Status::OK();</a>
<a name="ln1189">}</a>
<a name="ln1190"> </a>
<a name="ln1191">Status YBClient::GetPermissions(client::internal::PermissionsCache* permissions_cache) {</a>
<a name="ln1192">  if (!permissions_cache) {</a>
<a name="ln1193">    DFATAL_OR_RETURN_NOT_OK(STATUS(InvalidArgument, &quot;Invalid null permissions_cache&quot;));</a>
<a name="ln1194">  }</a>
<a name="ln1195"> </a>
<a name="ln1196">  boost::optional&lt;uint64_t&gt; version = permissions_cache-&gt;version();</a>
<a name="ln1197"> </a>
<a name="ln1198">  // Setting up request.</a>
<a name="ln1199">  GetPermissionsRequestPB req;</a>
<a name="ln1200">  if (version) {</a>
<a name="ln1201">    req.set_if_version_greater_than(*version);</a>
<a name="ln1202">  }</a>
<a name="ln1203"> </a>
<a name="ln1204">  GetPermissionsResponsePB resp;</a>
<a name="ln1205">  CALL_SYNC_LEADER_MASTER_RPC(req, resp, GetPermissions);</a>
<a name="ln1206"> </a>
<a name="ln1207">  VLOG(1) &lt;&lt; &quot;Got permissions cache: &quot; &lt;&lt; resp.ShortDebugString();</a>
<a name="ln1208"> </a>
<a name="ln1209">  // The first request is a special case. We always replace the cache since we don't have anything.</a>
<a name="ln1210">  if (!version) {</a>
<a name="ln1211">    // We should at least receive cassandra's permissions.</a>
<a name="ln1212">    if (resp.role_permissions_size() == 0) {</a>
<a name="ln1213">      DFATAL_OR_RETURN_NOT_OK(</a>
<a name="ln1214">          STATUS(IllegalState, &quot;Received invalid empty permissions cache from master&quot;));</a>
<a name="ln1215"> </a>
<a name="ln1216">    }</a>
<a name="ln1217">  } else if (resp.version() == *version) {</a>
<a name="ln1218">      // No roles should have been received if both versions match.</a>
<a name="ln1219">      if (resp.role_permissions_size() != 0) {</a>
<a name="ln1220">        DFATAL_OR_RETURN_NOT_OK(STATUS(IllegalState,</a>
<a name="ln1221">            &quot;Received permissions cache when none was expected because the master's &quot;</a>
<a name="ln1222">            &quot;permissions versions is equal to the client's version&quot;));</a>
<a name="ln1223">      }</a>
<a name="ln1224">      // Nothing to update.</a>
<a name="ln1225">      return Status::OK();</a>
<a name="ln1226">  } else if (resp.version() &lt; *version) {</a>
<a name="ln1227">    // If the versions don't match, then the master's version has to be greater than ours.</a>
<a name="ln1228">    DFATAL_OR_RETURN_NOT_OK(STATUS_SUBSTITUTE(IllegalState,</a>
<a name="ln1229">        &quot;Client's permissions version $0 can't be greater than the master's permissions version $1&quot;,</a>
<a name="ln1230">        *version, resp.version()));</a>
<a name="ln1231">  }</a>
<a name="ln1232"> </a>
<a name="ln1233">  permissions_cache-&gt;UpdateRolesPermissions(resp);</a>
<a name="ln1234">  return Status::OK();</a>
<a name="ln1235">}</a>
<a name="ln1236"> </a>
<a name="ln1237">Status YBClient::CreateUDType(const std::string&amp; namespace_name,</a>
<a name="ln1238">                              const std::string&amp; type_name,</a>
<a name="ln1239">                              const std::vector&lt;std::string&gt;&amp; field_names,</a>
<a name="ln1240">                              const std::vector&lt;std::shared_ptr&lt;QLType&gt;&gt;&amp; field_types) {</a>
<a name="ln1241">  // Setting up request.</a>
<a name="ln1242">  CreateUDTypeRequestPB req;</a>
<a name="ln1243">  req.mutable_namespace_()-&gt;set_name(namespace_name);</a>
<a name="ln1244">  req.set_name(type_name);</a>
<a name="ln1245">  for (const string&amp; field_name : field_names) {</a>
<a name="ln1246">    req.add_field_names(field_name);</a>
<a name="ln1247">  }</a>
<a name="ln1248">  for (const std::shared_ptr&lt;QLType&gt;&amp; field_type : field_types) {</a>
<a name="ln1249">    field_type-&gt;ToQLTypePB(req.add_field_types());</a>
<a name="ln1250">  }</a>
<a name="ln1251"> </a>
<a name="ln1252">  CreateUDTypeResponsePB resp;</a>
<a name="ln1253">  CALL_SYNC_LEADER_MASTER_RPC(req, resp, CreateUDType);</a>
<a name="ln1254">  return Status::OK();</a>
<a name="ln1255">}</a>
<a name="ln1256"> </a>
<a name="ln1257">Status YBClient::DeleteUDType(const std::string&amp; namespace_name,</a>
<a name="ln1258">                              const std::string&amp; type_name) {</a>
<a name="ln1259">  // Setting up request.</a>
<a name="ln1260">  DeleteUDTypeRequestPB req;</a>
<a name="ln1261">  req.mutable_type()-&gt;mutable_namespace_()-&gt;set_name(namespace_name);</a>
<a name="ln1262">  req.mutable_type()-&gt;set_type_name(type_name);</a>
<a name="ln1263"> </a>
<a name="ln1264">  DeleteUDTypeResponsePB resp;</a>
<a name="ln1265">  CALL_SYNC_LEADER_MASTER_RPC(req, resp, DeleteUDType);</a>
<a name="ln1266">  return Status::OK();</a>
<a name="ln1267">}</a>
<a name="ln1268"> </a>
<a name="ln1269">Result&lt;CDCStreamId&gt; YBClient::CreateCDCStream(</a>
<a name="ln1270">    const TableId&amp; table_id,</a>
<a name="ln1271">    const std::unordered_map&lt;std::string, std::string&gt;&amp; options) {</a>
<a name="ln1272">  // Setting up request.</a>
<a name="ln1273">  CreateCDCStreamRequestPB req;</a>
<a name="ln1274">  req.set_table_id(table_id);</a>
<a name="ln1275">  req.mutable_options()-&gt;Reserve(options.size());</a>
<a name="ln1276">  for (const auto&amp; option : options) {</a>
<a name="ln1277">    auto new_option = req.add_options();</a>
<a name="ln1278">    new_option-&gt;set_key(option.first);</a>
<a name="ln1279">    new_option-&gt;set_value(option.second);</a>
<a name="ln1280">  }</a>
<a name="ln1281"> </a>
<a name="ln1282">  CreateCDCStreamResponsePB resp;</a>
<a name="ln1283">  CALL_SYNC_LEADER_MASTER_RPC(req, resp, CreateCDCStream);</a>
<a name="ln1284">  return resp.stream_id();</a>
<a name="ln1285">}</a>
<a name="ln1286"> </a>
<a name="ln1287">void YBClient::CreateCDCStream(const TableId&amp; table_id,</a>
<a name="ln1288">                               const std::unordered_map&lt;std::string, std::string&gt;&amp; options,</a>
<a name="ln1289">                               CreateCDCStreamCallback callback) {</a>
<a name="ln1290">  auto deadline = CoarseMonoClock::Now() + default_admin_operation_timeout();</a>
<a name="ln1291">  data_-&gt;CreateCDCStream(this, table_id, options, deadline, callback);</a>
<a name="ln1292">}</a>
<a name="ln1293"> </a>
<a name="ln1294">Status YBClient::GetCDCStream(const CDCStreamId&amp; stream_id,</a>
<a name="ln1295">                              TableId* table_id,</a>
<a name="ln1296">                              std::unordered_map&lt;std::string, std::string&gt;* options) {</a>
<a name="ln1297">  // Setting up request.</a>
<a name="ln1298">  GetCDCStreamRequestPB req;</a>
<a name="ln1299">  req.set_stream_id(stream_id);</a>
<a name="ln1300"> </a>
<a name="ln1301">  // Sending request.</a>
<a name="ln1302">  GetCDCStreamResponsePB resp;</a>
<a name="ln1303">  CALL_SYNC_LEADER_MASTER_RPC(req, resp, GetCDCStream);</a>
<a name="ln1304"> </a>
<a name="ln1305">  // Filling in return values.</a>
<a name="ln1306">  *table_id = resp.stream().table_id();</a>
<a name="ln1307"> </a>
<a name="ln1308">  options-&gt;clear();</a>
<a name="ln1309">  options-&gt;reserve(resp.stream().options_size());</a>
<a name="ln1310">  for (const auto&amp; option : resp.stream().options()) {</a>
<a name="ln1311">    options-&gt;emplace(option.key(), option.value());</a>
<a name="ln1312">  }</a>
<a name="ln1313"> </a>
<a name="ln1314">  return Status::OK();</a>
<a name="ln1315">}</a>
<a name="ln1316"> </a>
<a name="ln1317">void YBClient::GetCDCStream(const CDCStreamId&amp; stream_id,</a>
<a name="ln1318">                            std::shared_ptr&lt;TableId&gt; table_id,</a>
<a name="ln1319">                            std::shared_ptr&lt;std::unordered_map&lt;std::string, std::string&gt;&gt; options,</a>
<a name="ln1320">                            StdStatusCallback callback) {</a>
<a name="ln1321">  auto deadline = CoarseMonoClock::Now() + default_admin_operation_timeout();</a>
<a name="ln1322">  data_-&gt;GetCDCStream(this, stream_id, table_id, options, deadline, callback);</a>
<a name="ln1323">}</a>
<a name="ln1324"> </a>
<a name="ln1325">Status YBClient::DeleteCDCStream(const vector&lt;CDCStreamId&gt;&amp; streams) {</a>
<a name="ln1326">  if (streams.empty()) {</a>
<a name="ln1327">    return STATUS(InvalidArgument, &quot;At least one stream id should be provided&quot;);</a>
<a name="ln1328">  }</a>
<a name="ln1329"> </a>
<a name="ln1330">  // Setting up request.</a>
<a name="ln1331">  DeleteCDCStreamRequestPB req;</a>
<a name="ln1332">  req.mutable_stream_id()-&gt;Reserve(streams.size());</a>
<a name="ln1333">  for (const auto&amp; stream : streams) {</a>
<a name="ln1334">    req.add_stream_id(stream);</a>
<a name="ln1335">  }</a>
<a name="ln1336"> </a>
<a name="ln1337">  DeleteCDCStreamResponsePB resp;</a>
<a name="ln1338">  CALL_SYNC_LEADER_MASTER_RPC(req, resp, DeleteCDCStream);</a>
<a name="ln1339">  return Status::OK();</a>
<a name="ln1340">}</a>
<a name="ln1341"> </a>
<a name="ln1342">Status YBClient::DeleteCDCStream(const CDCStreamId&amp; stream_id) {</a>
<a name="ln1343">  // Setting up request.</a>
<a name="ln1344">  DeleteCDCStreamRequestPB req;</a>
<a name="ln1345">  req.add_stream_id(stream_id);</a>
<a name="ln1346"> </a>
<a name="ln1347">  DeleteCDCStreamResponsePB resp;</a>
<a name="ln1348">  CALL_SYNC_LEADER_MASTER_RPC(req, resp, DeleteCDCStream);</a>
<a name="ln1349">  return Status::OK();</a>
<a name="ln1350">}</a>
<a name="ln1351"> </a>
<a name="ln1352">void YBClient::DeleteCDCStream(const CDCStreamId&amp; stream_id, StatusCallback callback) {</a>
<a name="ln1353">  auto deadline = CoarseMonoClock::Now() + default_admin_operation_timeout();</a>
<a name="ln1354">  data_-&gt;DeleteCDCStream(this, stream_id, deadline, callback);</a>
<a name="ln1355">}</a>
<a name="ln1356"> </a>
<a name="ln1357">Status YBClient::TabletServerCount(int *tserver_count, bool primary_only, bool use_cache) {</a>
<a name="ln1358">  int tserver_count_cached = data_-&gt;tserver_count_cached_.load(std::memory_order_acquire);</a>
<a name="ln1359">  if (use_cache &amp;&amp; tserver_count_cached &gt; 0) {</a>
<a name="ln1360">    *tserver_count = tserver_count_cached;</a>
<a name="ln1361">    return Status::OK();</a>
<a name="ln1362">  }</a>
<a name="ln1363"> </a>
<a name="ln1364">  ListTabletServersRequestPB req;</a>
<a name="ln1365">  ListTabletServersResponsePB resp;</a>
<a name="ln1366">  req.set_primary_only(primary_only);</a>
<a name="ln1367">  CALL_SYNC_LEADER_MASTER_RPC(req, resp, ListTabletServers);</a>
<a name="ln1368">  data_-&gt;tserver_count_cached_.store(resp.servers_size(), std::memory_order_release);</a>
<a name="ln1369">  *tserver_count = resp.servers_size();</a>
<a name="ln1370">  return Status::OK();</a>
<a name="ln1371">}</a>
<a name="ln1372"> </a>
<a name="ln1373">Status YBClient::ListTabletServers(vector&lt;std::unique_ptr&lt;YBTabletServer&gt;&gt;* tablet_servers) {</a>
<a name="ln1374">  ListTabletServersRequestPB req;</a>
<a name="ln1375">  ListTabletServersResponsePB resp;</a>
<a name="ln1376">  CALL_SYNC_LEADER_MASTER_RPC(req, resp, ListTabletServers);</a>
<a name="ln1377">  for (int i = 0; i &lt; resp.servers_size(); i++) {</a>
<a name="ln1378">    const ListTabletServersResponsePB_Entry&amp; e = resp.servers(i);</a>
<a name="ln1379">    auto ts = std::make_unique&lt;YBTabletServer&gt;(</a>
<a name="ln1380">        e.instance_id().permanent_uuid(),</a>
<a name="ln1381">        DesiredHostPort(e.registration().common(), data_-&gt;cloud_info_pb_).host());</a>
<a name="ln1382">    tablet_servers-&gt;push_back(std::move(ts));</a>
<a name="ln1383">  }</a>
<a name="ln1384">  return Status::OK();</a>
<a name="ln1385">}</a>
<a name="ln1386"> </a>
<a name="ln1387">void YBClient::SetLocalTabletServer(const string&amp; ts_uuid,</a>
<a name="ln1388">                                    const shared_ptr&lt;tserver::TabletServerServiceProxy&gt;&amp; proxy,</a>
<a name="ln1389">                                    const tserver::LocalTabletServer* local_tserver) {</a>
<a name="ln1390">  data_-&gt;meta_cache_-&gt;SetLocalTabletServer(ts_uuid, proxy, local_tserver);</a>
<a name="ln1391">}</a>
<a name="ln1392"> </a>
<a name="ln1393">Result&lt;bool&gt; YBClient::IsLoadBalanced(uint32_t num_servers) {</a>
<a name="ln1394">  IsLoadBalancedRequestPB req;</a>
<a name="ln1395">  IsLoadBalancedResponsePB resp;</a>
<a name="ln1396"> </a>
<a name="ln1397">  req.set_expected_num_servers(num_servers);</a>
<a name="ln1398">  // Cannot use CALL_SYNC_LEADER_MASTER_RPC directly since this is substituted with RETURN_NOT_OK</a>
<a name="ln1399">  // and we want to capture the status to check if load is balanced.</a>
<a name="ln1400">  Status s = [&amp;, this]() -&gt; Status {</a>
<a name="ln1401">    CALL_SYNC_LEADER_MASTER_RPC(req, resp, IsLoadBalanced);</a>
<a name="ln1402">    return Status::OK();</a>
<a name="ln1403">  }();</a>
<a name="ln1404">  return s.ok();</a>
<a name="ln1405">}</a>
<a name="ln1406"> </a>
<a name="ln1407">Result&lt;bool&gt; YBClient::IsLoadBalancerIdle() {</a>
<a name="ln1408">  IsLoadBalancerIdleRequestPB req;</a>
<a name="ln1409">  IsLoadBalancerIdleResponsePB resp;</a>
<a name="ln1410"> </a>
<a name="ln1411">  Status s = [&amp;]() -&gt; Status {</a>
<a name="ln1412">    CALL_SYNC_LEADER_MASTER_RPC(req, resp, IsLoadBalancerIdle);</a>
<a name="ln1413">    return Status::OK();</a>
<a name="ln1414">  }();</a>
<a name="ln1415"> </a>
<a name="ln1416">  if (s.ok()) {</a>
<a name="ln1417">    return true;</a>
<a name="ln1418">  } else if (master::MasterError(s) == master::MasterErrorPB::LOAD_BALANCER_RECENTLY_ACTIVE) {</a>
<a name="ln1419">    return false;</a>
<a name="ln1420">  } else {</a>
<a name="ln1421">    return s;</a>
<a name="ln1422">  }</a>
<a name="ln1423">}</a>
<a name="ln1424"> </a>
<a name="ln1425">Status YBClient::GetTabletsFromTableId(const string&amp; table_id,</a>
<a name="ln1426">                                       const int32_t max_tablets,</a>
<a name="ln1427">                                       RepeatedPtrField&lt;TabletLocationsPB&gt;* tablets) {</a>
<a name="ln1428">  GetTableLocationsRequestPB req;</a>
<a name="ln1429">  GetTableLocationsResponsePB resp;</a>
<a name="ln1430">  req.mutable_table()-&gt;set_table_id(table_id);</a>
<a name="ln1431"> </a>
<a name="ln1432">  if (max_tablets == 0) {</a>
<a name="ln1433">    req.set_max_returned_locations(std::numeric_limits&lt;int32_t&gt;::max());</a>
<a name="ln1434">  } else if (max_tablets &gt; 0) {</a>
<a name="ln1435">    req.set_max_returned_locations(max_tablets);</a>
<a name="ln1436">  }</a>
<a name="ln1437">  CALL_SYNC_LEADER_MASTER_RPC(req, resp, GetTableLocations);</a>
<a name="ln1438">  *tablets = resp.tablet_locations();</a>
<a name="ln1439">  return Status::OK();</a>
<a name="ln1440">}</a>
<a name="ln1441"> </a>
<a name="ln1442">Status YBClient::GetTablets(const YBTableName&amp; table_name,</a>
<a name="ln1443">                            const int32_t max_tablets,</a>
<a name="ln1444">                            RepeatedPtrField&lt;TabletLocationsPB&gt;* tablets,</a>
<a name="ln1445">                            const RequireTabletsRunning require_tablets_running) {</a>
<a name="ln1446">  GetTableLocationsRequestPB req;</a>
<a name="ln1447">  GetTableLocationsResponsePB resp;</a>
<a name="ln1448">  if (table_name.has_table()) {</a>
<a name="ln1449">    table_name.SetIntoTableIdentifierPB(req.mutable_table());</a>
<a name="ln1450">  } else if (table_name.has_table_id()) {</a>
<a name="ln1451">    req.mutable_table()-&gt;set_table_id(table_name.table_id());</a>
<a name="ln1452">  }</a>
<a name="ln1453"> </a>
<a name="ln1454">  if (max_tablets == 0) {</a>
<a name="ln1455">    req.set_max_returned_locations(std::numeric_limits&lt;int32_t&gt;::max());</a>
<a name="ln1456">  } else if (max_tablets &gt; 0) {</a>
<a name="ln1457">    req.set_max_returned_locations(max_tablets);</a>
<a name="ln1458">  }</a>
<a name="ln1459">  req.set_require_tablets_running(require_tablets_running);</a>
<a name="ln1460">  CALL_SYNC_LEADER_MASTER_RPC(req, resp, GetTableLocations);</a>
<a name="ln1461">  *tablets = resp.tablet_locations();</a>
<a name="ln1462">  return Status::OK();</a>
<a name="ln1463">}</a>
<a name="ln1464"> </a>
<a name="ln1465">Status YBClient::GetTabletLocation(const TabletId&amp; tablet_id,</a>
<a name="ln1466">                                   master::TabletLocationsPB* tablet_location) {</a>
<a name="ln1467">  GetTabletLocationsRequestPB req;</a>
<a name="ln1468">  GetTabletLocationsResponsePB resp;</a>
<a name="ln1469">  req.add_tablet_ids(tablet_id);</a>
<a name="ln1470">  CALL_SYNC_LEADER_MASTER_RPC(req, resp, GetTabletLocations);</a>
<a name="ln1471"> </a>
<a name="ln1472">  if (resp.tablet_locations_size() != 1) {</a>
<a name="ln1473">    return STATUS_SUBSTITUTE(IllegalState, &quot;Expected single tablet for $0, received $1&quot;,</a>
<a name="ln1474">                             tablet_id, resp.tablet_locations_size());</a>
<a name="ln1475">  }</a>
<a name="ln1476"> </a>
<a name="ln1477">  *tablet_location = resp.tablet_locations(0);</a>
<a name="ln1478">  return Status::OK();</a>
<a name="ln1479">}</a>
<a name="ln1480"> </a>
<a name="ln1481">namespace {</a>
<a name="ln1482"> </a>
<a name="ln1483">void FillFromRepeatedTabletLocations(</a>
<a name="ln1484">    const RepeatedPtrField&lt;TabletLocationsPB&gt;&amp; tablets,</a>
<a name="ln1485">    vector&lt;TabletId&gt;* tablet_uuids,</a>
<a name="ln1486">    vector&lt;string&gt;* ranges,</a>
<a name="ln1487">    std::vector&lt;master::TabletLocationsPB&gt;* locations) {</a>
<a name="ln1488">  tablet_uuids-&gt;reserve(tablets.size());</a>
<a name="ln1489">  if (ranges != nullptr) {</a>
<a name="ln1490">    ranges-&gt;reserve(tablets.size());</a>
<a name="ln1491">  }</a>
<a name="ln1492">  for (const TabletLocationsPB&amp; tablet : tablets) {</a>
<a name="ln1493">    if (locations) {</a>
<a name="ln1494">      locations-&gt;push_back(tablet);</a>
<a name="ln1495">    }</a>
<a name="ln1496">    tablet_uuids-&gt;push_back(tablet.tablet_id());</a>
<a name="ln1497">    if (ranges != nullptr) {</a>
<a name="ln1498">      const PartitionPB&amp; partition = tablet.partition();</a>
<a name="ln1499">      ranges-&gt;push_back(partition.ShortDebugString());</a>
<a name="ln1500">    }</a>
<a name="ln1501">  }</a>
<a name="ln1502">}</a>
<a name="ln1503"> </a>
<a name="ln1504">} // namespace</a>
<a name="ln1505"> </a>
<a name="ln1506">Status YBClient::GetTablets(const YBTableName&amp; table_name,</a>
<a name="ln1507">                            const int32_t max_tablets,</a>
<a name="ln1508">                            vector&lt;TabletId&gt;* tablet_uuids,</a>
<a name="ln1509">                            vector&lt;string&gt;* ranges,</a>
<a name="ln1510">                            std::vector&lt;master::TabletLocationsPB&gt;* locations,</a>
<a name="ln1511">                            const RequireTabletsRunning require_tablets_running) {</a>
<a name="ln1512">  RepeatedPtrField&lt;TabletLocationsPB&gt; tablets;</a>
<a name="ln1513">  RETURN_NOT_OK(GetTablets(table_name, max_tablets, &amp;tablets, require_tablets_running));</a>
<a name="ln1514">  FillFromRepeatedTabletLocations(tablets, tablet_uuids, ranges, locations);</a>
<a name="ln1515">  return Status::OK();</a>
<a name="ln1516">}</a>
<a name="ln1517"> </a>
<a name="ln1518">Status YBClient::GetTabletsAndUpdateCache(</a>
<a name="ln1519">    const YBTableName&amp; table_name,</a>
<a name="ln1520">    const int32_t max_tablets,</a>
<a name="ln1521">    vector&lt;TabletId&gt;* tablet_uuids,</a>
<a name="ln1522">    vector&lt;string&gt;* ranges,</a>
<a name="ln1523">    std::vector&lt;master::TabletLocationsPB&gt;* locations) {</a>
<a name="ln1524">  RepeatedPtrField&lt;TabletLocationsPB&gt; tablets;</a>
<a name="ln1525">  RETURN_NOT_OK(GetTablets(table_name, max_tablets, &amp;tablets, RequireTabletsRunning::kFalse));</a>
<a name="ln1526">  FillFromRepeatedTabletLocations(tablets, tablet_uuids, ranges, locations);</a>
<a name="ln1527"> </a>
<a name="ln1528">  RETURN_NOT_OK(data_-&gt;meta_cache_-&gt;ProcessTabletLocations(</a>
<a name="ln1529">      tablets, /* partition_group_start= */ nullptr, /* request_no= */ 0));</a>
<a name="ln1530"> </a>
<a name="ln1531">  return Status::OK();</a>
<a name="ln1532">}</a>
<a name="ln1533"> </a>
<a name="ln1534">rpc::Messenger* YBClient::messenger() const {</a>
<a name="ln1535">  return data_-&gt;messenger_;</a>
<a name="ln1536">}</a>
<a name="ln1537"> </a>
<a name="ln1538">const scoped_refptr&lt;MetricEntity&gt;&amp; YBClient::metric_entity() const {</a>
<a name="ln1539">  return data_-&gt;metric_entity_;</a>
<a name="ln1540">}</a>
<a name="ln1541"> </a>
<a name="ln1542">rpc::ProxyCache&amp; YBClient::proxy_cache() const {</a>
<a name="ln1543">  return *data_-&gt;proxy_cache_;</a>
<a name="ln1544">}</a>
<a name="ln1545"> </a>
<a name="ln1546">ThreadPool *YBClient::callback_threadpool() {</a>
<a name="ln1547">  return data_-&gt;cb_threadpool_.get();</a>
<a name="ln1548">}</a>
<a name="ln1549"> </a>
<a name="ln1550">const std::string&amp; YBClient::proxy_uuid() const {</a>
<a name="ln1551">  return data_-&gt;uuid_;</a>
<a name="ln1552">}</a>
<a name="ln1553"> </a>
<a name="ln1554">const ClientId&amp; YBClient::id() const {</a>
<a name="ln1555">  return data_-&gt;id_;</a>
<a name="ln1556">}</a>
<a name="ln1557"> </a>
<a name="ln1558">const CloudInfoPB&amp; YBClient::cloud_info() const {</a>
<a name="ln1559">  return data_-&gt;cloud_info_pb_;</a>
<a name="ln1560">}</a>
<a name="ln1561"> </a>
<a name="ln1562">std::pair&lt;RetryableRequestId, RetryableRequestId&gt; YBClient::NextRequestIdAndMinRunningRequestId(</a>
<a name="ln1563">    const TabletId&amp; tablet_id) {</a>
<a name="ln1564">  std::lock_guard&lt;simple_spinlock&gt; lock(data_-&gt;tablet_requests_mutex_);</a>
<a name="ln1565">  auto&amp; tablet = data_-&gt;tablet_requests_[tablet_id];</a>
<a name="ln1566">  auto id = tablet.request_id_seq++;</a>
<a name="ln1567">  tablet.running_requests.insert(id);</a>
<a name="ln1568">  return std::make_pair(id, *tablet.running_requests.begin());</a>
<a name="ln1569">}</a>
<a name="ln1570"> </a>
<a name="ln1571">void YBClient::RequestFinished(const TabletId&amp; tablet_id, RetryableRequestId request_id) {</a>
<a name="ln1572">  std::lock_guard&lt;simple_spinlock&gt; lock(data_-&gt;tablet_requests_mutex_);</a>
<a name="ln1573">  auto&amp; tablet = data_-&gt;tablet_requests_[tablet_id];</a>
<a name="ln1574">  auto it = tablet.running_requests.find(request_id);</a>
<a name="ln1575">  if (it != tablet.running_requests.end()) {</a>
<a name="ln1576">    tablet.running_requests.erase(it);</a>
<a name="ln1577">  } else {</a>
<a name="ln1578">    LOG(DFATAL) &lt;&lt; &quot;RequestFinished called for an unknown request: &quot;</a>
<a name="ln1579">                &lt;&lt; tablet_id &lt;&lt; &quot;, &quot; &lt;&lt; request_id;</a>
<a name="ln1580">  }</a>
<a name="ln1581">}</a>
<a name="ln1582"> </a>
<a name="ln1583">void YBClient::LookupTabletByKey(const YBTable* table,</a>
<a name="ln1584">                                 const std::string&amp; partition_key,</a>
<a name="ln1585">                                 CoarseTimePoint deadline,</a>
<a name="ln1586">                                 LookupTabletCallback callback) {</a>
<a name="ln1587">  data_-&gt;meta_cache_-&gt;LookupTabletByKey(table, partition_key, deadline, std::move(callback));</a>
<a name="ln1588">}</a>
<a name="ln1589"> </a>
<a name="ln1590">void YBClient::LookupTabletById(const std::string&amp; tablet_id,</a>
<a name="ln1591">                                CoarseTimePoint deadline,</a>
<a name="ln1592">                                LookupTabletCallback callback,</a>
<a name="ln1593">                                UseCache use_cache) {</a>
<a name="ln1594">  data_-&gt;meta_cache_-&gt;LookupTabletById(</a>
<a name="ln1595">      tablet_id, deadline, std::move(callback), use_cache);</a>
<a name="ln1596">}</a>
<a name="ln1597"> </a>
<a name="ln1598">HostPort YBClient::GetMasterLeaderAddress() {</a>
<a name="ln1599">  return data_-&gt;leader_master_hostport();</a>
<a name="ln1600">}</a>
<a name="ln1601"> </a>
<a name="ln1602">Status YBClient::ListMasters(CoarseTimePoint deadline, std::vector&lt;std::string&gt;* master_uuids) {</a>
<a name="ln1603">  ListMastersRequestPB req;</a>
<a name="ln1604">  ListMastersResponsePB resp;</a>
<a name="ln1605">  CALL_SYNC_LEADER_MASTER_RPC_WITH_DEADLINE(req, resp, deadline, ListMasters);</a>
<a name="ln1606"> </a>
<a name="ln1607">  master_uuids-&gt;clear();</a>
<a name="ln1608">  for (const ServerEntryPB&amp; master : resp.masters()) {</a>
<a name="ln1609">    if (master.has_error()) {</a>
<a name="ln1610">      LOG(ERROR) &lt;&lt; &quot;Master &quot; &lt;&lt; master.ShortDebugString() &lt;&lt; &quot; hit error &quot;</a>
<a name="ln1611">        &lt;&lt; master.error().ShortDebugString();</a>
<a name="ln1612">      return StatusFromPB(master.error());</a>
<a name="ln1613">    }</a>
<a name="ln1614">    master_uuids-&gt;push_back(master.instance_id().permanent_uuid());</a>
<a name="ln1615">  }</a>
<a name="ln1616">  return Status::OK();</a>
<a name="ln1617">}</a>
<a name="ln1618"> </a>
<a name="ln1619">Result&lt;HostPort&gt; YBClient::RefreshMasterLeaderAddress() {</a>
<a name="ln1620">  auto deadline = CoarseMonoClock::Now() + default_admin_operation_timeout();</a>
<a name="ln1621">  RETURN_NOT_OK(data_-&gt;SetMasterServerProxy(deadline));</a>
<a name="ln1622"> </a>
<a name="ln1623">  return GetMasterLeaderAddress();</a>
<a name="ln1624">}</a>
<a name="ln1625"> </a>
<a name="ln1626">Status YBClient::RemoveMasterFromClient(const HostPort&amp; remove) {</a>
<a name="ln1627">  return data_-&gt;RemoveMasterAddress(remove);</a>
<a name="ln1628">}</a>
<a name="ln1629"> </a>
<a name="ln1630">Status YBClient::AddMasterToClient(const HostPort&amp; add) {</a>
<a name="ln1631">  return data_-&gt;AddMasterAddress(add);</a>
<a name="ln1632">}</a>
<a name="ln1633"> </a>
<a name="ln1634">Status YBClient::SetMasterAddresses(const std::string&amp; addrs) {</a>
<a name="ln1635">  return data_-&gt;SetMasterAddresses(addrs);</a>
<a name="ln1636">}</a>
<a name="ln1637"> </a>
<a name="ln1638">Status YBClient::GetMasterUUID(const string&amp; host,</a>
<a name="ln1639">                               int16_t port,</a>
<a name="ln1640">                               string* uuid) {</a>
<a name="ln1641">  HostPort hp(host, port);</a>
<a name="ln1642">  ServerEntryPB server;</a>
<a name="ln1643">  RETURN_NOT_OK(master::GetMasterEntryForHosts(</a>
<a name="ln1644">      data_-&gt;proxy_cache_.get(), {hp}, default_rpc_timeout(), &amp;server));</a>
<a name="ln1645"> </a>
<a name="ln1646">  if (server.has_error()) {</a>
<a name="ln1647">    return STATUS_FORMAT(</a>
<a name="ln1648">      RuntimeError,</a>
<a name="ln1649">      &quot;Error while getting uuid of $0.&quot;,</a>
<a name="ln1650">      HostPortToString(host, port));</a>
<a name="ln1651">  }</a>
<a name="ln1652"> </a>
<a name="ln1653">  *uuid = server.instance_id().permanent_uuid();</a>
<a name="ln1654"> </a>
<a name="ln1655">  return Status::OK();</a>
<a name="ln1656">}</a>
<a name="ln1657"> </a>
<a name="ln1658">Status YBClient::SetReplicationInfo(const ReplicationInfoPB&amp; replication_info) {</a>
<a name="ln1659">  auto deadline = CoarseMonoClock::Now() + default_admin_operation_timeout();</a>
<a name="ln1660">  return data_-&gt;SetReplicationInfo(this, replication_info, deadline);</a>
<a name="ln1661">}</a>
<a name="ln1662"> </a>
<a name="ln1663">Result&lt;std::vector&lt;YBTableName&gt;&gt; YBClient::ListTables(const std::string&amp; filter,</a>
<a name="ln1664">                                                      bool exclude_ysql) {</a>
<a name="ln1665">  ListTablesRequestPB req;</a>
<a name="ln1666">  ListTablesResponsePB resp;</a>
<a name="ln1667"> </a>
<a name="ln1668">  if (!filter.empty()) {</a>
<a name="ln1669">    req.set_name_filter(filter);</a>
<a name="ln1670">  }</a>
<a name="ln1671">  CALL_SYNC_LEADER_MASTER_RPC(req, resp, ListTables);</a>
<a name="ln1672">  std::vector&lt;YBTableName&gt; result;</a>
<a name="ln1673">  result.reserve(resp.tables_size());</a>
<a name="ln1674">  for (int i = 0; i &lt; resp.tables_size(); i++) {</a>
<a name="ln1675">    const ListTablesResponsePB_TableInfo&amp; table_info = resp.tables(i);</a>
<a name="ln1676">    DCHECK(table_info.has_namespace_());</a>
<a name="ln1677">    DCHECK(table_info.namespace_().has_name());</a>
<a name="ln1678">    DCHECK(table_info.namespace_().has_id());</a>
<a name="ln1679">    if (exclude_ysql &amp;&amp; table_info.table_type() == TableType::PGSQL_TABLE_TYPE) {</a>
<a name="ln1680">      continue;</a>
<a name="ln1681">    }</a>
<a name="ln1682">    result.emplace_back(master::GetDatabaseTypeForTable(table_info.table_type()),</a>
<a name="ln1683">                        table_info.namespace_().id(),</a>
<a name="ln1684">                        table_info.namespace_().name(),</a>
<a name="ln1685">                        table_info.id(),</a>
<a name="ln1686">                        table_info.name(),</a>
<a name="ln1687">                        table_info.relation_type());</a>
<a name="ln1688">  }</a>
<a name="ln1689">  return result;</a>
<a name="ln1690">}</a>
<a name="ln1691"> </a>
<a name="ln1692">Result&lt;bool&gt; YBClient::TableExists(const YBTableName&amp; table_name) {</a>
<a name="ln1693">  for (const YBTableName&amp; table : VERIFY_RESULT(ListTables(table_name.table_name()))) {</a>
<a name="ln1694">    if (table == table_name) {</a>
<a name="ln1695">      return true;</a>
<a name="ln1696">    }</a>
<a name="ln1697">  }</a>
<a name="ln1698">  return false;</a>
<a name="ln1699">}</a>
<a name="ln1700"> </a>
<a name="ln1701">Status YBClient::OpenTable(const YBTableName&amp; table_name, shared_ptr&lt;YBTable&gt;* table) {</a>
<a name="ln1702">  YBTableInfo info;</a>
<a name="ln1703">  auto deadline = CoarseMonoClock::Now() + default_admin_operation_timeout();</a>
<a name="ln1704">  RETURN_NOT_OK(data_-&gt;GetTableSchema(this, table_name, deadline, &amp;info));</a>
<a name="ln1705"> </a>
<a name="ln1706">  // In the future, probably will look up the table in some map to reuse YBTable</a>
<a name="ln1707">  // instances.</a>
<a name="ln1708">  std::shared_ptr&lt;YBTable&gt; ret(new YBTable(this, info));</a>
<a name="ln1709">  RETURN_NOT_OK(ret-&gt;Open());</a>
<a name="ln1710">  table-&gt;swap(ret);</a>
<a name="ln1711">  return Status::OK();</a>
<a name="ln1712">}</a>
<a name="ln1713"> </a>
<a name="ln1714">Status YBClient::OpenTable(const TableId&amp; table_id, shared_ptr&lt;YBTable&gt;* table) {</a>
<a name="ln1715">  YBTableInfo info;</a>
<a name="ln1716">  auto deadline = CoarseMonoClock::Now() + default_admin_operation_timeout();</a>
<a name="ln1717">  RETURN_NOT_OK(data_-&gt;GetTableSchema(this, table_id, deadline, &amp;info));</a>
<a name="ln1718"> </a>
<a name="ln1719">  // In the future, probably will look up the table in some map to reuse YBTable</a>
<a name="ln1720">  // instances.</a>
<a name="ln1721">  std::shared_ptr&lt;YBTable&gt; ret(new YBTable(this, info));</a>
<a name="ln1722">  RETURN_NOT_OK(ret-&gt;Open());</a>
<a name="ln1723">  table-&gt;swap(ret);</a>
<a name="ln1724">  return Status::OK();</a>
<a name="ln1725">}</a>
<a name="ln1726"> </a>
<a name="ln1727">shared_ptr&lt;YBSession&gt; YBClient::NewSession() {</a>
<a name="ln1728">  return std::make_shared&lt;YBSession&gt;(this);</a>
<a name="ln1729">}</a>
<a name="ln1730"> </a>
<a name="ln1731">bool YBClient::IsMultiMaster() const {</a>
<a name="ln1732">  return data_-&gt;IsMultiMaster();</a>
<a name="ln1733">}</a>
<a name="ln1734"> </a>
<a name="ln1735">Result&lt;int&gt; YBClient::NumTabletsForUserTable(TableType table_type) {</a>
<a name="ln1736">  if (FLAGS_TEST_yb_num_total_tablets &gt; 0) {</a>
<a name="ln1737">    VLOG(1) &lt;&lt; &quot;num_tablets=&quot; &lt;&lt; FLAGS_TEST_yb_num_total_tablets</a>
<a name="ln1738">            &lt;&lt; &quot;: --TEST_yb_num_total_tablets is specified.&quot;;</a>
<a name="ln1739">    return FLAGS_TEST_yb_num_total_tablets;</a>
<a name="ln1740">  } else {</a>
<a name="ln1741">    int tserver_count = 0;</a>
<a name="ln1742">    RETURN_NOT_OK(TabletServerCount(&amp;tserver_count, true /* primary_only */));</a>
<a name="ln1743">    int num_tablets = 0;</a>
<a name="ln1744">    if (table_type == TableType::PGSQL_TABLE_TYPE) {</a>
<a name="ln1745">      num_tablets = tserver_count * FLAGS_ysql_num_shards_per_tserver;</a>
<a name="ln1746">      VLOG(1) &lt;&lt; &quot;num_tablets = &quot; &lt;&lt; num_tablets &lt;&lt; &quot;: &quot;</a>
<a name="ln1747">              &lt;&lt; &quot;calculated as tserver_count * FLAGS_ysql_num_shards_per_tserver (&quot;</a>
<a name="ln1748">              &lt;&lt; tserver_count &lt;&lt; &quot; * &quot; &lt;&lt; FLAGS_ysql_num_shards_per_tserver &lt;&lt; &quot;)&quot;;</a>
<a name="ln1749">    } else {</a>
<a name="ln1750">      num_tablets = tserver_count * FLAGS_yb_num_shards_per_tserver;</a>
<a name="ln1751">      VLOG(1) &lt;&lt; &quot;num_tablets = &quot; &lt;&lt; num_tablets &lt;&lt; &quot;: &quot;</a>
<a name="ln1752">              &lt;&lt; &quot;calculated as tserver_count * FLAGS_yb_num_shards_per_tserver (&quot;</a>
<a name="ln1753">              &lt;&lt; tserver_count &lt;&lt; &quot; * &quot; &lt;&lt; FLAGS_yb_num_shards_per_tserver &lt;&lt; &quot;)&quot;;</a>
<a name="ln1754">    }</a>
<a name="ln1755">    return num_tablets;</a>
<a name="ln1756">  }</a>
<a name="ln1757">}</a>
<a name="ln1758"> </a>
<a name="ln1759">void YBClient::TEST_set_admin_operation_timeout(const MonoDelta&amp; timeout) {</a>
<a name="ln1760">  data_-&gt;default_admin_operation_timeout_ = timeout;</a>
<a name="ln1761">}</a>
<a name="ln1762"> </a>
<a name="ln1763">const MonoDelta&amp; YBClient::default_admin_operation_timeout() const {</a>
<a name="ln1764">  return data_-&gt;default_admin_operation_timeout_;</a>
<a name="ln1765">}</a>
<a name="ln1766"> </a>
<a name="ln1767">const MonoDelta&amp; YBClient::default_rpc_timeout() const {</a>
<a name="ln1768">  return data_-&gt;default_rpc_timeout_;</a>
<a name="ln1769">}</a>
<a name="ln1770"> </a>
<a name="ln1771">const uint64_t YBClient::kNoHybridTime = 0;</a>
<a name="ln1772"> </a>
<a name="ln1773">uint64_t YBClient::GetLatestObservedHybridTime() const {</a>
<a name="ln1774">  return data_-&gt;GetLatestObservedHybridTime();</a>
<a name="ln1775">}</a>
<a name="ln1776"> </a>
<a name="ln1777">void YBClient::SetLatestObservedHybridTime(uint64_t ht_hybrid_time) {</a>
<a name="ln1778">  data_-&gt;UpdateLatestObservedHybridTime(ht_hybrid_time);</a>
<a name="ln1779">}</a>
<a name="ln1780"> </a>
<a name="ln1781">}  // namespace client</a>
<a name="ln1782">}  // namespace yb</a>

</code></pre>
<div class="balloon" rel="234"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v614/" target="_blank">V614</a> Potentially uninitialized variable 'client_severity' used. Consider checking the first actual argument of the 'Run' function.</p></div>
<div class="balloon" rel="915"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="943"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="990"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1193"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1196"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1004/" target="_blank">V1004</a> The 'permissions_cache' pointer was used unsafely after it was verified against nullptr. Check lines: 1192, 1196.</p></div>
<div class="balloon" rel="1207"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1213"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1220"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1228"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1676"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1677"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1678"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1737"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1746"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1751"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
