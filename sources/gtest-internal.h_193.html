
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>gtest-internal.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Copyright 2005, Google Inc.</a>
<a name="ln2">// All rights reserved.</a>
<a name="ln3">//</a>
<a name="ln4">// Redistribution and use in source and binary forms, with or without</a>
<a name="ln5">// modification, are permitted provided that the following conditions are</a>
<a name="ln6">// met:</a>
<a name="ln7">//</a>
<a name="ln8">//     * Redistributions of source code must retain the above copyright</a>
<a name="ln9">// notice, this list of conditions and the following disclaimer.</a>
<a name="ln10">//     * Redistributions in binary form must reproduce the above</a>
<a name="ln11">// copyright notice, this list of conditions and the following disclaimer</a>
<a name="ln12">// in the documentation and/or other materials provided with the</a>
<a name="ln13">// distribution.</a>
<a name="ln14">//     * Neither the name of Google Inc. nor the names of its</a>
<a name="ln15">// contributors may be used to endorse or promote products derived from</a>
<a name="ln16">// this software without specific prior written permission.</a>
<a name="ln17">//</a>
<a name="ln18">// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</a>
<a name="ln19">// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</a>
<a name="ln20">// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</a>
<a name="ln21">// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</a>
<a name="ln22">// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</a>
<a name="ln23">// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</a>
<a name="ln24">// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</a>
<a name="ln25">// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</a>
<a name="ln26">// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</a>
<a name="ln27">// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</a>
<a name="ln28">// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</a>
<a name="ln29">//</a>
<a name="ln30">// Authors: wan@google.com (Zhanyong Wan), eefacm@gmail.com (Sean Mcafee)</a>
<a name="ln31">//</a>
<a name="ln32">// The Google C++ Testing Framework (Google Test)</a>
<a name="ln33">//</a>
<a name="ln34">// This header file declares functions and macros used internally by</a>
<a name="ln35">// Google Test.  They are subject to change without notice.</a>
<a name="ln36"> </a>
<a name="ln37">#ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_</a>
<a name="ln38">#define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_</a>
<a name="ln39"> </a>
<a name="ln40">#include &quot;gtest/internal/gtest-port.h&quot;</a>
<a name="ln41"> </a>
<a name="ln42">#if GTEST_OS_LINUX</a>
<a name="ln43"># include &lt;stdlib.h&gt;</a>
<a name="ln44"># include &lt;sys/types.h&gt;</a>
<a name="ln45"># include &lt;sys/wait.h&gt;</a>
<a name="ln46"># include &lt;unistd.h&gt;</a>
<a name="ln47">#endif  // GTEST_OS_LINUX</a>
<a name="ln48"> </a>
<a name="ln49">#if GTEST_HAS_EXCEPTIONS</a>
<a name="ln50"># include &lt;stdexcept&gt;</a>
<a name="ln51">#endif</a>
<a name="ln52"> </a>
<a name="ln53">#include &lt;ctype.h&gt;</a>
<a name="ln54">#include &lt;float.h&gt;</a>
<a name="ln55">#include &lt;string.h&gt;</a>
<a name="ln56">#include &lt;iomanip&gt;</a>
<a name="ln57">#include &lt;limits&gt;</a>
<a name="ln58">#include &lt;map&gt;</a>
<a name="ln59">#include &lt;set&gt;</a>
<a name="ln60">#include &lt;string&gt;</a>
<a name="ln61">#include &lt;vector&gt;</a>
<a name="ln62"> </a>
<a name="ln63">#include &quot;gtest/gtest-message.h&quot;</a>
<a name="ln64">#include &quot;gtest/internal/gtest-string.h&quot;</a>
<a name="ln65">#include &quot;gtest/internal/gtest-filepath.h&quot;</a>
<a name="ln66">#include &quot;gtest/internal/gtest-type-util.h&quot;</a>
<a name="ln67"> </a>
<a name="ln68">// Due to C++ preprocessor weirdness, we need double indirection to</a>
<a name="ln69">// concatenate two tokens when one of them is __LINE__.  Writing</a>
<a name="ln70">//</a>
<a name="ln71">//   foo ## __LINE__</a>
<a name="ln72">//</a>
<a name="ln73">// will result in the token foo__LINE__, instead of foo followed by</a>
<a name="ln74">// the current line number.  For more details, see</a>
<a name="ln75">// http://www.parashift.com/c++-faq-lite/misc-technical-issues.html#faq-39.6</a>
<a name="ln76">#define GTEST_CONCAT_TOKEN_(foo, bar) GTEST_CONCAT_TOKEN_IMPL_(foo, bar)</a>
<a name="ln77">#define GTEST_CONCAT_TOKEN_IMPL_(foo, bar) foo ## bar</a>
<a name="ln78"> </a>
<a name="ln79">class ProtocolMessage;</a>
<a name="ln80">namespace proto2 { class Message; }</a>
<a name="ln81"> </a>
<a name="ln82">namespace testing {</a>
<a name="ln83"> </a>
<a name="ln84">// Forward declarations.</a>
<a name="ln85"> </a>
<a name="ln86">class AssertionResult;                 // Result of an assertion.</a>
<a name="ln87">class Message;                         // Represents a failure message.</a>
<a name="ln88">class Test;                            // Represents a test.</a>
<a name="ln89">class TestInfo;                        // Information about a test.</a>
<a name="ln90">class TestPartResult;                  // Result of a test part.</a>
<a name="ln91">class UnitTest;                        // A collection of test cases.</a>
<a name="ln92"> </a>
<a name="ln93">template &lt;typename T&gt;</a>
<a name="ln94">::std::string PrintToString(const T&amp; value);</a>
<a name="ln95"> </a>
<a name="ln96">namespace internal {</a>
<a name="ln97"> </a>
<a name="ln98">struct TraceInfo;                      // Information about a trace point.</a>
<a name="ln99">class ScopedTrace;                     // Implements scoped trace.</a>
<a name="ln100">class TestInfoImpl;                    // Opaque implementation of TestInfo</a>
<a name="ln101">class UnitTestImpl;                    // Opaque implementation of UnitTest</a>
<a name="ln102"> </a>
<a name="ln103">// The text used in failure messages to indicate the start of the</a>
<a name="ln104">// stack trace.</a>
<a name="ln105">GTEST_API_ extern const char kStackTraceMarker[];</a>
<a name="ln106"> </a>
<a name="ln107">// Two overloaded helpers for checking at compile time whether an</a>
<a name="ln108">// expression is a null pointer literal (i.e. NULL or any 0-valued</a>
<a name="ln109">// compile-time integral constant).  Their return values have</a>
<a name="ln110">// different sizes, so we can use sizeof() to test which version is</a>
<a name="ln111">// picked by the compiler.  These helpers have no implementations, as</a>
<a name="ln112">// we only need their signatures.</a>
<a name="ln113">//</a>
<a name="ln114">// Given IsNullLiteralHelper(x), the compiler will pick the first</a>
<a name="ln115">// version if x can be implicitly converted to Secret*, and pick the</a>
<a name="ln116">// second version otherwise.  Since Secret is a secret and incomplete</a>
<a name="ln117">// type, the only expression a user can write that has type Secret* is</a>
<a name="ln118">// a null pointer literal.  Therefore, we know that x is a null</a>
<a name="ln119">// pointer literal if and only if the first version is picked by the</a>
<a name="ln120">// compiler.</a>
<a name="ln121">char IsNullLiteralHelper(Secret* p);</a>
<a name="ln122">char (&amp;IsNullLiteralHelper(...))[2];  // NOLINT</a>
<a name="ln123"> </a>
<a name="ln124">// A compile-time bool constant that is true if and only if x is a</a>
<a name="ln125">// null pointer literal (i.e. NULL or any 0-valued compile-time</a>
<a name="ln126">// integral constant).</a>
<a name="ln127">#ifdef GTEST_ELLIPSIS_NEEDS_POD_</a>
<a name="ln128">// We lose support for NULL detection where the compiler doesn't like</a>
<a name="ln129">// passing non-POD classes through ellipsis (...).</a>
<a name="ln130"># define GTEST_IS_NULL_LITERAL_(x) false</a>
<a name="ln131">#else</a>
<a name="ln132"># define GTEST_IS_NULL_LITERAL_(x) \</a>
<a name="ln133">    (sizeof(::testing::internal::IsNullLiteralHelper(x)) == 1)</a>
<a name="ln134">#endif  // GTEST_ELLIPSIS_NEEDS_POD_</a>
<a name="ln135"> </a>
<a name="ln136">// Appends the user-supplied message to the Google-Test-generated message.</a>
<a name="ln137">GTEST_API_ std::string AppendUserMessage(</a>
<a name="ln138">    const std::string&amp; gtest_msg, const Message&amp; user_msg);</a>
<a name="ln139"> </a>
<a name="ln140">#if GTEST_HAS_EXCEPTIONS</a>
<a name="ln141"> </a>
<a name="ln142">// This exception is thrown by (and only by) a failed Google Test</a>
<a name="ln143">// assertion when GTEST_FLAG(throw_on_failure) is true (if exceptions</a>
<a name="ln144">// are enabled).  We derive it from std::runtime_error, which is for</a>
<a name="ln145">// errors presumably detectable only at run time.  Since</a>
<a name="ln146">// std::runtime_error inherits from std::exception, many testing</a>
<a name="ln147">// frameworks know how to extract and print the message inside it.</a>
<a name="ln148">class GTEST_API_ GoogleTestFailureException : public ::std::runtime_error {</a>
<a name="ln149"> public:</a>
<a name="ln150">  explicit GoogleTestFailureException(const TestPartResult&amp; failure);</a>
<a name="ln151">};</a>
<a name="ln152"> </a>
<a name="ln153">#endif  // GTEST_HAS_EXCEPTIONS</a>
<a name="ln154"> </a>
<a name="ln155">// A helper class for creating scoped traces in user programs.</a>
<a name="ln156">class GTEST_API_ ScopedTrace {</a>
<a name="ln157"> public:</a>
<a name="ln158">  // The c'tor pushes the given source file location and message onto</a>
<a name="ln159">  // a trace stack maintained by Google Test.</a>
<a name="ln160">  ScopedTrace(const char* file, int line, const Message&amp; message);</a>
<a name="ln161"> </a>
<a name="ln162">  // The d'tor pops the info pushed by the c'tor.</a>
<a name="ln163">  //</a>
<a name="ln164">  // Note that the d'tor is not virtual in order to be efficient.</a>
<a name="ln165">  // Don't inherit from ScopedTrace!</a>
<a name="ln166">  ~ScopedTrace();</a>
<a name="ln167"> </a>
<a name="ln168"> private:</a>
<a name="ln169">  GTEST_DISALLOW_COPY_AND_ASSIGN_(ScopedTrace);</a>
<a name="ln170">} GTEST_ATTRIBUTE_UNUSED_;  // A ScopedTrace object does its job in its</a>
<a name="ln171">                            // c'tor and d'tor.  Therefore it doesn't</a>
<a name="ln172">                            // need to be used otherwise.</a>
<a name="ln173"> </a>
<a name="ln174">namespace edit_distance {</a>
<a name="ln175">// Returns the optimal edits to go from 'left' to 'right'.</a>
<a name="ln176">// All edits cost the same, with replace having lower priority than</a>
<a name="ln177">// add/remove.</a>
<a name="ln178">// Simple implementation of the Wagner–Fischer algorithm.</a>
<a name="ln179">// See http://en.wikipedia.org/wiki/Wagner-Fischer_algorithm</a>
<a name="ln180">enum EditType { kMatch, kAdd, kRemove, kReplace };</a>
<a name="ln181">GTEST_API_ std::vector&lt;EditType&gt; CalculateOptimalEdits(</a>
<a name="ln182">    const std::vector&lt;size_t&gt;&amp; left, const std::vector&lt;size_t&gt;&amp; right);</a>
<a name="ln183"> </a>
<a name="ln184">// Same as above, but the input is represented as strings.</a>
<a name="ln185">GTEST_API_ std::vector&lt;EditType&gt; CalculateOptimalEdits(</a>
<a name="ln186">    const std::vector&lt;std::string&gt;&amp; left,</a>
<a name="ln187">    const std::vector&lt;std::string&gt;&amp; right);</a>
<a name="ln188"> </a>
<a name="ln189">// Create a diff of the input strings in Unified diff format.</a>
<a name="ln190">GTEST_API_ std::string CreateUnifiedDiff(const std::vector&lt;std::string&gt;&amp; left,</a>
<a name="ln191">                                         const std::vector&lt;std::string&gt;&amp; right,</a>
<a name="ln192">                                         size_t context = 2);</a>
<a name="ln193"> </a>
<a name="ln194">}  // namespace edit_distance</a>
<a name="ln195"> </a>
<a name="ln196">// Calculate the diff between 'left' and 'right' and return it in unified diff</a>
<a name="ln197">// format.</a>
<a name="ln198">// If not null, stores in 'total_line_count' the total number of lines found</a>
<a name="ln199">// in left + right.</a>
<a name="ln200">GTEST_API_ std::string DiffStrings(const std::string&amp; left,</a>
<a name="ln201">                                   const std::string&amp; right,</a>
<a name="ln202">                                   size_t* total_line_count);</a>
<a name="ln203"> </a>
<a name="ln204">// Constructs and returns the message for an equality assertion</a>
<a name="ln205">// (e.g. ASSERT_EQ, EXPECT_STREQ, etc) failure.</a>
<a name="ln206">//</a>
<a name="ln207">// The first four parameters are the expressions used in the assertion</a>
<a name="ln208">// and their values, as strings.  For example, for ASSERT_EQ(foo, bar)</a>
<a name="ln209">// where foo is 5 and bar is 6, we have:</a>
<a name="ln210">//</a>
<a name="ln211">//   expected_expression: &quot;foo&quot;</a>
<a name="ln212">//   actual_expression:   &quot;bar&quot;</a>
<a name="ln213">//   expected_value:      &quot;5&quot;</a>
<a name="ln214">//   actual_value:        &quot;6&quot;</a>
<a name="ln215">//</a>
<a name="ln216">// The ignoring_case parameter is true iff the assertion is a</a>
<a name="ln217">// *_STRCASEEQ*.  When it's true, the string &quot; (ignoring case)&quot; will</a>
<a name="ln218">// be inserted into the message.</a>
<a name="ln219">GTEST_API_ AssertionResult EqFailure(const char* expected_expression,</a>
<a name="ln220">                                     const char* actual_expression,</a>
<a name="ln221">                                     const std::string&amp; expected_value,</a>
<a name="ln222">                                     const std::string&amp; actual_value,</a>
<a name="ln223">                                     bool ignoring_case);</a>
<a name="ln224"> </a>
<a name="ln225">// Constructs a failure message for Boolean assertions such as EXPECT_TRUE.</a>
<a name="ln226">GTEST_API_ std::string GetBoolAssertionFailureMessage(</a>
<a name="ln227">    const AssertionResult&amp; assertion_result,</a>
<a name="ln228">    const char* expression_text,</a>
<a name="ln229">    const char* actual_predicate_value,</a>
<a name="ln230">    const char* expected_predicate_value);</a>
<a name="ln231"> </a>
<a name="ln232">// This template class represents an IEEE floating-point number</a>
<a name="ln233">// (either single-precision or double-precision, depending on the</a>
<a name="ln234">// template parameters).</a>
<a name="ln235">//</a>
<a name="ln236">// The purpose of this class is to do more sophisticated number</a>
<a name="ln237">// comparison.  (Due to round-off error, etc, it's very unlikely that</a>
<a name="ln238">// two floating-points will be equal exactly.  Hence a naive</a>
<a name="ln239">// comparison by the == operation often doesn't work.)</a>
<a name="ln240">//</a>
<a name="ln241">// Format of IEEE floating-point:</a>
<a name="ln242">//</a>
<a name="ln243">//   The most-significant bit being the leftmost, an IEEE</a>
<a name="ln244">//   floating-point looks like</a>
<a name="ln245">//</a>
<a name="ln246">//     sign_bit exponent_bits fraction_bits</a>
<a name="ln247">//</a>
<a name="ln248">//   Here, sign_bit is a single bit that designates the sign of the</a>
<a name="ln249">//   number.</a>
<a name="ln250">//</a>
<a name="ln251">//   For float, there are 8 exponent bits and 23 fraction bits.</a>
<a name="ln252">//</a>
<a name="ln253">//   For double, there are 11 exponent bits and 52 fraction bits.</a>
<a name="ln254">//</a>
<a name="ln255">//   More details can be found at</a>
<a name="ln256">//   http://en.wikipedia.org/wiki/IEEE_floating-point_standard.</a>
<a name="ln257">//</a>
<a name="ln258">// Template parameter:</a>
<a name="ln259">//</a>
<a name="ln260">//   RawType: the raw floating-point type (either float or double)</a>
<a name="ln261">template &lt;typename RawType&gt;</a>
<a name="ln262">class FloatingPoint {</a>
<a name="ln263"> public:</a>
<a name="ln264">  // Defines the unsigned integer type that has the same size as the</a>
<a name="ln265">  // floating point number.</a>
<a name="ln266">  typedef typename TypeWithSize&lt;sizeof(RawType)&gt;::UInt Bits;</a>
<a name="ln267"> </a>
<a name="ln268">  // Constants.</a>
<a name="ln269"> </a>
<a name="ln270">  // # of bits in a number.</a>
<a name="ln271">  static const size_t kBitCount = 8*sizeof(RawType);</a>
<a name="ln272"> </a>
<a name="ln273">  // # of fraction bits in a number.</a>
<a name="ln274">  static const size_t kFractionBitCount =</a>
<a name="ln275">    std::numeric_limits&lt;RawType&gt;::digits - 1;</a>
<a name="ln276"> </a>
<a name="ln277">  // # of exponent bits in a number.</a>
<a name="ln278">  static const size_t kExponentBitCount = kBitCount - 1 - kFractionBitCount;</a>
<a name="ln279"> </a>
<a name="ln280">  // The mask for the sign bit.</a>
<a name="ln281">  static const Bits kSignBitMask = static_cast&lt;Bits&gt;(1) &lt;&lt; (kBitCount - 1);</a>
<a name="ln282"> </a>
<a name="ln283">  // The mask for the fraction bits.</a>
<a name="ln284">  static const Bits kFractionBitMask =</a>
<a name="ln285">    ~static_cast&lt;Bits&gt;(0) &gt;&gt; (kExponentBitCount + 1);</a>
<a name="ln286"> </a>
<a name="ln287">  // The mask for the exponent bits.</a>
<a name="ln288">  static const Bits kExponentBitMask = ~(kSignBitMask | kFractionBitMask);</a>
<a name="ln289"> </a>
<a name="ln290">  // How many ULP's (Units in the Last Place) we want to tolerate when</a>
<a name="ln291">  // comparing two numbers.  The larger the value, the more error we</a>
<a name="ln292">  // allow.  A 0 value means that two numbers must be exactly the same</a>
<a name="ln293">  // to be considered equal.</a>
<a name="ln294">  //</a>
<a name="ln295">  // The maximum error of a single floating-point operation is 0.5</a>
<a name="ln296">  // units in the last place.  On Intel CPU's, all floating-point</a>
<a name="ln297">  // calculations are done with 80-bit precision, while double has 64</a>
<a name="ln298">  // bits.  Therefore, 4 should be enough for ordinary use.</a>
<a name="ln299">  //</a>
<a name="ln300">  // See the following article for more details on ULP:</a>
<a name="ln301">  // http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/</a>
<a name="ln302">  static const size_t kMaxUlps = 4;</a>
<a name="ln303"> </a>
<a name="ln304">  // Constructs a FloatingPoint from a raw floating-point number.</a>
<a name="ln305">  //</a>
<a name="ln306">  // On an Intel CPU, passing a non-normalized NAN (Not a Number)</a>
<a name="ln307">  // around may change its bits, although the new value is guaranteed</a>
<a name="ln308">  // to be also a NAN.  Therefore, don't expect this constructor to</a>
<a name="ln309">  // preserve the bits in x when x is a NAN.</a>
<a name="ln310">  explicit FloatingPoint(const RawType&amp; x) { u_.value_ = x; }</a>
<a name="ln311"> </a>
<a name="ln312">  // Static methods</a>
<a name="ln313"> </a>
<a name="ln314">  // Reinterprets a bit pattern as a floating-point number.</a>
<a name="ln315">  //</a>
<a name="ln316">  // This function is needed to test the AlmostEquals() method.</a>
<a name="ln317">  static RawType ReinterpretBits(const Bits bits) {</a>
<a name="ln318">    FloatingPoint fp(0);</a>
<a name="ln319">    fp.u_.bits_ = bits;</a>
<a name="ln320">    return fp.u_.value_;</a>
<a name="ln321">  }</a>
<a name="ln322"> </a>
<a name="ln323">  // Returns the floating-point number that represent positive infinity.</a>
<a name="ln324">  static RawType Infinity() {</a>
<a name="ln325">    return ReinterpretBits(kExponentBitMask);</a>
<a name="ln326">  }</a>
<a name="ln327"> </a>
<a name="ln328">  // Returns the maximum representable finite floating-point number.</a>
<a name="ln329">  static RawType Max();</a>
<a name="ln330"> </a>
<a name="ln331">  // Non-static methods</a>
<a name="ln332"> </a>
<a name="ln333">  // Returns the bits that represents this number.</a>
<a name="ln334">  const Bits &amp;bits() const { return u_.bits_; }</a>
<a name="ln335"> </a>
<a name="ln336">  // Returns the exponent bits of this number.</a>
<a name="ln337">  Bits exponent_bits() const { return kExponentBitMask &amp; u_.bits_; }</a>
<a name="ln338"> </a>
<a name="ln339">  // Returns the fraction bits of this number.</a>
<a name="ln340">  Bits fraction_bits() const { return kFractionBitMask &amp; u_.bits_; }</a>
<a name="ln341"> </a>
<a name="ln342">  // Returns the sign bit of this number.</a>
<a name="ln343">  Bits sign_bit() const { return kSignBitMask &amp; u_.bits_; }</a>
<a name="ln344"> </a>
<a name="ln345">  // Returns true iff this is NAN (not a number).</a>
<a name="ln346">  bool is_nan() const {</a>
<a name="ln347">    // It's a NAN if the exponent bits are all ones and the fraction</a>
<a name="ln348">    // bits are not entirely zeros.</a>
<a name="ln349">    return (exponent_bits() == kExponentBitMask) &amp;&amp; (fraction_bits() != 0);</a>
<a name="ln350">  }</a>
<a name="ln351"> </a>
<a name="ln352">  // Returns true iff this number is at most kMaxUlps ULP's away from</a>
<a name="ln353">  // rhs.  In particular, this function:</a>
<a name="ln354">  //</a>
<a name="ln355">  //   - returns false if either number is (or both are) NAN.</a>
<a name="ln356">  //   - treats really large numbers as almost equal to infinity.</a>
<a name="ln357">  //   - thinks +0.0 and -0.0 are 0 DLP's apart.</a>
<a name="ln358">  bool AlmostEquals(const FloatingPoint&amp; rhs) const {</a>
<a name="ln359">    // The IEEE standard says that any comparison operation involving</a>
<a name="ln360">    // a NAN must return false.</a>
<a name="ln361">    if (is_nan() || rhs.is_nan()) return false;</a>
<a name="ln362"> </a>
<a name="ln363">    return DistanceBetweenSignAndMagnitudeNumbers(u_.bits_, rhs.u_.bits_)</a>
<a name="ln364">        &lt;= kMaxUlps;</a>
<a name="ln365">  }</a>
<a name="ln366"> </a>
<a name="ln367"> private:</a>
<a name="ln368">  // The data type used to store the actual floating-point number.</a>
<a name="ln369">  union FloatingPointUnion {</a>
<a name="ln370">    RawType value_;  // The raw floating-point number.</a>
<a name="ln371">    Bits bits_;      // The bits that represent the number.</a>
<a name="ln372">  };</a>
<a name="ln373"> </a>
<a name="ln374">  // Converts an integer from the sign-and-magnitude representation to</a>
<a name="ln375">  // the biased representation.  More precisely, let N be 2 to the</a>
<a name="ln376">  // power of (kBitCount - 1), an integer x is represented by the</a>
<a name="ln377">  // unsigned number x + N.</a>
<a name="ln378">  //</a>
<a name="ln379">  // For instance,</a>
<a name="ln380">  //</a>
<a name="ln381">  //   -N + 1 (the most negative number representable using</a>
<a name="ln382">  //          sign-and-magnitude) is represented by 1;</a>
<a name="ln383">  //   0      is represented by N; and</a>
<a name="ln384">  //   N - 1  (the biggest number representable using</a>
<a name="ln385">  //          sign-and-magnitude) is represented by 2N - 1.</a>
<a name="ln386">  //</a>
<a name="ln387">  // Read http://en.wikipedia.org/wiki/Signed_number_representations</a>
<a name="ln388">  // for more details on signed number representations.</a>
<a name="ln389">  static Bits SignAndMagnitudeToBiased(const Bits &amp;sam) {</a>
<a name="ln390">    if (kSignBitMask &amp; sam) {</a>
<a name="ln391">      // sam represents a negative number.</a>
<a name="ln392">      return ~sam + 1;</a>
<a name="ln393">    } else {</a>
<a name="ln394">      // sam represents a positive number.</a>
<a name="ln395">      return kSignBitMask | sam;</a>
<a name="ln396">    }</a>
<a name="ln397">  }</a>
<a name="ln398"> </a>
<a name="ln399">  // Given two numbers in the sign-and-magnitude representation,</a>
<a name="ln400">  // returns the distance between them as an unsigned number.</a>
<a name="ln401">  static Bits DistanceBetweenSignAndMagnitudeNumbers(const Bits &amp;sam1,</a>
<a name="ln402">                                                     const Bits &amp;sam2) {</a>
<a name="ln403">    const Bits biased1 = SignAndMagnitudeToBiased(sam1);</a>
<a name="ln404">    const Bits biased2 = SignAndMagnitudeToBiased(sam2);</a>
<a name="ln405">    return (biased1 &gt;= biased2) ? (biased1 - biased2) : (biased2 - biased1);</a>
<a name="ln406">  }</a>
<a name="ln407"> </a>
<a name="ln408">  FloatingPointUnion u_;</a>
<a name="ln409">};</a>
<a name="ln410"> </a>
<a name="ln411">// We cannot use std::numeric_limits&lt;T&gt;::max() as it clashes with the max()</a>
<a name="ln412">// macro defined by &lt;windows.h&gt;.</a>
<a name="ln413">template &lt;&gt;</a>
<a name="ln414">inline float FloatingPoint&lt;float&gt;::Max() { return FLT_MAX; }</a>
<a name="ln415">template &lt;&gt;</a>
<a name="ln416">inline double FloatingPoint&lt;double&gt;::Max() { return DBL_MAX; }</a>
<a name="ln417"> </a>
<a name="ln418">// Typedefs the instances of the FloatingPoint template class that we</a>
<a name="ln419">// care to use.</a>
<a name="ln420">typedef FloatingPoint&lt;float&gt; Float;</a>
<a name="ln421">typedef FloatingPoint&lt;double&gt; Double;</a>
<a name="ln422"> </a>
<a name="ln423">// In order to catch the mistake of putting tests that use different</a>
<a name="ln424">// test fixture classes in the same test case, we need to assign</a>
<a name="ln425">// unique IDs to fixture classes and compare them.  The TypeId type is</a>
<a name="ln426">// used to hold such IDs.  The user should treat TypeId as an opaque</a>
<a name="ln427">// type: the only operation allowed on TypeId values is to compare</a>
<a name="ln428">// them for equality using the == operator.</a>
<a name="ln429">typedef const void* TypeId;</a>
<a name="ln430"> </a>
<a name="ln431">template &lt;typename T&gt;</a>
<a name="ln432">class TypeIdHelper {</a>
<a name="ln433"> public:</a>
<a name="ln434">  // dummy_ must not have a const type.  Otherwise an overly eager</a>
<a name="ln435">  // compiler (e.g. MSVC 7.1 &amp; 8.0) may try to merge</a>
<a name="ln436">  // TypeIdHelper&lt;T&gt;::dummy_ for different Ts as an &quot;optimization&quot;.</a>
<a name="ln437">  static bool dummy_;</a>
<a name="ln438">};</a>
<a name="ln439"> </a>
<a name="ln440">template &lt;typename T&gt;</a>
<a name="ln441">bool TypeIdHelper&lt;T&gt;::dummy_ = false;</a>
<a name="ln442"> </a>
<a name="ln443">// GetTypeId&lt;T&gt;() returns the ID of type T.  Different values will be</a>
<a name="ln444">// returned for different types.  Calling the function twice with the</a>
<a name="ln445">// same type argument is guaranteed to return the same ID.</a>
<a name="ln446">template &lt;typename T&gt;</a>
<a name="ln447">TypeId GetTypeId() {</a>
<a name="ln448">  // The compiler is required to allocate a different</a>
<a name="ln449">  // TypeIdHelper&lt;T&gt;::dummy_ variable for each T used to instantiate</a>
<a name="ln450">  // the template.  Therefore, the address of dummy_ is guaranteed to</a>
<a name="ln451">  // be unique.</a>
<a name="ln452">  return &amp;(TypeIdHelper&lt;T&gt;::dummy_);</a>
<a name="ln453">}</a>
<a name="ln454"> </a>
<a name="ln455">// Returns the type ID of ::testing::Test.  Always call this instead</a>
<a name="ln456">// of GetTypeId&lt; ::testing::Test&gt;() to get the type ID of</a>
<a name="ln457">// ::testing::Test, as the latter may give the wrong result due to a</a>
<a name="ln458">// suspected linker bug when compiling Google Test as a Mac OS X</a>
<a name="ln459">// framework.</a>
<a name="ln460">GTEST_API_ TypeId GetTestTypeId();</a>
<a name="ln461"> </a>
<a name="ln462">// Defines the abstract factory interface that creates instances</a>
<a name="ln463">// of a Test object.</a>
<a name="ln464">class TestFactoryBase {</a>
<a name="ln465"> public:</a>
<a name="ln466">  virtual ~TestFactoryBase() {}</a>
<a name="ln467"> </a>
<a name="ln468">  // Creates a test instance to run. The instance is both created and destroyed</a>
<a name="ln469">  // within TestInfoImpl::Run()</a>
<a name="ln470">  virtual Test* CreateTest() = 0;</a>
<a name="ln471"> </a>
<a name="ln472"> protected:</a>
<a name="ln473">  TestFactoryBase() {}</a>
<a name="ln474"> </a>
<a name="ln475"> private:</a>
<a name="ln476">  GTEST_DISALLOW_COPY_AND_ASSIGN_(TestFactoryBase);</a>
<a name="ln477">};</a>
<a name="ln478"> </a>
<a name="ln479">// This class provides implementation of TeastFactoryBase interface.</a>
<a name="ln480">// It is used in TEST and TEST_F macros.</a>
<a name="ln481">template &lt;class TestClass&gt;</a>
<a name="ln482">class TestFactoryImpl : public TestFactoryBase {</a>
<a name="ln483"> public:</a>
<a name="ln484">  virtual Test* CreateTest() { return new TestClass; }</a>
<a name="ln485">};</a>
<a name="ln486"> </a>
<a name="ln487">#if GTEST_OS_WINDOWS</a>
<a name="ln488"> </a>
<a name="ln489">// Predicate-formatters for implementing the HRESULT checking macros</a>
<a name="ln490">// {ASSERT|EXPECT}_HRESULT_{SUCCEEDED|FAILED}</a>
<a name="ln491">// We pass a long instead of HRESULT to avoid causing an</a>
<a name="ln492">// include dependency for the HRESULT type.</a>
<a name="ln493">GTEST_API_ AssertionResult IsHRESULTSuccess(const char* expr,</a>
<a name="ln494">                                            long hr);  // NOLINT</a>
<a name="ln495">GTEST_API_ AssertionResult IsHRESULTFailure(const char* expr,</a>
<a name="ln496">                                            long hr);  // NOLINT</a>
<a name="ln497"> </a>
<a name="ln498">#endif  // GTEST_OS_WINDOWS</a>
<a name="ln499"> </a>
<a name="ln500">// Types of SetUpTestCase() and TearDownTestCase() functions.</a>
<a name="ln501">typedef void (*SetUpTestCaseFunc)();</a>
<a name="ln502">typedef void (*TearDownTestCaseFunc)();</a>
<a name="ln503"> </a>
<a name="ln504">struct CodeLocation {</a>
<a name="ln505">  CodeLocation(const string&amp; a_file, int a_line) : file(a_file), line(a_line) {}</a>
<a name="ln506"> </a>
<a name="ln507">  string file;</a>
<a name="ln508">  int line;</a>
<a name="ln509">};</a>
<a name="ln510"> </a>
<a name="ln511">// Creates a new TestInfo object and registers it with Google Test;</a>
<a name="ln512">// returns the created object.</a>
<a name="ln513">//</a>
<a name="ln514">// Arguments:</a>
<a name="ln515">//</a>
<a name="ln516">//   test_case_name:   name of the test case</a>
<a name="ln517">//   name:             name of the test</a>
<a name="ln518">//   type_param        the name of the test's type parameter, or NULL if</a>
<a name="ln519">//                     this is not a typed or a type-parameterized test.</a>
<a name="ln520">//   value_param       text representation of the test's value parameter,</a>
<a name="ln521">//                     or NULL if this is not a type-parameterized test.</a>
<a name="ln522">//   code_location:    code location where the test is defined</a>
<a name="ln523">//   fixture_class_id: ID of the test fixture class</a>
<a name="ln524">//   set_up_tc:        pointer to the function that sets up the test case</a>
<a name="ln525">//   tear_down_tc:     pointer to the function that tears down the test case</a>
<a name="ln526">//   factory:          pointer to the factory that creates a test object.</a>
<a name="ln527">//                     The newly created TestInfo instance will assume</a>
<a name="ln528">//                     ownership of the factory object.</a>
<a name="ln529">GTEST_API_ TestInfo* MakeAndRegisterTestInfo(</a>
<a name="ln530">    const char* test_case_name,</a>
<a name="ln531">    const char* name,</a>
<a name="ln532">    const char* type_param,</a>
<a name="ln533">    const char* value_param,</a>
<a name="ln534">    CodeLocation code_location,</a>
<a name="ln535">    TypeId fixture_class_id,</a>
<a name="ln536">    SetUpTestCaseFunc set_up_tc,</a>
<a name="ln537">    TearDownTestCaseFunc tear_down_tc,</a>
<a name="ln538">    TestFactoryBase* factory);</a>
<a name="ln539"> </a>
<a name="ln540">// If *pstr starts with the given prefix, modifies *pstr to be right</a>
<a name="ln541">// past the prefix and returns true; otherwise leaves *pstr unchanged</a>
<a name="ln542">// and returns false.  None of pstr, *pstr, and prefix can be NULL.</a>
<a name="ln543">GTEST_API_ bool SkipPrefix(const char* prefix, const char** pstr);</a>
<a name="ln544"> </a>
<a name="ln545">#if GTEST_HAS_TYPED_TEST || GTEST_HAS_TYPED_TEST_P</a>
<a name="ln546"> </a>
<a name="ln547">// State of the definition of a type-parameterized test case.</a>
<a name="ln548">class GTEST_API_ TypedTestCasePState {</a>
<a name="ln549"> public:</a>
<a name="ln550">  TypedTestCasePState() : registered_(false) {}</a>
<a name="ln551"> </a>
<a name="ln552">  // Adds the given test name to defined_test_names_ and return true</a>
<a name="ln553">  // if the test case hasn't been registered; otherwise aborts the</a>
<a name="ln554">  // program.</a>
<a name="ln555">  bool AddTestName(const char* file, int line, const char* case_name,</a>
<a name="ln556">                   const char* test_name) {</a>
<a name="ln557">    if (registered_) {</a>
<a name="ln558">      fprintf(stderr, &quot;%s Test %s must be defined before &quot;</a>
<a name="ln559">              &quot;REGISTER_TYPED_TEST_CASE_P(%s, ...).\n&quot;,</a>
<a name="ln560">              FormatFileLocation(file, line).c_str(), test_name, case_name);</a>
<a name="ln561">      fflush(stderr);</a>
<a name="ln562">      posix::Abort();</a>
<a name="ln563">    }</a>
<a name="ln564">    registered_tests_.insert(</a>
<a name="ln565">        ::std::make_pair(test_name, CodeLocation(file, line)));</a>
<a name="ln566">    return true;</a>
<a name="ln567">  }</a>
<a name="ln568"> </a>
<a name="ln569">  bool TestExists(const std::string&amp; test_name) const {</a>
<a name="ln570">    return registered_tests_.count(test_name) &gt; 0;</a>
<a name="ln571">  }</a>
<a name="ln572"> </a>
<a name="ln573">  const CodeLocation&amp; GetCodeLocation(const std::string&amp; test_name) const {</a>
<a name="ln574">    RegisteredTestsMap::const_iterator it = registered_tests_.find(test_name);</a>
<a name="ln575">    GTEST_CHECK_(it != registered_tests_.end());</a>
<a name="ln576">    return it-&gt;second;</a>
<a name="ln577">  }</a>
<a name="ln578"> </a>
<a name="ln579">  // Verifies that registered_tests match the test names in</a>
<a name="ln580">  // defined_test_names_; returns registered_tests if successful, or</a>
<a name="ln581">  // aborts the program otherwise.</a>
<a name="ln582">  const char* VerifyRegisteredTestNames(</a>
<a name="ln583">      const char* file, int line, const char* registered_tests);</a>
<a name="ln584"> </a>
<a name="ln585"> private:</a>
<a name="ln586">  typedef ::std::map&lt;std::string, CodeLocation&gt; RegisteredTestsMap;</a>
<a name="ln587"> </a>
<a name="ln588">  bool registered_;</a>
<a name="ln589">  RegisteredTestsMap registered_tests_;</a>
<a name="ln590">};</a>
<a name="ln591"> </a>
<a name="ln592">// Skips to the first non-space char after the first comma in 'str';</a>
<a name="ln593">// returns NULL if no comma is found in 'str'.</a>
<a name="ln594">inline const char* SkipComma(const char* str) {</a>
<a name="ln595">  const char* comma = strchr(str, ',');</a>
<a name="ln596">  if (comma == NULL) {</a>
<a name="ln597">    return NULL;</a>
<a name="ln598">  }</a>
<a name="ln599">  while (IsSpace(*(++comma))) {}</a>
<a name="ln600">  return comma;</a>
<a name="ln601">}</a>
<a name="ln602"> </a>
<a name="ln603">// Returns the prefix of 'str' before the first comma in it; returns</a>
<a name="ln604">// the entire string if it contains no comma.</a>
<a name="ln605">inline std::string GetPrefixUntilComma(const char* str) {</a>
<a name="ln606">  const char* comma = strchr(str, ',');</a>
<a name="ln607">  return comma == NULL ? str : std::string(str, comma);</a>
<a name="ln608">}</a>
<a name="ln609"> </a>
<a name="ln610">// Splits a given string on a given delimiter, populating a given</a>
<a name="ln611">// vector with the fields.</a>
<a name="ln612">void SplitString(const ::std::string&amp; str, char delimiter,</a>
<a name="ln613">                 ::std::vector&lt; ::std::string&gt;* dest);</a>
<a name="ln614"> </a>
<a name="ln615">// TypeParameterizedTest&lt;Fixture, TestSel, Types&gt;::Register()</a>
<a name="ln616">// registers a list of type-parameterized tests with Google Test.  The</a>
<a name="ln617">// return value is insignificant - we just need to return something</a>
<a name="ln618">// such that we can call this function in a namespace scope.</a>
<a name="ln619">//</a>
<a name="ln620">// Implementation note: The GTEST_TEMPLATE_ macro declares a template</a>
<a name="ln621">// template parameter.  It's defined in gtest-type-util.h.</a>
<a name="ln622">template &lt;GTEST_TEMPLATE_ Fixture, class TestSel, typename Types&gt;</a>
<a name="ln623">class TypeParameterizedTest {</a>
<a name="ln624"> public:</a>
<a name="ln625">  // 'index' is the index of the test in the type list 'Types'</a>
<a name="ln626">  // specified in INSTANTIATE_TYPED_TEST_CASE_P(Prefix, TestCase,</a>
<a name="ln627">  // Types).  Valid values for 'index' are [0, N - 1] where N is the</a>
<a name="ln628">  // length of Types.</a>
<a name="ln629">  static bool Register(const char* prefix,</a>
<a name="ln630">                       CodeLocation code_location,</a>
<a name="ln631">                       const char* case_name, const char* test_names,</a>
<a name="ln632">                       int index) {</a>
<a name="ln633">    typedef typename Types::Head Type;</a>
<a name="ln634">    typedef Fixture&lt;Type&gt; FixtureClass;</a>
<a name="ln635">    typedef typename GTEST_BIND_(TestSel, Type) TestClass;</a>
<a name="ln636"> </a>
<a name="ln637">    // First, registers the first type-parameterized test in the type</a>
<a name="ln638">    // list.</a>
<a name="ln639">    MakeAndRegisterTestInfo(</a>
<a name="ln640">        (std::string(prefix) + (prefix[0] == '\0' ? &quot;&quot; : &quot;/&quot;) + case_name + &quot;/&quot;</a>
<a name="ln641">         + StreamableToString(index)).c_str(),</a>
<a name="ln642">        StripTrailingSpaces(GetPrefixUntilComma(test_names)).c_str(),</a>
<a name="ln643">        GetTypeName&lt;Type&gt;().c_str(),</a>
<a name="ln644">        NULL,  // No value parameter.</a>
<a name="ln645">        code_location,</a>
<a name="ln646">        GetTypeId&lt;FixtureClass&gt;(),</a>
<a name="ln647">        TestClass::SetUpTestCase,</a>
<a name="ln648">        TestClass::TearDownTestCase,</a>
<a name="ln649">        new TestFactoryImpl&lt;TestClass&gt;);</a>
<a name="ln650"> </a>
<a name="ln651">    // Next, recurses (at compile time) with the tail of the type list.</a>
<a name="ln652">    return TypeParameterizedTest&lt;Fixture, TestSel, typename Types::Tail&gt;</a>
<a name="ln653">        ::Register(prefix, code_location, case_name, test_names, index + 1);</a>
<a name="ln654">  }</a>
<a name="ln655">};</a>
<a name="ln656"> </a>
<a name="ln657">// The base case for the compile time recursion.</a>
<a name="ln658">template &lt;GTEST_TEMPLATE_ Fixture, class TestSel&gt;</a>
<a name="ln659">class TypeParameterizedTest&lt;Fixture, TestSel, Types0&gt; {</a>
<a name="ln660"> public:</a>
<a name="ln661">  static bool Register(const char* /*prefix*/, CodeLocation,</a>
<a name="ln662">                       const char* /*case_name*/, const char* /*test_names*/,</a>
<a name="ln663">                       int /*index*/) {</a>
<a name="ln664">    return true;</a>
<a name="ln665">  }</a>
<a name="ln666">};</a>
<a name="ln667"> </a>
<a name="ln668">// TypeParameterizedTestCase&lt;Fixture, Tests, Types&gt;::Register()</a>
<a name="ln669">// registers *all combinations* of 'Tests' and 'Types' with Google</a>
<a name="ln670">// Test.  The return value is insignificant - we just need to return</a>
<a name="ln671">// something such that we can call this function in a namespace scope.</a>
<a name="ln672">template &lt;GTEST_TEMPLATE_ Fixture, typename Tests, typename Types&gt;</a>
<a name="ln673">class TypeParameterizedTestCase {</a>
<a name="ln674"> public:</a>
<a name="ln675">  static bool Register(const char* prefix, CodeLocation code_location,</a>
<a name="ln676">                       const TypedTestCasePState* state,</a>
<a name="ln677">                       const char* case_name, const char* test_names) {</a>
<a name="ln678">    std::string test_name = StripTrailingSpaces(</a>
<a name="ln679">        GetPrefixUntilComma(test_names));</a>
<a name="ln680">    if (!state-&gt;TestExists(test_name)) {</a>
<a name="ln681">      fprintf(stderr, &quot;Failed to get code location for test %s.%s at %s.&quot;,</a>
<a name="ln682">              case_name, test_name.c_str(),</a>
<a name="ln683">              FormatFileLocation(code_location.file.c_str(),</a>
<a name="ln684">                                 code_location.line).c_str());</a>
<a name="ln685">      fflush(stderr);</a>
<a name="ln686">      posix::Abort();</a>
<a name="ln687">    }</a>
<a name="ln688">    const CodeLocation&amp; test_location = state-&gt;GetCodeLocation(test_name);</a>
<a name="ln689"> </a>
<a name="ln690">    typedef typename Tests::Head Head;</a>
<a name="ln691"> </a>
<a name="ln692">    // First, register the first test in 'Test' for each type in 'Types'.</a>
<a name="ln693">    TypeParameterizedTest&lt;Fixture, Head, Types&gt;::Register(</a>
<a name="ln694">        prefix, test_location, case_name, test_names, 0);</a>
<a name="ln695"> </a>
<a name="ln696">    // Next, recurses (at compile time) with the tail of the test list.</a>
<a name="ln697">    return TypeParameterizedTestCase&lt;Fixture, typename Tests::Tail, Types&gt;</a>
<a name="ln698">        ::Register(prefix, code_location, state,</a>
<a name="ln699">                   case_name, SkipComma(test_names));</a>
<a name="ln700">  }</a>
<a name="ln701">};</a>
<a name="ln702"> </a>
<a name="ln703">// The base case for the compile time recursion.</a>
<a name="ln704">template &lt;GTEST_TEMPLATE_ Fixture, typename Types&gt;</a>
<a name="ln705">class TypeParameterizedTestCase&lt;Fixture, Templates0, Types&gt; {</a>
<a name="ln706"> public:</a>
<a name="ln707">  static bool Register(const char* /*prefix*/, CodeLocation,</a>
<a name="ln708">                       const TypedTestCasePState* /*state*/,</a>
<a name="ln709">                       const char* /*case_name*/, const char* /*test_names*/) {</a>
<a name="ln710">    return true;</a>
<a name="ln711">  }</a>
<a name="ln712">};</a>
<a name="ln713"> </a>
<a name="ln714">#endif  // GTEST_HAS_TYPED_TEST || GTEST_HAS_TYPED_TEST_P</a>
<a name="ln715"> </a>
<a name="ln716">// Returns the current OS stack trace as an std::string.</a>
<a name="ln717">//</a>
<a name="ln718">// The maximum number of stack frames to be included is specified by</a>
<a name="ln719">// the gtest_stack_trace_depth flag.  The skip_count parameter</a>
<a name="ln720">// specifies the number of top frames to be skipped, which doesn't</a>
<a name="ln721">// count against the number of frames to be included.</a>
<a name="ln722">//</a>
<a name="ln723">// For example, if Foo() calls Bar(), which in turn calls</a>
<a name="ln724">// GetCurrentOsStackTraceExceptTop(..., 1), Foo() will be included in</a>
<a name="ln725">// the trace but Bar() and GetCurrentOsStackTraceExceptTop() won't.</a>
<a name="ln726">GTEST_API_ std::string GetCurrentOsStackTraceExceptTop(</a>
<a name="ln727">    UnitTest* unit_test, int skip_count);</a>
<a name="ln728"> </a>
<a name="ln729">// Helpers for suppressing warnings on unreachable code or constant</a>
<a name="ln730">// condition.</a>
<a name="ln731"> </a>
<a name="ln732">// Always returns true.</a>
<a name="ln733">GTEST_API_ bool AlwaysTrue();</a>
<a name="ln734"> </a>
<a name="ln735">// Always returns false.</a>
<a name="ln736">inline bool AlwaysFalse() { return !AlwaysTrue(); }</a>
<a name="ln737"> </a>
<a name="ln738">// Helper for suppressing false warning from Clang on a const char*</a>
<a name="ln739">// variable declared in a conditional expression always being NULL in</a>
<a name="ln740">// the else branch.</a>
<a name="ln741">struct GTEST_API_ ConstCharPtr {</a>
<a name="ln742">  ConstCharPtr(const char* str) : value(str) {}</a>
<a name="ln743">  operator bool() const { return true; }</a>
<a name="ln744">  const char* value;</a>
<a name="ln745">};</a>
<a name="ln746"> </a>
<a name="ln747">// A simple Linear Congruential Generator for generating random</a>
<a name="ln748">// numbers with a uniform distribution.  Unlike rand() and srand(), it</a>
<a name="ln749">// doesn't use global state (and therefore can't interfere with user</a>
<a name="ln750">// code).  Unlike rand_r(), it's portable.  An LCG isn't very random,</a>
<a name="ln751">// but it's good enough for our purposes.</a>
<a name="ln752">class GTEST_API_ Random {</a>
<a name="ln753"> public:</a>
<a name="ln754">  static const UInt32 kMaxRange = 1u &lt;&lt; 31;</a>
<a name="ln755"> </a>
<a name="ln756">  explicit Random(UInt32 seed) : state_(seed) {}</a>
<a name="ln757"> </a>
<a name="ln758">  void Reseed(UInt32 seed) { state_ = seed; }</a>
<a name="ln759"> </a>
<a name="ln760">  // Generates a random number from [0, range).  Crashes if 'range' is</a>
<a name="ln761">  // 0 or greater than kMaxRange.</a>
<a name="ln762">  UInt32 Generate(UInt32 range);</a>
<a name="ln763"> </a>
<a name="ln764"> private:</a>
<a name="ln765">  UInt32 state_;</a>
<a name="ln766">  GTEST_DISALLOW_COPY_AND_ASSIGN_(Random);</a>
<a name="ln767">};</a>
<a name="ln768"> </a>
<a name="ln769">// Defining a variable of type CompileAssertTypesEqual&lt;T1, T2&gt; will cause a</a>
<a name="ln770">// compiler error iff T1 and T2 are different types.</a>
<a name="ln771">template &lt;typename T1, typename T2&gt;</a>
<a name="ln772">struct CompileAssertTypesEqual;</a>
<a name="ln773"> </a>
<a name="ln774">template &lt;typename T&gt;</a>
<a name="ln775">struct CompileAssertTypesEqual&lt;T, T&gt; {</a>
<a name="ln776">};</a>
<a name="ln777"> </a>
<a name="ln778">// Removes the reference from a type if it is a reference type,</a>
<a name="ln779">// otherwise leaves it unchanged.  This is the same as</a>
<a name="ln780">// tr1::remove_reference, which is not widely available yet.</a>
<a name="ln781">template &lt;typename T&gt;</a>
<a name="ln782">struct RemoveReference { typedef T type; };  // NOLINT</a>
<a name="ln783">template &lt;typename T&gt;</a>
<a name="ln784">struct RemoveReference&lt;T&amp;&gt; { typedef T type; };  // NOLINT</a>
<a name="ln785"> </a>
<a name="ln786">// A handy wrapper around RemoveReference that works when the argument</a>
<a name="ln787">// T depends on template parameters.</a>
<a name="ln788">#define GTEST_REMOVE_REFERENCE_(T) \</a>
<a name="ln789">    typename ::testing::internal::RemoveReference&lt;T&gt;::type</a>
<a name="ln790"> </a>
<a name="ln791">// Removes const from a type if it is a const type, otherwise leaves</a>
<a name="ln792">// it unchanged.  This is the same as tr1::remove_const, which is not</a>
<a name="ln793">// widely available yet.</a>
<a name="ln794">template &lt;typename T&gt;</a>
<a name="ln795">struct RemoveConst { typedef T type; };  // NOLINT</a>
<a name="ln796">template &lt;typename T&gt;</a>
<a name="ln797">struct RemoveConst&lt;const T&gt; { typedef T type; };  // NOLINT</a>
<a name="ln798"> </a>
<a name="ln799">// MSVC 8.0, Sun C++, and IBM XL C++ have a bug which causes the above</a>
<a name="ln800">// definition to fail to remove the const in 'const int[3]' and 'const</a>
<a name="ln801">// char[3][4]'.  The following specialization works around the bug.</a>
<a name="ln802">template &lt;typename T, size_t N&gt;</a>
<a name="ln803">struct RemoveConst&lt;const T[N]&gt; {</a>
<a name="ln804">  typedef typename RemoveConst&lt;T&gt;::type type[N];</a>
<a name="ln805">};</a>
<a name="ln806"> </a>
<a name="ln807">#if defined(_MSC_VER) &amp;&amp; _MSC_VER &lt; 1400</a>
<a name="ln808">// This is the only specialization that allows VC++ 7.1 to remove const in</a>
<a name="ln809">// 'const int[3] and 'const int[3][4]'.  However, it causes trouble with GCC</a>
<a name="ln810">// and thus needs to be conditionally compiled.</a>
<a name="ln811">template &lt;typename T, size_t N&gt;</a>
<a name="ln812">struct RemoveConst&lt;T[N]&gt; {</a>
<a name="ln813">  typedef typename RemoveConst&lt;T&gt;::type type[N];</a>
<a name="ln814">};</a>
<a name="ln815">#endif</a>
<a name="ln816"> </a>
<a name="ln817">// A handy wrapper around RemoveConst that works when the argument</a>
<a name="ln818">// T depends on template parameters.</a>
<a name="ln819">#define GTEST_REMOVE_CONST_(T) \</a>
<a name="ln820">    typename ::testing::internal::RemoveConst&lt;T&gt;::type</a>
<a name="ln821"> </a>
<a name="ln822">// Turns const U&amp;, U&amp;, const U, and U all into U.</a>
<a name="ln823">#define GTEST_REMOVE_REFERENCE_AND_CONST_(T) \</a>
<a name="ln824">    GTEST_REMOVE_CONST_(GTEST_REMOVE_REFERENCE_(T))</a>
<a name="ln825"> </a>
<a name="ln826">// Adds reference to a type if it is not a reference type,</a>
<a name="ln827">// otherwise leaves it unchanged.  This is the same as</a>
<a name="ln828">// tr1::add_reference, which is not widely available yet.</a>
<a name="ln829">template &lt;typename T&gt;</a>
<a name="ln830">struct AddReference { typedef T&amp; type; };  // NOLINT</a>
<a name="ln831">template &lt;typename T&gt;</a>
<a name="ln832">struct AddReference&lt;T&amp;&gt; { typedef T&amp; type; };  // NOLINT</a>
<a name="ln833"> </a>
<a name="ln834">// A handy wrapper around AddReference that works when the argument T</a>
<a name="ln835">// depends on template parameters.</a>
<a name="ln836">#define GTEST_ADD_REFERENCE_(T) \</a>
<a name="ln837">    typename ::testing::internal::AddReference&lt;T&gt;::type</a>
<a name="ln838"> </a>
<a name="ln839">// Adds a reference to const on top of T as necessary.  For example,</a>
<a name="ln840">// it transforms</a>
<a name="ln841">//</a>
<a name="ln842">//   char         ==&gt; const char&amp;</a>
<a name="ln843">//   const char   ==&gt; const char&amp;</a>
<a name="ln844">//   char&amp;        ==&gt; const char&amp;</a>
<a name="ln845">//   const char&amp;  ==&gt; const char&amp;</a>
<a name="ln846">//</a>
<a name="ln847">// The argument T must depend on some template parameters.</a>
<a name="ln848">#define GTEST_REFERENCE_TO_CONST_(T) \</a>
<a name="ln849">    GTEST_ADD_REFERENCE_(const GTEST_REMOVE_REFERENCE_(T))</a>
<a name="ln850"> </a>
<a name="ln851">// ImplicitlyConvertible&lt;From, To&gt;::value is a compile-time bool</a>
<a name="ln852">// constant that's true iff type From can be implicitly converted to</a>
<a name="ln853">// type To.</a>
<a name="ln854">template &lt;typename From, typename To&gt;</a>
<a name="ln855">class ImplicitlyConvertible {</a>
<a name="ln856"> private:</a>
<a name="ln857">  // We need the following helper functions only for their types.</a>
<a name="ln858">  // They have no implementations.</a>
<a name="ln859"> </a>
<a name="ln860">  // MakeFrom() is an expression whose type is From.  We cannot simply</a>
<a name="ln861">  // use From(), as the type From may not have a public default</a>
<a name="ln862">  // constructor.</a>
<a name="ln863">  static typename AddReference&lt;From&gt;::type MakeFrom();</a>
<a name="ln864"> </a>
<a name="ln865">  // These two functions are overloaded.  Given an expression</a>
<a name="ln866">  // Helper(x), the compiler will pick the first version if x can be</a>
<a name="ln867">  // implicitly converted to type To; otherwise it will pick the</a>
<a name="ln868">  // second version.</a>
<a name="ln869">  //</a>
<a name="ln870">  // The first version returns a value of size 1, and the second</a>
<a name="ln871">  // version returns a value of size 2.  Therefore, by checking the</a>
<a name="ln872">  // size of Helper(x), which can be done at compile time, we can tell</a>
<a name="ln873">  // which version of Helper() is used, and hence whether x can be</a>
<a name="ln874">  // implicitly converted to type To.</a>
<a name="ln875">  static char Helper(To);</a>
<a name="ln876">  static char (&amp;Helper(...))[2];  // NOLINT</a>
<a name="ln877"> </a>
<a name="ln878">  // We have to put the 'public' section after the 'private' section,</a>
<a name="ln879">  // or MSVC refuses to compile the code.</a>
<a name="ln880"> public:</a>
<a name="ln881">#if defined(__BORLANDC__)</a>
<a name="ln882">  // C++Builder cannot use member overload resolution during template</a>
<a name="ln883">  // instantiation.  The simplest workaround is to use its C++0x type traits</a>
<a name="ln884">  // functions (C++Builder 2009 and above only).</a>
<a name="ln885">  static const bool value = __is_convertible(From, To);</a>
<a name="ln886">#else</a>
<a name="ln887">  // MSVC warns about implicitly converting from double to int for</a>
<a name="ln888">  // possible loss of data, so we need to temporarily disable the</a>
<a name="ln889">  // warning.</a>
<a name="ln890">  GTEST_DISABLE_MSC_WARNINGS_PUSH_(4244)</a>
<a name="ln891">  static const bool value =</a>
<a name="ln892">      sizeof(Helper(ImplicitlyConvertible::MakeFrom())) == 1;</a>
<a name="ln893">  GTEST_DISABLE_MSC_WARNINGS_POP_()</a>
<a name="ln894">#endif  // __BORLANDC__</a>
<a name="ln895">};</a>
<a name="ln896">template &lt;typename From, typename To&gt;</a>
<a name="ln897">const bool ImplicitlyConvertible&lt;From, To&gt;::value;</a>
<a name="ln898"> </a>
<a name="ln899">// IsAProtocolMessage&lt;T&gt;::value is a compile-time bool constant that's</a>
<a name="ln900">// true iff T is type ProtocolMessage, proto2::Message, or a subclass</a>
<a name="ln901">// of those.</a>
<a name="ln902">template &lt;typename T&gt;</a>
<a name="ln903">struct IsAProtocolMessage</a>
<a name="ln904">    : public bool_constant&lt;</a>
<a name="ln905">  ImplicitlyConvertible&lt;const T*, const ::ProtocolMessage*&gt;::value ||</a>
<a name="ln906">  ImplicitlyConvertible&lt;const T*, const ::proto2::Message*&gt;::value&gt; {</a>
<a name="ln907">};</a>
<a name="ln908"> </a>
<a name="ln909">// When the compiler sees expression IsContainerTest&lt;C&gt;(0), if C is an</a>
<a name="ln910">// STL-style container class, the first overload of IsContainerTest</a>
<a name="ln911">// will be viable (since both C::iterator* and C::const_iterator* are</a>
<a name="ln912">// valid types and NULL can be implicitly converted to them).  It will</a>
<a name="ln913">// be picked over the second overload as 'int' is a perfect match for</a>
<a name="ln914">// the type of argument 0.  If C::iterator or C::const_iterator is not</a>
<a name="ln915">// a valid type, the first overload is not viable, and the second</a>
<a name="ln916">// overload will be picked.  Therefore, we can determine whether C is</a>
<a name="ln917">// a container class by checking the type of IsContainerTest&lt;C&gt;(0).</a>
<a name="ln918">// The value of the expression is insignificant.</a>
<a name="ln919">//</a>
<a name="ln920">// Note that we look for both C::iterator and C::const_iterator.  The</a>
<a name="ln921">// reason is that C++ injects the name of a class as a member of the</a>
<a name="ln922">// class itself (e.g. you can refer to class iterator as either</a>
<a name="ln923">// 'iterator' or 'iterator::iterator').  If we look for C::iterator</a>
<a name="ln924">// only, for example, we would mistakenly think that a class named</a>
<a name="ln925">// iterator is an STL container.</a>
<a name="ln926">//</a>
<a name="ln927">// Also note that the simpler approach of overloading</a>
<a name="ln928">// IsContainerTest(typename C::const_iterator*) and</a>
<a name="ln929">// IsContainerTest(...) doesn't work with Visual Age C++ and Sun C++.</a>
<a name="ln930">typedef int IsContainer;</a>
<a name="ln931">template &lt;class C&gt;</a>
<a name="ln932">IsContainer IsContainerTest(int /* dummy */,</a>
<a name="ln933">                            typename C::iterator* /* it */ = NULL,</a>
<a name="ln934">                            typename C::const_iterator* /* const_it */ = NULL) {</a>
<a name="ln935">  return 0;</a>
<a name="ln936">}</a>
<a name="ln937"> </a>
<a name="ln938">typedef char IsNotContainer;</a>
<a name="ln939">template &lt;class C&gt;</a>
<a name="ln940">IsNotContainer IsContainerTest(long /* dummy */) { return '\0'; }</a>
<a name="ln941"> </a>
<a name="ln942">// EnableIf&lt;condition&gt;::type is void when 'Cond' is true, and</a>
<a name="ln943">// undefined when 'Cond' is false.  To use SFINAE to make a function</a>
<a name="ln944">// overload only apply when a particular expression is true, add</a>
<a name="ln945">// &quot;typename EnableIf&lt;expression&gt;::type* = 0&quot; as the last parameter.</a>
<a name="ln946">template&lt;bool&gt; struct EnableIf;</a>
<a name="ln947">template&lt;&gt; struct EnableIf&lt;true&gt; { typedef void type; };  // NOLINT</a>
<a name="ln948"> </a>
<a name="ln949">// Utilities for native arrays.</a>
<a name="ln950"> </a>
<a name="ln951">// ArrayEq() compares two k-dimensional native arrays using the</a>
<a name="ln952">// elements' operator==, where k can be any integer &gt;= 0.  When k is</a>
<a name="ln953">// 0, ArrayEq() degenerates into comparing a single pair of values.</a>
<a name="ln954"> </a>
<a name="ln955">template &lt;typename T, typename U&gt;</a>
<a name="ln956">bool ArrayEq(const T* lhs, size_t size, const U* rhs);</a>
<a name="ln957"> </a>
<a name="ln958">// This generic version is used when k is 0.</a>
<a name="ln959">template &lt;typename T, typename U&gt;</a>
<a name="ln960">inline bool ArrayEq(const T&amp; lhs, const U&amp; rhs) { return lhs == rhs; }</a>
<a name="ln961"> </a>
<a name="ln962">// This overload is used when k &gt;= 1.</a>
<a name="ln963">template &lt;typename T, typename U, size_t N&gt;</a>
<a name="ln964">inline bool ArrayEq(const T(&amp;lhs)[N], const U(&amp;rhs)[N]) {</a>
<a name="ln965">  return internal::ArrayEq(lhs, N, rhs);</a>
<a name="ln966">}</a>
<a name="ln967"> </a>
<a name="ln968">// This helper reduces code bloat.  If we instead put its logic inside</a>
<a name="ln969">// the previous ArrayEq() function, arrays with different sizes would</a>
<a name="ln970">// lead to different copies of the template code.</a>
<a name="ln971">template &lt;typename T, typename U&gt;</a>
<a name="ln972">bool ArrayEq(const T* lhs, size_t size, const U* rhs) {</a>
<a name="ln973">  for (size_t i = 0; i != size; i++) {</a>
<a name="ln974">    if (!internal::ArrayEq(lhs[i], rhs[i]))</a>
<a name="ln975">      return false;</a>
<a name="ln976">  }</a>
<a name="ln977">  return true;</a>
<a name="ln978">}</a>
<a name="ln979"> </a>
<a name="ln980">// Finds the first element in the iterator range [begin, end) that</a>
<a name="ln981">// equals elem.  Element may be a native array type itself.</a>
<a name="ln982">template &lt;typename Iter, typename Element&gt;</a>
<a name="ln983">Iter ArrayAwareFind(Iter begin, Iter end, const Element&amp; elem) {</a>
<a name="ln984">  for (Iter it = begin; it != end; ++it) {</a>
<a name="ln985">    if (internal::ArrayEq(*it, elem))</a>
<a name="ln986">      return it;</a>
<a name="ln987">  }</a>
<a name="ln988">  return end;</a>
<a name="ln989">}</a>
<a name="ln990"> </a>
<a name="ln991">// CopyArray() copies a k-dimensional native array using the elements'</a>
<a name="ln992">// operator=, where k can be any integer &gt;= 0.  When k is 0,</a>
<a name="ln993">// CopyArray() degenerates into copying a single value.</a>
<a name="ln994"> </a>
<a name="ln995">template &lt;typename T, typename U&gt;</a>
<a name="ln996">void CopyArray(const T* from, size_t size, U* to);</a>
<a name="ln997"> </a>
<a name="ln998">// This generic version is used when k is 0.</a>
<a name="ln999">template &lt;typename T, typename U&gt;</a>
<a name="ln1000">inline void CopyArray(const T&amp; from, U* to) { *to = from; }</a>
<a name="ln1001"> </a>
<a name="ln1002">// This overload is used when k &gt;= 1.</a>
<a name="ln1003">template &lt;typename T, typename U, size_t N&gt;</a>
<a name="ln1004">inline void CopyArray(const T(&amp;from)[N], U(*to)[N]) {</a>
<a name="ln1005">  internal::CopyArray(from, N, *to);</a>
<a name="ln1006">}</a>
<a name="ln1007"> </a>
<a name="ln1008">// This helper reduces code bloat.  If we instead put its logic inside</a>
<a name="ln1009">// the previous CopyArray() function, arrays with different sizes</a>
<a name="ln1010">// would lead to different copies of the template code.</a>
<a name="ln1011">template &lt;typename T, typename U&gt;</a>
<a name="ln1012">void CopyArray(const T* from, size_t size, U* to) {</a>
<a name="ln1013">  for (size_t i = 0; i != size; i++) {</a>
<a name="ln1014">    internal::CopyArray(from[i], to + i);</a>
<a name="ln1015">  }</a>
<a name="ln1016">}</a>
<a name="ln1017"> </a>
<a name="ln1018">// The relation between an NativeArray object (see below) and the</a>
<a name="ln1019">// native array it represents.</a>
<a name="ln1020">// We use 2 different structs to allow non-copyable types to be used, as long</a>
<a name="ln1021">// as RelationToSourceReference() is passed.</a>
<a name="ln1022">struct RelationToSourceReference {};</a>
<a name="ln1023">struct RelationToSourceCopy {};</a>
<a name="ln1024"> </a>
<a name="ln1025">// Adapts a native array to a read-only STL-style container.  Instead</a>
<a name="ln1026">// of the complete STL container concept, this adaptor only implements</a>
<a name="ln1027">// members useful for Google Mock's container matchers.  New members</a>
<a name="ln1028">// should be added as needed.  To simplify the implementation, we only</a>
<a name="ln1029">// support Element being a raw type (i.e. having no top-level const or</a>
<a name="ln1030">// reference modifier).  It's the client's responsibility to satisfy</a>
<a name="ln1031">// this requirement.  Element can be an array type itself (hence</a>
<a name="ln1032">// multi-dimensional arrays are supported).</a>
<a name="ln1033">template &lt;typename Element&gt;</a>
<a name="ln1034">class NativeArray {</a>
<a name="ln1035"> public:</a>
<a name="ln1036">  // STL-style container typedefs.</a>
<a name="ln1037">  typedef Element value_type;</a>
<a name="ln1038">  typedef Element* iterator;</a>
<a name="ln1039">  typedef const Element* const_iterator;</a>
<a name="ln1040"> </a>
<a name="ln1041">  // Constructs from a native array. References the source.</a>
<a name="ln1042">  NativeArray(const Element* array, size_t count, RelationToSourceReference) {</a>
<a name="ln1043">    InitRef(array, count);</a>
<a name="ln1044">  }</a>
<a name="ln1045"> </a>
<a name="ln1046">  // Constructs from a native array. Copies the source.</a>
<a name="ln1047">  NativeArray(const Element* array, size_t count, RelationToSourceCopy) {</a>
<a name="ln1048">    InitCopy(array, count);</a>
<a name="ln1049">  }</a>
<a name="ln1050"> </a>
<a name="ln1051">  // Copy constructor.</a>
<a name="ln1052">  NativeArray(const NativeArray&amp; rhs) {</a>
<a name="ln1053">    (this-&gt;*rhs.clone_)(rhs.array_, rhs.size_);</a>
<a name="ln1054">  }</a>
<a name="ln1055"> </a>
<a name="ln1056">  ~NativeArray() {</a>
<a name="ln1057">    if (clone_ != &amp;NativeArray::InitRef)</a>
<a name="ln1058">      delete[] array_;</a>
<a name="ln1059">  }</a>
<a name="ln1060"> </a>
<a name="ln1061">  // STL-style container methods.</a>
<a name="ln1062">  size_t size() const { return size_; }</a>
<a name="ln1063">  const_iterator begin() const { return array_; }</a>
<a name="ln1064">  const_iterator end() const { return array_ + size_; }</a>
<a name="ln1065">  bool operator==(const NativeArray&amp; rhs) const {</a>
<a name="ln1066">    return size() == rhs.size() &amp;&amp;</a>
<a name="ln1067">        ArrayEq(begin(), size(), rhs.begin());</a>
<a name="ln1068">  }</a>
<a name="ln1069"> </a>
<a name="ln1070"> private:</a>
<a name="ln1071">  enum {</a>
<a name="ln1072">    kCheckTypeIsNotConstOrAReference = StaticAssertTypeEqHelper&lt;</a>
<a name="ln1073">        Element, GTEST_REMOVE_REFERENCE_AND_CONST_(Element)&gt;::value,</a>
<a name="ln1074">  };</a>
<a name="ln1075"> </a>
<a name="ln1076">  // Initializes this object with a copy of the input.</a>
<a name="ln1077">  void InitCopy(const Element* array, size_t a_size) {</a>
<a name="ln1078">    Element* const copy = new Element[a_size];</a>
<a name="ln1079">    CopyArray(array, a_size, copy);</a>
<a name="ln1080">    array_ = copy;</a>
<a name="ln1081">    size_ = a_size;</a>
<a name="ln1082">    clone_ = &amp;NativeArray::InitCopy;</a>
<a name="ln1083">  }</a>
<a name="ln1084"> </a>
<a name="ln1085">  // Initializes this object with a reference of the input.</a>
<a name="ln1086">  void InitRef(const Element* array, size_t a_size) {</a>
<a name="ln1087">    array_ = array;</a>
<a name="ln1088">    size_ = a_size;</a>
<a name="ln1089">    clone_ = &amp;NativeArray::InitRef;</a>
<a name="ln1090">  }</a>
<a name="ln1091"> </a>
<a name="ln1092">  const Element* array_;</a>
<a name="ln1093">  size_t size_;</a>
<a name="ln1094">  void (NativeArray::*clone_)(const Element*, size_t);</a>
<a name="ln1095"> </a>
<a name="ln1096">  GTEST_DISALLOW_ASSIGN_(NativeArray);</a>
<a name="ln1097">};</a>
<a name="ln1098"> </a>
<a name="ln1099">}  // namespace internal</a>
<a name="ln1100">}  // namespace testing</a>
<a name="ln1101"> </a>
<a name="ln1102">#define GTEST_MESSAGE_AT_(file, line, message, result_type) \</a>
<a name="ln1103">  ::testing::internal::AssertHelper(result_type, file, line, message) \</a>
<a name="ln1104">    = ::testing::Message()</a>
<a name="ln1105"> </a>
<a name="ln1106">#define GTEST_MESSAGE_(message, result_type) \</a>
<a name="ln1107">  GTEST_MESSAGE_AT_(__FILE__, __LINE__, message, result_type)</a>
<a name="ln1108"> </a>
<a name="ln1109">#define GTEST_FATAL_FAILURE_(message) \</a>
<a name="ln1110">  return GTEST_MESSAGE_(message, ::testing::TestPartResult::kFatalFailure)</a>
<a name="ln1111"> </a>
<a name="ln1112">#define GTEST_NONFATAL_FAILURE_(message) \</a>
<a name="ln1113">  GTEST_MESSAGE_(message, ::testing::TestPartResult::kNonFatalFailure)</a>
<a name="ln1114"> </a>
<a name="ln1115">#define GTEST_SUCCESS_(message) \</a>
<a name="ln1116">  GTEST_MESSAGE_(message, ::testing::TestPartResult::kSuccess)</a>
<a name="ln1117"> </a>
<a name="ln1118">// Suppresses MSVC warnings 4072 (unreachable code) for the code following</a>
<a name="ln1119">// statement if it returns or throws (or doesn't return or throw in some</a>
<a name="ln1120">// situations).</a>
<a name="ln1121">#define GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement) \</a>
<a name="ln1122">  if (::testing::internal::AlwaysTrue()) { statement; }</a>
<a name="ln1123"> </a>
<a name="ln1124">#define GTEST_TEST_THROW_(statement, expected_exception, fail) \</a>
<a name="ln1125">  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \</a>
<a name="ln1126">  if (::testing::internal::ConstCharPtr gtest_msg = &quot;&quot;) { \</a>
<a name="ln1127">    bool gtest_caught_expected = false; \</a>
<a name="ln1128">    try { \</a>
<a name="ln1129">      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \</a>
<a name="ln1130">    } \</a>
<a name="ln1131">    catch (expected_exception const&amp;) { \</a>
<a name="ln1132">      gtest_caught_expected = true; \</a>
<a name="ln1133">    } \</a>
<a name="ln1134">    catch (...) { \</a>
<a name="ln1135">      gtest_msg.value = \</a>
<a name="ln1136">          &quot;Expected: &quot; #statement &quot; throws an exception of type &quot; \</a>
<a name="ln1137">          #expected_exception &quot;.\n  Actual: it throws a different type.&quot;; \</a>
<a name="ln1138">      goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__); \</a>
<a name="ln1139">    } \</a>
<a name="ln1140">    if (!gtest_caught_expected) { \</a>
<a name="ln1141">      gtest_msg.value = \</a>
<a name="ln1142">          &quot;Expected: &quot; #statement &quot; throws an exception of type &quot; \</a>
<a name="ln1143">          #expected_exception &quot;.\n  Actual: it throws nothing.&quot;; \</a>
<a name="ln1144">      goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__); \</a>
<a name="ln1145">    } \</a>
<a name="ln1146">  } else \</a>
<a name="ln1147">    GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__): \</a>
<a name="ln1148">      fail(gtest_msg.value)</a>
<a name="ln1149"> </a>
<a name="ln1150">#define GTEST_TEST_NO_THROW_(statement, fail) \</a>
<a name="ln1151">  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \</a>
<a name="ln1152">  if (::testing::internal::AlwaysTrue()) { \</a>
<a name="ln1153">    try { \</a>
<a name="ln1154">      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \</a>
<a name="ln1155">    } \</a>
<a name="ln1156">    catch (...) { \</a>
<a name="ln1157">      goto GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__); \</a>
<a name="ln1158">    } \</a>
<a name="ln1159">  } else \</a>
<a name="ln1160">    GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__): \</a>
<a name="ln1161">      fail(&quot;Expected: &quot; #statement &quot; doesn't throw an exception.\n&quot; \</a>
<a name="ln1162">           &quot;  Actual: it throws.&quot;)</a>
<a name="ln1163"> </a>
<a name="ln1164">#define GTEST_TEST_ANY_THROW_(statement, fail) \</a>
<a name="ln1165">  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \</a>
<a name="ln1166">  if (::testing::internal::AlwaysTrue()) { \</a>
<a name="ln1167">    bool gtest_caught_any = false; \</a>
<a name="ln1168">    try { \</a>
<a name="ln1169">      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \</a>
<a name="ln1170">    } \</a>
<a name="ln1171">    catch (...) { \</a>
<a name="ln1172">      gtest_caught_any = true; \</a>
<a name="ln1173">    } \</a>
<a name="ln1174">    if (!gtest_caught_any) { \</a>
<a name="ln1175">      goto GTEST_CONCAT_TOKEN_(gtest_label_testanythrow_, __LINE__); \</a>
<a name="ln1176">    } \</a>
<a name="ln1177">  } else \</a>
<a name="ln1178">    GTEST_CONCAT_TOKEN_(gtest_label_testanythrow_, __LINE__): \</a>
<a name="ln1179">      fail(&quot;Expected: &quot; #statement &quot; throws an exception.\n&quot; \</a>
<a name="ln1180">           &quot;  Actual: it doesn't.&quot;)</a>
<a name="ln1181"> </a>
<a name="ln1182"> </a>
<a name="ln1183">// Implements Boolean test assertions such as EXPECT_TRUE. expression can be</a>
<a name="ln1184">// either a boolean expression or an AssertionResult. text is a textual</a>
<a name="ln1185">// represenation of expression as it was passed into the EXPECT_TRUE.</a>
<a name="ln1186">#define GTEST_TEST_BOOLEAN_(expression, text, actual, expected, fail) \</a>
<a name="ln1187">  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \</a>
<a name="ln1188">  if (const ::testing::AssertionResult gtest_ar_ = \</a>
<a name="ln1189">      ::testing::AssertionResult(expression)) \</a>
<a name="ln1190">    ; \</a>
<a name="ln1191">  else \</a>
<a name="ln1192">    fail(::testing::internal::GetBoolAssertionFailureMessage(\</a>
<a name="ln1193">        gtest_ar_, text, #actual, #expected).c_str())</a>
<a name="ln1194"> </a>
<a name="ln1195">#define GTEST_TEST_NO_FATAL_FAILURE_(statement, fail) \</a>
<a name="ln1196">  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \</a>
<a name="ln1197">  if (::testing::internal::AlwaysTrue()) { \</a>
<a name="ln1198">    ::testing::internal::HasNewFatalFailureHelper gtest_fatal_failure_checker; \</a>
<a name="ln1199">    GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \</a>
<a name="ln1200">    if (gtest_fatal_failure_checker.has_new_fatal_failure()) { \</a>
<a name="ln1201">      goto GTEST_CONCAT_TOKEN_(gtest_label_testnofatal_, __LINE__); \</a>
<a name="ln1202">    } \</a>
<a name="ln1203">  } else \</a>
<a name="ln1204">    GTEST_CONCAT_TOKEN_(gtest_label_testnofatal_, __LINE__): \</a>
<a name="ln1205">      fail(&quot;Expected: &quot; #statement &quot; doesn't generate new fatal &quot; \</a>
<a name="ln1206">           &quot;failures in the current thread.\n&quot; \</a>
<a name="ln1207">           &quot;  Actual: it does.&quot;)</a>
<a name="ln1208"> </a>
<a name="ln1209">// Expands to the name of the class that implements the given test.</a>
<a name="ln1210">#define GTEST_TEST_CLASS_NAME_(test_case_name, test_name) \</a>
<a name="ln1211">  test_case_name##_##test_name##_Test</a>
<a name="ln1212"> </a>
<a name="ln1213">// Helper macro for defining tests.</a>
<a name="ln1214">#define GTEST_TEST_(test_case_name, test_name, parent_class, parent_id)\</a>
<a name="ln1215">class GTEST_TEST_CLASS_NAME_(test_case_name, test_name) : public parent_class {\</a>
<a name="ln1216"> public:\</a>
<a name="ln1217">  GTEST_TEST_CLASS_NAME_(test_case_name, test_name)() {}\</a>
<a name="ln1218"> private:\</a>
<a name="ln1219">  virtual void TestBody();\</a>
<a name="ln1220">  static ::testing::TestInfo* const test_info_ GTEST_ATTRIBUTE_UNUSED_;\</a>
<a name="ln1221">  GTEST_DISALLOW_COPY_AND_ASSIGN_(\</a>
<a name="ln1222">      GTEST_TEST_CLASS_NAME_(test_case_name, test_name));\</a>
<a name="ln1223">};\</a>
<a name="ln1224">\</a>
<a name="ln1225">::testing::TestInfo* const GTEST_TEST_CLASS_NAME_(test_case_name, test_name)\</a>
<a name="ln1226">  ::test_info_ =\</a>
<a name="ln1227">    ::testing::internal::MakeAndRegisterTestInfo(\</a>
<a name="ln1228">        #test_case_name, #test_name, NULL, NULL, \</a>
<a name="ln1229">        ::testing::internal::CodeLocation(__FILE__, __LINE__), \</a>
<a name="ln1230">        (parent_id), \</a>
<a name="ln1231">        parent_class::SetUpTestCase, \</a>
<a name="ln1232">        parent_class::TearDownTestCase, \</a>
<a name="ln1233">        new ::testing::internal::TestFactoryImpl&lt;\</a>
<a name="ln1234">            GTEST_TEST_CLASS_NAME_(test_case_name, test_name)&gt;);\</a>
<a name="ln1235">void GTEST_TEST_CLASS_NAME_(test_case_name, test_name)::TestBody()</a>
<a name="ln1236"> </a>
<a name="ln1237">#endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_</a>
<a name="ln1238"> </a>

</code></pre>
<div class="balloon" rel="1052"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: size_.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
