
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>sys_catalog.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Licensed to the Apache Software Foundation (ASF) under one</a>
<a name="ln2">// or more contributor license agreements.  See the NOTICE file</a>
<a name="ln3">// distributed with this work for additional information</a>
<a name="ln4">// regarding copyright ownership.  The ASF licenses this file</a>
<a name="ln5">// to you under the Apache License, Version 2.0 (the</a>
<a name="ln6">// &quot;License&quot;); you may not use this file except in compliance</a>
<a name="ln7">// with the License.  You may obtain a copy of the License at</a>
<a name="ln8">//</a>
<a name="ln9">//   http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln10">//</a>
<a name="ln11">// Unless required by applicable law or agreed to in writing,</a>
<a name="ln12">// software distributed under the License is distributed on an</a>
<a name="ln13">// &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</a>
<a name="ln14">// KIND, either express or implied.  See the License for the</a>
<a name="ln15">// specific language governing permissions and limitations</a>
<a name="ln16">// under the License.</a>
<a name="ln17">//</a>
<a name="ln18">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln19">//</a>
<a name="ln20">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln21">//</a>
<a name="ln22">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln23">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln24">//</a>
<a name="ln25">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln26">//</a>
<a name="ln27">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln28">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln29">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln30">// under the License.</a>
<a name="ln31">//</a>
<a name="ln32"> </a>
<a name="ln33">#include &quot;yb/master/sys_catalog.h&quot;</a>
<a name="ln34"> </a>
<a name="ln35">#include &lt;cmath&gt;</a>
<a name="ln36">#include &lt;memory&gt;</a>
<a name="ln37"> </a>
<a name="ln38">#include &lt;gflags/gflags.h&gt;</a>
<a name="ln39">#include &lt;glog/logging.h&gt;</a>
<a name="ln40">#include &lt;boost/optional.hpp&gt;</a>
<a name="ln41"> </a>
<a name="ln42">#include &quot;yb/common/partial_row.h&quot;</a>
<a name="ln43">#include &quot;yb/common/partition.h&quot;</a>
<a name="ln44">#include &quot;yb/common/schema.h&quot;</a>
<a name="ln45">#include &quot;yb/common/wire_protocol.h&quot;</a>
<a name="ln46">#include &quot;yb/common/ql_value.h&quot;</a>
<a name="ln47">#include &quot;yb/common/ql_protocol_util.h&quot;</a>
<a name="ln48"> </a>
<a name="ln49">#include &quot;yb/consensus/log_anchor_registry.h&quot;</a>
<a name="ln50">#include &quot;yb/consensus/consensus.h&quot;</a>
<a name="ln51">#include &quot;yb/consensus/consensus_meta.h&quot;</a>
<a name="ln52">#include &quot;yb/consensus/consensus_peers.h&quot;</a>
<a name="ln53">#include &quot;yb/consensus/opid_util.h&quot;</a>
<a name="ln54">#include &quot;yb/consensus/quorum_util.h&quot;</a>
<a name="ln55"> </a>
<a name="ln56">#include &quot;yb/docdb/doc_rowwise_iterator.h&quot;</a>
<a name="ln57"> </a>
<a name="ln58">#include &quot;yb/fs/fs_manager.h&quot;</a>
<a name="ln59">#include &quot;yb/gutil/strings/numbers.h&quot;</a>
<a name="ln60">#include &quot;yb/master/catalog_manager.h&quot;</a>
<a name="ln61">#include &quot;yb/master/master.h&quot;</a>
<a name="ln62">#include &quot;yb/master/master.pb.h&quot;</a>
<a name="ln63">#include &quot;yb/master/sys_catalog_writer.h&quot;</a>
<a name="ln64">#include &quot;yb/rpc/rpc_context.h&quot;</a>
<a name="ln65">#include &quot;yb/tablet/tablet_bootstrap_if.h&quot;</a>
<a name="ln66">#include &quot;yb/tablet/tablet.h&quot;</a>
<a name="ln67">#include &quot;yb/tablet/tablet_fwd.h&quot;</a>
<a name="ln68">#include &quot;yb/tablet/tablet_options.h&quot;</a>
<a name="ln69">#include &quot;yb/tablet/operations/write_operation.h&quot;</a>
<a name="ln70"> </a>
<a name="ln71">#include &quot;yb/tserver/ts_tablet_manager.h&quot;</a>
<a name="ln72"> </a>
<a name="ln73">#include &quot;yb/util/flag_tags.h&quot;</a>
<a name="ln74">#include &quot;yb/util/logging.h&quot;</a>
<a name="ln75">#include &quot;yb/util/net/dns_resolver.h&quot;</a>
<a name="ln76">#include &quot;yb/util/random_util.h&quot;</a>
<a name="ln77">#include &quot;yb/util/size_literals.h&quot;</a>
<a name="ln78">#include &quot;yb/util/threadpool.h&quot;</a>
<a name="ln79"> </a>
<a name="ln80">using namespace std::literals; // NOLINT</a>
<a name="ln81">using namespace yb::size_literals;</a>
<a name="ln82"> </a>
<a name="ln83">using std::shared_ptr;</a>
<a name="ln84">using std::unique_ptr;</a>
<a name="ln85"> </a>
<a name="ln86">using yb::consensus::CONSENSUS_CONFIG_ACTIVE;</a>
<a name="ln87">using yb::consensus::CONSENSUS_CONFIG_COMMITTED;</a>
<a name="ln88">using yb::consensus::ConsensusMetadata;</a>
<a name="ln89">using yb::consensus::RaftConfigPB;</a>
<a name="ln90">using yb::consensus::RaftPeerPB;</a>
<a name="ln91">using yb::log::Log;</a>
<a name="ln92">using yb::log::LogAnchorRegistry;</a>
<a name="ln93">using yb::tserver::WriteRequestPB;</a>
<a name="ln94">using yb::tserver::WriteResponsePB;</a>
<a name="ln95">using strings::Substitute;</a>
<a name="ln96">using yb::consensus::StateChangeContext;</a>
<a name="ln97">using yb::consensus::StateChangeReason;</a>
<a name="ln98">using yb::consensus::ChangeConfigRequestPB;</a>
<a name="ln99">using yb::consensus::ChangeConfigRecordPB;</a>
<a name="ln100"> </a>
<a name="ln101">DEFINE_bool(notify_peer_of_removal_from_cluster, true,</a>
<a name="ln102">            &quot;Notify a peer after it has been removed from the cluster.&quot;);</a>
<a name="ln103">TAG_FLAG(notify_peer_of_removal_from_cluster, hidden);</a>
<a name="ln104">TAG_FLAG(notify_peer_of_removal_from_cluster, advanced);</a>
<a name="ln105"> </a>
<a name="ln106">METRIC_DEFINE_histogram(</a>
<a name="ln107">  server, dns_resolve_latency_during_sys_catalog_setup,</a>
<a name="ln108">  &quot;yb.master.SysCatalogTable.SetupConfig DNS Resolve&quot;,</a>
<a name="ln109">  yb::MetricUnit::kMicroseconds,</a>
<a name="ln110">  &quot;Microseconds spent resolving DNS requests during SysCatalogTable::SetupConfig&quot;,</a>
<a name="ln111">  60000000LU, 2);</a>
<a name="ln112">METRIC_DEFINE_counter(</a>
<a name="ln113">  server, sys_catalog_peer_write_count,</a>
<a name="ln114">  &quot;yb.master.SysCatalogTable Count of Writes&quot;,</a>
<a name="ln115">  yb::MetricUnit::kRequests,</a>
<a name="ln116">  &quot;Number of writes to disk handled by the system catalog.&quot;);</a>
<a name="ln117"> </a>
<a name="ln118">DECLARE_int32(master_discovery_timeout_ms);</a>
<a name="ln119"> </a>
<a name="ln120">DEFINE_int32(sys_catalog_write_timeout_ms, 60000, &quot;Timeout for writes into system catalog&quot;);</a>
<a name="ln121">DEFINE_int32(copy_tables_batch_bytes, 500_KB, &quot;Max bytes per batch for copy pg sql tables&quot;);</a>
<a name="ln122"> </a>
<a name="ln123">DEFINE_test_flag(int32, sys_catalog_write_rejection_percentage, 0,</a>
<a name="ln124">  &quot;Reject specified percentage of sys catalog writes.&quot;);</a>
<a name="ln125"> </a>
<a name="ln126">namespace yb {</a>
<a name="ln127">namespace master {</a>
<a name="ln128"> </a>
<a name="ln129">std::string SysCatalogTable::schema_column_type() { return kSysCatalogTableColType; }</a>
<a name="ln130"> </a>
<a name="ln131">std::string SysCatalogTable::schema_column_id() { return kSysCatalogTableColId; }</a>
<a name="ln132"> </a>
<a name="ln133">std::string SysCatalogTable::schema_column_metadata() { return kSysCatalogTableColMetadata; }</a>
<a name="ln134"> </a>
<a name="ln135">SysCatalogTable::SysCatalogTable(Master* master, MetricRegistry* metrics,</a>
<a name="ln136">                                 ElectedLeaderCallback leader_cb)</a>
<a name="ln137">    : schema_(BuildTableSchema()),</a>
<a name="ln138">      metric_registry_(metrics),</a>
<a name="ln139">      metric_entity_(METRIC_ENTITY_server.Instantiate(metric_registry_, &quot;yb.master&quot;)),</a>
<a name="ln140">      master_(master),</a>
<a name="ln141">      leader_cb_(std::move(leader_cb)) {</a>
<a name="ln142">  CHECK_OK(ThreadPoolBuilder(&quot;inform_removed_master&quot;).Build(&amp;inform_removed_master_pool_));</a>
<a name="ln143">  CHECK_OK(ThreadPoolBuilder(&quot;raft&quot;).Build(&amp;raft_pool_));</a>
<a name="ln144">  CHECK_OK(ThreadPoolBuilder(&quot;prepare&quot;).set_min_threads(1).Build(&amp;tablet_prepare_pool_));</a>
<a name="ln145">  CHECK_OK(ThreadPoolBuilder(&quot;append&quot;).set_min_threads(1).Build(&amp;append_pool_));</a>
<a name="ln146">  CHECK_OK(ThreadPoolBuilder(&quot;log-alloc&quot;).set_min_threads(1).Build(&amp;allocation_pool_));</a>
<a name="ln147"> </a>
<a name="ln148">  setup_config_dns_histogram_ = METRIC_dns_resolve_latency_during_sys_catalog_setup.Instantiate(</a>
<a name="ln149">      metric_entity_);</a>
<a name="ln150">  peer_write_count = METRIC_sys_catalog_peer_write_count.Instantiate(metric_entity_);</a>
<a name="ln151">}</a>
<a name="ln152"> </a>
<a name="ln153">SysCatalogTable::~SysCatalogTable() {</a>
<a name="ln154">}</a>
<a name="ln155"> </a>
<a name="ln156">void SysCatalogTable::Shutdown() {</a>
<a name="ln157">  if (tablet_peer()) {</a>
<a name="ln158">    std::atomic_load(&amp;tablet_peer_)-&gt;Shutdown();</a>
<a name="ln159">  }</a>
<a name="ln160">  inform_removed_master_pool_-&gt;Shutdown();</a>
<a name="ln161">  raft_pool_-&gt;Shutdown();</a>
<a name="ln162">  tablet_prepare_pool_-&gt;Shutdown();</a>
<a name="ln163">}</a>
<a name="ln164"> </a>
<a name="ln165">Status SysCatalogTable::ConvertConfigToMasterAddresses(</a>
<a name="ln166">    const RaftConfigPB&amp; config,</a>
<a name="ln167">    bool check_missing_uuids) {</a>
<a name="ln168">  auto loaded_master_addresses = std::make_shared&lt;server::MasterAddresses&gt;();</a>
<a name="ln169">  bool has_missing_uuids = false;</a>
<a name="ln170">  for (const auto&amp; peer : config.peers()) {</a>
<a name="ln171">    if (check_missing_uuids &amp;&amp; !peer.has_permanent_uuid()) {</a>
<a name="ln172">      LOG(WARNING) &lt;&lt; &quot;No uuid for master peer: &quot; &lt;&lt; peer.ShortDebugString();</a>
<a name="ln173">      has_missing_uuids = true;</a>
<a name="ln174">      break;</a>
<a name="ln175">    }</a>
<a name="ln176"> </a>
<a name="ln177">    loaded_master_addresses-&gt;push_back({});</a>
<a name="ln178">    auto&amp; list = loaded_master_addresses-&gt;back();</a>
<a name="ln179">    for (const auto&amp; hp : peer.last_known_private_addr()) {</a>
<a name="ln180">      list.push_back(HostPortFromPB(hp));</a>
<a name="ln181">    }</a>
<a name="ln182">    for (const auto&amp; hp : peer.last_known_broadcast_addr()) {</a>
<a name="ln183">      list.push_back(HostPortFromPB(hp));</a>
<a name="ln184">    }</a>
<a name="ln185">  }</a>
<a name="ln186"> </a>
<a name="ln187">  if (has_missing_uuids) {</a>
<a name="ln188">    return STATUS(IllegalState, &quot;Trying to load distributed config, but had missing uuids.&quot;);</a>
<a name="ln189">  }</a>
<a name="ln190"> </a>
<a name="ln191">  master_-&gt;SetMasterAddresses(loaded_master_addresses);</a>
<a name="ln192"> </a>
<a name="ln193">  return Status::OK();</a>
<a name="ln194">}</a>
<a name="ln195"> </a>
<a name="ln196">Status SysCatalogTable::CreateAndFlushConsensusMeta(</a>
<a name="ln197">    FsManager* fs_manager,</a>
<a name="ln198">    const RaftConfigPB&amp; config,</a>
<a name="ln199">    int64_t current_term) {</a>
<a name="ln200">  std::unique_ptr&lt;ConsensusMetadata&gt; cmeta;</a>
<a name="ln201">  string tablet_id = kSysCatalogTabletId;</a>
<a name="ln202">  RETURN_NOT_OK_PREPEND(ConsensusMetadata::Create(fs_manager,</a>
<a name="ln203">                                                  tablet_id,</a>
<a name="ln204">                                                  fs_manager-&gt;uuid(),</a>
<a name="ln205">                                                  config,</a>
<a name="ln206">                                                  current_term,</a>
<a name="ln207">                                                  &amp;cmeta),</a>
<a name="ln208">                        &quot;Unable to persist consensus metadata for tablet &quot; + tablet_id);</a>
<a name="ln209">  return Status::OK();</a>
<a name="ln210">}</a>
<a name="ln211"> </a>
<a name="ln212">Status SysCatalogTable::Load(FsManager* fs_manager) {</a>
<a name="ln213">  LOG(INFO) &lt;&lt; &quot;Trying to load previous SysCatalogTable data from disk&quot;;</a>
<a name="ln214">  // Load Metadata Information from disk</a>
<a name="ln215">  scoped_refptr&lt;tablet::RaftGroupMetadata&gt; metadata;</a>
<a name="ln216">  RETURN_NOT_OK(tablet::RaftGroupMetadata::Load(fs_manager, kSysCatalogTabletId, &amp;metadata));</a>
<a name="ln217"> </a>
<a name="ln218">  // Verify that the schema is the current one</a>
<a name="ln219">  if (!metadata-&gt;schema()-&gt;Equals(schema_)) {</a>
<a name="ln220">    // TODO: In this case we probably should execute the migration step.</a>
<a name="ln221">    return(STATUS(Corruption, &quot;Unexpected schema&quot;, metadata-&gt;schema()-&gt;ToString()));</a>
<a name="ln222">  }</a>
<a name="ln223"> </a>
<a name="ln224">  // Update partition schema of old SysCatalogTable. SysCatalogTable should be non-partitioned.</a>
<a name="ln225">  if (metadata-&gt;partition_schema()-&gt;IsHashPartitioning()) {</a>
<a name="ln226">    LOG(INFO) &lt;&lt; &quot;Updating partition schema of SysCatalogTable ...&quot;;</a>
<a name="ln227">    PartitionSchema partition_schema;</a>
<a name="ln228">    RETURN_NOT_OK(PartitionSchema::FromPB(PartitionSchemaPB(), *metadata-&gt;schema(),</a>
<a name="ln229">                                          &amp;partition_schema));</a>
<a name="ln230">    metadata-&gt;SetPartitionSchema(partition_schema);</a>
<a name="ln231">    RETURN_NOT_OK(metadata-&gt;Flush());</a>
<a name="ln232">  }</a>
<a name="ln233"> </a>
<a name="ln234">  // TODO(bogdan) we should revisit this as well as next step to understand what happens if you</a>
<a name="ln235">  // started on this local config, but the consensus layer has a different config? (essentially,</a>
<a name="ln236">  // if your local cmeta is stale...</a>
<a name="ln237">  //</a>
<a name="ln238">  // Allow for statically and explicitly assigning the consensus configuration and roles through</a>
<a name="ln239">  // the master configuration on startup.</a>
<a name="ln240">  //</a>
<a name="ln241">  // TODO: The following assumptions need revisiting:</a>
<a name="ln242">  // 1. We always believe the local config options for who is in the consensus configuration.</a>
<a name="ln243">  // 2. We always want to look up all node's UUIDs on start (via RPC).</a>
<a name="ln244">  //    - TODO: Cache UUIDs. See KUDU-526.</a>
<a name="ln245">  string tablet_id = metadata-&gt;raft_group_id();</a>
<a name="ln246">  std::unique_ptr&lt;ConsensusMetadata&gt; cmeta;</a>
<a name="ln247">  RETURN_NOT_OK_PREPEND(ConsensusMetadata::Load(fs_manager, tablet_id, fs_manager-&gt;uuid(), &amp;cmeta),</a>
<a name="ln248">                        &quot;Unable to load consensus metadata for tablet &quot; + tablet_id);</a>
<a name="ln249"> </a>
<a name="ln250">  const RaftConfigPB&amp; loaded_config = cmeta-&gt;active_config();</a>
<a name="ln251">  DCHECK(!loaded_config.peers().empty()) &lt;&lt; &quot;Loaded consensus metadata, but had no peers!&quot;;</a>
<a name="ln252"> </a>
<a name="ln253">  if (loaded_config.peers().empty()) {</a>
<a name="ln254">    return STATUS(IllegalState, &quot;Trying to load distributed config, but contains no peers.&quot;);</a>
<a name="ln255">  }</a>
<a name="ln256"> </a>
<a name="ln257">  if (loaded_config.peers().size() &gt; 1) {</a>
<a name="ln258">    LOG(INFO) &lt;&lt; &quot;Configuring consensus for distributed operation...&quot;;</a>
<a name="ln259">    RETURN_NOT_OK(ConvertConfigToMasterAddresses(loaded_config, true));</a>
<a name="ln260">  } else {</a>
<a name="ln261">    LOG(INFO) &lt;&lt; &quot;Configuring consensus for local operation...&quot;;</a>
<a name="ln262">    // We know we have exactly one peer.</a>
<a name="ln263">    const auto&amp; peer = loaded_config.peers().Get(0);</a>
<a name="ln264">    if (!peer.has_permanent_uuid()) {</a>
<a name="ln265">      return STATUS(IllegalState, &quot;Loaded consesnsus metadata, but peer did not have a uuid&quot;);</a>
<a name="ln266">    }</a>
<a name="ln267">    if (peer.permanent_uuid() != fs_manager-&gt;uuid()) {</a>
<a name="ln268">      return STATUS(IllegalState, Substitute(</a>
<a name="ln269">          &quot;Loaded consensus metadata, but peer uuid ($0) was different than our uuid ($1)&quot;,</a>
<a name="ln270">          peer.permanent_uuid(), fs_manager-&gt;uuid()));</a>
<a name="ln271">    }</a>
<a name="ln272">  }</a>
<a name="ln273"> </a>
<a name="ln274">  RETURN_NOT_OK(SetupTablet(metadata));</a>
<a name="ln275">  return Status::OK();</a>
<a name="ln276">}</a>
<a name="ln277"> </a>
<a name="ln278">Status SysCatalogTable::CreateNew(FsManager *fs_manager) {</a>
<a name="ln279">  LOG(INFO) &lt;&lt; &quot;Creating new SysCatalogTable data&quot;;</a>
<a name="ln280">  // Create the new Metadata</a>
<a name="ln281">  scoped_refptr&lt;tablet::RaftGroupMetadata&gt; metadata;</a>
<a name="ln282">  Schema schema = BuildTableSchema();</a>
<a name="ln283">  PartitionSchema partition_schema;</a>
<a name="ln284">  RETURN_NOT_OK(PartitionSchema::FromPB(PartitionSchemaPB(), schema, &amp;partition_schema));</a>
<a name="ln285"> </a>
<a name="ln286">  vector&lt;YBPartialRow&gt; split_rows;</a>
<a name="ln287">  vector&lt;Partition&gt; partitions;</a>
<a name="ln288">  RETURN_NOT_OK(partition_schema.CreatePartitions(split_rows, schema, &amp;partitions));</a>
<a name="ln289">  DCHECK_EQ(1, partitions.size());</a>
<a name="ln290"> </a>
<a name="ln291">  RETURN_NOT_OK(tablet::RaftGroupMetadata::CreateNew(</a>
<a name="ln292">      fs_manager,</a>
<a name="ln293">      kSysCatalogTableId,</a>
<a name="ln294">      kSysCatalogTabletId,</a>
<a name="ln295">      &quot;&quot;,</a>
<a name="ln296">      table_name(),</a>
<a name="ln297">      TableType::YQL_TABLE_TYPE,</a>
<a name="ln298">      schema,</a>
<a name="ln299">      IndexMap(),</a>
<a name="ln300">      partition_schema,</a>
<a name="ln301">      partitions[0],</a>
<a name="ln302">      boost::none /* index_info */,</a>
<a name="ln303">      0 /* schema_version */,</a>
<a name="ln304">      tablet::TABLET_DATA_READY,</a>
<a name="ln305">      &amp;metadata));</a>
<a name="ln306"> </a>
<a name="ln307">  RaftConfigPB config;</a>
<a name="ln308">  RETURN_NOT_OK_PREPEND(SetupConfig(master_-&gt;opts(), &amp;config),</a>
<a name="ln309">                        &quot;Failed to initialize distributed config&quot;);</a>
<a name="ln310"> </a>
<a name="ln311">  RETURN_NOT_OK(CreateAndFlushConsensusMeta(fs_manager, config, consensus::kMinimumTerm));</a>
<a name="ln312"> </a>
<a name="ln313">  return SetupTablet(metadata);</a>
<a name="ln314">}</a>
<a name="ln315"> </a>
<a name="ln316">Status SysCatalogTable::SetupConfig(const MasterOptions&amp; options,</a>
<a name="ln317">                                    RaftConfigPB* committed_config) {</a>
<a name="ln318">  // Build the set of followers from our server options.</a>
<a name="ln319">  auto master_addresses = options.GetMasterAddresses();  // ENG-285</a>
<a name="ln320"> </a>
<a name="ln321">  // Now resolve UUIDs.</a>
<a name="ln322">  // By the time a SysCatalogTable is created and initted, the masters should be</a>
<a name="ln323">  // starting up, so this should be fine to do.</a>
<a name="ln324">  DCHECK(master_-&gt;messenger());</a>
<a name="ln325">  RaftConfigPB resolved_config;</a>
<a name="ln326">  resolved_config.set_opid_index(consensus::kInvalidOpIdIndex);</a>
<a name="ln327"> </a>
<a name="ln328">  ScopedDnsTracker dns_tracker(setup_config_dns_histogram_);</a>
<a name="ln329">  for (const auto&amp; list : *options.GetMasterAddresses()) {</a>
<a name="ln330">    LOG(INFO) &lt;&lt; &quot;Determining permanent_uuid for &quot; + yb::ToString(list);</a>
<a name="ln331">    RaftPeerPB new_peer;</a>
<a name="ln332">    // TODO: Use ConsensusMetadata to cache the results of these lookups so</a>
<a name="ln333">    // we only require RPC access to the full consensus configuration on first startup.</a>
<a name="ln334">    // See KUDU-526.</a>
<a name="ln335">    RETURN_NOT_OK_PREPEND(</a>
<a name="ln336">      consensus::SetPermanentUuidForRemotePeer(</a>
<a name="ln337">        &amp;master_-&gt;proxy_cache(),</a>
<a name="ln338">        std::chrono::milliseconds(FLAGS_master_discovery_timeout_ms),</a>
<a name="ln339">        list,</a>
<a name="ln340">        &amp;new_peer),</a>
<a name="ln341">      Format(&quot;Unable to resolve UUID for $0&quot;, yb::ToString(list)));</a>
<a name="ln342">    resolved_config.add_peers()-&gt;Swap(&amp;new_peer);</a>
<a name="ln343">  }</a>
<a name="ln344"> </a>
<a name="ln345">  LOG(INFO) &lt;&lt; &quot;Setting up raft configuration: &quot; &lt;&lt; resolved_config.ShortDebugString();</a>
<a name="ln346"> </a>
<a name="ln347">  RETURN_NOT_OK(consensus::VerifyRaftConfig(resolved_config, consensus::COMMITTED_QUORUM));</a>
<a name="ln348"> </a>
<a name="ln349">  *committed_config = resolved_config;</a>
<a name="ln350">  return Status::OK();</a>
<a name="ln351">}</a>
<a name="ln352"> </a>
<a name="ln353">void SysCatalogTable::SysCatalogStateChanged(</a>
<a name="ln354">    const string&amp; tablet_id,</a>
<a name="ln355">    std::shared_ptr&lt;StateChangeContext&gt; context) {</a>
<a name="ln356">  CHECK_EQ(tablet_id, tablet_peer()-&gt;tablet_id());</a>
<a name="ln357">  shared_ptr&lt;consensus::Consensus&gt; consensus = tablet_peer()-&gt;shared_consensus();</a>
<a name="ln358">  if (!consensus) {</a>
<a name="ln359">    LOG_WITH_PREFIX(WARNING) &lt;&lt; &quot;Received notification of tablet state change &quot;</a>
<a name="ln360">                             &lt;&lt; &quot;but tablet no longer running. Tablet ID: &quot;</a>
<a name="ln361">                             &lt;&lt; tablet_id &lt;&lt; &quot;. Reason: &quot; &lt;&lt; context-&gt;ToString();</a>
<a name="ln362">    return;</a>
<a name="ln363">  }</a>
<a name="ln364"> </a>
<a name="ln365">  // We use the active config, in case there is a pending one with this peer becoming the voter,</a>
<a name="ln366">  // that allows its role to be determined correctly as the LEADER and so loads the sys catalog.</a>
<a name="ln367">  // Done as part of ENG-286.</a>
<a name="ln368">  consensus::ConsensusStatePB cstate = context-&gt;is_config_locked() ?</a>
<a name="ln369">      consensus-&gt;ConsensusStateUnlocked(CONSENSUS_CONFIG_ACTIVE) :</a>
<a name="ln370">      consensus-&gt;ConsensusState(CONSENSUS_CONFIG_ACTIVE);</a>
<a name="ln371">  LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;SysCatalogTable state changed. Locked=&quot; &lt;&lt; context-&gt;is_config_locked_</a>
<a name="ln372">                        &lt;&lt; &quot;. Reason: &quot; &lt;&lt; context-&gt;ToString()</a>
<a name="ln373">                        &lt;&lt; &quot;. Latest consensus state: &quot; &lt;&lt; cstate.ShortDebugString();</a>
<a name="ln374">  RaftPeerPB::Role role = GetConsensusRole(tablet_peer()-&gt;permanent_uuid(), cstate);</a>
<a name="ln375">  LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;This master's current role is: &quot;</a>
<a name="ln376">                        &lt;&lt; RaftPeerPB::Role_Name(role);</a>
<a name="ln377"> </a>
<a name="ln378">  // For LEADER election case only, load the sysCatalog into memory via the callback.</a>
<a name="ln379">  // Note that for a *single* master case, the TABLET_PEER_START is being overloaded to imply a</a>
<a name="ln380">  // leader creation step, as there is no election done per-se.</a>
<a name="ln381">  // For the change config case, LEADER is the one which started the operation, so new role is same</a>
<a name="ln382">  // as its old role of LEADER and hence it need not reload the sysCatalog via the callback.</a>
<a name="ln383">  if (role == RaftPeerPB::LEADER &amp;&amp;</a>
<a name="ln384">      (context-&gt;reason == StateChangeReason::NEW_LEADER_ELECTED ||</a>
<a name="ln385">       (cstate.config().peers_size() == 1 &amp;&amp;</a>
<a name="ln386">        context-&gt;reason == StateChangeReason::TABLET_PEER_STARTED))) {</a>
<a name="ln387">    CHECK_OK(leader_cb_.Run());</a>
<a name="ln388">  }</a>
<a name="ln389"> </a>
<a name="ln390">  // Perform any further changes for context based reasons.</a>
<a name="ln391">  // For config change peer update, both leader and follower need to update their in-memory state.</a>
<a name="ln392">  // NOTE: if there are any errors, we check in debug mode, but ignore the error in non-debug case.</a>
<a name="ln393">  if (context-&gt;reason == StateChangeReason::LEADER_CONFIG_CHANGE_COMPLETE ||</a>
<a name="ln394">      context-&gt;reason == StateChangeReason::FOLLOWER_CONFIG_CHANGE_COMPLETE) {</a>
<a name="ln395">    int new_count = context-&gt;change_record.new_config().peers_size();</a>
<a name="ln396">    int old_count = context-&gt;change_record.old_config().peers_size();</a>
<a name="ln397"> </a>
<a name="ln398">    LOG(INFO) &lt;&lt; &quot;Processing context '&quot; &lt;&lt; context-&gt;ToString()</a>
<a name="ln399">              &lt;&lt; &quot;' - new count &quot; &lt;&lt; new_count &lt;&lt; &quot;, old count &quot; &lt;&lt; old_count;</a>
<a name="ln400"> </a>
<a name="ln401">    // If new_config and old_config have the same number of peers, then the change config must have</a>
<a name="ln402">    // been a ROLE_CHANGE, thus old_config must have exactly one peer in transition (PRE_VOTER or</a>
<a name="ln403">    // PRE_OBSERVER) and new_config should have none.</a>
<a name="ln404">    if (new_count == old_count) {</a>
<a name="ln405">      int old_config_peers_transition_count =</a>
<a name="ln406">          CountServersInTransition(context-&gt;change_record.old_config());</a>
<a name="ln407">      if ( old_config_peers_transition_count != 1) {</a>
<a name="ln408">        LOG(FATAL) &lt;&lt; &quot;Expected old config to have one server in transition (PRE_VOTER or &quot;</a>
<a name="ln409">                   &lt;&lt; &quot;PRE_OBSERVER), but found &quot; &lt;&lt; old_config_peers_transition_count</a>
<a name="ln410">                   &lt;&lt; &quot;. Config: &quot; &lt;&lt; context-&gt;change_record.old_config().ShortDebugString();</a>
<a name="ln411">      }</a>
<a name="ln412">      int new_config_peers_transition_count =</a>
<a name="ln413">          CountServersInTransition(context-&gt;change_record.new_config());</a>
<a name="ln414">      if (new_config_peers_transition_count != 0) {</a>
<a name="ln415">        LOG(FATAL) &lt;&lt; &quot;Expected new config to have no servers in transition (PRE_VOTER or &quot;</a>
<a name="ln416">                   &lt;&lt; &quot;PRE_OBSERVER), but found &quot; &lt;&lt; new_config_peers_transition_count</a>
<a name="ln417">                   &lt;&lt; &quot;. Config: &quot; &lt;&lt; context-&gt;change_record.old_config().ShortDebugString();</a>
<a name="ln418">      }</a>
<a name="ln419">    } else if (std::abs(new_count - old_count) != 1) {</a>
<a name="ln420"> </a>
<a name="ln421">      LOG(FATAL) &lt;&lt; &quot;Expected exactly one server addition or deletion, found &quot; &lt;&lt; new_count</a>
<a name="ln422">                 &lt;&lt; &quot; servers in new config and &quot; &lt;&lt; old_count &lt;&lt; &quot; servers in old config.&quot;;</a>
<a name="ln423">      return;</a>
<a name="ln424">    }</a>
<a name="ln425"> </a>
<a name="ln426">    Status s = master_-&gt;ResetMemoryState(context-&gt;change_record.new_config());</a>
<a name="ln427">    if (!s.ok()) {</a>
<a name="ln428">      LOG(WARNING) &lt;&lt; &quot;Change Memory state failed &quot; &lt;&lt; s.ToString();</a>
<a name="ln429">      DCHECK(false);</a>
<a name="ln430">      return;</a>
<a name="ln431">    }</a>
<a name="ln432"> </a>
<a name="ln433">    // Try to make the removed master, go back to shell mode so as not to ping this cluster.</a>
<a name="ln434">    // This is best effort and should not perform any fatals or checks.</a>
<a name="ln435">    if (FLAGS_notify_peer_of_removal_from_cluster &amp;&amp;</a>
<a name="ln436">        context-&gt;reason == StateChangeReason::LEADER_CONFIG_CHANGE_COMPLETE &amp;&amp;</a>
<a name="ln437">        context-&gt;remove_uuid != &quot;&quot;) {</a>
<a name="ln438">      RaftPeerPB peer;</a>
<a name="ln439">      LOG(INFO) &lt;&lt; &quot;Asking &quot; &lt;&lt; context-&gt;remove_uuid &lt;&lt; &quot; to go into shell mode&quot;;</a>
<a name="ln440">      WARN_NOT_OK(GetRaftConfigMember(context-&gt;change_record.old_config(),</a>
<a name="ln441">                                      context-&gt;remove_uuid,</a>
<a name="ln442">                                      &amp;peer),</a>
<a name="ln443">                  Substitute(&quot;Could not find uuid=$0 in config.&quot;, context-&gt;remove_uuid));</a>
<a name="ln444">      WARN_NOT_OK(</a>
<a name="ln445">          inform_removed_master_pool_-&gt;SubmitFunc(</a>
<a name="ln446">              [this, host_port = DesiredHostPort(peer, master_-&gt;MakeCloudInfoPB())]() {</a>
<a name="ln447">            WARN_NOT_OK(master_-&gt;InformRemovedMaster(host_port),</a>
<a name="ln448">                        &quot;Failed to inform removed master &quot; + host_port.ShortDebugString());</a>
<a name="ln449">          }),</a>
<a name="ln450">          Substitute(&quot;Error submitting removal task for uuid=$0&quot;, context-&gt;remove_uuid));</a>
<a name="ln451">    }</a>
<a name="ln452">  } else {</a>
<a name="ln453">    VLOG(2) &lt;&lt; &quot;Reason '&quot; &lt;&lt; context-&gt;ToString() &lt;&lt; &quot;' provided in state change context, &quot;</a>
<a name="ln454">            &lt;&lt; &quot;no action needed.&quot;;</a>
<a name="ln455">  }</a>
<a name="ln456">}</a>
<a name="ln457"> </a>
<a name="ln458">Status SysCatalogTable::GoIntoShellMode() {</a>
<a name="ln459">  CHECK(tablet_peer());</a>
<a name="ln460">  Shutdown();</a>
<a name="ln461"> </a>
<a name="ln462">  // Remove on-disk log, cmeta and tablet superblocks.</a>
<a name="ln463">  RETURN_NOT_OK(tserver::DeleteTabletData(tablet_peer()-&gt;tablet_metadata(),</a>
<a name="ln464">                                          tablet::TABLET_DATA_DELETED,</a>
<a name="ln465">                                          master_-&gt;fs_manager()-&gt;uuid(),</a>
<a name="ln466">                                          yb::OpId()));</a>
<a name="ln467">  RETURN_NOT_OK(tablet_peer()-&gt;tablet_metadata()-&gt;DeleteSuperBlock());</a>
<a name="ln468">  RETURN_NOT_OK(master_-&gt;fs_manager()-&gt;DeleteFileSystemLayout());</a>
<a name="ln469">  std::shared_ptr&lt;tablet::TabletPeer&gt; null_tablet_peer(nullptr);</a>
<a name="ln470">  std::atomic_store(&amp;tablet_peer_, null_tablet_peer);</a>
<a name="ln471">  inform_removed_master_pool_.reset();</a>
<a name="ln472">  raft_pool_.reset();</a>
<a name="ln473">  tablet_prepare_pool_.reset();</a>
<a name="ln474"> </a>
<a name="ln475">  return Status::OK();</a>
<a name="ln476">}</a>
<a name="ln477"> </a>
<a name="ln478">void SysCatalogTable::SetupTabletPeer(const scoped_refptr&lt;tablet::RaftGroupMetadata&gt;&amp; metadata) {</a>
<a name="ln479">  InitLocalRaftPeerPB();</a>
<a name="ln480"> </a>
<a name="ln481">  // TODO: handle crash mid-creation of tablet? do we ever end up with a</a>
<a name="ln482">  // partially created tablet here?</a>
<a name="ln483">  auto tablet_peer = std::make_shared&lt;tablet::TabletPeer&gt;(</a>
<a name="ln484">      metadata,</a>
<a name="ln485">      local_peer_pb_,</a>
<a name="ln486">      scoped_refptr&lt;server::Clock&gt;(master_-&gt;clock()),</a>
<a name="ln487">      metadata-&gt;fs_manager()-&gt;uuid(),</a>
<a name="ln488">      Bind(&amp;SysCatalogTable::SysCatalogStateChanged, Unretained(this), metadata-&gt;raft_group_id()),</a>
<a name="ln489">      metric_registry_,</a>
<a name="ln490">      nullptr /* tablet_splitter */,</a>
<a name="ln491">      master_-&gt;async_client_initializer().get_client_future());</a>
<a name="ln492"> </a>
<a name="ln493">  std::atomic_store(&amp;tablet_peer_, tablet_peer);</a>
<a name="ln494">}</a>
<a name="ln495"> </a>
<a name="ln496">Status SysCatalogTable::SetupTablet(const scoped_refptr&lt;tablet::RaftGroupMetadata&gt;&amp; metadata) {</a>
<a name="ln497">  SetupTabletPeer(metadata);</a>
<a name="ln498"> </a>
<a name="ln499">  RETURN_NOT_OK(OpenTablet(metadata));</a>
<a name="ln500"> </a>
<a name="ln501">  return Status::OK();</a>
<a name="ln502">}</a>
<a name="ln503"> </a>
<a name="ln504">Status SysCatalogTable::OpenTablet(const scoped_refptr&lt;tablet::RaftGroupMetadata&gt;&amp; metadata) {</a>
<a name="ln505">  CHECK(tablet_peer());</a>
<a name="ln506"> </a>
<a name="ln507">  tablet::TabletPtr tablet;</a>
<a name="ln508">  scoped_refptr&lt;Log&gt; log;</a>
<a name="ln509">  consensus::ConsensusBootstrapInfo consensus_info;</a>
<a name="ln510">  RETURN_NOT_OK(tablet_peer()-&gt;SetBootstrapping());</a>
<a name="ln511">  tablet::TabletOptions tablet_options;</a>
<a name="ln512">  tablet::TabletInitData tablet_init_data = {</a>
<a name="ln513">      .metadata = metadata,</a>
<a name="ln514">      .client_future = master_-&gt;async_client_initializer().get_client_future(),</a>
<a name="ln515">      .clock = scoped_refptr&lt;server::Clock&gt;(master_-&gt;clock()),</a>
<a name="ln516">      .parent_mem_tracker = master_-&gt;mem_tracker(),</a>
<a name="ln517">      .block_based_table_mem_tracker =</a>
<a name="ln518">          MemTracker::FindOrCreateTracker(&quot;BlockBasedTable&quot;, master_-&gt;mem_tracker()),</a>
<a name="ln519">      .metric_registry = metric_registry_,</a>
<a name="ln520">      .log_anchor_registry = tablet_peer()-&gt;log_anchor_registry(),</a>
<a name="ln521">      .tablet_options = tablet_options,</a>
<a name="ln522">      .log_prefix_suffix = &quot; P &quot; + tablet_peer()-&gt;permanent_uuid(),</a>
<a name="ln523">      .transaction_participant_context = tablet_peer().get(),</a>
<a name="ln524">      .local_tablet_filter = client::LocalTabletFilter(),</a>
<a name="ln525">      // This is only required if the sys catalog tablet is also acting as a transaction status</a>
<a name="ln526">      // tablet, which it does not as of 12/06/2019. This could have been a nullptr, but putting</a>
<a name="ln527">      // the TabletPeer here in case we need this for rolling master upgrades when we do enable</a>
<a name="ln528">      // storing transaction status records in the sys catalog tablet.</a>
<a name="ln529">      .transaction_coordinator_context = tablet_peer().get(),</a>
<a name="ln530">      // Disable transactions if we are creating the initial sys catalog snapshot.</a>
<a name="ln531">      // initdb is much faster with transactions disabled.</a>
<a name="ln532">      .txns_enabled = tablet::TransactionsEnabled(!FLAGS_create_initial_sys_catalog_snapshot),</a>
<a name="ln533">      .is_sys_catalog = tablet::IsSysCatalogTablet::kTrue,</a>
<a name="ln534">      .snapshot_coordinator = &amp;master_-&gt;catalog_manager()-&gt;snapshot_coordinator(),</a>
<a name="ln535">      .tablet_splitter = nullptr,</a>
<a name="ln536">  };</a>
<a name="ln537">  tablet::BootstrapTabletData data = {</a>
<a name="ln538">      .tablet_init_data = tablet_init_data,</a>
<a name="ln539">      .listener = tablet_peer()-&gt;status_listener(),</a>
<a name="ln540">      .append_pool = append_pool(),</a>
<a name="ln541">      .allocation_pool = allocation_pool_.get(),</a>
<a name="ln542">      .retryable_requests = nullptr,</a>
<a name="ln543">  };</a>
<a name="ln544">  RETURN_NOT_OK(BootstrapTablet(data, &amp;tablet, &amp;log, &amp;consensus_info));</a>
<a name="ln545"> </a>
<a name="ln546">  // TODO: Do we have a setSplittable(false) or something from the outside is</a>
<a name="ln547">  // handling split in the TS?</a>
<a name="ln548"> </a>
<a name="ln549">  RETURN_NOT_OK_PREPEND(</a>
<a name="ln550">      tablet_peer()-&gt;InitTabletPeer(</a>
<a name="ln551">          tablet,</a>
<a name="ln552">          master_-&gt;mem_tracker(),</a>
<a name="ln553">          master_-&gt;messenger(),</a>
<a name="ln554">          &amp;master_-&gt;proxy_cache(),</a>
<a name="ln555">          log,</a>
<a name="ln556">          tablet-&gt;GetMetricEntity(),</a>
<a name="ln557">          raft_pool(),</a>
<a name="ln558">          tablet_prepare_pool(),</a>
<a name="ln559">          nullptr /* retryable_requests */,</a>
<a name="ln560">          yb::OpId() /* split_op_id */),</a>
<a name="ln561">      &quot;Failed to Init() TabletPeer&quot;);</a>
<a name="ln562"> </a>
<a name="ln563">  RETURN_NOT_OK_PREPEND(tablet_peer()-&gt;Start(consensus_info),</a>
<a name="ln564">                        &quot;Failed to Start() TabletPeer&quot;);</a>
<a name="ln565"> </a>
<a name="ln566">  tablet_peer()-&gt;RegisterMaintenanceOps(master_-&gt;maintenance_manager());</a>
<a name="ln567"> </a>
<a name="ln568">  if (!tablet-&gt;schema()-&gt;Equals(schema_)) {</a>
<a name="ln569">    return STATUS(Corruption, &quot;Unexpected schema&quot;, tablet-&gt;schema()-&gt;ToString());</a>
<a name="ln570">  }</a>
<a name="ln571">  return Status::OK();</a>
<a name="ln572">}</a>
<a name="ln573"> </a>
<a name="ln574">std::string SysCatalogTable::LogPrefix() const {</a>
<a name="ln575">  return Substitute(&quot;T $0 P $1 [$2]: &quot;,</a>
<a name="ln576">                    tablet_peer()-&gt;tablet_id(),</a>
<a name="ln577">                    tablet_peer()-&gt;permanent_uuid(),</a>
<a name="ln578">                    table_name());</a>
<a name="ln579">}</a>
<a name="ln580"> </a>
<a name="ln581">Status SysCatalogTable::WaitUntilRunning() {</a>
<a name="ln582">  TRACE_EVENT0(&quot;master&quot;, &quot;SysCatalogTable::WaitUntilRunning&quot;);</a>
<a name="ln583">  int seconds_waited = 0;</a>
<a name="ln584">  while (true) {</a>
<a name="ln585">    Status status = tablet_peer()-&gt;WaitUntilConsensusRunning(MonoDelta::FromSeconds(1));</a>
<a name="ln586">    seconds_waited++;</a>
<a name="ln587">    if (status.ok()) {</a>
<a name="ln588">      LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;configured and running, proceeding with master startup.&quot;;</a>
<a name="ln589">      break;</a>
<a name="ln590">    }</a>
<a name="ln591">    if (status.IsTimedOut()) {</a>
<a name="ln592">      LOG_WITH_PREFIX(INFO) &lt;&lt;  &quot;not online yet (have been trying for &quot;</a>
<a name="ln593">                               &lt;&lt; seconds_waited &lt;&lt; &quot; seconds)&quot;;</a>
<a name="ln594">      continue;</a>
<a name="ln595">    }</a>
<a name="ln596">    // if the status is not OK or TimedOut return it.</a>
<a name="ln597">    return status;</a>
<a name="ln598">  }</a>
<a name="ln599">  return Status::OK();</a>
<a name="ln600">}</a>
<a name="ln601"> </a>
<a name="ln602">CHECKED_STATUS SysCatalogTable::SyncWrite(SysCatalogWriter* writer) {</a>
<a name="ln603">  if (PREDICT_FALSE(FLAGS_TEST_sys_catalog_write_rejection_percentage &gt; 0) &amp;&amp;</a>
<a name="ln604">      RandomUniformInt(1, 99) &lt;= FLAGS_TEST_sys_catalog_write_rejection_percentage) {</a>
<a name="ln605">    return STATUS(InternalError, &quot;Injected random failure for testing.&quot;);</a>
<a name="ln606">  }</a>
<a name="ln607"> </a>
<a name="ln608">  auto resp = std::make_shared&lt;tserver::WriteResponsePB&gt;();</a>
<a name="ln609">  // If this is a PG write, them the pgsql write batch is not empty.</a>
<a name="ln610">  //</a>
<a name="ln611">  // If this is a QL write, then it is a normal sys_catalog write, so ignore writes that might</a>
<a name="ln612">  // have filtered out all of the writes from the batch, as they were the same payload as the cow</a>
<a name="ln613">  // objects that are backing them.</a>
<a name="ln614">  if (writer-&gt;req().ql_write_batch().empty() &amp;&amp; writer-&gt;req().pgsql_write_batch().empty()) {</a>
<a name="ln615">    return Status::OK();</a>
<a name="ln616">  }</a>
<a name="ln617"> </a>
<a name="ln618">  auto latch = std::make_shared&lt;CountDownLatch&gt;(1);</a>
<a name="ln619">  auto operation_state = std::make_unique&lt;tablet::WriteOperationState&gt;(</a>
<a name="ln620">      tablet_peer()-&gt;tablet(), &amp;writer-&gt;req(), resp.get());</a>
<a name="ln621">  operation_state-&gt;set_completion_callback(</a>
<a name="ln622">      tablet::MakeLatchOperationCompletionCallback(latch, resp));</a>
<a name="ln623"> </a>
<a name="ln624">  tablet_peer()-&gt;WriteAsync(</a>
<a name="ln625">      std::move(operation_state), writer-&gt;leader_term(), CoarseTimePoint::max() /* deadline */);</a>
<a name="ln626">  peer_write_count-&gt;Increment();</a>
<a name="ln627"> </a>
<a name="ln628">  {</a>
<a name="ln629">    int num_iterations = 0;</a>
<a name="ln630">    auto time = CoarseMonoClock::now();</a>
<a name="ln631">    auto deadline = time + FLAGS_sys_catalog_write_timeout_ms * 1ms;</a>
<a name="ln632">    static constexpr auto kWarningInterval = 5s;</a>
<a name="ln633">    while (!latch-&gt;WaitUntil(std::min(deadline, time + kWarningInterval))) {</a>
<a name="ln634">      ++num_iterations;</a>
<a name="ln635">      const auto waited_so_far = num_iterations * kWarningInterval;</a>
<a name="ln636">      LOG(WARNING) &lt;&lt; &quot;Waited for &quot;</a>
<a name="ln637">                   &lt;&lt; waited_so_far &lt;&lt; &quot; for synchronous write to complete. &quot;</a>
<a name="ln638">                   &lt;&lt; &quot;Continuing to wait.&quot;;</a>
<a name="ln639">      time = CoarseMonoClock::now();</a>
<a name="ln640">      if (time &gt;= deadline) {</a>
<a name="ln641">        LOG(ERROR) &lt;&lt; &quot;Already waited for a total of &quot; &lt;&lt; waited_so_far &lt;&lt; &quot;. &quot;</a>
<a name="ln642">                   &lt;&lt; &quot;Returning a timeout from SyncWrite.&quot;;</a>
<a name="ln643">        return STATUS_FORMAT(TimedOut, &quot;SyncWrite timed out after $0&quot;, waited_so_far);</a>
<a name="ln644">      }</a>
<a name="ln645">    }</a>
<a name="ln646">  }</a>
<a name="ln647"> </a>
<a name="ln648">  if (resp-&gt;has_error()) {</a>
<a name="ln649">    return StatusFromPB(resp-&gt;error().status());</a>
<a name="ln650">  }</a>
<a name="ln651">  if (resp-&gt;per_row_errors_size() &gt; 0) {</a>
<a name="ln652">    for (const WriteResponsePB::PerRowErrorPB&amp; error : resp-&gt;per_row_errors()) {</a>
<a name="ln653">      LOG(WARNING) &lt;&lt; &quot;row &quot; &lt;&lt; error.row_index() &lt;&lt; &quot;: &quot; &lt;&lt; StatusFromPB(error.error()).ToString();</a>
<a name="ln654">    }</a>
<a name="ln655">    return STATUS(Corruption, &quot;One or more rows failed to write&quot;);</a>
<a name="ln656">  }</a>
<a name="ln657">  return Status::OK();</a>
<a name="ln658">}</a>
<a name="ln659"> </a>
<a name="ln660">// Schema for the unified SysCatalogTable:</a>
<a name="ln661">//</a>
<a name="ln662">// (entry_type, entry_id) -&gt; metadata</a>
<a name="ln663">//</a>
<a name="ln664">// entry_type is a enum defined in sys_tables. It indicates</a>
<a name="ln665">// whether an entry is a table or a tablet.</a>
<a name="ln666">//</a>
<a name="ln667">// entry_type is the first part of a compound key as to allow</a>
<a name="ln668">// efficient scans of entries of only a single type (e.g., only</a>
<a name="ln669">// scan all of the tables, or only scan all of the tablets).</a>
<a name="ln670">//</a>
<a name="ln671">// entry_id is either a table id or a tablet id. For tablet entries,</a>
<a name="ln672">// the table id that the tablet is associated with is stored in the</a>
<a name="ln673">// protobuf itself.</a>
<a name="ln674">Schema SysCatalogTable::BuildTableSchema() {</a>
<a name="ln675">  SchemaBuilder builder;</a>
<a name="ln676">  CHECK_OK(builder.AddKeyColumn(kSysCatalogTableColType, INT8));</a>
<a name="ln677">  CHECK_OK(builder.AddKeyColumn(kSysCatalogTableColId, BINARY));</a>
<a name="ln678">  CHECK_OK(builder.AddColumn(kSysCatalogTableColMetadata, BINARY));</a>
<a name="ln679">  return builder.Build();</a>
<a name="ln680">}</a>
<a name="ln681"> </a>
<a name="ln682">// ==================================================================</a>
<a name="ln683">// Other methods</a>
<a name="ln684">// ==================================================================</a>
<a name="ln685">void SysCatalogTable::InitLocalRaftPeerPB() {</a>
<a name="ln686">  local_peer_pb_.set_permanent_uuid(master_-&gt;fs_manager()-&gt;uuid());</a>
<a name="ln687">  ServerRegistrationPB reg;</a>
<a name="ln688">  CHECK_OK(master_-&gt;GetRegistration(&amp;reg, server::RpcOnly::kTrue));</a>
<a name="ln689">  TakeRegistration(&amp;reg, &amp;local_peer_pb_);</a>
<a name="ln690">}</a>
<a name="ln691"> </a>
<a name="ln692">Status SysCatalogTable::Visit(VisitorBase* visitor) {</a>
<a name="ln693">  TRACE_EVENT0(&quot;master&quot;, &quot;Visitor::VisitAll&quot;);</a>
<a name="ln694"> </a>
<a name="ln695">  auto tablet = tablet_peer()-&gt;shared_tablet();</a>
<a name="ln696">  if (!tablet) {</a>
<a name="ln697">    return STATUS(ShutdownInProgress, &quot;SysConfig is shutting down.&quot;);</a>
<a name="ln698">  }</a>
<a name="ln699"> </a>
<a name="ln700">  auto start = CoarseMonoClock::Now();</a>
<a name="ln701"> </a>
<a name="ln702">  uint64_t count = 0;</a>
<a name="ln703">  RETURN_NOT_OK(EnumerateSysCatalog(tablet.get(), schema_, visitor-&gt;entry_type(),</a>
<a name="ln704">                                    [visitor, &amp;count](const Slice&amp; id, const Slice&amp; data) {</a>
<a name="ln705">    ++count;</a>
<a name="ln706">    return visitor-&gt;Visit(id, data);</a>
<a name="ln707">  }));</a>
<a name="ln708"> </a>
<a name="ln709">  auto duration = CoarseMonoClock::Now() - start;</a>
<a name="ln710">  string id = Format(&quot;num_entries_with_type_$0_loaded&quot;, std::to_string(visitor-&gt;entry_type()));</a>
<a name="ln711">  if (visitor_duration_metrics_.find(id) == visitor_duration_metrics_.end()) {</a>
<a name="ln712">    string description = id + &quot; metric for SysCatalogTable::Visit&quot;;</a>
<a name="ln713">    std::unique_ptr&lt;GaugePrototype&lt;uint64&gt;&gt; counter_gauge =</a>
<a name="ln714">        std::make_unique&lt;OwningGaugePrototype&lt;uint64&gt;&gt;(</a>
<a name="ln715">            &quot;server&quot;, id, description, yb::MetricUnit::kEntries, description,</a>
<a name="ln716">            yb::MetricLevel::kInfo, yb::EXPOSE_AS_COUNTER);</a>
<a name="ln717">    visitor_duration_metrics_[id] = metric_entity_-&gt;FindOrCreateGauge(</a>
<a name="ln718">        std::move(counter_gauge), static_cast&lt;uint64&gt;(0) /* initial_value */);</a>
<a name="ln719">  }</a>
<a name="ln720">  visitor_duration_metrics_[id]-&gt;IncrementBy(count);</a>
<a name="ln721"> </a>
<a name="ln722">  id = Format(&quot;duration_ms_loading_entries_with_type_$0&quot;, std::to_string(visitor-&gt;entry_type()));</a>
<a name="ln723">  if (visitor_duration_metrics_.find(id) == visitor_duration_metrics_.end()) {</a>
<a name="ln724">    string description = id + &quot; metric for SysCatalogTable::Visit&quot;;</a>
<a name="ln725">    std::unique_ptr&lt;GaugePrototype&lt;uint64&gt;&gt; duration_gauge =</a>
<a name="ln726">        std::make_unique&lt;OwningGaugePrototype&lt;uint64&gt;&gt;(</a>
<a name="ln727">            &quot;server&quot;, id, description, yb::MetricUnit::kMilliseconds, description,</a>
<a name="ln728">            yb::MetricLevel::kInfo);</a>
<a name="ln729">    visitor_duration_metrics_[id] = metric_entity_-&gt;FindOrCreateGauge(</a>
<a name="ln730">        std::move(duration_gauge), static_cast&lt;uint64&gt;(0) /* initial_value */);</a>
<a name="ln731">  }</a>
<a name="ln732">  visitor_duration_metrics_[id]-&gt;IncrementBy(ToMilliseconds(duration));</a>
<a name="ln733">  return Status::OK();</a>
<a name="ln734">}</a>
<a name="ln735"> </a>
<a name="ln736">Status SysCatalogTable::CopyPgsqlTables(</a>
<a name="ln737">    const vector&lt;TableId&gt;&amp; source_table_ids, const vector&lt;TableId&gt;&amp; target_table_ids,</a>
<a name="ln738">    const int64_t leader_term) {</a>
<a name="ln739">  TRACE_EVENT0(&quot;master&quot;, &quot;CopyPgsqlTables&quot;);</a>
<a name="ln740"> </a>
<a name="ln741">  std::unique_ptr&lt;SysCatalogWriter&gt; writer = NewWriter(leader_term);</a>
<a name="ln742"> </a>
<a name="ln743">  DSCHECK_EQ(</a>
<a name="ln744">      source_table_ids.size(), target_table_ids.size(), InvalidArgument,</a>
<a name="ln745">      &quot;size mismatch between source tables and target tables&quot;);</a>
<a name="ln746"> </a>
<a name="ln747">  int batch_count = 0, total_count = 0, total_bytes = 0;</a>
<a name="ln748">  for (int i = 0; i &lt; source_table_ids.size(); ++i) {</a>
<a name="ln749">    auto&amp; source_table_id = source_table_ids[i];</a>
<a name="ln750">    auto&amp; target_table_id = target_table_ids[i];</a>
<a name="ln751"> </a>
<a name="ln752">    const auto* tablet = tablet_peer()-&gt;tablet();</a>
<a name="ln753">    const auto* meta = tablet-&gt;metadata();</a>
<a name="ln754">    const std::shared_ptr&lt;tablet::TableInfo&gt; source_table_info =</a>
<a name="ln755">        VERIFY_RESULT(meta-&gt;GetTableInfo(source_table_id));</a>
<a name="ln756">    const std::shared_ptr&lt;tablet::TableInfo&gt; target_table_info =</a>
<a name="ln757">        VERIFY_RESULT(meta-&gt;GetTableInfo(target_table_id));</a>
<a name="ln758">    const Schema source_projection = source_table_info-&gt;schema.CopyWithoutColumnIds();</a>
<a name="ln759">    std::unique_ptr&lt;common::YQLRowwiseIteratorIf&gt; iter = VERIFY_RESULT(</a>
<a name="ln760">        tablet-&gt;NewRowIterator(source_projection, boost::none, {}, source_table_id));</a>
<a name="ln761">    QLTableRow source_row;</a>
<a name="ln762"> </a>
<a name="ln763">    while (VERIFY_RESULT(iter-&gt;HasNext())) {</a>
<a name="ln764">      RETURN_NOT_OK(iter-&gt;NextRow(&amp;source_row));</a>
<a name="ln765"> </a>
<a name="ln766">      RETURN_NOT_OK(writer-&gt;InsertPgsqlTableRow(</a>
<a name="ln767">          source_table_info-&gt;schema, source_row, target_table_id, target_table_info-&gt;schema,</a>
<a name="ln768">          target_table_info-&gt;schema_version, true /* is_upsert */));</a>
<a name="ln769"> </a>
<a name="ln770">      ++total_count;</a>
<a name="ln771">      if (FLAGS_copy_tables_batch_bytes &gt; 0 &amp;&amp; 0 == (total_count % 128)) {</a>
<a name="ln772">          // Break up the write into batches of roughly the same serialized size</a>
<a name="ln773">          // in order to avoid uncontrolled large network writes.</a>
<a name="ln774">          // ByteSizeLong is an expensive calculation so do not perform it each time</a>
<a name="ln775"> </a>
<a name="ln776">        size_t batch_bytes = writer-&gt;req().ByteSizeLong();</a>
<a name="ln777">        if (batch_bytes &gt; FLAGS_copy_tables_batch_bytes) {</a>
<a name="ln778">          RETURN_NOT_OK(SyncWrite(writer.get()));</a>
<a name="ln779"> </a>
<a name="ln780">          total_bytes += batch_bytes;</a>
<a name="ln781">          ++batch_count;</a>
<a name="ln782">          LOG(INFO) &lt;&lt; Format(</a>
<a name="ln783">              &quot;CopyPgsqlTables: Batch# $0 copied $1 rows with $2 bytes&quot;, batch_count,</a>
<a name="ln784">              writer-&gt;req().pgsql_write_batch_size(), HumanizeBytes(batch_bytes));</a>
<a name="ln785"> </a>
<a name="ln786">          writer = NewWriter(leader_term);</a>
<a name="ln787">        }</a>
<a name="ln788">      }</a>
<a name="ln789">    }</a>
<a name="ln790">  }</a>
<a name="ln791"> </a>
<a name="ln792">  if (writer-&gt;req().pgsql_write_batch_size() &gt; 0) {</a>
<a name="ln793">    RETURN_NOT_OK(SyncWrite(writer.get()));</a>
<a name="ln794">    size_t batch_bytes = writer-&gt;req().ByteSizeLong();</a>
<a name="ln795">    total_bytes += batch_bytes;</a>
<a name="ln796">    ++batch_count;</a>
<a name="ln797">    LOG(INFO) &lt;&lt; Format(</a>
<a name="ln798">        &quot;CopyPgsqlTables: Batch# $0 copied $1 rows with $2 bytes&quot;, batch_count,</a>
<a name="ln799">        writer-&gt;req().pgsql_write_batch_size(), HumanizeBytes(batch_bytes));</a>
<a name="ln800">  }</a>
<a name="ln801"> </a>
<a name="ln802">  LOG(INFO) &lt;&lt; Format(</a>
<a name="ln803">      &quot;CopyPgsqlTables: Copied total $0 rows, total $1 bytes in $2 batches&quot;, total_count,</a>
<a name="ln804">      HumanizeBytes(total_bytes), batch_count);</a>
<a name="ln805">  return Status::OK();</a>
<a name="ln806">}</a>
<a name="ln807"> </a>
<a name="ln808">Status SysCatalogTable::DeleteYsqlSystemTable(const string&amp; table_id) {</a>
<a name="ln809">  tablet_peer()-&gt;tablet_metadata()-&gt;RemoveTable(table_id);</a>
<a name="ln810">  return Status::OK();</a>
<a name="ln811">}</a>
<a name="ln812"> </a>
<a name="ln813">const Schema&amp; SysCatalogTable::schema() {</a>
<a name="ln814">  return schema_;</a>
<a name="ln815">}</a>
<a name="ln816"> </a>
<a name="ln817">} // namespace master</a>
<a name="ln818">} // namespace yb</a>

</code></pre>
<div class="balloon" rel="142"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="143"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="144"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="145"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="146"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="251"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="324"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="387"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="429"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="453"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="459"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="505"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="676"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="677"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="678"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="688"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
