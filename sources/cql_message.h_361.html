
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>cql_message.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Copyright (c) YugaByte, Inc.</a>
<a name="ln2">//</a>
<a name="ln3">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln4">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln5">//</a>
<a name="ln6">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln7">//</a>
<a name="ln8">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln9">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln10">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln11">// under the License.</a>
<a name="ln12">//</a>
<a name="ln13">//</a>
<a name="ln14">// This file contains the CQLRequest and CQLResponse classes that implement the CQL protocol for</a>
<a name="ln15">// the CQL server. For the protocol spec, see https://github.com/apache/cassandra/tree/trunk/doc</a>
<a name="ln16">//   - native_protocol_v3.spec</a>
<a name="ln17">//   - native_protocol_v4.spec</a>
<a name="ln18">//   - native_protocol_v5.spec</a>
<a name="ln19"> </a>
<a name="ln20">#ifndef YB_YQL_CQL_CQLSERVER_CQL_MESSAGE_H_</a>
<a name="ln21">#define YB_YQL_CQL_CQLSERVER_CQL_MESSAGE_H_</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;stdint.h&gt;</a>
<a name="ln24">#include &lt;memory&gt;</a>
<a name="ln25">#include &lt;set&gt;</a>
<a name="ln26">#include &lt;unordered_map&gt;</a>
<a name="ln27"> </a>
<a name="ln28">#include &quot;yb/common/wire_protocol.h&quot;</a>
<a name="ln29">#include &quot;yb/rpc/server_event.h&quot;</a>
<a name="ln30">#include &quot;yb/yql/cql/ql/util/statement_params.h&quot;</a>
<a name="ln31">#include &quot;yb/yql/cql/ql/util/statement_result.h&quot;</a>
<a name="ln32"> </a>
<a name="ln33">#include &quot;yb/util/memory/memory_usage.h&quot;</a>
<a name="ln34">#include &quot;yb/util/slice.h&quot;</a>
<a name="ln35">#include &quot;yb/util/status.h&quot;</a>
<a name="ln36">#include &quot;yb/util/net/sockaddr.h&quot;</a>
<a name="ln37"> </a>
<a name="ln38">namespace yb {</a>
<a name="ln39">namespace cqlserver {</a>
<a name="ln40"> </a>
<a name="ln41">class CQLRequest;</a>
<a name="ln42">class CQLResponse;</a>
<a name="ln43"> </a>
<a name="ln44">// ---------------------------------- Generic CQL message ---------------------------------</a>
<a name="ln45">class CQLMessage {</a>
<a name="ln46"> </a>
<a name="ln47"> public:</a>
<a name="ln48">  //</a>
<a name="ln49">  // Each CQL message consists of a 9-byte header:</a>
<a name="ln50">  //   0         8        16        24        32         40</a>
<a name="ln51">  //   +---------+---------+---------+---------+---------+</a>
<a name="ln52">  //   | version |  flags  |      stream       | opcode  |</a>
<a name="ln53">  //   +---------+---------+---------+---------+---------+</a>
<a name="ln54">  //   |                length                 |</a>
<a name="ln55">  //   +---------+---------+---------+---------+</a>
<a name="ln56">  //   |            ...  body ...              |</a>
<a name="ln57">  //   +----------------------------------------</a>
<a name="ln58">  static constexpr int32_t kHeaderPosVersion    = 0;</a>
<a name="ln59">  static constexpr int32_t kHeaderPosFlags      = 1;</a>
<a name="ln60">  static constexpr int32_t kHeaderPosStreamId   = 2;</a>
<a name="ln61">  static constexpr int32_t kHeaderPosOpcode     = 4;</a>
<a name="ln62">  static constexpr int32_t kHeaderPosLength     = 5;</a>
<a name="ln63">  static constexpr int32_t kMessageHeaderLength = 9;</a>
<a name="ln64"> </a>
<a name="ln65">  // Datatypes for CQL message header</a>
<a name="ln66">  using Version = uint8_t;</a>
<a name="ln67">  static constexpr Version kV3Version       = 0x03;</a>
<a name="ln68">  static constexpr Version kV4Version       = 0x04; // Current Cassandra production version</a>
<a name="ln69">  static constexpr Version kMinimumVersion  = kV3Version;</a>
<a name="ln70">  static constexpr Version kCurrentVersion  = kV4Version;</a>
<a name="ln71">  static constexpr Version kV5Version       = 0x05; // In development. See JIRA CASSANDRA-9362.</a>
<a name="ln72">  static constexpr Version kResponseVersion = 0x80;</a>
<a name="ln73"> </a>
<a name="ln74">  using Flags = uint8_t;</a>
<a name="ln75">  static constexpr Flags kCompressionFlag   = 0x01;</a>
<a name="ln76">  static constexpr Flags kTracingFlag       = 0x02;</a>
<a name="ln77">  static constexpr Flags kCustomPayloadFlag = 0x04; // Since V4</a>
<a name="ln78">  static constexpr Flags kWarningFlag       = 0x08; // Since V4</a>
<a name="ln79"> </a>
<a name="ln80">  using StreamId = uint16_t;</a>
<a name="ln81">  static constexpr StreamId kEventStreamId = 0xffff; // Special stream id for events.</a>
<a name="ln82"> </a>
<a name="ln83">  enum class Opcode : uint8_t {</a>
<a name="ln84">    ERROR          = 0x00,</a>
<a name="ln85">    STARTUP        = 0x01,</a>
<a name="ln86">    READY          = 0x02,</a>
<a name="ln87">    AUTHENTICATE   = 0x03,</a>
<a name="ln88">    OPTIONS        = 0x05,</a>
<a name="ln89">    SUPPORTED      = 0x06,</a>
<a name="ln90">    QUERY          = 0x07,</a>
<a name="ln91">    RESULT         = 0x08,</a>
<a name="ln92">    PREPARE        = 0x09,</a>
<a name="ln93">    EXECUTE        = 0x0A,</a>
<a name="ln94">    REGISTER       = 0x0B,</a>
<a name="ln95">    EVENT          = 0x0C,</a>
<a name="ln96">    BATCH          = 0x0D,</a>
<a name="ln97">    AUTH_CHALLENGE = 0x0E,</a>
<a name="ln98">    AUTH_RESPONSE  = 0x0F,</a>
<a name="ln99">    AUTH_SUCCESS   = 0x10</a>
<a name="ln100">  };</a>
<a name="ln101"> </a>
<a name="ln102">  struct Header {</a>
<a name="ln103">    const Version  version;</a>
<a name="ln104">    const Flags    flags;</a>
<a name="ln105">    const StreamId stream_id;</a>
<a name="ln106">    const Opcode   opcode;</a>
<a name="ln107"> </a>
<a name="ln108">    Header(const Version version, const Flags flags, const StreamId stream_id, const Opcode opcode)</a>
<a name="ln109">       : version(version), flags(flags), stream_id(stream_id), opcode(opcode) { }</a>
<a name="ln110">    Header(const Version version, const StreamId stream_id, const Opcode opcode)</a>
<a name="ln111">       : version(version), flags(0), stream_id(stream_id), opcode(opcode) { }</a>
<a name="ln112">  };</a>
<a name="ln113"> </a>
<a name="ln114">  // STARTUP options.</a>
<a name="ln115">  static constexpr char kCQLVersionOption[] = &quot;CQL_VERSION&quot;;</a>
<a name="ln116">  static constexpr char kCompressionOption[] = &quot;COMPRESSION&quot;;</a>
<a name="ln117">  static constexpr char kNoCompactOption[] = &quot;NO_COMPACT&quot;;</a>
<a name="ln118"> </a>
<a name="ln119">  // Message body compression schemes.</a>
<a name="ln120">  enum class CompressionScheme {</a>
<a name="ln121">    kNone = 0,</a>
<a name="ln122">    kLz4,</a>
<a name="ln123">    kSnappy</a>
<a name="ln124">  };</a>
<a name="ln125">  static constexpr char kLZ4Compression[] = &quot;lz4&quot;;</a>
<a name="ln126">  static constexpr char kSnappyCompression[] = &quot;snappy&quot;;</a>
<a name="ln127"> </a>
<a name="ln128">  // Supported events.</a>
<a name="ln129">  static constexpr char kTopologyChangeEvent[] = &quot;TOPOLOGY_CHANGE&quot;;</a>
<a name="ln130">  static constexpr char kStatusChangeEvent[] = &quot;STATUS_CHANGE&quot;;</a>
<a name="ln131">  static constexpr char kSchemaChangeEvent[] = &quot;SCHEMA_CHANGE&quot;;</a>
<a name="ln132"> </a>
<a name="ln133">  using Events = uint8_t;</a>
<a name="ln134">  static constexpr Events kNoEvents       = 0x00;</a>
<a name="ln135">  static constexpr Events kTopologyChange = 0x01;</a>
<a name="ln136">  static constexpr Events kStatusChange   = 0x02;</a>
<a name="ln137">  static constexpr Events kSchemaChange   = 0x04;</a>
<a name="ln138">  static constexpr Events kAllEvents      = kTopologyChange | kStatusChange | kSchemaChange;</a>
<a name="ln139"> </a>
<a name="ln140">  // Basic datatype mapping for CQL message body:</a>
<a name="ln141">  //   Int        -&gt; int32_t</a>
<a name="ln142">  //   Long       -&gt; int64_t</a>
<a name="ln143">  //   Byte       -&gt; uint8_t</a>
<a name="ln144">  //   Short      -&gt; uint16_t</a>
<a name="ln145">  //   String     -&gt; std::string</a>
<a name="ln146">  //   LongString -&gt; std::string</a>
<a name="ln147">  //   UUID       -&gt; std::string</a>
<a name="ln148">  //   TimeUUID   -&gt; std::string</a>
<a name="ln149">  //   StringList -&gt; std::vector&lt;String&gt;</a>
<a name="ln150">  //   Bytes      -&gt; std::string</a>
<a name="ln151">  //   ShortBytes -&gt; std::string</a>
<a name="ln152">  //   Inet       -&gt; Endpoint</a>
<a name="ln153">  //   Consistency    -&gt; uint16_t</a>
<a name="ln154">  //   StringMap      -&gt; std::unordered_map&lt;std::string, std::string&gt;</a>
<a name="ln155">  //   StringMultiMap -&gt; std::unordered_map&lt;std::string, std::vector&lt;String&gt;&gt;</a>
<a name="ln156">  //   BytesMap       -&gt; std::unordered_map&lt;std::string, std::string&gt; (Since V4)</a>
<a name="ln157">  static constexpr size_t kIntSize   = 4;</a>
<a name="ln158">  static constexpr size_t kLongSize  = 8;</a>
<a name="ln159">  static constexpr size_t kByteSize  = 1;</a>
<a name="ln160">  static constexpr size_t kShortSize = 2;</a>
<a name="ln161">  static constexpr size_t kUUIDSize  = 16;</a>
<a name="ln162">  static constexpr size_t kConsistencySize = 2;</a>
<a name="ln163">  enum class Consistency : uint16_t {</a>
<a name="ln164">    ANY          = 0x0000,</a>
<a name="ln165">    ONE          = 0x0001,</a>
<a name="ln166">    TWO          = 0x0002,</a>
<a name="ln167">    THREE        = 0x0003,</a>
<a name="ln168">    QUORUM       = 0x0004,</a>
<a name="ln169">    ALL          = 0x0005,</a>
<a name="ln170">    LOCAL_QUORUM = 0x0006,</a>
<a name="ln171">    EACH_QUORUM  = 0x0007,</a>
<a name="ln172">    SERIAL       = 0x0008,</a>
<a name="ln173">    LOCAL_SERIAL = 0x0009,</a>
<a name="ln174">    LOCAL_ONE    = 0x000A</a>
<a name="ln175">  };</a>
<a name="ln176"> </a>
<a name="ln177">  struct Value {</a>
<a name="ln178">    enum class Kind {</a>
<a name="ln179">      NOT_NULL =  0,</a>
<a name="ln180">      IS_NULL  = -1, // Since V4</a>
<a name="ln181">      NOT_SET  = -2  // Since V4</a>
<a name="ln182">    };</a>
<a name="ln183"> </a>
<a name="ln184">    Kind kind = Kind::NOT_NULL;</a>
<a name="ln185">    std::string name;</a>
<a name="ln186">    std::string value; // As required by QLValue::Deserialize() for CQL, the value includes</a>
<a name="ln187">                       // the 4-byte length header, i.e. &quot;&lt;4-byte-length&gt;&lt;value&gt;&quot;.</a>
<a name="ln188">  };</a>
<a name="ln189"> </a>
<a name="ln190">  // Id of a prepared query for PREPARE, EXECUTE and BATCH requests.</a>
<a name="ln191">  using QueryId = std::string;</a>
<a name="ln192"> </a>
<a name="ln193">  // Query parameters for QUERY, EXECUTE and BATCH requests</a>
<a name="ln194">  struct QueryParameters : ql::StatementParameters {</a>
<a name="ln195">    using Flags = uint8_t;</a>
<a name="ln196">    static constexpr Flags kWithValuesFlag            = 0x01;</a>
<a name="ln197">    static constexpr Flags kSkipMetadataFlag          = 0x02;</a>
<a name="ln198">    static constexpr Flags kWithPageSizeFlag          = 0x04;</a>
<a name="ln199">    static constexpr Flags kWithPagingStateFlag       = 0x08;</a>
<a name="ln200">    static constexpr Flags kWithSerialConsistencyFlag = 0x10;</a>
<a name="ln201">    static constexpr Flags kWithDefaultTimestampFlag  = 0x20;</a>
<a name="ln202">    static constexpr Flags kWithNamesForValuesFlag    = 0x40;</a>
<a name="ln203"> </a>
<a name="ln204">    Consistency consistency = Consistency::ANY;</a>
<a name="ln205">    Flags flags = 0;</a>
<a name="ln206">    std::vector&lt;Value&gt; values;</a>
<a name="ln207">    std::unordered_map&lt;std::string, std::vector&lt;Value&gt;::size_type&gt; value_map;</a>
<a name="ln208">    Consistency serial_consistency = Consistency::ANY;</a>
<a name="ln209">    int64_t default_timestamp = 0;</a>
<a name="ln210"> </a>
<a name="ln211">    QueryParameters() : ql::StatementParameters() { }</a>
<a name="ln212"> </a>
<a name="ln213">    virtual CHECKED_STATUS GetBindVariable(const std::string&amp; name,</a>
<a name="ln214">                                           int64_t pos,</a>
<a name="ln215">                                           const std::shared_ptr&lt;QLType&gt;&amp; type,</a>
<a name="ln216">                                           QLValue* value) const override;</a>
<a name="ln217"> </a>
<a name="ln218">    CHECKED_STATUS ValidateConsistency();</a>
<a name="ln219">  };</a>
<a name="ln220"> </a>
<a name="ln221">  // Accessors for header fields</a>
<a name="ln222">  Version version()    const { return header_.version;   }</a>
<a name="ln223">  Flags flags()        const { return header_.flags;     }</a>
<a name="ln224">  StreamId stream_id() const { return header_.stream_id; }</a>
<a name="ln225">  Opcode opcode()      const { return header_.opcode;    }</a>
<a name="ln226"> </a>
<a name="ln227"> protected:</a>
<a name="ln228">  explicit CQLMessage(const Header&amp; header) : header_(header) { }</a>
<a name="ln229">  virtual ~CQLMessage() { }</a>
<a name="ln230"> </a>
<a name="ln231">  bool VersionIsCompatible(const Version min_version) const {</a>
<a name="ln232">    return (version() &amp; ~kResponseVersion) &gt;= min_version;</a>
<a name="ln233">  }</a>
<a name="ln234"> </a>
<a name="ln235">  const Header header_;</a>
<a name="ln236">};</a>
<a name="ln237"> </a>
<a name="ln238">// ------------------------------------ CQL request -----------------------------------</a>
<a name="ln239">class CQLRequest : public CQLMessage {</a>
<a name="ln240"> public:</a>
<a name="ln241">  // &quot;Factory&quot; function to parse a CQL serlized request message and construct a request object.</a>
<a name="ln242">  // Return true iff a request is parsed successfully without error. If an error occurs, an error</a>
<a name="ln243">  // response will be returned instead and it should be sent back to the CQL client.</a>
<a name="ln244">  static bool ParseRequest(</a>
<a name="ln245">      const Slice&amp; mesg, CompressionScheme compression_scheme,</a>
<a name="ln246">      std::unique_ptr&lt;CQLRequest&gt;* request, std::unique_ptr&lt;CQLResponse&gt;* error_response);</a>
<a name="ln247"> </a>
<a name="ln248">  static StreamId ParseStreamId(const Slice&amp; mesg) {</a>
<a name="ln249">    return static_cast&lt;StreamId&gt;(NetworkByteOrder::Load16(mesg.data() + kHeaderPosStreamId));</a>
<a name="ln250">  }</a>
<a name="ln251"> </a>
<a name="ln252">  virtual ~CQLRequest();</a>
<a name="ln253"> </a>
<a name="ln254"> protected:</a>
<a name="ln255">  CQLRequest(const Header&amp; header, const Slice&amp; body);</a>
<a name="ln256"> </a>
<a name="ln257">  // Function to parse a request body that all CQLRequest subclasses need to implement</a>
<a name="ln258">  virtual CHECKED_STATUS ParseBody() = 0;</a>
<a name="ln259"> </a>
<a name="ln260">  // Parse a CQL number (8, 16, 32 and 64-bit integer). &lt;num_type&gt; is the parsed integer type.</a>
<a name="ln261">  // &lt;converter&gt; converts the number from network byte-order to machine order and &lt;data_type&gt;</a>
<a name="ln262">  // is the coverter's return type. The converter's return type &lt;data_type&gt; is unsigned while</a>
<a name="ln263">  // &lt;num_type&gt; may be signed or unsigned.</a>
<a name="ln264">  template&lt;typename num_type, typename data_type&gt;</a>
<a name="ln265">  inline CHECKED_STATUS ParseNum(</a>
<a name="ln266">      const char* type_name, data_type (*converter)(const void*), num_type* val) {</a>
<a name="ln267">    RETURN_NOT_OK(CQLDecodeNum(sizeof(num_type), converter, &amp;body_, val));</a>
<a name="ln268">    DVLOG(4) &lt;&lt; type_name &lt;&lt; &quot; &quot; &lt;&lt; static_cast&lt;int64_t&gt;(*val);</a>
<a name="ln269">    return Status::OK();</a>
<a name="ln270">  }</a>
<a name="ln271"> </a>
<a name="ln272">  // Parse a CQL byte stream (string or bytes). &lt;len_type&gt; is the parsed length type.</a>
<a name="ln273">  // &lt;len_parser&gt; parses the byte length from network byte-order to machine order.</a>
<a name="ln274">  template&lt;typename len_type&gt;</a>
<a name="ln275">  inline CHECKED_STATUS ParseBytes(</a>
<a name="ln276">      const char* type_name, Status (CQLRequest::*len_parser)(len_type*), std::string* val) {</a>
<a name="ln277">    len_type len = 0;</a>
<a name="ln278">    RETURN_NOT_OK((this-&gt;*len_parser)(&amp;len));</a>
<a name="ln279">    RETURN_NOT_OK(CQLDecodeBytes(static_cast&lt;size_t&gt;(len), &amp;body_, val));</a>
<a name="ln280">    DVLOG(4) &lt;&lt; type_name &lt;&lt; &quot; &quot; &lt;&lt; *val;</a>
<a name="ln281">    return Status::OK();</a>
<a name="ln282">  }</a>
<a name="ln283"> </a>
<a name="ln284">  inline CHECKED_STATUS ParseByte(uint8_t* value) {</a>
<a name="ln285">    static_assert(sizeof(*value) == kByteSize, &quot;inconsistent byte size&quot;);</a>
<a name="ln286">    return ParseNum(&quot;CQL byte&quot;, Load8, value);</a>
<a name="ln287">  }</a>
<a name="ln288">  inline CHECKED_STATUS ParseShort(uint16_t* value) {</a>
<a name="ln289">    static_assert(sizeof(*value) == kShortSize, &quot;inconsistent short size&quot;);</a>
<a name="ln290">    return ParseNum(&quot;CQL byte&quot;, NetworkByteOrder::Load16, value);</a>
<a name="ln291">  }</a>
<a name="ln292">  inline CHECKED_STATUS ParseInt(int32_t* value) {</a>
<a name="ln293">    static_assert(sizeof(*value) == kIntSize, &quot;inconsistent int size&quot;);</a>
<a name="ln294">    return ParseNum(&quot;CQL int&quot;, NetworkByteOrder::Load32, value);</a>
<a name="ln295">  }</a>
<a name="ln296">  inline CHECKED_STATUS ParseLong(int64_t* value) {</a>
<a name="ln297">    static_assert(sizeof(*value) == kLongSize, &quot;inconsistent long size&quot;);</a>
<a name="ln298">    return ParseNum(&quot;CQL long&quot;, NetworkByteOrder::Load64, value);</a>
<a name="ln299">  }</a>
<a name="ln300">  inline CHECKED_STATUS ParseString(std::string* value)  {</a>
<a name="ln301">    return ParseBytes(&quot;CQL string&quot;, &amp;CQLRequest::ParseShort, value);</a>
<a name="ln302">  }</a>
<a name="ln303">  inline CHECKED_STATUS ParseLongString(std::string* value)  {</a>
<a name="ln304">    return ParseBytes(&quot;CQL long string&quot;, &amp;CQLRequest::ParseInt, value);</a>
<a name="ln305">  }</a>
<a name="ln306">  inline CHECKED_STATUS ParseShortBytes(std::string* value) {</a>
<a name="ln307">    return ParseBytes(&quot;CQL short bytes&quot;, &amp;CQLRequest::ParseShort, value);</a>
<a name="ln308">  }</a>
<a name="ln309">  inline CHECKED_STATUS ParseBytes(std::string* value) {</a>
<a name="ln310">    return ParseBytes(&quot;CQL bytes&quot;, &amp;CQLRequest::ParseInt, value);</a>
<a name="ln311">  }</a>
<a name="ln312">  inline CHECKED_STATUS ParseConsistency(Consistency* consistency) {</a>
<a name="ln313">    static_assert(sizeof(*consistency) == kConsistencySize, &quot;inconsistent consistency size&quot;);</a>
<a name="ln314">    return ParseNum(&quot;CQL consistency&quot;, NetworkByteOrder::Load16, consistency);</a>
<a name="ln315">  }</a>
<a name="ln316">  CHECKED_STATUS ParseUUID(std::string* value);</a>
<a name="ln317">  CHECKED_STATUS ParseTimeUUID(std::string* value);</a>
<a name="ln318">  CHECKED_STATUS ParseStringList(std::vector&lt;std::string&gt;* list);</a>
<a name="ln319">  CHECKED_STATUS ParseInet(Endpoint* value);</a>
<a name="ln320">  CHECKED_STATUS ParseStringMap(std::unordered_map&lt;std::string, std::string&gt;* map);</a>
<a name="ln321">  CHECKED_STATUS ParseStringMultiMap(</a>
<a name="ln322">      std::unordered_map&lt;std::string, std::vector&lt;std::string&gt;&gt;* map);</a>
<a name="ln323">  CHECKED_STATUS ParseBytesMap(std::unordered_map&lt;std::string, std::string&gt;* map);</a>
<a name="ln324">  CHECKED_STATUS ParseValue(bool with_name, Value* value);</a>
<a name="ln325">  CHECKED_STATUS ParseQueryParameters(QueryParameters* params);</a>
<a name="ln326"> </a>
<a name="ln327"> private:</a>
<a name="ln328">  Slice body_;</a>
<a name="ln329">};</a>
<a name="ln330"> </a>
<a name="ln331">// ------------------------------ Individual CQL requests -----------------------------------</a>
<a name="ln332">class StartupRequest : public CQLRequest {</a>
<a name="ln333"> public:</a>
<a name="ln334">  StartupRequest(const Header&amp; header, const Slice&amp; body);</a>
<a name="ln335">  virtual ~StartupRequest() override;</a>
<a name="ln336"> </a>
<a name="ln337">  const std::unordered_map&lt;std::string, std::string&gt;&amp; options() const { return options_; }</a>
<a name="ln338"> </a>
<a name="ln339"> protected:</a>
<a name="ln340">  virtual CHECKED_STATUS ParseBody() override;</a>
<a name="ln341"> </a>
<a name="ln342"> private:</a>
<a name="ln343">  std::unordered_map&lt;std::string, std::string&gt; options_;</a>
<a name="ln344">};</a>
<a name="ln345"> </a>
<a name="ln346">//------------------------------------------------------------</a>
<a name="ln347">class AuthResponseRequest : public CQLRequest {</a>
<a name="ln348"> public:</a>
<a name="ln349">  class AuthQueryParameters : public ql::StatementParameters {</a>
<a name="ln350">   public:</a>
<a name="ln351">    AuthQueryParameters() : ql::StatementParameters() {}</a>
<a name="ln352"> </a>
<a name="ln353">    CHECKED_STATUS GetBindVariable(const std::string&amp; name,</a>
<a name="ln354">                                   int64_t pos,</a>
<a name="ln355">                                   const std::shared_ptr&lt;QLType&gt;&amp; type,</a>
<a name="ln356">                                   QLValue* value) const override;</a>
<a name="ln357">    std::string username;</a>
<a name="ln358">    std::string password;</a>
<a name="ln359">  };</a>
<a name="ln360"> </a>
<a name="ln361">  AuthResponseRequest(const Header&amp; header, const Slice&amp; body);</a>
<a name="ln362">  virtual ~AuthResponseRequest() override;</a>
<a name="ln363"> </a>
<a name="ln364">  const std::string&amp; token() const { return token_; }</a>
<a name="ln365">  const AuthQueryParameters&amp; params() const { return params_; }</a>
<a name="ln366"> </a>
<a name="ln367"> protected:</a>
<a name="ln368">  virtual CHECKED_STATUS ParseBody() override;</a>
<a name="ln369"> </a>
<a name="ln370"> private:</a>
<a name="ln371">  std::string token_;</a>
<a name="ln372">  AuthQueryParameters params_;</a>
<a name="ln373">};</a>
<a name="ln374"> </a>
<a name="ln375">//------------------------------------------------------------</a>
<a name="ln376">class OptionsRequest : public CQLRequest {</a>
<a name="ln377"> public:</a>
<a name="ln378">  OptionsRequest(const Header&amp; header, const Slice&amp; body);</a>
<a name="ln379">  virtual ~OptionsRequest() override;</a>
<a name="ln380"> </a>
<a name="ln381"> protected:</a>
<a name="ln382">  virtual CHECKED_STATUS ParseBody() override;</a>
<a name="ln383">};</a>
<a name="ln384"> </a>
<a name="ln385">//------------------------------------------------------------</a>
<a name="ln386">class QueryRequest : public CQLRequest {</a>
<a name="ln387"> public:</a>
<a name="ln388">  QueryRequest(const Header&amp; header, const Slice&amp; body);</a>
<a name="ln389">  virtual ~QueryRequest() override;</a>
<a name="ln390"> </a>
<a name="ln391">  const std::string&amp; query() const { return query_; }</a>
<a name="ln392">  const QueryParameters&amp; params() const { return params_; }</a>
<a name="ln393"> </a>
<a name="ln394"> protected:</a>
<a name="ln395">  virtual CHECKED_STATUS ParseBody() override;</a>
<a name="ln396"> </a>
<a name="ln397"> private:</a>
<a name="ln398">  std::string query_;</a>
<a name="ln399">  QueryParameters params_;</a>
<a name="ln400">};</a>
<a name="ln401"> </a>
<a name="ln402">//------------------------------------------------------------</a>
<a name="ln403">class PrepareRequest : public CQLRequest {</a>
<a name="ln404"> public:</a>
<a name="ln405">  PrepareRequest(const Header&amp; header, const Slice&amp; body);</a>
<a name="ln406">  virtual ~PrepareRequest() override;</a>
<a name="ln407"> </a>
<a name="ln408">  const std::string&amp; query() const { return query_; }</a>
<a name="ln409"> </a>
<a name="ln410"> protected:</a>
<a name="ln411">  virtual CHECKED_STATUS ParseBody() override;</a>
<a name="ln412"> </a>
<a name="ln413"> private:</a>
<a name="ln414">  std::string query_;</a>
<a name="ln415">};</a>
<a name="ln416"> </a>
<a name="ln417">//------------------------------------------------------------</a>
<a name="ln418">class ExecuteRequest : public CQLRequest {</a>
<a name="ln419"> public:</a>
<a name="ln420">  ExecuteRequest(const Header&amp; header, const Slice&amp; body);</a>
<a name="ln421">  virtual ~ExecuteRequest() override;</a>
<a name="ln422"> </a>
<a name="ln423">  const QueryId&amp; query_id() const { return query_id_; }</a>
<a name="ln424">  const QueryParameters&amp; params() const { return params_; }</a>
<a name="ln425"> </a>
<a name="ln426"> protected:</a>
<a name="ln427">  virtual CHECKED_STATUS ParseBody() override;</a>
<a name="ln428"> </a>
<a name="ln429"> private:</a>
<a name="ln430">  QueryId query_id_;</a>
<a name="ln431">  QueryParameters params_;</a>
<a name="ln432">};</a>
<a name="ln433"> </a>
<a name="ln434">//------------------------------------------------------------</a>
<a name="ln435">class BatchRequest : public CQLRequest {</a>
<a name="ln436"> public:</a>
<a name="ln437">  enum class Type : uint8_t {</a>
<a name="ln438">    LOGGED   = 0x00,</a>
<a name="ln439">    UNLOGGED = 0x01,</a>
<a name="ln440">    COUNTER  = 0x02</a>
<a name="ln441">  };</a>
<a name="ln442">  struct Query {</a>
<a name="ln443">    bool is_prepared = false;</a>
<a name="ln444">    QueryId query_id;</a>
<a name="ln445">    std::string query;</a>
<a name="ln446">    QueryParameters params;</a>
<a name="ln447">  };</a>
<a name="ln448"> </a>
<a name="ln449">  BatchRequest(const Header&amp; header, const Slice&amp; body);</a>
<a name="ln450">  virtual ~BatchRequest() override;</a>
<a name="ln451"> </a>
<a name="ln452">  const std::vector&lt;Query&gt;&amp; queries() const { return queries_; }</a>
<a name="ln453"> </a>
<a name="ln454"> protected:</a>
<a name="ln455">  virtual CHECKED_STATUS ParseBody() override;</a>
<a name="ln456"> </a>
<a name="ln457"> private:</a>
<a name="ln458"> </a>
<a name="ln459">  Type type_ = Type::LOGGED;</a>
<a name="ln460">  std::vector&lt;Query&gt; queries_;</a>
<a name="ln461">};</a>
<a name="ln462"> </a>
<a name="ln463">//------------------------------------------------------------</a>
<a name="ln464">class RegisterRequest : public CQLRequest {</a>
<a name="ln465"> public:</a>
<a name="ln466">  RegisterRequest(const Header&amp; header, const Slice&amp; body);</a>
<a name="ln467">  virtual ~RegisterRequest() override;</a>
<a name="ln468"> </a>
<a name="ln469">  Events events() const { return events_; }</a>
<a name="ln470"> </a>
<a name="ln471"> protected:</a>
<a name="ln472">  virtual CHECKED_STATUS ParseBody() override;</a>
<a name="ln473"> </a>
<a name="ln474"> private:</a>
<a name="ln475">  Events events_;</a>
<a name="ln476">};</a>
<a name="ln477"> </a>
<a name="ln478">// ------------------------------------ CQL response -----------------------------------</a>
<a name="ln479">class CQLResponse : public CQLMessage {</a>
<a name="ln480"> public:</a>
<a name="ln481">  virtual ~CQLResponse();</a>
<a name="ln482">  virtual void Serialize(CompressionScheme compression_scheme, faststring* mesg) const;</a>
<a name="ln483"> </a>
<a name="ln484">  Events registered_events() const { return registered_events_; }</a>
<a name="ln485">  void set_registered_events(Events events) { registered_events_ = events; }</a>
<a name="ln486"> </a>
<a name="ln487"> protected:</a>
<a name="ln488">  CQLResponse(const CQLRequest&amp; request, Opcode opcode);</a>
<a name="ln489">  CQLResponse(StreamId stream_id, Opcode opcode);</a>
<a name="ln490">  void SerializeHeader(bool compress, faststring* mesg) const;</a>
<a name="ln491"> </a>
<a name="ln492">  // Function to serialize a response body that all CQLResponse subclasses need to implement</a>
<a name="ln493">  virtual void SerializeBody(faststring* mesg) const = 0;</a>
<a name="ln494"> </a>
<a name="ln495"> private:</a>
<a name="ln496">  Events registered_events_ = kNoEvents;</a>
<a name="ln497">};</a>
<a name="ln498"> </a>
<a name="ln499">// ------------------------------ Individual CQL responses -----------------------------------</a>
<a name="ln500">class ErrorResponse : public CQLResponse {</a>
<a name="ln501"> public:</a>
<a name="ln502">  enum class Code : int32_t {</a>
<a name="ln503">    SERVER_ERROR     = 0x0000,</a>
<a name="ln504">    PROTOCOL_ERROR   = 0x000A,</a>
<a name="ln505">    BAD_CREDENTIALS  = 0x0100,</a>
<a name="ln506">    UNAVAILABLE      = 0x1000,</a>
<a name="ln507">    OVERLOADED       = 0x1001,</a>
<a name="ln508">    IS_BOOTSTRAPPING = 0x1002,</a>
<a name="ln509">    TRUNCATE_ERROR   = 0x1003,</a>
<a name="ln510">    WRITE_TIMEOUT    = 0x1100,</a>
<a name="ln511">    READ_TIMEOUT     = 0x1200,</a>
<a name="ln512">    READ_FAILURE     = 0x1300, // Since V4</a>
<a name="ln513">    FUNCTION_FAILURE = 0x1400, // Since V4</a>
<a name="ln514">    WRITE_FAILURE    = 0x1500, // Since V4</a>
<a name="ln515">    SYNTAX_ERROR     = 0x2000,</a>
<a name="ln516">    UNAUTHORIZED     = 0x2100,</a>
<a name="ln517">    INVALID          = 0x2200,</a>
<a name="ln518">    CONFIG_ERROR     = 0x2300,</a>
<a name="ln519">    ALREADY_EXISTS   = 0x2400,</a>
<a name="ln520">    UNPREPARED       = 0x2500,</a>
<a name="ln521">  };</a>
<a name="ln522"> </a>
<a name="ln523">  // Construct an error response for the request, or by just the stream id if the request object</a>
<a name="ln524">  // is not constructed (e.g. when the request opcode is invalid).</a>
<a name="ln525">  ErrorResponse(const CQLRequest&amp; request, Code code, const std::string&amp; message);</a>
<a name="ln526">  ErrorResponse(const CQLRequest&amp; request, Code code, const Status&amp; status);</a>
<a name="ln527">  ErrorResponse(StreamId stream_id, Code code, const std::string&amp; message);</a>
<a name="ln528"> </a>
<a name="ln529">  virtual ~ErrorResponse() override;</a>
<a name="ln530"> </a>
<a name="ln531"> protected:</a>
<a name="ln532">  virtual void SerializeBody(faststring* mesg) const override;</a>
<a name="ln533">  virtual void SerializeErrorBody(faststring* mesg) const;</a>
<a name="ln534"> </a>
<a name="ln535"> private:</a>
<a name="ln536">  const Code code_;</a>
<a name="ln537">  const std::string message_;</a>
<a name="ln538">};</a>
<a name="ln539"> </a>
<a name="ln540">//------------------------------------------------------------</a>
<a name="ln541">class UnpreparedErrorResponse : public ErrorResponse {</a>
<a name="ln542"> public:</a>
<a name="ln543">  explicit UnpreparedErrorResponse(const CQLRequest&amp; request, const QueryId&amp; query_id);</a>
<a name="ln544">  virtual ~UnpreparedErrorResponse() override;</a>
<a name="ln545"> </a>
<a name="ln546"> protected:</a>
<a name="ln547">  virtual void SerializeErrorBody(faststring* mesg) const override;</a>
<a name="ln548"> </a>
<a name="ln549"> private:</a>
<a name="ln550">  const QueryId query_id_;</a>
<a name="ln551">};</a>
<a name="ln552"> </a>
<a name="ln553">//------------------------------------------------------------</a>
<a name="ln554">class ReadyResponse : public CQLResponse {</a>
<a name="ln555"> public:</a>
<a name="ln556">  explicit ReadyResponse(const CQLRequest&amp; request);</a>
<a name="ln557">  virtual ~ReadyResponse() override;</a>
<a name="ln558"> </a>
<a name="ln559"> protected:</a>
<a name="ln560">  virtual void SerializeBody(faststring* mesg) const override;</a>
<a name="ln561">};</a>
<a name="ln562"> </a>
<a name="ln563">//------------------------------------------------------------</a>
<a name="ln564">class AuthenticateResponse : public CQLResponse {</a>
<a name="ln565"> public:</a>
<a name="ln566">  AuthenticateResponse(const CQLRequest&amp; request, const std::string&amp; authenticator);</a>
<a name="ln567">  virtual ~AuthenticateResponse() override;</a>
<a name="ln568"> </a>
<a name="ln569"> protected:</a>
<a name="ln570">  virtual void SerializeBody(faststring* mesg) const override;</a>
<a name="ln571"> </a>
<a name="ln572"> private:</a>
<a name="ln573">  const std::string authenticator_;</a>
<a name="ln574">};</a>
<a name="ln575"> </a>
<a name="ln576">//------------------------------------------------------------</a>
<a name="ln577">class SupportedResponse : public CQLResponse {</a>
<a name="ln578"> public:</a>
<a name="ln579">  explicit SupportedResponse(</a>
<a name="ln580">      const CQLRequest&amp; request,</a>
<a name="ln581">      const std::unordered_map&lt;std::string, std::vector&lt;std::string&gt;&gt;* options);</a>
<a name="ln582">  virtual ~SupportedResponse() override;</a>
<a name="ln583"> </a>
<a name="ln584"> protected:</a>
<a name="ln585">  virtual void SerializeBody(faststring* mesg) const override;</a>
<a name="ln586"> </a>
<a name="ln587"> private:</a>
<a name="ln588">  const std::unordered_map&lt;std::string, std::vector&lt;std::string&gt;&gt;* options_;</a>
<a name="ln589">};</a>
<a name="ln590"> </a>
<a name="ln591">//------------------------------------------------------------</a>
<a name="ln592">class ResultResponse : public CQLResponse {</a>
<a name="ln593"> public:</a>
<a name="ln594">  virtual ~ResultResponse() override;</a>
<a name="ln595"> </a>
<a name="ln596"> protected:</a>
<a name="ln597">  enum class Kind : int32_t {</a>
<a name="ln598">    VOID          = 0x00000001,</a>
<a name="ln599">    ROWS          = 0x00000002,</a>
<a name="ln600">    SET_KEYSPACE  = 0x00000003,</a>
<a name="ln601">    PREPARED      = 0x00000004,</a>
<a name="ln602">    SCHEMA_CHANGE = 0x00000005</a>
<a name="ln603">  };</a>
<a name="ln604"> </a>
<a name="ln605">  // Metadata for ROWS resultset</a>
<a name="ln606">  struct RowsMetadata {</a>
<a name="ln607">    using Flags = int32_t;</a>
<a name="ln608">    static constexpr Flags kHasGlobalTableSpec = 0x00000001;</a>
<a name="ln609">    static constexpr Flags kHasMorePages       = 0x00000002;</a>
<a name="ln610">    static constexpr Flags kNoMetadata         = 0x00000004;</a>
<a name="ln611"> </a>
<a name="ln612">    Flags flags = 0;</a>
<a name="ln613">    std::string paging_state;</a>
<a name="ln614"> </a>
<a name="ln615">    struct GlobalTableSpec {</a>
<a name="ln616">      std::string keyspace;</a>
<a name="ln617">      std::string table;</a>
<a name="ln618"> </a>
<a name="ln619">      GlobalTableSpec() { }</a>
<a name="ln620">      GlobalTableSpec(const std::string&amp; keyspace, const std::string&amp; table)</a>
<a name="ln621">          : keyspace(keyspace), table(table) { }</a>
<a name="ln622">    };</a>
<a name="ln623">    GlobalTableSpec global_table_spec;</a>
<a name="ln624"> </a>
<a name="ln625">    struct Type {</a>
<a name="ln626">      enum class Id : uint16_t {</a>
<a name="ln627">        CUSTOM    = 0x0000,</a>
<a name="ln628">        ASCII     = 0x0001,</a>
<a name="ln629">        BIGINT    = 0x0002,</a>
<a name="ln630">        BLOB      = 0x0003,</a>
<a name="ln631">        BOOLEAN   = 0x0004,</a>
<a name="ln632">        COUNTER   = 0x0005,</a>
<a name="ln633">        DECIMAL   = 0x0006,</a>
<a name="ln634">        DOUBLE    = 0x0007,</a>
<a name="ln635">        FLOAT     = 0x0008,</a>
<a name="ln636">        INT       = 0x0009,</a>
<a name="ln637">        TIMESTAMP = 0x000B,</a>
<a name="ln638">        UUID      = 0x000C,</a>
<a name="ln639">        VARCHAR   = 0x000D,</a>
<a name="ln640">        VARINT    = 0x000E,</a>
<a name="ln641">        TIMEUUID  = 0x000F,</a>
<a name="ln642">        INET      = 0x0010,</a>
<a name="ln643">        DATE      = 0x0011, // Since V4</a>
<a name="ln644">        TIME      = 0x0012, // Since V4</a>
<a name="ln645">        SMALLINT  = 0x0013, // Since V4</a>
<a name="ln646">        TINYINT   = 0x0014, // Since V4</a>
<a name="ln647">        LIST      = 0x0020,</a>
<a name="ln648">        MAP       = 0x0021,</a>
<a name="ln649">        SET       = 0x0022,</a>
<a name="ln650">        UDT       = 0x0030,</a>
<a name="ln651">        TUPLE     = 0x0031,</a>
<a name="ln652">        JSONB     = 0x0080  // Yugabyte specific types start here</a>
<a name="ln653">      };</a>
<a name="ln654"> </a>
<a name="ln655">      Id id = Id::CUSTOM;</a>
<a name="ln656"> </a>
<a name="ln657">      struct MapType {</a>
<a name="ln658">        std::shared_ptr&lt;const Type&gt; key_type;</a>
<a name="ln659">        std::shared_ptr&lt;const Type&gt; value_type;</a>
<a name="ln660">      };</a>
<a name="ln661"> </a>
<a name="ln662">      struct UDTType {</a>
<a name="ln663">        std::string keyspace;</a>
<a name="ln664">        std::string name;</a>
<a name="ln665">        struct Field {</a>
<a name="ln666">          std::string name;</a>
<a name="ln667">          std::shared_ptr&lt;const Type&gt; type;</a>
<a name="ln668">        };</a>
<a name="ln669">        std::vector&lt;Field&gt; fields;</a>
<a name="ln670">      };</a>
<a name="ln671"> </a>
<a name="ln672">      typedef std::vector&lt;std::shared_ptr&lt;const Type&gt;&gt; TupleComponentTypes;</a>
<a name="ln673"> </a>
<a name="ln674">      // The use of union to store strings and shared pointers needs to be done with great care</a>
<a name="ln675">      // since constructors and destructors won't be called automatically.</a>
<a name="ln676">      // TODO(Robert): an alternate idea will be to create a type hierarchy of individual types</a>
<a name="ln677">      // and allocate it out of a memory pool to avoid allocation overhead and memory</a>
<a name="ln678">      // fragmentation. Revisit it when we return real query results from tserver.</a>
<a name="ln679">      union {</a>
<a name="ln680">        std::string custom_class_name;</a>
<a name="ln681">        std::shared_ptr&lt;const Type&gt; element_type; // for list or set</a>
<a name="ln682">        std::shared_ptr&lt;const MapType&gt; map_type;</a>
<a name="ln683">        std::shared_ptr&lt;const UDTType&gt; udt_type;</a>
<a name="ln684">        std::shared_ptr&lt;const TupleComponentTypes&gt; tuple_component_types;</a>
<a name="ln685">      };</a>
<a name="ln686"> </a>
<a name="ln687">      explicit Type(Id id); // for primitive type</a>
<a name="ln688">      explicit Type(const std::string&amp; custom_class_name);</a>
<a name="ln689">               Type(Id id, std::shared_ptr&lt;const Type&gt; element_type); // for list or set</a>
<a name="ln690">      explicit Type(std::shared_ptr&lt;const MapType&gt; map_type);</a>
<a name="ln691">      explicit Type(std::shared_ptr&lt;const UDTType&gt; udt_type);</a>
<a name="ln692">      explicit Type(std::shared_ptr&lt;const TupleComponentTypes&gt; tuple_component_types);</a>
<a name="ln693">      explicit Type(const Type&amp; t);</a>
<a name="ln694">      explicit Type(const std::shared_ptr&lt;QLType&gt;&amp; type);</a>
<a name="ln695">      ~Type();</a>
<a name="ln696">    };</a>
<a name="ln697">    struct ColSpec {</a>
<a name="ln698">      std::string keyspace;</a>
<a name="ln699">      std::string table;</a>
<a name="ln700">      std::string column;</a>
<a name="ln701">      Type type;</a>
<a name="ln702"> </a>
<a name="ln703">      ColSpec(const client::YBTableName&amp; table_name, const std::string&amp; column, const Type&amp; type)</a>
<a name="ln704">          : keyspace(table_name.namespace_name()), table(table_name.table_name()),</a>
<a name="ln705">            column(column), type(type) {}</a>
<a name="ln706">      ColSpec(const std::string&amp; column, const Type&amp; type) : column(column), type(type) {}</a>
<a name="ln707">    };</a>
<a name="ln708">    int32_t col_count;</a>
<a name="ln709">    std::vector&lt;ColSpec&gt; col_specs;</a>
<a name="ln710"> </a>
<a name="ln711">    RowsMetadata();</a>
<a name="ln712">    RowsMetadata(const client::YBTableName&amp; table_name,</a>
<a name="ln713">                 const std::vector&lt;ColumnSchema&gt;&amp; columns,</a>
<a name="ln714">                 const std::string&amp; paging_state,</a>
<a name="ln715">                 bool no_metadata);</a>
<a name="ln716">  };</a>
<a name="ln717"> </a>
<a name="ln718">  ResultResponse(const CQLRequest&amp; request, Kind kind);</a>
<a name="ln719">  virtual void SerializeBody(faststring* mesg) const override;</a>
<a name="ln720"> </a>
<a name="ln721">  // Function to serialize a result body that all ResultResponse subclasses need to implement</a>
<a name="ln722">  virtual void SerializeResultBody(faststring* mesg) const = 0;</a>
<a name="ln723"> </a>
<a name="ln724">  // Helper serialize functions</a>
<a name="ln725">  void SerializeType(const RowsMetadata::Type* type, faststring* mesg) const;</a>
<a name="ln726">  void SerializeColSpecs(</a>
<a name="ln727">      bool has_global_table_spec, const RowsMetadata::GlobalTableSpec&amp; global_table_spec,</a>
<a name="ln728">      const std::vector&lt;RowsMetadata::ColSpec&gt;&amp; col_specs, faststring* mesg) const;</a>
<a name="ln729">  void SerializeRowsMetadata(const RowsMetadata&amp; metadata, faststring* mesg) const;</a>
<a name="ln730"> </a>
<a name="ln731"> private:</a>
<a name="ln732">  const Kind kind_;</a>
<a name="ln733">};</a>
<a name="ln734"> </a>
<a name="ln735">//------------------------------------------------------------</a>
<a name="ln736">class VoidResultResponse : public ResultResponse {</a>
<a name="ln737"> public:</a>
<a name="ln738">  explicit VoidResultResponse(const CQLRequest&amp; request);</a>
<a name="ln739">  virtual ~VoidResultResponse() override;</a>
<a name="ln740"> </a>
<a name="ln741"> protected:</a>
<a name="ln742">  virtual void SerializeResultBody(faststring* mesg) const override;</a>
<a name="ln743">};</a>
<a name="ln744"> </a>
<a name="ln745">//------------------------------------------------------------</a>
<a name="ln746">class RowsResultResponse : public ResultResponse {</a>
<a name="ln747"> public:</a>
<a name="ln748">  RowsResultResponse(const QueryRequest&amp; request, const ql::RowsResult::SharedPtr&amp; result);</a>
<a name="ln749">  RowsResultResponse(const ExecuteRequest&amp; request, const ql::RowsResult::SharedPtr&amp; result);</a>
<a name="ln750">  RowsResultResponse(const BatchRequest&amp; request, const ql::RowsResult::SharedPtr&amp; result);</a>
<a name="ln751"> </a>
<a name="ln752">  virtual ~RowsResultResponse() override;</a>
<a name="ln753"> </a>
<a name="ln754"> protected:</a>
<a name="ln755">  virtual void SerializeResultBody(faststring* mesg) const override;</a>
<a name="ln756"> </a>
<a name="ln757"> private:</a>
<a name="ln758">  const ql::RowsResult::SharedPtr result_;</a>
<a name="ln759">  const bool skip_metadata_;</a>
<a name="ln760">};</a>
<a name="ln761"> </a>
<a name="ln762">//------------------------------------------------------------</a>
<a name="ln763">class SetKeyspaceResultResponse : public ResultResponse {</a>
<a name="ln764"> public:</a>
<a name="ln765">  SetKeyspaceResultResponse(const CQLRequest&amp; request, const ql::SetKeyspaceResult&amp; result);</a>
<a name="ln766">  virtual ~SetKeyspaceResultResponse() override;</a>
<a name="ln767"> protected:</a>
<a name="ln768">  virtual void SerializeResultBody(faststring* mesg) const override;</a>
<a name="ln769"> private:</a>
<a name="ln770">  const std::string keyspace_;</a>
<a name="ln771">};</a>
<a name="ln772"> </a>
<a name="ln773">//------------------------------------------------------------</a>
<a name="ln774">class PreparedResultResponse : public ResultResponse {</a>
<a name="ln775"> public:</a>
<a name="ln776">  PreparedResultResponse(const CQLRequest&amp; request, const QueryId&amp; query_id);</a>
<a name="ln777">  PreparedResultResponse(</a>
<a name="ln778">      const CQLRequest&amp; request, const QueryId&amp; query_id, const ql::PreparedResult&amp; result);</a>
<a name="ln779">  virtual ~PreparedResultResponse() override;</a>
<a name="ln780"> </a>
<a name="ln781"> protected:</a>
<a name="ln782">  virtual void SerializeResultBody(faststring* mesg) const override;</a>
<a name="ln783"> </a>
<a name="ln784"> private:</a>
<a name="ln785">  struct PreparedMetadata {</a>
<a name="ln786">    using Flags = int32_t;</a>
<a name="ln787">    static constexpr Flags kHasGlobalTableSpec = 0x00000001;</a>
<a name="ln788"> </a>
<a name="ln789">    Flags flags = 0;</a>
<a name="ln790">    std::vector&lt;uint16_t&gt; pk_indices;</a>
<a name="ln791">    RowsMetadata::GlobalTableSpec global_table_spec;</a>
<a name="ln792">    std::vector&lt;RowsMetadata::ColSpec&gt; col_specs;</a>
<a name="ln793"> </a>
<a name="ln794">    PreparedMetadata();</a>
<a name="ln795">    PreparedMetadata(</a>
<a name="ln796">        const client::YBTableName&amp; table_name, const std::vector&lt;int64_t&gt;&amp; hash_col_indices,</a>
<a name="ln797">        const std::vector&lt;client::YBTableName&gt;&amp; bind_table_names,</a>
<a name="ln798">        const std::vector&lt;ColumnSchema&gt;&amp; bind_variable_schemas);</a>
<a name="ln799">  };</a>
<a name="ln800"> </a>
<a name="ln801">  void SerializePreparedMetadata(const PreparedMetadata&amp; metadata, faststring* mesg) const;</a>
<a name="ln802"> </a>
<a name="ln803">  const QueryId query_id_;</a>
<a name="ln804">  const PreparedMetadata prepared_metadata_;</a>
<a name="ln805">  const RowsMetadata rows_metadata_;</a>
<a name="ln806">};</a>
<a name="ln807"> </a>
<a name="ln808">//------------------------------------------------------------</a>
<a name="ln809">class SchemaChangeResultResponse : public ResultResponse {</a>
<a name="ln810"> public:</a>
<a name="ln811">  SchemaChangeResultResponse(const CQLRequest&amp; request, const ql::SchemaChangeResult&amp; result);</a>
<a name="ln812">  virtual ~SchemaChangeResultResponse() override;</a>
<a name="ln813"> </a>
<a name="ln814">  void Serialize(CompressionScheme compression_scheme, faststring* mesg) const override;</a>
<a name="ln815"> </a>
<a name="ln816"> protected:</a>
<a name="ln817">  virtual void SerializeResultBody(faststring* mesg) const override;</a>
<a name="ln818"> </a>
<a name="ln819"> private:</a>
<a name="ln820">  const std::string change_type_;</a>
<a name="ln821">  const std::string target_;</a>
<a name="ln822">  const std::string keyspace_;</a>
<a name="ln823">  const std::string object_;</a>
<a name="ln824">  const std::vector&lt;std::string&gt; argument_types_;</a>
<a name="ln825">};</a>
<a name="ln826"> </a>
<a name="ln827">//------------------------------------------------------------</a>
<a name="ln828">class EventResponse : public CQLResponse {</a>
<a name="ln829"> public:</a>
<a name="ln830">  virtual std::string ToString() const;</a>
<a name="ln831">  virtual ~EventResponse() override;</a>
<a name="ln832">  virtual size_t ObjectSize() const = 0;</a>
<a name="ln833">  virtual size_t DynamicMemoryUsage() const = 0;</a>
<a name="ln834"> </a>
<a name="ln835"> protected:</a>
<a name="ln836">  explicit EventResponse(const std::string&amp; event_type);</a>
<a name="ln837">  virtual void SerializeBody(faststring* mesg) const override;</a>
<a name="ln838">  virtual void SerializeEventBody(faststring* mesg) const = 0;</a>
<a name="ln839">  virtual std::string BodyToString() const = 0;</a>
<a name="ln840"> private:</a>
<a name="ln841">  const std::string event_type_;</a>
<a name="ln842">};</a>
<a name="ln843"> </a>
<a name="ln844">//------------------------------------------------------------</a>
<a name="ln845">class TopologyChangeEventResponse : public EventResponse {</a>
<a name="ln846"> public:</a>
<a name="ln847">  static constexpr const char* const kMovedNode = &quot;MOVED_NODE&quot;;</a>
<a name="ln848">  static constexpr const char* const kNewNode = &quot;NEW_NODE&quot;;</a>
<a name="ln849">  virtual ~TopologyChangeEventResponse() override;</a>
<a name="ln850">  TopologyChangeEventResponse(const std::string&amp; topology_change_type, const Endpoint&amp; node);</a>
<a name="ln851">  size_t ObjectSize() const override { return sizeof(*this); }</a>
<a name="ln852">  size_t DynamicMemoryUsage() const override { return DynamicMemoryUsageOf(topology_change_type_); }</a>
<a name="ln853"> </a>
<a name="ln854"> protected:</a>
<a name="ln855">  virtual void SerializeEventBody(faststring* mesg) const override;</a>
<a name="ln856">  std::string BodyToString() const override;</a>
<a name="ln857"> </a>
<a name="ln858"> private:</a>
<a name="ln859">  const std::string topology_change_type_;</a>
<a name="ln860">  const Endpoint node_;</a>
<a name="ln861">};</a>
<a name="ln862"> </a>
<a name="ln863">//------------------------------------------------------------</a>
<a name="ln864">class StatusChangeEventResponse : public EventResponse {</a>
<a name="ln865"> public:</a>
<a name="ln866">  virtual ~StatusChangeEventResponse() override;</a>
<a name="ln867">  size_t ObjectSize() const override { return sizeof(*this); }</a>
<a name="ln868">  size_t DynamicMemoryUsage() const override { return DynamicMemoryUsageOf(status_change_type_); }</a>
<a name="ln869"> </a>
<a name="ln870"> protected:</a>
<a name="ln871">  virtual void SerializeEventBody(faststring* mesg) const override;</a>
<a name="ln872">  std::string BodyToString() const override;</a>
<a name="ln873"> </a>
<a name="ln874"> private:</a>
<a name="ln875">  StatusChangeEventResponse(const std::string&amp; status_change_type, const Endpoint&amp; node);</a>
<a name="ln876"> </a>
<a name="ln877">  const std::string status_change_type_;</a>
<a name="ln878">  const Endpoint node_;</a>
<a name="ln879">};</a>
<a name="ln880"> </a>
<a name="ln881">//------------------------------------------------------------</a>
<a name="ln882">class SchemaChangeEventResponse : public EventResponse {</a>
<a name="ln883"> public:</a>
<a name="ln884">  SchemaChangeEventResponse(</a>
<a name="ln885">      const std::string&amp; change_type, const std::string&amp; target,</a>
<a name="ln886">      const std::string&amp; keyspace, const std::string&amp; object = &quot;&quot;,</a>
<a name="ln887">      const std::vector&lt;std::string&gt;&amp; argument_types = kEmptyArgumentTypes);</a>
<a name="ln888">  virtual ~SchemaChangeEventResponse() override;</a>
<a name="ln889">  size_t ObjectSize() const override { return sizeof(*this); }</a>
<a name="ln890">  size_t DynamicMemoryUsage() const override {</a>
<a name="ln891">    return DynamicMemoryUsageOf(change_type_, target_, keyspace_, object_, argument_types_);</a>
<a name="ln892">  }</a>
<a name="ln893"> </a>
<a name="ln894"> protected:</a>
<a name="ln895">  virtual void SerializeEventBody(faststring* mesg) const override;</a>
<a name="ln896">  std::string BodyToString() const override;</a>
<a name="ln897"> </a>
<a name="ln898"> private:</a>
<a name="ln899">  static const std::vector&lt;std::string&gt; kEmptyArgumentTypes;</a>
<a name="ln900"> </a>
<a name="ln901">  const std::string change_type_;</a>
<a name="ln902">  const std::string target_;</a>
<a name="ln903">  const std::string keyspace_;</a>
<a name="ln904">  const std::string object_;</a>
<a name="ln905">  const std::vector&lt;std::string&gt; argument_types_;</a>
<a name="ln906">};</a>
<a name="ln907"> </a>
<a name="ln908">//------------------------------------------------------------</a>
<a name="ln909">class AuthChallengeResponse : public CQLResponse {</a>
<a name="ln910"> public:</a>
<a name="ln911">  AuthChallengeResponse(const CQLRequest&amp; request, const std::string&amp; token);</a>
<a name="ln912">  virtual ~AuthChallengeResponse() override;</a>
<a name="ln913"> </a>
<a name="ln914"> protected:</a>
<a name="ln915">  virtual void SerializeBody(faststring* mesg) const override;</a>
<a name="ln916"> </a>
<a name="ln917"> private:</a>
<a name="ln918"> </a>
<a name="ln919">  const std::string token_;</a>
<a name="ln920">};</a>
<a name="ln921"> </a>
<a name="ln922">//------------------------------------------------------------</a>
<a name="ln923">class AuthSuccessResponse : public CQLResponse {</a>
<a name="ln924"> public:</a>
<a name="ln925">  AuthSuccessResponse(const CQLRequest&amp; request, const std::string&amp; token);</a>
<a name="ln926">  virtual ~AuthSuccessResponse() override;</a>
<a name="ln927"> </a>
<a name="ln928"> protected:</a>
<a name="ln929">  virtual void SerializeBody(faststring* mesg) const override;</a>
<a name="ln930"> </a>
<a name="ln931"> private:</a>
<a name="ln932">  const std::string token_;</a>
<a name="ln933">};</a>
<a name="ln934"> </a>
<a name="ln935">//------------------------------------------------------------</a>
<a name="ln936">class CQLServerEvent : public rpc::ServerEvent {</a>
<a name="ln937"> public:</a>
<a name="ln938">  explicit CQLServerEvent(std::unique_ptr&lt;EventResponse&gt; event_response);</a>
<a name="ln939">  void Serialize(boost::container::small_vector_base&lt;RefCntBuffer&gt;* output) const override;</a>
<a name="ln940">  std::string ToString() const override;</a>
<a name="ln941">  size_t ObjectSize() const { return sizeof(*this); }</a>
<a name="ln942">  size_t DynamicMemoryUsage() const {</a>
<a name="ln943">    return DynamicMemoryUsageOf(event_response_) + DynamicMemoryUsageOf(serialized_response_);</a>
<a name="ln944">  }</a>
<a name="ln945"> </a>
<a name="ln946"> private:</a>
<a name="ln947"> </a>
<a name="ln948">  std::unique_ptr&lt;EventResponse&gt; event_response_;</a>
<a name="ln949">  // Need to keep the serialized response around since we return a reference to it via Slice in</a>
<a name="ln950">  // Serialize().</a>
<a name="ln951">  RefCntBuffer serialized_response_;</a>
<a name="ln952">};</a>
<a name="ln953"> </a>
<a name="ln954">//------------------------------------------------------------</a>
<a name="ln955">class CQLServerEventList : public rpc::ServerEventList {</a>
<a name="ln956"> public:</a>
<a name="ln957">  CQLServerEventList();</a>
<a name="ln958">  void AddEvent(std::unique_ptr&lt;CQLServerEvent&gt; event);</a>
<a name="ln959">  void Serialize(boost::container::small_vector_base&lt;RefCntBuffer&gt;* output) override;</a>
<a name="ln960">  std::string ToString() const override;</a>
<a name="ln961"> </a>
<a name="ln962">  size_t ObjectSize() const override { return sizeof(CQLServerEventList); }</a>
<a name="ln963"> </a>
<a name="ln964">  size_t DynamicMemoryUsage() const override { return DynamicMemoryUsageOf(cql_server_events_); }</a>
<a name="ln965"> </a>
<a name="ln966"> private:</a>
<a name="ln967">  void Transferred(const Status&amp; status, rpc::Connection*) override;</a>
<a name="ln968">  std::vector&lt;std::unique_ptr&lt;CQLServerEvent&gt;&gt; cql_server_events_;</a>
<a name="ln969">};</a>
<a name="ln970"> </a>
<a name="ln971">}  // namespace cqlserver</a>
<a name="ln972">}  // namespace yb</a>
<a name="ln973"> </a>
<a name="ln974">#endif // YB_YQL_CQL_CQLSERVER_CQL_MESSAGE_H_</a>

</code></pre>
<div class="balloon" rel="268"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="280"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
