
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>serialize.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Copyright 2010 Google Inc. All Rights Reserved.</a>
<a name="ln2">// Refactored from contributions of various authors in strings/strutil.h</a>
<a name="ln3">//</a>
<a name="ln4">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln5">//</a>
<a name="ln6">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln7">//</a>
<a name="ln8">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln9">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln10">//</a>
<a name="ln11">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln12">//</a>
<a name="ln13">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln14">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln15">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln16">// under the License.</a>
<a name="ln17">//</a>
<a name="ln18">// This file contains conversion functions from various data types to</a>
<a name="ln19">// strings and back.</a>
<a name="ln20"> </a>
<a name="ln21">#ifndef STRINGS_SERIALIZE_H_</a>
<a name="ln22">#define STRINGS_SERIALIZE_H_</a>
<a name="ln23"> </a>
<a name="ln24">#include &lt;string.h&gt;</a>
<a name="ln25">#include &lt;ext/hash_map&gt;</a>
<a name="ln26">using __gnu_cxx::hash;</a>
<a name="ln27">using __gnu_cxx::hash_map;</a>
<a name="ln28">#include &lt;string&gt;</a>
<a name="ln29">using std::string;</a>
<a name="ln30">#include &lt;utility&gt;</a>
<a name="ln31">using std::make_pair;</a>
<a name="ln32">using std::pair;</a>
<a name="ln33">#include &lt;vector&gt;</a>
<a name="ln34">using std::vector;</a>
<a name="ln35"> </a>
<a name="ln36">#include &lt;glog/logging.h&gt;</a>
<a name="ln37"> </a>
<a name="ln38">#include &quot;yb/gutil/int128.h&quot;</a>
<a name="ln39">#include &quot;yb/gutil/integral_types.h&quot;</a>
<a name="ln40">#include &quot;yb/gutil/logging-inl.h&quot;</a>
<a name="ln41">#include &quot;yb/gutil/type_traits.h&quot;</a>
<a name="ln42">#include &quot;yb/gutil/strings/stringpiece.h&quot;</a>
<a name="ln43">#include &quot;yb/gutil/endian.h&quot;</a>
<a name="ln44">#include &quot;yb/gutil/stl_util.h&quot;</a>
<a name="ln45"> </a>
<a name="ln46">// Converts a 4-byte uint32 to a string such that the string keys sort in</a>
<a name="ln47">// the same order as the original uint32 value.</a>
<a name="ln48">// TODO(user): Rework all reinterpret_casts&lt;&gt; in this file.</a>
<a name="ln49">inline void KeyFromUint32(uint32 u32, string* key) {</a>
<a name="ln50">  uint32 norder = ghtonl(u32);</a>
<a name="ln51">  key-&gt;assign(reinterpret_cast&lt;const char*&gt;(&amp;norder), sizeof(norder));</a>
<a name="ln52">}</a>
<a name="ln53"> </a>
<a name="ln54">// Converts &quot;fp&quot; to an 8-byte string key</a>
<a name="ln55">inline void KeyFromUint64(uint64 fp, string* key) {</a>
<a name="ln56">  uint64 norder = htonll(fp);</a>
<a name="ln57">  key-&gt;assign(reinterpret_cast&lt;const char*&gt;(&amp;norder), sizeof(norder));</a>
<a name="ln58">}</a>
<a name="ln59"> </a>
<a name="ln60">// Converts a 16-byte uint128 to a string such that the string keys sort in</a>
<a name="ln61">// the same order as the original uint128 value.</a>
<a name="ln62">inline void KeyFromUint128(uint128 fp, string* key) {</a>
<a name="ln63">  uint64 norder[] = { htonll(Uint128High64(fp)),</a>
<a name="ln64">                      htonll(Uint128Low64(fp))</a>
<a name="ln65">  };</a>
<a name="ln66">  key-&gt;assign(reinterpret_cast&lt;const char*&gt;(norder), 2 * sizeof(norder[0]));</a>
<a name="ln67">}</a>
<a name="ln68"> </a>
<a name="ln69">// This version of KeyFromUint32 is less efficient but very convenient</a>
<a name="ln70">string Uint32ToKey(uint32 u32);</a>
<a name="ln71"> </a>
<a name="ln72">// This version of KeyFromUint64 is less efficient but very convenient</a>
<a name="ln73">string Uint64ToKey(uint64 fp);</a>
<a name="ln74"> </a>
<a name="ln75">// This version of KeyFromUint128 is less efficient but very convenient</a>
<a name="ln76">string Uint128ToKey(uint128 u128);</a>
<a name="ln77"> </a>
<a name="ln78">// Converts a 4-byte string key (typically generated by KeyFromUint32 or</a>
<a name="ln79">// Uint32ToKey) into a uint32 value.</a>
<a name="ln80">inline uint32 KeyToUint32(const GStringPiece&amp; key) {</a>
<a name="ln81">  uint32 value;</a>
<a name="ln82">  DCHECK_EQ(key.size(), sizeof(value));</a>
<a name="ln83">  memcpy(&amp;value, key.data(), sizeof(value));</a>
<a name="ln84">  return gntohl(value);</a>
<a name="ln85">}</a>
<a name="ln86"> </a>
<a name="ln87">// Converts an 8-byte string key (typically generated by Uint64ToKey or</a>
<a name="ln88">// KeyFromUint64) into a uint64 value</a>
<a name="ln89">inline uint64 KeyToUint64(const GStringPiece&amp; key) {</a>
<a name="ln90">  uint64 value;</a>
<a name="ln91">  DCHECK_EQ(key.size(), sizeof(value));</a>
<a name="ln92">  memcpy(&amp;value, key.data(), sizeof(value));</a>
<a name="ln93">  return ntohll(value);</a>
<a name="ln94">}</a>
<a name="ln95"> </a>
<a name="ln96">// Converts a 16-byte string key (typically generated by Uint128ToKey or</a>
<a name="ln97">// KeyFromUint128) into a uint128 value</a>
<a name="ln98">inline uint128 KeyToUint128(const GStringPiece&amp; key) {</a>
<a name="ln99">  uint64 v0, v1;</a>
<a name="ln100">  DCHECK_EQ(key.size(), sizeof(v0) + sizeof(v1));</a>
<a name="ln101">  memcpy(&amp;v0, key.data(), sizeof(v0));</a>
<a name="ln102">  memcpy(&amp;v1, key.data() + sizeof(v0), sizeof(v1));</a>
<a name="ln103">  return uint128(ntohll(v0), ntohll(v1));</a>
<a name="ln104">}</a>
<a name="ln105"> </a>
<a name="ln106">// Converts &quot;i32&quot; to a 4-byte string key</a>
<a name="ln107">// NOTE: Lexicographic ordering of the resulting strings does not in</a>
<a name="ln108">// general correspond to any natural ordering of the corresponding</a>
<a name="ln109">// integers. For non-negative inputs, lexicographic ordering of the</a>
<a name="ln110">// resulting strings corresponds to increasing ordering of the</a>
<a name="ln111">// integers. However, negative inputs are sorted *after* the non-negative</a>
<a name="ln112">// inputs. To obtain keys such that lexicographic ordering corresponds</a>
<a name="ln113">// to the natural total order on the integers, use OrderedStringFromInt32()</a>
<a name="ln114">// or ReverseOrderedStringFromInt32() instead.</a>
<a name="ln115">void KeyFromInt32(int32 i32, string* key);</a>
<a name="ln116"> </a>
<a name="ln117">// Convenient form of KeyFromInt32.</a>
<a name="ln118">inline string Int32ToKey(int32 i32) {</a>
<a name="ln119">  string s;</a>
<a name="ln120">  KeyFromInt32(i32, &amp;s);</a>
<a name="ln121">  return s;</a>
<a name="ln122">}</a>
<a name="ln123"> </a>
<a name="ln124">// Converts a 4-byte string key (typically generated by KeyFromInt32)</a>
<a name="ln125">// into an int32 value</a>
<a name="ln126">int32 KeyToInt32(const GStringPiece&amp; key);</a>
<a name="ln127"> </a>
<a name="ln128">// Converts a double value to an 8-byte string key, so that</a>
<a name="ln129">// the string keys sort in the same order as the original double values.</a>
<a name="ln130">void KeyFromDouble(double x, string* key);</a>
<a name="ln131"> </a>
<a name="ln132">// Converts key generated by KeyFromDouble() back to double.</a>
<a name="ln133">double KeyToDouble(const GStringPiece&amp; key);</a>
<a name="ln134"> </a>
<a name="ln135">// This version of KeyFromDouble is less efficient but very convenient</a>
<a name="ln136">string DoubleToKey(double x);</a>
<a name="ln137"> </a>
<a name="ln138">// Converts int32 to a 4-byte string key such that lexicographic</a>
<a name="ln139">// ordering of strings is equivalent to sorting in increasing order by</a>
<a name="ln140">// integer values. This can be useful when constructing secondary</a>
<a name="ln141">void OrderedStringFromInt32(int32 i32, string* key);</a>
<a name="ln142"> </a>
<a name="ln143">// This version of OrderedStringFromInt32 is less efficient but very convenient</a>
<a name="ln144">string Int32ToOrderedString(int32 i32);</a>
<a name="ln145"> </a>
<a name="ln146">// The inverse of the above function.</a>
<a name="ln147">int32 OrderedStringToInt32(const GStringPiece&amp; key);</a>
<a name="ln148"> </a>
<a name="ln149">// Converts int64 to an 8-byte string key such that lexicographic</a>
<a name="ln150">// ordering of strings is equivalent to sorting in increasing order by</a>
<a name="ln151">// integer values.</a>
<a name="ln152">void OrderedStringFromInt64(int64 i64, string* key);</a>
<a name="ln153"> </a>
<a name="ln154">// This version of OrderedStringFromInt64 is less efficient but very convenient</a>
<a name="ln155">string Int64ToOrderedString(int64 i64);</a>
<a name="ln156"> </a>
<a name="ln157">// The inverse of the above function.</a>
<a name="ln158">int64 OrderedStringToInt64(const GStringPiece&amp; key);</a>
<a name="ln159"> </a>
<a name="ln160">// Converts int32 to a 4-byte string key such that lexicographic</a>
<a name="ln161">// ordering of strings is equivalent to sorting in decreasing order</a>
<a name="ln162">// by integer values. This can be useful when constructing secondary</a>
<a name="ln163">void ReverseOrderedStringFromInt32(int32 i32, string* key);</a>
<a name="ln164"> </a>
<a name="ln165">// This version of ReverseOrderedStringFromInt32 is less efficient but very</a>
<a name="ln166">string Int32ToReverseOrderedString(int32 i32);</a>
<a name="ln167"> </a>
<a name="ln168">// The inverse of the above function.</a>
<a name="ln169">int32 ReverseOrderedStringToInt32(const GStringPiece&amp; key);</a>
<a name="ln170"> </a>
<a name="ln171">// Converts int64 to an 8-byte string key such that lexicographic</a>
<a name="ln172">// ordering of strings is equivalent to sorting in decreasing order</a>
<a name="ln173">// by integer values. This can be useful when constructing secondary</a>
<a name="ln174">void ReverseOrderedStringFromInt64(int64 i64, string* key);</a>
<a name="ln175"> </a>
<a name="ln176">// This version of ReverseOrderedStringFromInt64 is less efficient but very</a>
<a name="ln177">string Int64ToReverseOrderedString(int64 i64);</a>
<a name="ln178"> </a>
<a name="ln179">// The inverse of the above function.</a>
<a name="ln180">int64 ReverseOrderedStringToInt64(const GStringPiece&amp; key);</a>
<a name="ln181"> </a>
<a name="ln182">// Stores the bytes of a plain old data type value in a C++ string.</a>
<a name="ln183">// Verifies the given data type is a POD and copies the bytes of the</a>
<a name="ln184">// value into a newly created string.</a>
<a name="ln185">//</a>
<a name="ln186">// Can replace the use of Encode*, and avoid the use of castings,</a>
<a name="ln187">// or adding additional functions for each type.</a>
<a name="ln188">// For example, use:</a>
<a name="ln189">//   int32 i = 100;</a>
<a name="ln190">//   string s = EncodePOD(i);</a>
<a name="ln191">// in place of:</a>
<a name="ln192">//   string s = EncodeUint32(static_cast&lt;uint32&gt;(i));</a>
<a name="ln193">template &lt;typename T&gt; inline string EncodePOD(const T&amp; value) {</a>
<a name="ln194">  ENFORCE_POD(T);</a>
<a name="ln195">  string s;</a>
<a name="ln196">  STLStringResizeUninitialized(&amp;s, sizeof(T));</a>
<a name="ln197">  memcpy(string_as_array(&amp;s), &amp;value, sizeof(T));</a>
<a name="ln198">  return s;</a>
<a name="ln199">}</a>
<a name="ln200"> </a>
<a name="ln201">// Retrieves the bytes of a plain old data type value from a GStringPiece.</a>
<a name="ln202">// Verifies the given data type is a POD and copies the bytes of the</a>
<a name="ln203">// value from the given string.</a>
<a name="ln204">// Returns true if the operation succeeded.</a>
<a name="ln205">// Note that other than the data length, no check is (or can be)</a>
<a name="ln206">// done on the type of data stored in the string.</a>
<a name="ln207">//</a>
<a name="ln208">// Can replace the use of Decode*, and avoid the use of castings,</a>
<a name="ln209">// or adding additional functions for each type.</a>
<a name="ln210">// For example, use:</a>
<a name="ln211">//   int32 i = 100;</a>
<a name="ln212">//   int32 j;</a>
<a name="ln213">//   string s = EncodePOD(i);</a>
<a name="ln214">//   CHECK(DecodePOD(s, &amp;j));</a>
<a name="ln215">// in place of:</a>
<a name="ln216">//   string s = EncodeUint32(static_cast&lt;uint32&gt;(i));</a>
<a name="ln217">//   CHECK(DecodesUint32(s, static_cast&lt;uint32*&gt;(&amp;j)));</a>
<a name="ln218">template &lt;typename T&gt; inline bool DecodePOD(const GStringPiece&amp; str, T* result) {</a>
<a name="ln219">  ENFORCE_POD(T);</a>
<a name="ln220">  CHECK(result != NULL);</a>
<a name="ln221">  if (sizeof(*result) != str.size()) {</a>
<a name="ln222">    return false;</a>
<a name="ln223">  }</a>
<a name="ln224">  memcpy(result, str.data(), sizeof(T));</a>
<a name="ln225">  return true;</a>
<a name="ln226">}</a>
<a name="ln227"> </a>
<a name="ln228">// Stores the value bytes of a vector of plain old data type in a C++ string.</a>
<a name="ln229">// Verifies the given data type is a POD and copies the bytes of each value</a>
<a name="ln230">// in the vector into a newly created string.</a>
<a name="ln231">template &lt;typename T&gt; inline string EncodeVectorPOD(const vector&lt;T&gt;&amp; vec) {</a>
<a name="ln232">  ENFORCE_POD(T);</a>
<a name="ln233">  string s;</a>
<a name="ln234">  STLStringResizeUninitialized(&amp;s, vec.size() * sizeof(T));</a>
<a name="ln235">  typename vector&lt;T&gt;::const_iterator iter;</a>
<a name="ln236">  char* ptr;</a>
<a name="ln237">  for (iter = vec.begin(), ptr = string_as_array(&amp;s);</a>
<a name="ln238">       iter != vec.end();</a>
<a name="ln239">       ++iter, ptr += sizeof(T)) {</a>
<a name="ln240">    memcpy(ptr, &amp;(*iter), sizeof(T));</a>
<a name="ln241">  }</a>
<a name="ln242">  return s;</a>
<a name="ln243">}</a>
<a name="ln244"> </a>
<a name="ln245">// Reconstructs a vector of a plain old data type values from a C++ string.</a>
<a name="ln246">// Verifies the given data type is a POD and copies the bytes of each value</a>
<a name="ln247">// from the given string to the given vector.</a>
<a name="ln248">// Returns true if the operation succeeded.</a>
<a name="ln249">// Note that other than the data length, no check is (or can be)</a>
<a name="ln250">// done on the type of data stored in the string.</a>
<a name="ln251">template &lt;typename T&gt; inline bool DecodeVectorPOD(const string&amp; str,</a>
<a name="ln252">                                                  vector&lt;T&gt;* result) {</a>
<a name="ln253">  ENFORCE_POD(T);</a>
<a name="ln254">  CHECK(result != NULL);</a>
<a name="ln255">  if (str.size() % sizeof(T) != 0)</a>
<a name="ln256">    return false;</a>
<a name="ln257">  result-&gt;clear();</a>
<a name="ln258">  result-&gt;reserve(str.size() / sizeof(T));</a>
<a name="ln259">  T value;</a>
<a name="ln260">  const char* begin = str.data();</a>
<a name="ln261">  const char* end = str.data() + str.size();</a>
<a name="ln262">  for (const char* ptr = begin; ptr != end; ptr += sizeof(T)) {</a>
<a name="ln263">    memcpy(&amp;value, ptr, sizeof(T));</a>
<a name="ln264">    result-&gt;push_back(value);</a>
<a name="ln265">  }</a>
<a name="ln266">  return true;</a>
<a name="ln267">}</a>
<a name="ln268"> </a>
<a name="ln269">// ----------------------------------------------------------------------</a>
<a name="ln270">// EncodeDouble()</a>
<a name="ln271">// EncodeFloat()</a>
<a name="ln272">// EncodeUint32()</a>
<a name="ln273">// EncodeUint64()</a>
<a name="ln274">// DecodeDouble()</a>
<a name="ln275">// DecodeFloat()</a>
<a name="ln276">// DecodeUint32()</a>
<a name="ln277">// DecodeUint64()</a>
<a name="ln278">//    The Encode* functions store the bytes of ints, floats or doubles into the</a>
<a name="ln279">//    data bytes of a C++ string.  The Decode* functions perform the reverse</a>
<a name="ln280">//    operations, but operate on a GStringPiece rather than directly on a C++</a>
<a name="ln281">//    string.  They return true iff s contained the right number of bytes.</a>
<a name="ln282">//</a>
<a name="ln283">//    These may be preferred to naked calls to EncodePOD/DecodePOD since</a>
<a name="ln284">//    they make the payload type explicit.</a>
<a name="ln285">//    Note that these encodings are NOT endian-neutral.</a>
<a name="ln286">// ----------------------------------------------------------------------</a>
<a name="ln287">inline string EncodeDouble(double d) {</a>
<a name="ln288">  return EncodePOD(d);</a>
<a name="ln289">}</a>
<a name="ln290"> </a>
<a name="ln291">inline string EncodeFloat(float f) {</a>
<a name="ln292">  return EncodePOD(f);</a>
<a name="ln293">}</a>
<a name="ln294"> </a>
<a name="ln295">inline string EncodeUint32(uint32 i) {</a>
<a name="ln296">  return EncodePOD(i);</a>
<a name="ln297">}</a>
<a name="ln298"> </a>
<a name="ln299">inline string EncodeUint64(uint64 i) {</a>
<a name="ln300">  return EncodePOD(i);</a>
<a name="ln301">}</a>
<a name="ln302"> </a>
<a name="ln303">inline bool DecodeDouble(const GStringPiece&amp; s, double* d) {</a>
<a name="ln304">  return DecodePOD(s, d);</a>
<a name="ln305">}</a>
<a name="ln306"> </a>
<a name="ln307">inline bool DecodeFloat(const GStringPiece&amp; s, float* f) {</a>
<a name="ln308">  return DecodePOD(s, f);</a>
<a name="ln309">}</a>
<a name="ln310"> </a>
<a name="ln311">inline bool DecodeUint32(const GStringPiece&amp; s, uint32* i) {</a>
<a name="ln312">  return DecodePOD(s, i);</a>
<a name="ln313">}</a>
<a name="ln314"> </a>
<a name="ln315">inline bool DecodeUint64(const GStringPiece&amp; s, uint64* i) {</a>
<a name="ln316">  return DecodePOD(s, i);</a>
<a name="ln317">}</a>
<a name="ln318"> </a>
<a name="ln319">// -------------------------------------------------------------------------</a>
<a name="ln320">// DictionaryParse</a>
<a name="ln321">//   This routine parses a common dictionary format (key and value separated</a>
<a name="ln322">//   by ':', entries separated by commas). This format is used for many</a>
<a name="ln323">//   complex commandline flags. It is also used to encode dictionaries for</a>
<a name="ln324">//   exporting them or writing them to a checkpoint. Returns a vector of</a>
<a name="ln325">//   &lt;key, value&gt; pairs. Returns true if there if no error in parsing, false</a>
<a name="ln326">//    otherwise.</a>
<a name="ln327">// -------------------------------------------------------------------------</a>
<a name="ln328">bool DictionaryParse(const string&amp; encoded_str,</a>
<a name="ln329">                      vector&lt;pair&lt;string, string&gt; &gt;* items);</a>
<a name="ln330"> </a>
<a name="ln331">// --------------------------------------------------------------------------</a>
<a name="ln332">// DictionaryInt32Encode</a>
<a name="ln333">// DictionaryInt64Encode</a>
<a name="ln334">// DictionaryDoubleEncode</a>
<a name="ln335">// DictionaryInt32Decode</a>
<a name="ln336">// DictionaryInt64Decode</a>
<a name="ln337">// DictionaryDoubleDecode</a>
<a name="ln338">//   Routines to serialize/unserialize simple dictionaries</a>
<a name="ln339">//   (string-&gt;T hashmaps). These are useful for exporting, checkpointing etc</a>
<a name="ln340">//   *Decode routines clear the input dictionary. They return true if there</a>
<a name="ln341">//   was no error in decoding, false otherwise.</a>
<a name="ln342">//   Note: these routines are not meant for use with very large dictionaries.</a>
<a name="ln343">//   They are written for convenience and not efficiency.</a>
<a name="ln344">// --------------------------------------------------------------------------</a>
<a name="ln345">string DictionaryInt32Encode(const hash_map&lt;string, int32&gt;* dictionary);</a>
<a name="ln346">string DictionaryInt64Encode(const hash_map&lt;string, int64&gt;* dictionary);</a>
<a name="ln347">string DictionaryDoubleEncode(const hash_map&lt;string, double&gt;* dictionary);</a>
<a name="ln348"> </a>
<a name="ln349">bool DictionaryInt32Decode(hash_map&lt;string, int32&gt;* dictionary,</a>
<a name="ln350">                           const string&amp; encoded_str);</a>
<a name="ln351">bool DictionaryInt64Decode(hash_map&lt;string, int64&gt;* dictionary,</a>
<a name="ln352">                           const string&amp; encoded_str);</a>
<a name="ln353">bool DictionaryDoubleDecode(hash_map&lt;string, double&gt;* dictionary,</a>
<a name="ln354">                            const string&amp; encoded_str);</a>
<a name="ln355"> </a>
<a name="ln356"> </a>
<a name="ln357">#endif  // STRINGS_SERIALIZE_H_</a>

</code></pre>
<div class="balloon" rel="220"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="224"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1004/" target="_blank">V1004</a> The 'result' pointer was used unsafely after it was verified against nullptr. Check lines: 220, 224.</p></div>
<div class="balloon" rel="254"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="257"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1004/" target="_blank">V1004</a> The 'result' pointer was used unsafely after it was verified against nullptr. Check lines: 254, 257.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
