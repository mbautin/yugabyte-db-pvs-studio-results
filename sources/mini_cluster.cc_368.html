
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>mini_cluster.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Licensed to the Apache Software Foundation (ASF) under one</a>
<a name="ln2">// or more contributor license agreements.  See the NOTICE file</a>
<a name="ln3">// distributed with this work for additional information</a>
<a name="ln4">// regarding copyright ownership.  The ASF licenses this file</a>
<a name="ln5">// to you under the Apache License, Version 2.0 (the</a>
<a name="ln6">// &quot;License&quot;); you may not use this file except in compliance</a>
<a name="ln7">// with the License.  You may obtain a copy of the License at</a>
<a name="ln8">//</a>
<a name="ln9">//   http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln10">//</a>
<a name="ln11">// Unless required by applicable law or agreed to in writing,</a>
<a name="ln12">// software distributed under the License is distributed on an</a>
<a name="ln13">// &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</a>
<a name="ln14">// KIND, either express or implied.  See the License for the</a>
<a name="ln15">// specific language governing permissions and limitations</a>
<a name="ln16">// under the License.</a>
<a name="ln17">//</a>
<a name="ln18">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln19">//</a>
<a name="ln20">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln21">//</a>
<a name="ln22">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln23">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln24">//</a>
<a name="ln25">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln26">//</a>
<a name="ln27">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln28">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln29">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln30">// under the License.</a>
<a name="ln31">//</a>
<a name="ln32"> </a>
<a name="ln33">#include &quot;yb/integration-tests/mini_cluster.h&quot;</a>
<a name="ln34"> </a>
<a name="ln35">#include &lt;algorithm&gt;</a>
<a name="ln36"> </a>
<a name="ln37">#include &quot;yb/client/client.h&quot;</a>
<a name="ln38"> </a>
<a name="ln39">#include &quot;yb/consensus/consensus.h&quot;</a>
<a name="ln40"> </a>
<a name="ln41">#include &quot;yb/gutil/strings/join.h&quot;</a>
<a name="ln42">#include &quot;yb/gutil/strings/substitute.h&quot;</a>
<a name="ln43">#include &quot;yb/master/catalog_manager.h&quot;</a>
<a name="ln44">#include &quot;yb/master/master.h&quot;</a>
<a name="ln45">#include &quot;yb/master/mini_master.h&quot;</a>
<a name="ln46">#include &quot;yb/master/ts_descriptor.h&quot;</a>
<a name="ln47">#include &quot;yb/master/ts_manager.h&quot;</a>
<a name="ln48"> </a>
<a name="ln49">#include &quot;yb/rocksdb/db/db_impl.h&quot;</a>
<a name="ln50"> </a>
<a name="ln51">#include &quot;yb/rpc/messenger.h&quot;</a>
<a name="ln52">#include &quot;yb/server/hybrid_clock.h&quot;</a>
<a name="ln53"> </a>
<a name="ln54">#include &quot;yb/tablet/tablet_peer.h&quot;</a>
<a name="ln55"> </a>
<a name="ln56">#include &quot;yb/tserver/mini_tablet_server.h&quot;</a>
<a name="ln57">#include &quot;yb/tserver/tablet_server.h&quot;</a>
<a name="ln58">#include &quot;yb/tserver/ts_tablet_manager.h&quot;</a>
<a name="ln59"> </a>
<a name="ln60">#include &quot;yb/util/path_util.h&quot;</a>
<a name="ln61">#include &quot;yb/util/random_util.h&quot;</a>
<a name="ln62">#include &quot;yb/util/scope_exit.h&quot;</a>
<a name="ln63">#include &quot;yb/util/status.h&quot;</a>
<a name="ln64">#include &quot;yb/util/stopwatch.h&quot;</a>
<a name="ln65">#include &quot;yb/util/test_util.h&quot;</a>
<a name="ln66"> </a>
<a name="ln67">using namespace std::literals;</a>
<a name="ln68">using strings::Substitute;</a>
<a name="ln69"> </a>
<a name="ln70">DEFINE_string(mini_cluster_base_dir, &quot;&quot;, &quot;Directory for master/ts data&quot;);</a>
<a name="ln71">DEFINE_bool(mini_cluster_reuse_data, false, &quot;Reuse data of mini cluster&quot;);</a>
<a name="ln72">DECLARE_int32(master_svc_num_threads);</a>
<a name="ln73">DECLARE_int32(memstore_size_mb);</a>
<a name="ln74">DECLARE_int32(master_consensus_svc_num_threads);</a>
<a name="ln75">DECLARE_int32(master_remote_bootstrap_svc_num_threads);</a>
<a name="ln76">DECLARE_int32(generic_svc_num_threads);</a>
<a name="ln77">DECLARE_int32(tablet_server_svc_num_threads);</a>
<a name="ln78">DECLARE_int32(ts_admin_svc_num_threads);</a>
<a name="ln79">DECLARE_int32(ts_consensus_svc_num_threads);</a>
<a name="ln80">DECLARE_int32(ts_remote_bootstrap_svc_num_threads);</a>
<a name="ln81">DECLARE_int32(replication_factor);</a>
<a name="ln82">DECLARE_string(use_private_ip);</a>
<a name="ln83">DECLARE_int32(load_balancer_initial_delay_secs);</a>
<a name="ln84"> </a>
<a name="ln85">namespace yb {</a>
<a name="ln86"> </a>
<a name="ln87">using client::YBClient;</a>
<a name="ln88">using client::YBClientBuilder;</a>
<a name="ln89">using master::CatalogManager;</a>
<a name="ln90">using master::MiniMaster;</a>
<a name="ln91">using master::TabletLocationsPB;</a>
<a name="ln92">using master::TSDescriptor;</a>
<a name="ln93">using std::shared_ptr;</a>
<a name="ln94">using std::string;</a>
<a name="ln95">using std::vector;</a>
<a name="ln96">using tserver::MiniTabletServer;</a>
<a name="ln97">using tserver::TabletServer;</a>
<a name="ln98"> </a>
<a name="ln99">namespace {</a>
<a name="ln100"> </a>
<a name="ln101">const std::vector&lt;uint16_t&gt; EMPTY_MASTER_RPC_PORTS = {};</a>
<a name="ln102">const int kMasterLeaderElectionWaitTimeSeconds = NonTsanVsTsan(20, 60);</a>
<a name="ln103"> </a>
<a name="ln104">std::string GetClusterDataDirName(const MiniClusterOptions&amp; options) {</a>
<a name="ln105">  std::string cluster_name = &quot;minicluster-data&quot;;</a>
<a name="ln106">  if (options.cluster_id == &quot;&quot;) {</a>
<a name="ln107">    return cluster_name;</a>
<a name="ln108">  }</a>
<a name="ln109">  return Format(&quot;$0-$1&quot;, cluster_name, options.cluster_id);</a>
<a name="ln110">}</a>
<a name="ln111"> </a>
<a name="ln112">std::string GetFsRoot(const MiniClusterOptions&amp; options) {</a>
<a name="ln113">  if (!options.data_root.empty()) {</a>
<a name="ln114">    return options.data_root;</a>
<a name="ln115">  }</a>
<a name="ln116">  if (!FLAGS_mini_cluster_base_dir.empty()) {</a>
<a name="ln117">    return FLAGS_mini_cluster_base_dir;</a>
<a name="ln118">  }</a>
<a name="ln119">  return JoinPathSegments(GetTestDataDirectory(), GetClusterDataDirName(options));</a>
<a name="ln120">}</a>
<a name="ln121"> </a>
<a name="ln122">} // namespace</a>
<a name="ln123"> </a>
<a name="ln124">MiniClusterOptions::MiniClusterOptions()</a>
<a name="ln125">    : num_masters(1),</a>
<a name="ln126">      num_tablet_servers(1) {</a>
<a name="ln127">}</a>
<a name="ln128"> </a>
<a name="ln129">MiniCluster::MiniCluster(Env* env, const MiniClusterOptions&amp; options)</a>
<a name="ln130">    : env_(env),</a>
<a name="ln131">      fs_root_(GetFsRoot(options)),</a>
<a name="ln132">      num_masters_initial_(options.num_masters),</a>
<a name="ln133">      num_ts_initial_(options.num_tablet_servers) {</a>
<a name="ln134">  mini_masters_.resize(num_masters_initial_);</a>
<a name="ln135">}</a>
<a name="ln136"> </a>
<a name="ln137">MiniCluster::~MiniCluster() {</a>
<a name="ln138">  Shutdown();</a>
<a name="ln139">}</a>
<a name="ln140"> </a>
<a name="ln141">Status MiniCluster::Start(const std::vector&lt;tserver::TabletServerOptions&gt;&amp; extra_tserver_options) {</a>
<a name="ln142">  CHECK(!fs_root_.empty()) &lt;&lt; &quot;No Fs root was provided&quot;;</a>
<a name="ln143">  CHECK(!running_);</a>
<a name="ln144"> </a>
<a name="ln145">  EnsurePortsAllocated();</a>
<a name="ln146"> </a>
<a name="ln147">  if (!env_-&gt;FileExists(fs_root_)) {</a>
<a name="ln148">    RETURN_NOT_OK(env_-&gt;CreateDir(fs_root_));</a>
<a name="ln149">  }</a>
<a name="ln150"> </a>
<a name="ln151">  // TODO: properly handle setting these variables in case of multiple MiniClusters in the same</a>
<a name="ln152">  // process.</a>
<a name="ln153"> </a>
<a name="ln154">  // Use conservative number of threads for the mini cluster for unit test env</a>
<a name="ln155">  // where several unit tests tend to run in parallel.</a>
<a name="ln156">  // To get default number of threads - try to find SERVICE_POOL_OPTIONS macro usage.</a>
<a name="ln157">  FLAGS_master_svc_num_threads = 2;</a>
<a name="ln158">  FLAGS_master_consensus_svc_num_threads = 2;</a>
<a name="ln159">  FLAGS_master_remote_bootstrap_svc_num_threads = 2;</a>
<a name="ln160">  FLAGS_generic_svc_num_threads = 2;</a>
<a name="ln161"> </a>
<a name="ln162">  FLAGS_tablet_server_svc_num_threads = 8;</a>
<a name="ln163">  FLAGS_ts_admin_svc_num_threads = 2;</a>
<a name="ln164">  FLAGS_ts_consensus_svc_num_threads = 8;</a>
<a name="ln165">  FLAGS_ts_remote_bootstrap_svc_num_threads = 2;</a>
<a name="ln166"> </a>
<a name="ln167">  // We are testing public/private IPs using mini cluster. So set mode to 'cloud'.</a>
<a name="ln168">  FLAGS_use_private_ip = &quot;cloud&quot;;</a>
<a name="ln169"> </a>
<a name="ln170">  // This dictates the RF of newly created tables.</a>
<a name="ln171">  SetAtomicFlag(num_ts_initial_ &gt;= 3 ? 3 : 1, &amp;FLAGS_replication_factor);</a>
<a name="ln172">  FLAGS_memstore_size_mb = 16;</a>
<a name="ln173">  // Default master args to make sure we don't wait to trigger new LB tasks upon master leader</a>
<a name="ln174">  // failover.</a>
<a name="ln175">  FLAGS_load_balancer_initial_delay_secs = 0;</a>
<a name="ln176"> </a>
<a name="ln177">  // start the masters</a>
<a name="ln178">  RETURN_NOT_OK_PREPEND(StartMasters(),</a>
<a name="ln179">                        &quot;Couldn't start distributed masters&quot;);</a>
<a name="ln180"> </a>
<a name="ln181">  if (!extra_tserver_options.empty() &amp;&amp; extra_tserver_options.size() != num_ts_initial_) {</a>
<a name="ln182">    return STATUS_SUBSTITUTE(InvalidArgument, &quot;num tserver options: $0 doesn't match with num &quot;</a>
<a name="ln183">        &quot;tservers: $1&quot;, extra_tserver_options.size(), num_ts_initial_);</a>
<a name="ln184">  }</a>
<a name="ln185"> </a>
<a name="ln186">  for (int i = 0; i &lt; num_ts_initial_; i++) {</a>
<a name="ln187">    if (!extra_tserver_options.empty()) {</a>
<a name="ln188">      RETURN_NOT_OK_PREPEND(AddTabletServer(extra_tserver_options[i]),</a>
<a name="ln189">                            Substitute(&quot;Error adding TS $0&quot;, i));</a>
<a name="ln190">    } else {</a>
<a name="ln191">      RETURN_NOT_OK_PREPEND(AddTabletServer(),</a>
<a name="ln192">                            Substitute(&quot;Error adding TS $0&quot;, i));</a>
<a name="ln193">    }</a>
<a name="ln194"> </a>
<a name="ln195">  }</a>
<a name="ln196"> </a>
<a name="ln197">  RETURN_NOT_OK_PREPEND(WaitForTabletServerCount(num_ts_initial_),</a>
<a name="ln198">                        &quot;Waiting for tablet servers to start&quot;);</a>
<a name="ln199"> </a>
<a name="ln200">  running_ = true;</a>
<a name="ln201">  return Status::OK();</a>
<a name="ln202">}</a>
<a name="ln203"> </a>
<a name="ln204">Status MiniCluster::StartMasters() {</a>
<a name="ln205">  CHECK_GE(master_rpc_ports_.size(), num_masters_initial_);</a>
<a name="ln206">  EnsurePortsAllocated();</a>
<a name="ln207"> </a>
<a name="ln208">  LOG(INFO) &lt;&lt; &quot;Creating distributed mini masters. RPC ports: &quot;</a>
<a name="ln209">            &lt;&lt; JoinInts(master_rpc_ports_, &quot;, &quot;);</a>
<a name="ln210"> </a>
<a name="ln211">  if (mini_masters_.size() &lt; num_masters_initial_) {</a>
<a name="ln212">    mini_masters_.resize(num_masters_initial_);</a>
<a name="ln213">  }</a>
<a name="ln214"> </a>
<a name="ln215">  bool started = false;</a>
<a name="ln216">  auto se = ScopeExit([this, &amp;started] {</a>
<a name="ln217">    if (!started) {</a>
<a name="ln218">      for (const auto&amp; master : mini_masters_) {</a>
<a name="ln219">        if (master) {</a>
<a name="ln220">          master-&gt;Shutdown();</a>
<a name="ln221">        }</a>
<a name="ln222">      }</a>
<a name="ln223">    }</a>
<a name="ln224">  });</a>
<a name="ln225"> </a>
<a name="ln226">  for (int i = 0; i &lt; num_masters_initial_; i++) {</a>
<a name="ln227">    mini_masters_[i] = std::make_shared&lt;MiniMaster&gt;(</a>
<a name="ln228">        env_, GetMasterFsRoot(i), master_rpc_ports_[i], master_web_ports_[i], i);</a>
<a name="ln229">    auto status = mini_masters_[i]-&gt;StartDistributedMaster(master_rpc_ports_);</a>
<a name="ln230">    LOG_IF(INFO, !status.ok()) &lt;&lt; &quot;Failed to start master: &quot; &lt;&lt; status;</a>
<a name="ln231">    RETURN_NOT_OK_PREPEND(status, Substitute(&quot;Couldn't start follower $0&quot;, i));</a>
<a name="ln232">    VLOG(1) &lt;&lt; &quot;Started MiniMaster with UUID &quot; &lt;&lt; mini_masters_[i]-&gt;permanent_uuid()</a>
<a name="ln233">            &lt;&lt; &quot; at index &quot; &lt;&lt; i;</a>
<a name="ln234">  }</a>
<a name="ln235">  int i = 0;</a>
<a name="ln236">  for (const shared_ptr&lt;MiniMaster&gt;&amp; master : mini_masters_) {</a>
<a name="ln237">    LOG(INFO) &lt;&lt; &quot;Waiting to initialize catalog manager on master &quot; &lt;&lt; i++;</a>
<a name="ln238">    RETURN_NOT_OK_PREPEND(master-&gt;WaitForCatalogManagerInit(),</a>
<a name="ln239">                          Substitute(&quot;Could not initialize catalog manager on master $0&quot;, i));</a>
<a name="ln240">  }</a>
<a name="ln241">  started = true;</a>
<a name="ln242">  return Status::OK();</a>
<a name="ln243">}</a>
<a name="ln244"> </a>
<a name="ln245">Status MiniCluster::StartSync() {</a>
<a name="ln246">  RETURN_NOT_OK(Start());</a>
<a name="ln247">  int count = 0;</a>
<a name="ln248">  for (const shared_ptr&lt;MiniTabletServer&gt;&amp; tablet_server : mini_tablet_servers_) {</a>
<a name="ln249">    RETURN_NOT_OK_PREPEND(tablet_server-&gt;WaitStarted(),</a>
<a name="ln250">                          Substitute(&quot;TabletServer $0 failed to start.&quot;, count));</a>
<a name="ln251">    count++;</a>
<a name="ln252">  }</a>
<a name="ln253">  return Status::OK();</a>
<a name="ln254">}</a>
<a name="ln255"> </a>
<a name="ln256">Status MiniCluster::RestartSync() {</a>
<a name="ln257">  LOG(INFO) &lt;&lt; string(80, '-');</a>
<a name="ln258">  LOG(INFO) &lt;&lt; __FUNCTION__;</a>
<a name="ln259">  LOG(INFO) &lt;&lt; string(80, '-');</a>
<a name="ln260"> </a>
<a name="ln261">  LOG(INFO) &lt;&lt; &quot;Restart tablet server(s)...&quot;;</a>
<a name="ln262">  for (auto&amp; tablet_server : mini_tablet_servers_) {</a>
<a name="ln263">    CHECK_OK(tablet_server-&gt;Restart());</a>
<a name="ln264">    CHECK_OK(tablet_server-&gt;WaitStarted());</a>
<a name="ln265">  }</a>
<a name="ln266">  LOG(INFO) &lt;&lt; &quot;Restart master server(s)...&quot;;</a>
<a name="ln267">  for (auto&amp; master_server : mini_masters_) {</a>
<a name="ln268">    CHECK_OK(master_server-&gt;Restart());</a>
<a name="ln269">    CHECK_OK(master_server-&gt;WaitForCatalogManagerInit());</a>
<a name="ln270">  }</a>
<a name="ln271"> </a>
<a name="ln272">  RETURN_NOT_OK_PREPEND(WaitForAllTabletServers(),</a>
<a name="ln273">                        &quot;Waiting for tablet servers to start&quot;);</a>
<a name="ln274">  running_ = true;</a>
<a name="ln275">  return Status::OK();</a>
<a name="ln276">}</a>
<a name="ln277"> </a>
<a name="ln278">Status MiniCluster::AddTabletServer(const tserver::TabletServerOptions&amp; extra_opts) {</a>
<a name="ln279">  if (mini_masters_.empty()) {</a>
<a name="ln280">    return STATUS(IllegalState, &quot;Master not yet initialized&quot;);</a>
<a name="ln281">  }</a>
<a name="ln282">  int new_idx = mini_tablet_servers_.size();</a>
<a name="ln283"> </a>
<a name="ln284">  EnsurePortsAllocated(0 /* num_masters (will pick default) */, new_idx + 1);</a>
<a name="ln285">  const uint16_t ts_rpc_port = tserver_rpc_ports_[new_idx];</a>
<a name="ln286">  gscoped_ptr&lt;MiniTabletServer&gt; tablet_server(</a>
<a name="ln287">    new MiniTabletServer(GetTabletServerFsRoot(new_idx), ts_rpc_port, extra_opts, new_idx));</a>
<a name="ln288"> </a>
<a name="ln289">  // set the master addresses</a>
<a name="ln290">  auto master_addr = std::make_shared&lt;server::MasterAddresses&gt;();</a>
<a name="ln291">  for (const shared_ptr&lt;MiniMaster&gt;&amp; master : mini_masters_) {</a>
<a name="ln292">    master_addr-&gt;push_back({HostPort(master-&gt;bound_rpc_addr())});</a>
<a name="ln293">    for (const auto&amp; hp : master-&gt;master()-&gt;opts().broadcast_addresses) {</a>
<a name="ln294">      master_addr-&gt;back().push_back(hp);</a>
<a name="ln295">    }</a>
<a name="ln296">  }</a>
<a name="ln297"> </a>
<a name="ln298">  tablet_server-&gt;options()-&gt;master_addresses_flag = server::MasterAddressesToString(*master_addr);</a>
<a name="ln299">  tablet_server-&gt;options()-&gt;SetMasterAddresses(master_addr);</a>
<a name="ln300">  tablet_server-&gt;options()-&gt;webserver_opts.port = tserver_web_ports_[new_idx];</a>
<a name="ln301">  RETURN_NOT_OK(tablet_server-&gt;Start());</a>
<a name="ln302">  mini_tablet_servers_.push_back(shared_ptr&lt;MiniTabletServer&gt;(tablet_server.release()));</a>
<a name="ln303">  return Status::OK();</a>
<a name="ln304">}</a>
<a name="ln305"> </a>
<a name="ln306">Status MiniCluster::AddTabletServer() {</a>
<a name="ln307">  auto options = tserver::TabletServerOptions::CreateTabletServerOptions();</a>
<a name="ln308">  RETURN_NOT_OK(options);</a>
<a name="ln309">  return AddTabletServer(*options);</a>
<a name="ln310">}</a>
<a name="ln311"> </a>
<a name="ln312">string MiniCluster::GetMasterAddresses() const {</a>
<a name="ln313">  string peer_addrs = &quot;&quot;;</a>
<a name="ln314">  for (const auto&amp; master : mini_masters_) {</a>
<a name="ln315">    if (!peer_addrs.empty()) {</a>
<a name="ln316">      peer_addrs += &quot;,&quot;;</a>
<a name="ln317">    }</a>
<a name="ln318">    peer_addrs += master-&gt;bound_rpc_addr_str();</a>
<a name="ln319">  }</a>
<a name="ln320">  return peer_addrs;</a>
<a name="ln321">}</a>
<a name="ln322"> </a>
<a name="ln323">int MiniCluster::LeaderMasterIdx() {</a>
<a name="ln324">  Stopwatch sw;</a>
<a name="ln325">  sw.start();</a>
<a name="ln326">  while (sw.elapsed().wall_seconds() &lt; kMasterLeaderElectionWaitTimeSeconds) {</a>
<a name="ln327">    for (int i = 0; i &lt; mini_masters_.size(); i++) {</a>
<a name="ln328">      MiniMaster* master = mini_master(i);</a>
<a name="ln329">      if (master-&gt;master() == nullptr || master-&gt;master()-&gt;IsShutdown()) {</a>
<a name="ln330">        continue;</a>
<a name="ln331">      }</a>
<a name="ln332">      CatalogManager::ScopedLeaderSharedLock l(master-&gt;master()-&gt;catalog_manager());</a>
<a name="ln333">      if (l.catalog_status().ok() &amp;&amp; l.leader_status().ok()) {</a>
<a name="ln334">        return i;</a>
<a name="ln335">      }</a>
<a name="ln336">    }</a>
<a name="ln337">    SleepFor(MonoDelta::FromMilliseconds(1));</a>
<a name="ln338">  }</a>
<a name="ln339">  LOG(ERROR) &lt;&lt; &quot;No leader master elected after &quot; &lt;&lt; kMasterLeaderElectionWaitTimeSeconds</a>
<a name="ln340">             &lt;&lt; &quot; seconds.&quot;;</a>
<a name="ln341">  return -1;</a>
<a name="ln342">}</a>
<a name="ln343"> </a>
<a name="ln344">MiniMaster* MiniCluster::leader_mini_master() {</a>
<a name="ln345">  auto idx = LeaderMasterIdx();</a>
<a name="ln346">  return idx != -1 ? mini_master(idx) : nullptr;</a>
<a name="ln347">}</a>
<a name="ln348"> </a>
<a name="ln349">void MiniCluster::Shutdown() {</a>
<a name="ln350">  if (!running_)</a>
<a name="ln351">    return;</a>
<a name="ln352"> </a>
<a name="ln353">  for (const shared_ptr&lt;MiniTabletServer&gt;&amp; tablet_server : mini_tablet_servers_) {</a>
<a name="ln354">    tablet_server-&gt;Shutdown();</a>
<a name="ln355">  }</a>
<a name="ln356">  mini_tablet_servers_.clear();</a>
<a name="ln357"> </a>
<a name="ln358">  for (shared_ptr&lt;MiniMaster&gt;&amp; master_server : mini_masters_) {</a>
<a name="ln359">    master_server-&gt;Shutdown();</a>
<a name="ln360">    master_server.reset();</a>
<a name="ln361">  }</a>
<a name="ln362">  mini_masters_.clear();</a>
<a name="ln363"> </a>
<a name="ln364">  running_ = false;</a>
<a name="ln365">}</a>
<a name="ln366"> </a>
<a name="ln367">Status MiniCluster::FlushTablets(tablet::FlushMode mode, tablet::FlushFlags flags) {</a>
<a name="ln368">  for (const auto&amp; tablet_server : mini_tablet_servers_) {</a>
<a name="ln369">    RETURN_NOT_OK(tablet_server-&gt;FlushTablets(mode, flags));</a>
<a name="ln370">  }</a>
<a name="ln371">  return Status::OK();</a>
<a name="ln372">}</a>
<a name="ln373"> </a>
<a name="ln374">Status MiniCluster::CompactTablets() {</a>
<a name="ln375">  for (const auto&amp; tablet_server : mini_tablet_servers_) {</a>
<a name="ln376">    RETURN_NOT_OK(tablet_server-&gt;CompactTablets());</a>
<a name="ln377">  }</a>
<a name="ln378">  return Status::OK();</a>
<a name="ln379">}</a>
<a name="ln380"> </a>
<a name="ln381">Status MiniCluster::SwitchMemtables() {</a>
<a name="ln382">  for (const auto&amp; tablet_server : mini_tablet_servers_) {</a>
<a name="ln383">    RETURN_NOT_OK(tablet_server-&gt;SwitchMemtables());</a>
<a name="ln384">  }</a>
<a name="ln385">  return Status::OK();</a>
<a name="ln386">}</a>
<a name="ln387"> </a>
<a name="ln388">Status MiniCluster::CleanTabletLogs() {</a>
<a name="ln389">  for (const auto&amp; tablet_server : mini_tablet_servers_) {</a>
<a name="ln390">    RETURN_NOT_OK(tablet_server-&gt;CleanTabletLogs());</a>
<a name="ln391">  }</a>
<a name="ln392">  return Status::OK();</a>
<a name="ln393">}</a>
<a name="ln394"> </a>
<a name="ln395">void MiniCluster::ShutdownMasters() {</a>
<a name="ln396">  for (shared_ptr&lt;MiniMaster&gt;&amp; master_server : mini_masters_) {</a>
<a name="ln397">    master_server-&gt;Shutdown();</a>
<a name="ln398">    master_server.reset();</a>
<a name="ln399">  }</a>
<a name="ln400">}</a>
<a name="ln401"> </a>
<a name="ln402">MiniMaster* MiniCluster::mini_master(int idx) {</a>
<a name="ln403">  CHECK_GE(idx, 0) &lt;&lt; &quot;Master idx must be &gt;= 0&quot;;</a>
<a name="ln404">  CHECK_LT(idx, mini_masters_.size()) &lt;&lt; &quot;Master idx must be &lt; num masters started&quot;;</a>
<a name="ln405">  return mini_masters_[idx].get();</a>
<a name="ln406">}</a>
<a name="ln407"> </a>
<a name="ln408">MiniTabletServer* MiniCluster::mini_tablet_server(int idx) {</a>
<a name="ln409">  CHECK_GE(idx, 0) &lt;&lt; &quot;TabletServer idx must be &gt;= 0&quot;;</a>
<a name="ln410">  CHECK_LT(idx, mini_tablet_servers_.size()) &lt;&lt; &quot;TabletServer idx must be &lt; 'num_ts_started_'&quot;;</a>
<a name="ln411">  return mini_tablet_servers_[idx].get();</a>
<a name="ln412">}</a>
<a name="ln413"> </a>
<a name="ln414">MiniTabletServer* MiniCluster::find_tablet_server(const std::string&amp; uuid) {</a>
<a name="ln415">  for (const auto&amp; server : mini_tablet_servers_) {</a>
<a name="ln416">    if (!server-&gt;server()) {</a>
<a name="ln417">      continue;</a>
<a name="ln418">    }</a>
<a name="ln419">    if (server-&gt;server()-&gt;instance_pb().permanent_uuid() == uuid) {</a>
<a name="ln420">      return server.get();</a>
<a name="ln421">    }</a>
<a name="ln422">  }</a>
<a name="ln423">  return nullptr;</a>
<a name="ln424">}</a>
<a name="ln425"> </a>
<a name="ln426">string MiniCluster::GetMasterFsRoot(int idx) {</a>
<a name="ln427">  return JoinPathSegments(fs_root_, Substitute(&quot;master-$0-root&quot;, idx + 1));</a>
<a name="ln428">}</a>
<a name="ln429"> </a>
<a name="ln430">string MiniCluster::GetTabletServerFsRoot(int idx) {</a>
<a name="ln431">  return JoinPathSegments(fs_root_, Substitute(&quot;ts-$0-root&quot;, idx + 1));</a>
<a name="ln432">}</a>
<a name="ln433"> </a>
<a name="ln434">tserver::TSTabletManager* MiniCluster::GetTabletManager(int idx) {</a>
<a name="ln435">  return mini_tablet_server(idx)-&gt;server()-&gt;tablet_manager();</a>
<a name="ln436">}</a>
<a name="ln437"> </a>
<a name="ln438">std::vector&lt;std::shared_ptr&lt;tablet::TabletPeer&gt;&gt; MiniCluster::GetTabletPeers(int idx) {</a>
<a name="ln439">  return GetTabletManager(idx)-&gt;GetTabletPeers();</a>
<a name="ln440">}</a>
<a name="ln441"> </a>
<a name="ln442">Status MiniCluster::WaitForReplicaCount(const string&amp; tablet_id,</a>
<a name="ln443">                                        int expected_count,</a>
<a name="ln444">                                        TabletLocationsPB* locations) {</a>
<a name="ln445">  Stopwatch sw;</a>
<a name="ln446">  sw.start();</a>
<a name="ln447">  while (sw.elapsed().wall_seconds() &lt; kTabletReportWaitTimeSeconds) {</a>
<a name="ln448">    Status s =</a>
<a name="ln449">        leader_mini_master()-&gt;master()-&gt;catalog_manager()-&gt;GetTabletLocations(tablet_id, locations);</a>
<a name="ln450">    if (s.ok() &amp;&amp; ((locations-&gt;stale() &amp;&amp; expected_count == 0) ||</a>
<a name="ln451">        (!locations-&gt;stale() &amp;&amp; locations-&gt;replicas_size() == expected_count))) {</a>
<a name="ln452">      return Status::OK();</a>
<a name="ln453">    }</a>
<a name="ln454"> </a>
<a name="ln455">    SleepFor(MonoDelta::FromMilliseconds(1));</a>
<a name="ln456">  }</a>
<a name="ln457">  return STATUS(TimedOut, Substitute(&quot;Tablet $0 never reached expected replica count $1&quot;,</a>
<a name="ln458">                                     tablet_id, expected_count));</a>
<a name="ln459">}</a>
<a name="ln460"> </a>
<a name="ln461">Status MiniCluster::WaitForAllTabletServers() {</a>
<a name="ln462">  return WaitForTabletServerCount(num_tablet_servers());</a>
<a name="ln463">}</a>
<a name="ln464"> </a>
<a name="ln465">Status MiniCluster::WaitForTabletServerCount(int count) {</a>
<a name="ln466">  vector&lt;shared_ptr&lt;master::TSDescriptor&gt; &gt; descs;</a>
<a name="ln467">  return WaitForTabletServerCount(count, &amp;descs);</a>
<a name="ln468">}</a>
<a name="ln469"> </a>
<a name="ln470">Status MiniCluster::WaitForTabletServerCount(int count,</a>
<a name="ln471">                                             vector&lt;shared_ptr&lt;TSDescriptor&gt; &gt;* descs) {</a>
<a name="ln472">  Stopwatch sw;</a>
<a name="ln473">  sw.start();</a>
<a name="ln474">  while (sw.elapsed().wall_seconds() &lt; kRegistrationWaitTimeSeconds) {</a>
<a name="ln475">    auto leader = leader_mini_master();</a>
<a name="ln476">    if (leader) {</a>
<a name="ln477">      leader-&gt;master()-&gt;ts_manager()-&gt;GetAllDescriptors(descs);</a>
<a name="ln478">      if (descs-&gt;size() == count) {</a>
<a name="ln479">        // GetAllDescriptors() may return servers that are no longer online.</a>
<a name="ln480">        // Do a second step of verification to verify that the descs that we got</a>
<a name="ln481">        // are aligned (same uuid/seqno) with the TSs that we have in the cluster.</a>
<a name="ln482">        int match_count = 0;</a>
<a name="ln483">        for (const shared_ptr&lt;TSDescriptor&gt;&amp; desc : *descs) {</a>
<a name="ln484">          for (auto mini_tablet_server : mini_tablet_servers_) {</a>
<a name="ln485">            auto ts = mini_tablet_server-&gt;server();</a>
<a name="ln486">            if (ts-&gt;instance_pb().permanent_uuid() == desc-&gt;permanent_uuid() &amp;&amp;</a>
<a name="ln487">                ts-&gt;instance_pb().instance_seqno() == desc-&gt;latest_seqno()) {</a>
<a name="ln488">              match_count++;</a>
<a name="ln489">              break;</a>
<a name="ln490">            }</a>
<a name="ln491">          }</a>
<a name="ln492">        }</a>
<a name="ln493"> </a>
<a name="ln494">        if (match_count == count) {</a>
<a name="ln495">          LOG(INFO) &lt;&lt; count &lt;&lt; &quot; TS(s) registered with Master after &quot;</a>
<a name="ln496">                    &lt;&lt; sw.elapsed().wall_seconds() &lt;&lt; &quot;s&quot;;</a>
<a name="ln497">          return Status::OK();</a>
<a name="ln498">        }</a>
<a name="ln499">      }</a>
<a name="ln500">    }</a>
<a name="ln501"> </a>
<a name="ln502">    SleepFor(MonoDelta::FromMilliseconds(1));</a>
<a name="ln503">  }</a>
<a name="ln504">  return STATUS(TimedOut, Substitute(&quot;$0 TS(s) never registered with master&quot;, count));</a>
<a name="ln505">}</a>
<a name="ln506"> </a>
<a name="ln507">void MiniCluster::ConfigureClientBuilder(YBClientBuilder* builder) {</a>
<a name="ln508">  CHECK_NOTNULL(builder);</a>
<a name="ln509">  builder-&gt;clear_master_server_addrs();</a>
<a name="ln510">  for (const shared_ptr&lt;MiniMaster&gt;&amp; master : mini_masters_) {</a>
<a name="ln511">    CHECK(master);</a>
<a name="ln512">    builder-&gt;add_master_server_addr(master-&gt;bound_rpc_addr_str());</a>
<a name="ln513">  }</a>
<a name="ln514">}</a>
<a name="ln515"> </a>
<a name="ln516">HostPort MiniCluster::DoGetLeaderMasterBoundRpcAddr() {</a>
<a name="ln517">  return leader_mini_master()-&gt;bound_rpc_addr();</a>
<a name="ln518">}</a>
<a name="ln519"> </a>
<a name="ln520">void MiniCluster::AllocatePortsForDaemonType(</a>
<a name="ln521">    const string daemon_type,</a>
<a name="ln522">    const int num_daemons,</a>
<a name="ln523">    const string port_type,</a>
<a name="ln524">    std::vector&lt;uint16_t&gt;* ports) {</a>
<a name="ln525">  const size_t old_size = ports-&gt;size();</a>
<a name="ln526">  if (ports-&gt;size() &lt; num_daemons) {</a>
<a name="ln527">    ports-&gt;resize(num_daemons, 0 /* default value */);</a>
<a name="ln528">  }</a>
<a name="ln529">  for (int i = old_size; i &lt; num_daemons; ++i) {</a>
<a name="ln530">    if ((*ports)[i] == 0) {</a>
<a name="ln531">      const uint16_t new_port = port_picker_.AllocateFreePort();</a>
<a name="ln532">      (*ports)[i] = new_port;</a>
<a name="ln533">      LOG(INFO) &lt;&lt; &quot;Using auto-assigned port &quot; &lt;&lt; new_port &lt;&lt; &quot; for a &quot; &lt;&lt; daemon_type</a>
<a name="ln534">                &lt;&lt; &quot; &quot; &lt;&lt; port_type &lt;&lt; &quot; port&quot;;</a>
<a name="ln535">    }</a>
<a name="ln536">  }</a>
<a name="ln537">}</a>
<a name="ln538"> </a>
<a name="ln539">void MiniCluster::EnsurePortsAllocated(int new_num_masters, int new_num_tservers) {</a>
<a name="ln540">  if (new_num_masters == 0) {</a>
<a name="ln541">    new_num_masters = std::max(num_masters_initial_, num_masters());</a>
<a name="ln542">  }</a>
<a name="ln543">  AllocatePortsForDaemonType(&quot;master&quot;, new_num_masters, &quot;RPC&quot;, &amp;master_rpc_ports_);</a>
<a name="ln544">  AllocatePortsForDaemonType(&quot;master&quot;, new_num_masters, &quot;web&quot;, &amp;master_web_ports_);</a>
<a name="ln545"> </a>
<a name="ln546">  if (new_num_tservers == 0) {</a>
<a name="ln547">    new_num_tservers = std::max(num_ts_initial_, num_tablet_servers());</a>
<a name="ln548">  }</a>
<a name="ln549">  AllocatePortsForDaemonType(&quot;tablet server&quot;, new_num_tservers, &quot;RPC&quot;, &amp;tserver_rpc_ports_);</a>
<a name="ln550">  AllocatePortsForDaemonType(&quot;tablet server&quot;, new_num_tservers, &quot;web&quot;, &amp;tserver_web_ports_);</a>
<a name="ln551">}</a>
<a name="ln552"> </a>
<a name="ln553">std::vector&lt;server::SkewedClockDeltaChanger&gt; SkewClocks(</a>
<a name="ln554">    MiniCluster* cluster, std::chrono::milliseconds clock_skew) {</a>
<a name="ln555">  std::vector&lt;server::SkewedClockDeltaChanger&gt; delta_changers;</a>
<a name="ln556">  for (int i = 0; i != cluster-&gt;num_tablet_servers(); ++i) {</a>
<a name="ln557">    auto* tserver = cluster-&gt;mini_tablet_server(i)-&gt;server();</a>
<a name="ln558">    auto* hybrid_clock = down_cast&lt;server::HybridClock*&gt;(tserver-&gt;clock());</a>
<a name="ln559">    delta_changers.emplace_back(</a>
<a name="ln560">        i * clock_skew, std::static_pointer_cast&lt;server::SkewedClock&gt;(hybrid_clock-&gt;TEST_clock()));</a>
<a name="ln561">  }</a>
<a name="ln562">  return delta_changers;</a>
<a name="ln563">}</a>
<a name="ln564"> </a>
<a name="ln565">void StepDownAllTablets(MiniCluster* cluster) {</a>
<a name="ln566">  for (int i = 0; i != cluster-&gt;num_tablet_servers(); ++i) {</a>
<a name="ln567">    for (const auto&amp; peer : cluster-&gt;GetTabletPeers(i)) {</a>
<a name="ln568">      consensus::LeaderStepDownRequestPB req;</a>
<a name="ln569">      req.set_tablet_id(peer-&gt;tablet_id());</a>
<a name="ln570">      consensus::LeaderStepDownResponsePB resp;</a>
<a name="ln571">      ASSERT_OK(peer-&gt;consensus()-&gt;StepDown(&amp;req, &amp;resp));</a>
<a name="ln572">    }</a>
<a name="ln573">  }</a>
<a name="ln574">}</a>
<a name="ln575"> </a>
<a name="ln576">void StepDownRandomTablet(MiniCluster* cluster) {</a>
<a name="ln577">  auto peers = ListTabletPeers(cluster, ListPeersFilter::kLeaders);</a>
<a name="ln578">  if (!peers.empty()) {</a>
<a name="ln579">    auto peer = RandomElement(peers);</a>
<a name="ln580"> </a>
<a name="ln581">    consensus::LeaderStepDownRequestPB req;</a>
<a name="ln582">    req.set_tablet_id(peer-&gt;tablet_id());</a>
<a name="ln583">    consensus::LeaderStepDownResponsePB resp;</a>
<a name="ln584">    ASSERT_OK(peer-&gt;consensus()-&gt;StepDown(&amp;req, &amp;resp));</a>
<a name="ln585">  }</a>
<a name="ln586">}</a>
<a name="ln587"> </a>
<a name="ln588">std::unordered_set&lt;string&gt; ListTabletIdsForTable(MiniCluster* cluster, const string&amp; table_id) {</a>
<a name="ln589">  std::unordered_set&lt;string&gt; tablet_ids;</a>
<a name="ln590">  for (auto peer : ListTabletPeers(cluster, ListPeersFilter::kAll)) {</a>
<a name="ln591">    if (peer-&gt;tablet_metadata()-&gt;table_id() == table_id) {</a>
<a name="ln592">      tablet_ids.insert(peer-&gt;tablet_id());</a>
<a name="ln593">    }</a>
<a name="ln594">  }</a>
<a name="ln595">  return tablet_ids;</a>
<a name="ln596">}</a>
<a name="ln597"> </a>
<a name="ln598">std::vector&lt;tablet::TabletPeerPtr&gt; ListTabletPeers(MiniCluster* cluster, ListPeersFilter filter) {</a>
<a name="ln599">  switch (filter) {</a>
<a name="ln600">    case ListPeersFilter::kAll:</a>
<a name="ln601">      return ListTabletPeers(cluster, [](const auto&amp; peer) { return true; });</a>
<a name="ln602">    case ListPeersFilter::kLeaders:</a>
<a name="ln603">      return ListTabletPeers(cluster, [](const auto&amp; peer) {</a>
<a name="ln604">        return peer-&gt;consensus()-&gt;GetLeaderStatus() != consensus::LeaderStatus::NOT_LEADER;</a>
<a name="ln605">      });</a>
<a name="ln606">    case ListPeersFilter::kNonLeaders:</a>
<a name="ln607">      return ListTabletPeers(cluster, [](const auto&amp; peer) {</a>
<a name="ln608">        return peer-&gt;consensus()-&gt;GetLeaderStatus() == consensus::LeaderStatus::NOT_LEADER;</a>
<a name="ln609">      });</a>
<a name="ln610">  }</a>
<a name="ln611"> </a>
<a name="ln612">  FATAL_INVALID_ENUM_VALUE(ListPeersFilter, filter);</a>
<a name="ln613">}</a>
<a name="ln614"> </a>
<a name="ln615">std::vector&lt;tablet::TabletPeerPtr&gt; ListTabletPeers(</a>
<a name="ln616">    MiniCluster* cluster,</a>
<a name="ln617">    const std::function&lt;bool(const std::shared_ptr&lt;tablet::TabletPeer&gt;&amp;)&gt;&amp; filter) {</a>
<a name="ln618">  std::vector&lt;tablet::TabletPeerPtr&gt; result;</a>
<a name="ln619"> </a>
<a name="ln620">  for (int i = 0; i != cluster-&gt;num_tablet_servers(); ++i) {</a>
<a name="ln621">    auto server = cluster-&gt;mini_tablet_server(i)-&gt;server();</a>
<a name="ln622">    if (!server) { // Server is shut down.</a>
<a name="ln623">      continue;</a>
<a name="ln624">    }</a>
<a name="ln625">    auto peers = server-&gt;tablet_manager()-&gt;GetTabletPeers();</a>
<a name="ln626">    for (const auto&amp; peer : peers) {</a>
<a name="ln627">      WARN_NOT_OK(</a>
<a name="ln628">          WaitFor([peer] { return peer-&gt;consensus() != nullptr; }, 5s,</a>
<a name="ln629">          Format(&quot;Waiting peer T $0 P $1 ready&quot;, peer-&gt;tablet_id(), peer-&gt;permanent_uuid())),</a>
<a name="ln630">          &quot;List tablet peers failure&quot;);</a>
<a name="ln631">      if (filter(peer)) {</a>
<a name="ln632">        result.push_back(peer);</a>
<a name="ln633">      }</a>
<a name="ln634">    }</a>
<a name="ln635">  }</a>
<a name="ln636"> </a>
<a name="ln637">  return result;</a>
<a name="ln638">}</a>
<a name="ln639"> </a>
<a name="ln640">Status WaitUntilTabletHasLeader(</a>
<a name="ln641">    MiniCluster* cluster, const string&amp; tablet_id, MonoTime deadline) {</a>
<a name="ln642">  return Wait([cluster, &amp;tablet_id] {</a>
<a name="ln643">    auto tablet_peers = ListTabletPeers(cluster, [&amp;tablet_id](auto peer) {</a>
<a name="ln644">      return peer-&gt;tablet_id() == tablet_id</a>
<a name="ln645">          &amp;&amp; peer-&gt;consensus()-&gt;GetLeaderStatus() != consensus::LeaderStatus::NOT_LEADER;</a>
<a name="ln646">    });</a>
<a name="ln647">    return tablet_peers.size() == 1;</a>
<a name="ln648">  }, deadline, &quot;Waiting for election in tablet &quot; + tablet_id);</a>
<a name="ln649">}</a>
<a name="ln650"> </a>
<a name="ln651">Status WaitForLeaderOfSingleTablet(</a>
<a name="ln652">    MiniCluster* cluster, tablet::TabletPeerPtr leader, MonoDelta duration,</a>
<a name="ln653">    const std::string&amp; description) {</a>
<a name="ln654">  return WaitFor([cluster, &amp;leader] {</a>
<a name="ln655">    auto new_leaders = ListTabletPeers(cluster, ListPeersFilter::kLeaders);</a>
<a name="ln656">    return new_leaders.size() == 1 &amp;&amp; new_leaders[0] == leader;</a>
<a name="ln657">  }, duration, description);</a>
<a name="ln658">}</a>
<a name="ln659"> </a>
<a name="ln660">Status StepDown(</a>
<a name="ln661">    tablet::TabletPeerPtr leader, const std::string&amp; new_leader_uuid,</a>
<a name="ln662">    ForceStepDown force_step_down) {</a>
<a name="ln663">  consensus::LeaderStepDownRequestPB req;</a>
<a name="ln664">  req.set_tablet_id(leader-&gt;tablet_id());</a>
<a name="ln665">  req.set_new_leader_uuid(new_leader_uuid);</a>
<a name="ln666">  if (force_step_down) {</a>
<a name="ln667">    req.set_force_step_down(true);</a>
<a name="ln668">  }</a>
<a name="ln669">  consensus::LeaderStepDownResponsePB resp;</a>
<a name="ln670">  RETURN_NOT_OK(leader-&gt;consensus()-&gt;StepDown(&amp;req, &amp;resp));</a>
<a name="ln671">  if (resp.has_error()) {</a>
<a name="ln672">    return STATUS_FORMAT(RuntimeError, &quot;Step down failed: $0&quot;, resp);</a>
<a name="ln673">  }</a>
<a name="ln674">  return Status::OK();</a>
<a name="ln675">}</a>
<a name="ln676"> </a>
<a name="ln677">std::thread RestartsThread(</a>
<a name="ln678">    MiniCluster* cluster, CoarseDuration interval, std::atomic&lt;bool&gt;* stop_flag) {</a>
<a name="ln679">  return std::thread([cluster, interval, stop_flag] {</a>
<a name="ln680">    CDSAttacher attacher;</a>
<a name="ln681">    SetFlagOnExit set_stop_on_exit(stop_flag);</a>
<a name="ln682">    int it = 0;</a>
<a name="ln683">    while (!stop_flag-&gt;load(std::memory_order_acquire)) {</a>
<a name="ln684">      std::this_thread::sleep_for(interval);</a>
<a name="ln685">      ASSERT_OK(cluster-&gt;mini_tablet_server(++it % cluster-&gt;num_tablet_servers())-&gt;Restart());</a>
<a name="ln686">    }</a>
<a name="ln687">  });</a>
<a name="ln688">}</a>
<a name="ln689"> </a>
<a name="ln690">Status WaitAllReplicasReady(MiniCluster* cluster, MonoDelta timeout) {</a>
<a name="ln691">  return WaitFor([cluster] {</a>
<a name="ln692">    std::unordered_set&lt;std::string&gt; tablet_ids;</a>
<a name="ln693">    auto peers = ListTabletPeers(cluster, ListPeersFilter::kAll);</a>
<a name="ln694">    for (const auto&amp; peer : peers) {</a>
<a name="ln695">      if (peer-&gt;state() != tablet::RaftGroupStatePB::RUNNING) {</a>
<a name="ln696">        return false;</a>
<a name="ln697">      }</a>
<a name="ln698">      tablet_ids.insert(peer-&gt;tablet_id());</a>
<a name="ln699">    }</a>
<a name="ln700">    auto replication_factor = cluster-&gt;num_tablet_servers();</a>
<a name="ln701">    return tablet_ids.size() * replication_factor == peers.size();</a>
<a name="ln702">  }, timeout, &quot;Wait all replicas to be ready&quot;);</a>
<a name="ln703">}</a>
<a name="ln704"> </a>
<a name="ln705">Status WaitAllReplicasHaveIndex(MiniCluster* cluster, int64_t index, MonoDelta timeout) {</a>
<a name="ln706">  return WaitFor([cluster, index] {</a>
<a name="ln707">    std::unordered_set&lt;std::string&gt; tablet_ids;</a>
<a name="ln708">    auto peers = ListTabletPeers(cluster, ListPeersFilter::kAll);</a>
<a name="ln709">    for (const auto&amp; peer : peers) {</a>
<a name="ln710">      if (peer-&gt;GetLatestLogEntryOpId().index &lt; index) {</a>
<a name="ln711">        return false;</a>
<a name="ln712">      }</a>
<a name="ln713">      tablet_ids.insert(peer-&gt;tablet_id());</a>
<a name="ln714">    }</a>
<a name="ln715">    auto replication_factor = cluster-&gt;num_tablet_servers();</a>
<a name="ln716">    return tablet_ids.size() * replication_factor == peers.size();</a>
<a name="ln717">  }, timeout, &quot;Wait for all replicas to have a specific Raft index&quot;);</a>
<a name="ln718">}</a>
<a name="ln719"> </a>
<a name="ln720">template &lt;class Collection&gt;</a>
<a name="ln721">void PushBackIfNotNull(const typename Collection::value_type&amp; value, Collection* collection) {</a>
<a name="ln722">  if (value != nullptr) {</a>
<a name="ln723">    collection-&gt;push_back(value);</a>
<a name="ln724">  }</a>
<a name="ln725">}</a>
<a name="ln726"> </a>
<a name="ln727">std::vector&lt;rocksdb::DB*&gt; GetAllRocksDbs(MiniCluster* cluster, bool include_intents) {</a>
<a name="ln728">  std::vector&lt;rocksdb::DB*&gt; dbs;</a>
<a name="ln729">  for (auto&amp; peer : ListTabletPeers(cluster, ListPeersFilter::kAll)) {</a>
<a name="ln730">    const auto* tablet = peer-&gt;tablet();</a>
<a name="ln731">    PushBackIfNotNull(tablet-&gt;TEST_db(), &amp;dbs);</a>
<a name="ln732">    if (include_intents) {</a>
<a name="ln733">      PushBackIfNotNull(tablet-&gt;TEST_intents_db(), &amp;dbs);</a>
<a name="ln734">    }</a>
<a name="ln735">  }</a>
<a name="ln736">  return dbs;</a>
<a name="ln737">}</a>
<a name="ln738"> </a>
<a name="ln739">int NumTotalRunningCompactions(MiniCluster* cluster) {</a>
<a name="ln740">  int compactions = 0;</a>
<a name="ln741">  for (auto* db : GetAllRocksDbs(cluster)) {</a>
<a name="ln742">    compactions += down_cast&lt;rocksdb::DBImpl*&gt;(db)-&gt;TEST_NumTotalRunningCompactions();</a>
<a name="ln743">  }</a>
<a name="ln744">  return compactions;</a>
<a name="ln745">}</a>
<a name="ln746"> </a>
<a name="ln747">int NumRunningFlushes(MiniCluster* cluster) {</a>
<a name="ln748">  int flushes = 0;</a>
<a name="ln749">  for (auto* db : GetAllRocksDbs(cluster)) {</a>
<a name="ln750">    flushes += down_cast&lt;rocksdb::DBImpl*&gt;(db)-&gt;TEST_NumRunningFlushes();</a>
<a name="ln751">  }</a>
<a name="ln752">  return flushes;</a>
<a name="ln753">}</a>
<a name="ln754"> </a>
<a name="ln755">Result&lt;scoped_refptr&lt;master::TableInfo&gt;&gt; FindTable(</a>
<a name="ln756">    MiniCluster* cluster, const client::YBTableName&amp; table_name) {</a>
<a name="ln757">  auto* catalog_manager = cluster-&gt;leader_mini_master()-&gt;master()-&gt;catalog_manager();</a>
<a name="ln758">  scoped_refptr&lt;master::TableInfo&gt; table_info;</a>
<a name="ln759">  master::TableIdentifierPB identifier;</a>
<a name="ln760">  table_name.SetIntoTableIdentifierPB(&amp;identifier);</a>
<a name="ln761">  RETURN_NOT_OK(catalog_manager-&gt;FindTable(identifier, &amp;table_info));</a>
<a name="ln762">  return table_info;</a>
<a name="ln763">}</a>
<a name="ln764"> </a>
<a name="ln765">Status WaitForInitDb(MiniCluster* cluster) {</a>
<a name="ln766">  const auto start_time = CoarseMonoClock::now();</a>
<a name="ln767">  const auto kTimeout = RegularBuildVsSanitizers(600s, 1800s);</a>
<a name="ln768">  while (CoarseMonoClock::now() &lt;= start_time + kTimeout) {</a>
<a name="ln769">    auto* catalog_manager = cluster-&gt;leader_mini_master()-&gt;master()-&gt;catalog_manager();</a>
<a name="ln770">    master::IsInitDbDoneRequestPB req;</a>
<a name="ln771">    master::IsInitDbDoneResponsePB resp;</a>
<a name="ln772">    auto status = catalog_manager-&gt;IsInitDbDone(&amp;req, &amp;resp);</a>
<a name="ln773">    if (!status.ok()) {</a>
<a name="ln774">      LOG(INFO) &lt;&lt; &quot;IsInitDbDone failure: &quot; &lt;&lt; status;</a>
<a name="ln775">      continue;</a>
<a name="ln776">    }</a>
<a name="ln777">    if (resp.done()) {</a>
<a name="ln778">      return Status::OK();</a>
<a name="ln779">    }</a>
<a name="ln780">    if (resp.has_initdb_error()) {</a>
<a name="ln781">      return STATUS_FORMAT(RuntimeError, &quot;Init DB failed: $0&quot;, resp.initdb_error());</a>
<a name="ln782">    }</a>
<a name="ln783">    std::this_thread::sleep_for(500ms);</a>
<a name="ln784">  }</a>
<a name="ln785"> </a>
<a name="ln786">  return STATUS_FORMAT(TimedOut, &quot;Unable to init db in $0&quot;, kTimeout);</a>
<a name="ln787">}</a>
<a name="ln788"> </a>
<a name="ln789">size_t CountIntents(MiniCluster* cluster, const TabletPeerFilter&amp; filter) {</a>
<a name="ln790">  size_t result = 0;</a>
<a name="ln791">  auto peers = ListTabletPeers(cluster, ListPeersFilter::kAll);</a>
<a name="ln792">  for (const auto &amp;peer : peers) {</a>
<a name="ln793">    auto participant = peer-&gt;tablet() ? peer-&gt;tablet()-&gt;transaction_participant() : nullptr;</a>
<a name="ln794">    if (!participant) {</a>
<a name="ln795">      continue;</a>
<a name="ln796">    }</a>
<a name="ln797">    if (filter &amp;&amp; !filter(peer.get())) {</a>
<a name="ln798">      continue;</a>
<a name="ln799">    }</a>
<a name="ln800">    auto intents_count = participant-&gt;TEST_CountIntents();</a>
<a name="ln801">    if (intents_count.first) {</a>
<a name="ln802">      result += intents_count.first;</a>
<a name="ln803">      LOG(INFO) &lt;&lt; Format(&quot;T $0 P $1: Intents present: $2, transactions: $3&quot;, peer-&gt;tablet_id(),</a>
<a name="ln804">                          peer-&gt;permanent_uuid(), intents_count.first, intents_count.second);</a>
<a name="ln805">    }</a>
<a name="ln806">  }</a>
<a name="ln807">  return result;</a>
<a name="ln808">}</a>
<a name="ln809"> </a>
<a name="ln810">MiniTabletServer* FindTabletLeader(MiniCluster* cluster, const TabletId&amp; tablet_id) {</a>
<a name="ln811">  for (int i = 0; i != cluster-&gt;num_tablet_servers(); ++i) {</a>
<a name="ln812">    auto server = cluster-&gt;mini_tablet_server(i);</a>
<a name="ln813">    if (!server-&gt;server()) { // Server is shut down.</a>
<a name="ln814">      continue;</a>
<a name="ln815">    }</a>
<a name="ln816">    if (server-&gt;server()-&gt;LeaderAndReady(tablet_id)) {</a>
<a name="ln817">      return server;</a>
<a name="ln818">    }</a>
<a name="ln819">  }</a>
<a name="ln820"> </a>
<a name="ln821">  return nullptr;</a>
<a name="ln822">}</a>
<a name="ln823"> </a>
<a name="ln824">void ShutdownAllTServers(MiniCluster* cluster) {</a>
<a name="ln825">  for (int i = 0; i != cluster-&gt;num_tablet_servers(); ++i) {</a>
<a name="ln826">    cluster-&gt;mini_tablet_server(i)-&gt;Shutdown();</a>
<a name="ln827">  }</a>
<a name="ln828">}</a>
<a name="ln829"> </a>
<a name="ln830">Status StartAllTServers(MiniCluster* cluster) {</a>
<a name="ln831">  for (int i = 0; i != cluster-&gt;num_tablet_servers(); ++i) {</a>
<a name="ln832">    RETURN_NOT_OK(cluster-&gt;mini_tablet_server(i)-&gt;Start());</a>
<a name="ln833">  }</a>
<a name="ln834"> </a>
<a name="ln835">  return Status::OK();</a>
<a name="ln836">}</a>
<a name="ln837"> </a>
<a name="ln838">void ShutdownAllMasters(MiniCluster* cluster) {</a>
<a name="ln839">  for (int i = 0; i != cluster-&gt;num_masters(); ++i) {</a>
<a name="ln840">    cluster-&gt;mini_master(i)-&gt;Shutdown();</a>
<a name="ln841">  }</a>
<a name="ln842">}</a>
<a name="ln843"> </a>
<a name="ln844">Status StartAllMasters(MiniCluster* cluster) {</a>
<a name="ln845">  for (int i = 0; i != cluster-&gt;num_masters(); ++i) {</a>
<a name="ln846">    RETURN_NOT_OK(cluster-&gt;mini_master(i)-&gt;Start());</a>
<a name="ln847">  }</a>
<a name="ln848"> </a>
<a name="ln849">  return Status::OK();</a>
<a name="ln850">}</a>
<a name="ln851"> </a>
<a name="ln852">Status BreakConnectivity(MiniCluster* cluster, int idx1, int idx2) {</a>
<a name="ln853">  for (int from_idx : {idx1, idx2}) {</a>
<a name="ln854">    int to_idx = idx1 ^ idx2 ^ from_idx;</a>
<a name="ln855">    for (auto type : {server::Private::kFalse, server::Private::kTrue}) {</a>
<a name="ln856">      // TEST_RpcAddress is 1-indexed; we expect from_idx/to_idx to be 0-indexed.</a>
<a name="ln857">      auto address = VERIFY_RESULT(HostToAddress(TEST_RpcAddress(to_idx + 1, type)));</a>
<a name="ln858">      for (auto messenger : { cluster-&gt;mini_master(from_idx)-&gt;master()-&gt;messenger(),</a>
<a name="ln859">                              cluster-&gt;mini_tablet_server(from_idx)-&gt;server()-&gt;messenger() }) {</a>
<a name="ln860">        messenger-&gt;BreakConnectivityTo(address);</a>
<a name="ln861">      }</a>
<a name="ln862">    }</a>
<a name="ln863">  }</a>
<a name="ln864"> </a>
<a name="ln865">  return Status::OK();</a>
<a name="ln866">}</a>
<a name="ln867"> </a>
<a name="ln868">}  // namespace yb</a>

</code></pre>
<div class="balloon" rel="142"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="143"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="230"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="232"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="263"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="264"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="268"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="269"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="512"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1004/" target="_blank">V1004</a> The 'master' pointer was used unsafely after it was verified against nullptr. Check lines: 511, 512.</p></div>
<div class="balloon" rel="511"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
