
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>async_rpc_tasks.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Copyright (c) YugaByte, Inc.</a>
<a name="ln2">//</a>
<a name="ln3">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln4">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln5">//</a>
<a name="ln6">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln7">//</a>
<a name="ln8">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln9">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln10">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln11">// under the License.</a>
<a name="ln12">//</a>
<a name="ln13">#ifndef YB_MASTER_ASYNC_RPC_TASKS_H</a>
<a name="ln14">#define YB_MASTER_ASYNC_RPC_TASKS_H</a>
<a name="ln15"> </a>
<a name="ln16">#include &lt;atomic&gt;</a>
<a name="ln17">#include &lt;string&gt;</a>
<a name="ln18"> </a>
<a name="ln19">#include &lt;boost/optional/optional.hpp&gt;</a>
<a name="ln20"> </a>
<a name="ln21">#include &quot;yb/common/entity_ids.h&quot;</a>
<a name="ln22"> </a>
<a name="ln23">#include &quot;yb/consensus/consensus.pb.h&quot;</a>
<a name="ln24">#include &quot;yb/consensus/metadata.pb.h&quot;</a>
<a name="ln25"> </a>
<a name="ln26">#include &quot;yb/gutil/ref_counted.h&quot;</a>
<a name="ln27">#include &quot;yb/gutil/gscoped_ptr.h&quot;</a>
<a name="ln28">#include &quot;yb/gutil/strings/substitute.h&quot;</a>
<a name="ln29"> </a>
<a name="ln30">#include &quot;yb/master/catalog_entity_info.h&quot;</a>
<a name="ln31">#include &quot;yb/rpc/rpc_controller.h&quot;</a>
<a name="ln32"> </a>
<a name="ln33">#include &quot;yb/server/monitored_task.h&quot;</a>
<a name="ln34"> </a>
<a name="ln35">#include &quot;yb/tserver/tserver_admin.pb.h&quot;</a>
<a name="ln36">#include &quot;yb/tserver/tserver_service.pb.h&quot;</a>
<a name="ln37"> </a>
<a name="ln38">#include &quot;yb/util/status.h&quot;</a>
<a name="ln39">#include &quot;yb/util/memory/memory.h&quot;</a>
<a name="ln40"> </a>
<a name="ln41"> </a>
<a name="ln42">namespace yb {</a>
<a name="ln43"> </a>
<a name="ln44">class ThreadPool;</a>
<a name="ln45"> </a>
<a name="ln46">namespace consensus {</a>
<a name="ln47">class ConsensusServiceProxy;</a>
<a name="ln48">}</a>
<a name="ln49"> </a>
<a name="ln50">namespace tserver {</a>
<a name="ln51">class TabletServerAdminServiceProxy;</a>
<a name="ln52">class TabletServerServiceProxy;</a>
<a name="ln53">}</a>
<a name="ln54"> </a>
<a name="ln55">namespace master {</a>
<a name="ln56"> </a>
<a name="ln57">class TSDescriptor;</a>
<a name="ln58">class Master;</a>
<a name="ln59"> </a>
<a name="ln60">class TableInfo;</a>
<a name="ln61">class TabletInfo;</a>
<a name="ln62"> </a>
<a name="ln63">// Interface used by RetryingTSRpcTask to pick the tablet server to</a>
<a name="ln64">// send the next RPC to.</a>
<a name="ln65">class TSPicker {</a>
<a name="ln66"> public:</a>
<a name="ln67">  TSPicker() {}</a>
<a name="ln68">  virtual ~TSPicker() {}</a>
<a name="ln69"> </a>
<a name="ln70">  // Sets *ts_desc to the tablet server to contact for the next RPC.</a>
<a name="ln71">  //</a>
<a name="ln72">  // This assumes that TSDescriptors are never deleted by the master,</a>
<a name="ln73">  // so the caller does not take ownership of the returned pointer.</a>
<a name="ln74">  virtual Status PickReplica(TSDescriptor** ts_desc) = 0;</a>
<a name="ln75"> </a>
<a name="ln76"> private:</a>
<a name="ln77">  DISALLOW_COPY_AND_ASSIGN(TSPicker);</a>
<a name="ln78">};</a>
<a name="ln79"> </a>
<a name="ln80">// Implementation of TSPicker which sends to a specific tablet server,</a>
<a name="ln81">// identified by its UUID.</a>
<a name="ln82">class PickSpecificUUID : public TSPicker {</a>
<a name="ln83"> public:</a>
<a name="ln84">  PickSpecificUUID(Master* master, std::string ts_uuid)</a>
<a name="ln85">      : master_(master), ts_uuid_(std::move(ts_uuid)) {}</a>
<a name="ln86"> </a>
<a name="ln87">  Status PickReplica(TSDescriptor** ts_desc) override;</a>
<a name="ln88"> </a>
<a name="ln89"> private:</a>
<a name="ln90">  Master* const master_;</a>
<a name="ln91">  const std::string ts_uuid_;</a>
<a name="ln92"> </a>
<a name="ln93">  DISALLOW_COPY_AND_ASSIGN(PickSpecificUUID);</a>
<a name="ln94">};</a>
<a name="ln95"> </a>
<a name="ln96">// Implementation of TSPicker which locates the current leader replica,</a>
<a name="ln97">// and sends the RPC to that server.</a>
<a name="ln98">class PickLeaderReplica : public TSPicker {</a>
<a name="ln99"> public:</a>
<a name="ln100">  explicit PickLeaderReplica(const scoped_refptr&lt;TabletInfo&gt;&amp; tablet)</a>
<a name="ln101">    : tablet_(tablet) {}</a>
<a name="ln102"> </a>
<a name="ln103">  Status PickReplica(TSDescriptor** ts_desc) override;</a>
<a name="ln104"> </a>
<a name="ln105"> private:</a>
<a name="ln106">  const scoped_refptr&lt;TabletInfo&gt; tablet_;</a>
<a name="ln107">};</a>
<a name="ln108"> </a>
<a name="ln109">// A background task which continuously retries sending an RPC to a tablet server.</a>
<a name="ln110">//</a>
<a name="ln111">// The target tablet server is refreshed before each RPC by consulting the provided</a>
<a name="ln112">// TSPicker implementation.</a>
<a name="ln113">class RetryingTSRpcTask : public MonitoredTask {</a>
<a name="ln114"> public:</a>
<a name="ln115">  RetryingTSRpcTask(Master *master,</a>
<a name="ln116">                    ThreadPool* callback_pool,</a>
<a name="ln117">                    gscoped_ptr&lt;TSPicker&gt; replica_picker,</a>
<a name="ln118">                    const scoped_refptr&lt;TableInfo&gt;&amp; table);</a>
<a name="ln119"> </a>
<a name="ln120">  // Send the subclass RPC request.</a>
<a name="ln121">  CHECKED_STATUS Run();</a>
<a name="ln122"> </a>
<a name="ln123">  // Abort this task and return its value before it was successfully aborted. If the task entered</a>
<a name="ln124">  // a different terminal state before we were able to abort it, return that state.</a>
<a name="ln125">  MonitoredTaskState AbortAndReturnPrevState(const Status&amp; status) override;</a>
<a name="ln126"> </a>
<a name="ln127">  MonitoredTaskState state() const override {</a>
<a name="ln128">    return state_.load(std::memory_order_acquire);</a>
<a name="ln129">  }</a>
<a name="ln130"> </a>
<a name="ln131">  MonoTime start_timestamp() const override { return start_ts_; }</a>
<a name="ln132">  MonoTime completion_timestamp() const override { return end_ts_; }</a>
<a name="ln133">  const scoped_refptr&lt;TableInfo&gt;&amp; table() const { return table_ ; }</a>
<a name="ln134"> </a>
<a name="ln135"> protected:</a>
<a name="ln136">  // Send an RPC request and register a callback.</a>
<a name="ln137">  // The implementation must return true if the callback was registered, and</a>
<a name="ln138">  // false if an error occurred and no callback will occur.</a>
<a name="ln139">  virtual bool SendRequest(int attempt) = 0;</a>
<a name="ln140"> </a>
<a name="ln141">  // Handle the response from the RPC request. On success, MarkSuccess() must</a>
<a name="ln142">  // be called to mutate the state_ variable. If retry is desired, then</a>
<a name="ln143">  // no state change is made. Retries will automatically be attempted as long</a>
<a name="ln144">  // as the state is MonitoredTaskState::kRunning and deadline_ has not yet passed.</a>
<a name="ln145">  virtual void HandleResponse(int attempt) = 0;</a>
<a name="ln146"> </a>
<a name="ln147">  // Return the id of the tablet that is the subject of the async request.</a>
<a name="ln148">  virtual TabletId tablet_id() const = 0;</a>
<a name="ln149"> </a>
<a name="ln150">  virtual Status ResetTSProxy();</a>
<a name="ln151"> </a>
<a name="ln152">  // Overridable log prefix with reasonable default.</a>
<a name="ln153">  std::string LogPrefix() const {</a>
<a name="ln154">    return strings::Substitute(&quot;$0 (task=$1, state=$2): &quot;, description(), this, ToString(state()));</a>
<a name="ln155">  }</a>
<a name="ln156"> </a>
<a name="ln157">  bool PerformStateTransition(MonitoredTaskState expected, MonitoredTaskState new_state)</a>
<a name="ln158">      WARN_UNUSED_RESULT {</a>
<a name="ln159">    return state_.compare_exchange_strong(expected, new_state);</a>
<a name="ln160">  }</a>
<a name="ln161"> </a>
<a name="ln162">  void TransitionToTerminalState(</a>
<a name="ln163">      MonitoredTaskState expected, MonitoredTaskState terminal_state, const Status&amp; status);</a>
<a name="ln164">  bool TransitionToWaitingState(MonitoredTaskState expected);</a>
<a name="ln165"> </a>
<a name="ln166">  // Transition this task state from running to complete.</a>
<a name="ln167">  void TransitionToCompleteState();</a>
<a name="ln168"> </a>
<a name="ln169">  // Transition this task state from expected to failed with specified status.</a>
<a name="ln170">  void TransitionToFailedState(MonitoredTaskState expected, const Status&amp; status);</a>
<a name="ln171"> </a>
<a name="ln172">  virtual void Finished(const Status&amp; status) {}</a>
<a name="ln173"> </a>
<a name="ln174">  void AbortTask(const Status&amp; status);</a>
<a name="ln175"> </a>
<a name="ln176">  virtual MonoTime ComputeDeadline();</a>
<a name="ln177">  // Callback meant to be invoked from asynchronous RPC service proxy calls.</a>
<a name="ln178">  void RpcCallback();</a>
<a name="ln179"> </a>
<a name="ln180">  auto BindRpcCallback() {</a>
<a name="ln181">    return std::bind(&amp;RetryingTSRpcTask::RpcCallback, shared_from(this));</a>
<a name="ln182">  }</a>
<a name="ln183"> </a>
<a name="ln184">  // Handle the actual work of the RPC callback. This is run on the master's worker</a>
<a name="ln185">  // pool, rather than a reactor thread, so it may do blocking IO operations.</a>
<a name="ln186">  void DoRpcCallback();</a>
<a name="ln187"> </a>
<a name="ln188">  // Called when the async task unregisters either successfully or unsuccessfully.</a>
<a name="ln189">  virtual void UnregisterAsyncTaskCallback();</a>
<a name="ln190"> </a>
<a name="ln191">  Master* const master_;</a>
<a name="ln192">  ThreadPool* const callback_pool_;</a>
<a name="ln193">  const gscoped_ptr&lt;TSPicker&gt; replica_picker_;</a>
<a name="ln194">  const scoped_refptr&lt;TableInfo&gt; table_;</a>
<a name="ln195"> </a>
<a name="ln196">  MonoTime start_ts_;</a>
<a name="ln197">  MonoTime end_ts_;</a>
<a name="ln198">  MonoTime deadline_;</a>
<a name="ln199"> </a>
<a name="ln200">  int attempt_;</a>
<a name="ln201">  rpc::RpcController rpc_;</a>
<a name="ln202">  TSDescriptor* target_ts_desc_ = nullptr;</a>
<a name="ln203">  std::shared_ptr&lt;tserver::TabletServerServiceProxy&gt; ts_proxy_;</a>
<a name="ln204">  std::shared_ptr&lt;tserver::TabletServerAdminServiceProxy&gt; ts_admin_proxy_;</a>
<a name="ln205">  std::shared_ptr&lt;consensus::ConsensusServiceProxy&gt; consensus_proxy_;</a>
<a name="ln206"> </a>
<a name="ln207">  std::atomic&lt;rpc::ScheduledTaskId&gt; reactor_task_id_{rpc::kInvalidTaskId};</a>
<a name="ln208"> </a>
<a name="ln209">  // Mutex protecting calls to UnregisterAsyncTask to avoid races between Run and user triggered</a>
<a name="ln210">  // Aborts.</a>
<a name="ln211">  std::mutex unregister_mutex_;</a>
<a name="ln212"> </a>
<a name="ln213"> private:</a>
<a name="ln214">  // Returns true if we should impose a limit in the number of retries for this task type.</a>
<a name="ln215">  bool RetryLimitTaskType() {</a>
<a name="ln216">    return type() != ASYNC_CREATE_REPLICA &amp;&amp; type() != ASYNC_DELETE_REPLICA;</a>
<a name="ln217">  }</a>
<a name="ln218"> </a>
<a name="ln219">  // Returns true if we should not retry for this task type.</a>
<a name="ln220">  bool NoRetryTaskType() {</a>
<a name="ln221">    return type() == ASYNC_FLUSH_TABLETS;</a>
<a name="ln222">  }</a>
<a name="ln223"> </a>
<a name="ln224">  // Reschedules the current task after a backoff delay.</a>
<a name="ln225">  // Returns false if the task was not rescheduled due to reaching the maximum</a>
<a name="ln226">  // timeout or because the task is no longer in a running state.</a>
<a name="ln227">  // Returns true if rescheduling the task was successful.</a>
<a name="ln228">  bool RescheduleWithBackoffDelay();</a>
<a name="ln229"> </a>
<a name="ln230">  // Callback for Reactor delayed task mechanism. Called either when it is time</a>
<a name="ln231">  // to execute the delayed task (with status == OK) or when the task</a>
<a name="ln232">  // is cancelled, i.e. when the scheduling timer is shut down (status != OK).</a>
<a name="ln233">  void RunDelayedTask(const Status&amp; status);</a>
<a name="ln234"> </a>
<a name="ln235">  // Clean up request and release resources. May call 'delete this'.</a>
<a name="ln236">  void UnregisterAsyncTask();</a>
<a name="ln237"> </a>
<a name="ln238">  CHECKED_STATUS Failed(const Status&amp; status);</a>
<a name="ln239"> </a>
<a name="ln240">  // Only abort this task on reactor if it has been scheduled.</a>
<a name="ln241">  void AbortIfScheduled();</a>
<a name="ln242"> </a>
<a name="ln243">  virtual int num_max_retries();</a>
<a name="ln244">  virtual int max_delay_ms();</a>
<a name="ln245"> </a>
<a name="ln246">  // Use state() and MarkX() accessors.</a>
<a name="ln247">  std::atomic&lt;MonitoredTaskState&gt; state_;</a>
<a name="ln248">};</a>
<a name="ln249"> </a>
<a name="ln250">// RetryingTSRpcTask subclass which always retries the same tablet server,</a>
<a name="ln251">// identified by its UUID.</a>
<a name="ln252">class RetrySpecificTSRpcTask : public RetryingTSRpcTask {</a>
<a name="ln253"> public:</a>
<a name="ln254">  RetrySpecificTSRpcTask(Master* master,</a>
<a name="ln255">                         ThreadPool* callback_pool,</a>
<a name="ln256">                         const std::string&amp; permanent_uuid,</a>
<a name="ln257">                         const scoped_refptr&lt;TableInfo&gt;&amp; table)</a>
<a name="ln258">    : RetryingTSRpcTask(master,</a>
<a name="ln259">                        callback_pool,</a>
<a name="ln260">                        gscoped_ptr&lt;TSPicker&gt;(new PickSpecificUUID(master, permanent_uuid)),</a>
<a name="ln261">                        table),</a>
<a name="ln262">      permanent_uuid_(permanent_uuid) {</a>
<a name="ln263">  }</a>
<a name="ln264"> </a>
<a name="ln265"> protected:</a>
<a name="ln266">  const std::string permanent_uuid_;</a>
<a name="ln267">};</a>
<a name="ln268"> </a>
<a name="ln269">// RetryingTSRpcTask subclass which retries sending an RPC to a tablet leader.</a>
<a name="ln270">class AsyncTabletLeaderTask : public RetryingTSRpcTask {</a>
<a name="ln271"> public:</a>
<a name="ln272">  AsyncTabletLeaderTask(</a>
<a name="ln273">      Master* master, ThreadPool* callback_pool, const scoped_refptr&lt;TabletInfo&gt;&amp; tablet);</a>
<a name="ln274"> </a>
<a name="ln275">  AsyncTabletLeaderTask(</a>
<a name="ln276">      Master* master, ThreadPool* callback_pool, const scoped_refptr&lt;TabletInfo&gt;&amp; tablet,</a>
<a name="ln277">      const scoped_refptr&lt;TableInfo&gt;&amp; table);</a>
<a name="ln278"> </a>
<a name="ln279">  std::string description() const override;</a>
<a name="ln280"> </a>
<a name="ln281"> protected:</a>
<a name="ln282">  TabletServerId permanent_uuid() const;</a>
<a name="ln283">  TabletId tablet_id() const override;</a>
<a name="ln284"> </a>
<a name="ln285">  scoped_refptr&lt;TabletInfo&gt; tablet_;</a>
<a name="ln286">};</a>
<a name="ln287"> </a>
<a name="ln288">// Fire off the async create tablet.</a>
<a name="ln289">// This requires that the new tablet info is locked for write, and the</a>
<a name="ln290">// consensus configuration information has been filled into the 'dirty' data.</a>
<a name="ln291">class AsyncCreateReplica : public RetrySpecificTSRpcTask {</a>
<a name="ln292"> public:</a>
<a name="ln293">  AsyncCreateReplica(Master *master,</a>
<a name="ln294">                     ThreadPool *callback_pool,</a>
<a name="ln295">                     const std::string&amp; permanent_uuid,</a>
<a name="ln296">                     const scoped_refptr&lt;TabletInfo&gt;&amp; tablet);</a>
<a name="ln297"> </a>
<a name="ln298">  Type type() const override { return ASYNC_CREATE_REPLICA; }</a>
<a name="ln299"> </a>
<a name="ln300">  std::string type_name() const override { return &quot;Create Tablet&quot;; }</a>
<a name="ln301"> </a>
<a name="ln302">  std::string description() const override {</a>
<a name="ln303">    return &quot;CreateTablet RPC for tablet &quot; + tablet_id_ + &quot; on TS &quot; + permanent_uuid_;</a>
<a name="ln304">  }</a>
<a name="ln305"> </a>
<a name="ln306"> protected:</a>
<a name="ln307">  TabletId tablet_id() const override { return tablet_id_; }</a>
<a name="ln308"> </a>
<a name="ln309">  void HandleResponse(int attempt) override;</a>
<a name="ln310">  bool SendRequest(int attempt) override;</a>
<a name="ln311"> </a>
<a name="ln312"> private:</a>
<a name="ln313">  const TabletId tablet_id_;</a>
<a name="ln314">  tserver::CreateTabletRequestPB req_;</a>
<a name="ln315">  tserver::CreateTabletResponsePB resp_;</a>
<a name="ln316">};</a>
<a name="ln317"> </a>
<a name="ln318">// Send a DeleteTablet() RPC request.</a>
<a name="ln319">class AsyncDeleteReplica : public RetrySpecificTSRpcTask {</a>
<a name="ln320"> public:</a>
<a name="ln321">  AsyncDeleteReplica(</a>
<a name="ln322">      Master* master, ThreadPool* callback_pool, const std::string&amp; permanent_uuid,</a>
<a name="ln323">      const scoped_refptr&lt;TableInfo&gt;&amp; table, TabletId tablet_id,</a>
<a name="ln324">      tablet::TabletDataState delete_type,</a>
<a name="ln325">      boost::optional&lt;int64_t&gt; cas_config_opid_index_less_or_equal,</a>
<a name="ln326">      std::string reason)</a>
<a name="ln327">      : RetrySpecificTSRpcTask(master, callback_pool, permanent_uuid, table),</a>
<a name="ln328">        tablet_id_(std::move(tablet_id)),</a>
<a name="ln329">        delete_type_(delete_type),</a>
<a name="ln330">        cas_config_opid_index_less_or_equal_(</a>
<a name="ln331">            std::move(cas_config_opid_index_less_or_equal)),</a>
<a name="ln332">        reason_(std::move(reason)) {}</a>
<a name="ln333"> </a>
<a name="ln334">  Type type() const override { return ASYNC_DELETE_REPLICA; }</a>
<a name="ln335"> </a>
<a name="ln336">  std::string type_name() const override { return &quot;Delete Tablet&quot;; }</a>
<a name="ln337"> </a>
<a name="ln338">  std::string description() const override {</a>
<a name="ln339">    return &quot;Delete Tablet RPC for &quot; + tablet_id_ + &quot; on TS=&quot; + permanent_uuid_;</a>
<a name="ln340">  }</a>
<a name="ln341"> </a>
<a name="ln342"> protected:</a>
<a name="ln343">  TabletId tablet_id() const override { return tablet_id_; }</a>
<a name="ln344"> </a>
<a name="ln345">  void HandleResponse(int attempt) override;</a>
<a name="ln346">  bool SendRequest(int attempt) override;</a>
<a name="ln347">  void UnregisterAsyncTaskCallback() override;</a>
<a name="ln348"> </a>
<a name="ln349">  const TabletId tablet_id_;</a>
<a name="ln350">  const tablet::TabletDataState delete_type_;</a>
<a name="ln351">  const boost::optional&lt;int64_t&gt; cas_config_opid_index_less_or_equal_;</a>
<a name="ln352">  const std::string reason_;</a>
<a name="ln353">  tserver::DeleteTabletResponsePB resp_;</a>
<a name="ln354">};</a>
<a name="ln355"> </a>
<a name="ln356">// Send the &quot;Alter Table&quot; with the latest table schema to the leader replica</a>
<a name="ln357">// for the tablet.</a>
<a name="ln358">// Keeps retrying until we get an &quot;ok&quot; response.</a>
<a name="ln359">//  - Alter completed</a>
<a name="ln360">//  - Tablet has already a newer version</a>
<a name="ln361">//    (which may happen in case of concurrent alters, or in case a previous attempt timed</a>
<a name="ln362">//     out but was actually applied).</a>
<a name="ln363">class AsyncAlterTable : public AsyncTabletLeaderTask {</a>
<a name="ln364"> public:</a>
<a name="ln365">  AsyncAlterTable(</a>
<a name="ln366">      Master* master, ThreadPool* callback_pool, const scoped_refptr&lt;TabletInfo&gt;&amp; tablet)</a>
<a name="ln367">      : AsyncTabletLeaderTask(master, callback_pool, tablet) {}</a>
<a name="ln368"> </a>
<a name="ln369">  AsyncAlterTable(</a>
<a name="ln370">      Master* master, ThreadPool* callback_pool, const scoped_refptr&lt;TabletInfo&gt;&amp; tablet,</a>
<a name="ln371">      const scoped_refptr&lt;TableInfo&gt;&amp; table)</a>
<a name="ln372">      : AsyncTabletLeaderTask(master, callback_pool, tablet, table) {}</a>
<a name="ln373"> </a>
<a name="ln374">  Type type() const override { return ASYNC_ALTER_TABLE; }</a>
<a name="ln375"> </a>
<a name="ln376">  std::string type_name() const override { return &quot;Alter Table&quot;; }</a>
<a name="ln377"> </a>
<a name="ln378"> protected:</a>
<a name="ln379">  uint32_t schema_version_;</a>
<a name="ln380">  tserver::ChangeMetadataResponsePB resp_;</a>
<a name="ln381"> </a>
<a name="ln382"> private:</a>
<a name="ln383">  void HandleResponse(int attempt) override;</a>
<a name="ln384">  bool SendRequest(int attempt) override;</a>
<a name="ln385">};</a>
<a name="ln386"> </a>
<a name="ln387">class AsyncBackfillDone : public AsyncAlterTable {</a>
<a name="ln388"> public:</a>
<a name="ln389">  AsyncBackfillDone(</a>
<a name="ln390">      Master* master, ThreadPool* callback_pool, const scoped_refptr&lt;TabletInfo&gt;&amp; tablet)</a>
<a name="ln391">      : AsyncAlterTable(master, callback_pool, tablet) {}</a>
<a name="ln392"> </a>
<a name="ln393">  Type type() const override { return ASYNC_BACKFILL_DONE; }</a>
<a name="ln394"> </a>
<a name="ln395">  std::string type_name() const override { return &quot;Mark backfill done.&quot;; }</a>
<a name="ln396"> </a>
<a name="ln397"> private:</a>
<a name="ln398">  bool SendRequest(int attempt) override;</a>
<a name="ln399">};</a>
<a name="ln400"> </a>
<a name="ln401">class AsyncCopartitionTable : public RetryingTSRpcTask {</a>
<a name="ln402"> public:</a>
<a name="ln403">  AsyncCopartitionTable(Master *master,</a>
<a name="ln404">                        ThreadPool* callback_pool,</a>
<a name="ln405">                        const scoped_refptr&lt;TabletInfo&gt;&amp; tablet,</a>
<a name="ln406">                        const scoped_refptr&lt;TableInfo&gt;&amp; table);</a>
<a name="ln407"> </a>
<a name="ln408">  Type type() const override { return ASYNC_COPARTITION_TABLE; }</a>
<a name="ln409"> </a>
<a name="ln410">  std::string type_name() const override { return &quot;Copartition Table&quot;; }</a>
<a name="ln411"> </a>
<a name="ln412">  std::string description() const override;</a>
<a name="ln413"> </a>
<a name="ln414"> private:</a>
<a name="ln415">  TabletId tablet_id() const override;</a>
<a name="ln416"> </a>
<a name="ln417">  TabletServerId permanent_uuid() const;</a>
<a name="ln418"> </a>
<a name="ln419">  void HandleResponse(int attempt) override;</a>
<a name="ln420">  bool SendRequest(int attempt) override;</a>
<a name="ln421"> </a>
<a name="ln422">  scoped_refptr&lt;TabletInfo&gt; tablet_;</a>
<a name="ln423">  scoped_refptr&lt;TableInfo&gt; table_;</a>
<a name="ln424">  tserver::CopartitionTableResponsePB resp_;</a>
<a name="ln425">};</a>
<a name="ln426"> </a>
<a name="ln427">// Send a Truncate() RPC request.</a>
<a name="ln428">class AsyncTruncate : public AsyncTabletLeaderTask {</a>
<a name="ln429"> public:</a>
<a name="ln430">  AsyncTruncate(Master* master, ThreadPool* callback_pool, const scoped_refptr&lt;TabletInfo&gt;&amp; tablet)</a>
<a name="ln431">      : AsyncTabletLeaderTask(master, callback_pool, tablet) {}</a>
<a name="ln432"> </a>
<a name="ln433">  Type type() const override { return ASYNC_TRUNCATE_TABLET; }</a>
<a name="ln434"> </a>
<a name="ln435">  // TODO: Could move Type to the outer scope and use YB_DEFINE_ENUM for it. So type_name() could</a>
<a name="ln436">  // be removed.</a>
<a name="ln437">  std::string type_name() const override { return &quot;Truncate Tablet&quot;; }</a>
<a name="ln438"> </a>
<a name="ln439"> protected:</a>
<a name="ln440">  void HandleResponse(int attempt) override;</a>
<a name="ln441">  bool SendRequest(int attempt) override;</a>
<a name="ln442"> </a>
<a name="ln443">  tserver::TruncateResponsePB resp_;</a>
<a name="ln444">};</a>
<a name="ln445"> </a>
<a name="ln446">class CommonInfoForRaftTask : public RetryingTSRpcTask {</a>
<a name="ln447"> public:</a>
<a name="ln448">  CommonInfoForRaftTask(</a>
<a name="ln449">      Master* master, ThreadPool* callback_pool, const scoped_refptr&lt;TabletInfo&gt;&amp; tablet,</a>
<a name="ln450">      const consensus::ConsensusStatePB&amp; cstate, const std::string&amp; change_config_ts_uuid);</a>
<a name="ln451"> </a>
<a name="ln452">  TabletId tablet_id() const override;</a>
<a name="ln453"> </a>
<a name="ln454">  virtual std::string change_config_ts_uuid() const { return change_config_ts_uuid_; }</a>
<a name="ln455"> </a>
<a name="ln456"> protected:</a>
<a name="ln457">  // Used by SendOrReceiveData. Return's false if RPC should not be sent.</a>
<a name="ln458">  virtual CHECKED_STATUS PrepareRequest(int attempt) = 0;</a>
<a name="ln459"> </a>
<a name="ln460">  TabletServerId permanent_uuid() const;</a>
<a name="ln461"> </a>
<a name="ln462">  const scoped_refptr&lt;TabletInfo&gt; tablet_;</a>
<a name="ln463">  const consensus::ConsensusStatePB cstate_;</a>
<a name="ln464"> </a>
<a name="ln465">  // The uuid of the TabletServer we intend to change in the config, for example, the one we are</a>
<a name="ln466">  // adding to a new config, or the one we intend to remove from the current config.</a>
<a name="ln467">  //</a>
<a name="ln468">  // This is different from the target_ts_desc_, which points to the tablet server to whom we</a>
<a name="ln469">  // issue the ChangeConfig RPC call, which is the Leader in the case of this class, due to the</a>
<a name="ln470">  // PickLeaderReplica set in the constructor.</a>
<a name="ln471">  const std::string change_config_ts_uuid_;</a>
<a name="ln472">};</a>
<a name="ln473"> </a>
<a name="ln474">class AsyncChangeConfigTask : public CommonInfoForRaftTask {</a>
<a name="ln475"> public:</a>
<a name="ln476">  AsyncChangeConfigTask(</a>
<a name="ln477">      Master* master, ThreadPool* callback_pool, const scoped_refptr&lt;TabletInfo&gt;&amp; tablet,</a>
<a name="ln478">      const consensus::ConsensusStatePB&amp; cstate, const std::string&amp; change_config_ts_uuid)</a>
<a name="ln479">      : CommonInfoForRaftTask(master, callback_pool, tablet, cstate, change_config_ts_uuid) {}</a>
<a name="ln480"> </a>
<a name="ln481">  Type type() const override { return ASYNC_CHANGE_CONFIG; }</a>
<a name="ln482"> </a>
<a name="ln483">  std::string type_name() const override { return &quot;ChangeConfig&quot;; }</a>
<a name="ln484"> </a>
<a name="ln485">  std::string description() const override;</a>
<a name="ln486"> </a>
<a name="ln487"> protected:</a>
<a name="ln488">  void HandleResponse(int attempt) override;</a>
<a name="ln489">  bool SendRequest(int attempt) override;</a>
<a name="ln490"> </a>
<a name="ln491">  consensus::ChangeConfigRequestPB req_;</a>
<a name="ln492">  consensus::ChangeConfigResponsePB resp_;</a>
<a name="ln493">};</a>
<a name="ln494"> </a>
<a name="ln495">class AsyncAddServerTask : public AsyncChangeConfigTask {</a>
<a name="ln496"> public:</a>
<a name="ln497">  AsyncAddServerTask(</a>
<a name="ln498">      Master* master, ThreadPool* callback_pool, const scoped_refptr&lt;TabletInfo&gt;&amp; tablet,</a>
<a name="ln499">      consensus::RaftPeerPB::MemberType member_type, const consensus::ConsensusStatePB&amp; cstate,</a>
<a name="ln500">      const std::string&amp; change_config_ts_uuid)</a>
<a name="ln501">      : AsyncChangeConfigTask(master, callback_pool, tablet, cstate, change_config_ts_uuid),</a>
<a name="ln502">        member_type_(member_type) {}</a>
<a name="ln503"> </a>
<a name="ln504">  Type type() const override { return ASYNC_ADD_SERVER; }</a>
<a name="ln505"> </a>
<a name="ln506">  std::string type_name() const override { return &quot;AddServer ChangeConfig&quot;; }</a>
<a name="ln507"> </a>
<a name="ln508">  bool started_by_lb() const override { return true; }</a>
<a name="ln509"> </a>
<a name="ln510"> protected:</a>
<a name="ln511">  CHECKED_STATUS PrepareRequest(int attempt) override;</a>
<a name="ln512"> </a>
<a name="ln513"> private:</a>
<a name="ln514">  // PRE_VOTER or PRE_OBSERVER (for async replicas).</a>
<a name="ln515">  consensus::RaftPeerPB::MemberType member_type_;</a>
<a name="ln516">};</a>
<a name="ln517"> </a>
<a name="ln518">// Task to remove a tablet server peer from an overly-replicated tablet config.</a>
<a name="ln519">class AsyncRemoveServerTask : public AsyncChangeConfigTask {</a>
<a name="ln520"> public:</a>
<a name="ln521">  AsyncRemoveServerTask(</a>
<a name="ln522">      Master* master, ThreadPool* callback_pool, const scoped_refptr&lt;TabletInfo&gt;&amp; tablet,</a>
<a name="ln523">      const consensus::ConsensusStatePB&amp; cstate, const std::string&amp; change_config_ts_uuid)</a>
<a name="ln524">      : AsyncChangeConfigTask(master, callback_pool, tablet, cstate, change_config_ts_uuid) {}</a>
<a name="ln525"> </a>
<a name="ln526">  Type type() const override { return ASYNC_REMOVE_SERVER; }</a>
<a name="ln527"> </a>
<a name="ln528">  std::string type_name() const override { return &quot;RemoveServer ChangeConfig&quot;; }</a>
<a name="ln529"> </a>
<a name="ln530">  bool started_by_lb() const override { return true; }</a>
<a name="ln531"> </a>
<a name="ln532"> protected:</a>
<a name="ln533">  CHECKED_STATUS PrepareRequest(int attempt) override;</a>
<a name="ln534">};</a>
<a name="ln535"> </a>
<a name="ln536">// Task to step down tablet server leader and optionally to remove it from an overly-replicated</a>
<a name="ln537">// tablet config.</a>
<a name="ln538">class AsyncTryStepDown : public CommonInfoForRaftTask {</a>
<a name="ln539"> public:</a>
<a name="ln540">  AsyncTryStepDown(</a>
<a name="ln541">      Master* master,</a>
<a name="ln542">      ThreadPool* callback_pool,</a>
<a name="ln543">      const scoped_refptr&lt;TabletInfo&gt;&amp; tablet,</a>
<a name="ln544">      const consensus::ConsensusStatePB&amp; cstate,</a>
<a name="ln545">      const std::string&amp; change_config_ts_uuid,</a>
<a name="ln546">      bool should_remove,</a>
<a name="ln547">      const std::string&amp; new_leader_uuid = &quot;&quot;)</a>
<a name="ln548">      : CommonInfoForRaftTask(master, callback_pool, tablet, cstate, change_config_ts_uuid),</a>
<a name="ln549">        should_remove_(should_remove),</a>
<a name="ln550">        new_leader_uuid_(new_leader_uuid) {}</a>
<a name="ln551"> </a>
<a name="ln552">  Type type() const override { return ASYNC_TRY_STEP_DOWN; }</a>
<a name="ln553"> </a>
<a name="ln554">  std::string type_name() const override { return &quot;Stepdown Leader&quot;; }</a>
<a name="ln555"> </a>
<a name="ln556">  std::string description() const override {</a>
<a name="ln557">    return &quot;Async Leader Stepdown&quot;;</a>
<a name="ln558">  }</a>
<a name="ln559"> </a>
<a name="ln560">  std::string new_leader_uuid() const { return new_leader_uuid_; }</a>
<a name="ln561"> </a>
<a name="ln562">  bool started_by_lb() const override { return true; }</a>
<a name="ln563"> </a>
<a name="ln564"> protected:</a>
<a name="ln565">  CHECKED_STATUS PrepareRequest(int attempt) override;</a>
<a name="ln566">  bool SendRequest(int attempt) override;</a>
<a name="ln567">  void HandleResponse(int attempt) override;</a>
<a name="ln568"> </a>
<a name="ln569">  const bool should_remove_;</a>
<a name="ln570">  const std::string new_leader_uuid_;</a>
<a name="ln571">  consensus::LeaderStepDownRequestPB stepdown_req_;</a>
<a name="ln572">  consensus::LeaderStepDownResponsePB stepdown_resp_;</a>
<a name="ln573">};</a>
<a name="ln574"> </a>
<a name="ln575">// Task to add a table to a tablet. Catalog Manager uses this task to send the request to the</a>
<a name="ln576">// tserver admin service.</a>
<a name="ln577">class AsyncAddTableToTablet : public RetryingTSRpcTask {</a>
<a name="ln578"> public:</a>
<a name="ln579">  AsyncAddTableToTablet(</a>
<a name="ln580">      Master* master, ThreadPool* callback_pool, const scoped_refptr&lt;TabletInfo&gt;&amp; tablet,</a>
<a name="ln581">      const scoped_refptr&lt;TableInfo&gt;&amp; table);</a>
<a name="ln582"> </a>
<a name="ln583">  Type type() const override { return ASYNC_ADD_TABLE_TO_TABLET; }</a>
<a name="ln584"> </a>
<a name="ln585">  std::string type_name() const override { return &quot;Add Table to Tablet&quot;; }</a>
<a name="ln586"> </a>
<a name="ln587">  std::string description() const override;</a>
<a name="ln588"> </a>
<a name="ln589"> private:</a>
<a name="ln590">  TabletId tablet_id() const override { return tablet_id_; }</a>
<a name="ln591"> </a>
<a name="ln592">  void HandleResponse(int attempt) override;</a>
<a name="ln593">  bool SendRequest(int attempt) override;</a>
<a name="ln594"> </a>
<a name="ln595">  scoped_refptr&lt;TabletInfo&gt; tablet_;</a>
<a name="ln596">  scoped_refptr&lt;TableInfo&gt; table_;</a>
<a name="ln597">  const TabletId tablet_id_;</a>
<a name="ln598">  tserver::AddTableToTabletRequestPB req_;</a>
<a name="ln599">  tserver::AddTableToTabletResponsePB resp_;</a>
<a name="ln600">};</a>
<a name="ln601"> </a>
<a name="ln602">// Task to remove a table from a tablet. Catalog Manager uses this task to send the request to the</a>
<a name="ln603">// tserver admin service.</a>
<a name="ln604">class AsyncRemoveTableFromTablet : public RetryingTSRpcTask {</a>
<a name="ln605"> public:</a>
<a name="ln606">  AsyncRemoveTableFromTablet(</a>
<a name="ln607">      Master* master, ThreadPool* callback_pool, const scoped_refptr&lt;TabletInfo&gt;&amp; tablet,</a>
<a name="ln608">      const scoped_refptr&lt;TableInfo&gt;&amp; table);</a>
<a name="ln609"> </a>
<a name="ln610">  Type type() const override { return ASYNC_REMOVE_TABLE_FROM_TABLET; }</a>
<a name="ln611"> </a>
<a name="ln612">  std::string type_name() const override { return &quot;Remove Table from Tablet&quot;; }</a>
<a name="ln613"> </a>
<a name="ln614">  std::string description() const override;</a>
<a name="ln615"> </a>
<a name="ln616"> private:</a>
<a name="ln617">  TabletId tablet_id() const override { return tablet_id_; }</a>
<a name="ln618"> </a>
<a name="ln619">  bool SendRequest(int attempt) override;</a>
<a name="ln620">  void HandleResponse(int attempt) override;</a>
<a name="ln621"> </a>
<a name="ln622">  const scoped_refptr&lt;TableInfo&gt; table_;</a>
<a name="ln623">  const scoped_refptr&lt;TabletInfo&gt; tablet_;</a>
<a name="ln624">  const TabletId tablet_id_;</a>
<a name="ln625">  tserver::RemoveTableFromTabletRequestPB req_;</a>
<a name="ln626">  tserver::RemoveTableFromTabletResponsePB resp_;</a>
<a name="ln627">};</a>
<a name="ln628"> </a>
<a name="ln629">// Sends SplitTabletRequest with provided arguments to the service interface of the leader of the</a>
<a name="ln630">// tablet.</a>
<a name="ln631">class AsyncSplitTablet : public AsyncTabletLeaderTask {</a>
<a name="ln632"> public:</a>
<a name="ln633">  AsyncSplitTablet(</a>
<a name="ln634">      Master* master, ThreadPool* callback_pool, const scoped_refptr&lt;TabletInfo&gt;&amp; tablet,</a>
<a name="ln635">      const std::array&lt;TabletId, 2&gt;&amp; new_tablet_ids, const std::string&amp; split_encoded_key,</a>
<a name="ln636">      const std::string&amp; split_partition_key);</a>
<a name="ln637"> </a>
<a name="ln638">  Type type() const override { return ASYNC_SPLIT_TABLET; }</a>
<a name="ln639"> </a>
<a name="ln640">  std::string type_name() const override { return &quot;Split Tablet&quot;; }</a>
<a name="ln641"> </a>
<a name="ln642"> protected:</a>
<a name="ln643">  void HandleResponse(int attempt) override;</a>
<a name="ln644">  bool SendRequest(int attempt) override;</a>
<a name="ln645"> </a>
<a name="ln646">  tserver::SplitTabletRequestPB req_;</a>
<a name="ln647">  tserver::SplitTabletResponsePB resp_;</a>
<a name="ln648">};</a>
<a name="ln649"> </a>
<a name="ln650">} // namespace master</a>
<a name="ln651">} // namespace yb</a>
<a name="ln652"> </a>
<a name="ln653">#endif // YB_MASTER_ASYNC_RPC_TASKS_H</a>

</code></pre>
<div class="balloon" rel="365"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: schema_version_.</p></div>
<div class="balloon" rel="369"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: schema_version_.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
