
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>docdb.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Copyright (c) YugaByte, Inc.</a>
<a name="ln2">//</a>
<a name="ln3">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln4">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln5">//</a>
<a name="ln6">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln7">//</a>
<a name="ln8">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln9">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln10">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln11">// under the License.</a>
<a name="ln12">//</a>
<a name="ln13"> </a>
<a name="ln14">#include &lt;algorithm&gt;</a>
<a name="ln15">#include &lt;memory&gt;</a>
<a name="ln16">#include &lt;stack&gt;</a>
<a name="ln17">#include &lt;string&gt;</a>
<a name="ln18">#include &lt;unordered_map&gt;</a>
<a name="ln19">#include &lt;vector&gt;</a>
<a name="ln20"> </a>
<a name="ln21">#include &quot;yb/common/hybrid_time.h&quot;</a>
<a name="ln22">#include &quot;yb/common/redis_protocol.pb.h&quot;</a>
<a name="ln23">#include &quot;yb/common/row_mark.h&quot;</a>
<a name="ln24">#include &quot;yb/common/transaction.h&quot;</a>
<a name="ln25"> </a>
<a name="ln26">#include &quot;yb/docdb/conflict_resolution.h&quot;</a>
<a name="ln27">#include &quot;yb/docdb/cql_operation.h&quot;</a>
<a name="ln28">#include &quot;yb/docdb/doc_ttl_util.h&quot;</a>
<a name="ln29">#include &quot;yb/docdb/docdb-internal.h&quot;</a>
<a name="ln30">#include &quot;yb/docdb/docdb.h&quot;</a>
<a name="ln31">#include &quot;yb/docdb/docdb.pb.h&quot;</a>
<a name="ln32">#include &quot;yb/docdb/docdb_debug.h&quot;</a>
<a name="ln33">#include &quot;yb/docdb/docdb_compaction_filter.h&quot;</a>
<a name="ln34">#include &quot;yb/docdb/docdb_rocksdb_util.h&quot;</a>
<a name="ln35">#include &quot;yb/docdb/docdb_util.h&quot;</a>
<a name="ln36">#include &quot;yb/docdb/intent.h&quot;</a>
<a name="ln37">#include &quot;yb/docdb/intent_aware_iterator.h&quot;</a>
<a name="ln38">#include &quot;yb/docdb/pgsql_operation.h&quot;</a>
<a name="ln39">#include &quot;yb/docdb/shared_lock_manager.h&quot;</a>
<a name="ln40">#include &quot;yb/docdb/subdocument.h&quot;</a>
<a name="ln41">#include &quot;yb/docdb/value.h&quot;</a>
<a name="ln42">#include &quot;yb/docdb/value_type.h&quot;</a>
<a name="ln43">#include &quot;yb/docdb/deadline_info.h&quot;</a>
<a name="ln44">#include &quot;yb/docdb/docdb_types.h&quot;</a>
<a name="ln45">#include &quot;yb/docdb/kv_debug.h&quot;</a>
<a name="ln46"> </a>
<a name="ln47">#include &quot;yb/gutil/strings/substitute.h&quot;</a>
<a name="ln48">#include &quot;yb/rocksutil/write_batch_formatter.h&quot;</a>
<a name="ln49">#include &quot;yb/rocksutil/yb_rocksdb.h&quot;</a>
<a name="ln50">#include &quot;yb/server/hybrid_clock.h&quot;</a>
<a name="ln51"> </a>
<a name="ln52">#include &quot;yb/util/bitmap.h&quot;</a>
<a name="ln53">#include &quot;yb/util/bytes_formatter.h&quot;</a>
<a name="ln54">#include &quot;yb/util/date_time.h&quot;</a>
<a name="ln55">#include &quot;yb/util/enums.h&quot;</a>
<a name="ln56">#include &quot;yb/util/flag_tags.h&quot;</a>
<a name="ln57">#include &quot;yb/util/logging.h&quot;</a>
<a name="ln58">#include &quot;yb/util/metrics.h&quot;</a>
<a name="ln59">#include &quot;yb/util/pb_util.h&quot;</a>
<a name="ln60">#include &quot;yb/util/status.h&quot;</a>
<a name="ln61"> </a>
<a name="ln62">#include &quot;yb/yql/cql/ql/util/errcodes.h&quot;</a>
<a name="ln63"> </a>
<a name="ln64">using std::endl;</a>
<a name="ln65">using std::list;</a>
<a name="ln66">using std::string;</a>
<a name="ln67">using std::stringstream;</a>
<a name="ln68">using std::unique_ptr;</a>
<a name="ln69">using std::shared_ptr;</a>
<a name="ln70">using std::stack;</a>
<a name="ln71">using std::vector;</a>
<a name="ln72">using std::make_shared;</a>
<a name="ln73"> </a>
<a name="ln74">using yb::HybridTime;</a>
<a name="ln75">using yb::FormatBytesAsStr;</a>
<a name="ln76">using strings::Substitute;</a>
<a name="ln77"> </a>
<a name="ln78">using namespace std::placeholders;</a>
<a name="ln79"> </a>
<a name="ln80">DEFINE_test_flag(bool, docdb_sort_weak_intents_in_tests, false,</a>
<a name="ln81">                &quot;Sort weak intents to make their order deterministic.&quot;);</a>
<a name="ln82">DEFINE_bool(enable_transaction_sealing, false,</a>
<a name="ln83">            &quot;Whether transaction sealing is enabled.&quot;);</a>
<a name="ln84">DEFINE_test_flag(bool, fail_on_replicated_batch_idx_set_in_txn_record, false,</a>
<a name="ln85">                 &quot;Fail when a set of replicated batch indexes is found in txn record.&quot;);</a>
<a name="ln86">DEFINE_int32(txn_max_apply_batch_records, 100000,</a>
<a name="ln87">             &quot;Max number of apply records allowed in single RocksDB batch. &quot;</a>
<a name="ln88">             &quot;When a transaction's data in one tablet does not fit into specified number of &quot;</a>
<a name="ln89">             &quot;records, it will be applied using multiple RocksDB write batches.&quot;);</a>
<a name="ln90"> </a>
<a name="ln91">namespace yb {</a>
<a name="ln92">namespace docdb {</a>
<a name="ln93"> </a>
<a name="ln94">namespace {</a>
<a name="ln95"> </a>
<a name="ln96">// Slice parts with the number of slices fixed at compile time.</a>
<a name="ln97">template &lt;int N&gt;</a>
<a name="ln98">struct FixedSliceParts {</a>
<a name="ln99">  FixedSliceParts(const std::array&lt;Slice, N&gt;&amp; input) : parts(input.data()) { // NOLINT</a>
<a name="ln100">  }</a>
<a name="ln101"> </a>
<a name="ln102">  operator SliceParts() const {</a>
<a name="ln103">    return SliceParts(parts, N);</a>
<a name="ln104">  }</a>
<a name="ln105"> </a>
<a name="ln106">  const Slice* parts;</a>
<a name="ln107">};</a>
<a name="ln108"> </a>
<a name="ln109">// Main intent data::</a>
<a name="ln110">// Prefix + DocPath + IntentType + DocHybridTime -&gt; TxnId + value of the intent</a>
<a name="ln111">// Reverse index by txn id:</a>
<a name="ln112">// Prefix + TxnId + DocHybridTime -&gt; Main intent data key</a>
<a name="ln113">//</a>
<a name="ln114">// Expects that last entry of key is DocHybridTime.</a>
<a name="ln115">template &lt;int N&gt;</a>
<a name="ln116">void AddIntent(</a>
<a name="ln117">    const TransactionId&amp; transaction_id,</a>
<a name="ln118">    const FixedSliceParts&lt;N&gt;&amp; key,</a>
<a name="ln119">    const SliceParts&amp; value,</a>
<a name="ln120">    rocksdb::WriteBatch* rocksdb_write_batch,</a>
<a name="ln121">    Slice reverse_value_prefix = Slice()) {</a>
<a name="ln122">  char reverse_key_prefix[1] = { ValueTypeAsChar::kTransactionId };</a>
<a name="ln123">  size_t doc_ht_buffer[kMaxWordsPerEncodedHybridTimeWithValueType];</a>
<a name="ln124">  auto doc_ht_slice = key.parts[N - 1];</a>
<a name="ln125">  memcpy(doc_ht_buffer, doc_ht_slice.data(), doc_ht_slice.size());</a>
<a name="ln126">  for (size_t i = 0; i != kMaxWordsPerEncodedHybridTimeWithValueType; ++i) {</a>
<a name="ln127">    doc_ht_buffer[i] = ~doc_ht_buffer[i];</a>
<a name="ln128">  }</a>
<a name="ln129">  doc_ht_slice = Slice(pointer_cast&lt;char*&gt;(doc_ht_buffer), doc_ht_slice.size());</a>
<a name="ln130"> </a>
<a name="ln131">  std::array&lt;Slice, 3&gt; reverse_key = {{</a>
<a name="ln132">      Slice(reverse_key_prefix, sizeof(reverse_key_prefix)),</a>
<a name="ln133">      transaction_id.AsSlice(),</a>
<a name="ln134">      doc_ht_slice,</a>
<a name="ln135">  }};</a>
<a name="ln136">  rocksdb_write_batch-&gt;Put(key, value);</a>
<a name="ln137">  if (reverse_value_prefix.empty()) {</a>
<a name="ln138">    rocksdb_write_batch-&gt;Put(reverse_key, key);</a>
<a name="ln139">  } else {</a>
<a name="ln140">    std::array&lt;Slice, N + 1&gt; reverse_value;</a>
<a name="ln141">    reverse_value[0] = reverse_value_prefix;</a>
<a name="ln142">    memcpy(&amp;reverse_value[1], key.parts, sizeof(*key.parts) * N);</a>
<a name="ln143">    rocksdb_write_batch-&gt;Put(reverse_key, reverse_value);</a>
<a name="ln144">  }</a>
<a name="ln145">}</a>
<a name="ln146"> </a>
<a name="ln147">// key should be valid prefix of doc key, ending with some complete pritimive value or group end.</a>
<a name="ln148">CHECKED_STATUS ApplyIntent(RefCntPrefix key,</a>
<a name="ln149">                           const IntentTypeSet intent_types,</a>
<a name="ln150">                           LockBatchEntries *keys_locked) {</a>
<a name="ln151">  // Have to strip kGroupEnd from end of key, because when only hash key is specified, we will</a>
<a name="ln152">  // get two kGroupEnd at end of strong intent.</a>
<a name="ln153">  size_t size = key.size();</a>
<a name="ln154">  if (size &gt; 0) {</a>
<a name="ln155">    if (key.data()[0] == ValueTypeAsChar::kGroupEnd) {</a>
<a name="ln156">      if (size != 1) {</a>
<a name="ln157">        return STATUS_FORMAT(Corruption, &quot;Key starting with group end: $0&quot;,</a>
<a name="ln158">            key.as_slice().ToDebugHexString());</a>
<a name="ln159">      }</a>
<a name="ln160">      size = 0;</a>
<a name="ln161">    } else {</a>
<a name="ln162">      while (key.data()[size - 1] == ValueTypeAsChar::kGroupEnd) {</a>
<a name="ln163">        --size;</a>
<a name="ln164">      }</a>
<a name="ln165">    }</a>
<a name="ln166">  }</a>
<a name="ln167">  key.Resize(size);</a>
<a name="ln168">  keys_locked-&gt;push_back({key, intent_types});</a>
<a name="ln169">  return Status::OK();</a>
<a name="ln170">}</a>
<a name="ln171"> </a>
<a name="ln172">struct DetermineKeysToLockResult {</a>
<a name="ln173">  LockBatchEntries lock_batch;</a>
<a name="ln174">  bool need_read_snapshot;</a>
<a name="ln175">};</a>
<a name="ln176"> </a>
<a name="ln177">Result&lt;DetermineKeysToLockResult&gt; DetermineKeysToLock(</a>
<a name="ln178">    const std::vector&lt;std::unique_ptr&lt;DocOperation&gt;&gt;&amp; doc_write_ops,</a>
<a name="ln179">    const google::protobuf::RepeatedPtrField&lt;KeyValuePairPB&gt;&amp; read_pairs,</a>
<a name="ln180">    const IsolationLevel isolation_level,</a>
<a name="ln181">    const OperationKind operation_kind,</a>
<a name="ln182">    const RowMarkType row_mark_type,</a>
<a name="ln183">    bool transactional_table,</a>
<a name="ln184">    PartialRangeKeyIntents partial_range_key_intents) {</a>
<a name="ln185">  DetermineKeysToLockResult result;</a>
<a name="ln186">  boost::container::small_vector&lt;RefCntPrefix, 8&gt; doc_paths;</a>
<a name="ln187">  boost::container::small_vector&lt;size_t, 32&gt; key_prefix_lengths;</a>
<a name="ln188">  result.need_read_snapshot = false;</a>
<a name="ln189">  for (const unique_ptr&lt;DocOperation&gt;&amp; doc_op : doc_write_ops) {</a>
<a name="ln190">    doc_paths.clear();</a>
<a name="ln191">    IsolationLevel level;</a>
<a name="ln192">    RETURN_NOT_OK(doc_op-&gt;GetDocPaths(GetDocPathsMode::kLock, &amp;doc_paths, &amp;level));</a>
<a name="ln193">    if (isolation_level != IsolationLevel::NON_TRANSACTIONAL) {</a>
<a name="ln194">      level = isolation_level;</a>
<a name="ln195">    }</a>
<a name="ln196">    IntentTypeSet strong_intent_types = GetStrongIntentTypeSet(level, operation_kind,</a>
<a name="ln197">                                                               row_mark_type);</a>
<a name="ln198">    if (isolation_level == IsolationLevel::SERIALIZABLE_ISOLATION &amp;&amp;</a>
<a name="ln199">        operation_kind == OperationKind::kWrite &amp;&amp;</a>
<a name="ln200">        doc_op-&gt;RequireReadSnapshot()) {</a>
<a name="ln201">      strong_intent_types = IntentTypeSet({IntentType::kStrongRead, IntentType::kStrongWrite});</a>
<a name="ln202">    }</a>
<a name="ln203"> </a>
<a name="ln204">    for (const auto&amp; doc_path : doc_paths) {</a>
<a name="ln205">      key_prefix_lengths.clear();</a>
<a name="ln206">      RETURN_NOT_OK(SubDocKey::DecodePrefixLengths(doc_path.as_slice(), &amp;key_prefix_lengths));</a>
<a name="ln207">      // At least entire doc_path should be returned, so empty key_prefix_lengths is an error.</a>
<a name="ln208">      if (key_prefix_lengths.empty()) {</a>
<a name="ln209">        return STATUS_FORMAT(Corruption, &quot;Unable to decode key prefixes from: $0&quot;,</a>
<a name="ln210">                             doc_path.as_slice().ToDebugHexString());</a>
<a name="ln211">      }</a>
<a name="ln212">      // We will acquire strong lock on entire doc_path, so remove it from list of weak locks.</a>
<a name="ln213">      key_prefix_lengths.pop_back();</a>
<a name="ln214">      auto partial_key = doc_path;</a>
<a name="ln215">      // Acquire weak lock on empty key for transactional tables,</a>
<a name="ln216">      // unless specified key is already empty.</a>
<a name="ln217">      if (doc_path.size() &gt; 0 &amp;&amp; transactional_table) {</a>
<a name="ln218">        partial_key.Resize(0);</a>
<a name="ln219">        RETURN_NOT_OK(ApplyIntent(</a>
<a name="ln220">            partial_key, StrongToWeak(strong_intent_types), &amp;result.lock_batch));</a>
<a name="ln221">      }</a>
<a name="ln222">      for (size_t prefix_length : key_prefix_lengths) {</a>
<a name="ln223">        partial_key.Resize(prefix_length);</a>
<a name="ln224">        RETURN_NOT_OK(ApplyIntent(</a>
<a name="ln225">            partial_key, StrongToWeak(strong_intent_types), &amp;result.lock_batch));</a>
<a name="ln226">      }</a>
<a name="ln227"> </a>
<a name="ln228">      RETURN_NOT_OK(ApplyIntent(doc_path, strong_intent_types, &amp;result.lock_batch));</a>
<a name="ln229">    }</a>
<a name="ln230"> </a>
<a name="ln231">    if (doc_op-&gt;RequireReadSnapshot()) {</a>
<a name="ln232">      result.need_read_snapshot = true;</a>
<a name="ln233">    }</a>
<a name="ln234">  }</a>
<a name="ln235"> </a>
<a name="ln236">  if (!read_pairs.empty()) {</a>
<a name="ln237">    RETURN_NOT_OK(EnumerateIntents(</a>
<a name="ln238">        read_pairs,</a>
<a name="ln239">        [&amp;result](IntentStrength strength, Slice value, KeyBytes* key, LastKey) {</a>
<a name="ln240">          RefCntPrefix prefix(key-&gt;AsSlice());</a>
<a name="ln241">          auto intent_types = strength == IntentStrength::kStrong</a>
<a name="ln242">              ? IntentTypeSet({IntentType::kStrongRead})</a>
<a name="ln243">              : IntentTypeSet({IntentType::kWeakRead});</a>
<a name="ln244">          return ApplyIntent(prefix, intent_types, &amp;result.lock_batch);</a>
<a name="ln245">        }, partial_range_key_intents));</a>
<a name="ln246">  }</a>
<a name="ln247"> </a>
<a name="ln248">  return result;</a>
<a name="ln249">}</a>
<a name="ln250"> </a>
<a name="ln251">void FilterKeysToLock(LockBatchEntries *keys_locked) {</a>
<a name="ln252">  if (keys_locked-&gt;empty()) {</a>
<a name="ln253">    return;</a>
<a name="ln254">  }</a>
<a name="ln255"> </a>
<a name="ln256">  std::sort(keys_locked-&gt;begin(), keys_locked-&gt;end(),</a>
<a name="ln257">            [](const auto&amp; lhs, const auto&amp; rhs) {</a>
<a name="ln258">              return lhs.key &lt; rhs.key;</a>
<a name="ln259">            });</a>
<a name="ln260"> </a>
<a name="ln261">  auto w = keys_locked-&gt;begin();</a>
<a name="ln262">  for (auto it = keys_locked-&gt;begin(); ++it != keys_locked-&gt;end();) {</a>
<a name="ln263">    if (it-&gt;key == w-&gt;key) {</a>
<a name="ln264">      w-&gt;intent_types |= it-&gt;intent_types;</a>
<a name="ln265">    } else {</a>
<a name="ln266">      ++w;</a>
<a name="ln267">      *w = *it;</a>
<a name="ln268">    }</a>
<a name="ln269">  }</a>
<a name="ln270"> </a>
<a name="ln271">  ++w;</a>
<a name="ln272">  keys_locked-&gt;erase(w, keys_locked-&gt;end());</a>
<a name="ln273">}</a>
<a name="ln274"> </a>
<a name="ln275">// Buffer for encoding DocHybridTime</a>
<a name="ln276">class DocHybridTimeBuffer {</a>
<a name="ln277"> public:</a>
<a name="ln278">  DocHybridTimeBuffer() {</a>
<a name="ln279">    buffer_[0] = ValueTypeAsChar::kHybridTime;</a>
<a name="ln280">  }</a>
<a name="ln281"> </a>
<a name="ln282">  Slice EncodeWithValueType(const DocHybridTime&amp; doc_ht) {</a>
<a name="ln283">    auto end = doc_ht.EncodedInDocDbFormat(buffer_.data() + 1);</a>
<a name="ln284">    return Slice(buffer_.data(), end);</a>
<a name="ln285">  }</a>
<a name="ln286"> </a>
<a name="ln287">  Slice EncodeWithValueType(HybridTime ht, IntraTxnWriteId write_id) {</a>
<a name="ln288">    return EncodeWithValueType(DocHybridTime(ht, write_id));</a>
<a name="ln289">  }</a>
<a name="ln290"> private:</a>
<a name="ln291">  std::array&lt;char, 1 + kMaxBytesPerEncodedHybridTime&gt; buffer_;</a>
<a name="ln292">};</a>
<a name="ln293"> </a>
<a name="ln294">}  // namespace</a>
<a name="ln295"> </a>
<a name="ln296">Result&lt;PrepareDocWriteOperationResult&gt; PrepareDocWriteOperation(</a>
<a name="ln297">    const std::vector&lt;std::unique_ptr&lt;DocOperation&gt;&gt;&amp; doc_write_ops,</a>
<a name="ln298">    const google::protobuf::RepeatedPtrField&lt;KeyValuePairPB&gt;&amp; read_pairs,</a>
<a name="ln299">    const scoped_refptr&lt;Histogram&gt;&amp; write_lock_latency,</a>
<a name="ln300">    const IsolationLevel isolation_level,</a>
<a name="ln301">    const OperationKind operation_kind,</a>
<a name="ln302">    const RowMarkType row_mark_type,</a>
<a name="ln303">    bool transactional_table,</a>
<a name="ln304">    CoarseTimePoint deadline,</a>
<a name="ln305">    PartialRangeKeyIntents partial_range_key_intents,</a>
<a name="ln306">    SharedLockManager *lock_manager) {</a>
<a name="ln307">  PrepareDocWriteOperationResult result;</a>
<a name="ln308"> </a>
<a name="ln309">  auto determine_keys_to_lock_result = VERIFY_RESULT(DetermineKeysToLock(</a>
<a name="ln310">      doc_write_ops, read_pairs, isolation_level, operation_kind, row_mark_type,</a>
<a name="ln311">      transactional_table, partial_range_key_intents));</a>
<a name="ln312">  if (determine_keys_to_lock_result.lock_batch.empty()) {</a>
<a name="ln313">    LOG(ERROR) &lt;&lt; &quot;Empty lock batch, doc_write_ops: &quot; &lt;&lt; yb::ToString(doc_write_ops)</a>
<a name="ln314">               &lt;&lt; &quot;, read pairs: &quot; &lt;&lt; yb::ToString(read_pairs);</a>
<a name="ln315">    return STATUS(Corruption, &quot;Empty lock batch&quot;);</a>
<a name="ln316">  }</a>
<a name="ln317">  result.need_read_snapshot = determine_keys_to_lock_result.need_read_snapshot;</a>
<a name="ln318"> </a>
<a name="ln319">  FilterKeysToLock(&amp;determine_keys_to_lock_result.lock_batch);</a>
<a name="ln320">  const MonoTime start_time = (write_lock_latency != nullptr) ? MonoTime::Now() : MonoTime();</a>
<a name="ln321">  result.lock_batch = LockBatch(</a>
<a name="ln322">      lock_manager, std::move(determine_keys_to_lock_result.lock_batch), deadline);</a>
<a name="ln323">  RETURN_NOT_OK_PREPEND(</a>
<a name="ln324">      result.lock_batch.status(), Format(&quot;Timeout: $0&quot;, deadline - ToCoarse(start_time)));</a>
<a name="ln325">  if (write_lock_latency != nullptr) {</a>
<a name="ln326">    const MonoDelta elapsed_time = MonoTime::Now().GetDeltaSince(start_time);</a>
<a name="ln327">    write_lock_latency-&gt;Increment(elapsed_time.ToMicroseconds());</a>
<a name="ln328">  }</a>
<a name="ln329"> </a>
<a name="ln330">  return result;</a>
<a name="ln331">}</a>
<a name="ln332"> </a>
<a name="ln333">Status SetDocOpQLErrorResponse(DocOperation* doc_op, string err_msg) {</a>
<a name="ln334">  switch (doc_op-&gt;OpType()) {</a>
<a name="ln335">    case DocOperation::Type::QL_WRITE_OPERATION: {</a>
<a name="ln336">      const auto &amp;resp = down_cast&lt;QLWriteOperation *&gt;(doc_op)-&gt;response();</a>
<a name="ln337">      resp-&gt;set_status(QLResponsePB::YQL_STATUS_QUERY_ERROR);</a>
<a name="ln338">      resp-&gt;set_error_message(err_msg);</a>
<a name="ln339">      break;</a>
<a name="ln340">    }</a>
<a name="ln341">    case DocOperation::Type::PGSQL_WRITE_OPERATION: {</a>
<a name="ln342">      const auto &amp;resp = down_cast&lt;PgsqlWriteOperation *&gt;(doc_op)-&gt;response();</a>
<a name="ln343">      resp-&gt;set_status(PgsqlResponsePB::PGSQL_STATUS_USAGE_ERROR);</a>
<a name="ln344">      resp-&gt;set_error_message(err_msg);</a>
<a name="ln345">      break;</a>
<a name="ln346">    }</a>
<a name="ln347">    default:</a>
<a name="ln348">      return STATUS_FORMAT(InternalError,</a>
<a name="ln349">                           &quot;Invalid status (QLError) for doc operation %d&quot;,</a>
<a name="ln350">                           doc_op-&gt;OpType());</a>
<a name="ln351">  }</a>
<a name="ln352">  return Status::OK();</a>
<a name="ln353">}</a>
<a name="ln354"> </a>
<a name="ln355">Status ExecuteDocWriteOperation(const vector&lt;unique_ptr&lt;DocOperation&gt;&gt;&amp; doc_write_ops,</a>
<a name="ln356">                                CoarseTimePoint deadline,</a>
<a name="ln357">                                const ReadHybridTime&amp; read_time,</a>
<a name="ln358">                                const DocDB&amp; doc_db,</a>
<a name="ln359">                                KeyValueWriteBatchPB* write_batch,</a>
<a name="ln360">                                InitMarkerBehavior init_marker_behavior,</a>
<a name="ln361">                                std::atomic&lt;int64_t&gt;* monotonic_counter,</a>
<a name="ln362">                                HybridTime* restart_read_ht,</a>
<a name="ln363">                                const string&amp; table_name) {</a>
<a name="ln364">  DCHECK_ONLY_NOTNULL(restart_read_ht);</a>
<a name="ln365">  DocWriteBatch doc_write_batch(doc_db, init_marker_behavior, monotonic_counter);</a>
<a name="ln366">  DocOperationApplyData data = {&amp;doc_write_batch, deadline, read_time, restart_read_ht};</a>
<a name="ln367">  for (const unique_ptr&lt;DocOperation&gt;&amp; doc_op : doc_write_ops) {</a>
<a name="ln368">    Status s = doc_op-&gt;Apply(data);</a>
<a name="ln369">    if (s.IsQLError()) {</a>
<a name="ln370">      string error_msg;</a>
<a name="ln371">      if (ql::GetErrorCode(s) == ql::ErrorCode::CONDITION_NOT_SATISFIED) {</a>
<a name="ln372">        // Generating the error message here because 'table_name'</a>
<a name="ln373">        // is not available on the lower level - in doc_op-&gt;Apply().</a>
<a name="ln374">        error_msg = Format(&quot;Condition on table $0 was not satisfied.&quot;, table_name);</a>
<a name="ln375">      } else {</a>
<a name="ln376">        error_msg =  s.message().ToBuffer();</a>
<a name="ln377">      }</a>
<a name="ln378"> </a>
<a name="ln379">      // Ensure we set appropriate error in the response object for QL errors.</a>
<a name="ln380">      RETURN_NOT_OK(SetDocOpQLErrorResponse(doc_op.get(), error_msg));</a>
<a name="ln381">      continue;</a>
<a name="ln382">    }</a>
<a name="ln383"> </a>
<a name="ln384">    RETURN_NOT_OK(s);</a>
<a name="ln385">  }</a>
<a name="ln386">  doc_write_batch.MoveToWriteBatchPB(write_batch);</a>
<a name="ln387">  return Status::OK();</a>
<a name="ln388">}</a>
<a name="ln389"> </a>
<a name="ln390">void PrepareNonTransactionWriteBatch(</a>
<a name="ln391">    const KeyValueWriteBatchPB&amp; put_batch,</a>
<a name="ln392">    HybridTime hybrid_time,</a>
<a name="ln393">    rocksdb::WriteBatch* rocksdb_write_batch) {</a>
<a name="ln394">  CHECK(put_batch.read_pairs().empty());</a>
<a name="ln395"> </a>
<a name="ln396">  DocHybridTimeBuffer doc_ht_buffer;</a>
<a name="ln397">  for (int write_id = 0; write_id &lt; put_batch.write_pairs_size(); ++write_id) {</a>
<a name="ln398">    const auto&amp; kv_pair = put_batch.write_pairs(write_id);</a>
<a name="ln399">    CHECK(!kv_pair.key().empty());</a>
<a name="ln400">    CHECK(!kv_pair.value().empty());</a>
<a name="ln401"> </a>
<a name="ln402">#ifndef NDEBUG</a>
<a name="ln403">    // Debug-only: ensure all keys we get in Raft replication can be decoded.</a>
<a name="ln404">    {</a>
<a name="ln405">      SubDocKey subdoc_key;</a>
<a name="ln406">      Status s = subdoc_key.FullyDecodeFromKeyWithOptionalHybridTime(kv_pair.key());</a>
<a name="ln407">      CHECK(s.ok())</a>
<a name="ln408">          &lt;&lt; &quot;Failed decoding key: &quot; &lt;&lt; s.ToString() &lt;&lt; &quot;; &quot;</a>
<a name="ln409">          &lt;&lt; &quot;Problematic key: &quot; &lt;&lt; BestEffortDocDBKeyToStr(KeyBytes(kv_pair.key())) &lt;&lt; &quot;\n&quot;</a>
<a name="ln410">          &lt;&lt; &quot;value: &quot; &lt;&lt; FormatBytesAsStr(kv_pair.value()) &lt;&lt; &quot;\n&quot;</a>
<a name="ln411">          &lt;&lt; &quot;put_batch:\n&quot; &lt;&lt; put_batch.DebugString();</a>
<a name="ln412">    }</a>
<a name="ln413">#endif</a>
<a name="ln414"> </a>
<a name="ln415">    // We replicate encoded SubDocKeys without a HybridTime at the end, and only append it here.</a>
<a name="ln416">    // The reason for this is that the HybridTime timestamp is only picked at the time of</a>
<a name="ln417">    // appending  an entry to the tablet's Raft log. Also this is a good way to save network</a>
<a name="ln418">    // bandwidth.</a>
<a name="ln419">    //</a>
<a name="ln420">    // &quot;Write id&quot; is the final component of our HybridTime encoding (or, to be more precise,</a>
<a name="ln421">    // DocHybridTime encoding) that helps disambiguate between different updates to the</a>
<a name="ln422">    // same key (row/column) within a transaction. We set it based on the position of the write</a>
<a name="ln423">    // operation in its write batch.</a>
<a name="ln424"> </a>
<a name="ln425">    hybrid_time = kv_pair.has_external_hybrid_time() ?</a>
<a name="ln426">        HybridTime(kv_pair.external_hybrid_time()) : hybrid_time;</a>
<a name="ln427">    std::array&lt;Slice, 2&gt; key_parts = {{</a>
<a name="ln428">        Slice(kv_pair.key()),</a>
<a name="ln429">        doc_ht_buffer.EncodeWithValueType(hybrid_time, write_id),</a>
<a name="ln430">    }};</a>
<a name="ln431">    Slice key_value = kv_pair.value();</a>
<a name="ln432">    rocksdb_write_batch-&gt;Put(key_parts, { &amp;key_value, 1 });</a>
<a name="ln433">  }</a>
<a name="ln434">}</a>
<a name="ln435"> </a>
<a name="ln436">namespace {</a>
<a name="ln437"> </a>
<a name="ln438">// Checks if the given slice points to the part of an encoded SubDocKey past all of the subkeys</a>
<a name="ln439">// (and definitely past all the hash/range keys). The only remaining part could be a hybrid time.</a>
<a name="ln440">inline bool IsEndOfSubKeys(const Slice&amp; key) {</a>
<a name="ln441">  return key[0] == ValueTypeAsChar::kGroupEnd &amp;&amp;</a>
<a name="ln442">         (key.size() == 1 || key[1] == ValueTypeAsChar::kHybridTime);</a>
<a name="ln443">}</a>
<a name="ln444"> </a>
<a name="ln445">// Enumerates weak intents generated by the given key by invoking the provided callback with each</a>
<a name="ln446">// weak intent stored in encoded_key_buffer. On return, *encoded_key_buffer contains the</a>
<a name="ln447">// corresponding strong intent, for which the callback has not yet been called. It is expected</a>
<a name="ln448">// that the caller would do so.</a>
<a name="ln449">Status EnumerateWeakIntents(</a>
<a name="ln450">    Slice key,</a>
<a name="ln451">    const EnumerateIntentsCallback&amp; functor,</a>
<a name="ln452">    KeyBytes* encoded_key_buffer,</a>
<a name="ln453">    PartialRangeKeyIntents partial_range_key_intents) {</a>
<a name="ln454">  static const Slice kEmptyIntentValue;</a>
<a name="ln455"> </a>
<a name="ln456">  encoded_key_buffer-&gt;Clear();</a>
<a name="ln457">  if (key.empty()) {</a>
<a name="ln458">    return STATUS(Corruption, &quot;An empty slice is not a valid encoded SubDocKey&quot;);</a>
<a name="ln459">  }</a>
<a name="ln460"> </a>
<a name="ln461">  const bool has_cotable_id = *key.cdata() == ValueTypeAsChar::kTableId;</a>
<a name="ln462">  const bool has_pgtable_id = *key.cdata() == ValueTypeAsChar::kPgTableOid;</a>
<a name="ln463">  {</a>
<a name="ln464">    bool is_table_root_key = false;</a>
<a name="ln465">    if (has_cotable_id) {</a>
<a name="ln466">      const auto kMinExpectedSize = kUuidSize + 2;</a>
<a name="ln467">      if (key.size() &lt; kMinExpectedSize) {</a>
<a name="ln468">        return STATUS_FORMAT(</a>
<a name="ln469">            Corruption,</a>
<a name="ln470">            &quot;Expected an encoded SubDocKey starting with a cotable id to be at least $0 bytes long&quot;,</a>
<a name="ln471">            kMinExpectedSize);</a>
<a name="ln472">      }</a>
<a name="ln473">      encoded_key_buffer-&gt;AppendRawBytes(key.cdata(), kUuidSize + 1);</a>
<a name="ln474">      is_table_root_key = key[kUuidSize + 1] == ValueTypeAsChar::kGroupEnd;</a>
<a name="ln475">    } else if (has_pgtable_id) {</a>
<a name="ln476">      const auto kMinExpectedSize = sizeof(PgTableOid) + 2;</a>
<a name="ln477">      if (key.size() &lt; kMinExpectedSize) {</a>
<a name="ln478">        return STATUS_FORMAT(</a>
<a name="ln479">            Corruption,</a>
<a name="ln480">            &quot;Expected an encoded SubDocKey starting with a pgtable id to be at least $0 bytes long&quot;,</a>
<a name="ln481">            kMinExpectedSize);</a>
<a name="ln482">      }</a>
<a name="ln483">      encoded_key_buffer-&gt;AppendRawBytes(key.cdata(), sizeof(PgTableOid) + 1);</a>
<a name="ln484">      is_table_root_key = key[sizeof(PgTableOid) + 1] == ValueTypeAsChar::kGroupEnd;</a>
<a name="ln485">    } else {</a>
<a name="ln486">      is_table_root_key = *key.cdata() == ValueTypeAsChar::kGroupEnd;</a>
<a name="ln487">    }</a>
<a name="ln488"> </a>
<a name="ln489">    encoded_key_buffer-&gt;AppendValueType(ValueType::kGroupEnd);</a>
<a name="ln490"> </a>
<a name="ln491">    if (is_table_root_key) {</a>
<a name="ln492">      // This must be a &quot;table root&quot; (or &quot;tablet root&quot;) key (no hash components, no range</a>
<a name="ln493">      // components, but the cotable might still be there). We are not really considering the case</a>
<a name="ln494">      // of any subkeys under the empty key, so we can return here.</a>
<a name="ln495">      return Status::OK();</a>
<a name="ln496">    }</a>
<a name="ln497">  }</a>
<a name="ln498"> </a>
<a name="ln499">  // For any non-empty key we already know that the empty key intent is weak.</a>
<a name="ln500">  RETURN_NOT_OK(functor(</a>
<a name="ln501">      IntentStrength::kWeak, kEmptyIntentValue, encoded_key_buffer, LastKey::kFalse));</a>
<a name="ln502"> </a>
<a name="ln503">  auto hashed_part_size = VERIFY_RESULT(DocKey::EncodedSize(key, DocKeyPart::kUpToHash));</a>
<a name="ln504"> </a>
<a name="ln505">  // Remove kGroupEnd that we just added to generate a weak intent.</a>
<a name="ln506">  encoded_key_buffer-&gt;RemoveLastByte();</a>
<a name="ln507"> </a>
<a name="ln508">  if (hashed_part_size != encoded_key_buffer-&gt;size()) {</a>
<a name="ln509">    // A hash component is present. Note that if cotable id is present, hashed_part_size would</a>
<a name="ln510">    // also include it, so we only need to append the new bytes.</a>
<a name="ln511">    encoded_key_buffer-&gt;AppendRawBytes(</a>
<a name="ln512">        key.cdata() + encoded_key_buffer-&gt;size(), hashed_part_size - encoded_key_buffer-&gt;size());</a>
<a name="ln513">    key.remove_prefix(hashed_part_size);</a>
<a name="ln514">    if (key.empty()) {</a>
<a name="ln515">      return STATUS(Corruption, &quot;Range key part missing, expected at least a kGroupEnd&quot;);</a>
<a name="ln516">    }</a>
<a name="ln517"> </a>
<a name="ln518">    // Append the kGroupEnd at the end for the empty range part to make this a valid encoded DocKey.</a>
<a name="ln519">    encoded_key_buffer-&gt;AppendValueType(ValueType::kGroupEnd);</a>
<a name="ln520">    if (IsEndOfSubKeys(key)) {</a>
<a name="ln521">      // This means the key ends at the hash component -- no range keys and no subkeys.</a>
<a name="ln522">      return Status::OK();</a>
<a name="ln523">    }</a>
<a name="ln524"> </a>
<a name="ln525">    // Generate a week intent that only includes the hash component.</a>
<a name="ln526">    RETURN_NOT_OK(functor(</a>
<a name="ln527">        IntentStrength::kWeak, kEmptyIntentValue, encoded_key_buffer, LastKey::kFalse));</a>
<a name="ln528"> </a>
<a name="ln529">    // Remove the kGroupEnd we added a bit earlier so we can append some range components.</a>
<a name="ln530">    encoded_key_buffer-&gt;RemoveLastByte();</a>
<a name="ln531">  } else {</a>
<a name="ln532">    // No hash component.</a>
<a name="ln533">    key.remove_prefix(hashed_part_size);</a>
<a name="ln534">  }</a>
<a name="ln535"> </a>
<a name="ln536">  // Range components.</a>
<a name="ln537">  auto range_key_start = key.cdata();</a>
<a name="ln538">  while (VERIFY_RESULT(ConsumePrimitiveValueFromKey(&amp;key))) {</a>
<a name="ln539">    encoded_key_buffer-&gt;AppendRawBytes(range_key_start, key.cdata() - range_key_start);</a>
<a name="ln540">    // We always need kGroupEnd at the end to make this a valid encoded DocKey.</a>
<a name="ln541">    encoded_key_buffer-&gt;AppendValueType(ValueType::kGroupEnd);</a>
<a name="ln542">    if (key.empty()) {</a>
<a name="ln543">      return STATUS(Corruption, &quot;Range key part is not terminated with a kGroupEnd&quot;);</a>
<a name="ln544">    }</a>
<a name="ln545">    if (IsEndOfSubKeys(key)) {</a>
<a name="ln546">      // This is the last range key and there are no subkeys.</a>
<a name="ln547">      return Status::OK();</a>
<a name="ln548">    }</a>
<a name="ln549">    if (partial_range_key_intents || *key.cdata() == ValueTypeAsChar::kGroupEnd) {</a>
<a name="ln550">      RETURN_NOT_OK(functor(</a>
<a name="ln551">          IntentStrength::kWeak, kEmptyIntentValue, encoded_key_buffer, LastKey::kFalse));</a>
<a name="ln552">    }</a>
<a name="ln553">    encoded_key_buffer-&gt;RemoveLastByte();</a>
<a name="ln554">    range_key_start = key.cdata();</a>
<a name="ln555">  }</a>
<a name="ln556"> </a>
<a name="ln557">  // We still need to append the kGroupEnd byte that closes the range portion to our buffer.</a>
<a name="ln558">  // The corresponding kGroupEnd has already been consumed from the key slice by the last call to</a>
<a name="ln559">  // ConsumePrimitiveValueFromKey, which returned false.</a>
<a name="ln560">  encoded_key_buffer-&gt;AppendValueType(ValueType::kGroupEnd);</a>
<a name="ln561"> </a>
<a name="ln562">  auto subkey_start = key.cdata();</a>
<a name="ln563">  while (VERIFY_RESULT(SubDocKey::DecodeSubkey(&amp;key))) {</a>
<a name="ln564">    encoded_key_buffer-&gt;AppendRawBytes(subkey_start, key.cdata() - subkey_start);</a>
<a name="ln565">    if (key.empty() || *key.cdata() == ValueTypeAsChar::kHybridTime) {</a>
<a name="ln566">      // This was the last subkey.</a>
<a name="ln567">      return Status::OK();</a>
<a name="ln568">    }</a>
<a name="ln569">    RETURN_NOT_OK(functor(</a>
<a name="ln570">        IntentStrength::kWeak, kEmptyIntentValue, encoded_key_buffer, LastKey::kFalse));</a>
<a name="ln571">    subkey_start = key.cdata();</a>
<a name="ln572">  }</a>
<a name="ln573"> </a>
<a name="ln574">  return STATUS(</a>
<a name="ln575">      Corruption,</a>
<a name="ln576">      &quot;Expected to reach the end of the key after decoding last valid subkey&quot;);</a>
<a name="ln577">}</a>
<a name="ln578"> </a>
<a name="ln579">}  // anonymous namespace</a>
<a name="ln580"> </a>
<a name="ln581">Status EnumerateIntents(</a>
<a name="ln582">    Slice key, const Slice&amp; intent_value, const EnumerateIntentsCallback&amp; functor,</a>
<a name="ln583">    KeyBytes* encoded_key_buffer, PartialRangeKeyIntents partial_range_key_intents,</a>
<a name="ln584">    LastKey last_key) {</a>
<a name="ln585">  RETURN_NOT_OK(EnumerateWeakIntents(</a>
<a name="ln586">      key, functor, encoded_key_buffer, partial_range_key_intents));</a>
<a name="ln587">  return functor(IntentStrength::kStrong, intent_value, encoded_key_buffer, last_key);</a>
<a name="ln588">}</a>
<a name="ln589"> </a>
<a name="ln590">Status EnumerateIntents(</a>
<a name="ln591">    const google::protobuf::RepeatedPtrField&lt;KeyValuePairPB&gt; &amp;kv_pairs,</a>
<a name="ln592">    const EnumerateIntentsCallback&amp; functor, PartialRangeKeyIntents partial_range_key_intents) {</a>
<a name="ln593">  KeyBytes encoded_key;</a>
<a name="ln594"> </a>
<a name="ln595">  for (int index = 0; index &lt; kv_pairs.size(); ) {</a>
<a name="ln596">    const auto &amp;kv_pair = kv_pairs.Get(index);</a>
<a name="ln597">    ++index;</a>
<a name="ln598">    CHECK(!kv_pair.key().empty());</a>
<a name="ln599">    CHECK(!kv_pair.value().empty());</a>
<a name="ln600">    RETURN_NOT_OK(EnumerateIntents(</a>
<a name="ln601">        kv_pair.key(), kv_pair.value(), functor, &amp;encoded_key, partial_range_key_intents,</a>
<a name="ln602">        LastKey(index == kv_pairs.size())));</a>
<a name="ln603">  }</a>
<a name="ln604"> </a>
<a name="ln605">  return Status::OK();</a>
<a name="ln606">}</a>
<a name="ln607"> </a>
<a name="ln608">class PrepareTransactionWriteBatchHelper {</a>
<a name="ln609"> public:</a>
<a name="ln610">  PrepareTransactionWriteBatchHelper(const PrepareTransactionWriteBatchHelper&amp;) = delete;</a>
<a name="ln611">  void operator=(const PrepareTransactionWriteBatchHelper&amp;) = delete;</a>
<a name="ln612"> </a>
<a name="ln613">  // `rocksdb_write_batch` - in-out parameter is filled by this prepare.</a>
<a name="ln614">  PrepareTransactionWriteBatchHelper(HybridTime hybrid_time,</a>
<a name="ln615">                                     rocksdb::WriteBatch* rocksdb_write_batch,</a>
<a name="ln616">                                     const TransactionId&amp; transaction_id,</a>
<a name="ln617">                                     const Slice&amp; replicated_batches_state,</a>
<a name="ln618">                                     IntraTxnWriteId* intra_txn_write_id)</a>
<a name="ln619">      : hybrid_time_(hybrid_time),</a>
<a name="ln620">        rocksdb_write_batch_(rocksdb_write_batch),</a>
<a name="ln621">        transaction_id_(transaction_id),</a>
<a name="ln622">        replicated_batches_state_(replicated_batches_state),</a>
<a name="ln623">        intra_txn_write_id_(intra_txn_write_id) {</a>
<a name="ln624">  }</a>
<a name="ln625"> </a>
<a name="ln626">  void Setup(</a>
<a name="ln627">      IsolationLevel isolation_level,</a>
<a name="ln628">      OperationKind kind,</a>
<a name="ln629">      RowMarkType row_mark) {</a>
<a name="ln630">    row_mark_ = row_mark;</a>
<a name="ln631">    strong_intent_types_ = GetStrongIntentTypeSet(isolation_level, kind, row_mark);</a>
<a name="ln632">  }</a>
<a name="ln633"> </a>
<a name="ln634">  // Using operator() to pass this object conveniently to EnumerateIntents.</a>
<a name="ln635">  CHECKED_STATUS operator()(IntentStrength intent_strength, Slice value_slice, KeyBytes* key,</a>
<a name="ln636">                            LastKey last_key) {</a>
<a name="ln637">    if (intent_strength == IntentStrength::kWeak) {</a>
<a name="ln638">      weak_intents_[key-&gt;data()] |= StrongToWeak(strong_intent_types_);</a>
<a name="ln639">      return Status::OK();</a>
<a name="ln640">    }</a>
<a name="ln641"> </a>
<a name="ln642">    const auto transaction_value_type = ValueTypeAsChar::kTransactionId;</a>
<a name="ln643">    const auto write_id_value_type = ValueTypeAsChar::kWriteId;</a>
<a name="ln644">    const auto row_lock_value_type = ValueTypeAsChar::kRowLock;</a>
<a name="ln645">    IntraTxnWriteId big_endian_write_id = BigEndian::FromHost32(*intra_txn_write_id_);</a>
<a name="ln646">    std::array&lt;Slice, 5&gt; value = {{</a>
<a name="ln647">        Slice(&amp;transaction_value_type, 1),</a>
<a name="ln648">        transaction_id_.AsSlice(),</a>
<a name="ln649">        Slice(&amp;write_id_value_type, 1),</a>
<a name="ln650">        Slice(pointer_cast&lt;char*&gt;(&amp;big_endian_write_id), sizeof(big_endian_write_id)),</a>
<a name="ln651">        value_slice,</a>
<a name="ln652">    }};</a>
<a name="ln653">    // Store a row lock indicator rather than data (in value_slice) for row lock intents.</a>
<a name="ln654">    if (IsValidRowMarkType(row_mark_)) {</a>
<a name="ln655">      value.back() = Slice(&amp;row_lock_value_type, 1);</a>
<a name="ln656">    }</a>
<a name="ln657"> </a>
<a name="ln658">    ++*intra_txn_write_id_;</a>
<a name="ln659"> </a>
<a name="ln660">    char intent_type[2] = { ValueTypeAsChar::kIntentTypeSet,</a>
<a name="ln661">                            static_cast&lt;char&gt;(strong_intent_types_.ToUIntPtr()) };</a>
<a name="ln662"> </a>
<a name="ln663">    DocHybridTimeBuffer doc_ht_buffer;</a>
<a name="ln664"> </a>
<a name="ln665">    constexpr size_t kNumKeyParts = 3;</a>
<a name="ln666">    std::array&lt;Slice, kNumKeyParts&gt; key_parts = {{</a>
<a name="ln667">        key-&gt;AsSlice(),</a>
<a name="ln668">        Slice(intent_type, 2),</a>
<a name="ln669">        doc_ht_buffer.EncodeWithValueType(hybrid_time_, write_id_++),</a>
<a name="ln670">    }};</a>
<a name="ln671"> </a>
<a name="ln672">    Slice reverse_value_prefix;</a>
<a name="ln673">    if (last_key &amp;&amp; FLAGS_enable_transaction_sealing) {</a>
<a name="ln674">      reverse_value_prefix = replicated_batches_state_;</a>
<a name="ln675">    }</a>
<a name="ln676">    AddIntent&lt;kNumKeyParts&gt;(</a>
<a name="ln677">        transaction_id_, key_parts, value, rocksdb_write_batch_, reverse_value_prefix);</a>
<a name="ln678"> </a>
<a name="ln679">    return Status::OK();</a>
<a name="ln680">  }</a>
<a name="ln681"> </a>
<a name="ln682">  void Finish() {</a>
<a name="ln683">    char transaction_id_value_type = ValueTypeAsChar::kTransactionId;</a>
<a name="ln684"> </a>
<a name="ln685">    DocHybridTimeBuffer doc_ht_buffer;</a>
<a name="ln686"> </a>
<a name="ln687">    std::array&lt;Slice, 2&gt; value = {{</a>
<a name="ln688">        Slice(&amp;transaction_id_value_type, 1),</a>
<a name="ln689">        transaction_id_.AsSlice(),</a>
<a name="ln690">    }};</a>
<a name="ln691"> </a>
<a name="ln692">    if (PREDICT_TRUE(!FLAGS_TEST_docdb_sort_weak_intents_in_tests)) {</a>
<a name="ln693">      for (const auto&amp; intent_and_types : weak_intents_) {</a>
<a name="ln694">        AddWeakIntent(intent_and_types, value, &amp;doc_ht_buffer);</a>
<a name="ln695">      }</a>
<a name="ln696">    } else {</a>
<a name="ln697">      // This is done in tests when deterministic DocDB state is required.</a>
<a name="ln698">      std::vector&lt;std::pair&lt;KeyBuffer, IntentTypeSet&gt;&gt; intents_and_types(</a>
<a name="ln699">          weak_intents_.begin(), weak_intents_.end());</a>
<a name="ln700">      sort(intents_and_types.begin(), intents_and_types.end());</a>
<a name="ln701">      for (const auto&amp; intent_and_types : intents_and_types) {</a>
<a name="ln702">        AddWeakIntent(intent_and_types, value, &amp;doc_ht_buffer);</a>
<a name="ln703">      }</a>
<a name="ln704">    }</a>
<a name="ln705">  }</a>
<a name="ln706"> </a>
<a name="ln707"> private:</a>
<a name="ln708">  void AddWeakIntent(</a>
<a name="ln709">      const std::pair&lt;KeyBuffer, IntentTypeSet&gt;&amp; intent_and_types,</a>
<a name="ln710">      const std::array&lt;Slice, 2&gt;&amp; value,</a>
<a name="ln711">      DocHybridTimeBuffer* doc_ht_buffer) {</a>
<a name="ln712">    char intent_type[2] = { ValueTypeAsChar::kIntentTypeSet,</a>
<a name="ln713">                            static_cast&lt;char&gt;(intent_and_types.second.ToUIntPtr()) };</a>
<a name="ln714">    constexpr size_t kNumKeyParts = 3;</a>
<a name="ln715">    std::array&lt;Slice, kNumKeyParts&gt; key = {{</a>
<a name="ln716">        intent_and_types.first.AsSlice(),</a>
<a name="ln717">        Slice(intent_type, 2),</a>
<a name="ln718">        doc_ht_buffer-&gt;EncodeWithValueType(hybrid_time_, write_id_++),</a>
<a name="ln719">    }};</a>
<a name="ln720"> </a>
<a name="ln721">    AddIntent&lt;kNumKeyParts&gt;(transaction_id_, key, value, rocksdb_write_batch_);</a>
<a name="ln722">  }</a>
<a name="ln723"> </a>
<a name="ln724">  // TODO(dtxn) weak &amp; strong intent in one batch.</a>
<a name="ln725">  // TODO(dtxn) extract part of code knowning about intents structure to lower level.</a>
<a name="ln726">  RowMarkType row_mark_;</a>
<a name="ln727">  HybridTime hybrid_time_;</a>
<a name="ln728">  rocksdb::WriteBatch* rocksdb_write_batch_;</a>
<a name="ln729">  const TransactionId&amp; transaction_id_;</a>
<a name="ln730">  Slice replicated_batches_state_;</a>
<a name="ln731">  IntentTypeSet strong_intent_types_;</a>
<a name="ln732">  std::unordered_map&lt;KeyBuffer, IntentTypeSet, ByteBufferHash&gt; weak_intents_;</a>
<a name="ln733">  IntraTxnWriteId write_id_ = 0;</a>
<a name="ln734">  IntraTxnWriteId* intra_txn_write_id_;</a>
<a name="ln735">};</a>
<a name="ln736"> </a>
<a name="ln737">// We have the following distinct types of data in this &quot;intent store&quot;:</a>
<a name="ln738">// Main intent data:</a>
<a name="ln739">//   Prefix + SubDocKey (no HybridTime) + IntentType + HybridTime -&gt; TxnId + value of the intent</a>
<a name="ln740">// Transaction metadata</a>
<a name="ln741">//   TxnId -&gt; status tablet id + isolation level</a>
<a name="ln742">// Reverse index by txn id</a>
<a name="ln743">//   TxnId + HybridTime -&gt; Main intent data key</a>
<a name="ln744">//</a>
<a name="ln745">// Where prefix is just a single byte prefix. TxnId, IntentType, HybridTime all prefixed with</a>
<a name="ln746">// appropriate value type.</a>
<a name="ln747">void PrepareTransactionWriteBatch(</a>
<a name="ln748">    const KeyValueWriteBatchPB&amp; put_batch,</a>
<a name="ln749">    HybridTime hybrid_time,</a>
<a name="ln750">    rocksdb::WriteBatch* rocksdb_write_batch,</a>
<a name="ln751">    const TransactionId&amp; transaction_id,</a>
<a name="ln752">    IsolationLevel isolation_level,</a>
<a name="ln753">    PartialRangeKeyIntents partial_range_key_intents,</a>
<a name="ln754">    const Slice&amp; replicated_batches_state,</a>
<a name="ln755">    IntraTxnWriteId* write_id) {</a>
<a name="ln756">  VLOG(4) &lt;&lt; &quot;PrepareTransactionWriteBatch(), write_id = &quot; &lt;&lt; *write_id;</a>
<a name="ln757"> </a>
<a name="ln758">  RowMarkType row_mark = GetRowMarkTypeFromPB(put_batch);</a>
<a name="ln759"> </a>
<a name="ln760">  PrepareTransactionWriteBatchHelper helper(</a>
<a name="ln761">      hybrid_time, rocksdb_write_batch, transaction_id, replicated_batches_state, write_id);</a>
<a name="ln762"> </a>
<a name="ln763">  if (!put_batch.write_pairs().empty()) {</a>
<a name="ln764">    if (IsValidRowMarkType(row_mark)) {</a>
<a name="ln765">      LOG(WARNING) &lt;&lt; &quot;Performing a write with row lock &quot;</a>
<a name="ln766">                   &lt;&lt; RowMarkType_Name(row_mark)</a>
<a name="ln767">                   &lt;&lt; &quot; when only reads are expected&quot;;</a>
<a name="ln768">    }</a>
<a name="ln769">    helper.Setup(isolation_level, OperationKind::kWrite, row_mark);</a>
<a name="ln770"> </a>
<a name="ln771">    // We cannot recover from failures here, because it means that we cannot apply replicated</a>
<a name="ln772">    // operation.</a>
<a name="ln773">    CHECK_OK(EnumerateIntents(put_batch.write_pairs(), std::ref(helper),</a>
<a name="ln774">             partial_range_key_intents));</a>
<a name="ln775">  }</a>
<a name="ln776"> </a>
<a name="ln777">  if (!put_batch.read_pairs().empty()) {</a>
<a name="ln778">    helper.Setup(isolation_level, OperationKind::kRead, row_mark);</a>
<a name="ln779">    CHECK_OK(EnumerateIntents(put_batch.read_pairs(), std::ref(helper), partial_range_key_intents));</a>
<a name="ln780">  }</a>
<a name="ln781"> </a>
<a name="ln782">  helper.Finish();</a>
<a name="ln783">}</a>
<a name="ln784"> </a>
<a name="ln785">// ------------------------------------------------------------------------------------------------</a>
<a name="ln786">// Standalone functions</a>
<a name="ln787">// ------------------------------------------------------------------------------------------------</a>
<a name="ln788"> </a>
<a name="ln789">void AppendTransactionKeyPrefix(const TransactionId&amp; transaction_id, KeyBytes* out) {</a>
<a name="ln790">  out-&gt;AppendValueType(ValueType::kTransactionId);</a>
<a name="ln791">  out-&gt;AppendRawBytes(transaction_id.AsSlice());</a>
<a name="ln792">}</a>
<a name="ln793"> </a>
<a name="ln794">CHECKED_STATUS IntentToWriteRequest(</a>
<a name="ln795">    const Slice&amp; transaction_id_slice,</a>
<a name="ln796">    HybridTime commit_ht,</a>
<a name="ln797">    const Slice&amp; reverse_index_key,</a>
<a name="ln798">    const Slice&amp; reverse_index_value,</a>
<a name="ln799">    rocksdb::Iterator* intent_iter,</a>
<a name="ln800">    rocksdb::WriteBatch* regular_batch,</a>
<a name="ln801">    IntraTxnWriteId* write_id) {</a>
<a name="ln802">  DocHybridTimeBuffer doc_ht_buffer;</a>
<a name="ln803">  intent_iter-&gt;Seek(reverse_index_value);</a>
<a name="ln804">  if (!intent_iter-&gt;Valid() || intent_iter-&gt;key() != reverse_index_value) {</a>
<a name="ln805">    LOG(DFATAL) &lt;&lt; &quot;Unable to find intent: &quot; &lt;&lt; reverse_index_value.ToDebugHexString()</a>
<a name="ln806">                &lt;&lt; &quot; for &quot; &lt;&lt; reverse_index_key.ToDebugHexString();</a>
<a name="ln807">    return Status::OK();</a>
<a name="ln808">  }</a>
<a name="ln809">  auto intent = VERIFY_RESULT(ParseIntentKey(intent_iter-&gt;key(), transaction_id_slice));</a>
<a name="ln810"> </a>
<a name="ln811">  if (intent.types.Test(IntentType::kStrongWrite)) {</a>
<a name="ln812">    IntraTxnWriteId stored_write_id;</a>
<a name="ln813">    Slice intent_value;</a>
<a name="ln814">    RETURN_NOT_OK(DecodeIntentValue(</a>
<a name="ln815">        intent_iter-&gt;value(), transaction_id_slice, &amp;stored_write_id, &amp;intent_value));</a>
<a name="ln816"> </a>
<a name="ln817">    // Write id should match to one that were calculated during append of intents.</a>
<a name="ln818">    // Doing it just for sanity check.</a>
<a name="ln819">    DCHECK_GE(stored_write_id, *write_id)</a>
<a name="ln820">      &lt;&lt; &quot;Value: &quot; &lt;&lt; intent_iter-&gt;value().ToDebugHexString();</a>
<a name="ln821">    *write_id = stored_write_id;</a>
<a name="ln822"> </a>
<a name="ln823">    // Intents for row locks should be ignored (i.e. should not be written as regular records).</a>
<a name="ln824">    if (intent_value.starts_with(ValueTypeAsChar::kRowLock)) {</a>
<a name="ln825">      return Status::OK();</a>
<a name="ln826">    }</a>
<a name="ln827"> </a>
<a name="ln828">    // After strip of prefix and suffix intent_key contains just SubDocKey w/o a hybrid time.</a>
<a name="ln829">    // Time will be added when writing batch to RocksDB.</a>
<a name="ln830">    std::array&lt;Slice, 2&gt; key_parts = {{</a>
<a name="ln831">        intent.doc_path,</a>
<a name="ln832">        doc_ht_buffer.EncodeWithValueType(commit_ht, *write_id),</a>
<a name="ln833">    }};</a>
<a name="ln834">    std::array&lt;Slice, 2&gt; value_parts = {{</a>
<a name="ln835">        intent.doc_ht,</a>
<a name="ln836">        intent_value,</a>
<a name="ln837">    }};</a>
<a name="ln838"> </a>
<a name="ln839">    // Useful when debugging transaction failure.</a>
<a name="ln840">#if defined(DUMP_APPLY)</a>
<a name="ln841">    SubDocKey sub_doc_key;</a>
<a name="ln842">    CHECK_OK(sub_doc_key.FullyDecodeFrom(intent.doc_path, HybridTimeRequired::kFalse));</a>
<a name="ln843">    if (!sub_doc_key.subkeys().empty()) {</a>
<a name="ln844">      auto txn_id = FullyDecodeTransactionId(transaction_id_slice);</a>
<a name="ln845">      LOG(INFO) &lt;&lt; &quot;Apply: &quot; &lt;&lt; sub_doc_key.ToString()</a>
<a name="ln846">                &lt;&lt; &quot;, time: &quot; &lt;&lt; commit_ht &lt;&lt; &quot;, write id: &quot; &lt;&lt; *write_id &lt;&lt; &quot;, txn: &quot; &lt;&lt; txn_id</a>
<a name="ln847">                &lt;&lt; &quot;, value: &quot; &lt;&lt; intent_value.ToDebugString();</a>
<a name="ln848">    }</a>
<a name="ln849">#endif</a>
<a name="ln850"> </a>
<a name="ln851">    regular_batch-&gt;Put(key_parts, value_parts);</a>
<a name="ln852">    ++*write_id;</a>
<a name="ln853">  }</a>
<a name="ln854"> </a>
<a name="ln855">  return Status::OK();</a>
<a name="ln856">}</a>
<a name="ln857"> </a>
<a name="ln858">template &lt;size_t N&gt;</a>
<a name="ln859">void PutApplyState(</a>
<a name="ln860">    const Slice&amp; transaction_id_slice, HybridTime commit_ht, IntraTxnWriteId write_id,</a>
<a name="ln861">    const std::array&lt;Slice, N&gt;&amp; value_parts, rocksdb::WriteBatch* regular_batch) {</a>
<a name="ln862">  char transaction_apply_state_value_type = ValueTypeAsChar::kTransactionApplyState;</a>
<a name="ln863">  char group_end_value_type = ValueTypeAsChar::kGroupEnd;</a>
<a name="ln864">  char hybrid_time_value_type = ValueTypeAsChar::kHybridTime;</a>
<a name="ln865">  DocHybridTime doc_hybrid_time(commit_ht, write_id);</a>
<a name="ln866">  char doc_hybrid_time_buffer[kMaxBytesPerEncodedHybridTime];</a>
<a name="ln867">  char* doc_hybrid_time_buffer_end = doc_hybrid_time.EncodedInDocDbFormat(</a>
<a name="ln868">      doc_hybrid_time_buffer);</a>
<a name="ln869">  std::array&lt;Slice, 5&gt; key_parts = {{</a>
<a name="ln870">      Slice(&amp;transaction_apply_state_value_type, 1),</a>
<a name="ln871">      transaction_id_slice,</a>
<a name="ln872">      Slice(&amp;group_end_value_type, 1),</a>
<a name="ln873">      Slice(&amp;hybrid_time_value_type, 1),</a>
<a name="ln874">      Slice(doc_hybrid_time_buffer, doc_hybrid_time_buffer_end),</a>
<a name="ln875">  }};</a>
<a name="ln876">  regular_batch-&gt;Put(key_parts, value_parts);</a>
<a name="ln877">}</a>
<a name="ln878"> </a>
<a name="ln879">ApplyTransactionState StoreApplyState(</a>
<a name="ln880">    const Slice&amp; transaction_id_slice, const Slice&amp; key, IntraTxnWriteId write_id,</a>
<a name="ln881">    HybridTime commit_ht, rocksdb::WriteBatch* regular_batch) {</a>
<a name="ln882">  auto result = ApplyTransactionState {</a>
<a name="ln883">    .key = key.ToBuffer(),</a>
<a name="ln884">    .write_id = write_id,</a>
<a name="ln885">  };</a>
<a name="ln886">  ApplyTransactionStatePB pb;</a>
<a name="ln887">  result.ToPB(&amp;pb);</a>
<a name="ln888">  pb.set_commit_ht(commit_ht.ToUint64());</a>
<a name="ln889">  faststring encoded_pb;</a>
<a name="ln890">  pb_util::SerializeToString(pb, &amp;encoded_pb);</a>
<a name="ln891">  char string_value_type = ValueTypeAsChar::kString;</a>
<a name="ln892">  std::array&lt;Slice, 2&gt; value_parts = {{</a>
<a name="ln893">    Slice(&amp;string_value_type, 1),</a>
<a name="ln894">    Slice(encoded_pb.data(), encoded_pb.size())</a>
<a name="ln895">  }};</a>
<a name="ln896">  PutApplyState(transaction_id_slice, commit_ht, write_id, value_parts, regular_batch);</a>
<a name="ln897">  return result;</a>
<a name="ln898">}</a>
<a name="ln899"> </a>
<a name="ln900">Result&lt;ApplyTransactionState&gt; PrepareApplyIntentsBatch(</a>
<a name="ln901">    const TransactionId&amp; transaction_id,</a>
<a name="ln902">    HybridTime commit_ht,</a>
<a name="ln903">    const KeyBounds* key_bounds,</a>
<a name="ln904">    const ApplyTransactionState* apply_state,</a>
<a name="ln905">    rocksdb::WriteBatch* regular_batch,</a>
<a name="ln906">    rocksdb::DB* intents_db,</a>
<a name="ln907">    rocksdb::WriteBatch* intents_batch) {</a>
<a name="ln908">  SCHECK_EQ((regular_batch != nullptr) + (intents_batch != nullptr), 1, InvalidArgument,</a>
<a name="ln909">            &quot;Exactly one write batch should be non-null, either regular or intents&quot;);</a>
<a name="ln910"> </a>
<a name="ln911">  // regular_batch or intents_batch could be null. In this case we don't fill apply batch for</a>
<a name="ln912">  // appropriate DB.</a>
<a name="ln913"> </a>
<a name="ln914">  KeyBytes txn_reverse_index_prefix;</a>
<a name="ln915">  Slice transaction_id_slice = transaction_id.AsSlice();</a>
<a name="ln916">  AppendTransactionKeyPrefix(transaction_id, &amp;txn_reverse_index_prefix);</a>
<a name="ln917">  txn_reverse_index_prefix.AppendValueType(ValueType::kMaxByte);</a>
<a name="ln918">  Slice key_prefix = txn_reverse_index_prefix.AsSlice();</a>
<a name="ln919">  key_prefix.remove_suffix(1);</a>
<a name="ln920">  const Slice reverse_index_upperbound = txn_reverse_index_prefix.AsSlice();</a>
<a name="ln921"> </a>
<a name="ln922">  auto reverse_index_iter = CreateRocksDBIterator(</a>
<a name="ln923">      intents_db, &amp;KeyBounds::kNoBounds, BloomFilterMode::DONT_USE_BLOOM_FILTER, boost::none,</a>
<a name="ln924">      rocksdb::kDefaultQueryId, nullptr /* read_filter */, &amp;reverse_index_upperbound);</a>
<a name="ln925"> </a>
<a name="ln926">  BoundedRocksDbIterator intent_iter;</a>
<a name="ln927"> </a>
<a name="ln928">  // If we don't have regular_batch, it means that we are just removing intents, i.e. when a</a>
<a name="ln929">  // transaction has been aborted. We don't need the intent iterator in that case, because the</a>
<a name="ln930">  // reverse index iterator is sufficient.</a>
<a name="ln931">  if (regular_batch) {</a>
<a name="ln932">    intent_iter = CreateRocksDBIterator(</a>
<a name="ln933">        intents_db, key_bounds, BloomFilterMode::DONT_USE_BLOOM_FILTER, boost::none,</a>
<a name="ln934">        rocksdb::kDefaultQueryId);</a>
<a name="ln935">  }</a>
<a name="ln936"> </a>
<a name="ln937">  reverse_index_iter.Seek(key_prefix);</a>
<a name="ln938"> </a>
<a name="ln939">  DocHybridTimeBuffer doc_ht_buffer;</a>
<a name="ln940"> </a>
<a name="ln941">  const auto&amp; log_prefix = intents_db-&gt;GetOptions().log_prefix;</a>
<a name="ln942"> </a>
<a name="ln943">  IntraTxnWriteId write_id = 0;</a>
<a name="ln944">  if (apply_state) {</a>
<a name="ln945">    reverse_index_iter.Seek(apply_state-&gt;key);</a>
<a name="ln946">    write_id = apply_state-&gt;write_id;</a>
<a name="ln947">    if (regular_batch) {</a>
<a name="ln948">      // This sanity check is invalid for remove case, because .SST file could be deleted.</a>
<a name="ln949">      LOG_IF(DFATAL, !reverse_index_iter.Valid() || reverse_index_iter.key() != apply_state-&gt;key)</a>
<a name="ln950">          &lt;&lt; &quot;Continue from wrong key: &quot; &lt;&lt; Slice(apply_state-&gt;key).ToDebugString() &lt;&lt; &quot;, txn: &quot;</a>
<a name="ln951">          &lt;&lt; transaction_id &lt;&lt; &quot;, position: &quot;</a>
<a name="ln952">          &lt;&lt; (reverse_index_iter.Valid() ? reverse_index_iter.key().ToDebugString() : &quot;&lt;INVALID&gt;&quot;)</a>
<a name="ln953">          &lt;&lt; &quot;, write id: &quot; &lt;&lt; write_id;</a>
<a name="ln954">    }</a>
<a name="ln955">  }</a>
<a name="ln956"> </a>
<a name="ln957">  const uint64_t max_records = FLAGS_txn_max_apply_batch_records;</a>
<a name="ln958">  const uint64_t write_id_limit = write_id + max_records;</a>
<a name="ln959">  while (reverse_index_iter.Valid()) {</a>
<a name="ln960">    const Slice key_slice(reverse_index_iter.key());</a>
<a name="ln961"> </a>
<a name="ln962">    if (!key_slice.starts_with(key_prefix)) {</a>
<a name="ln963">      break;</a>
<a name="ln964">    }</a>
<a name="ln965"> </a>
<a name="ln966">    VLOG(4) &lt;&lt; log_prefix &lt;&lt; &quot;Apply reverse index record to [&quot;</a>
<a name="ln967">            &lt;&lt; (regular_batch ? &quot;R&quot; : &quot;&quot;) &lt;&lt; (intents_batch ? &quot;I&quot; : &quot;&quot;)</a>
<a name="ln968">            &lt;&lt; &quot;]: &quot; &lt;&lt; EntryToString(reverse_index_iter, StorageDbType::kIntents);</a>
<a name="ln969"> </a>
<a name="ln970">    // If the key ends at the transaction id then it is transaction metadata (status tablet,</a>
<a name="ln971">    // isolation level etc.).</a>
<a name="ln972">    if (key_slice.size() &gt; txn_reverse_index_prefix.size()) {</a>
<a name="ln973">      auto reverse_index_value = reverse_index_iter.value();</a>
<a name="ln974">      if (!reverse_index_value.empty() &amp;&amp; reverse_index_value[0] == ValueTypeAsChar::kBitSet) {</a>
<a name="ln975">        CHECK(!FLAGS_TEST_fail_on_replicated_batch_idx_set_in_txn_record);</a>
<a name="ln976">        reverse_index_value.remove_prefix(1);</a>
<a name="ln977">        RETURN_NOT_OK(OneWayBitmap::Skip(&amp;reverse_index_value));</a>
<a name="ln978">      }</a>
<a name="ln979"> </a>
<a name="ln980">      // Value of reverse index is a key of original intent record, so seek it and check match.</a>
<a name="ln981">      if (regular_batch &amp;&amp;</a>
<a name="ln982">          (!key_bounds || key_bounds-&gt;IsWithinBounds(reverse_index_iter.value()))) {</a>
<a name="ln983">        // We store apply state only if there are some more intents left.</a>
<a name="ln984">        // So doing this check here, instead of right after write_id was incremented.</a>
<a name="ln985">        if (write_id &gt;= write_id_limit) {</a>
<a name="ln986">          return StoreApplyState(</a>
<a name="ln987">              transaction_id_slice, key_slice, write_id, commit_ht, regular_batch);</a>
<a name="ln988">        }</a>
<a name="ln989">        RETURN_NOT_OK(IntentToWriteRequest(</a>
<a name="ln990">            transaction_id_slice, commit_ht, key_slice, reverse_index_value,</a>
<a name="ln991">            &amp;intent_iter, regular_batch, &amp;write_id));</a>
<a name="ln992">      }</a>
<a name="ln993"> </a>
<a name="ln994">      if (intents_batch) {</a>
<a name="ln995">        intents_batch-&gt;SingleDelete(reverse_index_value);</a>
<a name="ln996">      }</a>
<a name="ln997">    }</a>
<a name="ln998"> </a>
<a name="ln999">    if (intents_batch) {</a>
<a name="ln1000">      if (intents_batch-&gt;Count() &gt;= max_records) {</a>
<a name="ln1001">        return ApplyTransactionState {</a>
<a name="ln1002">          .key = key_slice.ToBuffer(),</a>
<a name="ln1003">          .write_id = write_id,</a>
<a name="ln1004">        };</a>
<a name="ln1005">      }</a>
<a name="ln1006"> </a>
<a name="ln1007">      intents_batch-&gt;SingleDelete(key_slice);</a>
<a name="ln1008">    }</a>
<a name="ln1009"> </a>
<a name="ln1010">    reverse_index_iter.Next();</a>
<a name="ln1011">  }</a>
<a name="ln1012"> </a>
<a name="ln1013">  if (apply_state &amp;&amp; regular_batch) {</a>
<a name="ln1014">    char tombstone_value_type = ValueTypeAsChar::kTombstone;</a>
<a name="ln1015">    std::array&lt;Slice, 1&gt; value_parts = {{Slice(&amp;tombstone_value_type, 1)}};</a>
<a name="ln1016">    PutApplyState(transaction_id_slice, commit_ht, write_id, value_parts, regular_batch);</a>
<a name="ln1017">  }</a>
<a name="ln1018"> </a>
<a name="ln1019">  return ApplyTransactionState {};</a>
<a name="ln1020">}</a>
<a name="ln1021"> </a>
<a name="ln1022">std::string ApplyTransactionState::ToString() const {</a>
<a name="ln1023">  return Format(&quot;{ key: $0 write_id: $1 }&quot;, Slice(key).ToDebugString(), write_id);</a>
<a name="ln1024">}</a>
<a name="ln1025"> </a>
<a name="ln1026">}  // namespace docdb</a>
<a name="ln1027">}  // namespace yb</a>

</code></pre>
<div class="balloon" rel="394"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="399"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="400"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="407"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="598"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="599"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="756"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="773"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="779"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="949"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="966"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="975"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="614"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: row_mark_.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
