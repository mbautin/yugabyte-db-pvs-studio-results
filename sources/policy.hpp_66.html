
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>policy.hpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//  Copyright John Maddock 2007.</a>
<a name="ln2">//  Use, modification and distribution are subject to the</a>
<a name="ln3">//  Boost Software License, Version 1.0. (See accompanying file</a>
<a name="ln4">//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)</a>
<a name="ln5"> </a>
<a name="ln6">#ifndef BOOST_MATH_POLICY_HPP</a>
<a name="ln7">#define BOOST_MATH_POLICY_HPP</a>
<a name="ln8"> </a>
<a name="ln9">#include &lt;boost/mpl/list.hpp&gt;</a>
<a name="ln10">#include &lt;boost/mpl/contains.hpp&gt;</a>
<a name="ln11">#include &lt;boost/mpl/if.hpp&gt;</a>
<a name="ln12">#include &lt;boost/mpl/find_if.hpp&gt;</a>
<a name="ln13">#include &lt;boost/mpl/remove_if.hpp&gt;</a>
<a name="ln14">#include &lt;boost/mpl/vector.hpp&gt;</a>
<a name="ln15">#include &lt;boost/mpl/push_back.hpp&gt;</a>
<a name="ln16">#include &lt;boost/mpl/at.hpp&gt;</a>
<a name="ln17">#include &lt;boost/mpl/size.hpp&gt;</a>
<a name="ln18">#include &lt;boost/mpl/comparison.hpp&gt;</a>
<a name="ln19">#include &lt;boost/type_traits/is_same.hpp&gt;</a>
<a name="ln20">#include &lt;boost/static_assert.hpp&gt;</a>
<a name="ln21">#include &lt;boost/assert.hpp&gt;</a>
<a name="ln22">#include &lt;boost/math/tools/config.hpp&gt;</a>
<a name="ln23">#include &lt;limits&gt;</a>
<a name="ln24">// Sadly we do need the .h versions of these to be sure of getting</a>
<a name="ln25">// FLT_MANT_DIG etc.</a>
<a name="ln26">#include &lt;limits.h&gt;</a>
<a name="ln27">#include &lt;stdlib.h&gt;</a>
<a name="ln28">#include &lt;stddef.h&gt;</a>
<a name="ln29">#include &lt;math.h&gt;</a>
<a name="ln30"> </a>
<a name="ln31">namespace boost{ namespace math{ </a>
<a name="ln32"> </a>
<a name="ln33">namespace tools{</a>
<a name="ln34"> </a>
<a name="ln35">template &lt;class T&gt;</a>
<a name="ln36">BOOST_MATH_CONSTEXPR int digits(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE(T)) BOOST_NOEXCEPT;</a>
<a name="ln37">template &lt;class T&gt;</a>
<a name="ln38">BOOST_MATH_CONSTEXPR T epsilon(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE(T)) BOOST_MATH_NOEXCEPT(T);</a>
<a name="ln39"> </a>
<a name="ln40">}</a>
<a name="ln41"> </a>
<a name="ln42">namespace policies{</a>
<a name="ln43"> </a>
<a name="ln44">//</a>
<a name="ln45">// Define macros for our default policies, if they're not defined already:</a>
<a name="ln46">//</a>
<a name="ln47">// Special cases for exceptions disabled first:</a>
<a name="ln48">//</a>
<a name="ln49">#ifdef BOOST_NO_EXCEPTIONS</a>
<a name="ln50">#  ifndef BOOST_MATH_DOMAIN_ERROR_POLICY</a>
<a name="ln51">#    define BOOST_MATH_DOMAIN_ERROR_POLICY errno_on_error</a>
<a name="ln52">#  endif</a>
<a name="ln53">#  ifndef BOOST_MATH_POLE_ERROR_POLICY</a>
<a name="ln54">#     define BOOST_MATH_POLE_ERROR_POLICY errno_on_error</a>
<a name="ln55">#  endif</a>
<a name="ln56">#  ifndef BOOST_MATH_OVERFLOW_ERROR_POLICY</a>
<a name="ln57">#     define BOOST_MATH_OVERFLOW_ERROR_POLICY errno_on_error</a>
<a name="ln58">#  endif</a>
<a name="ln59">#  ifndef BOOST_MATH_EVALUATION_ERROR_POLICY</a>
<a name="ln60">#     define BOOST_MATH_EVALUATION_ERROR_POLICY errno_on_error</a>
<a name="ln61">#  endif</a>
<a name="ln62">#  ifndef BOOST_MATH_ROUNDING_ERROR_POLICY</a>
<a name="ln63">#     define BOOST_MATH_ROUNDING_ERROR_POLICY errno_on_error</a>
<a name="ln64">#  endif</a>
<a name="ln65">#endif</a>
<a name="ln66">//</a>
<a name="ln67">// Then the regular cases:</a>
<a name="ln68">//</a>
<a name="ln69">#ifndef BOOST_MATH_DOMAIN_ERROR_POLICY</a>
<a name="ln70">#define BOOST_MATH_DOMAIN_ERROR_POLICY throw_on_error</a>
<a name="ln71">#endif</a>
<a name="ln72">#ifndef BOOST_MATH_POLE_ERROR_POLICY</a>
<a name="ln73">#define BOOST_MATH_POLE_ERROR_POLICY throw_on_error</a>
<a name="ln74">#endif</a>
<a name="ln75">#ifndef BOOST_MATH_OVERFLOW_ERROR_POLICY</a>
<a name="ln76">#define BOOST_MATH_OVERFLOW_ERROR_POLICY throw_on_error</a>
<a name="ln77">#endif</a>
<a name="ln78">#ifndef BOOST_MATH_EVALUATION_ERROR_POLICY</a>
<a name="ln79">#define BOOST_MATH_EVALUATION_ERROR_POLICY throw_on_error</a>
<a name="ln80">#endif</a>
<a name="ln81">#ifndef BOOST_MATH_ROUNDING_ERROR_POLICY</a>
<a name="ln82">#define BOOST_MATH_ROUNDING_ERROR_POLICY throw_on_error</a>
<a name="ln83">#endif</a>
<a name="ln84">#ifndef BOOST_MATH_UNDERFLOW_ERROR_POLICY</a>
<a name="ln85">#define BOOST_MATH_UNDERFLOW_ERROR_POLICY ignore_error</a>
<a name="ln86">#endif</a>
<a name="ln87">#ifndef BOOST_MATH_DENORM_ERROR_POLICY</a>
<a name="ln88">#define BOOST_MATH_DENORM_ERROR_POLICY ignore_error</a>
<a name="ln89">#endif</a>
<a name="ln90">#ifndef BOOST_MATH_INDETERMINATE_RESULT_ERROR_POLICY</a>
<a name="ln91">#define BOOST_MATH_INDETERMINATE_RESULT_ERROR_POLICY ignore_error</a>
<a name="ln92">#endif</a>
<a name="ln93">#ifndef BOOST_MATH_DIGITS10_POLICY</a>
<a name="ln94">#define BOOST_MATH_DIGITS10_POLICY 0</a>
<a name="ln95">#endif</a>
<a name="ln96">#ifndef BOOST_MATH_PROMOTE_FLOAT_POLICY</a>
<a name="ln97">#define BOOST_MATH_PROMOTE_FLOAT_POLICY true</a>
<a name="ln98">#endif</a>
<a name="ln99">#ifndef BOOST_MATH_PROMOTE_DOUBLE_POLICY</a>
<a name="ln100">#ifdef BOOST_MATH_NO_LONG_DOUBLE_MATH_FUNCTIONS</a>
<a name="ln101">#define BOOST_MATH_PROMOTE_DOUBLE_POLICY false</a>
<a name="ln102">#else</a>
<a name="ln103">#define BOOST_MATH_PROMOTE_DOUBLE_POLICY true</a>
<a name="ln104">#endif</a>
<a name="ln105">#endif</a>
<a name="ln106">#ifndef BOOST_MATH_DISCRETE_QUANTILE_POLICY</a>
<a name="ln107">#define BOOST_MATH_DISCRETE_QUANTILE_POLICY integer_round_outwards</a>
<a name="ln108">#endif</a>
<a name="ln109">#ifndef BOOST_MATH_ASSERT_UNDEFINED_POLICY</a>
<a name="ln110">#define BOOST_MATH_ASSERT_UNDEFINED_POLICY true</a>
<a name="ln111">#endif</a>
<a name="ln112">#ifndef BOOST_MATH_MAX_SERIES_ITERATION_POLICY</a>
<a name="ln113">#define BOOST_MATH_MAX_SERIES_ITERATION_POLICY 1000000</a>
<a name="ln114">#endif</a>
<a name="ln115">#ifndef BOOST_MATH_MAX_ROOT_ITERATION_POLICY</a>
<a name="ln116">#define BOOST_MATH_MAX_ROOT_ITERATION_POLICY 200</a>
<a name="ln117">#endif</a>
<a name="ln118"> </a>
<a name="ln119">#if !defined(__BORLANDC__)</a>
<a name="ln120">#define BOOST_MATH_META_INT(type, name, Default)\</a>
<a name="ln121">   template &lt;type N = Default&gt; struct name : public boost::mpl::int_&lt;N&gt;{};\</a>
<a name="ln122">   namespace detail{\</a>
<a name="ln123">   template &lt;type N&gt;\</a>
<a name="ln124">   char test_is_valid_arg(const name&lt;N&gt;*);\</a>
<a name="ln125">   char test_is_default_arg(const name&lt;Default&gt;*);\</a>
<a name="ln126">   template &lt;class T&gt; struct is_##name##_imp\</a>
<a name="ln127">   {\</a>
<a name="ln128">      template &lt;type N&gt; static char test(const name&lt;N&gt;*);\</a>
<a name="ln129">      static double test(...);\</a>
<a name="ln130">      BOOST_STATIC_CONSTANT(bool, value = sizeof(test(static_cast&lt;T*&gt;(0))) == 1);\</a>
<a name="ln131">   };\</a>
<a name="ln132">   }\</a>
<a name="ln133">   template &lt;class T&gt; struct is_##name : public boost::mpl::bool_&lt; ::boost::math::policies::detail::is_##name##_imp&lt;T&gt;::value&gt;{};</a>
<a name="ln134"> </a>
<a name="ln135">#define BOOST_MATH_META_BOOL(name, Default)\</a>
<a name="ln136">   template &lt;bool N = Default&gt; struct name : public boost::mpl::bool_&lt;N&gt;{};\</a>
<a name="ln137">   namespace detail{\</a>
<a name="ln138">   template &lt;bool N&gt;\</a>
<a name="ln139">   char test_is_valid_arg(const name&lt;N&gt;*);\</a>
<a name="ln140">   char test_is_default_arg(const name&lt;Default&gt;*);\</a>
<a name="ln141">   template &lt;class T&gt; struct is_##name##_imp\</a>
<a name="ln142">   {\</a>
<a name="ln143">      template &lt;bool N&gt; static char test(const name&lt;N&gt;*);\</a>
<a name="ln144">      static double test(...);\</a>
<a name="ln145">      BOOST_STATIC_CONSTANT(bool, value = sizeof(test(static_cast&lt;T*&gt;(0))) == 1);\</a>
<a name="ln146">   };\</a>
<a name="ln147">   }\</a>
<a name="ln148">   template &lt;class T&gt; struct is_##name : public boost::mpl::bool_&lt; ::boost::math::policies::detail::is_##name##_imp&lt;T&gt;::value&gt;{};</a>
<a name="ln149">#else</a>
<a name="ln150">#define BOOST_MATH_META_INT(Type, name, Default)\</a>
<a name="ln151">   template &lt;Type N = Default&gt; struct name : public boost::mpl::int_&lt;N&gt;{};\</a>
<a name="ln152">   namespace detail{\</a>
<a name="ln153">   template &lt;Type N&gt;\</a>
<a name="ln154">   char test_is_valid_arg(const name&lt;N&gt;*);\</a>
<a name="ln155">   char test_is_default_arg(const name&lt;Default&gt;*);\</a>
<a name="ln156">   template &lt;class T&gt; struct is_##name##_tester\</a>
<a name="ln157">   {\</a>
<a name="ln158">      template &lt;Type N&gt; static char test(const name&lt;N&gt;&amp;);\</a>
<a name="ln159">      static double test(...);\</a>
<a name="ln160">   };\</a>
<a name="ln161">   template &lt;class T&gt; struct is_##name##_imp\</a>
<a name="ln162">   {\</a>
<a name="ln163">      static T inst;\</a>
<a name="ln164">      BOOST_STATIC_CONSTANT(bool, value = sizeof( ::boost::math::policies::detail::is_##name##_tester&lt;T&gt;::test(inst)) == 1);\</a>
<a name="ln165">   };\</a>
<a name="ln166">   }\</a>
<a name="ln167">   template &lt;class T&gt; struct is_##name : public boost::mpl::bool_&lt; ::boost::math::policies::detail::is_##name##_imp&lt;T&gt;::value&gt;\</a>
<a name="ln168">   {\</a>
<a name="ln169">      template &lt;class U&gt; struct apply{ typedef is_##name&lt;U&gt; type; };\</a>
<a name="ln170">   };</a>
<a name="ln171"> </a>
<a name="ln172">#define BOOST_MATH_META_BOOL(name, Default)\</a>
<a name="ln173">   template &lt;bool N = Default&gt; struct name : public boost::mpl::bool_&lt;N&gt;{};\</a>
<a name="ln174">   namespace detail{\</a>
<a name="ln175">   template &lt;bool N&gt;\</a>
<a name="ln176">   char test_is_valid_arg(const name&lt;N&gt;*);\</a>
<a name="ln177">   char test_is_default_arg(const name&lt;Default&gt;*);\</a>
<a name="ln178">   template &lt;class T&gt; struct is_##name##_tester\</a>
<a name="ln179">   {\</a>
<a name="ln180">      template &lt;bool N&gt; static char test(const name&lt;N&gt;&amp;);\</a>
<a name="ln181">      static double test(...);\</a>
<a name="ln182">   };\</a>
<a name="ln183">   template &lt;class T&gt; struct is_##name##_imp\</a>
<a name="ln184">   {\</a>
<a name="ln185">      static T inst;\</a>
<a name="ln186">      BOOST_STATIC_CONSTANT(bool, value = sizeof( ::boost::math::policies::detail::is_##name##_tester&lt;T&gt;::test(inst)) == 1);\</a>
<a name="ln187">   };\</a>
<a name="ln188">   }\</a>
<a name="ln189">   template &lt;class T&gt; struct is_##name : public boost::mpl::bool_&lt; ::boost::math::policies::detail::is_##name##_imp&lt;T&gt;::value&gt;\</a>
<a name="ln190">   {\</a>
<a name="ln191">      template &lt;class U&gt; struct apply{ typedef is_##name&lt;U&gt; type;  };\</a>
<a name="ln192">   };</a>
<a name="ln193">#endif</a>
<a name="ln194">//</a>
<a name="ln195">// Begin by defining policy types for error handling:</a>
<a name="ln196">//</a>
<a name="ln197">enum error_policy_type</a>
<a name="ln198">{</a>
<a name="ln199">   throw_on_error = 0,</a>
<a name="ln200">   errno_on_error = 1,</a>
<a name="ln201">   ignore_error = 2,</a>
<a name="ln202">   user_error = 3</a>
<a name="ln203">};</a>
<a name="ln204"> </a>
<a name="ln205">BOOST_MATH_META_INT(error_policy_type, domain_error, BOOST_MATH_DOMAIN_ERROR_POLICY)</a>
<a name="ln206">BOOST_MATH_META_INT(error_policy_type, pole_error, BOOST_MATH_POLE_ERROR_POLICY)</a>
<a name="ln207">BOOST_MATH_META_INT(error_policy_type, overflow_error, BOOST_MATH_OVERFLOW_ERROR_POLICY)</a>
<a name="ln208">BOOST_MATH_META_INT(error_policy_type, underflow_error, BOOST_MATH_UNDERFLOW_ERROR_POLICY)</a>
<a name="ln209">BOOST_MATH_META_INT(error_policy_type, denorm_error, BOOST_MATH_DENORM_ERROR_POLICY)</a>
<a name="ln210">BOOST_MATH_META_INT(error_policy_type, evaluation_error, BOOST_MATH_EVALUATION_ERROR_POLICY)</a>
<a name="ln211">BOOST_MATH_META_INT(error_policy_type, rounding_error, BOOST_MATH_ROUNDING_ERROR_POLICY)</a>
<a name="ln212">BOOST_MATH_META_INT(error_policy_type, indeterminate_result_error, BOOST_MATH_INDETERMINATE_RESULT_ERROR_POLICY)</a>
<a name="ln213"> </a>
<a name="ln214">//</a>
<a name="ln215">// Policy types for internal promotion:</a>
<a name="ln216">//</a>
<a name="ln217">BOOST_MATH_META_BOOL(promote_float, BOOST_MATH_PROMOTE_FLOAT_POLICY)</a>
<a name="ln218">BOOST_MATH_META_BOOL(promote_double, BOOST_MATH_PROMOTE_DOUBLE_POLICY)</a>
<a name="ln219">BOOST_MATH_META_BOOL(assert_undefined, BOOST_MATH_ASSERT_UNDEFINED_POLICY)</a>
<a name="ln220">//</a>
<a name="ln221">// Policy types for discrete quantiles:</a>
<a name="ln222">//</a>
<a name="ln223">enum discrete_quantile_policy_type</a>
<a name="ln224">{</a>
<a name="ln225">   real,</a>
<a name="ln226">   integer_round_outwards,</a>
<a name="ln227">   integer_round_inwards,</a>
<a name="ln228">   integer_round_down,</a>
<a name="ln229">   integer_round_up,</a>
<a name="ln230">   integer_round_nearest</a>
<a name="ln231">};</a>
<a name="ln232"> </a>
<a name="ln233">BOOST_MATH_META_INT(discrete_quantile_policy_type, discrete_quantile, BOOST_MATH_DISCRETE_QUANTILE_POLICY)</a>
<a name="ln234">//</a>
<a name="ln235">// Precision:</a>
<a name="ln236">//</a>
<a name="ln237">BOOST_MATH_META_INT(int, digits10, BOOST_MATH_DIGITS10_POLICY)</a>
<a name="ln238">BOOST_MATH_META_INT(int, digits2, 0)</a>
<a name="ln239">//</a>
<a name="ln240">// Iterations:</a>
<a name="ln241">//</a>
<a name="ln242">BOOST_MATH_META_INT(unsigned long, max_series_iterations, BOOST_MATH_MAX_SERIES_ITERATION_POLICY)</a>
<a name="ln243">BOOST_MATH_META_INT(unsigned long, max_root_iterations, BOOST_MATH_MAX_ROOT_ITERATION_POLICY)</a>
<a name="ln244">//</a>
<a name="ln245">// Define the names for each possible policy:</a>
<a name="ln246">//</a>
<a name="ln247">#define BOOST_MATH_PARAMETER(name)\</a>
<a name="ln248">   BOOST_PARAMETER_TEMPLATE_KEYWORD(name##_name)\</a>
<a name="ln249">   BOOST_PARAMETER_NAME(name##_name)</a>
<a name="ln250"> </a>
<a name="ln251">struct default_policy{};</a>
<a name="ln252"> </a>
<a name="ln253">namespace detail{</a>
<a name="ln254">//</a>
<a name="ln255">// Trait to work out bits precision from digits10 and digits2:</a>
<a name="ln256">//</a>
<a name="ln257">template &lt;class Digits10, class Digits2&gt;</a>
<a name="ln258">struct precision</a>
<a name="ln259">{</a>
<a name="ln260">   //</a>
<a name="ln261">   // Now work out the precision:</a>
<a name="ln262">   //</a>
<a name="ln263">   typedef typename mpl::if_c&lt;</a>
<a name="ln264">      (Digits10::value == 0),</a>
<a name="ln265">      digits2&lt;0&gt;,</a>
<a name="ln266">      digits2&lt;((Digits10::value + 1) * 1000L) / 301L&gt;</a>
<a name="ln267">   &gt;::type digits2_type;</a>
<a name="ln268">public:</a>
<a name="ln269">#ifdef __BORLANDC__</a>
<a name="ln270">   typedef typename mpl::if_c&lt;</a>
<a name="ln271">      (Digits2::value &gt; ::boost::math::policies::detail::precision&lt;Digits10,Digits2&gt;::digits2_type::value),</a>
<a name="ln272">      Digits2, digits2_type&gt;::type type;</a>
<a name="ln273">#else</a>
<a name="ln274">   typedef typename mpl::if_c&lt;</a>
<a name="ln275">      (Digits2::value &gt; digits2_type::value),</a>
<a name="ln276">      Digits2, digits2_type&gt;::type type;</a>
<a name="ln277">#endif</a>
<a name="ln278">};</a>
<a name="ln279"> </a>
<a name="ln280">template &lt;class A, class B, bool b&gt;</a>
<a name="ln281">struct select_result</a>
<a name="ln282">{</a>
<a name="ln283">   typedef A type;</a>
<a name="ln284">};</a>
<a name="ln285">template &lt;class A, class B&gt;</a>
<a name="ln286">struct select_result&lt;A, B, false&gt;</a>
<a name="ln287">{</a>
<a name="ln288">   typedef typename mpl::deref&lt;B&gt;::type type;</a>
<a name="ln289">};</a>
<a name="ln290"> </a>
<a name="ln291">template &lt;class Seq, class Pred, class DefaultType&gt;</a>
<a name="ln292">struct find_arg</a>
<a name="ln293">{</a>
<a name="ln294">private:</a>
<a name="ln295">   typedef typename mpl::find_if&lt;Seq, Pred&gt;::type iter;</a>
<a name="ln296">   typedef typename mpl::end&lt;Seq&gt;::type end_type;</a>
<a name="ln297">public:</a>
<a name="ln298">   typedef typename select_result&lt;</a>
<a name="ln299">      DefaultType, iter,</a>
<a name="ln300">      ::boost::is_same&lt;iter, end_type&gt;::value&gt;::type type;</a>
<a name="ln301">};</a>
<a name="ln302"> </a>
<a name="ln303">double test_is_valid_arg(...);</a>
<a name="ln304">double test_is_default_arg(...);</a>
<a name="ln305">char test_is_valid_arg(const default_policy*);</a>
<a name="ln306">char test_is_default_arg(const default_policy*);</a>
<a name="ln307"> </a>
<a name="ln308">template &lt;class T&gt;</a>
<a name="ln309">struct is_valid_policy_imp </a>
<a name="ln310">{</a>
<a name="ln311">   BOOST_STATIC_CONSTANT(bool, value = sizeof(::boost::math::policies::detail::test_is_valid_arg(static_cast&lt;T*&gt;(0))) == 1);</a>
<a name="ln312">};</a>
<a name="ln313"> </a>
<a name="ln314">template &lt;class T&gt;</a>
<a name="ln315">struct is_default_policy_imp</a>
<a name="ln316">{</a>
<a name="ln317">   BOOST_STATIC_CONSTANT(bool, value = sizeof(::boost::math::policies::detail::test_is_default_arg(static_cast&lt;T*&gt;(0))) == 1);</a>
<a name="ln318">};</a>
<a name="ln319"> </a>
<a name="ln320">template &lt;class T&gt; struct is_valid_policy </a>
<a name="ln321">: public mpl::bool_&lt; </a>
<a name="ln322">   ::boost::math::policies::detail::is_valid_policy_imp&lt;T&gt;::value&gt;</a>
<a name="ln323">{};</a>
<a name="ln324"> </a>
<a name="ln325">template &lt;class T&gt; struct is_default_policy </a>
<a name="ln326">: public mpl::bool_&lt; </a>
<a name="ln327">   ::boost::math::policies::detail::is_default_policy_imp&lt;T&gt;::value&gt;</a>
<a name="ln328">{</a>
<a name="ln329">   template &lt;class U&gt;</a>
<a name="ln330">   struct apply</a>
<a name="ln331">   {</a>
<a name="ln332">      typedef is_default_policy&lt;U&gt; type;</a>
<a name="ln333">   };</a>
<a name="ln334">};</a>
<a name="ln335"> </a>
<a name="ln336">template &lt;class Seq, class T, int N&gt;</a>
<a name="ln337">struct append_N</a>
<a name="ln338">{</a>
<a name="ln339">   typedef typename mpl::push_back&lt;Seq, T&gt;::type new_seq;</a>
<a name="ln340">   typedef typename append_N&lt;new_seq, T, N-1&gt;::type type;</a>
<a name="ln341">};</a>
<a name="ln342"> </a>
<a name="ln343">template &lt;class Seq, class T&gt;</a>
<a name="ln344">struct append_N&lt;Seq, T, 0&gt;</a>
<a name="ln345">{</a>
<a name="ln346">   typedef Seq type;</a>
<a name="ln347">};</a>
<a name="ln348"> </a>
<a name="ln349">//</a>
<a name="ln350">// Traits class to work out what template parameters our default</a>
<a name="ln351">// policy&lt;&gt; class will have when modified for forwarding:</a>
<a name="ln352">//</a>
<a name="ln353">template &lt;bool f, bool d&gt;</a>
<a name="ln354">struct default_args</a>
<a name="ln355">{</a>
<a name="ln356">   typedef promote_float&lt;false&gt; arg1;</a>
<a name="ln357">   typedef promote_double&lt;false&gt; arg2;</a>
<a name="ln358">};</a>
<a name="ln359"> </a>
<a name="ln360">template &lt;&gt;</a>
<a name="ln361">struct default_args&lt;false, false&gt;</a>
<a name="ln362">{</a>
<a name="ln363">   typedef default_policy arg1;</a>
<a name="ln364">   typedef default_policy arg2;</a>
<a name="ln365">};</a>
<a name="ln366"> </a>
<a name="ln367">template &lt;&gt;</a>
<a name="ln368">struct default_args&lt;true, false&gt;</a>
<a name="ln369">{</a>
<a name="ln370">   typedef promote_float&lt;false&gt; arg1;</a>
<a name="ln371">   typedef default_policy arg2;</a>
<a name="ln372">};</a>
<a name="ln373"> </a>
<a name="ln374">template &lt;&gt;</a>
<a name="ln375">struct default_args&lt;false, true&gt;</a>
<a name="ln376">{</a>
<a name="ln377">   typedef promote_double&lt;false&gt; arg1;</a>
<a name="ln378">   typedef default_policy arg2;</a>
<a name="ln379">};</a>
<a name="ln380"> </a>
<a name="ln381">typedef default_args&lt;BOOST_MATH_PROMOTE_FLOAT_POLICY, BOOST_MATH_PROMOTE_DOUBLE_POLICY&gt;::arg1 forwarding_arg1;</a>
<a name="ln382">typedef default_args&lt;BOOST_MATH_PROMOTE_FLOAT_POLICY, BOOST_MATH_PROMOTE_DOUBLE_POLICY&gt;::arg2 forwarding_arg2;</a>
<a name="ln383"> </a>
<a name="ln384">} // detail</a>
<a name="ln385">//</a>
<a name="ln386">// Now define the policy type with enough arguments to handle all</a>
<a name="ln387">// the policies:</a>
<a name="ln388">//</a>
<a name="ln389">template &lt;class A1 = default_policy, </a>
<a name="ln390">          class A2 = default_policy, </a>
<a name="ln391">          class A3 = default_policy,</a>
<a name="ln392">          class A4 = default_policy,</a>
<a name="ln393">          class A5 = default_policy,</a>
<a name="ln394">          class A6 = default_policy,</a>
<a name="ln395">          class A7 = default_policy,</a>
<a name="ln396">          class A8 = default_policy,</a>
<a name="ln397">          class A9 = default_policy,</a>
<a name="ln398">          class A10 = default_policy,</a>
<a name="ln399">          class A11 = default_policy,</a>
<a name="ln400">          class A12 = default_policy,</a>
<a name="ln401">          class A13 = default_policy&gt;</a>
<a name="ln402">struct policy</a>
<a name="ln403">{</a>
<a name="ln404">private:</a>
<a name="ln405">   //</a>
<a name="ln406">   // Validate all our arguments:</a>
<a name="ln407">   //</a>
<a name="ln408">   BOOST_STATIC_ASSERT(::boost::math::policies::detail::is_valid_policy&lt;A1&gt;::value);</a>
<a name="ln409">   BOOST_STATIC_ASSERT(::boost::math::policies::detail::is_valid_policy&lt;A2&gt;::value);</a>
<a name="ln410">   BOOST_STATIC_ASSERT(::boost::math::policies::detail::is_valid_policy&lt;A3&gt;::value);</a>
<a name="ln411">   BOOST_STATIC_ASSERT(::boost::math::policies::detail::is_valid_policy&lt;A4&gt;::value);</a>
<a name="ln412">   BOOST_STATIC_ASSERT(::boost::math::policies::detail::is_valid_policy&lt;A5&gt;::value);</a>
<a name="ln413">   BOOST_STATIC_ASSERT(::boost::math::policies::detail::is_valid_policy&lt;A6&gt;::value);</a>
<a name="ln414">   BOOST_STATIC_ASSERT(::boost::math::policies::detail::is_valid_policy&lt;A7&gt;::value);</a>
<a name="ln415">   BOOST_STATIC_ASSERT(::boost::math::policies::detail::is_valid_policy&lt;A8&gt;::value);</a>
<a name="ln416">   BOOST_STATIC_ASSERT(::boost::math::policies::detail::is_valid_policy&lt;A9&gt;::value);</a>
<a name="ln417">   BOOST_STATIC_ASSERT(::boost::math::policies::detail::is_valid_policy&lt;A10&gt;::value);</a>
<a name="ln418">   BOOST_STATIC_ASSERT(::boost::math::policies::detail::is_valid_policy&lt;A11&gt;::value);</a>
<a name="ln419">   BOOST_STATIC_ASSERT(::boost::math::policies::detail::is_valid_policy&lt;A12&gt;::value);</a>
<a name="ln420">   BOOST_STATIC_ASSERT(::boost::math::policies::detail::is_valid_policy&lt;A13&gt;::value);</a>
<a name="ln421">   //</a>
<a name="ln422">   // Typelist of the arguments:</a>
<a name="ln423">   //</a>
<a name="ln424">   typedef mpl::list&lt;A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11,A12,A13&gt; arg_list;</a>
<a name="ln425"> </a>
<a name="ln426">public:</a>
<a name="ln427">   typedef typename detail::find_arg&lt;arg_list, is_domain_error&lt;mpl::_1&gt;, domain_error&lt;&gt; &gt;::type domain_error_type;</a>
<a name="ln428">   typedef typename detail::find_arg&lt;arg_list, is_pole_error&lt;mpl::_1&gt;, pole_error&lt;&gt; &gt;::type pole_error_type;</a>
<a name="ln429">   typedef typename detail::find_arg&lt;arg_list, is_overflow_error&lt;mpl::_1&gt;, overflow_error&lt;&gt; &gt;::type overflow_error_type;</a>
<a name="ln430">   typedef typename detail::find_arg&lt;arg_list, is_underflow_error&lt;mpl::_1&gt;, underflow_error&lt;&gt; &gt;::type underflow_error_type;</a>
<a name="ln431">   typedef typename detail::find_arg&lt;arg_list, is_denorm_error&lt;mpl::_1&gt;, denorm_error&lt;&gt; &gt;::type denorm_error_type;</a>
<a name="ln432">   typedef typename detail::find_arg&lt;arg_list, is_evaluation_error&lt;mpl::_1&gt;, evaluation_error&lt;&gt; &gt;::type evaluation_error_type;</a>
<a name="ln433">   typedef typename detail::find_arg&lt;arg_list, is_rounding_error&lt;mpl::_1&gt;, rounding_error&lt;&gt; &gt;::type rounding_error_type;</a>
<a name="ln434">   typedef typename detail::find_arg&lt;arg_list, is_indeterminate_result_error&lt;mpl::_1&gt;, indeterminate_result_error&lt;&gt; &gt;::type indeterminate_result_error_type;</a>
<a name="ln435">private:</a>
<a name="ln436">   //</a>
<a name="ln437">   // Now work out the precision:</a>
<a name="ln438">   //</a>
<a name="ln439">   typedef typename detail::find_arg&lt;arg_list, is_digits10&lt;mpl::_1&gt;, digits10&lt;&gt; &gt;::type digits10_type;</a>
<a name="ln440">   typedef typename detail::find_arg&lt;arg_list, is_digits2&lt;mpl::_1&gt;, digits2&lt;&gt; &gt;::type bits_precision_type;</a>
<a name="ln441">public:</a>
<a name="ln442">   typedef typename detail::precision&lt;digits10_type, bits_precision_type&gt;::type precision_type;</a>
<a name="ln443">   //</a>
<a name="ln444">   // Internal promotion:</a>
<a name="ln445">   //</a>
<a name="ln446">   typedef typename detail::find_arg&lt;arg_list, is_promote_float&lt;mpl::_1&gt;, promote_float&lt;&gt; &gt;::type promote_float_type;</a>
<a name="ln447">   typedef typename detail::find_arg&lt;arg_list, is_promote_double&lt;mpl::_1&gt;, promote_double&lt;&gt; &gt;::type promote_double_type;</a>
<a name="ln448">   //</a>
<a name="ln449">   // Discrete quantiles:</a>
<a name="ln450">   //</a>
<a name="ln451">   typedef typename detail::find_arg&lt;arg_list, is_discrete_quantile&lt;mpl::_1&gt;, discrete_quantile&lt;&gt; &gt;::type discrete_quantile_type;</a>
<a name="ln452">   //</a>
<a name="ln453">   // Mathematically undefined properties:</a>
<a name="ln454">   //</a>
<a name="ln455">   typedef typename detail::find_arg&lt;arg_list, is_assert_undefined&lt;mpl::_1&gt;, assert_undefined&lt;&gt; &gt;::type assert_undefined_type;</a>
<a name="ln456">   //</a>
<a name="ln457">   // Max iterations:</a>
<a name="ln458">   //</a>
<a name="ln459">   typedef typename detail::find_arg&lt;arg_list, is_max_series_iterations&lt;mpl::_1&gt;, max_series_iterations&lt;&gt; &gt;::type max_series_iterations_type;</a>
<a name="ln460">   typedef typename detail::find_arg&lt;arg_list, is_max_root_iterations&lt;mpl::_1&gt;, max_root_iterations&lt;&gt; &gt;::type max_root_iterations_type;</a>
<a name="ln461">};</a>
<a name="ln462">//</a>
<a name="ln463">// These full specializations are defined to reduce the amount of</a>
<a name="ln464">// template instantiations that have to take place when using the default</a>
<a name="ln465">// policies, they have quite a large impact on compile times:</a>
<a name="ln466">//</a>
<a name="ln467">template &lt;&gt;</a>
<a name="ln468">struct policy&lt;default_policy, default_policy, default_policy, default_policy, default_policy, default_policy, default_policy, default_policy, default_policy, default_policy, default_policy&gt;</a>
<a name="ln469">{</a>
<a name="ln470">public:</a>
<a name="ln471">   typedef domain_error&lt;&gt; domain_error_type;</a>
<a name="ln472">   typedef pole_error&lt;&gt; pole_error_type;</a>
<a name="ln473">   typedef overflow_error&lt;&gt; overflow_error_type;</a>
<a name="ln474">   typedef underflow_error&lt;&gt; underflow_error_type;</a>
<a name="ln475">   typedef denorm_error&lt;&gt; denorm_error_type;</a>
<a name="ln476">   typedef evaluation_error&lt;&gt; evaluation_error_type;</a>
<a name="ln477">   typedef rounding_error&lt;&gt; rounding_error_type;</a>
<a name="ln478">   typedef indeterminate_result_error&lt;&gt; indeterminate_result_error_type;</a>
<a name="ln479">#if BOOST_MATH_DIGITS10_POLICY == 0</a>
<a name="ln480">   typedef digits2&lt;&gt; precision_type;</a>
<a name="ln481">#else</a>
<a name="ln482">   typedef detail::precision&lt;digits10&lt;&gt;, digits2&lt;&gt; &gt;::type precision_type;</a>
<a name="ln483">#endif</a>
<a name="ln484">   typedef promote_float&lt;&gt; promote_float_type;</a>
<a name="ln485">   typedef promote_double&lt;&gt; promote_double_type;</a>
<a name="ln486">   typedef discrete_quantile&lt;&gt; discrete_quantile_type;</a>
<a name="ln487">   typedef assert_undefined&lt;&gt; assert_undefined_type;</a>
<a name="ln488">   typedef max_series_iterations&lt;&gt; max_series_iterations_type;</a>
<a name="ln489">   typedef max_root_iterations&lt;&gt; max_root_iterations_type;</a>
<a name="ln490">};</a>
<a name="ln491"> </a>
<a name="ln492">template &lt;&gt;</a>
<a name="ln493">struct policy&lt;detail::forwarding_arg1, detail::forwarding_arg2, default_policy, default_policy, default_policy, default_policy, default_policy, default_policy, default_policy, default_policy, default_policy&gt;</a>
<a name="ln494">{</a>
<a name="ln495">public:</a>
<a name="ln496">   typedef domain_error&lt;&gt; domain_error_type;</a>
<a name="ln497">   typedef pole_error&lt;&gt; pole_error_type;</a>
<a name="ln498">   typedef overflow_error&lt;&gt; overflow_error_type;</a>
<a name="ln499">   typedef underflow_error&lt;&gt; underflow_error_type;</a>
<a name="ln500">   typedef denorm_error&lt;&gt; denorm_error_type;</a>
<a name="ln501">   typedef evaluation_error&lt;&gt; evaluation_error_type;</a>
<a name="ln502">   typedef rounding_error&lt;&gt; rounding_error_type;</a>
<a name="ln503">   typedef indeterminate_result_error&lt;&gt; indeterminate_result_error_type;</a>
<a name="ln504">#if BOOST_MATH_DIGITS10_POLICY == 0</a>
<a name="ln505">   typedef digits2&lt;&gt; precision_type;</a>
<a name="ln506">#else</a>
<a name="ln507">   typedef detail::precision&lt;digits10&lt;&gt;, digits2&lt;&gt; &gt;::type precision_type;</a>
<a name="ln508">#endif</a>
<a name="ln509">   typedef promote_float&lt;false&gt; promote_float_type;</a>
<a name="ln510">   typedef promote_double&lt;false&gt; promote_double_type;</a>
<a name="ln511">   typedef discrete_quantile&lt;&gt; discrete_quantile_type;</a>
<a name="ln512">   typedef assert_undefined&lt;&gt; assert_undefined_type;</a>
<a name="ln513">   typedef max_series_iterations&lt;&gt; max_series_iterations_type;</a>
<a name="ln514">   typedef max_root_iterations&lt;&gt; max_root_iterations_type;</a>
<a name="ln515">};</a>
<a name="ln516"> </a>
<a name="ln517">template &lt;class Policy, </a>
<a name="ln518">          class A1 = default_policy, </a>
<a name="ln519">          class A2 = default_policy, </a>
<a name="ln520">          class A3 = default_policy,</a>
<a name="ln521">          class A4 = default_policy,</a>
<a name="ln522">          class A5 = default_policy,</a>
<a name="ln523">          class A6 = default_policy,</a>
<a name="ln524">          class A7 = default_policy,</a>
<a name="ln525">          class A8 = default_policy,</a>
<a name="ln526">          class A9 = default_policy,</a>
<a name="ln527">          class A10 = default_policy,</a>
<a name="ln528">          class A11 = default_policy,</a>
<a name="ln529">          class A12 = default_policy,</a>
<a name="ln530">          class A13 = default_policy&gt;</a>
<a name="ln531">struct normalise</a>
<a name="ln532">{</a>
<a name="ln533">private:</a>
<a name="ln534">   typedef mpl::list&lt;A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11,A12,A13&gt; arg_list;</a>
<a name="ln535">   typedef typename detail::find_arg&lt;arg_list, is_domain_error&lt;mpl::_1&gt;, typename Policy::domain_error_type &gt;::type domain_error_type;</a>
<a name="ln536">   typedef typename detail::find_arg&lt;arg_list, is_pole_error&lt;mpl::_1&gt;, typename Policy::pole_error_type &gt;::type pole_error_type;</a>
<a name="ln537">   typedef typename detail::find_arg&lt;arg_list, is_overflow_error&lt;mpl::_1&gt;, typename Policy::overflow_error_type &gt;::type overflow_error_type;</a>
<a name="ln538">   typedef typename detail::find_arg&lt;arg_list, is_underflow_error&lt;mpl::_1&gt;, typename Policy::underflow_error_type &gt;::type underflow_error_type;</a>
<a name="ln539">   typedef typename detail::find_arg&lt;arg_list, is_denorm_error&lt;mpl::_1&gt;, typename Policy::denorm_error_type &gt;::type denorm_error_type;</a>
<a name="ln540">   typedef typename detail::find_arg&lt;arg_list, is_evaluation_error&lt;mpl::_1&gt;, typename Policy::evaluation_error_type &gt;::type evaluation_error_type;</a>
<a name="ln541">   typedef typename detail::find_arg&lt;arg_list, is_rounding_error&lt;mpl::_1&gt;, typename Policy::rounding_error_type &gt;::type rounding_error_type;</a>
<a name="ln542">   typedef typename detail::find_arg&lt;arg_list, is_indeterminate_result_error&lt;mpl::_1&gt;, typename Policy::indeterminate_result_error_type &gt;::type indeterminate_result_error_type;</a>
<a name="ln543">   //</a>
<a name="ln544">   // Now work out the precision:</a>
<a name="ln545">   //</a>
<a name="ln546">   typedef typename detail::find_arg&lt;arg_list, is_digits10&lt;mpl::_1&gt;, digits10&lt;&gt; &gt;::type digits10_type;</a>
<a name="ln547">   typedef typename detail::find_arg&lt;arg_list, is_digits2&lt;mpl::_1&gt;, typename Policy::precision_type &gt;::type bits_precision_type;</a>
<a name="ln548">   typedef typename detail::precision&lt;digits10_type, bits_precision_type&gt;::type precision_type;</a>
<a name="ln549">   //</a>
<a name="ln550">   // Internal promotion:</a>
<a name="ln551">   //</a>
<a name="ln552">   typedef typename detail::find_arg&lt;arg_list, is_promote_float&lt;mpl::_1&gt;, typename Policy::promote_float_type &gt;::type promote_float_type;</a>
<a name="ln553">   typedef typename detail::find_arg&lt;arg_list, is_promote_double&lt;mpl::_1&gt;, typename Policy::promote_double_type &gt;::type promote_double_type;</a>
<a name="ln554">   //</a>
<a name="ln555">   // Discrete quantiles:</a>
<a name="ln556">   //</a>
<a name="ln557">   typedef typename detail::find_arg&lt;arg_list, is_discrete_quantile&lt;mpl::_1&gt;, typename Policy::discrete_quantile_type &gt;::type discrete_quantile_type;</a>
<a name="ln558">   //</a>
<a name="ln559">   // Mathematically undefined properties:</a>
<a name="ln560">   //</a>
<a name="ln561">   typedef typename detail::find_arg&lt;arg_list, is_assert_undefined&lt;mpl::_1&gt;, typename Policy::assert_undefined_type &gt;::type assert_undefined_type;</a>
<a name="ln562">   //</a>
<a name="ln563">   // Max iterations:</a>
<a name="ln564">   //</a>
<a name="ln565">   typedef typename detail::find_arg&lt;arg_list, is_max_series_iterations&lt;mpl::_1&gt;, typename Policy::max_series_iterations_type&gt;::type max_series_iterations_type;</a>
<a name="ln566">   typedef typename detail::find_arg&lt;arg_list, is_max_root_iterations&lt;mpl::_1&gt;, typename Policy::max_root_iterations_type&gt;::type max_root_iterations_type;</a>
<a name="ln567">   //</a>
<a name="ln568">   // Define a typelist of the policies:</a>
<a name="ln569">   //</a>
<a name="ln570">   typedef mpl::vector&lt;</a>
<a name="ln571">      domain_error_type,</a>
<a name="ln572">      pole_error_type,</a>
<a name="ln573">      overflow_error_type,</a>
<a name="ln574">      underflow_error_type,</a>
<a name="ln575">      denorm_error_type,</a>
<a name="ln576">      evaluation_error_type,</a>
<a name="ln577">      rounding_error_type,</a>
<a name="ln578">      indeterminate_result_error_type,</a>
<a name="ln579">      precision_type,</a>
<a name="ln580">      promote_float_type,</a>
<a name="ln581">      promote_double_type,</a>
<a name="ln582">      discrete_quantile_type,</a>
<a name="ln583">      assert_undefined_type,</a>
<a name="ln584">      max_series_iterations_type,</a>
<a name="ln585">      max_root_iterations_type&gt; result_list;</a>
<a name="ln586">   //</a>
<a name="ln587">   // Remove all the policies that are the same as the default:</a>
<a name="ln588">   //</a>
<a name="ln589">   typedef typename mpl::remove_if&lt;result_list, detail::is_default_policy&lt;mpl::_&gt; &gt;::type reduced_list;</a>
<a name="ln590">   //</a>
<a name="ln591">   // Pad out the list with defaults:</a>
<a name="ln592">   //</a>
<a name="ln593">   typedef typename detail::append_N&lt;reduced_list, default_policy, (14 - ::boost::mpl::size&lt;reduced_list&gt;::value)&gt;::type result_type;</a>
<a name="ln594">public:</a>
<a name="ln595">   typedef policy&lt;</a>
<a name="ln596">      typename mpl::at&lt;result_type, mpl::int_&lt;0&gt; &gt;::type,</a>
<a name="ln597">      typename mpl::at&lt;result_type, mpl::int_&lt;1&gt; &gt;::type,</a>
<a name="ln598">      typename mpl::at&lt;result_type, mpl::int_&lt;2&gt; &gt;::type,</a>
<a name="ln599">      typename mpl::at&lt;result_type, mpl::int_&lt;3&gt; &gt;::type,</a>
<a name="ln600">      typename mpl::at&lt;result_type, mpl::int_&lt;4&gt; &gt;::type,</a>
<a name="ln601">      typename mpl::at&lt;result_type, mpl::int_&lt;5&gt; &gt;::type,</a>
<a name="ln602">      typename mpl::at&lt;result_type, mpl::int_&lt;6&gt; &gt;::type,</a>
<a name="ln603">      typename mpl::at&lt;result_type, mpl::int_&lt;7&gt; &gt;::type,</a>
<a name="ln604">      typename mpl::at&lt;result_type, mpl::int_&lt;8&gt; &gt;::type,</a>
<a name="ln605">      typename mpl::at&lt;result_type, mpl::int_&lt;9&gt; &gt;::type,</a>
<a name="ln606">      typename mpl::at&lt;result_type, mpl::int_&lt;10&gt; &gt;::type,</a>
<a name="ln607">      typename mpl::at&lt;result_type, mpl::int_&lt;11&gt; &gt;::type,</a>
<a name="ln608">      typename mpl::at&lt;result_type, mpl::int_&lt;12&gt; &gt;::type &gt; type;</a>
<a name="ln609">};</a>
<a name="ln610">//</a>
<a name="ln611">// Full specialisation to speed up compilation of the common case:</a>
<a name="ln612">//</a>
<a name="ln613">template &lt;&gt;</a>
<a name="ln614">struct normalise&lt;policy&lt;&gt;, </a>
<a name="ln615">          promote_float&lt;false&gt;, </a>
<a name="ln616">          promote_double&lt;false&gt;, </a>
<a name="ln617">          discrete_quantile&lt;&gt;,</a>
<a name="ln618">          assert_undefined&lt;&gt;,</a>
<a name="ln619">          default_policy,</a>
<a name="ln620">          default_policy,</a>
<a name="ln621">          default_policy,</a>
<a name="ln622">          default_policy,</a>
<a name="ln623">          default_policy,</a>
<a name="ln624">          default_policy,</a>
<a name="ln625">          default_policy&gt;</a>
<a name="ln626">{</a>
<a name="ln627">   typedef policy&lt;detail::forwarding_arg1, detail::forwarding_arg2&gt; type;</a>
<a name="ln628">};</a>
<a name="ln629"> </a>
<a name="ln630">template &lt;&gt;</a>
<a name="ln631">struct normalise&lt;policy&lt;detail::forwarding_arg1, detail::forwarding_arg2&gt;,</a>
<a name="ln632">          promote_float&lt;false&gt;,</a>
<a name="ln633">          promote_double&lt;false&gt;,</a>
<a name="ln634">          discrete_quantile&lt;&gt;,</a>
<a name="ln635">          assert_undefined&lt;&gt;,</a>
<a name="ln636">          default_policy,</a>
<a name="ln637">          default_policy,</a>
<a name="ln638">          default_policy,</a>
<a name="ln639">          default_policy,</a>
<a name="ln640">          default_policy,</a>
<a name="ln641">          default_policy,</a>
<a name="ln642">          default_policy&gt;</a>
<a name="ln643">{</a>
<a name="ln644">   typedef policy&lt;detail::forwarding_arg1, detail::forwarding_arg2&gt; type;</a>
<a name="ln645">};</a>
<a name="ln646"> </a>
<a name="ln647">inline BOOST_MATH_CONSTEXPR policy&lt;&gt; make_policy() BOOST_NOEXCEPT</a>
<a name="ln648">{ return policy&lt;&gt;(); }</a>
<a name="ln649"> </a>
<a name="ln650">template &lt;class A1&gt;</a>
<a name="ln651">inline BOOST_MATH_CONSTEXPR typename normalise&lt;policy&lt;&gt;, A1&gt;::type make_policy(const A1&amp;) BOOST_NOEXCEPT</a>
<a name="ln652">{ </a>
<a name="ln653">   typedef typename normalise&lt;policy&lt;&gt;, A1&gt;::type result_type;</a>
<a name="ln654">   return result_type(); </a>
<a name="ln655">}</a>
<a name="ln656"> </a>
<a name="ln657">template &lt;class A1, class A2&gt;</a>
<a name="ln658">inline BOOST_MATH_CONSTEXPR typename normalise&lt;policy&lt;&gt;, A1, A2&gt;::type make_policy(const A1&amp;, const A2&amp;) BOOST_NOEXCEPT</a>
<a name="ln659">{ </a>
<a name="ln660">   typedef typename normalise&lt;policy&lt;&gt;, A1, A2&gt;::type result_type;</a>
<a name="ln661">   return result_type(); </a>
<a name="ln662">}</a>
<a name="ln663"> </a>
<a name="ln664">template &lt;class A1, class A2, class A3&gt;</a>
<a name="ln665">inline BOOST_MATH_CONSTEXPR typename normalise&lt;policy&lt;&gt;, A1, A2, A3&gt;::type make_policy(const A1&amp;, const A2&amp;, const A3&amp;) BOOST_NOEXCEPT</a>
<a name="ln666">{ </a>
<a name="ln667">   typedef typename normalise&lt;policy&lt;&gt;, A1, A2, A3&gt;::type result_type;</a>
<a name="ln668">   return result_type(); </a>
<a name="ln669">}</a>
<a name="ln670"> </a>
<a name="ln671">template &lt;class A1, class A2, class A3, class A4&gt;</a>
<a name="ln672">inline BOOST_MATH_CONSTEXPR typename normalise&lt;policy&lt;&gt;, A1, A2, A3, A4&gt;::type make_policy(const A1&amp;, const A2&amp;, const A3&amp;, const A4&amp;) BOOST_NOEXCEPT</a>
<a name="ln673">{ </a>
<a name="ln674">   typedef typename normalise&lt;policy&lt;&gt;, A1, A2, A3, A4&gt;::type result_type;</a>
<a name="ln675">   return result_type(); </a>
<a name="ln676">}</a>
<a name="ln677"> </a>
<a name="ln678">template &lt;class A1, class A2, class A3, class A4, class A5&gt;</a>
<a name="ln679">inline BOOST_MATH_CONSTEXPR typename normalise&lt;policy&lt;&gt;, A1, A2, A3, A4, A5&gt;::type make_policy(const A1&amp;, const A2&amp;, const A3&amp;, const A4&amp;, const A5&amp;) BOOST_NOEXCEPT</a>
<a name="ln680">{ </a>
<a name="ln681">   typedef typename normalise&lt;policy&lt;&gt;, A1, A2, A3, A4, A5&gt;::type result_type;</a>
<a name="ln682">   return result_type(); </a>
<a name="ln683">}</a>
<a name="ln684"> </a>
<a name="ln685">template &lt;class A1, class A2, class A3, class A4, class A5, class A6&gt;</a>
<a name="ln686">inline BOOST_MATH_CONSTEXPR typename normalise&lt;policy&lt;&gt;, A1, A2, A3, A4, A5, A6&gt;::type make_policy(const A1&amp;, const A2&amp;, const A3&amp;, const A4&amp;, const A5&amp;, const A6&amp;) BOOST_NOEXCEPT</a>
<a name="ln687">{ </a>
<a name="ln688">   typedef typename normalise&lt;policy&lt;&gt;, A1, A2, A3, A4, A5, A6&gt;::type result_type;</a>
<a name="ln689">   return result_type(); </a>
<a name="ln690">}</a>
<a name="ln691"> </a>
<a name="ln692">template &lt;class A1, class A2, class A3, class A4, class A5, class A6, class A7&gt;</a>
<a name="ln693">inline BOOST_MATH_CONSTEXPR typename normalise&lt;policy&lt;&gt;, A1, A2, A3, A4, A5, A6, A7&gt;::type make_policy(const A1&amp;, const A2&amp;, const A3&amp;, const A4&amp;, const A5&amp;, const A6&amp;, const A7&amp;) BOOST_NOEXCEPT</a>
<a name="ln694">{ </a>
<a name="ln695">   typedef typename normalise&lt;policy&lt;&gt;, A1, A2, A3, A4, A5, A6, A7&gt;::type result_type;</a>
<a name="ln696">   return result_type(); </a>
<a name="ln697">}</a>
<a name="ln698"> </a>
<a name="ln699">template &lt;class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8&gt;</a>
<a name="ln700">inline BOOST_MATH_CONSTEXPR typename normalise&lt;policy&lt;&gt;, A1, A2, A3, A4, A5, A6, A7, A8&gt;::type make_policy(const A1&amp;, const A2&amp;, const A3&amp;, const A4&amp;, const A5&amp;, const A6&amp;, const A7&amp;, const A8&amp;) BOOST_NOEXCEPT</a>
<a name="ln701">{ </a>
<a name="ln702">   typedef typename normalise&lt;policy&lt;&gt;, A1, A2, A3, A4, A5, A6, A7, A8&gt;::type result_type;</a>
<a name="ln703">   return result_type(); </a>
<a name="ln704">}</a>
<a name="ln705"> </a>
<a name="ln706">template &lt;class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9&gt;</a>
<a name="ln707">inline BOOST_MATH_CONSTEXPR typename normalise&lt;policy&lt;&gt;, A1, A2, A3, A4, A5, A6, A7, A8, A9&gt;::type make_policy(const A1&amp;, const A2&amp;, const A3&amp;, const A4&amp;, const A5&amp;, const A6&amp;, const A7&amp;, const A8&amp;, const A9&amp;) BOOST_NOEXCEPT</a>
<a name="ln708">{ </a>
<a name="ln709">   typedef typename normalise&lt;policy&lt;&gt;, A1, A2, A3, A4, A5, A6, A7, A8, A9&gt;::type result_type;</a>
<a name="ln710">   return result_type(); </a>
<a name="ln711">}</a>
<a name="ln712"> </a>
<a name="ln713">template &lt;class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10&gt;</a>
<a name="ln714">inline BOOST_MATH_CONSTEXPR typename normalise&lt;policy&lt;&gt;, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10&gt;::type make_policy(const A1&amp;, const A2&amp;, const A3&amp;, const A4&amp;, const A5&amp;, const A6&amp;, const A7&amp;, const A8&amp;, const A9&amp;, const A10&amp;) BOOST_NOEXCEPT</a>
<a name="ln715">{ </a>
<a name="ln716">   typedef typename normalise&lt;policy&lt;&gt;, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10&gt;::type result_type;</a>
<a name="ln717">   return result_type(); </a>
<a name="ln718">}</a>
<a name="ln719"> </a>
<a name="ln720">template &lt;class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11&gt;</a>
<a name="ln721">inline BOOST_MATH_CONSTEXPR typename normalise&lt;policy&lt;&gt;, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11&gt;::type make_policy(const A1&amp;, const A2&amp;, const A3&amp;, const A4&amp;, const A5&amp;, const A6&amp;, const A7&amp;, const A8&amp;, const A9&amp;, const A10&amp;, const A11&amp;) BOOST_NOEXCEPT</a>
<a name="ln722">{</a>
<a name="ln723">   typedef typename normalise&lt;policy&lt;&gt;, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11&gt;::type result_type;</a>
<a name="ln724">   return result_type();</a>
<a name="ln725">}</a>
<a name="ln726"> </a>
<a name="ln727">//</a>
<a name="ln728">// Traits class to handle internal promotion:</a>
<a name="ln729">//</a>
<a name="ln730">template &lt;class Real, class Policy&gt;</a>
<a name="ln731">struct evaluation</a>
<a name="ln732">{</a>
<a name="ln733">   typedef Real type;</a>
<a name="ln734">};</a>
<a name="ln735"> </a>
<a name="ln736">template &lt;class Policy&gt;</a>
<a name="ln737">struct evaluation&lt;float, Policy&gt;</a>
<a name="ln738">{</a>
<a name="ln739">   typedef typename mpl::if_&lt;typename Policy::promote_float_type, double, float&gt;::type type;</a>
<a name="ln740">};</a>
<a name="ln741"> </a>
<a name="ln742">template &lt;class Policy&gt;</a>
<a name="ln743">struct evaluation&lt;double, Policy&gt;</a>
<a name="ln744">{</a>
<a name="ln745">   typedef typename mpl::if_&lt;typename Policy::promote_double_type, long double, double&gt;::type type;</a>
<a name="ln746">};</a>
<a name="ln747"> </a>
<a name="ln748">#ifdef BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS</a>
<a name="ln749"> </a>
<a name="ln750">template &lt;class Real&gt;</a>
<a name="ln751">struct basic_digits : public mpl::int_&lt;0&gt;{ };</a>
<a name="ln752">template &lt;&gt;</a>
<a name="ln753">struct basic_digits&lt;float&gt; : public mpl::int_&lt;FLT_MANT_DIG&gt;{ };</a>
<a name="ln754">template &lt;&gt;</a>
<a name="ln755">struct basic_digits&lt;double&gt; : public mpl::int_&lt;DBL_MANT_DIG&gt;{ };</a>
<a name="ln756">template &lt;&gt;</a>
<a name="ln757">struct basic_digits&lt;long double&gt; : public mpl::int_&lt;LDBL_MANT_DIG&gt;{ };</a>
<a name="ln758"> </a>
<a name="ln759">template &lt;class Real, class Policy&gt;</a>
<a name="ln760">struct precision</a>
<a name="ln761">{</a>
<a name="ln762">   BOOST_STATIC_ASSERT( ::std::numeric_limits&lt;Real&gt;::radix == 2);</a>
<a name="ln763">   typedef typename Policy::precision_type precision_type;</a>
<a name="ln764">   typedef basic_digits&lt;Real&gt; digits_t;</a>
<a name="ln765">   typedef typename mpl::if_&lt;</a>
<a name="ln766">      mpl::equal_to&lt;digits_t, mpl::int_&lt;0&gt; &gt;,</a>
<a name="ln767">      // Possibly unknown precision:</a>
<a name="ln768">      precision_type,</a>
<a name="ln769">      typename mpl::if_&lt;</a>
<a name="ln770">         mpl::or_&lt;mpl::less_equal&lt;digits_t, precision_type&gt;, mpl::less_equal&lt;precision_type, mpl::int_&lt;0&gt; &gt; &gt;,</a>
<a name="ln771">         // Default case, full precision for RealType:</a>
<a name="ln772">         digits2&lt; ::std::numeric_limits&lt;Real&gt;::digits&gt;,</a>
<a name="ln773">         // User customised precision:</a>
<a name="ln774">         precision_type</a>
<a name="ln775">      &gt;::type</a>
<a name="ln776">   &gt;::type type;</a>
<a name="ln777">};</a>
<a name="ln778"> </a>
<a name="ln779">template &lt;class Policy&gt;</a>
<a name="ln780">struct precision&lt;float, Policy&gt;</a>
<a name="ln781">{</a>
<a name="ln782">   typedef digits2&lt;FLT_MANT_DIG&gt; type;</a>
<a name="ln783">};</a>
<a name="ln784">template &lt;class Policy&gt;</a>
<a name="ln785">struct precision&lt;double, Policy&gt;</a>
<a name="ln786">{</a>
<a name="ln787">   typedef digits2&lt;DBL_MANT_DIG&gt; type;</a>
<a name="ln788">};</a>
<a name="ln789">template &lt;class Policy&gt;</a>
<a name="ln790">struct precision&lt;long double, Policy&gt;</a>
<a name="ln791">{</a>
<a name="ln792">   typedef digits2&lt;LDBL_MANT_DIG&gt; type;</a>
<a name="ln793">};</a>
<a name="ln794"> </a>
<a name="ln795">#else</a>
<a name="ln796"> </a>
<a name="ln797">template &lt;class Real, class Policy&gt;</a>
<a name="ln798">struct precision</a>
<a name="ln799">{</a>
<a name="ln800">   BOOST_STATIC_ASSERT((::std::numeric_limits&lt;Real&gt;::radix == 2) || ((::std::numeric_limits&lt;Real&gt;::is_specialized == 0) || (::std::numeric_limits&lt;Real&gt;::digits == 0)));</a>
<a name="ln801">#ifndef __BORLANDC__</a>
<a name="ln802">   typedef typename Policy::precision_type precision_type;</a>
<a name="ln803">   typedef typename mpl::if_c&lt;</a>
<a name="ln804">      ((::std::numeric_limits&lt;Real&gt;::is_specialized == 0) || (::std::numeric_limits&lt;Real&gt;::digits == 0)),</a>
<a name="ln805">      // Possibly unknown precision:</a>
<a name="ln806">      precision_type,</a>
<a name="ln807">      typename mpl::if_c&lt;</a>
<a name="ln808">         ((::std::numeric_limits&lt;Real&gt;::digits &lt;= precision_type::value) </a>
<a name="ln809">         || (Policy::precision_type::value &lt;= 0)),</a>
<a name="ln810">         // Default case, full precision for RealType:</a>
<a name="ln811">         digits2&lt; ::std::numeric_limits&lt;Real&gt;::digits&gt;,</a>
<a name="ln812">         // User customised precision:</a>
<a name="ln813">         precision_type</a>
<a name="ln814">      &gt;::type</a>
<a name="ln815">   &gt;::type type;</a>
<a name="ln816">#else</a>
<a name="ln817">   typedef typename Policy::precision_type precision_type;</a>
<a name="ln818">   typedef mpl::int_&lt; ::std::numeric_limits&lt;Real&gt;::digits&gt; digits_t;</a>
<a name="ln819">   typedef mpl::bool_&lt; ::std::numeric_limits&lt;Real&gt;::is_specialized&gt; spec_t;</a>
<a name="ln820">   typedef typename mpl::if_&lt;</a>
<a name="ln821">      mpl::or_&lt;mpl::equal_to&lt;spec_t, mpl::false_&gt;, mpl::equal_to&lt;digits_t, mpl::int_&lt;0&gt; &gt; &gt;,</a>
<a name="ln822">      // Possibly unknown precision:</a>
<a name="ln823">      precision_type,</a>
<a name="ln824">      typename mpl::if_&lt;</a>
<a name="ln825">         mpl::or_&lt;mpl::less_equal&lt;digits_t, precision_type&gt;, mpl::less_equal&lt;precision_type, mpl::int_&lt;0&gt; &gt; &gt;,</a>
<a name="ln826">         // Default case, full precision for RealType:</a>
<a name="ln827">         digits2&lt; ::std::numeric_limits&lt;Real&gt;::digits&gt;,</a>
<a name="ln828">         // User customised precision:</a>
<a name="ln829">         precision_type</a>
<a name="ln830">      &gt;::type</a>
<a name="ln831">   &gt;::type type;</a>
<a name="ln832">#endif</a>
<a name="ln833">};</a>
<a name="ln834"> </a>
<a name="ln835">#endif</a>
<a name="ln836"> </a>
<a name="ln837">#ifdef BOOST_MATH_USE_FLOAT128</a>
<a name="ln838"> </a>
<a name="ln839">template &lt;class Policy&gt;</a>
<a name="ln840">struct precision&lt;BOOST_MATH_FLOAT128_TYPE, Policy&gt;</a>
<a name="ln841">{</a>
<a name="ln842">   typedef mpl::int_&lt;113&gt; type;</a>
<a name="ln843">};</a>
<a name="ln844"> </a>
<a name="ln845">#endif</a>
<a name="ln846"> </a>
<a name="ln847">namespace detail{</a>
<a name="ln848"> </a>
<a name="ln849">template &lt;class T, class Policy&gt;</a>
<a name="ln850">inline BOOST_MATH_CONSTEXPR int digits_imp(mpl::true_ const&amp;) BOOST_NOEXCEPT</a>
<a name="ln851">{</a>
<a name="ln852">#ifndef BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS</a>
<a name="ln853">   BOOST_STATIC_ASSERT( ::std::numeric_limits&lt;T&gt;::is_specialized);</a>
<a name="ln854">#else</a>
<a name="ln855">   BOOST_ASSERT(::std::numeric_limits&lt;T&gt;::is_specialized);</a>
<a name="ln856">#endif</a>
<a name="ln857">   typedef typename boost::math::policies::precision&lt;T, Policy&gt;::type p_t;</a>
<a name="ln858">   return p_t::value;</a>
<a name="ln859">}</a>
<a name="ln860"> </a>
<a name="ln861">template &lt;class T, class Policy&gt;</a>
<a name="ln862">inline BOOST_MATH_CONSTEXPR int digits_imp(mpl::false_ const&amp;) BOOST_NOEXCEPT</a>
<a name="ln863">{</a>
<a name="ln864">   return tools::digits&lt;T&gt;();</a>
<a name="ln865">}</a>
<a name="ln866"> </a>
<a name="ln867">} // namespace detail</a>
<a name="ln868"> </a>
<a name="ln869">template &lt;class T, class Policy&gt;</a>
<a name="ln870">inline BOOST_MATH_CONSTEXPR int digits(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE(T)) BOOST_NOEXCEPT</a>
<a name="ln871">{</a>
<a name="ln872">   typedef mpl::bool_&lt; std::numeric_limits&lt;T&gt;::is_specialized &gt; tag_type;</a>
<a name="ln873">   return detail::digits_imp&lt;T, Policy&gt;(tag_type());</a>
<a name="ln874">}</a>
<a name="ln875">template &lt;class T, class Policy&gt;</a>
<a name="ln876">inline BOOST_MATH_CONSTEXPR int digits_base10(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE(T)) BOOST_NOEXCEPT</a>
<a name="ln877">{</a>
<a name="ln878">   return boost::math::policies::digits&lt;T, Policy&gt;() * 301 / 1000L;</a>
<a name="ln879">}</a>
<a name="ln880"> </a>
<a name="ln881">template &lt;class Policy&gt;</a>
<a name="ln882">inline BOOST_MATH_CONSTEXPR unsigned long get_max_series_iterations() BOOST_NOEXCEPT</a>
<a name="ln883">{</a>
<a name="ln884">   typedef typename Policy::max_series_iterations_type iter_type;</a>
<a name="ln885">   return iter_type::value;</a>
<a name="ln886">}</a>
<a name="ln887"> </a>
<a name="ln888">template &lt;class Policy&gt;</a>
<a name="ln889">inline BOOST_MATH_CONSTEXPR unsigned long get_max_root_iterations() BOOST_NOEXCEPT</a>
<a name="ln890">{</a>
<a name="ln891">   typedef typename Policy::max_root_iterations_type iter_type;</a>
<a name="ln892">   return iter_type::value;</a>
<a name="ln893">}</a>
<a name="ln894"> </a>
<a name="ln895">namespace detail{</a>
<a name="ln896"> </a>
<a name="ln897">template &lt;class T, class Digits, class Small, class Default&gt;</a>
<a name="ln898">struct series_factor_calc</a>
<a name="ln899">{</a>
<a name="ln900">   static T get() BOOST_MATH_NOEXCEPT(T)</a>
<a name="ln901">   {</a>
<a name="ln902">      return ldexp(T(1.0), 1 - Digits::value);</a>
<a name="ln903">   }</a>
<a name="ln904">};</a>
<a name="ln905"> </a>
<a name="ln906">template &lt;class T, class Digits&gt;</a>
<a name="ln907">struct series_factor_calc&lt;T, Digits, mpl::true_, mpl::true_&gt;</a>
<a name="ln908">{</a>
<a name="ln909">   static BOOST_MATH_CONSTEXPR T get() BOOST_MATH_NOEXCEPT(T)</a>
<a name="ln910">   {</a>
<a name="ln911">      return boost::math::tools::epsilon&lt;T&gt;();</a>
<a name="ln912">   }</a>
<a name="ln913">};</a>
<a name="ln914">template &lt;class T, class Digits&gt;</a>
<a name="ln915">struct series_factor_calc&lt;T, Digits, mpl::true_, mpl::false_&gt;</a>
<a name="ln916">{</a>
<a name="ln917">   static BOOST_MATH_CONSTEXPR T get() BOOST_MATH_NOEXCEPT(T)</a>
<a name="ln918">   {</a>
<a name="ln919">      return 1 / static_cast&lt;T&gt;(static_cast&lt;boost::uintmax_t&gt;(1u) &lt;&lt; (Digits::value - 1));</a>
<a name="ln920">   }</a>
<a name="ln921">};</a>
<a name="ln922">template &lt;class T, class Digits&gt;</a>
<a name="ln923">struct series_factor_calc&lt;T, Digits, mpl::false_, mpl::true_&gt;</a>
<a name="ln924">{</a>
<a name="ln925">   static BOOST_MATH_CONSTEXPR T get() BOOST_MATH_NOEXCEPT(T)</a>
<a name="ln926">   {</a>
<a name="ln927">      return boost::math::tools::epsilon&lt;T&gt;();</a>
<a name="ln928">   }</a>
<a name="ln929">};</a>
<a name="ln930"> </a>
<a name="ln931">template &lt;class T, class Policy&gt;</a>
<a name="ln932">inline BOOST_MATH_CONSTEXPR T get_epsilon_imp(mpl::true_ const&amp;) BOOST_MATH_NOEXCEPT(T)</a>
<a name="ln933">{</a>
<a name="ln934">#ifndef BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS</a>
<a name="ln935">   BOOST_STATIC_ASSERT( ::std::numeric_limits&lt;T&gt;::is_specialized);</a>
<a name="ln936">   BOOST_STATIC_ASSERT( ::std::numeric_limits&lt;T&gt;::radix == 2);</a>
<a name="ln937">#else</a>
<a name="ln938">   BOOST_ASSERT(::std::numeric_limits&lt;T&gt;::is_specialized);</a>
<a name="ln939">   BOOST_ASSERT(::std::numeric_limits&lt;T&gt;::radix == 2);</a>
<a name="ln940">#endif</a>
<a name="ln941">   typedef typename boost::math::policies::precision&lt;T, Policy&gt;::type p_t;</a>
<a name="ln942">   typedef mpl::bool_&lt;p_t::value &lt;= std::numeric_limits&lt;boost::uintmax_t&gt;::digits&gt; is_small_int;</a>
<a name="ln943">   typedef mpl::bool_&lt;p_t::value &gt;= std::numeric_limits&lt;T&gt;::digits&gt; is_default_value;</a>
<a name="ln944">   return series_factor_calc&lt;T, p_t, is_small_int, is_default_value&gt;::get();</a>
<a name="ln945">}</a>
<a name="ln946"> </a>
<a name="ln947">template &lt;class T, class Policy&gt;</a>
<a name="ln948">inline BOOST_MATH_CONSTEXPR T get_epsilon_imp(mpl::false_ const&amp;) BOOST_MATH_NOEXCEPT(T)</a>
<a name="ln949">{</a>
<a name="ln950">   return tools::epsilon&lt;T&gt;();</a>
<a name="ln951">}</a>
<a name="ln952"> </a>
<a name="ln953">} // namespace detail</a>
<a name="ln954"> </a>
<a name="ln955">template &lt;class T, class Policy&gt;</a>
<a name="ln956">inline BOOST_MATH_CONSTEXPR T get_epsilon(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE(T)) BOOST_MATH_NOEXCEPT(T)</a>
<a name="ln957">{</a>
<a name="ln958">   typedef mpl::bool_&lt; (std::numeric_limits&lt;T&gt;::is_specialized &amp;&amp; (std::numeric_limits&lt;T&gt;::radix == 2)) &gt; tag_type;</a>
<a name="ln959">   return detail::get_epsilon_imp&lt;T, Policy&gt;(tag_type());</a>
<a name="ln960">}</a>
<a name="ln961"> </a>
<a name="ln962">namespace detail{</a>
<a name="ln963"> </a>
<a name="ln964">template &lt;class A1, </a>
<a name="ln965">          class A2, </a>
<a name="ln966">          class A3,</a>
<a name="ln967">          class A4,</a>
<a name="ln968">          class A5,</a>
<a name="ln969">          class A6,</a>
<a name="ln970">          class A7,</a>
<a name="ln971">          class A8,</a>
<a name="ln972">          class A9,</a>
<a name="ln973">          class A10,</a>
<a name="ln974">          class A11&gt;</a>
<a name="ln975">char test_is_policy(const policy&lt;A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11&gt;*);</a>
<a name="ln976">double test_is_policy(...);</a>
<a name="ln977"> </a>
<a name="ln978">template &lt;class P&gt;</a>
<a name="ln979">struct is_policy_imp</a>
<a name="ln980">{</a>
<a name="ln981">   BOOST_STATIC_CONSTANT(bool, value = (sizeof(::boost::math::policies::detail::test_is_policy(static_cast&lt;P*&gt;(0))) == 1));</a>
<a name="ln982">};</a>
<a name="ln983"> </a>
<a name="ln984">}</a>
<a name="ln985"> </a>
<a name="ln986">template &lt;class P&gt;</a>
<a name="ln987">struct is_policy : public mpl::bool_&lt; ::boost::math::policies::detail::is_policy_imp&lt;P&gt;::value&gt; {};</a>
<a name="ln988"> </a>
<a name="ln989">//</a>
<a name="ln990">// Helper traits class for distribution error handling:</a>
<a name="ln991">//</a>
<a name="ln992">template &lt;class Policy&gt;</a>
<a name="ln993">struct constructor_error_check</a>
<a name="ln994">{</a>
<a name="ln995">   typedef typename Policy::domain_error_type domain_error_type;</a>
<a name="ln996">   typedef typename mpl::if_c&lt;</a>
<a name="ln997">      (domain_error_type::value == throw_on_error) || (domain_error_type::value == user_error) || (domain_error_type::value == errno_on_error),</a>
<a name="ln998">      mpl::true_,</a>
<a name="ln999">      mpl::false_&gt;::type type;</a>
<a name="ln1000">};</a>
<a name="ln1001"> </a>
<a name="ln1002">template &lt;class Policy&gt;</a>
<a name="ln1003">struct method_error_check</a>
<a name="ln1004">{</a>
<a name="ln1005">   typedef typename Policy::domain_error_type domain_error_type;</a>
<a name="ln1006">   typedef typename mpl::if_c&lt;</a>
<a name="ln1007">      (domain_error_type::value == throw_on_error) &amp;&amp; (domain_error_type::value != user_error),</a>
<a name="ln1008">      mpl::false_,</a>
<a name="ln1009">      mpl::true_&gt;::type type;</a>
<a name="ln1010">};</a>
<a name="ln1011">//</a>
<a name="ln1012">// Does the Policy ever throw on error?</a>
<a name="ln1013">//</a>
<a name="ln1014">template &lt;class Policy&gt;</a>
<a name="ln1015">struct is_noexcept_error_policy</a>
<a name="ln1016">{</a>
<a name="ln1017">   typedef typename Policy::domain_error_type               t1;</a>
<a name="ln1018">   typedef typename Policy::pole_error_type                 t2;</a>
<a name="ln1019">   typedef typename Policy::overflow_error_type             t3;</a>
<a name="ln1020">   typedef typename Policy::underflow_error_type            t4;</a>
<a name="ln1021">   typedef typename Policy::denorm_error_type               t5;</a>
<a name="ln1022">   typedef typename Policy::evaluation_error_type           t6;</a>
<a name="ln1023">   typedef typename Policy::rounding_error_type             t7;</a>
<a name="ln1024">   typedef typename Policy::indeterminate_result_error_type t8;</a>
<a name="ln1025"> </a>
<a name="ln1026">   BOOST_STATIC_CONSTANT(bool, value = </a>
<a name="ln1027">      ((t1::value != throw_on_error) &amp;&amp; (t1::value != user_error)</a>
<a name="ln1028">      &amp;&amp; (t2::value != throw_on_error) &amp;&amp; (t2::value != user_error)</a>
<a name="ln1029">      &amp;&amp; (t3::value != throw_on_error) &amp;&amp; (t3::value != user_error)</a>
<a name="ln1030">      &amp;&amp; (t4::value != throw_on_error) &amp;&amp; (t4::value != user_error)</a>
<a name="ln1031">      &amp;&amp; (t5::value != throw_on_error) &amp;&amp; (t5::value != user_error)</a>
<a name="ln1032">      &amp;&amp; (t6::value != throw_on_error) &amp;&amp; (t6::value != user_error)</a>
<a name="ln1033">      &amp;&amp; (t7::value != throw_on_error) &amp;&amp; (t7::value != user_error)</a>
<a name="ln1034">      &amp;&amp; (t8::value != throw_on_error) &amp;&amp; (t8::value != user_error)));</a>
<a name="ln1035">};</a>
<a name="ln1036"> </a>
<a name="ln1037">}}} // namespaces</a>
<a name="ln1038"> </a>
<a name="ln1039">#endif // BOOST_MATH_POLICY_HPP</a>
<a name="ln1040"> </a>

</code></pre>
<div class="balloon" rel="1026"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v562/" target="_blank">V562</a> It's odd to compare a bool type value with a value of 3: t1::value != user_error.</p></div>
<div class="balloon" rel="1026"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v562/" target="_blank">V562</a> It's odd to compare a bool type value with a value of 3: t2::value != user_error.</p></div>
<div class="balloon" rel="1026"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v562/" target="_blank">V562</a> It's odd to compare a bool type value with a value of 3: t3::value != user_error.</p></div>
<div class="balloon" rel="1026"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v562/" target="_blank">V562</a> It's odd to compare a bool type value with a value of 3: t4::value != user_error.</p></div>
<div class="balloon" rel="1026"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v562/" target="_blank">V562</a> It's odd to compare a bool type value with a value of 3: t5::value != user_error.</p></div>
<div class="balloon" rel="1026"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v562/" target="_blank">V562</a> It's odd to compare a bool type value with a value of 3: t6::value != user_error.</p></div>
<div class="balloon" rel="1026"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v562/" target="_blank">V562</a> It's odd to compare a bool type value with a value of 3: t7::value != user_error.</p></div>
<div class="balloon" rel="1026"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v562/" target="_blank">V562</a> It's odd to compare a bool type value with a value of 3: t8::value != user_error.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
