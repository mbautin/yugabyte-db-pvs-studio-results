
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>log_util.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Licensed to the Apache Software Foundation (ASF) under one</a>
<a name="ln2">// or more contributor license agreements.  See the NOTICE file</a>
<a name="ln3">// distributed with this work for additional information</a>
<a name="ln4">// regarding copyright ownership.  The ASF licenses this file</a>
<a name="ln5">// to you under the Apache License, Version 2.0 (the</a>
<a name="ln6">// &quot;License&quot;); you may not use this file except in compliance</a>
<a name="ln7">// with the License.  You may obtain a copy of the License at</a>
<a name="ln8">//</a>
<a name="ln9">//   http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln10">//</a>
<a name="ln11">// Unless required by applicable law or agreed to in writing,</a>
<a name="ln12">// software distributed under the License is distributed on an</a>
<a name="ln13">// &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</a>
<a name="ln14">// KIND, either express or implied.  See the License for the</a>
<a name="ln15">// specific language governing permissions and limitations</a>
<a name="ln16">// under the License.</a>
<a name="ln17">//</a>
<a name="ln18">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln19">//</a>
<a name="ln20">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln21">//</a>
<a name="ln22">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln23">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln24">//</a>
<a name="ln25">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln26">//</a>
<a name="ln27">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln28">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln29">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln30">// under the License.</a>
<a name="ln31">//</a>
<a name="ln32"> </a>
<a name="ln33">#ifndef YB_CONSENSUS_LOG_UTIL_H_</a>
<a name="ln34">#define YB_CONSENSUS_LOG_UTIL_H_</a>
<a name="ln35"> </a>
<a name="ln36">#include &lt;iosfwd&gt;</a>
<a name="ln37">#include &lt;map&gt;</a>
<a name="ln38">#include &lt;memory&gt;</a>
<a name="ln39">#include &lt;string&gt;</a>
<a name="ln40">#include &lt;utility&gt;</a>
<a name="ln41">#include &lt;vector&gt;</a>
<a name="ln42"> </a>
<a name="ln43">#include &lt;gtest/gtest.h&gt;</a>
<a name="ln44"> </a>
<a name="ln45">#include &quot;yb/consensus/log.pb.h&quot;</a>
<a name="ln46">#include &quot;yb/consensus/consensus_fwd.h&quot;</a>
<a name="ln47">#include &quot;yb/gutil/macros.h&quot;</a>
<a name="ln48">#include &quot;yb/gutil/ref_counted.h&quot;</a>
<a name="ln49">#include &quot;yb/util/atomic.h&quot;</a>
<a name="ln50">#include &quot;yb/util/env.h&quot;</a>
<a name="ln51">#include &quot;yb/util/monotime.h&quot;</a>
<a name="ln52">#include &quot;yb/util/opid.h&quot;</a>
<a name="ln53">#include &quot;yb/util/restart_safe_clock.h&quot;</a>
<a name="ln54">#include &quot;yb/util/tostring.h&quot;</a>
<a name="ln55"> </a>
<a name="ln56">// Used by other classes, now part of the API.</a>
<a name="ln57">DECLARE_bool(durable_wal_write);</a>
<a name="ln58">DECLARE_bool(require_durable_wal_write);</a>
<a name="ln59">DECLARE_string(fs_wal_dirs);</a>
<a name="ln60">DECLARE_string(fs_data_dirs);</a>
<a name="ln61"> </a>
<a name="ln62">namespace yb {</a>
<a name="ln63"> </a>
<a name="ln64">namespace consensus {</a>
<a name="ln65">class ReplicateMsg;</a>
<a name="ln66">struct OpIdBiggerThanFunctor;</a>
<a name="ln67">} // namespace consensus</a>
<a name="ln68"> </a>
<a name="ln69">namespace log {</a>
<a name="ln70"> </a>
<a name="ln71">// Suffix for temporary files</a>
<a name="ln72">extern const char kTmpSuffix[];</a>
<a name="ln73"> </a>
<a name="ln74">// Each log entry is prefixed by its length (4 bytes), CRC (4 bytes),</a>
<a name="ln75">// and checksum of the other two fields (see EntryHeader struct below).</a>
<a name="ln76">extern const size_t kEntryHeaderSize;</a>
<a name="ln77"> </a>
<a name="ln78">extern const int kLogMajorVersion;</a>
<a name="ln79">extern const int kLogMinorVersion;</a>
<a name="ln80"> </a>
<a name="ln81">class ReadableLogSegment;</a>
<a name="ln82"> </a>
<a name="ln83">// Options for the Write Ahead Log. The LogOptions constructor initializes default field values</a>
<a name="ln84">// based on flags. See log_util.cc for details.</a>
<a name="ln85">struct LogOptions {</a>
<a name="ln86"> </a>
<a name="ln87">  // The size of a Log segment.</a>
<a name="ln88">  // Logs will roll over upon reaching this size.</a>
<a name="ln89">  size_t segment_size_bytes;</a>
<a name="ln90"> </a>
<a name="ln91">  size_t initial_segment_size_bytes;</a>
<a name="ln92"> </a>
<a name="ln93">  // Whether to call fsync on every call to Append().</a>
<a name="ln94">  bool durable_wal_write;</a>
<a name="ln95"> </a>
<a name="ln96">  // If non-zero, call fsync on a call to Append() every interval of time.</a>
<a name="ln97">  MonoDelta interval_durable_wal_write;</a>
<a name="ln98"> </a>
<a name="ln99">  // If non-zero, call fsync on a call to Append() if more than given amount of data to sync.</a>
<a name="ln100">  int32_t bytes_durable_wal_write_mb;</a>
<a name="ln101"> </a>
<a name="ln102">  // Whether to fallocate segments before writing to them.</a>
<a name="ln103">  bool preallocate_segments;</a>
<a name="ln104"> </a>
<a name="ln105">  // Whether the allocation should happen asynchronously.</a>
<a name="ln106">  bool async_preallocate_segments;</a>
<a name="ln107"> </a>
<a name="ln108">  uint32_t retention_secs = 0;</a>
<a name="ln109"> </a>
<a name="ln110">  // Env for log file operations.</a>
<a name="ln111">  Env* env;</a>
<a name="ln112"> </a>
<a name="ln113">  std::string peer_uuid;</a>
<a name="ln114"> </a>
<a name="ln115">  uint64_t initial_active_segment_sequence_number = 0;</a>
<a name="ln116"> </a>
<a name="ln117">  LogOptions();</a>
<a name="ln118">};</a>
<a name="ln119"> </a>
<a name="ln120">struct LogEntryMetadata {</a>
<a name="ln121">  RestartSafeCoarseTimePoint entry_time;</a>
<a name="ln122">  int64_t offset;</a>
<a name="ln123">  uint64_t active_segment_sequence_number;</a>
<a name="ln124"> </a>
<a name="ln125">  std::string ToString() const {</a>
<a name="ln126">    return Format(&quot;{ entry_time: $0 offset: $1 active_segment_sequence_number: $2 }&quot;,</a>
<a name="ln127">                  entry_time, offset, active_segment_sequence_number);</a>
<a name="ln128">  }</a>
<a name="ln129">};</a>
<a name="ln130"> </a>
<a name="ln131">// A sequence of segments, ordered by increasing sequence number.</a>
<a name="ln132">typedef std::vector&lt;scoped_refptr&lt;ReadableLogSegment&gt; &gt; SegmentSequence;</a>
<a name="ln133">typedef std::vector&lt;std::unique_ptr&lt;LogEntryPB&gt;&gt; LogEntries;</a>
<a name="ln134"> </a>
<a name="ln135">struct ReadEntriesResult {</a>
<a name="ln136">  // Read entries</a>
<a name="ln137">  LogEntries entries;</a>
<a name="ln138"> </a>
<a name="ln139">  // Time, offset in WAL, and sequence number of respective entry</a>
<a name="ln140">  std::vector&lt;LogEntryMetadata&gt; entry_metadata;</a>
<a name="ln141"> </a>
<a name="ln142">  // Where we finished reading</a>
<a name="ln143">  int64_t end_offset;</a>
<a name="ln144"> </a>
<a name="ln145">  yb::OpId committed_op_id;</a>
<a name="ln146"> </a>
<a name="ln147">  // Failure status</a>
<a name="ln148">  Status status;</a>
<a name="ln149">};</a>
<a name="ln150"> </a>
<a name="ln151">struct FirstEntryMetadata {</a>
<a name="ln152">  OpId op_id;</a>
<a name="ln153">  RestartSafeCoarseTimePoint entry_time;</a>
<a name="ln154"> </a>
<a name="ln155">  std::string ToString() const {</a>
<a name="ln156">    return YB_STRUCT_TO_STRING(op_id, entry_time);</a>
<a name="ln157">  }</a>
<a name="ln158">};</a>
<a name="ln159"> </a>
<a name="ln160">// A segment of the log can either be a ReadableLogSegment (for replay and</a>
<a name="ln161">// consensus catch-up) or a WritableLogSegment (where the Log actually stores</a>
<a name="ln162">// state). LogSegments have a maximum size defined in LogOptions (set from the</a>
<a name="ln163">// log_segment_size_mb flag, which defaults to 64). Upon reaching this size</a>
<a name="ln164">// segments are rolled over and the Log continues in a new segment.</a>
<a name="ln165"> </a>
<a name="ln166">// A readable log segment for recovery and follower catch-up.</a>
<a name="ln167">class ReadableLogSegment : public RefCountedThreadSafe&lt;ReadableLogSegment&gt; {</a>
<a name="ln168"> public:</a>
<a name="ln169">  // Factory method to construct a ReadableLogSegment from a file on the FS.</a>
<a name="ln170">  static CHECKED_STATUS Open(Env* env,</a>
<a name="ln171">                     const std::string&amp; path,</a>
<a name="ln172">                     scoped_refptr&lt;ReadableLogSegment&gt;* segment);</a>
<a name="ln173"> </a>
<a name="ln174">  // Build a readable segment to read entries from the provided path.</a>
<a name="ln175">  ReadableLogSegment(std::string path,</a>
<a name="ln176">                     std::shared_ptr&lt;RandomAccessFile&gt; readable_file);</a>
<a name="ln177"> </a>
<a name="ln178">  // Initialize the ReadableLogSegment.</a>
<a name="ln179">  // This initializer provides methods for avoiding disk IO when creating a</a>
<a name="ln180">  // ReadableLogSegment for the current WritableLogSegment, i.e. for reading</a>
<a name="ln181">  // the log entries in the same segment that is currently being written to.</a>
<a name="ln182">  CHECKED_STATUS Init(const LogSegmentHeaderPB&amp; header,</a>
<a name="ln183">              int64_t first_entry_offset);</a>
<a name="ln184"> </a>
<a name="ln185">  // Initialize the ReadableLogSegment.</a>
<a name="ln186">  // This initializer provides methods for avoiding disk IO when creating a</a>
<a name="ln187">  // ReadableLogSegment from a WritableLogSegment (i.e. for log rolling).</a>
<a name="ln188">  CHECKED_STATUS Init(const LogSegmentHeaderPB&amp; header,</a>
<a name="ln189">                      const LogSegmentFooterPB&amp; footer,</a>
<a name="ln190">                      int64_t first_entry_offset);</a>
<a name="ln191"> </a>
<a name="ln192">  // Initialize the ReadableLogSegment.</a>
<a name="ln193">  // This initializer will parse the log segment header and footer.</a>
<a name="ln194">  // Note: This returns Status and may fail.</a>
<a name="ln195">  CHECKED_STATUS Init();</a>
<a name="ln196"> </a>
<a name="ln197">  // Reads all entries of the provided segment.</a>
<a name="ln198">  //</a>
<a name="ln199">  // If the log is corrupted (i.e. the returned 'Status' is 'Corruption') all</a>
<a name="ln200">  // the log entries read up to the corrupted one are returned in the 'entries'</a>
<a name="ln201">  // vector.</a>
<a name="ln202">  //</a>
<a name="ln203">  // All gathered information is returned in result.</a>
<a name="ln204">  // In case of failure status field of result is not ok.</a>
<a name="ln205">  //</a>
<a name="ln206">  // Will stop after reading max_entries_to_read entries.</a>
<a name="ln207">  ReadEntriesResult ReadEntries(int64_t max_entries_to_read = std::numeric_limits&lt;int64_t&gt;::max());</a>
<a name="ln208"> </a>
<a name="ln209">  // Reads the metadata of the first entry in the segment</a>
<a name="ln210">  Result&lt;FirstEntryMetadata&gt; ReadFirstEntryMetadata();</a>
<a name="ln211"> </a>
<a name="ln212">  // Rebuilds this segment's footer by scanning its entries.</a>
<a name="ln213">  // This is an expensive operation as it reads and parses the whole segment</a>
<a name="ln214">  // so it should be only used in the case of a crash, where the footer is</a>
<a name="ln215">  // missing because we didn't have the time to write it out.</a>
<a name="ln216">  CHECKED_STATUS RebuildFooterByScanning();</a>
<a name="ln217"> </a>
<a name="ln218">  bool IsInitialized() const {</a>
<a name="ln219">    return is_initialized_;</a>
<a name="ln220">  }</a>
<a name="ln221"> </a>
<a name="ln222">  // Returns the parent directory where log segments are stored.</a>
<a name="ln223">  const std::string &amp;path() const {</a>
<a name="ln224">    return path_;</a>
<a name="ln225">  }</a>
<a name="ln226"> </a>
<a name="ln227">  const LogSegmentHeaderPB&amp; header() const {</a>
<a name="ln228">    DCHECK(header_.IsInitialized());</a>
<a name="ln229">    return header_;</a>
<a name="ln230">  }</a>
<a name="ln231"> </a>
<a name="ln232">  // Indicates whether this segment has a footer.</a>
<a name="ln233">  //</a>
<a name="ln234">  // Segments that were properly closed, e.g. because they were rolled over,</a>
<a name="ln235">  // will have properly written footers. On the other hand if there was a</a>
<a name="ln236">  // crash and the segment was not closed properly the footer will be missing.</a>
<a name="ln237">  // In this case calling ReadEntries() will rebuild the footer.</a>
<a name="ln238">  bool HasFooter() const {</a>
<a name="ln239">    return footer_.IsInitialized();</a>
<a name="ln240">  }</a>
<a name="ln241"> </a>
<a name="ln242">  // Returns this log segment's footer.</a>
<a name="ln243">  //</a>
<a name="ln244">  // If HasFooter() returns false this cannot be called.</a>
<a name="ln245">  const LogSegmentFooterPB&amp; footer() const {</a>
<a name="ln246">    DCHECK(IsInitialized());</a>
<a name="ln247">    CHECK(HasFooter());</a>
<a name="ln248">    return footer_;</a>
<a name="ln249">  }</a>
<a name="ln250"> </a>
<a name="ln251">  const std::shared_ptr&lt;RandomAccessFile&gt; readable_file() const {</a>
<a name="ln252">    return readable_file_;</a>
<a name="ln253">  }</a>
<a name="ln254"> </a>
<a name="ln255">  const std::shared_ptr&lt;RandomAccessFile&gt; readable_file_checkpoint() const {</a>
<a name="ln256">    return readable_file_checkpoint_;</a>
<a name="ln257">  }</a>
<a name="ln258"> </a>
<a name="ln259">  const int64_t file_size() const {</a>
<a name="ln260">    return file_size_.Load();</a>
<a name="ln261">  }</a>
<a name="ln262"> </a>
<a name="ln263">  const int64_t first_entry_offset() const {</a>
<a name="ln264">    return first_entry_offset_;</a>
<a name="ln265">  }</a>
<a name="ln266"> </a>
<a name="ln267">  const int64_t get_header_size() const {</a>
<a name="ln268">    return readable_file_-&gt;GetEncryptionHeaderSize();</a>
<a name="ln269">  }</a>
<a name="ln270"> </a>
<a name="ln271">  // Returns the full size of the file, if the segment is closed and has</a>
<a name="ln272">  // a footer, or the offset where the last written, non corrupt entry</a>
<a name="ln273">  // ends.</a>
<a name="ln274">  const int64_t readable_up_to() const;</a>
<a name="ln275"> </a>
<a name="ln276"> private:</a>
<a name="ln277">  friend class RefCountedThreadSafe&lt;ReadableLogSegment&gt;;</a>
<a name="ln278">  friend class LogReader;</a>
<a name="ln279">  FRIEND_TEST(LogTest, TestWriteAndReadToAndFromInProgressSegment);</a>
<a name="ln280"> </a>
<a name="ln281">  struct EntryHeader {</a>
<a name="ln282">    // The length of the batch data.</a>
<a name="ln283">    uint32_t msg_length;</a>
<a name="ln284"> </a>
<a name="ln285">    // The CRC32C of the batch data.</a>
<a name="ln286">    uint32_t msg_crc;</a>
<a name="ln287"> </a>
<a name="ln288">    // The CRC32C of this EntryHeader.</a>
<a name="ln289">    uint32_t header_crc;</a>
<a name="ln290">  };</a>
<a name="ln291"> </a>
<a name="ln292">  ~ReadableLogSegment() {}</a>
<a name="ln293"> </a>
<a name="ln294">  // Helper functions called by Init().</a>
<a name="ln295"> </a>
<a name="ln296">  CHECKED_STATUS ReadFileSize();</a>
<a name="ln297"> </a>
<a name="ln298">  CHECKED_STATUS ReadHeader();</a>
<a name="ln299"> </a>
<a name="ln300">  CHECKED_STATUS ReadHeaderMagicAndHeaderLength(uint32_t *len);</a>
<a name="ln301"> </a>
<a name="ln302">  CHECKED_STATUS ParseHeaderMagicAndHeaderLength(const Slice &amp;data, uint32_t *parsed_len);</a>
<a name="ln303"> </a>
<a name="ln304">  CHECKED_STATUS ReadFooter();</a>
<a name="ln305"> </a>
<a name="ln306">  CHECKED_STATUS ReadFooterMagicAndFooterLength(uint32_t *len);</a>
<a name="ln307"> </a>
<a name="ln308">  CHECKED_STATUS ParseFooterMagicAndFooterLength(const Slice &amp;data, uint32_t *parsed_len);</a>
<a name="ln309"> </a>
<a name="ln310">  // Starting at 'offset', read the rest of the log file, looking for any</a>
<a name="ln311">  // valid log entry headers. If any are found, sets *has_valid_entries to true.</a>
<a name="ln312">  //</a>
<a name="ln313">  // Returns a bad Status only in the case that some IO error occurred reading the</a>
<a name="ln314">  // file.</a>
<a name="ln315">  CHECKED_STATUS ScanForValidEntryHeaders(int64_t offset, bool* has_valid_entries);</a>
<a name="ln316"> </a>
<a name="ln317">  // Format a nice error message to report on a corruption in a log file.</a>
<a name="ln318">  CHECKED_STATUS MakeCorruptionStatus(int batch_number, int64_t batch_offset,</a>
<a name="ln319">                              std::vector&lt;int64_t&gt;* recent_offsets,</a>
<a name="ln320">                              const std::vector&lt;std::unique_ptr&lt;LogEntryPB&gt;&gt;&amp; entries,</a>
<a name="ln321">                              const Status&amp; status) const;</a>
<a name="ln322"> </a>
<a name="ln323">  CHECKED_STATUS ReadEntryHeaderAndBatch(int64_t* offset,</a>
<a name="ln324">                                         faststring* tmp_buf,</a>
<a name="ln325">                                         LogEntryBatchPB* batch);</a>
<a name="ln326"> </a>
<a name="ln327">  // Reads a log entry header from the segment.</a>
<a name="ln328">  // Also increments the passed offset* by the length of the entry.</a>
<a name="ln329">  CHECKED_STATUS ReadEntryHeader(int64_t *offset, EntryHeader* header);</a>
<a name="ln330"> </a>
<a name="ln331">  // Decode a log entry header from the given slice, which must be kEntryHeaderSize</a>
<a name="ln332">  // bytes long. Returns true if successful, false if corrupt.</a>
<a name="ln333">  //</a>
<a name="ln334">  // NOTE: this is performance-critical since it is used by ScanForValidEntryHeaders</a>
<a name="ln335">  // and thus returns bool instead of Status.</a>
<a name="ln336">  CHECKED_STATUS DecodeEntryHeader(const Slice&amp; data, EntryHeader* header);</a>
<a name="ln337"> </a>
<a name="ln338">  // Reads a log entry batch from the provided readable segment, which gets decoded</a>
<a name="ln339">  // into 'entry_batch' and increments 'offset' by the batch's length.</a>
<a name="ln340">  CHECKED_STATUS ReadEntryBatch(int64_t *offset,</a>
<a name="ln341">                                const EntryHeader&amp; header,</a>
<a name="ln342">                                faststring* tmp_buf,</a>
<a name="ln343">                                LogEntryBatchPB* entry_batch);</a>
<a name="ln344"> </a>
<a name="ln345">  void UpdateReadableToOffset(int64_t readable_to_offset);</a>
<a name="ln346"> </a>
<a name="ln347">  const std::string path_;</a>
<a name="ln348"> </a>
<a name="ln349">  // The size of the readable file.</a>
<a name="ln350">  // This is set by Init(). In the case of a log being written to,</a>
<a name="ln351">  // this may be increased by UpdateReadableToOffset()</a>
<a name="ln352">  AtomicInt&lt;int64_t&gt; file_size_;</a>
<a name="ln353"> </a>
<a name="ln354">  // The offset up to which we can read the file.</a>
<a name="ln355">  // For already written segments this is fixed and equal to the file size</a>
<a name="ln356">  // but for the segments currently written to this is the offset up to which</a>
<a name="ln357">  // we can read without the fear of reading garbage/zeros.</a>
<a name="ln358">  // This is atomic because the Log thread might be updating the segment's readable</a>
<a name="ln359">  // offset while an async reader is reading the segment's entries.</a>
<a name="ln360">  // is reading it.</a>
<a name="ln361">  AtomicInt&lt;int64_t&gt; readable_to_offset_;</a>
<a name="ln362"> </a>
<a name="ln363">  // a readable file for a log segment (used on replay)</a>
<a name="ln364">  const std::shared_ptr&lt;RandomAccessFile&gt; readable_file_;</a>
<a name="ln365"> </a>
<a name="ln366">  std::shared_ptr&lt;RandomAccessFile&gt; readable_file_checkpoint_;</a>
<a name="ln367"> </a>
<a name="ln368">  bool is_initialized_;</a>
<a name="ln369"> </a>
<a name="ln370">  LogSegmentHeaderPB header_;</a>
<a name="ln371"> </a>
<a name="ln372">  LogSegmentFooterPB footer_;</a>
<a name="ln373"> </a>
<a name="ln374">  // True if the footer was rebuilt, rather than actually found on disk.</a>
<a name="ln375">  bool footer_was_rebuilt_;</a>
<a name="ln376"> </a>
<a name="ln377">  // the offset of the first entry in the log.</a>
<a name="ln378">  int64_t first_entry_offset_;</a>
<a name="ln379"> </a>
<a name="ln380">  DISALLOW_COPY_AND_ASSIGN(ReadableLogSegment);</a>
<a name="ln381">};</a>
<a name="ln382"> </a>
<a name="ln383">// A writable log segment where state data is stored.</a>
<a name="ln384">class WritableLogSegment {</a>
<a name="ln385"> public:</a>
<a name="ln386">  WritableLogSegment(std::string path,</a>
<a name="ln387">                     std::shared_ptr&lt;WritableFile&gt; writable_file);</a>
<a name="ln388"> </a>
<a name="ln389">  // Opens the segment by writing the header.</a>
<a name="ln390">  CHECKED_STATUS WriteHeaderAndOpen(const LogSegmentHeaderPB&amp; new_header);</a>
<a name="ln391"> </a>
<a name="ln392">  // Closes the segment by writing the footer and then actually closing the</a>
<a name="ln393">  // underlying WritableFile.</a>
<a name="ln394">  CHECKED_STATUS WriteFooterAndClose(const LogSegmentFooterPB&amp; footer);</a>
<a name="ln395"> </a>
<a name="ln396">  bool IsClosed() {</a>
<a name="ln397">    return IsHeaderWritten() &amp;&amp; IsFooterWritten();</a>
<a name="ln398">  }</a>
<a name="ln399"> </a>
<a name="ln400">  int64_t Size() const {</a>
<a name="ln401">    return writable_file_-&gt;Size();</a>
<a name="ln402">  }</a>
<a name="ln403"> </a>
<a name="ln404">  // Appends the provided batch of data, including a header</a>
<a name="ln405">  // and checksum.</a>
<a name="ln406">  // Makes sure that the log segment has not been closed.</a>
<a name="ln407">  CHECKED_STATUS WriteEntryBatch(const Slice&amp; entry_batch_data);</a>
<a name="ln408"> </a>
<a name="ln409">  // Makes sure the I/O buffers in the underlying writable file are flushed.</a>
<a name="ln410">  CHECKED_STATUS Sync() {</a>
<a name="ln411">    return writable_file_-&gt;Sync();</a>
<a name="ln412">  }</a>
<a name="ln413"> </a>
<a name="ln414">  // Returns true if the segment header has already been written to disk.</a>
<a name="ln415">  bool IsHeaderWritten() const {</a>
<a name="ln416">    return is_header_written_;</a>
<a name="ln417">  }</a>
<a name="ln418"> </a>
<a name="ln419">  const LogSegmentHeaderPB&amp; header() const {</a>
<a name="ln420">    DCHECK(IsHeaderWritten());</a>
<a name="ln421">    return header_;</a>
<a name="ln422">  }</a>
<a name="ln423"> </a>
<a name="ln424">  bool IsFooterWritten() const {</a>
<a name="ln425">    return is_footer_written_;</a>
<a name="ln426">  }</a>
<a name="ln427"> </a>
<a name="ln428">  const LogSegmentFooterPB&amp; footer() const {</a>
<a name="ln429">    DCHECK(IsFooterWritten());</a>
<a name="ln430">    return footer_;</a>
<a name="ln431">  }</a>
<a name="ln432"> </a>
<a name="ln433">  // Returns the parent directory where log segments are stored.</a>
<a name="ln434">  const std::string &amp;path() const {</a>
<a name="ln435">    return path_;</a>
<a name="ln436">  }</a>
<a name="ln437"> </a>
<a name="ln438">  const int64_t first_entry_offset() const {</a>
<a name="ln439">    return first_entry_offset_;</a>
<a name="ln440">  }</a>
<a name="ln441"> </a>
<a name="ln442">  const int64_t written_offset() const {</a>
<a name="ln443">    return written_offset_;</a>
<a name="ln444">  }</a>
<a name="ln445"> </a>
<a name="ln446"> private:</a>
<a name="ln447"> </a>
<a name="ln448">  const std::shared_ptr&lt;WritableFile&gt;&amp; writable_file() const {</a>
<a name="ln449">    return writable_file_;</a>
<a name="ln450">  }</a>
<a name="ln451"> </a>
<a name="ln452">  // The path to the log file.</a>
<a name="ln453">  const std::string path_;</a>
<a name="ln454"> </a>
<a name="ln455">  // The writable file to which this LogSegment will be written.</a>
<a name="ln456">  const std::shared_ptr&lt;WritableFile&gt; writable_file_;</a>
<a name="ln457"> </a>
<a name="ln458">  bool is_header_written_;</a>
<a name="ln459"> </a>
<a name="ln460">  bool is_footer_written_;</a>
<a name="ln461"> </a>
<a name="ln462">  LogSegmentHeaderPB header_;</a>
<a name="ln463"> </a>
<a name="ln464">  LogSegmentFooterPB footer_;</a>
<a name="ln465"> </a>
<a name="ln466">  // the offset of the first entry in the log</a>
<a name="ln467">  int64_t first_entry_offset_;</a>
<a name="ln468"> </a>
<a name="ln469">  // The offset where the last written entry ends.</a>
<a name="ln470">  int64_t written_offset_;</a>
<a name="ln471"> </a>
<a name="ln472">  DISALLOW_COPY_AND_ASSIGN(WritableLogSegment);</a>
<a name="ln473">};</a>
<a name="ln474"> </a>
<a name="ln475">using consensus::ReplicateMsgs;</a>
<a name="ln476"> </a>
<a name="ln477">// Sets 'batch' to a newly created batch that contains the pre-allocated</a>
<a name="ln478">// ReplicateMsgs in 'msgs'.</a>
<a name="ln479">// We use C-style passing here to avoid having to allocate a vector</a>
<a name="ln480">// in some hot paths.</a>
<a name="ln481">LogEntryBatchPB CreateBatchFromAllocatedOperations(const ReplicateMsgs&amp; msgs);</a>
<a name="ln482"> </a>
<a name="ln483">// Checks if 'fname' is a correctly formatted name of log segment file.</a>
<a name="ln484">bool IsLogFileName(const std::string&amp; fname);</a>
<a name="ln485"> </a>
<a name="ln486">CHECKED_STATUS CheckPathsAreODirectWritable(const std::vector&lt;std::string&gt;&amp; paths);</a>
<a name="ln487">CHECKED_STATUS CheckRelevantPathsAreODirectWritable();</a>
<a name="ln488"> </a>
<a name="ln489">// Modify durable wal write flag depending on the value of FLAGS_require_durable_wal_write.</a>
<a name="ln490">CHECKED_STATUS ModifyDurableWriteFlagIfNotODirect();</a>
<a name="ln491"> </a>
<a name="ln492">}  // namespace log</a>
<a name="ln493">}  // namespace yb</a>
<a name="ln494"> </a>
<a name="ln495">#endif /* YB_CONSENSUS_LOG_UTIL_H_ */</a>

</code></pre>
<div class="balloon" rel="228"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="246"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="247"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="420"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="429"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
