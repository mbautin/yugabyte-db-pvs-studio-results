
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>atomic</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// -*- C++ -*- header.</a>
<a name="ln2"> </a>
<a name="ln3">// Copyright (C) 2008-2018 Free Software Foundation, Inc.</a>
<a name="ln4">//</a>
<a name="ln5">// This file is part of the GNU ISO C++ Library.  This library is free</a>
<a name="ln6">// software; you can redistribute it and/or modify it under the</a>
<a name="ln7">// terms of the GNU General Public License as published by the</a>
<a name="ln8">// Free Software Foundation; either version 3, or (at your option)</a>
<a name="ln9">// any later version.</a>
<a name="ln10"> </a>
<a name="ln11">// This library is distributed in the hope that it will be useful,</a>
<a name="ln12">// but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">// GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">// Under Section 7 of GPL version 3, you are granted additional</a>
<a name="ln17">// permissions described in the GCC Runtime Library Exception, version</a>
<a name="ln18">// 3.1, as published by the Free Software Foundation.</a>
<a name="ln19"> </a>
<a name="ln20">// You should have received a copy of the GNU General Public License and</a>
<a name="ln21">// a copy of the GCC Runtime Library Exception along with this program;</a>
<a name="ln22">// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see</a>
<a name="ln23">// &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln24"> </a>
<a name="ln25">/** @file include/atomic</a>
<a name="ln26"> *  This is a Standard C++ Library header.</a>
<a name="ln27"> */</a>
<a name="ln28"> </a>
<a name="ln29">// Based on &quot;C++ Atomic Types and Operations&quot; by Hans Boehm and Lawrence Crowl.</a>
<a name="ln30">// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2427.html</a>
<a name="ln31"> </a>
<a name="ln32">#ifndef _GLIBCXX_ATOMIC</a>
<a name="ln33">#define _GLIBCXX_ATOMIC 1</a>
<a name="ln34"> </a>
<a name="ln35">#pragma GCC system_header</a>
<a name="ln36"> </a>
<a name="ln37">#if __cplusplus &lt; 201103L</a>
<a name="ln38"># include &lt;bits/c++0x_warning.h&gt;</a>
<a name="ln39">#else</a>
<a name="ln40"> </a>
<a name="ln41">#include &lt;bits/atomic_base.h&gt;</a>
<a name="ln42">#include &lt;bits/move.h&gt;</a>
<a name="ln43"> </a>
<a name="ln44">namespace std _GLIBCXX_VISIBILITY(default)</a>
<a name="ln45">{</a>
<a name="ln46">_GLIBCXX_BEGIN_NAMESPACE_VERSION</a>
<a name="ln47"> </a>
<a name="ln48">  /**</a>
<a name="ln49">   * @addtogroup atomics</a>
<a name="ln50">   * @{</a>
<a name="ln51">   */</a>
<a name="ln52"> </a>
<a name="ln53">#if __cplusplus &gt; 201402L</a>
<a name="ln54"># define __cpp_lib_atomic_is_always_lock_free 201603</a>
<a name="ln55">#endif</a>
<a name="ln56"> </a>
<a name="ln57">  template&lt;typename _Tp&gt;</a>
<a name="ln58">    struct atomic;</a>
<a name="ln59"> </a>
<a name="ln60">  /// atomic&lt;bool&gt;</a>
<a name="ln61">  // NB: No operators or fetch-operations for this type.</a>
<a name="ln62">  template&lt;&gt;</a>
<a name="ln63">  struct atomic&lt;bool&gt;</a>
<a name="ln64">  {</a>
<a name="ln65">  private:</a>
<a name="ln66">    __atomic_base&lt;bool&gt;	_M_base;</a>
<a name="ln67"> </a>
<a name="ln68">  public:</a>
<a name="ln69">    atomic() noexcept = default;</a>
<a name="ln70">    ~atomic() noexcept = default;</a>
<a name="ln71">    atomic(const atomic&amp;) = delete;</a>
<a name="ln72">    atomic&amp; operator=(const atomic&amp;) = delete;</a>
<a name="ln73">    atomic&amp; operator=(const atomic&amp;) volatile = delete;</a>
<a name="ln74"> </a>
<a name="ln75">    constexpr atomic(bool __i) noexcept : _M_base(__i) { }</a>
<a name="ln76"> </a>
<a name="ln77">    bool</a>
<a name="ln78">    operator=(bool __i) noexcept</a>
<a name="ln79">    { return _M_base.operator=(__i); }</a>
<a name="ln80"> </a>
<a name="ln81">    bool</a>
<a name="ln82">    operator=(bool __i) volatile noexcept</a>
<a name="ln83">    { return _M_base.operator=(__i); }</a>
<a name="ln84"> </a>
<a name="ln85">    operator bool() const noexcept</a>
<a name="ln86">    { return _M_base.load(); }</a>
<a name="ln87"> </a>
<a name="ln88">    operator bool() const volatile noexcept</a>
<a name="ln89">    { return _M_base.load(); }</a>
<a name="ln90"> </a>
<a name="ln91">    bool</a>
<a name="ln92">    is_lock_free() const noexcept { return _M_base.is_lock_free(); }</a>
<a name="ln93"> </a>
<a name="ln94">    bool</a>
<a name="ln95">    is_lock_free() const volatile noexcept { return _M_base.is_lock_free(); }</a>
<a name="ln96"> </a>
<a name="ln97">#if __cplusplus &gt; 201402L</a>
<a name="ln98">    static constexpr bool is_always_lock_free = ATOMIC_BOOL_LOCK_FREE == 2;</a>
<a name="ln99">#endif</a>
<a name="ln100"> </a>
<a name="ln101">    void</a>
<a name="ln102">    store(bool __i, memory_order __m = memory_order_seq_cst) noexcept</a>
<a name="ln103">    { _M_base.store(__i, __m); }</a>
<a name="ln104"> </a>
<a name="ln105">    void</a>
<a name="ln106">    store(bool __i, memory_order __m = memory_order_seq_cst) volatile noexcept</a>
<a name="ln107">    { _M_base.store(__i, __m); }</a>
<a name="ln108"> </a>
<a name="ln109">    bool</a>
<a name="ln110">    load(memory_order __m = memory_order_seq_cst) const noexcept</a>
<a name="ln111">    { return _M_base.load(__m); }</a>
<a name="ln112"> </a>
<a name="ln113">    bool</a>
<a name="ln114">    load(memory_order __m = memory_order_seq_cst) const volatile noexcept</a>
<a name="ln115">    { return _M_base.load(__m); }</a>
<a name="ln116"> </a>
<a name="ln117">    bool</a>
<a name="ln118">    exchange(bool __i, memory_order __m = memory_order_seq_cst) noexcept</a>
<a name="ln119">    { return _M_base.exchange(__i, __m); }</a>
<a name="ln120"> </a>
<a name="ln121">    bool</a>
<a name="ln122">    exchange(bool __i,</a>
<a name="ln123">	     memory_order __m = memory_order_seq_cst) volatile noexcept</a>
<a name="ln124">    { return _M_base.exchange(__i, __m); }</a>
<a name="ln125"> </a>
<a name="ln126">    bool</a>
<a name="ln127">    compare_exchange_weak(bool&amp; __i1, bool __i2, memory_order __m1,</a>
<a name="ln128">			  memory_order __m2) noexcept</a>
<a name="ln129">    { return _M_base.compare_exchange_weak(__i1, __i2, __m1, __m2); }</a>
<a name="ln130"> </a>
<a name="ln131">    bool</a>
<a name="ln132">    compare_exchange_weak(bool&amp; __i1, bool __i2, memory_order __m1,</a>
<a name="ln133">			  memory_order __m2) volatile noexcept</a>
<a name="ln134">    { return _M_base.compare_exchange_weak(__i1, __i2, __m1, __m2); }</a>
<a name="ln135"> </a>
<a name="ln136">    bool</a>
<a name="ln137">    compare_exchange_weak(bool&amp; __i1, bool __i2,</a>
<a name="ln138">			  memory_order __m = memory_order_seq_cst) noexcept</a>
<a name="ln139">    { return _M_base.compare_exchange_weak(__i1, __i2, __m); }</a>
<a name="ln140"> </a>
<a name="ln141">    bool</a>
<a name="ln142">    compare_exchange_weak(bool&amp; __i1, bool __i2,</a>
<a name="ln143">		     memory_order __m = memory_order_seq_cst) volatile noexcept</a>
<a name="ln144">    { return _M_base.compare_exchange_weak(__i1, __i2, __m); }</a>
<a name="ln145"> </a>
<a name="ln146">    bool</a>
<a name="ln147">    compare_exchange_strong(bool&amp; __i1, bool __i2, memory_order __m1,</a>
<a name="ln148">			    memory_order __m2) noexcept</a>
<a name="ln149">    { return _M_base.compare_exchange_strong(__i1, __i2, __m1, __m2); }</a>
<a name="ln150"> </a>
<a name="ln151">    bool</a>
<a name="ln152">    compare_exchange_strong(bool&amp; __i1, bool __i2, memory_order __m1,</a>
<a name="ln153">			    memory_order __m2) volatile noexcept</a>
<a name="ln154">    { return _M_base.compare_exchange_strong(__i1, __i2, __m1, __m2); }</a>
<a name="ln155"> </a>
<a name="ln156">    bool</a>
<a name="ln157">    compare_exchange_strong(bool&amp; __i1, bool __i2,</a>
<a name="ln158">			    memory_order __m = memory_order_seq_cst) noexcept</a>
<a name="ln159">    { return _M_base.compare_exchange_strong(__i1, __i2, __m); }</a>
<a name="ln160"> </a>
<a name="ln161">    bool</a>
<a name="ln162">    compare_exchange_strong(bool&amp; __i1, bool __i2,</a>
<a name="ln163">		    memory_order __m = memory_order_seq_cst) volatile noexcept</a>
<a name="ln164">    { return _M_base.compare_exchange_strong(__i1, __i2, __m); }</a>
<a name="ln165">  };</a>
<a name="ln166"> </a>
<a name="ln167"> </a>
<a name="ln168">  /**</a>
<a name="ln169">   *  @brief Generic atomic type, primary class template.</a>
<a name="ln170">   *</a>
<a name="ln171">   *  @tparam _Tp  Type to be made atomic, must be trivally copyable.</a>
<a name="ln172">   */</a>
<a name="ln173">  template&lt;typename _Tp&gt;</a>
<a name="ln174">    struct atomic</a>
<a name="ln175">    {</a>
<a name="ln176">    private:</a>
<a name="ln177">      // Align 1/2/4/8/16-byte types to at least their size.</a>
<a name="ln178">      static constexpr int _S_min_alignment</a>
<a name="ln179">	= (sizeof(_Tp) &amp; (sizeof(_Tp) - 1)) || sizeof(_Tp) &gt; 16</a>
<a name="ln180">	? 0 : sizeof(_Tp);</a>
<a name="ln181"> </a>
<a name="ln182">      static constexpr int _S_alignment</a>
<a name="ln183">        = _S_min_alignment &gt; alignof(_Tp) ? _S_min_alignment : alignof(_Tp);</a>
<a name="ln184"> </a>
<a name="ln185">      alignas(_S_alignment) _Tp _M_i;</a>
<a name="ln186"> </a>
<a name="ln187">      static_assert(__is_trivially_copyable(_Tp),</a>
<a name="ln188">		    &quot;std::atomic requires a trivially copyable type&quot;);</a>
<a name="ln189"> </a>
<a name="ln190">      static_assert(sizeof(_Tp) &gt; 0,</a>
<a name="ln191">		    &quot;Incomplete or zero-sized types are not supported&quot;);</a>
<a name="ln192"> </a>
<a name="ln193">    public:</a>
<a name="ln194">      atomic() noexcept = default;</a>
<a name="ln195">      ~atomic() noexcept = default;</a>
<a name="ln196">      atomic(const atomic&amp;) = delete;</a>
<a name="ln197">      atomic&amp; operator=(const atomic&amp;) = delete;</a>
<a name="ln198">      atomic&amp; operator=(const atomic&amp;) volatile = delete;</a>
<a name="ln199"> </a>
<a name="ln200">      constexpr atomic(_Tp __i) noexcept : _M_i(__i) { }</a>
<a name="ln201"> </a>
<a name="ln202">      operator _Tp() const noexcept</a>
<a name="ln203">      { return load(); }</a>
<a name="ln204"> </a>
<a name="ln205">      operator _Tp() const volatile noexcept</a>
<a name="ln206">      { return load(); }</a>
<a name="ln207"> </a>
<a name="ln208">      _Tp</a>
<a name="ln209">      operator=(_Tp __i) noexcept</a>
<a name="ln210">      { store(__i); return __i; }</a>
<a name="ln211"> </a>
<a name="ln212">      _Tp</a>
<a name="ln213">      operator=(_Tp __i) volatile noexcept</a>
<a name="ln214">      { store(__i); return __i; }</a>
<a name="ln215"> </a>
<a name="ln216">      bool</a>
<a name="ln217">      is_lock_free() const noexcept</a>
<a name="ln218">      {</a>
<a name="ln219">	// Produce a fake, minimally aligned pointer.</a>
<a name="ln220">	return __atomic_is_lock_free(sizeof(_M_i),</a>
<a name="ln221">	    reinterpret_cast&lt;void *&gt;(-__alignof(_M_i)));</a>
<a name="ln222">      }</a>
<a name="ln223"> </a>
<a name="ln224">      bool</a>
<a name="ln225">      is_lock_free() const volatile noexcept</a>
<a name="ln226">      {</a>
<a name="ln227">	// Produce a fake, minimally aligned pointer.</a>
<a name="ln228">	return __atomic_is_lock_free(sizeof(_M_i),</a>
<a name="ln229">	    reinterpret_cast&lt;void *&gt;(-__alignof(_M_i)));</a>
<a name="ln230">      }</a>
<a name="ln231"> </a>
<a name="ln232">#if __cplusplus &gt; 201402L</a>
<a name="ln233">      static constexpr bool is_always_lock_free</a>
<a name="ln234">	= __atomic_always_lock_free(sizeof(_M_i), 0);</a>
<a name="ln235">#endif</a>
<a name="ln236"> </a>
<a name="ln237">      void</a>
<a name="ln238">      store(_Tp __i, memory_order __m = memory_order_seq_cst) noexcept</a>
<a name="ln239">      { __atomic_store(std::__addressof(_M_i), std::__addressof(__i), __m); }</a>
<a name="ln240"> </a>
<a name="ln241">      void</a>
<a name="ln242">      store(_Tp __i, memory_order __m = memory_order_seq_cst) volatile noexcept</a>
<a name="ln243">      { __atomic_store(std::__addressof(_M_i), std::__addressof(__i), __m); }</a>
<a name="ln244"> </a>
<a name="ln245">      _Tp</a>
<a name="ln246">      load(memory_order __m = memory_order_seq_cst) const noexcept</a>
<a name="ln247">      {</a>
<a name="ln248">	alignas(_Tp) unsigned char __buf[sizeof(_Tp)];</a>
<a name="ln249">	_Tp* __ptr = reinterpret_cast&lt;_Tp*&gt;(__buf);</a>
<a name="ln250">	__atomic_load(std::__addressof(_M_i), __ptr, __m);</a>
<a name="ln251">	return *__ptr;</a>
<a name="ln252">      }</a>
<a name="ln253"> </a>
<a name="ln254">      _Tp</a>
<a name="ln255">      load(memory_order __m = memory_order_seq_cst) const volatile noexcept</a>
<a name="ln256">      {</a>
<a name="ln257">        alignas(_Tp) unsigned char __buf[sizeof(_Tp)];</a>
<a name="ln258">	_Tp* __ptr = reinterpret_cast&lt;_Tp*&gt;(__buf);</a>
<a name="ln259">	__atomic_load(std::__addressof(_M_i), __ptr, __m);</a>
<a name="ln260">	return *__ptr;</a>
<a name="ln261">      }</a>
<a name="ln262"> </a>
<a name="ln263">      _Tp</a>
<a name="ln264">      exchange(_Tp __i, memory_order __m = memory_order_seq_cst) noexcept</a>
<a name="ln265">      {</a>
<a name="ln266">        alignas(_Tp) unsigned char __buf[sizeof(_Tp)];</a>
<a name="ln267">	_Tp* __ptr = reinterpret_cast&lt;_Tp*&gt;(__buf);</a>
<a name="ln268">	__atomic_exchange(std::__addressof(_M_i), std::__addressof(__i),</a>
<a name="ln269">			  __ptr, __m);</a>
<a name="ln270">	return *__ptr;</a>
<a name="ln271">      }</a>
<a name="ln272"> </a>
<a name="ln273">      _Tp</a>
<a name="ln274">      exchange(_Tp __i,</a>
<a name="ln275">	       memory_order __m = memory_order_seq_cst) volatile noexcept</a>
<a name="ln276">      {</a>
<a name="ln277">        alignas(_Tp) unsigned char __buf[sizeof(_Tp)];</a>
<a name="ln278">	_Tp* __ptr = reinterpret_cast&lt;_Tp*&gt;(__buf);</a>
<a name="ln279">	__atomic_exchange(std::__addressof(_M_i), std::__addressof(__i),</a>
<a name="ln280">			  __ptr, __m);</a>
<a name="ln281">	return *__ptr;</a>
<a name="ln282">      }</a>
<a name="ln283"> </a>
<a name="ln284">      bool</a>
<a name="ln285">      compare_exchange_weak(_Tp&amp; __e, _Tp __i, memory_order __s,</a>
<a name="ln286">			    memory_order __f) noexcept</a>
<a name="ln287">      {</a>
<a name="ln288">	return __atomic_compare_exchange(std::__addressof(_M_i),</a>
<a name="ln289">					 std::__addressof(__e),</a>
<a name="ln290">					 std::__addressof(__i),</a>
<a name="ln291">					 true, __s, __f);</a>
<a name="ln292">      }</a>
<a name="ln293"> </a>
<a name="ln294">      bool</a>
<a name="ln295">      compare_exchange_weak(_Tp&amp; __e, _Tp __i, memory_order __s,</a>
<a name="ln296">			    memory_order __f) volatile noexcept</a>
<a name="ln297">      {</a>
<a name="ln298">	return __atomic_compare_exchange(std::__addressof(_M_i),</a>
<a name="ln299">					 std::__addressof(__e),</a>
<a name="ln300">					 std::__addressof(__i),</a>
<a name="ln301">					 true, __s, __f);</a>
<a name="ln302">      }</a>
<a name="ln303"> </a>
<a name="ln304">      bool</a>
<a name="ln305">      compare_exchange_weak(_Tp&amp; __e, _Tp __i,</a>
<a name="ln306">			    memory_order __m = memory_order_seq_cst) noexcept</a>
<a name="ln307">      { return compare_exchange_weak(__e, __i, __m,</a>
<a name="ln308">                                     __cmpexch_failure_order(__m)); }</a>
<a name="ln309"> </a>
<a name="ln310">      bool</a>
<a name="ln311">      compare_exchange_weak(_Tp&amp; __e, _Tp __i,</a>
<a name="ln312">		     memory_order __m = memory_order_seq_cst) volatile noexcept</a>
<a name="ln313">      { return compare_exchange_weak(__e, __i, __m,</a>
<a name="ln314">                                     __cmpexch_failure_order(__m)); }</a>
<a name="ln315"> </a>
<a name="ln316">      bool</a>
<a name="ln317">      compare_exchange_strong(_Tp&amp; __e, _Tp __i, memory_order __s,</a>
<a name="ln318">			      memory_order __f) noexcept</a>
<a name="ln319">      {</a>
<a name="ln320">	return __atomic_compare_exchange(std::__addressof(_M_i),</a>
<a name="ln321">					 std::__addressof(__e),</a>
<a name="ln322">					 std::__addressof(__i),</a>
<a name="ln323">					 false, __s, __f);</a>
<a name="ln324">      }</a>
<a name="ln325"> </a>
<a name="ln326">      bool</a>
<a name="ln327">      compare_exchange_strong(_Tp&amp; __e, _Tp __i, memory_order __s,</a>
<a name="ln328">			      memory_order __f) volatile noexcept</a>
<a name="ln329">      {</a>
<a name="ln330">	return __atomic_compare_exchange(std::__addressof(_M_i),</a>
<a name="ln331">					 std::__addressof(__e),</a>
<a name="ln332">					 std::__addressof(__i),</a>
<a name="ln333">					 false, __s, __f);</a>
<a name="ln334">      }</a>
<a name="ln335"> </a>
<a name="ln336">      bool</a>
<a name="ln337">      compare_exchange_strong(_Tp&amp; __e, _Tp __i,</a>
<a name="ln338">			       memory_order __m = memory_order_seq_cst) noexcept</a>
<a name="ln339">      { return compare_exchange_strong(__e, __i, __m,</a>
<a name="ln340">                                       __cmpexch_failure_order(__m)); }</a>
<a name="ln341"> </a>
<a name="ln342">      bool</a>
<a name="ln343">      compare_exchange_strong(_Tp&amp; __e, _Tp __i,</a>
<a name="ln344">		     memory_order __m = memory_order_seq_cst) volatile noexcept</a>
<a name="ln345">      { return compare_exchange_strong(__e, __i, __m,</a>
<a name="ln346">                                       __cmpexch_failure_order(__m)); }</a>
<a name="ln347">    };</a>
<a name="ln348"> </a>
<a name="ln349"> </a>
<a name="ln350">  /// Partial specialization for pointer types.</a>
<a name="ln351">  template&lt;typename _Tp&gt;</a>
<a name="ln352">    struct atomic&lt;_Tp*&gt;</a>
<a name="ln353">    {</a>
<a name="ln354">      typedef _Tp* 			__pointer_type;</a>
<a name="ln355">      typedef __atomic_base&lt;_Tp*&gt;	__base_type;</a>
<a name="ln356">      __base_type			_M_b;</a>
<a name="ln357"> </a>
<a name="ln358">      atomic() noexcept = default;</a>
<a name="ln359">      ~atomic() noexcept = default;</a>
<a name="ln360">      atomic(const atomic&amp;) = delete;</a>
<a name="ln361">      atomic&amp; operator=(const atomic&amp;) = delete;</a>
<a name="ln362">      atomic&amp; operator=(const atomic&amp;) volatile = delete;</a>
<a name="ln363"> </a>
<a name="ln364">      constexpr atomic(__pointer_type __p) noexcept : _M_b(__p) { }</a>
<a name="ln365"> </a>
<a name="ln366">      operator __pointer_type() const noexcept</a>
<a name="ln367">      { return __pointer_type(_M_b); }</a>
<a name="ln368"> </a>
<a name="ln369">      operator __pointer_type() const volatile noexcept</a>
<a name="ln370">      { return __pointer_type(_M_b); }</a>
<a name="ln371"> </a>
<a name="ln372">      __pointer_type</a>
<a name="ln373">      operator=(__pointer_type __p) noexcept</a>
<a name="ln374">      { return _M_b.operator=(__p); }</a>
<a name="ln375"> </a>
<a name="ln376">      __pointer_type</a>
<a name="ln377">      operator=(__pointer_type __p) volatile noexcept</a>
<a name="ln378">      { return _M_b.operator=(__p); }</a>
<a name="ln379"> </a>
<a name="ln380">      __pointer_type</a>
<a name="ln381">      operator++(int) noexcept</a>
<a name="ln382">      { return _M_b++; }</a>
<a name="ln383"> </a>
<a name="ln384">      __pointer_type</a>
<a name="ln385">      operator++(int) volatile noexcept</a>
<a name="ln386">      { return _M_b++; }</a>
<a name="ln387"> </a>
<a name="ln388">      __pointer_type</a>
<a name="ln389">      operator--(int) noexcept</a>
<a name="ln390">      { return _M_b--; }</a>
<a name="ln391"> </a>
<a name="ln392">      __pointer_type</a>
<a name="ln393">      operator--(int) volatile noexcept</a>
<a name="ln394">      { return _M_b--; }</a>
<a name="ln395"> </a>
<a name="ln396">      __pointer_type</a>
<a name="ln397">      operator++() noexcept</a>
<a name="ln398">      { return ++_M_b; }</a>
<a name="ln399"> </a>
<a name="ln400">      __pointer_type</a>
<a name="ln401">      operator++() volatile noexcept</a>
<a name="ln402">      { return ++_M_b; }</a>
<a name="ln403"> </a>
<a name="ln404">      __pointer_type</a>
<a name="ln405">      operator--() noexcept</a>
<a name="ln406">      { return --_M_b; }</a>
<a name="ln407"> </a>
<a name="ln408">      __pointer_type</a>
<a name="ln409">      operator--() volatile noexcept</a>
<a name="ln410">      { return --_M_b; }</a>
<a name="ln411"> </a>
<a name="ln412">      __pointer_type</a>
<a name="ln413">      operator+=(ptrdiff_t __d) noexcept</a>
<a name="ln414">      { return _M_b.operator+=(__d); }</a>
<a name="ln415"> </a>
<a name="ln416">      __pointer_type</a>
<a name="ln417">      operator+=(ptrdiff_t __d) volatile noexcept</a>
<a name="ln418">      { return _M_b.operator+=(__d); }</a>
<a name="ln419"> </a>
<a name="ln420">      __pointer_type</a>
<a name="ln421">      operator-=(ptrdiff_t __d) noexcept</a>
<a name="ln422">      { return _M_b.operator-=(__d); }</a>
<a name="ln423"> </a>
<a name="ln424">      __pointer_type</a>
<a name="ln425">      operator-=(ptrdiff_t __d) volatile noexcept</a>
<a name="ln426">      { return _M_b.operator-=(__d); }</a>
<a name="ln427"> </a>
<a name="ln428">      bool</a>
<a name="ln429">      is_lock_free() const noexcept</a>
<a name="ln430">      { return _M_b.is_lock_free(); }</a>
<a name="ln431"> </a>
<a name="ln432">      bool</a>
<a name="ln433">      is_lock_free() const volatile noexcept</a>
<a name="ln434">      { return _M_b.is_lock_free(); }</a>
<a name="ln435"> </a>
<a name="ln436">#if __cplusplus &gt; 201402L</a>
<a name="ln437">    static constexpr bool is_always_lock_free = ATOMIC_POINTER_LOCK_FREE == 2;</a>
<a name="ln438">#endif</a>
<a name="ln439"> </a>
<a name="ln440">      void</a>
<a name="ln441">      store(__pointer_type __p,</a>
<a name="ln442">	    memory_order __m = memory_order_seq_cst) noexcept</a>
<a name="ln443">      { return _M_b.store(__p, __m); }</a>
<a name="ln444"> </a>
<a name="ln445">      void</a>
<a name="ln446">      store(__pointer_type __p,</a>
<a name="ln447">	    memory_order __m = memory_order_seq_cst) volatile noexcept</a>
<a name="ln448">      { return _M_b.store(__p, __m); }</a>
<a name="ln449"> </a>
<a name="ln450">      __pointer_type</a>
<a name="ln451">      load(memory_order __m = memory_order_seq_cst) const noexcept</a>
<a name="ln452">      { return _M_b.load(__m); }</a>
<a name="ln453"> </a>
<a name="ln454">      __pointer_type</a>
<a name="ln455">      load(memory_order __m = memory_order_seq_cst) const volatile noexcept</a>
<a name="ln456">      { return _M_b.load(__m); }</a>
<a name="ln457"> </a>
<a name="ln458">      __pointer_type</a>
<a name="ln459">      exchange(__pointer_type __p,</a>
<a name="ln460">	       memory_order __m = memory_order_seq_cst) noexcept</a>
<a name="ln461">      { return _M_b.exchange(__p, __m); }</a>
<a name="ln462"> </a>
<a name="ln463">      __pointer_type</a>
<a name="ln464">      exchange(__pointer_type __p,</a>
<a name="ln465">	       memory_order __m = memory_order_seq_cst) volatile noexcept</a>
<a name="ln466">      { return _M_b.exchange(__p, __m); }</a>
<a name="ln467"> </a>
<a name="ln468">      bool</a>
<a name="ln469">      compare_exchange_weak(__pointer_type&amp; __p1, __pointer_type __p2,</a>
<a name="ln470">			    memory_order __m1, memory_order __m2) noexcept</a>
<a name="ln471">      { return _M_b.compare_exchange_strong(__p1, __p2, __m1, __m2); }</a>
<a name="ln472"> </a>
<a name="ln473">      bool</a>
<a name="ln474">      compare_exchange_weak(__pointer_type&amp; __p1, __pointer_type __p2,</a>
<a name="ln475">			    memory_order __m1,</a>
<a name="ln476">			    memory_order __m2) volatile noexcept</a>
<a name="ln477">      { return _M_b.compare_exchange_strong(__p1, __p2, __m1, __m2); }</a>
<a name="ln478"> </a>
<a name="ln479">      bool</a>
<a name="ln480">      compare_exchange_weak(__pointer_type&amp; __p1, __pointer_type __p2,</a>
<a name="ln481">			    memory_order __m = memory_order_seq_cst) noexcept</a>
<a name="ln482">      {</a>
<a name="ln483">	return compare_exchange_weak(__p1, __p2, __m,</a>
<a name="ln484">				     __cmpexch_failure_order(__m));</a>
<a name="ln485">      }</a>
<a name="ln486"> </a>
<a name="ln487">      bool</a>
<a name="ln488">      compare_exchange_weak(__pointer_type&amp; __p1, __pointer_type __p2,</a>
<a name="ln489">		    memory_order __m = memory_order_seq_cst) volatile noexcept</a>
<a name="ln490">      {</a>
<a name="ln491">	return compare_exchange_weak(__p1, __p2, __m,</a>
<a name="ln492">				     __cmpexch_failure_order(__m));</a>
<a name="ln493">      }</a>
<a name="ln494"> </a>
<a name="ln495">      bool</a>
<a name="ln496">      compare_exchange_strong(__pointer_type&amp; __p1, __pointer_type __p2,</a>
<a name="ln497">			      memory_order __m1, memory_order __m2) noexcept</a>
<a name="ln498">      { return _M_b.compare_exchange_strong(__p1, __p2, __m1, __m2); }</a>
<a name="ln499"> </a>
<a name="ln500">      bool</a>
<a name="ln501">      compare_exchange_strong(__pointer_type&amp; __p1, __pointer_type __p2,</a>
<a name="ln502">			      memory_order __m1,</a>
<a name="ln503">			      memory_order __m2) volatile noexcept</a>
<a name="ln504">      { return _M_b.compare_exchange_strong(__p1, __p2, __m1, __m2); }</a>
<a name="ln505"> </a>
<a name="ln506">      bool</a>
<a name="ln507">      compare_exchange_strong(__pointer_type&amp; __p1, __pointer_type __p2,</a>
<a name="ln508">			      memory_order __m = memory_order_seq_cst) noexcept</a>
<a name="ln509">      {</a>
<a name="ln510">	return _M_b.compare_exchange_strong(__p1, __p2, __m,</a>
<a name="ln511">					    __cmpexch_failure_order(__m));</a>
<a name="ln512">      }</a>
<a name="ln513"> </a>
<a name="ln514">      bool</a>
<a name="ln515">      compare_exchange_strong(__pointer_type&amp; __p1, __pointer_type __p2,</a>
<a name="ln516">		    memory_order __m = memory_order_seq_cst) volatile noexcept</a>
<a name="ln517">      {</a>
<a name="ln518">	return _M_b.compare_exchange_strong(__p1, __p2, __m,</a>
<a name="ln519">					    __cmpexch_failure_order(__m));</a>
<a name="ln520">      }</a>
<a name="ln521"> </a>
<a name="ln522">      __pointer_type</a>
<a name="ln523">      fetch_add(ptrdiff_t __d,</a>
<a name="ln524">		memory_order __m = memory_order_seq_cst) noexcept</a>
<a name="ln525">      { return _M_b.fetch_add(__d, __m); }</a>
<a name="ln526"> </a>
<a name="ln527">      __pointer_type</a>
<a name="ln528">      fetch_add(ptrdiff_t __d,</a>
<a name="ln529">		memory_order __m = memory_order_seq_cst) volatile noexcept</a>
<a name="ln530">      { return _M_b.fetch_add(__d, __m); }</a>
<a name="ln531"> </a>
<a name="ln532">      __pointer_type</a>
<a name="ln533">      fetch_sub(ptrdiff_t __d,</a>
<a name="ln534">		memory_order __m = memory_order_seq_cst) noexcept</a>
<a name="ln535">      { return _M_b.fetch_sub(__d, __m); }</a>
<a name="ln536"> </a>
<a name="ln537">      __pointer_type</a>
<a name="ln538">      fetch_sub(ptrdiff_t __d,</a>
<a name="ln539">		memory_order __m = memory_order_seq_cst) volatile noexcept</a>
<a name="ln540">      { return _M_b.fetch_sub(__d, __m); }</a>
<a name="ln541">    };</a>
<a name="ln542"> </a>
<a name="ln543"> </a>
<a name="ln544">  /// Explicit specialization for char.</a>
<a name="ln545">  template&lt;&gt;</a>
<a name="ln546">    struct atomic&lt;char&gt; : __atomic_base&lt;char&gt;</a>
<a name="ln547">    {</a>
<a name="ln548">      typedef char 			__integral_type;</a>
<a name="ln549">      typedef __atomic_base&lt;char&gt; 	__base_type;</a>
<a name="ln550"> </a>
<a name="ln551">      atomic() noexcept = default;</a>
<a name="ln552">      ~atomic() noexcept = default;</a>
<a name="ln553">      atomic(const atomic&amp;) = delete;</a>
<a name="ln554">      atomic&amp; operator=(const atomic&amp;) = delete;</a>
<a name="ln555">      atomic&amp; operator=(const atomic&amp;) volatile = delete;</a>
<a name="ln556"> </a>
<a name="ln557">      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }</a>
<a name="ln558"> </a>
<a name="ln559">      using __base_type::operator __integral_type;</a>
<a name="ln560">      using __base_type::operator=;</a>
<a name="ln561"> </a>
<a name="ln562">#if __cplusplus &gt; 201402L</a>
<a name="ln563">    static constexpr bool is_always_lock_free = ATOMIC_CHAR_LOCK_FREE == 2;</a>
<a name="ln564">#endif</a>
<a name="ln565">    };</a>
<a name="ln566"> </a>
<a name="ln567">  /// Explicit specialization for signed char.</a>
<a name="ln568">  template&lt;&gt;</a>
<a name="ln569">    struct atomic&lt;signed char&gt; : __atomic_base&lt;signed char&gt;</a>
<a name="ln570">    {</a>
<a name="ln571">      typedef signed char 		__integral_type;</a>
<a name="ln572">      typedef __atomic_base&lt;signed char&gt; 	__base_type;</a>
<a name="ln573"> </a>
<a name="ln574">      atomic() noexcept= default;</a>
<a name="ln575">      ~atomic() noexcept = default;</a>
<a name="ln576">      atomic(const atomic&amp;) = delete;</a>
<a name="ln577">      atomic&amp; operator=(const atomic&amp;) = delete;</a>
<a name="ln578">      atomic&amp; operator=(const atomic&amp;) volatile = delete;</a>
<a name="ln579"> </a>
<a name="ln580">      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }</a>
<a name="ln581"> </a>
<a name="ln582">      using __base_type::operator __integral_type;</a>
<a name="ln583">      using __base_type::operator=;</a>
<a name="ln584"> </a>
<a name="ln585">#if __cplusplus &gt; 201402L</a>
<a name="ln586">    static constexpr bool is_always_lock_free = ATOMIC_CHAR_LOCK_FREE == 2;</a>
<a name="ln587">#endif</a>
<a name="ln588">    };</a>
<a name="ln589"> </a>
<a name="ln590">  /// Explicit specialization for unsigned char.</a>
<a name="ln591">  template&lt;&gt;</a>
<a name="ln592">    struct atomic&lt;unsigned char&gt; : __atomic_base&lt;unsigned char&gt;</a>
<a name="ln593">    {</a>
<a name="ln594">      typedef unsigned char 		__integral_type;</a>
<a name="ln595">      typedef __atomic_base&lt;unsigned char&gt; 	__base_type;</a>
<a name="ln596"> </a>
<a name="ln597">      atomic() noexcept= default;</a>
<a name="ln598">      ~atomic() noexcept = default;</a>
<a name="ln599">      atomic(const atomic&amp;) = delete;</a>
<a name="ln600">      atomic&amp; operator=(const atomic&amp;) = delete;</a>
<a name="ln601">      atomic&amp; operator=(const atomic&amp;) volatile = delete;</a>
<a name="ln602"> </a>
<a name="ln603">      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }</a>
<a name="ln604"> </a>
<a name="ln605">      using __base_type::operator __integral_type;</a>
<a name="ln606">      using __base_type::operator=;</a>
<a name="ln607"> </a>
<a name="ln608">#if __cplusplus &gt; 201402L</a>
<a name="ln609">    static constexpr bool is_always_lock_free = ATOMIC_CHAR_LOCK_FREE == 2;</a>
<a name="ln610">#endif</a>
<a name="ln611">    };</a>
<a name="ln612"> </a>
<a name="ln613">  /// Explicit specialization for short.</a>
<a name="ln614">  template&lt;&gt;</a>
<a name="ln615">    struct atomic&lt;short&gt; : __atomic_base&lt;short&gt;</a>
<a name="ln616">    {</a>
<a name="ln617">      typedef short 			__integral_type;</a>
<a name="ln618">      typedef __atomic_base&lt;short&gt; 		__base_type;</a>
<a name="ln619"> </a>
<a name="ln620">      atomic() noexcept = default;</a>
<a name="ln621">      ~atomic() noexcept = default;</a>
<a name="ln622">      atomic(const atomic&amp;) = delete;</a>
<a name="ln623">      atomic&amp; operator=(const atomic&amp;) = delete;</a>
<a name="ln624">      atomic&amp; operator=(const atomic&amp;) volatile = delete;</a>
<a name="ln625"> </a>
<a name="ln626">      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }</a>
<a name="ln627"> </a>
<a name="ln628">      using __base_type::operator __integral_type;</a>
<a name="ln629">      using __base_type::operator=;</a>
<a name="ln630"> </a>
<a name="ln631">#if __cplusplus &gt; 201402L</a>
<a name="ln632">    static constexpr bool is_always_lock_free = ATOMIC_SHORT_LOCK_FREE == 2;</a>
<a name="ln633">#endif</a>
<a name="ln634">    };</a>
<a name="ln635"> </a>
<a name="ln636">  /// Explicit specialization for unsigned short.</a>
<a name="ln637">  template&lt;&gt;</a>
<a name="ln638">    struct atomic&lt;unsigned short&gt; : __atomic_base&lt;unsigned short&gt;</a>
<a name="ln639">    {</a>
<a name="ln640">      typedef unsigned short 	      	__integral_type;</a>
<a name="ln641">      typedef __atomic_base&lt;unsigned short&gt; 		__base_type;</a>
<a name="ln642"> </a>
<a name="ln643">      atomic() noexcept = default;</a>
<a name="ln644">      ~atomic() noexcept = default;</a>
<a name="ln645">      atomic(const atomic&amp;) = delete;</a>
<a name="ln646">      atomic&amp; operator=(const atomic&amp;) = delete;</a>
<a name="ln647">      atomic&amp; operator=(const atomic&amp;) volatile = delete;</a>
<a name="ln648"> </a>
<a name="ln649">      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }</a>
<a name="ln650"> </a>
<a name="ln651">      using __base_type::operator __integral_type;</a>
<a name="ln652">      using __base_type::operator=;</a>
<a name="ln653"> </a>
<a name="ln654">#if __cplusplus &gt; 201402L</a>
<a name="ln655">    static constexpr bool is_always_lock_free = ATOMIC_SHORT_LOCK_FREE == 2;</a>
<a name="ln656">#endif</a>
<a name="ln657">    };</a>
<a name="ln658"> </a>
<a name="ln659">  /// Explicit specialization for int.</a>
<a name="ln660">  template&lt;&gt;</a>
<a name="ln661">    struct atomic&lt;int&gt; : __atomic_base&lt;int&gt;</a>
<a name="ln662">    {</a>
<a name="ln663">      typedef int 			__integral_type;</a>
<a name="ln664">      typedef __atomic_base&lt;int&gt; 		__base_type;</a>
<a name="ln665"> </a>
<a name="ln666">      atomic() noexcept = default;</a>
<a name="ln667">      ~atomic() noexcept = default;</a>
<a name="ln668">      atomic(const atomic&amp;) = delete;</a>
<a name="ln669">      atomic&amp; operator=(const atomic&amp;) = delete;</a>
<a name="ln670">      atomic&amp; operator=(const atomic&amp;) volatile = delete;</a>
<a name="ln671"> </a>
<a name="ln672">      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }</a>
<a name="ln673"> </a>
<a name="ln674">      using __base_type::operator __integral_type;</a>
<a name="ln675">      using __base_type::operator=;</a>
<a name="ln676"> </a>
<a name="ln677">#if __cplusplus &gt; 201402L</a>
<a name="ln678">    static constexpr bool is_always_lock_free = ATOMIC_INT_LOCK_FREE == 2;</a>
<a name="ln679">#endif</a>
<a name="ln680">    };</a>
<a name="ln681"> </a>
<a name="ln682">  /// Explicit specialization for unsigned int.</a>
<a name="ln683">  template&lt;&gt;</a>
<a name="ln684">    struct atomic&lt;unsigned int&gt; : __atomic_base&lt;unsigned int&gt;</a>
<a name="ln685">    {</a>
<a name="ln686">      typedef unsigned int		__integral_type;</a>
<a name="ln687">      typedef __atomic_base&lt;unsigned int&gt; 	__base_type;</a>
<a name="ln688"> </a>
<a name="ln689">      atomic() noexcept = default;</a>
<a name="ln690">      ~atomic() noexcept = default;</a>
<a name="ln691">      atomic(const atomic&amp;) = delete;</a>
<a name="ln692">      atomic&amp; operator=(const atomic&amp;) = delete;</a>
<a name="ln693">      atomic&amp; operator=(const atomic&amp;) volatile = delete;</a>
<a name="ln694"> </a>
<a name="ln695">      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }</a>
<a name="ln696"> </a>
<a name="ln697">      using __base_type::operator __integral_type;</a>
<a name="ln698">      using __base_type::operator=;</a>
<a name="ln699"> </a>
<a name="ln700">#if __cplusplus &gt; 201402L</a>
<a name="ln701">    static constexpr bool is_always_lock_free = ATOMIC_INT_LOCK_FREE == 2;</a>
<a name="ln702">#endif</a>
<a name="ln703">    };</a>
<a name="ln704"> </a>
<a name="ln705">  /// Explicit specialization for long.</a>
<a name="ln706">  template&lt;&gt;</a>
<a name="ln707">    struct atomic&lt;long&gt; : __atomic_base&lt;long&gt;</a>
<a name="ln708">    {</a>
<a name="ln709">      typedef long 			__integral_type;</a>
<a name="ln710">      typedef __atomic_base&lt;long&gt; 	__base_type;</a>
<a name="ln711"> </a>
<a name="ln712">      atomic() noexcept = default;</a>
<a name="ln713">      ~atomic() noexcept = default;</a>
<a name="ln714">      atomic(const atomic&amp;) = delete;</a>
<a name="ln715">      atomic&amp; operator=(const atomic&amp;) = delete;</a>
<a name="ln716">      atomic&amp; operator=(const atomic&amp;) volatile = delete;</a>
<a name="ln717"> </a>
<a name="ln718">      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }</a>
<a name="ln719"> </a>
<a name="ln720">      using __base_type::operator __integral_type;</a>
<a name="ln721">      using __base_type::operator=;</a>
<a name="ln722"> </a>
<a name="ln723">#if __cplusplus &gt; 201402L</a>
<a name="ln724">    static constexpr bool is_always_lock_free = ATOMIC_LONG_LOCK_FREE == 2;</a>
<a name="ln725">#endif</a>
<a name="ln726">    };</a>
<a name="ln727"> </a>
<a name="ln728">  /// Explicit specialization for unsigned long.</a>
<a name="ln729">  template&lt;&gt;</a>
<a name="ln730">    struct atomic&lt;unsigned long&gt; : __atomic_base&lt;unsigned long&gt;</a>
<a name="ln731">    {</a>
<a name="ln732">      typedef unsigned long 		__integral_type;</a>
<a name="ln733">      typedef __atomic_base&lt;unsigned long&gt; 	__base_type;</a>
<a name="ln734"> </a>
<a name="ln735">      atomic() noexcept = default;</a>
<a name="ln736">      ~atomic() noexcept = default;</a>
<a name="ln737">      atomic(const atomic&amp;) = delete;</a>
<a name="ln738">      atomic&amp; operator=(const atomic&amp;) = delete;</a>
<a name="ln739">      atomic&amp; operator=(const atomic&amp;) volatile = delete;</a>
<a name="ln740"> </a>
<a name="ln741">      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }</a>
<a name="ln742"> </a>
<a name="ln743">      using __base_type::operator __integral_type;</a>
<a name="ln744">      using __base_type::operator=;</a>
<a name="ln745"> </a>
<a name="ln746">#if __cplusplus &gt; 201402L</a>
<a name="ln747">    static constexpr bool is_always_lock_free = ATOMIC_LONG_LOCK_FREE == 2;</a>
<a name="ln748">#endif</a>
<a name="ln749">    };</a>
<a name="ln750"> </a>
<a name="ln751">  /// Explicit specialization for long long.</a>
<a name="ln752">  template&lt;&gt;</a>
<a name="ln753">    struct atomic&lt;long long&gt; : __atomic_base&lt;long long&gt;</a>
<a name="ln754">    {</a>
<a name="ln755">      typedef long long 		__integral_type;</a>
<a name="ln756">      typedef __atomic_base&lt;long long&gt; 		__base_type;</a>
<a name="ln757"> </a>
<a name="ln758">      atomic() noexcept = default;</a>
<a name="ln759">      ~atomic() noexcept = default;</a>
<a name="ln760">      atomic(const atomic&amp;) = delete;</a>
<a name="ln761">      atomic&amp; operator=(const atomic&amp;) = delete;</a>
<a name="ln762">      atomic&amp; operator=(const atomic&amp;) volatile = delete;</a>
<a name="ln763"> </a>
<a name="ln764">      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }</a>
<a name="ln765"> </a>
<a name="ln766">      using __base_type::operator __integral_type;</a>
<a name="ln767">      using __base_type::operator=;</a>
<a name="ln768"> </a>
<a name="ln769">#if __cplusplus &gt; 201402L</a>
<a name="ln770">    static constexpr bool is_always_lock_free = ATOMIC_LLONG_LOCK_FREE == 2;</a>
<a name="ln771">#endif</a>
<a name="ln772">    };</a>
<a name="ln773"> </a>
<a name="ln774">  /// Explicit specialization for unsigned long long.</a>
<a name="ln775">  template&lt;&gt;</a>
<a name="ln776">    struct atomic&lt;unsigned long long&gt; : __atomic_base&lt;unsigned long long&gt;</a>
<a name="ln777">    {</a>
<a name="ln778">      typedef unsigned long long       	__integral_type;</a>
<a name="ln779">      typedef __atomic_base&lt;unsigned long long&gt; 	__base_type;</a>
<a name="ln780"> </a>
<a name="ln781">      atomic() noexcept = default;</a>
<a name="ln782">      ~atomic() noexcept = default;</a>
<a name="ln783">      atomic(const atomic&amp;) = delete;</a>
<a name="ln784">      atomic&amp; operator=(const atomic&amp;) = delete;</a>
<a name="ln785">      atomic&amp; operator=(const atomic&amp;) volatile = delete;</a>
<a name="ln786"> </a>
<a name="ln787">      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }</a>
<a name="ln788"> </a>
<a name="ln789">      using __base_type::operator __integral_type;</a>
<a name="ln790">      using __base_type::operator=;</a>
<a name="ln791"> </a>
<a name="ln792">#if __cplusplus &gt; 201402L</a>
<a name="ln793">    static constexpr bool is_always_lock_free = ATOMIC_LLONG_LOCK_FREE == 2;</a>
<a name="ln794">#endif</a>
<a name="ln795">    };</a>
<a name="ln796"> </a>
<a name="ln797">  /// Explicit specialization for wchar_t.</a>
<a name="ln798">  template&lt;&gt;</a>
<a name="ln799">    struct atomic&lt;wchar_t&gt; : __atomic_base&lt;wchar_t&gt;</a>
<a name="ln800">    {</a>
<a name="ln801">      typedef wchar_t 			__integral_type;</a>
<a name="ln802">      typedef __atomic_base&lt;wchar_t&gt; 	__base_type;</a>
<a name="ln803"> </a>
<a name="ln804">      atomic() noexcept = default;</a>
<a name="ln805">      ~atomic() noexcept = default;</a>
<a name="ln806">      atomic(const atomic&amp;) = delete;</a>
<a name="ln807">      atomic&amp; operator=(const atomic&amp;) = delete;</a>
<a name="ln808">      atomic&amp; operator=(const atomic&amp;) volatile = delete;</a>
<a name="ln809"> </a>
<a name="ln810">      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }</a>
<a name="ln811"> </a>
<a name="ln812">      using __base_type::operator __integral_type;</a>
<a name="ln813">      using __base_type::operator=;</a>
<a name="ln814"> </a>
<a name="ln815">#if __cplusplus &gt; 201402L</a>
<a name="ln816">    static constexpr bool is_always_lock_free = ATOMIC_WCHAR_T_LOCK_FREE == 2;</a>
<a name="ln817">#endif</a>
<a name="ln818">    };</a>
<a name="ln819"> </a>
<a name="ln820">  /// Explicit specialization for char16_t.</a>
<a name="ln821">  template&lt;&gt;</a>
<a name="ln822">    struct atomic&lt;char16_t&gt; : __atomic_base&lt;char16_t&gt;</a>
<a name="ln823">    {</a>
<a name="ln824">      typedef char16_t 			__integral_type;</a>
<a name="ln825">      typedef __atomic_base&lt;char16_t&gt; 	__base_type;</a>
<a name="ln826"> </a>
<a name="ln827">      atomic() noexcept = default;</a>
<a name="ln828">      ~atomic() noexcept = default;</a>
<a name="ln829">      atomic(const atomic&amp;) = delete;</a>
<a name="ln830">      atomic&amp; operator=(const atomic&amp;) = delete;</a>
<a name="ln831">      atomic&amp; operator=(const atomic&amp;) volatile = delete;</a>
<a name="ln832"> </a>
<a name="ln833">      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }</a>
<a name="ln834"> </a>
<a name="ln835">      using __base_type::operator __integral_type;</a>
<a name="ln836">      using __base_type::operator=;</a>
<a name="ln837"> </a>
<a name="ln838">#if __cplusplus &gt; 201402L</a>
<a name="ln839">    static constexpr bool is_always_lock_free = ATOMIC_CHAR16_T_LOCK_FREE == 2;</a>
<a name="ln840">#endif</a>
<a name="ln841">    };</a>
<a name="ln842"> </a>
<a name="ln843">  /// Explicit specialization for char32_t.</a>
<a name="ln844">  template&lt;&gt;</a>
<a name="ln845">    struct atomic&lt;char32_t&gt; : __atomic_base&lt;char32_t&gt;</a>
<a name="ln846">    {</a>
<a name="ln847">      typedef char32_t 			__integral_type;</a>
<a name="ln848">      typedef __atomic_base&lt;char32_t&gt; 	__base_type;</a>
<a name="ln849"> </a>
<a name="ln850">      atomic() noexcept = default;</a>
<a name="ln851">      ~atomic() noexcept = default;</a>
<a name="ln852">      atomic(const atomic&amp;) = delete;</a>
<a name="ln853">      atomic&amp; operator=(const atomic&amp;) = delete;</a>
<a name="ln854">      atomic&amp; operator=(const atomic&amp;) volatile = delete;</a>
<a name="ln855"> </a>
<a name="ln856">      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }</a>
<a name="ln857"> </a>
<a name="ln858">      using __base_type::operator __integral_type;</a>
<a name="ln859">      using __base_type::operator=;</a>
<a name="ln860"> </a>
<a name="ln861">#if __cplusplus &gt; 201402L</a>
<a name="ln862">    static constexpr bool is_always_lock_free = ATOMIC_CHAR32_T_LOCK_FREE == 2;</a>
<a name="ln863">#endif</a>
<a name="ln864">    };</a>
<a name="ln865"> </a>
<a name="ln866"> </a>
<a name="ln867">  /// atomic_bool</a>
<a name="ln868">  typedef atomic&lt;bool&gt;			atomic_bool;</a>
<a name="ln869"> </a>
<a name="ln870">  /// atomic_char</a>
<a name="ln871">  typedef atomic&lt;char&gt;			atomic_char;</a>
<a name="ln872"> </a>
<a name="ln873">  /// atomic_schar</a>
<a name="ln874">  typedef atomic&lt;signed char&gt;		atomic_schar;</a>
<a name="ln875"> </a>
<a name="ln876">  /// atomic_uchar</a>
<a name="ln877">  typedef atomic&lt;unsigned char&gt;		atomic_uchar;</a>
<a name="ln878"> </a>
<a name="ln879">  /// atomic_short</a>
<a name="ln880">  typedef atomic&lt;short&gt;			atomic_short;</a>
<a name="ln881"> </a>
<a name="ln882">  /// atomic_ushort</a>
<a name="ln883">  typedef atomic&lt;unsigned short&gt;	atomic_ushort;</a>
<a name="ln884"> </a>
<a name="ln885">  /// atomic_int</a>
<a name="ln886">  typedef atomic&lt;int&gt;			atomic_int;</a>
<a name="ln887"> </a>
<a name="ln888">  /// atomic_uint</a>
<a name="ln889">  typedef atomic&lt;unsigned int&gt;		atomic_uint;</a>
<a name="ln890"> </a>
<a name="ln891">  /// atomic_long</a>
<a name="ln892">  typedef atomic&lt;long&gt;			atomic_long;</a>
<a name="ln893"> </a>
<a name="ln894">  /// atomic_ulong</a>
<a name="ln895">  typedef atomic&lt;unsigned long&gt;		atomic_ulong;</a>
<a name="ln896"> </a>
<a name="ln897">  /// atomic_llong</a>
<a name="ln898">  typedef atomic&lt;long long&gt;		atomic_llong;</a>
<a name="ln899"> </a>
<a name="ln900">  /// atomic_ullong</a>
<a name="ln901">  typedef atomic&lt;unsigned long long&gt;	atomic_ullong;</a>
<a name="ln902"> </a>
<a name="ln903">  /// atomic_wchar_t</a>
<a name="ln904">  typedef atomic&lt;wchar_t&gt;		atomic_wchar_t;</a>
<a name="ln905"> </a>
<a name="ln906">  /// atomic_char16_t</a>
<a name="ln907">  typedef atomic&lt;char16_t&gt;		atomic_char16_t;</a>
<a name="ln908"> </a>
<a name="ln909">  /// atomic_char32_t</a>
<a name="ln910">  typedef atomic&lt;char32_t&gt;		atomic_char32_t;</a>
<a name="ln911"> </a>
<a name="ln912">#ifdef _GLIBCXX_USE_C99_STDINT_TR1</a>
<a name="ln913">  // _GLIBCXX_RESOLVE_LIB_DEFECTS</a>
<a name="ln914">  // 2441. Exact-width atomic typedefs should be provided</a>
<a name="ln915"> </a>
<a name="ln916">  /// atomic_int8_t</a>
<a name="ln917">  typedef atomic&lt;int8_t&gt;		atomic_int8_t;</a>
<a name="ln918"> </a>
<a name="ln919">  /// atomic_uint8_t</a>
<a name="ln920">  typedef atomic&lt;uint8_t&gt;		atomic_uint8_t;</a>
<a name="ln921"> </a>
<a name="ln922">  /// atomic_int16_t</a>
<a name="ln923">  typedef atomic&lt;int16_t&gt;		atomic_int16_t;</a>
<a name="ln924"> </a>
<a name="ln925">  /// atomic_uint16_t</a>
<a name="ln926">  typedef atomic&lt;uint16_t&gt;		atomic_uint16_t;</a>
<a name="ln927"> </a>
<a name="ln928">  /// atomic_int32_t</a>
<a name="ln929">  typedef atomic&lt;int32_t&gt;		atomic_int32_t;</a>
<a name="ln930"> </a>
<a name="ln931">  /// atomic_uint32_t</a>
<a name="ln932">  typedef atomic&lt;uint32_t&gt;		atomic_uint32_t;</a>
<a name="ln933"> </a>
<a name="ln934">  /// atomic_int64_t</a>
<a name="ln935">  typedef atomic&lt;int64_t&gt;		atomic_int64_t;</a>
<a name="ln936"> </a>
<a name="ln937">  /// atomic_uint64_t</a>
<a name="ln938">  typedef atomic&lt;uint64_t&gt;		atomic_uint64_t;</a>
<a name="ln939"> </a>
<a name="ln940"> </a>
<a name="ln941">  /// atomic_int_least8_t</a>
<a name="ln942">  typedef atomic&lt;int_least8_t&gt;		atomic_int_least8_t;</a>
<a name="ln943"> </a>
<a name="ln944">  /// atomic_uint_least8_t</a>
<a name="ln945">  typedef atomic&lt;uint_least8_t&gt;		atomic_uint_least8_t;</a>
<a name="ln946"> </a>
<a name="ln947">  /// atomic_int_least16_t</a>
<a name="ln948">  typedef atomic&lt;int_least16_t&gt;		atomic_int_least16_t;</a>
<a name="ln949"> </a>
<a name="ln950">  /// atomic_uint_least16_t</a>
<a name="ln951">  typedef atomic&lt;uint_least16_t&gt;	atomic_uint_least16_t;</a>
<a name="ln952"> </a>
<a name="ln953">  /// atomic_int_least32_t</a>
<a name="ln954">  typedef atomic&lt;int_least32_t&gt;		atomic_int_least32_t;</a>
<a name="ln955"> </a>
<a name="ln956">  /// atomic_uint_least32_t</a>
<a name="ln957">  typedef atomic&lt;uint_least32_t&gt;	atomic_uint_least32_t;</a>
<a name="ln958"> </a>
<a name="ln959">  /// atomic_int_least64_t</a>
<a name="ln960">  typedef atomic&lt;int_least64_t&gt;		atomic_int_least64_t;</a>
<a name="ln961"> </a>
<a name="ln962">  /// atomic_uint_least64_t</a>
<a name="ln963">  typedef atomic&lt;uint_least64_t&gt;	atomic_uint_least64_t;</a>
<a name="ln964"> </a>
<a name="ln965"> </a>
<a name="ln966">  /// atomic_int_fast8_t</a>
<a name="ln967">  typedef atomic&lt;int_fast8_t&gt;		atomic_int_fast8_t;</a>
<a name="ln968"> </a>
<a name="ln969">  /// atomic_uint_fast8_t</a>
<a name="ln970">  typedef atomic&lt;uint_fast8_t&gt;		atomic_uint_fast8_t;</a>
<a name="ln971"> </a>
<a name="ln972">  /// atomic_int_fast16_t</a>
<a name="ln973">  typedef atomic&lt;int_fast16_t&gt;		atomic_int_fast16_t;</a>
<a name="ln974"> </a>
<a name="ln975">  /// atomic_uint_fast16_t</a>
<a name="ln976">  typedef atomic&lt;uint_fast16_t&gt;		atomic_uint_fast16_t;</a>
<a name="ln977"> </a>
<a name="ln978">  /// atomic_int_fast32_t</a>
<a name="ln979">  typedef atomic&lt;int_fast32_t&gt;		atomic_int_fast32_t;</a>
<a name="ln980"> </a>
<a name="ln981">  /// atomic_uint_fast32_t</a>
<a name="ln982">  typedef atomic&lt;uint_fast32_t&gt;		atomic_uint_fast32_t;</a>
<a name="ln983"> </a>
<a name="ln984">  /// atomic_int_fast64_t</a>
<a name="ln985">  typedef atomic&lt;int_fast64_t&gt;		atomic_int_fast64_t;</a>
<a name="ln986"> </a>
<a name="ln987">  /// atomic_uint_fast64_t</a>
<a name="ln988">  typedef atomic&lt;uint_fast64_t&gt;		atomic_uint_fast64_t;</a>
<a name="ln989">#endif</a>
<a name="ln990"> </a>
<a name="ln991"> </a>
<a name="ln992">  /// atomic_intptr_t</a>
<a name="ln993">  typedef atomic&lt;intptr_t&gt;		atomic_intptr_t;</a>
<a name="ln994"> </a>
<a name="ln995">  /// atomic_uintptr_t</a>
<a name="ln996">  typedef atomic&lt;uintptr_t&gt;		atomic_uintptr_t;</a>
<a name="ln997"> </a>
<a name="ln998">  /// atomic_size_t</a>
<a name="ln999">  typedef atomic&lt;size_t&gt;		atomic_size_t;</a>
<a name="ln1000"> </a>
<a name="ln1001">  /// atomic_ptrdiff_t</a>
<a name="ln1002">  typedef atomic&lt;ptrdiff_t&gt;		atomic_ptrdiff_t;</a>
<a name="ln1003"> </a>
<a name="ln1004">#ifdef _GLIBCXX_USE_C99_STDINT_TR1</a>
<a name="ln1005">  /// atomic_intmax_t</a>
<a name="ln1006">  typedef atomic&lt;intmax_t&gt;		atomic_intmax_t;</a>
<a name="ln1007"> </a>
<a name="ln1008">  /// atomic_uintmax_t</a>
<a name="ln1009">  typedef atomic&lt;uintmax_t&gt;		atomic_uintmax_t;</a>
<a name="ln1010">#endif</a>
<a name="ln1011"> </a>
<a name="ln1012">  // Function definitions, atomic_flag operations.</a>
<a name="ln1013">  inline bool</a>
<a name="ln1014">  atomic_flag_test_and_set_explicit(atomic_flag* __a,</a>
<a name="ln1015">				    memory_order __m) noexcept</a>
<a name="ln1016">  { return __a-&gt;test_and_set(__m); }</a>
<a name="ln1017"> </a>
<a name="ln1018">  inline bool</a>
<a name="ln1019">  atomic_flag_test_and_set_explicit(volatile atomic_flag* __a,</a>
<a name="ln1020">				    memory_order __m) noexcept</a>
<a name="ln1021">  { return __a-&gt;test_and_set(__m); }</a>
<a name="ln1022"> </a>
<a name="ln1023">  inline void</a>
<a name="ln1024">  atomic_flag_clear_explicit(atomic_flag* __a, memory_order __m) noexcept</a>
<a name="ln1025">  { __a-&gt;clear(__m); }</a>
<a name="ln1026"> </a>
<a name="ln1027">  inline void</a>
<a name="ln1028">  atomic_flag_clear_explicit(volatile atomic_flag* __a,</a>
<a name="ln1029">			     memory_order __m) noexcept</a>
<a name="ln1030">  { __a-&gt;clear(__m); }</a>
<a name="ln1031"> </a>
<a name="ln1032">  inline bool</a>
<a name="ln1033">  atomic_flag_test_and_set(atomic_flag* __a) noexcept</a>
<a name="ln1034">  { return atomic_flag_test_and_set_explicit(__a, memory_order_seq_cst); }</a>
<a name="ln1035"> </a>
<a name="ln1036">  inline bool</a>
<a name="ln1037">  atomic_flag_test_and_set(volatile atomic_flag* __a) noexcept</a>
<a name="ln1038">  { return atomic_flag_test_and_set_explicit(__a, memory_order_seq_cst); }</a>
<a name="ln1039"> </a>
<a name="ln1040">  inline void</a>
<a name="ln1041">  atomic_flag_clear(atomic_flag* __a) noexcept</a>
<a name="ln1042">  { atomic_flag_clear_explicit(__a, memory_order_seq_cst); }</a>
<a name="ln1043"> </a>
<a name="ln1044">  inline void</a>
<a name="ln1045">  atomic_flag_clear(volatile atomic_flag* __a) noexcept</a>
<a name="ln1046">  { atomic_flag_clear_explicit(__a, memory_order_seq_cst); }</a>
<a name="ln1047"> </a>
<a name="ln1048"> </a>
<a name="ln1049">  // Function templates generally applicable to atomic types.</a>
<a name="ln1050">  template&lt;typename _ITp&gt;</a>
<a name="ln1051">    inline bool</a>
<a name="ln1052">    atomic_is_lock_free(const atomic&lt;_ITp&gt;* __a) noexcept</a>
<a name="ln1053">    { return __a-&gt;is_lock_free(); }</a>
<a name="ln1054"> </a>
<a name="ln1055">  template&lt;typename _ITp&gt;</a>
<a name="ln1056">    inline bool</a>
<a name="ln1057">    atomic_is_lock_free(const volatile atomic&lt;_ITp&gt;* __a) noexcept</a>
<a name="ln1058">    { return __a-&gt;is_lock_free(); }</a>
<a name="ln1059"> </a>
<a name="ln1060">  template&lt;typename _ITp&gt;</a>
<a name="ln1061">    inline void</a>
<a name="ln1062">    atomic_init(atomic&lt;_ITp&gt;* __a, _ITp __i) noexcept</a>
<a name="ln1063">    { __a-&gt;store(__i, memory_order_relaxed); }</a>
<a name="ln1064"> </a>
<a name="ln1065">  template&lt;typename _ITp&gt;</a>
<a name="ln1066">    inline void</a>
<a name="ln1067">    atomic_init(volatile atomic&lt;_ITp&gt;* __a, _ITp __i) noexcept</a>
<a name="ln1068">    { __a-&gt;store(__i, memory_order_relaxed); }</a>
<a name="ln1069"> </a>
<a name="ln1070">  template&lt;typename _ITp&gt;</a>
<a name="ln1071">    inline void</a>
<a name="ln1072">    atomic_store_explicit(atomic&lt;_ITp&gt;* __a, _ITp __i,</a>
<a name="ln1073">			  memory_order __m) noexcept</a>
<a name="ln1074">    { __a-&gt;store(__i, __m); }</a>
<a name="ln1075"> </a>
<a name="ln1076">  template&lt;typename _ITp&gt;</a>
<a name="ln1077">    inline void</a>
<a name="ln1078">    atomic_store_explicit(volatile atomic&lt;_ITp&gt;* __a, _ITp __i,</a>
<a name="ln1079">			  memory_order __m) noexcept</a>
<a name="ln1080">    { __a-&gt;store(__i, __m); }</a>
<a name="ln1081"> </a>
<a name="ln1082">  template&lt;typename _ITp&gt;</a>
<a name="ln1083">    inline _ITp</a>
<a name="ln1084">    atomic_load_explicit(const atomic&lt;_ITp&gt;* __a, memory_order __m) noexcept</a>
<a name="ln1085">    { return __a-&gt;load(__m); }</a>
<a name="ln1086"> </a>
<a name="ln1087">  template&lt;typename _ITp&gt;</a>
<a name="ln1088">    inline _ITp</a>
<a name="ln1089">    atomic_load_explicit(const volatile atomic&lt;_ITp&gt;* __a,</a>
<a name="ln1090">			 memory_order __m) noexcept</a>
<a name="ln1091">    { return __a-&gt;load(__m); }</a>
<a name="ln1092"> </a>
<a name="ln1093">  template&lt;typename _ITp&gt;</a>
<a name="ln1094">    inline _ITp</a>
<a name="ln1095">    atomic_exchange_explicit(atomic&lt;_ITp&gt;* __a, _ITp __i,</a>
<a name="ln1096">			     memory_order __m) noexcept</a>
<a name="ln1097">    { return __a-&gt;exchange(__i, __m); }</a>
<a name="ln1098"> </a>
<a name="ln1099">  template&lt;typename _ITp&gt;</a>
<a name="ln1100">    inline _ITp</a>
<a name="ln1101">    atomic_exchange_explicit(volatile atomic&lt;_ITp&gt;* __a, _ITp __i,</a>
<a name="ln1102">			     memory_order __m) noexcept</a>
<a name="ln1103">    { return __a-&gt;exchange(__i, __m); }</a>
<a name="ln1104"> </a>
<a name="ln1105">  template&lt;typename _ITp&gt;</a>
<a name="ln1106">    inline bool</a>
<a name="ln1107">    atomic_compare_exchange_weak_explicit(atomic&lt;_ITp&gt;* __a,</a>
<a name="ln1108">					  _ITp* __i1, _ITp __i2,</a>
<a name="ln1109">					  memory_order __m1,</a>
<a name="ln1110">					  memory_order __m2) noexcept</a>
<a name="ln1111">    { return __a-&gt;compare_exchange_weak(*__i1, __i2, __m1, __m2); }</a>
<a name="ln1112"> </a>
<a name="ln1113">  template&lt;typename _ITp&gt;</a>
<a name="ln1114">    inline bool</a>
<a name="ln1115">    atomic_compare_exchange_weak_explicit(volatile atomic&lt;_ITp&gt;* __a,</a>
<a name="ln1116">					  _ITp* __i1, _ITp __i2,</a>
<a name="ln1117">					  memory_order __m1,</a>
<a name="ln1118">					  memory_order __m2) noexcept</a>
<a name="ln1119">    { return __a-&gt;compare_exchange_weak(*__i1, __i2, __m1, __m2); }</a>
<a name="ln1120"> </a>
<a name="ln1121">  template&lt;typename _ITp&gt;</a>
<a name="ln1122">    inline bool</a>
<a name="ln1123">    atomic_compare_exchange_strong_explicit(atomic&lt;_ITp&gt;* __a,</a>
<a name="ln1124">					    _ITp* __i1, _ITp __i2,</a>
<a name="ln1125">					    memory_order __m1,</a>
<a name="ln1126">					    memory_order __m2) noexcept</a>
<a name="ln1127">    { return __a-&gt;compare_exchange_strong(*__i1, __i2, __m1, __m2); }</a>
<a name="ln1128"> </a>
<a name="ln1129">  template&lt;typename _ITp&gt;</a>
<a name="ln1130">    inline bool</a>
<a name="ln1131">    atomic_compare_exchange_strong_explicit(volatile atomic&lt;_ITp&gt;* __a,</a>
<a name="ln1132">					    _ITp* __i1, _ITp __i2,</a>
<a name="ln1133">					    memory_order __m1,</a>
<a name="ln1134">					    memory_order __m2) noexcept</a>
<a name="ln1135">    { return __a-&gt;compare_exchange_strong(*__i1, __i2, __m1, __m2); }</a>
<a name="ln1136"> </a>
<a name="ln1137"> </a>
<a name="ln1138">  template&lt;typename _ITp&gt;</a>
<a name="ln1139">    inline void</a>
<a name="ln1140">    atomic_store(atomic&lt;_ITp&gt;* __a, _ITp __i) noexcept</a>
<a name="ln1141">    { atomic_store_explicit(__a, __i, memory_order_seq_cst); }</a>
<a name="ln1142"> </a>
<a name="ln1143">  template&lt;typename _ITp&gt;</a>
<a name="ln1144">    inline void</a>
<a name="ln1145">    atomic_store(volatile atomic&lt;_ITp&gt;* __a, _ITp __i) noexcept</a>
<a name="ln1146">    { atomic_store_explicit(__a, __i, memory_order_seq_cst); }</a>
<a name="ln1147"> </a>
<a name="ln1148">  template&lt;typename _ITp&gt;</a>
<a name="ln1149">    inline _ITp</a>
<a name="ln1150">    atomic_load(const atomic&lt;_ITp&gt;* __a) noexcept</a>
<a name="ln1151">    { return atomic_load_explicit(__a, memory_order_seq_cst); }</a>
<a name="ln1152"> </a>
<a name="ln1153">  template&lt;typename _ITp&gt;</a>
<a name="ln1154">    inline _ITp</a>
<a name="ln1155">    atomic_load(const volatile atomic&lt;_ITp&gt;* __a) noexcept</a>
<a name="ln1156">    { return atomic_load_explicit(__a, memory_order_seq_cst); }</a>
<a name="ln1157"> </a>
<a name="ln1158">  template&lt;typename _ITp&gt;</a>
<a name="ln1159">    inline _ITp</a>
<a name="ln1160">    atomic_exchange(atomic&lt;_ITp&gt;* __a, _ITp __i) noexcept</a>
<a name="ln1161">    { return atomic_exchange_explicit(__a, __i, memory_order_seq_cst); }</a>
<a name="ln1162"> </a>
<a name="ln1163">  template&lt;typename _ITp&gt;</a>
<a name="ln1164">    inline _ITp</a>
<a name="ln1165">    atomic_exchange(volatile atomic&lt;_ITp&gt;* __a, _ITp __i) noexcept</a>
<a name="ln1166">    { return atomic_exchange_explicit(__a, __i, memory_order_seq_cst); }</a>
<a name="ln1167"> </a>
<a name="ln1168">  template&lt;typename _ITp&gt;</a>
<a name="ln1169">    inline bool</a>
<a name="ln1170">    atomic_compare_exchange_weak(atomic&lt;_ITp&gt;* __a,</a>
<a name="ln1171">				 _ITp* __i1, _ITp __i2) noexcept</a>
<a name="ln1172">    {</a>
<a name="ln1173">      return atomic_compare_exchange_weak_explicit(__a, __i1, __i2,</a>
<a name="ln1174">						   memory_order_seq_cst,</a>
<a name="ln1175">						   memory_order_seq_cst);</a>
<a name="ln1176">    }</a>
<a name="ln1177"> </a>
<a name="ln1178">  template&lt;typename _ITp&gt;</a>
<a name="ln1179">    inline bool</a>
<a name="ln1180">    atomic_compare_exchange_weak(volatile atomic&lt;_ITp&gt;* __a,</a>
<a name="ln1181">				 _ITp* __i1, _ITp __i2) noexcept</a>
<a name="ln1182">    {</a>
<a name="ln1183">      return atomic_compare_exchange_weak_explicit(__a, __i1, __i2,</a>
<a name="ln1184">						   memory_order_seq_cst,</a>
<a name="ln1185">						   memory_order_seq_cst);</a>
<a name="ln1186">    }</a>
<a name="ln1187"> </a>
<a name="ln1188">  template&lt;typename _ITp&gt;</a>
<a name="ln1189">    inline bool</a>
<a name="ln1190">    atomic_compare_exchange_strong(atomic&lt;_ITp&gt;* __a,</a>
<a name="ln1191">				   _ITp* __i1, _ITp __i2) noexcept</a>
<a name="ln1192">    {</a>
<a name="ln1193">      return atomic_compare_exchange_strong_explicit(__a, __i1, __i2,</a>
<a name="ln1194">						     memory_order_seq_cst,</a>
<a name="ln1195">						     memory_order_seq_cst);</a>
<a name="ln1196">    }</a>
<a name="ln1197"> </a>
<a name="ln1198">  template&lt;typename _ITp&gt;</a>
<a name="ln1199">    inline bool</a>
<a name="ln1200">    atomic_compare_exchange_strong(volatile atomic&lt;_ITp&gt;* __a,</a>
<a name="ln1201">				   _ITp* __i1, _ITp __i2) noexcept</a>
<a name="ln1202">    {</a>
<a name="ln1203">      return atomic_compare_exchange_strong_explicit(__a, __i1, __i2,</a>
<a name="ln1204">						     memory_order_seq_cst,</a>
<a name="ln1205">						     memory_order_seq_cst);</a>
<a name="ln1206">    }</a>
<a name="ln1207"> </a>
<a name="ln1208">  // Function templates for atomic_integral operations only, using</a>
<a name="ln1209">  // __atomic_base. Template argument should be constricted to</a>
<a name="ln1210">  // intergral types as specified in the standard, excluding address</a>
<a name="ln1211">  // types.</a>
<a name="ln1212">  template&lt;typename _ITp&gt;</a>
<a name="ln1213">    inline _ITp</a>
<a name="ln1214">    atomic_fetch_add_explicit(__atomic_base&lt;_ITp&gt;* __a, _ITp __i,</a>
<a name="ln1215">			      memory_order __m) noexcept</a>
<a name="ln1216">    { return __a-&gt;fetch_add(__i, __m); }</a>
<a name="ln1217"> </a>
<a name="ln1218">  template&lt;typename _ITp&gt;</a>
<a name="ln1219">    inline _ITp</a>
<a name="ln1220">    atomic_fetch_add_explicit(volatile __atomic_base&lt;_ITp&gt;* __a, _ITp __i,</a>
<a name="ln1221">			      memory_order __m) noexcept</a>
<a name="ln1222">    { return __a-&gt;fetch_add(__i, __m); }</a>
<a name="ln1223"> </a>
<a name="ln1224">  template&lt;typename _ITp&gt;</a>
<a name="ln1225">    inline _ITp</a>
<a name="ln1226">    atomic_fetch_sub_explicit(__atomic_base&lt;_ITp&gt;* __a, _ITp __i,</a>
<a name="ln1227">			      memory_order __m) noexcept</a>
<a name="ln1228">    { return __a-&gt;fetch_sub(__i, __m); }</a>
<a name="ln1229"> </a>
<a name="ln1230">  template&lt;typename _ITp&gt;</a>
<a name="ln1231">    inline _ITp</a>
<a name="ln1232">    atomic_fetch_sub_explicit(volatile __atomic_base&lt;_ITp&gt;* __a, _ITp __i,</a>
<a name="ln1233">			      memory_order __m) noexcept</a>
<a name="ln1234">    { return __a-&gt;fetch_sub(__i, __m); }</a>
<a name="ln1235"> </a>
<a name="ln1236">  template&lt;typename _ITp&gt;</a>
<a name="ln1237">    inline _ITp</a>
<a name="ln1238">    atomic_fetch_and_explicit(__atomic_base&lt;_ITp&gt;* __a, _ITp __i,</a>
<a name="ln1239">			      memory_order __m) noexcept</a>
<a name="ln1240">    { return __a-&gt;fetch_and(__i, __m); }</a>
<a name="ln1241"> </a>
<a name="ln1242">  template&lt;typename _ITp&gt;</a>
<a name="ln1243">    inline _ITp</a>
<a name="ln1244">    atomic_fetch_and_explicit(volatile __atomic_base&lt;_ITp&gt;* __a, _ITp __i,</a>
<a name="ln1245">			      memory_order __m) noexcept</a>
<a name="ln1246">    { return __a-&gt;fetch_and(__i, __m); }</a>
<a name="ln1247"> </a>
<a name="ln1248">  template&lt;typename _ITp&gt;</a>
<a name="ln1249">    inline _ITp</a>
<a name="ln1250">    atomic_fetch_or_explicit(__atomic_base&lt;_ITp&gt;* __a, _ITp __i,</a>
<a name="ln1251">			     memory_order __m) noexcept</a>
<a name="ln1252">    { return __a-&gt;fetch_or(__i, __m); }</a>
<a name="ln1253"> </a>
<a name="ln1254">  template&lt;typename _ITp&gt;</a>
<a name="ln1255">    inline _ITp</a>
<a name="ln1256">    atomic_fetch_or_explicit(volatile __atomic_base&lt;_ITp&gt;* __a, _ITp __i,</a>
<a name="ln1257">			     memory_order __m) noexcept</a>
<a name="ln1258">    { return __a-&gt;fetch_or(__i, __m); }</a>
<a name="ln1259"> </a>
<a name="ln1260">  template&lt;typename _ITp&gt;</a>
<a name="ln1261">    inline _ITp</a>
<a name="ln1262">    atomic_fetch_xor_explicit(__atomic_base&lt;_ITp&gt;* __a, _ITp __i,</a>
<a name="ln1263">			      memory_order __m) noexcept</a>
<a name="ln1264">    { return __a-&gt;fetch_xor(__i, __m); }</a>
<a name="ln1265"> </a>
<a name="ln1266">  template&lt;typename _ITp&gt;</a>
<a name="ln1267">    inline _ITp</a>
<a name="ln1268">    atomic_fetch_xor_explicit(volatile __atomic_base&lt;_ITp&gt;* __a, _ITp __i,</a>
<a name="ln1269">			      memory_order __m) noexcept</a>
<a name="ln1270">    { return __a-&gt;fetch_xor(__i, __m); }</a>
<a name="ln1271"> </a>
<a name="ln1272">  template&lt;typename _ITp&gt;</a>
<a name="ln1273">    inline _ITp</a>
<a name="ln1274">    atomic_fetch_add(__atomic_base&lt;_ITp&gt;* __a, _ITp __i) noexcept</a>
<a name="ln1275">    { return atomic_fetch_add_explicit(__a, __i, memory_order_seq_cst); }</a>
<a name="ln1276"> </a>
<a name="ln1277">  template&lt;typename _ITp&gt;</a>
<a name="ln1278">    inline _ITp</a>
<a name="ln1279">    atomic_fetch_add(volatile __atomic_base&lt;_ITp&gt;* __a, _ITp __i) noexcept</a>
<a name="ln1280">    { return atomic_fetch_add_explicit(__a, __i, memory_order_seq_cst); }</a>
<a name="ln1281"> </a>
<a name="ln1282">  template&lt;typename _ITp&gt;</a>
<a name="ln1283">    inline _ITp</a>
<a name="ln1284">    atomic_fetch_sub(__atomic_base&lt;_ITp&gt;* __a, _ITp __i) noexcept</a>
<a name="ln1285">    { return atomic_fetch_sub_explicit(__a, __i, memory_order_seq_cst); }</a>
<a name="ln1286"> </a>
<a name="ln1287">  template&lt;typename _ITp&gt;</a>
<a name="ln1288">    inline _ITp</a>
<a name="ln1289">    atomic_fetch_sub(volatile __atomic_base&lt;_ITp&gt;* __a, _ITp __i) noexcept</a>
<a name="ln1290">    { return atomic_fetch_sub_explicit(__a, __i, memory_order_seq_cst); }</a>
<a name="ln1291"> </a>
<a name="ln1292">  template&lt;typename _ITp&gt;</a>
<a name="ln1293">    inline _ITp</a>
<a name="ln1294">    atomic_fetch_and(__atomic_base&lt;_ITp&gt;* __a, _ITp __i) noexcept</a>
<a name="ln1295">    { return atomic_fetch_and_explicit(__a, __i, memory_order_seq_cst); }</a>
<a name="ln1296"> </a>
<a name="ln1297">  template&lt;typename _ITp&gt;</a>
<a name="ln1298">    inline _ITp</a>
<a name="ln1299">    atomic_fetch_and(volatile __atomic_base&lt;_ITp&gt;* __a, _ITp __i) noexcept</a>
<a name="ln1300">    { return atomic_fetch_and_explicit(__a, __i, memory_order_seq_cst); }</a>
<a name="ln1301"> </a>
<a name="ln1302">  template&lt;typename _ITp&gt;</a>
<a name="ln1303">    inline _ITp</a>
<a name="ln1304">    atomic_fetch_or(__atomic_base&lt;_ITp&gt;* __a, _ITp __i) noexcept</a>
<a name="ln1305">    { return atomic_fetch_or_explicit(__a, __i, memory_order_seq_cst); }</a>
<a name="ln1306"> </a>
<a name="ln1307">  template&lt;typename _ITp&gt;</a>
<a name="ln1308">    inline _ITp</a>
<a name="ln1309">    atomic_fetch_or(volatile __atomic_base&lt;_ITp&gt;* __a, _ITp __i) noexcept</a>
<a name="ln1310">    { return atomic_fetch_or_explicit(__a, __i, memory_order_seq_cst); }</a>
<a name="ln1311"> </a>
<a name="ln1312">  template&lt;typename _ITp&gt;</a>
<a name="ln1313">    inline _ITp</a>
<a name="ln1314">    atomic_fetch_xor(__atomic_base&lt;_ITp&gt;* __a, _ITp __i) noexcept</a>
<a name="ln1315">    { return atomic_fetch_xor_explicit(__a, __i, memory_order_seq_cst); }</a>
<a name="ln1316"> </a>
<a name="ln1317">  template&lt;typename _ITp&gt;</a>
<a name="ln1318">    inline _ITp</a>
<a name="ln1319">    atomic_fetch_xor(volatile __atomic_base&lt;_ITp&gt;* __a, _ITp __i) noexcept</a>
<a name="ln1320">    { return atomic_fetch_xor_explicit(__a, __i, memory_order_seq_cst); }</a>
<a name="ln1321"> </a>
<a name="ln1322"> </a>
<a name="ln1323">  // Partial specializations for pointers.</a>
<a name="ln1324">  template&lt;typename _ITp&gt;</a>
<a name="ln1325">    inline _ITp*</a>
<a name="ln1326">    atomic_fetch_add_explicit(atomic&lt;_ITp*&gt;* __a, ptrdiff_t __d,</a>
<a name="ln1327">			      memory_order __m) noexcept</a>
<a name="ln1328">    { return __a-&gt;fetch_add(__d, __m); }</a>
<a name="ln1329"> </a>
<a name="ln1330">  template&lt;typename _ITp&gt;</a>
<a name="ln1331">    inline _ITp*</a>
<a name="ln1332">    atomic_fetch_add_explicit(volatile atomic&lt;_ITp*&gt;* __a, ptrdiff_t __d,</a>
<a name="ln1333">			      memory_order __m) noexcept</a>
<a name="ln1334">    { return __a-&gt;fetch_add(__d, __m); }</a>
<a name="ln1335"> </a>
<a name="ln1336">  template&lt;typename _ITp&gt;</a>
<a name="ln1337">    inline _ITp*</a>
<a name="ln1338">    atomic_fetch_add(volatile atomic&lt;_ITp*&gt;* __a, ptrdiff_t __d) noexcept</a>
<a name="ln1339">    { return __a-&gt;fetch_add(__d); }</a>
<a name="ln1340"> </a>
<a name="ln1341">  template&lt;typename _ITp&gt;</a>
<a name="ln1342">    inline _ITp*</a>
<a name="ln1343">    atomic_fetch_add(atomic&lt;_ITp*&gt;* __a, ptrdiff_t __d) noexcept</a>
<a name="ln1344">    { return __a-&gt;fetch_add(__d); }</a>
<a name="ln1345"> </a>
<a name="ln1346">  template&lt;typename _ITp&gt;</a>
<a name="ln1347">    inline _ITp*</a>
<a name="ln1348">    atomic_fetch_sub_explicit(volatile atomic&lt;_ITp*&gt;* __a,</a>
<a name="ln1349">			      ptrdiff_t __d, memory_order __m) noexcept</a>
<a name="ln1350">    { return __a-&gt;fetch_sub(__d, __m); }</a>
<a name="ln1351"> </a>
<a name="ln1352">  template&lt;typename _ITp&gt;</a>
<a name="ln1353">    inline _ITp*</a>
<a name="ln1354">    atomic_fetch_sub_explicit(atomic&lt;_ITp*&gt;* __a, ptrdiff_t __d,</a>
<a name="ln1355">			      memory_order __m) noexcept</a>
<a name="ln1356">    { return __a-&gt;fetch_sub(__d, __m); }</a>
<a name="ln1357"> </a>
<a name="ln1358">  template&lt;typename _ITp&gt;</a>
<a name="ln1359">    inline _ITp*</a>
<a name="ln1360">    atomic_fetch_sub(volatile atomic&lt;_ITp*&gt;* __a, ptrdiff_t __d) noexcept</a>
<a name="ln1361">    { return __a-&gt;fetch_sub(__d); }</a>
<a name="ln1362"> </a>
<a name="ln1363">  template&lt;typename _ITp&gt;</a>
<a name="ln1364">    inline _ITp*</a>
<a name="ln1365">    atomic_fetch_sub(atomic&lt;_ITp*&gt;* __a, ptrdiff_t __d) noexcept</a>
<a name="ln1366">    { return __a-&gt;fetch_sub(__d); }</a>
<a name="ln1367">  // @} group atomics</a>
<a name="ln1368"> </a>
<a name="ln1369">_GLIBCXX_END_NAMESPACE_VERSION</a>
<a name="ln1370">} // namespace</a>
<a name="ln1371"> </a>
<a name="ln1372">#endif // C++11</a>
<a name="ln1373"> </a>
<a name="ln1374">#endif // _GLIBCXX_ATOMIC</a>

</code></pre>
<div class="balloon" rel="210"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v790/" target="_blank">V790</a> It is odd that the assignment operator takes an object by a non-constant reference and returns this object.</p></div>
<div class="balloon" rel="214"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v790/" target="_blank">V790</a> It is odd that the assignment operator takes an object by a non-constant reference and returns this object.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
