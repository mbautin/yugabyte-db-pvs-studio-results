
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>buffer.hpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//</a>
<a name="ln2">// buffer.hpp</a>
<a name="ln3">// ~~~~~~~~~~</a>
<a name="ln4">//</a>
<a name="ln5">// Copyright (c) 2003-2018 Christopher M. Kohlhoff (chris at kohlhoff dot com)</a>
<a name="ln6">//</a>
<a name="ln7">// Distributed under the Boost Software License, Version 1.0. (See accompanying</a>
<a name="ln8">// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)</a>
<a name="ln9">//</a>
<a name="ln10"> </a>
<a name="ln11">#ifndef BOOST_ASIO_BUFFER_HPP</a>
<a name="ln12">#define BOOST_ASIO_BUFFER_HPP</a>
<a name="ln13"> </a>
<a name="ln14">#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1200)</a>
<a name="ln15"># pragma once</a>
<a name="ln16">#endif // defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1200)</a>
<a name="ln17"> </a>
<a name="ln18">#include &lt;boost/asio/detail/config.hpp&gt;</a>
<a name="ln19">#include &lt;cstddef&gt;</a>
<a name="ln20">#include &lt;cstring&gt;</a>
<a name="ln21">#include &lt;limits&gt;</a>
<a name="ln22">#include &lt;stdexcept&gt;</a>
<a name="ln23">#include &lt;string&gt;</a>
<a name="ln24">#include &lt;vector&gt;</a>
<a name="ln25">#include &lt;boost/asio/detail/array_fwd.hpp&gt;</a>
<a name="ln26">#include &lt;boost/asio/detail/string_view.hpp&gt;</a>
<a name="ln27">#include &lt;boost/asio/detail/throw_exception.hpp&gt;</a>
<a name="ln28">#include &lt;boost/asio/detail/type_traits.hpp&gt;</a>
<a name="ln29"> </a>
<a name="ln30">#if defined(BOOST_ASIO_MSVC) &amp;&amp; (BOOST_ASIO_MSVC &gt;= 1700)</a>
<a name="ln31"># if defined(_HAS_ITERATOR_DEBUGGING) &amp;&amp; (_HAS_ITERATOR_DEBUGGING != 0)</a>
<a name="ln32">#  if !defined(BOOST_ASIO_DISABLE_BUFFER_DEBUGGING)</a>
<a name="ln33">#   define BOOST_ASIO_ENABLE_BUFFER_DEBUGGING</a>
<a name="ln34">#  endif // !defined(BOOST_ASIO_DISABLE_BUFFER_DEBUGGING)</a>
<a name="ln35"># endif // defined(_HAS_ITERATOR_DEBUGGING)</a>
<a name="ln36">#endif // defined(BOOST_ASIO_MSVC) &amp;&amp; (BOOST_ASIO_MSVC &gt;= 1700)</a>
<a name="ln37"> </a>
<a name="ln38">#if defined(__GNUC__)</a>
<a name="ln39"># if defined(_GLIBCXX_DEBUG)</a>
<a name="ln40">#  if !defined(BOOST_ASIO_DISABLE_BUFFER_DEBUGGING)</a>
<a name="ln41">#   define BOOST_ASIO_ENABLE_BUFFER_DEBUGGING</a>
<a name="ln42">#  endif // !defined(BOOST_ASIO_DISABLE_BUFFER_DEBUGGING)</a>
<a name="ln43"># endif // defined(_GLIBCXX_DEBUG)</a>
<a name="ln44">#endif // defined(__GNUC__)</a>
<a name="ln45"> </a>
<a name="ln46">#if defined(BOOST_ASIO_ENABLE_BUFFER_DEBUGGING)</a>
<a name="ln47"># include &lt;boost/asio/detail/functional.hpp&gt;</a>
<a name="ln48">#endif // BOOST_ASIO_ENABLE_BUFFER_DEBUGGING</a>
<a name="ln49"> </a>
<a name="ln50">#if defined(BOOST_ASIO_HAS_BOOST_WORKAROUND)</a>
<a name="ln51"># include &lt;boost/detail/workaround.hpp&gt;</a>
<a name="ln52"># if BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x582)) \</a>
<a name="ln53">    || BOOST_WORKAROUND(__SUNPRO_CC, BOOST_TESTED_AT(0x590))</a>
<a name="ln54">#  define BOOST_ASIO_ENABLE_ARRAY_BUFFER_WORKAROUND</a>
<a name="ln55"># endif // BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x582))</a>
<a name="ln56">        // || BOOST_WORKAROUND(__SUNPRO_CC, BOOST_TESTED_AT(0x590))</a>
<a name="ln57">#endif // defined(BOOST_ASIO_HAS_BOOST_WORKAROUND)</a>
<a name="ln58"> </a>
<a name="ln59">#if defined(BOOST_ASIO_ENABLE_ARRAY_BUFFER_WORKAROUND)</a>
<a name="ln60"># include &lt;boost/asio/detail/type_traits.hpp&gt;</a>
<a name="ln61">#endif // defined(BOOST_ASIO_ENABLE_ARRAY_BUFFER_WORKAROUND)</a>
<a name="ln62"> </a>
<a name="ln63">#include &lt;boost/asio/detail/push_options.hpp&gt;</a>
<a name="ln64"> </a>
<a name="ln65">namespace boost {</a>
<a name="ln66">namespace asio {</a>
<a name="ln67"> </a>
<a name="ln68">class mutable_buffer;</a>
<a name="ln69">class const_buffer;</a>
<a name="ln70"> </a>
<a name="ln71">/// Holds a buffer that can be modified.</a>
<a name="ln72">/**</a>
<a name="ln73"> * The mutable_buffer class provides a safe representation of a buffer that can</a>
<a name="ln74"> * be modified. It does not own the underlying data, and so is cheap to copy or</a>
<a name="ln75"> * assign.</a>
<a name="ln76"> *</a>
<a name="ln77"> * @par Accessing Buffer Contents</a>
<a name="ln78"> *</a>
<a name="ln79"> * The contents of a buffer may be accessed using the @c data() and @c size()</a>
<a name="ln80"> * member functions:</a>
<a name="ln81"> *</a>
<a name="ln82"> * @code boost::asio::mutable_buffer b1 = ...;</a>
<a name="ln83"> * std::size_t s1 = b1.size();</a>
<a name="ln84"> * unsigned char* p1 = static_cast&lt;unsigned char*&gt;(b1.data());</a>
<a name="ln85"> * @endcode</a>
<a name="ln86"> *</a>
<a name="ln87"> * The @c data() member function permits violations of type safety, so uses of</a>
<a name="ln88"> * it in application code should be carefully considered.</a>
<a name="ln89"> */</a>
<a name="ln90">class mutable_buffer</a>
<a name="ln91">{</a>
<a name="ln92">public:</a>
<a name="ln93">  /// Construct an empty buffer.</a>
<a name="ln94">  mutable_buffer() BOOST_ASIO_NOEXCEPT</a>
<a name="ln95">    : data_(0),</a>
<a name="ln96">      size_(0)</a>
<a name="ln97">  {</a>
<a name="ln98">  }</a>
<a name="ln99"> </a>
<a name="ln100">  /// Construct a buffer to represent a given memory range.</a>
<a name="ln101">  mutable_buffer(void* data, std::size_t size) BOOST_ASIO_NOEXCEPT</a>
<a name="ln102">    : data_(data),</a>
<a name="ln103">      size_(size)</a>
<a name="ln104">  {</a>
<a name="ln105">  }</a>
<a name="ln106"> </a>
<a name="ln107">#if defined(BOOST_ASIO_ENABLE_BUFFER_DEBUGGING)</a>
<a name="ln108">  mutable_buffer(void* data, std::size_t size,</a>
<a name="ln109">      boost::asio::detail::function&lt;void()&gt; debug_check)</a>
<a name="ln110">    : data_(data),</a>
<a name="ln111">      size_(size),</a>
<a name="ln112">      debug_check_(debug_check)</a>
<a name="ln113">  {</a>
<a name="ln114">  }</a>
<a name="ln115"> </a>
<a name="ln116">  const boost::asio::detail::function&lt;void()&gt;&amp; get_debug_check() const</a>
<a name="ln117">  {</a>
<a name="ln118">    return debug_check_;</a>
<a name="ln119">  }</a>
<a name="ln120">#endif // BOOST_ASIO_ENABLE_BUFFER_DEBUGGING</a>
<a name="ln121"> </a>
<a name="ln122">  /// Get a pointer to the beginning of the memory range.</a>
<a name="ln123">  void* data() const BOOST_ASIO_NOEXCEPT</a>
<a name="ln124">  {</a>
<a name="ln125">#if defined(BOOST_ASIO_ENABLE_BUFFER_DEBUGGING)</a>
<a name="ln126">    if (size_ &amp;&amp; debug_check_)</a>
<a name="ln127">      debug_check_();</a>
<a name="ln128">#endif // BOOST_ASIO_ENABLE_BUFFER_DEBUGGING</a>
<a name="ln129">    return data_;</a>
<a name="ln130">  }</a>
<a name="ln131"> </a>
<a name="ln132">  /// Get the size of the memory range.</a>
<a name="ln133">  std::size_t size() const BOOST_ASIO_NOEXCEPT</a>
<a name="ln134">  {</a>
<a name="ln135">    return size_;</a>
<a name="ln136">  }</a>
<a name="ln137"> </a>
<a name="ln138">  /// Move the start of the buffer by the specified number of bytes.</a>
<a name="ln139">  mutable_buffer&amp; operator+=(std::size_t n) BOOST_ASIO_NOEXCEPT</a>
<a name="ln140">  {</a>
<a name="ln141">    std::size_t offset = n &lt; size_ ? n : size_;</a>
<a name="ln142">    data_ = static_cast&lt;char*&gt;(data_) + offset;</a>
<a name="ln143">    size_ -= offset;</a>
<a name="ln144">    return *this;</a>
<a name="ln145">  }</a>
<a name="ln146"> </a>
<a name="ln147">private:</a>
<a name="ln148">  void* data_;</a>
<a name="ln149">  std::size_t size_;</a>
<a name="ln150"> </a>
<a name="ln151">#if defined(BOOST_ASIO_ENABLE_BUFFER_DEBUGGING)</a>
<a name="ln152">  boost::asio::detail::function&lt;void()&gt; debug_check_;</a>
<a name="ln153">#endif // BOOST_ASIO_ENABLE_BUFFER_DEBUGGING</a>
<a name="ln154">};</a>
<a name="ln155"> </a>
<a name="ln156">#if !defined(BOOST_ASIO_NO_DEPRECATED)</a>
<a name="ln157"> </a>
<a name="ln158">/// (Deprecated: Use mutable_buffer.) Adapts a single modifiable buffer so that</a>
<a name="ln159">/// it meets the requirements of the MutableBufferSequence concept.</a>
<a name="ln160">class mutable_buffers_1</a>
<a name="ln161">  : public mutable_buffer</a>
<a name="ln162">{</a>
<a name="ln163">public:</a>
<a name="ln164">  /// The type for each element in the list of buffers.</a>
<a name="ln165">  typedef mutable_buffer value_type;</a>
<a name="ln166"> </a>
<a name="ln167">  /// A random-access iterator type that may be used to read elements.</a>
<a name="ln168">  typedef const mutable_buffer* const_iterator;</a>
<a name="ln169"> </a>
<a name="ln170">  /// Construct to represent a given memory range.</a>
<a name="ln171">  mutable_buffers_1(void* data, std::size_t size) BOOST_ASIO_NOEXCEPT</a>
<a name="ln172">    : mutable_buffer(data, size)</a>
<a name="ln173">  {</a>
<a name="ln174">  }</a>
<a name="ln175"> </a>
<a name="ln176">#if defined(BOOST_ASIO_ENABLE_BUFFER_DEBUGGING)</a>
<a name="ln177">  mutable_buffers_1(void* data, std::size_t size,</a>
<a name="ln178">      boost::asio::detail::function&lt;void()&gt; debug_check)</a>
<a name="ln179">    : mutable_buffer(data, size, debug_check)</a>
<a name="ln180">  {</a>
<a name="ln181">  }</a>
<a name="ln182">#endif // BOOST_ASIO_ENABLE_BUFFER_DEBUGGING</a>
<a name="ln183"> </a>
<a name="ln184">  /// Construct to represent a single modifiable buffer.</a>
<a name="ln185">  explicit mutable_buffers_1(const mutable_buffer&amp; b) BOOST_ASIO_NOEXCEPT</a>
<a name="ln186">    : mutable_buffer(b)</a>
<a name="ln187">  {</a>
<a name="ln188">  }</a>
<a name="ln189"> </a>
<a name="ln190">  /// Get a random-access iterator to the first element.</a>
<a name="ln191">  const_iterator begin() const BOOST_ASIO_NOEXCEPT</a>
<a name="ln192">  {</a>
<a name="ln193">    return this;</a>
<a name="ln194">  }</a>
<a name="ln195"> </a>
<a name="ln196">  /// Get a random-access iterator for one past the last element.</a>
<a name="ln197">  const_iterator end() const BOOST_ASIO_NOEXCEPT</a>
<a name="ln198">  {</a>
<a name="ln199">    return begin() + 1;</a>
<a name="ln200">  }</a>
<a name="ln201">};</a>
<a name="ln202"> </a>
<a name="ln203">#endif // !defined(BOOST_ASIO_NO_DEPRECATED)</a>
<a name="ln204"> </a>
<a name="ln205">/// Holds a buffer that cannot be modified.</a>
<a name="ln206">/**</a>
<a name="ln207"> * The const_buffer class provides a safe representation of a buffer that cannot</a>
<a name="ln208"> * be modified. It does not own the underlying data, and so is cheap to copy or</a>
<a name="ln209"> * assign.</a>
<a name="ln210"> *</a>
<a name="ln211"> * @par Accessing Buffer Contents</a>
<a name="ln212"> *</a>
<a name="ln213"> * The contents of a buffer may be accessed using the @c data() and @c size()</a>
<a name="ln214"> * member functions:</a>
<a name="ln215"> *</a>
<a name="ln216"> * @code boost::asio::const_buffer b1 = ...;</a>
<a name="ln217"> * std::size_t s1 = b1.size();</a>
<a name="ln218"> * const unsigned char* p1 = static_cast&lt;const unsigned char*&gt;(b1.data());</a>
<a name="ln219"> * @endcode</a>
<a name="ln220"> *</a>
<a name="ln221"> * The @c data() member function permits violations of type safety, so uses of</a>
<a name="ln222"> * it in application code should be carefully considered.</a>
<a name="ln223"> */</a>
<a name="ln224">class const_buffer</a>
<a name="ln225">{</a>
<a name="ln226">public:</a>
<a name="ln227">  /// Construct an empty buffer.</a>
<a name="ln228">  const_buffer() BOOST_ASIO_NOEXCEPT</a>
<a name="ln229">    : data_(0),</a>
<a name="ln230">      size_(0)</a>
<a name="ln231">  {</a>
<a name="ln232">  }</a>
<a name="ln233"> </a>
<a name="ln234">  /// Construct a buffer to represent a given memory range.</a>
<a name="ln235">  const_buffer(const void* data, std::size_t size) BOOST_ASIO_NOEXCEPT</a>
<a name="ln236">    : data_(data),</a>
<a name="ln237">      size_(size)</a>
<a name="ln238">  {</a>
<a name="ln239">  }</a>
<a name="ln240"> </a>
<a name="ln241">  /// Construct a non-modifiable buffer from a modifiable one.</a>
<a name="ln242">  const_buffer(const mutable_buffer&amp; b) BOOST_ASIO_NOEXCEPT</a>
<a name="ln243">    : data_(b.data()),</a>
<a name="ln244">      size_(b.size())</a>
<a name="ln245">#if defined(BOOST_ASIO_ENABLE_BUFFER_DEBUGGING)</a>
<a name="ln246">      , debug_check_(b.get_debug_check())</a>
<a name="ln247">#endif // BOOST_ASIO_ENABLE_BUFFER_DEBUGGING</a>
<a name="ln248">  {</a>
<a name="ln249">  }</a>
<a name="ln250"> </a>
<a name="ln251">#if defined(BOOST_ASIO_ENABLE_BUFFER_DEBUGGING)</a>
<a name="ln252">  const_buffer(const void* data, std::size_t size,</a>
<a name="ln253">      boost::asio::detail::function&lt;void()&gt; debug_check)</a>
<a name="ln254">    : data_(data),</a>
<a name="ln255">      size_(size),</a>
<a name="ln256">      debug_check_(debug_check)</a>
<a name="ln257">  {</a>
<a name="ln258">  }</a>
<a name="ln259"> </a>
<a name="ln260">  const boost::asio::detail::function&lt;void()&gt;&amp; get_debug_check() const</a>
<a name="ln261">  {</a>
<a name="ln262">    return debug_check_;</a>
<a name="ln263">  }</a>
<a name="ln264">#endif // BOOST_ASIO_ENABLE_BUFFER_DEBUGGING</a>
<a name="ln265"> </a>
<a name="ln266">  /// Get a pointer to the beginning of the memory range.</a>
<a name="ln267">  const void* data() const BOOST_ASIO_NOEXCEPT</a>
<a name="ln268">  {</a>
<a name="ln269">#if defined(BOOST_ASIO_ENABLE_BUFFER_DEBUGGING)</a>
<a name="ln270">    if (size_ &amp;&amp; debug_check_)</a>
<a name="ln271">      debug_check_();</a>
<a name="ln272">#endif // BOOST_ASIO_ENABLE_BUFFER_DEBUGGING</a>
<a name="ln273">    return data_;</a>
<a name="ln274">  }</a>
<a name="ln275"> </a>
<a name="ln276">  /// Get the size of the memory range.</a>
<a name="ln277">  std::size_t size() const BOOST_ASIO_NOEXCEPT</a>
<a name="ln278">  {</a>
<a name="ln279">    return size_;</a>
<a name="ln280">  }</a>
<a name="ln281"> </a>
<a name="ln282">  /// Move the start of the buffer by the specified number of bytes.</a>
<a name="ln283">  const_buffer&amp; operator+=(std::size_t n) BOOST_ASIO_NOEXCEPT</a>
<a name="ln284">  {</a>
<a name="ln285">    std::size_t offset = n &lt; size_ ? n : size_;</a>
<a name="ln286">    data_ = static_cast&lt;const char*&gt;(data_) + offset;</a>
<a name="ln287">    size_ -= offset;</a>
<a name="ln288">    return *this;</a>
<a name="ln289">  }</a>
<a name="ln290"> </a>
<a name="ln291">private:</a>
<a name="ln292">  const void* data_;</a>
<a name="ln293">  std::size_t size_;</a>
<a name="ln294"> </a>
<a name="ln295">#if defined(BOOST_ASIO_ENABLE_BUFFER_DEBUGGING)</a>
<a name="ln296">  boost::asio::detail::function&lt;void()&gt; debug_check_;</a>
<a name="ln297">#endif // BOOST_ASIO_ENABLE_BUFFER_DEBUGGING</a>
<a name="ln298">};</a>
<a name="ln299"> </a>
<a name="ln300">#if !defined(BOOST_ASIO_NO_DEPRECATED)</a>
<a name="ln301"> </a>
<a name="ln302">/// (Deprecated: Use const_buffer.) Adapts a single non-modifiable buffer so</a>
<a name="ln303">/// that it meets the requirements of the ConstBufferSequence concept.</a>
<a name="ln304">class const_buffers_1</a>
<a name="ln305">  : public const_buffer</a>
<a name="ln306">{</a>
<a name="ln307">public:</a>
<a name="ln308">  /// The type for each element in the list of buffers.</a>
<a name="ln309">  typedef const_buffer value_type;</a>
<a name="ln310"> </a>
<a name="ln311">  /// A random-access iterator type that may be used to read elements.</a>
<a name="ln312">  typedef const const_buffer* const_iterator;</a>
<a name="ln313"> </a>
<a name="ln314">  /// Construct to represent a given memory range.</a>
<a name="ln315">  const_buffers_1(const void* data, std::size_t size) BOOST_ASIO_NOEXCEPT</a>
<a name="ln316">    : const_buffer(data, size)</a>
<a name="ln317">  {</a>
<a name="ln318">  }</a>
<a name="ln319"> </a>
<a name="ln320">#if defined(BOOST_ASIO_ENABLE_BUFFER_DEBUGGING)</a>
<a name="ln321">  const_buffers_1(const void* data, std::size_t size,</a>
<a name="ln322">      boost::asio::detail::function&lt;void()&gt; debug_check)</a>
<a name="ln323">    : const_buffer(data, size, debug_check)</a>
<a name="ln324">  {</a>
<a name="ln325">  }</a>
<a name="ln326">#endif // BOOST_ASIO_ENABLE_BUFFER_DEBUGGING</a>
<a name="ln327"> </a>
<a name="ln328">  /// Construct to represent a single non-modifiable buffer.</a>
<a name="ln329">  explicit const_buffers_1(const const_buffer&amp; b) BOOST_ASIO_NOEXCEPT</a>
<a name="ln330">    : const_buffer(b)</a>
<a name="ln331">  {</a>
<a name="ln332">  }</a>
<a name="ln333"> </a>
<a name="ln334">  /// Get a random-access iterator to the first element.</a>
<a name="ln335">  const_iterator begin() const BOOST_ASIO_NOEXCEPT</a>
<a name="ln336">  {</a>
<a name="ln337">    return this;</a>
<a name="ln338">  }</a>
<a name="ln339"> </a>
<a name="ln340">  /// Get a random-access iterator for one past the last element.</a>
<a name="ln341">  const_iterator end() const BOOST_ASIO_NOEXCEPT</a>
<a name="ln342">  {</a>
<a name="ln343">    return begin() + 1;</a>
<a name="ln344">  }</a>
<a name="ln345">};</a>
<a name="ln346"> </a>
<a name="ln347">#endif // !defined(BOOST_ASIO_NO_DEPRECATED)</a>
<a name="ln348"> </a>
<a name="ln349">/// (Deprecated: Use the socket/descriptor wait() and async_wait() member</a>
<a name="ln350">/// functions.) An implementation of both the ConstBufferSequence and</a>
<a name="ln351">/// MutableBufferSequence concepts to represent a null buffer sequence.</a>
<a name="ln352">class null_buffers</a>
<a name="ln353">{</a>
<a name="ln354">public:</a>
<a name="ln355">  /// The type for each element in the list of buffers.</a>
<a name="ln356">  typedef mutable_buffer value_type;</a>
<a name="ln357"> </a>
<a name="ln358">  /// A random-access iterator type that may be used to read elements.</a>
<a name="ln359">  typedef const mutable_buffer* const_iterator;</a>
<a name="ln360"> </a>
<a name="ln361">  /// Get a random-access iterator to the first element.</a>
<a name="ln362">  const_iterator begin() const BOOST_ASIO_NOEXCEPT</a>
<a name="ln363">  {</a>
<a name="ln364">    return &amp;buf_;</a>
<a name="ln365">  }</a>
<a name="ln366"> </a>
<a name="ln367">  /// Get a random-access iterator for one past the last element.</a>
<a name="ln368">  const_iterator end() const BOOST_ASIO_NOEXCEPT</a>
<a name="ln369">  {</a>
<a name="ln370">    return &amp;buf_;</a>
<a name="ln371">  }</a>
<a name="ln372"> </a>
<a name="ln373">private:</a>
<a name="ln374">  mutable_buffer buf_;</a>
<a name="ln375">};</a>
<a name="ln376"> </a>
<a name="ln377">/** @defgroup buffer_sequence_begin boost::asio::buffer_sequence_begin</a>
<a name="ln378"> *</a>
<a name="ln379"> * @brief The boost::asio::buffer_sequence_begin function returns an iterator</a>
<a name="ln380"> * pointing to the first element in a buffer sequence.</a>
<a name="ln381"> */</a>
<a name="ln382">/*@{*/</a>
<a name="ln383"> </a>
<a name="ln384">/// Get an iterator to the first element in a buffer sequence.</a>
<a name="ln385">inline const mutable_buffer* buffer_sequence_begin(const mutable_buffer&amp; b)</a>
<a name="ln386">{</a>
<a name="ln387">  return &amp;b;</a>
<a name="ln388">}</a>
<a name="ln389"> </a>
<a name="ln390">/// Get an iterator to the first element in a buffer sequence.</a>
<a name="ln391">inline const const_buffer* buffer_sequence_begin(const const_buffer&amp; b)</a>
<a name="ln392">{</a>
<a name="ln393">  return &amp;b;</a>
<a name="ln394">}</a>
<a name="ln395"> </a>
<a name="ln396">#if defined(BOOST_ASIO_HAS_DECLTYPE) || defined(GENERATING_DOCUMENTATION)</a>
<a name="ln397"> </a>
<a name="ln398">/// Get an iterator to the first element in a buffer sequence.</a>
<a name="ln399">template &lt;typename C&gt;</a>
<a name="ln400">inline auto buffer_sequence_begin(C&amp; c) -&gt; decltype(c.begin())</a>
<a name="ln401">{</a>
<a name="ln402">  return c.begin();</a>
<a name="ln403">}</a>
<a name="ln404"> </a>
<a name="ln405">/// Get an iterator to the first element in a buffer sequence.</a>
<a name="ln406">template &lt;typename C&gt;</a>
<a name="ln407">inline auto buffer_sequence_begin(const C&amp; c) -&gt; decltype(c.begin())</a>
<a name="ln408">{</a>
<a name="ln409">  return c.begin();</a>
<a name="ln410">}</a>
<a name="ln411"> </a>
<a name="ln412">#else // defined(BOOST_ASIO_HAS_DECLTYPE) || defined(GENERATING_DOCUMENTATION)</a>
<a name="ln413"> </a>
<a name="ln414">template &lt;typename C&gt;</a>
<a name="ln415">inline typename C::iterator buffer_sequence_begin(C&amp; c)</a>
<a name="ln416">{</a>
<a name="ln417">  return c.begin();</a>
<a name="ln418">}</a>
<a name="ln419"> </a>
<a name="ln420">template &lt;typename C&gt;</a>
<a name="ln421">inline typename C::const_iterator buffer_sequence_begin(const C&amp; c)</a>
<a name="ln422">{</a>
<a name="ln423">  return c.begin();</a>
<a name="ln424">}</a>
<a name="ln425"> </a>
<a name="ln426">#endif // defined(BOOST_ASIO_HAS_DECLTYPE) || defined(GENERATING_DOCUMENTATION)</a>
<a name="ln427"> </a>
<a name="ln428">/*@}*/</a>
<a name="ln429"> </a>
<a name="ln430">/** @defgroup buffer_sequence_end boost::asio::buffer_sequence_end</a>
<a name="ln431"> *</a>
<a name="ln432"> * @brief The boost::asio::buffer_sequence_end function returns an iterator</a>
<a name="ln433"> * pointing to one past the end element in a buffer sequence.</a>
<a name="ln434"> */</a>
<a name="ln435">/*@{*/</a>
<a name="ln436"> </a>
<a name="ln437">/// Get an iterator to one past the end element in a buffer sequence.</a>
<a name="ln438">inline const mutable_buffer* buffer_sequence_end(const mutable_buffer&amp; b)</a>
<a name="ln439">{</a>
<a name="ln440">  return &amp;b + 1;</a>
<a name="ln441">}</a>
<a name="ln442"> </a>
<a name="ln443">/// Get an iterator to one past the end element in a buffer sequence.</a>
<a name="ln444">inline const const_buffer* buffer_sequence_end(const const_buffer&amp; b)</a>
<a name="ln445">{</a>
<a name="ln446">  return &amp;b + 1;</a>
<a name="ln447">}</a>
<a name="ln448"> </a>
<a name="ln449">#if defined(BOOST_ASIO_HAS_DECLTYPE) || defined(GENERATING_DOCUMENTATION)</a>
<a name="ln450"> </a>
<a name="ln451">/// Get an iterator to one past the end element in a buffer sequence.</a>
<a name="ln452">template &lt;typename C&gt;</a>
<a name="ln453">inline auto buffer_sequence_end(C&amp; c) -&gt; decltype(c.end())</a>
<a name="ln454">{</a>
<a name="ln455">  return c.end();</a>
<a name="ln456">}</a>
<a name="ln457"> </a>
<a name="ln458">/// Get an iterator to one past the end element in a buffer sequence.</a>
<a name="ln459">template &lt;typename C&gt;</a>
<a name="ln460">inline auto buffer_sequence_end(const C&amp; c) -&gt; decltype(c.end())</a>
<a name="ln461">{</a>
<a name="ln462">  return c.end();</a>
<a name="ln463">}</a>
<a name="ln464"> </a>
<a name="ln465">#else // defined(BOOST_ASIO_HAS_DECLTYPE) || defined(GENERATING_DOCUMENTATION)</a>
<a name="ln466"> </a>
<a name="ln467">template &lt;typename C&gt;</a>
<a name="ln468">inline typename C::iterator buffer_sequence_end(C&amp; c)</a>
<a name="ln469">{</a>
<a name="ln470">  return c.end();</a>
<a name="ln471">}</a>
<a name="ln472"> </a>
<a name="ln473">template &lt;typename C&gt;</a>
<a name="ln474">inline typename C::const_iterator buffer_sequence_end(const C&amp; c)</a>
<a name="ln475">{</a>
<a name="ln476">  return c.end();</a>
<a name="ln477">}</a>
<a name="ln478"> </a>
<a name="ln479">#endif // defined(BOOST_ASIO_HAS_DECLTYPE) || defined(GENERATING_DOCUMENTATION)</a>
<a name="ln480"> </a>
<a name="ln481">/*@}*/</a>
<a name="ln482"> </a>
<a name="ln483">namespace detail {</a>
<a name="ln484"> </a>
<a name="ln485">// Tag types used to select appropriately optimised overloads.</a>
<a name="ln486">struct one_buffer {};</a>
<a name="ln487">struct multiple_buffers {};</a>
<a name="ln488"> </a>
<a name="ln489">// Helper trait to detect single buffers.</a>
<a name="ln490">template &lt;typename BufferSequence&gt;</a>
<a name="ln491">struct buffer_sequence_cardinality :</a>
<a name="ln492">  conditional&lt;</a>
<a name="ln493">    is_same&lt;BufferSequence, mutable_buffer&gt;::value</a>
<a name="ln494">#if !defined(BOOST_ASIO_NO_DEPRECATED)</a>
<a name="ln495">      || is_same&lt;BufferSequence, mutable_buffers_1&gt;::value</a>
<a name="ln496">      || is_same&lt;BufferSequence, const_buffers_1&gt;::value</a>
<a name="ln497">#endif // !defined(BOOST_ASIO_NO_DEPRECATED)</a>
<a name="ln498">      || is_same&lt;BufferSequence, const_buffer&gt;::value,</a>
<a name="ln499">    one_buffer, multiple_buffers&gt;::type {};</a>
<a name="ln500"> </a>
<a name="ln501">template &lt;typename Iterator&gt;</a>
<a name="ln502">inline std::size_t buffer_size(one_buffer,</a>
<a name="ln503">    Iterator begin, Iterator) BOOST_ASIO_NOEXCEPT</a>
<a name="ln504">{</a>
<a name="ln505">  return const_buffer(*begin).size();</a>
<a name="ln506">}</a>
<a name="ln507"> </a>
<a name="ln508">template &lt;typename Iterator&gt;</a>
<a name="ln509">inline std::size_t buffer_size(multiple_buffers,</a>
<a name="ln510">    Iterator begin, Iterator end) BOOST_ASIO_NOEXCEPT</a>
<a name="ln511">{</a>
<a name="ln512">  std::size_t total_buffer_size = 0;</a>
<a name="ln513"> </a>
<a name="ln514">  Iterator iter = begin;</a>
<a name="ln515">  for (; iter != end; ++iter)</a>
<a name="ln516">  {</a>
<a name="ln517">    const_buffer b(*iter);</a>
<a name="ln518">    total_buffer_size += b.size();</a>
<a name="ln519">  }</a>
<a name="ln520"> </a>
<a name="ln521">  return total_buffer_size;</a>
<a name="ln522">}</a>
<a name="ln523"> </a>
<a name="ln524">} // namespace detail</a>
<a name="ln525"> </a>
<a name="ln526">/// Get the total number of bytes in a buffer sequence.</a>
<a name="ln527">/**</a>
<a name="ln528"> * The @c buffer_size function determines the total size of all buffers in the</a>
<a name="ln529"> * buffer sequence, as if computed as follows:</a>
<a name="ln530"> *</a>
<a name="ln531"> * @code size_t total_size = 0;</a>
<a name="ln532"> * auto i = boost::asio::buffer_sequence_begin(buffers);</a>
<a name="ln533"> * auto end = boost::asio::buffer_sequence_end(buffers);</a>
<a name="ln534"> * for (; i != end; ++i)</a>
<a name="ln535"> * {</a>
<a name="ln536"> *   const_buffer b(*i);</a>
<a name="ln537"> *   total_size += b.size();</a>
<a name="ln538"> * }</a>
<a name="ln539"> * return total_size; @endcode</a>
<a name="ln540"> *</a>
<a name="ln541"> * The @c BufferSequence template parameter may meet either of the @c</a>
<a name="ln542"> * ConstBufferSequence or @c MutableBufferSequence type requirements.</a>
<a name="ln543"> */</a>
<a name="ln544">template &lt;typename BufferSequence&gt;</a>
<a name="ln545">inline std::size_t buffer_size(const BufferSequence&amp; b) BOOST_ASIO_NOEXCEPT</a>
<a name="ln546">{</a>
<a name="ln547">  return detail::buffer_size(</a>
<a name="ln548">      detail::buffer_sequence_cardinality&lt;BufferSequence&gt;(),</a>
<a name="ln549">      boost::asio::buffer_sequence_begin(b),</a>
<a name="ln550">      boost::asio::buffer_sequence_end(b));</a>
<a name="ln551">}</a>
<a name="ln552"> </a>
<a name="ln553">#if !defined(BOOST_ASIO_NO_DEPRECATED)</a>
<a name="ln554"> </a>
<a name="ln555">/** @defgroup buffer_cast boost::asio::buffer_cast</a>
<a name="ln556"> *</a>
<a name="ln557"> * @brief (Deprecated: Use the @c data() member function.) The</a>
<a name="ln558"> * boost::asio::buffer_cast function is used to obtain a pointer to the</a>
<a name="ln559"> * underlying memory region associated with a buffer.</a>
<a name="ln560"> *</a>
<a name="ln561"> * @par Examples:</a>
<a name="ln562"> *</a>
<a name="ln563"> * To access the memory of a non-modifiable buffer, use:</a>
<a name="ln564"> * @code boost::asio::const_buffer b1 = ...;</a>
<a name="ln565"> * const unsigned char* p1 = boost::asio::buffer_cast&lt;const unsigned char*&gt;(b1);</a>
<a name="ln566"> * @endcode</a>
<a name="ln567"> *</a>
<a name="ln568"> * To access the memory of a modifiable buffer, use:</a>
<a name="ln569"> * @code boost::asio::mutable_buffer b2 = ...;</a>
<a name="ln570"> * unsigned char* p2 = boost::asio::buffer_cast&lt;unsigned char*&gt;(b2);</a>
<a name="ln571"> * @endcode</a>
<a name="ln572"> *</a>
<a name="ln573"> * The boost::asio::buffer_cast function permits violations of type safety, so</a>
<a name="ln574"> * uses of it in application code should be carefully considered.</a>
<a name="ln575"> */</a>
<a name="ln576">/*@{*/</a>
<a name="ln577"> </a>
<a name="ln578">/// Cast a non-modifiable buffer to a specified pointer to POD type.</a>
<a name="ln579">template &lt;typename PointerToPodType&gt;</a>
<a name="ln580">inline PointerToPodType buffer_cast(const mutable_buffer&amp; b) BOOST_ASIO_NOEXCEPT</a>
<a name="ln581">{</a>
<a name="ln582">  return static_cast&lt;PointerToPodType&gt;(b.data());</a>
<a name="ln583">}</a>
<a name="ln584"> </a>
<a name="ln585">/// Cast a non-modifiable buffer to a specified pointer to POD type.</a>
<a name="ln586">template &lt;typename PointerToPodType&gt;</a>
<a name="ln587">inline PointerToPodType buffer_cast(const const_buffer&amp; b) BOOST_ASIO_NOEXCEPT</a>
<a name="ln588">{</a>
<a name="ln589">  return static_cast&lt;PointerToPodType&gt;(b.data());</a>
<a name="ln590">}</a>
<a name="ln591"> </a>
<a name="ln592">/*@}*/</a>
<a name="ln593"> </a>
<a name="ln594">#endif // !defined(BOOST_ASIO_NO_DEPRECATED)</a>
<a name="ln595"> </a>
<a name="ln596">/// Create a new modifiable buffer that is offset from the start of another.</a>
<a name="ln597">/**</a>
<a name="ln598"> * @relates mutable_buffer</a>
<a name="ln599"> */</a>
<a name="ln600">inline mutable_buffer operator+(const mutable_buffer&amp; b,</a>
<a name="ln601">    std::size_t n) BOOST_ASIO_NOEXCEPT</a>
<a name="ln602">{</a>
<a name="ln603">  std::size_t offset = n &lt; b.size() ? n : b.size();</a>
<a name="ln604">  char* new_data = static_cast&lt;char*&gt;(b.data()) + offset;</a>
<a name="ln605">  std::size_t new_size = b.size() - offset;</a>
<a name="ln606">  return mutable_buffer(new_data, new_size</a>
<a name="ln607">#if defined(BOOST_ASIO_ENABLE_BUFFER_DEBUGGING)</a>
<a name="ln608">      , b.get_debug_check()</a>
<a name="ln609">#endif // BOOST_ASIO_ENABLE_BUFFER_DEBUGGING</a>
<a name="ln610">      );</a>
<a name="ln611">}</a>
<a name="ln612"> </a>
<a name="ln613">/// Create a new modifiable buffer that is offset from the start of another.</a>
<a name="ln614">/**</a>
<a name="ln615"> * @relates mutable_buffer</a>
<a name="ln616"> */</a>
<a name="ln617">inline mutable_buffer operator+(std::size_t n,</a>
<a name="ln618">    const mutable_buffer&amp; b) BOOST_ASIO_NOEXCEPT</a>
<a name="ln619">{</a>
<a name="ln620">  return b + n;</a>
<a name="ln621">}</a>
<a name="ln622"> </a>
<a name="ln623">/// Create a new non-modifiable buffer that is offset from the start of another.</a>
<a name="ln624">/**</a>
<a name="ln625"> * @relates const_buffer</a>
<a name="ln626"> */</a>
<a name="ln627">inline const_buffer operator+(const const_buffer&amp; b,</a>
<a name="ln628">    std::size_t n) BOOST_ASIO_NOEXCEPT</a>
<a name="ln629">{</a>
<a name="ln630">  std::size_t offset = n &lt; b.size() ? n : b.size();</a>
<a name="ln631">  const char* new_data = static_cast&lt;const char*&gt;(b.data()) + offset;</a>
<a name="ln632">  std::size_t new_size = b.size() - offset;</a>
<a name="ln633">  return const_buffer(new_data, new_size</a>
<a name="ln634">#if defined(BOOST_ASIO_ENABLE_BUFFER_DEBUGGING)</a>
<a name="ln635">      , b.get_debug_check()</a>
<a name="ln636">#endif // BOOST_ASIO_ENABLE_BUFFER_DEBUGGING</a>
<a name="ln637">      );</a>
<a name="ln638">}</a>
<a name="ln639"> </a>
<a name="ln640">/// Create a new non-modifiable buffer that is offset from the start of another.</a>
<a name="ln641">/**</a>
<a name="ln642"> * @relates const_buffer</a>
<a name="ln643"> */</a>
<a name="ln644">inline const_buffer operator+(std::size_t n,</a>
<a name="ln645">    const const_buffer&amp; b) BOOST_ASIO_NOEXCEPT</a>
<a name="ln646">{</a>
<a name="ln647">  return b + n;</a>
<a name="ln648">}</a>
<a name="ln649"> </a>
<a name="ln650">#if defined(BOOST_ASIO_ENABLE_BUFFER_DEBUGGING)</a>
<a name="ln651">namespace detail {</a>
<a name="ln652"> </a>
<a name="ln653">template &lt;typename Iterator&gt;</a>
<a name="ln654">class buffer_debug_check</a>
<a name="ln655">{</a>
<a name="ln656">public:</a>
<a name="ln657">  buffer_debug_check(Iterator iter)</a>
<a name="ln658">    : iter_(iter)</a>
<a name="ln659">  {</a>
<a name="ln660">  }</a>
<a name="ln661"> </a>
<a name="ln662">  ~buffer_debug_check()</a>
<a name="ln663">  {</a>
<a name="ln664">#if defined(BOOST_ASIO_MSVC) &amp;&amp; (BOOST_ASIO_MSVC == 1400)</a>
<a name="ln665">    // MSVC 8's string iterator checking may crash in a std::string::iterator</a>
<a name="ln666">    // object's destructor when the iterator points to an already-destroyed</a>
<a name="ln667">    // std::string object, unless the iterator is cleared first.</a>
<a name="ln668">    iter_ = Iterator();</a>
<a name="ln669">#endif // defined(BOOST_ASIO_MSVC) &amp;&amp; (BOOST_ASIO_MSVC == 1400)</a>
<a name="ln670">  }</a>
<a name="ln671"> </a>
<a name="ln672">  void operator()()</a>
<a name="ln673">  {</a>
<a name="ln674">    (void)*iter_;</a>
<a name="ln675">  }</a>
<a name="ln676"> </a>
<a name="ln677">private:</a>
<a name="ln678">  Iterator iter_;</a>
<a name="ln679">};</a>
<a name="ln680"> </a>
<a name="ln681">} // namespace detail</a>
<a name="ln682">#endif // BOOST_ASIO_ENABLE_BUFFER_DEBUGGING</a>
<a name="ln683"> </a>
<a name="ln684">/** @defgroup buffer boost::asio::buffer</a>
<a name="ln685"> *</a>
<a name="ln686"> * @brief The boost::asio::buffer function is used to create a buffer object to</a>
<a name="ln687"> * represent raw memory, an array of POD elements, a vector of POD elements,</a>
<a name="ln688"> * or a std::string.</a>
<a name="ln689"> *</a>
<a name="ln690"> * A buffer object represents a contiguous region of memory as a 2-tuple</a>
<a name="ln691"> * consisting of a pointer and size in bytes. A tuple of the form &lt;tt&gt;{void*,</a>
<a name="ln692"> * size_t}&lt;/tt&gt; specifies a mutable (modifiable) region of memory. Similarly, a</a>
<a name="ln693"> * tuple of the form &lt;tt&gt;{const void*, size_t}&lt;/tt&gt; specifies a const</a>
<a name="ln694"> * (non-modifiable) region of memory. These two forms correspond to the classes</a>
<a name="ln695"> * mutable_buffer and const_buffer, respectively. To mirror C++'s conversion</a>
<a name="ln696"> * rules, a mutable_buffer is implicitly convertible to a const_buffer, and the</a>
<a name="ln697"> * opposite conversion is not permitted.</a>
<a name="ln698"> *</a>
<a name="ln699"> * The simplest use case involves reading or writing a single buffer of a</a>
<a name="ln700"> * specified size:</a>
<a name="ln701"> *</a>
<a name="ln702"> * @code sock.send(boost::asio::buffer(data, size)); @endcode</a>
<a name="ln703"> *</a>
<a name="ln704"> * In the above example, the return value of boost::asio::buffer meets the</a>
<a name="ln705"> * requirements of the ConstBufferSequence concept so that it may be directly</a>
<a name="ln706"> * passed to the socket's write function. A buffer created for modifiable</a>
<a name="ln707"> * memory also meets the requirements of the MutableBufferSequence concept.</a>
<a name="ln708"> *</a>
<a name="ln709"> * An individual buffer may be created from a builtin array, std::vector,</a>
<a name="ln710"> * std::array or boost::array of POD elements. This helps prevent buffer</a>
<a name="ln711"> * overruns by automatically determining the size of the buffer:</a>
<a name="ln712"> *</a>
<a name="ln713"> * @code char d1[128];</a>
<a name="ln714"> * size_t bytes_transferred = sock.receive(boost::asio::buffer(d1));</a>
<a name="ln715"> *</a>
<a name="ln716"> * std::vector&lt;char&gt; d2(128);</a>
<a name="ln717"> * bytes_transferred = sock.receive(boost::asio::buffer(d2));</a>
<a name="ln718"> *</a>
<a name="ln719"> * std::array&lt;char, 128&gt; d3;</a>
<a name="ln720"> * bytes_transferred = sock.receive(boost::asio::buffer(d3));</a>
<a name="ln721"> *</a>
<a name="ln722"> * boost::array&lt;char, 128&gt; d4;</a>
<a name="ln723"> * bytes_transferred = sock.receive(boost::asio::buffer(d4)); @endcode</a>
<a name="ln724"> *</a>
<a name="ln725"> * In all three cases above, the buffers created are exactly 128 bytes long.</a>
<a name="ln726"> * Note that a vector is @e never automatically resized when creating or using</a>
<a name="ln727"> * a buffer. The buffer size is determined using the vector's &lt;tt&gt;size()&lt;/tt&gt;</a>
<a name="ln728"> * member function, and not its capacity.</a>
<a name="ln729"> *</a>
<a name="ln730"> * @par Accessing Buffer Contents</a>
<a name="ln731"> *</a>
<a name="ln732"> * The contents of a buffer may be accessed using the @c data() and @c size()</a>
<a name="ln733"> * member functions:</a>
<a name="ln734"> *</a>
<a name="ln735"> * @code boost::asio::mutable_buffer b1 = ...;</a>
<a name="ln736"> * std::size_t s1 = b1.size();</a>
<a name="ln737"> * unsigned char* p1 = static_cast&lt;unsigned char*&gt;(b1.data());</a>
<a name="ln738"> *</a>
<a name="ln739"> * boost::asio::const_buffer b2 = ...;</a>
<a name="ln740"> * std::size_t s2 = b2.size();</a>
<a name="ln741"> * const void* p2 = b2.data(); @endcode</a>
<a name="ln742"> *</a>
<a name="ln743"> * The @c data() member function permits violations of type safety, so</a>
<a name="ln744"> * uses of it in application code should be carefully considered.</a>
<a name="ln745"> *</a>
<a name="ln746"> * For convenience, a @ref buffer_size function is provided that works with</a>
<a name="ln747"> * both buffers and buffer sequences (that is, types meeting the</a>
<a name="ln748"> * ConstBufferSequence or MutableBufferSequence type requirements). In this</a>
<a name="ln749"> * case, the function returns the total size of all buffers in the sequence.</a>
<a name="ln750"> *</a>
<a name="ln751"> * @par Buffer Copying</a>
<a name="ln752"> *</a>
<a name="ln753"> * The @ref buffer_copy function may be used to copy raw bytes between</a>
<a name="ln754"> * individual buffers and buffer sequences.</a>
<a name="ln755">*</a>
<a name="ln756"> * In particular, when used with the @ref buffer_size function, the @ref</a>
<a name="ln757"> * buffer_copy function can be used to linearise a sequence of buffers. For</a>
<a name="ln758"> * example:</a>
<a name="ln759"> *</a>
<a name="ln760"> * @code vector&lt;const_buffer&gt; buffers = ...;</a>
<a name="ln761"> *</a>
<a name="ln762"> * vector&lt;unsigned char&gt; data(boost::asio::buffer_size(buffers));</a>
<a name="ln763"> * boost::asio::buffer_copy(boost::asio::buffer(data), buffers); @endcode</a>
<a name="ln764"> *</a>
<a name="ln765"> * Note that @ref buffer_copy is implemented in terms of @c memcpy, and</a>
<a name="ln766"> * consequently it cannot be used to copy between overlapping memory regions.</a>
<a name="ln767"> *</a>
<a name="ln768"> * @par Buffer Invalidation</a>
<a name="ln769"> *</a>
<a name="ln770"> * A buffer object does not have any ownership of the memory it refers to. It</a>
<a name="ln771"> * is the responsibility of the application to ensure the memory region remains</a>
<a name="ln772"> * valid until it is no longer required for an I/O operation. When the memory</a>
<a name="ln773"> * is no longer available, the buffer is said to have been invalidated.</a>
<a name="ln774"> *</a>
<a name="ln775"> * For the boost::asio::buffer overloads that accept an argument of type</a>
<a name="ln776"> * std::vector, the buffer objects returned are invalidated by any vector</a>
<a name="ln777"> * operation that also invalidates all references, pointers and iterators</a>
<a name="ln778"> * referring to the elements in the sequence (C++ Std, 23.2.4)</a>
<a name="ln779"> *</a>
<a name="ln780"> * For the boost::asio::buffer overloads that accept an argument of type</a>
<a name="ln781"> * std::basic_string, the buffer objects returned are invalidated according to</a>
<a name="ln782"> * the rules defined for invalidation of references, pointers and iterators</a>
<a name="ln783"> * referring to elements of the sequence (C++ Std, 21.3).</a>
<a name="ln784"> *</a>
<a name="ln785"> * @par Buffer Arithmetic</a>
<a name="ln786"> *</a>
<a name="ln787"> * Buffer objects may be manipulated using simple arithmetic in a safe way</a>
<a name="ln788"> * which helps prevent buffer overruns. Consider an array initialised as</a>
<a name="ln789"> * follows:</a>
<a name="ln790"> *</a>
<a name="ln791"> * @code boost::array&lt;char, 6&gt; a = { 'a', 'b', 'c', 'd', 'e' }; @endcode</a>
<a name="ln792"> *</a>
<a name="ln793"> * A buffer object @c b1 created using:</a>
<a name="ln794"> *</a>
<a name="ln795"> * @code b1 = boost::asio::buffer(a); @endcode</a>
<a name="ln796"> *</a>
<a name="ln797"> * represents the entire array, &lt;tt&gt;{ 'a', 'b', 'c', 'd', 'e' }&lt;/tt&gt;. An</a>
<a name="ln798"> * optional second argument to the boost::asio::buffer function may be used to</a>
<a name="ln799"> * limit the size, in bytes, of the buffer:</a>
<a name="ln800"> *</a>
<a name="ln801"> * @code b2 = boost::asio::buffer(a, 3); @endcode</a>
<a name="ln802"> *</a>
<a name="ln803"> * such that @c b2 represents the data &lt;tt&gt;{ 'a', 'b', 'c' }&lt;/tt&gt;. Even if the</a>
<a name="ln804"> * size argument exceeds the actual size of the array, the size of the buffer</a>
<a name="ln805"> * object created will be limited to the array size.</a>
<a name="ln806"> *</a>
<a name="ln807"> * An offset may be applied to an existing buffer to create a new one:</a>
<a name="ln808"> *</a>
<a name="ln809"> * @code b3 = b1 + 2; @endcode</a>
<a name="ln810"> *</a>
<a name="ln811"> * where @c b3 will set to represent &lt;tt&gt;{ 'c', 'd', 'e' }&lt;/tt&gt;. If the offset</a>
<a name="ln812"> * exceeds the size of the existing buffer, the newly created buffer will be</a>
<a name="ln813"> * empty.</a>
<a name="ln814"> *</a>
<a name="ln815"> * Both an offset and size may be specified to create a buffer that corresponds</a>
<a name="ln816"> * to a specific range of bytes within an existing buffer:</a>
<a name="ln817"> *</a>
<a name="ln818"> * @code b4 = boost::asio::buffer(b1 + 1, 3); @endcode</a>
<a name="ln819"> *</a>
<a name="ln820"> * so that @c b4 will refer to the bytes &lt;tt&gt;{ 'b', 'c', 'd' }&lt;/tt&gt;.</a>
<a name="ln821"> *</a>
<a name="ln822"> * @par Buffers and Scatter-Gather I/O</a>
<a name="ln823"> *</a>
<a name="ln824"> * To read or write using multiple buffers (i.e. scatter-gather I/O), multiple</a>
<a name="ln825"> * buffer objects may be assigned into a container that supports the</a>
<a name="ln826"> * MutableBufferSequence (for read) or ConstBufferSequence (for write) concepts:</a>
<a name="ln827"> *</a>
<a name="ln828"> * @code</a>
<a name="ln829"> * char d1[128];</a>
<a name="ln830"> * std::vector&lt;char&gt; d2(128);</a>
<a name="ln831"> * boost::array&lt;char, 128&gt; d3;</a>
<a name="ln832"> *</a>
<a name="ln833"> * boost::array&lt;mutable_buffer, 3&gt; bufs1 = {</a>
<a name="ln834"> *   boost::asio::buffer(d1),</a>
<a name="ln835"> *   boost::asio::buffer(d2),</a>
<a name="ln836"> *   boost::asio::buffer(d3) };</a>
<a name="ln837"> * bytes_transferred = sock.receive(bufs1);</a>
<a name="ln838"> *</a>
<a name="ln839"> * std::vector&lt;const_buffer&gt; bufs2;</a>
<a name="ln840"> * bufs2.push_back(boost::asio::buffer(d1));</a>
<a name="ln841"> * bufs2.push_back(boost::asio::buffer(d2));</a>
<a name="ln842"> * bufs2.push_back(boost::asio::buffer(d3));</a>
<a name="ln843"> * bytes_transferred = sock.send(bufs2); @endcode</a>
<a name="ln844"> */</a>
<a name="ln845">/*@{*/</a>
<a name="ln846"> </a>
<a name="ln847">#if defined(BOOST_ASIO_NO_DEPRECATED) || defined(GENERATING_DOCUMENTATION)</a>
<a name="ln848"># define BOOST_ASIO_MUTABLE_BUFFER mutable_buffer</a>
<a name="ln849"># define BOOST_ASIO_CONST_BUFFER const_buffer</a>
<a name="ln850">#else // defined(BOOST_ASIO_NO_DEPRECATED) || defined(GENERATING_DOCUMENTATION)</a>
<a name="ln851"># define BOOST_ASIO_MUTABLE_BUFFER mutable_buffers_1</a>
<a name="ln852"># define BOOST_ASIO_CONST_BUFFER const_buffers_1</a>
<a name="ln853">#endif // defined(BOOST_ASIO_NO_DEPRECATED) || defined(GENERATING_DOCUMENTATION)</a>
<a name="ln854"> </a>
<a name="ln855">/// Create a new modifiable buffer from an existing buffer.</a>
<a name="ln856">/**</a>
<a name="ln857"> * @returns &lt;tt&gt;mutable_buffer(b)&lt;/tt&gt;.</a>
<a name="ln858"> */</a>
<a name="ln859">inline BOOST_ASIO_MUTABLE_BUFFER buffer(</a>
<a name="ln860">    const mutable_buffer&amp; b) BOOST_ASIO_NOEXCEPT</a>
<a name="ln861">{</a>
<a name="ln862">  return BOOST_ASIO_MUTABLE_BUFFER(b);</a>
<a name="ln863">}</a>
<a name="ln864"> </a>
<a name="ln865">/// Create a new modifiable buffer from an existing buffer.</a>
<a name="ln866">/**</a>
<a name="ln867"> * @returns A mutable_buffer value equivalent to:</a>
<a name="ln868"> * @code mutable_buffer(</a>
<a name="ln869"> *     b.data(),</a>
<a name="ln870"> *     min(b.size(), max_size_in_bytes)); @endcode</a>
<a name="ln871"> */</a>
<a name="ln872">inline BOOST_ASIO_MUTABLE_BUFFER buffer(const mutable_buffer&amp; b,</a>
<a name="ln873">    std::size_t max_size_in_bytes) BOOST_ASIO_NOEXCEPT</a>
<a name="ln874">{</a>
<a name="ln875">  return BOOST_ASIO_MUTABLE_BUFFER(</a>
<a name="ln876">      mutable_buffer(b.data(),</a>
<a name="ln877">        b.size() &lt; max_size_in_bytes</a>
<a name="ln878">        ? b.size() : max_size_in_bytes</a>
<a name="ln879">#if defined(BOOST_ASIO_ENABLE_BUFFER_DEBUGGING)</a>
<a name="ln880">        , b.get_debug_check()</a>
<a name="ln881">#endif // BOOST_ASIO_ENABLE_BUFFER_DEBUGGING</a>
<a name="ln882">        ));</a>
<a name="ln883">}</a>
<a name="ln884"> </a>
<a name="ln885">/// Create a new non-modifiable buffer from an existing buffer.</a>
<a name="ln886">/**</a>
<a name="ln887"> * @returns &lt;tt&gt;const_buffer(b)&lt;/tt&gt;.</a>
<a name="ln888"> */</a>
<a name="ln889">inline BOOST_ASIO_CONST_BUFFER buffer(</a>
<a name="ln890">    const const_buffer&amp; b) BOOST_ASIO_NOEXCEPT</a>
<a name="ln891">{</a>
<a name="ln892">  return BOOST_ASIO_CONST_BUFFER(b);</a>
<a name="ln893">}</a>
<a name="ln894"> </a>
<a name="ln895">/// Create a new non-modifiable buffer from an existing buffer.</a>
<a name="ln896">/**</a>
<a name="ln897"> * @returns A const_buffer value equivalent to:</a>
<a name="ln898"> * @code const_buffer(</a>
<a name="ln899"> *     b.data(),</a>
<a name="ln900"> *     min(b.size(), max_size_in_bytes)); @endcode</a>
<a name="ln901"> */</a>
<a name="ln902">inline BOOST_ASIO_CONST_BUFFER buffer(const const_buffer&amp; b,</a>
<a name="ln903">    std::size_t max_size_in_bytes) BOOST_ASIO_NOEXCEPT</a>
<a name="ln904">{</a>
<a name="ln905">  return BOOST_ASIO_CONST_BUFFER(b.data(),</a>
<a name="ln906">      b.size() &lt; max_size_in_bytes</a>
<a name="ln907">      ? b.size() : max_size_in_bytes</a>
<a name="ln908">#if defined(BOOST_ASIO_ENABLE_BUFFER_DEBUGGING)</a>
<a name="ln909">      , b.get_debug_check()</a>
<a name="ln910">#endif // BOOST_ASIO_ENABLE_BUFFER_DEBUGGING</a>
<a name="ln911">      );</a>
<a name="ln912">}</a>
<a name="ln913"> </a>
<a name="ln914">/// Create a new modifiable buffer that represents the given memory range.</a>
<a name="ln915">/**</a>
<a name="ln916"> * @returns &lt;tt&gt;mutable_buffer(data, size_in_bytes)&lt;/tt&gt;.</a>
<a name="ln917"> */</a>
<a name="ln918">inline BOOST_ASIO_MUTABLE_BUFFER buffer(void* data,</a>
<a name="ln919">    std::size_t size_in_bytes) BOOST_ASIO_NOEXCEPT</a>
<a name="ln920">{</a>
<a name="ln921">  return BOOST_ASIO_MUTABLE_BUFFER(data, size_in_bytes);</a>
<a name="ln922">}</a>
<a name="ln923"> </a>
<a name="ln924">/// Create a new non-modifiable buffer that represents the given memory range.</a>
<a name="ln925">/**</a>
<a name="ln926"> * @returns &lt;tt&gt;const_buffer(data, size_in_bytes)&lt;/tt&gt;.</a>
<a name="ln927"> */</a>
<a name="ln928">inline BOOST_ASIO_CONST_BUFFER buffer(const void* data,</a>
<a name="ln929">    std::size_t size_in_bytes) BOOST_ASIO_NOEXCEPT</a>
<a name="ln930">{</a>
<a name="ln931">  return BOOST_ASIO_CONST_BUFFER(data, size_in_bytes);</a>
<a name="ln932">}</a>
<a name="ln933"> </a>
<a name="ln934">/// Create a new modifiable buffer that represents the given POD array.</a>
<a name="ln935">/**</a>
<a name="ln936"> * @returns A mutable_buffer value equivalent to:</a>
<a name="ln937"> * @code mutable_buffer(</a>
<a name="ln938"> *     static_cast&lt;void*&gt;(data),</a>
<a name="ln939"> *     N * sizeof(PodType)); @endcode</a>
<a name="ln940"> */</a>
<a name="ln941">template &lt;typename PodType, std::size_t N&gt;</a>
<a name="ln942">inline BOOST_ASIO_MUTABLE_BUFFER buffer(PodType (&amp;data)[N]) BOOST_ASIO_NOEXCEPT</a>
<a name="ln943">{</a>
<a name="ln944">  return BOOST_ASIO_MUTABLE_BUFFER(data, N * sizeof(PodType));</a>
<a name="ln945">}</a>
<a name="ln946"> </a>
<a name="ln947">/// Create a new modifiable buffer that represents the given POD array.</a>
<a name="ln948">/**</a>
<a name="ln949"> * @returns A mutable_buffer value equivalent to:</a>
<a name="ln950"> * @code mutable_buffer(</a>
<a name="ln951"> *     static_cast&lt;void*&gt;(data),</a>
<a name="ln952"> *     min(N * sizeof(PodType), max_size_in_bytes)); @endcode</a>
<a name="ln953"> */</a>
<a name="ln954">template &lt;typename PodType, std::size_t N&gt;</a>
<a name="ln955">inline BOOST_ASIO_MUTABLE_BUFFER buffer(PodType (&amp;data)[N],</a>
<a name="ln956">    std::size_t max_size_in_bytes) BOOST_ASIO_NOEXCEPT</a>
<a name="ln957">{</a>
<a name="ln958">  return BOOST_ASIO_MUTABLE_BUFFER(data,</a>
<a name="ln959">      N * sizeof(PodType) &lt; max_size_in_bytes</a>
<a name="ln960">      ? N * sizeof(PodType) : max_size_in_bytes);</a>
<a name="ln961">}</a>
<a name="ln962"> </a>
<a name="ln963">/// Create a new non-modifiable buffer that represents the given POD array.</a>
<a name="ln964">/**</a>
<a name="ln965"> * @returns A const_buffer value equivalent to:</a>
<a name="ln966"> * @code const_buffer(</a>
<a name="ln967"> *     static_cast&lt;const void*&gt;(data),</a>
<a name="ln968"> *     N * sizeof(PodType)); @endcode</a>
<a name="ln969"> */</a>
<a name="ln970">template &lt;typename PodType, std::size_t N&gt;</a>
<a name="ln971">inline BOOST_ASIO_CONST_BUFFER buffer(</a>
<a name="ln972">    const PodType (&amp;data)[N]) BOOST_ASIO_NOEXCEPT</a>
<a name="ln973">{</a>
<a name="ln974">  return BOOST_ASIO_CONST_BUFFER(data, N * sizeof(PodType));</a>
<a name="ln975">}</a>
<a name="ln976"> </a>
<a name="ln977">/// Create a new non-modifiable buffer that represents the given POD array.</a>
<a name="ln978">/**</a>
<a name="ln979"> * @returns A const_buffer value equivalent to:</a>
<a name="ln980"> * @code const_buffer(</a>
<a name="ln981"> *     static_cast&lt;const void*&gt;(data),</a>
<a name="ln982"> *     min(N * sizeof(PodType), max_size_in_bytes)); @endcode</a>
<a name="ln983"> */</a>
<a name="ln984">template &lt;typename PodType, std::size_t N&gt;</a>
<a name="ln985">inline BOOST_ASIO_CONST_BUFFER buffer(const PodType (&amp;data)[N],</a>
<a name="ln986">    std::size_t max_size_in_bytes) BOOST_ASIO_NOEXCEPT</a>
<a name="ln987">{</a>
<a name="ln988">  return BOOST_ASIO_CONST_BUFFER(data,</a>
<a name="ln989">      N * sizeof(PodType) &lt; max_size_in_bytes</a>
<a name="ln990">      ? N * sizeof(PodType) : max_size_in_bytes);</a>
<a name="ln991">}</a>
<a name="ln992"> </a>
<a name="ln993">#if defined(BOOST_ASIO_ENABLE_ARRAY_BUFFER_WORKAROUND)</a>
<a name="ln994"> </a>
<a name="ln995">// Borland C++ and Sun Studio think the overloads:</a>
<a name="ln996">//</a>
<a name="ln997">//   unspecified buffer(boost::array&lt;PodType, N&gt;&amp; array ...);</a>
<a name="ln998">//</a>
<a name="ln999">// and</a>
<a name="ln1000">//</a>
<a name="ln1001">//   unspecified buffer(boost::array&lt;const PodType, N&gt;&amp; array ...);</a>
<a name="ln1002">//</a>
<a name="ln1003">// are ambiguous. This will be worked around by using a buffer_types traits</a>
<a name="ln1004">// class that contains typedefs for the appropriate buffer and container</a>
<a name="ln1005">// classes, based on whether PodType is const or non-const.</a>
<a name="ln1006"> </a>
<a name="ln1007">namespace detail {</a>
<a name="ln1008"> </a>
<a name="ln1009">template &lt;bool IsConst&gt;</a>
<a name="ln1010">struct buffer_types_base;</a>
<a name="ln1011"> </a>
<a name="ln1012">template &lt;&gt;</a>
<a name="ln1013">struct buffer_types_base&lt;false&gt;</a>
<a name="ln1014">{</a>
<a name="ln1015">  typedef mutable_buffer buffer_type;</a>
<a name="ln1016">  typedef BOOST_ASIO_MUTABLE_BUFFER container_type;</a>
<a name="ln1017">};</a>
<a name="ln1018"> </a>
<a name="ln1019">template &lt;&gt;</a>
<a name="ln1020">struct buffer_types_base&lt;true&gt;</a>
<a name="ln1021">{</a>
<a name="ln1022">  typedef const_buffer buffer_type;</a>
<a name="ln1023">  typedef BOOST_ASIO_CONST_BUFFER container_type;</a>
<a name="ln1024">};</a>
<a name="ln1025"> </a>
<a name="ln1026">template &lt;typename PodType&gt;</a>
<a name="ln1027">struct buffer_types</a>
<a name="ln1028">  : public buffer_types_base&lt;is_const&lt;PodType&gt;::value&gt;</a>
<a name="ln1029">{</a>
<a name="ln1030">};</a>
<a name="ln1031"> </a>
<a name="ln1032">} // namespace detail</a>
<a name="ln1033"> </a>
<a name="ln1034">template &lt;typename PodType, std::size_t N&gt;</a>
<a name="ln1035">inline typename detail::buffer_types&lt;PodType&gt;::container_type</a>
<a name="ln1036">buffer(boost::array&lt;PodType, N&gt;&amp; data) BOOST_ASIO_NOEXCEPT</a>
<a name="ln1037">{</a>
<a name="ln1038">  typedef typename boost::asio::detail::buffer_types&lt;PodType&gt;::buffer_type</a>
<a name="ln1039">    buffer_type;</a>
<a name="ln1040">  typedef typename boost::asio::detail::buffer_types&lt;PodType&gt;::container_type</a>
<a name="ln1041">    container_type;</a>
<a name="ln1042">  return container_type(</a>
<a name="ln1043">      buffer_type(data.c_array(), data.size() * sizeof(PodType)));</a>
<a name="ln1044">}</a>
<a name="ln1045"> </a>
<a name="ln1046">template &lt;typename PodType, std::size_t N&gt;</a>
<a name="ln1047">inline typename detail::buffer_types&lt;PodType&gt;::container_type</a>
<a name="ln1048">buffer(boost::array&lt;PodType, N&gt;&amp; data,</a>
<a name="ln1049">    std::size_t max_size_in_bytes) BOOST_ASIO_NOEXCEPT</a>
<a name="ln1050">{</a>
<a name="ln1051">  typedef typename boost::asio::detail::buffer_types&lt;PodType&gt;::buffer_type</a>
<a name="ln1052">    buffer_type;</a>
<a name="ln1053">  typedef typename boost::asio::detail::buffer_types&lt;PodType&gt;::container_type</a>
<a name="ln1054">    container_type;</a>
<a name="ln1055">  return container_type(</a>
<a name="ln1056">      buffer_type(data.c_array(),</a>
<a name="ln1057">        data.size() * sizeof(PodType) &lt; max_size_in_bytes</a>
<a name="ln1058">        ? data.size() * sizeof(PodType) : max_size_in_bytes));</a>
<a name="ln1059">}</a>
<a name="ln1060"> </a>
<a name="ln1061">#else // defined(BOOST_ASIO_ENABLE_ARRAY_BUFFER_WORKAROUND)</a>
<a name="ln1062"> </a>
<a name="ln1063">/// Create a new modifiable buffer that represents the given POD array.</a>
<a name="ln1064">/**</a>
<a name="ln1065"> * @returns A mutable_buffer value equivalent to:</a>
<a name="ln1066"> * @code mutable_buffer(</a>
<a name="ln1067"> *     data.data(),</a>
<a name="ln1068"> *     data.size() * sizeof(PodType)); @endcode</a>
<a name="ln1069"> */</a>
<a name="ln1070">template &lt;typename PodType, std::size_t N&gt;</a>
<a name="ln1071">inline BOOST_ASIO_MUTABLE_BUFFER buffer(</a>
<a name="ln1072">    boost::array&lt;PodType, N&gt;&amp; data) BOOST_ASIO_NOEXCEPT</a>
<a name="ln1073">{</a>
<a name="ln1074">  return BOOST_ASIO_MUTABLE_BUFFER(</a>
<a name="ln1075">      data.c_array(), data.size() * sizeof(PodType));</a>
<a name="ln1076">}</a>
<a name="ln1077"> </a>
<a name="ln1078">/// Create a new modifiable buffer that represents the given POD array.</a>
<a name="ln1079">/**</a>
<a name="ln1080"> * @returns A mutable_buffer value equivalent to:</a>
<a name="ln1081"> * @code mutable_buffer(</a>
<a name="ln1082"> *     data.data(),</a>
<a name="ln1083"> *     min(data.size() * sizeof(PodType), max_size_in_bytes)); @endcode</a>
<a name="ln1084"> */</a>
<a name="ln1085">template &lt;typename PodType, std::size_t N&gt;</a>
<a name="ln1086">inline BOOST_ASIO_MUTABLE_BUFFER buffer(boost::array&lt;PodType, N&gt;&amp; data,</a>
<a name="ln1087">    std::size_t max_size_in_bytes) BOOST_ASIO_NOEXCEPT</a>
<a name="ln1088">{</a>
<a name="ln1089">  return BOOST_ASIO_MUTABLE_BUFFER(data.c_array(),</a>
<a name="ln1090">      data.size() * sizeof(PodType) &lt; max_size_in_bytes</a>
<a name="ln1091">      ? data.size() * sizeof(PodType) : max_size_in_bytes);</a>
<a name="ln1092">}</a>
<a name="ln1093"> </a>
<a name="ln1094">/// Create a new non-modifiable buffer that represents the given POD array.</a>
<a name="ln1095">/**</a>
<a name="ln1096"> * @returns A const_buffer value equivalent to:</a>
<a name="ln1097"> * @code const_buffer(</a>
<a name="ln1098"> *     data.data(),</a>
<a name="ln1099"> *     data.size() * sizeof(PodType)); @endcode</a>
<a name="ln1100"> */</a>
<a name="ln1101">template &lt;typename PodType, std::size_t N&gt;</a>
<a name="ln1102">inline BOOST_ASIO_CONST_BUFFER buffer(</a>
<a name="ln1103">    boost::array&lt;const PodType, N&gt;&amp; data) BOOST_ASIO_NOEXCEPT</a>
<a name="ln1104">{</a>
<a name="ln1105">  return BOOST_ASIO_CONST_BUFFER(data.data(), data.size() * sizeof(PodType));</a>
<a name="ln1106">}</a>
<a name="ln1107"> </a>
<a name="ln1108">/// Create a new non-modifiable buffer that represents the given POD array.</a>
<a name="ln1109">/**</a>
<a name="ln1110"> * @returns A const_buffer value equivalent to:</a>
<a name="ln1111"> * @code const_buffer(</a>
<a name="ln1112"> *     data.data(),</a>
<a name="ln1113"> *     min(data.size() * sizeof(PodType), max_size_in_bytes)); @endcode</a>
<a name="ln1114"> */</a>
<a name="ln1115">template &lt;typename PodType, std::size_t N&gt;</a>
<a name="ln1116">inline BOOST_ASIO_CONST_BUFFER buffer(boost::array&lt;const PodType, N&gt;&amp; data,</a>
<a name="ln1117">    std::size_t max_size_in_bytes) BOOST_ASIO_NOEXCEPT</a>
<a name="ln1118">{</a>
<a name="ln1119">  return BOOST_ASIO_CONST_BUFFER(data.data(),</a>
<a name="ln1120">      data.size() * sizeof(PodType) &lt; max_size_in_bytes</a>
<a name="ln1121">      ? data.size() * sizeof(PodType) : max_size_in_bytes);</a>
<a name="ln1122">}</a>
<a name="ln1123"> </a>
<a name="ln1124">#endif // defined(BOOST_ASIO_ENABLE_ARRAY_BUFFER_WORKAROUND)</a>
<a name="ln1125"> </a>
<a name="ln1126">/// Create a new non-modifiable buffer that represents the given POD array.</a>
<a name="ln1127">/**</a>
<a name="ln1128"> * @returns A const_buffer value equivalent to:</a>
<a name="ln1129"> * @code const_buffer(</a>
<a name="ln1130"> *     data.data(),</a>
<a name="ln1131"> *     data.size() * sizeof(PodType)); @endcode</a>
<a name="ln1132"> */</a>
<a name="ln1133">template &lt;typename PodType, std::size_t N&gt;</a>
<a name="ln1134">inline BOOST_ASIO_CONST_BUFFER buffer(</a>
<a name="ln1135">    const boost::array&lt;PodType, N&gt;&amp; data) BOOST_ASIO_NOEXCEPT</a>
<a name="ln1136">{</a>
<a name="ln1137">  return BOOST_ASIO_CONST_BUFFER(data.data(), data.size() * sizeof(PodType));</a>
<a name="ln1138">}</a>
<a name="ln1139"> </a>
<a name="ln1140">/// Create a new non-modifiable buffer that represents the given POD array.</a>
<a name="ln1141">/**</a>
<a name="ln1142"> * @returns A const_buffer value equivalent to:</a>
<a name="ln1143"> * @code const_buffer(</a>
<a name="ln1144"> *     data.data(),</a>
<a name="ln1145"> *     min(data.size() * sizeof(PodType), max_size_in_bytes)); @endcode</a>
<a name="ln1146"> */</a>
<a name="ln1147">template &lt;typename PodType, std::size_t N&gt;</a>
<a name="ln1148">inline BOOST_ASIO_CONST_BUFFER buffer(const boost::array&lt;PodType, N&gt;&amp; data,</a>
<a name="ln1149">    std::size_t max_size_in_bytes) BOOST_ASIO_NOEXCEPT</a>
<a name="ln1150">{</a>
<a name="ln1151">  return BOOST_ASIO_CONST_BUFFER(data.data(),</a>
<a name="ln1152">      data.size() * sizeof(PodType) &lt; max_size_in_bytes</a>
<a name="ln1153">      ? data.size() * sizeof(PodType) : max_size_in_bytes);</a>
<a name="ln1154">}</a>
<a name="ln1155"> </a>
<a name="ln1156">#if defined(BOOST_ASIO_HAS_STD_ARRAY) || defined(GENERATING_DOCUMENTATION)</a>
<a name="ln1157"> </a>
<a name="ln1158">/// Create a new modifiable buffer that represents the given POD array.</a>
<a name="ln1159">/**</a>
<a name="ln1160"> * @returns A mutable_buffer value equivalent to:</a>
<a name="ln1161"> * @code mutable_buffer(</a>
<a name="ln1162"> *     data.data(),</a>
<a name="ln1163"> *     data.size() * sizeof(PodType)); @endcode</a>
<a name="ln1164"> */</a>
<a name="ln1165">template &lt;typename PodType, std::size_t N&gt;</a>
<a name="ln1166">inline BOOST_ASIO_MUTABLE_BUFFER buffer(</a>
<a name="ln1167">    std::array&lt;PodType, N&gt;&amp; data) BOOST_ASIO_NOEXCEPT</a>
<a name="ln1168">{</a>
<a name="ln1169">  return BOOST_ASIO_MUTABLE_BUFFER(data.data(), data.size() * sizeof(PodType));</a>
<a name="ln1170">}</a>
<a name="ln1171"> </a>
<a name="ln1172">/// Create a new modifiable buffer that represents the given POD array.</a>
<a name="ln1173">/**</a>
<a name="ln1174"> * @returns A mutable_buffer value equivalent to:</a>
<a name="ln1175"> * @code mutable_buffer(</a>
<a name="ln1176"> *     data.data(),</a>
<a name="ln1177"> *     min(data.size() * sizeof(PodType), max_size_in_bytes)); @endcode</a>
<a name="ln1178"> */</a>
<a name="ln1179">template &lt;typename PodType, std::size_t N&gt;</a>
<a name="ln1180">inline BOOST_ASIO_MUTABLE_BUFFER buffer(std::array&lt;PodType, N&gt;&amp; data,</a>
<a name="ln1181">    std::size_t max_size_in_bytes) BOOST_ASIO_NOEXCEPT</a>
<a name="ln1182">{</a>
<a name="ln1183">  return BOOST_ASIO_MUTABLE_BUFFER(data.data(),</a>
<a name="ln1184">      data.size() * sizeof(PodType) &lt; max_size_in_bytes</a>
<a name="ln1185">      ? data.size() * sizeof(PodType) : max_size_in_bytes);</a>
<a name="ln1186">}</a>
<a name="ln1187"> </a>
<a name="ln1188">/// Create a new non-modifiable buffer that represents the given POD array.</a>
<a name="ln1189">/**</a>
<a name="ln1190"> * @returns A const_buffer value equivalent to:</a>
<a name="ln1191"> * @code const_buffer(</a>
<a name="ln1192"> *     data.data(),</a>
<a name="ln1193"> *     data.size() * sizeof(PodType)); @endcode</a>
<a name="ln1194"> */</a>
<a name="ln1195">template &lt;typename PodType, std::size_t N&gt;</a>
<a name="ln1196">inline BOOST_ASIO_CONST_BUFFER buffer(</a>
<a name="ln1197">    std::array&lt;const PodType, N&gt;&amp; data) BOOST_ASIO_NOEXCEPT</a>
<a name="ln1198">{</a>
<a name="ln1199">  return BOOST_ASIO_CONST_BUFFER(data.data(), data.size() * sizeof(PodType));</a>
<a name="ln1200">}</a>
<a name="ln1201"> </a>
<a name="ln1202">/// Create a new non-modifiable buffer that represents the given POD array.</a>
<a name="ln1203">/**</a>
<a name="ln1204"> * @returns A const_buffer value equivalent to:</a>
<a name="ln1205"> * @code const_buffer(</a>
<a name="ln1206"> *     data.data(),</a>
<a name="ln1207"> *     min(data.size() * sizeof(PodType), max_size_in_bytes)); @endcode</a>
<a name="ln1208"> */</a>
<a name="ln1209">template &lt;typename PodType, std::size_t N&gt;</a>
<a name="ln1210">inline BOOST_ASIO_CONST_BUFFER buffer(std::array&lt;const PodType, N&gt;&amp; data,</a>
<a name="ln1211">    std::size_t max_size_in_bytes) BOOST_ASIO_NOEXCEPT</a>
<a name="ln1212">{</a>
<a name="ln1213">  return BOOST_ASIO_CONST_BUFFER(data.data(),</a>
<a name="ln1214">      data.size() * sizeof(PodType) &lt; max_size_in_bytes</a>
<a name="ln1215">      ? data.size() * sizeof(PodType) : max_size_in_bytes);</a>
<a name="ln1216">}</a>
<a name="ln1217"> </a>
<a name="ln1218">/// Create a new non-modifiable buffer that represents the given POD array.</a>
<a name="ln1219">/**</a>
<a name="ln1220"> * @returns A const_buffer value equivalent to:</a>
<a name="ln1221"> * @code const_buffer(</a>
<a name="ln1222"> *     data.data(),</a>
<a name="ln1223"> *     data.size() * sizeof(PodType)); @endcode</a>
<a name="ln1224"> */</a>
<a name="ln1225">template &lt;typename PodType, std::size_t N&gt;</a>
<a name="ln1226">inline BOOST_ASIO_CONST_BUFFER buffer(</a>
<a name="ln1227">    const std::array&lt;PodType, N&gt;&amp; data) BOOST_ASIO_NOEXCEPT</a>
<a name="ln1228">{</a>
<a name="ln1229">  return BOOST_ASIO_CONST_BUFFER(data.data(), data.size() * sizeof(PodType));</a>
<a name="ln1230">}</a>
<a name="ln1231"> </a>
<a name="ln1232">/// Create a new non-modifiable buffer that represents the given POD array.</a>
<a name="ln1233">/**</a>
<a name="ln1234"> * @returns A const_buffer value equivalent to:</a>
<a name="ln1235"> * @code const_buffer(</a>
<a name="ln1236"> *     data.data(),</a>
<a name="ln1237"> *     min(data.size() * sizeof(PodType), max_size_in_bytes)); @endcode</a>
<a name="ln1238"> */</a>
<a name="ln1239">template &lt;typename PodType, std::size_t N&gt;</a>
<a name="ln1240">inline BOOST_ASIO_CONST_BUFFER buffer(const std::array&lt;PodType, N&gt;&amp; data,</a>
<a name="ln1241">    std::size_t max_size_in_bytes) BOOST_ASIO_NOEXCEPT</a>
<a name="ln1242">{</a>
<a name="ln1243">  return BOOST_ASIO_CONST_BUFFER(data.data(),</a>
<a name="ln1244">      data.size() * sizeof(PodType) &lt; max_size_in_bytes</a>
<a name="ln1245">      ? data.size() * sizeof(PodType) : max_size_in_bytes);</a>
<a name="ln1246">}</a>
<a name="ln1247"> </a>
<a name="ln1248">#endif // defined(BOOST_ASIO_HAS_STD_ARRAY) || defined(GENERATING_DOCUMENTATION)</a>
<a name="ln1249"> </a>
<a name="ln1250">/// Create a new modifiable buffer that represents the given POD vector.</a>
<a name="ln1251">/**</a>
<a name="ln1252"> * @returns A mutable_buffer value equivalent to:</a>
<a name="ln1253"> * @code mutable_buffer(</a>
<a name="ln1254"> *     data.size() ? &amp;data[0] : 0,</a>
<a name="ln1255"> *     data.size() * sizeof(PodType)); @endcode</a>
<a name="ln1256"> *</a>
<a name="ln1257"> * @note The buffer is invalidated by any vector operation that would also</a>
<a name="ln1258"> * invalidate iterators.</a>
<a name="ln1259"> */</a>
<a name="ln1260">template &lt;typename PodType, typename Allocator&gt;</a>
<a name="ln1261">inline BOOST_ASIO_MUTABLE_BUFFER buffer(</a>
<a name="ln1262">    std::vector&lt;PodType, Allocator&gt;&amp; data) BOOST_ASIO_NOEXCEPT</a>
<a name="ln1263">{</a>
<a name="ln1264">  return BOOST_ASIO_MUTABLE_BUFFER(</a>
<a name="ln1265">      data.size() ? &amp;data[0] : 0, data.size() * sizeof(PodType)</a>
<a name="ln1266">#if defined(BOOST_ASIO_ENABLE_BUFFER_DEBUGGING)</a>
<a name="ln1267">      , detail::buffer_debug_check&lt;</a>
<a name="ln1268">          typename std::vector&lt;PodType, Allocator&gt;::iterator</a>
<a name="ln1269">        &gt;(data.begin())</a>
<a name="ln1270">#endif // BOOST_ASIO_ENABLE_BUFFER_DEBUGGING</a>
<a name="ln1271">      );</a>
<a name="ln1272">}</a>
<a name="ln1273"> </a>
<a name="ln1274">/// Create a new modifiable buffer that represents the given POD vector.</a>
<a name="ln1275">/**</a>
<a name="ln1276"> * @returns A mutable_buffer value equivalent to:</a>
<a name="ln1277"> * @code mutable_buffer(</a>
<a name="ln1278"> *     data.size() ? &amp;data[0] : 0,</a>
<a name="ln1279"> *     min(data.size() * sizeof(PodType), max_size_in_bytes)); @endcode</a>
<a name="ln1280"> *</a>
<a name="ln1281"> * @note The buffer is invalidated by any vector operation that would also</a>
<a name="ln1282"> * invalidate iterators.</a>
<a name="ln1283"> */</a>
<a name="ln1284">template &lt;typename PodType, typename Allocator&gt;</a>
<a name="ln1285">inline BOOST_ASIO_MUTABLE_BUFFER buffer(std::vector&lt;PodType, Allocator&gt;&amp; data,</a>
<a name="ln1286">    std::size_t max_size_in_bytes) BOOST_ASIO_NOEXCEPT</a>
<a name="ln1287">{</a>
<a name="ln1288">  return BOOST_ASIO_MUTABLE_BUFFER(data.size() ? &amp;data[0] : 0,</a>
<a name="ln1289">      data.size() * sizeof(PodType) &lt; max_size_in_bytes</a>
<a name="ln1290">      ? data.size() * sizeof(PodType) : max_size_in_bytes</a>
<a name="ln1291">#if defined(BOOST_ASIO_ENABLE_BUFFER_DEBUGGING)</a>
<a name="ln1292">      , detail::buffer_debug_check&lt;</a>
<a name="ln1293">          typename std::vector&lt;PodType, Allocator&gt;::iterator</a>
<a name="ln1294">        &gt;(data.begin())</a>
<a name="ln1295">#endif // BOOST_ASIO_ENABLE_BUFFER_DEBUGGING</a>
<a name="ln1296">      );</a>
<a name="ln1297">}</a>
<a name="ln1298"> </a>
<a name="ln1299">/// Create a new non-modifiable buffer that represents the given POD vector.</a>
<a name="ln1300">/**</a>
<a name="ln1301"> * @returns A const_buffer value equivalent to:</a>
<a name="ln1302"> * @code const_buffer(</a>
<a name="ln1303"> *     data.size() ? &amp;data[0] : 0,</a>
<a name="ln1304"> *     data.size() * sizeof(PodType)); @endcode</a>
<a name="ln1305"> *</a>
<a name="ln1306"> * @note The buffer is invalidated by any vector operation that would also</a>
<a name="ln1307"> * invalidate iterators.</a>
<a name="ln1308"> */</a>
<a name="ln1309">template &lt;typename PodType, typename Allocator&gt;</a>
<a name="ln1310">inline BOOST_ASIO_CONST_BUFFER buffer(</a>
<a name="ln1311">    const std::vector&lt;PodType, Allocator&gt;&amp; data) BOOST_ASIO_NOEXCEPT</a>
<a name="ln1312">{</a>
<a name="ln1313">  return BOOST_ASIO_CONST_BUFFER(</a>
<a name="ln1314">      data.size() ? &amp;data[0] : 0, data.size() * sizeof(PodType)</a>
<a name="ln1315">#if defined(BOOST_ASIO_ENABLE_BUFFER_DEBUGGING)</a>
<a name="ln1316">      , detail::buffer_debug_check&lt;</a>
<a name="ln1317">          typename std::vector&lt;PodType, Allocator&gt;::const_iterator</a>
<a name="ln1318">        &gt;(data.begin())</a>
<a name="ln1319">#endif // BOOST_ASIO_ENABLE_BUFFER_DEBUGGING</a>
<a name="ln1320">      );</a>
<a name="ln1321">}</a>
<a name="ln1322"> </a>
<a name="ln1323">/// Create a new non-modifiable buffer that represents the given POD vector.</a>
<a name="ln1324">/**</a>
<a name="ln1325"> * @returns A const_buffer value equivalent to:</a>
<a name="ln1326"> * @code const_buffer(</a>
<a name="ln1327"> *     data.size() ? &amp;data[0] : 0,</a>
<a name="ln1328"> *     min(data.size() * sizeof(PodType), max_size_in_bytes)); @endcode</a>
<a name="ln1329"> *</a>
<a name="ln1330"> * @note The buffer is invalidated by any vector operation that would also</a>
<a name="ln1331"> * invalidate iterators.</a>
<a name="ln1332"> */</a>
<a name="ln1333">template &lt;typename PodType, typename Allocator&gt;</a>
<a name="ln1334">inline BOOST_ASIO_CONST_BUFFER buffer(</a>
<a name="ln1335">    const std::vector&lt;PodType, Allocator&gt;&amp; data,</a>
<a name="ln1336">    std::size_t max_size_in_bytes) BOOST_ASIO_NOEXCEPT</a>
<a name="ln1337">{</a>
<a name="ln1338">  return BOOST_ASIO_CONST_BUFFER(data.size() ? &amp;data[0] : 0,</a>
<a name="ln1339">      data.size() * sizeof(PodType) &lt; max_size_in_bytes</a>
<a name="ln1340">      ? data.size() * sizeof(PodType) : max_size_in_bytes</a>
<a name="ln1341">#if defined(BOOST_ASIO_ENABLE_BUFFER_DEBUGGING)</a>
<a name="ln1342">      , detail::buffer_debug_check&lt;</a>
<a name="ln1343">          typename std::vector&lt;PodType, Allocator&gt;::const_iterator</a>
<a name="ln1344">        &gt;(data.begin())</a>
<a name="ln1345">#endif // BOOST_ASIO_ENABLE_BUFFER_DEBUGGING</a>
<a name="ln1346">      );</a>
<a name="ln1347">}</a>
<a name="ln1348"> </a>
<a name="ln1349">/// Create a new modifiable buffer that represents the given string.</a>
<a name="ln1350">/**</a>
<a name="ln1351"> * @returns &lt;tt&gt;mutable_buffer(data.size() ? &amp;data[0] : 0,</a>
<a name="ln1352"> * data.size() * sizeof(Elem))&lt;/tt&gt;.</a>
<a name="ln1353"> *</a>
<a name="ln1354"> * @note The buffer is invalidated by any non-const operation called on the</a>
<a name="ln1355"> * given string object.</a>
<a name="ln1356"> */</a>
<a name="ln1357">template &lt;typename Elem, typename Traits, typename Allocator&gt;</a>
<a name="ln1358">inline BOOST_ASIO_MUTABLE_BUFFER buffer(</a>
<a name="ln1359">    std::basic_string&lt;Elem, Traits, Allocator&gt;&amp; data) BOOST_ASIO_NOEXCEPT</a>
<a name="ln1360">{</a>
<a name="ln1361">  return BOOST_ASIO_MUTABLE_BUFFER(data.size() ? &amp;data[0] : 0,</a>
<a name="ln1362">      data.size() * sizeof(Elem)</a>
<a name="ln1363">#if defined(BOOST_ASIO_ENABLE_BUFFER_DEBUGGING)</a>
<a name="ln1364">      , detail::buffer_debug_check&lt;</a>
<a name="ln1365">          typename std::basic_string&lt;Elem, Traits, Allocator&gt;::iterator</a>
<a name="ln1366">        &gt;(data.begin())</a>
<a name="ln1367">#endif // BOOST_ASIO_ENABLE_BUFFER_DEBUGGING</a>
<a name="ln1368">      );</a>
<a name="ln1369">}</a>
<a name="ln1370"> </a>
<a name="ln1371">/// Create a new modifiable buffer that represents the given string.</a>
<a name="ln1372">/**</a>
<a name="ln1373"> * @returns A mutable_buffer value equivalent to:</a>
<a name="ln1374"> * @code mutable_buffer(</a>
<a name="ln1375"> *     data.size() ? &amp;data[0] : 0,</a>
<a name="ln1376"> *     min(data.size() * sizeof(Elem), max_size_in_bytes)); @endcode</a>
<a name="ln1377"> *</a>
<a name="ln1378"> * @note The buffer is invalidated by any non-const operation called on the</a>
<a name="ln1379"> * given string object.</a>
<a name="ln1380"> */</a>
<a name="ln1381">template &lt;typename Elem, typename Traits, typename Allocator&gt;</a>
<a name="ln1382">inline BOOST_ASIO_MUTABLE_BUFFER buffer(</a>
<a name="ln1383">    std::basic_string&lt;Elem, Traits, Allocator&gt;&amp; data,</a>
<a name="ln1384">    std::size_t max_size_in_bytes) BOOST_ASIO_NOEXCEPT</a>
<a name="ln1385">{</a>
<a name="ln1386">  return BOOST_ASIO_MUTABLE_BUFFER(data.size() ? &amp;data[0] : 0,</a>
<a name="ln1387">      data.size() * sizeof(Elem) &lt; max_size_in_bytes</a>
<a name="ln1388">      ? data.size() * sizeof(Elem) : max_size_in_bytes</a>
<a name="ln1389">#if defined(BOOST_ASIO_ENABLE_BUFFER_DEBUGGING)</a>
<a name="ln1390">      , detail::buffer_debug_check&lt;</a>
<a name="ln1391">          typename std::basic_string&lt;Elem, Traits, Allocator&gt;::iterator</a>
<a name="ln1392">        &gt;(data.begin())</a>
<a name="ln1393">#endif // BOOST_ASIO_ENABLE_BUFFER_DEBUGGING</a>
<a name="ln1394">      );</a>
<a name="ln1395">}</a>
<a name="ln1396"> </a>
<a name="ln1397">/// Create a new non-modifiable buffer that represents the given string.</a>
<a name="ln1398">/**</a>
<a name="ln1399"> * @returns &lt;tt&gt;const_buffer(data.data(), data.size() * sizeof(Elem))&lt;/tt&gt;.</a>
<a name="ln1400"> *</a>
<a name="ln1401"> * @note The buffer is invalidated by any non-const operation called on the</a>
<a name="ln1402"> * given string object.</a>
<a name="ln1403"> */</a>
<a name="ln1404">template &lt;typename Elem, typename Traits, typename Allocator&gt;</a>
<a name="ln1405">inline BOOST_ASIO_CONST_BUFFER buffer(</a>
<a name="ln1406">    const std::basic_string&lt;Elem, Traits, Allocator&gt;&amp; data) BOOST_ASIO_NOEXCEPT</a>
<a name="ln1407">{</a>
<a name="ln1408">  return BOOST_ASIO_CONST_BUFFER(data.data(), data.size() * sizeof(Elem)</a>
<a name="ln1409">#if defined(BOOST_ASIO_ENABLE_BUFFER_DEBUGGING)</a>
<a name="ln1410">      , detail::buffer_debug_check&lt;</a>
<a name="ln1411">          typename std::basic_string&lt;Elem, Traits, Allocator&gt;::const_iterator</a>
<a name="ln1412">        &gt;(data.begin())</a>
<a name="ln1413">#endif // BOOST_ASIO_ENABLE_BUFFER_DEBUGGING</a>
<a name="ln1414">      );</a>
<a name="ln1415">}</a>
<a name="ln1416"> </a>
<a name="ln1417">/// Create a new non-modifiable buffer that represents the given string.</a>
<a name="ln1418">/**</a>
<a name="ln1419"> * @returns A const_buffer value equivalent to:</a>
<a name="ln1420"> * @code const_buffer(</a>
<a name="ln1421"> *     data.data(),</a>
<a name="ln1422"> *     min(data.size() * sizeof(Elem), max_size_in_bytes)); @endcode</a>
<a name="ln1423"> *</a>
<a name="ln1424"> * @note The buffer is invalidated by any non-const operation called on the</a>
<a name="ln1425"> * given string object.</a>
<a name="ln1426"> */</a>
<a name="ln1427">template &lt;typename Elem, typename Traits, typename Allocator&gt;</a>
<a name="ln1428">inline BOOST_ASIO_CONST_BUFFER buffer(</a>
<a name="ln1429">    const std::basic_string&lt;Elem, Traits, Allocator&gt;&amp; data,</a>
<a name="ln1430">    std::size_t max_size_in_bytes) BOOST_ASIO_NOEXCEPT</a>
<a name="ln1431">{</a>
<a name="ln1432">  return BOOST_ASIO_CONST_BUFFER(data.data(),</a>
<a name="ln1433">      data.size() * sizeof(Elem) &lt; max_size_in_bytes</a>
<a name="ln1434">      ? data.size() * sizeof(Elem) : max_size_in_bytes</a>
<a name="ln1435">#if defined(BOOST_ASIO_ENABLE_BUFFER_DEBUGGING)</a>
<a name="ln1436">      , detail::buffer_debug_check&lt;</a>
<a name="ln1437">          typename std::basic_string&lt;Elem, Traits, Allocator&gt;::const_iterator</a>
<a name="ln1438">        &gt;(data.begin())</a>
<a name="ln1439">#endif // BOOST_ASIO_ENABLE_BUFFER_DEBUGGING</a>
<a name="ln1440">      );</a>
<a name="ln1441">}</a>
<a name="ln1442"> </a>
<a name="ln1443">#if defined(BOOST_ASIO_HAS_STRING_VIEW) \</a>
<a name="ln1444">  || defined(GENERATING_DOCUMENTATION)</a>
<a name="ln1445"> </a>
<a name="ln1446">/// Create a new modifiable buffer that represents the given string_view.</a>
<a name="ln1447">/**</a>
<a name="ln1448"> * @returns &lt;tt&gt;mutable_buffer(data.size() ? &amp;data[0] : 0,</a>
<a name="ln1449"> * data.size() * sizeof(Elem))&lt;/tt&gt;.</a>
<a name="ln1450"> */</a>
<a name="ln1451">template &lt;typename Elem, typename Traits&gt;</a>
<a name="ln1452">inline BOOST_ASIO_CONST_BUFFER buffer(</a>
<a name="ln1453">    basic_string_view&lt;Elem, Traits&gt; data) BOOST_ASIO_NOEXCEPT</a>
<a name="ln1454">{</a>
<a name="ln1455">  return BOOST_ASIO_CONST_BUFFER(data.size() ? &amp;data[0] : 0,</a>
<a name="ln1456">      data.size() * sizeof(Elem)</a>
<a name="ln1457">#if defined(BOOST_ASIO_ENABLE_BUFFER_DEBUGGING)</a>
<a name="ln1458">      , detail::buffer_debug_check&lt;</a>
<a name="ln1459">          typename basic_string_view&lt;Elem, Traits&gt;::iterator</a>
<a name="ln1460">        &gt;(data.begin())</a>
<a name="ln1461">#endif // BOOST_ASIO_ENABLE_BUFFER_DEBUGGING</a>
<a name="ln1462">      );</a>
<a name="ln1463">}</a>
<a name="ln1464"> </a>
<a name="ln1465">/// Create a new non-modifiable buffer that represents the given string.</a>
<a name="ln1466">/**</a>
<a name="ln1467"> * @returns A mutable_buffer value equivalent to:</a>
<a name="ln1468"> * @code mutable_buffer(</a>
<a name="ln1469"> *     data.size() ? &amp;data[0] : 0,</a>
<a name="ln1470"> *     min(data.size() * sizeof(Elem), max_size_in_bytes)); @endcode</a>
<a name="ln1471"> */</a>
<a name="ln1472">template &lt;typename Elem, typename Traits&gt;</a>
<a name="ln1473">inline BOOST_ASIO_CONST_BUFFER buffer(</a>
<a name="ln1474">    basic_string_view&lt;Elem, Traits&gt; data,</a>
<a name="ln1475">    std::size_t max_size_in_bytes) BOOST_ASIO_NOEXCEPT</a>
<a name="ln1476">{</a>
<a name="ln1477">  return BOOST_ASIO_CONST_BUFFER(data.size() ? &amp;data[0] : 0,</a>
<a name="ln1478">      data.size() * sizeof(Elem) &lt; max_size_in_bytes</a>
<a name="ln1479">      ? data.size() * sizeof(Elem) : max_size_in_bytes</a>
<a name="ln1480">#if defined(BOOST_ASIO_ENABLE_BUFFER_DEBUGGING)</a>
<a name="ln1481">      , detail::buffer_debug_check&lt;</a>
<a name="ln1482">          typename basic_string_view&lt;Elem, Traits&gt;::iterator</a>
<a name="ln1483">        &gt;(data.begin())</a>
<a name="ln1484">#endif // BOOST_ASIO_ENABLE_BUFFER_DEBUGGING</a>
<a name="ln1485">      );</a>
<a name="ln1486">}</a>
<a name="ln1487"> </a>
<a name="ln1488">#endif // defined(BOOST_ASIO_HAS_STRING_VIEW)</a>
<a name="ln1489">       //  || defined(GENERATING_DOCUMENTATION)</a>
<a name="ln1490"> </a>
<a name="ln1491">/*@}*/</a>
<a name="ln1492"> </a>
<a name="ln1493">/// Adapt a basic_string to the DynamicBuffer requirements.</a>
<a name="ln1494">/**</a>
<a name="ln1495"> * Requires that &lt;tt&gt;sizeof(Elem) == 1&lt;/tt&gt;.</a>
<a name="ln1496"> */</a>
<a name="ln1497">template &lt;typename Elem, typename Traits, typename Allocator&gt;</a>
<a name="ln1498">class dynamic_string_buffer</a>
<a name="ln1499">{</a>
<a name="ln1500">public:</a>
<a name="ln1501">  /// The type used to represent the input sequence as a list of buffers.</a>
<a name="ln1502">  typedef BOOST_ASIO_CONST_BUFFER const_buffers_type;</a>
<a name="ln1503"> </a>
<a name="ln1504">  /// The type used to represent the output sequence as a list of buffers.</a>
<a name="ln1505">  typedef BOOST_ASIO_MUTABLE_BUFFER mutable_buffers_type;</a>
<a name="ln1506"> </a>
<a name="ln1507">  /// Construct a dynamic buffer from a string.</a>
<a name="ln1508">  /**</a>
<a name="ln1509">   * @param s The string to be used as backing storage for the dynamic buffer.</a>
<a name="ln1510">   * Any existing data in the string is treated as the dynamic buffer's input</a>
<a name="ln1511">   * sequence. The object stores a reference to the string and the user is</a>
<a name="ln1512">   * responsible for ensuring that the string object remains valid until the</a>
<a name="ln1513">   * dynamic_string_buffer object is destroyed.</a>
<a name="ln1514">   *</a>
<a name="ln1515">   * @param maximum_size Specifies a maximum size for the buffer, in bytes.</a>
<a name="ln1516">   */</a>
<a name="ln1517">  explicit dynamic_string_buffer(std::basic_string&lt;Elem, Traits, Allocator&gt;&amp; s,</a>
<a name="ln1518">      std::size_t maximum_size =</a>
<a name="ln1519">        (std::numeric_limits&lt;std::size_t&gt;::max)()) BOOST_ASIO_NOEXCEPT</a>
<a name="ln1520">    : string_(s),</a>
<a name="ln1521">      size_(string_.size()),</a>
<a name="ln1522">      max_size_(maximum_size)</a>
<a name="ln1523">  {</a>
<a name="ln1524">  }</a>
<a name="ln1525"> </a>
<a name="ln1526">#if defined(BOOST_ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)</a>
<a name="ln1527">  /// Move construct a dynamic buffer.</a>
<a name="ln1528">  dynamic_string_buffer(dynamic_string_buffer&amp;&amp; other) BOOST_ASIO_NOEXCEPT</a>
<a name="ln1529">    : string_(other.string_),</a>
<a name="ln1530">      size_(other.size_),</a>
<a name="ln1531">      max_size_(other.max_size_)</a>
<a name="ln1532">  {</a>
<a name="ln1533">  }</a>
<a name="ln1534">#endif // defined(BOOST_ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)</a>
<a name="ln1535"> </a>
<a name="ln1536">  /// Get the size of the input sequence.</a>
<a name="ln1537">  std::size_t size() const BOOST_ASIO_NOEXCEPT</a>
<a name="ln1538">  {</a>
<a name="ln1539">    return size_;</a>
<a name="ln1540">  }</a>
<a name="ln1541"> </a>
<a name="ln1542">  /// Get the maximum size of the dynamic buffer.</a>
<a name="ln1543">  /**</a>
<a name="ln1544">   * @returns The allowed maximum of the sum of the sizes of the input sequence</a>
<a name="ln1545">   * and output sequence.</a>
<a name="ln1546">   */</a>
<a name="ln1547">  std::size_t max_size() const BOOST_ASIO_NOEXCEPT</a>
<a name="ln1548">  {</a>
<a name="ln1549">    return max_size_;</a>
<a name="ln1550">  }</a>
<a name="ln1551"> </a>
<a name="ln1552">  /// Get the current capacity of the dynamic buffer.</a>
<a name="ln1553">  /**</a>
<a name="ln1554">   * @returns The current total capacity of the buffer, i.e. for both the input</a>
<a name="ln1555">   * sequence and output sequence.</a>
<a name="ln1556">   */</a>
<a name="ln1557">  std::size_t capacity() const BOOST_ASIO_NOEXCEPT</a>
<a name="ln1558">  {</a>
<a name="ln1559">    return string_.capacity();</a>
<a name="ln1560">  }</a>
<a name="ln1561"> </a>
<a name="ln1562">  /// Get a list of buffers that represents the input sequence.</a>
<a name="ln1563">  /**</a>
<a name="ln1564">   * @returns An object of type @c const_buffers_type that satisfies</a>
<a name="ln1565">   * ConstBufferSequence requirements, representing the basic_string memory in</a>
<a name="ln1566">   * input sequence.</a>
<a name="ln1567">   *</a>
<a name="ln1568">   * @note The returned object is invalidated by any @c dynamic_string_buffer</a>
<a name="ln1569">   * or @c basic_string member function that modifies the input sequence or</a>
<a name="ln1570">   * output sequence.</a>
<a name="ln1571">   */</a>
<a name="ln1572">  const_buffers_type data() const BOOST_ASIO_NOEXCEPT</a>
<a name="ln1573">  {</a>
<a name="ln1574">    return const_buffers_type(boost::asio::buffer(string_, size_));</a>
<a name="ln1575">  }</a>
<a name="ln1576"> </a>
<a name="ln1577">  /// Get a list of buffers that represents the output sequence, with the given</a>
<a name="ln1578">  /// size.</a>
<a name="ln1579">  /**</a>
<a name="ln1580">   * Ensures that the output sequence can accommodate @c n bytes, resizing the</a>
<a name="ln1581">   * basic_string object as necessary.</a>
<a name="ln1582">   *</a>
<a name="ln1583">   * @returns An object of type @c mutable_buffers_type that satisfies</a>
<a name="ln1584">   * MutableBufferSequence requirements, representing basic_string memory</a>
<a name="ln1585">   * at the start of the output sequence of size @c n.</a>
<a name="ln1586">   *</a>
<a name="ln1587">   * @throws std::length_error If &lt;tt&gt;size() + n &gt; max_size()&lt;/tt&gt;.</a>
<a name="ln1588">   *</a>
<a name="ln1589">   * @note The returned object is invalidated by any @c dynamic_string_buffer</a>
<a name="ln1590">   * or @c basic_string member function that modifies the input sequence or</a>
<a name="ln1591">   * output sequence.</a>
<a name="ln1592">   */</a>
<a name="ln1593">  mutable_buffers_type prepare(std::size_t n)</a>
<a name="ln1594">  {</a>
<a name="ln1595">    if (size () &gt; max_size() || max_size() - size() &lt; n)</a>
<a name="ln1596">    {</a>
<a name="ln1597">      std::length_error ex(&quot;dynamic_string_buffer too long&quot;);</a>
<a name="ln1598">      boost::asio::detail::throw_exception(ex);</a>
<a name="ln1599">    }</a>
<a name="ln1600"> </a>
<a name="ln1601">    string_.resize(size_ + n);</a>
<a name="ln1602"> </a>
<a name="ln1603">    return boost::asio::buffer(boost::asio::buffer(string_) + size_, n);</a>
<a name="ln1604">  }</a>
<a name="ln1605"> </a>
<a name="ln1606">  /// Move bytes from the output sequence to the input sequence.</a>
<a name="ln1607">  /**</a>
<a name="ln1608">   * @param n The number of bytes to append from the start of the output</a>
<a name="ln1609">   * sequence to the end of the input sequence. The remainder of the output</a>
<a name="ln1610">   * sequence is discarded.</a>
<a name="ln1611">   *</a>
<a name="ln1612">   * Requires a preceding call &lt;tt&gt;prepare(x)&lt;/tt&gt; where &lt;tt&gt;x &gt;= n&lt;/tt&gt;, and</a>
<a name="ln1613">   * no intervening operations that modify the input or output sequence.</a>
<a name="ln1614">   *</a>
<a name="ln1615">   * @note If @c n is greater than the size of the output sequence, the entire</a>
<a name="ln1616">   * output sequence is moved to the input sequence and no error is issued.</a>
<a name="ln1617">   */</a>
<a name="ln1618">  void commit(std::size_t n)</a>
<a name="ln1619">  {</a>
<a name="ln1620">    size_ += (std::min)(n, string_.size() - size_);</a>
<a name="ln1621">    string_.resize(size_);</a>
<a name="ln1622">  }</a>
<a name="ln1623"> </a>
<a name="ln1624">  /// Remove characters from the input sequence.</a>
<a name="ln1625">  /**</a>
<a name="ln1626">   * Removes @c n characters from the beginning of the input sequence.</a>
<a name="ln1627">   *</a>
<a name="ln1628">   * @note If @c n is greater than the size of the input sequence, the entire</a>
<a name="ln1629">   * input sequence is consumed and no error is issued.</a>
<a name="ln1630">   */</a>
<a name="ln1631">  void consume(std::size_t n)</a>
<a name="ln1632">  {</a>
<a name="ln1633">    std::size_t consume_length = (std::min)(n, size_);</a>
<a name="ln1634">    string_.erase(0, consume_length);</a>
<a name="ln1635">    size_ -= consume_length;</a>
<a name="ln1636">  }</a>
<a name="ln1637"> </a>
<a name="ln1638">private:</a>
<a name="ln1639">  std::basic_string&lt;Elem, Traits, Allocator&gt;&amp; string_;</a>
<a name="ln1640">  std::size_t size_;</a>
<a name="ln1641">  const std::size_t max_size_;</a>
<a name="ln1642">};</a>
<a name="ln1643"> </a>
<a name="ln1644">/// Adapt a vector to the DynamicBuffer requirements.</a>
<a name="ln1645">/**</a>
<a name="ln1646"> * Requires that &lt;tt&gt;sizeof(Elem) == 1&lt;/tt&gt;.</a>
<a name="ln1647"> */</a>
<a name="ln1648">template &lt;typename Elem, typename Allocator&gt;</a>
<a name="ln1649">class dynamic_vector_buffer</a>
<a name="ln1650">{</a>
<a name="ln1651">public:</a>
<a name="ln1652">  /// The type used to represent the input sequence as a list of buffers.</a>
<a name="ln1653">  typedef BOOST_ASIO_CONST_BUFFER const_buffers_type;</a>
<a name="ln1654"> </a>
<a name="ln1655">  /// The type used to represent the output sequence as a list of buffers.</a>
<a name="ln1656">  typedef BOOST_ASIO_MUTABLE_BUFFER mutable_buffers_type;</a>
<a name="ln1657"> </a>
<a name="ln1658">  /// Construct a dynamic buffer from a string.</a>
<a name="ln1659">  /**</a>
<a name="ln1660">   * @param v The vector to be used as backing storage for the dynamic buffer.</a>
<a name="ln1661">   * Any existing data in the vector is treated as the dynamic buffer's input</a>
<a name="ln1662">   * sequence. The object stores a reference to the vector and the user is</a>
<a name="ln1663">   * responsible for ensuring that the vector object remains valid until the</a>
<a name="ln1664">   * dynamic_vector_buffer object is destroyed.</a>
<a name="ln1665">   *</a>
<a name="ln1666">   * @param maximum_size Specifies a maximum size for the buffer, in bytes.</a>
<a name="ln1667">   */</a>
<a name="ln1668">  explicit dynamic_vector_buffer(std::vector&lt;Elem, Allocator&gt;&amp; v,</a>
<a name="ln1669">      std::size_t maximum_size =</a>
<a name="ln1670">        (std::numeric_limits&lt;std::size_t&gt;::max)()) BOOST_ASIO_NOEXCEPT</a>
<a name="ln1671">    : vector_(v),</a>
<a name="ln1672">      size_(vector_.size()),</a>
<a name="ln1673">      max_size_(maximum_size)</a>
<a name="ln1674">  {</a>
<a name="ln1675">  }</a>
<a name="ln1676"> </a>
<a name="ln1677">#if defined(BOOST_ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)</a>
<a name="ln1678">  /// Move construct a dynamic buffer.</a>
<a name="ln1679">  dynamic_vector_buffer(dynamic_vector_buffer&amp;&amp; other) BOOST_ASIO_NOEXCEPT</a>
<a name="ln1680">    : vector_(other.vector_),</a>
<a name="ln1681">      size_(other.size_),</a>
<a name="ln1682">      max_size_(other.max_size_)</a>
<a name="ln1683">  {</a>
<a name="ln1684">  }</a>
<a name="ln1685">#endif // defined(BOOST_ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)</a>
<a name="ln1686"> </a>
<a name="ln1687">  /// Get the size of the input sequence.</a>
<a name="ln1688">  std::size_t size() const BOOST_ASIO_NOEXCEPT</a>
<a name="ln1689">  {</a>
<a name="ln1690">    return size_;</a>
<a name="ln1691">  }</a>
<a name="ln1692"> </a>
<a name="ln1693">  /// Get the maximum size of the dynamic buffer.</a>
<a name="ln1694">  /**</a>
<a name="ln1695">   * @returns The allowed maximum of the sum of the sizes of the input sequence</a>
<a name="ln1696">   * and output sequence.</a>
<a name="ln1697">   */</a>
<a name="ln1698">  std::size_t max_size() const BOOST_ASIO_NOEXCEPT</a>
<a name="ln1699">  {</a>
<a name="ln1700">    return max_size_;</a>
<a name="ln1701">  }</a>
<a name="ln1702"> </a>
<a name="ln1703">  /// Get the current capacity of the dynamic buffer.</a>
<a name="ln1704">  /**</a>
<a name="ln1705">   * @returns The current total capacity of the buffer, i.e. for both the input</a>
<a name="ln1706">   * sequence and output sequence.</a>
<a name="ln1707">   */</a>
<a name="ln1708">  std::size_t capacity() const BOOST_ASIO_NOEXCEPT</a>
<a name="ln1709">  {</a>
<a name="ln1710">    return vector_.capacity();</a>
<a name="ln1711">  }</a>
<a name="ln1712"> </a>
<a name="ln1713">  /// Get a list of buffers that represents the input sequence.</a>
<a name="ln1714">  /**</a>
<a name="ln1715">   * @returns An object of type @c const_buffers_type that satisfies</a>
<a name="ln1716">   * ConstBufferSequence requirements, representing the basic_string memory in</a>
<a name="ln1717">   * input sequence.</a>
<a name="ln1718">   *</a>
<a name="ln1719">   * @note The returned object is invalidated by any @c dynamic_vector_buffer</a>
<a name="ln1720">   * or @c basic_string member function that modifies the input sequence or</a>
<a name="ln1721">   * output sequence.</a>
<a name="ln1722">   */</a>
<a name="ln1723">  const_buffers_type data() const BOOST_ASIO_NOEXCEPT</a>
<a name="ln1724">  {</a>
<a name="ln1725">    return const_buffers_type(boost::asio::buffer(vector_, size_));</a>
<a name="ln1726">  }</a>
<a name="ln1727"> </a>
<a name="ln1728">  /// Get a list of buffers that represents the output sequence, with the given</a>
<a name="ln1729">  /// size.</a>
<a name="ln1730">  /**</a>
<a name="ln1731">   * Ensures that the output sequence can accommodate @c n bytes, resizing the</a>
<a name="ln1732">   * basic_string object as necessary.</a>
<a name="ln1733">   *</a>
<a name="ln1734">   * @returns An object of type @c mutable_buffers_type that satisfies</a>
<a name="ln1735">   * MutableBufferSequence requirements, representing basic_string memory</a>
<a name="ln1736">   * at the start of the output sequence of size @c n.</a>
<a name="ln1737">   *</a>
<a name="ln1738">   * @throws std::length_error If &lt;tt&gt;size() + n &gt; max_size()&lt;/tt&gt;.</a>
<a name="ln1739">   *</a>
<a name="ln1740">   * @note The returned object is invalidated by any @c dynamic_vector_buffer</a>
<a name="ln1741">   * or @c basic_string member function that modifies the input sequence or</a>
<a name="ln1742">   * output sequence.</a>
<a name="ln1743">   */</a>
<a name="ln1744">  mutable_buffers_type prepare(std::size_t n)</a>
<a name="ln1745">  {</a>
<a name="ln1746">    if (size () &gt; max_size() || max_size() - size() &lt; n)</a>
<a name="ln1747">    {</a>
<a name="ln1748">      std::length_error ex(&quot;dynamic_vector_buffer too long&quot;);</a>
<a name="ln1749">      boost::asio::detail::throw_exception(ex);</a>
<a name="ln1750">    }</a>
<a name="ln1751"> </a>
<a name="ln1752">    vector_.resize(size_ + n);</a>
<a name="ln1753"> </a>
<a name="ln1754">    return boost::asio::buffer(boost::asio::buffer(vector_) + size_, n);</a>
<a name="ln1755">  }</a>
<a name="ln1756"> </a>
<a name="ln1757">  /// Move bytes from the output sequence to the input sequence.</a>
<a name="ln1758">  /**</a>
<a name="ln1759">   * @param n The number of bytes to append from the start of the output</a>
<a name="ln1760">   * sequence to the end of the input sequence. The remainder of the output</a>
<a name="ln1761">   * sequence is discarded.</a>
<a name="ln1762">   *</a>
<a name="ln1763">   * Requires a preceding call &lt;tt&gt;prepare(x)&lt;/tt&gt; where &lt;tt&gt;x &gt;= n&lt;/tt&gt;, and</a>
<a name="ln1764">   * no intervening operations that modify the input or output sequence.</a>
<a name="ln1765">   *</a>
<a name="ln1766">   * @note If @c n is greater than the size of the output sequence, the entire</a>
<a name="ln1767">   * output sequence is moved to the input sequence and no error is issued.</a>
<a name="ln1768">   */</a>
<a name="ln1769">  void commit(std::size_t n)</a>
<a name="ln1770">  {</a>
<a name="ln1771">    size_ += (std::min)(n, vector_.size() - size_);</a>
<a name="ln1772">    vector_.resize(size_);</a>
<a name="ln1773">  }</a>
<a name="ln1774"> </a>
<a name="ln1775">  /// Remove characters from the input sequence.</a>
<a name="ln1776">  /**</a>
<a name="ln1777">   * Removes @c n characters from the beginning of the input sequence.</a>
<a name="ln1778">   *</a>
<a name="ln1779">   * @note If @c n is greater than the size of the input sequence, the entire</a>
<a name="ln1780">   * input sequence is consumed and no error is issued.</a>
<a name="ln1781">   */</a>
<a name="ln1782">  void consume(std::size_t n)</a>
<a name="ln1783">  {</a>
<a name="ln1784">    std::size_t consume_length = (std::min)(n, size_);</a>
<a name="ln1785">    vector_.erase(vector_.begin(), vector_.begin() + consume_length);</a>
<a name="ln1786">    size_ -= consume_length;</a>
<a name="ln1787">  }</a>
<a name="ln1788"> </a>
<a name="ln1789">private:</a>
<a name="ln1790">  std::vector&lt;Elem, Allocator&gt;&amp; vector_;</a>
<a name="ln1791">  std::size_t size_;</a>
<a name="ln1792">  const std::size_t max_size_;</a>
<a name="ln1793">};</a>
<a name="ln1794"> </a>
<a name="ln1795">/** @defgroup dynamic_buffer boost::asio::dynamic_buffer</a>
<a name="ln1796"> *</a>
<a name="ln1797"> * @brief The boost::asio::dynamic_buffer function is used to create a</a>
<a name="ln1798"> * dynamically resized buffer from a @c std::basic_string or @c std::vector.</a>
<a name="ln1799"> */</a>
<a name="ln1800">/*@{*/</a>
<a name="ln1801"> </a>
<a name="ln1802">/// Create a new dynamic buffer that represents the given string.</a>
<a name="ln1803">/**</a>
<a name="ln1804"> * @returns &lt;tt&gt;dynamic_string_buffer&lt;Elem, Traits, Allocator&gt;(data)&lt;/tt&gt;.</a>
<a name="ln1805"> */</a>
<a name="ln1806">template &lt;typename Elem, typename Traits, typename Allocator&gt;</a>
<a name="ln1807">inline dynamic_string_buffer&lt;Elem, Traits, Allocator&gt; dynamic_buffer(</a>
<a name="ln1808">    std::basic_string&lt;Elem, Traits, Allocator&gt;&amp; data) BOOST_ASIO_NOEXCEPT</a>
<a name="ln1809">{</a>
<a name="ln1810">  return dynamic_string_buffer&lt;Elem, Traits, Allocator&gt;(data);</a>
<a name="ln1811">}</a>
<a name="ln1812"> </a>
<a name="ln1813">/// Create a new dynamic buffer that represents the given string.</a>
<a name="ln1814">/**</a>
<a name="ln1815"> * @returns &lt;tt&gt;dynamic_string_buffer&lt;Elem, Traits, Allocator&gt;(data,</a>
<a name="ln1816"> * max_size)&lt;/tt&gt;.</a>
<a name="ln1817"> */</a>
<a name="ln1818">template &lt;typename Elem, typename Traits, typename Allocator&gt;</a>
<a name="ln1819">inline dynamic_string_buffer&lt;Elem, Traits, Allocator&gt; dynamic_buffer(</a>
<a name="ln1820">    std::basic_string&lt;Elem, Traits, Allocator&gt;&amp; data,</a>
<a name="ln1821">    std::size_t max_size) BOOST_ASIO_NOEXCEPT</a>
<a name="ln1822">{</a>
<a name="ln1823">  return dynamic_string_buffer&lt;Elem, Traits, Allocator&gt;(data, max_size);</a>
<a name="ln1824">}</a>
<a name="ln1825"> </a>
<a name="ln1826">/// Create a new dynamic buffer that represents the given vector.</a>
<a name="ln1827">/**</a>
<a name="ln1828"> * @returns &lt;tt&gt;dynamic_vector_buffer&lt;Elem, Allocator&gt;(data)&lt;/tt&gt;.</a>
<a name="ln1829"> */</a>
<a name="ln1830">template &lt;typename Elem, typename Allocator&gt;</a>
<a name="ln1831">inline dynamic_vector_buffer&lt;Elem, Allocator&gt; dynamic_buffer(</a>
<a name="ln1832">    std::vector&lt;Elem, Allocator&gt;&amp; data) BOOST_ASIO_NOEXCEPT</a>
<a name="ln1833">{</a>
<a name="ln1834">  return dynamic_vector_buffer&lt;Elem, Allocator&gt;(data);</a>
<a name="ln1835">}</a>
<a name="ln1836"> </a>
<a name="ln1837">/// Create a new dynamic buffer that represents the given vector.</a>
<a name="ln1838">/**</a>
<a name="ln1839"> * @returns &lt;tt&gt;dynamic_vector_buffer&lt;Elem, Allocator&gt;(data, max_size)&lt;/tt&gt;.</a>
<a name="ln1840"> */</a>
<a name="ln1841">template &lt;typename Elem, typename Allocator&gt;</a>
<a name="ln1842">inline dynamic_vector_buffer&lt;Elem, Allocator&gt; dynamic_buffer(</a>
<a name="ln1843">    std::vector&lt;Elem, Allocator&gt;&amp; data,</a>
<a name="ln1844">    std::size_t max_size) BOOST_ASIO_NOEXCEPT</a>
<a name="ln1845">{</a>
<a name="ln1846">  return dynamic_vector_buffer&lt;Elem, Allocator&gt;(data, max_size);</a>
<a name="ln1847">}</a>
<a name="ln1848"> </a>
<a name="ln1849">/*@}*/</a>
<a name="ln1850"> </a>
<a name="ln1851">/** @defgroup buffer_copy boost::asio::buffer_copy</a>
<a name="ln1852"> *</a>
<a name="ln1853"> * @brief The boost::asio::buffer_copy function is used to copy bytes from a</a>
<a name="ln1854"> * source buffer (or buffer sequence) to a target buffer (or buffer sequence).</a>
<a name="ln1855"> *</a>
<a name="ln1856"> * The @c buffer_copy function is available in two forms:</a>
<a name="ln1857"> *</a>
<a name="ln1858"> * @li A 2-argument form: @c buffer_copy(target, source)</a>
<a name="ln1859"> *</a>
<a name="ln1860"> * @li A 3-argument form: @c buffer_copy(target, source, max_bytes_to_copy)</a>
<a name="ln1861"> *</a>
<a name="ln1862"> * Both forms return the number of bytes actually copied. The number of bytes</a>
<a name="ln1863"> * copied is the lesser of:</a>
<a name="ln1864"> *</a>
<a name="ln1865"> * @li @c buffer_size(target)</a>
<a name="ln1866"> *</a>
<a name="ln1867"> * @li @c buffer_size(source)</a>
<a name="ln1868"> *</a>
<a name="ln1869"> * @li @c If specified, @c max_bytes_to_copy.</a>
<a name="ln1870"> *</a>
<a name="ln1871"> * This prevents buffer overflow, regardless of the buffer sizes used in the</a>
<a name="ln1872"> * copy operation.</a>
<a name="ln1873"> *</a>
<a name="ln1874"> * Note that @ref buffer_copy is implemented in terms of @c memcpy, and</a>
<a name="ln1875"> * consequently it cannot be used to copy between overlapping memory regions.</a>
<a name="ln1876"> */</a>
<a name="ln1877">/*@{*/</a>
<a name="ln1878"> </a>
<a name="ln1879">namespace detail {</a>
<a name="ln1880"> </a>
<a name="ln1881">inline std::size_t buffer_copy_1(const mutable_buffer&amp; target,</a>
<a name="ln1882">    const const_buffer&amp; source)</a>
<a name="ln1883">{</a>
<a name="ln1884">  using namespace std; // For memcpy.</a>
<a name="ln1885">  std::size_t target_size = target.size();</a>
<a name="ln1886">  std::size_t source_size = source.size();</a>
<a name="ln1887">  std::size_t n = target_size &lt; source_size ? target_size : source_size;</a>
<a name="ln1888">  if (n &gt; 0)</a>
<a name="ln1889">    memcpy(target.data(), source.data(), n);</a>
<a name="ln1890">  return n;</a>
<a name="ln1891">}</a>
<a name="ln1892"> </a>
<a name="ln1893">template &lt;typename TargetIterator, typename SourceIterator&gt;</a>
<a name="ln1894">inline std::size_t buffer_copy(one_buffer, one_buffer,</a>
<a name="ln1895">    TargetIterator target_begin, TargetIterator,</a>
<a name="ln1896">    SourceIterator source_begin, SourceIterator) BOOST_ASIO_NOEXCEPT</a>
<a name="ln1897">{</a>
<a name="ln1898">  return (buffer_copy_1)(*target_begin, *source_begin);</a>
<a name="ln1899">}</a>
<a name="ln1900"> </a>
<a name="ln1901">template &lt;typename TargetIterator, typename SourceIterator&gt;</a>
<a name="ln1902">inline std::size_t buffer_copy(one_buffer, one_buffer,</a>
<a name="ln1903">    TargetIterator target_begin, TargetIterator,</a>
<a name="ln1904">    SourceIterator source_begin, SourceIterator,</a>
<a name="ln1905">    std::size_t max_bytes_to_copy) BOOST_ASIO_NOEXCEPT</a>
<a name="ln1906">{</a>
<a name="ln1907">  return (buffer_copy_1)(*target_begin,</a>
<a name="ln1908">      boost::asio::buffer(*source_begin, max_bytes_to_copy));</a>
<a name="ln1909">}</a>
<a name="ln1910"> </a>
<a name="ln1911">template &lt;typename TargetIterator, typename SourceIterator&gt;</a>
<a name="ln1912">std::size_t buffer_copy(one_buffer, multiple_buffers,</a>
<a name="ln1913">    TargetIterator target_begin, TargetIterator,</a>
<a name="ln1914">    SourceIterator source_begin, SourceIterator source_end,</a>
<a name="ln1915">    std::size_t max_bytes_to_copy</a>
<a name="ln1916">      = (std::numeric_limits&lt;std::size_t&gt;::max)()) BOOST_ASIO_NOEXCEPT</a>
<a name="ln1917">{</a>
<a name="ln1918">  std::size_t total_bytes_copied = 0;</a>
<a name="ln1919">  SourceIterator source_iter = source_begin;</a>
<a name="ln1920"> </a>
<a name="ln1921">  for (mutable_buffer target_buffer(</a>
<a name="ln1922">        boost::asio::buffer(*target_begin, max_bytes_to_copy));</a>
<a name="ln1923">      target_buffer.size() &amp;&amp; source_iter != source_end; ++source_iter)</a>
<a name="ln1924">  {</a>
<a name="ln1925">    const_buffer source_buffer(*source_iter);</a>
<a name="ln1926">    std::size_t bytes_copied = (buffer_copy_1)(target_buffer, source_buffer);</a>
<a name="ln1927">    total_bytes_copied += bytes_copied;</a>
<a name="ln1928">    target_buffer += bytes_copied;</a>
<a name="ln1929">  }</a>
<a name="ln1930"> </a>
<a name="ln1931">  return total_bytes_copied;</a>
<a name="ln1932">}</a>
<a name="ln1933"> </a>
<a name="ln1934">template &lt;typename TargetIterator, typename SourceIterator&gt;</a>
<a name="ln1935">std::size_t buffer_copy(multiple_buffers, one_buffer,</a>
<a name="ln1936">    TargetIterator target_begin, TargetIterator target_end,</a>
<a name="ln1937">    SourceIterator source_begin, SourceIterator,</a>
<a name="ln1938">    std::size_t max_bytes_to_copy</a>
<a name="ln1939">      = (std::numeric_limits&lt;std::size_t&gt;::max)()) BOOST_ASIO_NOEXCEPT</a>
<a name="ln1940">{</a>
<a name="ln1941">  std::size_t total_bytes_copied = 0;</a>
<a name="ln1942">  TargetIterator target_iter = target_begin;</a>
<a name="ln1943"> </a>
<a name="ln1944">  for (const_buffer source_buffer(</a>
<a name="ln1945">        boost::asio::buffer(*source_begin, max_bytes_to_copy));</a>
<a name="ln1946">      source_buffer.size() &amp;&amp; target_iter != target_end; ++target_iter)</a>
<a name="ln1947">  {</a>
<a name="ln1948">    mutable_buffer target_buffer(*target_iter);</a>
<a name="ln1949">    std::size_t bytes_copied = (buffer_copy_1)(target_buffer, source_buffer);</a>
<a name="ln1950">    total_bytes_copied += bytes_copied;</a>
<a name="ln1951">    source_buffer += bytes_copied;</a>
<a name="ln1952">  }</a>
<a name="ln1953"> </a>
<a name="ln1954">  return total_bytes_copied;</a>
<a name="ln1955">}</a>
<a name="ln1956"> </a>
<a name="ln1957">template &lt;typename TargetIterator, typename SourceIterator&gt;</a>
<a name="ln1958">std::size_t buffer_copy(multiple_buffers, multiple_buffers,</a>
<a name="ln1959">    TargetIterator target_begin, TargetIterator target_end,</a>
<a name="ln1960">    SourceIterator source_begin, SourceIterator source_end) BOOST_ASIO_NOEXCEPT</a>
<a name="ln1961">{</a>
<a name="ln1962">  std::size_t total_bytes_copied = 0;</a>
<a name="ln1963"> </a>
<a name="ln1964">  TargetIterator target_iter = target_begin;</a>
<a name="ln1965">  std::size_t target_buffer_offset = 0;</a>
<a name="ln1966"> </a>
<a name="ln1967">  SourceIterator source_iter = source_begin;</a>
<a name="ln1968">  std::size_t source_buffer_offset = 0;</a>
<a name="ln1969"> </a>
<a name="ln1970">  while (target_iter != target_end &amp;&amp; source_iter != source_end)</a>
<a name="ln1971">  {</a>
<a name="ln1972">    mutable_buffer target_buffer =</a>
<a name="ln1973">      mutable_buffer(*target_iter) + target_buffer_offset;</a>
<a name="ln1974"> </a>
<a name="ln1975">    const_buffer source_buffer =</a>
<a name="ln1976">      const_buffer(*source_iter) + source_buffer_offset;</a>
<a name="ln1977"> </a>
<a name="ln1978">    std::size_t bytes_copied = (buffer_copy_1)(target_buffer, source_buffer);</a>
<a name="ln1979">    total_bytes_copied += bytes_copied;</a>
<a name="ln1980"> </a>
<a name="ln1981">    if (bytes_copied == target_buffer.size())</a>
<a name="ln1982">    {</a>
<a name="ln1983">      ++target_iter;</a>
<a name="ln1984">      target_buffer_offset = 0;</a>
<a name="ln1985">    }</a>
<a name="ln1986">    else</a>
<a name="ln1987">      target_buffer_offset += bytes_copied;</a>
<a name="ln1988"> </a>
<a name="ln1989">    if (bytes_copied == source_buffer.size())</a>
<a name="ln1990">    {</a>
<a name="ln1991">      ++source_iter;</a>
<a name="ln1992">      source_buffer_offset = 0;</a>
<a name="ln1993">    }</a>
<a name="ln1994">    else</a>
<a name="ln1995">      source_buffer_offset += bytes_copied;</a>
<a name="ln1996">  }</a>
<a name="ln1997"> </a>
<a name="ln1998">  return total_bytes_copied;</a>
<a name="ln1999">}</a>
<a name="ln2000"> </a>
<a name="ln2001">template &lt;typename TargetIterator, typename SourceIterator&gt;</a>
<a name="ln2002">std::size_t buffer_copy(multiple_buffers, multiple_buffers,</a>
<a name="ln2003">    TargetIterator target_begin, TargetIterator target_end,</a>
<a name="ln2004">    SourceIterator source_begin, SourceIterator source_end,</a>
<a name="ln2005">    std::size_t max_bytes_to_copy) BOOST_ASIO_NOEXCEPT</a>
<a name="ln2006">{</a>
<a name="ln2007">  std::size_t total_bytes_copied = 0;</a>
<a name="ln2008"> </a>
<a name="ln2009">  TargetIterator target_iter = target_begin;</a>
<a name="ln2010">  std::size_t target_buffer_offset = 0;</a>
<a name="ln2011"> </a>
<a name="ln2012">  SourceIterator source_iter = source_begin;</a>
<a name="ln2013">  std::size_t source_buffer_offset = 0;</a>
<a name="ln2014"> </a>
<a name="ln2015">  while (total_bytes_copied != max_bytes_to_copy</a>
<a name="ln2016">      &amp;&amp; target_iter != target_end &amp;&amp; source_iter != source_end)</a>
<a name="ln2017">  {</a>
<a name="ln2018">    mutable_buffer target_buffer =</a>
<a name="ln2019">      mutable_buffer(*target_iter) + target_buffer_offset;</a>
<a name="ln2020"> </a>
<a name="ln2021">    const_buffer source_buffer =</a>
<a name="ln2022">      const_buffer(*source_iter) + source_buffer_offset;</a>
<a name="ln2023"> </a>
<a name="ln2024">    std::size_t bytes_copied = (buffer_copy_1)(</a>
<a name="ln2025">        target_buffer, boost::asio::buffer(source_buffer,</a>
<a name="ln2026">          max_bytes_to_copy - total_bytes_copied));</a>
<a name="ln2027">    total_bytes_copied += bytes_copied;</a>
<a name="ln2028"> </a>
<a name="ln2029">    if (bytes_copied == target_buffer.size())</a>
<a name="ln2030">    {</a>
<a name="ln2031">      ++target_iter;</a>
<a name="ln2032">      target_buffer_offset = 0;</a>
<a name="ln2033">    }</a>
<a name="ln2034">    else</a>
<a name="ln2035">      target_buffer_offset += bytes_copied;</a>
<a name="ln2036"> </a>
<a name="ln2037">    if (bytes_copied == source_buffer.size())</a>
<a name="ln2038">    {</a>
<a name="ln2039">      ++source_iter;</a>
<a name="ln2040">      source_buffer_offset = 0;</a>
<a name="ln2041">    }</a>
<a name="ln2042">    else</a>
<a name="ln2043">      source_buffer_offset += bytes_copied;</a>
<a name="ln2044">  }</a>
<a name="ln2045"> </a>
<a name="ln2046">  return total_bytes_copied;</a>
<a name="ln2047">}</a>
<a name="ln2048"> </a>
<a name="ln2049">} // namespace detail</a>
<a name="ln2050"> </a>
<a name="ln2051">/// Copies bytes from a source buffer sequence to a target buffer sequence.</a>
<a name="ln2052">/**</a>
<a name="ln2053"> * @param target A modifiable buffer sequence representing the memory regions to</a>
<a name="ln2054"> * which the bytes will be copied.</a>
<a name="ln2055"> *</a>
<a name="ln2056"> * @param source A non-modifiable buffer sequence representing the memory</a>
<a name="ln2057"> * regions from which the bytes will be copied.</a>
<a name="ln2058"> *</a>
<a name="ln2059"> * @returns The number of bytes copied.</a>
<a name="ln2060"> *</a>
<a name="ln2061"> * @note The number of bytes copied is the lesser of:</a>
<a name="ln2062"> *</a>
<a name="ln2063"> * @li @c buffer_size(target)</a>
<a name="ln2064"> *</a>
<a name="ln2065"> * @li @c buffer_size(source)</a>
<a name="ln2066"> *</a>
<a name="ln2067"> * This function is implemented in terms of @c memcpy, and consequently it</a>
<a name="ln2068"> * cannot be used to copy between overlapping memory regions.</a>
<a name="ln2069"> */</a>
<a name="ln2070">template &lt;typename MutableBufferSequence, typename ConstBufferSequence&gt;</a>
<a name="ln2071">inline std::size_t buffer_copy(const MutableBufferSequence&amp; target,</a>
<a name="ln2072">    const ConstBufferSequence&amp; source) BOOST_ASIO_NOEXCEPT</a>
<a name="ln2073">{</a>
<a name="ln2074">  return detail::buffer_copy(</a>
<a name="ln2075">      detail::buffer_sequence_cardinality&lt;MutableBufferSequence&gt;(),</a>
<a name="ln2076">      detail::buffer_sequence_cardinality&lt;ConstBufferSequence&gt;(),</a>
<a name="ln2077">      boost::asio::buffer_sequence_begin(target),</a>
<a name="ln2078">      boost::asio::buffer_sequence_end(target),</a>
<a name="ln2079">      boost::asio::buffer_sequence_begin(source),</a>
<a name="ln2080">      boost::asio::buffer_sequence_end(source));</a>
<a name="ln2081">}</a>
<a name="ln2082"> </a>
<a name="ln2083">/// Copies a limited number of bytes from a source buffer sequence to a target</a>
<a name="ln2084">/// buffer sequence.</a>
<a name="ln2085">/**</a>
<a name="ln2086"> * @param target A modifiable buffer sequence representing the memory regions to</a>
<a name="ln2087"> * which the bytes will be copied.</a>
<a name="ln2088"> *</a>
<a name="ln2089"> * @param source A non-modifiable buffer sequence representing the memory</a>
<a name="ln2090"> * regions from which the bytes will be copied.</a>
<a name="ln2091"> *</a>
<a name="ln2092"> * @param max_bytes_to_copy The maximum number of bytes to be copied.</a>
<a name="ln2093"> *</a>
<a name="ln2094"> * @returns The number of bytes copied.</a>
<a name="ln2095"> *</a>
<a name="ln2096"> * @note The number of bytes copied is the lesser of:</a>
<a name="ln2097"> *</a>
<a name="ln2098"> * @li @c buffer_size(target)</a>
<a name="ln2099"> *</a>
<a name="ln2100"> * @li @c buffer_size(source)</a>
<a name="ln2101"> *</a>
<a name="ln2102"> * @li @c max_bytes_to_copy</a>
<a name="ln2103"> *</a>
<a name="ln2104"> * This function is implemented in terms of @c memcpy, and consequently it</a>
<a name="ln2105"> * cannot be used to copy between overlapping memory regions.</a>
<a name="ln2106"> */</a>
<a name="ln2107">template &lt;typename MutableBufferSequence, typename ConstBufferSequence&gt;</a>
<a name="ln2108">inline std::size_t buffer_copy(const MutableBufferSequence&amp; target,</a>
<a name="ln2109">    const ConstBufferSequence&amp; source,</a>
<a name="ln2110">    std::size_t max_bytes_to_copy) BOOST_ASIO_NOEXCEPT</a>
<a name="ln2111">{</a>
<a name="ln2112">  return detail::buffer_copy(</a>
<a name="ln2113">      detail::buffer_sequence_cardinality&lt;MutableBufferSequence&gt;(),</a>
<a name="ln2114">      detail::buffer_sequence_cardinality&lt;ConstBufferSequence&gt;(),</a>
<a name="ln2115">      boost::asio::buffer_sequence_begin(target),</a>
<a name="ln2116">      boost::asio::buffer_sequence_end(target),</a>
<a name="ln2117">      boost::asio::buffer_sequence_begin(source),</a>
<a name="ln2118">      boost::asio::buffer_sequence_end(source), max_bytes_to_copy);</a>
<a name="ln2119">}</a>
<a name="ln2120"> </a>
<a name="ln2121">/*@}*/</a>
<a name="ln2122"> </a>
<a name="ln2123">} // namespace asio</a>
<a name="ln2124">} // namespace boost</a>
<a name="ln2125"> </a>
<a name="ln2126">#include &lt;boost/asio/detail/pop_options.hpp&gt;</a>
<a name="ln2127">#include &lt;boost/asio/detail/is_buffer_sequence.hpp&gt;</a>
<a name="ln2128">#include &lt;boost/asio/detail/push_options.hpp&gt;</a>
<a name="ln2129"> </a>
<a name="ln2130">namespace boost {</a>
<a name="ln2131">namespace asio {</a>
<a name="ln2132"> </a>
<a name="ln2133">/// Trait to determine whether a type satisfies the MutableBufferSequence</a>
<a name="ln2134">/// requirements.</a>
<a name="ln2135">template &lt;typename T&gt;</a>
<a name="ln2136">struct is_mutable_buffer_sequence</a>
<a name="ln2137">#if defined(GENERATING_DOCUMENTATION)</a>
<a name="ln2138">  : integral_constant&lt;bool, automatically_determined&gt;</a>
<a name="ln2139">#else // defined(GENERATING_DOCUMENTATION)</a>
<a name="ln2140">  : boost::asio::detail::is_buffer_sequence&lt;T, mutable_buffer&gt;</a>
<a name="ln2141">#endif // defined(GENERATING_DOCUMENTATION)</a>
<a name="ln2142">{</a>
<a name="ln2143">};</a>
<a name="ln2144"> </a>
<a name="ln2145">/// Trait to determine whether a type satisfies the ConstBufferSequence</a>
<a name="ln2146">/// requirements.</a>
<a name="ln2147">template &lt;typename T&gt;</a>
<a name="ln2148">struct is_const_buffer_sequence</a>
<a name="ln2149">#if defined(GENERATING_DOCUMENTATION)</a>
<a name="ln2150">  : integral_constant&lt;bool, automatically_determined&gt;</a>
<a name="ln2151">#else // defined(GENERATING_DOCUMENTATION)</a>
<a name="ln2152">  : boost::asio::detail::is_buffer_sequence&lt;T, const_buffer&gt;</a>
<a name="ln2153">#endif // defined(GENERATING_DOCUMENTATION)</a>
<a name="ln2154">{</a>
<a name="ln2155">};</a>
<a name="ln2156"> </a>
<a name="ln2157">/// Trait to determine whether a type satisfies the DynamicBuffer requirements.</a>
<a name="ln2158">template &lt;typename T&gt;</a>
<a name="ln2159">struct is_dynamic_buffer</a>
<a name="ln2160">#if defined(GENERATING_DOCUMENTATION)</a>
<a name="ln2161">  : integral_constant&lt;bool, automatically_determined&gt;</a>
<a name="ln2162">#else // defined(GENERATING_DOCUMENTATION)</a>
<a name="ln2163">  : boost::asio::detail::is_dynamic_buffer&lt;T&gt;</a>
<a name="ln2164">#endif // defined(GENERATING_DOCUMENTATION)</a>
<a name="ln2165">{</a>
<a name="ln2166">};</a>
<a name="ln2167"> </a>
<a name="ln2168">} // namespace asio</a>
<a name="ln2169">} // namespace boost</a>
<a name="ln2170"> </a>
<a name="ln2171">#include &lt;boost/asio/detail/pop_options.hpp&gt;</a>
<a name="ln2172"> </a>
<a name="ln2173">#endif // BOOST_ASIO_BUFFER_HPP</a>

</code></pre>
<div class="balloon" rel="368"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v524/" target="_blank">V524</a> It is odd that the body of 'end' function is fully equivalent to the body of 'begin' function.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
