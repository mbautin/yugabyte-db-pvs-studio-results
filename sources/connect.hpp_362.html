
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>connect.hpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//</a>
<a name="ln2">// impl/connect.hpp</a>
<a name="ln3">// ~~~~~~~~~~~~~~~~</a>
<a name="ln4">//</a>
<a name="ln5">// Copyright (c) 2003-2018 Christopher M. Kohlhoff (chris at kohlhoff dot com)</a>
<a name="ln6">//</a>
<a name="ln7">// Distributed under the Boost Software License, Version 1.0. (See accompanying</a>
<a name="ln8">// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)</a>
<a name="ln9">//</a>
<a name="ln10"> </a>
<a name="ln11">#ifndef BOOST_ASIO_IMPL_CONNECT_HPP</a>
<a name="ln12">#define BOOST_ASIO_IMPL_CONNECT_HPP</a>
<a name="ln13"> </a>
<a name="ln14">#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1200)</a>
<a name="ln15"># pragma once</a>
<a name="ln16">#endif // defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1200)</a>
<a name="ln17"> </a>
<a name="ln18">#include &lt;algorithm&gt;</a>
<a name="ln19">#include &lt;boost/asio/associated_allocator.hpp&gt;</a>
<a name="ln20">#include &lt;boost/asio/associated_executor.hpp&gt;</a>
<a name="ln21">#include &lt;boost/asio/detail/bind_handler.hpp&gt;</a>
<a name="ln22">#include &lt;boost/asio/detail/handler_alloc_helpers.hpp&gt;</a>
<a name="ln23">#include &lt;boost/asio/detail/handler_cont_helpers.hpp&gt;</a>
<a name="ln24">#include &lt;boost/asio/detail/handler_invoke_helpers.hpp&gt;</a>
<a name="ln25">#include &lt;boost/asio/detail/handler_type_requirements.hpp&gt;</a>
<a name="ln26">#include &lt;boost/asio/detail/throw_error.hpp&gt;</a>
<a name="ln27">#include &lt;boost/asio/error.hpp&gt;</a>
<a name="ln28">#include &lt;boost/asio/post.hpp&gt;</a>
<a name="ln29"> </a>
<a name="ln30">#include &lt;boost/asio/detail/push_options.hpp&gt;</a>
<a name="ln31"> </a>
<a name="ln32">namespace boost {</a>
<a name="ln33">namespace asio {</a>
<a name="ln34"> </a>
<a name="ln35">namespace detail</a>
<a name="ln36">{</a>
<a name="ln37">  struct default_connect_condition</a>
<a name="ln38">  {</a>
<a name="ln39">    template &lt;typename Endpoint&gt;</a>
<a name="ln40">    bool operator()(const boost::system::error_code&amp;, const Endpoint&amp;)</a>
<a name="ln41">    {</a>
<a name="ln42">      return true;</a>
<a name="ln43">    }</a>
<a name="ln44">  };</a>
<a name="ln45"> </a>
<a name="ln46">  template &lt;typename Protocol, typename Iterator&gt;</a>
<a name="ln47">  inline typename Protocol::endpoint deref_connect_result(</a>
<a name="ln48">      Iterator iter, boost::system::error_code&amp; ec)</a>
<a name="ln49">  {</a>
<a name="ln50">    return ec ? typename Protocol::endpoint() : *iter;</a>
<a name="ln51">  }</a>
<a name="ln52"> </a>
<a name="ln53">  template &lt;typename T, typename Iterator&gt;</a>
<a name="ln54">  struct legacy_connect_condition_helper : T</a>
<a name="ln55">  {</a>
<a name="ln56">    typedef char (*fallback_func_type)(...);</a>
<a name="ln57">    operator fallback_func_type() const;</a>
<a name="ln58">  };</a>
<a name="ln59"> </a>
<a name="ln60">  template &lt;typename R, typename Arg1, typename Arg2, typename Iterator&gt;</a>
<a name="ln61">  struct legacy_connect_condition_helper&lt;R (*)(Arg1, Arg2), Iterator&gt;</a>
<a name="ln62">  {</a>
<a name="ln63">    R operator()(Arg1, Arg2) const;</a>
<a name="ln64">    char operator()(...) const;</a>
<a name="ln65">  };</a>
<a name="ln66"> </a>
<a name="ln67">  template &lt;typename T, typename Iterator&gt;</a>
<a name="ln68">  struct is_legacy_connect_condition</a>
<a name="ln69">  {</a>
<a name="ln70">    static char asio_connect_condition_check(char);</a>
<a name="ln71">    static char (&amp;asio_connect_condition_check(Iterator))[2];</a>
<a name="ln72"> </a>
<a name="ln73">    static const bool value =</a>
<a name="ln74">      sizeof(asio_connect_condition_check(</a>
<a name="ln75">        (*static_cast&lt;legacy_connect_condition_helper&lt;T, Iterator&gt;*&gt;(0))(</a>
<a name="ln76">          *static_cast&lt;const boost::system::error_code*&gt;(0),</a>
<a name="ln77">          *static_cast&lt;const Iterator*&gt;(0)))) != 1;</a>
<a name="ln78">  };</a>
<a name="ln79"> </a>
<a name="ln80">  template &lt;typename ConnectCondition, typename Iterator&gt;</a>
<a name="ln81">  inline Iterator call_connect_condition(ConnectCondition&amp; connect_condition,</a>
<a name="ln82">      const boost::system::error_code&amp; ec, Iterator next, Iterator end,</a>
<a name="ln83">      typename enable_if&lt;is_legacy_connect_condition&lt;</a>
<a name="ln84">        ConnectCondition, Iterator&gt;::value&gt;::type* = 0)</a>
<a name="ln85">  {</a>
<a name="ln86">    if (next != end)</a>
<a name="ln87">      return connect_condition(ec, next);</a>
<a name="ln88">    return end;</a>
<a name="ln89">  }</a>
<a name="ln90"> </a>
<a name="ln91">  template &lt;typename ConnectCondition, typename Iterator&gt;</a>
<a name="ln92">  inline Iterator call_connect_condition(ConnectCondition&amp; connect_condition,</a>
<a name="ln93">      const boost::system::error_code&amp; ec, Iterator next, Iterator end,</a>
<a name="ln94">      typename enable_if&lt;!is_legacy_connect_condition&lt;</a>
<a name="ln95">        ConnectCondition, Iterator&gt;::value&gt;::type* = 0)</a>
<a name="ln96">  {</a>
<a name="ln97">    for (;next != end; ++next)</a>
<a name="ln98">      if (connect_condition(ec, *next))</a>
<a name="ln99">        return next;</a>
<a name="ln100">    return end;</a>
<a name="ln101">  }</a>
<a name="ln102">}</a>
<a name="ln103"> </a>
<a name="ln104">template &lt;typename Protocol BOOST_ASIO_SVC_TPARAM, typename EndpointSequence&gt;</a>
<a name="ln105">typename Protocol::endpoint connect(</a>
<a name="ln106">    basic_socket&lt;Protocol BOOST_ASIO_SVC_TARG&gt;&amp; s,</a>
<a name="ln107">    const EndpointSequence&amp; endpoints,</a>
<a name="ln108">    typename enable_if&lt;is_endpoint_sequence&lt;</a>
<a name="ln109">        EndpointSequence&gt;::value&gt;::type*)</a>
<a name="ln110">{</a>
<a name="ln111">  boost::system::error_code ec;</a>
<a name="ln112">  typename Protocol::endpoint result = connect(s, endpoints, ec);</a>
<a name="ln113">  boost::asio::detail::throw_error(ec, &quot;connect&quot;);</a>
<a name="ln114">  return result;</a>
<a name="ln115">}</a>
<a name="ln116"> </a>
<a name="ln117">template &lt;typename Protocol BOOST_ASIO_SVC_TPARAM, typename EndpointSequence&gt;</a>
<a name="ln118">typename Protocol::endpoint connect(</a>
<a name="ln119">    basic_socket&lt;Protocol BOOST_ASIO_SVC_TARG&gt;&amp; s,</a>
<a name="ln120">    const EndpointSequence&amp; endpoints, boost::system::error_code&amp; ec,</a>
<a name="ln121">    typename enable_if&lt;is_endpoint_sequence&lt;</a>
<a name="ln122">        EndpointSequence&gt;::value&gt;::type*)</a>
<a name="ln123">{</a>
<a name="ln124">  return detail::deref_connect_result&lt;Protocol&gt;(</a>
<a name="ln125">      connect(s, endpoints.begin(), endpoints.end(),</a>
<a name="ln126">        detail::default_connect_condition(), ec), ec);</a>
<a name="ln127">}</a>
<a name="ln128"> </a>
<a name="ln129">#if !defined(BOOST_ASIO_NO_DEPRECATED)</a>
<a name="ln130">template &lt;typename Protocol BOOST_ASIO_SVC_TPARAM, typename Iterator&gt;</a>
<a name="ln131">Iterator connect(basic_socket&lt;Protocol BOOST_ASIO_SVC_TARG&gt;&amp; s, Iterator begin,</a>
<a name="ln132">    typename enable_if&lt;!is_endpoint_sequence&lt;Iterator&gt;::value&gt;::type*)</a>
<a name="ln133">{</a>
<a name="ln134">  boost::system::error_code ec;</a>
<a name="ln135">  Iterator result = connect(s, begin, ec);</a>
<a name="ln136">  boost::asio::detail::throw_error(ec, &quot;connect&quot;);</a>
<a name="ln137">  return result;</a>
<a name="ln138">}</a>
<a name="ln139"> </a>
<a name="ln140">template &lt;typename Protocol BOOST_ASIO_SVC_TPARAM, typename Iterator&gt;</a>
<a name="ln141">inline Iterator connect(basic_socket&lt;Protocol BOOST_ASIO_SVC_TARG&gt;&amp; s,</a>
<a name="ln142">    Iterator begin, boost::system::error_code&amp; ec,</a>
<a name="ln143">    typename enable_if&lt;!is_endpoint_sequence&lt;Iterator&gt;::value&gt;::type*)</a>
<a name="ln144">{</a>
<a name="ln145">  return connect(s, begin, Iterator(), detail::default_connect_condition(), ec);</a>
<a name="ln146">}</a>
<a name="ln147">#endif // !defined(BOOST_ASIO_NO_DEPRECATED)</a>
<a name="ln148"> </a>
<a name="ln149">template &lt;typename Protocol BOOST_ASIO_SVC_TPARAM, typename Iterator&gt;</a>
<a name="ln150">Iterator connect(basic_socket&lt;Protocol BOOST_ASIO_SVC_TARG&gt;&amp; s,</a>
<a name="ln151">    Iterator begin, Iterator end)</a>
<a name="ln152">{</a>
<a name="ln153">  boost::system::error_code ec;</a>
<a name="ln154">  Iterator result = connect(s, begin, end, ec);</a>
<a name="ln155">  boost::asio::detail::throw_error(ec, &quot;connect&quot;);</a>
<a name="ln156">  return result;</a>
<a name="ln157">}</a>
<a name="ln158"> </a>
<a name="ln159">template &lt;typename Protocol BOOST_ASIO_SVC_TPARAM, typename Iterator&gt;</a>
<a name="ln160">inline Iterator connect(basic_socket&lt;Protocol BOOST_ASIO_SVC_TARG&gt;&amp; s,</a>
<a name="ln161">    Iterator begin, Iterator end, boost::system::error_code&amp; ec)</a>
<a name="ln162">{</a>
<a name="ln163">  return connect(s, begin, end, detail::default_connect_condition(), ec);</a>
<a name="ln164">}</a>
<a name="ln165"> </a>
<a name="ln166">template &lt;typename Protocol BOOST_ASIO_SVC_TPARAM,</a>
<a name="ln167">    typename EndpointSequence, typename ConnectCondition&gt;</a>
<a name="ln168">typename Protocol::endpoint connect(</a>
<a name="ln169">    basic_socket&lt;Protocol BOOST_ASIO_SVC_TARG&gt;&amp; s,</a>
<a name="ln170">    const EndpointSequence&amp; endpoints, ConnectCondition connect_condition,</a>
<a name="ln171">    typename enable_if&lt;is_endpoint_sequence&lt;</a>
<a name="ln172">        EndpointSequence&gt;::value&gt;::type*)</a>
<a name="ln173">{</a>
<a name="ln174">  boost::system::error_code ec;</a>
<a name="ln175">  typename Protocol::endpoint result = connect(</a>
<a name="ln176">      s, endpoints, connect_condition, ec);</a>
<a name="ln177">  boost::asio::detail::throw_error(ec, &quot;connect&quot;);</a>
<a name="ln178">  return result;</a>
<a name="ln179">}</a>
<a name="ln180"> </a>
<a name="ln181">template &lt;typename Protocol BOOST_ASIO_SVC_TPARAM,</a>
<a name="ln182">    typename EndpointSequence, typename ConnectCondition&gt;</a>
<a name="ln183">typename Protocol::endpoint connect(</a>
<a name="ln184">    basic_socket&lt;Protocol BOOST_ASIO_SVC_TARG&gt;&amp; s,</a>
<a name="ln185">    const EndpointSequence&amp; endpoints, ConnectCondition connect_condition,</a>
<a name="ln186">    boost::system::error_code&amp; ec,</a>
<a name="ln187">    typename enable_if&lt;is_endpoint_sequence&lt;</a>
<a name="ln188">        EndpointSequence&gt;::value&gt;::type*)</a>
<a name="ln189">{</a>
<a name="ln190">  return detail::deref_connect_result&lt;Protocol&gt;(</a>
<a name="ln191">      connect(s, endpoints.begin(), endpoints.end(),</a>
<a name="ln192">        connect_condition, ec), ec);</a>
<a name="ln193">}</a>
<a name="ln194"> </a>
<a name="ln195">#if !defined(BOOST_ASIO_NO_DEPRECATED)</a>
<a name="ln196">template &lt;typename Protocol BOOST_ASIO_SVC_TPARAM,</a>
<a name="ln197">    typename Iterator, typename ConnectCondition&gt;</a>
<a name="ln198">Iterator connect(basic_socket&lt;Protocol BOOST_ASIO_SVC_TARG&gt;&amp; s,</a>
<a name="ln199">    Iterator begin, ConnectCondition connect_condition,</a>
<a name="ln200">    typename enable_if&lt;!is_endpoint_sequence&lt;Iterator&gt;::value&gt;::type*)</a>
<a name="ln201">{</a>
<a name="ln202">  boost::system::error_code ec;</a>
<a name="ln203">  Iterator result = connect(s, begin, connect_condition, ec);</a>
<a name="ln204">  boost::asio::detail::throw_error(ec, &quot;connect&quot;);</a>
<a name="ln205">  return result;</a>
<a name="ln206">}</a>
<a name="ln207"> </a>
<a name="ln208">template &lt;typename Protocol BOOST_ASIO_SVC_TPARAM,</a>
<a name="ln209">    typename Iterator, typename ConnectCondition&gt;</a>
<a name="ln210">inline Iterator connect(basic_socket&lt;Protocol BOOST_ASIO_SVC_TARG&gt;&amp; s,</a>
<a name="ln211">    Iterator begin, ConnectCondition connect_condition,</a>
<a name="ln212">    boost::system::error_code&amp; ec,</a>
<a name="ln213">    typename enable_if&lt;!is_endpoint_sequence&lt;Iterator&gt;::value&gt;::type*)</a>
<a name="ln214">{</a>
<a name="ln215">  return connect(s, begin, Iterator(), connect_condition, ec);</a>
<a name="ln216">}</a>
<a name="ln217">#endif // !defined(BOOST_ASIO_NO_DEPRECATED)</a>
<a name="ln218"> </a>
<a name="ln219">template &lt;typename Protocol BOOST_ASIO_SVC_TPARAM,</a>
<a name="ln220">    typename Iterator, typename ConnectCondition&gt;</a>
<a name="ln221">Iterator connect(basic_socket&lt;Protocol BOOST_ASIO_SVC_TARG&gt;&amp; s,</a>
<a name="ln222">    Iterator begin, Iterator end, ConnectCondition connect_condition)</a>
<a name="ln223">{</a>
<a name="ln224">  boost::system::error_code ec;</a>
<a name="ln225">  Iterator result = connect(s, begin, end, connect_condition, ec);</a>
<a name="ln226">  boost::asio::detail::throw_error(ec, &quot;connect&quot;);</a>
<a name="ln227">  return result;</a>
<a name="ln228">}</a>
<a name="ln229"> </a>
<a name="ln230">template &lt;typename Protocol BOOST_ASIO_SVC_TPARAM,</a>
<a name="ln231">    typename Iterator, typename ConnectCondition&gt;</a>
<a name="ln232">Iterator connect(basic_socket&lt;Protocol BOOST_ASIO_SVC_TARG&gt;&amp; s,</a>
<a name="ln233">    Iterator begin, Iterator end, ConnectCondition connect_condition,</a>
<a name="ln234">    boost::system::error_code&amp; ec)</a>
<a name="ln235">{</a>
<a name="ln236">  ec = boost::system::error_code();</a>
<a name="ln237"> </a>
<a name="ln238">  for (Iterator iter = begin; iter != end; ++iter)</a>
<a name="ln239">  {</a>
<a name="ln240">    iter = (detail::call_connect_condition(connect_condition, ec, iter, end));</a>
<a name="ln241">    if (iter != end)</a>
<a name="ln242">    {</a>
<a name="ln243">      s.close(ec);</a>
<a name="ln244">      s.connect(*iter, ec);</a>
<a name="ln245">      if (!ec)</a>
<a name="ln246">        return iter;</a>
<a name="ln247">    }</a>
<a name="ln248">    else</a>
<a name="ln249">      break;</a>
<a name="ln250">  }</a>
<a name="ln251"> </a>
<a name="ln252">  if (!ec)</a>
<a name="ln253">    ec = boost::asio::error::not_found;</a>
<a name="ln254"> </a>
<a name="ln255">  return end;</a>
<a name="ln256">}</a>
<a name="ln257"> </a>
<a name="ln258">namespace detail</a>
<a name="ln259">{</a>
<a name="ln260">  // Enable the empty base class optimisation for the connect condition.</a>
<a name="ln261">  template &lt;typename ConnectCondition&gt;</a>
<a name="ln262">  class base_from_connect_condition</a>
<a name="ln263">  {</a>
<a name="ln264">  protected:</a>
<a name="ln265">    explicit base_from_connect_condition(</a>
<a name="ln266">        const ConnectCondition&amp; connect_condition)</a>
<a name="ln267">      : connect_condition_(connect_condition)</a>
<a name="ln268">    {</a>
<a name="ln269">    }</a>
<a name="ln270"> </a>
<a name="ln271">    template &lt;typename Iterator&gt;</a>
<a name="ln272">    void check_condition(const boost::system::error_code&amp; ec,</a>
<a name="ln273">        Iterator&amp; iter, Iterator&amp; end)</a>
<a name="ln274">    {</a>
<a name="ln275">      iter = detail::call_connect_condition(connect_condition_, ec, iter, end);</a>
<a name="ln276">    }</a>
<a name="ln277"> </a>
<a name="ln278">  private:</a>
<a name="ln279">    ConnectCondition connect_condition_;</a>
<a name="ln280">  };</a>
<a name="ln281"> </a>
<a name="ln282">  // The default_connect_condition implementation is essentially a no-op. This</a>
<a name="ln283">  // template specialisation lets us eliminate all costs associated with it.</a>
<a name="ln284">  template &lt;&gt;</a>
<a name="ln285">  class base_from_connect_condition&lt;default_connect_condition&gt;</a>
<a name="ln286">  {</a>
<a name="ln287">  protected:</a>
<a name="ln288">    explicit base_from_connect_condition(const default_connect_condition&amp;)</a>
<a name="ln289">    {</a>
<a name="ln290">    }</a>
<a name="ln291"> </a>
<a name="ln292">    template &lt;typename Iterator&gt;</a>
<a name="ln293">    void check_condition(const boost::system::error_code&amp;, Iterator&amp;, Iterator&amp;)</a>
<a name="ln294">    {</a>
<a name="ln295">    }</a>
<a name="ln296">  };</a>
<a name="ln297"> </a>
<a name="ln298">  template &lt;typename Protocol BOOST_ASIO_SVC_TPARAM,</a>
<a name="ln299">      typename EndpointSequence, typename ConnectCondition,</a>
<a name="ln300">      typename RangeConnectHandler&gt;</a>
<a name="ln301">  class range_connect_op : base_from_connect_condition&lt;ConnectCondition&gt;</a>
<a name="ln302">  {</a>
<a name="ln303">  public:</a>
<a name="ln304">    range_connect_op(basic_socket&lt;Protocol BOOST_ASIO_SVC_TARG&gt;&amp; sock,</a>
<a name="ln305">        const EndpointSequence&amp; endpoints,</a>
<a name="ln306">        const ConnectCondition&amp; connect_condition,</a>
<a name="ln307">        RangeConnectHandler&amp; handler)</a>
<a name="ln308">      : base_from_connect_condition&lt;ConnectCondition&gt;(connect_condition),</a>
<a name="ln309">        socket_(sock),</a>
<a name="ln310">        endpoints_(endpoints),</a>
<a name="ln311">        index_(0),</a>
<a name="ln312">        start_(0),</a>
<a name="ln313">        handler_(BOOST_ASIO_MOVE_CAST(RangeConnectHandler)(handler))</a>
<a name="ln314">    {</a>
<a name="ln315">    }</a>
<a name="ln316"> </a>
<a name="ln317">#if defined(BOOST_ASIO_HAS_MOVE)</a>
<a name="ln318">    range_connect_op(const range_connect_op&amp; other)</a>
<a name="ln319">      : base_from_connect_condition&lt;ConnectCondition&gt;(other),</a>
<a name="ln320">        socket_(other.socket_),</a>
<a name="ln321">        endpoints_(other.endpoints_),</a>
<a name="ln322">        index_(other.index_),</a>
<a name="ln323">        start_(other.start_),</a>
<a name="ln324">        handler_(other.handler_)</a>
<a name="ln325">    {</a>
<a name="ln326">    }</a>
<a name="ln327"> </a>
<a name="ln328">    range_connect_op(range_connect_op&amp;&amp; other)</a>
<a name="ln329">      : base_from_connect_condition&lt;ConnectCondition&gt;(other),</a>
<a name="ln330">        socket_(other.socket_),</a>
<a name="ln331">        endpoints_(other.endpoints_),</a>
<a name="ln332">        index_(other.index_),</a>
<a name="ln333">        start_(other.start_),</a>
<a name="ln334">        handler_(BOOST_ASIO_MOVE_CAST(RangeConnectHandler)(other.handler_))</a>
<a name="ln335">    {</a>
<a name="ln336">    }</a>
<a name="ln337">#endif // defined(BOOST_ASIO_HAS_MOVE)</a>
<a name="ln338"> </a>
<a name="ln339">    void operator()(boost::system::error_code ec, int start = 0)</a>
<a name="ln340">    {</a>
<a name="ln341">      typename EndpointSequence::const_iterator begin = endpoints_.begin();</a>
<a name="ln342">      typename EndpointSequence::const_iterator iter = begin;</a>
<a name="ln343">      std::advance(iter, index_);</a>
<a name="ln344">      typename EndpointSequence::const_iterator end = endpoints_.end();</a>
<a name="ln345"> </a>
<a name="ln346">      switch (start_ = start)</a>
<a name="ln347">      {</a>
<a name="ln348">        case 1:</a>
<a name="ln349">        for (;;)</a>
<a name="ln350">        {</a>
<a name="ln351">          this-&gt;check_condition(ec, iter, end);</a>
<a name="ln352">          index_ = std::distance(begin, iter);</a>
<a name="ln353"> </a>
<a name="ln354">          if (iter != end)</a>
<a name="ln355">          {</a>
<a name="ln356">            socket_.close(ec);</a>
<a name="ln357">            socket_.async_connect(*iter,</a>
<a name="ln358">                BOOST_ASIO_MOVE_CAST(range_connect_op)(*this));</a>
<a name="ln359">            return;</a>
<a name="ln360">          }</a>
<a name="ln361"> </a>
<a name="ln362">          if (start)</a>
<a name="ln363">          {</a>
<a name="ln364">            ec = boost::asio::error::not_found;</a>
<a name="ln365">            boost::asio::post(socket_.get_executor(),</a>
<a name="ln366">                detail::bind_handler(</a>
<a name="ln367">                  BOOST_ASIO_MOVE_CAST(range_connect_op)(*this), ec));</a>
<a name="ln368">            return;</a>
<a name="ln369">          }</a>
<a name="ln370"> </a>
<a name="ln371">          default:</a>
<a name="ln372"> </a>
<a name="ln373">          if (iter == end)</a>
<a name="ln374">            break;</a>
<a name="ln375"> </a>
<a name="ln376">          if (!socket_.is_open())</a>
<a name="ln377">          {</a>
<a name="ln378">            ec = boost::asio::error::operation_aborted;</a>
<a name="ln379">            break;</a>
<a name="ln380">          }</a>
<a name="ln381"> </a>
<a name="ln382">          if (!ec)</a>
<a name="ln383">            break;</a>
<a name="ln384"> </a>
<a name="ln385">          ++iter;</a>
<a name="ln386">          ++index_;</a>
<a name="ln387">        }</a>
<a name="ln388"> </a>
<a name="ln389">        handler_(static_cast&lt;const boost::system::error_code&amp;&gt;(ec),</a>
<a name="ln390">            static_cast&lt;const typename Protocol::endpoint&amp;&gt;(</a>
<a name="ln391">              ec || iter == end ? typename Protocol::endpoint() : *iter));</a>
<a name="ln392">      }</a>
<a name="ln393">    }</a>
<a name="ln394"> </a>
<a name="ln395">  //private:</a>
<a name="ln396">    basic_socket&lt;Protocol BOOST_ASIO_SVC_TARG&gt;&amp; socket_;</a>
<a name="ln397">    EndpointSequence endpoints_;</a>
<a name="ln398">    std::size_t index_;</a>
<a name="ln399">    int start_;</a>
<a name="ln400">    RangeConnectHandler handler_;</a>
<a name="ln401">  };</a>
<a name="ln402"> </a>
<a name="ln403">  template &lt;typename Protocol BOOST_ASIO_SVC_TPARAM,</a>
<a name="ln404">      typename EndpointSequence, typename ConnectCondition,</a>
<a name="ln405">      typename RangeConnectHandler&gt;</a>
<a name="ln406">  inline void* asio_handler_allocate(std::size_t size,</a>
<a name="ln407">      range_connect_op&lt;Protocol BOOST_ASIO_SVC_TARG, EndpointSequence,</a>
<a name="ln408">        ConnectCondition, RangeConnectHandler&gt;* this_handler)</a>
<a name="ln409">  {</a>
<a name="ln410">    return boost_asio_handler_alloc_helpers::allocate(</a>
<a name="ln411">        size, this_handler-&gt;handler_);</a>
<a name="ln412">  }</a>
<a name="ln413"> </a>
<a name="ln414">  template &lt;typename Protocol BOOST_ASIO_SVC_TPARAM,</a>
<a name="ln415">      typename EndpointSequence, typename ConnectCondition,</a>
<a name="ln416">      typename RangeConnectHandler&gt;</a>
<a name="ln417">  inline void asio_handler_deallocate(void* pointer, std::size_t size,</a>
<a name="ln418">      range_connect_op&lt;Protocol BOOST_ASIO_SVC_TARG, EndpointSequence,</a>
<a name="ln419">        ConnectCondition, RangeConnectHandler&gt;* this_handler)</a>
<a name="ln420">  {</a>
<a name="ln421">    boost_asio_handler_alloc_helpers::deallocate(</a>
<a name="ln422">        pointer, size, this_handler-&gt;handler_);</a>
<a name="ln423">  }</a>
<a name="ln424"> </a>
<a name="ln425">  template &lt;typename Protocol BOOST_ASIO_SVC_TPARAM,</a>
<a name="ln426">      typename EndpointSequence, typename ConnectCondition,</a>
<a name="ln427">      typename RangeConnectHandler&gt;</a>
<a name="ln428">  inline bool asio_handler_is_continuation(</a>
<a name="ln429">      range_connect_op&lt;Protocol BOOST_ASIO_SVC_TARG, EndpointSequence,</a>
<a name="ln430">        ConnectCondition, RangeConnectHandler&gt;* this_handler)</a>
<a name="ln431">  {</a>
<a name="ln432">    return boost_asio_handler_cont_helpers::is_continuation(</a>
<a name="ln433">        this_handler-&gt;handler_);</a>
<a name="ln434">  }</a>
<a name="ln435"> </a>
<a name="ln436">  template &lt;typename Function, typename Protocol</a>
<a name="ln437">      BOOST_ASIO_SVC_TPARAM, typename EndpointSequence,</a>
<a name="ln438">      typename ConnectCondition, typename RangeConnectHandler&gt;</a>
<a name="ln439">  inline void asio_handler_invoke(Function&amp; function,</a>
<a name="ln440">      range_connect_op&lt;Protocol BOOST_ASIO_SVC_TARG, EndpointSequence,</a>
<a name="ln441">        ConnectCondition, RangeConnectHandler&gt;* this_handler)</a>
<a name="ln442">  {</a>
<a name="ln443">    boost_asio_handler_invoke_helpers::invoke(</a>
<a name="ln444">        function, this_handler-&gt;handler_);</a>
<a name="ln445">  }</a>
<a name="ln446"> </a>
<a name="ln447">  template &lt;typename Function, typename Protocol</a>
<a name="ln448">      BOOST_ASIO_SVC_TPARAM, typename EndpointSequence,</a>
<a name="ln449">      typename ConnectCondition, typename RangeConnectHandler&gt;</a>
<a name="ln450">  inline void asio_handler_invoke(const Function&amp; function,</a>
<a name="ln451">      range_connect_op&lt;Protocol BOOST_ASIO_SVC_TARG, EndpointSequence,</a>
<a name="ln452">        ConnectCondition, RangeConnectHandler&gt;* this_handler)</a>
<a name="ln453">  {</a>
<a name="ln454">    boost_asio_handler_invoke_helpers::invoke(</a>
<a name="ln455">        function, this_handler-&gt;handler_);</a>
<a name="ln456">  }</a>
<a name="ln457"> </a>
<a name="ln458">  template &lt;typename Protocol BOOST_ASIO_SVC_TPARAM, typename Iterator,</a>
<a name="ln459">      typename ConnectCondition, typename IteratorConnectHandler&gt;</a>
<a name="ln460">  class iterator_connect_op : base_from_connect_condition&lt;ConnectCondition&gt;</a>
<a name="ln461">  {</a>
<a name="ln462">  public:</a>
<a name="ln463">    iterator_connect_op(basic_socket&lt;Protocol BOOST_ASIO_SVC_TARG&gt;&amp; sock,</a>
<a name="ln464">        const Iterator&amp; begin, const Iterator&amp; end,</a>
<a name="ln465">        const ConnectCondition&amp; connect_condition,</a>
<a name="ln466">        IteratorConnectHandler&amp; handler)</a>
<a name="ln467">      : base_from_connect_condition&lt;ConnectCondition&gt;(connect_condition),</a>
<a name="ln468">        socket_(sock),</a>
<a name="ln469">        iter_(begin),</a>
<a name="ln470">        end_(end),</a>
<a name="ln471">        start_(0),</a>
<a name="ln472">        handler_(BOOST_ASIO_MOVE_CAST(IteratorConnectHandler)(handler))</a>
<a name="ln473">    {</a>
<a name="ln474">    }</a>
<a name="ln475"> </a>
<a name="ln476">#if defined(BOOST_ASIO_HAS_MOVE)</a>
<a name="ln477">    iterator_connect_op(const iterator_connect_op&amp; other)</a>
<a name="ln478">      : base_from_connect_condition&lt;ConnectCondition&gt;(other),</a>
<a name="ln479">        socket_(other.socket_),</a>
<a name="ln480">        iter_(other.iter_),</a>
<a name="ln481">        end_(other.end_),</a>
<a name="ln482">        start_(other.start_),</a>
<a name="ln483">        handler_(other.handler_)</a>
<a name="ln484">    {</a>
<a name="ln485">    }</a>
<a name="ln486"> </a>
<a name="ln487">    iterator_connect_op(iterator_connect_op&amp;&amp; other)</a>
<a name="ln488">      : base_from_connect_condition&lt;ConnectCondition&gt;(other),</a>
<a name="ln489">        socket_(other.socket_),</a>
<a name="ln490">        iter_(other.iter_),</a>
<a name="ln491">        end_(other.end_),</a>
<a name="ln492">        start_(other.start_),</a>
<a name="ln493">        handler_(BOOST_ASIO_MOVE_CAST(IteratorConnectHandler)(other.handler_))</a>
<a name="ln494">    {</a>
<a name="ln495">    }</a>
<a name="ln496">#endif // defined(BOOST_ASIO_HAS_MOVE)</a>
<a name="ln497"> </a>
<a name="ln498">    void operator()(boost::system::error_code ec, int start = 0)</a>
<a name="ln499">    {</a>
<a name="ln500">      switch (start_ = start)</a>
<a name="ln501">      {</a>
<a name="ln502">        case 1:</a>
<a name="ln503">        for (;;)</a>
<a name="ln504">        {</a>
<a name="ln505">          this-&gt;check_condition(ec, iter_, end_);</a>
<a name="ln506"> </a>
<a name="ln507">          if (iter_ != end_)</a>
<a name="ln508">          {</a>
<a name="ln509">            socket_.close(ec);</a>
<a name="ln510">            socket_.async_connect(*iter_,</a>
<a name="ln511">                BOOST_ASIO_MOVE_CAST(iterator_connect_op)(*this));</a>
<a name="ln512">            return;</a>
<a name="ln513">          }</a>
<a name="ln514"> </a>
<a name="ln515">          if (start)</a>
<a name="ln516">          {</a>
<a name="ln517">            ec = boost::asio::error::not_found;</a>
<a name="ln518">            boost::asio::post(socket_.get_executor(),</a>
<a name="ln519">                detail::bind_handler(</a>
<a name="ln520">                  BOOST_ASIO_MOVE_CAST(iterator_connect_op)(*this), ec));</a>
<a name="ln521">            return;</a>
<a name="ln522">          }</a>
<a name="ln523"> </a>
<a name="ln524">          default:</a>
<a name="ln525"> </a>
<a name="ln526">          if (iter_ == end_)</a>
<a name="ln527">            break;</a>
<a name="ln528"> </a>
<a name="ln529">          if (!socket_.is_open())</a>
<a name="ln530">          {</a>
<a name="ln531">            ec = boost::asio::error::operation_aborted;</a>
<a name="ln532">            break;</a>
<a name="ln533">          }</a>
<a name="ln534"> </a>
<a name="ln535">          if (!ec)</a>
<a name="ln536">            break;</a>
<a name="ln537"> </a>
<a name="ln538">          ++iter_;</a>
<a name="ln539">        }</a>
<a name="ln540"> </a>
<a name="ln541">        handler_(static_cast&lt;const boost::system::error_code&amp;&gt;(ec),</a>
<a name="ln542">            static_cast&lt;const Iterator&amp;&gt;(iter_));</a>
<a name="ln543">      }</a>
<a name="ln544">    }</a>
<a name="ln545"> </a>
<a name="ln546">  //private:</a>
<a name="ln547">    basic_socket&lt;Protocol BOOST_ASIO_SVC_TARG&gt;&amp; socket_;</a>
<a name="ln548">    Iterator iter_;</a>
<a name="ln549">    Iterator end_;</a>
<a name="ln550">    int start_;</a>
<a name="ln551">    IteratorConnectHandler handler_;</a>
<a name="ln552">  };</a>
<a name="ln553"> </a>
<a name="ln554">  template &lt;typename Protocol BOOST_ASIO_SVC_TPARAM, typename Iterator,</a>
<a name="ln555">      typename ConnectCondition, typename IteratorConnectHandler&gt;</a>
<a name="ln556">  inline void* asio_handler_allocate(std::size_t size,</a>
<a name="ln557">      iterator_connect_op&lt;Protocol BOOST_ASIO_SVC_TARG, Iterator,</a>
<a name="ln558">        ConnectCondition, IteratorConnectHandler&gt;* this_handler)</a>
<a name="ln559">  {</a>
<a name="ln560">    return boost_asio_handler_alloc_helpers::allocate(</a>
<a name="ln561">        size, this_handler-&gt;handler_);</a>
<a name="ln562">  }</a>
<a name="ln563"> </a>
<a name="ln564">  template &lt;typename Protocol BOOST_ASIO_SVC_TPARAM, typename Iterator,</a>
<a name="ln565">      typename ConnectCondition, typename IteratorConnectHandler&gt;</a>
<a name="ln566">  inline void asio_handler_deallocate(void* pointer, std::size_t size,</a>
<a name="ln567">      iterator_connect_op&lt;Protocol BOOST_ASIO_SVC_TARG, Iterator,</a>
<a name="ln568">        ConnectCondition, IteratorConnectHandler&gt;* this_handler)</a>
<a name="ln569">  {</a>
<a name="ln570">    boost_asio_handler_alloc_helpers::deallocate(</a>
<a name="ln571">        pointer, size, this_handler-&gt;handler_);</a>
<a name="ln572">  }</a>
<a name="ln573"> </a>
<a name="ln574">  template &lt;typename Protocol BOOST_ASIO_SVC_TPARAM, typename Iterator,</a>
<a name="ln575">      typename ConnectCondition, typename IteratorConnectHandler&gt;</a>
<a name="ln576">  inline bool asio_handler_is_continuation(</a>
<a name="ln577">      iterator_connect_op&lt;Protocol BOOST_ASIO_SVC_TARG, Iterator,</a>
<a name="ln578">        ConnectCondition, IteratorConnectHandler&gt;* this_handler)</a>
<a name="ln579">  {</a>
<a name="ln580">    return boost_asio_handler_cont_helpers::is_continuation(</a>
<a name="ln581">        this_handler-&gt;handler_);</a>
<a name="ln582">  }</a>
<a name="ln583"> </a>
<a name="ln584">  template &lt;typename Function, typename Protocol</a>
<a name="ln585">      BOOST_ASIO_SVC_TPARAM, typename Iterator,</a>
<a name="ln586">      typename ConnectCondition, typename IteratorConnectHandler&gt;</a>
<a name="ln587">  inline void asio_handler_invoke(Function&amp; function,</a>
<a name="ln588">      iterator_connect_op&lt;Protocol BOOST_ASIO_SVC_TARG, Iterator,</a>
<a name="ln589">        ConnectCondition, IteratorConnectHandler&gt;* this_handler)</a>
<a name="ln590">  {</a>
<a name="ln591">    boost_asio_handler_invoke_helpers::invoke(</a>
<a name="ln592">        function, this_handler-&gt;handler_);</a>
<a name="ln593">  }</a>
<a name="ln594"> </a>
<a name="ln595">  template &lt;typename Function, typename Protocol</a>
<a name="ln596">      BOOST_ASIO_SVC_TPARAM, typename Iterator,</a>
<a name="ln597">      typename ConnectCondition, typename IteratorConnectHandler&gt;</a>
<a name="ln598">  inline void asio_handler_invoke(const Function&amp; function,</a>
<a name="ln599">      iterator_connect_op&lt;Protocol BOOST_ASIO_SVC_TARG, Iterator,</a>
<a name="ln600">        ConnectCondition, IteratorConnectHandler&gt;* this_handler)</a>
<a name="ln601">  {</a>
<a name="ln602">    boost_asio_handler_invoke_helpers::invoke(</a>
<a name="ln603">        function, this_handler-&gt;handler_);</a>
<a name="ln604">  }</a>
<a name="ln605">} // namespace detail</a>
<a name="ln606"> </a>
<a name="ln607">#if !defined(GENERATING_DOCUMENTATION)</a>
<a name="ln608"> </a>
<a name="ln609">template &lt;typename Protocol BOOST_ASIO_SVC_TPARAM,</a>
<a name="ln610">    typename EndpointSequence, typename ConnectCondition,</a>
<a name="ln611">    typename RangeConnectHandler, typename Allocator&gt;</a>
<a name="ln612">struct associated_allocator&lt;</a>
<a name="ln613">    detail::range_connect_op&lt;Protocol BOOST_ASIO_SVC_TARG,</a>
<a name="ln614">      EndpointSequence, ConnectCondition, RangeConnectHandler&gt;,</a>
<a name="ln615">    Allocator&gt;</a>
<a name="ln616">{</a>
<a name="ln617">  typedef typename associated_allocator&lt;</a>
<a name="ln618">      RangeConnectHandler, Allocator&gt;::type type;</a>
<a name="ln619"> </a>
<a name="ln620">  static type get(</a>
<a name="ln621">      const detail::range_connect_op&lt;Protocol BOOST_ASIO_SVC_TARG,</a>
<a name="ln622">        EndpointSequence, ConnectCondition, RangeConnectHandler&gt;&amp; h,</a>
<a name="ln623">      const Allocator&amp; a = Allocator()) BOOST_ASIO_NOEXCEPT</a>
<a name="ln624">  {</a>
<a name="ln625">    return associated_allocator&lt;RangeConnectHandler,</a>
<a name="ln626">        Allocator&gt;::get(h.handler_, a);</a>
<a name="ln627">  }</a>
<a name="ln628">};</a>
<a name="ln629"> </a>
<a name="ln630">template &lt;typename Protocol BOOST_ASIO_SVC_TPARAM,</a>
<a name="ln631">    typename EndpointSequence, typename ConnectCondition,</a>
<a name="ln632">    typename RangeConnectHandler, typename Executor&gt;</a>
<a name="ln633">struct associated_executor&lt;</a>
<a name="ln634">    detail::range_connect_op&lt;Protocol BOOST_ASIO_SVC_TARG,</a>
<a name="ln635">      EndpointSequence, ConnectCondition, RangeConnectHandler&gt;,</a>
<a name="ln636">    Executor&gt;</a>
<a name="ln637">{</a>
<a name="ln638">  typedef typename associated_executor&lt;</a>
<a name="ln639">      RangeConnectHandler, Executor&gt;::type type;</a>
<a name="ln640"> </a>
<a name="ln641">  static type get(</a>
<a name="ln642">      const detail::range_connect_op&lt;Protocol BOOST_ASIO_SVC_TARG,</a>
<a name="ln643">        EndpointSequence, ConnectCondition, RangeConnectHandler&gt;&amp; h,</a>
<a name="ln644">      const Executor&amp; ex = Executor()) BOOST_ASIO_NOEXCEPT</a>
<a name="ln645">  {</a>
<a name="ln646">    return associated_executor&lt;RangeConnectHandler,</a>
<a name="ln647">        Executor&gt;::get(h.handler_, ex);</a>
<a name="ln648">  }</a>
<a name="ln649">};</a>
<a name="ln650"> </a>
<a name="ln651">template &lt;typename Protocol BOOST_ASIO_SVC_TPARAM,</a>
<a name="ln652">    typename Iterator, typename ConnectCondition,</a>
<a name="ln653">    typename IteratorConnectHandler, typename Allocator&gt;</a>
<a name="ln654">struct associated_allocator&lt;</a>
<a name="ln655">    detail::iterator_connect_op&lt;Protocol BOOST_ASIO_SVC_TARG, Iterator,</a>
<a name="ln656">      ConnectCondition, IteratorConnectHandler&gt;,</a>
<a name="ln657">    Allocator&gt;</a>
<a name="ln658">{</a>
<a name="ln659">  typedef typename associated_allocator&lt;</a>
<a name="ln660">      IteratorConnectHandler, Allocator&gt;::type type;</a>
<a name="ln661"> </a>
<a name="ln662">  static type get(</a>
<a name="ln663">      const detail::iterator_connect_op&lt;Protocol BOOST_ASIO_SVC_TARG,</a>
<a name="ln664">        Iterator, ConnectCondition, IteratorConnectHandler&gt;&amp; h,</a>
<a name="ln665">      const Allocator&amp; a = Allocator()) BOOST_ASIO_NOEXCEPT</a>
<a name="ln666">  {</a>
<a name="ln667">    return associated_allocator&lt;IteratorConnectHandler,</a>
<a name="ln668">        Allocator&gt;::get(h.handler_, a);</a>
<a name="ln669">  }</a>
<a name="ln670">};</a>
<a name="ln671"> </a>
<a name="ln672">template &lt;typename Protocol BOOST_ASIO_SVC_TPARAM,</a>
<a name="ln673">    typename Iterator, typename ConnectCondition,</a>
<a name="ln674">    typename IteratorConnectHandler, typename Executor&gt;</a>
<a name="ln675">struct associated_executor&lt;</a>
<a name="ln676">    detail::iterator_connect_op&lt;Protocol BOOST_ASIO_SVC_TARG, Iterator,</a>
<a name="ln677">      ConnectCondition, IteratorConnectHandler&gt;,</a>
<a name="ln678">    Executor&gt;</a>
<a name="ln679">{</a>
<a name="ln680">  typedef typename associated_executor&lt;</a>
<a name="ln681">      IteratorConnectHandler, Executor&gt;::type type;</a>
<a name="ln682"> </a>
<a name="ln683">  static type get(</a>
<a name="ln684">      const detail::iterator_connect_op&lt;Protocol BOOST_ASIO_SVC_TARG,</a>
<a name="ln685">        Iterator, ConnectCondition, IteratorConnectHandler&gt;&amp; h,</a>
<a name="ln686">      const Executor&amp; ex = Executor()) BOOST_ASIO_NOEXCEPT</a>
<a name="ln687">  {</a>
<a name="ln688">    return associated_executor&lt;IteratorConnectHandler,</a>
<a name="ln689">        Executor&gt;::get(h.handler_, ex);</a>
<a name="ln690">  }</a>
<a name="ln691">};</a>
<a name="ln692"> </a>
<a name="ln693">#endif // !defined(GENERATING_DOCUMENTATION)</a>
<a name="ln694"> </a>
<a name="ln695">template &lt;typename Protocol BOOST_ASIO_SVC_TPARAM,</a>
<a name="ln696">    typename EndpointSequence, typename RangeConnectHandler&gt;</a>
<a name="ln697">inline BOOST_ASIO_INITFN_RESULT_TYPE(RangeConnectHandler,</a>
<a name="ln698">    void (boost::system::error_code, typename Protocol::endpoint))</a>
<a name="ln699">async_connect(basic_socket&lt;Protocol BOOST_ASIO_SVC_TARG&gt;&amp; s,</a>
<a name="ln700">    const EndpointSequence&amp; endpoints,</a>
<a name="ln701">    BOOST_ASIO_MOVE_ARG(RangeConnectHandler) handler,</a>
<a name="ln702">    typename enable_if&lt;is_endpoint_sequence&lt;</a>
<a name="ln703">        EndpointSequence&gt;::value&gt;::type*)</a>
<a name="ln704">{</a>
<a name="ln705">  // If you get an error on the following line it means that your handler does</a>
<a name="ln706">  // not meet the documented type requirements for a RangeConnectHandler.</a>
<a name="ln707">  BOOST_ASIO_RANGE_CONNECT_HANDLER_CHECK(</a>
<a name="ln708">      RangeConnectHandler, handler, typename Protocol::endpoint) type_check;</a>
<a name="ln709"> </a>
<a name="ln710">  async_completion&lt;RangeConnectHandler,</a>
<a name="ln711">    void (boost::system::error_code, typename Protocol::endpoint)&gt;</a>
<a name="ln712">      init(handler);</a>
<a name="ln713"> </a>
<a name="ln714">  detail::range_connect_op&lt;Protocol BOOST_ASIO_SVC_TARG, EndpointSequence,</a>
<a name="ln715">    detail::default_connect_condition,</a>
<a name="ln716">      BOOST_ASIO_HANDLER_TYPE(RangeConnectHandler,</a>
<a name="ln717">        void (boost::system::error_code, typename Protocol::endpoint))&gt;(s,</a>
<a name="ln718">          endpoints, detail::default_connect_condition(),</a>
<a name="ln719">            init.completion_handler)(boost::system::error_code(), 1);</a>
<a name="ln720"> </a>
<a name="ln721">  return init.result.get();</a>
<a name="ln722">}</a>
<a name="ln723"> </a>
<a name="ln724">#if !defined(BOOST_ASIO_NO_DEPRECATED)</a>
<a name="ln725">template &lt;typename Protocol BOOST_ASIO_SVC_TPARAM,</a>
<a name="ln726">    typename Iterator, typename IteratorConnectHandler&gt;</a>
<a name="ln727">inline BOOST_ASIO_INITFN_RESULT_TYPE(IteratorConnectHandler,</a>
<a name="ln728">    void (boost::system::error_code, Iterator))</a>
<a name="ln729">async_connect(basic_socket&lt;Protocol BOOST_ASIO_SVC_TARG&gt;&amp; s,</a>
<a name="ln730">    Iterator begin, BOOST_ASIO_MOVE_ARG(IteratorConnectHandler) handler,</a>
<a name="ln731">    typename enable_if&lt;!is_endpoint_sequence&lt;Iterator&gt;::value&gt;::type*)</a>
<a name="ln732">{</a>
<a name="ln733">  // If you get an error on the following line it means that your handler does</a>
<a name="ln734">  // not meet the documented type requirements for a IteratorConnectHandler.</a>
<a name="ln735">  BOOST_ASIO_ITERATOR_CONNECT_HANDLER_CHECK(</a>
<a name="ln736">      IteratorConnectHandler, handler, Iterator) type_check;</a>
<a name="ln737"> </a>
<a name="ln738">  async_completion&lt;IteratorConnectHandler,</a>
<a name="ln739">    void (boost::system::error_code, Iterator)&gt; init(handler);</a>
<a name="ln740"> </a>
<a name="ln741">  detail::iterator_connect_op&lt;Protocol BOOST_ASIO_SVC_TARG, Iterator,</a>
<a name="ln742">    detail::default_connect_condition, BOOST_ASIO_HANDLER_TYPE(</a>
<a name="ln743">      IteratorConnectHandler, void (boost::system::error_code, Iterator))&gt;(s,</a>
<a name="ln744">        begin, Iterator(), detail::default_connect_condition(),</a>
<a name="ln745">          init.completion_handler)(boost::system::error_code(), 1);</a>
<a name="ln746"> </a>
<a name="ln747">  return init.result.get();</a>
<a name="ln748">}</a>
<a name="ln749">#endif // !defined(BOOST_ASIO_NO_DEPRECATED)</a>
<a name="ln750"> </a>
<a name="ln751">template &lt;typename Protocol BOOST_ASIO_SVC_TPARAM,</a>
<a name="ln752">    typename Iterator, typename IteratorConnectHandler&gt;</a>
<a name="ln753">inline BOOST_ASIO_INITFN_RESULT_TYPE(IteratorConnectHandler,</a>
<a name="ln754">    void (boost::system::error_code, Iterator))</a>
<a name="ln755">async_connect(basic_socket&lt;Protocol BOOST_ASIO_SVC_TARG&gt;&amp; s,</a>
<a name="ln756">    Iterator begin, Iterator end,</a>
<a name="ln757">    BOOST_ASIO_MOVE_ARG(IteratorConnectHandler) handler)</a>
<a name="ln758">{</a>
<a name="ln759">  // If you get an error on the following line it means that your handler does</a>
<a name="ln760">  // not meet the documented type requirements for a IteratorConnectHandler.</a>
<a name="ln761">  BOOST_ASIO_ITERATOR_CONNECT_HANDLER_CHECK(</a>
<a name="ln762">      IteratorConnectHandler, handler, Iterator) type_check;</a>
<a name="ln763"> </a>
<a name="ln764">  async_completion&lt;IteratorConnectHandler,</a>
<a name="ln765">    void (boost::system::error_code, Iterator)&gt; init(handler);</a>
<a name="ln766"> </a>
<a name="ln767">  detail::iterator_connect_op&lt;Protocol BOOST_ASIO_SVC_TARG, Iterator,</a>
<a name="ln768">    detail::default_connect_condition, BOOST_ASIO_HANDLER_TYPE(</a>
<a name="ln769">      IteratorConnectHandler, void (boost::system::error_code, Iterator))&gt;(s,</a>
<a name="ln770">        begin, end, detail::default_connect_condition(),</a>
<a name="ln771">          init.completion_handler)(boost::system::error_code(), 1);</a>
<a name="ln772"> </a>
<a name="ln773">  return init.result.get();</a>
<a name="ln774">}</a>
<a name="ln775"> </a>
<a name="ln776">template &lt;typename Protocol BOOST_ASIO_SVC_TPARAM, typename EndpointSequence,</a>
<a name="ln777">    typename ConnectCondition, typename RangeConnectHandler&gt;</a>
<a name="ln778">inline BOOST_ASIO_INITFN_RESULT_TYPE(RangeConnectHandler,</a>
<a name="ln779">    void (boost::system::error_code, typename Protocol::endpoint))</a>
<a name="ln780">async_connect(basic_socket&lt;Protocol BOOST_ASIO_SVC_TARG&gt;&amp; s,</a>
<a name="ln781">    const EndpointSequence&amp; endpoints, ConnectCondition connect_condition,</a>
<a name="ln782">    BOOST_ASIO_MOVE_ARG(RangeConnectHandler) handler,</a>
<a name="ln783">    typename enable_if&lt;is_endpoint_sequence&lt;</a>
<a name="ln784">        EndpointSequence&gt;::value&gt;::type*)</a>
<a name="ln785">{</a>
<a name="ln786">  // If you get an error on the following line it means that your handler does</a>
<a name="ln787">  // not meet the documented type requirements for a RangeConnectHandler.</a>
<a name="ln788">  BOOST_ASIO_RANGE_CONNECT_HANDLER_CHECK(</a>
<a name="ln789">      RangeConnectHandler, handler, typename Protocol::endpoint) type_check;</a>
<a name="ln790"> </a>
<a name="ln791">  async_completion&lt;RangeConnectHandler,</a>
<a name="ln792">    void (boost::system::error_code, typename Protocol::endpoint)&gt;</a>
<a name="ln793">      init(handler);</a>
<a name="ln794"> </a>
<a name="ln795">  detail::range_connect_op&lt;Protocol BOOST_ASIO_SVC_TARG, EndpointSequence,</a>
<a name="ln796">    ConnectCondition, BOOST_ASIO_HANDLER_TYPE(RangeConnectHandler,</a>
<a name="ln797">      void (boost::system::error_code, typename Protocol::endpoint))&gt;(s,</a>
<a name="ln798">        endpoints, connect_condition, init.completion_handler)(</a>
<a name="ln799">          boost::system::error_code(), 1);</a>
<a name="ln800"> </a>
<a name="ln801">  return init.result.get();</a>
<a name="ln802">}</a>
<a name="ln803"> </a>
<a name="ln804">#if !defined(BOOST_ASIO_NO_DEPRECATED)</a>
<a name="ln805">template &lt;typename Protocol BOOST_ASIO_SVC_TPARAM, typename Iterator,</a>
<a name="ln806">    typename ConnectCondition, typename IteratorConnectHandler&gt;</a>
<a name="ln807">inline BOOST_ASIO_INITFN_RESULT_TYPE(IteratorConnectHandler,</a>
<a name="ln808">    void (boost::system::error_code, Iterator))</a>
<a name="ln809">async_connect(basic_socket&lt;Protocol BOOST_ASIO_SVC_TARG&gt;&amp; s,</a>
<a name="ln810">    Iterator begin, ConnectCondition connect_condition,</a>
<a name="ln811">    BOOST_ASIO_MOVE_ARG(IteratorConnectHandler) handler,</a>
<a name="ln812">    typename enable_if&lt;!is_endpoint_sequence&lt;Iterator&gt;::value&gt;::type*)</a>
<a name="ln813">{</a>
<a name="ln814">  // If you get an error on the following line it means that your handler does</a>
<a name="ln815">  // not meet the documented type requirements for a IteratorConnectHandler.</a>
<a name="ln816">  BOOST_ASIO_ITERATOR_CONNECT_HANDLER_CHECK(</a>
<a name="ln817">      IteratorConnectHandler, handler, Iterator) type_check;</a>
<a name="ln818"> </a>
<a name="ln819">  async_completion&lt;IteratorConnectHandler,</a>
<a name="ln820">    void (boost::system::error_code, Iterator)&gt; init(handler);</a>
<a name="ln821"> </a>
<a name="ln822">  detail::iterator_connect_op&lt;Protocol BOOST_ASIO_SVC_TARG, Iterator,</a>
<a name="ln823">    ConnectCondition, BOOST_ASIO_HANDLER_TYPE(</a>
<a name="ln824">      IteratorConnectHandler, void (boost::system::error_code, Iterator))&gt;(s,</a>
<a name="ln825">        begin, Iterator(), connect_condition, init.completion_handler)(</a>
<a name="ln826">          boost::system::error_code(), 1);</a>
<a name="ln827"> </a>
<a name="ln828">  return init.result.get();</a>
<a name="ln829">}</a>
<a name="ln830">#endif // !defined(BOOST_ASIO_NO_DEPRECATED)</a>
<a name="ln831"> </a>
<a name="ln832">template &lt;typename Protocol BOOST_ASIO_SVC_TPARAM, typename Iterator,</a>
<a name="ln833">    typename ConnectCondition, typename IteratorConnectHandler&gt;</a>
<a name="ln834">inline BOOST_ASIO_INITFN_RESULT_TYPE(IteratorConnectHandler,</a>
<a name="ln835">    void (boost::system::error_code, Iterator))</a>
<a name="ln836">async_connect(basic_socket&lt;Protocol BOOST_ASIO_SVC_TARG&gt;&amp; s,</a>
<a name="ln837">    Iterator begin, Iterator end, ConnectCondition connect_condition,</a>
<a name="ln838">    BOOST_ASIO_MOVE_ARG(IteratorConnectHandler) handler)</a>
<a name="ln839">{</a>
<a name="ln840">  // If you get an error on the following line it means that your handler does</a>
<a name="ln841">  // not meet the documented type requirements for a IteratorConnectHandler.</a>
<a name="ln842">  BOOST_ASIO_ITERATOR_CONNECT_HANDLER_CHECK(</a>
<a name="ln843">      IteratorConnectHandler, handler, Iterator) type_check;</a>
<a name="ln844"> </a>
<a name="ln845">  async_completion&lt;IteratorConnectHandler,</a>
<a name="ln846">    void (boost::system::error_code, Iterator)&gt; init(handler);</a>
<a name="ln847"> </a>
<a name="ln848">  detail::iterator_connect_op&lt;Protocol BOOST_ASIO_SVC_TARG, Iterator,</a>
<a name="ln849">    ConnectCondition, BOOST_ASIO_HANDLER_TYPE(</a>
<a name="ln850">      IteratorConnectHandler, void (boost::system::error_code, Iterator))&gt;(s,</a>
<a name="ln851">        begin, end, connect_condition, init.completion_handler)(</a>
<a name="ln852">          boost::system::error_code(), 1);</a>
<a name="ln853"> </a>
<a name="ln854">  return init.result.get();</a>
<a name="ln855">}</a>
<a name="ln856"> </a>
<a name="ln857">} // namespace asio</a>
<a name="ln858">} // namespace boost</a>
<a name="ln859"> </a>
<a name="ln860">#include &lt;boost/asio/detail/pop_options.hpp&gt;</a>
<a name="ln861"> </a>
<a name="ln862">#endif // BOOST_ASIO_IMPL_CONNECT_HPP</a>

</code></pre>
<div class="balloon" rel="362"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'start' is always true.</p></div>
<div class="balloon" rel="515"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'start' is always true.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
