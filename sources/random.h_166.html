
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>random.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// random number generation -*- C++ -*-</a>
<a name="ln2"> </a>
<a name="ln3">// Copyright (C) 2009-2018 Free Software Foundation, Inc.</a>
<a name="ln4">//</a>
<a name="ln5">// This file is part of the GNU ISO C++ Library.  This library is free</a>
<a name="ln6">// software; you can redistribute it and/or modify it under the</a>
<a name="ln7">// terms of the GNU General Public License as published by the</a>
<a name="ln8">// Free Software Foundation; either version 3, or (at your option)</a>
<a name="ln9">// any later version.</a>
<a name="ln10"> </a>
<a name="ln11">// This library is distributed in the hope that it will be useful,</a>
<a name="ln12">// but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">// GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">// Under Section 7 of GPL version 3, you are granted additional</a>
<a name="ln17">// permissions described in the GCC Runtime Library Exception, version</a>
<a name="ln18">// 3.1, as published by the Free Software Foundation.</a>
<a name="ln19"> </a>
<a name="ln20">// You should have received a copy of the GNU General Public License and</a>
<a name="ln21">// a copy of the GCC Runtime Library Exception along with this program;</a>
<a name="ln22">// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see</a>
<a name="ln23">// &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln24"> </a>
<a name="ln25">/**</a>
<a name="ln26"> * @file bits/random.h</a>
<a name="ln27"> *  This is an internal header file, included by other library headers.</a>
<a name="ln28"> *  Do not attempt to use it directly. @headername{random}</a>
<a name="ln29"> */</a>
<a name="ln30"> </a>
<a name="ln31">#ifndef _RANDOM_H</a>
<a name="ln32">#define _RANDOM_H 1</a>
<a name="ln33"> </a>
<a name="ln34">#include &lt;vector&gt;</a>
<a name="ln35">#include &lt;bits/uniform_int_dist.h&gt;</a>
<a name="ln36"> </a>
<a name="ln37">namespace std _GLIBCXX_VISIBILITY(default)</a>
<a name="ln38">{</a>
<a name="ln39">_GLIBCXX_BEGIN_NAMESPACE_VERSION</a>
<a name="ln40"> </a>
<a name="ln41">  // [26.4] Random number generation</a>
<a name="ln42"> </a>
<a name="ln43">  /**</a>
<a name="ln44">   * @defgroup random Random Number Generation</a>
<a name="ln45">   * @ingroup numerics</a>
<a name="ln46">   *</a>
<a name="ln47">   * A facility for generating random numbers on selected distributions.</a>
<a name="ln48">   * @{</a>
<a name="ln49">   */</a>
<a name="ln50"> </a>
<a name="ln51">  /**</a>
<a name="ln52">   * @brief A function template for converting the output of a (integral)</a>
<a name="ln53">   * uniform random number generator to a floatng point result in the range</a>
<a name="ln54">   * [0-1).</a>
<a name="ln55">   */</a>
<a name="ln56">  template&lt;typename _RealType, size_t __bits,</a>
<a name="ln57">	   typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln58">    _RealType</a>
<a name="ln59">    generate_canonical(_UniformRandomNumberGenerator&amp; __g);</a>
<a name="ln60"> </a>
<a name="ln61">  /*</a>
<a name="ln62">   * Implementation-space details.</a>
<a name="ln63">   */</a>
<a name="ln64">  namespace __detail</a>
<a name="ln65">  {</a>
<a name="ln66">    template&lt;typename _UIntType, size_t __w,</a>
<a name="ln67">	     bool = __w &lt; static_cast&lt;size_t&gt;</a>
<a name="ln68">			  (std::numeric_limits&lt;_UIntType&gt;::digits)&gt;</a>
<a name="ln69">      struct _Shift</a>
<a name="ln70">      { static const _UIntType __value = 0; };</a>
<a name="ln71"> </a>
<a name="ln72">    template&lt;typename _UIntType, size_t __w&gt;</a>
<a name="ln73">      struct _Shift&lt;_UIntType, __w, true&gt;</a>
<a name="ln74">      { static const _UIntType __value = _UIntType(1) &lt;&lt; __w; };</a>
<a name="ln75"> </a>
<a name="ln76">    template&lt;int __s,</a>
<a name="ln77">	     int __which = ((__s &lt;= __CHAR_BIT__ * sizeof (int))</a>
<a name="ln78">			    + (__s &lt;= __CHAR_BIT__ * sizeof (long))</a>
<a name="ln79">			    + (__s &lt;= __CHAR_BIT__ * sizeof (long long))</a>
<a name="ln80">			    /* assume long long no bigger than __int128 */</a>
<a name="ln81">			    + (__s &lt;= 128))&gt;</a>
<a name="ln82">      struct _Select_uint_least_t</a>
<a name="ln83">      {</a>
<a name="ln84">	static_assert(__which &lt; 0, /* needs to be dependent */</a>
<a name="ln85">		      &quot;sorry, would be too much trouble for a slow result&quot;);</a>
<a name="ln86">      };</a>
<a name="ln87"> </a>
<a name="ln88">    template&lt;int __s&gt;</a>
<a name="ln89">      struct _Select_uint_least_t&lt;__s, 4&gt;</a>
<a name="ln90">      { typedef unsigned int type; };</a>
<a name="ln91"> </a>
<a name="ln92">    template&lt;int __s&gt;</a>
<a name="ln93">      struct _Select_uint_least_t&lt;__s, 3&gt;</a>
<a name="ln94">      { typedef unsigned long type; };</a>
<a name="ln95"> </a>
<a name="ln96">    template&lt;int __s&gt;</a>
<a name="ln97">      struct _Select_uint_least_t&lt;__s, 2&gt;</a>
<a name="ln98">      { typedef unsigned long long type; };</a>
<a name="ln99"> </a>
<a name="ln100">#ifdef _GLIBCXX_USE_INT128</a>
<a name="ln101">    template&lt;int __s&gt;</a>
<a name="ln102">      struct _Select_uint_least_t&lt;__s, 1&gt;</a>
<a name="ln103">      { typedef unsigned __int128 type; };</a>
<a name="ln104">#endif</a>
<a name="ln105"> </a>
<a name="ln106">    // Assume a != 0, a &lt; m, c &lt; m, x &lt; m.</a>
<a name="ln107">    template&lt;typename _Tp, _Tp __m, _Tp __a, _Tp __c,</a>
<a name="ln108">	     bool __big_enough = (!(__m &amp; (__m - 1))</a>
<a name="ln109">				  || (_Tp(-1) - __c) / __a &gt;= __m - 1),</a>
<a name="ln110">             bool __schrage_ok = __m % __a &lt; __m / __a&gt;</a>
<a name="ln111">      struct _Mod</a>
<a name="ln112">      {</a>
<a name="ln113">	typedef typename _Select_uint_least_t&lt;std::__lg(__a)</a>
<a name="ln114">					      + std::__lg(__m) + 2&gt;::type _Tp2;</a>
<a name="ln115">	static _Tp</a>
<a name="ln116">	__calc(_Tp __x)</a>
<a name="ln117">	{ return static_cast&lt;_Tp&gt;((_Tp2(__a) * __x + __c) % __m); }</a>
<a name="ln118">      };</a>
<a name="ln119"> </a>
<a name="ln120">    // Schrage.</a>
<a name="ln121">    template&lt;typename _Tp, _Tp __m, _Tp __a, _Tp __c&gt;</a>
<a name="ln122">      struct _Mod&lt;_Tp, __m, __a, __c, false, true&gt;</a>
<a name="ln123">      {</a>
<a name="ln124">	static _Tp</a>
<a name="ln125">	__calc(_Tp __x);</a>
<a name="ln126">      };</a>
<a name="ln127"> </a>
<a name="ln128">    // Special cases:</a>
<a name="ln129">    // - for m == 2^n or m == 0, unsigned integer overflow is safe.</a>
<a name="ln130">    // - a * (m - 1) + c fits in _Tp, there is no overflow.</a>
<a name="ln131">    template&lt;typename _Tp, _Tp __m, _Tp __a, _Tp __c, bool __s&gt;</a>
<a name="ln132">      struct _Mod&lt;_Tp, __m, __a, __c, true, __s&gt;</a>
<a name="ln133">      {</a>
<a name="ln134">	static _Tp</a>
<a name="ln135">	__calc(_Tp __x)</a>
<a name="ln136">	{</a>
<a name="ln137">	  _Tp __res = __a * __x + __c;</a>
<a name="ln138">	  if (__m)</a>
<a name="ln139">	    __res %= __m;</a>
<a name="ln140">	  return __res;</a>
<a name="ln141">	}</a>
<a name="ln142">      };</a>
<a name="ln143"> </a>
<a name="ln144">    template&lt;typename _Tp, _Tp __m, _Tp __a = 1, _Tp __c = 0&gt;</a>
<a name="ln145">      inline _Tp</a>
<a name="ln146">      __mod(_Tp __x)</a>
<a name="ln147">      { return _Mod&lt;_Tp, __m, __a, __c&gt;::__calc(__x); }</a>
<a name="ln148"> </a>
<a name="ln149">    /*</a>
<a name="ln150">     * An adaptor class for converting the output of any Generator into</a>
<a name="ln151">     * the input for a specific Distribution.</a>
<a name="ln152">     */</a>
<a name="ln153">    template&lt;typename _Engine, typename _DInputType&gt;</a>
<a name="ln154">      struct _Adaptor</a>
<a name="ln155">      {</a>
<a name="ln156">	static_assert(std::is_floating_point&lt;_DInputType&gt;::value,</a>
<a name="ln157">		      &quot;template argument must be a floating point type&quot;);</a>
<a name="ln158"> </a>
<a name="ln159">      public:</a>
<a name="ln160">	_Adaptor(_Engine&amp; __g)</a>
<a name="ln161">	: _M_g(__g) { }</a>
<a name="ln162"> </a>
<a name="ln163">	_DInputType</a>
<a name="ln164">	min() const</a>
<a name="ln165">	{ return _DInputType(0); }</a>
<a name="ln166"> </a>
<a name="ln167">	_DInputType</a>
<a name="ln168">	max() const</a>
<a name="ln169">	{ return _DInputType(1); }</a>
<a name="ln170"> </a>
<a name="ln171">	/*</a>
<a name="ln172">	 * Converts a value generated by the adapted random number generator</a>
<a name="ln173">	 * into a value in the input domain for the dependent random number</a>
<a name="ln174">	 * distribution.</a>
<a name="ln175">	 */</a>
<a name="ln176">	_DInputType</a>
<a name="ln177">	operator()()</a>
<a name="ln178">	{</a>
<a name="ln179">	  return std::generate_canonical&lt;_DInputType,</a>
<a name="ln180">	                            std::numeric_limits&lt;_DInputType&gt;::digits,</a>
<a name="ln181">	                            _Engine&gt;(_M_g);</a>
<a name="ln182">	}</a>
<a name="ln183"> </a>
<a name="ln184">      private:</a>
<a name="ln185">	_Engine&amp; _M_g;</a>
<a name="ln186">      };</a>
<a name="ln187"> </a>
<a name="ln188">  } // namespace __detail</a>
<a name="ln189"> </a>
<a name="ln190">  /**</a>
<a name="ln191">   * @addtogroup random_generators Random Number Generators</a>
<a name="ln192">   * @ingroup random</a>
<a name="ln193">   *</a>
<a name="ln194">   * These classes define objects which provide random or pseudorandom</a>
<a name="ln195">   * numbers, either from a discrete or a continuous interval.  The</a>
<a name="ln196">   * random number generator supplied as a part of this library are</a>
<a name="ln197">   * all uniform random number generators which provide a sequence of</a>
<a name="ln198">   * random number uniformly distributed over their range.</a>
<a name="ln199">   *</a>
<a name="ln200">   * A number generator is a function object with an operator() that</a>
<a name="ln201">   * takes zero arguments and returns a number.</a>
<a name="ln202">   *</a>
<a name="ln203">   * A compliant random number generator must satisfy the following</a>
<a name="ln204">   * requirements.  &lt;table border=1 cellpadding=10 cellspacing=0&gt;</a>
<a name="ln205">   * &lt;caption align=top&gt;Random Number Generator Requirements&lt;/caption&gt;</a>
<a name="ln206">   * &lt;tr&gt;&lt;td&gt;To be documented.&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt;</a>
<a name="ln207">   *</a>
<a name="ln208">   * @{</a>
<a name="ln209">   */</a>
<a name="ln210"> </a>
<a name="ln211">  /**</a>
<a name="ln212">   * @brief A model of a linear congruential random number generator.</a>
<a name="ln213">   *</a>
<a name="ln214">   * A random number generator that produces pseudorandom numbers via</a>
<a name="ln215">   * linear function:</a>
<a name="ln216">   * @f[</a>
<a name="ln217">   *     x_{i+1}\leftarrow(ax_{i} + c) \bmod m </a>
<a name="ln218">   * @f]</a>
<a name="ln219">   *</a>
<a name="ln220">   * The template parameter @p _UIntType must be an unsigned integral type</a>
<a name="ln221">   * large enough to store values up to (__m-1). If the template parameter</a>
<a name="ln222">   * @p __m is 0, the modulus @p __m used is</a>
<a name="ln223">   * std::numeric_limits&lt;_UIntType&gt;::max() plus 1. Otherwise, the template</a>
<a name="ln224">   * parameters @p __a and @p __c must be less than @p __m.</a>
<a name="ln225">   *</a>
<a name="ln226">   * The size of the state is @f$1@f$.</a>
<a name="ln227">   */</a>
<a name="ln228">  template&lt;typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m&gt;</a>
<a name="ln229">    class linear_congruential_engine</a>
<a name="ln230">    {</a>
<a name="ln231">      static_assert(std::is_unsigned&lt;_UIntType&gt;::value,</a>
<a name="ln232">		    &quot;result_type must be an unsigned integral type&quot;);</a>
<a name="ln233">      static_assert(__m == 0u || (__a &lt; __m &amp;&amp; __c &lt; __m),</a>
<a name="ln234">		    &quot;template argument substituting __m out of bounds&quot;);</a>
<a name="ln235"> </a>
<a name="ln236">    public:</a>
<a name="ln237">      /** The type of the generated random value. */</a>
<a name="ln238">      typedef _UIntType result_type;</a>
<a name="ln239"> </a>
<a name="ln240">      /** The multiplier. */</a>
<a name="ln241">      static constexpr result_type multiplier   = __a;</a>
<a name="ln242">      /** An increment. */</a>
<a name="ln243">      static constexpr result_type increment    = __c;</a>
<a name="ln244">      /** The modulus. */</a>
<a name="ln245">      static constexpr result_type modulus      = __m;</a>
<a name="ln246">      static constexpr result_type default_seed = 1u;</a>
<a name="ln247"> </a>
<a name="ln248">      /**</a>
<a name="ln249">       * @brief Constructs a %linear_congruential_engine random number</a>
<a name="ln250">       *        generator engine with seed @p __s.  The default seed value</a>
<a name="ln251">       *        is 1.</a>
<a name="ln252">       *</a>
<a name="ln253">       * @param __s The initial seed value.</a>
<a name="ln254">       */</a>
<a name="ln255">      explicit</a>
<a name="ln256">      linear_congruential_engine(result_type __s = default_seed)</a>
<a name="ln257">      { seed(__s); }</a>
<a name="ln258"> </a>
<a name="ln259">      /**</a>
<a name="ln260">       * @brief Constructs a %linear_congruential_engine random number</a>
<a name="ln261">       *        generator engine seeded from the seed sequence @p __q.</a>
<a name="ln262">       *</a>
<a name="ln263">       * @param __q the seed sequence.</a>
<a name="ln264">       */</a>
<a name="ln265">      template&lt;typename _Sseq, typename = typename</a>
<a name="ln266">	std::enable_if&lt;!std::is_same&lt;_Sseq, linear_congruential_engine&gt;::value&gt;</a>
<a name="ln267">	       ::type&gt;</a>
<a name="ln268">        explicit</a>
<a name="ln269">        linear_congruential_engine(_Sseq&amp; __q)</a>
<a name="ln270">        { seed(__q); }</a>
<a name="ln271"> </a>
<a name="ln272">      /**</a>
<a name="ln273">       * @brief Reseeds the %linear_congruential_engine random number generator</a>
<a name="ln274">       *        engine sequence to the seed @p __s.</a>
<a name="ln275">       *</a>
<a name="ln276">       * @param __s The new seed.</a>
<a name="ln277">       */</a>
<a name="ln278">      void</a>
<a name="ln279">      seed(result_type __s = default_seed);</a>
<a name="ln280"> </a>
<a name="ln281">      /**</a>
<a name="ln282">       * @brief Reseeds the %linear_congruential_engine random number generator</a>
<a name="ln283">       *        engine</a>
<a name="ln284">       * sequence using values from the seed sequence @p __q.</a>
<a name="ln285">       *</a>
<a name="ln286">       * @param __q the seed sequence.</a>
<a name="ln287">       */</a>
<a name="ln288">      template&lt;typename _Sseq&gt;</a>
<a name="ln289">        typename std::enable_if&lt;std::is_class&lt;_Sseq&gt;::value&gt;::type</a>
<a name="ln290">        seed(_Sseq&amp; __q);</a>
<a name="ln291"> </a>
<a name="ln292">      /**</a>
<a name="ln293">       * @brief Gets the smallest possible value in the output range.</a>
<a name="ln294">       *</a>
<a name="ln295">       * The minimum depends on the @p __c parameter: if it is zero, the</a>
<a name="ln296">       * minimum generated must be &gt; 0, otherwise 0 is allowed.</a>
<a name="ln297">       */</a>
<a name="ln298">      static constexpr result_type</a>
<a name="ln299">      min()</a>
<a name="ln300">      { return __c == 0u ? 1u : 0u; }</a>
<a name="ln301"> </a>
<a name="ln302">      /**</a>
<a name="ln303">       * @brief Gets the largest possible value in the output range.</a>
<a name="ln304">       */</a>
<a name="ln305">      static constexpr result_type</a>
<a name="ln306">      max()</a>
<a name="ln307">      { return __m - 1u; }</a>
<a name="ln308"> </a>
<a name="ln309">      /**</a>
<a name="ln310">       * @brief Discard a sequence of random numbers.</a>
<a name="ln311">       */</a>
<a name="ln312">      void</a>
<a name="ln313">      discard(unsigned long long __z)</a>
<a name="ln314">      {</a>
<a name="ln315">	for (; __z != 0ULL; --__z)</a>
<a name="ln316">	  (*this)();</a>
<a name="ln317">      }</a>
<a name="ln318"> </a>
<a name="ln319">      /**</a>
<a name="ln320">       * @brief Gets the next random number in the sequence.</a>
<a name="ln321">       */</a>
<a name="ln322">      result_type</a>
<a name="ln323">      operator()()</a>
<a name="ln324">      {</a>
<a name="ln325">	_M_x = __detail::__mod&lt;_UIntType, __m, __a, __c&gt;(_M_x);</a>
<a name="ln326">	return _M_x;</a>
<a name="ln327">      }</a>
<a name="ln328"> </a>
<a name="ln329">      /**</a>
<a name="ln330">       * @brief Compares two linear congruential random number generator</a>
<a name="ln331">       * objects of the same type for equality.</a>
<a name="ln332">       *</a>
<a name="ln333">       * @param __lhs A linear congruential random number generator object.</a>
<a name="ln334">       * @param __rhs Another linear congruential random number generator</a>
<a name="ln335">       *              object.</a>
<a name="ln336">       *</a>
<a name="ln337">       * @returns true if the infinite sequences of generated values</a>
<a name="ln338">       *          would be equal, false otherwise.</a>
<a name="ln339">       */</a>
<a name="ln340">      friend bool</a>
<a name="ln341">      operator==(const linear_congruential_engine&amp; __lhs,</a>
<a name="ln342">		 const linear_congruential_engine&amp; __rhs)</a>
<a name="ln343">      { return __lhs._M_x == __rhs._M_x; }</a>
<a name="ln344"> </a>
<a name="ln345">      /**</a>
<a name="ln346">       * @brief Writes the textual representation of the state x(i) of x to</a>
<a name="ln347">       *        @p __os.</a>
<a name="ln348">       *</a>
<a name="ln349">       * @param __os  The output stream.</a>
<a name="ln350">       * @param __lcr A % linear_congruential_engine random number generator.</a>
<a name="ln351">       * @returns __os.</a>
<a name="ln352">       */</a>
<a name="ln353">      template&lt;typename _UIntType1, _UIntType1 __a1, _UIntType1 __c1,</a>
<a name="ln354">	       _UIntType1 __m1, typename _CharT, typename _Traits&gt;</a>
<a name="ln355">	friend std::basic_ostream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln356">	operator&lt;&lt;(std::basic_ostream&lt;_CharT, _Traits&gt;&amp; __os,</a>
<a name="ln357">		   const std::linear_congruential_engine&lt;_UIntType1,</a>
<a name="ln358">		   __a1, __c1, __m1&gt;&amp; __lcr);</a>
<a name="ln359"> </a>
<a name="ln360">      /**</a>
<a name="ln361">       * @brief Sets the state of the engine by reading its textual</a>
<a name="ln362">       *        representation from @p __is.</a>
<a name="ln363">       *</a>
<a name="ln364">       * The textual representation must have been previously written using</a>
<a name="ln365">       * an output stream whose imbued locale and whose type's template</a>
<a name="ln366">       * specialization arguments _CharT and _Traits were the same as those</a>
<a name="ln367">       * of @p __is.</a>
<a name="ln368">       *</a>
<a name="ln369">       * @param __is  The input stream.</a>
<a name="ln370">       * @param __lcr A % linear_congruential_engine random number generator.</a>
<a name="ln371">       * @returns __is.</a>
<a name="ln372">       */</a>
<a name="ln373">      template&lt;typename _UIntType1, _UIntType1 __a1, _UIntType1 __c1,</a>
<a name="ln374">	       _UIntType1 __m1, typename _CharT, typename _Traits&gt;</a>
<a name="ln375">	friend std::basic_istream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln376">	operator&gt;&gt;(std::basic_istream&lt;_CharT, _Traits&gt;&amp; __is,</a>
<a name="ln377">		   std::linear_congruential_engine&lt;_UIntType1, __a1,</a>
<a name="ln378">		   __c1, __m1&gt;&amp; __lcr);</a>
<a name="ln379"> </a>
<a name="ln380">    private:</a>
<a name="ln381">      _UIntType _M_x;</a>
<a name="ln382">    };</a>
<a name="ln383"> </a>
<a name="ln384">  /**</a>
<a name="ln385">   * @brief Compares two linear congruential random number generator</a>
<a name="ln386">   * objects of the same type for inequality.</a>
<a name="ln387">   *</a>
<a name="ln388">   * @param __lhs A linear congruential random number generator object.</a>
<a name="ln389">   * @param __rhs Another linear congruential random number generator</a>
<a name="ln390">   *              object.</a>
<a name="ln391">   *</a>
<a name="ln392">   * @returns true if the infinite sequences of generated values</a>
<a name="ln393">   *          would be different, false otherwise.</a>
<a name="ln394">   */</a>
<a name="ln395">  template&lt;typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m&gt;</a>
<a name="ln396">    inline bool</a>
<a name="ln397">    operator!=(const std::linear_congruential_engine&lt;_UIntType, __a,</a>
<a name="ln398">	       __c, __m&gt;&amp; __lhs,</a>
<a name="ln399">	       const std::linear_congruential_engine&lt;_UIntType, __a,</a>
<a name="ln400">	       __c, __m&gt;&amp; __rhs)</a>
<a name="ln401">    { return !(__lhs == __rhs); }</a>
<a name="ln402"> </a>
<a name="ln403"> </a>
<a name="ln404">  /**</a>
<a name="ln405">   * A generalized feedback shift register discrete random number generator.</a>
<a name="ln406">   *</a>
<a name="ln407">   * This algorithm avoids multiplication and division and is designed to be</a>
<a name="ln408">   * friendly to a pipelined architecture.  If the parameters are chosen</a>
<a name="ln409">   * correctly, this generator will produce numbers with a very long period and</a>
<a name="ln410">   * fairly good apparent entropy, although still not cryptographically strong.</a>
<a name="ln411">   *</a>
<a name="ln412">   * The best way to use this generator is with the predefined mt19937 class.</a>
<a name="ln413">   *</a>
<a name="ln414">   * This algorithm was originally invented by Makoto Matsumoto and</a>
<a name="ln415">   * Takuji Nishimura.</a>
<a name="ln416">   *</a>
<a name="ln417">   * @tparam __w  Word size, the number of bits in each element of </a>
<a name="ln418">   *              the state vector.</a>
<a name="ln419">   * @tparam __n  The degree of recursion.</a>
<a name="ln420">   * @tparam __m  The period parameter.</a>
<a name="ln421">   * @tparam __r  The separation point bit index.</a>
<a name="ln422">   * @tparam __a  The last row of the twist matrix.</a>
<a name="ln423">   * @tparam __u  The first right-shift tempering matrix parameter.</a>
<a name="ln424">   * @tparam __d  The first right-shift tempering matrix mask.</a>
<a name="ln425">   * @tparam __s  The first left-shift tempering matrix parameter.</a>
<a name="ln426">   * @tparam __b  The first left-shift tempering matrix mask.</a>
<a name="ln427">   * @tparam __t  The second left-shift tempering matrix parameter.</a>
<a name="ln428">   * @tparam __c  The second left-shift tempering matrix mask.</a>
<a name="ln429">   * @tparam __l  The second right-shift tempering matrix parameter.</a>
<a name="ln430">   * @tparam __f  Initialization multiplier.</a>
<a name="ln431">   */</a>
<a name="ln432">  template&lt;typename _UIntType, size_t __w,</a>
<a name="ln433">	   size_t __n, size_t __m, size_t __r,</a>
<a name="ln434">	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,</a>
<a name="ln435">	   _UIntType __b, size_t __t,</a>
<a name="ln436">	   _UIntType __c, size_t __l, _UIntType __f&gt;</a>
<a name="ln437">    class mersenne_twister_engine</a>
<a name="ln438">    {</a>
<a name="ln439">      static_assert(std::is_unsigned&lt;_UIntType&gt;::value,</a>
<a name="ln440">		    &quot;result_type must be an unsigned integral type&quot;);</a>
<a name="ln441">      static_assert(1u &lt;= __m &amp;&amp; __m &lt;= __n,</a>
<a name="ln442">		    &quot;template argument substituting __m out of bounds&quot;);</a>
<a name="ln443">      static_assert(__r &lt;= __w, &quot;template argument substituting &quot;</a>
<a name="ln444">		    &quot;__r out of bound&quot;);</a>
<a name="ln445">      static_assert(__u &lt;= __w, &quot;template argument substituting &quot;</a>
<a name="ln446">		    &quot;__u out of bound&quot;);</a>
<a name="ln447">      static_assert(__s &lt;= __w, &quot;template argument substituting &quot;</a>
<a name="ln448">		    &quot;__s out of bound&quot;);</a>
<a name="ln449">      static_assert(__t &lt;= __w, &quot;template argument substituting &quot;</a>
<a name="ln450">		    &quot;__t out of bound&quot;);</a>
<a name="ln451">      static_assert(__l &lt;= __w, &quot;template argument substituting &quot;</a>
<a name="ln452">		    &quot;__l out of bound&quot;);</a>
<a name="ln453">      static_assert(__w &lt;= std::numeric_limits&lt;_UIntType&gt;::digits,</a>
<a name="ln454">		    &quot;template argument substituting __w out of bound&quot;);</a>
<a name="ln455">      static_assert(__a &lt;= (__detail::_Shift&lt;_UIntType, __w&gt;::__value - 1),</a>
<a name="ln456">		    &quot;template argument substituting __a out of bound&quot;);</a>
<a name="ln457">      static_assert(__b &lt;= (__detail::_Shift&lt;_UIntType, __w&gt;::__value - 1),</a>
<a name="ln458">		    &quot;template argument substituting __b out of bound&quot;);</a>
<a name="ln459">      static_assert(__c &lt;= (__detail::_Shift&lt;_UIntType, __w&gt;::__value - 1),</a>
<a name="ln460">		    &quot;template argument substituting __c out of bound&quot;);</a>
<a name="ln461">      static_assert(__d &lt;= (__detail::_Shift&lt;_UIntType, __w&gt;::__value - 1),</a>
<a name="ln462">		    &quot;template argument substituting __d out of bound&quot;);</a>
<a name="ln463">      static_assert(__f &lt;= (__detail::_Shift&lt;_UIntType, __w&gt;::__value - 1),</a>
<a name="ln464">		    &quot;template argument substituting __f out of bound&quot;);</a>
<a name="ln465"> </a>
<a name="ln466">    public:</a>
<a name="ln467">      /** The type of the generated random value. */</a>
<a name="ln468">      typedef _UIntType result_type;</a>
<a name="ln469"> </a>
<a name="ln470">      // parameter values</a>
<a name="ln471">      static constexpr size_t      word_size                 = __w;</a>
<a name="ln472">      static constexpr size_t      state_size                = __n;</a>
<a name="ln473">      static constexpr size_t      shift_size                = __m;</a>
<a name="ln474">      static constexpr size_t      mask_bits                 = __r;</a>
<a name="ln475">      static constexpr result_type xor_mask                  = __a;</a>
<a name="ln476">      static constexpr size_t      tempering_u               = __u;</a>
<a name="ln477">      static constexpr result_type tempering_d               = __d;</a>
<a name="ln478">      static constexpr size_t      tempering_s               = __s;</a>
<a name="ln479">      static constexpr result_type tempering_b               = __b;</a>
<a name="ln480">      static constexpr size_t      tempering_t               = __t;</a>
<a name="ln481">      static constexpr result_type tempering_c               = __c;</a>
<a name="ln482">      static constexpr size_t      tempering_l               = __l;</a>
<a name="ln483">      static constexpr result_type initialization_multiplier = __f;</a>
<a name="ln484">      static constexpr result_type default_seed = 5489u;</a>
<a name="ln485"> </a>
<a name="ln486">      // constructors and member function</a>
<a name="ln487">      explicit</a>
<a name="ln488">      mersenne_twister_engine(result_type __sd = default_seed)</a>
<a name="ln489">      { seed(__sd); }</a>
<a name="ln490"> </a>
<a name="ln491">      /**</a>
<a name="ln492">       * @brief Constructs a %mersenne_twister_engine random number generator</a>
<a name="ln493">       *        engine seeded from the seed sequence @p __q.</a>
<a name="ln494">       *</a>
<a name="ln495">       * @param __q the seed sequence.</a>
<a name="ln496">       */</a>
<a name="ln497">      template&lt;typename _Sseq, typename = typename</a>
<a name="ln498">        std::enable_if&lt;!std::is_same&lt;_Sseq, mersenne_twister_engine&gt;::value&gt;</a>
<a name="ln499">	       ::type&gt;</a>
<a name="ln500">        explicit</a>
<a name="ln501">        mersenne_twister_engine(_Sseq&amp; __q)</a>
<a name="ln502">        { seed(__q); }</a>
<a name="ln503"> </a>
<a name="ln504">      void</a>
<a name="ln505">      seed(result_type __sd = default_seed);</a>
<a name="ln506"> </a>
<a name="ln507">      template&lt;typename _Sseq&gt;</a>
<a name="ln508">	typename std::enable_if&lt;std::is_class&lt;_Sseq&gt;::value&gt;::type</a>
<a name="ln509">        seed(_Sseq&amp; __q);</a>
<a name="ln510"> </a>
<a name="ln511">      /**</a>
<a name="ln512">       * @brief Gets the smallest possible value in the output range.</a>
<a name="ln513">       */</a>
<a name="ln514">      static constexpr result_type</a>
<a name="ln515">      min()</a>
<a name="ln516">      { return 0; }</a>
<a name="ln517"> </a>
<a name="ln518">      /**</a>
<a name="ln519">       * @brief Gets the largest possible value in the output range.</a>
<a name="ln520">       */</a>
<a name="ln521">      static constexpr result_type</a>
<a name="ln522">      max()</a>
<a name="ln523">      { return __detail::_Shift&lt;_UIntType, __w&gt;::__value - 1; }</a>
<a name="ln524"> </a>
<a name="ln525">      /**</a>
<a name="ln526">       * @brief Discard a sequence of random numbers.</a>
<a name="ln527">       */</a>
<a name="ln528">      void</a>
<a name="ln529">      discard(unsigned long long __z);</a>
<a name="ln530"> </a>
<a name="ln531">      result_type</a>
<a name="ln532">      operator()();</a>
<a name="ln533"> </a>
<a name="ln534">      /**</a>
<a name="ln535">       * @brief Compares two % mersenne_twister_engine random number generator</a>
<a name="ln536">       *        objects of the same type for equality.</a>
<a name="ln537">       *</a>
<a name="ln538">       * @param __lhs A % mersenne_twister_engine random number generator</a>
<a name="ln539">       *              object.</a>
<a name="ln540">       * @param __rhs Another % mersenne_twister_engine random number</a>
<a name="ln541">       *              generator object.</a>
<a name="ln542">       *</a>
<a name="ln543">       * @returns true if the infinite sequences of generated values</a>
<a name="ln544">       *          would be equal, false otherwise.</a>
<a name="ln545">       */</a>
<a name="ln546">      friend bool</a>
<a name="ln547">      operator==(const mersenne_twister_engine&amp; __lhs,</a>
<a name="ln548">		 const mersenne_twister_engine&amp; __rhs)</a>
<a name="ln549">      { return (std::equal(__lhs._M_x, __lhs._M_x + state_size, __rhs._M_x)</a>
<a name="ln550">		&amp;&amp; __lhs._M_p == __rhs._M_p); }</a>
<a name="ln551"> </a>
<a name="ln552">      /**</a>
<a name="ln553">       * @brief Inserts the current state of a % mersenne_twister_engine</a>
<a name="ln554">       *        random number generator engine @p __x into the output stream</a>
<a name="ln555">       *        @p __os.</a>
<a name="ln556">       *</a>
<a name="ln557">       * @param __os An output stream.</a>
<a name="ln558">       * @param __x  A % mersenne_twister_engine random number generator</a>
<a name="ln559">       *             engine.</a>
<a name="ln560">       *</a>
<a name="ln561">       * @returns The output stream with the state of @p __x inserted or in</a>
<a name="ln562">       * an error state.</a>
<a name="ln563">       */</a>
<a name="ln564">      template&lt;typename _UIntType1,</a>
<a name="ln565">	       size_t __w1, size_t __n1,</a>
<a name="ln566">	       size_t __m1, size_t __r1,</a>
<a name="ln567">	       _UIntType1 __a1, size_t __u1,</a>
<a name="ln568">	       _UIntType1 __d1, size_t __s1,</a>
<a name="ln569">	       _UIntType1 __b1, size_t __t1,</a>
<a name="ln570">	       _UIntType1 __c1, size_t __l1, _UIntType1 __f1,</a>
<a name="ln571">	       typename _CharT, typename _Traits&gt;</a>
<a name="ln572">	friend std::basic_ostream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln573">	operator&lt;&lt;(std::basic_ostream&lt;_CharT, _Traits&gt;&amp; __os,</a>
<a name="ln574">		   const std::mersenne_twister_engine&lt;_UIntType1, __w1, __n1,</a>
<a name="ln575">		   __m1, __r1, __a1, __u1, __d1, __s1, __b1, __t1, __c1,</a>
<a name="ln576">		   __l1, __f1&gt;&amp; __x);</a>
<a name="ln577"> </a>
<a name="ln578">      /**</a>
<a name="ln579">       * @brief Extracts the current state of a % mersenne_twister_engine</a>
<a name="ln580">       *        random number generator engine @p __x from the input stream</a>
<a name="ln581">       *        @p __is.</a>
<a name="ln582">       *</a>
<a name="ln583">       * @param __is An input stream.</a>
<a name="ln584">       * @param __x  A % mersenne_twister_engine random number generator</a>
<a name="ln585">       *             engine.</a>
<a name="ln586">       *</a>
<a name="ln587">       * @returns The input stream with the state of @p __x extracted or in</a>
<a name="ln588">       * an error state.</a>
<a name="ln589">       */</a>
<a name="ln590">      template&lt;typename _UIntType1,</a>
<a name="ln591">	       size_t __w1, size_t __n1,</a>
<a name="ln592">	       size_t __m1, size_t __r1,</a>
<a name="ln593">	       _UIntType1 __a1, size_t __u1,</a>
<a name="ln594">	       _UIntType1 __d1, size_t __s1,</a>
<a name="ln595">	       _UIntType1 __b1, size_t __t1,</a>
<a name="ln596">	       _UIntType1 __c1, size_t __l1, _UIntType1 __f1,</a>
<a name="ln597">	       typename _CharT, typename _Traits&gt;</a>
<a name="ln598">	friend std::basic_istream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln599">	operator&gt;&gt;(std::basic_istream&lt;_CharT, _Traits&gt;&amp; __is,</a>
<a name="ln600">		   std::mersenne_twister_engine&lt;_UIntType1, __w1, __n1, __m1,</a>
<a name="ln601">		   __r1, __a1, __u1, __d1, __s1, __b1, __t1, __c1,</a>
<a name="ln602">		   __l1, __f1&gt;&amp; __x);</a>
<a name="ln603"> </a>
<a name="ln604">    private:</a>
<a name="ln605">      void _M_gen_rand();</a>
<a name="ln606"> </a>
<a name="ln607">      _UIntType _M_x[state_size];</a>
<a name="ln608">      size_t    _M_p;</a>
<a name="ln609">    };</a>
<a name="ln610"> </a>
<a name="ln611">  /**</a>
<a name="ln612">   * @brief Compares two % mersenne_twister_engine random number generator</a>
<a name="ln613">   *        objects of the same type for inequality.</a>
<a name="ln614">   *</a>
<a name="ln615">   * @param __lhs A % mersenne_twister_engine random number generator</a>
<a name="ln616">   *              object.</a>
<a name="ln617">   * @param __rhs Another % mersenne_twister_engine random number</a>
<a name="ln618">   *              generator object.</a>
<a name="ln619">   *</a>
<a name="ln620">   * @returns true if the infinite sequences of generated values</a>
<a name="ln621">   *          would be different, false otherwise.</a>
<a name="ln622">   */</a>
<a name="ln623">  template&lt;typename _UIntType, size_t __w,</a>
<a name="ln624">	   size_t __n, size_t __m, size_t __r,</a>
<a name="ln625">	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,</a>
<a name="ln626">	   _UIntType __b, size_t __t,</a>
<a name="ln627">	   _UIntType __c, size_t __l, _UIntType __f&gt;</a>
<a name="ln628">    inline bool</a>
<a name="ln629">    operator!=(const std::mersenne_twister_engine&lt;_UIntType, __w, __n, __m,</a>
<a name="ln630">	       __r, __a, __u, __d, __s, __b, __t, __c, __l, __f&gt;&amp; __lhs,</a>
<a name="ln631">	       const std::mersenne_twister_engine&lt;_UIntType, __w, __n, __m,</a>
<a name="ln632">	       __r, __a, __u, __d, __s, __b, __t, __c, __l, __f&gt;&amp; __rhs)</a>
<a name="ln633">    { return !(__lhs == __rhs); }</a>
<a name="ln634"> </a>
<a name="ln635"> </a>
<a name="ln636">  /**</a>
<a name="ln637">   * @brief The Marsaglia-Zaman generator.</a>
<a name="ln638">   *</a>
<a name="ln639">   * This is a model of a Generalized Fibonacci discrete random number</a>
<a name="ln640">   * generator, sometimes referred to as the SWC generator.</a>
<a name="ln641">   *</a>
<a name="ln642">   * A discrete random number generator that produces pseudorandom</a>
<a name="ln643">   * numbers using:</a>
<a name="ln644">   * @f[</a>
<a name="ln645">   *     x_{i}\leftarrow(x_{i - s} - x_{i - r} - carry_{i-1}) \bmod m </a>
<a name="ln646">   * @f]</a>
<a name="ln647">   *</a>
<a name="ln648">   * The size of the state is @f$r@f$</a>
<a name="ln649">   * and the maximum period of the generator is @f$(m^r - m^s - 1)@f$.</a>
<a name="ln650">   */</a>
<a name="ln651">  template&lt;typename _UIntType, size_t __w, size_t __s, size_t __r&gt;</a>
<a name="ln652">    class subtract_with_carry_engine</a>
<a name="ln653">    {</a>
<a name="ln654">      static_assert(std::is_unsigned&lt;_UIntType&gt;::value,</a>
<a name="ln655">		    &quot;result_type must be an unsigned integral type&quot;);</a>
<a name="ln656">      static_assert(0u &lt; __s &amp;&amp; __s &lt; __r,</a>
<a name="ln657">		    &quot;0 &lt; s &lt; r&quot;);</a>
<a name="ln658">      static_assert(0u &lt; __w &amp;&amp; __w &lt;= std::numeric_limits&lt;_UIntType&gt;::digits,</a>
<a name="ln659">		    &quot;template argument substituting __w out of bounds&quot;);</a>
<a name="ln660"> </a>
<a name="ln661">    public:</a>
<a name="ln662">      /** The type of the generated random value. */</a>
<a name="ln663">      typedef _UIntType result_type;</a>
<a name="ln664"> </a>
<a name="ln665">      // parameter values</a>
<a name="ln666">      static constexpr size_t      word_size    = __w;</a>
<a name="ln667">      static constexpr size_t      short_lag    = __s;</a>
<a name="ln668">      static constexpr size_t      long_lag     = __r;</a>
<a name="ln669">      static constexpr result_type default_seed = 19780503u;</a>
<a name="ln670"> </a>
<a name="ln671">      /**</a>
<a name="ln672">       * @brief Constructs an explicitly seeded % subtract_with_carry_engine</a>
<a name="ln673">       *        random number generator.</a>
<a name="ln674">       */</a>
<a name="ln675">      explicit</a>
<a name="ln676">      subtract_with_carry_engine(result_type __sd = default_seed)</a>
<a name="ln677">      { seed(__sd); }</a>
<a name="ln678"> </a>
<a name="ln679">      /**</a>
<a name="ln680">       * @brief Constructs a %subtract_with_carry_engine random number engine</a>
<a name="ln681">       *        seeded from the seed sequence @p __q.</a>
<a name="ln682">       *</a>
<a name="ln683">       * @param __q the seed sequence.</a>
<a name="ln684">       */</a>
<a name="ln685">      template&lt;typename _Sseq, typename = typename</a>
<a name="ln686">        std::enable_if&lt;!std::is_same&lt;_Sseq, subtract_with_carry_engine&gt;::value&gt;</a>
<a name="ln687">	       ::type&gt;</a>
<a name="ln688">        explicit</a>
<a name="ln689">        subtract_with_carry_engine(_Sseq&amp; __q)</a>
<a name="ln690">        { seed(__q); }</a>
<a name="ln691"> </a>
<a name="ln692">      /**</a>
<a name="ln693">       * @brief Seeds the initial state @f$x_0@f$ of the random number</a>
<a name="ln694">       *        generator.</a>
<a name="ln695">       *</a>
<a name="ln696">       * N1688[4.19] modifies this as follows.  If @p __value == 0,</a>
<a name="ln697">       * sets value to 19780503.  In any case, with a linear</a>
<a name="ln698">       * congruential generator lcg(i) having parameters @f$ m_{lcg} =</a>
<a name="ln699">       * 2147483563, a_{lcg} = 40014, c_{lcg} = 0, and lcg(0) = value</a>
<a name="ln700">       * @f$, sets @f$ x_{-r} \dots x_{-1} @f$ to @f$ lcg(1) \bmod m</a>
<a name="ln701">       * \dots lcg(r) \bmod m @f$ respectively.  If @f$ x_{-1} = 0 @f$</a>
<a name="ln702">       * set carry to 1, otherwise sets carry to 0.</a>
<a name="ln703">       */</a>
<a name="ln704">      void</a>
<a name="ln705">      seed(result_type __sd = default_seed);</a>
<a name="ln706"> </a>
<a name="ln707">      /**</a>
<a name="ln708">       * @brief Seeds the initial state @f$x_0@f$ of the</a>
<a name="ln709">       * % subtract_with_carry_engine random number generator.</a>
<a name="ln710">       */</a>
<a name="ln711">      template&lt;typename _Sseq&gt;</a>
<a name="ln712">	typename std::enable_if&lt;std::is_class&lt;_Sseq&gt;::value&gt;::type</a>
<a name="ln713">        seed(_Sseq&amp; __q);</a>
<a name="ln714"> </a>
<a name="ln715">      /**</a>
<a name="ln716">       * @brief Gets the inclusive minimum value of the range of random</a>
<a name="ln717">       * integers returned by this generator.</a>
<a name="ln718">       */</a>
<a name="ln719">      static constexpr result_type</a>
<a name="ln720">      min()</a>
<a name="ln721">      { return 0; }</a>
<a name="ln722"> </a>
<a name="ln723">      /**</a>
<a name="ln724">       * @brief Gets the inclusive maximum value of the range of random</a>
<a name="ln725">       * integers returned by this generator.</a>
<a name="ln726">       */</a>
<a name="ln727">      static constexpr result_type</a>
<a name="ln728">      max()</a>
<a name="ln729">      { return __detail::_Shift&lt;_UIntType, __w&gt;::__value - 1; }</a>
<a name="ln730"> </a>
<a name="ln731">      /**</a>
<a name="ln732">       * @brief Discard a sequence of random numbers.</a>
<a name="ln733">       */</a>
<a name="ln734">      void</a>
<a name="ln735">      discard(unsigned long long __z)</a>
<a name="ln736">      {</a>
<a name="ln737">	for (; __z != 0ULL; --__z)</a>
<a name="ln738">	  (*this)();</a>
<a name="ln739">      }</a>
<a name="ln740"> </a>
<a name="ln741">      /**</a>
<a name="ln742">       * @brief Gets the next random number in the sequence.</a>
<a name="ln743">       */</a>
<a name="ln744">      result_type</a>
<a name="ln745">      operator()();</a>
<a name="ln746"> </a>
<a name="ln747">      /**</a>
<a name="ln748">       * @brief Compares two % subtract_with_carry_engine random number</a>
<a name="ln749">       *        generator objects of the same type for equality.</a>
<a name="ln750">       *</a>
<a name="ln751">       * @param __lhs A % subtract_with_carry_engine random number generator</a>
<a name="ln752">       *              object.</a>
<a name="ln753">       * @param __rhs Another % subtract_with_carry_engine random number</a>
<a name="ln754">       *              generator object.</a>
<a name="ln755">       *</a>
<a name="ln756">       * @returns true if the infinite sequences of generated values</a>
<a name="ln757">       *          would be equal, false otherwise.</a>
<a name="ln758">      */</a>
<a name="ln759">      friend bool</a>
<a name="ln760">      operator==(const subtract_with_carry_engine&amp; __lhs,</a>
<a name="ln761">		 const subtract_with_carry_engine&amp; __rhs)</a>
<a name="ln762">      { return (std::equal(__lhs._M_x, __lhs._M_x + long_lag, __rhs._M_x)</a>
<a name="ln763">		&amp;&amp; __lhs._M_carry == __rhs._M_carry</a>
<a name="ln764">		&amp;&amp; __lhs._M_p == __rhs._M_p); }</a>
<a name="ln765"> </a>
<a name="ln766">      /**</a>
<a name="ln767">       * @brief Inserts the current state of a % subtract_with_carry_engine</a>
<a name="ln768">       *        random number generator engine @p __x into the output stream</a>
<a name="ln769">       *        @p __os.</a>
<a name="ln770">       *</a>
<a name="ln771">       * @param __os An output stream.</a>
<a name="ln772">       * @param __x  A % subtract_with_carry_engine random number generator</a>
<a name="ln773">       *             engine.</a>
<a name="ln774">       *</a>
<a name="ln775">       * @returns The output stream with the state of @p __x inserted or in</a>
<a name="ln776">       * an error state.</a>
<a name="ln777">       */</a>
<a name="ln778">      template&lt;typename _UIntType1, size_t __w1, size_t __s1, size_t __r1,</a>
<a name="ln779">	       typename _CharT, typename _Traits&gt;</a>
<a name="ln780">	friend std::basic_ostream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln781">	operator&lt;&lt;(std::basic_ostream&lt;_CharT, _Traits&gt;&amp; __os,</a>
<a name="ln782">		   const std::subtract_with_carry_engine&lt;_UIntType1, __w1,</a>
<a name="ln783">		   __s1, __r1&gt;&amp; __x);</a>
<a name="ln784"> </a>
<a name="ln785">      /**</a>
<a name="ln786">       * @brief Extracts the current state of a % subtract_with_carry_engine</a>
<a name="ln787">       *        random number generator engine @p __x from the input stream</a>
<a name="ln788">       *        @p __is.</a>
<a name="ln789">       *</a>
<a name="ln790">       * @param __is An input stream.</a>
<a name="ln791">       * @param __x  A % subtract_with_carry_engine random number generator</a>
<a name="ln792">       *             engine.</a>
<a name="ln793">       *</a>
<a name="ln794">       * @returns The input stream with the state of @p __x extracted or in</a>
<a name="ln795">       * an error state.</a>
<a name="ln796">       */</a>
<a name="ln797">      template&lt;typename _UIntType1, size_t __w1, size_t __s1, size_t __r1,</a>
<a name="ln798">	       typename _CharT, typename _Traits&gt;</a>
<a name="ln799">	friend std::basic_istream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln800">	operator&gt;&gt;(std::basic_istream&lt;_CharT, _Traits&gt;&amp; __is,</a>
<a name="ln801">		   std::subtract_with_carry_engine&lt;_UIntType1, __w1,</a>
<a name="ln802">		   __s1, __r1&gt;&amp; __x);</a>
<a name="ln803"> </a>
<a name="ln804">    private:</a>
<a name="ln805">      /// The state of the generator.  This is a ring buffer.</a>
<a name="ln806">      _UIntType  _M_x[long_lag];</a>
<a name="ln807">      _UIntType  _M_carry;		///&lt; The carry</a>
<a name="ln808">      size_t     _M_p;			///&lt; Current index of x(i - r).</a>
<a name="ln809">    };</a>
<a name="ln810"> </a>
<a name="ln811">  /**</a>
<a name="ln812">   * @brief Compares two % subtract_with_carry_engine random number</a>
<a name="ln813">   *        generator objects of the same type for inequality.</a>
<a name="ln814">   *</a>
<a name="ln815">   * @param __lhs A % subtract_with_carry_engine random number generator</a>
<a name="ln816">   *              object.</a>
<a name="ln817">   * @param __rhs Another % subtract_with_carry_engine random number</a>
<a name="ln818">   *              generator object.</a>
<a name="ln819">   *</a>
<a name="ln820">   * @returns true if the infinite sequences of generated values</a>
<a name="ln821">   *          would be different, false otherwise.</a>
<a name="ln822">   */</a>
<a name="ln823">  template&lt;typename _UIntType, size_t __w, size_t __s, size_t __r&gt;</a>
<a name="ln824">    inline bool</a>
<a name="ln825">    operator!=(const std::subtract_with_carry_engine&lt;_UIntType, __w,</a>
<a name="ln826">	       __s, __r&gt;&amp; __lhs,</a>
<a name="ln827">	       const std::subtract_with_carry_engine&lt;_UIntType, __w,</a>
<a name="ln828">	       __s, __r&gt;&amp; __rhs)</a>
<a name="ln829">    { return !(__lhs == __rhs); }</a>
<a name="ln830"> </a>
<a name="ln831"> </a>
<a name="ln832">  /**</a>
<a name="ln833">   * Produces random numbers from some base engine by discarding blocks of</a>
<a name="ln834">   * data.</a>
<a name="ln835">   *</a>
<a name="ln836">   * 0 &lt;= @p __r &lt;= @p __p</a>
<a name="ln837">   */</a>
<a name="ln838">  template&lt;typename _RandomNumberEngine, size_t __p, size_t __r&gt;</a>
<a name="ln839">    class discard_block_engine</a>
<a name="ln840">    {</a>
<a name="ln841">      static_assert(1 &lt;= __r &amp;&amp; __r &lt;= __p,</a>
<a name="ln842">		    &quot;template argument substituting __r out of bounds&quot;);</a>
<a name="ln843"> </a>
<a name="ln844">    public:</a>
<a name="ln845">      /** The type of the generated random value. */</a>
<a name="ln846">      typedef typename _RandomNumberEngine::result_type result_type;</a>
<a name="ln847"> </a>
<a name="ln848">      // parameter values</a>
<a name="ln849">      static constexpr size_t block_size = __p;</a>
<a name="ln850">      static constexpr size_t used_block = __r;</a>
<a name="ln851"> </a>
<a name="ln852">      /**</a>
<a name="ln853">       * @brief Constructs a default %discard_block_engine engine.</a>
<a name="ln854">       *</a>
<a name="ln855">       * The underlying engine is default constructed as well.</a>
<a name="ln856">       */</a>
<a name="ln857">      discard_block_engine()</a>
<a name="ln858">      : _M_b(), _M_n(0) { }</a>
<a name="ln859"> </a>
<a name="ln860">      /**</a>
<a name="ln861">       * @brief Copy constructs a %discard_block_engine engine.</a>
<a name="ln862">       *</a>
<a name="ln863">       * Copies an existing base class random number generator.</a>
<a name="ln864">       * @param __rng An existing (base class) engine object.</a>
<a name="ln865">       */</a>
<a name="ln866">      explicit</a>
<a name="ln867">      discard_block_engine(const _RandomNumberEngine&amp; __rng)</a>
<a name="ln868">      : _M_b(__rng), _M_n(0) { }</a>
<a name="ln869"> </a>
<a name="ln870">      /**</a>
<a name="ln871">       * @brief Move constructs a %discard_block_engine engine.</a>
<a name="ln872">       *</a>
<a name="ln873">       * Copies an existing base class random number generator.</a>
<a name="ln874">       * @param __rng An existing (base class) engine object.</a>
<a name="ln875">       */</a>
<a name="ln876">      explicit</a>
<a name="ln877">      discard_block_engine(_RandomNumberEngine&amp;&amp; __rng)</a>
<a name="ln878">      : _M_b(std::move(__rng)), _M_n(0) { }</a>
<a name="ln879"> </a>
<a name="ln880">      /**</a>
<a name="ln881">       * @brief Seed constructs a %discard_block_engine engine.</a>
<a name="ln882">       *</a>
<a name="ln883">       * Constructs the underlying generator engine seeded with @p __s.</a>
<a name="ln884">       * @param __s A seed value for the base class engine.</a>
<a name="ln885">       */</a>
<a name="ln886">      explicit</a>
<a name="ln887">      discard_block_engine(result_type __s)</a>
<a name="ln888">      : _M_b(__s), _M_n(0) { }</a>
<a name="ln889"> </a>
<a name="ln890">      /**</a>
<a name="ln891">       * @brief Generator construct a %discard_block_engine engine.</a>
<a name="ln892">       *</a>
<a name="ln893">       * @param __q A seed sequence.</a>
<a name="ln894">       */</a>
<a name="ln895">      template&lt;typename _Sseq, typename = typename</a>
<a name="ln896">	std::enable_if&lt;!std::is_same&lt;_Sseq, discard_block_engine&gt;::value</a>
<a name="ln897">		       &amp;&amp; !std::is_same&lt;_Sseq, _RandomNumberEngine&gt;::value&gt;</a>
<a name="ln898">	       ::type&gt;</a>
<a name="ln899">        explicit</a>
<a name="ln900">        discard_block_engine(_Sseq&amp; __q)</a>
<a name="ln901">	: _M_b(__q), _M_n(0)</a>
<a name="ln902">        { }</a>
<a name="ln903"> </a>
<a name="ln904">      /**</a>
<a name="ln905">       * @brief Reseeds the %discard_block_engine object with the default</a>
<a name="ln906">       *        seed for the underlying base class generator engine.</a>
<a name="ln907">       */</a>
<a name="ln908">      void</a>
<a name="ln909">      seed()</a>
<a name="ln910">      {</a>
<a name="ln911">	_M_b.seed();</a>
<a name="ln912">	_M_n = 0;</a>
<a name="ln913">      }</a>
<a name="ln914"> </a>
<a name="ln915">      /**</a>
<a name="ln916">       * @brief Reseeds the %discard_block_engine object with the default</a>
<a name="ln917">       *        seed for the underlying base class generator engine.</a>
<a name="ln918">       */</a>
<a name="ln919">      void</a>
<a name="ln920">      seed(result_type __s)</a>
<a name="ln921">      {</a>
<a name="ln922">	_M_b.seed(__s);</a>
<a name="ln923">	_M_n = 0;</a>
<a name="ln924">      }</a>
<a name="ln925"> </a>
<a name="ln926">      /**</a>
<a name="ln927">       * @brief Reseeds the %discard_block_engine object with the given seed</a>
<a name="ln928">       *        sequence.</a>
<a name="ln929">       * @param __q A seed generator function.</a>
<a name="ln930">       */</a>
<a name="ln931">      template&lt;typename _Sseq&gt;</a>
<a name="ln932">        void</a>
<a name="ln933">        seed(_Sseq&amp; __q)</a>
<a name="ln934">        {</a>
<a name="ln935">	  _M_b.seed(__q);</a>
<a name="ln936">	  _M_n = 0;</a>
<a name="ln937">	}</a>
<a name="ln938"> </a>
<a name="ln939">      /**</a>
<a name="ln940">       * @brief Gets a const reference to the underlying generator engine</a>
<a name="ln941">       *        object.</a>
<a name="ln942">       */</a>
<a name="ln943">      const _RandomNumberEngine&amp;</a>
<a name="ln944">      base() const noexcept</a>
<a name="ln945">      { return _M_b; }</a>
<a name="ln946"> </a>
<a name="ln947">      /**</a>
<a name="ln948">       * @brief Gets the minimum value in the generated random number range.</a>
<a name="ln949">       */</a>
<a name="ln950">      static constexpr result_type</a>
<a name="ln951">      min()</a>
<a name="ln952">      { return _RandomNumberEngine::min(); }</a>
<a name="ln953"> </a>
<a name="ln954">      /**</a>
<a name="ln955">       * @brief Gets the maximum value in the generated random number range.</a>
<a name="ln956">       */</a>
<a name="ln957">      static constexpr result_type</a>
<a name="ln958">      max()</a>
<a name="ln959">      { return _RandomNumberEngine::max(); }</a>
<a name="ln960"> </a>
<a name="ln961">      /**</a>
<a name="ln962">       * @brief Discard a sequence of random numbers.</a>
<a name="ln963">       */</a>
<a name="ln964">      void</a>
<a name="ln965">      discard(unsigned long long __z)</a>
<a name="ln966">      {</a>
<a name="ln967">	for (; __z != 0ULL; --__z)</a>
<a name="ln968">	  (*this)();</a>
<a name="ln969">      }</a>
<a name="ln970"> </a>
<a name="ln971">      /**</a>
<a name="ln972">       * @brief Gets the next value in the generated random number sequence.</a>
<a name="ln973">       */</a>
<a name="ln974">      result_type</a>
<a name="ln975">      operator()();</a>
<a name="ln976"> </a>
<a name="ln977">      /**</a>
<a name="ln978">       * @brief Compares two %discard_block_engine random number generator</a>
<a name="ln979">       *        objects of the same type for equality.</a>
<a name="ln980">       *</a>
<a name="ln981">       * @param __lhs A %discard_block_engine random number generator object.</a>
<a name="ln982">       * @param __rhs Another %discard_block_engine random number generator</a>
<a name="ln983">       *              object.</a>
<a name="ln984">       *</a>
<a name="ln985">       * @returns true if the infinite sequences of generated values</a>
<a name="ln986">       *          would be equal, false otherwise.</a>
<a name="ln987">       */</a>
<a name="ln988">      friend bool</a>
<a name="ln989">      operator==(const discard_block_engine&amp; __lhs,</a>
<a name="ln990">		 const discard_block_engine&amp; __rhs)</a>
<a name="ln991">      { return __lhs._M_b == __rhs._M_b &amp;&amp; __lhs._M_n == __rhs._M_n; }</a>
<a name="ln992"> </a>
<a name="ln993">      /**</a>
<a name="ln994">       * @brief Inserts the current state of a %discard_block_engine random</a>
<a name="ln995">       *        number generator engine @p __x into the output stream</a>
<a name="ln996">       *        @p __os.</a>
<a name="ln997">       *</a>
<a name="ln998">       * @param __os An output stream.</a>
<a name="ln999">       * @param __x  A %discard_block_engine random number generator engine.</a>
<a name="ln1000">       *</a>
<a name="ln1001">       * @returns The output stream with the state of @p __x inserted or in</a>
<a name="ln1002">       * an error state.</a>
<a name="ln1003">       */</a>
<a name="ln1004">      template&lt;typename _RandomNumberEngine1, size_t __p1, size_t __r1,</a>
<a name="ln1005">	       typename _CharT, typename _Traits&gt;</a>
<a name="ln1006">	friend std::basic_ostream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln1007">	operator&lt;&lt;(std::basic_ostream&lt;_CharT, _Traits&gt;&amp; __os,</a>
<a name="ln1008">		   const std::discard_block_engine&lt;_RandomNumberEngine1,</a>
<a name="ln1009">		   __p1, __r1&gt;&amp; __x);</a>
<a name="ln1010"> </a>
<a name="ln1011">      /**</a>
<a name="ln1012">       * @brief Extracts the current state of a % subtract_with_carry_engine</a>
<a name="ln1013">       *        random number generator engine @p __x from the input stream</a>
<a name="ln1014">       *        @p __is.</a>
<a name="ln1015">       *</a>
<a name="ln1016">       * @param __is An input stream.</a>
<a name="ln1017">       * @param __x  A %discard_block_engine random number generator engine.</a>
<a name="ln1018">       *</a>
<a name="ln1019">       * @returns The input stream with the state of @p __x extracted or in</a>
<a name="ln1020">       * an error state.</a>
<a name="ln1021">       */</a>
<a name="ln1022">      template&lt;typename _RandomNumberEngine1, size_t __p1, size_t __r1,</a>
<a name="ln1023">	       typename _CharT, typename _Traits&gt;</a>
<a name="ln1024">	friend std::basic_istream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln1025">	operator&gt;&gt;(std::basic_istream&lt;_CharT, _Traits&gt;&amp; __is,</a>
<a name="ln1026">		   std::discard_block_engine&lt;_RandomNumberEngine1,</a>
<a name="ln1027">		   __p1, __r1&gt;&amp; __x);</a>
<a name="ln1028"> </a>
<a name="ln1029">    private:</a>
<a name="ln1030">      _RandomNumberEngine _M_b;</a>
<a name="ln1031">      size_t _M_n;</a>
<a name="ln1032">    };</a>
<a name="ln1033"> </a>
<a name="ln1034">  /**</a>
<a name="ln1035">   * @brief Compares two %discard_block_engine random number generator</a>
<a name="ln1036">   *        objects of the same type for inequality.</a>
<a name="ln1037">   *</a>
<a name="ln1038">   * @param __lhs A %discard_block_engine random number generator object.</a>
<a name="ln1039">   * @param __rhs Another %discard_block_engine random number generator</a>
<a name="ln1040">   *              object.</a>
<a name="ln1041">   *</a>
<a name="ln1042">   * @returns true if the infinite sequences of generated values</a>
<a name="ln1043">   *          would be different, false otherwise.</a>
<a name="ln1044">   */</a>
<a name="ln1045">  template&lt;typename _RandomNumberEngine, size_t __p, size_t __r&gt;</a>
<a name="ln1046">    inline bool</a>
<a name="ln1047">    operator!=(const std::discard_block_engine&lt;_RandomNumberEngine, __p,</a>
<a name="ln1048">	       __r&gt;&amp; __lhs,</a>
<a name="ln1049">	       const std::discard_block_engine&lt;_RandomNumberEngine, __p,</a>
<a name="ln1050">	       __r&gt;&amp; __rhs)</a>
<a name="ln1051">    { return !(__lhs == __rhs); }</a>
<a name="ln1052"> </a>
<a name="ln1053"> </a>
<a name="ln1054">  /**</a>
<a name="ln1055">   * Produces random numbers by combining random numbers from some base</a>
<a name="ln1056">   * engine to produce random numbers with a specifies number of bits @p __w.</a>
<a name="ln1057">   */</a>
<a name="ln1058">  template&lt;typename _RandomNumberEngine, size_t __w, typename _UIntType&gt;</a>
<a name="ln1059">    class independent_bits_engine</a>
<a name="ln1060">    {</a>
<a name="ln1061">      static_assert(std::is_unsigned&lt;_UIntType&gt;::value,</a>
<a name="ln1062">		    &quot;result_type must be an unsigned integral type&quot;);</a>
<a name="ln1063">      static_assert(0u &lt; __w &amp;&amp; __w &lt;= std::numeric_limits&lt;_UIntType&gt;::digits,</a>
<a name="ln1064">		    &quot;template argument substituting __w out of bounds&quot;);</a>
<a name="ln1065"> </a>
<a name="ln1066">    public:</a>
<a name="ln1067">      /** The type of the generated random value. */</a>
<a name="ln1068">      typedef _UIntType result_type;</a>
<a name="ln1069"> </a>
<a name="ln1070">      /**</a>
<a name="ln1071">       * @brief Constructs a default %independent_bits_engine engine.</a>
<a name="ln1072">       *</a>
<a name="ln1073">       * The underlying engine is default constructed as well.</a>
<a name="ln1074">       */</a>
<a name="ln1075">      independent_bits_engine()</a>
<a name="ln1076">      : _M_b() { }</a>
<a name="ln1077"> </a>
<a name="ln1078">      /**</a>
<a name="ln1079">       * @brief Copy constructs a %independent_bits_engine engine.</a>
<a name="ln1080">       *</a>
<a name="ln1081">       * Copies an existing base class random number generator.</a>
<a name="ln1082">       * @param __rng An existing (base class) engine object.</a>
<a name="ln1083">       */</a>
<a name="ln1084">      explicit</a>
<a name="ln1085">      independent_bits_engine(const _RandomNumberEngine&amp; __rng)</a>
<a name="ln1086">      : _M_b(__rng) { }</a>
<a name="ln1087"> </a>
<a name="ln1088">      /**</a>
<a name="ln1089">       * @brief Move constructs a %independent_bits_engine engine.</a>
<a name="ln1090">       *</a>
<a name="ln1091">       * Copies an existing base class random number generator.</a>
<a name="ln1092">       * @param __rng An existing (base class) engine object.</a>
<a name="ln1093">       */</a>
<a name="ln1094">      explicit</a>
<a name="ln1095">      independent_bits_engine(_RandomNumberEngine&amp;&amp; __rng)</a>
<a name="ln1096">      : _M_b(std::move(__rng)) { }</a>
<a name="ln1097"> </a>
<a name="ln1098">      /**</a>
<a name="ln1099">       * @brief Seed constructs a %independent_bits_engine engine.</a>
<a name="ln1100">       *</a>
<a name="ln1101">       * Constructs the underlying generator engine seeded with @p __s.</a>
<a name="ln1102">       * @param __s A seed value for the base class engine.</a>
<a name="ln1103">       */</a>
<a name="ln1104">      explicit</a>
<a name="ln1105">      independent_bits_engine(result_type __s)</a>
<a name="ln1106">      : _M_b(__s) { }</a>
<a name="ln1107"> </a>
<a name="ln1108">      /**</a>
<a name="ln1109">       * @brief Generator construct a %independent_bits_engine engine.</a>
<a name="ln1110">       *</a>
<a name="ln1111">       * @param __q A seed sequence.</a>
<a name="ln1112">       */</a>
<a name="ln1113">      template&lt;typename _Sseq, typename = typename</a>
<a name="ln1114">	std::enable_if&lt;!std::is_same&lt;_Sseq, independent_bits_engine&gt;::value</a>
<a name="ln1115">		       &amp;&amp; !std::is_same&lt;_Sseq, _RandomNumberEngine&gt;::value&gt;</a>
<a name="ln1116">               ::type&gt;</a>
<a name="ln1117">        explicit</a>
<a name="ln1118">        independent_bits_engine(_Sseq&amp; __q)</a>
<a name="ln1119">        : _M_b(__q)</a>
<a name="ln1120">        { }</a>
<a name="ln1121"> </a>
<a name="ln1122">      /**</a>
<a name="ln1123">       * @brief Reseeds the %independent_bits_engine object with the default</a>
<a name="ln1124">       *        seed for the underlying base class generator engine.</a>
<a name="ln1125">       */</a>
<a name="ln1126">      void</a>
<a name="ln1127">      seed()</a>
<a name="ln1128">      { _M_b.seed(); }</a>
<a name="ln1129"> </a>
<a name="ln1130">      /**</a>
<a name="ln1131">       * @brief Reseeds the %independent_bits_engine object with the default</a>
<a name="ln1132">       *        seed for the underlying base class generator engine.</a>
<a name="ln1133">       */</a>
<a name="ln1134">      void</a>
<a name="ln1135">      seed(result_type __s)</a>
<a name="ln1136">      { _M_b.seed(__s); }</a>
<a name="ln1137"> </a>
<a name="ln1138">      /**</a>
<a name="ln1139">       * @brief Reseeds the %independent_bits_engine object with the given</a>
<a name="ln1140">       *        seed sequence.</a>
<a name="ln1141">       * @param __q A seed generator function.</a>
<a name="ln1142">       */</a>
<a name="ln1143">      template&lt;typename _Sseq&gt;</a>
<a name="ln1144">        void</a>
<a name="ln1145">        seed(_Sseq&amp; __q)</a>
<a name="ln1146">        { _M_b.seed(__q); }</a>
<a name="ln1147"> </a>
<a name="ln1148">      /**</a>
<a name="ln1149">       * @brief Gets a const reference to the underlying generator engine</a>
<a name="ln1150">       *        object.</a>
<a name="ln1151">       */</a>
<a name="ln1152">      const _RandomNumberEngine&amp;</a>
<a name="ln1153">      base() const noexcept</a>
<a name="ln1154">      { return _M_b; }</a>
<a name="ln1155"> </a>
<a name="ln1156">      /**</a>
<a name="ln1157">       * @brief Gets the minimum value in the generated random number range.</a>
<a name="ln1158">       */</a>
<a name="ln1159">      static constexpr result_type</a>
<a name="ln1160">      min()</a>
<a name="ln1161">      { return 0U; }</a>
<a name="ln1162"> </a>
<a name="ln1163">      /**</a>
<a name="ln1164">       * @brief Gets the maximum value in the generated random number range.</a>
<a name="ln1165">       */</a>
<a name="ln1166">      static constexpr result_type</a>
<a name="ln1167">      max()</a>
<a name="ln1168">      { return __detail::_Shift&lt;_UIntType, __w&gt;::__value - 1; }</a>
<a name="ln1169"> </a>
<a name="ln1170">      /**</a>
<a name="ln1171">       * @brief Discard a sequence of random numbers.</a>
<a name="ln1172">       */</a>
<a name="ln1173">      void</a>
<a name="ln1174">      discard(unsigned long long __z)</a>
<a name="ln1175">      {</a>
<a name="ln1176">	for (; __z != 0ULL; --__z)</a>
<a name="ln1177">	  (*this)();</a>
<a name="ln1178">      }</a>
<a name="ln1179"> </a>
<a name="ln1180">      /**</a>
<a name="ln1181">       * @brief Gets the next value in the generated random number sequence.</a>
<a name="ln1182">       */</a>
<a name="ln1183">      result_type</a>
<a name="ln1184">      operator()();</a>
<a name="ln1185"> </a>
<a name="ln1186">      /**</a>
<a name="ln1187">       * @brief Compares two %independent_bits_engine random number generator</a>
<a name="ln1188">       * objects of the same type for equality.</a>
<a name="ln1189">       *</a>
<a name="ln1190">       * @param __lhs A %independent_bits_engine random number generator</a>
<a name="ln1191">       *              object.</a>
<a name="ln1192">       * @param __rhs Another %independent_bits_engine random number generator</a>
<a name="ln1193">       *              object.</a>
<a name="ln1194">       *</a>
<a name="ln1195">       * @returns true if the infinite sequences of generated values</a>
<a name="ln1196">       *          would be equal, false otherwise.</a>
<a name="ln1197">       */</a>
<a name="ln1198">      friend bool</a>
<a name="ln1199">      operator==(const independent_bits_engine&amp; __lhs,</a>
<a name="ln1200">		 const independent_bits_engine&amp; __rhs)</a>
<a name="ln1201">      { return __lhs._M_b == __rhs._M_b; }</a>
<a name="ln1202"> </a>
<a name="ln1203">      /**</a>
<a name="ln1204">       * @brief Extracts the current state of a % subtract_with_carry_engine</a>
<a name="ln1205">       *        random number generator engine @p __x from the input stream</a>
<a name="ln1206">       *        @p __is.</a>
<a name="ln1207">       *</a>
<a name="ln1208">       * @param __is An input stream.</a>
<a name="ln1209">       * @param __x  A %independent_bits_engine random number generator</a>
<a name="ln1210">       *             engine.</a>
<a name="ln1211">       *</a>
<a name="ln1212">       * @returns The input stream with the state of @p __x extracted or in</a>
<a name="ln1213">       *          an error state.</a>
<a name="ln1214">       */</a>
<a name="ln1215">      template&lt;typename _CharT, typename _Traits&gt;</a>
<a name="ln1216">	friend std::basic_istream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln1217">	operator&gt;&gt;(std::basic_istream&lt;_CharT, _Traits&gt;&amp; __is,</a>
<a name="ln1218">		   std::independent_bits_engine&lt;_RandomNumberEngine,</a>
<a name="ln1219">		   __w, _UIntType&gt;&amp; __x)</a>
<a name="ln1220">	{</a>
<a name="ln1221">	  __is &gt;&gt; __x._M_b;</a>
<a name="ln1222">	  return __is;</a>
<a name="ln1223">	}</a>
<a name="ln1224"> </a>
<a name="ln1225">    private:</a>
<a name="ln1226">      _RandomNumberEngine _M_b;</a>
<a name="ln1227">    };</a>
<a name="ln1228"> </a>
<a name="ln1229">  /**</a>
<a name="ln1230">   * @brief Compares two %independent_bits_engine random number generator</a>
<a name="ln1231">   * objects of the same type for inequality.</a>
<a name="ln1232">   *</a>
<a name="ln1233">   * @param __lhs A %independent_bits_engine random number generator</a>
<a name="ln1234">   *              object.</a>
<a name="ln1235">   * @param __rhs Another %independent_bits_engine random number generator</a>
<a name="ln1236">   *              object.</a>
<a name="ln1237">   *</a>
<a name="ln1238">   * @returns true if the infinite sequences of generated values</a>
<a name="ln1239">   *          would be different, false otherwise.</a>
<a name="ln1240">   */</a>
<a name="ln1241">  template&lt;typename _RandomNumberEngine, size_t __w, typename _UIntType&gt;</a>
<a name="ln1242">    inline bool</a>
<a name="ln1243">    operator!=(const std::independent_bits_engine&lt;_RandomNumberEngine, __w,</a>
<a name="ln1244">	       _UIntType&gt;&amp; __lhs,</a>
<a name="ln1245">	       const std::independent_bits_engine&lt;_RandomNumberEngine, __w,</a>
<a name="ln1246">	       _UIntType&gt;&amp; __rhs)</a>
<a name="ln1247">    { return !(__lhs == __rhs); }</a>
<a name="ln1248"> </a>
<a name="ln1249">  /**</a>
<a name="ln1250">   * @brief Inserts the current state of a %independent_bits_engine random</a>
<a name="ln1251">   *        number generator engine @p __x into the output stream @p __os.</a>
<a name="ln1252">   *</a>
<a name="ln1253">   * @param __os An output stream.</a>
<a name="ln1254">   * @param __x  A %independent_bits_engine random number generator engine.</a>
<a name="ln1255">   *</a>
<a name="ln1256">   * @returns The output stream with the state of @p __x inserted or in</a>
<a name="ln1257">   *          an error state.</a>
<a name="ln1258">   */</a>
<a name="ln1259">  template&lt;typename _RandomNumberEngine, size_t __w, typename _UIntType,</a>
<a name="ln1260">	   typename _CharT, typename _Traits&gt;</a>
<a name="ln1261">    std::basic_ostream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln1262">    operator&lt;&lt;(std::basic_ostream&lt;_CharT, _Traits&gt;&amp; __os,</a>
<a name="ln1263">	       const std::independent_bits_engine&lt;_RandomNumberEngine,</a>
<a name="ln1264">	       __w, _UIntType&gt;&amp; __x)</a>
<a name="ln1265">    {</a>
<a name="ln1266">      __os &lt;&lt; __x.base();</a>
<a name="ln1267">      return __os;</a>
<a name="ln1268">    }</a>
<a name="ln1269"> </a>
<a name="ln1270"> </a>
<a name="ln1271">  /**</a>
<a name="ln1272">   * @brief Produces random numbers by combining random numbers from some</a>
<a name="ln1273">   * base engine to produce random numbers with a specifies number of bits</a>
<a name="ln1274">   * @p __k.</a>
<a name="ln1275">   */</a>
<a name="ln1276">  template&lt;typename _RandomNumberEngine, size_t __k&gt;</a>
<a name="ln1277">    class shuffle_order_engine</a>
<a name="ln1278">    {</a>
<a name="ln1279">      static_assert(1u &lt;= __k, &quot;template argument substituting &quot;</a>
<a name="ln1280">		    &quot;__k out of bound&quot;);</a>
<a name="ln1281"> </a>
<a name="ln1282">    public:</a>
<a name="ln1283">      /** The type of the generated random value. */</a>
<a name="ln1284">      typedef typename _RandomNumberEngine::result_type result_type;</a>
<a name="ln1285"> </a>
<a name="ln1286">      static constexpr size_t table_size = __k;</a>
<a name="ln1287"> </a>
<a name="ln1288">      /**</a>
<a name="ln1289">       * @brief Constructs a default %shuffle_order_engine engine.</a>
<a name="ln1290">       *</a>
<a name="ln1291">       * The underlying engine is default constructed as well.</a>
<a name="ln1292">       */</a>
<a name="ln1293">      shuffle_order_engine()</a>
<a name="ln1294">      : _M_b()</a>
<a name="ln1295">      { _M_initialize(); }</a>
<a name="ln1296"> </a>
<a name="ln1297">      /**</a>
<a name="ln1298">       * @brief Copy constructs a %shuffle_order_engine engine.</a>
<a name="ln1299">       *</a>
<a name="ln1300">       * Copies an existing base class random number generator.</a>
<a name="ln1301">       * @param __rng An existing (base class) engine object.</a>
<a name="ln1302">       */</a>
<a name="ln1303">      explicit</a>
<a name="ln1304">      shuffle_order_engine(const _RandomNumberEngine&amp; __rng)</a>
<a name="ln1305">      : _M_b(__rng)</a>
<a name="ln1306">      { _M_initialize(); }</a>
<a name="ln1307"> </a>
<a name="ln1308">      /**</a>
<a name="ln1309">       * @brief Move constructs a %shuffle_order_engine engine.</a>
<a name="ln1310">       *</a>
<a name="ln1311">       * Copies an existing base class random number generator.</a>
<a name="ln1312">       * @param __rng An existing (base class) engine object.</a>
<a name="ln1313">       */</a>
<a name="ln1314">      explicit</a>
<a name="ln1315">      shuffle_order_engine(_RandomNumberEngine&amp;&amp; __rng)</a>
<a name="ln1316">      : _M_b(std::move(__rng))</a>
<a name="ln1317">      { _M_initialize(); }</a>
<a name="ln1318"> </a>
<a name="ln1319">      /**</a>
<a name="ln1320">       * @brief Seed constructs a %shuffle_order_engine engine.</a>
<a name="ln1321">       *</a>
<a name="ln1322">       * Constructs the underlying generator engine seeded with @p __s.</a>
<a name="ln1323">       * @param __s A seed value for the base class engine.</a>
<a name="ln1324">       */</a>
<a name="ln1325">      explicit</a>
<a name="ln1326">      shuffle_order_engine(result_type __s)</a>
<a name="ln1327">      : _M_b(__s)</a>
<a name="ln1328">      { _M_initialize(); }</a>
<a name="ln1329"> </a>
<a name="ln1330">      /**</a>
<a name="ln1331">       * @brief Generator construct a %shuffle_order_engine engine.</a>
<a name="ln1332">       *</a>
<a name="ln1333">       * @param __q A seed sequence.</a>
<a name="ln1334">       */</a>
<a name="ln1335">      template&lt;typename _Sseq, typename = typename</a>
<a name="ln1336">	std::enable_if&lt;!std::is_same&lt;_Sseq, shuffle_order_engine&gt;::value</a>
<a name="ln1337">		       &amp;&amp; !std::is_same&lt;_Sseq, _RandomNumberEngine&gt;::value&gt;</a>
<a name="ln1338">	       ::type&gt;</a>
<a name="ln1339">        explicit</a>
<a name="ln1340">        shuffle_order_engine(_Sseq&amp; __q)</a>
<a name="ln1341">        : _M_b(__q)</a>
<a name="ln1342">        { _M_initialize(); }</a>
<a name="ln1343"> </a>
<a name="ln1344">      /**</a>
<a name="ln1345">       * @brief Reseeds the %shuffle_order_engine object with the default seed</a>
<a name="ln1346">                for the underlying base class generator engine.</a>
<a name="ln1347">       */</a>
<a name="ln1348">      void</a>
<a name="ln1349">      seed()</a>
<a name="ln1350">      {</a>
<a name="ln1351">	_M_b.seed();</a>
<a name="ln1352">	_M_initialize();</a>
<a name="ln1353">      }</a>
<a name="ln1354"> </a>
<a name="ln1355">      /**</a>
<a name="ln1356">       * @brief Reseeds the %shuffle_order_engine object with the default seed</a>
<a name="ln1357">       *        for the underlying base class generator engine.</a>
<a name="ln1358">       */</a>
<a name="ln1359">      void</a>
<a name="ln1360">      seed(result_type __s)</a>
<a name="ln1361">      {</a>
<a name="ln1362">	_M_b.seed(__s);</a>
<a name="ln1363">	_M_initialize();</a>
<a name="ln1364">      }</a>
<a name="ln1365"> </a>
<a name="ln1366">      /**</a>
<a name="ln1367">       * @brief Reseeds the %shuffle_order_engine object with the given seed</a>
<a name="ln1368">       *        sequence.</a>
<a name="ln1369">       * @param __q A seed generator function.</a>
<a name="ln1370">       */</a>
<a name="ln1371">      template&lt;typename _Sseq&gt;</a>
<a name="ln1372">        void</a>
<a name="ln1373">        seed(_Sseq&amp; __q)</a>
<a name="ln1374">        {</a>
<a name="ln1375">	  _M_b.seed(__q);</a>
<a name="ln1376">	  _M_initialize();</a>
<a name="ln1377">	}</a>
<a name="ln1378"> </a>
<a name="ln1379">      /**</a>
<a name="ln1380">       * Gets a const reference to the underlying generator engine object.</a>
<a name="ln1381">       */</a>
<a name="ln1382">      const _RandomNumberEngine&amp;</a>
<a name="ln1383">      base() const noexcept</a>
<a name="ln1384">      { return _M_b; }</a>
<a name="ln1385"> </a>
<a name="ln1386">      /**</a>
<a name="ln1387">       * Gets the minimum value in the generated random number range.</a>
<a name="ln1388">       */</a>
<a name="ln1389">      static constexpr result_type</a>
<a name="ln1390">      min()</a>
<a name="ln1391">      { return _RandomNumberEngine::min(); }</a>
<a name="ln1392"> </a>
<a name="ln1393">      /**</a>
<a name="ln1394">       * Gets the maximum value in the generated random number range.</a>
<a name="ln1395">       */</a>
<a name="ln1396">      static constexpr result_type</a>
<a name="ln1397">      max()</a>
<a name="ln1398">      { return _RandomNumberEngine::max(); }</a>
<a name="ln1399"> </a>
<a name="ln1400">      /**</a>
<a name="ln1401">       * Discard a sequence of random numbers.</a>
<a name="ln1402">       */</a>
<a name="ln1403">      void</a>
<a name="ln1404">      discard(unsigned long long __z)</a>
<a name="ln1405">      {</a>
<a name="ln1406">	for (; __z != 0ULL; --__z)</a>
<a name="ln1407">	  (*this)();</a>
<a name="ln1408">      }</a>
<a name="ln1409"> </a>
<a name="ln1410">      /**</a>
<a name="ln1411">       * Gets the next value in the generated random number sequence.</a>
<a name="ln1412">       */</a>
<a name="ln1413">      result_type</a>
<a name="ln1414">      operator()();</a>
<a name="ln1415"> </a>
<a name="ln1416">      /**</a>
<a name="ln1417">       * Compares two %shuffle_order_engine random number generator objects</a>
<a name="ln1418">       * of the same type for equality.</a>
<a name="ln1419">       *</a>
<a name="ln1420">       * @param __lhs A %shuffle_order_engine random number generator object.</a>
<a name="ln1421">       * @param __rhs Another %shuffle_order_engine random number generator</a>
<a name="ln1422">       *              object.</a>
<a name="ln1423">       *</a>
<a name="ln1424">       * @returns true if the infinite sequences of generated values</a>
<a name="ln1425">       *          would be equal, false otherwise.</a>
<a name="ln1426">      */</a>
<a name="ln1427">      friend bool</a>
<a name="ln1428">      operator==(const shuffle_order_engine&amp; __lhs,</a>
<a name="ln1429">		 const shuffle_order_engine&amp; __rhs)</a>
<a name="ln1430">      { return (__lhs._M_b == __rhs._M_b</a>
<a name="ln1431">		&amp;&amp; std::equal(__lhs._M_v, __lhs._M_v + __k, __rhs._M_v)</a>
<a name="ln1432">		&amp;&amp; __lhs._M_y == __rhs._M_y); }</a>
<a name="ln1433"> </a>
<a name="ln1434">      /**</a>
<a name="ln1435">       * @brief Inserts the current state of a %shuffle_order_engine random</a>
<a name="ln1436">       *        number generator engine @p __x into the output stream</a>
<a name="ln1437">	@p __os.</a>
<a name="ln1438">       *</a>
<a name="ln1439">       * @param __os An output stream.</a>
<a name="ln1440">       * @param __x  A %shuffle_order_engine random number generator engine.</a>
<a name="ln1441">       *</a>
<a name="ln1442">       * @returns The output stream with the state of @p __x inserted or in</a>
<a name="ln1443">       * an error state.</a>
<a name="ln1444">       */</a>
<a name="ln1445">      template&lt;typename _RandomNumberEngine1, size_t __k1,</a>
<a name="ln1446">	       typename _CharT, typename _Traits&gt;</a>
<a name="ln1447">	friend std::basic_ostream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln1448">	operator&lt;&lt;(std::basic_ostream&lt;_CharT, _Traits&gt;&amp; __os,</a>
<a name="ln1449">		   const std::shuffle_order_engine&lt;_RandomNumberEngine1,</a>
<a name="ln1450">		   __k1&gt;&amp; __x);</a>
<a name="ln1451"> </a>
<a name="ln1452">      /**</a>
<a name="ln1453">       * @brief Extracts the current state of a % subtract_with_carry_engine</a>
<a name="ln1454">       *        random number generator engine @p __x from the input stream</a>
<a name="ln1455">       *        @p __is.</a>
<a name="ln1456">       *</a>
<a name="ln1457">       * @param __is An input stream.</a>
<a name="ln1458">       * @param __x  A %shuffle_order_engine random number generator engine.</a>
<a name="ln1459">       *</a>
<a name="ln1460">       * @returns The input stream with the state of @p __x extracted or in</a>
<a name="ln1461">       * an error state.</a>
<a name="ln1462">       */</a>
<a name="ln1463">      template&lt;typename _RandomNumberEngine1, size_t __k1,</a>
<a name="ln1464">	       typename _CharT, typename _Traits&gt;</a>
<a name="ln1465">	friend std::basic_istream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln1466">	operator&gt;&gt;(std::basic_istream&lt;_CharT, _Traits&gt;&amp; __is,</a>
<a name="ln1467">		   std::shuffle_order_engine&lt;_RandomNumberEngine1, __k1&gt;&amp; __x);</a>
<a name="ln1468"> </a>
<a name="ln1469">    private:</a>
<a name="ln1470">      void _M_initialize()</a>
<a name="ln1471">      {</a>
<a name="ln1472">	for (size_t __i = 0; __i &lt; __k; ++__i)</a>
<a name="ln1473">	  _M_v[__i] = _M_b();</a>
<a name="ln1474">	_M_y = _M_b();</a>
<a name="ln1475">      }</a>
<a name="ln1476"> </a>
<a name="ln1477">      _RandomNumberEngine _M_b;</a>
<a name="ln1478">      result_type _M_v[__k];</a>
<a name="ln1479">      result_type _M_y;</a>
<a name="ln1480">    };</a>
<a name="ln1481"> </a>
<a name="ln1482">  /**</a>
<a name="ln1483">   * Compares two %shuffle_order_engine random number generator objects</a>
<a name="ln1484">   * of the same type for inequality.</a>
<a name="ln1485">   *</a>
<a name="ln1486">   * @param __lhs A %shuffle_order_engine random number generator object.</a>
<a name="ln1487">   * @param __rhs Another %shuffle_order_engine random number generator</a>
<a name="ln1488">   *              object.</a>
<a name="ln1489">   *</a>
<a name="ln1490">   * @returns true if the infinite sequences of generated values</a>
<a name="ln1491">   *          would be different, false otherwise.</a>
<a name="ln1492">   */</a>
<a name="ln1493">  template&lt;typename _RandomNumberEngine, size_t __k&gt;</a>
<a name="ln1494">    inline bool</a>
<a name="ln1495">    operator!=(const std::shuffle_order_engine&lt;_RandomNumberEngine,</a>
<a name="ln1496">	       __k&gt;&amp; __lhs,</a>
<a name="ln1497">	       const std::shuffle_order_engine&lt;_RandomNumberEngine,</a>
<a name="ln1498">	       __k&gt;&amp; __rhs)</a>
<a name="ln1499">    { return !(__lhs == __rhs); }</a>
<a name="ln1500"> </a>
<a name="ln1501"> </a>
<a name="ln1502">  /**</a>
<a name="ln1503">   * The classic Minimum Standard rand0 of Lewis, Goodman, and Miller.</a>
<a name="ln1504">   */</a>
<a name="ln1505">  typedef linear_congruential_engine&lt;uint_fast32_t, 16807UL, 0UL, 2147483647UL&gt;</a>
<a name="ln1506">  minstd_rand0;</a>
<a name="ln1507"> </a>
<a name="ln1508">  /**</a>
<a name="ln1509">   * An alternative LCR (Lehmer Generator function).</a>
<a name="ln1510">   */</a>
<a name="ln1511">  typedef linear_congruential_engine&lt;uint_fast32_t, 48271UL, 0UL, 2147483647UL&gt;</a>
<a name="ln1512">  minstd_rand;</a>
<a name="ln1513"> </a>
<a name="ln1514">  /**</a>
<a name="ln1515">   * The classic Mersenne Twister.</a>
<a name="ln1516">   *</a>
<a name="ln1517">   * Reference:</a>
<a name="ln1518">   * M. Matsumoto and T. Nishimura, Mersenne Twister: A 623-Dimensionally</a>
<a name="ln1519">   * Equidistributed Uniform Pseudo-Random Number Generator, ACM Transactions</a>
<a name="ln1520">   * on Modeling and Computer Simulation, Vol. 8, No. 1, January 1998, pp 3-30.</a>
<a name="ln1521">   */</a>
<a name="ln1522">  typedef mersenne_twister_engine&lt;</a>
<a name="ln1523">    uint_fast32_t,</a>
<a name="ln1524">    32, 624, 397, 31,</a>
<a name="ln1525">    0x9908b0dfUL, 11,</a>
<a name="ln1526">    0xffffffffUL, 7,</a>
<a name="ln1527">    0x9d2c5680UL, 15,</a>
<a name="ln1528">    0xefc60000UL, 18, 1812433253UL&gt; mt19937;</a>
<a name="ln1529"> </a>
<a name="ln1530">  /**</a>
<a name="ln1531">   * An alternative Mersenne Twister.</a>
<a name="ln1532">   */</a>
<a name="ln1533">  typedef mersenne_twister_engine&lt;</a>
<a name="ln1534">    uint_fast64_t,</a>
<a name="ln1535">    64, 312, 156, 31,</a>
<a name="ln1536">    0xb5026f5aa96619e9ULL, 29,</a>
<a name="ln1537">    0x5555555555555555ULL, 17,</a>
<a name="ln1538">    0x71d67fffeda60000ULL, 37,</a>
<a name="ln1539">    0xfff7eee000000000ULL, 43,</a>
<a name="ln1540">    6364136223846793005ULL&gt; mt19937_64;</a>
<a name="ln1541"> </a>
<a name="ln1542">  typedef subtract_with_carry_engine&lt;uint_fast32_t, 24, 10, 24&gt;</a>
<a name="ln1543">    ranlux24_base;</a>
<a name="ln1544"> </a>
<a name="ln1545">  typedef subtract_with_carry_engine&lt;uint_fast64_t, 48, 5, 12&gt;</a>
<a name="ln1546">    ranlux48_base;</a>
<a name="ln1547"> </a>
<a name="ln1548">  typedef discard_block_engine&lt;ranlux24_base, 223, 23&gt; ranlux24;</a>
<a name="ln1549"> </a>
<a name="ln1550">  typedef discard_block_engine&lt;ranlux48_base, 389, 11&gt; ranlux48;</a>
<a name="ln1551"> </a>
<a name="ln1552">  typedef shuffle_order_engine&lt;minstd_rand0, 256&gt; knuth_b;</a>
<a name="ln1553"> </a>
<a name="ln1554">  typedef minstd_rand0 default_random_engine;</a>
<a name="ln1555"> </a>
<a name="ln1556">  /**</a>
<a name="ln1557">   * A standard interface to a platform-specific non-deterministic</a>
<a name="ln1558">   * random number generator (if any are available).</a>
<a name="ln1559">   */</a>
<a name="ln1560">  class random_device</a>
<a name="ln1561">  {</a>
<a name="ln1562">  public:</a>
<a name="ln1563">    /** The type of the generated random value. */</a>
<a name="ln1564">    typedef unsigned int result_type;</a>
<a name="ln1565"> </a>
<a name="ln1566">    // constructors, destructors and member functions</a>
<a name="ln1567"> </a>
<a name="ln1568">#ifdef _GLIBCXX_USE_RANDOM_TR1</a>
<a name="ln1569"> </a>
<a name="ln1570">    explicit</a>
<a name="ln1571">    random_device(const std::string&amp; __token = &quot;default&quot;)</a>
<a name="ln1572">    {</a>
<a name="ln1573">      _M_init(__token);</a>
<a name="ln1574">    }</a>
<a name="ln1575"> </a>
<a name="ln1576">    ~random_device()</a>
<a name="ln1577">    { _M_fini(); }</a>
<a name="ln1578"> </a>
<a name="ln1579">#else</a>
<a name="ln1580"> </a>
<a name="ln1581">    explicit</a>
<a name="ln1582">    random_device(const std::string&amp; __token = &quot;mt19937&quot;)</a>
<a name="ln1583">    { _M_init_pretr1(__token); }</a>
<a name="ln1584"> </a>
<a name="ln1585">  public:</a>
<a name="ln1586"> </a>
<a name="ln1587">#endif</a>
<a name="ln1588"> </a>
<a name="ln1589">    static constexpr result_type</a>
<a name="ln1590">    min()</a>
<a name="ln1591">    { return std::numeric_limits&lt;result_type&gt;::min(); }</a>
<a name="ln1592"> </a>
<a name="ln1593">    static constexpr result_type</a>
<a name="ln1594">    max()</a>
<a name="ln1595">    { return std::numeric_limits&lt;result_type&gt;::max(); }</a>
<a name="ln1596"> </a>
<a name="ln1597">    double</a>
<a name="ln1598">    entropy() const noexcept</a>
<a name="ln1599">    {</a>
<a name="ln1600">#ifdef _GLIBCXX_USE_RANDOM_TR1</a>
<a name="ln1601">      return this-&gt;_M_getentropy();</a>
<a name="ln1602">#else</a>
<a name="ln1603">      return 0.0;</a>
<a name="ln1604">#endif</a>
<a name="ln1605">    }</a>
<a name="ln1606"> </a>
<a name="ln1607">    result_type</a>
<a name="ln1608">    operator()()</a>
<a name="ln1609">    {</a>
<a name="ln1610">#ifdef _GLIBCXX_USE_RANDOM_TR1</a>
<a name="ln1611">      return this-&gt;_M_getval();</a>
<a name="ln1612">#else</a>
<a name="ln1613">      return this-&gt;_M_getval_pretr1();</a>
<a name="ln1614">#endif</a>
<a name="ln1615">    }</a>
<a name="ln1616"> </a>
<a name="ln1617">    // No copy functions.</a>
<a name="ln1618">    random_device(const random_device&amp;) = delete;</a>
<a name="ln1619">    void operator=(const random_device&amp;) = delete;</a>
<a name="ln1620"> </a>
<a name="ln1621">  private:</a>
<a name="ln1622"> </a>
<a name="ln1623">    void _M_init(const std::string&amp; __token);</a>
<a name="ln1624">    void _M_init_pretr1(const std::string&amp; __token);</a>
<a name="ln1625">    void _M_fini();</a>
<a name="ln1626"> </a>
<a name="ln1627">    result_type _M_getval();</a>
<a name="ln1628">    result_type _M_getval_pretr1();</a>
<a name="ln1629">    double _M_getentropy() const noexcept;</a>
<a name="ln1630"> </a>
<a name="ln1631">    union</a>
<a name="ln1632">    {</a>
<a name="ln1633">      void*      _M_file;</a>
<a name="ln1634">      mt19937    _M_mt;</a>
<a name="ln1635">    };</a>
<a name="ln1636">  };</a>
<a name="ln1637"> </a>
<a name="ln1638">  /* @} */ // group random_generators</a>
<a name="ln1639"> </a>
<a name="ln1640">  /**</a>
<a name="ln1641">   * @addtogroup random_distributions Random Number Distributions</a>
<a name="ln1642">   * @ingroup random</a>
<a name="ln1643">   * @{</a>
<a name="ln1644">   */</a>
<a name="ln1645"> </a>
<a name="ln1646">  /**</a>
<a name="ln1647">   * @addtogroup random_distributions_uniform Uniform Distributions</a>
<a name="ln1648">   * @ingroup random_distributions</a>
<a name="ln1649">   * @{</a>
<a name="ln1650">   */</a>
<a name="ln1651"> </a>
<a name="ln1652">  // std::uniform_int_distribution is defined in &lt;bits/uniform_int_dist.h&gt;</a>
<a name="ln1653"> </a>
<a name="ln1654">  /**</a>
<a name="ln1655">   * @brief Return true if two uniform integer distributions have</a>
<a name="ln1656">   *        different parameters.</a>
<a name="ln1657">   */</a>
<a name="ln1658">  template&lt;typename _IntType&gt;</a>
<a name="ln1659">    inline bool</a>
<a name="ln1660">    operator!=(const std::uniform_int_distribution&lt;_IntType&gt;&amp; __d1,</a>
<a name="ln1661">	       const std::uniform_int_distribution&lt;_IntType&gt;&amp; __d2)</a>
<a name="ln1662">    { return !(__d1 == __d2); }</a>
<a name="ln1663"> </a>
<a name="ln1664">  /**</a>
<a name="ln1665">   * @brief Inserts a %uniform_int_distribution random number</a>
<a name="ln1666">   *        distribution @p __x into the output stream @p os.</a>
<a name="ln1667">   *</a>
<a name="ln1668">   * @param __os An output stream.</a>
<a name="ln1669">   * @param __x  A %uniform_int_distribution random number distribution.</a>
<a name="ln1670">   *</a>
<a name="ln1671">   * @returns The output stream with the state of @p __x inserted or in</a>
<a name="ln1672">   * an error state.</a>
<a name="ln1673">   */</a>
<a name="ln1674">  template&lt;typename _IntType, typename _CharT, typename _Traits&gt;</a>
<a name="ln1675">    std::basic_ostream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln1676">    operator&lt;&lt;(std::basic_ostream&lt;_CharT, _Traits&gt;&amp;,</a>
<a name="ln1677">	       const std::uniform_int_distribution&lt;_IntType&gt;&amp;);</a>
<a name="ln1678"> </a>
<a name="ln1679">  /**</a>
<a name="ln1680">   * @brief Extracts a %uniform_int_distribution random number distribution</a>
<a name="ln1681">   * @p __x from the input stream @p __is.</a>
<a name="ln1682">   *</a>
<a name="ln1683">   * @param __is An input stream.</a>
<a name="ln1684">   * @param __x  A %uniform_int_distribution random number generator engine.</a>
<a name="ln1685">   *</a>
<a name="ln1686">   * @returns The input stream with @p __x extracted or in an error state.</a>
<a name="ln1687">   */</a>
<a name="ln1688">  template&lt;typename _IntType, typename _CharT, typename _Traits&gt;</a>
<a name="ln1689">    std::basic_istream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln1690">    operator&gt;&gt;(std::basic_istream&lt;_CharT, _Traits&gt;&amp;,</a>
<a name="ln1691">	       std::uniform_int_distribution&lt;_IntType&gt;&amp;);</a>
<a name="ln1692"> </a>
<a name="ln1693"> </a>
<a name="ln1694">  /**</a>
<a name="ln1695">   * @brief Uniform continuous distribution for random numbers.</a>
<a name="ln1696">   *</a>
<a name="ln1697">   * A continuous random distribution on the range [min, max) with equal</a>
<a name="ln1698">   * probability throughout the range.  The URNG should be real-valued and</a>
<a name="ln1699">   * deliver number in the range [0, 1).</a>
<a name="ln1700">   */</a>
<a name="ln1701">  template&lt;typename _RealType = double&gt;</a>
<a name="ln1702">    class uniform_real_distribution</a>
<a name="ln1703">    {</a>
<a name="ln1704">      static_assert(std::is_floating_point&lt;_RealType&gt;::value,</a>
<a name="ln1705">		    &quot;result_type must be a floating point type&quot;);</a>
<a name="ln1706"> </a>
<a name="ln1707">    public:</a>
<a name="ln1708">      /** The type of the range of the distribution. */</a>
<a name="ln1709">      typedef _RealType result_type;</a>
<a name="ln1710"> </a>
<a name="ln1711">      /** Parameter type. */</a>
<a name="ln1712">      struct param_type</a>
<a name="ln1713">      {</a>
<a name="ln1714">	typedef uniform_real_distribution&lt;_RealType&gt; distribution_type;</a>
<a name="ln1715"> </a>
<a name="ln1716">	explicit</a>
<a name="ln1717">	param_type(_RealType __a = _RealType(0),</a>
<a name="ln1718">		   _RealType __b = _RealType(1))</a>
<a name="ln1719">	: _M_a(__a), _M_b(__b)</a>
<a name="ln1720">	{</a>
<a name="ln1721">	  __glibcxx_assert(_M_a &lt;= _M_b);</a>
<a name="ln1722">	}</a>
<a name="ln1723"> </a>
<a name="ln1724">	result_type</a>
<a name="ln1725">	a() const</a>
<a name="ln1726">	{ return _M_a; }</a>
<a name="ln1727"> </a>
<a name="ln1728">	result_type</a>
<a name="ln1729">	b() const</a>
<a name="ln1730">	{ return _M_b; }</a>
<a name="ln1731"> </a>
<a name="ln1732">	friend bool</a>
<a name="ln1733">	operator==(const param_type&amp; __p1, const param_type&amp; __p2)</a>
<a name="ln1734">	{ return __p1._M_a == __p2._M_a &amp;&amp; __p1._M_b == __p2._M_b; }</a>
<a name="ln1735"> </a>
<a name="ln1736">	friend bool</a>
<a name="ln1737">	operator!=(const param_type&amp; __p1, const param_type&amp; __p2)</a>
<a name="ln1738">	{ return !(__p1 == __p2); }</a>
<a name="ln1739"> </a>
<a name="ln1740">      private:</a>
<a name="ln1741">	_RealType _M_a;</a>
<a name="ln1742">	_RealType _M_b;</a>
<a name="ln1743">      };</a>
<a name="ln1744"> </a>
<a name="ln1745">    public:</a>
<a name="ln1746">      /**</a>
<a name="ln1747">       * @brief Constructs a uniform_real_distribution object.</a>
<a name="ln1748">       *</a>
<a name="ln1749">       * @param __a [IN]  The lower bound of the distribution.</a>
<a name="ln1750">       * @param __b [IN]  The upper bound of the distribution.</a>
<a name="ln1751">       */</a>
<a name="ln1752">      explicit</a>
<a name="ln1753">      uniform_real_distribution(_RealType __a = _RealType(0),</a>
<a name="ln1754">				_RealType __b = _RealType(1))</a>
<a name="ln1755">      : _M_param(__a, __b)</a>
<a name="ln1756">      { }</a>
<a name="ln1757"> </a>
<a name="ln1758">      explicit</a>
<a name="ln1759">      uniform_real_distribution(const param_type&amp; __p)</a>
<a name="ln1760">      : _M_param(__p)</a>
<a name="ln1761">      { }</a>
<a name="ln1762"> </a>
<a name="ln1763">      /**</a>
<a name="ln1764">       * @brief Resets the distribution state.</a>
<a name="ln1765">       *</a>
<a name="ln1766">       * Does nothing for the uniform real distribution.</a>
<a name="ln1767">       */</a>
<a name="ln1768">      void</a>
<a name="ln1769">      reset() { }</a>
<a name="ln1770"> </a>
<a name="ln1771">      result_type</a>
<a name="ln1772">      a() const</a>
<a name="ln1773">      { return _M_param.a(); }</a>
<a name="ln1774"> </a>
<a name="ln1775">      result_type</a>
<a name="ln1776">      b() const</a>
<a name="ln1777">      { return _M_param.b(); }</a>
<a name="ln1778"> </a>
<a name="ln1779">      /**</a>
<a name="ln1780">       * @brief Returns the parameter set of the distribution.</a>
<a name="ln1781">       */</a>
<a name="ln1782">      param_type</a>
<a name="ln1783">      param() const</a>
<a name="ln1784">      { return _M_param; }</a>
<a name="ln1785"> </a>
<a name="ln1786">      /**</a>
<a name="ln1787">       * @brief Sets the parameter set of the distribution.</a>
<a name="ln1788">       * @param __param The new parameter set of the distribution.</a>
<a name="ln1789">       */</a>
<a name="ln1790">      void</a>
<a name="ln1791">      param(const param_type&amp; __param)</a>
<a name="ln1792">      { _M_param = __param; }</a>
<a name="ln1793"> </a>
<a name="ln1794">      /**</a>
<a name="ln1795">       * @brief Returns the inclusive lower bound of the distribution range.</a>
<a name="ln1796">       */</a>
<a name="ln1797">      result_type</a>
<a name="ln1798">      min() const</a>
<a name="ln1799">      { return this-&gt;a(); }</a>
<a name="ln1800"> </a>
<a name="ln1801">      /**</a>
<a name="ln1802">       * @brief Returns the inclusive upper bound of the distribution range.</a>
<a name="ln1803">       */</a>
<a name="ln1804">      result_type</a>
<a name="ln1805">      max() const</a>
<a name="ln1806">      { return this-&gt;b(); }</a>
<a name="ln1807"> </a>
<a name="ln1808">      /**</a>
<a name="ln1809">       * @brief Generating functions.</a>
<a name="ln1810">       */</a>
<a name="ln1811">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln1812">	result_type</a>
<a name="ln1813">	operator()(_UniformRandomNumberGenerator&amp; __urng)</a>
<a name="ln1814">        { return this-&gt;operator()(__urng, _M_param); }</a>
<a name="ln1815"> </a>
<a name="ln1816">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln1817">	result_type</a>
<a name="ln1818">	operator()(_UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln1819">		   const param_type&amp; __p)</a>
<a name="ln1820">	{</a>
<a name="ln1821">	  __detail::_Adaptor&lt;_UniformRandomNumberGenerator, result_type&gt;</a>
<a name="ln1822">	    __aurng(__urng);</a>
<a name="ln1823">	  return (__aurng() * (__p.b() - __p.a())) + __p.a();</a>
<a name="ln1824">	}</a>
<a name="ln1825"> </a>
<a name="ln1826">      template&lt;typename _ForwardIterator,</a>
<a name="ln1827">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln1828">	void</a>
<a name="ln1829">	__generate(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln1830">		   _UniformRandomNumberGenerator&amp; __urng)</a>
<a name="ln1831">	{ this-&gt;__generate(__f, __t, __urng, _M_param); }</a>
<a name="ln1832"> </a>
<a name="ln1833">      template&lt;typename _ForwardIterator,</a>
<a name="ln1834">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln1835">	void</a>
<a name="ln1836">	__generate(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln1837">		   _UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln1838">		   const param_type&amp; __p)</a>
<a name="ln1839">	{ this-&gt;__generate_impl(__f, __t, __urng, __p); }</a>
<a name="ln1840"> </a>
<a name="ln1841">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln1842">	void</a>
<a name="ln1843">	__generate(result_type* __f, result_type* __t,</a>
<a name="ln1844">		   _UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln1845">		   const param_type&amp; __p)</a>
<a name="ln1846">	{ this-&gt;__generate_impl(__f, __t, __urng, __p); }</a>
<a name="ln1847"> </a>
<a name="ln1848">      /**</a>
<a name="ln1849">       * @brief Return true if two uniform real distributions have</a>
<a name="ln1850">       *        the same parameters.</a>
<a name="ln1851">       */</a>
<a name="ln1852">      friend bool</a>
<a name="ln1853">      operator==(const uniform_real_distribution&amp; __d1,</a>
<a name="ln1854">		 const uniform_real_distribution&amp; __d2)</a>
<a name="ln1855">      { return __d1._M_param == __d2._M_param; }</a>
<a name="ln1856"> </a>
<a name="ln1857">    private:</a>
<a name="ln1858">      template&lt;typename _ForwardIterator,</a>
<a name="ln1859">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln1860">	void</a>
<a name="ln1861">	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln1862">			_UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln1863">			const param_type&amp; __p);</a>
<a name="ln1864"> </a>
<a name="ln1865">      param_type _M_param;</a>
<a name="ln1866">    };</a>
<a name="ln1867"> </a>
<a name="ln1868">  /**</a>
<a name="ln1869">   * @brief Return true if two uniform real distributions have</a>
<a name="ln1870">   *        different parameters.</a>
<a name="ln1871">   */</a>
<a name="ln1872">  template&lt;typename _IntType&gt;</a>
<a name="ln1873">    inline bool</a>
<a name="ln1874">    operator!=(const std::uniform_real_distribution&lt;_IntType&gt;&amp; __d1,</a>
<a name="ln1875">	       const std::uniform_real_distribution&lt;_IntType&gt;&amp; __d2)</a>
<a name="ln1876">    { return !(__d1 == __d2); }</a>
<a name="ln1877"> </a>
<a name="ln1878">  /**</a>
<a name="ln1879">   * @brief Inserts a %uniform_real_distribution random number</a>
<a name="ln1880">   *        distribution @p __x into the output stream @p __os.</a>
<a name="ln1881">   *</a>
<a name="ln1882">   * @param __os An output stream.</a>
<a name="ln1883">   * @param __x  A %uniform_real_distribution random number distribution.</a>
<a name="ln1884">   *</a>
<a name="ln1885">   * @returns The output stream with the state of @p __x inserted or in</a>
<a name="ln1886">   *          an error state.</a>
<a name="ln1887">   */</a>
<a name="ln1888">  template&lt;typename _RealType, typename _CharT, typename _Traits&gt;</a>
<a name="ln1889">    std::basic_ostream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln1890">    operator&lt;&lt;(std::basic_ostream&lt;_CharT, _Traits&gt;&amp;,</a>
<a name="ln1891">	       const std::uniform_real_distribution&lt;_RealType&gt;&amp;);</a>
<a name="ln1892"> </a>
<a name="ln1893">  /**</a>
<a name="ln1894">   * @brief Extracts a %uniform_real_distribution random number distribution</a>
<a name="ln1895">   * @p __x from the input stream @p __is.</a>
<a name="ln1896">   *</a>
<a name="ln1897">   * @param __is An input stream.</a>
<a name="ln1898">   * @param __x  A %uniform_real_distribution random number generator engine.</a>
<a name="ln1899">   *</a>
<a name="ln1900">   * @returns The input stream with @p __x extracted or in an error state.</a>
<a name="ln1901">   */</a>
<a name="ln1902">  template&lt;typename _RealType, typename _CharT, typename _Traits&gt;</a>
<a name="ln1903">    std::basic_istream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln1904">    operator&gt;&gt;(std::basic_istream&lt;_CharT, _Traits&gt;&amp;,</a>
<a name="ln1905">	       std::uniform_real_distribution&lt;_RealType&gt;&amp;);</a>
<a name="ln1906"> </a>
<a name="ln1907">  /* @} */ // group random_distributions_uniform</a>
<a name="ln1908"> </a>
<a name="ln1909">  /**</a>
<a name="ln1910">   * @addtogroup random_distributions_normal Normal Distributions</a>
<a name="ln1911">   * @ingroup random_distributions</a>
<a name="ln1912">   * @{</a>
<a name="ln1913">   */</a>
<a name="ln1914"> </a>
<a name="ln1915">  /**</a>
<a name="ln1916">   * @brief A normal continuous distribution for random numbers.</a>
<a name="ln1917">   *</a>
<a name="ln1918">   * The formula for the normal probability density function is</a>
<a name="ln1919">   * @f[</a>
<a name="ln1920">   *     p(x|\mu,\sigma) = \frac{1}{\sigma \sqrt{2 \pi}}</a>
<a name="ln1921">   *            e^{- \frac{{x - \mu}^ {2}}{2 \sigma ^ {2}} } </a>
<a name="ln1922">   * @f]</a>
<a name="ln1923">   */</a>
<a name="ln1924">  template&lt;typename _RealType = double&gt;</a>
<a name="ln1925">    class normal_distribution</a>
<a name="ln1926">    {</a>
<a name="ln1927">      static_assert(std::is_floating_point&lt;_RealType&gt;::value,</a>
<a name="ln1928">		    &quot;result_type must be a floating point type&quot;);</a>
<a name="ln1929"> </a>
<a name="ln1930">    public:</a>
<a name="ln1931">      /** The type of the range of the distribution. */</a>
<a name="ln1932">      typedef _RealType result_type;</a>
<a name="ln1933"> </a>
<a name="ln1934">      /** Parameter type. */</a>
<a name="ln1935">      struct param_type</a>
<a name="ln1936">      {</a>
<a name="ln1937">	typedef normal_distribution&lt;_RealType&gt; distribution_type;</a>
<a name="ln1938"> </a>
<a name="ln1939">	explicit</a>
<a name="ln1940">	param_type(_RealType __mean = _RealType(0),</a>
<a name="ln1941">		   _RealType __stddev = _RealType(1))</a>
<a name="ln1942">	: _M_mean(__mean), _M_stddev(__stddev)</a>
<a name="ln1943">	{</a>
<a name="ln1944">	  __glibcxx_assert(_M_stddev &gt; _RealType(0));</a>
<a name="ln1945">	}</a>
<a name="ln1946"> </a>
<a name="ln1947">	_RealType</a>
<a name="ln1948">	mean() const</a>
<a name="ln1949">	{ return _M_mean; }</a>
<a name="ln1950"> </a>
<a name="ln1951">	_RealType</a>
<a name="ln1952">	stddev() const</a>
<a name="ln1953">	{ return _M_stddev; }</a>
<a name="ln1954"> </a>
<a name="ln1955">	friend bool</a>
<a name="ln1956">	operator==(const param_type&amp; __p1, const param_type&amp; __p2)</a>
<a name="ln1957">	{ return (__p1._M_mean == __p2._M_mean</a>
<a name="ln1958">		  &amp;&amp; __p1._M_stddev == __p2._M_stddev); }</a>
<a name="ln1959"> </a>
<a name="ln1960">	friend bool</a>
<a name="ln1961">	operator!=(const param_type&amp; __p1, const param_type&amp; __p2)</a>
<a name="ln1962">	{ return !(__p1 == __p2); }</a>
<a name="ln1963"> </a>
<a name="ln1964">      private:</a>
<a name="ln1965">	_RealType _M_mean;</a>
<a name="ln1966">	_RealType _M_stddev;</a>
<a name="ln1967">      };</a>
<a name="ln1968"> </a>
<a name="ln1969">    public:</a>
<a name="ln1970">      /**</a>
<a name="ln1971">       * Constructs a normal distribution with parameters @f$mean@f$ and</a>
<a name="ln1972">       * standard deviation.</a>
<a name="ln1973">       */</a>
<a name="ln1974">      explicit</a>
<a name="ln1975">      normal_distribution(result_type __mean = result_type(0),</a>
<a name="ln1976">			  result_type __stddev = result_type(1))</a>
<a name="ln1977">      : _M_param(__mean, __stddev), _M_saved_available(false)</a>
<a name="ln1978">      { }</a>
<a name="ln1979"> </a>
<a name="ln1980">      explicit</a>
<a name="ln1981">      normal_distribution(const param_type&amp; __p)</a>
<a name="ln1982">      : _M_param(__p), _M_saved_available(false)</a>
<a name="ln1983">      { }</a>
<a name="ln1984"> </a>
<a name="ln1985">      /**</a>
<a name="ln1986">       * @brief Resets the distribution state.</a>
<a name="ln1987">       */</a>
<a name="ln1988">      void</a>
<a name="ln1989">      reset()</a>
<a name="ln1990">      { _M_saved_available = false; }</a>
<a name="ln1991"> </a>
<a name="ln1992">      /**</a>
<a name="ln1993">       * @brief Returns the mean of the distribution.</a>
<a name="ln1994">       */</a>
<a name="ln1995">      _RealType</a>
<a name="ln1996">      mean() const</a>
<a name="ln1997">      { return _M_param.mean(); }</a>
<a name="ln1998"> </a>
<a name="ln1999">      /**</a>
<a name="ln2000">       * @brief Returns the standard deviation of the distribution.</a>
<a name="ln2001">       */</a>
<a name="ln2002">      _RealType</a>
<a name="ln2003">      stddev() const</a>
<a name="ln2004">      { return _M_param.stddev(); }</a>
<a name="ln2005"> </a>
<a name="ln2006">      /**</a>
<a name="ln2007">       * @brief Returns the parameter set of the distribution.</a>
<a name="ln2008">       */</a>
<a name="ln2009">      param_type</a>
<a name="ln2010">      param() const</a>
<a name="ln2011">      { return _M_param; }</a>
<a name="ln2012"> </a>
<a name="ln2013">      /**</a>
<a name="ln2014">       * @brief Sets the parameter set of the distribution.</a>
<a name="ln2015">       * @param __param The new parameter set of the distribution.</a>
<a name="ln2016">       */</a>
<a name="ln2017">      void</a>
<a name="ln2018">      param(const param_type&amp; __param)</a>
<a name="ln2019">      { _M_param = __param; }</a>
<a name="ln2020"> </a>
<a name="ln2021">      /**</a>
<a name="ln2022">       * @brief Returns the greatest lower bound value of the distribution.</a>
<a name="ln2023">       */</a>
<a name="ln2024">      result_type</a>
<a name="ln2025">      min() const</a>
<a name="ln2026">      { return std::numeric_limits&lt;result_type&gt;::lowest(); }</a>
<a name="ln2027"> </a>
<a name="ln2028">      /**</a>
<a name="ln2029">       * @brief Returns the least upper bound value of the distribution.</a>
<a name="ln2030">       */</a>
<a name="ln2031">      result_type</a>
<a name="ln2032">      max() const</a>
<a name="ln2033">      { return std::numeric_limits&lt;result_type&gt;::max(); }</a>
<a name="ln2034"> </a>
<a name="ln2035">      /**</a>
<a name="ln2036">       * @brief Generating functions.</a>
<a name="ln2037">       */</a>
<a name="ln2038">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln2039">	result_type</a>
<a name="ln2040">	operator()(_UniformRandomNumberGenerator&amp; __urng)</a>
<a name="ln2041">	{ return this-&gt;operator()(__urng, _M_param); }</a>
<a name="ln2042"> </a>
<a name="ln2043">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln2044">	result_type</a>
<a name="ln2045">	operator()(_UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln2046">		   const param_type&amp; __p);</a>
<a name="ln2047"> </a>
<a name="ln2048">      template&lt;typename _ForwardIterator,</a>
<a name="ln2049">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln2050">	void</a>
<a name="ln2051">	__generate(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln2052">		   _UniformRandomNumberGenerator&amp; __urng)</a>
<a name="ln2053">	{ this-&gt;__generate(__f, __t, __urng, _M_param); }</a>
<a name="ln2054"> </a>
<a name="ln2055">      template&lt;typename _ForwardIterator,</a>
<a name="ln2056">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln2057">	void</a>
<a name="ln2058">	__generate(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln2059">		   _UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln2060">		   const param_type&amp; __p)</a>
<a name="ln2061">	{ this-&gt;__generate_impl(__f, __t, __urng, __p); }</a>
<a name="ln2062"> </a>
<a name="ln2063">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln2064">	void</a>
<a name="ln2065">	__generate(result_type* __f, result_type* __t,</a>
<a name="ln2066">		   _UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln2067">		   const param_type&amp; __p)</a>
<a name="ln2068">	{ this-&gt;__generate_impl(__f, __t, __urng, __p); }</a>
<a name="ln2069"> </a>
<a name="ln2070">      /**</a>
<a name="ln2071">       * @brief Return true if two normal distributions have</a>
<a name="ln2072">       *        the same parameters and the sequences that would</a>
<a name="ln2073">       *        be generated are equal.</a>
<a name="ln2074">       */</a>
<a name="ln2075">      template&lt;typename _RealType1&gt;</a>
<a name="ln2076">	friend bool</a>
<a name="ln2077">        operator==(const std::normal_distribution&lt;_RealType1&gt;&amp; __d1,</a>
<a name="ln2078">		   const std::normal_distribution&lt;_RealType1&gt;&amp; __d2);</a>
<a name="ln2079"> </a>
<a name="ln2080">      /**</a>
<a name="ln2081">       * @brief Inserts a %normal_distribution random number distribution</a>
<a name="ln2082">       * @p __x into the output stream @p __os.</a>
<a name="ln2083">       *</a>
<a name="ln2084">       * @param __os An output stream.</a>
<a name="ln2085">       * @param __x  A %normal_distribution random number distribution.</a>
<a name="ln2086">       *</a>
<a name="ln2087">       * @returns The output stream with the state of @p __x inserted or in</a>
<a name="ln2088">       * an error state.</a>
<a name="ln2089">       */</a>
<a name="ln2090">      template&lt;typename _RealType1, typename _CharT, typename _Traits&gt;</a>
<a name="ln2091">	friend std::basic_ostream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln2092">	operator&lt;&lt;(std::basic_ostream&lt;_CharT, _Traits&gt;&amp; __os,</a>
<a name="ln2093">		   const std::normal_distribution&lt;_RealType1&gt;&amp; __x);</a>
<a name="ln2094"> </a>
<a name="ln2095">      /**</a>
<a name="ln2096">       * @brief Extracts a %normal_distribution random number distribution</a>
<a name="ln2097">       * @p __x from the input stream @p __is.</a>
<a name="ln2098">       *</a>
<a name="ln2099">       * @param __is An input stream.</a>
<a name="ln2100">       * @param __x  A %normal_distribution random number generator engine.</a>
<a name="ln2101">       *</a>
<a name="ln2102">       * @returns The input stream with @p __x extracted or in an error</a>
<a name="ln2103">       *          state.</a>
<a name="ln2104">       */</a>
<a name="ln2105">      template&lt;typename _RealType1, typename _CharT, typename _Traits&gt;</a>
<a name="ln2106">	friend std::basic_istream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln2107">	operator&gt;&gt;(std::basic_istream&lt;_CharT, _Traits&gt;&amp; __is,</a>
<a name="ln2108">		   std::normal_distribution&lt;_RealType1&gt;&amp; __x);</a>
<a name="ln2109"> </a>
<a name="ln2110">    private:</a>
<a name="ln2111">      template&lt;typename _ForwardIterator,</a>
<a name="ln2112">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln2113">	void</a>
<a name="ln2114">	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln2115">			_UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln2116">			const param_type&amp; __p);</a>
<a name="ln2117"> </a>
<a name="ln2118">      param_type  _M_param;</a>
<a name="ln2119">      result_type _M_saved;</a>
<a name="ln2120">      bool        _M_saved_available;</a>
<a name="ln2121">    };</a>
<a name="ln2122"> </a>
<a name="ln2123">  /**</a>
<a name="ln2124">   * @brief Return true if two normal distributions are different.</a>
<a name="ln2125">   */</a>
<a name="ln2126">  template&lt;typename _RealType&gt;</a>
<a name="ln2127">    inline bool</a>
<a name="ln2128">    operator!=(const std::normal_distribution&lt;_RealType&gt;&amp; __d1,</a>
<a name="ln2129">	       const std::normal_distribution&lt;_RealType&gt;&amp; __d2)</a>
<a name="ln2130">    { return !(__d1 == __d2); }</a>
<a name="ln2131"> </a>
<a name="ln2132"> </a>
<a name="ln2133">  /**</a>
<a name="ln2134">   * @brief A lognormal_distribution random number distribution.</a>
<a name="ln2135">   *</a>
<a name="ln2136">   * The formula for the normal probability mass function is</a>
<a name="ln2137">   * @f[</a>
<a name="ln2138">   *     p(x|m,s) = \frac{1}{sx\sqrt{2\pi}}</a>
<a name="ln2139">   *                \exp{-\frac{(\ln{x} - m)^2}{2s^2}} </a>
<a name="ln2140">   * @f]</a>
<a name="ln2141">   */</a>
<a name="ln2142">  template&lt;typename _RealType = double&gt;</a>
<a name="ln2143">    class lognormal_distribution</a>
<a name="ln2144">    {</a>
<a name="ln2145">      static_assert(std::is_floating_point&lt;_RealType&gt;::value,</a>
<a name="ln2146">		    &quot;result_type must be a floating point type&quot;);</a>
<a name="ln2147"> </a>
<a name="ln2148">    public:</a>
<a name="ln2149">      /** The type of the range of the distribution. */</a>
<a name="ln2150">      typedef _RealType result_type;</a>
<a name="ln2151"> </a>
<a name="ln2152">      /** Parameter type. */</a>
<a name="ln2153">      struct param_type</a>
<a name="ln2154">      {</a>
<a name="ln2155">	typedef lognormal_distribution&lt;_RealType&gt; distribution_type;</a>
<a name="ln2156"> </a>
<a name="ln2157">	explicit</a>
<a name="ln2158">	param_type(_RealType __m = _RealType(0),</a>
<a name="ln2159">		   _RealType __s = _RealType(1))</a>
<a name="ln2160">	: _M_m(__m), _M_s(__s)</a>
<a name="ln2161">	{ }</a>
<a name="ln2162"> </a>
<a name="ln2163">	_RealType</a>
<a name="ln2164">	m() const</a>
<a name="ln2165">	{ return _M_m; }</a>
<a name="ln2166"> </a>
<a name="ln2167">	_RealType</a>
<a name="ln2168">	s() const</a>
<a name="ln2169">	{ return _M_s; }</a>
<a name="ln2170"> </a>
<a name="ln2171">	friend bool</a>
<a name="ln2172">	operator==(const param_type&amp; __p1, const param_type&amp; __p2)</a>
<a name="ln2173">	{ return __p1._M_m == __p2._M_m &amp;&amp; __p1._M_s == __p2._M_s; }</a>
<a name="ln2174"> </a>
<a name="ln2175">	friend bool</a>
<a name="ln2176">	operator!=(const param_type&amp; __p1, const param_type&amp; __p2)</a>
<a name="ln2177">	{ return !(__p1 == __p2); }</a>
<a name="ln2178"> </a>
<a name="ln2179">      private:</a>
<a name="ln2180">	_RealType _M_m;</a>
<a name="ln2181">	_RealType _M_s;</a>
<a name="ln2182">      };</a>
<a name="ln2183"> </a>
<a name="ln2184">      explicit</a>
<a name="ln2185">      lognormal_distribution(_RealType __m = _RealType(0),</a>
<a name="ln2186">			     _RealType __s = _RealType(1))</a>
<a name="ln2187">      : _M_param(__m, __s), _M_nd()</a>
<a name="ln2188">      { }</a>
<a name="ln2189"> </a>
<a name="ln2190">      explicit</a>
<a name="ln2191">      lognormal_distribution(const param_type&amp; __p)</a>
<a name="ln2192">      : _M_param(__p), _M_nd()</a>
<a name="ln2193">      { }</a>
<a name="ln2194"> </a>
<a name="ln2195">      /**</a>
<a name="ln2196">       * Resets the distribution state.</a>
<a name="ln2197">       */</a>
<a name="ln2198">      void</a>
<a name="ln2199">      reset()</a>
<a name="ln2200">      { _M_nd.reset(); }</a>
<a name="ln2201"> </a>
<a name="ln2202">      /**</a>
<a name="ln2203">       *</a>
<a name="ln2204">       */</a>
<a name="ln2205">      _RealType</a>
<a name="ln2206">      m() const</a>
<a name="ln2207">      { return _M_param.m(); }</a>
<a name="ln2208"> </a>
<a name="ln2209">      _RealType</a>
<a name="ln2210">      s() const</a>
<a name="ln2211">      { return _M_param.s(); }</a>
<a name="ln2212"> </a>
<a name="ln2213">      /**</a>
<a name="ln2214">       * @brief Returns the parameter set of the distribution.</a>
<a name="ln2215">       */</a>
<a name="ln2216">      param_type</a>
<a name="ln2217">      param() const</a>
<a name="ln2218">      { return _M_param; }</a>
<a name="ln2219"> </a>
<a name="ln2220">      /**</a>
<a name="ln2221">       * @brief Sets the parameter set of the distribution.</a>
<a name="ln2222">       * @param __param The new parameter set of the distribution.</a>
<a name="ln2223">       */</a>
<a name="ln2224">      void</a>
<a name="ln2225">      param(const param_type&amp; __param)</a>
<a name="ln2226">      { _M_param = __param; }</a>
<a name="ln2227"> </a>
<a name="ln2228">      /**</a>
<a name="ln2229">       * @brief Returns the greatest lower bound value of the distribution.</a>
<a name="ln2230">       */</a>
<a name="ln2231">      result_type</a>
<a name="ln2232">      min() const</a>
<a name="ln2233">      { return result_type(0); }</a>
<a name="ln2234"> </a>
<a name="ln2235">      /**</a>
<a name="ln2236">       * @brief Returns the least upper bound value of the distribution.</a>
<a name="ln2237">       */</a>
<a name="ln2238">      result_type</a>
<a name="ln2239">      max() const</a>
<a name="ln2240">      { return std::numeric_limits&lt;result_type&gt;::max(); }</a>
<a name="ln2241"> </a>
<a name="ln2242">      /**</a>
<a name="ln2243">       * @brief Generating functions.</a>
<a name="ln2244">       */</a>
<a name="ln2245">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln2246">	result_type</a>
<a name="ln2247">	operator()(_UniformRandomNumberGenerator&amp; __urng)</a>
<a name="ln2248">        { return this-&gt;operator()(__urng, _M_param); }</a>
<a name="ln2249"> </a>
<a name="ln2250">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln2251">	result_type</a>
<a name="ln2252">	operator()(_UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln2253">		   const param_type&amp; __p)</a>
<a name="ln2254">        { return std::exp(__p.s() * _M_nd(__urng) + __p.m()); }</a>
<a name="ln2255"> </a>
<a name="ln2256">      template&lt;typename _ForwardIterator,</a>
<a name="ln2257">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln2258">	void</a>
<a name="ln2259">	__generate(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln2260">		   _UniformRandomNumberGenerator&amp; __urng)</a>
<a name="ln2261">	{ this-&gt;__generate(__f, __t, __urng, _M_param); }</a>
<a name="ln2262"> </a>
<a name="ln2263">      template&lt;typename _ForwardIterator,</a>
<a name="ln2264">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln2265">	void</a>
<a name="ln2266">	__generate(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln2267">		   _UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln2268">		   const param_type&amp; __p)</a>
<a name="ln2269">	{ this-&gt;__generate_impl(__f, __t, __urng, __p); }</a>
<a name="ln2270"> </a>
<a name="ln2271">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln2272">	void</a>
<a name="ln2273">	__generate(result_type* __f, result_type* __t,</a>
<a name="ln2274">		   _UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln2275">		   const param_type&amp; __p)</a>
<a name="ln2276">	{ this-&gt;__generate_impl(__f, __t, __urng, __p); }</a>
<a name="ln2277"> </a>
<a name="ln2278">      /**</a>
<a name="ln2279">       * @brief Return true if two lognormal distributions have</a>
<a name="ln2280">       *        the same parameters and the sequences that would</a>
<a name="ln2281">       *        be generated are equal.</a>
<a name="ln2282">       */</a>
<a name="ln2283">      friend bool</a>
<a name="ln2284">      operator==(const lognormal_distribution&amp; __d1,</a>
<a name="ln2285">		 const lognormal_distribution&amp; __d2)</a>
<a name="ln2286">      { return (__d1._M_param == __d2._M_param</a>
<a name="ln2287">		&amp;&amp; __d1._M_nd == __d2._M_nd); }</a>
<a name="ln2288"> </a>
<a name="ln2289">      /**</a>
<a name="ln2290">       * @brief Inserts a %lognormal_distribution random number distribution</a>
<a name="ln2291">       * @p __x into the output stream @p __os.</a>
<a name="ln2292">       *</a>
<a name="ln2293">       * @param __os An output stream.</a>
<a name="ln2294">       * @param __x  A %lognormal_distribution random number distribution.</a>
<a name="ln2295">       *</a>
<a name="ln2296">       * @returns The output stream with the state of @p __x inserted or in</a>
<a name="ln2297">       * an error state.</a>
<a name="ln2298">       */</a>
<a name="ln2299">      template&lt;typename _RealType1, typename _CharT, typename _Traits&gt;</a>
<a name="ln2300">	friend std::basic_ostream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln2301">	operator&lt;&lt;(std::basic_ostream&lt;_CharT, _Traits&gt;&amp; __os,</a>
<a name="ln2302">		   const std::lognormal_distribution&lt;_RealType1&gt;&amp; __x);</a>
<a name="ln2303"> </a>
<a name="ln2304">      /**</a>
<a name="ln2305">       * @brief Extracts a %lognormal_distribution random number distribution</a>
<a name="ln2306">       * @p __x from the input stream @p __is.</a>
<a name="ln2307">       *</a>
<a name="ln2308">       * @param __is An input stream.</a>
<a name="ln2309">       * @param __x A %lognormal_distribution random number</a>
<a name="ln2310">       *            generator engine.</a>
<a name="ln2311">       *</a>
<a name="ln2312">       * @returns The input stream with @p __x extracted or in an error state.</a>
<a name="ln2313">       */</a>
<a name="ln2314">      template&lt;typename _RealType1, typename _CharT, typename _Traits&gt;</a>
<a name="ln2315">	friend std::basic_istream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln2316">	operator&gt;&gt;(std::basic_istream&lt;_CharT, _Traits&gt;&amp; __is,</a>
<a name="ln2317">		   std::lognormal_distribution&lt;_RealType1&gt;&amp; __x);</a>
<a name="ln2318"> </a>
<a name="ln2319">    private:</a>
<a name="ln2320">      template&lt;typename _ForwardIterator,</a>
<a name="ln2321">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln2322">	void</a>
<a name="ln2323">	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln2324">			_UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln2325">			const param_type&amp; __p);</a>
<a name="ln2326"> </a>
<a name="ln2327">      param_type _M_param;</a>
<a name="ln2328"> </a>
<a name="ln2329">      std::normal_distribution&lt;result_type&gt; _M_nd;</a>
<a name="ln2330">    };</a>
<a name="ln2331"> </a>
<a name="ln2332">  /**</a>
<a name="ln2333">   * @brief Return true if two lognormal distributions are different.</a>
<a name="ln2334">   */</a>
<a name="ln2335">  template&lt;typename _RealType&gt;</a>
<a name="ln2336">    inline bool</a>
<a name="ln2337">    operator!=(const std::lognormal_distribution&lt;_RealType&gt;&amp; __d1,</a>
<a name="ln2338">	       const std::lognormal_distribution&lt;_RealType&gt;&amp; __d2)</a>
<a name="ln2339">    { return !(__d1 == __d2); }</a>
<a name="ln2340"> </a>
<a name="ln2341"> </a>
<a name="ln2342">  /**</a>
<a name="ln2343">   * @brief A gamma continuous distribution for random numbers.</a>
<a name="ln2344">   *</a>
<a name="ln2345">   * The formula for the gamma probability density function is:</a>
<a name="ln2346">   * @f[</a>
<a name="ln2347">   *     p(x|\alpha,\beta) = \frac{1}{\beta\Gamma(\alpha)}</a>
<a name="ln2348">   *                         (x/\beta)^{\alpha - 1} e^{-x/\beta} </a>
<a name="ln2349">   * @f]</a>
<a name="ln2350">   */</a>
<a name="ln2351">  template&lt;typename _RealType = double&gt;</a>
<a name="ln2352">    class gamma_distribution</a>
<a name="ln2353">    {</a>
<a name="ln2354">      static_assert(std::is_floating_point&lt;_RealType&gt;::value,</a>
<a name="ln2355">		    &quot;result_type must be a floating point type&quot;);</a>
<a name="ln2356"> </a>
<a name="ln2357">    public:</a>
<a name="ln2358">      /** The type of the range of the distribution. */</a>
<a name="ln2359">      typedef _RealType result_type;</a>
<a name="ln2360"> </a>
<a name="ln2361">      /** Parameter type. */</a>
<a name="ln2362">      struct param_type</a>
<a name="ln2363">      {</a>
<a name="ln2364">	typedef gamma_distribution&lt;_RealType&gt; distribution_type;</a>
<a name="ln2365">	friend class gamma_distribution&lt;_RealType&gt;;</a>
<a name="ln2366"> </a>
<a name="ln2367">	explicit</a>
<a name="ln2368">	param_type(_RealType __alpha_val = _RealType(1),</a>
<a name="ln2369">		   _RealType __beta_val = _RealType(1))</a>
<a name="ln2370">	: _M_alpha(__alpha_val), _M_beta(__beta_val)</a>
<a name="ln2371">	{</a>
<a name="ln2372">	  __glibcxx_assert(_M_alpha &gt; _RealType(0));</a>
<a name="ln2373">	  _M_initialize();</a>
<a name="ln2374">	}</a>
<a name="ln2375"> </a>
<a name="ln2376">	_RealType</a>
<a name="ln2377">	alpha() const</a>
<a name="ln2378">	{ return _M_alpha; }</a>
<a name="ln2379"> </a>
<a name="ln2380">	_RealType</a>
<a name="ln2381">	beta() const</a>
<a name="ln2382">	{ return _M_beta; }</a>
<a name="ln2383"> </a>
<a name="ln2384">	friend bool</a>
<a name="ln2385">	operator==(const param_type&amp; __p1, const param_type&amp; __p2)</a>
<a name="ln2386">	{ return (__p1._M_alpha == __p2._M_alpha</a>
<a name="ln2387">		  &amp;&amp; __p1._M_beta == __p2._M_beta); }</a>
<a name="ln2388"> </a>
<a name="ln2389">	friend bool</a>
<a name="ln2390">	operator!=(const param_type&amp; __p1, const param_type&amp; __p2)</a>
<a name="ln2391">	{ return !(__p1 == __p2); }</a>
<a name="ln2392"> </a>
<a name="ln2393">      private:</a>
<a name="ln2394">	void</a>
<a name="ln2395">	_M_initialize();</a>
<a name="ln2396"> </a>
<a name="ln2397">	_RealType _M_alpha;</a>
<a name="ln2398">	_RealType _M_beta;</a>
<a name="ln2399"> </a>
<a name="ln2400">	_RealType _M_malpha, _M_a2;</a>
<a name="ln2401">      };</a>
<a name="ln2402"> </a>
<a name="ln2403">    public:</a>
<a name="ln2404">      /**</a>
<a name="ln2405">       * @brief Constructs a gamma distribution with parameters</a>
<a name="ln2406">       * @f$\alpha@f$ and @f$\beta@f$.</a>
<a name="ln2407">       */</a>
<a name="ln2408">      explicit</a>
<a name="ln2409">      gamma_distribution(_RealType __alpha_val = _RealType(1),</a>
<a name="ln2410">			 _RealType __beta_val = _RealType(1))</a>
<a name="ln2411">      : _M_param(__alpha_val, __beta_val), _M_nd()</a>
<a name="ln2412">      { }</a>
<a name="ln2413"> </a>
<a name="ln2414">      explicit</a>
<a name="ln2415">      gamma_distribution(const param_type&amp; __p)</a>
<a name="ln2416">      : _M_param(__p), _M_nd()</a>
<a name="ln2417">      { }</a>
<a name="ln2418"> </a>
<a name="ln2419">      /**</a>
<a name="ln2420">       * @brief Resets the distribution state.</a>
<a name="ln2421">       */</a>
<a name="ln2422">      void</a>
<a name="ln2423">      reset()</a>
<a name="ln2424">      { _M_nd.reset(); }</a>
<a name="ln2425"> </a>
<a name="ln2426">      /**</a>
<a name="ln2427">       * @brief Returns the @f$\alpha@f$ of the distribution.</a>
<a name="ln2428">       */</a>
<a name="ln2429">      _RealType</a>
<a name="ln2430">      alpha() const</a>
<a name="ln2431">      { return _M_param.alpha(); }</a>
<a name="ln2432"> </a>
<a name="ln2433">      /**</a>
<a name="ln2434">       * @brief Returns the @f$\beta@f$ of the distribution.</a>
<a name="ln2435">       */</a>
<a name="ln2436">      _RealType</a>
<a name="ln2437">      beta() const</a>
<a name="ln2438">      { return _M_param.beta(); }</a>
<a name="ln2439"> </a>
<a name="ln2440">      /**</a>
<a name="ln2441">       * @brief Returns the parameter set of the distribution.</a>
<a name="ln2442">       */</a>
<a name="ln2443">      param_type</a>
<a name="ln2444">      param() const</a>
<a name="ln2445">      { return _M_param; }</a>
<a name="ln2446"> </a>
<a name="ln2447">      /**</a>
<a name="ln2448">       * @brief Sets the parameter set of the distribution.</a>
<a name="ln2449">       * @param __param The new parameter set of the distribution.</a>
<a name="ln2450">       */</a>
<a name="ln2451">      void</a>
<a name="ln2452">      param(const param_type&amp; __param)</a>
<a name="ln2453">      { _M_param = __param; }</a>
<a name="ln2454"> </a>
<a name="ln2455">      /**</a>
<a name="ln2456">       * @brief Returns the greatest lower bound value of the distribution.</a>
<a name="ln2457">       */</a>
<a name="ln2458">      result_type</a>
<a name="ln2459">      min() const</a>
<a name="ln2460">      { return result_type(0); }</a>
<a name="ln2461"> </a>
<a name="ln2462">      /**</a>
<a name="ln2463">       * @brief Returns the least upper bound value of the distribution.</a>
<a name="ln2464">       */</a>
<a name="ln2465">      result_type</a>
<a name="ln2466">      max() const</a>
<a name="ln2467">      { return std::numeric_limits&lt;result_type&gt;::max(); }</a>
<a name="ln2468"> </a>
<a name="ln2469">      /**</a>
<a name="ln2470">       * @brief Generating functions.</a>
<a name="ln2471">       */</a>
<a name="ln2472">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln2473">	result_type</a>
<a name="ln2474">	operator()(_UniformRandomNumberGenerator&amp; __urng)</a>
<a name="ln2475">	{ return this-&gt;operator()(__urng, _M_param); }</a>
<a name="ln2476"> </a>
<a name="ln2477">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln2478">	result_type</a>
<a name="ln2479">	operator()(_UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln2480">		   const param_type&amp; __p);</a>
<a name="ln2481"> </a>
<a name="ln2482">      template&lt;typename _ForwardIterator,</a>
<a name="ln2483">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln2484">	void</a>
<a name="ln2485">	__generate(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln2486">		   _UniformRandomNumberGenerator&amp; __urng)</a>
<a name="ln2487">	{ this-&gt;__generate(__f, __t, __urng, _M_param); }</a>
<a name="ln2488"> </a>
<a name="ln2489">      template&lt;typename _ForwardIterator,</a>
<a name="ln2490">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln2491">	void</a>
<a name="ln2492">	__generate(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln2493">		   _UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln2494">		   const param_type&amp; __p)</a>
<a name="ln2495">	{ this-&gt;__generate_impl(__f, __t, __urng, __p); }</a>
<a name="ln2496"> </a>
<a name="ln2497">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln2498">	void</a>
<a name="ln2499">	__generate(result_type* __f, result_type* __t,</a>
<a name="ln2500">		   _UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln2501">		   const param_type&amp; __p)</a>
<a name="ln2502">	{ this-&gt;__generate_impl(__f, __t, __urng, __p); }</a>
<a name="ln2503"> </a>
<a name="ln2504">      /**</a>
<a name="ln2505">       * @brief Return true if two gamma distributions have the same</a>
<a name="ln2506">       *        parameters and the sequences that would be generated</a>
<a name="ln2507">       *        are equal.</a>
<a name="ln2508">       */</a>
<a name="ln2509">      friend bool</a>
<a name="ln2510">      operator==(const gamma_distribution&amp; __d1,</a>
<a name="ln2511">		 const gamma_distribution&amp; __d2)</a>
<a name="ln2512">      { return (__d1._M_param == __d2._M_param</a>
<a name="ln2513">		&amp;&amp; __d1._M_nd == __d2._M_nd); }</a>
<a name="ln2514"> </a>
<a name="ln2515">      /**</a>
<a name="ln2516">       * @brief Inserts a %gamma_distribution random number distribution</a>
<a name="ln2517">       * @p __x into the output stream @p __os.</a>
<a name="ln2518">       *</a>
<a name="ln2519">       * @param __os An output stream.</a>
<a name="ln2520">       * @param __x  A %gamma_distribution random number distribution.</a>
<a name="ln2521">       *</a>
<a name="ln2522">       * @returns The output stream with the state of @p __x inserted or in</a>
<a name="ln2523">       * an error state.</a>
<a name="ln2524">       */</a>
<a name="ln2525">      template&lt;typename _RealType1, typename _CharT, typename _Traits&gt;</a>
<a name="ln2526">	friend std::basic_ostream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln2527">	operator&lt;&lt;(std::basic_ostream&lt;_CharT, _Traits&gt;&amp; __os,</a>
<a name="ln2528">		   const std::gamma_distribution&lt;_RealType1&gt;&amp; __x);</a>
<a name="ln2529"> </a>
<a name="ln2530">      /**</a>
<a name="ln2531">       * @brief Extracts a %gamma_distribution random number distribution</a>
<a name="ln2532">       * @p __x from the input stream @p __is.</a>
<a name="ln2533">       *</a>
<a name="ln2534">       * @param __is An input stream.</a>
<a name="ln2535">       * @param __x  A %gamma_distribution random number generator engine.</a>
<a name="ln2536">       *</a>
<a name="ln2537">       * @returns The input stream with @p __x extracted or in an error state.</a>
<a name="ln2538">       */</a>
<a name="ln2539">      template&lt;typename _RealType1, typename _CharT, typename _Traits&gt;</a>
<a name="ln2540">	friend std::basic_istream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln2541">	operator&gt;&gt;(std::basic_istream&lt;_CharT, _Traits&gt;&amp; __is,</a>
<a name="ln2542">		   std::gamma_distribution&lt;_RealType1&gt;&amp; __x);</a>
<a name="ln2543"> </a>
<a name="ln2544">    private:</a>
<a name="ln2545">      template&lt;typename _ForwardIterator,</a>
<a name="ln2546">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln2547">	void</a>
<a name="ln2548">	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln2549">			_UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln2550">			const param_type&amp; __p);</a>
<a name="ln2551"> </a>
<a name="ln2552">      param_type _M_param;</a>
<a name="ln2553"> </a>
<a name="ln2554">      std::normal_distribution&lt;result_type&gt; _M_nd;</a>
<a name="ln2555">    };</a>
<a name="ln2556"> </a>
<a name="ln2557">  /**</a>
<a name="ln2558">   * @brief Return true if two gamma distributions are different.</a>
<a name="ln2559">   */</a>
<a name="ln2560">   template&lt;typename _RealType&gt;</a>
<a name="ln2561">     inline bool</a>
<a name="ln2562">     operator!=(const std::gamma_distribution&lt;_RealType&gt;&amp; __d1,</a>
<a name="ln2563">		const std::gamma_distribution&lt;_RealType&gt;&amp; __d2)</a>
<a name="ln2564">    { return !(__d1 == __d2); }</a>
<a name="ln2565"> </a>
<a name="ln2566"> </a>
<a name="ln2567">  /**</a>
<a name="ln2568">   * @brief A chi_squared_distribution random number distribution.</a>
<a name="ln2569">   *</a>
<a name="ln2570">   * The formula for the normal probability mass function is</a>
<a name="ln2571">   * @f$p(x|n) = \frac{x^{(n/2) - 1}e^{-x/2}}{\Gamma(n/2) 2^{n/2}}@f$</a>
<a name="ln2572">   */</a>
<a name="ln2573">  template&lt;typename _RealType = double&gt;</a>
<a name="ln2574">    class chi_squared_distribution</a>
<a name="ln2575">    {</a>
<a name="ln2576">      static_assert(std::is_floating_point&lt;_RealType&gt;::value,</a>
<a name="ln2577">		    &quot;result_type must be a floating point type&quot;);</a>
<a name="ln2578"> </a>
<a name="ln2579">    public:</a>
<a name="ln2580">      /** The type of the range of the distribution. */</a>
<a name="ln2581">      typedef _RealType result_type;</a>
<a name="ln2582"> </a>
<a name="ln2583">      /** Parameter type. */</a>
<a name="ln2584">      struct param_type</a>
<a name="ln2585">      {</a>
<a name="ln2586">	typedef chi_squared_distribution&lt;_RealType&gt; distribution_type;</a>
<a name="ln2587"> </a>
<a name="ln2588">	explicit</a>
<a name="ln2589">	param_type(_RealType __n = _RealType(1))</a>
<a name="ln2590">	: _M_n(__n)</a>
<a name="ln2591">	{ }</a>
<a name="ln2592"> </a>
<a name="ln2593">	_RealType</a>
<a name="ln2594">	n() const</a>
<a name="ln2595">	{ return _M_n; }</a>
<a name="ln2596"> </a>
<a name="ln2597">	friend bool</a>
<a name="ln2598">	operator==(const param_type&amp; __p1, const param_type&amp; __p2)</a>
<a name="ln2599">	{ return __p1._M_n == __p2._M_n; }</a>
<a name="ln2600"> </a>
<a name="ln2601">	friend bool</a>
<a name="ln2602">	operator!=(const param_type&amp; __p1, const param_type&amp; __p2)</a>
<a name="ln2603">	{ return !(__p1 == __p2); }</a>
<a name="ln2604"> </a>
<a name="ln2605">      private:</a>
<a name="ln2606">	_RealType _M_n;</a>
<a name="ln2607">      };</a>
<a name="ln2608"> </a>
<a name="ln2609">      explicit</a>
<a name="ln2610">      chi_squared_distribution(_RealType __n = _RealType(1))</a>
<a name="ln2611">      : _M_param(__n), _M_gd(__n / 2)</a>
<a name="ln2612">      { }</a>
<a name="ln2613"> </a>
<a name="ln2614">      explicit</a>
<a name="ln2615">      chi_squared_distribution(const param_type&amp; __p)</a>
<a name="ln2616">      : _M_param(__p), _M_gd(__p.n() / 2)</a>
<a name="ln2617">      { }</a>
<a name="ln2618"> </a>
<a name="ln2619">      /**</a>
<a name="ln2620">       * @brief Resets the distribution state.</a>
<a name="ln2621">       */</a>
<a name="ln2622">      void</a>
<a name="ln2623">      reset()</a>
<a name="ln2624">      { _M_gd.reset(); }</a>
<a name="ln2625"> </a>
<a name="ln2626">      /**</a>
<a name="ln2627">       *</a>
<a name="ln2628">       */</a>
<a name="ln2629">      _RealType</a>
<a name="ln2630">      n() const</a>
<a name="ln2631">      { return _M_param.n(); }</a>
<a name="ln2632"> </a>
<a name="ln2633">      /**</a>
<a name="ln2634">       * @brief Returns the parameter set of the distribution.</a>
<a name="ln2635">       */</a>
<a name="ln2636">      param_type</a>
<a name="ln2637">      param() const</a>
<a name="ln2638">      { return _M_param; }</a>
<a name="ln2639"> </a>
<a name="ln2640">      /**</a>
<a name="ln2641">       * @brief Sets the parameter set of the distribution.</a>
<a name="ln2642">       * @param __param The new parameter set of the distribution.</a>
<a name="ln2643">       */</a>
<a name="ln2644">      void</a>
<a name="ln2645">      param(const param_type&amp; __param)</a>
<a name="ln2646">      {</a>
<a name="ln2647">	_M_param = __param;</a>
<a name="ln2648">	typedef typename std::gamma_distribution&lt;result_type&gt;::param_type</a>
<a name="ln2649">	  param_type;</a>
<a name="ln2650">	_M_gd.param(param_type{__param.n() / 2});</a>
<a name="ln2651">      }</a>
<a name="ln2652"> </a>
<a name="ln2653">      /**</a>
<a name="ln2654">       * @brief Returns the greatest lower bound value of the distribution.</a>
<a name="ln2655">       */</a>
<a name="ln2656">      result_type</a>
<a name="ln2657">      min() const</a>
<a name="ln2658">      { return result_type(0); }</a>
<a name="ln2659"> </a>
<a name="ln2660">      /**</a>
<a name="ln2661">       * @brief Returns the least upper bound value of the distribution.</a>
<a name="ln2662">       */</a>
<a name="ln2663">      result_type</a>
<a name="ln2664">      max() const</a>
<a name="ln2665">      { return std::numeric_limits&lt;result_type&gt;::max(); }</a>
<a name="ln2666"> </a>
<a name="ln2667">      /**</a>
<a name="ln2668">       * @brief Generating functions.</a>
<a name="ln2669">       */</a>
<a name="ln2670">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln2671">	result_type</a>
<a name="ln2672">	operator()(_UniformRandomNumberGenerator&amp; __urng)</a>
<a name="ln2673">	{ return 2 * _M_gd(__urng); }</a>
<a name="ln2674"> </a>
<a name="ln2675">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln2676">	result_type</a>
<a name="ln2677">	operator()(_UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln2678">		   const param_type&amp; __p)</a>
<a name="ln2679">        {</a>
<a name="ln2680">	  typedef typename std::gamma_distribution&lt;result_type&gt;::param_type</a>
<a name="ln2681">	    param_type;</a>
<a name="ln2682">	  return 2 * _M_gd(__urng, param_type(__p.n() / 2));</a>
<a name="ln2683">	}</a>
<a name="ln2684"> </a>
<a name="ln2685">      template&lt;typename _ForwardIterator,</a>
<a name="ln2686">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln2687">	void</a>
<a name="ln2688">	__generate(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln2689">		   _UniformRandomNumberGenerator&amp; __urng)</a>
<a name="ln2690">        { this-&gt;__generate_impl(__f, __t, __urng); }</a>
<a name="ln2691"> </a>
<a name="ln2692">      template&lt;typename _ForwardIterator,</a>
<a name="ln2693">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln2694">	void</a>
<a name="ln2695">	__generate(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln2696">		   _UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln2697">		   const param_type&amp; __p)</a>
<a name="ln2698">	{ typename std::gamma_distribution&lt;result_type&gt;::param_type</a>
<a name="ln2699">	    __p2(__p.n() / 2);</a>
<a name="ln2700">	  this-&gt;__generate_impl(__f, __t, __urng, __p2); }</a>
<a name="ln2701"> </a>
<a name="ln2702">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln2703">	void</a>
<a name="ln2704">	__generate(result_type* __f, result_type* __t,</a>
<a name="ln2705">		   _UniformRandomNumberGenerator&amp; __urng)</a>
<a name="ln2706">        { this-&gt;__generate_impl(__f, __t, __urng); }</a>
<a name="ln2707"> </a>
<a name="ln2708">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln2709">	void</a>
<a name="ln2710">	__generate(result_type* __f, result_type* __t,</a>
<a name="ln2711">		   _UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln2712">		   const param_type&amp; __p)</a>
<a name="ln2713">	{ typename std::gamma_distribution&lt;result_type&gt;::param_type</a>
<a name="ln2714">	    __p2(__p.n() / 2);</a>
<a name="ln2715">	  this-&gt;__generate_impl(__f, __t, __urng, __p2); }</a>
<a name="ln2716"> </a>
<a name="ln2717">      /**</a>
<a name="ln2718">       * @brief Return true if two Chi-squared distributions have</a>
<a name="ln2719">       *        the same parameters and the sequences that would be</a>
<a name="ln2720">       *        generated are equal.</a>
<a name="ln2721">       */</a>
<a name="ln2722">      friend bool</a>
<a name="ln2723">      operator==(const chi_squared_distribution&amp; __d1,</a>
<a name="ln2724">		 const chi_squared_distribution&amp; __d2)</a>
<a name="ln2725">      { return __d1._M_param == __d2._M_param &amp;&amp; __d1._M_gd == __d2._M_gd; }</a>
<a name="ln2726"> </a>
<a name="ln2727">      /**</a>
<a name="ln2728">       * @brief Inserts a %chi_squared_distribution random number distribution</a>
<a name="ln2729">       * @p __x into the output stream @p __os.</a>
<a name="ln2730">       *</a>
<a name="ln2731">       * @param __os An output stream.</a>
<a name="ln2732">       * @param __x  A %chi_squared_distribution random number distribution.</a>
<a name="ln2733">       *</a>
<a name="ln2734">       * @returns The output stream with the state of @p __x inserted or in</a>
<a name="ln2735">       * an error state.</a>
<a name="ln2736">       */</a>
<a name="ln2737">      template&lt;typename _RealType1, typename _CharT, typename _Traits&gt;</a>
<a name="ln2738">	friend std::basic_ostream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln2739">	operator&lt;&lt;(std::basic_ostream&lt;_CharT, _Traits&gt;&amp; __os,</a>
<a name="ln2740">		   const std::chi_squared_distribution&lt;_RealType1&gt;&amp; __x);</a>
<a name="ln2741"> </a>
<a name="ln2742">      /**</a>
<a name="ln2743">       * @brief Extracts a %chi_squared_distribution random number distribution</a>
<a name="ln2744">       * @p __x from the input stream @p __is.</a>
<a name="ln2745">       *</a>
<a name="ln2746">       * @param __is An input stream.</a>
<a name="ln2747">       * @param __x A %chi_squared_distribution random number</a>
<a name="ln2748">       *            generator engine.</a>
<a name="ln2749">       *</a>
<a name="ln2750">       * @returns The input stream with @p __x extracted or in an error state.</a>
<a name="ln2751">       */</a>
<a name="ln2752">      template&lt;typename _RealType1, typename _CharT, typename _Traits&gt;</a>
<a name="ln2753">	friend std::basic_istream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln2754">	operator&gt;&gt;(std::basic_istream&lt;_CharT, _Traits&gt;&amp; __is,</a>
<a name="ln2755">		   std::chi_squared_distribution&lt;_RealType1&gt;&amp; __x);</a>
<a name="ln2756"> </a>
<a name="ln2757">    private:</a>
<a name="ln2758">      template&lt;typename _ForwardIterator,</a>
<a name="ln2759">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln2760">	void</a>
<a name="ln2761">	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln2762">			_UniformRandomNumberGenerator&amp; __urng);</a>
<a name="ln2763"> </a>
<a name="ln2764">      template&lt;typename _ForwardIterator,</a>
<a name="ln2765">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln2766">	void</a>
<a name="ln2767">	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln2768">			_UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln2769">			const typename</a>
<a name="ln2770">			std::gamma_distribution&lt;result_type&gt;::param_type&amp; __p);</a>
<a name="ln2771"> </a>
<a name="ln2772">      param_type _M_param;</a>
<a name="ln2773"> </a>
<a name="ln2774">      std::gamma_distribution&lt;result_type&gt; _M_gd;</a>
<a name="ln2775">    };</a>
<a name="ln2776"> </a>
<a name="ln2777">  /**</a>
<a name="ln2778">   * @brief Return true if two Chi-squared distributions are different.</a>
<a name="ln2779">   */</a>
<a name="ln2780">  template&lt;typename _RealType&gt;</a>
<a name="ln2781">    inline bool</a>
<a name="ln2782">    operator!=(const std::chi_squared_distribution&lt;_RealType&gt;&amp; __d1,</a>
<a name="ln2783">	       const std::chi_squared_distribution&lt;_RealType&gt;&amp; __d2)</a>
<a name="ln2784">    { return !(__d1 == __d2); }</a>
<a name="ln2785"> </a>
<a name="ln2786"> </a>
<a name="ln2787">  /**</a>
<a name="ln2788">   * @brief A cauchy_distribution random number distribution.</a>
<a name="ln2789">   *</a>
<a name="ln2790">   * The formula for the normal probability mass function is</a>
<a name="ln2791">   * @f$p(x|a,b) = (\pi b (1 + (\frac{x-a}{b})^2))^{-1}@f$</a>
<a name="ln2792">   */</a>
<a name="ln2793">  template&lt;typename _RealType = double&gt;</a>
<a name="ln2794">    class cauchy_distribution</a>
<a name="ln2795">    {</a>
<a name="ln2796">      static_assert(std::is_floating_point&lt;_RealType&gt;::value,</a>
<a name="ln2797">		    &quot;result_type must be a floating point type&quot;);</a>
<a name="ln2798"> </a>
<a name="ln2799">    public:</a>
<a name="ln2800">      /** The type of the range of the distribution. */</a>
<a name="ln2801">      typedef _RealType result_type;</a>
<a name="ln2802"> </a>
<a name="ln2803">      /** Parameter type. */</a>
<a name="ln2804">      struct param_type</a>
<a name="ln2805">      {</a>
<a name="ln2806">	typedef cauchy_distribution&lt;_RealType&gt; distribution_type;</a>
<a name="ln2807"> </a>
<a name="ln2808">	explicit</a>
<a name="ln2809">	param_type(_RealType __a = _RealType(0),</a>
<a name="ln2810">		   _RealType __b = _RealType(1))</a>
<a name="ln2811">	: _M_a(__a), _M_b(__b)</a>
<a name="ln2812">	{ }</a>
<a name="ln2813"> </a>
<a name="ln2814">	_RealType</a>
<a name="ln2815">	a() const</a>
<a name="ln2816">	{ return _M_a; }</a>
<a name="ln2817"> </a>
<a name="ln2818">	_RealType</a>
<a name="ln2819">	b() const</a>
<a name="ln2820">	{ return _M_b; }</a>
<a name="ln2821"> </a>
<a name="ln2822">	friend bool</a>
<a name="ln2823">	operator==(const param_type&amp; __p1, const param_type&amp; __p2)</a>
<a name="ln2824">	{ return __p1._M_a == __p2._M_a &amp;&amp; __p1._M_b == __p2._M_b; }</a>
<a name="ln2825"> </a>
<a name="ln2826">	friend bool</a>
<a name="ln2827">	operator!=(const param_type&amp; __p1, const param_type&amp; __p2)</a>
<a name="ln2828">	{ return !(__p1 == __p2); }</a>
<a name="ln2829"> </a>
<a name="ln2830">      private:</a>
<a name="ln2831">	_RealType _M_a;</a>
<a name="ln2832">	_RealType _M_b;</a>
<a name="ln2833">      };</a>
<a name="ln2834"> </a>
<a name="ln2835">      explicit</a>
<a name="ln2836">      cauchy_distribution(_RealType __a = _RealType(0),</a>
<a name="ln2837">			  _RealType __b = _RealType(1))</a>
<a name="ln2838">      : _M_param(__a, __b)</a>
<a name="ln2839">      { }</a>
<a name="ln2840"> </a>
<a name="ln2841">      explicit</a>
<a name="ln2842">      cauchy_distribution(const param_type&amp; __p)</a>
<a name="ln2843">      : _M_param(__p)</a>
<a name="ln2844">      { }</a>
<a name="ln2845"> </a>
<a name="ln2846">      /**</a>
<a name="ln2847">       * @brief Resets the distribution state.</a>
<a name="ln2848">       */</a>
<a name="ln2849">      void</a>
<a name="ln2850">      reset()</a>
<a name="ln2851">      { }</a>
<a name="ln2852"> </a>
<a name="ln2853">      /**</a>
<a name="ln2854">       *</a>
<a name="ln2855">       */</a>
<a name="ln2856">      _RealType</a>
<a name="ln2857">      a() const</a>
<a name="ln2858">      { return _M_param.a(); }</a>
<a name="ln2859"> </a>
<a name="ln2860">      _RealType</a>
<a name="ln2861">      b() const</a>
<a name="ln2862">      { return _M_param.b(); }</a>
<a name="ln2863"> </a>
<a name="ln2864">      /**</a>
<a name="ln2865">       * @brief Returns the parameter set of the distribution.</a>
<a name="ln2866">       */</a>
<a name="ln2867">      param_type</a>
<a name="ln2868">      param() const</a>
<a name="ln2869">      { return _M_param; }</a>
<a name="ln2870"> </a>
<a name="ln2871">      /**</a>
<a name="ln2872">       * @brief Sets the parameter set of the distribution.</a>
<a name="ln2873">       * @param __param The new parameter set of the distribution.</a>
<a name="ln2874">       */</a>
<a name="ln2875">      void</a>
<a name="ln2876">      param(const param_type&amp; __param)</a>
<a name="ln2877">      { _M_param = __param; }</a>
<a name="ln2878"> </a>
<a name="ln2879">      /**</a>
<a name="ln2880">       * @brief Returns the greatest lower bound value of the distribution.</a>
<a name="ln2881">       */</a>
<a name="ln2882">      result_type</a>
<a name="ln2883">      min() const</a>
<a name="ln2884">      { return std::numeric_limits&lt;result_type&gt;::lowest(); }</a>
<a name="ln2885"> </a>
<a name="ln2886">      /**</a>
<a name="ln2887">       * @brief Returns the least upper bound value of the distribution.</a>
<a name="ln2888">       */</a>
<a name="ln2889">      result_type</a>
<a name="ln2890">      max() const</a>
<a name="ln2891">      { return std::numeric_limits&lt;result_type&gt;::max(); }</a>
<a name="ln2892"> </a>
<a name="ln2893">      /**</a>
<a name="ln2894">       * @brief Generating functions.</a>
<a name="ln2895">       */</a>
<a name="ln2896">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln2897">	result_type</a>
<a name="ln2898">	operator()(_UniformRandomNumberGenerator&amp; __urng)</a>
<a name="ln2899">	{ return this-&gt;operator()(__urng, _M_param); }</a>
<a name="ln2900"> </a>
<a name="ln2901">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln2902">	result_type</a>
<a name="ln2903">	operator()(_UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln2904">		   const param_type&amp; __p);</a>
<a name="ln2905"> </a>
<a name="ln2906">      template&lt;typename _ForwardIterator,</a>
<a name="ln2907">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln2908">	void</a>
<a name="ln2909">	__generate(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln2910">		   _UniformRandomNumberGenerator&amp; __urng)</a>
<a name="ln2911">	{ this-&gt;__generate(__f, __t, __urng, _M_param); }</a>
<a name="ln2912"> </a>
<a name="ln2913">      template&lt;typename _ForwardIterator,</a>
<a name="ln2914">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln2915">	void</a>
<a name="ln2916">	__generate(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln2917">		   _UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln2918">		   const param_type&amp; __p)</a>
<a name="ln2919">	{ this-&gt;__generate_impl(__f, __t, __urng, __p); }</a>
<a name="ln2920"> </a>
<a name="ln2921">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln2922">	void</a>
<a name="ln2923">	__generate(result_type* __f, result_type* __t,</a>
<a name="ln2924">		   _UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln2925">		   const param_type&amp; __p)</a>
<a name="ln2926">	{ this-&gt;__generate_impl(__f, __t, __urng, __p); }</a>
<a name="ln2927"> </a>
<a name="ln2928">      /**</a>
<a name="ln2929">       * @brief Return true if two Cauchy distributions have</a>
<a name="ln2930">       *        the same parameters.</a>
<a name="ln2931">       */</a>
<a name="ln2932">      friend bool</a>
<a name="ln2933">      operator==(const cauchy_distribution&amp; __d1,</a>
<a name="ln2934">		 const cauchy_distribution&amp; __d2)</a>
<a name="ln2935">      { return __d1._M_param == __d2._M_param; }</a>
<a name="ln2936"> </a>
<a name="ln2937">    private:</a>
<a name="ln2938">      template&lt;typename _ForwardIterator,</a>
<a name="ln2939">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln2940">	void</a>
<a name="ln2941">	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln2942">			_UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln2943">			const param_type&amp; __p);</a>
<a name="ln2944"> </a>
<a name="ln2945">      param_type _M_param;</a>
<a name="ln2946">    };</a>
<a name="ln2947"> </a>
<a name="ln2948">  /**</a>
<a name="ln2949">   * @brief Return true if two Cauchy distributions have</a>
<a name="ln2950">   *        different parameters.</a>
<a name="ln2951">   */</a>
<a name="ln2952">  template&lt;typename _RealType&gt;</a>
<a name="ln2953">    inline bool</a>
<a name="ln2954">    operator!=(const std::cauchy_distribution&lt;_RealType&gt;&amp; __d1,</a>
<a name="ln2955">	       const std::cauchy_distribution&lt;_RealType&gt;&amp; __d2)</a>
<a name="ln2956">    { return !(__d1 == __d2); }</a>
<a name="ln2957"> </a>
<a name="ln2958">  /**</a>
<a name="ln2959">   * @brief Inserts a %cauchy_distribution random number distribution</a>
<a name="ln2960">   * @p __x into the output stream @p __os.</a>
<a name="ln2961">   *</a>
<a name="ln2962">   * @param __os An output stream.</a>
<a name="ln2963">   * @param __x  A %cauchy_distribution random number distribution.</a>
<a name="ln2964">   *</a>
<a name="ln2965">   * @returns The output stream with the state of @p __x inserted or in</a>
<a name="ln2966">   * an error state.</a>
<a name="ln2967">   */</a>
<a name="ln2968">  template&lt;typename _RealType, typename _CharT, typename _Traits&gt;</a>
<a name="ln2969">    std::basic_ostream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln2970">    operator&lt;&lt;(std::basic_ostream&lt;_CharT, _Traits&gt;&amp; __os,</a>
<a name="ln2971">	       const std::cauchy_distribution&lt;_RealType&gt;&amp; __x);</a>
<a name="ln2972"> </a>
<a name="ln2973">  /**</a>
<a name="ln2974">   * @brief Extracts a %cauchy_distribution random number distribution</a>
<a name="ln2975">   * @p __x from the input stream @p __is.</a>
<a name="ln2976">   *</a>
<a name="ln2977">   * @param __is An input stream.</a>
<a name="ln2978">   * @param __x A %cauchy_distribution random number</a>
<a name="ln2979">   *            generator engine.</a>
<a name="ln2980">   *</a>
<a name="ln2981">   * @returns The input stream with @p __x extracted or in an error state.</a>
<a name="ln2982">   */</a>
<a name="ln2983">  template&lt;typename _RealType, typename _CharT, typename _Traits&gt;</a>
<a name="ln2984">    std::basic_istream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln2985">    operator&gt;&gt;(std::basic_istream&lt;_CharT, _Traits&gt;&amp; __is,</a>
<a name="ln2986">	       std::cauchy_distribution&lt;_RealType&gt;&amp; __x);</a>
<a name="ln2987"> </a>
<a name="ln2988"> </a>
<a name="ln2989">  /**</a>
<a name="ln2990">   * @brief A fisher_f_distribution random number distribution.</a>
<a name="ln2991">   *</a>
<a name="ln2992">   * The formula for the normal probability mass function is</a>
<a name="ln2993">   * @f[</a>
<a name="ln2994">   *     p(x|m,n) = \frac{\Gamma((m+n)/2)}{\Gamma(m/2)\Gamma(n/2)}</a>
<a name="ln2995">   *                (\frac{m}{n})^{m/2} x^{(m/2)-1}</a>
<a name="ln2996">   *                (1 + \frac{mx}{n})^{-(m+n)/2} </a>
<a name="ln2997">   * @f]</a>
<a name="ln2998">   */</a>
<a name="ln2999">  template&lt;typename _RealType = double&gt;</a>
<a name="ln3000">    class fisher_f_distribution</a>
<a name="ln3001">    {</a>
<a name="ln3002">      static_assert(std::is_floating_point&lt;_RealType&gt;::value,</a>
<a name="ln3003">		    &quot;result_type must be a floating point type&quot;);</a>
<a name="ln3004"> </a>
<a name="ln3005">    public:</a>
<a name="ln3006">      /** The type of the range of the distribution. */</a>
<a name="ln3007">      typedef _RealType result_type;</a>
<a name="ln3008"> </a>
<a name="ln3009">      /** Parameter type. */</a>
<a name="ln3010">      struct param_type</a>
<a name="ln3011">      {</a>
<a name="ln3012">	typedef fisher_f_distribution&lt;_RealType&gt; distribution_type;</a>
<a name="ln3013"> </a>
<a name="ln3014">	explicit</a>
<a name="ln3015">	param_type(_RealType __m = _RealType(1),</a>
<a name="ln3016">		   _RealType __n = _RealType(1))</a>
<a name="ln3017">	: _M_m(__m), _M_n(__n)</a>
<a name="ln3018">	{ }</a>
<a name="ln3019"> </a>
<a name="ln3020">	_RealType</a>
<a name="ln3021">	m() const</a>
<a name="ln3022">	{ return _M_m; }</a>
<a name="ln3023"> </a>
<a name="ln3024">	_RealType</a>
<a name="ln3025">	n() const</a>
<a name="ln3026">	{ return _M_n; }</a>
<a name="ln3027"> </a>
<a name="ln3028">	friend bool</a>
<a name="ln3029">	operator==(const param_type&amp; __p1, const param_type&amp; __p2)</a>
<a name="ln3030">	{ return __p1._M_m == __p2._M_m &amp;&amp; __p1._M_n == __p2._M_n; }</a>
<a name="ln3031"> </a>
<a name="ln3032">	friend bool</a>
<a name="ln3033">	operator!=(const param_type&amp; __p1, const param_type&amp; __p2)</a>
<a name="ln3034">	{ return !(__p1 == __p2); }</a>
<a name="ln3035"> </a>
<a name="ln3036">      private:</a>
<a name="ln3037">	_RealType _M_m;</a>
<a name="ln3038">	_RealType _M_n;</a>
<a name="ln3039">      };</a>
<a name="ln3040"> </a>
<a name="ln3041">      explicit</a>
<a name="ln3042">      fisher_f_distribution(_RealType __m = _RealType(1),</a>
<a name="ln3043">			    _RealType __n = _RealType(1))</a>
<a name="ln3044">      : _M_param(__m, __n), _M_gd_x(__m / 2), _M_gd_y(__n / 2)</a>
<a name="ln3045">      { }</a>
<a name="ln3046"> </a>
<a name="ln3047">      explicit</a>
<a name="ln3048">      fisher_f_distribution(const param_type&amp; __p)</a>
<a name="ln3049">      : _M_param(__p), _M_gd_x(__p.m() / 2), _M_gd_y(__p.n() / 2)</a>
<a name="ln3050">      { }</a>
<a name="ln3051"> </a>
<a name="ln3052">      /**</a>
<a name="ln3053">       * @brief Resets the distribution state.</a>
<a name="ln3054">       */</a>
<a name="ln3055">      void</a>
<a name="ln3056">      reset()</a>
<a name="ln3057">      {</a>
<a name="ln3058">	_M_gd_x.reset();</a>
<a name="ln3059">	_M_gd_y.reset();</a>
<a name="ln3060">      }</a>
<a name="ln3061"> </a>
<a name="ln3062">      /**</a>
<a name="ln3063">       *</a>
<a name="ln3064">       */</a>
<a name="ln3065">      _RealType</a>
<a name="ln3066">      m() const</a>
<a name="ln3067">      { return _M_param.m(); }</a>
<a name="ln3068"> </a>
<a name="ln3069">      _RealType</a>
<a name="ln3070">      n() const</a>
<a name="ln3071">      { return _M_param.n(); }</a>
<a name="ln3072"> </a>
<a name="ln3073">      /**</a>
<a name="ln3074">       * @brief Returns the parameter set of the distribution.</a>
<a name="ln3075">       */</a>
<a name="ln3076">      param_type</a>
<a name="ln3077">      param() const</a>
<a name="ln3078">      { return _M_param; }</a>
<a name="ln3079"> </a>
<a name="ln3080">      /**</a>
<a name="ln3081">       * @brief Sets the parameter set of the distribution.</a>
<a name="ln3082">       * @param __param The new parameter set of the distribution.</a>
<a name="ln3083">       */</a>
<a name="ln3084">      void</a>
<a name="ln3085">      param(const param_type&amp; __param)</a>
<a name="ln3086">      { _M_param = __param; }</a>
<a name="ln3087"> </a>
<a name="ln3088">      /**</a>
<a name="ln3089">       * @brief Returns the greatest lower bound value of the distribution.</a>
<a name="ln3090">       */</a>
<a name="ln3091">      result_type</a>
<a name="ln3092">      min() const</a>
<a name="ln3093">      { return result_type(0); }</a>
<a name="ln3094"> </a>
<a name="ln3095">      /**</a>
<a name="ln3096">       * @brief Returns the least upper bound value of the distribution.</a>
<a name="ln3097">       */</a>
<a name="ln3098">      result_type</a>
<a name="ln3099">      max() const</a>
<a name="ln3100">      { return std::numeric_limits&lt;result_type&gt;::max(); }</a>
<a name="ln3101"> </a>
<a name="ln3102">      /**</a>
<a name="ln3103">       * @brief Generating functions.</a>
<a name="ln3104">       */</a>
<a name="ln3105">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln3106">	result_type</a>
<a name="ln3107">	operator()(_UniformRandomNumberGenerator&amp; __urng)</a>
<a name="ln3108">	{ return (_M_gd_x(__urng) * n()) / (_M_gd_y(__urng) * m()); }</a>
<a name="ln3109"> </a>
<a name="ln3110">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln3111">	result_type</a>
<a name="ln3112">	operator()(_UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln3113">		   const param_type&amp; __p)</a>
<a name="ln3114">        {</a>
<a name="ln3115">	  typedef typename std::gamma_distribution&lt;result_type&gt;::param_type</a>
<a name="ln3116">	    param_type;</a>
<a name="ln3117">	  return ((_M_gd_x(__urng, param_type(__p.m() / 2)) * n())</a>
<a name="ln3118">		  / (_M_gd_y(__urng, param_type(__p.n() / 2)) * m()));</a>
<a name="ln3119">	}</a>
<a name="ln3120"> </a>
<a name="ln3121">      template&lt;typename _ForwardIterator,</a>
<a name="ln3122">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln3123">	void</a>
<a name="ln3124">	__generate(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln3125">		   _UniformRandomNumberGenerator&amp; __urng)</a>
<a name="ln3126">	{ this-&gt;__generate_impl(__f, __t, __urng); }</a>
<a name="ln3127"> </a>
<a name="ln3128">      template&lt;typename _ForwardIterator,</a>
<a name="ln3129">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln3130">	void</a>
<a name="ln3131">	__generate(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln3132">		   _UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln3133">		   const param_type&amp; __p)</a>
<a name="ln3134">	{ this-&gt;__generate_impl(__f, __t, __urng, __p); }</a>
<a name="ln3135"> </a>
<a name="ln3136">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln3137">	void</a>
<a name="ln3138">	__generate(result_type* __f, result_type* __t,</a>
<a name="ln3139">		   _UniformRandomNumberGenerator&amp; __urng)</a>
<a name="ln3140">	{ this-&gt;__generate_impl(__f, __t, __urng); }</a>
<a name="ln3141"> </a>
<a name="ln3142">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln3143">	void</a>
<a name="ln3144">	__generate(result_type* __f, result_type* __t,</a>
<a name="ln3145">		   _UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln3146">		   const param_type&amp; __p)</a>
<a name="ln3147">	{ this-&gt;__generate_impl(__f, __t, __urng, __p); }</a>
<a name="ln3148"> </a>
<a name="ln3149">      /**</a>
<a name="ln3150">       * @brief Return true if two Fisher f distributions have</a>
<a name="ln3151">       *        the same parameters and the sequences that would</a>
<a name="ln3152">       *        be generated are equal.</a>
<a name="ln3153">       */</a>
<a name="ln3154">      friend bool</a>
<a name="ln3155">      operator==(const fisher_f_distribution&amp; __d1,</a>
<a name="ln3156">		 const fisher_f_distribution&amp; __d2)</a>
<a name="ln3157">      { return (__d1._M_param == __d2._M_param</a>
<a name="ln3158">		&amp;&amp; __d1._M_gd_x == __d2._M_gd_x</a>
<a name="ln3159">		&amp;&amp; __d1._M_gd_y == __d2._M_gd_y); }</a>
<a name="ln3160"> </a>
<a name="ln3161">      /**</a>
<a name="ln3162">       * @brief Inserts a %fisher_f_distribution random number distribution</a>
<a name="ln3163">       * @p __x into the output stream @p __os.</a>
<a name="ln3164">       *</a>
<a name="ln3165">       * @param __os An output stream.</a>
<a name="ln3166">       * @param __x  A %fisher_f_distribution random number distribution.</a>
<a name="ln3167">       *</a>
<a name="ln3168">       * @returns The output stream with the state of @p __x inserted or in</a>
<a name="ln3169">       * an error state.</a>
<a name="ln3170">       */</a>
<a name="ln3171">      template&lt;typename _RealType1, typename _CharT, typename _Traits&gt;</a>
<a name="ln3172">	friend std::basic_ostream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln3173">	operator&lt;&lt;(std::basic_ostream&lt;_CharT, _Traits&gt;&amp; __os,</a>
<a name="ln3174">		   const std::fisher_f_distribution&lt;_RealType1&gt;&amp; __x);</a>
<a name="ln3175"> </a>
<a name="ln3176">      /**</a>
<a name="ln3177">       * @brief Extracts a %fisher_f_distribution random number distribution</a>
<a name="ln3178">       * @p __x from the input stream @p __is.</a>
<a name="ln3179">       *</a>
<a name="ln3180">       * @param __is An input stream.</a>
<a name="ln3181">       * @param __x A %fisher_f_distribution random number</a>
<a name="ln3182">       *            generator engine.</a>
<a name="ln3183">       *</a>
<a name="ln3184">       * @returns The input stream with @p __x extracted or in an error state.</a>
<a name="ln3185">       */</a>
<a name="ln3186">      template&lt;typename _RealType1, typename _CharT, typename _Traits&gt;</a>
<a name="ln3187">	friend std::basic_istream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln3188">	operator&gt;&gt;(std::basic_istream&lt;_CharT, _Traits&gt;&amp; __is,</a>
<a name="ln3189">		   std::fisher_f_distribution&lt;_RealType1&gt;&amp; __x);</a>
<a name="ln3190"> </a>
<a name="ln3191">    private:</a>
<a name="ln3192">      template&lt;typename _ForwardIterator,</a>
<a name="ln3193">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln3194">	void</a>
<a name="ln3195">	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln3196">			_UniformRandomNumberGenerator&amp; __urng);</a>
<a name="ln3197"> </a>
<a name="ln3198">      template&lt;typename _ForwardIterator,</a>
<a name="ln3199">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln3200">	void</a>
<a name="ln3201">	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln3202">			_UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln3203">			const param_type&amp; __p);</a>
<a name="ln3204"> </a>
<a name="ln3205">      param_type _M_param;</a>
<a name="ln3206"> </a>
<a name="ln3207">      std::gamma_distribution&lt;result_type&gt; _M_gd_x, _M_gd_y;</a>
<a name="ln3208">    };</a>
<a name="ln3209"> </a>
<a name="ln3210">  /**</a>
<a name="ln3211">   * @brief Return true if two Fisher f distributions are different.</a>
<a name="ln3212">   */</a>
<a name="ln3213">  template&lt;typename _RealType&gt;</a>
<a name="ln3214">    inline bool</a>
<a name="ln3215">    operator!=(const std::fisher_f_distribution&lt;_RealType&gt;&amp; __d1,</a>
<a name="ln3216">	       const std::fisher_f_distribution&lt;_RealType&gt;&amp; __d2)</a>
<a name="ln3217">    { return !(__d1 == __d2); }</a>
<a name="ln3218"> </a>
<a name="ln3219">  /**</a>
<a name="ln3220">   * @brief A student_t_distribution random number distribution.</a>
<a name="ln3221">   *</a>
<a name="ln3222">   * The formula for the normal probability mass function is:</a>
<a name="ln3223">   * @f[</a>
<a name="ln3224">   *     p(x|n) = \frac{1}{\sqrt(n\pi)} \frac{\Gamma((n+1)/2)}{\Gamma(n/2)}</a>
<a name="ln3225">   *              (1 + \frac{x^2}{n}) ^{-(n+1)/2} </a>
<a name="ln3226">   * @f]</a>
<a name="ln3227">   */</a>
<a name="ln3228">  template&lt;typename _RealType = double&gt;</a>
<a name="ln3229">    class student_t_distribution</a>
<a name="ln3230">    {</a>
<a name="ln3231">      static_assert(std::is_floating_point&lt;_RealType&gt;::value,</a>
<a name="ln3232">		    &quot;result_type must be a floating point type&quot;);</a>
<a name="ln3233"> </a>
<a name="ln3234">    public:</a>
<a name="ln3235">      /** The type of the range of the distribution. */</a>
<a name="ln3236">      typedef _RealType result_type;</a>
<a name="ln3237"> </a>
<a name="ln3238">      /** Parameter type. */</a>
<a name="ln3239">      struct param_type</a>
<a name="ln3240">      {</a>
<a name="ln3241">	typedef student_t_distribution&lt;_RealType&gt; distribution_type;</a>
<a name="ln3242"> </a>
<a name="ln3243">	explicit</a>
<a name="ln3244">	param_type(_RealType __n = _RealType(1))</a>
<a name="ln3245">	: _M_n(__n)</a>
<a name="ln3246">	{ }</a>
<a name="ln3247"> </a>
<a name="ln3248">	_RealType</a>
<a name="ln3249">	n() const</a>
<a name="ln3250">	{ return _M_n; }</a>
<a name="ln3251"> </a>
<a name="ln3252">	friend bool</a>
<a name="ln3253">	operator==(const param_type&amp; __p1, const param_type&amp; __p2)</a>
<a name="ln3254">	{ return __p1._M_n == __p2._M_n; }</a>
<a name="ln3255"> </a>
<a name="ln3256">	friend bool</a>
<a name="ln3257">	operator!=(const param_type&amp; __p1, const param_type&amp; __p2)</a>
<a name="ln3258">	{ return !(__p1 == __p2); }</a>
<a name="ln3259"> </a>
<a name="ln3260">      private:</a>
<a name="ln3261">	_RealType _M_n;</a>
<a name="ln3262">      };</a>
<a name="ln3263"> </a>
<a name="ln3264">      explicit</a>
<a name="ln3265">      student_t_distribution(_RealType __n = _RealType(1))</a>
<a name="ln3266">      : _M_param(__n), _M_nd(), _M_gd(__n / 2, 2)</a>
<a name="ln3267">      { }</a>
<a name="ln3268"> </a>
<a name="ln3269">      explicit</a>
<a name="ln3270">      student_t_distribution(const param_type&amp; __p)</a>
<a name="ln3271">      : _M_param(__p), _M_nd(), _M_gd(__p.n() / 2, 2)</a>
<a name="ln3272">      { }</a>
<a name="ln3273"> </a>
<a name="ln3274">      /**</a>
<a name="ln3275">       * @brief Resets the distribution state.</a>
<a name="ln3276">       */</a>
<a name="ln3277">      void</a>
<a name="ln3278">      reset()</a>
<a name="ln3279">      {</a>
<a name="ln3280">	_M_nd.reset();</a>
<a name="ln3281">	_M_gd.reset();</a>
<a name="ln3282">      }</a>
<a name="ln3283"> </a>
<a name="ln3284">      /**</a>
<a name="ln3285">       *</a>
<a name="ln3286">       */</a>
<a name="ln3287">      _RealType</a>
<a name="ln3288">      n() const</a>
<a name="ln3289">      { return _M_param.n(); }</a>
<a name="ln3290"> </a>
<a name="ln3291">      /**</a>
<a name="ln3292">       * @brief Returns the parameter set of the distribution.</a>
<a name="ln3293">       */</a>
<a name="ln3294">      param_type</a>
<a name="ln3295">      param() const</a>
<a name="ln3296">      { return _M_param; }</a>
<a name="ln3297"> </a>
<a name="ln3298">      /**</a>
<a name="ln3299">       * @brief Sets the parameter set of the distribution.</a>
<a name="ln3300">       * @param __param The new parameter set of the distribution.</a>
<a name="ln3301">       */</a>
<a name="ln3302">      void</a>
<a name="ln3303">      param(const param_type&amp; __param)</a>
<a name="ln3304">      { _M_param = __param; }</a>
<a name="ln3305"> </a>
<a name="ln3306">      /**</a>
<a name="ln3307">       * @brief Returns the greatest lower bound value of the distribution.</a>
<a name="ln3308">       */</a>
<a name="ln3309">      result_type</a>
<a name="ln3310">      min() const</a>
<a name="ln3311">      { return std::numeric_limits&lt;result_type&gt;::lowest(); }</a>
<a name="ln3312"> </a>
<a name="ln3313">      /**</a>
<a name="ln3314">       * @brief Returns the least upper bound value of the distribution.</a>
<a name="ln3315">       */</a>
<a name="ln3316">      result_type</a>
<a name="ln3317">      max() const</a>
<a name="ln3318">      { return std::numeric_limits&lt;result_type&gt;::max(); }</a>
<a name="ln3319"> </a>
<a name="ln3320">      /**</a>
<a name="ln3321">       * @brief Generating functions.</a>
<a name="ln3322">       */</a>
<a name="ln3323">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln3324">	result_type</a>
<a name="ln3325">        operator()(_UniformRandomNumberGenerator&amp; __urng)</a>
<a name="ln3326">        { return _M_nd(__urng) * std::sqrt(n() / _M_gd(__urng)); }</a>
<a name="ln3327"> </a>
<a name="ln3328">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln3329">	result_type</a>
<a name="ln3330">	operator()(_UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln3331">		   const param_type&amp; __p)</a>
<a name="ln3332">        {</a>
<a name="ln3333">	  typedef typename std::gamma_distribution&lt;result_type&gt;::param_type</a>
<a name="ln3334">	    param_type;</a>
<a name="ln3335">	</a>
<a name="ln3336">	  const result_type __g = _M_gd(__urng, param_type(__p.n() / 2, 2));</a>
<a name="ln3337">	  return _M_nd(__urng) * std::sqrt(__p.n() / __g);</a>
<a name="ln3338">        }</a>
<a name="ln3339"> </a>
<a name="ln3340">      template&lt;typename _ForwardIterator,</a>
<a name="ln3341">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln3342">	void</a>
<a name="ln3343">	__generate(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln3344">		   _UniformRandomNumberGenerator&amp; __urng)</a>
<a name="ln3345">	{ this-&gt;__generate_impl(__f, __t, __urng); }</a>
<a name="ln3346"> </a>
<a name="ln3347">      template&lt;typename _ForwardIterator,</a>
<a name="ln3348">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln3349">	void</a>
<a name="ln3350">	__generate(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln3351">		   _UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln3352">		   const param_type&amp; __p)</a>
<a name="ln3353">	{ this-&gt;__generate_impl(__f, __t, __urng, __p); }</a>
<a name="ln3354"> </a>
<a name="ln3355">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln3356">	void</a>
<a name="ln3357">	__generate(result_type* __f, result_type* __t,</a>
<a name="ln3358">		   _UniformRandomNumberGenerator&amp; __urng)</a>
<a name="ln3359">	{ this-&gt;__generate_impl(__f, __t, __urng); }</a>
<a name="ln3360"> </a>
<a name="ln3361">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln3362">	void</a>
<a name="ln3363">	__generate(result_type* __f, result_type* __t,</a>
<a name="ln3364">		   _UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln3365">		   const param_type&amp; __p)</a>
<a name="ln3366">	{ this-&gt;__generate_impl(__f, __t, __urng, __p); }</a>
<a name="ln3367"> </a>
<a name="ln3368">      /**</a>
<a name="ln3369">       * @brief Return true if two Student t distributions have</a>
<a name="ln3370">       *        the same parameters and the sequences that would</a>
<a name="ln3371">       *        be generated are equal.</a>
<a name="ln3372">       */</a>
<a name="ln3373">      friend bool</a>
<a name="ln3374">      operator==(const student_t_distribution&amp; __d1,</a>
<a name="ln3375">		 const student_t_distribution&amp; __d2)</a>
<a name="ln3376">      { return (__d1._M_param == __d2._M_param</a>
<a name="ln3377">		&amp;&amp; __d1._M_nd == __d2._M_nd &amp;&amp; __d1._M_gd == __d2._M_gd); }</a>
<a name="ln3378"> </a>
<a name="ln3379">      /**</a>
<a name="ln3380">       * @brief Inserts a %student_t_distribution random number distribution</a>
<a name="ln3381">       * @p __x into the output stream @p __os.</a>
<a name="ln3382">       *</a>
<a name="ln3383">       * @param __os An output stream.</a>
<a name="ln3384">       * @param __x  A %student_t_distribution random number distribution.</a>
<a name="ln3385">       *</a>
<a name="ln3386">       * @returns The output stream with the state of @p __x inserted or in</a>
<a name="ln3387">       * an error state.</a>
<a name="ln3388">       */</a>
<a name="ln3389">      template&lt;typename _RealType1, typename _CharT, typename _Traits&gt;</a>
<a name="ln3390">	friend std::basic_ostream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln3391">	operator&lt;&lt;(std::basic_ostream&lt;_CharT, _Traits&gt;&amp; __os,</a>
<a name="ln3392">		   const std::student_t_distribution&lt;_RealType1&gt;&amp; __x);</a>
<a name="ln3393"> </a>
<a name="ln3394">      /**</a>
<a name="ln3395">       * @brief Extracts a %student_t_distribution random number distribution</a>
<a name="ln3396">       * @p __x from the input stream @p __is.</a>
<a name="ln3397">       *</a>
<a name="ln3398">       * @param __is An input stream.</a>
<a name="ln3399">       * @param __x A %student_t_distribution random number</a>
<a name="ln3400">       *            generator engine.</a>
<a name="ln3401">       *</a>
<a name="ln3402">       * @returns The input stream with @p __x extracted or in an error state.</a>
<a name="ln3403">       */</a>
<a name="ln3404">      template&lt;typename _RealType1, typename _CharT, typename _Traits&gt;</a>
<a name="ln3405">	friend std::basic_istream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln3406">	operator&gt;&gt;(std::basic_istream&lt;_CharT, _Traits&gt;&amp; __is,</a>
<a name="ln3407">		   std::student_t_distribution&lt;_RealType1&gt;&amp; __x);</a>
<a name="ln3408"> </a>
<a name="ln3409">    private:</a>
<a name="ln3410">      template&lt;typename _ForwardIterator,</a>
<a name="ln3411">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln3412">	void</a>
<a name="ln3413">	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln3414">			_UniformRandomNumberGenerator&amp; __urng);</a>
<a name="ln3415">      template&lt;typename _ForwardIterator,</a>
<a name="ln3416">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln3417">	void</a>
<a name="ln3418">	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln3419">			_UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln3420">			const param_type&amp; __p);</a>
<a name="ln3421"> </a>
<a name="ln3422">      param_type _M_param;</a>
<a name="ln3423"> </a>
<a name="ln3424">      std::normal_distribution&lt;result_type&gt; _M_nd;</a>
<a name="ln3425">      std::gamma_distribution&lt;result_type&gt; _M_gd;</a>
<a name="ln3426">    };</a>
<a name="ln3427"> </a>
<a name="ln3428">  /**</a>
<a name="ln3429">   * @brief Return true if two Student t distributions are different.</a>
<a name="ln3430">   */</a>
<a name="ln3431">  template&lt;typename _RealType&gt;</a>
<a name="ln3432">    inline bool</a>
<a name="ln3433">    operator!=(const std::student_t_distribution&lt;_RealType&gt;&amp; __d1,</a>
<a name="ln3434">	       const std::student_t_distribution&lt;_RealType&gt;&amp; __d2)</a>
<a name="ln3435">    { return !(__d1 == __d2); }</a>
<a name="ln3436"> </a>
<a name="ln3437"> </a>
<a name="ln3438">  /* @} */ // group random_distributions_normal</a>
<a name="ln3439"> </a>
<a name="ln3440">  /**</a>
<a name="ln3441">   * @addtogroup random_distributions_bernoulli Bernoulli Distributions</a>
<a name="ln3442">   * @ingroup random_distributions</a>
<a name="ln3443">   * @{</a>
<a name="ln3444">   */</a>
<a name="ln3445"> </a>
<a name="ln3446">  /**</a>
<a name="ln3447">   * @brief A Bernoulli random number distribution.</a>
<a name="ln3448">   *</a>
<a name="ln3449">   * Generates a sequence of true and false values with likelihood @f$p@f$</a>
<a name="ln3450">   * that true will come up and @f$(1 - p)@f$ that false will appear.</a>
<a name="ln3451">   */</a>
<a name="ln3452">  class bernoulli_distribution</a>
<a name="ln3453">  {</a>
<a name="ln3454">  public:</a>
<a name="ln3455">    /** The type of the range of the distribution. */</a>
<a name="ln3456">    typedef bool result_type;</a>
<a name="ln3457"> </a>
<a name="ln3458">    /** Parameter type. */</a>
<a name="ln3459">    struct param_type</a>
<a name="ln3460">    {</a>
<a name="ln3461">      typedef bernoulli_distribution distribution_type;</a>
<a name="ln3462"> </a>
<a name="ln3463">      explicit</a>
<a name="ln3464">      param_type(double __p = 0.5)</a>
<a name="ln3465">      : _M_p(__p)</a>
<a name="ln3466">      {</a>
<a name="ln3467">	__glibcxx_assert((_M_p &gt;= 0.0) &amp;&amp; (_M_p &lt;= 1.0));</a>
<a name="ln3468">      }</a>
<a name="ln3469"> </a>
<a name="ln3470">      double</a>
<a name="ln3471">      p() const</a>
<a name="ln3472">      { return _M_p; }</a>
<a name="ln3473"> </a>
<a name="ln3474">      friend bool</a>
<a name="ln3475">      operator==(const param_type&amp; __p1, const param_type&amp; __p2)</a>
<a name="ln3476">      { return __p1._M_p == __p2._M_p; }</a>
<a name="ln3477"> </a>
<a name="ln3478">      friend bool</a>
<a name="ln3479">      operator!=(const param_type&amp; __p1, const param_type&amp; __p2)</a>
<a name="ln3480">      { return !(__p1 == __p2); }</a>
<a name="ln3481"> </a>
<a name="ln3482">    private:</a>
<a name="ln3483">      double _M_p;</a>
<a name="ln3484">    };</a>
<a name="ln3485"> </a>
<a name="ln3486">  public:</a>
<a name="ln3487">    /**</a>
<a name="ln3488">     * @brief Constructs a Bernoulli distribution with likelihood @p p.</a>
<a name="ln3489">     *</a>
<a name="ln3490">     * @param __p  [IN]  The likelihood of a true result being returned.</a>
<a name="ln3491">     *                   Must be in the interval @f$[0, 1]@f$.</a>
<a name="ln3492">     */</a>
<a name="ln3493">    explicit</a>
<a name="ln3494">    bernoulli_distribution(double __p = 0.5)</a>
<a name="ln3495">    : _M_param(__p)</a>
<a name="ln3496">    { }</a>
<a name="ln3497"> </a>
<a name="ln3498">    explicit</a>
<a name="ln3499">    bernoulli_distribution(const param_type&amp; __p)</a>
<a name="ln3500">    : _M_param(__p)</a>
<a name="ln3501">    { }</a>
<a name="ln3502"> </a>
<a name="ln3503">    /**</a>
<a name="ln3504">     * @brief Resets the distribution state.</a>
<a name="ln3505">     *</a>
<a name="ln3506">     * Does nothing for a Bernoulli distribution.</a>
<a name="ln3507">     */</a>
<a name="ln3508">    void</a>
<a name="ln3509">    reset() { }</a>
<a name="ln3510"> </a>
<a name="ln3511">    /**</a>
<a name="ln3512">     * @brief Returns the @p p parameter of the distribution.</a>
<a name="ln3513">     */</a>
<a name="ln3514">    double</a>
<a name="ln3515">    p() const</a>
<a name="ln3516">    { return _M_param.p(); }</a>
<a name="ln3517"> </a>
<a name="ln3518">    /**</a>
<a name="ln3519">     * @brief Returns the parameter set of the distribution.</a>
<a name="ln3520">     */</a>
<a name="ln3521">    param_type</a>
<a name="ln3522">    param() const</a>
<a name="ln3523">    { return _M_param; }</a>
<a name="ln3524"> </a>
<a name="ln3525">    /**</a>
<a name="ln3526">     * @brief Sets the parameter set of the distribution.</a>
<a name="ln3527">     * @param __param The new parameter set of the distribution.</a>
<a name="ln3528">     */</a>
<a name="ln3529">    void</a>
<a name="ln3530">    param(const param_type&amp; __param)</a>
<a name="ln3531">    { _M_param = __param; }</a>
<a name="ln3532"> </a>
<a name="ln3533">    /**</a>
<a name="ln3534">     * @brief Returns the greatest lower bound value of the distribution.</a>
<a name="ln3535">     */</a>
<a name="ln3536">    result_type</a>
<a name="ln3537">    min() const</a>
<a name="ln3538">    { return std::numeric_limits&lt;result_type&gt;::min(); }</a>
<a name="ln3539"> </a>
<a name="ln3540">    /**</a>
<a name="ln3541">     * @brief Returns the least upper bound value of the distribution.</a>
<a name="ln3542">     */</a>
<a name="ln3543">    result_type</a>
<a name="ln3544">    max() const</a>
<a name="ln3545">    { return std::numeric_limits&lt;result_type&gt;::max(); }</a>
<a name="ln3546"> </a>
<a name="ln3547">    /**</a>
<a name="ln3548">     * @brief Generating functions.</a>
<a name="ln3549">     */</a>
<a name="ln3550">    template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln3551">      result_type</a>
<a name="ln3552">      operator()(_UniformRandomNumberGenerator&amp; __urng)</a>
<a name="ln3553">      { return this-&gt;operator()(__urng, _M_param); }</a>
<a name="ln3554"> </a>
<a name="ln3555">    template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln3556">      result_type</a>
<a name="ln3557">      operator()(_UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln3558">		 const param_type&amp; __p)</a>
<a name="ln3559">      {</a>
<a name="ln3560">	__detail::_Adaptor&lt;_UniformRandomNumberGenerator, double&gt;</a>
<a name="ln3561">	  __aurng(__urng);</a>
<a name="ln3562">	if ((__aurng() - __aurng.min())</a>
<a name="ln3563">	     &lt; __p.p() * (__aurng.max() - __aurng.min()))</a>
<a name="ln3564">	  return true;</a>
<a name="ln3565">	return false;</a>
<a name="ln3566">      }</a>
<a name="ln3567"> </a>
<a name="ln3568">    template&lt;typename _ForwardIterator,</a>
<a name="ln3569">	     typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln3570">      void</a>
<a name="ln3571">      __generate(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln3572">		 _UniformRandomNumberGenerator&amp; __urng)</a>
<a name="ln3573">      { this-&gt;__generate(__f, __t, __urng, _M_param); }</a>
<a name="ln3574"> </a>
<a name="ln3575">    template&lt;typename _ForwardIterator,</a>
<a name="ln3576">	     typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln3577">      void</a>
<a name="ln3578">      __generate(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln3579">		 _UniformRandomNumberGenerator&amp; __urng, const param_type&amp; __p)</a>
<a name="ln3580">      { this-&gt;__generate_impl(__f, __t, __urng, __p); }</a>
<a name="ln3581"> </a>
<a name="ln3582">    template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln3583">      void</a>
<a name="ln3584">      __generate(result_type* __f, result_type* __t,</a>
<a name="ln3585">		 _UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln3586">		 const param_type&amp; __p)</a>
<a name="ln3587">      { this-&gt;__generate_impl(__f, __t, __urng, __p); }</a>
<a name="ln3588"> </a>
<a name="ln3589">    /**</a>
<a name="ln3590">     * @brief Return true if two Bernoulli distributions have</a>
<a name="ln3591">     *        the same parameters.</a>
<a name="ln3592">     */</a>
<a name="ln3593">    friend bool</a>
<a name="ln3594">    operator==(const bernoulli_distribution&amp; __d1,</a>
<a name="ln3595">	       const bernoulli_distribution&amp; __d2)</a>
<a name="ln3596">    { return __d1._M_param == __d2._M_param; }</a>
<a name="ln3597"> </a>
<a name="ln3598">  private:</a>
<a name="ln3599">    template&lt;typename _ForwardIterator,</a>
<a name="ln3600">	     typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln3601">      void</a>
<a name="ln3602">      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln3603">		      _UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln3604">		      const param_type&amp; __p);</a>
<a name="ln3605"> </a>
<a name="ln3606">    param_type _M_param;</a>
<a name="ln3607">  };</a>
<a name="ln3608"> </a>
<a name="ln3609">  /**</a>
<a name="ln3610">   * @brief Return true if two Bernoulli distributions have</a>
<a name="ln3611">   *        different parameters.</a>
<a name="ln3612">   */</a>
<a name="ln3613">  inline bool</a>
<a name="ln3614">  operator!=(const std::bernoulli_distribution&amp; __d1,</a>
<a name="ln3615">	     const std::bernoulli_distribution&amp; __d2)</a>
<a name="ln3616">  { return !(__d1 == __d2); }</a>
<a name="ln3617"> </a>
<a name="ln3618">  /**</a>
<a name="ln3619">   * @brief Inserts a %bernoulli_distribution random number distribution</a>
<a name="ln3620">   * @p __x into the output stream @p __os.</a>
<a name="ln3621">   *</a>
<a name="ln3622">   * @param __os An output stream.</a>
<a name="ln3623">   * @param __x  A %bernoulli_distribution random number distribution.</a>
<a name="ln3624">   *</a>
<a name="ln3625">   * @returns The output stream with the state of @p __x inserted or in</a>
<a name="ln3626">   * an error state.</a>
<a name="ln3627">   */</a>
<a name="ln3628">  template&lt;typename _CharT, typename _Traits&gt;</a>
<a name="ln3629">    std::basic_ostream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln3630">    operator&lt;&lt;(std::basic_ostream&lt;_CharT, _Traits&gt;&amp; __os,</a>
<a name="ln3631">	       const std::bernoulli_distribution&amp; __x);</a>
<a name="ln3632"> </a>
<a name="ln3633">  /**</a>
<a name="ln3634">   * @brief Extracts a %bernoulli_distribution random number distribution</a>
<a name="ln3635">   * @p __x from the input stream @p __is.</a>
<a name="ln3636">   *</a>
<a name="ln3637">   * @param __is An input stream.</a>
<a name="ln3638">   * @param __x  A %bernoulli_distribution random number generator engine.</a>
<a name="ln3639">   *</a>
<a name="ln3640">   * @returns The input stream with @p __x extracted or in an error state.</a>
<a name="ln3641">   */</a>
<a name="ln3642">  template&lt;typename _CharT, typename _Traits&gt;</a>
<a name="ln3643">    std::basic_istream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln3644">    operator&gt;&gt;(std::basic_istream&lt;_CharT, _Traits&gt;&amp; __is,</a>
<a name="ln3645">	       std::bernoulli_distribution&amp; __x)</a>
<a name="ln3646">    {</a>
<a name="ln3647">      double __p;</a>
<a name="ln3648">      __is &gt;&gt; __p;</a>
<a name="ln3649">      __x.param(bernoulli_distribution::param_type(__p));</a>
<a name="ln3650">      return __is;</a>
<a name="ln3651">    }</a>
<a name="ln3652"> </a>
<a name="ln3653"> </a>
<a name="ln3654">  /**</a>
<a name="ln3655">   * @brief A discrete binomial random number distribution.</a>
<a name="ln3656">   *</a>
<a name="ln3657">   * The formula for the binomial probability density function is</a>
<a name="ln3658">   * @f$p(i|t,p) = \binom{t}{i} p^i (1 - p)^{t - i}@f$ where @f$t@f$</a>
<a name="ln3659">   * and @f$p@f$ are the parameters of the distribution.</a>
<a name="ln3660">   */</a>
<a name="ln3661">  template&lt;typename _IntType = int&gt;</a>
<a name="ln3662">    class binomial_distribution</a>
<a name="ln3663">    {</a>
<a name="ln3664">      static_assert(std::is_integral&lt;_IntType&gt;::value,</a>
<a name="ln3665">		    &quot;result_type must be an integral type&quot;);</a>
<a name="ln3666"> </a>
<a name="ln3667">    public:</a>
<a name="ln3668">      /** The type of the range of the distribution. */</a>
<a name="ln3669">      typedef _IntType result_type;</a>
<a name="ln3670"> </a>
<a name="ln3671">      /** Parameter type. */</a>
<a name="ln3672">      struct param_type</a>
<a name="ln3673">      {</a>
<a name="ln3674">	typedef binomial_distribution&lt;_IntType&gt; distribution_type;</a>
<a name="ln3675">	friend class binomial_distribution&lt;_IntType&gt;;</a>
<a name="ln3676"> </a>
<a name="ln3677">	explicit</a>
<a name="ln3678">	param_type(_IntType __t = _IntType(1), double __p = 0.5)</a>
<a name="ln3679">	: _M_t(__t), _M_p(__p)</a>
<a name="ln3680">	{</a>
<a name="ln3681">	  __glibcxx_assert((_M_t &gt;= _IntType(0))</a>
<a name="ln3682">				&amp;&amp; (_M_p &gt;= 0.0)</a>
<a name="ln3683">				&amp;&amp; (_M_p &lt;= 1.0));</a>
<a name="ln3684">	  _M_initialize();</a>
<a name="ln3685">	}</a>
<a name="ln3686"> </a>
<a name="ln3687">	_IntType</a>
<a name="ln3688">	t() const</a>
<a name="ln3689">	{ return _M_t; }</a>
<a name="ln3690"> </a>
<a name="ln3691">	double</a>
<a name="ln3692">	p() const</a>
<a name="ln3693">	{ return _M_p; }</a>
<a name="ln3694"> </a>
<a name="ln3695">	friend bool</a>
<a name="ln3696">	operator==(const param_type&amp; __p1, const param_type&amp; __p2)</a>
<a name="ln3697">	{ return __p1._M_t == __p2._M_t &amp;&amp; __p1._M_p == __p2._M_p; }</a>
<a name="ln3698"> </a>
<a name="ln3699">	friend bool</a>
<a name="ln3700">	operator!=(const param_type&amp; __p1, const param_type&amp; __p2)</a>
<a name="ln3701">	{ return !(__p1 == __p2); }</a>
<a name="ln3702"> </a>
<a name="ln3703">      private:</a>
<a name="ln3704">	void</a>
<a name="ln3705">	_M_initialize();</a>
<a name="ln3706"> </a>
<a name="ln3707">	_IntType _M_t;</a>
<a name="ln3708">	double _M_p;</a>
<a name="ln3709"> </a>
<a name="ln3710">	double _M_q;</a>
<a name="ln3711">#if _GLIBCXX_USE_C99_MATH_TR1</a>
<a name="ln3712">	double _M_d1, _M_d2, _M_s1, _M_s2, _M_c,</a>
<a name="ln3713">	       _M_a1, _M_a123, _M_s, _M_lf, _M_lp1p;</a>
<a name="ln3714">#endif</a>
<a name="ln3715">	bool   _M_easy;</a>
<a name="ln3716">      };</a>
<a name="ln3717"> </a>
<a name="ln3718">      // constructors and member function</a>
<a name="ln3719">      explicit</a>
<a name="ln3720">      binomial_distribution(_IntType __t = _IntType(1),</a>
<a name="ln3721">			    double __p = 0.5)</a>
<a name="ln3722">      : _M_param(__t, __p), _M_nd()</a>
<a name="ln3723">      { }</a>
<a name="ln3724"> </a>
<a name="ln3725">      explicit</a>
<a name="ln3726">      binomial_distribution(const param_type&amp; __p)</a>
<a name="ln3727">      : _M_param(__p), _M_nd()</a>
<a name="ln3728">      { }</a>
<a name="ln3729"> </a>
<a name="ln3730">      /**</a>
<a name="ln3731">       * @brief Resets the distribution state.</a>
<a name="ln3732">       */</a>
<a name="ln3733">      void</a>
<a name="ln3734">      reset()</a>
<a name="ln3735">      { _M_nd.reset(); }</a>
<a name="ln3736"> </a>
<a name="ln3737">      /**</a>
<a name="ln3738">       * @brief Returns the distribution @p t parameter.</a>
<a name="ln3739">       */</a>
<a name="ln3740">      _IntType</a>
<a name="ln3741">      t() const</a>
<a name="ln3742">      { return _M_param.t(); }</a>
<a name="ln3743"> </a>
<a name="ln3744">      /**</a>
<a name="ln3745">       * @brief Returns the distribution @p p parameter.</a>
<a name="ln3746">       */</a>
<a name="ln3747">      double</a>
<a name="ln3748">      p() const</a>
<a name="ln3749">      { return _M_param.p(); }</a>
<a name="ln3750"> </a>
<a name="ln3751">      /**</a>
<a name="ln3752">       * @brief Returns the parameter set of the distribution.</a>
<a name="ln3753">       */</a>
<a name="ln3754">      param_type</a>
<a name="ln3755">      param() const</a>
<a name="ln3756">      { return _M_param; }</a>
<a name="ln3757"> </a>
<a name="ln3758">      /**</a>
<a name="ln3759">       * @brief Sets the parameter set of the distribution.</a>
<a name="ln3760">       * @param __param The new parameter set of the distribution.</a>
<a name="ln3761">       */</a>
<a name="ln3762">      void</a>
<a name="ln3763">      param(const param_type&amp; __param)</a>
<a name="ln3764">      { _M_param = __param; }</a>
<a name="ln3765"> </a>
<a name="ln3766">      /**</a>
<a name="ln3767">       * @brief Returns the greatest lower bound value of the distribution.</a>
<a name="ln3768">       */</a>
<a name="ln3769">      result_type</a>
<a name="ln3770">      min() const</a>
<a name="ln3771">      { return 0; }</a>
<a name="ln3772"> </a>
<a name="ln3773">      /**</a>
<a name="ln3774">       * @brief Returns the least upper bound value of the distribution.</a>
<a name="ln3775">       */</a>
<a name="ln3776">      result_type</a>
<a name="ln3777">      max() const</a>
<a name="ln3778">      { return _M_param.t(); }</a>
<a name="ln3779"> </a>
<a name="ln3780">      /**</a>
<a name="ln3781">       * @brief Generating functions.</a>
<a name="ln3782">       */</a>
<a name="ln3783">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln3784">	result_type</a>
<a name="ln3785">	operator()(_UniformRandomNumberGenerator&amp; __urng)</a>
<a name="ln3786">	{ return this-&gt;operator()(__urng, _M_param); }</a>
<a name="ln3787"> </a>
<a name="ln3788">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln3789">	result_type</a>
<a name="ln3790">	operator()(_UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln3791">		   const param_type&amp; __p);</a>
<a name="ln3792"> </a>
<a name="ln3793">      template&lt;typename _ForwardIterator,</a>
<a name="ln3794">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln3795">	void</a>
<a name="ln3796">	__generate(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln3797">		   _UniformRandomNumberGenerator&amp; __urng)</a>
<a name="ln3798">	{ this-&gt;__generate(__f, __t, __urng, _M_param); }</a>
<a name="ln3799"> </a>
<a name="ln3800">      template&lt;typename _ForwardIterator,</a>
<a name="ln3801">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln3802">	void</a>
<a name="ln3803">	__generate(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln3804">		   _UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln3805">		   const param_type&amp; __p)</a>
<a name="ln3806">	{ this-&gt;__generate_impl(__f, __t, __urng, __p); }</a>
<a name="ln3807"> </a>
<a name="ln3808">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln3809">	void</a>
<a name="ln3810">	__generate(result_type* __f, result_type* __t,</a>
<a name="ln3811">		   _UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln3812">		   const param_type&amp; __p)</a>
<a name="ln3813">	{ this-&gt;__generate_impl(__f, __t, __urng, __p); }</a>
<a name="ln3814"> </a>
<a name="ln3815">      /**</a>
<a name="ln3816">       * @brief Return true if two binomial distributions have</a>
<a name="ln3817">       *        the same parameters and the sequences that would</a>
<a name="ln3818">       *        be generated are equal.</a>
<a name="ln3819">       */</a>
<a name="ln3820">	friend bool</a>
<a name="ln3821">        operator==(const binomial_distribution&amp; __d1,</a>
<a name="ln3822">		   const binomial_distribution&amp; __d2)</a>
<a name="ln3823">#ifdef _GLIBCXX_USE_C99_MATH_TR1</a>
<a name="ln3824">	{ return __d1._M_param == __d2._M_param &amp;&amp; __d1._M_nd == __d2._M_nd; }</a>
<a name="ln3825">#else</a>
<a name="ln3826">        { return __d1._M_param == __d2._M_param; }</a>
<a name="ln3827">#endif</a>
<a name="ln3828"> </a>
<a name="ln3829">      /**</a>
<a name="ln3830">       * @brief Inserts a %binomial_distribution random number distribution</a>
<a name="ln3831">       * @p __x into the output stream @p __os.</a>
<a name="ln3832">       *</a>
<a name="ln3833">       * @param __os An output stream.</a>
<a name="ln3834">       * @param __x  A %binomial_distribution random number distribution.</a>
<a name="ln3835">       *</a>
<a name="ln3836">       * @returns The output stream with the state of @p __x inserted or in</a>
<a name="ln3837">       * an error state.</a>
<a name="ln3838">       */</a>
<a name="ln3839">      template&lt;typename _IntType1,</a>
<a name="ln3840">	       typename _CharT, typename _Traits&gt;</a>
<a name="ln3841">	friend std::basic_ostream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln3842">	operator&lt;&lt;(std::basic_ostream&lt;_CharT, _Traits&gt;&amp; __os,</a>
<a name="ln3843">		   const std::binomial_distribution&lt;_IntType1&gt;&amp; __x);</a>
<a name="ln3844"> </a>
<a name="ln3845">      /**</a>
<a name="ln3846">       * @brief Extracts a %binomial_distribution random number distribution</a>
<a name="ln3847">       * @p __x from the input stream @p __is.</a>
<a name="ln3848">       *</a>
<a name="ln3849">       * @param __is An input stream.</a>
<a name="ln3850">       * @param __x  A %binomial_distribution random number generator engine.</a>
<a name="ln3851">       *</a>
<a name="ln3852">       * @returns The input stream with @p __x extracted or in an error</a>
<a name="ln3853">       *          state.</a>
<a name="ln3854">       */</a>
<a name="ln3855">      template&lt;typename _IntType1,</a>
<a name="ln3856">	       typename _CharT, typename _Traits&gt;</a>
<a name="ln3857">	friend std::basic_istream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln3858">	operator&gt;&gt;(std::basic_istream&lt;_CharT, _Traits&gt;&amp; __is,</a>
<a name="ln3859">		   std::binomial_distribution&lt;_IntType1&gt;&amp; __x);</a>
<a name="ln3860"> </a>
<a name="ln3861">    private:</a>
<a name="ln3862">      template&lt;typename _ForwardIterator,</a>
<a name="ln3863">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln3864">	void</a>
<a name="ln3865">	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln3866">			_UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln3867">			const param_type&amp; __p);</a>
<a name="ln3868"> </a>
<a name="ln3869">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln3870">	result_type</a>
<a name="ln3871">	_M_waiting(_UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln3872">		   _IntType __t, double __q);</a>
<a name="ln3873"> </a>
<a name="ln3874">      param_type _M_param;</a>
<a name="ln3875"> </a>
<a name="ln3876">      // NB: Unused when _GLIBCXX_USE_C99_MATH_TR1 is undefined.</a>
<a name="ln3877">      std::normal_distribution&lt;double&gt; _M_nd;</a>
<a name="ln3878">    };</a>
<a name="ln3879"> </a>
<a name="ln3880">  /**</a>
<a name="ln3881">   * @brief Return true if two binomial distributions are different.</a>
<a name="ln3882">   */</a>
<a name="ln3883">  template&lt;typename _IntType&gt;</a>
<a name="ln3884">    inline bool</a>
<a name="ln3885">    operator!=(const std::binomial_distribution&lt;_IntType&gt;&amp; __d1,</a>
<a name="ln3886">	       const std::binomial_distribution&lt;_IntType&gt;&amp; __d2)</a>
<a name="ln3887">    { return !(__d1 == __d2); }</a>
<a name="ln3888"> </a>
<a name="ln3889"> </a>
<a name="ln3890">  /**</a>
<a name="ln3891">   * @brief A discrete geometric random number distribution.</a>
<a name="ln3892">   *</a>
<a name="ln3893">   * The formula for the geometric probability density function is</a>
<a name="ln3894">   * @f$p(i|p) = p(1 - p)^{i}@f$ where @f$p@f$ is the parameter of the</a>
<a name="ln3895">   * distribution.</a>
<a name="ln3896">   */</a>
<a name="ln3897">  template&lt;typename _IntType = int&gt;</a>
<a name="ln3898">    class geometric_distribution</a>
<a name="ln3899">    {</a>
<a name="ln3900">      static_assert(std::is_integral&lt;_IntType&gt;::value,</a>
<a name="ln3901">		    &quot;result_type must be an integral type&quot;);</a>
<a name="ln3902"> </a>
<a name="ln3903">    public:</a>
<a name="ln3904">      /** The type of the range of the distribution. */</a>
<a name="ln3905">      typedef _IntType  result_type;</a>
<a name="ln3906"> </a>
<a name="ln3907">      /** Parameter type. */</a>
<a name="ln3908">      struct param_type</a>
<a name="ln3909">      {</a>
<a name="ln3910">	typedef geometric_distribution&lt;_IntType&gt; distribution_type;</a>
<a name="ln3911">	friend class geometric_distribution&lt;_IntType&gt;;</a>
<a name="ln3912"> </a>
<a name="ln3913">	explicit</a>
<a name="ln3914">	param_type(double __p = 0.5)</a>
<a name="ln3915">	: _M_p(__p)</a>
<a name="ln3916">	{</a>
<a name="ln3917">	  __glibcxx_assert((_M_p &gt; 0.0) &amp;&amp; (_M_p &lt; 1.0));</a>
<a name="ln3918">	  _M_initialize();</a>
<a name="ln3919">	}</a>
<a name="ln3920"> </a>
<a name="ln3921">	double</a>
<a name="ln3922">	p() const</a>
<a name="ln3923">	{ return _M_p; }</a>
<a name="ln3924"> </a>
<a name="ln3925">	friend bool</a>
<a name="ln3926">	operator==(const param_type&amp; __p1, const param_type&amp; __p2)</a>
<a name="ln3927">	{ return __p1._M_p == __p2._M_p; }</a>
<a name="ln3928"> </a>
<a name="ln3929">	friend bool</a>
<a name="ln3930">	operator!=(const param_type&amp; __p1, const param_type&amp; __p2)</a>
<a name="ln3931">	{ return !(__p1 == __p2); }</a>
<a name="ln3932"> </a>
<a name="ln3933">      private:</a>
<a name="ln3934">	void</a>
<a name="ln3935">	_M_initialize()</a>
<a name="ln3936">	{ _M_log_1_p = std::log(1.0 - _M_p); }</a>
<a name="ln3937"> </a>
<a name="ln3938">	double _M_p;</a>
<a name="ln3939"> </a>
<a name="ln3940">	double _M_log_1_p;</a>
<a name="ln3941">      };</a>
<a name="ln3942"> </a>
<a name="ln3943">      // constructors and member function</a>
<a name="ln3944">      explicit</a>
<a name="ln3945">      geometric_distribution(double __p = 0.5)</a>
<a name="ln3946">      : _M_param(__p)</a>
<a name="ln3947">      { }</a>
<a name="ln3948"> </a>
<a name="ln3949">      explicit</a>
<a name="ln3950">      geometric_distribution(const param_type&amp; __p)</a>
<a name="ln3951">      : _M_param(__p)</a>
<a name="ln3952">      { }</a>
<a name="ln3953"> </a>
<a name="ln3954">      /**</a>
<a name="ln3955">       * @brief Resets the distribution state.</a>
<a name="ln3956">       *</a>
<a name="ln3957">       * Does nothing for the geometric distribution.</a>
<a name="ln3958">       */</a>
<a name="ln3959">      void</a>
<a name="ln3960">      reset() { }</a>
<a name="ln3961"> </a>
<a name="ln3962">      /**</a>
<a name="ln3963">       * @brief Returns the distribution parameter @p p.</a>
<a name="ln3964">       */</a>
<a name="ln3965">      double</a>
<a name="ln3966">      p() const</a>
<a name="ln3967">      { return _M_param.p(); }</a>
<a name="ln3968"> </a>
<a name="ln3969">      /**</a>
<a name="ln3970">       * @brief Returns the parameter set of the distribution.</a>
<a name="ln3971">       */</a>
<a name="ln3972">      param_type</a>
<a name="ln3973">      param() const</a>
<a name="ln3974">      { return _M_param; }</a>
<a name="ln3975"> </a>
<a name="ln3976">      /**</a>
<a name="ln3977">       * @brief Sets the parameter set of the distribution.</a>
<a name="ln3978">       * @param __param The new parameter set of the distribution.</a>
<a name="ln3979">       */</a>
<a name="ln3980">      void</a>
<a name="ln3981">      param(const param_type&amp; __param)</a>
<a name="ln3982">      { _M_param = __param; }</a>
<a name="ln3983"> </a>
<a name="ln3984">      /**</a>
<a name="ln3985">       * @brief Returns the greatest lower bound value of the distribution.</a>
<a name="ln3986">       */</a>
<a name="ln3987">      result_type</a>
<a name="ln3988">      min() const</a>
<a name="ln3989">      { return 0; }</a>
<a name="ln3990"> </a>
<a name="ln3991">      /**</a>
<a name="ln3992">       * @brief Returns the least upper bound value of the distribution.</a>
<a name="ln3993">       */</a>
<a name="ln3994">      result_type</a>
<a name="ln3995">      max() const</a>
<a name="ln3996">      { return std::numeric_limits&lt;result_type&gt;::max(); }</a>
<a name="ln3997"> </a>
<a name="ln3998">      /**</a>
<a name="ln3999">       * @brief Generating functions.</a>
<a name="ln4000">       */</a>
<a name="ln4001">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln4002">	result_type</a>
<a name="ln4003">	operator()(_UniformRandomNumberGenerator&amp; __urng)</a>
<a name="ln4004">	{ return this-&gt;operator()(__urng, _M_param); }</a>
<a name="ln4005"> </a>
<a name="ln4006">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln4007">	result_type</a>
<a name="ln4008">	operator()(_UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln4009">		   const param_type&amp; __p);</a>
<a name="ln4010"> </a>
<a name="ln4011">      template&lt;typename _ForwardIterator,</a>
<a name="ln4012">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln4013">	void</a>
<a name="ln4014">	__generate(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln4015">		   _UniformRandomNumberGenerator&amp; __urng)</a>
<a name="ln4016">	{ this-&gt;__generate(__f, __t, __urng, _M_param); }</a>
<a name="ln4017"> </a>
<a name="ln4018">      template&lt;typename _ForwardIterator,</a>
<a name="ln4019">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln4020">	void</a>
<a name="ln4021">	__generate(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln4022">		   _UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln4023">		   const param_type&amp; __p)</a>
<a name="ln4024">	{ this-&gt;__generate_impl(__f, __t, __urng, __p); }</a>
<a name="ln4025"> </a>
<a name="ln4026">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln4027">	void</a>
<a name="ln4028">	__generate(result_type* __f, result_type* __t,</a>
<a name="ln4029">		   _UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln4030">		   const param_type&amp; __p)</a>
<a name="ln4031">	{ this-&gt;__generate_impl(__f, __t, __urng, __p); }</a>
<a name="ln4032"> </a>
<a name="ln4033">      /**</a>
<a name="ln4034">       * @brief Return true if two geometric distributions have</a>
<a name="ln4035">       *        the same parameters.</a>
<a name="ln4036">       */</a>
<a name="ln4037">      friend bool</a>
<a name="ln4038">      operator==(const geometric_distribution&amp; __d1,</a>
<a name="ln4039">		 const geometric_distribution&amp; __d2)</a>
<a name="ln4040">      { return __d1._M_param == __d2._M_param; }</a>
<a name="ln4041"> </a>
<a name="ln4042">    private:</a>
<a name="ln4043">      template&lt;typename _ForwardIterator,</a>
<a name="ln4044">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln4045">	void</a>
<a name="ln4046">	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln4047">			_UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln4048">			const param_type&amp; __p);</a>
<a name="ln4049"> </a>
<a name="ln4050">      param_type _M_param;</a>
<a name="ln4051">    };</a>
<a name="ln4052"> </a>
<a name="ln4053">  /**</a>
<a name="ln4054">   * @brief Return true if two geometric distributions have</a>
<a name="ln4055">   *        different parameters.</a>
<a name="ln4056">   */</a>
<a name="ln4057">  template&lt;typename _IntType&gt;</a>
<a name="ln4058">    inline bool</a>
<a name="ln4059">    operator!=(const std::geometric_distribution&lt;_IntType&gt;&amp; __d1,</a>
<a name="ln4060">	       const std::geometric_distribution&lt;_IntType&gt;&amp; __d2)</a>
<a name="ln4061">    { return !(__d1 == __d2); }</a>
<a name="ln4062"> </a>
<a name="ln4063">  /**</a>
<a name="ln4064">   * @brief Inserts a %geometric_distribution random number distribution</a>
<a name="ln4065">   * @p __x into the output stream @p __os.</a>
<a name="ln4066">   *</a>
<a name="ln4067">   * @param __os An output stream.</a>
<a name="ln4068">   * @param __x  A %geometric_distribution random number distribution.</a>
<a name="ln4069">   *</a>
<a name="ln4070">   * @returns The output stream with the state of @p __x inserted or in</a>
<a name="ln4071">   * an error state.</a>
<a name="ln4072">   */</a>
<a name="ln4073">  template&lt;typename _IntType,</a>
<a name="ln4074">	   typename _CharT, typename _Traits&gt;</a>
<a name="ln4075">    std::basic_ostream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln4076">    operator&lt;&lt;(std::basic_ostream&lt;_CharT, _Traits&gt;&amp; __os,</a>
<a name="ln4077">	       const std::geometric_distribution&lt;_IntType&gt;&amp; __x);</a>
<a name="ln4078"> </a>
<a name="ln4079">  /**</a>
<a name="ln4080">   * @brief Extracts a %geometric_distribution random number distribution</a>
<a name="ln4081">   * @p __x from the input stream @p __is.</a>
<a name="ln4082">   *</a>
<a name="ln4083">   * @param __is An input stream.</a>
<a name="ln4084">   * @param __x  A %geometric_distribution random number generator engine.</a>
<a name="ln4085">   *</a>
<a name="ln4086">   * @returns The input stream with @p __x extracted or in an error state.</a>
<a name="ln4087">   */</a>
<a name="ln4088">  template&lt;typename _IntType,</a>
<a name="ln4089">	   typename _CharT, typename _Traits&gt;</a>
<a name="ln4090">    std::basic_istream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln4091">    operator&gt;&gt;(std::basic_istream&lt;_CharT, _Traits&gt;&amp; __is,</a>
<a name="ln4092">	       std::geometric_distribution&lt;_IntType&gt;&amp; __x);</a>
<a name="ln4093"> </a>
<a name="ln4094"> </a>
<a name="ln4095">  /**</a>
<a name="ln4096">   * @brief A negative_binomial_distribution random number distribution.</a>
<a name="ln4097">   *</a>
<a name="ln4098">   * The formula for the negative binomial probability mass function is</a>
<a name="ln4099">   * @f$p(i) = \binom{n}{i} p^i (1 - p)^{t - i}@f$ where @f$t@f$</a>
<a name="ln4100">   * and @f$p@f$ are the parameters of the distribution.</a>
<a name="ln4101">   */</a>
<a name="ln4102">  template&lt;typename _IntType = int&gt;</a>
<a name="ln4103">    class negative_binomial_distribution</a>
<a name="ln4104">    {</a>
<a name="ln4105">      static_assert(std::is_integral&lt;_IntType&gt;::value,</a>
<a name="ln4106">		    &quot;result_type must be an integral type&quot;);</a>
<a name="ln4107"> </a>
<a name="ln4108">    public:</a>
<a name="ln4109">      /** The type of the range of the distribution. */</a>
<a name="ln4110">      typedef _IntType result_type;</a>
<a name="ln4111"> </a>
<a name="ln4112">      /** Parameter type. */</a>
<a name="ln4113">      struct param_type</a>
<a name="ln4114">      {</a>
<a name="ln4115">	typedef negative_binomial_distribution&lt;_IntType&gt; distribution_type;</a>
<a name="ln4116"> </a>
<a name="ln4117">	explicit</a>
<a name="ln4118">	param_type(_IntType __k = 1, double __p = 0.5)</a>
<a name="ln4119">	: _M_k(__k), _M_p(__p)</a>
<a name="ln4120">	{</a>
<a name="ln4121">	  __glibcxx_assert((_M_k &gt; 0) &amp;&amp; (_M_p &gt; 0.0) &amp;&amp; (_M_p &lt;= 1.0));</a>
<a name="ln4122">	}</a>
<a name="ln4123"> </a>
<a name="ln4124">	_IntType</a>
<a name="ln4125">	k() const</a>
<a name="ln4126">	{ return _M_k; }</a>
<a name="ln4127"> </a>
<a name="ln4128">	double</a>
<a name="ln4129">	p() const</a>
<a name="ln4130">	{ return _M_p; }</a>
<a name="ln4131"> </a>
<a name="ln4132">	friend bool</a>
<a name="ln4133">	operator==(const param_type&amp; __p1, const param_type&amp; __p2)</a>
<a name="ln4134">	{ return __p1._M_k == __p2._M_k &amp;&amp; __p1._M_p == __p2._M_p; }</a>
<a name="ln4135"> </a>
<a name="ln4136">	friend bool</a>
<a name="ln4137">	operator!=(const param_type&amp; __p1, const param_type&amp; __p2)</a>
<a name="ln4138">	{ return !(__p1 == __p2); }</a>
<a name="ln4139"> </a>
<a name="ln4140">      private:</a>
<a name="ln4141">	_IntType _M_k;</a>
<a name="ln4142">	double _M_p;</a>
<a name="ln4143">      };</a>
<a name="ln4144"> </a>
<a name="ln4145">      explicit</a>
<a name="ln4146">      negative_binomial_distribution(_IntType __k = 1, double __p = 0.5)</a>
<a name="ln4147">      : _M_param(__k, __p), _M_gd(__k, (1.0 - __p) / __p)</a>
<a name="ln4148">      { }</a>
<a name="ln4149"> </a>
<a name="ln4150">      explicit</a>
<a name="ln4151">      negative_binomial_distribution(const param_type&amp; __p)</a>
<a name="ln4152">      : _M_param(__p), _M_gd(__p.k(), (1.0 - __p.p()) / __p.p())</a>
<a name="ln4153">      { }</a>
<a name="ln4154"> </a>
<a name="ln4155">      /**</a>
<a name="ln4156">       * @brief Resets the distribution state.</a>
<a name="ln4157">       */</a>
<a name="ln4158">      void</a>
<a name="ln4159">      reset()</a>
<a name="ln4160">      { _M_gd.reset(); }</a>
<a name="ln4161"> </a>
<a name="ln4162">      /**</a>
<a name="ln4163">       * @brief Return the @f$k@f$ parameter of the distribution.</a>
<a name="ln4164">       */</a>
<a name="ln4165">      _IntType</a>
<a name="ln4166">      k() const</a>
<a name="ln4167">      { return _M_param.k(); }</a>
<a name="ln4168"> </a>
<a name="ln4169">      /**</a>
<a name="ln4170">       * @brief Return the @f$p@f$ parameter of the distribution.</a>
<a name="ln4171">       */</a>
<a name="ln4172">      double</a>
<a name="ln4173">      p() const</a>
<a name="ln4174">      { return _M_param.p(); }</a>
<a name="ln4175"> </a>
<a name="ln4176">      /**</a>
<a name="ln4177">       * @brief Returns the parameter set of the distribution.</a>
<a name="ln4178">       */</a>
<a name="ln4179">      param_type</a>
<a name="ln4180">      param() const</a>
<a name="ln4181">      { return _M_param; }</a>
<a name="ln4182"> </a>
<a name="ln4183">      /**</a>
<a name="ln4184">       * @brief Sets the parameter set of the distribution.</a>
<a name="ln4185">       * @param __param The new parameter set of the distribution.</a>
<a name="ln4186">       */</a>
<a name="ln4187">      void</a>
<a name="ln4188">      param(const param_type&amp; __param)</a>
<a name="ln4189">      { _M_param = __param; }</a>
<a name="ln4190"> </a>
<a name="ln4191">      /**</a>
<a name="ln4192">       * @brief Returns the greatest lower bound value of the distribution.</a>
<a name="ln4193">       */</a>
<a name="ln4194">      result_type</a>
<a name="ln4195">      min() const</a>
<a name="ln4196">      { return result_type(0); }</a>
<a name="ln4197"> </a>
<a name="ln4198">      /**</a>
<a name="ln4199">       * @brief Returns the least upper bound value of the distribution.</a>
<a name="ln4200">       */</a>
<a name="ln4201">      result_type</a>
<a name="ln4202">      max() const</a>
<a name="ln4203">      { return std::numeric_limits&lt;result_type&gt;::max(); }</a>
<a name="ln4204"> </a>
<a name="ln4205">      /**</a>
<a name="ln4206">       * @brief Generating functions.</a>
<a name="ln4207">       */</a>
<a name="ln4208">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln4209">	result_type</a>
<a name="ln4210">        operator()(_UniformRandomNumberGenerator&amp; __urng);</a>
<a name="ln4211"> </a>
<a name="ln4212">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln4213">	result_type</a>
<a name="ln4214">	operator()(_UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln4215">		   const param_type&amp; __p);</a>
<a name="ln4216"> </a>
<a name="ln4217">      template&lt;typename _ForwardIterator,</a>
<a name="ln4218">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln4219">	void</a>
<a name="ln4220">	__generate(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln4221">		   _UniformRandomNumberGenerator&amp; __urng)</a>
<a name="ln4222">	{ this-&gt;__generate_impl(__f, __t, __urng); }</a>
<a name="ln4223"> </a>
<a name="ln4224">      template&lt;typename _ForwardIterator,</a>
<a name="ln4225">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln4226">	void</a>
<a name="ln4227">	__generate(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln4228">		   _UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln4229">		   const param_type&amp; __p)</a>
<a name="ln4230">	{ this-&gt;__generate_impl(__f, __t, __urng, __p); }</a>
<a name="ln4231"> </a>
<a name="ln4232">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln4233">	void</a>
<a name="ln4234">	__generate(result_type* __f, result_type* __t,</a>
<a name="ln4235">		   _UniformRandomNumberGenerator&amp; __urng)</a>
<a name="ln4236">	{ this-&gt;__generate_impl(__f, __t, __urng); }</a>
<a name="ln4237"> </a>
<a name="ln4238">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln4239">	void</a>
<a name="ln4240">	__generate(result_type* __f, result_type* __t,</a>
<a name="ln4241">		   _UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln4242">		   const param_type&amp; __p)</a>
<a name="ln4243">	{ this-&gt;__generate_impl(__f, __t, __urng, __p); }</a>
<a name="ln4244"> </a>
<a name="ln4245">      /**</a>
<a name="ln4246">       * @brief Return true if two negative binomial distributions have</a>
<a name="ln4247">       *        the same parameters and the sequences that would be</a>
<a name="ln4248">       *        generated are equal.</a>
<a name="ln4249">       */</a>
<a name="ln4250">      friend bool</a>
<a name="ln4251">      operator==(const negative_binomial_distribution&amp; __d1,</a>
<a name="ln4252">		 const negative_binomial_distribution&amp; __d2)</a>
<a name="ln4253">      { return __d1._M_param == __d2._M_param &amp;&amp; __d1._M_gd == __d2._M_gd; }</a>
<a name="ln4254"> </a>
<a name="ln4255">      /**</a>
<a name="ln4256">       * @brief Inserts a %negative_binomial_distribution random</a>
<a name="ln4257">       *        number distribution @p __x into the output stream @p __os.</a>
<a name="ln4258">       *</a>
<a name="ln4259">       * @param __os An output stream.</a>
<a name="ln4260">       * @param __x  A %negative_binomial_distribution random number</a>
<a name="ln4261">       *             distribution.</a>
<a name="ln4262">       *</a>
<a name="ln4263">       * @returns The output stream with the state of @p __x inserted or in</a>
<a name="ln4264">       *          an error state.</a>
<a name="ln4265">       */</a>
<a name="ln4266">      template&lt;typename _IntType1, typename _CharT, typename _Traits&gt;</a>
<a name="ln4267">	friend std::basic_ostream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln4268">	operator&lt;&lt;(std::basic_ostream&lt;_CharT, _Traits&gt;&amp; __os,</a>
<a name="ln4269">		   const std::negative_binomial_distribution&lt;_IntType1&gt;&amp; __x);</a>
<a name="ln4270"> </a>
<a name="ln4271">      /**</a>
<a name="ln4272">       * @brief Extracts a %negative_binomial_distribution random number</a>
<a name="ln4273">       *        distribution @p __x from the input stream @p __is.</a>
<a name="ln4274">       *</a>
<a name="ln4275">       * @param __is An input stream.</a>
<a name="ln4276">       * @param __x A %negative_binomial_distribution random number</a>
<a name="ln4277">       *            generator engine.</a>
<a name="ln4278">       *</a>
<a name="ln4279">       * @returns The input stream with @p __x extracted or in an error state.</a>
<a name="ln4280">       */</a>
<a name="ln4281">      template&lt;typename _IntType1, typename _CharT, typename _Traits&gt;</a>
<a name="ln4282">	friend std::basic_istream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln4283">	operator&gt;&gt;(std::basic_istream&lt;_CharT, _Traits&gt;&amp; __is,</a>
<a name="ln4284">		   std::negative_binomial_distribution&lt;_IntType1&gt;&amp; __x);</a>
<a name="ln4285"> </a>
<a name="ln4286">    private:</a>
<a name="ln4287">      template&lt;typename _ForwardIterator,</a>
<a name="ln4288">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln4289">	void</a>
<a name="ln4290">	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln4291">			_UniformRandomNumberGenerator&amp; __urng);</a>
<a name="ln4292">      template&lt;typename _ForwardIterator,</a>
<a name="ln4293">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln4294">	void</a>
<a name="ln4295">	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln4296">			_UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln4297">			const param_type&amp; __p);</a>
<a name="ln4298"> </a>
<a name="ln4299">      param_type _M_param;</a>
<a name="ln4300"> </a>
<a name="ln4301">      std::gamma_distribution&lt;double&gt; _M_gd;</a>
<a name="ln4302">    };</a>
<a name="ln4303"> </a>
<a name="ln4304">  /**</a>
<a name="ln4305">   * @brief Return true if two negative binomial distributions are different.</a>
<a name="ln4306">   */</a>
<a name="ln4307">  template&lt;typename _IntType&gt;</a>
<a name="ln4308">    inline bool</a>
<a name="ln4309">    operator!=(const std::negative_binomial_distribution&lt;_IntType&gt;&amp; __d1,</a>
<a name="ln4310">	       const std::negative_binomial_distribution&lt;_IntType&gt;&amp; __d2)</a>
<a name="ln4311">    { return !(__d1 == __d2); }</a>
<a name="ln4312"> </a>
<a name="ln4313"> </a>
<a name="ln4314">  /* @} */ // group random_distributions_bernoulli</a>
<a name="ln4315"> </a>
<a name="ln4316">  /**</a>
<a name="ln4317">   * @addtogroup random_distributions_poisson Poisson Distributions</a>
<a name="ln4318">   * @ingroup random_distributions</a>
<a name="ln4319">   * @{</a>
<a name="ln4320">   */</a>
<a name="ln4321"> </a>
<a name="ln4322">  /**</a>
<a name="ln4323">   * @brief A discrete Poisson random number distribution.</a>
<a name="ln4324">   *</a>
<a name="ln4325">   * The formula for the Poisson probability density function is</a>
<a name="ln4326">   * @f$p(i|\mu) = \frac{\mu^i}{i!} e^{-\mu}@f$ where @f$\mu@f$ is the</a>
<a name="ln4327">   * parameter of the distribution.</a>
<a name="ln4328">   */</a>
<a name="ln4329">  template&lt;typename _IntType = int&gt;</a>
<a name="ln4330">    class poisson_distribution</a>
<a name="ln4331">    {</a>
<a name="ln4332">      static_assert(std::is_integral&lt;_IntType&gt;::value,</a>
<a name="ln4333">		    &quot;result_type must be an integral type&quot;);</a>
<a name="ln4334"> </a>
<a name="ln4335">    public:</a>
<a name="ln4336">      /** The type of the range of the distribution. */</a>
<a name="ln4337">      typedef _IntType  result_type;</a>
<a name="ln4338"> </a>
<a name="ln4339">      /** Parameter type. */</a>
<a name="ln4340">      struct param_type</a>
<a name="ln4341">      {</a>
<a name="ln4342">	typedef poisson_distribution&lt;_IntType&gt; distribution_type;</a>
<a name="ln4343">	friend class poisson_distribution&lt;_IntType&gt;;</a>
<a name="ln4344"> </a>
<a name="ln4345">	explicit</a>
<a name="ln4346">	param_type(double __mean = 1.0)</a>
<a name="ln4347">	: _M_mean(__mean)</a>
<a name="ln4348">	{</a>
<a name="ln4349">	  __glibcxx_assert(_M_mean &gt; 0.0);</a>
<a name="ln4350">	  _M_initialize();</a>
<a name="ln4351">	}</a>
<a name="ln4352"> </a>
<a name="ln4353">	double</a>
<a name="ln4354">	mean() const</a>
<a name="ln4355">	{ return _M_mean; }</a>
<a name="ln4356"> </a>
<a name="ln4357">	friend bool</a>
<a name="ln4358">	operator==(const param_type&amp; __p1, const param_type&amp; __p2)</a>
<a name="ln4359">	{ return __p1._M_mean == __p2._M_mean; }</a>
<a name="ln4360"> </a>
<a name="ln4361">	friend bool</a>
<a name="ln4362">	operator!=(const param_type&amp; __p1, const param_type&amp; __p2)</a>
<a name="ln4363">	{ return !(__p1 == __p2); }</a>
<a name="ln4364"> </a>
<a name="ln4365">      private:</a>
<a name="ln4366">	// Hosts either log(mean) or the threshold of the simple method.</a>
<a name="ln4367">	void</a>
<a name="ln4368">	_M_initialize();</a>
<a name="ln4369"> </a>
<a name="ln4370">	double _M_mean;</a>
<a name="ln4371"> </a>
<a name="ln4372">	double _M_lm_thr;</a>
<a name="ln4373">#if _GLIBCXX_USE_C99_MATH_TR1</a>
<a name="ln4374">	double _M_lfm, _M_sm, _M_d, _M_scx, _M_1cx, _M_c2b, _M_cb;</a>
<a name="ln4375">#endif</a>
<a name="ln4376">      };</a>
<a name="ln4377"> </a>
<a name="ln4378">      // constructors and member function</a>
<a name="ln4379">      explicit</a>
<a name="ln4380">      poisson_distribution(double __mean = 1.0)</a>
<a name="ln4381">      : _M_param(__mean), _M_nd()</a>
<a name="ln4382">      { }</a>
<a name="ln4383"> </a>
<a name="ln4384">      explicit</a>
<a name="ln4385">      poisson_distribution(const param_type&amp; __p)</a>
<a name="ln4386">      : _M_param(__p), _M_nd()</a>
<a name="ln4387">      { }</a>
<a name="ln4388"> </a>
<a name="ln4389">      /**</a>
<a name="ln4390">       * @brief Resets the distribution state.</a>
<a name="ln4391">       */</a>
<a name="ln4392">      void</a>
<a name="ln4393">      reset()</a>
<a name="ln4394">      { _M_nd.reset(); }</a>
<a name="ln4395"> </a>
<a name="ln4396">      /**</a>
<a name="ln4397">       * @brief Returns the distribution parameter @p mean.</a>
<a name="ln4398">       */</a>
<a name="ln4399">      double</a>
<a name="ln4400">      mean() const</a>
<a name="ln4401">      { return _M_param.mean(); }</a>
<a name="ln4402"> </a>
<a name="ln4403">      /**</a>
<a name="ln4404">       * @brief Returns the parameter set of the distribution.</a>
<a name="ln4405">       */</a>
<a name="ln4406">      param_type</a>
<a name="ln4407">      param() const</a>
<a name="ln4408">      { return _M_param; }</a>
<a name="ln4409"> </a>
<a name="ln4410">      /**</a>
<a name="ln4411">       * @brief Sets the parameter set of the distribution.</a>
<a name="ln4412">       * @param __param The new parameter set of the distribution.</a>
<a name="ln4413">       */</a>
<a name="ln4414">      void</a>
<a name="ln4415">      param(const param_type&amp; __param)</a>
<a name="ln4416">      { _M_param = __param; }</a>
<a name="ln4417"> </a>
<a name="ln4418">      /**</a>
<a name="ln4419">       * @brief Returns the greatest lower bound value of the distribution.</a>
<a name="ln4420">       */</a>
<a name="ln4421">      result_type</a>
<a name="ln4422">      min() const</a>
<a name="ln4423">      { return 0; }</a>
<a name="ln4424"> </a>
<a name="ln4425">      /**</a>
<a name="ln4426">       * @brief Returns the least upper bound value of the distribution.</a>
<a name="ln4427">       */</a>
<a name="ln4428">      result_type</a>
<a name="ln4429">      max() const</a>
<a name="ln4430">      { return std::numeric_limits&lt;result_type&gt;::max(); }</a>
<a name="ln4431"> </a>
<a name="ln4432">      /**</a>
<a name="ln4433">       * @brief Generating functions.</a>
<a name="ln4434">       */</a>
<a name="ln4435">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln4436">	result_type</a>
<a name="ln4437">	operator()(_UniformRandomNumberGenerator&amp; __urng)</a>
<a name="ln4438">	{ return this-&gt;operator()(__urng, _M_param); }</a>
<a name="ln4439"> </a>
<a name="ln4440">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln4441">	result_type</a>
<a name="ln4442">	operator()(_UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln4443">		   const param_type&amp; __p);</a>
<a name="ln4444"> </a>
<a name="ln4445">      template&lt;typename _ForwardIterator,</a>
<a name="ln4446">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln4447">	void</a>
<a name="ln4448">	__generate(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln4449">		   _UniformRandomNumberGenerator&amp; __urng)</a>
<a name="ln4450">	{ this-&gt;__generate(__f, __t, __urng, _M_param); }</a>
<a name="ln4451"> </a>
<a name="ln4452">      template&lt;typename _ForwardIterator,</a>
<a name="ln4453">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln4454">	void</a>
<a name="ln4455">	__generate(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln4456">		   _UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln4457">		   const param_type&amp; __p)</a>
<a name="ln4458">	{ this-&gt;__generate_impl(__f, __t, __urng, __p); }</a>
<a name="ln4459"> </a>
<a name="ln4460">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln4461">	void</a>
<a name="ln4462">	__generate(result_type* __f, result_type* __t,</a>
<a name="ln4463">		   _UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln4464">		   const param_type&amp; __p)</a>
<a name="ln4465">	{ this-&gt;__generate_impl(__f, __t, __urng, __p); }</a>
<a name="ln4466"> </a>
<a name="ln4467">       /**</a>
<a name="ln4468">	* @brief Return true if two Poisson distributions have the same</a>
<a name="ln4469">	*        parameters and the sequences that would be generated</a>
<a name="ln4470">	*        are equal.</a>
<a name="ln4471">	*/</a>
<a name="ln4472">      friend bool</a>
<a name="ln4473">      operator==(const poisson_distribution&amp; __d1,</a>
<a name="ln4474">		 const poisson_distribution&amp; __d2)</a>
<a name="ln4475">#ifdef _GLIBCXX_USE_C99_MATH_TR1</a>
<a name="ln4476">      { return __d1._M_param == __d2._M_param &amp;&amp; __d1._M_nd == __d2._M_nd; }</a>
<a name="ln4477">#else</a>
<a name="ln4478">      { return __d1._M_param == __d2._M_param; }</a>
<a name="ln4479">#endif</a>
<a name="ln4480"> </a>
<a name="ln4481">      /**</a>
<a name="ln4482">       * @brief Inserts a %poisson_distribution random number distribution</a>
<a name="ln4483">       * @p __x into the output stream @p __os.</a>
<a name="ln4484">       *</a>
<a name="ln4485">       * @param __os An output stream.</a>
<a name="ln4486">       * @param __x  A %poisson_distribution random number distribution.</a>
<a name="ln4487">       *</a>
<a name="ln4488">       * @returns The output stream with the state of @p __x inserted or in</a>
<a name="ln4489">       * an error state.</a>
<a name="ln4490">       */</a>
<a name="ln4491">      template&lt;typename _IntType1, typename _CharT, typename _Traits&gt;</a>
<a name="ln4492">	friend std::basic_ostream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln4493">	operator&lt;&lt;(std::basic_ostream&lt;_CharT, _Traits&gt;&amp; __os,</a>
<a name="ln4494">		   const std::poisson_distribution&lt;_IntType1&gt;&amp; __x);</a>
<a name="ln4495"> </a>
<a name="ln4496">      /**</a>
<a name="ln4497">       * @brief Extracts a %poisson_distribution random number distribution</a>
<a name="ln4498">       * @p __x from the input stream @p __is.</a>
<a name="ln4499">       *</a>
<a name="ln4500">       * @param __is An input stream.</a>
<a name="ln4501">       * @param __x  A %poisson_distribution random number generator engine.</a>
<a name="ln4502">       *</a>
<a name="ln4503">       * @returns The input stream with @p __x extracted or in an error</a>
<a name="ln4504">       *          state.</a>
<a name="ln4505">       */</a>
<a name="ln4506">      template&lt;typename _IntType1, typename _CharT, typename _Traits&gt;</a>
<a name="ln4507">	friend std::basic_istream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln4508">	operator&gt;&gt;(std::basic_istream&lt;_CharT, _Traits&gt;&amp; __is,</a>
<a name="ln4509">		   std::poisson_distribution&lt;_IntType1&gt;&amp; __x);</a>
<a name="ln4510"> </a>
<a name="ln4511">    private:</a>
<a name="ln4512">      template&lt;typename _ForwardIterator,</a>
<a name="ln4513">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln4514">	void</a>
<a name="ln4515">	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln4516">			_UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln4517">			const param_type&amp; __p);</a>
<a name="ln4518"> </a>
<a name="ln4519">      param_type _M_param;</a>
<a name="ln4520"> </a>
<a name="ln4521">      // NB: Unused when _GLIBCXX_USE_C99_MATH_TR1 is undefined.</a>
<a name="ln4522">      std::normal_distribution&lt;double&gt; _M_nd;</a>
<a name="ln4523">    };</a>
<a name="ln4524"> </a>
<a name="ln4525">  /**</a>
<a name="ln4526">   * @brief Return true if two Poisson distributions are different.</a>
<a name="ln4527">   */</a>
<a name="ln4528">  template&lt;typename _IntType&gt;</a>
<a name="ln4529">    inline bool</a>
<a name="ln4530">    operator!=(const std::poisson_distribution&lt;_IntType&gt;&amp; __d1,</a>
<a name="ln4531">	       const std::poisson_distribution&lt;_IntType&gt;&amp; __d2)</a>
<a name="ln4532">    { return !(__d1 == __d2); }</a>
<a name="ln4533"> </a>
<a name="ln4534"> </a>
<a name="ln4535">  /**</a>
<a name="ln4536">   * @brief An exponential continuous distribution for random numbers.</a>
<a name="ln4537">   *</a>
<a name="ln4538">   * The formula for the exponential probability density function is</a>
<a name="ln4539">   * @f$p(x|\lambda) = \lambda e^{-\lambda x}@f$.</a>
<a name="ln4540">   *</a>
<a name="ln4541">   * &lt;table border=1 cellpadding=10 cellspacing=0&gt;</a>
<a name="ln4542">   * &lt;caption align=top&gt;Distribution Statistics&lt;/caption&gt;</a>
<a name="ln4543">   * &lt;tr&gt;&lt;td&gt;Mean&lt;/td&gt;&lt;td&gt;@f$\frac{1}{\lambda}@f$&lt;/td&gt;&lt;/tr&gt;</a>
<a name="ln4544">   * &lt;tr&gt;&lt;td&gt;Median&lt;/td&gt;&lt;td&gt;@f$\frac{\ln 2}{\lambda}@f$&lt;/td&gt;&lt;/tr&gt;</a>
<a name="ln4545">   * &lt;tr&gt;&lt;td&gt;Mode&lt;/td&gt;&lt;td&gt;@f$zero@f$&lt;/td&gt;&lt;/tr&gt;</a>
<a name="ln4546">   * &lt;tr&gt;&lt;td&gt;Range&lt;/td&gt;&lt;td&gt;@f$[0, \infty]@f$&lt;/td&gt;&lt;/tr&gt;</a>
<a name="ln4547">   * &lt;tr&gt;&lt;td&gt;Standard Deviation&lt;/td&gt;&lt;td&gt;@f$\frac{1}{\lambda}@f$&lt;/td&gt;&lt;/tr&gt;</a>
<a name="ln4548">   * &lt;/table&gt;</a>
<a name="ln4549">   */</a>
<a name="ln4550">  template&lt;typename _RealType = double&gt;</a>
<a name="ln4551">    class exponential_distribution</a>
<a name="ln4552">    {</a>
<a name="ln4553">      static_assert(std::is_floating_point&lt;_RealType&gt;::value,</a>
<a name="ln4554">		    &quot;result_type must be a floating point type&quot;);</a>
<a name="ln4555"> </a>
<a name="ln4556">    public:</a>
<a name="ln4557">      /** The type of the range of the distribution. */</a>
<a name="ln4558">      typedef _RealType result_type;</a>
<a name="ln4559"> </a>
<a name="ln4560">      /** Parameter type. */</a>
<a name="ln4561">      struct param_type</a>
<a name="ln4562">      {</a>
<a name="ln4563">	typedef exponential_distribution&lt;_RealType&gt; distribution_type;</a>
<a name="ln4564"> </a>
<a name="ln4565">	explicit</a>
<a name="ln4566">	param_type(_RealType __lambda = _RealType(1))</a>
<a name="ln4567">	: _M_lambda(__lambda)</a>
<a name="ln4568">	{</a>
<a name="ln4569">	  __glibcxx_assert(_M_lambda &gt; _RealType(0));</a>
<a name="ln4570">	}</a>
<a name="ln4571"> </a>
<a name="ln4572">	_RealType</a>
<a name="ln4573">	lambda() const</a>
<a name="ln4574">	{ return _M_lambda; }</a>
<a name="ln4575"> </a>
<a name="ln4576">	friend bool</a>
<a name="ln4577">	operator==(const param_type&amp; __p1, const param_type&amp; __p2)</a>
<a name="ln4578">	{ return __p1._M_lambda == __p2._M_lambda; }</a>
<a name="ln4579"> </a>
<a name="ln4580">	friend bool</a>
<a name="ln4581">	operator!=(const param_type&amp; __p1, const param_type&amp; __p2)</a>
<a name="ln4582">	{ return !(__p1 == __p2); }</a>
<a name="ln4583"> </a>
<a name="ln4584">      private:</a>
<a name="ln4585">	_RealType _M_lambda;</a>
<a name="ln4586">      };</a>
<a name="ln4587"> </a>
<a name="ln4588">    public:</a>
<a name="ln4589">      /**</a>
<a name="ln4590">       * @brief Constructs an exponential distribution with inverse scale</a>
<a name="ln4591">       *        parameter @f$\lambda@f$.</a>
<a name="ln4592">       */</a>
<a name="ln4593">      explicit</a>
<a name="ln4594">      exponential_distribution(const result_type&amp; __lambda = result_type(1))</a>
<a name="ln4595">      : _M_param(__lambda)</a>
<a name="ln4596">      { }</a>
<a name="ln4597"> </a>
<a name="ln4598">      explicit</a>
<a name="ln4599">      exponential_distribution(const param_type&amp; __p)</a>
<a name="ln4600">      : _M_param(__p)</a>
<a name="ln4601">      { }</a>
<a name="ln4602"> </a>
<a name="ln4603">      /**</a>
<a name="ln4604">       * @brief Resets the distribution state.</a>
<a name="ln4605">       *</a>
<a name="ln4606">       * Has no effect on exponential distributions.</a>
<a name="ln4607">       */</a>
<a name="ln4608">      void</a>
<a name="ln4609">      reset() { }</a>
<a name="ln4610"> </a>
<a name="ln4611">      /**</a>
<a name="ln4612">       * @brief Returns the inverse scale parameter of the distribution.</a>
<a name="ln4613">       */</a>
<a name="ln4614">      _RealType</a>
<a name="ln4615">      lambda() const</a>
<a name="ln4616">      { return _M_param.lambda(); }</a>
<a name="ln4617"> </a>
<a name="ln4618">      /**</a>
<a name="ln4619">       * @brief Returns the parameter set of the distribution.</a>
<a name="ln4620">       */</a>
<a name="ln4621">      param_type</a>
<a name="ln4622">      param() const</a>
<a name="ln4623">      { return _M_param; }</a>
<a name="ln4624"> </a>
<a name="ln4625">      /**</a>
<a name="ln4626">       * @brief Sets the parameter set of the distribution.</a>
<a name="ln4627">       * @param __param The new parameter set of the distribution.</a>
<a name="ln4628">       */</a>
<a name="ln4629">      void</a>
<a name="ln4630">      param(const param_type&amp; __param)</a>
<a name="ln4631">      { _M_param = __param; }</a>
<a name="ln4632"> </a>
<a name="ln4633">      /**</a>
<a name="ln4634">       * @brief Returns the greatest lower bound value of the distribution.</a>
<a name="ln4635">       */</a>
<a name="ln4636">      result_type</a>
<a name="ln4637">      min() const</a>
<a name="ln4638">      { return result_type(0); }</a>
<a name="ln4639"> </a>
<a name="ln4640">      /**</a>
<a name="ln4641">       * @brief Returns the least upper bound value of the distribution.</a>
<a name="ln4642">       */</a>
<a name="ln4643">      result_type</a>
<a name="ln4644">      max() const</a>
<a name="ln4645">      { return std::numeric_limits&lt;result_type&gt;::max(); }</a>
<a name="ln4646"> </a>
<a name="ln4647">      /**</a>
<a name="ln4648">       * @brief Generating functions.</a>
<a name="ln4649">       */</a>
<a name="ln4650">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln4651">	result_type</a>
<a name="ln4652">	operator()(_UniformRandomNumberGenerator&amp; __urng)</a>
<a name="ln4653">        { return this-&gt;operator()(__urng, _M_param); }</a>
<a name="ln4654"> </a>
<a name="ln4655">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln4656">	result_type</a>
<a name="ln4657">	operator()(_UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln4658">		   const param_type&amp; __p)</a>
<a name="ln4659">	{</a>
<a name="ln4660">	  __detail::_Adaptor&lt;_UniformRandomNumberGenerator, result_type&gt;</a>
<a name="ln4661">	    __aurng(__urng);</a>
<a name="ln4662">	  return -std::log(result_type(1) - __aurng()) / __p.lambda();</a>
<a name="ln4663">	}</a>
<a name="ln4664"> </a>
<a name="ln4665">      template&lt;typename _ForwardIterator,</a>
<a name="ln4666">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln4667">	void</a>
<a name="ln4668">	__generate(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln4669">		   _UniformRandomNumberGenerator&amp; __urng)</a>
<a name="ln4670">	{ this-&gt;__generate(__f, __t, __urng, _M_param); }</a>
<a name="ln4671"> </a>
<a name="ln4672">      template&lt;typename _ForwardIterator,</a>
<a name="ln4673">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln4674">	void</a>
<a name="ln4675">	__generate(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln4676">		   _UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln4677">		   const param_type&amp; __p)</a>
<a name="ln4678">	{ this-&gt;__generate_impl(__f, __t, __urng, __p); }</a>
<a name="ln4679"> </a>
<a name="ln4680">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln4681">	void</a>
<a name="ln4682">	__generate(result_type* __f, result_type* __t,</a>
<a name="ln4683">		   _UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln4684">		   const param_type&amp; __p)</a>
<a name="ln4685">	{ this-&gt;__generate_impl(__f, __t, __urng, __p); }</a>
<a name="ln4686"> </a>
<a name="ln4687">      /**</a>
<a name="ln4688">       * @brief Return true if two exponential distributions have the same</a>
<a name="ln4689">       *        parameters.</a>
<a name="ln4690">       */</a>
<a name="ln4691">      friend bool</a>
<a name="ln4692">      operator==(const exponential_distribution&amp; __d1,</a>
<a name="ln4693">		 const exponential_distribution&amp; __d2)</a>
<a name="ln4694">      { return __d1._M_param == __d2._M_param; }</a>
<a name="ln4695"> </a>
<a name="ln4696">    private:</a>
<a name="ln4697">      template&lt;typename _ForwardIterator,</a>
<a name="ln4698">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln4699">	void</a>
<a name="ln4700">	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln4701">			_UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln4702">			const param_type&amp; __p);</a>
<a name="ln4703"> </a>
<a name="ln4704">      param_type _M_param;</a>
<a name="ln4705">    };</a>
<a name="ln4706"> </a>
<a name="ln4707">  /**</a>
<a name="ln4708">   * @brief Return true if two exponential distributions have different</a>
<a name="ln4709">   *        parameters.</a>
<a name="ln4710">   */</a>
<a name="ln4711">  template&lt;typename _RealType&gt;</a>
<a name="ln4712">    inline bool</a>
<a name="ln4713">    operator!=(const std::exponential_distribution&lt;_RealType&gt;&amp; __d1,</a>
<a name="ln4714">	       const std::exponential_distribution&lt;_RealType&gt;&amp; __d2)</a>
<a name="ln4715">    { return !(__d1 == __d2); }</a>
<a name="ln4716"> </a>
<a name="ln4717">  /**</a>
<a name="ln4718">   * @brief Inserts a %exponential_distribution random number distribution</a>
<a name="ln4719">   * @p __x into the output stream @p __os.</a>
<a name="ln4720">   *</a>
<a name="ln4721">   * @param __os An output stream.</a>
<a name="ln4722">   * @param __x  A %exponential_distribution random number distribution.</a>
<a name="ln4723">   *</a>
<a name="ln4724">   * @returns The output stream with the state of @p __x inserted or in</a>
<a name="ln4725">   * an error state.</a>
<a name="ln4726">   */</a>
<a name="ln4727">  template&lt;typename _RealType, typename _CharT, typename _Traits&gt;</a>
<a name="ln4728">    std::basic_ostream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln4729">    operator&lt;&lt;(std::basic_ostream&lt;_CharT, _Traits&gt;&amp; __os,</a>
<a name="ln4730">	       const std::exponential_distribution&lt;_RealType&gt;&amp; __x);</a>
<a name="ln4731"> </a>
<a name="ln4732">  /**</a>
<a name="ln4733">   * @brief Extracts a %exponential_distribution random number distribution</a>
<a name="ln4734">   * @p __x from the input stream @p __is.</a>
<a name="ln4735">   *</a>
<a name="ln4736">   * @param __is An input stream.</a>
<a name="ln4737">   * @param __x A %exponential_distribution random number</a>
<a name="ln4738">   *            generator engine.</a>
<a name="ln4739">   *</a>
<a name="ln4740">   * @returns The input stream with @p __x extracted or in an error state.</a>
<a name="ln4741">   */</a>
<a name="ln4742">  template&lt;typename _RealType, typename _CharT, typename _Traits&gt;</a>
<a name="ln4743">    std::basic_istream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln4744">    operator&gt;&gt;(std::basic_istream&lt;_CharT, _Traits&gt;&amp; __is,</a>
<a name="ln4745">	       std::exponential_distribution&lt;_RealType&gt;&amp; __x);</a>
<a name="ln4746"> </a>
<a name="ln4747"> </a>
<a name="ln4748">  /**</a>
<a name="ln4749">   * @brief A weibull_distribution random number distribution.</a>
<a name="ln4750">   *</a>
<a name="ln4751">   * The formula for the normal probability density function is:</a>
<a name="ln4752">   * @f[</a>
<a name="ln4753">   *     p(x|\alpha,\beta) = \frac{\alpha}{\beta} (\frac{x}{\beta})^{\alpha-1}</a>
<a name="ln4754">   *                         \exp{(-(\frac{x}{\beta})^\alpha)} </a>
<a name="ln4755">   * @f]</a>
<a name="ln4756">   */</a>
<a name="ln4757">  template&lt;typename _RealType = double&gt;</a>
<a name="ln4758">    class weibull_distribution</a>
<a name="ln4759">    {</a>
<a name="ln4760">      static_assert(std::is_floating_point&lt;_RealType&gt;::value,</a>
<a name="ln4761">		    &quot;result_type must be a floating point type&quot;);</a>
<a name="ln4762"> </a>
<a name="ln4763">    public:</a>
<a name="ln4764">      /** The type of the range of the distribution. */</a>
<a name="ln4765">      typedef _RealType result_type;</a>
<a name="ln4766"> </a>
<a name="ln4767">      /** Parameter type. */</a>
<a name="ln4768">      struct param_type</a>
<a name="ln4769">      {</a>
<a name="ln4770">	typedef weibull_distribution&lt;_RealType&gt; distribution_type;</a>
<a name="ln4771"> </a>
<a name="ln4772">	explicit</a>
<a name="ln4773">	param_type(_RealType __a = _RealType(1),</a>
<a name="ln4774">		   _RealType __b = _RealType(1))</a>
<a name="ln4775">	: _M_a(__a), _M_b(__b)</a>
<a name="ln4776">	{ }</a>
<a name="ln4777"> </a>
<a name="ln4778">	_RealType</a>
<a name="ln4779">	a() const</a>
<a name="ln4780">	{ return _M_a; }</a>
<a name="ln4781"> </a>
<a name="ln4782">	_RealType</a>
<a name="ln4783">	b() const</a>
<a name="ln4784">	{ return _M_b; }</a>
<a name="ln4785"> </a>
<a name="ln4786">	friend bool</a>
<a name="ln4787">	operator==(const param_type&amp; __p1, const param_type&amp; __p2)</a>
<a name="ln4788">	{ return __p1._M_a == __p2._M_a &amp;&amp; __p1._M_b == __p2._M_b; }</a>
<a name="ln4789"> </a>
<a name="ln4790">	friend bool</a>
<a name="ln4791">	operator!=(const param_type&amp; __p1, const param_type&amp; __p2)</a>
<a name="ln4792">	{ return !(__p1 == __p2); }</a>
<a name="ln4793"> </a>
<a name="ln4794">      private:</a>
<a name="ln4795">	_RealType _M_a;</a>
<a name="ln4796">	_RealType _M_b;</a>
<a name="ln4797">      };</a>
<a name="ln4798"> </a>
<a name="ln4799">      explicit</a>
<a name="ln4800">      weibull_distribution(_RealType __a = _RealType(1),</a>
<a name="ln4801">			   _RealType __b = _RealType(1))</a>
<a name="ln4802">      : _M_param(__a, __b)</a>
<a name="ln4803">      { }</a>
<a name="ln4804"> </a>
<a name="ln4805">      explicit</a>
<a name="ln4806">      weibull_distribution(const param_type&amp; __p)</a>
<a name="ln4807">      : _M_param(__p)</a>
<a name="ln4808">      { }</a>
<a name="ln4809"> </a>
<a name="ln4810">      /**</a>
<a name="ln4811">       * @brief Resets the distribution state.</a>
<a name="ln4812">       */</a>
<a name="ln4813">      void</a>
<a name="ln4814">      reset()</a>
<a name="ln4815">      { }</a>
<a name="ln4816"> </a>
<a name="ln4817">      /**</a>
<a name="ln4818">       * @brief Return the @f$a@f$ parameter of the distribution.</a>
<a name="ln4819">       */</a>
<a name="ln4820">      _RealType</a>
<a name="ln4821">      a() const</a>
<a name="ln4822">      { return _M_param.a(); }</a>
<a name="ln4823"> </a>
<a name="ln4824">      /**</a>
<a name="ln4825">       * @brief Return the @f$b@f$ parameter of the distribution.</a>
<a name="ln4826">       */</a>
<a name="ln4827">      _RealType</a>
<a name="ln4828">      b() const</a>
<a name="ln4829">      { return _M_param.b(); }</a>
<a name="ln4830"> </a>
<a name="ln4831">      /**</a>
<a name="ln4832">       * @brief Returns the parameter set of the distribution.</a>
<a name="ln4833">       */</a>
<a name="ln4834">      param_type</a>
<a name="ln4835">      param() const</a>
<a name="ln4836">      { return _M_param; }</a>
<a name="ln4837"> </a>
<a name="ln4838">      /**</a>
<a name="ln4839">       * @brief Sets the parameter set of the distribution.</a>
<a name="ln4840">       * @param __param The new parameter set of the distribution.</a>
<a name="ln4841">       */</a>
<a name="ln4842">      void</a>
<a name="ln4843">      param(const param_type&amp; __param)</a>
<a name="ln4844">      { _M_param = __param; }</a>
<a name="ln4845"> </a>
<a name="ln4846">      /**</a>
<a name="ln4847">       * @brief Returns the greatest lower bound value of the distribution.</a>
<a name="ln4848">       */</a>
<a name="ln4849">      result_type</a>
<a name="ln4850">      min() const</a>
<a name="ln4851">      { return result_type(0); }</a>
<a name="ln4852"> </a>
<a name="ln4853">      /**</a>
<a name="ln4854">       * @brief Returns the least upper bound value of the distribution.</a>
<a name="ln4855">       */</a>
<a name="ln4856">      result_type</a>
<a name="ln4857">      max() const</a>
<a name="ln4858">      { return std::numeric_limits&lt;result_type&gt;::max(); }</a>
<a name="ln4859"> </a>
<a name="ln4860">      /**</a>
<a name="ln4861">       * @brief Generating functions.</a>
<a name="ln4862">       */</a>
<a name="ln4863">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln4864">	result_type</a>
<a name="ln4865">	operator()(_UniformRandomNumberGenerator&amp; __urng)</a>
<a name="ln4866">	{ return this-&gt;operator()(__urng, _M_param); }</a>
<a name="ln4867"> </a>
<a name="ln4868">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln4869">	result_type</a>
<a name="ln4870">	operator()(_UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln4871">		   const param_type&amp; __p);</a>
<a name="ln4872"> </a>
<a name="ln4873">      template&lt;typename _ForwardIterator,</a>
<a name="ln4874">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln4875">	void</a>
<a name="ln4876">	__generate(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln4877">		   _UniformRandomNumberGenerator&amp; __urng)</a>
<a name="ln4878">	{ this-&gt;__generate(__f, __t, __urng, _M_param); }</a>
<a name="ln4879"> </a>
<a name="ln4880">      template&lt;typename _ForwardIterator,</a>
<a name="ln4881">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln4882">	void</a>
<a name="ln4883">	__generate(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln4884">		   _UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln4885">		   const param_type&amp; __p)</a>
<a name="ln4886">	{ this-&gt;__generate_impl(__f, __t, __urng, __p); }</a>
<a name="ln4887"> </a>
<a name="ln4888">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln4889">	void</a>
<a name="ln4890">	__generate(result_type* __f, result_type* __t,</a>
<a name="ln4891">		   _UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln4892">		   const param_type&amp; __p)</a>
<a name="ln4893">	{ this-&gt;__generate_impl(__f, __t, __urng, __p); }</a>
<a name="ln4894"> </a>
<a name="ln4895">      /**</a>
<a name="ln4896">       * @brief Return true if two Weibull distributions have the same</a>
<a name="ln4897">       *        parameters.</a>
<a name="ln4898">       */</a>
<a name="ln4899">      friend bool</a>
<a name="ln4900">      operator==(const weibull_distribution&amp; __d1,</a>
<a name="ln4901">		 const weibull_distribution&amp; __d2)</a>
<a name="ln4902">      { return __d1._M_param == __d2._M_param; }</a>
<a name="ln4903"> </a>
<a name="ln4904">    private:</a>
<a name="ln4905">      template&lt;typename _ForwardIterator,</a>
<a name="ln4906">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln4907">	void</a>
<a name="ln4908">	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln4909">			_UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln4910">			const param_type&amp; __p);</a>
<a name="ln4911"> </a>
<a name="ln4912">      param_type _M_param;</a>
<a name="ln4913">    };</a>
<a name="ln4914"> </a>
<a name="ln4915">   /**</a>
<a name="ln4916">    * @brief Return true if two Weibull distributions have different</a>
<a name="ln4917">    *        parameters.</a>
<a name="ln4918">    */</a>
<a name="ln4919">  template&lt;typename _RealType&gt;</a>
<a name="ln4920">    inline bool</a>
<a name="ln4921">    operator!=(const std::weibull_distribution&lt;_RealType&gt;&amp; __d1,</a>
<a name="ln4922">	       const std::weibull_distribution&lt;_RealType&gt;&amp; __d2)</a>
<a name="ln4923">    { return !(__d1 == __d2); }</a>
<a name="ln4924"> </a>
<a name="ln4925">  /**</a>
<a name="ln4926">   * @brief Inserts a %weibull_distribution random number distribution</a>
<a name="ln4927">   * @p __x into the output stream @p __os.</a>
<a name="ln4928">   *</a>
<a name="ln4929">   * @param __os An output stream.</a>
<a name="ln4930">   * @param __x  A %weibull_distribution random number distribution.</a>
<a name="ln4931">   *</a>
<a name="ln4932">   * @returns The output stream with the state of @p __x inserted or in</a>
<a name="ln4933">   * an error state.</a>
<a name="ln4934">   */</a>
<a name="ln4935">  template&lt;typename _RealType, typename _CharT, typename _Traits&gt;</a>
<a name="ln4936">    std::basic_ostream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln4937">    operator&lt;&lt;(std::basic_ostream&lt;_CharT, _Traits&gt;&amp; __os,</a>
<a name="ln4938">	       const std::weibull_distribution&lt;_RealType&gt;&amp; __x);</a>
<a name="ln4939"> </a>
<a name="ln4940">  /**</a>
<a name="ln4941">   * @brief Extracts a %weibull_distribution random number distribution</a>
<a name="ln4942">   * @p __x from the input stream @p __is.</a>
<a name="ln4943">   *</a>
<a name="ln4944">   * @param __is An input stream.</a>
<a name="ln4945">   * @param __x A %weibull_distribution random number</a>
<a name="ln4946">   *            generator engine.</a>
<a name="ln4947">   *</a>
<a name="ln4948">   * @returns The input stream with @p __x extracted or in an error state.</a>
<a name="ln4949">   */</a>
<a name="ln4950">  template&lt;typename _RealType, typename _CharT, typename _Traits&gt;</a>
<a name="ln4951">    std::basic_istream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln4952">    operator&gt;&gt;(std::basic_istream&lt;_CharT, _Traits&gt;&amp; __is,</a>
<a name="ln4953">	       std::weibull_distribution&lt;_RealType&gt;&amp; __x);</a>
<a name="ln4954"> </a>
<a name="ln4955"> </a>
<a name="ln4956">  /**</a>
<a name="ln4957">   * @brief A extreme_value_distribution random number distribution.</a>
<a name="ln4958">   *</a>
<a name="ln4959">   * The formula for the normal probability mass function is</a>
<a name="ln4960">   * @f[</a>
<a name="ln4961">   *     p(x|a,b) = \frac{1}{b}</a>
<a name="ln4962">   *                \exp( \frac{a-x}{b} - \exp(\frac{a-x}{b})) </a>
<a name="ln4963">   * @f]</a>
<a name="ln4964">   */</a>
<a name="ln4965">  template&lt;typename _RealType = double&gt;</a>
<a name="ln4966">    class extreme_value_distribution</a>
<a name="ln4967">    {</a>
<a name="ln4968">      static_assert(std::is_floating_point&lt;_RealType&gt;::value,</a>
<a name="ln4969">		    &quot;result_type must be a floating point type&quot;);</a>
<a name="ln4970"> </a>
<a name="ln4971">    public:</a>
<a name="ln4972">      /** The type of the range of the distribution. */</a>
<a name="ln4973">      typedef _RealType result_type;</a>
<a name="ln4974"> </a>
<a name="ln4975">      /** Parameter type. */</a>
<a name="ln4976">      struct param_type</a>
<a name="ln4977">      {</a>
<a name="ln4978">	typedef extreme_value_distribution&lt;_RealType&gt; distribution_type;</a>
<a name="ln4979"> </a>
<a name="ln4980">	explicit</a>
<a name="ln4981">	param_type(_RealType __a = _RealType(0),</a>
<a name="ln4982">		   _RealType __b = _RealType(1))</a>
<a name="ln4983">	: _M_a(__a), _M_b(__b)</a>
<a name="ln4984">	{ }</a>
<a name="ln4985"> </a>
<a name="ln4986">	_RealType</a>
<a name="ln4987">	a() const</a>
<a name="ln4988">	{ return _M_a; }</a>
<a name="ln4989"> </a>
<a name="ln4990">	_RealType</a>
<a name="ln4991">	b() const</a>
<a name="ln4992">	{ return _M_b; }</a>
<a name="ln4993"> </a>
<a name="ln4994">	friend bool</a>
<a name="ln4995">	operator==(const param_type&amp; __p1, const param_type&amp; __p2)</a>
<a name="ln4996">	{ return __p1._M_a == __p2._M_a &amp;&amp; __p1._M_b == __p2._M_b; }</a>
<a name="ln4997"> </a>
<a name="ln4998">	friend bool</a>
<a name="ln4999">	operator!=(const param_type&amp; __p1, const param_type&amp; __p2)</a>
<a name="ln5000">	{ return !(__p1 == __p2); }</a>
<a name="ln5001"> </a>
<a name="ln5002">      private:</a>
<a name="ln5003">	_RealType _M_a;</a>
<a name="ln5004">	_RealType _M_b;</a>
<a name="ln5005">      };</a>
<a name="ln5006"> </a>
<a name="ln5007">      explicit</a>
<a name="ln5008">      extreme_value_distribution(_RealType __a = _RealType(0),</a>
<a name="ln5009">				 _RealType __b = _RealType(1))</a>
<a name="ln5010">      : _M_param(__a, __b)</a>
<a name="ln5011">      { }</a>
<a name="ln5012"> </a>
<a name="ln5013">      explicit</a>
<a name="ln5014">      extreme_value_distribution(const param_type&amp; __p)</a>
<a name="ln5015">      : _M_param(__p)</a>
<a name="ln5016">      { }</a>
<a name="ln5017"> </a>
<a name="ln5018">      /**</a>
<a name="ln5019">       * @brief Resets the distribution state.</a>
<a name="ln5020">       */</a>
<a name="ln5021">      void</a>
<a name="ln5022">      reset()</a>
<a name="ln5023">      { }</a>
<a name="ln5024"> </a>
<a name="ln5025">      /**</a>
<a name="ln5026">       * @brief Return the @f$a@f$ parameter of the distribution.</a>
<a name="ln5027">       */</a>
<a name="ln5028">      _RealType</a>
<a name="ln5029">      a() const</a>
<a name="ln5030">      { return _M_param.a(); }</a>
<a name="ln5031"> </a>
<a name="ln5032">      /**</a>
<a name="ln5033">       * @brief Return the @f$b@f$ parameter of the distribution.</a>
<a name="ln5034">       */</a>
<a name="ln5035">      _RealType</a>
<a name="ln5036">      b() const</a>
<a name="ln5037">      { return _M_param.b(); }</a>
<a name="ln5038"> </a>
<a name="ln5039">      /**</a>
<a name="ln5040">       * @brief Returns the parameter set of the distribution.</a>
<a name="ln5041">       */</a>
<a name="ln5042">      param_type</a>
<a name="ln5043">      param() const</a>
<a name="ln5044">      { return _M_param; }</a>
<a name="ln5045"> </a>
<a name="ln5046">      /**</a>
<a name="ln5047">       * @brief Sets the parameter set of the distribution.</a>
<a name="ln5048">       * @param __param The new parameter set of the distribution.</a>
<a name="ln5049">       */</a>
<a name="ln5050">      void</a>
<a name="ln5051">      param(const param_type&amp; __param)</a>
<a name="ln5052">      { _M_param = __param; }</a>
<a name="ln5053"> </a>
<a name="ln5054">      /**</a>
<a name="ln5055">       * @brief Returns the greatest lower bound value of the distribution.</a>
<a name="ln5056">       */</a>
<a name="ln5057">      result_type</a>
<a name="ln5058">      min() const</a>
<a name="ln5059">      { return std::numeric_limits&lt;result_type&gt;::lowest(); }</a>
<a name="ln5060"> </a>
<a name="ln5061">      /**</a>
<a name="ln5062">       * @brief Returns the least upper bound value of the distribution.</a>
<a name="ln5063">       */</a>
<a name="ln5064">      result_type</a>
<a name="ln5065">      max() const</a>
<a name="ln5066">      { return std::numeric_limits&lt;result_type&gt;::max(); }</a>
<a name="ln5067"> </a>
<a name="ln5068">      /**</a>
<a name="ln5069">       * @brief Generating functions.</a>
<a name="ln5070">       */</a>
<a name="ln5071">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln5072">	result_type</a>
<a name="ln5073">	operator()(_UniformRandomNumberGenerator&amp; __urng)</a>
<a name="ln5074">	{ return this-&gt;operator()(__urng, _M_param); }</a>
<a name="ln5075"> </a>
<a name="ln5076">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln5077">	result_type</a>
<a name="ln5078">	operator()(_UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln5079">		   const param_type&amp; __p);</a>
<a name="ln5080"> </a>
<a name="ln5081">      template&lt;typename _ForwardIterator,</a>
<a name="ln5082">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln5083">	void</a>
<a name="ln5084">	__generate(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln5085">		   _UniformRandomNumberGenerator&amp; __urng)</a>
<a name="ln5086">	{ this-&gt;__generate(__f, __t, __urng, _M_param); }</a>
<a name="ln5087"> </a>
<a name="ln5088">      template&lt;typename _ForwardIterator,</a>
<a name="ln5089">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln5090">	void</a>
<a name="ln5091">	__generate(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln5092">		   _UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln5093">		   const param_type&amp; __p)</a>
<a name="ln5094">	{ this-&gt;__generate_impl(__f, __t, __urng, __p); }</a>
<a name="ln5095"> </a>
<a name="ln5096">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln5097">	void</a>
<a name="ln5098">	__generate(result_type* __f, result_type* __t,</a>
<a name="ln5099">		   _UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln5100">		   const param_type&amp; __p)</a>
<a name="ln5101">	{ this-&gt;__generate_impl(__f, __t, __urng, __p); }</a>
<a name="ln5102"> </a>
<a name="ln5103">      /**</a>
<a name="ln5104">       * @brief Return true if two extreme value distributions have the same</a>
<a name="ln5105">       *        parameters.</a>
<a name="ln5106">       */</a>
<a name="ln5107">      friend bool</a>
<a name="ln5108">      operator==(const extreme_value_distribution&amp; __d1,</a>
<a name="ln5109">		 const extreme_value_distribution&amp; __d2)</a>
<a name="ln5110">      { return __d1._M_param == __d2._M_param; }</a>
<a name="ln5111"> </a>
<a name="ln5112">    private:</a>
<a name="ln5113">      template&lt;typename _ForwardIterator,</a>
<a name="ln5114">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln5115">	void</a>
<a name="ln5116">	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln5117">			_UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln5118">			const param_type&amp; __p);</a>
<a name="ln5119"> </a>
<a name="ln5120">      param_type _M_param;</a>
<a name="ln5121">    };</a>
<a name="ln5122"> </a>
<a name="ln5123">  /**</a>
<a name="ln5124">    * @brief Return true if two extreme value distributions have different</a>
<a name="ln5125">    *        parameters.</a>
<a name="ln5126">   */</a>
<a name="ln5127">  template&lt;typename _RealType&gt;</a>
<a name="ln5128">    inline bool</a>
<a name="ln5129">    operator!=(const std::extreme_value_distribution&lt;_RealType&gt;&amp; __d1,</a>
<a name="ln5130">	       const std::extreme_value_distribution&lt;_RealType&gt;&amp; __d2)</a>
<a name="ln5131">    { return !(__d1 == __d2); }</a>
<a name="ln5132"> </a>
<a name="ln5133">  /**</a>
<a name="ln5134">   * @brief Inserts a %extreme_value_distribution random number distribution</a>
<a name="ln5135">   * @p __x into the output stream @p __os.</a>
<a name="ln5136">   *</a>
<a name="ln5137">   * @param __os An output stream.</a>
<a name="ln5138">   * @param __x  A %extreme_value_distribution random number distribution.</a>
<a name="ln5139">   *</a>
<a name="ln5140">   * @returns The output stream with the state of @p __x inserted or in</a>
<a name="ln5141">   * an error state.</a>
<a name="ln5142">   */</a>
<a name="ln5143">  template&lt;typename _RealType, typename _CharT, typename _Traits&gt;</a>
<a name="ln5144">    std::basic_ostream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln5145">    operator&lt;&lt;(std::basic_ostream&lt;_CharT, _Traits&gt;&amp; __os,</a>
<a name="ln5146">	       const std::extreme_value_distribution&lt;_RealType&gt;&amp; __x);</a>
<a name="ln5147"> </a>
<a name="ln5148">  /**</a>
<a name="ln5149">   * @brief Extracts a %extreme_value_distribution random number</a>
<a name="ln5150">   *        distribution @p __x from the input stream @p __is.</a>
<a name="ln5151">   *</a>
<a name="ln5152">   * @param __is An input stream.</a>
<a name="ln5153">   * @param __x A %extreme_value_distribution random number</a>
<a name="ln5154">   *            generator engine.</a>
<a name="ln5155">   *</a>
<a name="ln5156">   * @returns The input stream with @p __x extracted or in an error state.</a>
<a name="ln5157">   */</a>
<a name="ln5158">  template&lt;typename _RealType, typename _CharT, typename _Traits&gt;</a>
<a name="ln5159">    std::basic_istream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln5160">    operator&gt;&gt;(std::basic_istream&lt;_CharT, _Traits&gt;&amp; __is,</a>
<a name="ln5161">	       std::extreme_value_distribution&lt;_RealType&gt;&amp; __x);</a>
<a name="ln5162"> </a>
<a name="ln5163"> </a>
<a name="ln5164">  /**</a>
<a name="ln5165">   * @brief A discrete_distribution random number distribution.</a>
<a name="ln5166">   *</a>
<a name="ln5167">   * The formula for the discrete probability mass function is</a>
<a name="ln5168">   *</a>
<a name="ln5169">   */</a>
<a name="ln5170">  template&lt;typename _IntType = int&gt;</a>
<a name="ln5171">    class discrete_distribution</a>
<a name="ln5172">    {</a>
<a name="ln5173">      static_assert(std::is_integral&lt;_IntType&gt;::value,</a>
<a name="ln5174">		    &quot;result_type must be an integral type&quot;);</a>
<a name="ln5175"> </a>
<a name="ln5176">    public:</a>
<a name="ln5177">      /** The type of the range of the distribution. */</a>
<a name="ln5178">      typedef _IntType result_type;</a>
<a name="ln5179"> </a>
<a name="ln5180">      /** Parameter type. */</a>
<a name="ln5181">      struct param_type</a>
<a name="ln5182">      {</a>
<a name="ln5183">	typedef discrete_distribution&lt;_IntType&gt; distribution_type;</a>
<a name="ln5184">	friend class discrete_distribution&lt;_IntType&gt;;</a>
<a name="ln5185"> </a>
<a name="ln5186">	param_type()</a>
<a name="ln5187">	: _M_prob(), _M_cp()</a>
<a name="ln5188">	{ }</a>
<a name="ln5189"> </a>
<a name="ln5190">	template&lt;typename _InputIterator&gt;</a>
<a name="ln5191">	  param_type(_InputIterator __wbegin,</a>
<a name="ln5192">		     _InputIterator __wend)</a>
<a name="ln5193">	  : _M_prob(__wbegin, __wend), _M_cp()</a>
<a name="ln5194">	  { _M_initialize(); }</a>
<a name="ln5195"> </a>
<a name="ln5196">	param_type(initializer_list&lt;double&gt; __wil)</a>
<a name="ln5197">	: _M_prob(__wil.begin(), __wil.end()), _M_cp()</a>
<a name="ln5198">	{ _M_initialize(); }</a>
<a name="ln5199"> </a>
<a name="ln5200">	template&lt;typename _Func&gt;</a>
<a name="ln5201">	  param_type(size_t __nw, double __xmin, double __xmax,</a>
<a name="ln5202">		     _Func __fw);</a>
<a name="ln5203"> </a>
<a name="ln5204">	// See: http://cpp-next.com/archive/2010/10/implicit-move-must-go/</a>
<a name="ln5205">	param_type(const param_type&amp;) = default;</a>
<a name="ln5206">	param_type&amp; operator=(const param_type&amp;) = default;</a>
<a name="ln5207"> </a>
<a name="ln5208">	std::vector&lt;double&gt;</a>
<a name="ln5209">	probabilities() const</a>
<a name="ln5210">	{ return _M_prob.empty() ? std::vector&lt;double&gt;(1, 1.0) : _M_prob; }</a>
<a name="ln5211"> </a>
<a name="ln5212">	friend bool</a>
<a name="ln5213">	operator==(const param_type&amp; __p1, const param_type&amp; __p2)</a>
<a name="ln5214">	{ return __p1._M_prob == __p2._M_prob; }</a>
<a name="ln5215"> </a>
<a name="ln5216">	friend bool</a>
<a name="ln5217">	operator!=(const param_type&amp; __p1, const param_type&amp; __p2)</a>
<a name="ln5218">	{ return !(__p1 == __p2); }</a>
<a name="ln5219"> </a>
<a name="ln5220">      private:</a>
<a name="ln5221">	void</a>
<a name="ln5222">	_M_initialize();</a>
<a name="ln5223"> </a>
<a name="ln5224">	std::vector&lt;double&gt; _M_prob;</a>
<a name="ln5225">	std::vector&lt;double&gt; _M_cp;</a>
<a name="ln5226">      };</a>
<a name="ln5227"> </a>
<a name="ln5228">      discrete_distribution()</a>
<a name="ln5229">      : _M_param()</a>
<a name="ln5230">      { }</a>
<a name="ln5231"> </a>
<a name="ln5232">      template&lt;typename _InputIterator&gt;</a>
<a name="ln5233">	discrete_distribution(_InputIterator __wbegin,</a>
<a name="ln5234">			      _InputIterator __wend)</a>
<a name="ln5235">	: _M_param(__wbegin, __wend)</a>
<a name="ln5236">	{ }</a>
<a name="ln5237"> </a>
<a name="ln5238">      discrete_distribution(initializer_list&lt;double&gt; __wl)</a>
<a name="ln5239">      : _M_param(__wl)</a>
<a name="ln5240">      { }</a>
<a name="ln5241"> </a>
<a name="ln5242">      template&lt;typename _Func&gt;</a>
<a name="ln5243">	discrete_distribution(size_t __nw, double __xmin, double __xmax,</a>
<a name="ln5244">			      _Func __fw)</a>
<a name="ln5245">	: _M_param(__nw, __xmin, __xmax, __fw)</a>
<a name="ln5246">	{ }</a>
<a name="ln5247"> </a>
<a name="ln5248">      explicit</a>
<a name="ln5249">      discrete_distribution(const param_type&amp; __p)</a>
<a name="ln5250">      : _M_param(__p)</a>
<a name="ln5251">      { }</a>
<a name="ln5252"> </a>
<a name="ln5253">      /**</a>
<a name="ln5254">       * @brief Resets the distribution state.</a>
<a name="ln5255">       */</a>
<a name="ln5256">      void</a>
<a name="ln5257">      reset()</a>
<a name="ln5258">      { }</a>
<a name="ln5259"> </a>
<a name="ln5260">      /**</a>
<a name="ln5261">       * @brief Returns the probabilities of the distribution.</a>
<a name="ln5262">       */</a>
<a name="ln5263">      std::vector&lt;double&gt;</a>
<a name="ln5264">      probabilities() const</a>
<a name="ln5265">      {</a>
<a name="ln5266">	return _M_param._M_prob.empty()</a>
<a name="ln5267">	  ? std::vector&lt;double&gt;(1, 1.0) : _M_param._M_prob;</a>
<a name="ln5268">      }</a>
<a name="ln5269"> </a>
<a name="ln5270">      /**</a>
<a name="ln5271">       * @brief Returns the parameter set of the distribution.</a>
<a name="ln5272">       */</a>
<a name="ln5273">      param_type</a>
<a name="ln5274">      param() const</a>
<a name="ln5275">      { return _M_param; }</a>
<a name="ln5276"> </a>
<a name="ln5277">      /**</a>
<a name="ln5278">       * @brief Sets the parameter set of the distribution.</a>
<a name="ln5279">       * @param __param The new parameter set of the distribution.</a>
<a name="ln5280">       */</a>
<a name="ln5281">      void</a>
<a name="ln5282">      param(const param_type&amp; __param)</a>
<a name="ln5283">      { _M_param = __param; }</a>
<a name="ln5284"> </a>
<a name="ln5285">      /**</a>
<a name="ln5286">       * @brief Returns the greatest lower bound value of the distribution.</a>
<a name="ln5287">       */</a>
<a name="ln5288">      result_type</a>
<a name="ln5289">      min() const</a>
<a name="ln5290">      { return result_type(0); }</a>
<a name="ln5291"> </a>
<a name="ln5292">      /**</a>
<a name="ln5293">       * @brief Returns the least upper bound value of the distribution.</a>
<a name="ln5294">       */</a>
<a name="ln5295">      result_type</a>
<a name="ln5296">      max() const</a>
<a name="ln5297">      {</a>
<a name="ln5298">	return _M_param._M_prob.empty()</a>
<a name="ln5299">	  ? result_type(0) : result_type(_M_param._M_prob.size() - 1);</a>
<a name="ln5300">      }</a>
<a name="ln5301"> </a>
<a name="ln5302">      /**</a>
<a name="ln5303">       * @brief Generating functions.</a>
<a name="ln5304">       */</a>
<a name="ln5305">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln5306">	result_type</a>
<a name="ln5307">	operator()(_UniformRandomNumberGenerator&amp; __urng)</a>
<a name="ln5308">	{ return this-&gt;operator()(__urng, _M_param); }</a>
<a name="ln5309"> </a>
<a name="ln5310">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln5311">	result_type</a>
<a name="ln5312">	operator()(_UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln5313">		   const param_type&amp; __p);</a>
<a name="ln5314"> </a>
<a name="ln5315">      template&lt;typename _ForwardIterator,</a>
<a name="ln5316">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln5317">	void</a>
<a name="ln5318">	__generate(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln5319">		   _UniformRandomNumberGenerator&amp; __urng)</a>
<a name="ln5320">	{ this-&gt;__generate(__f, __t, __urng, _M_param); }</a>
<a name="ln5321"> </a>
<a name="ln5322">      template&lt;typename _ForwardIterator,</a>
<a name="ln5323">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln5324">	void</a>
<a name="ln5325">	__generate(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln5326">		   _UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln5327">		   const param_type&amp; __p)</a>
<a name="ln5328">	{ this-&gt;__generate_impl(__f, __t, __urng, __p); }</a>
<a name="ln5329"> </a>
<a name="ln5330">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln5331">	void</a>
<a name="ln5332">	__generate(result_type* __f, result_type* __t,</a>
<a name="ln5333">		   _UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln5334">		   const param_type&amp; __p)</a>
<a name="ln5335">	{ this-&gt;__generate_impl(__f, __t, __urng, __p); }</a>
<a name="ln5336"> </a>
<a name="ln5337">      /**</a>
<a name="ln5338">       * @brief Return true if two discrete distributions have the same</a>
<a name="ln5339">       *        parameters.</a>
<a name="ln5340">       */</a>
<a name="ln5341">      friend bool</a>
<a name="ln5342">      operator==(const discrete_distribution&amp; __d1,</a>
<a name="ln5343">		 const discrete_distribution&amp; __d2)</a>
<a name="ln5344">      { return __d1._M_param == __d2._M_param; }</a>
<a name="ln5345"> </a>
<a name="ln5346">      /**</a>
<a name="ln5347">       * @brief Inserts a %discrete_distribution random number distribution</a>
<a name="ln5348">       * @p __x into the output stream @p __os.</a>
<a name="ln5349">       *</a>
<a name="ln5350">       * @param __os An output stream.</a>
<a name="ln5351">       * @param __x  A %discrete_distribution random number distribution.</a>
<a name="ln5352">       *</a>
<a name="ln5353">       * @returns The output stream with the state of @p __x inserted or in</a>
<a name="ln5354">       * an error state.</a>
<a name="ln5355">       */</a>
<a name="ln5356">      template&lt;typename _IntType1, typename _CharT, typename _Traits&gt;</a>
<a name="ln5357">	friend std::basic_ostream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln5358">	operator&lt;&lt;(std::basic_ostream&lt;_CharT, _Traits&gt;&amp; __os,</a>
<a name="ln5359">		   const std::discrete_distribution&lt;_IntType1&gt;&amp; __x);</a>
<a name="ln5360"> </a>
<a name="ln5361">      /**</a>
<a name="ln5362">       * @brief Extracts a %discrete_distribution random number distribution</a>
<a name="ln5363">       * @p __x from the input stream @p __is.</a>
<a name="ln5364">       *</a>
<a name="ln5365">       * @param __is An input stream.</a>
<a name="ln5366">       * @param __x A %discrete_distribution random number</a>
<a name="ln5367">       *            generator engine.</a>
<a name="ln5368">       *</a>
<a name="ln5369">       * @returns The input stream with @p __x extracted or in an error</a>
<a name="ln5370">       *          state.</a>
<a name="ln5371">       */</a>
<a name="ln5372">      template&lt;typename _IntType1, typename _CharT, typename _Traits&gt;</a>
<a name="ln5373">	friend std::basic_istream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln5374">	operator&gt;&gt;(std::basic_istream&lt;_CharT, _Traits&gt;&amp; __is,</a>
<a name="ln5375">		   std::discrete_distribution&lt;_IntType1&gt;&amp; __x);</a>
<a name="ln5376"> </a>
<a name="ln5377">    private:</a>
<a name="ln5378">      template&lt;typename _ForwardIterator,</a>
<a name="ln5379">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln5380">	void</a>
<a name="ln5381">	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln5382">			_UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln5383">			const param_type&amp; __p);</a>
<a name="ln5384"> </a>
<a name="ln5385">      param_type _M_param;</a>
<a name="ln5386">    };</a>
<a name="ln5387"> </a>
<a name="ln5388">  /**</a>
<a name="ln5389">    * @brief Return true if two discrete distributions have different</a>
<a name="ln5390">    *        parameters.</a>
<a name="ln5391">    */</a>
<a name="ln5392">  template&lt;typename _IntType&gt;</a>
<a name="ln5393">    inline bool</a>
<a name="ln5394">    operator!=(const std::discrete_distribution&lt;_IntType&gt;&amp; __d1,</a>
<a name="ln5395">	       const std::discrete_distribution&lt;_IntType&gt;&amp; __d2)</a>
<a name="ln5396">    { return !(__d1 == __d2); }</a>
<a name="ln5397"> </a>
<a name="ln5398"> </a>
<a name="ln5399">  /**</a>
<a name="ln5400">   * @brief A piecewise_constant_distribution random number distribution.</a>
<a name="ln5401">   *</a>
<a name="ln5402">   * The formula for the piecewise constant probability mass function is</a>
<a name="ln5403">   *</a>
<a name="ln5404">   */</a>
<a name="ln5405">  template&lt;typename _RealType = double&gt;</a>
<a name="ln5406">    class piecewise_constant_distribution</a>
<a name="ln5407">    {</a>
<a name="ln5408">      static_assert(std::is_floating_point&lt;_RealType&gt;::value,</a>
<a name="ln5409">		    &quot;result_type must be a floating point type&quot;);</a>
<a name="ln5410"> </a>
<a name="ln5411">    public:</a>
<a name="ln5412">      /** The type of the range of the distribution. */</a>
<a name="ln5413">      typedef _RealType result_type;</a>
<a name="ln5414"> </a>
<a name="ln5415">      /** Parameter type. */</a>
<a name="ln5416">      struct param_type</a>
<a name="ln5417">      {</a>
<a name="ln5418">	typedef piecewise_constant_distribution&lt;_RealType&gt; distribution_type;</a>
<a name="ln5419">	friend class piecewise_constant_distribution&lt;_RealType&gt;;</a>
<a name="ln5420"> </a>
<a name="ln5421">	param_type()</a>
<a name="ln5422">	: _M_int(), _M_den(), _M_cp()</a>
<a name="ln5423">	{ }</a>
<a name="ln5424"> </a>
<a name="ln5425">	template&lt;typename _InputIteratorB, typename _InputIteratorW&gt;</a>
<a name="ln5426">	  param_type(_InputIteratorB __bfirst,</a>
<a name="ln5427">		     _InputIteratorB __bend,</a>
<a name="ln5428">		     _InputIteratorW __wbegin);</a>
<a name="ln5429"> </a>
<a name="ln5430">	template&lt;typename _Func&gt;</a>
<a name="ln5431">	  param_type(initializer_list&lt;_RealType&gt; __bi, _Func __fw);</a>
<a name="ln5432"> </a>
<a name="ln5433">	template&lt;typename _Func&gt;</a>
<a name="ln5434">	  param_type(size_t __nw, _RealType __xmin, _RealType __xmax,</a>
<a name="ln5435">		     _Func __fw);</a>
<a name="ln5436"> </a>
<a name="ln5437">	// See: http://cpp-next.com/archive/2010/10/implicit-move-must-go/</a>
<a name="ln5438">	param_type(const param_type&amp;) = default;</a>
<a name="ln5439">	param_type&amp; operator=(const param_type&amp;) = default;</a>
<a name="ln5440"> </a>
<a name="ln5441">	std::vector&lt;_RealType&gt;</a>
<a name="ln5442">	intervals() const</a>
<a name="ln5443">	{</a>
<a name="ln5444">	  if (_M_int.empty())</a>
<a name="ln5445">	    {</a>
<a name="ln5446">	      std::vector&lt;_RealType&gt; __tmp(2);</a>
<a name="ln5447">	      __tmp[1] = _RealType(1);</a>
<a name="ln5448">	      return __tmp;</a>
<a name="ln5449">	    }</a>
<a name="ln5450">	  else</a>
<a name="ln5451">	    return _M_int;</a>
<a name="ln5452">	}</a>
<a name="ln5453"> </a>
<a name="ln5454">	std::vector&lt;double&gt;</a>
<a name="ln5455">	densities() const</a>
<a name="ln5456">	{ return _M_den.empty() ? std::vector&lt;double&gt;(1, 1.0) : _M_den; }</a>
<a name="ln5457"> </a>
<a name="ln5458">	friend bool</a>
<a name="ln5459">	operator==(const param_type&amp; __p1, const param_type&amp; __p2)</a>
<a name="ln5460">	{ return __p1._M_int == __p2._M_int &amp;&amp; __p1._M_den == __p2._M_den; }</a>
<a name="ln5461"> </a>
<a name="ln5462">	friend bool</a>
<a name="ln5463">	operator!=(const param_type&amp; __p1, const param_type&amp; __p2)</a>
<a name="ln5464">	{ return !(__p1 == __p2); }</a>
<a name="ln5465"> </a>
<a name="ln5466">      private:</a>
<a name="ln5467">	void</a>
<a name="ln5468">	_M_initialize();</a>
<a name="ln5469"> </a>
<a name="ln5470">	std::vector&lt;_RealType&gt; _M_int;</a>
<a name="ln5471">	std::vector&lt;double&gt; _M_den;</a>
<a name="ln5472">	std::vector&lt;double&gt; _M_cp;</a>
<a name="ln5473">      };</a>
<a name="ln5474"> </a>
<a name="ln5475">      explicit</a>
<a name="ln5476">      piecewise_constant_distribution()</a>
<a name="ln5477">      : _M_param()</a>
<a name="ln5478">      { }</a>
<a name="ln5479"> </a>
<a name="ln5480">      template&lt;typename _InputIteratorB, typename _InputIteratorW&gt;</a>
<a name="ln5481">	piecewise_constant_distribution(_InputIteratorB __bfirst,</a>
<a name="ln5482">					_InputIteratorB __bend,</a>
<a name="ln5483">					_InputIteratorW __wbegin)</a>
<a name="ln5484">	: _M_param(__bfirst, __bend, __wbegin)</a>
<a name="ln5485">	{ }</a>
<a name="ln5486"> </a>
<a name="ln5487">      template&lt;typename _Func&gt;</a>
<a name="ln5488">	piecewise_constant_distribution(initializer_list&lt;_RealType&gt; __bl,</a>
<a name="ln5489">					_Func __fw)</a>
<a name="ln5490">	: _M_param(__bl, __fw)</a>
<a name="ln5491">	{ }</a>
<a name="ln5492"> </a>
<a name="ln5493">      template&lt;typename _Func&gt;</a>
<a name="ln5494">	piecewise_constant_distribution(size_t __nw,</a>
<a name="ln5495">					_RealType __xmin, _RealType __xmax,</a>
<a name="ln5496">					_Func __fw)</a>
<a name="ln5497">	: _M_param(__nw, __xmin, __xmax, __fw)</a>
<a name="ln5498">	{ }</a>
<a name="ln5499"> </a>
<a name="ln5500">      explicit</a>
<a name="ln5501">      piecewise_constant_distribution(const param_type&amp; __p)</a>
<a name="ln5502">      : _M_param(__p)</a>
<a name="ln5503">      { }</a>
<a name="ln5504"> </a>
<a name="ln5505">      /**</a>
<a name="ln5506">       * @brief Resets the distribution state.</a>
<a name="ln5507">       */</a>
<a name="ln5508">      void</a>
<a name="ln5509">      reset()</a>
<a name="ln5510">      { }</a>
<a name="ln5511"> </a>
<a name="ln5512">      /**</a>
<a name="ln5513">       * @brief Returns a vector of the intervals.</a>
<a name="ln5514">       */</a>
<a name="ln5515">      std::vector&lt;_RealType&gt;</a>
<a name="ln5516">      intervals() const</a>
<a name="ln5517">      {</a>
<a name="ln5518">	if (_M_param._M_int.empty())</a>
<a name="ln5519">	  {</a>
<a name="ln5520">	    std::vector&lt;_RealType&gt; __tmp(2);</a>
<a name="ln5521">	    __tmp[1] = _RealType(1);</a>
<a name="ln5522">	    return __tmp;</a>
<a name="ln5523">	  }</a>
<a name="ln5524">	else</a>
<a name="ln5525">	  return _M_param._M_int;</a>
<a name="ln5526">      }</a>
<a name="ln5527"> </a>
<a name="ln5528">      /**</a>
<a name="ln5529">       * @brief Returns a vector of the probability densities.</a>
<a name="ln5530">       */</a>
<a name="ln5531">      std::vector&lt;double&gt;</a>
<a name="ln5532">      densities() const</a>
<a name="ln5533">      {</a>
<a name="ln5534">	return _M_param._M_den.empty()</a>
<a name="ln5535">	  ? std::vector&lt;double&gt;(1, 1.0) : _M_param._M_den;</a>
<a name="ln5536">      }</a>
<a name="ln5537"> </a>
<a name="ln5538">      /**</a>
<a name="ln5539">       * @brief Returns the parameter set of the distribution.</a>
<a name="ln5540">       */</a>
<a name="ln5541">      param_type</a>
<a name="ln5542">      param() const</a>
<a name="ln5543">      { return _M_param; }</a>
<a name="ln5544"> </a>
<a name="ln5545">      /**</a>
<a name="ln5546">       * @brief Sets the parameter set of the distribution.</a>
<a name="ln5547">       * @param __param The new parameter set of the distribution.</a>
<a name="ln5548">       */</a>
<a name="ln5549">      void</a>
<a name="ln5550">      param(const param_type&amp; __param)</a>
<a name="ln5551">      { _M_param = __param; }</a>
<a name="ln5552"> </a>
<a name="ln5553">      /**</a>
<a name="ln5554">       * @brief Returns the greatest lower bound value of the distribution.</a>
<a name="ln5555">       */</a>
<a name="ln5556">      result_type</a>
<a name="ln5557">      min() const</a>
<a name="ln5558">      {</a>
<a name="ln5559">	return _M_param._M_int.empty()</a>
<a name="ln5560">	  ? result_type(0) : _M_param._M_int.front();</a>
<a name="ln5561">      }</a>
<a name="ln5562"> </a>
<a name="ln5563">      /**</a>
<a name="ln5564">       * @brief Returns the least upper bound value of the distribution.</a>
<a name="ln5565">       */</a>
<a name="ln5566">      result_type</a>
<a name="ln5567">      max() const</a>
<a name="ln5568">      {</a>
<a name="ln5569">	return _M_param._M_int.empty()</a>
<a name="ln5570">	  ? result_type(1) : _M_param._M_int.back();</a>
<a name="ln5571">      }</a>
<a name="ln5572"> </a>
<a name="ln5573">      /**</a>
<a name="ln5574">       * @brief Generating functions.</a>
<a name="ln5575">       */</a>
<a name="ln5576">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln5577">	result_type</a>
<a name="ln5578">	operator()(_UniformRandomNumberGenerator&amp; __urng)</a>
<a name="ln5579">	{ return this-&gt;operator()(__urng, _M_param); }</a>
<a name="ln5580"> </a>
<a name="ln5581">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln5582">	result_type</a>
<a name="ln5583">	operator()(_UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln5584">		   const param_type&amp; __p);</a>
<a name="ln5585"> </a>
<a name="ln5586">      template&lt;typename _ForwardIterator,</a>
<a name="ln5587">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln5588">	void</a>
<a name="ln5589">	__generate(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln5590">		   _UniformRandomNumberGenerator&amp; __urng)</a>
<a name="ln5591">	{ this-&gt;__generate(__f, __t, __urng, _M_param); }</a>
<a name="ln5592"> </a>
<a name="ln5593">      template&lt;typename _ForwardIterator,</a>
<a name="ln5594">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln5595">	void</a>
<a name="ln5596">	__generate(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln5597">		   _UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln5598">		   const param_type&amp; __p)</a>
<a name="ln5599">	{ this-&gt;__generate_impl(__f, __t, __urng, __p); }</a>
<a name="ln5600"> </a>
<a name="ln5601">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln5602">	void</a>
<a name="ln5603">	__generate(result_type* __f, result_type* __t,</a>
<a name="ln5604">		   _UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln5605">		   const param_type&amp; __p)</a>
<a name="ln5606">	{ this-&gt;__generate_impl(__f, __t, __urng, __p); }</a>
<a name="ln5607"> </a>
<a name="ln5608">      /**</a>
<a name="ln5609">       * @brief Return true if two piecewise constant distributions have the</a>
<a name="ln5610">       *        same parameters.</a>
<a name="ln5611">       */</a>
<a name="ln5612">      friend bool</a>
<a name="ln5613">      operator==(const piecewise_constant_distribution&amp; __d1,</a>
<a name="ln5614">		 const piecewise_constant_distribution&amp; __d2)</a>
<a name="ln5615">      { return __d1._M_param == __d2._M_param; }</a>
<a name="ln5616"> </a>
<a name="ln5617">      /**</a>
<a name="ln5618">       * @brief Inserts a %piecewise_constant_distribution random</a>
<a name="ln5619">       *        number distribution @p __x into the output stream @p __os.</a>
<a name="ln5620">       *</a>
<a name="ln5621">       * @param __os An output stream.</a>
<a name="ln5622">       * @param __x  A %piecewise_constant_distribution random number</a>
<a name="ln5623">       *             distribution.</a>
<a name="ln5624">       *</a>
<a name="ln5625">       * @returns The output stream with the state of @p __x inserted or in</a>
<a name="ln5626">       * an error state.</a>
<a name="ln5627">       */</a>
<a name="ln5628">      template&lt;typename _RealType1, typename _CharT, typename _Traits&gt;</a>
<a name="ln5629">	friend std::basic_ostream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln5630">	operator&lt;&lt;(std::basic_ostream&lt;_CharT, _Traits&gt;&amp; __os,</a>
<a name="ln5631">		   const std::piecewise_constant_distribution&lt;_RealType1&gt;&amp; __x);</a>
<a name="ln5632"> </a>
<a name="ln5633">      /**</a>
<a name="ln5634">       * @brief Extracts a %piecewise_constant_distribution random</a>
<a name="ln5635">       *        number distribution @p __x from the input stream @p __is.</a>
<a name="ln5636">       *</a>
<a name="ln5637">       * @param __is An input stream.</a>
<a name="ln5638">       * @param __x A %piecewise_constant_distribution random number</a>
<a name="ln5639">       *            generator engine.</a>
<a name="ln5640">       *</a>
<a name="ln5641">       * @returns The input stream with @p __x extracted or in an error</a>
<a name="ln5642">       *          state.</a>
<a name="ln5643">       */</a>
<a name="ln5644">      template&lt;typename _RealType1, typename _CharT, typename _Traits&gt;</a>
<a name="ln5645">	friend std::basic_istream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln5646">	operator&gt;&gt;(std::basic_istream&lt;_CharT, _Traits&gt;&amp; __is,</a>
<a name="ln5647">		   std::piecewise_constant_distribution&lt;_RealType1&gt;&amp; __x);</a>
<a name="ln5648"> </a>
<a name="ln5649">    private:</a>
<a name="ln5650">      template&lt;typename _ForwardIterator,</a>
<a name="ln5651">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln5652">	void</a>
<a name="ln5653">	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln5654">			_UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln5655">			const param_type&amp; __p);</a>
<a name="ln5656"> </a>
<a name="ln5657">      param_type _M_param;</a>
<a name="ln5658">    };</a>
<a name="ln5659"> </a>
<a name="ln5660">  /**</a>
<a name="ln5661">    * @brief Return true if two piecewise constant distributions have </a>
<a name="ln5662">    *        different parameters.</a>
<a name="ln5663">   */</a>
<a name="ln5664">  template&lt;typename _RealType&gt;</a>
<a name="ln5665">    inline bool</a>
<a name="ln5666">    operator!=(const std::piecewise_constant_distribution&lt;_RealType&gt;&amp; __d1,</a>
<a name="ln5667">	       const std::piecewise_constant_distribution&lt;_RealType&gt;&amp; __d2)</a>
<a name="ln5668">    { return !(__d1 == __d2); }</a>
<a name="ln5669"> </a>
<a name="ln5670"> </a>
<a name="ln5671">  /**</a>
<a name="ln5672">   * @brief A piecewise_linear_distribution random number distribution.</a>
<a name="ln5673">   *</a>
<a name="ln5674">   * The formula for the piecewise linear probability mass function is</a>
<a name="ln5675">   *</a>
<a name="ln5676">   */</a>
<a name="ln5677">  template&lt;typename _RealType = double&gt;</a>
<a name="ln5678">    class piecewise_linear_distribution</a>
<a name="ln5679">    {</a>
<a name="ln5680">      static_assert(std::is_floating_point&lt;_RealType&gt;::value,</a>
<a name="ln5681">		    &quot;result_type must be a floating point type&quot;);</a>
<a name="ln5682"> </a>
<a name="ln5683">    public:</a>
<a name="ln5684">      /** The type of the range of the distribution. */</a>
<a name="ln5685">      typedef _RealType result_type;</a>
<a name="ln5686"> </a>
<a name="ln5687">      /** Parameter type. */</a>
<a name="ln5688">      struct param_type</a>
<a name="ln5689">      {</a>
<a name="ln5690">	typedef piecewise_linear_distribution&lt;_RealType&gt; distribution_type;</a>
<a name="ln5691">	friend class piecewise_linear_distribution&lt;_RealType&gt;;</a>
<a name="ln5692"> </a>
<a name="ln5693">	param_type()</a>
<a name="ln5694">	: _M_int(), _M_den(), _M_cp(), _M_m()</a>
<a name="ln5695">	{ }</a>
<a name="ln5696"> </a>
<a name="ln5697">	template&lt;typename _InputIteratorB, typename _InputIteratorW&gt;</a>
<a name="ln5698">	  param_type(_InputIteratorB __bfirst,</a>
<a name="ln5699">		     _InputIteratorB __bend,</a>
<a name="ln5700">		     _InputIteratorW __wbegin);</a>
<a name="ln5701"> </a>
<a name="ln5702">	template&lt;typename _Func&gt;</a>
<a name="ln5703">	  param_type(initializer_list&lt;_RealType&gt; __bl, _Func __fw);</a>
<a name="ln5704"> </a>
<a name="ln5705">	template&lt;typename _Func&gt;</a>
<a name="ln5706">	  param_type(size_t __nw, _RealType __xmin, _RealType __xmax,</a>
<a name="ln5707">		     _Func __fw);</a>
<a name="ln5708"> </a>
<a name="ln5709">	// See: http://cpp-next.com/archive/2010/10/implicit-move-must-go/</a>
<a name="ln5710">	param_type(const param_type&amp;) = default;</a>
<a name="ln5711">	param_type&amp; operator=(const param_type&amp;) = default;</a>
<a name="ln5712"> </a>
<a name="ln5713">	std::vector&lt;_RealType&gt;</a>
<a name="ln5714">	intervals() const</a>
<a name="ln5715">	{</a>
<a name="ln5716">	  if (_M_int.empty())</a>
<a name="ln5717">	    {</a>
<a name="ln5718">	      std::vector&lt;_RealType&gt; __tmp(2);</a>
<a name="ln5719">	      __tmp[1] = _RealType(1);</a>
<a name="ln5720">	      return __tmp;</a>
<a name="ln5721">	    }</a>
<a name="ln5722">	  else</a>
<a name="ln5723">	    return _M_int;</a>
<a name="ln5724">	}</a>
<a name="ln5725"> </a>
<a name="ln5726">	std::vector&lt;double&gt;</a>
<a name="ln5727">	densities() const</a>
<a name="ln5728">	{ return _M_den.empty() ? std::vector&lt;double&gt;(2, 1.0) : _M_den; }</a>
<a name="ln5729"> </a>
<a name="ln5730">	friend bool</a>
<a name="ln5731">	operator==(const param_type&amp; __p1, const param_type&amp; __p2)</a>
<a name="ln5732">	{ return __p1._M_int == __p2._M_int &amp;&amp; __p1._M_den == __p2._M_den; }</a>
<a name="ln5733"> </a>
<a name="ln5734">	friend bool</a>
<a name="ln5735">	operator!=(const param_type&amp; __p1, const param_type&amp; __p2)</a>
<a name="ln5736">	{ return !(__p1 == __p2); }</a>
<a name="ln5737"> </a>
<a name="ln5738">      private:</a>
<a name="ln5739">	void</a>
<a name="ln5740">	_M_initialize();</a>
<a name="ln5741"> </a>
<a name="ln5742">	std::vector&lt;_RealType&gt; _M_int;</a>
<a name="ln5743">	std::vector&lt;double&gt; _M_den;</a>
<a name="ln5744">	std::vector&lt;double&gt; _M_cp;</a>
<a name="ln5745">	std::vector&lt;double&gt; _M_m;</a>
<a name="ln5746">      };</a>
<a name="ln5747"> </a>
<a name="ln5748">      explicit</a>
<a name="ln5749">      piecewise_linear_distribution()</a>
<a name="ln5750">      : _M_param()</a>
<a name="ln5751">      { }</a>
<a name="ln5752"> </a>
<a name="ln5753">      template&lt;typename _InputIteratorB, typename _InputIteratorW&gt;</a>
<a name="ln5754">	piecewise_linear_distribution(_InputIteratorB __bfirst,</a>
<a name="ln5755">				      _InputIteratorB __bend,</a>
<a name="ln5756">				      _InputIteratorW __wbegin)</a>
<a name="ln5757">	: _M_param(__bfirst, __bend, __wbegin)</a>
<a name="ln5758">	{ }</a>
<a name="ln5759"> </a>
<a name="ln5760">      template&lt;typename _Func&gt;</a>
<a name="ln5761">	piecewise_linear_distribution(initializer_list&lt;_RealType&gt; __bl,</a>
<a name="ln5762">				      _Func __fw)</a>
<a name="ln5763">	: _M_param(__bl, __fw)</a>
<a name="ln5764">	{ }</a>
<a name="ln5765"> </a>
<a name="ln5766">      template&lt;typename _Func&gt;</a>
<a name="ln5767">	piecewise_linear_distribution(size_t __nw,</a>
<a name="ln5768">				      _RealType __xmin, _RealType __xmax,</a>
<a name="ln5769">				      _Func __fw)</a>
<a name="ln5770">	: _M_param(__nw, __xmin, __xmax, __fw)</a>
<a name="ln5771">	{ }</a>
<a name="ln5772"> </a>
<a name="ln5773">      explicit</a>
<a name="ln5774">      piecewise_linear_distribution(const param_type&amp; __p)</a>
<a name="ln5775">      : _M_param(__p)</a>
<a name="ln5776">      { }</a>
<a name="ln5777"> </a>
<a name="ln5778">      /**</a>
<a name="ln5779">       * Resets the distribution state.</a>
<a name="ln5780">       */</a>
<a name="ln5781">      void</a>
<a name="ln5782">      reset()</a>
<a name="ln5783">      { }</a>
<a name="ln5784"> </a>
<a name="ln5785">      /**</a>
<a name="ln5786">       * @brief Return the intervals of the distribution.</a>
<a name="ln5787">       */</a>
<a name="ln5788">      std::vector&lt;_RealType&gt;</a>
<a name="ln5789">      intervals() const</a>
<a name="ln5790">      {</a>
<a name="ln5791">	if (_M_param._M_int.empty())</a>
<a name="ln5792">	  {</a>
<a name="ln5793">	    std::vector&lt;_RealType&gt; __tmp(2);</a>
<a name="ln5794">	    __tmp[1] = _RealType(1);</a>
<a name="ln5795">	    return __tmp;</a>
<a name="ln5796">	  }</a>
<a name="ln5797">	else</a>
<a name="ln5798">	  return _M_param._M_int;</a>
<a name="ln5799">      }</a>
<a name="ln5800"> </a>
<a name="ln5801">      /**</a>
<a name="ln5802">       * @brief Return a vector of the probability densities of the</a>
<a name="ln5803">       *        distribution.</a>
<a name="ln5804">       */</a>
<a name="ln5805">      std::vector&lt;double&gt;</a>
<a name="ln5806">      densities() const</a>
<a name="ln5807">      {</a>
<a name="ln5808">	return _M_param._M_den.empty()</a>
<a name="ln5809">	  ? std::vector&lt;double&gt;(2, 1.0) : _M_param._M_den;</a>
<a name="ln5810">      }</a>
<a name="ln5811"> </a>
<a name="ln5812">      /**</a>
<a name="ln5813">       * @brief Returns the parameter set of the distribution.</a>
<a name="ln5814">       */</a>
<a name="ln5815">      param_type</a>
<a name="ln5816">      param() const</a>
<a name="ln5817">      { return _M_param; }</a>
<a name="ln5818"> </a>
<a name="ln5819">      /**</a>
<a name="ln5820">       * @brief Sets the parameter set of the distribution.</a>
<a name="ln5821">       * @param __param The new parameter set of the distribution.</a>
<a name="ln5822">       */</a>
<a name="ln5823">      void</a>
<a name="ln5824">      param(const param_type&amp; __param)</a>
<a name="ln5825">      { _M_param = __param; }</a>
<a name="ln5826"> </a>
<a name="ln5827">      /**</a>
<a name="ln5828">       * @brief Returns the greatest lower bound value of the distribution.</a>
<a name="ln5829">       */</a>
<a name="ln5830">      result_type</a>
<a name="ln5831">      min() const</a>
<a name="ln5832">      {</a>
<a name="ln5833">	return _M_param._M_int.empty()</a>
<a name="ln5834">	  ? result_type(0) : _M_param._M_int.front();</a>
<a name="ln5835">      }</a>
<a name="ln5836"> </a>
<a name="ln5837">      /**</a>
<a name="ln5838">       * @brief Returns the least upper bound value of the distribution.</a>
<a name="ln5839">       */</a>
<a name="ln5840">      result_type</a>
<a name="ln5841">      max() const</a>
<a name="ln5842">      {</a>
<a name="ln5843">	return _M_param._M_int.empty()</a>
<a name="ln5844">	  ? result_type(1) : _M_param._M_int.back();</a>
<a name="ln5845">      }</a>
<a name="ln5846"> </a>
<a name="ln5847">      /**</a>
<a name="ln5848">       * @brief Generating functions.</a>
<a name="ln5849">       */</a>
<a name="ln5850">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln5851">	result_type</a>
<a name="ln5852">	operator()(_UniformRandomNumberGenerator&amp; __urng)</a>
<a name="ln5853">	{ return this-&gt;operator()(__urng, _M_param); }</a>
<a name="ln5854"> </a>
<a name="ln5855">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln5856">	result_type</a>
<a name="ln5857">	operator()(_UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln5858">		   const param_type&amp; __p);</a>
<a name="ln5859"> </a>
<a name="ln5860">      template&lt;typename _ForwardIterator,</a>
<a name="ln5861">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln5862">	void</a>
<a name="ln5863">	__generate(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln5864">		   _UniformRandomNumberGenerator&amp; __urng)</a>
<a name="ln5865">	{ this-&gt;__generate(__f, __t, __urng, _M_param); }</a>
<a name="ln5866"> </a>
<a name="ln5867">      template&lt;typename _ForwardIterator,</a>
<a name="ln5868">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln5869">	void</a>
<a name="ln5870">	__generate(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln5871">		   _UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln5872">		   const param_type&amp; __p)</a>
<a name="ln5873">	{ this-&gt;__generate_impl(__f, __t, __urng, __p); }</a>
<a name="ln5874"> </a>
<a name="ln5875">      template&lt;typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln5876">	void</a>
<a name="ln5877">	__generate(result_type* __f, result_type* __t,</a>
<a name="ln5878">		   _UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln5879">		   const param_type&amp; __p)</a>
<a name="ln5880">	{ this-&gt;__generate_impl(__f, __t, __urng, __p); }</a>
<a name="ln5881"> </a>
<a name="ln5882">      /**</a>
<a name="ln5883">       * @brief Return true if two piecewise linear distributions have the</a>
<a name="ln5884">       *        same parameters.</a>
<a name="ln5885">       */</a>
<a name="ln5886">      friend bool</a>
<a name="ln5887">      operator==(const piecewise_linear_distribution&amp; __d1,</a>
<a name="ln5888">		 const piecewise_linear_distribution&amp; __d2)</a>
<a name="ln5889">      { return __d1._M_param == __d2._M_param; }</a>
<a name="ln5890"> </a>
<a name="ln5891">      /**</a>
<a name="ln5892">       * @brief Inserts a %piecewise_linear_distribution random number</a>
<a name="ln5893">       *        distribution @p __x into the output stream @p __os.</a>
<a name="ln5894">       *</a>
<a name="ln5895">       * @param __os An output stream.</a>
<a name="ln5896">       * @param __x  A %piecewise_linear_distribution random number</a>
<a name="ln5897">       *             distribution.</a>
<a name="ln5898">       *</a>
<a name="ln5899">       * @returns The output stream with the state of @p __x inserted or in</a>
<a name="ln5900">       *          an error state.</a>
<a name="ln5901">       */</a>
<a name="ln5902">      template&lt;typename _RealType1, typename _CharT, typename _Traits&gt;</a>
<a name="ln5903">	friend std::basic_ostream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln5904">	operator&lt;&lt;(std::basic_ostream&lt;_CharT, _Traits&gt;&amp; __os,</a>
<a name="ln5905">		   const std::piecewise_linear_distribution&lt;_RealType1&gt;&amp; __x);</a>
<a name="ln5906"> </a>
<a name="ln5907">      /**</a>
<a name="ln5908">       * @brief Extracts a %piecewise_linear_distribution random number</a>
<a name="ln5909">       *        distribution @p __x from the input stream @p __is.</a>
<a name="ln5910">       *</a>
<a name="ln5911">       * @param __is An input stream.</a>
<a name="ln5912">       * @param __x  A %piecewise_linear_distribution random number</a>
<a name="ln5913">       *             generator engine.</a>
<a name="ln5914">       *</a>
<a name="ln5915">       * @returns The input stream with @p __x extracted or in an error</a>
<a name="ln5916">       *          state.</a>
<a name="ln5917">       */</a>
<a name="ln5918">      template&lt;typename _RealType1, typename _CharT, typename _Traits&gt;</a>
<a name="ln5919">	friend std::basic_istream&lt;_CharT, _Traits&gt;&amp;</a>
<a name="ln5920">	operator&gt;&gt;(std::basic_istream&lt;_CharT, _Traits&gt;&amp; __is,</a>
<a name="ln5921">		   std::piecewise_linear_distribution&lt;_RealType1&gt;&amp; __x);</a>
<a name="ln5922"> </a>
<a name="ln5923">    private:</a>
<a name="ln5924">      template&lt;typename _ForwardIterator,</a>
<a name="ln5925">	       typename _UniformRandomNumberGenerator&gt;</a>
<a name="ln5926">	void</a>
<a name="ln5927">	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,</a>
<a name="ln5928">			_UniformRandomNumberGenerator&amp; __urng,</a>
<a name="ln5929">			const param_type&amp; __p);</a>
<a name="ln5930"> </a>
<a name="ln5931">      param_type _M_param;</a>
<a name="ln5932">    };</a>
<a name="ln5933"> </a>
<a name="ln5934">  /**</a>
<a name="ln5935">    * @brief Return true if two piecewise linear distributions have</a>
<a name="ln5936">    *        different parameters.</a>
<a name="ln5937">   */</a>
<a name="ln5938">  template&lt;typename _RealType&gt;</a>
<a name="ln5939">    inline bool</a>
<a name="ln5940">    operator!=(const std::piecewise_linear_distribution&lt;_RealType&gt;&amp; __d1,</a>
<a name="ln5941">	       const std::piecewise_linear_distribution&lt;_RealType&gt;&amp; __d2)</a>
<a name="ln5942">    { return !(__d1 == __d2); }</a>
<a name="ln5943"> </a>
<a name="ln5944"> </a>
<a name="ln5945">  /* @} */ // group random_distributions_poisson</a>
<a name="ln5946"> </a>
<a name="ln5947">  /* @} */ // group random_distributions</a>
<a name="ln5948"> </a>
<a name="ln5949">  /**</a>
<a name="ln5950">   * @addtogroup random_utilities Random Number Utilities</a>
<a name="ln5951">   * @ingroup random</a>
<a name="ln5952">   * @{</a>
<a name="ln5953">   */</a>
<a name="ln5954"> </a>
<a name="ln5955">  /**</a>
<a name="ln5956">   * @brief The seed_seq class generates sequences of seeds for random</a>
<a name="ln5957">   *        number generators.</a>
<a name="ln5958">   */</a>
<a name="ln5959">  class seed_seq</a>
<a name="ln5960">  {</a>
<a name="ln5961">  public:</a>
<a name="ln5962">    /** The type of the seed vales. */</a>
<a name="ln5963">    typedef uint_least32_t result_type;</a>
<a name="ln5964"> </a>
<a name="ln5965">    /** Default constructor. */</a>
<a name="ln5966">    seed_seq() noexcept</a>
<a name="ln5967">    : _M_v()</a>
<a name="ln5968">    { }</a>
<a name="ln5969"> </a>
<a name="ln5970">    template&lt;typename _IntType&gt;</a>
<a name="ln5971">      seed_seq(std::initializer_list&lt;_IntType&gt; il);</a>
<a name="ln5972"> </a>
<a name="ln5973">    template&lt;typename _InputIterator&gt;</a>
<a name="ln5974">      seed_seq(_InputIterator __begin, _InputIterator __end);</a>
<a name="ln5975"> </a>
<a name="ln5976">    // generating functions</a>
<a name="ln5977">    template&lt;typename _RandomAccessIterator&gt;</a>
<a name="ln5978">      void</a>
<a name="ln5979">      generate(_RandomAccessIterator __begin, _RandomAccessIterator __end);</a>
<a name="ln5980"> </a>
<a name="ln5981">    // property functions</a>
<a name="ln5982">    size_t size() const noexcept</a>
<a name="ln5983">    { return _M_v.size(); }</a>
<a name="ln5984"> </a>
<a name="ln5985">    template&lt;typename OutputIterator&gt;</a>
<a name="ln5986">      void</a>
<a name="ln5987">      param(OutputIterator __dest) const</a>
<a name="ln5988">      { std::copy(_M_v.begin(), _M_v.end(), __dest); }</a>
<a name="ln5989"> </a>
<a name="ln5990">    // no copy functions</a>
<a name="ln5991">    seed_seq(const seed_seq&amp;) = delete;</a>
<a name="ln5992">    seed_seq&amp; operator=(const seed_seq&amp;) = delete;</a>
<a name="ln5993"> </a>
<a name="ln5994">  private:</a>
<a name="ln5995">    std::vector&lt;result_type&gt; _M_v;</a>
<a name="ln5996">  };</a>
<a name="ln5997"> </a>
<a name="ln5998">  /* @} */ // group random_utilities</a>
<a name="ln5999"> </a>
<a name="ln6000">  /* @} */ // group random</a>
<a name="ln6001"> </a>
<a name="ln6002">_GLIBCXX_END_NAMESPACE_VERSION</a>
<a name="ln6003">} // namespace std</a>
<a name="ln6004"> </a>
<a name="ln6005">#endif</a>

</code></pre>
<div class="balloon" rel="1974"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: _M_saved.</p></div>
<div class="balloon" rel="1980"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: _M_saved.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
