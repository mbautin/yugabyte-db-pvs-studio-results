
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>hp.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Copyright (c) 2006-2018 Maxim Khizhinsky</a>
<a name="ln2">//</a>
<a name="ln3">// Distributed under the Boost Software License, Version 1.0. (See accompanying</a>
<a name="ln4">// file LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)</a>
<a name="ln5"> </a>
<a name="ln6">#ifndef CDSLIB_GC_HP_SMR_H</a>
<a name="ln7">#define CDSLIB_GC_HP_SMR_H</a>
<a name="ln8"> </a>
<a name="ln9">#include &lt;exception&gt;</a>
<a name="ln10">#include &lt;cds/gc/details/hp_common.h&gt;</a>
<a name="ln11">#include &lt;cds/threading/model.h&gt;</a>
<a name="ln12">#include &lt;cds/details/throw_exception.h&gt;</a>
<a name="ln13">#include &lt;cds/details/marked_ptr.h&gt;</a>
<a name="ln14">#include &lt;cds/user_setup/cache_line.h&gt;</a>
<a name="ln15"> </a>
<a name="ln16">/**</a>
<a name="ln17">    @page cds_garbage_collectors_comparison Hazard Pointer SMR implementations</a>
<a name="ln18">    @ingroup cds_garbage_collector</a>
<a name="ln19"> </a>
<a name="ln20">    &lt;table&gt;</a>
<a name="ln21">        &lt;tr&gt;</a>
<a name="ln22">            &lt;th&gt;Feature&lt;/th&gt;</a>
<a name="ln23">            &lt;th&gt;%cds::gc::HP&lt;/th&gt;</a>
<a name="ln24">            &lt;th&gt;%cds::gc::DHP&lt;/th&gt;</a>
<a name="ln25">        &lt;/tr&gt;</a>
<a name="ln26">        &lt;tr&gt;</a>
<a name="ln27">            &lt;td&gt;Max number of guarded (hazard) pointers per thread&lt;/td&gt;</a>
<a name="ln28">            &lt;td&gt;limited (specified at construction time)&lt;/td&gt;</a>
<a name="ln29">            &lt;td&gt;unlimited (dynamically allocated when needed)&lt;/td&gt;</a>
<a name="ln30">        &lt;/tr&gt;</a>
<a name="ln31">        &lt;tr&gt;</a>
<a name="ln32">            &lt;td&gt;Max number of retired pointers&lt;sup&gt;1&lt;/sup&gt;&lt;/td&gt;</a>
<a name="ln33">            &lt;td&gt;bounded, specified at construction time&lt;/td&gt;</a>
<a name="ln34">            &lt;td&gt;bounded, adaptive, depends on current thread count and number of hazard pointer for each thread&lt;/td&gt;</a>
<a name="ln35">        &lt;/tr&gt;</a>
<a name="ln36">        &lt;tr&gt;</a>
<a name="ln37">            &lt;td&gt;Thread count&lt;/td&gt;</a>
<a name="ln38">            &lt;td&gt;bounded, upper bound is specified at construction time&lt;/td&gt;</a>
<a name="ln39">            &lt;td&gt;unbounded&lt;/td&gt;</a>
<a name="ln40">        &lt;/tr&gt;</a>
<a name="ln41">    &lt;/table&gt;</a>
<a name="ln42"> </a>
<a name="ln43">    &lt;sup&gt;1&lt;/sup&gt;Unbounded count of retired pointers means a possibility of memory exhaustion.</a>
<a name="ln44">*/</a>
<a name="ln45"> </a>
<a name="ln46">namespace cds {</a>
<a name="ln47">    /// @defgroup cds_garbage_collector Garbage collectors</a>
<a name="ln48"> </a>
<a name="ln49"> </a>
<a name="ln50">    /// Different safe memory reclamation schemas (garbage collectors)</a>
<a name="ln51">    /** @ingroup cds_garbage_collector</a>
<a name="ln52"> </a>
<a name="ln53">        This namespace specifies different safe memory reclamation (SMR) algorithms.</a>
<a name="ln54">        See \ref cds_garbage_collector &quot;Garbage collectors&quot;</a>
<a name="ln55">    */</a>
<a name="ln56">    namespace gc {</a>
<a name="ln57">    } // namespace gc</a>
<a name="ln58"> </a>
<a name="ln59">} // namespace cds</a>
<a name="ln60"> </a>
<a name="ln61"> </a>
<a name="ln62">namespace cds { namespace gc {</a>
<a name="ln63">    /// Hazard pointer implementation details</a>
<a name="ln64">    namespace hp {</a>
<a name="ln65">        using namespace cds::gc::hp::common;</a>
<a name="ln66"> </a>
<a name="ln67">        /// Exception &quot;Not enough Hazard Pointer&quot;</a>
<a name="ln68">        class not_enough_hazard_ptr: public std::length_error</a>
<a name="ln69">        {</a>
<a name="ln70">        //@cond</a>
<a name="ln71">        public:</a>
<a name="ln72">            not_enough_hazard_ptr()</a>
<a name="ln73">                : std::length_error( &quot;Not enough Hazard Pointer&quot; )</a>
<a name="ln74">            {}</a>
<a name="ln75">        //@endcond</a>
<a name="ln76">        };</a>
<a name="ln77"> </a>
<a name="ln78">        /// Exception &quot;Hazard Pointer SMR is not initialized&quot;</a>
<a name="ln79">        class not_initialized: public std::runtime_error</a>
<a name="ln80">        {</a>
<a name="ln81">        //@cond</a>
<a name="ln82">        public:</a>
<a name="ln83">            not_initialized()</a>
<a name="ln84">                : std::runtime_error( &quot;Global Hazard Pointer SMR object is not initialized&quot; )</a>
<a name="ln85">            {}</a>
<a name="ln86">        //@endcond</a>
<a name="ln87">        };</a>
<a name="ln88"> </a>
<a name="ln89">        //@cond</a>
<a name="ln90">        /// Per-thread hazard pointer storage</a>
<a name="ln91">        class thread_hp_storage {</a>
<a name="ln92">        public:</a>
<a name="ln93">            thread_hp_storage( guard* arr, size_t nSize ) noexcept</a>
<a name="ln94">                : free_head_( arr )</a>
<a name="ln95">                , array_( arr )</a>
<a name="ln96">                , capacity_( nSize )</a>
<a name="ln97">#       ifdef CDS_ENABLE_HPSTAT</a>
<a name="ln98">                , alloc_guard_count_(0)</a>
<a name="ln99">                , free_guard_count_(0)</a>
<a name="ln100">#       endif</a>
<a name="ln101">            {</a>
<a name="ln102">                // Initialize guards</a>
<a name="ln103">                new( arr ) guard[nSize];</a>
<a name="ln104"> </a>
<a name="ln105">                for ( guard* pEnd = arr + nSize - 1; arr &lt; pEnd; ++arr )</a>
<a name="ln106">                    arr-&gt;next_ = arr + 1;</a>
<a name="ln107">                arr-&gt;next_ = nullptr;</a>
<a name="ln108">            }</a>
<a name="ln109"> </a>
<a name="ln110">            thread_hp_storage() = delete;</a>
<a name="ln111">            thread_hp_storage( thread_hp_storage const&amp; ) = delete;</a>
<a name="ln112">            thread_hp_storage( thread_hp_storage&amp;&amp; ) = delete;</a>
<a name="ln113"> </a>
<a name="ln114">            size_t capacity() const noexcept</a>
<a name="ln115">            {</a>
<a name="ln116">                return capacity_;</a>
<a name="ln117">            }</a>
<a name="ln118"> </a>
<a name="ln119">            bool full() const noexcept</a>
<a name="ln120">            {</a>
<a name="ln121">                return free_head_ == nullptr;</a>
<a name="ln122">            }</a>
<a name="ln123"> </a>
<a name="ln124">            guard* alloc()</a>
<a name="ln125">            {</a>
<a name="ln126">#       ifdef CDS_DISABLE_SMR_EXCEPTION</a>
<a name="ln127">                assert( !full());</a>
<a name="ln128">#       else</a>
<a name="ln129">                if ( full())</a>
<a name="ln130">                    CDS_THROW_EXCEPTION( not_enough_hazard_ptr());</a>
<a name="ln131">#       endif</a>
<a name="ln132">                guard* g = free_head_;</a>
<a name="ln133">                free_head_ = g-&gt;next_;</a>
<a name="ln134">                CDS_HPSTAT( ++alloc_guard_count_ );</a>
<a name="ln135">                return g;</a>
<a name="ln136">            }</a>
<a name="ln137"> </a>
<a name="ln138">            void free( guard* g ) noexcept</a>
<a name="ln139">            {</a>
<a name="ln140">                assert( g &gt;= array_ &amp;&amp; g &lt; array_ + capacity());</a>
<a name="ln141"> </a>
<a name="ln142">                if ( g ) {</a>
<a name="ln143">                    g-&gt;clear();</a>
<a name="ln144">                    g-&gt;next_ = free_head_;</a>
<a name="ln145">                    free_head_ = g;</a>
<a name="ln146">                    CDS_HPSTAT( ++free_guard_count_ );</a>
<a name="ln147">                }</a>
<a name="ln148">            }</a>
<a name="ln149"> </a>
<a name="ln150">            template&lt; size_t Capacity&gt;</a>
<a name="ln151">            size_t alloc( guard_array&lt;Capacity&gt;&amp; arr )</a>
<a name="ln152">            {</a>
<a name="ln153">                size_t i;</a>
<a name="ln154">                guard* g = free_head_;</a>
<a name="ln155">                for ( i = 0; i &lt; Capacity &amp;&amp; g; ++i ) {</a>
<a name="ln156">                    arr.reset( i, g );</a>
<a name="ln157">                    g = g-&gt;next_;</a>
<a name="ln158">                }</a>
<a name="ln159"> </a>
<a name="ln160">#       ifdef CDS_DISABLE_SMR_EXCEPTION</a>
<a name="ln161">                assert( i == Capacity );</a>
<a name="ln162">#       else</a>
<a name="ln163">                if ( i != Capacity )</a>
<a name="ln164">                    CDS_THROW_EXCEPTION( not_enough_hazard_ptr());</a>
<a name="ln165">#       endif</a>
<a name="ln166">                free_head_ = g;</a>
<a name="ln167">                CDS_HPSTAT( alloc_guard_count_ += Capacity );</a>
<a name="ln168">                return i;</a>
<a name="ln169">            }</a>
<a name="ln170"> </a>
<a name="ln171">            template &lt;size_t Capacity&gt;</a>
<a name="ln172">            void free( guard_array&lt;Capacity&gt;&amp; arr ) noexcept</a>
<a name="ln173">            {</a>
<a name="ln174">                guard* gList = free_head_;</a>
<a name="ln175">                for ( size_t i = 0; i &lt; Capacity; ++i ) {</a>
<a name="ln176">                    guard* g = arr[i];</a>
<a name="ln177">                    if ( g ) {</a>
<a name="ln178">                        g-&gt;clear();</a>
<a name="ln179">                        g-&gt;next_ = gList;</a>
<a name="ln180">                        gList = g;</a>
<a name="ln181">                        CDS_HPSTAT( ++free_guard_count_ );</a>
<a name="ln182">                    }</a>
<a name="ln183">                }</a>
<a name="ln184">                free_head_ = gList;</a>
<a name="ln185">            }</a>
<a name="ln186"> </a>
<a name="ln187">            // cppcheck-suppress functionConst</a>
<a name="ln188">            void clear()</a>
<a name="ln189">            {</a>
<a name="ln190">                for ( guard* cur = array_, *last = array_ + capacity(); cur &lt; last; ++cur )</a>
<a name="ln191">                    cur-&gt;clear();</a>
<a name="ln192">            }</a>
<a name="ln193"> </a>
<a name="ln194">            guard&amp; operator[]( size_t idx )</a>
<a name="ln195">            {</a>
<a name="ln196">                assert( idx &lt; capacity());</a>
<a name="ln197"> </a>
<a name="ln198">                return array_[idx];</a>
<a name="ln199">            }</a>
<a name="ln200"> </a>
<a name="ln201">            static size_t calc_array_size( size_t capacity )</a>
<a name="ln202">            {</a>
<a name="ln203">                return sizeof( guard ) * capacity;</a>
<a name="ln204">            }</a>
<a name="ln205"> </a>
<a name="ln206">            guard* begin() const</a>
<a name="ln207">            {</a>
<a name="ln208">                return array_;</a>
<a name="ln209">            }</a>
<a name="ln210"> </a>
<a name="ln211">            guard* end() const</a>
<a name="ln212">            {</a>
<a name="ln213">                return &amp;array_[capacity_];</a>
<a name="ln214">            }</a>
<a name="ln215"> </a>
<a name="ln216">        private:</a>
<a name="ln217">            guard*          free_head_; ///&lt; Head of free guard list</a>
<a name="ln218">            guard* const    array_;     ///&lt; HP array</a>
<a name="ln219">            size_t const    capacity_;  ///&lt; HP array capacity</a>
<a name="ln220">#       ifdef CDS_ENABLE_HPSTAT</a>
<a name="ln221">        public:</a>
<a name="ln222">            size_t          alloc_guard_count_;</a>
<a name="ln223">            size_t          free_guard_count_;</a>
<a name="ln224">#       endif</a>
<a name="ln225">        };</a>
<a name="ln226">        //@endcond</a>
<a name="ln227"> </a>
<a name="ln228">        //@cond</a>
<a name="ln229">        /// Per-thread retired array</a>
<a name="ln230">        class retired_array</a>
<a name="ln231">        {</a>
<a name="ln232">        public:</a>
<a name="ln233">            retired_array( retired_ptr* arr, size_t capacity ) noexcept</a>
<a name="ln234">                : current_( arr )</a>
<a name="ln235">                , last_( arr + capacity )</a>
<a name="ln236">                , retired_( arr )</a>
<a name="ln237">#       ifdef CDS_ENABLE_HPSTAT</a>
<a name="ln238">                , retire_call_count_(0)</a>
<a name="ln239">#       endif</a>
<a name="ln240">            {}</a>
<a name="ln241"> </a>
<a name="ln242">            retired_array() = delete;</a>
<a name="ln243">            retired_array( retired_array const&amp; ) = delete;</a>
<a name="ln244">            retired_array( retired_array&amp;&amp; ) = delete;</a>
<a name="ln245"> </a>
<a name="ln246">            size_t capacity() const noexcept</a>
<a name="ln247">            {</a>
<a name="ln248">                return last_ - retired_;</a>
<a name="ln249">            }</a>
<a name="ln250"> </a>
<a name="ln251">            size_t size() const noexcept</a>
<a name="ln252">            {</a>
<a name="ln253">                return current_.load(atomics::memory_order_relaxed) - retired_;</a>
<a name="ln254">            }</a>
<a name="ln255"> </a>
<a name="ln256">            bool push( retired_ptr&amp;&amp; p ) noexcept</a>
<a name="ln257">            {</a>
<a name="ln258">                retired_ptr* cur = current_.load( atomics::memory_order_relaxed );</a>
<a name="ln259">                *cur = p;</a>
<a name="ln260">                CDS_HPSTAT( ++retire_call_count_ );</a>
<a name="ln261">                current_.store( cur + 1, atomics::memory_order_relaxed );</a>
<a name="ln262">                return cur + 1 &lt; last_;</a>
<a name="ln263">            }</a>
<a name="ln264"> </a>
<a name="ln265">            retired_ptr* first() const noexcept</a>
<a name="ln266">            {</a>
<a name="ln267">                return retired_;</a>
<a name="ln268">            }</a>
<a name="ln269"> </a>
<a name="ln270">            retired_ptr* last() const noexcept</a>
<a name="ln271">            {</a>
<a name="ln272">                return current_.load( atomics::memory_order_relaxed );</a>
<a name="ln273">            }</a>
<a name="ln274"> </a>
<a name="ln275">            void reset( size_t nSize ) noexcept</a>
<a name="ln276">            {</a>
<a name="ln277">                current_.store( first() + nSize, atomics::memory_order_relaxed );</a>
<a name="ln278">            }</a>
<a name="ln279"> </a>
<a name="ln280">            void interthread_clear()</a>
<a name="ln281">            {</a>
<a name="ln282">                current_.exchange( first(), atomics::memory_order_acq_rel );</a>
<a name="ln283">            }</a>
<a name="ln284"> </a>
<a name="ln285">            bool full() const noexcept</a>
<a name="ln286">            {</a>
<a name="ln287">                return current_.load( atomics::memory_order_relaxed ) == last_;</a>
<a name="ln288">            }</a>
<a name="ln289"> </a>
<a name="ln290">            static size_t calc_array_size( size_t capacity )</a>
<a name="ln291">            {</a>
<a name="ln292">                return sizeof( retired_ptr ) * capacity;</a>
<a name="ln293">            }</a>
<a name="ln294"> </a>
<a name="ln295">        private:</a>
<a name="ln296">            atomics::atomic&lt;retired_ptr*&gt; current_;</a>
<a name="ln297">            retired_ptr* const            last_;</a>
<a name="ln298">            retired_ptr* const            retired_;</a>
<a name="ln299">#       ifdef CDS_ENABLE_HPSTAT</a>
<a name="ln300">        public:</a>
<a name="ln301">            size_t  retire_call_count_;</a>
<a name="ln302">#       endif</a>
<a name="ln303">        };</a>
<a name="ln304">        //@endcond</a>
<a name="ln305"> </a>
<a name="ln306">        /// Internal statistics</a>
<a name="ln307">        struct stat {</a>
<a name="ln308">            size_t  guard_allocated;    ///&lt; Count of allocated HP guards</a>
<a name="ln309">            size_t  guard_freed;        ///&lt; Count of freed HP guards</a>
<a name="ln310">            size_t  retired_count;      ///&lt; Count of retired pointers</a>
<a name="ln311">            size_t  free_count;         ///&lt; Count of free pointers</a>
<a name="ln312">            size_t  scan_count;         ///&lt; Count of \p scan() call</a>
<a name="ln313">            size_t  help_scan_count;    ///&lt; Count of \p help_scan() call</a>
<a name="ln314"> </a>
<a name="ln315">            size_t  thread_rec_count;   ///&lt; Count of thread records</a>
<a name="ln316"> </a>
<a name="ln317">            /// Default ctor</a>
<a name="ln318">            stat()</a>
<a name="ln319">            {</a>
<a name="ln320">                clear();</a>
<a name="ln321">            }</a>
<a name="ln322"> </a>
<a name="ln323">            /// Clears all counters</a>
<a name="ln324">            void clear()</a>
<a name="ln325">            {</a>
<a name="ln326">                guard_allocated =</a>
<a name="ln327">                    guard_freed =</a>
<a name="ln328">                    retired_count =</a>
<a name="ln329">                    free_count =</a>
<a name="ln330">                    scan_count =</a>
<a name="ln331">                    help_scan_count =</a>
<a name="ln332">                    thread_rec_count = 0;</a>
<a name="ln333">            }</a>
<a name="ln334">        };</a>
<a name="ln335"> </a>
<a name="ln336">        //@cond</a>
<a name="ln337">        /// Per-thread data</a>
<a name="ln338">        struct thread_data {</a>
<a name="ln339">            thread_hp_storage   hazards_;   ///&lt; Hazard pointers private to the thread</a>
<a name="ln340">            retired_array       retired_;   ///&lt; Retired data private to the thread</a>
<a name="ln341"> </a>
<a name="ln342">            char pad1_[cds::c_nCacheLineSize];</a>
<a name="ln343">            atomics::atomic&lt;unsigned int&gt; sync_; ///&lt; dummy var to introduce synchronizes-with relationship between threads</a>
<a name="ln344">            char pad2_[cds::c_nCacheLineSize];</a>
<a name="ln345"> </a>
<a name="ln346">#       ifdef CDS_ENABLE_HPSTAT</a>
<a name="ln347">            // Internal statistics:</a>
<a name="ln348">            size_t              free_count_;</a>
<a name="ln349">            size_t              scan_count_;</a>
<a name="ln350">            size_t              help_scan_count_;</a>
<a name="ln351">#       endif</a>
<a name="ln352"> </a>
<a name="ln353">            // CppCheck warn: pad1_ and pad2_ is uninitialized in ctor</a>
<a name="ln354">            // cppcheck-suppress uninitMemberVar</a>
<a name="ln355">            thread_data( guard* guards, size_t guard_count, retired_ptr* retired_arr, size_t retired_capacity )</a>
<a name="ln356">                : hazards_( guards, guard_count )</a>
<a name="ln357">                , retired_( retired_arr, retired_capacity )</a>
<a name="ln358">                , sync_(0)</a>
<a name="ln359">#       ifdef CDS_ENABLE_HPSTAT</a>
<a name="ln360">                , free_count_(0)</a>
<a name="ln361">                , scan_count_(0)</a>
<a name="ln362">                , help_scan_count_(0)</a>
<a name="ln363">#       endif</a>
<a name="ln364">            {}</a>
<a name="ln365"> </a>
<a name="ln366">            thread_data() = delete;</a>
<a name="ln367">            thread_data( thread_data const&amp; ) = delete;</a>
<a name="ln368">            thread_data( thread_data&amp;&amp; ) = delete;</a>
<a name="ln369"> </a>
<a name="ln370">            void sync()</a>
<a name="ln371">            {</a>
<a name="ln372">                sync_.fetch_add( 1, atomics::memory_order_acq_rel );</a>
<a name="ln373">            }</a>
<a name="ln374">        };</a>
<a name="ln375">        //@endcond</a>
<a name="ln376"> </a>
<a name="ln377">        /// \p smr::scan() strategy</a>
<a name="ln378">        enum scan_type {</a>
<a name="ln379">            classic,    ///&lt; classic scan as described in Michael's works (see smr::classic_scan())</a>
<a name="ln380">            inplace     ///&lt; inplace scan without allocation (see smr::inplace_scan())</a>
<a name="ln381">        };</a>
<a name="ln382"> </a>
<a name="ln383">        //@cond</a>
<a name="ln384">        /// Hazard Pointer SMR (Safe Memory Reclamation)</a>
<a name="ln385">        class smr</a>
<a name="ln386">        {</a>
<a name="ln387">            struct thread_record;</a>
<a name="ln388"> </a>
<a name="ln389">        public:</a>
<a name="ln390">            /// Returns the instance of Hazard Pointer \ref smr</a>
<a name="ln391">            static smr&amp; instance()</a>
<a name="ln392">            {</a>
<a name="ln393">#       ifdef CDS_DISABLE_SMR_EXCEPTION</a>
<a name="ln394">                assert( instance_ != nullptr );</a>
<a name="ln395">#       else</a>
<a name="ln396">                if ( !instance_ )</a>
<a name="ln397">                    CDS_THROW_EXCEPTION( not_initialized());</a>
<a name="ln398">#       endif</a>
<a name="ln399">                return *instance_;</a>
<a name="ln400">            }</a>
<a name="ln401"> </a>
<a name="ln402">            /// Creates Hazard Pointer SMR singleton</a>
<a name="ln403">            /**</a>
<a name="ln404">                Hazard Pointer SMR is a singleton. If HP instance is not initialized then the function creates the instance.</a>
<a name="ln405">                Otherwise it does nothing.</a>
<a name="ln406"> </a>
<a name="ln407">                The Michael's HP reclamation schema depends of three parameters:</a>
<a name="ln408">                - \p nHazardPtrCount - HP pointer count per thread. Usually it is small number (2-4) depending from</a>
<a name="ln409">                    the data structure algorithms. By default, if \p nHazardPtrCount = 0,</a>
<a name="ln410">                    the function uses maximum of HP count for CDS library</a>
<a name="ln411">                - \p nMaxThreadCount - max count of thread with using HP GC in your application. Default is 100.</a>
<a name="ln412">                - \p nMaxRetiredPtrCount - capacity of array of retired pointers for each thread. Must be greater than</a>
<a name="ln413">                    &lt;tt&gt; nHazardPtrCount * nMaxThreadCount &lt;/tt&gt;</a>
<a name="ln414">                    Default is &lt;tt&gt;2 * nHazardPtrCount * nMaxThreadCount&lt;/tt&gt;</a>
<a name="ln415">            */</a>
<a name="ln416">            static CDS_EXPORT_API void construct(</a>
<a name="ln417">                size_t nHazardPtrCount = 0,     ///&lt; Hazard pointer count per thread</a>
<a name="ln418">                size_t nMaxThreadCount = 0,     ///&lt; Max count of simultaneous working thread in your application</a>
<a name="ln419">                size_t nMaxRetiredPtrCount = 0, ///&lt; Capacity of the array of retired objects for the thread</a>
<a name="ln420">                scan_type nScanType = inplace   ///&lt; Scan type (see \ref scan_type enum)</a>
<a name="ln421">            );</a>
<a name="ln422"> </a>
<a name="ln423">            // for back-copatibility</a>
<a name="ln424">            static void Construct(</a>
<a name="ln425">                size_t nHazardPtrCount = 0,     ///&lt; Hazard pointer count per thread</a>
<a name="ln426">                size_t nMaxThreadCount = 0,     ///&lt; Max count of simultaneous working thread in your application</a>
<a name="ln427">                size_t nMaxRetiredPtrCount = 0, ///&lt; Capacity of the array of retired objects for the thread</a>
<a name="ln428">                scan_type nScanType = inplace   ///&lt; Scan type (see \ref scan_type enum)</a>
<a name="ln429">            )</a>
<a name="ln430">            {</a>
<a name="ln431">                construct( nHazardPtrCount, nMaxThreadCount, nMaxRetiredPtrCount, nScanType );</a>
<a name="ln432">            }</a>
<a name="ln433"> </a>
<a name="ln434">            /// Destroys global instance of \ref smr</a>
<a name="ln435">            /**</a>
<a name="ln436">                The parameter \p bDetachAll should be used carefully: if its value is \p true,</a>
<a name="ln437">                then the object destroyed automatically detaches all attached threads. This feature</a>
<a name="ln438">                can be useful when you have no control over the thread termination, for example,</a>
<a name="ln439">                when \p libcds is injected into existing external thread.</a>
<a name="ln440">            */</a>
<a name="ln441">            static CDS_EXPORT_API void destruct(</a>
<a name="ln442">                bool bDetachAll = false     ///&lt; Detach all threads</a>
<a name="ln443">            );</a>
<a name="ln444"> </a>
<a name="ln445">            // for back-compatibility</a>
<a name="ln446">            static void Destruct(</a>
<a name="ln447">                bool bDetachAll = false     ///&lt; Detach all threads</a>
<a name="ln448">            )</a>
<a name="ln449">            {</a>
<a name="ln450">                destruct( bDetachAll );</a>
<a name="ln451">            }</a>
<a name="ln452"> </a>
<a name="ln453">            /// Checks if global SMR object is constructed and may be used</a>
<a name="ln454">            static bool isUsed() noexcept</a>
<a name="ln455">            {</a>
<a name="ln456">                return instance_ != nullptr;</a>
<a name="ln457">            }</a>
<a name="ln458"> </a>
<a name="ln459">            /// Set memory management functions</a>
<a name="ln460">            /**</a>
<a name="ln461">                @note This function may be called &lt;b&gt;BEFORE&lt;/b&gt; creating an instance</a>
<a name="ln462">                of Hazard Pointer SMR</a>
<a name="ln463"> </a>
<a name="ln464">                SMR object allocates some memory for thread-specific data and for</a>
<a name="ln465">                creating SMR object.</a>
<a name="ln466">                By default, a standard \p new and \p delete operators are used for this.</a>
<a name="ln467">            */</a>
<a name="ln468">            static CDS_EXPORT_API void set_memory_allocator(</a>
<a name="ln469">                void* ( *alloc_func )( size_t size ),</a>
<a name="ln470">                void (*free_func )( void * p )</a>
<a name="ln471">            );</a>
<a name="ln472"> </a>
<a name="ln473">            /// Returns max Hazard Pointer count per thread</a>
<a name="ln474">            size_t get_hazard_ptr_count() const noexcept</a>
<a name="ln475">            {</a>
<a name="ln476">                return hazard_ptr_count_;</a>
<a name="ln477">            }</a>
<a name="ln478"> </a>
<a name="ln479">            /// Returns max thread count</a>
<a name="ln480">            size_t get_max_thread_count() const noexcept</a>
<a name="ln481">            {</a>
<a name="ln482">                return max_thread_count_;</a>
<a name="ln483">            }</a>
<a name="ln484"> </a>
<a name="ln485">            /// Returns max size of retired objects array</a>
<a name="ln486">            size_t get_max_retired_ptr_count() const noexcept</a>
<a name="ln487">            {</a>
<a name="ln488">                return max_retired_ptr_count_;</a>
<a name="ln489">            }</a>
<a name="ln490"> </a>
<a name="ln491">            /// Get current scan strategy</a>
<a name="ln492">            scan_type get_scan_type() const</a>
<a name="ln493">            {</a>
<a name="ln494">                return scan_type_;</a>
<a name="ln495">            }</a>
<a name="ln496"> </a>
<a name="ln497">            /// Checks that required hazard pointer count \p nRequiredCount is less or equal then max hazard pointer count</a>
<a name="ln498">            /**</a>
<a name="ln499">                If &lt;tt&gt; nRequiredCount &gt; get_hazard_ptr_count()&lt;/tt&gt; then the exception \p not_enough_hazard_ptr is thrown</a>
<a name="ln500">            */</a>
<a name="ln501">            static void check_hazard_ptr_count( size_t nRequiredCount )</a>
<a name="ln502">            {</a>
<a name="ln503">                if ( instance().get_hazard_ptr_count() &lt; nRequiredCount ) {</a>
<a name="ln504">#       ifdef CDS_DISABLE_SMR_EXCEPTION</a>
<a name="ln505">                    assert( false );    // not enough hazard ptr</a>
<a name="ln506">#       else</a>
<a name="ln507">                    CDS_THROW_EXCEPTION( not_enough_hazard_ptr());</a>
<a name="ln508">#       endif</a>
<a name="ln509">                }</a>
<a name="ln510">            }</a>
<a name="ln511"> </a>
<a name="ln512">            /// Returns thread-local data for the current thread</a>
<a name="ln513">            static CDS_EXPORT_API thread_data* tls();</a>
<a name="ln514"> </a>
<a name="ln515">            static CDS_EXPORT_API void attach_thread();</a>
<a name="ln516">            static CDS_EXPORT_API void detach_thread();</a>
<a name="ln517"> </a>
<a name="ln518">            /// Get internal statistics</a>
<a name="ln519">            CDS_EXPORT_API void statistics( stat&amp; st );</a>
<a name="ln520"> </a>
<a name="ln521">        public: // for internal use only</a>
<a name="ln522">            /// The main garbage collecting function</a>
<a name="ln523">            /**</a>
<a name="ln524">                This function is called internally when upper bound of thread's list of reclaimed pointers</a>
<a name="ln525">                is reached.</a>
<a name="ln526"> </a>
<a name="ln527">                There are the following scan algorithm:</a>
<a name="ln528">                - \ref hzp_gc_classic_scan &quot;classic_scan&quot; allocates memory for internal use</a>
<a name="ln529">                - \ref hzp_gc_inplace_scan &quot;inplace_scan&quot; does not allocate any memory</a>
<a name="ln530"> </a>
<a name="ln531">                Use \p set_scan_type() member function to setup appropriate scan algorithm.</a>
<a name="ln532">            */</a>
<a name="ln533">            void scan( thread_data* pRec )</a>
<a name="ln534">            {</a>
<a name="ln535">                pRec-&gt;sync();</a>
<a name="ln536">                ( this-&gt;*scan_func_ )( pRec );</a>
<a name="ln537">            }</a>
<a name="ln538"> </a>
<a name="ln539">            /// Helper scan routine</a>
<a name="ln540">            /**</a>
<a name="ln541">                The function guarantees that every node that is eligible for reuse is eventually freed, barring</a>
<a name="ln542">                thread failures. To do so, after executing \p scan(), a thread executes a \p %help_scan(),</a>
<a name="ln543">                where it checks every HP record. If an HP record is inactive, the thread moves all &quot;lost&quot; reclaimed pointers</a>
<a name="ln544">                to thread's list of reclaimed pointers.</a>
<a name="ln545"> </a>
<a name="ln546">                The function is called internally by \p scan().</a>
<a name="ln547">            */</a>
<a name="ln548">            CDS_EXPORT_API void help_scan( thread_data* pThis );</a>
<a name="ln549"> </a>
<a name="ln550">        private:</a>
<a name="ln551">            CDS_EXPORT_API smr(</a>
<a name="ln552">                size_t nHazardPtrCount,     ///&lt; Hazard pointer count per thread</a>
<a name="ln553">                size_t nMaxThreadCount,     ///&lt; Max count of simultaneous working thread in your application</a>
<a name="ln554">                size_t nMaxRetiredPtrCount, ///&lt; Capacity of the array of retired objects for the thread</a>
<a name="ln555">                scan_type nScanType         ///&lt; Scan type (see \ref scan_type enum)</a>
<a name="ln556">            );</a>
<a name="ln557"> </a>
<a name="ln558">            CDS_EXPORT_API ~smr();</a>
<a name="ln559"> </a>
<a name="ln560">            CDS_EXPORT_API void detach_all_thread();</a>
<a name="ln561"> </a>
<a name="ln562">            /// Classic scan algorithm</a>
<a name="ln563">            /** @anchor hzp_gc_classic_scan</a>
<a name="ln564">                Classical scan algorithm as described in Michael's paper.</a>
<a name="ln565"> </a>
<a name="ln566">                A scan includes four stages. The first stage involves scanning the array HP for non-null values.</a>
<a name="ln567">                Whenever a non-null value is encountered, it is inserted in a local list of currently protected pointer.</a>
<a name="ln568">                Only stage 1 accesses shared variables. The following stages operate only on private variables.</a>
<a name="ln569"> </a>
<a name="ln570">                The second stage of a scan involves sorting local list of protected pointers to allow</a>
<a name="ln571">                binary search in the third stage.</a>
<a name="ln572"> </a>
<a name="ln573">                The third stage of a scan involves checking each reclaimed node</a>
<a name="ln574">                against the pointers in local list of protected pointers. If the binary search yields</a>
<a name="ln575">                no match, the node is freed. Otherwise, it cannot be deleted now and must kept in thread's list</a>
<a name="ln576">                of reclaimed pointers.</a>
<a name="ln577"> </a>
<a name="ln578">                The forth stage prepares new thread's private list of reclaimed pointers</a>
<a name="ln579">                that could not be freed during the current scan, where they remain until the next scan.</a>
<a name="ln580"> </a>
<a name="ln581">                This algorithm allocates memory for internal HP array.</a>
<a name="ln582"> </a>
<a name="ln583">                This function is called internally by ThreadGC object when upper bound of thread's list of reclaimed pointers</a>
<a name="ln584">                is reached.</a>
<a name="ln585">            */</a>
<a name="ln586">            CDS_EXPORT_API void classic_scan( thread_data* pRec );</a>
<a name="ln587"> </a>
<a name="ln588">            /// In-place scan algorithm</a>
<a name="ln589">            /** @anchor hzp_gc_inplace_scan</a>
<a name="ln590">                Unlike the \p classic_scan() algorithm, \p %inplace_scan() does not allocate any memory.</a>
<a name="ln591">                All operations are performed in-place.</a>
<a name="ln592">            */</a>
<a name="ln593">            CDS_EXPORT_API void inplace_scan( thread_data* pRec );</a>
<a name="ln594"> </a>
<a name="ln595">        private:</a>
<a name="ln596">            CDS_EXPORT_API thread_record* create_thread_data();</a>
<a name="ln597">            static CDS_EXPORT_API void destroy_thread_data( thread_record* pRec );</a>
<a name="ln598"> </a>
<a name="ln599">            /// Allocates Hazard Pointer SMR thread private data</a>
<a name="ln600">            CDS_EXPORT_API thread_record* alloc_thread_data();</a>
<a name="ln601"> </a>
<a name="ln602">            /// Free HP SMR thread-private data</a>
<a name="ln603">            CDS_EXPORT_API void free_thread_data( thread_record* pRec, bool callHelpScan );</a>
<a name="ln604"> </a>
<a name="ln605">        private:</a>
<a name="ln606">            static CDS_EXPORT_API smr* instance_;</a>
<a name="ln607"> </a>
<a name="ln608">            atomics::atomic&lt; thread_record*&gt;    thread_list_;   ///&lt; Head of thread list</a>
<a name="ln609"> </a>
<a name="ln610">            size_t const    hazard_ptr_count_;      ///&lt; max count of thread's hazard pointer</a>
<a name="ln611">            size_t const    max_thread_count_;      ///&lt; max count of thread</a>
<a name="ln612">            size_t const    max_retired_ptr_count_; ///&lt; max count of retired ptr per thread</a>
<a name="ln613">            scan_type const scan_type_;             ///&lt; scan type (see \ref scan_type enum)</a>
<a name="ln614">            void ( smr::*scan_func_ )( thread_data* pRec );</a>
<a name="ln615">        };</a>
<a name="ln616">        //@endcond</a>
<a name="ln617"> </a>
<a name="ln618">        //@cond</a>
<a name="ln619">        // for backward compatibility</a>
<a name="ln620">        typedef smr GarbageCollector;</a>
<a name="ln621">        //@endcond</a>
<a name="ln622"> </a>
<a name="ln623">    } // namespace hp</a>
<a name="ln624"> </a>
<a name="ln625">    /// Hazard Pointer SMR (Safe Memory Reclamation)</a>
<a name="ln626">    /**  @ingroup cds_garbage_collector</a>
<a name="ln627"> </a>
<a name="ln628">        Implementation of classic Hazard Pointer SMR</a>
<a name="ln629"> </a>
<a name="ln630">        Sources:</a>
<a name="ln631">            - [2002] Maged M.Michael &quot;Safe memory reclamation for dynamic lock-freeobjects using atomic reads and writes&quot;</a>
<a name="ln632">            - [2003] Maged M.Michael &quot;Hazard Pointers: Safe memory reclamation for lock-free objects&quot;</a>
<a name="ln633">            - [2004] Andrei Alexandrescy, Maged Michael &quot;Lock-free Data Structures with Hazard Pointers&quot;</a>
<a name="ln634"> </a>
<a name="ln635">        Hazard Pointer SMR is a singleton. The main user-level part of Hazard Pointer schema is</a>
<a name="ln636">        \p %cds::gc::HP class and its nested classes. Before use any HP-related class you must initialize \p %HP</a>
<a name="ln637">        by contructing \p %cds::gc::HP object in beginning of your \p main().</a>
<a name="ln638">        See \ref cds_how_to_use &quot;How to use&quot; section for details how to apply SMR schema.</a>
<a name="ln639">    */</a>
<a name="ln640">    class HP</a>
<a name="ln641">    {</a>
<a name="ln642">    public:</a>
<a name="ln643">        /// Native guarded pointer type</a>
<a name="ln644">        typedef hp::hazard_ptr guarded_pointer;</a>
<a name="ln645"> </a>
<a name="ln646">        /// Atomic reference</a>
<a name="ln647">        template &lt;typename T&gt; using atomic_ref = atomics::atomic&lt;T *&gt;;</a>
<a name="ln648"> </a>
<a name="ln649">        /// Atomic marked pointer</a>
<a name="ln650">        template &lt;typename MarkedPtr&gt; using atomic_marked_ptr = atomics::atomic&lt;MarkedPtr&gt;;</a>
<a name="ln651"> </a>
<a name="ln652">        /// Atomic type</a>
<a name="ln653">        template &lt;typename T&gt; using atomic_type = atomics::atomic&lt;T&gt;;</a>
<a name="ln654"> </a>
<a name="ln655">        /// Exception &quot;Not enough Hazard Pointer&quot;</a>
<a name="ln656">        typedef hp::not_enough_hazard_ptr not_enough_hazard_ptr_exception;</a>
<a name="ln657"> </a>
<a name="ln658">        /// Internal statistics</a>
<a name="ln659">        typedef hp::stat stat;</a>
<a name="ln660"> </a>
<a name="ln661">        /// Hazard Pointer guard</a>
<a name="ln662">        /**</a>
<a name="ln663">            A guard is a hazard pointer.</a>
<a name="ln664">            Additionally, the \p %Guard class manages allocation and deallocation of the hazard pointer.</a>
<a name="ln665"> </a>
<a name="ln666">            \p %Guard object is movable but not copyable.</a>
<a name="ln667"> </a>
<a name="ln668">            The guard object can be in two states:</a>
<a name="ln669">            - unlinked - the guard is not linked with any internal hazard pointer.</a>
<a name="ln670">              In this state no operation except \p link() and move assignment is supported.</a>
<a name="ln671">            - linked (default) - the guard allocates an internal hazard pointer and completely operable.</a>
<a name="ln672"> </a>
<a name="ln673">            Due to performance reason the implementation does not check state of the guard at runtime.</a>
<a name="ln674"> </a>
<a name="ln675">            @warning Move assignment transfers the guard in unlinked state, use with care.</a>
<a name="ln676">        */</a>
<a name="ln677">        class Guard</a>
<a name="ln678">        {</a>
<a name="ln679">        public:</a>
<a name="ln680">            /// Default ctor allocates a guard (hazard pointer) from thread-private storage</a>
<a name="ln681">            /**</a>
<a name="ln682">                @warning Can throw \p not_enough_hazard_ptr if internal hazard pointer objects are exhausted.</a>
<a name="ln683">            */</a>
<a name="ln684">            Guard()</a>
<a name="ln685">                : guard_( hp::smr::tls()-&gt;hazards_.alloc())</a>
<a name="ln686">            {}</a>
<a name="ln687"> </a>
<a name="ln688">            /// Initilalizes an unlinked guard i.e. the guard contains no hazard pointer. Used for move semantics support</a>
<a name="ln689">            explicit Guard( std::nullptr_t ) noexcept</a>
<a name="ln690">                : guard_( nullptr )</a>
<a name="ln691">            {}</a>
<a name="ln692"> </a>
<a name="ln693">            /// Move ctor - \p src guard becomes unlinked (transfer internal guard ownership)</a>
<a name="ln694">            Guard( Guard&amp;&amp; src ) noexcept</a>
<a name="ln695">                : guard_( src.guard_ )</a>
<a name="ln696">            {</a>
<a name="ln697">                src.guard_ = nullptr;</a>
<a name="ln698">            }</a>
<a name="ln699"> </a>
<a name="ln700">            /// Move assignment: the internal guards are swapped between \p src and \p this</a>
<a name="ln701">            /**</a>
<a name="ln702">                @warning \p src will become in unlinked state if \p this was unlinked on entry.</a>
<a name="ln703">            */</a>
<a name="ln704">            Guard&amp; operator=( Guard&amp;&amp; src ) noexcept</a>
<a name="ln705">            {</a>
<a name="ln706">                std::swap( guard_, src.guard_ );</a>
<a name="ln707">                return *this;</a>
<a name="ln708">            }</a>
<a name="ln709"> </a>
<a name="ln710">            /// Copy ctor is prohibited - the guard is not copyable</a>
<a name="ln711">            Guard( Guard const&amp; ) = delete;</a>
<a name="ln712"> </a>
<a name="ln713">            /// Copy assignment is prohibited</a>
<a name="ln714">            Guard&amp; operator=( Guard const&amp; ) = delete;</a>
<a name="ln715"> </a>
<a name="ln716">            /// Frees the internal hazard pointer if the guard is in linked state</a>
<a name="ln717">            ~Guard()</a>
<a name="ln718">            {</a>
<a name="ln719">                unlink();</a>
<a name="ln720">            }</a>
<a name="ln721"> </a>
<a name="ln722">            /// Checks if the guard object linked with any internal hazard pointer</a>
<a name="ln723">            bool is_linked() const</a>
<a name="ln724">            {</a>
<a name="ln725">                return guard_ != nullptr;</a>
<a name="ln726">            }</a>
<a name="ln727"> </a>
<a name="ln728">            /// Links the guard with internal hazard pointer if the guard is in unlinked state</a>
<a name="ln729">            /**</a>
<a name="ln730">                @warning Can throw \p not_enough_hazard_ptr_exception if internal hazard pointer array is exhausted.</a>
<a name="ln731">            */</a>
<a name="ln732">            void link()</a>
<a name="ln733">            {</a>
<a name="ln734">                if ( !guard_ )</a>
<a name="ln735">                    guard_ = hp::smr::tls()-&gt;hazards_.alloc();</a>
<a name="ln736">            }</a>
<a name="ln737"> </a>
<a name="ln738">            /// Unlinks the guard from internal hazard pointer; the guard becomes in unlinked state</a>
<a name="ln739">            void unlink()</a>
<a name="ln740">            {</a>
<a name="ln741">                if ( guard_ ) {</a>
<a name="ln742">                    hp::smr::tls()-&gt;hazards_.free( guard_ );</a>
<a name="ln743">                    guard_ = nullptr;</a>
<a name="ln744">                }</a>
<a name="ln745">            }</a>
<a name="ln746"> </a>
<a name="ln747">            /// Protects a pointer of type \p atomic&lt;T*&gt;</a>
<a name="ln748">            /**</a>
<a name="ln749">                Return the value of \p toGuard</a>
<a name="ln750"> </a>
<a name="ln751">                The function tries to load \p toGuard and to store it</a>
<a name="ln752">                to the HP slot repeatedly until the guard's value equals \p toGuard</a>
<a name="ln753"> </a>
<a name="ln754">                @warning The guad object should be in linked state, otherwise the result is undefined</a>
<a name="ln755">            */</a>
<a name="ln756">            template &lt;typename T&gt;</a>
<a name="ln757">            T protect( atomics::atomic&lt;T&gt; const&amp; toGuard )</a>
<a name="ln758">            {</a>
<a name="ln759">                return protect(toGuard, [](T p) { return p; });</a>
<a name="ln760">            }</a>
<a name="ln761"> </a>
<a name="ln762">            /// Protects a converted pointer of type \p atomic&lt;T*&gt;</a>
<a name="ln763">            /**</a>
<a name="ln764">                Return the value of \p toGuard</a>
<a name="ln765"> </a>
<a name="ln766">                The function tries to load \p toGuard and to store result of \p f functor</a>
<a name="ln767">                to the HP slot repeatedly until the guard's value equals \p toGuard.</a>
<a name="ln768"> </a>
<a name="ln769">                The function is useful for intrusive containers when \p toGuard is a node pointer</a>
<a name="ln770">                that should be converted to a pointer to the value before protecting.</a>
<a name="ln771">                The parameter \p f of type Func is a functor that makes this conversion:</a>
<a name="ln772">                \code</a>
<a name="ln773">                    struct functor {</a>
<a name="ln774">                        value_type * operator()( T * p );</a>
<a name="ln775">                    };</a>
<a name="ln776">                \endcode</a>
<a name="ln777">                Actually, the result of &lt;tt&gt; f( toGuard.load()) &lt;/tt&gt; is assigned to the hazard pointer.</a>
<a name="ln778"> </a>
<a name="ln779">                @warning The guad object should be in linked state, otherwise the result is undefined</a>
<a name="ln780">            */</a>
<a name="ln781">            template &lt;typename T, class Func&gt;</a>
<a name="ln782">            T protect( atomics::atomic&lt;T&gt; const&amp; toGuard, Func f )</a>
<a name="ln783">            {</a>
<a name="ln784">                assert( guard_ != nullptr );</a>
<a name="ln785"> </a>
<a name="ln786">                T pCur = toGuard.load(atomics::memory_order_relaxed);</a>
<a name="ln787">                T pRet;</a>
<a name="ln788">                do {</a>
<a name="ln789">                    pRet = pCur;</a>
<a name="ln790">                    assign( f( pCur ));</a>
<a name="ln791">                    pCur = toGuard.load(atomics::memory_order_acquire);</a>
<a name="ln792">                } while ( pRet != pCur );</a>
<a name="ln793">                return pCur;</a>
<a name="ln794">            }</a>
<a name="ln795"> </a>
<a name="ln796">            /// Store \p p to the guard</a>
<a name="ln797">            /**</a>
<a name="ln798">                The function equals to a simple assignment the value \p p to guard, no loop is performed.</a>
<a name="ln799">                Can be used for a pointer that cannot be changed concurrently or if the pointer is already</a>
<a name="ln800">                guarded by another guard.</a>
<a name="ln801"> </a>
<a name="ln802">                @warning The guad object should be in linked state, otherwise the result is undefined</a>
<a name="ln803">            */</a>
<a name="ln804">            template &lt;typename T&gt;</a>
<a name="ln805">            T * assign( T* p )</a>
<a name="ln806">            {</a>
<a name="ln807">                assert( guard_ != nullptr );</a>
<a name="ln808"> </a>
<a name="ln809">                guard_-&gt;set( p );</a>
<a name="ln810">                hp::smr::tls()-&gt;sync();</a>
<a name="ln811">                return p;</a>
<a name="ln812">            }</a>
<a name="ln813"> </a>
<a name="ln814">            //@cond</a>
<a name="ln815">            std::nullptr_t assign( std::nullptr_t )</a>
<a name="ln816">            {</a>
<a name="ln817">                assert( guard_ != nullptr );</a>
<a name="ln818"> </a>
<a name="ln819">                guard_-&gt;clear();</a>
<a name="ln820">                return nullptr;</a>
<a name="ln821">            }</a>
<a name="ln822">            //@endcond</a>
<a name="ln823"> </a>
<a name="ln824">            /// Copy a value guarded from \p src guard to \p this guard (valid only in linked state)</a>
<a name="ln825">            void copy( Guard const&amp; src )</a>
<a name="ln826">            {</a>
<a name="ln827">                assign( src.get_native());</a>
<a name="ln828">            }</a>
<a name="ln829"> </a>
<a name="ln830">            /// Store marked pointer \p p to the guard</a>
<a name="ln831">            /**</a>
<a name="ln832">                The function equals to a simple assignment of &lt;tt&gt;p.ptr()&lt;/tt&gt;, no loop is performed.</a>
<a name="ln833">                Can be used for a marked pointer that cannot be changed concurrently or if the marked pointer</a>
<a name="ln834">                is already guarded by another guard.</a>
<a name="ln835"> </a>
<a name="ln836">                @warning The guard object should be in linked state, otherwise the result is undefined</a>
<a name="ln837">            */</a>
<a name="ln838">            template &lt;typename T, int BITMASK&gt;</a>
<a name="ln839">            T * assign( cds::details::marked_ptr&lt;T, BITMASK&gt; p )</a>
<a name="ln840">            {</a>
<a name="ln841">                return assign( p.ptr());</a>
<a name="ln842">            }</a>
<a name="ln843"> </a>
<a name="ln844">            /// Clear value of the guard (valid only in linked state)</a>
<a name="ln845">            void clear()</a>
<a name="ln846">            {</a>
<a name="ln847">                assign( nullptr );</a>
<a name="ln848">            }</a>
<a name="ln849"> </a>
<a name="ln850">            /// Get the value currently protected (valid only in linked state)</a>
<a name="ln851">            template &lt;typename T&gt;</a>
<a name="ln852">            T * get() const</a>
<a name="ln853">            {</a>
<a name="ln854">                assert( guard_ != nullptr );</a>
<a name="ln855">                return guard_-&gt;get_as&lt;T&gt;();</a>
<a name="ln856">            }</a>
<a name="ln857"> </a>
<a name="ln858">            /// Get native hazard pointer stored (valid only in linked state)</a>
<a name="ln859">            guarded_pointer get_native() const</a>
<a name="ln860">            {</a>
<a name="ln861">                assert( guard_ != nullptr );</a>
<a name="ln862">                return guard_-&gt;get();</a>
<a name="ln863">            }</a>
<a name="ln864"> </a>
<a name="ln865">            //@cond</a>
<a name="ln866">            hp::guard* release()</a>
<a name="ln867">            {</a>
<a name="ln868">                hp::guard* g = guard_;</a>
<a name="ln869">                guard_ = nullptr;</a>
<a name="ln870">                return g;</a>
<a name="ln871">            }</a>
<a name="ln872"> </a>
<a name="ln873">            hp::guard*&amp; guard_ref()</a>
<a name="ln874">            {</a>
<a name="ln875">                return guard_;</a>
<a name="ln876">            }</a>
<a name="ln877">            //@endcond</a>
<a name="ln878"> </a>
<a name="ln879">        private:</a>
<a name="ln880">            //@cond</a>
<a name="ln881">            hp::guard* guard_;</a>
<a name="ln882">            //@endcond</a>
<a name="ln883">        };</a>
<a name="ln884"> </a>
<a name="ln885">        /// Array of Hazard Pointer guards</a>
<a name="ln886">        /**</a>
<a name="ln887">            The class is intended for allocating an array of hazard pointer guards.</a>
<a name="ln888">            Template parameter \p Count defines the size of the array.</a>
<a name="ln889">        */</a>
<a name="ln890">        template &lt;size_t Count&gt;</a>
<a name="ln891">        class GuardArray</a>
<a name="ln892">        {</a>
<a name="ln893">        public:</a>
<a name="ln894">            /// Rebind array for other size \p Count2</a>
<a name="ln895">            template &lt;size_t Count2&gt;</a>
<a name="ln896">            struct rebind {</a>
<a name="ln897">                typedef GuardArray&lt;Count2&gt;  other;   ///&lt; rebinding result</a>
<a name="ln898">            };</a>
<a name="ln899"> </a>
<a name="ln900">            /// Array capacity</a>
<a name="ln901">            static constexpr const size_t c_nCapacity = Count;</a>
<a name="ln902"> </a>
<a name="ln903">        public:</a>
<a name="ln904">            /// Default ctor allocates \p Count hazard pointers</a>
<a name="ln905">            GuardArray()</a>
<a name="ln906">            {</a>
<a name="ln907">                hp::smr::tls()-&gt;hazards_.alloc( guards_ );</a>
<a name="ln908">            }</a>
<a name="ln909"> </a>
<a name="ln910">            /// Move ctor is prohibited</a>
<a name="ln911">            GuardArray( GuardArray&amp;&amp; ) = delete;</a>
<a name="ln912"> </a>
<a name="ln913">            /// Move assignment is prohibited</a>
<a name="ln914">            GuardArray&amp; operator=( GuardArray&amp;&amp; ) = delete;</a>
<a name="ln915"> </a>
<a name="ln916">            /// Copy ctor is prohibited</a>
<a name="ln917">            GuardArray( GuardArray const&amp; ) = delete;</a>
<a name="ln918"> </a>
<a name="ln919">            /// Copy assignment is prohibited</a>
<a name="ln920">            GuardArray&amp; operator=( GuardArray const&amp; ) = delete;</a>
<a name="ln921"> </a>
<a name="ln922">            /// Frees allocated hazard pointers</a>
<a name="ln923">            ~GuardArray()</a>
<a name="ln924">            {</a>
<a name="ln925">                hp::smr::tls()-&gt;hazards_.free( guards_ );</a>
<a name="ln926">            }</a>
<a name="ln927"> </a>
<a name="ln928">            /// Protects a pointer of type \p atomic&lt;T*&gt;</a>
<a name="ln929">            /**</a>
<a name="ln930">                Return the value of \p toGuard</a>
<a name="ln931"> </a>
<a name="ln932">                The function tries to load \p toGuard and to store it</a>
<a name="ln933">                to the slot \p nIndex repeatedly until the guard's value equals \p toGuard</a>
<a name="ln934">            */</a>
<a name="ln935">            template &lt;typename T&gt;</a>
<a name="ln936">            T protect( size_t nIndex, atomics::atomic&lt;T&gt; const&amp; toGuard )</a>
<a name="ln937">            {</a>
<a name="ln938">                return protect(nIndex, toGuard, [](T p) { return p; });</a>
<a name="ln939">            }</a>
<a name="ln940"> </a>
<a name="ln941">            /// Protects a pointer of type \p atomic&lt;T*&gt;</a>
<a name="ln942">            /**</a>
<a name="ln943">                Return the value of \p toGuard</a>
<a name="ln944"> </a>
<a name="ln945">                The function tries to load \p toGuard and to store it</a>
<a name="ln946">                to the slot \p nIndex repeatedly until the guard's value equals \p toGuard</a>
<a name="ln947"> </a>
<a name="ln948">                The function is useful for intrusive containers when \p toGuard is a node pointer</a>
<a name="ln949">                that should be converted to a pointer to the value type before guarding.</a>
<a name="ln950">                The parameter \p f of type Func is a functor that makes this conversion:</a>
<a name="ln951">                \code</a>
<a name="ln952">                    struct functor {</a>
<a name="ln953">                        value_type * operator()( T * p );</a>
<a name="ln954">                    };</a>
<a name="ln955">                \endcode</a>
<a name="ln956">                Really, the result of &lt;tt&gt; f( toGuard.load()) &lt;/tt&gt; is assigned to the hazard pointer.</a>
<a name="ln957">            */</a>
<a name="ln958">            template &lt;typename T, class Func&gt;</a>
<a name="ln959">            T protect( size_t nIndex, atomics::atomic&lt;T&gt; const&amp; toGuard, Func f )</a>
<a name="ln960">            {</a>
<a name="ln961">                assert( nIndex &lt; capacity());</a>
<a name="ln962"> </a>
<a name="ln963">                T pRet;</a>
<a name="ln964">                do {</a>
<a name="ln965">                    assign( nIndex, f( pRet = toGuard.load(atomics::memory_order_relaxed)));</a>
<a name="ln966">                } while ( pRet != toGuard.load(atomics::memory_order_acquire));</a>
<a name="ln967"> </a>
<a name="ln968">                return pRet;</a>
<a name="ln969">            }</a>
<a name="ln970"> </a>
<a name="ln971">            /// Store \p to the slot \p nIndex</a>
<a name="ln972">            /**</a>
<a name="ln973">                The function equals to a simple assignment, no loop is performed.</a>
<a name="ln974">            */</a>
<a name="ln975">            template &lt;typename T&gt;</a>
<a name="ln976">            T * assign( size_t nIndex, T * p )</a>
<a name="ln977">            {</a>
<a name="ln978">                assert( nIndex &lt; capacity());</a>
<a name="ln979"> </a>
<a name="ln980">                guards_.set( nIndex, p );</a>
<a name="ln981">                hp::smr::tls()-&gt;sync();</a>
<a name="ln982">                return p;</a>
<a name="ln983">            }</a>
<a name="ln984"> </a>
<a name="ln985">            /// Store marked pointer \p p to the guard</a>
<a name="ln986">            /**</a>
<a name="ln987">                The function equals to a simple assignment of &lt;tt&gt;p.ptr()&lt;/tt&gt;, no loop is performed.</a>
<a name="ln988">                Can be used for a marked pointer that cannot be changed concurrently.</a>
<a name="ln989">            */</a>
<a name="ln990">            template &lt;typename T, int BITMASK&gt;</a>
<a name="ln991">            T * assign( size_t nIndex, cds::details::marked_ptr&lt;T, BITMASK&gt; p )</a>
<a name="ln992">            {</a>
<a name="ln993">                return assign( nIndex, p.ptr());</a>
<a name="ln994">            }</a>
<a name="ln995"> </a>
<a name="ln996">            /// Copy guarded value from \p src guard to slot at index \p nIndex</a>
<a name="ln997">            void copy( size_t nIndex, Guard const&amp; src )</a>
<a name="ln998">            {</a>
<a name="ln999">                assign( nIndex, src.get_native());</a>
<a name="ln1000">            }</a>
<a name="ln1001"> </a>
<a name="ln1002">            /// Copy guarded value from slot \p nSrcIndex to the slot \p nDestIndex</a>
<a name="ln1003">            void copy( size_t nDestIndex, size_t nSrcIndex )</a>
<a name="ln1004">            {</a>
<a name="ln1005">                assign( nDestIndex, get_native( nSrcIndex ));</a>
<a name="ln1006">            }</a>
<a name="ln1007"> </a>
<a name="ln1008">            /// Clear value of the slot \p nIndex</a>
<a name="ln1009">            void clear( size_t nIndex )</a>
<a name="ln1010">            {</a>
<a name="ln1011">                guards_.clear( nIndex );</a>
<a name="ln1012">            }</a>
<a name="ln1013"> </a>
<a name="ln1014">            /// Get current value of slot \p nIndex</a>
<a name="ln1015">            template &lt;typename T&gt;</a>
<a name="ln1016">            T * get( size_t nIndex ) const</a>
<a name="ln1017">            {</a>
<a name="ln1018">                assert( nIndex &lt; capacity());</a>
<a name="ln1019">                return guards_[nIndex]-&gt;template get_as&lt;T&gt;();</a>
<a name="ln1020">            }</a>
<a name="ln1021"> </a>
<a name="ln1022">            /// Get native hazard pointer stored</a>
<a name="ln1023">            guarded_pointer get_native( size_t nIndex ) const</a>
<a name="ln1024">            {</a>
<a name="ln1025">                assert( nIndex &lt; capacity());</a>
<a name="ln1026">                return guards_[nIndex]-&gt;get();</a>
<a name="ln1027">            }</a>
<a name="ln1028"> </a>
<a name="ln1029">            //@cond</a>
<a name="ln1030">            hp::guard* release( size_t nIndex ) noexcept</a>
<a name="ln1031">            {</a>
<a name="ln1032">                return guards_.release( nIndex );</a>
<a name="ln1033">            }</a>
<a name="ln1034">            //@endcond</a>
<a name="ln1035"> </a>
<a name="ln1036">            /// Capacity of the guard array</a>
<a name="ln1037">            static constexpr size_t capacity()</a>
<a name="ln1038">            {</a>
<a name="ln1039">                return c_nCapacity;</a>
<a name="ln1040">            }</a>
<a name="ln1041"> </a>
<a name="ln1042">        private:</a>
<a name="ln1043">            //@cond</a>
<a name="ln1044">            hp::guard_array&lt;c_nCapacity&gt; guards_;</a>
<a name="ln1045">            //@endcond</a>
<a name="ln1046">        };</a>
<a name="ln1047"> </a>
<a name="ln1048">        /// Guarded pointer</a>
<a name="ln1049">        /**</a>
<a name="ln1050">            A guarded pointer is a pair of a pointer and GC's guard.</a>
<a name="ln1051">            Usually, it is used for returning a pointer to an element of a lock-free container.</a>
<a name="ln1052">            The guard prevents the pointer to be early disposed (freed) by SMR.</a>
<a name="ln1053">            After destructing \p %guarded_ptr object the pointer can be disposed (freed) automatically at any time.</a>
<a name="ln1054"> </a>
<a name="ln1055">            Template arguments:</a>
<a name="ln1056">            - \p GuardedType - a type which the guard stores</a>
<a name="ln1057">            - \p ValueType - a value type</a>
<a name="ln1058">            - \p Cast - a functor for converting &lt;tt&gt;GuardedType*&lt;/tt&gt; to &lt;tt&gt;ValueType*&lt;/tt&gt;. Default is \p void (no casting).</a>
<a name="ln1059"> </a>
<a name="ln1060">            For intrusive containers, \p GuardedType is the same as \p ValueType and no casting is needed.</a>
<a name="ln1061">            In such case the \p %guarded_ptr is:</a>
<a name="ln1062">            @code</a>
<a name="ln1063">            typedef cds::gc::HP::guarded_ptr&lt; foo &gt; intrusive_guarded_ptr;</a>
<a name="ln1064">            @endcode</a>
<a name="ln1065"> </a>
<a name="ln1066">            For standard (non-intrusive) containers \p GuardedType is not the same as \p ValueType and casting is needed.</a>
<a name="ln1067">            For example:</a>
<a name="ln1068">            @code</a>
<a name="ln1069">            struct foo {</a>
<a name="ln1070">                int const   key;</a>
<a name="ln1071">                std::string value;</a>
<a name="ln1072">            };</a>
<a name="ln1073"> </a>
<a name="ln1074">            struct value_accessor {</a>
<a name="ln1075">                std::string* operator()( foo* pFoo ) const</a>
<a name="ln1076">                {</a>
<a name="ln1077">                    return &amp;(pFoo-&gt;value);</a>
<a name="ln1078">                }</a>
<a name="ln1079">            };</a>
<a name="ln1080"> </a>
<a name="ln1081">            // Guarded ptr</a>
<a name="ln1082">            typedef cds::gc::HP::guarded_ptr&lt; Foo, std::string, value_accessor &gt; nonintrusive_guarded_ptr;</a>
<a name="ln1083">            @endcode</a>
<a name="ln1084"> </a>
<a name="ln1085">            You don't need use this class directly.</a>
<a name="ln1086">            All set/map container classes from \p libcds declare the typedef for \p %guarded_ptr with appropriate casting functor.</a>
<a name="ln1087">        */</a>
<a name="ln1088">        template &lt;typename GuardedType, typename ValueType=GuardedType, typename Cast=void &gt;</a>
<a name="ln1089">        class guarded_ptr</a>
<a name="ln1090">        {</a>
<a name="ln1091">            //@cond</a>
<a name="ln1092">            struct trivial_cast {</a>
<a name="ln1093">                ValueType * operator()( GuardedType * p ) const</a>
<a name="ln1094">                {</a>
<a name="ln1095">                    return p;</a>
<a name="ln1096">                }</a>
<a name="ln1097">            };</a>
<a name="ln1098"> </a>
<a name="ln1099">            template &lt;typename GT, typename VT, typename C&gt; friend class guarded_ptr;</a>
<a name="ln1100">            //@endcond</a>
<a name="ln1101"> </a>
<a name="ln1102">        public:</a>
<a name="ln1103">            typedef GuardedType guarded_type; ///&lt; Guarded type</a>
<a name="ln1104">            typedef ValueType   value_type;   ///&lt; Value type</a>
<a name="ln1105"> </a>
<a name="ln1106">            /// Functor for casting \p guarded_type to \p value_type</a>
<a name="ln1107">            typedef typename std::conditional&lt; std::is_same&lt;Cast, void&gt;::value, trivial_cast, Cast &gt;::type value_cast;</a>
<a name="ln1108"> </a>
<a name="ln1109">        public:</a>
<a name="ln1110">            /// Creates empty guarded pointer</a>
<a name="ln1111">            guarded_ptr() noexcept</a>
<a name="ln1112">                : guard_(nullptr)</a>
<a name="ln1113">            {}</a>
<a name="ln1114"> </a>
<a name="ln1115">            //@cond</a>
<a name="ln1116">            explicit guarded_ptr( hp::guard* g ) noexcept</a>
<a name="ln1117">                : guard_( g )</a>
<a name="ln1118">            {}</a>
<a name="ln1119"> </a>
<a name="ln1120">            /// Initializes guarded pointer with \p p</a>
<a name="ln1121">            explicit guarded_ptr( guarded_type* p ) noexcept</a>
<a name="ln1122">                : guard_( nullptr )</a>
<a name="ln1123">            {</a>
<a name="ln1124">                reset(p);</a>
<a name="ln1125">            }</a>
<a name="ln1126">            explicit guarded_ptr( std::nullptr_t ) noexcept</a>
<a name="ln1127">                : guard_( nullptr )</a>
<a name="ln1128">            {}</a>
<a name="ln1129">            //@endcond</a>
<a name="ln1130"> </a>
<a name="ln1131">            /// Move ctor</a>
<a name="ln1132">            guarded_ptr( guarded_ptr&amp;&amp; gp ) noexcept</a>
<a name="ln1133">                : guard_( gp.guard_ )</a>
<a name="ln1134">            {</a>
<a name="ln1135">                gp.guard_ = nullptr;</a>
<a name="ln1136">            }</a>
<a name="ln1137"> </a>
<a name="ln1138">            /// Move ctor</a>
<a name="ln1139">            template &lt;typename GT, typename VT, typename C&gt;</a>
<a name="ln1140">            guarded_ptr( guarded_ptr&lt;GT, VT, C&gt;&amp;&amp; gp ) noexcept</a>
<a name="ln1141">                : guard_( gp.guard_ )</a>
<a name="ln1142">            {</a>
<a name="ln1143">                gp.guard_ = nullptr;</a>
<a name="ln1144">            }</a>
<a name="ln1145"> </a>
<a name="ln1146">            /// Ctor from \p Guard</a>
<a name="ln1147">            explicit guarded_ptr( Guard&amp;&amp; g ) noexcept</a>
<a name="ln1148">                : guard_( g.release())</a>
<a name="ln1149">            {}</a>
<a name="ln1150"> </a>
<a name="ln1151">            /// The guarded pointer is not copy-constructible</a>
<a name="ln1152">            guarded_ptr( guarded_ptr const&amp; gp ) = delete;</a>
<a name="ln1153"> </a>
<a name="ln1154">            /// Clears the guarded pointer</a>
<a name="ln1155">            /**</a>
<a name="ln1156">                \ref release() is called if guarded pointer is not \ref empty()</a>
<a name="ln1157">            */</a>
<a name="ln1158">            ~guarded_ptr() noexcept</a>
<a name="ln1159">            {</a>
<a name="ln1160">                release();</a>
<a name="ln1161">            }</a>
<a name="ln1162"> </a>
<a name="ln1163">            /// Move-assignment operator</a>
<a name="ln1164">            guarded_ptr&amp; operator=( guarded_ptr&amp;&amp; gp ) noexcept</a>
<a name="ln1165">            {</a>
<a name="ln1166">                std::swap( guard_, gp.guard_ );</a>
<a name="ln1167">                return *this;</a>
<a name="ln1168">            }</a>
<a name="ln1169"> </a>
<a name="ln1170">            /// Move-assignment from \p Guard</a>
<a name="ln1171">            guarded_ptr&amp; operator=( Guard&amp;&amp; g ) noexcept</a>
<a name="ln1172">            {</a>
<a name="ln1173">                std::swap( guard_, g.guard_ref());</a>
<a name="ln1174">                return *this;</a>
<a name="ln1175">            }</a>
<a name="ln1176"> </a>
<a name="ln1177">            /// The guarded pointer is not copy-assignable</a>
<a name="ln1178">            guarded_ptr&amp; operator=(guarded_ptr const&amp; gp) = delete;</a>
<a name="ln1179"> </a>
<a name="ln1180">            /// Returns a pointer to guarded value</a>
<a name="ln1181">            value_type * operator -&gt;() const noexcept</a>
<a name="ln1182">            {</a>
<a name="ln1183">                assert( !empty());</a>
<a name="ln1184">                return value_cast()( guard_-&gt;get_as&lt;guarded_type&gt;());</a>
<a name="ln1185">            }</a>
<a name="ln1186"> </a>
<a name="ln1187">            /// Returns a reference to guarded value</a>
<a name="ln1188">            value_type&amp; operator *() noexcept</a>
<a name="ln1189">            {</a>
<a name="ln1190">                assert( !empty());</a>
<a name="ln1191">                return *value_cast()( guard_-&gt;get_as&lt;guarded_type&gt;());</a>
<a name="ln1192">            }</a>
<a name="ln1193"> </a>
<a name="ln1194">            /// Returns const reference to guarded value</a>
<a name="ln1195">            value_type const&amp; operator *() const noexcept</a>
<a name="ln1196">            {</a>
<a name="ln1197">                assert( !empty());</a>
<a name="ln1198">                return *value_cast()( guard_-&gt;get_as&lt;guarded_type&gt;());</a>
<a name="ln1199">            }</a>
<a name="ln1200"> </a>
<a name="ln1201">            /// Checks if the guarded pointer is \p nullptr</a>
<a name="ln1202">            bool empty() const noexcept</a>
<a name="ln1203">            {</a>
<a name="ln1204">                return !guard_ || guard_-&gt;get( atomics::memory_order_relaxed ) == nullptr;</a>
<a name="ln1205">            }</a>
<a name="ln1206"> </a>
<a name="ln1207">            /// \p bool operator returns &lt;tt&gt;!empty()&lt;/tt&gt;</a>
<a name="ln1208">            explicit operator bool() const noexcept</a>
<a name="ln1209">            {</a>
<a name="ln1210">                return !empty();</a>
<a name="ln1211">            }</a>
<a name="ln1212"> </a>
<a name="ln1213">            /// Clears guarded pointer</a>
<a name="ln1214">            /**</a>
<a name="ln1215">                If the guarded pointer has been released, the pointer can be disposed (freed) at any time.</a>
<a name="ln1216">                Dereferncing the guarded pointer after \p release() is dangerous.</a>
<a name="ln1217">            */</a>
<a name="ln1218">            void release() noexcept</a>
<a name="ln1219">            {</a>
<a name="ln1220">                free_guard();</a>
<a name="ln1221">            }</a>
<a name="ln1222"> </a>
<a name="ln1223">            //@cond</a>
<a name="ln1224">            // For internal use only!!!</a>
<a name="ln1225">            void reset(guarded_type * p) noexcept</a>
<a name="ln1226">            {</a>
<a name="ln1227">                alloc_guard();</a>
<a name="ln1228">                assert( guard_ );</a>
<a name="ln1229">                guard_-&gt;set(p);</a>
<a name="ln1230">            }</a>
<a name="ln1231">            //@endcond</a>
<a name="ln1232"> </a>
<a name="ln1233">        private:</a>
<a name="ln1234">            //@cond</a>
<a name="ln1235">            void alloc_guard()</a>
<a name="ln1236">            {</a>
<a name="ln1237">                if ( !guard_ )</a>
<a name="ln1238">                    guard_ = hp::smr::tls()-&gt;hazards_.alloc();</a>
<a name="ln1239">            }</a>
<a name="ln1240"> </a>
<a name="ln1241">            void free_guard()</a>
<a name="ln1242">            {</a>
<a name="ln1243">                if ( guard_ ) {</a>
<a name="ln1244">                    hp::smr::tls()-&gt;hazards_.free( guard_ );</a>
<a name="ln1245">                    guard_ = nullptr;</a>
<a name="ln1246">                }</a>
<a name="ln1247">            }</a>
<a name="ln1248">            //@endcond</a>
<a name="ln1249"> </a>
<a name="ln1250">        private:</a>
<a name="ln1251">            //@cond</a>
<a name="ln1252">            hp::guard* guard_;</a>
<a name="ln1253">            //@endcond</a>
<a name="ln1254">        };</a>
<a name="ln1255"> </a>
<a name="ln1256">    public:</a>
<a name="ln1257">        /// \p scan() type</a>
<a name="ln1258">        enum class scan_type {</a>
<a name="ln1259">            classic = hp::classic,    ///&lt; classic scan as described in Michael's papers</a>
<a name="ln1260">            inplace = hp::inplace     ///&lt; inplace scan without allocation</a>
<a name="ln1261">        };</a>
<a name="ln1262"> </a>
<a name="ln1263">        /// Initializes %HP singleton</a>
<a name="ln1264">        /**</a>
<a name="ln1265">            The constructor initializes Hazard Pointer SMR singleton with passed parameters.</a>
<a name="ln1266">            If the instance does not yet exist then the function creates the instance.</a>
<a name="ln1267">            Otherwise it does nothing.</a>
<a name="ln1268"> </a>
<a name="ln1269">            The Michael's %HP reclamation schema depends of three parameters:</a>
<a name="ln1270">            - \p nHazardPtrCount - hazard pointer count per thread. Usually it is small number (up to 10) depending from</a>
<a name="ln1271">                the data structure algorithms. If \p nHazardPtrCount = 0, the defaul value 8 is used</a>
<a name="ln1272">            - \p nMaxThreadCount - max count of thread with using Hazard Pointer GC in your application. Default is 100.</a>
<a name="ln1273">            - \p nMaxRetiredPtrCount - capacity of array of retired pointers for each thread. Must be greater than</a>
<a name="ln1274">                &lt;tt&gt; nHazardPtrCount * nMaxThreadCount &lt;/tt&gt;. Default is &lt;tt&gt;2 * nHazardPtrCount * nMaxThreadCount &lt;/tt&gt;.</a>
<a name="ln1275">        */</a>
<a name="ln1276">        HP(</a>
<a name="ln1277">            size_t nHazardPtrCount = 0,     ///&lt; Hazard pointer count per thread</a>
<a name="ln1278">            size_t nMaxThreadCount = 0,     ///&lt; Max count of simultaneous working thread in your application</a>
<a name="ln1279">            size_t nMaxRetiredPtrCount = 0, ///&lt; Capacity of the array of retired objects for the thread</a>
<a name="ln1280">            scan_type nScanType = scan_type::inplace   ///&lt; Scan type (see \p scan_type enum)</a>
<a name="ln1281">        )</a>
<a name="ln1282">        {</a>
<a name="ln1283">            hp::smr::construct(</a>
<a name="ln1284">                nHazardPtrCount,</a>
<a name="ln1285">                nMaxThreadCount,</a>
<a name="ln1286">                nMaxRetiredPtrCount,</a>
<a name="ln1287">                static_cast&lt;hp::scan_type&gt;(nScanType)</a>
<a name="ln1288">            );</a>
<a name="ln1289">        }</a>
<a name="ln1290"> </a>
<a name="ln1291">        /// Terminates GC singleton</a>
<a name="ln1292">        /**</a>
<a name="ln1293">            The destructor destroys %HP global object. After calling of this function you may \b NOT</a>
<a name="ln1294">            use CDS data structures based on \p %cds::gc::HP.</a>
<a name="ln1295">            Usually, %HP object is destroyed at the end of your \p main().</a>
<a name="ln1296">        */</a>
<a name="ln1297">        ~HP()</a>
<a name="ln1298">        {</a>
<a name="ln1299">            hp::smr::destruct( true );</a>
<a name="ln1300">        }</a>
<a name="ln1301"> </a>
<a name="ln1302">        /// Checks that required hazard pointer count \p nCountNeeded is less or equal then max hazard pointer count</a>
<a name="ln1303">        /**</a>
<a name="ln1304">            If &lt;tt&gt; nRequiredCount &gt; get_hazard_ptr_count()&lt;/tt&gt; then the exception \p not_enough_hazard_ptr is thrown</a>
<a name="ln1305">        */</a>
<a name="ln1306">        static void check_available_guards( size_t nCountNeeded )</a>
<a name="ln1307">        {</a>
<a name="ln1308">            hp::smr::check_hazard_ptr_count( nCountNeeded );</a>
<a name="ln1309">        }</a>
<a name="ln1310"> </a>
<a name="ln1311">        /// Set memory management functions</a>
<a name="ln1312">        /**</a>
<a name="ln1313">            @note This function may be called &lt;b&gt;BEFORE&lt;/b&gt; creating an instance</a>
<a name="ln1314">            of Hazard Pointer SMR</a>
<a name="ln1315"> </a>
<a name="ln1316">            SMR object allocates some memory for thread-specific data and for</a>
<a name="ln1317">            creating SMR object.</a>
<a name="ln1318">            By default, a standard \p new and \p delete operators are used for this.</a>
<a name="ln1319">        */</a>
<a name="ln1320">        static void set_memory_allocator(</a>
<a name="ln1321">            void* ( *alloc_func )( size_t size ),   ///&lt; \p malloc() function</a>
<a name="ln1322">            void( *free_func )( void * p )          ///&lt; \p free() function</a>
<a name="ln1323">        )</a>
<a name="ln1324">        {</a>
<a name="ln1325">            hp::smr::set_memory_allocator( alloc_func, free_func );</a>
<a name="ln1326">        }</a>
<a name="ln1327"> </a>
<a name="ln1328">        /// Returns max Hazard Pointer count</a>
<a name="ln1329">        static size_t max_hazard_count()</a>
<a name="ln1330">        {</a>
<a name="ln1331">            return hp::smr::instance().get_hazard_ptr_count();</a>
<a name="ln1332">        }</a>
<a name="ln1333"> </a>
<a name="ln1334">        /// Returns max count of thread</a>
<a name="ln1335">        static size_t max_thread_count()</a>
<a name="ln1336">        {</a>
<a name="ln1337">            return hp::smr::instance().get_max_thread_count();</a>
<a name="ln1338">        }</a>
<a name="ln1339"> </a>
<a name="ln1340">        /// Returns capacity of retired pointer array</a>
<a name="ln1341">        static size_t retired_array_capacity()</a>
<a name="ln1342">        {</a>
<a name="ln1343">            return hp::smr::instance().get_max_retired_ptr_count();</a>
<a name="ln1344">        }</a>
<a name="ln1345"> </a>
<a name="ln1346">        /// Retire pointer \p p with function \p func</a>
<a name="ln1347">        /**</a>
<a name="ln1348">            The function places pointer \p p to array of pointers ready for removing.</a>
<a name="ln1349">            (so called retired pointer array). The pointer can be safely removed when no hazard pointer points to it.</a>
<a name="ln1350">            \p func is a disposer: when \p p can be safely removed, \p func is called.</a>
<a name="ln1351">        */</a>
<a name="ln1352">        template &lt;typename T&gt;</a>
<a name="ln1353">        static void retire( T * p, void( *func )( void * ))</a>
<a name="ln1354">        {</a>
<a name="ln1355">            hp::thread_data* rec = hp::smr::tls();</a>
<a name="ln1356">            if ( !rec-&gt;retired_.push( hp::retired_ptr( p, func )))</a>
<a name="ln1357">                hp::smr::instance().scan( rec );</a>
<a name="ln1358">        }</a>
<a name="ln1359"> </a>
<a name="ln1360">        /// Retire pointer \p p with functor of type \p Disposer</a>
<a name="ln1361">        /**</a>
<a name="ln1362">            The function places pointer \p p to array of pointers ready for removing.</a>
<a name="ln1363">            (so called retired pointer array). The pointer can be safely removed when no hazard pointer points to it.</a>
<a name="ln1364"> </a>
<a name="ln1365">            Deleting the pointer is an invocation of some object of type \p Disposer; the interface of \p Disposer is:</a>
<a name="ln1366">            \code</a>
<a name="ln1367">            template &lt;typename T&gt;</a>
<a name="ln1368">            struct disposer {</a>
<a name="ln1369">                void operator()( T * p )    ;   // disposing operator</a>
<a name="ln1370">            };</a>
<a name="ln1371">            \endcode</a>
<a name="ln1372">            Since the functor call can happen at any time after \p retire() call, additional restrictions are imposed to \p Disposer type:</a>
<a name="ln1373">            - it should be stateless functor</a>
<a name="ln1374">            - it should be default-constructible</a>
<a name="ln1375">            - the result of functor call with argument \p p should not depend on where the functor will be called.</a>
<a name="ln1376"> </a>
<a name="ln1377">            \par Examples:</a>
<a name="ln1378">            Operator \p delete functor:</a>
<a name="ln1379">            \code</a>
<a name="ln1380">            template &lt;typename T&gt;</a>
<a name="ln1381">            struct disposer {</a>
<a name="ln1382">                void operator ()( T * p ) {</a>
<a name="ln1383">                    delete p;</a>
<a name="ln1384">                }</a>
<a name="ln1385">            };</a>
<a name="ln1386"> </a>
<a name="ln1387">            // How to call HP::retire method</a>
<a name="ln1388">            int * p = new int;</a>
<a name="ln1389"> </a>
<a name="ln1390">            // ... use p in lock-free manner</a>
<a name="ln1391"> </a>
<a name="ln1392">            cds::gc::HP::retire&lt;disposer&gt;( p ) ;   // place p to retired pointer array of HP GC</a>
<a name="ln1393">            \endcode</a>
<a name="ln1394"> </a>
<a name="ln1395">            Functor based on \p std::allocator :</a>
<a name="ln1396">            \code</a>
<a name="ln1397">            template &lt;typename Alloc = std::allocator&lt;int&gt; &gt;</a>
<a name="ln1398">            struct disposer {</a>
<a name="ln1399">                template &lt;typename T&gt;</a>
<a name="ln1400">                void operator()( T * p ) {</a>
<a name="ln1401">                    typedef typename Alloc::templare rebind&lt;T&gt;::other alloc_t;</a>
<a name="ln1402">                    alloc_t a;</a>
<a name="ln1403">                    a.destroy( p );</a>
<a name="ln1404">                    a.deallocate( p, 1 );</a>
<a name="ln1405">                }</a>
<a name="ln1406">            };</a>
<a name="ln1407">            \endcode</a>
<a name="ln1408">        */</a>
<a name="ln1409">        template &lt;class Disposer, typename T&gt;</a>
<a name="ln1410">        static void retire( T * p )</a>
<a name="ln1411">        {</a>
<a name="ln1412">            if ( !hp::smr::tls()-&gt;retired_.push( hp::retired_ptr( p, +[]( void* p ) { Disposer()( static_cast&lt;T*&gt;( p )); })))</a>
<a name="ln1413">                scan();</a>
<a name="ln1414">        }</a>
<a name="ln1415"> </a>
<a name="ln1416">        /// Get current scan strategy</a>
<a name="ln1417">        static scan_type getScanType()</a>
<a name="ln1418">        {</a>
<a name="ln1419">            return static_cast&lt;scan_type&gt;( hp::smr::instance().get_scan_type());</a>
<a name="ln1420">        }</a>
<a name="ln1421"> </a>
<a name="ln1422">        /// Checks if Hazard Pointer GC is constructed and may be used</a>
<a name="ln1423">        static bool isUsed()</a>
<a name="ln1424">        {</a>
<a name="ln1425">            return hp::smr::isUsed();</a>
<a name="ln1426">        }</a>
<a name="ln1427"> </a>
<a name="ln1428">        /// Forces SMR call for current thread</a>
<a name="ln1429">        /**</a>
<a name="ln1430">            Usually, this function should not be called directly.</a>
<a name="ln1431">        */</a>
<a name="ln1432">        static void scan()</a>
<a name="ln1433">        {</a>
<a name="ln1434">            hp::smr::instance().scan( hp::smr::tls());</a>
<a name="ln1435">        }</a>
<a name="ln1436"> </a>
<a name="ln1437">        /// Synonym for \p scan()</a>
<a name="ln1438">        static void force_dispose()</a>
<a name="ln1439">        {</a>
<a name="ln1440">            scan();</a>
<a name="ln1441">        }</a>
<a name="ln1442"> </a>
<a name="ln1443">        /// Returns internal statistics</a>
<a name="ln1444">        /**</a>
<a name="ln1445">            The function clears \p st before gathering statistics.</a>
<a name="ln1446"> </a>
<a name="ln1447">            @note Internal statistics is available only if you compile</a>
<a name="ln1448">            \p libcds and your program with \p -DCDS_ENABLE_HPSTAT.</a>
<a name="ln1449">        */</a>
<a name="ln1450">        static void statistics( stat&amp; st )</a>
<a name="ln1451">        {</a>
<a name="ln1452">            hp::smr::instance().statistics( st );</a>
<a name="ln1453">        }</a>
<a name="ln1454"> </a>
<a name="ln1455">        /// Returns post-mortem statistics</a>
<a name="ln1456">        /**</a>
<a name="ln1457">            Post-mortem statistics is gathered in the \p %HP object destructor</a>
<a name="ln1458">            and can be accessible after destructing the global \p %HP object.</a>
<a name="ln1459"> </a>
<a name="ln1460">            @note Internal statistics is available only if you compile</a>
<a name="ln1461">            \p libcds and your program with \p -DCDS_ENABLE_HPSTAT.</a>
<a name="ln1462"> </a>
<a name="ln1463">            Usage:</a>
<a name="ln1464">            \code</a>
<a name="ln1465">            int main()</a>
<a name="ln1466">            {</a>
<a name="ln1467">                cds::Initialize();</a>
<a name="ln1468">                {</a>
<a name="ln1469">                    // Initialize HP SMR</a>
<a name="ln1470">                    cds::gc::HP hp;</a>
<a name="ln1471"> </a>
<a name="ln1472">                    // deal with HP-based data structured</a>
<a name="ln1473">                    // ...</a>
<a name="ln1474">                }</a>
<a name="ln1475"> </a>
<a name="ln1476">                // HP object destroyed</a>
<a name="ln1477">                // Get total post-mortem statistics</a>
<a name="ln1478">                cds::gc::HP::stat const&amp; st = cds::gc::HP::postmortem_statistics();</a>
<a name="ln1479"> </a>
<a name="ln1480">                printf( &quot;HP statistics:\n&quot;</a>
<a name="ln1481">                    &quot;  thread count           = %llu\n&quot;</a>
<a name="ln1482">                    &quot;  guard allocated        = %llu\n&quot;</a>
<a name="ln1483">                    &quot;  guard freed            = %llu\n&quot;</a>
<a name="ln1484">                    &quot;  retired data count     = %llu\n&quot;</a>
<a name="ln1485">                    &quot;  free data count        = %llu\n&quot;</a>
<a name="ln1486">                    &quot;  scan() call count      = %llu\n&quot;</a>
<a name="ln1487">                    &quot;  help_scan() call count = %llu\n&quot;,</a>
<a name="ln1488">                    st.thread_rec_count,</a>
<a name="ln1489">                    st.guard_allocated, st.guard_freed,</a>
<a name="ln1490">                    st.retired_count, st.free_count,</a>
<a name="ln1491">                    st.scan_count, st.help_scan_count</a>
<a name="ln1492">                );</a>
<a name="ln1493"> </a>
<a name="ln1494">                cds::Terminate();</a>
<a name="ln1495">            }</a>
<a name="ln1496">            \endcode</a>
<a name="ln1497">        */</a>
<a name="ln1498">        CDS_EXPORT_API static stat const&amp; postmortem_statistics();</a>
<a name="ln1499">    };</a>
<a name="ln1500"> </a>
<a name="ln1501">}} // namespace cds::gc</a>
<a name="ln1502"> </a>
<a name="ln1503">#endif // #ifndef CDSLIB_GC_HP_SMR_H</a>
<a name="ln1504"> </a>

</code></pre>
<div class="balloon" rel="355"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: pad1_, pad2_.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
