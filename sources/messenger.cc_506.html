
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>messenger.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Licensed to the Apache Software Foundation (ASF) under one</a>
<a name="ln2">// or more contributor license agreements.  See the NOTICE file</a>
<a name="ln3">// distributed with this work for additional information</a>
<a name="ln4">// regarding copyright ownership.  The ASF licenses this file</a>
<a name="ln5">// to you under the Apache License, Version 2.0 (the</a>
<a name="ln6">// &quot;License&quot;); you may not use this file except in compliance</a>
<a name="ln7">// with the License.  You may obtain a copy of the License at</a>
<a name="ln8">//</a>
<a name="ln9">//   http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln10">//</a>
<a name="ln11">// Unless required by applicable law or agreed to in writing,</a>
<a name="ln12">// software distributed under the License is distributed on an</a>
<a name="ln13">// &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</a>
<a name="ln14">// KIND, either express or implied.  See the License for the</a>
<a name="ln15">// specific language governing permissions and limitations</a>
<a name="ln16">// under the License.</a>
<a name="ln17">//</a>
<a name="ln18">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln19">//</a>
<a name="ln20">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln21">//</a>
<a name="ln22">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln23">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln24">//</a>
<a name="ln25">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln26">//</a>
<a name="ln27">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln28">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln29">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln30">// under the License.</a>
<a name="ln31">//</a>
<a name="ln32"> </a>
<a name="ln33">#include &quot;yb/rpc/messenger.h&quot;</a>
<a name="ln34"> </a>
<a name="ln35">#include &lt;arpa/inet.h&gt;</a>
<a name="ln36">#include &lt;sys/socket.h&gt;</a>
<a name="ln37">#include &lt;sys/types.h&gt;</a>
<a name="ln38">#include &lt;unistd.h&gt;</a>
<a name="ln39"> </a>
<a name="ln40">#include &lt;list&gt;</a>
<a name="ln41">#include &lt;mutex&gt;</a>
<a name="ln42">#include &lt;set&gt;</a>
<a name="ln43">#include &lt;string&gt;</a>
<a name="ln44">#include &lt;thread&gt;</a>
<a name="ln45"> </a>
<a name="ln46">#include &lt;gflags/gflags.h&gt;</a>
<a name="ln47">#include &lt;glog/logging.h&gt;</a>
<a name="ln48"> </a>
<a name="ln49">#include &quot;yb/gutil/gscoped_ptr.h&quot;</a>
<a name="ln50">#include &quot;yb/gutil/map-util.h&quot;</a>
<a name="ln51">#include &quot;yb/gutil/stl_util.h&quot;</a>
<a name="ln52">#include &quot;yb/gutil/strings/substitute.h&quot;</a>
<a name="ln53"> </a>
<a name="ln54">#include &quot;yb/rpc/acceptor.h&quot;</a>
<a name="ln55">#include &quot;yb/rpc/connection.h&quot;</a>
<a name="ln56">#include &quot;yb/rpc/constants.h&quot;</a>
<a name="ln57">#include &quot;yb/rpc/proxy.h&quot;</a>
<a name="ln58">#include &quot;yb/rpc/rpc_header.pb.h&quot;</a>
<a name="ln59">#include &quot;yb/rpc/rpc_metrics.h&quot;</a>
<a name="ln60">#include &quot;yb/rpc/rpc_service.h&quot;</a>
<a name="ln61">#include &quot;yb/rpc/rpc_util.h&quot;</a>
<a name="ln62">#include &quot;yb/rpc/tcp_stream.h&quot;</a>
<a name="ln63">#include &quot;yb/rpc/yb_rpc.h&quot;</a>
<a name="ln64"> </a>
<a name="ln65">#include &quot;yb/util/errno.h&quot;</a>
<a name="ln66">#include &quot;yb/util/flag_tags.h&quot;</a>
<a name="ln67">#include &quot;yb/util/logging.h&quot;</a>
<a name="ln68">#include &quot;yb/util/metrics.h&quot;</a>
<a name="ln69">#include &quot;yb/util/monotime.h&quot;</a>
<a name="ln70">#include &quot;yb/util/net/dns_resolver.h&quot;</a>
<a name="ln71">#include &quot;yb/util/net/socket.h&quot;</a>
<a name="ln72">#include &quot;yb/util/scope_exit.h&quot;</a>
<a name="ln73">#include &quot;yb/util/size_literals.h&quot;</a>
<a name="ln74">#include &quot;yb/util/status.h&quot;</a>
<a name="ln75">#include &quot;yb/util/threadpool.h&quot;</a>
<a name="ln76">#include &quot;yb/util/thread_restrictions.h&quot;</a>
<a name="ln77">#include &quot;yb/util/trace.h&quot;</a>
<a name="ln78"> </a>
<a name="ln79">using namespace std::literals;</a>
<a name="ln80">using namespace std::placeholders;</a>
<a name="ln81">using namespace yb::size_literals;</a>
<a name="ln82"> </a>
<a name="ln83">using std::string;</a>
<a name="ln84">using std::shared_ptr;</a>
<a name="ln85">using strings::Substitute;</a>
<a name="ln86"> </a>
<a name="ln87">DECLARE_int32(num_connections_to_server);</a>
<a name="ln88">DEFINE_int32(rpc_default_keepalive_time_ms, 65000,</a>
<a name="ln89">             &quot;If an RPC connection from a client is idle for this amount of time, the server &quot;</a>
<a name="ln90">             &quot;will disconnect the client. Setting flag to 0 disables this clean up.&quot;);</a>
<a name="ln91">TAG_FLAG(rpc_default_keepalive_time_ms, advanced);</a>
<a name="ln92">DEFINE_uint64(io_thread_pool_size, 4, &quot;Size of allocated IO Thread Pool.&quot;);</a>
<a name="ln93"> </a>
<a name="ln94">DEFINE_int64(outbound_rpc_memory_limit, 0, &quot;Outbound RPC memory limit&quot;);</a>
<a name="ln95"> </a>
<a name="ln96">DEFINE_int32(rpc_queue_limit, 10000, &quot;Queue limit for rpc server&quot;);</a>
<a name="ln97">DEFINE_int32(rpc_workers_limit, 1024, &quot;Workers limit for rpc server&quot;);</a>
<a name="ln98"> </a>
<a name="ln99">DEFINE_int32(socket_receive_buffer_size, 0, &quot;Socket receive buffer size, 0 to use default&quot;);</a>
<a name="ln100"> </a>
<a name="ln101">namespace yb {</a>
<a name="ln102">namespace rpc {</a>
<a name="ln103"> </a>
<a name="ln104">class Messenger;</a>
<a name="ln105">class ServerBuilder;</a>
<a name="ln106"> </a>
<a name="ln107">// ------------------------------------------------------------------------------------------------</a>
<a name="ln108">// MessengerBuilder</a>
<a name="ln109">// ------------------------------------------------------------------------------------------------</a>
<a name="ln110"> </a>
<a name="ln111">MessengerBuilder::MessengerBuilder(std::string name)</a>
<a name="ln112">    : name_(std::move(name)),</a>
<a name="ln113">      connection_keepalive_time_(FLAGS_rpc_default_keepalive_time_ms * 1ms),</a>
<a name="ln114">      coarse_timer_granularity_(100ms),</a>
<a name="ln115">      listen_protocol_(TcpStream::StaticProtocol()),</a>
<a name="ln116">      queue_limit_(FLAGS_rpc_queue_limit),</a>
<a name="ln117">      workers_limit_(FLAGS_rpc_workers_limit),</a>
<a name="ln118">      num_connections_to_server_(GetAtomicFlag(&amp;FLAGS_num_connections_to_server)) {</a>
<a name="ln119">  AddStreamFactory(TcpStream::StaticProtocol(), TcpStream::Factory());</a>
<a name="ln120">}</a>
<a name="ln121"> </a>
<a name="ln122">MessengerBuilder&amp; MessengerBuilder::set_connection_keepalive_time(</a>
<a name="ln123">    CoarseMonoClock::Duration keepalive) {</a>
<a name="ln124">  connection_keepalive_time_ = keepalive;</a>
<a name="ln125">  return *this;</a>
<a name="ln126">}</a>
<a name="ln127"> </a>
<a name="ln128">MessengerBuilder&amp; MessengerBuilder::set_num_reactors(int num_reactors) {</a>
<a name="ln129">  num_reactors_ = num_reactors;</a>
<a name="ln130">  return *this;</a>
<a name="ln131">}</a>
<a name="ln132"> </a>
<a name="ln133">MessengerBuilder&amp; MessengerBuilder::set_coarse_timer_granularity(</a>
<a name="ln134">    CoarseMonoClock::Duration granularity) {</a>
<a name="ln135">  coarse_timer_granularity_ = granularity;</a>
<a name="ln136">  return *this;</a>
<a name="ln137">}</a>
<a name="ln138"> </a>
<a name="ln139">MessengerBuilder &amp;MessengerBuilder::set_metric_entity(</a>
<a name="ln140">    const scoped_refptr&lt;MetricEntity&gt;&amp; metric_entity) {</a>
<a name="ln141">  metric_entity_ = metric_entity;</a>
<a name="ln142">  return *this;</a>
<a name="ln143">}</a>
<a name="ln144"> </a>
<a name="ln145">Result&lt;std::unique_ptr&lt;Messenger&gt;&gt; MessengerBuilder::Build() {</a>
<a name="ln146">  if (!connection_context_factory_) {</a>
<a name="ln147">    UseDefaultConnectionContextFactory();</a>
<a name="ln148">  }</a>
<a name="ln149">  std::unique_ptr&lt;Messenger&gt; messenger(new Messenger(*this));</a>
<a name="ln150">  RETURN_NOT_OK(messenger-&gt;Init());</a>
<a name="ln151"> </a>
<a name="ln152">  return messenger;</a>
<a name="ln153">}</a>
<a name="ln154"> </a>
<a name="ln155">MessengerBuilder &amp;MessengerBuilder::AddStreamFactory(</a>
<a name="ln156">    const Protocol* protocol, StreamFactoryPtr factory) {</a>
<a name="ln157">  auto p = stream_factories_.emplace(protocol, std::move(factory));</a>
<a name="ln158">  LOG_IF(DFATAL, !p.second) &lt;&lt; &quot;Duplicate stream factory: &quot; &lt;&lt; protocol-&gt;ToString();</a>
<a name="ln159">  return *this;</a>
<a name="ln160">}</a>
<a name="ln161"> </a>
<a name="ln162">MessengerBuilder &amp;MessengerBuilder::UseDefaultConnectionContextFactory(</a>
<a name="ln163">    const std::shared_ptr&lt;MemTracker&gt;&amp; parent_mem_tracker) {</a>
<a name="ln164">  if (parent_mem_tracker) {</a>
<a name="ln165">    last_used_parent_mem_tracker_ = parent_mem_tracker;</a>
<a name="ln166">  }</a>
<a name="ln167">  connection_context_factory_ = rpc::CreateConnectionContextFactory&lt;YBOutboundConnectionContext&gt;(</a>
<a name="ln168">      FLAGS_outbound_rpc_memory_limit, parent_mem_tracker);</a>
<a name="ln169">  return *this;</a>
<a name="ln170">}</a>
<a name="ln171"> </a>
<a name="ln172">// ------------------------------------------------------------------------------------------------</a>
<a name="ln173">// Messenger</a>
<a name="ln174">// ------------------------------------------------------------------------------------------------</a>
<a name="ln175"> </a>
<a name="ln176">void Messenger::Shutdown() {</a>
<a name="ln177">  ShutdownThreadPools();</a>
<a name="ln178">  ShutdownAcceptor();</a>
<a name="ln179">  UnregisterAllServices();</a>
<a name="ln180"> </a>
<a name="ln181">  // Since we're shutting down, it's OK to block.</a>
<a name="ln182">  ThreadRestrictions::ScopedAllowWait allow_wait;</a>
<a name="ln183"> </a>
<a name="ln184">  std::vector&lt;Reactor*&gt; reactors;</a>
<a name="ln185">  std::unique_ptr&lt;Acceptor&gt; acceptor;</a>
<a name="ln186">  {</a>
<a name="ln187">    std::lock_guard&lt;percpu_rwlock&gt; guard(lock_);</a>
<a name="ln188">    if (closing_) {</a>
<a name="ln189">      return;</a>
<a name="ln190">    }</a>
<a name="ln191">    VLOG(1) &lt;&lt; &quot;shutting down messenger &quot; &lt;&lt; name_;</a>
<a name="ln192">    closing_ = true;</a>
<a name="ln193"> </a>
<a name="ln194">    DCHECK(rpc_services_.empty()) &lt;&lt; &quot;Unregister RPC services before shutting down Messenger&quot;;</a>
<a name="ln195">    rpc_services_.clear();</a>
<a name="ln196"> </a>
<a name="ln197">    acceptor.swap(acceptor_);</a>
<a name="ln198"> </a>
<a name="ln199">    for (const auto&amp; reactor : reactors_) {</a>
<a name="ln200">      reactors.push_back(reactor.get());</a>
<a name="ln201">    }</a>
<a name="ln202">  }</a>
<a name="ln203"> </a>
<a name="ln204">  if (acceptor) {</a>
<a name="ln205">    acceptor-&gt;Shutdown();</a>
<a name="ln206">  }</a>
<a name="ln207"> </a>
<a name="ln208">  for (auto* reactor : reactors) {</a>
<a name="ln209">    reactor-&gt;Shutdown();</a>
<a name="ln210">  }</a>
<a name="ln211"> </a>
<a name="ln212">  scheduler_.Shutdown();</a>
<a name="ln213">  io_thread_pool_.Shutdown();</a>
<a name="ln214"> </a>
<a name="ln215">  for (auto* reactor : reactors) {</a>
<a name="ln216">    reactor-&gt;Join();</a>
<a name="ln217">  }</a>
<a name="ln218"> </a>
<a name="ln219">  io_thread_pool_.Join();</a>
<a name="ln220"> </a>
<a name="ln221">  {</a>
<a name="ln222">    std::lock_guard&lt;std::mutex&gt; guard(mutex_scheduled_tasks_);</a>
<a name="ln223">    LOG_IF(DFATAL, !scheduled_tasks_.empty())</a>
<a name="ln224">        &lt;&lt; &quot;Scheduled tasks is not empty after messenger shutdown: &quot;</a>
<a name="ln225">        &lt;&lt; yb::ToString(scheduled_tasks_);</a>
<a name="ln226">  }</a>
<a name="ln227">}</a>
<a name="ln228"> </a>
<a name="ln229">Status Messenger::ListenAddress(</a>
<a name="ln230">    ConnectionContextFactoryPtr factory, const Endpoint&amp; accept_endpoint,</a>
<a name="ln231">    Endpoint* bound_endpoint) {</a>
<a name="ln232">  Acceptor* acceptor;</a>
<a name="ln233">  {</a>
<a name="ln234">    std::lock_guard&lt;percpu_rwlock&gt; guard(lock_);</a>
<a name="ln235">    if (!acceptor_) {</a>
<a name="ln236">      acceptor_.reset(new Acceptor(</a>
<a name="ln237">          metric_entity_, std::bind(&amp;Messenger::RegisterInboundSocket, this, factory, _1, _2)));</a>
<a name="ln238">    }</a>
<a name="ln239">    auto accept_host = accept_endpoint.address();</a>
<a name="ln240">    auto&amp; outbound_address = accept_host.is_v6() ? outbound_address_v6_</a>
<a name="ln241">                                                 : outbound_address_v4_;</a>
<a name="ln242">    if (outbound_address.is_unspecified() &amp;&amp; !accept_host.is_unspecified()) {</a>
<a name="ln243">      outbound_address = accept_host;</a>
<a name="ln244">    }</a>
<a name="ln245">    acceptor = acceptor_.get();</a>
<a name="ln246">  }</a>
<a name="ln247">  return acceptor-&gt;Listen(accept_endpoint, bound_endpoint);</a>
<a name="ln248">}</a>
<a name="ln249"> </a>
<a name="ln250">Status Messenger::StartAcceptor() {</a>
<a name="ln251">  std::lock_guard&lt;percpu_rwlock&gt; guard(lock_);</a>
<a name="ln252">  if (acceptor_) {</a>
<a name="ln253">    return acceptor_-&gt;Start();</a>
<a name="ln254">  } else {</a>
<a name="ln255">    return STATUS(IllegalState, &quot;Trying to start acceptor w/o active addresses&quot;);</a>
<a name="ln256">  }</a>
<a name="ln257">}</a>
<a name="ln258"> </a>
<a name="ln259">void Messenger::BreakConnectivityWith(const IpAddress&amp; address) {</a>
<a name="ln260">  BreakConnectivity(address, /* incoming */ true, /* outgoing */ true);</a>
<a name="ln261">}</a>
<a name="ln262">void Messenger::BreakConnectivityTo(const IpAddress&amp; address) {</a>
<a name="ln263">  BreakConnectivity(address, /* incoming */ false, /* outgoing */ true);</a>
<a name="ln264">}</a>
<a name="ln265"> </a>
<a name="ln266">void Messenger::BreakConnectivityFrom(const IpAddress&amp; address) {</a>
<a name="ln267">  BreakConnectivity(address, /* incoming */ true, /* outgoing */ false);</a>
<a name="ln268">}</a>
<a name="ln269"> </a>
<a name="ln270">void Messenger::BreakConnectivity(const IpAddress&amp; address, bool incoming, bool outgoing) {</a>
<a name="ln271">  LOG(INFO) &lt;&lt; &quot;TEST: Break &quot; &lt;&lt; (incoming ? &quot;incoming&quot; : &quot;&quot;) &lt;&lt; &quot;/&quot; &lt;&lt; (outgoing ? &quot;outgoing&quot; : &quot;&quot;)</a>
<a name="ln272">            &lt;&lt; &quot; connectivity with: &quot; &lt;&lt; address;</a>
<a name="ln273"> </a>
<a name="ln274">  boost::optional&lt;CountDownLatch&gt; latch;</a>
<a name="ln275">  {</a>
<a name="ln276">    std::lock_guard&lt;percpu_rwlock&gt; guard(lock_);</a>
<a name="ln277">    if (broken_connectivity_from_.empty() || broken_connectivity_to_.empty()) {</a>
<a name="ln278">      has_broken_connectivity_.store(true, std::memory_order_release);</a>
<a name="ln279">    }</a>
<a name="ln280">    bool inserted_from = false;</a>
<a name="ln281">    if (incoming) {</a>
<a name="ln282">      inserted_from = broken_connectivity_from_.insert(address).second;</a>
<a name="ln283">    }</a>
<a name="ln284">    bool inserted_to = false;</a>
<a name="ln285">    if (outgoing) {</a>
<a name="ln286">      inserted_to = broken_connectivity_to_.insert(address).second;</a>
<a name="ln287">    }</a>
<a name="ln288">    if (inserted_from || inserted_to) {</a>
<a name="ln289">      latch.emplace(reactors_.size());</a>
<a name="ln290">      for (const auto&amp; reactor : reactors_) {</a>
<a name="ln291">        auto scheduled = reactor-&gt;ScheduleReactorTask(MakeFunctorReactorTask(</a>
<a name="ln292">            [&amp;latch, address, incoming, outgoing](Reactor* reactor) {</a>
<a name="ln293">              if (incoming) {</a>
<a name="ln294">                reactor-&gt;DropIncomingWithRemoteAddress(address);</a>
<a name="ln295">              }</a>
<a name="ln296">              if (outgoing) {</a>
<a name="ln297">                reactor-&gt;DropOutgoingWithRemoteAddress(address);</a>
<a name="ln298">              }</a>
<a name="ln299">              latch-&gt;CountDown();</a>
<a name="ln300">            },</a>
<a name="ln301">            SOURCE_LOCATION()));</a>
<a name="ln302">        if (!scheduled) {</a>
<a name="ln303">          LOG(INFO) &lt;&lt; &quot;Failed to schedule drop connection with: &quot; &lt;&lt; address.to_string();</a>
<a name="ln304">          latch-&gt;CountDown();</a>
<a name="ln305">        }</a>
<a name="ln306">      }</a>
<a name="ln307">    }</a>
<a name="ln308">  }</a>
<a name="ln309"> </a>
<a name="ln310">  if (latch) {</a>
<a name="ln311">    latch-&gt;Wait();</a>
<a name="ln312">  }</a>
<a name="ln313">}</a>
<a name="ln314"> </a>
<a name="ln315">void Messenger::RestoreConnectivityWith(const IpAddress&amp; address) {</a>
<a name="ln316">  RestoreConnectivity(address, /* incoming */ true, /* outgoing */ true);</a>
<a name="ln317">}</a>
<a name="ln318">void Messenger::RestoreConnectivityTo(const IpAddress&amp; address) {</a>
<a name="ln319">  RestoreConnectivity(address, /* incoming */ false, /* outgoing */ true);</a>
<a name="ln320">}</a>
<a name="ln321"> </a>
<a name="ln322">void Messenger::RestoreConnectivityFrom(const IpAddress&amp; address) {</a>
<a name="ln323">  RestoreConnectivity(address, /* incoming */ true, /* outgoing */ false);</a>
<a name="ln324">}</a>
<a name="ln325"> </a>
<a name="ln326">void Messenger::RestoreConnectivity(const IpAddress&amp; address, bool incoming, bool outgoing) {</a>
<a name="ln327">  LOG(INFO) &lt;&lt; &quot;TEST: Restore &quot; &lt;&lt; (incoming ? &quot;incoming&quot; : &quot;&quot;) &lt;&lt; &quot;/&quot;</a>
<a name="ln328">            &lt;&lt; (outgoing ? &quot;outgoing&quot; : &quot;&quot;) &lt;&lt; &quot; connectivity with: &quot; &lt;&lt; address;</a>
<a name="ln329"> </a>
<a name="ln330">  std::lock_guard&lt;percpu_rwlock&gt; guard(lock_);</a>
<a name="ln331">  if (incoming) {</a>
<a name="ln332">    broken_connectivity_from_.erase(address);</a>
<a name="ln333">  }</a>
<a name="ln334">  if (outgoing) {</a>
<a name="ln335">    broken_connectivity_to_.erase(address);</a>
<a name="ln336">  }</a>
<a name="ln337">  if (broken_connectivity_from_.empty() &amp;&amp; broken_connectivity_to_.empty()) {</a>
<a name="ln338">    has_broken_connectivity_.store(false, std::memory_order_release);</a>
<a name="ln339">  }</a>
<a name="ln340">}</a>
<a name="ln341"> </a>
<a name="ln342">bool Messenger::TEST_ShouldArtificiallyRejectIncomingCallsFrom(const IpAddress &amp;remote) {</a>
<a name="ln343">  if (has_broken_connectivity_.load(std::memory_order_acquire)) {</a>
<a name="ln344">    shared_lock&lt;rw_spinlock&gt; guard(lock_.get_lock());</a>
<a name="ln345">    return broken_connectivity_from_.count(remote) != 0;</a>
<a name="ln346">  }</a>
<a name="ln347">  return false;</a>
<a name="ln348">}</a>
<a name="ln349"> </a>
<a name="ln350">bool Messenger::TEST_ShouldArtificiallyRejectOutgoingCallsTo(const IpAddress &amp;remote) {</a>
<a name="ln351">  if (has_broken_connectivity_.load(std::memory_order_acquire)) {</a>
<a name="ln352">    shared_lock&lt;rw_spinlock&gt; guard(lock_.get_lock());</a>
<a name="ln353">    return broken_connectivity_to_.count(remote) != 0;</a>
<a name="ln354">  }</a>
<a name="ln355">  return false;</a>
<a name="ln356">}</a>
<a name="ln357"> </a>
<a name="ln358">Status Messenger::TEST_GetReactorMetrics(size_t reactor_idx, ReactorMetrics* metrics) {</a>
<a name="ln359">  if (reactor_idx &gt;= reactors_.size()) {</a>
<a name="ln360">    return STATUS_FORMAT(</a>
<a name="ln361">        InvalidArgument, &quot;Invalid reactor index $0, should be &gt;=0 and &lt;$1&quot;, reactor_idx,</a>
<a name="ln362">        reactors_.size());</a>
<a name="ln363">  }</a>
<a name="ln364">  return reactors_[reactor_idx]-&gt;GetMetrics(metrics);</a>
<a name="ln365">}</a>
<a name="ln366"> </a>
<a name="ln367">void Messenger::ShutdownAcceptor() {</a>
<a name="ln368">  std::unique_ptr&lt;Acceptor&gt; acceptor;</a>
<a name="ln369">  {</a>
<a name="ln370">    std::lock_guard&lt;percpu_rwlock&gt; guard(lock_);</a>
<a name="ln371">    acceptor.swap(acceptor_);</a>
<a name="ln372">  }</a>
<a name="ln373">  if (acceptor) {</a>
<a name="ln374">    acceptor-&gt;Shutdown();</a>
<a name="ln375">  }</a>
<a name="ln376">}</a>
<a name="ln377"> </a>
<a name="ln378">rpc::ThreadPool&amp; Messenger::ThreadPool(ServicePriority priority) {</a>
<a name="ln379">  switch (priority) {</a>
<a name="ln380">    case ServicePriority::kNormal:</a>
<a name="ln381">      return *normal_thread_pool_;</a>
<a name="ln382">    case ServicePriority::kHigh:</a>
<a name="ln383">      auto high_priority_thread_pool = high_priority_thread_pool_.get();</a>
<a name="ln384">      if (high_priority_thread_pool) {</a>
<a name="ln385">        return *high_priority_thread_pool;</a>
<a name="ln386">      }</a>
<a name="ln387">      std::lock_guard&lt;std::mutex&gt; lock(mutex_high_priority_thread_pool_);</a>
<a name="ln388">      high_priority_thread_pool = high_priority_thread_pool_.get();</a>
<a name="ln389">      if (high_priority_thread_pool) {</a>
<a name="ln390">        return *high_priority_thread_pool;</a>
<a name="ln391">      }</a>
<a name="ln392">      const ThreadPoolOptions&amp; options = normal_thread_pool_-&gt;options();</a>
<a name="ln393">      high_priority_thread_pool_.reset(new rpc::ThreadPool(</a>
<a name="ln394">          name_ + &quot;-high-pri&quot;, options.queue_limit, options.max_workers));</a>
<a name="ln395">      return *high_priority_thread_pool_.get();</a>
<a name="ln396">  }</a>
<a name="ln397">  FATAL_INVALID_ENUM_VALUE(ServicePriority, priority);</a>
<a name="ln398">}</a>
<a name="ln399"> </a>
<a name="ln400">// Register a new RpcService to handle inbound requests.</a>
<a name="ln401">Status Messenger::RegisterService(const string&amp; service_name,</a>
<a name="ln402">                                  const scoped_refptr&lt;RpcService&gt;&amp; service) {</a>
<a name="ln403">  DCHECK(service);</a>
<a name="ln404">  std::lock_guard&lt;percpu_rwlock&gt; guard(lock_);</a>
<a name="ln405">  if (InsertIfNotPresent(&amp;rpc_services_, service_name, service)) {</a>
<a name="ln406">    UpdateServicesCache(&amp;guard);</a>
<a name="ln407">    return Status::OK();</a>
<a name="ln408">  } else {</a>
<a name="ln409">    return STATUS_SUBSTITUTE(AlreadyPresent, &quot;Service $0 is already present&quot;, service_name);</a>
<a name="ln410">  }</a>
<a name="ln411">}</a>
<a name="ln412"> </a>
<a name="ln413">void Messenger::ShutdownThreadPools() {</a>
<a name="ln414">  normal_thread_pool_-&gt;Shutdown();</a>
<a name="ln415">  auto high_priority_thread_pool = high_priority_thread_pool_.get();</a>
<a name="ln416">  if (high_priority_thread_pool) {</a>
<a name="ln417">    high_priority_thread_pool-&gt;Shutdown();</a>
<a name="ln418">  }</a>
<a name="ln419">}</a>
<a name="ln420"> </a>
<a name="ln421">void Messenger::UnregisterAllServices() {</a>
<a name="ln422">  decltype(rpc_services_) rpc_services_copy; // Drain rpc services here,</a>
<a name="ln423">                                             // to avoid deleting them in locked state.</a>
<a name="ln424">  {</a>
<a name="ln425">    std::lock_guard&lt;percpu_rwlock&gt; guard(lock_);</a>
<a name="ln426">    rpc_services_.swap(rpc_services_copy);</a>
<a name="ln427">    UpdateServicesCache(&amp;guard);</a>
<a name="ln428">  }</a>
<a name="ln429"> </a>
<a name="ln430">  for (const auto&amp; p : rpc_services_copy) {</a>
<a name="ln431">    p.second-&gt;StartShutdown();</a>
<a name="ln432">  }</a>
<a name="ln433">  for (const auto&amp; p : rpc_services_copy) {</a>
<a name="ln434">    p.second-&gt;CompleteShutdown();</a>
<a name="ln435">  }</a>
<a name="ln436">  rpc_services_copy.clear();</a>
<a name="ln437">}</a>
<a name="ln438"> </a>
<a name="ln439">// Unregister an RpcService.</a>
<a name="ln440">Status Messenger::UnregisterService(const string&amp; service_name) {</a>
<a name="ln441">  scoped_refptr&lt;RpcService&gt; service;</a>
<a name="ln442">  {</a>
<a name="ln443">    std::lock_guard&lt;percpu_rwlock&gt; guard(lock_);</a>
<a name="ln444">    auto it = rpc_services_.find(service_name);</a>
<a name="ln445">    if (it == rpc_services_.end()) {</a>
<a name="ln446">      return STATUS(ServiceUnavailable, Substitute(&quot;service $0 not registered on $1&quot;,</a>
<a name="ln447">                   service_name, name_));</a>
<a name="ln448">    }</a>
<a name="ln449">    service = it-&gt;second;</a>
<a name="ln450">    rpc_services_.erase(it);</a>
<a name="ln451">    UpdateServicesCache(&amp;guard);</a>
<a name="ln452">  }</a>
<a name="ln453">  service-&gt;StartShutdown();</a>
<a name="ln454">  service-&gt;CompleteShutdown();</a>
<a name="ln455">  return Status::OK();</a>
<a name="ln456">}</a>
<a name="ln457"> </a>
<a name="ln458">class NotifyDisconnectedReactorTask : public ReactorTask {</a>
<a name="ln459"> public:</a>
<a name="ln460">  NotifyDisconnectedReactorTask(OutboundCallPtr call, const SourceLocation&amp; source_location)</a>
<a name="ln461">      : ReactorTask(source_location), call_(std::move(call)) {}</a>
<a name="ln462"> </a>
<a name="ln463">  void Run(Reactor* reactor) override  {</a>
<a name="ln464">    call_-&gt;Transferred(STATUS_FORMAT(</a>
<a name="ln465">        NetworkError, &quot;TEST: Connectivity is broken with $0&quot;,</a>
<a name="ln466">        call_-&gt;conn_id().remote().address()), nullptr);</a>
<a name="ln467">  }</a>
<a name="ln468"> private:</a>
<a name="ln469">  void DoAbort(const Status &amp;abort_status) override {</a>
<a name="ln470">    call_-&gt;Transferred(abort_status, nullptr);</a>
<a name="ln471">  }</a>
<a name="ln472"> </a>
<a name="ln473">  OutboundCallPtr call_;</a>
<a name="ln474">};</a>
<a name="ln475"> </a>
<a name="ln476">void Messenger::QueueOutboundCall(OutboundCallPtr call) {</a>
<a name="ln477">  const auto&amp; remote = call-&gt;conn_id().remote();</a>
<a name="ln478">  Reactor *reactor = RemoteToReactor(remote, call-&gt;conn_id().idx());</a>
<a name="ln479"> </a>
<a name="ln480">  if (TEST_ShouldArtificiallyRejectOutgoingCallsTo(remote.address())) {</a>
<a name="ln481">    VLOG(1) &lt;&lt; &quot;TEST: Rejected connection to &quot; &lt;&lt; remote;</a>
<a name="ln482">    auto scheduled = reactor-&gt;ScheduleReactorTask(std::make_shared&lt;NotifyDisconnectedReactorTask&gt;(</a>
<a name="ln483">        call, SOURCE_LOCATION()));</a>
<a name="ln484">    if (!scheduled) {</a>
<a name="ln485">      call-&gt;Transferred(STATUS(Aborted, &quot;Reactor is closing&quot;), nullptr /* conn */);</a>
<a name="ln486">    }</a>
<a name="ln487">    return;</a>
<a name="ln488">  }</a>
<a name="ln489"> </a>
<a name="ln490">  reactor-&gt;QueueOutboundCall(std::move(call));</a>
<a name="ln491">}</a>
<a name="ln492"> </a>
<a name="ln493">void Messenger::QueueInboundCall(InboundCallPtr call) {</a>
<a name="ln494">  auto service = rpc_service(call-&gt;service_name());</a>
<a name="ln495">  if (PREDICT_FALSE(!service)) {</a>
<a name="ln496">    Status s = STATUS_FORMAT(ServiceUnavailable,</a>
<a name="ln497">                             &quot;Service $0 not registered on $1&quot;,</a>
<a name="ln498">                             call-&gt;service_name(),</a>
<a name="ln499">                             name_);</a>
<a name="ln500">    LOG(WARNING) &lt;&lt; s;</a>
<a name="ln501">    call-&gt;RespondFailure(ErrorStatusPB::ERROR_NO_SUCH_SERVICE, s);</a>
<a name="ln502">    return;</a>
<a name="ln503">  }</a>
<a name="ln504"> </a>
<a name="ln505">  // The RpcService will respond to the client on success or failure.</a>
<a name="ln506">  service-&gt;QueueInboundCall(std::move(call));</a>
<a name="ln507">}</a>
<a name="ln508"> </a>
<a name="ln509">void Messenger::Handle(InboundCallPtr call) {</a>
<a name="ln510">  auto service = rpc_service(call-&gt;service_name());</a>
<a name="ln511">  if (PREDICT_FALSE(!service)) {</a>
<a name="ln512">    Status s = STATUS_FORMAT(ServiceUnavailable,</a>
<a name="ln513">                             &quot;Service $0 not registered on $1&quot;,</a>
<a name="ln514">                             call-&gt;service_name(),</a>
<a name="ln515">                             name_);</a>
<a name="ln516">    LOG(WARNING) &lt;&lt; s;</a>
<a name="ln517">    call-&gt;RespondFailure(ErrorStatusPB::ERROR_NO_SUCH_SERVICE, s);</a>
<a name="ln518">    return;</a>
<a name="ln519">  }</a>
<a name="ln520"> </a>
<a name="ln521">  service-&gt;Handle(std::move(call));</a>
<a name="ln522">}</a>
<a name="ln523"> </a>
<a name="ln524">const std::shared_ptr&lt;MemTracker&gt;&amp; Messenger::parent_mem_tracker() {</a>
<a name="ln525">  return connection_context_factory_-&gt;buffer_tracker();</a>
<a name="ln526">}</a>
<a name="ln527"> </a>
<a name="ln528">void Messenger::RegisterInboundSocket(</a>
<a name="ln529">    const ConnectionContextFactoryPtr&amp; factory, Socket *new_socket, const Endpoint&amp; remote) {</a>
<a name="ln530">  if (TEST_ShouldArtificiallyRejectIncomingCallsFrom(remote.address())) {</a>
<a name="ln531">    auto status = new_socket-&gt;Close();</a>
<a name="ln532">    VLOG(1) &lt;&lt; &quot;TEST: Rejected connection from &quot; &lt;&lt; remote</a>
<a name="ln533">            &lt;&lt; &quot;, close status: &quot; &lt;&lt; status.ToString();</a>
<a name="ln534">    return;</a>
<a name="ln535">  }</a>
<a name="ln536"> </a>
<a name="ln537">  if (FLAGS_socket_receive_buffer_size) {</a>
<a name="ln538">    WARN_NOT_OK(new_socket-&gt;SetReceiveBufferSize(FLAGS_socket_receive_buffer_size),</a>
<a name="ln539">                &quot;Set receive buffer size failed: &quot;);</a>
<a name="ln540">  }</a>
<a name="ln541"> </a>
<a name="ln542">  auto receive_buffer_size = new_socket-&gt;GetReceiveBufferSize();</a>
<a name="ln543">  if (!receive_buffer_size.ok()) {</a>
<a name="ln544">    LOG(WARNING) &lt;&lt; &quot;Register inbound socket failed: &quot; &lt;&lt; receive_buffer_size.status();</a>
<a name="ln545">    return;</a>
<a name="ln546">  }</a>
<a name="ln547"> </a>
<a name="ln548">  int idx = num_connections_accepted_.fetch_add(1) % num_connections_to_server_;</a>
<a name="ln549">  Reactor *reactor = RemoteToReactor(remote, idx);</a>
<a name="ln550">  reactor-&gt;RegisterInboundSocket(</a>
<a name="ln551">      new_socket, remote, factory-&gt;Create(*receive_buffer_size), factory-&gt;buffer_tracker());</a>
<a name="ln552">}</a>
<a name="ln553"> </a>
<a name="ln554">Messenger::Messenger(const MessengerBuilder &amp;bld)</a>
<a name="ln555">    : name_(bld.name_),</a>
<a name="ln556">      connection_context_factory_(bld.connection_context_factory_),</a>
<a name="ln557">      stream_factories_(bld.stream_factories_),</a>
<a name="ln558">      listen_protocol_(bld.listen_protocol_),</a>
<a name="ln559">      metric_entity_(bld.metric_entity_),</a>
<a name="ln560">      io_thread_pool_(name_, FLAGS_io_thread_pool_size),</a>
<a name="ln561">      scheduler_(&amp;io_thread_pool_.io_service()),</a>
<a name="ln562">      normal_thread_pool_(new rpc::ThreadPool(name_, bld.queue_limit_, bld.workers_limit_)),</a>
<a name="ln563">      resolver_(new DnsResolver(&amp;io_thread_pool_.io_service())),</a>
<a name="ln564">      rpc_metrics_(new RpcMetrics(bld.metric_entity_)),</a>
<a name="ln565">      num_connections_to_server_(bld.num_connections_to_server_) {</a>
<a name="ln566">#ifndef NDEBUG</a>
<a name="ln567">  creation_stack_trace_.Collect(/* skip_frames */ 1);</a>
<a name="ln568">#endif</a>
<a name="ln569">  VLOG(1) &lt;&lt; &quot;Messenger constructor for &quot; &lt;&lt; this &lt;&lt; &quot; called at:\n&quot; &lt;&lt; GetStackTrace();</a>
<a name="ln570">  for (int i = 0; i &lt; bld.num_reactors_; i++) {</a>
<a name="ln571">    reactors_.emplace_back(std::make_unique&lt;Reactor&gt;(this, i, bld));</a>
<a name="ln572">  }</a>
<a name="ln573">  // Make sure skip buffer is allocated before we hit memory limit and try to use it.</a>
<a name="ln574">  GetGlobalSkipBuffer();</a>
<a name="ln575">}</a>
<a name="ln576"> </a>
<a name="ln577">Messenger::~Messenger() {</a>
<a name="ln578">  std::lock_guard&lt;percpu_rwlock&gt; guard(lock_);</a>
<a name="ln579">  // This logging and the corresponding logging in the constructor is here to track down the</a>
<a name="ln580">  // occasional CHECK(closing_) failure below in some tests (ENG-2838).</a>
<a name="ln581">  VLOG(1) &lt;&lt; &quot;Messenger destructor for &quot; &lt;&lt; this &lt;&lt; &quot; called at:\n&quot; &lt;&lt; GetStackTrace();</a>
<a name="ln582">#ifndef NDEBUG</a>
<a name="ln583">  if (!closing_) {</a>
<a name="ln584">    LOG(ERROR) &lt;&lt; &quot;Messenger created here:\n&quot; &lt;&lt; creation_stack_trace_.Symbolize()</a>
<a name="ln585">               &lt;&lt; &quot;Messenger destructor for &quot; &lt;&lt; this &lt;&lt; &quot; called at:\n&quot; &lt;&lt; GetStackTrace();</a>
<a name="ln586">  }</a>
<a name="ln587">#endif</a>
<a name="ln588">  CHECK(closing_) &lt;&lt; &quot;Should have already shut down&quot;;</a>
<a name="ln589">  reactors_.clear();</a>
<a name="ln590">}</a>
<a name="ln591"> </a>
<a name="ln592">size_t Messenger::max_concurrent_requests() const {</a>
<a name="ln593">  return num_connections_to_server_;</a>
<a name="ln594">}</a>
<a name="ln595"> </a>
<a name="ln596">Reactor* Messenger::RemoteToReactor(const Endpoint&amp; remote, uint32_t idx) {</a>
<a name="ln597">  uint32_t hashCode = hash_value(remote);</a>
<a name="ln598">  int reactor_idx = (hashCode + idx) % reactors_.size();</a>
<a name="ln599">  // This is just a static partitioning; where each connection</a>
<a name="ln600">  // to a remote is assigned to a particular reactor. We could</a>
<a name="ln601">  // get a lot fancier with assigning Sockaddrs to Reactors,</a>
<a name="ln602">  // but this should be good enough.</a>
<a name="ln603">  return reactors_[reactor_idx].get();</a>
<a name="ln604">}</a>
<a name="ln605"> </a>
<a name="ln606">Status Messenger::Init() {</a>
<a name="ln607">  Status status;</a>
<a name="ln608">  for (const auto&amp; r : reactors_) {</a>
<a name="ln609">    RETURN_NOT_OK(r-&gt;Init());</a>
<a name="ln610">  }</a>
<a name="ln611"> </a>
<a name="ln612">  return Status::OK();</a>
<a name="ln613">}</a>
<a name="ln614"> </a>
<a name="ln615">Status Messenger::DumpRunningRpcs(const DumpRunningRpcsRequestPB&amp; req,</a>
<a name="ln616">                                  DumpRunningRpcsResponsePB* resp) {</a>
<a name="ln617">  shared_lock&lt;rw_spinlock&gt; guard(lock_.get_lock());</a>
<a name="ln618">  for (const auto&amp; reactor : reactors_) {</a>
<a name="ln619">    RETURN_NOT_OK(reactor-&gt;DumpRunningRpcs(req, resp));</a>
<a name="ln620">  }</a>
<a name="ln621">  return Status::OK();</a>
<a name="ln622">}</a>
<a name="ln623"> </a>
<a name="ln624">Status Messenger::QueueEventOnAllReactors(</a>
<a name="ln625">    ServerEventListPtr server_event, const SourceLocation&amp; source_location) {</a>
<a name="ln626">  shared_lock&lt;rw_spinlock&gt; guard(lock_.get_lock());</a>
<a name="ln627">  for (const auto&amp; reactor : reactors_) {</a>
<a name="ln628">    reactor-&gt;QueueEventOnAllConnections(server_event, source_location);</a>
<a name="ln629">  }</a>
<a name="ln630">  return Status::OK();</a>
<a name="ln631">}</a>
<a name="ln632"> </a>
<a name="ln633">void Messenger::RemoveScheduledTask(ScheduledTaskId id) {</a>
<a name="ln634">  CHECK_GT(id, 0);</a>
<a name="ln635">  std::lock_guard&lt;std::mutex&gt; guard(mutex_scheduled_tasks_);</a>
<a name="ln636">  scheduled_tasks_.erase(id);</a>
<a name="ln637">}</a>
<a name="ln638"> </a>
<a name="ln639">void Messenger::AbortOnReactor(ScheduledTaskId task_id) {</a>
<a name="ln640">  DCHECK(!reactors_.empty());</a>
<a name="ln641">  CHECK_GT(task_id, 0);</a>
<a name="ln642"> </a>
<a name="ln643">  std::shared_ptr&lt;DelayedTask&gt; task;</a>
<a name="ln644">  {</a>
<a name="ln645">    std::lock_guard&lt;std::mutex&gt; guard(mutex_scheduled_tasks_);</a>
<a name="ln646">    auto iter = scheduled_tasks_.find(task_id);</a>
<a name="ln647">    if (iter != scheduled_tasks_.end()) {</a>
<a name="ln648">      task = iter-&gt;second;</a>
<a name="ln649">      scheduled_tasks_.erase(iter);</a>
<a name="ln650">    }</a>
<a name="ln651">  }</a>
<a name="ln652">  if (task) {</a>
<a name="ln653">    task-&gt;AbortTask(STATUS(Aborted, &quot;Task aborted by messenger&quot;));</a>
<a name="ln654">  }</a>
<a name="ln655">}</a>
<a name="ln656"> </a>
<a name="ln657">ScheduledTaskId Messenger::ScheduleOnReactor(</a>
<a name="ln658">    StatusFunctor func, MonoDelta when, const SourceLocation&amp; source_location, Messenger* msgr) {</a>
<a name="ln659">  DCHECK(!reactors_.empty());</a>
<a name="ln660"> </a>
<a name="ln661">  // If we're already running on a reactor thread, reuse it.</a>
<a name="ln662">  Reactor* chosen = nullptr;</a>
<a name="ln663">  for (const auto&amp; r : reactors_) {</a>
<a name="ln664">    if (r-&gt;IsCurrentThread()) {</a>
<a name="ln665">      chosen = r.get();</a>
<a name="ln666">    }</a>
<a name="ln667">  }</a>
<a name="ln668">  if (chosen == nullptr) {</a>
<a name="ln669">    // Not running on a reactor thread, pick one at random.</a>
<a name="ln670">    chosen = reactors_[rand() % reactors_.size()].get();</a>
<a name="ln671">  }</a>
<a name="ln672"> </a>
<a name="ln673">  ScheduledTaskId task_id = 0;</a>
<a name="ln674">  if (msgr != nullptr) {</a>
<a name="ln675">    task_id = next_task_id_.fetch_add(1);</a>
<a name="ln676">  }</a>
<a name="ln677">  auto task = std::make_shared&lt;DelayedTask&gt;(</a>
<a name="ln678">      std::move(func), when, task_id, source_location, msgr);</a>
<a name="ln679">  if (msgr != nullptr) {</a>
<a name="ln680">    std::lock_guard&lt;std::mutex&gt; guard(mutex_scheduled_tasks_);</a>
<a name="ln681">    scheduled_tasks_.emplace(task_id, task);</a>
<a name="ln682">  }</a>
<a name="ln683"> </a>
<a name="ln684">  if (chosen-&gt;ScheduleReactorTask(task)) {</a>
<a name="ln685">    return task_id;</a>
<a name="ln686">  }</a>
<a name="ln687"> </a>
<a name="ln688">  {</a>
<a name="ln689">    std::lock_guard&lt;std::mutex&gt; guard(mutex_scheduled_tasks_);</a>
<a name="ln690">    scheduled_tasks_.erase(task_id);</a>
<a name="ln691">  }</a>
<a name="ln692"> </a>
<a name="ln693">  return kInvalidTaskId;</a>
<a name="ln694">}</a>
<a name="ln695"> </a>
<a name="ln696">void Messenger::UpdateServicesCache(std::lock_guard&lt;percpu_rwlock&gt;* guard) {</a>
<a name="ln697">  DCHECK_ONLY_NOTNULL(guard);</a>
<a name="ln698"> </a>
<a name="ln699">  rpc_services_cache_.Set(rpc_services_);</a>
<a name="ln700">}</a>
<a name="ln701"> </a>
<a name="ln702">scoped_refptr&lt;RpcService&gt; Messenger::rpc_service(const string&amp; service_name) const {</a>
<a name="ln703">  auto cache = rpc_services_cache_.get();</a>
<a name="ln704">  auto it = cache-&gt;find(service_name);</a>
<a name="ln705">  if (it != cache-&gt;end()) {</a>
<a name="ln706">    // Since our cache is a cache of whole rpc_services_ map, we could check only it.</a>
<a name="ln707">    return it-&gt;second;</a>
<a name="ln708">  }</a>
<a name="ln709">  return scoped_refptr&lt;RpcService&gt;();</a>
<a name="ln710">}</a>
<a name="ln711"> </a>
<a name="ln712">} // namespace rpc</a>
<a name="ln713">} // namespace yb</a>

</code></pre>
<div class="balloon" rel="158"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="191"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="194"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="223"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="403"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="481"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="532"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="569"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="581"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="588"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="640"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="659"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
