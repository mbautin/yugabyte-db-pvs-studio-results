
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>options_helper.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//  Copyright (c) 2011-present, Facebook, Inc.  All rights reserved.</a>
<a name="ln2">//  This source code is licensed under the BSD-style license found in the</a>
<a name="ln3">//  LICENSE file in the root directory of this source tree. An additional grant</a>
<a name="ln4">//  of patent rights can be found in the PATENTS file in the same directory.</a>
<a name="ln5">//</a>
<a name="ln6">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln7">//</a>
<a name="ln8">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln9">//</a>
<a name="ln10">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln11">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln12">//</a>
<a name="ln13">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln14">//</a>
<a name="ln15">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln16">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln17">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln18">// under the License.</a>
<a name="ln19">//</a>
<a name="ln20">#include &quot;yb/rocksdb/util/options_helper.h&quot;</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;cassert&gt;</a>
<a name="ln23">#include &lt;cctype&gt;</a>
<a name="ln24">#include &lt;cstdlib&gt;</a>
<a name="ln25">#include &lt;unordered_set&gt;</a>
<a name="ln26">#include &lt;vector&gt;</a>
<a name="ln27">#include &quot;yb/rocksdb/cache.h&quot;</a>
<a name="ln28">#include &quot;yb/rocksdb/compaction_filter.h&quot;</a>
<a name="ln29">#include &quot;yb/rocksdb/convenience.h&quot;</a>
<a name="ln30">#include &quot;yb/rocksdb/filter_policy.h&quot;</a>
<a name="ln31">#include &quot;yb/rocksdb/memtablerep.h&quot;</a>
<a name="ln32">#include &quot;yb/rocksdb/merge_operator.h&quot;</a>
<a name="ln33">#include &quot;yb/rocksdb/options.h&quot;</a>
<a name="ln34">#include &quot;yb/rocksdb/rate_limiter.h&quot;</a>
<a name="ln35">#include &quot;yb/rocksdb/slice_transform.h&quot;</a>
<a name="ln36">#include &quot;yb/rocksdb/table.h&quot;</a>
<a name="ln37">#include &quot;yb/rocksdb/table/block_based_table_factory.h&quot;</a>
<a name="ln38">#include &quot;yb/rocksdb/table/plain_table_factory.h&quot;</a>
<a name="ln39">#include &quot;yb/rocksdb/util/logging.h&quot;</a>
<a name="ln40">#include &quot;yb/util/string_util.h&quot;</a>
<a name="ln41"> </a>
<a name="ln42">namespace rocksdb {</a>
<a name="ln43"> </a>
<a name="ln44">#ifndef ROCKSDB_LITE</a>
<a name="ln45">bool isSpecialChar(const char c) {</a>
<a name="ln46">  if (c == '\\' || c == '#' || c == ':' || c == '\r' || c == '\n') {</a>
<a name="ln47">    return true;</a>
<a name="ln48">  }</a>
<a name="ln49">  return false;</a>
<a name="ln50">}</a>
<a name="ln51"> </a>
<a name="ln52">char UnescapeChar(const char c) {</a>
<a name="ln53">  static const std::unordered_map&lt;char, char&gt; convert_map = {{'r', '\r'},</a>
<a name="ln54">                                                             {'n', '\n'}};</a>
<a name="ln55"> </a>
<a name="ln56">  auto iter = convert_map.find(c);</a>
<a name="ln57">  if (iter == convert_map.end()) {</a>
<a name="ln58">    return c;</a>
<a name="ln59">  }</a>
<a name="ln60">  return iter-&gt;second;</a>
<a name="ln61">}</a>
<a name="ln62"> </a>
<a name="ln63">char EscapeChar(const char c) {</a>
<a name="ln64">  static const std::unordered_map&lt;char, char&gt; convert_map = {{'\n', 'n'},</a>
<a name="ln65">                                                             {'\r', 'r'}};</a>
<a name="ln66"> </a>
<a name="ln67">  auto iter = convert_map.find(c);</a>
<a name="ln68">  if (iter == convert_map.end()) {</a>
<a name="ln69">    return c;</a>
<a name="ln70">  }</a>
<a name="ln71">  return iter-&gt;second;</a>
<a name="ln72">}</a>
<a name="ln73"> </a>
<a name="ln74">std::string EscapeOptionString(const std::string&amp; raw_string) {</a>
<a name="ln75">  std::string output;</a>
<a name="ln76">  for (auto c : raw_string) {</a>
<a name="ln77">    if (isSpecialChar(c)) {</a>
<a name="ln78">      output += '\\';</a>
<a name="ln79">      output += EscapeChar(c);</a>
<a name="ln80">    } else {</a>
<a name="ln81">      output += c;</a>
<a name="ln82">    }</a>
<a name="ln83">  }</a>
<a name="ln84"> </a>
<a name="ln85">  return output;</a>
<a name="ln86">}</a>
<a name="ln87"> </a>
<a name="ln88">std::string UnescapeOptionString(const std::string&amp; escaped_string) {</a>
<a name="ln89">  bool escaped = false;</a>
<a name="ln90">  std::string output;</a>
<a name="ln91"> </a>
<a name="ln92">  for (auto c : escaped_string) {</a>
<a name="ln93">    if (escaped) {</a>
<a name="ln94">      output += UnescapeChar(c);</a>
<a name="ln95">      escaped = false;</a>
<a name="ln96">    } else {</a>
<a name="ln97">      if (c == '\\') {</a>
<a name="ln98">        escaped = true;</a>
<a name="ln99">        continue;</a>
<a name="ln100">      }</a>
<a name="ln101">      output += c;</a>
<a name="ln102">    }</a>
<a name="ln103">  }</a>
<a name="ln104">  return output;</a>
<a name="ln105">}</a>
<a name="ln106"> </a>
<a name="ln107">namespace {</a>
<a name="ln108">std::string trim(const std::string&amp; str) {</a>
<a name="ln109">  if (str.empty()) return std::string();</a>
<a name="ln110">  size_t start = 0;</a>
<a name="ln111">  size_t end = str.size() - 1;</a>
<a name="ln112">  while (isspace(str[start]) != 0 &amp;&amp; start &lt;= end) {</a>
<a name="ln113">    ++start;</a>
<a name="ln114">  }</a>
<a name="ln115">  while (isspace(str[end]) != 0 &amp;&amp; start &lt;= end) {</a>
<a name="ln116">    --end;</a>
<a name="ln117">  }</a>
<a name="ln118">  if (start &lt;= end) {</a>
<a name="ln119">    return str.substr(start, end - start + 1);</a>
<a name="ln120">  }</a>
<a name="ln121">  return std::string();</a>
<a name="ln122">}</a>
<a name="ln123"> </a>
<a name="ln124">template &lt;typename T&gt;</a>
<a name="ln125">bool ParseEnum(const std::unordered_map&lt;std::string, T&gt;&amp; type_map,</a>
<a name="ln126">               const std::string&amp; type, T* value) {</a>
<a name="ln127">  auto iter = type_map.find(type);</a>
<a name="ln128">  if (iter != type_map.end()) {</a>
<a name="ln129">    *value = iter-&gt;second;</a>
<a name="ln130">    return true;</a>
<a name="ln131">  }</a>
<a name="ln132">  return false;</a>
<a name="ln133">}</a>
<a name="ln134"> </a>
<a name="ln135">template &lt;typename T&gt;</a>
<a name="ln136">bool SerializeEnum(const std::unordered_map&lt;std::string, T&gt;&amp; type_map,</a>
<a name="ln137">                   const T&amp; type, std::string* value) {</a>
<a name="ln138">  for (const auto&amp; pair : type_map) {</a>
<a name="ln139">    if (pair.second == type) {</a>
<a name="ln140">      *value = pair.first;</a>
<a name="ln141">      return true;</a>
<a name="ln142">    }</a>
<a name="ln143">  }</a>
<a name="ln144">  return false;</a>
<a name="ln145">}</a>
<a name="ln146"> </a>
<a name="ln147">bool SerializeVectorCompressionType(const std::vector&lt;CompressionType&gt;&amp; types,</a>
<a name="ln148">                                    std::string* value) {</a>
<a name="ln149">  std::stringstream ss;</a>
<a name="ln150">  bool result;</a>
<a name="ln151">  for (size_t i = 0; i &lt; types.size(); ++i) {</a>
<a name="ln152">    if (i &gt; 0) {</a>
<a name="ln153">      ss &lt;&lt; ':';</a>
<a name="ln154">    }</a>
<a name="ln155">    std::string string_type;</a>
<a name="ln156">    result = SerializeEnum&lt;CompressionType&gt;(compression_type_string_map,</a>
<a name="ln157">                                            types[i], &amp;string_type);</a>
<a name="ln158">    if (result == false) {</a>
<a name="ln159">      return result;</a>
<a name="ln160">    }</a>
<a name="ln161">    ss &lt;&lt; string_type;</a>
<a name="ln162">  }</a>
<a name="ln163">  *value = ss.str();</a>
<a name="ln164">  return true;</a>
<a name="ln165">}</a>
<a name="ln166"> </a>
<a name="ln167">bool ParseBoolean(const std::string&amp; type, const std::string&amp; value) {</a>
<a name="ln168">  if (value == &quot;true&quot; || value == &quot;1&quot;) {</a>
<a name="ln169">    return true;</a>
<a name="ln170">  } else if (value == &quot;false&quot; || value == &quot;0&quot;) {</a>
<a name="ln171">    return false;</a>
<a name="ln172">  }</a>
<a name="ln173">  throw std::invalid_argument(type);</a>
<a name="ln174">}</a>
<a name="ln175"> </a>
<a name="ln176">uint64_t ParseUint64(const std::string&amp; value) {</a>
<a name="ln177">  size_t endchar;</a>
<a name="ln178">#ifndef CYGWIN</a>
<a name="ln179">  uint64_t num = std::stoull(value.c_str(), &amp;endchar);</a>
<a name="ln180">#else</a>
<a name="ln181">  char* endptr;</a>
<a name="ln182">  uint64_t num = std::strtoul(value.c_str(), &amp;endptr, 0);</a>
<a name="ln183">  endchar = endptr - value.c_str();</a>
<a name="ln184">#endif</a>
<a name="ln185"> </a>
<a name="ln186">  if (endchar &lt; value.length()) {</a>
<a name="ln187">    char c = value[endchar];</a>
<a name="ln188">    if (c == 'k' || c == 'K')</a>
<a name="ln189">      num &lt;&lt;= 10LL;</a>
<a name="ln190">    else if (c == 'm' || c == 'M')</a>
<a name="ln191">      num &lt;&lt;= 20LL;</a>
<a name="ln192">    else if (c == 'g' || c == 'G')</a>
<a name="ln193">      num &lt;&lt;= 30LL;</a>
<a name="ln194">    else if (c == 't' || c == 'T')</a>
<a name="ln195">      num &lt;&lt;= 40LL;</a>
<a name="ln196">  }</a>
<a name="ln197"> </a>
<a name="ln198">  return num;</a>
<a name="ln199">}</a>
<a name="ln200"> </a>
<a name="ln201">size_t ParseSizeT(const std::string&amp; value) {</a>
<a name="ln202">  return static_cast&lt;size_t&gt;(ParseUint64(value));</a>
<a name="ln203">}</a>
<a name="ln204"> </a>
<a name="ln205">uint32_t ParseUint32(const std::string&amp; value) {</a>
<a name="ln206">  uint64_t num = ParseUint64(value);</a>
<a name="ln207">  if ((num &gt;&gt; 32LL) == 0) {</a>
<a name="ln208">    return static_cast&lt;uint32_t&gt;(num);</a>
<a name="ln209">  } else {</a>
<a name="ln210">    throw std::out_of_range(value);</a>
<a name="ln211">  }</a>
<a name="ln212">}</a>
<a name="ln213"> </a>
<a name="ln214">int ParseInt(const std::string&amp; value) {</a>
<a name="ln215">  size_t endchar;</a>
<a name="ln216">#ifndef CYGWIN</a>
<a name="ln217">  int num = std::stoi(value.c_str(), &amp;endchar);</a>
<a name="ln218">#else</a>
<a name="ln219">  char* endptr;</a>
<a name="ln220">  int num = std::strtoul(value.c_str(), &amp;endptr, 0);</a>
<a name="ln221">  endchar = endptr - value.c_str();</a>
<a name="ln222">#endif</a>
<a name="ln223"> </a>
<a name="ln224">  if (endchar &lt; value.length()) {</a>
<a name="ln225">    char c = value[endchar];</a>
<a name="ln226">    if (c == 'k' || c == 'K')</a>
<a name="ln227">      num *= (1 &lt;&lt; 10);</a>
<a name="ln228">    else if (c == 'm' || c == 'M')</a>
<a name="ln229">      num *= (1 &lt;&lt; 20);</a>
<a name="ln230">    else if (c == 'g' || c == 'G')</a>
<a name="ln231">      num *= (1 &lt;&lt; 30);</a>
<a name="ln232">  }</a>
<a name="ln233"> </a>
<a name="ln234">  return num;</a>
<a name="ln235">}</a>
<a name="ln236"> </a>
<a name="ln237">double ParseDouble(const std::string&amp; value) {</a>
<a name="ln238">#ifndef CYGWIN</a>
<a name="ln239">  return std::stod(value);</a>
<a name="ln240">#else</a>
<a name="ln241">  return std::strtod(value.c_str(), 0);</a>
<a name="ln242">#endif</a>
<a name="ln243">}</a>
<a name="ln244"> </a>
<a name="ln245">bool ParseVectorCompressionType(</a>
<a name="ln246">    const std::string&amp; value,</a>
<a name="ln247">    std::vector&lt;CompressionType&gt;* compression_per_level) {</a>
<a name="ln248">  compression_per_level-&gt;clear();</a>
<a name="ln249">  size_t start = 0;</a>
<a name="ln250">  while (start &lt; value.size()) {</a>
<a name="ln251">    size_t end = value.find(':', start);</a>
<a name="ln252">    bool is_ok;</a>
<a name="ln253">    CompressionType type;</a>
<a name="ln254">    if (end == std::string::npos) {</a>
<a name="ln255">      is_ok = ParseEnum&lt;CompressionType&gt;(compression_type_string_map,</a>
<a name="ln256">                                         value.substr(start), &amp;type);</a>
<a name="ln257">      if (!is_ok) {</a>
<a name="ln258">        return false;</a>
<a name="ln259">      }</a>
<a name="ln260">      compression_per_level-&gt;emplace_back(type);</a>
<a name="ln261">      break;</a>
<a name="ln262">    } else {</a>
<a name="ln263">      is_ok = ParseEnum&lt;CompressionType&gt;(</a>
<a name="ln264">          compression_type_string_map, value.substr(start, end - start), &amp;type);</a>
<a name="ln265">      if (!is_ok) {</a>
<a name="ln266">        return false;</a>
<a name="ln267">      }</a>
<a name="ln268">      compression_per_level-&gt;emplace_back(type);</a>
<a name="ln269">      start = end + 1;</a>
<a name="ln270">    }</a>
<a name="ln271">  }</a>
<a name="ln272">  return true;</a>
<a name="ln273">}</a>
<a name="ln274"> </a>
<a name="ln275">bool ParseSliceTransformHelper(</a>
<a name="ln276">    const std::string&amp; kFixedPrefixName, const std::string&amp; kCappedPrefixName,</a>
<a name="ln277">    const std::string&amp; value,</a>
<a name="ln278">    std::shared_ptr&lt;const SliceTransform&gt;* slice_transform) {</a>
<a name="ln279">  static const std::string kNullptrString = &quot;nullptr&quot;;</a>
<a name="ln280">  auto&amp; pe_value = value;</a>
<a name="ln281">  if (pe_value.size() &gt; kFixedPrefixName.size() &amp;&amp;</a>
<a name="ln282">      pe_value.compare(0, kFixedPrefixName.size(), kFixedPrefixName) == 0) {</a>
<a name="ln283">    int prefix_length = ParseInt(trim(value.substr(kFixedPrefixName.size())));</a>
<a name="ln284">    slice_transform-&gt;reset(NewFixedPrefixTransform(prefix_length));</a>
<a name="ln285">  } else if (pe_value.size() &gt; kCappedPrefixName.size() &amp;&amp;</a>
<a name="ln286">             pe_value.compare(0, kCappedPrefixName.size(), kCappedPrefixName) ==</a>
<a name="ln287">                 0) {</a>
<a name="ln288">    int prefix_length =</a>
<a name="ln289">        ParseInt(trim(pe_value.substr(kCappedPrefixName.size())));</a>
<a name="ln290">    slice_transform-&gt;reset(NewCappedPrefixTransform(prefix_length));</a>
<a name="ln291">  } else if (value == kNullptrString) {</a>
<a name="ln292">    slice_transform-&gt;reset();</a>
<a name="ln293">  } else {</a>
<a name="ln294">    return false;</a>
<a name="ln295">  }</a>
<a name="ln296"> </a>
<a name="ln297">  return true;</a>
<a name="ln298">}</a>
<a name="ln299"> </a>
<a name="ln300">bool ParseSliceTransform(</a>
<a name="ln301">    const std::string&amp; value,</a>
<a name="ln302">    std::shared_ptr&lt;const SliceTransform&gt;* slice_transform) {</a>
<a name="ln303">  // While we normally don't convert the string representation of a</a>
<a name="ln304">  // pointer-typed option into its instance, here we do so for backward</a>
<a name="ln305">  // compatibility as we allow this action in SetOption().</a>
<a name="ln306"> </a>
<a name="ln307">  // TODO(yhchiang): A possible better place for these serialization /</a>
<a name="ln308">  // deserialization is inside the class definition of pointer-typed</a>
<a name="ln309">  // option itself, but this requires a bigger change of public API.</a>
<a name="ln310">  bool result =</a>
<a name="ln311">      ParseSliceTransformHelper(&quot;fixed:&quot;, &quot;capped:&quot;, value, slice_transform);</a>
<a name="ln312">  if (result) {</a>
<a name="ln313">    return result;</a>
<a name="ln314">  }</a>
<a name="ln315">  result = ParseSliceTransformHelper(</a>
<a name="ln316">      &quot;rocksdb.FixedPrefix.&quot;, &quot;rocksdb.CappedPrefix.&quot;, value, slice_transform);</a>
<a name="ln317">  if (result) {</a>
<a name="ln318">    return result;</a>
<a name="ln319">  }</a>
<a name="ln320">  // TODO(yhchiang): we can further support other default</a>
<a name="ln321">  //                 SliceTransforms here.</a>
<a name="ln322">  return false;</a>
<a name="ln323">}</a>
<a name="ln324"> </a>
<a name="ln325">bool ParseOptionHelper(char* opt_address, const OptionType&amp; opt_type,</a>
<a name="ln326">                       const std::string&amp; value) {</a>
<a name="ln327">  switch (opt_type) {</a>
<a name="ln328">    case OptionType::kBoolean:</a>
<a name="ln329">      *reinterpret_cast&lt;bool*&gt;(opt_address) = ParseBoolean(&quot;&quot;, value);</a>
<a name="ln330">      break;</a>
<a name="ln331">    case OptionType::kInt:</a>
<a name="ln332">      *reinterpret_cast&lt;int*&gt;(opt_address) = ParseInt(value);</a>
<a name="ln333">      break;</a>
<a name="ln334">    case OptionType::kUInt:</a>
<a name="ln335">      *reinterpret_cast&lt;unsigned int*&gt;(opt_address) = ParseUint32(value);</a>
<a name="ln336">      break;</a>
<a name="ln337">    case OptionType::kUInt32T:</a>
<a name="ln338">      *reinterpret_cast&lt;uint32_t*&gt;(opt_address) = ParseUint32(value);</a>
<a name="ln339">      break;</a>
<a name="ln340">    case OptionType::kUInt64T:</a>
<a name="ln341">      *reinterpret_cast&lt;uint64_t*&gt;(opt_address) = ParseUint64(value);</a>
<a name="ln342">      break;</a>
<a name="ln343">    case OptionType::kSizeT:</a>
<a name="ln344">      *reinterpret_cast&lt;size_t*&gt;(opt_address) = ParseSizeT(value);</a>
<a name="ln345">      break;</a>
<a name="ln346">    case OptionType::kString:</a>
<a name="ln347">      *reinterpret_cast&lt;std::string*&gt;(opt_address) = value;</a>
<a name="ln348">      break;</a>
<a name="ln349">    case OptionType::kDouble:</a>
<a name="ln350">      *reinterpret_cast&lt;double*&gt;(opt_address) = ParseDouble(value);</a>
<a name="ln351">      break;</a>
<a name="ln352">    case OptionType::kCompactionStyle:</a>
<a name="ln353">      return ParseEnum&lt;CompactionStyle&gt;(</a>
<a name="ln354">          compaction_style_string_map, value,</a>
<a name="ln355">          reinterpret_cast&lt;CompactionStyle*&gt;(opt_address));</a>
<a name="ln356">    case OptionType::kCompressionType:</a>
<a name="ln357">      return ParseEnum&lt;CompressionType&gt;(</a>
<a name="ln358">          compression_type_string_map, value,</a>
<a name="ln359">          reinterpret_cast&lt;CompressionType*&gt;(opt_address));</a>
<a name="ln360">    case OptionType::kVectorCompressionType:</a>
<a name="ln361">      return ParseVectorCompressionType(</a>
<a name="ln362">          value, reinterpret_cast&lt;std::vector&lt;CompressionType&gt;*&gt;(opt_address));</a>
<a name="ln363">    case OptionType::kSliceTransform:</a>
<a name="ln364">      return ParseSliceTransform(</a>
<a name="ln365">          value, reinterpret_cast&lt;std::shared_ptr&lt;const SliceTransform&gt;*&gt;(</a>
<a name="ln366">                     opt_address));</a>
<a name="ln367">    case OptionType::kChecksumType:</a>
<a name="ln368">      return ParseEnum&lt;ChecksumType&gt;(</a>
<a name="ln369">          checksum_type_string_map, value,</a>
<a name="ln370">          reinterpret_cast&lt;ChecksumType*&gt;(opt_address));</a>
<a name="ln371">    case OptionType::kBlockBasedTableIndexType:</a>
<a name="ln372">      return ParseEnum&lt;IndexType&gt;(</a>
<a name="ln373">          block_base_table_index_type_string_map, value,</a>
<a name="ln374">          reinterpret_cast&lt;IndexType*&gt;(opt_address));</a>
<a name="ln375">    case OptionType::kEncodingType:</a>
<a name="ln376">      return ParseEnum&lt;EncodingType&gt;(</a>
<a name="ln377">          encoding_type_string_map, value,</a>
<a name="ln378">          reinterpret_cast&lt;EncodingType*&gt;(opt_address));</a>
<a name="ln379">    case OptionType::kWALRecoveryMode:</a>
<a name="ln380">      return ParseEnum&lt;WALRecoveryMode&gt;(</a>
<a name="ln381">          wal_recovery_mode_string_map, value,</a>
<a name="ln382">          reinterpret_cast&lt;WALRecoveryMode*&gt;(opt_address));</a>
<a name="ln383">    case OptionType::kAccessHint:</a>
<a name="ln384">      return ParseEnum&lt;DBOptions::AccessHint&gt;(</a>
<a name="ln385">          access_hint_string_map, value,</a>
<a name="ln386">          reinterpret_cast&lt;DBOptions::AccessHint*&gt;(opt_address));</a>
<a name="ln387">    case OptionType::kInfoLogLevel:</a>
<a name="ln388">      return ParseEnum&lt;InfoLogLevel&gt;(</a>
<a name="ln389">          info_log_level_string_map, value,</a>
<a name="ln390">          reinterpret_cast&lt;InfoLogLevel*&gt;(opt_address));</a>
<a name="ln391">    default:</a>
<a name="ln392">      return false;</a>
<a name="ln393">  }</a>
<a name="ln394">  return true;</a>
<a name="ln395">}</a>
<a name="ln396"> </a>
<a name="ln397">}  // anonymouse namespace</a>
<a name="ln398"> </a>
<a name="ln399">bool SerializeSingleOptionHelper(const char* opt_address,</a>
<a name="ln400">                                 const OptionType opt_type,</a>
<a name="ln401">                                 std::string* value) {</a>
<a name="ln402">  static const std::string kNullptrString = &quot;nullptr&quot;;</a>
<a name="ln403">  assert(value);</a>
<a name="ln404">  switch (opt_type) {</a>
<a name="ln405">    case OptionType::kBoolean:</a>
<a name="ln406">      *value = *(reinterpret_cast&lt;const bool*&gt;(opt_address)) ? &quot;true&quot; : &quot;false&quot;;</a>
<a name="ln407">      break;</a>
<a name="ln408">    case OptionType::kInt:</a>
<a name="ln409">      *value = ToString(*(reinterpret_cast&lt;const int*&gt;(opt_address)));</a>
<a name="ln410">      break;</a>
<a name="ln411">    case OptionType::kUInt:</a>
<a name="ln412">      *value = ToString(*(reinterpret_cast&lt;const unsigned int*&gt;(opt_address)));</a>
<a name="ln413">      break;</a>
<a name="ln414">    case OptionType::kUInt32T:</a>
<a name="ln415">      *value = ToString(*(reinterpret_cast&lt;const uint32_t*&gt;(opt_address)));</a>
<a name="ln416">      break;</a>
<a name="ln417">    case OptionType::kUInt64T:</a>
<a name="ln418">      *value = ToString(*(reinterpret_cast&lt;const uint64_t*&gt;(opt_address)));</a>
<a name="ln419">      break;</a>
<a name="ln420">    case OptionType::kSizeT:</a>
<a name="ln421">      *value = ToString(*(reinterpret_cast&lt;const size_t*&gt;(opt_address)));</a>
<a name="ln422">      break;</a>
<a name="ln423">    case OptionType::kDouble:</a>
<a name="ln424">      *value = ToString(*(reinterpret_cast&lt;const double*&gt;(opt_address)));</a>
<a name="ln425">      break;</a>
<a name="ln426">    case OptionType::kString:</a>
<a name="ln427">      *value = EscapeOptionString(</a>
<a name="ln428">          *(reinterpret_cast&lt;const std::string*&gt;(opt_address)));</a>
<a name="ln429">      break;</a>
<a name="ln430">    case OptionType::kCompactionStyle:</a>
<a name="ln431">      return SerializeEnum&lt;CompactionStyle&gt;(</a>
<a name="ln432">          compaction_style_string_map,</a>
<a name="ln433">          *(reinterpret_cast&lt;const CompactionStyle*&gt;(opt_address)), value);</a>
<a name="ln434">    case OptionType::kCompressionType:</a>
<a name="ln435">      return SerializeEnum&lt;CompressionType&gt;(</a>
<a name="ln436">          compression_type_string_map,</a>
<a name="ln437">          *(reinterpret_cast&lt;const CompressionType*&gt;(opt_address)), value);</a>
<a name="ln438">    case OptionType::kVectorCompressionType:</a>
<a name="ln439">      return SerializeVectorCompressionType(</a>
<a name="ln440">          *(reinterpret_cast&lt;const std::vector&lt;CompressionType&gt;*&gt;(opt_address)),</a>
<a name="ln441">          value);</a>
<a name="ln442">      break;</a>
<a name="ln443">    case OptionType::kSliceTransform: {</a>
<a name="ln444">      const auto* slice_transform_ptr =</a>
<a name="ln445">          reinterpret_cast&lt;const std::shared_ptr&lt;const SliceTransform&gt;*&gt;(</a>
<a name="ln446">              opt_address);</a>
<a name="ln447">      *value = slice_transform_ptr-&gt;get() ? slice_transform_ptr-&gt;get()-&gt;Name()</a>
<a name="ln448">                                          : kNullptrString;</a>
<a name="ln449">      break;</a>
<a name="ln450">    }</a>
<a name="ln451">    case OptionType::kTableFactory: {</a>
<a name="ln452">      const auto* table_factory_ptr =</a>
<a name="ln453">          reinterpret_cast&lt;const std::shared_ptr&lt;const TableFactory&gt;*&gt;(</a>
<a name="ln454">              opt_address);</a>
<a name="ln455">      *value = table_factory_ptr-&gt;get() ? table_factory_ptr-&gt;get()-&gt;Name()</a>
<a name="ln456">                                        : kNullptrString;</a>
<a name="ln457">      break;</a>
<a name="ln458">    }</a>
<a name="ln459">    case OptionType::kComparator: {</a>
<a name="ln460">      // it's a const pointer of const Comparator*</a>
<a name="ln461">      const auto* ptr = reinterpret_cast&lt;const Comparator* const*&gt;(opt_address);</a>
<a name="ln462">      // Since the user-specified comparator will be wrapped by</a>
<a name="ln463">      // InternalKeyComparator, we should persist the user-specified one</a>
<a name="ln464">      // instead of InternalKeyComparator.</a>
<a name="ln465">      const auto* internal_comparator =</a>
<a name="ln466">          dynamic_cast&lt;const InternalKeyComparator*&gt;(*ptr);</a>
<a name="ln467">      if (internal_comparator != nullptr) {</a>
<a name="ln468">        *value = internal_comparator-&gt;user_comparator()-&gt;Name();</a>
<a name="ln469">      } else {</a>
<a name="ln470">        *value = *ptr ? (*ptr)-&gt;Name() : kNullptrString;</a>
<a name="ln471">      }</a>
<a name="ln472">      break;</a>
<a name="ln473">    }</a>
<a name="ln474">    case OptionType::kCompactionFilter: {</a>
<a name="ln475">      // it's a const pointer of const CompactionFilter*</a>
<a name="ln476">      const auto* ptr =</a>
<a name="ln477">          reinterpret_cast&lt;const CompactionFilter* const*&gt;(opt_address);</a>
<a name="ln478">      *value = *ptr ? (*ptr)-&gt;Name() : kNullptrString;</a>
<a name="ln479">      break;</a>
<a name="ln480">    }</a>
<a name="ln481">    case OptionType::kCompactionFilterFactory: {</a>
<a name="ln482">      const auto* ptr =</a>
<a name="ln483">          reinterpret_cast&lt;const std::shared_ptr&lt;CompactionFilterFactory&gt;*&gt;(</a>
<a name="ln484">              opt_address);</a>
<a name="ln485">      *value = ptr-&gt;get() ? ptr-&gt;get()-&gt;Name() : kNullptrString;</a>
<a name="ln486">      break;</a>
<a name="ln487">    }</a>
<a name="ln488">    case OptionType::kMemTableRepFactory: {</a>
<a name="ln489">      const auto* ptr =</a>
<a name="ln490">          reinterpret_cast&lt;const std::shared_ptr&lt;MemTableRepFactory&gt;*&gt;(</a>
<a name="ln491">              opt_address);</a>
<a name="ln492">      *value = ptr-&gt;get() ? ptr-&gt;get()-&gt;Name() : kNullptrString;</a>
<a name="ln493">      break;</a>
<a name="ln494">    }</a>
<a name="ln495">    case OptionType::kMergeOperator: {</a>
<a name="ln496">      const auto* ptr =</a>
<a name="ln497">          reinterpret_cast&lt;const std::shared_ptr&lt;MergeOperator&gt;*&gt;(opt_address);</a>
<a name="ln498">      *value = ptr-&gt;get() ? ptr-&gt;get()-&gt;Name() : kNullptrString;</a>
<a name="ln499">      break;</a>
<a name="ln500">    }</a>
<a name="ln501">    case OptionType::kFilterPolicy: {</a>
<a name="ln502">      const auto* ptr =</a>
<a name="ln503">          reinterpret_cast&lt;const std::shared_ptr&lt;FilterPolicy&gt;*&gt;(opt_address);</a>
<a name="ln504">      *value = ptr-&gt;get() ? ptr-&gt;get()-&gt;Name() : kNullptrString;</a>
<a name="ln505">      break;</a>
<a name="ln506">    }</a>
<a name="ln507">    case OptionType::kChecksumType:</a>
<a name="ln508">      return SerializeEnum&lt;ChecksumType&gt;(</a>
<a name="ln509">          checksum_type_string_map,</a>
<a name="ln510">          *reinterpret_cast&lt;const ChecksumType*&gt;(opt_address), value);</a>
<a name="ln511">    case OptionType::kBlockBasedTableIndexType:</a>
<a name="ln512">      return SerializeEnum&lt;IndexType&gt;(</a>
<a name="ln513">          block_base_table_index_type_string_map,</a>
<a name="ln514">          *reinterpret_cast&lt;const IndexType*&gt;(opt_address),</a>
<a name="ln515">          value);</a>
<a name="ln516">    case OptionType::kFlushBlockPolicyFactory: {</a>
<a name="ln517">      const auto* ptr =</a>
<a name="ln518">          reinterpret_cast&lt;const std::shared_ptr&lt;FlushBlockPolicyFactory&gt;*&gt;(</a>
<a name="ln519">              opt_address);</a>
<a name="ln520">      *value = ptr-&gt;get() ? ptr-&gt;get()-&gt;Name() : kNullptrString;</a>
<a name="ln521">      break;</a>
<a name="ln522">    }</a>
<a name="ln523">    case OptionType::kEncodingType:</a>
<a name="ln524">      return SerializeEnum&lt;EncodingType&gt;(</a>
<a name="ln525">          encoding_type_string_map,</a>
<a name="ln526">          *reinterpret_cast&lt;const EncodingType*&gt;(opt_address), value);</a>
<a name="ln527">    case OptionType::kWALRecoveryMode:</a>
<a name="ln528">      return SerializeEnum&lt;WALRecoveryMode&gt;(</a>
<a name="ln529">          wal_recovery_mode_string_map,</a>
<a name="ln530">          *reinterpret_cast&lt;const WALRecoveryMode*&gt;(opt_address), value);</a>
<a name="ln531">    case OptionType::kAccessHint:</a>
<a name="ln532">      return SerializeEnum&lt;DBOptions::AccessHint&gt;(</a>
<a name="ln533">          access_hint_string_map,</a>
<a name="ln534">          *reinterpret_cast&lt;const DBOptions::AccessHint*&gt;(opt_address), value);</a>
<a name="ln535">    case OptionType::kInfoLogLevel:</a>
<a name="ln536">      return SerializeEnum&lt;InfoLogLevel&gt;(</a>
<a name="ln537">          info_log_level_string_map,</a>
<a name="ln538">          *reinterpret_cast&lt;const InfoLogLevel*&gt;(opt_address), value);</a>
<a name="ln539">    default:</a>
<a name="ln540">      return false;</a>
<a name="ln541">  }</a>
<a name="ln542">  return true;</a>
<a name="ln543">}</a>
<a name="ln544"> </a>
<a name="ln545"> </a>
<a name="ln546">template&lt;typename OptionsType&gt;</a>
<a name="ln547">bool ParseMemtableOptions(const std::string&amp; name, const std::string&amp; value,</a>
<a name="ln548">                          OptionsType* new_options) {</a>
<a name="ln549">  if (name == &quot;write_buffer_size&quot;) {</a>
<a name="ln550">    new_options-&gt;write_buffer_size = ParseSizeT(value);</a>
<a name="ln551">  } else if (name == &quot;arena_block_size&quot;) {</a>
<a name="ln552">    new_options-&gt;arena_block_size = ParseSizeT(value);</a>
<a name="ln553">  } else if (name == &quot;memtable_prefix_bloom_bits&quot;) {</a>
<a name="ln554">    new_options-&gt;memtable_prefix_bloom_bits = ParseUint32(value);</a>
<a name="ln555">  } else if (name == &quot;memtable_prefix_bloom_probes&quot;) {</a>
<a name="ln556">    new_options-&gt;memtable_prefix_bloom_probes = ParseUint32(value);</a>
<a name="ln557">  } else if (name == &quot;memtable_prefix_bloom_huge_page_tlb_size&quot;) {</a>
<a name="ln558">    new_options-&gt;memtable_prefix_bloom_huge_page_tlb_size =</a>
<a name="ln559">      ParseSizeT(value);</a>
<a name="ln560">  } else if (name == &quot;max_successive_merges&quot;) {</a>
<a name="ln561">    new_options-&gt;max_successive_merges = ParseSizeT(value);</a>
<a name="ln562">  } else if (name == &quot;filter_deletes&quot;) {</a>
<a name="ln563">    new_options-&gt;filter_deletes = ParseBoolean(name, value);</a>
<a name="ln564">  } else if (name == &quot;max_write_buffer_number&quot;) {</a>
<a name="ln565">    new_options-&gt;max_write_buffer_number = ParseInt(value);</a>
<a name="ln566">  } else if (name == &quot;inplace_update_num_locks&quot;) {</a>
<a name="ln567">    new_options-&gt;inplace_update_num_locks = ParseSizeT(value);</a>
<a name="ln568">  } else {</a>
<a name="ln569">    return false;</a>
<a name="ln570">  }</a>
<a name="ln571">  return true;</a>
<a name="ln572">}</a>
<a name="ln573"> </a>
<a name="ln574">template&lt;typename OptionsType&gt;</a>
<a name="ln575">bool ParseCompactionOptions(const std::string&amp; name, const std::string&amp; value,</a>
<a name="ln576">                            OptionsType* new_options) {</a>
<a name="ln577">  if (name == &quot;disable_auto_compactions&quot;) {</a>
<a name="ln578">    new_options-&gt;disable_auto_compactions = ParseBoolean(name, value);</a>
<a name="ln579">  } else if (name == &quot;soft_rate_limit&quot;) {</a>
<a name="ln580">    // Deprecated options but still leave it here to avoid older options</a>
<a name="ln581">    // strings can be consumed.</a>
<a name="ln582">  } else if (name == &quot;soft_pending_compaction_bytes_limit&quot;) {</a>
<a name="ln583">    new_options-&gt;soft_pending_compaction_bytes_limit = ParseUint64(value);</a>
<a name="ln584">  } else if (name == &quot;hard_pending_compaction_bytes_limit&quot;) {</a>
<a name="ln585">    new_options-&gt;hard_pending_compaction_bytes_limit = ParseUint64(value);</a>
<a name="ln586">  } else if (name == &quot;hard_rate_limit&quot;) {</a>
<a name="ln587">    // Deprecated options but still leave it here to avoid older options</a>
<a name="ln588">    // strings can be consumed.</a>
<a name="ln589">  } else if (name == &quot;level0_file_num_compaction_trigger&quot;) {</a>
<a name="ln590">    new_options-&gt;level0_file_num_compaction_trigger = ParseInt(value);</a>
<a name="ln591">  } else if (name == &quot;level0_slowdown_writes_trigger&quot;) {</a>
<a name="ln592">    new_options-&gt;level0_slowdown_writes_trigger = ParseInt(value);</a>
<a name="ln593">  } else if (name == &quot;level0_stop_writes_trigger&quot;) {</a>
<a name="ln594">    new_options-&gt;level0_stop_writes_trigger = ParseInt(value);</a>
<a name="ln595">  } else if (name == &quot;max_grandparent_overlap_factor&quot;) {</a>
<a name="ln596">    new_options-&gt;max_grandparent_overlap_factor = ParseInt(value);</a>
<a name="ln597">  } else if (name == &quot;expanded_compaction_factor&quot;) {</a>
<a name="ln598">    new_options-&gt;expanded_compaction_factor = ParseInt(value);</a>
<a name="ln599">  } else if (name == &quot;source_compaction_factor&quot;) {</a>
<a name="ln600">    new_options-&gt;source_compaction_factor = ParseInt(value);</a>
<a name="ln601">  } else if (name == &quot;target_file_size_base&quot;) {</a>
<a name="ln602">    new_options-&gt;target_file_size_base = ParseInt(value);</a>
<a name="ln603">  } else if (name == &quot;target_file_size_multiplier&quot;) {</a>
<a name="ln604">    new_options-&gt;target_file_size_multiplier = ParseInt(value);</a>
<a name="ln605">  } else if (name == &quot;max_bytes_for_level_base&quot;) {</a>
<a name="ln606">    new_options-&gt;max_bytes_for_level_base = ParseUint64(value);</a>
<a name="ln607">  } else if (name == &quot;max_bytes_for_level_multiplier&quot;) {</a>
<a name="ln608">    new_options-&gt;max_bytes_for_level_multiplier = ParseInt(value);</a>
<a name="ln609">  } else if (name == &quot;max_bytes_for_level_multiplier_additional&quot;) {</a>
<a name="ln610">    new_options-&gt;max_bytes_for_level_multiplier_additional.clear();</a>
<a name="ln611">    size_t start = 0;</a>
<a name="ln612">    while (true) {</a>
<a name="ln613">      size_t end = value.find(':', start);</a>
<a name="ln614">      if (end == std::string::npos) {</a>
<a name="ln615">        new_options-&gt;max_bytes_for_level_multiplier_additional.push_back(</a>
<a name="ln616">            ParseInt(value.substr(start)));</a>
<a name="ln617">        break;</a>
<a name="ln618">      } else {</a>
<a name="ln619">        new_options-&gt;max_bytes_for_level_multiplier_additional.push_back(</a>
<a name="ln620">            ParseInt(value.substr(start, end - start)));</a>
<a name="ln621">        start = end + 1;</a>
<a name="ln622">      }</a>
<a name="ln623">    }</a>
<a name="ln624">  } else if (name == &quot;verify_checksums_in_compaction&quot;) {</a>
<a name="ln625">    new_options-&gt;verify_checksums_in_compaction = ParseBoolean(name, value);</a>
<a name="ln626">  } else {</a>
<a name="ln627">    return false;</a>
<a name="ln628">  }</a>
<a name="ln629">  return true;</a>
<a name="ln630">}</a>
<a name="ln631"> </a>
<a name="ln632">template&lt;typename OptionsType&gt;</a>
<a name="ln633">bool ParseMiscOptions(const std::string&amp; name, const std::string&amp; value,</a>
<a name="ln634">                      OptionsType* new_options) {</a>
<a name="ln635">  if (name == &quot;max_sequential_skip_in_iterations&quot;) {</a>
<a name="ln636">    new_options-&gt;max_sequential_skip_in_iterations = ParseUint64(value);</a>
<a name="ln637">  } else if (name == &quot;paranoid_file_checks&quot;) {</a>
<a name="ln638">    new_options-&gt;paranoid_file_checks = ParseBoolean(name, value);</a>
<a name="ln639">  } else {</a>
<a name="ln640">    return false;</a>
<a name="ln641">  }</a>
<a name="ln642">  return true;</a>
<a name="ln643">}</a>
<a name="ln644"> </a>
<a name="ln645">Status GetMutableOptionsFromStrings(</a>
<a name="ln646">    const MutableCFOptions&amp; base_options,</a>
<a name="ln647">    const std::unordered_map&lt;std::string, std::string&gt;&amp; options_map,</a>
<a name="ln648">    MutableCFOptions* new_options) {</a>
<a name="ln649">  assert(new_options);</a>
<a name="ln650">  *new_options = base_options;</a>
<a name="ln651">  for (const auto&amp; o : options_map) {</a>
<a name="ln652">    try {</a>
<a name="ln653">      if (ParseMemtableOptions(o.first, o.second, new_options)) {</a>
<a name="ln654">      } else if (ParseCompactionOptions(o.first, o.second, new_options)) {</a>
<a name="ln655">      } else if (ParseMiscOptions(o.first, o.second, new_options)) {</a>
<a name="ln656">      } else {</a>
<a name="ln657">        return STATUS(InvalidArgument,</a>
<a name="ln658">            &quot;unsupported dynamic option: &quot; + o.first);</a>
<a name="ln659">      }</a>
<a name="ln660">    } catch (std::exception&amp; e) {</a>
<a name="ln661">      return STATUS(InvalidArgument, &quot;error parsing &quot; + o.first + &quot;:&quot; +</a>
<a name="ln662">                                     std::string(e.what()));</a>
<a name="ln663">    }</a>
<a name="ln664">  }</a>
<a name="ln665">  return Status::OK();</a>
<a name="ln666">}</a>
<a name="ln667"> </a>
<a name="ln668">Status StringToMap(const std::string&amp; opts_str,</a>
<a name="ln669">                   std::unordered_map&lt;std::string, std::string&gt;* opts_map) {</a>
<a name="ln670">  assert(opts_map);</a>
<a name="ln671">  // Example:</a>
<a name="ln672">  //   opts_str = &quot;write_buffer_size=1024;max_write_buffer_number=2;&quot;</a>
<a name="ln673">  //              &quot;nested_opt={opt1=1;opt2=2};max_bytes_for_level_base=100&quot;</a>
<a name="ln674">  size_t pos = 0;</a>
<a name="ln675">  std::string opts = trim(opts_str);</a>
<a name="ln676">  while (pos &lt; opts.size()) {</a>
<a name="ln677">    size_t eq_pos = opts.find('=', pos);</a>
<a name="ln678">    if (eq_pos == std::string::npos) {</a>
<a name="ln679">      return STATUS(InvalidArgument, &quot;Mismatched key value pair, '=' expected&quot;);</a>
<a name="ln680">    }</a>
<a name="ln681">    std::string key = trim(opts.substr(pos, eq_pos - pos));</a>
<a name="ln682">    if (key.empty()) {</a>
<a name="ln683">      return STATUS(InvalidArgument, &quot;Empty key found&quot;);</a>
<a name="ln684">    }</a>
<a name="ln685"> </a>
<a name="ln686">    // skip space after '=' and look for '{' for possible nested options</a>
<a name="ln687">    pos = eq_pos + 1;</a>
<a name="ln688">    while (pos &lt; opts.size() &amp;&amp; isspace(opts[pos])) {</a>
<a name="ln689">      ++pos;</a>
<a name="ln690">    }</a>
<a name="ln691">    // Empty value at the end</a>
<a name="ln692">    if (pos &gt;= opts.size()) {</a>
<a name="ln693">      (*opts_map)[key] = &quot;&quot;;</a>
<a name="ln694">      break;</a>
<a name="ln695">    }</a>
<a name="ln696">    if (opts[pos] == '{') {</a>
<a name="ln697">      int count = 1;</a>
<a name="ln698">      size_t brace_pos = pos + 1;</a>
<a name="ln699">      while (brace_pos &lt; opts.size()) {</a>
<a name="ln700">        if (opts[brace_pos] == '{') {</a>
<a name="ln701">          ++count;</a>
<a name="ln702">        } else if (opts[brace_pos] == '}') {</a>
<a name="ln703">          --count;</a>
<a name="ln704">          if (count == 0) {</a>
<a name="ln705">            break;</a>
<a name="ln706">          }</a>
<a name="ln707">        }</a>
<a name="ln708">        ++brace_pos;</a>
<a name="ln709">      }</a>
<a name="ln710">      // found the matching closing brace</a>
<a name="ln711">      if (count == 0) {</a>
<a name="ln712">        (*opts_map)[key] = trim(opts.substr(pos + 1, brace_pos - pos - 1));</a>
<a name="ln713">        // skip all whitespace and move to the next ';'</a>
<a name="ln714">        // brace_pos points to the next position after the matching '}'</a>
<a name="ln715">        pos = brace_pos + 1;</a>
<a name="ln716">        while (pos &lt; opts.size() &amp;&amp; isspace(opts[pos])) {</a>
<a name="ln717">          ++pos;</a>
<a name="ln718">        }</a>
<a name="ln719">        if (pos &lt; opts.size() &amp;&amp; opts[pos] != ';') {</a>
<a name="ln720">          return STATUS(InvalidArgument,</a>
<a name="ln721">              &quot;Unexpected chars after nested options&quot;);</a>
<a name="ln722">        }</a>
<a name="ln723">        ++pos;</a>
<a name="ln724">      } else {</a>
<a name="ln725">        return STATUS(InvalidArgument,</a>
<a name="ln726">            &quot;Mismatched curly braces for nested options&quot;);</a>
<a name="ln727">      }</a>
<a name="ln728">    } else {</a>
<a name="ln729">      size_t sc_pos = opts.find(';', pos);</a>
<a name="ln730">      if (sc_pos == std::string::npos) {</a>
<a name="ln731">        (*opts_map)[key] = trim(opts.substr(pos));</a>
<a name="ln732">        // It either ends with a trailing semi-colon or the last key-value pair</a>
<a name="ln733">        break;</a>
<a name="ln734">      } else {</a>
<a name="ln735">        (*opts_map)[key] = trim(opts.substr(pos, sc_pos - pos));</a>
<a name="ln736">      }</a>
<a name="ln737">      pos = sc_pos + 1;</a>
<a name="ln738">    }</a>
<a name="ln739">  }</a>
<a name="ln740"> </a>
<a name="ln741">  return Status::OK();</a>
<a name="ln742">}</a>
<a name="ln743"> </a>
<a name="ln744">Status ParseColumnFamilyOption(const std::string&amp; name,</a>
<a name="ln745">                               const std::string&amp; org_value,</a>
<a name="ln746">                               ColumnFamilyOptions* new_options,</a>
<a name="ln747">                               bool input_strings_escaped = false) {</a>
<a name="ln748">  const std::string&amp; value =</a>
<a name="ln749">      input_strings_escaped ? UnescapeOptionString(org_value) : org_value;</a>
<a name="ln750">  try {</a>
<a name="ln751">    if (name == &quot;max_bytes_for_level_multiplier_additional&quot;) {</a>
<a name="ln752">      new_options-&gt;max_bytes_for_level_multiplier_additional.clear();</a>
<a name="ln753">      size_t start = 0;</a>
<a name="ln754">      while (true) {</a>
<a name="ln755">        size_t end = value.find(':', start);</a>
<a name="ln756">        if (end == std::string::npos) {</a>
<a name="ln757">          new_options-&gt;max_bytes_for_level_multiplier_additional.push_back(</a>
<a name="ln758">              ParseInt(value.substr(start)));</a>
<a name="ln759">          break;</a>
<a name="ln760">        } else {</a>
<a name="ln761">          new_options-&gt;max_bytes_for_level_multiplier_additional.push_back(</a>
<a name="ln762">              ParseInt(value.substr(start, end - start)));</a>
<a name="ln763">          start = end + 1;</a>
<a name="ln764">        }</a>
<a name="ln765">      }</a>
<a name="ln766">    } else if (name == &quot;block_based_table_factory&quot;) {</a>
<a name="ln767">      // Nested options</a>
<a name="ln768">      BlockBasedTableOptions table_opt, base_table_options;</a>
<a name="ln769">      auto block_based_table_factory = dynamic_cast&lt;BlockBasedTableFactory*&gt;(</a>
<a name="ln770">          new_options-&gt;table_factory.get());</a>
<a name="ln771">      if (block_based_table_factory != nullptr) {</a>
<a name="ln772">        base_table_options = block_based_table_factory-&gt;table_options();</a>
<a name="ln773">      }</a>
<a name="ln774">      Status table_opt_s = GetBlockBasedTableOptionsFromString(</a>
<a name="ln775">          base_table_options, value, &amp;table_opt);</a>
<a name="ln776">      if (!table_opt_s.ok()) {</a>
<a name="ln777">        return STATUS(InvalidArgument,</a>
<a name="ln778">            &quot;unable to parse the specified CF option &quot; + name);</a>
<a name="ln779">      }</a>
<a name="ln780">      new_options-&gt;table_factory.reset(NewBlockBasedTableFactory(table_opt));</a>
<a name="ln781">    } else if (name == &quot;plain_table_factory&quot;) {</a>
<a name="ln782">      // Nested options</a>
<a name="ln783">      PlainTableOptions table_opt, base_table_options;</a>
<a name="ln784">      auto plain_table_factory = dynamic_cast&lt;PlainTableFactory*&gt;(</a>
<a name="ln785">          new_options-&gt;table_factory.get());</a>
<a name="ln786">      if (plain_table_factory != nullptr) {</a>
<a name="ln787">        base_table_options = plain_table_factory-&gt;table_options();</a>
<a name="ln788">      }</a>
<a name="ln789">      Status table_opt_s = GetPlainTableOptionsFromString(</a>
<a name="ln790">          base_table_options, value, &amp;table_opt);</a>
<a name="ln791">      if (!table_opt_s.ok()) {</a>
<a name="ln792">        return STATUS(InvalidArgument,</a>
<a name="ln793">            &quot;unable to parse the specified CF option &quot; + name);</a>
<a name="ln794">      }</a>
<a name="ln795">      new_options-&gt;table_factory.reset(NewPlainTableFactory(table_opt));</a>
<a name="ln796">    } else if (name == &quot;memtable&quot;) {</a>
<a name="ln797">      std::unique_ptr&lt;MemTableRepFactory&gt; new_mem_factory;</a>
<a name="ln798">      Status mem_factory_s =</a>
<a name="ln799">          GetMemTableRepFactoryFromString(value, &amp;new_mem_factory);</a>
<a name="ln800">      if (!mem_factory_s.ok()) {</a>
<a name="ln801">        return STATUS(InvalidArgument,</a>
<a name="ln802">            &quot;unable to parse the specified CF option &quot; + name);</a>
<a name="ln803">      }</a>
<a name="ln804">      new_options-&gt;memtable_factory.reset(new_mem_factory.release());</a>
<a name="ln805">    } else if (name == &quot;compression_opts&quot;) {</a>
<a name="ln806">      size_t start = 0;</a>
<a name="ln807">      size_t end = value.find(':');</a>
<a name="ln808">      if (end == std::string::npos) {</a>
<a name="ln809">        return STATUS(InvalidArgument,</a>
<a name="ln810">            &quot;unable to parse the specified CF option &quot; + name);</a>
<a name="ln811">      }</a>
<a name="ln812">      new_options-&gt;compression_opts.window_bits =</a>
<a name="ln813">          ParseInt(value.substr(start, end - start));</a>
<a name="ln814">      start = end + 1;</a>
<a name="ln815">      end = value.find(':', start);</a>
<a name="ln816">      if (end == std::string::npos) {</a>
<a name="ln817">        return STATUS(InvalidArgument,</a>
<a name="ln818">            &quot;unable to parse the specified CF option &quot; + name);</a>
<a name="ln819">      }</a>
<a name="ln820">      new_options-&gt;compression_opts.level =</a>
<a name="ln821">          ParseInt(value.substr(start, end - start));</a>
<a name="ln822">      start = end + 1;</a>
<a name="ln823">      if (start &gt;= value.size()) {</a>
<a name="ln824">        return STATUS(InvalidArgument,</a>
<a name="ln825">            &quot;unable to parse the specified CF option &quot; + name);</a>
<a name="ln826">      }</a>
<a name="ln827">      new_options-&gt;compression_opts.strategy =</a>
<a name="ln828">          ParseInt(value.substr(start, value.size() - start));</a>
<a name="ln829">    } else if (name == &quot;compaction_options_fifo&quot;) {</a>
<a name="ln830">      new_options-&gt;compaction_options_fifo.max_table_files_size =</a>
<a name="ln831">          ParseUint64(value);</a>
<a name="ln832">    } else {</a>
<a name="ln833">      auto iter = cf_options_type_info.find(name);</a>
<a name="ln834">      if (iter == cf_options_type_info.end()) {</a>
<a name="ln835">        return STATUS(InvalidArgument,</a>
<a name="ln836">            &quot;Unable to parse the specified CF option &quot; + name);</a>
<a name="ln837">      }</a>
<a name="ln838">      const auto&amp; opt_info = iter-&gt;second;</a>
<a name="ln839">      if (ParseOptionHelper(</a>
<a name="ln840">              reinterpret_cast&lt;char*&gt;(new_options) + opt_info.offset,</a>
<a name="ln841">              opt_info.type, value)) {</a>
<a name="ln842">        return Status::OK();</a>
<a name="ln843">      }</a>
<a name="ln844">      switch (opt_info.verification) {</a>
<a name="ln845">        case OptionVerificationType::kByName:</a>
<a name="ln846">        case OptionVerificationType::kByNameAllowNull:</a>
<a name="ln847">          return STATUS(NotSupported,</a>
<a name="ln848">              &quot;Deserializing the specified CF option &quot; + name +</a>
<a name="ln849">                  &quot; is not supported&quot;);</a>
<a name="ln850">        case OptionVerificationType::kDeprecated:</a>
<a name="ln851">          return Status::OK();</a>
<a name="ln852">        default:</a>
<a name="ln853">          return STATUS(InvalidArgument,</a>
<a name="ln854">              &quot;Unable to parse the specified CF option &quot; + name);</a>
<a name="ln855">      }</a>
<a name="ln856">    }</a>
<a name="ln857">  } catch (const std::exception&amp;) {</a>
<a name="ln858">    return STATUS(InvalidArgument,</a>
<a name="ln859">        &quot;unable to parse the specified option &quot; + name);</a>
<a name="ln860">  }</a>
<a name="ln861">  return Status::OK();</a>
<a name="ln862">}</a>
<a name="ln863"> </a>
<a name="ln864">bool SerializeSingleDBOption(std::string* opt_string,</a>
<a name="ln865">                             const DBOptions&amp; db_options,</a>
<a name="ln866">                             const std::string&amp; name,</a>
<a name="ln867">                             const std::string&amp; delimiter) {</a>
<a name="ln868">  auto iter = db_options_type_info.find(name);</a>
<a name="ln869">  if (iter == db_options_type_info.end()) {</a>
<a name="ln870">    return false;</a>
<a name="ln871">  }</a>
<a name="ln872">  auto&amp; opt_info = iter-&gt;second;</a>
<a name="ln873">  const char* opt_address =</a>
<a name="ln874">      reinterpret_cast&lt;const char*&gt;(&amp;db_options) + opt_info.offset;</a>
<a name="ln875">  std::string value;</a>
<a name="ln876">  bool result = SerializeSingleOptionHelper(opt_address, opt_info.type, &amp;value);</a>
<a name="ln877">  if (result) {</a>
<a name="ln878">    *opt_string = name + &quot;=&quot; + value + delimiter;</a>
<a name="ln879">  }</a>
<a name="ln880">  return result;</a>
<a name="ln881">}</a>
<a name="ln882"> </a>
<a name="ln883">Status GetStringFromDBOptions(std::string* opt_string,</a>
<a name="ln884">                              const DBOptions&amp; db_options,</a>
<a name="ln885">                              const std::string&amp; delimiter) {</a>
<a name="ln886">  assert(opt_string);</a>
<a name="ln887">  opt_string-&gt;clear();</a>
<a name="ln888">  for (auto iter = db_options_type_info.begin();</a>
<a name="ln889">       iter != db_options_type_info.end(); ++iter) {</a>
<a name="ln890">    if (iter-&gt;second.verification == OptionVerificationType::kDeprecated) {</a>
<a name="ln891">      // If the option is no longer used in rocksdb and marked as deprecated,</a>
<a name="ln892">      // we skip it in the serialization.</a>
<a name="ln893">      continue;</a>
<a name="ln894">    }</a>
<a name="ln895">    std::string single_output;</a>
<a name="ln896">    bool result = SerializeSingleDBOption(&amp;single_output, db_options,</a>
<a name="ln897">                                          iter-&gt;first, delimiter);</a>
<a name="ln898">    assert(result);</a>
<a name="ln899">    if (result) {</a>
<a name="ln900">      opt_string-&gt;append(single_output);</a>
<a name="ln901">    }</a>
<a name="ln902">  }</a>
<a name="ln903">  return Status::OK();</a>
<a name="ln904">}</a>
<a name="ln905"> </a>
<a name="ln906">bool SerializeSingleColumnFamilyOption(std::string* opt_string,</a>
<a name="ln907">                                       const ColumnFamilyOptions&amp; cf_options,</a>
<a name="ln908">                                       const std::string&amp; name,</a>
<a name="ln909">                                       const std::string&amp; delimiter) {</a>
<a name="ln910">  auto iter = cf_options_type_info.find(name);</a>
<a name="ln911">  if (iter == cf_options_type_info.end()) {</a>
<a name="ln912">    return false;</a>
<a name="ln913">  }</a>
<a name="ln914">  auto&amp; opt_info = iter-&gt;second;</a>
<a name="ln915">  const char* opt_address =</a>
<a name="ln916">      reinterpret_cast&lt;const char*&gt;(&amp;cf_options) + opt_info.offset;</a>
<a name="ln917">  std::string value;</a>
<a name="ln918">  bool result = SerializeSingleOptionHelper(opt_address, opt_info.type, &amp;value);</a>
<a name="ln919">  if (result) {</a>
<a name="ln920">    *opt_string = name + &quot;=&quot; + value + delimiter;</a>
<a name="ln921">  }</a>
<a name="ln922">  return result;</a>
<a name="ln923">}</a>
<a name="ln924"> </a>
<a name="ln925">Status GetStringFromColumnFamilyOptions(std::string* opt_string,</a>
<a name="ln926">                                        const ColumnFamilyOptions&amp; cf_options,</a>
<a name="ln927">                                        const std::string&amp; delimiter) {</a>
<a name="ln928">  assert(opt_string);</a>
<a name="ln929">  opt_string-&gt;clear();</a>
<a name="ln930">  for (auto iter = cf_options_type_info.begin();</a>
<a name="ln931">       iter != cf_options_type_info.end(); ++iter) {</a>
<a name="ln932">    if (iter-&gt;second.verification == OptionVerificationType::kDeprecated) {</a>
<a name="ln933">      // If the option is no longer used in rocksdb and marked as deprecated,</a>
<a name="ln934">      // we skip it in the serialization.</a>
<a name="ln935">      continue;</a>
<a name="ln936">    }</a>
<a name="ln937">    std::string single_output;</a>
<a name="ln938">    bool result = SerializeSingleColumnFamilyOption(&amp;single_output, cf_options,</a>
<a name="ln939">                                                    iter-&gt;first, delimiter);</a>
<a name="ln940">    if (result) {</a>
<a name="ln941">      opt_string-&gt;append(single_output);</a>
<a name="ln942">    } else {</a>
<a name="ln943">      return STATUS(InvalidArgument, &quot;failed to serialize %s\n&quot;,</a>
<a name="ln944">                                     iter-&gt;first.c_str());</a>
<a name="ln945">    }</a>
<a name="ln946">    assert(result);</a>
<a name="ln947">  }</a>
<a name="ln948">  return Status::OK();</a>
<a name="ln949">}</a>
<a name="ln950"> </a>
<a name="ln951">bool SerializeSingleBlockBasedTableOption(</a>
<a name="ln952">    std::string* opt_string, const BlockBasedTableOptions&amp; bbt_options,</a>
<a name="ln953">    const std::string&amp; name, const std::string&amp; delimiter) {</a>
<a name="ln954">  auto iter = block_based_table_type_info.find(name);</a>
<a name="ln955">  if (iter == block_based_table_type_info.end()) {</a>
<a name="ln956">    return false;</a>
<a name="ln957">  }</a>
<a name="ln958">  auto&amp; opt_info = iter-&gt;second;</a>
<a name="ln959">  const char* opt_address =</a>
<a name="ln960">      reinterpret_cast&lt;const char*&gt;(&amp;bbt_options) + opt_info.offset;</a>
<a name="ln961">  std::string value;</a>
<a name="ln962">  bool result = SerializeSingleOptionHelper(opt_address, opt_info.type, &amp;value);</a>
<a name="ln963">  if (result) {</a>
<a name="ln964">    *opt_string = name + &quot;=&quot; + value + delimiter;</a>
<a name="ln965">  }</a>
<a name="ln966">  return result;</a>
<a name="ln967">}</a>
<a name="ln968"> </a>
<a name="ln969">Status GetStringFromBlockBasedTableOptions(</a>
<a name="ln970">    std::string* opt_string, const BlockBasedTableOptions&amp; bbt_options,</a>
<a name="ln971">    const std::string&amp; delimiter) {</a>
<a name="ln972">  assert(opt_string);</a>
<a name="ln973">  opt_string-&gt;clear();</a>
<a name="ln974">  for (auto iter = block_based_table_type_info.begin();</a>
<a name="ln975">       iter != block_based_table_type_info.end(); ++iter) {</a>
<a name="ln976">    if (iter-&gt;second.verification == OptionVerificationType::kDeprecated) {</a>
<a name="ln977">      // If the option is no longer used in rocksdb and marked as deprecated,</a>
<a name="ln978">      // we skip it in the serialization.</a>
<a name="ln979">      continue;</a>
<a name="ln980">    }</a>
<a name="ln981">    std::string single_output;</a>
<a name="ln982">    bool result = SerializeSingleBlockBasedTableOption(</a>
<a name="ln983">        &amp;single_output, bbt_options, iter-&gt;first, delimiter);</a>
<a name="ln984">    assert(result);</a>
<a name="ln985">    if (result) {</a>
<a name="ln986">      opt_string-&gt;append(single_output);</a>
<a name="ln987">    }</a>
<a name="ln988">  }</a>
<a name="ln989">  return Status::OK();</a>
<a name="ln990">}</a>
<a name="ln991"> </a>
<a name="ln992">Status GetStringFromTableFactory(std::string* opts_str, const TableFactory* tf,</a>
<a name="ln993">                                 const std::string&amp; delimiter) {</a>
<a name="ln994">  const auto* bbtf = dynamic_cast&lt;const BlockBasedTableFactory*&gt;(tf);</a>
<a name="ln995">  opts_str-&gt;clear();</a>
<a name="ln996">  if (bbtf != nullptr) {</a>
<a name="ln997">    return GetStringFromBlockBasedTableOptions(opts_str, bbtf-&gt;table_options(),</a>
<a name="ln998">                                               delimiter);</a>
<a name="ln999">  }</a>
<a name="ln1000"> </a>
<a name="ln1001">  return Status::OK();</a>
<a name="ln1002">}</a>
<a name="ln1003"> </a>
<a name="ln1004">Status ParseDBOption(const std::string&amp; name,</a>
<a name="ln1005">                     const std::string&amp; org_value,</a>
<a name="ln1006">                     DBOptions* new_options,</a>
<a name="ln1007">                     bool input_strings_escaped = false) {</a>
<a name="ln1008">  const std::string&amp; value =</a>
<a name="ln1009">      input_strings_escaped ? UnescapeOptionString(org_value) : org_value;</a>
<a name="ln1010">  try {</a>
<a name="ln1011">    if (name == &quot;rate_limiter_bytes_per_sec&quot;) {</a>
<a name="ln1012">      new_options-&gt;rate_limiter.reset(</a>
<a name="ln1013">          NewGenericRateLimiter(static_cast&lt;int64_t&gt;(ParseUint64(value))));</a>
<a name="ln1014">    } else {</a>
<a name="ln1015">      auto iter = db_options_type_info.find(name);</a>
<a name="ln1016">      if (iter == db_options_type_info.end()) {</a>
<a name="ln1017">        return STATUS(InvalidArgument, &quot;Unrecognized option DBOptions:&quot;, name);</a>
<a name="ln1018">      }</a>
<a name="ln1019">      const auto&amp; opt_info = iter-&gt;second;</a>
<a name="ln1020">      if (ParseOptionHelper(</a>
<a name="ln1021">              reinterpret_cast&lt;char*&gt;(new_options) + opt_info.offset,</a>
<a name="ln1022">              opt_info.type, value)) {</a>
<a name="ln1023">        return Status::OK();</a>
<a name="ln1024">      }</a>
<a name="ln1025">      switch (opt_info.verification) {</a>
<a name="ln1026">        case OptionVerificationType::kByName:</a>
<a name="ln1027">        case OptionVerificationType::kByNameAllowNull:</a>
<a name="ln1028">          return STATUS(NotSupported,</a>
<a name="ln1029">              &quot;Deserializing the specified DB option &quot; + name +</a>
<a name="ln1030">                  &quot; is not supported&quot;);</a>
<a name="ln1031">        case OptionVerificationType::kDeprecated:</a>
<a name="ln1032">          return Status::OK();</a>
<a name="ln1033">        default:</a>
<a name="ln1034">          return STATUS(InvalidArgument,</a>
<a name="ln1035">              &quot;Unable to parse the specified DB option &quot; + name);</a>
<a name="ln1036">      }</a>
<a name="ln1037">    }</a>
<a name="ln1038">  } catch (const std::exception&amp;) {</a>
<a name="ln1039">    return STATUS(InvalidArgument, &quot;Unable to parse DBOptions:&quot;, name);</a>
<a name="ln1040">  }</a>
<a name="ln1041">  return Status::OK();</a>
<a name="ln1042">}</a>
<a name="ln1043"> </a>
<a name="ln1044">std::string ParseBlockBasedTableOption(const std::string&amp; name,</a>
<a name="ln1045">                                       const std::string&amp; org_value,</a>
<a name="ln1046">                                       BlockBasedTableOptions* new_options,</a>
<a name="ln1047">                                       bool input_strings_escaped = false) {</a>
<a name="ln1048">  const std::string&amp; value =</a>
<a name="ln1049">      input_strings_escaped ? UnescapeOptionString(org_value) : org_value;</a>
<a name="ln1050">  if (!input_strings_escaped) {</a>
<a name="ln1051">    // if the input string is not escaped, it means this function is</a>
<a name="ln1052">    // invoked from SetOptions, which takes the old format.</a>
<a name="ln1053">    if (name == &quot;block_cache&quot;) {</a>
<a name="ln1054">      new_options-&gt;block_cache = NewLRUCache(ParseSizeT(value));</a>
<a name="ln1055">      return &quot;&quot;;</a>
<a name="ln1056">    } else if (name == &quot;block_cache_compressed&quot;) {</a>
<a name="ln1057">      new_options-&gt;block_cache_compressed = NewLRUCache(ParseSizeT(value));</a>
<a name="ln1058">      return &quot;&quot;;</a>
<a name="ln1059">    } else if (name == &quot;filter_policy&quot;) {</a>
<a name="ln1060">      // Expect the following format</a>
<a name="ln1061">      // bloomfilter:int:bool</a>
<a name="ln1062">      const std::string kName = &quot;bloomfilter:&quot;;</a>
<a name="ln1063">      if (value.compare(0, kName.size(), kName) != 0) {</a>
<a name="ln1064">        return &quot;Invalid filter policy name&quot;;</a>
<a name="ln1065">      }</a>
<a name="ln1066">      size_t pos = value.find(':', kName.size());</a>
<a name="ln1067">      if (pos == std::string::npos) {</a>
<a name="ln1068">        return &quot;Invalid filter policy config, missing bits_per_key&quot;;</a>
<a name="ln1069">      }</a>
<a name="ln1070">      int bits_per_key =</a>
<a name="ln1071">          ParseInt(trim(value.substr(kName.size(), pos - kName.size())));</a>
<a name="ln1072">      bool use_block_based_builder =</a>
<a name="ln1073">          ParseBoolean(&quot;use_block_based_builder&quot;, trim(value.substr(pos + 1)));</a>
<a name="ln1074">      new_options-&gt;filter_policy.reset(</a>
<a name="ln1075">          NewBloomFilterPolicy(bits_per_key, use_block_based_builder));</a>
<a name="ln1076">      return &quot;&quot;;</a>
<a name="ln1077">    }</a>
<a name="ln1078">  }</a>
<a name="ln1079">  const auto iter = block_based_table_type_info.find(name);</a>
<a name="ln1080">  if (iter == block_based_table_type_info.end()) {</a>
<a name="ln1081">    return &quot;Unrecognized option&quot;;</a>
<a name="ln1082">  }</a>
<a name="ln1083">  const auto&amp; opt_info = iter-&gt;second;</a>
<a name="ln1084">  if (!ParseOptionHelper(reinterpret_cast&lt;char*&gt;(new_options) + opt_info.offset,</a>
<a name="ln1085">                         opt_info.type, value)) {</a>
<a name="ln1086">    return &quot;Invalid value&quot;;</a>
<a name="ln1087">  }</a>
<a name="ln1088">  return &quot;&quot;;</a>
<a name="ln1089">}</a>
<a name="ln1090"> </a>
<a name="ln1091">std::string ParsePlainTableOptions(const std::string&amp; name,</a>
<a name="ln1092">                                   const std::string&amp; org_value,</a>
<a name="ln1093">                                   PlainTableOptions* new_option,</a>
<a name="ln1094">                                   bool input_strings_escaped = false) {</a>
<a name="ln1095">  const std::string&amp; value =</a>
<a name="ln1096">      input_strings_escaped ? UnescapeOptionString(org_value) : org_value;</a>
<a name="ln1097">  const auto iter = plain_table_type_info.find(name);</a>
<a name="ln1098">  if (iter == plain_table_type_info.end()) {</a>
<a name="ln1099">    return &quot;Unrecognized option&quot;;</a>
<a name="ln1100">  }</a>
<a name="ln1101">  const auto&amp; opt_info = iter-&gt;second;</a>
<a name="ln1102">  if (!ParseOptionHelper(reinterpret_cast&lt;char*&gt;(new_option) + opt_info.offset,</a>
<a name="ln1103">                         opt_info.type, value)) {</a>
<a name="ln1104">    return &quot;Invalid value&quot;;</a>
<a name="ln1105">  }</a>
<a name="ln1106">  return &quot;&quot;;</a>
<a name="ln1107">}</a>
<a name="ln1108"> </a>
<a name="ln1109">Status GetBlockBasedTableOptionsFromMap(</a>
<a name="ln1110">    const BlockBasedTableOptions&amp; table_options,</a>
<a name="ln1111">    const std::unordered_map&lt;std::string, std::string&gt;&amp; opts_map,</a>
<a name="ln1112">    BlockBasedTableOptions* new_table_options, bool input_strings_escaped) {</a>
<a name="ln1113">  assert(new_table_options);</a>
<a name="ln1114">  *new_table_options = table_options;</a>
<a name="ln1115">  for (const auto&amp; o : opts_map) {</a>
<a name="ln1116">    auto error_message = ParseBlockBasedTableOption(</a>
<a name="ln1117">        o.first, o.second, new_table_options, input_strings_escaped);</a>
<a name="ln1118">    if (error_message != &quot;&quot;) {</a>
<a name="ln1119">      const auto iter = block_based_table_type_info.find(o.first);</a>
<a name="ln1120">      if (iter == block_based_table_type_info.end() ||</a>
<a name="ln1121">          !input_strings_escaped ||  // !input_strings_escaped indicates</a>
<a name="ln1122">                                     // the old API, where everything is</a>
<a name="ln1123">                                     // parsable.</a>
<a name="ln1124">          (iter-&gt;second.verification != OptionVerificationType::kByName &amp;&amp;</a>
<a name="ln1125">           iter-&gt;second.verification !=</a>
<a name="ln1126">               OptionVerificationType::kByNameAllowNull &amp;&amp;</a>
<a name="ln1127">           iter-&gt;second.verification != OptionVerificationType::kDeprecated)) {</a>
<a name="ln1128">        return STATUS(InvalidArgument, &quot;Can't parse BlockBasedTableOptions:&quot;,</a>
<a name="ln1129">                                       o.first + &quot; &quot; + error_message);</a>
<a name="ln1130">      }</a>
<a name="ln1131">    }</a>
<a name="ln1132">  }</a>
<a name="ln1133">  return Status::OK();</a>
<a name="ln1134">}</a>
<a name="ln1135"> </a>
<a name="ln1136">Status GetBlockBasedTableOptionsFromString(</a>
<a name="ln1137">    const BlockBasedTableOptions&amp; table_options,</a>
<a name="ln1138">    const std::string&amp; opts_str,</a>
<a name="ln1139">    BlockBasedTableOptions* new_table_options) {</a>
<a name="ln1140">  std::unordered_map&lt;std::string, std::string&gt; opts_map;</a>
<a name="ln1141">  Status s = StringToMap(opts_str, &amp;opts_map);</a>
<a name="ln1142">  if (!s.ok()) {</a>
<a name="ln1143">    return s;</a>
<a name="ln1144">  }</a>
<a name="ln1145">  return GetBlockBasedTableOptionsFromMap(table_options, opts_map,</a>
<a name="ln1146">                                          new_table_options);</a>
<a name="ln1147">}</a>
<a name="ln1148"> </a>
<a name="ln1149">Status GetPlainTableOptionsFromMap(</a>
<a name="ln1150">    const PlainTableOptions&amp; table_options,</a>
<a name="ln1151">    const std::unordered_map&lt;std::string, std::string&gt;&amp; opts_map,</a>
<a name="ln1152">    PlainTableOptions* new_table_options, bool input_strings_escaped) {</a>
<a name="ln1153">  assert(new_table_options);</a>
<a name="ln1154">  *new_table_options = table_options;</a>
<a name="ln1155">  for (const auto&amp; o : opts_map) {</a>
<a name="ln1156">    auto error_message = ParsePlainTableOptions(</a>
<a name="ln1157">        o.first, o.second, new_table_options, input_strings_escaped);</a>
<a name="ln1158">    if (error_message != &quot;&quot;) {</a>
<a name="ln1159">      const auto iter = plain_table_type_info.find(o.first);</a>
<a name="ln1160">      if (iter == plain_table_type_info.end() ||</a>
<a name="ln1161">          !input_strings_escaped ||  // !input_strings_escaped indicates</a>
<a name="ln1162">                                     // the old API, where everything is</a>
<a name="ln1163">                                     // parsable.</a>
<a name="ln1164">          (iter-&gt;second.verification != OptionVerificationType::kByName &amp;&amp;</a>
<a name="ln1165">           iter-&gt;second.verification !=</a>
<a name="ln1166">               OptionVerificationType::kByNameAllowNull &amp;&amp;</a>
<a name="ln1167">           iter-&gt;second.verification != OptionVerificationType::kDeprecated)) {</a>
<a name="ln1168">        return STATUS(InvalidArgument, &quot;Can't parse PlainTableOptions:&quot;,</a>
<a name="ln1169">                                        o.first + &quot; &quot; + error_message);</a>
<a name="ln1170">      }</a>
<a name="ln1171">    }</a>
<a name="ln1172">  }</a>
<a name="ln1173">  return Status::OK();</a>
<a name="ln1174">}</a>
<a name="ln1175"> </a>
<a name="ln1176">Status GetPlainTableOptionsFromString(</a>
<a name="ln1177">    const PlainTableOptions&amp; table_options,</a>
<a name="ln1178">    const std::string&amp; opts_str,</a>
<a name="ln1179">    PlainTableOptions* new_table_options) {</a>
<a name="ln1180">  std::unordered_map&lt;std::string, std::string&gt; opts_map;</a>
<a name="ln1181">  Status s = StringToMap(opts_str, &amp;opts_map);</a>
<a name="ln1182">  if (!s.ok()) {</a>
<a name="ln1183">    return s;</a>
<a name="ln1184">  }</a>
<a name="ln1185">  return GetPlainTableOptionsFromMap(table_options, opts_map,</a>
<a name="ln1186">                                     new_table_options);</a>
<a name="ln1187">}</a>
<a name="ln1188"> </a>
<a name="ln1189">Status GetMemTableRepFactoryFromString(const std::string&amp; opts_str,</a>
<a name="ln1190">    std::unique_ptr&lt;MemTableRepFactory&gt;* new_mem_factory) {</a>
<a name="ln1191">  std::vector&lt;std::string&gt; opts_list = StringSplit(opts_str, ':');</a>
<a name="ln1192">  size_t len = opts_list.size();</a>
<a name="ln1193"> </a>
<a name="ln1194">  if (opts_list.size() &lt;= 0 || opts_list.size() &gt; 2) {</a>
<a name="ln1195">    return STATUS(InvalidArgument, &quot;Can't parse memtable_factory option &quot;,</a>
<a name="ln1196">                                     opts_str);</a>
<a name="ln1197">  }</a>
<a name="ln1198"> </a>
<a name="ln1199">  MemTableRepFactory* mem_factory = nullptr;</a>
<a name="ln1200"> </a>
<a name="ln1201">  if (opts_list[0] == &quot;skip_list&quot;) {</a>
<a name="ln1202">    // Expecting format</a>
<a name="ln1203">    // skip_list:&lt;lookahead&gt;</a>
<a name="ln1204">    if (2 == len) {</a>
<a name="ln1205">      size_t lookahead = ParseSizeT(opts_list[1]);</a>
<a name="ln1206">      mem_factory = new SkipListFactory(lookahead);</a>
<a name="ln1207">    } else if (1 == len) {</a>
<a name="ln1208">      mem_factory = new SkipListFactory();</a>
<a name="ln1209">    }</a>
<a name="ln1210">  } else if (opts_list[0] == &quot;prefix_hash&quot;) {</a>
<a name="ln1211">    // Expecting format</a>
<a name="ln1212">    // prfix_hash:&lt;hash_bucket_count&gt;</a>
<a name="ln1213">    if (2 == len) {</a>
<a name="ln1214">      size_t hash_bucket_count = ParseSizeT(opts_list[1]);</a>
<a name="ln1215">      mem_factory = NewHashSkipListRepFactory(hash_bucket_count);</a>
<a name="ln1216">    } else if (1 == len) {</a>
<a name="ln1217">      mem_factory = NewHashSkipListRepFactory();</a>
<a name="ln1218">    }</a>
<a name="ln1219">  } else if (opts_list[0] == &quot;hash_linkedlist&quot;) {</a>
<a name="ln1220">    // Expecting format</a>
<a name="ln1221">    // hash_linkedlist:&lt;hash_bucket_count&gt;</a>
<a name="ln1222">    if (2 == len) {</a>
<a name="ln1223">      size_t hash_bucket_count = ParseSizeT(opts_list[1]);</a>
<a name="ln1224">      mem_factory = NewHashLinkListRepFactory(hash_bucket_count);</a>
<a name="ln1225">    } else if (1 == len) {</a>
<a name="ln1226">      mem_factory = NewHashLinkListRepFactory();</a>
<a name="ln1227">    }</a>
<a name="ln1228">  } else if (opts_list[0] == &quot;vector&quot;) {</a>
<a name="ln1229">    // Expecting format</a>
<a name="ln1230">    // vector:&lt;count&gt;</a>
<a name="ln1231">    if (2 == len) {</a>
<a name="ln1232">      size_t count = ParseSizeT(opts_list[1]);</a>
<a name="ln1233">      mem_factory = new VectorRepFactory(count);</a>
<a name="ln1234">    } else if (1 == len) {</a>
<a name="ln1235">      mem_factory = new VectorRepFactory();</a>
<a name="ln1236">    }</a>
<a name="ln1237">  } else {</a>
<a name="ln1238">    return STATUS(InvalidArgument, &quot;Unrecognized memtable_factory option &quot;,</a>
<a name="ln1239">                                   opts_str);</a>
<a name="ln1240">  }</a>
<a name="ln1241"> </a>
<a name="ln1242">  if (mem_factory != nullptr) {</a>
<a name="ln1243">    new_mem_factory-&gt;reset(mem_factory);</a>
<a name="ln1244">  }</a>
<a name="ln1245"> </a>
<a name="ln1246">  return Status::OK();</a>
<a name="ln1247">}</a>
<a name="ln1248"> </a>
<a name="ln1249">Status GetColumnFamilyOptionsFromMap(</a>
<a name="ln1250">    const ColumnFamilyOptions&amp; base_options,</a>
<a name="ln1251">    const std::unordered_map&lt;std::string, std::string&gt;&amp; opts_map,</a>
<a name="ln1252">    ColumnFamilyOptions* new_options, bool input_strings_escaped) {</a>
<a name="ln1253">  return GetColumnFamilyOptionsFromMapInternal(</a>
<a name="ln1254">      base_options, opts_map, new_options, input_strings_escaped);</a>
<a name="ln1255">}</a>
<a name="ln1256"> </a>
<a name="ln1257">Status GetColumnFamilyOptionsFromMapInternal(</a>
<a name="ln1258">    const ColumnFamilyOptions&amp; base_options,</a>
<a name="ln1259">    const std::unordered_map&lt;std::string, std::string&gt;&amp; opts_map,</a>
<a name="ln1260">    ColumnFamilyOptions* new_options, bool input_strings_escaped,</a>
<a name="ln1261">    std::vector&lt;std::string&gt;* unsupported_options_names) {</a>
<a name="ln1262">  assert(new_options);</a>
<a name="ln1263">  *new_options = base_options;</a>
<a name="ln1264">  if (unsupported_options_names) {</a>
<a name="ln1265">    unsupported_options_names-&gt;clear();</a>
<a name="ln1266">  }</a>
<a name="ln1267">  for (const auto&amp; o : opts_map) {</a>
<a name="ln1268">    auto s = ParseColumnFamilyOption(o.first, o.second, new_options,</a>
<a name="ln1269">                                 input_strings_escaped);</a>
<a name="ln1270">    if (!s.ok()) {</a>
<a name="ln1271">      if (s.IsNotSupported()) {</a>
<a name="ln1272">        // If the deserialization of the specified option is not supported</a>
<a name="ln1273">        // and an output vector of unsupported_options is provided, then</a>
<a name="ln1274">        // we log the name of the unsupported option and proceed.</a>
<a name="ln1275">        if (unsupported_options_names != nullptr) {</a>
<a name="ln1276">          unsupported_options_names-&gt;push_back(o.first);</a>
<a name="ln1277">        }</a>
<a name="ln1278">        // Note that we still return Status::OK in such case to maintain</a>
<a name="ln1279">        // the backward compatibility in the old public API defined in</a>
<a name="ln1280">        // rocksdb/convenience.h</a>
<a name="ln1281">      } else {</a>
<a name="ln1282">        return s;</a>
<a name="ln1283">      }</a>
<a name="ln1284">    }</a>
<a name="ln1285">  }</a>
<a name="ln1286">  return Status::OK();</a>
<a name="ln1287">}</a>
<a name="ln1288"> </a>
<a name="ln1289">Status GetColumnFamilyOptionsFromString(</a>
<a name="ln1290">    const ColumnFamilyOptions&amp; base_options,</a>
<a name="ln1291">    const std::string&amp; opts_str,</a>
<a name="ln1292">    ColumnFamilyOptions* new_options) {</a>
<a name="ln1293">  std::unordered_map&lt;std::string, std::string&gt; opts_map;</a>
<a name="ln1294">  Status s = StringToMap(opts_str, &amp;opts_map);</a>
<a name="ln1295">  if (!s.ok()) {</a>
<a name="ln1296">    return s;</a>
<a name="ln1297">  }</a>
<a name="ln1298">  return GetColumnFamilyOptionsFromMap(base_options, opts_map, new_options);</a>
<a name="ln1299">}</a>
<a name="ln1300"> </a>
<a name="ln1301">Status GetDBOptionsFromMap(</a>
<a name="ln1302">    const DBOptions&amp; base_options,</a>
<a name="ln1303">    const std::unordered_map&lt;std::string, std::string&gt;&amp; opts_map,</a>
<a name="ln1304">    DBOptions* new_options, bool input_strings_escaped) {</a>
<a name="ln1305">  return GetDBOptionsFromMapInternal(</a>
<a name="ln1306">      base_options, opts_map, new_options, input_strings_escaped);</a>
<a name="ln1307">}</a>
<a name="ln1308"> </a>
<a name="ln1309">Status GetDBOptionsFromMapInternal(</a>
<a name="ln1310">    const DBOptions&amp; base_options,</a>
<a name="ln1311">    const std::unordered_map&lt;std::string, std::string&gt;&amp; opts_map,</a>
<a name="ln1312">    DBOptions* new_options, bool input_strings_escaped,</a>
<a name="ln1313">    std::vector&lt;std::string&gt;* unsupported_options_names) {</a>
<a name="ln1314">  assert(new_options);</a>
<a name="ln1315">  *new_options = base_options;</a>
<a name="ln1316">  if (unsupported_options_names) {</a>
<a name="ln1317">    unsupported_options_names-&gt;clear();</a>
<a name="ln1318">  }</a>
<a name="ln1319">  for (const auto&amp; o : opts_map) {</a>
<a name="ln1320">    auto s = ParseDBOption(o.first, o.second,</a>
<a name="ln1321">                           new_options, input_strings_escaped);</a>
<a name="ln1322">    if (!s.ok()) {</a>
<a name="ln1323">      if (s.IsNotSupported()) {</a>
<a name="ln1324">        // If the deserialization of the specified option is not supported</a>
<a name="ln1325">        // and an output vector of unsupported_options is provided, then</a>
<a name="ln1326">        // we log the name of the unsupported option and proceed.</a>
<a name="ln1327">        if (unsupported_options_names != nullptr) {</a>
<a name="ln1328">          unsupported_options_names-&gt;push_back(o.first);</a>
<a name="ln1329">        }</a>
<a name="ln1330">        // Note that we still return Status::OK in such case to maintain</a>
<a name="ln1331">        // the backward compatibility in the old public API defined in</a>
<a name="ln1332">        // rocksdb/convenience.h</a>
<a name="ln1333">      } else {</a>
<a name="ln1334">        return s;</a>
<a name="ln1335">      }</a>
<a name="ln1336">    }</a>
<a name="ln1337">  }</a>
<a name="ln1338">  return Status::OK();</a>
<a name="ln1339">}</a>
<a name="ln1340"> </a>
<a name="ln1341">Status GetDBOptionsFromString(</a>
<a name="ln1342">    const DBOptions&amp; base_options,</a>
<a name="ln1343">    const std::string&amp; opts_str,</a>
<a name="ln1344">    DBOptions* new_options) {</a>
<a name="ln1345">  std::unordered_map&lt;std::string, std::string&gt; opts_map;</a>
<a name="ln1346">  Status s = StringToMap(opts_str, &amp;opts_map);</a>
<a name="ln1347">  if (!s.ok()) {</a>
<a name="ln1348">    return s;</a>
<a name="ln1349">  }</a>
<a name="ln1350">  return GetDBOptionsFromMap(base_options, opts_map, new_options);</a>
<a name="ln1351">}</a>
<a name="ln1352"> </a>
<a name="ln1353">Status GetOptionsFromString(const Options&amp; base_options,</a>
<a name="ln1354">                            const std::string&amp; opts_str, Options* new_options) {</a>
<a name="ln1355">  std::unordered_map&lt;std::string, std::string&gt; opts_map;</a>
<a name="ln1356">  Status s = StringToMap(opts_str, &amp;opts_map);</a>
<a name="ln1357">  if (!s.ok()) {</a>
<a name="ln1358">    return s;</a>
<a name="ln1359">  }</a>
<a name="ln1360">  DBOptions new_db_options(base_options);</a>
<a name="ln1361">  ColumnFamilyOptions new_cf_options(base_options);</a>
<a name="ln1362">  for (const auto&amp; o : opts_map) {</a>
<a name="ln1363">    if (ParseDBOption(o.first, o.second, &amp;new_db_options).ok()) {</a>
<a name="ln1364">    } else if (ParseColumnFamilyOption(</a>
<a name="ln1365">        o.first, o.second, &amp;new_cf_options).ok()) {</a>
<a name="ln1366">    } else {</a>
<a name="ln1367">      return STATUS(InvalidArgument, &quot;Can't parse option &quot; + o.first);</a>
<a name="ln1368">    }</a>
<a name="ln1369">  }</a>
<a name="ln1370">  *new_options = Options(new_db_options, new_cf_options);</a>
<a name="ln1371">  return Status::OK();</a>
<a name="ln1372">}</a>
<a name="ln1373"> </a>
<a name="ln1374">Status GetTableFactoryFromMap(</a>
<a name="ln1375">    const std::string&amp; factory_name,</a>
<a name="ln1376">    const std::unordered_map&lt;std::string, std::string&gt;&amp; opt_map,</a>
<a name="ln1377">    std::shared_ptr&lt;TableFactory&gt;* table_factory) {</a>
<a name="ln1378">  Status s;</a>
<a name="ln1379">  if (factory_name == BlockBasedTableFactory().Name()) {</a>
<a name="ln1380">    BlockBasedTableOptions bbt_opt;</a>
<a name="ln1381">    s = GetBlockBasedTableOptionsFromMap(BlockBasedTableOptions(), opt_map,</a>
<a name="ln1382">                                         &amp;bbt_opt, true);</a>
<a name="ln1383">    if (!s.ok()) {</a>
<a name="ln1384">      return s;</a>
<a name="ln1385">    }</a>
<a name="ln1386">    table_factory-&gt;reset(new BlockBasedTableFactory(bbt_opt));</a>
<a name="ln1387">    return Status::OK();</a>
<a name="ln1388">  } else if (factory_name == PlainTableFactory().Name()) {</a>
<a name="ln1389">    PlainTableOptions pt_opt;</a>
<a name="ln1390">    s = GetPlainTableOptionsFromMap(PlainTableOptions(), opt_map, &amp;pt_opt,</a>
<a name="ln1391">                                    true);</a>
<a name="ln1392">    if (!s.ok()) {</a>
<a name="ln1393">      return s;</a>
<a name="ln1394">    }</a>
<a name="ln1395">    table_factory-&gt;reset(new PlainTableFactory(pt_opt));</a>
<a name="ln1396">    return Status::OK();</a>
<a name="ln1397">  }</a>
<a name="ln1398">  // Return OK for not supported table factories as TableFactory</a>
<a name="ln1399">  // Deserialization is optional.</a>
<a name="ln1400">  table_factory-&gt;reset();</a>
<a name="ln1401">  return Status::OK();</a>
<a name="ln1402">}</a>
<a name="ln1403"> </a>
<a name="ln1404">ColumnFamilyOptions BuildColumnFamilyOptions(</a>
<a name="ln1405">    const Options&amp; options, const MutableCFOptions&amp; mutable_cf_options) {</a>
<a name="ln1406">  ColumnFamilyOptions cf_opts(options);</a>
<a name="ln1407"> </a>
<a name="ln1408">  // Memtable related options</a>
<a name="ln1409">  cf_opts.write_buffer_size = mutable_cf_options.write_buffer_size;</a>
<a name="ln1410">  cf_opts.max_write_buffer_number = mutable_cf_options.max_write_buffer_number;</a>
<a name="ln1411">  cf_opts.arena_block_size = mutable_cf_options.arena_block_size;</a>
<a name="ln1412">  cf_opts.memtable_prefix_bloom_bits =</a>
<a name="ln1413">      mutable_cf_options.memtable_prefix_bloom_bits;</a>
<a name="ln1414">  cf_opts.memtable_prefix_bloom_probes =</a>
<a name="ln1415">      mutable_cf_options.memtable_prefix_bloom_probes;</a>
<a name="ln1416">  cf_opts.memtable_prefix_bloom_huge_page_tlb_size =</a>
<a name="ln1417">      mutable_cf_options.memtable_prefix_bloom_huge_page_tlb_size;</a>
<a name="ln1418">  cf_opts.max_successive_merges = mutable_cf_options.max_successive_merges;</a>
<a name="ln1419">  cf_opts.filter_deletes = mutable_cf_options.filter_deletes;</a>
<a name="ln1420">  cf_opts.inplace_update_num_locks =</a>
<a name="ln1421">      mutable_cf_options.inplace_update_num_locks;</a>
<a name="ln1422"> </a>
<a name="ln1423">  // Compaction related options</a>
<a name="ln1424">  cf_opts.disable_auto_compactions =</a>
<a name="ln1425">      mutable_cf_options.disable_auto_compactions;</a>
<a name="ln1426">  cf_opts.level0_file_num_compaction_trigger =</a>
<a name="ln1427">      mutable_cf_options.level0_file_num_compaction_trigger;</a>
<a name="ln1428">  cf_opts.level0_slowdown_writes_trigger =</a>
<a name="ln1429">      mutable_cf_options.level0_slowdown_writes_trigger;</a>
<a name="ln1430">  cf_opts.level0_stop_writes_trigger =</a>
<a name="ln1431">      mutable_cf_options.level0_stop_writes_trigger;</a>
<a name="ln1432">  cf_opts.max_grandparent_overlap_factor =</a>
<a name="ln1433">      mutable_cf_options.max_grandparent_overlap_factor;</a>
<a name="ln1434">  cf_opts.expanded_compaction_factor =</a>
<a name="ln1435">      mutable_cf_options.expanded_compaction_factor;</a>
<a name="ln1436">  cf_opts.source_compaction_factor =</a>
<a name="ln1437">      mutable_cf_options.source_compaction_factor;</a>
<a name="ln1438">  cf_opts.target_file_size_base = mutable_cf_options.target_file_size_base;</a>
<a name="ln1439">  cf_opts.target_file_size_multiplier =</a>
<a name="ln1440">      mutable_cf_options.target_file_size_multiplier;</a>
<a name="ln1441">  cf_opts.max_bytes_for_level_base =</a>
<a name="ln1442">      mutable_cf_options.max_bytes_for_level_base;</a>
<a name="ln1443">  cf_opts.max_bytes_for_level_multiplier =</a>
<a name="ln1444">      mutable_cf_options.max_bytes_for_level_multiplier;</a>
<a name="ln1445"> </a>
<a name="ln1446">  cf_opts.max_bytes_for_level_multiplier_additional.clear();</a>
<a name="ln1447">  for (auto value :</a>
<a name="ln1448">       mutable_cf_options.max_bytes_for_level_multiplier_additional) {</a>
<a name="ln1449">    cf_opts.max_bytes_for_level_multiplier_additional.emplace_back(value);</a>
<a name="ln1450">  }</a>
<a name="ln1451"> </a>
<a name="ln1452">  cf_opts.verify_checksums_in_compaction =</a>
<a name="ln1453">      mutable_cf_options.verify_checksums_in_compaction;</a>
<a name="ln1454"> </a>
<a name="ln1455">  // Misc options</a>
<a name="ln1456">  cf_opts.max_sequential_skip_in_iterations =</a>
<a name="ln1457">      mutable_cf_options.max_sequential_skip_in_iterations;</a>
<a name="ln1458">  cf_opts.paranoid_file_checks = mutable_cf_options.paranoid_file_checks;</a>
<a name="ln1459">  cf_opts.compaction_measure_io_stats =</a>
<a name="ln1460">      mutable_cf_options.compaction_measure_io_stats;</a>
<a name="ln1461"> </a>
<a name="ln1462">  cf_opts.table_factory = options.table_factory;</a>
<a name="ln1463">  // TODO(yhchiang): find some way to handle the following derived options</a>
<a name="ln1464">  // * max_file_size</a>
<a name="ln1465"> </a>
<a name="ln1466">  return cf_opts;</a>
<a name="ln1467">}</a>
<a name="ln1468"> </a>
<a name="ln1469">#endif  // !ROCKSDB_LITE</a>
<a name="ln1470">}  // namespace rocksdb</a>

</code></pre>
<div class="balloon" rel="112"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v781/" target="_blank">V781</a> The value of the 'start' index is checked after it was used. Perhaps there is a mistake in program logic.</p></div>
<div class="balloon" rel="115"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v781/" target="_blank">V781</a> The value of the 'end' index is checked after it was used. Perhaps there is a mistake in program logic.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
