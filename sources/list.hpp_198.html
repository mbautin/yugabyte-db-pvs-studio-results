
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>list.hpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/////////////////////////////////////////////////////////////////////////////</a>
<a name="ln2">//</a>
<a name="ln3">// (C) Copyright Olaf Krzikalla 2004-2006.</a>
<a name="ln4">// (C) Copyright Ion Gaztanaga  2006-2014</a>
<a name="ln5">//</a>
<a name="ln6">// Distributed under the Boost Software License, Version 1.0.</a>
<a name="ln7">//    (See accompanying file LICENSE_1_0.txt or copy at</a>
<a name="ln8">//          http://www.boost.org/LICENSE_1_0.txt)</a>
<a name="ln9">//</a>
<a name="ln10">// See http://www.boost.org/libs/intrusive for documentation.</a>
<a name="ln11">//</a>
<a name="ln12">/////////////////////////////////////////////////////////////////////////////</a>
<a name="ln13"> </a>
<a name="ln14">#ifndef BOOST_INTRUSIVE_LIST_HPP</a>
<a name="ln15">#define BOOST_INTRUSIVE_LIST_HPP</a>
<a name="ln16"> </a>
<a name="ln17">#include &lt;boost/intrusive/detail/config_begin.hpp&gt;</a>
<a name="ln18">#include &lt;boost/intrusive/intrusive_fwd.hpp&gt;</a>
<a name="ln19">#include &lt;boost/intrusive/detail/assert.hpp&gt;</a>
<a name="ln20">#include &lt;boost/intrusive/list_hook.hpp&gt;</a>
<a name="ln21">#include &lt;boost/intrusive/circular_list_algorithms.hpp&gt;</a>
<a name="ln22">#include &lt;boost/intrusive/pointer_traits.hpp&gt;</a>
<a name="ln23">#include &lt;boost/intrusive/detail/mpl.hpp&gt;</a>
<a name="ln24">#include &lt;boost/intrusive/link_mode.hpp&gt;</a>
<a name="ln25">#include &lt;boost/intrusive/detail/get_value_traits.hpp&gt;</a>
<a name="ln26">#include &lt;boost/intrusive/detail/is_stateful_value_traits.hpp&gt;</a>
<a name="ln27">#include &lt;boost/intrusive/detail/default_header_holder.hpp&gt;</a>
<a name="ln28">#include &lt;boost/intrusive/detail/reverse_iterator.hpp&gt;</a>
<a name="ln29">#include &lt;boost/intrusive/detail/uncast.hpp&gt;</a>
<a name="ln30">#include &lt;boost/intrusive/detail/list_iterator.hpp&gt;</a>
<a name="ln31">#include &lt;boost/intrusive/detail/array_initializer.hpp&gt;</a>
<a name="ln32">#include &lt;boost/intrusive/detail/exception_disposer.hpp&gt;</a>
<a name="ln33">#include &lt;boost/intrusive/detail/equal_to_value.hpp&gt;</a>
<a name="ln34">#include &lt;boost/intrusive/detail/key_nodeptr_comp.hpp&gt;</a>
<a name="ln35">#include &lt;boost/intrusive/detail/simple_disposers.hpp&gt;</a>
<a name="ln36">#include &lt;boost/intrusive/detail/size_holder.hpp&gt;</a>
<a name="ln37">#include &lt;boost/intrusive/detail/algorithm.hpp&gt;</a>
<a name="ln38"> </a>
<a name="ln39">#include &lt;boost/move/utility_core.hpp&gt;</a>
<a name="ln40">#include &lt;boost/static_assert.hpp&gt;</a>
<a name="ln41"> </a>
<a name="ln42">#include &lt;boost/intrusive/detail/minimal_less_equal_header.hpp&gt;//std::less</a>
<a name="ln43">#include &lt;cstddef&gt;   //std::size_t, etc.</a>
<a name="ln44"> </a>
<a name="ln45">#if defined(BOOST_HAS_PRAGMA_ONCE)</a>
<a name="ln46">#  pragma once</a>
<a name="ln47">#endif</a>
<a name="ln48"> </a>
<a name="ln49">namespace boost {</a>
<a name="ln50">namespace intrusive {</a>
<a name="ln51"> </a>
<a name="ln52">/// @cond</a>
<a name="ln53"> </a>
<a name="ln54">struct default_list_hook_applier</a>
<a name="ln55">{  template &lt;class T&gt; struct apply{ typedef typename T::default_list_hook type;  };  };</a>
<a name="ln56"> </a>
<a name="ln57">template&lt;&gt;</a>
<a name="ln58">struct is_default_hook_tag&lt;default_list_hook_applier&gt;</a>
<a name="ln59">{  static const bool value = true;  };</a>
<a name="ln60"> </a>
<a name="ln61">struct list_defaults</a>
<a name="ln62">{</a>
<a name="ln63">   typedef default_list_hook_applier proto_value_traits;</a>
<a name="ln64">   static const bool constant_time_size = true;</a>
<a name="ln65">   typedef std::size_t size_type;</a>
<a name="ln66">   typedef void header_holder_type;</a>
<a name="ln67">};</a>
<a name="ln68"> </a>
<a name="ln69">/// @endcond</a>
<a name="ln70"> </a>
<a name="ln71">//! The class template list is an intrusive container that mimics most of the</a>
<a name="ln72">//! interface of std::list as described in the C++ standard.</a>
<a name="ln73">//!</a>
<a name="ln74">//! The template parameter \c T is the type to be managed by the container.</a>
<a name="ln75">//! The user can specify additional options and if no options are provided</a>
<a name="ln76">//! default options are used.</a>
<a name="ln77">//!</a>
<a name="ln78">//! The container supports the following options:</a>
<a name="ln79">//! \c base_hook&lt;&gt;/member_hook&lt;&gt;/value_traits&lt;&gt;,</a>
<a name="ln80">//! \c constant_time_size&lt;&gt; and \c size_type&lt;&gt;.</a>
<a name="ln81">#if defined(BOOST_INTRUSIVE_DOXYGEN_INVOKED)</a>
<a name="ln82">template&lt;class T, class ...Options&gt;</a>
<a name="ln83">#else</a>
<a name="ln84">template &lt;class ValueTraits, class SizeType, bool ConstantTimeSize, typename HeaderHolder&gt;</a>
<a name="ln85">#endif</a>
<a name="ln86">class list_impl</a>
<a name="ln87">{</a>
<a name="ln88">   //Public typedefs</a>
<a name="ln89">   public:</a>
<a name="ln90">   typedef ValueTraits                                               value_traits;</a>
<a name="ln91">   typedef typename value_traits::pointer                            pointer;</a>
<a name="ln92">   typedef typename value_traits::const_pointer                      const_pointer;</a>
<a name="ln93">   typedef typename pointer_traits&lt;pointer&gt;::element_type            value_type;</a>
<a name="ln94">   typedef typename pointer_traits&lt;pointer&gt;::reference               reference;</a>
<a name="ln95">   typedef typename pointer_traits&lt;const_pointer&gt;::reference         const_reference;</a>
<a name="ln96">   typedef typename pointer_traits&lt;pointer&gt;::difference_type         difference_type;</a>
<a name="ln97">   typedef SizeType                                                  size_type;</a>
<a name="ln98">   typedef list_iterator&lt;value_traits, false&gt;                        iterator;</a>
<a name="ln99">   typedef list_iterator&lt;value_traits, true&gt;                         const_iterator;</a>
<a name="ln100">   typedef boost::intrusive::reverse_iterator&lt;iterator&gt;              reverse_iterator;</a>
<a name="ln101">   typedef boost::intrusive::reverse_iterator&lt;const_iterator&gt;        const_reverse_iterator;</a>
<a name="ln102">   typedef typename value_traits::node_traits                        node_traits;</a>
<a name="ln103">   typedef typename node_traits::node                                node;</a>
<a name="ln104">   typedef typename node_traits::node_ptr                            node_ptr;</a>
<a name="ln105">   typedef typename node_traits::const_node_ptr                      const_node_ptr;</a>
<a name="ln106">   typedef circular_list_algorithms&lt;node_traits&gt;                     node_algorithms;</a>
<a name="ln107">   typedef typename detail::get_header_holder_type</a>
<a name="ln108">      &lt; value_traits, HeaderHolder &gt;::type                           header_holder_type;</a>
<a name="ln109"> </a>
<a name="ln110">   static const bool constant_time_size = ConstantTimeSize;</a>
<a name="ln111">   static const bool stateful_value_traits = detail::is_stateful_value_traits&lt;value_traits&gt;::value;</a>
<a name="ln112">   static const bool has_container_from_iterator =</a>
<a name="ln113">        detail::is_same&lt; header_holder_type, detail::default_header_holder&lt; node_traits &gt; &gt;::value;</a>
<a name="ln114"> </a>
<a name="ln115">   /// @cond</a>
<a name="ln116"> </a>
<a name="ln117">   private:</a>
<a name="ln118">   typedef detail::size_holder&lt;constant_time_size, size_type&gt;          size_traits;</a>
<a name="ln119"> </a>
<a name="ln120">   //noncopyable</a>
<a name="ln121">   BOOST_MOVABLE_BUT_NOT_COPYABLE(list_impl)</a>
<a name="ln122"> </a>
<a name="ln123">   static const bool safemode_or_autounlink = is_safe_autounlink&lt;value_traits::link_mode&gt;::value;</a>
<a name="ln124"> </a>
<a name="ln125">   //Constant-time size is incompatible with auto-unlink hooks!</a>
<a name="ln126">   BOOST_STATIC_ASSERT(!(constant_time_size &amp;&amp;</a>
<a name="ln127">                        ((int)value_traits::link_mode == (int)auto_unlink)</a>
<a name="ln128">                      ));</a>
<a name="ln129"> </a>
<a name="ln130">   node_ptr get_root_node()</a>
<a name="ln131">   { return data_.root_plus_size_.m_header.get_node(); }</a>
<a name="ln132"> </a>
<a name="ln133">   const_node_ptr get_root_node() const</a>
<a name="ln134">   { return data_.root_plus_size_.m_header.get_node(); }</a>
<a name="ln135"> </a>
<a name="ln136">   struct root_plus_size : public size_traits</a>
<a name="ln137">   {</a>
<a name="ln138">      header_holder_type m_header;</a>
<a name="ln139">   };</a>
<a name="ln140"> </a>
<a name="ln141">   struct data_t : public value_traits</a>
<a name="ln142">   {</a>
<a name="ln143">      typedef typename list_impl::value_traits value_traits;</a>
<a name="ln144">      explicit data_t(const value_traits &amp;val_traits)</a>
<a name="ln145">         :  value_traits(val_traits)</a>
<a name="ln146">      {}</a>
<a name="ln147"> </a>
<a name="ln148">      root_plus_size root_plus_size_;</a>
<a name="ln149">   } data_;</a>
<a name="ln150"> </a>
<a name="ln151">   size_traits &amp;priv_size_traits()</a>
<a name="ln152">   {  return data_.root_plus_size_;  }</a>
<a name="ln153"> </a>
<a name="ln154">   const size_traits &amp;priv_size_traits() const</a>
<a name="ln155">   {  return data_.root_plus_size_;  }</a>
<a name="ln156"> </a>
<a name="ln157">   const value_traits &amp;priv_value_traits() const</a>
<a name="ln158">   {  return data_;  }</a>
<a name="ln159"> </a>
<a name="ln160">   value_traits &amp;priv_value_traits()</a>
<a name="ln161">   {  return data_;  }</a>
<a name="ln162"> </a>
<a name="ln163">   typedef typename boost::intrusive::value_traits_pointers</a>
<a name="ln164">      &lt;ValueTraits&gt;::const_value_traits_ptr const_value_traits_ptr;</a>
<a name="ln165"> </a>
<a name="ln166">   const_value_traits_ptr priv_value_traits_ptr() const</a>
<a name="ln167">   {  return pointer_traits&lt;const_value_traits_ptr&gt;::pointer_to(this-&gt;priv_value_traits());  }</a>
<a name="ln168"> </a>
<a name="ln169">   /// @endcond</a>
<a name="ln170"> </a>
<a name="ln171">   public:</a>
<a name="ln172"> </a>
<a name="ln173">   //! &lt;b&gt;Effects&lt;/b&gt;: constructs an empty list.</a>
<a name="ln174">   //!</a>
<a name="ln175">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant</a>
<a name="ln176">   //!</a>
<a name="ln177">   //! &lt;b&gt;Throws&lt;/b&gt;: If value_traits::node_traits::node</a>
<a name="ln178">   //!   constructor throws (this does not happen with predefined Boost.Intrusive hooks).</a>
<a name="ln179">   list_impl()</a>
<a name="ln180">      :  data_(value_traits())</a>
<a name="ln181">   {</a>
<a name="ln182">      this-&gt;priv_size_traits().set_size(size_type(0));</a>
<a name="ln183">      node_algorithms::init_header(this-&gt;get_root_node());</a>
<a name="ln184">   }</a>
<a name="ln185"> </a>
<a name="ln186">   //! &lt;b&gt;Effects&lt;/b&gt;: constructs an empty list.</a>
<a name="ln187">   //!</a>
<a name="ln188">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant</a>
<a name="ln189">   //!</a>
<a name="ln190">   //! &lt;b&gt;Throws&lt;/b&gt;: If value_traits::node_traits::node</a>
<a name="ln191">   //!   constructor throws (this does not happen with predefined Boost.Intrusive hooks).</a>
<a name="ln192">   explicit list_impl(const value_traits &amp;v_traits)</a>
<a name="ln193">      :  data_(v_traits)</a>
<a name="ln194">   {</a>
<a name="ln195">      this-&gt;priv_size_traits().set_size(size_type(0));</a>
<a name="ln196">      node_algorithms::init_header(this-&gt;get_root_node());</a>
<a name="ln197">   }</a>
<a name="ln198"> </a>
<a name="ln199">   //! &lt;b&gt;Requires&lt;/b&gt;: Dereferencing iterator must yield an lvalue of type value_type.</a>
<a name="ln200">   //!</a>
<a name="ln201">   //! &lt;b&gt;Effects&lt;/b&gt;: Constructs a list equal to the range [first,last).</a>
<a name="ln202">   //!</a>
<a name="ln203">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear in distance(b, e). No copy constructors are called.</a>
<a name="ln204">   //!</a>
<a name="ln205">   //! &lt;b&gt;Throws&lt;/b&gt;: If value_traits::node_traits::node</a>
<a name="ln206">   //!   constructor throws (this does not happen with predefined Boost.Intrusive hooks).</a>
<a name="ln207">   template&lt;class Iterator&gt;</a>
<a name="ln208">   list_impl(Iterator b, Iterator e, const value_traits &amp;v_traits = value_traits())</a>
<a name="ln209">      :  data_(v_traits)</a>
<a name="ln210">   {</a>
<a name="ln211">      //nothrow, no need to rollback to release elements on exception</a>
<a name="ln212">      this-&gt;priv_size_traits().set_size(size_type(0));</a>
<a name="ln213">      node_algorithms::init_header(this-&gt;get_root_node());</a>
<a name="ln214">      //nothrow, no need to rollback to release elements on exception</a>
<a name="ln215">      this-&gt;insert(this-&gt;cend(), b, e);</a>
<a name="ln216">   }</a>
<a name="ln217"> </a>
<a name="ln218">   //! &lt;b&gt;Effects&lt;/b&gt;: Constructs a container moving resources from another container.</a>
<a name="ln219">   //!   Internal value traits are move constructed and</a>
<a name="ln220">   //!   nodes belonging to x (except the node representing the &quot;end&quot;) are linked to *this.</a>
<a name="ln221">   //!</a>
<a name="ln222">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln223">   //!</a>
<a name="ln224">   //! &lt;b&gt;Throws&lt;/b&gt;: If value_traits::node_traits::node's</a>
<a name="ln225">   //!   move constructor throws (this does not happen with predefined Boost.Intrusive hooks)</a>
<a name="ln226">   //!   or the move constructor of value traits throws.</a>
<a name="ln227">   list_impl(BOOST_RV_REF(list_impl) x)</a>
<a name="ln228">      : data_(::boost::move(x.priv_value_traits()))</a>
<a name="ln229">   {</a>
<a name="ln230">      this-&gt;priv_size_traits().set_size(size_type(0));</a>
<a name="ln231">      node_algorithms::init_header(this-&gt;get_root_node());</a>
<a name="ln232">      //nothrow, no need to rollback to release elements on exception</a>
<a name="ln233">      this-&gt;swap(x);</a>
<a name="ln234">   }</a>
<a name="ln235"> </a>
<a name="ln236">   //! &lt;b&gt;Effects&lt;/b&gt;: Equivalent to swap</a>
<a name="ln237">   //!</a>
<a name="ln238">   list_impl&amp; operator=(BOOST_RV_REF(list_impl) x)</a>
<a name="ln239">   {  this-&gt;swap(x); return *this;  }</a>
<a name="ln240"> </a>
<a name="ln241">   //! &lt;b&gt;Effects&lt;/b&gt;: If it's not a safe-mode or an auto-unlink value_type</a>
<a name="ln242">   //!   the destructor does nothing</a>
<a name="ln243">   //!   (ie. no code is generated). Otherwise it detaches all elements from this.</a>
<a name="ln244">   //!   In this case the objects in the list are not deleted (i.e. no destructors</a>
<a name="ln245">   //!   are called), but the hooks according to the ValueTraits template parameter</a>
<a name="ln246">   //!   are set to their default value.</a>
<a name="ln247">   //!</a>
<a name="ln248">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear to the number of elements in the list, if</a>
<a name="ln249">   //!   it's a safe-mode or auto-unlink value . Otherwise constant.</a>
<a name="ln250">   ~list_impl()</a>
<a name="ln251">   {</a>
<a name="ln252">      if(is_safe_autounlink&lt;ValueTraits::link_mode&gt;::value){</a>
<a name="ln253">         this-&gt;clear();</a>
<a name="ln254">         node_algorithms::init(this-&gt;get_root_node());</a>
<a name="ln255">      }</a>
<a name="ln256">   }</a>
<a name="ln257"> </a>
<a name="ln258">   //! &lt;b&gt;Requires&lt;/b&gt;: value must be an lvalue.</a>
<a name="ln259">   //!</a>
<a name="ln260">   //! &lt;b&gt;Effects&lt;/b&gt;: Inserts the value in the back of the list.</a>
<a name="ln261">   //!   No copy constructors are called.</a>
<a name="ln262">   //!</a>
<a name="ln263">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln264">   //!</a>
<a name="ln265">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln266">   //!</a>
<a name="ln267">   //! &lt;b&gt;Note&lt;/b&gt;: Does not affect the validity of iterators and references.</a>
<a name="ln268">   void push_back(reference value)</a>
<a name="ln269">   {</a>
<a name="ln270">      node_ptr to_insert = priv_value_traits().to_node_ptr(value);</a>
<a name="ln271">      BOOST_INTRUSIVE_SAFE_HOOK_DEFAULT_ASSERT(!safemode_or_autounlink || node_algorithms::inited(to_insert));</a>
<a name="ln272">      node_algorithms::link_before(this-&gt;get_root_node(), to_insert);</a>
<a name="ln273">      this-&gt;priv_size_traits().increment();</a>
<a name="ln274">   }</a>
<a name="ln275"> </a>
<a name="ln276">   //! &lt;b&gt;Requires&lt;/b&gt;: value must be an lvalue.</a>
<a name="ln277">   //!</a>
<a name="ln278">   //! &lt;b&gt;Effects&lt;/b&gt;: Inserts the value in the front of the list.</a>
<a name="ln279">   //!   No copy constructors are called.</a>
<a name="ln280">   //!</a>
<a name="ln281">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln282">   //!</a>
<a name="ln283">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln284">   //!</a>
<a name="ln285">   //! &lt;b&gt;Note&lt;/b&gt;: Does not affect the validity of iterators and references.</a>
<a name="ln286">   void push_front(reference value)</a>
<a name="ln287">   {</a>
<a name="ln288">      node_ptr to_insert = priv_value_traits().to_node_ptr(value);</a>
<a name="ln289">      BOOST_INTRUSIVE_SAFE_HOOK_DEFAULT_ASSERT(!safemode_or_autounlink || node_algorithms::inited(to_insert));</a>
<a name="ln290">      node_algorithms::link_before(node_traits::get_next(this-&gt;get_root_node()), to_insert);</a>
<a name="ln291">      this-&gt;priv_size_traits().increment();</a>
<a name="ln292">   }</a>
<a name="ln293"> </a>
<a name="ln294">   //! &lt;b&gt;Effects&lt;/b&gt;: Erases the last element of the list.</a>
<a name="ln295">   //!   No destructors are called.</a>
<a name="ln296">   //!</a>
<a name="ln297">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln298">   //!</a>
<a name="ln299">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln300">   //!</a>
<a name="ln301">   //! &lt;b&gt;Note&lt;/b&gt;: Invalidates the iterators (but not the references) to the erased element.</a>
<a name="ln302">   void pop_back()</a>
<a name="ln303">   {  return this-&gt;pop_back_and_dispose(detail::null_disposer());   }</a>
<a name="ln304"> </a>
<a name="ln305">   //! &lt;b&gt;Requires&lt;/b&gt;: Disposer::operator()(pointer) shouldn't throw.</a>
<a name="ln306">   //!</a>
<a name="ln307">   //! &lt;b&gt;Effects&lt;/b&gt;: Erases the last element of the list.</a>
<a name="ln308">   //!   No destructors are called.</a>
<a name="ln309">   //!   Disposer::operator()(pointer) is called for the removed element.</a>
<a name="ln310">   //!</a>
<a name="ln311">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln312">   //!</a>
<a name="ln313">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln314">   //!</a>
<a name="ln315">   //! &lt;b&gt;Note&lt;/b&gt;: Invalidates the iterators to the erased element.</a>
<a name="ln316">   template&lt;class Disposer&gt;</a>
<a name="ln317">   void pop_back_and_dispose(Disposer disposer)</a>
<a name="ln318">   {</a>
<a name="ln319">      node_ptr to_erase = node_traits::get_previous(this-&gt;get_root_node());</a>
<a name="ln320">      node_algorithms::unlink(to_erase);</a>
<a name="ln321">      this-&gt;priv_size_traits().decrement();</a>
<a name="ln322">      if(safemode_or_autounlink)</a>
<a name="ln323">         node_algorithms::init(to_erase);</a>
<a name="ln324">      disposer(priv_value_traits().to_value_ptr(to_erase));</a>
<a name="ln325">   }</a>
<a name="ln326"> </a>
<a name="ln327">   //! &lt;b&gt;Effects&lt;/b&gt;: Erases the first element of the list.</a>
<a name="ln328">   //!   No destructors are called.</a>
<a name="ln329">   //!</a>
<a name="ln330">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln331">   //!</a>
<a name="ln332">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln333">   //!</a>
<a name="ln334">   //! &lt;b&gt;Note&lt;/b&gt;: Invalidates the iterators (but not the references) to the erased element.</a>
<a name="ln335">   void pop_front()</a>
<a name="ln336">   {  return this-&gt;pop_front_and_dispose(detail::null_disposer());   }</a>
<a name="ln337"> </a>
<a name="ln338">   //! &lt;b&gt;Requires&lt;/b&gt;: Disposer::operator()(pointer) shouldn't throw.</a>
<a name="ln339">   //!</a>
<a name="ln340">   //! &lt;b&gt;Effects&lt;/b&gt;: Erases the first element of the list.</a>
<a name="ln341">   //!   No destructors are called.</a>
<a name="ln342">   //!   Disposer::operator()(pointer) is called for the removed element.</a>
<a name="ln343">   //!</a>
<a name="ln344">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln345">   //!</a>
<a name="ln346">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln347">   //!</a>
<a name="ln348">   //! &lt;b&gt;Note&lt;/b&gt;: Invalidates the iterators to the erased element.</a>
<a name="ln349">   template&lt;class Disposer&gt;</a>
<a name="ln350">   void pop_front_and_dispose(Disposer disposer)</a>
<a name="ln351">   {</a>
<a name="ln352">      node_ptr to_erase = node_traits::get_next(this-&gt;get_root_node());</a>
<a name="ln353">      node_algorithms::unlink(to_erase);</a>
<a name="ln354">      this-&gt;priv_size_traits().decrement();</a>
<a name="ln355">      if(safemode_or_autounlink)</a>
<a name="ln356">         node_algorithms::init(to_erase);</a>
<a name="ln357">      disposer(priv_value_traits().to_value_ptr(to_erase));</a>
<a name="ln358">   }</a>
<a name="ln359"> </a>
<a name="ln360">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns a reference to the first element of the list.</a>
<a name="ln361">   //!</a>
<a name="ln362">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln363">   //!</a>
<a name="ln364">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln365">   reference front()</a>
<a name="ln366">   { return *priv_value_traits().to_value_ptr(node_traits::get_next(this-&gt;get_root_node())); }</a>
<a name="ln367"> </a>
<a name="ln368">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns a const_reference to the first element of the list.</a>
<a name="ln369">   //!</a>
<a name="ln370">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln371">   //!</a>
<a name="ln372">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln373">   const_reference front() const</a>
<a name="ln374">   { return *priv_value_traits().to_value_ptr(node_traits::get_next(this-&gt;get_root_node())); }</a>
<a name="ln375"> </a>
<a name="ln376">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns a reference to the last element of the list.</a>
<a name="ln377">   //!</a>
<a name="ln378">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln379">   //!</a>
<a name="ln380">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln381">   reference back()</a>
<a name="ln382">   { return *priv_value_traits().to_value_ptr(node_traits::get_previous(this-&gt;get_root_node())); }</a>
<a name="ln383"> </a>
<a name="ln384">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns a const_reference to the last element of the list.</a>
<a name="ln385">   //!</a>
<a name="ln386">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln387">   //!</a>
<a name="ln388">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln389">   const_reference back() const</a>
<a name="ln390">   { return *priv_value_traits().to_value_ptr(detail::uncast(node_traits::get_previous(this-&gt;get_root_node()))); }</a>
<a name="ln391"> </a>
<a name="ln392">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns an iterator to the first element contained in the list.</a>
<a name="ln393">   //!</a>
<a name="ln394">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln395">   //!</a>
<a name="ln396">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln397">   iterator begin()</a>
<a name="ln398">   { return iterator(node_traits::get_next(this-&gt;get_root_node()), this-&gt;priv_value_traits_ptr()); }</a>
<a name="ln399"> </a>
<a name="ln400">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns a const_iterator to the first element contained in the list.</a>
<a name="ln401">   //!</a>
<a name="ln402">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln403">   //!</a>
<a name="ln404">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln405">   const_iterator begin() const</a>
<a name="ln406">   { return this-&gt;cbegin(); }</a>
<a name="ln407"> </a>
<a name="ln408">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns a const_iterator to the first element contained in the list.</a>
<a name="ln409">   //!</a>
<a name="ln410">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln411">   //!</a>
<a name="ln412">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln413">   const_iterator cbegin() const</a>
<a name="ln414">   { return const_iterator(node_traits::get_next(this-&gt;get_root_node()), this-&gt;priv_value_traits_ptr()); }</a>
<a name="ln415"> </a>
<a name="ln416">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns an iterator to the end of the list.</a>
<a name="ln417">   //!</a>
<a name="ln418">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln419">   //!</a>
<a name="ln420">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln421">   iterator end()</a>
<a name="ln422">   { return iterator(this-&gt;get_root_node(), this-&gt;priv_value_traits_ptr()); }</a>
<a name="ln423"> </a>
<a name="ln424">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns a const_iterator to the end of the list.</a>
<a name="ln425">   //!</a>
<a name="ln426">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln427">   //!</a>
<a name="ln428">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln429">   const_iterator end() const</a>
<a name="ln430">   { return this-&gt;cend(); }</a>
<a name="ln431"> </a>
<a name="ln432">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns a constant iterator to the end of the list.</a>
<a name="ln433">   //!</a>
<a name="ln434">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln435">   //!</a>
<a name="ln436">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln437">   const_iterator cend() const</a>
<a name="ln438">   { return const_iterator(detail::uncast(this-&gt;get_root_node()), this-&gt;priv_value_traits_ptr()); }</a>
<a name="ln439"> </a>
<a name="ln440">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns a reverse_iterator pointing to the beginning</a>
<a name="ln441">   //! of the reversed list.</a>
<a name="ln442">   //!</a>
<a name="ln443">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln444">   //!</a>
<a name="ln445">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln446">   reverse_iterator rbegin()</a>
<a name="ln447">   { return reverse_iterator(this-&gt;end()); }</a>
<a name="ln448"> </a>
<a name="ln449">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns a const_reverse_iterator pointing to the beginning</a>
<a name="ln450">   //! of the reversed list.</a>
<a name="ln451">   //!</a>
<a name="ln452">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln453">   //!</a>
<a name="ln454">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln455">   const_reverse_iterator rbegin() const</a>
<a name="ln456">   { return this-&gt;crbegin(); }</a>
<a name="ln457"> </a>
<a name="ln458">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns a const_reverse_iterator pointing to the beginning</a>
<a name="ln459">   //! of the reversed list.</a>
<a name="ln460">   //!</a>
<a name="ln461">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln462">   //!</a>
<a name="ln463">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln464">   const_reverse_iterator crbegin() const</a>
<a name="ln465">   { return const_reverse_iterator(end()); }</a>
<a name="ln466"> </a>
<a name="ln467">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns a reverse_iterator pointing to the end</a>
<a name="ln468">   //! of the reversed list.</a>
<a name="ln469">   //!</a>
<a name="ln470">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln471">   //!</a>
<a name="ln472">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln473">   reverse_iterator rend()</a>
<a name="ln474">   { return reverse_iterator(begin()); }</a>
<a name="ln475"> </a>
<a name="ln476">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns a const_reverse_iterator pointing to the end</a>
<a name="ln477">   //! of the reversed list.</a>
<a name="ln478">   //!</a>
<a name="ln479">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln480">   //!</a>
<a name="ln481">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln482">   const_reverse_iterator rend() const</a>
<a name="ln483">   { return this-&gt;crend(); }</a>
<a name="ln484"> </a>
<a name="ln485">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns a const_reverse_iterator pointing to the end</a>
<a name="ln486">   //! of the reversed list.</a>
<a name="ln487">   //!</a>
<a name="ln488">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln489">   //!</a>
<a name="ln490">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln491">   const_reverse_iterator crend() const</a>
<a name="ln492">   { return const_reverse_iterator(this-&gt;begin()); }</a>
<a name="ln493"> </a>
<a name="ln494">   //! &lt;b&gt;Precondition&lt;/b&gt;: end_iterator must be a valid end iterator</a>
<a name="ln495">   //!   of list.</a>
<a name="ln496">   //!</a>
<a name="ln497">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns a const reference to the list associated to the end iterator</a>
<a name="ln498">   //!</a>
<a name="ln499">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln500">   //!</a>
<a name="ln501">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln502">   static list_impl &amp;container_from_end_iterator(iterator end_iterator)</a>
<a name="ln503">   {  return list_impl::priv_container_from_end_iterator(end_iterator);   }</a>
<a name="ln504"> </a>
<a name="ln505">   //! &lt;b&gt;Precondition&lt;/b&gt;: end_iterator must be a valid end const_iterator</a>
<a name="ln506">   //!   of list.</a>
<a name="ln507">   //!</a>
<a name="ln508">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns a const reference to the list associated to the end iterator</a>
<a name="ln509">   //!</a>
<a name="ln510">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln511">   //!</a>
<a name="ln512">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln513">   static const list_impl &amp;container_from_end_iterator(const_iterator end_iterator)</a>
<a name="ln514">   {  return list_impl::priv_container_from_end_iterator(end_iterator);   }</a>
<a name="ln515"> </a>
<a name="ln516">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns the number of the elements contained in the list.</a>
<a name="ln517">   //!</a>
<a name="ln518">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln519">   //!</a>
<a name="ln520">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear to the number of elements contained in the list.</a>
<a name="ln521">   //!   if constant-time size option is disabled. Constant time otherwise.</a>
<a name="ln522">   //!</a>
<a name="ln523">   //! &lt;b&gt;Note&lt;/b&gt;: Does not affect the validity of iterators and references.</a>
<a name="ln524">   size_type size() const</a>
<a name="ln525">   {</a>
<a name="ln526">      if(constant_time_size)</a>
<a name="ln527">         return this-&gt;priv_size_traits().get_size();</a>
<a name="ln528">      else</a>
<a name="ln529">         return node_algorithms::count(this-&gt;get_root_node()) - 1;</a>
<a name="ln530">   }</a>
<a name="ln531"> </a>
<a name="ln532">   //! &lt;b&gt;Effects&lt;/b&gt;: Returns true if the list contains no elements.</a>
<a name="ln533">   //!</a>
<a name="ln534">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln535">   //!</a>
<a name="ln536">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln537">   //!</a>
<a name="ln538">   //! &lt;b&gt;Note&lt;/b&gt;: Does not affect the validity of iterators and references.</a>
<a name="ln539">   bool empty() const</a>
<a name="ln540">   {  return node_algorithms::unique(this-&gt;get_root_node());   }</a>
<a name="ln541"> </a>
<a name="ln542">   //! &lt;b&gt;Effects&lt;/b&gt;: Swaps the elements of x and *this.</a>
<a name="ln543">   //!</a>
<a name="ln544">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln545">   //!</a>
<a name="ln546">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln547">   //!</a>
<a name="ln548">   //! &lt;b&gt;Note&lt;/b&gt;: Does not affect the validity of iterators and references.</a>
<a name="ln549">   void swap(list_impl&amp; other)</a>
<a name="ln550">   {</a>
<a name="ln551">      node_algorithms::swap_nodes(this-&gt;get_root_node(), other.get_root_node());</a>
<a name="ln552">      this-&gt;priv_size_traits().swap(other.priv_size_traits());</a>
<a name="ln553">   }</a>
<a name="ln554"> </a>
<a name="ln555">   //! &lt;b&gt;Effects&lt;/b&gt;: Moves backwards all the elements, so that the first</a>
<a name="ln556">   //!   element becomes the second, the second becomes the third...</a>
<a name="ln557">   //!   the last element becomes the first one.</a>
<a name="ln558">   //!</a>
<a name="ln559">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln560">   //!</a>
<a name="ln561">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear to the number of shifts.</a>
<a name="ln562">   //!</a>
<a name="ln563">   //! &lt;b&gt;Note&lt;/b&gt;: Does not affect the validity of iterators and references.</a>
<a name="ln564">   void shift_backwards(size_type n = 1)</a>
<a name="ln565">   {  node_algorithms::move_forward(this-&gt;get_root_node(), n);  }</a>
<a name="ln566"> </a>
<a name="ln567">   //! &lt;b&gt;Effects&lt;/b&gt;: Moves forward all the elements, so that the second</a>
<a name="ln568">   //!   element becomes the first, the third becomes the second...</a>
<a name="ln569">   //!   the first element becomes the last one.</a>
<a name="ln570">   //!</a>
<a name="ln571">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln572">   //!</a>
<a name="ln573">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear to the number of shifts.</a>
<a name="ln574">   //!</a>
<a name="ln575">   //! &lt;b&gt;Note&lt;/b&gt;: Does not affect the validity of iterators and references.</a>
<a name="ln576">   void shift_forward(size_type n = 1)</a>
<a name="ln577">   {  node_algorithms::move_backwards(this-&gt;get_root_node(), n);  }</a>
<a name="ln578"> </a>
<a name="ln579">   //! &lt;b&gt;Effects&lt;/b&gt;: Erases the element pointed by i of the list.</a>
<a name="ln580">   //!   No destructors are called.</a>
<a name="ln581">   //!</a>
<a name="ln582">   //! &lt;b&gt;Returns&lt;/b&gt;: the first element remaining beyond the removed element,</a>
<a name="ln583">   //!   or end() if no such element exists.</a>
<a name="ln584">   //!</a>
<a name="ln585">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln586">   //!</a>
<a name="ln587">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln588">   //!</a>
<a name="ln589">   //! &lt;b&gt;Note&lt;/b&gt;: Invalidates the iterators (but not the references) to the</a>
<a name="ln590">   //!   erased element.</a>
<a name="ln591">   iterator erase(const_iterator i)</a>
<a name="ln592">   {  return this-&gt;erase_and_dispose(i, detail::null_disposer());  }</a>
<a name="ln593"> </a>
<a name="ln594">   //! &lt;b&gt;Requires&lt;/b&gt;: b and e must be valid iterators to elements in *this.</a>
<a name="ln595">   //!</a>
<a name="ln596">   //! &lt;b&gt;Effects&lt;/b&gt;: Erases the element range pointed by b and e</a>
<a name="ln597">   //! No destructors are called.</a>
<a name="ln598">   //!</a>
<a name="ln599">   //! &lt;b&gt;Returns&lt;/b&gt;: the first element remaining beyond the removed elements,</a>
<a name="ln600">   //!   or end() if no such element exists.</a>
<a name="ln601">   //!</a>
<a name="ln602">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln603">   //!</a>
<a name="ln604">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear to the number of erased elements if it's a safe-mode</a>
<a name="ln605">   //!   or auto-unlink value, or constant-time size is enabled. Constant-time otherwise.</a>
<a name="ln606">   //!</a>
<a name="ln607">   //! &lt;b&gt;Note&lt;/b&gt;: Invalidates the iterators (but not the references) to the</a>
<a name="ln608">   //!   erased elements.</a>
<a name="ln609">   iterator erase(const_iterator b, const_iterator e)</a>
<a name="ln610">   {</a>
<a name="ln611">      if(safemode_or_autounlink || constant_time_size){</a>
<a name="ln612">         return this-&gt;erase_and_dispose(b, e, detail::null_disposer());</a>
<a name="ln613">      }</a>
<a name="ln614">      else{</a>
<a name="ln615">         node_algorithms::unlink(b.pointed_node(), e.pointed_node());</a>
<a name="ln616">         return e.unconst();</a>
<a name="ln617">      }</a>
<a name="ln618">   }</a>
<a name="ln619"> </a>
<a name="ln620">   //! &lt;b&gt;Requires&lt;/b&gt;: b and e must be valid iterators to elements in *this.</a>
<a name="ln621">   //!   n must be distance(b, e).</a>
<a name="ln622">   //!</a>
<a name="ln623">   //! &lt;b&gt;Effects&lt;/b&gt;: Erases the element range pointed by b and e</a>
<a name="ln624">   //! No destructors are called.</a>
<a name="ln625">   //!</a>
<a name="ln626">   //! &lt;b&gt;Returns&lt;/b&gt;: the first element remaining beyond the removed elements,</a>
<a name="ln627">   //!   or end() if no such element exists.</a>
<a name="ln628">   //!</a>
<a name="ln629">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln630">   //!</a>
<a name="ln631">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear to the number of erased elements if it's a safe-mode</a>
<a name="ln632">   //!   or auto-unlink value is enabled. Constant-time otherwise.</a>
<a name="ln633">   //!</a>
<a name="ln634">   //! &lt;b&gt;Note&lt;/b&gt;: Invalidates the iterators (but not the references) to the</a>
<a name="ln635">   //!   erased elements.</a>
<a name="ln636">   iterator erase(const_iterator b, const_iterator e, size_type n)</a>
<a name="ln637">   {</a>
<a name="ln638">      BOOST_INTRUSIVE_INVARIANT_ASSERT(node_algorithms::distance(b.pointed_node(), e.pointed_node()) == n);</a>
<a name="ln639">      if(safemode_or_autounlink || constant_time_size){</a>
<a name="ln640">         return this-&gt;erase_and_dispose(b, e, detail::null_disposer());</a>
<a name="ln641">      }</a>
<a name="ln642">      else{</a>
<a name="ln643">         if(constant_time_size){</a>
<a name="ln644">            this-&gt;priv_size_traits().decrease(n);</a>
<a name="ln645">         }</a>
<a name="ln646">         node_algorithms::unlink(b.pointed_node(), e.pointed_node());</a>
<a name="ln647">         return e.unconst();</a>
<a name="ln648">      }</a>
<a name="ln649">   }</a>
<a name="ln650"> </a>
<a name="ln651">   //! &lt;b&gt;Requires&lt;/b&gt;: Disposer::operator()(pointer) shouldn't throw.</a>
<a name="ln652">   //!</a>
<a name="ln653">   //! &lt;b&gt;Effects&lt;/b&gt;: Erases the element pointed by i of the list.</a>
<a name="ln654">   //!   No destructors are called.</a>
<a name="ln655">   //!   Disposer::operator()(pointer) is called for the removed element.</a>
<a name="ln656">   //!</a>
<a name="ln657">   //! &lt;b&gt;Returns&lt;/b&gt;: the first element remaining beyond the removed element,</a>
<a name="ln658">   //!   or end() if no such element exists.</a>
<a name="ln659">   //!</a>
<a name="ln660">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln661">   //!</a>
<a name="ln662">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln663">   //!</a>
<a name="ln664">   //! &lt;b&gt;Note&lt;/b&gt;: Invalidates the iterators to the erased element.</a>
<a name="ln665">   template &lt;class Disposer&gt;</a>
<a name="ln666">   iterator erase_and_dispose(const_iterator i, Disposer disposer)</a>
<a name="ln667">   {</a>
<a name="ln668">      node_ptr to_erase(i.pointed_node());</a>
<a name="ln669">      ++i;</a>
<a name="ln670">      node_algorithms::unlink(to_erase);</a>
<a name="ln671">      this-&gt;priv_size_traits().decrement();</a>
<a name="ln672">      if(safemode_or_autounlink)</a>
<a name="ln673">         node_algorithms::init(to_erase);</a>
<a name="ln674">      disposer(this-&gt;priv_value_traits().to_value_ptr(to_erase));</a>
<a name="ln675">      return i.unconst();</a>
<a name="ln676">   }</a>
<a name="ln677"> </a>
<a name="ln678">   #if !defined(BOOST_INTRUSIVE_DOXYGEN_INVOKED)</a>
<a name="ln679">   template&lt;class Disposer&gt;</a>
<a name="ln680">   iterator erase_and_dispose(iterator i, Disposer disposer)</a>
<a name="ln681">   {  return this-&gt;erase_and_dispose(const_iterator(i), disposer);   }</a>
<a name="ln682">   #endif</a>
<a name="ln683"> </a>
<a name="ln684">   //! &lt;b&gt;Requires&lt;/b&gt;: Disposer::operator()(pointer) shouldn't throw.</a>
<a name="ln685">   //!</a>
<a name="ln686">   //! &lt;b&gt;Effects&lt;/b&gt;: Erases the element range pointed by b and e</a>
<a name="ln687">   //!   No destructors are called.</a>
<a name="ln688">   //!   Disposer::operator()(pointer) is called for the removed elements.</a>
<a name="ln689">   //!</a>
<a name="ln690">   //! &lt;b&gt;Returns&lt;/b&gt;: the first element remaining beyond the removed elements,</a>
<a name="ln691">   //!   or end() if no such element exists.</a>
<a name="ln692">   //!</a>
<a name="ln693">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln694">   //!</a>
<a name="ln695">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear to the number of elements erased.</a>
<a name="ln696">   //!</a>
<a name="ln697">   //! &lt;b&gt;Note&lt;/b&gt;: Invalidates the iterators to the erased elements.</a>
<a name="ln698">   template &lt;class Disposer&gt;</a>
<a name="ln699">   iterator erase_and_dispose(const_iterator b, const_iterator e, Disposer disposer)</a>
<a name="ln700">   {</a>
<a name="ln701">      node_ptr bp(b.pointed_node()), ep(e.pointed_node());</a>
<a name="ln702">      node_algorithms::unlink(bp, ep);</a>
<a name="ln703">      while(bp != ep){</a>
<a name="ln704">         node_ptr to_erase(bp);</a>
<a name="ln705">         bp = node_traits::get_next(bp);</a>
<a name="ln706">         if(safemode_or_autounlink)</a>
<a name="ln707">            node_algorithms::init(to_erase);</a>
<a name="ln708">         disposer(priv_value_traits().to_value_ptr(to_erase));</a>
<a name="ln709">         this-&gt;priv_size_traits().decrement();</a>
<a name="ln710">      }</a>
<a name="ln711">      return e.unconst();</a>
<a name="ln712">   }</a>
<a name="ln713"> </a>
<a name="ln714">   //! &lt;b&gt;Effects&lt;/b&gt;: Erases all the elements of the container.</a>
<a name="ln715">   //!   No destructors are called.</a>
<a name="ln716">   //!</a>
<a name="ln717">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln718">   //!</a>
<a name="ln719">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear to the number of elements of the list.</a>
<a name="ln720">   //!   if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</a>
<a name="ln721">   //!</a>
<a name="ln722">   //! &lt;b&gt;Note&lt;/b&gt;: Invalidates the iterators (but not the references) to the erased elements.</a>
<a name="ln723">   void clear()</a>
<a name="ln724">   {</a>
<a name="ln725">      if(safemode_or_autounlink){</a>
<a name="ln726">         this-&gt;clear_and_dispose(detail::null_disposer());</a>
<a name="ln727">      }</a>
<a name="ln728">      else{</a>
<a name="ln729">         node_algorithms::init_header(this-&gt;get_root_node());</a>
<a name="ln730">         this-&gt;priv_size_traits().set_size(size_type(0));</a>
<a name="ln731">      }</a>
<a name="ln732">   }</a>
<a name="ln733"> </a>
<a name="ln734">   //! &lt;b&gt;Requires&lt;/b&gt;: Disposer::operator()(pointer) shouldn't throw.</a>
<a name="ln735">   //!</a>
<a name="ln736">   //! &lt;b&gt;Effects&lt;/b&gt;: Erases all the elements of the container.</a>
<a name="ln737">   //!   No destructors are called.</a>
<a name="ln738">   //!   Disposer::operator()(pointer) is called for the removed elements.</a>
<a name="ln739">   //!</a>
<a name="ln740">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln741">   //!</a>
<a name="ln742">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear to the number of elements of the list.</a>
<a name="ln743">   //!</a>
<a name="ln744">   //! &lt;b&gt;Note&lt;/b&gt;: Invalidates the iterators to the erased elements.</a>
<a name="ln745">   template &lt;class Disposer&gt;</a>
<a name="ln746">   void clear_and_dispose(Disposer disposer)</a>
<a name="ln747">   {</a>
<a name="ln748">      const_iterator it(this-&gt;begin()), itend(this-&gt;end());</a>
<a name="ln749">      while(it != itend){</a>
<a name="ln750">         node_ptr to_erase(it.pointed_node());</a>
<a name="ln751">         ++it;</a>
<a name="ln752">         if(safemode_or_autounlink)</a>
<a name="ln753">            node_algorithms::init(to_erase);</a>
<a name="ln754">         disposer(priv_value_traits().to_value_ptr(to_erase));</a>
<a name="ln755">      }</a>
<a name="ln756">      node_algorithms::init_header(this-&gt;get_root_node());</a>
<a name="ln757">      this-&gt;priv_size_traits().set_size(0);</a>
<a name="ln758">   }</a>
<a name="ln759"> </a>
<a name="ln760">   //! &lt;b&gt;Requires&lt;/b&gt;: Disposer::operator()(pointer) shouldn't throw.</a>
<a name="ln761">   //!   Cloner should yield to nodes equivalent to the original nodes.</a>
<a name="ln762">   //!</a>
<a name="ln763">   //! &lt;b&gt;Effects&lt;/b&gt;: Erases all the elements from *this</a>
<a name="ln764">   //!   calling Disposer::operator()(pointer), clones all the</a>
<a name="ln765">   //!   elements from src calling Cloner::operator()(const_reference )</a>
<a name="ln766">   //!   and inserts them on *this.</a>
<a name="ln767">   //!</a>
<a name="ln768">   //!   If cloner throws, all cloned elements are unlinked and disposed</a>
<a name="ln769">   //!   calling Disposer::operator()(pointer).</a>
<a name="ln770">   //!</a>
<a name="ln771">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear to erased plus inserted elements.</a>
<a name="ln772">   //!</a>
<a name="ln773">   //! &lt;b&gt;Throws&lt;/b&gt;: If cloner throws. Basic guarantee.</a>
<a name="ln774">   template &lt;class Cloner, class Disposer&gt;</a>
<a name="ln775">   void clone_from(const list_impl &amp;src, Cloner cloner, Disposer disposer)</a>
<a name="ln776">   {</a>
<a name="ln777">      this-&gt;clear_and_dispose(disposer);</a>
<a name="ln778">      detail::exception_disposer&lt;list_impl, Disposer&gt;</a>
<a name="ln779">         rollback(*this, disposer);</a>
<a name="ln780">      const_iterator b(src.begin()), e(src.end());</a>
<a name="ln781">      for(; b != e; ++b){</a>
<a name="ln782">         this-&gt;push_back(*cloner(*b));</a>
<a name="ln783">      }</a>
<a name="ln784">      rollback.release();</a>
<a name="ln785">   }</a>
<a name="ln786"> </a>
<a name="ln787">   //! &lt;b&gt;Requires&lt;/b&gt;: Disposer::operator()(pointer) shouldn't throw.</a>
<a name="ln788">   //!   Cloner should yield to nodes equivalent to the original nodes.</a>
<a name="ln789">   //!</a>
<a name="ln790">   //! &lt;b&gt;Effects&lt;/b&gt;: Erases all the elements from *this</a>
<a name="ln791">   //!   calling Disposer::operator()(pointer), clones all the</a>
<a name="ln792">   //!   elements from src calling Cloner::operator()(reference)</a>
<a name="ln793">   //!   and inserts them on *this.</a>
<a name="ln794">   //!</a>
<a name="ln795">   //!   If cloner throws, all cloned elements are unlinked and disposed</a>
<a name="ln796">   //!   calling Disposer::operator()(pointer).</a>
<a name="ln797">   //!</a>
<a name="ln798">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear to erased plus inserted elements.</a>
<a name="ln799">   //!</a>
<a name="ln800">   //! &lt;b&gt;Throws&lt;/b&gt;: If cloner throws. Basic guarantee.</a>
<a name="ln801">   template &lt;class Cloner, class Disposer&gt;</a>
<a name="ln802">   void clone_from(BOOST_RV_REF(list_impl) src, Cloner cloner, Disposer disposer)</a>
<a name="ln803">   {</a>
<a name="ln804">      this-&gt;clear_and_dispose(disposer);</a>
<a name="ln805">      detail::exception_disposer&lt;list_impl, Disposer&gt;</a>
<a name="ln806">         rollback(*this, disposer);</a>
<a name="ln807">      iterator b(src.begin()), e(src.end());</a>
<a name="ln808">      for(; b != e; ++b){</a>
<a name="ln809">         this-&gt;push_back(*cloner(*b));</a>
<a name="ln810">      }</a>
<a name="ln811">      rollback.release();</a>
<a name="ln812">   }</a>
<a name="ln813"> </a>
<a name="ln814">   //! &lt;b&gt;Requires&lt;/b&gt;: value must be an lvalue and p must be a valid iterator of *this.</a>
<a name="ln815">   //!</a>
<a name="ln816">   //! &lt;b&gt;Effects&lt;/b&gt;: Inserts the value before the position pointed by p.</a>
<a name="ln817">   //!</a>
<a name="ln818">   //! &lt;b&gt;Returns&lt;/b&gt;: An iterator to the inserted element.</a>
<a name="ln819">   //!</a>
<a name="ln820">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln821">   //!</a>
<a name="ln822">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant time. No copy constructors are called.</a>
<a name="ln823">   //!</a>
<a name="ln824">   //! &lt;b&gt;Note&lt;/b&gt;: Does not affect the validity of iterators and references.</a>
<a name="ln825">   iterator insert(const_iterator p, reference value)</a>
<a name="ln826">   {</a>
<a name="ln827">      node_ptr to_insert = this-&gt;priv_value_traits().to_node_ptr(value);</a>
<a name="ln828">      BOOST_INTRUSIVE_SAFE_HOOK_DEFAULT_ASSERT(!safemode_or_autounlink || node_algorithms::inited(to_insert));</a>
<a name="ln829">      node_algorithms::link_before(p.pointed_node(), to_insert);</a>
<a name="ln830">      this-&gt;priv_size_traits().increment();</a>
<a name="ln831">      return iterator(to_insert, this-&gt;priv_value_traits_ptr());</a>
<a name="ln832">   }</a>
<a name="ln833"> </a>
<a name="ln834">   //! &lt;b&gt;Requires&lt;/b&gt;: Dereferencing iterator must yield</a>
<a name="ln835">   //!   an lvalue of type value_type and p must be a valid iterator of *this.</a>
<a name="ln836">   //!</a>
<a name="ln837">   //! &lt;b&gt;Effects&lt;/b&gt;: Inserts the range pointed by b and e before the position p.</a>
<a name="ln838">   //!   No copy constructors are called.</a>
<a name="ln839">   //!</a>
<a name="ln840">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln841">   //!</a>
<a name="ln842">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear to the number of elements inserted.</a>
<a name="ln843">   //!</a>
<a name="ln844">   //! &lt;b&gt;Note&lt;/b&gt;: Does not affect the validity of iterators and references.</a>
<a name="ln845">   template&lt;class Iterator&gt;</a>
<a name="ln846">   void insert(const_iterator p, Iterator b, Iterator e)</a>
<a name="ln847">   {</a>
<a name="ln848">      for (; b != e; ++b)</a>
<a name="ln849">         this-&gt;insert(p, *b);</a>
<a name="ln850">   }</a>
<a name="ln851"> </a>
<a name="ln852">   //! &lt;b&gt;Requires&lt;/b&gt;: Dereferencing iterator must yield</a>
<a name="ln853">   //!   an lvalue of type value_type.</a>
<a name="ln854">   //!</a>
<a name="ln855">   //! &lt;b&gt;Effects&lt;/b&gt;: Clears the list and inserts the range pointed by b and e.</a>
<a name="ln856">   //!   No destructors or copy constructors are called.</a>
<a name="ln857">   //!</a>
<a name="ln858">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln859">   //!</a>
<a name="ln860">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear to the number of elements inserted plus</a>
<a name="ln861">   //!   linear to the elements contained in the list if it's a safe-mode</a>
<a name="ln862">   //!   or auto-unlink value.</a>
<a name="ln863">   //!   Linear to the number of elements inserted in the list otherwise.</a>
<a name="ln864">   //!</a>
<a name="ln865">   //! &lt;b&gt;Note&lt;/b&gt;: Invalidates the iterators (but not the references)</a>
<a name="ln866">   //!   to the erased elements.</a>
<a name="ln867">   template&lt;class Iterator&gt;</a>
<a name="ln868">   void assign(Iterator b, Iterator e)</a>
<a name="ln869">   {</a>
<a name="ln870">      this-&gt;clear();</a>
<a name="ln871">      this-&gt;insert(this-&gt;cend(), b, e);</a>
<a name="ln872">   }</a>
<a name="ln873"> </a>
<a name="ln874">   //! &lt;b&gt;Requires&lt;/b&gt;: Disposer::operator()(pointer) shouldn't throw.</a>
<a name="ln875">   //!</a>
<a name="ln876">   //! &lt;b&gt;Requires&lt;/b&gt;: Dereferencing iterator must yield</a>
<a name="ln877">   //!   an lvalue of type value_type.</a>
<a name="ln878">   //!</a>
<a name="ln879">   //! &lt;b&gt;Effects&lt;/b&gt;: Clears the list and inserts the range pointed by b and e.</a>
<a name="ln880">   //!   No destructors or copy constructors are called.</a>
<a name="ln881">   //!   Disposer::operator()(pointer) is called for the removed elements.</a>
<a name="ln882">   //!</a>
<a name="ln883">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln884">   //!</a>
<a name="ln885">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear to the number of elements inserted plus</a>
<a name="ln886">   //!   linear to the elements contained in the list.</a>
<a name="ln887">   //!</a>
<a name="ln888">   //! &lt;b&gt;Note&lt;/b&gt;: Invalidates the iterators (but not the references)</a>
<a name="ln889">   //!   to the erased elements.</a>
<a name="ln890">   template&lt;class Iterator, class Disposer&gt;</a>
<a name="ln891">   void dispose_and_assign(Disposer disposer, Iterator b, Iterator e)</a>
<a name="ln892">   {</a>
<a name="ln893">      this-&gt;clear_and_dispose(disposer);</a>
<a name="ln894">      this-&gt;insert(this-&gt;cend(), b, e);</a>
<a name="ln895">   }</a>
<a name="ln896"> </a>
<a name="ln897">   //! &lt;b&gt;Requires&lt;/b&gt;: p must be a valid iterator of *this.</a>
<a name="ln898">   //!</a>
<a name="ln899">   //! &lt;b&gt;Effects&lt;/b&gt;: Transfers all the elements of list x to this list, before the</a>
<a name="ln900">   //!   the element pointed by p. No destructors or copy constructors are called.</a>
<a name="ln901">   //!</a>
<a name="ln902">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln903">   //!</a>
<a name="ln904">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln905">   //!</a>
<a name="ln906">   //! &lt;b&gt;Note&lt;/b&gt;: Iterators of values obtained from list x now point to elements of</a>
<a name="ln907">   //!    this list. Iterators of this list and all the references are not invalidated.</a>
<a name="ln908">   void splice(const_iterator p, list_impl&amp; x)</a>
<a name="ln909">   {</a>
<a name="ln910">      if(!x.empty()){</a>
<a name="ln911">         node_algorithms::transfer</a>
<a name="ln912">            (p.pointed_node(), x.begin().pointed_node(), x.end().pointed_node());</a>
<a name="ln913">         size_traits &amp;thist = this-&gt;priv_size_traits();</a>
<a name="ln914">         size_traits &amp;xt = x.priv_size_traits();</a>
<a name="ln915">         thist.increase(xt.get_size());</a>
<a name="ln916">         xt.set_size(size_type(0));</a>
<a name="ln917">      }</a>
<a name="ln918">   }</a>
<a name="ln919"> </a>
<a name="ln920">   //! &lt;b&gt;Requires&lt;/b&gt;: p must be a valid iterator of *this.</a>
<a name="ln921">   //!   new_ele must point to an element contained in list x.</a>
<a name="ln922">   //!</a>
<a name="ln923">   //! &lt;b&gt;Effects&lt;/b&gt;: Transfers the value pointed by new_ele, from list x to this list,</a>
<a name="ln924">   //!   before the element pointed by p. No destructors or copy constructors are called.</a>
<a name="ln925">   //!   If p == new_ele or p == ++new_ele, this function is a null operation.</a>
<a name="ln926">   //!</a>
<a name="ln927">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln928">   //!</a>
<a name="ln929">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln930">   //!</a>
<a name="ln931">   //! &lt;b&gt;Note&lt;/b&gt;: Iterators of values obtained from list x now point to elements of this</a>
<a name="ln932">   //!   list. Iterators of this list and all the references are not invalidated.</a>
<a name="ln933">   void splice(const_iterator p, list_impl&amp;x, const_iterator new_ele)</a>
<a name="ln934">   {</a>
<a name="ln935">      node_algorithms::transfer(p.pointed_node(), new_ele.pointed_node());</a>
<a name="ln936">      x.priv_size_traits().decrement();</a>
<a name="ln937">      this-&gt;priv_size_traits().increment();</a>
<a name="ln938">   }</a>
<a name="ln939"> </a>
<a name="ln940">   //! &lt;b&gt;Requires&lt;/b&gt;: p must be a valid iterator of *this.</a>
<a name="ln941">   //!   f and e must point to elements contained in list x.</a>
<a name="ln942">   //!</a>
<a name="ln943">   //! &lt;b&gt;Effects&lt;/b&gt;: Transfers the range pointed by f and e from list x to this list,</a>
<a name="ln944">   //!   before the element pointed by p. No destructors or copy constructors are called.</a>
<a name="ln945">   //!</a>
<a name="ln946">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln947">   //!</a>
<a name="ln948">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear to the number of elements transferred</a>
<a name="ln949">   //!   if constant-time size option is enabled. Constant-time otherwise.</a>
<a name="ln950">   //!</a>
<a name="ln951">   //! &lt;b&gt;Note&lt;/b&gt;: Iterators of values obtained from list x now point to elements of this</a>
<a name="ln952">   //!   list. Iterators of this list and all the references are not invalidated.</a>
<a name="ln953">   void splice(const_iterator p, list_impl&amp;x, const_iterator f, const_iterator e)</a>
<a name="ln954">   {</a>
<a name="ln955">      if(constant_time_size)</a>
<a name="ln956">         this-&gt;splice(p, x, f, e, node_algorithms::distance(f.pointed_node(), e.pointed_node()));</a>
<a name="ln957">      else</a>
<a name="ln958">         this-&gt;splice(p, x, f, e, 1);//intrusive::iterator_distance is a dummy value</a>
<a name="ln959">   }</a>
<a name="ln960"> </a>
<a name="ln961">   //! &lt;b&gt;Requires&lt;/b&gt;: p must be a valid iterator of *this.</a>
<a name="ln962">   //!   f and e must point to elements contained in list x.</a>
<a name="ln963">   //!   n == distance(f, e)</a>
<a name="ln964">   //!</a>
<a name="ln965">   //! &lt;b&gt;Effects&lt;/b&gt;: Transfers the range pointed by f and e from list x to this list,</a>
<a name="ln966">   //!   before the element pointed by p. No destructors or copy constructors are called.</a>
<a name="ln967">   //!</a>
<a name="ln968">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln969">   //!</a>
<a name="ln970">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant.</a>
<a name="ln971">   //!</a>
<a name="ln972">   //! &lt;b&gt;Note&lt;/b&gt;: Iterators of values obtained from list x now point to elements of this</a>
<a name="ln973">   //!   list. Iterators of this list and all the references are not invalidated.</a>
<a name="ln974">   void splice(const_iterator p, list_impl&amp;x, const_iterator f, const_iterator e, size_type n)</a>
<a name="ln975">   {</a>
<a name="ln976">      if(n){</a>
<a name="ln977">         if(constant_time_size){</a>
<a name="ln978">            BOOST_INTRUSIVE_INVARIANT_ASSERT(n == node_algorithms::distance(f.pointed_node(), e.pointed_node()));</a>
<a name="ln979">            node_algorithms::transfer(p.pointed_node(), f.pointed_node(), e.pointed_node());</a>
<a name="ln980">            size_traits &amp;thist = this-&gt;priv_size_traits();</a>
<a name="ln981">            size_traits &amp;xt = x.priv_size_traits();</a>
<a name="ln982">            thist.increase(n);</a>
<a name="ln983">            xt.decrease(n);</a>
<a name="ln984">         }</a>
<a name="ln985">         else{</a>
<a name="ln986">            node_algorithms::transfer(p.pointed_node(), f.pointed_node(), e.pointed_node());</a>
<a name="ln987">         }</a>
<a name="ln988">      }</a>
<a name="ln989">   }</a>
<a name="ln990"> </a>
<a name="ln991">   //! &lt;b&gt;Effects&lt;/b&gt;: This function sorts the list *this according to std::less&lt;value_type&gt;.</a>
<a name="ln992">   //!   The sort is stable, that is, the relative order of equivalent elements is preserved.</a>
<a name="ln993">   //!</a>
<a name="ln994">   //! &lt;b&gt;Throws&lt;/b&gt;: If value_traits::node_traits::node</a>
<a name="ln995">   //!   constructor throws (this does not happen with predefined Boost.Intrusive hooks)</a>
<a name="ln996">   //!   or std::less&lt;value_type&gt; throws. Basic guarantee.</a>
<a name="ln997">   //!</a>
<a name="ln998">   //! &lt;b&gt;Notes&lt;/b&gt;: Iterators and references are not invalidated.</a>
<a name="ln999">   //!</a>
<a name="ln1000">   //! &lt;b&gt;Complexity&lt;/b&gt;: The number of comparisons is approximately N log N, where N</a>
<a name="ln1001">   //!   is the list's size.</a>
<a name="ln1002">   void sort()</a>
<a name="ln1003">   {  this-&gt;sort(std::less&lt;value_type&gt;());  }</a>
<a name="ln1004"> </a>
<a name="ln1005">   //! &lt;b&gt;Requires&lt;/b&gt;: p must be a comparison function that induces a strict weak ordering</a>
<a name="ln1006">   //!</a>
<a name="ln1007">   //! &lt;b&gt;Effects&lt;/b&gt;: This function sorts the list *this according to p. The sort is</a>
<a name="ln1008">   //!   stable, that is, the relative order of equivalent elements is preserved.</a>
<a name="ln1009">   //!</a>
<a name="ln1010">   //! &lt;b&gt;Throws&lt;/b&gt;: If value_traits::node_traits::node</a>
<a name="ln1011">   //!   constructor throws (this does not happen with predefined Boost.Intrusive hooks)</a>
<a name="ln1012">   //!   or the predicate throws. Basic guarantee.</a>
<a name="ln1013">   //!</a>
<a name="ln1014">   //! &lt;b&gt;Notes&lt;/b&gt;: This won't throw if list_base_hook&lt;&gt; or</a>
<a name="ln1015">   //!   list_member_hook are used.</a>
<a name="ln1016">   //!   Iterators and references are not invalidated.</a>
<a name="ln1017">   //!</a>
<a name="ln1018">   //! &lt;b&gt;Complexity&lt;/b&gt;: The number of comparisons is approximately N log N, where N</a>
<a name="ln1019">   //!   is the list's size.</a>
<a name="ln1020">   template&lt;class Predicate&gt;</a>
<a name="ln1021">   void sort(Predicate p)</a>
<a name="ln1022">   {</a>
<a name="ln1023">      if(node_traits::get_next(this-&gt;get_root_node())</a>
<a name="ln1024">         != node_traits::get_previous(this-&gt;get_root_node())){</a>
<a name="ln1025">         list_impl carry(this-&gt;priv_value_traits());</a>
<a name="ln1026">         detail::array_initializer&lt;list_impl, 64&gt; counter(this-&gt;priv_value_traits());</a>
<a name="ln1027">         int fill = 0;</a>
<a name="ln1028">         while(!this-&gt;empty()){</a>
<a name="ln1029">            carry.splice(carry.cbegin(), *this, this-&gt;cbegin());</a>
<a name="ln1030">            int i = 0;</a>
<a name="ln1031">            while(i &lt; fill &amp;&amp; !counter[i].empty()) {</a>
<a name="ln1032">               counter[i].merge(carry, p);</a>
<a name="ln1033">               carry.swap(counter[i++]);</a>
<a name="ln1034">            }</a>
<a name="ln1035">            carry.swap(counter[i]);</a>
<a name="ln1036">            if(i == fill)</a>
<a name="ln1037">               ++fill;</a>
<a name="ln1038">         }</a>
<a name="ln1039">         for (int i = 1; i &lt; fill; ++i)</a>
<a name="ln1040">            counter[i].merge(counter[i-1], p);</a>
<a name="ln1041">         this-&gt;swap(counter[fill-1]);</a>
<a name="ln1042">      }</a>
<a name="ln1043">   }</a>
<a name="ln1044"> </a>
<a name="ln1045">   //! &lt;b&gt;Effects&lt;/b&gt;: This function removes all of x's elements and inserts them</a>
<a name="ln1046">   //!   in order into *this according to std::less&lt;value_type&gt;. The merge is stable;</a>
<a name="ln1047">   //!   that is, if an element from *this is equivalent to one from x, then the element</a>
<a name="ln1048">   //!   from *this will precede the one from x.</a>
<a name="ln1049">   //!</a>
<a name="ln1050">   //! &lt;b&gt;Throws&lt;/b&gt;: If std::less&lt;value_type&gt; throws. Basic guarantee.</a>
<a name="ln1051">   //!</a>
<a name="ln1052">   //! &lt;b&gt;Complexity&lt;/b&gt;: This function is linear time: it performs at most</a>
<a name="ln1053">   //!   size() + x.size() - 1 comparisons.</a>
<a name="ln1054">   //!</a>
<a name="ln1055">   //! &lt;b&gt;Note&lt;/b&gt;: Iterators and references are not invalidated</a>
<a name="ln1056">   void merge(list_impl&amp; x)</a>
<a name="ln1057">   { this-&gt;merge(x, std::less&lt;value_type&gt;()); }</a>
<a name="ln1058"> </a>
<a name="ln1059">   //! &lt;b&gt;Requires&lt;/b&gt;: p must be a comparison function that induces a strict weak</a>
<a name="ln1060">   //!   ordering and both *this and x must be sorted according to that ordering</a>
<a name="ln1061">   //!   The lists x and *this must be distinct.</a>
<a name="ln1062">   //!</a>
<a name="ln1063">   //! &lt;b&gt;Effects&lt;/b&gt;: This function removes all of x's elements and inserts them</a>
<a name="ln1064">   //!   in order into *this. The merge is stable; that is, if an element from *this is</a>
<a name="ln1065">   //!   equivalent to one from x, then the element from *this will precede the one from x.</a>
<a name="ln1066">   //!</a>
<a name="ln1067">   //! &lt;b&gt;Throws&lt;/b&gt;: If the predicate throws. Basic guarantee.</a>
<a name="ln1068">   //!</a>
<a name="ln1069">   //! &lt;b&gt;Complexity&lt;/b&gt;: This function is linear time: it performs at most</a>
<a name="ln1070">   //!   size() + x.size() - 1 comparisons.</a>
<a name="ln1071">   //!</a>
<a name="ln1072">   //! &lt;b&gt;Note&lt;/b&gt;: Iterators and references are not invalidated.</a>
<a name="ln1073">   template&lt;class Predicate&gt;</a>
<a name="ln1074">   void merge(list_impl&amp; x, Predicate p)</a>
<a name="ln1075">   {</a>
<a name="ln1076">      const_iterator e(this-&gt;cend()), ex(x.cend());</a>
<a name="ln1077">      const_iterator b(this-&gt;cbegin());</a>
<a name="ln1078">      while(!x.empty()){</a>
<a name="ln1079">         const_iterator ix(x.cbegin());</a>
<a name="ln1080">         while (b != e &amp;&amp; !p(*ix, *b)){</a>
<a name="ln1081">            ++b;</a>
<a name="ln1082">         }</a>
<a name="ln1083">         if(b == e){</a>
<a name="ln1084">            //Now transfer the rest to the end of the container</a>
<a name="ln1085">            this-&gt;splice(e, x);</a>
<a name="ln1086">            break;</a>
<a name="ln1087">         }</a>
<a name="ln1088">         else{</a>
<a name="ln1089">            size_type n(0);</a>
<a name="ln1090">            do{</a>
<a name="ln1091">               ++ix; ++n;</a>
<a name="ln1092">            } while(ix != ex &amp;&amp; p(*ix, *b));</a>
<a name="ln1093">            this-&gt;splice(b, x, x.begin(), ix, n);</a>
<a name="ln1094">         }</a>
<a name="ln1095">      }</a>
<a name="ln1096">   }</a>
<a name="ln1097"> </a>
<a name="ln1098">   //! &lt;b&gt;Effects&lt;/b&gt;: Reverses the order of elements in the list.</a>
<a name="ln1099">   //!</a>
<a name="ln1100">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln1101">   //!</a>
<a name="ln1102">   //! &lt;b&gt;Complexity&lt;/b&gt;: This function is linear time.</a>
<a name="ln1103">   //!</a>
<a name="ln1104">   //! &lt;b&gt;Note&lt;/b&gt;: Iterators and references are not invalidated</a>
<a name="ln1105">   void reverse()</a>
<a name="ln1106">   {  node_algorithms::reverse(this-&gt;get_root_node());   }</a>
<a name="ln1107"> </a>
<a name="ln1108">   //! &lt;b&gt;Effects&lt;/b&gt;: Removes all the elements that compare equal to value.</a>
<a name="ln1109">   //!   No destructors are called.</a>
<a name="ln1110">   //!</a>
<a name="ln1111">   //! &lt;b&gt;Throws&lt;/b&gt;: If std::equal_to&lt;value_type&gt; throws. Basic guarantee.</a>
<a name="ln1112">   //!</a>
<a name="ln1113">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear time. It performs exactly size() comparisons for equality.</a>
<a name="ln1114">   //!</a>
<a name="ln1115">   //! &lt;b&gt;Note&lt;/b&gt;: The relative order of elements that are not removed is unchanged,</a>
<a name="ln1116">   //!   and iterators to elements that are not removed remain valid.</a>
<a name="ln1117">   void remove(const_reference value)</a>
<a name="ln1118">   {  this-&gt;remove_if(detail::equal_to_value&lt;const_reference&gt;(value));  }</a>
<a name="ln1119"> </a>
<a name="ln1120">   //! &lt;b&gt;Requires&lt;/b&gt;: Disposer::operator()(pointer) shouldn't throw.</a>
<a name="ln1121">   //!</a>
<a name="ln1122">   //! &lt;b&gt;Effects&lt;/b&gt;: Removes all the elements that compare equal to value.</a>
<a name="ln1123">   //!   Disposer::operator()(pointer) is called for every removed element.</a>
<a name="ln1124">   //!</a>
<a name="ln1125">   //! &lt;b&gt;Throws&lt;/b&gt;: If std::equal_to&lt;value_type&gt; throws. Basic guarantee.</a>
<a name="ln1126">   //!</a>
<a name="ln1127">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear time. It performs exactly size() comparisons for equality.</a>
<a name="ln1128">   //!</a>
<a name="ln1129">   //! &lt;b&gt;Note&lt;/b&gt;: The relative order of elements that are not removed is unchanged,</a>
<a name="ln1130">   //!   and iterators to elements that are not removed remain valid.</a>
<a name="ln1131">   template&lt;class Disposer&gt;</a>
<a name="ln1132">   void remove_and_dispose(const_reference value, Disposer disposer)</a>
<a name="ln1133">   {  this-&gt;remove_and_dispose_if(detail::equal_to_value&lt;const_reference&gt;(value), disposer);  }</a>
<a name="ln1134"> </a>
<a name="ln1135">   //! &lt;b&gt;Effects&lt;/b&gt;: Removes all the elements for which a specified</a>
<a name="ln1136">   //!   predicate is satisfied. No destructors are called.</a>
<a name="ln1137">   //!</a>
<a name="ln1138">   //! &lt;b&gt;Throws&lt;/b&gt;: If pred throws. Basic guarantee.</a>
<a name="ln1139">   //!</a>
<a name="ln1140">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear time. It performs exactly size() calls to the predicate.</a>
<a name="ln1141">   //!</a>
<a name="ln1142">   //! &lt;b&gt;Note&lt;/b&gt;: The relative order of elements that are not removed is unchanged,</a>
<a name="ln1143">   //!   and iterators to elements that are not removed remain valid.</a>
<a name="ln1144">   template&lt;class Pred&gt;</a>
<a name="ln1145">   void remove_if(Pred pred)</a>
<a name="ln1146">   {</a>
<a name="ln1147">      const node_ptr root_node = this-&gt;get_root_node();</a>
<a name="ln1148">      typename node_algorithms::stable_partition_info info;</a>
<a name="ln1149">      node_algorithms::stable_partition</a>
<a name="ln1150">         (node_traits::get_next(root_node), root_node, detail::key_nodeptr_comp&lt;Pred, value_traits&gt;(pred, &amp;this-&gt;priv_value_traits()), info);</a>
<a name="ln1151">      //Invariants preserved by stable_partition so erase can be safely called</a>
<a name="ln1152">      //The first element might have changed so calculate it again</a>
<a name="ln1153">      this-&gt;erase( const_iterator(node_traits::get_next(root_node), this-&gt;priv_value_traits_ptr())</a>
<a name="ln1154">                 , const_iterator(info.beg_2st_partition, this-&gt;priv_value_traits_ptr())</a>
<a name="ln1155">                 , info.num_1st_partition);</a>
<a name="ln1156">   }</a>
<a name="ln1157"> </a>
<a name="ln1158">   //! &lt;b&gt;Requires&lt;/b&gt;: Disposer::operator()(pointer) shouldn't throw.</a>
<a name="ln1159">   //!</a>
<a name="ln1160">   //! &lt;b&gt;Effects&lt;/b&gt;: Removes all the elements for which a specified</a>
<a name="ln1161">   //!   predicate is satisfied.</a>
<a name="ln1162">   //!   Disposer::operator()(pointer) is called for every removed element.</a>
<a name="ln1163">   //!</a>
<a name="ln1164">   //! &lt;b&gt;Throws&lt;/b&gt;: If pred throws. Basic guarantee.</a>
<a name="ln1165">   //!</a>
<a name="ln1166">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear time. It performs exactly size() comparisons for equality.</a>
<a name="ln1167">   //!</a>
<a name="ln1168">   //! &lt;b&gt;Note&lt;/b&gt;: The relative order of elements that are not removed is unchanged,</a>
<a name="ln1169">   //!   and iterators to elements that are not removed remain valid.</a>
<a name="ln1170">   template&lt;class Pred, class Disposer&gt;</a>
<a name="ln1171">   void remove_and_dispose_if(Pred pred, Disposer disposer)</a>
<a name="ln1172">   {</a>
<a name="ln1173">      const node_ptr root_node = this-&gt;get_root_node();</a>
<a name="ln1174">      typename node_algorithms::stable_partition_info info;</a>
<a name="ln1175">      node_algorithms::stable_partition</a>
<a name="ln1176">         (node_traits::get_next(root_node), root_node, detail::key_nodeptr_comp&lt;Pred, value_traits&gt;(pred, &amp;this-&gt;priv_value_traits()), info);</a>
<a name="ln1177">      //Invariants preserved by stable_partition so erase can be safely called</a>
<a name="ln1178">      //The first element might have changed so calculate it again</a>
<a name="ln1179">      this-&gt;erase_and_dispose( const_iterator(node_traits::get_next(root_node), this-&gt;priv_value_traits_ptr())</a>
<a name="ln1180">                             , const_iterator(info.beg_2st_partition, this-&gt;priv_value_traits_ptr())</a>
<a name="ln1181">                             , disposer);</a>
<a name="ln1182">   }</a>
<a name="ln1183"> </a>
<a name="ln1184">   //! &lt;b&gt;Effects&lt;/b&gt;: Removes adjacent duplicate elements or adjacent</a>
<a name="ln1185">   //!   elements that are equal from the list. No destructors are called.</a>
<a name="ln1186">   //!</a>
<a name="ln1187">   //! &lt;b&gt;Throws&lt;/b&gt;: If std::equal_to&lt;value_type throws. Basic guarantee.</a>
<a name="ln1188">   //!</a>
<a name="ln1189">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear time (size()-1 comparisons calls to pred()).</a>
<a name="ln1190">   //!</a>
<a name="ln1191">   //! &lt;b&gt;Note&lt;/b&gt;: The relative order of elements that are not removed is unchanged,</a>
<a name="ln1192">   //!   and iterators to elements that are not removed remain valid.</a>
<a name="ln1193">   void unique()</a>
<a name="ln1194">   {  this-&gt;unique_and_dispose(std::equal_to&lt;value_type&gt;(), detail::null_disposer());  }</a>
<a name="ln1195"> </a>
<a name="ln1196">   //! &lt;b&gt;Effects&lt;/b&gt;: Removes adjacent duplicate elements or adjacent</a>
<a name="ln1197">   //!   elements that satisfy some binary predicate from the list.</a>
<a name="ln1198">   //!   No destructors are called.</a>
<a name="ln1199">   //!</a>
<a name="ln1200">   //! &lt;b&gt;Throws&lt;/b&gt;: If pred throws. Basic guarantee.</a>
<a name="ln1201">   //!</a>
<a name="ln1202">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear time (size()-1 comparisons equality comparisons).</a>
<a name="ln1203">   //!</a>
<a name="ln1204">   //! &lt;b&gt;Note&lt;/b&gt;: The relative order of elements that are not removed is unchanged,</a>
<a name="ln1205">   //!   and iterators to elements that are not removed remain valid.</a>
<a name="ln1206">   template&lt;class BinaryPredicate&gt;</a>
<a name="ln1207">   void unique(BinaryPredicate pred)</a>
<a name="ln1208">   {  this-&gt;unique_and_dispose(pred, detail::null_disposer());  }</a>
<a name="ln1209"> </a>
<a name="ln1210">   //! &lt;b&gt;Requires&lt;/b&gt;: Disposer::operator()(pointer) shouldn't throw.</a>
<a name="ln1211">   //!</a>
<a name="ln1212">   //! &lt;b&gt;Effects&lt;/b&gt;: Removes adjacent duplicate elements or adjacent</a>
<a name="ln1213">   //!   elements that are equal from the list.</a>
<a name="ln1214">   //!   Disposer::operator()(pointer) is called for every removed element.</a>
<a name="ln1215">   //!</a>
<a name="ln1216">   //! &lt;b&gt;Throws&lt;/b&gt;: If std::equal_to&lt;value_type throws. Basic guarantee.</a>
<a name="ln1217">   //!</a>
<a name="ln1218">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear time (size()-1) comparisons equality comparisons.</a>
<a name="ln1219">   //!</a>
<a name="ln1220">   //! &lt;b&gt;Note&lt;/b&gt;: The relative order of elements that are not removed is unchanged,</a>
<a name="ln1221">   //!   and iterators to elements that are not removed remain valid.</a>
<a name="ln1222">   template&lt;class Disposer&gt;</a>
<a name="ln1223">   void unique_and_dispose(Disposer disposer)</a>
<a name="ln1224">   {  this-&gt;unique_and_dispose(std::equal_to&lt;value_type&gt;(), disposer);  }</a>
<a name="ln1225"> </a>
<a name="ln1226">   //! &lt;b&gt;Requires&lt;/b&gt;: Disposer::operator()(pointer) shouldn't throw.</a>
<a name="ln1227">   //!</a>
<a name="ln1228">   //! &lt;b&gt;Effects&lt;/b&gt;: Removes adjacent duplicate elements or adjacent</a>
<a name="ln1229">   //!   elements that satisfy some binary predicate from the list.</a>
<a name="ln1230">   //!   Disposer::operator()(pointer) is called for every removed element.</a>
<a name="ln1231">   //!</a>
<a name="ln1232">   //! &lt;b&gt;Throws&lt;/b&gt;: If pred throws. Basic guarantee.</a>
<a name="ln1233">   //!</a>
<a name="ln1234">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear time (size()-1) comparisons equality comparisons.</a>
<a name="ln1235">   //!</a>
<a name="ln1236">   //! &lt;b&gt;Note&lt;/b&gt;: The relative order of elements that are not removed is unchanged,</a>
<a name="ln1237">   //!   and iterators to elements that are not removed remain valid.</a>
<a name="ln1238">   template&lt;class BinaryPredicate, class Disposer&gt;</a>
<a name="ln1239">   void unique_and_dispose(BinaryPredicate pred, Disposer disposer)</a>
<a name="ln1240">   {</a>
<a name="ln1241">      const_iterator itend(this-&gt;cend());</a>
<a name="ln1242">      const_iterator cur(this-&gt;cbegin());</a>
<a name="ln1243"> </a>
<a name="ln1244">      if(cur != itend){</a>
<a name="ln1245">         const_iterator after(cur);</a>
<a name="ln1246">         ++after;</a>
<a name="ln1247">         while(after != itend){</a>
<a name="ln1248">            if(pred(*cur, *after)){</a>
<a name="ln1249">               after = this-&gt;erase_and_dispose(after, disposer);</a>
<a name="ln1250">            }</a>
<a name="ln1251">            else{</a>
<a name="ln1252">               cur = after;</a>
<a name="ln1253">               ++after;</a>
<a name="ln1254">            }</a>
<a name="ln1255">         }</a>
<a name="ln1256">      }</a>
<a name="ln1257">   }</a>
<a name="ln1258"> </a>
<a name="ln1259">   //! &lt;b&gt;Requires&lt;/b&gt;: value must be a reference to a value inserted in a list.</a>
<a name="ln1260">   //!</a>
<a name="ln1261">   //! &lt;b&gt;Effects&lt;/b&gt;: This function returns a const_iterator pointing to the element</a>
<a name="ln1262">   //!</a>
<a name="ln1263">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln1264">   //!</a>
<a name="ln1265">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant time.</a>
<a name="ln1266">   //!</a>
<a name="ln1267">   //! &lt;b&gt;Note&lt;/b&gt;: Iterators and references are not invalidated.</a>
<a name="ln1268">   //!   This static function is available only if the &lt;i&gt;value traits&lt;/i&gt;</a>
<a name="ln1269">   //!   is stateless.</a>
<a name="ln1270">   static iterator s_iterator_to(reference value)</a>
<a name="ln1271">   {</a>
<a name="ln1272">      BOOST_STATIC_ASSERT((!stateful_value_traits));</a>
<a name="ln1273">      BOOST_INTRUSIVE_INVARIANT_ASSERT(!node_algorithms::inited(value_traits::to_node_ptr(value)));</a>
<a name="ln1274">      return iterator(value_traits::to_node_ptr(value), const_value_traits_ptr());</a>
<a name="ln1275">   }</a>
<a name="ln1276"> </a>
<a name="ln1277">   //! &lt;b&gt;Requires&lt;/b&gt;: value must be a const reference to a value inserted in a list.</a>
<a name="ln1278">   //!</a>
<a name="ln1279">   //! &lt;b&gt;Effects&lt;/b&gt;: This function returns an iterator pointing to the element.</a>
<a name="ln1280">   //!</a>
<a name="ln1281">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln1282">   //!</a>
<a name="ln1283">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant time.</a>
<a name="ln1284">   //!</a>
<a name="ln1285">   //! &lt;b&gt;Note&lt;/b&gt;: Iterators and references are not invalidated.</a>
<a name="ln1286">   //!   This static function is available only if the &lt;i&gt;value traits&lt;/i&gt;</a>
<a name="ln1287">   //!   is stateless.</a>
<a name="ln1288">   static const_iterator s_iterator_to(const_reference value)</a>
<a name="ln1289">   {</a>
<a name="ln1290">      BOOST_STATIC_ASSERT((!stateful_value_traits));</a>
<a name="ln1291">      reference r =*detail::uncast(pointer_traits&lt;const_pointer&gt;::pointer_to(value));</a>
<a name="ln1292">      BOOST_INTRUSIVE_INVARIANT_ASSERT(!node_algorithms::inited(value_traits::to_node_ptr(r)));</a>
<a name="ln1293">      return const_iterator(value_traits::to_node_ptr(r), const_value_traits_ptr());</a>
<a name="ln1294">   }</a>
<a name="ln1295"> </a>
<a name="ln1296">   //! &lt;b&gt;Requires&lt;/b&gt;: value must be a reference to a value inserted in a list.</a>
<a name="ln1297">   //!</a>
<a name="ln1298">   //! &lt;b&gt;Effects&lt;/b&gt;: This function returns a const_iterator pointing to the element</a>
<a name="ln1299">   //!</a>
<a name="ln1300">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln1301">   //!</a>
<a name="ln1302">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant time.</a>
<a name="ln1303">   //!</a>
<a name="ln1304">   //! &lt;b&gt;Note&lt;/b&gt;: Iterators and references are not invalidated.</a>
<a name="ln1305">   iterator iterator_to(reference value)</a>
<a name="ln1306">   {</a>
<a name="ln1307">      BOOST_INTRUSIVE_INVARIANT_ASSERT(!node_algorithms::inited(this-&gt;priv_value_traits().to_node_ptr(value)));</a>
<a name="ln1308">      return iterator(this-&gt;priv_value_traits().to_node_ptr(value), this-&gt;priv_value_traits_ptr());</a>
<a name="ln1309">   }</a>
<a name="ln1310"> </a>
<a name="ln1311">   //! &lt;b&gt;Requires&lt;/b&gt;: value must be a const reference to a value inserted in a list.</a>
<a name="ln1312">   //!</a>
<a name="ln1313">   //! &lt;b&gt;Effects&lt;/b&gt;: This function returns an iterator pointing to the element.</a>
<a name="ln1314">   //!</a>
<a name="ln1315">   //! &lt;b&gt;Throws&lt;/b&gt;: Nothing.</a>
<a name="ln1316">   //!</a>
<a name="ln1317">   //! &lt;b&gt;Complexity&lt;/b&gt;: Constant time.</a>
<a name="ln1318">   //!</a>
<a name="ln1319">   //! &lt;b&gt;Note&lt;/b&gt;: Iterators and references are not invalidated.</a>
<a name="ln1320">   const_iterator iterator_to(const_reference value) const</a>
<a name="ln1321">   {</a>
<a name="ln1322">      reference r = *detail::uncast(pointer_traits&lt;const_pointer&gt;::pointer_to(value));</a>
<a name="ln1323">      BOOST_INTRUSIVE_INVARIANT_ASSERT(!node_algorithms::inited(this-&gt;priv_value_traits().to_node_ptr(r)));</a>
<a name="ln1324">      return const_iterator(this-&gt;priv_value_traits().to_node_ptr(r), this-&gt;priv_value_traits_ptr());</a>
<a name="ln1325">   }</a>
<a name="ln1326"> </a>
<a name="ln1327">   //! &lt;b&gt;Effects&lt;/b&gt;: Asserts the integrity of the container.</a>
<a name="ln1328">   //!</a>
<a name="ln1329">   //! &lt;b&gt;Complexity&lt;/b&gt;: Linear time.</a>
<a name="ln1330">   //!</a>
<a name="ln1331">   //! &lt;b&gt;Note&lt;/b&gt;: The method has no effect when asserts are turned off (e.g., with NDEBUG).</a>
<a name="ln1332">   //!   Experimental function, interface might change in future versions.</a>
<a name="ln1333">   void check() const</a>
<a name="ln1334">   {</a>
<a name="ln1335">      const_node_ptr header_ptr = get_root_node();</a>
<a name="ln1336">      // header's next and prev are never null</a>
<a name="ln1337">      BOOST_INTRUSIVE_INVARIANT_ASSERT(node_traits::get_next(header_ptr));</a>
<a name="ln1338">      BOOST_INTRUSIVE_INVARIANT_ASSERT(node_traits::get_previous(header_ptr));</a>
<a name="ln1339">      // header's next and prev either both point to header (empty list) or neither does</a>
<a name="ln1340">      BOOST_INTRUSIVE_INVARIANT_ASSERT((node_traits::get_next(header_ptr) == header_ptr)</a>
<a name="ln1341">         == (node_traits::get_previous(header_ptr) == header_ptr));</a>
<a name="ln1342">      if (node_traits::get_next(header_ptr) == header_ptr)</a>
<a name="ln1343">      {</a>
<a name="ln1344">         if (constant_time_size)</a>
<a name="ln1345">            BOOST_INTRUSIVE_INVARIANT_ASSERT(this-&gt;priv_size_traits().get_size() == 0);</a>
<a name="ln1346">         return;</a>
<a name="ln1347">      }</a>
<a name="ln1348">      size_t node_count = 0;</a>
<a name="ln1349">      const_node_ptr p = header_ptr;</a>
<a name="ln1350">      while (true)</a>
<a name="ln1351">      {</a>
<a name="ln1352">         const_node_ptr next_p = node_traits::get_next(p);</a>
<a name="ln1353">         BOOST_INTRUSIVE_INVARIANT_ASSERT(next_p);</a>
<a name="ln1354">         BOOST_INTRUSIVE_INVARIANT_ASSERT(node_traits::get_previous(next_p) == p);</a>
<a name="ln1355">         p = next_p;</a>
<a name="ln1356">         if (p == header_ptr) break;</a>
<a name="ln1357">         ++node_count;</a>
<a name="ln1358">      }</a>
<a name="ln1359">      if (constant_time_size)</a>
<a name="ln1360">         BOOST_INTRUSIVE_INVARIANT_ASSERT(this-&gt;priv_size_traits().get_size() == node_count);</a>
<a name="ln1361">   }</a>
<a name="ln1362"> </a>
<a name="ln1363">   friend bool operator==(const list_impl &amp;x, const list_impl &amp;y)</a>
<a name="ln1364">   {</a>
<a name="ln1365">      if(constant_time_size &amp;&amp; x.size() != y.size()){</a>
<a name="ln1366">         return false;</a>
<a name="ln1367">      }</a>
<a name="ln1368">      return ::boost::intrusive::algo_equal(x.cbegin(), x.cend(), y.cbegin(), y.cend());</a>
<a name="ln1369">   }</a>
<a name="ln1370"> </a>
<a name="ln1371">   friend bool operator!=(const list_impl &amp;x, const list_impl &amp;y)</a>
<a name="ln1372">   {  return !(x == y); }</a>
<a name="ln1373"> </a>
<a name="ln1374">   friend bool operator&lt;(const list_impl &amp;x, const list_impl &amp;y)</a>
<a name="ln1375">   {  return ::boost::intrusive::algo_lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());  }</a>
<a name="ln1376"> </a>
<a name="ln1377">   friend bool operator&gt;(const list_impl &amp;x, const list_impl &amp;y)</a>
<a name="ln1378">   {  return y &lt; x;  }</a>
<a name="ln1379"> </a>
<a name="ln1380">   friend bool operator&lt;=(const list_impl &amp;x, const list_impl &amp;y)</a>
<a name="ln1381">   {  return !(y &lt; x);  }</a>
<a name="ln1382"> </a>
<a name="ln1383">   friend bool operator&gt;=(const list_impl &amp;x, const list_impl &amp;y)</a>
<a name="ln1384">   {  return !(x &lt; y);  }</a>
<a name="ln1385"> </a>
<a name="ln1386">   friend void swap(list_impl &amp;x, list_impl &amp;y)</a>
<a name="ln1387">   {  x.swap(y);  }</a>
<a name="ln1388"> </a>
<a name="ln1389">   /// @cond</a>
<a name="ln1390"> </a>
<a name="ln1391">   private:</a>
<a name="ln1392">   static list_impl &amp;priv_container_from_end_iterator(const const_iterator &amp;end_iterator)</a>
<a name="ln1393">   {</a>
<a name="ln1394">      BOOST_STATIC_ASSERT((has_container_from_iterator));</a>
<a name="ln1395">      node_ptr p = end_iterator.pointed_node();</a>
<a name="ln1396">      header_holder_type* h = header_holder_type::get_holder(p);</a>
<a name="ln1397">      root_plus_size* r = detail::parent_from_member</a>
<a name="ln1398">         &lt; root_plus_size, header_holder_type&gt;(h, &amp;root_plus_size::m_header);</a>
<a name="ln1399">      data_t *d = detail::parent_from_member&lt;data_t, root_plus_size&gt;</a>
<a name="ln1400">         ( r, &amp;data_t::root_plus_size_);</a>
<a name="ln1401">      list_impl *s  = detail::parent_from_member&lt;list_impl, data_t&gt;(d, &amp;list_impl::data_);</a>
<a name="ln1402">      return *s;</a>
<a name="ln1403">   }</a>
<a name="ln1404">   /// @endcond</a>
<a name="ln1405">};</a>
<a name="ln1406"> </a>
<a name="ln1407"> </a>
<a name="ln1408">//! Helper metafunction to define a \c list that yields to the same type when the</a>
<a name="ln1409">//! same options (either explicitly or implicitly) are used.</a>
<a name="ln1410">#if defined(BOOST_INTRUSIVE_DOXYGEN_INVOKED) || defined(BOOST_INTRUSIVE_VARIADIC_TEMPLATES)</a>
<a name="ln1411">template&lt;class T, class ...Options&gt;</a>
<a name="ln1412">#else</a>
<a name="ln1413">template&lt;class T, class O1 = void, class O2 = void, class O3 = void, class O4 = void&gt;</a>
<a name="ln1414">#endif</a>
<a name="ln1415">struct make_list</a>
<a name="ln1416">{</a>
<a name="ln1417">   /// @cond</a>
<a name="ln1418">   typedef typename pack_options</a>
<a name="ln1419">      &lt; list_defaults,</a>
<a name="ln1420">         #if !defined(BOOST_INTRUSIVE_VARIADIC_TEMPLATES)</a>
<a name="ln1421">         O1, O2, O3, O4</a>
<a name="ln1422">         #else</a>
<a name="ln1423">         Options...</a>
<a name="ln1424">         #endif</a>
<a name="ln1425">      &gt;::type packed_options;</a>
<a name="ln1426"> </a>
<a name="ln1427">   typedef typename detail::get_value_traits</a>
<a name="ln1428">      &lt;T, typename packed_options::proto_value_traits&gt;::type value_traits;</a>
<a name="ln1429">   typedef list_impl</a>
<a name="ln1430">      &lt;</a>
<a name="ln1431">         value_traits,</a>
<a name="ln1432">         typename packed_options::size_type,</a>
<a name="ln1433">         packed_options::constant_time_size,</a>
<a name="ln1434">         typename packed_options::header_holder_type</a>
<a name="ln1435">      &gt; implementation_defined;</a>
<a name="ln1436">   /// @endcond</a>
<a name="ln1437">   typedef implementation_defined type;</a>
<a name="ln1438">};</a>
<a name="ln1439"> </a>
<a name="ln1440"> </a>
<a name="ln1441">#ifndef BOOST_INTRUSIVE_DOXYGEN_INVOKED</a>
<a name="ln1442"> </a>
<a name="ln1443">#if !defined(BOOST_INTRUSIVE_VARIADIC_TEMPLATES)</a>
<a name="ln1444">template&lt;class T, class O1, class O2, class O3, class O4&gt;</a>
<a name="ln1445">#else</a>
<a name="ln1446">template&lt;class T, class ...Options&gt;</a>
<a name="ln1447">#endif</a>
<a name="ln1448">class list</a>
<a name="ln1449">   :  public make_list&lt;T,</a>
<a name="ln1450">      #if !defined(BOOST_INTRUSIVE_VARIADIC_TEMPLATES)</a>
<a name="ln1451">      O1, O2, O3, O4</a>
<a name="ln1452">      #else</a>
<a name="ln1453">      Options...</a>
<a name="ln1454">      #endif</a>
<a name="ln1455">   &gt;::type</a>
<a name="ln1456">{</a>
<a name="ln1457">   typedef typename make_list</a>
<a name="ln1458">      &lt;T,</a>
<a name="ln1459">      #if !defined(BOOST_INTRUSIVE_VARIADIC_TEMPLATES)</a>
<a name="ln1460">      O1, O2, O3, O4</a>
<a name="ln1461">      #else</a>
<a name="ln1462">      Options...</a>
<a name="ln1463">      #endif</a>
<a name="ln1464">      &gt;::type      Base;</a>
<a name="ln1465">   //Assert if passed value traits are compatible with the type</a>
<a name="ln1466">   BOOST_STATIC_ASSERT((detail::is_same&lt;typename Base::value_traits::value_type, T&gt;::value));</a>
<a name="ln1467">   BOOST_MOVABLE_BUT_NOT_COPYABLE(list)</a>
<a name="ln1468"> </a>
<a name="ln1469">   public:</a>
<a name="ln1470">   typedef typename Base::value_traits          value_traits;</a>
<a name="ln1471">   typedef typename Base::iterator              iterator;</a>
<a name="ln1472">   typedef typename Base::const_iterator        const_iterator;</a>
<a name="ln1473"> </a>
<a name="ln1474">   list()</a>
<a name="ln1475">      :  Base()</a>
<a name="ln1476">   {}</a>
<a name="ln1477"> </a>
<a name="ln1478">   explicit list(const value_traits &amp;v_traits)</a>
<a name="ln1479">      :  Base(v_traits)</a>
<a name="ln1480">   {}</a>
<a name="ln1481"> </a>
<a name="ln1482">   template&lt;class Iterator&gt;</a>
<a name="ln1483">   list(Iterator b, Iterator e, const value_traits &amp;v_traits = value_traits())</a>
<a name="ln1484">      :  Base(b, e, v_traits)</a>
<a name="ln1485">   {}</a>
<a name="ln1486"> </a>
<a name="ln1487">   list(BOOST_RV_REF(list) x)</a>
<a name="ln1488">      :  Base(BOOST_MOVE_BASE(Base, x))</a>
<a name="ln1489">   {}</a>
<a name="ln1490"> </a>
<a name="ln1491">   list&amp; operator=(BOOST_RV_REF(list) x)</a>
<a name="ln1492">   {  return static_cast&lt;list &amp;&gt;(this-&gt;Base::operator=(BOOST_MOVE_BASE(Base, x)));  }</a>
<a name="ln1493"> </a>
<a name="ln1494">   template &lt;class Cloner, class Disposer&gt;</a>
<a name="ln1495">   void clone_from(const list &amp;src, Cloner cloner, Disposer disposer)</a>
<a name="ln1496">   {  Base::clone_from(src, cloner, disposer);  }</a>
<a name="ln1497"> </a>
<a name="ln1498">   template &lt;class Cloner, class Disposer&gt;</a>
<a name="ln1499">   void clone_from(BOOST_RV_REF(list) src, Cloner cloner, Disposer disposer)</a>
<a name="ln1500">   {  Base::clone_from(BOOST_MOVE_BASE(Base, src), cloner, disposer);  }</a>
<a name="ln1501"> </a>
<a name="ln1502">   static list &amp;container_from_end_iterator(iterator end_iterator)</a>
<a name="ln1503">   {  return static_cast&lt;list &amp;&gt;(Base::container_from_end_iterator(end_iterator));   }</a>
<a name="ln1504"> </a>
<a name="ln1505">   static const list &amp;container_from_end_iterator(const_iterator end_iterator)</a>
<a name="ln1506">   {  return static_cast&lt;const list &amp;&gt;(Base::container_from_end_iterator(end_iterator));   }</a>
<a name="ln1507">};</a>
<a name="ln1508"> </a>
<a name="ln1509">#endif</a>
<a name="ln1510"> </a>
<a name="ln1511">} //namespace intrusive</a>
<a name="ln1512">} //namespace boost</a>
<a name="ln1513"> </a>
<a name="ln1514">#include &lt;boost/intrusive/detail/config_end.hpp&gt;</a>
<a name="ln1515"> </a>
<a name="ln1516">#endif //BOOST_INTRUSIVE_LIST_HPP</a>

</code></pre>
<div class="balloon" rel="144"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: root_plus_size_.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
