
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>docdb_test_util.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Copyright (c) YugaByte, Inc.</a>
<a name="ln2">//</a>
<a name="ln3">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln4">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln5">//</a>
<a name="ln6">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln7">//</a>
<a name="ln8">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln9">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln10">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln11">// under the License.</a>
<a name="ln12">//</a>
<a name="ln13"> </a>
<a name="ln14">#include &quot;yb/docdb/docdb_test_util.h&quot;</a>
<a name="ln15"> </a>
<a name="ln16">#include &lt;algorithm&gt;</a>
<a name="ln17">#include &lt;memory&gt;</a>
<a name="ln18">#include &lt;sstream&gt;</a>
<a name="ln19"> </a>
<a name="ln20">#include &quot;yb/rocksdb/table.h&quot;</a>
<a name="ln21">#include &quot;yb/rocksdb/util/statistics.h&quot;</a>
<a name="ln22"> </a>
<a name="ln23">#include &quot;yb/common/hybrid_time.h&quot;</a>
<a name="ln24">#include &quot;yb/docdb/doc_key.h&quot;</a>
<a name="ln25">#include &quot;yb/docdb/doc_reader.h&quot;</a>
<a name="ln26">#include &quot;yb/docdb/docdb-internal.h&quot;</a>
<a name="ln27">#include &quot;yb/docdb/docdb.h&quot;</a>
<a name="ln28">#include &quot;yb/docdb/docdb_compaction_filter.h&quot;</a>
<a name="ln29">#include &quot;yb/docdb/docdb_rocksdb_util.h&quot;</a>
<a name="ln30">#include &quot;yb/docdb/in_mem_docdb.h&quot;</a>
<a name="ln31">#include &quot;yb/gutil/strings/substitute.h&quot;</a>
<a name="ln32">#include &quot;yb/rocksutil/write_batch_formatter.h&quot;</a>
<a name="ln33">#include &quot;yb/rocksutil/yb_rocksdb.h&quot;</a>
<a name="ln34">#include &quot;yb/util/bytes_formatter.h&quot;</a>
<a name="ln35">#include &quot;yb/util/path_util.h&quot;</a>
<a name="ln36">#include &quot;yb/util/scope_exit.h&quot;</a>
<a name="ln37">#include &quot;yb/util/status.h&quot;</a>
<a name="ln38">#include &quot;yb/util/string_trim.h&quot;</a>
<a name="ln39">#include &quot;yb/util/test_macros.h&quot;</a>
<a name="ln40">#include &quot;yb/util/test_util.h&quot;</a>
<a name="ln41">#include &quot;yb/util/tostring.h&quot;</a>
<a name="ln42">#include &quot;yb/util/algorithm_util.h&quot;</a>
<a name="ln43">#include &quot;yb/util/string_util.h&quot;</a>
<a name="ln44">#include &quot;yb/tablet/tablet_options.h&quot;</a>
<a name="ln45">#include &quot;yb/rocksdb/db/filename.h&quot;</a>
<a name="ln46"> </a>
<a name="ln47">using std::endl;</a>
<a name="ln48">using std::make_shared;</a>
<a name="ln49">using std::string;</a>
<a name="ln50">using std::unique_ptr;</a>
<a name="ln51">using std::vector;</a>
<a name="ln52">using std::stringstream;</a>
<a name="ln53"> </a>
<a name="ln54">using strings::Substitute;</a>
<a name="ln55"> </a>
<a name="ln56">using yb::util::ApplyEagerLineContinuation;</a>
<a name="ln57">using yb::FormatBytesAsStr;</a>
<a name="ln58">using yb::util::TrimStr;</a>
<a name="ln59">using yb::util::LeftShiftTextBlock;</a>
<a name="ln60">using yb::util::TrimCppComments;</a>
<a name="ln61"> </a>
<a name="ln62">namespace yb {</a>
<a name="ln63">namespace docdb {</a>
<a name="ln64"> </a>
<a name="ln65">namespace {</a>
<a name="ln66"> </a>
<a name="ln67">class NonTransactionalStatusProvider: public TransactionStatusManager {</a>
<a name="ln68"> public:</a>
<a name="ln69">  HybridTime LocalCommitTime(const TransactionId &amp;id) override {</a>
<a name="ln70">    Fail();</a>
<a name="ln71">    return HybridTime::kInvalid;</a>
<a name="ln72">  }</a>
<a name="ln73"> </a>
<a name="ln74">  void RequestStatusAt(const StatusRequest&amp; request) override {</a>
<a name="ln75">    Fail();</a>
<a name="ln76">  }</a>
<a name="ln77"> </a>
<a name="ln78">  Result&lt;TransactionMetadata&gt; PrepareMetadata(const TransactionMetadataPB&amp; pb) override {</a>
<a name="ln79">    Fail();</a>
<a name="ln80">    return STATUS(Expired, &quot;&quot;);</a>
<a name="ln81">  }</a>
<a name="ln82"> </a>
<a name="ln83">  int64_t RegisterRequest() override {</a>
<a name="ln84">    Fail();</a>
<a name="ln85">    return 0;</a>
<a name="ln86">  }</a>
<a name="ln87"> </a>
<a name="ln88">  void UnregisterRequest(int64_t) override {</a>
<a name="ln89">    Fail();</a>
<a name="ln90">  }</a>
<a name="ln91"> </a>
<a name="ln92">  void Abort(const TransactionId&amp; id, TransactionStatusCallback callback) override {</a>
<a name="ln93">    Fail();</a>
<a name="ln94">  }</a>
<a name="ln95"> </a>
<a name="ln96">  void Cleanup(TransactionIdSet&amp;&amp; set) override {</a>
<a name="ln97">    Fail();</a>
<a name="ln98">  }</a>
<a name="ln99"> </a>
<a name="ln100">  void FillPriorities(</a>
<a name="ln101">      boost::container::small_vector_base&lt;std::pair&lt;TransactionId, uint64_t&gt;&gt;* inout) override {</a>
<a name="ln102">    Fail();</a>
<a name="ln103">  }</a>
<a name="ln104"> </a>
<a name="ln105">  HybridTime MinRunningHybridTime() const override {</a>
<a name="ln106">    return HybridTime::kMax;</a>
<a name="ln107">  }</a>
<a name="ln108"> </a>
<a name="ln109"> private:</a>
<a name="ln110">  static void Fail() {</a>
<a name="ln111">    LOG(FATAL) &lt;&lt; &quot;Internal error: trying to get transaction status for non transactional table&quot;;</a>
<a name="ln112">  }</a>
<a name="ln113">};</a>
<a name="ln114"> </a>
<a name="ln115">NonTransactionalStatusProvider kNonTransactionalStatusProvider;</a>
<a name="ln116"> </a>
<a name="ln117">} // namespace</a>
<a name="ln118"> </a>
<a name="ln119">const TransactionOperationContext kNonTransactionalOperationContext = {</a>
<a name="ln120">    TransactionId::Nil(), &amp;kNonTransactionalStatusProvider</a>
<a name="ln121">};</a>
<a name="ln122"> </a>
<a name="ln123">PrimitiveValue GenRandomPrimitiveValue(RandomNumberGenerator* rng) {</a>
<a name="ln124">  static vector&lt;string&gt; kFruit = {</a>
<a name="ln125">      &quot;Apple&quot;,</a>
<a name="ln126">      &quot;Apricot&quot;,</a>
<a name="ln127">      &quot;Avocado&quot;,</a>
<a name="ln128">      &quot;Banana&quot;,</a>
<a name="ln129">      &quot;Bilberry&quot;,</a>
<a name="ln130">      &quot;Blackberry&quot;,</a>
<a name="ln131">      &quot;Blackcurrant&quot;,</a>
<a name="ln132">      &quot;Blood orange&quot;,</a>
<a name="ln133">      &quot;Blueberry&quot;,</a>
<a name="ln134">      &quot;Boysenberry&quot;,</a>
<a name="ln135">      &quot;Cantaloupe&quot;,</a>
<a name="ln136">      &quot;Cherimoya&quot;,</a>
<a name="ln137">      &quot;Cherry&quot;,</a>
<a name="ln138">      &quot;Clementine&quot;,</a>
<a name="ln139">      &quot;Cloudberry&quot;,</a>
<a name="ln140">      &quot;Coconut&quot;,</a>
<a name="ln141">      &quot;Cranberry&quot;,</a>
<a name="ln142">      &quot;Cucumber&quot;,</a>
<a name="ln143">      &quot;Currant&quot;,</a>
<a name="ln144">      &quot;Custard apple&quot;,</a>
<a name="ln145">      &quot;Damson&quot;,</a>
<a name="ln146">      &quot;Date&quot;,</a>
<a name="ln147">      &quot;Decaisnea Fargesii&quot;,</a>
<a name="ln148">      &quot;Dragonfruit&quot;,</a>
<a name="ln149">      &quot;Durian&quot;,</a>
<a name="ln150">      &quot;Elderberry&quot;,</a>
<a name="ln151">      &quot;Feijoa&quot;,</a>
<a name="ln152">      &quot;Fig&quot;,</a>
<a name="ln153">      &quot;Goji berry&quot;,</a>
<a name="ln154">      &quot;Gooseberry&quot;,</a>
<a name="ln155">      &quot;Grape&quot;,</a>
<a name="ln156">      &quot;Grapefruit&quot;,</a>
<a name="ln157">      &quot;Guava&quot;,</a>
<a name="ln158">      &quot;Honeyberry&quot;,</a>
<a name="ln159">      &quot;Honeydew&quot;,</a>
<a name="ln160">      &quot;Huckleberry&quot;,</a>
<a name="ln161">      &quot;Jabuticaba&quot;,</a>
<a name="ln162">      &quot;Jackfruit&quot;,</a>
<a name="ln163">      &quot;Jambul&quot;,</a>
<a name="ln164">      &quot;Jujube&quot;,</a>
<a name="ln165">      &quot;Juniper berry&quot;,</a>
<a name="ln166">      &quot;Kiwifruit&quot;,</a>
<a name="ln167">      &quot;Kumquat&quot;,</a>
<a name="ln168">      &quot;Lemon&quot;,</a>
<a name="ln169">      &quot;Lime&quot;,</a>
<a name="ln170">      &quot;Longan&quot;,</a>
<a name="ln171">      &quot;Loquat&quot;,</a>
<a name="ln172">      &quot;Lychee&quot;,</a>
<a name="ln173">      &quot;Mandarine&quot;,</a>
<a name="ln174">      &quot;Mango&quot;,</a>
<a name="ln175">      &quot;Marionberry&quot;,</a>
<a name="ln176">      &quot;Melon&quot;,</a>
<a name="ln177">      &quot;Miracle fruit&quot;,</a>
<a name="ln178">      &quot;Mulberry&quot;,</a>
<a name="ln179">      &quot;Nance&quot;,</a>
<a name="ln180">      &quot;Nectarine&quot;,</a>
<a name="ln181">      &quot;Olive&quot;,</a>
<a name="ln182">      &quot;Orange&quot;,</a>
<a name="ln183">      &quot;Papaya&quot;,</a>
<a name="ln184">      &quot;Passionfruit&quot;,</a>
<a name="ln185">      &quot;Peach&quot;,</a>
<a name="ln186">      &quot;Pear&quot;,</a>
<a name="ln187">      &quot;Persimmon&quot;,</a>
<a name="ln188">      &quot;Physalis&quot;,</a>
<a name="ln189">      &quot;Pineapple&quot;,</a>
<a name="ln190">      &quot;Plantain&quot;,</a>
<a name="ln191">      &quot;Plum&quot;,</a>
<a name="ln192">      &quot;Plumcot (or Pluot)&quot;,</a>
<a name="ln193">      &quot;Pomegranate&quot;,</a>
<a name="ln194">      &quot;Pomelo&quot;,</a>
<a name="ln195">      &quot;Prune (dried plum)&quot;,</a>
<a name="ln196">      &quot;Purple mangosteen&quot;,</a>
<a name="ln197">      &quot;Quince&quot;,</a>
<a name="ln198">      &quot;Raisin&quot;,</a>
<a name="ln199">      &quot;Rambutan&quot;,</a>
<a name="ln200">      &quot;Raspberry&quot;,</a>
<a name="ln201">      &quot;Redcurrant&quot;,</a>
<a name="ln202">      &quot;Salak&quot;,</a>
<a name="ln203">      &quot;Salal berry&quot;,</a>
<a name="ln204">      &quot;Salmonberry&quot;,</a>
<a name="ln205">      &quot;Satsuma&quot;,</a>
<a name="ln206">      &quot;Star fruit&quot;,</a>
<a name="ln207">      &quot;Strawberry&quot;,</a>
<a name="ln208">      &quot;Tamarillo&quot;,</a>
<a name="ln209">      &quot;Tamarind&quot;,</a>
<a name="ln210">      &quot;Tangerine&quot;,</a>
<a name="ln211">      &quot;Tomato&quot;,</a>
<a name="ln212">      &quot;Ugli fruit&quot;,</a>
<a name="ln213">      &quot;Watermelon&quot;,</a>
<a name="ln214">      &quot;Yuzu&quot;</a>
<a name="ln215">  };</a>
<a name="ln216">  switch ((*rng)() % 6) {</a>
<a name="ln217">    case 0:</a>
<a name="ln218">      return PrimitiveValue(static_cast&lt;int64_t&gt;((*rng)()));</a>
<a name="ln219">    case 1: {</a>
<a name="ln220">      string s;</a>
<a name="ln221">      for (int j = 0; j &lt; (*rng)() % 50; ++j) {</a>
<a name="ln222">        s.push_back((*rng)() &amp; 0xff);</a>
<a name="ln223">      }</a>
<a name="ln224">      return PrimitiveValue(s);</a>
<a name="ln225">    }</a>
<a name="ln226">    case 2: return PrimitiveValue(ValueType::kNullLow);</a>
<a name="ln227">    case 3: return PrimitiveValue(ValueType::kTrue);</a>
<a name="ln228">    case 4: return PrimitiveValue(ValueType::kFalse);</a>
<a name="ln229">    case 5: return PrimitiveValue(kFruit[(*rng)() % kFruit.size()]);</a>
<a name="ln230">  }</a>
<a name="ln231">  LOG(FATAL) &lt;&lt; &quot;Should never get here&quot;;</a>
<a name="ln232">  return PrimitiveValue();  // to make the compiler happy</a>
<a name="ln233">}</a>
<a name="ln234"> </a>
<a name="ln235"> </a>
<a name="ln236">// Generate a vector of random primitive values.</a>
<a name="ln237">vector&lt;PrimitiveValue&gt; GenRandomPrimitiveValues(RandomNumberGenerator* rng, int max_num) {</a>
<a name="ln238">  vector&lt;PrimitiveValue&gt; result;</a>
<a name="ln239">  for (int i = 0; i &lt; (*rng)() % (max_num + 1); ++i) {</a>
<a name="ln240">    result.push_back(GenRandomPrimitiveValue(rng));</a>
<a name="ln241">  }</a>
<a name="ln242">  return result;</a>
<a name="ln243">}</a>
<a name="ln244"> </a>
<a name="ln245">DocKey CreateMinimalDocKey(RandomNumberGenerator* rng, UseHash use_hash) {</a>
<a name="ln246">  return use_hash ? DocKey(static_cast&lt;DocKeyHash&gt;((*rng)()), std::vector&lt;PrimitiveValue&gt;(),</a>
<a name="ln247">      std::vector&lt;PrimitiveValue&gt;()) : DocKey();</a>
<a name="ln248">}</a>
<a name="ln249"> </a>
<a name="ln250">DocKey GenRandomDocKey(RandomNumberGenerator* rng, UseHash use_hash) {</a>
<a name="ln251">  if (use_hash) {</a>
<a name="ln252">    return DocKey(</a>
<a name="ln253">        static_cast&lt;uint32_t&gt;((*rng)()),  // this is just a random value, not a hash function result</a>
<a name="ln254">        GenRandomPrimitiveValues(rng),</a>
<a name="ln255">        GenRandomPrimitiveValues(rng));</a>
<a name="ln256">  } else {</a>
<a name="ln257">    return DocKey(GenRandomPrimitiveValues(rng));</a>
<a name="ln258">  }</a>
<a name="ln259">}</a>
<a name="ln260"> </a>
<a name="ln261">vector&lt;DocKey&gt; GenRandomDocKeys(RandomNumberGenerator* rng, UseHash use_hash, int num_keys) {</a>
<a name="ln262">  vector&lt;DocKey&gt; result;</a>
<a name="ln263">  result.push_back(CreateMinimalDocKey(rng, use_hash));</a>
<a name="ln264">  for (int iteration = 0; iteration &lt; num_keys; ++iteration) {</a>
<a name="ln265">    result.push_back(GenRandomDocKey(rng, use_hash));</a>
<a name="ln266">  }</a>
<a name="ln267">  return result;</a>
<a name="ln268">}</a>
<a name="ln269"> </a>
<a name="ln270">vector&lt;SubDocKey&gt; GenRandomSubDocKeys(RandomNumberGenerator* rng, UseHash use_hash, int num_keys) {</a>
<a name="ln271">  vector&lt;SubDocKey&gt; result;</a>
<a name="ln272">  result.push_back(SubDocKey(CreateMinimalDocKey(rng, use_hash), HybridTime((*rng)())));</a>
<a name="ln273">  for (int iteration = 0; iteration &lt; num_keys; ++iteration) {</a>
<a name="ln274">    result.push_back(SubDocKey(GenRandomDocKey(rng, use_hash)));</a>
<a name="ln275">    for (int i = 0; i &lt; (*rng)() % (kMaxNumRandomSubKeys + 1); ++i) {</a>
<a name="ln276">      result.back().AppendSubKeysAndMaybeHybridTime(GenRandomPrimitiveValue(rng));</a>
<a name="ln277">    }</a>
<a name="ln278">    const IntraTxnWriteId write_id = static_cast&lt;IntraTxnWriteId&gt;(</a>
<a name="ln279">        (*rng)() % 2 == 0 ? 0 : (*rng)() % 1000000);</a>
<a name="ln280">    result.back().set_hybrid_time(DocHybridTime(HybridTime((*rng)()), write_id));</a>
<a name="ln281">  }</a>
<a name="ln282">  return result;</a>
<a name="ln283">}</a>
<a name="ln284">// ------------------------------------------------------------------------------------------------</a>
<a name="ln285"> </a>
<a name="ln286">void LogicalRocksDBDebugSnapshot::Capture(rocksdb::DB* rocksdb) {</a>
<a name="ln287">  kvs.clear();</a>
<a name="ln288">  rocksdb::ReadOptions read_options;</a>
<a name="ln289">  auto iter = unique_ptr&lt;rocksdb::Iterator&gt;(rocksdb-&gt;NewIterator(read_options));</a>
<a name="ln290">  iter-&gt;SeekToFirst();</a>
<a name="ln291">  while (iter-&gt;Valid()) {</a>
<a name="ln292">    kvs.emplace_back(iter-&gt;key().ToBuffer(), iter-&gt;value().ToBuffer());</a>
<a name="ln293">    iter-&gt;Next();</a>
<a name="ln294">  }</a>
<a name="ln295">  // Save the DocDB debug dump as a string so we can check that we've properly restored the snapshot</a>
<a name="ln296">  // in RestoreTo.</a>
<a name="ln297">  docdb_debug_dump_str = DocDBDebugDumpToStr(rocksdb);</a>
<a name="ln298">}</a>
<a name="ln299"> </a>
<a name="ln300">void LogicalRocksDBDebugSnapshot::RestoreTo(rocksdb::DB *rocksdb) const {</a>
<a name="ln301">  rocksdb::ReadOptions read_options;</a>
<a name="ln302">  rocksdb::WriteOptions write_options;</a>
<a name="ln303">  auto iter = unique_ptr&lt;rocksdb::Iterator&gt;(rocksdb-&gt;NewIterator(read_options));</a>
<a name="ln304">  iter-&gt;SeekToFirst();</a>
<a name="ln305">  while (iter-&gt;Valid()) {</a>
<a name="ln306">    ASSERT_OK(rocksdb-&gt;Delete(write_options, iter-&gt;key()));</a>
<a name="ln307">    iter-&gt;Next();</a>
<a name="ln308">  }</a>
<a name="ln309">  for (const auto&amp; kv : kvs) {</a>
<a name="ln310">    ASSERT_OK(rocksdb-&gt;Put(write_options, kv.first, kv.second));</a>
<a name="ln311">  }</a>
<a name="ln312">  ASSERT_OK(FullyCompactDB(rocksdb));</a>
<a name="ln313">  ASSERT_EQ(docdb_debug_dump_str, DocDBDebugDumpToStr(rocksdb));</a>
<a name="ln314">}</a>
<a name="ln315"> </a>
<a name="ln316">// ------------------------------------------------------------------------------------------------</a>
<a name="ln317"> </a>
<a name="ln318">DocDBLoadGenerator::DocDBLoadGenerator(DocDBRocksDBFixture* fixture,</a>
<a name="ln319">                                       const int num_doc_keys,</a>
<a name="ln320">                                       const int num_unique_subkeys,</a>
<a name="ln321">                                       const UseHash use_hash,</a>
<a name="ln322">                                       const ResolveIntentsDuringRead resolve_intents,</a>
<a name="ln323">                                       const int deletion_chance,</a>
<a name="ln324">                                       const int max_nesting_level,</a>
<a name="ln325">                                       const uint64 random_seed,</a>
<a name="ln326">                                       const int verification_frequency)</a>
<a name="ln327">    : fixture_(fixture),</a>
<a name="ln328">      doc_keys_(GenRandomDocKeys(&amp;random_, use_hash, num_doc_keys)),</a>
<a name="ln329">      resolve_intents_(resolve_intents),</a>
<a name="ln330">      possible_subkeys_(GenRandomPrimitiveValues(&amp;random_, num_unique_subkeys)),</a>
<a name="ln331">      iteration_(1),</a>
<a name="ln332">      deletion_chance_(deletion_chance),</a>
<a name="ln333">      max_nesting_level_(max_nesting_level),</a>
<a name="ln334">      verification_frequency_(verification_frequency) {</a>
<a name="ln335">  CHECK_GE(max_nesting_level_, 1);</a>
<a name="ln336">  // Use a fixed seed so that tests are deterministic.</a>
<a name="ln337">  random_.seed(random_seed);</a>
<a name="ln338"> </a>
<a name="ln339">  // This is done so we can use VerifySnapshot with in_mem_docdb_. That should preform a &quot;latest&quot;</a>
<a name="ln340">  // read.</a>
<a name="ln341">  in_mem_docdb_.SetCaptureHybridTime(HybridTime::kMax);</a>
<a name="ln342">}</a>
<a name="ln343"> </a>
<a name="ln344">void DocDBLoadGenerator::PerformOperation(bool compact_history) {</a>
<a name="ln345">  // Increment the iteration right away so we can return from the function at any time.</a>
<a name="ln346">  const int current_iteration = iteration_;</a>
<a name="ln347">  ++iteration_;</a>
<a name="ln348"> </a>
<a name="ln349">  DOCDB_DEBUG_LOG(&quot;Starting iteration i=$0&quot;, current_iteration);</a>
<a name="ln350">  auto dwb = fixture_-&gt;MakeDocWriteBatch();</a>
<a name="ln351">  const auto&amp; doc_key = RandomElementOf(doc_keys_, &amp;random_);</a>
<a name="ln352">  const KeyBytes encoded_doc_key(doc_key.Encode());</a>
<a name="ln353"> </a>
<a name="ln354">  const SubDocument* current_doc = in_mem_docdb_.GetDocument(doc_key);</a>
<a name="ln355"> </a>
<a name="ln356">  bool is_deletion = false;</a>
<a name="ln357">  if (current_doc != nullptr &amp;&amp;</a>
<a name="ln358">      current_doc-&gt;value_type() != ValueType::kObject) {</a>
<a name="ln359">    // The entire document is not an object, let's delete it.</a>
<a name="ln360">    is_deletion = true;</a>
<a name="ln361">  }</a>
<a name="ln362"> </a>
<a name="ln363">  vector&lt;PrimitiveValue&gt; subkeys;</a>
<a name="ln364">  if (!is_deletion) {</a>
<a name="ln365">    // Add up to (max_nesting_level_ - 1) subkeys. Combined with the document key itself, this</a>
<a name="ln366">    // gives us the desired maximum nesting level.</a>
<a name="ln367">    for (int j = 0; j &lt; random_() % max_nesting_level_; ++j) {</a>
<a name="ln368">      if (current_doc != nullptr &amp;&amp; current_doc-&gt;value_type() != ValueType::kObject) {</a>
<a name="ln369">        // We can't add any more subkeys because we've found a primitive subdocument.</a>
<a name="ln370">        break;</a>
<a name="ln371">      }</a>
<a name="ln372">      subkeys.emplace_back(RandomElementOf(possible_subkeys_, &amp;random_));</a>
<a name="ln373">      if (current_doc != nullptr) {</a>
<a name="ln374">        current_doc = current_doc-&gt;GetChild(subkeys.back());</a>
<a name="ln375">      }</a>
<a name="ln376">    }</a>
<a name="ln377">  }</a>
<a name="ln378"> </a>
<a name="ln379">  const DocPath doc_path(encoded_doc_key, subkeys);</a>
<a name="ln380">  const auto value = GenRandomPrimitiveValue(&amp;random_);</a>
<a name="ln381">  const HybridTime hybrid_time(current_iteration);</a>
<a name="ln382">  last_operation_ht_ = hybrid_time;</a>
<a name="ln383"> </a>
<a name="ln384">  if (random_() % deletion_chance_ == 0) {</a>
<a name="ln385">    is_deletion = true;</a>
<a name="ln386">  }</a>
<a name="ln387"> </a>
<a name="ln388">  const bool doc_already_exists_in_mem =</a>
<a name="ln389">      in_mem_docdb_.GetDocument(doc_key) != nullptr;</a>
<a name="ln390"> </a>
<a name="ln391">  if (is_deletion) {</a>
<a name="ln392">    DOCDB_DEBUG_LOG(&quot;Iteration $0: deleting doc path $1&quot;, current_iteration, doc_path.ToString());</a>
<a name="ln393">    ASSERT_OK(dwb.DeleteSubDoc(doc_path, ReadHybridTime::Max()));</a>
<a name="ln394">    ASSERT_OK(in_mem_docdb_.DeleteSubDoc(doc_path));</a>
<a name="ln395">  } else {</a>
<a name="ln396">    DOCDB_DEBUG_LOG(&quot;Iteration $0: setting value at doc path $1 to $2&quot;,</a>
<a name="ln397">                    current_iteration, doc_path.ToString(), value.ToString());</a>
<a name="ln398">    ASSERT_OK(in_mem_docdb_.SetPrimitive(doc_path, value));</a>
<a name="ln399">    const auto set_primitive_status = dwb.SetPrimitive(doc_path, value);</a>
<a name="ln400">    if (!set_primitive_status.ok()) {</a>
<a name="ln401">      DocDBDebugDump(rocksdb(), std::cerr, StorageDbType::kRegular);</a>
<a name="ln402">      LOG(INFO) &lt;&lt; &quot;doc_path=&quot; &lt;&lt; doc_path.ToString();</a>
<a name="ln403">    }</a>
<a name="ln404">    ASSERT_OK(set_primitive_status);</a>
<a name="ln405">  }</a>
<a name="ln406"> </a>
<a name="ln407">  // We perform our randomly chosen operation first, both on the production version of DocDB</a>
<a name="ln408">  // sitting on top of RocksDB, and on the in-memory single-threaded debug version used for</a>
<a name="ln409">  // validation.</a>
<a name="ln410">  ASSERT_OK(fixture_-&gt;WriteToRocksDB(dwb, hybrid_time));</a>
<a name="ln411">  const SubDocument* const subdoc_from_mem = in_mem_docdb_.GetDocument(doc_key);</a>
<a name="ln412"> </a>
<a name="ln413">  TransactionOperationContextOpt txn_op_context = GetReadOperationTransactionContext();</a>
<a name="ln414"> </a>
<a name="ln415">  // In case we are asked to compact history, we read the document from RocksDB before and after the</a>
<a name="ln416">  // compaction, and expect to get the same result in both cases.</a>
<a name="ln417">  for (int do_compaction_now = 0; do_compaction_now &lt;= compact_history; ++do_compaction_now) {</a>
<a name="ln418">    if (do_compaction_now) {</a>
<a name="ln419">      // This will happen between the two iterations of the loop. If compact_history is false,</a>
<a name="ln420">      // there is only one iteration and the compaction does not happen.</a>
<a name="ln421">      fixture_-&gt;FullyCompactHistoryBefore(hybrid_time);</a>
<a name="ln422">    }</a>
<a name="ln423">    SubDocKey sub_doc_key(doc_key);</a>
<a name="ln424">    SubDocument doc_from_rocksdb;</a>
<a name="ln425">    bool doc_found_in_rocksdb = false;</a>
<a name="ln426">    auto encoded_sub_doc_key = sub_doc_key.EncodeWithoutHt();</a>
<a name="ln427">    GetSubDocumentData data = { encoded_sub_doc_key, &amp;doc_from_rocksdb, &amp;doc_found_in_rocksdb };</a>
<a name="ln428">    ASSERT_OK(GetSubDocument(doc_db(), data, rocksdb::kDefaultQueryId,</a>
<a name="ln429">                             txn_op_context, CoarseTimePoint::max() /* deadline */));</a>
<a name="ln430">    if (is_deletion &amp;&amp; (</a>
<a name="ln431">            doc_path.num_subkeys() == 0 ||  // Deleted the entire sub-document,</a>
<a name="ln432">            !doc_already_exists_in_mem)) {  // or the document did not exist in the first place.</a>
<a name="ln433">      // In this case, after performing the deletion operation, we definitely should not see the</a>
<a name="ln434">      // top-level document in RocksDB or in the in-memory database.</a>
<a name="ln435">      ASSERT_FALSE(doc_found_in_rocksdb);</a>
<a name="ln436">      ASSERT_EQ(nullptr, subdoc_from_mem);</a>
<a name="ln437">    } else {</a>
<a name="ln438">      // This is not a deletion, or we've deleted a sub-key from a document, but the top-level</a>
<a name="ln439">      // document should still be there in RocksDB.</a>
<a name="ln440">      ASSERT_TRUE(doc_found_in_rocksdb);</a>
<a name="ln441">      ASSERT_NE(nullptr, subdoc_from_mem);</a>
<a name="ln442"> </a>
<a name="ln443">      ASSERT_EQ(*subdoc_from_mem, doc_from_rocksdb);</a>
<a name="ln444">      DOCDB_DEBUG_LOG(&quot;Retrieved a document from RocksDB: $0&quot;, doc_from_rocksdb.ToString());</a>
<a name="ln445">      ASSERT_STR_EQ_VERBOSE_TRIMMED(subdoc_from_mem-&gt;ToString(), doc_from_rocksdb.ToString());</a>
<a name="ln446">    }</a>
<a name="ln447">  }</a>
<a name="ln448"> </a>
<a name="ln449">  if (current_iteration % verification_frequency_ == 0) {</a>
<a name="ln450">    // in_mem_docdb_ has its captured_at() hybrid_time set to HybridTime::kMax, so the following</a>
<a name="ln451">    // will result in checking the latest state of DocDB stored in RocksDB against in_mem_docdb_.</a>
<a name="ln452">    ASSERT_NO_FATALS(VerifySnapshot(in_mem_docdb_))</a>
<a name="ln453">        &lt;&lt; &quot;Discrepancy between RocksDB-based and in-memory DocDB state found after iteration &quot;</a>
<a name="ln454">        &lt;&lt; current_iteration;</a>
<a name="ln455">  }</a>
<a name="ln456">}</a>
<a name="ln457"> </a>
<a name="ln458">HybridTime DocDBLoadGenerator::last_operation_ht() const {</a>
<a name="ln459">  CHECK(last_operation_ht_.is_valid());</a>
<a name="ln460">  return last_operation_ht_;</a>
<a name="ln461">}</a>
<a name="ln462"> </a>
<a name="ln463">void DocDBLoadGenerator::FlushRocksDB() {</a>
<a name="ln464">  LOG(INFO) &lt;&lt; &quot;Forcing a RocksDB flush after hybrid_time &quot; &lt;&lt; last_operation_ht().value();</a>
<a name="ln465">  ASSERT_OK(fixture_-&gt;FlushRocksDbAndWait());</a>
<a name="ln466">}</a>
<a name="ln467"> </a>
<a name="ln468">void DocDBLoadGenerator::CaptureDocDbSnapshot() {</a>
<a name="ln469">  // Capture snapshots from time to time.</a>
<a name="ln470">  docdb_snapshots_.emplace_back();</a>
<a name="ln471">  docdb_snapshots_.back().CaptureAt(doc_db(), HybridTime::kMax);</a>
<a name="ln472">  docdb_snapshots_.back().SetCaptureHybridTime(last_operation_ht_);</a>
<a name="ln473">}</a>
<a name="ln474"> </a>
<a name="ln475">void DocDBLoadGenerator::VerifyOldestSnapshot() {</a>
<a name="ln476">  if (!docdb_snapshots_.empty()) {</a>
<a name="ln477">    ASSERT_NO_FATALS(VerifySnapshot(GetOldestSnapshot()));</a>
<a name="ln478">  }</a>
<a name="ln479">}</a>
<a name="ln480"> </a>
<a name="ln481">void DocDBLoadGenerator::CheckIfOldestSnapshotIsStillValid(const HybridTime cleanup_ht) {</a>
<a name="ln482">  if (docdb_snapshots_.empty()) {</a>
<a name="ln483">    return;</a>
<a name="ln484">  }</a>
<a name="ln485"> </a>
<a name="ln486">  const InMemDocDbState* latest_snapshot_before_ht = nullptr;</a>
<a name="ln487">  for (const auto&amp; snapshot : docdb_snapshots_) {</a>
<a name="ln488">    const HybridTime snap_ht = snapshot.captured_at();</a>
<a name="ln489">    if (snap_ht.CompareTo(cleanup_ht) &lt; 0 &amp;&amp;</a>
<a name="ln490">        (latest_snapshot_before_ht == nullptr ||</a>
<a name="ln491">         latest_snapshot_before_ht-&gt;captured_at().CompareTo(snap_ht) &lt; 0)) {</a>
<a name="ln492">      latest_snapshot_before_ht = &amp;snapshot;</a>
<a name="ln493">    }</a>
<a name="ln494">  }</a>
<a name="ln495"> </a>
<a name="ln496">  if (latest_snapshot_before_ht == nullptr) {</a>
<a name="ln497">    return;</a>
<a name="ln498">  }</a>
<a name="ln499"> </a>
<a name="ln500">  const auto&amp; snapshot = *latest_snapshot_before_ht;</a>
<a name="ln501">  LOG(INFO) &lt;&lt; &quot;Checking whether snapshot at hybrid_time &quot;</a>
<a name="ln502">            &lt;&lt; snapshot.captured_at().ToDebugString()</a>
<a name="ln503">            &lt;&lt; &quot; is no longer valid after history cleanup for hybrid_times before &quot;</a>
<a name="ln504">            &lt;&lt; cleanup_ht.ToDebugString()</a>
<a name="ln505">            &lt;&lt; &quot;, last operation hybrid_time: &quot; &lt;&lt; last_operation_ht() &lt;&lt; &quot;.&quot;;</a>
<a name="ln506">  RecordSnapshotDivergence(snapshot, cleanup_ht);</a>
<a name="ln507">}</a>
<a name="ln508"> </a>
<a name="ln509">void DocDBLoadGenerator::VerifyRandomDocDbSnapshot() {</a>
<a name="ln510">  if (!docdb_snapshots_.empty()) {</a>
<a name="ln511">    const int snapshot_idx = NextRandomInt(docdb_snapshots_.size());</a>
<a name="ln512">    ASSERT_NO_FATALS(VerifySnapshot(docdb_snapshots_[snapshot_idx]));</a>
<a name="ln513">  }</a>
<a name="ln514">}</a>
<a name="ln515"> </a>
<a name="ln516">void DocDBLoadGenerator::RemoveSnapshotsBefore(HybridTime ht) {</a>
<a name="ln517">  docdb_snapshots_.erase(</a>
<a name="ln518">      std::remove_if(docdb_snapshots_.begin(),</a>
<a name="ln519">                     docdb_snapshots_.end(),</a>
<a name="ln520">                     [=](const InMemDocDbState&amp; entry) { return entry.captured_at() &lt; ht; }),</a>
<a name="ln521">      docdb_snapshots_.end());</a>
<a name="ln522">  // Double-check that there is no state corruption in any of the snapshots. Such corruption</a>
<a name="ln523">  // happened when I (Mikhail) initially forgot to add the &quot;erase&quot; call above (as per the</a>
<a name="ln524">  // &quot;erase/remove&quot; C++ idiom), and ended up with a bunch of moved-from objects still in the</a>
<a name="ln525">  // snapshots array.</a>
<a name="ln526">  for (const auto&amp; snapshot : docdb_snapshots_) {</a>
<a name="ln527">    snapshot.SanityCheck();</a>
<a name="ln528">  }</a>
<a name="ln529">}</a>
<a name="ln530"> </a>
<a name="ln531">const InMemDocDbState&amp; DocDBLoadGenerator::GetOldestSnapshot() {</a>
<a name="ln532">  CHECK(!docdb_snapshots_.empty());</a>
<a name="ln533">  return *std::min_element(</a>
<a name="ln534">      docdb_snapshots_.begin(),</a>
<a name="ln535">      docdb_snapshots_.end(),</a>
<a name="ln536">      [](const InMemDocDbState&amp; a, const InMemDocDbState&amp; b) {</a>
<a name="ln537">        return a.captured_at() &lt; b.captured_at();</a>
<a name="ln538">      });</a>
<a name="ln539">}</a>
<a name="ln540"> </a>
<a name="ln541">void DocDBLoadGenerator::VerifySnapshot(const InMemDocDbState&amp; snapshot) {</a>
<a name="ln542">  const HybridTime snap_ht = snapshot.captured_at();</a>
<a name="ln543">  InMemDocDbState flashback_state;</a>
<a name="ln544"> </a>
<a name="ln545">  string details_msg;</a>
<a name="ln546">  {</a>
<a name="ln547">    stringstream details_ss;</a>
<a name="ln548">    details_ss &lt;&lt; &quot;After operation at hybrid_time &quot; &lt;&lt; last_operation_ht().value() &lt;&lt; &quot;: &quot;</a>
<a name="ln549">        &lt;&lt; &quot;performing a flashback query at hybrid_time &quot; &lt;&lt; snap_ht.ToDebugString() &lt;&lt; &quot; &quot;</a>
<a name="ln550">        &lt;&lt; &quot;(last operation's hybrid_time: &quot; &lt;&lt; last_operation_ht() &lt;&lt; &quot;) &quot;</a>
<a name="ln551">        &lt;&lt; &quot;and verifying it against the snapshot captured at that hybrid_time.&quot;;</a>
<a name="ln552">    details_msg = details_ss.str();</a>
<a name="ln553">  }</a>
<a name="ln554">  LOG(INFO) &lt;&lt; details_msg;</a>
<a name="ln555"> </a>
<a name="ln556">  flashback_state.CaptureAt(doc_db(), snap_ht);</a>
<a name="ln557">  const bool is_match = flashback_state.EqualsAndLogDiff(snapshot);</a>
<a name="ln558">  if (!is_match) {</a>
<a name="ln559">    LOG(ERROR) &lt;&lt; details_msg &lt;&lt; &quot;\nDOCDB SNAPSHOT VERIFICATION FAILED, DOCDB STATE:&quot;;</a>
<a name="ln560">    fixture_-&gt;DocDBDebugDumpToConsole();</a>
<a name="ln561">  }</a>
<a name="ln562">  ASSERT_TRUE(is_match) &lt;&lt; details_msg;</a>
<a name="ln563">}</a>
<a name="ln564"> </a>
<a name="ln565">void DocDBLoadGenerator::RecordSnapshotDivergence(const InMemDocDbState &amp;snapshot,</a>
<a name="ln566">                                                  const HybridTime cleanup_ht) {</a>
<a name="ln567">  InMemDocDbState flashback_state;</a>
<a name="ln568">  const auto snap_ht = snapshot.captured_at();</a>
<a name="ln569">  flashback_state.CaptureAt(doc_db(), snap_ht);</a>
<a name="ln570">  if (!flashback_state.EqualsAndLogDiff(snapshot, /* log_diff = */ false)) {</a>
<a name="ln571">    // Implicitly converting hybrid_times to ints. That's OK, because we're using small enough</a>
<a name="ln572">    // integer values for hybrid_times.</a>
<a name="ln573">    divergent_snapshot_ht_and_cleanup_ht_.emplace_back(snapshot.captured_at().value(),</a>
<a name="ln574">                                                       cleanup_ht.value());</a>
<a name="ln575">  }</a>
<a name="ln576">}</a>
<a name="ln577"> </a>
<a name="ln578">TransactionOperationContextOpt DocDBLoadGenerator::GetReadOperationTransactionContext() {</a>
<a name="ln579">  if (resolve_intents_) {</a>
<a name="ln580">    return kNonTransactionalOperationContext;</a>
<a name="ln581">  }</a>
<a name="ln582">  return boost::none;</a>
<a name="ln583">}</a>
<a name="ln584"> </a>
<a name="ln585">// ------------------------------------------------------------------------------------------------</a>
<a name="ln586"> </a>
<a name="ln587">void DocDBRocksDBFixture::AssertDocDbDebugDumpStrEq(const string &amp;expected) {</a>
<a name="ln588">  const string debug_dump_str = TrimDocDbDebugDumpStr(DocDBDebugDumpToStr());</a>
<a name="ln589">  const string expected_str = TrimDocDbDebugDumpStr(expected);</a>
<a name="ln590">  if (expected_str != debug_dump_str) {</a>
<a name="ln591">    auto expected_lines = StringSplit(expected_str, '\n');</a>
<a name="ln592">    auto actual_lines = StringSplit(debug_dump_str, '\n');</a>
<a name="ln593">    vector&lt;int&gt; mismatch_line_numbers;</a>
<a name="ln594">    for (int i = 0; i &lt; std::min(expected_lines.size(), actual_lines.size()); ++i) {</a>
<a name="ln595">      if (expected_lines[i] != actual_lines[i]) {</a>
<a name="ln596">        mismatch_line_numbers.push_back(i + 1);</a>
<a name="ln597">      }</a>
<a name="ln598">    }</a>
<a name="ln599">    LOG(ERROR) &lt;&lt; &quot;Assertion failure&quot;</a>
<a name="ln600">               &lt;&lt; &quot;\nExpected DocDB contents:\n\n&quot; &lt;&lt; expected_str &lt;&lt; &quot;\n&quot;</a>
<a name="ln601">               &lt;&lt; &quot;\nActual DocDB contents:\n\n&quot; &lt;&lt; debug_dump_str &lt;&lt; &quot;\n&quot;</a>
<a name="ln602">               &lt;&lt; &quot;\nExpected # of lines: &quot; &lt;&lt; expected_lines.size()</a>
<a name="ln603">               &lt;&lt; &quot;, actual # of lines: &quot; &lt;&lt; actual_lines.size()</a>
<a name="ln604">               &lt;&lt; &quot;\nLines not matching: &quot; &lt;&lt; yb::ToString(mismatch_line_numbers)</a>
<a name="ln605">               &lt;&lt; &quot;\nPlease check if source files have trailing whitespace and remove it.&quot;;</a>
<a name="ln606"> </a>
<a name="ln607">    FAIL();</a>
<a name="ln608">  }</a>
<a name="ln609">}</a>
<a name="ln610"> </a>
<a name="ln611">void DocDBRocksDBFixture::FullyCompactHistoryBefore(HybridTime history_cutoff) {</a>
<a name="ln612">  LOG(INFO) &lt;&lt; &quot;Major-compacting history before hybrid_time &quot; &lt;&lt; history_cutoff;</a>
<a name="ln613">  SetHistoryCutoffHybridTime(history_cutoff);</a>
<a name="ln614">  auto se = ScopeExit([this] {</a>
<a name="ln615">    SetHistoryCutoffHybridTime(HybridTime::kMin);</a>
<a name="ln616">  });</a>
<a name="ln617"> </a>
<a name="ln618">  ASSERT_OK(FlushRocksDbAndWait());</a>
<a name="ln619">  ASSERT_OK(FullyCompactDB(regular_db_.get()));</a>
<a name="ln620">}</a>
<a name="ln621"> </a>
<a name="ln622">void DocDBRocksDBFixture::MinorCompaction(</a>
<a name="ln623">    HybridTime history_cutoff,</a>
<a name="ln624">    int num_files_to_compact,</a>
<a name="ln625">    int start_index) {</a>
<a name="ln626"> </a>
<a name="ln627">  ASSERT_OK(FlushRocksDbAndWait());</a>
<a name="ln628">  SetHistoryCutoffHybridTime(history_cutoff);</a>
<a name="ln629">  auto se = ScopeExit([this] {</a>
<a name="ln630">    SetHistoryCutoffHybridTime(HybridTime::kMin);</a>
<a name="ln631">  });</a>
<a name="ln632"> </a>
<a name="ln633">  rocksdb::ColumnFamilyMetaData cf_meta;</a>
<a name="ln634">  regular_db_-&gt;GetColumnFamilyMetaData(&amp;cf_meta);</a>
<a name="ln635"> </a>
<a name="ln636">  vector&lt;string&gt; compaction_input_file_names;</a>
<a name="ln637">  vector&lt;string&gt; remaining_file_names;</a>
<a name="ln638"> </a>
<a name="ln639">  size_t initial_num_files = 0;</a>
<a name="ln640">  {</a>
<a name="ln641">    const auto&amp; files = cf_meta.levels[0].files;</a>
<a name="ln642">    initial_num_files = files.size();</a>
<a name="ln643">    ASSERT_LE(num_files_to_compact, files.size());</a>
<a name="ln644">    vector&lt;string&gt; file_names;</a>
<a name="ln645">    for (const auto&amp; sst_meta : files) {</a>
<a name="ln646">      file_names.push_back(sst_meta.name);</a>
<a name="ln647">    }</a>
<a name="ln648">    SortByKey(file_names.begin(), file_names.end(), rocksdb::TableFileNameToNumber);</a>
<a name="ln649"> </a>
<a name="ln650">    if (start_index &lt; 0) {</a>
<a name="ln651">      start_index = file_names.size() - num_files_to_compact;</a>
<a name="ln652">    }</a>
<a name="ln653"> </a>
<a name="ln654">    for (int i = 0; i &lt; file_names.size(); ++i) {</a>
<a name="ln655">      if (start_index &lt;= i &amp;&amp; compaction_input_file_names.size() &lt; num_files_to_compact) {</a>
<a name="ln656">        compaction_input_file_names.push_back(file_names[i]);</a>
<a name="ln657">      } else {</a>
<a name="ln658">        remaining_file_names.push_back(file_names[i]);</a>
<a name="ln659">      }</a>
<a name="ln660">    }</a>
<a name="ln661">    ASSERT_EQ(num_files_to_compact, compaction_input_file_names.size())</a>
<a name="ln662">        &lt;&lt; &quot;Tried to add &quot; &lt;&lt; num_files_to_compact &lt;&lt; &quot; files starting with index &quot; &lt;&lt; start_index</a>
<a name="ln663">        &lt;&lt; &quot;, ended up adding &quot; &lt;&lt; yb::ToString(compaction_input_file_names)</a>
<a name="ln664">        &lt;&lt; &quot; and leaving &quot; &lt;&lt; yb::ToString(remaining_file_names) &lt;&lt; &quot; out. All files: &quot;</a>
<a name="ln665">        &lt;&lt; yb::ToString(file_names);</a>
<a name="ln666"> </a>
<a name="ln667">    LOG(INFO) &lt;&lt; &quot;Minor-compacting history before hybrid_time &quot; &lt;&lt; history_cutoff &lt;&lt; &quot;:\n&quot;</a>
<a name="ln668">              &lt;&lt; &quot;  files being compacted: &quot; &lt;&lt; yb::ToString(compaction_input_file_names) &lt;&lt; &quot;\n&quot;</a>
<a name="ln669">              &lt;&lt; &quot;  other files: &quot; &lt;&lt; yb::ToString(remaining_file_names);</a>
<a name="ln670"> </a>
<a name="ln671">    ASSERT_OK(regular_db_-&gt;CompactFiles(</a>
<a name="ln672">        rocksdb::CompactionOptions(),</a>
<a name="ln673">        compaction_input_file_names,</a>
<a name="ln674">        /* output_level */ 0));</a>
<a name="ln675">    const auto sstables_after_compaction = SSTableFileNames();</a>
<a name="ln676">    LOG(INFO) &lt;&lt; &quot;SSTable files after compaction: &quot; &lt;&lt; sstables_after_compaction.size()</a>
<a name="ln677">              &lt;&lt; &quot; (&quot; &lt;&lt; yb::ToString(sstables_after_compaction) &lt;&lt; &quot;)&quot;;</a>
<a name="ln678">    for (const auto&amp; remaining_file : remaining_file_names) {</a>
<a name="ln679">      ASSERT_TRUE(</a>
<a name="ln680">          std::find(sstables_after_compaction.begin(), sstables_after_compaction.end(),</a>
<a name="ln681">                    remaining_file) != sstables_after_compaction.end()</a>
<a name="ln682">      ) &lt;&lt; &quot;File &quot; &lt;&lt; remaining_file &lt;&lt; &quot; not found in file list after compaction: &quot;</a>
<a name="ln683">        &lt;&lt; yb::ToString(sstables_after_compaction) &lt;&lt; &quot;, even though none of these files were &quot;</a>
<a name="ln684">        &lt;&lt; &quot;supposed to be compacted: &quot; &lt;&lt; yb::ToString(remaining_file_names);</a>
<a name="ln685">    }</a>
<a name="ln686">  }</a>
<a name="ln687"> </a>
<a name="ln688">  regular_db_-&gt;GetColumnFamilyMetaData(&amp;cf_meta);</a>
<a name="ln689">  vector&lt;string&gt; files_after_compaction;</a>
<a name="ln690">  for (const auto&amp; sst_meta : cf_meta.levels[0].files) {</a>
<a name="ln691">    files_after_compaction.push_back(sst_meta.name);</a>
<a name="ln692">  }</a>
<a name="ln693">  const int64_t expected_resulting_num_files = initial_num_files - num_files_to_compact + 1;</a>
<a name="ln694">  ASSERT_EQ(expected_resulting_num_files,</a>
<a name="ln695">            static_cast&lt;int64_t&gt;(cf_meta.levels[0].files.size()))</a>
<a name="ln696">      &lt;&lt; &quot;Files after compaction: &quot; &lt;&lt; yb::ToString(files_after_compaction);</a>
<a name="ln697">}</a>
<a name="ln698"> </a>
<a name="ln699">int DocDBRocksDBFixture::NumSSTableFiles() {</a>
<a name="ln700">  rocksdb::ColumnFamilyMetaData cf_meta;</a>
<a name="ln701">  regular_db_-&gt;GetColumnFamilyMetaData(&amp;cf_meta);</a>
<a name="ln702">  return cf_meta.levels[0].files.size();</a>
<a name="ln703">}</a>
<a name="ln704"> </a>
<a name="ln705">StringVector DocDBRocksDBFixture::SSTableFileNames() {</a>
<a name="ln706">  rocksdb::ColumnFamilyMetaData cf_meta;</a>
<a name="ln707">  regular_db_-&gt;GetColumnFamilyMetaData(&amp;cf_meta);</a>
<a name="ln708">  StringVector files;</a>
<a name="ln709">  for (const auto&amp; sstable_meta : cf_meta.levels[0].files) {</a>
<a name="ln710">    files.push_back(sstable_meta.name);</a>
<a name="ln711">  }</a>
<a name="ln712">  SortByKey(files.begin(), files.end(), rocksdb::TableFileNameToNumber);</a>
<a name="ln713">  return files;</a>
<a name="ln714">}</a>
<a name="ln715"> </a>
<a name="ln716">Status DocDBRocksDBFixture::FormatDocWriteBatch(const DocWriteBatch &amp;dwb, string* dwb_str) {</a>
<a name="ln717">  WriteBatchFormatter formatter;</a>
<a name="ln718">  rocksdb::WriteBatch rocksdb_write_batch;</a>
<a name="ln719">  RETURN_NOT_OK(PopulateRocksDBWriteBatch(dwb, &amp;rocksdb_write_batch));</a>
<a name="ln720">  RETURN_NOT_OK(rocksdb_write_batch.Iterate(&amp;formatter));</a>
<a name="ln721">  *dwb_str = formatter.str();</a>
<a name="ln722">  return Status::OK();</a>
<a name="ln723">}</a>
<a name="ln724"> </a>
<a name="ln725">Status FullyCompactDB(rocksdb::DB* rocksdb) {</a>
<a name="ln726">  rocksdb::CompactRangeOptions compact_range_options;</a>
<a name="ln727">  return rocksdb-&gt;CompactRange(compact_range_options, nullptr, nullptr);</a>
<a name="ln728">}</a>
<a name="ln729"> </a>
<a name="ln730">Status DocDBRocksDBFixture::InitRocksDBDir() {</a>
<a name="ln731">  string test_dir;</a>
<a name="ln732">  RETURN_NOT_OK(Env::Default()-&gt;GetTestDirectory(&amp;test_dir));</a>
<a name="ln733">  rocksdb_dir_ = JoinPathSegments(test_dir, StringPrintf(&quot;mytestdb-%d&quot;, rand()));</a>
<a name="ln734">  CHECK(!rocksdb_dir_.empty());  // Check twice before we recursively delete anything.</a>
<a name="ln735">  CHECK_NE(rocksdb_dir_, &quot;/&quot;);</a>
<a name="ln736">  RETURN_NOT_OK(Env::Default()-&gt;DeleteRecursively(rocksdb_dir_));</a>
<a name="ln737">  RETURN_NOT_OK(Env::Default()-&gt;DeleteRecursively(IntentsDBDir()));</a>
<a name="ln738">  return Status::OK();</a>
<a name="ln739">}</a>
<a name="ln740"> </a>
<a name="ln741">string DocDBRocksDBFixture::tablet_id() {</a>
<a name="ln742">  return &quot;mytablet&quot;;</a>
<a name="ln743">}</a>
<a name="ln744"> </a>
<a name="ln745">Status DocDBRocksDBFixture::InitRocksDBOptions() {</a>
<a name="ln746">  RETURN_NOT_OK(InitCommonRocksDBOptions());</a>
<a name="ln747">  return Status::OK();</a>
<a name="ln748">}</a>
<a name="ln749"> </a>
<a name="ln750">string TrimDocDbDebugDumpStr(const string&amp; debug_dump_str) {</a>
<a name="ln751">  return TrimStr(ApplyEagerLineContinuation(LeftShiftTextBlock(TrimCppComments(debug_dump_str))));</a>
<a name="ln752">}</a>
<a name="ln753"> </a>
<a name="ln754">}  // namespace docdb</a>
<a name="ln755">}  // namespace yb</a>

</code></pre>
<div class="balloon" rel="459"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="532"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="734"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
