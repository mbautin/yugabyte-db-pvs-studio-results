
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>skiplist.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//  Copyright (c) 2011-present, Facebook, Inc.  All rights reserved.</a>
<a name="ln2">//  This source code is licensed under the BSD-style license found in the</a>
<a name="ln3">//  LICENSE file in the root directory of this source tree. An additional grant</a>
<a name="ln4">//  of patent rights can be found in the PATENTS file in the same directory.</a>
<a name="ln5">//</a>
<a name="ln6">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln7">//</a>
<a name="ln8">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln9">//</a>
<a name="ln10">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln11">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln12">//</a>
<a name="ln13">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln14">//</a>
<a name="ln15">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln16">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln17">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln18">// under the License.</a>
<a name="ln19">//</a>
<a name="ln20">// Copyright (c) 2011 The LevelDB Authors. All rights reserved.</a>
<a name="ln21">// Use of this source code is governed by a BSD-style license that can be</a>
<a name="ln22">// found in the LICENSE file. See the AUTHORS file for names of contributors.</a>
<a name="ln23"> </a>
<a name="ln24">// Thread safety</a>
<a name="ln25">// -------------</a>
<a name="ln26">//</a>
<a name="ln27">// Writes require external synchronization, most likely a mutex.</a>
<a name="ln28">// Reads require a guarantee that the SkipList will not be destroyed</a>
<a name="ln29">// while the read is in progress.  Apart from that, reads progress</a>
<a name="ln30">// without any internal locking or synchronization.</a>
<a name="ln31">//</a>
<a name="ln32">// Invariants:</a>
<a name="ln33">//</a>
<a name="ln34">// (1) Allocated nodes are never deleted until the SkipList is</a>
<a name="ln35">// destroyed.  This is trivially guaranteed by the code since we</a>
<a name="ln36">// never delete any skip list nodes.</a>
<a name="ln37">//</a>
<a name="ln38">// (2) The contents of a Node except for the next/prev pointers are</a>
<a name="ln39">// immutable after the Node has been linked into the SkipList.</a>
<a name="ln40">// Only Insert() modifies the list, and it is careful to initialize</a>
<a name="ln41">// a node and use release-stores to publish the nodes in one or</a>
<a name="ln42">// more lists.</a>
<a name="ln43">//</a>
<a name="ln44">// ... prev vs. next pointer ordering ...</a>
<a name="ln45">//</a>
<a name="ln46"> </a>
<a name="ln47">#ifndef YB_ROCKSDB_DB_SKIPLIST_H</a>
<a name="ln48">#define YB_ROCKSDB_DB_SKIPLIST_H</a>
<a name="ln49"> </a>
<a name="ln50">#pragma once</a>
<a name="ln51"> </a>
<a name="ln52">#include &lt;atomic&gt;</a>
<a name="ln53"> </a>
<a name="ln54">#include &quot;yb/rocksdb/port/port.h&quot;</a>
<a name="ln55">#include &quot;yb/rocksdb/util/allocator.h&quot;</a>
<a name="ln56">#include &quot;yb/rocksdb/util/random.h&quot;</a>
<a name="ln57"> </a>
<a name="ln58">namespace rocksdb {</a>
<a name="ln59"> </a>
<a name="ln60">// Base skip list implementation shares common logic for SkipList and SingleWriterInlineSkipList.</a>
<a name="ln61">// Since concurrent writes are not allowed many operations could be simplified.</a>
<a name="ln62">// See InlineSkipList for an implementation that supports concurrent writes.</a>
<a name="ln63">template&lt;class Key, class Comparator, class NodeType&gt;</a>
<a name="ln64">class SkipListBase {</a>
<a name="ln65"> private:</a>
<a name="ln66">  typedef NodeType Node;</a>
<a name="ln67"> </a>
<a name="ln68"> public:</a>
<a name="ln69">  // Create a new SkipList object that will use &quot;cmp&quot; for comparing keys,</a>
<a name="ln70">  // and will allocate memory using &quot;*allocator&quot;.  Objects allocated in the</a>
<a name="ln71">  // allocator must remain allocated for the lifetime of the skiplist object.</a>
<a name="ln72">  explicit SkipListBase(Comparator cmp, Allocator* allocator,</a>
<a name="ln73">                        int32_t max_height = 12, int32_t branching_factor = 4);</a>
<a name="ln74"> </a>
<a name="ln75">  // No copying allowed</a>
<a name="ln76">  SkipListBase(const SkipListBase&amp;) = delete;</a>
<a name="ln77">  void operator=(const SkipListBase&amp;) = delete;</a>
<a name="ln78"> </a>
<a name="ln79">  // Returns true iff an entry that compares equal to key is in the list.</a>
<a name="ln80">  bool Contains(Key key) const;</a>
<a name="ln81"> </a>
<a name="ln82">  bool Erase(Key key, Comparator cmp);</a>
<a name="ln83"> </a>
<a name="ln84">  // Return estimated number of entries smaller than `key`.</a>
<a name="ln85">  uint64_t EstimateCount(Key key) const;</a>
<a name="ln86"> </a>
<a name="ln87">  // Iteration over the contents of a skip list</a>
<a name="ln88">  class Iterator {</a>
<a name="ln89">   public:</a>
<a name="ln90">    // Initialize an iterator over the specified list.</a>
<a name="ln91">    // The returned iterator is not valid.</a>
<a name="ln92">    explicit Iterator(const SkipListBase* list);</a>
<a name="ln93"> </a>
<a name="ln94">    // Change the underlying skiplist used for this iterator</a>
<a name="ln95">    // This enables us not changing the iterator without deallocating</a>
<a name="ln96">    // an old one and then allocating a new one</a>
<a name="ln97">    void SetList(const SkipListBase* list);</a>
<a name="ln98"> </a>
<a name="ln99">    // Returns true iff the iterator is positioned at a valid node.</a>
<a name="ln100">    bool Valid() const;</a>
<a name="ln101"> </a>
<a name="ln102">    // Returns the key at the current position.</a>
<a name="ln103">    // REQUIRES: Valid()</a>
<a name="ln104">    Key key() const;</a>
<a name="ln105"> </a>
<a name="ln106">    // Advances to the next position.</a>
<a name="ln107">    // REQUIRES: Valid()</a>
<a name="ln108">    void Next();</a>
<a name="ln109"> </a>
<a name="ln110">    // Advances to the previous position.</a>
<a name="ln111">    // REQUIRES: Valid()</a>
<a name="ln112">    void Prev();</a>
<a name="ln113"> </a>
<a name="ln114">    // Advance to the first entry with a key &gt;= target</a>
<a name="ln115">    void Seek(Key target);</a>
<a name="ln116"> </a>
<a name="ln117">    // Position at the first entry in list.</a>
<a name="ln118">    // Final state of iterator is Valid() iff list is not empty.</a>
<a name="ln119">    void SeekToFirst();</a>
<a name="ln120"> </a>
<a name="ln121">    // Position at the last entry in list.</a>
<a name="ln122">    // Final state of iterator is Valid() iff list is not empty.</a>
<a name="ln123">    void SeekToLast();</a>
<a name="ln124"> </a>
<a name="ln125">   private:</a>
<a name="ln126">    const SkipListBase* list_;</a>
<a name="ln127">    Node* node_;</a>
<a name="ln128">    // Intentionally copyable</a>
<a name="ln129">  };</a>
<a name="ln130"> </a>
<a name="ln131"> protected:</a>
<a name="ln132">  // We do insert in 3 phases:</a>
<a name="ln133">  // 1) Prepare key insertion</a>
<a name="ln134">  // 2) Allocate and initialize node</a>
<a name="ln135">  // 3) Complete newly allocated node</a>
<a name="ln136">  // (1) and (3) are generic phases, while (2) is implementation specific.</a>
<a name="ln137">  // REQUIRES: nothing that compares equal to key is currently in the list.</a>
<a name="ln138">  void PrepareInsert(Key key);</a>
<a name="ln139">  void CompleteInsert(NodeType* node, int height);</a>
<a name="ln140"> </a>
<a name="ln141">  int RandomHeight();</a>
<a name="ln142"> </a>
<a name="ln143">  Allocator* const allocator_;    // Allocator used for allocations of nodes</a>
<a name="ln144"> </a>
<a name="ln145"> private:</a>
<a name="ln146">  const uint16_t kMaxHeight_;</a>
<a name="ln147">  const uint16_t kBranching_;</a>
<a name="ln148">  const uint32_t kScaledInverseBranching_;</a>
<a name="ln149"> </a>
<a name="ln150">  // Immutable after construction</a>
<a name="ln151">  Comparator const compare_;</a>
<a name="ln152"> </a>
<a name="ln153">  Node* const head_;</a>
<a name="ln154"> </a>
<a name="ln155">  // Modified only by Insert().  Read racily by readers, but stale</a>
<a name="ln156">  // values are ok.</a>
<a name="ln157">  std::atomic&lt;int&gt; max_height_;  // Height of the entire list</a>
<a name="ln158"> </a>
<a name="ln159">  // Used for optimizing sequential insert patterns.  Tricky.  prev_[i] for</a>
<a name="ln160">  // i up to max_height_ is the predecessor of prev_[0] and prev_height_</a>
<a name="ln161">  // is the height of prev_[0].  prev_[0] can only be equal to head before</a>
<a name="ln162">  // insertion, in which case max_height_ and prev_height_ are 1.</a>
<a name="ln163">  Node** prev_;</a>
<a name="ln164">  int32_t prev_height_;</a>
<a name="ln165"> </a>
<a name="ln166">  // Whether prev_ is valid, prev_ is invalidated during erase.</a>
<a name="ln167">  bool prev_valid_ = true;</a>
<a name="ln168"> </a>
<a name="ln169">  int GetMaxHeight() const {</a>
<a name="ln170">    return max_height_.load(std::memory_order_relaxed);</a>
<a name="ln171">  }</a>
<a name="ln172"> </a>
<a name="ln173">  bool Equal(Key a, Key b) const { return (compare_(a, b) == 0); }</a>
<a name="ln174"> </a>
<a name="ln175">  // Return true if key is greater than the data stored in &quot;n&quot;</a>
<a name="ln176">  bool KeyIsAfterNode(Key key, Node* n) const;</a>
<a name="ln177"> </a>
<a name="ln178">  // Returns the earliest node with a key &gt;= key.</a>
<a name="ln179">  // Return nullptr if there is no such node.</a>
<a name="ln180">  Node* FindGreaterOrEqual(Key key) const;</a>
<a name="ln181"> </a>
<a name="ln182">  // Return the latest node with a key &lt; key.</a>
<a name="ln183">  // Return head_ if there is no such node.</a>
<a name="ln184">  // Fills prev[level] with pointer to previous node at &quot;level&quot; for every</a>
<a name="ln185">  // level in [0..max_height_-1], if prev is non-null.</a>
<a name="ln186">  Node* FindLessThan(Key key, Node** prev = nullptr) const;</a>
<a name="ln187"> </a>
<a name="ln188">  // Return the last node in the list.</a>
<a name="ln189">  // Return head_ if list is empty.</a>
<a name="ln190">  Node* FindLast() const;</a>
<a name="ln191">};</a>
<a name="ln192"> </a>
<a name="ln193">// Implementation details follow</a>
<a name="ln194">template&lt;typename Key&gt;</a>
<a name="ln195">struct SkipListNode {</a>
<a name="ln196">  explicit SkipListNode(const Key&amp; k) : key(k) { }</a>
<a name="ln197"> </a>
<a name="ln198">  Key const key;</a>
<a name="ln199"> </a>
<a name="ln200">  // Accessors/mutators for links.  Wrapped in methods so we can</a>
<a name="ln201">  // add the appropriate barriers as necessary.</a>
<a name="ln202">  SkipListNode* Next(int n) {</a>
<a name="ln203">    DCHECK_GE(n, 0);</a>
<a name="ln204">    // Use an 'acquire load' so that we observe a fully initialized</a>
<a name="ln205">    // version of the returned Node.</a>
<a name="ln206">    return next_[n].load(std::memory_order_acquire);</a>
<a name="ln207">  }</a>
<a name="ln208"> </a>
<a name="ln209">  void SetNext(int n, SkipListNode* x) {</a>
<a name="ln210">    DCHECK_GE(n, 0);</a>
<a name="ln211">    // Use a 'release store' so that anybody who reads through this</a>
<a name="ln212">    // pointer observes a fully initialized version of the inserted node.</a>
<a name="ln213">    next_[n].store(x, std::memory_order_release);</a>
<a name="ln214">  }</a>
<a name="ln215"> </a>
<a name="ln216">  // No-barrier variants that can be safely used in a few locations.</a>
<a name="ln217">  SkipListNode* NoBarrier_Next(int n) {</a>
<a name="ln218">    DCHECK_GE(n, 0);</a>
<a name="ln219">    return next_[n].load(std::memory_order_relaxed);</a>
<a name="ln220">  }</a>
<a name="ln221"> </a>
<a name="ln222">  void NoBarrier_SetNext(int n, SkipListNode* x) {</a>
<a name="ln223">    DCHECK_GE(n, 0);</a>
<a name="ln224">    next_[n].store(x, std::memory_order_relaxed);</a>
<a name="ln225">  }</a>
<a name="ln226"> </a>
<a name="ln227">  static SkipListNode&lt;Key&gt;* Create(Allocator* allocator, const Key&amp; key, int height) {</a>
<a name="ln228">    char* mem = allocator-&gt;AllocateAligned(</a>
<a name="ln229">        sizeof(SkipListNode&lt;Key&gt;) + sizeof(std::atomic&lt;SkipListNode&lt;Key&gt;*&gt;) * (height - 1));</a>
<a name="ln230">    return new (mem) SkipListNode&lt;Key&gt;(key);</a>
<a name="ln231">  }</a>
<a name="ln232"> </a>
<a name="ln233">  static SkipListNode&lt;Key&gt;* CreateHead(Allocator* allocator, int height) {</a>
<a name="ln234">    return Create(allocator, Key() /* any key will do */, height);</a>
<a name="ln235">  }</a>
<a name="ln236"> </a>
<a name="ln237"> private:</a>
<a name="ln238">  // Array of length equal to the node height.  next_[0] is lowest level link.</a>
<a name="ln239">  std::atomic&lt;SkipListNode*&gt; next_[1];</a>
<a name="ln240">};</a>
<a name="ln241"> </a>
<a name="ln242">// Generic skip list implementation - allows any key comparable with specified comparator.</a>
<a name="ln243">// Please note thread safety at top of this file.</a>
<a name="ln244">template&lt;typename Key, class Comparator&gt;</a>
<a name="ln245">class SkipList : public SkipListBase&lt;const Key&amp;, Comparator, SkipListNode&lt;Key&gt;&gt; {</a>
<a name="ln246"> private:</a>
<a name="ln247">  typedef SkipListNode&lt;Key&gt; Node;</a>
<a name="ln248">  typedef SkipListBase&lt;const Key&amp;, Comparator, SkipListNode&lt;Key&gt;&gt; Base;</a>
<a name="ln249"> </a>
<a name="ln250"> public:</a>
<a name="ln251">  template&lt;class... Args&gt;</a>
<a name="ln252">  explicit SkipList(Args&amp;&amp;... args)</a>
<a name="ln253">      : Base(std::forward&lt;Args&gt;(args)...) {</a>
<a name="ln254">  }</a>
<a name="ln255"> </a>
<a name="ln256">  void Insert(const Key&amp; key) {</a>
<a name="ln257">    Base::PrepareInsert(key);</a>
<a name="ln258">    int height = Base::RandomHeight();</a>
<a name="ln259">    Node* x = Node::Create(Base::allocator_, key, height);</a>
<a name="ln260">    Base::CompleteInsert(x, height);</a>
<a name="ln261">  }</a>
<a name="ln262"> </a>
<a name="ln263"> private:</a>
<a name="ln264">  Node* NewNode(const Key&amp; key, int height);</a>
<a name="ln265">};</a>
<a name="ln266"> </a>
<a name="ln267">template&lt;typename Key, class Comparator&gt;</a>
<a name="ln268">typename SkipList&lt;Key, Comparator&gt;::Node*</a>
<a name="ln269">SkipList&lt;Key, Comparator&gt;::NewNode(const Key&amp; key, int height) {</a>
<a name="ln270">  return Node::Create(Base::allocator_, key, height);</a>
<a name="ln271">}</a>
<a name="ln272"> </a>
<a name="ln273">template&lt;class Key, class Comparator, class NodeType&gt;</a>
<a name="ln274">SkipListBase&lt;Key, Comparator, NodeType&gt;::Iterator::Iterator(</a>
<a name="ln275">    const SkipListBase* list) {</a>
<a name="ln276">  SetList(list);</a>
<a name="ln277">}</a>
<a name="ln278"> </a>
<a name="ln279">template&lt;class Key, class Comparator, class NodeType&gt;</a>
<a name="ln280">void SkipListBase&lt;Key, Comparator, NodeType&gt;::Iterator::SetList(const SkipListBase* list) {</a>
<a name="ln281">  list_ = list;</a>
<a name="ln282">  node_ = nullptr;</a>
<a name="ln283">}</a>
<a name="ln284"> </a>
<a name="ln285">template&lt;class Key, class Comparator, class NodeType&gt;</a>
<a name="ln286">bool SkipListBase&lt;Key, Comparator, NodeType&gt;::Iterator::Valid() const {</a>
<a name="ln287">  return node_ != nullptr;</a>
<a name="ln288">}</a>
<a name="ln289"> </a>
<a name="ln290">template&lt;class Key, class Comparator, class NodeType&gt;</a>
<a name="ln291">Key SkipListBase&lt;Key, Comparator, NodeType&gt;::Iterator::key() const {</a>
<a name="ln292">  DCHECK(Valid());</a>
<a name="ln293">  return node_-&gt;key;</a>
<a name="ln294">}</a>
<a name="ln295"> </a>
<a name="ln296">template&lt;class Key, class Comparator, class NodeType&gt;</a>
<a name="ln297">void SkipListBase&lt;Key, Comparator, NodeType&gt;::Iterator::Next() {</a>
<a name="ln298">  DCHECK(Valid());</a>
<a name="ln299">  node_ = node_-&gt;Next(0);</a>
<a name="ln300">}</a>
<a name="ln301"> </a>
<a name="ln302">template&lt;class Key, class Comparator, class NodeType&gt;</a>
<a name="ln303">void SkipListBase&lt;Key, Comparator, NodeType&gt;::Iterator::Prev() {</a>
<a name="ln304">  // Instead of using explicit &quot;prev&quot; links, we just search for the</a>
<a name="ln305">  // last node that falls before key.</a>
<a name="ln306">  DCHECK(Valid());</a>
<a name="ln307">  node_ = list_-&gt;FindLessThan(node_-&gt;key);</a>
<a name="ln308">  if (node_ == list_-&gt;head_) {</a>
<a name="ln309">    node_ = nullptr;</a>
<a name="ln310">  }</a>
<a name="ln311">}</a>
<a name="ln312"> </a>
<a name="ln313">template&lt;class Key, class Comparator, class NodeType&gt;</a>
<a name="ln314">void SkipListBase&lt;Key, Comparator, NodeType&gt;::Iterator::Seek(Key target) {</a>
<a name="ln315">  node_ = list_-&gt;FindGreaterOrEqual(target);</a>
<a name="ln316">}</a>
<a name="ln317"> </a>
<a name="ln318">template&lt;class Key, class Comparator, class NodeType&gt;</a>
<a name="ln319">void SkipListBase&lt;Key, Comparator, NodeType&gt;::Iterator::SeekToFirst() {</a>
<a name="ln320">  node_ = list_-&gt;head_-&gt;Next(0);</a>
<a name="ln321">}</a>
<a name="ln322"> </a>
<a name="ln323">template&lt;class Key, class Comparator, class NodeType&gt;</a>
<a name="ln324">void SkipListBase&lt;Key, Comparator, NodeType&gt;::Iterator::SeekToLast() {</a>
<a name="ln325">  node_ = list_-&gt;FindLast();</a>
<a name="ln326">  if (node_ == list_-&gt;head_) {</a>
<a name="ln327">    node_ = nullptr;</a>
<a name="ln328">  }</a>
<a name="ln329">}</a>
<a name="ln330"> </a>
<a name="ln331">template&lt;class Key, class Comparator, class NodeType&gt;</a>
<a name="ln332">int SkipListBase&lt;Key, Comparator, NodeType&gt;::RandomHeight() {</a>
<a name="ln333">  auto rnd = Random::GetTLSInstance();</a>
<a name="ln334"> </a>
<a name="ln335">  // Increase height with probability 1 in kBranching</a>
<a name="ln336">  int height = 1;</a>
<a name="ln337">  while (height &lt; kMaxHeight_ &amp;&amp; rnd-&gt;Next() &lt; kScaledInverseBranching_) {</a>
<a name="ln338">    height++;</a>
<a name="ln339">  }</a>
<a name="ln340">  return height;</a>
<a name="ln341">}</a>
<a name="ln342"> </a>
<a name="ln343">template&lt;class Key, class Comparator, class NodeType&gt;</a>
<a name="ln344">bool SkipListBase&lt;Key, Comparator, NodeType&gt;::KeyIsAfterNode(Key key, Node* n) const {</a>
<a name="ln345">  // nullptr n is considered infinite</a>
<a name="ln346">  return (n != nullptr) &amp;&amp; (compare_(n-&gt;key, key) &lt; 0);</a>
<a name="ln347">}</a>
<a name="ln348"> </a>
<a name="ln349">template&lt;class Key, class Comparator, class NodeType&gt;</a>
<a name="ln350">typename SkipListBase&lt;Key, Comparator, NodeType&gt;::Node* SkipListBase&lt;Key, Comparator, NodeType&gt;::</a>
<a name="ln351">  FindGreaterOrEqual(Key key) const {</a>
<a name="ln352">  // Note: It looks like we could reduce duplication by implementing</a>
<a name="ln353">  // this function as FindLessThan(key)-&gt;Next(0), but we wouldn't be able</a>
<a name="ln354">  // to exit early on equality and the result wouldn't even be correct.</a>
<a name="ln355">  // A concurrent insert might occur after FindLessThan(key) but before</a>
<a name="ln356">  // we get a chance to call Next(0).</a>
<a name="ln357">  Node* x = head_;</a>
<a name="ln358">  int level = GetMaxHeight() - 1;</a>
<a name="ln359">  Node* last_bigger = nullptr;</a>
<a name="ln360">  while (true) {</a>
<a name="ln361">    Node* next = x-&gt;Next(level);</a>
<a name="ln362">    // Make sure the lists are sorted</a>
<a name="ln363">    DCHECK(x == head_ || next == nullptr || KeyIsAfterNode(next-&gt;key, x));</a>
<a name="ln364">    // Make sure we haven't overshot during our search</a>
<a name="ln365">    DCHECK(x == head_ || KeyIsAfterNode(key, x));</a>
<a name="ln366">    int cmp = (next == nullptr || next == last_bigger)</a>
<a name="ln367">        ? 1 : compare_(next-&gt;key, key);</a>
<a name="ln368">    if (cmp == 0 || (cmp &gt; 0 &amp;&amp; level == 0)) {</a>
<a name="ln369">      return next;</a>
<a name="ln370">    } else if (cmp &lt; 0) {</a>
<a name="ln371">      // Keep searching in this list</a>
<a name="ln372">      x = next;</a>
<a name="ln373">    } else {</a>
<a name="ln374">      // Switch to next list, reuse compare_() result</a>
<a name="ln375">      last_bigger = next;</a>
<a name="ln376">      level--;</a>
<a name="ln377">    }</a>
<a name="ln378">  }</a>
<a name="ln379">}</a>
<a name="ln380"> </a>
<a name="ln381">template&lt;class Key, class Comparator, class NodeType&gt;</a>
<a name="ln382">typename SkipListBase&lt;Key, Comparator, NodeType&gt;::Node*</a>
<a name="ln383">SkipListBase&lt;Key, Comparator, NodeType&gt;::FindLessThan(Key key, Node** prev) const {</a>
<a name="ln384">  Node* x = head_;</a>
<a name="ln385">  int level = GetMaxHeight() - 1;</a>
<a name="ln386">  // KeyIsAfter(key, last_not_after) is definitely false</a>
<a name="ln387">  Node* last_not_after = nullptr;</a>
<a name="ln388">  while (true) {</a>
<a name="ln389">    Node* next = x-&gt;Next(level);</a>
<a name="ln390">    DCHECK(x == head_ || next == nullptr || KeyIsAfterNode(next-&gt;key, x));</a>
<a name="ln391">    DCHECK(x == head_ || KeyIsAfterNode(key, x));</a>
<a name="ln392">    if (next != last_not_after &amp;&amp; KeyIsAfterNode(key, next)) {</a>
<a name="ln393">      // Keep searching in this list</a>
<a name="ln394">      x = next;</a>
<a name="ln395">    } else {</a>
<a name="ln396">      if (prev != nullptr) {</a>
<a name="ln397">        prev[level] = x;</a>
<a name="ln398">      }</a>
<a name="ln399">      if (level == 0) {</a>
<a name="ln400">        return x;</a>
<a name="ln401">      } else {</a>
<a name="ln402">        // Switch to next list, reuse KeyIUsAfterNode() result</a>
<a name="ln403">        last_not_after = next;</a>
<a name="ln404">        level--;</a>
<a name="ln405">      }</a>
<a name="ln406">    }</a>
<a name="ln407">  }</a>
<a name="ln408">}</a>
<a name="ln409"> </a>
<a name="ln410">template&lt;class Key, class Comparator, class NodeType&gt;</a>
<a name="ln411">typename SkipListBase&lt;Key, Comparator, NodeType&gt;::Node*</a>
<a name="ln412">    SkipListBase&lt;Key, Comparator, NodeType&gt;::FindLast() const {</a>
<a name="ln413">  Node* x = head_;</a>
<a name="ln414">  int level = GetMaxHeight() - 1;</a>
<a name="ln415">  while (true) {</a>
<a name="ln416">    Node* next = x-&gt;Next(level);</a>
<a name="ln417">    if (next == nullptr) {</a>
<a name="ln418">      if (level == 0) {</a>
<a name="ln419">        return x;</a>
<a name="ln420">      } else {</a>
<a name="ln421">        // Switch to next list</a>
<a name="ln422">        level--;</a>
<a name="ln423">      }</a>
<a name="ln424">    } else {</a>
<a name="ln425">      x = next;</a>
<a name="ln426">    }</a>
<a name="ln427">  }</a>
<a name="ln428">}</a>
<a name="ln429"> </a>
<a name="ln430">template&lt;class Key, class Comparator, class NodeType&gt;</a>
<a name="ln431">uint64_t SkipListBase&lt;Key, Comparator, NodeType&gt;::EstimateCount(Key key) const {</a>
<a name="ln432">  uint64_t count = 0;</a>
<a name="ln433"> </a>
<a name="ln434">  Node* x = head_;</a>
<a name="ln435">  int level = GetMaxHeight() - 1;</a>
<a name="ln436">  while (true) {</a>
<a name="ln437">    DCHECK(x == head_ || compare_(x-&gt;key, key) &lt; 0);</a>
<a name="ln438">    Node* next = x-&gt;Next(level);</a>
<a name="ln439">    if (next == nullptr || compare_(next-&gt;key, key) &gt;= 0) {</a>
<a name="ln440">      if (level == 0) {</a>
<a name="ln441">        return count;</a>
<a name="ln442">      } else {</a>
<a name="ln443">        // Switch to next list</a>
<a name="ln444">        count *= kBranching_;</a>
<a name="ln445">        level--;</a>
<a name="ln446">      }</a>
<a name="ln447">    } else {</a>
<a name="ln448">      x = next;</a>
<a name="ln449">      count++;</a>
<a name="ln450">    }</a>
<a name="ln451">  }</a>
<a name="ln452">}</a>
<a name="ln453"> </a>
<a name="ln454">template&lt;class Key, class Comparator, class NodeType&gt;</a>
<a name="ln455">void SkipListBase&lt;Key, Comparator, NodeType&gt;::PrepareInsert(Key key) {</a>
<a name="ln456">  // fast path for sequential insertion</a>
<a name="ln457">  if (prev_valid_ &amp;&amp; !KeyIsAfterNode(key, prev_[0]-&gt;NoBarrier_Next(0)) &amp;&amp;</a>
<a name="ln458">      (prev_[0] == head_ || KeyIsAfterNode(key, prev_[0]))) {</a>
<a name="ln459">    DCHECK(prev_[0] != head_ || (prev_height_ == 1 &amp;&amp; GetMaxHeight() == 1))</a>
<a name="ln460">        &lt;&lt; &quot;prev_height_: &quot; &lt;&lt; prev_height_ &lt;&lt; &quot;, GetMaxHeight(): &quot; &lt;&lt; GetMaxHeight();</a>
<a name="ln461"> </a>
<a name="ln462">    // Outside of this method prev_[1..max_height_] is the predecessor</a>
<a name="ln463">    // of prev_[0], and prev_height_ refers to prev_[0].  Inside Insert</a>
<a name="ln464">    // prev_[0..max_height - 1] is the predecessor of key.  Switch from</a>
<a name="ln465">    // the external state to the internal</a>
<a name="ln466">    for (int i = 1; i &lt; prev_height_; i++) {</a>
<a name="ln467">      prev_[i] = prev_[0];</a>
<a name="ln468">    }</a>
<a name="ln469">  } else {</a>
<a name="ln470">    // TODO(opt): we could use a NoBarrier predecessor search as an</a>
<a name="ln471">    // optimization for architectures where memory_order_acquire needs</a>
<a name="ln472">    // a synchronization instruction.  Doesn't matter on x86</a>
<a name="ln473">    FindLessThan(key, prev_);</a>
<a name="ln474">    prev_valid_ = true;</a>
<a name="ln475">  }</a>
<a name="ln476"> </a>
<a name="ln477">  // Our data structure does not allow duplicate insertion</a>
<a name="ln478">  DCHECK(prev_[0]-&gt;Next(0) == nullptr || !Equal(key, prev_[0]-&gt;Next(0)-&gt;key));</a>
<a name="ln479">}</a>
<a name="ln480"> </a>
<a name="ln481">template&lt;class Key, class Comparator, class NodeType&gt;</a>
<a name="ln482">SkipListBase&lt;Key, Comparator, NodeType&gt;::SkipListBase(</a>
<a name="ln483">    const Comparator cmp, Allocator* allocator, int32_t max_height, int32_t branching_factor)</a>
<a name="ln484">    : allocator_(allocator),</a>
<a name="ln485">      kMaxHeight_(max_height),</a>
<a name="ln486">      kBranching_(branching_factor),</a>
<a name="ln487">      kScaledInverseBranching_((Random::kMaxNext + 1) / kBranching_),</a>
<a name="ln488">      compare_(cmp),</a>
<a name="ln489">      head_(Node::CreateHead(allocator, max_height)),</a>
<a name="ln490">      max_height_(1),</a>
<a name="ln491">      prev_height_(1) {</a>
<a name="ln492">  DCHECK(max_height &gt; 0 &amp;&amp; kMaxHeight_ == static_cast&lt;uint32_t&gt;(max_height));</a>
<a name="ln493">  DCHECK(branching_factor &gt; 0 &amp;&amp;</a>
<a name="ln494">         kBranching_ == static_cast&lt;uint32_t&gt;(branching_factor));</a>
<a name="ln495">  DCHECK_GT(kScaledInverseBranching_, 0);</a>
<a name="ln496">  // Allocate the prev_ Node* array, directly from the passed-in allocator.</a>
<a name="ln497">  // prev_ does not need to be freed, as its life cycle is tied up with</a>
<a name="ln498">  // the allocator as a whole.</a>
<a name="ln499">  prev_ = reinterpret_cast&lt;Node**&gt;(allocator_-&gt;AllocateAligned(sizeof(Node*) * kMaxHeight_));</a>
<a name="ln500">  for (int i = 0; i &lt; kMaxHeight_; i++) {</a>
<a name="ln501">    head_-&gt;SetNext(i, nullptr);</a>
<a name="ln502">    prev_[i] = head_;</a>
<a name="ln503">  }</a>
<a name="ln504">}</a>
<a name="ln505"> </a>
<a name="ln506">template&lt;class Key, class Comparator, class NodeType&gt;</a>
<a name="ln507">void SkipListBase&lt;Key, Comparator, NodeType&gt;::CompleteInsert(NodeType* node, int height) {</a>
<a name="ln508">  DCHECK_GT(height, 0);</a>
<a name="ln509">  DCHECK_LE(height, kMaxHeight_);</a>
<a name="ln510"> </a>
<a name="ln511">  if (height &gt; GetMaxHeight()) {</a>
<a name="ln512">    for (int i = GetMaxHeight(); i &lt; height; i++) {</a>
<a name="ln513">      prev_[i] = head_;</a>
<a name="ln514">    }</a>
<a name="ln515"> </a>
<a name="ln516">    // It is ok to mutate max_height_ without any synchronization</a>
<a name="ln517">    // with concurrent readers.  A concurrent reader that observes</a>
<a name="ln518">    // the new value of max_height_ will see either the old value of</a>
<a name="ln519">    // new level pointers from head_ (nullptr), or a new value set in</a>
<a name="ln520">    // the loop below.  In the former case the reader will</a>
<a name="ln521">    // immediately drop to the next level since nullptr sorts after all</a>
<a name="ln522">    // keys.  In the latter case the reader will use the new node.</a>
<a name="ln523">    max_height_.store(height, std::memory_order_relaxed);</a>
<a name="ln524">  }</a>
<a name="ln525"> </a>
<a name="ln526">  for (int i = 0; i &lt; height; i++) {</a>
<a name="ln527">    // NoBarrier_SetNext() suffices since we will add a barrier when</a>
<a name="ln528">    // we publish a pointer to &quot;x&quot; in prev[i].</a>
<a name="ln529">    node-&gt;NoBarrier_SetNext(i, prev_[i]-&gt;NoBarrier_Next(i));</a>
<a name="ln530">    prev_[i]-&gt;SetNext(i, node);</a>
<a name="ln531">  }</a>
<a name="ln532">  prev_[0] = node;</a>
<a name="ln533">  prev_height_ = height;</a>
<a name="ln534">}</a>
<a name="ln535"> </a>
<a name="ln536">template&lt;class Key, class Comparator, class NodeType&gt;</a>
<a name="ln537">bool SkipListBase&lt;Key, Comparator, NodeType&gt;::Contains(Key key) const {</a>
<a name="ln538">  Node* x = FindGreaterOrEqual(key);</a>
<a name="ln539">  return x != nullptr &amp;&amp; Equal(key, x-&gt;key);</a>
<a name="ln540">}</a>
<a name="ln541"> </a>
<a name="ln542">template&lt;class Key, class Comparator, class NodeType&gt;</a>
<a name="ln543">bool SkipListBase&lt;Key, Comparator, NodeType&gt;::Erase(Key key, Comparator cmp) {</a>
<a name="ln544">  auto prev = static_cast&lt;Node**&gt;(alloca(sizeof(Node*) * kMaxHeight_));</a>
<a name="ln545">  auto node = FindLessThan(key, prev);</a>
<a name="ln546">  node = node-&gt;Next(0);</a>
<a name="ln547">  if (node == nullptr || cmp(key, node-&gt;key) != 0) {</a>
<a name="ln548">    return false;</a>
<a name="ln549">  }</a>
<a name="ln550"> </a>
<a name="ln551">  for (int level = max_height_; --level &gt;= 0;) {</a>
<a name="ln552">    if (prev[level]-&gt;NoBarrier_Next(level) == node) {</a>
<a name="ln553">      prev[level]-&gt;SetNext(level, node-&gt;Next(level));</a>
<a name="ln554">    }</a>
<a name="ln555">  }</a>
<a name="ln556"> </a>
<a name="ln557">  prev_valid_ = false;</a>
<a name="ln558"> </a>
<a name="ln559">  return true;</a>
<a name="ln560">}</a>
<a name="ln561"> </a>
<a name="ln562">struct SingleWriterInlineSkipListNode {</a>
<a name="ln563">  std::atomic&lt;SingleWriterInlineSkipListNode*&gt; next_[1];</a>
<a name="ln564">  char key[0];</a>
<a name="ln565"> </a>
<a name="ln566">  explicit SingleWriterInlineSkipListNode(int height) {</a>
<a name="ln567">    memcpy(static_cast&lt;void*&gt;(&amp;next_[0]), &amp;height, sizeof(int));</a>
<a name="ln568">  }</a>
<a name="ln569"> </a>
<a name="ln570">  // Accessors/mutators for links.  Wrapped in methods so we can add</a>
<a name="ln571">  // the appropriate barriers as necessary, and perform the necessary</a>
<a name="ln572">  // addressing trickery for storing links below the Node in memory.</a>
<a name="ln573">  ATTRIBUTE_NO_SANITIZE_UNDEFINED SingleWriterInlineSkipListNode* Next(int n) {</a>
<a name="ln574">    DCHECK_GE(n, 0);</a>
<a name="ln575">    // Use an 'acquire load' so that we observe a fully initialized</a>
<a name="ln576">    // version of the returned Node.</a>
<a name="ln577">    return (next_[-n].load(std::memory_order_acquire));</a>
<a name="ln578">  }</a>
<a name="ln579"> </a>
<a name="ln580">  ATTRIBUTE_NO_SANITIZE_UNDEFINED void SetNext(int n, SingleWriterInlineSkipListNode* x) {</a>
<a name="ln581">    DCHECK_GE(n, 0);</a>
<a name="ln582">    // Use a 'release store' so that anybody who reads through this</a>
<a name="ln583">    // pointer observes a fully initialized version of the inserted node.</a>
<a name="ln584">    next_[-n].store(x, std::memory_order_release);</a>
<a name="ln585">  }</a>
<a name="ln586"> </a>
<a name="ln587">  // No-barrier variants that can be safely used in a few locations.</a>
<a name="ln588">  ATTRIBUTE_NO_SANITIZE_UNDEFINED SingleWriterInlineSkipListNode* NoBarrier_Next(int n) {</a>
<a name="ln589">    DCHECK_GE(n, 0);</a>
<a name="ln590">    return next_[-n].load(std::memory_order_relaxed);</a>
<a name="ln591">  }</a>
<a name="ln592"> </a>
<a name="ln593">  ATTRIBUTE_NO_SANITIZE_UNDEFINED void NoBarrier_SetNext(int n, SingleWriterInlineSkipListNode* x) {</a>
<a name="ln594">    DCHECK_GE(n, 0);</a>
<a name="ln595">    next_[-n].store(x, std::memory_order_relaxed);</a>
<a name="ln596">  }</a>
<a name="ln597"> </a>
<a name="ln598">  int UnstashHeight() const {</a>
<a name="ln599">    int rv;</a>
<a name="ln600">    memcpy(&amp;rv, &amp;next_[0], sizeof(int));</a>
<a name="ln601">    return rv;</a>
<a name="ln602">  }</a>
<a name="ln603"> </a>
<a name="ln604">  static SingleWriterInlineSkipListNode* Create(Allocator* allocator, size_t key_size, int height) {</a>
<a name="ln605">    auto prefix = sizeof(std::atomic&lt;SingleWriterInlineSkipListNode*&gt;) * (height - 1);</a>
<a name="ln606"> </a>
<a name="ln607">    // prefix is space for the height - 1 pointers that we store before</a>
<a name="ln608">    // the Node instance (next_[-(height - 1) .. -1]).  Node starts at</a>
<a name="ln609">    // raw + prefix, and holds the bottom-mode (level 0) skip list pointer</a>
<a name="ln610">    // next_[0]. key_size is the bytes for the key.</a>
<a name="ln611">    char* mem = allocator-&gt;AllocateAligned(</a>
<a name="ln612">        prefix + offsetof(SingleWriterInlineSkipListNode, key) + key_size);</a>
<a name="ln613">    return new (mem + prefix) SingleWriterInlineSkipListNode(height);</a>
<a name="ln614">  }</a>
<a name="ln615"> </a>
<a name="ln616">  static SingleWriterInlineSkipListNode* CreateHead(Allocator* allocator, int height) {</a>
<a name="ln617">    return Create(allocator, 0 /* key_size */, height);</a>
<a name="ln618">  }</a>
<a name="ln619">};</a>
<a name="ln620"> </a>
<a name="ln621">// Skip list designed for using variable size byte arrays as a key.</a>
<a name="ln622">// Node has variable size and key is copied directly to the node.</a>
<a name="ln623">// Please note thread safety at top of this file.</a>
<a name="ln624">template &lt;class Comparator&gt;</a>
<a name="ln625">class SingleWriterInlineSkipList :</a>
<a name="ln626">    public SkipListBase&lt;const char*, Comparator, SingleWriterInlineSkipListNode&gt; {</a>
<a name="ln627"> private:</a>
<a name="ln628">  typedef SkipListBase&lt;const char*, Comparator, SingleWriterInlineSkipListNode&gt; Base;</a>
<a name="ln629"> </a>
<a name="ln630"> public:</a>
<a name="ln631">  template&lt;class... Args&gt;</a>
<a name="ln632">  explicit SingleWriterInlineSkipList(Args&amp;&amp;... args)</a>
<a name="ln633">      : Base(std::forward&lt;Args&gt;(args)...) {</a>
<a name="ln634">  }</a>
<a name="ln635"> </a>
<a name="ln636">  char* AllocateKey(size_t key_size) {</a>
<a name="ln637">    return SingleWriterInlineSkipListNode::Create(</a>
<a name="ln638">        Base::allocator_, key_size, Base::RandomHeight())-&gt;key;</a>
<a name="ln639">  }</a>
<a name="ln640"> </a>
<a name="ln641">  void Insert(const char* key) {</a>
<a name="ln642">    Base::PrepareInsert(key);</a>
<a name="ln643">    auto node = reinterpret_cast&lt;SingleWriterInlineSkipListNode*&gt;(</a>
<a name="ln644">        const_cast&lt;char*&gt;(key) - offsetof(SingleWriterInlineSkipListNode, key));</a>
<a name="ln645">    Base::CompleteInsert(node, node-&gt;UnstashHeight());</a>
<a name="ln646">  }</a>
<a name="ln647"> </a>
<a name="ln648">  void InsertConcurrently(const char* key) {</a>
<a name="ln649">    LOG(FATAL) &lt;&lt; &quot;Concurrent insert is not supported&quot;;</a>
<a name="ln650">  }</a>
<a name="ln651">};</a>
<a name="ln652"> </a>
<a name="ln653">}  // namespace rocksdb</a>
<a name="ln654"> </a>
<a name="ln655">#endif // YB_ROCKSDB_DB_SKIPLIST_H</a>

</code></pre>
<div class="balloon" rel="292"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="298"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="306"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="363"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="365"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="390"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="391"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="437"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="459"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="478"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="492"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="493"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="566"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: key.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
