
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>basket_queue.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Copyright (c) 2006-2018 Maxim Khizhinsky</a>
<a name="ln2">//</a>
<a name="ln3">// Distributed under the Boost Software License, Version 1.0. (See accompanying</a>
<a name="ln4">// file LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)</a>
<a name="ln5"> </a>
<a name="ln6">#ifndef CDSLIB_INTRUSIVE_BASKET_QUEUE_H</a>
<a name="ln7">#define CDSLIB_INTRUSIVE_BASKET_QUEUE_H</a>
<a name="ln8"> </a>
<a name="ln9">#include &lt;type_traits&gt;</a>
<a name="ln10">#include &lt;cds/intrusive/details/single_link_struct.h&gt;</a>
<a name="ln11">#include &lt;cds/details/marked_ptr.h&gt;</a>
<a name="ln12"> </a>
<a name="ln13">namespace cds { namespace intrusive {</a>
<a name="ln14"> </a>
<a name="ln15">    /// BasketQueue -related definitions</a>
<a name="ln16">    /** @ingroup cds_intrusive_helper</a>
<a name="ln17">    */</a>
<a name="ln18">    namespace basket_queue {</a>
<a name="ln19">        /// BasketQueue node</a>
<a name="ln20">        /**</a>
<a name="ln21">            Template parameters:</a>
<a name="ln22">            Template parameters:</a>
<a name="ln23">            - GC - garbage collector used</a>
<a name="ln24">            - Tag - a \ref cds_intrusive_hook_tag &quot;tag&quot;</a>
<a name="ln25">            */</a>
<a name="ln26">        template &lt;class GC, typename Tag = opt::none&gt;</a>
<a name="ln27">        struct node</a>
<a name="ln28">        {</a>
<a name="ln29">            typedef GC      gc  ;   ///&lt; Garbage collector</a>
<a name="ln30">            typedef Tag     tag ;   ///&lt; tag</a>
<a name="ln31"> </a>
<a name="ln32">            typedef cds::details::marked_ptr&lt;node, 1&gt;                    marked_ptr;        ///&lt; marked pointer</a>
<a name="ln33">            typedef typename gc::template atomic_marked_ptr&lt; marked_ptr&gt; atomic_marked_ptr; ///&lt; atomic marked pointer specific for GC</a>
<a name="ln34"> </a>
<a name="ln35">            /// Rebind node for other template parameters</a>
<a name="ln36">            template &lt;class GC2, typename Tag2 = tag&gt;</a>
<a name="ln37">            struct rebind {</a>
<a name="ln38">                typedef node&lt;GC2, Tag2&gt;  other ;    ///&lt; Rebinding result</a>
<a name="ln39">            };</a>
<a name="ln40"> </a>
<a name="ln41">            atomic_marked_ptr m_pNext ; ///&lt; pointer to the next node in the container</a>
<a name="ln42"> </a>
<a name="ln43">            node()</a>
<a name="ln44">            {</a>
<a name="ln45">                m_pNext.store( marked_ptr(), atomics::memory_order_release );</a>
<a name="ln46">            }</a>
<a name="ln47">        };</a>
<a name="ln48"> </a>
<a name="ln49">        using cds::intrusive::single_link::default_hook;</a>
<a name="ln50"> </a>
<a name="ln51">        //@cond</a>
<a name="ln52">        template &lt; typename HookType, typename... Options&gt;</a>
<a name="ln53">        struct hook</a>
<a name="ln54">        {</a>
<a name="ln55">            typedef typename opt::make_options&lt; default_hook, Options...&gt;::type  options;</a>
<a name="ln56">            typedef typename options::gc    gc;</a>
<a name="ln57">            typedef typename options::tag   tag;</a>
<a name="ln58">            typedef node&lt;gc, tag&gt; node_type;</a>
<a name="ln59">            typedef HookType     hook_type;</a>
<a name="ln60">        };</a>
<a name="ln61">        //@endcond</a>
<a name="ln62"> </a>
<a name="ln63"> </a>
<a name="ln64">        /// Base hook</a>
<a name="ln65">        /**</a>
<a name="ln66">            \p Options are:</a>
<a name="ln67">            - opt::gc - garbage collector used.</a>
<a name="ln68">            - opt::tag - a \ref cds_intrusive_hook_tag &quot;tag&quot;</a>
<a name="ln69">        */</a>
<a name="ln70">        template &lt; typename... Options &gt;</a>
<a name="ln71">        struct base_hook: public hook&lt; opt::base_hook_tag, Options... &gt;</a>
<a name="ln72">        {};</a>
<a name="ln73"> </a>
<a name="ln74">        /// Member hook</a>
<a name="ln75">        /**</a>
<a name="ln76">            \p MemberOffset defines offset in bytes of \ref node member into your structure.</a>
<a name="ln77">            Use \p offsetof macro to define \p MemberOffset</a>
<a name="ln78"> </a>
<a name="ln79">            \p Options are:</a>
<a name="ln80">            - opt::gc - garbage collector used.</a>
<a name="ln81">            - opt::tag - a \ref cds_intrusive_hook_tag &quot;tag&quot;</a>
<a name="ln82">        */</a>
<a name="ln83">        template &lt; size_t MemberOffset, typename... Options &gt;</a>
<a name="ln84">        struct member_hook: public hook&lt; opt::member_hook_tag, Options... &gt;</a>
<a name="ln85">        {</a>
<a name="ln86">            //@cond</a>
<a name="ln87">            static const size_t c_nMemberOffset = MemberOffset;</a>
<a name="ln88">            //@endcond</a>
<a name="ln89">        };</a>
<a name="ln90"> </a>
<a name="ln91">        /// Traits hook</a>
<a name="ln92">        /**</a>
<a name="ln93">            \p NodeTraits defines type traits for node.</a>
<a name="ln94">            See \ref node_traits for \p NodeTraits interface description</a>
<a name="ln95"> </a>
<a name="ln96">            \p Options are:</a>
<a name="ln97">            - opt::gc - garbage collector used.</a>
<a name="ln98">            - opt::tag - a \ref cds_intrusive_hook_tag &quot;tag&quot;</a>
<a name="ln99">        */</a>
<a name="ln100">        template &lt;typename NodeTraits, typename... Options &gt;</a>
<a name="ln101">        struct traits_hook: public hook&lt; opt::traits_hook_tag, Options... &gt;</a>
<a name="ln102">        {</a>
<a name="ln103">            //@cond</a>
<a name="ln104">            typedef NodeTraits node_traits;</a>
<a name="ln105">            //@endcond</a>
<a name="ln106">        };</a>
<a name="ln107"> </a>
<a name="ln108">        /// BasketQueue internal statistics. May be used for debugging or profiling</a>
<a name="ln109">        /**</a>
<a name="ln110">            Template argument \p Counter defines type of counter.</a>
<a name="ln111">            Default is \p cds::atomicity::event_counter, that is weak, i.e. it is not guaranteed</a>
<a name="ln112">            strict event counting.</a>
<a name="ln113">            You may use stronger type of counter like as \p cds::atomicity::item_counter,</a>
<a name="ln114">            or even integral type, for example, \p int.</a>
<a name="ln115">        */</a>
<a name="ln116">        template &lt;typename Counter = cds::atomicity::event_counter &gt;</a>
<a name="ln117">        struct stat</a>
<a name="ln118">        {</a>
<a name="ln119">            typedef Counter counter_type;   ///&lt; Counter type</a>
<a name="ln120"> </a>
<a name="ln121">            counter_type m_EnqueueCount;    ///&lt; Enqueue call count</a>
<a name="ln122">            counter_type m_DequeueCount;    ///&lt; Dequeue call count</a>
<a name="ln123">            counter_type m_EnqueueRace;     ///&lt; Count of enqueue race conditions encountered</a>
<a name="ln124">            counter_type m_DequeueRace;     ///&lt; Count of dequeue race conditions encountered</a>
<a name="ln125">            counter_type m_AdvanceTailError;///&lt; Count of &quot;advance tail failed&quot; events</a>
<a name="ln126">            counter_type m_BadTail;         ///&lt; Count of events &quot;Tail is not pointed to the last item in the queue&quot;</a>
<a name="ln127">            counter_type m_TryAddBasket;    ///&lt; Count of attemps adding new item to a basket (only or BasketQueue, for other queue this metric is not used)</a>
<a name="ln128">            counter_type m_AddBasketCount;  ///&lt; Count of events &quot;Enqueue a new item into basket&quot; (only or BasketQueue, for other queue this metric is not used)</a>
<a name="ln129">            counter_type m_EmptyDequeue;    ///&lt; Count of dequeue from empty queue</a>
<a name="ln130"> </a>
<a name="ln131">            /// Register enqueue call</a>
<a name="ln132">            void onEnqueue()                { ++m_EnqueueCount; }</a>
<a name="ln133">            /// Register dequeue call</a>
<a name="ln134">            void onDequeue()                { ++m_DequeueCount; }</a>
<a name="ln135">            /// Register enqueue race event</a>
<a name="ln136">            void onEnqueueRace()            { ++m_EnqueueRace; }</a>
<a name="ln137">            /// Register dequeue race event</a>
<a name="ln138">            void onDequeueRace()            { ++m_DequeueRace; }</a>
<a name="ln139">            /// Register &quot;advance tail failed&quot; event</a>
<a name="ln140">            void onAdvanceTailFailed()      { ++m_AdvanceTailError; }</a>
<a name="ln141">            /// Register event &quot;Tail is not pointed to last item in the queue&quot;</a>
<a name="ln142">            void onBadTail()                { ++m_BadTail; }</a>
<a name="ln143">            /// Register an attempt t add new item to basket</a>
<a name="ln144">            void onTryAddBasket()           { ++m_TryAddBasket; }</a>
<a name="ln145">            /// Register event &quot;Enqueue a new item into basket&quot; (only or BasketQueue, for other queue this metric is not used)</a>
<a name="ln146">            void onAddBasket()              { ++m_AddBasketCount; }</a>
<a name="ln147">            /// Register dequeuing from empty queue</a>
<a name="ln148">            void onEmptyDequeue()           { ++m_EmptyDequeue; }</a>
<a name="ln149"> </a>
<a name="ln150"> </a>
<a name="ln151">            //@cond</a>
<a name="ln152">            void reset()</a>
<a name="ln153">            {</a>
<a name="ln154">                m_EnqueueCount.reset();</a>
<a name="ln155">                m_DequeueCount.reset();</a>
<a name="ln156">                m_EnqueueRace.reset();</a>
<a name="ln157">                m_DequeueRace.reset();</a>
<a name="ln158">                m_AdvanceTailError.reset();</a>
<a name="ln159">                m_BadTail.reset();</a>
<a name="ln160">                m_TryAddBasket.reset();</a>
<a name="ln161">                m_AddBasketCount.reset();</a>
<a name="ln162">                m_EmptyDequeue.reset();</a>
<a name="ln163">            }</a>
<a name="ln164"> </a>
<a name="ln165">            stat&amp; operator +=( stat const&amp; s )</a>
<a name="ln166">            {</a>
<a name="ln167">                m_EnqueueCount  += s.m_EnqueueCount.get();</a>
<a name="ln168">                m_DequeueCount  += s.m_DequeueCount.get();</a>
<a name="ln169">                m_EnqueueRace   += s.m_EnqueueRace.get();</a>
<a name="ln170">                m_DequeueRace   += s.m_DequeueRace.get();</a>
<a name="ln171">                m_AdvanceTailError += s.m_AdvanceTailError.get();</a>
<a name="ln172">                m_BadTail       += s.m_BadTail.get();</a>
<a name="ln173">                m_TryAddBasket  += s.m_TryAddBasket.get();</a>
<a name="ln174">                m_AddBasketCount += s.m_AddBasketCount.get();</a>
<a name="ln175">                m_EmptyDequeue  += s.m_EmptyDequeue.get();</a>
<a name="ln176">                return *this;</a>
<a name="ln177">            }</a>
<a name="ln178">            //@endcond</a>
<a name="ln179">        };</a>
<a name="ln180"> </a>
<a name="ln181">        /// Dummy BasketQueue statistics - no counting is performed, no overhead. Support interface like \p basket_queue::stat</a>
<a name="ln182">        struct empty_stat</a>
<a name="ln183">        {</a>
<a name="ln184">            //@cond</a>
<a name="ln185">            void onEnqueue()            const {}</a>
<a name="ln186">            void onDequeue()            const {}</a>
<a name="ln187">            void onEnqueueRace()        const {}</a>
<a name="ln188">            void onDequeueRace()        const {}</a>
<a name="ln189">            void onAdvanceTailFailed()  const {}</a>
<a name="ln190">            void onBadTail()            const {}</a>
<a name="ln191">            void onTryAddBasket()       const {}</a>
<a name="ln192">            void onAddBasket()          const {}</a>
<a name="ln193">            void onEmptyDequeue()       const {}</a>
<a name="ln194"> </a>
<a name="ln195">            void reset() {}</a>
<a name="ln196">            empty_stat&amp; operator +=( empty_stat const&amp; )</a>
<a name="ln197">            {</a>
<a name="ln198">                return *this;</a>
<a name="ln199">            }</a>
<a name="ln200">            //@endcond</a>
<a name="ln201">        };</a>
<a name="ln202"> </a>
<a name="ln203">        /// BasketQueue default type traits</a>
<a name="ln204">        struct traits</a>
<a name="ln205">        {</a>
<a name="ln206">            /// Back-off strategy</a>
<a name="ln207">            typedef cds::backoff::empty             back_off;</a>
<a name="ln208"> </a>
<a name="ln209">            /// Hook, possible types are \p basket_queue::base_hook, \p basket_queue::member_hook, \p basket_queue::traits_hook</a>
<a name="ln210">            typedef basket_queue::base_hook&lt;&gt;       hook;</a>
<a name="ln211"> </a>
<a name="ln212">            /// The functor used for dispose removed items. Default is \p opt::v::empty_disposer. This option is used for dequeuing</a>
<a name="ln213">            typedef opt::v::empty_disposer          disposer;</a>
<a name="ln214"> </a>
<a name="ln215">            /// Item counting feature; by default, disabled. Use \p cds::atomicity::item_counter to enable item counting</a>
<a name="ln216">            typedef atomicity::empty_item_counter   item_counter;</a>
<a name="ln217"> </a>
<a name="ln218">            /// Internal statistics (by default, disabled)</a>
<a name="ln219">            /**</a>
<a name="ln220">                Possible option value are: \p basket_queue::stat, \p basket_queue::empty_stat (the default),</a>
<a name="ln221">                user-provided class that supports \p %basket_queue::stat interface.</a>
<a name="ln222">            */</a>
<a name="ln223">            typedef basket_queue::empty_stat        stat;</a>
<a name="ln224"> </a>
<a name="ln225">            /// C++ memory ordering model</a>
<a name="ln226">            /**</a>
<a name="ln227">                Can be \p opt::v::relaxed_ordering (relaxed memory model, the default)</a>
<a name="ln228">                or \p opt::v::sequential_consistent (sequentially consisnent memory model).</a>
<a name="ln229">            */</a>
<a name="ln230">            typedef opt::v::relaxed_ordering        memory_model;</a>
<a name="ln231"> </a>
<a name="ln232">            /// Link checking, see \p cds::opt::link_checker</a>
<a name="ln233">            static constexpr const opt::link_check_type link_checker = opt::debug_check_link;</a>
<a name="ln234"> </a>
<a name="ln235">            /// Padding for internal critical atomic data. Default is \p opt::cache_line_padding</a>
<a name="ln236">            enum { padding = opt::cache_line_padding };</a>
<a name="ln237">        };</a>
<a name="ln238"> </a>
<a name="ln239"> </a>
<a name="ln240">        /// Metafunction converting option list to \p basket_queue::traits</a>
<a name="ln241">        /**</a>
<a name="ln242">            Supported \p Options are:</a>
<a name="ln243">            - \p opt::hook - hook used. Possible hooks are: \p basket_queue::base_hook, \p basket_queue::member_hook, \p basket_queue::traits_hook.</a>
<a name="ln244">                If the option is not specified, \p %basket_queue::base_hook&lt;&gt; is used.</a>
<a name="ln245">            - \p opt::back_off - back-off strategy used, default is \p cds::backoff::empty.</a>
<a name="ln246">            - \p opt::disposer - the functor used for dispose removed items. Default is \p opt::v::empty_disposer. This option is used</a>
<a name="ln247">                when dequeuing.</a>
<a name="ln248">            - \p opt::link_checker - the type of node's link fields checking. Default is \p opt::debug_check_link</a>
<a name="ln249">            - \p opt::item_counter - the type of item counting feature. Default is \p cds::atomicity::empty_item_counter (item counting disabled)</a>
<a name="ln250">                To enable item counting use \p cds::atomicity::item_counter</a>
<a name="ln251">            - \p opt::stat - the type to gather internal statistics.</a>
<a name="ln252">                Possible statistics types are: \p basket_queue::stat, \p basket_queue::empty_stat, user-provided class that supports \p %basket_queue::stat interface.</a>
<a name="ln253">                Default is \p %basket_queue::empty_stat (internal statistics disabled).</a>
<a name="ln254">            - \p opt::padding - padding for internal critical atomic data. Default is \p opt::cache_line_padding</a>
<a name="ln255">            - \p opt::memory_model - C++ memory ordering model. Can be \p opt::v::relaxed_ordering (relaxed memory model, the default)</a>
<a name="ln256">                or \p opt::v::sequential_consistent (sequentially consisnent memory model).</a>
<a name="ln257"> </a>
<a name="ln258">            Example: declare \p %BasketQueue with item counting and internal statistics</a>
<a name="ln259">            \code</a>
<a name="ln260">            typedef cds::intrusive::BasketQueue&lt; cds::gc::HP, Foo,</a>
<a name="ln261">                typename cds::intrusive::basket_queue::make_traits&lt;</a>
<a name="ln262">                    cds::intrusive::opt:hook&lt; cds::intrusive::basket_queue::base_hook&lt; cds::opt::gc&lt;cds:gc::HP&gt; &gt;&gt;,</a>
<a name="ln263">                    cds::opt::item_counte&lt; cds::atomicity::item_counter &gt;,</a>
<a name="ln264">                    cds::opt::stat&lt; cds::intrusive::basket_queue::stat&lt;&gt; &gt;</a>
<a name="ln265">                &gt;::type</a>
<a name="ln266">            &gt; myQueue;</a>
<a name="ln267">            \endcode</a>
<a name="ln268">        */</a>
<a name="ln269">        template &lt;typename... Options&gt;</a>
<a name="ln270">        struct make_traits {</a>
<a name="ln271">#   ifdef CDS_DOXYGEN_INVOKED</a>
<a name="ln272">            typedef implementation_defined type;   ///&lt; Metafunction result</a>
<a name="ln273">#   else</a>
<a name="ln274">            typedef typename cds::opt::make_options&lt;</a>
<a name="ln275">                typename cds::opt::find_type_traits&lt; traits, Options... &gt;::type</a>
<a name="ln276">                , Options...</a>
<a name="ln277">            &gt;::type type;</a>
<a name="ln278">#   endif</a>
<a name="ln279">        };</a>
<a name="ln280">    }   // namespace basket_queue</a>
<a name="ln281"> </a>
<a name="ln282">    /// Basket lock-free queue (intrusive variant)</a>
<a name="ln283">    /** @ingroup cds_intrusive_queue</a>
<a name="ln284">        Implementation of basket queue algorithm.</a>
<a name="ln285"> </a>
<a name="ln286">        \par Source:</a>
<a name="ln287">            [2007] Moshe Hoffman, Ori Shalev, Nir Shavit &quot;The Baskets Queue&quot;</a>
<a name="ln288"> </a>
<a name="ln289">        &lt;b&gt;Key idea&lt;/b&gt;</a>
<a name="ln290"> </a>
<a name="ln291">        In the 'basket' approach, instead of</a>
<a name="ln292">        the traditional ordered list of nodes, the queue consists of an ordered list of groups</a>
<a name="ln293">        of nodes (logical baskets). The order of nodes in each basket need not be specified, and in</a>
<a name="ln294">        fact, it is easiest to maintain them in FIFO order. The baskets fulfill the following basic</a>
<a name="ln295">        rules:</a>
<a name="ln296">        - Each basket has a time interval in which all its nodes' enqueue operations overlap.</a>
<a name="ln297">        - The baskets are ordered by the order of their respective time intervals.</a>
<a name="ln298">        - For each basket, its nodes' dequeue operations occur after its time interval.</a>
<a name="ln299">        - The dequeue operations are performed according to the order of baskets.</a>
<a name="ln300"> </a>
<a name="ln301">        Two properties define the FIFO order of nodes:</a>
<a name="ln302">        - The order of nodes in a basket is not specified.</a>
<a name="ln303">        - The order of nodes in different baskets is the FIFO-order of their respective baskets.</a>
<a name="ln304"> </a>
<a name="ln305">        In algorithms such as the MS-queue or optimistic</a>
<a name="ln306">        queue, threads enqueue items by applying a Compare-and-swap (CAS) operation to the</a>
<a name="ln307">        queue's tail pointer, and all the threads that fail on a particular CAS operation (and also</a>
<a name="ln308">        the winner of that CAS) overlap in time. In particular, they share the time interval of</a>
<a name="ln309">        the CAS operation itself. Hence, all the threads that fail to CAS on the tail-node of</a>
<a name="ln310">        the queue may be inserted into the same basket. By integrating the basket-mechanism</a>
<a name="ln311">        as the back-off mechanism, the time usually spent on backing-off before trying to link</a>
<a name="ln312">        onto the new tail, can now be utilized to insert the failed operations into the basket,</a>
<a name="ln313">        allowing enqueues to complete sooner. In the meantime, the next successful CAS operations</a>
<a name="ln314">        by enqueues allow new baskets to be formed down the list, and these can be</a>
<a name="ln315">        filled concurrently. Moreover, the failed operations don't retry their link attempt on the</a>
<a name="ln316">        new tail, lowering the overall contention on it. This leads to a queue</a>
<a name="ln317">        algorithm that unlike all former concurrent queue algorithms requires virtually no tuning</a>
<a name="ln318">        of the backoff mechanisms to reduce contention, making the algorithm an attractive</a>
<a name="ln319">        out-of-the-box queue.</a>
<a name="ln320"> </a>
<a name="ln321">        In order to enqueue, just as in \p MSQueue, a thread first tries to link the new node to</a>
<a name="ln322">        the last node. If it failed to do so, then another thread has already succeeded. Thus it</a>
<a name="ln323">        tries to insert the new node into the new basket that was created by the winner thread.</a>
<a name="ln324">        To dequeue a node, a thread first reads the head of the queue to obtain the</a>
<a name="ln325">        oldest basket. It may then dequeue any node in the oldest basket.</a>
<a name="ln326"> </a>
<a name="ln327">        &lt;b&gt;Template arguments:&lt;/b&gt;</a>
<a name="ln328">        - \p GC - garbage collector type: \p gc::HP, \p gc::DHP</a>
<a name="ln329">        - \p T - type of value to be stored in the queue</a>
<a name="ln330">        - \p Traits - queue traits, default is \p basket_queue::traits. You can use \p basket_queue::make_traits</a>
<a name="ln331">            metafunction to make your traits or just derive your traits from \p %basket_queue::traits:</a>
<a name="ln332">            \code</a>
<a name="ln333">            struct myTraits: public cds::intrusive::basket_queue::traits {</a>
<a name="ln334">                typedef cds::intrusive::basket_queue::stat&lt;&gt; stat;</a>
<a name="ln335">                typedef cds::atomicity::item_counter    item_counter;</a>
<a name="ln336">            };</a>
<a name="ln337">            typedef cds::intrusive::BasketQueue&lt; cds::gc::HP, Foo, myTraits &gt; myQueue;</a>
<a name="ln338"> </a>
<a name="ln339">            // Equivalent make_traits example:</a>
<a name="ln340">            typedef cds::intrusive::BasketQueue&lt; cds::gc::HP, Foo,</a>
<a name="ln341">                typename cds::intrusive::basket_queue::make_traits&lt;</a>
<a name="ln342">                    cds::opt::stat&lt; cds::intrusive::basket_queue::stat&lt;&gt; &gt;,</a>
<a name="ln343">                    cds::opt::item_counter&lt; cds::atomicity::item_counter &gt;</a>
<a name="ln344">                &gt;::type</a>
<a name="ln345">            &gt; myQueue;</a>
<a name="ln346">            \endcode</a>
<a name="ln347"> </a>
<a name="ln348">        Garbage collecting schema \p GC must be consistent with the \p basket_queue::node GC.</a>
<a name="ln349"> </a>
<a name="ln350">        \par About item disposing</a>
<a name="ln351">        Like \p MSQueue, the Baskets queue algo has a key feature: even if the queue is empty it contains one item that is &quot;dummy&quot; one from</a>
<a name="ln352">        the standpoint of the algo. See \p dequeue() function doc for explanation.</a>
<a name="ln353"> </a>
<a name="ln354">        \par Examples</a>
<a name="ln355">        \code</a>
<a name="ln356">        #include &lt;cds/intrusive/basket_queue.h&gt;</a>
<a name="ln357">        #include &lt;cds/gc/hp.h&gt;</a>
<a name="ln358"> </a>
<a name="ln359">        namespace ci = cds::inrtusive;</a>
<a name="ln360">        typedef cds::gc::HP hp_gc;</a>
<a name="ln361"> </a>
<a name="ln362">        // Basket queue with Hazard Pointer garbage collector, base hook + item disposer:</a>
<a name="ln363">        struct Foo: public ci::basket_queue::node&lt; hp_gc &gt;</a>
<a name="ln364">        {</a>
<a name="ln365">            // Your data</a>
<a name="ln366">            ...</a>
<a name="ln367">        };</a>
<a name="ln368"> </a>
<a name="ln369">        // Disposer for Foo struct just deletes the object passed in</a>
<a name="ln370">        struct fooDisposer {</a>
<a name="ln371">            void operator()( Foo * p )</a>
<a name="ln372">            {</a>
<a name="ln373">                delete p;</a>
<a name="ln374">            }</a>
<a name="ln375">        };</a>
<a name="ln376"> </a>
<a name="ln377">        struct fooTraits: public ci::basket_queue::traits {</a>
<a name="ln378">            typedef ci::basket_queue::base_hook&lt; ci::opt::gc&lt;hp_gc&gt; &gt; hook;</a>
<a name="ln379">            typedef fooDisposer disposer;</a>
<a name="ln380">        };</a>
<a name="ln381">        typedef ci::BasketQueue&lt; hp_gc, Foo, fooTraits &gt; fooQueue;</a>
<a name="ln382"> </a>
<a name="ln383">        // BasketQueue with Hazard Pointer garbage collector,</a>
<a name="ln384">        // member hook + item disposer + item counter,</a>
<a name="ln385">        // without padding of internal queue data:</a>
<a name="ln386">        struct Bar</a>
<a name="ln387">        {</a>
<a name="ln388">            // Your data</a>
<a name="ln389">            ...</a>
<a name="ln390">            ci::basket_queue::node&lt; hp_gc &gt; hMember;</a>
<a name="ln391">        };</a>
<a name="ln392"> </a>
<a name="ln393">        struct barTraits: public</a>
<a name="ln394">            ci::basket_queue::make_traits&lt;</a>
<a name="ln395">                ci::opt::hook&lt;</a>
<a name="ln396">                    ci::basket_queue::member_hook&lt;</a>
<a name="ln397">                        offsetof(Bar, hMember)</a>
<a name="ln398">                        ,ci::opt::gc&lt;hp_gc&gt;</a>
<a name="ln399">                    &gt;</a>
<a name="ln400">                &gt;</a>
<a name="ln401">                ,ci::opt::disposer&lt; fooDisposer &gt;</a>
<a name="ln402">                ,cds::opt::item_counter&lt; cds::atomicity::item_counter &gt;</a>
<a name="ln403">                ,cds::opt::padding&lt; cds::opt::no_special_padding &gt;</a>
<a name="ln404">            &gt;::type</a>
<a name="ln405">        {};</a>
<a name="ln406">        typedef ci::BasketQueue&lt; hp_gc, Bar, barTraits &gt; barQueue;</a>
<a name="ln407">        \endcode</a>
<a name="ln408">    */</a>
<a name="ln409">    template &lt;typename GC, typename T, typename Traits = basket_queue::traits &gt;</a>
<a name="ln410">    class BasketQueue</a>
<a name="ln411">    {</a>
<a name="ln412">    public:</a>
<a name="ln413">        typedef GC gc;          ///&lt; Garbage collector</a>
<a name="ln414">        typedef T  value_type;  ///&lt; type of value stored in the queue</a>
<a name="ln415">        typedef Traits traits;  ///&lt; Queue traits</a>
<a name="ln416">        typedef typename traits::hook       hook;       ///&lt; hook type</a>
<a name="ln417">        typedef typename hook::node_type    node_type;  ///&lt; node type</a>
<a name="ln418">        typedef typename traits::disposer   disposer;   ///&lt; disposer used</a>
<a name="ln419">        typedef typename get_node_traits&lt; value_type, node_type, hook&gt;::type node_traits;   ///&lt; node traits</a>
<a name="ln420">        typedef typename single_link::get_link_checker&lt; node_type, traits::link_checker &gt;::type link_checker;   ///&lt; link checker</a>
<a name="ln421"> </a>
<a name="ln422">        typedef typename traits::back_off       back_off;     ///&lt; back-off strategy</a>
<a name="ln423">        typedef typename traits::item_counter   item_counter; ///&lt; Item counting policy used</a>
<a name="ln424">        typedef typename traits::stat           stat;         ///&lt; Internal statistics policy used</a>
<a name="ln425">        typedef typename traits::memory_model   memory_model; ///&lt; Memory ordering. See cds::opt::memory_model option</a>
<a name="ln426"> </a>
<a name="ln427">        /// Rebind template arguments</a>
<a name="ln428">        template &lt;typename GC2, typename T2, typename Traits2&gt;</a>
<a name="ln429">        struct rebind {</a>
<a name="ln430">            typedef BasketQueue&lt; GC2, T2, Traits2&gt; other   ;   ///&lt; Rebinding result</a>
<a name="ln431">        };</a>
<a name="ln432"> </a>
<a name="ln433">        static constexpr const size_t c_nHazardPtrCount = 6 ; ///&lt; Count of hazard pointer required for the algorithm</a>
<a name="ln434"> </a>
<a name="ln435">    protected:</a>
<a name="ln436">        //@cond</a>
<a name="ln437">        typedef typename node_type::marked_ptr   marked_ptr;</a>
<a name="ln438">        typedef typename node_type::atomic_marked_ptr atomic_marked_ptr;</a>
<a name="ln439"> </a>
<a name="ln440">        // GC and node_type::gc must be the same</a>
<a name="ln441">        static_assert( std::is_same&lt;gc, typename node_type::gc&gt;::value, &quot;GC and node_type::gc must be the same&quot;);</a>
<a name="ln442">        //@endcond</a>
<a name="ln443"> </a>
<a name="ln444">        atomic_marked_ptr    m_pHead ;           ///&lt; Queue's head pointer (aligned)</a>
<a name="ln445">        //@cond</a>
<a name="ln446">        typename opt::details::apply_padding&lt; atomic_marked_ptr, traits::padding &gt;::padding_type pad1_;</a>
<a name="ln447">        //@endcond</a>
<a name="ln448">        atomic_marked_ptr    m_pTail ;           ///&lt; Queue's tail pointer (aligned)</a>
<a name="ln449">        //@cond</a>
<a name="ln450">        typename opt::details::apply_padding&lt; atomic_marked_ptr, traits::padding &gt;::padding_type pad2_;</a>
<a name="ln451">        //@endcond</a>
<a name="ln452">        node_type           m_Dummy ;           ///&lt; dummy node</a>
<a name="ln453">        //@cond</a>
<a name="ln454">        typename opt::details::apply_padding&lt; node_type, traits::padding &gt;::padding_type pad3_;</a>
<a name="ln455">        //@endcond</a>
<a name="ln456">        item_counter        m_ItemCounter   ;   ///&lt; Item counter</a>
<a name="ln457">        stat                m_Stat  ;           ///&lt; Internal statistics</a>
<a name="ln458">        //@cond</a>
<a name="ln459">        size_t const        m_nMaxHops;</a>
<a name="ln460">        //@endcond</a>
<a name="ln461"> </a>
<a name="ln462">        //@cond</a>
<a name="ln463"> </a>
<a name="ln464">        struct dequeue_result {</a>
<a name="ln465">            typename gc::template GuardArray&lt;3&gt;  guards;</a>
<a name="ln466">            node_type * pNext;</a>
<a name="ln467">        };</a>
<a name="ln468"> </a>
<a name="ln469">        bool do_dequeue( dequeue_result&amp; res, bool bDeque )</a>
<a name="ln470">        {</a>
<a name="ln471">            // Note:</a>
<a name="ln472">            // If bDeque == false then the function is called from empty method and no real dequeuing operation is performed</a>
<a name="ln473"> </a>
<a name="ln474">            back_off bkoff;</a>
<a name="ln475"> </a>
<a name="ln476">            marked_ptr h;</a>
<a name="ln477">            marked_ptr t;</a>
<a name="ln478">            marked_ptr pNext;</a>
<a name="ln479"> </a>
<a name="ln480">            while ( true ) {</a>
<a name="ln481">                h = res.guards.protect( 0, m_pHead, []( marked_ptr p ) -&gt; value_type * { return node_traits::to_value_ptr( p.ptr());});</a>
<a name="ln482">                t = res.guards.protect( 1, m_pTail, []( marked_ptr p ) -&gt; value_type * { return node_traits::to_value_ptr( p.ptr());});</a>
<a name="ln483">                pNext = res.guards.protect( 2, h-&gt;m_pNext, []( marked_ptr p ) -&gt; value_type * { return node_traits::to_value_ptr( p.ptr());});</a>
<a name="ln484"> </a>
<a name="ln485">                if ( h == m_pHead.load( memory_model::memory_order_acquire )) {</a>
<a name="ln486">                    if ( h.ptr() == t.ptr()) {</a>
<a name="ln487">                        if ( !pNext.ptr()) {</a>
<a name="ln488">                            m_Stat.onEmptyDequeue();</a>
<a name="ln489">                            return false;</a>
<a name="ln490">                        }</a>
<a name="ln491"> </a>
<a name="ln492">                        {</a>
<a name="ln493">                            typename gc::Guard g;</a>
<a name="ln494">                            while ( pNext-&gt;m_pNext.load(memory_model::memory_order_relaxed).ptr() &amp;&amp; m_pTail.load(memory_model::memory_order_relaxed) == t ) {</a>
<a name="ln495">                                pNext = g.protect( pNext-&gt;m_pNext, []( marked_ptr p ) -&gt; value_type * { return node_traits::to_value_ptr( p.ptr());});</a>
<a name="ln496">                                res.guards.copy( 2, g );</a>
<a name="ln497">                            }</a>
<a name="ln498">                        }</a>
<a name="ln499"> </a>
<a name="ln500">                        m_pTail.compare_exchange_weak( t, marked_ptr(pNext.ptr()), memory_model::memory_order_acquire, atomics::memory_order_relaxed );</a>
<a name="ln501">                    }</a>
<a name="ln502">                    else {</a>
<a name="ln503">                        marked_ptr iter( h );</a>
<a name="ln504">                        size_t hops = 0;</a>
<a name="ln505"> </a>
<a name="ln506">                        typename gc::Guard g;</a>
<a name="ln507"> </a>
<a name="ln508">                        while ( pNext.ptr() &amp;&amp; pNext.bits() &amp;&amp; iter.ptr() != t.ptr() &amp;&amp; m_pHead.load(memory_model::memory_order_relaxed) == h ) {</a>
<a name="ln509">                            iter = pNext;</a>
<a name="ln510">                            g.assign( res.guards.template get&lt;value_type&gt;(2));</a>
<a name="ln511">                            pNext = res.guards.protect( 2, pNext-&gt;m_pNext, []( marked_ptr p ) -&gt; value_type * { return node_traits::to_value_ptr( p.ptr());});</a>
<a name="ln512">                            ++hops;</a>
<a name="ln513">                        }</a>
<a name="ln514"> </a>
<a name="ln515">                        if ( m_pHead.load(memory_model::memory_order_relaxed) != h )</a>
<a name="ln516">                            continue;</a>
<a name="ln517"> </a>
<a name="ln518">                        if ( iter.ptr() == t.ptr())</a>
<a name="ln519">                            free_chain( h, iter );</a>
<a name="ln520">                        else if ( bDeque ) {</a>
<a name="ln521">                            res.pNext = pNext.ptr();</a>
<a name="ln522"> </a>
<a name="ln523">                            if ( iter-&gt;m_pNext.compare_exchange_weak( pNext, marked_ptr( pNext.ptr(), 1 ), memory_model::memory_order_acquire, atomics::memory_order_relaxed )) {</a>
<a name="ln524">                                if ( hops &gt;= m_nMaxHops )</a>
<a name="ln525">                                    free_chain( h, pNext );</a>
<a name="ln526">                                break;</a>
<a name="ln527">                            }</a>
<a name="ln528">                        }</a>
<a name="ln529">                        else</a>
<a name="ln530">                            return true;</a>
<a name="ln531">                    }</a>
<a name="ln532">                }</a>
<a name="ln533"> </a>
<a name="ln534">                if ( bDeque )</a>
<a name="ln535">                    m_Stat.onDequeueRace();</a>
<a name="ln536">                bkoff();</a>
<a name="ln537">            }</a>
<a name="ln538"> </a>
<a name="ln539">            if ( bDeque ) {</a>
<a name="ln540">                --m_ItemCounter;</a>
<a name="ln541">                m_Stat.onDequeue();</a>
<a name="ln542">            }</a>
<a name="ln543"> </a>
<a name="ln544">            return true;</a>
<a name="ln545">        }</a>
<a name="ln546"> </a>
<a name="ln547">        void free_chain( marked_ptr head, marked_ptr newHead )</a>
<a name="ln548">        {</a>
<a name="ln549">            // &quot;head&quot; and &quot;newHead&quot; are guarded</a>
<a name="ln550"> </a>
<a name="ln551">            if ( m_pHead.compare_exchange_strong( head, marked_ptr(newHead.ptr()), memory_model::memory_order_release, atomics::memory_order_relaxed ))</a>
<a name="ln552">            {</a>
<a name="ln553">                typename gc::template GuardArray&lt;2&gt; guards;</a>
<a name="ln554">                guards.assign( 0, node_traits::to_value_ptr(head.ptr()));</a>
<a name="ln555">                while ( head.ptr() != newHead.ptr()) {</a>
<a name="ln556">                    marked_ptr pNext = guards.protect( 1, head-&gt;m_pNext, []( marked_ptr p ) -&gt; value_type * { return node_traits::to_value_ptr( p.ptr());});</a>
<a name="ln557">                    assert( pNext.bits() != 0 );</a>
<a name="ln558">                    dispose_node( head.ptr());</a>
<a name="ln559">                    guards.copy( 0, 1 );</a>
<a name="ln560">                    head = pNext;</a>
<a name="ln561">                }</a>
<a name="ln562">            }</a>
<a name="ln563">        }</a>
<a name="ln564"> </a>
<a name="ln565">        static void clear_links( node_type * pNode )</a>
<a name="ln566">        {</a>
<a name="ln567">            pNode-&gt;m_pNext.store( marked_ptr( nullptr ), memory_model::memory_order_release );</a>
<a name="ln568">        }</a>
<a name="ln569"> </a>
<a name="ln570">        void dispose_node( node_type * p )</a>
<a name="ln571">        {</a>
<a name="ln572">            if ( p != &amp;m_Dummy ) {</a>
<a name="ln573">                struct internal_disposer</a>
<a name="ln574">                {</a>
<a name="ln575">                    void operator()( value_type * p )</a>
<a name="ln576">                    {</a>
<a name="ln577">                        assert( p != nullptr );</a>
<a name="ln578">                        BasketQueue::clear_links( node_traits::to_node_ptr( p ));</a>
<a name="ln579">                        disposer()(p);</a>
<a name="ln580">                    }</a>
<a name="ln581">                };</a>
<a name="ln582">                gc::template retire&lt;internal_disposer&gt;( node_traits::to_value_ptr(p));</a>
<a name="ln583">            }</a>
<a name="ln584">        }</a>
<a name="ln585">        //@endcond</a>
<a name="ln586"> </a>
<a name="ln587">    public:</a>
<a name="ln588">        /// Initializes empty queue</a>
<a name="ln589">        BasketQueue()</a>
<a name="ln590">            : m_pHead( &amp;m_Dummy )</a>
<a name="ln591">            , m_pTail( &amp;m_Dummy )</a>
<a name="ln592">            , m_nMaxHops( 3 )</a>
<a name="ln593">        {}</a>
<a name="ln594"> </a>
<a name="ln595">        /// Destructor clears the queue</a>
<a name="ln596">        /**</a>
<a name="ln597">            Since the baskets queue contains at least one item even</a>
<a name="ln598">            if the queue is empty, the destructor may call item disposer.</a>
<a name="ln599">        */</a>
<a name="ln600">        ~BasketQueue()</a>
<a name="ln601">        {</a>
<a name="ln602">            clear();</a>
<a name="ln603"> </a>
<a name="ln604">            node_type * pHead = m_pHead.load(memory_model::memory_order_relaxed).ptr();</a>
<a name="ln605">            assert( pHead != nullptr );</a>
<a name="ln606"> </a>
<a name="ln607">            {</a>
<a name="ln608">                node_type * pNext = pHead-&gt;m_pNext.load( memory_model::memory_order_relaxed ).ptr();</a>
<a name="ln609">                while ( pNext ) {</a>
<a name="ln610">                    node_type * p = pNext;</a>
<a name="ln611">                    pNext = pNext-&gt;m_pNext.load( memory_model::memory_order_relaxed ).ptr();</a>
<a name="ln612">                    p-&gt;m_pNext.store( marked_ptr(), memory_model::memory_order_relaxed );</a>
<a name="ln613">                    dispose_node( p );</a>
<a name="ln614">                }</a>
<a name="ln615">                pHead-&gt;m_pNext.store( marked_ptr(), memory_model::memory_order_relaxed );</a>
<a name="ln616">                //m_pTail.store( marked_ptr( pHead ), memory_model::memory_order_relaxed );</a>
<a name="ln617">            }</a>
<a name="ln618"> </a>
<a name="ln619">            m_pHead.store( marked_ptr( nullptr ), memory_model::memory_order_relaxed );</a>
<a name="ln620">            m_pTail.store( marked_ptr( nullptr ), memory_model::memory_order_relaxed );</a>
<a name="ln621"> </a>
<a name="ln622">            dispose_node( pHead );</a>
<a name="ln623">        }</a>
<a name="ln624"> </a>
<a name="ln625">        /// Enqueues \p val value into the queue.</a>
<a name="ln626">        /** @anchor cds_intrusive_BasketQueue_enqueue</a>
<a name="ln627">            The function always returns \p true.</a>
<a name="ln628">        */</a>
<a name="ln629">        bool enqueue( value_type&amp; val )</a>
<a name="ln630">        {</a>
<a name="ln631">            node_type * pNew = node_traits::to_node_ptr( val );</a>
<a name="ln632">            link_checker::is_empty( pNew );</a>
<a name="ln633"> </a>
<a name="ln634">            typename gc::Guard guard;</a>
<a name="ln635">            typename gc::Guard gNext;</a>
<a name="ln636">            back_off bkoff;</a>
<a name="ln637"> </a>
<a name="ln638">            marked_ptr t;</a>
<a name="ln639">            while ( true ) {</a>
<a name="ln640">                t = guard.protect( m_pTail, []( marked_ptr p ) -&gt; value_type * { return node_traits::to_value_ptr( p.ptr());});</a>
<a name="ln641"> </a>
<a name="ln642">                marked_ptr pNext = t-&gt;m_pNext.load(memory_model::memory_order_relaxed );</a>
<a name="ln643"> </a>
<a name="ln644">                if ( pNext.ptr() == nullptr ) {</a>
<a name="ln645">                    pNew-&gt;m_pNext.store( marked_ptr(), memory_model::memory_order_relaxed );</a>
<a name="ln646">                    if ( t-&gt;m_pNext.compare_exchange_weak( pNext, marked_ptr(pNew), memory_model::memory_order_release, atomics::memory_order_relaxed )) {</a>
<a name="ln647">                        if ( !m_pTail.compare_exchange_strong( t, marked_ptr(pNew), memory_model::memory_order_release, atomics::memory_order_relaxed ))</a>
<a name="ln648">                            m_Stat.onAdvanceTailFailed();</a>
<a name="ln649">                        break;</a>
<a name="ln650">                    }</a>
<a name="ln651"> </a>
<a name="ln652">                    // Try adding to basket</a>
<a name="ln653">                    m_Stat.onTryAddBasket();</a>
<a name="ln654"> </a>
<a name="ln655">                    // Reread tail next</a>
<a name="ln656">                try_again:</a>
<a name="ln657">                    pNext = gNext.protect( t-&gt;m_pNext, []( marked_ptr p ) -&gt; value_type * { return node_traits::to_value_ptr( p.ptr());});</a>
<a name="ln658"> </a>
<a name="ln659">                    // add to the basket</a>
<a name="ln660">                    if ( m_pTail.load( memory_model::memory_order_relaxed ) == t</a>
<a name="ln661">                         &amp;&amp; t-&gt;m_pNext.load( memory_model::memory_order_relaxed) == pNext</a>
<a name="ln662">                         &amp;&amp; !pNext.bits())</a>
<a name="ln663">                    {</a>
<a name="ln664">                        bkoff();</a>
<a name="ln665">                        pNew-&gt;m_pNext.store( pNext, memory_model::memory_order_relaxed );</a>
<a name="ln666">                        if ( t-&gt;m_pNext.compare_exchange_weak( pNext, marked_ptr( pNew ), memory_model::memory_order_release, atomics::memory_order_relaxed )) {</a>
<a name="ln667">                            m_Stat.onAddBasket();</a>
<a name="ln668">                            break;</a>
<a name="ln669">                        }</a>
<a name="ln670">                        goto try_again;</a>
<a name="ln671">                    }</a>
<a name="ln672">                }</a>
<a name="ln673">                else {</a>
<a name="ln674">                    // Tail is misplaced, advance it</a>
<a name="ln675"> </a>
<a name="ln676">                    typename gc::template GuardArray&lt;2&gt; g;</a>
<a name="ln677">                    g.assign( 0, node_traits::to_value_ptr( pNext.ptr()));</a>
<a name="ln678">                    if ( m_pTail.load( memory_model::memory_order_acquire ) != t</a>
<a name="ln679">                      || t-&gt;m_pNext.load( memory_model::memory_order_relaxed ) != pNext )</a>
<a name="ln680">                    {</a>
<a name="ln681">                        m_Stat.onEnqueueRace();</a>
<a name="ln682">                        bkoff();</a>
<a name="ln683">                        continue;</a>
<a name="ln684">                    }</a>
<a name="ln685"> </a>
<a name="ln686">                    marked_ptr p;</a>
<a name="ln687">                    bool bTailOk = true;</a>
<a name="ln688">                    while ( (p = pNext-&gt;m_pNext.load( memory_model::memory_order_acquire )).ptr() != nullptr )</a>
<a name="ln689">                    {</a>
<a name="ln690">                        bTailOk = m_pTail.load( memory_model::memory_order_relaxed ) == t;</a>
<a name="ln691">                        if ( !bTailOk )</a>
<a name="ln692">                            break;</a>
<a name="ln693"> </a>
<a name="ln694">                        g.assign( 1, node_traits::to_value_ptr( p.ptr()));</a>
<a name="ln695">                        if ( pNext-&gt;m_pNext.load( memory_model::memory_order_relaxed ) != p )</a>
<a name="ln696">                            continue;</a>
<a name="ln697">                        pNext = p;</a>
<a name="ln698">                        g.assign( 0, g.template get&lt;value_type&gt;( 1 ));</a>
<a name="ln699">                    }</a>
<a name="ln700">                    if ( !bTailOk || !m_pTail.compare_exchange_weak( t, marked_ptr( pNext.ptr()), memory_model::memory_order_release, atomics::memory_order_relaxed ))</a>
<a name="ln701">                        m_Stat.onAdvanceTailFailed();</a>
<a name="ln702"> </a>
<a name="ln703">                    m_Stat.onBadTail();</a>
<a name="ln704">                }</a>
<a name="ln705"> </a>
<a name="ln706">                m_Stat.onEnqueueRace();</a>
<a name="ln707">            }</a>
<a name="ln708"> </a>
<a name="ln709">            ++m_ItemCounter;</a>
<a name="ln710">            m_Stat.onEnqueue();</a>
<a name="ln711"> </a>
<a name="ln712">            return true;</a>
<a name="ln713">        }</a>
<a name="ln714"> </a>
<a name="ln715">        /// Synonym for \p enqueue() function</a>
<a name="ln716">        bool push( value_type&amp; val )</a>
<a name="ln717">        {</a>
<a name="ln718">            return enqueue( val );</a>
<a name="ln719">        }</a>
<a name="ln720"> </a>
<a name="ln721">        /// Dequeues a value from the queue</a>
<a name="ln722">        /** @anchor cds_intrusive_BasketQueue_dequeue</a>
<a name="ln723">            If the queue is empty the function returns \p nullptr.</a>
<a name="ln724"> </a>
<a name="ln725">            @note See \p MSQueue::dequeue() note about item disposing</a>
<a name="ln726">        */</a>
<a name="ln727">        value_type * dequeue()</a>
<a name="ln728">        {</a>
<a name="ln729">            dequeue_result res;</a>
<a name="ln730"> </a>
<a name="ln731">            if ( do_dequeue( res, true ))</a>
<a name="ln732">                return node_traits::to_value_ptr( *res.pNext );</a>
<a name="ln733">            return nullptr;</a>
<a name="ln734">        }</a>
<a name="ln735"> </a>
<a name="ln736">        /// Synonym for \p dequeue() function</a>
<a name="ln737">        value_type * pop()</a>
<a name="ln738">        {</a>
<a name="ln739">            return dequeue();</a>
<a name="ln740">        }</a>
<a name="ln741"> </a>
<a name="ln742">        /// Checks if the queue is empty</a>
<a name="ln743">        /**</a>
<a name="ln744">            Note that this function is not \p const.</a>
<a name="ln745">            The function is based on \p dequeue() algorithm</a>
<a name="ln746">            but really it does not dequeue any item.</a>
<a name="ln747">        */</a>
<a name="ln748">        bool empty()</a>
<a name="ln749">        {</a>
<a name="ln750">            dequeue_result res;</a>
<a name="ln751">            return !do_dequeue( res, false );</a>
<a name="ln752">        }</a>
<a name="ln753"> </a>
<a name="ln754">        /// Clear the queue</a>
<a name="ln755">        /**</a>
<a name="ln756">            The function repeatedly calls \p dequeue() until it returns \p nullptr.</a>
<a name="ln757">            The disposer defined in template \p Traits is called for each item</a>
<a name="ln758">            that can be safely disposed.</a>
<a name="ln759">        */</a>
<a name="ln760">        void clear()</a>
<a name="ln761">        {</a>
<a name="ln762">            while ( dequeue());</a>
<a name="ln763">        }</a>
<a name="ln764"> </a>
<a name="ln765">        /// Returns queue's item count</a>
<a name="ln766">        /**</a>
<a name="ln767">            The value returned depends on \p Traits (see basket_queue::traits::item_counter). For \p atomicity::empty_item_counter,</a>
<a name="ln768">            this function always returns 0.</a>
<a name="ln769"> </a>
<a name="ln770">            @note Even if you use real item counter and it returns 0, this fact is not mean that the queue</a>
<a name="ln771">            is empty. To check queue emptyness use \p empty() method.</a>
<a name="ln772">        */</a>
<a name="ln773">        size_t size() const</a>
<a name="ln774">        {</a>
<a name="ln775">            return m_ItemCounter.value();</a>
<a name="ln776">        }</a>
<a name="ln777"> </a>
<a name="ln778">        /// Returns reference to internal statistics</a>
<a name="ln779">        const stat&amp; statistics() const</a>
<a name="ln780">        {</a>
<a name="ln781">            return m_Stat;</a>
<a name="ln782">        }</a>
<a name="ln783">    };</a>
<a name="ln784"> </a>
<a name="ln785">}} // namespace cds::intrusive</a>
<a name="ln786"> </a>
<a name="ln787">#endif // #ifndef CDSLIB_INTRUSIVE_BASKET_QUEUE_H</a>

</code></pre>
<div class="balloon" rel="539"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'bDeque' is always true.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
