
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>tablet_bootstrap.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Licensed to the Apache Software Foundation (ASF) under one</a>
<a name="ln2">// or more contributor license agreements.  See the NOTICE file</a>
<a name="ln3">// distributed with this work for additional information</a>
<a name="ln4">// regarding copyright ownership.  The ASF licenses this file</a>
<a name="ln5">// to you under the Apache License, Version 2.0 (the</a>
<a name="ln6">// &quot;License&quot;); you may not use this file except in compliance</a>
<a name="ln7">// with the License.  You may obtain a copy of the License at</a>
<a name="ln8">//</a>
<a name="ln9">//   http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln10">//</a>
<a name="ln11">// Unless required by applicable law or agreed to in writing,</a>
<a name="ln12">// software distributed under the License is distributed on an</a>
<a name="ln13">// &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</a>
<a name="ln14">// KIND, either express or implied.  See the License for the</a>
<a name="ln15">// specific language governing permissions and limitations</a>
<a name="ln16">// under the License.</a>
<a name="ln17">//</a>
<a name="ln18">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln19">//</a>
<a name="ln20">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln21">//</a>
<a name="ln22">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln23">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln24">//</a>
<a name="ln25">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln26">//</a>
<a name="ln27">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln28">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln29">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln30">// under the License.</a>
<a name="ln31">//</a>
<a name="ln32">#include &quot;yb/tablet/tablet_bootstrap.h&quot;</a>
<a name="ln33"> </a>
<a name="ln34">#include &quot;yb/consensus/consensus.h&quot;</a>
<a name="ln35">#include &quot;yb/consensus/consensus_util.h&quot;</a>
<a name="ln36">#include &quot;yb/consensus/log.h&quot;</a>
<a name="ln37">#include &quot;yb/consensus/log_anchor_registry.h&quot;</a>
<a name="ln38">#include &quot;yb/consensus/log_reader.h&quot;</a>
<a name="ln39">#include &quot;yb/consensus/log_util.h&quot;</a>
<a name="ln40">#include &quot;yb/consensus/retryable_requests.h&quot;</a>
<a name="ln41"> </a>
<a name="ln42">#include &quot;yb/server/hybrid_clock.h&quot;</a>
<a name="ln43">#include &quot;yb/tablet/snapshot_coordinator.h&quot;</a>
<a name="ln44">#include &quot;yb/tablet/tablet_fwd.h&quot;</a>
<a name="ln45">#include &quot;yb/tablet/tablet_snapshots.h&quot;</a>
<a name="ln46">#include &quot;yb/tablet/tablet.h&quot;</a>
<a name="ln47">#include &quot;yb/tablet/tablet_peer.h&quot;</a>
<a name="ln48">#include &quot;yb/tablet/tablet_splitter.h&quot;</a>
<a name="ln49">#include &quot;yb/tablet/operations/change_metadata_operation.h&quot;</a>
<a name="ln50">#include &quot;yb/tablet/operations/history_cutoff_operation.h&quot;</a>
<a name="ln51">#include &quot;yb/tablet/operations/snapshot_operation.h&quot;</a>
<a name="ln52">#include &quot;yb/tablet/operations/split_operation.h&quot;</a>
<a name="ln53">#include &quot;yb/tablet/operations/truncate_operation.h&quot;</a>
<a name="ln54">#include &quot;yb/tablet/operations/update_txn_operation.h&quot;</a>
<a name="ln55">#include &quot;yb/tablet/operations/write_operation.h&quot;</a>
<a name="ln56">#include &quot;yb/util/fault_injection.h&quot;</a>
<a name="ln57">#include &quot;yb/util/flag_tags.h&quot;</a>
<a name="ln58">#include &quot;yb/util/opid.h&quot;</a>
<a name="ln59">#include &quot;yb/util/logging.h&quot;</a>
<a name="ln60">#include &quot;yb/util/scope_exit.h&quot;</a>
<a name="ln61">#include &quot;yb/util/status.h&quot;</a>
<a name="ln62">#include &quot;yb/util/stopwatch.h&quot;</a>
<a name="ln63">#include &quot;yb/util/env_util.h&quot;</a>
<a name="ln64">#include &quot;yb/consensus/log_index.h&quot;</a>
<a name="ln65">#include &quot;yb/docdb/consensus_frontier.h&quot;</a>
<a name="ln66">#include &quot;yb/tserver/backup.pb.h&quot;</a>
<a name="ln67"> </a>
<a name="ln68">DEFINE_bool(skip_remove_old_recovery_dir, false,</a>
<a name="ln69">            &quot;Skip removing WAL recovery dir after startup. (useful for debugging)&quot;);</a>
<a name="ln70">TAG_FLAG(skip_remove_old_recovery_dir, hidden);</a>
<a name="ln71"> </a>
<a name="ln72">DEFINE_bool(skip_wal_rewrite, true,</a>
<a name="ln73">            &quot;Skip rewriting WAL files during bootstrap.&quot;);</a>
<a name="ln74">TAG_FLAG(skip_wal_rewrite, experimental);</a>
<a name="ln75">TAG_FLAG(skip_wal_rewrite, runtime);</a>
<a name="ln76"> </a>
<a name="ln77">DEFINE_test_flag(double, fault_crash_during_log_replay, 0.0,</a>
<a name="ln78">                 &quot;Fraction of the time when the tablet will crash immediately &quot;</a>
<a name="ln79">                 &quot;after processing a log entry during log replay.&quot;);</a>
<a name="ln80"> </a>
<a name="ln81">DECLARE_uint64(max_clock_sync_error_usec);</a>
<a name="ln82"> </a>
<a name="ln83">DEFINE_bool(force_recover_flushed_frontier, false,</a>
<a name="ln84">            &quot;Could be used to ignore the flushed frontier metadata from RocksDB manifest and &quot;</a>
<a name="ln85">            &quot;recover it from the log instead.&quot;);</a>
<a name="ln86">TAG_FLAG(force_recover_flushed_frontier, hidden);</a>
<a name="ln87">TAG_FLAG(force_recover_flushed_frontier, advanced);</a>
<a name="ln88"> </a>
<a name="ln89">DEFINE_bool(skip_flushed_entries, true,</a>
<a name="ln90">            &quot;Only replay WAL entries that are not flushed to RocksDB or within the retryable &quot;</a>
<a name="ln91">            &quot;request timeout.&quot;);</a>
<a name="ln92"> </a>
<a name="ln93">DECLARE_int32(retryable_request_timeout_secs);</a>
<a name="ln94"> </a>
<a name="ln95">DEFINE_uint64(transaction_status_tablet_log_segment_size_bytes, 4_MB,</a>
<a name="ln96">              &quot;The segment size for transaction status tablet log roll-overs, in bytes.&quot;);</a>
<a name="ln97"> </a>
<a name="ln98">namespace yb {</a>
<a name="ln99">namespace tablet {</a>
<a name="ln100"> </a>
<a name="ln101">struct ReplayState;</a>
<a name="ln102">class WriteOperationState;</a>
<a name="ln103"> </a>
<a name="ln104">using namespace std::literals; // NOLINT</a>
<a name="ln105">using namespace std::placeholders;</a>
<a name="ln106">using std::shared_ptr;</a>
<a name="ln107"> </a>
<a name="ln108">using log::Log;</a>
<a name="ln109">using log::LogEntryPB;</a>
<a name="ln110">using log::LogOptions;</a>
<a name="ln111">using log::LogReader;</a>
<a name="ln112">using log::ReadableLogSegment;</a>
<a name="ln113">using log::LogEntryMetadata;</a>
<a name="ln114">using log::LogIndex;</a>
<a name="ln115">using log::CreateNewSegment;</a>
<a name="ln116">using log::SegmentSequence;</a>
<a name="ln117">using consensus::ChangeConfigRecordPB;</a>
<a name="ln118">using consensus::RaftConfigPB;</a>
<a name="ln119">using consensus::ConsensusBootstrapInfo;</a>
<a name="ln120">using consensus::ConsensusMetadata;</a>
<a name="ln121">using consensus::MinimumOpId;</a>
<a name="ln122">using consensus::OpIdEquals;</a>
<a name="ln123">using consensus::OpIdToString;</a>
<a name="ln124">using consensus::ReplicateMsg;</a>
<a name="ln125">using strings::Substitute;</a>
<a name="ln126">using tserver::ChangeMetadataRequestPB;</a>
<a name="ln127">using tserver::TruncateRequestPB;</a>
<a name="ln128">using tserver::WriteRequestPB;</a>
<a name="ln129">using tserver::TabletSnapshotOpRequestPB;</a>
<a name="ln130"> </a>
<a name="ln131">static string DebugInfo(const string&amp; tablet_id,</a>
<a name="ln132">                        int segment_seqno,</a>
<a name="ln133">                        int entry_idx,</a>
<a name="ln134">                        const string&amp; segment_path,</a>
<a name="ln135">                        const LogEntryPB* entry) {</a>
<a name="ln136">  // Truncate the debug string to a reasonable length for logging.  Otherwise, glog will truncate</a>
<a name="ln137">  // for us and we may miss important information which came after this long string.</a>
<a name="ln138">  string debug_str = entry ? entry-&gt;ShortDebugString() : &quot;&lt;NULL&gt;&quot;s;</a>
<a name="ln139">  if (debug_str.size() &gt; 500) {</a>
<a name="ln140">    debug_str.resize(500);</a>
<a name="ln141">    debug_str.append(&quot;...&quot;);</a>
<a name="ln142">  }</a>
<a name="ln143">  return Substitute(&quot;Debug Info: Error playing entry $0 of segment $1 of tablet $2. &quot;</a>
<a name="ln144">                    &quot;Segment path: $3. Entry: $4&quot;, entry_idx, segment_seqno, tablet_id,</a>
<a name="ln145">                    segment_path, debug_str);</a>
<a name="ln146">}</a>
<a name="ln147"> </a>
<a name="ln148">// ================================================================================================</a>
<a name="ln149">// Class ReplayState.</a>
<a name="ln150">// ================================================================================================</a>
<a name="ln151"> </a>
<a name="ln152">struct Entry {</a>
<a name="ln153">  std::unique_ptr&lt;log::LogEntryPB&gt; entry;</a>
<a name="ln154">  RestartSafeCoarseTimePoint entry_time;</a>
<a name="ln155"> </a>
<a name="ln156">  std::string ToString() const {</a>
<a name="ln157">    return Format(&quot;{ entry: $0 entry_time: $1 }&quot;, entry, entry_time);</a>
<a name="ln158">  }</a>
<a name="ln159">};</a>
<a name="ln160"> </a>
<a name="ln161">typedef std::map&lt;int64_t, Entry&gt; OpIndexToEntryMap;</a>
<a name="ln162"> </a>
<a name="ln163">// State kept during replay.</a>
<a name="ln164">struct ReplayState {</a>
<a name="ln165">  ReplayState(</a>
<a name="ln166">      const OpIdPB&amp; regular_op_id,</a>
<a name="ln167">      const OpIdPB&amp; intents_op_id,</a>
<a name="ln168">      const std::string&amp; log_prefix_)</a>
<a name="ln169">      : regular_stored_op_id(regular_op_id),</a>
<a name="ln170">        intents_stored_op_id(intents_op_id),</a>
<a name="ln171">        log_prefix(log_prefix_) {</a>
<a name="ln172">  }</a>
<a name="ln173"> </a>
<a name="ln174">  // Return true if 'b' is allowed to immediately follow 'a' in the log.</a>
<a name="ln175">  static bool IsValidSequence(const OpIdPB&amp; a, const OpIdPB&amp; b);</a>
<a name="ln176"> </a>
<a name="ln177">  // Return a Corruption status if 'id' seems to be out-of-sequence in the log.</a>
<a name="ln178">  Status CheckSequentialReplicateId(const consensus::ReplicateMsg&amp; msg);</a>
<a name="ln179"> </a>
<a name="ln180">  void UpdateCommittedOpId(const OpIdPB&amp; id);</a>
<a name="ln181"> </a>
<a name="ln182">  // Updates split_op_id. Expects msg to be SPLIT_OP.</a>
<a name="ln183">  // tablet_id is ID of the tablet being bootstrapped.</a>
<a name="ln184">  // Return error if it catches inconsistency between split operations.</a>
<a name="ln185">  CHECKED_STATUS UpdateSplitOpId(const ReplicateMsg&amp; msg, const TabletId&amp; tablet_id);</a>
<a name="ln186"> </a>
<a name="ln187">  // half_limit is half the limit on the number of entries added</a>
<a name="ln188">  void AddEntriesToStrings(</a>
<a name="ln189">      const OpIndexToEntryMap&amp; entries, std::vector&lt;std::string&gt;* strings, int half_limit) const;</a>
<a name="ln190"> </a>
<a name="ln191">  // half_limit is half the limit on the number of entries to be dumped</a>
<a name="ln192">  void DumpReplayStateToStrings(std::vector&lt;std::string&gt;* strings, int half_limit) const;</a>
<a name="ln193"> </a>
<a name="ln194">  bool CanApply(log::LogEntryPB* entry);</a>
<a name="ln195"> </a>
<a name="ln196">  const std::string&amp; LogPrefix() const { return log_prefix; }</a>
<a name="ln197"> </a>
<a name="ln198">  void UpdateCommittedFromStored();</a>
<a name="ln199"> </a>
<a name="ln200">  // The last replicate message's ID.</a>
<a name="ln201">  OpIdPB prev_op_id = consensus::MinimumOpId();</a>
<a name="ln202"> </a>
<a name="ln203">  // The last operation known to be committed.  All other operations with lower IDs are also</a>
<a name="ln204">  // committed.</a>
<a name="ln205">  OpIdPB committed_op_id = consensus::MinimumOpId();</a>
<a name="ln206"> </a>
<a name="ln207">  // The id of the split operation designated for this tablet added to Raft log.</a>
<a name="ln208">  // See comments for ReplicateState::split_op_id_.</a>
<a name="ln209">  OpIdPB split_op_id;</a>
<a name="ln210"> </a>
<a name="ln211">  // All REPLICATE entries that have not been applied to RocksDB yet. We decide what entries are</a>
<a name="ln212">  // safe to apply and delete from this map based on the commit index included into each REPLICATE</a>
<a name="ln213">  // message.</a>
<a name="ln214">  //</a>
<a name="ln215">  // The key in this map is the Raft index.</a>
<a name="ln216">  OpIndexToEntryMap pending_replicates;</a>
<a name="ln217"> </a>
<a name="ln218">  // ----------------------------------------------------------------------------------------------</a>
<a name="ln219">  // State specific to RocksDB-backed tables</a>
<a name="ln220"> </a>
<a name="ln221">  const OpIdPB regular_stored_op_id;</a>
<a name="ln222">  const OpIdPB intents_stored_op_id;</a>
<a name="ln223"> </a>
<a name="ln224">  // Total number of log entries applied to RocksDB.</a>
<a name="ln225">  int64_t num_entries_applied_to_rocksdb = 0;</a>
<a name="ln226"> </a>
<a name="ln227">  // If we encounter the last entry flushed to a RocksDB SSTable (as identified by the max</a>
<a name="ln228">  // persistent sequence number), we remember the hybrid time of that entry in this field.</a>
<a name="ln229">  // We guarantee that we'll either see that entry or a latter entry we know is committed into Raft</a>
<a name="ln230">  // during log replay. This is crucial for properly setting safe time at bootstrap.</a>
<a name="ln231">  HybridTime max_committed_hybrid_time = HybridTime::kMin;</a>
<a name="ln232"> </a>
<a name="ln233">  const std::string log_prefix;</a>
<a name="ln234">};</a>
<a name="ln235"> </a>
<a name="ln236">void ReplayState::UpdateCommittedFromStored() {</a>
<a name="ln237">  if (consensus::OpIdBiggerThan(regular_stored_op_id, committed_op_id)) {</a>
<a name="ln238">    committed_op_id = regular_stored_op_id;</a>
<a name="ln239">  }</a>
<a name="ln240"> </a>
<a name="ln241">  if (consensus::OpIdBiggerThan(intents_stored_op_id, committed_op_id)) {</a>
<a name="ln242">    committed_op_id = intents_stored_op_id;</a>
<a name="ln243">  }</a>
<a name="ln244">}</a>
<a name="ln245"> </a>
<a name="ln246">// Return true if 'b' is allowed to immediately follow 'a' in the log.</a>
<a name="ln247">bool ReplayState::IsValidSequence(const OpIdPB&amp; a, const OpIdPB&amp; b) {</a>
<a name="ln248">  if (a.term() == 0 &amp;&amp; a.index() == 0) {</a>
<a name="ln249">    // Not initialized - can start with any opid.</a>
<a name="ln250">    return true;</a>
<a name="ln251">  }</a>
<a name="ln252"> </a>
<a name="ln253">  // Within the same term, we should never skip entries.</a>
<a name="ln254">  // We can, however go backwards (see KUDU-783 for an example)</a>
<a name="ln255">  if (b.term() == a.term() &amp;&amp;</a>
<a name="ln256">      b.index() &gt; a.index() + 1) {</a>
<a name="ln257">    return false;</a>
<a name="ln258">  }</a>
<a name="ln259"> </a>
<a name="ln260">  // TODO: check that the term does not decrease.</a>
<a name="ln261">  // https://github.com/yugabyte/yugabyte-db/issues/5115</a>
<a name="ln262"> </a>
<a name="ln263">  return true;</a>
<a name="ln264">}</a>
<a name="ln265"> </a>
<a name="ln266">// Return a Corruption status if 'id' seems to be out-of-sequence in the log.</a>
<a name="ln267">Status ReplayState::CheckSequentialReplicateId(const ReplicateMsg&amp; msg) {</a>
<a name="ln268">  SCHECK(msg.has_id(), Corruption, &quot;A REPLICATE message must have an id&quot;);</a>
<a name="ln269">  if (PREDICT_FALSE(!IsValidSequence(prev_op_id, msg.id()))) {</a>
<a name="ln270">    string op_desc = Substitute(&quot;$0 REPLICATE (Type: $1)&quot;,</a>
<a name="ln271">                                OpIdToString(msg.id()),</a>
<a name="ln272">                                OperationType_Name(msg.op_type()));</a>
<a name="ln273">    return STATUS_FORMAT(Corruption,</a>
<a name="ln274">                         &quot;Unexpected opid following opid $0. Operation: $1&quot;,</a>
<a name="ln275">                         OpIdToString(prev_op_id),</a>
<a name="ln276">                         op_desc);</a>
<a name="ln277">  }</a>
<a name="ln278"> </a>
<a name="ln279">  prev_op_id = msg.id();</a>
<a name="ln280">  return Status::OK();</a>
<a name="ln281">}</a>
<a name="ln282"> </a>
<a name="ln283">void ReplayState::UpdateCommittedOpId(const OpIdPB&amp; id) {</a>
<a name="ln284">  if (consensus::OpIdLessThan(committed_op_id, id)) {</a>
<a name="ln285">    VLOG_WITH_PREFIX(1) &lt;&lt; &quot;Updating committed op id to &quot; &lt;&lt; id;</a>
<a name="ln286">    committed_op_id = id;</a>
<a name="ln287">  }</a>
<a name="ln288">}</a>
<a name="ln289"> </a>
<a name="ln290">Status ReplayState::UpdateSplitOpId(const ReplicateMsg&amp; msg, const TabletId&amp; tablet_id) {</a>
<a name="ln291">  SCHECK_EQ(</a>
<a name="ln292">      msg.op_type(), consensus::SPLIT_OP, IllegalState,</a>
<a name="ln293">      Format(&quot;Unexpected operation $0 instead of SPLIT_OP&quot;, msg));</a>
<a name="ln294">  const auto tablet_id_to_split = msg.split_request().tablet_id();</a>
<a name="ln295"> </a>
<a name="ln296">  if (split_op_id.IsInitialized()) {</a>
<a name="ln297">    if (tablet_id_to_split == tablet_id) {</a>
<a name="ln298">      return STATUS_FORMAT(</a>
<a name="ln299">          IllegalState,</a>
<a name="ln300">          &quot;There should be at most one SPLIT_OP designated for tablet $0 but we got two: &quot;</a>
<a name="ln301">          &quot;$1, $2&quot;,</a>
<a name="ln302">          tablet_id, split_op_id, msg.id());</a>
<a name="ln303">    }</a>
<a name="ln304"> </a>
<a name="ln305">    return STATUS_FORMAT(</a>
<a name="ln306">        IllegalState,</a>
<a name="ln307">        &quot;Unexpected SPLIT_OP $0 designated for another tablet $1 after we've already &quot;</a>
<a name="ln308">        &quot;replayed SPLIT_OP $2 for this tablet $3&quot;,</a>
<a name="ln309">        msg.id(), tablet_id_to_split, split_op_id, tablet_id);</a>
<a name="ln310">  }</a>
<a name="ln311"> </a>
<a name="ln312">  if (tablet_id_to_split == tablet_id) {</a>
<a name="ln313">    // We might be asked to replay SPLIT_OP designated for a different (ancestor) tablet, will</a>
<a name="ln314">    // just ignore it in this case.</a>
<a name="ln315">    split_op_id = msg.id();</a>
<a name="ln316">  }</a>
<a name="ln317">  return Status::OK();</a>
<a name="ln318">}</a>
<a name="ln319"> </a>
<a name="ln320">void ReplayState::AddEntriesToStrings(const OpIndexToEntryMap&amp; entries,</a>
<a name="ln321">                                      std::vector&lt;std::string&gt;* strings,</a>
<a name="ln322">                                      int half_limit) const {</a>
<a name="ln323">  const auto n = entries.size();</a>
<a name="ln324">  const bool overflow = n &gt; 2 * half_limit;</a>
<a name="ln325">  size_t index = 0;</a>
<a name="ln326">  for (const auto&amp; entry : entries) {</a>
<a name="ln327">    if (!overflow || (index &lt; half_limit || index &gt;= n - half_limit)) {</a>
<a name="ln328">      const auto&amp; replicate = entry.second.entry.get()-&gt;replicate();</a>
<a name="ln329">      strings-&gt;push_back(Format(</a>
<a name="ln330">          &quot;    [$0] op_id: $1 hybrid_time: $2 op_type: $3 committed_op_id: $4&quot;,</a>
<a name="ln331">          index + 1,</a>
<a name="ln332">          OpId::FromPB(replicate.id()),</a>
<a name="ln333">          replicate.hybrid_time(),</a>
<a name="ln334">          replicate.op_type(),</a>
<a name="ln335">          OpId::FromPB(replicate.committed_op_id())));</a>
<a name="ln336">    }</a>
<a name="ln337">    if (overflow &amp;&amp; index == half_limit - 1) {</a>
<a name="ln338">      strings-&gt;push_back(Format(&quot;($0 lines skipped)&quot;, n - 2 * half_limit));</a>
<a name="ln339">    }</a>
<a name="ln340">    index++;</a>
<a name="ln341">  }</a>
<a name="ln342">}</a>
<a name="ln343"> </a>
<a name="ln344">void ReplayState::DumpReplayStateToStrings(</a>
<a name="ln345">    std::vector&lt;std::string&gt;* strings,</a>
<a name="ln346">    int half_limit) const {</a>
<a name="ln347">  strings-&gt;push_back(Substitute(</a>
<a name="ln348">      &quot;ReplayState: &quot;</a>
<a name="ln349">      &quot;Previous OpId: $0, &quot;</a>
<a name="ln350">      &quot;Committed OpId: $1, &quot;</a>
<a name="ln351">      &quot;Pending Replicates: $2, &quot;</a>
<a name="ln352">      &quot;Flushed Regular: $3, &quot;</a>
<a name="ln353">      &quot;Flushed Intents: $4&quot;,</a>
<a name="ln354">      OpIdToString(prev_op_id),</a>
<a name="ln355">      OpIdToString(committed_op_id),</a>
<a name="ln356">      pending_replicates.size(),</a>
<a name="ln357">      OpIdToString(regular_stored_op_id),</a>
<a name="ln358">      OpIdToString(intents_stored_op_id)));</a>
<a name="ln359">  if (num_entries_applied_to_rocksdb &gt; 0) {</a>
<a name="ln360">    strings-&gt;push_back(Substitute(&quot;Log entries applied to RocksDB: $0&quot;,</a>
<a name="ln361">                                  num_entries_applied_to_rocksdb));</a>
<a name="ln362">  }</a>
<a name="ln363">  if (!pending_replicates.empty()) {</a>
<a name="ln364">    strings-&gt;push_back(Substitute(&quot;Dumping REPLICATES ($0 items):&quot;, pending_replicates.size()));</a>
<a name="ln365">    AddEntriesToStrings(pending_replicates, strings, half_limit);</a>
<a name="ln366">  }</a>
<a name="ln367">}</a>
<a name="ln368"> </a>
<a name="ln369">bool ReplayState::CanApply(LogEntryPB* entry) {</a>
<a name="ln370">  return consensus::OpIdCompare(entry-&gt;replicate().id(), committed_op_id) &lt;= 0;</a>
<a name="ln371">}</a>
<a name="ln372"> </a>
<a name="ln373">// ================================================================================================</a>
<a name="ln374">// Class TabletBootstrap.</a>
<a name="ln375">// ================================================================================================</a>
<a name="ln376"> </a>
<a name="ln377">namespace {</a>
<a name="ln378"> </a>
<a name="ln379">struct ReplayDecision {</a>
<a name="ln380">  bool should_replay = false;</a>
<a name="ln381"> </a>
<a name="ln382">  // This is true for transaction update operations that have already been applied to the regular</a>
<a name="ln383">  // RocksDB but not to the intents RocksDB.</a>
<a name="ln384">  AlreadyAppliedToRegularDB already_applied_to_regular_db = AlreadyAppliedToRegularDB::kFalse;</a>
<a name="ln385">};</a>
<a name="ln386"> </a>
<a name="ln387">ReplayDecision ShouldReplayOperation(</a>
<a name="ln388">    consensus::OperationType op_type,</a>
<a name="ln389">    const int64_t index,</a>
<a name="ln390">    const int64_t regular_flushed_index,</a>
<a name="ln391">    const int64_t intents_flushed_index,</a>
<a name="ln392">    TransactionStatus txn_status,</a>
<a name="ln393">    bool write_op_has_transaction) {</a>
<a name="ln394">  // In most cases we assume that intents_flushed_index &lt;= regular_flushed_index but here we are</a>
<a name="ln395">  // trying to be resilient to violations of that assumption.</a>
<a name="ln396">  if (index &lt;= std::min(regular_flushed_index, intents_flushed_index)) {</a>
<a name="ln397">    // Never replay anyting that is flushed to both regular and intents RocksDBs in a transactional</a>
<a name="ln398">    // table.</a>
<a name="ln399">    return {false};</a>
<a name="ln400">  }</a>
<a name="ln401"> </a>
<a name="ln402">  if (op_type == consensus::UPDATE_TRANSACTION_OP) {</a>
<a name="ln403">    if (txn_status == TransactionStatus::APPLYING &amp;&amp;</a>
<a name="ln404">        intents_flushed_index &lt; index &amp;&amp; index &lt;= regular_flushed_index) {</a>
<a name="ln405">      // Intents were applied/flushed to regular RocksDB, but not flushed into the intents RocksDB.</a>
<a name="ln406">      return {true, AlreadyAppliedToRegularDB::kTrue};</a>
<a name="ln407">    }</a>
<a name="ln408">    // For other types of transaction updates, we ignore them if they have been flushed to the</a>
<a name="ln409">    // regular RocksDB.</a>
<a name="ln410">    return {index &gt; regular_flushed_index};</a>
<a name="ln411">  }</a>
<a name="ln412"> </a>
<a name="ln413">  if (op_type == consensus::WRITE_OP &amp;&amp; write_op_has_transaction) {</a>
<a name="ln414">    // Write intents that have not been flushed into the intents DB.</a>
<a name="ln415">    return {index &gt; intents_flushed_index};</a>
<a name="ln416">  }</a>
<a name="ln417"> </a>
<a name="ln418">  return {index &gt; regular_flushed_index};</a>
<a name="ln419">}</a>
<a name="ln420"> </a>
<a name="ln421">}  // anonymous namespace</a>
<a name="ln422"> </a>
<a name="ln423">YB_STRONGLY_TYPED_BOOL(NeedsRecovery);</a>
<a name="ln424"> </a>
<a name="ln425">// Bootstraps an existing tablet by opening the metadata from disk, and rebuilding soft state by</a>
<a name="ln426">// playing log segments. A bootstrapped tablet can then be added to an existing consensus</a>
<a name="ln427">// configuration as a LEARNER, which will bring its state up to date with the rest of the consensus</a>
<a name="ln428">// configuration, or it can start serving the data itself, after it has been appointed LEADER of</a>
<a name="ln429">// that particular consensus configuration.</a>
<a name="ln430">//</a>
<a name="ln431">// NOTE: this does not handle pulling data from other replicas in the cluster. That is handled by</a>
<a name="ln432">// the 'RemoteBootstrap' classes, which copy blocks and metadata locally before invoking this local</a>
<a name="ln433">// bootstrap functionality.</a>
<a name="ln434">//</a>
<a name="ln435">// This class is not thread-safe.</a>
<a name="ln436">class TabletBootstrap {</a>
<a name="ln437"> public:</a>
<a name="ln438">  explicit TabletBootstrap(const BootstrapTabletData&amp; data)</a>
<a name="ln439">      : data_(data),</a>
<a name="ln440">        meta_(data.tablet_init_data.metadata),</a>
<a name="ln441">        mem_tracker_(data.tablet_init_data.parent_mem_tracker),</a>
<a name="ln442">        listener_(data.listener),</a>
<a name="ln443">        append_pool_(data.append_pool),</a>
<a name="ln444">        allocation_pool_(data.allocation_pool),</a>
<a name="ln445">      skip_wal_rewrite_(FLAGS_skip_wal_rewrite) ,</a>
<a name="ln446">        test_hooks_(data.test_hooks) {</a>
<a name="ln447">  }</a>
<a name="ln448"> </a>
<a name="ln449">  ~TabletBootstrap() {}</a>
<a name="ln450"> </a>
<a name="ln451">  CHECKED_STATUS Bootstrap(</a>
<a name="ln452">      TabletPtr* rebuilt_tablet,</a>
<a name="ln453">      scoped_refptr&lt;log::Log&gt;* rebuilt_log,</a>
<a name="ln454">      consensus::ConsensusBootstrapInfo* consensus_info) {</a>
<a name="ln455">    const string tablet_id = meta_-&gt;raft_group_id();</a>
<a name="ln456"> </a>
<a name="ln457">    // Replay requires a valid Consensus metadata file to exist in order to compare the committed</a>
<a name="ln458">    // consensus configuration seqno with the log entries and also to persist committed but</a>
<a name="ln459">    // unpersisted changes.</a>
<a name="ln460">    RETURN_NOT_OK_PREPEND(ConsensusMetadata::Load(meta_-&gt;fs_manager(), tablet_id,</a>
<a name="ln461">                                                  meta_-&gt;fs_manager()-&gt;uuid(), &amp;cmeta_),</a>
<a name="ln462">                          &quot;Unable to load Consensus metadata&quot;);</a>
<a name="ln463"> </a>
<a name="ln464">    // Make sure we don't try to locally bootstrap a tablet that was in the middle of a remote</a>
<a name="ln465">    // bootstrap. It's likely that not all files were copied over successfully.</a>
<a name="ln466">    TabletDataState tablet_data_state = meta_-&gt;tablet_data_state();</a>
<a name="ln467">    if (!CanServeTabletData(tablet_data_state)) {</a>
<a name="ln468">      return STATUS(Corruption, &quot;Unable to locally bootstrap tablet &quot; + tablet_id + &quot;: &quot; +</a>
<a name="ln469">                                &quot;RaftGroupMetadata bootstrap state is &quot; +</a>
<a name="ln470">                                TabletDataState_Name(tablet_data_state));</a>
<a name="ln471">    }</a>
<a name="ln472"> </a>
<a name="ln473">    listener_-&gt;StatusMessage(&quot;Bootstrap starting.&quot;);</a>
<a name="ln474"> </a>
<a name="ln475">    if (VLOG_IS_ON(1)) {</a>
<a name="ln476">      RaftGroupReplicaSuperBlockPB super_block;</a>
<a name="ln477">      meta_-&gt;ToSuperBlock(&amp;super_block);</a>
<a name="ln478">      VLOG_WITH_PREFIX(1) &lt;&lt; &quot;Tablet Metadata: &quot; &lt;&lt; super_block.DebugString();</a>
<a name="ln479">    }</a>
<a name="ln480"> </a>
<a name="ln481">    const bool has_blocks = VERIFY_RESULT(OpenTablet());</a>
<a name="ln482"> </a>
<a name="ln483">    const auto needs_recovery = VERIFY_RESULT(PrepareToReplay());</a>
<a name="ln484">    if (needs_recovery &amp;&amp; !skip_wal_rewrite_) {</a>
<a name="ln485">      RETURN_NOT_OK(OpenLogReader());</a>
<a name="ln486">    }</a>
<a name="ln487"> </a>
<a name="ln488">    // This is a new tablet, nothing left to do.</a>
<a name="ln489">    if (!has_blocks &amp;&amp; !needs_recovery) {</a>
<a name="ln490">      LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;No blocks or log segments found. Creating new log.&quot;;</a>
<a name="ln491">      RETURN_NOT_OK_PREPEND(OpenNewLog(CreateNewSegment::kTrue), &quot;Failed to open new log&quot;);</a>
<a name="ln492">      RETURN_NOT_OK(FinishBootstrap(&quot;No bootstrap required, opened a new log&quot;,</a>
<a name="ln493">                                    rebuilt_log,</a>
<a name="ln494">                                    rebuilt_tablet));</a>
<a name="ln495">      consensus_info-&gt;last_id = MinimumOpId();</a>
<a name="ln496">      consensus_info-&gt;last_committed_id = MinimumOpId();</a>
<a name="ln497">      return Status::OK();</a>
<a name="ln498">    }</a>
<a name="ln499"> </a>
<a name="ln500">    // If there were blocks, there must be segments to replay. This is required by Raft, since we</a>
<a name="ln501">    // always need to know the term and index of the last logged op in order to vote, know how to</a>
<a name="ln502">    // respond to AppendEntries(), etc.</a>
<a name="ln503">    if (has_blocks &amp;&amp; !needs_recovery) {</a>
<a name="ln504">      return STATUS(IllegalState, Substitute(&quot;Tablet $0: Found rowsets but no log &quot;</a>
<a name="ln505">                                            &quot;segments could be found.&quot;,</a>
<a name="ln506">                                            tablet_id));</a>
<a name="ln507">    }</a>
<a name="ln508"> </a>
<a name="ln509">    RETURN_NOT_OK_PREPEND(PlaySegments(consensus_info), &quot;Failed log replay. Reason&quot;);</a>
<a name="ln510"> </a>
<a name="ln511">    if (cmeta_-&gt;current_term() &lt; consensus_info-&gt;last_id.term()) {</a>
<a name="ln512">      cmeta_-&gt;set_current_term(consensus_info-&gt;last_id.term());</a>
<a name="ln513">    }</a>
<a name="ln514"> </a>
<a name="ln515">    // Flush the consensus metadata once at the end to persist our changes, if any.</a>
<a name="ln516">    RETURN_NOT_OK(cmeta_-&gt;Flush());</a>
<a name="ln517"> </a>
<a name="ln518">    RETURN_NOT_OK(RemoveRecoveryDir());</a>
<a name="ln519"> </a>
<a name="ln520">    if (FLAGS_force_recover_flushed_frontier) {</a>
<a name="ln521">      RETURN_NOT_OK(tablet_-&gt;Flush(FlushMode::kSync));</a>
<a name="ln522">      docdb::ConsensusFrontier new_consensus_frontier;</a>
<a name="ln523">      new_consensus_frontier.set_op_id(consensus_info-&gt;last_committed_id);</a>
<a name="ln524">      new_consensus_frontier.set_hybrid_time(tablet_-&gt;mvcc_manager()-&gt;LastReplicatedHybridTime());</a>
<a name="ln525">      // We don't attempt to recover the history cutoff here because it will be recovered</a>
<a name="ln526">      // automatically on the first compaction, and this is a special mode for manual</a>
<a name="ln527">      // troubleshooting.</a>
<a name="ln528">      LOG_WITH_PREFIX(WARNING)</a>
<a name="ln529">          &lt;&lt; &quot;--force_recover_flushed_frontier specified, forcefully setting &quot;</a>
<a name="ln530">          &lt;&lt; &quot;flushed frontier after bootstrap: &quot; &lt;&lt; new_consensus_frontier.ToString();</a>
<a name="ln531">      RETURN_NOT_OK(tablet_-&gt;ModifyFlushedFrontier(</a>
<a name="ln532">          new_consensus_frontier, rocksdb::FrontierModificationMode::kForce));</a>
<a name="ln533">    }</a>
<a name="ln534"> </a>
<a name="ln535">    RETURN_NOT_OK(FinishBootstrap(&quot;Bootstrap complete.&quot;, rebuilt_log, rebuilt_tablet));</a>
<a name="ln536"> </a>
<a name="ln537">    return Status::OK();</a>
<a name="ln538">  }</a>
<a name="ln539"> </a>
<a name="ln540"> private:</a>
<a name="ln541">  // Finishes bootstrap, setting 'rebuilt_log' and 'rebuilt_tablet'.</a>
<a name="ln542">  CHECKED_STATUS FinishBootstrap(</a>
<a name="ln543">      const std::string&amp; message,</a>
<a name="ln544">      scoped_refptr&lt;log::Log&gt;* rebuilt_log,</a>
<a name="ln545">      TabletPtr* rebuilt_tablet) {</a>
<a name="ln546">    tablet_-&gt;MarkFinishedBootstrapping();</a>
<a name="ln547">    listener_-&gt;StatusMessage(message);</a>
<a name="ln548">    *rebuilt_tablet = std::move(tablet_);</a>
<a name="ln549">    RETURN_NOT_OK(log_-&gt;EnsureInitialNewSegmentAllocated());</a>
<a name="ln550">    rebuilt_log-&gt;swap(log_);</a>
<a name="ln551">    return Status::OK();</a>
<a name="ln552">  }</a>
<a name="ln553"> </a>
<a name="ln554">  // Sets result to true if there was any data on disk for this tablet.</a>
<a name="ln555">  Result&lt;bool&gt; OpenTablet() {</a>
<a name="ln556">    CleanupSnapshots();</a>
<a name="ln557"> </a>
<a name="ln558">    auto tablet = std::make_shared&lt;Tablet&gt;(data_.tablet_init_data);</a>
<a name="ln559">    // Doing nothing for now except opening a tablet locally.</a>
<a name="ln560">    LOG_TIMING_PREFIX(INFO, LogPrefix(), &quot;opening tablet&quot;) {</a>
<a name="ln561">      RETURN_NOT_OK(tablet-&gt;Open());</a>
<a name="ln562">    }</a>
<a name="ln563"> </a>
<a name="ln564">    // In theory, an error can happen in case of tablet Shutdown or in RocksDB object replacement</a>
<a name="ln565">    // operation like RestoreSnapshot or Truncate. However, those operations can't really be</a>
<a name="ln566">    // happening concurrently as we haven't opened the tablet yet.</a>
<a name="ln567">    const bool has_ss_tables = VERIFY_RESULT(tablet-&gt;HasSSTables());</a>
<a name="ln568"> </a>
<a name="ln569">    tablet_ = std::move(tablet);</a>
<a name="ln570">    return has_ss_tables;</a>
<a name="ln571">  }</a>
<a name="ln572"> </a>
<a name="ln573">  // Checks if a previous log recovery directory exists. If so, it deletes any files in the log dir</a>
<a name="ln574">  // and sets 'needs_recovery' to true, meaning that the previous recovery attempt should be retried</a>
<a name="ln575">  // from the recovery dir.</a>
<a name="ln576">  //</a>
<a name="ln577">  // Otherwise, if there is a log directory with log files in it, renames that log dir to the log</a>
<a name="ln578">  // recovery dir and creates a new, empty log dir so that log replay can proceed. 'needs_recovery'</a>
<a name="ln579">  // is also returned as true in this case.</a>
<a name="ln580">  //</a>
<a name="ln581">  // If no log segments are found, 'needs_recovery' is set to false.</a>
<a name="ln582">  Result&lt;NeedsRecovery&gt; PrepareToReplay() {</a>
<a name="ln583">    const string&amp; log_dir = tablet_-&gt;metadata()-&gt;wal_dir();</a>
<a name="ln584"> </a>
<a name="ln585">    // If the recovery directory exists, then we crashed mid-recovery.  Throw away any logs from the</a>
<a name="ln586">    // previous recovery attempt and restart the log replay process from the beginning using the</a>
<a name="ln587">    // same recovery dir as last time.</a>
<a name="ln588">    const string recovery_path = FsManager::GetTabletWalRecoveryDir(log_dir);</a>
<a name="ln589">    if (GetEnv()-&gt;FileExists(recovery_path)) {</a>
<a name="ln590">      LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Previous recovery directory found at &quot; &lt;&lt; recovery_path &lt;&lt; &quot;: &quot;</a>
<a name="ln591">                            &lt;&lt; &quot;Replaying log files from this location instead of &quot; &lt;&lt; log_dir;</a>
<a name="ln592"> </a>
<a name="ln593">      // Since we have a recovery directory, clear out the log_dir by recursively deleting it and</a>
<a name="ln594">      // creating a new one so that we don't end up with remnants of old WAL segments or indexes</a>
<a name="ln595">      // after replay.</a>
<a name="ln596">      if (GetEnv()-&gt;FileExists(log_dir)) {</a>
<a name="ln597">        LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Deleting old log files from previous recovery attempt in &quot;</a>
<a name="ln598">                              &lt;&lt; log_dir;</a>
<a name="ln599">        RETURN_NOT_OK_PREPEND(GetEnv()-&gt;DeleteRecursively(log_dir),</a>
<a name="ln600">                              &quot;Could not recursively delete old log dir &quot; + log_dir);</a>
<a name="ln601">      }</a>
<a name="ln602"> </a>
<a name="ln603">      RETURN_NOT_OK_PREPEND(env_util::CreateDirIfMissing(GetEnv(), DirName(log_dir)),</a>
<a name="ln604">                            &quot;Failed to create table log directory &quot; + DirName(log_dir));</a>
<a name="ln605"> </a>
<a name="ln606">      RETURN_NOT_OK_PREPEND(env_util::CreateDirIfMissing(GetEnv(), log_dir),</a>
<a name="ln607">                            &quot;Failed to create tablet log directory &quot; + log_dir);</a>
<a name="ln608"> </a>
<a name="ln609">      return NeedsRecovery::kTrue;</a>
<a name="ln610">    }</a>
<a name="ln611"> </a>
<a name="ln612">    // If we made it here, there was no pre-existing recovery dir.  Now we look for log files in</a>
<a name="ln613">    // log_dir, and if we find any then we rename the whole log_dir to a recovery dir and return</a>
<a name="ln614">    // needs_recovery = true.</a>
<a name="ln615">    RETURN_NOT_OK_PREPEND(env_util::CreateDirIfMissing(GetEnv(), DirName(log_dir)),</a>
<a name="ln616">                          &quot;Failed to create table log directory &quot; + DirName(log_dir));</a>
<a name="ln617"> </a>
<a name="ln618">    RETURN_NOT_OK_PREPEND(env_util::CreateDirIfMissing(GetEnv(), log_dir),</a>
<a name="ln619">                          &quot;Failed to create tablet log directory &quot; + log_dir);</a>
<a name="ln620"> </a>
<a name="ln621">    vector&lt;string&gt; log_dir_children = VERIFY_RESULT_PREPEND(</a>
<a name="ln622">        GetEnv()-&gt;GetChildren(log_dir, ExcludeDots::kTrue), &quot;Couldn't list log segments.&quot;);</a>
<a name="ln623"> </a>
<a name="ln624">    // To ensure consistent order of log messages. Note: this does not affect the replay order</a>
<a name="ln625">    // of segments, only the order of INFO log messages below.</a>
<a name="ln626">    sort(log_dir_children.begin(), log_dir_children.end());</a>
<a name="ln627"> </a>
<a name="ln628">    bool needs_recovery = false;</a>
<a name="ln629">    for (const string&amp; log_dir_child : log_dir_children) {</a>
<a name="ln630">      if (!log::IsLogFileName(log_dir_child)) {</a>
<a name="ln631">        continue;</a>
<a name="ln632">      }</a>
<a name="ln633"> </a>
<a name="ln634">      needs_recovery = true;</a>
<a name="ln635">      string source_path = JoinPathSegments(log_dir, log_dir_child);</a>
<a name="ln636">      if (skip_wal_rewrite_) {</a>
<a name="ln637">        LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Will attempt to recover log segment &quot; &lt;&lt; source_path;</a>
<a name="ln638">        continue;</a>
<a name="ln639">      }</a>
<a name="ln640"> </a>
<a name="ln641">      string dest_path = JoinPathSegments(recovery_path, log_dir_child);</a>
<a name="ln642">      LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Will attempt to recover log segment &quot; &lt;&lt; source_path</a>
<a name="ln643">                            &lt;&lt; &quot; to &quot; &lt;&lt; dest_path;</a>
<a name="ln644">    }</a>
<a name="ln645"> </a>
<a name="ln646">    if (!skip_wal_rewrite_ &amp;&amp; needs_recovery) {</a>
<a name="ln647">      // Atomically rename the log directory to the recovery directory and then re-create the log</a>
<a name="ln648">      // directory.</a>
<a name="ln649">      LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Moving log directory &quot; &lt;&lt; log_dir &lt;&lt; &quot; to recovery directory &quot;</a>
<a name="ln650">                            &lt;&lt; recovery_path &lt;&lt; &quot; in preparation for log replay&quot;;</a>
<a name="ln651">      RETURN_NOT_OK_PREPEND(GetEnv()-&gt;RenameFile(log_dir, recovery_path),</a>
<a name="ln652">                            Substitute(&quot;Could not move log directory $0 to recovery dir $1&quot;,</a>
<a name="ln653">                                      log_dir, recovery_path));</a>
<a name="ln654">      RETURN_NOT_OK_PREPEND(GetEnv()-&gt;CreateDir(log_dir),</a>
<a name="ln655">                            &quot;Failed to recreate log directory &quot; + log_dir);</a>
<a name="ln656">    }</a>
<a name="ln657">    return NeedsRecovery(needs_recovery);</a>
<a name="ln658">  }</a>
<a name="ln659"> </a>
<a name="ln660">  // Opens the latest log segments for the Tablet that will allow to rebuild the tablet's soft</a>
<a name="ln661">  // state. If there are existing log segments in the tablet's log directly they are moved to a</a>
<a name="ln662">  // &quot;log-recovery&quot; directory which is deleted when the replay process is completed (as they have</a>
<a name="ln663">  // been duplicated in the current log directory).</a>
<a name="ln664">  //</a>
<a name="ln665">  // If a &quot;log-recovery&quot; directory is already present, we will continue to replay from the</a>
<a name="ln666">  // &quot;log-recovery&quot; directory. Tablet metadata is updated once replay has finished from the</a>
<a name="ln667">  // &quot;log-recovery&quot; directory.</a>
<a name="ln668">  Status OpenLogReader() {</a>
<a name="ln669">    auto wal_dir = tablet_-&gt;metadata()-&gt;wal_dir();</a>
<a name="ln670">    auto wal_path = skip_wal_rewrite_ ? wal_dir :</a>
<a name="ln671">        meta_-&gt;fs_manager()-&gt;GetTabletWalRecoveryDir(wal_dir);</a>
<a name="ln672">    VLOG_WITH_PREFIX(1) &lt;&lt; &quot;Opening log reader in log recovery dir &quot; &lt;&lt; wal_path;</a>
<a name="ln673">    // Open the reader.</a>
<a name="ln674">    scoped_refptr&lt;LogIndex&gt; index(nullptr);</a>
<a name="ln675">    RETURN_NOT_OK_PREPEND(LogReader::Open(GetEnv(),</a>
<a name="ln676">                                          index,</a>
<a name="ln677">                                          tablet_-&gt;metadata()-&gt;raft_group_id(),</a>
<a name="ln678">                                          wal_path,</a>
<a name="ln679">                                          tablet_-&gt;metadata()-&gt;fs_manager()-&gt;uuid(),</a>
<a name="ln680">                                          tablet_-&gt;GetMetricEntity().get(),</a>
<a name="ln681">                                          &amp;log_reader_), &quot;Could not open LogReader. Reason&quot;);</a>
<a name="ln682">    return Status::OK();</a>
<a name="ln683">  }</a>
<a name="ln684"> </a>
<a name="ln685">  // Removes the recovery directory and all files contained therein.  Intended to be invoked after</a>
<a name="ln686">  // log replay successfully completes.</a>
<a name="ln687">  CHECKED_STATUS RemoveRecoveryDir() {</a>
<a name="ln688">    const string recovery_path = FsManager::GetTabletWalRecoveryDir(tablet_-&gt;metadata()-&gt;wal_dir());</a>
<a name="ln689">    if (!GetEnv()-&gt;FileExists(recovery_path)) {</a>
<a name="ln690">      VLOG(1) &lt;&lt; &quot;Tablet WAL recovery dir &quot; &lt;&lt; recovery_path &lt;&lt; &quot; does not exist.&quot;;</a>
<a name="ln691">      if (!skip_wal_rewrite_) {</a>
<a name="ln692">        return STATUS(IllegalState, &quot;Expected recovery dir, none found.&quot;);</a>
<a name="ln693">      }</a>
<a name="ln694">      return Status::OK();</a>
<a name="ln695">    }</a>
<a name="ln696"> </a>
<a name="ln697">    LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Preparing to delete log recovery files and directory &quot;</a>
<a name="ln698">                          &lt;&lt; recovery_path;</a>
<a name="ln699"> </a>
<a name="ln700">    string tmp_path = Substitute(&quot;$0-$1&quot;, recovery_path, GetCurrentTimeMicros());</a>
<a name="ln701">    LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Renaming log recovery dir from &quot;  &lt;&lt; recovery_path</a>
<a name="ln702">                          &lt;&lt; &quot; to &quot; &lt;&lt; tmp_path;</a>
<a name="ln703">    RETURN_NOT_OK_PREPEND(GetEnv()-&gt;RenameFile(recovery_path, tmp_path),</a>
<a name="ln704">                          Substitute(&quot;Could not rename old recovery dir from: $0 to: $1&quot;,</a>
<a name="ln705">                                    recovery_path, tmp_path));</a>
<a name="ln706"> </a>
<a name="ln707">    if (FLAGS_skip_remove_old_recovery_dir) {</a>
<a name="ln708">      LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;--skip_remove_old_recovery_dir enabled. NOT deleting &quot; &lt;&lt; tmp_path;</a>
<a name="ln709">      return Status::OK();</a>
<a name="ln710">    }</a>
<a name="ln711">    LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Deleting all files from renamed log recovery directory &quot; &lt;&lt; tmp_path;</a>
<a name="ln712">    RETURN_NOT_OK_PREPEND(GetEnv()-&gt;DeleteRecursively(tmp_path),</a>
<a name="ln713">                          &quot;Could not remove renamed recovery dir &quot; + tmp_path);</a>
<a name="ln714">    LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Completed deletion of old log recovery files and directory &quot;</a>
<a name="ln715">                          &lt;&lt; tmp_path;</a>
<a name="ln716">    return Status::OK();</a>
<a name="ln717">  }</a>
<a name="ln718"> </a>
<a name="ln719">  // Opens a new log in the tablet's log directory.  The directory is expected to be clean.</a>
<a name="ln720">  CHECKED_STATUS OpenNewLog(log::CreateNewSegment create_new_segment) {</a>
<a name="ln721">    auto log_options = LogOptions();</a>
<a name="ln722">    const auto&amp; metadata = *tablet_-&gt;metadata();</a>
<a name="ln723">    log_options.retention_secs = metadata.wal_retention_secs();</a>
<a name="ln724">    log_options.env = GetEnv();</a>
<a name="ln725">    if (tablet_-&gt;metadata()-&gt;table_type() == TableType::TRANSACTION_STATUS_TABLE_TYPE) {</a>
<a name="ln726">      auto log_segment_size = FLAGS_transaction_status_tablet_log_segment_size_bytes;</a>
<a name="ln727">      if (log_segment_size) {</a>
<a name="ln728">        log_options.segment_size_bytes = log_segment_size;</a>
<a name="ln729">      }</a>
<a name="ln730">    }</a>
<a name="ln731">    RETURN_NOT_OK(Log::Open(log_options,</a>
<a name="ln732">                            tablet_-&gt;tablet_id(),</a>
<a name="ln733">                            metadata.wal_dir(),</a>
<a name="ln734">                            metadata.fs_manager()-&gt;uuid(),</a>
<a name="ln735">                            *tablet_-&gt;schema(),</a>
<a name="ln736">                            metadata.schema_version(),</a>
<a name="ln737">                            tablet_-&gt;GetMetricEntity(),</a>
<a name="ln738">                            append_pool_,</a>
<a name="ln739">                            allocation_pool_,</a>
<a name="ln740">                            metadata.cdc_min_replicated_index(),</a>
<a name="ln741">                            &amp;log_,</a>
<a name="ln742">                            create_new_segment));</a>
<a name="ln743">    // Disable sync temporarily in order to speed up appends during the bootstrap process.</a>
<a name="ln744">    log_-&gt;DisableSync();</a>
<a name="ln745">    return Status::OK();</a>
<a name="ln746">  }</a>
<a name="ln747"> </a>
<a name="ln748">  // Handle the given log entry. Validates entry.type() (it can only be REPLICATE), optionally</a>
<a name="ln749">  // injects latency in tests, and delegates to HandleReplicateMessage.</a>
<a name="ln750">  CHECKED_STATUS HandleEntry(</a>
<a name="ln751">      yb::log::LogEntryMetadata entry_metadata, std::unique_ptr&lt;log::LogEntryPB&gt;* entry_ptr) {</a>
<a name="ln752">    auto&amp; entry = **entry_ptr;</a>
<a name="ln753">    VLOG_WITH_PREFIX(2) &lt;&lt; &quot;Handling entry: &quot; &lt;&lt; entry.ShortDebugString();</a>
<a name="ln754"> </a>
<a name="ln755">    switch (entry.type()) {</a>
<a name="ln756">      case log::REPLICATE:</a>
<a name="ln757">        RETURN_NOT_OK(HandleReplicateMessage(entry_metadata, entry_ptr));</a>
<a name="ln758">        break;</a>
<a name="ln759">      default:</a>
<a name="ln760">        return STATUS(Corruption, Substitute(&quot;Unexpected log entry type: $0&quot;, entry.type()));</a>
<a name="ln761">    }</a>
<a name="ln762">    MAYBE_FAULT(FLAGS_TEST_fault_crash_during_log_replay);</a>
<a name="ln763">    return Status::OK();</a>
<a name="ln764">  }</a>
<a name="ln765"> </a>
<a name="ln766">  // HandleReplicateMessage implements these important pieces of logic:</a>
<a name="ln767">  //   - Removes the &quot;tail&quot; of pending_replicates overwritten by a new leader's operations when</a>
<a name="ln768">  //     encountering an entry with an index lower than or equal to the index of an operation that</a>
<a name="ln769">  //     is already present in pending_replicates.</a>
<a name="ln770">  //   - Ignores entries that have already been flushed into regular and intents RocksDBs.</a>
<a name="ln771">  //   - Updates committed OpId based on the commmited OpId from the entry and calls</a>
<a name="ln772">  //     ApplyCommittedPendingReplicates.</a>
<a name="ln773">  //   - Updates the &quot;monotonic counter&quot; used for assigning internal keys in YCQL arrays.</a>
<a name="ln774">  CHECKED_STATUS HandleReplicateMessage(</a>
<a name="ln775">      LogEntryMetadata entry_metadata, std::unique_ptr&lt;log::LogEntryPB&gt;* replicate_entry_ptr) {</a>
<a name="ln776">    auto&amp; replicate_entry = **replicate_entry_ptr;</a>
<a name="ln777">    stats_.ops_read++;</a>
<a name="ln778"> </a>
<a name="ln779">    const ReplicateMsg&amp; replicate = replicate_entry.replicate();</a>
<a name="ln780">    VLOG_WITH_PREFIX(1) &lt;&lt; &quot;HandleReplicateMessage: &quot; &lt;&lt; entry_metadata.ToString()</a>
<a name="ln781">                        &lt;&lt; &quot;, op id: &quot; &lt;&lt; replicate.id()</a>
<a name="ln782">                        &lt;&lt; &quot;, committed op id: &quot; &lt;&lt; replicate.committed_op_id();</a>
<a name="ln783">    RETURN_NOT_OK(replay_state_-&gt;CheckSequentialReplicateId(replicate));</a>
<a name="ln784">    SCHECK(replicate.has_hybrid_time(), Corruption, &quot;A REPLICATE message must have a hybrid time&quot;);</a>
<a name="ln785">    UpdateClock(replicate.hybrid_time());</a>
<a name="ln786"> </a>
<a name="ln787">    // This sets the monotonic counter to at least replicate.monotonic_counter() atomically.</a>
<a name="ln788">    tablet_-&gt;UpdateMonotonicCounter(replicate.monotonic_counter());</a>
<a name="ln789"> </a>
<a name="ln790">    const OpIdPB&amp; op_id = replicate_entry.replicate().id();</a>
<a name="ln791"> </a>
<a name="ln792">    // Append the replicate message to the log as is if we are not skipping wal rewrite. If we are</a>
<a name="ln793">    // skipping, set consensus_state_only to true.</a>
<a name="ln794">    RETURN_NOT_OK(log_-&gt;Append(replicate_entry_ptr-&gt;get(), entry_metadata, skip_wal_rewrite_));</a>
<a name="ln795"> </a>
<a name="ln796">    auto iter = replay_state_-&gt;pending_replicates.lower_bound(op_id.index());</a>
<a name="ln797"> </a>
<a name="ln798">    // If there was an entry with the same or higher index as the entry we're adding, then we need</a>
<a name="ln799">    // to delete that entry and all entries with higher indexes.</a>
<a name="ln800">    if (iter != replay_state_-&gt;pending_replicates.end()) {</a>
<a name="ln801">      auto&amp; existing_entry = iter-&gt;second;</a>
<a name="ln802">      auto&amp; last_entry = replay_state_-&gt;pending_replicates.rbegin()-&gt;second;</a>
<a name="ln803"> </a>
<a name="ln804">      LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Overwriting operations starting at: &quot;</a>
<a name="ln805">                            &lt;&lt; existing_entry.entry-&gt;replicate().id()</a>
<a name="ln806">                            &lt;&lt; &quot; up to: &quot; &lt;&lt; last_entry.entry-&gt;replicate().id()</a>
<a name="ln807">                            &lt;&lt; &quot; with operation: &quot; &lt;&lt; replicate.id();</a>
<a name="ln808">      stats_.ops_overwritten += std::distance(iter, replay_state_-&gt;pending_replicates.end());</a>
<a name="ln809">      if (test_hooks_) {</a>
<a name="ln810">        // Tell the test framework about overwritten OpIds.</a>
<a name="ln811">        for (auto callback_iter = iter;</a>
<a name="ln812">             callback_iter != replay_state_-&gt;pending_replicates.end();</a>
<a name="ln813">             callback_iter++) {</a>
<a name="ln814">          test_hooks_-&gt;Overwritten(</a>
<a name="ln815">              yb::OpId::FromPB(callback_iter-&gt;second.entry-&gt;replicate().id()));</a>
<a name="ln816">        }</a>
<a name="ln817">      }</a>
<a name="ln818">      replay_state_-&gt;pending_replicates.erase(iter, replay_state_-&gt;pending_replicates.end());</a>
<a name="ln819">    }</a>
<a name="ln820"> </a>
<a name="ln821">    // We expect entry_metadata.entry_time to always be set for newly written WAL entries. However,</a>
<a name="ln822">    // for some very old WALs, it might be missing.</a>
<a name="ln823">    LOG_IF_WITH_PREFIX(DFATAL, entry_metadata.entry_time == RestartSafeCoarseTimePoint())</a>
<a name="ln824">        &lt;&lt; &quot;Entry metadata must have a restart-safe time. OpId: &quot; &lt;&lt; OpId::FromPB(replicate.id());</a>
<a name="ln825"> </a>
<a name="ln826">    CHECK(replay_state_-&gt;pending_replicates.emplace(</a>
<a name="ln827">        op_id.index(), Entry{std::move(*replicate_entry_ptr), entry_metadata.entry_time}).second);</a>
<a name="ln828"> </a>
<a name="ln829">    CHECK(replicate.has_committed_op_id())</a>
<a name="ln830">        &lt;&lt; &quot;Replicate message has no committed_op_id for table type &quot;</a>
<a name="ln831">        &lt;&lt; TableType_Name(tablet_-&gt;table_type()) &lt;&lt; &quot;. Replicate message:\n&quot;</a>
<a name="ln832">        &lt;&lt; replicate.DebugString();</a>
<a name="ln833"> </a>
<a name="ln834">    // We include the commit index as of the time a REPLICATE entry was added to the leader's log</a>
<a name="ln835">    // into that entry. This allows us to decide when we can replay a REPLICATE entry during</a>
<a name="ln836">    // bootstrap.</a>
<a name="ln837">    replay_state_-&gt;UpdateCommittedOpId(replicate.committed_op_id());</a>
<a name="ln838"> </a>
<a name="ln839">    return ApplyCommittedPendingReplicates();</a>
<a name="ln840">  }</a>
<a name="ln841"> </a>
<a name="ln842">  // Replays the given committed operation.</a>
<a name="ln843">  CHECKED_STATUS PlayAnyRequest(</a>
<a name="ln844">      ReplicateMsg* replicate, AlreadyAppliedToRegularDB already_applied_to_regular_db) {</a>
<a name="ln845">    const auto op_type = replicate-&gt;op_type();</a>
<a name="ln846">    if (test_hooks_) {</a>
<a name="ln847">      test_hooks_-&gt;Replayed(yb::OpId::FromPB(replicate-&gt;id()), already_applied_to_regular_db);</a>
<a name="ln848">    }</a>
<a name="ln849">    switch (op_type) {</a>
<a name="ln850">      case consensus::WRITE_OP:</a>
<a name="ln851">        return PlayWriteRequest(replicate);</a>
<a name="ln852"> </a>
<a name="ln853">      case consensus::CHANGE_METADATA_OP:</a>
<a name="ln854">        return PlayChangeMetadataRequest(replicate);</a>
<a name="ln855"> </a>
<a name="ln856">      case consensus::CHANGE_CONFIG_OP:</a>
<a name="ln857">        return PlayChangeConfigRequest(replicate);</a>
<a name="ln858"> </a>
<a name="ln859">      case consensus::TRUNCATE_OP:</a>
<a name="ln860">        return PlayTruncateRequest(replicate);</a>
<a name="ln861"> </a>
<a name="ln862">      case consensus::NO_OP:</a>
<a name="ln863">        return Status::OK();  // This is why it is a no-op!</a>
<a name="ln864"> </a>
<a name="ln865">      case consensus::UPDATE_TRANSACTION_OP:</a>
<a name="ln866">        return PlayUpdateTransactionRequest(replicate, already_applied_to_regular_db);</a>
<a name="ln867"> </a>
<a name="ln868">      case consensus::SNAPSHOT_OP:</a>
<a name="ln869">        return PlayTabletSnapshotRequest(replicate);</a>
<a name="ln870"> </a>
<a name="ln871">      case consensus::HISTORY_CUTOFF_OP:</a>
<a name="ln872">        return PlayHistoryCutoffRequest(replicate);</a>
<a name="ln873"> </a>
<a name="ln874">      case consensus::SPLIT_OP:</a>
<a name="ln875">        return PlaySplitOpRequest(replicate);</a>
<a name="ln876"> </a>
<a name="ln877">      // Unexpected cases:</a>
<a name="ln878">      case consensus::UNKNOWN_OP:</a>
<a name="ln879">        return STATUS(IllegalState, Substitute(&quot;Unsupported operation type: $0&quot;, op_type));</a>
<a name="ln880">    }</a>
<a name="ln881"> </a>
<a name="ln882">    LOG_WITH_PREFIX(DFATAL) &lt;&lt; &quot;Invalid operation type &quot; &lt;&lt; op_type</a>
<a name="ln883">                            &lt;&lt; &quot;for a REPLICATE operation: &quot; &lt;&lt; replicate-&gt;ShortDebugString();</a>
<a name="ln884">    return STATUS_FORMAT(Corruption, &quot;Invalid operation type: $0&quot;, op_type);</a>
<a name="ln885">  }</a>
<a name="ln886"> </a>
<a name="ln887">  CHECKED_STATUS PlayTabletSnapshotRequest(ReplicateMsg* replicate_msg) {</a>
<a name="ln888">    TabletSnapshotOpRequestPB* const snapshot = replicate_msg-&gt;mutable_snapshot_request();</a>
<a name="ln889"> </a>
<a name="ln890">    SnapshotOperationState tx_state(tablet_.get(), snapshot);</a>
<a name="ln891">    tx_state.set_hybrid_time(HybridTime(replicate_msg-&gt;hybrid_time()));</a>
<a name="ln892"> </a>
<a name="ln893">    return tx_state.Apply(/* leader_term= */ yb::OpId::kUnknownTerm);</a>
<a name="ln894">  }</a>
<a name="ln895"> </a>
<a name="ln896">  CHECKED_STATUS PlayHistoryCutoffRequest(ReplicateMsg* replicate_msg) {</a>
<a name="ln897">    HistoryCutoffOperationState state(</a>
<a name="ln898">        tablet_.get(), replicate_msg-&gt;mutable_history_cutoff());</a>
<a name="ln899"> </a>
<a name="ln900">    return state.Replicated(/* leader_term= */ yb::OpId::kUnknownTerm);</a>
<a name="ln901">  }</a>
<a name="ln902"> </a>
<a name="ln903">  CHECKED_STATUS PlaySplitOpRequest(ReplicateMsg* replicate_msg) {</a>
<a name="ln904">    tserver::SplitTabletRequestPB* const split_request = replicate_msg-&gt;mutable_split_request();</a>
<a name="ln905">    RETURN_NOT_OK(replay_state_-&gt;UpdateSplitOpId(*replicate_msg, tablet_-&gt;tablet_id()));</a>
<a name="ln906">    // We might be asked to replay SPLIT_OP even if it was applied and flushed when</a>
<a name="ln907">    // FLAGS_force_recover_flushed_frontier is set.</a>
<a name="ln908">    if (split_request-&gt;tablet_id() != tablet_-&gt;tablet_id()) {</a>
<a name="ln909">      // Ignore SPLIT_OP designated for ancestor tablet(s).</a>
<a name="ln910">      return Status::OK();</a>
<a name="ln911">    }</a>
<a name="ln912"> </a>
<a name="ln913">    if (tablet_-&gt;metadata()-&gt;tablet_data_state() == TabletDataState::TABLET_DATA_SPLIT_COMPLETED) {</a>
<a name="ln914">      // Ignore SPLIT_OP if tablet has been already split.</a>
<a name="ln915">      return Status::OK();</a>
<a name="ln916">    }</a>
<a name="ln917"> </a>
<a name="ln918">    SplitOperationState state(</a>
<a name="ln919">        tablet_.get(), nullptr /* consensus_for_abort */, data_.tablet_init_data.tablet_splitter,</a>
<a name="ln920">        split_request);</a>
<a name="ln921">    return data_.tablet_init_data.tablet_splitter-&gt;ApplyTabletSplit(&amp;state);</a>
<a name="ln922"> </a>
<a name="ln923">    // TODO(tsplit): In scope of https://github.com/yugabyte/yugabyte-db/issues/1461 add integration</a>
<a name="ln924">    // tests for:</a>
<a name="ln925">    // - tablet bootstrap of original tablet which hasn't been yet split and replaying split</a>
<a name="ln926">    // operation.</a>
<a name="ln927">    // - tablet bootstrap of original tablet which has been already successfully split and replaying</a>
<a name="ln928">    // split operation.</a>
<a name="ln929">    // - tablet bootstrap of new after-split tablet replaying split operation.</a>
<a name="ln930">  }</a>
<a name="ln931"> </a>
<a name="ln932">  void HandleRetryableRequest(</a>
<a name="ln933">      const ReplicateMsg&amp; replicate, RestartSafeCoarseTimePoint entry_time) {</a>
<a name="ln934">    if (!replicate.has_write_request())</a>
<a name="ln935">      return;</a>
<a name="ln936"> </a>
<a name="ln937">    if (data_.retryable_requests) {</a>
<a name="ln938">      data_.retryable_requests-&gt;Bootstrap(replicate, entry_time);</a>
<a name="ln939">    }</a>
<a name="ln940"> </a>
<a name="ln941">    // In a test, we might not have data_.retryable_requests, but we still want to tell the test</a>
<a name="ln942">    // that we would submit this OpId to retryable_requests.</a>
<a name="ln943">    if (test_hooks_) {</a>
<a name="ln944">      test_hooks_-&gt;RetryableRequest(OpId::FromPB(replicate.id()));</a>
<a name="ln945">    }</a>
<a name="ln946">  }</a>
<a name="ln947"> </a>
<a name="ln948">  // Performs various checks based on the OpId, and decides whether to replay the given operation.</a>
<a name="ln949">  // If so, calls PlayAnyRequest, or sometimes calls PlayUpdateTransactionRequest directly.</a>
<a name="ln950">  CHECKED_STATUS MaybeReplayCommittedEntry(</a>
<a name="ln951">      LogEntryPB* replicate_entry, RestartSafeCoarseTimePoint entry_time) {</a>
<a name="ln952">    ReplicateMsg* const replicate = replicate_entry-&gt;mutable_replicate();</a>
<a name="ln953">    const auto op_type = replicate-&gt;op_type();</a>
<a name="ln954">    const auto decision = ShouldReplayOperation(</a>
<a name="ln955">        op_type,</a>
<a name="ln956">        replicate-&gt;id().index(),</a>
<a name="ln957">        replay_state_-&gt;regular_stored_op_id.index(),</a>
<a name="ln958">        replay_state_-&gt;intents_stored_op_id.index(),</a>
<a name="ln959">        // txn_status</a>
<a name="ln960">        replicate-&gt;has_transaction_state()</a>
<a name="ln961">            ? replicate-&gt;transaction_state().status()</a>
<a name="ln962">            : TransactionStatus::ABORTED,  // should not be used</a>
<a name="ln963">        // write_op_has_transaction</a>
<a name="ln964">        replicate-&gt;has_write_request() &amp;&amp;</a>
<a name="ln965">            replicate-&gt;write_request().has_write_batch() &amp;&amp;</a>
<a name="ln966">            replicate-&gt;write_request().write_batch().has_transaction());</a>
<a name="ln967"> </a>
<a name="ln968">    HandleRetryableRequest(*replicate, entry_time);</a>
<a name="ln969"> </a>
<a name="ln970">    if (decision.should_replay) {</a>
<a name="ln971">      const auto status = PlayAnyRequest(replicate, decision.already_applied_to_regular_db);</a>
<a name="ln972">      if (!status.ok()) {</a>
<a name="ln973">        return status.CloneAndAppend(Format(</a>
<a name="ln974">            &quot;Failed to play $0 request. ReplicateMsg: { $1 }&quot;,</a>
<a name="ln975">            OperationType_Name(op_type), *replicate));</a>
<a name="ln976">      }</a>
<a name="ln977">      replay_state_-&gt;max_committed_hybrid_time.MakeAtLeast(HybridTime(replicate-&gt;hybrid_time()));</a>
<a name="ln978">    }</a>
<a name="ln979"> </a>
<a name="ln980">    return Status::OK();</a>
<a name="ln981">  }</a>
<a name="ln982"> </a>
<a name="ln983">  void DumpReplayStateToLog() {</a>
<a name="ln984">    // Dump the replay state, this will log the pending replicates, which might be useful for</a>
<a name="ln985">    // debugging.</a>
<a name="ln986">    vector&lt;string&gt; state_dump;</a>
<a name="ln987">    constexpr int kMaxLinesToDump = 1000;</a>
<a name="ln988">    replay_state_-&gt;DumpReplayStateToStrings(&amp;state_dump, kMaxLinesToDump / 2);</a>
<a name="ln989">    for (const string&amp; line : state_dump) {</a>
<a name="ln990">      LOG_WITH_PREFIX(INFO) &lt;&lt; line;</a>
<a name="ln991">    }</a>
<a name="ln992">  }</a>
<a name="ln993"> </a>
<a name="ln994">  Result&lt;DocDbOpIds&gt; GetFlushedOpIds() {</a>
<a name="ln995">    const auto flushed_op_ids = VERIFY_RESULT(tablet_-&gt;MaxPersistentOpId());</a>
<a name="ln996"> </a>
<a name="ln997">    if (FLAGS_force_recover_flushed_frontier) {</a>
<a name="ln998">      // This is used very rarely to replay all log entries and recover RocksDB flushed OpId</a>
<a name="ln999">      // metadata.</a>
<a name="ln1000">      LOG_WITH_PREFIX(WARNING)</a>
<a name="ln1001">          &lt;&lt; &quot;--force_recover_flushed_frontier specified, ignoring existing flushed frontiers &quot;</a>
<a name="ln1002">          &lt;&lt; &quot;from RocksDB metadata (will replay all log records): &quot; &lt;&lt; flushed_op_ids.ToString();</a>
<a name="ln1003">      return DocDbOpIds();</a>
<a name="ln1004">    }</a>
<a name="ln1005"> </a>
<a name="ln1006">    if (test_hooks_) {</a>
<a name="ln1007">      const auto docdb_flushed_op_ids_override = test_hooks_-&gt;GetFlushedOpIdsOverride();</a>
<a name="ln1008">      if (docdb_flushed_op_ids_override.is_initialized()) {</a>
<a name="ln1009">        LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Using test values of flushed DocDB OpIds: &quot;</a>
<a name="ln1010">                              &lt;&lt; docdb_flushed_op_ids_override-&gt;ToString();</a>
<a name="ln1011">        return *docdb_flushed_op_ids_override;</a>
<a name="ln1012">      }</a>
<a name="ln1013">    }</a>
<a name="ln1014"> </a>
<a name="ln1015">    // Production codepath.</a>
<a name="ln1016">    LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Flushed DocDB OpIds: &quot; &lt;&lt; flushed_op_ids.ToString();</a>
<a name="ln1017">    return flushed_op_ids;</a>
<a name="ln1018">  }</a>
<a name="ln1019"> </a>
<a name="ln1020">  // Determines the first segment to replay based two criteria:</a>
<a name="ln1021">  // - The first OpId of the segment must be less than or equal to (in terms of OpId comparison</a>
<a name="ln1022">  //   where term is compared first and index second) the &quot;flushed OpId&quot;. This &quot;flushed OpId&quot; is</a>
<a name="ln1023">  //   determined as the minimum of intents and regular RocksDBs' flushed OpIds for transactional</a>
<a name="ln1024">  //   tables, and just the regular RocksDB's flushed OpId for non-transactional tables. Note that</a>
<a name="ln1025">  //   in practice the flushed OpId of the intents RocksDB should also be less than or equal to the</a>
<a name="ln1026">  //   flushed OpId of the regular RocksDB or this would be an invariant violation.</a>
<a name="ln1027">  //</a>
<a name="ln1028">  // - The &quot;restart safe time&quot; of the first operation in the segment that we choose to start the</a>
<a name="ln1029">  //   replay with must be such that we guarantee that at least FLAGS_retryable_request_timeout_secs</a>
<a name="ln1030">  //   seconds worth of latest log records are replayed. This is needed to allow deduplicating</a>
<a name="ln1031">  //   automatic retries from YCQL and YSQL query layer and avoid Jepsen-type consistency</a>
<a name="ln1032">  //   violations. We satisfy this constraint by taking the last segment's first operation's</a>
<a name="ln1033">  //   restart-safe time, subtracting FLAGS_retryable_request_timeout_secs seconds from it, and</a>
<a name="ln1034">  //   finding a segment that has that time or earlier as its first operation's restart-safe time.</a>
<a name="ln1035">  //   This also means we are never allowed to start replay with the last segment, as long as</a>
<a name="ln1036">  //   FLAGS_retryable_request_timeout_secs is greater than 0.</a>
<a name="ln1037">  //</a>
<a name="ln1038">  //   This &quot;restart safe time&quot; is similar to the regular Linux monotonic clock time, but is</a>
<a name="ln1039">  //   maintained across tablet server restarts. See RestartSafeCoarseMonoClock for details.</a>
<a name="ln1040">  //</a>
<a name="ln1041">  //   See https://github.com/yugabyte/yugabyte-db/commit/5cf01889a1b4589a82085e578b5f4746c6614a5d</a>
<a name="ln1042">  //   and the Git history of retryable_requests.cc for more context on this requirement.</a>
<a name="ln1043">  //</a>
<a name="ln1044">  // As long as the two conditions above are satisfied, it is advantageous to us to pick the latest</a>
<a name="ln1045">  // possible segment to start replay with. That way we can skip the maximum number of segments.</a>
<a name="ln1046">  //</a>
<a name="ln1047">  // Returns the iterator pointing to the first segment to start replay with. Also produces a number</a>
<a name="ln1048">  // of diagnostic log messages.</a>
<a name="ln1049">  //</a>
<a name="ln1050">  // This functionality was originally introduced in</a>
<a name="ln1051">  // https://github.com/yugabyte/yugabyte-db/commit/41ef3f75e3c68686595c7613f53b649823b84fed</a>
<a name="ln1052">  SegmentSequence::iterator SkipFlushedEntries(SegmentSequence* segments_ptr) {</a>
<a name="ln1053">    static const char* kBootstrapOptimizerLogPrefix =</a>
<a name="ln1054">        &quot;Bootstrap optimizer (skip_flushed_entries): &quot;;</a>
<a name="ln1055"> </a>
<a name="ln1056">    // Lower bound on op IDs that need to be replayed. This is the &quot;flushed OpId&quot; that this</a>
<a name="ln1057">    // function's comment mentions.</a>
<a name="ln1058">    const auto op_id_replay_lowest = [this]() -&gt; OpId {</a>
<a name="ln1059">      const yb::OpId regular_op_id = yb::OpId::FromPB(replay_state_-&gt;regular_stored_op_id);</a>
<a name="ln1060">      const yb::OpId intents_op_id = yb::OpId::FromPB(replay_state_-&gt;intents_stored_op_id);</a>
<a name="ln1061">      const bool has_intents_db =</a>
<a name="ln1062">          tablet_-&gt;doc_db().intents || (test_hooks_ &amp;&amp; test_hooks_-&gt;HasIntentsDB());</a>
<a name="ln1063">      const auto op_id_replay_lowest =</a>
<a name="ln1064">          has_intents_db ? std::min(regular_op_id, intents_op_id) : regular_op_id;</a>
<a name="ln1065">      LOG_WITH_PREFIX(INFO)</a>
<a name="ln1066">          &lt;&lt; kBootstrapOptimizerLogPrefix</a>
<a name="ln1067">          &lt;&lt; &quot;op_id_replay_lowest=&quot; &lt;&lt; op_id_replay_lowest</a>
<a name="ln1068">          &lt;&lt; &quot; (regular_op_id=&quot; &lt;&lt; regular_op_id</a>
<a name="ln1069">          &lt;&lt; &quot;, intents_op_id=&quot; &lt;&lt; intents_op_id</a>
<a name="ln1070">          &lt;&lt; &quot;, has_intents_db=&quot; &lt;&lt; has_intents_db &lt;&lt; &quot;)&quot;;</a>
<a name="ln1071">      return op_id_replay_lowest;</a>
<a name="ln1072">    }();</a>
<a name="ln1073"> </a>
<a name="ln1074">    SegmentSequence&amp; segments = *segments_ptr;</a>
<a name="ln1075"> </a>
<a name="ln1076">    // Time point of the first entry of the last WAL segment, and how far back in time from it we</a>
<a name="ln1077">    // should retain other entries.</a>
<a name="ln1078">    boost::optional&lt;RestartSafeCoarseTimePoint&gt; replay_from_this_or_earlier_time;</a>
<a name="ln1079">    const RestartSafeCoarseDuration min_seconds_to_retain_logs =</a>
<a name="ln1080">        std::chrono::seconds(GetAtomicFlag(&amp;FLAGS_retryable_request_timeout_secs));</a>
<a name="ln1081"> </a>
<a name="ln1082">    auto iter = segments.end();</a>
<a name="ln1083">    while (iter != segments.begin()) {</a>
<a name="ln1084">      --iter;</a>
<a name="ln1085">      ReadableLogSegment&amp; segment = **iter;</a>
<a name="ln1086">      const std::string&amp; segment_path = segment.path();</a>
<a name="ln1087"> </a>
<a name="ln1088">      const auto first_op_metadata_result = segment.ReadFirstEntryMetadata();</a>
<a name="ln1089">      if (!first_op_metadata_result.ok()) {</a>
<a name="ln1090">        if (test_hooks_) {</a>
<a name="ln1091">          test_hooks_-&gt;FirstOpIdOfSegment(segment_path, OpId::Invalid());</a>
<a name="ln1092">        }</a>
<a name="ln1093">        LOG_WITH_PREFIX(WARNING)</a>
<a name="ln1094">            &lt;&lt; kBootstrapOptimizerLogPrefix</a>
<a name="ln1095">            &lt;&lt; &quot;Could not read the first entry's metadata of log segment &quot; &lt;&lt; segment_path &lt;&lt; &quot;. &quot;</a>
<a name="ln1096">            &lt;&lt; &quot;Simply continuing to earlier segments to determine the first segment &quot;</a>
<a name="ln1097">            &lt;&lt; &quot;to start the replay at. The error was: &quot; &lt;&lt; first_op_metadata_result.status();</a>
<a name="ln1098">        continue;</a>
<a name="ln1099">      }</a>
<a name="ln1100">      const auto&amp; first_op_metadata = *first_op_metadata_result;</a>
<a name="ln1101"> </a>
<a name="ln1102">      const auto op_id = first_op_metadata.op_id;</a>
<a name="ln1103">      if (test_hooks_) {</a>
<a name="ln1104">        test_hooks_-&gt;FirstOpIdOfSegment(segment_path, op_id);</a>
<a name="ln1105">      }</a>
<a name="ln1106">      const RestartSafeCoarseTimePoint first_op_time = first_op_metadata.entry_time;</a>
<a name="ln1107"> </a>
<a name="ln1108">      if (!replay_from_this_or_earlier_time.is_initialized()) {</a>
<a name="ln1109">        replay_from_this_or_earlier_time = first_op_time - min_seconds_to_retain_logs;</a>
<a name="ln1110">      }</a>
<a name="ln1111"> </a>
<a name="ln1112">      const auto is_first_op_id_low_enough = op_id &lt;= op_id_replay_lowest;</a>
<a name="ln1113">      const auto is_first_op_time_early_enough = first_op_time &lt;= replay_from_this_or_earlier_time;</a>
<a name="ln1114"> </a>
<a name="ln1115">      const auto common_details_str = [&amp;]() {</a>
<a name="ln1116">        std::ostringstream ss;</a>
<a name="ln1117">        ss &lt;&lt; EXPR_VALUE_FOR_LOG(first_op_time) &lt;&lt; &quot;, &quot;</a>
<a name="ln1118">           &lt;&lt; EXPR_VALUE_FOR_LOG(min_seconds_to_retain_logs) &lt;&lt; &quot;, &quot;</a>
<a name="ln1119">           &lt;&lt; EXPR_VALUE_FOR_LOG(*replay_from_this_or_earlier_time);</a>
<a name="ln1120">        return ss.str();</a>
<a name="ln1121">      };</a>
<a name="ln1122"> </a>
<a name="ln1123">      if (is_first_op_id_low_enough &amp;&amp; is_first_op_time_early_enough) {</a>
<a name="ln1124">        LOG_WITH_PREFIX(INFO)</a>
<a name="ln1125">            &lt;&lt; kBootstrapOptimizerLogPrefix</a>
<a name="ln1126">            &lt;&lt; &quot;found first mandatory segment op id: &quot; &lt;&lt; op_id</a>
<a name="ln1127">            &lt;&lt; common_details_str() &lt;&lt; &quot;, &quot;</a>
<a name="ln1128">            &lt;&lt; &quot;number of segments to be skipped: &quot; &lt;&lt; (iter - segments.begin());</a>
<a name="ln1129">        return iter;</a>
<a name="ln1130">      }</a>
<a name="ln1131"> </a>
<a name="ln1132">      LOG_WITH_PREFIX(INFO)</a>
<a name="ln1133">          &lt;&lt; &quot;Segment &quot; &lt;&lt; segment_path &lt;&lt; &quot; cannot be used as the first segment to start replay &quot;</a>
<a name="ln1134">          &lt;&lt; &quot;with according to our OpId and retention criteria. &quot;</a>
<a name="ln1135">          &lt;&lt; (iter == segments.begin()</a>
<a name="ln1136">                  ? &quot;However, this is already the earliest segment so we have to start replay &quot;</a>
<a name="ln1137">                    &quot;here. We should probably investigate how we got into this situation. &quot;</a>
<a name="ln1138">                  : &quot;Continuing to earlier segments.&quot;)</a>
<a name="ln1139">          &lt;&lt; EXPR_VALUE_FOR_LOG(op_id) &lt;&lt; &quot;, &quot;</a>
<a name="ln1140">          &lt;&lt; common_details_str() &lt;&lt; &quot;, &quot;</a>
<a name="ln1141">          &lt;&lt; EXPR_VALUE_FOR_LOG(is_first_op_id_low_enough) &lt;&lt; &quot;, &quot;</a>
<a name="ln1142">          &lt;&lt; EXPR_VALUE_FOR_LOG(is_first_op_time_early_enough);</a>
<a name="ln1143">    }</a>
<a name="ln1144"> </a>
<a name="ln1145">    LOG_WITH_PREFIX(INFO)</a>
<a name="ln1146">        &lt;&lt; kBootstrapOptimizerLogPrefix</a>
<a name="ln1147">        &lt;&lt; &quot;will replay all segments starting from the very first one.&quot;;</a>
<a name="ln1148"> </a>
<a name="ln1149">    return iter;</a>
<a name="ln1150">  }</a>
<a name="ln1151"> </a>
<a name="ln1152">  // Plays the log segments into the tablet being built.  The process of playing the segments can</a>
<a name="ln1153">  // work in two modes:</a>
<a name="ln1154">  //</a>
<a name="ln1155">  // - With skip_wal_rewrite enabled (default mode):</a>
<a name="ln1156">  //   Reuses existing segments of the log, rebuilding log segment footers when necessary.</a>
<a name="ln1157">  //</a>
<a name="ln1158">  // - With skip_wal_rewrite disabled (legacy mode):</a>
<a name="ln1159">  //   Moves the old log to a &quot;recovery directory&quot; and replays entries from the old into a new log.</a>
<a name="ln1160">  //   This is very I/O-intensive. We should probably get rid of this mode eventually.</a>
<a name="ln1161">  //</a>
<a name="ln1162">  // The resulting log can be continued later on when then tablet is rebuilt and starts accepting</a>
<a name="ln1163">  // writes from clients.</a>
<a name="ln1164">  CHECKED_STATUS PlaySegments(ConsensusBootstrapInfo* consensus_info) {</a>
<a name="ln1165">    const auto flushed_op_ids = VERIFY_RESULT(GetFlushedOpIds());</a>
<a name="ln1166"> </a>
<a name="ln1167">    if (tablet_-&gt;snapshot_coordinator()) {</a>
<a name="ln1168">      // We should load transaction aware snapshots before replaying logs, because we need them</a>
<a name="ln1169">      // during this replay.</a>
<a name="ln1170">      RETURN_NOT_OK(tablet_-&gt;snapshot_coordinator()-&gt;Load(tablet_.get()));</a>
<a name="ln1171">    }</a>
<a name="ln1172"> </a>
<a name="ln1173">    OpIdPB regular_op_id;</a>
<a name="ln1174">    regular_op_id.set_term(flushed_op_ids.regular.term);</a>
<a name="ln1175">    regular_op_id.set_index(flushed_op_ids.regular.index);</a>
<a name="ln1176">    OpIdPB intents_op_id;</a>
<a name="ln1177">    intents_op_id.set_term(flushed_op_ids.intents.term);</a>
<a name="ln1178">    intents_op_id.set_index(flushed_op_ids.intents.index);</a>
<a name="ln1179">    replay_state_ = std::make_unique&lt;ReplayState&gt;(regular_op_id, intents_op_id, LogPrefix());</a>
<a name="ln1180">    replay_state_-&gt;max_committed_hybrid_time = VERIFY_RESULT(tablet_-&gt;MaxPersistentHybridTime());</a>
<a name="ln1181"> </a>
<a name="ln1182">    if (FLAGS_force_recover_flushed_frontier) {</a>
<a name="ln1183">      LOG_WITH_PREFIX(WARNING)</a>
<a name="ln1184">          &lt;&lt; &quot;--force_recover_flushed_frontier specified, ignoring max committed hybrid time from  &quot;</a>
<a name="ln1185">          &lt;&lt; &quot;RocksDB metadata (will replay all log records): &quot;</a>
<a name="ln1186">          &lt;&lt; replay_state_-&gt;max_committed_hybrid_time;</a>
<a name="ln1187">      replay_state_-&gt;max_committed_hybrid_time = HybridTime::kMin;</a>
<a name="ln1188">    } else {</a>
<a name="ln1189">      LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Max persistent index in RocksDB's SSTables before bootstrap: &quot;</a>
<a name="ln1190">                            &lt;&lt; &quot;regular RocksDB: &quot;</a>
<a name="ln1191">                            &lt;&lt; replay_state_-&gt;regular_stored_op_id.ShortDebugString() &lt;&lt; &quot;; &quot;</a>
<a name="ln1192">                            &lt;&lt; &quot;intents RocksDB: &quot;</a>
<a name="ln1193">                            &lt;&lt; replay_state_-&gt;intents_stored_op_id.ShortDebugString();</a>
<a name="ln1194">    }</a>
<a name="ln1195"> </a>
<a name="ln1196">    // Open the log.</a>
<a name="ln1197">    //</a>
<a name="ln1198">    // If skip_wal_rewrite is true (default case), defer appending to this log until bootstrap is</a>
<a name="ln1199">    // finished to preserve the state of old log. In that case we don't need to create a new</a>
<a name="ln1200">    // segment until bootstrap is done.</a>
<a name="ln1201">    //</a>
<a name="ln1202">    // If skip_wal_rewrite is false, create a new segment and append each replayed entry to this</a>
<a name="ln1203">    // new log.</a>
<a name="ln1204">    RETURN_NOT_OK_PREPEND(</a>
<a name="ln1205">        OpenNewLog(log::CreateNewSegment(!FLAGS_skip_wal_rewrite)), &quot;Failed to open new log&quot;);</a>
<a name="ln1206"> </a>
<a name="ln1207">    log::SegmentSequence segments;</a>
<a name="ln1208">    RETURN_NOT_OK(log_-&gt;GetSegmentsSnapshot(&amp;segments));</a>
<a name="ln1209"> </a>
<a name="ln1210">    // Find the earliest log segment we need to read, so the rest can be ignored.</a>
<a name="ln1211">    auto iter = FLAGS_skip_flushed_entries ? SkipFlushedEntries(&amp;segments) : segments.begin();</a>
<a name="ln1212"> </a>
<a name="ln1213">    yb::OpId last_committed_op_id;</a>
<a name="ln1214">    yb::OpId last_read_entry_op_id;</a>
<a name="ln1215">    RestartSafeCoarseTimePoint last_entry_time;</a>
<a name="ln1216">    for (; iter != segments.end(); ++iter) {</a>
<a name="ln1217">      const scoped_refptr&lt;ReadableLogSegment&gt;&amp; segment = *iter;</a>
<a name="ln1218"> </a>
<a name="ln1219">      auto read_result = segment-&gt;ReadEntries();</a>
<a name="ln1220">      last_committed_op_id = std::max(last_committed_op_id, read_result.committed_op_id);</a>
<a name="ln1221">      if (!read_result.entries.empty()) {</a>
<a name="ln1222">        last_read_entry_op_id = yb::OpId::FromPB(read_result.entries.back()-&gt;replicate().id());</a>
<a name="ln1223">      }</a>
<a name="ln1224">      for (size_t entry_idx = 0; entry_idx &lt; read_result.entries.size(); ++entry_idx) {</a>
<a name="ln1225">        const Status s = HandleEntry(</a>
<a name="ln1226">            read_result.entry_metadata[entry_idx], &amp;read_result.entries[entry_idx]);</a>
<a name="ln1227">        if (!s.ok()) {</a>
<a name="ln1228">          LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Dumping replay state to log: &quot; &lt;&lt; s;</a>
<a name="ln1229">          DumpReplayStateToLog();</a>
<a name="ln1230">          RETURN_NOT_OK_PREPEND(s, DebugInfo(tablet_-&gt;tablet_id(),</a>
<a name="ln1231">                                            segment-&gt;header().sequence_number(),</a>
<a name="ln1232">                                            entry_idx, segment-&gt;path(),</a>
<a name="ln1233">                                            read_result.entries[entry_idx].get()));</a>
<a name="ln1234">        }</a>
<a name="ln1235">      }</a>
<a name="ln1236">      if (!read_result.entry_metadata.empty()) {</a>
<a name="ln1237">        last_entry_time = read_result.entry_metadata.back().entry_time;</a>
<a name="ln1238">      }</a>
<a name="ln1239"> </a>
<a name="ln1240">      // If the LogReader failed to read for some reason, we'll still try to replay as many entries</a>
<a name="ln1241">      // as possible, and then fail with Corruption.</a>
<a name="ln1242">      if (PREDICT_FALSE(!read_result.status.ok())) {</a>
<a name="ln1243">        return STATUS_FORMAT(Corruption,</a>
<a name="ln1244">                            &quot;Error reading Log Segment of tablet $0: $1 &quot;</a>
<a name="ln1245">                                &quot;(Read up to entry $2 of segment $3, in path $4)&quot;,</a>
<a name="ln1246">                            tablet_-&gt;tablet_id(),</a>
<a name="ln1247">                            read_result.status,</a>
<a name="ln1248">                            read_result.entries.size(),</a>
<a name="ln1249">                            segment-&gt;header().sequence_number(),</a>
<a name="ln1250">                            segment-&gt;path());</a>
<a name="ln1251">      }</a>
<a name="ln1252"> </a>
<a name="ln1253">      // TODO: could be more granular here and log during the segments as well, plus give info about</a>
<a name="ln1254">      // number of MB processed, but this is better than nothing.</a>
<a name="ln1255">      auto status = Format(</a>
<a name="ln1256">          &quot;Bootstrap replayed $0/$1 log segments. $2. Pending: $3 replicates. &quot;</a>
<a name="ln1257">              &quot;Last read committed op id: $4&quot;,</a>
<a name="ln1258">          (iter - segments.begin()) + 1, segments.size(), stats_,</a>
<a name="ln1259">          replay_state_-&gt;pending_replicates.size(), read_result.committed_op_id);</a>
<a name="ln1260">      if (read_result.entry_metadata.empty()) {</a>
<a name="ln1261">        status += &quot;, no entries in last segment&quot;;</a>
<a name="ln1262">      } else {</a>
<a name="ln1263">        status += &quot;, last entry metadata: &quot; + read_result.entry_metadata.back().ToString() +</a>
<a name="ln1264">                  &quot;, last read entry op id: &quot; + last_read_entry_op_id.ToString();</a>
<a name="ln1265">      }</a>
<a name="ln1266">      listener_-&gt;StatusMessage(status);</a>
<a name="ln1267">    }</a>
<a name="ln1268"> </a>
<a name="ln1269">    replay_state_-&gt;UpdateCommittedFromStored();</a>
<a name="ln1270">    RETURN_NOT_OK(ApplyCommittedPendingReplicates());</a>
<a name="ln1271"> </a>
<a name="ln1272">    if (last_committed_op_id.index &gt; replay_state_-&gt;committed_op_id.index()) {</a>
<a name="ln1273">      auto it = replay_state_-&gt;pending_replicates.find(last_committed_op_id.index);</a>
<a name="ln1274">      if (it != replay_state_-&gt;pending_replicates.end()) {</a>
<a name="ln1275">        // That should be guaranteed by RAFT protocol. If record is committed, it cannot</a>
<a name="ln1276">        // be overriden by a new leader.</a>
<a name="ln1277">        if (last_committed_op_id.term == it-&gt;second.entry-&gt;replicate().id().term()) {</a>
<a name="ln1278">          replay_state_-&gt;UpdateCommittedOpId(last_committed_op_id.ToPB&lt;OpIdPB&gt;());</a>
<a name="ln1279">          RETURN_NOT_OK(ApplyCommittedPendingReplicates());</a>
<a name="ln1280">        } else {</a>
<a name="ln1281">          DumpReplayStateToLog();</a>
<a name="ln1282">          LOG_WITH_PREFIX(DFATAL)</a>
<a name="ln1283">              &lt;&lt; &quot;Invalid last committed op id: &quot; &lt;&lt; last_committed_op_id</a>
<a name="ln1284">              &lt;&lt; &quot;, record with this index has another term: &quot;</a>
<a name="ln1285">              &lt;&lt; it-&gt;second.entry-&gt;replicate().id();</a>
<a name="ln1286">        }</a>
<a name="ln1287">      } else {</a>
<a name="ln1288">        DumpReplayStateToLog();</a>
<a name="ln1289">        LOG_WITH_PREFIX(DFATAL)</a>
<a name="ln1290">            &lt;&lt; &quot;Does not have an entry for the last committed index: &quot; &lt;&lt; last_committed_op_id</a>
<a name="ln1291">            &lt;&lt; &quot;, entries: &quot; &lt;&lt; yb::ToString(replay_state_-&gt;pending_replicates);</a>
<a name="ln1292">      }</a>
<a name="ln1293">    }</a>
<a name="ln1294"> </a>
<a name="ln1295">    LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Dumping replay state to log at the end of &quot; &lt;&lt; __FUNCTION__;</a>
<a name="ln1296">    DumpReplayStateToLog();</a>
<a name="ln1297"> </a>
<a name="ln1298">    // Set up the ConsensusBootstrapInfo structure for the caller.</a>
<a name="ln1299">    for (auto&amp; e : replay_state_-&gt;pending_replicates) {</a>
<a name="ln1300">      // We only allow log entries with an index later than the index of the last log entry already</a>
<a name="ln1301">      // applied to RocksDB to be passed to the tablet as &quot;orphaned replicates&quot;. This will make sure</a>
<a name="ln1302">      // we don't try to write to RocksDB with non-monotonic sequence ids, but still create</a>
<a name="ln1303">      // ConsensusRound instances for writes that have not been persisted into RocksDB.</a>
<a name="ln1304">      consensus_info-&gt;orphaned_replicates.emplace_back(e.second.entry-&gt;release_replicate());</a>
<a name="ln1305">    }</a>
<a name="ln1306">    LOG_WITH_PREFIX(INFO)</a>
<a name="ln1307">        &lt;&lt; &quot;Number of orphaned replicates: &quot; &lt;&lt; consensus_info-&gt;orphaned_replicates.size()</a>
<a name="ln1308">        &lt;&lt; &quot;, last id: &quot; &lt;&lt; replay_state_-&gt;prev_op_id</a>
<a name="ln1309">        &lt;&lt; &quot;, commited id: &quot; &lt;&lt; replay_state_-&gt;committed_op_id;</a>
<a name="ln1310"> </a>
<a name="ln1311">    SCHECK(replay_state_-&gt;prev_op_id.term() &gt;= replay_state_-&gt;committed_op_id.term() &amp;&amp;</a>
<a name="ln1312">           replay_state_-&gt;prev_op_id.index() &gt;= replay_state_-&gt;committed_op_id.index(),</a>
<a name="ln1313">           IllegalState, &quot;WAL files missing, or committed op id is incorrect&quot;);</a>
<a name="ln1314"> </a>
<a name="ln1315">    tablet_-&gt;mvcc_manager()-&gt;SetLastReplicated(replay_state_-&gt;max_committed_hybrid_time);</a>
<a name="ln1316">    consensus_info-&gt;last_id = replay_state_-&gt;prev_op_id;</a>
<a name="ln1317">    consensus_info-&gt;last_committed_id = replay_state_-&gt;committed_op_id;</a>
<a name="ln1318">    consensus_info-&gt;split_op_id = replay_state_-&gt;split_op_id;</a>
<a name="ln1319"> </a>
<a name="ln1320">    if (data_.retryable_requests) {</a>
<a name="ln1321">      data_.retryable_requests-&gt;Clock().Adjust(last_entry_time);</a>
<a name="ln1322">    }</a>
<a name="ln1323"> </a>
<a name="ln1324">    return Status::OK();</a>
<a name="ln1325">  }</a>
<a name="ln1326"> </a>
<a name="ln1327">  CHECKED_STATUS PlayWriteRequest(ReplicateMsg* replicate_msg) {</a>
<a name="ln1328">    SCHECK(replicate_msg-&gt;has_hybrid_time(), IllegalState,</a>
<a name="ln1329">           &quot;A write operation with no hybrid time&quot;);</a>
<a name="ln1330"> </a>
<a name="ln1331">    WriteRequestPB* write = replicate_msg-&gt;mutable_write_request();</a>
<a name="ln1332"> </a>
<a name="ln1333">    SCHECK(write-&gt;has_write_batch(), Corruption, &quot;A write request must have a write batch&quot;);</a>
<a name="ln1334"> </a>
<a name="ln1335">    WriteOperationState operation_state(nullptr, write, nullptr);</a>
<a name="ln1336">    operation_state.mutable_op_id()-&gt;CopyFrom(replicate_msg-&gt;id());</a>
<a name="ln1337">    HybridTime hybrid_time(replicate_msg-&gt;hybrid_time());</a>
<a name="ln1338">    operation_state.set_hybrid_time(hybrid_time);</a>
<a name="ln1339"> </a>
<a name="ln1340">    tablet_-&gt;mvcc_manager()-&gt;AddPending(&amp;hybrid_time);</a>
<a name="ln1341"> </a>
<a name="ln1342">    tablet_-&gt;StartOperation(&amp;operation_state);</a>
<a name="ln1343"> </a>
<a name="ln1344">    // Use committed OpId for mem store anchoring.</a>
<a name="ln1345">    operation_state.mutable_op_id()-&gt;CopyFrom(replicate_msg-&gt;id());</a>
<a name="ln1346"> </a>
<a name="ln1347">    if (test_hooks_ &amp;&amp;</a>
<a name="ln1348">        replicate_msg-&gt;has_write_request() &amp;&amp;</a>
<a name="ln1349">        replicate_msg-&gt;write_request().has_write_batch() &amp;&amp;</a>
<a name="ln1350">        replicate_msg-&gt;write_request().write_batch().has_transaction() &amp;&amp;</a>
<a name="ln1351">        test_hooks_-&gt;ShouldSkipWritingIntents()) {</a>
<a name="ln1352">      // Used in unit tests to avoid instantiating the entire transactional subsystem.</a>
<a name="ln1353">      tablet_-&gt;mvcc_manager()-&gt;Replicated(hybrid_time);</a>
<a name="ln1354">      return Status::OK();</a>
<a name="ln1355">    }</a>
<a name="ln1356"> </a>
<a name="ln1357">    auto apply_status = tablet_-&gt;ApplyRowOperations(&amp;operation_state);</a>
<a name="ln1358">    // Failure is regular case, since could happen because transaction was aborted, while</a>
<a name="ln1359">    // replicating its intents.</a>
<a name="ln1360">    LOG_IF(INFO, !apply_status.ok()) &lt;&lt; &quot;Apply operation failed: &quot; &lt;&lt; apply_status;</a>
<a name="ln1361"> </a>
<a name="ln1362">    tablet_-&gt;mvcc_manager()-&gt;Replicated(hybrid_time);</a>
<a name="ln1363">    return Status::OK();</a>
<a name="ln1364">  }</a>
<a name="ln1365"> </a>
<a name="ln1366">  CHECKED_STATUS PlayChangeMetadataRequest(ReplicateMsg* replicate_msg) {</a>
<a name="ln1367">    ChangeMetadataRequestPB* request = replicate_msg-&gt;mutable_change_metadata_request();</a>
<a name="ln1368"> </a>
<a name="ln1369">    // Decode schema</a>
<a name="ln1370">    Schema schema;</a>
<a name="ln1371">    if (request-&gt;has_schema()) {</a>
<a name="ln1372">      RETURN_NOT_OK(SchemaFromPB(request-&gt;schema(), &amp;schema));</a>
<a name="ln1373">    }</a>
<a name="ln1374"> </a>
<a name="ln1375">    ChangeMetadataOperationState operation_state(request);</a>
<a name="ln1376"> </a>
<a name="ln1377">    RETURN_NOT_OK(tablet_-&gt;CreatePreparedChangeMetadata(</a>
<a name="ln1378">        &amp;operation_state, request-&gt;has_schema() ? &amp;schema : nullptr));</a>
<a name="ln1379"> </a>
<a name="ln1380">    if (request-&gt;has_schema()) {</a>
<a name="ln1381">      // Apply the alter schema to the tablet.</a>
<a name="ln1382">      RETURN_NOT_OK_PREPEND(tablet_-&gt;AlterSchema(&amp;operation_state), &quot;Failed to AlterSchema:&quot;);</a>
<a name="ln1383"> </a>
<a name="ln1384">      // Also update the log information. Normally, the AlterSchema() call above takes care of this,</a>
<a name="ln1385">      // but our new log isn't hooked up to the tablet yet.</a>
<a name="ln1386">      log_-&gt;SetSchemaForNextLogSegment(schema, operation_state.schema_version());</a>
<a name="ln1387">    }</a>
<a name="ln1388"> </a>
<a name="ln1389">    if (request-&gt;has_wal_retention_secs()) {</a>
<a name="ln1390">      RETURN_NOT_OK_PREPEND(tablet_-&gt;AlterWalRetentionSecs(&amp;operation_state),</a>
<a name="ln1391">                            &quot;Failed to alter wal retention secs&quot;);</a>
<a name="ln1392">      log_-&gt;set_wal_retention_secs(request-&gt;wal_retention_secs());</a>
<a name="ln1393">    }</a>
<a name="ln1394"> </a>
<a name="ln1395">    return Status::OK();</a>
<a name="ln1396">  }</a>
<a name="ln1397"> </a>
<a name="ln1398">  CHECKED_STATUS PlayChangeConfigRequest(ReplicateMsg* replicate_msg) {</a>
<a name="ln1399">    ChangeConfigRecordPB* change_config = replicate_msg-&gt;mutable_change_config_record();</a>
<a name="ln1400">    RaftConfigPB config = change_config-&gt;new_config();</a>
<a name="ln1401"> </a>
<a name="ln1402">    int64_t cmeta_opid_index =  cmeta_-&gt;committed_config().opid_index();</a>
<a name="ln1403">    if (replicate_msg-&gt;id().index() &gt; cmeta_opid_index) {</a>
<a name="ln1404">      SCHECK(!config.has_opid_index(),</a>
<a name="ln1405">             Corruption,</a>
<a name="ln1406">             &quot;A config change record must have an opid_index&quot;);</a>
<a name="ln1407">      config.set_opid_index(replicate_msg-&gt;id().index());</a>
<a name="ln1408">      VLOG_WITH_PREFIX(1) &lt;&lt; &quot;WAL replay found Raft configuration with log index &quot;</a>
<a name="ln1409">                          &lt;&lt; config.opid_index()</a>
<a name="ln1410">                          &lt;&lt; &quot; that is greater than the committed config's index &quot;</a>
<a name="ln1411">                          &lt;&lt; cmeta_opid_index</a>
<a name="ln1412">                          &lt;&lt; &quot;. Applying this configuration change.&quot;;</a>
<a name="ln1413">      cmeta_-&gt;set_committed_config(config);</a>
<a name="ln1414">      // We flush once at the end of bootstrap.</a>
<a name="ln1415">    } else {</a>
<a name="ln1416">      VLOG_WITH_PREFIX(1) &lt;&lt; &quot;WAL replay found Raft configuration with log index &quot;</a>
<a name="ln1417">                          &lt;&lt; replicate_msg-&gt;id().index()</a>
<a name="ln1418">                          &lt;&lt; &quot;, which is less than or equal to the committed &quot;</a>
<a name="ln1419">                          &lt;&lt; &quot;config's index &quot; &lt;&lt; cmeta_opid_index &lt;&lt; &quot;. &quot;</a>
<a name="ln1420">                          &lt;&lt; &quot;Skipping application of this config change.&quot;;</a>
<a name="ln1421">    }</a>
<a name="ln1422"> </a>
<a name="ln1423">    return Status::OK();</a>
<a name="ln1424">  }</a>
<a name="ln1425"> </a>
<a name="ln1426">  CHECKED_STATUS PlayTruncateRequest(ReplicateMsg* replicate_msg) {</a>
<a name="ln1427">    TruncateRequestPB* req = replicate_msg-&gt;mutable_truncate_request();</a>
<a name="ln1428"> </a>
<a name="ln1429">    TruncateOperationState operation_state(nullptr, req);</a>
<a name="ln1430"> </a>
<a name="ln1431">    Status s = tablet_-&gt;Truncate(&amp;operation_state);</a>
<a name="ln1432"> </a>
<a name="ln1433">    RETURN_NOT_OK_PREPEND(s, &quot;Failed to Truncate:&quot;);</a>
<a name="ln1434"> </a>
<a name="ln1435">    return Status::OK();</a>
<a name="ln1436">  }</a>
<a name="ln1437"> </a>
<a name="ln1438">  CHECKED_STATUS PlayUpdateTransactionRequest(</a>
<a name="ln1439">      ReplicateMsg* replicate_msg, AlreadyAppliedToRegularDB already_applied_to_regular_db) {</a>
<a name="ln1440">    SCHECK(replicate_msg-&gt;has_hybrid_time(),</a>
<a name="ln1441">           Corruption, &quot;A transaction update request must have a hybrid time&quot;);</a>
<a name="ln1442"> </a>
<a name="ln1443">    UpdateTxnOperationState operation_state(</a>
<a name="ln1444">        /* tablet */ nullptr, replicate_msg-&gt;mutable_transaction_state());</a>
<a name="ln1445">    operation_state.mutable_op_id()-&gt;CopyFrom(replicate_msg-&gt;id());</a>
<a name="ln1446">    HybridTime hybrid_time(replicate_msg-&gt;hybrid_time());</a>
<a name="ln1447">    operation_state.set_hybrid_time(hybrid_time);</a>
<a name="ln1448"> </a>
<a name="ln1449">    tablet_-&gt;mvcc_manager()-&gt;AddPending(&amp;hybrid_time);</a>
<a name="ln1450">    auto scope_exit = ScopeExit([this, hybrid_time] {</a>
<a name="ln1451">      tablet_-&gt;mvcc_manager()-&gt;Replicated(hybrid_time);</a>
<a name="ln1452">    });</a>
<a name="ln1453"> </a>
<a name="ln1454">    if (test_hooks_ &amp;&amp; test_hooks_-&gt;ShouldSkipTransactionUpdates()) {</a>
<a name="ln1455">      // Used in tests where we don't have transaction participant instantiated.</a>
<a name="ln1456">      return Status::OK();</a>
<a name="ln1457">    }</a>
<a name="ln1458"> </a>
<a name="ln1459">    auto transaction_participant = tablet_-&gt;transaction_participant();</a>
<a name="ln1460">    if (transaction_participant) {</a>
<a name="ln1461">      TransactionParticipant::ReplicatedData replicated_data = {</a>
<a name="ln1462">        .leader_term = yb::OpId::kUnknownTerm,</a>
<a name="ln1463">        .state = *operation_state.request(),</a>
<a name="ln1464">        .op_id = operation_state.op_id(),</a>
<a name="ln1465">        .hybrid_time = operation_state.hybrid_time(),</a>
<a name="ln1466">        .sealed = operation_state.request()-&gt;sealed(),</a>
<a name="ln1467">        .already_applied_to_regular_db = already_applied_to_regular_db</a>
<a name="ln1468">      };</a>
<a name="ln1469">      return transaction_participant-&gt;ProcessReplicated(replicated_data);</a>
<a name="ln1470">    }</a>
<a name="ln1471"> </a>
<a name="ln1472">    auto transaction_coordinator = tablet_-&gt;transaction_coordinator();</a>
<a name="ln1473">    if (!transaction_coordinator) {</a>
<a name="ln1474">      return STATUS(</a>
<a name="ln1475">          IllegalState,</a>
<a name="ln1476">          &quot;No transaction coordinator or participant, cannot process a transaction update request&quot;);</a>
<a name="ln1477">    }</a>
<a name="ln1478">    TransactionCoordinator::ReplicatedData replicated_data = {</a>
<a name="ln1479">        yb::OpId::kUnknownTerm,</a>
<a name="ln1480">        *operation_state.request(),</a>
<a name="ln1481">        operation_state.op_id(),</a>
<a name="ln1482">        operation_state.hybrid_time()</a>
<a name="ln1483">    };</a>
<a name="ln1484">    return transaction_coordinator-&gt;ProcessReplicated(replicated_data);</a>
<a name="ln1485">  }</a>
<a name="ln1486"> </a>
<a name="ln1487">  // Decodes a HybridTime from the provided string and updates the clock with it.</a>
<a name="ln1488">  void UpdateClock(uint64_t hybrid_time) {</a>
<a name="ln1489">    data_.tablet_init_data.clock-&gt;Update(HybridTime(hybrid_time));</a>
<a name="ln1490">  }</a>
<a name="ln1491"> </a>
<a name="ln1492">  // Return a log prefix string in the standard &quot;T xxx P yyy&quot; format.</a>
<a name="ln1493">  std::string LogPrefix() const {</a>
<a name="ln1494">    return consensus::MakeTabletLogPrefix(meta_-&gt;raft_group_id(), meta_-&gt;fs_manager()-&gt;uuid());</a>
<a name="ln1495">  }</a>
<a name="ln1496"> </a>
<a name="ln1497">  Env* GetEnv() {</a>
<a name="ln1498">    if (data_.tablet_init_data.tablet_options.env) {</a>
<a name="ln1499">      return data_.tablet_init_data.tablet_options.env;</a>
<a name="ln1500">    }</a>
<a name="ln1501">    return meta_-&gt;fs_manager()-&gt;env();</a>
<a name="ln1502">  }</a>
<a name="ln1503"> </a>
<a name="ln1504">  void CleanupSnapshots() {</a>
<a name="ln1505">    // Disk clean-up: deleting temporary/incomplete snapshots.</a>
<a name="ln1506">    const string top_snapshots_dir = TabletSnapshots::SnapshotsDirName(meta_-&gt;rocksdb_dir());</a>
<a name="ln1507"> </a>
<a name="ln1508">    if (meta_-&gt;fs_manager()-&gt;env()-&gt;FileExists(top_snapshots_dir)) {</a>
<a name="ln1509">      vector&lt;string&gt; snapshot_dirs;</a>
<a name="ln1510">      Status s = meta_-&gt;fs_manager()-&gt;env()-&gt;GetChildren(</a>
<a name="ln1511">          top_snapshots_dir, ExcludeDots::kTrue, &amp;snapshot_dirs);</a>
<a name="ln1512"> </a>
<a name="ln1513">      if (!s.ok()) {</a>
<a name="ln1514">        LOG_WITH_PREFIX(WARNING) &lt;&lt; &quot;Cannot get list of snapshot directories in &quot;</a>
<a name="ln1515">                                 &lt;&lt; top_snapshots_dir &lt;&lt; &quot;: &quot; &lt;&lt; s;</a>
<a name="ln1516">      } else {</a>
<a name="ln1517">        for (const string&amp; dir_name : snapshot_dirs) {</a>
<a name="ln1518">          const string snapshot_dir = JoinPathSegments(top_snapshots_dir, dir_name);</a>
<a name="ln1519"> </a>
<a name="ln1520">          if (TabletSnapshots::IsTempSnapshotDir(snapshot_dir)) {</a>
<a name="ln1521">            LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Deleting old temporary snapshot directory &quot; &lt;&lt; snapshot_dir;</a>
<a name="ln1522"> </a>
<a name="ln1523">            s = meta_-&gt;fs_manager()-&gt;env()-&gt;DeleteRecursively(snapshot_dir);</a>
<a name="ln1524">            if (!s.ok()) {</a>
<a name="ln1525">              LOG_WITH_PREFIX(WARNING) &lt;&lt; &quot;Cannot delete old temporary snapshot directory &quot;</a>
<a name="ln1526">                                       &lt;&lt; snapshot_dir &lt;&lt; &quot;: &quot; &lt;&lt; s;</a>
<a name="ln1527">            }</a>
<a name="ln1528"> </a>
<a name="ln1529">            s = meta_-&gt;fs_manager()-&gt;env()-&gt;SyncDir(top_snapshots_dir);</a>
<a name="ln1530">            if (!s.ok()) {</a>
<a name="ln1531">              LOG_WITH_PREFIX(WARNING) &lt;&lt; &quot;Cannot sync top snapshots dir &quot; &lt;&lt; top_snapshots_dir</a>
<a name="ln1532">                                       &lt;&lt; &quot;: &quot; &lt;&lt; s;</a>
<a name="ln1533">            }</a>
<a name="ln1534">          }</a>
<a name="ln1535">        }</a>
<a name="ln1536">      }</a>
<a name="ln1537">    }</a>
<a name="ln1538">  }</a>
<a name="ln1539"> </a>
<a name="ln1540">  // Goes through the contiguous prefix of pending_replicates and applies those that are committed</a>
<a name="ln1541">  // by calling MaybeReplayCommittedEntry.</a>
<a name="ln1542">  CHECKED_STATUS ApplyCommittedPendingReplicates() {</a>
<a name="ln1543">    auto&amp; pending_replicates = replay_state_-&gt;pending_replicates;</a>
<a name="ln1544">    auto iter = pending_replicates.begin();</a>
<a name="ln1545">    while (iter != pending_replicates.end() &amp;&amp; replay_state_-&gt;CanApply(iter-&gt;second.entry.get())) {</a>
<a name="ln1546">      VLOG_WITH_PREFIX(1) &lt;&lt; &quot;Applying committed pending replicate &quot;</a>
<a name="ln1547">                          &lt;&lt; iter-&gt;second.entry-&gt;replicate().id();</a>
<a name="ln1548">      auto op_id = iter-&gt;second.entry-&gt;replicate().id();</a>
<a name="ln1549">      RETURN_NOT_OK(MaybeReplayCommittedEntry(iter-&gt;second.entry.get(), iter-&gt;second.entry_time));</a>
<a name="ln1550">      iter = pending_replicates.erase(iter);  // erase and advance the iterator (C++11)</a>
<a name="ln1551">      ++replay_state_-&gt;num_entries_applied_to_rocksdb;</a>
<a name="ln1552">    }</a>
<a name="ln1553">    return Status::OK();</a>
<a name="ln1554">  }</a>
<a name="ln1555"> </a>
<a name="ln1556">  // ----------------------------------------------------------------------------------------------</a>
<a name="ln1557">  // Member fields</a>
<a name="ln1558">  // ----------------------------------------------------------------------------------------------</a>
<a name="ln1559"> </a>
<a name="ln1560">  BootstrapTabletData data_;</a>
<a name="ln1561">  RaftGroupMetadataPtr meta_;</a>
<a name="ln1562">  std::shared_ptr&lt;MemTracker&gt; mem_tracker_;</a>
<a name="ln1563">  TabletStatusListener* listener_;</a>
<a name="ln1564">  TabletPtr tablet_;</a>
<a name="ln1565">  scoped_refptr&lt;log::Log&gt; log_;</a>
<a name="ln1566">  std::unique_ptr&lt;log::LogReader&gt; log_reader_;</a>
<a name="ln1567">  std::unique_ptr&lt;ReplayState&gt; replay_state_;</a>
<a name="ln1568"> </a>
<a name="ln1569">  std::unique_ptr&lt;consensus::ConsensusMetadata&gt; cmeta_;</a>
<a name="ln1570"> </a>
<a name="ln1571">  // Thread pool for append task for bootstrap.</a>
<a name="ln1572">  ThreadPool* append_pool_;</a>
<a name="ln1573"> </a>
<a name="ln1574">  ThreadPool* allocation_pool_;</a>
<a name="ln1575"> </a>
<a name="ln1576">  // Statistics on the replay of entries in the log.</a>
<a name="ln1577">  struct Stats {</a>
<a name="ln1578">    std::string ToString() const;</a>
<a name="ln1579"> </a>
<a name="ln1580">    // Number of REPLICATE messages read from the log</a>
<a name="ln1581">    int ops_read = 0;</a>
<a name="ln1582"> </a>
<a name="ln1583">    // Number of REPLICATE messages which were overwritten by later entries.</a>
<a name="ln1584">    int ops_overwritten = 0;</a>
<a name="ln1585">  } stats_;</a>
<a name="ln1586"> </a>
<a name="ln1587">  HybridTime rocksdb_last_entry_hybrid_time_ = HybridTime::kMin;</a>
<a name="ln1588"> </a>
<a name="ln1589">  bool skip_wal_rewrite_;</a>
<a name="ln1590"> </a>
<a name="ln1591">  // A way to inject flushed OpIds for regular and intents RocksDBs.</a>
<a name="ln1592">  boost::optional&lt;DocDbOpIds&gt; TEST_docdb_flushed_op_ids_;</a>
<a name="ln1593"> </a>
<a name="ln1594">  bool TEST_collect_replayed_op_ids_;</a>
<a name="ln1595"> </a>
<a name="ln1596">  // This is populated if TEST_collect_replayed_op_ids is true.</a>
<a name="ln1597">  std::vector&lt;yb::OpId&gt; TEST_replayed_op_ids_;</a>
<a name="ln1598"> </a>
<a name="ln1599">  std::shared_ptr&lt;TabletBootstrapTestHooksIf&gt; test_hooks_;</a>
<a name="ln1600"> </a>
<a name="ln1601">  DISALLOW_COPY_AND_ASSIGN(TabletBootstrap);</a>
<a name="ln1602">};</a>
<a name="ln1603"> </a>
<a name="ln1604">// ============================================================================</a>
<a name="ln1605">//  Class TabletBootstrap::Stats.</a>
<a name="ln1606">// ============================================================================</a>
<a name="ln1607"> </a>
<a name="ln1608">string TabletBootstrap::Stats::ToString() const {</a>
<a name="ln1609">  return Format(&quot;Read operations: $0, overwritten operations: $1&quot;,</a>
<a name="ln1610">                ops_read, ops_overwritten);</a>
<a name="ln1611">}</a>
<a name="ln1612"> </a>
<a name="ln1613">CHECKED_STATUS BootstrapTabletImpl(</a>
<a name="ln1614">    const BootstrapTabletData&amp; data,</a>
<a name="ln1615">    TabletPtr* rebuilt_tablet,</a>
<a name="ln1616">    scoped_refptr&lt;log::Log&gt;* rebuilt_log,</a>
<a name="ln1617">    consensus::ConsensusBootstrapInfo* results) {</a>
<a name="ln1618">  TabletBootstrap tablet_bootstrap(data);</a>
<a name="ln1619">  auto bootstrap_status = tablet_bootstrap.Bootstrap(rebuilt_tablet, rebuilt_log, results);</a>
<a name="ln1620">  if (!bootstrap_status.ok()) {</a>
<a name="ln1621">    LOG(WARNING) &lt;&lt; &quot;T &quot; &lt;&lt; (*rebuilt_tablet ? (*rebuilt_tablet)-&gt;tablet_id() : &quot;N/A&quot;)</a>
<a name="ln1622">                 &lt;&lt; &quot; Tablet bootstrap failed: &quot; &lt;&lt; bootstrap_status;</a>
<a name="ln1623">  }</a>
<a name="ln1624">  return bootstrap_status;</a>
<a name="ln1625">}</a>
<a name="ln1626"> </a>
<a name="ln1627">} // namespace tablet</a>
<a name="ln1628">} // namespace yb</a>

</code></pre>
<div class="balloon" rel="285"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="478"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="672"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="690"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="753"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="780"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="823"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="826"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="829"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1360"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1408"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1416"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1546"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="438"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: TEST_collect_replayed_op_ids_.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
