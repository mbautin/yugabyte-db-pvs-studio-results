
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>stl_vector.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Vector implementation -*- C++ -*-</a>
<a name="ln2"> </a>
<a name="ln3">// Copyright (C) 2001-2018 Free Software Foundation, Inc.</a>
<a name="ln4">//</a>
<a name="ln5">// This file is part of the GNU ISO C++ Library.  This library is free</a>
<a name="ln6">// software; you can redistribute it and/or modify it under the</a>
<a name="ln7">// terms of the GNU General Public License as published by the</a>
<a name="ln8">// Free Software Foundation; either version 3, or (at your option)</a>
<a name="ln9">// any later version.</a>
<a name="ln10"> </a>
<a name="ln11">// This library is distributed in the hope that it will be useful,</a>
<a name="ln12">// but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">// GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">// Under Section 7 of GPL version 3, you are granted additional</a>
<a name="ln17">// permissions described in the GCC Runtime Library Exception, version</a>
<a name="ln18">// 3.1, as published by the Free Software Foundation.</a>
<a name="ln19"> </a>
<a name="ln20">// You should have received a copy of the GNU General Public License and</a>
<a name="ln21">// a copy of the GCC Runtime Library Exception along with this program;</a>
<a name="ln22">// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see</a>
<a name="ln23">// &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln24"> </a>
<a name="ln25">/*</a>
<a name="ln26"> *</a>
<a name="ln27"> * Copyright (c) 1994</a>
<a name="ln28"> * Hewlett-Packard Company</a>
<a name="ln29"> *</a>
<a name="ln30"> * Permission to use, copy, modify, distribute and sell this software</a>
<a name="ln31"> * and its documentation for any purpose is hereby granted without fee,</a>
<a name="ln32"> * provided that the above copyright notice appear in all copies and</a>
<a name="ln33"> * that both that copyright notice and this permission notice appear</a>
<a name="ln34"> * in supporting documentation.  Hewlett-Packard Company makes no</a>
<a name="ln35"> * representations about the suitability of this software for any</a>
<a name="ln36"> * purpose.  It is provided &quot;as is&quot; without express or implied warranty.</a>
<a name="ln37"> *</a>
<a name="ln38"> *</a>
<a name="ln39"> * Copyright (c) 1996</a>
<a name="ln40"> * Silicon Graphics Computer Systems, Inc.</a>
<a name="ln41"> *</a>
<a name="ln42"> * Permission to use, copy, modify, distribute and sell this software</a>
<a name="ln43"> * and its documentation for any purpose is hereby granted without fee,</a>
<a name="ln44"> * provided that the above copyright notice appear in all copies and</a>
<a name="ln45"> * that both that copyright notice and this permission notice appear</a>
<a name="ln46"> * in supporting documentation.  Silicon Graphics makes no</a>
<a name="ln47"> * representations about the suitability of this  software for any</a>
<a name="ln48"> * purpose.  It is provided &quot;as is&quot; without express or implied warranty.</a>
<a name="ln49"> */</a>
<a name="ln50"> </a>
<a name="ln51">/** @file bits/stl_vector.h</a>
<a name="ln52"> *  This is an internal header file, included by other library headers.</a>
<a name="ln53"> *  Do not attempt to use it directly. @headername{vector}</a>
<a name="ln54"> */</a>
<a name="ln55"> </a>
<a name="ln56">#ifndef _STL_VECTOR_H</a>
<a name="ln57">#define _STL_VECTOR_H 1</a>
<a name="ln58"> </a>
<a name="ln59">#include &lt;bits/stl_iterator_base_funcs.h&gt;</a>
<a name="ln60">#include &lt;bits/functexcept.h&gt;</a>
<a name="ln61">#include &lt;bits/concept_check.h&gt;</a>
<a name="ln62">#if __cplusplus &gt;= 201103L</a>
<a name="ln63">#include &lt;initializer_list&gt;</a>
<a name="ln64">#endif</a>
<a name="ln65"> </a>
<a name="ln66">#include &lt;debug/assertions.h&gt;</a>
<a name="ln67"> </a>
<a name="ln68">#if _GLIBCXX_SANITIZE_STD_ALLOCATOR &amp;&amp; _GLIBCXX_SANITIZE_VECTOR</a>
<a name="ln69">extern &quot;C&quot; void</a>
<a name="ln70">__sanitizer_annotate_contiguous_container(const void*, const void*,</a>
<a name="ln71">					  const void*, const void*);</a>
<a name="ln72">#endif</a>
<a name="ln73"> </a>
<a name="ln74">namespace std _GLIBCXX_VISIBILITY(default)</a>
<a name="ln75">{</a>
<a name="ln76">_GLIBCXX_BEGIN_NAMESPACE_VERSION</a>
<a name="ln77">_GLIBCXX_BEGIN_NAMESPACE_CONTAINER</a>
<a name="ln78"> </a>
<a name="ln79">  /// See bits/stl_deque.h's _Deque_base for an explanation.</a>
<a name="ln80">  template&lt;typename _Tp, typename _Alloc&gt;</a>
<a name="ln81">    struct _Vector_base</a>
<a name="ln82">    {</a>
<a name="ln83">      typedef typename __gnu_cxx::__alloc_traits&lt;_Alloc&gt;::template</a>
<a name="ln84">	rebind&lt;_Tp&gt;::other _Tp_alloc_type;</a>
<a name="ln85">      typedef typename __gnu_cxx::__alloc_traits&lt;_Tp_alloc_type&gt;::pointer</a>
<a name="ln86">       	pointer;</a>
<a name="ln87"> </a>
<a name="ln88">      struct _Vector_impl</a>
<a name="ln89">      : public _Tp_alloc_type</a>
<a name="ln90">      {</a>
<a name="ln91">	pointer _M_start;</a>
<a name="ln92">	pointer _M_finish;</a>
<a name="ln93">	pointer _M_end_of_storage;</a>
<a name="ln94"> </a>
<a name="ln95">	_Vector_impl()</a>
<a name="ln96">	: _Tp_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()</a>
<a name="ln97">	{ }</a>
<a name="ln98"> </a>
<a name="ln99">	_Vector_impl(_Tp_alloc_type const&amp; __a) _GLIBCXX_NOEXCEPT</a>
<a name="ln100">	: _Tp_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage()</a>
<a name="ln101">	{ }</a>
<a name="ln102"> </a>
<a name="ln103">#if __cplusplus &gt;= 201103L</a>
<a name="ln104">	_Vector_impl(_Tp_alloc_type&amp;&amp; __a) noexcept</a>
<a name="ln105">	: _Tp_alloc_type(std::move(__a)),</a>
<a name="ln106">	  _M_start(), _M_finish(), _M_end_of_storage()</a>
<a name="ln107">	{ }</a>
<a name="ln108">#endif</a>
<a name="ln109"> </a>
<a name="ln110">	void _M_swap_data(_Vector_impl&amp; __x) _GLIBCXX_NOEXCEPT</a>
<a name="ln111">	{</a>
<a name="ln112">	  std::swap(_M_start, __x._M_start);</a>
<a name="ln113">	  std::swap(_M_finish, __x._M_finish);</a>
<a name="ln114">	  std::swap(_M_end_of_storage, __x._M_end_of_storage);</a>
<a name="ln115">	}</a>
<a name="ln116"> </a>
<a name="ln117">#if _GLIBCXX_SANITIZE_STD_ALLOCATOR &amp;&amp; _GLIBCXX_SANITIZE_VECTOR</a>
<a name="ln118">	template&lt;typename = _Tp_alloc_type&gt;</a>
<a name="ln119">	  struct _Asan</a>
<a name="ln120">	  {</a>
<a name="ln121">	    typedef typename __gnu_cxx::__alloc_traits&lt;_Tp_alloc_type&gt;</a>
<a name="ln122">	      ::size_type size_type;</a>
<a name="ln123"> </a>
<a name="ln124">	    static void _S_shrink(_Vector_impl&amp;, size_type) { }</a>
<a name="ln125">	    static void _S_on_dealloc(_Vector_impl&amp;) { }</a>
<a name="ln126"> </a>
<a name="ln127">	    typedef _Vector_impl&amp; _Reinit;</a>
<a name="ln128"> </a>
<a name="ln129">	    struct _Grow</a>
<a name="ln130">	    {</a>
<a name="ln131">	      _Grow(_Vector_impl&amp;, size_type) { }</a>
<a name="ln132">	      void _M_grew(size_type) { }</a>
<a name="ln133">	    };</a>
<a name="ln134">	  };</a>
<a name="ln135"> </a>
<a name="ln136">	// Enable ASan annotations for memory obtained from std::allocator.</a>
<a name="ln137">	template&lt;typename _Up&gt;</a>
<a name="ln138">	  struct _Asan&lt;allocator&lt;_Up&gt; &gt;</a>
<a name="ln139">	  {</a>
<a name="ln140">	    typedef typename __gnu_cxx::__alloc_traits&lt;_Tp_alloc_type&gt;</a>
<a name="ln141">	      ::size_type size_type;</a>
<a name="ln142"> </a>
<a name="ln143">	    // Adjust ASan annotation for [_M_start, _M_end_of_storage) to</a>
<a name="ln144">	    // mark end of valid region as __curr instead of __prev.</a>
<a name="ln145">	    static void</a>
<a name="ln146">	    _S_adjust(_Vector_impl&amp; __impl, pointer __prev, pointer __curr)</a>
<a name="ln147">	    {</a>
<a name="ln148">	      __sanitizer_annotate_contiguous_container(__impl._M_start,</a>
<a name="ln149">		  __impl._M_end_of_storage, __prev, __curr);</a>
<a name="ln150">	    }</a>
<a name="ln151"> </a>
<a name="ln152">	    static void</a>
<a name="ln153">	    _S_grow(_Vector_impl&amp; __impl, size_type __n)</a>
<a name="ln154">	    { _S_adjust(__impl, __impl._M_finish, __impl._M_finish + __n); }</a>
<a name="ln155"> </a>
<a name="ln156">	    static void</a>
<a name="ln157">	    _S_shrink(_Vector_impl&amp; __impl, size_type __n)</a>
<a name="ln158">	    { _S_adjust(__impl, __impl._M_finish + __n, __impl._M_finish); }</a>
<a name="ln159"> </a>
<a name="ln160">	    static void</a>
<a name="ln161">	    _S_on_dealloc(_Vector_impl&amp; __impl)</a>
<a name="ln162">	    {</a>
<a name="ln163">	      if (__impl._M_start)</a>
<a name="ln164">		_S_adjust(__impl, __impl._M_finish, __impl._M_end_of_storage);</a>
<a name="ln165">	    }</a>
<a name="ln166"> </a>
<a name="ln167">	    // Used on reallocation to tell ASan unused capacity is invalid.</a>
<a name="ln168">	    struct _Reinit</a>
<a name="ln169">	    {</a>
<a name="ln170">	      explicit _Reinit(_Vector_impl&amp; __impl) : _M_impl(__impl)</a>
<a name="ln171">	      {</a>
<a name="ln172">		// Mark unused capacity as valid again before deallocating it.</a>
<a name="ln173">		_S_on_dealloc(_M_impl);</a>
<a name="ln174">	      }</a>
<a name="ln175"> </a>
<a name="ln176">	      ~_Reinit()</a>
<a name="ln177">	      {</a>
<a name="ln178">		// Mark unused capacity as invalid after reallocation.</a>
<a name="ln179">		if (_M_impl._M_start)</a>
<a name="ln180">		  _S_adjust(_M_impl, _M_impl._M_end_of_storage,</a>
<a name="ln181">			    _M_impl._M_finish);</a>
<a name="ln182">	      }</a>
<a name="ln183"> </a>
<a name="ln184">	      _Vector_impl&amp; _M_impl;</a>
<a name="ln185"> </a>
<a name="ln186">#if __cplusplus &gt;= 201103L</a>
<a name="ln187">	      _Reinit(const _Reinit&amp;) = delete;</a>
<a name="ln188">	      _Reinit&amp; operator=(const _Reinit&amp;) = delete;</a>
<a name="ln189">#endif</a>
<a name="ln190">	    };</a>
<a name="ln191"> </a>
<a name="ln192">	    // Tell ASan when unused capacity is initialized to be valid.</a>
<a name="ln193">	    struct _Grow</a>
<a name="ln194">	    {</a>
<a name="ln195">	      _Grow(_Vector_impl&amp; __impl, size_type __n)</a>
<a name="ln196">	      : _M_impl(__impl), _M_n(__n)</a>
<a name="ln197">	      { _S_grow(_M_impl, __n); }</a>
<a name="ln198"> </a>
<a name="ln199">	      ~_Grow() { if (_M_n) _S_shrink(_M_impl, _M_n); }</a>
<a name="ln200"> </a>
<a name="ln201">	      void _M_grew(size_type __n) { _M_n -= __n; }</a>
<a name="ln202"> </a>
<a name="ln203">#if __cplusplus &gt;= 201103L</a>
<a name="ln204">	      _Grow(const _Grow&amp;) = delete;</a>
<a name="ln205">	      _Grow&amp; operator=(const _Grow&amp;) = delete;</a>
<a name="ln206">#endif</a>
<a name="ln207">	    private:</a>
<a name="ln208">	      _Vector_impl&amp; _M_impl;</a>
<a name="ln209">	      size_type _M_n;</a>
<a name="ln210">	    };</a>
<a name="ln211">	  };</a>
<a name="ln212"> </a>
<a name="ln213">#define _GLIBCXX_ASAN_ANNOTATE_REINIT \</a>
<a name="ln214">  typename _Base::_Vector_impl::template _Asan&lt;&gt;::_Reinit const \</a>
<a name="ln215">	__attribute__((__unused__)) __reinit_guard(this-&gt;_M_impl)</a>
<a name="ln216">#define _GLIBCXX_ASAN_ANNOTATE_GROW(n) \</a>
<a name="ln217">  typename _Base::_Vector_impl::template _Asan&lt;&gt;::_Grow \</a>
<a name="ln218">	__attribute__((__unused__)) __grow_guard(this-&gt;_M_impl, (n))</a>
<a name="ln219">#define _GLIBCXX_ASAN_ANNOTATE_GREW(n) __grow_guard._M_grew(n)</a>
<a name="ln220">#define _GLIBCXX_ASAN_ANNOTATE_SHRINK(n) \</a>
<a name="ln221">  _Base::_Vector_impl::template _Asan&lt;&gt;::_S_shrink(this-&gt;_M_impl, n)</a>
<a name="ln222">#define _GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC \</a>
<a name="ln223">  _Base::_Vector_impl::template _Asan&lt;&gt;::_S_on_dealloc(this-&gt;_M_impl)</a>
<a name="ln224">#else // ! (_GLIBCXX_SANITIZE_STD_ALLOCATOR &amp;&amp; _GLIBCXX_SANITIZE_VECTOR)</a>
<a name="ln225">#define _GLIBCXX_ASAN_ANNOTATE_REINIT</a>
<a name="ln226">#define _GLIBCXX_ASAN_ANNOTATE_GROW(n)</a>
<a name="ln227">#define _GLIBCXX_ASAN_ANNOTATE_GREW(n)</a>
<a name="ln228">#define _GLIBCXX_ASAN_ANNOTATE_SHRINK(n)</a>
<a name="ln229">#define _GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC</a>
<a name="ln230">#endif // _GLIBCXX_SANITIZE_STD_ALLOCATOR &amp;&amp; _GLIBCXX_SANITIZE_VECTOR</a>
<a name="ln231">      };</a>
<a name="ln232"> </a>
<a name="ln233">    public:</a>
<a name="ln234">      typedef _Alloc allocator_type;</a>
<a name="ln235"> </a>
<a name="ln236">      _Tp_alloc_type&amp;</a>
<a name="ln237">      _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT</a>
<a name="ln238">      { return *static_cast&lt;_Tp_alloc_type*&gt;(&amp;this-&gt;_M_impl); }</a>
<a name="ln239"> </a>
<a name="ln240">      const _Tp_alloc_type&amp;</a>
<a name="ln241">      _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT</a>
<a name="ln242">      { return *static_cast&lt;const _Tp_alloc_type*&gt;(&amp;this-&gt;_M_impl); }</a>
<a name="ln243"> </a>
<a name="ln244">      allocator_type</a>
<a name="ln245">      get_allocator() const _GLIBCXX_NOEXCEPT</a>
<a name="ln246">      { return allocator_type(_M_get_Tp_allocator()); }</a>
<a name="ln247"> </a>
<a name="ln248">      _Vector_base()</a>
<a name="ln249">      : _M_impl() { }</a>
<a name="ln250"> </a>
<a name="ln251">      _Vector_base(const allocator_type&amp; __a) _GLIBCXX_NOEXCEPT</a>
<a name="ln252">      : _M_impl(__a) { }</a>
<a name="ln253"> </a>
<a name="ln254">      _Vector_base(size_t __n)</a>
<a name="ln255">      : _M_impl()</a>
<a name="ln256">      { _M_create_storage(__n); }</a>
<a name="ln257"> </a>
<a name="ln258">      _Vector_base(size_t __n, const allocator_type&amp; __a)</a>
<a name="ln259">      : _M_impl(__a)</a>
<a name="ln260">      { _M_create_storage(__n); }</a>
<a name="ln261"> </a>
<a name="ln262">#if __cplusplus &gt;= 201103L</a>
<a name="ln263">      _Vector_base(_Tp_alloc_type&amp;&amp; __a) noexcept</a>
<a name="ln264">      : _M_impl(std::move(__a)) { }</a>
<a name="ln265"> </a>
<a name="ln266">      _Vector_base(_Vector_base&amp;&amp; __x) noexcept</a>
<a name="ln267">      : _M_impl(std::move(__x._M_get_Tp_allocator()))</a>
<a name="ln268">      { this-&gt;_M_impl._M_swap_data(__x._M_impl); }</a>
<a name="ln269"> </a>
<a name="ln270">      _Vector_base(_Vector_base&amp;&amp; __x, const allocator_type&amp; __a)</a>
<a name="ln271">      : _M_impl(__a)</a>
<a name="ln272">      {</a>
<a name="ln273">	if (__x.get_allocator() == __a)</a>
<a name="ln274">	  this-&gt;_M_impl._M_swap_data(__x._M_impl);</a>
<a name="ln275">	else</a>
<a name="ln276">	  {</a>
<a name="ln277">	    size_t __n = __x._M_impl._M_finish - __x._M_impl._M_start;</a>
<a name="ln278">	    _M_create_storage(__n);</a>
<a name="ln279">	  }</a>
<a name="ln280">      }</a>
<a name="ln281">#endif</a>
<a name="ln282"> </a>
<a name="ln283">      ~_Vector_base() _GLIBCXX_NOEXCEPT</a>
<a name="ln284">      {</a>
<a name="ln285">	_M_deallocate(_M_impl._M_start,</a>
<a name="ln286">		      _M_impl._M_end_of_storage - _M_impl._M_start);</a>
<a name="ln287">      }</a>
<a name="ln288"> </a>
<a name="ln289">    public:</a>
<a name="ln290">      _Vector_impl _M_impl;</a>
<a name="ln291"> </a>
<a name="ln292">      pointer</a>
<a name="ln293">      _M_allocate(size_t __n)</a>
<a name="ln294">      {</a>
<a name="ln295">	typedef __gnu_cxx::__alloc_traits&lt;_Tp_alloc_type&gt; _Tr;</a>
<a name="ln296">	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();</a>
<a name="ln297">      }</a>
<a name="ln298"> </a>
<a name="ln299">      void</a>
<a name="ln300">      _M_deallocate(pointer __p, size_t __n)</a>
<a name="ln301">      {</a>
<a name="ln302">	typedef __gnu_cxx::__alloc_traits&lt;_Tp_alloc_type&gt; _Tr;</a>
<a name="ln303">	if (__p)</a>
<a name="ln304">	  _Tr::deallocate(_M_impl, __p, __n);</a>
<a name="ln305">      }</a>
<a name="ln306"> </a>
<a name="ln307">    private:</a>
<a name="ln308">      void</a>
<a name="ln309">      _M_create_storage(size_t __n)</a>
<a name="ln310">      {</a>
<a name="ln311">	this-&gt;_M_impl._M_start = this-&gt;_M_allocate(__n);</a>
<a name="ln312">	this-&gt;_M_impl._M_finish = this-&gt;_M_impl._M_start;</a>
<a name="ln313">	this-&gt;_M_impl._M_end_of_storage = this-&gt;_M_impl._M_start + __n;</a>
<a name="ln314">      }</a>
<a name="ln315">    };</a>
<a name="ln316"> </a>
<a name="ln317">  /**</a>
<a name="ln318">   *  @brief A standard container which offers fixed time access to</a>
<a name="ln319">   *  individual elements in any order.</a>
<a name="ln320">   *</a>
<a name="ln321">   *  @ingroup sequences</a>
<a name="ln322">   *</a>
<a name="ln323">   *  @tparam _Tp  Type of element.</a>
<a name="ln324">   *  @tparam _Alloc  Allocator type, defaults to allocator&lt;_Tp&gt;.</a>
<a name="ln325">   *</a>
<a name="ln326">   *  Meets the requirements of a &lt;a href=&quot;tables.html#65&quot;&gt;container&lt;/a&gt;, a</a>
<a name="ln327">   *  &lt;a href=&quot;tables.html#66&quot;&gt;reversible container&lt;/a&gt;, and a</a>
<a name="ln328">   *  &lt;a href=&quot;tables.html#67&quot;&gt;sequence&lt;/a&gt;, including the</a>
<a name="ln329">   *  &lt;a href=&quot;tables.html#68&quot;&gt;optional sequence requirements&lt;/a&gt; with the</a>
<a name="ln330">   *  %exception of @c push_front and @c pop_front.</a>
<a name="ln331">   *</a>
<a name="ln332">   *  In some terminology a %vector can be described as a dynamic</a>
<a name="ln333">   *  C-style array, it offers fast and efficient access to individual</a>
<a name="ln334">   *  elements in any order and saves the user from worrying about</a>
<a name="ln335">   *  memory and size allocation.  Subscripting ( @c [] ) access is</a>
<a name="ln336">   *  also provided as with C-style arrays.</a>
<a name="ln337">  */</a>
<a name="ln338">  template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt; &gt;</a>
<a name="ln339">    class vector : protected _Vector_base&lt;_Tp, _Alloc&gt;</a>
<a name="ln340">    {</a>
<a name="ln341">#ifdef _GLIBCXX_CONCEPT_CHECKS</a>
<a name="ln342">      // Concept requirements.</a>
<a name="ln343">      typedef typename _Alloc::value_type		_Alloc_value_type;</a>
<a name="ln344"># if __cplusplus &lt; 201103L</a>
<a name="ln345">      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)</a>
<a name="ln346"># endif</a>
<a name="ln347">      __glibcxx_class_requires2(_Tp, _Alloc_value_type, _SameTypeConcept)</a>
<a name="ln348">#endif</a>
<a name="ln349"> </a>
<a name="ln350">#if __cplusplus &gt;= 201103L</a>
<a name="ln351">      static_assert(is_same&lt;typename remove_cv&lt;_Tp&gt;::type, _Tp&gt;::value,</a>
<a name="ln352">	  &quot;std::vector must have a non-const, non-volatile value_type&quot;);</a>
<a name="ln353"># ifdef __STRICT_ANSI__</a>
<a name="ln354">      static_assert(is_same&lt;typename _Alloc::value_type, _Tp&gt;::value,</a>
<a name="ln355">	  &quot;std::vector must have the same value_type as its allocator&quot;);</a>
<a name="ln356"># endif</a>
<a name="ln357">#endif</a>
<a name="ln358"> </a>
<a name="ln359">      typedef _Vector_base&lt;_Tp, _Alloc&gt;			_Base;</a>
<a name="ln360">      typedef typename _Base::_Tp_alloc_type		_Tp_alloc_type;</a>
<a name="ln361">      typedef __gnu_cxx::__alloc_traits&lt;_Tp_alloc_type&gt;	_Alloc_traits;</a>
<a name="ln362"> </a>
<a name="ln363">    public:</a>
<a name="ln364">      typedef _Tp					value_type;</a>
<a name="ln365">      typedef typename _Base::pointer			pointer;</a>
<a name="ln366">      typedef typename _Alloc_traits::const_pointer	const_pointer;</a>
<a name="ln367">      typedef typename _Alloc_traits::reference		reference;</a>
<a name="ln368">      typedef typename _Alloc_traits::const_reference	const_reference;</a>
<a name="ln369">      typedef __gnu_cxx::__normal_iterator&lt;pointer, vector&gt; iterator;</a>
<a name="ln370">      typedef __gnu_cxx::__normal_iterator&lt;const_pointer, vector&gt;</a>
<a name="ln371">      const_iterator;</a>
<a name="ln372">      typedef std::reverse_iterator&lt;const_iterator&gt;	const_reverse_iterator;</a>
<a name="ln373">      typedef std::reverse_iterator&lt;iterator&gt;		reverse_iterator;</a>
<a name="ln374">      typedef size_t					size_type;</a>
<a name="ln375">      typedef ptrdiff_t					difference_type;</a>
<a name="ln376">      typedef _Alloc					allocator_type;</a>
<a name="ln377"> </a>
<a name="ln378">    protected:</a>
<a name="ln379">      using _Base::_M_allocate;</a>
<a name="ln380">      using _Base::_M_deallocate;</a>
<a name="ln381">      using _Base::_M_impl;</a>
<a name="ln382">      using _Base::_M_get_Tp_allocator;</a>
<a name="ln383"> </a>
<a name="ln384">    public:</a>
<a name="ln385">      // [23.2.4.1] construct/copy/destroy</a>
<a name="ln386">      // (assign() and get_allocator() are also listed in this section)</a>
<a name="ln387"> </a>
<a name="ln388">      /**</a>
<a name="ln389">       *  @brief  Creates a %vector with no elements.</a>
<a name="ln390">       */</a>
<a name="ln391">      vector()</a>
<a name="ln392">#if __cplusplus &gt;= 201103L</a>
<a name="ln393">      noexcept(is_nothrow_default_constructible&lt;_Alloc&gt;::value)</a>
<a name="ln394">#endif</a>
<a name="ln395">      : _Base() { }</a>
<a name="ln396"> </a>
<a name="ln397">      /**</a>
<a name="ln398">       *  @brief  Creates a %vector with no elements.</a>
<a name="ln399">       *  @param  __a  An allocator object.</a>
<a name="ln400">       */</a>
<a name="ln401">      explicit</a>
<a name="ln402">      vector(const allocator_type&amp; __a) _GLIBCXX_NOEXCEPT</a>
<a name="ln403">      : _Base(__a) { }</a>
<a name="ln404"> </a>
<a name="ln405">#if __cplusplus &gt;= 201103L</a>
<a name="ln406">      /**</a>
<a name="ln407">       *  @brief  Creates a %vector with default constructed elements.</a>
<a name="ln408">       *  @param  __n  The number of elements to initially create.</a>
<a name="ln409">       *  @param  __a  An allocator.</a>
<a name="ln410">       *</a>
<a name="ln411">       *  This constructor fills the %vector with @a __n default</a>
<a name="ln412">       *  constructed elements.</a>
<a name="ln413">       */</a>
<a name="ln414">      explicit</a>
<a name="ln415">      vector(size_type __n, const allocator_type&amp; __a = allocator_type())</a>
<a name="ln416">      : _Base(__n, __a)</a>
<a name="ln417">      { _M_default_initialize(__n); }</a>
<a name="ln418"> </a>
<a name="ln419">      /**</a>
<a name="ln420">       *  @brief  Creates a %vector with copies of an exemplar element.</a>
<a name="ln421">       *  @param  __n  The number of elements to initially create.</a>
<a name="ln422">       *  @param  __value  An element to copy.</a>
<a name="ln423">       *  @param  __a  An allocator.</a>
<a name="ln424">       *</a>
<a name="ln425">       *  This constructor fills the %vector with @a __n copies of @a __value.</a>
<a name="ln426">       */</a>
<a name="ln427">      vector(size_type __n, const value_type&amp; __value,</a>
<a name="ln428">	     const allocator_type&amp; __a = allocator_type())</a>
<a name="ln429">      : _Base(__n, __a)</a>
<a name="ln430">      { _M_fill_initialize(__n, __value); }</a>
<a name="ln431">#else</a>
<a name="ln432">      /**</a>
<a name="ln433">       *  @brief  Creates a %vector with copies of an exemplar element.</a>
<a name="ln434">       *  @param  __n  The number of elements to initially create.</a>
<a name="ln435">       *  @param  __value  An element to copy.</a>
<a name="ln436">       *  @param  __a  An allocator.</a>
<a name="ln437">       *</a>
<a name="ln438">       *  This constructor fills the %vector with @a __n copies of @a __value.</a>
<a name="ln439">       */</a>
<a name="ln440">      explicit</a>
<a name="ln441">      vector(size_type __n, const value_type&amp; __value = value_type(),</a>
<a name="ln442">	     const allocator_type&amp; __a = allocator_type())</a>
<a name="ln443">      : _Base(__n, __a)</a>
<a name="ln444">      { _M_fill_initialize(__n, __value); }</a>
<a name="ln445">#endif</a>
<a name="ln446"> </a>
<a name="ln447">      /**</a>
<a name="ln448">       *  @brief  %Vector copy constructor.</a>
<a name="ln449">       *  @param  __x  A %vector of identical element and allocator types.</a>
<a name="ln450">       *</a>
<a name="ln451">       *  All the elements of @a __x are copied, but any unused capacity in</a>
<a name="ln452">       *  @a __x  will not be copied</a>
<a name="ln453">       *  (i.e. capacity() == size() in the new %vector).</a>
<a name="ln454">       *</a>
<a name="ln455">       *  The newly-created %vector uses a copy of the allocator object used</a>
<a name="ln456">       *  by @a __x (unless the allocator traits dictate a different object).</a>
<a name="ln457">       */</a>
<a name="ln458">      vector(const vector&amp; __x)</a>
<a name="ln459">      : _Base(__x.size(),</a>
<a name="ln460">	_Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))</a>
<a name="ln461">      {</a>
<a name="ln462">	this-&gt;_M_impl._M_finish =</a>
<a name="ln463">	  std::__uninitialized_copy_a(__x.begin(), __x.end(),</a>
<a name="ln464">				      this-&gt;_M_impl._M_start,</a>
<a name="ln465">				      _M_get_Tp_allocator());</a>
<a name="ln466">      }</a>
<a name="ln467"> </a>
<a name="ln468">#if __cplusplus &gt;= 201103L</a>
<a name="ln469">      /**</a>
<a name="ln470">       *  @brief  %Vector move constructor.</a>
<a name="ln471">       *  @param  __x  A %vector of identical element and allocator types.</a>
<a name="ln472">       *</a>
<a name="ln473">       *  The newly-created %vector contains the exact contents of @a __x.</a>
<a name="ln474">       *  The contents of @a __x are a valid, but unspecified %vector.</a>
<a name="ln475">       */</a>
<a name="ln476">      vector(vector&amp;&amp; __x) noexcept</a>
<a name="ln477">      : _Base(std::move(__x)) { }</a>
<a name="ln478"> </a>
<a name="ln479">      /// Copy constructor with alternative allocator</a>
<a name="ln480">      vector(const vector&amp; __x, const allocator_type&amp; __a)</a>
<a name="ln481">      : _Base(__x.size(), __a)</a>
<a name="ln482">      {</a>
<a name="ln483">	this-&gt;_M_impl._M_finish =</a>
<a name="ln484">	  std::__uninitialized_copy_a(__x.begin(), __x.end(),</a>
<a name="ln485">				      this-&gt;_M_impl._M_start,</a>
<a name="ln486">				      _M_get_Tp_allocator());</a>
<a name="ln487">      }</a>
<a name="ln488"> </a>
<a name="ln489">      /// Move constructor with alternative allocator</a>
<a name="ln490">      vector(vector&amp;&amp; __rv, const allocator_type&amp; __m)</a>
<a name="ln491">      noexcept(_Alloc_traits::_S_always_equal())</a>
<a name="ln492">      : _Base(std::move(__rv), __m)</a>
<a name="ln493">      {</a>
<a name="ln494">	if (__rv.get_allocator() != __m)</a>
<a name="ln495">	  {</a>
<a name="ln496">	    this-&gt;_M_impl._M_finish =</a>
<a name="ln497">	      std::__uninitialized_move_a(__rv.begin(), __rv.end(),</a>
<a name="ln498">					  this-&gt;_M_impl._M_start,</a>
<a name="ln499">					  _M_get_Tp_allocator());</a>
<a name="ln500">	    __rv.clear();</a>
<a name="ln501">	  }</a>
<a name="ln502">      }</a>
<a name="ln503"> </a>
<a name="ln504">      /**</a>
<a name="ln505">       *  @brief  Builds a %vector from an initializer list.</a>
<a name="ln506">       *  @param  __l  An initializer_list.</a>
<a name="ln507">       *  @param  __a  An allocator.</a>
<a name="ln508">       *</a>
<a name="ln509">       *  Create a %vector consisting of copies of the elements in the</a>
<a name="ln510">       *  initializer_list @a __l.</a>
<a name="ln511">       *</a>
<a name="ln512">       *  This will call the element type's copy constructor N times</a>
<a name="ln513">       *  (where N is @a __l.size()) and do no memory reallocation.</a>
<a name="ln514">       */</a>
<a name="ln515">      vector(initializer_list&lt;value_type&gt; __l,</a>
<a name="ln516">	     const allocator_type&amp; __a = allocator_type())</a>
<a name="ln517">      : _Base(__a)</a>
<a name="ln518">      {</a>
<a name="ln519">	_M_range_initialize(__l.begin(), __l.end(),</a>
<a name="ln520">			    random_access_iterator_tag());</a>
<a name="ln521">      }</a>
<a name="ln522">#endif</a>
<a name="ln523"> </a>
<a name="ln524">      /**</a>
<a name="ln525">       *  @brief  Builds a %vector from a range.</a>
<a name="ln526">       *  @param  __first  An input iterator.</a>
<a name="ln527">       *  @param  __last  An input iterator.</a>
<a name="ln528">       *  @param  __a  An allocator.</a>
<a name="ln529">       *</a>
<a name="ln530">       *  Create a %vector consisting of copies of the elements from</a>
<a name="ln531">       *  [first,last).</a>
<a name="ln532">       *</a>
<a name="ln533">       *  If the iterators are forward, bidirectional, or</a>
<a name="ln534">       *  random-access, then this will call the elements' copy</a>
<a name="ln535">       *  constructor N times (where N is distance(first,last)) and do</a>
<a name="ln536">       *  no memory reallocation.  But if only input iterators are</a>
<a name="ln537">       *  used, then this will do at most 2N calls to the copy</a>
<a name="ln538">       *  constructor, and logN memory reallocations.</a>
<a name="ln539">       */</a>
<a name="ln540">#if __cplusplus &gt;= 201103L</a>
<a name="ln541">      template&lt;typename _InputIterator,</a>
<a name="ln542">	       typename = std::_RequireInputIter&lt;_InputIterator&gt;&gt;</a>
<a name="ln543">	vector(_InputIterator __first, _InputIterator __last,</a>
<a name="ln544">	       const allocator_type&amp; __a = allocator_type())</a>
<a name="ln545">	: _Base(__a)</a>
<a name="ln546">	{ _M_initialize_dispatch(__first, __last, __false_type()); }</a>
<a name="ln547">#else</a>
<a name="ln548">      template&lt;typename _InputIterator&gt;</a>
<a name="ln549">	vector(_InputIterator __first, _InputIterator __last,</a>
<a name="ln550">	       const allocator_type&amp; __a = allocator_type())</a>
<a name="ln551">	: _Base(__a)</a>
<a name="ln552">	{</a>
<a name="ln553">	  // Check whether it's an integral type.  If so, it's not an iterator.</a>
<a name="ln554">	  typedef typename std::__is_integer&lt;_InputIterator&gt;::__type _Integral;</a>
<a name="ln555">	  _M_initialize_dispatch(__first, __last, _Integral());</a>
<a name="ln556">	}</a>
<a name="ln557">#endif</a>
<a name="ln558"> </a>
<a name="ln559">      /**</a>
<a name="ln560">       *  The dtor only erases the elements, and note that if the</a>
<a name="ln561">       *  elements themselves are pointers, the pointed-to memory is</a>
<a name="ln562">       *  not touched in any way.  Managing the pointer is the user's</a>
<a name="ln563">       *  responsibility.</a>
<a name="ln564">       */</a>
<a name="ln565">      ~vector() _GLIBCXX_NOEXCEPT</a>
<a name="ln566">      {</a>
<a name="ln567">	std::_Destroy(this-&gt;_M_impl._M_start, this-&gt;_M_impl._M_finish,</a>
<a name="ln568">		      _M_get_Tp_allocator());</a>
<a name="ln569">	_GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC;</a>
<a name="ln570">      }</a>
<a name="ln571"> </a>
<a name="ln572">      /**</a>
<a name="ln573">       *  @brief  %Vector assignment operator.</a>
<a name="ln574">       *  @param  __x  A %vector of identical element and allocator types.</a>
<a name="ln575">       *</a>
<a name="ln576">       *  All the elements of @a __x are copied, but any unused capacity in</a>
<a name="ln577">       *  @a __x will not be copied.</a>
<a name="ln578">       *</a>
<a name="ln579">       *  Whether the allocator is copied depends on the allocator traits.</a>
<a name="ln580">       */</a>
<a name="ln581">      vector&amp;</a>
<a name="ln582">      operator=(const vector&amp; __x);</a>
<a name="ln583"> </a>
<a name="ln584">#if __cplusplus &gt;= 201103L</a>
<a name="ln585">      /**</a>
<a name="ln586">       *  @brief  %Vector move assignment operator.</a>
<a name="ln587">       *  @param  __x  A %vector of identical element and allocator types.</a>
<a name="ln588">       *</a>
<a name="ln589">       *  The contents of @a __x are moved into this %vector (without copying,</a>
<a name="ln590">       *  if the allocators permit it).</a>
<a name="ln591">       *  Afterwards @a __x is a valid, but unspecified %vector.</a>
<a name="ln592">       *</a>
<a name="ln593">       *  Whether the allocator is moved depends on the allocator traits.</a>
<a name="ln594">       */</a>
<a name="ln595">      vector&amp;</a>
<a name="ln596">      operator=(vector&amp;&amp; __x) noexcept(_Alloc_traits::_S_nothrow_move())</a>
<a name="ln597">      {</a>
<a name="ln598">	constexpr bool __move_storage =</a>
<a name="ln599">	  _Alloc_traits::_S_propagate_on_move_assign()</a>
<a name="ln600">	  || _Alloc_traits::_S_always_equal();</a>
<a name="ln601">	_M_move_assign(std::move(__x), __bool_constant&lt;__move_storage&gt;());</a>
<a name="ln602">	return *this;</a>
<a name="ln603">      }</a>
<a name="ln604"> </a>
<a name="ln605">      /**</a>
<a name="ln606">       *  @brief  %Vector list assignment operator.</a>
<a name="ln607">       *  @param  __l  An initializer_list.</a>
<a name="ln608">       *</a>
<a name="ln609">       *  This function fills a %vector with copies of the elements in the</a>
<a name="ln610">       *  initializer list @a __l.</a>
<a name="ln611">       *</a>
<a name="ln612">       *  Note that the assignment completely changes the %vector and</a>
<a name="ln613">       *  that the resulting %vector's size is the same as the number</a>
<a name="ln614">       *  of elements assigned.</a>
<a name="ln615">       */</a>
<a name="ln616">      vector&amp;</a>
<a name="ln617">      operator=(initializer_list&lt;value_type&gt; __l)</a>
<a name="ln618">      {</a>
<a name="ln619">	this-&gt;_M_assign_aux(__l.begin(), __l.end(),</a>
<a name="ln620">			    random_access_iterator_tag());</a>
<a name="ln621">	return *this;</a>
<a name="ln622">      }</a>
<a name="ln623">#endif</a>
<a name="ln624"> </a>
<a name="ln625">      /**</a>
<a name="ln626">       *  @brief  Assigns a given value to a %vector.</a>
<a name="ln627">       *  @param  __n  Number of elements to be assigned.</a>
<a name="ln628">       *  @param  __val  Value to be assigned.</a>
<a name="ln629">       *</a>
<a name="ln630">       *  This function fills a %vector with @a __n copies of the given</a>
<a name="ln631">       *  value.  Note that the assignment completely changes the</a>
<a name="ln632">       *  %vector and that the resulting %vector's size is the same as</a>
<a name="ln633">       *  the number of elements assigned.</a>
<a name="ln634">       */</a>
<a name="ln635">      void</a>
<a name="ln636">      assign(size_type __n, const value_type&amp; __val)</a>
<a name="ln637">      { _M_fill_assign(__n, __val); }</a>
<a name="ln638"> </a>
<a name="ln639">      /**</a>
<a name="ln640">       *  @brief  Assigns a range to a %vector.</a>
<a name="ln641">       *  @param  __first  An input iterator.</a>
<a name="ln642">       *  @param  __last   An input iterator.</a>
<a name="ln643">       *</a>
<a name="ln644">       *  This function fills a %vector with copies of the elements in the</a>
<a name="ln645">       *  range [__first,__last).</a>
<a name="ln646">       *</a>
<a name="ln647">       *  Note that the assignment completely changes the %vector and</a>
<a name="ln648">       *  that the resulting %vector's size is the same as the number</a>
<a name="ln649">       *  of elements assigned.</a>
<a name="ln650">       */</a>
<a name="ln651">#if __cplusplus &gt;= 201103L</a>
<a name="ln652">      template&lt;typename _InputIterator,</a>
<a name="ln653">	       typename = std::_RequireInputIter&lt;_InputIterator&gt;&gt;</a>
<a name="ln654">	void</a>
<a name="ln655">	assign(_InputIterator __first, _InputIterator __last)</a>
<a name="ln656">	{ _M_assign_dispatch(__first, __last, __false_type()); }</a>
<a name="ln657">#else</a>
<a name="ln658">      template&lt;typename _InputIterator&gt;</a>
<a name="ln659">	void</a>
<a name="ln660">	assign(_InputIterator __first, _InputIterator __last)</a>
<a name="ln661">	{</a>
<a name="ln662">	  // Check whether it's an integral type.  If so, it's not an iterator.</a>
<a name="ln663">	  typedef typename std::__is_integer&lt;_InputIterator&gt;::__type _Integral;</a>
<a name="ln664">	  _M_assign_dispatch(__first, __last, _Integral());</a>
<a name="ln665">	}</a>
<a name="ln666">#endif</a>
<a name="ln667"> </a>
<a name="ln668">#if __cplusplus &gt;= 201103L</a>
<a name="ln669">      /**</a>
<a name="ln670">       *  @brief  Assigns an initializer list to a %vector.</a>
<a name="ln671">       *  @param  __l  An initializer_list.</a>
<a name="ln672">       *</a>
<a name="ln673">       *  This function fills a %vector with copies of the elements in the</a>
<a name="ln674">       *  initializer list @a __l.</a>
<a name="ln675">       *</a>
<a name="ln676">       *  Note that the assignment completely changes the %vector and</a>
<a name="ln677">       *  that the resulting %vector's size is the same as the number</a>
<a name="ln678">       *  of elements assigned.</a>
<a name="ln679">       */</a>
<a name="ln680">      void</a>
<a name="ln681">      assign(initializer_list&lt;value_type&gt; __l)</a>
<a name="ln682">      {</a>
<a name="ln683">	this-&gt;_M_assign_aux(__l.begin(), __l.end(),</a>
<a name="ln684">			    random_access_iterator_tag());</a>
<a name="ln685">      }</a>
<a name="ln686">#endif</a>
<a name="ln687"> </a>
<a name="ln688">      /// Get a copy of the memory allocation object.</a>
<a name="ln689">      using _Base::get_allocator;</a>
<a name="ln690"> </a>
<a name="ln691">      // iterators</a>
<a name="ln692">      /**</a>
<a name="ln693">       *  Returns a read/write iterator that points to the first</a>
<a name="ln694">       *  element in the %vector.  Iteration is done in ordinary</a>
<a name="ln695">       *  element order.</a>
<a name="ln696">       */</a>
<a name="ln697">      iterator</a>
<a name="ln698">      begin() _GLIBCXX_NOEXCEPT</a>
<a name="ln699">      { return iterator(this-&gt;_M_impl._M_start); }</a>
<a name="ln700"> </a>
<a name="ln701">      /**</a>
<a name="ln702">       *  Returns a read-only (constant) iterator that points to the</a>
<a name="ln703">       *  first element in the %vector.  Iteration is done in ordinary</a>
<a name="ln704">       *  element order.</a>
<a name="ln705">       */</a>
<a name="ln706">      const_iterator</a>
<a name="ln707">      begin() const _GLIBCXX_NOEXCEPT</a>
<a name="ln708">      { return const_iterator(this-&gt;_M_impl._M_start); }</a>
<a name="ln709"> </a>
<a name="ln710">      /**</a>
<a name="ln711">       *  Returns a read/write iterator that points one past the last</a>
<a name="ln712">       *  element in the %vector.  Iteration is done in ordinary</a>
<a name="ln713">       *  element order.</a>
<a name="ln714">       */</a>
<a name="ln715">      iterator</a>
<a name="ln716">      end() _GLIBCXX_NOEXCEPT</a>
<a name="ln717">      { return iterator(this-&gt;_M_impl._M_finish); }</a>
<a name="ln718"> </a>
<a name="ln719">      /**</a>
<a name="ln720">       *  Returns a read-only (constant) iterator that points one past</a>
<a name="ln721">       *  the last element in the %vector.  Iteration is done in</a>
<a name="ln722">       *  ordinary element order.</a>
<a name="ln723">       */</a>
<a name="ln724">      const_iterator</a>
<a name="ln725">      end() const _GLIBCXX_NOEXCEPT</a>
<a name="ln726">      { return const_iterator(this-&gt;_M_impl._M_finish); }</a>
<a name="ln727"> </a>
<a name="ln728">      /**</a>
<a name="ln729">       *  Returns a read/write reverse iterator that points to the</a>
<a name="ln730">       *  last element in the %vector.  Iteration is done in reverse</a>
<a name="ln731">       *  element order.</a>
<a name="ln732">       */</a>
<a name="ln733">      reverse_iterator</a>
<a name="ln734">      rbegin() _GLIBCXX_NOEXCEPT</a>
<a name="ln735">      { return reverse_iterator(end()); }</a>
<a name="ln736"> </a>
<a name="ln737">      /**</a>
<a name="ln738">       *  Returns a read-only (constant) reverse iterator that points</a>
<a name="ln739">       *  to the last element in the %vector.  Iteration is done in</a>
<a name="ln740">       *  reverse element order.</a>
<a name="ln741">       */</a>
<a name="ln742">      const_reverse_iterator</a>
<a name="ln743">      rbegin() const _GLIBCXX_NOEXCEPT</a>
<a name="ln744">      { return const_reverse_iterator(end()); }</a>
<a name="ln745"> </a>
<a name="ln746">      /**</a>
<a name="ln747">       *  Returns a read/write reverse iterator that points to one</a>
<a name="ln748">       *  before the first element in the %vector.  Iteration is done</a>
<a name="ln749">       *  in reverse element order.</a>
<a name="ln750">       */</a>
<a name="ln751">      reverse_iterator</a>
<a name="ln752">      rend() _GLIBCXX_NOEXCEPT</a>
<a name="ln753">      { return reverse_iterator(begin()); }</a>
<a name="ln754"> </a>
<a name="ln755">      /**</a>
<a name="ln756">       *  Returns a read-only (constant) reverse iterator that points</a>
<a name="ln757">       *  to one before the first element in the %vector.  Iteration</a>
<a name="ln758">       *  is done in reverse element order.</a>
<a name="ln759">       */</a>
<a name="ln760">      const_reverse_iterator</a>
<a name="ln761">      rend() const _GLIBCXX_NOEXCEPT</a>
<a name="ln762">      { return const_reverse_iterator(begin()); }</a>
<a name="ln763"> </a>
<a name="ln764">#if __cplusplus &gt;= 201103L</a>
<a name="ln765">      /**</a>
<a name="ln766">       *  Returns a read-only (constant) iterator that points to the</a>
<a name="ln767">       *  first element in the %vector.  Iteration is done in ordinary</a>
<a name="ln768">       *  element order.</a>
<a name="ln769">       */</a>
<a name="ln770">      const_iterator</a>
<a name="ln771">      cbegin() const noexcept</a>
<a name="ln772">      { return const_iterator(this-&gt;_M_impl._M_start); }</a>
<a name="ln773"> </a>
<a name="ln774">      /**</a>
<a name="ln775">       *  Returns a read-only (constant) iterator that points one past</a>
<a name="ln776">       *  the last element in the %vector.  Iteration is done in</a>
<a name="ln777">       *  ordinary element order.</a>
<a name="ln778">       */</a>
<a name="ln779">      const_iterator</a>
<a name="ln780">      cend() const noexcept</a>
<a name="ln781">      { return const_iterator(this-&gt;_M_impl._M_finish); }</a>
<a name="ln782"> </a>
<a name="ln783">      /**</a>
<a name="ln784">       *  Returns a read-only (constant) reverse iterator that points</a>
<a name="ln785">       *  to the last element in the %vector.  Iteration is done in</a>
<a name="ln786">       *  reverse element order.</a>
<a name="ln787">       */</a>
<a name="ln788">      const_reverse_iterator</a>
<a name="ln789">      crbegin() const noexcept</a>
<a name="ln790">      { return const_reverse_iterator(end()); }</a>
<a name="ln791"> </a>
<a name="ln792">      /**</a>
<a name="ln793">       *  Returns a read-only (constant) reverse iterator that points</a>
<a name="ln794">       *  to one before the first element in the %vector.  Iteration</a>
<a name="ln795">       *  is done in reverse element order.</a>
<a name="ln796">       */</a>
<a name="ln797">      const_reverse_iterator</a>
<a name="ln798">      crend() const noexcept</a>
<a name="ln799">      { return const_reverse_iterator(begin()); }</a>
<a name="ln800">#endif</a>
<a name="ln801"> </a>
<a name="ln802">      // [23.2.4.2] capacity</a>
<a name="ln803">      /**  Returns the number of elements in the %vector.  */</a>
<a name="ln804">      size_type</a>
<a name="ln805">      size() const _GLIBCXX_NOEXCEPT</a>
<a name="ln806">      { return size_type(this-&gt;_M_impl._M_finish - this-&gt;_M_impl._M_start); }</a>
<a name="ln807"> </a>
<a name="ln808">      /**  Returns the size() of the largest possible %vector.  */</a>
<a name="ln809">      size_type</a>
<a name="ln810">      max_size() const _GLIBCXX_NOEXCEPT</a>
<a name="ln811">      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }</a>
<a name="ln812"> </a>
<a name="ln813">#if __cplusplus &gt;= 201103L</a>
<a name="ln814">      /**</a>
<a name="ln815">       *  @brief  Resizes the %vector to the specified number of elements.</a>
<a name="ln816">       *  @param  __new_size  Number of elements the %vector should contain.</a>
<a name="ln817">       *</a>
<a name="ln818">       *  This function will %resize the %vector to the specified</a>
<a name="ln819">       *  number of elements.  If the number is smaller than the</a>
<a name="ln820">       *  %vector's current size the %vector is truncated, otherwise</a>
<a name="ln821">       *  default constructed elements are appended.</a>
<a name="ln822">       */</a>
<a name="ln823">      void</a>
<a name="ln824">      resize(size_type __new_size)</a>
<a name="ln825">      {</a>
<a name="ln826">	if (__new_size &gt; size())</a>
<a name="ln827">	  _M_default_append(__new_size - size());</a>
<a name="ln828">	else if (__new_size &lt; size())</a>
<a name="ln829">	  _M_erase_at_end(this-&gt;_M_impl._M_start + __new_size);</a>
<a name="ln830">      }</a>
<a name="ln831"> </a>
<a name="ln832">      /**</a>
<a name="ln833">       *  @brief  Resizes the %vector to the specified number of elements.</a>
<a name="ln834">       *  @param  __new_size  Number of elements the %vector should contain.</a>
<a name="ln835">       *  @param  __x  Data with which new elements should be populated.</a>
<a name="ln836">       *</a>
<a name="ln837">       *  This function will %resize the %vector to the specified</a>
<a name="ln838">       *  number of elements.  If the number is smaller than the</a>
<a name="ln839">       *  %vector's current size the %vector is truncated, otherwise</a>
<a name="ln840">       *  the %vector is extended and new elements are populated with</a>
<a name="ln841">       *  given data.</a>
<a name="ln842">       */</a>
<a name="ln843">      void</a>
<a name="ln844">      resize(size_type __new_size, const value_type&amp; __x)</a>
<a name="ln845">      {</a>
<a name="ln846">	if (__new_size &gt; size())</a>
<a name="ln847">	  _M_fill_insert(end(), __new_size - size(), __x);</a>
<a name="ln848">	else if (__new_size &lt; size())</a>
<a name="ln849">	  _M_erase_at_end(this-&gt;_M_impl._M_start + __new_size);</a>
<a name="ln850">      }</a>
<a name="ln851">#else</a>
<a name="ln852">      /**</a>
<a name="ln853">       *  @brief  Resizes the %vector to the specified number of elements.</a>
<a name="ln854">       *  @param  __new_size  Number of elements the %vector should contain.</a>
<a name="ln855">       *  @param  __x  Data with which new elements should be populated.</a>
<a name="ln856">       *</a>
<a name="ln857">       *  This function will %resize the %vector to the specified</a>
<a name="ln858">       *  number of elements.  If the number is smaller than the</a>
<a name="ln859">       *  %vector's current size the %vector is truncated, otherwise</a>
<a name="ln860">       *  the %vector is extended and new elements are populated with</a>
<a name="ln861">       *  given data.</a>
<a name="ln862">       */</a>
<a name="ln863">      void</a>
<a name="ln864">      resize(size_type __new_size, value_type __x = value_type())</a>
<a name="ln865">      {</a>
<a name="ln866">	if (__new_size &gt; size())</a>
<a name="ln867">	  _M_fill_insert(end(), __new_size - size(), __x);</a>
<a name="ln868">	else if (__new_size &lt; size())</a>
<a name="ln869">	  _M_erase_at_end(this-&gt;_M_impl._M_start + __new_size);</a>
<a name="ln870">      }</a>
<a name="ln871">#endif</a>
<a name="ln872"> </a>
<a name="ln873">#if __cplusplus &gt;= 201103L</a>
<a name="ln874">      /**  A non-binding request to reduce capacity() to size().  */</a>
<a name="ln875">      void</a>
<a name="ln876">      shrink_to_fit()</a>
<a name="ln877">      { _M_shrink_to_fit(); }</a>
<a name="ln878">#endif</a>
<a name="ln879"> </a>
<a name="ln880">      /**</a>
<a name="ln881">       *  Returns the total number of elements that the %vector can</a>
<a name="ln882">       *  hold before needing to allocate more memory.</a>
<a name="ln883">       */</a>
<a name="ln884">      size_type</a>
<a name="ln885">      capacity() const _GLIBCXX_NOEXCEPT</a>
<a name="ln886">      { return size_type(this-&gt;_M_impl._M_end_of_storage</a>
<a name="ln887">			 - this-&gt;_M_impl._M_start); }</a>
<a name="ln888"> </a>
<a name="ln889">      /**</a>
<a name="ln890">       *  Returns true if the %vector is empty.  (Thus begin() would</a>
<a name="ln891">       *  equal end().)</a>
<a name="ln892">       */</a>
<a name="ln893">      bool</a>
<a name="ln894">      empty() const _GLIBCXX_NOEXCEPT</a>
<a name="ln895">      { return begin() == end(); }</a>
<a name="ln896"> </a>
<a name="ln897">      /**</a>
<a name="ln898">       *  @brief  Attempt to preallocate enough memory for specified number of</a>
<a name="ln899">       *          elements.</a>
<a name="ln900">       *  @param  __n  Number of elements required.</a>
<a name="ln901">       *  @throw  std::length_error  If @a n exceeds @c max_size().</a>
<a name="ln902">       *</a>
<a name="ln903">       *  This function attempts to reserve enough memory for the</a>
<a name="ln904">       *  %vector to hold the specified number of elements.  If the</a>
<a name="ln905">       *  number requested is more than max_size(), length_error is</a>
<a name="ln906">       *  thrown.</a>
<a name="ln907">       *</a>
<a name="ln908">       *  The advantage of this function is that if optimal code is a</a>
<a name="ln909">       *  necessity and the user can determine the number of elements</a>
<a name="ln910">       *  that will be required, the user can reserve the memory in</a>
<a name="ln911">       *  %advance, and thus prevent a possible reallocation of memory</a>
<a name="ln912">       *  and copying of %vector data.</a>
<a name="ln913">       */</a>
<a name="ln914">      void</a>
<a name="ln915">      reserve(size_type __n);</a>
<a name="ln916"> </a>
<a name="ln917">      // element access</a>
<a name="ln918">      /**</a>
<a name="ln919">       *  @brief  Subscript access to the data contained in the %vector.</a>
<a name="ln920">       *  @param __n The index of the element for which data should be</a>
<a name="ln921">       *  accessed.</a>
<a name="ln922">       *  @return  Read/write reference to data.</a>
<a name="ln923">       *</a>
<a name="ln924">       *  This operator allows for easy, array-style, data access.</a>
<a name="ln925">       *  Note that data access with this operator is unchecked and</a>
<a name="ln926">       *  out_of_range lookups are not defined. (For checked lookups</a>
<a name="ln927">       *  see at().)</a>
<a name="ln928">       */</a>
<a name="ln929">      reference</a>
<a name="ln930">      operator[](size_type __n) _GLIBCXX_NOEXCEPT</a>
<a name="ln931">      {</a>
<a name="ln932">	__glibcxx_requires_subscript(__n);</a>
<a name="ln933">	return *(this-&gt;_M_impl._M_start + __n);</a>
<a name="ln934">      }</a>
<a name="ln935"> </a>
<a name="ln936">      /**</a>
<a name="ln937">       *  @brief  Subscript access to the data contained in the %vector.</a>
<a name="ln938">       *  @param __n The index of the element for which data should be</a>
<a name="ln939">       *  accessed.</a>
<a name="ln940">       *  @return  Read-only (constant) reference to data.</a>
<a name="ln941">       *</a>
<a name="ln942">       *  This operator allows for easy, array-style, data access.</a>
<a name="ln943">       *  Note that data access with this operator is unchecked and</a>
<a name="ln944">       *  out_of_range lookups are not defined. (For checked lookups</a>
<a name="ln945">       *  see at().)</a>
<a name="ln946">       */</a>
<a name="ln947">      const_reference</a>
<a name="ln948">      operator[](size_type __n) const _GLIBCXX_NOEXCEPT</a>
<a name="ln949">      {</a>
<a name="ln950">	__glibcxx_requires_subscript(__n);</a>
<a name="ln951">	return *(this-&gt;_M_impl._M_start + __n);</a>
<a name="ln952">      }</a>
<a name="ln953"> </a>
<a name="ln954">    protected:</a>
<a name="ln955">      /// Safety check used only from at().</a>
<a name="ln956">      void</a>
<a name="ln957">      _M_range_check(size_type __n) const</a>
<a name="ln958">      {</a>
<a name="ln959">	if (__n &gt;= this-&gt;size())</a>
<a name="ln960">	  __throw_out_of_range_fmt(__N(&quot;vector::_M_range_check: __n &quot;</a>
<a name="ln961">				       &quot;(which is %zu) &gt;= this-&gt;size() &quot;</a>
<a name="ln962">				       &quot;(which is %zu)&quot;),</a>
<a name="ln963">				   __n, this-&gt;size());</a>
<a name="ln964">      }</a>
<a name="ln965"> </a>
<a name="ln966">    public:</a>
<a name="ln967">      /**</a>
<a name="ln968">       *  @brief  Provides access to the data contained in the %vector.</a>
<a name="ln969">       *  @param __n The index of the element for which data should be</a>
<a name="ln970">       *  accessed.</a>
<a name="ln971">       *  @return  Read/write reference to data.</a>
<a name="ln972">       *  @throw  std::out_of_range  If @a __n is an invalid index.</a>
<a name="ln973">       *</a>
<a name="ln974">       *  This function provides for safer data access.  The parameter</a>
<a name="ln975">       *  is first checked that it is in the range of the vector.  The</a>
<a name="ln976">       *  function throws out_of_range if the check fails.</a>
<a name="ln977">       */</a>
<a name="ln978">      reference</a>
<a name="ln979">      at(size_type __n)</a>
<a name="ln980">      {</a>
<a name="ln981">	_M_range_check(__n);</a>
<a name="ln982">	return (*this)[__n];</a>
<a name="ln983">      }</a>
<a name="ln984"> </a>
<a name="ln985">      /**</a>
<a name="ln986">       *  @brief  Provides access to the data contained in the %vector.</a>
<a name="ln987">       *  @param __n The index of the element for which data should be</a>
<a name="ln988">       *  accessed.</a>
<a name="ln989">       *  @return  Read-only (constant) reference to data.</a>
<a name="ln990">       *  @throw  std::out_of_range  If @a __n is an invalid index.</a>
<a name="ln991">       *</a>
<a name="ln992">       *  This function provides for safer data access.  The parameter</a>
<a name="ln993">       *  is first checked that it is in the range of the vector.  The</a>
<a name="ln994">       *  function throws out_of_range if the check fails.</a>
<a name="ln995">       */</a>
<a name="ln996">      const_reference</a>
<a name="ln997">      at(size_type __n) const</a>
<a name="ln998">      {</a>
<a name="ln999">	_M_range_check(__n);</a>
<a name="ln1000">	return (*this)[__n];</a>
<a name="ln1001">      }</a>
<a name="ln1002"> </a>
<a name="ln1003">      /**</a>
<a name="ln1004">       *  Returns a read/write reference to the data at the first</a>
<a name="ln1005">       *  element of the %vector.</a>
<a name="ln1006">       */</a>
<a name="ln1007">      reference</a>
<a name="ln1008">      front() _GLIBCXX_NOEXCEPT</a>
<a name="ln1009">      {</a>
<a name="ln1010">	__glibcxx_requires_nonempty();</a>
<a name="ln1011">	return *begin();</a>
<a name="ln1012">      }</a>
<a name="ln1013"> </a>
<a name="ln1014">      /**</a>
<a name="ln1015">       *  Returns a read-only (constant) reference to the data at the first</a>
<a name="ln1016">       *  element of the %vector.</a>
<a name="ln1017">       */</a>
<a name="ln1018">      const_reference</a>
<a name="ln1019">      front() const _GLIBCXX_NOEXCEPT</a>
<a name="ln1020">      {</a>
<a name="ln1021">	__glibcxx_requires_nonempty();</a>
<a name="ln1022">	return *begin();</a>
<a name="ln1023">      }</a>
<a name="ln1024"> </a>
<a name="ln1025">      /**</a>
<a name="ln1026">       *  Returns a read/write reference to the data at the last</a>
<a name="ln1027">       *  element of the %vector.</a>
<a name="ln1028">       */</a>
<a name="ln1029">      reference</a>
<a name="ln1030">      back() _GLIBCXX_NOEXCEPT</a>
<a name="ln1031">      {</a>
<a name="ln1032">	__glibcxx_requires_nonempty();</a>
<a name="ln1033">	return *(end() - 1);</a>
<a name="ln1034">      }</a>
<a name="ln1035"> </a>
<a name="ln1036">      /**</a>
<a name="ln1037">       *  Returns a read-only (constant) reference to the data at the</a>
<a name="ln1038">       *  last element of the %vector.</a>
<a name="ln1039">       */</a>
<a name="ln1040">      const_reference</a>
<a name="ln1041">      back() const _GLIBCXX_NOEXCEPT</a>
<a name="ln1042">      {</a>
<a name="ln1043">	__glibcxx_requires_nonempty();</a>
<a name="ln1044">	return *(end() - 1);</a>
<a name="ln1045">      }</a>
<a name="ln1046"> </a>
<a name="ln1047">      // _GLIBCXX_RESOLVE_LIB_DEFECTS</a>
<a name="ln1048">      // DR 464. Suggestion for new member functions in standard containers.</a>
<a name="ln1049">      // data access</a>
<a name="ln1050">      /**</a>
<a name="ln1051">       *   Returns a pointer such that [data(), data() + size()) is a valid</a>
<a name="ln1052">       *   range.  For a non-empty %vector, data() == &amp;front().</a>
<a name="ln1053">       */</a>
<a name="ln1054">      _Tp*</a>
<a name="ln1055">      data() _GLIBCXX_NOEXCEPT</a>
<a name="ln1056">      { return _M_data_ptr(this-&gt;_M_impl._M_start); }</a>
<a name="ln1057"> </a>
<a name="ln1058">      const _Tp*</a>
<a name="ln1059">      data() const _GLIBCXX_NOEXCEPT</a>
<a name="ln1060">      { return _M_data_ptr(this-&gt;_M_impl._M_start); }</a>
<a name="ln1061"> </a>
<a name="ln1062">      // [23.2.4.3] modifiers</a>
<a name="ln1063">      /**</a>
<a name="ln1064">       *  @brief  Add data to the end of the %vector.</a>
<a name="ln1065">       *  @param  __x  Data to be added.</a>
<a name="ln1066">       *</a>
<a name="ln1067">       *  This is a typical stack operation.  The function creates an</a>
<a name="ln1068">       *  element at the end of the %vector and assigns the given data</a>
<a name="ln1069">       *  to it.  Due to the nature of a %vector this operation can be</a>
<a name="ln1070">       *  done in constant time if the %vector has preallocated space</a>
<a name="ln1071">       *  available.</a>
<a name="ln1072">       */</a>
<a name="ln1073">      void</a>
<a name="ln1074">      push_back(const value_type&amp; __x)</a>
<a name="ln1075">      {</a>
<a name="ln1076">	if (this-&gt;_M_impl._M_finish != this-&gt;_M_impl._M_end_of_storage)</a>
<a name="ln1077">	  {</a>
<a name="ln1078">	    _GLIBCXX_ASAN_ANNOTATE_GROW(1);</a>
<a name="ln1079">	    _Alloc_traits::construct(this-&gt;_M_impl, this-&gt;_M_impl._M_finish,</a>
<a name="ln1080">				     __x);</a>
<a name="ln1081">	    ++this-&gt;_M_impl._M_finish;</a>
<a name="ln1082">	    _GLIBCXX_ASAN_ANNOTATE_GREW(1);</a>
<a name="ln1083">	  }</a>
<a name="ln1084">	else</a>
<a name="ln1085">	  _M_realloc_insert(end(), __x);</a>
<a name="ln1086">      }</a>
<a name="ln1087"> </a>
<a name="ln1088">#if __cplusplus &gt;= 201103L</a>
<a name="ln1089">      void</a>
<a name="ln1090">      push_back(value_type&amp;&amp; __x)</a>
<a name="ln1091">      { emplace_back(std::move(__x)); }</a>
<a name="ln1092"> </a>
<a name="ln1093">      template&lt;typename... _Args&gt;</a>
<a name="ln1094">#if __cplusplus &gt; 201402L</a>
<a name="ln1095">	reference</a>
<a name="ln1096">#else</a>
<a name="ln1097">	void</a>
<a name="ln1098">#endif</a>
<a name="ln1099">	emplace_back(_Args&amp;&amp;... __args);</a>
<a name="ln1100">#endif</a>
<a name="ln1101"> </a>
<a name="ln1102">      /**</a>
<a name="ln1103">       *  @brief  Removes last element.</a>
<a name="ln1104">       *</a>
<a name="ln1105">       *  This is a typical stack operation. It shrinks the %vector by one.</a>
<a name="ln1106">       *</a>
<a name="ln1107">       *  Note that no data is returned, and if the last element's</a>
<a name="ln1108">       *  data is needed, it should be retrieved before pop_back() is</a>
<a name="ln1109">       *  called.</a>
<a name="ln1110">       */</a>
<a name="ln1111">      void</a>
<a name="ln1112">      pop_back() _GLIBCXX_NOEXCEPT</a>
<a name="ln1113">      {</a>
<a name="ln1114">	__glibcxx_requires_nonempty();</a>
<a name="ln1115">	--this-&gt;_M_impl._M_finish;</a>
<a name="ln1116">	_Alloc_traits::destroy(this-&gt;_M_impl, this-&gt;_M_impl._M_finish);</a>
<a name="ln1117">	_GLIBCXX_ASAN_ANNOTATE_SHRINK(1);</a>
<a name="ln1118">      }</a>
<a name="ln1119"> </a>
<a name="ln1120">#if __cplusplus &gt;= 201103L</a>
<a name="ln1121">      /**</a>
<a name="ln1122">       *  @brief  Inserts an object in %vector before specified iterator.</a>
<a name="ln1123">       *  @param  __position  A const_iterator into the %vector.</a>
<a name="ln1124">       *  @param  __args  Arguments.</a>
<a name="ln1125">       *  @return  An iterator that points to the inserted data.</a>
<a name="ln1126">       *</a>
<a name="ln1127">       *  This function will insert an object of type T constructed</a>
<a name="ln1128">       *  with T(std::forward&lt;Args&gt;(args)...) before the specified location.</a>
<a name="ln1129">       *  Note that this kind of operation could be expensive for a %vector</a>
<a name="ln1130">       *  and if it is frequently used the user should consider using</a>
<a name="ln1131">       *  std::list.</a>
<a name="ln1132">       */</a>
<a name="ln1133">      template&lt;typename... _Args&gt;</a>
<a name="ln1134">	iterator</a>
<a name="ln1135">	emplace(const_iterator __position, _Args&amp;&amp;... __args)</a>
<a name="ln1136">	{ return _M_emplace_aux(__position, std::forward&lt;_Args&gt;(__args)...); }</a>
<a name="ln1137"> </a>
<a name="ln1138">      /**</a>
<a name="ln1139">       *  @brief  Inserts given value into %vector before specified iterator.</a>
<a name="ln1140">       *  @param  __position  A const_iterator into the %vector.</a>
<a name="ln1141">       *  @param  __x  Data to be inserted.</a>
<a name="ln1142">       *  @return  An iterator that points to the inserted data.</a>
<a name="ln1143">       *</a>
<a name="ln1144">       *  This function will insert a copy of the given value before</a>
<a name="ln1145">       *  the specified location.  Note that this kind of operation</a>
<a name="ln1146">       *  could be expensive for a %vector and if it is frequently</a>
<a name="ln1147">       *  used the user should consider using std::list.</a>
<a name="ln1148">       */</a>
<a name="ln1149">      iterator</a>
<a name="ln1150">      insert(const_iterator __position, const value_type&amp; __x);</a>
<a name="ln1151">#else</a>
<a name="ln1152">      /**</a>
<a name="ln1153">       *  @brief  Inserts given value into %vector before specified iterator.</a>
<a name="ln1154">       *  @param  __position  An iterator into the %vector.</a>
<a name="ln1155">       *  @param  __x  Data to be inserted.</a>
<a name="ln1156">       *  @return  An iterator that points to the inserted data.</a>
<a name="ln1157">       *</a>
<a name="ln1158">       *  This function will insert a copy of the given value before</a>
<a name="ln1159">       *  the specified location.  Note that this kind of operation</a>
<a name="ln1160">       *  could be expensive for a %vector and if it is frequently</a>
<a name="ln1161">       *  used the user should consider using std::list.</a>
<a name="ln1162">       */</a>
<a name="ln1163">      iterator</a>
<a name="ln1164">      insert(iterator __position, const value_type&amp; __x);</a>
<a name="ln1165">#endif</a>
<a name="ln1166"> </a>
<a name="ln1167">#if __cplusplus &gt;= 201103L</a>
<a name="ln1168">      /**</a>
<a name="ln1169">       *  @brief  Inserts given rvalue into %vector before specified iterator.</a>
<a name="ln1170">       *  @param  __position  A const_iterator into the %vector.</a>
<a name="ln1171">       *  @param  __x  Data to be inserted.</a>
<a name="ln1172">       *  @return  An iterator that points to the inserted data.</a>
<a name="ln1173">       *</a>
<a name="ln1174">       *  This function will insert a copy of the given rvalue before</a>
<a name="ln1175">       *  the specified location.  Note that this kind of operation</a>
<a name="ln1176">       *  could be expensive for a %vector and if it is frequently</a>
<a name="ln1177">       *  used the user should consider using std::list.</a>
<a name="ln1178">       */</a>
<a name="ln1179">      iterator</a>
<a name="ln1180">      insert(const_iterator __position, value_type&amp;&amp; __x)</a>
<a name="ln1181">      { return _M_insert_rval(__position, std::move(__x)); }</a>
<a name="ln1182"> </a>
<a name="ln1183">      /**</a>
<a name="ln1184">       *  @brief  Inserts an initializer_list into the %vector.</a>
<a name="ln1185">       *  @param  __position  An iterator into the %vector.</a>
<a name="ln1186">       *  @param  __l  An initializer_list.</a>
<a name="ln1187">       *</a>
<a name="ln1188">       *  This function will insert copies of the data in the</a>
<a name="ln1189">       *  initializer_list @a l into the %vector before the location</a>
<a name="ln1190">       *  specified by @a position.</a>
<a name="ln1191">       *</a>
<a name="ln1192">       *  Note that this kind of operation could be expensive for a</a>
<a name="ln1193">       *  %vector and if it is frequently used the user should</a>
<a name="ln1194">       *  consider using std::list.</a>
<a name="ln1195">       */</a>
<a name="ln1196">      iterator</a>
<a name="ln1197">      insert(const_iterator __position, initializer_list&lt;value_type&gt; __l)</a>
<a name="ln1198">      {</a>
<a name="ln1199">	auto __offset = __position - cbegin();</a>
<a name="ln1200">	_M_range_insert(begin() + __offset, __l.begin(), __l.end(),</a>
<a name="ln1201">			std::random_access_iterator_tag());</a>
<a name="ln1202">	return begin() + __offset;</a>
<a name="ln1203">      }</a>
<a name="ln1204">#endif</a>
<a name="ln1205"> </a>
<a name="ln1206">#if __cplusplus &gt;= 201103L</a>
<a name="ln1207">      /**</a>
<a name="ln1208">       *  @brief  Inserts a number of copies of given data into the %vector.</a>
<a name="ln1209">       *  @param  __position  A const_iterator into the %vector.</a>
<a name="ln1210">       *  @param  __n  Number of elements to be inserted.</a>
<a name="ln1211">       *  @param  __x  Data to be inserted.</a>
<a name="ln1212">       *  @return  An iterator that points to the inserted data.</a>
<a name="ln1213">       *</a>
<a name="ln1214">       *  This function will insert a specified number of copies of</a>
<a name="ln1215">       *  the given data before the location specified by @a position.</a>
<a name="ln1216">       *</a>
<a name="ln1217">       *  Note that this kind of operation could be expensive for a</a>
<a name="ln1218">       *  %vector and if it is frequently used the user should</a>
<a name="ln1219">       *  consider using std::list.</a>
<a name="ln1220">       */</a>
<a name="ln1221">      iterator</a>
<a name="ln1222">      insert(const_iterator __position, size_type __n, const value_type&amp; __x)</a>
<a name="ln1223">      {</a>
<a name="ln1224">	difference_type __offset = __position - cbegin();</a>
<a name="ln1225">	_M_fill_insert(begin() + __offset, __n, __x);</a>
<a name="ln1226">	return begin() + __offset;</a>
<a name="ln1227">      }</a>
<a name="ln1228">#else</a>
<a name="ln1229">      /**</a>
<a name="ln1230">       *  @brief  Inserts a number of copies of given data into the %vector.</a>
<a name="ln1231">       *  @param  __position  An iterator into the %vector.</a>
<a name="ln1232">       *  @param  __n  Number of elements to be inserted.</a>
<a name="ln1233">       *  @param  __x  Data to be inserted.</a>
<a name="ln1234">       *</a>
<a name="ln1235">       *  This function will insert a specified number of copies of</a>
<a name="ln1236">       *  the given data before the location specified by @a position.</a>
<a name="ln1237">       *</a>
<a name="ln1238">       *  Note that this kind of operation could be expensive for a</a>
<a name="ln1239">       *  %vector and if it is frequently used the user should</a>
<a name="ln1240">       *  consider using std::list.</a>
<a name="ln1241">       */</a>
<a name="ln1242">      void</a>
<a name="ln1243">      insert(iterator __position, size_type __n, const value_type&amp; __x)</a>
<a name="ln1244">      { _M_fill_insert(__position, __n, __x); }</a>
<a name="ln1245">#endif</a>
<a name="ln1246"> </a>
<a name="ln1247">#if __cplusplus &gt;= 201103L</a>
<a name="ln1248">      /**</a>
<a name="ln1249">       *  @brief  Inserts a range into the %vector.</a>
<a name="ln1250">       *  @param  __position  A const_iterator into the %vector.</a>
<a name="ln1251">       *  @param  __first  An input iterator.</a>
<a name="ln1252">       *  @param  __last   An input iterator.</a>
<a name="ln1253">       *  @return  An iterator that points to the inserted data.</a>
<a name="ln1254">       *</a>
<a name="ln1255">       *  This function will insert copies of the data in the range</a>
<a name="ln1256">       *  [__first,__last) into the %vector before the location specified</a>
<a name="ln1257">       *  by @a pos.</a>
<a name="ln1258">       *</a>
<a name="ln1259">       *  Note that this kind of operation could be expensive for a</a>
<a name="ln1260">       *  %vector and if it is frequently used the user should</a>
<a name="ln1261">       *  consider using std::list.</a>
<a name="ln1262">       */</a>
<a name="ln1263">      template&lt;typename _InputIterator,</a>
<a name="ln1264">	       typename = std::_RequireInputIter&lt;_InputIterator&gt;&gt;</a>
<a name="ln1265">	iterator</a>
<a name="ln1266">	insert(const_iterator __position, _InputIterator __first,</a>
<a name="ln1267">	       _InputIterator __last)</a>
<a name="ln1268">	{</a>
<a name="ln1269">	  difference_type __offset = __position - cbegin();</a>
<a name="ln1270">	  _M_insert_dispatch(begin() + __offset,</a>
<a name="ln1271">			     __first, __last, __false_type());</a>
<a name="ln1272">	  return begin() + __offset;</a>
<a name="ln1273">	}</a>
<a name="ln1274">#else</a>
<a name="ln1275">      /**</a>
<a name="ln1276">       *  @brief  Inserts a range into the %vector.</a>
<a name="ln1277">       *  @param  __position  An iterator into the %vector.</a>
<a name="ln1278">       *  @param  __first  An input iterator.</a>
<a name="ln1279">       *  @param  __last   An input iterator.</a>
<a name="ln1280">       *</a>
<a name="ln1281">       *  This function will insert copies of the data in the range</a>
<a name="ln1282">       *  [__first,__last) into the %vector before the location specified</a>
<a name="ln1283">       *  by @a pos.</a>
<a name="ln1284">       *</a>
<a name="ln1285">       *  Note that this kind of operation could be expensive for a</a>
<a name="ln1286">       *  %vector and if it is frequently used the user should</a>
<a name="ln1287">       *  consider using std::list.</a>
<a name="ln1288">       */</a>
<a name="ln1289">      template&lt;typename _InputIterator&gt;</a>
<a name="ln1290">	void</a>
<a name="ln1291">	insert(iterator __position, _InputIterator __first,</a>
<a name="ln1292">	       _InputIterator __last)</a>
<a name="ln1293">	{</a>
<a name="ln1294">	  // Check whether it's an integral type.  If so, it's not an iterator.</a>
<a name="ln1295">	  typedef typename std::__is_integer&lt;_InputIterator&gt;::__type _Integral;</a>
<a name="ln1296">	  _M_insert_dispatch(__position, __first, __last, _Integral());</a>
<a name="ln1297">	}</a>
<a name="ln1298">#endif</a>
<a name="ln1299"> </a>
<a name="ln1300">      /**</a>
<a name="ln1301">       *  @brief  Remove element at given position.</a>
<a name="ln1302">       *  @param  __position  Iterator pointing to element to be erased.</a>
<a name="ln1303">       *  @return  An iterator pointing to the next element (or end()).</a>
<a name="ln1304">       *</a>
<a name="ln1305">       *  This function will erase the element at the given position and thus</a>
<a name="ln1306">       *  shorten the %vector by one.</a>
<a name="ln1307">       *</a>
<a name="ln1308">       *  Note This operation could be expensive and if it is</a>
<a name="ln1309">       *  frequently used the user should consider using std::list.</a>
<a name="ln1310">       *  The user is also cautioned that this function only erases</a>
<a name="ln1311">       *  the element, and that if the element is itself a pointer,</a>
<a name="ln1312">       *  the pointed-to memory is not touched in any way.  Managing</a>
<a name="ln1313">       *  the pointer is the user's responsibility.</a>
<a name="ln1314">       */</a>
<a name="ln1315">      iterator</a>
<a name="ln1316">#if __cplusplus &gt;= 201103L</a>
<a name="ln1317">      erase(const_iterator __position)</a>
<a name="ln1318">      { return _M_erase(begin() + (__position - cbegin())); }</a>
<a name="ln1319">#else</a>
<a name="ln1320">      erase(iterator __position)</a>
<a name="ln1321">      { return _M_erase(__position); }</a>
<a name="ln1322">#endif</a>
<a name="ln1323"> </a>
<a name="ln1324">      /**</a>
<a name="ln1325">       *  @brief  Remove a range of elements.</a>
<a name="ln1326">       *  @param  __first  Iterator pointing to the first element to be erased.</a>
<a name="ln1327">       *  @param  __last  Iterator pointing to one past the last element to be</a>
<a name="ln1328">       *                  erased.</a>
<a name="ln1329">       *  @return  An iterator pointing to the element pointed to by @a __last</a>
<a name="ln1330">       *           prior to erasing (or end()).</a>
<a name="ln1331">       *</a>
<a name="ln1332">       *  This function will erase the elements in the range</a>
<a name="ln1333">       *  [__first,__last) and shorten the %vector accordingly.</a>
<a name="ln1334">       *</a>
<a name="ln1335">       *  Note This operation could be expensive and if it is</a>
<a name="ln1336">       *  frequently used the user should consider using std::list.</a>
<a name="ln1337">       *  The user is also cautioned that this function only erases</a>
<a name="ln1338">       *  the elements, and that if the elements themselves are</a>
<a name="ln1339">       *  pointers, the pointed-to memory is not touched in any way.</a>
<a name="ln1340">       *  Managing the pointer is the user's responsibility.</a>
<a name="ln1341">       */</a>
<a name="ln1342">      iterator</a>
<a name="ln1343">#if __cplusplus &gt;= 201103L</a>
<a name="ln1344">      erase(const_iterator __first, const_iterator __last)</a>
<a name="ln1345">      {</a>
<a name="ln1346">	const auto __beg = begin();</a>
<a name="ln1347">	const auto __cbeg = cbegin();</a>
<a name="ln1348">	return _M_erase(__beg + (__first - __cbeg), __beg + (__last - __cbeg));</a>
<a name="ln1349">      }</a>
<a name="ln1350">#else</a>
<a name="ln1351">      erase(iterator __first, iterator __last)</a>
<a name="ln1352">      { return _M_erase(__first, __last); }</a>
<a name="ln1353">#endif</a>
<a name="ln1354"> </a>
<a name="ln1355">      /**</a>
<a name="ln1356">       *  @brief  Swaps data with another %vector.</a>
<a name="ln1357">       *  @param  __x  A %vector of the same element and allocator types.</a>
<a name="ln1358">       *</a>
<a name="ln1359">       *  This exchanges the elements between two vectors in constant time.</a>
<a name="ln1360">       *  (Three pointers, so it should be quite fast.)</a>
<a name="ln1361">       *  Note that the global std::swap() function is specialized such that</a>
<a name="ln1362">       *  std::swap(v1,v2) will feed to this function.</a>
<a name="ln1363">       *</a>
<a name="ln1364">       *  Whether the allocators are swapped depends on the allocator traits.</a>
<a name="ln1365">       */</a>
<a name="ln1366">      void</a>
<a name="ln1367">      swap(vector&amp; __x) _GLIBCXX_NOEXCEPT</a>
<a name="ln1368">      {</a>
<a name="ln1369">#if __cplusplus &gt;= 201103L</a>
<a name="ln1370">	__glibcxx_assert(_Alloc_traits::propagate_on_container_swap::value</a>
<a name="ln1371">			 || _M_get_Tp_allocator() == __x._M_get_Tp_allocator());</a>
<a name="ln1372">#endif</a>
<a name="ln1373">	this-&gt;_M_impl._M_swap_data(__x._M_impl);</a>
<a name="ln1374">	_Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),</a>
<a name="ln1375">				  __x._M_get_Tp_allocator());</a>
<a name="ln1376">      }</a>
<a name="ln1377"> </a>
<a name="ln1378">      /**</a>
<a name="ln1379">       *  Erases all the elements.  Note that this function only erases the</a>
<a name="ln1380">       *  elements, and that if the elements themselves are pointers, the</a>
<a name="ln1381">       *  pointed-to memory is not touched in any way.  Managing the pointer is</a>
<a name="ln1382">       *  the user's responsibility.</a>
<a name="ln1383">       */</a>
<a name="ln1384">      void</a>
<a name="ln1385">      clear() _GLIBCXX_NOEXCEPT</a>
<a name="ln1386">      { _M_erase_at_end(this-&gt;_M_impl._M_start); }</a>
<a name="ln1387"> </a>
<a name="ln1388">    protected:</a>
<a name="ln1389">      /**</a>
<a name="ln1390">       *  Memory expansion handler.  Uses the member allocation function to</a>
<a name="ln1391">       *  obtain @a n bytes of memory, and then copies [first,last) into it.</a>
<a name="ln1392">       */</a>
<a name="ln1393">      template&lt;typename _ForwardIterator&gt;</a>
<a name="ln1394">	pointer</a>
<a name="ln1395">	_M_allocate_and_copy(size_type __n,</a>
<a name="ln1396">			     _ForwardIterator __first, _ForwardIterator __last)</a>
<a name="ln1397">	{</a>
<a name="ln1398">	  pointer __result = this-&gt;_M_allocate(__n);</a>
<a name="ln1399">	  __try</a>
<a name="ln1400">	    {</a>
<a name="ln1401">	      std::__uninitialized_copy_a(__first, __last, __result,</a>
<a name="ln1402">					  _M_get_Tp_allocator());</a>
<a name="ln1403">	      return __result;</a>
<a name="ln1404">	    }</a>
<a name="ln1405">	  __catch(...)</a>
<a name="ln1406">	    {</a>
<a name="ln1407">	      _M_deallocate(__result, __n);</a>
<a name="ln1408">	      __throw_exception_again;</a>
<a name="ln1409">	    }</a>
<a name="ln1410">	}</a>
<a name="ln1411"> </a>
<a name="ln1412"> </a>
<a name="ln1413">      // Internal constructor functions follow.</a>
<a name="ln1414"> </a>
<a name="ln1415">      // Called by the range constructor to implement [23.1.1]/9</a>
<a name="ln1416"> </a>
<a name="ln1417">      // _GLIBCXX_RESOLVE_LIB_DEFECTS</a>
<a name="ln1418">      // 438. Ambiguity in the &quot;do the right thing&quot; clause</a>
<a name="ln1419">      template&lt;typename _Integer&gt;</a>
<a name="ln1420">	void</a>
<a name="ln1421">	_M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)</a>
<a name="ln1422">	{</a>
<a name="ln1423">	  this-&gt;_M_impl._M_start = _M_allocate(static_cast&lt;size_type&gt;(__n));</a>
<a name="ln1424">	  this-&gt;_M_impl._M_end_of_storage =</a>
<a name="ln1425">	    this-&gt;_M_impl._M_start + static_cast&lt;size_type&gt;(__n);</a>
<a name="ln1426">	  _M_fill_initialize(static_cast&lt;size_type&gt;(__n), __value);</a>
<a name="ln1427">	}</a>
<a name="ln1428"> </a>
<a name="ln1429">      // Called by the range constructor to implement [23.1.1]/9</a>
<a name="ln1430">      template&lt;typename _InputIterator&gt;</a>
<a name="ln1431">	void</a>
<a name="ln1432">	_M_initialize_dispatch(_InputIterator __first, _InputIterator __last,</a>
<a name="ln1433">			       __false_type)</a>
<a name="ln1434">	{</a>
<a name="ln1435">	  typedef typename std::iterator_traits&lt;_InputIterator&gt;::</a>
<a name="ln1436">	    iterator_category _IterCategory;</a>
<a name="ln1437">	  _M_range_initialize(__first, __last, _IterCategory());</a>
<a name="ln1438">	}</a>
<a name="ln1439"> </a>
<a name="ln1440">      // Called by the second initialize_dispatch above</a>
<a name="ln1441">      template&lt;typename _InputIterator&gt;</a>
<a name="ln1442">	void</a>
<a name="ln1443">	_M_range_initialize(_InputIterator __first, _InputIterator __last,</a>
<a name="ln1444">			    std::input_iterator_tag)</a>
<a name="ln1445">	{</a>
<a name="ln1446">	  __try {</a>
<a name="ln1447">	    for (; __first != __last; ++__first)</a>
<a name="ln1448">#if __cplusplus &gt;= 201103L</a>
<a name="ln1449">	      emplace_back(*__first);</a>
<a name="ln1450">#else</a>
<a name="ln1451">	      push_back(*__first);</a>
<a name="ln1452">#endif</a>
<a name="ln1453">	  } __catch(...) {</a>
<a name="ln1454">	    clear();</a>
<a name="ln1455">	    __throw_exception_again;</a>
<a name="ln1456">	  }</a>
<a name="ln1457">	}</a>
<a name="ln1458"> </a>
<a name="ln1459">      // Called by the second initialize_dispatch above</a>
<a name="ln1460">      template&lt;typename _ForwardIterator&gt;</a>
<a name="ln1461">	void</a>
<a name="ln1462">	_M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,</a>
<a name="ln1463">			    std::forward_iterator_tag)</a>
<a name="ln1464">	{</a>
<a name="ln1465">	  const size_type __n = std::distance(__first, __last);</a>
<a name="ln1466">	  this-&gt;_M_impl._M_start = this-&gt;_M_allocate(__n);</a>
<a name="ln1467">	  this-&gt;_M_impl._M_end_of_storage = this-&gt;_M_impl._M_start + __n;</a>
<a name="ln1468">	  this-&gt;_M_impl._M_finish =</a>
<a name="ln1469">	    std::__uninitialized_copy_a(__first, __last,</a>
<a name="ln1470">					this-&gt;_M_impl._M_start,</a>
<a name="ln1471">					_M_get_Tp_allocator());</a>
<a name="ln1472">	}</a>
<a name="ln1473"> </a>
<a name="ln1474">      // Called by the first initialize_dispatch above and by the</a>
<a name="ln1475">      // vector(n,value,a) constructor.</a>
<a name="ln1476">      void</a>
<a name="ln1477">      _M_fill_initialize(size_type __n, const value_type&amp; __value)</a>
<a name="ln1478">      {</a>
<a name="ln1479">	this-&gt;_M_impl._M_finish =</a>
<a name="ln1480">	  std::__uninitialized_fill_n_a(this-&gt;_M_impl._M_start, __n, __value,</a>
<a name="ln1481">					_M_get_Tp_allocator());</a>
<a name="ln1482">      }</a>
<a name="ln1483"> </a>
<a name="ln1484">#if __cplusplus &gt;= 201103L</a>
<a name="ln1485">      // Called by the vector(n) constructor.</a>
<a name="ln1486">      void</a>
<a name="ln1487">      _M_default_initialize(size_type __n)</a>
<a name="ln1488">      {</a>
<a name="ln1489">	this-&gt;_M_impl._M_finish =</a>
<a name="ln1490">	  std::__uninitialized_default_n_a(this-&gt;_M_impl._M_start, __n,</a>
<a name="ln1491">					   _M_get_Tp_allocator());</a>
<a name="ln1492">      }</a>
<a name="ln1493">#endif</a>
<a name="ln1494"> </a>
<a name="ln1495">      // Internal assign functions follow.  The *_aux functions do the actual</a>
<a name="ln1496">      // assignment work for the range versions.</a>
<a name="ln1497"> </a>
<a name="ln1498">      // Called by the range assign to implement [23.1.1]/9</a>
<a name="ln1499"> </a>
<a name="ln1500">      // _GLIBCXX_RESOLVE_LIB_DEFECTS</a>
<a name="ln1501">      // 438. Ambiguity in the &quot;do the right thing&quot; clause</a>
<a name="ln1502">      template&lt;typename _Integer&gt;</a>
<a name="ln1503">	void</a>
<a name="ln1504">	_M_assign_dispatch(_Integer __n, _Integer __val, __true_type)</a>
<a name="ln1505">	{ _M_fill_assign(__n, __val); }</a>
<a name="ln1506"> </a>
<a name="ln1507">      // Called by the range assign to implement [23.1.1]/9</a>
<a name="ln1508">      template&lt;typename _InputIterator&gt;</a>
<a name="ln1509">	void</a>
<a name="ln1510">	_M_assign_dispatch(_InputIterator __first, _InputIterator __last,</a>
<a name="ln1511">			   __false_type)</a>
<a name="ln1512">	{ _M_assign_aux(__first, __last, std::__iterator_category(__first)); }</a>
<a name="ln1513"> </a>
<a name="ln1514">      // Called by the second assign_dispatch above</a>
<a name="ln1515">      template&lt;typename _InputIterator&gt;</a>
<a name="ln1516">	void</a>
<a name="ln1517">	_M_assign_aux(_InputIterator __first, _InputIterator __last,</a>
<a name="ln1518">		      std::input_iterator_tag);</a>
<a name="ln1519"> </a>
<a name="ln1520">      // Called by the second assign_dispatch above</a>
<a name="ln1521">      template&lt;typename _ForwardIterator&gt;</a>
<a name="ln1522">	void</a>
<a name="ln1523">	_M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,</a>
<a name="ln1524">		      std::forward_iterator_tag);</a>
<a name="ln1525"> </a>
<a name="ln1526">      // Called by assign(n,t), and the range assign when it turns out</a>
<a name="ln1527">      // to be the same thing.</a>
<a name="ln1528">      void</a>
<a name="ln1529">      _M_fill_assign(size_type __n, const value_type&amp; __val);</a>
<a name="ln1530"> </a>
<a name="ln1531">      // Internal insert functions follow.</a>
<a name="ln1532"> </a>
<a name="ln1533">      // Called by the range insert to implement [23.1.1]/9</a>
<a name="ln1534"> </a>
<a name="ln1535">      // _GLIBCXX_RESOLVE_LIB_DEFECTS</a>
<a name="ln1536">      // 438. Ambiguity in the &quot;do the right thing&quot; clause</a>
<a name="ln1537">      template&lt;typename _Integer&gt;</a>
<a name="ln1538">	void</a>
<a name="ln1539">	_M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,</a>
<a name="ln1540">			   __true_type)</a>
<a name="ln1541">	{ _M_fill_insert(__pos, __n, __val); }</a>
<a name="ln1542"> </a>
<a name="ln1543">      // Called by the range insert to implement [23.1.1]/9</a>
<a name="ln1544">      template&lt;typename _InputIterator&gt;</a>
<a name="ln1545">	void</a>
<a name="ln1546">	_M_insert_dispatch(iterator __pos, _InputIterator __first,</a>
<a name="ln1547">			   _InputIterator __last, __false_type)</a>
<a name="ln1548">	{</a>
<a name="ln1549">	  _M_range_insert(__pos, __first, __last,</a>
<a name="ln1550">			  std::__iterator_category(__first));</a>
<a name="ln1551">	}</a>
<a name="ln1552"> </a>
<a name="ln1553">      // Called by the second insert_dispatch above</a>
<a name="ln1554">      template&lt;typename _InputIterator&gt;</a>
<a name="ln1555">	void</a>
<a name="ln1556">	_M_range_insert(iterator __pos, _InputIterator __first,</a>
<a name="ln1557">			_InputIterator __last, std::input_iterator_tag);</a>
<a name="ln1558"> </a>
<a name="ln1559">      // Called by the second insert_dispatch above</a>
<a name="ln1560">      template&lt;typename _ForwardIterator&gt;</a>
<a name="ln1561">	void</a>
<a name="ln1562">	_M_range_insert(iterator __pos, _ForwardIterator __first,</a>
<a name="ln1563">			_ForwardIterator __last, std::forward_iterator_tag);</a>
<a name="ln1564"> </a>
<a name="ln1565">      // Called by insert(p,n,x), and the range insert when it turns out to be</a>
<a name="ln1566">      // the same thing.</a>
<a name="ln1567">      void</a>
<a name="ln1568">      _M_fill_insert(iterator __pos, size_type __n, const value_type&amp; __x);</a>
<a name="ln1569"> </a>
<a name="ln1570">#if __cplusplus &gt;= 201103L</a>
<a name="ln1571">      // Called by resize(n).</a>
<a name="ln1572">      void</a>
<a name="ln1573">      _M_default_append(size_type __n);</a>
<a name="ln1574"> </a>
<a name="ln1575">      bool</a>
<a name="ln1576">      _M_shrink_to_fit();</a>
<a name="ln1577">#endif</a>
<a name="ln1578"> </a>
<a name="ln1579">#if __cplusplus &lt; 201103L</a>
<a name="ln1580">      // Called by insert(p,x)</a>
<a name="ln1581">      void</a>
<a name="ln1582">      _M_insert_aux(iterator __position, const value_type&amp; __x);</a>
<a name="ln1583"> </a>
<a name="ln1584">      void</a>
<a name="ln1585">      _M_realloc_insert(iterator __position, const value_type&amp; __x);</a>
<a name="ln1586">#else</a>
<a name="ln1587">      // A value_type object constructed with _Alloc_traits::construct()</a>
<a name="ln1588">      // and destroyed with _Alloc_traits::destroy().</a>
<a name="ln1589">      struct _Temporary_value</a>
<a name="ln1590">      {</a>
<a name="ln1591">	template&lt;typename... _Args&gt;</a>
<a name="ln1592">	  explicit</a>
<a name="ln1593">	  _Temporary_value(vector* __vec, _Args&amp;&amp;... __args) : _M_this(__vec)</a>
<a name="ln1594">	  {</a>
<a name="ln1595">	    _Alloc_traits::construct(_M_this-&gt;_M_impl, _M_ptr(),</a>
<a name="ln1596">				     std::forward&lt;_Args&gt;(__args)...);</a>
<a name="ln1597">	  }</a>
<a name="ln1598"> </a>
<a name="ln1599">	~_Temporary_value()</a>
<a name="ln1600">	{ _Alloc_traits::destroy(_M_this-&gt;_M_impl, _M_ptr()); }</a>
<a name="ln1601"> </a>
<a name="ln1602">	value_type&amp;</a>
<a name="ln1603">	_M_val() { return *reinterpret_cast&lt;_Tp*&gt;(&amp;__buf); }</a>
<a name="ln1604"> </a>
<a name="ln1605">      private:</a>
<a name="ln1606">	pointer</a>
<a name="ln1607">	_M_ptr() { return pointer_traits&lt;pointer&gt;::pointer_to(_M_val()); }</a>
<a name="ln1608"> </a>
<a name="ln1609">	vector* _M_this;</a>
<a name="ln1610">	typename aligned_storage&lt;sizeof(_Tp), alignof(_Tp)&gt;::type __buf;</a>
<a name="ln1611">      };</a>
<a name="ln1612"> </a>
<a name="ln1613">      // Called by insert(p,x) and other functions when insertion needs to</a>
<a name="ln1614">      // reallocate or move existing elements. _Arg is either _Tp&amp; or _Tp.</a>
<a name="ln1615">      template&lt;typename _Arg&gt;</a>
<a name="ln1616">	void</a>
<a name="ln1617">	_M_insert_aux(iterator __position, _Arg&amp;&amp; __arg);</a>
<a name="ln1618"> </a>
<a name="ln1619">      template&lt;typename... _Args&gt;</a>
<a name="ln1620">	void</a>
<a name="ln1621">	_M_realloc_insert(iterator __position, _Args&amp;&amp;... __args);</a>
<a name="ln1622"> </a>
<a name="ln1623">      // Either move-construct at the end, or forward to _M_insert_aux.</a>
<a name="ln1624">      iterator</a>
<a name="ln1625">      _M_insert_rval(const_iterator __position, value_type&amp;&amp; __v);</a>
<a name="ln1626"> </a>
<a name="ln1627">      // Try to emplace at the end, otherwise forward to _M_insert_aux.</a>
<a name="ln1628">      template&lt;typename... _Args&gt;</a>
<a name="ln1629">	iterator</a>
<a name="ln1630">	_M_emplace_aux(const_iterator __position, _Args&amp;&amp;... __args);</a>
<a name="ln1631"> </a>
<a name="ln1632">      // Emplacing an rvalue of the correct type can use _M_insert_rval.</a>
<a name="ln1633">      iterator</a>
<a name="ln1634">      _M_emplace_aux(const_iterator __position, value_type&amp;&amp; __v)</a>
<a name="ln1635">      { return _M_insert_rval(__position, std::move(__v)); }</a>
<a name="ln1636">#endif</a>
<a name="ln1637"> </a>
<a name="ln1638">      // Called by _M_fill_insert, _M_insert_aux etc.</a>
<a name="ln1639">      size_type</a>
<a name="ln1640">      _M_check_len(size_type __n, const char* __s) const</a>
<a name="ln1641">      {</a>
<a name="ln1642">	if (max_size() - size() &lt; __n)</a>
<a name="ln1643">	  __throw_length_error(__N(__s));</a>
<a name="ln1644"> </a>
<a name="ln1645">	const size_type __len = size() + std::max(size(), __n);</a>
<a name="ln1646">	return (__len &lt; size() || __len &gt; max_size()) ? max_size() : __len;</a>
<a name="ln1647">      }</a>
<a name="ln1648"> </a>
<a name="ln1649">      // Internal erase functions follow.</a>
<a name="ln1650"> </a>
<a name="ln1651">      // Called by erase(q1,q2), clear(), resize(), _M_fill_assign,</a>
<a name="ln1652">      // _M_assign_aux.</a>
<a name="ln1653">      void</a>
<a name="ln1654">      _M_erase_at_end(pointer __pos) _GLIBCXX_NOEXCEPT</a>
<a name="ln1655">      {</a>
<a name="ln1656">	if (size_type __n = this-&gt;_M_impl._M_finish - __pos)</a>
<a name="ln1657">	  {</a>
<a name="ln1658">	    std::_Destroy(__pos, this-&gt;_M_impl._M_finish,</a>
<a name="ln1659">			  _M_get_Tp_allocator());</a>
<a name="ln1660">	    this-&gt;_M_impl._M_finish = __pos;</a>
<a name="ln1661">	    _GLIBCXX_ASAN_ANNOTATE_SHRINK(__n);</a>
<a name="ln1662">	  }</a>
<a name="ln1663">      }</a>
<a name="ln1664"> </a>
<a name="ln1665">      iterator</a>
<a name="ln1666">      _M_erase(iterator __position);</a>
<a name="ln1667"> </a>
<a name="ln1668">      iterator</a>
<a name="ln1669">      _M_erase(iterator __first, iterator __last);</a>
<a name="ln1670"> </a>
<a name="ln1671">#if __cplusplus &gt;= 201103L</a>
<a name="ln1672">    private:</a>
<a name="ln1673">      // Constant-time move assignment when source object's memory can be</a>
<a name="ln1674">      // moved, either because the source's allocator will move too</a>
<a name="ln1675">      // or because the allocators are equal.</a>
<a name="ln1676">      void</a>
<a name="ln1677">      _M_move_assign(vector&amp;&amp; __x, std::true_type) noexcept</a>
<a name="ln1678">      {</a>
<a name="ln1679">	vector __tmp(get_allocator());</a>
<a name="ln1680">	this-&gt;_M_impl._M_swap_data(__tmp._M_impl);</a>
<a name="ln1681">	this-&gt;_M_impl._M_swap_data(__x._M_impl);</a>
<a name="ln1682">	std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());</a>
<a name="ln1683">      }</a>
<a name="ln1684"> </a>
<a name="ln1685">      // Do move assignment when it might not be possible to move source</a>
<a name="ln1686">      // object's memory, resulting in a linear-time operation.</a>
<a name="ln1687">      void</a>
<a name="ln1688">      _M_move_assign(vector&amp;&amp; __x, std::false_type)</a>
<a name="ln1689">      {</a>
<a name="ln1690">	if (__x._M_get_Tp_allocator() == this-&gt;_M_get_Tp_allocator())</a>
<a name="ln1691">	  _M_move_assign(std::move(__x), std::true_type());</a>
<a name="ln1692">	else</a>
<a name="ln1693">	  {</a>
<a name="ln1694">	    // The rvalue's allocator cannot be moved and is not equal,</a>
<a name="ln1695">	    // so we need to individually move each element.</a>
<a name="ln1696">	    this-&gt;assign(std::__make_move_if_noexcept_iterator(__x.begin()),</a>
<a name="ln1697">			 std::__make_move_if_noexcept_iterator(__x.end()));</a>
<a name="ln1698">	    __x.clear();</a>
<a name="ln1699">	  }</a>
<a name="ln1700">      }</a>
<a name="ln1701">#endif</a>
<a name="ln1702"> </a>
<a name="ln1703">      template&lt;typename _Up&gt;</a>
<a name="ln1704">	_Up*</a>
<a name="ln1705">	_M_data_ptr(_Up* __ptr) const _GLIBCXX_NOEXCEPT</a>
<a name="ln1706">	{ return __ptr; }</a>
<a name="ln1707"> </a>
<a name="ln1708">#if __cplusplus &gt;= 201103L</a>
<a name="ln1709">      template&lt;typename _Ptr&gt;</a>
<a name="ln1710">	typename std::pointer_traits&lt;_Ptr&gt;::element_type*</a>
<a name="ln1711">	_M_data_ptr(_Ptr __ptr) const</a>
<a name="ln1712">	{ return empty() ? nullptr : std::__to_address(__ptr); }</a>
<a name="ln1713">#else</a>
<a name="ln1714">      template&lt;typename _Up&gt;</a>
<a name="ln1715">	_Up*</a>
<a name="ln1716">	_M_data_ptr(_Up* __ptr) _GLIBCXX_NOEXCEPT</a>
<a name="ln1717">	{ return __ptr; }</a>
<a name="ln1718"> </a>
<a name="ln1719">      template&lt;typename _Ptr&gt;</a>
<a name="ln1720">	value_type*</a>
<a name="ln1721">	_M_data_ptr(_Ptr __ptr)</a>
<a name="ln1722">	{ return empty() ? (value_type*)0 : __ptr.operator-&gt;(); }</a>
<a name="ln1723"> </a>
<a name="ln1724">      template&lt;typename _Ptr&gt;</a>
<a name="ln1725">	const value_type*</a>
<a name="ln1726">	_M_data_ptr(_Ptr __ptr) const</a>
<a name="ln1727">	{ return empty() ? (const value_type*)0 : __ptr.operator-&gt;(); }</a>
<a name="ln1728">#endif</a>
<a name="ln1729">    };</a>
<a name="ln1730"> </a>
<a name="ln1731">#if __cpp_deduction_guides &gt;= 201606</a>
<a name="ln1732">  template&lt;typename _InputIterator, typename _ValT</a>
<a name="ln1733">	     = typename iterator_traits&lt;_InputIterator&gt;::value_type,</a>
<a name="ln1734">	   typename _Allocator = allocator&lt;_ValT&gt;,</a>
<a name="ln1735">	   typename = _RequireInputIter&lt;_InputIterator&gt;,</a>
<a name="ln1736">	   typename = _RequireAllocator&lt;_Allocator&gt;&gt;</a>
<a name="ln1737">    vector(_InputIterator, _InputIterator, _Allocator = _Allocator())</a>
<a name="ln1738">      -&gt; vector&lt;_ValT, _Allocator&gt;;</a>
<a name="ln1739">#endif</a>
<a name="ln1740"> </a>
<a name="ln1741">  /**</a>
<a name="ln1742">   *  @brief  Vector equality comparison.</a>
<a name="ln1743">   *  @param  __x  A %vector.</a>
<a name="ln1744">   *  @param  __y  A %vector of the same type as @a __x.</a>
<a name="ln1745">   *  @return  True iff the size and elements of the vectors are equal.</a>
<a name="ln1746">   *</a>
<a name="ln1747">   *  This is an equivalence relation.  It is linear in the size of the</a>
<a name="ln1748">   *  vectors.  Vectors are considered equivalent if their sizes are equal,</a>
<a name="ln1749">   *  and if corresponding elements compare equal.</a>
<a name="ln1750">  */</a>
<a name="ln1751">  template&lt;typename _Tp, typename _Alloc&gt;</a>
<a name="ln1752">    inline bool</a>
<a name="ln1753">    operator==(const vector&lt;_Tp, _Alloc&gt;&amp; __x, const vector&lt;_Tp, _Alloc&gt;&amp; __y)</a>
<a name="ln1754">    { return (__x.size() == __y.size()</a>
<a name="ln1755">	      &amp;&amp; std::equal(__x.begin(), __x.end(), __y.begin())); }</a>
<a name="ln1756"> </a>
<a name="ln1757">  /**</a>
<a name="ln1758">   *  @brief  Vector ordering relation.</a>
<a name="ln1759">   *  @param  __x  A %vector.</a>
<a name="ln1760">   *  @param  __y  A %vector of the same type as @a __x.</a>
<a name="ln1761">   *  @return  True iff @a __x is lexicographically less than @a __y.</a>
<a name="ln1762">   *</a>
<a name="ln1763">   *  This is a total ordering relation.  It is linear in the size of the</a>
<a name="ln1764">   *  vectors.  The elements must be comparable with @c &lt;.</a>
<a name="ln1765">   *</a>
<a name="ln1766">   *  See std::lexicographical_compare() for how the determination is made.</a>
<a name="ln1767">  */</a>
<a name="ln1768">  template&lt;typename _Tp, typename _Alloc&gt;</a>
<a name="ln1769">    inline bool</a>
<a name="ln1770">    operator&lt;(const vector&lt;_Tp, _Alloc&gt;&amp; __x, const vector&lt;_Tp, _Alloc&gt;&amp; __y)</a>
<a name="ln1771">    { return std::lexicographical_compare(__x.begin(), __x.end(),</a>
<a name="ln1772">					  __y.begin(), __y.end()); }</a>
<a name="ln1773"> </a>
<a name="ln1774">  /// Based on operator==</a>
<a name="ln1775">  template&lt;typename _Tp, typename _Alloc&gt;</a>
<a name="ln1776">    inline bool</a>
<a name="ln1777">    operator!=(const vector&lt;_Tp, _Alloc&gt;&amp; __x, const vector&lt;_Tp, _Alloc&gt;&amp; __y)</a>
<a name="ln1778">    { return !(__x == __y); }</a>
<a name="ln1779"> </a>
<a name="ln1780">  /// Based on operator&lt;</a>
<a name="ln1781">  template&lt;typename _Tp, typename _Alloc&gt;</a>
<a name="ln1782">    inline bool</a>
<a name="ln1783">    operator&gt;(const vector&lt;_Tp, _Alloc&gt;&amp; __x, const vector&lt;_Tp, _Alloc&gt;&amp; __y)</a>
<a name="ln1784">    { return __y &lt; __x; }</a>
<a name="ln1785"> </a>
<a name="ln1786">  /// Based on operator&lt;</a>
<a name="ln1787">  template&lt;typename _Tp, typename _Alloc&gt;</a>
<a name="ln1788">    inline bool</a>
<a name="ln1789">    operator&lt;=(const vector&lt;_Tp, _Alloc&gt;&amp; __x, const vector&lt;_Tp, _Alloc&gt;&amp; __y)</a>
<a name="ln1790">    { return !(__y &lt; __x); }</a>
<a name="ln1791"> </a>
<a name="ln1792">  /// Based on operator&lt;</a>
<a name="ln1793">  template&lt;typename _Tp, typename _Alloc&gt;</a>
<a name="ln1794">    inline bool</a>
<a name="ln1795">    operator&gt;=(const vector&lt;_Tp, _Alloc&gt;&amp; __x, const vector&lt;_Tp, _Alloc&gt;&amp; __y)</a>
<a name="ln1796">    { return !(__x &lt; __y); }</a>
<a name="ln1797"> </a>
<a name="ln1798">  /// See std::vector::swap().</a>
<a name="ln1799">  template&lt;typename _Tp, typename _Alloc&gt;</a>
<a name="ln1800">    inline void</a>
<a name="ln1801">    swap(vector&lt;_Tp, _Alloc&gt;&amp; __x, vector&lt;_Tp, _Alloc&gt;&amp; __y)</a>
<a name="ln1802">    _GLIBCXX_NOEXCEPT_IF(noexcept(__x.swap(__y)))</a>
<a name="ln1803">    { __x.swap(__y); }</a>
<a name="ln1804"> </a>
<a name="ln1805">_GLIBCXX_END_NAMESPACE_CONTAINER</a>
<a name="ln1806">_GLIBCXX_END_NAMESPACE_VERSION</a>
<a name="ln1807">} // namespace std</a>
<a name="ln1808"> </a>
<a name="ln1809">#endif /* _STL_VECTOR_H */</a>

</code></pre>
<div class="balloon" rel="1603"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v580/" target="_blank">V580</a> Instantiation of std::vector < execution_context::service * >: An odd explicit type casting: reinterpret_cast< _Tp * > (& __buf). Consider verifying it.</p></div>
<div class="balloon" rel="1603"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v580/" target="_blank">V580</a> Instantiation of std::vector < PType * >: An odd explicit type casting: reinterpret_cast< _Tp * > (& __buf). Consider verifying it.</p></div>
<div class="balloon" rel="1603"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v580/" target="_blank">V580</a> Instantiation of std::vector < RemoteTabletServer * >: An odd explicit type casting: reinterpret_cast< _Tp * > (& __buf). Consider verifying it.</p></div>
<div class="balloon" rel="1603"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v580/" target="_blank">V580</a> Instantiation of std::vector < const TabletId * >: An odd explicit type casting: reinterpret_cast< _Tp * > (& __buf). Consider verifying it.</p></div>
<div class="balloon" rel="1603"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v580/" target="_blank">V580</a> Instantiation of std::vector < T * >: An odd explicit type casting: reinterpret_cast< _Tp * > (& __buf). Consider verifying it.</p></div>
<div class="balloon" rel="1603"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v580/" target="_blank">V580</a> Instantiation of vector < char * >: An odd explicit type casting: reinterpret_cast< _Tp * > (& __buf). Consider verifying it.</p></div>
<div class="balloon" rel="1603"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v580/" target="_blank">V580</a> Instantiation of std::vector < const ImmutableCFOptions * >: An odd explicit type casting: reinterpret_cast< _Tp * > (& __buf). Consider verifying it.</p></div>
<div class="balloon" rel="1603"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v580/" target="_blank">V580</a> Instantiation of std::vector < ColumnFamilyHandle * >: An odd explicit type casting: reinterpret_cast< _Tp * > (& __buf). Consider verifying it.</p></div>
<div class="balloon" rel="1603"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v580/" target="_blank">V580</a> Instantiation of std::vector < InternalIterator * >: An odd explicit type casting: reinterpret_cast< _Tp * > (& __buf). Consider verifying it.</p></div>
<div class="balloon" rel="1603"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v580/" target="_blank">V580</a> Instantiation of std::vector < VersionEdit * >: An odd explicit type casting: reinterpret_cast< _Tp * > (& __buf). Consider verifying it.</p></div>
<div class="balloon" rel="1603"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v580/" target="_blank">V580</a> Instantiation of std::vector < PrefixRecord * >: An odd explicit type casting: reinterpret_cast< _Tp * > (& __buf). Consider verifying it.</p></div>
<div class="balloon" rel="1603"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v580/" target="_blank">V580</a> Instantiation of std::vector < SanityTest * >: An odd explicit type casting: reinterpret_cast< _Tp * > (& __buf). Consider verifying it.</p></div>
<div class="balloon" rel="1603"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v580/" target="_blank">V580</a> Instantiation of std::vector < Iterator * >: An odd explicit type casting: reinterpret_cast< _Tp * > (& __buf). Consider verifying it.</p></div>
<div class="balloon" rel="1603"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v580/" target="_blank">V580</a> Instantiation of std::vector < ThreadState * >: An odd explicit type casting: reinterpret_cast< _Tp * > (& __buf). Consider verifying it.</p></div>
<div class="balloon" rel="1603"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v580/" target="_blank">V580</a> Instantiation of vector < const FieldDescriptor * >: An odd explicit type casting: reinterpret_cast< _Tp * > (& __buf). Consider verifying it.</p></div>
<div class="balloon" rel="1603"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v580/" target="_blank">V580</a> Instantiation of std::vector < const Message * >: An odd explicit type casting: reinterpret_cast< _Tp * > (& __buf). Consider verifying it.</p></div>
<div class="balloon" rel="1603"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v580/" target="_blank">V580</a> Instantiation of std::vector < PriorityThreadPoolWorker * >: An odd explicit type casting: reinterpret_cast< _Tp * > (& __buf). Consider verifying it.</p></div>
<div class="balloon" rel="1603"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v580/" target="_blank">V580</a> Instantiation of vector < const ThreadCategory * >: An odd explicit type casting: reinterpret_cast< _Tp * > (& __buf). Consider verifying it.</p></div>
<div class="balloon" rel="1603"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v580/" target="_blank">V580</a> Instantiation of vector < TraceEntry * >: An odd explicit type casting: reinterpret_cast< _Tp * > (& __buf). Consider verifying it.</p></div>
<div class="balloon" rel="1603"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v580/" target="_blank">V580</a> Instantiation of std::vector < ExecContext * >: An odd explicit type casting: reinterpret_cast< _Tp * > (& __buf). Consider verifying it.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
