
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>db_test_util.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Copyright (c) 2011-present, Facebook, Inc.  All rights reserved.</a>
<a name="ln2">// This source code is licensed under the BSD-style license found in the</a>
<a name="ln3">// LICENSE file in the root directory of this source tree. An additional grant</a>
<a name="ln4">// of patent rights can be found in the PATENTS file in the same directory.</a>
<a name="ln5">//</a>
<a name="ln6">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln7">//</a>
<a name="ln8">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln9">//</a>
<a name="ln10">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln11">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln12">//</a>
<a name="ln13">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln14">//</a>
<a name="ln15">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln16">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln17">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln18">// under the License.</a>
<a name="ln19">//</a>
<a name="ln20">// Copyright (c) 2011 The LevelDB Authors. All rights reserved.</a>
<a name="ln21">// Use of this source code is governed by a BSD-style license that can be</a>
<a name="ln22">// found in the LICENSE file. See the AUTHORS file for names of contributors.</a>
<a name="ln23"> </a>
<a name="ln24">#include &quot;yb/rocksdb/db/db_test_util.h&quot;</a>
<a name="ln25"> </a>
<a name="ln26">#include &quot;yb/util/encryption_util.h&quot;</a>
<a name="ln27">#include &quot;yb/util/random_util.h&quot;</a>
<a name="ln28">#include &quot;yb/util/header_manager_impl.h&quot;</a>
<a name="ln29">#include &quot;yb/util/universe_key_manager.h&quot;</a>
<a name="ln30">#include &quot;yb/rocksutil/rocksdb_encrypted_file_factory.h&quot;</a>
<a name="ln31"> </a>
<a name="ln32">namespace rocksdb {</a>
<a name="ln33"> </a>
<a name="ln34">// Special Env used to delay background operations</a>
<a name="ln35"> </a>
<a name="ln36">SpecialEnv::SpecialEnv(Env* base)</a>
<a name="ln37">    : EnvWrapper(base),</a>
<a name="ln38">      rnd_(301),</a>
<a name="ln39">      sleep_counter_(this),</a>
<a name="ln40">      addon_time_(0),</a>
<a name="ln41">      time_elapse_only_sleep_(false),</a>
<a name="ln42">      no_sleep_(false) {</a>
<a name="ln43">  delay_sstable_sync_.store(false, std::memory_order_release);</a>
<a name="ln44">  drop_writes_.store(false, std::memory_order_release);</a>
<a name="ln45">  no_space_.store(false, std::memory_order_release);</a>
<a name="ln46">  non_writable_.store(false, std::memory_order_release);</a>
<a name="ln47">  count_random_reads_ = false;</a>
<a name="ln48">  count_sequential_reads_ = false;</a>
<a name="ln49">  manifest_sync_error_.store(false, std::memory_order_release);</a>
<a name="ln50">  manifest_write_error_.store(false, std::memory_order_release);</a>
<a name="ln51">  log_write_error_.store(false, std::memory_order_release);</a>
<a name="ln52">  random_file_open_counter_.store(0, std::memory_order_relaxed);</a>
<a name="ln53">  log_write_slowdown_ = 0;</a>
<a name="ln54">  bytes_written_ = 0;</a>
<a name="ln55">  sync_counter_ = 0;</a>
<a name="ln56">  non_writeable_rate_ = 0;</a>
<a name="ln57">  new_writable_count_ = 0;</a>
<a name="ln58">  non_writable_count_ = 0;</a>
<a name="ln59">  table_write_callback_ = nullptr;</a>
<a name="ln60">}</a>
<a name="ln61"> </a>
<a name="ln62">const string DBTestBase::kKeyId = &quot;key_id&quot;;</a>
<a name="ln63">const string DBTestBase::kKeyFile = &quot;universe_key_file&quot;;</a>
<a name="ln64"> </a>
<a name="ln65">DBTestBase::DBTestBase(const std::string path, bool encryption_enabled)</a>
<a name="ln66">    : option_config_(kDefault),</a>
<a name="ln67">      mem_env_(!getenv(&quot;MEM_ENV&quot;) ? nullptr : new MockEnv(Env::Default())),</a>
<a name="ln68">      env_(new SpecialEnv(mem_env_ ? mem_env_ : Env::Default())) {</a>
<a name="ln69">  if (encryption_enabled) {</a>
<a name="ln70">    CreateEncryptedEnv();</a>
<a name="ln71">  }</a>
<a name="ln72">  env_-&gt;SetBackgroundThreads(1, Env::LOW);</a>
<a name="ln73">  env_-&gt;SetBackgroundThreads(1, Env::HIGH);</a>
<a name="ln74">  dbname_ = test::TmpDir(env_) + path;</a>
<a name="ln75">  alternative_wal_dir_ = dbname_ + &quot;/wal&quot;;</a>
<a name="ln76">  alternative_db_log_dir_ = dbname_ + &quot;/db_log_dir&quot;;</a>
<a name="ln77">  auto options = CurrentOptions();</a>
<a name="ln78">  auto delete_options = options;</a>
<a name="ln79">  delete_options.wal_dir = alternative_wal_dir_;</a>
<a name="ln80">  WARN_NOT_OK(DestroyDB(dbname_, delete_options), &quot;Cleanup failed &quot; + dbname_);</a>
<a name="ln81">  // Destroy it for not alternative WAL dir is used.</a>
<a name="ln82">  WARN_NOT_OK(DestroyDB(dbname_, options), &quot;Cleanup failed &quot; + dbname_);</a>
<a name="ln83">  db_ = nullptr;</a>
<a name="ln84">  Reopen(options);</a>
<a name="ln85">  Random::GetTLSInstance()-&gt;Reset(0xdeadbeef);</a>
<a name="ln86">}</a>
<a name="ln87"> </a>
<a name="ln88">DBTestBase::~DBTestBase() {</a>
<a name="ln89">  Env::Default()-&gt;CleanupFile(kKeyFile);</a>
<a name="ln90">  rocksdb::SyncPoint::GetInstance()-&gt;DisableProcessing();</a>
<a name="ln91">  rocksdb::SyncPoint::GetInstance()-&gt;LoadDependency({});</a>
<a name="ln92">  rocksdb::SyncPoint::GetInstance()-&gt;ClearAllCallBacks();</a>
<a name="ln93">  Close();</a>
<a name="ln94">  Options options;</a>
<a name="ln95">  options.db_paths.emplace_back(dbname_, 0);</a>
<a name="ln96">  options.db_paths.emplace_back(dbname_ + &quot;_2&quot;, 0);</a>
<a name="ln97">  options.db_paths.emplace_back(dbname_ + &quot;_3&quot;, 0);</a>
<a name="ln98">  options.db_paths.emplace_back(dbname_ + &quot;_4&quot;, 0);</a>
<a name="ln99">  EXPECT_OK(DestroyDB(dbname_, options));</a>
<a name="ln100">  delete env_;</a>
<a name="ln101">}</a>
<a name="ln102"> </a>
<a name="ln103">void DBTestBase::CreateEncryptedEnv() {</a>
<a name="ln104">  auto bytes = yb::RandomBytes(32);</a>
<a name="ln105">  yb::Slice key(bytes.data(), bytes.size());</a>
<a name="ln106">  auto status = yb::WriteStringToFile(yb::Env::Default(), key, kKeyFile);</a>
<a name="ln107">  if (!status.ok()) {</a>
<a name="ln108">    LOG(FATAL) &lt;&lt; &quot;Could not write slice to file:&quot; &lt;&lt; status.ToString();</a>
<a name="ln109">  }</a>
<a name="ln110"> </a>
<a name="ln111">  auto res = yb::enterprise::UniverseKeyManager::FromKey(kKeyId, key);</a>
<a name="ln112">  if (!res.ok()) {</a>
<a name="ln113">    LOG(FATAL) &lt;&lt; &quot;Could not get key from bytes:&quot; &lt;&lt; res.status().ToString();</a>
<a name="ln114">  }</a>
<a name="ln115">  universe_key_manager_ = std::move(*res);</a>
<a name="ln116">  encrypted_env_ = yb::enterprise::NewRocksDBEncryptedEnv(</a>
<a name="ln117">      yb::enterprise::DefaultHeaderManager(universe_key_manager_.get()));</a>
<a name="ln118">  delete env_;</a>
<a name="ln119">  env_ = new rocksdb::SpecialEnv(encrypted_env_.get());</a>
<a name="ln120">}</a>
<a name="ln121"> </a>
<a name="ln122">bool DBTestBase::ShouldSkipOptions(int option_config, int skip_mask) {</a>
<a name="ln123">#ifdef ROCKSDB_LITE</a>
<a name="ln124">    // These options are not supported in ROCKSDB_LITE</a>
<a name="ln125">  if (option_config == kHashSkipList ||</a>
<a name="ln126">      option_config == kPlainTableFirstBytePrefix ||</a>
<a name="ln127">      option_config == kPlainTableCappedPrefix ||</a>
<a name="ln128">      option_config == kPlainTableCappedPrefixNonMmap ||</a>
<a name="ln129">      option_config == kPlainTableAllBytesPrefix ||</a>
<a name="ln130">      option_config == kVectorRep || option_config == kHashLinkList ||</a>
<a name="ln131">      option_config == kUniversalCompaction ||</a>
<a name="ln132">      option_config == kUniversalCompactionMultiLevel ||</a>
<a name="ln133">      option_config == kUniversalSubcompactions ||</a>
<a name="ln134">      option_config == kFIFOCompaction ||</a>
<a name="ln135">      option_config == kConcurrentSkipList) {</a>
<a name="ln136">    return true;</a>
<a name="ln137">    }</a>
<a name="ln138">#endif</a>
<a name="ln139"> </a>
<a name="ln140">    if ((skip_mask &amp; kSkipDeletesFilterFirst) &amp;&amp;</a>
<a name="ln141">        option_config == kDeletesFilterFirst) {</a>
<a name="ln142">      return true;</a>
<a name="ln143">    }</a>
<a name="ln144">    if ((skip_mask &amp; kSkipUniversalCompaction) &amp;&amp;</a>
<a name="ln145">        (option_config == kUniversalCompaction ||</a>
<a name="ln146">         option_config == kUniversalCompactionMultiLevel)) {</a>
<a name="ln147">      return true;</a>
<a name="ln148">    }</a>
<a name="ln149">    if ((skip_mask &amp; kSkipMergePut) &amp;&amp; option_config == kMergePut) {</a>
<a name="ln150">      return true;</a>
<a name="ln151">    }</a>
<a name="ln152">    if ((skip_mask &amp; kSkipNoSeekToLast) &amp;&amp;</a>
<a name="ln153">        (option_config == kHashLinkList || option_config == kHashSkipList)) {</a>
<a name="ln154">      return true;</a>
<a name="ln155">    }</a>
<a name="ln156">    if ((skip_mask &amp; kSkipPlainTable) &amp;&amp;</a>
<a name="ln157">        (option_config == kPlainTableAllBytesPrefix ||</a>
<a name="ln158">         option_config == kPlainTableFirstBytePrefix ||</a>
<a name="ln159">         option_config == kPlainTableCappedPrefix ||</a>
<a name="ln160">         option_config == kPlainTableCappedPrefixNonMmap)) {</a>
<a name="ln161">      return true;</a>
<a name="ln162">    }</a>
<a name="ln163">    if ((skip_mask &amp; kSkipHashIndex) &amp;&amp;</a>
<a name="ln164">        (option_config == kBlockBasedTableWithPrefixHashIndex ||</a>
<a name="ln165">         option_config == kBlockBasedTableWithWholeKeyHashIndex)) {</a>
<a name="ln166">      return true;</a>
<a name="ln167">    }</a>
<a name="ln168">    if ((skip_mask &amp; kSkipFIFOCompaction) &amp;&amp; option_config == kFIFOCompaction) {</a>
<a name="ln169">      return true;</a>
<a name="ln170">    }</a>
<a name="ln171">    if ((skip_mask &amp; kSkipMmapReads) &amp;&amp; option_config == kWalDirAndMmapReads) {</a>
<a name="ln172">      return true;</a>
<a name="ln173">    }</a>
<a name="ln174">    return false;</a>
<a name="ln175">}</a>
<a name="ln176"> </a>
<a name="ln177">// Switch to a fresh database with the next option configuration to</a>
<a name="ln178">// test.  Return false if there are no more configurations to test.</a>
<a name="ln179">bool DBTestBase::ChangeOptions(int skip_mask) {</a>
<a name="ln180">  for (option_config_++; option_config_ &lt; kEnd; option_config_++) {</a>
<a name="ln181">    if (ShouldSkipOptions(option_config_, skip_mask)) {</a>
<a name="ln182">      continue;</a>
<a name="ln183">    }</a>
<a name="ln184">    break;</a>
<a name="ln185">  }</a>
<a name="ln186"> </a>
<a name="ln187">  if (option_config_ &gt;= kEnd) {</a>
<a name="ln188">    Destroy(last_options_);</a>
<a name="ln189">    return false;</a>
<a name="ln190">  } else {</a>
<a name="ln191">    auto options = CurrentOptions();</a>
<a name="ln192">    options.create_if_missing = true;</a>
<a name="ln193">    DestroyAndReopen(options);</a>
<a name="ln194">    return true;</a>
<a name="ln195">  }</a>
<a name="ln196">}</a>
<a name="ln197"> </a>
<a name="ln198">// Switch between different compaction styles.</a>
<a name="ln199">bool DBTestBase::ChangeCompactOptions() {</a>
<a name="ln200">  if (option_config_ == kDefault) {</a>
<a name="ln201">    option_config_ = kUniversalCompaction;</a>
<a name="ln202">    Destroy(last_options_);</a>
<a name="ln203">    auto options = CurrentOptions();</a>
<a name="ln204">    options.create_if_missing = true;</a>
<a name="ln205">    CHECK_OK(TryReopen(options));</a>
<a name="ln206">    return true;</a>
<a name="ln207">  } else if (option_config_ == kUniversalCompaction) {</a>
<a name="ln208">    option_config_ = kUniversalCompactionMultiLevel;</a>
<a name="ln209">    Destroy(last_options_);</a>
<a name="ln210">    auto options = CurrentOptions();</a>
<a name="ln211">    options.create_if_missing = true;</a>
<a name="ln212">    CHECK_OK(TryReopen(options));</a>
<a name="ln213">    return true;</a>
<a name="ln214">  } else if (option_config_ == kUniversalCompactionMultiLevel) {</a>
<a name="ln215">    option_config_ = kLevelSubcompactions;</a>
<a name="ln216">    Destroy(last_options_);</a>
<a name="ln217">    auto options = CurrentOptions();</a>
<a name="ln218">    assert(options.max_subcompactions &gt; 1);</a>
<a name="ln219">    CHECK_OK(TryReopen(options));</a>
<a name="ln220">    return true;</a>
<a name="ln221">  } else if (option_config_ == kLevelSubcompactions) {</a>
<a name="ln222">    option_config_ = kUniversalSubcompactions;</a>
<a name="ln223">    Destroy(last_options_);</a>
<a name="ln224">    auto options = CurrentOptions();</a>
<a name="ln225">    assert(options.max_subcompactions &gt; 1);</a>
<a name="ln226">    CHECK_OK(TryReopen(options));</a>
<a name="ln227">    return true;</a>
<a name="ln228">  } else {</a>
<a name="ln229">    return false;</a>
<a name="ln230">  }</a>
<a name="ln231">}</a>
<a name="ln232"> </a>
<a name="ln233">// Switch between different filter policy</a>
<a name="ln234">// Jump from kDefault to kFilter to kFullFilter</a>
<a name="ln235">bool DBTestBase::ChangeFilterOptions() {</a>
<a name="ln236">  if (option_config_ == kDefault) {</a>
<a name="ln237">    option_config_ = kFilter;</a>
<a name="ln238">  } else if (option_config_ == kFilter) {</a>
<a name="ln239">    option_config_ = kFullFilterWithNewTableReaderForCompactions;</a>
<a name="ln240">  } else {</a>
<a name="ln241">    return false;</a>
<a name="ln242">  }</a>
<a name="ln243">  Destroy(last_options_);</a>
<a name="ln244"> </a>
<a name="ln245">  auto options = CurrentOptions();</a>
<a name="ln246">  options.create_if_missing = true;</a>
<a name="ln247">  CHECK_OK(TryReopen(options));</a>
<a name="ln248">  return true;</a>
<a name="ln249">}</a>
<a name="ln250"> </a>
<a name="ln251">// Return the current option configuration.</a>
<a name="ln252">Options DBTestBase::CurrentOptions(</a>
<a name="ln253">    const anon::OptionsOverride&amp; options_override) {</a>
<a name="ln254">  Options options;</a>
<a name="ln255">  options.write_buffer_size = 4090 * 4096;</a>
<a name="ln256">  return CurrentOptions(options, options_override);</a>
<a name="ln257">}</a>
<a name="ln258"> </a>
<a name="ln259">Options DBTestBase::CurrentOptions(</a>
<a name="ln260">    const Options&amp; defaultOptions,</a>
<a name="ln261">    const anon::OptionsOverride&amp; options_override) {</a>
<a name="ln262">  // this redundant copy is to minimize code change w/o having lint error.</a>
<a name="ln263">  Options options = defaultOptions;</a>
<a name="ln264">  XFUNC_TEST(&quot;&quot;, &quot;dbtest_options&quot;, inplace_options1, GetXFTestOptions,</a>
<a name="ln265">             reinterpret_cast&lt;Options*&gt;(&amp;options),</a>
<a name="ln266">             options_override.skip_policy);</a>
<a name="ln267">  BlockBasedTableOptions table_options;</a>
<a name="ln268">  bool set_block_based_table_factory = true;</a>
<a name="ln269">  switch (option_config_) {</a>
<a name="ln270">#ifndef ROCKSDB_LITE</a>
<a name="ln271">    case kHashSkipList:</a>
<a name="ln272">      options.prefix_extractor.reset(NewFixedPrefixTransform(1));</a>
<a name="ln273">      options.memtable_factory.reset(NewHashSkipListRepFactory(16));</a>
<a name="ln274">      break;</a>
<a name="ln275">    case kPlainTableFirstBytePrefix:</a>
<a name="ln276">      options.table_factory.reset(new PlainTableFactory());</a>
<a name="ln277">      options.prefix_extractor.reset(NewFixedPrefixTransform(1));</a>
<a name="ln278">      options.allow_mmap_reads = true;</a>
<a name="ln279">      options.max_sequential_skip_in_iterations = 999999;</a>
<a name="ln280">      set_block_based_table_factory = false;</a>
<a name="ln281">      break;</a>
<a name="ln282">    case kPlainTableCappedPrefix:</a>
<a name="ln283">      options.table_factory.reset(new PlainTableFactory());</a>
<a name="ln284">      options.prefix_extractor.reset(NewCappedPrefixTransform(8));</a>
<a name="ln285">      options.allow_mmap_reads = true;</a>
<a name="ln286">      options.max_sequential_skip_in_iterations = 999999;</a>
<a name="ln287">      set_block_based_table_factory = false;</a>
<a name="ln288">      break;</a>
<a name="ln289">    case kPlainTableCappedPrefixNonMmap:</a>
<a name="ln290">      options.table_factory.reset(new PlainTableFactory());</a>
<a name="ln291">      options.prefix_extractor.reset(NewCappedPrefixTransform(8));</a>
<a name="ln292">      options.allow_mmap_reads = false;</a>
<a name="ln293">      options.max_sequential_skip_in_iterations = 999999;</a>
<a name="ln294">      set_block_based_table_factory = false;</a>
<a name="ln295">      break;</a>
<a name="ln296">    case kPlainTableAllBytesPrefix:</a>
<a name="ln297">      options.table_factory.reset(new PlainTableFactory());</a>
<a name="ln298">      options.prefix_extractor.reset(NewNoopTransform());</a>
<a name="ln299">      options.allow_mmap_reads = true;</a>
<a name="ln300">      options.max_sequential_skip_in_iterations = 999999;</a>
<a name="ln301">      set_block_based_table_factory = false;</a>
<a name="ln302">      break;</a>
<a name="ln303">    case kVectorRep:</a>
<a name="ln304">      options.memtable_factory.reset(new VectorRepFactory(100));</a>
<a name="ln305">      break;</a>
<a name="ln306">    case kHashLinkList:</a>
<a name="ln307">      options.prefix_extractor.reset(NewFixedPrefixTransform(1));</a>
<a name="ln308">      options.memtable_factory.reset(</a>
<a name="ln309">          NewHashLinkListRepFactory(4, 0, 3, true, 4));</a>
<a name="ln310">      break;</a>
<a name="ln311">#endif  // ROCKSDB_LITE</a>
<a name="ln312">    case kMergePut:</a>
<a name="ln313">      options.merge_operator = MergeOperators::CreatePutOperator();</a>
<a name="ln314">      break;</a>
<a name="ln315">    case kFilter:</a>
<a name="ln316">      table_options.filter_policy.reset(NewBloomFilterPolicy(10, true));</a>
<a name="ln317">      break;</a>
<a name="ln318">    case kFullFilterWithNewTableReaderForCompactions:</a>
<a name="ln319">      table_options.filter_policy.reset(NewBloomFilterPolicy(10, false));</a>
<a name="ln320">      options.new_table_reader_for_compaction_inputs = true;</a>
<a name="ln321">      options.compaction_readahead_size = 10 * 1024 * 1024;</a>
<a name="ln322">      break;</a>
<a name="ln323">    case kUncompressed:</a>
<a name="ln324">      options.compression = kNoCompression;</a>
<a name="ln325">      break;</a>
<a name="ln326">    case kNumLevel_3:</a>
<a name="ln327">      options.num_levels = 3;</a>
<a name="ln328">      break;</a>
<a name="ln329">    case kDBLogDir:</a>
<a name="ln330">      options.db_log_dir = alternative_db_log_dir_;</a>
<a name="ln331">      break;</a>
<a name="ln332">    case kWalDirAndMmapReads:</a>
<a name="ln333">      options.wal_dir = alternative_wal_dir_;</a>
<a name="ln334">      // mmap reads should be orthogonal to WalDir setting, so we piggyback to</a>
<a name="ln335">      // this option config to test mmap reads as well</a>
<a name="ln336">      options.allow_mmap_reads = true;</a>
<a name="ln337">      break;</a>
<a name="ln338">    case kManifestFileSize:</a>
<a name="ln339">      options.max_manifest_file_size = 50;  // 50 bytes</a>
<a name="ln340">      // YugaByte change: the break statement was missing here in RocksDB before we made implicit</a>
<a name="ln341">      // fallthrough an error.</a>
<a name="ln342">      break;</a>
<a name="ln343">    case kPerfOptions:</a>
<a name="ln344">      options.soft_rate_limit = 2.0;</a>
<a name="ln345">      options.delayed_write_rate = 8 * 1024 * 1024;</a>
<a name="ln346">      // TODO(3.13) -- test more options</a>
<a name="ln347">      break;</a>
<a name="ln348">    case kDeletesFilterFirst:</a>
<a name="ln349">      options.filter_deletes = true;</a>
<a name="ln350">      break;</a>
<a name="ln351">    case kUniversalCompaction:</a>
<a name="ln352">      options.compaction_style = kCompactionStyleUniversal;</a>
<a name="ln353">      options.num_levels = 1;</a>
<a name="ln354">      break;</a>
<a name="ln355">    case kUniversalCompactionMultiLevel:</a>
<a name="ln356">      options.compaction_style = kCompactionStyleUniversal;</a>
<a name="ln357">      options.num_levels = 8;</a>
<a name="ln358">      break;</a>
<a name="ln359">    case kCompressedBlockCache:</a>
<a name="ln360">      options.allow_mmap_writes = true;</a>
<a name="ln361">      table_options.block_cache_compressed = NewLRUCache(8 * 1024 * 1024);</a>
<a name="ln362">      break;</a>
<a name="ln363">    case kInfiniteMaxOpenFiles:</a>
<a name="ln364">      options.max_open_files = -1;</a>
<a name="ln365">      break;</a>
<a name="ln366">    case kxxHashChecksum: {</a>
<a name="ln367">      table_options.checksum = kxxHash;</a>
<a name="ln368">      break;</a>
<a name="ln369">    }</a>
<a name="ln370">    case kFIFOCompaction: {</a>
<a name="ln371">      options.compaction_style = kCompactionStyleFIFO;</a>
<a name="ln372">      break;</a>
<a name="ln373">    }</a>
<a name="ln374">    case kBlockBasedTableWithPrefixHashIndex: {</a>
<a name="ln375">      table_options.index_type = IndexType::kHashSearch;</a>
<a name="ln376">      options.prefix_extractor.reset(NewFixedPrefixTransform(1));</a>
<a name="ln377">      break;</a>
<a name="ln378">    }</a>
<a name="ln379">    case kBlockBasedTableWithWholeKeyHashIndex: {</a>
<a name="ln380">      table_options.index_type = IndexType::kHashSearch;</a>
<a name="ln381">      options.prefix_extractor.reset(NewNoopTransform());</a>
<a name="ln382">      break;</a>
<a name="ln383">    }</a>
<a name="ln384">    case kBlockBasedTableWithIndexRestartInterval: {</a>
<a name="ln385">      table_options.index_block_restart_interval = 8;</a>
<a name="ln386">      break;</a>
<a name="ln387">    }</a>
<a name="ln388">    case kOptimizeFiltersForHits: {</a>
<a name="ln389">      options.optimize_filters_for_hits = true;</a>
<a name="ln390">      set_block_based_table_factory = true;</a>
<a name="ln391">      break;</a>
<a name="ln392">    }</a>
<a name="ln393">    case kRowCache: {</a>
<a name="ln394">      options.row_cache = NewLRUCache(1024 * 1024);</a>
<a name="ln395">      break;</a>
<a name="ln396">    }</a>
<a name="ln397">    case kRecycleLogFiles: {</a>
<a name="ln398">      options.recycle_log_file_num = 2;</a>
<a name="ln399">      break;</a>
<a name="ln400">    }</a>
<a name="ln401">    case kLevelSubcompactions: {</a>
<a name="ln402">      options.max_subcompactions = 4;</a>
<a name="ln403">      break;</a>
<a name="ln404">    }</a>
<a name="ln405">    case kUniversalSubcompactions: {</a>
<a name="ln406">      options.compaction_style = kCompactionStyleUniversal;</a>
<a name="ln407">      options.num_levels = 8;</a>
<a name="ln408">      options.max_subcompactions = 4;</a>
<a name="ln409">      break;</a>
<a name="ln410">    }</a>
<a name="ln411">    case kConcurrentSkipList: {</a>
<a name="ln412">      options.allow_concurrent_memtable_write = true;</a>
<a name="ln413">      options.enable_write_thread_adaptive_yield = true;</a>
<a name="ln414">      break;</a>
<a name="ln415">    }</a>
<a name="ln416"> </a>
<a name="ln417">    default:</a>
<a name="ln418">      break;</a>
<a name="ln419">  }</a>
<a name="ln420"> </a>
<a name="ln421">  if (options_override.filter_policy) {</a>
<a name="ln422">    table_options.filter_policy = options_override.filter_policy;</a>
<a name="ln423">  }</a>
<a name="ln424">  if (set_block_based_table_factory) {</a>
<a name="ln425">    options.table_factory.reset(NewBlockBasedTableFactory(table_options));</a>
<a name="ln426">  }</a>
<a name="ln427">  options.env = env_;</a>
<a name="ln428">  options.checkpoint_env = env_-&gt;IsPlainText() ? env_ : Env::Default();</a>
<a name="ln429">  options.create_if_missing = true;</a>
<a name="ln430">  options.fail_if_options_file_error = true;</a>
<a name="ln431">  return options;</a>
<a name="ln432">}</a>
<a name="ln433"> </a>
<a name="ln434">void DBTestBase::CreateColumnFamilies(const std::vector&lt;std::string&gt;&amp; cfs,</a>
<a name="ln435">                                      const Options&amp; options) {</a>
<a name="ln436">  ColumnFamilyOptions cf_opts(options);</a>
<a name="ln437">  size_t cfi = handles_.size();</a>
<a name="ln438">  handles_.resize(cfi + cfs.size());</a>
<a name="ln439">  for (auto cf : cfs) {</a>
<a name="ln440">    ASSERT_OK(db_-&gt;CreateColumnFamily(cf_opts, cf, &amp;handles_[cfi++]));</a>
<a name="ln441">  }</a>
<a name="ln442">}</a>
<a name="ln443"> </a>
<a name="ln444">void DBTestBase::CreateAndReopenWithCF(const std::vector&lt;std::string&gt;&amp; cfs,</a>
<a name="ln445">                                       const Options&amp; options) {</a>
<a name="ln446">  CreateColumnFamilies(cfs, options);</a>
<a name="ln447">  std::vector&lt;std::string&gt; cfs_plus_default = cfs;</a>
<a name="ln448">  cfs_plus_default.insert(cfs_plus_default.begin(), kDefaultColumnFamilyName);</a>
<a name="ln449">  ReopenWithColumnFamilies(cfs_plus_default, options);</a>
<a name="ln450">}</a>
<a name="ln451"> </a>
<a name="ln452">void DBTestBase::ReopenWithColumnFamilies(const std::vector&lt;std::string&gt;&amp; cfs,</a>
<a name="ln453">                                          const std::vector&lt;Options&gt;&amp; options) {</a>
<a name="ln454">  ASSERT_OK(TryReopenWithColumnFamilies(cfs, options));</a>
<a name="ln455">}</a>
<a name="ln456"> </a>
<a name="ln457">void DBTestBase::ReopenWithColumnFamilies(const std::vector&lt;std::string&gt;&amp; cfs,</a>
<a name="ln458">                                          const Options&amp; options) {</a>
<a name="ln459">  ASSERT_OK(TryReopenWithColumnFamilies(cfs, options));</a>
<a name="ln460">}</a>
<a name="ln461"> </a>
<a name="ln462">Status DBTestBase::TryReopenWithColumnFamilies(</a>
<a name="ln463">    const std::vector&lt;std::string&gt;&amp; cfs, const std::vector&lt;Options&gt;&amp; options) {</a>
<a name="ln464">  Close();</a>
<a name="ln465">  EXPECT_EQ(cfs.size(), options.size());</a>
<a name="ln466">  std::vector&lt;ColumnFamilyDescriptor&gt; column_families;</a>
<a name="ln467">  for (size_t i = 0; i &lt; cfs.size(); ++i) {</a>
<a name="ln468">    column_families.push_back(ColumnFamilyDescriptor(cfs[i], options[i]));</a>
<a name="ln469">  }</a>
<a name="ln470">  DBOptions db_opts = DBOptions(options[0]);</a>
<a name="ln471">  return DB::Open(db_opts, dbname_, column_families, &amp;handles_, &amp;db_);</a>
<a name="ln472">}</a>
<a name="ln473"> </a>
<a name="ln474">Status DBTestBase::TryReopenWithColumnFamilies(</a>
<a name="ln475">    const std::vector&lt;std::string&gt;&amp; cfs, const Options&amp; options) {</a>
<a name="ln476">  Close();</a>
<a name="ln477">  std::vector&lt;Options&gt; v_opts(cfs.size(), options);</a>
<a name="ln478">  return TryReopenWithColumnFamilies(cfs, v_opts);</a>
<a name="ln479">}</a>
<a name="ln480"> </a>
<a name="ln481">void DBTestBase::Reopen(const Options&amp; options) {</a>
<a name="ln482">  ASSERT_OK(TryReopen(options));</a>
<a name="ln483">}</a>
<a name="ln484"> </a>
<a name="ln485">void DBTestBase::Close() {</a>
<a name="ln486">  for (auto h : handles_) {</a>
<a name="ln487">    delete h;</a>
<a name="ln488">  }</a>
<a name="ln489">  handles_.clear();</a>
<a name="ln490">  delete db_;</a>
<a name="ln491">  db_ = nullptr;</a>
<a name="ln492">}</a>
<a name="ln493"> </a>
<a name="ln494">void DBTestBase::DestroyAndReopen(const Options&amp; options) {</a>
<a name="ln495">  // Destroy using last options</a>
<a name="ln496">  Destroy(last_options_);</a>
<a name="ln497">  ASSERT_OK(TryReopen(options));</a>
<a name="ln498">}</a>
<a name="ln499"> </a>
<a name="ln500">void DBTestBase::Destroy(const Options&amp; options) {</a>
<a name="ln501">  Close();</a>
<a name="ln502">  ASSERT_OK(DestroyDB(dbname_, options));</a>
<a name="ln503">}</a>
<a name="ln504"> </a>
<a name="ln505">Status DBTestBase::ReadOnlyReopen(const Options&amp; options) {</a>
<a name="ln506">  return DB::OpenForReadOnly(options, dbname_, &amp;db_);</a>
<a name="ln507">}</a>
<a name="ln508"> </a>
<a name="ln509">Status DBTestBase::TryReopen(const Options&amp; options) {</a>
<a name="ln510">  Close();</a>
<a name="ln511">  last_options_ = options;</a>
<a name="ln512">  return DB::Open(options, dbname_, &amp;db_);</a>
<a name="ln513">}</a>
<a name="ln514"> </a>
<a name="ln515">Status DBTestBase::Flush(int cf) {</a>
<a name="ln516">  if (cf == 0) {</a>
<a name="ln517">    return db_-&gt;Flush(FlushOptions());</a>
<a name="ln518">  } else {</a>
<a name="ln519">    return db_-&gt;Flush(FlushOptions(), handles_[cf]);</a>
<a name="ln520">  }</a>
<a name="ln521">}</a>
<a name="ln522"> </a>
<a name="ln523">Status DBTestBase::Put(const Slice&amp; k, const Slice&amp; v, WriteOptions wo) {</a>
<a name="ln524">  if (kMergePut == option_config_) {</a>
<a name="ln525">    return db_-&gt;Merge(wo, k, v);</a>
<a name="ln526">  } else {</a>
<a name="ln527">    return db_-&gt;Put(wo, k, v);</a>
<a name="ln528">  }</a>
<a name="ln529">}</a>
<a name="ln530"> </a>
<a name="ln531">Status DBTestBase::Put(int cf, const Slice&amp; k, const Slice&amp; v,</a>
<a name="ln532">                       WriteOptions wo) {</a>
<a name="ln533">  if (kMergePut == option_config_) {</a>
<a name="ln534">    return db_-&gt;Merge(wo, handles_[cf], k, v);</a>
<a name="ln535">  } else {</a>
<a name="ln536">    return db_-&gt;Put(wo, handles_[cf], k, v);</a>
<a name="ln537">  }</a>
<a name="ln538">}</a>
<a name="ln539"> </a>
<a name="ln540">Status DBTestBase::Delete(const std::string&amp; k) {</a>
<a name="ln541">  return db_-&gt;Delete(WriteOptions(), k);</a>
<a name="ln542">}</a>
<a name="ln543"> </a>
<a name="ln544">Status DBTestBase::Delete(int cf, const std::string&amp; k) {</a>
<a name="ln545">  return db_-&gt;Delete(WriteOptions(), handles_[cf], k);</a>
<a name="ln546">}</a>
<a name="ln547"> </a>
<a name="ln548">Status DBTestBase::SingleDelete(const std::string&amp; k) {</a>
<a name="ln549">  return db_-&gt;SingleDelete(WriteOptions(), k);</a>
<a name="ln550">}</a>
<a name="ln551"> </a>
<a name="ln552">Status DBTestBase::SingleDelete(int cf, const std::string&amp; k) {</a>
<a name="ln553">  return db_-&gt;SingleDelete(WriteOptions(), handles_[cf], k);</a>
<a name="ln554">}</a>
<a name="ln555"> </a>
<a name="ln556">std::string DBTestBase::Get(const std::string&amp; k, const Snapshot* snapshot) {</a>
<a name="ln557">  ReadOptions options;</a>
<a name="ln558">  options.verify_checksums = true;</a>
<a name="ln559">  options.snapshot = snapshot;</a>
<a name="ln560">  options.query_id = kInMultiTouchId;</a>
<a name="ln561">  std::string result;</a>
<a name="ln562">  Status s = db_-&gt;Get(options, k, &amp;result);</a>
<a name="ln563">  if (s.IsNotFound()) {</a>
<a name="ln564">    result = &quot;NOT_FOUND&quot;;</a>
<a name="ln565">  } else if (!s.ok()) {</a>
<a name="ln566">    result = s.ToString();</a>
<a name="ln567">  }</a>
<a name="ln568">  return result;</a>
<a name="ln569">}</a>
<a name="ln570"> </a>
<a name="ln571">std::string DBTestBase::Get(int cf, const std::string&amp; k,</a>
<a name="ln572">                            const Snapshot* snapshot) {</a>
<a name="ln573">  ReadOptions options;</a>
<a name="ln574">  options.verify_checksums = true;</a>
<a name="ln575">  options.snapshot = snapshot;</a>
<a name="ln576">  std::string result;</a>
<a name="ln577">  Status s = db_-&gt;Get(options, handles_[cf], k, &amp;result);</a>
<a name="ln578">  if (s.IsNotFound()) {</a>
<a name="ln579">    result = &quot;NOT_FOUND&quot;;</a>
<a name="ln580">  } else if (!s.ok()) {</a>
<a name="ln581">    result = s.ToString();</a>
<a name="ln582">  }</a>
<a name="ln583">  return result;</a>
<a name="ln584">}</a>
<a name="ln585"> </a>
<a name="ln586">uint64_t DBTestBase::GetNumSnapshots() {</a>
<a name="ln587">  uint64_t int_num;</a>
<a name="ln588">  EXPECT_TRUE(dbfull()-&gt;GetIntProperty(&quot;rocksdb.num-snapshots&quot;, &amp;int_num));</a>
<a name="ln589">  return int_num;</a>
<a name="ln590">}</a>
<a name="ln591"> </a>
<a name="ln592">uint64_t DBTestBase::GetTimeOldestSnapshots() {</a>
<a name="ln593">  uint64_t int_num;</a>
<a name="ln594">  EXPECT_TRUE(</a>
<a name="ln595">      dbfull()-&gt;GetIntProperty(&quot;rocksdb.oldest-snapshot-time&quot;, &amp;int_num));</a>
<a name="ln596">  return int_num;</a>
<a name="ln597">}</a>
<a name="ln598"> </a>
<a name="ln599">// Return a string that contains all key,value pairs in order,</a>
<a name="ln600">// formatted like &quot;(k1-&gt;v1)(k2-&gt;v2)&quot;.</a>
<a name="ln601">std::string DBTestBase::Contents(int cf) {</a>
<a name="ln602">  std::vector&lt;std::string&gt; forward;</a>
<a name="ln603">  std::string result;</a>
<a name="ln604">  Iterator* iter = (cf == 0) ? db_-&gt;NewIterator(ReadOptions())</a>
<a name="ln605">                             : db_-&gt;NewIterator(ReadOptions(), handles_[cf]);</a>
<a name="ln606">  for (iter-&gt;SeekToFirst(); iter-&gt;Valid(); iter-&gt;Next()) {</a>
<a name="ln607">    std::string s = IterStatus(iter);</a>
<a name="ln608">    result.push_back('(');</a>
<a name="ln609">    result.append(s);</a>
<a name="ln610">    result.push_back(')');</a>
<a name="ln611">    forward.push_back(s);</a>
<a name="ln612">  }</a>
<a name="ln613"> </a>
<a name="ln614">  // Check reverse iteration results are the reverse of forward results</a>
<a name="ln615">  unsigned int matched = 0;</a>
<a name="ln616">  for (iter-&gt;SeekToLast(); iter-&gt;Valid(); iter-&gt;Prev()) {</a>
<a name="ln617">    EXPECT_LT(matched, forward.size());</a>
<a name="ln618">    EXPECT_EQ(IterStatus(iter), forward[forward.size() - matched - 1]);</a>
<a name="ln619">    matched++;</a>
<a name="ln620">  }</a>
<a name="ln621">  EXPECT_EQ(matched, forward.size());</a>
<a name="ln622"> </a>
<a name="ln623">  delete iter;</a>
<a name="ln624">  return result;</a>
<a name="ln625">}</a>
<a name="ln626"> </a>
<a name="ln627">std::string DBTestBase::AllEntriesFor(const Slice&amp; user_key, int cf) {</a>
<a name="ln628">  Arena arena;</a>
<a name="ln629">  ScopedArenaIterator iter;</a>
<a name="ln630">  if (cf == 0) {</a>
<a name="ln631">    iter.set(dbfull()-&gt;NewInternalIterator(&amp;arena));</a>
<a name="ln632">  } else {</a>
<a name="ln633">    iter.set(dbfull()-&gt;NewInternalIterator(&amp;arena, handles_[cf]));</a>
<a name="ln634">  }</a>
<a name="ln635">  InternalKey target(user_key, kMaxSequenceNumber, kTypeValue);</a>
<a name="ln636">  iter-&gt;Seek(target.Encode());</a>
<a name="ln637">  std::string result;</a>
<a name="ln638">  if (!iter-&gt;status().ok()) {</a>
<a name="ln639">    result = iter-&gt;status().ToString();</a>
<a name="ln640">  } else {</a>
<a name="ln641">    result = &quot;[ &quot;;</a>
<a name="ln642">    bool first = true;</a>
<a name="ln643">    while (iter-&gt;Valid()) {</a>
<a name="ln644">      ParsedInternalKey ikey(Slice(), 0, kTypeValue);</a>
<a name="ln645">      if (!ParseInternalKey(iter-&gt;key(), &amp;ikey)) {</a>
<a name="ln646">        result += &quot;CORRUPTED&quot;;</a>
<a name="ln647">      } else {</a>
<a name="ln648">        if (!last_options_.comparator-&gt;Equal(ikey.user_key, user_key)) {</a>
<a name="ln649">          break;</a>
<a name="ln650">        }</a>
<a name="ln651">        if (!first) {</a>
<a name="ln652">          result += &quot;, &quot;;</a>
<a name="ln653">        }</a>
<a name="ln654">        first = false;</a>
<a name="ln655">        switch (ikey.type) {</a>
<a name="ln656">          case kTypeValue:</a>
<a name="ln657">            result += iter-&gt;value().ToString();</a>
<a name="ln658">            break;</a>
<a name="ln659">          case kTypeMerge:</a>
<a name="ln660">            // keep it the same as kTypeValue for testing kMergePut</a>
<a name="ln661">            result += iter-&gt;value().ToString();</a>
<a name="ln662">            break;</a>
<a name="ln663">          case kTypeDeletion:</a>
<a name="ln664">            result += &quot;DEL&quot;;</a>
<a name="ln665">            break;</a>
<a name="ln666">          case kTypeSingleDeletion:</a>
<a name="ln667">            result += &quot;SDEL&quot;;</a>
<a name="ln668">            break;</a>
<a name="ln669">          default:</a>
<a name="ln670">            assert(false);</a>
<a name="ln671">            break;</a>
<a name="ln672">        }</a>
<a name="ln673">      }</a>
<a name="ln674">      iter-&gt;Next();</a>
<a name="ln675">    }</a>
<a name="ln676">    if (!first) {</a>
<a name="ln677">      result += &quot; &quot;;</a>
<a name="ln678">    }</a>
<a name="ln679">    result += &quot;]&quot;;</a>
<a name="ln680">  }</a>
<a name="ln681">  return result;</a>
<a name="ln682">}</a>
<a name="ln683"> </a>
<a name="ln684">#ifndef ROCKSDB_LITE</a>
<a name="ln685">int DBTestBase::NumSortedRuns(int cf) {</a>
<a name="ln686">  ColumnFamilyMetaData cf_meta;</a>
<a name="ln687">  if (cf == 0) {</a>
<a name="ln688">    db_-&gt;GetColumnFamilyMetaData(&amp;cf_meta);</a>
<a name="ln689">  } else {</a>
<a name="ln690">    db_-&gt;GetColumnFamilyMetaData(handles_[cf], &amp;cf_meta);</a>
<a name="ln691">  }</a>
<a name="ln692">  int num_sr = static_cast&lt;int&gt;(cf_meta.levels[0].files.size());</a>
<a name="ln693">  for (size_t i = 1U; i &lt; cf_meta.levels.size(); i++) {</a>
<a name="ln694">    if (cf_meta.levels[i].files.size() &gt; 0) {</a>
<a name="ln695">      num_sr++;</a>
<a name="ln696">    }</a>
<a name="ln697">  }</a>
<a name="ln698">  return num_sr;</a>
<a name="ln699">}</a>
<a name="ln700"> </a>
<a name="ln701">uint64_t DBTestBase::TotalSize(int cf) {</a>
<a name="ln702">  ColumnFamilyMetaData cf_meta;</a>
<a name="ln703">  if (cf == 0) {</a>
<a name="ln704">    db_-&gt;GetColumnFamilyMetaData(&amp;cf_meta);</a>
<a name="ln705">  } else {</a>
<a name="ln706">    db_-&gt;GetColumnFamilyMetaData(handles_[cf], &amp;cf_meta);</a>
<a name="ln707">  }</a>
<a name="ln708">  return cf_meta.size;</a>
<a name="ln709">}</a>
<a name="ln710"> </a>
<a name="ln711">uint64_t DBTestBase::SizeAtLevel(int level) {</a>
<a name="ln712">  std::vector&lt;LiveFileMetaData&gt; metadata;</a>
<a name="ln713">  db_-&gt;GetLiveFilesMetaData(&amp;metadata);</a>
<a name="ln714">  uint64_t sum = 0;</a>
<a name="ln715">  for (const auto&amp; m : metadata) {</a>
<a name="ln716">    if (m.level == level) {</a>
<a name="ln717">      sum += m.total_size;</a>
<a name="ln718">    }</a>
<a name="ln719">  }</a>
<a name="ln720">  return sum;</a>
<a name="ln721">}</a>
<a name="ln722"> </a>
<a name="ln723">size_t DBTestBase::TotalLiveFiles(int cf) {</a>
<a name="ln724">  ColumnFamilyMetaData cf_meta;</a>
<a name="ln725">  if (cf == 0) {</a>
<a name="ln726">    db_-&gt;GetColumnFamilyMetaData(&amp;cf_meta);</a>
<a name="ln727">  } else {</a>
<a name="ln728">    db_-&gt;GetColumnFamilyMetaData(handles_[cf], &amp;cf_meta);</a>
<a name="ln729">  }</a>
<a name="ln730">  size_t num_files = 0;</a>
<a name="ln731">  for (auto&amp; level : cf_meta.levels) {</a>
<a name="ln732">    num_files += level.files.size();</a>
<a name="ln733">  }</a>
<a name="ln734">  return num_files;</a>
<a name="ln735">}</a>
<a name="ln736"> </a>
<a name="ln737">size_t DBTestBase::CountLiveFiles() {</a>
<a name="ln738">  std::vector&lt;LiveFileMetaData&gt; metadata;</a>
<a name="ln739">  db_-&gt;GetLiveFilesMetaData(&amp;metadata);</a>
<a name="ln740">  return metadata.size();</a>
<a name="ln741">}</a>
<a name="ln742">#endif  // ROCKSDB_LITE</a>
<a name="ln743"> </a>
<a name="ln744">int DBTestBase::NumTableFilesAtLevel(int level, int cf) {</a>
<a name="ln745">  std::string property;</a>
<a name="ln746">  if (cf == 0) {</a>
<a name="ln747">    // default cfd</a>
<a name="ln748">    EXPECT_TRUE(db_-&gt;GetProperty(</a>
<a name="ln749">        &quot;rocksdb.num-files-at-level&quot; + NumberToString(level), &amp;property));</a>
<a name="ln750">  } else {</a>
<a name="ln751">    EXPECT_TRUE(db_-&gt;GetProperty(</a>
<a name="ln752">        handles_[cf], &quot;rocksdb.num-files-at-level&quot; + NumberToString(level),</a>
<a name="ln753">        &amp;property));</a>
<a name="ln754">  }</a>
<a name="ln755">  return atoi(property.c_str());</a>
<a name="ln756">}</a>
<a name="ln757"> </a>
<a name="ln758">int DBTestBase::TotalTableFiles(int cf, int levels) {</a>
<a name="ln759">  if (levels == -1) {</a>
<a name="ln760">    levels = CurrentOptions().num_levels;</a>
<a name="ln761">  }</a>
<a name="ln762">  int result = 0;</a>
<a name="ln763">  for (int level = 0; level &lt; levels; level++) {</a>
<a name="ln764">    result += NumTableFilesAtLevel(level, cf);</a>
<a name="ln765">  }</a>
<a name="ln766">  return result;</a>
<a name="ln767">}</a>
<a name="ln768"> </a>
<a name="ln769">// Return spread of files per level</a>
<a name="ln770">std::string DBTestBase::FilesPerLevel(int cf) {</a>
<a name="ln771">  int num_levels =</a>
<a name="ln772">      (cf == 0) ? db_-&gt;NumberLevels() : db_-&gt;NumberLevels(handles_[1]);</a>
<a name="ln773">  std::string result;</a>
<a name="ln774">  size_t last_non_zero_offset = 0;</a>
<a name="ln775">  for (int level = 0; level &lt; num_levels; level++) {</a>
<a name="ln776">    int f = NumTableFilesAtLevel(level, cf);</a>
<a name="ln777">    char buf[100];</a>
<a name="ln778">    snprintf(buf, sizeof(buf), &quot;%s%d&quot;, (level ? &quot;,&quot; : &quot;&quot;), f);</a>
<a name="ln779">    result += buf;</a>
<a name="ln780">    if (f &gt; 0) {</a>
<a name="ln781">      last_non_zero_offset = result.size();</a>
<a name="ln782">    }</a>
<a name="ln783">  }</a>
<a name="ln784">  result.resize(last_non_zero_offset);</a>
<a name="ln785">  return result;</a>
<a name="ln786">}</a>
<a name="ln787"> </a>
<a name="ln788">size_t DBTestBase::CountFiles() {</a>
<a name="ln789">  std::vector&lt;std::string&gt; files;</a>
<a name="ln790">  env_-&gt;GetChildrenWarnNotOk(dbname_, &amp;files);</a>
<a name="ln791"> </a>
<a name="ln792">  std::vector&lt;std::string&gt; logfiles;</a>
<a name="ln793">  if (dbname_ != last_options_.wal_dir) {</a>
<a name="ln794">    env_-&gt;GetChildrenWarnNotOk(last_options_.wal_dir, &amp;logfiles);</a>
<a name="ln795">  }</a>
<a name="ln796"> </a>
<a name="ln797">  return files.size() + logfiles.size();</a>
<a name="ln798">}</a>
<a name="ln799"> </a>
<a name="ln800">uint64_t DBTestBase::Size(const Slice&amp; start, const Slice&amp; limit, int cf) {</a>
<a name="ln801">  Range r(start, limit);</a>
<a name="ln802">  uint64_t size;</a>
<a name="ln803">  if (cf == 0) {</a>
<a name="ln804">    db_-&gt;GetApproximateSizes(&amp;r, 1, &amp;size);</a>
<a name="ln805">  } else {</a>
<a name="ln806">    db_-&gt;GetApproximateSizes(handles_[1], &amp;r, 1, &amp;size);</a>
<a name="ln807">  }</a>
<a name="ln808">  return size;</a>
<a name="ln809">}</a>
<a name="ln810"> </a>
<a name="ln811">void DBTestBase::Compact(int cf, const Slice&amp; start, const Slice&amp; limit,</a>
<a name="ln812">                         uint32_t target_path_id) {</a>
<a name="ln813">  CompactRangeOptions compact_options;</a>
<a name="ln814">  compact_options.target_path_id = target_path_id;</a>
<a name="ln815">  ASSERT_OK(db_-&gt;CompactRange(compact_options, handles_[cf], &amp;start, &amp;limit));</a>
<a name="ln816">}</a>
<a name="ln817"> </a>
<a name="ln818">void DBTestBase::Compact(int cf, const Slice&amp; start, const Slice&amp; limit) {</a>
<a name="ln819">  ASSERT_OK(</a>
<a name="ln820">      db_-&gt;CompactRange(CompactRangeOptions(), handles_[cf], &amp;start, &amp;limit));</a>
<a name="ln821">}</a>
<a name="ln822"> </a>
<a name="ln823">void DBTestBase::Compact(const Slice&amp; start, const Slice&amp; limit) {</a>
<a name="ln824">  ASSERT_OK(db_-&gt;CompactRange(CompactRangeOptions(), &amp;start, &amp;limit));</a>
<a name="ln825">}</a>
<a name="ln826"> </a>
<a name="ln827">// Do n memtable compactions, each of which produces an sstable</a>
<a name="ln828">// covering the range [small,large].</a>
<a name="ln829">void DBTestBase::MakeTables(int n, const std::string&amp; small,</a>
<a name="ln830">                            const std::string&amp; large, int cf) {</a>
<a name="ln831">  for (int i = 0; i &lt; n; i++) {</a>
<a name="ln832">    ASSERT_OK(Put(cf, small, &quot;begin&quot;));</a>
<a name="ln833">    ASSERT_OK(Put(cf, large, &quot;end&quot;));</a>
<a name="ln834">    ASSERT_OK(Flush(cf));</a>
<a name="ln835">    MoveFilesToLevel(n - i - 1, cf);</a>
<a name="ln836">  }</a>
<a name="ln837">}</a>
<a name="ln838"> </a>
<a name="ln839">// Prevent pushing of new sstables into deeper levels by adding</a>
<a name="ln840">// tables that cover a specified range to all levels.</a>
<a name="ln841">void DBTestBase::FillLevels(const std::string&amp; smallest,</a>
<a name="ln842">                            const std::string&amp; largest, int cf) {</a>
<a name="ln843">  MakeTables(db_-&gt;NumberLevels(handles_[cf]), smallest, largest, cf);</a>
<a name="ln844">}</a>
<a name="ln845"> </a>
<a name="ln846">void DBTestBase::MoveFilesToLevel(int level, int cf) {</a>
<a name="ln847">  for (int l = 0; l &lt; level; ++l) {</a>
<a name="ln848">    if (cf &gt; 0) {</a>
<a name="ln849">      CHECK_OK(dbfull()-&gt;TEST_CompactRange(l, nullptr, nullptr, handles_[cf]));</a>
<a name="ln850">    } else {</a>
<a name="ln851">      CHECK_OK(dbfull()-&gt;TEST_CompactRange(l, nullptr, nullptr));</a>
<a name="ln852">    }</a>
<a name="ln853">  }</a>
<a name="ln854">}</a>
<a name="ln855"> </a>
<a name="ln856">void DBTestBase::DumpFileCounts(const char* label) {</a>
<a name="ln857">  fprintf(stderr, &quot;---\n%s:\n&quot;, label);</a>
<a name="ln858">  fprintf(stderr, &quot;maxoverlap: %&quot; PRIu64 &quot;\n&quot;,</a>
<a name="ln859">          dbfull()-&gt;TEST_MaxNextLevelOverlappingBytes());</a>
<a name="ln860">  for (int level = 0; level &lt; db_-&gt;NumberLevels(); level++) {</a>
<a name="ln861">    int num = NumTableFilesAtLevel(level);</a>
<a name="ln862">    if (num &gt; 0) {</a>
<a name="ln863">      fprintf(stderr, &quot;  level %3d : %d files\n&quot;, level, num);</a>
<a name="ln864">    }</a>
<a name="ln865">  }</a>
<a name="ln866">}</a>
<a name="ln867"> </a>
<a name="ln868">std::string DBTestBase::DumpSSTableList() {</a>
<a name="ln869">  std::string property;</a>
<a name="ln870">  db_-&gt;GetProperty(&quot;rocksdb.sstables&quot;, &amp;property);</a>
<a name="ln871">  return property;</a>
<a name="ln872">}</a>
<a name="ln873"> </a>
<a name="ln874">void DBTestBase::GetSstFiles(std::string path,</a>
<a name="ln875">                             std::vector&lt;std::string&gt;* files) {</a>
<a name="ln876">  env_-&gt;GetChildrenWarnNotOk(path, files);</a>
<a name="ln877"> </a>
<a name="ln878">  files-&gt;erase(</a>
<a name="ln879">      std::remove_if(files-&gt;begin(), files-&gt;end(), [](std::string name) {</a>
<a name="ln880">        uint64_t number;</a>
<a name="ln881">        FileType type;</a>
<a name="ln882">        return !(ParseFileName(name, &amp;number, &amp;type) &amp;&amp; type == kTableFile);</a>
<a name="ln883">      }), files-&gt;end());</a>
<a name="ln884">}</a>
<a name="ln885"> </a>
<a name="ln886">int DBTestBase::GetSstFileCount(std::string path) {</a>
<a name="ln887">  std::vector&lt;std::string&gt; files;</a>
<a name="ln888">  GetSstFiles(path, &amp;files);</a>
<a name="ln889">  return static_cast&lt;int&gt;(files.size());</a>
<a name="ln890">}</a>
<a name="ln891"> </a>
<a name="ln892">// this will generate non-overlapping files since it keeps increasing key_idx</a>
<a name="ln893">void DBTestBase::GenerateNewFile(int cf, Random* rnd, int* key_idx,</a>
<a name="ln894">                                 bool nowait) {</a>
<a name="ln895">  for (int i = 0; i &lt; KNumKeysByGenerateNewFile; i++) {</a>
<a name="ln896">    ASSERT_OK(Put(cf, Key(*key_idx), RandomString(rnd, (i == 99) ? 1 : 990)));</a>
<a name="ln897">    (*key_idx)++;</a>
<a name="ln898">  }</a>
<a name="ln899">  if (!nowait) {</a>
<a name="ln900">    CHECK_OK(dbfull()-&gt;TEST_WaitForFlushMemTable());</a>
<a name="ln901">    CHECK_OK(dbfull()-&gt;TEST_WaitForCompact());</a>
<a name="ln902">  }</a>
<a name="ln903">}</a>
<a name="ln904"> </a>
<a name="ln905">// this will generate non-overlapping files since it keeps increasing key_idx</a>
<a name="ln906">void DBTestBase::GenerateNewFile(Random* rnd, int* key_idx, bool nowait) {</a>
<a name="ln907">  for (int i = 0; i &lt; KNumKeysByGenerateNewFile; i++) {</a>
<a name="ln908">    ASSERT_OK(Put(Key(*key_idx), RandomString(rnd, (i == 99) ? 1 : 990)));</a>
<a name="ln909">    (*key_idx)++;</a>
<a name="ln910">  }</a>
<a name="ln911">  if (!nowait) {</a>
<a name="ln912">    CHECK_OK(dbfull()-&gt;TEST_WaitForFlushMemTable());</a>
<a name="ln913">    CHECK_OK(dbfull()-&gt;TEST_WaitForCompact());</a>
<a name="ln914">  }</a>
<a name="ln915">}</a>
<a name="ln916"> </a>
<a name="ln917">const int DBTestBase::kNumKeysByGenerateNewRandomFile = 51;</a>
<a name="ln918"> </a>
<a name="ln919">void DBTestBase::GenerateNewRandomFile(Random* rnd, bool nowait) {</a>
<a name="ln920">  for (int i = 0; i &lt; kNumKeysByGenerateNewRandomFile; i++) {</a>
<a name="ln921">    ASSERT_OK(Put(&quot;key&quot; + RandomString(rnd, 7), RandomString(rnd, 2000)));</a>
<a name="ln922">  }</a>
<a name="ln923">  ASSERT_OK(Put(&quot;key&quot; + RandomString(rnd, 7), RandomString(rnd, 200)));</a>
<a name="ln924">  if (!nowait) {</a>
<a name="ln925">    CHECK_OK(dbfull()-&gt;TEST_WaitForFlushMemTable());</a>
<a name="ln926">    CHECK_OK(dbfull()-&gt;TEST_WaitForCompact());</a>
<a name="ln927">  }</a>
<a name="ln928">}</a>
<a name="ln929"> </a>
<a name="ln930">std::string DBTestBase::IterStatus(Iterator* iter) {</a>
<a name="ln931">  std::string result;</a>
<a name="ln932">  if (iter-&gt;Valid()) {</a>
<a name="ln933">    result = iter-&gt;key().ToString() + &quot;-&gt;&quot; + iter-&gt;value().ToString();</a>
<a name="ln934">  } else {</a>
<a name="ln935">    result = &quot;(invalid)&quot;;</a>
<a name="ln936">  }</a>
<a name="ln937">  return result;</a>
<a name="ln938">}</a>
<a name="ln939"> </a>
<a name="ln940">Options DBTestBase::OptionsForLogIterTest() {</a>
<a name="ln941">  Options options = CurrentOptions();</a>
<a name="ln942">  options.create_if_missing = true;</a>
<a name="ln943">  options.WAL_ttl_seconds = 1000;</a>
<a name="ln944">  return options;</a>
<a name="ln945">}</a>
<a name="ln946"> </a>
<a name="ln947">std::string DBTestBase::DummyString(size_t len, char c) {</a>
<a name="ln948">  return std::string(len, c);</a>
<a name="ln949">}</a>
<a name="ln950"> </a>
<a name="ln951">void DBTestBase::VerifyIterLast(std::string expected_key, int cf) {</a>
<a name="ln952">  Iterator* iter;</a>
<a name="ln953">  ReadOptions ro;</a>
<a name="ln954">  if (cf == 0) {</a>
<a name="ln955">    iter = db_-&gt;NewIterator(ro);</a>
<a name="ln956">  } else {</a>
<a name="ln957">    iter = db_-&gt;NewIterator(ro, handles_[cf]);</a>
<a name="ln958">  }</a>
<a name="ln959">  iter-&gt;SeekToLast();</a>
<a name="ln960">  ASSERT_EQ(IterStatus(iter), expected_key);</a>
<a name="ln961">  delete iter;</a>
<a name="ln962">}</a>
<a name="ln963"> </a>
<a name="ln964">// Used to test InplaceUpdate</a>
<a name="ln965"> </a>
<a name="ln966">// If previous value is nullptr or delta is &gt; than previous value,</a>
<a name="ln967">//   sets newValue with delta</a>
<a name="ln968">// If previous value is not empty,</a>
<a name="ln969">//   updates previous value with 'b' string of previous value size - 1.</a>
<a name="ln970">UpdateStatus DBTestBase::updateInPlaceSmallerSize(char* prevValue,</a>
<a name="ln971">                                                  uint32_t* prevSize,</a>
<a name="ln972">                                                  Slice delta,</a>
<a name="ln973">                                                  std::string* newValue) {</a>
<a name="ln974">  if (prevValue == nullptr) {</a>
<a name="ln975">    *newValue = std::string(delta.size(), 'c');</a>
<a name="ln976">    return UpdateStatus::UPDATED;</a>
<a name="ln977">  } else {</a>
<a name="ln978">    *prevSize = *prevSize - 1;</a>
<a name="ln979">    std::string str_b = std::string(*prevSize, 'b');</a>
<a name="ln980">    memcpy(prevValue, str_b.c_str(), str_b.size());</a>
<a name="ln981">    return UpdateStatus::UPDATED_INPLACE;</a>
<a name="ln982">  }</a>
<a name="ln983">}</a>
<a name="ln984"> </a>
<a name="ln985">UpdateStatus DBTestBase::updateInPlaceSmallerVarintSize(char* prevValue,</a>
<a name="ln986">                                                        uint32_t* prevSize,</a>
<a name="ln987">                                                        Slice delta,</a>
<a name="ln988">                                                        std::string* newValue) {</a>
<a name="ln989">  if (prevValue == nullptr) {</a>
<a name="ln990">    *newValue = std::string(delta.size(), 'c');</a>
<a name="ln991">    return UpdateStatus::UPDATED;</a>
<a name="ln992">  } else {</a>
<a name="ln993">    *prevSize = 1;</a>
<a name="ln994">    std::string str_b = std::string(*prevSize, 'b');</a>
<a name="ln995">    memcpy(prevValue, str_b.c_str(), str_b.size());</a>
<a name="ln996">    return UpdateStatus::UPDATED_INPLACE;</a>
<a name="ln997">  }</a>
<a name="ln998">}</a>
<a name="ln999"> </a>
<a name="ln1000">UpdateStatus DBTestBase::updateInPlaceLargerSize(char* prevValue,</a>
<a name="ln1001">                                                 uint32_t* prevSize,</a>
<a name="ln1002">                                                 Slice delta,</a>
<a name="ln1003">                                                 std::string* newValue) {</a>
<a name="ln1004">  *newValue = std::string(delta.size(), 'c');</a>
<a name="ln1005">  return UpdateStatus::UPDATED;</a>
<a name="ln1006">}</a>
<a name="ln1007"> </a>
<a name="ln1008">UpdateStatus DBTestBase::updateInPlaceNoAction(char* prevValue,</a>
<a name="ln1009">                                               uint32_t* prevSize, Slice delta,</a>
<a name="ln1010">                                               std::string* newValue) {</a>
<a name="ln1011">  return UpdateStatus::UPDATE_FAILED;</a>
<a name="ln1012">}</a>
<a name="ln1013"> </a>
<a name="ln1014">// Utility method to test InplaceUpdate</a>
<a name="ln1015">void DBTestBase::validateNumberOfEntries(int numValues, int cf) {</a>
<a name="ln1016">  Arena arena;</a>
<a name="ln1017">  ScopedArenaIterator iter;</a>
<a name="ln1018">  if (cf != 0) {</a>
<a name="ln1019">    iter.set(dbfull()-&gt;NewInternalIterator(&amp;arena, handles_[cf]));</a>
<a name="ln1020">  } else {</a>
<a name="ln1021">    iter.set(dbfull()-&gt;NewInternalIterator(&amp;arena));</a>
<a name="ln1022">  }</a>
<a name="ln1023">  iter-&gt;SeekToFirst();</a>
<a name="ln1024">  ASSERT_EQ(iter-&gt;status().ok(), true);</a>
<a name="ln1025">  int seq = numValues;</a>
<a name="ln1026">  while (iter-&gt;Valid()) {</a>
<a name="ln1027">    ParsedInternalKey ikey;</a>
<a name="ln1028">    ikey.sequence = -1;</a>
<a name="ln1029">    ASSERT_EQ(ParseInternalKey(iter-&gt;key(), &amp;ikey), true);</a>
<a name="ln1030"> </a>
<a name="ln1031">    // checks sequence number for updates</a>
<a name="ln1032">    ASSERT_EQ(ikey.sequence, (unsigned)seq--);</a>
<a name="ln1033">    iter-&gt;Next();</a>
<a name="ln1034">  }</a>
<a name="ln1035">  ASSERT_EQ(0, seq);</a>
<a name="ln1036">}</a>
<a name="ln1037"> </a>
<a name="ln1038">void DBTestBase::CopyFile(const std::string&amp; source,</a>
<a name="ln1039">                          const std::string&amp; destination, uint64_t size) {</a>
<a name="ln1040">  const EnvOptions soptions;</a>
<a name="ln1041">  unique_ptr&lt;SequentialFile&gt; srcfile;</a>
<a name="ln1042">  ASSERT_OK(env_-&gt;NewSequentialFile(source, &amp;srcfile, soptions));</a>
<a name="ln1043">  unique_ptr&lt;WritableFile&gt; destfile;</a>
<a name="ln1044">  ASSERT_OK(env_-&gt;NewWritableFile(destination, &amp;destfile, soptions));</a>
<a name="ln1045"> </a>
<a name="ln1046">  if (size == 0) {</a>
<a name="ln1047">    // default argument means copy everything</a>
<a name="ln1048">    ASSERT_OK(env_-&gt;GetFileSize(source, &amp;size));</a>
<a name="ln1049">  }</a>
<a name="ln1050"> </a>
<a name="ln1051">  uint8_t buffer[4096];</a>
<a name="ln1052">  Slice slice;</a>
<a name="ln1053">  while (size &gt; 0) {</a>
<a name="ln1054">    uint64_t one = std::min(uint64_t(sizeof(buffer)), size);</a>
<a name="ln1055">    ASSERT_OK(srcfile-&gt;Read(one, &amp;slice, buffer));</a>
<a name="ln1056">    ASSERT_OK(destfile-&gt;Append(slice));</a>
<a name="ln1057">    size -= slice.size();</a>
<a name="ln1058">  }</a>
<a name="ln1059">  ASSERT_OK(destfile-&gt;Close());</a>
<a name="ln1060">}</a>
<a name="ln1061"> </a>
<a name="ln1062">std::unordered_map&lt;std::string, uint64_t&gt; DBTestBase::GetAllSSTFiles(</a>
<a name="ln1063">    uint64_t* total_size) {</a>
<a name="ln1064">  std::unordered_map&lt;std::string, uint64_t&gt; res;</a>
<a name="ln1065"> </a>
<a name="ln1066">  if (total_size) {</a>
<a name="ln1067">    *total_size = 0;</a>
<a name="ln1068">  }</a>
<a name="ln1069">  std::vector&lt;std::string&gt; files;</a>
<a name="ln1070">  env_-&gt;GetChildrenWarnNotOk(dbname_, &amp;files);</a>
<a name="ln1071">  for (auto&amp; file_name : files) {</a>
<a name="ln1072">    uint64_t number;</a>
<a name="ln1073">    FileType type;</a>
<a name="ln1074">    std::string file_path = dbname_ + &quot;/&quot; + file_name;</a>
<a name="ln1075">    if (ParseFileName(file_name, &amp;number, &amp;type) &amp;&amp;</a>
<a name="ln1076">        (type == kTableFile || type == kTableSBlockFile)) {</a>
<a name="ln1077">      uint64_t file_size = 0;</a>
<a name="ln1078">      CHECK_OK(env_-&gt;GetFileSize(file_path, &amp;file_size));</a>
<a name="ln1079">      res[file_path] = file_size;</a>
<a name="ln1080">      if (total_size) {</a>
<a name="ln1081">        *total_size += file_size;</a>
<a name="ln1082">      }</a>
<a name="ln1083">    }</a>
<a name="ln1084">  }</a>
<a name="ln1085">  return res;</a>
<a name="ln1086">}</a>
<a name="ln1087"> </a>
<a name="ln1088">}  // namespace rocksdb</a>

</code></pre>
<div class="balloon" rel="205"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="212"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="219"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="226"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="247"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="657"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 657, 661</p></div>
<div class="balloon" rel="849"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="851"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="900"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="901"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="912"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="913"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="925"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="926"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1078"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
