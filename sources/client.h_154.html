
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>client.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Licensed to the Apache Software Foundation (ASF) under one</a>
<a name="ln2">// or more contributor license agreements.  See the NOTICE file</a>
<a name="ln3">// distributed with this work for additional information</a>
<a name="ln4">// regarding copyright ownership.  The ASF licenses this file</a>
<a name="ln5">// to you under the Apache License, Version 2.0 (the</a>
<a name="ln6">// &quot;License&quot;); you may not use this file except in compliance</a>
<a name="ln7">// with the License.  You may obtain a copy of the License at</a>
<a name="ln8">//</a>
<a name="ln9">//   http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln10">//</a>
<a name="ln11">// Unless required by applicable law or agreed to in writing,</a>
<a name="ln12">// software distributed under the License is distributed on an</a>
<a name="ln13">// &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</a>
<a name="ln14">// KIND, either express or implied.  See the License for the</a>
<a name="ln15">// specific language governing permissions and limitations</a>
<a name="ln16">// under the License.</a>
<a name="ln17">//</a>
<a name="ln18">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln19">//</a>
<a name="ln20">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln21">//</a>
<a name="ln22">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln23">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln24">//</a>
<a name="ln25">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln26">//</a>
<a name="ln27">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln28">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln29">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln30">// under the License.</a>
<a name="ln31">//</a>
<a name="ln32">#ifndef YB_CLIENT_CLIENT_H_</a>
<a name="ln33">#define YB_CLIENT_CLIENT_H_</a>
<a name="ln34"> </a>
<a name="ln35">#include &lt;stdint.h&gt;</a>
<a name="ln36"> </a>
<a name="ln37">#include &lt;memory&gt;</a>
<a name="ln38">#include &lt;string&gt;</a>
<a name="ln39">#include &lt;vector&gt;</a>
<a name="ln40">#include &lt;utility&gt;</a>
<a name="ln41">#include &lt;mutex&gt;</a>
<a name="ln42"> </a>
<a name="ln43">#include &lt;boost/function.hpp&gt;</a>
<a name="ln44">#include &lt;boost/functional/hash/hash.hpp&gt;</a>
<a name="ln45"> </a>
<a name="ln46">#include &quot;yb/client/client_fwd.h&quot;</a>
<a name="ln47">#include &quot;yb/client/schema.h&quot;</a>
<a name="ln48">#include &quot;yb/common/common.pb.h&quot;</a>
<a name="ln49">#include &quot;yb/common/wire_protocol.h&quot;</a>
<a name="ln50"> </a>
<a name="ln51">#ifdef YB_HEADERS_NO_STUBS</a>
<a name="ln52">#include &lt;gtest/gtest_prod.h&gt;</a>
<a name="ln53">#include &quot;yb/common/clock.h&quot;</a>
<a name="ln54">#include &quot;yb/common/entity_ids.h&quot;</a>
<a name="ln55">#include &quot;yb/common/index.h&quot;</a>
<a name="ln56">#include &quot;yb/gutil/macros.h&quot;</a>
<a name="ln57">#include &quot;yb/gutil/port.h&quot;</a>
<a name="ln58">#else</a>
<a name="ln59">#include &quot;yb/client/stubs.h&quot;</a>
<a name="ln60">#endif</a>
<a name="ln61">#include &quot;yb/client/permissions.h&quot;</a>
<a name="ln62">#include &quot;yb/client/yb_table_name.h&quot;</a>
<a name="ln63">#include &quot;yb/client/namespace_alterer.h&quot;</a>
<a name="ln64"> </a>
<a name="ln65">#include &quot;yb/common/partition.h&quot;</a>
<a name="ln66">#include &quot;yb/common/roles_permissions.h&quot;</a>
<a name="ln67"> </a>
<a name="ln68">#include &quot;yb/master/master.pb.h&quot;</a>
<a name="ln69"> </a>
<a name="ln70">#include &quot;yb/rpc/rpc_fwd.h&quot;</a>
<a name="ln71"> </a>
<a name="ln72">#include &quot;yb/util/enums.h&quot;</a>
<a name="ln73">#include &quot;yb/util/monotime.h&quot;</a>
<a name="ln74">#include &quot;yb/util/net/net_fwd.h&quot;</a>
<a name="ln75">#include &quot;yb/util/result.h&quot;</a>
<a name="ln76">#include &quot;yb/util/status.h&quot;</a>
<a name="ln77">#include &quot;yb/util/status_callback.h&quot;</a>
<a name="ln78">#include &quot;yb/util/strongly_typed_bool.h&quot;</a>
<a name="ln79">#include &quot;yb/util/threadpool.h&quot;</a>
<a name="ln80"> </a>
<a name="ln81">template&lt;class T&gt; class scoped_refptr;</a>
<a name="ln82"> </a>
<a name="ln83">YB_DEFINE_ENUM(GrantRevokeStatementType, (GRANT)(REVOKE));</a>
<a name="ln84">YB_STRONGLY_TYPED_BOOL(RequireTabletsRunning);</a>
<a name="ln85"> </a>
<a name="ln86">namespace yb {</a>
<a name="ln87"> </a>
<a name="ln88">class CloudInfoPB;</a>
<a name="ln89">class MetricEntity;</a>
<a name="ln90"> </a>
<a name="ln91">namespace master {</a>
<a name="ln92">class ReplicationInfoPB;</a>
<a name="ln93">class TabletLocationsPB;</a>
<a name="ln94">}</a>
<a name="ln95"> </a>
<a name="ln96">namespace tserver {</a>
<a name="ln97">class LocalTabletServer;</a>
<a name="ln98">class TabletServerServiceProxy;</a>
<a name="ln99">}</a>
<a name="ln100"> </a>
<a name="ln101">namespace client {</a>
<a name="ln102">namespace internal {</a>
<a name="ln103">class ClientMasterRpc;</a>
<a name="ln104">class CreateCDCStreamRpc;</a>
<a name="ln105">class DeleteCDCStreamRpc;</a>
<a name="ln106">class GetCDCStreamRpc;</a>
<a name="ln107">}</a>
<a name="ln108"> </a>
<a name="ln109">// This needs to be called by a client app before performing any operations that could result in</a>
<a name="ln110">// logging.</a>
<a name="ln111">void InitLogging();</a>
<a name="ln112"> </a>
<a name="ln113">//</a>
<a name="ln114">// Installs a callback for internal client logging. It is invoked for a</a>
<a name="ln115">// log event of any severity, across any YBClient instance.</a>
<a name="ln116">//</a>
<a name="ln117">// Only the first invocation has any effect; subsequent invocations are</a>
<a name="ln118">// a no-op. The caller must ensure that 'cb' stays alive until</a>
<a name="ln119">// UninstallLoggingCallback() is called.</a>
<a name="ln120">//</a>
<a name="ln121">// Before a callback is registered, all internal client log events are</a>
<a name="ln122">// logged to stderr.</a>
<a name="ln123">void InstallLoggingCallback(YBLoggingCallback* cb);</a>
<a name="ln124"> </a>
<a name="ln125">// Removes a callback installed via InstallLoggingCallback().</a>
<a name="ln126">//</a>
<a name="ln127">// Only the first invocation has any effect; subsequent invocations are</a>
<a name="ln128">// a no-op.</a>
<a name="ln129">//</a>
<a name="ln130">// Should be called before unloading the client library.</a>
<a name="ln131">void UninstallLoggingCallback();</a>
<a name="ln132"> </a>
<a name="ln133">// Set the logging verbosity of the client library. By default, this is 0. Logs become</a>
<a name="ln134">// progressively more verbose as the level is increased. Empirically, the highest</a>
<a name="ln135">// verbosity level used in YB is 6, which includes very fine-grained tracing</a>
<a name="ln136">// information. Most useful logging is enabled at level 1 or 2, with the higher levels</a>
<a name="ln137">// used only in rare circumstances.</a>
<a name="ln138">//</a>
<a name="ln139">// Logs are emitted to stderr, or to the configured log callback at SEVERITY_INFO.</a>
<a name="ln140">//</a>
<a name="ln141">// This may be called safely at any point during usage of the library.</a>
<a name="ln142">void SetVerboseLogLevel(int level);</a>
<a name="ln143"> </a>
<a name="ln144">// The YB client library uses signals internally in some cases. By default, it uses</a>
<a name="ln145">// SIGUSR2. If your application makes use of SIGUSR2, this advanced API can help</a>
<a name="ln146">// workaround conflicts.</a>
<a name="ln147">Status SetInternalSignalNumber(int signum);</a>
<a name="ln148"> </a>
<a name="ln149">using MasterAddressSource = std::function&lt;std::vector&lt;std::string&gt;()&gt;;</a>
<a name="ln150"> </a>
<a name="ln151">// Creates a new YBClient with the desired options.</a>
<a name="ln152">//</a>
<a name="ln153">// Note that YBClients are shared amongst multiple threads and, as such,</a>
<a name="ln154">// are stored in shared pointers.</a>
<a name="ln155">class YBClientBuilder {</a>
<a name="ln156"> public:</a>
<a name="ln157">  YBClientBuilder();</a>
<a name="ln158">  ~YBClientBuilder();</a>
<a name="ln159"> </a>
<a name="ln160">  YBClientBuilder&amp; clear_master_server_addrs();</a>
<a name="ln161"> </a>
<a name="ln162">  // Add RPC addresses of multiple masters.</a>
<a name="ln163">  YBClientBuilder&amp; master_server_addrs(const std::vector&lt;std::string&gt;&amp; addrs);</a>
<a name="ln164"> </a>
<a name="ln165">  // Add a REST endpoint from which the address of the masters can be queried initially, and</a>
<a name="ln166">  // refreshed in case of retries. Note that the endpoint mechanism overrides</a>
<a name="ln167">  // both 'add_master_server_addr_file' and 'add_master_server_addr'.</a>
<a name="ln168">  YBClientBuilder&amp; add_master_server_endpoint(const std::string&amp; endpoint);</a>
<a name="ln169"> </a>
<a name="ln170">  // Add an RPC address of a master. At least one master is required.</a>
<a name="ln171">  YBClientBuilder&amp; add_master_server_addr(const std::string&amp; addr);</a>
<a name="ln172"> </a>
<a name="ln173">  // Don't override master addresses with external information from FLAGS_flagfile.</a>
<a name="ln174">  YBClientBuilder&amp; skip_master_flagfile(bool should_skip = true);</a>
<a name="ln175"> </a>
<a name="ln176">  // The default timeout used for administrative operations (e.g. CreateTable,</a>
<a name="ln177">  // AlterTable, ...). Optional.</a>
<a name="ln178">  //</a>
<a name="ln179">  // If not provided, defaults to 10s.</a>
<a name="ln180">  YBClientBuilder&amp; default_admin_operation_timeout(const MonoDelta&amp; timeout);</a>
<a name="ln181"> </a>
<a name="ln182">  // The default timeout for individual RPCs. Optional.</a>
<a name="ln183">  //</a>
<a name="ln184">  // If not provided, defaults to 5s.</a>
<a name="ln185">  YBClientBuilder&amp; default_rpc_timeout(const MonoDelta&amp; timeout);</a>
<a name="ln186"> </a>
<a name="ln187">  // Set the number of reactor threads that are used to send out the requests.</a>
<a name="ln188">  // (defaults to the flag value yb_client_num_reactors : 16).</a>
<a name="ln189">  YBClientBuilder&amp; set_num_reactors(int32_t num_reactors);</a>
<a name="ln190"> </a>
<a name="ln191">  // Sets the cloud info for the client, indicating where the client is located.</a>
<a name="ln192">  YBClientBuilder&amp; set_cloud_info_pb(const CloudInfoPB&amp; cloud_info_pb);</a>
<a name="ln193"> </a>
<a name="ln194">  // Sets metric entity to be used for emitting metrics. Optional.</a>
<a name="ln195">  YBClientBuilder&amp; set_metric_entity(const scoped_refptr&lt;MetricEntity&gt;&amp; metric_entity);</a>
<a name="ln196"> </a>
<a name="ln197">  // Sets client name to be used for naming the client's messenger/reactors.</a>
<a name="ln198">  YBClientBuilder&amp; set_client_name(const std::string&amp; name);</a>
<a name="ln199"> </a>
<a name="ln200">  // Sets the size of the threadpool for calling callbacks.</a>
<a name="ln201">  YBClientBuilder&amp; set_callback_threadpool_size(size_t size);</a>
<a name="ln202"> </a>
<a name="ln203">  YBClientBuilder&amp; wait_for_leader_election_on_init(bool should_wait = true);</a>
<a name="ln204"> </a>
<a name="ln205">  // Sets skip master leader resolution.</a>
<a name="ln206">  // Used in tests, when we do not have real master.</a>
<a name="ln207">  YBClientBuilder&amp; set_skip_master_leader_resolution(bool value);</a>
<a name="ln208"> </a>
<a name="ln209">  // Sets the tserver uuid for the client used by the CQL proxy. Intended only for use by CQL</a>
<a name="ln210">  // proxy clients.</a>
<a name="ln211">  YBClientBuilder&amp; set_tserver_uuid(const TabletServerId&amp; uuid);</a>
<a name="ln212"> </a>
<a name="ln213">  YBClientBuilder&amp; set_parent_mem_tracker(const std::shared_ptr&lt;MemTracker&gt;&amp; mem_tracker);</a>
<a name="ln214"> </a>
<a name="ln215">  YBClientBuilder&amp; set_master_address_flag_name(const std::string&amp; value);</a>
<a name="ln216"> </a>
<a name="ln217">  YBClientBuilder&amp; AddMasterAddressSource(const MasterAddressSource&amp; source);</a>
<a name="ln218"> </a>
<a name="ln219">  // Creates the client.</a>
<a name="ln220">  // Will use specified messenger if not nullptr.</a>
<a name="ln221">  // If messenger is nullptr - messenger will be created and owned by client. Client will shutdown</a>
<a name="ln222">  // messenger on client shutdown.</a>
<a name="ln223">  //</a>
<a name="ln224">  // The return value may indicate an error in the create operation, or a</a>
<a name="ln225">  // misuse of the builder; in the latter case, only the last error is</a>
<a name="ln226">  // returned.</a>
<a name="ln227">  Result&lt;std::unique_ptr&lt;YBClient&gt;&gt; Build(rpc::Messenger* messenger = nullptr);</a>
<a name="ln228"> </a>
<a name="ln229">  // Creates the client which gets the messenger ownership and shuts it down on client shutdown.</a>
<a name="ln230">  Result&lt;std::unique_ptr&lt;YBClient&gt;&gt; Build(std::unique_ptr&lt;rpc::Messenger&gt;&amp;&amp; messenger);</a>
<a name="ln231"> </a>
<a name="ln232"> private:</a>
<a name="ln233">  class Data;</a>
<a name="ln234"> </a>
<a name="ln235">  CHECKED_STATUS DoBuild(rpc::Messenger* messenger, std::unique_ptr&lt;client::YBClient&gt;* client);</a>
<a name="ln236"> </a>
<a name="ln237">  std::unique_ptr&lt;Data&gt; data_;</a>
<a name="ln238"> </a>
<a name="ln239">  DISALLOW_COPY_AND_ASSIGN(YBClientBuilder);</a>
<a name="ln240">};</a>
<a name="ln241"> </a>
<a name="ln242">// The YBClient represents a connection to a cluster. From the user</a>
<a name="ln243">// perspective, they should only need to create one of these in their</a>
<a name="ln244">// application, likely a singleton -- but it's not a singleton in YB in any</a>
<a name="ln245">// way. Different Client objects do not interact with each other -- no</a>
<a name="ln246">// connection pooling, etc. Each YBClient instance is sandboxed with no</a>
<a name="ln247">// global cross-client state.</a>
<a name="ln248">//</a>
<a name="ln249">// In the implementation, the client holds various pieces of common</a>
<a name="ln250">// infrastructure which is not table-specific:</a>
<a name="ln251">//</a>
<a name="ln252">// - RPC messenger: reactor threads and RPC connections are pooled here</a>
<a name="ln253">// - Authentication: the client is initialized with some credentials, and</a>
<a name="ln254">//   all accesses through it share those credentials.</a>
<a name="ln255">// - Caches: caches of table schemas, tablet locations, tablet server IP</a>
<a name="ln256">//   addresses, etc are shared per-client.</a>
<a name="ln257">//</a>
<a name="ln258">// In order to actually access data on the cluster, callers must first</a>
<a name="ln259">// create a YBSession object using NewSession(). A YBClient may</a>
<a name="ln260">// have several associated sessions.</a>
<a name="ln261">//</a>
<a name="ln262">// TODO: Cluster administration functions are likely to be in this class</a>
<a name="ln263">// as well.</a>
<a name="ln264">//</a>
<a name="ln265">// This class is thread-safe.</a>
<a name="ln266">class YBClient {</a>
<a name="ln267"> public:</a>
<a name="ln268">  ~YBClient();</a>
<a name="ln269"> </a>
<a name="ln270">  std::unique_ptr&lt;YBTableCreator&gt; NewTableCreator();</a>
<a name="ln271"> </a>
<a name="ln272">  // set 'create_in_progress' to true if a CreateTable operation is in-progress.</a>
<a name="ln273">  CHECKED_STATUS IsCreateTableInProgress(const YBTableName&amp; table_name,</a>
<a name="ln274">                                         bool *create_in_progress);</a>
<a name="ln275"> </a>
<a name="ln276">  // Wait for create table to finish.</a>
<a name="ln277">  CHECKED_STATUS WaitForCreateTableToFinish(const YBTableName&amp; table_name);</a>
<a name="ln278">  CHECKED_STATUS WaitForCreateTableToFinish(const YBTableName&amp; table_name,</a>
<a name="ln279">                                            const CoarseTimePoint&amp; deadline);</a>
<a name="ln280"> </a>
<a name="ln281">  CHECKED_STATUS WaitForCreateTableToFinish(const string&amp; table_id);</a>
<a name="ln282">  CHECKED_STATUS WaitForCreateTableToFinish(const string&amp; table_id,</a>
<a name="ln283">                                            const CoarseTimePoint&amp; deadline);</a>
<a name="ln284"> </a>
<a name="ln285">  // Truncate the specified table.</a>
<a name="ln286">  // Set 'wait' to true if the call must wait for the table to be fully truncated before returning.</a>
<a name="ln287">  CHECKED_STATUS TruncateTable(const std::string&amp; table_id, bool wait = true);</a>
<a name="ln288">  CHECKED_STATUS TruncateTables(const std::vector&lt;std::string&gt;&amp; table_ids, bool wait = true);</a>
<a name="ln289"> </a>
<a name="ln290">  // Delete the specified table.</a>
<a name="ln291">  // Set 'wait' to true if the call must wait for the table to be fully deleted before returning.</a>
<a name="ln292">  CHECKED_STATUS DeleteTable(const YBTableName&amp; table_name, bool wait = true);</a>
<a name="ln293">  CHECKED_STATUS DeleteTable(const std::string&amp; table_id, bool wait = true);</a>
<a name="ln294"> </a>
<a name="ln295">  // Delete the specified index table.</a>
<a name="ln296">  // Set 'wait' to true if the call must wait for the table to be fully deleted before returning.</a>
<a name="ln297">  CHECKED_STATUS DeleteIndexTable(const YBTableName&amp; table_name,</a>
<a name="ln298">                                  YBTableName* indexed_table_name = nullptr,</a>
<a name="ln299">                                  bool wait = true);</a>
<a name="ln300"> </a>
<a name="ln301">  CHECKED_STATUS DeleteIndexTable(const std::string&amp; table_id,</a>
<a name="ln302">                                  YBTableName* indexed_table_name = nullptr,</a>
<a name="ln303">                                  bool wait = true);</a>
<a name="ln304"> </a>
<a name="ln305">  // Flush or compact the specified tables.</a>
<a name="ln306">  CHECKED_STATUS FlushTables(const std::vector&lt;TableId&gt;&amp; table_ids,</a>
<a name="ln307">                             bool add_indexes,</a>
<a name="ln308">                             int timeout_secs,</a>
<a name="ln309">                             bool is_compaction);</a>
<a name="ln310">  CHECKED_STATUS FlushTables(const std::vector&lt;YBTableName&gt;&amp; table_names,</a>
<a name="ln311">                             bool add_indexes,</a>
<a name="ln312">                             int timeout_secs,</a>
<a name="ln313">                             bool is_compaction);</a>
<a name="ln314"> </a>
<a name="ln315">  std::unique_ptr&lt;YBTableAlterer&gt; NewTableAlterer(const YBTableName&amp; table_name);</a>
<a name="ln316">  std::unique_ptr&lt;YBTableAlterer&gt; NewTableAlterer(const string id);</a>
<a name="ln317"> </a>
<a name="ln318">  // Set 'alter_in_progress' to true if an AlterTable operation is in-progress.</a>
<a name="ln319">  CHECKED_STATUS IsAlterTableInProgress(const YBTableName&amp; table_name,</a>
<a name="ln320">                                        const string&amp; table_id,</a>
<a name="ln321">                                        bool *alter_in_progress);</a>
<a name="ln322"> </a>
<a name="ln323">  CHECKED_STATUS GetTableSchema(const YBTableName&amp; table_name,</a>
<a name="ln324">                                YBSchema* schema,</a>
<a name="ln325">                                PartitionSchema* partition_schema);</a>
<a name="ln326">  Result&lt;YBTableInfo&gt; GetYBTableInfo(const YBTableName&amp; table_name);</a>
<a name="ln327"> </a>
<a name="ln328">  CHECKED_STATUS GetTableSchemaById(const TableId&amp; table_id, std::shared_ptr&lt;YBTableInfo&gt; info,</a>
<a name="ln329">                                    StatusCallback callback);</a>
<a name="ln330"> </a>
<a name="ln331">  Result&lt;IndexPermissions&gt; GetIndexPermissions(</a>
<a name="ln332">      const TableId&amp; table_id,</a>
<a name="ln333">      const TableId&amp; index_id);</a>
<a name="ln334">  Result&lt;IndexPermissions&gt; GetIndexPermissions(</a>
<a name="ln335">      const YBTableName&amp; table_name,</a>
<a name="ln336">      const YBTableName&amp; index_name);</a>
<a name="ln337">  Result&lt;IndexPermissions&gt; WaitUntilIndexPermissionsAtLeast(</a>
<a name="ln338">      const TableId&amp; table_id,</a>
<a name="ln339">      const TableId&amp; index_id,</a>
<a name="ln340">      const IndexPermissions&amp; target_index_permissions);</a>
<a name="ln341">  Result&lt;IndexPermissions&gt; WaitUntilIndexPermissionsAtLeast(</a>
<a name="ln342">      const YBTableName&amp; table_name,</a>
<a name="ln343">      const YBTableName&amp; index_name,</a>
<a name="ln344">      const IndexPermissions&amp; target_index_permissions);</a>
<a name="ln345"> </a>
<a name="ln346">  // Trigger an async index permissions update after new YSQL index permissions are committed.</a>
<a name="ln347">  Status AsyncUpdateIndexPermissions(const TableId&amp; indexed_table_id);</a>
<a name="ln348"> </a>
<a name="ln349">  // Namespace related methods.</a>
<a name="ln350"> </a>
<a name="ln351">  // Create a new namespace with the given name.</a>
<a name="ln352">  // TODO(neil) When database_type is undefined, backend will not check error on database type.</a>
<a name="ln353">  // Except for testing we should use proper database_types for all creations.</a>
<a name="ln354">  CHECKED_STATUS CreateNamespace(const std::string&amp; namespace_name,</a>
<a name="ln355">                                 const boost::optional&lt;YQLDatabase&gt;&amp; database_type = boost::none,</a>
<a name="ln356">                                 const std::string&amp; creator_role_name = &quot;&quot;,</a>
<a name="ln357">                                 const std::string&amp; namespace_id = &quot;&quot;,</a>
<a name="ln358">                                 const std::string&amp; source_namespace_id = &quot;&quot;,</a>
<a name="ln359">                                 const boost::optional&lt;uint32_t&gt;&amp; next_pg_oid = boost::none,</a>
<a name="ln360">                                 const bool colocated = false);</a>
<a name="ln361"> </a>
<a name="ln362">  // It calls CreateNamespace(), but before it checks that the namespace has NOT been yet</a>
<a name="ln363">  // created. So, it prevents error 'namespace already exists'.</a>
<a name="ln364">  // TODO(neil) When database_type is undefined, backend will not check error on database type.</a>
<a name="ln365">  // Except for testing we should use proper database_types for all creations.</a>
<a name="ln366">  CHECKED_STATUS CreateNamespaceIfNotExists(const std::string&amp; namespace_name,</a>
<a name="ln367">                                            const boost::optional&lt;YQLDatabase&gt;&amp; database_type =</a>
<a name="ln368">                                            boost::none,</a>
<a name="ln369">                                            const std::string&amp; creator_role_name = &quot;&quot;,</a>
<a name="ln370">                                            const std::string&amp; namespace_id = &quot;&quot;,</a>
<a name="ln371">                                            const std::string&amp; source_namespace_id = &quot;&quot;,</a>
<a name="ln372">                                            const boost::optional&lt;uint32_t&gt;&amp; next_pg_oid =</a>
<a name="ln373">                                            boost::none,</a>
<a name="ln374">                                            const bool colocated = false);</a>
<a name="ln375"> </a>
<a name="ln376">  // Set 'create_in_progress' to true if a CreateNamespace operation is in-progress.</a>
<a name="ln377">  CHECKED_STATUS IsCreateNamespaceInProgress(const std::string&amp; namespace_name,</a>
<a name="ln378">                                             const boost::optional&lt;YQLDatabase&gt;&amp; database_type,</a>
<a name="ln379">                                             const std::string&amp; namespace_id,</a>
<a name="ln380">                                             bool *create_in_progress);</a>
<a name="ln381"> </a>
<a name="ln382">  // Delete namespace with the given name.</a>
<a name="ln383">  CHECKED_STATUS DeleteNamespace(const std::string&amp; namespace_name,</a>
<a name="ln384">                                 const boost::optional&lt;YQLDatabase&gt;&amp; database_type = boost::none,</a>
<a name="ln385">                                 const std::string&amp; namespace_id = &quot;&quot;);</a>
<a name="ln386"> </a>
<a name="ln387">  // Set 'delete_in_progress' to true if a DeleteNamespace operation is in-progress.</a>
<a name="ln388">  CHECKED_STATUS IsDeleteNamespaceInProgress(const std::string&amp; namespace_name,</a>
<a name="ln389">                                             const boost::optional&lt;YQLDatabase&gt;&amp; database_type,</a>
<a name="ln390">                                             const std::string&amp; namespace_id,</a>
<a name="ln391">                                             bool *delete_in_progress);</a>
<a name="ln392"> </a>
<a name="ln393">  YBNamespaceAlterer* NewNamespaceAlterer(const string&amp; namespace_name,</a>
<a name="ln394">                                          const std::string&amp; namespace_id);</a>
<a name="ln395"> </a>
<a name="ln396">  // For Postgres: reserve oids for a Postgres database.</a>
<a name="ln397">  CHECKED_STATUS ReservePgsqlOids(const std::string&amp; namespace_id,</a>
<a name="ln398">                                  uint32_t next_oid, uint32_t count,</a>
<a name="ln399">                                  uint32_t* begin_oid, uint32_t* end_oid);</a>
<a name="ln400"> </a>
<a name="ln401">  CHECKED_STATUS GetYsqlCatalogMasterVersion(uint64_t *ysql_catalog_version);</a>
<a name="ln402"> </a>
<a name="ln403">  // Grant permission with given arguments.</a>
<a name="ln404">  CHECKED_STATUS GrantRevokePermission(GrantRevokeStatementType statement_type,</a>
<a name="ln405">                                       const PermissionType&amp; permission,</a>
<a name="ln406">                                       const ResourceType&amp; resource_type,</a>
<a name="ln407">                                       const std::string&amp; canonical_resource,</a>
<a name="ln408">                                       const char* resource_name,</a>
<a name="ln409">                                       const char* namespace_name,</a>
<a name="ln410">                                       const std::string&amp; role_name);</a>
<a name="ln411"> </a>
<a name="ln412">  // List all namespace identifiers.</a>
<a name="ln413">  Result&lt;vector&lt;master::NamespaceIdentifierPB&gt;&gt; ListNamespaces() {</a>
<a name="ln414">    return ListNamespaces(boost::none);</a>
<a name="ln415">  }</a>
<a name="ln416"> </a>
<a name="ln417">  Result&lt;vector&lt;master::NamespaceIdentifierPB&gt;&gt; ListNamespaces(</a>
<a name="ln418">      const boost::optional&lt;YQLDatabase&gt;&amp; database_type);</a>
<a name="ln419"> </a>
<a name="ln420">  // Get namespace information.</a>
<a name="ln421">  CHECKED_STATUS GetNamespaceInfo(const std::string&amp; namespace_id,</a>
<a name="ln422">                                  const std::string&amp; namespace_name,</a>
<a name="ln423">                                  const boost::optional&lt;YQLDatabase&gt;&amp; database_type,</a>
<a name="ln424">                                  master::GetNamespaceInfoResponsePB* ret);</a>
<a name="ln425"> </a>
<a name="ln426">  // Check if the namespace given by 'namespace_name' or 'namespace_id' exists.</a>
<a name="ln427">  // Result value is set only on success.</a>
<a name="ln428">  Result&lt;bool&gt; NamespaceExists(const std::string&amp; namespace_name,</a>
<a name="ln429">                               const boost::optional&lt;YQLDatabase&gt;&amp; database_type = boost::none);</a>
<a name="ln430">  Result&lt;bool&gt; NamespaceIdExists(const std::string&amp; namespace_id,</a>
<a name="ln431">                                 const boost::optional&lt;YQLDatabase&gt;&amp; database_type = boost::none);</a>
<a name="ln432"> </a>
<a name="ln433">  // Create a new tablegroup.</a>
<a name="ln434">  CHECKED_STATUS CreateTablegroup(const std::string&amp; namespace_name,</a>
<a name="ln435">                                  const std::string&amp; namespace_id,</a>
<a name="ln436">                                  const std::string&amp; tablegroup_id);</a>
<a name="ln437"> </a>
<a name="ln438">  // Delete a tablegroup.</a>
<a name="ln439">  CHECKED_STATUS DeleteTablegroup(const std::string&amp; namespace_id,</a>
<a name="ln440">                                  const std::string&amp; tablegroup_id);</a>
<a name="ln441"> </a>
<a name="ln442">  // Check if the tablegroup given by 'tablegroup_id' exists.</a>
<a name="ln443">  // Result value is set only on success.</a>
<a name="ln444">  Result&lt;bool&gt; TablegroupExists(const std::string&amp; namespace_name,</a>
<a name="ln445">                                const std::string&amp; tablegroup_id);</a>
<a name="ln446">  Result&lt;vector&lt;master::TablegroupIdentifierPB&gt;&gt; ListTablegroups(const std::string&amp; namespace_name);</a>
<a name="ln447"> </a>
<a name="ln448">  // Authentication and Authorization</a>
<a name="ln449">  // Create a new role.</a>
<a name="ln450">  CHECKED_STATUS CreateRole(const RoleName&amp; role_name,</a>
<a name="ln451">                            const std::string&amp; salted_hash,</a>
<a name="ln452">                            const bool login, const bool superuser,</a>
<a name="ln453">                            const RoleName&amp; creator_role_name);</a>
<a name="ln454"> </a>
<a name="ln455">  // Alter an existing role.</a>
<a name="ln456">  CHECKED_STATUS AlterRole(const RoleName&amp; role_name,</a>
<a name="ln457">                           const boost::optional&lt;std::string&gt;&amp; salted_hash,</a>
<a name="ln458">                           const boost::optional&lt;bool&gt; login,</a>
<a name="ln459">                           const boost::optional&lt;bool&gt; superuser,</a>
<a name="ln460">                           const RoleName&amp; current_role_name);</a>
<a name="ln461"> </a>
<a name="ln462">  // Delete a role.</a>
<a name="ln463">  CHECKED_STATUS DeleteRole(const std::string&amp; role_name, const std::string&amp; current_role_name);</a>
<a name="ln464"> </a>
<a name="ln465">  CHECKED_STATUS SetRedisPasswords(const vector&lt;string&gt;&amp; passwords);</a>
<a name="ln466">  // Fetches the password from the local cache, or from the master if the local cached value</a>
<a name="ln467">  // is too old.</a>
<a name="ln468">  CHECKED_STATUS GetRedisPasswords(vector&lt;string&gt;* passwords);</a>
<a name="ln469"> </a>
<a name="ln470">  CHECKED_STATUS SetRedisConfig(const string&amp; key, const vector&lt;string&gt;&amp; values);</a>
<a name="ln471">  CHECKED_STATUS GetRedisConfig(const string&amp; key, vector&lt;string&gt;* values);</a>
<a name="ln472"> </a>
<a name="ln473">  // Grants a role to another role, or revokes a role from another role.</a>
<a name="ln474">  CHECKED_STATUS GrantRevokeRole(GrantRevokeStatementType statement_type,</a>
<a name="ln475">                                 const std::string&amp; granted_role_name,</a>
<a name="ln476">                                 const std::string&amp; recipient_role_name);</a>
<a name="ln477"> </a>
<a name="ln478">  // Get all the roles' permissions from the master only if the master's permissions version is</a>
<a name="ln479">  // greater than permissions_cache-&gt;version().s</a>
<a name="ln480">  CHECKED_STATUS GetPermissions(client::internal::PermissionsCache* permissions_cache);</a>
<a name="ln481"> </a>
<a name="ln482">  // (User-defined) type related methods.</a>
<a name="ln483"> </a>
<a name="ln484">  // Create a new (user-defined) type.</a>
<a name="ln485">  CHECKED_STATUS CreateUDType(const std::string &amp;namespace_name,</a>
<a name="ln486">                              const std::string &amp;type_name,</a>
<a name="ln487">                              const std::vector&lt;std::string&gt; &amp;field_names,</a>
<a name="ln488">                              const std::vector&lt;std::shared_ptr&lt;QLType&gt;&gt; &amp;field_types);</a>
<a name="ln489"> </a>
<a name="ln490">  // Delete a (user-defined) type by name.</a>
<a name="ln491">  CHECKED_STATUS DeleteUDType(const std::string &amp;namespace_name, const std::string &amp;type_name);</a>
<a name="ln492"> </a>
<a name="ln493">  // Retrieve a (user-defined) type by name.</a>
<a name="ln494">  CHECKED_STATUS GetUDType(const std::string &amp;namespace_name,</a>
<a name="ln495">                           const std::string &amp;type_name,</a>
<a name="ln496">                           std::shared_ptr&lt;QLType&gt; *ql_type);</a>
<a name="ln497"> </a>
<a name="ln498">  // CDC Stream related methods.</a>
<a name="ln499"> </a>
<a name="ln500">  // Create a new CDC stream.</a>
<a name="ln501">  Result&lt;CDCStreamId&gt; CreateCDCStream(const TableId&amp; table_id,</a>
<a name="ln502">                                      const std::unordered_map&lt;std::string, std::string&gt;&amp; options);</a>
<a name="ln503"> </a>
<a name="ln504">  void CreateCDCStream(const TableId&amp; table_id,</a>
<a name="ln505">                       const std::unordered_map&lt;std::string, std::string&gt;&amp; options,</a>
<a name="ln506">                       CreateCDCStreamCallback callback);</a>
<a name="ln507"> </a>
<a name="ln508">  // Delete multiple CDC streams.</a>
<a name="ln509">  CHECKED_STATUS DeleteCDCStream(const vector&lt;CDCStreamId&gt;&amp; streams);</a>
<a name="ln510"> </a>
<a name="ln511">  // Delete a CDC stream.</a>
<a name="ln512">  CHECKED_STATUS DeleteCDCStream(const CDCStreamId&amp; stream_id);</a>
<a name="ln513"> </a>
<a name="ln514">  void DeleteCDCStream(const CDCStreamId&amp; stream_id, StatusCallback callback);</a>
<a name="ln515"> </a>
<a name="ln516">  // Retrieve a CDC stream.</a>
<a name="ln517">  CHECKED_STATUS GetCDCStream(const CDCStreamId &amp;stream_id,</a>
<a name="ln518">                              TableId* table_id,</a>
<a name="ln519">                              std::unordered_map&lt;std::string, std::string&gt;* options);</a>
<a name="ln520"> </a>
<a name="ln521">  void GetCDCStream(const CDCStreamId&amp; stream_id,</a>
<a name="ln522">                    std::shared_ptr&lt;TableId&gt; table_id,</a>
<a name="ln523">                    std::shared_ptr&lt;std::unordered_map&lt;std::string, std::string&gt;&gt; options,</a>
<a name="ln524">                    StdStatusCallback callback);</a>
<a name="ln525"> </a>
<a name="ln526">  // Find the number of tservers. This function should not be called frequently for reading or</a>
<a name="ln527">  // writing actual data. Currently, it is called only for SQL DDL statements.</a>
<a name="ln528">  // If primary_only is set to true, we expect the primary/sync cluster tserver count only.</a>
<a name="ln529">  // If use_cache is set to true, we return old value.</a>
<a name="ln530">  CHECKED_STATUS TabletServerCount(int *tserver_count, bool primary_only = false,</a>
<a name="ln531">      bool use_cache = false);</a>
<a name="ln532"> </a>
<a name="ln533">  CHECKED_STATUS ListTabletServers(std::vector&lt;std::unique_ptr&lt;YBTabletServer&gt;&gt;* tablet_servers);</a>
<a name="ln534"> </a>
<a name="ln535">  // Sets local tserver and its proxy.</a>
<a name="ln536">  void SetLocalTabletServer(const std::string&amp; ts_uuid,</a>
<a name="ln537">                            const std::shared_ptr&lt;tserver::TabletServerServiceProxy&gt;&amp; proxy,</a>
<a name="ln538">                            const tserver::LocalTabletServer* local_tserver);</a>
<a name="ln539"> </a>
<a name="ln540">  // List only those tables whose names pass a substring match on 'filter'.</a>
<a name="ln541">  //</a>
<a name="ln542">  // 'tables' is appended to only on success.</a>
<a name="ln543">  Result&lt;std::vector&lt;YBTableName&gt;&gt; ListTables(</a>
<a name="ln544">      const std::string&amp; filter = &quot;&quot;,</a>
<a name="ln545">      bool exclude_ysql = false);</a>
<a name="ln546"> </a>
<a name="ln547">  // List all running tablets' uuids for this table.</a>
<a name="ln548">  // 'tablets' is appended to only on success.</a>
<a name="ln549">  CHECKED_STATUS GetTablets(</a>
<a name="ln550">      const YBTableName&amp; table_name,</a>
<a name="ln551">      const int32_t max_tablets,</a>
<a name="ln552">      std::vector&lt;TabletId&gt;* tablet_uuids,</a>
<a name="ln553">      std::vector&lt;std::string&gt;* ranges,</a>
<a name="ln554">      std::vector&lt;master::TabletLocationsPB&gt;* locations = nullptr,</a>
<a name="ln555">      RequireTabletsRunning require_tablets_running = RequireTabletsRunning::kFalse);</a>
<a name="ln556"> </a>
<a name="ln557">  CHECKED_STATUS GetTabletsAndUpdateCache(</a>
<a name="ln558">      const YBTableName&amp; table_name,</a>
<a name="ln559">      const int32_t max_tablets,</a>
<a name="ln560">      std::vector&lt;TabletId&gt;* tablet_uuids,</a>
<a name="ln561">      std::vector&lt;std::string&gt;* ranges,</a>
<a name="ln562">      std::vector&lt;master::TabletLocationsPB&gt;* locations);</a>
<a name="ln563"> </a>
<a name="ln564">  Status GetTabletsFromTableId(</a>
<a name="ln565">      const std::string&amp; table_id, const int32_t max_tablets,</a>
<a name="ln566">      google::protobuf::RepeatedPtrField&lt;master::TabletLocationsPB&gt;* tablets);</a>
<a name="ln567"> </a>
<a name="ln568">  CHECKED_STATUS GetTablets(</a>
<a name="ln569">      const YBTableName&amp; table_name,</a>
<a name="ln570">      const int32_t max_tablets,</a>
<a name="ln571">      google::protobuf::RepeatedPtrField&lt;master::TabletLocationsPB&gt;* tablets,</a>
<a name="ln572">      RequireTabletsRunning require_tablets_running = RequireTabletsRunning::kFalse);</a>
<a name="ln573"> </a>
<a name="ln574">  CHECKED_STATUS GetTabletLocation(const TabletId&amp; tablet_id,</a>
<a name="ln575">                                   master::TabletLocationsPB* tablet_location);</a>
<a name="ln576"> </a>
<a name="ln577">  // Get the list of master uuids. Can be enhanced later to also return port/host info.</a>
<a name="ln578">  CHECKED_STATUS ListMasters(</a>
<a name="ln579">    CoarseTimePoint deadline,</a>
<a name="ln580">    std::vector&lt;std::string&gt;* master_uuids);</a>
<a name="ln581"> </a>
<a name="ln582">  // Check if the table given by 'table_name' exists.</a>
<a name="ln583">  // Result value is set only on success.</a>
<a name="ln584">  Result&lt;bool&gt; TableExists(const YBTableName&amp; table_name);</a>
<a name="ln585"> </a>
<a name="ln586">  Result&lt;bool&gt; IsLoadBalanced(uint32_t num_servers);</a>
<a name="ln587">  Result&lt;bool&gt; IsLoadBalancerIdle();</a>
<a name="ln588"> </a>
<a name="ln589">  // Open the table with the given name or id. This will do an RPC to ensure that</a>
<a name="ln590">  // the table exists and look up its schema.</a>
<a name="ln591">  //</a>
<a name="ln592">  // TODO: should we offer an async version of this as well?</a>
<a name="ln593">  // TODO: probably should have a configurable timeout in YBClientBuilder?</a>
<a name="ln594">  CHECKED_STATUS OpenTable(const YBTableName&amp; table_name, std::shared_ptr&lt;YBTable&gt;* table);</a>
<a name="ln595">  CHECKED_STATUS OpenTable(const TableId&amp; table_id, std::shared_ptr&lt;YBTable&gt;* table);</a>
<a name="ln596"> </a>
<a name="ln597">  Result&lt;YBTablePtr&gt; OpenTable(const TableId&amp; table_id) {</a>
<a name="ln598">    YBTablePtr result;</a>
<a name="ln599">    RETURN_NOT_OK(OpenTable(table_id, &amp;result));</a>
<a name="ln600">    return result;</a>
<a name="ln601">  }</a>
<a name="ln602"> </a>
<a name="ln603">  Result&lt;YBTablePtr&gt; OpenTable(const YBTableName&amp; name) {</a>
<a name="ln604">    YBTablePtr result;</a>
<a name="ln605">    RETURN_NOT_OK(OpenTable(name, &amp;result));</a>
<a name="ln606">    return result;</a>
<a name="ln607">  }</a>
<a name="ln608"> </a>
<a name="ln609">  // Create a new session for interacting with the cluster.</a>
<a name="ln610">  // User is responsible for destroying the session object.</a>
<a name="ln611">  // This is a fully local operation (no RPCs or blocking).</a>
<a name="ln612">  std::shared_ptr&lt;YBSession&gt; NewSession();</a>
<a name="ln613"> </a>
<a name="ln614">  // Return the socket address of the master leader for this client.</a>
<a name="ln615">  HostPort GetMasterLeaderAddress();</a>
<a name="ln616"> </a>
<a name="ln617">  // Caller knows that the existing leader might have died or stepped down, so it can use this API</a>
<a name="ln618">  // to reset the client state to point to new master leader.</a>
<a name="ln619">  Result&lt;HostPort&gt; RefreshMasterLeaderAddress();</a>
<a name="ln620"> </a>
<a name="ln621">  // Once a config change is completed to add/remove a master, update the client to add/remove it</a>
<a name="ln622">  // from its own master address list.</a>
<a name="ln623">  CHECKED_STATUS AddMasterToClient(const HostPort&amp; add);</a>
<a name="ln624">  CHECKED_STATUS RemoveMasterFromClient(const HostPort&amp; remove);</a>
<a name="ln625">  CHECKED_STATUS SetMasterAddresses(const std::string&amp; addrs);</a>
<a name="ln626"> </a>
<a name="ln627">  // Policy with which to choose amongst multiple replicas.</a>
<a name="ln628">  enum ReplicaSelection {</a>
<a name="ln629">    // Select the LEADER replica.</a>
<a name="ln630">    LEADER_ONLY,</a>
<a name="ln631"> </a>
<a name="ln632">    // Select the closest replica to the client, or a random one if all</a>
<a name="ln633">    // replicas are equidistant.</a>
<a name="ln634">    CLOSEST_REPLICA,</a>
<a name="ln635"> </a>
<a name="ln636">    // Select the first replica in the list.</a>
<a name="ln637">    FIRST_REPLICA</a>
<a name="ln638">  };</a>
<a name="ln639"> </a>
<a name="ln640">  bool IsMultiMaster() const;</a>
<a name="ln641"> </a>
<a name="ln642">  // Get the number of tablets to be created for a new user table.</a>
<a name="ln643">  // This will be based on --num_shards_per_tserver or --ysql_num_shards_per_tserver</a>
<a name="ln644">  // and number of tservers.</a>
<a name="ln645">  Result&lt;int&gt; NumTabletsForUserTable(TableType table_type);</a>
<a name="ln646"> </a>
<a name="ln647">  void TEST_set_admin_operation_timeout(const MonoDelta&amp; timeout);</a>
<a name="ln648"> </a>
<a name="ln649">  const MonoDelta&amp; default_admin_operation_timeout() const;</a>
<a name="ln650">  const MonoDelta&amp; default_rpc_timeout() const;</a>
<a name="ln651"> </a>
<a name="ln652">  // Value for the latest observed hybrid_time when none has been observed or set.</a>
<a name="ln653">  static const uint64_t kNoHybridTime;</a>
<a name="ln654"> </a>
<a name="ln655">  // Returns highest hybrid_time observed by the client.</a>
<a name="ln656">  // The latest observed hybrid_time can be used to start a snapshot scan on a</a>
<a name="ln657">  // table which is guaranteed to contain all data written or previously read by</a>
<a name="ln658">  // this client.</a>
<a name="ln659">  uint64_t GetLatestObservedHybridTime() const;</a>
<a name="ln660"> </a>
<a name="ln661">  // Sets the latest observed hybrid_time, encoded in the HybridTime format.</a>
<a name="ln662">  // This is only useful when forwarding hybrid_times between clients to enforce</a>
<a name="ln663">  // external consistency when using YBSession::CLIENT_PROPAGATED external consistency</a>
<a name="ln664">  // mode.</a>
<a name="ln665">  // To use this the user must obtain the HybridTime encoded hybrid_time from the first</a>
<a name="ln666">  // client with YBClient::GetLatestObservedHybridTime() and the set it in the new</a>
<a name="ln667">  // client with this method.</a>
<a name="ln668">  void SetLatestObservedHybridTime(uint64_t ht_hybrid_time);</a>
<a name="ln669"> </a>
<a name="ln670">  // Given a host and port for a master, get the uuid of that process.</a>
<a name="ln671">  CHECKED_STATUS GetMasterUUID(const std::string&amp; host, int16_t port, std::string* uuid);</a>
<a name="ln672"> </a>
<a name="ln673">  CHECKED_STATUS SetReplicationInfo(const master::ReplicationInfoPB&amp; replication_info);</a>
<a name="ln674"> </a>
<a name="ln675">  void LookupTabletByKey(const YBTable* table,</a>
<a name="ln676">                         const std::string&amp; partition_key,</a>
<a name="ln677">                        CoarseTimePoint deadline,</a>
<a name="ln678">                         LookupTabletCallback callback);</a>
<a name="ln679"> </a>
<a name="ln680">  void LookupTabletById(const std::string&amp; tablet_id,</a>
<a name="ln681">                        CoarseTimePoint deadline,</a>
<a name="ln682">                        LookupTabletCallback callback,</a>
<a name="ln683">                        UseCache use_cache);</a>
<a name="ln684"> </a>
<a name="ln685">  rpc::Messenger* messenger() const;</a>
<a name="ln686"> </a>
<a name="ln687">  const scoped_refptr&lt;MetricEntity&gt;&amp; metric_entity() const;</a>
<a name="ln688"> </a>
<a name="ln689">  rpc::ProxyCache&amp; proxy_cache() const;</a>
<a name="ln690"> </a>
<a name="ln691">  const std::string&amp; proxy_uuid() const;</a>
<a name="ln692"> </a>
<a name="ln693">  // Id of this client instance.</a>
<a name="ln694">  const ClientId&amp; id() const;</a>
<a name="ln695"> </a>
<a name="ln696">  const CloudInfoPB&amp; cloud_info() const;</a>
<a name="ln697"> </a>
<a name="ln698">  std::pair&lt;RetryableRequestId, RetryableRequestId&gt; NextRequestIdAndMinRunningRequestId(</a>
<a name="ln699">      const TabletId&amp; tablet_id);</a>
<a name="ln700">  void RequestFinished(const TabletId&amp; tablet_id, RetryableRequestId request_id);</a>
<a name="ln701"> </a>
<a name="ln702">  void Shutdown();</a>
<a name="ln703"> </a>
<a name="ln704"> private:</a>
<a name="ln705">  class Data;</a>
<a name="ln706"> </a>
<a name="ln707">  friend class YBClientBuilder;</a>
<a name="ln708">  friend class YBNoOp;</a>
<a name="ln709">  friend class YBTable;</a>
<a name="ln710">  friend class YBTableAlterer;</a>
<a name="ln711">  friend class YBNamespaceAlterer;</a>
<a name="ln712">  friend class YBTableCreator;</a>
<a name="ln713">  friend class internal::Batcher;</a>
<a name="ln714">  friend class internal::GetTableSchemaRpc;</a>
<a name="ln715">  friend class internal::LookupRpc;</a>
<a name="ln716">  friend class internal::MetaCache;</a>
<a name="ln717">  friend class internal::RemoteTablet;</a>
<a name="ln718">  friend class internal::RemoteTabletServer;</a>
<a name="ln719">  friend class internal::AsyncRpc;</a>
<a name="ln720">  friend class internal::TabletInvoker;</a>
<a name="ln721">  friend class internal::ClientMasterRpc;</a>
<a name="ln722">  friend class internal::CreateCDCStreamRpc;</a>
<a name="ln723">  friend class internal::DeleteCDCStreamRpc;</a>
<a name="ln724">  friend class internal::GetCDCStreamRpc;</a>
<a name="ln725">  friend class PlacementInfoTest;</a>
<a name="ln726"> </a>
<a name="ln727">  FRIEND_TEST(ClientTest, TestGetTabletServerBlacklist);</a>
<a name="ln728">  FRIEND_TEST(ClientTest, TestMasterDown);</a>
<a name="ln729">  FRIEND_TEST(ClientTest, TestMasterLookupPermits);</a>
<a name="ln730">  FRIEND_TEST(ClientTest, TestReplicatedTabletWritesAndAltersWithLeaderElection);</a>
<a name="ln731">  FRIEND_TEST(ClientTest, TestScanFaultTolerance);</a>
<a name="ln732">  FRIEND_TEST(ClientTest, TestScanTimeout);</a>
<a name="ln733">  FRIEND_TEST(ClientTest, TestWriteWithDeadMaster);</a>
<a name="ln734">  FRIEND_TEST(MasterFailoverTest, DISABLED_TestPauseAfterCreateTableIssued);</a>
<a name="ln735">  FRIEND_TEST(MasterFailoverTestIndexCreation, TestPauseAfterCreateIndexIssued);</a>
<a name="ln736"> </a>
<a name="ln737">  friend std::future&lt;Result&lt;internal::RemoteTabletPtr&gt;&gt; LookupFirstTabletFuture(</a>
<a name="ln738">      const YBTable* table);</a>
<a name="ln739"> </a>
<a name="ln740">  YBClient();</a>
<a name="ln741"> </a>
<a name="ln742">  ThreadPool* callback_threadpool();</a>
<a name="ln743"> </a>
<a name="ln744">  std::unique_ptr&lt;Data&gt; data_;</a>
<a name="ln745"> </a>
<a name="ln746">  DISALLOW_COPY_AND_ASSIGN(YBClient);</a>
<a name="ln747">};</a>
<a name="ln748"> </a>
<a name="ln749">}  // namespace client</a>
<a name="ln750">}  // namespace yb</a>
<a name="ln751">#endif  // YB_CLIENT_CLIENT_H_</a>

</code></pre>
<div class="balloon" rel="83"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1043/" target="_blank">V1043</a> A global object variable 'kGrantRevokeStatementTypeList' is declared in the header. Multiple copies of it will be created in all translation units that include this header file.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
