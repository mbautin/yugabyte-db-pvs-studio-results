
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>iterators.hpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//////////////////////////////////////////////////////////////////////////////</a>
<a name="ln2">//</a>
<a name="ln3">// (C) Copyright Ion Gaztanaga 2005-2013.</a>
<a name="ln4">// (C) Copyright Gennaro Prota 2003 - 2004.</a>
<a name="ln5">//</a>
<a name="ln6">// Distributed under the Boost Software License, Version 1.0.</a>
<a name="ln7">// (See accompanying file LICENSE_1_0.txt or copy at</a>
<a name="ln8">// http://www.boost.org/LICENSE_1_0.txt)</a>
<a name="ln9">//</a>
<a name="ln10">// See http://www.boost.org/libs/container for documentation.</a>
<a name="ln11">//</a>
<a name="ln12">//////////////////////////////////////////////////////////////////////////////</a>
<a name="ln13"> </a>
<a name="ln14">#ifndef BOOST_CONTAINER_DETAIL_ITERATORS_HPP</a>
<a name="ln15">#define BOOST_CONTAINER_DETAIL_ITERATORS_HPP</a>
<a name="ln16"> </a>
<a name="ln17">#ifndef BOOST_CONFIG_HPP</a>
<a name="ln18">#  include &lt;boost/config.hpp&gt;</a>
<a name="ln19">#endif</a>
<a name="ln20"> </a>
<a name="ln21">#if defined(BOOST_HAS_PRAGMA_ONCE)</a>
<a name="ln22">#  pragma once</a>
<a name="ln23">#endif</a>
<a name="ln24"> </a>
<a name="ln25">#include &lt;boost/container/detail/config_begin.hpp&gt;</a>
<a name="ln26">#include &lt;boost/container/detail/workaround.hpp&gt;</a>
<a name="ln27">#include &lt;boost/container/allocator_traits.hpp&gt;</a>
<a name="ln28">#include &lt;boost/container/detail/type_traits.hpp&gt;</a>
<a name="ln29">#include &lt;boost/container/detail/value_init.hpp&gt;</a>
<a name="ln30">#include &lt;boost/static_assert.hpp&gt;</a>
<a name="ln31">#include &lt;boost/move/utility_core.hpp&gt;</a>
<a name="ln32">#include &lt;boost/intrusive/detail/reverse_iterator.hpp&gt;</a>
<a name="ln33"> </a>
<a name="ln34">#if defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES)</a>
<a name="ln35">#include &lt;boost/move/detail/fwd_macros.hpp&gt;</a>
<a name="ln36">#else</a>
<a name="ln37">#include &lt;boost/container/detail/variadic_templates_tools.hpp&gt;</a>
<a name="ln38">#endif</a>
<a name="ln39">#include &lt;boost/container/detail/iterator.hpp&gt;</a>
<a name="ln40"> </a>
<a name="ln41">namespace boost {</a>
<a name="ln42">namespace container {</a>
<a name="ln43"> </a>
<a name="ln44">template &lt;class T, class Difference = std::ptrdiff_t&gt;</a>
<a name="ln45">class constant_iterator</a>
<a name="ln46">  : public ::boost::container::iterator</a>
<a name="ln47">      &lt;std::random_access_iterator_tag, T, Difference, const T*, const T &amp;&gt;</a>
<a name="ln48">{</a>
<a name="ln49">   typedef  constant_iterator&lt;T, Difference&gt; this_type;</a>
<a name="ln50"> </a>
<a name="ln51">   public:</a>
<a name="ln52">   explicit constant_iterator(const T &amp;ref, Difference range_size)</a>
<a name="ln53">      :  m_ptr(&amp;ref), m_num(range_size){}</a>
<a name="ln54"> </a>
<a name="ln55">   //Constructors</a>
<a name="ln56">   constant_iterator()</a>
<a name="ln57">      :  m_ptr(0), m_num(0){}</a>
<a name="ln58"> </a>
<a name="ln59">   constant_iterator&amp; operator++()</a>
<a name="ln60">   { increment();   return *this;   }</a>
<a name="ln61"> </a>
<a name="ln62">   constant_iterator operator++(int)</a>
<a name="ln63">   {</a>
<a name="ln64">      constant_iterator result (*this);</a>
<a name="ln65">      increment();</a>
<a name="ln66">      return result;</a>
<a name="ln67">   }</a>
<a name="ln68"> </a>
<a name="ln69">   constant_iterator&amp; operator--()</a>
<a name="ln70">   { decrement();   return *this;   }</a>
<a name="ln71"> </a>
<a name="ln72">   constant_iterator operator--(int)</a>
<a name="ln73">   {</a>
<a name="ln74">      constant_iterator result (*this);</a>
<a name="ln75">      decrement();</a>
<a name="ln76">      return result;</a>
<a name="ln77">   }</a>
<a name="ln78"> </a>
<a name="ln79">   friend bool operator== (const constant_iterator&amp; i, const constant_iterator&amp; i2)</a>
<a name="ln80">   { return i.equal(i2); }</a>
<a name="ln81"> </a>
<a name="ln82">   friend bool operator!= (const constant_iterator&amp; i, const constant_iterator&amp; i2)</a>
<a name="ln83">   { return !(i == i2); }</a>
<a name="ln84"> </a>
<a name="ln85">   friend bool operator&lt; (const constant_iterator&amp; i, const constant_iterator&amp; i2)</a>
<a name="ln86">   { return i.less(i2); }</a>
<a name="ln87"> </a>
<a name="ln88">   friend bool operator&gt; (const constant_iterator&amp; i, const constant_iterator&amp; i2)</a>
<a name="ln89">   { return i2 &lt; i; }</a>
<a name="ln90"> </a>
<a name="ln91">   friend bool operator&lt;= (const constant_iterator&amp; i, const constant_iterator&amp; i2)</a>
<a name="ln92">   { return !(i &gt; i2); }</a>
<a name="ln93"> </a>
<a name="ln94">   friend bool operator&gt;= (const constant_iterator&amp; i, const constant_iterator&amp; i2)</a>
<a name="ln95">   { return !(i &lt; i2); }</a>
<a name="ln96"> </a>
<a name="ln97">   friend Difference operator- (const constant_iterator&amp; i, const constant_iterator&amp; i2)</a>
<a name="ln98">   { return i2.distance_to(i); }</a>
<a name="ln99"> </a>
<a name="ln100">   //Arithmetic</a>
<a name="ln101">   constant_iterator&amp; operator+=(Difference off)</a>
<a name="ln102">   {  this-&gt;advance(off); return *this;   }</a>
<a name="ln103"> </a>
<a name="ln104">   constant_iterator operator+(Difference off) const</a>
<a name="ln105">   {</a>
<a name="ln106">      constant_iterator other(*this);</a>
<a name="ln107">      other.advance(off);</a>
<a name="ln108">      return other;</a>
<a name="ln109">   }</a>
<a name="ln110"> </a>
<a name="ln111">   friend constant_iterator operator+(Difference off, const constant_iterator&amp; right)</a>
<a name="ln112">   {  return right + off; }</a>
<a name="ln113"> </a>
<a name="ln114">   constant_iterator&amp; operator-=(Difference off)</a>
<a name="ln115">   {  this-&gt;advance(-off); return *this;   }</a>
<a name="ln116"> </a>
<a name="ln117">   constant_iterator operator-(Difference off) const</a>
<a name="ln118">   {  return *this + (-off);  }</a>
<a name="ln119"> </a>
<a name="ln120">   const T&amp; operator*() const</a>
<a name="ln121">   { return dereference(); }</a>
<a name="ln122"> </a>
<a name="ln123">   const T&amp; operator[] (Difference ) const</a>
<a name="ln124">   { return dereference(); }</a>
<a name="ln125"> </a>
<a name="ln126">   const T* operator-&gt;() const</a>
<a name="ln127">   { return &amp;(dereference()); }</a>
<a name="ln128"> </a>
<a name="ln129">   private:</a>
<a name="ln130">   const T *   m_ptr;</a>
<a name="ln131">   Difference  m_num;</a>
<a name="ln132"> </a>
<a name="ln133">   void increment()</a>
<a name="ln134">   { --m_num; }</a>
<a name="ln135"> </a>
<a name="ln136">   void decrement()</a>
<a name="ln137">   { ++m_num; }</a>
<a name="ln138"> </a>
<a name="ln139">   bool equal(const this_type &amp;other) const</a>
<a name="ln140">   {  return m_num == other.m_num;   }</a>
<a name="ln141"> </a>
<a name="ln142">   bool less(const this_type &amp;other) const</a>
<a name="ln143">   {  return other.m_num &lt; m_num;   }</a>
<a name="ln144"> </a>
<a name="ln145">   const T &amp; dereference() const</a>
<a name="ln146">   { return *m_ptr; }</a>
<a name="ln147"> </a>
<a name="ln148">   void advance(Difference n)</a>
<a name="ln149">   {  m_num -= n; }</a>
<a name="ln150"> </a>
<a name="ln151">   Difference distance_to(const this_type &amp;other)const</a>
<a name="ln152">   {  return m_num - other.m_num;   }</a>
<a name="ln153">};</a>
<a name="ln154"> </a>
<a name="ln155">template &lt;class T, class Difference&gt;</a>
<a name="ln156">class value_init_construct_iterator</a>
<a name="ln157">  : public ::boost::container::iterator</a>
<a name="ln158">      &lt;std::random_access_iterator_tag, T, Difference, const T*, const T &amp;&gt;</a>
<a name="ln159">{</a>
<a name="ln160">   typedef  value_init_construct_iterator&lt;T, Difference&gt; this_type;</a>
<a name="ln161"> </a>
<a name="ln162">   public:</a>
<a name="ln163">   explicit value_init_construct_iterator(Difference range_size)</a>
<a name="ln164">      :  m_num(range_size){}</a>
<a name="ln165"> </a>
<a name="ln166">   //Constructors</a>
<a name="ln167">   value_init_construct_iterator()</a>
<a name="ln168">      :  m_num(0){}</a>
<a name="ln169"> </a>
<a name="ln170">   value_init_construct_iterator&amp; operator++()</a>
<a name="ln171">   { increment();   return *this;   }</a>
<a name="ln172"> </a>
<a name="ln173">   value_init_construct_iterator operator++(int)</a>
<a name="ln174">   {</a>
<a name="ln175">      value_init_construct_iterator result (*this);</a>
<a name="ln176">      increment();</a>
<a name="ln177">      return result;</a>
<a name="ln178">   }</a>
<a name="ln179"> </a>
<a name="ln180">   value_init_construct_iterator&amp; operator--()</a>
<a name="ln181">   { decrement();   return *this;   }</a>
<a name="ln182"> </a>
<a name="ln183">   value_init_construct_iterator operator--(int)</a>
<a name="ln184">   {</a>
<a name="ln185">      value_init_construct_iterator result (*this);</a>
<a name="ln186">      decrement();</a>
<a name="ln187">      return result;</a>
<a name="ln188">   }</a>
<a name="ln189"> </a>
<a name="ln190">   friend bool operator== (const value_init_construct_iterator&amp; i, const value_init_construct_iterator&amp; i2)</a>
<a name="ln191">   { return i.equal(i2); }</a>
<a name="ln192"> </a>
<a name="ln193">   friend bool operator!= (const value_init_construct_iterator&amp; i, const value_init_construct_iterator&amp; i2)</a>
<a name="ln194">   { return !(i == i2); }</a>
<a name="ln195"> </a>
<a name="ln196">   friend bool operator&lt; (const value_init_construct_iterator&amp; i, const value_init_construct_iterator&amp; i2)</a>
<a name="ln197">   { return i.less(i2); }</a>
<a name="ln198"> </a>
<a name="ln199">   friend bool operator&gt; (const value_init_construct_iterator&amp; i, const value_init_construct_iterator&amp; i2)</a>
<a name="ln200">   { return i2 &lt; i; }</a>
<a name="ln201"> </a>
<a name="ln202">   friend bool operator&lt;= (const value_init_construct_iterator&amp; i, const value_init_construct_iterator&amp; i2)</a>
<a name="ln203">   { return !(i &gt; i2); }</a>
<a name="ln204"> </a>
<a name="ln205">   friend bool operator&gt;= (const value_init_construct_iterator&amp; i, const value_init_construct_iterator&amp; i2)</a>
<a name="ln206">   { return !(i &lt; i2); }</a>
<a name="ln207"> </a>
<a name="ln208">   friend Difference operator- (const value_init_construct_iterator&amp; i, const value_init_construct_iterator&amp; i2)</a>
<a name="ln209">   { return i2.distance_to(i); }</a>
<a name="ln210"> </a>
<a name="ln211">   //Arithmetic</a>
<a name="ln212">   value_init_construct_iterator&amp; operator+=(Difference off)</a>
<a name="ln213">   {  this-&gt;advance(off); return *this;   }</a>
<a name="ln214"> </a>
<a name="ln215">   value_init_construct_iterator operator+(Difference off) const</a>
<a name="ln216">   {</a>
<a name="ln217">      value_init_construct_iterator other(*this);</a>
<a name="ln218">      other.advance(off);</a>
<a name="ln219">      return other;</a>
<a name="ln220">   }</a>
<a name="ln221"> </a>
<a name="ln222">   friend value_init_construct_iterator operator+(Difference off, const value_init_construct_iterator&amp; right)</a>
<a name="ln223">   {  return right + off; }</a>
<a name="ln224"> </a>
<a name="ln225">   value_init_construct_iterator&amp; operator-=(Difference off)</a>
<a name="ln226">   {  this-&gt;advance(-off); return *this;   }</a>
<a name="ln227"> </a>
<a name="ln228">   value_init_construct_iterator operator-(Difference off) const</a>
<a name="ln229">   {  return *this + (-off);  }</a>
<a name="ln230"> </a>
<a name="ln231">   //This pseudo-iterator's dereference operations have no sense since value is not</a>
<a name="ln232">   //constructed until ::boost::container::construct_in_place is called.</a>
<a name="ln233">   //So comment them to catch bad uses</a>
<a name="ln234">   //const T&amp; operator*() const;</a>
<a name="ln235">   //const T&amp; operator[](difference_type) const;</a>
<a name="ln236">   //const T* operator-&gt;() const;</a>
<a name="ln237"> </a>
<a name="ln238">   private:</a>
<a name="ln239">   Difference  m_num;</a>
<a name="ln240"> </a>
<a name="ln241">   void increment()</a>
<a name="ln242">   { --m_num; }</a>
<a name="ln243"> </a>
<a name="ln244">   void decrement()</a>
<a name="ln245">   { ++m_num; }</a>
<a name="ln246"> </a>
<a name="ln247">   bool equal(const this_type &amp;other) const</a>
<a name="ln248">   {  return m_num == other.m_num;   }</a>
<a name="ln249"> </a>
<a name="ln250">   bool less(const this_type &amp;other) const</a>
<a name="ln251">   {  return other.m_num &lt; m_num;   }</a>
<a name="ln252"> </a>
<a name="ln253">   const T &amp; dereference() const</a>
<a name="ln254">   {</a>
<a name="ln255">      static T dummy;</a>
<a name="ln256">      return dummy;</a>
<a name="ln257">   }</a>
<a name="ln258"> </a>
<a name="ln259">   void advance(Difference n)</a>
<a name="ln260">   {  m_num -= n; }</a>
<a name="ln261"> </a>
<a name="ln262">   Difference distance_to(const this_type &amp;other)const</a>
<a name="ln263">   {  return m_num - other.m_num;   }</a>
<a name="ln264">};</a>
<a name="ln265"> </a>
<a name="ln266">template &lt;class T, class Difference&gt;</a>
<a name="ln267">class default_init_construct_iterator</a>
<a name="ln268">  : public ::boost::container::iterator</a>
<a name="ln269">      &lt;std::random_access_iterator_tag, T, Difference, const T*, const T &amp;&gt;</a>
<a name="ln270">{</a>
<a name="ln271">   typedef  default_init_construct_iterator&lt;T, Difference&gt; this_type;</a>
<a name="ln272"> </a>
<a name="ln273">   public:</a>
<a name="ln274">   explicit default_init_construct_iterator(Difference range_size)</a>
<a name="ln275">      :  m_num(range_size){}</a>
<a name="ln276"> </a>
<a name="ln277">   //Constructors</a>
<a name="ln278">   default_init_construct_iterator()</a>
<a name="ln279">      :  m_num(0){}</a>
<a name="ln280"> </a>
<a name="ln281">   default_init_construct_iterator&amp; operator++()</a>
<a name="ln282">   { increment();   return *this;   }</a>
<a name="ln283"> </a>
<a name="ln284">   default_init_construct_iterator operator++(int)</a>
<a name="ln285">   {</a>
<a name="ln286">      default_init_construct_iterator result (*this);</a>
<a name="ln287">      increment();</a>
<a name="ln288">      return result;</a>
<a name="ln289">   }</a>
<a name="ln290"> </a>
<a name="ln291">   default_init_construct_iterator&amp; operator--()</a>
<a name="ln292">   { decrement();   return *this;   }</a>
<a name="ln293"> </a>
<a name="ln294">   default_init_construct_iterator operator--(int)</a>
<a name="ln295">   {</a>
<a name="ln296">      default_init_construct_iterator result (*this);</a>
<a name="ln297">      decrement();</a>
<a name="ln298">      return result;</a>
<a name="ln299">   }</a>
<a name="ln300"> </a>
<a name="ln301">   friend bool operator== (const default_init_construct_iterator&amp; i, const default_init_construct_iterator&amp; i2)</a>
<a name="ln302">   { return i.equal(i2); }</a>
<a name="ln303"> </a>
<a name="ln304">   friend bool operator!= (const default_init_construct_iterator&amp; i, const default_init_construct_iterator&amp; i2)</a>
<a name="ln305">   { return !(i == i2); }</a>
<a name="ln306"> </a>
<a name="ln307">   friend bool operator&lt; (const default_init_construct_iterator&amp; i, const default_init_construct_iterator&amp; i2)</a>
<a name="ln308">   { return i.less(i2); }</a>
<a name="ln309"> </a>
<a name="ln310">   friend bool operator&gt; (const default_init_construct_iterator&amp; i, const default_init_construct_iterator&amp; i2)</a>
<a name="ln311">   { return i2 &lt; i; }</a>
<a name="ln312"> </a>
<a name="ln313">   friend bool operator&lt;= (const default_init_construct_iterator&amp; i, const default_init_construct_iterator&amp; i2)</a>
<a name="ln314">   { return !(i &gt; i2); }</a>
<a name="ln315"> </a>
<a name="ln316">   friend bool operator&gt;= (const default_init_construct_iterator&amp; i, const default_init_construct_iterator&amp; i2)</a>
<a name="ln317">   { return !(i &lt; i2); }</a>
<a name="ln318"> </a>
<a name="ln319">   friend Difference operator- (const default_init_construct_iterator&amp; i, const default_init_construct_iterator&amp; i2)</a>
<a name="ln320">   { return i2.distance_to(i); }</a>
<a name="ln321"> </a>
<a name="ln322">   //Arithmetic</a>
<a name="ln323">   default_init_construct_iterator&amp; operator+=(Difference off)</a>
<a name="ln324">   {  this-&gt;advance(off); return *this;   }</a>
<a name="ln325"> </a>
<a name="ln326">   default_init_construct_iterator operator+(Difference off) const</a>
<a name="ln327">   {</a>
<a name="ln328">      default_init_construct_iterator other(*this);</a>
<a name="ln329">      other.advance(off);</a>
<a name="ln330">      return other;</a>
<a name="ln331">   }</a>
<a name="ln332"> </a>
<a name="ln333">   friend default_init_construct_iterator operator+(Difference off, const default_init_construct_iterator&amp; right)</a>
<a name="ln334">   {  return right + off; }</a>
<a name="ln335"> </a>
<a name="ln336">   default_init_construct_iterator&amp; operator-=(Difference off)</a>
<a name="ln337">   {  this-&gt;advance(-off); return *this;   }</a>
<a name="ln338"> </a>
<a name="ln339">   default_init_construct_iterator operator-(Difference off) const</a>
<a name="ln340">   {  return *this + (-off);  }</a>
<a name="ln341"> </a>
<a name="ln342">   //This pseudo-iterator's dereference operations have no sense since value is not</a>
<a name="ln343">   //constructed until ::boost::container::construct_in_place is called.</a>
<a name="ln344">   //So comment them to catch bad uses</a>
<a name="ln345">   //const T&amp; operator*() const;</a>
<a name="ln346">   //const T&amp; operator[](difference_type) const;</a>
<a name="ln347">   //const T* operator-&gt;() const;</a>
<a name="ln348"> </a>
<a name="ln349">   private:</a>
<a name="ln350">   Difference  m_num;</a>
<a name="ln351"> </a>
<a name="ln352">   void increment()</a>
<a name="ln353">   { --m_num; }</a>
<a name="ln354"> </a>
<a name="ln355">   void decrement()</a>
<a name="ln356">   { ++m_num; }</a>
<a name="ln357"> </a>
<a name="ln358">   bool equal(const this_type &amp;other) const</a>
<a name="ln359">   {  return m_num == other.m_num;   }</a>
<a name="ln360"> </a>
<a name="ln361">   bool less(const this_type &amp;other) const</a>
<a name="ln362">   {  return other.m_num &lt; m_num;   }</a>
<a name="ln363"> </a>
<a name="ln364">   const T &amp; dereference() const</a>
<a name="ln365">   {</a>
<a name="ln366">      static T dummy;</a>
<a name="ln367">      return dummy;</a>
<a name="ln368">   }</a>
<a name="ln369"> </a>
<a name="ln370">   void advance(Difference n)</a>
<a name="ln371">   {  m_num -= n; }</a>
<a name="ln372"> </a>
<a name="ln373">   Difference distance_to(const this_type &amp;other)const</a>
<a name="ln374">   {  return m_num - other.m_num;   }</a>
<a name="ln375">};</a>
<a name="ln376"> </a>
<a name="ln377"> </a>
<a name="ln378">template &lt;class T, class Difference = std::ptrdiff_t&gt;</a>
<a name="ln379">class repeat_iterator</a>
<a name="ln380">  : public ::boost::container::iterator</a>
<a name="ln381">      &lt;std::random_access_iterator_tag, T, Difference, T*, T&amp;&gt;</a>
<a name="ln382">{</a>
<a name="ln383">   typedef repeat_iterator&lt;T, Difference&gt; this_type;</a>
<a name="ln384">   public:</a>
<a name="ln385">   explicit repeat_iterator(T &amp;ref, Difference range_size)</a>
<a name="ln386">      :  m_ptr(&amp;ref), m_num(range_size){}</a>
<a name="ln387"> </a>
<a name="ln388">   //Constructors</a>
<a name="ln389">   repeat_iterator()</a>
<a name="ln390">      :  m_ptr(0), m_num(0){}</a>
<a name="ln391"> </a>
<a name="ln392">   this_type&amp; operator++()</a>
<a name="ln393">   { increment();   return *this;   }</a>
<a name="ln394"> </a>
<a name="ln395">   this_type operator++(int)</a>
<a name="ln396">   {</a>
<a name="ln397">      this_type result (*this);</a>
<a name="ln398">      increment();</a>
<a name="ln399">      return result;</a>
<a name="ln400">   }</a>
<a name="ln401"> </a>
<a name="ln402">   this_type&amp; operator--()</a>
<a name="ln403">   { increment();   return *this;   }</a>
<a name="ln404"> </a>
<a name="ln405">   this_type operator--(int)</a>
<a name="ln406">   {</a>
<a name="ln407">      this_type result (*this);</a>
<a name="ln408">      increment();</a>
<a name="ln409">      return result;</a>
<a name="ln410">   }</a>
<a name="ln411"> </a>
<a name="ln412">   friend bool operator== (const this_type&amp; i, const this_type&amp; i2)</a>
<a name="ln413">   { return i.equal(i2); }</a>
<a name="ln414"> </a>
<a name="ln415">   friend bool operator!= (const this_type&amp; i, const this_type&amp; i2)</a>
<a name="ln416">   { return !(i == i2); }</a>
<a name="ln417"> </a>
<a name="ln418">   friend bool operator&lt; (const this_type&amp; i, const this_type&amp; i2)</a>
<a name="ln419">   { return i.less(i2); }</a>
<a name="ln420"> </a>
<a name="ln421">   friend bool operator&gt; (const this_type&amp; i, const this_type&amp; i2)</a>
<a name="ln422">   { return i2 &lt; i; }</a>
<a name="ln423"> </a>
<a name="ln424">   friend bool operator&lt;= (const this_type&amp; i, const this_type&amp; i2)</a>
<a name="ln425">   { return !(i &gt; i2); }</a>
<a name="ln426"> </a>
<a name="ln427">   friend bool operator&gt;= (const this_type&amp; i, const this_type&amp; i2)</a>
<a name="ln428">   { return !(i &lt; i2); }</a>
<a name="ln429"> </a>
<a name="ln430">   friend Difference operator- (const this_type&amp; i, const this_type&amp; i2)</a>
<a name="ln431">   { return i2.distance_to(i); }</a>
<a name="ln432"> </a>
<a name="ln433">   //Arithmetic</a>
<a name="ln434">   this_type&amp; operator+=(Difference off)</a>
<a name="ln435">   {  this-&gt;advance(off); return *this;   }</a>
<a name="ln436"> </a>
<a name="ln437">   this_type operator+(Difference off) const</a>
<a name="ln438">   {</a>
<a name="ln439">      this_type other(*this);</a>
<a name="ln440">      other.advance(off);</a>
<a name="ln441">      return other;</a>
<a name="ln442">   }</a>
<a name="ln443"> </a>
<a name="ln444">   friend this_type operator+(Difference off, const this_type&amp; right)</a>
<a name="ln445">   {  return right + off; }</a>
<a name="ln446"> </a>
<a name="ln447">   this_type&amp; operator-=(Difference off)</a>
<a name="ln448">   {  this-&gt;advance(-off); return *this;   }</a>
<a name="ln449"> </a>
<a name="ln450">   this_type operator-(Difference off) const</a>
<a name="ln451">   {  return *this + (-off);  }</a>
<a name="ln452"> </a>
<a name="ln453">   T&amp; operator*() const</a>
<a name="ln454">   { return dereference(); }</a>
<a name="ln455"> </a>
<a name="ln456">   T&amp; operator[] (Difference ) const</a>
<a name="ln457">   { return dereference(); }</a>
<a name="ln458"> </a>
<a name="ln459">   T *operator-&gt;() const</a>
<a name="ln460">   { return &amp;(dereference()); }</a>
<a name="ln461"> </a>
<a name="ln462">   private:</a>
<a name="ln463">   T *         m_ptr;</a>
<a name="ln464">   Difference  m_num;</a>
<a name="ln465"> </a>
<a name="ln466">   void increment()</a>
<a name="ln467">   { --m_num; }</a>
<a name="ln468"> </a>
<a name="ln469">   void decrement()</a>
<a name="ln470">   { ++m_num; }</a>
<a name="ln471"> </a>
<a name="ln472">   bool equal(const this_type &amp;other) const</a>
<a name="ln473">   {  return m_num == other.m_num;   }</a>
<a name="ln474"> </a>
<a name="ln475">   bool less(const this_type &amp;other) const</a>
<a name="ln476">   {  return other.m_num &lt; m_num;   }</a>
<a name="ln477"> </a>
<a name="ln478">   T &amp; dereference() const</a>
<a name="ln479">   { return *m_ptr; }</a>
<a name="ln480"> </a>
<a name="ln481">   void advance(Difference n)</a>
<a name="ln482">   {  m_num -= n; }</a>
<a name="ln483"> </a>
<a name="ln484">   Difference distance_to(const this_type &amp;other)const</a>
<a name="ln485">   {  return m_num - other.m_num;   }</a>
<a name="ln486">};</a>
<a name="ln487"> </a>
<a name="ln488">template &lt;class T, class EmplaceFunctor, class Difference /*= std::ptrdiff_t*/&gt;</a>
<a name="ln489">class emplace_iterator</a>
<a name="ln490">  : public ::boost::container::iterator</a>
<a name="ln491">      &lt;std::random_access_iterator_tag, T, Difference, const T*, const T &amp;&gt;</a>
<a name="ln492">{</a>
<a name="ln493">   typedef emplace_iterator this_type;</a>
<a name="ln494"> </a>
<a name="ln495">   public:</a>
<a name="ln496">   typedef Difference difference_type;</a>
<a name="ln497">   BOOST_CONTAINER_FORCEINLINE explicit emplace_iterator(EmplaceFunctor&amp;e)</a>
<a name="ln498">      :  m_num(1), m_pe(&amp;e){}</a>
<a name="ln499"> </a>
<a name="ln500">   BOOST_CONTAINER_FORCEINLINE emplace_iterator()</a>
<a name="ln501">      :  m_num(0), m_pe(0){}</a>
<a name="ln502"> </a>
<a name="ln503">   BOOST_CONTAINER_FORCEINLINE this_type&amp; operator++()</a>
<a name="ln504">   { increment();   return *this;   }</a>
<a name="ln505"> </a>
<a name="ln506">   this_type operator++(int)</a>
<a name="ln507">   {</a>
<a name="ln508">      this_type result (*this);</a>
<a name="ln509">      increment();</a>
<a name="ln510">      return result;</a>
<a name="ln511">   }</a>
<a name="ln512"> </a>
<a name="ln513">   BOOST_CONTAINER_FORCEINLINE this_type&amp; operator--()</a>
<a name="ln514">   { decrement();   return *this;   }</a>
<a name="ln515"> </a>
<a name="ln516">   this_type operator--(int)</a>
<a name="ln517">   {</a>
<a name="ln518">      this_type result (*this);</a>
<a name="ln519">      decrement();</a>
<a name="ln520">      return result;</a>
<a name="ln521">   }</a>
<a name="ln522"> </a>
<a name="ln523">   BOOST_CONTAINER_FORCEINLINE friend bool operator== (const this_type&amp; i, const this_type&amp; i2)</a>
<a name="ln524">   { return i.equal(i2); }</a>
<a name="ln525"> </a>
<a name="ln526">   BOOST_CONTAINER_FORCEINLINE friend bool operator!= (const this_type&amp; i, const this_type&amp; i2)</a>
<a name="ln527">   { return !(i == i2); }</a>
<a name="ln528"> </a>
<a name="ln529">   BOOST_CONTAINER_FORCEINLINE friend bool operator&lt; (const this_type&amp; i, const this_type&amp; i2)</a>
<a name="ln530">   { return i.less(i2); }</a>
<a name="ln531"> </a>
<a name="ln532">   BOOST_CONTAINER_FORCEINLINE friend bool operator&gt; (const this_type&amp; i, const this_type&amp; i2)</a>
<a name="ln533">   { return i2 &lt; i; }</a>
<a name="ln534"> </a>
<a name="ln535">   BOOST_CONTAINER_FORCEINLINE friend bool operator&lt;= (const this_type&amp; i, const this_type&amp; i2)</a>
<a name="ln536">   { return !(i &gt; i2); }</a>
<a name="ln537"> </a>
<a name="ln538">   BOOST_CONTAINER_FORCEINLINE friend bool operator&gt;= (const this_type&amp; i, const this_type&amp; i2)</a>
<a name="ln539">   { return !(i &lt; i2); }</a>
<a name="ln540"> </a>
<a name="ln541">   BOOST_CONTAINER_FORCEINLINE friend difference_type operator- (const this_type&amp; i, const this_type&amp; i2)</a>
<a name="ln542">   { return i2.distance_to(i); }</a>
<a name="ln543"> </a>
<a name="ln544">   //Arithmetic</a>
<a name="ln545">   BOOST_CONTAINER_FORCEINLINE this_type&amp; operator+=(difference_type off)</a>
<a name="ln546">   {  this-&gt;advance(off); return *this;   }</a>
<a name="ln547"> </a>
<a name="ln548">   this_type operator+(difference_type off) const</a>
<a name="ln549">   {</a>
<a name="ln550">      this_type other(*this);</a>
<a name="ln551">      other.advance(off);</a>
<a name="ln552">      return other;</a>
<a name="ln553">   }</a>
<a name="ln554"> </a>
<a name="ln555">   BOOST_CONTAINER_FORCEINLINE friend this_type operator+(difference_type off, const this_type&amp; right)</a>
<a name="ln556">   {  return right + off; }</a>
<a name="ln557"> </a>
<a name="ln558">   BOOST_CONTAINER_FORCEINLINE this_type&amp; operator-=(difference_type off)</a>
<a name="ln559">   {  this-&gt;advance(-off); return *this;   }</a>
<a name="ln560"> </a>
<a name="ln561">   BOOST_CONTAINER_FORCEINLINE this_type operator-(difference_type off) const</a>
<a name="ln562">   {  return *this + (-off);  }</a>
<a name="ln563"> </a>
<a name="ln564">   private:</a>
<a name="ln565">   //This pseudo-iterator's dereference operations have no sense since value is not</a>
<a name="ln566">   //constructed until ::boost::container::construct_in_place is called.</a>
<a name="ln567">   //So comment them to catch bad uses</a>
<a name="ln568">   const T&amp; operator*() const;</a>
<a name="ln569">   const T&amp; operator[](difference_type) const;</a>
<a name="ln570">   const T* operator-&gt;() const;</a>
<a name="ln571"> </a>
<a name="ln572">   public:</a>
<a name="ln573">   template&lt;class Allocator&gt;</a>
<a name="ln574">   void construct_in_place(Allocator &amp;a, T* ptr)</a>
<a name="ln575">   {  (*m_pe)(a, ptr);  }</a>
<a name="ln576"> </a>
<a name="ln577">   template&lt;class DestIt&gt;</a>
<a name="ln578">   void assign_in_place(DestIt dest)</a>
<a name="ln579">   {  (*m_pe)(dest);  }</a>
<a name="ln580"> </a>
<a name="ln581">   private:</a>
<a name="ln582">   difference_type m_num;</a>
<a name="ln583">   EmplaceFunctor *            m_pe;</a>
<a name="ln584"> </a>
<a name="ln585">   BOOST_CONTAINER_FORCEINLINE void increment()</a>
<a name="ln586">   { --m_num; }</a>
<a name="ln587"> </a>
<a name="ln588">   BOOST_CONTAINER_FORCEINLINE void decrement()</a>
<a name="ln589">   { ++m_num; }</a>
<a name="ln590"> </a>
<a name="ln591">   BOOST_CONTAINER_FORCEINLINE bool equal(const this_type &amp;other) const</a>
<a name="ln592">   {  return m_num == other.m_num;   }</a>
<a name="ln593"> </a>
<a name="ln594">   BOOST_CONTAINER_FORCEINLINE bool less(const this_type &amp;other) const</a>
<a name="ln595">   {  return other.m_num &lt; m_num;   }</a>
<a name="ln596"> </a>
<a name="ln597">   BOOST_CONTAINER_FORCEINLINE const T &amp; dereference() const</a>
<a name="ln598">   {</a>
<a name="ln599">      static T dummy;</a>
<a name="ln600">      return dummy;</a>
<a name="ln601">   }</a>
<a name="ln602"> </a>
<a name="ln603">   BOOST_CONTAINER_FORCEINLINE void advance(difference_type n)</a>
<a name="ln604">   {  m_num -= n; }</a>
<a name="ln605"> </a>
<a name="ln606">   BOOST_CONTAINER_FORCEINLINE difference_type distance_to(const this_type &amp;other)const</a>
<a name="ln607">   {  return difference_type(m_num - other.m_num);   }</a>
<a name="ln608">};</a>
<a name="ln609"> </a>
<a name="ln610">#if !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES)</a>
<a name="ln611"> </a>
<a name="ln612">template&lt;class ...Args&gt;</a>
<a name="ln613">struct emplace_functor</a>
<a name="ln614">{</a>
<a name="ln615">   typedef typename dtl::build_number_seq&lt;sizeof...(Args)&gt;::type index_tuple_t;</a>
<a name="ln616"> </a>
<a name="ln617">   emplace_functor(BOOST_FWD_REF(Args)... args)</a>
<a name="ln618">      : args_(args...)</a>
<a name="ln619">   {}</a>
<a name="ln620"> </a>
<a name="ln621">   template&lt;class Allocator, class T&gt;</a>
<a name="ln622">   BOOST_CONTAINER_FORCEINLINE void operator()(Allocator &amp;a, T *ptr)</a>
<a name="ln623">   {  emplace_functor::inplace_impl(a, ptr, index_tuple_t());  }</a>
<a name="ln624"> </a>
<a name="ln625">   template&lt;class DestIt&gt;</a>
<a name="ln626">   BOOST_CONTAINER_FORCEINLINE void operator()(DestIt dest)</a>
<a name="ln627">   {  emplace_functor::inplace_impl(dest, index_tuple_t());  }</a>
<a name="ln628"> </a>
<a name="ln629">   private:</a>
<a name="ln630">   template&lt;class Allocator, class T, std::size_t ...IdxPack&gt;</a>
<a name="ln631">   BOOST_CONTAINER_FORCEINLINE void inplace_impl(Allocator &amp;a, T* ptr, const dtl::index_tuple&lt;IdxPack...&gt;&amp;)</a>
<a name="ln632">   {</a>
<a name="ln633">      allocator_traits&lt;Allocator&gt;::construct</a>
<a name="ln634">         (a, ptr, ::boost::forward&lt;Args&gt;(dtl::get&lt;IdxPack&gt;(args_))...);</a>
<a name="ln635">   }</a>
<a name="ln636"> </a>
<a name="ln637">   template&lt;class DestIt, std::size_t ...IdxPack&gt;</a>
<a name="ln638">   BOOST_CONTAINER_FORCEINLINE void inplace_impl(DestIt dest, const dtl::index_tuple&lt;IdxPack...&gt;&amp;)</a>
<a name="ln639">   {</a>
<a name="ln640">      typedef typename boost::container::iterator_traits&lt;DestIt&gt;::value_type value_type;</a>
<a name="ln641">      value_type &amp;&amp; tmp= value_type(::boost::forward&lt;Args&gt;(dtl::get&lt;IdxPack&gt;(args_))...);</a>
<a name="ln642">      *dest = ::boost::move(tmp);</a>
<a name="ln643">   }</a>
<a name="ln644"> </a>
<a name="ln645">   dtl::tuple&lt;Args&amp;...&gt; args_;</a>
<a name="ln646">};</a>
<a name="ln647"> </a>
<a name="ln648">template&lt;class ...Args&gt;</a>
<a name="ln649">struct emplace_functor_type</a>
<a name="ln650">{</a>
<a name="ln651">   typedef emplace_functor&lt;Args...&gt; type;</a>
<a name="ln652">};</a>
<a name="ln653"> </a>
<a name="ln654">#else // !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES)</a>
<a name="ln655"> </a>
<a name="ln656">//Partial specializations cannot match argument list for primary template, so add an extra argument</a>
<a name="ln657">template &lt;BOOST_MOVE_CLASSDFLT9, class Dummy = void&gt;</a>
<a name="ln658">struct emplace_functor_type;</a>
<a name="ln659"> </a>
<a name="ln660">#define BOOST_MOVE_ITERATOR_EMPLACE_FUNCTOR_CODE(N) \</a>
<a name="ln661">BOOST_MOVE_TMPL_LT##N BOOST_MOVE_CLASS##N BOOST_MOVE_GT##N \</a>
<a name="ln662">struct emplace_functor##N\</a>
<a name="ln663">{\</a>
<a name="ln664">   explicit emplace_functor##N( BOOST_MOVE_UREF##N )\</a>
<a name="ln665">      BOOST_MOVE_COLON##N BOOST_MOVE_FWD_INIT##N{}\</a>
<a name="ln666">   \</a>
<a name="ln667">   template&lt;class Allocator, class T&gt;\</a>
<a name="ln668">   void operator()(Allocator &amp;a, T *ptr)\</a>
<a name="ln669">   {  allocator_traits&lt;Allocator&gt;::construct(a, ptr BOOST_MOVE_I##N BOOST_MOVE_MFWD##N);  }\</a>
<a name="ln670">   \</a>
<a name="ln671">   template&lt;class DestIt&gt;\</a>
<a name="ln672">   void operator()(DestIt dest)\</a>
<a name="ln673">   {\</a>
<a name="ln674">      typedef typename boost::container::iterator_traits&lt;DestIt&gt;::value_type value_type;\</a>
<a name="ln675">      BOOST_MOVE_IF(N, value_type tmp(BOOST_MOVE_MFWD##N), dtl::value_init&lt;value_type&gt; tmp) ;\</a>
<a name="ln676">      *dest = ::boost::move(const_cast&lt;value_type &amp;&gt;(BOOST_MOVE_IF(N, tmp, tmp.get())));\</a>
<a name="ln677">   }\</a>
<a name="ln678">   \</a>
<a name="ln679">   BOOST_MOVE_MREF##N\</a>
<a name="ln680">};\</a>
<a name="ln681">\</a>
<a name="ln682">template &lt;BOOST_MOVE_CLASS##N&gt;\</a>
<a name="ln683">struct emplace_functor_type&lt;BOOST_MOVE_TARG##N&gt;\</a>
<a name="ln684">{\</a>
<a name="ln685">   typedef emplace_functor##N BOOST_MOVE_LT##N BOOST_MOVE_TARG##N BOOST_MOVE_GT##N type;\</a>
<a name="ln686">};\</a>
<a name="ln687">//</a>
<a name="ln688"> </a>
<a name="ln689">BOOST_MOVE_ITERATE_0TO9(BOOST_MOVE_ITERATOR_EMPLACE_FUNCTOR_CODE)</a>
<a name="ln690"> </a>
<a name="ln691">#undef BOOST_MOVE_ITERATOR_EMPLACE_FUNCTOR_CODE</a>
<a name="ln692"> </a>
<a name="ln693">#endif</a>
<a name="ln694"> </a>
<a name="ln695">namespace dtl {</a>
<a name="ln696"> </a>
<a name="ln697">template&lt;class T&gt;</a>
<a name="ln698">struct has_iterator_category</a>
<a name="ln699">{</a>
<a name="ln700">   struct two { char _[2]; };</a>
<a name="ln701"> </a>
<a name="ln702">   template &lt;typename X&gt;</a>
<a name="ln703">   static char test(int, typename X::iterator_category*);</a>
<a name="ln704"> </a>
<a name="ln705">   template &lt;typename X&gt;</a>
<a name="ln706">   static two test(int, ...);</a>
<a name="ln707"> </a>
<a name="ln708">   static const bool value = (1 == sizeof(test&lt;T&gt;(0, 0)));</a>
<a name="ln709">};</a>
<a name="ln710"> </a>
<a name="ln711"> </a>
<a name="ln712">template&lt;class T, bool = has_iterator_category&lt;T&gt;::value &gt;</a>
<a name="ln713">struct is_input_iterator</a>
<a name="ln714">{</a>
<a name="ln715">   static const bool value = is_same&lt;typename T::iterator_category, std::input_iterator_tag&gt;::value;</a>
<a name="ln716">};</a>
<a name="ln717"> </a>
<a name="ln718">template&lt;class T&gt;</a>
<a name="ln719">struct is_input_iterator&lt;T, false&gt;</a>
<a name="ln720">{</a>
<a name="ln721">   static const bool value = false;</a>
<a name="ln722">};</a>
<a name="ln723"> </a>
<a name="ln724">template&lt;class T&gt;</a>
<a name="ln725">struct is_not_input_iterator</a>
<a name="ln726">{</a>
<a name="ln727">   static const bool value = !is_input_iterator&lt;T&gt;::value;</a>
<a name="ln728">};</a>
<a name="ln729"> </a>
<a name="ln730">template&lt;class T, bool = has_iterator_category&lt;T&gt;::value &gt;</a>
<a name="ln731">struct is_forward_iterator</a>
<a name="ln732">{</a>
<a name="ln733">   static const bool value = is_same&lt;typename T::iterator_category, std::forward_iterator_tag&gt;::value;</a>
<a name="ln734">};</a>
<a name="ln735"> </a>
<a name="ln736">template&lt;class T&gt;</a>
<a name="ln737">struct is_forward_iterator&lt;T, false&gt;</a>
<a name="ln738">{</a>
<a name="ln739">   static const bool value = false;</a>
<a name="ln740">};</a>
<a name="ln741"> </a>
<a name="ln742">template&lt;class T, bool = has_iterator_category&lt;T&gt;::value &gt;</a>
<a name="ln743">struct is_bidirectional_iterator</a>
<a name="ln744">{</a>
<a name="ln745">   static const bool value = is_same&lt;typename T::iterator_category, std::bidirectional_iterator_tag&gt;::value;</a>
<a name="ln746">};</a>
<a name="ln747"> </a>
<a name="ln748">template&lt;class T&gt;</a>
<a name="ln749">struct is_bidirectional_iterator&lt;T, false&gt;</a>
<a name="ln750">{</a>
<a name="ln751">   static const bool value = false;</a>
<a name="ln752">};</a>
<a name="ln753"> </a>
<a name="ln754">template&lt;class IINodeType&gt;</a>
<a name="ln755">struct iiterator_node_value_type {</a>
<a name="ln756">  typedef typename IINodeType::value_type type;</a>
<a name="ln757">};</a>
<a name="ln758"> </a>
<a name="ln759">template&lt;class IIterator&gt;</a>
<a name="ln760">struct iiterator_types</a>
<a name="ln761">{</a>
<a name="ln762">   typedef typename IIterator::value_type                            it_value_type;</a>
<a name="ln763">   typedef typename iiterator_node_value_type&lt;it_value_type&gt;::type   value_type;</a>
<a name="ln764">   typedef typename boost::container::iterator_traits&lt;IIterator&gt;::pointer         it_pointer;</a>
<a name="ln765">   typedef typename boost::container::iterator_traits&lt;IIterator&gt;::difference_type difference_type;</a>
<a name="ln766">   typedef typename ::boost::intrusive::pointer_traits&lt;it_pointer&gt;::</a>
<a name="ln767">      template rebind_pointer&lt;value_type&gt;::type                      pointer;</a>
<a name="ln768">   typedef typename ::boost::intrusive::pointer_traits&lt;it_pointer&gt;::</a>
<a name="ln769">      template rebind_pointer&lt;const value_type&gt;::type                const_pointer;</a>
<a name="ln770">   typedef typename ::boost::intrusive::</a>
<a name="ln771">      pointer_traits&lt;pointer&gt;::reference                             reference;</a>
<a name="ln772">   typedef typename ::boost::intrusive::</a>
<a name="ln773">      pointer_traits&lt;const_pointer&gt;::reference                       const_reference;</a>
<a name="ln774">   typedef typename IIterator::iterator_category                     iterator_category;</a>
<a name="ln775">};</a>
<a name="ln776"> </a>
<a name="ln777">template&lt;class IIterator, bool IsConst&gt;</a>
<a name="ln778">struct iterator_types</a>
<a name="ln779">{</a>
<a name="ln780">   typedef typename ::boost::container::iterator</a>
<a name="ln781">      &lt; typename iiterator_types&lt;IIterator&gt;::iterator_category</a>
<a name="ln782">      , typename iiterator_types&lt;IIterator&gt;::value_type</a>
<a name="ln783">      , typename iiterator_types&lt;IIterator&gt;::difference_type</a>
<a name="ln784">      , typename iiterator_types&lt;IIterator&gt;::const_pointer</a>
<a name="ln785">      , typename iiterator_types&lt;IIterator&gt;::const_reference&gt; type;</a>
<a name="ln786">};</a>
<a name="ln787"> </a>
<a name="ln788">template&lt;class IIterator&gt;</a>
<a name="ln789">struct iterator_types&lt;IIterator, false&gt;</a>
<a name="ln790">{</a>
<a name="ln791">   typedef typename ::boost::container::iterator</a>
<a name="ln792">      &lt; typename iiterator_types&lt;IIterator&gt;::iterator_category</a>
<a name="ln793">      , typename iiterator_types&lt;IIterator&gt;::value_type</a>
<a name="ln794">      , typename iiterator_types&lt;IIterator&gt;::difference_type</a>
<a name="ln795">      , typename iiterator_types&lt;IIterator&gt;::pointer</a>
<a name="ln796">      , typename iiterator_types&lt;IIterator&gt;::reference&gt; type;</a>
<a name="ln797">};</a>
<a name="ln798"> </a>
<a name="ln799">template&lt;class IIterator, bool IsConst&gt;</a>
<a name="ln800">class iterator_from_iiterator</a>
<a name="ln801">{</a>
<a name="ln802">   typedef typename iterator_types&lt;IIterator, IsConst&gt;::type types_t;</a>
<a name="ln803"> </a>
<a name="ln804">   public:</a>
<a name="ln805">   typedef typename types_t::pointer             pointer;</a>
<a name="ln806">   typedef typename types_t::reference           reference;</a>
<a name="ln807">   typedef typename types_t::difference_type     difference_type;</a>
<a name="ln808">   typedef typename types_t::iterator_category   iterator_category;</a>
<a name="ln809">   typedef typename types_t::value_type          value_type;</a>
<a name="ln810"> </a>
<a name="ln811">   BOOST_CONTAINER_FORCEINLINE iterator_from_iiterator()</a>
<a name="ln812">      : m_iit()</a>
<a name="ln813">   {}</a>
<a name="ln814"> </a>
<a name="ln815">   BOOST_CONTAINER_FORCEINLINE explicit iterator_from_iiterator(IIterator iit) BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln816">      : m_iit(iit)</a>
<a name="ln817">   {}</a>
<a name="ln818"> </a>
<a name="ln819">   BOOST_CONTAINER_FORCEINLINE iterator_from_iiterator(iterator_from_iiterator&lt;IIterator, false&gt; const&amp; other) BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln820">      :  m_iit(other.get())</a>
<a name="ln821">   {}</a>
<a name="ln822"> </a>
<a name="ln823">   BOOST_CONTAINER_FORCEINLINE iterator_from_iiterator&amp; operator++() BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln824">   {  ++this-&gt;m_iit;   return *this;  }</a>
<a name="ln825"> </a>
<a name="ln826">   BOOST_CONTAINER_FORCEINLINE iterator_from_iiterator operator++(int) BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln827">   {</a>
<a name="ln828">      iterator_from_iiterator result (*this);</a>
<a name="ln829">      ++this-&gt;m_iit;</a>
<a name="ln830">      return result;</a>
<a name="ln831">   }</a>
<a name="ln832"> </a>
<a name="ln833">   BOOST_CONTAINER_FORCEINLINE iterator_from_iiterator&amp; operator--() BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln834">   {</a>
<a name="ln835">      //If the iterator_from_iiterator is not a bidirectional iterator, operator-- should not exist</a>
<a name="ln836">      BOOST_STATIC_ASSERT((is_bidirectional_iterator&lt;iterator_from_iiterator&gt;::value));</a>
<a name="ln837">      --this-&gt;m_iit;   return *this;</a>
<a name="ln838">   }</a>
<a name="ln839"> </a>
<a name="ln840">   BOOST_CONTAINER_FORCEINLINE iterator_from_iiterator operator--(int) BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln841">   {</a>
<a name="ln842">      iterator_from_iiterator result (*this);</a>
<a name="ln843">      --this-&gt;m_iit;</a>
<a name="ln844">      return result;</a>
<a name="ln845">   }</a>
<a name="ln846"> </a>
<a name="ln847">   BOOST_CONTAINER_FORCEINLINE friend bool operator== (const iterator_from_iiterator&amp; l, const iterator_from_iiterator&amp; r) BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln848">   {  return l.m_iit == r.m_iit;   }</a>
<a name="ln849"> </a>
<a name="ln850">   BOOST_CONTAINER_FORCEINLINE friend bool operator!= (const iterator_from_iiterator&amp; l, const iterator_from_iiterator&amp; r) BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln851">   {  return !(l == r); }</a>
<a name="ln852"> </a>
<a name="ln853">   BOOST_CONTAINER_FORCEINLINE reference operator*()  const BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln854">   {  return this-&gt;m_iit-&gt;get_data();  }</a>
<a name="ln855"> </a>
<a name="ln856">   BOOST_CONTAINER_FORCEINLINE pointer   operator-&gt;() const BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln857">   {  return ::boost::intrusive::pointer_traits&lt;pointer&gt;::pointer_to(this-&gt;operator*());  }</a>
<a name="ln858"> </a>
<a name="ln859">   BOOST_CONTAINER_FORCEINLINE const IIterator &amp;get() const BOOST_NOEXCEPT_OR_NOTHROW</a>
<a name="ln860">   {  return this-&gt;m_iit;   }</a>
<a name="ln861"> </a>
<a name="ln862">   private:</a>
<a name="ln863">   IIterator m_iit;</a>
<a name="ln864">};</a>
<a name="ln865"> </a>
<a name="ln866">}  //namespace dtl {</a>
<a name="ln867"> </a>
<a name="ln868">using ::boost::intrusive::reverse_iterator;</a>
<a name="ln869"> </a>
<a name="ln870">}  //namespace container {</a>
<a name="ln871">}  //namespace boost {</a>
<a name="ln872"> </a>
<a name="ln873">#include &lt;boost/container/detail/config_end.hpp&gt;</a>
<a name="ln874"> </a>
<a name="ln875">#endif   //#ifndef BOOST_CONTAINER_DETAIL_ITERATORS_HPP</a>

</code></pre>
<div class="balloon" rel="402"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v524/" target="_blank">V524</a> It is odd that the body of '--' function is fully equivalent to the body of '++' function.</p></div>
<div class="balloon" rel="405"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v524/" target="_blank">V524</a> It is odd that the body of '--' function is fully equivalent to the body of '++' function.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
