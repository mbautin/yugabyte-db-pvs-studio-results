
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ts_tablet_manager.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Licensed to the Apache Software Foundation (ASF) under one</a>
<a name="ln2">// or more contributor license agreements.  See the NOTICE file</a>
<a name="ln3">// distributed with this work for additional information</a>
<a name="ln4">// regarding copyright ownership.  The ASF licenses this file</a>
<a name="ln5">// to you under the Apache License, Version 2.0 (the</a>
<a name="ln6">// &quot;License&quot;); you may not use this file except in compliance</a>
<a name="ln7">// with the License.  You may obtain a copy of the License at</a>
<a name="ln8">//</a>
<a name="ln9">//   http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln10">//</a>
<a name="ln11">// Unless required by applicable law or agreed to in writing,</a>
<a name="ln12">// software distributed under the License is distributed on an</a>
<a name="ln13">// &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</a>
<a name="ln14">// KIND, either express or implied.  See the License for the</a>
<a name="ln15">// specific language governing permissions and limitations</a>
<a name="ln16">// under the License.</a>
<a name="ln17">//</a>
<a name="ln18">// The following only applies to changes made to this file as part of YugaByte development.</a>
<a name="ln19">//</a>
<a name="ln20">// Portions Copyright (c) YugaByte, Inc.</a>
<a name="ln21">//</a>
<a name="ln22">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except</a>
<a name="ln23">// in compliance with the License.  You may obtain a copy of the License at</a>
<a name="ln24">//</a>
<a name="ln25">// http://www.apache.org/licenses/LICENSE-2.0</a>
<a name="ln26">//</a>
<a name="ln27">// Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<a name="ln28">// is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<a name="ln29">// or implied.  See the License for the specific language governing permissions and limitations</a>
<a name="ln30">// under the License.</a>
<a name="ln31">//</a>
<a name="ln32"> </a>
<a name="ln33">#include &quot;yb/tserver/ts_tablet_manager.h&quot;</a>
<a name="ln34"> </a>
<a name="ln35">#include &lt;algorithm&gt;</a>
<a name="ln36">#include &lt;memory&gt;</a>
<a name="ln37">#include &lt;mutex&gt;</a>
<a name="ln38">#include &lt;string&gt;</a>
<a name="ln39">#include &lt;vector&gt;</a>
<a name="ln40"> </a>
<a name="ln41">#include &lt;boost/optional/optional.hpp&gt;</a>
<a name="ln42"> </a>
<a name="ln43">#include &lt;glog/logging.h&gt;</a>
<a name="ln44"> </a>
<a name="ln45">#include &quot;yb/client/client.h&quot;</a>
<a name="ln46"> </a>
<a name="ln47">#include &quot;yb/common/wire_protocol.h&quot;</a>
<a name="ln48">#include &quot;yb/consensus/consensus.h&quot;</a>
<a name="ln49">#include &quot;yb/consensus/consensus_meta.h&quot;</a>
<a name="ln50">#include &quot;yb/consensus/log.h&quot;</a>
<a name="ln51">#include &quot;yb/consensus/log_anchor_registry.h&quot;</a>
<a name="ln52">#include &quot;yb/consensus/metadata.pb.h&quot;</a>
<a name="ln53">#include &quot;yb/consensus/opid_util.h&quot;</a>
<a name="ln54">#include &quot;yb/consensus/quorum_util.h&quot;</a>
<a name="ln55">#include &quot;yb/consensus/retryable_requests.h&quot;</a>
<a name="ln56">#include &quot;yb/consensus/raft_consensus.h&quot;</a>
<a name="ln57"> </a>
<a name="ln58">#include &quot;yb/docdb/consensus_frontier.h&quot;</a>
<a name="ln59"> </a>
<a name="ln60">#include &quot;yb/fs/fs_manager.h&quot;</a>
<a name="ln61"> </a>
<a name="ln62">#include &quot;yb/gutil/strings/human_readable.h&quot;</a>
<a name="ln63">#include &quot;yb/gutil/strings/substitute.h&quot;</a>
<a name="ln64">#include &quot;yb/gutil/strings/util.h&quot;</a>
<a name="ln65">#include &quot;yb/gutil/sysinfo.h&quot;</a>
<a name="ln66"> </a>
<a name="ln67">#include &quot;yb/master/master.pb.h&quot;</a>
<a name="ln68">#include &quot;yb/master/sys_catalog.h&quot;</a>
<a name="ln69"> </a>
<a name="ln70">#include &quot;yb/rocksdb/memory_monitor.h&quot;</a>
<a name="ln71"> </a>
<a name="ln72">#include &quot;yb/rpc/messenger.h&quot;</a>
<a name="ln73"> </a>
<a name="ln74">#include &quot;yb/tablet/metadata.pb.h&quot;</a>
<a name="ln75">#include &quot;yb/tablet/tablet.h&quot;</a>
<a name="ln76">#include &quot;yb/tablet/tablet.pb.h&quot;</a>
<a name="ln77">#include &quot;yb/tablet/tablet_bootstrap_if.h&quot;</a>
<a name="ln78">#include &quot;yb/tablet/tablet_fwd.h&quot;</a>
<a name="ln79">#include &quot;yb/tablet/tablet_metadata.h&quot;</a>
<a name="ln80">#include &quot;yb/tablet/tablet_peer.h&quot;</a>
<a name="ln81">#include &quot;yb/tablet/tablet_options.h&quot;</a>
<a name="ln82">#include &quot;yb/tablet/operations/split_operation.h&quot;</a>
<a name="ln83"> </a>
<a name="ln84">#include &quot;yb/tserver/heartbeater.h&quot;</a>
<a name="ln85">#include &quot;yb/tserver/remote_bootstrap_client.h&quot;</a>
<a name="ln86">#include &quot;yb/tserver/remote_bootstrap_session.h&quot;</a>
<a name="ln87">#include &quot;yb/tserver/remote_bootstrap_snapshots.h&quot;</a>
<a name="ln88">#include &quot;yb/tserver/tablet_server.h&quot;</a>
<a name="ln89"> </a>
<a name="ln90">#include &quot;yb/util/background_task.h&quot;</a>
<a name="ln91">#include &quot;yb/util/debug/long_operation_tracker.h&quot;</a>
<a name="ln92">#include &quot;yb/util/debug/trace_event.h&quot;</a>
<a name="ln93">#include &quot;yb/util/env.h&quot;</a>
<a name="ln94">#include &quot;yb/util/env_util.h&quot;</a>
<a name="ln95">#include &quot;yb/util/fault_injection.h&quot;</a>
<a name="ln96">#include &quot;yb/util/file_util.h&quot;</a>
<a name="ln97">#include &quot;yb/util/flag_tags.h&quot;</a>
<a name="ln98">#include &quot;yb/util/mem_tracker.h&quot;</a>
<a name="ln99">#include &quot;yb/util/metrics.h&quot;</a>
<a name="ln100">#include &quot;yb/util/pb_util.h&quot;</a>
<a name="ln101">#include &quot;yb/util/scope_exit.h&quot;</a>
<a name="ln102">#include &quot;yb/util/stopwatch.h&quot;</a>
<a name="ln103">#include &quot;yb/util/trace.h&quot;</a>
<a name="ln104">#include &quot;yb/util/tsan_util.h&quot;</a>
<a name="ln105">#include &quot;yb/util/shared_lock.h&quot;</a>
<a name="ln106"> </a>
<a name="ln107">using namespace std::literals;</a>
<a name="ln108">using namespace std::placeholders;</a>
<a name="ln109"> </a>
<a name="ln110">DEFINE_int32(num_tablets_to_open_simultaneously, 0,</a>
<a name="ln111">             &quot;Number of threads available to open tablets during startup. If this &quot;</a>
<a name="ln112">             &quot;is set to 0 (the default), then the number of bootstrap threads will &quot;</a>
<a name="ln113">             &quot;be set based on the number of data directories. If the data directories &quot;</a>
<a name="ln114">             &quot;are on some very fast storage device such as SSD or a RAID array, it &quot;</a>
<a name="ln115">             &quot;may make sense to manually tune this.&quot;);</a>
<a name="ln116">TAG_FLAG(num_tablets_to_open_simultaneously, advanced);</a>
<a name="ln117"> </a>
<a name="ln118">DEFINE_int32(tablet_start_warn_threshold_ms, 500,</a>
<a name="ln119">             &quot;If a tablet takes more than this number of millis to start, issue &quot;</a>
<a name="ln120">             &quot;a warning with a trace.&quot;);</a>
<a name="ln121">TAG_FLAG(tablet_start_warn_threshold_ms, hidden);</a>
<a name="ln122"> </a>
<a name="ln123">DEFINE_int32(db_block_cache_num_shard_bits, 4,</a>
<a name="ln124">             &quot;Number of bits to use for sharding the block cache (defaults to 4 bits)&quot;);</a>
<a name="ln125">TAG_FLAG(db_block_cache_num_shard_bits, advanced);</a>
<a name="ln126"> </a>
<a name="ln127">DEFINE_bool(enable_log_cache_gc, true,</a>
<a name="ln128">            &quot;Set to true to enable log cache garbage collector.&quot;);</a>
<a name="ln129"> </a>
<a name="ln130">DEFINE_bool(log_cache_gc_evict_only_over_allocated, true,</a>
<a name="ln131">            &quot;If set to true, log cache garbage collection would evict only memory that was &quot;</a>
<a name="ln132">            &quot;allocated over limit for log cache. Otherwise it will try to evict requested number &quot;</a>
<a name="ln133">            &quot;of bytes.&quot;);</a>
<a name="ln134"> </a>
<a name="ln135">DEFINE_bool(enable_block_based_table_cache_gc, false,</a>
<a name="ln136">            &quot;Set to true to enable block based table garbage collector.&quot;);</a>
<a name="ln137"> </a>
<a name="ln138">DEFINE_test_flag(double, fault_crash_after_blocks_deleted, 0.0,</a>
<a name="ln139">                 &quot;Fraction of the time when the tablet will crash immediately &quot;</a>
<a name="ln140">                 &quot;after deleting the data blocks during tablet deletion.&quot;);</a>
<a name="ln141"> </a>
<a name="ln142">DEFINE_test_flag(double, fault_crash_after_wal_deleted, 0.0,</a>
<a name="ln143">                 &quot;Fraction of the time when the tablet will crash immediately &quot;</a>
<a name="ln144">                 &quot;after deleting the WAL segments during tablet deletion.&quot;);</a>
<a name="ln145"> </a>
<a name="ln146">DEFINE_test_flag(double, fault_crash_after_cmeta_deleted, 0.0,</a>
<a name="ln147">                 &quot;Fraction of the time when the tablet will crash immediately &quot;</a>
<a name="ln148">                 &quot;after deleting the consensus metadata during tablet deletion.&quot;);</a>
<a name="ln149"> </a>
<a name="ln150">DEFINE_test_flag(double, fault_crash_after_rb_files_fetched, 0.0,</a>
<a name="ln151">                 &quot;Fraction of the time when the tablet will crash immediately &quot;</a>
<a name="ln152">                 &quot;after fetching the files during a remote bootstrap but before &quot;</a>
<a name="ln153">                 &quot;marking the superblock as TABLET_DATA_READY.&quot;)</a>
<a name="ln154"> </a>
<a name="ln155">DEFINE_test_flag(bool, pretend_memory_exceeded_enforce_flush, false,</a>
<a name="ln156">                 &quot;Always pretend memory has been exceeded to enforce background flush.&quot;);</a>
<a name="ln157"> </a>
<a name="ln158">DEFINE_test_flag(int32, crash_if_remote_bootstrap_sessions_greater_than, 0,</a>
<a name="ln159">                 &quot;If greater than zero, this process will crash if we detect more than the &quot;</a>
<a name="ln160">                 &quot;specified number of remote bootstrap sessions.&quot;);</a>
<a name="ln161"> </a>
<a name="ln162">DEFINE_test_flag(int32, crash_if_remote_bootstrap_sessions_per_table_greater_than, 0,</a>
<a name="ln163">                 &quot;If greater than zero, this process will crash if for any table we exceed the &quot;</a>
<a name="ln164">                 &quot;specified number of remote bootstrap sessions&quot;);</a>
<a name="ln165"> </a>
<a name="ln166">DEFINE_test_flag(bool, force_single_tablet_failure, false,</a>
<a name="ln167">                 &quot;Force exactly one tablet to a failed state.&quot;);</a>
<a name="ln168"> </a>
<a name="ln169">DEFINE_test_flag(int32, apply_tablet_split_inject_delay_ms, 0,</a>
<a name="ln170">                 &quot;Inject delay into TSTabletManager::ApplyTabletSplit.&quot;);</a>
<a name="ln171"> </a>
<a name="ln172">namespace {</a>
<a name="ln173"> </a>
<a name="ln174">constexpr int kDbCacheSizeUsePercentage = -1;</a>
<a name="ln175">constexpr int kDbCacheSizeCacheDisabled = -2;</a>
<a name="ln176"> </a>
<a name="ln177">} // namespace</a>
<a name="ln178"> </a>
<a name="ln179">DEFINE_int32(flush_background_task_interval_msec, 0,</a>
<a name="ln180">             &quot;The tick interval time for the flush background task. &quot;</a>
<a name="ln181">             &quot;This defaults to 0, which means disable the background task &quot;</a>
<a name="ln182">             &quot;And only use callbacks on memstore allocations. &quot;);</a>
<a name="ln183"> </a>
<a name="ln184">DEFINE_int64(global_memstore_size_percentage, 10,</a>
<a name="ln185">             &quot;Percentage of total available memory to use for the global memstore. &quot;</a>
<a name="ln186">             &quot;Default is 10. See also memstore_size_mb and &quot;</a>
<a name="ln187">             &quot;global_memstore_size_mb_max.&quot;);</a>
<a name="ln188">DEFINE_int64(global_memstore_size_mb_max, 2048,</a>
<a name="ln189">             &quot;Global memstore size is determined as a percentage of the available &quot;</a>
<a name="ln190">             &quot;memory. However, this flag limits it in absolute size. Value of 0 &quot;</a>
<a name="ln191">             &quot;means no limit on the value obtained by the percentage. Default is 2048.&quot;);</a>
<a name="ln192"> </a>
<a name="ln193">DEFINE_int64(db_block_cache_size_bytes, kDbCacheSizeUsePercentage,</a>
<a name="ln194">             &quot;Size of cross-tablet shared RocksDB block cache (in bytes). &quot;</a>
<a name="ln195">             &quot;This defaults to -1 for system auto-generated default, which would use &quot;</a>
<a name="ln196">             &quot;FLAGS_db_block_cache_ram_percentage to select a percentage of the total memory as &quot;</a>
<a name="ln197">             &quot;the default size for the shared block cache. Value of -2 disables block cache.&quot;);</a>
<a name="ln198"> </a>
<a name="ln199">DEFINE_int32(db_block_cache_size_percentage, 50,</a>
<a name="ln200">             &quot;Default percentage of total available memory to use as block cache size, if not &quot;</a>
<a name="ln201">             &quot;asking for a raw number, through FLAGS_db_block_cache_size_bytes.&quot;);</a>
<a name="ln202"> </a>
<a name="ln203">DEFINE_int32(read_pool_max_threads, 128,</a>
<a name="ln204">             &quot;The maximum number of threads allowed for read_pool_. This pool is used &quot;</a>
<a name="ln205">             &quot;to run multiple read operations, that are part of the same tablet rpc, &quot;</a>
<a name="ln206">             &quot;in parallel.&quot;);</a>
<a name="ln207">DEFINE_int32(read_pool_max_queue_size, 128,</a>
<a name="ln208">             &quot;The maximum number of tasks that can be held in the queue for read_pool_. This pool &quot;</a>
<a name="ln209">             &quot;is used to run multiple read operations, that are part of the same tablet rpc, &quot;</a>
<a name="ln210">             &quot;in parallel.&quot;);</a>
<a name="ln211"> </a>
<a name="ln212">DEFINE_test_flag(int32, sleep_after_tombstoning_tablet_secs, 0,</a>
<a name="ln213">                 &quot;Whether we sleep in LogAndTombstone after calling DeleteTabletData.&quot;);</a>
<a name="ln214"> </a>
<a name="ln215">constexpr int kTServerYbClientDefaultTimeoutMs = yb::RegularBuildVsSanitizers(5, 60) * 1000;</a>
<a name="ln216"> </a>
<a name="ln217">DEFINE_int32(tserver_yb_client_default_timeout_ms, kTServerYbClientDefaultTimeoutMs,</a>
<a name="ln218">             &quot;Default timeout for the YBClient embedded into the tablet server that is used &quot;</a>
<a name="ln219">             &quot;for distributed transactions.&quot;);</a>
<a name="ln220"> </a>
<a name="ln221">DEFINE_bool(enable_restart_transaction_status_tablets_first, true,</a>
<a name="ln222">            &quot;Set to true to prioritize bootstrapping transaction status tablets first.&quot;);</a>
<a name="ln223"> </a>
<a name="ln224">namespace yb {</a>
<a name="ln225">namespace tserver {</a>
<a name="ln226"> </a>
<a name="ln227">METRIC_DEFINE_histogram(server, op_apply_queue_length, &quot;Operation Apply Queue Length&quot;,</a>
<a name="ln228">                        MetricUnit::kTasks,</a>
<a name="ln229">                        &quot;Number of operations waiting to be applied to the tablet. &quot;</a>
<a name="ln230">                        &quot;High queue lengths indicate that the server is unable to process &quot;</a>
<a name="ln231">                        &quot;operations as fast as they are being written to the WAL.&quot;,</a>
<a name="ln232">                        10000, 2);</a>
<a name="ln233"> </a>
<a name="ln234">METRIC_DEFINE_histogram(server, op_apply_queue_time, &quot;Operation Apply Queue Time&quot;,</a>
<a name="ln235">                        MetricUnit::kMicroseconds,</a>
<a name="ln236">                        &quot;Time that operations spent waiting in the apply queue before being &quot;</a>
<a name="ln237">                        &quot;processed. High queue times indicate that the server is unable to &quot;</a>
<a name="ln238">                        &quot;process operations as fast as they are being written to the WAL.&quot;,</a>
<a name="ln239">                        10000000, 2);</a>
<a name="ln240"> </a>
<a name="ln241">METRIC_DEFINE_histogram(server, op_apply_run_time, &quot;Operation Apply Run Time&quot;,</a>
<a name="ln242">                        MetricUnit::kMicroseconds,</a>
<a name="ln243">                        &quot;Time that operations spent being applied to the tablet. &quot;</a>
<a name="ln244">                        &quot;High values may indicate that the server is under-provisioned or &quot;</a>
<a name="ln245">                        &quot;that operations consist of very large batches.&quot;,</a>
<a name="ln246">                        10000000, 2);</a>
<a name="ln247"> </a>
<a name="ln248">METRIC_DEFINE_histogram(server, op_read_queue_length, &quot;Operation Read op Queue Length&quot;,</a>
<a name="ln249">                        MetricUnit::kTasks,</a>
<a name="ln250">                        &quot;Number of operations waiting to be applied to the tablet. &quot;</a>
<a name="ln251">                            &quot;High queue lengths indicate that the server is unable to process &quot;</a>
<a name="ln252">                            &quot;operations as fast as they are being written to the WAL.&quot;,</a>
<a name="ln253">                        10000, 2);</a>
<a name="ln254"> </a>
<a name="ln255">METRIC_DEFINE_histogram(server, op_read_queue_time, &quot;Operation Read op Queue Time&quot;,</a>
<a name="ln256">                        MetricUnit::kMicroseconds,</a>
<a name="ln257">                        &quot;Time that operations spent waiting in the read queue before being &quot;</a>
<a name="ln258">                            &quot;processed. High queue times indicate that the server is unable to &quot;</a>
<a name="ln259">                            &quot;process operations as fast as they are being written to the WAL.&quot;,</a>
<a name="ln260">                        10000000, 2);</a>
<a name="ln261"> </a>
<a name="ln262">METRIC_DEFINE_histogram(server, op_read_run_time, &quot;Operation Read op Run Time&quot;,</a>
<a name="ln263">                        MetricUnit::kMicroseconds,</a>
<a name="ln264">                        &quot;Time that operations spent being applied to the tablet. &quot;</a>
<a name="ln265">                            &quot;High values may indicate that the server is under-provisioned or &quot;</a>
<a name="ln266">                            &quot;that operations consist of very large batches.&quot;,</a>
<a name="ln267">                        10000000, 2);</a>
<a name="ln268"> </a>
<a name="ln269">METRIC_DEFINE_histogram(server, ts_bootstrap_time, &quot;TServer Bootstrap Time&quot;,</a>
<a name="ln270">                        MetricUnit::kMicroseconds,</a>
<a name="ln271">                        &quot;Time that the tablet server takes to bootstrap all of its tablets.&quot;,</a>
<a name="ln272">                        10000000, 2);</a>
<a name="ln273"> </a>
<a name="ln274">using consensus::ConsensusMetadata;</a>
<a name="ln275">using consensus::ConsensusStatePB;</a>
<a name="ln276">using consensus::RaftConfigPB;</a>
<a name="ln277">using consensus::RaftPeerPB;</a>
<a name="ln278">using consensus::StartRemoteBootstrapRequestPB;</a>
<a name="ln279">using log::Log;</a>
<a name="ln280">using master::ReportedTabletPB;</a>
<a name="ln281">using master::TabletReportPB;</a>
<a name="ln282">using std::shared_ptr;</a>
<a name="ln283">using std::string;</a>
<a name="ln284">using std::unordered_set;</a>
<a name="ln285">using std::vector;</a>
<a name="ln286">using strings::Substitute;</a>
<a name="ln287">using tablet::BOOTSTRAPPING;</a>
<a name="ln288">using tablet::NOT_STARTED;</a>
<a name="ln289">using tablet::RaftGroupMetadata;</a>
<a name="ln290">using tablet::RaftGroupMetadataPtr;</a>
<a name="ln291">using tablet::RaftGroupStatePB;</a>
<a name="ln292">using tablet::RUNNING;</a>
<a name="ln293">using tablet::TABLET_DATA_COPYING;</a>
<a name="ln294">using tablet::TABLET_DATA_DELETED;</a>
<a name="ln295">using tablet::TABLET_DATA_READY;</a>
<a name="ln296">using tablet::TABLET_DATA_SPLIT_COMPLETED;</a>
<a name="ln297">using tablet::TABLET_DATA_TOMBSTONED;</a>
<a name="ln298">using tablet::TabletDataState;</a>
<a name="ln299">using tablet::TabletPeer;</a>
<a name="ln300">using tablet::TabletPeerPtr;</a>
<a name="ln301">using tablet::TabletStatusListener;</a>
<a name="ln302">using tablet::TabletStatusPB;</a>
<a name="ln303"> </a>
<a name="ln304">// Only called from the background task to ensure it's synchronized</a>
<a name="ln305">void TSTabletManager::MaybeFlushTablet() {</a>
<a name="ln306">  int iteration = 0;</a>
<a name="ln307">  while (memory_monitor()-&gt;Exceeded() ||</a>
<a name="ln308">         (iteration++ == 0 &amp;&amp; FLAGS_TEST_pretend_memory_exceeded_enforce_flush)) {</a>
<a name="ln309">    YB_LOG_EVERY_N_SECS(INFO, 5) &lt;&lt; Format(&quot;Memstore global limit of $0 bytes reached, looking for &quot;</a>
<a name="ln310">                                           &quot;tablet to flush&quot;, memory_monitor()-&gt;limit());</a>
<a name="ln311">    auto flush_tick = rocksdb::FlushTick();</a>
<a name="ln312">    TabletPeerPtr tablet_to_flush = TabletToFlush();</a>
<a name="ln313">    // TODO(bojanserafimov): If tablet_to_flush flushes now because of other reasons,</a>
<a name="ln314">    // we will schedule a second flush, which will unnecessarily stall writes for a short time. This</a>
<a name="ln315">    // will not happen often, but should be fixed.</a>
<a name="ln316">    if (tablet_to_flush) {</a>
<a name="ln317">      LOG(INFO)</a>
<a name="ln318">          &lt;&lt; TabletLogPrefix(tablet_to_flush-&gt;tablet_id())</a>
<a name="ln319">          &lt;&lt; &quot;Flushing tablet with oldest memstore write at &quot;</a>
<a name="ln320">          &lt;&lt; tablet_to_flush-&gt;tablet()-&gt;OldestMutableMemtableWriteHybridTime();</a>
<a name="ln321">      WARN_NOT_OK(</a>
<a name="ln322">          tablet_to_flush-&gt;tablet()-&gt;Flush(</a>
<a name="ln323">              tablet::FlushMode::kAsync, tablet::FlushFlags::kAll, flush_tick),</a>
<a name="ln324">          Substitute(&quot;Flush failed on $0&quot;, tablet_to_flush-&gt;tablet_id()));</a>
<a name="ln325">      for (auto listener : TEST_listeners) {</a>
<a name="ln326">        listener-&gt;StartedFlush(tablet_to_flush-&gt;tablet_id());</a>
<a name="ln327">      }</a>
<a name="ln328">    }</a>
<a name="ln329">  }</a>
<a name="ln330">}</a>
<a name="ln331"> </a>
<a name="ln332">// Return the tablet with the oldest write in memstore, or nullptr if all tablet memstores are</a>
<a name="ln333">// empty or about to flush.</a>
<a name="ln334">TabletPeerPtr TSTabletManager::TabletToFlush() {</a>
<a name="ln335">  SharedLock&lt;RWMutex&gt; lock(mutex_); // For using the tablet map</a>
<a name="ln336">  HybridTime oldest_write_in_memstores = HybridTime::kMax;</a>
<a name="ln337">  TabletPeerPtr tablet_to_flush;</a>
<a name="ln338">  for (const TabletMap::value_type&amp; entry : tablet_map_) {</a>
<a name="ln339">    const auto tablet = entry.second-&gt;shared_tablet();</a>
<a name="ln340">    if (tablet) {</a>
<a name="ln341">      const auto ht = tablet-&gt;OldestMutableMemtableWriteHybridTime();</a>
<a name="ln342">      if (ht.ok()) {</a>
<a name="ln343">        if (*ht &lt; oldest_write_in_memstores) {</a>
<a name="ln344">          oldest_write_in_memstores = *ht;</a>
<a name="ln345">          tablet_to_flush = entry.second;</a>
<a name="ln346">        }</a>
<a name="ln347">      } else {</a>
<a name="ln348">        YB_LOG_EVERY_N_SECS(WARNING, 5) &lt;&lt; Format(</a>
<a name="ln349">            &quot;Failed to get oldest mutable memtable write ht for tablet $0: $1&quot;,</a>
<a name="ln350">            tablet-&gt;tablet_id(), ht.status());</a>
<a name="ln351">      }</a>
<a name="ln352">    }</a>
<a name="ln353">  }</a>
<a name="ln354">  return tablet_to_flush;</a>
<a name="ln355">}</a>
<a name="ln356"> </a>
<a name="ln357">namespace {</a>
<a name="ln358"> </a>
<a name="ln359">class LRUCacheGC : public GarbageCollector {</a>
<a name="ln360"> public:</a>
<a name="ln361">  explicit LRUCacheGC(std::shared_ptr&lt;rocksdb::Cache&gt; cache) : cache_(std::move(cache)) {}</a>
<a name="ln362"> </a>
<a name="ln363">  void CollectGarbage(size_t required) {</a>
<a name="ln364">    if (!FLAGS_enable_block_based_table_cache_gc) {</a>
<a name="ln365">      return;</a>
<a name="ln366">    }</a>
<a name="ln367"> </a>
<a name="ln368">    auto evicted = cache_-&gt;Evict(required);</a>
<a name="ln369">    LOG(INFO) &lt;&lt; &quot;Evicted from table cache: &quot; &lt;&lt; HumanReadableNumBytes::ToString(evicted)</a>
<a name="ln370">              &lt;&lt; &quot;, new usage: &quot; &lt;&lt; HumanReadableNumBytes::ToString(cache_-&gt;GetUsage())</a>
<a name="ln371">              &lt;&lt; &quot;, required: &quot; &lt;&lt; HumanReadableNumBytes::ToString(required);</a>
<a name="ln372">  }</a>
<a name="ln373"> </a>
<a name="ln374">  virtual ~LRUCacheGC() = default;</a>
<a name="ln375"> </a>
<a name="ln376"> private:</a>
<a name="ln377">  std::shared_ptr&lt;rocksdb::Cache&gt; cache_;</a>
<a name="ln378">};</a>
<a name="ln379"> </a>
<a name="ln380">class FunctorGC : public GarbageCollector {</a>
<a name="ln381"> public:</a>
<a name="ln382">  explicit FunctorGC(std::function&lt;void(size_t)&gt; impl) : impl_(std::move(impl)) {}</a>
<a name="ln383"> </a>
<a name="ln384">  void CollectGarbage(size_t required) {</a>
<a name="ln385">    impl_(required);</a>
<a name="ln386">  }</a>
<a name="ln387"> </a>
<a name="ln388">  virtual ~FunctorGC() = default;</a>
<a name="ln389"> </a>
<a name="ln390"> private:</a>
<a name="ln391">  std::function&lt;void(size_t)&gt; impl_;</a>
<a name="ln392">};</a>
<a name="ln393"> </a>
<a name="ln394">} // namespace</a>
<a name="ln395"> </a>
<a name="ln396">TSTabletManager::TSTabletManager(FsManager* fs_manager,</a>
<a name="ln397">                                 TabletServer* server,</a>
<a name="ln398">                                 MetricRegistry* metric_registry)</a>
<a name="ln399">  : fs_manager_(fs_manager),</a>
<a name="ln400">    server_(server),</a>
<a name="ln401">    next_report_seq_(0),</a>
<a name="ln402">    metric_registry_(metric_registry),</a>
<a name="ln403">    state_(MANAGER_INITIALIZING) {</a>
<a name="ln404"> </a>
<a name="ln405">  ThreadPoolMetrics metrics = {</a>
<a name="ln406">      METRIC_op_apply_queue_length.Instantiate(server_-&gt;metric_entity()),</a>
<a name="ln407">      METRIC_op_apply_queue_time.Instantiate(server_-&gt;metric_entity()),</a>
<a name="ln408">      METRIC_op_apply_run_time.Instantiate(server_-&gt;metric_entity())</a>
<a name="ln409">  };</a>
<a name="ln410">  CHECK_OK(ThreadPoolBuilder(&quot;apply&quot;)</a>
<a name="ln411">               .set_metrics(std::move(metrics))</a>
<a name="ln412">               .Build(&amp;apply_pool_));</a>
<a name="ln413"> </a>
<a name="ln414">  // This pool is shared by all replicas hosted by this server.</a>
<a name="ln415">  //</a>
<a name="ln416">  // Some submitted tasks use blocking IO, so we configure no upper bound on</a>
<a name="ln417">  // the maximum number of threads in each pool (otherwise the default value of</a>
<a name="ln418">  // &quot;number of CPUs&quot; may cause blocking tasks to starve other &quot;fast&quot; tasks).</a>
<a name="ln419">  // However, the effective upper bound is the number of replicas as each will</a>
<a name="ln420">  // submit its own tasks via a dedicated token.</a>
<a name="ln421">  CHECK_OK(ThreadPoolBuilder(&quot;raft&quot;)</a>
<a name="ln422">               .set_min_threads(1)</a>
<a name="ln423">               .unlimited_threads()</a>
<a name="ln424">               .Build(&amp;raft_pool_));</a>
<a name="ln425">  CHECK_OK(ThreadPoolBuilder(&quot;prepare&quot;)</a>
<a name="ln426">               .set_min_threads(1)</a>
<a name="ln427">               .unlimited_threads()</a>
<a name="ln428">               .Build(&amp;tablet_prepare_pool_));</a>
<a name="ln429">  CHECK_OK(ThreadPoolBuilder(&quot;append&quot;)</a>
<a name="ln430">               .set_min_threads(1)</a>
<a name="ln431">               .unlimited_threads()</a>
<a name="ln432">               .set_idle_timeout(MonoDelta::FromMilliseconds(10000))</a>
<a name="ln433">               .Build(&amp;append_pool_));</a>
<a name="ln434">  CHECK_OK(ThreadPoolBuilder(&quot;log-alloc&quot;)</a>
<a name="ln435">               .set_min_threads(1)</a>
<a name="ln436">               .unlimited_threads()</a>
<a name="ln437">               .Build(&amp;allocation_pool_));</a>
<a name="ln438">  ThreadPoolMetrics read_metrics = {</a>
<a name="ln439">      METRIC_op_read_queue_length.Instantiate(server_-&gt;metric_entity()),</a>
<a name="ln440">      METRIC_op_read_queue_time.Instantiate(server_-&gt;metric_entity()),</a>
<a name="ln441">      METRIC_op_read_run_time.Instantiate(server_-&gt;metric_entity())</a>
<a name="ln442">  };</a>
<a name="ln443">  CHECK_OK(ThreadPoolBuilder(&quot;read-parallel&quot;)</a>
<a name="ln444">               .set_max_threads(FLAGS_read_pool_max_threads)</a>
<a name="ln445">               .set_max_queue_size(FLAGS_read_pool_max_queue_size)</a>
<a name="ln446">               .set_metrics(std::move(read_metrics))</a>
<a name="ln447">               .Build(&amp;read_pool_));</a>
<a name="ln448"> </a>
<a name="ln449">  int64_t block_cache_size_bytes = FLAGS_db_block_cache_size_bytes;</a>
<a name="ln450">  int64_t total_ram_avail = MemTracker::GetRootTracker()-&gt;limit();</a>
<a name="ln451">  // Auto-compute size of block cache if asked to.</a>
<a name="ln452">  if (FLAGS_db_block_cache_size_bytes == kDbCacheSizeUsePercentage) {</a>
<a name="ln453">    // Check some bounds.</a>
<a name="ln454">    CHECK(FLAGS_db_block_cache_size_percentage &gt; 0 &amp;&amp; FLAGS_db_block_cache_size_percentage &lt;= 100)</a>
<a name="ln455">        &lt;&lt; Substitute(</a>
<a name="ln456">               &quot;Flag tablet_block_cache_size_percentage must be between 0 and 100. Current value: &quot;</a>
<a name="ln457">               &quot;$0&quot;,</a>
<a name="ln458">               FLAGS_db_block_cache_size_percentage);</a>
<a name="ln459"> </a>
<a name="ln460">    block_cache_size_bytes = total_ram_avail * FLAGS_db_block_cache_size_percentage / 100;</a>
<a name="ln461">  }</a>
<a name="ln462"> </a>
<a name="ln463">  block_based_table_mem_tracker_ = MemTracker::FindOrCreateTracker(</a>
<a name="ln464">      block_cache_size_bytes, &quot;BlockBasedTable&quot;, server_-&gt;mem_tracker());</a>
<a name="ln465"> </a>
<a name="ln466">  if (FLAGS_db_block_cache_size_bytes != kDbCacheSizeCacheDisabled) {</a>
<a name="ln467">    tablet_options_.block_cache = rocksdb::NewLRUCache(block_cache_size_bytes,</a>
<a name="ln468">                                                       FLAGS_db_block_cache_num_shard_bits);</a>
<a name="ln469">    tablet_options_.block_cache-&gt;SetMetrics(server_-&gt;metric_entity());</a>
<a name="ln470">    block_based_table_gc_ = std::make_shared&lt;LRUCacheGC&gt;(tablet_options_.block_cache);</a>
<a name="ln471">    block_based_table_mem_tracker_-&gt;AddGarbageCollector(block_based_table_gc_);</a>
<a name="ln472">  }</a>
<a name="ln473"> </a>
<a name="ln474">  auto log_cache_mem_tracker = consensus::LogCache::GetServerMemTracker(server_-&gt;mem_tracker());</a>
<a name="ln475">  log_cache_gc_ = std::make_shared&lt;FunctorGC&gt;(</a>
<a name="ln476">      std::bind(&amp;TSTabletManager::LogCacheGC, this, log_cache_mem_tracker.get(), _1));</a>
<a name="ln477">  log_cache_mem_tracker-&gt;AddGarbageCollector(log_cache_gc_);</a>
<a name="ln478"> </a>
<a name="ln479">  // Calculate memstore_size_bytes</a>
<a name="ln480">  bool should_count_memory = FLAGS_global_memstore_size_percentage &gt; 0;</a>
<a name="ln481">  CHECK(FLAGS_global_memstore_size_percentage &gt; 0 &amp;&amp; FLAGS_global_memstore_size_percentage &lt;= 100)</a>
<a name="ln482">    &lt;&lt; Substitute(</a>
<a name="ln483">        &quot;Flag tablet_block_cache_size_percentage must be between 0 and 100. Current value: &quot;</a>
<a name="ln484">        &quot;$0&quot;,</a>
<a name="ln485">        FLAGS_global_memstore_size_percentage);</a>
<a name="ln486">  size_t memstore_size_bytes = total_ram_avail * FLAGS_global_memstore_size_percentage / 100;</a>
<a name="ln487"> </a>
<a name="ln488">  if (FLAGS_global_memstore_size_mb_max != 0) {</a>
<a name="ln489">    memstore_size_bytes = std::min(memstore_size_bytes,</a>
<a name="ln490">                                   static_cast&lt;size_t&gt;(FLAGS_global_memstore_size_mb_max &lt;&lt; 20));</a>
<a name="ln491">  }</a>
<a name="ln492"> </a>
<a name="ln493">  // Add memory monitor and background thread for flushing</a>
<a name="ln494">  if (should_count_memory) {</a>
<a name="ln495">    background_task_.reset(new BackgroundTask(</a>
<a name="ln496">      std::function&lt;void()&gt;([this](){ MaybeFlushTablet(); }),</a>
<a name="ln497">      &quot;tablet manager&quot;,</a>
<a name="ln498">      &quot;flush scheduler bgtask&quot;,</a>
<a name="ln499">      std::chrono::milliseconds(FLAGS_flush_background_task_interval_msec)));</a>
<a name="ln500">    tablet_options_.memory_monitor = std::make_shared&lt;rocksdb::MemoryMonitor&gt;(</a>
<a name="ln501">        memstore_size_bytes,</a>
<a name="ln502">        std::function&lt;void()&gt;([this](){</a>
<a name="ln503">                                YB_WARN_NOT_OK(background_task_-&gt;Wake(), &quot;Wakeup error&quot;); }));</a>
<a name="ln504">  }</a>
<a name="ln505">}</a>
<a name="ln506"> </a>
<a name="ln507">TSTabletManager::~TSTabletManager() {</a>
<a name="ln508">}</a>
<a name="ln509"> </a>
<a name="ln510">Status TSTabletManager::Init() {</a>
<a name="ln511">  CHECK_EQ(state(), MANAGER_INITIALIZING);</a>
<a name="ln512"> </a>
<a name="ln513">  async_client_init_.emplace(</a>
<a name="ln514">      &quot;tserver_client&quot;, 0 /* num_reactors */,</a>
<a name="ln515">      FLAGS_tserver_yb_client_default_timeout_ms / 1000, server_-&gt;permanent_uuid(),</a>
<a name="ln516">      &amp;server_-&gt;options(), server_-&gt;metric_entity(), server_-&gt;mem_tracker(),</a>
<a name="ln517">      server_-&gt;messenger());</a>
<a name="ln518"> </a>
<a name="ln519">  async_client_init_-&gt;AddPostCreateHook([this](client::YBClient* client) {</a>
<a name="ln520">    auto* tserver = server();</a>
<a name="ln521">    if (tserver != nullptr &amp;&amp; tserver-&gt;proxy() != nullptr) {</a>
<a name="ln522">      client-&gt;SetLocalTabletServer(tserver-&gt;permanent_uuid(), tserver-&gt;proxy(), tserver);</a>
<a name="ln523">    }</a>
<a name="ln524">  });</a>
<a name="ln525"> </a>
<a name="ln526">  tablet_options_.env = server_-&gt;GetEnv();</a>
<a name="ln527">  tablet_options_.rocksdb_env = server_-&gt;GetRocksDBEnv();</a>
<a name="ln528">  tablet_options_.listeners = server_-&gt;options().listeners;</a>
<a name="ln529"> </a>
<a name="ln530">  // Start the threadpool we'll use to open tablets.</a>
<a name="ln531">  // This has to be done in Init() instead of the constructor, since the</a>
<a name="ln532">  // FsManager isn't initialized until this point.</a>
<a name="ln533">  int max_bootstrap_threads = FLAGS_num_tablets_to_open_simultaneously;</a>
<a name="ln534">  if (max_bootstrap_threads == 0) {</a>
<a name="ln535">    size_t num_cpus = base::NumCPUs();</a>
<a name="ln536">    if (num_cpus &lt;= 2) {</a>
<a name="ln537">      max_bootstrap_threads = 2;</a>
<a name="ln538">    } else {</a>
<a name="ln539">      max_bootstrap_threads = min(num_cpus - 1, fs_manager_-&gt;GetDataRootDirs().size() * 8);</a>
<a name="ln540">    }</a>
<a name="ln541">    LOG_WITH_PREFIX(INFO) &lt;&lt;  &quot;max_bootstrap_threads=&quot; &lt;&lt; max_bootstrap_threads;</a>
<a name="ln542">  }</a>
<a name="ln543">  ThreadPoolMetrics metrics = {</a>
<a name="ln544">          NULL,</a>
<a name="ln545">          NULL,</a>
<a name="ln546">          METRIC_ts_bootstrap_time.Instantiate(server_-&gt;metric_entity())</a>
<a name="ln547">  };</a>
<a name="ln548">  RETURN_NOT_OK(ThreadPoolBuilder(&quot;tablet-bootstrap&quot;)</a>
<a name="ln549">                .set_max_threads(max_bootstrap_threads)</a>
<a name="ln550">                .set_metrics(std::move(metrics))</a>
<a name="ln551">                .Build(&amp;open_tablet_pool_));</a>
<a name="ln552"> </a>
<a name="ln553">  CleanupCheckpoints();</a>
<a name="ln554"> </a>
<a name="ln555">  // Search for tablets in the metadata dir.</a>
<a name="ln556">  vector&lt;string&gt; tablet_ids;</a>
<a name="ln557">  RETURN_NOT_OK(fs_manager_-&gt;ListTabletIds(&amp;tablet_ids));</a>
<a name="ln558"> </a>
<a name="ln559">  InitLocalRaftPeerPB();</a>
<a name="ln560"> </a>
<a name="ln561">  deque&lt;RaftGroupMetadataPtr&gt; metas;</a>
<a name="ln562"> </a>
<a name="ln563">  // First, load all of the tablet metadata. We do this before we start</a>
<a name="ln564">  // submitting the actual OpenTablet() tasks so that we don't have to compete</a>
<a name="ln565">  // for disk resources, etc, with bootstrap processes and running tablets.</a>
<a name="ln566">  MonoTime start(MonoTime::Now());</a>
<a name="ln567">  for (const string&amp; tablet_id : tablet_ids) {</a>
<a name="ln568">    RaftGroupMetadataPtr meta;</a>
<a name="ln569">    RETURN_NOT_OK_PREPEND(OpenTabletMeta(tablet_id, &amp;meta),</a>
<a name="ln570">                          &quot;Failed to open tablet metadata for tablet: &quot; + tablet_id);</a>
<a name="ln571">    if (PREDICT_FALSE(!CanServeTabletData(meta-&gt;tablet_data_state()))) {</a>
<a name="ln572">      RETURN_NOT_OK(HandleNonReadyTabletOnStartup(meta));</a>
<a name="ln573">      continue;</a>
<a name="ln574">    }</a>
<a name="ln575">    RegisterDataAndWalDir(</a>
<a name="ln576">        fs_manager_, meta-&gt;table_id(), meta-&gt;raft_group_id(), meta-&gt;data_root_dir(),</a>
<a name="ln577">        meta-&gt;wal_root_dir());</a>
<a name="ln578">    if (FLAGS_enable_restart_transaction_status_tablets_first) {</a>
<a name="ln579">      // Prioritize bootstrapping transaction status tablets first.</a>
<a name="ln580">      if (meta-&gt;table_type() == TRANSACTION_STATUS_TABLE_TYPE) {</a>
<a name="ln581">        metas.push_front(meta);</a>
<a name="ln582">      } else {</a>
<a name="ln583">        metas.push_back(meta);</a>
<a name="ln584">      }</a>
<a name="ln585">    } else {</a>
<a name="ln586">      metas.push_back(meta);</a>
<a name="ln587">    }</a>
<a name="ln588">  }</a>
<a name="ln589"> </a>
<a name="ln590">  MonoDelta elapsed = MonoTime::Now().GetDeltaSince(start);</a>
<a name="ln591">  LOG(INFO) &lt;&lt; &quot;Loaded metadata for &quot; &lt;&lt; tablet_ids.size() &lt;&lt; &quot; tablet in &quot;</a>
<a name="ln592">            &lt;&lt; elapsed.ToMilliseconds() &lt;&lt; &quot; ms&quot;;</a>
<a name="ln593"> </a>
<a name="ln594">  // Now submit the &quot;Open&quot; task for each.</a>
<a name="ln595">  for (const RaftGroupMetadataPtr&amp; meta : metas) {</a>
<a name="ln596">    scoped_refptr&lt;TransitionInProgressDeleter&gt; deleter;</a>
<a name="ln597">    RETURN_NOT_OK(StartTabletStateTransition(</a>
<a name="ln598">        meta-&gt;raft_group_id(), &quot;opening tablet&quot;, &amp;deleter));</a>
<a name="ln599"> </a>
<a name="ln600">    TabletPeerPtr tablet_peer = VERIFY_RESULT(CreateAndRegisterTabletPeer(meta, NEW_PEER));</a>
<a name="ln601">    RETURN_NOT_OK(open_tablet_pool_-&gt;SubmitFunc(</a>
<a name="ln602">        std::bind(&amp;TSTabletManager::OpenTablet, this, meta, deleter)));</a>
<a name="ln603">  }</a>
<a name="ln604"> </a>
<a name="ln605">  {</a>
<a name="ln606">    std::lock_guard&lt;RWMutex&gt; lock(mutex_);</a>
<a name="ln607">    state_ = MANAGER_RUNNING;</a>
<a name="ln608">  }</a>
<a name="ln609"> </a>
<a name="ln610">  if (background_task_) {</a>
<a name="ln611">    RETURN_NOT_OK(background_task_-&gt;Init());</a>
<a name="ln612">  }</a>
<a name="ln613"> </a>
<a name="ln614">  return Status::OK();</a>
<a name="ln615">}</a>
<a name="ln616"> </a>
<a name="ln617">void TSTabletManager::CleanupCheckpoints() {</a>
<a name="ln618">  for (const auto&amp; data_root : fs_manager_-&gt;GetDataRootDirs()) {</a>
<a name="ln619">    auto tables_dir = JoinPathSegments(data_root, FsManager::kRocksDBDirName);</a>
<a name="ln620">    auto tables = fs_manager_-&gt;env()-&gt;GetChildren(tables_dir, ExcludeDots::kTrue);</a>
<a name="ln621">    if (!tables.ok()) {</a>
<a name="ln622">      LOG_WITH_PREFIX(WARNING)</a>
<a name="ln623">          &lt;&lt; &quot;Failed to get tables in &quot; &lt;&lt; tables_dir &lt;&lt; &quot;: &quot; &lt;&lt; tables.status();</a>
<a name="ln624">      continue;</a>
<a name="ln625">    }</a>
<a name="ln626">    for (const auto&amp; table : *tables) {</a>
<a name="ln627">      auto table_dir = JoinPathSegments(tables_dir, table);</a>
<a name="ln628">      auto tablets = fs_manager_-&gt;env()-&gt;GetChildren(table_dir, ExcludeDots::kTrue);</a>
<a name="ln629">      if (!tablets.ok()) {</a>
<a name="ln630">        LOG_WITH_PREFIX(WARNING)</a>
<a name="ln631">            &lt;&lt; &quot;Failed to get tablets in &quot; &lt;&lt; table_dir &lt;&lt; &quot;: &quot; &lt;&lt; tables.status();</a>
<a name="ln632">        continue;</a>
<a name="ln633">      }</a>
<a name="ln634">      for (const auto&amp; tablet : *tablets) {</a>
<a name="ln635">        auto checkpoints_dir = JoinPathSegments(</a>
<a name="ln636">            table_dir, tablet, RemoteBootstrapSession::kCheckpointsDir);</a>
<a name="ln637">        if (fs_manager_-&gt;env()-&gt;FileExists(checkpoints_dir)) {</a>
<a name="ln638">          LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Cleaning up checkpoints dir: &quot; &lt;&lt; yb::ToString(checkpoints_dir);</a>
<a name="ln639">          auto status = fs_manager_-&gt;env()-&gt;DeleteRecursively(checkpoints_dir);</a>
<a name="ln640">          WARN_NOT_OK(status, Format(&quot;Cleanup of checkpoints dir $0 failed&quot;, checkpoints_dir));</a>
<a name="ln641">        }</a>
<a name="ln642">      }</a>
<a name="ln643">    }</a>
<a name="ln644">  }</a>
<a name="ln645">}</a>
<a name="ln646"> </a>
<a name="ln647">Status TSTabletManager::Start() {</a>
<a name="ln648">  async_client_init_-&gt;Start();</a>
<a name="ln649"> </a>
<a name="ln650">  return Status::OK();</a>
<a name="ln651">}</a>
<a name="ln652"> </a>
<a name="ln653">Status TSTabletManager::WaitForAllBootstrapsToFinish() {</a>
<a name="ln654">  CHECK_EQ(state(), MANAGER_RUNNING);</a>
<a name="ln655"> </a>
<a name="ln656">  open_tablet_pool_-&gt;Wait();</a>
<a name="ln657"> </a>
<a name="ln658">  Status s = Status::OK();</a>
<a name="ln659"> </a>
<a name="ln660">  SharedLock&lt;RWMutex&gt; shared_lock(mutex_);</a>
<a name="ln661">  for (const TabletMap::value_type&amp; entry : tablet_map_) {</a>
<a name="ln662">    if (entry.second-&gt;state() == tablet::FAILED) {</a>
<a name="ln663">      if (s.ok()) {</a>
<a name="ln664">        s = entry.second-&gt;error();</a>
<a name="ln665">      }</a>
<a name="ln666">    }</a>
<a name="ln667">  }</a>
<a name="ln668"> </a>
<a name="ln669">  return s;</a>
<a name="ln670">}</a>
<a name="ln671"> </a>
<a name="ln672">Result&lt;scoped_refptr&lt;TransitionInProgressDeleter&gt;&gt;</a>
<a name="ln673">TSTabletManager::StartTabletStateTransitionForCreation(const TabletId&amp; tablet_id) {</a>
<a name="ln674">  scoped_refptr&lt;TransitionInProgressDeleter&gt; deleter;</a>
<a name="ln675">  SharedLock&lt;RWMutex&gt; lock(mutex_);</a>
<a name="ln676">  TRACE(&quot;Acquired tablet manager lock&quot;);</a>
<a name="ln677"> </a>
<a name="ln678">  // Sanity check that the tablet isn't already registered.</a>
<a name="ln679">  TabletPeerPtr junk;</a>
<a name="ln680">  if (LookupTabletUnlocked(tablet_id, &amp;junk)) {</a>
<a name="ln681">    return STATUS(AlreadyPresent, &quot;Tablet already registered&quot;, tablet_id);</a>
<a name="ln682">  }</a>
<a name="ln683"> </a>
<a name="ln684">  RETURN_NOT_OK(StartTabletStateTransition(tablet_id, &quot;creating tablet&quot;, &amp;deleter));</a>
<a name="ln685"> </a>
<a name="ln686">  return deleter;</a>
<a name="ln687">}</a>
<a name="ln688"> </a>
<a name="ln689">Status TSTabletManager::CreateNewTablet(</a>
<a name="ln690">    const string&amp; table_id,</a>
<a name="ln691">    const string&amp; tablet_id,</a>
<a name="ln692">    const Partition&amp; partition,</a>
<a name="ln693">    const string&amp; namespace_name,</a>
<a name="ln694">    const string&amp; table_name,</a>
<a name="ln695">    TableType table_type,</a>
<a name="ln696">    const Schema&amp; schema,</a>
<a name="ln697">    const PartitionSchema&amp; partition_schema,</a>
<a name="ln698">    const boost::optional&lt;IndexInfo&gt;&amp; index_info,</a>
<a name="ln699">    RaftConfigPB config,</a>
<a name="ln700">    TabletPeerPtr* tablet_peer,</a>
<a name="ln701">    const bool colocated) {</a>
<a name="ln702">  if (state() != MANAGER_RUNNING) {</a>
<a name="ln703">    return STATUS_FORMAT(IllegalState, &quot;Manager is not running: $0&quot;, state());</a>
<a name="ln704">  }</a>
<a name="ln705">  CHECK(IsRaftConfigMember(server_-&gt;instance_pb().permanent_uuid(), config));</a>
<a name="ln706"> </a>
<a name="ln707">  for (int i = 0; i &lt; config.peers_size(); ++i) {</a>
<a name="ln708">    const auto&amp; config_peer = config.peers(i);</a>
<a name="ln709">    CHECK(config_peer.has_member_type());</a>
<a name="ln710">  }</a>
<a name="ln711"> </a>
<a name="ln712">  // Set the initial opid_index for a RaftConfigPB to -1.</a>
<a name="ln713">  config.set_opid_index(consensus::kInvalidOpIdIndex);</a>
<a name="ln714"> </a>
<a name="ln715">  scoped_refptr&lt;TransitionInProgressDeleter&gt; deleter =</a>
<a name="ln716">      VERIFY_RESULT(StartTabletStateTransitionForCreation(tablet_id));</a>
<a name="ln717"> </a>
<a name="ln718">  // Create the metadata.</a>
<a name="ln719">  TRACE(&quot;Creating new metadata...&quot;);</a>
<a name="ln720">  RaftGroupMetadataPtr meta;</a>
<a name="ln721">  string data_root_dir;</a>
<a name="ln722">  string wal_root_dir;</a>
<a name="ln723">  GetAndRegisterDataAndWalDir(fs_manager_, table_id, tablet_id, &amp;data_root_dir, &amp;wal_root_dir);</a>
<a name="ln724">  Status create_status = RaftGroupMetadata::CreateNew(fs_manager_,</a>
<a name="ln725">                                                   table_id,</a>
<a name="ln726">                                                   tablet_id,</a>
<a name="ln727">                                                   namespace_name,</a>
<a name="ln728">                                                   table_name,</a>
<a name="ln729">                                                   table_type,</a>
<a name="ln730">                                                   schema,</a>
<a name="ln731">                                                   IndexMap(),</a>
<a name="ln732">                                                   partition_schema,</a>
<a name="ln733">                                                   partition,</a>
<a name="ln734">                                                   index_info,</a>
<a name="ln735">                                                   0 /* schema_version */,</a>
<a name="ln736">                                                   TABLET_DATA_READY,</a>
<a name="ln737">                                                   &amp;meta,</a>
<a name="ln738">                                                   data_root_dir,</a>
<a name="ln739">                                                   wal_root_dir,</a>
<a name="ln740">                                                   colocated);</a>
<a name="ln741">  if (!create_status.ok()) {</a>
<a name="ln742">    UnregisterDataWalDir(table_id, tablet_id, data_root_dir, wal_root_dir);</a>
<a name="ln743">  }</a>
<a name="ln744">  RETURN_NOT_OK_PREPEND(create_status, &quot;Couldn't create tablet metadata&quot;)</a>
<a name="ln745">  LOG(INFO) &lt;&lt; TabletLogPrefix(tablet_id)</a>
<a name="ln746">            &lt;&lt; &quot;Created tablet metadata for table: &quot; &lt;&lt; table_id;</a>
<a name="ln747"> </a>
<a name="ln748">  // We must persist the consensus metadata to disk before starting a new</a>
<a name="ln749">  // tablet's TabletPeer and Consensus implementation.</a>
<a name="ln750">  std::unique_ptr&lt;ConsensusMetadata&gt; cmeta;</a>
<a name="ln751">  RETURN_NOT_OK_PREPEND(ConsensusMetadata::Create(fs_manager_, tablet_id, fs_manager_-&gt;uuid(),</a>
<a name="ln752">                                                  config, consensus::kMinimumTerm, &amp;cmeta),</a>
<a name="ln753">                        &quot;Unable to create new ConsensusMeta for tablet &quot; + tablet_id);</a>
<a name="ln754">  TabletPeerPtr new_peer = VERIFY_RESULT(CreateAndRegisterTabletPeer(meta, NEW_PEER));</a>
<a name="ln755"> </a>
<a name="ln756">  // We can run this synchronously since there is nothing to bootstrap.</a>
<a name="ln757">  RETURN_NOT_OK(</a>
<a name="ln758">      open_tablet_pool_-&gt;SubmitFunc(std::bind(&amp;TSTabletManager::OpenTablet, this, meta, deleter)));</a>
<a name="ln759"> </a>
<a name="ln760">  if (tablet_peer) {</a>
<a name="ln761">    *tablet_peer = new_peer;</a>
<a name="ln762">  }</a>
<a name="ln763">  return Status::OK();</a>
<a name="ln764">}</a>
<a name="ln765"> </a>
<a name="ln766">struct TabletCreationMetaData {</a>
<a name="ln767">  TabletId tablet_id;</a>
<a name="ln768">  scoped_refptr&lt;TransitionInProgressDeleter&gt; transition_deleter;</a>
<a name="ln769">  Partition partition;</a>
<a name="ln770">  docdb::KeyBounds key_bounds;</a>
<a name="ln771">  RaftGroupMetadataPtr raft_group_metadata;</a>
<a name="ln772">};</a>
<a name="ln773"> </a>
<a name="ln774">namespace {</a>
<a name="ln775"> </a>
<a name="ln776">// Creates SplitTabletsCreationMetaData for two new tablets for `tablet` splitting based on request.</a>
<a name="ln777">SplitTabletsCreationMetaData PrepareTabletCreationMetaDataForSplit(</a>
<a name="ln778">    const SplitTabletRequestPB&amp; request, const tablet::Tablet&amp; tablet) {</a>
<a name="ln779">  SplitTabletsCreationMetaData metas;</a>
<a name="ln780"> </a>
<a name="ln781">  const auto&amp; split_partition_key = request.split_partition_key();</a>
<a name="ln782">  const auto&amp; split_encoded_key = request.split_encoded_key();</a>
<a name="ln783"> </a>
<a name="ln784">  std::shared_ptr&lt;Partition&gt; source_partition = tablet.metadata()-&gt;partition();</a>
<a name="ln785">  const auto source_key_bounds = *tablet.doc_db().key_bounds;</a>
<a name="ln786"> </a>
<a name="ln787">  {</a>
<a name="ln788">    TabletCreationMetaData meta;</a>
<a name="ln789">    meta.tablet_id = request.new_tablet1_id();</a>
<a name="ln790">    meta.partition = *source_partition;</a>
<a name="ln791">    meta.key_bounds = source_key_bounds;</a>
<a name="ln792">    meta.partition.set_partition_key_end(split_partition_key);</a>
<a name="ln793">    meta.key_bounds.upper.Reset(split_encoded_key);</a>
<a name="ln794">    metas.push_back(meta);</a>
<a name="ln795">  }</a>
<a name="ln796"> </a>
<a name="ln797">  {</a>
<a name="ln798">    TabletCreationMetaData meta;</a>
<a name="ln799">    meta.tablet_id = request.new_tablet2_id();</a>
<a name="ln800">    meta.partition = *source_partition;</a>
<a name="ln801">    meta.key_bounds = source_key_bounds;</a>
<a name="ln802">    meta.partition.set_partition_key_start(split_partition_key);</a>
<a name="ln803">    meta.key_bounds.lower.Reset(split_encoded_key);</a>
<a name="ln804">    metas.push_back(meta);</a>
<a name="ln805">  }</a>
<a name="ln806"> </a>
<a name="ln807">  return metas;</a>
<a name="ln808">}</a>
<a name="ln809"> </a>
<a name="ln810">}  // namespace</a>
<a name="ln811"> </a>
<a name="ln812">Status TSTabletManager::StartSubtabletsSplit(</a>
<a name="ln813">    const RaftGroupMetadata&amp; source_tablet_meta, SplitTabletsCreationMetaData* tcmetas) {</a>
<a name="ln814">  auto* const env = fs_manager_-&gt;env();</a>
<a name="ln815"> </a>
<a name="ln816">  auto iter = tcmetas-&gt;begin();</a>
<a name="ln817">  while (iter != tcmetas-&gt;end()) {</a>
<a name="ln818">    const auto&amp; subtablet_id = iter-&gt;tablet_id;</a>
<a name="ln819"> </a>
<a name="ln820">    iter-&gt;transition_deleter = VERIFY_RESULT(StartTabletStateTransitionForCreation(subtablet_id));</a>
<a name="ln821"> </a>
<a name="ln822">    // Try to load metadata from previous not completed split.</a>
<a name="ln823">    if (RaftGroupMetadata::Load(fs_manager_, subtablet_id, &amp;iter-&gt;raft_group_metadata).ok() &amp;&amp;</a>
<a name="ln824">        CanServeTabletData(iter-&gt;raft_group_metadata-&gt;tablet_data_state())) {</a>
<a name="ln825">      // Sub tablet has been already created and ready during previous split attempt,</a>
<a name="ln826">      // no need to re-create.</a>
<a name="ln827">      iter = tcmetas-&gt;erase(iter);</a>
<a name="ln828">      continue;</a>
<a name="ln829">    }</a>
<a name="ln830"> </a>
<a name="ln831">    // Delete on-disk data for new tablet IDs in case it is present as a leftover from previously</a>
<a name="ln832">    // failed tablet split attempt.</a>
<a name="ln833">    // TODO(tsplit): add test for that.</a>
<a name="ln834">    const auto data_dir = source_tablet_meta.GetSubRaftGroupDataDir(subtablet_id);</a>
<a name="ln835">    if (env-&gt;FileExists(data_dir)) {</a>
<a name="ln836">      RETURN_NOT_OK_PREPEND(</a>
<a name="ln837">          env-&gt;DeleteRecursively(data_dir),</a>
<a name="ln838">          Format(&quot;Unable to recursively delete data dir for tablet $0&quot;, subtablet_id));</a>
<a name="ln839">    }</a>
<a name="ln840">    RETURN_NOT_OK(Log::DeleteOnDiskData(</a>
<a name="ln841">        env, subtablet_id, source_tablet_meta.GetSubRaftGroupWalDir(subtablet_id),</a>
<a name="ln842">        fs_manager_-&gt;uuid()));</a>
<a name="ln843">    RETURN_NOT_OK(ConsensusMetadata::DeleteOnDiskData(fs_manager_, subtablet_id));</a>
<a name="ln844"> </a>
<a name="ln845">    ++iter;</a>
<a name="ln846">  }</a>
<a name="ln847">  return Status::OK();</a>
<a name="ln848">}</a>
<a name="ln849"> </a>
<a name="ln850">void TSTabletManager::CreatePeerAndOpenTablet(</a>
<a name="ln851">    const tablet::RaftGroupMetadataPtr&amp; meta,</a>
<a name="ln852">    const scoped_refptr&lt;TransitionInProgressDeleter&gt;&amp; deleter) {</a>
<a name="ln853">  Status s = ResultToStatus(CreateAndRegisterTabletPeer(meta, NEW_PEER));</a>
<a name="ln854">  if (!s.ok()) {</a>
<a name="ln855">    LOG(DFATAL) &lt;&lt; &quot;Failed to create and register tablet peer: &quot; &lt;&lt; s;</a>
<a name="ln856">    return;</a>
<a name="ln857">  }</a>
<a name="ln858">  s = open_tablet_pool_-&gt;SubmitFunc(std::bind(&amp;TSTabletManager::OpenTablet, this, meta, deleter));</a>
<a name="ln859">  if (!s.ok()) {</a>
<a name="ln860">    LOG(DFATAL) &lt;&lt; Format(&quot;Failed to schedule opening tablet $0: $1&quot;, meta-&gt;table_id(), s);</a>
<a name="ln861">    return;</a>
<a name="ln862">  }</a>
<a name="ln863">}</a>
<a name="ln864"> </a>
<a name="ln865">Status TSTabletManager::ApplyTabletSplit(tablet::SplitOperationState* op_state) {</a>
<a name="ln866">  if (state() != MANAGER_RUNNING) {</a>
<a name="ln867">    return STATUS_FORMAT(IllegalState, &quot;Manager is not running: $0&quot;, state());</a>
<a name="ln868">  }</a>
<a name="ln869"> </a>
<a name="ln870">  auto* tablet = CHECK_NOTNULL(op_state-&gt;tablet());</a>
<a name="ln871">  const auto tablet_id = tablet-&gt;tablet_id();</a>
<a name="ln872">  const auto* request = op_state-&gt;request();</a>
<a name="ln873">  SCHECK_EQ(</a>
<a name="ln874">      request-&gt;tablet_id(), tablet_id, IllegalState,</a>
<a name="ln875">      Format(</a>
<a name="ln876">          &quot;Unexpected SPLIT_OP $0 designated for tablet $1 to be applied to tablet $2&quot;,</a>
<a name="ln877">          op_state-&gt;op_id(), request-&gt;tablet_id(), tablet_id));</a>
<a name="ln878">  SCHECK(</a>
<a name="ln879">      tablet_id != request-&gt;new_tablet1_id() &amp;&amp; tablet_id != request-&gt;new_tablet2_id(),</a>
<a name="ln880">      IllegalState,</a>
<a name="ln881">      Format(</a>
<a name="ln882">          &quot;One of SPLIT_OP $0 destination tablet IDs ($1, $2) is the same as source tablet ID $3&quot;,</a>
<a name="ln883">          op_state-&gt;op_id(), request-&gt;new_tablet1_id(), request-&gt;new_tablet2_id(), tablet_id));</a>
<a name="ln884"> </a>
<a name="ln885">  auto tablet_peer = VERIFY_RESULT(LookupTablet(tablet_id));</a>
<a name="ln886">  RETURN_NOT_OK(tablet_peer-&gt;raft_consensus()-&gt;FlushLogIndex());</a>
<a name="ln887"> </a>
<a name="ln888">  auto&amp; meta = *CHECK_NOTNULL(tablet-&gt;metadata());</a>
<a name="ln889"> </a>
<a name="ln890">  // TODO(tsplit): We can later implement better per-disk distribution during compaction of split</a>
<a name="ln891">  // tablets.</a>
<a name="ln892">  const auto table_id = meta.table_id();</a>
<a name="ln893">  const auto data_root_dir =</a>
<a name="ln894">      VERIFY_RESULT(GetAssignedRootDirForTablet(TabletDirType::kData, table_id, tablet_id));</a>
<a name="ln895">  const auto wal_root_dir =</a>
<a name="ln896">      VERIFY_RESULT(GetAssignedRootDirForTablet(TabletDirType::kWal, table_id, tablet_id));</a>
<a name="ln897"> </a>
<a name="ln898">  if (FLAGS_TEST_apply_tablet_split_inject_delay_ms &gt; 0) {</a>
<a name="ln899">    LOG(INFO) &lt;&lt; &quot;TEST: ApplyTabletSplit: injecting delay of &quot;</a>
<a name="ln900">              &lt;&lt; FLAGS_TEST_apply_tablet_split_inject_delay_ms &lt;&lt; &quot; ms for &quot; &lt;&lt; AsString(*op_state);</a>
<a name="ln901">    std::this_thread::sleep_for(FLAGS_TEST_apply_tablet_split_inject_delay_ms * 1ms);</a>
<a name="ln902">    LOG(INFO) &lt;&lt; &quot;TEST: ApplyTabletSplit: delay finished&quot;;</a>
<a name="ln903">  }</a>
<a name="ln904"> </a>
<a name="ln905">  auto tcmetas = PrepareTabletCreationMetaDataForSplit(*request, *tablet);</a>
<a name="ln906"> </a>
<a name="ln907">  RETURN_NOT_OK(StartSubtabletsSplit(meta, &amp;tcmetas));</a>
<a name="ln908"> </a>
<a name="ln909">  for (const auto&amp; tcmeta : tcmetas) {</a>
<a name="ln910">    RegisterDataAndWalDir(fs_manager_, table_id, tcmeta.tablet_id, data_root_dir, wal_root_dir);</a>
<a name="ln911">  }</a>
<a name="ln912"> </a>
<a name="ln913">  bool successfully_completed = false;</a>
<a name="ln914">  auto se = ScopeExit([&amp;] {</a>
<a name="ln915">    if (!successfully_completed) {</a>
<a name="ln916">      for (const auto&amp; tcmeta : tcmetas) {</a>
<a name="ln917">        UnregisterDataWalDir(table_id, tcmeta.tablet_id, data_root_dir, wal_root_dir);</a>
<a name="ln918">      }</a>
<a name="ln919">    }</a>
<a name="ln920">  });</a>
<a name="ln921"> </a>
<a name="ln922">  std::unique_ptr&lt;ConsensusMetadata&gt; cmeta;</a>
<a name="ln923">  RETURN_NOT_OK(ConsensusMetadata::Load(fs_manager_, tablet_id, fs_manager_-&gt;uuid(), &amp;cmeta));</a>
<a name="ln924"> </a>
<a name="ln925">  for (auto&amp; tcmeta : tcmetas) {</a>
<a name="ln926">    const auto&amp; new_tablet_id = tcmeta.tablet_id;</a>
<a name="ln927"> </a>
<a name="ln928">    // Copy raft group metadata.</a>
<a name="ln929">    tcmeta.raft_group_metadata = VERIFY_RESULT(tablet-&gt;CreateSubtablet(</a>
<a name="ln930">        new_tablet_id, tcmeta.partition, tcmeta.key_bounds, yb::OpId::FromPB(op_state-&gt;op_id()),</a>
<a name="ln931">        op_state-&gt;hybrid_time()));</a>
<a name="ln932">    LOG(INFO) &lt;&lt; &quot;Created raft group metadata for table: &quot; &lt;&lt; table_id</a>
<a name="ln933">              &lt;&lt; &quot; tablet: &quot; &lt;&lt; new_tablet_id;</a>
<a name="ln934"> </a>
<a name="ln935">    // Copy consensus metadata.</a>
<a name="ln936">    // Here we reuse the same cmeta instance for both new tablets. This is safe, because:</a>
<a name="ln937">    // 1) Their consensus metadata only differ by tablet id.</a>
<a name="ln938">    // 2) Flush() will save it into a new path corresponding to tablet id we set before flushing.</a>
<a name="ln939">    cmeta-&gt;set_tablet_id(new_tablet_id);</a>
<a name="ln940">    RETURN_NOT_OK(cmeta-&gt;Flush());</a>
<a name="ln941"> </a>
<a name="ln942">    const auto&amp; dest_wal_dir = tcmeta.raft_group_metadata-&gt;wal_dir();</a>
<a name="ln943">    RETURN_NOT_OK(tablet_peer-&gt;raft_consensus()-&gt;CopyLogTo(dest_wal_dir));</a>
<a name="ln944"> </a>
<a name="ln945">    tcmeta.raft_group_metadata-&gt;set_tablet_data_state(TABLET_DATA_READY);</a>
<a name="ln946">    RETURN_NOT_OK(tcmeta.raft_group_metadata-&gt;Flush());</a>
<a name="ln947">  }</a>
<a name="ln948"> </a>
<a name="ln949">  meta.set_tablet_data_state(tablet::TABLET_DATA_SPLIT_COMPLETED);</a>
<a name="ln950">  RETURN_NOT_OK(meta.Flush());</a>
<a name="ln951"> </a>
<a name="ln952">  for (auto&amp; tcmeta : tcmetas) {</a>
<a name="ln953">    // Call CreatePeerAndOpenTablet asynchronously to avoid write-locking TSTabletManager::mutex_</a>
<a name="ln954">    // here since apply of SPLIT_OP is done under ReplicaState lock and this could lead to deadlock</a>
<a name="ln955">    // in case of reverse lock order in some other thread.</a>
<a name="ln956">    // See https://github.com/yugabyte/yugabyte-db/issues/4312 for more details.</a>
<a name="ln957">    RETURN_NOT_OK(apply_pool_-&gt;SubmitFunc(std::bind(</a>
<a name="ln958">        &amp;TSTabletManager::CreatePeerAndOpenTablet, this, tcmeta.raft_group_metadata,</a>
<a name="ln959">        tcmeta.transition_deleter)));</a>
<a name="ln960">  }</a>
<a name="ln961"> </a>
<a name="ln962">  successfully_completed = true;</a>
<a name="ln963">  return Status::OK();</a>
<a name="ln964">}</a>
<a name="ln965"> </a>
<a name="ln966">string LogPrefix(const string&amp; tablet_id, const string&amp; uuid) {</a>
<a name="ln967">  return &quot;T &quot; + tablet_id + &quot; P &quot; + uuid + &quot;: &quot;;</a>
<a name="ln968">}</a>
<a name="ln969"> </a>
<a name="ln970">Status CheckLeaderTermNotLower(</a>
<a name="ln971">    const string&amp; tablet_id,</a>
<a name="ln972">    const string&amp; uuid,</a>
<a name="ln973">    int64_t leader_term,</a>
<a name="ln974">    int64_t last_logged_term) {</a>
<a name="ln975">  if (PREDICT_FALSE(leader_term &lt; last_logged_term)) {</a>
<a name="ln976">    Status s = STATUS(InvalidArgument,</a>
<a name="ln977">        Substitute(&quot;Leader has replica of tablet $0 with term $1 lower than last &quot;</a>
<a name="ln978">                   &quot;logged term $2 on local replica. Rejecting remote bootstrap request&quot;,</a>
<a name="ln979">                   tablet_id, leader_term, last_logged_term));</a>
<a name="ln980">    LOG(WARNING) &lt;&lt; LogPrefix(tablet_id, uuid) &lt;&lt; &quot;Remote bootstrap: &quot; &lt;&lt; s;</a>
<a name="ln981">    return s;</a>
<a name="ln982">  }</a>
<a name="ln983">  return Status::OK();</a>
<a name="ln984">}</a>
<a name="ln985"> </a>
<a name="ln986">Status HandleReplacingStaleTablet(</a>
<a name="ln987">    RaftGroupMetadataPtr meta,</a>
<a name="ln988">    TabletPeerPtr old_tablet_peer,</a>
<a name="ln989">    const string&amp; tablet_id,</a>
<a name="ln990">    const string&amp; uuid,</a>
<a name="ln991">    const int64_t&amp; leader_term) {</a>
<a name="ln992">  TabletDataState data_state = meta-&gt;tablet_data_state();</a>
<a name="ln993">  switch (data_state) {</a>
<a name="ln994">    case TABLET_DATA_COPYING: {</a>
<a name="ln995">      // This should not be possible due to the transition_in_progress_ &quot;lock&quot;.</a>
<a name="ln996">      LOG(FATAL) &lt;&lt; LogPrefix(tablet_id, uuid) &lt;&lt; &quot; Remote bootstrap: &quot;</a>
<a name="ln997">                 &lt;&lt; &quot;Found tablet in TABLET_DATA_COPYING state during StartRemoteBootstrap()&quot;;</a>
<a name="ln998">    }</a>
<a name="ln999">    case TABLET_DATA_TOMBSTONED: {</a>
<a name="ln1000">      RETURN_NOT_OK(old_tablet_peer-&gt;CheckShutdownOrNotStarted());</a>
<a name="ln1001">      int64_t last_logged_term = meta-&gt;tombstone_last_logged_opid().term;</a>
<a name="ln1002">      RETURN_NOT_OK(CheckLeaderTermNotLower(tablet_id,</a>
<a name="ln1003">                                            uuid,</a>
<a name="ln1004">                                            leader_term,</a>
<a name="ln1005">                                            last_logged_term));</a>
<a name="ln1006">      break;</a>
<a name="ln1007">    }</a>
<a name="ln1008">    case TABLET_DATA_SPLIT_COMPLETED:</a>
<a name="ln1009">    case TABLET_DATA_READY: {</a>
<a name="ln1010">      if (tablet_id == master::kSysCatalogTabletId) {</a>
<a name="ln1011">        LOG(FATAL) &lt;&lt; LogPrefix(tablet_id, uuid) &lt;&lt; &quot; Remote bootstrap: &quot;</a>
<a name="ln1012">                   &lt;&lt; &quot;Found tablet in &quot; &lt;&lt; TabletDataState_Name(data_state)</a>
<a name="ln1013">                   &lt;&lt; &quot; state during StartRemoteBootstrap()&quot;;</a>
<a name="ln1014">      }</a>
<a name="ln1015">      // There's a valid race here that can lead us to come here:</a>
<a name="ln1016">      // 1. Leader sends a second remote bootstrap request as a result of receiving a</a>
<a name="ln1017">      // TABLET_NOT_FOUND from this tserver while it was in the middle of a remote bootstrap.</a>
<a name="ln1018">      // 2. The remote bootstrap request arrives after the first one is finished, and it is able to</a>
<a name="ln1019">      // grab the mutex.</a>
<a name="ln1020">      // 3. This tserver finds that it already has the metadata for the tablet, and determines that</a>
<a name="ln1021">      // it needs to replace the tablet setting replacing_tablet to true.</a>
<a name="ln1022">      // In this case, the master can simply ignore this error.</a>
<a name="ln1023">      return STATUS_FORMAT(</a>
<a name="ln1024">          IllegalState, &quot;Tablet $0 in $1 state&quot;, tablet_id, TabletDataState_Name(data_state));</a>
<a name="ln1025">    }</a>
<a name="ln1026">    default: {</a>
<a name="ln1027">      return STATUS(IllegalState,</a>
<a name="ln1028">          Substitute(&quot;Found tablet $0 in unexpected state $1 for remote bootstrap.&quot;,</a>
<a name="ln1029">                     tablet_id, TabletDataState_Name(data_state)));</a>
<a name="ln1030">    }</a>
<a name="ln1031">  }</a>
<a name="ln1032"> </a>
<a name="ln1033">  return Status::OK();</a>
<a name="ln1034">}</a>
<a name="ln1035"> </a>
<a name="ln1036">Status TSTabletManager::StartRemoteBootstrap(const StartRemoteBootstrapRequestPB&amp; req) {</a>
<a name="ln1037">  // To prevent racing against Shutdown, we increment this as soon as we start. This should be done</a>
<a name="ln1038">  // before checking for ClosingUnlocked, as on shutdown, we proceed in reverse:</a>
<a name="ln1039">  // - first mark as closing</a>
<a name="ln1040">  // - then wait for num_tablets_being_remote_bootstrapped_ == 0</a>
<a name="ln1041">  ++num_tablets_being_remote_bootstrapped_;</a>
<a name="ln1042">  auto decrement_num_rbs_se = ScopeExit([this](){</a>
<a name="ln1043">    --num_tablets_being_remote_bootstrapped_;</a>
<a name="ln1044">  });</a>
<a name="ln1045"> </a>
<a name="ln1046">  LongOperationTracker tracker(&quot;StartRemoteBootstrap&quot;, 5s);</a>
<a name="ln1047"> </a>
<a name="ln1048">  const string&amp; tablet_id = req.tablet_id();</a>
<a name="ln1049">  const string&amp; bootstrap_peer_uuid = req.bootstrap_peer_uuid();</a>
<a name="ln1050">  HostPort bootstrap_peer_addr = HostPortFromPB(DesiredHostPort(</a>
<a name="ln1051">      req.source_broadcast_addr(), req.source_private_addr(), req.source_cloud_info(),</a>
<a name="ln1052">      server_-&gt;MakeCloudInfoPB()));</a>
<a name="ln1053">  int64_t leader_term = req.caller_term();</a>
<a name="ln1054"> </a>
<a name="ln1055">  const string kLogPrefix = TabletLogPrefix(tablet_id);</a>
<a name="ln1056"> </a>
<a name="ln1057">  TabletPeerPtr old_tablet_peer;</a>
<a name="ln1058">  RaftGroupMetadataPtr meta;</a>
<a name="ln1059">  bool replacing_tablet = false;</a>
<a name="ln1060">  scoped_refptr&lt;TransitionInProgressDeleter&gt; deleter;</a>
<a name="ln1061">  {</a>
<a name="ln1062">    std::lock_guard&lt;RWMutex&gt; lock(mutex_);</a>
<a name="ln1063">    if (ClosingUnlocked()) {</a>
<a name="ln1064">      auto result = STATUS_FORMAT(</a>
<a name="ln1065">          IllegalState, &quot;StartRemoteBootstrap in wrong state: $0&quot;,</a>
<a name="ln1066">          TSTabletManagerStatePB_Name(state_));</a>
<a name="ln1067">      LOG(WARNING) &lt;&lt; kLogPrefix &lt;&lt; result;</a>
<a name="ln1068">      return result;</a>
<a name="ln1069">    }</a>
<a name="ln1070"> </a>
<a name="ln1071">    if (LookupTabletUnlocked(tablet_id, &amp;old_tablet_peer)) {</a>
<a name="ln1072">      meta = old_tablet_peer-&gt;tablet_metadata();</a>
<a name="ln1073">      replacing_tablet = true;</a>
<a name="ln1074">    }</a>
<a name="ln1075">    RETURN_NOT_OK(StartTabletStateTransition(</a>
<a name="ln1076">        tablet_id, Substitute(&quot;remote bootstrapping tablet from peer $0&quot;, bootstrap_peer_uuid),</a>
<a name="ln1077">        &amp;deleter));</a>
<a name="ln1078">  }</a>
<a name="ln1079"> </a>
<a name="ln1080">  if (replacing_tablet) {</a>
<a name="ln1081">    // Make sure the existing tablet peer is shut down and tombstoned.</a>
<a name="ln1082">    RETURN_NOT_OK(HandleReplacingStaleTablet(meta,</a>
<a name="ln1083">                                             old_tablet_peer,</a>
<a name="ln1084">                                             tablet_id,</a>
<a name="ln1085">                                             fs_manager_-&gt;uuid(),</a>
<a name="ln1086">                                             leader_term));</a>
<a name="ln1087">  }</a>
<a name="ln1088"> </a>
<a name="ln1089">  string init_msg = kLogPrefix + Substitute(&quot;Initiating remote bootstrap from Peer $0 ($1)&quot;,</a>
<a name="ln1090">                                            bootstrap_peer_uuid, bootstrap_peer_addr.ToString());</a>
<a name="ln1091">  LOG(INFO) &lt;&lt; init_msg;</a>
<a name="ln1092">  TRACE(init_msg);</a>
<a name="ln1093"> </a>
<a name="ln1094">  auto rb_client = std::make_unique&lt;RemoteBootstrapClient&gt;(tablet_id, fs_manager_);</a>
<a name="ln1095"> </a>
<a name="ln1096">  // Download and persist the remote superblock in TABLET_DATA_COPYING state.</a>
<a name="ln1097">  if (replacing_tablet) {</a>
<a name="ln1098">    RETURN_NOT_OK(rb_client-&gt;SetTabletToReplace(meta, leader_term));</a>
<a name="ln1099">  }</a>
<a name="ln1100">  RETURN_NOT_OK(rb_client-&gt;Start(bootstrap_peer_uuid,</a>
<a name="ln1101">                                 &amp;server_-&gt;proxy_cache(),</a>
<a name="ln1102">                                 bootstrap_peer_addr,</a>
<a name="ln1103">                                 &amp;meta,</a>
<a name="ln1104">                                 this));</a>
<a name="ln1105"> </a>
<a name="ln1106">  // From this point onward, the superblock is persisted in TABLET_DATA_COPYING</a>
<a name="ln1107">  // state, and we need to tombstone the tablet if additional steps prior to</a>
<a name="ln1108">  // getting to a TABLET_DATA_READY state fail.</a>
<a name="ln1109"> </a>
<a name="ln1110">  // Registering a non-initialized TabletPeer offers visibility through the Web UI.</a>
<a name="ln1111">  RegisterTabletPeerMode mode = replacing_tablet ? REPLACEMENT_PEER : NEW_PEER;</a>
<a name="ln1112">  TabletPeerPtr tablet_peer = VERIFY_RESULT(CreateAndRegisterTabletPeer(meta, mode));</a>
<a name="ln1113">  MarkTabletBeingRemoteBootstrapped(tablet_peer-&gt;tablet_id(),</a>
<a name="ln1114">      tablet_peer-&gt;tablet_metadata()-&gt;table_id());</a>
<a name="ln1115"> </a>
<a name="ln1116">  // TODO: If we ever make this method asynchronous, we need to move this code somewhere else.</a>
<a name="ln1117">  auto se = ScopeExit([this, tablet_peer] {</a>
<a name="ln1118">    UnmarkTabletBeingRemoteBootstrapped(tablet_peer-&gt;tablet_id(),</a>
<a name="ln1119">        tablet_peer-&gt;tablet_metadata()-&gt;table_id());</a>
<a name="ln1120">  });</a>
<a name="ln1121"> </a>
<a name="ln1122">  // Download all of the remote files.</a>
<a name="ln1123">  TOMBSTONE_NOT_OK(rb_client-&gt;FetchAll(tablet_peer-&gt;status_listener()),</a>
<a name="ln1124">                   meta,</a>
<a name="ln1125">                   fs_manager_-&gt;uuid(),</a>
<a name="ln1126">                   &quot;Remote bootstrap: Unable to fetch data from remote peer &quot; +</a>
<a name="ln1127">                       bootstrap_peer_uuid + &quot; (&quot; + bootstrap_peer_addr.ToString() + &quot;)&quot;,</a>
<a name="ln1128">                   this);</a>
<a name="ln1129"> </a>
<a name="ln1130">  MAYBE_FAULT(FLAGS_TEST_fault_crash_after_rb_files_fetched);</a>
<a name="ln1131"> </a>
<a name="ln1132">  // Write out the last files to make the new replica visible and update the</a>
<a name="ln1133">  // TabletDataState in the superblock to TABLET_DATA_READY.</a>
<a name="ln1134">  // Finish() will call EndRemoteSession() and wait for the leader to successfully submit a</a>
<a name="ln1135">  // ChangeConfig request (to change this server's role from PRE_VOTER or PRE_OBSERVER to VOTER or</a>
<a name="ln1136">  // OBSERVER respectively). If the RPC times out, we will ignore the error (since the leader could</a>
<a name="ln1137">  // have successfully submitted the ChangeConfig request and failed to respond in time)</a>
<a name="ln1138">  // and check the committed config until we find that this server's role has changed, or until we</a>
<a name="ln1139">  // time out which will cause us to tombstone the tablet.</a>
<a name="ln1140">  TOMBSTONE_NOT_OK(rb_client-&gt;Finish(),</a>
<a name="ln1141">                   meta,</a>
<a name="ln1142">                   fs_manager_-&gt;uuid(),</a>
<a name="ln1143">                   &quot;Remote bootstrap: Failed calling Finish()&quot;,</a>
<a name="ln1144">                   this);</a>
<a name="ln1145"> </a>
<a name="ln1146">  LOG(INFO) &lt;&lt; kLogPrefix &lt;&lt; &quot;Remote bootstrap: Opening tablet&quot;;</a>
<a name="ln1147"> </a>
<a name="ln1148">  // TODO(hector):  ENG-3173: We need to simulate a failure in OpenTablet during remote bootstrap</a>
<a name="ln1149">  // and verify that this tablet server gets remote bootstrapped again by the leader. We also need</a>
<a name="ln1150">  // to check what happens when this server receives raft consensus requests since at this point,</a>
<a name="ln1151">  // this tablet server could be a voter (if the ChangeRole request in Finish succeeded and its</a>
<a name="ln1152">  // initial role was PRE_VOTER).</a>
<a name="ln1153">  OpenTablet(meta, nullptr);</a>
<a name="ln1154">  // If OpenTablet fails, tablet_peer-&gt;error() will be set.</a>
<a name="ln1155">  RETURN_NOT_OK(ShutdownAndTombstoneTabletPeerNotOk(</a>
<a name="ln1156">      tablet_peer-&gt;error(), tablet_peer, meta, fs_manager_-&gt;uuid(),</a>
<a name="ln1157">      &quot;Remote bootstrap: OpenTablet() failed&quot;, this));</a>
<a name="ln1158"> </a>
<a name="ln1159">  auto status = rb_client-&gt;VerifyChangeRoleSucceeded(tablet_peer-&gt;shared_consensus());</a>
<a name="ln1160">  if (!status.ok()) {</a>
<a name="ln1161">    // If for some reason this tserver wasn't promoted (e.g. from PRE-VOTER to VOTER), the leader</a>
<a name="ln1162">    // will find out and do the CHANGE_CONFIG.</a>
<a name="ln1163">    LOG(WARNING) &lt;&lt; kLogPrefix &lt;&lt; &quot;Remote bootstrap finished. &quot;</a>
<a name="ln1164">                               &lt;&lt; &quot;Failure calling VerifyChangeRoleSucceeded: &quot;</a>
<a name="ln1165">                               &lt;&lt; status.ToString();</a>
<a name="ln1166">  } else {</a>
<a name="ln1167">    LOG(INFO) &lt;&lt; kLogPrefix &lt;&lt; &quot;Remote bootstrap for tablet ended successfully&quot;;</a>
<a name="ln1168">  }</a>
<a name="ln1169"> </a>
<a name="ln1170">  WARN_NOT_OK(rb_client-&gt;Remove(), &quot;Remove remote bootstrap sessions failed&quot;);</a>
<a name="ln1171"> </a>
<a name="ln1172">  return Status::OK();</a>
<a name="ln1173">}</a>
<a name="ln1174"> </a>
<a name="ln1175">// Create and register a new TabletPeer, given tablet metadata.</a>
<a name="ln1176">Result&lt;TabletPeerPtr&gt; TSTabletManager::CreateAndRegisterTabletPeer(</a>
<a name="ln1177">    const RaftGroupMetadataPtr&amp; meta, RegisterTabletPeerMode mode) {</a>
<a name="ln1178">  TabletPeerPtr tablet_peer(new tablet::TabletPeer(</a>
<a name="ln1179">      meta,</a>
<a name="ln1180">      local_peer_pb_,</a>
<a name="ln1181">      scoped_refptr&lt;server::Clock&gt;(server_-&gt;clock()),</a>
<a name="ln1182">      fs_manager_-&gt;uuid(),</a>
<a name="ln1183">      Bind(&amp;TSTabletManager::ApplyChange, Unretained(this), meta-&gt;raft_group_id()),</a>
<a name="ln1184">      metric_registry_,</a>
<a name="ln1185">      this,</a>
<a name="ln1186">      async_client_init_-&gt;get_client_future()));</a>
<a name="ln1187">  RETURN_NOT_OK(RegisterTablet(meta-&gt;raft_group_id(), tablet_peer, mode));</a>
<a name="ln1188">  return tablet_peer;</a>
<a name="ln1189">}</a>
<a name="ln1190"> </a>
<a name="ln1191">Status TSTabletManager::DeleteTablet(</a>
<a name="ln1192">    const string&amp; tablet_id,</a>
<a name="ln1193">    TabletDataState delete_type,</a>
<a name="ln1194">    const boost::optional&lt;int64_t&gt;&amp; cas_config_opid_index_less_or_equal,</a>
<a name="ln1195">    boost::optional&lt;TabletServerErrorPB::Code&gt;* error_code) {</a>
<a name="ln1196"> </a>
<a name="ln1197">  if (delete_type != TABLET_DATA_DELETED &amp;&amp; delete_type != TABLET_DATA_TOMBSTONED) {</a>
<a name="ln1198">    return STATUS(InvalidArgument, &quot;DeleteTablet() requires an argument that is one of &quot;</a>
<a name="ln1199">                                   &quot;TABLET_DATA_DELETED or TABLET_DATA_TOMBSTONED&quot;,</a>
<a name="ln1200">                                   Substitute(&quot;Given: $0 ($1)&quot;,</a>
<a name="ln1201">                                              TabletDataState_Name(delete_type), delete_type));</a>
<a name="ln1202">  }</a>
<a name="ln1203"> </a>
<a name="ln1204">  TRACE(&quot;Deleting tablet $0&quot;, tablet_id);</a>
<a name="ln1205"> </a>
<a name="ln1206">  TabletPeerPtr tablet_peer;</a>
<a name="ln1207">  scoped_refptr&lt;TransitionInProgressDeleter&gt; deleter;</a>
<a name="ln1208">  {</a>
<a name="ln1209">    // Acquire the lock in exclusive mode as we'll add a entry to the</a>
<a name="ln1210">    // transition_in_progress_ map.</a>
<a name="ln1211">    std::lock_guard&lt;RWMutex&gt; lock(mutex_);</a>
<a name="ln1212">    TRACE(&quot;Acquired tablet manager lock&quot;);</a>
<a name="ln1213">    RETURN_NOT_OK(CheckRunningUnlocked(error_code));</a>
<a name="ln1214"> </a>
<a name="ln1215">    if (!LookupTabletUnlocked(tablet_id, &amp;tablet_peer)) {</a>
<a name="ln1216">      *error_code = TabletServerErrorPB::TABLET_NOT_FOUND;</a>
<a name="ln1217">      return STATUS(NotFound, &quot;Tablet not found&quot;, tablet_id);</a>
<a name="ln1218">    }</a>
<a name="ln1219">    // Sanity check that the tablet's deletion isn't already in progress</a>
<a name="ln1220">    Status s = StartTabletStateTransition(tablet_id, &quot;deleting tablet&quot;, &amp;deleter);</a>
<a name="ln1221">    if (PREDICT_FALSE(!s.ok())) {</a>
<a name="ln1222">      *error_code = TabletServerErrorPB::TABLET_NOT_RUNNING;</a>
<a name="ln1223">      return s;</a>
<a name="ln1224">    }</a>
<a name="ln1225">  }</a>
<a name="ln1226"> </a>
<a name="ln1227">  // If the tablet is already deleted, the CAS check isn't possible because</a>
<a name="ln1228">  // consensus and therefore the log is not available.</a>
<a name="ln1229">  TabletDataState data_state = tablet_peer-&gt;tablet_metadata()-&gt;tablet_data_state();</a>
<a name="ln1230">  bool tablet_deleted = (data_state == TABLET_DATA_DELETED || data_state == TABLET_DATA_TOMBSTONED);</a>
<a name="ln1231"> </a>
<a name="ln1232">  // If a tablet peer is in the FAILED state, then we need to be able to tombstone or delete this</a>
<a name="ln1233">  // tablet. If the tablet is tombstoned, then this TS can be remote bootstrapped with the same</a>
<a name="ln1234">  // tablet.</a>
<a name="ln1235">  bool tablet_failed = tablet_peer-&gt;state() == RaftGroupStatePB::FAILED;</a>
<a name="ln1236"> </a>
<a name="ln1237">  // They specified an &quot;atomic&quot; delete. Check the committed config's opid_index.</a>
<a name="ln1238">  // TODO: There's actually a race here between the check and shutdown, but</a>
<a name="ln1239">  // it's tricky to fix. We could try checking again after the shutdown and</a>
<a name="ln1240">  // restarting the tablet if the local replica committed a higher config</a>
<a name="ln1241">  // change op during that time, or potentially something else more invasive.</a>
<a name="ln1242">  if (cas_config_opid_index_less_or_equal &amp;&amp; !tablet_deleted &amp;&amp; !tablet_failed) {</a>
<a name="ln1243">    shared_ptr&lt;consensus::Consensus&gt; consensus = tablet_peer-&gt;shared_consensus();</a>
<a name="ln1244">    if (!consensus) {</a>
<a name="ln1245">      *error_code = TabletServerErrorPB::TABLET_NOT_RUNNING;</a>
<a name="ln1246">      return STATUS(IllegalState, &quot;Consensus not available. Tablet shutting down&quot;);</a>
<a name="ln1247">    }</a>
<a name="ln1248">    RaftConfigPB committed_config = consensus-&gt;CommittedConfig();</a>
<a name="ln1249">    if (committed_config.opid_index() &gt; *cas_config_opid_index_less_or_equal) {</a>
<a name="ln1250">      *error_code = TabletServerErrorPB::CAS_FAILED;</a>
<a name="ln1251">      return STATUS(IllegalState, Substitute(&quot;Request specified cas_config_opid_index_less_or_equal&quot;</a>
<a name="ln1252">                                             &quot; of $0 but the committed config has opid_index of $1&quot;,</a>
<a name="ln1253">                                             *cas_config_opid_index_less_or_equal,</a>
<a name="ln1254">                                             committed_config.opid_index()));</a>
<a name="ln1255">    }</a>
<a name="ln1256">  }</a>
<a name="ln1257"> </a>
<a name="ln1258">  RaftGroupMetadataPtr meta = tablet_peer-&gt;tablet_metadata();</a>
<a name="ln1259">  // TODO(raju): should tablet being tombstoned not avoid flushing memtable as well ?</a>
<a name="ln1260">  tablet_peer-&gt;Shutdown((delete_type == TABLET_DATA_DELETED) ?</a>
<a name="ln1261">      tablet::IsDropTable::kTrue : tablet::IsDropTable::kFalse);</a>
<a name="ln1262"> </a>
<a name="ln1263">  yb::OpId last_logged_opid = tablet_peer-&gt;GetLatestLogEntryOpId();</a>
<a name="ln1264"> </a>
<a name="ln1265">  Status s = DeleteTabletData(meta,</a>
<a name="ln1266">                              delete_type,</a>
<a name="ln1267">                              fs_manager_-&gt;uuid(),</a>
<a name="ln1268">                              last_logged_opid,</a>
<a name="ln1269">                              this);</a>
<a name="ln1270">  if (PREDICT_FALSE(!s.ok())) {</a>
<a name="ln1271">    s = s.CloneAndPrepend(Substitute(&quot;Unable to delete on-disk data from tablet $0&quot;,</a>
<a name="ln1272">                                     tablet_id));</a>
<a name="ln1273">    LOG(WARNING) &lt;&lt; s.ToString();</a>
<a name="ln1274">    tablet_peer-&gt;SetFailed(s);</a>
<a name="ln1275">    return s;</a>
<a name="ln1276">  }</a>
<a name="ln1277"> </a>
<a name="ln1278">  tablet_peer-&gt;status_listener()-&gt;StatusMessage(&quot;Deleted tablet blocks from disk&quot;);</a>
<a name="ln1279"> </a>
<a name="ln1280">  // We only remove DELETED tablets from the tablet map.</a>
<a name="ln1281">  if (delete_type == TABLET_DATA_DELETED) {</a>
<a name="ln1282">    std::lock_guard&lt;RWMutex&gt; lock(mutex_);</a>
<a name="ln1283">    RETURN_NOT_OK(CheckRunningUnlocked(error_code));</a>
<a name="ln1284">    CHECK_EQ(1, tablet_map_.erase(tablet_id)) &lt;&lt; tablet_id;</a>
<a name="ln1285">  }</a>
<a name="ln1286"> </a>
<a name="ln1287">  // We unregister TOMBSTONED tablets in addition to DELETED tablets because they do not have</a>
<a name="ln1288">  // any more data on disk, so we shouldn't count these tablets when load balancing the disks.</a>
<a name="ln1289">  UnregisterDataWalDir(meta-&gt;table_id(),</a>
<a name="ln1290">                       tablet_id,</a>
<a name="ln1291">                       meta-&gt;data_root_dir(),</a>
<a name="ln1292">                       meta-&gt;wal_root_dir());</a>
<a name="ln1293"> </a>
<a name="ln1294">  return Status::OK();</a>
<a name="ln1295">}</a>
<a name="ln1296"> </a>
<a name="ln1297">Status TSTabletManager::CheckRunningUnlocked(</a>
<a name="ln1298">    boost::optional&lt;TabletServerErrorPB::Code&gt;* error_code) const {</a>
<a name="ln1299">  if (state_ == MANAGER_RUNNING) {</a>
<a name="ln1300">    return Status::OK();</a>
<a name="ln1301">  }</a>
<a name="ln1302">  *error_code = TabletServerErrorPB::TABLET_NOT_RUNNING;</a>
<a name="ln1303">  return STATUS(ServiceUnavailable, Substitute(&quot;Tablet Manager is not running: $0&quot;,</a>
<a name="ln1304">                                               TSTabletManagerStatePB_Name(state_)));</a>
<a name="ln1305">}</a>
<a name="ln1306"> </a>
<a name="ln1307">// NO_THREAD_SAFETY_ANALYSIS because this analysis does not work with unique_lock.</a>
<a name="ln1308">Status TSTabletManager::StartTabletStateTransition(</a>
<a name="ln1309">    const string&amp; tablet_id,</a>
<a name="ln1310">    const string&amp; reason,</a>
<a name="ln1311">    scoped_refptr&lt;TransitionInProgressDeleter&gt;* deleter) NO_THREAD_SAFETY_ANALYSIS {</a>
<a name="ln1312">  std::unique_lock&lt;std::mutex&gt; lock(transition_in_progress_mutex_);</a>
<a name="ln1313">  const auto emplace_result = transition_in_progress_.emplace(tablet_id, reason);</a>
<a name="ln1314">  if (!emplace_result.second) {</a>
<a name="ln1315">    return STATUS_FORMAT(</a>
<a name="ln1316">        AlreadyPresent, &quot;State transition of tablet $0 already in progress: $1&quot;, tablet_id,</a>
<a name="ln1317">        *emplace_result.first);</a>
<a name="ln1318">  }</a>
<a name="ln1319">  deleter-&gt;reset(new TransitionInProgressDeleter(</a>
<a name="ln1320">      &amp;transition_in_progress_, &amp;transition_in_progress_mutex_, tablet_id));</a>
<a name="ln1321">  return Status::OK();</a>
<a name="ln1322">}</a>
<a name="ln1323"> </a>
<a name="ln1324">bool TSTabletManager::IsTabletInTransition(const TabletId&amp; tablet_id) const {</a>
<a name="ln1325">  std::unique_lock&lt;std::mutex&gt; lock(transition_in_progress_mutex_);</a>
<a name="ln1326">  return ContainsKey(transition_in_progress_, tablet_id);</a>
<a name="ln1327">}</a>
<a name="ln1328"> </a>
<a name="ln1329">Status TSTabletManager::OpenTabletMeta(const string&amp; tablet_id,</a>
<a name="ln1330">                                       RaftGroupMetadataPtr* metadata) {</a>
<a name="ln1331">  LOG(INFO) &lt;&lt; &quot;Loading metadata for tablet &quot; &lt;&lt; tablet_id;</a>
<a name="ln1332">  TRACE(&quot;Loading metadata...&quot;);</a>
<a name="ln1333">  RaftGroupMetadataPtr meta;</a>
<a name="ln1334">  RETURN_NOT_OK_PREPEND(RaftGroupMetadata::Load(fs_manager_, tablet_id, &amp;meta),</a>
<a name="ln1335">                        strings::Substitute(&quot;Failed to load tablet metadata for tablet id $0&quot;,</a>
<a name="ln1336">                                            tablet_id));</a>
<a name="ln1337">  TRACE(&quot;Metadata loaded&quot;);</a>
<a name="ln1338">  metadata-&gt;swap(meta);</a>
<a name="ln1339">  return Status::OK();</a>
<a name="ln1340">}</a>
<a name="ln1341"> </a>
<a name="ln1342">void TSTabletManager::OpenTablet(const RaftGroupMetadataPtr&amp; meta,</a>
<a name="ln1343">                                 const scoped_refptr&lt;TransitionInProgressDeleter&gt;&amp; deleter) {</a>
<a name="ln1344">  string tablet_id = meta-&gt;raft_group_id();</a>
<a name="ln1345">  TRACE_EVENT1(&quot;tserver&quot;, &quot;TSTabletManager::OpenTablet&quot;,</a>
<a name="ln1346">               &quot;tablet_id&quot;, tablet_id);</a>
<a name="ln1347"> </a>
<a name="ln1348">  TabletPeerPtr tablet_peer;</a>
<a name="ln1349">  CHECK(LookupTablet(tablet_id, &amp;tablet_peer))</a>
<a name="ln1350">      &lt;&lt; &quot;Tablet not registered prior to OpenTabletAsync call: &quot; &lt;&lt; tablet_id;</a>
<a name="ln1351"> </a>
<a name="ln1352">  tablet::TabletPtr tablet;</a>
<a name="ln1353">  scoped_refptr&lt;Log&gt; log;</a>
<a name="ln1354">  const string kLogPrefix = TabletLogPrefix(tablet_id);</a>
<a name="ln1355"> </a>
<a name="ln1356">  LOG(INFO) &lt;&lt; kLogPrefix &lt;&lt; &quot;Bootstrapping tablet&quot;;</a>
<a name="ln1357">  TRACE(&quot;Bootstrapping tablet&quot;);</a>
<a name="ln1358"> </a>
<a name="ln1359">  consensus::ConsensusBootstrapInfo bootstrap_info;</a>
<a name="ln1360">  consensus::RetryableRequests retryable_requests(kLogPrefix);</a>
<a name="ln1361">  yb::OpId split_op_id;</a>
<a name="ln1362"> </a>
<a name="ln1363">  LOG_TIMING_PREFIX(INFO, kLogPrefix, &quot;bootstrapping tablet&quot;) {</a>
<a name="ln1364">    if (CompareAndSetFlag(&amp;FLAGS_TEST_force_single_tablet_failure,</a>
<a name="ln1365">                          true /* expected */, false /* val */)) {</a>
<a name="ln1366">      LOG(ERROR) &lt;&lt; &quot;Setting the state of a tablet to FAILED&quot;;</a>
<a name="ln1367">      tablet_peer-&gt;SetFailed(STATUS(InternalError, &quot;Setting tablet to failed state for test&quot;,</a>
<a name="ln1368">                                    tablet_id));</a>
<a name="ln1369">      return;</a>
<a name="ln1370">    }</a>
<a name="ln1371"> </a>
<a name="ln1372">    // TODO: handle crash mid-creation of tablet? do we ever end up with a</a>
<a name="ln1373">    // partially created tablet here?</a>
<a name="ln1374">    auto s = tablet_peer-&gt;SetBootstrapping();</a>
<a name="ln1375">    if (!s.ok()) {</a>
<a name="ln1376">      LOG(ERROR) &lt;&lt; kLogPrefix &lt;&lt; &quot;Tablet failed to set bootstrapping: &quot; &lt;&lt; s;</a>
<a name="ln1377">      tablet_peer-&gt;SetFailed(s);</a>
<a name="ln1378">      return;</a>
<a name="ln1379">    }</a>
<a name="ln1380"> </a>
<a name="ln1381">    tablet::TabletInitData tablet_init_data = {</a>
<a name="ln1382">      .metadata = meta,</a>
<a name="ln1383">      .client_future = async_client_init_-&gt;get_client_future(),</a>
<a name="ln1384">      .clock = scoped_refptr&lt;server::Clock&gt;(server_-&gt;clock()),</a>
<a name="ln1385">      .parent_mem_tracker = MemTracker::FindOrCreateTracker(&quot;Tablets&quot;, server_-&gt;mem_tracker()),</a>
<a name="ln1386">      .block_based_table_mem_tracker = block_based_table_mem_tracker_,</a>
<a name="ln1387">      .metric_registry = metric_registry_,</a>
<a name="ln1388">      .log_anchor_registry = tablet_peer-&gt;log_anchor_registry(),</a>
<a name="ln1389">      .tablet_options = tablet_options_,</a>
<a name="ln1390">      .log_prefix_suffix = &quot; P &quot; + tablet_peer-&gt;permanent_uuid(),</a>
<a name="ln1391">      .transaction_participant_context = tablet_peer.get(),</a>
<a name="ln1392">      .local_tablet_filter = std::bind(&amp;TSTabletManager::PreserveLocalLeadersOnly, this, _1),</a>
<a name="ln1393">      .transaction_coordinator_context = tablet_peer.get(),</a>
<a name="ln1394">      .txns_enabled = tablet::TransactionsEnabled::kTrue,</a>
<a name="ln1395">      // We are assuming we're never dealing with the system catalog tablet in TSTabletManager.</a>
<a name="ln1396">      .is_sys_catalog = tablet::IsSysCatalogTablet::kFalse,</a>
<a name="ln1397">      .snapshot_coordinator = nullptr,</a>
<a name="ln1398">      .tablet_splitter = this,</a>
<a name="ln1399">    };</a>
<a name="ln1400">    tablet::BootstrapTabletData data = {</a>
<a name="ln1401">      .tablet_init_data = tablet_init_data,</a>
<a name="ln1402">      .listener = tablet_peer-&gt;status_listener(),</a>
<a name="ln1403">      .append_pool = append_pool(),</a>
<a name="ln1404">      .allocation_pool = allocation_pool_.get(),</a>
<a name="ln1405">      .retryable_requests = &amp;retryable_requests,</a>
<a name="ln1406">    };</a>
<a name="ln1407">    s = BootstrapTablet(data, &amp;tablet, &amp;log, &amp;bootstrap_info);</a>
<a name="ln1408">    if (!s.ok()) {</a>
<a name="ln1409">      LOG(ERROR) &lt;&lt; kLogPrefix &lt;&lt; &quot;Tablet failed to bootstrap: &quot; &lt;&lt; s;</a>
<a name="ln1410">      tablet_peer-&gt;SetFailed(s);</a>
<a name="ln1411">      return;</a>
<a name="ln1412">    }</a>
<a name="ln1413">  }</a>
<a name="ln1414"> </a>
<a name="ln1415">  MonoTime start(MonoTime::Now());</a>
<a name="ln1416">  LOG_TIMING_PREFIX(INFO, kLogPrefix, &quot;starting tablet&quot;) {</a>
<a name="ln1417">    TRACE(&quot;Initializing tablet peer&quot;);</a>
<a name="ln1418">    auto s = tablet_peer-&gt;InitTabletPeer(</a>
<a name="ln1419">        tablet,</a>
<a name="ln1420">        server_-&gt;mem_tracker(),</a>
<a name="ln1421">        server_-&gt;messenger(),</a>
<a name="ln1422">        &amp;server_-&gt;proxy_cache(),</a>
<a name="ln1423">        log,</a>
<a name="ln1424">        tablet-&gt;GetMetricEntity(),</a>
<a name="ln1425">        raft_pool(),</a>
<a name="ln1426">        tablet_prepare_pool(),</a>
<a name="ln1427">        &amp;retryable_requests,</a>
<a name="ln1428">        yb::OpId::FromPB(bootstrap_info.split_op_id));</a>
<a name="ln1429"> </a>
<a name="ln1430">    if (!s.ok()) {</a>
<a name="ln1431">      LOG(ERROR) &lt;&lt; kLogPrefix &lt;&lt; &quot;Tablet failed to init: &quot;</a>
<a name="ln1432">                 &lt;&lt; s.ToString();</a>
<a name="ln1433">      tablet_peer-&gt;SetFailed(s);</a>
<a name="ln1434">      return;</a>
<a name="ln1435">    }</a>
<a name="ln1436"> </a>
<a name="ln1437">    TRACE(&quot;Starting tablet peer&quot;);</a>
<a name="ln1438">    s = tablet_peer-&gt;Start(bootstrap_info);</a>
<a name="ln1439">    if (!s.ok()) {</a>
<a name="ln1440">      LOG(ERROR) &lt;&lt; kLogPrefix &lt;&lt; &quot;Tablet failed to start: &quot;</a>
<a name="ln1441">                 &lt;&lt; s.ToString();</a>
<a name="ln1442">      tablet_peer-&gt;SetFailed(s);</a>
<a name="ln1443">      return;</a>
<a name="ln1444">    }</a>
<a name="ln1445"> </a>
<a name="ln1446">    tablet_peer-&gt;RegisterMaintenanceOps(server_-&gt;maintenance_manager());</a>
<a name="ln1447">  }</a>
<a name="ln1448"> </a>
<a name="ln1449">  int elapsed_ms = MonoTime::Now().GetDeltaSince(start).ToMilliseconds();</a>
<a name="ln1450">  if (elapsed_ms &gt; FLAGS_tablet_start_warn_threshold_ms) {</a>
<a name="ln1451">    LOG(WARNING) &lt;&lt; kLogPrefix &lt;&lt; &quot;Tablet startup took &quot; &lt;&lt; elapsed_ms &lt;&lt; &quot;ms&quot;;</a>
<a name="ln1452">    if (Trace::CurrentTrace()) {</a>
<a name="ln1453">      LOG(WARNING) &lt;&lt; kLogPrefix &lt;&lt; &quot;Trace:&quot; &lt;&lt; std::endl</a>
<a name="ln1454">                   &lt;&lt; Trace::CurrentTrace()-&gt;DumpToString(true);</a>
<a name="ln1455">    }</a>
<a name="ln1456">  }</a>
<a name="ln1457">}</a>
<a name="ln1458"> </a>
<a name="ln1459">void TSTabletManager::StartShutdown() {</a>
<a name="ln1460">  async_client_init_-&gt;Shutdown();</a>
<a name="ln1461"> </a>
<a name="ln1462">  if (background_task_) {</a>
<a name="ln1463">    background_task_-&gt;Shutdown();</a>
<a name="ln1464">  }</a>
<a name="ln1465"> </a>
<a name="ln1466">  {</a>
<a name="ln1467">    std::lock_guard&lt;RWMutex&gt; lock(mutex_);</a>
<a name="ln1468">    switch (state_) {</a>
<a name="ln1469">      case MANAGER_QUIESCING: {</a>
<a name="ln1470">        VLOG(1) &lt;&lt; &quot;Tablet manager shut down already in progress..&quot;;</a>
<a name="ln1471">        return;</a>
<a name="ln1472">      }</a>
<a name="ln1473">      case MANAGER_SHUTDOWN: {</a>
<a name="ln1474">        VLOG(1) &lt;&lt; &quot;Tablet manager has already been shut down.&quot;;</a>
<a name="ln1475">        return;</a>
<a name="ln1476">      }</a>
<a name="ln1477">      case MANAGER_INITIALIZING:</a>
<a name="ln1478">      case MANAGER_RUNNING: {</a>
<a name="ln1479">        LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Shutting down tablet manager...&quot;;</a>
<a name="ln1480">        state_ = MANAGER_QUIESCING;</a>
<a name="ln1481">        break;</a>
<a name="ln1482">      }</a>
<a name="ln1483">      default: {</a>
<a name="ln1484">        LOG(FATAL) &lt;&lt; &quot;Invalid state: &quot; &lt;&lt; TSTabletManagerStatePB_Name(state_);</a>
<a name="ln1485">      }</a>
<a name="ln1486">    }</a>
<a name="ln1487">  }</a>
<a name="ln1488"> </a>
<a name="ln1489">  // Wait for all RBS operations to finish.</a>
<a name="ln1490">  const MonoDelta kSingleWait = 10ms;</a>
<a name="ln1491">  const MonoDelta kReportInterval = 5s;</a>
<a name="ln1492">  const MonoDelta kMaxWait = 30s;</a>
<a name="ln1493">  MonoDelta waited = MonoDelta::kZero;</a>
<a name="ln1494">  MonoDelta next_report_time = kReportInterval;</a>
<a name="ln1495">  while (int remaining_rbs = num_tablets_being_remote_bootstrapped_ &gt; 0) {</a>
<a name="ln1496">    if (waited &gt;= next_report_time) {</a>
<a name="ln1497">      if (waited &gt;= kMaxWait) {</a>
<a name="ln1498">        LOG_WITH_PREFIX(DFATAL)</a>
<a name="ln1499">            &lt;&lt; &quot;Waited for &quot; &lt;&lt; waited &lt;&lt; &quot;ms. Still had &quot;</a>
<a name="ln1500">            &lt;&lt; remaining_rbs &lt;&lt; &quot; pending remote bootstraps&quot;;</a>
<a name="ln1501">      } else {</a>
<a name="ln1502">        LOG_WITH_PREFIX(WARNING)</a>
<a name="ln1503">            &lt;&lt; &quot;Still waiting for &quot; &lt;&lt; remaining_rbs</a>
<a name="ln1504">            &lt;&lt; &quot; ongoing RemoteBootstraps to finish after &quot; &lt;&lt; waited;</a>
<a name="ln1505">      }</a>
<a name="ln1506">      next_report_time = std::min(kMaxWait, waited + kReportInterval);</a>
<a name="ln1507">    }</a>
<a name="ln1508">    SleepFor(kSingleWait);</a>
<a name="ln1509">    waited += kSingleWait;</a>
<a name="ln1510">  }</a>
<a name="ln1511"> </a>
<a name="ln1512">  // Shut down the bootstrap pool, so new tablets are registered after this point.</a>
<a name="ln1513">  open_tablet_pool_-&gt;Shutdown();</a>
<a name="ln1514"> </a>
<a name="ln1515">  // Take a snapshot of the peers list -- that way we don't have to hold</a>
<a name="ln1516">  // on to the lock while shutting them down, which might cause a lock</a>
<a name="ln1517">  // inversion. (see KUDU-308 for example).</a>
<a name="ln1518">  for (const TabletPeerPtr&amp; peer : GetTabletPeers()) {</a>
<a name="ln1519">    if (peer-&gt;StartShutdown()) {</a>
<a name="ln1520">      shutting_down_peers_.push_back(peer);</a>
<a name="ln1521">    }</a>
<a name="ln1522">  }</a>
<a name="ln1523">}</a>
<a name="ln1524"> </a>
<a name="ln1525">void TSTabletManager::CompleteShutdown() {</a>
<a name="ln1526">  for (const TabletPeerPtr&amp; peer : shutting_down_peers_) {</a>
<a name="ln1527">    peer-&gt;CompleteShutdown();</a>
<a name="ln1528">  }</a>
<a name="ln1529"> </a>
<a name="ln1530">  // Shut down the apply pool.</a>
<a name="ln1531">  apply_pool_-&gt;Shutdown();</a>
<a name="ln1532"> </a>
<a name="ln1533">  if (raft_pool_) {</a>
<a name="ln1534">    raft_pool_-&gt;Shutdown();</a>
<a name="ln1535">  }</a>
<a name="ln1536">  if (tablet_prepare_pool_) {</a>
<a name="ln1537">    tablet_prepare_pool_-&gt;Shutdown();</a>
<a name="ln1538">  }</a>
<a name="ln1539">  if (append_pool_) {</a>
<a name="ln1540">    append_pool_-&gt;Shutdown();</a>
<a name="ln1541">  }</a>
<a name="ln1542"> </a>
<a name="ln1543">  {</a>
<a name="ln1544">    std::lock_guard&lt;RWMutex&gt; l(mutex_);</a>
<a name="ln1545">    tablet_map_.clear();</a>
<a name="ln1546"> </a>
<a name="ln1547">    std::lock_guard&lt;std::mutex&gt; dir_assignment_lock(dir_assignment_mutex_);</a>
<a name="ln1548">    table_data_assignment_map_.clear();</a>
<a name="ln1549">    table_wal_assignment_map_.clear();</a>
<a name="ln1550"> </a>
<a name="ln1551">    state_ = MANAGER_SHUTDOWN;</a>
<a name="ln1552">  }</a>
<a name="ln1553">}</a>
<a name="ln1554"> </a>
<a name="ln1555">std::string TSTabletManager::LogPrefix() const {</a>
<a name="ln1556">  return &quot;P &quot; + fs_manager_-&gt;uuid() + &quot;: &quot;;</a>
<a name="ln1557">}</a>
<a name="ln1558"> </a>
<a name="ln1559">std::string TSTabletManager::TabletLogPrefix(const TabletId&amp; tablet_id) const {</a>
<a name="ln1560">  return tserver::LogPrefix(tablet_id, fs_manager_-&gt;uuid());</a>
<a name="ln1561">}</a>
<a name="ln1562"> </a>
<a name="ln1563">bool TSTabletManager::ClosingUnlocked() const {</a>
<a name="ln1564">  return state_ == MANAGER_QUIESCING || state_ == MANAGER_SHUTDOWN;</a>
<a name="ln1565">}</a>
<a name="ln1566"> </a>
<a name="ln1567">Status TSTabletManager::RegisterTablet(const TabletId&amp; tablet_id,</a>
<a name="ln1568">                                       const TabletPeerPtr&amp; tablet_peer,</a>
<a name="ln1569">                                       RegisterTabletPeerMode mode) {</a>
<a name="ln1570">  std::lock_guard&lt;RWMutex&gt; lock(mutex_);</a>
<a name="ln1571">  if (ClosingUnlocked()) {</a>
<a name="ln1572">    auto result = STATUS_FORMAT(</a>
<a name="ln1573">        IllegalState, &quot;Unable to register tablet peer: $0: closing&quot;, tablet_id);</a>
<a name="ln1574">    LOG(WARNING) &lt;&lt; result;</a>
<a name="ln1575">    return result;</a>
<a name="ln1576">  }</a>
<a name="ln1577"> </a>
<a name="ln1578">  // If we are replacing a tablet peer, we delete the existing one first.</a>
<a name="ln1579">  if (mode == REPLACEMENT_PEER &amp;&amp; tablet_map_.erase(tablet_id) != 1) {</a>
<a name="ln1580">    auto result = STATUS_FORMAT(</a>
<a name="ln1581">        NotFound, &quot;Unable to remove previous tablet peer $0: not registered&quot;, tablet_id);</a>
<a name="ln1582">    LOG(WARNING) &lt;&lt; result;</a>
<a name="ln1583">    return result;</a>
<a name="ln1584">  }</a>
<a name="ln1585">  if (!InsertIfNotPresent(&amp;tablet_map_, tablet_id, tablet_peer)) {</a>
<a name="ln1586">    auto result = STATUS_FORMAT(</a>
<a name="ln1587">        AlreadyPresent, &quot;Unable to register tablet peer $0: already registered&quot;, tablet_id);</a>
<a name="ln1588">    LOG(WARNING) &lt;&lt; result;</a>
<a name="ln1589">    return result;</a>
<a name="ln1590">  }</a>
<a name="ln1591"> </a>
<a name="ln1592">  LOG_WITH_PREFIX(INFO) &lt;&lt; &quot;Registered tablet &quot; &lt;&lt; tablet_id;</a>
<a name="ln1593"> </a>
<a name="ln1594">  return Status::OK();</a>
<a name="ln1595">}</a>
<a name="ln1596"> </a>
<a name="ln1597">bool TSTabletManager::LookupTablet(const string&amp; tablet_id,</a>
<a name="ln1598">                                   TabletPeerPtr* tablet_peer) const {</a>
<a name="ln1599">  SharedLock&lt;RWMutex&gt; shared_lock(mutex_);</a>
<a name="ln1600">  return LookupTabletUnlocked(tablet_id, tablet_peer);</a>
<a name="ln1601">}</a>
<a name="ln1602"> </a>
<a name="ln1603">Result&lt;std::shared_ptr&lt;tablet::TabletPeer&gt;&gt; TSTabletManager::LookupTablet(</a>
<a name="ln1604">    const TabletId&amp; tablet_id) const {</a>
<a name="ln1605">  TabletPeerPtr tablet_peer;</a>
<a name="ln1606">  SCHECK(LookupTablet(tablet_id, &amp;tablet_peer), NotFound, Format(&quot;Tablet $0 not found&quot;, tablet_id));</a>
<a name="ln1607">  return tablet_peer;</a>
<a name="ln1608">}</a>
<a name="ln1609"> </a>
<a name="ln1610">bool TSTabletManager::LookupTabletUnlocked(const string&amp; tablet_id,</a>
<a name="ln1611">                                           TabletPeerPtr* tablet_peer) const {</a>
<a name="ln1612">  const TabletPeerPtr* found = FindOrNull(tablet_map_, tablet_id);</a>
<a name="ln1613">  if (!found) {</a>
<a name="ln1614">    return false;</a>
<a name="ln1615">  }</a>
<a name="ln1616">  *tablet_peer = *found;</a>
<a name="ln1617">  return true;</a>
<a name="ln1618">}</a>
<a name="ln1619"> </a>
<a name="ln1620">Status TSTabletManager::GetTabletPeer(const string&amp; tablet_id,</a>
<a name="ln1621">                                      TabletPeerPtr* tablet_peer) const {</a>
<a name="ln1622">  if (!LookupTablet(tablet_id, tablet_peer)) {</a>
<a name="ln1623">    return STATUS(NotFound, &quot;Tablet not found&quot;, tablet_id);</a>
<a name="ln1624">  }</a>
<a name="ln1625">  TabletDataState data_state = (*tablet_peer)-&gt;tablet_metadata()-&gt;tablet_data_state();</a>
<a name="ln1626">  if (!CanServeTabletData(data_state)) {</a>
<a name="ln1627">    return STATUS(</a>
<a name="ln1628">        IllegalState, &quot;Tablet data state not ready: &quot; + TabletDataState_Name(data_state),</a>
<a name="ln1629">        tablet_id);</a>
<a name="ln1630">  }</a>
<a name="ln1631">  return Status::OK();</a>
<a name="ln1632">}</a>
<a name="ln1633"> </a>
<a name="ln1634">const NodeInstancePB&amp; TSTabletManager::NodeInstance() const {</a>
<a name="ln1635">  return server_-&gt;instance_pb();</a>
<a name="ln1636">}</a>
<a name="ln1637"> </a>
<a name="ln1638">Status TSTabletManager::GetRegistration(ServerRegistrationPB* reg) const {</a>
<a name="ln1639">  return server_-&gt;GetRegistration(reg, server::RpcOnly::kTrue);</a>
<a name="ln1640">}</a>
<a name="ln1641"> </a>
<a name="ln1642">void TSTabletManager::GetTabletPeers(TabletPeers* tablet_peers) const {</a>
<a name="ln1643">  SharedLock&lt;RWMutex&gt; shared_lock(mutex_);</a>
<a name="ln1644">  GetTabletPeersUnlocked(tablet_peers);</a>
<a name="ln1645">}</a>
<a name="ln1646"> </a>
<a name="ln1647">void TSTabletManager::GetTabletPeersUnlocked(TabletPeers* tablet_peers) const {</a>
<a name="ln1648">  AppendValuesFromMap(tablet_map_, tablet_peers);</a>
<a name="ln1649">}</a>
<a name="ln1650"> </a>
<a name="ln1651">void TSTabletManager::PreserveLocalLeadersOnly(std::vector&lt;const TabletId*&gt;* tablet_ids) const {</a>
<a name="ln1652">  SharedLock&lt;RWMutex&gt; shared_lock(mutex_);</a>
<a name="ln1653">  auto filter = [this](const TabletId* id) {</a>
<a name="ln1654">    auto it = tablet_map_.find(*id);</a>
<a name="ln1655">    if (it == tablet_map_.end()) {</a>
<a name="ln1656">      return true;</a>
<a name="ln1657">    }</a>
<a name="ln1658">    auto leader_status = it-&gt;second-&gt;LeaderStatus();</a>
<a name="ln1659">    return leader_status != consensus::LeaderStatus::LEADER_AND_READY;</a>
<a name="ln1660">  };</a>
<a name="ln1661">  tablet_ids-&gt;erase(std::remove_if(tablet_ids-&gt;begin(), tablet_ids-&gt;end(), filter),</a>
<a name="ln1662">                    tablet_ids-&gt;end());</a>
<a name="ln1663">}</a>
<a name="ln1664"> </a>
<a name="ln1665">TSTabletManager::TabletPeers TSTabletManager::GetTabletPeers() const {</a>
<a name="ln1666">  TabletPeers peers;</a>
<a name="ln1667">  GetTabletPeers(&amp;peers);</a>
<a name="ln1668">  return peers;</a>
<a name="ln1669">}</a>
<a name="ln1670"> </a>
<a name="ln1671">void TSTabletManager::ApplyChange(const string&amp; tablet_id,</a>
<a name="ln1672">                                  shared_ptr&lt;consensus::StateChangeContext&gt; context) {</a>
<a name="ln1673">  WARN_NOT_OK(</a>
<a name="ln1674">      apply_pool_-&gt;SubmitFunc(</a>
<a name="ln1675">          std::bind(&amp;TSTabletManager::MarkTabletDirty, this, tablet_id, context)),</a>
<a name="ln1676">      &quot;Unable to run MarkDirty callback&quot;)</a>
<a name="ln1677">}</a>
<a name="ln1678"> </a>
<a name="ln1679">void TSTabletManager::MarkTabletDirty(const TabletId&amp; tablet_id,</a>
<a name="ln1680">                                      std::shared_ptr&lt;consensus::StateChangeContext&gt; context) {</a>
<a name="ln1681">  std::lock_guard&lt;RWMutex&gt; lock(mutex_);</a>
<a name="ln1682">  MarkDirtyUnlocked(tablet_id, context);</a>
<a name="ln1683">}</a>
<a name="ln1684"> </a>
<a name="ln1685">void TSTabletManager::MarkTabletBeingRemoteBootstrapped(</a>
<a name="ln1686">    const TabletId&amp; tablet_id, const TableId&amp; table_id) {</a>
<a name="ln1687">  std::lock_guard&lt;RWMutex&gt; lock(mutex_);</a>
<a name="ln1688">  tablets_being_remote_bootstrapped_.insert(tablet_id);</a>
<a name="ln1689">  tablets_being_remote_bootstrapped_per_table_[table_id].insert(tablet_id);</a>
<a name="ln1690">  MaybeDoChecksForTests(table_id);</a>
<a name="ln1691">  LOG(INFO) &lt;&lt; &quot;Concurrent remote bootstrap sessions: &quot;</a>
<a name="ln1692">            &lt;&lt; tablets_being_remote_bootstrapped_.size()</a>
<a name="ln1693">            &lt;&lt; &quot;Concurrent remote bootstrap sessions for table &quot; &lt;&lt; table_id</a>
<a name="ln1694">            &lt;&lt; &quot;: &quot; &lt;&lt; tablets_being_remote_bootstrapped_per_table_[table_id].size();</a>
<a name="ln1695">}</a>
<a name="ln1696"> </a>
<a name="ln1697">void TSTabletManager::UnmarkTabletBeingRemoteBootstrapped(</a>
<a name="ln1698">    const TabletId&amp; tablet_id, const TableId&amp; table_id) {</a>
<a name="ln1699">  std::lock_guard&lt;RWMutex&gt; lock(mutex_);</a>
<a name="ln1700">  tablets_being_remote_bootstrapped_.erase(tablet_id);</a>
<a name="ln1701">  tablets_being_remote_bootstrapped_per_table_[table_id].erase(tablet_id);</a>
<a name="ln1702">}</a>
<a name="ln1703"> </a>
<a name="ln1704">int TSTabletManager::GetNumDirtyTabletsForTests() const {</a>
<a name="ln1705">  SharedLock&lt;RWMutex&gt; lock(mutex_);</a>
<a name="ln1706">  return dirty_tablets_.size();</a>
<a name="ln1707">}</a>
<a name="ln1708"> </a>
<a name="ln1709">Status TSTabletManager::GetNumTabletsPendingBootstrap(</a>
<a name="ln1710">    IsTabletServerReadyResponsePB* resp) const {</a>
<a name="ln1711">  if (state() != MANAGER_RUNNING) {</a>
<a name="ln1712">    resp-&gt;set_num_tablets_not_running(INT_MAX);</a>
<a name="ln1713">    resp-&gt;set_total_tablets(INT_MAX);</a>
<a name="ln1714">    return Status::OK();</a>
<a name="ln1715">  }</a>
<a name="ln1716"> </a>
<a name="ln1717">  SharedLock&lt;RWMutex&gt; shared_lock(mutex_);</a>
<a name="ln1718">  int num_pending = 0;</a>
<a name="ln1719">  int total_tablets = 0;</a>
<a name="ln1720">  for (const auto&amp; entry : tablet_map_) {</a>
<a name="ln1721">    RaftGroupStatePB state = entry.second-&gt;state();</a>
<a name="ln1722">    TabletDataState data_state = entry.second-&gt;data_state();</a>
<a name="ln1723">    // Do not count tablets that will never get to RUNNING state.</a>
<a name="ln1724">    if (!CanServeTabletData(data_state)) {</a>
<a name="ln1725">      continue;</a>
<a name="ln1726">    }</a>
<a name="ln1727">    bool not_started_or_bootstrap = state == NOT_STARTED || state == BOOTSTRAPPING;</a>
<a name="ln1728">    if (not_started_or_bootstrap || state == RUNNING) {</a>
<a name="ln1729">      total_tablets++;</a>
<a name="ln1730">    }</a>
<a name="ln1731">    if (not_started_or_bootstrap) {</a>
<a name="ln1732">      num_pending++;</a>
<a name="ln1733">    }</a>
<a name="ln1734">  }</a>
<a name="ln1735"> </a>
<a name="ln1736">  LOG(INFO) &lt;&lt; num_pending &lt;&lt; &quot; tablets pending bootstrap out of &quot; &lt;&lt; total_tablets;</a>
<a name="ln1737">  resp-&gt;set_num_tablets_not_running(num_pending);</a>
<a name="ln1738">  resp-&gt;set_total_tablets(total_tablets);</a>
<a name="ln1739"> </a>
<a name="ln1740">  return Status::OK();</a>
<a name="ln1741">}</a>
<a name="ln1742"> </a>
<a name="ln1743">int TSTabletManager::GetNumLiveTablets() const {</a>
<a name="ln1744">  int count = 0;</a>
<a name="ln1745">  SharedLock&lt;RWMutex&gt; lock(mutex_);</a>
<a name="ln1746">  for (const auto&amp; entry : tablet_map_) {</a>
<a name="ln1747">    RaftGroupStatePB state = entry.second-&gt;state();</a>
<a name="ln1748">    if (state == BOOTSTRAPPING ||</a>
<a name="ln1749">        state == RUNNING) {</a>
<a name="ln1750">      count++;</a>
<a name="ln1751">    }</a>
<a name="ln1752">  }</a>
<a name="ln1753">  return count;</a>
<a name="ln1754">}</a>
<a name="ln1755"> </a>
<a name="ln1756">int TSTabletManager::GetLeaderCount() const {</a>
<a name="ln1757">  int count = 0;</a>
<a name="ln1758">  SharedLock&lt;RWMutex&gt; lock(mutex_);</a>
<a name="ln1759">  for (const auto&amp; entry : tablet_map_) {</a>
<a name="ln1760">    consensus::LeaderStatus leader_status = entry.second-&gt;LeaderStatus(/* allow_stale =*/ true);</a>
<a name="ln1761">    if (leader_status != consensus::LeaderStatus::NOT_LEADER) {</a>
<a name="ln1762">      count++;</a>
<a name="ln1763">    }</a>
<a name="ln1764">  }</a>
<a name="ln1765">  return count;</a>
<a name="ln1766">}</a>
<a name="ln1767"> </a>
<a name="ln1768">void TSTabletManager::MarkDirtyUnlocked(const TabletId&amp; tablet_id,</a>
<a name="ln1769">                                        std::shared_ptr&lt;consensus::StateChangeContext&gt; context) {</a>
<a name="ln1770">  TabletReportState* state = FindOrNull(dirty_tablets_, tablet_id);</a>
<a name="ln1771">  if (state != nullptr) {</a>
<a name="ln1772">    CHECK_GE(next_report_seq_, state-&gt;change_seq);</a>
<a name="ln1773">    state-&gt;change_seq = next_report_seq_;</a>
<a name="ln1774">  } else {</a>
<a name="ln1775">    TabletReportState state;</a>
<a name="ln1776">    state.change_seq = next_report_seq_;</a>
<a name="ln1777">    InsertOrDie(&amp;dirty_tablets_, tablet_id, state);</a>
<a name="ln1778">  }</a>
<a name="ln1779">  VLOG(2) &lt;&lt; TabletLogPrefix(tablet_id)</a>
<a name="ln1780">          &lt;&lt; &quot;Marking dirty. Reason: &quot; &lt;&lt; context-&gt;ToString()</a>
<a name="ln1781">          &lt;&lt; &quot;. Will report this tablet to the Master in the next heartbeat &quot;</a>
<a name="ln1782">          &lt;&lt; &quot;as part of report #&quot; &lt;&lt; next_report_seq_;</a>
<a name="ln1783">  server_-&gt;heartbeater()-&gt;TriggerASAP();</a>
<a name="ln1784">}</a>
<a name="ln1785"> </a>
<a name="ln1786">void TSTabletManager::InitLocalRaftPeerPB() {</a>
<a name="ln1787">  DCHECK_EQ(state(), MANAGER_INITIALIZING);</a>
<a name="ln1788">  local_peer_pb_.set_permanent_uuid(fs_manager_-&gt;uuid());</a>
<a name="ln1789">  ServerRegistrationPB reg;</a>
<a name="ln1790">  CHECK_OK(server_-&gt;GetRegistration(&amp;reg, server::RpcOnly::kTrue));</a>
<a name="ln1791">  TakeRegistration(&amp;reg, &amp;local_peer_pb_);</a>
<a name="ln1792">}</a>
<a name="ln1793"> </a>
<a name="ln1794">void TSTabletManager::CreateReportedTabletPB(const TabletPeerPtr&amp; tablet_peer,</a>
<a name="ln1795">                                             ReportedTabletPB* reported_tablet) {</a>
<a name="ln1796">  reported_tablet-&gt;set_tablet_id(tablet_peer-&gt;tablet_id());</a>
<a name="ln1797">  reported_tablet-&gt;set_state(tablet_peer-&gt;state());</a>
<a name="ln1798">  reported_tablet-&gt;set_tablet_data_state(tablet_peer-&gt;tablet_metadata()-&gt;tablet_data_state());</a>
<a name="ln1799">  if (tablet_peer-&gt;state() == tablet::FAILED) {</a>
<a name="ln1800">    AppStatusPB* error_status = reported_tablet-&gt;mutable_error();</a>
<a name="ln1801">    StatusToPB(tablet_peer-&gt;error(), error_status);</a>
<a name="ln1802">  }</a>
<a name="ln1803">  reported_tablet-&gt;set_schema_version(tablet_peer-&gt;tablet_metadata()-&gt;schema_version());</a>
<a name="ln1804"> </a>
<a name="ln1805">  // We cannot get consensus state information unless the TabletPeer is running.</a>
<a name="ln1806">  shared_ptr&lt;consensus::Consensus&gt; consensus = tablet_peer-&gt;shared_consensus();</a>
<a name="ln1807">  if (consensus) {</a>
<a name="ln1808">    *reported_tablet-&gt;mutable_committed_consensus_state() =</a>
<a name="ln1809">        consensus-&gt;ConsensusState(consensus::CONSENSUS_CONFIG_COMMITTED);</a>
<a name="ln1810">  }</a>
<a name="ln1811">}</a>
<a name="ln1812"> </a>
<a name="ln1813">void TSTabletManager::GenerateIncrementalTabletReport(TabletReportPB* report) {</a>
<a name="ln1814">  report-&gt;Clear();</a>
<a name="ln1815">  report-&gt;set_is_incremental(true);</a>
<a name="ln1816">  // Creating the tablet report can be slow in the case that it is in the</a>
<a name="ln1817">  // middle of flushing its consensus metadata. We don't want to hold</a>
<a name="ln1818">  // lock_ for too long, even in read mode, since it can cause other readers</a>
<a name="ln1819">  // to block if there is a waiting writer (see KUDU-2193). So, we just make</a>
<a name="ln1820">  // a local copy of the set of replicas.</a>
<a name="ln1821">  vector&lt;std::shared_ptr&lt;TabletPeer&gt;&gt; to_report;</a>
<a name="ln1822">  vector&lt;TabletId&gt; tablet_ids;</a>
<a name="ln1823">  {</a>
<a name="ln1824">    SharedLock&lt;RWMutex&gt; shared_lock(mutex_);</a>
<a name="ln1825">    tablet_ids.reserve(dirty_tablets_.size() + tablets_being_remote_bootstrapped_.size());</a>
<a name="ln1826">    to_report.reserve(dirty_tablets_.size() + tablets_being_remote_bootstrapped_.size());</a>
<a name="ln1827">    report-&gt;set_sequence_number(next_report_seq_++);</a>
<a name="ln1828">    for (const DirtyMap::value_type&amp; dirty_entry : dirty_tablets_) {</a>
<a name="ln1829">      const TabletId&amp; tablet_id = dirty_entry.first;</a>
<a name="ln1830">      tablet_ids.push_back(tablet_id);</a>
<a name="ln1831">    }</a>
<a name="ln1832">    for (auto const&amp; tablet_id : tablets_being_remote_bootstrapped_) {</a>
<a name="ln1833">      VLOG(1) &lt;&lt; &quot;Tablet &quot; &lt;&lt; tablet_id &lt;&lt; &quot; being remote bootstrapped&quot;;</a>
<a name="ln1834">      tablet_ids.push_back(tablet_id);</a>
<a name="ln1835">    }</a>
<a name="ln1836"> </a>
<a name="ln1837">    for (auto const&amp; tablet_id : tablet_ids) {</a>
<a name="ln1838">      TabletPeerPtr* tablet_peer = FindOrNull(tablet_map_, tablet_id);</a>
<a name="ln1839">      if (tablet_peer) {</a>
<a name="ln1840">        // Dirty entry, report on it.</a>
<a name="ln1841">        to_report.push_back(*tablet_peer);</a>
<a name="ln1842">      } else {</a>
<a name="ln1843">        // Removed.</a>
<a name="ln1844">        report-&gt;add_removed_tablet_ids(tablet_id);</a>
<a name="ln1845">      }</a>
<a name="ln1846">    }</a>
<a name="ln1847">  }</a>
<a name="ln1848">  for (const auto&amp; replica : to_report) {</a>
<a name="ln1849">    CreateReportedTabletPB(replica, report-&gt;add_updated_tablets());</a>
<a name="ln1850">  }</a>
<a name="ln1851">}</a>
<a name="ln1852"> </a>
<a name="ln1853">void TSTabletManager::GenerateFullTabletReport(TabletReportPB* report) {</a>
<a name="ln1854">  report-&gt;Clear();</a>
<a name="ln1855">  report-&gt;set_is_incremental(false);</a>
<a name="ln1856">  // Creating the tablet report can be slow in the case that it is in the</a>
<a name="ln1857">  // middle of flushing its consensus metadata. We don't want to hold</a>
<a name="ln1858">  // lock_ for too long, even in read mode, since it can cause other readers</a>
<a name="ln1859">  // to block if there is a waiting writer (see KUDU-2193). So, we just make</a>
<a name="ln1860">  // a local copy of the set of replicas.</a>
<a name="ln1861">  vector&lt;std::shared_ptr&lt;TabletPeer&gt;&gt; to_report;</a>
<a name="ln1862">  {</a>
<a name="ln1863">    SharedLock&lt;RWMutex&gt; shared_lock(mutex_);</a>
<a name="ln1864">    report-&gt;set_sequence_number(next_report_seq_++);</a>
<a name="ln1865">    GetTabletPeersUnlocked(&amp;to_report);</a>
<a name="ln1866">  }</a>
<a name="ln1867">  for (const auto&amp; replica : to_report) {</a>
<a name="ln1868">    CreateReportedTabletPB(replica, report-&gt;add_updated_tablets());</a>
<a name="ln1869">  }</a>
<a name="ln1870"> </a>
<a name="ln1871">  std::lock_guard&lt;RWMutex&gt; l(mutex_);</a>
<a name="ln1872">  dirty_tablets_.clear();</a>
<a name="ln1873">}</a>
<a name="ln1874"> </a>
<a name="ln1875">void TSTabletManager::MarkTabletReportAcknowledged(const TabletReportPB&amp; report) {</a>
<a name="ln1876">  std::lock_guard&lt;RWMutex&gt; l(mutex_);</a>
<a name="ln1877"> </a>
<a name="ln1878">  int32_t acked_seq = report.sequence_number();</a>
<a name="ln1879">  CHECK_LT(acked_seq, next_report_seq_);</a>
<a name="ln1880"> </a>
<a name="ln1881">  // Clear the &quot;dirty&quot; state for any tablets which have not changed since</a>
<a name="ln1882">  // this report.</a>
<a name="ln1883">  auto it = dirty_tablets_.begin();</a>
<a name="ln1884">  while (it != dirty_tablets_.end()) {</a>
<a name="ln1885">    const TabletReportState&amp; state = it-&gt;second;</a>
<a name="ln1886">    if (state.change_seq &lt;= acked_seq) {</a>
<a name="ln1887">      // This entry has not changed since this tablet report, we no longer need</a>
<a name="ln1888">      // to track it as dirty. If it becomes dirty again, it will be re-added</a>
<a name="ln1889">      // with a higher sequence number.</a>
<a name="ln1890">      it = dirty_tablets_.erase(it);</a>
<a name="ln1891">    } else {</a>
<a name="ln1892">      ++it;</a>
<a name="ln1893">    }</a>
<a name="ln1894">  }</a>
<a name="ln1895">}</a>
<a name="ln1896"> </a>
<a name="ln1897">Status TSTabletManager::HandleNonReadyTabletOnStartup(</a>
<a name="ln1898">    const RaftGroupMetadataPtr&amp; meta) {</a>
<a name="ln1899">  const string&amp; tablet_id = meta-&gt;raft_group_id();</a>
<a name="ln1900">  TabletDataState data_state = meta-&gt;tablet_data_state();</a>
<a name="ln1901">  CHECK(data_state == TABLET_DATA_DELETED ||</a>
<a name="ln1902">        data_state == TABLET_DATA_TOMBSTONED ||</a>
<a name="ln1903">        data_state == TABLET_DATA_COPYING)</a>
<a name="ln1904">      &lt;&lt; &quot;Unexpected TabletDataState in tablet &quot; &lt;&lt; tablet_id &lt;&lt; &quot;: &quot;</a>
<a name="ln1905">      &lt;&lt; TabletDataState_Name(data_state) &lt;&lt; &quot; (&quot; &lt;&lt; data_state &lt;&lt; &quot;)&quot;;</a>
<a name="ln1906"> </a>
<a name="ln1907">  if (data_state == TABLET_DATA_COPYING) {</a>
<a name="ln1908">    // We tombstone tablets that failed to remotely bootstrap.</a>
<a name="ln1909">    data_state = TABLET_DATA_TOMBSTONED;</a>
<a name="ln1910">  }</a>
<a name="ln1911"> </a>
<a name="ln1912">  const string kLogPrefix = TabletLogPrefix(tablet_id);</a>
<a name="ln1913"> </a>
<a name="ln1914">  // If the tablet is already fully tombstoned with no remaining data or WAL,</a>
<a name="ln1915">  // then no need to roll anything forward.</a>
<a name="ln1916">  bool skip_deletion = meta-&gt;IsTombstonedWithNoRocksDBData() &amp;&amp;</a>
<a name="ln1917">                       !Log::HasOnDiskData(meta-&gt;fs_manager(), meta-&gt;wal_dir());</a>
<a name="ln1918"> </a>
<a name="ln1919">  LOG_IF(WARNING, !skip_deletion)</a>
<a name="ln1920">      &lt;&lt; kLogPrefix &lt;&lt; &quot;Tablet Manager startup: Rolling forward tablet deletion &quot;</a>
<a name="ln1921">      &lt;&lt; &quot;of type &quot; &lt;&lt; TabletDataState_Name(data_state);</a>
<a name="ln1922"> </a>
<a name="ln1923">  if (!skip_deletion) {</a>
<a name="ln1924">    // Passing no OpId will retain the last_logged_opid that was previously in the metadata.</a>
<a name="ln1925">    RETURN_NOT_OK(DeleteTabletData(meta, data_state, fs_manager_-&gt;uuid(), yb::OpId()));</a>
<a name="ln1926">  }</a>
<a name="ln1927"> </a>
<a name="ln1928">  // We only delete the actual superblock of a TABLET_DATA_DELETED tablet on startup.</a>
<a name="ln1929">  // TODO: Consider doing this after a fixed delay, instead of waiting for a restart.</a>
<a name="ln1930">  // See KUDU-941.</a>
<a name="ln1931">  if (data_state == TABLET_DATA_DELETED) {</a>
<a name="ln1932">    LOG(INFO) &lt;&lt; kLogPrefix &lt;&lt; &quot;Deleting tablet superblock&quot;;</a>
<a name="ln1933">    return meta-&gt;DeleteSuperBlock();</a>
<a name="ln1934">  }</a>
<a name="ln1935"> </a>
<a name="ln1936">  // Register TOMBSTONED tablets so that they get reported to the Master, which</a>
<a name="ln1937">  // allows us to permanently delete replica tombstones when a table gets deleted.</a>
<a name="ln1938">  if (data_state == TABLET_DATA_TOMBSTONED) {</a>
<a name="ln1939">    RETURN_NOT_OK(CreateAndRegisterTabletPeer(meta, NEW_PEER));</a>
<a name="ln1940">  }</a>
<a name="ln1941"> </a>
<a name="ln1942">  return Status::OK();</a>
<a name="ln1943">}</a>
<a name="ln1944"> </a>
<a name="ln1945">void TSTabletManager::GetAndRegisterDataAndWalDir(FsManager* fs_manager,</a>
<a name="ln1946">                                                  const string&amp; table_id,</a>
<a name="ln1947">                                                  const string&amp; tablet_id,</a>
<a name="ln1948">                                                  string* data_root_dir,</a>
<a name="ln1949">                                                  string* wal_root_dir) {</a>
<a name="ln1950">  // Skip sys catalog table and kudu table from modifying the map.</a>
<a name="ln1951">  if (table_id == master::kSysCatalogTableId) {</a>
<a name="ln1952">    return;</a>
<a name="ln1953">  }</a>
<a name="ln1954">  LOG(INFO) &lt;&lt; &quot;Get and update data/wal directory assignment map for table: &quot; \</a>
<a name="ln1955">            &lt;&lt; table_id &lt;&lt; &quot; and tablet &quot; &lt;&lt; tablet_id;</a>
<a name="ln1956">  std::lock_guard&lt;std::mutex&gt; dir_assignment_lock(dir_assignment_mutex_);</a>
<a name="ln1957">  // Initialize the map if the directory mapping does not exist.</a>
<a name="ln1958">  auto data_root_dirs = fs_manager-&gt;GetDataRootDirs();</a>
<a name="ln1959">  CHECK(!data_root_dirs.empty()) &lt;&lt; &quot;No data root directories found&quot;;</a>
<a name="ln1960">  auto table_data_assignment_iter = table_data_assignment_map_.find(table_id);</a>
<a name="ln1961">  if (table_data_assignment_iter == table_data_assignment_map_.end()) {</a>
<a name="ln1962">    for (string data_root_iter : data_root_dirs) {</a>
<a name="ln1963">      unordered_set&lt;string&gt; tablet_id_set;</a>
<a name="ln1964">      table_data_assignment_map_[table_id][data_root_iter] = tablet_id_set;</a>
<a name="ln1965">    }</a>
<a name="ln1966">  }</a>
<a name="ln1967">  // Find the data directory with the least count of tablets for this table.</a>
<a name="ln1968">  table_data_assignment_iter = table_data_assignment_map_.find(table_id);</a>
<a name="ln1969">  auto data_assignment_value_map = table_data_assignment_iter-&gt;second;</a>
<a name="ln1970">  string min_dir;</a>
<a name="ln1971">  uint64_t min_dir_count = kuint64max;</a>
<a name="ln1972">  for (auto it = data_assignment_value_map.begin(); it != data_assignment_value_map.end(); ++it) {</a>
<a name="ln1973">    if (min_dir_count &gt; it-&gt;second.size()) {</a>
<a name="ln1974">      min_dir = it-&gt;first;</a>
<a name="ln1975">      min_dir_count = it-&gt;second.size();</a>
<a name="ln1976">    }</a>
<a name="ln1977">  }</a>
<a name="ln1978">  *data_root_dir = min_dir;</a>
<a name="ln1979">  // Increment the count for min_dir.</a>
<a name="ln1980">  auto data_assignment_value_iter = table_data_assignment_map_[table_id].find(min_dir);</a>
<a name="ln1981">  data_assignment_value_iter-&gt;second.insert(tablet_id);</a>
<a name="ln1982"> </a>
<a name="ln1983">  // Find the wal directory with the least count of tablets for this table.</a>
<a name="ln1984">  min_dir = &quot;&quot;;</a>
<a name="ln1985">  min_dir_count = kuint64max;</a>
<a name="ln1986">  auto wal_root_dirs = fs_manager-&gt;GetWalRootDirs();</a>
<a name="ln1987">  CHECK(!wal_root_dirs.empty()) &lt;&lt; &quot;No wal root directories found&quot;;</a>
<a name="ln1988">  auto table_wal_assignment_iter = table_wal_assignment_map_.find(table_id);</a>
<a name="ln1989">  if (table_wal_assignment_iter == table_wal_assignment_map_.end()) {</a>
<a name="ln1990">    for (string wal_root_iter : wal_root_dirs) {</a>
<a name="ln1991">      unordered_set&lt;string&gt; tablet_id_set;</a>
<a name="ln1992">      table_wal_assignment_map_[table_id][wal_root_iter] = tablet_id_set;</a>
<a name="ln1993">    }</a>
<a name="ln1994">  }</a>
<a name="ln1995">  table_wal_assignment_iter = table_wal_assignment_map_.find(table_id);</a>
<a name="ln1996">  auto wal_assignment_value_map = table_wal_assignment_iter-&gt;second;</a>
<a name="ln1997">  for (auto it = wal_assignment_value_map.begin(); it != wal_assignment_value_map.end(); ++it) {</a>
<a name="ln1998">    if (min_dir_count &gt; it-&gt;second.size()) {</a>
<a name="ln1999">      min_dir = it-&gt;first;</a>
<a name="ln2000">      min_dir_count = it-&gt;second.size();</a>
<a name="ln2001">    }</a>
<a name="ln2002">  }</a>
<a name="ln2003">  *wal_root_dir = min_dir;</a>
<a name="ln2004">  auto wal_assignment_value_iter = table_wal_assignment_map_[table_id].find(min_dir);</a>
<a name="ln2005">  wal_assignment_value_iter-&gt;second.insert(tablet_id);</a>
<a name="ln2006">}</a>
<a name="ln2007"> </a>
<a name="ln2008">void TSTabletManager::RegisterDataAndWalDir(FsManager* fs_manager,</a>
<a name="ln2009">                                            const string&amp; table_id,</a>
<a name="ln2010">                                            const string&amp; tablet_id,</a>
<a name="ln2011">                                            const string&amp; data_root_dir,</a>
<a name="ln2012">                                            const string&amp; wal_root_dir) {</a>
<a name="ln2013">  // Skip sys catalog table from modifying the map.</a>
<a name="ln2014">  if (table_id == master::kSysCatalogTableId) {</a>
<a name="ln2015">    return;</a>
<a name="ln2016">  }</a>
<a name="ln2017">  LOG(INFO) &lt;&lt; &quot;Update data/wal directory assignment map for table: &quot;</a>
<a name="ln2018">            &lt;&lt; table_id &lt;&lt; &quot; and tablet &quot; &lt;&lt; tablet_id;</a>
<a name="ln2019">  std::lock_guard&lt;std::mutex&gt; dir_assignment_lock(dir_assignment_mutex_);</a>
<a name="ln2020">  // Initialize the map if the directory mapping does not exist.</a>
<a name="ln2021">  auto data_root_dirs = fs_manager-&gt;GetDataRootDirs();</a>
<a name="ln2022">  CHECK(!data_root_dirs.empty()) &lt;&lt; &quot;No data root directories found&quot;;</a>
<a name="ln2023">  auto table_data_assignment_iter = table_data_assignment_map_.find(table_id);</a>
<a name="ln2024">  if (table_data_assignment_iter == table_data_assignment_map_.end()) {</a>
<a name="ln2025">    for (string data_root_iter : data_root_dirs) {</a>
<a name="ln2026">      unordered_set&lt;string&gt; tablet_id_set;</a>
<a name="ln2027">      table_data_assignment_map_[table_id][data_root_iter] = tablet_id_set;</a>
<a name="ln2028">    }</a>
<a name="ln2029">  }</a>
<a name="ln2030">  // Increment the count for data_root_dir.</a>
<a name="ln2031">  table_data_assignment_iter = table_data_assignment_map_.find(table_id);</a>
<a name="ln2032">  auto data_assignment_value_map = table_data_assignment_iter-&gt;second;</a>
<a name="ln2033">  auto data_assignment_value_iter = table_data_assignment_map_[table_id].find(data_root_dir);</a>
<a name="ln2034">  if (data_assignment_value_iter == table_data_assignment_map_[table_id].end()) {</a>
<a name="ln2035">    unordered_set&lt;string&gt; tablet_id_set;</a>
<a name="ln2036">    tablet_id_set.insert(tablet_id);</a>
<a name="ln2037">    table_data_assignment_map_[table_id][data_root_dir] = tablet_id_set;</a>
<a name="ln2038">  } else {</a>
<a name="ln2039">    data_assignment_value_iter-&gt;second.insert(tablet_id);</a>
<a name="ln2040">  }</a>
<a name="ln2041"> </a>
<a name="ln2042">  auto wal_root_dirs = fs_manager-&gt;GetWalRootDirs();</a>
<a name="ln2043">  CHECK(!wal_root_dirs.empty()) &lt;&lt; &quot;No wal root directories found&quot;;</a>
<a name="ln2044">  auto table_wal_assignment_iter = table_wal_assignment_map_.find(table_id);</a>
<a name="ln2045">  if (table_wal_assignment_iter == table_wal_assignment_map_.end()) {</a>
<a name="ln2046">    for (string wal_root_iter : wal_root_dirs) {</a>
<a name="ln2047">      unordered_set&lt;string&gt; tablet_id_set;</a>
<a name="ln2048">      table_wal_assignment_map_[table_id][wal_root_iter] = tablet_id_set;</a>
<a name="ln2049">    }</a>
<a name="ln2050">  }</a>
<a name="ln2051">  // Increment the count for wal_root_dir.</a>
<a name="ln2052">  table_wal_assignment_iter = table_wal_assignment_map_.find(table_id);</a>
<a name="ln2053">  auto wal_assignment_value_map = table_wal_assignment_iter-&gt;second;</a>
<a name="ln2054">  auto wal_assignment_value_iter = table_wal_assignment_map_[table_id].find(wal_root_dir);</a>
<a name="ln2055">  if (wal_assignment_value_iter == table_wal_assignment_map_[table_id].end()) {</a>
<a name="ln2056">    unordered_set&lt;string&gt; tablet_id_set;</a>
<a name="ln2057">    tablet_id_set.insert(tablet_id);</a>
<a name="ln2058">    table_wal_assignment_map_[table_id][wal_root_dir] = tablet_id_set;</a>
<a name="ln2059">  } else {</a>
<a name="ln2060">    wal_assignment_value_iter-&gt;second.insert(tablet_id);</a>
<a name="ln2061">  }</a>
<a name="ln2062">}</a>
<a name="ln2063"> </a>
<a name="ln2064">TSTabletManager::TableDiskAssignmentMap* TSTabletManager::GetTableDiskAssignmentMapUnlocked(</a>
<a name="ln2065">    TabletDirType dir_type) {</a>
<a name="ln2066">  switch (dir_type) {</a>
<a name="ln2067">    case TabletDirType::kData:</a>
<a name="ln2068">      return &amp;table_data_assignment_map_;</a>
<a name="ln2069">    case TabletDirType::kWal:</a>
<a name="ln2070">      return &amp;table_wal_assignment_map_;</a>
<a name="ln2071">  }</a>
<a name="ln2072">  FATAL_INVALID_ENUM_VALUE(TabletDirType, dir_type);</a>
<a name="ln2073">}</a>
<a name="ln2074"> </a>
<a name="ln2075">Result&lt;const std::string&amp;&gt; TSTabletManager::GetAssignedRootDirForTablet(</a>
<a name="ln2076">    TabletDirType dir_type, const TableId&amp; table_id, const TabletId&amp; tablet_id) {</a>
<a name="ln2077">  std::lock_guard&lt;std::mutex&gt; dir_assignment_lock(dir_assignment_mutex_);</a>
<a name="ln2078"> </a>
<a name="ln2079">  TableDiskAssignmentMap* table_assignment_map = GetTableDiskAssignmentMapUnlocked(dir_type);</a>
<a name="ln2080">  auto tablets_by_root_dir = table_assignment_map-&gt;find(table_id);</a>
<a name="ln2081">  if (tablets_by_root_dir == table_assignment_map-&gt;end()) {</a>
<a name="ln2082">    return STATUS_FORMAT(</a>
<a name="ln2083">        IllegalState, &quot;Table ID $0 is not in $1 table assignment map&quot;, table_id, dir_type);</a>
<a name="ln2084">  }</a>
<a name="ln2085">  for (auto&amp; data_dir_and_tablets : tablets_by_root_dir-&gt;second) {</a>
<a name="ln2086">    if (data_dir_and_tablets.second.count(tablet_id) &gt; 0) {</a>
<a name="ln2087">      return data_dir_and_tablets.first;</a>
<a name="ln2088">    }</a>
<a name="ln2089">  }</a>
<a name="ln2090">  return STATUS_FORMAT(</a>
<a name="ln2091">      IllegalState, &quot;Tablet ID $0 is not found in $1 assignment map for table $2&quot;, tablet_id,</a>
<a name="ln2092">      dir_type, table_id);</a>
<a name="ln2093">}</a>
<a name="ln2094"> </a>
<a name="ln2095">void TSTabletManager::UnregisterDataWalDir(const string&amp; table_id,</a>
<a name="ln2096">                                           const string&amp; tablet_id,</a>
<a name="ln2097">                                           const string&amp; data_root_dir,</a>
<a name="ln2098">                                           const string&amp; wal_root_dir) {</a>
<a name="ln2099">  // Skip sys catalog table from modifying the map.</a>
<a name="ln2100">  if (table_id == master::kSysCatalogTableId) {</a>
<a name="ln2101">    return;</a>
<a name="ln2102">  }</a>
<a name="ln2103">  LOG(INFO) &lt;&lt; &quot;Unregister data/wal directory assignment map for table: &quot;</a>
<a name="ln2104">            &lt;&lt; table_id &lt;&lt; &quot; and tablet &quot; &lt;&lt; tablet_id;</a>
<a name="ln2105">  std::lock_guard&lt;std::mutex&gt; lock(dir_assignment_mutex_);</a>
<a name="ln2106">  auto table_data_assignment_iter = table_data_assignment_map_.find(table_id);</a>
<a name="ln2107">  if (table_data_assignment_iter == table_data_assignment_map_.end()) {</a>
<a name="ln2108">    // It is possible that we can't find an assignment for the table if the operations followed in</a>
<a name="ln2109">    // this order:</a>
<a name="ln2110">    // 1. The only tablet for a table gets tombstoned, and UnregisterDataWalDir removes it from</a>
<a name="ln2111">    //    the maps.</a>
<a name="ln2112">    // 2. TSTabletManager gets restarted (so the maps are cleared).</a>
<a name="ln2113">    // 3. During TsTabletManager initialization, the tombstoned TABLET won't get registered,</a>
<a name="ln2114">    //    so if a DeleteTablet request with type DELETED gets sent, UnregisterDataWalDir won't</a>
<a name="ln2115">    //    find the table.</a>
<a name="ln2116"> </a>
<a name="ln2117">    // Check that both maps should be consistent.</a>
<a name="ln2118">    DCHECK(table_wal_assignment_map_.find(table_id) == table_wal_assignment_map_.end());</a>
<a name="ln2119">  }</a>
<a name="ln2120">  if (table_data_assignment_iter != table_data_assignment_map_.end()) {</a>
<a name="ln2121">    auto data_assignment_value_iter = table_data_assignment_map_[table_id].find(data_root_dir);</a>
<a name="ln2122">    DCHECK(data_assignment_value_iter != table_data_assignment_map_[table_id].end())</a>
<a name="ln2123">      &lt;&lt; &quot;No data directory index found for table: &quot; &lt;&lt; table_id;</a>
<a name="ln2124">    if (data_assignment_value_iter != table_data_assignment_map_[table_id].end()) {</a>
<a name="ln2125">      data_assignment_value_iter-&gt;second.erase(tablet_id);</a>
<a name="ln2126">    } else {</a>
<a name="ln2127">      LOG(WARNING) &lt;&lt; &quot;Tablet &quot; &lt;&lt; tablet_id &lt;&lt; &quot; not in the set for data directory &quot;</a>
<a name="ln2128">                   &lt;&lt; data_root_dir &lt;&lt; &quot;for table &quot; &lt;&lt; table_id;</a>
<a name="ln2129">    }</a>
<a name="ln2130">  }</a>
<a name="ln2131">  auto table_wal_assignment_iter = table_wal_assignment_map_.find(table_id);</a>
<a name="ln2132">  if (table_wal_assignment_iter != table_wal_assignment_map_.end()) {</a>
<a name="ln2133">    auto wal_assignment_value_iter = table_wal_assignment_map_[table_id].find(wal_root_dir);</a>
<a name="ln2134">    DCHECK(wal_assignment_value_iter != table_wal_assignment_map_[table_id].end())</a>
<a name="ln2135">      &lt;&lt; &quot;No wal directory index found for table: &quot; &lt;&lt; table_id;</a>
<a name="ln2136">    if (wal_assignment_value_iter != table_wal_assignment_map_[table_id].end()) {</a>
<a name="ln2137">      wal_assignment_value_iter-&gt;second.erase(tablet_id);</a>
<a name="ln2138">    } else {</a>
<a name="ln2139">      LOG(WARNING) &lt;&lt; &quot;Tablet &quot; &lt;&lt; tablet_id &lt;&lt; &quot; not in the set for wal directory &quot;</a>
<a name="ln2140">                   &lt;&lt; wal_root_dir &lt;&lt; &quot;for table &quot; &lt;&lt; table_id;</a>
<a name="ln2141">    }</a>
<a name="ln2142">  }</a>
<a name="ln2143">}</a>
<a name="ln2144"> </a>
<a name="ln2145">client::YBClient&amp; TSTabletManager::client() {</a>
<a name="ln2146">  return *async_client_init_-&gt;client();</a>
<a name="ln2147">}</a>
<a name="ln2148"> </a>
<a name="ln2149">void TSTabletManager::MaybeDoChecksForTests(const TableId&amp; table_id) {</a>
<a name="ln2150">  // First check that the global RBS limits are respected if the flag is non-zero.</a>
<a name="ln2151">  if (PREDICT_FALSE(FLAGS_TEST_crash_if_remote_bootstrap_sessions_greater_than &gt; 0) &amp;&amp;</a>
<a name="ln2152">      tablets_being_remote_bootstrapped_.size() &gt;</a>
<a name="ln2153">      FLAGS_TEST_crash_if_remote_bootstrap_sessions_greater_than) {</a>
<a name="ln2154">    string tablets;</a>
<a name="ln2155">    // The purpose of limiting the number of remote bootstraps is to cap how much</a>
<a name="ln2156">    // network bandwidth all the RBS sessions use.</a>
<a name="ln2157">    // When we finish transferring the files, we wait until the role of the new peer</a>
<a name="ln2158">    // has been changed from PRE_VOTER to VOTER before we remove the tablet_id</a>
<a name="ln2159">    // from tablets_being_remote_bootstrapped_. Since it's possible to be here</a>
<a name="ln2160">    // because a few tablets are already open, and in the RUNNING state, but still</a>
<a name="ln2161">    // in the tablets_being_remote_bootstrapped_ list, we check the state of each</a>
<a name="ln2162">    // tablet before deciding if the load balancer has violated the concurrent RBS limit.</a>
<a name="ln2163">    int count = 0;</a>
<a name="ln2164">    for (const auto&amp; tablet_id : tablets_being_remote_bootstrapped_) {</a>
<a name="ln2165">      TabletPeerPtr* tablet_peer = FindOrNull(tablet_map_, tablet_id);</a>
<a name="ln2166">      if (tablet_peer &amp;&amp; (*tablet_peer)-&gt;state() == RaftGroupStatePB::RUNNING) {</a>
<a name="ln2167">        continue;</a>
<a name="ln2168">      }</a>
<a name="ln2169">      if (!tablets.empty()) {</a>
<a name="ln2170">        tablets += &quot;, &quot;;</a>
<a name="ln2171">      }</a>
<a name="ln2172">      tablets += tablet_id;</a>
<a name="ln2173">      count++;</a>
<a name="ln2174">    }</a>
<a name="ln2175">    if (count &gt; FLAGS_TEST_crash_if_remote_bootstrap_sessions_greater_than) {</a>
<a name="ln2176">      LOG(FATAL) &lt;&lt; &quot;Exceeded the specified maximum number of concurrent remote bootstrap sessions.&quot;</a>
<a name="ln2177">                 &lt;&lt; &quot; Specified: &quot; &lt;&lt; FLAGS_TEST_crash_if_remote_bootstrap_sessions_greater_than</a>
<a name="ln2178">                 &lt;&lt; &quot;, number concurrent remote bootstrap sessions: &quot;</a>
<a name="ln2179">                 &lt;&lt; tablets_being_remote_bootstrapped_.size() &lt;&lt; &quot;, for tablets: &quot; &lt;&lt; tablets;</a>
<a name="ln2180">    }</a>
<a name="ln2181">  }</a>
<a name="ln2182"> </a>
<a name="ln2183">  // Check that the per-table RBS limits are respected if the flag is non-zero.</a>
<a name="ln2184">  if (PREDICT_FALSE(FLAGS_TEST_crash_if_remote_bootstrap_sessions_per_table_greater_than &gt; 0) &amp;&amp;</a>
<a name="ln2185">      tablets_being_remote_bootstrapped_per_table_[table_id].size() &gt;</a>
<a name="ln2186">          FLAGS_TEST_crash_if_remote_bootstrap_sessions_per_table_greater_than) {</a>
<a name="ln2187">    string tablets;</a>
<a name="ln2188">    int count = 0;</a>
<a name="ln2189">    for (const auto&amp; tablet_id : tablets_being_remote_bootstrapped_per_table_[table_id]) {</a>
<a name="ln2190">      TabletPeerPtr* tablet_peer = FindOrNull(tablet_map_, tablet_id);</a>
<a name="ln2191">      if (tablet_peer &amp;&amp; (*tablet_peer)-&gt;state() == RaftGroupStatePB::RUNNING) {</a>
<a name="ln2192">        continue;</a>
<a name="ln2193">      }</a>
<a name="ln2194">      if (!tablets.empty()) {</a>
<a name="ln2195">        tablets += &quot;, &quot;;</a>
<a name="ln2196">      }</a>
<a name="ln2197">      tablets += tablet_id;</a>
<a name="ln2198">      count++;</a>
<a name="ln2199">    }</a>
<a name="ln2200">    if (count &gt; FLAGS_TEST_crash_if_remote_bootstrap_sessions_per_table_greater_than) {</a>
<a name="ln2201">      LOG(FATAL) &lt;&lt; &quot;Exceeded the specified maximum number of concurrent remote bootstrap &quot;</a>
<a name="ln2202">                 &lt;&lt; &quot;sessions per table. Specified: &quot;</a>
<a name="ln2203">                 &lt;&lt; FLAGS_TEST_crash_if_remote_bootstrap_sessions_per_table_greater_than</a>
<a name="ln2204">                 &lt;&lt; &quot;, number of concurrent remote bootstrap sessions for table &quot; &lt;&lt; table_id</a>
<a name="ln2205">                 &lt;&lt; &quot;: &quot; &lt;&lt; tablets_being_remote_bootstrapped_per_table_[table_id].size()</a>
<a name="ln2206">                 &lt;&lt; &quot;, for tablets: &quot; &lt;&lt; tablets;</a>
<a name="ln2207">    }</a>
<a name="ln2208">  }</a>
<a name="ln2209">}</a>
<a name="ln2210"> </a>
<a name="ln2211">size_t GetLogCacheSize(TabletPeer* peer) {</a>
<a name="ln2212">  return down_cast&lt;consensus::RaftConsensus*&gt;(peer-&gt;consensus())-&gt;LogCacheSize();</a>
<a name="ln2213">}</a>
<a name="ln2214"> </a>
<a name="ln2215">void TSTabletManager::LogCacheGC(MemTracker* log_cache_mem_tracker, size_t bytes_to_evict) {</a>
<a name="ln2216">  if (!FLAGS_enable_log_cache_gc) {</a>
<a name="ln2217">    return;</a>
<a name="ln2218">  }</a>
<a name="ln2219"> </a>
<a name="ln2220">  if (FLAGS_log_cache_gc_evict_only_over_allocated) {</a>
<a name="ln2221">    if (!log_cache_mem_tracker-&gt;has_limit()) {</a>
<a name="ln2222">      return;</a>
<a name="ln2223">    }</a>
<a name="ln2224">    auto limit = log_cache_mem_tracker-&gt;limit();</a>
<a name="ln2225">    auto consumption = log_cache_mem_tracker-&gt;consumption();</a>
<a name="ln2226">    if (consumption &lt;= limit) {</a>
<a name="ln2227">      return;</a>
<a name="ln2228">    }</a>
<a name="ln2229">    bytes_to_evict = std::min&lt;size_t&gt;(bytes_to_evict, consumption - limit);</a>
<a name="ln2230">  }</a>
<a name="ln2231"> </a>
<a name="ln2232">  std::vector&lt;TabletPeerPtr&gt; peers;</a>
<a name="ln2233">  {</a>
<a name="ln2234">    SharedLock&lt;RWMutex&gt; shared_lock(mutex_);</a>
<a name="ln2235">    peers.reserve(tablet_map_.size());</a>
<a name="ln2236">    for (const auto&amp; pair : tablet_map_) {</a>
<a name="ln2237">      if (GetLogCacheSize(pair.second.get()) &gt; 0) {</a>
<a name="ln2238">        peers.push_back(pair.second);</a>
<a name="ln2239">      }</a>
<a name="ln2240">    }</a>
<a name="ln2241">  }</a>
<a name="ln2242">  std::sort(peers.begin(), peers.end(), [](const auto&amp; lhs, const auto&amp; rhs) {</a>
<a name="ln2243">    // Note inverse order.</a>
<a name="ln2244">    return GetLogCacheSize(lhs.get()) &gt; GetLogCacheSize(rhs.get());</a>
<a name="ln2245">  });</a>
<a name="ln2246"> </a>
<a name="ln2247">  size_t total_evicted = 0;</a>
<a name="ln2248">  for (const auto&amp; peer : peers) {</a>
<a name="ln2249">    size_t evicted = down_cast&lt;consensus::RaftConsensus*&gt;(</a>
<a name="ln2250">        peer-&gt;consensus())-&gt;EvictLogCache(bytes_to_evict - total_evicted);</a>
<a name="ln2251">    total_evicted += evicted;</a>
<a name="ln2252">    if (total_evicted &gt;= bytes_to_evict) {</a>
<a name="ln2253">      break;</a>
<a name="ln2254">    }</a>
<a name="ln2255">  }</a>
<a name="ln2256"> </a>
<a name="ln2257">  LOG(INFO) &lt;&lt; &quot;Evicted from log cache: &quot; &lt;&lt; HumanReadableNumBytes::ToString(total_evicted)</a>
<a name="ln2258">            &lt;&lt; &quot;, required: &quot; &lt;&lt; HumanReadableNumBytes::ToString(bytes_to_evict);</a>
<a name="ln2259">}</a>
<a name="ln2260"> </a>
<a name="ln2261">Status DeleteTabletData(const RaftGroupMetadataPtr&amp; meta,</a>
<a name="ln2262">                        TabletDataState data_state,</a>
<a name="ln2263">                        const string&amp; uuid,</a>
<a name="ln2264">                        const yb::OpId&amp; last_logged_opid,</a>
<a name="ln2265">                        TSTabletManager* ts_manager) {</a>
<a name="ln2266">  const string&amp; tablet_id = meta-&gt;raft_group_id();</a>
<a name="ln2267">  const string kLogPrefix = LogPrefix(tablet_id, uuid);</a>
<a name="ln2268">  LOG(INFO) &lt;&lt; kLogPrefix &lt;&lt; &quot;Deleting tablet data with delete state &quot;</a>
<a name="ln2269">            &lt;&lt; TabletDataState_Name(data_state);</a>
<a name="ln2270">  CHECK(data_state == TABLET_DATA_DELETED ||</a>
<a name="ln2271">        data_state == TABLET_DATA_TOMBSTONED)</a>
<a name="ln2272">      &lt;&lt; &quot;Unexpected data_state to delete tablet &quot; &lt;&lt; meta-&gt;raft_group_id() &lt;&lt; &quot;: &quot;</a>
<a name="ln2273">      &lt;&lt; TabletDataState_Name(data_state) &lt;&lt; &quot; (&quot; &lt;&lt; data_state &lt;&lt; &quot;)&quot;;</a>
<a name="ln2274"> </a>
<a name="ln2275">  // Note: Passing an unset 'last_logged_opid' will retain the last_logged_opid</a>
<a name="ln2276">  // that was previously in the metadata.</a>
<a name="ln2277">  RETURN_NOT_OK(meta-&gt;DeleteTabletData(data_state, last_logged_opid));</a>
<a name="ln2278">  LOG(INFO) &lt;&lt; kLogPrefix &lt;&lt; &quot;Tablet deleted. Last logged OpId: &quot;</a>
<a name="ln2279">            &lt;&lt; meta-&gt;tombstone_last_logged_opid();</a>
<a name="ln2280">  MAYBE_FAULT(FLAGS_TEST_fault_crash_after_blocks_deleted);</a>
<a name="ln2281"> </a>
<a name="ln2282">  RETURN_NOT_OK(Log::DeleteOnDiskData(</a>
<a name="ln2283">      meta-&gt;fs_manager()-&gt;env(), meta-&gt;raft_group_id(), meta-&gt;wal_dir(),</a>
<a name="ln2284">      meta-&gt;fs_manager()-&gt;uuid()));</a>
<a name="ln2285">  MAYBE_FAULT(FLAGS_TEST_fault_crash_after_wal_deleted);</a>
<a name="ln2286"> </a>
<a name="ln2287">  // We do not delete the superblock or the consensus metadata when tombstoning</a>
<a name="ln2288">  // a tablet.</a>
<a name="ln2289">  if (data_state == TABLET_DATA_TOMBSTONED) {</a>
<a name="ln2290">    return Status::OK();</a>
<a name="ln2291">  }</a>
<a name="ln2292"> </a>
<a name="ln2293">  // Only TABLET_DATA_DELETED tablets get this far.</a>
<a name="ln2294">  RETURN_NOT_OK(ConsensusMetadata::DeleteOnDiskData(meta-&gt;fs_manager(), meta-&gt;raft_group_id()));</a>
<a name="ln2295">  MAYBE_FAULT(FLAGS_TEST_fault_crash_after_cmeta_deleted);</a>
<a name="ln2296"> </a>
<a name="ln2297">  return Status::OK();</a>
<a name="ln2298">}</a>
<a name="ln2299"> </a>
<a name="ln2300">void LogAndTombstone(const RaftGroupMetadataPtr&amp; meta,</a>
<a name="ln2301">                     const std::string&amp; msg,</a>
<a name="ln2302">                     const std::string&amp; uuid,</a>
<a name="ln2303">                     const Status&amp; s,</a>
<a name="ln2304">                     TSTabletManager* ts_manager) {</a>
<a name="ln2305">  const string&amp; tablet_id = meta-&gt;raft_group_id();</a>
<a name="ln2306">  const string kLogPrefix = LogPrefix(tablet_id, uuid);</a>
<a name="ln2307">  LOG(WARNING) &lt;&lt; kLogPrefix &lt;&lt; msg &lt;&lt; &quot;: &quot; &lt;&lt; s.ToString();</a>
<a name="ln2308"> </a>
<a name="ln2309">  // Tombstone the tablet when remote bootstrap fails.</a>
<a name="ln2310">  LOG(INFO) &lt;&lt; kLogPrefix &lt;&lt; &quot;Tombstoning tablet after failed remote bootstrap&quot;;</a>
<a name="ln2311">  Status delete_status = DeleteTabletData(meta,</a>
<a name="ln2312">                                          TABLET_DATA_TOMBSTONED,</a>
<a name="ln2313">                                          uuid,</a>
<a name="ln2314">                                          yb::OpId(),</a>
<a name="ln2315">                                          ts_manager);</a>
<a name="ln2316"> </a>
<a name="ln2317">  if (PREDICT_FALSE(FLAGS_TEST_sleep_after_tombstoning_tablet_secs &gt; 0)) {</a>
<a name="ln2318">    // We sleep here so that the test can verify that the state of the tablet is</a>
<a name="ln2319">    // TABLET_DATA_TOMBSTONED.</a>
<a name="ln2320">    LOG(INFO) &lt;&lt; &quot;Sleeping after remote bootstrap failed&quot;;</a>
<a name="ln2321">    SleepFor(MonoDelta::FromSeconds(FLAGS_TEST_sleep_after_tombstoning_tablet_secs));</a>
<a name="ln2322">  }</a>
<a name="ln2323"> </a>
<a name="ln2324">  if (PREDICT_FALSE(!delete_status.ok())) {</a>
<a name="ln2325">    // This failure should only either indicate a bug or an IO error.</a>
<a name="ln2326">    LOG(FATAL) &lt;&lt; kLogPrefix &lt;&lt; &quot;Failed to tombstone tablet after remote bootstrap: &quot;</a>
<a name="ln2327">               &lt;&lt; delete_status.ToString();</a>
<a name="ln2328">  }</a>
<a name="ln2329"> </a>
<a name="ln2330">  // Remove the child tracker if present.</a>
<a name="ln2331">  if (ts_manager != nullptr) {</a>
<a name="ln2332">    auto tracker = MemTracker::FindTracker(</a>
<a name="ln2333">        Format(&quot;tablet-$0&quot;, meta-&gt;raft_group_id()), ts_manager-&gt;server()-&gt;mem_tracker());</a>
<a name="ln2334">    if (tracker) {</a>
<a name="ln2335">      tracker-&gt;UnregisterFromParent();</a>
<a name="ln2336">    }</a>
<a name="ln2337">  }</a>
<a name="ln2338">}</a>
<a name="ln2339"> </a>
<a name="ln2340">TransitionInProgressDeleter::TransitionInProgressDeleter(</a>
<a name="ln2341">    TransitionInProgressMap* map, std::mutex* mutex, const TabletId&amp; tablet_id)</a>
<a name="ln2342">    : in_progress_(map), mutex_(mutex), tablet_id_(tablet_id) {}</a>
<a name="ln2343"> </a>
<a name="ln2344">TransitionInProgressDeleter::~TransitionInProgressDeleter() {</a>
<a name="ln2345">  std::string transition;</a>
<a name="ln2346">  {</a>
<a name="ln2347">    std::unique_lock&lt;std::mutex&gt; lock(*mutex_);</a>
<a name="ln2348">    const auto iter = in_progress_-&gt;find(tablet_id_);</a>
<a name="ln2349">    CHECK(iter != in_progress_-&gt;end());</a>
<a name="ln2350">    transition = iter-&gt;second;</a>
<a name="ln2351">    in_progress_-&gt;erase(iter);</a>
<a name="ln2352">  }</a>
<a name="ln2353">  LOG(INFO) &lt;&lt; &quot;Deleted transition in progress &quot; &lt;&lt; transition</a>
<a name="ln2354">            &lt;&lt; &quot; for tablet &quot; &lt;&lt; tablet_id_;</a>
<a name="ln2355">}</a>
<a name="ln2356"> </a>
<a name="ln2357">Status ShutdownAndTombstoneTabletPeerNotOk(</a>
<a name="ln2358">    const Status&amp; status, const tablet::TabletPeerPtr&amp; tablet_peer,</a>
<a name="ln2359">    const tablet::RaftGroupMetadataPtr&amp; meta, const std::string&amp; uuid, const char* msg,</a>
<a name="ln2360">    TSTabletManager* ts_tablet_manager) {</a>
<a name="ln2361">  if (status.ok()) {</a>
<a name="ln2362">    return status;</a>
<a name="ln2363">  }</a>
<a name="ln2364">  // If shutdown was initiated by someone else we should not wait for shutdown to complete.</a>
<a name="ln2365">  if (tablet_peer &amp;&amp; tablet_peer-&gt;StartShutdown()) {</a>
<a name="ln2366">    tablet_peer-&gt;CompleteShutdown();</a>
<a name="ln2367">  }</a>
<a name="ln2368">  tserver::LogAndTombstone(meta, msg, uuid, status, ts_tablet_manager);</a>
<a name="ln2369">  return status;</a>
<a name="ln2370">}</a>
<a name="ln2371"> </a>
<a name="ln2372">} // namespace tserver</a>
<a name="ln2373">} // namespace yb</a>

</code></pre>
<div class="balloon" rel="410"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="421"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="425"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="429"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="434"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="443"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="454"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="481"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="705"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="709"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="998"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v796/" target="_blank">V796</a> It is possible that 'break' statement is missing in switch statement.</p></div>
<div class="balloon" rel="1349"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1470"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1474"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1495"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v593/" target="_blank">V593</a> Consider reviewing the expression of the 'A = B > C' kind. The expression is calculated as following: 'A = (B > C)'.</p></div>
<div class="balloon" rel="1779"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1790"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1833"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1901"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1919"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1959"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="1987"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="2022"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="2043"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="2118"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="2122"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="2134"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="2270"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>
<div class="balloon" rel="2349"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v521/" target="_blank">V521</a> Such expressions using the ',' operator are dangerous. Make sure the expression is correct.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
